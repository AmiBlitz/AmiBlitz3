; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Sys:Programme/AIDE/Types/AmiBlitz3"
; ExeFile         = "AB3Scan"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 521
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = "sourcecodes:ab3test.ab3 -v 1"
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 8
; CursorColumn    = 33
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 1
; Max GadgetList  = 1
; Max Queue       = 1
; Max Screen      = 2
; Max Shape       = 1
; Max CopList     = 1
; Max Sprite      = 1
; Max Stencil     = 1
; Max Module      = 1
; Max Window      = 30
; Max Anim        = 1
; Max Sound       = 1
; Max Bank        = 1
; Max Buffer      = 1
; Max BitMap      = 1
; Max Slice       = 1
; Max Page        = 1
; Max Tape        = 1
; Max IntuiFont   = 12
; Max MedModule   = 1
; Max Palette     = 1
; Max MenuList    = 1
; Max BlitzFont   = 1
; Max GTList      = 30
; /XTRA
Syntax 6
optimize 7

XINCLUDE "file.include.ab3"
XINCLUDE "dos.include.ab3"
XINCLUDE "strptr.include.ab3"
XINCLUDE "prefixtree.include.ab3"

error_SetFlags{#error_stdout}

#AB3H_NONE   = 0
#AB3H_SEARCH = 1
#AB3H_FOUND  = 2
#AB3H_DONE   = 3

#VB_NONE  = 0
#VB_INFO  = 1
#VB_DEBUG = 2

vers.s = Peek.s(?version)
#DF_FUNCTION     = $0001
#DF_MACRO        = $0002
#DF_LABEL        = $0004
#DF_SOURCE       = $0008
#DF_NEWTYPE      = $0010
#DF_FIELD        = $0020
#DF_CONSTANT     = $0040
#DF_GLOBAL       = $0080
#DF_INCLUDE      = $0100
#DF_STRING       = $0200
#DF_LOCAL        = $0400
#DF_ALL          = $FFFF

#AB3TF_IS        = $0001 ;/* is part of token */
#AB3TF_EOL       = $0002 ;/* end of line */
#AB3TF_NEW       = $0004 ;/* starts a possibly new token */
#AB3TF_STOP      = $0008 ;/* stops a token */
#AB3TF_QUOT      = $0010 ;/* start/end quoting */
#AB3TF_COMMENT   = $0020 ;/* comment */
#AB3TF_COPY      = $0040 ;/* copy over to destination */
#AB3TF_FIRST     = $0080 ;/* can serve as first char in token */
#AB3TF_HEX       = $0100
#AB3TF_BIN       = $0200
#AB3TF_DEC       = $0400
#AB3TF_SPACE     = $0800
#AB3TF_ILLEGAL   = $1000
#AB3TF_2BYTETOKEN= $2000

; Tokens IDs
#TOKEN_End       = $8002
#TOKEN_Return    = $8007
#TOKEN_Statement = $8008
#TOKEN_Function  = $8009
#TOKEN_If        = $800B
#TOKEN_While     = $800C
#TOKEN_Macro     = $800D
#TOKEN_Select    = $800E
#TOKEN_Case      = $800F
#TOKEN_For       = $8016
#TOKEN_Then      = $8021
#TOKEN_Stop      = $802D
#TOKEN_TRAP      = $80AE
#TOKEN_Repeat    = $80BB
#TOKEN_EndIf     = $80C0
#TOKEN_Object    = $80D7
#TOKEN_NEWTYPE   = $8001
#TOKEN_INCLUDE   = $8013
#TOKEN_XINCLUDE  = $8012
#TOKEN_SHARED    = $8015
#TOKEN_DEFTYPE   = $8033
#TOKEN_SizeOf    = $802F
#TOKEN_Peek      = $8002 ; 180/2
#TOKEN_Poke      = $8001 ; 180/1

NEWTYPE.AmiBlitz3

  CharFlags.w[256]    ; character flags

End NEWTYPE


NEWTYPE.Parser

  ; current file
  *filename.str
  *path.str
  tokenized.l
  ab3header.l

  ; current line
  first.l
  bptr.l
  clength.l
  linecount.l

  ; global settings
  recursive.l
  *pattern.str
  *filesT.prefixtree
  verbose.l
  dflags.l
  in_newtype.l
  in_function.l
  in_macro.l
  *incpath.str

End NEWTYPE

SHARED AmiBlitz3.AmiBlitz3


Function.s GetDosFileName{filename.s}

  MaxLen buff.s = 1024
  
  lock.l = Lock_(&filename,#ACCESS_READ);
  If lock
    NameFromLock_ lock,&buff,1023
    filename = Peek.s(&buff)
    UnLock_ lock : lock=0
  End If
  
  Function Return filename
  
End Function


Function.l FAST _ab3_ParseComment{*parser.Parser,cpos.l}

  If cpos<2

  If *parser\ab3header=#AB3H_FOUND
    While cpos<*parser\clength-4
      If Peek.b(*parser\bptr+cpos)=@"/"
        cpos+1
        If Peek.b(*parser\bptr+cpos)=@"X"
          cpos+1
          If Peek.b(*parser\bptr+cpos)=@"T"
            cpos+1
            If Peek.b(*parser\bptr+cpos)=@"R"
              cpos+1
              If Peek.b(*parser\bptr+cpos)=@"A"
                *parser\linecount=0
                *parser\ab3header = #AB3H_DONE
              End If
            End If
          End If
        End If
      End If
      cpos+1
    Wend
  End If

  If *parser\ab3header=#AB3H_SEARCH
    While cpos<*parser\clength-3
      If Peek.b(*parser\bptr+cpos)=@"X"
        cpos+1
        If Peek.b(*parser\bptr+cpos)=@"T"
          cpos+1
          If Peek.b(*parser\bptr+cpos)=@"R"
            cpos+1
            If Peek.b(*parser\bptr+cpos)=@"A"
              *parser\ab3header = #AB3H_FOUND
            End If
          End If
        End If
      End If
      cpos+1
    Wend
  End If
  End If

  Function Return *parser\clength; just skip to end of line

End Function


Function.l FAST _ab3_SkipTill{*parser.Parser,cpos.l,char.b}

  While cpos<*parser\clength
    c.b = Peek.b(*parser\bptr+cpos)
    If c=char Then Function Return cpos
    cpos+1
  Wend
  Function Return cpos

End Function


Function.l _ab3_ParseString{*parser.Parser,cpos.l}

  bpos.l = cpos-1 : If bpos<0 Then bpos=0
  While cpos<*parser\clength
    c.w = Peek.b(*parser\bptr+cpos)&$FF : cpos+1
    If AmiBlitz3\CharFlags[c]&#AB3TF_QUOT
    
        If *parser\dflags&(#DF_STRING)><0
          string.s = Peeks$(*parser\bptr+bpos,cpos-bpos)
          NPrint "STRING\\09",*parser\linecount,"\\09",string
        End If    
    
      Function Return cpos
    End If
  Wend
  Function Return cpos

End Function


Function.l FAST _ab3_SkipWhiteSpaces{*parser.Parser,cpos.l}

  While cpos<*parser\clength AND AmiBlitz3\CharFlags[Peek.b(*parser\bptr + cpos)&$FF]&#AB3TF_SPACE : cpos+1 : Wend
  Function Return cpos

End Function


Function.l FAST _ab3_SkipToken{*parser.Parser,cpos.l}

  cf.l = 0
  While (cf&#AB3TF_STOP)=0 AND cpos<*parser\clength
    cpos+1 : If cpos>=*parser\clength Then Function Return cpos
    cf.l = AmiBlitz3\CharFlags[Peek.b(*parser\bptr + cpos)&$FF]
  Wend
  Function Return cpos

End Function


Function.l _ab3_ParseNewtype{*parser.Parser,cpos.l}

  *parser\in_newtype=False
  If *parser\first><False AND *parser\dflags&(#DF_NEWTYPE|#DF_FIELD)><0
    If *parser\verbose>=#VB_DEBUG Then NPrint "DEBUG Parse Newtype..."
    name.s     = ""
    comment.s  = ""
    cpos = _ab3_SkipWhiteSpaces{*parser,cpos}
    c.b = Peek.b(*parser\bptr + cpos)
    If c = @"."
      opos.l = cpos+1
      cpos.l = _ab3_SkipToken{*parser,cpos}
      name.s = Peeks$(*parser\bptr+opos,cpos-opos)
    
      cpos = _ab3_SkipTill{*parser,cpos,@";"}
      If cpos<*parser\clength Then cpos = _ab3_SkipWhiteSpaces{*parser,cpos+1}
      If cpos<*parser\clength
        comment = Peeks$(*parser\bptr+cpos,*parser\clength-cpos)
        cpos = *parser\clength
      End If
      If name
        If *parser\dflags&(#DF_NEWTYPE)><0
          NPrint "NEWTYPE\\09",*parser\linecount,"\\09",name,"\\09",comment
        End If
        If *parser\dflags&(#DF_FIELD)><0
          *parser\in_newtype = True
        End If
      Else
        If *parser\verbose>=#VB_INFO Then NPrint "ERROR Newtype, unable to find name???"
      End If
    Else
      If *parser\verbose>=#VB_INFO Then NPrint "ERROR Newtype, but no . following???"
    End If
  End If
  
  Function Return cpos
  
End Function


Function.l ab3_GetIncludeLock{filename.s}
  incLock.l  = Lock_ (&filename,#ACCESS_READ)   ; try bla.blub
  ex.s       = dos_GetExt{filename}
;
  If incLock = False
    filename = dos_SetExt{filename,"ab3"}
    incLock  = Lock_ (&filename,#ACCESS_READ)   ; try bla.ab3
  End If
;
  If incLock = False
    filename = dos_SetExt{filename,"ab2"}
    incLock  = Lock_ (&filename,#ACCESS_READ)   ; try bla.ab2
  End If

  If incLock = False
    filename = dos_SetExt{filename,"bb2"}
    incLock  = Lock_ (&filename,#ACCESS_READ)   ; try bla.bb2
  End If

  If incLock = False
    filename = dos_SetExt{filename,ex+".ab3"}
    incLock  = Lock_ (&filename,#ACCESS_READ)   ; try bla.blub.ab3
  End If
;
  If incLock = False
    filename = dos_SetExt{filename,"ab2"}
    incLock  = Lock_ (&filename,#ACCESS_READ)   ; try bla.blub.ab2
  End If
;
  If incLock = False
    filename = dos_SetExt{filename,"bb2"}
    incLock  = Lock_ (&filename,#ACCESS_READ)   ; try bla.blub.bb2
  End If
;
  Function Return incLock
End Function


Function.l _ab3_ParseInclude{*parser.Parser,cpos.l}

  If *parser\first><False AND str_Len{*parser\incpath}>0
    If *parser\verbose>=#VB_DEBUG Then NPrint "DEBUG Parse Include..."
    name.s     = ""
    comment.s  = ""
    cpos = _ab3_SkipWhiteSpaces{*parser,cpos}
    c.w = Peek.b(*parser\bptr + cpos) : cpos+1
    If c<0 Then Function Return cpos-1
     
    If c = $22
      opos.l = cpos-1
      cpos = _ab3_SkipTill{*parser,cpos,$22}
      If cpos<*parser\clength
    
      cpos.l = _ab3_SkipToken{*parser,cpos}
      name.s = Peeks$(*parser\bptr+opos,cpos-opos)
    
      cpos = _ab3_SkipTill{*parser,cpos,@";"}
      If cpos<*parser\clength Then cpos = _ab3_SkipWhiteSpaces{*parser,cpos+1}
      If cpos<*parser\clength
        comment = Peeks$(*parser\bptr+cpos,*parser\clength-cpos)
      End If
      If name
        name = Replace$(name,"\\22","")
        ;NPrint "INC: ",name
        filename.s = dos_AddPart{str_Read{&*parser\path},name}
        lock.l = ab3_GetIncludeLock{filename}
        If lock=0
          filename.s = dos_AddPart{str_Read{&*parser\incpath},name}
          lock.l = ab3_GetIncludeLock{filename}
        End If
        If lock
          MaxLen dosname.s = 1024
          NameFromLock_ lock,&dosname,1023
          UnLock_ lock : lock=0
          dosname.s = Peek.s(&dosname) ; GetDosFileName{filename}
          If pft_FindItem{*parser\filesT,dosname}=""
            pft_AddItem{*parser\filesT,dosname,"todo"}
          End If
          If *parser\dflags&#DF_INCLUDE
            NPrint "INCLUDE\\09",*parser\linecount,"\\09",dosname,"\\09",comment
          EndIf
        Else
          If *parser\verbose>=#VB_INFO Then NPrint "ERROR Unable to find include: \\22",filename,"\\22"
        End If
        
      End If
      End If
    End If
  End If
  Function Return cpos
  
End Function


Function.l _ab3_ParseMacro{*parser.Parser,cpos.l}

  If *parser\first><False AND *parser\dflags&#DF_MACRO><0
    If *parser\verbose>=#VB_DEBUG Then NPrint "DEBUG Parse Macro..."
    name.s     = ""
    comment.s  = ""
    cpos = _ab3_SkipWhiteSpaces{*parser,cpos}
    opos.l = cpos
    cpos.l = _ab3_SkipToken{*parser,cpos}
    name.s = Peeks$(*parser\bptr+opos,cpos-opos)
    
    cpos = _ab3_SkipTill{*parser,cpos,@";"}
    If cpos<*parser\clength Then cpos = _ab3_SkipWhiteSpaces{*parser,cpos+1}
    If cpos<*parser\clength
      comment = Peeks$(*parser\bptr+cpos,*parser\clength-cpos)
    End If
    If name
      NPrint "MACRO\\09",*parser\linecount,"\\09",name,"\\09",comment
    End If
  End If
  
  Function Return cpos
  
End Function


Function.l _ab3_ParseConstant{*parser.Parser,cpos.l}

  If *parser\first><False AND *parser\dflags&#DF_CONSTANT><0
    If *parser\verbose>=#VB_DEBUG Then NPrint "DEBUG Parse Constant..."
    name.s     = ""
    value.s    = ""
    comment.s  = ""
    cpos = _ab3_SkipWhiteSpaces{*parser,cpos}
    opos.l = cpos
    cpos.l = _ab3_SkipToken{*parser,cpos}
    name.s = Peeks$(*parser\bptr+opos,cpos-opos)
    cpos = _ab3_SkipWhiteSpaces{*parser,cpos}
    c.w = Peek.b(*parser\bptr + cpos) : cpos+1
    If c><@"=" Then Function Return cpos-1
    cpos = _ab3_SkipWhiteSpaces{*parser,cpos}
    opos.l = cpos
    cpos = _ab3_SkipTill{*parser,cpos,@":"}
    If cpos>=*parser\clength Then cpos = _ab3_SkipTill{*parser,opos,@";"}
    If opos>0 Then While cpos>opos AND Peek.b(*parser\bptr + cpos-1)=@" ":cpos-1:Wend
    value.s = Peeks$(*parser\bptr+opos,cpos-opos)

    cpos = _ab3_SkipTill{*parser,cpos,@";"}
    If cpos<*parser\clength 
      cpos = _ab3_SkipWhiteSpaces{*parser,cpos+1}
      If cpos<*parser\clength
        comment = Peeks$(*parser\bptr+cpos,*parser\clength-cpos)
      End If
    End If
    If name
      NPrint "CONSTANT\\09",*parser\linecount,"\\09",name,"\\09",value,"\\09",comment
    End If
  End If
  Function Return cpos
  
End Function

Function.l _ab3_ParseEnd{*parser.Parser,cpos.l}

  If *parser\verbose>=#VB_DEBUG Then NPrint "DEBUG Parse End... F:",*parser\in_function," NT:",*parser\in_newtype
  cpos = _ab3_SkipWhiteSpaces{*parser,cpos}
  c.w = Peek.b(*parser\bptr + cpos) 
  If c<0
    tokenid.l = Peek.w(*parser\bptr+cpos)&$FFFF : cpos+2
    Select tokenid
      Case #TOKEN_Function  : *parser\in_function = False
      Case #TOKEN_Statement : *parser\in_function = False
      Case #TOKEN_NEWTYPE   : *parser\in_newtype  = False
      Case #TOKEN_Macro     : *parser\in_macro    = False
    End Select
    If *parser\verbose>=#VB_DEBUG Then NPrint "DEBUG End: ",Hex$(tokenid)
    
  Else
    opos.l = cpos
    cpos.l = _ab3_SkipToken{*parser,cpos}
    token.s = Peeks$(*parser\bptr+opos,cpos-opos)
    If *parser\verbose>=#VB_DEBUG Then NPrint "DEBUG End: ",token

    Select token
      Case "Function"  : *parser\in_function = False
      Case "Statement" : *parser\in_function = False
      Case "NEWTYPE"   : *parser\in_newtype  = False
      Case "Macro"     : *parser\in_macro    = False
    End Select
  End If
  If *parser\verbose>=#VB_DEBUG Then NPrint "DEBUG Parse ===... F:",*parser\in_function," NT:",*parser\in_newtype

  Function Return cpos
End Function

Function.l _ab3_ParseFunction{*parser.Parser,cpos.l}

    If *parser\first><False AND *parser\dflags&#DF_FUNCTION><0
    If *parser\verbose>=#VB_DEBUG Then NPrint "DEBUG Parse Function..."
    typ.s      = ""
    name.s     = ""
    modifier.s = ""
    track.s    = ""
    comment.s  = ""
    cpos = _ab3_SkipWhiteSpaces{*parser,cpos}
    c.w = Peek.b(*parser\bptr + cpos) : cpos+1
    If c<0 Then Function Return cpos-1
      
    If c = @"."
      opos.l = cpos
      cpos.l = _ab3_SkipToken{*parser,cpos}
      typ.s = Peeks$(*parser\bptr+opos,cpos-opos)
      cpos = _ab3_SkipWhiteSpaces{*parser,cpos}
      c.w = Peek.b(*parser\bptr + cpos) : cpos+1
    End If
    opos.l = cpos-1
    cpos.l = _ab3_SkipToken{*parser,cpos}
    name.s = Peeks$(*parser\bptr+opos,cpos-opos)
    If name="FAST"
      modifier=name
      opos.l = _ab3_SkipWhiteSpaces{*parser,cpos}
      cpos.l = _ab3_SkipToken{*parser,opos}
      name.s = Peeks$(*parser\bptr+opos,cpos-opos)
    End If
    cpos.l = _ab3_SkipWhiteSpaces{*parser,cpos}
    c.w = Peek.b(*parser\bptr + cpos) : cpos+1
    If c><@"{" Then Function Return cpos-1
    opos = cpos
    cpos = _ab3_SkipTill{*parser,cpos,@"}"}
    If cpos<*parser\clength
      If name
        track.s = Peeks$(*parser\bptr+opos,cpos-opos)
        track=Replace$(track," ","")
        track=Replace$(track,"\\09","")
        comment=Replace$(comment,"\\09"," ")
        NPrint "FUNCTION\\09",*parser\linecount,"\\09",name,"\\09",typ,"\\09",track,"\\09",comment
        *parser\in_function = True
        If *parser\dflags&#DF_LOCAL><0
          kpos.l=0
          Repeat
            opos.l = kpos+1
            kpos.l = Instr(track,",",opos)
            If kpos=0 Then kpos=FLen(track)+1
            If kpos>opos
              ppos.l = Instr(track,".",opos+1)
              If ppos>0 AND ppos<kpos-1
                name.s = Mid$(track,opos,ppos-opos)
                typ.s  = Mid$(track,ppos+1,kpos-ppos-1)
                ;NPrint "LOCAL\\09",*parser\linecount,"\\09",name,"\\09",typ
                NPrint "PARAM\\09",*parser\linecount,"\\09",name,"\\09",typ
              End If
            End If
          Until kpos<=opos
        End If
      End If
    End If
  End If
  
  Function Return cpos
            
End Function


Function.l _ab3_ParseToken{*parser.Parser,cpos.l}

  opos.l  = cpos-1
  cpos    = _ab3_SkipToken{*parser,opos}
  token.s = Peeks$(*parser\bptr+opos,cpos-opos)
  tokenid.w = 0
  If *parser\verbose>=#VB_DEBUG Then NPrint "DEBUG Parse Text Token (=",token,")"

  Select token
    Case "Function"  : tokenid = #TOKEN_Function
    Case "Statement" : tokenid = #TOKEN_Statement
    Case "NEWTYPE"   : tokenid = #TOKEN_NEWTYPE
    Case "Macro"     : tokenid = #TOKEN_Macro
    Case "End"       : tokenid = #TOKEN_End
    Case "XINCLUDE"  : tokenid = #TOKEN_XINCLUDE
    Case "INCLUDE"   : tokenid = #TOKEN_INCLUDE
    Case "SHARED"    : tokenid = #TOKEN_SHARED
    Case "DEFTYPE"   : tokenid = #TOKEN_DEFTYPE
    Case "If"        : tokenid = #TOKEN_If
    Case "SizeOf"    : tokenid = #TOKEN_SizeOf
    Case "Peek"      : tokenid = #TOKEN_Peek
    Case "Poke"      : tokenid = #TOKEN_Poke
    Default
     If *parser\in_newtype
       If opos>0
         c.w = Peek.b(*parser\bptr + opos-1)
         If c=@"*" Then token="*"+token
       End If

       cpos.l = _ab3_SkipWhiteSpaces{*parser,cpos}
       c.w = Peek.b(*parser\bptr + cpos) : cpos+1
       typ.s = ""
       If c=@"."
         opos.l = cpos
         cpos.l = _ab3_SkipToken{*parser,cpos}
         typ.s = Peeks$(*parser\bptr+opos,cpos-opos)
       End If
       NPrint "FIELD\\09",*parser\linecount,"\\09",token,"\\09",typ
     Else
       c.w = Peek.b(*parser\bptr + cpos) : cpos+1
       typ.s = ""
       If c=@"."
         opos.l = cpos
         cpos.l = _ab3_SkipToken{*parser,cpos}
         typ.s = Peeks$(*parser\bptr+opos,cpos-opos)
       
         If typ><""
           If *parser\in_function ; todo: doenst recognize shared
             If *parser\dflags&#DF_LOCAL><0
               NPrint "LOCAL\\09",*parser\linecount,"\\09",token,"\\09",typ
             End If
           Else
             If *parser\dflags&#DF_GLOBAL><0
               NPrint "GLOBAL\\09",*parser\linecount,"\\09",token,"\\09",typ
             End If  
           End If
         End If
       Else
         ; token has not type attached
       End If
     End If
     Function Return cpos
  End Select

  Select tokenid
    Case #TOKEN_Function  : cpos = _ab3_ParseFunction{*parser,cpos}      
    Case #TOKEN_Statement : cpos = _ab3_ParseFunction{*parser,cpos}      
    Case #TOKEN_Macro     : cpos = _ab3_ParseMacro   {*parser,cpos}      
    Case #TOKEN_NEWTYPE   : cpos = _ab3_ParseNewtype {*parser,cpos}      
    Case #TOKEN_XINCLUDE  : cpos = _ab3_ParseInclude {*parser,cpos}
    Case #TOKEN_INCLUDE   : cpos = _ab3_ParseInclude {*parser,cpos}
    Case #TOKEN_End       : cpos = _ab3_ParseEnd     {*parser,cpos}
  End Select

  Function Return cpos

End Function


Function.l _ab3_Parse2ByteToken{*parser.Parser,cpos.l}

  tokenid.w = Peek.w(*parser\bptr+cpos-1) : cpos +1
  If *parser\verbose>=#VB_DEBUG Then NPrint "DEBUG Parse 2Byte Token ($",Right$(Hex$(tokenid),4),")"
  
  Select tokenid
    Case #TOKEN_Function  : cpos = _ab3_ParseFunction{*parser,cpos}      
    Case #TOKEN_Statement : cpos = _ab3_ParseFunction{*parser,cpos}      
    Case #TOKEN_Macro     : cpos = _ab3_ParseMacro   {*parser,cpos}      
    Case #TOKEN_NEWTYPE   : cpos = _ab3_ParseNewtype {*parser,cpos}
    Case #TOKEN_XINCLUDE  : cpos = _ab3_ParseInclude {*parser,cpos}
    Case #TOKEN_INCLUDE   : cpos = _ab3_ParseInclude {*parser,cpos}
    Case #TOKEN_End       : cpos = _ab3_ParseEnd     {*parser,cpos}
  End Select
  Function Return cpos
  
End Function


Function.l FAST _ab3_SkipBinary{*parser.Parser,cpos.l}

  cf.l = 0

  Repeat
    cpos+1 : If cpos>=*parser\clength Then Function Return cpos
    cf.l = AmiBlitz3\CharFlags[Peek.b(*parser\bptr + cpos)&$FF]
    If (cf&#AB3TF_BIN)=0 Then Function Return cpos-1
  Until cpos>=*parser\clength

  Function Return cpos

End Function


Function.l FAST _ab3_SkipHex{*parser.Parser,cpos.l}

  Repeat
    If cpos<*parser\clength
      cf.l = AmiBlitz3\CharFlags[Peek.b(*parser\bptr + cpos)&$FF]
    Else
      cf = 0
    End If
    cpos+1
  Until (cf&#AB3TF_HEX)=0 OR cpos>=*parser\clength

  Function Return cpos-1

End Function


Function.l FAST _ab3_ParseNumber{*parser.Parser,cpos.l}

  Repeat
    If cpos<*parser\clength
      cf.l = AmiBlitz3\CharFlags[Peek.b(*parser\bptr + cpos)&$FF]
    Else
      cf = 0
    End If
    cpos+1
  Until (cf&#AB3TF_DEC)=0 OR cpos>=*parser\clength

  If (Peek.b(*parser\bptr + cpos-1)=@".") ; has a decimal point
    Repeat
      If cpos<*parser\clength
        cf.l = AmiBlitz3\CharFlags[Peek.b(*parser\bptr + cpos)&$FF]
      Else
        cf = 0
      End If
      cpos+1
    Until (cf&#AB3TF_DEC)=0 OR cpos>=*parser\clength
  End If

  cpos-1
  Function Return cpos

End Function


Function.l ab3_ParseLine{*parser.Parser,cpos.l}

  While cpos<*parser\clength
    c.b = Peek.b(*parser\bptr+cpos) : cpos+1
    cf.l = AmiBlitz3\CharFlags[c&$FF]

    If (cf&#AB3TF_COMMENT   ) Then cpos = _ab3_ParseComment   {*parser,cpos} : cf = 0 : c=0 : *parser\first=False
    If (cf&#AB3TF_QUOT      ) Then cpos = _ab3_ParseString    {*parser,cpos} : cf = 0 : c=0 : *parser\first=False
    If (cf&#AB3TF_FIRST     ) Then cpos = _ab3_ParseToken     {*parser,cpos} : cf = 0 : c=0 : *parser\first=False
    If (cf&#AB3TF_DEC       ) Then cpos = _ab3_ParseNumber    {*parser,cpos} : cf = 0 : c=0 : *parser\first=False
    If (cf&#AB3TF_2BYTETOKEN) Then cpos = _ab3_Parse2ByteToken{*parser,cpos} : cf = 0 : c=0 : *parser\first=False

    Select c
      Case @":" : *parser\first=True
      Case @"#"
        Select Peek.b(*parser\bptr+cpos)
          Case $22
            cpos = _ab3_ParseString{*parser,cpos+1}
          Default
            If *parser\first><False AND *parser\dflags&#DF_CONSTANT><0
              cpos = _ab3_ParseConstant{*parser,cpos}
            Else
              cpos = _ab3_SkipToken{*parser,cpos}
            End If              
        End Select
        *parser\first=False

      Case @"!" ; its a macro reference
        cpos = _ab3_SkipToken{*parser,cpos}
        *parser\first=False

      Case @"."
        If *parser\first><False AND *parser\dflags&#DF_LABEL><0
          opos.l = cpos
          cpos = _ab3_SkipToken{*parser,cpos}
          NPrint "LABEL\\09",*parser\linecount,"\\09",Peeks$(*parser\bptr+opos,cpos-opos)
        Else
          ; its a type reference
          cpos = _ab3_SkipToken{*parser,cpos}
        End If
        *parser\first=False
        
      Case @"\" ; its a member reference
        cpos = _ab3_SkipToken{*parser,cpos}
        *parser\first=False

      Case @"%"
        cpos = _ab3_SkipBinary{*parser,cpos}
        *parser\first=False

      Case @"$"
        cpos = _ab3_SkipHex{*parser,cpos}
        *parser\first=False

      Case @"@"
        Select Peek.b(*parser\bptr+cpos)
          Case @"@" ; its @@
            cpos+1
            If cpos<*parser\clength ; remaining chars
              cpos=*parser\clength
            End If
          Case $22 ; its @"ILBM"
            cpos = _ab3_ParseString{*parser,cpos+1}
          Case @"#" ; its @#constant
            ; its an implicit constant definition
            cpos = _ab3_SkipToken{*parser,cpos}
          Default
            ; wtf!?
            cpos = _ab3_SkipToken{*parser,cpos}

        End Select
        *parser\first=False
      Default
        ; hm, could only be space
    End Select

  Wend
  Function Return cpos
  
End Function


Function.Parser ab3_CreateParser{incpath.s,pattern.s,recursive.l,dflags.l,verbose.l}

  *parser.Parser = AllocVec_(SizeOf.Parser,#MEMF_ANY)
  If *parser
    ; current file
    *parser\filename   = Null
    *parser\path       = Null
    *parser\tokenized  = False
    *parser\ab3header  = #AB3H_NONE

    ; current line
    *parser\first      = True
    *parser\bptr       = Null
    *parser\clength    = 0

    ; global settings
    *parser\recursive   = recursive
    *parser\pattern     = Null
    *parser\incpath     = Null
    *parser\filesT      = pft_Create{4096}
    *parser\verbose     = verbose
    *parser\dflags      = dflags
    *parser\in_newtype  = False
    *parser\in_function = False
    *parser\in_macro    = False
    
    tempbuf.s = LSet$(" ",FLen(pattern)*3+4)
    ParsePatternNoCase_ &pattern,&tempbuf,FLen(tempbuf)
    str_WritePtr{&*parser\pattern,&tempbuf}
    str_Write{&*parser\incpath,incpath}
   ; NPrint "Incpath : ",str_Read{&*parser\incpath}," len = ",str_Len{*parser\incpath}
  End If
  
  Function Return *parser
  
End Function


Statement ab3_FreeParser{*parser.Parser}
  
  str_Free{&*parser\filename}
  str_Free{&*parser\path}
  str_Free{&*parser\incpath}
  str_Free{&*parser\pattern}
  pft_Free{*parser\filesT} : *parser\filesT = Null

End Statement

Function.s file_ReadAB3Line {fid.l}

  dummy.l = 0
  dummy2.l = 0
  maxc.l = 1024
  a.s = ""
  While dummy>=0
    If file_EOF{fid}
      dummy=-1
    Else
      dummy=0
      If file_ReadMem {fid,&dummy+3,1} = False Then dummy=-1
      If dummy=$00 OR dummy=$0a OR FLen(a)>maxc Then dummy=-1
    End If

    If dummy>=0
      a.s + Chr$(dummy)
    End If
  Wend
  Function Return a.s
  
End Function


Function.l ab3_Parse{*parser.Parser,filename.s}

  dosname.s = GetDosFileName{filename}
  
  done.s = pft_FindItem{*parser\filesT,dosname}
  If done="done" Then Function Return False

  pft_AddItem{*parser\filesT,dosname,"done"}
  str_Write{&*parser\path,dos_PathPart{dosname}}
  str_Write{&*parser\filename,dosname}

  fid.l = file_Open{filename,#file_read}
  If fid<0 Then Function Return False

  *parser\tokenized = False
  *parser\linecount = 0
  Select LCase$(dos_GetExt{filename})
    Case "ab3" : *parser\ab3header  = #AB3H_SEARCH
    Case "bb2" : *parser\tokenized=True
    Case "bb"  : *parser\tokenized=True
    Default:     *parser\tokenized=False
  End Select
  
  If *parser\dflags&#DF_SOURCE><0
    NPrint "SOURCE\\09",dosname
  EndIf

  Repeat
    code.s = file_ReadAB3Line{fid}
    *parser\linecount+1
    ;NPrint "line: ",*parser\linecount,"::",code
  
    *parser\bptr    = &code ; base pointer
    *parser\clength = FLen(code) ; length
    *parser\first   = True
    ab3_ParseLine{*parser,0}

  Until file_EOF{fid}
  file_Close{fid}
  
  Function Return True
  
End Function


Function.l ab3_Scan{*parser.Parser,path.s}

  DEFTYPE.FileInfoBlock fib
  If *parser\verbose>1 Then NPrint "INFO Scan ",path
  lock.l = Lock_(&path,#ACCESS_READ)
  If lock
    If Examine_ (lock,&fib)
      While ExNext_(lock,&fib)><0
        If SetSignal_(0,0)&#SIGBREAKF_CTRL_C Then UnLock_ lock : Function Return False
        
        filename.s = dos_AddPart{path,Peek.s(&fib\fib_FileName)}
        If fib\fib_DirEntryType<0
          If MatchPatternNoCase_ (&*parser\pattern\str,&fib\fib_FileName)><0 
            ; parse file...
            ab3_Parse{*parser,filename}
          End If
        Else
          If *parser\recursive
            If ab3_Scan{*parser,filename} = False
              UnLock_ lock
              Function Return False
            End If
          End If
        End If
      Wend
    End If
    UnLock_ lock
  End If
  
  pft_Reset{*parser\filesT}
  While pft_GetNextItem{*parser\filesT}
    value.s    = pft_GetString{*parser\filesT}
    filename.s = pft_GetKey{*parser\filesT}
    ;NPrint "Check ",filename," :: ",value
    If value="todo"
      ab3_Parse{*parser,filename}
      pft_AddItem{*parser\filesT,filename,"done"}
      pft_Reset{*parser\filesT}
    End If
  Wend
  
  Function Return True

End Function


Function.l ab3_Init{}

  For n.l=0 To 255
    AmiBlitz3\CharFlags[n] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW |#AB3TF_2BYTETOKEN
  Next

  AmiBlitz3\CharFlags[   0] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_EOL ; Null
  AmiBlitz3\CharFlags[   1] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SOH
  AmiBlitz3\CharFlags[   2] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; STX
  AmiBlitz3\CharFlags[   3] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ETX
  AmiBlitz3\CharFlags[   4] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; EOT
  AmiBlitz3\CharFlags[   5] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ENQ
  AmiBlitz3\CharFlags[   6] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ACK
  AmiBlitz3\CharFlags[   7] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; BELL
  AmiBlitz3\CharFlags[   8] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; BS  (backspace)
  AmiBlitz3\CharFlags[   9] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW|#AB3TF_SPACE ; TAB (tabulator)
  AmiBlitz3\CharFlags[  10] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW|#AB3TF_EOL ; LF  (line feed) Linux Return
  AmiBlitz3\CharFlags[  11] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; VT
  AmiBlitz3\CharFlags[  12] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; FF  (feed forward)
  AmiBlitz3\CharFlags[  13] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CR  (carrier return) Windows Return
  AmiBlitz3\CharFlags[  14] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SO
  AmiBlitz3\CharFlags[  15] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SI
  AmiBlitz3\CharFlags[  16] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; DLE
  AmiBlitz3\CharFlags[  17] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; DC1
  AmiBlitz3\CharFlags[  18] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CD2
  AmiBlitz3\CharFlags[  19] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CD3
  AmiBlitz3\CharFlags[  20] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CD4
  AmiBlitz3\CharFlags[  21] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; NAK
  AmiBlitz3\CharFlags[  22] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SYN
  AmiBlitz3\CharFlags[  23] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ETB
  AmiBlitz3\CharFlags[  24] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CAN (Cancel)
  AmiBlitz3\CharFlags[  25] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; EM
  AmiBlitz3\CharFlags[  26] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SUB
  AmiBlitz3\CharFlags[  27] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ESC (Escape)
  AmiBlitz3\CharFlags[  28] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; FS
  AmiBlitz3\CharFlags[  29] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; GS
  AmiBlitz3\CharFlags[  30] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; RS
  AmiBlitz3\CharFlags[  31] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; US
  AmiBlitz3\CharFlags[@" "] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY|#AB3TF_SPACE ; Space
  AmiBlitz3\CharFlags[@"!"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[  34] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY|#AB3TF_QUOT
  AmiBlitz3\CharFlags[@"#"] = #AB3TF_STOP | #AB3TF_IS   | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"$"] = #AB3TF_STOP | #AB3TF_IS   | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"%"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"&"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"'"] = #AB3TF_STOP | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"("] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@")"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"*"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"+"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@","] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"-"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"."] = #AB3TF_STOP | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"/"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"0"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_BIN |#AB3TF_HEX|#AB3TF_DEC
  AmiBlitz3\CharFlags[@"1"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_BIN |#AB3TF_HEX|#AB3TF_DEC
  AmiBlitz3\CharFlags[@"2"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"3"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"4"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"5"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"6"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"7"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"8"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"9"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@":"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@";"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COMMENT|#AB3TF_COPY
  AmiBlitz3\CharFlags[@"<"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"="] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@">"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"?"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"@"] = #AB3TF_STOP | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"A"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"B"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"C"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"D"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"E"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"F"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"G"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"H"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"I"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"J"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"K"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"L"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"M"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"N"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"O"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"P"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"Q"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"R"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"S"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"T"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"U"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"V"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"W"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"X"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"Y"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"Z"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"["] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"\"] = #AB3TF_STOP | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"]"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"^"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"_"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"`"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"a"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"b"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"c"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"d"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"e"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"f"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"g"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"h"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"i"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"j"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"k"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"l"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"m"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"n"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"o"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"p"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"q"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"r"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"s"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"t"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"u"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"v"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"w"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"x"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"y"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"z"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"{"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"|"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"}"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"~"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[ 127] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW

  Function Return True

End Function



; ===========================================================
;///////////////////////////////////
;// Command line interface
;///////////////////////////////////

; Tell the compiler what AB3 Includes we are going to use.
XINCLUDE "dos.include.bb2"  ; we will use functions from the dos.include

; We assume no error happened so far ...
err.l        = False ; indicate that an error has occured
showhelp.l   = False ; show the CLI tool's help

; Set the default values of your CLI arguments.
verbose.l    = 1
recursive.l  = False
incpath.s    = ""
dflags.l     = #DF_ALL

; Get the required CLI arguments ...
filename.s = dos_GetNextArg{} ; first read the filename
If filename.s = ""
  NPrint "*** ERROR: No filename specified!"
  err=True
EndIf

; Get the optional CLI arguments
Repeat
  arg.s = dos_GetNextArg{} ; get the next CLI argument
  larg.s = LCase$(arg) ; lower case the option string
  If Left$(larg.s,1) = "-" Then larg=UnRight$(larg,1)
  Select larg
    Case "v"  : verbose    = Vallong(dos_GetNextArg{})
    Case "h"  : showhelp   = True  ; show the help and quit
    Case "r"  : recursive  = True
    Case "i"  : incpath    = dos_GetNextArg{}
    Case "df" : dflags   = 0
      flags.s = LCase$(dos_GetNextArg{})
      If Instr(flags,"f") Then dflags|#DF_FUNCTION
      If Instr(flags,"m") Then dflags|#DF_MACRO
      If Instr(flags,"t") Then dflags|#DF_NEWTYPE
      If Instr(flags,"c") Then dflags|#DF_CONSTANT
      If Instr(flags,"l") Then dflags|#DF_LABEL
      If Instr(flags,"s") Then dflags|#DF_SOURCE
      If Instr(flags,"n") Then dflags|#DF_FIELD
      If Instr(flags,"g") Then dflags|#DF_GLOBAL
      If Instr(flags,"v") Then dflags|#DF_LOCAL
      If Instr(flags,"i") Then dflags|#DF_INCLUDE
      If Instr(flags,"$") Then dflags|#DF_STRING
    Default
      If arg><""
        NPrint "*** ERROR: Unknown option \\22",arg,"\\22 specified!"
        err = True
      End If
  End Select
Until arg = "" ; until we processed all arguments

; Show the help if something went wrong or help was requested
If err><False OR showhelp = True
  NPrint vers
  NPrint "Scan an \\22Amiblitz\\22 source code for various properties."
  NPrint "\\nSyntax: AB3Scan <sourcefile> [options]"
  NPrint "  required"
  NPrint "  <sourcefile>      : source file to process"
  NPrint "  optional"
  NPrint "  -(df)lags <flags> : flags to indicate what to output:"
  NPrint "                      S = source file"
  NPrint "                      F = functions"
  NPrint "                      M = macros"
  NPrint "                      T = newtypes"
  NPrint "                      N = newtype fields"
  NPrint "                      C = constants"
  NPrint "                      L = labels"
  NPrint "                      G = global variables"
  NPrint "                      V = local variables"
  NPrint "                      I = includes"
  NPrint "                      $ = strings"
  NPrint "  -(i)nclude <path> : include directory"
  NPrint "  -(r)ecursive      : scan recursive (XINCLUDES) too"
  NPrint "  -(v)erbose <v>    : verbose level"
  NPrint "  -(h)help          : show this help"
  NPrint "\\nExample:"
  NPrint "  AB3Scan \\22DH0:Files\MyProgram.ab3\\22 -r -df SFM\\n"
  End
End If

If dos_IsDir{filename}
  path.s    = filename
  pattern.s = "#?.(bb|bb2|ab2|ab3)"
Else
  path.s    = dos_PathPart{filename}
  pattern.s = dos_FilePart{filename}
End If

; Do something useful here and do some shell output...
If verbose>1 Then NPrint "INFO Scan \\22",path,"\\22 for \\22",pattern,"\\22..."
ab3_Init{}
*parser.Parser = ab3_CreateParser{incpath,pattern,recursive,dflags,verbose}
If *parser = Null Then NPrint "*** Unable to create AB3 Parser!" : End
ab3_Scan{*parser,path}
If *parser\verbose>1 Then NPrint "INFO Done."
ab3_FreeParser{*parser} : *parser = Null
End

Dc.b "$VER: "
version:
Dc.b "AB3Scan \\__VER_MAJOR.\\__VER_MINOR (\\__DATE_GER__) Build \\__VER_PATCH.\\__VER_BUILD",0
shortversion:
Dc.b "AB3Scan \\__VER_MAJOR.\\__VER_MINOR",0


