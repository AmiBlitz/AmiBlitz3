; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "DH18:AMITest/Amiblitz3/AIDE"
; ExeFile         = "AIDE"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.3.2
; NumberOfBuilds  = 1113
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8192
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 1
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 25
; CursorColumn    = 63
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 1
; Max GadgetList  = 1
; Max Queue       = 1
; Max Screen      = 2
; Max Shape       = 1
; Max CopList     = 1
; Max Sprite      = 1
; Max Stencil     = 1
; Max Module      = 1
; Max Window      = 30
; Max Anim        = 1
; Max Sound       = 1
; Max Bank        = 1
; Max Buffer      = 1
; Max BitMap      = 1
; Max Slice       = 1
; Max Page        = 1
; Max Tape        = 1
; Max IntuiFont   = 12
; Max MedModule   = 1
; Max Palette     = 1
; Max MenuList    = 1
; Max BlitzFont   = 1
; Max GTList      = 30
; /XTRA
optimize 7
Syntax 6            ; changed to 6 for a better check  tomsmart1

#STR_USEPOOLED = 1  ; added to reduce memoryfracmentation via strptr.include   tomsmart1

WBStartup

JMP skipversion
Dc.b "$VER: "
version:
Dc.b "AIDE \\__VER_MAJOR.\\__VER_MINOR (\\__DATE_GER__) Build \\__VER_PATCH.\\__VER_BUILD",0
Even
shortversion:
Dc.b "AIDE \\__VER_MAJOR.\\__VER_MINOR",0
Even
skipversion:

ver.s = Peek.s(?shortversion)

XINCLUDE "ab3support.include.ab3"
XINCLUDE "error.include.ab3"
If AB3Support_OpenLib{2}=False Then WbToScreen 0 : error{"Please install ab3support.library v2!"} : End

XINCLUDE "ntui.include.ab3"        ; fix path of the include  tomsmart1
XINCLUDE "prefixtree.include.ab3"
XINCLUDE "hashmap.include.ab3"
XINCLUDE "dos.include.ab3"
XINCLUDE "file.include.ab3"
XINCLUDE "strptr.include.ab3"      ; added because functions are used  tomsmart1


#DOCTYPE_DEFAULT    = 0
#DOCTYPE_TEXT       = 1
#DOCTYPE_AMIGAGUIDE = 2
#DOCTYPE_AMIBLITZ3  = 3
#DOCTYPE_CPP        = 4
#DOCTYPE_MAKEFILE   = 5
#DOCTYPE_A          = 6
#DOCTYPE_AREXX      = 7
#DOCTYPE_XML        = 8
#DOCTYPE_HTML       = 9
#DOCTYPE_JAVA       = 10
#DOCTYPE_MAX        = 11

#DOCUMENT_MAX = 256

#GUILAYOUT_SMALL  = 0
#GUILAYOUT_MEDIUM = 1
#GUILAYOUT_LARGE  = 2

NEWTYPE.tuiVarArgs

  lock.l
  argC.l
  *argVA.b[16]

End NEWTYPE

RunErrsOff ; debugger must be switched off
ntui_RunAsyncAndNotifyMain:
Function.l ntui_RunAsyncAndNotifyMain{}

  MOVE.l _amiblitz3_global_base_runasync,a5
  *pargs.tuiVarArgs = ?_ntui_varargs

  *exe.str        = Null
  *cliargs.str    = Null
  *outfile.str    = Null
  *notifyId.str   = Null
  *string.str     = Null
  *cmdline.str    = Null
  *obj.tuiObject              = *pargs\argVA[0]
  str_WritePtrAsync{&*exe      ,*pargs\argVA[1]}
  str_WritePtrAsync{&*cliargs  ,*pargs\argVA[2]}
  str_WritePtrAsync{&*outfile  ,*pargs\argVA[3]}
  str_WritePtrAsync{&*notifyId ,*pargs\argVA[4]}
  value.l                     = *pargs\argVA[5]
  str_WritePtrAsync{&*string   ,*pargs\argVA[6]}
  str_WritePtrAsync{&*cmdline  ,*pargs\argVA[7]}
  If *obj Then ntui_Lock{*obj}
  *pargs\lock = False
  *pargs = Null

  If str_LenAsync{*cmdline}>0
    Execute_ str_GetPtrAsync{*cmdline},Null,Null
  Else
    outputFH.l = Open_(str_GetPtrAsync{*outfile},#MODE_NEWFILE)
    If outputFH
      n.l=0
      *tagList.tagL10 = AllocVec_(SizeOf.tagL10,#MEMF_ANY)
      If *tagList
        *tagList\tag[n]\ti_Tag = #NP_Priority  , 0                         : n=n+1
        *tagList\tag[n]\ti_Tag = #NP_Arguments , str_GetPtrAsync{*cliargs} : n=n+1
        *tagList\tag[n]\ti_Tag = #NP_StackSize , 8192                      : n=n+1
        *tagList\tag[n]\ti_Tag = #SYS_Input    , Null                      : n=n+1
        *tagList\tag[n]\ti_Tag = #SYS_Output   , outputFH                  : n=n+1
        *tagList\tag[n]\ti_Tag = #TAG_DONE     , 0
        ret.l = SystemTagList_ (str_GetPtrAsync{*exe},*tagList)
      End If
      Close_ outputFH
    End If
  End If
  ntui_PostNotifyWithData{*obj,str_GetPtrAsync{*notifyId},#TUIEV_USER,value,str_GetPtrAsync{*string},0,0,0,0}

  str_FreeAsync{&*exe}
  str_FreeAsync{&*cliargs}
  str_FreeAsync{&*outfile}
  str_FreeAsync{&*notifyId}
  str_FreeAsync{&*string}
  str_FreeAsync{&*cmdline}
   If *obj Then ntui_Unlock{*obj}
  Function Return 0

End Function
!_MakeGlobalFuncPointer_RunErrsOff{ntui_RunAsyncAndNotifyMain,{}}
LastRunErrsMode

Function.l ntui_RunAsyncAndNotify{*obj.tuiObject,exe.s,params.s,outfile.s,notifyId.s,value.l,string.s}

    DEFTYPE.tag5 tagList
    MOVE.l a5,_amiblitz3_global_base_runasync
    tagList\ti_Tag = #NP_Entry,*ntui_RunAsyncAndNotifyMain,#NP_Name,?_ntui_asynctaskname,#NP_Priority,0,#NP_StackSize,8192,#TAG_DONE,0

    commandline.s = "\\22"+exe+"\\22 >\\22"+outfile+"\\22 "+params
    *args.tuiVarArgs = ?_ntui_varargs
    *args\lock = True
    *args\argVA[0] = *obj
    *args\argVA[1] = &exe
    *args\argVA[2] = &params
    *args\argVA[3] = &outfile
    *args\argVA[4] = &notifyId
    *args\argVA[5] = value
    *args\argVA[6] = &string
    *args\argVA[7] = &commandline
    *args\argC = 8

    *process.Process = CreateNewProc_(tagList)
    If *process
      While (*args\lock) : Delay_ 1 : Wend
    EndIf
    
    Function Return *process><Null

    _amiblitz3_global_base_runasync:
    Dc.l 0

    _ntui_varargs:
    Dc.l 0 ; lock
    Dc.l 0 ; argC
    Dc.l 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ; argVA
    _ntui_asynctaskname:
    Dc.b "NTUI RunAsync",0
    
End Function


NEWTYPE.AIDE_Document

  IsUsed.l
  IsLocked.l
  DocType.l
  *Source.tuiGroup
  *TextBox.tuiTextBox
  Title.s
  ImageFile.s
  *Xtra.b
  NeedScan.l

End NEWTYPE


NEWTYPE.AIDE_DocType

  Pattern.s              ; dos pattern for identification, e.g. "#?.guide"
  PatternParsed.s        ; private, parsed dos pattern
  DefIcon.s              ; default image, e.g. "GUI/AGuide.png"
  Name.s                 ; name of doctype, e.g. "AmigeGuide"

  BasePath.s
  SDKPath.s
  BuildSourceCmd.s
  DebugSourceCmd.s
  ScanSourceCmd.s
  BuildProjectCmd.s
  DebugProjectCmd.s
  ScanProjectCmd.s
  ScanSDKCmd.s
  OpenCmd.s

  *DebugSource.tuiFunc   ; callback for debugging
  *BuildSource.tuiFunc   ; callback for building a file
  *DebugProject.tuiFunc  ; callback for debugging
  *BuildProject.tuiFunc  ; callback for building the project
  *Deinit.tuiFunc        ; free all resources
  *WritePrefs.tuiFunc    ; write the preferences
  *ReadPrefs.tuiFunc     ; read the preferences
  *Export.tuiFunc        ; document export filter, e.g. for BB2
  *Import.tuiFunc        ; document import filter, e.g. for BB2
  *Attach.tuiFunc        ; manipulate the textBox to handle the document type
  *Detach.tuiFunc
  *ScanSource.tuiFunc    ; callback for scanning the source
  *ScanSourceAsync.tuiFunc    ; callback for scanning the source
  *ScanSourceFinish.tuiFunc    ; callback for scanning the source
  *UpdateSDK.tuiFunc
  *JumpTo.tuiFunc
  ;*LongHelp.tuiFunc
  ;*QuickHelp.tuiFunc
  *OpenSettings.tuiFunc  ; Open the settings window for this document type
  *ApplySettings.tuiFunc ; Apply the settings window for this document type

End NEWTYPE


NEWTYPE.AIDE_ProjectType

  Pattern.s            ; dos pattern for identification, e.g. "#?.guide"
  PatternParsed.s      ; private, parsed dos pattern
  DefIcon.s            ; default image, e.g. "GUI/AGuide.png"
  Name.s               ; name of doctype, e.g. "AmigeGuide"

  *Debug.tuiFunc       ; callback for debugging
  *Build.tuiFunc       ; callback for building the file
  *Deinit.tuiFunc      ; free all resources
  *WritePrefs.tuiFunc  ; write the preferences
  *ReadPrefs.tuiFunc   ; read the preferences
  *Export.tuiFunc      ; document export filter, e.g. for BB2
  *Import.tuiFunc      ; document import filter, e.g. for BB2

End NEWTYPE

#FAVORITE_MAX = 20

NEWTYPE.AIDE_Favorite

  path.s
  count.l

End NEWTYPE


NEWTYPE.AIDE_Prefs

  CaseSensitiveSearch.l
  EscapeSearch.l
  ShowWelcome.w            ; -1 Show Welcome Window, 0 dont show
  AutoFormat.w             ; auto format the line that you are editing
  BoldTokens.w             ; use bold font for tokens
  ItalicComments.w         ; use italic font for comments
  PubScreenName.s          ; use this pubscreen, or create if not found
  OpenLastSource.w         ; open last sourcecode on next start
  RGBPens.l[#TUITBPEN_MAX] ; RGB values of pens, see ntui_TextBox for pens
  SourceCodeFontName.s     ; name of the font used for sourcecode
  SourceCodeFontSize.l     ; size
  AREXXPort.s              ; AIDE's AREXX Port name
  AppIcon.s                ; AIDE's AppIcon filename
  DefIconFolder.s
  DefIconAssign.s
  DefIconFile.s
  DefIconDevice.s
  EditorCursorStyle.l
  EditorBlinkSpeed.l
  ActiveDocument.s
  FileListPath.s
  NTUIBorderStyle.l
  NTUIFillStyle.l
  GUILayout.l
  OpenDocs.s
  
End NEWTYPE


NEWTYPE.AIDE

  ;/* Preferences */
  Prefs.AIDE_Prefs

  ;/* Document Types */
  DocType.AIDE_DocType[#DOCTYPE_MAX]
  
  ;/* Open Documents */
  Document.AIDE_Document[#DOCUMENT_MAX]

  ;/* Database of visited folders */
  *FavoriteT.prefixtree
  FavoriteFileName.s

  ;/* Runtime Data */
  Icon.s
  InstallPath.s            ; base path
  CallDirLock.l
  AddAssignDone.l
  LastMajorVersion.l       ; major version of AIDE that has been started last time
  LastMinorVersion.l       ; minor version
  RefreshAll.l             ; all cached files need refresh!
  GuiPath.s
  SysPath.s
  DocTypesPath.s
  Quit.l                   ; indicate exit of program
  IsDebugging.l
  IsBuilding.l
  BuildPath.s
  BuildExe.s
  BuildArgs.s

  ;/ GUI State */
  state.l
  anchor_lpos.l
  anchor_cpos.l

End NEWTYPE


; Window IDs
Macro win_main                  "win_main"               :End Macro
Macro win_about                 "win_about"              :End Macro
Macro win_calculator            "win_calculator"         :End Macro
Macro win_preferences           "win_preferences"        :End Macro
Macro win_project_settings      "win_project_settings"   :End Macro
Macro win_source_settings       "win_source_settings"    :End Macro
Macro win_popuphelp             "win_popuphelp"          :End Macro
Macro win_inputselector         "win_inputselector"      :End Macro
Macro win_splash                "win_splash"             :End Macro
Macro req_source_open           "req_source_open"        :End Macro
Macro req_project_open          "req_project_open"       :End Macro
Macro req_source_saveas         "req_source_saveas"      :End Macro
Macro req_project_saveas        "req_project_saveas"     :End Macro

; object IDs
Macro obj_filelist_path         "obj_filelist_path"      :End Macro
Macro obj_filelist_pattern      "obj_filelist_pattern"   :End Macro
Macro obj_filelist              "obj_filelist"           :End Macro

Macro obj_main_sourcetab        "obj_main_sourcetab"     :End Macro
Macro obj_main_console          "obj_main_console"       :End Macro
Macro obj_main_menubar          "obj_main_menubar"       :End Macro
Macro obj_main_toolbar          "obj_main_toolbar"       :End Macro

Macro obj_find_string           "obj_find_string"        :End Macro
Macro obj_find_docasesense      "obj_find_docasesense"   :End Macro
Macro obj_find_doescape         "obj_find_doescape"      :End Macro
Macro obj_find_replacestring    "obj_find_replacestring" :End Macro

Macro obj_source_text           "obj_source_text"        :End Macro
Macro obj_source_title          "obj_source_title"       :End Macro
Macro obj_source_status         "obj_source_status"      :End Macro
Macro obj_source_newtab         "obj_source_newtab"      :End Macro
Macro obj_source_build          "obj_source_build"       :End Macro
Macro obj_source_debug          "obj_source_debug"       :End Macro
Macro obj_source_save           "obj_source_save"        :End Macro
Macro obj_source_saveall        "obj_source_saveall"     :End Macro
Macro obj_source_undo           "obj_source_undo"        :End Macro
Macro obj_source_dstatus        "obj_source_dstatus"     :End Macro

Macro obj_project_build         "obj_project_build"      :End Macro
Macro obj_project_debug         "obj_project_debug"      :End Macro
Macro obj_project_clean         "obj_project_clean"      :End Macro
Macro obj_project_rebuild       "obj_project_rebuild"    :End Macro
Macro obj_project_new           "obj_project_new"        :End Macro
Macro obj_project_close         "obj_project_close"      :End Macro
Macro obj_project_open          "obj_project_open"       :End Macro
Macro obj_project_export        "obj_project_export"     :End Macro
Macro obj_project_save          "obj_project_save"       :End Macro
Macro obj_project_saveas        "obj_project_saveas"     :End Macro
Macro obj_project_settings      "obj_project_settings"   :End Macro

Macro obj_debug_continue        "obj_debug_continue"     :End Macro
Macro obj_debug_break           "obj_debug_break"        :End Macro
Macro obj_debug_step            "obj_debug_step"         :End Macro
Macro obj_debug_stepin          "obj_debug_stepin"       :End Macro
Macro obj_debug_stepout         "obj_debug_stepout"      :End Macro
Macro obj_debug_end             "obj_debug_end"          :End Macro

Macro obj_about_version         "obj_about_version"      :End Macro
Macro obj_about_arexxport       "obj_about_arexxport"    :End Macro
Macro obj_about_pubscreen       "obj_about_pubscreen"    :End Macro

Macro obj_popuphelp_image       "obj_popuphelp_image"    :End Macro
Macro obj_popuphelp_text        "obj_popuphelp_text"     :End Macro
Macro obj_popuphelp_name        "obj_popuphelp_name"     :End Macro
Macro obj_popuphelp_source      "obj_popuphelp_source"   :End Macro

Macro obj_selector_list         "obj_selector_list"      :End Macro

;Macro obj_sdk_tab           "obj_sdk_tab"           :End Macro

Macro obj_src_list          "obj_src_list"          :End Macro
Macro obj_src_show_function "obj_src_show_function" :End Macro
Macro obj_src_show_token    "obj_src_show_token"    :End Macro
Macro obj_src_show_macro    "obj_src_show_macro"    :End Macro
Macro obj_src_show_constant "obj_src_show_constant" :End Macro
Macro obj_src_show_struct   "obj_src_show_struct"   :End Macro
Macro obj_src_show_label    "obj_src_show_label"    :End Macro
Macro obj_src_show_local    "obj_src_show_local"    :End Macro
Macro obj_src_show_global   "obj_src_show_global"   :End Macro
Macro obj_src_show_string   "obj_src_show_string"   :End Macro
Macro obj_src_show_all      "obj_src_show_all"      :End Macro
Macro obj_src_filter        "obj_src_filter"        :End Macro
Macro obj_src_filter_image  "obj_src_filter_image"  :End Macro
Macro obj_src_filter_stats  "obj_src_filter_stats"  :End Macro

Macro obj_ab3_list          "obj_ab3_list"          :End Macro
Macro obj_ab3_show_function "obj_ab3_show_function" :End Macro
Macro obj_ab3_show_token    "obj_ab3_show_token"    :End Macro
Macro obj_ab3_show_macro    "obj_ab3_show_macro"    :End Macro
Macro obj_ab3_show_constant "obj_ab3_show_constant" :End Macro
Macro obj_ab3_show_struct   "obj_ab3_show_struct"   :End Macro
Macro obj_ab3_show_label    "obj_ab3_show_label"    :End Macro
Macro obj_ab3_show_local    "obj_ab3_show_local"    :End Macro
Macro obj_ab3_show_global   "obj_ab3_show_global"   :End Macro
Macro obj_ab3_show_string   "obj_ab3_show_string"   :End Macro
Macro obj_ab3_show_all      "obj_ab3_show_all"      :End Macro
Macro obj_ab3_filter        "obj_ab3_filter"        :End Macro
Macro obj_ab3_filter_image  "obj_ab3_filter_image"  :End Macro
Macro obj_ab3_filter_stats  "obj_ab3_filter_stats"  :End Macro

Macro obj_splash_message    "obj_splash_message"    :End Macro
Macro obj_splash_progress   "obj_splash_progress"   :End Macro

; Notifies
Macro ev_aide_about             "ev_about"               :End Macro
Macro ev_aide_calculator        "ev_calculator"          :End Macro
Macro ev_aide_preferences       "ev_preferences"         :End Macro
Macro ev_tool_shell             "ev_tool_shell"          :End Macro
Macro ev_aide_prefs_apply       "ev_aide_prefs_apply"    :End Macro

Macro ev_filelist_select        "ev_filelist_select"         :End Macro
Macro ev_filelist_showdrives    "ev_filelist_showdrives"     :End Macro
Macro ev_filelist_parentpath    "ev_filelist_parentpath"     :End Macro
Macro ev_filelist_refresh       "ev_filelist_refresh"        :End Macro
Macro ev_filelist_favorites     "ev_filelist_favorites"      :End Macro
Macro ev_filelist_newfolder     "ev_filelist_newfolder"      :End Macro
Macro ev_filelist_delete        "ev_filelist_delete"         :End Macro
Macro ev_filelist_rename        "ev_filelist_rename"         :End Macro
Macro ev_filelist_setpattern    "ev_filelist_setpattern"     :End Macro

Macro ev_source_build           "ev_source_build"            :End Macro
Macro ev_source_cursor          "ev_source_cursor"           :End Macro
Macro ev_source_debug           "ev_source_debug"            :End Macro
Macro ev_source_new             "ev_source_new"              :End Macro
Macro ev_source_open            "ev_source_open"             :End Macro
Macro ev_source_open_req        "ev_source_open_req"         :End Macro
Macro ev_source_close           "ev_source_close"            :End Macro
Macro ev_source_closeall        "ev_source_closeall"         :End Macro
Macro ev_source_closeallbutthis "ev_source_closeallbutthis"  :End Macro
Macro ev_source_save            "ev_source_save"             :End Macro
Macro ev_source_saveas          "ev_source_saveas"           :End Macro
Macro ev_source_saveas_req      "ev_source_saveas_req"       :End Macro
Macro ev_source_saveall         "ev_source_saveall"          :End Macro
Macro ev_source_settings        "ev_source_settings"         :End Macro
Macro ev_source_applysettings   "ev_source_applysettings"    :End Macro
Macro ev_source_cut             "ev_source_cut"              :End Macro
Macro ev_source_copy            "ev_source_copy"             :End Macro
Macro ev_source_paste           "ev_source_paste"            :End Macro
Macro ev_source_delete          "ev_source_delete"           :End Macro
Macro ev_source_selectall       "ev_source_selectall"        :End Macro
Macro ev_source_undo            "ev_source_undo"             :End Macro
Macro ev_source_find            "ev_source_find"             :End Macro
Macro ev_source_replace         "ev_source_replace"          :End Macro
Macro ev_source_switch          "ev_source_switch"           :End Macro

Macro ev_project_debug          "ev_project_debug"           :End Macro
Macro ev_project_build          "ev_project_build"           :End Macro
Macro ev_project_new            "ev_project_new"             :End Macro
Macro ev_project_close          "ev_project_close"           :End Macro
Macro ev_project_import         "ev_project_import"          :End Macro

Macro ev_console_close          "ev_console_close"           :End Macro
Macro ev_console_click          "ev_console_click"           :End Macro

Macro ev_find_refresh           "ev_find_refresh"            :End Macro
Macro ev_find_next              "ev_find_next"               :End Macro
Macro ev_find_prev              "ev_find_prev"               :End Macro
Macro ev_find_replaceall        "ev_find_replaceall"         :End Macro
Macro ev_find_replace           "ev_find_replace"            :End Macro
Macro ev_find_replacefind       "ev_find_replacefind"        :End Macro
Macro ev_find_docasesense       "ev_find_docasesense"        :End Macro
Macro ev_find_doescape          "ev_find_doescape"           :End Macro

Macro ev_src_refresh            "ev_src_refresh"             :End Macro
Macro ev_src_jumpto             "ev_src_jumpto"              :End Macro
Macro ev_src_rescan             "ev_src_rescan"              :End Macro

Macro ev_ab3_refresh            "ev_ab3_refresh"             :End Macro
Macro ev_ab3_jumpto             "ev_ab3_jumpto"              :End Macro
Macro ev_ab3_rescan             "ev_ab3_rescan"              :End Macro

Macro ev_setlayout_small        "ev_setlayout_small"         :End Macro
Macro ev_setlayout_medium       "ev_setlayout_medium"        :End Macro
Macro ev_setlayout_large        "ev_setlayout_large"         :End Macro

Macro ev_input_select           "ev_input_select"            :End Macro
Macro ev_filelist_iconinfo      "ev_filelist_iconinfo" : End Macro

; deprecated
Macro file_win_source_settings_ab3 "win_source_settings_ab3.xml" :End Macro
Macro file_win_source_settings_cpp "win_source_settings_cpp.xml" :End Macro
Macro file_win_source_settings_ag  "win_source_settings_ag.xml"  :End Macro
Macro file_fragment_source         "fragment_source.xml"         :End Macro
Macro file_fragment_maxobj_ab3     "fragment_maxobj_ab3.xml"     :End Macro

; XML Files
Macro file_engine                  "engine.xml"                  :End Macro
Macro file_requester               "requester.xml"               :End Macro
Macro file_win_about               "win_about.xml"               :End Macro
Macro file_win_calculator          "win_calculator.xml"          :End Macro
Macro file_win_popuphelp           "win_popuphelp.xml"           :End Macro
Macro file_win_inputselector       "win_inputselector.xml"       :End Macro
Macro file_win_splash              "win_splash.xml"              :End Macro
Macro file_win_preferences         "win_preferences.xml"         :End Macro
Macro file_win_main_small          "win_main_small.xml"          :End Macro
Macro file_win_main_mid            "win_main_mid.xml"            :End Macro
Macro file_win_main_large          "win_main_large.xml"          :End Macro

; Fragments for main window
Macro file_fragment_filebrowser    "fragment_filebrowser.xml"    :End Macro
Macro file_fragment_sourcebrowser  "fragment_sourcebrowser.xml"  :End Macro
Macro file_fragment_projectbrowser "fragment_projectbrowser.xml" :End Macro
Macro file_fragment_ab3browser     "fragment_ab3browser.xml"     :End Macro
Macro file_fragment_aissbrowser    "fragment_aissbrowser.xml"    :End Macro
Macro file_fragment_menu           "fragment_menu.xml"           :End Macro
Macro file_fragment_toolbar        "fragment_toolbar.xml"        :End Macro
Macro file_fragment_console        "fragment_console.xml"        :End Macro
Macro file_fragment_editor         "fragment_editor.xml"         :End Macro

; holders
Macro holder_menu                  "holder_menu"                 :End Macro
Macro holder_toolbar               "holder_toolbar"              :End Macro
Macro holder_editor                "holder_editor"               :End Macro
Macro holder_browser               "holder_browser"              :End Macro
Macro holder_browser2              "holder_browser2"             :End Macro
Macro holder_browser3              "holder_browser3"             :End Macro
Macro holder_console               "holder_console"              :End Macro

Macro If_BadDocX_Then
If docX<0 OR docX>=#DOCUMENT_MAX Then `1
If AIDE\Document[docX]\IsUsed=False Then `1
End Macro

SHARED AIDE.AIDE
SHARED *ntui.tuiEngine

;/* init the AIDE preferences and path settings */
Statement AIDE_Init{icon.s,dir.s}

  AIDE\InstallPath    = dir
  AIDE\Icon           = icon
  AIDE\GuiPath        = dos_AddPart{AIDE\InstallPath,"Gui"}
  AIDE\SysPath        = dos_AddPart{AIDE\InstallPath,"System"}
  AIDE\DocTypesPath   = dos_AddPart{AIDE\InstallPath,"Types"}
  AIDE\Quit           = False
  AIDE\CallDirLock    = 0
  AIDE\AddAssignDone  = dos_AddAssign{"Libs",dos_AddPart{AIDE\InstallPath,"Libs"}}

  installLock.l = Lock_(&AIDE\InstallPath,#ACCESS_READ)
  If installLock
    AIDE\CallDirLock = CurrentDir_ (installLock)
  End If

  For docX.l=0 To #DOCUMENT_MAX-1
    AIDE\Document[docX]\IsUsed    = False
    AIDE\Document[docX]\IsLocked  = False
    AIDE\Document[docX]\Source    = Null
    AIDE\Document[docX]\TextBox   = Null
    AIDE\Document[docX]\Xtra      = Null
    AIDE\Document[docX]\Title     = ""
    AIDE\Document[docX]\ImageFile = ""
  Next

  For docTypeX.l=0 To #DOCTYPE_MAX-1
    AIDE\DocType[docTypeX]\Pattern       = ""            ; dos pattern for identification, e.g. "#?.guide"
    AIDE\DocType[docTypeX]\PatternParsed = ""     ; private, parsed dos pattern
    AIDE\DocType[docTypeX]\DefIcon       = ""     ; default image, e.g. "GUI/AGuide.png"
    AIDE\DocType[docTypeX]\Name          = ""     ; name of doctype, e.g. "AmigeGuide"
    AIDE\DocType[docTypeX]\DebugSource   = Null     ; callback for debugging
    AIDE\DocType[docTypeX]\BuildSource   = Null     ; callback for building a file
    AIDE\DocType[docTypeX]\DebugProject  = Null    ; callback for debugging
    AIDE\DocType[docTypeX]\BuildProject  = Null    ; callback for building the project
    AIDE\DocType[docTypeX]\Deinit        = Null      ; free all resources
    AIDE\DocType[docTypeX]\WritePrefs    = Null  ; write the preferences
    AIDE\DocType[docTypeX]\ReadPrefs     = Null   ; read the preferences
    AIDE\DocType[docTypeX]\Export        = Null      ; document export filter, e.g. for BB2
    AIDE\DocType[docTypeX]\Import        = Null      ; document import filter, e.g. for BB2
    AIDE\DocType[docTypeX]\Attach        = Null      ; manipulate the textBox to handle the document type
    AIDE\DocType[docTypeX]\Detach        = Null
    AIDE\DocType[docTypeX]\ScanSource    = Null  ; callback for scanning the source
    AIDE\DocType[docTypeX]\ScanSourceAsync  = Null  ; callback for scanning the source
    AIDE\DocType[docTypeX]\ScanSourceFinish = Null  ; callback for scanning the source
    AIDE\DocType[docTypeX]\UpdateSDK     = Null
    AIDE\DocType[docTypeX]\JumpTo        = Null
    AIDE\DocType[docTypeX]\OpenSettings  = Null
    AIDE\DocType[docTypeX]\ApplySettings = Null
  Next
  
  AIDE\IsBuilding  = False
  AIDE\IsDebugging = False
  AIDE\FavoriteT   = Null
  AIDE\FavoriteFileName = dos_AddPart{AIDE\SysPath,"PathHistory.pft"}

End Statement



progIcon.s  = dos_GetStartIcon{"AIDE"}
progFile.s  = dos_GetProgFile{"Sourcecodes:AmiBlitz3/AIDE/AIDE"}
progDir.s   = dos_PathPart{progFile} ; dos_GetProgDir{""}
AIDE_Init{progIcon,progDir}


Statement StartUp_Message{message.s}  
SHARED startprogress.l

  If message><""
    *splashmsg.tuiLabel = (.tuiLabel)ntui_GetObjectByID{*ntui,!obj_splash_message}
    If *splashmsg
      ntui_SetString{*splashmsg,message}
      _ntui_Redraw{*splashmsg,Null}
    End If
  End If
  
  *progress.tuiImageView = (.tuiImageView)ntui_GetObjectByID{*ntui,!obj_splash_progress}
  If *progress
    image.s = "Gui/images/busy_"+Str$(startprogress & $7)
    ntui_SetAttr{*progress,#TUIIVA_IMAGE,&image}
    _ntui_Redraw{*progress,Null}
    startprogress+1
  End If
  
End Statement



Statement Popup_Help{name.s,text.s,source.s,x.l,y.l}

  *win.tuiWindow = ntui_GetWindowByID{*ntui,!win_popuphelp,-1}
  If *win Then ntui_FreeObject{*win} : *win=Null ; hack to make it reopen again!
  
  If *win=Null
    *win = ntui_GetWindow{ntui_BuildFromXMLFile{*ntui,dos_AddPart{AIDE\GuiPath,!file_win_popuphelp}}}
  Else
    ntui_HideWindowByID{*ntui,!win_popuphelp}
  EndIf

  If name="" Then Statement Return
  
  If *win
    ntui_SetStringByID{*win,!obj_popuphelp_name,name}
    ntui_SetStringByID{*win,!obj_popuphelp_text,text}
    ntui_SetStringByID{*win,!obj_popuphelp_source,source}
    ntui_Rethink{*win}
    ntui_ShowWindow{*win,x,y,Null,False}
  EndIf

End Statement


Statement PopUp_InputSelector{options.s,x.l,y.l}

  *win.tuiWindow = ntui_GetWindowByID{*ntui,!win_inputselector,-1}
  If *win Then ntui_FreeObject{*win} : *win=Null ; hack to make it reopen again!
  
  If *win=Null
    *obj.tuiObject = ntui_BuildFromXMLFile{*ntui,dos_AddPart{AIDE\GuiPath,!file_win_inputselector}}
    If *obj Then *win = ntui_GetWindow{*obj}
  Else
    ntui_HideWindowByID{*ntui,!win_inputselector}
  EndIf

  If options="" Then Statement Return
  
  If *win = Null Then Statement Return
  
  *listView.tuiListView = (.tuiListView)ntui_GetObjectByID{*win,!obj_selector_list}
  If *listView = Null Then Statement Return
  
  apos.l = 0
  bpos.l = 0
  count.l = 0
  Repeat
    apos = bpos+1
    bpos = Instr(options,"\\09",apos)
    If bpos=0 Then bpos = FLen(options)
    If bpos>apos
      option.s = Mid$(options,apos,bpos-apos)
      ntui_AddListItem{*listView,-1,option,count,0,0}
      count+1
    EndIf
  Until bpos<=apos
  
  ntui_Rethink{*win}
  ntui_ShowWindow{*win,x,y,Null,False}
  
End Statement


Function.l instr_nocaseP{*hayP.b,hayLen.l,*needleP.b,needleLen.l,pos.l}

  ; optimized implementation, not finished!
  While pos+needleLen<=hayLen
    char.b = Peek.b(*hayP+pos)
    If char>=@"A" AND char<=@"Z" Then char=char - @"A" + @"a"
    If char=Peek.b(*needleP)
      m.l = 0
      Repeat
        m+1
        char=Peek.b(*hayP+pos+m)
        If char>=@"A" AND char<=@"Z" Then char=char - @"A" + @"a"        
      Until char><Peek.b(*needleP+m) OR m>=needleLen
      If m=needleLen Then Function Return pos+1
    End If
    pos+1
  Wend
  Function Return 0
  
End Function  


Function.l instr_nocase_{hay.s,needle.s,@pos.l}

  hay.s = LCase$(hay)
  needle.s = LCase$(needle)
  Function Return Instr(hay,needle,pos)
  
End Function


Function.s UnescapeString{string.s}
  pos.l = 0
  os.s = string
  Repeat
    pos.l = Instr(string,"\",pos+1)
    If pos>0
      c.l = Peek.b(&string+pos)
      Select c
        Case @"\" :  string = Left$(string,pos-1) + Chr$($5C) + Right$(string,FLen(string)-pos-1)
        Case @"0" :  string = Left$(string,pos-1) + Chr$($00) + Right$(string,FLen(string)-pos-1)
        Case @"t" :  string = Left$(string,pos-1) + Chr$($09) + Right$(string,FLen(string)-pos-1)
        Case @"n" :  string = Left$(string,pos-1) + Chr$($10) + Right$(string,FLen(string)-pos-1)
        Case @"r" :  string = Left$(string,pos-1) + Chr$($13) + Right$(string,FLen(string)-pos-1)
        Case @"x"
          c.l = 0
          nib.l = Peek.b(&string+pos+1) &$FF
          done.l = 0
          If nib>=@"0" AND nib<=@"9" Then c + (nib-@"0")    : done=1
          If nib>=@"a" AND nib<=@"f" Then c + (nib-@"a"+10) : done=1
          If nib>=@"A" AND nib<=@"F" Then c + (nib-@"A"+10) : done=1

          If done
            c LSL 4
            nib.l = Peek.b(&string+pos+2) &$FF
            done = 0
            If nib>=@"0" AND nib<=@"9" Then c + (nib-@"0")    : done=1
            If nib>=@"a" AND nib<=@"f" Then c + (nib-@"a"+10) : done=1
            If nib>=@"A" AND nib<=@"F" Then c + (nib-@"A"+10) : done=1
            If done
              string = Left$(string,pos-1) + Chr$(c) + Right$(string,FLen(string)-pos-3)
            End If
          End If
        Default

      End Select
    End If

  Until pos=0
  ;If os><string Then error{"Mapped "+os+" to "+string}

  Function Return string

End Function


Function.s GetDosFileName{filename.s}

  MaxLen buff.s = 1024
  
  lock.l = Lock_(&filename,#ACCESS_READ);
  If lock
    NameFromLock_ lock,&buff,1023
    filename = Peek.s(&buff)
    UnLock_ lock : lock=0
  End If
  
  Function Return filename
  
End Function


Statement AIDE_AutoLayout{}
  If *ntui\screen_=Null Then Statement Return

  top.l    = *ntui\screen_\BarHeight
  bottom.l = *ntui\screen_\Height-1
  left.l   = 0
  right.l  = *ntui\screen_\Width-1


  ;lock.l = LockIBase_ (0)
  *myWindow.Window = *ntui\screen_\FirstWindow

  While *myWindow
    rx.l = *myWindow\Width/*myWindow\Height
    ry.l = *myWindow\Height/*myWindow\Width
    If rx>8
      If *myWindow\TopEdge+*myWindow\Height-1 >= bottom
        bottom = Min(bottom,*myWindow\TopEdge-1)
      End If
      If *myWindow\TopEdge<*ntui\screen_\BarHeight
        top    = Max(top,*myWindow\TopEdge+*myWindow\Height)
      End If
    End If

    If ry>2
      If *myWindow\LeftEdge+*myWindow\Width-1 >= right
        right = Min(right,*myWindow\LeftEdge-1)
      End If
      If *myWindow\LeftEdge<=0
        left  = Max(left,*myWindow\LeftEdge+*myWindow\Width)
      End If
    End If
    *myWindow = *myWindow\NextWindow
  Wend

  ;UnlockIBase_ lock
  
  *win.tuiWindow = ntui_GetWindowByID{*ntui,!win_main}
  If *win
    bbox.tuiRect\left = left,top,right,bottom
    ntui_SetAttr{*win,#TUIWA_SCREENBOX,bbox}
  End If

End Statement


Statement DocType_SetPattern{docTypeX.l,pattern.s}

  tempbuffer.s = LSet$(" ",FLen(pattern)*3+7)

  AIDE\DocType[docTypeX]\Pattern = pattern
  If ParsePatternNoCase_ (&AIDE\DocType[docTypeX]\Pattern,&tempbuffer,FLen(tempbuffer))>=0
    AIDE\DocType[docTypeX]\PatternParsed = Peek.s(&tempbuffer)
  Else
    AIDE\DocType[docTypeX]\PatternParsed = ""
  End If
  
End Statement


Function.l DocType_Examine{filename.s}

  docType.l = #DOCTYPE_DEFAULT
  For n.l=1 To #DOCTYPE_MAX-1
    If AIDE\DocType[n]\PatternParsed><""
      If MatchPatternNoCase_ (&AIDE\DocType[n]\PatternParsed,&filename)
        docType = n
      End If
    End If
  Next

  Function Return docType

End Function


Statement FileLister_AddFile{*listView.tuiListView,filename.s}
  d.s = dos_GetFileDate{filename}

  path.s = dos_PathPart{filename}
  If path=AIDE\Prefs\FileListPath Then name.s = dos_FilePart{filename} : Else name = filename

  If dos_IsDir{filename}
    flags.l=0
    If Peek.b(&name)=@"." Then flags | #TUIF_DISABLED
    b.s = "\pRIGHT\t<DIR>"
    If dos_Exist{filename+".info"} Then icon.s = filename+".info" : Else icon.s = AIDE\Prefs\DefIconFolder
    ntui_AddListItem{*listView,-1,"\p"+icon+"|\b"+name+"|"+b+"|"+d+"",0,1234,flags}
  Else
    bs.l = dos_GetFileSize{filename}
    If bs>=1000
      Format "000"
      b = Str$(bs MOD 1000)
      Format ""
    Else
      b = Str$(bs)
    End If
    While bs>1000
      bs/1000
      If bs>=1000
        Format "000"
        b = Str$(bs MOD 1000)+"."+b
        Format ""
      Else
        b = Str$(bs)+"."+b
      End If
    Wend
    flags = 0
    If dos_Exist{filename+".info"}
      icon.s = filename+".info"
    Else
      docTypeX.l = DocType_Examine{name}
      icon.s = AIDE\DocType[docTypeX]\DefIcon
    End If
    ntui_AddListItem{*listView,-1,"\p"+icon+"|"+name+"|"+b+"|"+d+"",0,1234,flags}
  End If

End Statement


Statement FileLister_Fill{id.s,path.s,pattern.s}
  *listView.tuiListView = (.tuiListView)ntui_GetObjectByID{*ntui,id}
  If *listView=Null Then Statement Return

  ntui_ClearListView{*listView}
  ;ntui_SetAttr{*listView,#TUILVA_TOTALWIDTH,0} ; this is read only attr !!!
  
  AIDE\Prefs\FileListPath = ""
  DocType_SetPattern{#DOCTYPE_DEFAULT,pattern}

  Select path
    Case ""
      Repeat
        name.s = dos_ScanVolumes{}
        If name
          flags.l=0;#TUIF_HIGHLIGHT
          s.f = dos_GetDiskSize{name}
          unit.s="B"
          If s>1024 Then s/1024 : unit="kB"
          If s>1024 Then s/1024 : unit="MB"
          If s>1024 Then s/1024 : unit="GB"
          b.s = Str$(Int(s))
          If s<100 Then n.l = Int(s*10) MOD 10 : b.s + "."+Str$(n)
          b.s + unit
          icon.s = name
          d.s = dos_GetFileDate{name}
          ntui_AddListItem{*listView,-1,"\p"+icon+"|\b"+name+"|"+b+"|"+d+"",0,1234,flags}
        End If
      Until name=""

      Repeat
        name.s = dos_ScanAssigns{}
        If name
          flags.l=0;#TUIF_HIGHLIGHT
          b.s = "<ASSIGN>"
          icon.s = AIDE\Prefs\DefIconAssign
          d.s = dos_GetFileDate{name}
          ntui_AddListItem{*listView,-1,"\p"+icon+"|\b"+name+"|"+b+"|"+d+"",0,1234,flags}
        End If
      Until name=""

    Case "AIDE::FAVORITES"
      If AIDE\FavoriteT
        pft_Sort{AIDE\FavoriteT}
        modified.l = False
        pft_Reset{AIDE\FavoriteT}
        While pft_GetNextItem{AIDE\FavoriteT}
          name.s = pft_GetKey{AIDE\FavoriteT}
          device.s = dos_DevicePart{name}
          If dos_Exist{name}=False
            pft_AddItem{AIDE\FavoriteT,name,""} : modified+1
          Else
            FileLister_AddFile{*listView,name}
          End If
        Wend
        If modified Then pft_Save{AIDE\FavoriteT,AIDE\FavoriteFileName}
      End If

    Default
      path = GetDosFileName{path}
      ;lock.l = Lock_ (&path,#ACCESS_READ)
      ;If lock
        ;MaxLen buff.s = 1024
          ;NameFromLock_ lock,&buff,1023
          ;path = Peek.s(&buff)

          If path><"" AND AIDE\FavoriteT><Null
            count$ = pft_FindItem{AIDE\FavoriteT,path}
            If count$=""
              count$="1"
            Else
              countL.l = Vallong(count$)
              count$=Str$(countL+1)
            End If
            pft_AddItem{AIDE\FavoriteT,path,count$}
          End If
        ;UnLock_ lock
      ;End If
      AIDE\Prefs\FileListPath = path
      Repeat
        name.s = dos_ScanDir{path,pattern}
        If name Then FileLister_AddFile{*listView,name}
      Until name=""

  End Select

  ntui_SetStringByID{*ntui,!obj_filelist_path   ,AIDE\Prefs\FileListPath}
  ntui_SetStringByID{*ntui,!obj_filelist_pattern,AIDE\DocType[#DOCTYPE_DEFAULT]\Pattern}

End Statement


Function.tuiGroup Source_FindActive{}

  *win.tuiWindow = (.tuiWindow)ntui_GetObjectByID{*ntui,!win_main}
  If *win
    *tab.tuiTabView = (.tuiTabView)ntui_GetObjectByID{*win,!obj_main_sourcetab}
    If *tab
      *group.tuiGroup = Null
      If ntui_GetAttr{*tab,#TUITVA_ACTIVETABOBJ,&*group}
        Function Return *group
      End If
    End If
  End If

  Function Return Null

End Function


Function.l Document_FindBySource{*source.tuiGroup}

  For docX.l=0 To #DOCUMENT_MAX-1
    If AIDE\Document[docX]\IsUsed
      If *source = AIDE\Document[docX]\Source Then Function Return docX
    End If
  Next

  Function Return -1

End Function


Statement Document_SetStatusMessage{docX.l,status.s}

  !If_BadDocX_Then{ Statement Return }
  If AIDE\Document[docX]\Source
    ntui_SetStringByID{AIDE\Document[docX]\Source,!obj_source_dstatus,status}
  End If

End Statement


Function.l Document_FindByTextBox{*textBox.tuiTextBox}

  For docX.l=0 To #DOCUMENT_MAX-1
    If AIDE\Document[docX]\IsUsed
      If AIDE\Document[docX]\TextBox = *textBox Function Return docX
    End If
  Next

  Function Return -1

End Function


Function.l Document_IsEdited{docX.l}

  !If_BadDocX_Then{ Function Return False }
  ntui_GetAttr{AIDE\Document[docX]\TextBox,#TUITBA_EDITED,&edited.l}
  Function Return edited

End Function


Function.l Document_CanUndo{docX.l}

  !If_BadDocX_Then{ Function Return False }
  ntui_GetAttr{AIDE\Document[docX]\TextBox,#TUITBA_UNDOSTEPS,&steps.l}
  Function Return steps

End Function


; get the document index from current tab
Function.l Document_FindActive{}

  If *ntui=Null Then Function Return -1
  *source.tuiGroup = Source_FindActive{}
  Function Return Document_FindBySource{*source}

End Function


Function.s Document_GetFileName{docX.l}

  !If_BadDocX_Then{ Function Return ""}

  If ntui_GetAttr{AIDE\Document[docX]\TextBox,#TUITBA_FILENAME,&filenameP.l}
    If filenameP Then Function Return Peek.s(filenameP)
  End If

  Function Return ""

End Function


Function.l Document_GetCursorLine{docX.l}

  !If_BadDocX_Then{ Function Return 0}

  If ntui_GetAttr{AIDE\Document[docX]\TextBox,#TUITBA_CURSORLINE,&lpos.l}
    Function Return lpos
  End If

  Function Return 0

End Function


Function.s Document_GetImageFile{docX.l}

  !If_BadDocX_Then{ Function Return "" }
  Function Return AIDE\Document[docX]\ImageFile

End Function


Function.l Document_SetTitle{docX.l,title.s,image.s}

  !If_BadDocX_Then{ Function Return False}

  *tab.tuiObject = ntui_GetObjectByID{*ntui,!obj_main_sourcetab}
  *source.tuiGroup = AIDE\Document[docX]\Source
  If *source
    If title="" Then title = AIDE\Document[docX]\Title     : Else AIDE\Document[docX]\Title     = title
    If image="" Then image = AIDE\Document[docX]\ImageFile : Else AIDE\Document[docX]\ImageFile = image

    If dos_Exist{image+".info"}=False
      image = AIDE\DocType[AIDE\Document[docX]\DocType]\DefIcon
    End If

    If Document_IsEdited{docX}      Then image = image + "|edit"   : ntui_SetAttr{*source,#TUIA_BOLD,True}       : Else ntui_SetAttr{*source,#TUIA_BOLD,False}
    If AIDE\Document[docX]\IsLocked Then image = image + "|off" ;: ntui_SetAttr{*source,#TUIA_UNDERLINED,True} : Else ntui_SetAttr{*source,#TUIA_UNDERLINED,False}
    ntui_SetAttr{*source,#TUIGA_IMAGE,&image}

    ntui_SetString{*source,title}
    ntui_Refresh{*tab,Null}
    succ.l = True
  End If

  Function Return succ

End Function


Function.l Document_GetDocType{docX.l}

  !If_BadDocX_Then{ Function Return #DOCTYPE_DEFAULT}

  Function Return AIDE\Document[docX]\DocType

End Function


SHARED updatecount.l
Statement AIDE_UpdateGui{}
  updatecount+1
  docX.l       = Document_FindActive{}
  docTypeX.l   = Document_GetDocType{docX}
  thisEdit.l   = False
  allEdit.l    = False
  canUndo.l    = False
  canBuildSource.l  = False
  canDebugSource.l  = False
  canBuildProject.l = False
  canDebugProject.l = False
  noProject.l  = True

  For n.l=0 To #DOCUMENT_MAX-1
    If AIDE\Document[n]\IsUsed
      If Document_IsEdited{n}
        allEdit = True
        If docX = n Then thisEdit = True
      End If
      If docX=n
        canUndo = Document_CanUndo{n}
        If AIDE\DocType[docTypeX]\BuildSource  Then canBuildSource=True
        If AIDE\DocType[docTypeX]\DebugSource  Then canDebugSource=True
        If AIDE\DocType[docTypeX]\BuildProject AND noProject=False Then canBuildProject=True
        If AIDE\DocType[docTypeX]\DebugProject AND noProject=False Then canDebugProject=True
      End If
    End If
  Next

  For n.l=0 To 1
    Select n
      Case 0
        *parent.tuiObject = ntui_GetObjectByID{*ntui,!obj_main_toolbar}
      Case 1
        *parent.tuiObject = ntui_GetObjectByID{*ntui,!obj_main_menubar}
    End Select


    ; project control
    ntui_SetAttrByID{*parent,!obj_project_build   ,#TUIA_DISABLED,AIDE\IsBuilding OR canBuildProject=False}
    ntui_SetAttrByID{*parent,!obj_project_rebuild ,#TUIA_DISABLED,AIDE\IsBuilding OR canBuildProject=False}
    ntui_SetAttrByID{*parent,!obj_project_debug   ,#TUIA_DISABLED,AIDE\IsBuilding OR canDebugProject=False}
    ntui_SetAttrByID{*parent,!obj_project_clean   ,#TUIA_DISABLED,AIDE\IsBuilding OR canBuildProject=False}
    ntui_SetAttrByID{*parent,!obj_project_save    ,#TUIA_DISABLED,AIDE\IsBuilding OR noProject}
    ntui_SetAttrByID{*parent,!obj_project_saveas  ,#TUIA_DISABLED,AIDE\IsBuilding OR noProject}
    ntui_SetAttrByID{*parent,!obj_project_export  ,#TUIA_DISABLED,AIDE\IsBuilding OR noProject}
    ntui_SetAttrByID{*parent,!obj_project_settings,#TUIA_DISABLED,AIDE\IsBuilding OR noProject}
    ntui_SetAttrByID{*parent,!obj_project_close   ,#TUIA_DISABLED,AIDE\IsBuilding OR noProject}
    ntui_SetAttrByID{*parent,!obj_project_open    ,#TUIA_DISABLED,AIDE\IsBuilding OR noProject}
    ntui_SetAttrByID{*parent,!obj_project_new     ,#TUIA_DISABLED,AIDE\IsBuilding OR noProject}

    ; source control
    ntui_SetAttrByID{*parent,!obj_source_build    ,#TUIA_DISABLED,AIDE\IsBuilding OR (AIDE\IsDebugging) OR canBuildSource=False}
    ntui_SetAttrByID{*parent,!obj_source_debug    ,#TUIA_DISABLED,AIDE\IsBuilding OR canDebugSource=False}
    ntui_SetAttrByID{*parent,!obj_source_save     ,#TUIA_DISABLED, (thisEdit=False)}
    ntui_SetAttrByID{*parent,!obj_source_saveall  ,#TUIA_DISABLED, (allEdit =False)}

    ntui_SetAttrByID{*parent,!obj_source_undo     ,#TUIA_DISABLED,(canUndo=False)}

    ; debugger control
    ntui_SetAttrByID{*parent,!obj_debug_continue  ,#TUIA_DISABLED,AIDE\IsDebugging=False}
    ntui_SetAttrByID{*parent,!obj_debug_break     ,#TUIA_DISABLED,AIDE\IsDebugging=False}
    ntui_SetAttrByID{*parent,!obj_debug_step      ,#TUIA_DISABLED,AIDE\IsDebugging=False}
    ntui_SetAttrByID{*parent,!obj_debug_stepin    ,#TUIA_DISABLED,AIDE\IsDebugging=False}
    ntui_SetAttrByID{*parent,!obj_debug_stepout   ,#TUIA_DISABLED,AIDE\IsDebugging=False}
    ntui_SetAttrByID{*parent,!obj_debug_end       ,#TUIA_DISABLED,AIDE\IsDebugging=False}
  Next

End Statement


Document_OnEdit:
Function.l Document_OnEdit{*textBox.tuiTextBox,*ev.tuiEvent,*notifyId.str}

  docX.l = Document_FindByTextBox{*textBox}
  If docX>=0
    Document_SetTitle{docX,"",""}
  End If
  AIDE_UpdateGui{}

End Function
!_MakeGlobalFuncPointer{Document_OnEdit,{Null,Null,Null}}


Statement Document_RemDocType{docX.l}

  !If_BadDocX_Then{ Statement Return}

  oldDocType.l = AIDE\Document[docX]\DocType
  If AIDE\DocType[oldDocType]\Detach
    !_CallFuncPointer{AIDE\DocType[oldDocType]\Detach,res.l,docX}
  End If

  AIDE\Document[docX]\DocType = #DOCTYPE_DEFAULT
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_STYLECB,Null}

End Statement


Function.l Document_SetDocType{docX.l,docType.l}

  !If_BadDocX_Then{ Function Return False }

  Document_RemDocType{docX.l}

  If AIDE\DocType[docType]\Attach
    !_CallFuncPointer{AIDE\DocType[docType]\Attach,res.l,docX}
  Else
    AIDE\Document[docX]\DocType = docType
    ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_STYLECB,Null}
    res.l = True
  End If

  Function Return res

End Function


Function.s Document_GetDosPattern{docX.l}

  !If_BadDocX_Then{ Function Return ""}

  Function Return AIDE\DocType[AIDE\Document[docX]\DocType]\Pattern

End Function


; find a source group by filename
Function.l Document_FindByFilename{findname.s}

  findlock.l = Lock_(&findname,#ACCESS_READ);
  If findlock=0 Then Function Return -1

  *source.tuiGroup = Null
  *win.tuiWindow = (.tuiWindow)ntui_GetObjectByID{*ntui,!win_main}
  If *win
    *tab.tuiTabView = (.tuiTabView)ntui_GetObjectByID{*win,!obj_main_sourcetab}
    If *tab
      *child.tuiObject = ntui_GetChildObject{*tab}
      While *child
        filelock.l = 0
        *tb.tuiTextBox = (.tuiTextBox)ntui_GetObjectByID{*child,!obj_source_text}
        If *tb
          If ntui_GetAttr{*tb,#TUITBA_FILENAME,&filenameP.l}
            If filenameP
              filelock = Lock_(filenameP,#ACCESS_READ)
              ;filename.s = Peek.s(filenameP)
            End If
          End If
        End If
        If SameLock_(filelock,findlock)=0
          *source = (.tuiGroup)*child
          *child = Null
        Else
          *child = ntui_GetNextObject{*child}
        End If
        If filelock Then UnLock_ filelock : filelock=0
      Wend
    End If
  End If
  If findlock Then UnLock_ findlock : findlock=0

  Function Return Document_FindBySource{*source}

End Function


; create a new document tab, but dont show it
Function.l Document_New{}

  ; find free document slot
  resultX.l = -1
  docX.l = 0
  While AIDE\Document[docX]\IsUsed=True AND docX<#DOCUMENT_MAX
    docX+1
  Wend
  If AIDE\Document[docX]\IsUsed=False
    *source.tuiGroup = Null
    *win.tuiWindow = (.tuiWindow)ntui_GetObjectByID{*ntui,!win_main}
    If *win
      *tab.tuiTabView = (.tuiTabView)ntui_GetObjectByID{*win,!obj_main_sourcetab}
      If *tab
        *source = (.tuiGroup)ntui_BuildFromXMLFile{*tab, dos_AddPart{AIDE\GuiPath,!file_fragment_source} }
        If *source
          *textBox.tuiTextBox = (.tuiTextBox)ntui_GetObjectByID{*source,!obj_source_text}
          If *textBox
            ntui_SetAttr{*source,#TUIA_USERDATA,docX}
            ntui_SetAttr{*textBox,#TUITBA_ONEDITCB,*Document_OnEdit}
            ntui_SetAttr{*textBox,#TUITBA_CURSORSTYLE,AIDE\Prefs\EditorCursorStyle}
            ntui_SetAttr{*textBox,#TUITBA_BLINKSPEED,AIDE\Prefs\EditorBlinkSpeed}
            AIDE\Document[docX]\Source   = *source
            AIDE\Document[docX]\TextBox  = *textBox
            AIDE\Document[docX]\IsUsed   = True
            AIDE\Document[docX]\DocType  = #DOCTYPE_DEFAULT
            AIDE\Document[docX]\Title    = "unnamed"
            AIDE\Document[docX]\IsLocked = False
            resultX.l = docX
            Document_SetTitle{docX,"unnamed","file"}
          End If
        End If
        If resultX<0
          If *source Then ntui_FreeObject{*source}
        End If
        ntui_Rethink{*tab}
      End If
    End If
  End If

  Function Return resultX

End Function


; save a document
Function.l Document_Save{docX.l,filename.s,@force.l}

  !If_BadDocX_Then{ Function Return False}
  succ.l = False

  If filename=""
    If ntui_GetAttr{AIDE\Document[docX]\TextBox,#TUITBA_FILENAME,&filenameP.l}
      If filenameP Then filename.s = Peek.s(filenameP)
    End If
  End If

  If filename
    filepart.s = dos_FilePart{filename}
    docType.l = DocType_Examine{filepart}
    If docType=#DOCTYPE_DEFAULT Then docType=AIDE\Document[docX]\DocType

    If AIDE\Document[docX]\DocType><docType
      Document_SetDocType{docX,docType}
    End If

    If AIDE\DocType[docType]\Export
      !_CallFuncPointer{AIDE\DocType[docType]\Export,err.l,docX,&filename}
    Else
      err.l = ntui_SaveTextBox{AIDE\Document[docX]\TextBox,&filename}
    End If

    If err=0
      ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_FILENAME,&filename}
      ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_EDITED,False}
      Document_SetTitle{docX,filepart,""}
      *tab.tuiObject = ntui_GetObjectByID{*ntui,!obj_main_sourcetab}
      ntui_Refresh{*tab,Null}
      succ=True
    End If
  End If

  AIDE_UpdateGui{}
  Function Return succ

End Function


; show a document (make active docX)
Statement Document_Show{docX.l}
 
  ;!If_BadDocX_Then{   Statement Return }
  If docX>=0
    ntui_SetAttrByID{*ntui,!obj_main_sourcetab,#TUITVA_ACTIVETABOBJ, AIDE\Document[docX]\Source}
  End If

  *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*ntui,!obj_src_list}
  If *lv
    ntui_ClearListView{*lv}
  End If
  
  If docX>=0
    docType.l = AIDE\Document[docX]\DocType

    If AIDE\Document[docX]\NeedScan=True

      AIDE\Document[docX]\NeedScan=False
      filename.s = Document_GetFileName{docX}

      If (AIDE\DocType[docType]\ScanSourceAsync)
        !_CallFuncPointer{AIDE\DocType[docType]\ScanSourceAsync, res.l, docX, &filename}
      Else
        If (AIDE\DocType[docType]\ScanSource)
          !_CallFuncPointer{AIDE\DocType[docType]\ScanSource, res.l, docX, &filename}
        End If
      End If

    End If
    
    If (AIDE\DocType[docType]\UpdateSDK)
      !_CallFuncPointer{AIDE\DocType[docType]\UpdateSDK, res.l, docX}
    End If
  End If

  If *lv 
    ntui_GetAttr{*lv,#TUILVA_TOTALITEMS,&items.l}
    If items=0
      title.s = ""
      ntui_SetAttr{*lv,#TUILVA_TITLE,&title}
      ntui_AddListItem{*lv,0,"<< no info available >>",-1,Null,#TUIF_DISABLED}
    End If
  End If

  AIDE_UpdateGui{}

End Statement


; closes the document of the current tab and the tab itself
Function.l Document_Close{docX.l}

  !If_BadDocX_Then{ Function Return False }

  Document_RemDocType{docX}

  *source.tuiGroup = AIDE\Document[docX]\Source
  If *source
    *tab.tuiTabView = (.tuiTabView)ntui_GetParentObject{*source}
    ntui_GetAttr{*tab,#TUITVA_ACTIVETAB,&tabX.l}
    If ntui_GetAttr{*source,#TUIA_USERDATA,&testX.l}
      If testX><docX Then error{"Internal Error: DocX mismatch!"}
    End If
    ntui_FreeObject{*source}
    ntui_Rethink{*tab}
    ntui_GetAttr{*tab,#TUITVA_NUMTABS,&tabN.l}
    If tabX>=tabN Then tabX-1
    ntui_SetAttr{*tab,#TUITVA_ACTIVETAB,tabX}
  End If
  AIDE\Document[docX]\IsUsed = False
  AIDE\Document[docX]\Source = Null
  docX.l = Document_FindActive{}
  Document_Show{docX.l}
  ;AIDE_UpdateGui{}

  Function Return True

End Function


Statement Document_SetCursor{docX.l,lpos.l,cpos.l}

  !If_BadDocX_Then{ Statement Return}
  
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_CURSORLINE,lpos}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_CURSORCHAR,cpos}
  
End Statement

Statement Document_JumpTo{docX.l,lpos.l,cpos.l,@focus.l}

  !If_BadDocX_Then{ Statement Return}
  
  docY.l = Document_FindActive{}
  If docY><docX Then Document_Show{docX}
  
  Document_SetCursor{docX,lpos,cpos}  
 
  ; make sure lpos is nicely visible
  ntui_GetAttr{AIDE\Document[docX]\TextBox,#TUITBA_TOPLINE,&tlpos.l}
  ntui_GetAttr{AIDE\Document[docX]\TextBox,#TUITBA_VISIBLELINES,&vlpos.l}
  ntui_GetAttr{AIDE\Document[docX]\TextBox,#TUITBA_TOTALLINES,&tlines.l}
  
  mlpos.l = lpos - vlpos/3 ; in the upper third...
  If tlines-vlpos<mlpos Then mlpos=tlines-vlpos

  If mlpos>=0
    ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_TOPLINE,mlpos}
  End If
  
  If focus Then ntui_SetFocus{AIDE\Document[docX]\TextBox}

End Statement


Statement Document_Scan_dep{docX.l}

  !If_BadDocX_Then{ Statement Return}

  filename.s = Document_GetFileName{docX}

  docType.l = AIDE\Document[docX]\DocType
  If AIDE\DocType[docType]\ScanSource

    If filename=""
      error{"No file is associated with this document."}
      Statement Return
    End If

    !_CallFuncPointer{AIDE\DocType[docType]\ScanSource, res.l, docX, &filename}
    AIDE_UpdateGui{}
  ;Else
    ;error{"No scanning configured for this file type."}
  End If

End Statement


; load a document (but dont show it)
Function.l Document_Load{docX.l,filename.s}

  !If_BadDocX_Then{ Function Return False }

  succ.l = False
  docType.l = -1
  filepart.s = dos_FilePart{filename}
  docType = DocType_Examine{filepart}

  If Document_SetDocType{docX,docType}

    If AIDE\DocType[docType]\Import
      !_CallFuncPointer{AIDE\DocType[docType]\Import,err.l,docX,&filename}
    Else      
      err.l = ntui_LoadTextBox{AIDE\Document[docX]\TextBox,&filename}
    End If

    If err=0
      ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_EDITED,False}
      ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_READONLY,AIDE\Document[docX]\IsLocked}
      Document_SetTitle{docX.l,filepart,filename}
      *tab.tuiObject = ntui_GetObjectByID{*ntui,!obj_main_sourcetab}
      ntui_Refresh{*tab,Null}
      succ = True
      AIDE\Document[docX]\NeedScan=True
    End If

  End If
  Function Return succ

End Function


; open a new document
Function.l Document_Open{filename.s}

  docX.l = Document_FindByFilename{filename}
  If docX<0
    docX = Document_New{}
    If docX>=0 Then Document_Load{docX,filename}
  End If

  Function Return docX

End Function


Statement Document_Debug{docX.l}

  !If_BadDocX_Then{ Statement Return}

  filename.s = Document_GetFileName{docX}
  edited.w   = Document_IsEdited{docX}

  docType.l = AIDE\Document[docX]\DocType
  If AIDE\DocType[docType]\DebugSource

    If filename=""
      error{"No file is associated with this document."}
      Statement Return
    End If

    If edited
      If Document_Save{docX,filename}=False
        error{"Unable to save document."}
        Statement Return
      End If
    End If

    !_CallFuncPointer{AIDE\DocType[docType]\DebugSource, res.l, docX, &filename}
    If res=0
      AIDE\IsDebugging=True
      AIDE\IsBuilding =True
    Else
      AIDE\IsDebugging=False
      AIDE\IsBuilding=False
    End If
    AIDE_UpdateGui{}
  Else
    error{"No debugging configured for this file type."}
  End If

End Statement


Statement Document_Build{docX.l}

  !If_BadDocX_Then{Statement Return}

  filename.s = Document_GetFileName{docX}
  edited.w   = Document_IsEdited{docX}

  docType.l = AIDE\Document[docX]\DocType
  If AIDE\DocType[docType]\BuildSource

    If filename=""
      error{"No file is associated with this document."}
      Statement Return
    End If

    If edited
      If Document_Save{docX,filename}=False
        error{"Unable to save document."}
        Statement Return
      End If
    End If

    !_CallFuncPointer{AIDE\DocType[docType]\BuildSource, res.l, docX, &filename}
    If res=0
      AIDE\IsBuilding = True
    Else
      AIDE\IsBuilding = False
    End If
    AIDE_UpdateGui{}
  Else
    error{"No build configured for this file type."}
  End If

End Statement


Function.l Document_ReplaceSelectedText{docX.l,replace.s,find.s,all.l}

  !If_BadDocX_Then{Function Return False}

  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  If *textBox=Null Then Function Return False
  If AIDE\Prefs\EscapeSearch
    find    = UnescapeString{find}
    replace = UnescapeString{replace}
  End If

  Function Return ntui_ReplaceTextBoxText{*textBox,&replace,FLen(replace),&find,FLen(find),AIDE\Prefs\CaseSensitiveSearch,all}

End Function


Function.l Document_SelectSearchText{docX.l,needle.s,direction.l}
  DEFTYPE.longP lposP,cposP,slposP,scposP

  !If_BadDocX_Then{Function Return False}

  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  If *textBox=Null Then Function Return False

  If AIDE\Prefs\EscapeSearch
    needle = UnescapeString{needle}
  End If


  ntui_GetAttr{*textBox,#TUITBA_CURSORLINE,lposP}
  ntui_GetAttr{*textBox,#TUITBA_CURSORCHAR,cposP}
  succ.l = False
  Select direction
    Case 1:
      succ = ntui_FindNextTextBoxText{*textBox,&needle,FLen(needle),lposP,cposP,AIDE\Prefs\CaseSensitiveSearch}
      If succ=False
        lposP\l = 0 : cposP\l = 0
        succ = ntui_FindNextTextBoxText{*textBox,&needle,FLen(needle),lposP,cposP,AIDE\Prefs\CaseSensitiveSearch}
      End If

    Case -1:
      _tb_seek{*textBox,lposP,cposP,-1}
      succ = ntui_FindPrevTextBoxText{*textBox,&needle,FLen(needle),lposP,cposP,AIDE\Prefs\CaseSensitiveSearch}
      If succ=False
        ntui_GetAttr{*textBox,#TUITBA_TOTALLINES,lposP}
        cposP\l = 0
        ;ntui_GetAttr{*textBox,#TUITBA_TOTALLINES,cposP}
        succ = ntui_FindPrevTextBoxText{*textBox,&needle,FLen(needle),lposP,cposP,AIDE\Prefs\CaseSensitiveSearch}
      End If

    Default:
      ntui_GetAttr{*textBox,#TUITBA_BEGINSELECTLINE,slposP}
      ntui_GetAttr{*textBox,#TUITBA_BEGINSELECTCHAR,scposP}
      If slposP\l>=0
        lposP\l = slposP\l
        cposP\l = scposP\l
      End If
      succ = ntui_FindNextTextBoxText{*textBox,&needle,FLen(needle),lposP,cposP,AIDE\Prefs\CaseSensitiveSearch}
      If succ=False
        lposP\l = 0 : cposP\l = 0
        succ = ntui_FindNextTextBoxText{*textBox,&needle,FLen(needle),lposP,cposP,AIDE\Prefs\CaseSensitiveSearch}
      End If

  End Select

  If succ
    ntui_SetAttr{*textBox,#TUITBA_CURSORLINE,lposP\l}
    ntui_SetAttr{*textBox,#TUITBA_CURSORCHAR,cposP\l+FLen(needle)}
    ntui_SetTextBoxSelection{*textBox,Null,lposP\l,cposP\l,lposP\l,cposP\l+FLen(needle)}
    ntui_Refresh{*textBox,Null}
  End If
  
  Function Return succ

End Function


; ========================== DOCTYPES =========================
XINCLUDE "AIDE_XML.ab3"
XINCLUDE "AIDE_AmigaGuide.ab3"
XINCLUDE "AIDE_AmiBlitz3.ab3"
XINCLUDE "AIDE_Makefile.ab3"
XINCLUDE "AIDE_C.ab3"
XINCLUDE "AIDE_Console.ab3"
XINCLUDE "AIDE_SearchHighlight.ab3"
XINCLUDE "AIDE_AISS.ab3"
; =============================================================


Statement Prefs_Write{icon.s}

  dos_SetToolValue  {"GUILayout"          ,AIDE\Prefs\GUILayout          ,icon}
  dos_SetToolBool   {"CaseSensitiveSearch",AIDE\Prefs\CaseSensitiveSearch,icon}
  dos_SetToolBool   {"EscapeSearch"       ,AIDE\Prefs\EscapeSearch       ,icon}
  dos_SetToolBool   {"ShowWelcome"        ,AIDE\Prefs\ShowWelcome        ,icon}
  dos_SetToolValue  {"EditorBlinkSpeed"   ,AIDE\Prefs\EditorBlinkSpeed   ,icon}
  dos_SetToolValue  {"EditorCursorStyle"  ,AIDE\Prefs\EditorCursorStyle  ,icon}
  dos_SetToolBool   {"AutoFormat"         ,AIDE\Prefs\AutoFormat         ,icon}
  dos_SetToolBool   {"BoldTokens"         ,AIDE\Prefs\BoldTokens         ,icon}
  dos_SetToolBool   {"ItalicComments"     ,AIDE\Prefs\ItalicComments     ,icon}
  dos_SetToolString {"PubScreenName"      ,AIDE\Prefs\PubScreenName      ,icon}
  dos_GetToolString {"AREXXPort"          ,AIDE\Prefs\AREXXPort          ,icon}
  dos_SetToolBool   {"OpenLastSource"     ,AIDE\Prefs\OpenLastSource     ,icon}
  dos_SetToolString {"SourceCodeFontName" ,AIDE\Prefs\SourceCodeFontName ,icon}
  dos_SetToolValue  {"SourceCodeFontSize" ,AIDE\Prefs\SourceCodeFontSize ,icon}
  dos_SetToolString {"AppIcon"            ,AIDE\Prefs\AppIcon            ,icon}
  dos_SetToolString {"FileListPath"       ,AIDE\Prefs\FileListPath       ,icon}
  dos_SetToolString {"DefIconFolder"      ,AIDE\Prefs\DefIconFolder      ,icon}
  dos_SetToolString {"DefIconAssign"      ,AIDE\Prefs\DefIconAssign      ,icon}
  dos_SetToolString {"DefIconDevice"      ,AIDE\Prefs\DefIconDevice      ,icon}
  dos_SetToolString {"LastMajorVersion"   ,"\\__VER_MAJOR"               ,icon}
  dos_SetToolString {"LastMinorVersion"   ,"\\__VER_MINOR"               ,icon}
  dos_SetToolValue  {"NTUIBorderStyle"    ,AIDE\Prefs\NTUIBorderStyle    ,icon}
  dos_SetToolValue  {"NTUIFillStyle"      ,AIDE\Prefs\NTUIFillStyle      ,icon}

  For n.l=0 To #DOCTYPE_MAX-1
    If AIDE\DocType[n]\Pattern><"" Then dos_SetToolString {"Pattern"+Str$(n+1) , AIDE\DocType[n]\Pattern  ,icon}
    If AIDE\DocType[n]\DefIcon><"" Then dos_SetToolString {"DefIcon"+Str$(n+1) , AIDE\DocType[n]\DefIcon  ,icon}

    If AIDE\DocType[n]\WritePrefs
      !_CallFuncPointer{AIDE\DocType[n]\WritePrefs,res.l,&icon}
    End If
  Next

  documents.s = ""
  For docX.l=0 To #DOCUMENT_MAX-1
    If AIDE\Document[docX]\IsUsed
      If documents><"" Then documents + "|"
      name.s = Document_GetFileName{docX}
      name = Replace$(name,"\","\"+"\")
      name = Replace$(name,"|","\|")
      name = Replace$(name,"@","\@")
      documents + Document_GetFileName{docX}
      lpos.l = Document_GetCursorLine{docX}
      If lpos>0 Then documents + "@"+Str$(lpos)
    End If
  Next

  dos_SetToolString {"OpenDocuments"       ,documents ,icon}
  docX.l = Document_FindActive{}
  dos_SetToolString{"ActiveDocument" , Document_GetFileName{docX} ,icon}

  If AIDE\FavoriteT 
    pft_Save{AIDE\FavoriteT,AIDE\FavoriteFileName}
  End If

End Statement


Statement AIDE_Deinit{exitcode.l}

  If *ntui
    ntui_Iconify{*ntui}
    ;AIDE\Prefs\FileListPath = ntui_GetStringByID{*ntui,!obj_filelist_path}
  End If
  
  If exitcode = 0 Then Prefs_Write{AIDE\Icon}

  For docX.l=0 To #DOCUMENT_MAX-1
    If AIDE\Document[docX]\IsUsed
      Document_Close{docX}
    End If
  Next

  For docType.l=0 To #DOCTYPE_MAX-1
    If AIDE\DocType[docType]\Deinit
      !_CallFuncPointer{AIDE\DocType[docType]\Deinit,res.l}
    End If
  Next

  If *ntui
    ntui_FreeEngine{*ntui}
    *ntui = Null
  End If

  If AIDE\FavoriteT Then pft_Free{AIDE\FavoriteT} : AIDE\FavoriteT = Null

  installLock.l = CurrentDir_(AIDE\CallDirLock) : AIDE\CallDirLock = 0
  If installLock Then UnLock_ installLock
  
  If AIDE\AddAssignDone Then dos_RemAssign{"Libs",dos_AddPart{AIDE\InstallPath,"Libs"}} : AIDE\AddAssignDone = False

End Statement


Statement Prefs_Apply{}

  For docX.l=0 To #DOCUMENT_MAX-1
    If AIDE\Document[docX]\IsUsed
      If AIDE\Document[docX]\TextBox><Null
        ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_CURSORSTYLE,AIDE\Prefs\EditorCursorStyle}
        ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_BLINKSPEED,AIDE\Prefs\EditorBlinkSpeed}
      End If
    End If
  Next
  ntui_SetAttr{*ntui,#TUIEA_FILLSTYLE,AIDE\Prefs\NTUIFillStyle}
  ntui_SetAttr{*ntui,#TUIEA_BORDERSTYLE,AIDE\Prefs\NTUIBorderStyle}
  ntui_SetAttr{*ntui,#TUIEA_PUBSCREENNAME,&AIDE\Prefs\PubScreenName}
  
End Statement


Statement Prefs_Read{icon.s}

  AIDE\Prefs\GUILayout           = dos_GetToolValue  {"GUILayout"          ,1             ,icon}
  AIDE\Prefs\CaseSensitiveSearch = dos_GetToolValue  {"CaseSensitiveSearch",False         ,icon}
  AIDE\Prefs\EscapeSearch        = dos_GetToolValue  {"EscapeSearch"       ,False         ,icon}   
  AIDE\Prefs\ShowWelcome         = dos_GetToolValue  {"ShowWelcome"        ,True          ,icon}
  AIDE\Prefs\EditorCursorStyle   = dos_GetToolValue  {"EditorCursorStyle"  ,#TUITBCS_LINE ,icon}
  AIDE\Prefs\EditorBlinkSpeed    = dos_GetToolValue  {"EditorBlinkSpeed"   ,3             ,icon}
  AIDE\Prefs\AutoFormat          = dos_GetToolValue  {"AutoFormat"         ,True          ,icon}
  AIDE\Prefs\BoldTokens          = dos_GetToolValue  {"BoldTokens"         ,True          ,icon}
  AIDE\Prefs\ItalicComments      = dos_GetToolValue  {"ItalicComments"     ,True          ,icon}
  AIDE\Prefs\PubScreenName       = dos_GetToolString {"PubScreenName"      ,"Workbench"   ,icon}
  AIDE\Prefs\AREXXPort           = dos_GetToolString {"AREXXPort"          ,"AIDE_REXX"   ,icon}
  AIDE\Prefs\OpenLastSource      = dos_GetToolValue  {"OpenLastSource"     ,True          ,icon}
  AIDE\Prefs\SourceCodeFontName  = dos_GetToolString {"SourceCodeFontName" ,""            ,icon}
  AIDE\Prefs\SourceCodeFontSize  = dos_GetToolValue  {"SourceCodeFontSize" ,-1            ,icon}
  AIDE\Prefs\AppIcon             = dos_GetToolString {"AppIcon"            ,icon          ,icon}
  AIDE\Prefs\FileListPath        = dos_GetToolString {"FileListPath"       ,""            ,icon}
  AIDE\Prefs\OpenDocs            = dos_GetToolString {"OpenDocuments"      ,""            ,icon}
  AIDE\Prefs\ActiveDocument      = dos_GetToolString {"ActiveDocument"     ,""            ,icon}
  AIDE\Prefs\NTUIBorderStyle     = dos_GetToolValue  {"NTUIBorderStyle"    ,0             ,icon}
  AIDE\Prefs\NTUIFillStyle       = dos_GetToolValue  {"NTUIFillStyle"      ,0             ,icon}
  
  ;/* check if the version has changed to last start... */
  AIDE\LastMajorVersion          = dos_GetToolValue  {"LastMajorVersion" ,0             ,icon}
  AIDE\LastMinorVersion          = dos_GetToolValue  {"LastMinorVersion" ,0             ,icon}
  AIDE\RefreshAll                = False
  If AIDE\LastMajorVersion><Vallong("\\__VER_MAJOR") OR AIDE\LastMinorVersion><Vallong("\\__VER_MINOR")
    AIDE\RefreshAll              = True
    dos_Delete{AIDE\FavoriteFileName}
  EndIf
  
  AIDE\Prefs\DefIconFolder       = dos_GetToolString {"DefIconFolder"      ,"folder"      ,icon}
  AIDE\Prefs\DefIconAssign       = dos_GetToolString {"DefIconAssign"      ,"assign"      ,icon}
  AIDE\Prefs\DefIconDevice       = dos_GetToolString {"DefIconDevice"      ,"device"      ,icon}

  AIDE\DocType[#DOCTYPE_DEFAULT   ]\Pattern = "~(#?.(xtra|bak|info|svn))"
  AIDE\DocType[#DOCTYPE_TEXT      ]\Pattern = "#?.(txt|readme)"
  AIDE\DocType[#DOCTYPE_AREXX     ]\Pattern = "#?.(rx|arexx|rexx)"
  AIDE\DocType[#DOCTYPE_XML       ]\Pattern = "#?.(xml|html)"
  
  AIDE\DocType[#DOCTYPE_DEFAULT   ]\DefIcon = dos_AddPart{AIDE\GuiPath,"icons/def_default.info"}
  AIDE\DocType[#DOCTYPE_TEXT      ]\DefIcon = dos_AddPart{AIDE\GuiPath,"icons/def_text.info"}
  AIDE\DocType[#DOCTYPE_AREXX     ]\DefIcon = dos_AddPart{AIDE\GuiPath,"icons/def_rexx.info"}
  AIDE\DocType[#DOCTYPE_XML       ]\DefIcon = dos_AddPart{AIDE\GuiPath,"icons/def_xml.info"}

  StartUp_Message{"loading favorites..."}
  If dos_Exist{AIDE\FavoriteFileName} Then AIDE\FavoriteT = pft_Load{AIDE\FavoriteFileName}
  If AIDE\FavoriteT=Null Then AIDE\FavoriteT = pft_Create{1024}

  StartUp_Message{"initializing file types..."}
  tempbuffer.s = LSet$(" ",1024)
  For n.l=0 To #DOCTYPE_MAX-1
    AIDE\DocType[n]\Pattern = dos_GetToolString {"Pattern"+Str$(n+1) , AIDE\DocType[n]\Pattern  ,icon}
    AIDE\DocType[n]\DefIcon = dos_GetToolString {"DefIcon"+Str$(n+1) , AIDE\DocType[n]\DefIcon  ,icon}
    DocType_SetPattern{n,AIDE\DocType[n]\Pattern}
    If AIDE\DocType[n]\ReadPrefs
      !_CallFuncPointer{AIDE\DocType[n]\ReadPrefs,res.l,&icon}
    End If
  Next

  ;StartUp_Message{"scan AISS folder..."}
  ;AISS_Refresh{"","",True}

  ; just a hack to make sure AB3 gets initialized
  ;If AIDE\RefreshAll
  ;  _AmiBlitz3_Prepare{True}
  ;  AIDE\RefreshAll = False
  ;End If

End Statement


Statement StartUp_OpenWorkSpace{}

  opendocs.s = AIDE\Prefs\OpenDocs
  
  apos.l = 1
  StartUp_Message{"opening workspace..."}
  Repeat
    bpos.l = Instr(opendocs,"|",apos)
    If bpos<=0 Then bpos=FLen(opendocs)+1
    If bpos>apos
      filename.s = Mid$(opendocs,apos,bpos-apos)
      cpos.l = Instr(filename,"@")
      lpos.l = 0
      If cpos>0
        lpos.l     = Vallong(Mid$(filename,cpos+1,FLen(filename)-cpos))
        filename.s = Left$(filename,cpos-1)
      End If
      If dos_Exist{filename}
        StartUp_Message{"opening "+dos_FilePart{filename}+"..."}
        docX.l = Document_Open{filename}
        Document_SetCursor{docX,lpos,cpos}
      End If
    End If
    apos = bpos+1
  Until apos>=FLen(opendocs)

End Statement


;/* open window functions */
Function.tuiWindow Window_Main{}

  *winmain.tuiWindow = ntui_GetWindowByID{*ntui,!win_main}
  If *winmain
    ntui_FreeObject{*winmain}
    *winmain = Null
  End If
    
  Select AIDE\Prefs\GUILayout
    Case #GUILAYOUT_MEDIUM:
      *winmain.tuiWindow = ntui_GetWindow{ntui_BuildFromXMLFile{*ntui,dos_AddPart{AIDE\GuiPath,!file_win_main_mid}}}
    Case #GUILAYOUT_LARGE:
      *winmain.tuiWindow = ntui_GetWindow{ntui_BuildFromXMLFile{*ntui,dos_AddPart{AIDE\GuiPath,!file_win_main_large}}}
    Default:
      *winmain.tuiWindow = ntui_GetWindow{ntui_BuildFromXMLFile{*ntui,dos_AddPart{AIDE\GuiPath,!file_win_main_small}}}
  End Select
  
  If *winmain = Null Then Function Return *winmain

  *holder_browser.tuiObject  = ntui_GetObjectByID{*winmain,!holder_browser}
  *holder_browser2.tuiObject = ntui_GetObjectByID{*winmain,!holder_browser2}
  *holder_browser3.tuiObject = ntui_GetObjectByID{*winmain,!holder_browser3}
  *holder_console.tuiObject  = ntui_GetObjectByID{*winmain,!holder_console}
  *holder_menu.tuiObject     = ntui_GetObjectByID{*winmain,!holder_menu}
  *holder_toolbar.tuiObject  = ntui_GetObjectByID{*winmain,!holder_toolbar}
  *holder_editor.tuiObject   = ntui_GetObjectByID{*winmain,!holder_editor}

  If *holder_browser3=Null Then *holder_browser3 = *holder_browser2
  If *holder_browser3=Null Then *holder_browser3 = *holder_browser
  If *holder_browser2=Null Then *holder_browser2 = *holder_browser
  
  If *holder_menu     Then ntui_BuildFromXMLFile{*holder_menu    ,dos_AddPart{AIDE\GuiPath,!file_fragment_menu}}
  If *holder_toolbar  Then ntui_BuildFromXMLFile{*holder_toolbar ,dos_AddPart{AIDE\GuiPath,!file_fragment_toolbar}}
  If *holder_console  Then ntui_BuildFromXMLFile{*holder_console ,dos_AddPart{AIDE\GuiPath,!file_fragment_console}}
  If *holder_browser  Then ntui_BuildFromXMLFile{*holder_browser ,dos_AddPart{AIDE\GuiPath,!file_fragment_filebrowser}}
  If *holder_browser2 Then ntui_BuildFromXMLFile{*holder_browser2,dos_AddPart{AIDE\GuiPath,!file_fragment_sourcebrowser}}
  If *holder_browser2 Then ntui_BuildFromXMLFile{*holder_browser2,dos_AddPart{AIDE\GuiPath,!file_fragment_projectbrowser}}
  If *holder_browser3 Then ntui_BuildFromXMLFile{*holder_browser3,dos_AddPart{AIDE\GuiPath,!file_fragment_ab3browser}}
  If *holder_browser3 Then ntui_BuildFromXMLFile{*holder_browser3,dos_AddPart{AIDE\GuiPath,!file_fragment_aissbrowser}}
  If *holder_editor   Then ntui_BuildFromXMLFile{*holder_editor  ,dos_AddPart{AIDE\GuiPath,!file_fragment_editor}}
  
  Function Return *winmain
  
End Function


Function.w Window_SetUpMain{}

  FileLister_Fill{!obj_filelist,AIDE\Prefs\FileListPath,AIDE\DocType[#DOCTYPE_DEFAULT]\Pattern}
  ntui_SetAttrByID{*ntui,!obj_main_console,#TUITBA_STYLECB,*_con_StyleCallback}
  ntui_SetValueByID{*ntui,!obj_find_docasesense,AIDE\Prefs\CaseSensitiveSearch}
  ntui_SetValueByID{*ntui,!obj_find_doescape   ,AIDE\Prefs\EscapeSearch}
  If AIDE\Prefs\EscapeSearch
    ntui_SetAttrByID{*ntui,!obj_find_string,#TUITBA_STYLECB,*_search_StyleCallback}
    ntui_SetAttrByID{*ntui,!obj_find_replacestring,#TUITBA_STYLECB,*_search_StyleCallback}
  Else
    ntui_SetAttrByID{*ntui,!obj_find_string,#TUITBA_STYLECB,Null}
    ntui_SetAttrByID{*ntui,!obj_find_replacestring,#TUITBA_STYLECB,Null}
  End If
  If AIDE\Prefs\PubScreenName="AIDE"
    ntui_SetAttrByID{*ntui,!win_main,#TUIWA_BORDERLESS,1}
  Else
    ntui_SetAttrByID{*ntui,!win_main,#TUIWA_BORDERLESS,0}
  End If
  AIDE_AutoLayout{}
  AIDE_UpdateGui{}
      
  If ntui_ShowWindowByID{*ntui,!win_main}=False Then error{"\\__THIS_FUNCTION: Unable to open main AIDE window!"}:Goto cleanup
      
  Function Return True

End Function


Statement Window_About{}

  If ntui_ShowWindowByID{*ntui,!win_about}=False
    ;*win.tuiWindow = ntui_GetWindow{ntui_BuildFromXMLMem{*ntui,?gui_about}}
    *win.tuiWindow = ntui_GetWindow{ntui_BuildFromXMLFile{*ntui,dos_AddPart{AIDE\GuiPath,!file_win_about}}}
    If *win
      ntui_SetStringByID{*win,!obj_about_version  ,"\\__VER_MAJOR.\\__VER_MINOR"}
      ntui_SetStringByID{*win,!obj_about_arexxport,AIDE\Prefs\AREXXPort}
      ntui_SetStringByID{*win,!obj_about_pubscreen,AIDE\Prefs\PubScreenName}
    End If
    If ntui_ShowWindowByID{*ntui,!win_about}=False Then error{"\\__THIS_FUNCTION: Unable to open About Window!"}
  End If

End Statement


Statement Document_ApplySettings{docX.l}

  !If_BadDocX_Then{ Statement Return }

  docType.l = AIDE\Document[docX]\DocType
  If AIDE\DocType[docType]\ApplySettings
    !_CallFuncPointer{AIDE\DocType[docType]\ApplySettings, res.l, docX}
  Else
    error{"No source settings available for this file type."}
  End If

End Statement


Statement Document_OpenSettings{docX.l}

  !If_BadDocX_Then{ Statement Return}

  docType.l = AIDE\Document[docX]\DocType
  If AIDE\DocType[docType]\OpenSettings
    !_CallFuncPointer{AIDE\DocType[docType]\OpenSettings, res.l, docX}
  Else
    error{"No source settings available for this file type."}
  End If

  ;*win.tuiWindow = ntui_GetWindowByID{*ntui,!win_source_settings,docX}
  ;If *win Then ntui_FreeObject{*win}
  ;If ntui_ShowWindowByID{*ntui,!win_source_settings,docX}=False
  ;  If ntui_ShowWindowByID{*ntui,!win_source_settings,docX}=False Then error{"\\__THIS_FUNCTION: Unable to open Settings Window!"}

End Statement


Statement Document_EditFunction{docX.l,func.s}
  !If_BadDocX_Then{Statement Return}

  If AIDE\Document[docX]\TextBox
    *tb.tuiTextBox = AIDE\Document[docX]\TextBox
    Select func
      Case "cut"       : key.s="x" : ntui_KeyStrokeTextBox{*tb,#RAWKEY_X,&key,#TUIQUAL_COM}
      Case "copy"      : key.s="c" : ntui_KeyStrokeTextBox{*tb,#RAWKEY_C,&key,#TUIQUAL_COM}
      Case "paste"     : key.s="v" : ntui_KeyStrokeTextBox{*tb,#RAWKEY_V,&key,#TUIQUAL_COM}
      Case "undo"      : key.s="z" : ntui_KeyStrokeTextBox{*tb,#RAWKEY_Z,&key,#TUIQUAL_COM}
      Case "selectall" : key.s="a" : ntui_KeyStrokeTextBox{*tb,#RAWKEY_A,&key,#TUIQUAL_COM}
      Case "delete"    : key.s="d" : ntui_KeyStrokeTextBox{*tb,#RAWKEY_D,&key,#TUIQUAL_COM}
    End Select
    ntui_SetFocus{*tb}
    ;ntui_Refresh{*tb,Null}
    AIDE_UpdateGui{}
  End If

End Statement


Statement Window_Calculator{}

  If ntui_ShowWindowByID{*ntui,!win_calculator}=False
    *win.tuiWindow = ntui_GetWindow{ntui_BuildFromXMLFile{*ntui,dos_AddPart{AIDE\GuiPath,!file_win_calculator}}}
    If ntui_ShowWindowByID{*ntui,!win_calculator}=False Then error{"\\__THIS_FUNCTION: Unable to open Calculator Window!"}
  End If

End Statement


Statement Prefs_SelectDoctype{doctypeX.l}

  If doctypeX<0 OR doctypeX>=#DOCTYPE_MAX
    ntui_SetAttrByID{*ntui,"obj_prefs_doctype_group",#TUIA_DISABLED,#TRUE}
  Else
    ntui_SetAttrByID{*ntui,"obj_prefs_doctype_group",#TUIA_DISABLED,#FALSE}
    ntui_SetStringByID{*ntui,"obj_prefs_doctype_icon",AIDE\DocType[doctypeX]\DefIcon}
    ntui_SetStringByID{*ntui,"obj_prefs_doctype_path",AIDE\DocType[doctypeX]\Name}
  End If
  
End Statement


Statement Window_Preferences{}

  If ntui_ShowWindowByID{*ntui,!win_preferences}=False
    *win.tuiWindow = ntui_GetWindow{ntui_BuildFromXMLFile{*ntui,dos_AddPart{AIDE\GuiPath,!file_win_preferences}}}
    If *win
      ntui_SetValueByID{*win,"obj_prefs_linecursor",       (AIDE\Prefs\EditorCursorStyle = #TUITBCS_LINE)}
      ntui_SetValueByID{*win,"obj_prefs_boldlinecursor",   (AIDE\Prefs\EditorCursorStyle = #TUITBCS_BOLDLINE)}
      ntui_SetValueByID{*win,"obj_prefs_blockcursor",      (AIDE\Prefs\EditorCursorStyle = #TUITBCS_BLOCK)}
      ntui_SetValueByID{*win,"obj_prefs_underscorecursor", (AIDE\Prefs\EditorCursorStyle = #TUITBCS_UNDERSCORE)}
      ntui_SetValueByID{*win,"obj_prefs_blinkspeed",        AIDE\Prefs\EditorBlinkSpeed}
      
      ntui_SetValueByID{*win,"obj_prefs_fillstyle",         AIDE\Prefs\NTUIFillStyle}
      ntui_SetValueByID{*win,"obj_prefs_borderstyle",       AIDE\Prefs\NTUIBorderStyle}
      If AIDE\Prefs\PubScreenName = "Workbench" Then scrmode.l = 0 : Else scrmode = 1
      ntui_SetValueByID{*win,"obj_prefs_screenmode",        scrmode}
      
      *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*ntui,"obj_prefs_doctype_list"}
      If *lv
        For doctypeX.l=0 To #DOCTYPE_MAX-1
          If AIDE\DocType[doctypeX]\Name><""
            image.s = "file"
            If AIDE\DocType[doctypeX]\DefIcon Then image=AIDE\DocType[doctypeX]\DefIcon
            lvitem.s = "\p"+image+"|"+AIDE\DocType[doctypeX]\Name
            ntui_AddListItem{*lv,0,lvitem,doctypeX,0,0}
          End If
        Next
      End If
    End If
    Prefs_SelectDoctype{-1}
    If ntui_ShowWindowByID{*ntui,!win_preferences}=False Then error{"\\__THIS_FUNCTION: Unable to open Preferences Window!"}
  End If

End Statement



Statement Prefs_ReadFromGui{}

  *win.tuiWindow = ntui_GetWindowByID{*ntui,!win_preferences}
  If *win=Null Then Statement Return
  If ntui_GetValueByID{*win,"obj_prefs_linecursor"}       Then AIDE\Prefs\EditorCursorStyle = #TUITBCS_LINE
  If ntui_GetValueByID{*win,"obj_prefs_boldlinecursor"}   Then AIDE\Prefs\EditorCursorStyle = #TUITBCS_BOLDLINE
  If ntui_GetValueByID{*win,"obj_prefs_blockcursor"}      Then AIDE\Prefs\EditorCursorStyle = #TUITBCS_BLOCK
  If ntui_GetValueByID{*win,"obj_prefs_underscorecursor"} Then AIDE\Prefs\EditorCursorStyle = #TUITBCS_UNDERSCORE
  AIDE\Prefs\EditorBlinkSpeed = ntui_GetValueByID{*win,"obj_prefs_blinkspeed"}
  
  ;ab3.s     = ntui_GetStringByID{*win,"obj_prefs_amiblitz3_compiler"} : If ab3     Then AmiBlitz3\Exe = ab3
  ;debug.s   = ntui_GetStringByID{*win,"obj_prefs_amiblitz3_debug"}    : If debug   Then AmiBlitz3\DebugSourceArgs = debug
  ;release.s = ntui_GetStringByID{*win,"obj_prefs_amiblitz3_release"}  : If release Then AmiBlitz3\BuildSourceArgs = release
  ;cpp.s     = ntui_GetStringByID{*win,"obj_prefs_cpp_compiler"}       : If cpp     Then CPP\Exe = cpp
  ;debug.s   = ntui_GetStringByID{*win,"obj_prefs_cpp_build"}          : If debug   Then CPP\BuildSourceArgs = debug
  
  If ntui_GetValueByID{*win,"obj_prefs_screenmode"}=0 Then AIDE\Prefs\PubScreenName = "Workbench" : Else AIDE\Prefs\PubScreenName = "AIDE"
  AIDE\Prefs\NTUIBorderStyle = ntui_GetValueByID{*win,"obj_prefs_borderstyle"}
  AIDE\Prefs\NTUIFillStyle   = ntui_GetValueByID{*win,"obj_prefs_fillstyle"}
  Prefs_Apply{}

  ntui_GetAttr{*ntui,#TUIA_DIRTY,&dirty.l}
  If dirty
    ntui_Iconify{*ntui}    
    ntui_SetAttr{*ntui,#TUIA_DIRTY,False}
    
    If AIDE\Prefs\PubScreenName="AIDE"
      ntui_SetAttrByID{*ntui,!win_main,#TUIWA_BORDERLESS,1}
    Else
      ntui_SetAttrByID{*ntui,!win_main,#TUIWA_BORDERLESS,0}
    End If
  
    ntui_PopUp{*ntui}
    AIDE_AutoLayout{}    
  End If
  
End Statement


;/* event handler function */
Statement AIDE_HandleNotifies{}

  Repeat
    *notify.tuiNotify = ntui_GetNotify{*ntui}

    Select ntui_GetNotifyID{*notify}
    Case "POPUP"        ; someone wants us to popup
      ntui_HideAppIcon{*ntui}
      If AIDE\Prefs\PubScreenName="AIDE"
        ntui_SetAttrByID{*ntui,!win_main,#TUIWA_BORDERLESS,1}
      Else
        ntui_SetAttrByID{*ntui,!win_main,#TUIWA_BORDERLESS,0}
      End If
      ntui_PopUp{*ntui,AIDE\Prefs\PubScreenName,Null}

    Case "ICONIFY"      ; someone wants us to iconify
      ntui_Iconify{*ntui}
      ntui_ShowAppIcon{*ntui}

    Case "AREXX"        ; we got an arexx message
      Select ntui_GetNotifyString{*notify}
         Case "QUIT"    : ntui_PostNotify{*ntui,"QUIT"}
         Case "ICONIFY" : ntui_PostNotify{*ntui,"ICONIFY"}
         Case "POPUP"   : ntui_PostNotify{*ntui,"POPUP"}
      End Select

    Case "CLOSE"        ; close a window
      *win.tuiWindow = ntui_GetNotifyWindow{*notify}
      If *win Then ntui_HideWindow{*win}

    Case "QUIT"         ; someone wants us to quit
      AIDE\Quit = True

    Case !ev_aide_about
      Window_About{}

    Case !ev_aide_calculator
      Window_Calculator{}

    Case !ev_aide_preferences
      ntui_FreeWindowByID{*ntui,!win_preferences} ; DEBUG: to reopen the window everytime fresh!
      Window_Preferences{}
      
    Case !ev_aide_prefs_apply
      ntui_HideWindowByID{*ntui,!win_preferences}
      Prefs_ReadFromGui{}
      
    Case !ev_filelist_refresh
      path.s = ntui_GetStringByID{*ntui,!obj_filelist_path}
      FileLister_Fill{!obj_filelist,path,AIDE\DocType[#DOCTYPE_DEFAULT]\Pattern}
      
    Case !ev_filelist_setpattern
      pattern.s = ntui_GetStringByID{*ntui,!obj_filelist_pattern}
      FileLister_Fill{!obj_filelist,AIDE\Prefs\FileListPath,pattern}

    Case !ev_filelist_parentpath
      path.s = ntui_GetStringByID{*ntui,!obj_filelist_path}
      path = dos_PathPart{path}
      FileLister_Fill{!obj_filelist,path,AIDE\DocType[#DOCTYPE_DEFAULT]\Pattern}

    Case !ev_filelist_showdrives
      FileLister_Fill{!obj_filelist,"",AIDE\DocType[#DOCTYPE_DEFAULT]\Pattern}

    Case !ev_filelist_favorites
      FileLister_Fill{!obj_filelist,"AIDE::FAVORITES",AIDE\DocType[#DOCTYPE_DEFAULT]\Pattern}

    Case !ev_filelist_select
      *obj.tuiObject = ntui_GetNotifyObject{*notify}
      ntui_GetAttr{*obj,#TUIA_CLASSID,&classId.l}
      If classId=#TUICLASS_LISTVIEW
        *listView.tuiListView = (.tuiListView)*obj
        selectedX.l = ntui_GetFirstSelectedListItem{*listView}
        selected.s  = ntui_GetListItemText{*listView,selectedX,1}

        path = dos_AddPart{AIDE\Prefs\FileListPath,selected}

        If dos_IsFile{path}
          docX.l = Document_Open{path}
          If docX>=0 Then Document_Show{docX}
        Else
          FileLister_Fill{!obj_filelist,path,AIDE\DocType[#DOCTYPE_DEFAULT]\Pattern}
        End If

      End If
      
    Case !ev_filelist_iconinfo
      *obj.tuiObject = ntui_GetObjectByID{*ntui,!obj_filelist}
      ntui_GetAttr{*obj,#TUIA_CLASSID,&classId.l}
      If classId=#TUICLASS_LISTVIEW
        *listView.tuiListView = (.tuiListView)*obj
        selectedX.l = ntui_GetFirstSelectedListItem{*listView}
        If selectedX>=0
          selected.s  = ntui_GetListItemText{*listView,selectedX,1}
          path = dos_AddPart{AIDE\Prefs\FileListPath,selected}
          ;cmd.s = "run wbinfo \\22"+path+"\\22"
          arg.s = "\\22"+path+"\\22 pubscreen "+AIDE\Prefs\PubScreenName
          ;error{arg}
          ;Execute_ &cmd,0,0
          dos_RunCli{"wbinfo",0,-1,False,arg}
        End If
      End If
      
    Case !ev_source_cursor
      *source.tuiGroup = Source_FindActive{}
      If *source
        ntui_GetAttrByID{*source,!obj_source_text,#TUITBA_CURSORLINE,&lpos.l}
        ntui_GetAttrByID{*source,!obj_source_text,#TUITBA_CURSORCHAR,&cpos.l}
        ntui_GetAttrByID{*source,!obj_source_text,#TUITBA_TOTALLINES,&ltotal.l}
        a.s = "Line "+Str$(lpos+1)+" / "+Str$(ltotal)+" Char "+Str$(cpos+1)
        ntui_SetStringByID{*source,!obj_source_status,a}

        ntui_GetAttrByID{*source,!obj_source_text,#TUITBA_NUMBEROFCHANGES,&changes.l}
        ntui_GetAttrByID{*source,!obj_source_text,#TUITBA_UNDOSTEPS,&steps.l}
        ntui_GetAttrByID{*source,!obj_source_text,#TUITBA_EDITED,&edited.l}
        a.s = "# Changes "+Str$(changes)+" / # Undo "+Str$(steps)+" / Edited "+Str$(edited)+" / GUI-Upd "+Str$(updatecount)
        ntui_SetStringByID{*source,!obj_source_dstatus,a}
        ;AIDE_UpdateGui{}
      End If

    Case !ev_source_debug
      docX.l = Document_FindActive{}
      If docX>=0
        Document_Debug{docX}
      Else
        error{"No file selected for debugging!"}
      End If

    Case !ev_source_build
      docX.l = Document_FindActive{}
      If docX>=0
        Document_Build{docX}
      Else
        error{"No file selected for compiling!"}
      End If

    Case !ev_project_build
      docX.l = Document_FindActive{}
      If docX>=0
        Document_Build{docX}
      Else
        error{"No project selected for building!"}
      End If

    Case !ev_project_debug
      docX.l = Document_FindActive{}
      If docX>=0
        Document_Debug{docX}
      Else
        error{"No project selected for debugging!"}
      End If

    Case !ev_source_save
      docX.l = Document_FindActive{}
      If docX>=0
        Document_Save{docX,""} ; find filename from textbox
      Else
        error{"No tab selected to save!"}
      End If

    Case !ev_source_saveall
      For docX.l = 0 To #DOCUMENT_MAX-1
        Document_Save{docX,""}
      Next


    Case !ev_source_saveas
      filename.s = ntui_GetNotifyString{*notify}
      docX.l = Document_FindActive{}
      If docX>=0
        Document_Save{docX,filename}
      End If

    Case !ev_source_close
      docX.l = Document_FindActive{}
      If docX>=0 Then Document_Close{docX}

    Case !ev_source_closeall
      For docX.l = 0 To #DOCUMENT_MAX-1
        Document_Close{docX}
      Next

    Case !ev_source_closeallbutthis
      docY.l = Document_FindActive{}
      For docX.l = 0 To #DOCUMENT_MAX-1
        If docX><docY Then Document_Close{docX}
      Next

    Case !ev_source_open_req
      docX.l = Document_FindActive{}
      If docX>=0
        filename.s = Document_GetFileName{docX}
        path.s     = dos_PathPart{filename}
        file_.s    = dos_FilePart{filename}
        ;pattern.s  = Document_GetDosPattern{docX}
        pattern.s  = AIDE\DocType[#DOCTYPE_DEFAULT]\Pattern

        If path><"" Then ntui_SetAttrByID{*ntui,!req_source_open,#TUIRA_PATH,&path}
        ntui_SetAttrByID{*ntui,!req_source_open,#TUIRA_FILE,&file_}
        ntui_SetAttrByID{*ntui,!req_source_open,#TUIRA_PATTERN,&pattern}
      End If
      ntui_ShowRequesterByID{*ntui,!req_source_open}

    Case !ev_source_open
      filename.s = ntui_GetNotifyString{*notify}
      docX.l = Document_Open{filename}
      If docX>=0 Then Document_Show{docX}

    Case !ev_source_new
      docX.l = Document_New{}
      If docX>=0 Then Document_Show{docX}

    Case !ev_source_saveas_req
      docX.l = Document_FindActive{}
      If docX>=0
        filename.s = Document_GetFileName{docX}
        path.s     = dos_PathPart{filename}
        file_.s    = dos_FilePart{filename}
        pattern.s  = Document_GetDosPattern{docX}

        If path><"" Then ntui_SetAttrByID{*ntui,!req_source_saveas,#TUIRA_PATH,&path}
        ntui_SetAttrByID{*ntui,!req_source_saveas,#TUIRA_FILE,&file_}
        ntui_SetAttrByID{*ntui,!req_source_saveas,#TUIRA_PATTERN,&pattern}
        

        ntui_ShowRequesterByID{*ntui,!req_source_saveas}
      Else
        error{"No tab selected to save!"}
      End If

   ; Case !ev_path_req
   ;   ntui_ShowRequesterByID{*ntui,"req_path"}

    Case !ev_source_settings
      docX.l = Document_FindActive{}
      If docX>=0
        Document_OpenSettings{docX}
      Else
        error{"No tab selected for settings!"}
      End If

    Case !ev_source_applysettings
      *win.tuiWindow = ntui_GetNotifyWindow{*notify}
      If *win
        ntui_GetAttr{*win,#TUIWA_INSTANCEID,&docX.l}
        If docX>=0
          Document_ApplySettings{docX}
          ntui_HideWindow{*win}
        End If
      End If

    Case !ev_tool_shell
      Execute_ "newcli",Null,Null

    Case !ev_console_close
      AIDE\IsBuilding  = False
      AIDE\IsDebugging = False
      AIDE_UpdateGui{}
      *con.tuiTextBox = (.tuiTextBox)ntui_GetObjectByID{*ntui,!obj_main_console}
      If *con
        txt.s = "\\1B[33m\\1B[1m<<< Done.\\n"
        ntui_SetAttr{*con,#TUITBA_APPENDTEXT,&txt}
      End If

    Case !ev_find_docasesense
      AIDE\Prefs\CaseSensitiveSearch = ntui_GetValueByID{*ntui,!obj_find_docasesense}
      
    Case !ev_find_doescape
      AIDE\Prefs\EscapeSearch = ntui_GetValueByID{*ntui,!obj_find_doescape}
      If AIDE\Prefs\EscapeSearch
        ntui_SetAttrByID{*ntui,!obj_find_string,#TUITBA_STYLECB,*_search_StyleCallback}
        ntui_SetAttrByID{*ntui,!obj_find_replacestring,#TUITBA_STYLECB,*_search_StyleCallback}
      Else
        ntui_SetAttrByID{*ntui,!obj_find_string,#TUITBA_STYLECB,Null}
        ntui_SetAttrByID{*ntui,!obj_find_replacestring,#TUITBA_STYLECB,Null}
      End If

    Case !ev_find_refresh
      needle.s = ntui_GetStringByID{*ntui,!obj_find_string}
      docX.l = Document_FindActive{}
      Document_SelectSearchText{docX,needle,0}

    Case !ev_find_next
      needle.s = ntui_GetStringByID{*ntui,!obj_find_string}
      docX.l = Document_FindActive{}
      Document_SelectSearchText{docX,needle,1}

    Case !ev_find_prev
      needle.s = ntui_GetStringByID{*ntui,!obj_find_string}
      docX.l = Document_FindActive{}
      Document_SelectSearchText{docX,needle,-1}
      
    Case !ev_source_find
      docX.l = Document_FindActive{}
      If docX>=0
        *search.tuiTextBox = (.tuiTextBox)ntui_GetObjectByID{*ntui,!obj_find_string}
        *tb.tuiTextBox = (.tuiTextBox)ntui_GetObjectByID{AIDE\Document[docX]\Source,!obj_source_text}
        If (*tb)
          text.s = ntui_GetTextBoxText{*tb,False}
        Else
          text = ""
        End If
        
        If (*search) 
          If text><"" Then ntui_SetAttr{*search,#TUITBA_TEXT,&text}
          ntui_SetFocus{*search}
          ntui_SetTextBoxSelection{*search}
        EndIf
        
      End If
      
    Case !ev_find_replacefind
      needle.s  = ntui_GetStringByID{*ntui,!obj_find_string}
      replace.s = ntui_GetStringByID{*ntui,!obj_find_replacestring}
      docX.l = Document_FindActive{}
      succ.l = Document_ReplaceSelectedText{docX,replace,"",False}
      Document_SelectSearchText{docX,needle,1}
      If succ Then count.l=1:Else count=0
      Document_SetStatusMessage{docX,Str$(count)+" occurences replaced"}
      
    Case !ev_find_replaceall
      needle.s  = ntui_GetStringByID{*ntui,!obj_find_string}
      replace.s = ntui_GetStringByID{*ntui,!obj_find_replacestring}
      docX.l = Document_FindActive{}
      count.l = Document_ReplaceSelectedText{docX,replace,needle,True}
      Document_SetStatusMessage{docX,Str$(count)+" occurences replaced"}
      
    Case !ev_source_undo      : Document_EditFunction{Document_FindActive{},"undo"}
    Case !ev_source_cut       : Document_EditFunction{Document_FindActive{},"cut"}
    Case !ev_source_copy      : Document_EditFunction{Document_FindActive{},"copy"}
    Case !ev_source_paste     : Document_EditFunction{Document_FindActive{},"paste"}
    Case !ev_source_delete    : Document_EditFunction{Document_FindActive{},"delete"}
    Case !ev_source_selectall : Document_EditFunction{Document_FindActive{},"selectall"}
    Case !ev_source_switch    : ;AIDE_UpdateGui{}
     docX.l = Document_FindActive{}
     Document_Show{docX}

    Case !ev_src_jumpto
      docX.l = Document_FindActive{}
      If docX>=0
        docType.l = AIDE\Document[docX]\DocType
        *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*ntui,!obj_src_list}
        If *lv
          i.l     = ntui_GetFirstSelectedListItem{*lv}
          type_.s = ntui_GetListItemText{*lv,i,0}
          name.s  = ntui_GetListItemText{*lv,i,1}
          more.s  = ntui_GetListItemText{*lv,i,2}
          If (AIDE\DocType[docType]\JumpTo)
            !_CallFuncPointer{AIDE\DocType[docType]\JumpTo, res.l, docX, &type_, &name, &more}
          End If
        End If
      End If
      
    Case !ev_src_refresh
      docX.l = Document_FindActive{}
      If docX>=0
        docType.l = AIDE\Document[docX]\DocType
        If (AIDE\DocType[docType]\UpdateSDK)
          !_CallFuncPointer{AIDE\DocType[docType]\UpdateSDK, res.l, docX}
        End If
      End If
      
    Case !ev_src_rescan
      docX.l = Document_FindActive{}
      If docX>=0
        AIDE\Document[docX]\NeedScan=True
        Document_Show{docX}
      End If
      
    Case !ev_ab3_jumpto
      docType.l = #DOCTYPE_AMIBLITZ3
      *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*ntui,!obj_ab3_list}
      If *lv
        i.l     = ntui_GetFirstSelectedListItem{*lv}
        type_.s = ntui_GetListItemText{*lv,i,0}
        name.s  = ntui_GetListItemText{*lv,i,1}
        more.s  = ntui_GetListItemText{*lv,i,2}
        If (AIDE\DocType[docType]\JumpTo)
          !_CallFuncPointer{AIDE\DocType[docType]\JumpTo, res.l, -1, &type_, &name, &more}
        End If
      End If

    Case !ev_ab3_refresh
      docType.l = #DOCTYPE_AMIBLITZ3
      If (AIDE\DocType[docType]\UpdateSDK)
        !_CallFuncPointer{AIDE\DocType[docType]\UpdateSDK, res.l, -1}
      End If
      
    Case !ev_ab3_rescan
      ntui_ShowWindowByID{*ntui,!win_splash}
      _AmiBlitz3_Prepare{True}
      id.s = !ev_ab3_refresh
      ntui_PostNotify{*ntui,&id}
      ntui_HideWindowByID{*ntui,!win_splash}
      
    Case !ev_setlayout_small
      For docX.l = 0 To #DOCUMENT_MAX-1
        Document_Close{docX}
      Next
      AIDE\Prefs\GUILayout = #GUILAYOUT_SMALL
      Window_Main{}
      Window_SetUpMain{}
      
    Case !ev_setlayout_medium
      For docX.l = 0 To #DOCUMENT_MAX-1
        Document_Close{docX}
      Next
      AIDE\Prefs\GUILayout = #GUILAYOUT_MEDIUM
      Window_Main{}
      Window_SetUpMain{}
      
    Case !ev_setlayout_large
      For docX.l = 0 To #DOCUMENT_MAX-1
        Document_Close{docX}
      Next
      AIDE\Prefs\GUILayout = #GUILAYOUT_LARGE
      Window_Main{}
      Window_SetUpMain{}
      
CNIF #HAS_AISS
    Case !ev_aiss_refresh : AISS_Refresh{"","",False}
    Case !ev_aiss_rescan  : AISS_Refresh{"","",True}
CEND
    Case !ev_console_click
      textP.l = 0
      ntui_GetAttrByID{*ntui,!obj_main_console,#TUITBA_CURSORLINE,&textP}
      ntui_GetAttrByID{*ntui,!obj_main_console,#TUITBA_LINE,&textP}
      If textP
        text.s = Peek.s(textP)
        ;error{"Linetext:"+text}

        find.s = ".c:" : pos.l = Instr(text,find)
        If pos<=0 Then find=".h:"   : pos = Instr(text,find)
        If pos<=0 Then find=".cpp:" : pos = Instr(text,find)
        If pos<=0 Then find=".hpp:" : pos = Instr(text,find)
        If pos>0
          pos + FLen(find)
          filename.s = Left$(text,pos-2)
          npos.l = Instr(text,":",pos)
          If npos>=0
            lposstr.s = Mid$(text,pos,npos-pos)
            lpos.l = Vallong(lposstr)-1
          Else
            lpos = 0
          End If
          filename=MakeAmigaDOSFilename{filename}
          ;error{"filename="+filename+" lpos="+Str$(lpos)}
          docX.l = Document_Open{filename}
          Document_JumpTo{docX,lpos,True}
        EndIf

        find.s = "Include"
        If Left$(text,FLen(find))=find
          cpos.l = 7
          While (Peek.b(&text+cpos)><$22 AND cpos<FLen(text)):cpos+1:Wend
          cpos+1
          If cpos<FLen(text)
            bpos.l = cpos
            While (Peek.b(&text+cpos)><$22 AND cpos<FLen(text)):cpos+1:Wend
            If cpos>bpos
              filename.s = Mid$(text,bpos+1,cpos-bpos)
              If Instr(filename,":")<=0 Then filename = dos_AddPart{AIDE\BuildPath,filename}

              ;error{"read:"+filename}
              docX.l = Document_Open{filename}
              Document_Show{docX}
            End If
          EndIf
        EndIf

        find.s = "Compiler Error"
        cpos = Instr(text,find)
        If cpos>0
          cpos.l = FLen(find)
          While (Peek.b(&text+cpos)><@"<" AND cpos<FLen(text)):cpos+1:Wend
          cpos+1
          If cpos<FLen(text)
            bpos.l = cpos
            While (Peek.b(&text+cpos)><@">" AND cpos<FLen(text)):cpos+1:Wend
            If cpos>bpos
              filename.s = Mid$(text,bpos+1,cpos-bpos)
              cpos= Instr(filename,"@")
              If cpos>0
                lposstr.s = Right$(filename,FLen(filename)-cpos)
                lpos.l = Vallong(lposstr)-1
                filename = Left$(filename,cpos-1)
              End If
              ;error{"Document:"+filename+"lpos="+lposstr}
              If Instr(filename,":")<=0 Then filename = dos_AddPart{AIDE\BuildPath,filename}
              
              docX.l = Document_Open{filename}
              Document_JumpTo{docX,lpos,True}
            End If
          EndIf


        EndIf

      EndIf
      Case !ev_input_select
        *win.tuiWindow = ntui_GetNotifyWindow{*notify}
        If *win
          ntui_HideWindow{*win}
          *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*win,!obj_selector_list}
          i.l = ntui_GetFirstSelectedListItem{*lv}
          If i>=0
            token.s = ntui_GetListItemText{*lv,i,0}
            ;ntui_GetNextSelectedListItem{*lv}
            ;If token Then error{"token selected: "+token}
          End If
        End If
        
      Case "FILESCAN"
        sourcefile.s = ntui_GetNotifyString{*notify}
        docX.l = Document_FindByFilename{sourcefile}
        If docX>=0
          docType.l = Document_GetDocType{docX}
          If (AIDE\DocType[docType]\ScanSourceFinish)
            !_CallFuncPointer{AIDE\DocType[docType]\ScanSourceFinish, res.l, docX, &sourcefile}
            If docX = Document_FindActive{}
               If (AIDE\DocType[docType]\UpdateSDK)
               !_CallFuncPointer{AIDE\DocType[docType]\UpdateSDK, res.l, docX}
              End If
            End If
            
          End If
        End If

      Case "TEST"
        string.s = ntui_GetNotifyString{*notify}
        value.l  = ntui_GetNotifyValue{*notify}
        error{"We are testing! str=\\22"+string+"\\22 / val="+Str$(value)}

      Default
        *con.tuiTextBox = (.tuiTextBox)ntui_GetObjectByID {*ntui,!obj_main_console}
        If *con
          id.s = ntui_GetNotifyID{*notify}
          If id
            string.s = ntui_GetNotifyString{*notify}
            value.l  = ntui_GetNotifyValue{*notify}
            msg.s = "Unhandled notification: "+id+" (str=\\22"+string+"\\22 / val="+Str$(value)+")\\n"
            ntui_SetAttr{*con,#TUITBA_APPENDTEXT,&msg}
          Else
            msg.s = "WARN: Empty notify!\\n"
          End If
        End If
        
    End Select

  Until *notify=Null

End Statement


;/* ============== Main Program ==============

  exitcode.l = 0
  
  ; build the splash screen
  *splash.tuiObject = ntui_BuildFromXMLFile{Null,dos_AddPart{AIDE\GuiPath,!file_win_splash}}
  If *splash = Null Then error{"Unable to init NTUI environment for AIDE!"} : exitcode = -1 : Goto cleanup
  *ntui = ntui_GetEngine{*splash}
  ntui_PopUp{*ntui,"",Null}
  ntui_ShowWindowByID{*ntui,!win_splash}

  ; read preferences
  StartUp_Message{"reading preferences..."}
  Prefs_Read{AIDE\Icon}

  ; build engine and requesters
  StartUp_Message{"building Gui..."}
  ntui_BuildFromXMLFile{*ntui,dos_AddPart{AIDE\GuiPath,!file_engine}}
  ntui_BuildFromXMLFile{*ntui,dos_AddPart{AIDE\GuiPath,!file_requester}}

  ; build main window
  *winmain.tuiWindow = Window_Main{}
  If *winmain = Null Then error{"Unable to open main window for AIDE!"} : exitcode = -1 : Goto cleanup

  ; open documents
  StartUp_OpenWorkSpace{}
  
  ; leave splash screen
  ntui_HideWindowByID{*ntui,!win_splash}
  ntui_Iconify{*ntui}

  ; open own screen
  ntui_PopUp{*ntui,AIDE\Prefs\PubScreenName,Null}
  ntui_ToFront{*ntui}
  
  ; setup the main window content
  If Window_SetUpMain{}=False Then exitcode=-2 : Goto cleanup

  ; highlight active document
  docX.l = Document_FindByFilename{AIDE\Prefs\ActiveDocument}
  Document_Show{docX}
  
  ; event loop
  Repeat
    Wait_ -1
    AIDE_HandleNotifies{}
  Until AIDE\Quit

.cleanup
  AIDE_Deinit{exitcode}
End

