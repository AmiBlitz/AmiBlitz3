; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Sys:Programme/AIDE"
; ExeFile         = "AIDE"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 503
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 36
; CursorColumn    = 81
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 1
; Max GadgetList  = 1
; Max Queue       = 1
; Max Screen      = 2
; Max Shape       = 1
; Max CopList     = 1
; Max Sprite      = 1
; Max Stencil     = 1
; Max Module      = 1
; Max Window      = 30
; Max Anim        = 1
; Max Sound       = 1
; Max Bank        = 1
; Max Buffer      = 1
; Max BitMap      = 1
; Max Slice       = 1
; Max Page        = 1
; Max Tape        = 1
; Max IntuiFont   = 12
; Max MedModule   = 1
; Max Palette     = 1
; Max MenuList    = 1
; Max BlitzFont   = 1
; Max GTList      = 30
; /XTRA
; ========================= Utilities ====================
; Copy the Workbench CLI struct if there is none in our task 
Function.l SetCLI{}
If Cli_() = Null
  *proc.Process = FindTask_(Null)

  If False ; WB hack
  *WBStartup_.WBStartup = dos_GetWBStartup{}  
  If *WBStartup_ >< Null
    *msg.Message = *WBStartup_\sm_Message
    *port.MsgPort = *msg\mn_ReplyPort
    *task.Process = *port\mp_SigTask
    *proc\pr_CLI = *task\pr_CLI
    *proc\pr_Flags & ($FFFFFFFF - #PRF_FREECLI)
    Function Return True
  End If
  End If
  If False
    cli.l = AllocDosObject_(#DOS_CLI,Null)
    *proc\pr_CLI = (cli ASR 2)
    *proc\pr_Flags | #PRF_FREECLI
  End If
  If True
    ;WorkbenchControl_(Null, 
    ;    #WBCTRLA_DuplicateSearchPath, &path, 
    ;    #TAG_END)
  End If
  
End If
Function Return False
End Function


Function.l RemCLI{}

  If False
    *proc.Process = FindTask_(Null)
    If *proc\pr_CLI = Null Function Return False
    *proc\pr_CLI = Null
  End If
  
  Function Return True
  
End Function


Function.l instr_nocaseP{*hayP.b,hayLen.l,*needleP.b,needleLen.l,pos.l}

  ; optimized implementation, not finished!
  While pos+needleLen<=hayLen
    char.b = Peek.b(*hayP+pos)
    If char>=@"A" AND char<=@"Z" Then char=char - @"A" + @"a"
    If char=Peek.b(*needleP)
      m.l = 0
      Repeat
        m+1
        char=Peek.b(*hayP+pos+m)
        If char>=@"A" AND char<=@"Z" Then char=char - @"A" + @"a"        
      Until char><Peek.b(*needleP+m) OR m>=needleLen
      If m=needleLen Then Function Return pos+1
    End If
    pos+1
  Wend
  Function Return 0
  
End Function  


Function.l instr_nocase_{hay.s,needle.s,@pos.l}

  hay.s = LCase$(hay)
  needle.s = LCase$(needle)
  Function Return Instr(hay,needle,pos)
  
End Function


Function.s UnescapeString{string.s}
  pos.l = 0
  os.s = string
  Repeat
    pos.l = Instr(string,"\",pos+1)
    If pos>0
      c.l = Peek.b(&string+pos)
      Select c
        Case @"\" :  string = Left$(string,pos-1) + Chr$($5C) + Right$(string,FLen(string)-pos-1)
        Case @"0" :  string = Left$(string,pos-1) + Chr$($00) + Right$(string,FLen(string)-pos-1)
        Case @"t" :  string = Left$(string,pos-1) + Chr$($09) + Right$(string,FLen(string)-pos-1)
        Case @"n" :  string = Left$(string,pos-1) + Chr$($10) + Right$(string,FLen(string)-pos-1)
        Case @"r" :  string = Left$(string,pos-1) + Chr$($13) + Right$(string,FLen(string)-pos-1)
        Case @"x"
          c.l = 0
          nib.l = Peek.b(&string+pos+1) &$FF
          done.l = 0
          If nib>=@"0" AND nib<=@"9" Then c + (nib-@"0")    : done=1
          If nib>=@"a" AND nib<=@"f" Then c + (nib-@"a"+10) : done=1
          If nib>=@"A" AND nib<=@"F" Then c + (nib-@"A"+10) : done=1

          If done
            c LSL 4
            nib.l = Peek.b(&string+pos+2) &$FF
            done = 0
            If nib>=@"0" AND nib<=@"9" Then c + (nib-@"0")    : done=1
            If nib>=@"a" AND nib<=@"f" Then c + (nib-@"a"+10) : done=1
            If nib>=@"A" AND nib<=@"F" Then c + (nib-@"A"+10) : done=1
            If done
              string = Left$(string,pos-1) + Chr$(c) + Right$(string,FLen(string)-pos-3)
            End If
          End If
        Default

      End Select
    End If

  Until pos=0
  ;If os><string Then error{"Mapped "+os+" to "+string}

  Function Return string

End Function


Function.s GetDosFileName{filename.s}

  MaxLen buff.s = 1024
  
  lock.l = Lock_(&filename,#ACCESS_READ);
  If lock
    NameFromLock_ lock,&buff,1023
    filename = Peek.s(&buff)
    UnLock_ lock : lock=0
  End If
  
  Function Return filename
  
End Function

Function.s ExtPath{path.s}

  If path = "" Then Function Return path
  If Right$(path,1) = ":" Then Function Return path  
  If Right$(path,1) = "/" Then Function Return path
  Function Return path + "/"
  
End Function

; parse a string with doctype specific placeholders
Function.s Prefs_ParseString{string.s, docTypeX.l}

  string = Replace$(string,"$","\\03")
  string = Replace$(string,"\" + "\\03","\$")
  string = Replace$(string,"\\03WORK:", ExtPath{AIDE\DocType[docTypeX]\WorkPath})
  string = Replace$(string,"\\03SDK:",  ExtPath{AIDE\DocType[docTypeX]\SDKPath})
  string = Replace$(string,"\\03AIDE:", ExtPath{AIDE\InstallPath})
  string = Replace$(string,"\\03PUBSCREEN", AIDE\Prefs\PubScreenName)
  string = Replace$(string,"\\03APPICON", AIDE\Prefs\AppIcon)
  string = Replace$(string,"\\03AREXX", AIDE\Prefs\AREXXPort)
  string = Replace$(string,"\\03GUI:",  ExtPath{AIDE\GuiPath})
  string = Replace$(string,"\\03TYPES:",ExtPath{AIDE\TypesPath})
  string = Replace$(string,"\\03STACK", Str$(AIDE\DocType[docTypeX]\Stack))
  string = Replace$(string,"\\03", "$")
  Function Return string
  
End Function


Function.s RunCmd_ParseString{string.s, inputfile.s, outputfile.s, workdir.s}

  string = Replace$(string,"%","\\03")
  string = Replace$(string,"\" + "\\03","\%")
  string = Replace$(string,"\\03p",dos_PathPart{inputfile})
  string = Replace$(string,"\\03f",dos_FilePart{inputfile})
  string = Replace$(string,"\\03F",inputfile)
  string = Replace$(string,"\\03w",workdir)
  string = Replace$(string,"\\03s",dos_RemExt{dos_FilePart{inputfile}})
  string = Replace$(string,"\\03x",dos_GetExt{inputfile})
  string = Replace$(string,"\\03O",outputfile)
  string = Replace$(string,"\\03o",dos_FilePart{outputfile})
  string = Replace$(string,"\\03", "%")
  
  
  string = Replace$(string,"$","\\03")
  string = Replace$(string,"\" + "\\03","\$")
  ; input file
  string = Replace$(string,"\\03FILE",inputfile)
  string = Replace$(string,"\\03NAME",dos_FilePart{inputfile})
  string = Replace$(string,"\\03DIR:",ExtPath{dos_PathPart{inputfile}})
  string = Replace$(string,"\\03STEM",dos_RemExt{dos_FilePart{inputfile}})
  string = Replace$(string,"\\03EXT",dos_GetExt{inputfile})
  ; out file
  string = Replace$(string,"\\03OUT",outputfile)
  string = Replace$(string,"\\03OUTNAME",dos_FilePart{outputfile})
  string = Replace$(string,"\\03OUTDIR:",ExtPath{dos_PathPart{outputfile}})
  string = Replace$(string,"\\03", "$")
  ; work dir
  string = Replace$(string,"\\03WORK:",ExtPath{workdir})
  
  Function Return string
  
End Function

; ===========================================================
