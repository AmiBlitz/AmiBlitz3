; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Sys:Programme/AIDE"
; ExeFile         = "AIDE"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 519
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 2002
; CursorColumn    = 18
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 1
; Max GadgetList  = 1
; Max Queue       = 1
; Max Screen      = 2
; Max Shape       = 1
; Max CopList     = 1
; Max Sprite      = 1
; Max Stencil     = 1
; Max Module      = 1
; Max Window      = 30
; Max Anim        = 1
; Max Sound       = 1
; Max Bank        = 1
; Max Buffer      = 1
; Max BitMap      = 1
; Max Slice       = 1
; Max Page        = 1
; Max Tape        = 1
; Max IntuiFont   = 12
; Max MedModule   = 1
; Max Palette     = 1
; Max MenuList    = 1
; Max BlitzFont   = 1
; Max GTList      = 30
; /XTRA
; ========================= AMIBLITZ3 ====================
#HAS_AMIBLITZ3 = 1

#AB3TF_IS        = $0001 ;/* is part of token */
#AB3TF_EOL       = $0002 ;/* end of line */
#AB3TF_NEW       = $0004 ;/* starts a possibly new token */
#AB3TF_STOP      = $0008 ;/* stops a token */
#AB3TF_QUOT      = $0010 ;/* start/end quoting */
#AB3TF_COMMENT   = $0020 ;/* comment */
#AB3TF_COPY      = $0040 ;/* copy over to destination */
#AB3TF_FIRST     = $0080 ;/* can serve as first char in token */
#AB3TF_HEX       = $0100
#AB3TF_BIN       = $0200
#AB3TF_DEC       = $0400
#AB3TF_SPACE     = $0800
#AB3TF_ILLEGAL   = $1000
#AB3TF_BRACKET   = $2000

#AB3_MIN_STACKSIZE    = 4000
#AB3_MIN_STRINGBUFFER = 1024

NEWTYPE.AmiBlitz3_Xtra ; Amiblitz3 Xtra Information

  *ExePath.str
  *ExeFile.str
  StringBuffer.l
  MakeSmallest.l
  FuncOptimize.l
  StackSize.l
  *CliArgs.str
  NumberOfBuilds.l
  MajorVersion.l
  MinorVersion.l
  PatchVersion.l
  CreateIcon.l
  UseDebugger.l
  DebugInfo.l
  CreateDbgFile.l
  OverflowCheck.l
  AssemblerCheck.l
  InterruptCheck.l
  AutoRun.l
  CursorLine.l
  CursorColumn.l
  *LabelSearch.str
  LabelRemark.w
  LabelAll.w
  LabelPosition.l
  *Residents.str
  *MaxName.str[256]
  MaxNum.w[256]
  *LocalSDK.prefixtree
  *LocalLSDK.prefixtree

End NEWTYPE

Statement _AmiBlitz3_InitXtra{*xtra.AmiBlitz3_Xtra} ; Initializer for _Xtra Newtype

  *xtra\ExePath        = Null
  *xtra\ExeFile        = Null
  *xtra\StringBuffer   = #AB3_MIN_STRINGBUFFER
  *xtra\MakeSmallest   = False
  *xtra\FuncOptimize   = False
  *xtra\StackSize      = #AB3_MIN_STACKSIZE
  *xtra\CliArgs        = Null
  *xtra\NumberOfBuilds = 0
  *xtra\MajorVersion   = 0
  *xtra\MinorVersion   = 0
  *xtra\PatchVersion   = 0
  *xtra\CreateIcon     = False
  *xtra\UseDebugger    = False
  *xtra\DebugInfo      = False
  *xtra\CreateDbgFile  = False
  *xtra\OverflowCheck  = False
  *xtra\AssemblerCheck = True
  *xtra\InterruptCheck = True
  *xtra\AutoRun        = True
  *xtra\CursorLine     = 0
  *xtra\CursorColumn   = 0
  *xtra\LabelSearch    = Null
  *xtra\LabelRemark    = False
  *xtra\LabelAll       = False
  *xtra\LabelPosition  = 0
  *xtra\Residents      = Null
  For n.l=0 To 255
    *xtra\MaxName[n] = Null
    *xtra\MaxNum[n]  = 0
  Next
  *xtra\LocalSDK       = Null
  *xtra\LocalLSDK      = Null

End Statement

Function.AmiBlitz3_Xtra _AmiBlitz3_AllocXtra{}

  *xtra.AmiBlitz3_Xtra = AllocVec_(SizeOf.AmiBlitz3_Xtra,#MEMF_ANY)
  If *xtra
    _AmiBlitz3_InitXtra{*xtra.AmiBlitz3_Xtra}
  End If

  Function Return *xtra

End Function

Statement _AmiBlitz3_FreeXtra{*xtra.AmiBlitz3_Xtra}

  If *xtra
    str_Free{&*xtra\ExePath}
    str_Free{&*xtra\ExeFile}
    str_Free{&*xtra\CliArgs}
    str_Free{&*xtra\LabelSearch}
    str_Free{&*xtra\Residents}
    For n.l=0 To 255
      str_Free{&*xtra\MaxName[n]}
    Next
    If *xtra\LocalSDK  Then pft_Free{*xtra\LocalSDK }  : *xtra\LocalSDK  = Null
    If *xtra\LocalLSDK Then pft_Free{*xtra\LocalLSDK}  : *xtra\LocalLSDK = Null
    FreeVec_ *xtra
  End If

End Statement

NEWTYPE.DocType_AmiBlitz3

  CharFlags.w[256]    ; character flags
  *Tokens.hashmap     ; hashmap with tokens => lib/id
  *LTokens.hashmap    ; hashmap with lowercased tokens => tokens
  *Detokens.l         ; reverse map to hashmap entries
  *TokensT.prefixtree
  *TempP.b
  *LineP.b
  AIDEDir.s           ; directory for Amiblitz3 related files
  Exe.s               ; executable of Amiblitz3
  Blitz3Path.s        ; 
  Blitz3Assign.s
  IncludeDir.s
  *SDK.prefixtree
  *LSDK.prefixtree
  BlitzLibName.s[256]
  ;DebugSourceArgs.s   ; command to launch AmiBlitz3s
  ;BuildSourceArgs.s
  ;DebugProjectArgs.s  ; command to launch AmiBlitz3s
  ;BuildProjectArgs.s  ; command to launch AmiBlitz3s
  DocType.l           ; docType ID
  IsPrepared.l        ; true if prepare was successfully called

  ; AIDE generateed files
  TokenHashMapFile.s
  TokenTreeFile.s
  TokenHashMapFileL.s
  SdkFile.s
  SdkFileL.s
  BlitzLibNameFile.s

End NEWTYPE
SHARED AmiBlitz3.DocType_AmiBlitz3

;AmiBlitz 3.5 (23.03.2013) Build 2.29
;
;Syntax: AmiBlitz3 [options]
;
;Options:
;  -(s)ource <File>    : Input source code filename (bb2, ab2 OR ab3)
;  -(e)xe <File>       : output executable filename
;  -(d)ebug            : compile with debug info
;  -(r)elease          : create release executable (size optimized)
;  -run                : run compiled program
;  -dump <info> <File> : dump compiler internals To File
;                        (info=all|token|label|var|func|const|Macro|Type|lib)
;  -dform <n>          : Format of compiler internals dump (0=bin, 1=ASCII; default=1)
;  -PED                : Start AmiBlitz3 IDE (PED)
;  -save <File>        : re-save source code (convert Format, If needed)
;  -(v)erbose <n>      : set verbose level (0, 1 OR 2; default=1)
;  -(h)elp             : Show this help

AmiBlitz3_ReadPrefs:
Statement AmiBlitz3_ReadPrefs{*iconP.b}

  icon.s = Peek.s(*iconP)
  AmiBlitz3\Exe                = dos_GetToolString{"AmiBlitz3_Exe"               ,"Blitz3:AmiBlitz3_Beta" ,icon}

  ; get includes
  dos_OpenToolTypes{AmiBlitz3\Exe}
  AmiBlitz3\IncludeDir   = dos_GetToolString{"INCLUDEDIR","Blitz3:Sourcecodes/Includes"}
  AmiBlitz3\Blitz3Assign = dos_GetToolString{"ASSIGN","Blitz3:"}
  dos_CloseToolTypes{}
  AmiBlitz3\Blitz3Path   = dos_PathPart{AmiBlitz3\Exe}
  If Left$(LCase$(AmiBlitz3\IncludeDir),FLen(AmiBlitz3\Blitz3Assign))=LCase$(AmiBlitz3\Blitz3Assign)
    AmiBlitz3\IncludeDir = dos_AddPart{AmiBlitz3\Blitz3Path,Right$(AmiBlitz3\IncludeDir,FLen(AmiBlitz3\IncludeDir)-FLen(AmiBlitz3\Blitz3Assign))}
  End If

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_ReadPrefs,{Null}}


AmiBlitz3_WritePrefs:
Statement AmiBlitz3_WritePrefs{*iconP.b}

  icon.s = Peek.s(*iconP)
  dos_SetToolString{"AmiBlitz3_Exe"                ,AmiBlitz3\Exe ,icon}

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_WritePrefs,{Null}}


Function.l AmiBlitz3_LongHelp{type_.s,symbol.s,libname.s}

  cmd.s = dos_AddPart{AmiBlitz3\Blitz3Path,"Tools/AB3HelpViewer"}
  cmd = GetDosFileName{cmd}
  If symbol ="" Then symbol = "main"
  args.s = " -t " + symbol
  
  If libname<>"" 
    libname = dos_FilePart{libname}
    libname = dos_RemExt{libname}
    args + " -l " + libname
  End If
  helpdir.s = dos_AddPart{AmiBlitz3\Blitz3Path,"Docs"}
  If helpdir<>"" 
    helpdir = GetDosFileName{helpdir}
    args + " -d " + helpdir
  End If
  ntui_GetAttr{*ntui,#TUIEA_PUBSCREENNAME,&*psn.b}
  If *psn Then pubscreen.s = Peek.s(*psn) : Else pubscreen=""
  If pubscreen<>""
    args + " -s " + pubscreen
  EndIf
  dos_RunCli{cmd,0,8192,False,args}
  
End Statement


AmiBlitz3_DebugSource:
Statement AmiBlitz3_DebugSource{docX.l,*filenameP.b}

  Default_DebugSource{docX, *filenameP}
  
End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_DebugSource,{0,Null}}


AmiBlitz3_BuildSource:
Statement AmiBlitz3_BuildSource{docX.l,*filenameP.b}

  filename.s = Peek.s(*filenameP)
  *xtra.AmiBlitz3_Xtra = (.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra
  If *xtra
    output.s = dos_AddPart{str_Read{&*xtra\ExePath},str_Read{&*xtra\ExeFile}}
  End If

  Document_RunCmd{docX, AIDE\DocType[#DOCTYPE_AMIBLITZ3]\BuildSourceCmd, filename, output, AIDE\DocType[#DOCTYPE_AMIBLITZ3]\WorkDir}

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_BuildSource,{0,Null}}


Function.l FAST _ab3_ParseComment{*tline.tline,cpos.l}

  _tb_SetStyleCommand{*tline,cpos-1 ,#TUITBSC_ITALIC,1,0}
  _tb_SetStyleCommand{*tline,cpos-1 ,#TUITBSC_FGPEN,#TUITBPEN_COMMENT,0}
  _tb_SetStyleCommand{*tline,cpos-1 ,#TUITBSC_BGPEN,#TUITBPEN_BG2    ,0}
;  _tb_SetStyleCommand{*tline,cpos-1 ,#TUITBSC_ITALIC,1,0}
;  _tb_SetStyleCommand{*tline,cpos-1 ,#TUITBSC_FGPEN,#TUITBPEN_COMMENT,0}
  _tb_SetStyleCommand{*tline,*tline\clength-1 ,#TUITBSC_BGPEN,#TUITBPEN_BG    ,0}

  Function Return *tline\clength; just skip to end of line

End Function


Function.l _ab3_ParseEscape{*tline.tline,cpos.l}
  opos.l = cpos-2
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_CONSTANT,0}

  esc.s = ""

  While cpos<*tline\clength
    c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
    esc + Chr$(c)
    If FLen(esc)>6
      Select UCase$(esc)
        Case "__THIS_FUNCTION": Function Return cpos
        Case "__THIS_INCLUDE" : Function Return cpos
        Case "__THIS_POINTER" : Function Return cpos
        Case "__CODELINE"     : Function Return cpos
        Case "__VER_MINOR"    : Function Return cpos
        Case "__VER_MAJOR"    : Function Return cpos
        Case "__VER_PATCH"    : Function Return cpos
        Case "__VER_BUILD"    : Function Return cpos
        Case "__DATE_GER__"   : Function Return cpos
        Case "__DATE__"       : Function Return cpos
      End Select
    End If

    If FLen(esc)=2
      If (AmiBlitz3\CharFlags[Peek.b(&esc+0)&$FF]&#AB3TF_HEX) AND (AmiBlitz3\CharFlags[Peek.b(&esc+1)&$FF]&#AB3TF_HEX) Then Function Return cpos
    End If

    If FLen(esc)=1
      If (c=@"n" OR c=@"N") Then Function Return cpos
    End If

    If FLen(esc)=3
      If (Peek.b(&esc+0)=@"r" OR Peek.b(&esc+0)=@"R")
        If (AmiBlitz3\CharFlags[Peek.b(&esc+1)&$FF]&#AB3TF_DEC) AND (AmiBlitz3\CharFlags[Peek.b(&esc+2)&$FF]&#AB3TF_DEC) Then Function Return cpos
      End If
    End If

    If ((AmiBlitz3\CharFlags[c]&#AB3TF_QUOT) OR (AmiBlitz3\CharFlags[c]&#AB3TF_IS)=0)
      _tb_SetStyleCommand{*tline,opos,#TUITBSC_WARN,1,#TUIPEN_RED}
      _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_WARN,0}
      Function Return cpos-1
    End If

  Wend
  Function Return cpos

End Function


Function.l FAST _ab3_ParseString{*tline.tline,cpos.l,fgPen.l}
  opos.l = cpos-1
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,fgPen,0}

  While cpos<*tline\clength
    c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
    If c=@"\"
      c.w = Peek.b(*tline\text+cpos)&$FF
      If c=@"\"
        cpos+1
        cpos = _ab3_ParseEscape{*tline,cpos}
        _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,fgPen,0}
      End If
    Else
      If AmiBlitz3\CharFlags[c]&#AB3TF_QUOT
        _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
        Function Return cpos
      End If
    End If
  Wend
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_WARN,1,#TUIPEN_RED}
  Function Return cpos

End Function


Function.l FAST _ab3_SkipWhiteSpaces{*tline.tline,cpos.l}

  While cpos<*tline\clength AND AmiBlitz3\CharFlags[Peek.b(*tline\text + cpos)&$FF]&#AB3TF_SPACE : cpos+1 : Wend
  Function Return cpos

End Function


Function.l FAST _ab3_ToLower{c.l}
  If c>=@"A" AND c<=@"Z" Then Function Return c-@"A"+@"a"
  Function Return c
End Function


Function.l _ab3_ParseToken{*tline.tline,cpos.l,*hm.hashmap,*cm.hashmap,first.l,*tempP.b}

  hash.l  = 0
  lhash.l = 0
  phash.l = 0
  cpos-1
  opos.l = cpos
  ln.l = 0
  Repeat
    If cpos<*tline\clength
      c.w = Peek.b(*tline\text + cpos) & $FF
      cf.l = AmiBlitz3\CharFlags[c&$FF]
      If (cf&#AB3TF_IS) ; it is a valid token char
        If (cf&#AB3TF_STOP)
          phash = hash
        Else
          phash = 0
        End If
        hash = (hash+c)*196314165
        cl.w = _ab3_ToLower{c}
        lhash = (lhash+cl)*196314165
        Poke.b *tempP+ln,cl:ln+1
      End If
    Else
      cf=0
      c=0
    End If
    cpos+1

  Until (cf&#AB3TF_IS)=0

  cpos-1

  tptr.l = hashmap_GetItemByHash{*hm,*tline\text+opos,cpos-opos,hash}
  If tptr=0 AND cpos>opos AND (phash><0)
    tptr = hashmap_GetItemByHash{*hm,*tline\text+opos,cpos-opos-1,phash}
    If tptr Then cpos-1 : c=Peek.b(*tline\text + cpos) & $FF
  End If

  If tptr ; its a token!
    _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_TOKEN,0}
    _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
    If c=$20 Then cpos+1
    _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
    _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}

    If c=@"$"
      _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TYPE,0}
      _tb_SetStyleCommand{*tline,cpos+1,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      cpos+1
    End If
    ;*tline\flags|#TUITBLF_HOT - #TUITBLF_HOT
  Else
    tptr.l = hashmap_GetItemByHash{*cm,*tempP,ln,lhash}
    If tptr ; its a token, just casing doesnt match
      _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_TOKEN,0}
      _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
      Poke.l *tempP+512-4,opos
      If ln>0
        CopyMem_ *tline\text+opos,*tempP+512,ln
        CopyMem_ tptr, *tline\text+opos,ln
      End If
      Poke.b *tempP+512+ln,0
      *tline\flags|#TUITBLF_HOT
      If c=$20 Then cpos+1
      _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
      _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
    Else
      If *tline\flags&#TUITBLF_HOT
        rpos.l=Peek.l(*tempP+512-4)
        If rpos=opos
          lnr.l = 0
          While Peek.b(*tempP+512+lnr) AND lnr<ln-1
            c.w = Peek.b(*tline\text + opos+lnr) & $FF
            r.w = Peek.b(*tempP+512+lnr) & $FF
            cl.w = _ab3_ToLower{c}
            rl.w = _ab3_ToLower{r}
            If cl=rl
              Poke.b *tline\text+opos+lnr,r
            End If
            lnr+1
          Wend
          Poke.b *tempP+512,0
          *tline\flags|#TUITBLF_HOT - #TUITBLF_HOT
        End If
      End If
      cpos = _ab3_SkipWhiteSpaces{*tline,cpos}
      c.w = Peek.b(*tline\text + cpos)&$FF
      Select c
        Case @"{"
          _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_FUNCTION,0}
          _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
          If c=$20 Then cpos+1

          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}

        Default
          If first
            ;_tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_LABEL,0}
            ;_tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          Else
          ;_tb_SetStyleCommand{*tline,opos ,#TUITBSC_WARN,1,0}
          ;_tb_SetStyleCommand{*tline,cpos ,#TUITBSC_WARN,0,0}
          End If
      End Select
    End If
  End If

  Function Return cpos

End Function


Function.l FAST _ab3_SkipToken{*tline.tline,cpos.l}

  cf.l = 0

  While (cf&#AB3TF_STOP)=0 AND cpos<*tline\clength
    cpos+1 : If cpos>=*tline\clength Then Function Return cpos
    cf.l = AmiBlitz3\CharFlags[Peek.b(*tline\text + cpos)&$FF]
  Wend
  Function Return cpos

End Function


Function.l FAST _ab3_SkipBinary{*tline.tline,cpos.l}

  cf.l = 0

  Repeat
    cpos+1 : If cpos>=*tline\clength Then Function Return cpos
    cf.l = AmiBlitz3\CharFlags[Peek.b(*tline\text + cpos)&$FF]
    If (cf&#AB3TF_BIN)=0 Then Function Return cpos-1
  Until cpos>=*tline\clength

  Function Return cpos

End Function

Function.l FAST _ab3_SkipHex{*tline.tline,cpos.l}

  Repeat
    If cpos<*tline\clength
      cf.l = AmiBlitz3\CharFlags[Peek.b(*tline\text + cpos)&$FF]
    Else
      cf = 0
    End If
    cpos+1
  Until (cf&#AB3TF_HEX)=0 OR cpos>=*tline\clength

  Function Return cpos-1

End Function


Function.l FAST _ab3_ParseNumber{*tline.tline,cpos.l}

  opos.l = cpos-1
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}

  Repeat
    If cpos<*tline\clength
      cf.l = AmiBlitz3\CharFlags[Peek.b(*tline\text + cpos)&$FF]
    Else
      cf = 0
    End If
    cpos+1
  Until (cf&#AB3TF_DEC)=0 OR cpos>=*tline\clength

  If (Peek.b(*tline\text + cpos-1)=@".") ; has a decimal point
    Repeat
      If cpos<*tline\clength
        cf.l = AmiBlitz3\CharFlags[Peek.b(*tline\text + cpos)&$FF]
      Else
        cf = 0
      End If
      cpos+1
    Until (cf&#AB3TF_DEC)=0 OR cpos>=*tline\clength
  End If

  cpos-1
  _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
  Function Return cpos

End Function


_ab3_StyleCallback:
Function.l _ab3_StyleCallback{*textBox.tuiTextBox,lpos.l,*tline.tline}

  If *tline\text
    *tline\sclength = 0
    tokenlength.l   = 0
    accept.w        = True
    bptr.l          = *tline\text ; base pointer
    clength.l       = *tline\clength ; end pointer
    hash.l          = 0
    cpos.l          = 0
    first.w         = True
    *hm.hashmap     = AmiBlitz3\Tokens
    *cm.hashmap     = AmiBlitz3\LTokens
    *tempP.b        = (.b)AmiBlitz3\TempP

    While cpos<clength
      c.b = Peek.b(bptr+cpos) : cpos+1
      cf.l = AmiBlitz3\CharFlags[c&$FF]

      If (cf&#AB3TF_COMMENT) Then cpos = _ab3_ParseComment{*tline,cpos}   : cf = 0 : c=0 : first=False
      If (cf&#AB3TF_QUOT   ) Then cpos = _ab3_ParseString{*tline,cpos,#TUITBPEN_STRING}    : cf = 0 : c=0 : first=False
      If (cf&#AB3TF_FIRST  ) Then cpos = _ab3_ParseToken{*tline,cpos,*hm,*cm,first,*tempP} : cf = 0 : c=0 : first=False
      If (cf&#AB3TF_DEC    ) Then cpos = _ab3_ParseNumber{*tline,cpos}    : cf = 0 : c=0 : first=False

      Select c
        Case @":" : first=True
        Case @"#"
          Select Peek.b(bptr+cpos)
            Case $22
              _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
              cpos = _ab3_ParseString{*tline,cpos+1,#TUITBPEN_NUMBER}
            Default
              _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
              cpos = _ab3_SkipToken{*tline,cpos}
             _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          End Select
          first=False

        Case @"!"
          _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_MACRO,0}
          _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_BOLD,1,0}
                                                                                                                                                                                                                                                WANTTAB
          cpos = _ab3_SkipToken{*tline,cpos}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          first=False

        Case @"."
          If first ; label
            ;_tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_LABEL,0}
            cpos = _ab3_SkipToken{*tline,cpos}
            ;_tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          Else
            _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TYPE,0}
            ;_tb_SetStyleCommand{*tline,cpos,#TUITBSC_ITALIC,1,0}
            cpos = _ab3_SkipToken{*tline,cpos}
            ;_tb_SetStyleCommand{*tline,cpos,#TUITBSC_ITALIC,0,0}
            _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          End If
          first=False
          
        Case @"'" ; local label
          cpos = _ab3_SkipToken{*tline,cpos}
          first=False
          
        Case @"\"
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_MEMBER,0}
          cpos = _ab3_SkipToken{*tline,cpos}
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          first=False

        Case @"%"
          _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
          cpos = _ab3_SkipBinary{*tline,cpos}
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          first=False

        Case @"$"
          _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
          cpos = _ab3_SkipHex{*tline,cpos}
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          first=False

        Case @"@"
          Select Peek.b(bptr+cpos)
            Case @"@" ; its @@
              _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_DIRECTIVE,0}
              cpos+1
              _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
              If cpos<clength ; remaining chars
                _tb_SetStyleCommand{*tline,cpos,#TUITBSC_WARN,1,#TUIPEN_RED}
                cpos=clength
              End If
            Case $22 ; its @"ILBM"
              _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
              cpos = _ab3_ParseString{*tline,cpos+1,#TUITBPEN_NUMBER}
            Case @"#" ; its @#constant
              _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
              cpos = _ab3_SkipToken{*tline,cpos}
             _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
            Default
              ;_tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_WARN,1,#TUIPEN_RED}
              cpos = _ab3_SkipToken{*tline,cpos}
              ;_tb_SetStyleCommand{*tline,cpos,#TUITBSC_WARN,0}

          End Select
          first=False
          
        Default
          ; hm, could only be space or illegal
          If ((cf&#AB3TF_ILLEGAL)><0) AND (cpos<*tline\clength-1)
            _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_WARN,1,#TUIPEN_RED}
            cpos=*tline\clength
          End If
      End Select
    Wend

    *tline\flags|#TUITBLF_STYLED
  End If
  Function Return #TUISCB_DONE

End Function
!_MakeGlobalFuncPointer{_ab3_StyleCallback,{Null,0,Null}}


Function.s cropfield{*stringP.b,pos.l,seperator.b,terminator.b}

  If pos>0
    Repeat
      c.b = Peek.b(*stringP) : *stringP+1
      If c=seperator Then pos-1
      If c=0 pos=-1
    Until pos<=0
  EndIf

  If pos=0
    *cropP.b = *stringP
    Repeat
      c.b = Peek.b(*stringP) : *stringP+1
    Until c=terminator OR c=0
    Function Return Peeks$(*cropP,*stringP-*cropP-1)
  End If
  
  Function Return ""

End Function


Function.s _ab3_GetInfoDecoratedSymbol{info.s}
  type_.s   = cropfield{info,0,$09,$09}

  Select type_
    Case "CONSTANT"
      name.s   = "#"+cropfield{info,1,$09,$09}
    Case "MACRO"
      name.s   = "!"+cropfield{info,1,$09,$09}
    Case "NEWTYPE"
      name.s   = "."+cropfield{info,1,$09,$09}
    Case "LABEL"
      name.s   = cropfield{info,1,$09,$09} + ":"
    Case "LOCAL"
      name.s   = cropfield{info,1,$09,$09} 
      xpos.l = Instr(name,":",0)
      If xpos > 0 Then name = Right$(name, FLen(name) - xpos)
    Case "GLOBAL"
      name.s   = cropfield{info,1,$09,$09}
    Default
      name.s   = cropfield{info,1,$09,$09}
  End Select

  Function Return name

End Function


Function.s _ab3_GetInfoType{info.s}
  Function Return cropfield{info,0,$09,$09}
End Function

Function.s _ab3_GetInfoSymbol{info.s}
  Function Return cropfield{info,1,$09,$09}
End Function

Function.s _ab3_GetInfoSource{info.s}
  Function Return cropfield{info,2,$09,$09}
End Function

Function.s _ab3_GetInfoLine{info.s}
  Function Return cropfield{info,3,$09,$09}
End Function

Function.s _ab3_GetInfoField4{info.s}
  Function Return cropfield{info,4,$09,$09}
End Function

Function.s _ab3_GetInfoField5{info.s}
  Function Return cropfield{info,5,$09,$09}
End Function

Function.s _ab3_GetInfoField6{info.s}
  Function Return cropfield{info,6,$09,$09}
End Function


Statement addSdkItem{*sdk.prefixtree,type_.s,name.s,info.s}

  pft_AddItem{*sdk,type_+":"+name,name+"\\09"+info}

End Statement


Statement genSdkMap{*sdk.prefixtree,*lsdk.prefixtree}

  If *sdk=Null Then Statement Return

  pft_Reset{*sdk}
  While pft_GetNextItem{*sdk}
    key.s = pft_GetKey{*sdk}
    type_.s = cropfield{key,0,@":",@":"}
    name.s  = cropfield{key,1,@":",@":"}
    lname.s = LCase$(name)
    If lname><name  ; redirect
      If pft_FindItem{*sdk,type_+":"+lname}=""
        pft_AddItem{*lsdk,type_+":"+lname,name}
      End If
    End If
  Wend

End Statement


Function.s getSdkItemInfo{*local.prefixtree,*local_l.prefixtree,*global.prefixtree,*global_l.prefixtree,type_.s,name.s}

  If *local
    info.s = pft_FindItem{*local,type_+":"+name}
    If info="" AND *local_l><Null
      rname.s = pft_FindItem{*local_l ,type_+":"+LCase$(name)}
      info.s = pft_FindItem{*local,type_+":"+rname}
    End If
    If info Then Function Return type_+"\\09"+info
  End If  
  
  If *global 
    info.s = pft_FindItem{*global,type_+":"+name}
    If info="" AND *global_l><Null
      rname = pft_FindItem{*global_l ,type_+":"+LCase$(name)}
      info.s = pft_FindItem{*global,type_+":"+rname}
    End If
    If info Then Function Return type_+"\\09"+info
  End If

  Function Return ""

End Function


Function.s getSdkLookAhead{*local.prefixtree,*local_l.prefixtree,*sdk.prefixtree,*sdk_l.prefixtree,type_.s,prefix.s}

  lhl.s = ""
  If *local
  succ.l = pft_Reset{*local,type_+":"+prefix}
  While pft_GetNextItem{*local}
    ;key.s = pft_GetKey{*sdk}
    info.s = pft_GetString{*local}
    name.s  = cropfield{info,0,$09,$09}
    lhl + name+"\\09"
  Wend
  If lhl><"" Then Function Return lhl
  End If

  If *sdk
  succ.l = pft_Reset{*sdk,type_+":"+prefix}
  While pft_GetNextItem{*sdk}
    ;key.s = pft_GetKey{*sdk}
    info.s = pft_GetString{*sdk}
    name.s  = cropfield{info,0,$09,$09}
    lhl + name+"\\09"
  Wend
  End If
  Function Return lhl
  
End Function

Function.s getSdkNewTypeOptions{*local.prefixtree,*local_l.prefixtree,*sdk.prefixtree,*sdk_l.prefixtree,prefix.s}

  lhl.s = ""
  If *local
    succ.l = pft_Reset{*local,"FIELD:"+prefix}
    While pft_GetNextItem{*local}
      info.s = pft_GetString{*local}
      name.s  = cropfield{info,0,$09,$09}
      xpos.l = Instr(name,"\",0)
      If xpos>0
        name = Right$(name, FLen(name) - xpos)
      End If
      type_.s  = cropfield{info,3,$09,$09}
      If type_ Then name + "."+type_
      lhl + name+"\\09"
    Wend
    If lhl><"" Then Function Return lhl
  End If

  If *sdk
    succ.l = pft_Reset{*sdk,"FIELD:"+prefix}
    While pft_GetNextItem{*sdk}
      info.s = pft_GetString{*sdk}
      name.s  = cropfield{info,0,$09,$09}
      type_.s  = cropfield{info,3,$09,$09}
      xpos.l = Instr(name,"\",0)
      If xpos>0
        name = Right$(name, FLen(name) - xpos)
      End If
      If type_ Then name + "."+type_
      lhl + name+"\\09"
    Wend
  End If
  Function Return lhl
  
End Function


Function.l _ab3_ImportAb3ScanFile{filename.s,*sdk.prefixtree,seperator.b}

  fid.l = file_Open{filename,#file_read}
  If fid<0 Function Return False
  sourcefile.s = ""
  newtype_.s   = ""
  function_.s  = ""

  ; format: ID:name             => name file line params       help
  ;         SOURCE:file         => file file    0              help
  ;         NEWTYPE:name        => name file line              help
  ;         FIELD:newtype\name  => name file line type         help
  ;         FUNCTION:name       => name file line return track help
  ;         FUNCTION:name       => name file line    ""  track help ; statement
  ;         MACRO:name          => name file line              help
  ;         CONSTANT:name       => name file line value        help
  ;         LABEL:name          => name file line              help
  ;         GLOBAL:name         => name file line type         help
  ;         LOCAL:function\name => name file line type         help
  ;         STRING:value        => valuefile line
  While file_EOF{fid}=False
    a.s = file_ReadLineF{fid}
    a= Replace$(a,"\\n","")
    ;a= ntui_EscapeListViewString{Null,a}
    id.s = cropfield{&a,0,seperator,seperator}
    Select id
      Case "SOURCE"   :
        sourcefile.s = cropfield{&a,1,seperator,seperator}
        ;sourcefile.s = Replace$(sourcefile,AmiBlitz3\IncludeDir,"%i")
        addSdkItem{*sdk,id,sourcefile,sourcefile+"\\09"+Str$(0)}

      Case "TOKEN"  :
        ltid.s      = cropfield{&a,1,seperator,seperator}
        tokenid.s   = cropfield{&ltid,1,@"/",$00}
        libid.s     = cropfield{&ltid,0,@"/",@"/"}
        token.s     = cropfield{&a,2,seperator,seperator}
        help.s      = cropfield{&a,3,seperator,$00}
        libidl.l    = Vallong(libid)
        If AmiBlitz3\BlitzLibName[libidl&$FF]><""
          sourcefile.s = AmiBlitz3\BlitzLibName[libidl&$FF]+" (BlitzLib #"+libid+"/"+tokenid+")"
        Else
          sourcefile.s = "BlitzLib #"+libid+"/"+tokenid
        End If
        addSdkItem{*sdk,id,token,sourcefile+"\\09"+"0"+"\\09"+help}

      Case "NEWTYPE"  :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        newtype_.s  = cropfield{&a,2,seperator,seperator}
        help.s      = cropfield{&a,3,seperator,$00}
        addSdkItem{*sdk,id,newtype_,sourcefile+"\\09"+codeline+"\\09"+help}
        
      Case "FIELD"    :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        field.s     = cropfield{&a,2,seperator,seperator}
        type_.s     = cropfield{&a,3,seperator,seperator}
        help.s      = cropfield{&a,4,seperator,$00}
        addSdkItem{*sdk,id,newtype_+"\"+field,sourcefile+"\\09"+codeline+"\\09"+type_+"\\09"+help}

      Case "FUNCTION" :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        function_.s = cropfield{&a,2,seperator,seperator}
        return_.s   = cropfield{&a,3,seperator,seperator}
        track.s     = cropfield{&a,4,seperator,seperator}
        help.s      = cropfield{&a,5,seperator,$00}
        addSdkItem{*sdk,id,function_,sourcefile+"\\09"+codeline+"\\09"+return_+"\\09"+track+"\\09"+help}
        
      Case "STATEMENT":
        codeline.s  = cropfield{&a,1,seperator,seperator}
        function_.s = cropfield{&a,2,seperator,seperator}
        track.s     = cropfield{&a,3,seperator,seperator}
        return_.s   = ""
        help.s      = cropfield{&a,4,seperator,$00}
        addSdkItem{*sdk,"FUNCTION",function_,sourcefile+"\\09"+codeline+"\\09"+return_+"\\09"+track+"\\09"+help}
        
      Case "MACRO"    :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        macro_.s    = cropfield{&a,2,seperator,seperator}
        help.s      = cropfield{&a,3,seperator,$00}
        addSdkItem{*sdk,id,macro_,sourcefile+"\\09"+codeline+"\\09"+help}
        
      Case "CONSTANT" :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        constant.s  = cropfield{&a,2,seperator,seperator} 
        value.s     = cropfield{&a,3,seperator,seperator}
        help.s      = cropfield{&a,4,seperator,$00}
        addSdkItem{*sdk,id,constant,sourcefile+"\\09"+codeline+"\\09"+value+"\\09"+help}

      Case "LABEL"    :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        label.s     = cropfield{&a,2,seperator,seperator}
        help.s      = cropfield{&a,3,seperator,$00}
        addSdkItem{*sdk,id,label,sourcefile+"\\09"+codeline+"\\09"+help}
        
      Case "GLOBAL"   :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        global.s    = cropfield{&a,2,seperator,seperator}
        type_.s     = cropfield{&a,3,seperator,seperator}
        help.s      = cropfield{&a,4,seperator,$00}
        addSdkItem{*sdk,id,global,sourcefile+"\\09"+codeline+"\\09"+type_+"\\09"+help}

      Case "LOCAL"   :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        local.s     = cropfield{&a,2,seperator,seperator}
        type_.s     = cropfield{&a,3,seperator,seperator}
        help.s      = cropfield{&a,4,seperator,$00}
        addSdkItem{*sdk,id,function_+":"+local,sourcefile+"\\09"+codeline+"\\09"+type_+"\\09"+help}

      Case "PARAM"   : id = "LOCAL" ; = local defined in track of function
        codeline.s  = cropfield{&a,1,seperator,seperator}
        local.s     = cropfield{&a,2,seperator,seperator}
        type_.s     = cropfield{&a,3,seperator,seperator}
        help.s      = cropfield{&a,4,seperator,$00}
        addSdkItem{*sdk,id,function_+":"+local,sourcefile+"\\09"+codeline+"\\09"+type_+"\\09"+help}

      Case "STRING"   :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        string.s    = cropfield{&a,2,seperator,seperator}
        help.s      = cropfield{&a,3,seperator,$00}
        addSdkItem{*sdk,id,string,sourcefile+"\\09"+codeline+"\\09"+string+"\\09"+help}
        
      Default : ; unkown, skip
    End Select
  Wend
  file_Close{fid}
  Function Return True
  
End Function


Function.l _ab3_ImportToken2LibFile{filename.s,*tokens.hashmap}

  AmiBlitz3\BlitzLibName[0] = "Intern0"
  AmiBlitz3\BlitzLibName[1] = "Intern1"

  fid.l = file_Open{filename,#file_read}
  If fid<0 Function Return False
  
  While file_EOF{fid}=False
    a.s = file_ReadLineF{fid}
    epos.l = Instr(a," ",0)
    tpos.l = Instr(a,";",epos+1)
    xpos.l = Instr(a," ",tpos+1)
    If xpos<=0 Then xpos = FLen(a)
    If tpos>0 Then While (Peek.b(&a+xpos-1)&$FF<=32) : xpos-1 : Wend
    If tpos>epos AND xpos>tpos
      libname.s = Left$(a,epos-1)
      token.s   = Mid$(a,tpos+1,xpos-tpos) 
      info.s    = hashmap_GetItem{*tokens,token}
      libid.l = (Peek.w(&info) LSR 7) & $FF
      tokid.l = (Peek.w(&info) & $7F)
      If info><""      
        AmiBlitz3\BlitzLibName[libid] = libname
      Else
        error{"Amiblitz3: Token NOT found in hashmap for reverse mapping: "+libname+"/"+token+"::"+Str$(libid)+"/"+Str$(tokid)+"!"}
      End If
    End If
  Wend
  file_Close{fid}
  
  Function Return True

End Function

Function.l _ab3_SaveBlitzLibNames{filename.s}

  fid.l = file_Open{filename,#file_forcewrite}
  If fid<0 Function Return False
  For libId.l = 0 To $FF
    file_WriteLine{fid,Str$(libId) + "\\09" + AmiBlitz3\BlitzLibName[libId]}
  Next
  file_Close{fid}
  Function Return True
  
End  Function

Function.l _ab3_LoadBlitzLibNames{filename.s}

  AmiBlitz3\BlitzLibName[0] = "Intern0"
  AmiBlitz3\BlitzLibName[1] = "Intern1"
  
  fid.l = file_Open{filename,#file_read}
  If fid<0 Function Return False
  While file_EOF{fid} = False
    a.s = file_ReadLine{fid}
    libId.l = Vallong(cropfield{&a,0,$09,$09})
    If (libId>=0) AND (libId<=$FF)
      AmiBlitz3\BlitzLibName[libId] = cropfield{&a,1,$09,$00}
    End If
  Wend
  file_Close{fid}
  Function Return True
  
End  Function

Function.l _ab3_ImportAb3DumpFile{filename.s,*sdk.prefixtree,*hm.hashmap,*cm.hashmap,*pft.prefixtree,sourcefile.s}

  fid.l = file_Open{filename,#file_read}
  If fid<0 Function Return False
  seperator.b = $20 ; SPACE
  newtype_.s = ""
  
  While file_EOF{fid}=False
    a.s = file_ReadLineF{fid}
    id.s = lindex{a,0}
    
    Select id
      Case "TOKEN"
        cookie.s    = cropfield{&a,1,seperator,seperator}
        tokenId.s   = cropfield{&cookie,1,@"/",$00}
        libId.s     = cropfield{&cookie,0,@"/",@"/"}
        name.s      = cropfield{&a,2,seperator,seperator}
        help.s      = cropfield{&a,3,seperator,$00}
        libId_l.l   = Vallong(libId)
        tokenId_l.l = Vallong(tokenId)
        If AmiBlitz3\BlitzLibName[libId_l&$FF]><""
          sourcefile.s = AmiBlitz3\BlitzLibName[libId_l&$FF]+" (BlitzLib #"+libId+"/"+tokenId+")"
        Else
          sourcefile.s = "BlitzLib #"+libId+"/"+tokenId
        End If
        If *sdk><Null Then addSdkItem{*sdk,id,name,sourcefile+"\\09"+"0"+"\\09"+help}
        
        If *hm><Null AND *cm><Null
          tokenW.w = (libId_l LSL 7) | tokenId_l | $8000
          tokenS.s = Peeks$(&tokenW,2)
          lname.s = LCase$(name)
          If hashmap_GetItem{*hm,name}="" AND hashmap_GetItem{*hm,lname}="" AND hashmap_GetItem{*cm,lname}=""
            hashmap_AddItem{*hm,name,tokenS}
            If *pft><Null Then pftlib_SetInt32{*pft,&name,tokenW & $FFFF}
            If *cm><Null AND name><lname Then hashmap_AddItem{*cm,lname,name}
          Else
            ; error{"Token Clash: "+name}
          End If
        End If
        
      Case "NEWTYPE"  :
        codeline.s  = "0"
        newtype_.s  = cropfield{&a,1,seperator,seperator}
        help.s      = cropfield{&a,2,seperator,$00}
        If *sdk><Null Then addSdkItem{*sdk,id,newtype_,sourcefile+"\\09"+codeline+"\\09"+help}
        
      Case "FIELD"    :
        codeline.s  = "0"
        field.s     = cropfield{&a,1,seperator,@"."}
        type_.s     = cropfield{&a,1,@".",seperator}
        help.s      = cropfield{&a,2,seperator,$00}
        If *sdk><Null Then addSdkItem{*sdk,id,newtype_+"\"+field,sourcefile+"\\09"+codeline+"\\09"+type_+"\\09"+help}
        
      Case "MACRO"    :
        codeline.s  = "0"
        macro_.s    = cropfield{&a,1,seperator,seperator}
        help.s      = cropfield{&a,2,seperator,$00}
        If *sdk><Null Then addSdkItem{*sdk,id,macro_,sourcefile+"\\09"+codeline+"\\09"+help}
        
      Case "CONSTANT" :
        codeline.s  = "0"
        constant.s  = cropfield{&a,1,seperator,seperator} 
        value.s     = cropfield{&a,2,seperator,seperator}
        help.s      = cropfield{&a,3,seperator,$00}
        If *sdk><Null Then addSdkItem{*sdk,id,constant,sourcefile+"\\09"+codeline+"\\09"+value+"\\09"+help}
        
    End Select
    
  Wend
  file_Close{fid}
  Function Return True
  
End Function


Function.l _ab3_ScanResidents{*SDK.prefixtree}

  residentdir.s = dos_AddPart{AmiBlitz3\Blitz3Path, "BlitzLibs/Residents"}
  Repeat
    resident.s = dos_ScanDir{residentdir,"#?.res",#dos_scan_files}
    resident = dos_FilePart{resident}
    If resident
      StartUp_Message{"query "+resident+" from AmiBlitz3..."}
      tokenfile.s  = dos_AddPart{AmiBlitz3\AIDEDir,"res_"+resident+".txt"}
      sourcefile.s = dos_AddPart{AmiBlitz3\AIDEDir,"res_"+resident+".ab3"}
      fid.l = file_Open{sourcefile, #file_forcewrite}
      If fid>=0
        file_WriteLine{fid,"; XTRA"}
        file_WriteLine{fid,"; Residents       = \\22"+resident+"\\22"}
        file_WriteLine{fid,"; /XTRA"}
        file_WriteLine{fid,"End"}
        file_Close{fid}
        dos_RunCli{AmiBlitz3\Exe,0,-1,True,"-source "+sourcefile+" -dump macro|type|const "+tokenfile+""}
        _ab3_ImportAb3DumpFile{tokenfile,*SDK,Null,Null,Null,resident}
      End If
    End If
  Until resident = ""

  Function Return True
  
End Function


AmiBlitz3_ScanSDK:
Statement AmiBlitz3_ScanSDK{}

  Stop
  StartUp_Message{"setup AmiBlitz3 SDK database..."}

  residentsfile.s  = dos_AddPart{AmiBlitz3\AIDEDir,"residents.tmp.txt"}
  tokenfile.s      = dos_AddPart{AmiBlitz3\AIDEDir,"tokens.tmp.txt"}
  includesfile.s   = dos_AddPart{AmiBlitz3\AIDEDir,"includes.tmp.txt"}

  dos_Delete{residentsfile}
  dos_Delete{tokenfile}
  dos_Delete{includesfile}
  
  *tokens.hashmap = hashmap_Create{14}
  *ltokens.hashmap = hashmap_Create{14}
  *tokenT.prefixtree = pft_Create{4096}
  If *tokens = Null OR *ltokens = Null OR *tokenT = Null Then Statement Return
  
  *SDK.prefixtree = pft_Create{1024*1024}
  *LSDK.prefixtree = pft_Create{1024*1024}
  If *SDK = Null OR *LSDK = Null Then Statement Return

  StartUp_Message{"query Blitz Tokens from AmiBlitz3..."}  
  dos_RunCli{AmiBlitz3\Exe,0,-1,True,"-dump token "+tokenfile+""}
  _ab3_ImportAb3DumpFile{tokenfile,*SDK,*tokens,*ltokens,*tokenT,""}
  
  StartUp_Message{"import BlitzLib mapping..."}
  tokenmapfile.s = dos_AddPart{AmiBlitz3\Blitz3Path,"System/token_mapping_libs.txt"}
  _ab3_ImportToken2LibFile{tokenmapfile,*tokens}
  
  StartUp_Message{"scan AmiBlitz3 includes..."}      
  ab3scan.s = dos_AddPart{AmiBlitz3\AIDEDir,"AB3Scan"}
  
  ; blocking
  ;dos_RunCli{ab3scan,0,-1,True,">"+includesfile+" "+AmiBlitz3\IncludeDir+" -r -df SFMTNCGL"}

  ; asnyc
  params.s = AmiBlitz3\IncludeDir+" -r -df SFMTNCGL"
  If ntui_RunAsyncAndNotify{*ntui,ab3scan,params,includesfile,"SCANDONE",0,""}
    done.l = False
    Repeat
      *notify.tuiNotify = ntui_WaitNotify{*ntui}
      Select ntui_GetNotifyID{*notify}
        Case "ev_splash_tick" : StartUp_Message{""}
        Case "SCANDONE" : done=True
      End Select
    Until done
    StartUp_Message{"import AmiBlitz3 include scan..."}  
    _ab3_ImportAb3ScanFile{includesfile,*SDK,$09}
  Else
    error{"Unable to run "+ab3scan+" "+params+"!"}
  End If
  
  StartUp_Message{"scan AmiBlitz3 residents..."}  
  _ab3_ScanResidents{*SDK}
    
  StartUp_Message{"generate AmiBlitz3 SDK lookup..."}  
  genSdkMap{*SDK,*LSDK}

  StartUp_Message{"sorting AmiBlitz3 SDK database..."}  
  pft_Sort{*SDK}
  
  StartUp_Message{"writing AmiBlitz3 SDK database..."}  
  hashmap_Save{*tokens,AmiBlitz3\TokenHashMapFile}
  hashmap_Save{*ltokens,AmiBlitz3\TokenHashMapFileL}
  pft_Save{*tokenT,AmiBlitz3\TokenTreeFile}
  pft_Save{*SDK,AmiBlitz3\SdkFile}
  pft_Save{*LSDK,AmiBlitz3\SdkFileL}
  _ab3_SaveBlitzLibNames{AmiBlitz3\BlitzLibNameFile}
  
  pft_Free{*tokenT}
  pft_Free{*SDK}
  pft_Free{*LSDK}
  hashmap_Free{*tokens}
  hashmap_Free{*ltokens}
  
End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_ScanSDK,{}}


Function.l _AmiBlitz3_Prepare{}

  StartUp_Message{"prepare AmiBlitz3 environment..."}

  If AmiBlitz3\TempP><Null Then FreeVec_ AmiBlitz3\TempP
  If AmiBlitz3\TokensT><Null Then pft_Free{AmiBlitz3\TokensT}
  If AmiBlitz3\SDK><Null Then pft_Free{AmiBlitz3\SDK}
  If AmiBlitz3\LSDK><Null Then pft_Free{AmiBlitz3\LSDK}
  If AmiBlitz3\Tokens><Null Then hashmap_Free{AmiBlitz3\Tokens}
  If AmiBlitz3\LTokens><Null Then hashmap_Free{AmiBlitz3\LTokens}

  AmiBlitz3\TempP = AllocVec_(1024,#MEMF_ANY)

  AmiBlitz3\Tokens  = hashmap_Load{AmiBlitz3\TokenHashMapFile}
  AmiBlitz3\LTokens = hashmap_Load{AmiBlitz3\TokenHashMapFileL}
  AmiBlitz3\TokensT = pft_Load{AmiBlitz3\TokenTreeFile}
  
  AmiBlitz3\SDK  = pft_Load{AmiBlitz3\SdkFile}
  AmiBlitz3\LSDK = pft_Load{AmiBlitz3\SdkFileL}

  If AmiBlitz3\Tokens ; generate inverse mapping from libid/tokenid => token name
    If AmiBlitz3\Detokens=Null
      AmiBlitz3\Detokens = AllocVec_ (128*256*4,#MEMF_CLEAR)
    Else
      For n.l=0 To 128*256-1
        Poke.l AmiBlitz3\Detokens + n*4,Null
      Next
    End If

    *hm.hashmap = AmiBlitz3\Tokens
    *ta.l       = AmiBlitz3\Detokens
    If *ta><Null AND *hm><Null
      For n.l=0 To *hm\size-1
        ptr.l   = Peek.l(*hm\base + n*4)
        If ptr
          size.l   = Peek.l(ptr) : ptr +4
          endptr.l = ptr + size
          While ptr<endptr
            ikl.l = Peek.l(ptr) : ptr +4+ikl
            isl.l = Peek.l(ptr) : ptr +4+isl
            tokenIndex.l = (Peek.w(ptr-isl) & $7FFF)
            Poke.l *ta+tokenIndex*4,ptr-isl-4-ikl-4
          Wend
        End If
      Next
    End If
  End If

  _ab3_LoadBlitzLibNames{AmiBlitz3\BlitzLibNameFile}

  ;/* ================= Init Character Flags ============== */
  For n.l=0 To 255
    AmiBlitz3\CharFlags[n] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW
  Next

  AmiBlitz3\CharFlags[   0] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_EOL ; Null
  AmiBlitz3\CharFlags[   1] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SOH
  AmiBlitz3\CharFlags[   2] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; STX
  AmiBlitz3\CharFlags[   3] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ETX
  AmiBlitz3\CharFlags[   4] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; EOT
  AmiBlitz3\CharFlags[   5] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ENQ
  AmiBlitz3\CharFlags[   6] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ACK
  AmiBlitz3\CharFlags[   7] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; BELL
  AmiBlitz3\CharFlags[   8] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; BS  (backspace)
  AmiBlitz3\CharFlags[   9] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW|#AB3TF_SPACE ; TAB (tabulator)
  AmiBlitz3\CharFlags[  10] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW|#AB3TF_EOL ; LF  (line feed) Linux Return
  AmiBlitz3\CharFlags[  11] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; VT
  AmiBlitz3\CharFlags[  12] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; FF  (feed forward)
  AmiBlitz3\CharFlags[  13] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CR  (carrier return) Windows Return
  AmiBlitz3\CharFlags[  14] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SO
  AmiBlitz3\CharFlags[  15] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SI
  AmiBlitz3\CharFlags[  16] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; DLE
  AmiBlitz3\CharFlags[  17] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; DC1
  AmiBlitz3\CharFlags[  18] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CD2
  AmiBlitz3\CharFlags[  19] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CD3
  AmiBlitz3\CharFlags[  20] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CD4
  AmiBlitz3\CharFlags[  21] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; NAK
  AmiBlitz3\CharFlags[  22] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SYN
  AmiBlitz3\CharFlags[  23] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ETB
  AmiBlitz3\CharFlags[  24] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CAN (Cancel)
  AmiBlitz3\CharFlags[  25] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; EM
  AmiBlitz3\CharFlags[  26] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SUB
  AmiBlitz3\CharFlags[  27] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ESC (Escape)
  AmiBlitz3\CharFlags[  28] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; FS
  AmiBlitz3\CharFlags[  29] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; GS
  AmiBlitz3\CharFlags[  30] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; RS
  AmiBlitz3\CharFlags[  31] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; US
  AmiBlitz3\CharFlags[@" "] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY | #AB3TF_SPACE ; Space
  AmiBlitz3\CharFlags[@"!"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY | #AB3TF_IS
  AmiBlitz3\CharFlags[  34] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY | #AB3TF_QUOT
  AmiBlitz3\CharFlags[@"#"] = #AB3TF_STOP | #AB3TF_IS   | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"$"] = #AB3TF_STOP | #AB3TF_IS   | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"%"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"&"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"'"] = #AB3TF_STOP | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"("] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY | #AB3TF_BRACKET
  AmiBlitz3\CharFlags[@")"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY | #AB3TF_BRACKET
  AmiBlitz3\CharFlags[@"*"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"+"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@","] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"-"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"."] = #AB3TF_STOP | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"/"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"0"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_BIN | #AB3TF_HEX | #AB3TF_DEC
  AmiBlitz3\CharFlags[@"1"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_BIN | #AB3TF_HEX | #AB3TF_DEC
  AmiBlitz3\CharFlags[@"2"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX | #AB3TF_DEC
  AmiBlitz3\CharFlags[@"3"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX | #AB3TF_DEC
  AmiBlitz3\CharFlags[@"4"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX | #AB3TF_DEC
  AmiBlitz3\CharFlags[@"5"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX | #AB3TF_DEC
  AmiBlitz3\CharFlags[@"6"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX | #AB3TF_DEC
  AmiBlitz3\CharFlags[@"7"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX | #AB3TF_DEC
  AmiBlitz3\CharFlags[@"8"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX | #AB3TF_DEC
  AmiBlitz3\CharFlags[@"9"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX | #AB3TF_DEC
  AmiBlitz3\CharFlags[@":"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@";"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COMMENT | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"<"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"="] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@">"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"?"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"@"] = #AB3TF_STOP | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"A"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"B"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"C"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"D"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"E"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"F"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"G"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"H"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"I"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"J"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"K"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"L"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"M"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"N"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"O"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"P"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"Q"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"R"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"S"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"T"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"U"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"V"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"W"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"X"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"Y"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"Z"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"["] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY | #AB3TF_BRACKET
  AmiBlitz3\CharFlags[@"\"] = #AB3TF_STOP | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"]"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY | #AB3TF_BRACKET
  AmiBlitz3\CharFlags[@"^"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"_"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"`"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"a"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"b"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"c"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"d"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"e"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"f"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"g"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"h"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"i"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"j"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"k"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"l"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"m"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"n"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"o"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"p"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"q"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"r"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"s"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"t"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"u"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"v"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"w"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"x"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"y"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"z"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"{"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY | #AB3TF_BRACKET
  AmiBlitz3\CharFlags[@"|"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"}"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY | #AB3TF_BRACKET
  AmiBlitz3\CharFlags[@"~"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[ 127] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW

  AmiBlitz3\IsPrepared=True

  Function Return True

End Function


AmiBlitz3_Deinit:
Statement AmiBlitz3_Deinit{}

  If AmiBlitz3\TokensT  Then pft_Free{AmiBlitz3\TokensT}    : AmiBlitz3\TokensT  = Null
  If AmiBlitz3\Tokens   Then hashmap_Free{AmiBlitz3\Tokens} : AmiBlitz3\Tokens   = Null
  If AmiBlitz3\LTokens  Then hashmap_Free{AmiBlitz3\LTokens}: AmiBlitz3\LTokens  = Null
  If AmiBlitz3\Detokens Then FreeVec_ AmiBlitz3\Detokens    : AmiBlitz3\Detokens = Null
  If AmiBlitz3\TempP    Then FreeVec_ AmiBlitz3\TempP       : AmiBlitz3\TempP    = Null
  If AmiBlitz3\SDK      Then pft_Free{AmiBlitz3\SDK}        : AmiBlitz3\SDK      = Null
  If AmiBlitz3\LSDK     Then pft_Free{AmiBlitz3\LSDK}       : AmiBlitz3\LSDK     = Null
  AmiBlitz3\IsPrepared = False

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_Deinit,{}}

Function.l _AmiBlitz3_ExportAB3{docX.l,filename.s}

  succ.l = False
  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  *xtra.AmiBlitz3_Xtra = (.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra

  fid.l = file_Open{filename,#file_forcewrite}
  If fid>=0
    If *xtra
    file_WriteLine{fid,"; XTRA"}
    file_WriteLine{fid,"; Embedded .xtra Header"}
    file_WriteLine{fid,"; "}
    file_WriteLine{fid,"; General Info"}
    file_WriteLine{fid,"; -------------------------------------------------------"}
    file_WriteLine{fid,"; ExePath         = \\22"+str_Read{&*xtra\ExePath}+"\\22"}
    file_WriteLine{fid,"; ExeFile         = \\22"+str_Read{&*xtra\ExeFile}+"\\22"}
    file_WriteLine{fid,"; CreateIcon      = "+Str$(*xtra\CreateIcon)}
    file_WriteLine{fid,"; Residents       = \\22"+str_Read{&*xtra\Residents}+"\\22"}
    file_WriteLine{fid,"; "}
    file_WriteLine{fid,"; Compiler"}
    file_WriteLine{fid,"; -------------------------------------------------------"}
    file_WriteLine{fid,"; StringBuffer    = "+Str$(*xtra\StringBuffer)}
    file_WriteLine{fid,"; MakeSmallest    = "+Str$(*xtra\MakeSmallest)}
    file_WriteLine{fid,"; FuncOptimize    = "+Str$(*xtra\FuncOptimize)}
    file_WriteLine{fid,"; Version         = "+Str$(*xtra\MajorVersion)+"."+Str$(*xtra\MinorVersion)+"."+Str$(*xtra\PatchVersion)}
    file_WriteLine{fid,"; NumberOfBuilds  = "+Str$(*xtra\NumberOfBuilds)}
    file_WriteLine{fid,"; "}
    file_WriteLine{fid,"; Debugger"}
    file_WriteLine{fid,"; -------------------------------------------------------"}
    file_WriteLine{fid,"; CliArgs         = \\22"+str_Read{&*xtra\CliArgs}+"\\22"}
    file_WriteLine{fid,"; StackSize       = "+Str$(*xtra\StackSize)}
    file_WriteLine{fid,"; RuntimeDebug    = "+Str$(*xtra\UseDebugger)}
    file_WriteLine{fid,"; DebugInfo       = "+Str$(*xtra\DebugInfo)}
    file_WriteLine{fid,"; CreateDbgFile   = "+Str$(*xtra\CreateDbgFile)}
    file_WriteLine{fid,"; OverflowCheck   = "+Str$(*xtra\OverflowCheck)}
    file_WriteLine{fid,"; AssemblerCheck  = "+Str$(*xtra\AssemblerCheck)}
    file_WriteLine{fid,"; InterruptCheck  = "+Str$(*xtra\InterruptCheck)}
    file_WriteLine{fid,"; AutoRun         = "+Str$(*xtra\AutoRun)}
    file_WriteLine{fid,"; "}
    file_WriteLine{fid,"; Editor"}
    file_WriteLine{fid,"; -------------------------------------------------------"}
    file_WriteLine{fid,"; CursorLine      = "+Str$(*xtra\CursorLine)}
    file_WriteLine{fid,"; CursorColumn    = "+Str$(*xtra\CursorColumn)}
    file_WriteLine{fid,"; LabelSearch     = \\22"+str_Read{&*xtra\LabelSearch}+"\\22"}
    file_WriteLine{fid,"; LabelRemark     = "+Str$(*xtra\LabelRemark)}
    file_WriteLine{fid,"; LabelAll        = "+Str$(*xtra\LabelAll)}
    file_WriteLine{fid,"; LabelPosition   = "+Str$(*xtra\LabelPosition)}
    file_WriteLine{fid,"; "}
    file_WriteLine{fid,"; Blitz Objects"}
    file_WriteLine{fid,"; -------------------------------------------------------"}

    For n.l = 0 To 255
      If *xtra\MaxName[n]
        name.s = str_Read{&*xtra\MaxName[n]}
        name.s = Replace$(name," ","-")
        maxname.s = "; Max "+name
        If FLen(maxname)<18 Then maxname + LSet$(" ",18-FLen(maxname))
        file_WriteLine{fid,maxname+"= "+Str$(*xtra\MaxNum[n])}
      End If
    Next

    file_WriteLine{fid,"; /XTRA"}
    End If

    ntui_GetAttr{*textBox,#TUITBA_TOTALLINES,&total.l}
    For n.l=0 To total-1
      *ptr.b = n
      l.l = n
      If ntui_GetAttr{*textBox,#TUITBA_LINE,&*ptr} AND ntui_GetAttr{*textBox,#TUITBA_LINELENGTH,&l}
        If *ptr Then file_WriteMem{fid,*ptr,l}
      End If
    Next

    succ = True
    file_Close{fid}
  End If

  Function Return succ

End Function

Function.l _AmiBlitz3_ImportAB3{docX.l,filename.s}

  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  *xtra.AmiBlitz3_Xtra = (.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra
  maxObjCount.l = 0

  fp.l = Open_(&filename,#MODE_OLDFILE)
  If fp=Null Then Function Return 1

  blength.l = 0
  If Seek_ (fp,0,#OFFSET_END)><-1
    blength   = Seek_ (fp,0,#OFFSET_BEGINNING)
  End If
  If blength>0

    ntui_SetAttr{*textBox,#TUITBA_TEXT,Null}
    ntui_SetAttr{*textBox,#TUITBA_FILENAME,&filename}

    inP.l = AllocVec_(blength,#MEMF_ANY)
    If inP
      rlength.l = Read_ (fp,inP,blength)
      If rlength=blength

        sptr.l = inP
        eptr.l = inP+blength
        headerDone.l = False
        offset.l = 0

        Repeat
          lptr.l = sptr
          While Peek.b(sptr)><$0A AND sptr<eptr : sptr+1:Wend
          If sptr<eptr Then sptr+1:Else headerDone=True

          lin.s = Peeks$(lptr,sptr-lptr)
          eqpos.l = Instr(lin,"=")
          If eqpos>0
            rawtoken.s = Left$(lin,eqpos-1)
            value.s    = Right$(lin,FLen(lin)-eqpos-1)
          Else
            rawtoken.s = lin
            value.s    =  ""
          End If

          token.s    = ""
          For n.l=0 To FLen(rawtoken)-1    ; trim token
            c.b = Peek.b(&rawtoken+n)
            If (c>=@"a" AND c<=@"z") OR (c>=@"A" AND c<=@"Z") OR c=@"_" OR c=@"/" OR c=@"-"
              If (c=@"-") Then c=32 ; - to SPACE
              token + Chr$(c)
            End If
          Next

          ltrim.l = 0
          lmax.l  = FLen(value)
          While Peek.b(&value+ltrim)&$FF<=32 AND ltrim<lmax: ltrim+1 : Wend
          rtrim.l = lmax
          While Peek.b(&value+rtrim)&$FF<=32 AND rtrim>=0 : rtrim-1 : Wend
          If Peek.b(&value+rtrim)=$22 AND Peek.b(&value+ltrim)=$22 Then rtrim-1:ltrim+1
          value = Mid$(value,ltrim+1,rtrim-ltrim+1)
          lvalue.l = Vallong(value)


          If token
            ;error{"token: "+token+" / value="+value}

            Select LCase$(token)
              Case "/xtra"
                headerDone = True
                ; remove embedded XTRA Header
                offset = sptr-inP

              Case "exepath"        : str_Write{&*xtra\ExePath, value}
              Case "exefile"        : str_Write{&*xtra\ExeFile, value} ;: error{"Set exefile to "+str_Read{&*xtra\ExeFile}}
              Case "residents"      : str_Write{&*xtra\Residents, value}
              Case "stringbuffer"   : *xtra\StringBuffer = lvalue : If *xtra\StringBuffer<#AB3_MIN_STRINGBUFFER  Then *xtra\StringBuffer=#AB3_MIN_STRINGBUFFER
              Case "stacksize"      : *xtra\StackSize    = lvalue : If *xtra\StackSize   <#AB3_MIN_STACKSIZE     Then *xtra\StackSize   =#AB3_MIN_STACKSIZE
              Case "makesmallest"   : *xtra\MakeSmallest = lvalue
              Case "funcoptimize"   : *xtra\FuncOptimize = lvalue
              Case "version"
                mpos.l = Instr(value,".",1)
                ppos.l = Instr(value,".",mpos+1)                          ; fixed search of the second "." because we must start +1 behind the first founded one
                *xtra\MajorVersion = Vallong(Left$(value,mpos))
                *xtra\MinorVersion = Vallong(Mid$(value,mpos+1,ppos-mpos+1))
                *xtra\PatchVersion = Vallong(Right$(value,FLen(value)-ppos))  ; fixed leng calculation
              Case "numberofbuilds" : *xtra\NumberOfBuilds = lvalue
              Case "cliargs"        : str_Write{&*xtra\CliArgs, Left$(value,254)}
              Case "createicon"     : *xtra\CreateIcon     = lvalue
              Case "runtimedebug"   : *xtra\UseDebugger    = lvalue
              Case "debuginfo"      : *xtra\DebugInfo      = lvalue
              Case "createdbgfile"  : *xtra\CreateDbgFile  = lvalue
              Case "overflowcheck"  : *xtra\OverflowCheck  = lvalue
              Case "assemblercheck" : *xtra\AssemblerCheck = lvalue
              Case "interruptcheck" : *xtra\InterruptCheck = lvalue
              Case "autorun"        : *xtra\AutoRun        = lvalue
              Case "cursorline"     : *xtra\CursorLine     = lvalue
              Case "cursorcolumn"   : *xtra\CursorColumn   = lvalue
              Case "labelsearch"    : str_Write{&*xtra\LabelSearch, Left$(value,29)}
              Case "labelremark"    : *xtra\LabelRemark    = lvalue
              Case "labelall"       : *xtra\LabelAll       = lvalue
              Case "labelposition"  : *xtra\LabelPosition  = lvalue            ; added the read of inner position of the labellist tomsmart1
              Default
                ;error{"is max obj ?"+token}
                If LCase$(Left$(token,3))="max"
                  bobjName.s = Right$(token,FLen(token)-3)
                  If maxObjCount<256
                    str_Write{&*xtra\MaxName[maxObjCount],bobjName}
                    *xtra\MaxNum[maxObjCount] = lvalue
                    maxObjCount+1
                  End If
                End If

            End Select
          End If

        Until headerDone

        ;ntui_AppendTextBox{*textBox,inP+offset,rlength-offset}
        _ntui_SetTextBoxText{*textBox,inP+offset,rlength-offset}
      End If
      FreeVec_ inP
    End If
  End If
  Close_ fp

  Function Return 0

End Function


; detokenize a blitz source code buffer and write it to file pointer
Function.l _AmiBlitz3_ImportBB2{docX.l,filename.s}

  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  *xtra.AmiBlitz3_Xtra = (.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra

  *detokens.l = AmiBlitz3\Detokens
  If *detokens = Null Then Function Return 3

  inP.l  = AllocVec_(4096*2,#MEMF_ANY)
  outP.l = AllocVec_(4096*2,#MEMF_ANY)
  If inP=Null OR outP=Null Then Function Return 2

  fp.l = Open_(&filename,#MODE_OLDFILE)
  If fp=Null Then Function Return 1

  dptr.l        = outP               ; destination pointer
  wptr.l        = outP+4096          ; write if destpointer>wptr!
  sptr.l        = inP                ; source pointer
  rpos.l        = 0
  count.l       = 0

  ntui_SetAttr{*textBox,#TUITBA_TEXT,Null}
  ntui_SetAttr{*textBox,#TUITBA_FILENAME,&filename}

  Repeat

    r.l = Read_ (fp,inP+rpos,4096*2-rpos)
    If r>0 Then rpos+r
    sptr = inP
    rptr.l = inP + Min(rpos,4096)

    While sptr<rptr
      c.b  = Peek.b(sptr)

      If (c&$80)
        ; token...
        tokenIndex.l = ((c & $7F) LSL 8) | (Peek.b(sptr+1) & $FF)
        tokenNode.l  = Peek.l(*detokens + tokenIndex*4)
        If tokenNode
          tokenLength.l = Peek.l(tokenNode) : tokenNode+4
          If tokenLength<128
            For n.l=0 To tokenLength-1
              Poke.b dptr,Peek.b(tokenNode) : dptr+1 : tokenNode+1
            Next
          Else
            ; token is longer than 128 chars, WTF!?
          End If
        Else
          libid.l   = (tokenIndex LSR 7) & $FF
          tokenid.l = tokenIndex & $7F
          defToken.s = "????Lib"+Str$(libid)+"/"+Str$(tokenid)
          For n.l=0 To FLen(defToken)-1
            Poke.b dptr,Peek.b(&defToken+n) : dptr+1
          Next
        End If
        sptr+2
      Else
        If c=0   ; it's a newline
          Poke.b dptr,$0A : dptr+1 : sptr+1
        Else
          Poke.b dptr,c : dptr+1 : sptr+1
        End If

        If (c=@";") ; it's a comment!
          Repeat
            c  = Peek.b(sptr)
            Poke.b dptr,c : dptr+1
            sptr+1
          Until (c=0) ;OR (sptr>=rptr))
          If c=0 Then Poke.b dptr-1,$0A
        End If

        If (c=$22) ; it's a string!
          Repeat
            c  = Peek.b(sptr)
            Poke.b dptr,c : dptr+1
            sptr+1
          Until (c=$22) OR (c=0) ;OR (sptr>=rptr))
          If c=0 Then Poke.b dptr-1,$0A
        End If

      End If

      If dptr>=wptr
        wlen.l = dptr-outP
        ;Poke.b dptr,$00
        ;ntui_SetAttr{*textBox,#TUITBA_APPENDTEXT,outP}
        ntui_AppendTextBox{*textBox,outP,wlen}
        count + wlen
        dptr = outP
      End If
    Wend

    rpos = rpos - (sptr - inP)
    If rpos>0 Then CopyMem_ sptr,inP,rpos

  Until rpos<=0

  If dptr>outP
    wlen.l = dptr-outP
    ;Poke.b dptr,$00
    ;ntui_SetAttr{*textBox,#TUITBA_APPENDTEXT,outP}
    ntui_AppendTextBox{*textBox,outP,wlen}
    count + wlen
    dptr = outP
  End If


  FreeVec_ inP
  FreeVec_ outP
  Close_ fp

  Function Return 0

End Function


AmiBlitz3_Import:
Function.l AmiBlitz3_Import{docX.l,*filenameP.b}

  err.l      = 0
  filename.s = Peek.s(*filenameP)
  ex.s       = dos_GetExt{filename}
  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  ntui_SetAttr{*textBox,#TUITBA_UNDO,False}
  Select ex
    Case "ab2"
      err.l = ntui_LoadTextBox{*textBox,&filename}
      AIDE\Document[docX]\IsLocked = True
    Case "ab3"
      err.l = _AmiBlitz3_ImportAB3{docX,filename}
      ntui_SetAttr{*textBox,#TUITBA_UNDO,True}
      AIDE\Document[docX]\IsLocked = False
    Case "bb2"
      err.l = _AmiBlitz3_ImportBB2{docX,filename}
      AIDE\Document[docX]\IsLocked = True
    Case "bb"
      err.l = _AmiBlitz3_ImportBB2{docX,filename}
      AIDE\Document[docX]\IsLocked = True
    Default
      err.l = ntui_LoadTextBox{*textBox,&filename}
      AIDE\Document[docX]\IsLocked = True
  End Select

  Function Return err

End Function
!_MakeGlobalFuncPointer{AmiBlitz3_Import,{0,Null}}


AmiBlitz3_Export:
Function.l AmiBlitz3_Export{docX.l,*filenameP.b}

  err.l = -1
  filename.s = Peek.s(*filenameP)
  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  ex.s       = dos_GetExt{filename}

  Select ex
    Case "ab2"
      err.l = ntui_SaveTextBox{*textBox,&filename}
      If err = 0 Then AIDE\Document[docX]\IsLocked = True
    Case "ab3"
      If _AmiBlitz3_ExportAB3{docX,filename}  
        err=0
        AIDE\Document[docX]\IsLocked = False
      End If
    Case "bb2"
      error{"Saving as .bb2 is not supported, please use .ab3"}
    Case "bb"
      error{"Saving as .bb is not supported, please use .ab3"}
    Default
      err.l = ntui_SaveTextBox{*textBox,&filename}
      If err = 0 Then AIDE\Document[docX]\IsLocked = True
  End Select

  Function Return err

End Function
!_MakeGlobalFuncPointer{AmiBlitz3_Export,{0,Null}}


AmiBlitz3_UpdateBrowser:
Statement AmiBlitz3_UpdateBrowser{docX.l}

  *sdk.prefixtree = Null

  If docX>=0
    *xtra.AmiBlitz3_Xtra = (.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra
    If *xtra
      *sdk = *xtra\LocalSDK  
    End If
    *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*ntui,!obj_src_list}
    *fi.tuiImageView = (.tuiImageView)ntui_GetObjectByID{*ntui,!obj_src_filter_image}
    *stats.tuiLabel   = (.tuiLabel)ntui_GetObjectByID{*ntui,!obj_src_filter_stats}
    func.l = ntui_GetValueByID{*ntui,!obj_src_show_function}
    macr.l = ntui_GetValueByID{*ntui,!obj_src_show_macro}
    newt.l = ntui_GetValueByID{*ntui,!obj_src_show_struct}
    labe.l = ntui_GetValueByID{*ntui,!obj_src_show_label}
    cons.l = ntui_GetValueByID{*ntui,!obj_src_show_constant}
    glob.l = ntui_GetValueByID{*ntui,!obj_src_show_global}
    loca.l = ntui_GetValueByID{*ntui,!obj_src_show_local}
    stri.l = ntui_GetValueByID{*ntui,!obj_src_show_string}
    ;toke.l = ntui_GetValueByID{*ntui,!obj_src_show_token}
    all.l  = ntui_GetValueByID{*ntui,!obj_src_show_all}
    filt.s = ntui_GetStringByID{*ntui,!obj_src_filter}
  Else
    *sdk = AmiBlitz3\SDK
    *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*ntui,!obj_ab3_list}
    *fi.tuiImageView = (.tuiImageView)ntui_GetObjectByID{*ntui,!obj_ab3_filter_image}
    *stats.tuiLabel   = (.tuiLabel)ntui_GetObjectByID{*ntui,!obj_ab3_filter_stats}
    func.l = ntui_GetValueByID{*ntui,!obj_ab3_show_function}
    macr.l = ntui_GetValueByID{*ntui,!obj_ab3_show_macro}
    newt.l = ntui_GetValueByID{*ntui,!obj_ab3_show_struct}
    labe.l = ntui_GetValueByID{*ntui,!obj_ab3_show_label}
    cons.l = ntui_GetValueByID{*ntui,!obj_ab3_show_constant}
    glob.l = ntui_GetValueByID{*ntui,!obj_ab3_show_global}
    ;loca.l = ntui_GetValueByID{*ntui,!obj_ab3_show_local}
    ;stri.l = ntui_GetValueByID{*ntui,!obj_ab3_show_string}
    toke.l = ntui_GetValueByID{*ntui,!obj_ab3_show_token}
    all.l  = ntui_GetValueByID{*ntui,!obj_ab3_show_all}
    filt.s = ntui_GetStringByID{*ntui,!obj_ab3_filter}
  End If
  
  #MAX_AB3RESULTS = 1000
  If all 
    func=True:macr=True:newt=True:labe=True:cons=True:glob=True:loca=True:stri=True:toke=True
    prefix.s = ""
  Else
    If func Then prefix="FUNCTION"
    If macr Then prefix="MACRO"
    If newt Then prefix="NEWTYPE"
    If labe Then prefix="LABEL"
    If cons Then prefix="CONSTANT"
    If glob Then prefix="GLOBAL"
    If loca Then prefix="LOCAL"
    If stri Then prefix="STRING"
    If toke Then prefix="TOKEN"
  End If
  count.l = 0
  
  filt = LCase$(filt)
  
  If *lv><Null AND *sdk><Null
    ntui_ClearListView{*lv}
    title.s = "\pinfo|\lEntity Name|\lMore..."
    ntui_SetAttr{*lv,#TUILVA_TITLE,&title}
    pft_Reset{*sdk,prefix}
    scount.l=0

    While pft_GetNextItem{*sdk} AND count<#MAX_AB3RESULTS
      scount+1
      ;key.s  = pft_GetKey{*sdk}
      key.l = pftlib_GetFoundKey{*sdk,&keyLen.l}
      addit.l = False
        
      Select Peek.l(key)
        Case @"FUNC":
          If func
            info.s   = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            type_.s  = cropfield{info,3,$09,$09}
            track.s  = cropfield{info,4,$09,$09}
            help.s   = cropfield{info,5,$09,$00}
            text.s   = "F|"+name+"|" + "{"+track+"}"
            If type_><"" Then text + " => ."+type_+" "
            If help><"" Then text+" ; "+help
            addit = True
          End If

        Case @"MACR"
          If macr
            info.s = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            help.s  = cropfield{info,3,$09,$09}
            text.s = "M|!"+name +"|"
            If help><"" Then text+"; "+help
            addit = True
          End If

        Case @"TOKE"
          If toke
            info.s = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            help.s  = cropfield{info,3,$09,$09}
            text.s = "@|"+name +"|"+ntui_EscapeListViewString{*lv,help}
            addit = True
          End If

        Case @"CONS"
          If cons
            info.s = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            value.s  = cropfield{info,3,$09,$09}
            help.s  = cropfield{info,4,$09,$09}
            text.s = "C|#"+name + "|= "+value
            If help><"" Then text+" ; "+help
            addit = True
          End If

        Case @"NEWT"
          If newt
            info.s = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            help.s  = cropfield{info,3,$09,$09}
            text.s = "NT|."+name+"|"
            If help><"" Then text+"; "+help
            addit = True
          EndIf

        Case @"LABE"
          If labe
            info.s = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            help.s  = cropfield{info,3,$09,$09}
            text.s = "L|:"+name+"|"
            If help><"" Then text+"; "+help
            addit = True
          End If

        Case @"STRI"
          If stri
            info.s = pft_GetString{*sdk}
            ;name.s     = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            help.s     = cropfield{info,4,$09,$09}
            string.s   = cropfield{info,3,$09,$09}
            string     = ntui_EscapeListViewString{*lv,string}
            text.s = "$|"+"\d<literal>"+"|"+string+"|"
            ;If help><"" Then text+"; "+help
            addit = True
          End If

        Case @"GLOB"
          If glob
            info.s = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            typ.s    = cropfield{info,3,$09,$09}
            help.s  = cropfield{info,4,$09,$09}
            text.s = "G|"+name+"|."+typ+""
            If help><"" Then text+" ; "+help
            addit = True
          End If

        Case @"LOCA"
          If loca
            info.s   = pft_GetString{*sdk}
            name.s   = ntui_EscapeListViewString{*lv,cropfield{info,0,$09,$09}}
            ;xpos.l   = Instr(name,"\")
            ;infunc.s   = "???"
            ;If xpos>0
            ;  infunc = Left$(name,xpos-1)
            ;  name   = Right$(name,FLen(name)-xpos)
            ;End If
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            typ.s    = cropfield{info,3,$09,$09}
            help.s   = cropfield{info,4,$09,$09}
            text.s  = "V|"+name+"|."+typ+""
            If help><"" Then text+" ; "+help
            addit = True
          End If

        Default
          addit = False

      End Select

      If addit
        ;If filt><"" Then addit.l = instr_nocase{text,filt}
        If filt><"" Then addit.l = instr_nocaseP{&text,FLen(text),&filt,FLen(filt),0}
        If addit
          count+1
          ntui_AddListItem{*lv,-1,text,-1,Null,$0}
        End If
      End If

    Wend
  EndIf
  image.s = "filter"
  text.s = Str$(count)+" results out of "+Str$(scount)+" total"
  If count<=0    Then image+"|off"
  If scount<=0 Then text="no entities found"
  If count>=#MAX_AB3RESULTS Then image+"|stop" : text = "truncated to "+Str$(count)
  If *fi Then ntui_SetAttr{*fi,#TUIIVA_IMAGE,&image}
  If *stats Then ntui_SetString{*stats,text}

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_UpdateBrowser,{0}}

Function.l _ab3_JumpToSDKItemInfo{info.s}

  If info = "" Then Function Return False
  source.s = _ab3_GetInfoSource{info}
  line_.s  = _ab3_GetInfoLine{info}
  lpos.l   = Vallong(cropfield{line_,0,@"/",@"/"})
  cpos.l   = Vallong(cropfield{line_,1,@"/",0})
  ex.s = dos_GetExt{source}
  If ex = "ab3" OR ex = "ab2" OR ex = "bb2"
    docX.l   = Document_Open{source}
    If lpos>0 Then lpos-1
    If cpos>0 Then cpos-1
    Document_JumpTo{docX,lpos,cpos,True}
    Function Return True
  End If
    
  Function Return False
  
End Function


AmiBlitz3_JumpTo:
Function.l AmiBlitz3_JumpTo{docX.l,*typeP.b,*nameP.b,*moreP.b}

  If *nameP Then name.s  = Peek.s(*nameP)
  If *typeP Then type_.s = Peek.s(*typeP)
  If *moreP Then more.s  = Peek.s(*moreP)
  
  *localSDK.prefixtree = Null
  *localLSDK.prefixtree= Null

  If docX>=0
    *xtra.AmiBlitz3_Xtra = (.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra
    If *xtra
      *localSDK  = *xtra\LocalSDK
      *localLSDK = *xtra\LocalLSDK
    End If
  End If
  
  Select type_
    Case "C"  : info.s = getSdkItemInfo{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"CONSTANT",UnRight$(name,1)}
    Case "NT" : info.s = getSdkItemInfo{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"NEWTYPE" ,UnRight$(name,1)}
    Case "M"  : info.s = getSdkItemInfo{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"MACRO"   ,UnRight$(name,1)}
    Case "L"  : info.s = getSdkItemInfo{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"LABEL"   ,UnRight$(name,1)}
    Case "G"  : info.s = getSdkItemInfo{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"GLOBAL"  ,name}
    Case "V"  : info.s = getSdkItemInfo{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"LOCAL"   ,name}
    Case "@"  : info.s = getSdkItemInfo{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"TOKEN"   ,name}      ; call the guide!
    Case "$"  : info.s = getSdkItemInfo{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"STRING"  ,more}
    Case "F"  : info.s = getSdkItemInfo{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"FUNCTION",name}
    Default
      info.s  = ""
      error{"Unkown entity to jump to : "+type_+"!"}
  End Select
  
  _ab3_JumpToSDKItemInfo{info}
  
  Function Return 0
  
End Function
!_MakeGlobalFuncPointer{AmiBlitz3_JumpTo,{0,Null,Null,Null}}

Function.s _ab3_GetScanResultFilename{docX.l}
  Function Return "RAM:AB3"+Hex$(FindTask_(Null))+Str$(docX)+".async.txt"
End Function


AmiBlitz3_ScanSourceFinish:
Statement AmiBlitz3_ScanSourceFinish{docX.l,*filenameP.b}

  ;If *filenameP=Null Then Statement Return

  resultfile.s = _ab3_GetScanResultFilename{docX.l}

  *xtra.AmiBlitz3_Xtra = (.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra
  If *xtra=Null Then Statement Return

  If *xtra\LocalSDK Then pft_Free{*xtra\LocalSDK} : *xtra\LocalSDK = Null
  If *xtra\LocalLSDK Then pft_Free{*xtra\LocalLSDK} : *xtra\LocalLSDK = Null

  If *xtra\LocalSDK = Null Then *xtra\LocalSDK   = pft_Create{4096}
  If *xtra\LocalSDK = Null Then Statement Return

  If *xtra\LocalLSDK = Null Then *xtra\LocalLSDK = pft_Create{4096}
  If *xtra\LocalLSDK = Null Then Statement Return

  If *xtra\LocalSDK
    _ab3_ImportAb3ScanFile{resultfile,*xtra\LocalSDK,$09}
    pft_Sort{*xtra\LocalSDK}
    If *xtra\LocalLSDK
      genSdkMap{*xtra\LocalSDK,*xtra\LocalLSDK}
    End If
  End If

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_ScanSourceFinish,{0,Null}}


AmiBlitz3_ScanSource:
Statement AmiBlitz3_ScanSource{docX.l,*filenameP.b}

  filename.s   = Peek.s(*filenameP)
  resultfile.s = _ab3_GetScanResultFilename{docX}
  ab3scan.s    = dos_AddPart{AmiBlitz3\AIDEDir,"AB3Scan"}
  params.s     = filename

  fid.l = file_Open{resultfile,#file_forcewrite}
  If fid>=0
    fh.l = file_GetFH{fid}
    dos_RunCli{ab3scan,-1,-1,True,params,Null,fh}
    file_Close{fid}
    AmiBlitz3_ScanSourceFinish{docX.l,*filenameP.b}
  End If

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_ScanSource,{0,Null}}


AmiBlitz3_ScanSourceAsync:
Statement AmiBlitz3_ScanSourceAsync{docX.l,*filenameP.b}

  filename.s   = Peek.s(*filenameP)
  resultfile.s = _ab3_GetScanResultFilename{docX}
  ab3scan.s    = dos_AddPart{AmiBlitz3\AIDEDir,"AB3Scan"}
  params.s     = filename

  ntui_RunAsyncAndNotify{*ntui,ab3scan,params,resultfile,"FILESCAN",docX,filename}

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_ScanSourceAsync,{0,Null}}


Function.l _ab3_FindReplaceStart{*textP.b,cpos.l}
  While cpos>0
    cpos-1
    c.w=Peek.b(*textP+cpos)&$FF 
    If (AmiBlitz3\CharFlags[c]&#AB3TF_IS) = 0 Then Function Return cpos + 1
  Wend
  Function Return cpos
  
End Function


Function.s _ab3_CropPrevToken{*textP.b,cpos.l,*fpos.l}

  If cpos<0 Then Function Return ""
  rbc.l = 0
  cbc.l = 0
  token.s = ""
  done.l = False
  from.l = -1
  to_.l  = -1
  Repeat
    c.w=Peek.b(*textP+cpos)&$FF 
    
    If c=@"{" Then cbc-1
    If c=@"}" Then cbc+1
    If c=@"(" Then rbc-1
    If c=@")" Then rbc+1
    If c=@"[" Then rbc-1
    If c=@"]" Then cbc+1
    
    If rbc<=0 AND cbc<=0
      If AmiBlitz3\CharFlags[c]&#AB3TF_IS
        from=cpos
      End If 
    End If
    If ((from>=0) AND ((AmiBlitz3\CharFlags[c]&#AB3TF_IS) = 0)) Then done=True
    cpos-1
  Until done=True OR cpos<0

  If from<0 Then Function Return ""
  to_=from
  Repeat
    c.w=Peek.b(*textP+to_)&$FF : to_+1
  Until AmiBlitz3\CharFlags[c]&#AB3TF_IS = 0
  token = Peeks$(*textP+from,to_-from-1)
    
  If *fpos Then Poke.l *fpos,from
  Function Return token
  
End Function

;      aaa bbb ccc
; this:aaaabbbbccc
; next:bbbbcccc
; prev:    aaaabbb
Function.s _ab3_CropNextToken{*textP.b,textLen.l,cpos.l,*fpos.l}

  If cpos>=textLen Then Function Return ""
  from.l = cpos
  If from<0 Then from=0  
  c.w = Peek.b(*textP+from)&$FF
  state.l = (AmiBlitz3\CharFlags[c]&#AB3TF_IS)
  done.l = False
  Repeat
    from+1
    c.w = Peek.b(*textP+from)&$FF
    If (AmiBlitz3\CharFlags[c]&#AB3TF_IS)><state
      If state=0 Then done=True : Else state=0
    End If
  Until done OR from>=textLen
  
  to_.l = from
  Repeat
    to_+1
    c.w = Peek.b(*textP+to_)&$FF
  Until (AmiBlitz3\CharFlags[c]&#AB3TF_IS=0) OR to_>=textLen

  If from>0
    c.w = Peek.b(*textP+from)&$FF
    If c = @"*" Then from-1
    If c = @"." Then from-1
    If c = @"#" Then from-1
  End If

  token.s = Peeks$(*textP+from,to_-from)
  If *fpos Then Poke.l *fpos,from
  Function Return token
  
End Function

Function.s getSdkContext_{*local.prefixtree,lpos.l,cpos.l}

  context.s = ""
  flpos.l = 0
  succ.l = pft_Reset{*local,"F:"}
  While pft_GetNextItem{*local}
    key.s = pft_GetKey{*local}
    info.s = pft_GetString{*local}
    line_.s  = cropfield{info,2,$09,$09}
    name.s  = cropfield{info,1,$09,$09}
    slpos.l   = Vallong(cropfield{line_,0,@"/",@"/"})
    scpos.l   = Vallong(cropfield{line_,1,@"/",0})
    If slpos<=lpos AND slpos>=flpos
      context = name
      flpos = slpos
    End If
  Wend
  Function Return context
  
End Function

_ab3_OnLoseFocusCallback:
Function.l _ab3_OnLoseFocusCallback{*textBox.tuiTextBox, *ev.tuiEvent, *notify.str}

  Popup_Help{"","","",0,0}
  Function Return False
  
End Function
!_MakeGlobalFuncPointer{_ab3_OnLoseFocusCallback,{Null,Null,Null}}


_ab3_OnKeyCallback:
Function.l _ab3_OnKeyCallback{*textBox.tuiTextBox,*ev.tuiEvent,*notify.str}

  *inputSelector.tuiWindow = ntui_GetWindowByID{*ntui,!win_inputselector}

  If *inputSelector
    ntui_GetAttr{*inputSelector,#TUIA_ONSCREEN,&onScreen.l}
    If onScreen
     *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*inputSelector,!obj_selector_list}
     If *lv
      ntui_GetEventAttr{*ev,#TUIEVA_RAWKEY,&rkey.l}
      ntui_GetEventAttr{*ev,#TUIEVA_VANILLAKEY,&vkey.l}
      Select rkey
        Case #RAWKEY_UP
          _ntui_DispatchEvent{*lv,*ev}
          Function Return True
        Case #RAWKEY_DOWN
          _ntui_DispatchEvent{*lv,*ev}
          Function Return True
        Case #RAWKEY_RETURN
          _ntui_DispatchEvent{*lv,*ev}
          Function Return True
        Case #RAWKEY_ESC
          ntui_HideWindow{*inputSelector}
          Function Return True
      End Select
      
      Select vkey
        Case $09 ; TAB
          *ev\value = #RAWKEY_RETURN
          _ntui_DispatchEvent{*lv,*ev}
          Function Return True
      End Select
      
     End If
    End If
  End If

  Function Return False
  
End Function
!_MakeGlobalFuncPointer{_ab3_OnKeyCallback,{Null,Null,Null}}

Function.s _ab3_GetContext{*local.prefixtree,lpos.l,cpos.l}
  context.s = ""
  succ.l = pft_Reset{*local,"FUNCTION:"}
  flpos.l = -1
  
  While pft_GetNextItem{*local}
    key.s = pft_GetKey{*local}
    ;error{"Test context: "+key}
    info.s = pft_GetString{*local}
    If info
      name.s    = cropfield{info,0,$09,$09}
      ;source.s  = cropfield{info,1,$09,$09}
      line_.s   = cropfield{info,2,$09,$09}
      slpos.l   = Vallong(cropfield{line_,0,@"/",@"/"})
      scpos.l   = Vallong(cropfield{line_,1,@"/",0})
      If (slpos>flpos AND slpos<=lpos)
        context = name        
        flpos = slpos
      End If
    End If
  Wend
  
  Function Return context
  
End Function

Function.s _ab3_GetTokenInfo{docX.l, token.s}

  *local.prefixtree = Null
  *local_l.prefixtree = Null
  If docX>=0
    *xtra.AmiBlitz3_Xtra = (.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra
    If *xtra 
      *local = *xtra\LocalSDK
      *local_l = *xtra\LocalLSDK
    End If
  End If
  
  If Peek.b(&token)=@"#"
    info.s = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"CONSTANT",UnRight$(token,1)}
    If info Then Function Return info
  End If
    
  If Peek.b(&token)=@"!"
    info.s = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"MACRO",UnRight$(token,1)}
    If info Then Function Return info
  End If

  info.s = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"NEWTYPE",token}
  If info Then Function Return info
  
  info.s = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"FUNCTION",token}
  If info Then Function Return info
    
  info.s = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"TOKEN",token}
  If info Then Function Return info

  info.s = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"GLOBAL",token}
  If info Then Function Return info

  info.s = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"LOCAL",token}
  If info Then Function Return info

  info.s = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"LABEL",token}
  If info Then Function Return info

  Function Return ""
  
End Function


Function.s _ab3_GetInfoDefinedInText{info.s}
  type_.s = _ab3_GetInfoType{info}
  file_.s = _ab3_GetInfoSource{info}
  Select type_
    Case "CONSTANT"
      source.s = "Constant defined in "+dos_FilePart{file_}
    
    Case "MACRO"
      source.s = "Macro defined in "+dos_FilePart{file_}

    Case "NEWTYPE"
      source.s = "Newtype defined in "+dos_FilePart{file_}
  
    Case "FUNCTION"
      dtype.s = cropfield{info,4,$09,$09}
      If dtype   
        source.s  = "Function defined in "+dos_FilePart{file_}
      Else
        source.s  = "Statement defined in "+dos_FilePart{file_}
      End If
      
    Case "TOKEN"
      source.s = "BlitzBasic Token defined in "+file_
      
    Case "GLOBAL"
      source.s = "Global variable defined in "+dos_FilePart{file_}
      
    Case "LOCAL"
      source.s = "Local variable defined in "+dos_FilePart{file_}
      name.s   = cropfield{info,1,$09,$00}
      xpos.l = Instr(name,":",0)
      If xpos>0
        source = source + "/" + Left$(name, xpos-1) + "{}"
      End If
      
    Case "LABEL"
      source.s = "Label variable defined in "+dos_FilePart{file_}

    Default
      source.s = type_ + " defined in "+file_
  End Select
    
  Function Return source
  
End Function

Function.s _ab3_GetInfoShortHelpText{info.s}
  type_.s = _ab3_GetInfoType{info}

  Select type_
    Case "CONSTANT"
      value.s  = cropfield{info,4,$09,$09}
      help.s   = cropfield{info,5,$09,$00}
      text.s   = " = "+value
      If help><"" Then text+" ; \\22"+help+"\\22"
    
    Case "MACRO"
      help.s   = cropfield{info,4,$09,$00}
      text.s   = ""
      If help 
        If Peek.b(&help)><@"{" Then text + " ; "
        text     +help
      End If

    Case "NEWTYPE"
      help.s   = cropfield{info,4,$09,$00}
      text.s   = ""
      If help><"" Then text+" ; "+help
  
    Case "FUNCTION"
      dtype.s = cropfield{info,4,$09,$09}
      track.s = cropfield{info,5,$09,$09}
      help.s  = cropfield{info,6,$09,$00}
      If dtype><"" Then text.s = "."+dtype : Else text=""
      text + "{"+track+"}"
      If help><"" Then text+" ; "+help
      
    Case "TOKEN"
      help.s   = cropfield{info,4,$09,$00}
      text.s   = " "+ help
      
    Case "GLOBAL"
      dtype.s = cropfield{info,4,$09,$09}
      help.s   = cropfield{info,5,$09,$00}
      If dtype><"" Then text.s = "."+dtype+" " : Else text=""
      If help Then text.s + " ; "+ help
      
    Case "LOCAL"
      dtype.s = cropfield{info,4,$09,$09}
      help.s   = cropfield{info,5,$09,$00}
      If dtype><"" Then text.s = "."+dtype+" " : Else text=""
      If help Then text.s + " ; "+ help
    
    Default
      help.s   = cropfield{info,4,$09,$00}
      text.s   = "??? "+ help
  End Select
    
  Function Return text

End Function

Function.s _ab3_GetTokenTypeAhead{token.s}
End Function

Function.l _ab3_LongHelpInfo{info.s}
  source.s = _ab3_GetInfoSource{info}
  token.s = _ab3_GetInfoSymbol{info}
  type_.s = _ab3_GetInfoType{info}
  AmiBlitz3_LongHelp{type_, token, source}
  Function Return 0
End Function


_ab3_OnPostKeyCallback:
Function.l _ab3_OnPostKeyCallback{*textBox.tuiTextBox,*ev.tuiEvent,*notify.str}

  ; get vanilla key
  vkey.l = $00
  ntui_GetEventAttr{*ev,#TUIEVA_VANILLAKEY,&vkey.l}

  ; hide popups
  If *ev\value=#RAWKEY_UP OR *ev\value=#RAWKEY_DOWN OR *ev\value=#RAWKEY_RETURN OR vkey=$0A OR *ev\value=#RAWKEY_ESC
    ntui_HideWindowByID{*ntui,!win_popuphelp}
    ntui_HideWindowByID{*ntui,!win_inputselector}
    Function Return False
  End If

  ; get SDK
  *local.prefixtree = Null
  *local_l.prefixtree = Null
  docX.l = Document_FindByTextBox{*textBox}
  If docX>=0
    *xtra.AmiBlitz3_Xtra = (.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra
    If *xtra 
      *local = *xtra\LocalSDK
      *local_l = *xtra\LocalLSDK
    End If
  End If

  ; get context
  ntui_GetAttr{*textBox,#TUITBA_CURSORLINE,&lpos.l}
  ntui_GetAttr{*textBox,#TUITBA_CURSORCHAR,&cpos.l}
  *lineP.b = lpos
  ntui_GetAttr{*textBox,#TUITBA_LINE,&*lineP}
  If *lineP = Null Then Function Return False
  token.s = _ab3_CropPrevToken{*lineP,cpos,&fpos.l}
  pixpos.tuiPixel\x = 0,0
  *win.tuiWindow = ntui_GetWindow{*textBox}
  ntui_GetAttr{*win,#TUIWA_SCREENPOSX,&winx.l}
  ntui_GetAttr{*win,#TUIWA_SCREENPOSY,&winy.l}
  ntui_GetTextBoxPixelCoordinates{*textBox,lpos+1,fpos,&pixpos.tuiPixel}

  ; when input selector is open...
  *inputSelector.tuiWindow = ntui_GetWindowByID{*ntui,!win_inputselector}
  If *inputSelector
    ntui_GetAttr{*inputSelector,#TUIA_ONSCREEN,&onScreen.l}
    If onScreen
      *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*inputSelector,!obj_selector_list}
       If *lv
        fpos.l = _ab3_FindReplaceStart{*lineP,cpos}
        If fpos > 0
          repl.s = Peeks$(*lineP + fpos, cpos - fpos)
          ntui_GetAttr{*lv, #TUILVA_TOTALITEMS, &itemN.l}
          If repl><""
          itemX.l = 0
          For i.l = 0 To itemN-1
            entry.s = ntui_GetListItemText{*lv, itemX, 0}
            If instr_nocase_{entry, repl} = 0 
              ntui_RemListItem{*lv, itemX}
            Else
              itemX+1
            End If
          Next            
          If itemX = 0 
            ntui_HideWindow{*inputSelector}
          Else
            ntui_Refresh{*lv, Null}
          End If
          End If
        End If
      End If
    End If
  End If

  ; on special keys...
  ; true case the function name
  If vkey=@"{"
    info.s = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"FUNCTION",token}
    If info
      name.s  = _ab3_GetInfoSymbol{info}
      If name><token ; correct the casing
        ntui_SetTextBoxSelection    {*textBox,Null,lpos,fpos,lpos,fpos+FLen(name)}
        ntui_ReplaceTextBoxSelection{*textBox,&name,FLen(name)}
      End If
    End If
  End If

  ; open explicit help
  If *ev\value=#RAWKEY_HELP
    localcontext.s = _ab3_GetContext{*local,lpos,cpos}
    localtoken.s = localcontext + ":" + token
    info.s = _ab3_GetTokenInfo{docX, localtoken}
    If info = "" Then info = _ab3_GetTokenInfo{docX, token}
    If info = "" Then Function Return False
    
    If *ev\qualifier_&#TUIQUAL_SHIFT
      _ab3_LongHelpInfo{info}      
      Function Return True
    End If
    
    If *ev\qualifier_&#TUIQUAL_ALT
      _ab3_JumpToSDKItemInfo{info}
      Function Return True
    End If
    
    name.s = _ab3_GetInfoDecoratedSymbol{info}
    text.s = _ab3_GetInfoShortHelpText{info}
    source.s = _ab3_GetInfoDefinedInText{info}
    Popup_Help{name,text,source,pixpos\x+winx,pixpos\y+winy}
  End If

  ; open implicit help
  If vkey=@"{" OR vkey=@" " OR vkey=@"(" OR vkey=@"." OR vkey=@"["
    ; quick help
    info.s = _ab3_GetTokenInfo{docX, token}
    If info
      *win.tuiWindow = ntui_GetWindow{*textBox}
      ntui_GetAttr{*win,#TUIWA_SCREENPOSX,&winx.l}
      ntui_GetAttr{*win,#TUIWA_SCREENPOSY,&winy.l}
      ntui_GetTextBoxPixelCoordinates{*textBox,lpos+1,fpos,&pixpos.tuiPixel}
      name.s = _ab3_GetInfoDecoratedSymbol{info}
      text.s = _ab3_GetInfoShortHelpText{info}
      source.s = _ab3_GetInfoDefinedInText{info}
      Popup_Help{name,text,source,pixpos\x+winx,pixpos\y+winy}
    End If
  End If

  If vkey=@"\"
    localcontext.s = _ab3_GetContext{*local,lpos,cpos}
    localtoken.s = localcontext + ":" + token

    info.s = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"LOCAL",localtoken}
    If info="" Then info = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"GLOBAL",token}
    If info="" 
      token="*"+token
      localtoken.s = localcontext + ":" + token      
      info = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"LOCAL",localtoken}
      If info="" Then info = getSdkItemInfo{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"GLOBAL",token}
    End If
    If info><""
      name.s     = _ab3_GetInfoSymbol{info}
      newtype_.s = _ab3_GetInfoField4{info}        
      lname.s = cropfield{name,1,@":",@":"}
      If FLen(lname)=FLen(token) Then name = lname
      If name><token
        ntui_SetTextBoxSelection    {*textBox,Null,lpos,fpos,lpos,fpos+FLen(name)}
        ntui_ReplaceTextBoxSelection{*textBox,&name,FLen(name)}          
      End If
      options.s = getSdkNewTypeOptions{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,newtype_+"\"}
      If options><""
        PopUp_InputSelector{options,pixpos\x+winx,pixpos\y+winy}
        Function Return True
      End If
    End If
  End If

 Function Return False

End Function
!_MakeGlobalFuncPointer{_ab3_OnPostKeyCallback,{Null,Null,Null}}


AmiBlitz3_Attach:
Function.l AmiBlitz3_Attach{docX.l}

  If AmiBlitz3\IsPrepared=False Then _AmiBlitz3_Prepare{}
  If AmiBlitz3\IsPrepared=False Then Function Return False

  AIDE\Document[docX]\Xtra    = _AmiBlitz3_AllocXtra{}
  AIDE\Document[docX]\DocType = AmiBlitz3\DocType
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_STYLECB,*_ab3_StyleCallback}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_ONPOSTKEYCB,*_ab3_OnPostKeyCallback}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUIA_ONLOSEFOCUSCB,*_ab3_OnLoseFocusCallback}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_ONKEYCB,*_ab3_OnKeyCallback}

  Function Return True

End Function
!_MakeGlobalFuncPointer{AmiBlitz3_Attach,{0}}


AmiBlitz3_Detach:
Function.l AmiBlitz3_Detach{docX.l}

  If AIDE\Document[docX]\Xtra Then _AmiBlitz3_FreeXtra{(.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra}
  AIDE\Document[docX]\Xtra = Null
  AIDE\Document[docX]\DocType = #DOCTYPE_DEFAULT
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_STYLECB,Null}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_ONKEYCB,Null}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_ONPOSTKEYCB,Null}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUIA_ONLOSEFOCUSCB,Null}
  
  Function Return True

End Function
!_MakeGlobalFuncPointer{AmiBlitz3_Detach,{0}}


AmiBlitz3_ApplySettings:
Statement AmiBlitz3_ApplySettings{docX.l}

  !If_BadDocX_Then{ Statement Return }

  *win.tuiWindow = ntui_GetWindowByID{*ntui,!win_source_settings,docX}
  If *win
      *xtra.AmiBlitz3_Xtra = (.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra
      *xtra\MajorVersion   = ntui_GetValueByID{*win,"obj_version_major"}
      *xtra\MinorVersion   = ntui_GetValueByID{*win,"obj_version_minor"}
      *xtra\PatchVersion   = ntui_GetValueByID{*win,"obj_version_patch"}
      *xtra\NumberOfBuilds = ntui_GetValueByID{*win,"obj_version_build"}
      *xtra\StackSize      = ntui_GetValueByID{*win,"obj_stacksize"    }
      *xtra\StringBuffer   = ntui_GetValueByID{*win,"obj_stringbuffer" }

      exefile.s            = ntui_GetStringByID{*win,"obj_exefile"     }
      str_Write{&*xtra\ExeFile   ,dos_FilePart{exefile}}
      str_Write{&*xtra\ExePath   ,dos_PathPart{exefile}}
      str_Write{&*xtra\CliArgs   ,ntui_GetStringByID{*win,"obj_cliargs"  }}
      str_Write{&*xtra\Residents ,ntui_GetStringByID{*win,"obj_residents"}}

      *xtra\MakeSmallest   = ntui_GetValueByID {*win,"obj_makesmallest"  }
      *xtra\FuncOptimize   = ntui_GetValueByID {*win,"obj_funcoptimize"  }
      *xtra\CreateIcon     = ntui_GetValueByID {*win,"obj_createicon"    }
      *xtra\UseDebugger    = ntui_GetValueByID {*win,"obj_runtimedebug"  }
      *xtra\DebugInfo      = ntui_GetValueByID {*win,"obj_debuginfo"     }
      *xtra\CreateDbgFile  = ntui_GetValueByID {*win,"obj_createdbgfile" }
      *xtra\OverflowCheck  = ntui_GetValueByID {*win,"obj_overflowcheck" }
      *xtra\AssemblerCheck = ntui_GetValueByID {*win,"obj_assemblercheck"}
      *xtra\InterruptCheck = ntui_GetValueByID {*win,"obj_interruptcheck"}
      *xtra\AutoRun        = ntui_GetValueByID {*win,"obj_autorun"       }

      *maxobjlist.tuiGroup = (.tuiGroup)ntui_GetObjectByID{*win,"obj_maxobjectlist"}
      If *maxobjlist
        For n.l=0 To 255
          name.s = str_Read{&*xtra\MaxName[n]}
          If name
            id.s = "obj_maxnum_"+name
            *xtra\MaxNum[n] = ntui_GetValueByID{*maxobjlist,id}
          End If
        Next
      End If
      
      
   End If

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_ApplySettings,{0}}


AmiBlitz3_OpenSettings:
Statement AmiBlitz3_OpenSettings{docX.l}

  !If_BadDocX_Then{ Statement Return}

  *win.tuiWindow = ntui_GetWindowByID{*ntui,!win_source_settings,docX}
  If *win Then ntui_FreeObject{*win}

  If ntui_ShowWindowByID{*ntui,!win_source_settings,docX}=False

    *win.tuiWindow = ntui_GetWindow{ntui_BuildFromXMLFile{*ntui,dos_AddPart{AIDE\GuiPath,!file_win_source_settings_ab3}}}
    If *win
      ntui_SetAttr{*win,#TUIWA_INSTANCEID,docX}

      *xtra.AmiBlitz3_Xtra = (.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra
      If *xtra
        Format ""
        ntui_SetStringByID{*win,"obj_version_major",Str$(*xtra\MajorVersion)}
        ntui_SetStringByID{*win,"obj_version_minor",Str$(*xtra\MinorVersion)}
        ntui_SetStringByID{*win,"obj_version_patch",Str$(*xtra\PatchVersion)}
        ntui_SetStringByID{*win,"obj_version_build",Str$(*xtra\NumberOfBuilds)}
        ntui_SetStringByID{*win,"obj_stacksize"    ,Str$(*xtra\StackSize)}
        ntui_SetStringByID{*win,"obj_stringbuffer" ,Str$(*xtra\StringBuffer)}

        ntui_SetStringByID{*win,"obj_exefile"  ,dos_AddPart{str_Read{&*xtra\ExePath},str_Read{&*xtra\ExeFile}}}
        ntui_SetStringByID{*win,"obj_cliargs"  ,str_Read{&*xtra\CliArgs  }}
        ntui_SetStringByID{*win,"obj_residents",str_Read{&*xtra\Residents}}

        ntui_SetValueByID {*win,"obj_makesmallest",*xtra\MakeSmallest}
        ntui_SetValueByID {*win,"obj_funcoptimize",*xtra\FuncOptimize}
        ntui_SetValueByID {*win,"obj_createicon"  ,*xtra\CreateIcon}
        ntui_SetValueByID {*win,"obj_runtimedebug",*xtra\UseDebugger}
        ntui_SetValueByID {*win,"obj_debuginfo"   ,*xtra\DebugInfo}

        ntui_SetValueByID {*win,"obj_createdbgfile",*xtra\CreateDbgFile}
        ntui_SetValueByID {*win,"obj_overflowcheck",*xtra\OverflowCheck}
        ntui_SetValueByID {*win,"obj_assemblercheck"  ,*xtra\AssemblerCheck}
        ntui_SetValueByID {*win,"obj_interruptcheck",*xtra\InterruptCheck}
        ntui_SetValueByID {*win,"obj_autorun"   ,*xtra\AutoRun}

        *maxobjlist.tuiGroup = (.tuiGroup)ntui_GetObjectByID{*win,"obj_maxobjectlist"}
        If *maxobjlist
          For n.l=0 To 255
            name.s = str_Read{&*xtra\MaxName[n]}
            If name
              *group.tuiGroup = (.tuiGroup)ntui_BuildFromXMLFile{*maxobjlist,dos_AddPart{AIDE\GuiPath,!file_fragment_maxobj_ab3}}

              If *group
                ntui_SetStringByID{*group,"obj_maxname",name}

                *obj.tuiObject = ntui_GetObjectByID{*group,"obj_maxnum"}
                If *obj
                  num.l = *xtra\MaxNum[n]
                  ntui_SetValue{*obj,num}
                  id.s = "obj_maxnum_"+name
                  ntui_SetAttr{*obj,#TUIA_ID,&id}
                End If

              End If
            End If
          Next
        End If
      End If
    End If
    If ntui_ShowWindowByID{*ntui,!win_source_settings,docX}=False Then error{"\\__THIS_FUNCTION: Unable to open Settings Window!"}
  End If

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_OpenSettings,{0}}


AmiBlitz3_Init:
Statement AmiBlitz3_Init{docType.l}

  ; Doctype Definitions
  AIDE\DocType[docType]\Pattern       = "#?.(bb|bb2|ab2|ab3)"
  AIDE\DocType[docType]\Name          = "AmiBlitz3"
  AIDE\DocType[docType]\DefIcon       = dos_AddPart{AIDE\GuiPath,"icons/def_amiblitz3.info"}
  
  ; Doctype Methods
  AIDE\DocType[docType]\Deinit        = *AmiBlitz3_Deinit
  AIDE\DocType[docType]\DebugSource   = *AmiBlitz3_DebugSource
  AIDE\DocType[docType]\BuildSource   = *AmiBlitz3_BuildSource
  AIDE\DocType[docType]\ReadPrefs     = *AmiBlitz3_ReadPrefs
  AIDE\DocType[docType]\WritePrefs    = *AmiBlitz3_WritePrefs
  AIDE\DocType[docType]\Import        = *AmiBlitz3_Import
  AIDE\DocType[docType]\Export        = *AmiBlitz3_Export
  AIDE\DocType[docType]\Attach        = *AmiBlitz3_Attach
  AIDE\DocType[docType]\Detach        = *AmiBlitz3_Detach
  AIDE\DocType[docType]\ScanSource    = Null;*AmiBlitz3_ScanSource
  AIDE\DocType[docType]\ScanSourceAsync  = *AmiBlitz3_ScanSourceAsync
  AIDE\DocType[docType]\ScanSourceFinish = *AmiBlitz3_ScanSourceFinish
  AIDE\DocType[docType]\UpdateBrowser = *AmiBlitz3_UpdateBrowser
  AIDE\DocType[docType]\ScanSDK       = *AmiBlitz3_ScanSDK
  AIDE\DocType[docType]\JumpTo        = *AmiBlitz3_JumpTo
  AIDE\DocType[docType]\OpenSettings  = *AmiBlitz3_OpenSettings
  AIDE\DocType[docType]\ApplySettings = *AmiBlitz3_ApplySettings

  ; Amiblitz3 Internal Context
  AmiBlitz3\Exe        = "Work:Sourcecodes/AmiBlitz3/AmiBlitz3_Beta"
  AmiBlitz3\AIDEDir    = dos_AddPart{AIDE\DocTypesPath,"AmiBlitz3"}
  AmiBlitz3\Tokens     = Null
  AmiBlitz3\Detokens   = Null
  AmiBlitz3\LTokens    = Null
  AmiBlitz3\TempP      = Null
  AmiBlitz3\DocType    = docType
  AmiBlitz3\IsPrepared = False       ; not yet prepared
  
  AmiBlitz3\TokenHashMapFile  = dos_AddPart{AmiBlitz3\AIDEDir,"tokens.hash"}
  AmiBlitz3\TokenHashMapFileL = dos_AddPart{AmiBlitz3\AIDEDir,"tokens.l.hash"}
  AmiBlitz3\TokenTreeFile     = dos_AddPart{AmiBlitz3\AIDEDir,"tokens.pft"}
  AmiBlitz3\SdkFile           = dos_AddPart{AmiBlitz3\AIDEDir,"sdk.pft"}
  AmiBlitz3\SdkFileL          = dos_AddPart{AmiBlitz3\AIDEDir,"sdk.l.pft"}
  AmiBlitz3\BlitzLibNameFile  = dos_AddPart{AmiBlitz3\AIDEDir,"blitzlibs.txt"}

End Statement

AmiBlitz3_Init{#DOCTYPE_AMIBLITZ3}

; ===========================================================
