; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Sys:Programme/AIDE"
; ExeFile         = "AIDE"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 519
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 2002
; CursorColumn    = 18
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 1
; Max GadgetList  = 1
; Max Queue       = 1
; Max Screen      = 2
; Max Shape       = 1
; Max CopList     = 1
; Max Sprite      = 1
; Max Stencil     = 1
; Max Module      = 1
; Max Window      = 30
; Max Anim        = 1
; Max Sound       = 1
; Max Bank        = 1
; Max Buffer      = 1
; Max BitMap      = 1
; Max Slice       = 1
; Max Page        = 1
; Max Tape        = 1
; Max IntuiFont   = 12
; Max MedModule   = 1
; Max Palette     = 1
; Max MenuList    = 1
; Max BlitzFont   = 1
; Max GTList      = 30
; /XTRA

; ========================= AMIBLITZ3 ====================
#HAS_AMIBLITZ3 = 1

#AB3TF_IS        = $0001 ;/* is part of token */
#AB3TF_EOL       = $0002 ;/* end of line */
#AB3TF_NEW       = $0004 ;/* starts a possibly new token */
#AB3TF_STOP      = $0008 ;/* stops a token */
#AB3TF_QUOT      = $0010 ;/* start/end quoting */
#AB3TF_COMMENT   = $0020 ;/* comment */
#AB3TF_COPY      = $0040 ;/* copy over to destination */
#AB3TF_FIRST     = $0080 ;/* can serve as first char in token */
#AB3TF_HEX       = $0100
#AB3TF_BIN       = $0200
#AB3TF_DEC       = $0400
#AB3TF_SPACE     = $0800
#AB3TF_ILLEGAL   = $1000
#AB3TF_BRACKET   = $2000

#AB3_MIN_STACKSIZE    = 4000
#AB3_MIN_STRINGBUFFER = 1024

NEWTYPE.AmiBlitz3_Xtra ; Amiblitz3 Xtra Information

  *ExePath.str
  *ExeFile.str
  StringBuffer.l
  MakeSmallest.l
  FuncOptimize.l
  StackSize.l
  *CliArgs.str
  NumberOfBuilds.l
  MajorVersion.l
  MinorVersion.l
  PatchVersion.l
  CreateIcon.l
  UseDebugger.l
  DebugInfo.l
  CreateDbgFile.l
  OverflowCheck.l
  AssemblerCheck.l
  InterruptCheck.l
  AutoRun.l
  CursorLine.l
  CursorColumn.l
  *LabelSearch.str
  LabelRemark.w
  LabelAll.w
  LabelPosition.l
  *Residents.str
  *MaxName.str[256]
  MaxNum.w[256]
  *LocalSDK.prefixtree
  *LocalLSDK.prefixtree

End NEWTYPE

Statement _AmiBlitz3_InitXtra{*xtra.AmiBlitz3_Xtra} ; Initializer for _Xtra Newtype

  *xtra\ExePath        = Null
  *xtra\ExeFile        = Null
  *xtra\StringBuffer   = #AB3_MIN_STRINGBUFFER
  *xtra\MakeSmallest   = False
  *xtra\FuncOptimize   = False
  *xtra\StackSize      = #AB3_MIN_STACKSIZE
  *xtra\CliArgs        = Null
  *xtra\NumberOfBuilds = 0
  *xtra\MajorVersion   = 0
  *xtra\MinorVersion   = 0
  *xtra\PatchVersion   = 0
  *xtra\CreateIcon     = False
  *xtra\UseDebugger    = False
  *xtra\DebugInfo      = False
  *xtra\CreateDbgFile  = False
  *xtra\OverflowCheck  = False
  *xtra\AssemblerCheck = True
  *xtra\InterruptCheck = True
  *xtra\AutoRun        = True
  *xtra\CursorLine     = 0
  *xtra\CursorColumn   = 0
  *xtra\LabelSearch    = Null
  *xtra\LabelRemark    = False
  *xtra\LabelAll       = False
  *xtra\LabelPosition  = 0
  *xtra\Residents      = Null
  For n.l=0 To 255
    *xtra\MaxName[n] = Null
    *xtra\MaxNum[n]  = 0
  Next
  *xtra\LocalSDK       = Null
  *xtra\LocalLSDK      = Null

End Statement

Function.AmiBlitz3_Xtra _AmiBlitz3_AllocXtra{}

  *xtra.AmiBlitz3_Xtra = AllocVec_(SizeOf.AmiBlitz3_Xtra,#MEMF_ANY)
  If *xtra
    _AmiBlitz3_InitXtra{*xtra.AmiBlitz3_Xtra}
  End If

  Function Return *xtra

End Function

Statement _AmiBlitz3_FreeXtra{*xtra.AmiBlitz3_Xtra}

  If *xtra
    str_Free{&*xtra\ExePath}
    str_Free{&*xtra\ExeFile}
    str_Free{&*xtra\CliArgs}
    str_Free{&*xtra\LabelSearch}
    str_Free{&*xtra\Residents}
    For n.l=0 To 255
      str_Free{&*xtra\MaxName[n]}
    Next
    If *xtra\LocalSDK  Then pft_Free{*xtra\LocalSDK }  : *xtra\LocalSDK  = Null
    If *xtra\LocalLSDK Then pft_Free{*xtra\LocalLSDK}  : *xtra\LocalLSDK = Null
    FreeVec_ *xtra
  End If

End Statement

NEWTYPE.DocType_AmiBlitz3

  CharFlags.w[256]    ; character flags
  *Tokens.hashmap     ; hashmap with tokens => lib/id
  *LTokens.hashmap    ; hashmap with lowercased tokens => tokens
  *Detokens.l         ; reverse map to hashmap entries
  *TokensT.prefixtree
  *TempP.b
  *LineP.b
  AIDEDir.s           ; directory for Amiblitz3 related files
  Exe.s               ; executalbe of Amiblitz3
  Blitz3Path.s        ; 
  Blitz3Assign.s
  IncludeDir.s
  *SDK.prefixtree
  *LSDK.prefixtree
  BlitzLibName.s[256]
  DebugSourceArgs.s   ; command to launch AmiBlitz3s
  BuildSourceArgs.s
  DebugProjectArgs.s  ; command to launch AmiBlitz3s
  BuildProjectArgs.s  ; command to launch AmiBlitz3s
  DocType.l           ; docType ID
  IsPrepared.l        ; true if prepare was successfully called

End NEWTYPE
SHARED AmiBlitz3.DocType_AmiBlitz3

;AmiBlitz 3.5 (23.03.2013) Build 2.29
;
;Syntax: AmiBlitz3 [options]
;
;Options:
;  -(s)ource <File>    : Input source code filename (bb2, ab2 OR ab3)
;  -(e)xe <File>       : output executable filename
;  -(d)ebug            : compile with debug info
;  -(r)elease          : create release executable (size optimized)
;  -run                : run compiled program
;  -dump <info> <File> : dump compiler internals To File
;                        (info=all|token|label|var|func|const|Macro|Type|lib)
;  -dform <n>          : Format of compiler internals dump (0=bin, 1=ASCII; default=1)
;  -PED                : Start AmiBlitz3 IDE (PED)
;  -save <File>        : re-save source code (convert Format, If needed)
;  -(v)erbose <n>      : set verbose level (0, 1 OR 2; default=1)
;  -(h)elp             : Show this help

AmiBlitz3_ReadPrefs:
Statement AmiBlitz3_ReadPrefs{*iconP.b}

  icon.s = Peek.s(*iconP)
  AmiBlitz3\Exe                = dos_GetToolString{"AmiBlitz3_Exe"               ,"Sourcecodes:AmiBlitz3/AmiBlitz3_Beta" ,icon}
  AmiBlitz3\DebugSourceArgs    = dos_GetToolString{"AmiBlitz3_DebugSourceArgs"   ,"-s \\22%f\\22 -v 2 -d -run"     ,icon}
  AmiBlitz3\BuildSourceArgs    = dos_GetToolString{"AmiBlitz3_BuildSourceArgs"   ,"-s \\22%f\\22 -v 2 -e \\22%o\\22"       ,icon}
  AmiBlitz3\DebugProjectArgs   = dos_GetToolString{"AmiBlitz3_DebugProjectArgs"  ,"-s \\22%f\\22 -v 2 -d -run"     ,icon}
  AmiBlitz3\BuildProjectArgs   = dos_GetToolString{"AmiBlitz3_BuildProjectArgs"  ,"-s \\22%f\\22 -v 2 -r -e \\22%o\\22"    ,icon}

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_ReadPrefs,{Null}}


AmiBlitz3_WritePrefs:
Statement AmiBlitz3_WritePrefs{*iconP.b}

  icon.s = Peek.s(*iconP)
  dos_SetToolString{"AmiBlitz3_Exe"                ,AmiBlitz3\Exe ,icon}
  dos_SetToolString{"AmiBlitz3_DebugSourceArgs"    ,AmiBlitz3\DebugSourceArgs,icon}
  dos_SetToolString{"AmiBlitz3_BuildSourceArgs"    ,AmiBlitz3\BuildSourceArgs,icon}
  dos_SetToolString{"AmiBlitz3_DebugProjectArgs"   ,AmiBlitz3\DebugProjectArgs,icon}
  dos_SetToolString{"AmiBlitz3_BuildProjectArgs"   ,AmiBlitz3\BuildProjectArgs,icon}

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_WritePrefs,{Null}}


Statement _AmiBlitz3_CompileAndRun{args.s}

  *con.tuiTextBox = (.tuiTextBox)ntui_GetObjectByID{*ntui,!obj_main_console}
  If *con
    pipefile.s = "Pipe:"+Hex$(FindTask_(0))
    txt.s = "\\1B[33m\\1B[1mAmiBlitz3 >>>\\n"
    ntui_SetAttr{*con,#TUITBA_TEXT,&txt}
    fh.l = Open_(&pipefile,#MODE_NEWFILE)
    If fh=0
      msg.s = "\\1B[33m\\1B[1mUnable to open "+pipefile+"!\\n"
      ntui_SetAttr{*con, #TUITBA_APPENDTEXT,&msg}
    Else
      ntui_SetTextBoxFileListener{*con,&pipefile}
    End If

    msg.s = AmiBlitz3\Exe+" "+args+"\\n"
    ntui_SetAttr{*con, #TUITBA_APPENDTEXT,&msg}
    ret.l = dos_RunCli{AmiBlitz3\Exe,-1,8192,False,args,-1,fh}

    If ret><0
      msg.s = "\\1B[33m\\1B[1mFailed with #"+Str$(ret)+"\\n"
      ntui_SetAttr{*con, #TUITBA_APPENDTEXT,&msg}
    End If
  End If

End Statement

AmiBlitz3_LongHelp:
Function.l AmiBlitz3_LongHelp{docX.l,*typeP.b,*nameP.b,*moreP.b}

  If *nameP Then name.s  = Peek.s(*nameP)
  If *typeP Then type_.s = Peek.s(*typeP)
  If *moreP Then more.s  = Peek.s(*moreP)
  
  *localSDK.prefixtree = Null
  *localLSDK.prefixtree= Null

  If docX>=0
    *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra
    If *xtra
      *localSDK  = *xtra\LocalSDK
      *localLSDK = *xtra\LocalLSDK
    End If
  End If
  
  symbol.s = name
  libname.s = more

  cmd.s = dos_AddPart{AmiBlitz3\Blitz3Path,"Tools/AB3HelpViewer"}
  If symbol ="" Then symbol = "main"
  args.s = " -q -t " + symbol
  If libname<>"" Then args + " -l " + dos_RemExt{libname}
  helpdir.s = dos_AddPart{AmiBlitz3\Blitz3Path,"Docs"}
  If helpdir<>"" Then args + " -d " + helpdir

  ntui_GetAttr{*ntui,#TUIEA_PUBSCREENNAME,&*psn.b}
  If *psn Then pubscreen.s = Peek.s(*psn) : Else pubscreen=""
  If pubscreen<>""
    args + " -s " + pubscreen
  EndIf
  error{"Will run: "+cmd+" "+args}
  dos_RunCli{cmd,0,8192,False,args}
  
End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_LongHelp,{0,Null,Null,Null}}


AmiBlitz3_DebugSource:
Statement AmiBlitz3_DebugSource{docX.l,*filenameP.b}

  filename.s = Peek.s(*filenameP)
  args.s   = AmiBlitz3\DebugSourceArgs
  args     = Replace$(args,"%f",filename)
  _AmiBlitz3_CompileAndRun{args}

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_DebugSource,{0,Null}}


AmiBlitz3_BuildSource:
Statement AmiBlitz3_BuildSource{docX.l,*filenameP.b}

  filename.s = Peek.s(*filenameP)
  args.s   = AmiBlitz3\BuildSourceArgs

  *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra

  args     = Replace$(args,"%f",filename)

  If *xtra
    exefile.s = dos_AddPart{str_Read{&*xtra\ExePath},str_Read{&*xtra\ExeFile}}
    args     = Replace$(args,"%o",exefile)
  End If
  _AmiBlitz3_CompileAndRun{args}

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_BuildSource,{0,Null}}


Function.l FAST _ab3_ParseComment{*tline.tline,cpos.l}

  _tb_SetStyleCommand{*tline,cpos-1 ,#TUITBSC_ITALIC,1,0}
  _tb_SetStyleCommand{*tline,cpos-1 ,#TUITBSC_FGPEN,#TUITBPEN_COMMENT,0}
  _tb_SetStyleCommand{*tline,cpos-1 ,#TUITBSC_BGPEN,#TUITBPEN_BG2    ,0}
;  _tb_SetStyleCommand{*tline,cpos-1 ,#TUITBSC_ITALIC,1,0}
;  _tb_SetStyleCommand{*tline,cpos-1 ,#TUITBSC_FGPEN,#TUITBPEN_COMMENT,0}
  _tb_SetStyleCommand{*tline,*tline\clength-1 ,#TUITBSC_BGPEN,#TUITBPEN_BG    ,0}

  Function Return *tline\clength; just skip to end of line

End Function


Function.l _ab3_ParseEscape{*tline.tline,cpos.l}
  opos.l = cpos-2
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_CONSTANT,0}

  esc.s = ""

  While cpos<*tline\clength
    c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
    esc + Chr$(c)
    If FLen(esc)>6
      Select UCase$(esc)
        Case "__THIS_FUNCTION": Function Return cpos
        Case "__THIS_INCLUDE" : Function Return cpos
        Case "__THIS_POINTER" : Function Return cpos
        Case "__CODELINE"     : Function Return cpos
        Case "__VER_MINOR"    : Function Return cpos
        Case "__VER_MAJOR"    : Function Return cpos
        Case "__VER_PATCH"    : Function Return cpos
        Case "__VER_BUILD"    : Function Return cpos
        Case "__DATE_GER__"   : Function Return cpos
        Case "__DATE__"       : Function Return cpos
      End Select
    End If

    If FLen(esc)=2
      If (AmiBlitz3\CharFlags[Peek.b(&esc+0)&$FF]&#AB3TF_HEX) AND (AmiBlitz3\CharFlags[Peek.b(&esc+1)&$FF]&#AB3TF_HEX) Then Function Return cpos
    End If

    If FLen(esc)=1
      If (c=@"n" OR c=@"N") Then Function Return cpos
    End If

    If FLen(esc)=3
      If (Peek.b(&esc+0)=@"r" OR Peek.b(&esc+0)=@"R")
        If (AmiBlitz3\CharFlags[Peek.b(&esc+1)&$FF]&#AB3TF_DEC) AND (AmiBlitz3\CharFlags[Peek.b(&esc+2)&$FF]&#AB3TF_DEC) Then Function Return cpos
      End If
    End If

    If ((AmiBlitz3\CharFlags[c]&#AB3TF_QUOT) OR (AmiBlitz3\CharFlags[c]&#AB3TF_IS)=0)
      _tb_SetStyleCommand{*tline,opos,#TUITBSC_WARN,1,#TUIPEN_RED}
      _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_WARN,0}
      Function Return cpos-1
    End If

  Wend
  Function Return cpos

End Function


Function.l FAST _ab3_ParseString{*tline.tline,cpos.l,fgPen.l}
  opos.l = cpos-1
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,fgPen,0}

  While cpos<*tline\clength
    c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
    If c=@"\"
      c.w = Peek.b(*tline\text+cpos)&$FF
      If c=@"\"
        cpos+1
        cpos = _ab3_ParseEscape{*tline,cpos}
        _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,fgPen,0}
      End If
    Else
      If AmiBlitz3\CharFlags[c]&#AB3TF_QUOT
        _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
        Function Return cpos
      End If
    End If
  Wend
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_WARN,1,#TUIPEN_RED}
  Function Return cpos

End Function


Function.l FAST _ab3_SkipWhiteSpaces{*tline.tline,cpos.l}

  While cpos<*tline\clength AND AmiBlitz3\CharFlags[Peek.b(*tline\text + cpos)&$FF]&#AB3TF_SPACE : cpos+1 : Wend
  Function Return cpos

End Function


Function.l FAST _ab3_ToLower{c.l}
  If c>=@"A" AND c<=@"Z" Then Function Return c-@"A"+@"a"
  Function Return c
End Function


Function.l _ab3_ParseToken{*tline.tline,cpos.l,*hm.hashmap,*cm.hashmap,first.l,*tempP.b}

  hash.l  = 0
  lhash.l = 0
  phash.l = 0
  cpos-1
  opos.l = cpos
  ln.l = 0
  Repeat
    If cpos<*tline\clength
      c.w = Peek.b(*tline\text + cpos) & $FF
      cf.l = AmiBlitz3\CharFlags[c&$FF]
      If (cf&#AB3TF_IS) ; it is a valid token char
        If (cf&#AB3TF_STOP)
          phash = hash
        Else
          phash = 0
        End If
        hash = (hash+c)*196314165
        cl.w = _ab3_ToLower{c}
        lhash = (lhash+cl)*196314165
        Poke.b *tempP+ln,cl:ln+1
      End If
    Else
      cf=0
      c=0
    End If
    cpos+1

  Until (cf&#AB3TF_IS)=0

  cpos-1

  tptr.l = hashmap_GetItemByHash{*hm,*tline\text+opos,cpos-opos,hash}
  If tptr=0 AND cpos>opos AND (phash><0)
    tptr = hashmap_GetItemByHash{*hm,*tline\text+opos,cpos-opos-1,phash}
    If tptr Then cpos-1 : c=Peek.b(*tline\text + cpos) & $FF
  End If

  If tptr ; its a token!
    _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_TOKEN,0}
    _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
    If c=$20 Then cpos+1
    _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
    _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}

    If c=@"$"
      _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TYPE,0}
      _tb_SetStyleCommand{*tline,cpos+1,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      cpos+1
    End If
    ;*tline\flags|#TUITBLF_HOT - #TUITBLF_HOT
  Else
    tptr.l = hashmap_GetItemByHash{*cm,*tempP,ln,lhash}
    If tptr ; its a token, just casing doesnt match
      _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_TOKEN,0}
      _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
      Poke.l *tempP+512-4,opos
      If ln>0
        CopyMem_ *tline\text+opos,*tempP+512,ln
        CopyMem_ tptr, *tline\text+opos,ln
      End If
      Poke.b *tempP+512+ln,0
      *tline\flags|#TUITBLF_HOT
      If c=$20 Then cpos+1
      _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
      _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
    Else
      If *tline\flags&#TUITBLF_HOT
        rpos.l=Peek.l(*tempP+512-4)
        If rpos=opos
          lnr.l = 0
          While Peek.b(*tempP+512+lnr) AND lnr<ln-1
            c.w = Peek.b(*tline\text + opos+lnr) & $FF
            r.w = Peek.b(*tempP+512+lnr) & $FF
            cl.w = _ab3_ToLower{c}
            rl.w = _ab3_ToLower{r}
            If cl=rl
              Poke.b *tline\text+opos+lnr,r
            End If
            lnr+1
          Wend
          Poke.b *tempP+512,0
          *tline\flags|#TUITBLF_HOT - #TUITBLF_HOT
        End If
      End If
      cpos = _ab3_SkipWhiteSpaces{*tline,cpos}
      c.w = Peek.b(*tline\text + cpos)&$FF
      Select c
        Case @"{"
          _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_FUNCTION,0}
          _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
          If c=$20 Then cpos+1

          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}

        Default
          If first
            ;_tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_LABEL,0}
            ;_tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          Else
          ;_tb_SetStyleCommand{*tline,opos ,#TUITBSC_WARN,1,0}
          ;_tb_SetStyleCommand{*tline,cpos ,#TUITBSC_WARN,0,0}
          End If
      End Select
    End If
  End If

  Function Return cpos

End Function


Function.l FAST _ab3_SkipToken{*tline.tline,cpos.l}

  cf.l = 0

  While (cf&#AB3TF_STOP)=0 AND cpos<*tline\clength
    cpos+1 : If cpos>=*tline\clength Then Function Return cpos
    cf.l = AmiBlitz3\CharFlags[Peek.b(*tline\text + cpos)&$FF]
  Wend
  Function Return cpos

End Function


Function.l FAST _ab3_SkipBinary{*tline.tline,cpos.l}

  cf.l = 0

  Repeat
    cpos+1 : If cpos>=*tline\clength Then Function Return cpos
    cf.l = AmiBlitz3\CharFlags[Peek.b(*tline\text + cpos)&$FF]
    If (cf&#AB3TF_BIN)=0 Then Function Return cpos-1
  Until cpos>=*tline\clength

  Function Return cpos

End Function

Function.l FAST _ab3_SkipHex{*tline.tline,cpos.l}

  Repeat
    If cpos<*tline\clength
      cf.l = AmiBlitz3\CharFlags[Peek.b(*tline\text + cpos)&$FF]
    Else
      cf = 0
    End If
    cpos+1
  Until (cf&#AB3TF_HEX)=0 OR cpos>=*tline\clength

  Function Return cpos-1

End Function


Function.l FAST _ab3_ParseNumber{*tline.tline,cpos.l}

  opos.l = cpos-1
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}

  Repeat
    If cpos<*tline\clength
      cf.l = AmiBlitz3\CharFlags[Peek.b(*tline\text + cpos)&$FF]
    Else
      cf = 0
    End If
    cpos+1
  Until (cf&#AB3TF_DEC)=0 OR cpos>=*tline\clength

  If (Peek.b(*tline\text + cpos-1)=@".") ; has a decimal point
    Repeat
      If cpos<*tline\clength
        cf.l = AmiBlitz3\CharFlags[Peek.b(*tline\text + cpos)&$FF]
      Else
        cf = 0
      End If
      cpos+1
    Until (cf&#AB3TF_DEC)=0 OR cpos>=*tline\clength
  End If

  cpos-1
  _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
  Function Return cpos

End Function


_ab3_StyleCallback:
Function.l _ab3_StyleCallback{*textBox.tuiTextBox,lpos.l,*tline.tline}

  If *tline\text
    *tline\sclength = 0
    tokenlength.l   = 0
    accept.w        = True
    bptr.l          = *tline\text ; base pointer
    clength.l       = *tline\clength ; end pointer
    hash.l          = 0
    cpos.l          = 0
    first.w         = True
    *hm.hashmap     = AmiBlitz3\Tokens
    *cm.hashmap     = AmiBlitz3\LTokens
    *tempP.b        = AmiBlitz3\TempP

    While cpos<clength
      c.b = Peek.b(bptr+cpos) : cpos+1
      cf.l = AmiBlitz3\CharFlags[c&$FF]

      If (cf&#AB3TF_COMMENT) Then cpos = _ab3_ParseComment{*tline,cpos}   : cf = 0 : c=0 : first=False
      If (cf&#AB3TF_QUOT   ) Then cpos = _ab3_ParseString{*tline,cpos,#TUITBPEN_STRING}    : cf = 0 : c=0 : first=False
      If (cf&#AB3TF_FIRST  ) Then cpos = _ab3_ParseToken{*tline,cpos,*hm,*cm,first,*tempP} : cf = 0 : c=0 : first=False
      If (cf&#AB3TF_DEC    ) Then cpos = _ab3_ParseNumber{*tline,cpos}    : cf = 0 : c=0 : first=False

      Select c
        Case @":" : first=True
        Case @"#"
          Select Peek.b(bptr+cpos)
            Case $22
              _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
              cpos = _ab3_ParseString{*tline,cpos+1,#TUITBPEN_NUMBER}
            Default
              _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
              cpos = _ab3_SkipToken{*tline,cpos}
             _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          End Select
          first=False

        Case @"!"
          _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_MACRO,0}
          _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_BOLD,1,0}
                                                                                                                                                                                                                                                WANTTAB
          cpos = _ab3_SkipToken{*tline,cpos}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          first=False

        Case @"."
          If first
            ;_tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_LABEL,0}
            cpos = _ab3_SkipToken{*tline,cpos}
            ;_tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          Else
            _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TYPE,0}
            ;_tb_SetStyleCommand{*tline,cpos,#TUITBSC_ITALIC,1,0}
            cpos = _ab3_SkipToken{*tline,cpos}
            ;_tb_SetStyleCommand{*tline,cpos,#TUITBSC_ITALIC,0,0}
            _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          End If
          first=False

       Case @"\"
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_MEMBER,0}
          cpos = _ab3_SkipToken{*tline,cpos}
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          first=False

        Case @"%"
          _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
          cpos = _ab3_SkipBinary{*tline,cpos}
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          first=False

        Case @"$"
          _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
          cpos = _ab3_SkipHex{*tline,cpos}
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          first=False

        Case @"@"
          Select Peek.b(bptr+cpos)
            Case @"@" ; its @@
              _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_DIRECTIVE,0}
              cpos+1
              _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
              If cpos<clength ; remaining chars
                _tb_SetStyleCommand{*tline,cpos,#TUITBSC_WARN,1,#TUIPEN_RED}
                cpos=clength
              End If
            Case $22 ; its @"ILBM"
              _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
              cpos = _ab3_ParseString{*tline,cpos+1,#TUITBPEN_NUMBER}
            Case @"#" ; its @#constant
              _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
              cpos = _ab3_SkipToken{*tline,cpos}
             _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
            Default
              ;_tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_WARN,1,#TUIPEN_RED}
              cpos = _ab3_SkipToken{*tline,cpos}
              ;_tb_SetStyleCommand{*tline,cpos,#TUITBSC_WARN,0}

          End Select
          first=False
          
        Default
          ; hm, could only be space or illegal
          If ((cf&#AB3TF_ILLEGAL)><0) AND (cpos<*tline\clength-1)
            _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_WARN,1,#TUIPEN_RED}
            cpos=*tline\clength
          End If
      End Select
    Wend

    *tline\flags|#TUITBLF_STYLED
  End If
  Function Return #TUISCB_DONE

End Function
!_MakeGlobalFuncPointer{_ab3_StyleCallback,{Null,0,Null}}


Function.s cropfield{*stringP.b,pos.l,seperator.b,terminator.b}

  If pos>0
    Repeat
      c.b = Peek.b(*stringP) : *stringP+1
      If c=seperator Then pos-1
      If c=0 pos=-1
    Until pos<=0
  EndIf

  If pos=0
    *cropP.b = *stringP
    Repeat
      c.b = Peek.b(*stringP) : *stringP+1
    Until c=terminator OR c=0
    Function Return Peeks$(*cropP,*stringP-*cropP-1)
  End If
  
  Function Return ""

End Function


Statement addSdkItem{*sdk.prefixtree,type_.s,name.s,info.s}

  pft_AddItem{*sdk,type_+":"+name,name+"\\09"+info}

End Statement


Statement genSdkMap{*sdk.prefixtree,*lsdk.prefixtree}

  If *sdk=Null Then Statement Return

  pft_Reset{*sdk}
  While pft_GetNextItem{*sdk}
    key.s = pft_GetKey{*sdk}
    type_.s = cropfield{key,0,@":",@":"}
    name.s  = cropfield{key,1,@":",@":"}
    lname.s = LCase$(name)
    If lname><name  ; redirect
      If pft_FindItem{*sdk,type_+":"+lname}=""
        pft_AddItem{*lsdk,type_+":"+lname,name}
      End If
    End If
  Wend

End Statement


Function.s getSdkItem{*local.prefixtree,*local_l.prefixtree,*global.prefixtree,*global_l.prefixtree,type_.s,name.s}

  If *local
    info.s = pft_FindItem{*local,type_+":"+name}
    If info="" AND *local_l><Null
      rname.s = pft_FindItem{*local_l ,type_+":"+LCase$(name)}
      info.s = pft_FindItem{*local,type_+":"+rname}
    End If
    If info Then Function Return info
  End If  
  
  If *global 
    info.s = pft_FindItem{*global,type_+":"+name}
    If info="" AND *global_l><Null
      rname = pft_FindItem{*global_l ,type_+":"+LCase$(name)}
      info.s = pft_FindItem{*global,type_+":"+rname}
    End If
    If info Then Function Return info
  End If

  Function Return ""

End Function


Function.s getSdkLookAhead{*local.prefixtree,*local_l.prefixtree,*sdk.prefixtree,*sdk_l.prefixtree,type_.s,prefix.s}

  lhl.s = ""
  If *local
  succ.l = pft_Reset{*local,type_+":"+prefix}
  ;error{"local: pft_Reset("+type_+":"+prefix+") = "+Str$(succ)}
  While pft_GetNextItem{*local}
    ;key.s = pft_GetKey{*sdk}
    info.s = pft_GetString{*local}
    name.s  = cropfield{info,0,$09,$09}
    lhl + name+"\\09"
  Wend
  If lhl><"" Then Function Return lhl
  End If

  If *sdk
  succ.l = pft_Reset{*sdk,type_+":"+prefix}
  ;error{"global: pft_Reset("+type_+":"+prefix+") = "+Str$(succ)}
  While pft_GetNextItem{*sdk}
    ;key.s = pft_GetKey{*sdk}
    info.s = pft_GetString{*sdk}
    name.s  = cropfield{info,0,$09,$09}
    lhl + name+"\\09"
  Wend
  End If
  Function Return lhl
  
End Function


Function.l _AmiBlitz3_ReadSDKFile{filename.s,*sdk.prefixtree,seperator.b}

  fid.l = file_Open{filename,#file_read}
  If fid<0 Function Return False
  source.s    = ""
  newtype_.s  = ""
  function_.s = ""

  ; format: ID:name             => name file line params       help
  ;         SOURCE:file         => file file    0              help
  ;         NEWTYPE:name        => name file line              help
  ;         FIELD:newtype\name  => name file line type         help
  ;         FUNCTION:name       => name file line return track help
  ;         FUNCTION:name       => name file line    ""  track help ; statement
  ;         MACRO:name          => name file line              help
  ;         CONSTANT:name       => name file line value        help
  ;         LABEL:name          => name file line              help
  ;         GLOBAL:name         => name file line type         help
  ;         LOCAL:function\name => name file line type         help
  ;         STRING:value        => valuefile line
  While file_EOF{fid}=False
    a.s = file_ReadLineF{fid}
    a= Replace$(a,"\\n","")
    ;a= ntui_EscapeListViewString{Null,a}
    id.s = cropfield{&a,0,seperator,seperator}
    Select id
      Case "SOURCE"   :
        sourcefile.s = cropfield{&a,1,seperator,seperator}
        ;sourcefile.s = Replace$(sourcefile,AmiBlitz3\IncludeDir,"%i")
        addSdkItem{*sdk,id,sourcefile,sourcefile+"\\09"+Str$(0)}

      Case "TOKEN"  :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        tokenid.s   = cropfield{&codeline,1,@"/",$00}
        libid.s     = cropfield{&codeline,0,@"/",@"/"}
        token.s     = cropfield{&a,2,seperator,seperator}
        help.s      = cropfield{&a,3,seperator,$00}
        libidl.l    = Vallong(libid)
        If AmiBlitz3\BlitzLibName[libidl&$FF]><""
          sourcefile.s = AmiBlitz3\BlitzLibName[libidl&$FF]+" (BlitzLib #"+libid+"/"+tokenid+")"
        Else
          sourcefile.s = "BlitzLib #"+libid+"/"+tokenid
        End If
        addSdkItem{*sdk,id,token,sourcefile+"\\09"+"0"+"\\09"+help}

      Case "NEWTYPE"  :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        newtype_.s  = cropfield{&a,2,seperator,seperator}
        help.s      = cropfield{&a,3,seperator,$00}
        addSdkItem{*sdk,id,newtype_,sourcefile+"\\09"+codeline+"\\09"+help}
        
      Case "FIELD"    :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        field.s     = cropfield{&a,2,seperator,seperator}
        type_.s     = cropfield{&a,3,seperator,seperator}
        help.s      = cropfield{&a,4,seperator,$00}
        addSdkItem{*sdk,id,newtype_+"\"+field,sourcefile+"\\09"+codeline+"\\09"+type_+"\\09"+help}

      Case "FUNCTION" :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        function_.s = cropfield{&a,2,seperator,seperator}
        return_.s   = cropfield{&a,3,seperator,seperator}
        track.s     = cropfield{&a,4,seperator,seperator}
        help.s      = cropfield{&a,5,seperator,$00}
        addSdkItem{*sdk,id,function_,sourcefile+"\\09"+codeline+"\\09"+return_+"\\09"+track+"\\09"+help}
        
      Case "STATEMENT":
        codeline.s  = cropfield{&a,1,seperator,seperator}
        function_.s = cropfield{&a,2,seperator,seperator}
        track.s     = cropfield{&a,3,seperator,seperator}
        return_.s   = ""
        help.s      = cropfield{&a,4,seperator,$00}
        addSdkItem{*sdk,"FUNCTION",function_,sourcefile+"\\09"+codeline+"\\09"+return_+"\\09"+track+"\\09"+help}
        
      Case "MACRO"    :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        macro_.s    = cropfield{&a,2,seperator,seperator}
        help.s      = cropfield{&a,3,seperator,$00}
        addSdkItem{*sdk,id,macro_,sourcefile+"\\09"+codeline+"\\09"+help}
        
      Case "CONSTANT" :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        constant.s  = cropfield{&a,2,seperator,seperator} 
        value.s     = cropfield{&a,3,seperator,seperator}
        help.s      = cropfield{&a,4,seperator,$00}
        addSdkItem{*sdk,id,constant,sourcefile+"\\09"+codeline+"\\09"+value+"\\09"+help}

      Case "LABEL"    :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        label.s     = cropfield{&a,2,seperator,seperator}
        help.s      = cropfield{&a,3,seperator,$00}
        addSdkItem{*sdk,id,label,sourcefile+"\\09"+codeline+"\\09"+help}
        
      Case "GLOBAL"   :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        global.s    = cropfield{&a,2,seperator,seperator}
        type_.s     = cropfield{&a,3,seperator,seperator}
        help.s      = cropfield{&a,4,seperator,$00}
        addSdkItem{*sdk,id,global,sourcefile+"\\09"+codeline+"\\09"+type_+"\\09"+help}

      Case "LOCAL"   :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        local.s     = cropfield{&a,2,seperator,seperator}
        type_.s     = cropfield{&a,3,seperator,seperator}
        help.s      = cropfield{&a,4,seperator,$00}
        addSdkItem{*sdk,id,function_+":"+local,sourcefile+"\\09"+codeline+"\\09"+type_+"\\09"+help}

      Case "PARAM"   : id = "LOCAL" ; = local defined in track of function
        codeline.s  = cropfield{&a,1,seperator,seperator}
        local.s     = cropfield{&a,2,seperator,seperator}
        type_.s     = cropfield{&a,3,seperator,seperator}
        help.s      = cropfield{&a,4,seperator,$00}
        addSdkItem{*sdk,id,function_+":"+local,sourcefile+"\\09"+codeline+"\\09"+type_+"\\09"+help}

      Case "STRING"   :
        codeline.s  = cropfield{&a,1,seperator,seperator}
        string.s    = cropfield{&a,2,seperator,seperator}
        help.s      = cropfield{&a,3,seperator,$00}
        addSdkItem{*sdk,id,string,sourcefile+"\\09"+codeline+"\\09"+string+"\\09"+help}
        
      Default : ; unkown, skip
    End Select
  Wend
  file_Close{fid}
  Function Return True
  
End Function


Function.l _AmiBlitz3_ReadToken2LibFile{filename.s,*hm.hashmap}

  fid.l = file_Open{filename,#file_read}
  If fid<0 Function Return False
  
  While file_EOF{fid}=False
    a.s = file_ReadLineF{fid}
    epos.l = Instr(a," ",0)
    tpos.l = Instr(a,";",epos+1)
    xpos.l = Instr(a," ",tpos+1)
    If xpos<=0 Then xpos = FLen(a)
    If tpos>0 Then While (Peek.b(&a+xpos-1)&$FF<=32) : xpos-1 : Wend
    If tpos>epos AND xpos>tpos
      libname.s = Left$(a,epos-1)
      token.s   = Mid$(a,tpos+1,xpos-tpos) 
      info.s    = hashmap_GetItem{*hm,token}
      libid.l = (Peek.w(&info) LSR 7) & $FF
      tokid.l = (Peek.w(&info) & $7F)
      If info><""      
        AmiBlitz3\BlitzLibName[libid] = libname
      Else
        error{"Amiblitz3: Token NOT found in hashmap for reverse mapping: "+libname+"/"+token+"::"+Str$(libid)+"/"+Str$(tokid)+"!"}
      End If
    End If
  Wend
  file_Close{fid}
  AmiBlitz3\BlitzLibName[0] = "Intern-0"
  AmiBlitz3\BlitzLibName[1] = "Intern-1"
  
  Function Return True

End Function


Function.l _AmiBlitz3_ReadTokenFile{filename.s,*hm.hashmap,*cm.hashmap,*pft.prefixtree}

  fid.l = file_Open{filename,#file_read}
  If fid<0 Function Return False
  
  While file_EOF{fid}=False
    a.s = file_ReadLineF{fid}
    t.s = lindex{a,0}
    If t="TOKEN"
      id.s   = lindex{a,1}
      name.s = lindex{a,2}
      help.s = Right$(a , FLen(a) - Instr(a,name)-FLen(name)-1)
      pos.l = Instr(id,"/")
      libID.l   = Vallong(Left$(id,pos-1))
      tokenID.l = Vallong(Right$(id,FLen(id)-pos))
      tokenW.w = (libID LSL 7) | tokenID | $8000
      tokenS.s = Peeks$(&tokenW,2)
      lname.s = LCase$(name)
      If hashmap_GetItem{*hm,name}="" AND hashmap_GetItem{*hm,lname}="" AND hashmap_GetItem{*cm,lname}=""
        hashmap_AddItem{*hm,name,tokenS}
        If *pft><Null Then pftlib_SetInt32{*pft,&name,tokenW & $FFFF}
        If *cm><Null AND name><lname Then hashmap_AddItem{*cm,lname,name}
      Else
        ; error{"Token Clash: "+name}
      End If
    End If
  Wend
  file_Close{fid}
  Function Return True
  
End Function


Function.l _AmiBlitz3_Prepare{refresh.l}

  StartUp_Message{"init AmiBlitz3 environment..."}

  tokenfile.s      = dos_AddPart{AmiBlitz3\AIDEDir,"tokens.tmp.txt"}
  includesfile.s   = dos_AddPart{AmiBlitz3\AIDEDir,"includes.tmp.txt"}
  hashmapfile.s    = dos_AddPart{AmiBlitz3\AIDEDir,"tokens.hash"}
  tokenspftfile.s  = dos_AddPart{AmiBlitz3\AIDEDir,"tokens.pft"}
  lhashmapfile.s   = dos_AddPart{AmiBlitz3\AIDEDir,"tokens.l.hash"}
  sdkfile.s        = dos_AddPart{AmiBlitz3\AIDEDir,"sdk.pft"}
  lsdkfile.s       = dos_AddPart{AmiBlitz3\AIDEDir,"sdk.l.pft"}

  If AIDE\RefreshAll Then refresh=True
  
  If refresh
    dos_Delete{tokenfile}
    dos_Delete{includesfile}
    dos_Delete{hashmapfile}
    dos_Delete{tokenspftfile}
    dos_Delete{lhashmapfile}
    dos_Delete{sdkfile}
    dos_Delete{lsdkfile}
  End If
  
  AmiBlitz3\TempP = AllocVec_(1024,#MEMF_ANY)

  If dos_Exist{hashmapfile} AND dos_Exist{lhashmapfile} AND refresh=False
    AmiBlitz3\Tokens  = hashmap_Load{hashmapfile}
    AmiBlitz3\LTokens = hashmap_Load{lhashmapfile}
    AmiBlitz3\TokensT = pft_Load{tokenspftfile}
  End If
  
  If dos_Exist{sdkfile} AND dos_Exist{lsdkfile} AND refresh=False
    AmiBlitz3\SDK  = pft_Load{sdkfile}
    AmiBlitz3\LSDK = pft_Load{lsdkfile}
  End If

  ; /* ========== Regenerate if not exists ================= */
  If AmiBlitz3\Tokens=Null OR AmiBlitz3\LTokens=Null
    StartUp_Message{"query tokens from AmiBlitz3..."}  
    dos_RunCli{AmiBlitz3\Exe,0,-1,True,"-dump token "+tokenfile+""}

    *hm.hashmap = hashmap_Create{14}
    *cm.hashmap = hashmap_Create{14}
    *pft.prefixtree = pft_Create{4096}
    If *hm
      _AmiBlitz3_ReadTokenFile{tokenfile,*hm,*cm,*pft}
      AmiBlitz3\Tokens  = *hm
      AmiBlitz3\LTokens = *cm
      AmiBlitz3\TokensT = pft_Optimize{*pft}
      pft_Free{*pft}
      hashmap_Save{AmiBlitz3\Tokens,hashmapfile}
      hashmap_Save{AmiBlitz3\LTokens,lhashmapfile}
      pft_Save{AmiBlitz3\TokensT,tokenspftfile}
    End If
  End If

  If AmiBlitz3\Tokens ; generate inverse mapping from libid/tokenid => token name
    If AmiBlitz3\Detokens=Null
      AmiBlitz3\Detokens = AllocVec_ (128*256*4,#MEMF_CLEAR)
    Else
      For n.l=0 To 128*256-1
        Poke.l AmiBlitz3\Detokens + n*4,Null
      Next
    End If

    *hm.hashmap = AmiBlitz3\Tokens
    *ta.l       = AmiBlitz3\Detokens
    If *ta><Null AND *hm><Null
      For n.l=0 To *hm\size-1
        ptr.l   = Peek.l(*hm\base + n*4)
        If ptr
          size.l   = Peek.l(ptr) : ptr +4
          endptr.l = ptr + size
          While ptr<endptr
            ikl.l = Peek.l(ptr) : ptr +4+ikl
            isl.l = Peek.l(ptr) : ptr +4+isl
            tokenIndex.l = (Peek.w(ptr-isl) & $7FFF)
            Poke.l *ta+tokenIndex*4,ptr-isl-4-ikl-4
          Wend
        End If
      Next
    End If
  End If

  ; get includes
  dos_OpenToolTypes{AmiBlitz3\Exe}
  AmiBlitz3\IncludeDir   = dos_GetToolString{"INCLUDEDIR","Blitz3:Sourcecodes/Includes"}
  AmiBlitz3\Blitz3Assign = dos_GetToolString{"ASSIGN","Blitz3:"}
  dos_CloseToolTypes{}
  AmiBlitz3\Blitz3Path   = dos_PathPart{AmiBlitz3\Exe}
  If Left$(LCase$(AmiBlitz3\IncludeDir),FLen(AmiBlitz3\Blitz3Assign))=LCase$(AmiBlitz3\Blitz3Assign)
    AmiBlitz3\IncludeDir = dos_AddPart{AmiBlitz3\Blitz3Path,Right$(AmiBlitz3\IncludeDir,FLen(AmiBlitz3\IncludeDir)-FLen(AmiBlitz3\Blitz3Assign))}
  End If
    
  If AmiBlitz3\SDK=Null OR AmiBlitz3\LSDK=Null
    StartUp_Message{"scanning AmiBlitz3 includes..."}    
    AmiBlitz3\SDK  = pft_Create{1024*1024}
    AmiBlitz3\LSDK = pft_Create{1024*1024}
    _AmiBlitz3_ReadToken2LibFile{dos_AddPart{AmiBlitz3\Blitz3Path,"System/token_mapping_libs.txt"},AmiBlitz3\Tokens}
    ab3scan.s = dos_AddPart{AmiBlitz3\AIDEDir,"AB3Scan"}
    If dos_Exist{includesfile}=False OR refresh
      ;dos_RunCli{ab3scan,0,-1,True,">"+includesfile+" "+AmiBlitz3\IncludeDir+" -r -df SFMTNCGL"}

      params.s = AmiBlitz3\IncludeDir+" -r -df SFMTNCGL"
      If ntui_RunAsyncAndNotify{*ntui,ab3scan,params,includesfile,"SCANDONE",0,""}
        done.l = False
        Repeat
          *notify.tuiNotify = ntui_WaitNotify{*ntui}
          Select ntui_GetNotifyID{*notify}
            Case "ev_splash_tick" : StartUp_Message{""}
            Case "SCANDONE" : done=True
          End Select
        Until done
      End If
    End If
    StartUp_Message{"reading AmiBlitz3 include info..."}  
    _AmiBlitz3_ReadSDKFile{includesfile,AmiBlitz3\SDK,$09}
    _AmiBlitz3_ReadSDKFile{tokenfile,AmiBlitz3\SDK,$20}
    *sdk.prefixtree = pft_Optimize{AmiBlitz3\SDK} : pft_Free{AmiBlitz3\SDK} : AmiBlitz3\SDK = *sdk
    genSdkMap{AmiBlitz3\SDK,AmiBlitz3\LSDK}
    *sdk.prefixtree = pft_Optimize{AmiBlitz3\LSDK} : pft_Free{AmiBlitz3\LSDK} : AmiBlitz3\LSDK = *sdk
    StartUp_Message{"sorting AmiBlitz3 include info..."}  
    pft_Sort{AmiBlitz3\SDK}
    StartUp_Message{"writing AmiBlitz3 include info..."}  
    pft_Save{AmiBlitz3\SDK,sdkfile}
    pft_Save{AmiBlitz3\LSDK,lsdkfile}
    ;pft_SaveASCII{AmiBlitz3\LSDK,lsdkfile+".asc.txt"}
    ;pft_SaveASCII{AmiBlitz3\SDK,sdkfile+".asc.txt"}
  End If
  ;dos_Delete{tokenspftfile}

  ;/* ================= Init Character Flags ============== */
  For n.l=0 To 255
    AmiBlitz3\CharFlags[n] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW
  Next

  AmiBlitz3\CharFlags[   0] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_EOL ; Null
  AmiBlitz3\CharFlags[   1] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SOH
  AmiBlitz3\CharFlags[   2] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; STX
  AmiBlitz3\CharFlags[   3] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ETX
  AmiBlitz3\CharFlags[   4] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; EOT
  AmiBlitz3\CharFlags[   5] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ENQ
  AmiBlitz3\CharFlags[   6] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ACK
  AmiBlitz3\CharFlags[   7] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; BELL
  AmiBlitz3\CharFlags[   8] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; BS  (backspace)
  AmiBlitz3\CharFlags[   9] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW|#AB3TF_SPACE ; TAB (tabulator)
  AmiBlitz3\CharFlags[  10] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW|#AB3TF_EOL ; LF  (line feed) Linux Return
  AmiBlitz3\CharFlags[  11] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; VT
  AmiBlitz3\CharFlags[  12] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; FF  (feed forward)
  AmiBlitz3\CharFlags[  13] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CR  (carrier return) Windows Return
  AmiBlitz3\CharFlags[  14] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SO
  AmiBlitz3\CharFlags[  15] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SI
  AmiBlitz3\CharFlags[  16] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; DLE
  AmiBlitz3\CharFlags[  17] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; DC1
  AmiBlitz3\CharFlags[  18] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CD2
  AmiBlitz3\CharFlags[  19] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CD3
  AmiBlitz3\CharFlags[  20] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CD4
  AmiBlitz3\CharFlags[  21] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; NAK
  AmiBlitz3\CharFlags[  22] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SYN
  AmiBlitz3\CharFlags[  23] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ETB
  AmiBlitz3\CharFlags[  24] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; CAN (Cancel)
  AmiBlitz3\CharFlags[  25] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; EM
  AmiBlitz3\CharFlags[  26] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; SUB
  AmiBlitz3\CharFlags[  27] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; ESC (Escape)
  AmiBlitz3\CharFlags[  28] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; FS
  AmiBlitz3\CharFlags[  29] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; GS
  AmiBlitz3\CharFlags[  30] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; RS
  AmiBlitz3\CharFlags[  31] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW ; US
  AmiBlitz3\CharFlags[@" "] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY|#AB3TF_SPACE ; Space
  AmiBlitz3\CharFlags[@"!"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY|#AB3TF_IS
  AmiBlitz3\CharFlags[  34] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY|#AB3TF_QUOT
  AmiBlitz3\CharFlags[@"#"] = #AB3TF_STOP | #AB3TF_IS   | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"$"] = #AB3TF_STOP | #AB3TF_IS   | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"%"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"&"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"'"] = #AB3TF_STOP | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"("] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY | #AB3TF_BRACKET
  AmiBlitz3\CharFlags[@")"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY | #AB3TF_BRACKET
  AmiBlitz3\CharFlags[@"*"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"+"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@","] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"-"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"."] = #AB3TF_STOP | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"/"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"0"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_BIN |#AB3TF_HEX|#AB3TF_DEC
  AmiBlitz3\CharFlags[@"1"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_BIN |#AB3TF_HEX|#AB3TF_DEC
  AmiBlitz3\CharFlags[@"2"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"3"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"4"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"5"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"6"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"7"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"8"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@"9"] = #AB3TF_IS   | #AB3TF_COPY | #AB3TF_HEX |#AB3TF_DEC
  AmiBlitz3\CharFlags[@":"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@";"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COMMENT|#AB3TF_COPY
  AmiBlitz3\CharFlags[@"<"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"="] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@">"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"?"] = #AB3TF_STOP | #AB3TF_NEW  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"@"] = #AB3TF_STOP | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"A"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"B"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"C"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"D"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"E"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"F"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY|#AB3TF_HEX
  AmiBlitz3\CharFlags[@"G"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"H"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"I"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"J"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"K"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"L"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"M"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"N"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"O"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"P"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"Q"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"R"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"S"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"T"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"U"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"V"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"W"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"X"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"Y"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"Z"] = #AB3TF_FIRST| #AB3TF_IS  |#AB3TF_COPY
  AmiBlitz3\CharFlags[@"["] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY | #AB3TF_BRACKET
  AmiBlitz3\CharFlags[@"\"] = #AB3TF_STOP | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"]"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY | #AB3TF_BRACKET
  AmiBlitz3\CharFlags[@"^"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"_"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"`"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"a"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"b"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"c"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"d"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"e"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"f"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY | #AB3TF_HEX
  AmiBlitz3\CharFlags[@"g"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"h"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"i"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"j"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"k"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"l"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"m"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"n"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"o"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"p"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"q"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"r"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"s"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"t"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"u"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"v"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"w"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"x"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"y"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"z"] = #AB3TF_FIRST| #AB3TF_IS  | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"{"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY | #AB3TF_BRACKET
  AmiBlitz3\CharFlags[@"|"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[@"}"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY | #AB3TF_BRACKET
  AmiBlitz3\CharFlags[@"~"] = #AB3TF_STOP | #AB3TF_NEW | #AB3TF_COPY
  AmiBlitz3\CharFlags[ 127] = #AB3TF_ILLEGAL | #AB3TF_STOP | #AB3TF_NEW

  AmiBlitz3\IsPrepared=True

  Function Return True

End Function


AmiBlitz3_Deinit:
Statement AmiBlitz3_Deinit{}

  If AmiBlitz3\TokensT  Then pft_Free{AmiBlitz3\TokensT}    : AmiBlitz3\TokensT  = Null
  If AmiBlitz3\Tokens   Then hashmap_Free{AmiBlitz3\Tokens} : AmiBlitz3\Tokens   = Null
  If AmiBlitz3\LTokens  Then hashmap_Free{AmiBlitz3\LTokens}: AmiBlitz3\LTokens  = Null
  If AmiBlitz3\Detokens Then FreeVec_ AmiBlitz3\Detokens    : AmiBlitz3\Detokens = Null
  If AmiBlitz3\TempP    Then FreeVec_ AmiBlitz3\TempP       : AmiBlitz3\TempP    = Null
  If AmiBlitz3\SDK      Then pft_Free{AmiBlitz3\SDK}        : AmiBlitz3\SDK      = Null
  If AmiBlitz3\LSDK     Then pft_Free{AmiBlitz3\LSDK}       : AmiBlitz3\LSDK     = Null
  AmiBlitz3\IsPrepared = False

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_Deinit,{}}

Function.l _AmiBlitz3_ExportAB3{docX.l,filename.s}

  succ.l = False
  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra

  fid.l = file_Open{filename,#file_forcewrite}
  If fid>=0
    If *xtra
    file_WriteLine{fid,"; XTRA"}
    file_WriteLine{fid,"; Embedded .xtra Header"}
    file_WriteLine{fid,"; "}
    file_WriteLine{fid,"; General Info"}
    file_WriteLine{fid,"; -------------------------------------------------------"}
    file_WriteLine{fid,"; ExePath         = \\22"+str_Read{&*xtra\ExePath}+"\\22"}
    file_WriteLine{fid,"; ExeFile         = \\22"+str_Read{&*xtra\ExeFile}+"\\22"}
    file_WriteLine{fid,"; CreateIcon      = "+Str$(*xtra\CreateIcon)}
    file_WriteLine{fid,"; Residents       = \\22"+str_Read{&*xtra\Residents}+"\\22"}
    file_WriteLine{fid,"; "}
    file_WriteLine{fid,"; Compiler"}
    file_WriteLine{fid,"; -------------------------------------------------------"}
    file_WriteLine{fid,"; StringBuffer    = "+Str$(*xtra\StringBuffer)}
    file_WriteLine{fid,"; MakeSmallest    = "+Str$(*xtra\MakeSmallest)}
    file_WriteLine{fid,"; FuncOptimize    = "+Str$(*xtra\FuncOptimize)}
    file_WriteLine{fid,"; Version         = "+Str$(*xtra\MajorVersion)+"."+Str$(*xtra\MinorVersion)+"."+Str$(*xtra\PatchVersion)}
    file_WriteLine{fid,"; NumberOfBuilds  = "+Str$(*xtra\NumberOfBuilds)}
    file_WriteLine{fid,"; "}
    file_WriteLine{fid,"; Debugger"}
    file_WriteLine{fid,"; -------------------------------------------------------"}
    file_WriteLine{fid,"; CliArgs         = \\22"+str_Read{&*xtra\CliArgs}+"\\22"}
    file_WriteLine{fid,"; StackSize       = "+Str$(*xtra\StackSize)}
    file_WriteLine{fid,"; RuntimeDebug    = "+Str$(*xtra\UseDebugger)}
    file_WriteLine{fid,"; DebugInfo       = "+Str$(*xtra\DebugInfo)}
    file_WriteLine{fid,"; CreateDbgFile   = "+Str$(*xtra\CreateDbgFile)}
    file_WriteLine{fid,"; OverflowCheck   = "+Str$(*xtra\OverflowCheck)}
    file_WriteLine{fid,"; AssemblerCheck  = "+Str$(*xtra\AssemblerCheck)}
    file_WriteLine{fid,"; InterruptCheck  = "+Str$(*xtra\InterruptCheck)}
    file_WriteLine{fid,"; AutoRun         = "+Str$(*xtra\AutoRun)}
    file_WriteLine{fid,"; "}
    file_WriteLine{fid,"; Editor"}
    file_WriteLine{fid,"; -------------------------------------------------------"}
    file_WriteLine{fid,"; CursorLine      = "+Str$(*xtra\CursorLine)}
    file_WriteLine{fid,"; CursorColumn    = "+Str$(*xtra\CursorColumn)}
    file_WriteLine{fid,"; LabelSearch     = \\22"+str_Read{&*xtra\LabelSearch}+"\\22"}
    file_WriteLine{fid,"; LabelRemark     = "+Str$(*xtra\LabelRemark)}
    file_WriteLine{fid,"; LabelAll        = "+Str$(*xtra\LabelAll)}
    file_WriteLine{fid,"; LabelPosition   = "+Str$(*xtra\LabelPosition)}
    file_WriteLine{fid,"; "}
    file_WriteLine{fid,"; Blitz Objects"}
    file_WriteLine{fid,"; -------------------------------------------------------"}

    For n.l = 0 To 255
      If *xtra\MaxName[n]
        name.s = str_Read{&*xtra\MaxName[n]}
        name.s = Replace$(name," ","-")
        maxname.s = "; Max "+name
        If FLen(maxname)<18 Then maxname + LSet$(" ",18-FLen(maxname))
        file_WriteLine{fid,maxname+"= "+Str$(*xtra\MaxNum[n])}
      End If
    Next

    file_WriteLine{fid,"; /XTRA"}
    End If

    ntui_GetAttr{*textBox,#TUITBA_TOTALLINES,&total.l}
    For n.l=0 To total-1
      *ptr.b = n
      l.l = n
      If ntui_GetAttr{*textBox,#TUITBA_LINE,&*ptr} AND ntui_GetAttr{*textBox,#TUITBA_LINELENGTH,&l}
        If *ptr Then file_WriteMem{fid,*ptr,l}
      End If
    Next

    succ = True
    file_Close{fid}
  End If

  Function Return succ

End Function

Function.l _AmiBlitz3_ImportAB3{docX.l,filename.s}

  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra
  maxObjCount.l = 0

  fp.l = Open_(&filename,#MODE_OLDFILE)
  If fp=Null Then Function Return 1

  blength.l = 0
  If Seek_ (fp,0,#OFFSET_END)><-1
    blength   = Seek_ (fp,0,#OFFSET_BEGINNING)
  End If
  If blength>0

    ntui_SetAttr{*textBox,#TUITBA_TEXT,Null}
    ntui_SetAttr{*textBox,#TUITBA_FILENAME,&filename}

    inP.l = AllocVec_(blength,#MEMF_ANY)
    If inP
      rlength.l = Read_ (fp,inP,blength)
      If rlength=blength

        sptr.l = inP
        eptr.l = inP+blength
        headerDone.l = False
        offset.l = 0

        Repeat
          lptr.l = sptr
          While Peek.b(sptr)><$0A AND sptr<eptr : sptr+1:Wend
          If sptr<eptr Then sptr+1:Else headerDone=True

          lin.s = Peeks$(lptr,sptr-lptr)
          eqpos.l = Instr(lin,"=")
          If eqpos>0
            rawtoken.s = Left$(lin,eqpos-1)
            value.s    = Right$(lin,FLen(lin)-eqpos-1)
          Else
            rawtoken.s = lin
            value.s    =  ""
          End If

          token.s    = ""
          For n.l=0 To FLen(rawtoken)-1    ; trim token
            c.b = Peek.b(&rawtoken+n)
            If (c>=@"a" AND c<=@"z") OR (c>=@"A" AND c<=@"Z") OR c=@"_" OR c=@"/" OR c=@"-"
              If (c=@"-") Then c=32 ; - to SPACE
              token + Chr$(c)
            End If
          Next

          ltrim.l = 0
          lmax.l  = FLen(value)
          While Peek.b(&value+ltrim)&$FF<=32 AND ltrim<lmax: ltrim+1 : Wend
          rtrim.l = lmax
          While Peek.b(&value+rtrim)&$FF<=32 AND rtrim>=0 : rtrim-1 : Wend
          If Peek.b(&value+rtrim)=$22 AND Peek.b(&value+ltrim)=$22 Then rtrim-1:ltrim+1
          value = Mid$(value,ltrim+1,rtrim-ltrim+1)
          lvalue.l = Vallong(value)


          If token
            ;error{"token: "+token+" / value="+value}

            Select LCase$(token)
              Case "/xtra"
                headerDone = True
                ; remove embedded XTRA Header
                offset = sptr-inP

              Case "exepath"        : str_Write{&*xtra\ExePath, value}
              Case "exefile"        : str_Write{&*xtra\ExeFile, value} ;: error{"Set exefile to "+str_Read{&*xtra\ExeFile}}
              Case "residents"      : str_Write{&*xtra\Residents, value}
              Case "stringbuffer"   : *xtra\StringBuffer = lvalue : If *xtra\StringBuffer<#AB3_MIN_STRINGBUFFER  Then *xtra\StringBuffer=#AB3_MIN_STRINGBUFFER
              Case "stacksize"      : *xtra\StackSize    = lvalue : If *xtra\StackSize   <#AB3_MIN_STACKSIZE     Then *xtra\StackSize   =#AB3_MIN_STACKSIZE
              Case "makesmallest"   : *xtra\MakeSmallest = lvalue
              Case "funcoptimize"   : *xtra\FuncOptimize = lvalue
              Case "version"
                mpos.l = Instr(value,".",1)
                ppos.l = Instr(value,".",mpos+1)                          ; fixed search of the second "." because we must start +1 behind the first founded one
                *xtra\MajorVersion = Vallong(Left$(value,mpos))
                *xtra\MinorVersion = Vallong(Mid$(value,mpos+1,ppos-mpos+1))
                *xtra\PatchVersion = Vallong(Right$(value,FLen(value)-ppos))  ; fixed leng calculation
              Case "numberofbuilds" : *xtra\NumberOfBuilds = lvalue
              Case "cliargs"        : str_Write{&*xtra\CliArgs, Left$(value,254)}
              Case "createicon"     : *xtra\CreateIcon     = lvalue
              Case "runtimedebug"   : *xtra\UseDebugger    = lvalue
              Case "debuginfo"      : *xtra\DebugInfo      = lvalue
              Case "createdbgfile"  : *xtra\CreateDbgFile  = lvalue
              Case "overflowcheck"  : *xtra\OverflowCheck  = lvalue
              Case "assemblercheck" : *xtra\AssemblerCheck = lvalue
              Case "interruptcheck" : *xtra\InterruptCheck = lvalue
              Case "autorun"        : *xtra\AutoRun        = lvalue
              Case "cursorline"     : *xtra\CursorLine     = lvalue
              Case "cursorcolumn"   : *xtra\CursorColumn   = lvalue
              Case "labelsearch"    : str_Write{&*xtra\LabelSearch, Left$(value,29)}
              Case "labelremark"    : *xtra\LabelRemark    = lvalue
              Case "labelall"       : *xtra\LabelAll       = lvalue
              Case "labelposition"  : *xtra\LabelPosition  = lvalue            ; added the read of inner position of the labellist tomsmart1
              Default
                ;error{"is max obj ?"+token}
                If LCase$(Left$(token,3))="max"
                  bobjName.s = Right$(token,FLen(token)-3)
                  If maxObjCount<256
                    str_Write{&*xtra\MaxName[maxObjCount],bobjName}
                    *xtra\MaxNum[maxObjCount] = lvalue
                    maxObjCount+1
                  End If
                End If

            End Select
          End If

        Until headerDone

        ;ntui_AppendTextBox{*textBox,inP+offset,rlength-offset}
        _ntui_SetTextBoxText{*textBox,inP+offset,rlength-offset}
      End If
      FreeVec_ inP
    End If
  End If
  Close_ fp

  Function Return 0

End Function


; detokenize a blitz source code buffer and write it to file pointer
Function.l _AmiBlitz3_ImportBB2{docX.l,filename.s}

  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra

  *detokens.l = AmiBlitz3\Detokens
  If *detokens = Null Then Function Return 3

  inP.l  = AllocVec_(4096*2,#MEMF_ANY)
  outP.l = AllocVec_(4096*2,#MEMF_ANY)
  If inP=Null OR outP=Null Then Function Return 2

  fp.l = Open_(&filename,#MODE_OLDFILE)
  If fp=Null Then Function Return 1

  dptr.l        = outP               ; destination pointer
  wptr.l        = outP+4096          ; write if destpointer>wptr!
  sptr.l        = inP                ; source pointer
  rpos.l        = 0
  count.l       = 0

  ntui_SetAttr{*textBox,#TUITBA_TEXT,Null}
  ntui_SetAttr{*textBox,#TUITBA_FILENAME,&filename}

  Repeat

    r.l = Read_ (fp,inP+rpos,4096*2-rpos)
    If r>0 Then rpos+r
    sptr = inP
    rptr.l = inP + Min(rpos,4096)

    While sptr<rptr
      c.b  = Peek.b(sptr)

      If (c&$80)
        ; token...
        tokenIndex.l = ((c & $7F) LSL 8) | (Peek.b(sptr+1) & $FF)
        tokenNode.l  = Peek.l(*detokens + tokenIndex*4)
        If tokenNode
          tokenLength.l = Peek.l(tokenNode) : tokenNode+4
          If tokenLength<128
            For n.l=0 To tokenLength-1
              Poke.b dptr,Peek.b(tokenNode) : dptr+1 : tokenNode+1
            Next
          Else
            ; token is longer than 128 chars, WTF!?
          End If
        Else
          libid.l   = (tokenIndex LSR 7) & $FF
          tokenid.l = tokenIndex & $7F
          defToken.s = "????Lib"+Str$(libid)+"/"+Str$(tokenid)
          For n.l=0 To FLen(defToken)-1
            Poke.b dptr,Peek.b(&defToken+n) : dptr+1
          Next
        End If
        sptr+2
      Else
        If c=0   ; it's a newline
          Poke.b dptr,$0A : dptr+1 : sptr+1
        Else
          Poke.b dptr,c : dptr+1 : sptr+1
        End If

        If (c=@";") ; it's a comment!
          Repeat
            c  = Peek.b(sptr)
            Poke.b dptr,c : dptr+1
            sptr+1
          Until (c=0) ;OR (sptr>=rptr))
          If c=0 Then Poke.b dptr-1,$0A
        End If

        If (c=$22) ; it's a string!
          Repeat
            c  = Peek.b(sptr)
            Poke.b dptr,c : dptr+1
            sptr+1
          Until (c=$22) OR (c=0) ;OR (sptr>=rptr))
          If c=0 Then Poke.b dptr-1,$0A
        End If

      End If

      If dptr>=wptr
        wlen.l = dptr-outP
        ;Poke.b dptr,$00
        ;ntui_SetAttr{*textBox,#TUITBA_APPENDTEXT,outP}
        ntui_AppendTextBox{*textBox,outP,wlen}
        count + wlen
        dptr = outP
      End If
    Wend

    rpos = rpos - (sptr - inP)
    If rpos>0 Then CopyMem_ sptr,inP,rpos

  Until rpos<=0

  If dptr>outP
    wlen.l = dptr-outP
    ;Poke.b dptr,$00
    ;ntui_SetAttr{*textBox,#TUITBA_APPENDTEXT,outP}
    ntui_AppendTextBox{*textBox,outP,wlen}
    count + wlen
    dptr = outP
  End If


  FreeVec_ inP
  FreeVec_ outP
  Close_ fp

  Function Return 0

End Function


AmiBlitz3_Import:
Function.l AmiBlitz3_Import{docX.l,*filenameP.b}

  err.l      = 0
  filename.s = Peek.s(*filenameP)
  ex.s       = dos_GetExt{filename}
  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  ntui_SetAttr{*textBox,#TUITBA_UNDO,False}
  Select ex
    Case "ab2"
      err.l = ntui_LoadTextBox{*textBox,&filename}
      AIDE\Document[docX]\IsLocked = True
    Case "ab3"
      err.l = _AmiBlitz3_ImportAB3{docX,filename}
      ntui_SetAttr{*textBox,#TUITBA_UNDO,True}
      AIDE\Document[docX]\IsLocked = False
    Case "bb2"
      err.l = _AmiBlitz3_ImportBB2{docX,filename}
      AIDE\Document[docX]\IsLocked = True
    Case "bb"
      err.l = _AmiBlitz3_ImportBB2{docX,filename}
      AIDE\Document[docX]\IsLocked = True
    Default
      err.l = ntui_LoadTextBox{*textBox,&filename}
      AIDE\Document[docX]\IsLocked = True
  End Select

  Function Return err

End Function
!_MakeGlobalFuncPointer{AmiBlitz3_Import,{0,Null}}


AmiBlitz3_Export:
Function.l AmiBlitz3_Export{docX.l,*filenameP.b}

  err.l = -1
  filename.s = Peek.s(*filenameP)
  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  ex.s       = dos_GetExt{filename}

  Select ex
    Case "ab2"
      err.l = ntui_SaveTextBox{*textBox,&filename}
    Case "ab3"
      If  _AmiBlitz3_ExportAB3{docX,filename} Then err=0:Else err=-1
    Case "bb2"
      error{"Saving as .bb2 is not supported, please use .ab3"}
    Case "bb"
      error{"Saving as .bb is not supported, please use .ab3"}
    Default
      err.l = ntui_SaveTextBox{*textBox,&filename}
  End Select

  Function Return err

End Function
!_MakeGlobalFuncPointer{AmiBlitz3_Export,{0,Null}}



AmiBlitz3_UpdateSDK:
Statement AmiBlitz3_UpdateSDK{docX.l}

  *sdk.prefixtree = Null

  If docX>=0
    *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra
    If *xtra
      *sdk = *xtra\LocalSDK  
    End If
    *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*ntui,!obj_src_list}
    *fi.tuiImageView = (.tuiImageView)ntui_GetObjectByID{*ntui,!obj_src_filter_image}
    *stats.tuiLabel   = (.tuiLabel)ntui_GetObjectByID{*ntui,!obj_src_filter_stats}
    func.l = ntui_GetValueByID{*ntui,!obj_src_show_function}
    macr.l = ntui_GetValueByID{*ntui,!obj_src_show_macro}
    newt.l = ntui_GetValueByID{*ntui,!obj_src_show_struct}
    labe.l = ntui_GetValueByID{*ntui,!obj_src_show_label}
    cons.l = ntui_GetValueByID{*ntui,!obj_src_show_constant}
    glob.l = ntui_GetValueByID{*ntui,!obj_src_show_global}
    loca.l = ntui_GetValueByID{*ntui,!obj_src_show_local}
    stri.l = ntui_GetValueByID{*ntui,!obj_src_show_string}
    ;toke.l = ntui_GetValueByID{*ntui,!obj_src_show_token}
    all.l  = ntui_GetValueByID{*ntui,!obj_src_show_all}
    filt.s = ntui_GetStringByID{*ntui,!obj_src_filter}
  Else
    *sdk = AmiBlitz3\SDK
    *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*ntui,!obj_ab3_list}
    *fi.tuiImageView = (.tuiImageView)ntui_GetObjectByID{*ntui,!obj_ab3_filter_image}
    *stats.tuiLabel   = (.tuiLabel)ntui_GetObjectByID{*ntui,!obj_ab3_filter_stats}
    func.l = ntui_GetValueByID{*ntui,!obj_ab3_show_function}
    macr.l = ntui_GetValueByID{*ntui,!obj_ab3_show_macro}
    newt.l = ntui_GetValueByID{*ntui,!obj_ab3_show_struct}
    labe.l = ntui_GetValueByID{*ntui,!obj_ab3_show_label}
    cons.l = ntui_GetValueByID{*ntui,!obj_ab3_show_constant}
    glob.l = ntui_GetValueByID{*ntui,!obj_ab3_show_global}
    ;loca.l = ntui_GetValueByID{*ntui,!obj_ab3_show_local}
    ;stri.l = ntui_GetValueByID{*ntui,!obj_ab3_show_string}
    toke.l = ntui_GetValueByID{*ntui,!obj_ab3_show_token}
    all.l  = ntui_GetValueByID{*ntui,!obj_ab3_show_all}
    filt.s = ntui_GetStringByID{*ntui,!obj_ab3_filter}
  End If
  
  #MAX_AB3RESULTS = 1000
  If all 
    func=True:macr=True:newt=True:labe=True:cons=True:glob=True:loca=True:stri=True:toke=True
    prefix.s = ""
  Else
    If func Then prefix="FUNCTION"
    If macr Then prefix="MACRO"
    If newt Then prefix="NEWTYPE"
    If labe Then prefix="LABEL"
    If cons Then prefix="CONSTANT"
    If glob Then prefix="GLOBAL"
    If loca Then prefix="LOCAL"
    If stri Then prefix="STRING"
    If toke Then prefix="TOKEN"
  End If
  count.l = 0
  
  filt = LCase$(filt)
  
  If *lv><Null AND *sdk><Null
    ntui_ClearListView{*lv}
    title.s = "\pinfo|\lEntity Name|\lMore..."
    ntui_SetAttr{*lv,#TUILVA_TITLE,&title}
    pft_Reset{*sdk,prefix}
    scount.l=0

    While pft_GetNextItem{*sdk} AND count<#MAX_AB3RESULTS
      scount+1
      ;key.s  = pft_GetKey{*sdk}
      key.l = pftlib_GetFoundKey{*sdk,&keyLen.l}
      addit.l = False
        
      Select Peek.l(key)
        Case @"FUNC":
          If func
            info.s   = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            type_.s  = cropfield{info,3,$09,$09}
            track.s  = cropfield{info,4,$09,$09}
            help.s   = cropfield{info,5,$09,$00}
            text.s   = "F|"+name+"|" + "{"+track+"}"
            If type_><"" Then text + " => ."+type_+" "
            If help><"" Then text+" ; "+help
            addit = True
          End If

        Case @"MACR"
          If macr
            info.s = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            help.s  = cropfield{info,3,$09,$09}
            text.s = "M|!"+name +"|"
            If help><"" Then text+"; "+help
            addit = True
          End If

        Case @"TOKE"
          If toke
            info.s = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            help.s  = cropfield{info,3,$09,$09}
            text.s = "@|"+name +"|"+ntui_EscapeListViewString{*lv,help}
            addit = True
          End If

        Case @"CONS"
          If cons
            info.s = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            value.s  = cropfield{info,3,$09,$09}
            help.s  = cropfield{info,4,$09,$09}
            text.s = "C|#"+name + "|= "+value
            If help><"" Then text+" ; "+help
            addit = True
          End If

        Case @"NEWT"
          If newt
            info.s = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            help.s  = cropfield{info,3,$09,$09}
            text.s = "NT|."+name+"|"
            If help><"" Then text+"; "+help
            addit = True
          EndIf

        Case @"LABE"
          If labe
            info.s = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            help.s  = cropfield{info,3,$09,$09}
            text.s = "L|:"+name+"|"
            If help><"" Then text+"; "+help
            addit = True
          End If

        Case @"STRI"
          If stri
            info.s = pft_GetString{*sdk}
            ;name.s     = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            help.s     = cropfield{info,4,$09,$09}
            string.s   = cropfield{info,3,$09,$09}
            string     = ntui_EscapeListViewString{*lv,string}
            text.s = "$|"+"\d<literal>"+"|"+string+"|"
            ;If help><"" Then text+"; "+help
            addit = True
          End If

        Case @"GLOB"
          If glob
            info.s = pft_GetString{*sdk}
            name.s   = cropfield{info,0,$09,$09}
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            typ.s    = cropfield{info,3,$09,$09}
            help.s  = cropfield{info,4,$09,$09}
            text.s = "G|"+name+"|."+typ+""
            If help><"" Then text+" ; "+help
            addit = True
          End If

        Case @"LOCA"
          If loca
            info.s   = pft_GetString{*sdk}
            name.s   = ntui_EscapeListViewString{*lv,cropfield{info,0,$09,$09}}
            ;xpos.l   = Instr(name,"\")
            ;infunc.s   = "???"
            ;If xpos>0
            ;  infunc = Left$(name,xpos-1)
            ;  name   = Right$(name,FLen(name)-xpos)
            ;End If
            ;source.s = cropfield{info,1,$09,$09}
            ;line_.s  = cropfield{info,2,$09,$09}
            typ.s    = cropfield{info,3,$09,$09}
            help.s   = cropfield{info,4,$09,$09}
            text.s  = "V|"+name+"|."+typ+""
            If help><"" Then text+" ; "+help
            addit = True
          End If

        Default
          addit = False

      End Select

      If addit
        ;If filt><"" Then addit.l = instr_nocase{text,filt}
        If filt><"" Then addit.l = instr_nocaseP{&text,FLen(text),&filt,FLen(filt),0}
        If addit
          count+1
          ntui_AddListItem{*lv,-1,text,-1,Null,$0}
        End If
      End If

    Wend
  EndIf
  image.s = "filter"
  text.s = Str$(count)+" results out of "+Str$(scount)+" total"
  If count<=0    Then image+"|off"
  If scount<=0 Then text="no entities found"
  If count>=#MAX_AB3RESULTS Then image+"|stop" : text = "too many results, truncated to"+Str$(count)
  If *fi Then ntui_SetAttr{*fi,#TUIIVA_IMAGE,&image}
  If *stats Then ntui_SetString{*stats,text}

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_UpdateSDK,{0}}


AmiBlitz3_JumpTo:
Function.l AmiBlitz3_JumpTo{docX.l,*typeP.b,*nameP.b,*moreP.b}

  If *nameP Then name.s  = Peek.s(*nameP)
  If *typeP Then type_.s = Peek.s(*typeP)
  If *moreP Then more.s  = Peek.s(*moreP)
  
  *localSDK.prefixtree = Null
  *localLSDK.prefixtree= Null

  If docX>=0
    *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra
    If *xtra
      *localSDK  = *xtra\LocalSDK
      *localLSDK = *xtra\LocalLSDK
    End If
  End If
  
  Select type_
    Case "C"  : info.s = getSdkItem{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"CONSTANT",UnRight$(name,1)}
    Case "NT" : info.s = getSdkItem{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"NEWTYPE" ,UnRight$(name,1)}
    Case "M"  : info.s = getSdkItem{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"MACRO"   ,UnRight$(name,1)}
    Case "L"  : info.s = getSdkItem{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"LABEL"   ,UnRight$(name,1)}
    Case "G"  : info.s = getSdkItem{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"GLOBAL"  ,name}
    Case "V"  : info.s = getSdkItem{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"LOCAL"   ,name}
    Case "@"  : info.s = getSdkItem{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"TOKEN"   ,name}      ; call the guide!
    Case "$"  : info.s = getSdkItem{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"STRING"  ,more}
    Case "F"  : info.s = getSdkItem{*localSDK,*localLSDK,AmiBlitz3\SDK,AmiBlitz3\LSDK,"FUNCTION",name}
    Default
      info.s  = ""
      error{"Unkown entity to jump to : "+type_+"!"}
  End Select
  
  If info
    source.s = cropfield{info,1,$09,$09}
    line_.s  = cropfield{info,2,$09,$09}
    lpos.l   = Vallong(cropfield{line_,0,@"/",@"/"})
    cpos.l   = Vallong(cropfield{line_,1,@"/",0})
    docX.l   = Document_Open{source}
    If lpos>0 Then lpos-1
    If cpos>0 Then cpos-1
    Document_JumpTo{docX,lpos,cpos,True}
  End If
  
  Function Return 0
  
End Function
!_MakeGlobalFuncPointer{AmiBlitz3_JumpTo,{0,Null,Null,Null}}

Function.s _ab3_GetScanResultFilename{docX.l}
  Function Return "RAM:AB3"+Hex$(FindTask_(Null))+Str$(docX)+".async.txt"
End Function


AmiBlitz3_ScanSourceFinish:
Statement AmiBlitz3_ScanSourceFinish{docX.l,*filenameP.b}

  ;If *filenameP=Null Then Statement Return

  resultfile.s = _ab3_GetScanResultFilename{docX.l}

  *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra
  If *xtra=Null Then Statement Return

  If *xtra\LocalSDK Then pft_Free{*xtra\LocalSDK} : *xtra\LocalSDK = Null
  If *xtra\LocalLSDK Then pft_Free{*xtra\LocalLSDK} : *xtra\LocalLSDK = Null

  If *xtra\LocalSDK = Null Then *xtra\LocalSDK   = pft_Create{4096}
  If *xtra\LocalSDK = Null Then Statement Return

  If *xtra\LocalLSDK = Null Then *xtra\LocalLSDK = pft_Create{4096}
  If *xtra\LocalLSDK = Null Then Statement Return

  If *xtra\LocalSDK
    _AmiBlitz3_ReadSDKFile{resultfile,*xtra\LocalSDK,$09}
    pft_Sort{*xtra\LocalSDK}
    If *xtra\LocalLSDK
      genSdkMap{*xtra\LocalSDK,*xtra\LocalLSDK}
    End If
  End If

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_ScanSourceFinish,{0,Null}}


AmiBlitz3_ScanSource:
Statement AmiBlitz3_ScanSource{docX.l,*filenameP.b}

  filename.s   = Peek.s(*filenameP)
  resultfile.s = _ab3_GetScanResultFilename{docX}
  ab3scan.s    = dos_AddPart{AmiBlitz3\AIDEDir,"AB3Scan"}
  params.s     = filename

  fid.l = file_Open{resultfile,#file_forcewrite}
  If fid>=0
    fh.l = file_GetFH{fid}
    dos_RunCli{ab3scan,-1,-1,True,params,Null,fh}
    file_Close{fid}
    AmiBlitz3_ScanSourceFinish{docX.l,*filenameP.b}
  End If

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_ScanSource,{0,Null}}


AmiBlitz3_ScanSourceAsync:
Statement AmiBlitz3_ScanSourceAsync{docX.l,*filenameP.b}

  filename.s   = Peek.s(*filenameP)
  resultfile.s = _ab3_GetScanResultFilename{docX}
  ab3scan.s    = dos_AddPart{AmiBlitz3\AIDEDir,"AB3Scan"}
  params.s     = filename

  ntui_RunAsyncAndNotify{*ntui,ab3scan,params,resultfile,"FILESCAN",docX,filename}

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_ScanSourceAsync,{0,Null}}


Function.s _ab3_CropPrevToken{*textP.b,cpos.l,*fpos.l}

  If cpos<0 Then Function Return ""
  rbc.l = 0
  cbc.l = 0
  token.s = ""
  done.l = False
  from.l = -1
  to_.l  = -1
  Repeat
    c.w=Peek.b(*textP+cpos)&$FF 
    
    If c=@"{" Then cbc-1
    If c=@"}" Then cbc+1
    If c=@"(" Then rbc-1
    If c=@")" Then rbc+1
    If c=@"[" Then rbc-1
    If c=@"]" Then cbc+1
    
    If rbc<=0 AND cbc<=0
      If AmiBlitz3\CharFlags[c]&#AB3TF_IS
        from=cpos
      End If 
    End If
    If ((from>=0) AND ((AmiBlitz3\CharFlags[c]&#AB3TF_IS) = 0)) Then done=True
    cpos-1
  Until done=True OR cpos<0

  If from<0 Then Function Return ""
  to_=from
  Repeat
    c.w=Peek.b(*textP+to_)&$FF : to_+1
  Until AmiBlitz3\CharFlags[c]&#AB3TF_IS = 0
  token = Peeks$(*textP+from,to_-from-1)
    
  If *fpos Then Poke.l *fpos,from
  Function Return token
  
End Function

;      aaa bbb ccc
; this:aaaabbbbccc
; next:bbbbcccc
; prev:    aaaabbb
Function.s _ab3_CropNextToken{*textP.b,textLen.l,cpos.l,*fpos.l}

  If cpos>=textLen Then Function Return ""
  from.l = cpos
  If from<0 Then from=0  
  c.w = Peek.b(*textP+from)&$FF
  state.l = (AmiBlitz3\CharFlags[c]&#AB3TF_IS)
  done.l = False
  Repeat
    from+1
    c.w = Peek.b(*textP+from)&$FF
    If (AmiBlitz3\CharFlags[c]&#AB3TF_IS)><state
      If state=0 Then done=True : Else state=0
    End If
  Until done OR from>=textLen
  
  to_.l = from
  Repeat
    to_+1
    c.w = Peek.b(*textP+to_)&$FF
  Until (AmiBlitz3\CharFlags[c]&#AB3TF_IS=0) OR to_>=textLen

  token.s = Peeks$(*textP+from,to_-from)
  If *fpos Then Poke.l *fpos,from
  Function Return token
  
End Function

Function.s getSdkContext_{*local.prefixtree,lpos.l,cpos.l}

  context.s = ""
  flpos.l = 0
  succ.l = pft_Reset{*local,"F:"}
  While pft_GetNextItem{*local}
    key.s = pft_GetKey{*local}
    info.s = pft_GetString{*local}
    line_.s  = cropfield{info,2,$09,$09}
    name.s  = cropfield{info,1,$09,$09}
    slpos.l   = Vallong(cropfield{line_,0,@"/",@"/"})
    scpos.l   = Vallong(cropfield{line_,1,@"/",0})
    If slpos<=lpos AND slpos>=flpos
      context = name
      flpos = slpos
    End If
  Wend
  Function Return context
  
End Function


_ab3_OnLoseFocusCallback:
Function.l _ab3_OnLoseFocusCallback{*textBox.tuiTextBox, *ev.tuiEvent, *notify.str}

  Popup_Help{"","","",0,0}
  Function Return False
  
End Function
!_MakeGlobalFuncPointer{_ab3_OnLoseFocusCallback,{Null,Null,Null}}


_ab3_OnKeyCallback:
Function.l _ab3_OnKeyCallback{*textBox.tuiTextBox,*ev.tuiEvent,*notify.str}

  *inputSelector.tuiWindow = ntui_GetWindowByID{*ntui,!win_inputselector}
  
  If *inputSelector
    ntui_GetAttr{*inputSelector,#TUIA_ONSCREEN,&onScreen.l}
    If onScreen
     *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*inputSelector,!obj_selector_list}
     If *lv
      Select *ev\value
        Case #RAWKEY_UP
          _ntui_DispatchEvent{*lv,*ev}
          Function Return True
        Case #RAWKEY_DOWN
          _ntui_DispatchEvent{*lv,*ev}
          Function Return True
        Case #RAWKEY_RETURN
          _ntui_DispatchEvent{*lv,*ev}
          Function Return True
        Case #RAWKEY_ESC
          ntui_HideWindow{*inputSelector}
          Function Return True
      End Select
     End If
    End If
  End If

  ;ntui_GetEventAttr{*ev,#TUIEVA_VANILLAKEY,&vkey.l}
    
  ; hide help
  ;If *ev\value=#RAWKEY_UP OR *ev\value=#RAWKEY_DOWN OR vkey=$0A OR *ev\value=#RAWKEY_ESC
  ;  PopupHelp{"","","",0,0}
  ;End If
  
  Function Return False
  
End Function
!_MakeGlobalFuncPointer{_ab3_OnKeyCallback,{Null,Null,Null}}

Function.s _ab3_GetContext{*local.prefixtree,lpos.l,cpos.l}
  context.s = ""
  succ.l = pft_Reset{*local,"FUNCTION:"}
  flpos.l = -1
  
  While pft_GetNextItem{*local}
    key.s = pft_GetKey{*local}
    ;error{"Test context: "+key}
    info.s = pft_GetString{*local}
    If info
      name.s    = cropfield{info,0,$09,$09}
      ;source.s  = cropfield{info,1,$09,$09}
      line_.s   = cropfield{info,2,$09,$09}
      slpos.l   = Vallong(cropfield{line_,0,@"/",@"/"})
      scpos.l   = Vallong(cropfield{line_,1,@"/",0})
      If (slpos>flpos AND slpos<=lpos)
        context = name        
        flpos = slpos
      End If
    End If
  Wend
  
  Function Return context
  
End Function

Function.s _ab3_GetTokenHelp{token.s}
End Function

Function.s _ab3_GetTokenTypeAhead{token.s}
End Function

_ab3_OnPostKeyCallback:
Function.l _ab3_OnPostKeyCallback{*textBox.tuiTextBox,*ev.tuiEvent,*notify.str}

  ; get vanilla key
  vkey.l = $00
  ntui_GetEventAttr{*ev,#TUIEVA_VANILLAKEY,&vkey.l}

  ; hide popups
  If *ev\value=#RAWKEY_UP OR *ev\value=#RAWKEY_DOWN OR *ev\value=#RAWKEY_RETURN OR vkey=$0A OR *ev\value=#RAWKEY_ESC
    ntui_HideWindowByID{*ntui,!win_popuphelp}
    ntui_HideWindowByID{*ntui,!win_inputselector}
    Function Return False
  End If

  ; get SDK
  *local.prefixtree = Null
  *local_l.prefixtree = Null
  docX.l = Document_FindByTextBox{*textBox}
  If docX>=0
    *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra
    If *xtra 
      *local = *xtra\LocalSDK
      *local_l = *xtra\LocalLSDK
    End If
  End If

  ; when input selector is open...
  *inputSelector.tuiWindow = ntui_GetWindowByID{*ntui,!win_inputselector}
  If *inputSelector
    ntui_GetAttr{*inputSelector,#TUIA_ONSCREEN,&onScreen.l}
    If onScreen
     *lv.tuiListView = (.tuiListView)ntui_GetObjectByID{*inputSelector,!obj_selector_list}
     If *lv
       
     End If
   End If
 End If
 
 Function Return False

End Function
!_MakeGlobalFuncPointer{_ab3_OnPostKeyCallback,{Null,Null,Null}}


_ab3_OnPostKeyCallback_dep:
Function.l _ab3_OnPostKeyCallback_dep{*textBox.tuiTextBox,*ev.tuiEvent,*notify.str}

  ; dont do anything when moving cursor
  If *ev\value=#RAWKEY_RIGHT OR *ev\value=#RAWKEY_LEFT
    Function Return False
  End If

  vkey.l = 0
  ntui_GetEventAttr{*ev,#TUIEVA_VANILLAKEY,&vkey.l}
  
  ; hide help
  If *ev\value=#RAWKEY_UP OR *ev\value=#RAWKEY_DOWN OR *ev\value=#RAWKEY_RETURN OR vkey=$0A OR *ev\value=#RAWKEY_ESC
    Popup_Help{"","","",0,0}
    Function Return False
  End If

  ntui_GetAttr{*textBox,#TUITBA_CURSORLINE,&lpos.l}
  ntui_GetAttr{*textBox,#TUITBA_CURSORCHAR,&cpos.l}
  *lineP.b = lpos
  ntui_GetAttr{*textBox,#TUITBA_LINE,&*lineP}
  If *lineP = Null Then Function Return False
  pixpos.tuiPixel\x = 0,0
  ntui_GetTextBoxPixelCoordinates{*textBox,lpos+1,cpos,&pixpos}
  *win.tuiWindow = ntui_GetWindow{*textBox}
  ntui_GetAttr{*win,#TUIWA_SCREENPOSX,&winx.l}
  ntui_GetAttr{*win,#TUIWA_SCREENPOSY,&winy.l}

  If vkey=@"{" OR vkey=@"\"; replace function name with correct casing
    token.s = _ab3_CropPrevToken{*lineP,cpos,&fpos.l}
    
    *local.prefixtree = Null
    *local_l.prefixtree = Null
    docX.l = Document_FindByTextBox{*textBox}
    If docX>=0
      *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra
      If *xtra 
        *local = *xtra\LocalSDK
        *local_l = *xtra\LocalLSDK
      End If
    End If

    If vkey=@"{"
      info.s = getSdkItem{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"FUNCTION",token}
      If info
        name.s  = cropfield{info,0,$09,$09}
        If name><token
          ntui_SetTextBoxSelection    {*textBox,Null,lpos,fpos,lpos,fpos+FLen(name)}
          ntui_ReplaceTextBoxSelection{*textBox,&name,FLen(name)}
          Function Return True          
        End If
      End If
    End If
    
    If vkey=@"\"
      localcontext.s = _ab3_GetContext{*local,lpos,cpos}
      localtoken.s = localcontext + ":" + token
      ;error{"Looking for "+localtoken}
      info.s = getSdkItem{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"LOCAL",localtoken}
      If info="" Then info = getSdkItem{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"GLOBAL",token}
      If info="" Then token="*"+token
      localtoken.s = localcontext + ":" + token      
      If info="" Then info = getSdkItem{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"LOCAL",localtoken}
      If info="" Then info = getSdkItem{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"GLOBAL",token}
      If info><""
        name.s     = cropfield{info,0,$09,$09}
        newtype_.s = cropfield{info,3,$09,$09}
        
        lname.s = cropfield{name,1,@":",@":"}
        If FLen(lname)=FLen(token) Then name = lname
        If name><token
          ntui_SetTextBoxSelection    {*textBox,Null,lpos,fpos,lpos,fpos+FLen(name)}
          ntui_ReplaceTextBoxSelection{*textBox,&name,FLen(name)}          
        End If
        ;error{"token:"+token+"\\ntype: "+newtype_}
        info.s     = getSdkLookAhead{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"FIELD",newtype_+"\"}
        info = Replace$(info,newtype_+"\","")
        ;If info Then error{"Whohoo:\\n"+info}
        If info><""
          field.s     = cropfield{info,0,$09,$09}
          field = Replace$(field,"*","")
          ntui_SetTextBoxSelection    {*textBox,Null,lpos,cpos,lpos,cpos}
          ntui_ReplaceTextBoxSelection{*textBox,&field,FLen(field)}   
          ntui_SetTextBoxSelection    {*textBox,Null,lpos,cpos,lpos,cpos+FLen(field)}
          
          options.s = info;"this\\09is\\09a\\09test!"
          PopUp_InputSelector{options,pixpos\x+winx,pixpos\y+winy}
          Function Return True
        End If
      End If
    End If
    Function Return False
  End If

  longhelp.l = False
  If *ev\value=#RAWKEY_HELP
    token.s = _ab3_CropPrevToken{*lineP,cpos,&fpos.l} ; explicit help!
    If *ev\qualifier_&#TUIQUAL_SHIFT
      longhelp = True
    End If
  End If
  
  If (AmiBlitz3\CharFlags[vkey]&(#AB3TF_IS|#AB3TF_SPACE|#AB3TF_BRACKET)) 
    token.s = _ab3_CropPrevToken{*lineP,cpos,&fpos.l} ; while typing
  End If
 
  If token="" Then Function Return False
  info.s = ""
  ntui_GetTextBoxPixelCoordinates{*textBox,lpos+1,cpos-FLen(token),&pixpos}

  *local.prefixtree = Null
  *local_l.prefixtree = Null
  docX.l = Document_FindByTextBox{*textBox}
  If docX>=0
    *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra
    If *xtra 
      *local = *xtra\LocalSDK
      *local_l = *xtra\LocalLSDK
    End If
  End If
  
  If Peek.b(&token)=@"#"
    info.s = getSdkItem{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"CONSTANT",UnRight$(token,1)}
    If info
      name.s   = "#"+cropfield{info,0,$09,$09}
      file_.s  = cropfield{info,1,$09,$09}
      source.s = "Constant defined in "+dos_FilePart{file_}
      value.s  = cropfield{info,3,$09,$09}
      help.s   = cropfield{info,4,$09,$00}
      text.s   = " = "+value
      If help><"" Then text+" ; \\22"+help+"\\22"
    End If
  End If
    
  If Peek.b(&token)=@"!"
    info.s = getSdkItem{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"MACRO",UnRight$(token,1)}
    If info
      name.s   = "!"+cropfield{info,0,$09,$09}
      file_.s  = cropfield{info,1,$09,$09}
      source.s = "Macro defined in "+dos_FilePart{file_}
      help.s   = cropfield{info,3,$09,$00}
      text.s   = ""
      If help 
        If Peek.b(&help)><@"{" Then text + " ; "
        text     +help
      End If
    End If
  End If

  If fpos>0 AND info=""
    If Peek.b(*lineP+fpos-1)=@"."
      info.s = getSdkItem{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"NEWTYPE",token}
      If info
        name.s   = "."+cropfield{info,0,$09,$09}
        source.s = "Newtype defined in "+dos_FilePart{cropfield{info,1,$09,$09}}
        help.s   = cropfield{info,3,$09,$00}
        text.s   = ""
        If help><"" Then text+" ; "+help
      End If
    End If
  End If
  
  If info=""
    info.s = getSdkItem{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"FUNCTION",token}
    If info
      name.s  = cropfield{info,0,$09,$09}
      file_.s = cropfield{info,1,$09,$09}
      type_.s = cropfield{info,3,$09,$09}
      track.s = cropfield{info,4,$09,$09}
      help.s  = cropfield{info,5,$09,$00}
      source.s  = "Function defined in "+dos_FilePart{file_}
      If type_><"" Then text.s = "."+type_+" " : Else text=""
      text + "{"+track+"}"
      If help><"" Then text+" ; "+help
    End If
  EndIf
    
  If info=""
    info.s = getSdkItem{*local,*local_l,AmiBlitz3\SDK,AmiBlitz3\LSDK,"TOKEN",token}
    If info
      name.s   = cropfield{info,0,$09,$09}
      file_.s  = cropfield{info,1,$09,$09}
      help.s   = cropfield{info,3,$09,$00}
      ;pos.l      = Instr(file_,"/",0)
      ;libnum.l   = Vallong(Left$(file_,pos-1))
      ;tokennum.l = Vallong(Right$(file_,FLen(file_)-pos))
      ;If libnum>=0 AND libnum<256 Then libname.s = AmiBlitz3\BlitzLibName[libnum] : Else libname.s="BlitzLib"
      source.s = "BlitzBasic Token defined in "+file_
      text.s   = " "+ help
    End If
  End If
  
  If longhelp
    AmiBlitz3_LongHelp{docX,&type_,&token,&file_}
  Else
    Popup_Help{name,text,source,pixpos\x+winx,pixpos\y+winy}
  End If
  
  Function Return False

End Function
!_MakeGlobalFuncPointer{_ab3_OnPostKeyCallback_dep,{Null,Null,Null}}


AmiBlitz3_Attach:
Function.l AmiBlitz3_Attach{docX.l}

  If AmiBlitz3\IsPrepared=False Then _AmiBlitz3_Prepare{False}
  If AmiBlitz3\IsPrepared=False Then Function Return False

  AIDE\Document[docX]\Xtra    = _AmiBlitz3_AllocXtra{}
  AIDE\Document[docX]\DocType = AmiBlitz3\DocType
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_STYLECB,*_ab3_StyleCallback}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_ONPOSTKEYCB,*_ab3_OnPostKeyCallback}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUIA_ONLOSEFOCUSCB,*_ab3_OnLoseFocusCallback}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_ONKEYCB,*_ab3_OnKeyCallback}

  Function Return True

End Function
!_MakeGlobalFuncPointer{AmiBlitz3_Attach,{0}}


AmiBlitz3_Detach:
Function.l AmiBlitz3_Detach{docX.l}

  If AIDE\Document[docX]\Xtra Then _AmiBlitz3_FreeXtra{(.AmiBlitz3_Xtra)AIDE\Document[docX]\Xtra}
  AIDE\Document[docX]\Xtra = Null
  AIDE\Document[docX]\DocType = #DOCTYPE_DEFAULT
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_STYLECB,Null}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_ONKEYCB,Null}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_ONPOSTKEYCB,Null}
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUIA_ONLOSEFOCUSCB,Null}
  
  Function Return True

End Function
!_MakeGlobalFuncPointer{AmiBlitz3_Detach,{0}}


AmiBlitz3_ApplySettings:
Statement AmiBlitz3_ApplySettings{docX.l}

  !If_BadDocX_Then{ Statement Return }

  *win.tuiWindow = ntui_GetWindowByID{*ntui,!win_source_settings,docX}
  If *win
      *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra
      *xtra\MajorVersion   = ntui_GetValueByID{*win,"obj_version_major"}
      *xtra\MinorVersion   = ntui_GetValueByID{*win,"obj_version_minor"}
      *xtra\PatchVersion   = ntui_GetValueByID{*win,"obj_version_patch"}
      *xtra\NumberOfBuilds = ntui_GetValueByID{*win,"obj_version_build"}
      *xtra\StackSize      = ntui_GetValueByID{*win,"obj_stacksize"    }
      *xtra\StringBuffer   = ntui_GetValueByID{*win,"obj_stringbuffer" }

      exefile.s            = ntui_GetStringByID{*win,"obj_exefile"     }
      str_Write{&*xtra\ExeFile   ,dos_FilePart{exefile}}
      str_Write{&*xtra\ExePath   ,dos_PathPart{exefile}}
      str_Write{&*xtra\CliArgs   ,ntui_GetStringByID{*win,"obj_cliargs"  }}
      str_Write{&*xtra\Residents ,ntui_GetStringByID{*win,"obj_residents"}}

      *xtra\MakeSmallest   = ntui_GetValueByID {*win,"obj_makesmallest"  }
      *xtra\FuncOptimize   = ntui_GetValueByID {*win,"obj_funcoptimize"  }
      *xtra\CreateIcon     = ntui_GetValueByID {*win,"obj_createicon"    }
      *xtra\UseDebugger    = ntui_GetValueByID {*win,"obj_runtimedebug"  }
      *xtra\DebugInfo      = ntui_GetValueByID {*win,"obj_debuginfo"     }
      *xtra\CreateDbgFile  = ntui_GetValueByID {*win,"obj_createdbgfile" }
      *xtra\OverflowCheck  = ntui_GetValueByID {*win,"obj_overflowcheck" }
      *xtra\AssemblerCheck = ntui_GetValueByID {*win,"obj_assemblercheck"}
      *xtra\InterruptCheck = ntui_GetValueByID {*win,"obj_interruptcheck"}
      *xtra\AutoRun        = ntui_GetValueByID {*win,"obj_autorun"       }

      *maxobjlist.tuiGroup = (.tuiGroup)ntui_GetObjectByID{*win,"obj_maxobjectlist"}
      If *maxobjlist
        For n.l=0 To 255
          name.s = str_Read{&*xtra\MaxName[n]}
          If name
            id.s = "obj_maxnum_"+name
            *xtra\MaxNum[n] = ntui_GetValueByID{*maxobjlist,id}
          End If
        Next
      End If
   End If

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_ApplySettings,{0}}


AmiBlitz3_OpenSettings:
Statement AmiBlitz3_OpenSettings{docX.l}

  !If_BadDocX_Then{ Statement Return}

  *win.tuiWindow = ntui_GetWindowByID{*ntui,!win_source_settings,docX}
  If *win Then ntui_FreeObject{*win}

  If ntui_ShowWindowByID{*ntui,!win_source_settings,docX}=False

    *win.tuiWindow = ntui_GetWindow{ntui_BuildFromXMLFile{*ntui,dos_AddPart{AIDE\GuiPath,!file_win_source_settings_ab3}}}
    If *win
      ntui_SetAttr{*win,#TUIWA_INSTANCEID,docX}

      *xtra.AmiBlitz3_Xtra = AIDE\Document[docX]\Xtra
      If *xtra
        Format ""
        ntui_SetStringByID{*win,"obj_version_major",Str$(*xtra\MajorVersion)}
        ntui_SetStringByID{*win,"obj_version_minor",Str$(*xtra\MinorVersion)}
        ntui_SetStringByID{*win,"obj_version_patch",Str$(*xtra\PatchVersion)}
        ntui_SetStringByID{*win,"obj_version_build",Str$(*xtra\NumberOfBuilds)}
        ntui_SetStringByID{*win,"obj_stacksize"    ,Str$(*xtra\StackSize)}
        ntui_SetStringByID{*win,"obj_stringbuffer" ,Str$(*xtra\StringBuffer)}

        ntui_SetStringByID{*win,"obj_exefile"  ,dos_AddPart{str_Read{&*xtra\ExePath},str_Read{&*xtra\ExeFile}}}
        ntui_SetStringByID{*win,"obj_cliargs"  ,str_Read{&*xtra\CliArgs  }}
        ntui_SetStringByID{*win,"obj_residents",str_Read{&*xtra\Residents}}

        ntui_SetValueByID {*win,"obj_makesmallest",*xtra\MakeSmallest}
        ntui_SetValueByID {*win,"obj_funcoptimize",*xtra\FuncOptimize}
        ntui_SetValueByID {*win,"obj_createicon"  ,*xtra\CreateIcon}
        ntui_SetValueByID {*win,"obj_runtimedebug",*xtra\UseDebugger}
        ntui_SetValueByID {*win,"obj_debuginfo"   ,*xtra\DebugInfo}

        ntui_SetValueByID {*win,"obj_createdbgfile",*xtra\CreateDbgFile}
        ntui_SetValueByID {*win,"obj_overflowcheck",*xtra\OverflowCheck}
        ntui_SetValueByID {*win,"obj_assemblercheck"  ,*xtra\AssemblerCheck}
        ntui_SetValueByID {*win,"obj_interruptcheck",*xtra\InterruptCheck}
        ntui_SetValueByID {*win,"obj_autorun"   ,*xtra\AutoRun}

        *maxobjlist.tuiGroup = (.tuiGroup)ntui_GetObjectByID{*win,"obj_maxobjectlist"}
        If *maxobjlist
          For n.l=0 To 255
            name.s = str_Read{&*xtra\MaxName[n]}
            If name
              *group.tuiGroup = (.tuiGroup)ntui_BuildFromXMLFile{*maxobjlist,dos_AddPart{AIDE\GuiPath,!file_fragment_maxobj_ab3}}

              If *group
                ntui_SetStringByID{*group,"obj_maxname",name}

                *obj.tuiObject = ntui_GetObjectByID{*group,"obj_maxnum"}
                If *obj
                  num.l = *xtra\MaxNum[n]
                  ntui_SetValue{*obj,num}
                  id.s = "obj_maxnum_"+name
                  ntui_SetAttr{*obj,#TUIA_ID,&id}
                End If

              End If
            End If
          Next
        End If
      End If
    End If
    If ntui_ShowWindowByID{*ntui,!win_source_settings,docX}=False Then error{"\\__THIS_FUNCTION: Unable to open Settings Window!"}
  End If

End Statement
!_MakeGlobalFuncPointer{AmiBlitz3_OpenSettings,{0}}


AmiBlitz3_Init:
Statement AmiBlitz3_Init{docType.l}

  ; Doctype Definitions
  AIDE\DocType[docType]\Pattern       = "#?.(bb|bb2|ab2|ab3)"
  AIDE\DocType[docType]\Name          = "AmiBlitz3"
  AIDE\DocType[docType]\DefIcon       = dos_AddPart{AIDE\GuiPath,"icons/def_amiblitz3.info"}
  
  ; Doctype Methods
  AIDE\DocType[docType]\Deinit        = *AmiBlitz3_Deinit
  AIDE\DocType[docType]\DebugSource   = *AmiBlitz3_DebugSource
  AIDE\DocType[docType]\BuildSource   = *AmiBlitz3_BuildSource
  AIDE\DocType[docType]\ReadPrefs     = *AmiBlitz3_ReadPrefs
  AIDE\DocType[docType]\WritePrefs    = *AmiBlitz3_WritePrefs
  AIDE\DocType[docType]\Import        = *AmiBlitz3_Import
  AIDE\DocType[docType]\Export        = *AmiBlitz3_Export
  AIDE\DocType[docType]\Attach        = *AmiBlitz3_Attach
  AIDE\DocType[docType]\Detach        = *AmiBlitz3_Detach
  AIDE\DocType[docType]\ScanSource    = Null;*AmiBlitz3_ScanSource
  AIDE\DocType[docType]\ScanSourceAsync  = *AmiBlitz3_ScanSourceAsync
  AIDE\DocType[docType]\ScanSourceFinish = *AmiBlitz3_ScanSourceFinish
  AIDE\DocType[docType]\UpdateSDK     = *AmiBlitz3_UpdateSDK
  AIDE\DocType[docType]\JumpTo        = *AmiBlitz3_JumpTo
  AIDE\DocType[docType]\OpenSettings  = *AmiBlitz3_OpenSettings
  AIDE\DocType[docType]\ApplySettings = *AmiBlitz3_ApplySettings

  ; Amiblitz3 Internal Context
  AmiBlitz3\Exe        = "Work:Sourcecodes/AmiBlitz3/AmiBlitz3_Beta"
  AmiBlitz3\AIDEDir    = dos_AddPart{AIDE\DocTypesPath,"AmiBlitz3"}
  AmiBlitz3\Tokens     = Null
  AmiBlitz3\Detokens   = Null
  AmiBlitz3\LTokens    = Null
  AmiBlitz3\TempP      = Null
  AmiBlitz3\DocType    = docType
  AmiBlitz3\IsPrepared = False       ; not yet prepared

End Statement

AmiBlitz3_Init{#DOCTYPE_AMIBLITZ3}

; ===========================================================


