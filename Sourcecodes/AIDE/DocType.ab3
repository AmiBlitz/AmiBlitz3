; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "//AIDE"
; ExeFile         = "AIDE"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.5.0
; NumberOfBuilds  = 1134
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8192
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 1
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 1677
; CursorColumn    = 68
; LabelSearch     = "def"
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 1
; Max GadgetList  = 1
; Max Queue       = 1
; Max Screen      = 2
; Max Shape       = 1
; Max CopList     = 1
; Max Sprite      = 1
; Max Stencil     = 1
; Max Module      = 1
; Max Window      = 30
; Max Anim        = 1
; Max Sound       = 1
; Max Bank        = 1
; Max Buffer      = 1
; Max BitMap      = 1
; Max Slice       = 1
; Max Page        = 1
; Max Tape        = 1
; Max IntuiFont   = 12
; Max MedModule   = 1
; Max Palette     = 1
; Max MenuList    = 1
; Max BlitzFont   = 1
; Max GTList      = 30
; /XTRA
; test if doctype is used
Function.l BaseType_IsAvailable{baseTypeX.l}

  If baseTypeX < 0 OR baseTypeX >= #BASETYPE_MAX Then Function Return False
  Function Return AIDE\BaseType[baseTypeX]\IsAvailable
  
End Function


; test if doctype is used
Function.l DocType_IsAvailable{docTypeX.l}

  If docTypeX < 0 OR docTypeX >= #DOCTYPE_MAX Then Function Return False
  Function Return AIDE\DocType[docTypeX]\IsAvailable
  
End Function


; convert a base type name to id
Function.l BaseType_GetByName{name.s}

  For baseTypeX.l = 0 To #BASETYPE_MAX
    If AIDE\BaseType[baseTypeX]\Name = name
      Function Return baseTypeX
    End If
  Next

  Function Return #BASETYPE_UNDEFINED
  
End Function


Function.s BaseType_GetName{baseTypeX.l}

  !_ASSERT{((baseTypeX >= 0) AND (baseTypeX < #BASETYPE_MAX))}
  Function Return AIDE\BaseType[baseTypeX]\Name
  
End Function


Function.l DocType_OpenDocs{docTypeX.l}

  openDocs.l = 0
  For docX.l = 0 To #DOCUMENT_MAX-1
    If AIDE\Document[docX]\IsUsed
      If AIDE\Document[docX]\DocTypeX = docTypeX Then openDocs+1
    End If
  Next
  
  Function Return openDocs
  
End Function


Statement DocType_Deinit{docTypeX.l}

  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  !_ASSERT{DocType_OpenDocs{docTypeX} = 0}
  !_ASSERT{AIDE\DocType[docTypeX]\Deinit}
  If DocType_IsAvailable{docTypeX} = False Then Statement Return

  !_CallFuncPointer{AIDE\DocType[docTypeX]\Deinit, success.l, docTypeX}
  
End Statement


; init a doctype configuration to the given basetype
Function.l BaseType_InitDocType{baseTypeX.l, docTypeX.l}

  !_ASSERT{((baseTypeX >= 0) AND (baseTypeX < #BASETYPE_MAX))}
  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  !_ASSERT{AIDE\BaseType[baseTypeX]\InitDocType}
  !_ASSERT{DocType_OpenDocs{docTypeX} = 0}
  If BaseType_IsAvailable{baseTypeX} = False Then baseTypeX = #BASETYPE_DEFAULT
  If DocType_IsAvailable{docTypeX}
    DocType_Deinit{docTypeX}
  End If  
  !_CallFuncPointer{AIDE\BaseType[baseTypeX]\InitDocType, success.l, baseTypeX, docTypeX}
  
  Function Return success
  
End Function


Statement BaseType_Unregister{baseTypeX.l}

  !_ASSERT{((baseTypeX >= 0) AND (baseTypeX < #BASETYPE_MAX))}
  !_ASSERT{AIDE\BaseType[baseTypeX]\Unregister}
  If BaseType_IsAvailable{baseTypeX} = False Then Statement Return
  !_CallFuncPointer{AIDE\BaseType[baseTypeX]\Unregister,success.l,baseTypeX}
  
End Statement


; get the icon for a doctype
Function.s DocType_GetDefIcon{docTypeX.l}

  Function Return AIDE\DocType[docTypeX]\DefIcon
  
End Function


; set the parsed DOS pattern for a doctype
Statement DocType_SetPattern{docTypeX.l,pattern.s}

  tempbuffer.s = LSet$(" ",FLen(pattern)*3+7)

  AIDE\DocType[docTypeX]\Pattern_ = pattern
  If ParsePatternNoCase_ (&AIDE\DocType[docTypeX]\Pattern_,&tempbuffer,FLen(tempbuffer))>=0
    AIDE\DocType[docTypeX]\PatternParsed_ = Peek.s(&tempbuffer)
  Else
    AIDE\DocType[docTypeX]\PatternParsed_ = ""
  End If
  
End Statement


; test a file for doctype
Function.l DocType_Examine{filename.s}

  docTypeX.l = #DOCTYPE_DEFAULT
  For n.l=1 To #DOCTYPE_MAX-1
    If DocType_IsAvailable{n}
      If AIDE\DocType[n]\PatternParsed_><""
        If MatchPatternNoCase_ (&AIDE\DocType[n]\PatternParsed_,&filename)
          docTypeX = n
        End If
      End If
    End If
  Next

  Function Return docTypeX

End Function


Function.l DocType_Prepare{docTypeX.l}

  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  !_ASSERT{AIDE\DocType[docTypeX]\Prepare}
  !_CallFuncPointer{AIDE\DocType[docTypeX]\Prepare,success.l,docTypeX}
  Function Return success

End Function


Function.l DocType_Attach{docTypeX.l, docX.l}

  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  !_ASSERT{AIDE\DocType[docTypeX]\Attach}
  If  (AIDE\DocType[docTypeX]\IsPrepared = False) Then DocType_Prepare{docTypeX}
  If  (AIDE\DocType[docTypeX]\IsPrepared = False) Then Function Return False
  !_CallFuncPointer{AIDE\DocType[docTypeX]\Attach,success.l,docTypeX, docX}
  Function Return success
  
End Function


Function.l DocType_Detach{docX.l}

  !_ASSERT{((docX >= 0) AND (docX < #DOCUMENT_MAX))}
  !_ASSERT{AIDE\Document[docX]\IsUsed}
  docTypeX.l  = AIDE\Document[docX]\DocTypeX
  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  !_ASSERT{AIDE\DocType[docTypeX]\Detach}
  !_CallFuncPointer{AIDE\DocType[docTypeX]\Detach, success.l, docTypeX, docX}
  Function Return success

End Function


Function.s DocType_OutputFile{docX.l}

  !_ASSERT{((docX >= 0) AND (docX < #DOCUMENT_MAX))}
  !_ASSERT{AIDE\Document[docX]\IsUsed}
  docTypeX.l  = AIDE\Document[docX]\DocTypeX
  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  !_ASSERT{AIDE\DocType[docTypeX]\OutputFile}
  !_CallFuncPointer{AIDE\DocType[docTypeX]\OutputFile, ptr.l, docTypeX, docX}
  If ptr><Null Then out.s = Peek.s(ptr) : Else out = "T:out"
  Function Return out

End Function


Function.l DocType_GetContext{docTypeX.l}
  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  Function Return AIDE\DocType[docTypeX]\Context
  
End Function


Function.s DocType_GetName{docTypeX.l}
  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  Function Return AIDE\DocType[docTypeX]\Name
  
End Function


Function.l DocType_Import{docX.l, filename.s}

  !_ASSERT{((docX >= 0) AND (docX < #DOCUMENT_MAX))}
  docTypeX.l  = AIDE\Document[docX]\DocTypeX
  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  !_ASSERT{AIDE\DocType[docTypeX]\Import}
  !_CallFuncPointer{AIDE\DocType[docTypeX]\Import, success.l, docTypeX, docX, &filename}
  Function Return success
  
End Function


Function.l DocType_Export{docX.l, filename.s}

  !_ASSERT{((docX >= 0) AND (docX < #DOCUMENT_MAX))}
  docTypeX.l  = AIDE\Document[docX]\DocTypeX  
  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  !_ASSERT{AIDE\DocType[docTypeX]\Export}
  !_CallFuncPointer{AIDE\DocType[docTypeX]\Export, success.l, docTypeX, docX, &filename}
  Function Return success
  
End Function


Statement DocType_ScanSource{docX.l, filename.s}

  !_ASSERT{((docX >= 0) AND (docX < #DOCUMENT_MAX))}
  docTypeX.l  = AIDE\Document[docX]\DocTypeX
  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  
  If filename="" ; this is actually up to the scan functiuon if file is needed
    error{"No file is associated with this document."}
    Statement Return
  End If
  
  If AIDE\DocType[docTypeX]\ScanSourceAsync
    !_CallFuncPointer{AIDE\DocType[docTypeX]\ScanSourceAsync, success.l, docTypeX, docX, &filename}
    Statement Return
  End If

  If AIDE\DocType[docTypeX]\ScanSource
    !_CallFuncPointer{AIDE\DocType[docTypeX]\ScanSource, success.l, docTypeX, docX, &filename}
  End If
    
End Statement


Statement DocType_ScanSourceFinish{docX.l}

  !_ASSERT{((docX >= 0) AND (docX < #DOCUMENT_MAX))}
  docTypeX.l  = AIDE\Document[docX]\DocTypeX
  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  If AIDE\DocType[docTypeX]\ScanSourceFinish = Null Then Statement Return
  !_CallFuncPointer{AIDE\DocType[docTypeX]\ScanSourceFinish, success.l, docTypeX, docX}
  
End Statement


Function.l DocType_ScanSDK{docTypeX.l}

  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  If AIDE\DocType[docTypeX]\ScanSDK = Null Then Function Return False
  !_CallFuncPointer{AIDE\DocType[docTypeX]\ScanSDK, success.l, docTypeX}
  Function Return success
  
End Function


Statement DocType_SourceBrowser{docX.l}

  !_ASSERT{((docX >= 0) AND (docX < #DOCUMENT_MAX))}
  docTypeX.l  = AIDE\Document[docX]\DocTypeX
  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  If AIDE\DocType[docTypeX]\SourceBrowser = Null Then Statement Return
  !_CallFuncPointer{AIDE\DocType[docTypeX]\SourceBrowser, success.l, docTypeX, docX}
  
End Statement


Function.l BaseType_GetFirstDocType{baseTypeX.l}

  docTypeX.l = 0
  While docTypeX < #DOCTYPE_MAX
    If DocType_IsAvailable{docTypeX}
      If (AIDE\DocType[docTypeX]\BaseTypeX = baseTypeX) Then Function Return docTypeX
    End If
    docTypeX+1
  Wend
  Function Return #DOCTYPE_UNDEFINED

End Function

Statement DocType_JumpTo{docX.l, type_.s, name.s, more.s}
  !_ASSERT{((docX >= 0) AND (docX < #DOCUMENT_MAX))}
  docTypeX.l  = AIDE\Document[docX]\DocTypeX
  !_ASSERT{((docTypeX >= 0) AND (docTypeX < #DOCTYPE_MAX))}
  If AIDE\DocType[docTypeX]\JumpTo = Null Then Statement Return
  !_CallFuncPointer{AIDE\DocType[docTypeX]\JumpTo, success.l, docTypeX, docX, &type_.s, &name.s, &more.s}
  
End Statement
