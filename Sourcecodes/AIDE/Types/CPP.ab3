; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Sys:Programme/AIDE"
; ExeFile         = "AIDE"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 0
; Version         = 0.0.0
; NumberOfBuilds  = 517
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 155
; CursorColumn    = 37
; LabelSearch     = "b"
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 1
; Max GadgetList  = 1
; Max Queue       = 1
; Max Screen      = 2
; Max Shape       = 1
; Max CopList     = 1
; Max Sprite      = 1
; Max Stencil     = 1
; Max Module      = 1
; Max Window      = 30
; Max Anim        = 1
; Max Sound       = 1
; Max Bank        = 1
; Max Buffer      = 1
; Max BitMap      = 1
; Max Slice       = 1
; Max Page        = 1
; Max Tape        = 1
; Max IntuiFont   = 12
; Max MedModule   = 1
; Max Palette     = 1
; Max MenuList    = 1
; Max BlitzFont   = 1
; Max GTList      = 30
; /XTRA
; ========================= CPP ====================
#HAS_CPP = 1

#CPPTF_IS        = $0001 ;/* is part of token */
#CPPTF_EOL       = $0002 ;/* end of line */
#CPPTF_NEW       = $0004 ;/* starts a possibly new token */
#CPPTF_STOP      = $0008 ;/* stops a token */
#CPPTF_QUOT      = $0010 ;/* start/end quoting */
#CPPTF_COMMENT   = $0020 ;/* comment */
#CPPTF_COPY      = $0040 ;/* copy over to destination */
#CPPTF_FIRST     = $0080 ;/* can serve as first char in token */
#CPPTF_HEX       = $0100
#CPPTF_BIN       = $0200
#CPPTF_DEC       = $0400
#CPPTF_SPACE     = $0800
#CPPTF_ILLEGAL   = $1000

NEWTYPE.CPP_Xtra ; CPP Xtra Information

  *ExePath.str
  *ExeFile.str

End NEWTYPE


Statement _CPP_InitXtra{*xtra.CPP_Xtra}

  *xtra\ExePath        = Null
  *xtra\ExeFile        = Null

End Statement


Function.CPP_Xtra _CPP_AllocXtra{}

  *xtra.CPP_Xtra = AllocVec_(SizeOf.CPP_Xtra,#MEMF_ANY)
  If *xtra
    _CPP_InitXtra{*xtra.CPP_Xtra}
  End If

  Function Return *xtra

End Function


Statement _CPP_FreeXtra{*xtra.CPP_Xtra}

  If *xtra
    str_Free{&*xtra\ExePath}
    str_Free{&*xtra\ExeFile}
    FreeVec_ *xtra
  End If

End Statement


NEWTYPE.BaseType_CPP

  CharFlags.w[256]    ; character flags
  *TempP.b
  *LineP.b
  AIDEDir.s           ; directory for Amiblitz3 related files
  IsInit.l            ; true if prepare was successfully called

End NEWTYPE

NEWTYPE.DocType_CPP

  *Tokens.hashmap     ; hashmap with tokens => lib/id

End NEWTYPE

SHARED CPP.BaseType_CPP


Function.s MakeGGFilename{filename.s}

  filename = Replace$(filename,"//","/../")
  If Left$(filename,1)="/" Then filename=".."+filename
  Function Return filename

End Function


Function.s MakeAmigaDOSFilename{filename.s}

  filename=Replace$(filename,"../","/")
  filename=Replace$(filename,"./","")
  If Instr(filename,":")<=0 Then filename = dos_AddPart{AIDE\CmdPath,filename}
  Function Return filename

End Function


Function.l FAST _cpp_ParseMultiLineComment{*tline.tline,cpos.l,*incomment.longP}

  opos.l = cpos-2 : If opos<0 Then opos=0 : first.w = False : Else first.w = True
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_ITALIC,1,0}
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_COMMENT,0}
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BGPEN,#TUITBPEN_BG2,0}

  While cpos<*tline\clength
    c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
    If c=@"*"
      c.w = Peek.b(*tline\text+cpos)&$FF
      If c=@"/"
        cpos+1
        If cpos<_tb_vlength{*tline} OR first
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_ITALIC,0,0}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BGPEN,#TUITBPEN_BG,0}
        End If
        *incomment\l = False
        Function Return cpos
      End If
    End If
  Wend

  *incomment\l = True
  Function Return cpos

End Function


Function.l FAST _cpp_ParseComment{*tline.tline,cpos.l}

  opos.l = cpos-2 : If opos<0 Then opos=0
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_ITALIC,1,0}
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_COMMENT,0}
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BGPEN,#TUITBPEN_BG2,0}
  _tb_SetStyleCommand{*tline,*tline\clength-1,#TUITBSC_BGPEN,#TUITBPEN_BG,0}
  Function Return *tline\clength

End Function


Function.l _cpp_ParseEscape{*tline.tline,cpos.l}

  opos.l = cpos-1
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_CONSTANT,0}

  esc.s = ""

  While cpos<*tline\clength
    c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
    esc + Chr$(c)

    If FLen(esc)=3
      If (CPP\CharFlags[Peek.b(&esc+1)&$FF]&#CPPTF_HEX) AND (CPP\CharFlags[Peek.b(&esc+2)&$FF]&#CPPTF_HEX) Then Function Return cpos
    End If

    If FLen(esc)=1
      If (c><@"x") Then Function Return cpos
    End If

    If ((CPP\CharFlags[c]&#CPPTF_IS)=0)
      _tb_SetStyleCommand{*tline,opos,#TUITBSC_WARN,1,#TUIPEN_RED}
      _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_WARN,0}
      Function Return cpos;-1
    End If

  Wend
  Function Return cpos

End Function


Function.l FAST _cpp_ParseString{*tline.tline,cpos.l,terminator.l}
  opos.l = cpos-1
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_STRING,0}

  While cpos<*tline\clength
    c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
    If c=@"\"
      ;c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
      ;If c=@"\"
        cpos = _cpp_ParseEscape{*tline,cpos}
        _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_STRING,0}
      ;End If
    Else
      If c=terminator ;CPP\CharFlags[c]&#CPPTF_QUOT
        _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
        Function Return cpos
      End If
    End If
  Wend
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_WARN,1,#TUIPEN_RED}
  Function Return cpos

End Function




Function.l FAST _cpp_ParseInclude{*tline.tline,cpos.l}
  opos.l = cpos-1
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_STRING,0}

  While cpos<*tline\clength
    c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
    If c=@"\"
      c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
      If c=@"\"
        cpos = _cpp_ParseEscape{*tline,cpos}
        _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_STRING,0}
      End If
    Else
      If c=@">"
        _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
        Function Return cpos
      End If
    End If
  Wend
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_WARN,1,#TUIPEN_RED}
  Function Return cpos

End Function


Function.l FAST _cpp_SkipWhiteSpaces{*tline.tline,cpos.l}

  While cpos<*tline\clength AND CPP\CharFlags[Peek.b(*tline\text + cpos)&$FF]&#CPPTF_SPACE : cpos+1 : Wend
  Function Return cpos

End Function

Function.l FAST _cpp_ToLower{c.l}
  If c>=@"A" AND c<=@"Z" Then Function Return c-@"A"+@"a"
  Function Return c
End Function

Function.l _cpp_ParseToken{*tline.tline,cpos.l,*hm.hashmap,first.l,hash.l}

  If hash=0 Then keyoff.l = 0: Else keyoff=1
  cpos-1
  opos.l = cpos
  Repeat
    If cpos<*tline\clength
      c.w = Peek.b(*tline\text + cpos) & $FF
      cf.l = CPP\CharFlags[c&$FF]
      If (cf&#CPPTF_IS) ; it is a valid token char
        hash = (hash+c)*196314165
      End If
    Else
      cf=0
    End If

    cpos+1

  Until (cf&#CPPTF_IS)=0
  cpos-1

  If *hm
    tptr.l = hashmap_GetItemByHash{*hm,*tline\text+opos,cpos-opos,hash,keyoff}
  End If
  If tptr ; its a token!
    Select Peek.b(tptr)
      Case @"K" ; keyword
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_TOKEN,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Case @"D" ; directive
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_DIRECTIVE,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Case @"T" ; type
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_TYPE,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Case @"V" ; value
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Case @"F" ; function
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_FUNCTION,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Case @"M" ; macro
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_MACRO,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Case @"C" ; constant
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_CONSTANT,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Case @"S" ; string
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_STRING,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Case @"L" ; label
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_LABEL,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Default
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}

    End Select
    ;*tline\flags|#TUITBLF_HOT - #TUITBLF_HOT
  Else
      cpos = _cpp_SkipWhiteSpaces{*tline,cpos}
      c.w = Peek.b(*tline\text + cpos)&$FF
      Select c
        Case @"("
          _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_TOKEN,0}
          ;_tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
          ;_tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}

        Default
          If first
            ;_tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_LABEL,0}
            ;_tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          Else
          ;_tb_SetStyleCommand{*tline,opos ,#TUITBSC_WARN,1,0}
          ;_tb_SetStyleCommand{*tline,cpos ,#TUITBSC_WARN,0,0}
          End If
      End Select
  End If

  Function Return cpos

End Function


Function.l FAST _cpp_SkipToken{*tline.tline,cpos.l}

  cf.l = 0

  While (cf&#CPPTF_STOP)=0 AND cpos<*tline\clength
    cpos+1 : If cpos>=*tline\clength Then Function Return cpos
    cf.l = CPP\CharFlags[Peek.b(*tline\text + cpos)&$FF]
  Wend
  Function Return cpos

End Function


Function.l FAST _cpp_SkipBinary{*tline.tline,cpos.l}

  cf.l = 0

  Repeat
    cpos+1 : If cpos>=*tline\clength Then Function Return cpos
    cf.l = CPP\CharFlags[Peek.b(*tline\text + cpos)&$FF]
    If (cf&#CPPTF_BIN)=0 Then Function Return cpos-1
  Until cpos>=*tline\clength

  Function Return cpos

End Function

Function.l FAST _cpp_SkipHex{*tline.tline,cpos.l}

  Repeat
    If cpos<*tline\clength
      cf.l = CPP\CharFlags[Peek.b(*tline\text + cpos)&$FF]
    Else
      cf = 0
    End If
    cpos+1
  Until (cf&#CPPTF_HEX)=0 OR cpos>=*tline\clength

  Function Return cpos-1

End Function


Function.l FAST _cpp_ParseNumber{*tline.tline,cpos.l}

  opos.l = cpos-1
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}

  Repeat
    If cpos<*tline\clength
      cf.l = CPP\CharFlags[Peek.b(*tline\text + cpos)&$FF]
    Else
      cf = 0
    End If
    cpos+1
  Until (cf&#CPPTF_DEC)=0 OR cpos>=*tline\clength

  If (Peek.b(*tline\text + cpos-1)=@".") ; has a decimal point
    Repeat
      If cpos<*tline\clength
        cf.l = CPP\CharFlags[Peek.b(*tline\text + cpos)&$FF]
      Else
        cf = 0
      End If
      cpos+1
    Until (cf&#CPPTF_DEC)=0 OR cpos>=*tline\clength
  End If

  cpos-1
  _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
  Function Return cpos

End Function


Function.l FAST _cpp_ParseDirective{*tline.tline,cpos.l,*hm.hashmap}
  hash.l = @"#"
  hash * 196314165
  clength.l = *tline\clength
  opos.l = cpos-1
  bptr.l = *tline\text
  first.l = False
  incomment.l = False
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_DIRECTIVE,0}
  While cpos<clength
      c.b = Peek.b(bptr+cpos) : cpos+1
      cf.l = CPP\CharFlags[c&$FF]

      Select c
        Case @"<"
          cpos = _cpp_ParseString{*tline,cpos,@">"}  : first=False
        Case @"/"
          c.b = Peek.b(bptr+cpos)
          Select c
            Case @"/"
              cpos+1
              cpos = _cpp_ParseComment{*tline,cpos}
              first=False
            Case @"*"
              cpos + 1
              cpos = _cpp_ParseMultiLineComment{*tline,cpos,(.longP)&incomment}
          End Select
        Default
          If (cf&#CPPTF_QUOT   ) Then cpos = _cpp_ParseString{*tline,cpos,c}    : first=False
          If (cf&#CPPTF_FIRST  )
            opos.l = cpos-1
            cpos = _cpp_ParseToken{*tline,cpos,*hm,first,hash} : first=False
            If Peeks$(bptr+opos,cpos-opos)="define" Then Function Return cpos
          EndIf
          If (cf&#CPPTF_DEC    ) Then cpos = _cpp_ParseNumber{*tline,cpos}    : first=False
       End Select
  Wend
  Function Return cpos

End Function


_cpp_StyleCallback:
Function.l _cpp_StyleCallback{*textBox.tuiTextBox,lpos.l,*tline.tline}
  If (ntui_GetAttr{*textBox,#TUIA_USERDATA,&docX.l} = False) Then Function Return #TUISCB_DONE
  docTypeX.l = AIDE\Document[docX]\DocTypeX
  *ctx.DocType_CPP = (.DocType_CPP)AIDE\DocType[docTypeX]\Context
  If *ctx
    *hm.hashmap     = *ctx\Tokens
  End If

  incomment.l = False
  If lpos>0
    !line_use{*pline, lpos-1}
    If (*pline\flags&#TUITBLF_STYLED)
       If (*pline\flags&#TUITBLF_INCOMMENT) Then incomment = True
    Else
      ; we should style it first!
      Function Return #TUISCB_PREV
    End If
  End If

  If *tline\text
    *tline\sclength = 0
    tokenlength.l   = 0
    accept.w        = True
    bptr.l          = *tline\text ; base pointer
    clength.l       = *tline\clength ; end pointer
    hash.l          = 0
    cpos.l          = 0
    first.w         = True
    If incomment
      cpos = _cpp_ParseMultiLineComment{*tline,cpos,(.longP)&incomment}
    End If

    While cpos<clength
      c.b = Peek.b(bptr+cpos) : cpos+1
      cf.l = CPP\CharFlags[c&$FF]

      Select c
        Case @";" : first=True

        Case @"#" :
          _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_DIRECTIVE,0}
          cpos = _cpp_ParseDirective{*tline,cpos,*hm}

          ;opos.l = cpos
          ;cpos = _cpp_SkipWhiteSpaces{*tline,cpos}
          ;hash.l = @"#"
          ;hash * 196314165
          ;cpos = _cpp_ParseToken{*tline,cpos+1,*hm,first,hash} : cf = 0 : c=0 : first=False
          ;If cpos<=opos Then cpos = opos+1
          ;_tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}

        Case @"."
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_MEMBER,0}
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_ITALIC,1}
          cpos = _cpp_SkipToken{*tline,cpos}
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_ITALIC,0}
          first=False

        Case @"-"
          c.b = Peek.b(bptr+cpos)
          cf.l = CPP\CharFlags[c&$FF]
          Select c
            Case @">"
              cpos+1
              _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_MEMBER,0}
              _tb_SetStyleCommand{*tline,cpos,#TUITBSC_ITALIC,1}
              cpos = _cpp_SkipToken{*tline,cpos}
              _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
              _tb_SetStyleCommand{*tline,cpos,#TUITBSC_ITALIC,0}
              first=False
          End Select

        Case @"/"
          c.b = Peek.b(bptr+cpos)
          Select c
            Case @"/"
              cpos+1
              cpos = _cpp_ParseComment{*tline,cpos}
              first=False
            Case @"*"
              cpos + 1
              cpos = _cpp_ParseMultiLineComment{*tline,cpos,(.longP)&incomment}
          End Select

        Case @"0"
          c.b = Peek.b(bptr+cpos)
          Select c
            Case @"x"
              _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
              cpos = _cpp_SkipHex{*tline,cpos+1}
              _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
              first=False
            Default
              cpos = _cpp_ParseNumber{*tline,cpos-1}    : cf = 0 : c=0 : first=False

          End Select
          first=False

        Default
          If (cf&#CPPTF_QUOT   ) Then cpos = _cpp_ParseString{*tline,cpos,c}    : first=False
          If (cf&#CPPTF_FIRST  ) Then cpos = _cpp_ParseToken{*tline,cpos,*hm,first,0} : first=False
          If (cf&#CPPTF_DEC    ) Then cpos = _cpp_ParseNumber{*tline,cpos}    : first=False

      End Select

    Wend

    *tline\flags|#TUITBLF_STYLED
    oflags.l = *tline\flags
    If incomment Then *tline\flags|#TUITBLF_INCOMMENT : Else *tline\flags|#TUITBLF_INCOMMENT - #TUITBLF_INCOMMENT
    If ((*tline\flags&#TUITBLF_INCOMMENT) >< (oflags&#TUITBLF_INCOMMENT)) Then Function Return #TUISCB_NEXT
  End If
  Function Return #TUISCB_DONE

End Function
!_MakeGlobalFuncPointer{_cpp_StyleCallback,{Null,0,Null}}

CPP_Prepare:
Function.l CPP_Prepare{docTypeX.l}

  *ctx.DocType_CPP = (.DocType_CPP)AIDE\DocType[docTypeX]\Context

  name.s = DocType_GetName{docTypeX}
  name.s = DocType_Name2File{name}
  tokenfile.s    = dos_AddPart{CPP\AIDEDir,name + ".txt"}
  hashmapfile.s  = dos_AddPart{CPP\AIDEDir,name + ".hash"}
  If CPP\TempP = Null
    CPP\TempP = AllocVec_(1024,#MEMF_ANY)
  End If
  !_ASSERT{CPP\TempP}
  If dos_Exist{hashmapfile}
    *ctx\Tokens = hashmap_Load{hashmapfile}
  End If

  If *ctx\Tokens = Null
    *hm.hashmap = hashmap_Create{14}
    If *hm
      fid.l = file_Open{tokenfile,#file_read}
      If fid>=0
        While file_EOF{fid}=False
          a.s = file_ReadLineF{fid}
          t.s = UCase$(lindex{a,0})
          If t
            name.s = lindex{a,1}
            help.s = Right$(a , FLen(a) - Instr(a,name)-FLen(name)-1)
            tokenS.s = t+";"+help
            hashmap_AddItem{*hm,name,tokenS}
            lname.s  = LCase$(name)
            If name><lname
              hashmap_AddItem{*hm,lname,tokenS}
            End If
          End If
        Wend
        file_Close{fid}
        *ctx\Tokens  = *hm
        hashmap_Save{*ctx\Tokens,hashmapfile}
      End If
    End If
  End If

  If CPP\IsInit Then Function Return Default_Prepare{docTypeX}

  For n.l=0 To 255
    CPP\CharFlags[n] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW
  Next

  CPP\CharFlags[   0] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_EOL ; Null
  CPP\CharFlags[   1] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; SOH
  CPP\CharFlags[   2] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; STX
  CPP\CharFlags[   3] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; ETX
  CPP\CharFlags[   4] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; EOT
  CPP\CharFlags[   5] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; ENQ
  CPP\CharFlags[   6] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; ACK
  CPP\CharFlags[   7] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; BELL
  CPP\CharFlags[   8] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; BS  (backspace)
  CPP\CharFlags[   9] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW|#CPPTF_SPACE ; TAB (tabulator)
  CPP\CharFlags[  10] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW|#CPPTF_EOL ; LF  (line feed) Linux Return
  CPP\CharFlags[  11] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; VT
  CPP\CharFlags[  12] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; FF  (feed forward)
  CPP\CharFlags[  13] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; CR  (carrier return) Windows Return
  CPP\CharFlags[  14] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; SO
  CPP\CharFlags[  15] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; SI
  CPP\CharFlags[  16] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; DLE
  CPP\CharFlags[  17] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; DC1
  CPP\CharFlags[  18] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; CD2
  CPP\CharFlags[  19] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; CD3
  CPP\CharFlags[  20] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; CD4
  CPP\CharFlags[  21] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; NAK
  CPP\CharFlags[  22] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; SYN
  CPP\CharFlags[  23] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; ETB
  CPP\CharFlags[  24] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; CAN (Cancel)
  CPP\CharFlags[  25] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; EM
  CPP\CharFlags[  26] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; SUB
  CPP\CharFlags[  27] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; ESC (Escape)
  CPP\CharFlags[  28] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; FS
  CPP\CharFlags[  29] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; GS
  CPP\CharFlags[  30] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; RS
  CPP\CharFlags[  31] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; US
  CPP\CharFlags[@" "] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY|#CPPTF_SPACE ; Space
  CPP\CharFlags[@"!"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[  34] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY|#CPPTF_QUOT
  CPP\CharFlags[@"#"] = #CPPTF_STOP | #CPPTF_IS   | #CPPTF_COPY;|#CPPTF_FIRST
  CPP\CharFlags[@"$"] = #CPPTF_STOP | #CPPTF_IS   | #CPPTF_COPY
  CPP\CharFlags[@"%"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"&"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"'"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY | #CPPTF_QUOT
  CPP\CharFlags[@"("] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@")"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"*"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"+"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@","] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"-"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"."] = #CPPTF_STOP | #CPPTF_COPY
  CPP\CharFlags[@"/"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"0"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_BIN |#CPPTF_HEX|#CPPTF_DEC
  CPP\CharFlags[@"1"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_BIN |#CPPTF_HEX|#CPPTF_DEC
  CPP\CharFlags[@"2"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"3"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"4"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"5"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"6"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"7"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"8"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"9"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@":"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@";"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COMMENT|#CPPTF_COPY
  CPP\CharFlags[@"<"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"="] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@">"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"?"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"@"] = #CPPTF_STOP | #CPPTF_COPY
  CPP\CharFlags[@"A"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY|#CPPTF_HEX
  CPP\CharFlags[@"B"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY|#CPPTF_HEX
  CPP\CharFlags[@"C"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY|#CPPTF_HEX
  CPP\CharFlags[@"D"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY|#CPPTF_HEX
  CPP\CharFlags[@"E"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY|#CPPTF_HEX
  CPP\CharFlags[@"F"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY|#CPPTF_HEX
  CPP\CharFlags[@"G"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"H"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"I"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"J"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"K"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"L"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"M"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"N"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"O"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"P"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"Q"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"R"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"S"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"T"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"U"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"V"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"W"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"X"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"Y"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"Z"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"["] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"\"] = #CPPTF_STOP | #CPPTF_COPY
  CPP\CharFlags[@"]"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"^"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"_"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"`"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"a"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY | #CPPTF_HEX
  CPP\CharFlags[@"b"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY | #CPPTF_HEX
  CPP\CharFlags[@"c"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY | #CPPTF_HEX
  CPP\CharFlags[@"d"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY | #CPPTF_HEX
  CPP\CharFlags[@"e"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY | #CPPTF_HEX
  CPP\CharFlags[@"f"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY | #CPPTF_HEX
  CPP\CharFlags[@"g"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"h"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"i"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"j"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"k"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"l"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"m"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"n"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"o"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"p"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"q"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"r"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"s"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"t"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"u"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"v"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"w"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"x"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"y"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"z"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"{"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"|"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"}"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"~"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[ 127] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW

  CPP\IsInit=True

  Function Return Default_Prepare{docTypeX}

End Function
!_MakeGlobalFuncPointer{CPP_Prepare,{0}}


CPP_Unregister:
Statement CPP_Unregister{baseTypeX.l}

  If CPP\TempP  Then FreeVec_ CPP\TempP  : FreeVec_ CPP\TempP = Null
  CPP\IsInit = False

End Statement
!_MakeGlobalFuncPointer{CPP_Unregister,{0}}


CPP_Attach:
Function.l CPP_Attach{docTypeX.l, docX.l}

  !_ASSERT{AIDE\DocType[docTypeX]\IsAvailable}
  !_ASSERT{AIDE\DocType[docTypeX]\IsPrepared}
  AIDE\Document[docX]\Xtra = _CPP_AllocXtra{}
  Function Return Default_Attach{docTypeX, docX}

End Function
!_MakeGlobalFuncPointer{CPP_Attach,{0, 0}}


CPP_Detach:
Function.l CPP_Detach{docTypeX.l, docX.l}

  If AIDE\Document[docX]\Xtra Then _CPP_FreeXtra{(.CPP_Xtra)AIDE\Document[docX]\Xtra}
  AIDE\Document[docX]\Xtra = Null

  Function Return Default_Detach{docTypeX, docX}

End Function
!_MakeGlobalFuncPointer{CPP_Detach,{0,0}}


CPP_Deinit:
Statement CPP_Deinit{docTypeX.l}

  If (AIDE\DocType[docTypeX]\Context)
    *ctx.DocType_CPP = (.DocType_CPP)AIDE\DocType[docTypeX]\Context
    If *ctx\Tokens Then hashmap_Free{*ctx\Tokens} : *ctx\Tokens = Null
    FreeVec_ AIDE\DocType[docTypeX]\Context
    AIDE\DocType[docTypeX]\Context = Null
  End If
  Default_Deinit{docTypeX}

End Statement
!_MakeGlobalFuncPointer{CPP_Deinit,{0}}


CPP_InitDocType:
Function.l CPP_InitDocType{baseTypeX.l, docTypeX.l}

  If NOT(Default_InitDocType{baseTypeX, docTypeX}) Then Function Return False
  DocType_SetPattern{docTypeX, "#?.(c|cpp|h|hpp)"}
  AIDE\DocType[docTypeX]\Name          = "C/C++"
  AIDE\DocType[docTypeX]\DefIcon       = "Icons/def_c.info"
  AIDE\DocType[docTypeX]\Attach        = *CPP_Attach
  AIDE\DocType[docTypeX]\Detach        = *CPP_Detach
  AIDE\DocType[docTypeX]\Deinit        = *CPP_Deinit
  AIDE\DocType[docTypeX]\Prepare       = *CPP_Prepare
  AIDE\DocType[docTypeX]\StyleCallback = *_cpp_StyleCallback
  AIDE\DocType[docTypeX]\Context       = AllocVec_(SizeOf.DocType_CPP, #MEMF_CLEAR)
  !_ASSERT{AIDE\DocType[docTypeX]\Context}
  Function Return True

End Function
!_MakeGlobalFuncPointer{CPP_InitDocType,{0,0}}

;/* event handler function */
CPP_HandleNotify:
Function.l CPP_HandleNotify{*notify.tuiNotify}

  Select ntui_GetNotifyID{*notify}
    Case !ev_console_click
      textP.l = 0
      ntui_GetAttrByID{*ntui,!obj_main_console,#TUITBA_CURSORLINE,&textP}
      ntui_GetAttrByID{*ntui,!obj_main_console,#TUITBA_LINE,&textP}
      If textP
        text.s = Peek.s(textP)
        find.s = ".c:" : pos.l = Instr(text,find)
        If pos<=0 Then find=".h:"   : pos = Instr(text,find)
        If pos<=0 Then find=".cpp:" : pos = Instr(text,find)
        If pos<=0 Then find=".hpp:" : pos = Instr(text,find)
        If pos>0
          pos + FLen(find)
          filename.s = Left$(text,pos-2)
          npos.l = Instr(text,":",pos)
          If npos>=0
            lposstr.s = Mid$(text,pos,npos-pos)
            lpos.l = Vallong(lposstr)-1
          Else
            lpos = 0
          End If
          filename=MakeAmigaDOSFilename{filename}
          ;error{"filename="+filename+" lpos="+Str$(lpos)}
          docX.l = Document_Open{filename}
          Document_JumpTo{docX,lpos,True}
          Function Return True
        EndIf
      End If
      Function Return False ; not interested...

    Default:
      Function Return False ; not interested...

  End Select
  Function Return True

End Function
!_MakeGlobalFuncPointer{CPP_HandleNotify,{Null}}


Statement CPP_Register{baseTypeX.l}

  AIDE\BaseType[baseTypeX]\Name = "C/C++"
  AIDE\BaseType[baseTypeX]\IsAvailable = True
  AIDE\BaseType[baseTypeX]\InitDocType = *CPP_InitDocType
  AIDE\BaseType[baseTypeX]\Unregister = *CPP_Unregister

  CPP\AIDEDir = dos_AddPart{AIDE\TypesPath,"CPP"}
  CPP\TempP   = Null
  CPP\IsInit  = False       ; not yet prepared

End Statement

CPP_Register{#BASETYPE_CPP}
InstallNotifyHandler{"CPP", *CPP_HandleNotify}

; ===========================================================
