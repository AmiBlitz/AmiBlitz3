; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Sys:Programme/AIDE"
; ExeFile         = "AIDE"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 0
; Version         = 0.0.0
; NumberOfBuilds  = 517
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 155
; CursorColumn    = 37
; LabelSearch     = "b"
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 1
; Max GadgetList  = 1
; Max Queue       = 1
; Max Screen      = 2
; Max Shape       = 1
; Max CopList     = 1
; Max Sprite      = 1
; Max Stencil     = 1
; Max Module      = 1
; Max Window      = 30
; Max Anim        = 1
; Max Sound       = 1
; Max Bank        = 1
; Max Buffer      = 1
; Max BitMap      = 1
; Max Slice       = 1
; Max Page        = 1
; Max Tape        = 1
; Max IntuiFont   = 12
; Max MedModule   = 1
; Max Palette     = 1
; Max MenuList    = 1
; Max BlitzFont   = 1
; Max GTList      = 30
; /XTRA

; ========================= CPP ====================
#HAS_CPP = 1

#CPPTF_IS        = $0001 ;/* is part of token */
#CPPTF_EOL       = $0002 ;/* end of line */
#CPPTF_NEW       = $0004 ;/* starts a possibly new token */
#CPPTF_STOP      = $0008 ;/* stops a token */
#CPPTF_QUOT      = $0010 ;/* start/end quoting */
#CPPTF_COMMENT   = $0020 ;/* comment */
#CPPTF_COPY      = $0040 ;/* copy over to destination */
#CPPTF_FIRST     = $0080 ;/* can serve as first char in token */
#CPPTF_HEX       = $0100
#CPPTF_BIN       = $0200
#CPPTF_DEC       = $0400
#CPPTF_SPACE     = $0800
#CPPTF_ILLEGAL   = $1000

NEWTYPE.CPP_Xtra ; CPP Xtra Information

  *ExePath.str
  *ExeFile.str

End NEWTYPE

Statement _CPP_InitXtra{*xtra.CPP_Xtra}

  *xtra\ExePath        = Null
  *xtra\ExeFile        = Null

End Statement

Function.CPP_Xtra _CPP_AllocXtra{}

  *xtra.CPP_Xtra = AllocVec_(SizeOf.CPP_Xtra,#MEMF_ANY)
  If *xtra
    _CPP_InitXtra{*xtra.CPP_Xtra}
  End If

  Function Return *xtra

End Function

Statement _CPP_FreeXtra{*xtra.CPP_Xtra}

  If *xtra
    str_Free{&*xtra\ExePath}
    str_Free{&*xtra\ExeFile}
    FreeVec_ *xtra
  End If

End Statement

NEWTYPE.DocType_CPP

  CharFlags.w[256]    ; character flags
  *Tokens.hashmap     ; hashmap with tokens => lib/id
  *TempP.b
  *LineP.b
  AIDEDir.s           ; directory for Amiblitz3 related files
  Exe.s               ; executalbe of Amiblitz3
  BuildSourceArgs.s   ; command to launch CPPs
  DebugProjectArgs.s  ; command to launch CPPs
  BuildProjectArgs.s  ; command to launch CPPs
  ;BuildArgs.s
  DocType.l           ; docType ID
  IsPrepared.l        ; true if prepare was successfully called

End NEWTYPE
SHARED CPP.DocType_CPP

Function.s MakeGGFilename{filename.s}

  filename = Replace$(filename,"//","/../")
  If Left$(filename,1)="/" Then filename=".."+filename
  Function Return filename
  
End Function


Function.s MakeAmigaDOSFilename{filename.s}

  filename=Replace$(filename,"../","/")
  filename=Replace$(filename,"./","")
  If Instr(filename,":")<=0 Then filename = dos_AddPart{AIDE\BuildPath,filename}
  Function Return filename
  
End Function

CPP_ReadPrefs:
Statement CPP_ReadPrefs{*iconP.b}

  icon.s               = Peek.s(*iconP)
  CPP\Exe              = dos_GetToolString{"CPP_Exe"              ,"GG:bin/sh"     ,icon}
  CPP\DebugProjectArgs = dos_GetToolString{"CPP_DebugProjectArgs" ,"%f -g -o %o"    ,icon}
  CPP\BuildProjectArgs = dos_GetToolString{"CPP_BuildProjectArgs" ,"%f -o %o"       ,icon}
  CPP\BuildSourceArgs  = dos_GetToolString{"CPP_BuildSourceArgs"  ,"-c \\22gcc 2>&1 %f -c -I ./\\22",icon}

End Statement
!_MakeGlobalFuncPointer{CPP_ReadPrefs,{Null}}


CPP_WritePrefs:
Statement CPP_WritePrefs{*iconP.b}

  icon.s = Peek.s(*iconP)
  dos_SetToolString{"CPP_Exe"                ,CPP\Exe ,icon}
  dos_SetToolString{"CPP_DebugProjectArgs"   ,CPP\DebugProjectArgs,icon}
  dos_SetToolString{"CPP_BuildProjectArgs"   ,CPP\BuildProjectArgs,icon}
  dos_SetToolString{"CPP_BuildSourceArgs"    ,CPP\BuildSourceArgs,icon}

End Statement
!_MakeGlobalFuncPointer{CPP_WritePrefs,{Null}}


Statement _CPP_CompileAndRun{args.s, path.s}

  *con.tuiTextBox = (.tuiTextBox)ntui_GetObjectByID{*ntui,!obj_main_console}
  If *con
    pipefile.s = "Pipe:"+Hex$(FindTask_(0))
    txt.s = "\\1B[33m\\1B[1mCPP >>>\\n"
    ntui_SetAttr{*con,#TUITBA_TEXT,&txt}
    fh.l = Open_(&pipefile,#MODE_NEWFILE)
    If fh=0
      msg.s = "\\1B[33m\\1B[1mUnable to open "+pipefile+"!\\n"
      ntui_SetAttr{*con, #TUITBA_APPENDTEXT,&msg}
    Else
      ntui_SetTextBoxFileListener{*con,&pipefile}
    End If

    msg.s = CPP\Exe+" "+args+"\\n"
    ntui_SetAttr{*con, #TUITBA_APPENDTEXT,&msg}
    
    If path Then tmplock.l = Lock_(&path,#ACCESS_READ):Else tmplock=0
    If tmplock
      oldlock.l = CurrentDir_ (tmplock)
    Else
      oldlock=-1
    End If
    AIDE\BuildPath = path
    AIDE\BuildArgs = args
    AIDE\BuildExe  = CPP\Exe
    ret.l = dos_RunCli{CPP\Exe,-1,32768,False,args,-1,fh}
    
    If oldlock><-1 Then CurrentDir_ oldlock
    If tmplock><0  Then UnLock_ tmplock

    If ret><0
      msg.s = "\\1B[33m\\1B[1mFailed with #"+Str$(ret)+"\\n"
      ntui_SetAttr{*con, #TUITBA_APPENDTEXT,&msg}
    End If
  End If

End Statement


CPP_DebugProject:
Statement CPP_DebugProject{*filenameP.b}

  filename.s = Peek.s(*filenameP)
  filename =  MakeGGFilename{filename}
  args.s   = CPP\DebugProjectArgs
  args     = Replace$(args,"%f",filename)
  path.s   = dos_PathPart{filename}
  _CPP_CompileAndRun{args,path}

End Statement
!_MakeGlobalFuncPointer{CPP_DebugProject,{Null}}


CPP_BuildSource:
Statement CPP_BuildSource{docX.l,*filenameP.b}

  filename.s = Peek.s(*filenameP)
  filename =  MakeGGFilename{filename}
  args.s   = CPP\BuildSourceArgs
  args     = Replace$(args,"%f",filename)
  path.s   = dos_PathPart{filename}
  _CPP_CompileAndRun{args,path}

End Statement
!_MakeGlobalFuncPointer{CPP_BuildSource,{0,Null}}


CPP_BuildProject:
Statement CPP_BuildProject{*filenameP.b}

  filename.s = Peek.s(*filenameP)
  filename =  MakeGGFilename{filename}
  args.s   = CPP\BuildProjectArgs
  args     = Replace$(args,"%f",filename)
  path.s   = dos_PathPart{filename}
  _CPP_CompileAndRun{args,path}

End Statement
!_MakeGlobalFuncPointer{CPP_BuildProject,{Null}}


Function.l FAST _cpp_ParseMultiLineComment{*tline.tline,cpos.l,*incomment.longP}

  opos.l = cpos-2 : If opos<0 Then opos=0 : first.w = False : Else first.w = True
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_ITALIC,1,0}
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_COMMENT,0}
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BGPEN,#TUITBPEN_BG2,0}

  While cpos<*tline\clength
    c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
    If c=@"*"
      c.w = Peek.b(*tline\text+cpos)&$FF
      If c=@"/"
        cpos+1
        If cpos<_tb_vlength{*tline} OR first
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_ITALIC,0,0}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BGPEN,#TUITBPEN_BG,0}
        End If
        *incomment\l = False
        Function Return cpos
      End If
    End If
  Wend

  *incomment\l = True
  Function Return cpos

End Function


Function.l FAST _cpp_ParseComment{*tline.tline,cpos.l}

  opos.l = cpos-2 : If opos<0 Then opos=0
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_ITALIC,1,0}
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_COMMENT,0}
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BGPEN,#TUITBPEN_BG2,0}
  _tb_SetStyleCommand{*tline,*tline\clength-1,#TUITBSC_BGPEN,#TUITBPEN_BG,0}
  Function Return *tline\clength

End Function


Function.l _cpp_ParseEscape{*tline.tline,cpos.l}

  opos.l = cpos-1
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_CONSTANT,0}

  esc.s = ""

  While cpos<*tline\clength
    c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
    esc + Chr$(c)

    If FLen(esc)=3
      If (CPP\CharFlags[Peek.b(&esc+1)&$FF]&#CPPTF_HEX) AND (CPP\CharFlags[Peek.b(&esc+2)&$FF]&#CPPTF_HEX) Then Function Return cpos
    End If

    If FLen(esc)=1
      If (c><@"x") Then Function Return cpos
    End If

    If ((CPP\CharFlags[c]&#CPPTF_IS)=0)
      _tb_SetStyleCommand{*tline,opos,#TUITBSC_WARN,1,#TUIPEN_RED}
      _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_WARN,0}
      Function Return cpos;-1
    End If

  Wend
  Function Return cpos

End Function


Function.l FAST _cpp_ParseString{*tline.tline,cpos.l,terminator.l}
  opos.l = cpos-1
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_STRING,0}

  While cpos<*tline\clength
    c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
    If c=@"\"
      ;c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
      ;If c=@"\"
        cpos = _cpp_ParseEscape{*tline,cpos}
        _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_STRING,0}
      ;End If
    Else
      If c=terminator ;CPP\CharFlags[c]&#CPPTF_QUOT
        _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
        Function Return cpos
      End If
    End If
  Wend
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_WARN,1,#TUIPEN_RED}
  Function Return cpos

End Function




Function.l FAST _cpp_ParseInclude{*tline.tline,cpos.l}
  opos.l = cpos-1
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_STRING,0}

  While cpos<*tline\clength
    c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
    If c=@"\"
      c.w = Peek.b(*tline\text+cpos)&$FF : cpos+1
      If c=@"\"
        cpos = _cpp_ParseEscape{*tline,cpos}
        _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_STRING,0}
      End If
    Else
      If c=@">"
        _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
        Function Return cpos
      End If
    End If
  Wend
  _tb_SetStyleCommand{*tline,opos ,#TUITBSC_WARN,1,#TUIPEN_RED}
  Function Return cpos

End Function


Function.l FAST _cpp_SkipWhiteSpaces{*tline.tline,cpos.l}

  While cpos<*tline\clength AND CPP\CharFlags[Peek.b(*tline\text + cpos)&$FF]&#CPPTF_SPACE : cpos+1 : Wend
  Function Return cpos

End Function

Function.l FAST _cpp_ToLower{c.l}
  If c>=@"A" AND c<=@"Z" Then Function Return c-@"A"+@"a"
  Function Return c
End Function

Function.l _cpp_ParseToken{*tline.tline,cpos.l,*hm.hashmap,first.l,hash.l}

  If hash=0 Then keyoff.l = 0: Else keyoff=1
  cpos-1
  opos.l = cpos
  Repeat
    If cpos<*tline\clength
      c.w = Peek.b(*tline\text + cpos) & $FF
      cf.l = CPP\CharFlags[c&$FF]
      If (cf&#CPPTF_IS) ; it is a valid token char
        hash = (hash+c)*196314165
      End If
    Else
      cf=0
    End If

    cpos+1

  Until (cf&#CPPTF_IS)=0
  cpos-1

  tptr.l = hashmap_GetItemByHash{*hm,*tline\text+opos,cpos-opos,hash,keyoff}
  If tptr ; its a token!
    Select Peek.b(tptr)
      Case @"K" ; keyword
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_TOKEN,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Case @"D" ; directive
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_DIRECTIVE,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Case @"T" ; type
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_TYPE,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Case @"V" ; value
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
      Default
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
        _tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}

    End Select
    ;*tline\flags|#TUITBLF_HOT - #TUITBLF_HOT
  Else
      cpos = _cpp_SkipWhiteSpaces{*tline,cpos}
      c.w = Peek.b(*tline\text + cpos)&$FF
      Select c
        Case @"("
          _tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_TOKEN,0}
          ;_tb_SetStyleCommand{*tline,opos ,#TUITBSC_BOLD,1,0}
          ;_tb_SetStyleCommand{*tline,cpos ,#TUITBSC_BOLD,0,0}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}

        Default
          If first
            ;_tb_SetStyleCommand{*tline,opos ,#TUITBSC_FGPEN,#TUITBPEN_LABEL,0}
            ;_tb_SetStyleCommand{*tline,cpos ,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          Else
          ;_tb_SetStyleCommand{*tline,opos ,#TUITBSC_WARN,1,0}
          ;_tb_SetStyleCommand{*tline,cpos ,#TUITBSC_WARN,0,0}
          End If
      End Select
  End If

  Function Return cpos

End Function


Function.l FAST _cpp_SkipToken{*tline.tline,cpos.l}

  cf.l = 0

  While (cf&#CPPTF_STOP)=0 AND cpos<*tline\clength
    cpos+1 : If cpos>=*tline\clength Then Function Return cpos
    cf.l = CPP\CharFlags[Peek.b(*tline\text + cpos)&$FF]
  Wend
  Function Return cpos

End Function


Function.l FAST _cpp_SkipBinary{*tline.tline,cpos.l}

  cf.l = 0

  Repeat
    cpos+1 : If cpos>=*tline\clength Then Function Return cpos
    cf.l = CPP\CharFlags[Peek.b(*tline\text + cpos)&$FF]
    If (cf&#CPPTF_BIN)=0 Then Function Return cpos-1
  Until cpos>=*tline\clength

  Function Return cpos

End Function

Function.l FAST _cpp_SkipHex{*tline.tline,cpos.l}

  Repeat
    If cpos<*tline\clength
      cf.l = CPP\CharFlags[Peek.b(*tline\text + cpos)&$FF]
    Else
      cf = 0
    End If
    cpos+1
  Until (cf&#CPPTF_HEX)=0 OR cpos>=*tline\clength

  Function Return cpos-1

End Function


Function.l FAST _cpp_ParseNumber{*tline.tline,cpos.l}

  opos.l = cpos-1
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}

  Repeat
    If cpos<*tline\clength
      cf.l = CPP\CharFlags[Peek.b(*tline\text + cpos)&$FF]
    Else
      cf = 0
    End If
    cpos+1
  Until (cf&#CPPTF_DEC)=0 OR cpos>=*tline\clength

  If (Peek.b(*tline\text + cpos-1)=@".") ; has a decimal point
    Repeat
      If cpos<*tline\clength
        cf.l = CPP\CharFlags[Peek.b(*tline\text + cpos)&$FF]
      Else
        cf = 0
      End If
      cpos+1
    Until (cf&#CPPTF_DEC)=0 OR cpos>=*tline\clength
  End If

  cpos-1
  _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
  Function Return cpos

End Function


Function.l FAST _cpp_ParseDirective{*tline.tline,cpos.l,*hm.hashmap}
  hash.l = @"#"
  hash * 196314165
  clength.l = *tline\clength
  opos.l = cpos-1
  bptr.l = *tline\text
  first.l = False
  incomment.l = False
  _tb_SetStyleCommand{*tline,opos,#TUITBSC_FGPEN,#TUITBPEN_DIRECTIVE,0}
  While cpos<clength
      c.b = Peek.b(bptr+cpos) : cpos+1
      cf.l = CPP\CharFlags[c&$FF]

      Select c
        Case @"<"
          cpos = _cpp_ParseString{*tline,cpos,@">"}  : first=False
        Case @"/"
          c.b = Peek.b(bptr+cpos)
          Select c
            Case @"/"
              cpos+1
              cpos = _cpp_ParseComment{*tline,cpos}
              first=False
            Case @"*"
              cpos + 1
              cpos = _cpp_ParseMultiLineComment{*tline,cpos,(.longP)&incomment}
          End Select
        Default
          If (cf&#CPPTF_QUOT   ) Then cpos = _cpp_ParseString{*tline,cpos,c}    : first=False
          If (cf&#CPPTF_FIRST  ) 
            opos.l = cpos-1
            cpos = _cpp_ParseToken{*tline,cpos,*hm,first,hash} : first=False
            If Peeks$(bptr+opos,cpos-opos)="define" Then Function Return cpos
          EndIf
          If (cf&#CPPTF_DEC    ) Then cpos = _cpp_ParseNumber{*tline,cpos}    : first=False
       End Select
  Wend
  Function Return cpos

End Function




_cpp_StyleCallback:
Function.l _cpp_StyleCallback{*textBox.tuiTextBox,lpos.l,*tline.tline}

  incomment.l = False
  If lpos>0
    !line_use{*pline, lpos-1}
    If (*pline\flags&#TUITBLF_STYLED)
       If (*pline\flags&#TUITBLF_INCOMMENT) Then incomment = True
    Else
      ; we should style it first!
      Function Return #TUISCB_PREV
    End If
  End If

  If *tline\text
    *tline\sclength = 0
    tokenlength.l   = 0
    accept.w        = True
    bptr.l          = *tline\text ; base pointer
    clength.l       = *tline\clength ; end pointer
    hash.l          = 0
    cpos.l          = 0
    first.w         = True
    *hm.hashmap     = CPP\Tokens
    If incomment
      cpos = _cpp_ParseMultiLineComment{*tline,cpos,(.longP)&incomment}
    End If

    While cpos<clength
      c.b = Peek.b(bptr+cpos) : cpos+1
      cf.l = CPP\CharFlags[c&$FF]

      Select c
        Case @";" : first=True

        Case @"#" :
          _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_DIRECTIVE,0}
          cpos = _cpp_ParseDirective{*tline,cpos,*hm}
          
          ;opos.l = cpos
          ;cpos = _cpp_SkipWhiteSpaces{*tline,cpos}
          ;hash.l = @"#"
          ;hash * 196314165
          ;cpos = _cpp_ParseToken{*tline,cpos+1,*hm,first,hash} : cf = 0 : c=0 : first=False
          ;If cpos<=opos Then cpos = opos+1
          ;_tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}

        Case @"."
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_MEMBER,0}
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_ITALIC,1}
          cpos = _cpp_SkipToken{*tline,cpos}
          _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
          _tb_SetStyleCommand{*tline,cpos ,#TUITBSC_ITALIC,0}
          first=False

        Case @"-"
          c.b = Peek.b(bptr+cpos)
          cf.l = CPP\CharFlags[c&$FF]
          Select c
            Case @">"
              cpos+1
              _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_MEMBER,0}
              _tb_SetStyleCommand{*tline,cpos,#TUITBSC_ITALIC,1}
              cpos = _cpp_SkipToken{*tline,cpos}
              _tb_SetStyleCommand{*tline,cpos,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
              _tb_SetStyleCommand{*tline,cpos,#TUITBSC_ITALIC,0}
              first=False
          End Select

        Case @"/"
          c.b = Peek.b(bptr+cpos)
          Select c
            Case @"/"
              cpos+1
              cpos = _cpp_ParseComment{*tline,cpos}
              first=False
            Case @"*"
              cpos + 1
              cpos = _cpp_ParseMultiLineComment{*tline,cpos,(.longP)&incomment}
          End Select

        Case @"0"
          c.b = Peek.b(bptr+cpos)
          Select c
            Case @"x"
              _tb_SetStyleCommand{*tline,cpos-1,#TUITBSC_FGPEN,#TUITBPEN_NUMBER,0}
              cpos = _cpp_SkipHex{*tline,cpos+1}
              _tb_SetStyleCommand{*tline,cpos+1,#TUITBSC_FGPEN,#TUITBPEN_TEXT,0}
              first=False
            Default
              cpos = _cpp_ParseNumber{*tline,cpos-1}    : cf = 0 : c=0 : first=False

          End Select
          first=False

        Default
          If (cf&#CPPTF_QUOT   ) Then cpos = _cpp_ParseString{*tline,cpos,c}    : first=False
          If (cf&#CPPTF_FIRST  ) Then cpos = _cpp_ParseToken{*tline,cpos,*hm,first,0} : first=False
          If (cf&#CPPTF_DEC    ) Then cpos = _cpp_ParseNumber{*tline,cpos}    : first=False

      End Select

    Wend

    *tline\flags|#TUITBLF_STYLED
    oflags.l = *tline\flags
    If incomment Then *tline\flags|#TUITBLF_INCOMMENT : Else *tline\flags|#TUITBLF_INCOMMENT - #TUITBLF_INCOMMENT
    If ((*tline\flags&#TUITBLF_INCOMMENT) >< (oflags&#TUITBLF_INCOMMENT)) Then Function Return #TUISCB_NEXT
  End If
  Function Return #TUISCB_DONE

End Function
!_MakeGlobalFuncPointer{_cpp_StyleCallback,{Null,0,Null}}


Function.l _CPP_Prepare{}

  tokenfile.s    = dos_AddPart{CPP\AIDEDir,"tokens.txt"}
  hashmapfile.s  = dos_AddPart{CPP\AIDEDir,"tokens.hash"}

  CPP\TempP = AllocVec_(1024,#MEMF_ANY)

  If dos_Exist{hashmapfile}
    CPP\Tokens  = hashmap_Load{hashmapfile}
  End If
  If CPP\Tokens=Null
    *hm.hashmap = hashmap_Create{14}
    If *hm
      fid.l = file_Open{tokenfile,#file_read}
      If fid>=0
        While file_EOF{fid}=False
          a.s = file_ReadLineF{fid}
          t.s = UCase$(lindex{a,0})
          If t ; ="KEYWORD" OR t="DIRECTIVE"
            name.s = lindex{a,1}
            help.s = Right$(a , FLen(a) - Instr(a,name)-FLen(name)-1)
            tokenS.s = t+";"+help
            hashmap_AddItem{*hm,name,tokenS}
          End If
        Wend
        CPP\Tokens  = *hm
        hashmap_Save{CPP\Tokens,hashmapfile}
        file_Close{fid}
      End If
    End If
  End If

  For n.l=0 To 255
    CPP\CharFlags[n] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW
  Next

  CPP\CharFlags[   0] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_EOL ; Null
  CPP\CharFlags[   1] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; SOH
  CPP\CharFlags[   2] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; STX
  CPP\CharFlags[   3] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; ETX
  CPP\CharFlags[   4] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; EOT
  CPP\CharFlags[   5] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; ENQ
  CPP\CharFlags[   6] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; ACK
  CPP\CharFlags[   7] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; BELL
  CPP\CharFlags[   8] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; BS  (backspace)
  CPP\CharFlags[   9] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW|#CPPTF_SPACE ; TAB (tabulator)
  CPP\CharFlags[  10] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW|#CPPTF_EOL ; LF  (line feed) Linux Return
  CPP\CharFlags[  11] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; VT
  CPP\CharFlags[  12] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; FF  (feed forward)
  CPP\CharFlags[  13] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; CR  (carrier return) Windows Return
  CPP\CharFlags[  14] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; SO
  CPP\CharFlags[  15] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; SI
  CPP\CharFlags[  16] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; DLE
  CPP\CharFlags[  17] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; DC1
  CPP\CharFlags[  18] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; CD2
  CPP\CharFlags[  19] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; CD3
  CPP\CharFlags[  20] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; CD4
  CPP\CharFlags[  21] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; NAK
  CPP\CharFlags[  22] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; SYN
  CPP\CharFlags[  23] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; ETB
  CPP\CharFlags[  24] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; CAN (Cancel)
  CPP\CharFlags[  25] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; EM
  CPP\CharFlags[  26] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; SUB
  CPP\CharFlags[  27] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; ESC (Escape)
  CPP\CharFlags[  28] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; FS
  CPP\CharFlags[  29] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; GS
  CPP\CharFlags[  30] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; RS
  CPP\CharFlags[  31] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW ; US
  CPP\CharFlags[@" "] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY|#CPPTF_SPACE ; Space
  CPP\CharFlags[@"!"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[  34] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY|#CPPTF_QUOT
  CPP\CharFlags[@"#"] = #CPPTF_STOP | #CPPTF_IS   | #CPPTF_COPY;|#CPPTF_FIRST
  CPP\CharFlags[@"$"] = #CPPTF_STOP | #CPPTF_IS   | #CPPTF_COPY
  CPP\CharFlags[@"%"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"&"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"'"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY | #CPPTF_QUOT
  CPP\CharFlags[@"("] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@")"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"*"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"+"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@","] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"-"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"."] = #CPPTF_STOP | #CPPTF_COPY
  CPP\CharFlags[@"/"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"0"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_BIN |#CPPTF_HEX|#CPPTF_DEC
  CPP\CharFlags[@"1"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_BIN |#CPPTF_HEX|#CPPTF_DEC
  CPP\CharFlags[@"2"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"3"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"4"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"5"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"6"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"7"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"8"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@"9"] = #CPPTF_IS   | #CPPTF_COPY | #CPPTF_HEX |#CPPTF_DEC
  CPP\CharFlags[@":"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@";"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COMMENT|#CPPTF_COPY
  CPP\CharFlags[@"<"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"="] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@">"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"?"] = #CPPTF_STOP | #CPPTF_NEW  | #CPPTF_COPY
  CPP\CharFlags[@"@"] = #CPPTF_STOP | #CPPTF_COPY
  CPP\CharFlags[@"A"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY|#CPPTF_HEX
  CPP\CharFlags[@"B"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY|#CPPTF_HEX
  CPP\CharFlags[@"C"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY|#CPPTF_HEX
  CPP\CharFlags[@"D"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY|#CPPTF_HEX
  CPP\CharFlags[@"E"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY|#CPPTF_HEX
  CPP\CharFlags[@"F"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY|#CPPTF_HEX
  CPP\CharFlags[@"G"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"H"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"I"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"J"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"K"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"L"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"M"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"N"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"O"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"P"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"Q"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"R"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"S"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"T"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"U"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"V"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"W"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"X"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"Y"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"Z"] = #CPPTF_FIRST| #CPPTF_IS  |#CPPTF_COPY
  CPP\CharFlags[@"["] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"\"] = #CPPTF_STOP | #CPPTF_COPY
  CPP\CharFlags[@"]"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"^"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"_"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"`"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"a"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY | #CPPTF_HEX
  CPP\CharFlags[@"b"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY | #CPPTF_HEX
  CPP\CharFlags[@"c"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY | #CPPTF_HEX
  CPP\CharFlags[@"d"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY | #CPPTF_HEX
  CPP\CharFlags[@"e"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY | #CPPTF_HEX
  CPP\CharFlags[@"f"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY | #CPPTF_HEX
  CPP\CharFlags[@"g"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"h"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"i"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"j"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"k"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"l"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"m"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"n"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"o"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"p"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"q"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"r"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"s"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"t"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"u"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"v"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"w"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"x"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"y"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"z"] = #CPPTF_FIRST| #CPPTF_IS  | #CPPTF_COPY
  CPP\CharFlags[@"{"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"|"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"}"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[@"~"] = #CPPTF_STOP | #CPPTF_NEW | #CPPTF_COPY
  CPP\CharFlags[ 127] = #CPPTF_ILLEGAL | #CPPTF_STOP | #CPPTF_NEW

  CPP\IsPrepared=True

  Function Return True

End Function


CPP_Deinit:
Statement CPP_Deinit{}

  If CPP\Tokens   Then hashmap_Free{CPP\Tokens}
  If CPP\TempP    Then FreeVec_ CPP\TempP
  CPP\Tokens     = Null
  CPP\IsPrepared = False

End Statement
!_MakeGlobalFuncPointer{CPP_Deinit,{}}



CPP_Import:
Function.l CPP_Import{docX.l,*filenameP.b}

  err.l      = 0
  filename.s = Peek.s(*filenameP)
  ex.s       = dos_GetExt{filename}
  AIDE\Document[docX]\Xtra = _CPP_AllocXtra{}
  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  err.l = ntui_LoadTextBox{*textBox,&filename}

  Function Return err

End Function
!_MakeGlobalFuncPointer{CPP_Import,{0,Null}}


CPP_Export:
Function.l CPP_Export{docX.l,*filenameP.b}

  filename.s = Peek.s(*filenameP)
  *textBox.tuiTextBox = AIDE\Document[docX]\TextBox
  err.l = ntui_SaveTextBox{*textBox,&filename}

  Function Return err

End Function
!_MakeGlobalFuncPointer{CPP_Export,{0,Null}}


CPP_Attach:
Function.l CPP_Attach{docX.l}

  If CPP\IsPrepared=False Then _CPP_Prepare{}
  If CPP\IsPrepared=False Then Function Return False

  AIDE\Document[docX]\DocType = CPP\DocType
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_STYLECB,*_cpp_StyleCallback}

  Function Return True

End Function
!_MakeGlobalFuncPointer{CPP_Attach,{0}}


CPP_Detach:
Function.l CPP_Detach{docX.l}

  If AIDE\Document[docX]\Xtra Then _CPP_FreeXtra{(.CPP_Xtra)AIDE\Document[docX]\Xtra}
  AIDE\Document[docX]\Xtra = Null

  AIDE\Document[docX]\DocType = #DOCTYPE_DEFAULT
  ntui_SetAttr{AIDE\Document[docX]\TextBox,#TUITBA_STYLECB,Null}

  Function Return True

End Function
!_MakeGlobalFuncPointer{CPP_Detach,{0}}


CPP_Init:
Statement CPP_Init{docType.l}

  AIDE\DocType[docType]\Pattern      = "#?.(c|cpp|h|hpp)"
  AIDE\DocType[docType]\Name         = "C/C++"
  AIDE\DocType[docType]\DefIcon      =  dos_AddPart{AIDE\GuiPath,"icons/def_c.info"}

  AIDE\DocType[docType]\Deinit       = *CPP_Deinit
  AIDE\DocType[docType]\DebugSource  = Null
  AIDE\DocType[docType]\BuildSource  = *CPP_BuildSource
  AIDE\DocType[docType]\DebugProject = *CPP_DebugProject
  AIDE\DocType[docType]\BuildProject = *CPP_BuildProject

  AIDE\DocType[docType]\ReadPrefs    = *CPP_ReadPrefs
  AIDE\DocType[docType]\WritePrefs   = *CPP_WritePrefs
  AIDE\DocType[docType]\Import       = *CPP_Import
  AIDE\DocType[docType]\Export       = *CPP_Export
  AIDE\DocType[docType]\Attach       = *CPP_Attach
  AIDE\DocType[docType]\Detach       = *CPP_Detach

  CPP\Exe        = "GG:bin/gcc"
  CPP\AIDEDir    = dos_AddPart{AIDE\DocTypesPath,"CPP"}
  CPP\Tokens     = Null
  CPP\TempP      = Null
  CPP\DocType    = docType
  CPP\IsPrepared = False       ; not yet prepared

End Statement

CPP_Init{#DOCTYPE_CPP}

; ===========================================================


