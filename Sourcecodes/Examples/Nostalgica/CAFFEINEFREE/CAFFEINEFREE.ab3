; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = ""
; ExeFile         = ""
; CreateIcon      = 1
; Residents       = ""
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 0
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 0
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 80000
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 1
; CursorColumn    = 1
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 20
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 20
; /XTRA
;THE CAFFIENE-FREE DIET SHOOT'EM-UP
;
;By Ben Campbell and JS Hong
;September, '93

;Note: to compile&run this game, you'll need the files in the
; 'inc' directory (CD!), and more than 1 meg memory (sorry),
; otherwise create executable, quit then run it

WBStartup ;run from an icon
NoCli ;free up ted and cli for low mem developers

#WIDTH=320-16         ;\___size of display area
#HEIGHT=256-16        ;/
                      ;the display is 16 pixels short of
                      ;full screen size 'cos we can't have
                      ;that and the scrolling while still
                      ;having enough bandwidth left for
                      ;all eight sprites.
                      ;so there. nyah nyah nyah.

#LEFTLIM=(-200*32)              ;\
#RIGHTLIM=(#WIDTH+200)*32       ; \__bob position limits
#TOPLIM=(-200*32)               ; /
#BOTTOMLIM=(#HEIGHT+200)*32     ;/
                                ;there is a notional offscreen buffer
                                ;of 200 pixels all round
                                ;so we can move bobs
                                ;smoothly onto the screen.
                                ;ie negative bob coords are
                                ;OK to use.

#MAPWIDTH=256         ;\___size of map (in 16x16 blocks)
#MAPHEIGHT=14         ;/
#MAPSIZE=#MAPWIDTH*#MAPHEIGHT

#NUMOFDUDES=8         ;number of bad dudes
                      ;maybe up this number for a special
                      ;accelerated version. maybe even AGA...
#BULLETSPR=14         ;number of first bullet sprite object

#WAVESIZE=24*#NUMOFDUDES

#NUMOFLEVELS=4

#MAXSHIELD=127        ;maximun player shield value

;SHAPE usage:
;first lot of shapes are bobs (including the charset images)
;then come all the background tiles.

#FIRSTBOB=0               ;first bob shape
#FIRSTCHAR=200            ;first charset shape ('A'!)
#FIRSTTILE=#FIRSTCHAR+42  ;first tile shape
                          ;note: if #FIRSTTILE is changed, you must
                          ;also update values in the LEVEL data.
                          ;(more info there...)

;so we have 200 bobs, then 42 chars, then about a zillion tiles. Groovy.
;(not all are used. keeping our options open.)


NEWTYPE.baddude
  state.w             ;update routine 0=inactive
  energy.w            ;0=splat, one ex-parrot.
  x.w                 ;\___position 11.5 format (ie 5 bitshifts)
  y.w                 ;/
  xs.w                ;\___speed (11.5 format)
  ys.w                ;/
  image.w             ;current shape
  flash.w             ;non-zero = use SolidMode for blitting
  antable.l           ;anim table to use
  anptr.w             ;current offset into anim table
  delay.w             ;time before dude activates (counts down)
  dat0.w              ;assorted data
  dat1.w
  dat2.w
  dat3.w
End NEWTYPE

NEWTYPE.bullet        ;bullet fired by player
  state.w
  x.w                 ;\__position
  y.w                 ;/
  xs.w                ;\__speed
  ys.w                ;/
  image.w
End NEWTYPE


NEWTYPE.lev
  ;level data structure
  wave.w[16]    ;attack waves appearing on this level
  endwave.w     ;end-of-level attack wave
  pal.w         ;palette
  map.w         ;map
  firsttile.w   ;which tiles to use
End NEWTYPE

NEWTYPE.hiscore
  ;entry in hiscore table
  name.s
  score.l
End NEWTYPE

NEWTYPE .bitmap      ;taken from bb2objtypes.res
  _ebwidth.w[0]      ;00: for compatability.
  _linemod.w         ;00: value to get from one scanline to next.
  _height.w          ;02: currently pixel height - but open to commodore 'enhancement'.
  _depth.w           ;04: number of bitplanes.
  _pad.b[2]          ;06: nothing.
  _data.l[8]         ;08: actual bitplane pointers.
  _pad2.b[12]        ;40: zilch.
  _flags.w           ;0=normal bitmap, <0=interleaved.
  _bitplanemod.w     ;value to get from one bitplane to next. MAY BE 0!
  _xclip.w           ;pixel width for render clipping
  _yclip.w           ;pixel height for render clipping
  _cclip.w           ;number of colours available on bitmap ( = 2^_depth)
  _isreal.w          ;0=no bitmap here, <0=blitz created bitmap, >0=borrowed
End NEWTYPE          ;64: sizeof

DEFTYPE.l p                         ; \___scratch vars
DEFTYPE.w i,j,x,y                   ; /
DEFTYPE.bitmap *bm                  ;/

;global vars
DEFTYPE.l mapsbase,mapbuffer,wavedata,anptrs,plrscore,dispscore
DEFTYPE.w gamestatus,bmtoggle,xfine,xcoarse,logi,phys
DEFTYPE.w plrx,plry,plrxs,plrys,plrimage,plrpitch
DEFTYPE.w firetimer,scrollspeed,d,keymode,plrshield
DEFTYPE.w level,dudecount,freedudes,gentimer,firsttile
DEFTYPE.s chargrid

;arrays (just like on the '64! them was the good old days...)
Dim oldplanes.l(1,3)
Dim dudes.baddude(#NUMOFDUDES)
Dim bullets.bullet(4)
Dim sinlt(360)              ;sinewave lookup table
Dim levs.lev(#NUMOFLEVELS)
Dim btime.w(10)             ;bonus timers
Dim hiscores.hiscore(8)     ;hiscore table

;allocate bitmaps
BitMap 0,#WIDTH+16+16+16,#HEIGHT+20+32,4
BitMap 1,#WIDTH+16+16+16,#HEIGHT+20+32,4

;load in stuff.

DosBuffLen 8192

;hmmm, they _look_ like disk-access commands... but where
;are all the nasty BCPL filehandle pointers?

ChDir "blitz3:sourcecodes/examples/nostalgica/caffeinefree/"
LoadShapes #FIRSTBOB,"inc/GeneralBobs.shapes"
LoadShapes #FIRSTBOB+60,"inc/TechBobs.shapes"
LoadShapes #FIRSTBOB+100,"inc/DarkBobs.shapes"
LoadShapes #FIRSTBOB+150,"inc/BigDudes.shapes"

LoadShapes #FIRSTCHAR,"inc/Chars.shapes"
;LoadShapes #FIRSTTILE+1,"inc/TechTiles.shapes"
;LoadShapes #FIRSTTILE+256+1,"inc/Mountains.shapes"
;LoadShapes #FIRSTTILE+512+1,"inc/DarkTiles.shapes"

LoadSprites 0,"inc/player.sprites"
LoadSprites #BULLETSPR,"inc/bullet.sprites"

LoadSound 0,"inc/sfx/sound8"   ;player fire
LoadSound 1,"inc/sfx/bonus.sfx"   ;player collecting bonus
LoadSound 2,"inc/sfx/appear6.sfx"   ;player hit by bad dude
LoadSound 3,"inc/sfx/appear6.sfx"       ;bullet hit baddude
LoadSound 4,"inc/sfx/boom.sfx"          ;explosion

LoadPalette 0,"inc/Tech.palette"
LoadPalette 0,"inc/sprites.palette",16
LoadPalette 1,"inc/Tech.palette"
LoadPalette 1,"inc/sprites.palette",16
LoadPalette 2,"inc/Mountains.palette"
LoadPalette 2,"inc/sprites.palette",16
LoadPalette 3,"inc/Dark.palette"
LoadPalette 3,"inc/sprites.palette",16

;load in the status bar image
BitMap 2,#WIDTH,30,4
LoadBitMap 2,"inc/StatBar.brush",4
BitMap 3,320,124,4
LoadBitMap 3,"inc/Title.brush",5

AutoCookie Off

;chop out techtiles
LoadBitMap 0,"inc/TechTiles.iff"
Use BitMap 0
x=0:y=0
For i=#FIRSTTILE+1 To #FIRSTTILE+255
  GetaShape i,x*16,y*16,16,16
  x=x+1
  If x>=20 Then x=0:y=y+1
Next

;chop out mountaintiles
LoadBitMap 0,"inc/Mountains.iff"
Use BitMap 0
x=0:y=0
For i=#FIRSTTILE+256+1 To #FIRSTTILE+256+255
  GetaShape i,x*16,y*16,16,16
  x=x+1
  If x>=20 Then x=0:y=y+1
Next

;chop out darktiles
LoadBitMap 0,"inc/DarkTiles.iff"
Use BitMap 0
x=0:y=0
For i=#FIRSTTILE+512+1 To #FIRSTTILE+512+255
  GetaShape i,x*16,y*16,16,16
  x=x+1
  If x>=20 Then x=0:y=y+1
Next



;go into BLITZ mode.
;(There's no way anyones _ever_ going to get me to write a
;game with system friendly double-buffering on anything less
;than wb3.0 - so the OS gets the boot.)

VWait 5*50              ;give the diskdrives time to settle...

BLITZ                   ;zap! pow! whammo!
BlitzKeys On

VWait
Poke.w $DFF106,0        ;make sure aga sprites are lowres...
Poke.w $DFF1FC,0        ;...and only one word wide (aga stuff)

;now drop through to MAIN...


;*************************
;FUNCTIONS / PROCEDURES


.ConvertChar
Function ConvertChar{c.w}
      ;converts an ascii value to an offset into our minimalistic
      ;charset. Returns converted value (-1 = char not in charset)

      DEFTYPE.w b

      b=-1    ;preset to invalid char

      If c>=Asc("0") AND c<=Asc("9") Then b=#FIRSTCHAR+26+c-Asc("0")
      If c>=Asc("a") AND c<=Asc("z") Then b=#FIRSTCHAR+c-Asc("a")
      Select c
        Case Asc(" ")
          b=#FIRSTCHAR+39   ;space
        Case Asc(".")
          b=#FIRSTCHAR+36
        Case Asc("-")
          b=#FIRSTCHAR+37
        Case Asc("!")
          b=#FIRSTCHAR+38
        Case Asc("@")
          b=#FIRSTCHAR+40   ;del
        Case Asc("#")
          b=#FIRSTCHAR+41   ;end
      End Select

  Function Return b
End Function



Statement WaitForClick{timeout.w}
  ;waits for the player to click fire or space, depending on keymode state
  ;timeout is in vblanks (-1 = infinite timeout)

  SHARED keymode

  DEFTYPE.w state,time,count

  count=0
  time=0

  Repeat

    VWait
    time=time+1

    If keymode
      state=RawStatus($40)
    Else
      state=Joyb(1)
    EndIf

    Select count
      Case 0
        ;waiting for down
        If state Then count=count+1
      Case 1
        ;waiting for up
        If state=Off Then count=count+1
    End Select

  Until time=timeout OR count=2

End Statement



.PlonkChars
Statement PlonkChars{a$,x.w,y.w}
  ;draw a string of chars to the current bitmap, using the current
  ;blitmode.

  DEFTYPE.w c,a,b
  a$=LCase$(a$)

  For c=1 To Len(a$)
    If x<320                              ;check for screen edge
      b = ConvertChar{Asc(Mid$(a$,c,1))}
      If b>=0
        Blit b,x,y
        x=x+16
      EndIf
    EndIf
  Next
End Statement


Statement CentrePlonk{a$,y}
  ;centre a string of text
  PlonkChars{a$,(#WIDTH/2)-(Len(a$)*8),y}
End Statement

.InitLevel
Statement InitLevel{}
  ;setup the level vars, do a wee level-intro-sequence and
  ;stuff like that.

  SHARED xfine,xcoarse,logi,phys,mapsbase,mapbuffer,scrollspeed
  SHARED plrx,plry,plrxs,plrys,plrimage,oldplanes()
  SHARED *bm,i,j,p,level,keymode,gamestatus,dudes(),bullets()
  SHARED firsttile,levs()

  firsttile=levs(level)\firsttile
  mapbuffer=mapsbase+(levs(level)\map * #MAPSIZE)

  ;setup slices
  Slice 1,44,#WIDTH,30,$fff8,4,0,16,#WIDTH,#WIDTH
  Show 2
  Use Palette 4
  Slice 0,44+32,#WIDTH,#HEIGHT,$fff8,4,8,32,#WIDTH+32+16,#WIDTH+32+16
  Use Palette levs(level)\pal

  ;init vars
  phys=0
  logi=1
  xfine=0
  xcoarse=0
  scrollspeed=1
  plrx=100*32
  plry=80*32
  plrxs=0
  plrys=0
  plrimage=0
  plrpitch=0
  gamestatus=0

  ;init dudes
  For i=0 To #NUMOFDUDES-1
    dudes(i)\state=0
  Next

  ;init bullets
  For i=0 To 3
    bullets(i)\state=0
  Next

  ;clear bitmaps
  Use BitMap 0
  Cls 0
  Use BitMap 1
  Cls 0

  ;BitMapOutput 0
  ;Locate 14,12
  ;Print "LEVEL "
  ;Print level
  ;BitMapOutput 1
  ;Locate 14,12
  ;Print "LEVEL "
  ;Print level
  BlitMode CookieMode
  Use BitMap 0
  PlonkChars{"level "+Str$(level+1),80,100}
  Use BitMap 1
  PlonkChars{"level "+Str$(level+1),80,100}

  DisplayOn
  Show 0,xfine+16,16
;  i=0
;  j=Off
;  Repeat
;    VWait
;    i=i+1
;    If keymode=On
;      j=RawStatus($40)
;    Else
;      j=Joyb(1)
;    EndIf
;  Until i=5*50 OR j

  WaitForClick{5*50}

  ;initialize physical bitmap (draw 1st column)
  Use BitMap phys
  p=mapbuffer
  For i=1 To #MAPHEIGHT
    j=Peek.b(p)
    If j<0 Then j=j+256
    Block firsttile+j,#WIDTH+32,i*16
    p=p+#MAPWIDTH
  Next

  ;suss out scrolling:
  ;a simple mainloop to scroll the background into view
  ;(the main game expects to start off with a full screen
  ;of grafix)

  xcoarse=0

  Repeat
    VWait                               ;new frame
    Show phys,xfine+16,16               ;show physical bitmap

    xfine=xfine+8                       ;8 pixels/cycle
    If xfine>=16                        ;need to coarse-scroll?
      xfine=xfine-16
      xcoarse=xcoarse+1
    EndIf

    ;update bitmap pointers if needed
    *bm=Addr BitMap(logi)
    *bm\_data[0]=oldplanes(logi,0)+(xcoarse*2)
    *bm\_data[1]=oldplanes(logi,1)+(xcoarse*2)
    *bm\_data[2]=oldplanes(logi,2)+(xcoarse*2)
    *bm\_data[3]=oldplanes(logi,3)+(xcoarse*2)

    ;draw up new column of blocks (have to do a whole column
    ;cos we're doing fast scrolling)
    Use BitMap logi
    p=mapbuffer+xcoarse
    For i=1 To #MAPHEIGHT
      j=Peek.b(p)
      If j<0 Then j=j+256
      Block firsttile+j,#WIDTH+32,i*16
      p=p+#MAPWIDTH
    Next

    ;swap physical and logical bitmaps
    phys=logi
    logi=1-logi
  Until xcoarse>=20         ;done a whole screen?
End Statement







;.CountFreeDudes
;Function.w CountFreeDudes{}
;  ;returns the number of free dudes in dudes() array
;  Shared dudes()
;
;  DEFTYPE.w f,d
;
;  f=0
;  For d=0 To #NUMOFDUDES-1
;    If dudes(d)\state=0 Then f=f+1
;  Next
;  Function Return f
;End Function


Function.w FindFreeDude{}
  ;goes through the dude array and finds a free baddude

  SHARED dudes()

  DEFTYPE.w i,d
  d=-1
  i=0
  Repeat
    If dudes(i)\state=0 Then d=i
    i=i+1
  Until i=#NUMOFDUDES OR d<>-1
  Function Return d
End Function



.StartAttackWave
Statement StartAttackWave{wave.w}
  SHARED dudes(),anptrs,i,p,wavedata,dudecount

  p=wavedata+(wave*#WAVESIZE)
  USEPATH dudes(i)
  For i=0 To #NUMOFDUDES-1
    \state=Peek.w(p) : p=p+2      ;I want postincrement!!!!!!
    \energy=Peek.w(p) : p=p+2     ;\energy=peek.w(p++)
    \x=Peek.w(p) : p=p+2
    \y=Peek.w(p) : p=p+2          ;pleeeeeeeeease?
    \xs=Peek.w(p) : p=p+2
    \ys=Peek.w(p) : p=p+2
    \antable=Peek.l(anptrs+(Peek.w(p)ASL 2)) : p=p+2
    \delay=Peek.w(p) : p=p+2
    \dat0=Peek.w(p) : p=p+2
    \dat1=Peek.w(p) : p=p+2
    \dat2=Peek.w(p) : p=p+2
    \dat3=Peek.w(p) : p=p+2

    \anptr=0
    \image=Peek.w(\antable)
    \flash=0
  Next
  dudecount=#NUMOFDUDES
End Statement



.DrawDudes
Statement DrawDudes{}
  SHARED dudes(),i,logi,xfine

  DEFTYPE.w x,y

  USEPATH dudes(i)

  For i=0 To #NUMOFDUDES-1
    If \state>0 AND \delay=0
      x=(\x ASR 5)+16
      y=(\y ASR 5)+16
      If x>=0 AND y>=0 AND x<(#WIDTH+16) AND y<(#HEIGHT+16)
        If \flash=0
          BBlitMode CookieMode
        Else
          BBlitMode SolidMode
          \flash=\flash-1
        EndIf
        ;BBlit logi,\image,x+xfine,y
        BBlit logi,#FIRSTBOB+\image,x+xfine,y
      EndIf
    EndIf
  Next
End Statement


.ExplodeDude
Statement ExplodeDude{}
  ;blow up the dude given by d.w
  SHARED dudes(),d,anptrs

  USEPATH dudes(d)
  \state=1
  \antable=Peek.l(anptrs)     ;anim 0 = explosion
  \image=Peek.w(\antable)
End Statement


Statement GeraldTheMouse{x.w,y.w}

  SHARED dudes(),anptrs
  DEFTYPE.w dude
  For dude=0 To #NUMOFDUDES-1
    USEPATH dudes(dude)
    If \state=0
      \state=1
      \x=x+(Rnd(48)*32)
      \y=y+(Rnd(48)*32)
      \xs=xs-4*32
      \ys=ys
      \energy=5
      \antable=Peek.l(anptrs+(0 ASL 2))
      \delay=Rnd(50)
      \dat0=4       ;accel
      \dat1=2*32    ;maxspeed
      \dat2=0
      \dat3=200      ;timer
      \anptr=0
      \image=Peek.w(\antable)
      \flash=0
    EndIf
  Next

End Statement



Statement LinDude{}
  ;moves dude given by d.w in a straight line
  SHARED dudes(),d
  USEPATH dudes(d)
  \x=\x+\xs
  \y=\y+\ys
  If \x<#LEFTLIM OR \x>#RIGHTLIM Then \state=0
  If \y<#TOPLIM OR \y>#BOTTOMLIM Then \state=0
End Statement



Statement VertSineDude{}
  SHARED dudes(),sinlt(),d
  USEPATH dudes(d)
  \x=\x+\xs
  \y=(sinlt(\dat0)ASR 1)+\dat1
  \dat0=\dat0+\ys
  If \dat0<0 Then \dat0=\dat0+360
  If \dat0>=360 Then \dat0=\dat0-360
  If \x<#LEFTLIM OR \x>#RIGHTLIM Then \state=0
  If \y<#TOPLIM OR \y>#BOTTOMLIM Then \state=0
End Statement



Statement HorzSineDude{}
  SHARED dudes(),sinlt(),d
  USEPATH dudes(d)
  \dat1=\dat1+\xs
  \x=(sinlt(\dat0) ASR 1)+\dat1
  \dat0=\dat0+\ys
  If \dat0<0 Then \dat0=\dat0+360
  If \dat0>=360 Then \dat0=\dat0-360
  If \x<#LEFTLIM OR \x>#RIGHTLIM Then \state=0
End Statement



Statement BothSineDude{}
  SHARED dudes(),sinlt(),d
  USEPATH dudes(d)

  \dat0=\dat0+\xs
  \x=(sinlt(\dat0) ASR 1)+\dat1
  If \dat0<0 Then \dat0=\dat0+360
  If \dat0>=360 Then \dat0=\dat0-360

  \dat2=\dat2+\ys
  \y=(sinlt(\dat2) ASR 1)+\dat3
  If \dat2<0 Then \dat2=\dat2+360
  If \dat2>=360 Then \dat2=\dat2-360

  If \x<#LEFTLIM OR \x>#RIGHTLIM Then \state=0
End Statement



Statement MoveBonus{}
  SHARED dudes(),d,scrollspeed
  USEPATH dudes(d)
  \x=\x-(scrollspeed ASL 5)
  \y=\y+\ys
  If \x<#LEFTLIM OR \x>#RIGHTLIM Then \state=0
  If \y>=((#HEIGHT-32)*32)                ;below groundlevel?
    \y=(#HEIGHT-32)*32
    \ys=0-(\ys ASR 1)                     ;damped bounce
    If Abs(\ys)<10 Then \ys=0             ;stop jittering
  Else
    \ys=\ys+3                             ;gravity
  EndIf
End Statement



Statement BouncyDude{}
  ;constantly bouncing dude
  SHARED dudes(),d
  USEPATH dudes(d)
  \x=\x+\xs
  \y=\y+\ys
  If \x<#LEFTLIM OR \x>#RIGHTLIM Then \state=0
  If \y < ((#HEIGHT-32)*32) Then \ys=\ys+3            ;gravity
  If \y >= ((#HEIGHT-32)*32) AND \ys>0 Then \ys=0-\ys ;bounce
End Statement


.AnimDude
Statement AnimDude{}
  ;animate dude in d.w
  SHARED dudes(),d,anptrs,logi
  DEFTYPE.w im

  USEPATH dudes(d)
  im=Peek.w(\antable+\anptr)
  If im<>-1
    \anptr=\anptr+2
    \image=im
  Else
    ;wrap anim back to first frame
    \anptr=0
    \image=Peek.w(\antable)
  EndIf

End Statement



.AnimDudeOnce
Statement AnimDudeOnce{}
  ;animate dude in d.w
  ;kill off dude when anim finished
  SHARED dudes(),d,anptrs,logi
  DEFTYPE.w im

  USEPATH dudes(d)
  im=Peek.w(\antable+\anptr)
  If im<>-1
    \anptr=\anptr+2
    \image=im
  Else
    \state=0
  EndIf
End Statement


Statement HomingDude{}
  SHARED dudes(),anptrs,d,plrx,plry
  USEPATH dudes(d)

  If \x<plrx Then \xs=\xs+\dat0 Else \xs=\xs-\dat0
  If \y<plry Then \ys=\ys+\dat0 Else \ys=\ys-\dat0

  If \xs>\dat1 Then \xs=\dat1
  If \xs<(0-\dat1) Then \xs=(0-\dat1)
  If \ys>\dat1 Then \ys=\dat1
  If \ys<(0-\dat1) Then \ys=(0-\dat1)

  LinDude{}
End Statement



Statement EOLDude1{}
  SHARED dudes(),anptrs,d
  USEPATH dudes(d)

  Select \dat3
    Case 0
      ;coming in from right
      \x=\x-(8*32)
      If \x<=\dat2 Then \dat3=1
      AnimDude{}
    Case 1
      VertSineDude{}
      AnimDude{}
      If Rnd(1000)<8 Then \dat3=2 : \xs=0     ;-(8*32)
    Case 2
      \xs=\xs-16
      \x=\x+\xs
      If \x<#LEFTLIM Then \dat3=0 : \x=#RIGHTLIM : \xs=0
      AnimDude{}
  End Select

End Statement



Statement EOLDude2{}
  SHARED dudes(),anptrs,d,sinlt()
  USEPATH dudes(d)

  DEFTYPE.w fd

  Select \dat3
    Case 0
      ;coming in from right
      \x=\x-(4*32)
      If \x<=(168+64)*32
        \x=(168+64)*32
        \xs=3
        \ys=2
        \dat0=90
        \dat1=0
        \dat3=1
      EndIf
    Case 1
      \dat0=\dat0+\xs
      \x=(sinlt(\dat0) ASR 1)+(168*32)
      If \dat0<0 Then \dat0=\dat0+360
      If \dat0>=360 Then \dat0=\dat0-360

      \dat1=\dat1+\ys
      \y=(sinlt(\dat1) ASR 1)+(80*32)
      If \dat1<0 Then \dat1=\dat1+360
      If \dat1>=360 Then \dat1=\dat1-360

      ;If Rnd(200)<5 Then DudeFire{-8*32,0,0}
      fd=-1
      If dudes(0)\state=0 Then fd=0
      If dudes(1)\state=0 Then fd=1

      If fd<>-1 AND Rnd(1000)<10
        USEPATH dudes(fd)
        \state=18
        \x=dudes(d)\x
        \y=dudes(d)\y+(24*32)
        \xs=xs-4*32
        \ys=ys
        \energy=5
        \antable=Peek.l(anptrs+(16 ASL 2))  ;3
        \delay=0
        \dat0=4       ;accel
        \dat1=2*32    ;maxspeed
        \dat2=0
        \dat3=200      ;timer
        \anptr=0
        \image=Peek.w(\antable)
        \flash=0

        USEPATH dudes(d)
      EndIf

  End Select

End Statement



Statement EOLDude3{}
  SHARED dudes(),anptrs,d,sinlt()
  USEPATH dudes(d)

  DEFTYPE.w fd

    fd=-1
    If dudes(0)\state=0 Then fd=0
    If dudes(1)\state=0 Then fd=1
    If dudes(2)\state=0 Then fd=2

    If fd<>-1 AND Rnd(1000)<50
      USEPATH dudes(fd)
      \state=18
      \x=dudes(d)\x
      \y=dudes(d)\y   ;+(24*32)
      \xs=xs-4*32
      \ys=ys
      \energy=5
      \antable=Peek.l(anptrs+(16 ASL 2))  ;3
      \delay=0
      \dat0=4       ;accel
      \dat1=2*32    ;maxspeed
      \dat2=0
      \dat3=200      ;timer
      \anptr=0
      \image=Peek.w(\antable)
      \flash=0

      USEPATH dudes(d)
    EndIf


End Statement




.UpdateDudes
Statement UpdateDudes{}
  SHARED dudes(),i,j,sinlt(),d,gamestatus,freedudes,level

  ;Poke.w $dff180,$000F

  freedudes=0                             ;num of free dudes
  USEPATH dudes(d)
  For d=0 To #NUMOFDUDES-1
    If \delay=0
      Select dudes(d)\state
        Case 0
          ;unused dude
          freedudes=freedudes+1
        Case 1
          ;explosion
          AnimDudeOnce{}
        Case 2
          ;bonus
          MoveBonus{}
        Case 3
          ;moving, falling explosion
          LinDude{}
          AnimDudeOnce{}
          \ys=\ys+5
        Case 5
          ;stationary, indestructable dude
          AnimDude{}
        Case 10
          LinDude{}
          AnimDude{}
        Case 11
          VertSineDude{}
          AnimDude{}
        Case 12
          BouncyDude{}
          AnimDude{}
        Case 13
          HorzSineDude{}
          AnimDude{}
        Case 14
          BothSineDude{}
          AnimDude{}
          \dat1=\dat1-32
        Case 15
          ;test end of level dude
          ;BothSineDude{}
          ;AnimDude{}
          ;If (Rnd(400)<=5) Then DudeFire{-6*32,0,3}
        Case 16
          ;accelerating dude
          LinDude{}
          \xs=\xs+\dat0
          \ys=\ys+\dat1
          AnimDude{}
        Case 17
          ;level 1 end of level dude
          EOLDude1{}
        Case 18
          ;homing dude
          HomingDude{}
          AnimDude{}
          \dat3=\dat3-1
          If \dat3<=0 Then ExplodeDude{}
        Case 19
          ;endoflevel dude 2
          EOLDude2{}
        Case 20
          ;endoflevel dude for level 4 (dark)
          EOLDude3{}
          AnimDude{}
      End Select
    Else
      \delay=\delay-1
      If \delay=0 AND \state=1 Then  Sound 4,15   ;explosion sound
    EndIf
  Next

End Statement





.NewWaves
Statement NewWaves{}
  ;suss out bringing on new waves...

    SHARED gamestatus,freedudes,gentimer,level,levs()

    If freedudes=#NUMOFDUDES
      Select gamestatus
        Case 0
          ;normal gameplay - bring on random waves

          StartAttackWave{levs(level)\wave[Rnd(16)]}
        Case 1
          ;bring on mean end-of-level-wave
          StartAttackWave{levs(level)\endwave}
          gamestatus=2
        Case 2
          ;finished end-of-level wave...
          gamestatus=3
          gentimer=0        ;reset timer
        Case 3
          ;little timer delay for dramatic effect...
          gentimer=gentimer+1
          If gentimer>=50 Then gamestatus=4
        Case 10
          ;just finished explosion sequence
          gamestatus=11
          gentimer=0
          ;StartAttackWave{10}
        Case 11
          ;pausing...
          gentimer=gentimer+1
          If gentimer>=50 Then gamestatus=12
          ;gamestatus=12

      End Select
    EndIf
  ;Poke.w  $dff180,0
End Statement





;.Zooooooom
Statement Zooooooom{}
  ;make all the currently active dudes zoom off the screen
  SHARED dudes(),d

  USEPATH dudes(d)
  For d=0 To #NUMOFDUDES-1
    If \state>0 AND \delay=0
      \state=10             ;move in straight line
      \xs=(-16*32)
      \ys=0
    Else
      \state=0
    EndIf
  Next
End Statement



.DisplaySprites
Statement DisplaySprites{}
  SHARED plrx,plry,plrimage,bullets(),i,gamestatus,plrpitch
  SHARED logi

  If gamestatus<10
    If logi=1 Then i=10 Else i=3           ;do flame flicker
    ShowSprite plrpitch+i,(plrx ASR 5)+16,plry ASR 5,0
  Else
    ShowSprite #BULLETSPR,0,0,0
    ShowSprite #BULLETSPR,0,0,1
    ShowSprite #BULLETSPR,0,0,2
    ShowSprite #BULLETSPR,0,0,3
  EndIf

  USEPATH bullets(i)
  For i=0 To 3

    ;Select \state
    ;  Case 0
    ;    ShowSprite #BULLETSPR,0,0,i+4
    ;  Case 1
    ;    ShowSprite #BULLETSPR+1,(\x ASR 5)+16,\y ASR 5,i+4
    ;  Case 2
    ;    ShowSprite #BULLETSPR+2,(\x ASR 5)+16,\y ASR 5,i+4
    ;End Select
    If \state>0
      ShowSprite \image,(\x ASR 5)+16,\y ASR 5,i+4
    Else
      ShowSprite #BULLETSPR,0,0,i+4
    EndIf
  Next
End Statement



;.FindFreeBullet
Function.w FindFreeBullet{}
  ;returns number of first free bullet (-1 = none free)
  SHARED bullets(),i

  i=-1                             ;the pessimistic approach.
  If bullets(3)\state=0 Then i=3
  If bullets(2)\state=0 Then i=2
  If bullets(1)\state=0 Then i=1
  If bullets(0)\state=0 Then i=0
  Function Return i
End Function



.MovePlayer
Statement MovePlayer{}
  SHARED dudes(),plrx,plry,plrxs,plrys,plrimage,plrpitch
  SHARED bullets(),i,firetimer,scrollspeed,keymode,btime()

  DEFTYPE.w plracc,maxspd,dx,dy

  If btime(1)=0     ;check speedup bonus
    plracc=6        ;normal accel
    maxspd=3*32
  Else
    plracc=8        ;double accel
    maxspd=4*32
  EndIf

  dx=0
  dy=0
  If keymode
    If RawStatus($19) Then dx=plracc
    If RawStatus($18) Then dx=0-plracc

    If RawStatus($31) Then dy=4
    If RawStatus($20) Then dy=-4
  Else
    dx=plracc*Joyx(1)
    dy=plracc*Joyy(1)
  EndIf
  plrxs=plrxs+dx
  plrys=plrys+dy

  ;x drag
  If dx=0
    If plrxs<-1 Then plrxs=plrxs+2
    If plrxs>1 Then plrxs=plrxs-2
  EndIf

  If btime(2)=0 Then plrys=plrys+1        ;gravity

  If plrxs<(0-maxspd) Then plrxs=(0-maxspd)
  If plrxs>maxspd Then plrxs=maxspd

  If plrys<(0-maxspd) Then plrys=(0-maxspd)
  If plrys>maxspd Then plrys=maxspd


  plrx=plrx+plrxs
  plry=plry+plrys

  If plrx<0-6*32 Then plrx=0-6*32: plrxs=0
  If plrx>=(#WIDTH-28)*32 Then plrx=(#WIDTH-28)*32 : plrxs=0

  If plry<0 Then plry=0 : plrys=0
  If plry>((#HEIGHT-46)*32) Then plry=((#HEIGHT-46)*32) : plrys=0


  plrpitch=plrys ASR 4  ;was 5
  If plrpitch<-3 Then plrpitch=-3
  If plrpitch>3 Then plrpitch=3


  ;Firing

  If firetimer=0
    ;ok to fire...
    If (RawStatus($40) AND keymode) OR (Joyb(1) AND keymode=Off)
      i=FindFreeBullet{}
      If i<>-1
        USEPATH bullets(i)
        ;\state=1
        \x=plrx
        \y=plry+(12 ASL 5)-(plrpitch ASL 5)
        \xs=plrxs+(12 ASL 5)
        \ys=plrpitch ASL 6
        ;\image=#BULLETSPR+1
        firetimer=5
        If btime(0)=0
          \state=1
          \image=#BULLETSPR+plrpitch+4          ;normal shots
        Else
          \state=2
          \image=#BULLETSPR+plrpitch+4+7          ;hot shots
        EndIf
        Sound 0,1,30
      EndIf
    EndIf
  Else
    ;wait...
    firetimer=firetimer-1
  EndIf

End Statement



.MoveBullets
Statement MoveBullets{}
  SHARED bullets(),i

  USEPATH bullets(i)
  For i=0 To 3
    If \state>0
      \x=\x+\xs
      \y=\y+\ys
      If \x>(#WIDTH*32) Then \state=0
      If \y<0 OR \y>((#HEIGHT-16)*32) Then \state=0
    EndIf
  Next
End Statement



.ChangeShield
Statement ChangeShield{delta.w}
  SHARED plrshield
  DEFTYPE.w oldshield

  Use BitMap 2
  oldshield=plrshield
  plrshield=plrshield+delta
  If plrshield<0Then plrshield=0
  If plrshield>#MAXSHIELD Then plrshield=#MAXSHIELD

  delta=plrshield-oldshield
  If delta>0
    ;increasing
    Boxf oldshield+8,5,plrshield+8,8,15
  EndIf
  If delta<0
    ;decreasing
    Boxf plrshield+8,5,oldshield+8,8,0
  EndIf

End Statement





.GiveBonus
Statement GiveBonus{num.w}
  SHARED btime()
  Select num
    Case 0
      ;hotshots
      btime(num)=400
    Case 1
      ;speedup
      btime(num)=400
    Case 2
      ;antigrav
      btime(num)=400
    Case 3
      ;shield bonus
      btime(num)=20
    Case 4
      ;score bonus
      btime(num)=100
  End Select
  Use BitMap 2
  BlitMode CookieMode
  Blit 12+num,144+(16*num),7
End Statement



.UpdateBTimers
Statement UpdateBTimers{}
  SHARED btime(),plrscore

  DEFTYPE.w b

  For b=0 To 4
    If btime(b)>0
      Select b
        Case 3
          ChangeShield{1}
        Case 4
          plrscore=plrscore+5
      End Select
      btime(b)=btime(b)-1
      If btime(b)=0
        ;timer expired - erase bonus icon thingy
        Use BitMap 2
        BlitMode EraseMode
        Blit 12+b,144+(16*b),7
      EndIf
    EndIf
  Next
End Statement


.CheckCollisions
Statement CheckCollisions{}
  SHARED dudes(),bullets(),plrx,plry,plrxs,plrys,d,i,plrscore,dudecount
  SHARED logi

  DEFTYPE.w x,y,dh,dw
  DEFTYPE.w pleb,foo

  ;first do player-baddude collisions

  x=plrx+(2*32)                       ;player x\___ allowing for
  y=plry                              ;player y/    hitzone

  dw=16*32                            ;dudewidth \__ preset to assume
  dh=16*32                            ;dudeheight/   16x16 images

  USEPATH dudes(d)
  For d=0 To #NUMOFDUDES-1
    If \state<>0 AND \delay=0
      If \image>=#FIRSTBOB+150
        ;allow for big (ie non 16x16) images
        dw=ShapeWidth(\image) ASL 5
        dh=ShapeWidth(\image) ASL 5
      EndIf
      If RectsHit(x,y,24*32,17*32,\x,\y,dw,dh)
        ;we have a hit on the player!
        Select \state
          Case 1
            ;explosion - do nothing
          Case 2
            ;groovy bonus dude
            ;plrscore=plrscore+100
            \state=0
            GiveBonus{\dat0}
            Sound 1,2,64
          Case 4
            ;bullet
            ChangeShield{-20}
            plrxs=plrxs+\xs
            plrys=plrys+\ys
            ExplodeDude{}
          Default
            ;normal scum-sucking dude
            ChangeShield{-2}
            Sound 2,4,64
        End Select
      EndIf
      If \image>=#FIRSTBOB+150
        ;reset dudedimensions back to 16x16
        dw=16*32
        dh=16*32
      EndIf

    EndIf
  Next

  ;now bullet-baddude hits:

  ;only check two of the bullets each cycle, to
  ;save a wee bit of uP time...

  USEPATH dudes(d)
  If logi=0 Then pleb=0 Else pleb=2           ;which two to check?
  For i=pleb To pleb+2                        ;bullet loop
    If bullets(i)\state<>0
      For d=0 To #NUMOFDUDES-1          ;dude loop
        If \state>=10
          If \image>=#FIRSTBOB+150
            ;allow for big (ie non 16x16) images
            dw=ShapeWidth(\image) ASL 5
            dh=ShapeWidth(\image) ASL 5
          EndIf
          If RectsHit(bullets(i)\x,bullets(i)\y,16*32,4*32,\x,\y,dw,dh)
            ;hit a bad dude!
            \energy=\energy-bullets(i)\state
            bullets(i)\state=0    ;kill the bullet
            If \energy<=0
              ;plrscore=plrscore+10
              ;do scoring
              Select \state
                Case 17
                  plrscore=plrscore+100
                Case 19
                  plrscore=plrscore+500
                Case 20
                  plrscore=plrscore+1000
                Default
                  ;normal dude
                  plrscore=plrscore+50
              End Select

              If \state<>18 Then dudecount=dudecount-1
              If dudecount<=0     ;killed all bad dudes?
                ;yep, drop a bonus
                \state=2
                \xs=-1*32
                \ys=-1*32
                \dat0=Rnd(5)
                \image=12+\dat0
              Else
                ;explode dude
                ;\state=0
                Select \state
                  Case 19
                    ;big dude 1
                    \state=0
                    GeraldTheMouse{\x,\y}
                  Case 20
                    ;level 4 (dark) endoflevel dude
                    ;use all dudes for explosion:
                    For foo=0 To #NUMOFDUDES-1
                      dudes(foo)\state=0
                    Next
                    ;boom.
                    GeraldTheMouse{\x-(16*32),\y-(16*32)}
                  Default
                    ExplodeDude{}
                    Sound 4,4,64    ;explosion sound
                End Select

              EndIf
            Else
              \flash=10
              Sound 3,8,30          ;hit sound
            EndIf
          EndIf
          If \image>=#FIRSTBOB+150
            ;reset dudedimensions back to 16x16
            dw=16*32
            dh=16*32
          EndIf
        EndIf
     Next
    EndIf
  Next
End Statement


.BlowUpPlayer
Statement BlowUpPlayer{}
  ;setup player explosion (a special form of attack wave)

  SHARED dudes(),d,plrx,plry,plrxs,plrys,antables,anptrs

  USEPATH dudes(d)
  For d=0 To #NUMOFDUDES-1
    \x=plrx+Rnd(16*32)    ;-8*32
    \y=plry+Rnd(16*32)    ;-8*32
    \xs=0   ;(Rnd(4)-4) ASL 5
    \ys=0   ;-(Rnd(2) ASL 5)
    \delay=Rnd(50)
    \state=1
    \antable=Peek.l(anptrs)     ;anim 0 = explosion
    \image=Peek.w(\antable)
  Next
  Sound 4,15    ;explosion sound (all channels, full volume)
End Statement


.InitStatusBox
Statement InitStatusBox{}
  SHARED plrshield
  Use BitMap 2
  ;Cls 0
  Boxf 8,5,plrshield+8,8,15
  Boxf 8*8,2*8,((8+6)*8)-1,(3*8)-1,0
  ;Box 0,22,plrshield,29,1
End Statement



.DisplayStatus
Statement DisplayStatus{}
  ;actually, just display the score.
  ;I used to print out the score every cycle, but it seemed
  ;to take up a lot of uP time and the game often dropped
  ;down to half framerate when things got busy. Now I only print
  ;the score when a change has been made, and it seems to have
  ;smoothed things out a bit. The moral of the story? Get
  ;an SGI rendering engine. Or one of those machines that
  ;Evans & Sunderland run their flight simulators on.
  ;Totally groovy machines - really cool vector hardware...

  SHARED plrscore,dispscore,plrshield
  BitMapOutput 2
  If plrscore<>dispscore
    ;only print it if it's different to the score
    ;already being displayed
    Locate 8,2
    Print plrscore
    dispscore=plrscore
  EndIf
End Statement



.RestoreBitmaps
Statement RestoreBitmaps{}
  SHARED *bm,oldplanes(),i,j
  ;restore bitmaps (which are hacked about by the scrolling)

  For i=0 To 1                        ;bitmap loop
    *bm = Addr BitMap(i)
    For j=0 To 3                      ;plane loop
      *bm\_data[j]=oldplanes(i,j)
    Next
  Next
End Statement






.DisplayHiScores
Statement DisplayHiScores{}
  ;draws the hiscores onto the current bitmap

  SHARED hiscores()
  DEFTYPE.w i

  BlitMode CookieMode
  Cls 0
  PlonkChars{"todays top scores",0,0}

  USEPATH hiscores(i)
  For i=0 To 7
    PlonkChars{\name,0,(16*i)+32}
    PlonkChars{Str$(\score),160,(16*i)+32}
  Next
End Statement


.InsertScore
Statement InsertScore{pos.w,name.s,score.l}
  ;insert name and score into a position in the hiscore table

  SHARED hiscores()

  DEFTYPE.w i

  i=7
  While i > pos
    hiscores(i)\name=hiscores(i-1)\name
    hiscores(i)\score=hiscores(i-1)\score
    i=i-1
  Wend

  hiscores(pos)\name=name
  hiscores(pos)\score=score

End Statement



.EnterName
Function.s EnterName{}
  ;gets the player to enter his/her name

  SHARED chargrid$,keymode

  DEFTYPE.s name$,a$
  DEFTYPE.w x,y,b,timer,dx,dy,jdel,pos

  Use BitMap 0
  BitMapOutput 0
  Cls 0

  Slice 0,44,#WIDTH,#HEIGHT,$fff8,4,8,32,#WIDTH+32+16,#WIDTH+32+16
  Show 0
  Use Palette 0

  BlitMode CookieMode

  PlonkChars{"wow! a high score!",0,0}
  PlonkChars{"enter your name...",0,20}

  For y=0 To 5
    For x=0 To 6
      b = ConvertChar{Asc( Mid$( chargrid$,(y*7)+x+1,1 ) ) }
      If b<>-1 Then Blit b,64+(x*24),56+(y*24)
    Next
  Next

  x=0
  y=0
  dx=0:dy=0
  jdel=0
  pos=0
  name$=""

  Box 80,208,80+15,208+15,15

  DisplayOn

  Repeat
    b = ConvertChar{Asc( Mid$( chargrid$,(y*7)+x+1,1 ) ) }
    VWait
    timer=timer+1
    If timer=10
      If b=#FIRSTCHAR+39
        ;special case for space
        Box 64+(x*24),56+(y*24),64+(x*24)+15,56+(y*24)+15,15
      Else
        BlitMode SolidMode : Blit b,64+(x*24),56+(y*24)
      EndIf
    EndIf
    If timer=20
      If b=#FIRSTCHAR+39
        ;special case for space
        Box 64+(x*24),56+(y*24),64+(x*24)+15,56+(y*24)+15,0
        timer=0
      Else
        BlitMode CookieMode : Blit b,64+(x*24),56+(y*24) :timer=0
      EndIf
    EndIf

    jdel=jdel+1       ;jdel used to delay joystick movements
    If jdel=7 OR (keymode AND Inkey$<>"")
      jdel=0

      If keymode=On
        dx=0
        dy=0
        If RawStatus($19) Then dx=1
        If RawStatus($18) Then dx=0-1
        If RawStatus($31) Then dy=1
        If RawStatus($20) Then dy=0-1
      Else
        dx=Joyx(1)
        dy=Joyy(1)
      EndIf

      If dx<>0 OR dy<>0
        Sound 2,15
        If b=#FIRSTCHAR+39
        ;special case for space
          Box 64+(x*24),56+(y*24),64+(x*24)+15,56+(y*24)+15,0
        Else
          BlitMode CookieMode : Blit b,64+(x*24),56+(y*24)
        EndIf

        x=x+dx
        y=y+dy
        If x<0 Then x=6 : y=y-1
        If x>6 Then x=0 : y=y+1
        If y<0 Then y=5
        If y>5 Then y=0
        b = ConvertChar{Asc( Mid$( chargrid$,(y*7)+x+1,1 ) ) }
        If b=#FIRSTCHAR+39
          ;special case for space
          Box 64+(x*24),56+(y*24),64+(x*24)+15,56+(y*24)+15,15
        Else
          BlitMode SolidMode : Blit b,64+(x*24),56+(y*24)
        EndIf
      EndIf
    EndIf

    a$=""
    If (Joyb(1) AND keymode=Off) OR (RawStatus($40) AND keymode)
      If keymode=On
        Repeat : Until RawStatus($40)=Off
      Else
        Repeat : Until Joyb(1)=Off
      EndIf

        Sound 1,15
        a$=Mid$( chargrid$,(y*7)+x+1,1 )
        Select a$
          Case "@"    ;delete
            If pos>0
              If pos<8 Then Box 80+(pos*16),208,80+(pos*16)+15,208+15,0
              pos=pos-1
              Boxf 80+(pos*16),208,80+(pos*16)+15,208+15,0
              Box 80+(pos*16),208,80+(pos*16)+15,208+15,15
              name$=Left$(name$,Len(name$)-1)
            EndIf
          Case "#"    ;end

          Default
            If pos<8
              Box 80+(pos*16),208,80+(pos*16)+15,208+15,0
              BlitMode CookieMode
              Blit b,80+(16*pos),208
              name$=name$+a$
              pos=pos+1
              If pos<8 Then Box 80+(pos*16),208,80+(pos*16)+15,208+15,15
            EndIf
        End Select
    EndIf

  Until a$="#"



  DisplayOff
  FreeSlices

  Function Return name$
End Function



.MaybeNewHigh
Statement MaybeNewHigh{}
  ;see if player got a high score

  SHARED hiscores(),plrscore

  DEFTYPE.w i,slot

  slot=-1
  i=0
  Repeat
    If plrscore>=hiscores(i)\score Then slot=i
    i=i+1
  Until i=8 OR slot<>-1

  If slot<>-1 Then InsertScore{slot,EnterName{},plrscore}
End Statement


Statement Wibble{}
  Use BitMap 0
  BitMapOutput 0
  Cls 0

  Slice 0,44,#WIDTH,#HEIGHT,$fff8,4,8,32,#WIDTH+32+16,#WIDTH+32+16
  Show 0
  Use Palette 0
  BlitMode CookieMode
  CentrePlonk{"and so the aliens",60}
  CentrePlonk{"were defeated.",80}
  DisplayOn

  WaitForClick{-1}
  Cls 0
  CentrePlonk{"as it happened",20}
  CentrePlonk{"the entire alien",40}
  CentrePlonk{"invasion turned",60}
  CentrePlonk{"out to be an",80}
  CentrePlonk{"advertising stunt",100}
  CentrePlonk{"pulled by a rather",120}
  CentrePlonk{"well known soft-",140}
  CentrePlonk{"drink company.",160}
  WaitForClick{-1}
  Cls 0
  CentrePlonk{"you get yourself",20}
  CentrePlonk{"a good agent",40}
  CentrePlonk{"and make a fortune",60}
  CentrePlonk{"on the tv chat",80}
  CentrePlonk{"show circuit",100}
  CentrePlonk{"and...",140}

  WaitForClick{-1}
  Cls 0
  CentrePlonk{"everyone lives",20}
  CentrePlonk{"happily ever after.",40}
  WaitForClick{-1}
  CentrePlonk{"except for the",80}
  CentrePlonk{"aliens who really",100}
  CentrePlonk{"didnt have very",120}
  CentrePlonk{"much fun at all.",140}

  WaitForClick{-1}
  Cls 0
  CentrePlonk{"game over",120}
  WaitForClick{-1}

  DisplayOff
  FreeSlices
  VWait 10

End Statement


.Title
Function.w Title{}
  SHARED i,j,keymode

  DEFTYPE.w startflag,tstate,delay,esc


  startflag=Off
  tstate=0
  delay=0

  Repeat
    VWait
    delay=delay-1
    If delay<0

      Select tstate

        ;Credits
        Case 0
          DisplayOff
          FreeSlices
          Slice 0,44,320,124,$fff8,4,8,32,320,320
          Show 3
          Use Palette 5

          Slice 1,44+128,320,128,$fff8,4,8,32,#WIDTH+32+16,#WIDTH+32+16
          Show 0
          Use Palette 0
          Use BitMap 0
          Cls 0

          DisplayOn
          BlitMode CookieMode
          Boxf 0,128,319,255,0
          CentrePlonk{"ben campbell",128+16}
          CentrePlonk{"programming",128+48}
          CentrePlonk{"graphics",128+66}

          For i=0 To 128 Step 8 : VWait : Show 0,0,i : Next

          delay=200
          tstate=1
        Case 1
          Boxf 0,0,319,127,0

          CentrePlonk{"js hong",24}
          CentrePlonk{"graphics",56}

          For i=128 To 0 Step -8 :VWait : Show 0,0,i : Next

          delay=200
          tstate=2
        Case 2
          Boxf 0,128,319,255,0
          CentrePlonk{"written in",128+40}
          CentrePlonk{"blitz basic ii",128+60}
          tstate=3
          delay=200
          For i=0 To 128 Step 8 : VWait : Show 0,0,i : Next
        Case 3
          Boxf 0,0,319,127,0
          CentrePlonk{"kill bad dudes",20}
          Blit #FIRSTBOB+25,96,50
          Blit #FIRSTBOB+62,120,50
          Blit #FIRSTBOB+71,144,50
          Blit #FIRSTBOB+67,168,50
          Blit #FIRSTBOB+30,192,50
          tstate=4
          delay=200
          For i=128 To 0 Step -8 : VWait : Show 0,0,i : Next
        Case 4
          Boxf 0,128,319,255,0
          CentrePlonk{"collect bonuses",128+20}
          Blit #FIRSTBOB+12,96,128+50
          Blit #FIRSTBOB+13,120,128+50
          Blit #FIRSTBOB+14,144,128+50
          Blit #FIRSTBOB+15,168,128+50
          Blit #FIRSTBOB+16,192,128+50
          tstate=5
          delay=200
          For i=0 To 128 Step 8 :VWait : Show 0,0,i : Next
        Case 5
          Boxf 0,0,319,127,0
          CentrePlonk{"press space or fire",50}
          CentrePlonk{"to start",70}
          tstate=6
          delay=200
          For i=128 To 0 Step -8 : VWait : Show 0,0,i : Next
        Case 6
          Use BitMap 1
          DisplayHiScores{}
          DisplayOff
          FreeSlices
          Slice 0,44,320,256,$fff8,4,8,32,#WIDTH+32+16,#WIDTH+32+16
          Show 1
          Use Palette 0
          DisplayOn
          tstate=0
          delay=500
      End Select


    EndIf

    i=Rnd(16)     ;seed

    esc=RawStatus($45)
    If RawStatus($40) Then keymode=On : startflag=On
    If Joyb(1) Then keymode=Off :startflag=On

  Until startflag OR esc

  DisplayOff
  FreeSlices
  Function Return esc
End Function


;*************************
.MAIN
;*************************
;

DisplayOff
;allocate bitmaps
BitMap 0,#WIDTH+16+16+16,#HEIGHT+20+32,4
BitMap 1,#WIDTH+16+16+16,#HEIGHT+20+32,4
;BitMap 2,#WIDTH,30,4
;Use BitMap 2
;Cls 0

Buffer 0,$8000                      ;\___allocate bob buffers
Buffer 1,$8000                      ;/

;get first tile shape: a blank (cludge around the mapeditor)
Use BitMap 0
Cls 0
GetaShape #FIRSTTILE,0,0,16,16
GetaShape #FIRSTTILE+256,0,0,16,16
GetaShape #FIRSTTILE+512,0,0,16,16

;init chargrid$
chargrid$="abcdefghijklmnopqrstuvwxyz0123456789.-! @#"

;save out bitplane pointers in the oldplanes array
For i=0 To 1                        ;bitmap loop
  *bm = Addr BitMap(i)
  For j=0 To 3                      ;plane loop
    oldplanes(i,j)=*bm\_data[j]
  Next
Next

;setup sine lookup table
For i=0 To 360
  sinlt(i)=Sin(i*(Pi/180))*127 *32
Next

;set up level structures
For i=0 To #NUMOFLEVELS-1
  For j=0 To 15
    Read levs(i)\wave[j]
  Next
  Read levs(i)\endwave
  Read levs(i)\pal
  Read levs(i)\map
  Read levs(i)\firsttile
Next


USEPATH hiscores(i)
For i=0 To 7
  Read \name
Next
For i=0 To 7
  Read \score
Next

mapsbase=?Maps
wavedata=?AttackWaves
anptrs=?AnTablePtrs

keymode=On


;install some error-handling.
;actually probably pretty pointless - the sorts of errors
;that I get generally make the computer go BLUUUUUUUUURRRRGGGG
;and set the battery-backed-up clock to 1978.
;but hey, what the hell...

While Title{}=Off               ;do title and check for exit

  ;new game
  plrscore=0
  dispscore=-1          ;force the score display
  plrshield=#MAXSHIELD
  level=0
  InitStatusBox{}
  For i=0 To 4
    btime(i)=0
  Next

  ;level loop starts here
  Repeat

    InitLevel{}

    .MAINLOOP

    Repeat

      ;wait for start of new frame
      VWait
      ;Kludge alert!
      Poke.w $DFF106,0        ;make sure aga sprites are lowres...
      Poke.w $DFF1FC,0        ;...and only one word wide (aga stuff)

      ;display physical bitmap
      Show phys,xfine+16,16

      ;display sprites...
      DisplaySprites{}

      ;do all drawing operations on logical bitmap
      Use BitMap logi

      ;wipe bobs from logical bitmap
      UnBuffer logi

      ;suss out scrolling
      If scrollspeed=1
        xfine=xfine+1
        If xfine>=16                        ;need to coarse-scroll?
          xfine=xfine-16
          xcoarse=xcoarse+1
        EndIf
      EndIf

      ;update bitmap pointers if needed
      *bm=Addr BitMap(logi)
      *bm\_data[0]=oldplanes(logi,0)+(xcoarse*2)
      *bm\_data[1]=oldplanes(logi,1)+(xcoarse*2)
      *bm\_data[2]=oldplanes(logi,2)+(xcoarse*2)
      *bm\_data[3]=oldplanes(logi,3)+(xcoarse*2)


      If scrollspeed=1
        ;draw blocks coming in on right of screen
        ;(we draw 2 blocks per cycle, so by the time the screen
        ;has moved 16 pixels (16 cycles), we've got a fresh column
        ;of 16 blocks ready to scroll in on both bitmaps)

        i=xfine/2
        If i<(#MAPHEIGHT/2)
          If xcoarse<#MAPWIDTH
            ;blit up blocks from mapdata
            p=mapbuffer+xcoarse+(i*2*#MAPWIDTH)
            j=Peek.b(p)
            If j<0 Then j=j+256
            Block firsttile+j,#WIDTH+32,(i ASL 5)+16
            j=Peek.b(p+#MAPWIDTH)
            If j<0 Then j=j+256
            Block firsttile+j,#WIDTH+32,(i ASL 5)+32
          Else
            ;run out of map data - just do blanks
            Block firsttile,#WIDTH+32,(i ASL 5)+16
            Block firsttile,#WIDTH+32,(i ASL 5)+32
          EndIf
        EndIf

        If xcoarse>=#MAPWIDTH+1               ;60 for shortmap
          ;reached the end of the level...
          gamestatus=1
          scrollspeed=0
          Zooooooom{}
        EndIf

      EndIf

      ;suss out movements/collisions/other stuff

      If gamestatus<10
        ;don't want to do this stuff if player dead/dying...
        If gamestatus<>1 Then CheckCollisions{}
        MovePlayer{}          ;read joystick, move player etc
      EndIf
      MoveBullets{}         ;update player bullet positions

      UpdateDudes{}           ;move any onscreen dudes
      NewWaves{}
      UpdateBTimers{}         ;update bonus timers

      ;draw up the bobs
      Use BitMap logi
      DrawDudes{}

      DisplayStatus{}

      If plrshield<=0 AND gamestatus<10
        ;start player explosion
        gamestatus=10
        BlowUpPlayer{}
        scrollspeed=0
      EndIf

      ;swap physical and logical bitmaps
      phys=logi
      logi=1-logi

    Until (gamestatus=12) OR (gamestatus=4)   ; OR Joyb(0)

    DisplayOff
    FlushBuffer 0
    FlushBuffer 1

    RestoreBitmaps{}

    If gamestatus=4 Then level=level+1

    FreeSlices
  Until gamestatus=12 OR level=#NUMOFLEVELS     ; OR Joyb(0)

  If level=#NUMOFLEVELS Then Wibble{}
  MaybeNewHigh{}              ;check for new highscore
Wend

.Cleanup
VWait 4:AMIGA     ;restore the system,
RestoreBitmaps{}  ;restore the bitmap structs,
OpenWorkBench_
WBenchToFront_    ;restore the view,
End               ;and bugger off!

;***************************************************

Even


;here is a problem - I can't seem to use constants or expressions
;within data statements... heavy bummer...

;level0 - mountains
Data.w 2,2,2,2,2,2,2,2,0,1,2,3,4,5,6,7    ;waves
Data.w 10                                 ;end of level wave
Data.w 2                                  ;palette
Data.w 0                                  ;map
Data.w 498                                ;=#FIRSTTILE+256

;level1 - tech
Data.w 8,9,11,12,13,14,15,16,0,2,3,4,5,6,7,12    ;waves
Data.w 17                                 ;end of level wave
Data.w 1                                  ;palette
Data.w 1                                  ;map
Data.w 242                                ;=#FIRSTTILE

;level2 - tech
Data.w 8,9,11,12,13,14,15,16,8,9,11,12,13,14,15,16    ;waves
Data.w 18                                 ;end of level wave
Data.w 1                                  ;palette
Data.w 2                                  ;map
Data.w 242                                ;=#FIRSTTILE

;level3 - dark level
Data.w 19,20,21,23,24,19,20,21,23,24,19,20,21,24,3,4
Data.w 22
Data.w 3
Data.w 3
Data.w 754

;initial hiscores
Data.s "this","is","the","high","score","table.","","wow."
Data.l 16000,14000,12000,10000,8000,6000,4000,2000


;BAD DUDE ANIMATION TABLES
;(-1 = end of table)

An0:      ;explosion anim - all palettes
Dc.w  0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9
Dc.w  10,10,10,11,11,11,-1

An1:      ;Blue missile thing (facing left) - all palettes
Dc.w 22,22,23,23,-1

An2:      ;Rotating blue ship (facing left) - all palettes
Dc.w 24,24,25,25,26,26,27,27,28,28,29,29,-1

An3:      ;Spinning sawblade-esque thing - all palettes
Dc.w 30,30,31,31,32,32,33,33,-1

An4:      ;Pulsating gold sphere - tech palette only
Dc.w 60,60,60,61,61,61,62,62,62,61,61,61,-1

An5:      ;Wobbly jellyfishesque dude - tech
Dc.w 63,63,63,64,64,64,65,65,65,64,64,64,-1

An6:      ;Big gold ship facing right - tech
Dc.w 66,-1

An7:      ;Big gold ship facing left - tech
Dc.w 67,-1

An8:      ;Little gold ship facing right - tech
Dc.w 68,-1

An9:      ;little gold ship facing left - tech
Dc.w 69,-1

An10:     ;rotating sphere
Dc.w 70,70,71,71,72,72,73,73,-1

An11:     ;accordian dude
Dc.w 74,74,74,75,75,75,76,76,76,77,77,77,76,76,76,75,75,75,-1

An12:     ;falcon1 (left)
Dc.w 78,-1

An13:     ;falcon2 (right)
Dc.w 79,-1

An14:     ;big dude 1
Dc.w 150,-1

An15:     ;big dude 2
Dc.w 151,-1

An16:     ;rotating sparkthing (all palettes)
Dc.w 34,34,34,35,35,35,36,36,36,37,37,37,-1

An17:     ;fighter (dark palette)
Dc.w  100,100,101,101,102,102,103,103,-1

An18:     ;flying saucers (dark)
Dc.w  104,104,104,105,105,105,106,106,106,107,107,107,-1

An19: ;electric arc (any palette)
Dc.w  152,152,152,153,153,153,154,154,154,155,155,155,-1

An20: ;endoflevel dude 3 (dark)
Dc.w 156,156,156,157,157,157,158,158,158,159,159,159,-1

An21: ;rotating thingys (dark)
Dc.w 108,108,109,109,110,110,111,111,112,112,113,113,-1


;pointers to animtables (spot the asm programmer!)
AnTablePtrs:
Dc.l An0,An1,An2,An3,An4,An5,An6,An7,An8,An9,An10,An11,An12,An13,An14
Dc.l An15,An16,An17,An18,An19,An20,An21


;BACKGROUND BLOCKMAPS

Maps:
IncBin "inc/maps/MountainsMap"
IncBin "inc/maps/TechMap1"
IncBin "inc/maps/TechMap2"
IncBin "inc/maps/DarkMap"


AttackWaves:
;  state.w             ;update routine 0=inactive, 1=exploding
;  energy.w
;  x.w                 ;\___position 11.5 format (ie 5 bitshifts)
;  y.w                 ;/
;  xs.w                ;\___speed (11.5 format)
;  ys.w                ;/
;  antable.w           ;anim table # to use
;  delay.w
;  dat0.w              ;assorted data
;  dat1.w
;  dat2.w
;  dat3.w
.ATTACKWAVES

;general waves - any palette

;wave 0 - line starting at bottomright, accelerating to topleft
Dc.w  16,1,330*32,160*32,-1*32,16,3,00,-2,-1,0,0
Dc.w  16,1,330*32,160*32,-1*32,16,3,05,-2,-1,0,0
Dc.w  16,1,330*32,160*32,-1*32,16,3,10,-2,-1,0,0
Dc.w  16,1,330*32,160*32,-1*32,16,3,15,-2,-1,0,0
Dc.w  16,1,330*32,160*32,-1*32,16,3,20,-2,-1,0,0
Dc.w  16,1,330*32,160*32,-1*32,16,3,25,-2,-1,0,0
Dc.w  16,1,330*32,160*32,-1*32,16,3,30,-2,-1,0,0
Dc.w  16,1,330*32,160*32,-1*32,16,3,35,-2,-1,0,0

;wave 1 - left to right parabolic
Dc.w  16,1,330*32,40*32,-2*32,5*32,2,0,-1,-3,0,0
Dc.w  16,1,330*32,40*32,-2*32,5*32,2,10,-1,-3,0,0
Dc.w  16,1,330*32,40*32,-2*32,5*32,2,20,-1,-3,0,0
Dc.w  16,1,330*32,40*32,-2*32,5*32,2,30,-1,-3,0,0
Dc.w  16,1,330*32,40*32,-2*32,5*32,2,40,-1,-3,0,0
Dc.w  16,1,330*32,40*32,-2*32,5*32,2,50,-1,-3,0,0
Dc.w  16,1,330*32,40*32,-2*32,5*32,2,60,-1,-3,0,0
Dc.w  16,1,330*32,40*32,-2*32,5*32,2,70,-1,-3,0,0

;wave 2 - left to right sine wave
Dc.w  11,1,330*32,75*32,-3*32,4,2,0,0,75*32,0,0
Dc.w  11,1,330*32,85*32,-3*32,4,2,10,0,85*32,0,0
Dc.w  11,1,330*32,95*32,-3*32,4,2,20,0,95*32,0,0
Dc.w  11,1,330*32,105*32,-3*32,4,2,30,0,105*32,0,0
Dc.w  11,1,330*32,115*32,-3*32,4,2,40,0,115*32,0,0
Dc.w  11,1,330*32,125*32,-3*32,4,2,50,0,125*32,0,0
Dc.w  11,1,330*32,135*32,-3*32,4,2,60,0,135*32,0,0
Dc.w  11,1,330*32,145*32,-3*32,4,2,70,0,145*32,0,0

;wave 3 - come in from top, sweep left
Dc.w  16,1,100*32,-40*32,1*32,120,3,70,-2,-1,0,0
Dc.w  16,1,130*32,-40*32,1*32,120,3,60,-2,-1,0,0
Dc.w  16,1,160*32,-40*32,1*32,120,3,50,-2,-1,0,0
Dc.w  16,1,190*32,-40*32,1*32,120,3,40,-2,-1,0,0
Dc.w  16,1,220*32,-40*32,1*32,120,3,30,-2,-1,0,0
Dc.w  16,1,250*32,-40*32,1*32,120,3,20,-2,-1,0,0
Dc.w  16,1,280*32,-40*32,1*32,120,3,10,-2,-1,0,0
Dc.w  16,1,310*32,-40*32,1*32,120,3,0,-2,-1,0,0

;wave 4 - random bunch going left
Dc.w  16,1,330*32,80*32,-4*32,0,2,17,-1,0,0,0
Dc.w  16,1,330*32,32*32,-4*32,0,2,28,-1,0,0,0
Dc.w  16,1,330*32,146*32,-4*32,0,2,35,-1,0,0,0
Dc.w  16,1,330*32,89*32,-4*32,0,2,30,-1,0,0,0
Dc.w  16,1,330*32,184*32,-4*32,0,2,46,-1,0,0,0
Dc.w  16,1,330*32,96*32,-4*32,0,2,0,-1,0,0,0
Dc.w  16,1,330*32,145*32,-4*32,0,2,15,-1,0,0,0
Dc.w  16,1,330*32,73*32,-4*32,0,2,9,-1,0,0,0

;wave 5 - interleaved sinewave going left
Dc.w  11,1,330*32,0*32,-2*32,6,2,0,180,100*32,0,0
Dc.w  11,1,350*32,0*32,-2*32,6,2,0,000,100*32,0,0
Dc.w  11,1,370*32,0*32,-2*32,6,2,0,180,100*32,0,0
Dc.w  11,1,390*32,0*32,-2*32,6,2,0,000,100*32,0,0
Dc.w  11,1,410*32,0*32,-2*32,6,2,0,180,100*32,0,0
Dc.w  11,1,430*32,0*32,-2*32,6,2,0,000,100*32,0,0
Dc.w  11,1,450*32,0*32,-2*32,6,2,0,180,100*32,0,0
Dc.w  11,1,470*32,0*32,-2*32,6,2,0,000,100*32,0,0

;wave 6 - randomly bouncing dudes, coming in from left
Dc.w  12,1,-110*32,100*32,32,1,3,0,80,100*32,0,0
Dc.w  12,1,-50*32,120*32,32,1,3,0,10,120*32,0,0
Dc.w  12,1,-90*32,60*32,32,1,3,0,190,60*32,0,0
Dc.w  12,1,-120*32,40*32,32,1,3,0,020,80*32,0,0
Dc.w  12,1,-150*32,90*32,32,1,3,0,300,90*32,0,0
Dc.w  12,1,-40*32,130*32,32,1,3,0,200,130*32,0,0
Dc.w  12,1,-80*32,150*32,32,1,3,0,270,150*32,0,0
Dc.w  12,1,-160*32,100*32,32,1,3,0,30,100*32,0,0

;wave 7 - horizontal sine wobble
Dc.w  13,1,330*32,40*32,-1*32,4,3,0,0,330*32,0,0
Dc.w  13,1,330*32,60*32,-1*32,4,3,4,0,330*32,0,0
Dc.w  13,1,330*32,80*32,-1*32,4,3,8,0,330*32,0,0
Dc.w  13,1,330*32,100*32,-1*32,4,3,12,0,330*32,0,0
Dc.w  13,1,330*32,120*32,-1*32,4,3,16,0,330*32,0,0
Dc.w  13,1,330*32,140*32,-1*32,4,3,20,0,330*32,0,0
Dc.w  13,1,330*32,160*32,-1*32,4,3,24,0,330*32,0,0
Dc.w  13,1,330*32,180*32,-1*32,4,3,28,0,330*32,0,0

;Tech waves - tech palette only

;wave 8 - sine formation from right
Dc.w  11,2,330*32,100*32,-2*32,4,7,10,0,70*32,0,0
Dc.w  11,1,330*32,100*32,-2*32,4,9,20,0,80*32,0,0
Dc.w  11,2,330*32,100*32,-2*32,4,7,30,0,90*32,0,0
Dc.w  11,1,330*32,100*32,-2*32,4,9,40,0,100*32,0,0
Dc.w  11,2,330*32,100*32,-2*32,4,7,50,0,110*32,0,0
Dc.w  11,1,330*32,100*32,-2*32,4,9,60,0,120*32,0,0
Dc.w  11,2,330*32,100*32,-2*32,4,7,70,0,130*32,0,0
Dc.w  11,1,330*32,100*32,-2*32,4,9,80,0,140*32,0,0

;wave 9 - sine formation from left
Dc.w  11,1,-30*32,100*32,32,4,8,0,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,32,4,8,10,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,32,4,8,20,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,32,4,8,30,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,32,4,8,40,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,32,4,8,50,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,32,4,8,60,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,32,4,8,70,0,100*32,0,0


;wave 10 - end of level wave 1
Dc.w  17,8,330*32,90*32,0,5,1,2,0,80*32,180*32,0      ;wave10
Dc.w  17,8,330*32,120*32,0,6,1,4,0,120*32,190*32,0
Dc.w  17,8,330*32,130*32,0,7,1,6,0,90*32,200*32,0
Dc.w  17,8,330*32,105*32,0,6,1,8,0,105*32,210*32,0
Dc.w  17,8,330*32,115*32,0,5,1,10,0,115*32,220*32,0
Dc.w  17,8,330*32,100*32,0,8,1,12,0,70*32,230*32,0
Dc.w  17,8,330*32,90*32,0,6,1,14,0,90*32,240*32,0
Dc.w  17,8,330*32,125*32,0,9,1,16,0,125*32,250*32,0

;wave 11 - sine formation from left (spheres)
Dc.w  11,1,-30*32,100*32,2*32,4,4,0,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,2*32,4,4,3,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,2*32,4,4,6,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,2*32,4,4,9,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,2*32,4,4,12,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,2*32,4,4,15,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,2*32,4,4,18,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,2*32,4,4,21,0,100*32,0,0

;wave 12 - bouncy formation from right
Dc.w  12,1,330*32,40*32,-64,0,5,0,0,0,0,0
Dc.w  12,1,330*32,40*32,-66,0,5,5,0,0,0,0
Dc.w  12,1,330*32,40*32,-68,0,5,10,0,0,0,0
Dc.w  12,1,330*32,40*32,-70,0,5,15,0,0,0,0
Dc.w  12,1,330*32,40*32,-72,0,5,20,0,0,0,0
Dc.w  12,1,330*32,40*32,-74,0,5,25,0,0,0,0
Dc.w  12,1,330*32,40*32,-76,0,5,30,0,0,0,0
Dc.w  12,1,330*32,40*32,-78,0,5,35,0,0,0,0

;wave 13 - sine waves from both sides
Dc.w  11,1,330*32,100*32,-64,2,11,00,0,100*32,0,0
Dc.w  11,1,330*32,100*32,-64,2,11,20,0,100*32,0,0
Dc.w  11,1,330*32,100*32,-64,2,11,40,0,100*32,0,0
Dc.w  11,1,330*32,100*32,-64,2,11,60,0,100*32,0,0
Dc.w  11,1,-30*32,100*32,64,2,11,00,90,100*32,0,0
Dc.w  11,1,-30*32,100*32,64,2,11,20,90,100*32,0,0
Dc.w  11,1,-30*32,100*32,64,2,11,40,90,100*32,0,0
Dc.w  11,1,-30*32,100*32,64,2,11,60,90,100*32,0,0

;wave 14 - mean sine wave from behind
Dc.w  11,3,-30*32,100*32,32,2,10,000,0,70*32,0,0
Dc.w  11,3,-30*32,100*32,32,2,10,150,0,80*32,0,0
Dc.w  11,3,-30*32,100*32,32,2,10,300,0,90*32,0,0
Dc.w  11,3,-30*32,100*32,32,2,10,450,0,100*32,0,0
Dc.w  11,3,-30*32,100*32,32,2,10,000,90,110*32,0,0
Dc.w  11,3,-30*32,100*32,32,2,10,150,90,120*32,0,0
Dc.w  11,3,-30*32,100*32,32,2,10,300,90,130*32,0,0
Dc.w  11,3,-30*32,100*32,32,2,10,450,90,140*32,0,0

;wave 15 - squiggly wave from right
Dc.w  14,2,330*32,100*32,2,2,10,0,90,330*32,0,70*32
Dc.w  14,2,330*32,100*32,2,2,10,10,90,340*32,0,80*32
Dc.w  14,2,330*32,100*32,2,2,10,20,90,350*32,0,90*32
Dc.w  14,2,330*32,100*32,2,2,10,30,90,360*32,0,100*32
Dc.w  14,2,330*32,100*32,2,2,10,40,90,370*32,0,110*32
Dc.w  14,2,330*32,100*32,2,2,10,50,90,380*32,0,120*32
Dc.w  14,2,330*32,100*32,2,2,10,60,90,390*32,0,130*32
Dc.w  14,2,330*32,100*32,2,2,10,70,90,400*32,0,140*32

;wave 16 - circular wave from right
Dc.w  14,2,330*32,100*32,4,4,10,0,90,330*32,0,100*32
Dc.w  14,2,330*32,100*32,4,4,10,0,100,330*32,10,100*32
Dc.w  14,2,330*32,100*32,4,4,10,0,110,330*32,20,100*32
Dc.w  14,2,330*32,100*32,4,4,10,0,120,330*32,30,100*32
Dc.w  14,2,330*32,100*32,4,4,10,0,130,330*32,40,100*32
Dc.w  14,2,330*32,100*32,4,4,10,0,140,330*32,50,100*32
Dc.w  14,2,330*32,100*32,4,4,10,0,150,330*32,60,100*32
Dc.w  14,2,330*32,100*32,4,4,10,0,160,330*32,70,100*32

;wave 17 - end of level wave 2
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  19,50,284*32,80*32,0,0,14,0,0,0,0,0

;wave 18 - end of level wave 3
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  19,40,284*32,80*32,0,0,15,0,0,0,0,0
Dc.w  19,40,284*32,80*32,0,0,15,40,0,0,0,0

;dark palette waves

;wave 19 - squiggly, right to left
Dc.w  14,4,330*32,100*32,2,2,17,0,90,330*32,0,70*32
Dc.w  14,4,330*32,100*32,2,2,17,10,90,340*32,0,80*32
Dc.w  14,4,330*32,100*32,2,2,17,20,90,350*32,0,90*32
Dc.w  14,4,330*32,100*32,2,2,17,30,90,360*32,0,100*32
Dc.w  14,4,330*32,100*32,2,2,17,40,90,370*32,0,110*32
Dc.w  14,4,330*32,100*32,2,2,17,50,90,380*32,0,120*32
Dc.w  14,4,330*32,100*32,2,2,17,60,90,390*32,0,130*32
Dc.w  14,4,330*32,100*32,2,2,17,70,90,400*32,0,140*32

;wave 20 - come in from bottom, sweep left
Dc.w  16,1,110*32,240*32,1*16,-120,18,70,-2,1,0,0
Dc.w  16,1,140*32,240*32,1*16,-120,18,60,-2,1,0,0
Dc.w  16,1,170*32,240*32,1*16,-120,18,50,-2,1,0,0
Dc.w  16,1,200*32,240*32,1*16,-120,18,40,-2,1,0,0
Dc.w  16,1,230*32,240*32,1*16,-120,18,30,-2,1,0,0
Dc.w  16,1,260*32,240*32,1*16,-120,18,20,-2,1,0,0
Dc.w  16,1,290*32,240*32,1*16,-120,18,10,-2,1,0,0
Dc.w  16,1,320*32,240*32,1*16,-120,18,0,-2,1,0,0

;wave 21 - horizonal sinewall
Dc.w  13,8,330*32,15*32,-1*32,4,21,0,0,330*32,0,0
Dc.w  13,8,330*32,40*32,-1*32,4,21,4,0,330*32,0,0
Dc.w  13,8,330*32,65*32,-1*32,4,21,8,0,330*32,0,0
Dc.w  13,8,330*32,90*32,-1*32,4,21,12,0,330*32,0,0
Dc.w  13,8,330*32,115*32,-1*32,4,21,16,0,330*32,0,0
Dc.w  13,8,330*32,140*32,-1*32,4,21,20,0,330*32,0,0
Dc.w  13,8,330*32,165*32,-1*32,4,21,24,0,330*32,0,0
Dc.w  13,8,330*32,190*32,-1*32,4,21,28,0,330*32,0,0

;wave 22 - end of level wave for level 4 (dark palette)
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  0,0,0,0,0,0,0,0,0,0,0,0
Dc.w  5,1,256*32,64*32,0,0,19,0,0,0,0,0
Dc.w  5,1,256*32,128*32,0,0,19,0,0,0,0,0
Dc.w  20,50,248*32,104*32,0,0,20,0,0,0,0,0

;wave 23 -  right to left sine wave (dark)
Dc.w  11,2,330*32,75*32,-2*32,4,21,0,0,75*32,0,0
Dc.w  11,2,330*32,85*32,-2*32,4,21,10,0,85*32,0,0
Dc.w  11,2,330*32,95*32,-2*32,4,21,20,0,95*32,0,0
Dc.w  11,2,330*32,105*32,-2*32,4,21,30,0,105*32,0,0
Dc.w  11,2,330*32,115*32,-2*32,4,21,40,0,115*32,0,0
Dc.w  11,2,330*32,125*32,-2*32,4,21,50,0,125*32,0,0
Dc.w  11,2,330*32,135*32,-2*32,4,21,60,0,135*32,0,0
Dc.w  11,2,330*32,145*32,-2*32,4,21,70,0,145*32,0,0

;wave 24 - mean sine wave from behind (dark)
Dc.w  11,3,-30*32,100*32,16,2,18,000,0,70*32,0,0
Dc.w  11,3,-30*32,100*32,16,2,18,100,0,80*32,0,0
Dc.w  11,3,-30*32,100*32,16,2,18,200,0,90*32,0,0
Dc.w  11,3,-30*32,100*32,16,2,18,300,0,100*32,0,0
Dc.w  11,3,-30*32,100*32,16,2,18,400,0,110*32,0,0
Dc.w  11,3,-30*32,100*32,16,2,18,500,0,120*32,0,0
Dc.w  11,3,-30*32,100*32,16,2,18,600,0,130*32,0,0
Dc.w  11,3,-30*32,100*32,16,2,18,700,0,140*32,0,0


