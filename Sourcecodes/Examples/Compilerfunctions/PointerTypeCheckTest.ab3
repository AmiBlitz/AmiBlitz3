; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "ram:"
; ExeFile         = "PointerTypeCheckTest"
; CreateIcon      = 0
; Residents       = "all.res,SDSTCP2.res,xpk.res,ttengine.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 100000
; MakeSmallest    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 51
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8192
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 102
; CursorColumn    = 1
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 100
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 100
; Max GadgetList  = 100
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 200
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 100
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 1
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 10
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 100
; Max BlitzFont   = 1
; Max GTList      = 100
; /XTRA
optimize 7
Syntax 6


NEWTYPE.parent_t   ; this is our super class
  field.l
End NEWTYPE

NEWTYPE.child_t    ; this is our sub class
  parent.parent_t
  field2.l
End NEWTYPE

NEWTYPE.stranger_t ; this is an unrelated class
  field.l
End NEWTYPE


Function.parent_t parent_new{}     ; constructor for parent
  *this.parent_t = AllocVec_(SizeOf.parent_t,#MEMF_ANY)
  Function Return *this
End Function

Function.child_t child_new{}       ; constructor for child
  *this.child_t = AllocVec_(SizeOf.child_t,#MEMF_ANY)
  Function Return *this
End Function

Function.stranger_t stranger_new{} ; constructor for stranger
  *this.stranger_t = AllocVec_(SizeOf.stranger_t,#MEMF_ANY)
  Function Return *this
End Function


Statement parent_delete{*this.parent_t} ; destructor for parent
  FreeVec_ *this
End Statement

Statement child_delete{*this.child_t} ; destructor for parent
  FreeVec_ *this
End Statement

Statement stranger_delete{*this.stranger_t} ; destructor for parent
  FreeVec_ *this
End Statement


Statement parent_method{*this.parent_t,param.l} ; final method
  *this\field = param
End Statement

Statement child_method{*this.child_t,param.l}   ; final method
  *this\parent\field = param
  *this\field2       = param
End Statement

Statement stranger_method{*this.stranger_t,param.l} ; final method
  *this\field = param
End Statement

; pointer tunneling as long
long.l = parent_new{}  ; shall this work?
;parent_delete{long}    ; and this? dunno.

; construct objects
*p.parent_t    = parent_new  {}  ; construct a new parent
*c.child_t     = child_new   {}  ; construct a new child
*s.stranger_t  = stranger_new{}  ; construct a new stranger

; test assignments
*p2.parent_t   = *p ; type match, ok
*p2.parent_t   = *c ; generalize, ok (requires "deep check")
*p2.parent_t   = *s ; type mismatch, fail !

*c2.child_t    = *p ; specialize, fail (needs cast)
*c2.child_t    = *c ; type match, ok
*c2.child_t    = *s ; type mismatch, fail

*s2.stranger_t = *p ; type mismatch, fail
*s2.stranger_t = *c ; type mismatch, fail
*s2.stranger_t = *s ; type match, ok

; test method calls
parent_method{*p,12345}   ; type match, ok
;parent_method{*c,12345}   ; generalize, ok
;parent_method{*s,12345}   ; type mismatch, fail

;child_method{*p,12345}    ; specialize, fail
child_method{*c,12345}    ; type match, ok
;child_method{*s,12345}    ; type mismatch, fail

;stranger_method{*p,12345} ; type mismatch, fail
;stranger_method{*c,12345} ; type mismatch, fail
stranger_method{*s,12345} ; type match, ok

; destroy objects
parent_delete{*p}
child_delete{*c}
stranger_delete{*s}

End

