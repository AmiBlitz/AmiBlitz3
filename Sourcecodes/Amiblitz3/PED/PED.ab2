;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: PED                                                                   /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, AmigaOS4, MOS                         /
;/                                                                             /
;/ Date: 01.09.2009                                                            /
;/                                                                             /
;/ Authors: 1990...1996 Mark Silby                                             /
;/          1991...2003 Red When Excited                                       /
;/          2003...2009 Bernd Roesch, Sven Droege                              /
;/          2009...2010 Thilo Koehler, Thomas Klein                            /
;/                                                                             /
;/ Requirements: AmigaOS3.1+                                                   /
;/                                                                             /
;/ Purpose:                                                                    /
;/ GUI for AmiBlitz3 programming language.                                     /
;/                                                                             /
;/ Abstract:                                                                   /
;/ This is not a stand alone program. It is launched by the AmiBlitz3 compiler./
;/ See AmiBlitz3 abstract.                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////

default_assign$ = "Blitz3:"
DEBUG
; -------------------------------------------------------
; KONSTANTENDEFINITIONEN
; -------------------------------------------------------
.CONST
#hardfold                    = 0     ;not working
;#lang                        = 0     ;0 english 1 german
#filenamepos                 = 27    ;startpos of fileclocknames
#filenameoffs                = 11    ;space betweeen a filename
#experiment                  = 1     ;free now
#MAX_Columns                 = 250   ;dont set higher than   = 250

#use_NTUI                    = 0     ; use NTUI

#maxlabels                   = 512
#maxhistory                  = 4*8
#MAX_SOURCEFILES             = 16

#MinByteSgnd                 = $80
#MaxByte                     = $FF
#MaxWordSgnd                 = $7FFF
#MaxWord                     = $FFFF
#Long_Custom                 = $DFF000
#_custom                     = $DFF000
;#COLOR00                     = $180

#MaxIntSgnd                  = $7FFFFFFF
#MemfLargest                 = $20000
#MemfPublic_MemfClear        = $10001

#HUNK_RELOC_16__MODE_OLDFILE = $3ED
#HUNK_RELOC_8__MODE_NEWFILE  = $3EE

;@@1
!initasm
!basic
optimize 5
Syntax 2
; ------------------------------------------------------
; INCLUDEFILES EINBINDEN
; ------------------------------------------------------
#use_bbscreen     = 0     ; workaround fuer screen_close crash
#USE_WBSTARTUPMSG = 0
#CLIARGMODE       = 0 ; OS-Calls

XINCLUDE "/Shared/library_offsets.ab3"
XINCLUDE "/Shared/common.ab3"
XINCLUDE "/Shared/preprocessor.include.ab3"
XINCLUDE "/Shared/ted.include.ab3"
XINCLUDE "dos.include.bb2"
XINCLUDE "asl.include.bb2"
XINCLUDE "multilist.include.bb2"
XINCLUDE "screen.include.bb2"
XINCLUDE "semaphore.include.bb2"
XINCLUDE "vvblank.include.bb2"
XINCLUDE "cpu.include.bb2"
XINCLUDE "file.include.bb2"
XINCLUDE "clipboard.include.bb2"
CNIF #use_NTUI
  XINCLUDE "ped.ntui.bb2"
CEND
XINCLUDE "translation.include.bb2"
;XINCLUDE "convert.include.bb2"
#MAX_STRINGSIZE = 512
#MAX_TEMPLATES  = 16

Macro ev_WaitEvent
   CNIF #use_NTUI
     Wait_ ($FFFFFFFF) ; Wait For all signals, could be ntui
     ntui_Handle{}
     ev.l = Event
   CELSE
     ev.l = WaitEvent
   CEND
End Macro


optimize 5
Syntax 2
#USE_WIZARD = 1
XINCLUDE "PE/wizard_Table.include.bb2"
XINCLUDE "PE/wizard_ColorWheel.include.bb2"
optimize 5
Syntax 2
; ------------------------------------------------------
; TYPENDEFINITIONEN
; ------------------------------------------------------
.TYPES
DEFTYPE.l quicktype,vars
DEFTYPE .l

NEWTYPE.project
  name.s
  drawer.s
  wizardfile.s
  sourcefile.s[#MAX_SOURCEFILES]
  sourcepath.s[#MAX_SOURCEFILES]
  sourcecounter.b
  pad.b         ; make it even
  ;
  version.w
  revision.w
  ;
  use_wbstartup.b
  use_nocli.b
  use_syntax.b
  use_optimize.b
  value_syntax.b
  value_optimize.b
End NEWTYPE
DEFTYPE.project ab2_project
Dim tempproject$(#MAX_SOURCEFILES,1)


NEWTYPE .pedfilelist
 dummy.b[$DE]
 filename.s
End NEWTYPE


NEWTYPE.tokendata
  *next_token.l
  number.w
  name.s
  help.s
End NEWTYPE


NEWTYPE .winprefs
  diag_x.w
  diag_y.w
  diag_w.w
  diag_h.w
  diag_on.b

  click_x.w
  click_y.w
  click_w.w
  click_h.w
  click_on.b

  ibrowser_x.w
  ibrowser_y.w
  ibrowser_w.w
  ibrowser_h.w
  ibrowser_on.b

  type_x.w
  type_y.w
  type_w.w
  type_h.w
  type_on.b
  activewin.b

  source_x.w
  source_y.w
  source_w.w
  source_h.w

  short_x.w
  short_y.w
  short_w.w
  short_h.w
  short_on.b

  lbrowser_x.w
  lbrowser_y.w
  lbrowser_w.w
  lbrowser_h.w
  lbrowser_on.b

  console_x.w
  console_y.w
  console_w.w
  console_h.w
  console_on.b
End NEWTYPE

NEWTYPE.custommenu
  itemname.s
  shortcut.s
  id.l
  command.s
End NEWTYPE

NEWTYPE.templates
  filename.s
  description.s
End NEWTYPE

; temporaere liste zur Erstellung des browsefiles
NEWTYPE.dirs
  name.s
End NEWTYPE


Dim List dirs.dirs(0)
Dim List custommenu.custommenu(0)
Dim List templates.templates(0)
Dim wpref.winprefs(3)
Dim help$(400)
DEFTYPE .winprefs wtemp
diag_x.l = 0
diag_y.l = 180
diag_w.l = 600
diag_h.l = 80

Dim diag_lab$(15)
Dim diag_val$(15)
Dim cmap.rgbval(256)

#AB3_cfunction         = 1
#AB3_cmacro            = 2
#AB3_cstring           = 3
#AB3_cnewtype          = 4
#AB3_cconstant         = 5
#AB3_cremarkforeground = 6
#AB3_cremarkbackground = 7
#AB3_ctoken            = 8
#AB3_ctokenbackground  = 9
#AB3_cbackground       = 10
#AB3_cother            = 11
#AB3_cclassic          = 12

#AB3_screenback        = 20
#AB3_screentext        = 21
#AB3_screenshine       = 22
#AB3_screenfill        = 23

Dim AB3Pen.w(24)
Dim AB3RGB.l(24)
Dim AB3RGB_temp.l(24)


Dim operators$(32)        ; Feld zum ablegen der Zeichen, die strukturiert werden sollen
SHARED num_operators.b
Restore key_chars
Repeat
  Read key_char$
  If key_char$<>""
    operators$(num_operators) = key_char$
    num_operators + 1
  EndIf
Until key_char$ = ""

key_chars:
Data.s "=",":","<",">","+","-","/","*","&","|",";",""

Dim chartab.b(129)
For i = 1 To 127
  a$ = Chr$(i)
  a$ = LCase$(a$)
  chartab(i) = Asc(a$)
Next
Poke.l ?comparetab,&chartab(0) ; make it basic!
Poke.b ?casemode,1
CaseSense Off

browse_macros.l           = Off
browse_instructions.l     = On
browse_includes.l         = On

Dim *nt2(15),pos2(15),pos$(15)
MaxLen tmp$               = 512

MaxLen sourcename$        = 96
MaxLen exepathname$       = 96
MaxLen exefilename$       = 96

MaxLen a$                 = 300      ;need for read .xtra
MaxLen aslpath$           = 250
MaxLen aslfile$           = 250
aslpath$ = "" : aslfile$ = "" : a$ = "" : ptn$ = "#?"

MaxLen tsourcedir$        = 192
MaxLen tincludedir$       = 192
MaxLen thepdir$           = 192
MaxLen tautodocdir$       = 192
MaxLen templatefilename$  =  96      ; fuer laden von templates
MaxLen temp_filename$     = 144      ; fuer laden von "jump_onclick"

MaxLen changelog$         = 1024


WZListAdd lst.List         ," "
WZListAdd lst2.List        ," "
WZListAdd list_labels.List ," "
oldfindstr$                = ""
oldreplacestr$             = ""
MaxLen screentitle$        = 96
Dim autodoc_nodes$(255)
Dim lib_mapping$(255,1)
Dim lib_check.b(255)
For i = 0 To 255
  lib_mapping$(i,0) = "* unused ID"+Str$(i)+" *"
  lib_mapping$(i,1) = ""
Next i
lib_mapping$(0,0) = "system1.lib"
lib_mapping$(0,1) = "ABCD"
Dim tokentable.b(65536)



; -- Strukturen fuer das Sourcewindow
DEFTYPE.Screen      *myscreen        ; Pointer to a screen
DEFTYPE.DrawInfo    *drawinfo        ; The drawing information of that screen

optimize 5
Syntax 2


; ------------------------------------------------------
; MAKRODEFINITIONS
; ------------------------------------------------------
.MACROS
Macro versions
  "\\__VER_MAJOR.\\__VER_MINOR (\\__DATE_GER__) Build \\__VER_PATCH.\\__VER_BUILD"
End Macro

Macro regs2stack
  MOVEM.l d0-d7/a0-a6,-(a7)
End Macro

Macro stack2regs
  MOVEM.l (a7)+,d0-d7/a0-a6
End Macro

Macro skipspace
 'nspace1`@
  CMP.b #" ",(`1)
  BNE 'nspace`@
  ADDQ.l #1,`1
  BRA 'nspace1`@
 'nspace`@
End Macro

Macro check
  CMP.b #"A",D2
   BCS.w 'JL_0_60E8`@
  CMP.b #"z",D2
   BHI.w 'JL_0_60E8`@
  CMP.b #"[",D2
   BCS.w 'JL_0_60E6`@
  CMP.b #"a",D2
   BCS.w 'JL_0_60E8`@
 'JL_0_60E6`@:
  CMP.w D2,D2
 'JL_0_60E8`@:
End Macro

Macro newalloc
  ADDQ.l #4,d0
  MOVE.l _execbase,a6
  MOVE.l comPtr_MemPool,a0
  MOVE.l d0,-(a7)
  JSR _AllocPooled(a6)
  MOVE.l (a7)+,d1
  TST.l d0
  BEQ 'lab1`@
  MOVE.l d0,a0
  MOVE.l d1,(a0)+
  MOVE.l a0,d0
 'lab1`@
End Macro

Macro newfree
  MOVE.l _execbase,a6
  MOVE.l comPtr_MemPool,a0
  MOVE.l -(a1),d0
  JSR _FreePooled(a6)        ; a0: poolHeader, a1: memory, d0: memsize
End Macro


; ------------------------------------------------------
; FUNCTIONDEFINITIONS
; ------------------------------------------------------
.FUNCTIONS
Statement Show_Helpfile{libname$,node$,pubscreen$}
  SHARED my_maindir$,helpdir$
  commandline.s = dos_AddPart{my_maindir$,"Tools/AB3HelpViewer"}
  If node$="" Then node$ = "main"
  commandline.s + " -q -t " + node$
  If libname$<>"" Then commandline.s + " -l " + dos_RemExt{libname$}
  If helpdir$<>"" Then commandline.s + " -d " + helpdir$

  If pubscreen$<>"" AND Peek.b(?use_wbscreen)=0
    commandline.s + " -s " + Peek$(?str_defaultpubscreen)
  Else
    commandline.s + " -s Workbench"
  EndIf
  dos_RunCli{commandline.s,0,8192,False}
End Statement


Function.b CheckWindow{title$}

  succ.b = True
  *thisscreen.Screen = Peek.l(Addr Screen(0))
  *conwin.Window = *thisscreen\FirstWindow
  While (*conwin<>0) AND Peek$(*conwin\Title)<>console_title$
    *conwin = Peek.l(*conwin)
  Wend
  If *conwin=0 Then succ = False

  Function Return succ
End Function


Statement PrintScreenTitle{text$}
  SHARED screentitle$
  winaddr.l = ActiveWindow
  If winaddr
    screentitle$ = text$
    If Peek.b(&screentitle$)
      SetWindowTitles_ winaddr,-1,&screentitle$
    EndIf
  EndIf
End Statement


Function.s TED_GetLibname{libnum.w}
  SHARED lib_mapping$()
  Function Return lib_mapping$(libnum,0)
End Function


Function.s TED_GetFirstTokenname{libnum.w}
  SHARED lib_mapping$()
  Function Return lib_mapping$(libnum,1)
End Function


Function.s TED_GetTokenName{*tokeninfo.tokeninfo,tnumber.w}
  While *tokeninfo
    If *tokeninfo\number = tnumber Then Function Return Peek.s(&*tokeninfo\dat)
    *tokeninfo = *tokeninfo\next_token
  Wend
  Function Return "" ; token not found
End Function


Function.w TED_GetTokenID{*tokeninfo.tokeninfo,tname$}
  lname$ = LCase$(tname$)
  While *tokeninfo
    If LCase$(Peek.s(&*tokeninfo\dat)) = lname$ Then Function Return *tokeninfo\number
    *tokeninfo = *tokeninfo\next_token
  Wend
  Function Return -1 ; token not found
End Function


Function.w TED_GetTokenLibnum{*tokeninfo.tokeninfo,tname$}
  number.w = TED_GetTokenID{*tokeninfo.tokeninfo,tname$}
  If number><-1 Then Function Return (number LSR 7)
  Function Return -1 ; token not found
End Function


Function.s TED_GetTokenHelp{*tokeninfo.tokeninfo,tname$}
  lname$ = LCase$(tname$)
  While *tokeninfo
    If LCase$(Peek.s(&*tokeninfo\dat)) = lname$
      ;Function Return tname$ + "  ; " + Peek.s(&*tokeninfo\dat+FLen(tname$)+1)
      Function Return Peek.s(&*tokeninfo\dat+FLen(tname$)+1)
    End If
    *tokeninfo = *tokeninfo\next_token
  Wend
  Function Return "" ; token not found
End Function


NEWTYPE .HelpIndexCacheItem
  name.s
  lname.s
  help.s
  includefile.s
End NEWTYPE
Dim List HelpIndexCache.HelpIndexCacheItem(0)


Statement TED_LoadHelpIndexFile{HelpIndexFile$}
  SHARED HelpIndexCache()
  ;fidW.l = file_Open{"sys:pedbug.txt",#file_forcewrite}
  fid.l = file_Open{HelpIndexFile$,#file_read}
  If fid<>-1
    ClearList HelpIndexCache()
    ;file_Cache{fid}
    While file_EOF{fid}=False
      zeile$ = file_ReadLine{fid}

      pos_name.l  = Instr(zeile$,"\\09",1)
      If pos_name=0 Then pos_name=FLen(zeile$)+1

      pos_desc.l  = Instr(zeile$,"\\09",pos_name+1)
      If pos_desc=0 Then pos_desc=FLen(zeile$)+1

      typ$  = Mid$(zeile$,1,pos_name-1)
      name$ = Mid$(zeile$,pos_name+1,pos_desc-pos_name-1)
      help$ = Mid$(zeile$,pos_desc+1)

      ;file_WriteLine{fidW,typ$+"::"+name$+"::"+help$}
      If typ$><""
      If typ$ = "FILE"
        filename$ = name$
      Else

        lname$ = LCase$(name$)
        If name$><""
          If help$=""
            Select typ$
              Case "FUNC" : help$ = "{...} ; Function"
              Case "MACR" : help$ = "{...} ; Macro"
              Case "STAT" : help$ = "{...} ; Statement"
              Default
                help$ = typ$
            End Select
          End If
          If AddItem(HelpIndexCache())
            HelpIndexCache()\name  = name$
            HelpIndexCache()\lname = lname$
            HelpIndexCache()\help  = help$
            HelpIndexCache()\includefile = filename$
          End If
        End If
      End If
      End If
    Wend
    file_Close{fid}
  End If
  ;If fidW><-1 Then file_Close{fidW}

End Statement


Statement TED_WriteHelpIndexCache{HelpIndexCacheFile$}
  SHARED HelpIndexCache()

  If OpenFile(1,HelpIndexCacheFile$)
    ResetList HelpIndexCache()
    While NextItem(HelpIndexCache())
      WriteType 1,HelpIndexCache()
    Wend
    CloseFile 1
  End If
End Statement


Statement TED_ReadHelpIndexCache{HelpIndexCacheFile$}
  SHARED HelpIndexCache()
;  fidW.l = file_Open{"sys:pedbug.txt",#file_forcewrite}

  If OpenFile(1,HelpIndexCacheFile$)
    ClearList HelpIndexCache()
    _lof.l = Lof(1)
    While _lof>Loc(1)
      If AddLast(HelpIndexCache())
        ReadType 1,HelpIndexCache()
        ;!cout{"*"+HelpIndexCache()\name+"*"}
        ;file_WriteLine{fidW,HelpIndexCache()\name}

      Else
        error{!TRANS{"Could not build index cache."}}
        Pop While: Goto exit_while
      EndIf
    Wend
    exit_while:
    CloseFile 1
  Else
    error{HelpIndexCacheFile$ + " "+!TRANS{"not found."}}
  End If

;  If fidW><-1 Then file_Close{fidW}

End Statement


Function.s TED_GetIncludeHelp{tname$}
  SHARED HelpIndexCacheFile$,HelpIndexCache()
  lname$ = LCase$(tname$)
  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then TED_ReadHelpIndexCache{HelpIndexCacheFile$}
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache())
    If HelpIndexCache()\lname = lname$
      Function Return HelpIndexCache()\help
    End If
  Wend
  Function Return ""                 ; function not found
End Function


Function.s TED_GetIncludeFunction{tname$}
  SHARED HelpIndexCacheFile$,HelpIndexCache()
  lname$ = LCase$(tname$)
  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then TED_ReadHelpIndexCache{HelpIndexCacheFile$}
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache())
    If HelpIndexCache()\lname = lname$
      Function Return HelpIndexCache()\name
    End If
  Wend
  Function Return ""                 ; function not found
End Function


Function.s TED_GetIncludeName{tname$}
  SHARED HelpIndexCacheFile$,HelpIndexCache()
  lname$ = LCase$(tname$)
  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then TED_ReadHelpIndexCache{HelpIndexCacheFile$}
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache())
    If HelpIndexCache()\lname = lname$
      Function Return HelpIndexCache()\includefile
    End If
  Wend
  Function Return "" ; function not found
End Function


Function.s TED_GetMacroHelp{macrobase.l,mname$}
  *mpointer.b = macrobase : mfound.b = False : mcounter.l = 0 : mname$ = StripLead$(StrLower(mname$),Asc("!"))
;  MOVE.l macrobase,a0:MOVE.l (a0),token@(a5)
  Repeat
    b$ = Peek$(*mpointer + 13)
    If StrLower(b$) = mname$
      i.l = Peek.w(*mpointer + 8)
      If i > 90 Then i = 90
      macroP.l = Peek.l(*mpointer + 4)
      If macroP Then help.s = StripLead$(Peek.s(macroP),32)
      help = StripLead$(help,@";")
      Function Return help
    End If
    *mpointer = Peek.l(*mpointer)
  Until *mpointer = 0
  Function Return ""
End Function


Function.s TED_GetMacroName{macrobase.l,mname$}
  *mpointer.b = macrobase : mfound.b = False : mcounter.l = 0 : mname$ = StripLead$(StrLower(mname$),Asc("!"))
;  MOVE.l macrobase,a0:MOVE.l (a0),token@(a5)
  Repeat
    b$ = Peek$(*mpointer + 13)
    If StrLower(b$) = mname$
      Function Return b$
    End If
    *mpointer = Peek.l(*mpointer)
  Until *mpointer = 0
  Function Return ""
End Function


Statement move_cursor {a$,lst.l,pos.l}
         ;Select EventCode
;loopm1:vvblank_resetsync{}
;           If RawKeyState($4c)
;                   i.l = WZListPos (a$)
;                   If i Then i = i-1 : WZPrint a$,pos,lst,i
;                   vvblank_wait_sync{4}:Goto loopm1
;           End If
;           If RawKeyState($4d)
;                   i = WZListPos (a$):
;                   If i <WZListItems(lst)-2 Then i = i+1:WZPrint a$,pos,lst,i
;                   vvblank_wait_sync{4}:Goto loopm1
;           End If
;         ;End Select
End Statement

Statement activategadget{ag$}  ;ag$ = gadget
  ActivateGadget_ WZGadAddr (ag$),WZWindowAddr,0
End Statement



Statement window_welcome{txt0$,@txt1$,@txt2$,@txt3$,@txt4$}
  SHARED my_systemdir$
  pngimage.l = -1
  ; -- es kommt zu einem Enforcerhit beim beenden von Amiblitz3, wenn dieses Fenster geoeffnet wurde !??

  WZWindow WZID("WIN_WELCOME"),0,128,-2,-2,-2,-2,WZID("WIN_WELCOME")
  *imagegad.Gadget = WZGadAddr("WELCOME_IMAGE")
  *win.Window = WZWindowAddr

;  imagefile.s = dos_AddPart{my_systemdir$,"amiblitz3_logo.jpg"}
;  If dos_Exist{imagefile}
;    If image_Load{0,imagefile}
;      pngimage = 0
;    EndIf
;  EndIf
  ;WZPrint "WELCOME_TITLE","AmiBlitz3"
  If (txt0$<>"")
    sharp.b = Instr(txt0$,"#")
    vlen.b = Len(txt0$)
    pv$ = Left$(txt0$,sharp - 1)
    cv$ = Right$(txt0$,vlen - sharp)
    WZPrint "PED",&pv$
    WZPrint "COMPILER",&cv$
  EndIf
  If (txt1$<>"") AND (txt2$<>"")
    WZPrint "TEXT1",&txt1$
    WZPrint "TEXT2",&txt2$
  EndIf
  WZPrint "ACIDLIBS_TEXT",&txt3$
  WZPrint "DEFLIBS_TEXT",&txt4$

;  If pngimage>=0 ; if we have a png image ...
    ; resize if bigger than imagegad ...
;    If image_GetWidth{pngimage}>*imagegad\Width OR image_GetHeight{pngimage}>*imagegad\Height
;      image_Resize{1-pngimage,pngimage,*imagegad\Width,*imagegad\Height}
;      image_Free{pngimage}
;      pngimage = 1-pngimage
;    End If
    ; and blit with alpha channel
;    If *imagegad<>0
;      EraseRect_ *win\RPort,*imagegad\LeftEdge,*imagegad\TopEdge,*imagegad\LeftEdge+*imagegad\Width,*imagegad\TopEdge+*imagegad\Height
;    EndIf
;    image_FancyBlit{pngimage,*imagegad\LeftEdge,*imagegad\TopEdge,-1,-1,*win\RPort,#image_blitmode_alpha}
;  EndIf

  If WZ_CheckOpen{"WIN_LABELS"}             Then WZ_LockWindow{"WIN_LABELS"}
  If WZ_CheckOpen{"WIN_NEWTYPE"}            Then WZ_LockWindow{"WIN_NEWTYPE"}
  If WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"} Then WZ_LockWindow{"WIN_INSTRUCTIONBROWSER"}
  Repeat
    !ev_WaitEvent
    If (ev = #IDCMP_IDCMPUPDATE)
      If WZGadName = "WELCOME_OK"
        welcome_Exit.b = True
      EndIf
    EndIf
  Until welcome_Exit
  WZCloseWindow WZID("WIN_WELCOME")
;  If pngimage>=0 Then image_Free{pngimage}
  If WZ_CheckOpen{"WIN_LABELS"}             Then WZ_UnlockWindow{"WIN_LABELS"}
  If WZ_CheckOpen{"WIN_NEWTYPE"}            Then WZ_UnlockWindow{"WIN_NEWTYPE"}
  If WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"} Then WZ_UnlockWindow{"WIN_INSTRUCTIONBROWSER"}
  FlushEvents
End Statement



Function.s check_constructs{currentline.l}
  DEFTYPE.SourceLine_t *sourceline
    a$ = ""
    *sourceline = Peek.l(currentline)
    *sourceline = *sourceline\NextLine
    ;!cout{Hex$(*sourceline\tokenised_text), Hex$(*sourceline)}
    ;!cout{Hex$(*sourceline + 9)}
    testaddr.l = Peek.l(*sourceline + 9) : bytecount.w = 0
    While (testaddr LSR 16) <> $0000
      testaddr = Peek.l(*sourceline + 9 + bytecount)
      actword.w = testaddr LSR 16


      ; check the token for parts of an if-loop
      Select actword
      Case $8021 : a$ = ""              ; THEN
      Case $8008 : a$ = "End Statement"
      Case $8009 : a$ = "End Function"
      Case $800B : a$ = "EndIf"
      Case $800C : a$ = "Wend"
      Case $800D : a$ = "End Macro"
      Case $800E : a$ = "End Select"
      Case $80BB : a$ = "Until"
      Case $8016 : a$ = "Next"
      End Select
      bytecount + 1
    Wend
    Function Return a$
End Function


Function.w preparseline{columnpos.w,lineaddr.l,auto_format.b,correct_funcnames.b}
  SHARED operators$(),num_operators

  ; clear highlight info but dont trash strings
  ;If (lineaddr MOD 2) <> 0 Then !cout{"alert: odd address " + Hex$(lineaddr)}
  If (lineaddr & $1) <> 0 Then !cout{"alert: odd address " + Hex$(lineaddr)}
  nostring.l = 0
  For i.l = lineaddr To lineaddr + #MAX_Columns
    If nostring.l = 0
      Poke.b i,Peek.b(i) AND $7f
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
    If Peek.b(i) = $22 Then nostring = 1
    ; workaround:
    ; sometimes there is a 0 in a linestring perhaps due
    ; to a wrong lineaddr
    ; the 0 is been replaced by a space
    If Peek.b(i) = 0 Then Poke.b i,32
  Next

  strg$ = Peeks$(lineaddr,#MAX_Columns) ; check this, was Peeks$$ before!

  ; --
  ; -- checking if editing a comment
  test_semi$ = StripLead$(strg$,@" ")
  kommata.w = Instr(test_semi$,";")
  If kommata AND (kommata < columnpos) Then Function Return columnpos

  len_strg.w = StrLen( StripTrail$(strg$,@" "))
  line_changed.b = False

  ; --
  ; -- replace lower written functionames with correct cases
  If correct_funcnames
    klammer.w = Instr(strg$,"{") - 1
    If klammer > 0
      run_left.l = -1
      again:
      Repeat
        run_left + 1
        char.l = Asc( Mid$(strg$,klammer - run_left,1) )
      Until ( ((char<65) AND (char<>33) AND ((char<48) OR (char>57))) OR (char > 122) OR (char > 90 AND char < 95)) OR (run_left >= klammer)
      If char = Asc(" ") AND run_left = 0 Then Goto again:
      ; 0 = 48; 9 = 57
      ; A = 65, Z = 90
      ; a = 97, z = 122
      funcname$ = StrSub(strg$,klammer - run_left + 1,run_left)
      funcname$ = StrChg(funcname$," ","")
      newfuncname$ = TED_GetIncludeFunction{funcname$}
      If newfuncname$<>""
        strg$ = StrChg(strg$,funcname$,newfuncname$)
        line_changed = True
      EndIf
    EndIf
  EndIf

  ; structurization of source
  If auto_format
    neustrg$ = ""
    make_struct.b = On
    For j.w = 1 To len_strg
      double_operator.b = False
      temp_disabled.b = Off
      no_pre_pad.b = Off
      no_post_pad.b = Off
      comment_mode.b = Off

      char$ = Mid$(strg$,j,1)
      If char$<>" "
        For k.w = 0 To num_operators-1
          If char$ = operators$(k)
            For l.w = 0 To num_operators - 1
              If last_op$ = operators$(l) Then double_operator = True
            Next
            If NOT double_operator
              op_found.b = True
              Pop For
              Goto exit_for
            EndIf
          Else
            op_found = False
          EndIf
        Next k
        exit_for:
        If char$ = Chr$(34) Then make_struct = -1 + Abs(make_struct)

        If (op_found = True) AND (last_op$ <> "=")
          last_op$ = char$

          Select char$
            Case ";"      ; innerhalb von Kommentaren nicht strukturieren
              comment_mode = On

            Case "-"      ; eine Zuweisung mit neg. Wert nicht formatieren
              If Mid$(strg$,j - 2,2) = "= " OR Mid$(strg$,j - 1,1) = "="
                temp_disabled = On
              EndIf

            Case "<"
              If Mid$(strg$,j-2,2) = "> " OR Mid$(strg$,j-1,1)=">"
                no_pre_pad = On
              EndIf
              If Mid$(strg$,j+2,2) = "> " OR Mid$(strg$,j+1,1)=">"
                no_post_pad = On
              EndIf

            Case ">"
              If Mid$(strg$,j-2,2) = "< " OR Mid$(strg$,j-1,1)="<"
                no_pre_pad = On
              EndIf
              If Mid$(strg$,j+2,2) = "< " OR Mid$(strg$,j+1,1)="<"
                no_post_pad = On
              EndIf

          End Select

          If make_struct AND (j > 1) AND (NOT temp_disabled) AND (NOT comment_mode = On)
            pad_pre$ = "" : pad_post$ =""
            If Mid$(strg$,j - 1,1) <>" " Then pad_pre$  = " " : columnpos + 1
            If Mid$(strg$,j + 1,1) <>" " Then pad_post$ = " " : columnpos + 1
            If no_pre_pad                Then pad_pre$  = ""   : columnpos - 1
            If no_post_pad               Then pad_post$ = ""   : columnpos - 1
            char$ = pad_pre$ + char$ + pad_post$
            line_changed = True
          EndIf
        Else
          last_op$ = ""
        EndIf
      EndIf
      neustrg$ + char$
    Next j
    strg$ = neustrg$
  EndIf

  ; --- write formated textline into textbuffer
  If line_changed
    strg$ = StrLeft(strg$,#MAX_Columns,32)
    For i.l = lineaddr To lineaddr + (#MAX_Columns - 6)
      achar.b = Asc(Mid$(strg$,i + 1 - lineaddr,1))
      Poke.b i,achar
    Next
  EndIf

  ; --- return new cursorposition if something as changed
  Function Return columnpos
End Function


Statement savewinpref{num.l,@sourcewin.l}
  SHARED wpref(),wtemp,console_title$

  used_win.l = Used Window
  ret.l = RTEZRequest("",!TRANS{"The window settings have been saved.\\nPress appropriate FN-Key (F4-F6) to set window configuration."},!TRANS{"_Ok"})

  USEPATH wtemp
  \lbrowser_on = 0
  \ibrowser_on = 0
  \type_on = 0
  \diag_on = 0
  \click_on = 0
  \short_on = 0

;  If used_win = 6
;    \activewin = 0                   ; 6 = Settings Window
;  Else
;    \activewin = used_win
;  EndIf
;  If !windowaddr <> ActiveWindow
    \activewin = 0
;  End If

  If WZ_CheckOpen{"WIN_LIBRARYBROWSER"}
     Use Window WZID("WIN_LIBRARYBROWSER")
     \lbrowser_x  = WindowX
     \lbrowser_y  = WindowY
     \lbrowser_w  = WindowWidth
     \lbrowser_h  = WindowHeight
     \lbrowser_on = 1
  End If
  If WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"}
     Use Window WZID("WIN_INSTRUCTIONBROWSER")
     \ibrowser_x  = WindowX
     \ibrowser_y  = WindowY
     \ibrowser_w  = WindowWidth
     \ibrowser_h  = WindowHeight
     \ibrowser_on = 1
  End If
  If WZ_CheckOpen{"WIN_NEWTYPE"}
     Use Window WZID("WIN_NEWTYPE")
     \type_x  = WindowX
     \type_y  = WindowY
     \type_w  = WindowWidth
     \type_h  = WindowHeight
     \type_on = 1
  End If
  If WZ_CheckOpen{"WIN_HELPDIAG"}
     Use Window WZID("WIN_HELPDIAG")
     \diag_x  = WindowX
     \diag_y  = WindowY
     \diag_w  = WindowWidth
     \diag_h  = WindowHeight
     \diag_on = 1
  End If
  If WZ_CheckOpen{"WIN_LABELS"}
     Use Window WZID("WIN_LABELS")
     \click_x  = WindowX
     \click_y  = WindowY
     \click_w  = WindowWidth
     \click_h  = WindowHeight
     \click_on = 1
  End If
  If WZ_CheckOpen{"WIN_SHORTCUTS"}
     Use Window WZID("WIN_SHORTCUTS")
     \short_x  = WindowX
     \short_y  = WindowY
     \short_w  = WindowWidth
     \short_h  = WindowHeight
     \short_on = 1
  EndIf

  If sourcewin > 0
    *swin.Window = Peek.l(sourcewin)
    \source_x = *swin\LeftEdge
    \source_y = *swin\TopEdge
    \source_w = *swin\Width
    \source_h = *swin\Height
  EndIf

  ; -- check if console is open and store its position
  *thisscreen.Screen = Peek.l(Addr Screen(0))
  *conwin.Window = *thisscreen\FirstWindow
;  message{"error"}
  security.l=0
  If *conwin
    While (*conwin<>0)
      If Peek$(*conwin\Title)<>console_title$
        If Peek.l(*conwin) Then *conwin = Peek.l(*conwin) Else *conwin = 0
      Else
        Pop While
        Goto exit_consearch
      EndIf
      ; notbremse fuer while-loop
      security + 1
      If security > 30 Then *conwin = 0
    Wend
  EndIf
  exit_consearch:
  If *conwin
    \console_x = *conwin\LeftEdge
    \console_y = *conwin\TopEdge
    \console_w = *conwin\Width
    \console_h = *conwin\Height
  EndIf
  Use Window used_win
  CopyMem_ &wtemp,&wpref(num),SizeOf .winprefs
End Statement


Statement read_libmapping{_file.s}
  SHARED tokenbase
  SHARED lib_mapping$()

  Dim templist$(255,1)
  DEFTYPE.w libcounter,i

  fid.l = file_Open{_file,#file_read}
  If fid<>-1
    file_Cache{fid}
    Repeat
      zeile$ = file_ReadLine{fid}
      qpos.w = Instr(zeile$,";")
      If qpos
        lstring$ = Left$(zeile$,qpos-1)
        rstring$ = Right$(zeile$,FLen(zeile$)-qpos)

        ; get libnumber from internal structure
        templist$(libcounter,0) = StrChg(lstring$," ","")
        templist$(libcounter,1) = StrChg(rstring$," ","")
        libcounter + 1
      EndIf
    Until file_EOF{fid}
    file_Close{fid}
    If libcounter = 0 Then Statement Return

    *tpointer.l = tokenbase
    If *tpointer
      Repeat
        token_next.l   = Peek.l(*tpointer)
        token_name$    = Peek$(*tpointer+6)
        libnum.w = Peek.w(*tpointer+4) LSR 7

        For i = 0 To libcounter
          If templist$(i,1) = token_name$
            If libnum > 0
              libname$ = templist$(i,0)
              firsttoken$ =  templist$(i,1)
              If (Instr(lib_mapping$(libnum,0),"unused")=0)
                message$= !TRANS{"Library clash!\\n" }
                message$+ !TRANS{"The dynamic added lib"}+" \\22"+libname$+"\\22\\n"
                message$+ !TRANS{"has overwritten"}+" \\22"+lib_mapping$(libnum,0)+"\\22 "+!TRANS{"stored in acidlibs/deflibs"}+".\\n"
                message$+ !TRANS{"Both libs have the same Lib-ID"}+" "+ Str$(libnum)+".\\n\\n"
                message$+ !TRANS{"Sourcecode that uses"}+" "+ lib_mapping$(libnum,0) + " "+!TRANS{"might not work,\\n"}
                message$+ !TRANS{"because these functions are now mapped to"}+" "+libname$+".\\n\\n"
                message$+ !TRANS{"You should remove the appropriate library from userlibs-directory,\\nor change the Lib-ID to a free one."}
                dummy.l = RTEZRequest("",message$,!TRANS{ "_Ok"})
                lib_mapping$(libnum,0) = libname$ + " ("+!TRANS{ "clashing with"}+" "+lib_mapping$(libnum,0)+")"
              Else
                lib_mapping$(libnum,0) = libname$
              EndIf
              lib_mapping$(libnum,1) = firsttoken$
              Pop If : Pop If : Pop For : Goto exit_this_loop
            EndIf
          EndIf
        Next i
        exit_this_loop:

        *tpointer.l = token_next
      Until (*tpointer = 0)
    EndIf
  EndIf
End Statement


Function.l AutoLayout{*wprefs.winprefs,mode.l}
  SHARED al_leftspace.l,al_rightspace.l,al_topspace.l,al_bottomspace.l
  USEPATH *wprefs
  *scr.Screen = Peek.l(Addr Screen(0))
  If *scr=0 Then Function Return False
  WZCloseWindow WZID("WIN_INSTRUCTIONBROWSER")
  top.l    = *scr\BarHeight +1 + al_topspace
  bottom.l = *scr\Height-1     - al_bottomspace
  left.l   = 0                 + al_leftspace
  right.l  = *scr\Width-1      - al_rightspace

  lock.l = LockIBase_ (0)
    *myWindow.Window = *scr\FirstWindow

    While *myWindow
      rx.l = *myWindow\Width/*myWindow\Height
      ry.l = *myWindow\Height/*myWindow\Width
      ;If *myWindow\Title Then rx=1 : ry=1
      If *myWindow\Flags&#WFLG_BORDERLESS = 0 Then rx=1 : ry=1
      If rx>2
        If *myWindow\TopEdge+*myWindow\Height-1 >= bottom
          bottom = Min(bottom,*myWindow\TopEdge-1)
        End If
        If *myWindow\TopEdge<*scr\BarHeight
          top    = Max(top,*myWindow\TopEdge+*myWindow\Height)
        End If
      End If

      If ry>2
        If *myWindow\LeftEdge+*myWindow\Width-1 >= right
          right = Min(right,*myWindow\LeftEdge-1)
        End If
        If *myWindow\LeftEdge<=0
          left  = Max(left,*myWindow\LeftEdge+*myWindow\Width)
        End If
      End If
      *myWindow = *myWindow\NextWindow
    Wend

  UnlockIBase_ lock

  width.l  = right-left+1
  height.l = bottom-top+1


  Select mode
    Case 0    ; Layout A
      splitpointY.l  = (bottom-top) * 3/4
      splitpointX.l  = (right-left) * 3/4

      If splitpointY<700              Then splitpointY=height
      If (right-left)-splitpointX<250 Then splitpointX=right-left-250

      ;\source_on   = True            ; source code window
      \source_x    = left,top,splitpointX,splitpointY
      Poke.w ?win_TopLeft,\source_x
      Poke.w ?win_TopEdge,\source_y
      Poke.w ?win_Width  ,\source_w
      Poke.w ?win_Height ,\source_h
      If (splitpointY<bottom-top+1)
        If (splitpointX>1024)
          \ibrowser_on = True        ; Instruction Browser
          \ibrowser_x  = left,(top+splitpointY),(splitpointX/2),bottom-(top+splitpointY)+1
          \lbrowser_on = True
          \lbrowser_x  = left+splitpointX/2,(top+splitpointY),splitpointX-(splitpointX/2),bottom-(top+splitpointY)+1
        Else
          \ibrowser_on = True        ; Instruction Browser
          \ibrowser_x  = left,(top+splitpointY),(splitpointX),bottom-(top+splitpointY)+1
          \lbrowser_on = False
        End If
      Else
        \lbrowser_on = False
        \ibrowser_on = False
      End If
      \click_on    = True            ; Source Browser
      \click_x     = (left+splitpointX),top,width-splitpointX,height*3/5
      \type_on     = True            ; Definition Browser
      \type_x      = (left+splitpointX),(top+height*3/5),width-splitpointX,bottom-((height)*3/5)+1-top

      If splitpointY<height
        \console_x   = left,(top+splitpointY),splitpointX,height-splitpointY
      Else
        \console_x   = left,(top),splitpointX,height
      End If

    Case 1    ; Layout B
      splitpointX1.l  = (width)  * 1/4 : If splitpointX1<400       Then splitpointX1=400
      splitpointX2.l  = (width)  * 3/4 : If width-splitpointX2<250 Then splitpointX2=width-250
      splitpointY.l   = (height) * 3/5

      If splitpointX2-splitpointX1<320 Then splitpointX1=0 ;: splitpointX2.l  = (right-left) * 1/3
      If splitpointY <400              Then splitpointY=0

      ;\source_on   = True ; source code window
      \source_x    = left+splitpointX1,top,splitpointX2-splitpointX1,height
      Poke.w ?win_TopLeft,\source_x
      Poke.w ?win_TopEdge,\source_y
      Poke.w ?win_Width  ,\source_w
      Poke.w ?win_Height ,\source_h

      If (splitpointX1>0)
        If (splitpointY>0)
          \ibrowser_on = True ; Instruction Browser
          \ibrowser_x  = left,top,splitpointX1,splitpointY
          \lbrowser_on = True
          \lbrowser_x  = left,top+splitpointY,splitpointX1,height-splitpointY
        Else
          \ibrowser_on = True ; Instruction Browser
          \ibrowser_x  = left,top,splitpointX1,height
          \lbrowser_on = False
        End If
      Else
        \lbrowser_on = False
        \ibrowser_on = False
      End If
      If (splitpointY>0)
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX2 ,top,width-splitpointX2,splitpointY
        \type_on     = True ; Definition Browser
        \type_x      = left+splitpointX2 ,top+splitpointY,width-splitpointX2,height-splitpointY
      Else
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX2,top,width-splitpointX2,height
        \type_on     = False ; Definition Browser
      End If
      \console_x    = left,(top+splitpointY),width,height-splitpointY

    Case 2    ; Layout C
      splitpointX.l  = (width) * 3/4 : If width-splitpointX<250 Then splitpointX=width-250
      splitpointY.l  = (height) * 3/5
      If splitpointY <400 Then splitpointY=0

      ;\source_on   = True ; source code window
      \source_x    = left,top,splitpointX,height
      Poke.w ?win_TopLeft,\source_x
      Poke.w ?win_TopEdge,\source_y
      Poke.w ?win_Width  ,\source_w
      Poke.w ?win_Height ,\source_h

      \lbrowser_on = False
      \ibrowser_on = False

      If (splitpointY>0)
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX ,top,width-splitpointX,splitpointY
        \type_on     = True ; Definition Browser
        \type_x      = left+splitpointX ,top+splitpointY,width-splitpointX,height-splitpointY
      Else
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX,top,width-splitpointX,height
        \type_on     = False ; Definition Browser
      End If
      \console_x   = left,(top+splitpointY),width,height-splitpointY


  End Select
  USELASTPATH
  Function Return True
End Function





;@@0
; -------------------------------------------------------------------------------------
; START DER PROGRAMM ROUTINE
; -------------------------------------------------------------------------------------

.STARTUP_PED
FindScreen 0

!asm
;
; -- checking for TEDY as input of D1 ...
; -- TEDY nicht in D1, also nicht vom Compiler gestartet
;
CMP.l #"TEDY",D1
BEQ 'no_exit
  !basic
  error{"PED is not a standalone editor anymore.\\nPlease start the AmiBlitz3-IDE via Compiler."}
  Goto abnormal_exit
'no_exit
!basic

!TRANS_INIT{"AmiBlitz3"}
; -- checking internal data structures...
;
; init the comdata structure
!ComData_LEA{comFunc_OpenWindow             ,A0}                : MOVE.l #comwin_open                 ,(A0)
!ComData_LEA{comFunc_CloseWindow            ,A0}                : MOVE.l #comwin_close                ,(A0) ;$04
!ComData_LEA{comFunc_MessageLoop            ,A0}                : MOVE.l #general_message_loop        ,(A0) ;$08
!ComData_LEA{comFunc_ErrorRequest           ,A0}                : MOVE.l #show_errorrequester         ,(A0) ;$0C
!ComData_LEA{comFunc_DetokenizeSource       ,A0}                : MOVE.l #DetokenizeSource            ,(A0) ;$10
!ComData_LEA{comFunc_TokenizeSource         ,A0}                : MOVE.l #TokenizeSource              ,(A0) ;$14
!ComData_LEA{comFunc_ASLFileRequest         ,A0}                : MOVE.l #show_aslfilerequest         ,(A0) ;$18
!ComData_LEA{comFunc_RefreshGadList         ,A0}                : MOVE.l #comwin_refreshglist         ,(A0) ;$1c
!ComData_LEA{comFunc_CheckEvents            ,A0}                : MOVE.l #check_events                ,(A0) ;$20
!ComData_LEA{comFunc_SetStoredColors        ,A0}                : MOVE.l #set_storedcolors            ,(A0) ;$30
!ComData_LEA{comFunc_SetStoredColors2       ,A0}                : MOVE.l #set_storedcolors            ,(A0) ;$34
!ComData_LEA{comFunc_DebugTrap              ,A0}                : MOVE.l #com_0_44E2                  ,(A0) ;$38
!ComData_LEA{comFunc_OpenConsole            ,A0}                : MOVE.l #console_open                ,(A0) ;$3C
!ComData_LEA{comFunc_CloseConsole           ,A0}                : MOVE.l #console_close               ,(A0) ;$40
!ComData_LEA{comFunc_ActivateGadCompilerWin ,A0}                : MOVE.l #activate_gad_in_compilerwin ,(A0) ;$44
!ComData_LEA{comFunc_SetNormalPointer       ,A0}                : MOVE.l #set_pointernormal           ,(A0) ;$48
!ComData_LEA{comFunc_SetBusyPointer         ,A0}                : MOVE.l #set_pointerbusy             ,(A0) ;$4C     4c 4d 4e 4f
!ComData_LEA{comFunc_CloseCompilerWin       ,A0}                : MOVE.l #old_CloseCompilerWin        ,(A0) ;$58     58 59 5a 5b
!ComData_LEA{comFunc_DetokenizeLine         ,A0}                : MOVE.l #detokenize_line             ,(A0) ;$64
!ComData_LEA{comPtr_CurrentDir              ,A0}                : MOVE.l #comStr_CurrentDir           ,(A0) ;$68
!ComData_LEA{comPtr_SourceName              ,A0}                : MOVE.l #comStr_SourceName           ,(A0) ;$6C
!ComData_LEA{comFunc_AL_0_852E              ,A0}                : MOVE.l #AL_0_8BD2                   ,(A0) ;$70
!ComData_LEA{comFunc_AL_0_8532              ,A0}                : MOVE.l #AL_0_8BD6                   ,(A0)
!ComData_LEA{comWord_MaxColumns             ,A0}                : MOVE.w #MAX_Columns                 ,(A0)
!ComData_LEA{comFunc_OpenCompilerWindow     ,A0}                : MOVE.l #compiler_openwindow         ,(A0)
!ComData_SetL{comFunc_CloseGUI              ,#close_gui}
!ComData_SetL{comFunc_CreateGUI             ,#create_whole_gui}
!ComData_SetL{comData_Magic                 ,#$7E3A3A7E}        ;#"~::~"}  ;
!ComData_LEA{comArray_KeyTable              ,A0}
MOVE.l #key_cursorup                        ,02(A0)
MOVE.l #key_cursordown                      ,08(A0)
MOVE.l #insertreturn                        ,14(A0)
MOVE.l #menu_helpgeneral                    ,20(A0)
MOVE.l #menu_helpincludesguide              ,26(A0)
MOVE.l #menu_helpblitzlibs                  ,32(A0)
MOVE.l #menu_dublicate                      ,38(A0)
MOVE.l #menu_previousfile                   ,44(A0)
MOVE.l #menu_nextfile                       ,50(A0)
MOVE.l #event_helpkey                       ,56(A0)
MOVE.l #event_vertscroller                  ,62(A0)
MOVE.l #event_shortcut                      ,68(A0)
MOVE.l #event_leftmousebutton               ,74(A0)
MOVE.l #AJL_0_7FCC                          ,80(A0)

;---  Check  if  all  needed  Librarys  are  available  with  the  needed  min  Version
errorout.s = ""      ; for the error text
ende.b     = False   ; abort indicater

If dos_CheckLib{"wizard.library",42} = False        ; needed for Compiler, PED and REDDebugger
  errorout + "Missing wizard.library:\\nThis library is required in version 42 by this IDE.\\n\\n"
  ende = True
EndIf

If dos_CheckLib{"reqtools.library",39} = False      ; needed for PED and REDDebugger
  errorout + "Missing reqtools.library:\\nThis library is required in version 39 by the IDE.\\n\\n"
  ende = True
End If

If dos_CheckLib{"ted.library",1} = False           ; needed for PED and REDDebugger
  errorout + "Missing ted.library:\\nThis library is required in version 1 by the IDE.\\n\\n"
  ende = True
End If

If dos_CheckLib{"disassembler.library",40} = False ; only needed for REDDebugger
  errorout + "Missing disassembler.library:\\nThis library is required in version 40 for REDDebugger.\\nASM debugging won't work.\\n\\n"
End If

If errorout <> ""     ; check if somthing to show
   errorout = "Please reinstall AmiBlitz3 or install the librarys in LIBS:\\n\\n" + errorout
   If ende
     errorout + "...that the PED can start!" ; for abort
   Else
     errorout + "...for a full working IDE!" ; for limited start
   End If
   error{!TRANS{errorout}}
End If

;--- End if needed library or Version is not available
If ende Then Goto abnormal_exit

*MyCatalog.l=OpenCatalogA_(0,"PED.catalog",0)
;Set Tags so WIzardlibrary Use catalog File
If *MyCatalog
   WZTags #SFH_Catalog,*MyCatalog,#TAG_DONE,0,#TAG_END,0
EndIf
;init Wizard GUI
WZLoadGUI ?wzgui



WZ_ShowMessage{!TRANS{"Initiating AmiBlitz3 Environment..."}}

; set windowtitle for progresswindow                         ; tomsmart1
;*win.Window = WZWindowAddr                                  ;get window pointer works, but i find it not save  tomsmart1
*win.Window = Peek.l(Addr Window(WZID("WIN_PROGRESS")))      ;get window pointer  tomsmart1
newwintitle.s="Amiblitz3 V" + !versions                      ;new window title tomsmart1
SetWindowTitles_ *win,newwintitle,-1                         ;show new window title  tomsmart1

; ------------------------------------------------------------------------------------
; AUSWERTEN DER TOOLTYPES
; ------------------------------------------------------------------------------------
.SET_DEFAULT_SETTINGS
;  MOVE.w #0,comWord_DoTokenize
;  MOVE.w #0,flag_tokenization
Poke.s ?warningtitle,!TRANS{"!!!PROGRAM IS RUNNING: ONLY SAVE/NAVIGATION/HELP WILL WORK..."}
a$ = dos_GetProgIcon{"Blitz3:AmiBlitz3"}

.TOOLTYPES
  disk_object.l = dos_OpenToolTypes{a$}
  If disk_object
    If dos_GetToolState{"no_welcome"}         = -1 Then Poke.b ?no_welcome         ,1 : Else Poke.b ?no_welcome         ,0
    If dos_GetToolState{"standardeditmode"}   = -1 Then Poke.b ?new_editmode       ,1 : Else Poke.b ?new_editmode       ,0
    If dos_GetToolState{"oldsearch"}          = -1 Then Poke.w ?oldsearch          ,1 : Else Poke.w ?oldsearch          ,0
    If dos_GetToolState{"nodisplaybeep"}      = -1 Then Poke.b ?nodisplaybeep      ,1 : Else Poke.b ?nodisplaybeep      ,0
  ;  If dos_GetToolState{"newcolormode"}       = -1 Then Poke.b ?newcolormode       ,1 : Else Poke
    If dos_GetToolState{"auto_format"}        = -1 Then Poke.b ?auto_format        ,1 : Else Poke.b ?auto_format        ,0
    If dos_GetToolState{"USE_INTELLISENSE"}   = -1 Then Poke.b ?use_intellisense   ,1 : Else Poke.b ?use_intellisense   ,0
    If dos_GetToolState{"AUTO_CONSTRUCTS"}    = -1 Then Poke.b ?auto_constructs    ,1 : Else Poke.b ?auto_constructs    ,0
    If dos_GetToolState{"correct_functions"}  = -1 Then Poke.b ?correct_functions  ,1 : Else Poke.b ?correct_functions  ,0
    If dos_GetToolState{"smart_tokenization"} = -1 Then Poke.w ?smart_tokenization ,1 : Else Poke.w ?smart_tokenization ,0

    If dos_GetToolState{"tokenbold"}          = -1 Then Poke.w ?bold_tokens        ,1 : Else Poke.w ?bold_tokens        ,0
    If dos_GetToolState{"italic_remarks"}     = -1 Then Poke.w ?italic_remarks     ,1 : Else Poke.w ?italic_remarks     ,0
    If dos_GetToolState{"onlinehelp"}         = -1 Then Poke.b ?onlinehelp         ,1 : Else Poke.b ?onlinehelp         ,0

    If dos_GetToolState{"use_asldims"}        = -1 Then Poke.w ?use_asldims        ,1 : Else Poke.w ?use_asldims        ,0
    If dos_GetToolState{"SOURCE_HISTORY"}     = -1 Then Poke.w ?remember_saved     ,1 : Else Poke.w ?remember_saved     ,0
    If dos_GetToolState{"load_last_source"}   = -1 Then Poke.b ?load_last_source   ,1 : Else Poke.b ?load_last_source   ,0

    If dos_GetToolState{"sort_labels"}        = -1 Then sort_labels.l  = True : Else sort_labels  = False
    If dos_GetToolState{"CON_ONWB"}           = -1 Then console_wb.l   = True : Else console_wb   = False
    If dos_GetToolState{"CON_WAIT"}           = -1 Then console_wait.l = True : Else console_wait = False

    If dos_GetToolState{"clone_wbscreen"}   = True
      Poke.b ?clone_wbscreen,1
      Poke.b ?use_wbscreen  ,0         ; for the case that both tooltypes are set we use cloneWB
    Else
      If dos_GetToolState{"use_wbscreen"}   = True
        Poke.b ?use_wbscreen  ,1
        Poke.b ?clone_wbscreen,0
      EndIf
    EndIf

    If dos_GetToolState{"defaultpubscreen"} = True
      Poke.w ?use_default_pubscreen,1
    Else
      Poke.w ?use_default_pubscreen,0
    EndIf

    If dos_GetToolState{"use_wbfont"}       = True
      use_wbfont.b = True
    End If

  Else
    MOVE.w #1,bold_tokens
    MOVE.b #1,onlinehelp
    MOVE.b #1,new_editmode
    MOVE.b #1,use_wbscreen
    MOVE.b #0,clone_wbscreen
    MOVE.w #0,use_default_pubscreen
    use_wbfont.b = True
  End If

  autolayout.l     = dos_GetToolValue{"autolayout"      ,-1}
  al_leftspace.l   = dos_GetToolValue{"autolayout_left"  ,0}
  al_topspace.l    = dos_GetToolValue{"autolayout_top"   ,0}
  al_rightspace.l  = dos_GetToolValue{"autolayout_right" ,0}
  al_bottomspace.l = dos_GetToolValue{"autolayout_bottom",0}

  console_device$ = dos_GetToolString{"CON_DEVICE","CON:"}
  console_font$   = dos_GetToolString{"CON_FONT",""}
  console_title$  = !TRANS{"AmiBlitz3 Console Output"}

  scroll_rate.l = dos_GetToolValue{"scrollrate",0}
  If scroll_rate<>0
    If vvblank_SetFreq {scroll_rate}=False Then MOVE.b #1,old_scrolling
  Else
    MOVE.b #1,old_scrolling
  EndIf
  Poke.b ?blinkrate, dos_GetToolValue{"cursorblinkrate",5}

  ; --- ASL-Requestersettings ------------------------------
  Poke.l ?aslreq_x      ,dos_GetToolValue{"ASLREQ_X" ,20}
  Poke.l ?aslreq_y      ,dos_GetToolValue{"ASLREQ_Y" ,20}
  Poke.l ?aslreq_width  ,dos_GetToolValue{"ASLREQ_W",320}
  Poke.l ?aslreq_height ,dos_GetToolValue{"ASLREQ_H",200}
  Poke.s ?comStr_FilePattern,dos_GetToolString{"ASLREQ_Pattern","#?.(bb2|ab2|ab3|asc|txt)"}

  If Peek.w(?use_asldims) <> 0
    asl_SetRequesterDims{Peek.l(?aslreq_x),Peek.l(?aslreq_y),Peek.l(?aslreq_width),Peek.l(?aslreq_height)}
  Else
    asl_SetRequesterDims{-1,-1,-1,-1}
  EndIf

  ; --- COLORS ---------------------------------------------
  AB3RGB(#AB3_ctoken)            = dos_GetToolValue{"tokencolor"      ,$646bd7} ;: Poke.b ?tokencolor,AB3RGB(#AB3_ctoken
  AB3RGB(#AB3_cfunction)         = dos_GetToolValue{"functioncolor"   ,$396635} ;: Poke.l ?functioncolor,AB3RGB(#AB3_cfunction
  AB3RGB(#AB3_cconstant)         = dos_GetToolValue{"constantcolor"   ,$8C338A} ;: Poke.l ?constantcolor,AB3RGB(#AB3_cconstant
  AB3RGB(#AB3_cnewtype)          = dos_GetToolValue{"newtypecolor"    ,$153492} ;: Poke.l ?newtypecolor,AB3RGB(#AB3_cnewtype
  AB3RGB(#AB3_cstring)           = dos_GetToolValue{"stringcolor"     ,$7D8A83} ;: Poke.w ?stringcolor,AB3RGB(#AB3_cstring
  AB3RGB(#AB3_cmacro)            = dos_GetToolValue{"macrocolor"      ,$CB3817} ;: Poke.l ?macrocolor,AB3RGB(#AB3_cmacro
  AB3RGB(#AB3_cother)            = dos_GetToolValue{"othercolor"      ,$000000} ;: Poke.w ?othercolor,AB3RGB(#AB3_cother
  AB3RGB(#AB3_cremarkforeground) = dos_GetToolValue{"remarkforg"      ,$6a9a66} ;: Poke.b ?remarkcolor,AB3RGB(#AB3_cremarkforg
  AB3RGB(#AB3_cremarkbackground) = dos_GetToolValue{"remarkbackg"     ,$f9f9f9} ;: Poke.b ?remarkbgcolor,AB3RGB(#AB3_cremarkbackg
  AB3RGB(#AB3_ctokenbackground)  = dos_GetToolValue{"tokenbackpen"    ,$ffffff} ;: Poke.b ?tokenbackground,AB3RGB(#AB3_ctokenbackground
  AB3RGB(#AB3_cbackground)       = dos_GetToolValue{"backgroundcolor" ,$ffffff} ;: Poke.l ?backgroundcolor,AB3RGB(#AB3_cbackgroundcolor
  AB3RGB(#AB3_cclassic)          = dos_GetToolValue{"classiccolor"    ,$ff0500} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screenback)        = dos_GetToolValue{"screenbackcolor" ,$c8c8c8} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screentext)        = dos_GetToolValue{"screentextcolor" ,$000000} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screenshine)       = dos_GetToolValue{"screenshinecolor",$FFFFFF} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screenfill)        = dos_GetToolValue{"screenfillcolor" ,$6e94e2} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic

  ; --- SCREEN ---------------------------------------------
  myscreen_modeid.l  = dos_GetToolValue{"SCREEN_ID"     ,0} : Poke.l ?ownscreen_modeid ,myscreen_modeid
  myscreen_Width.l   = dos_GetToolValue{"SCREEN_WIDTH"  ,0} : Poke.w ?ownscreen_width  ,myscreen_Width
  myscreen_Height.l  = dos_GetToolValue{"SCREEN_HEIGHT" ,0} : Poke.w ?ownscreen_height ,myscreen_Height
  myscreen_Depth.l   = dos_GetToolValue{"SCREEN_DEPTH"  ,0} : Poke.w ?ownscreen_depth  ,myscreen_Depth

  ; check if any Screentooltype set
  If Peek.b(?clone_wbscreen)=0 AND Peek.b(?use_wbscreen )=0 AND myscreen_modeid.l=0
     Poke.b ?use_wbscreen,1          ; we use WBScreen if no Screen Tooltype is set
  EndIf

  MaxLen str2$   = 4096   ; this is important since Honitos used some string pointers, that might be empty
  MaxLen cstr$   = 4096   ; pointers to empty string might be NULL, that's why!
  MaxLen cstr2$  = 4096   ; pointers to empty string might be NULL, that's why!
  MaxLen str2b$  = 4096
  str2$          = ""
  cstr$          = ""
  cstr2$         = ""
  str2b$         = ""
  changelog$     = ""
  oldfindstr$    = ""
  oldreplacestr$ = ""

  ; --- FONTS ----------------------------------------------
  If use_wbfont = False
    ;no Tooltype use_wbfont so check for GUI and Source font tooltypes
    str_guifont$    = dos_GetToolString{"guifont",""}       ; no predefine Font use WB fonts instead
    str_sourcefont$ = dos_GetToolString{"sourcefont",""}

    If str_guifont$<>"" OR str_sourcefont$<>""
      ; check and set GUIfont
      If str_guifont$<>""
        InitArgParse str_guifont$
        guifont$ = NextArgChar$(@",")
        a$ = NextArg$
        guifontsize.w = Vallong(a$)
      EndIf
      ; check and set Sourcefont
      If str_sourcefont$<>""
        InitArgParse str_sourcefont$
        sourcefont$ = NextArgChar$(@",")
        a$ = NextArg$
        sourcefont_size.w = Vallong(a$)
        ;Gosub check_font
        Poke.s ?str_sourcefontname ,sourcefont$ + StrClone(Chr$(0),79 - Len(sourcefont$))
        Poke.w ?sourcefontsize     ,sourcefont_size
        Poke.b ?sourcefontstyle    ,sourcefont_style.w
      EndIf
    Else
      ; no guifont and sourcefont set so use WBfonts
      use_wbfont.b = True
    EndIf
  EndIf

  ; --- DIRECTORIES ---------------------------------------
  my_maindir$      = dos_GetToolString{"ASSIGN",default_assign$}
  If my_maindir$ = "" Then my_maindir$ = default_assign$ ; in case someone sets assign to ""
  my_systemdir$    = dos_AddPart{my_maindir$,"System"}
  my_blitzlibsdir$ = dos_AddPart{my_maindir$,"Blitzlibs"}
  last_source$     = dos_GetToolString{"last_source",""}

  includedir$      = dos_GetToolString{"INCLUDEDIR" ,dos_AddPart{my_maindir$,"Sourcecodes/Includes"}} : Poke.l ?ptr_incdirname,&includedir$
  helpdir$         = dos_GetToolString{"HELPDIR"    ,dos_AddPart{my_maindir$,"Docs"}}
  autodocdir$      = dos_GetToolString{"AUTODOCDIR" ,dos_AddPart{my_maindir$,"Docs"}}
  sourcedir$       = dos_GetToolString{"SOURCEDIR"  ,dos_AddPart{my_maindir$,"Sourcecodes"}} : Poke.l ?ptr_source_dir,&sourcedir$
  addonprefs$      = dos_GetToolString{"WINDOWPREFS",dos_AddPart{my_maindir$,"System/ped_addon.prefs"}} : Poke.l ?ptr_source_dir,&sourcedir$

  CLR.l ptr_deflibsfilename
  deflibfile$      = dos_GetToolString{"LIBFILE",dos_AddPart{my_blitzlibsdir$,"DefLibs"}} : Poke.l ?ptr_deflibsfilename,&deflibfile$

  If dos_Exist{deflibfile$}
    deflibdate$ = dos_GetFileDate{deflibfile$}
  Else
    dummy.l= RTEZRequest(!TRANS{"Libsfile not found!"},!TRANS{"Libsfile not found, using deflibs"},!TRANS{"Ok"})
    deflibdate$ = dos_GetFileDate{dos_AddPart{my_blitzlibsdir$,"DefLibs"}}
  End If
  deflibdate$  = StrChg(deflibdate$,"/",".")
  acidlibdate$ = StrChg(dos_GetFileDate{dos_AddPart{my_blitzlibsdir$,"AcidLibs"}},"/",".")
  Poke$ ?blitzname,my_maindir$
  Poke$ ?str_pedpalfile,dos_AddPart{my_systemdir$,"PED.pal"}
  Poke$ ?str_tedhistory_env,dos_AddPart{my_systemdir$,"PED.history"}
;  Poke$ ?str_tedmenufile,my_systemdir$ + "PED.menus"
  tedmenufile$ = dos_AddPart{my_systemdir$,"PED.menus"}

; ------------------------------------------------------
; EINBINDEN DER KONFIGURATIONSDATEIEN
; ------------------------------------------------------
.CONFIGFILES
WZ_ShowMessage{!TRANS{"Building Helpindex for Includes..."}}
HelpIndexFile$             = dos_AddPart{my_systemdir$,"HelpIndex.txt"}
HelpIndexCacheFile$        = dos_AddPart{my_systemdir$,"HelpIndexCache.bin"}

; our fast tokenizer ...
TokenHashMapFile.s         = dos_AddPart{my_systemdir$,"TokenList.hashmap"}
*PreProcessor.preprocessor = preproc_Create{}
Poke.l ?comPtr_PreProcessor,*PreProcessor
preproc_LoadTokens{*PreProcessor,TokenHashMapFile}

*rc_fib.FileInfoBlock = AllocDosObject_ (#DOS_FIB,0)

If dos_Exist{HelpIndexCacheFile$}
  TED_ReadHelpIndexCache{HelpIndexCacheFile$}
Else
  Gosub build_HelpIndexFile
End If


If ReadFile (0,addonprefs$)
  ReadType 0,wpref(0)
  ReadType 0,wpref(1)
  ReadType 0,wpref(2)
  CloseFile 0
End If

; settings for type browser
newtype_mode.l = 0

; ---------------------------------------- MAINPROGRAM ----------------------------------------------
WZ_ShowMessage{!TRANS{"Starting IDE..."} }
.MAINPROGRAM
!asm
begin1:
  MOVE.l A1,comLong_AB3IsAvailable   ; A1 is teddata of compiler

  ; --
  ; -- initiation of compiler data-interface
  MOVEA.l #comPtr_TokenBase,A0       ;teddata for compiler
  MOVEQ.l #$11,D0
  JL_0_1E:
    MOVE.w (A1)+,(A0)+
  DBF D0,JL_0_1E

  MOVE.l -8(a1),newted
  MOVE.l (a1),constantbase
  MOVE.l ptr_deflibsfilename,4(a1)
  MOVE.l ptr_incdirname,8(a1)

  MOVE.l -4(a1),d0
  BEQ 'l10
    MOVE.l d0,a0
    MOVEQ #6,d1
   'l11
      MOVE.l (a0),a0
    DBF d1,'l11
    MOVE.l a0,newtypebase
 'l10:

  JSR open_doslibrary
  BEQ.w exit_ped

  ; --
  ; -- initiation of some editor datas
.begin
  MOVEQ #127,d0                      ; clear char-table
  LEA chartab,a0
 'l12
    MOVE.b #1,128(a0)
    CLR.b (a0)+
  DBF d0,'l12

  LEA chartab,a0                     ; init char-table
  MOVE.b #1,(a0)
  MOVE.b #1,","(a0)
  MOVE.b #1,";"(a0)
  MOVE.b #1,":"(a0)
  MOVE.b #1,"("(a0)
  MOVE.b #1,")"(a0)
  MOVE.b #1,"="(a0)
  MOVE.b #1,"+"(a0)
  MOVE.b #1,"-"(a0)
  MOVE.b #1,"*"(a0)
  MOVE.b #1,"/"(a0)
  MOVE.b #1,"$"(a0)
  MOVE.b #1,"%"(a0)
  MOVE.b #1,"."(a0)
  MOVE.b #1,"["(a0)
  MOVE.b #1,"]"(a0)
  MOVE.b #1,"{"(a0)
  MOVE.b #1,"}"(a0)
  MOVE.b #1,"\"(a0)
  MOVE.b #1,">"(a0)
  MOVE.b #1,"<"(a0)
  MOVE.b #1,"&"(a0)
  MOVE.b #1,"|"(a0)
  MOVE.b #1,"^"(a0)
  MOVE.w #0101,1(a0)
  MOVE.b #1,$20(a0)

  !basic
  Poke.l ?comPtr_MemPool, CreatePool_(#MEMF_CLEAR,40000,40000)
  If Peek.l(?comPtr_MemPool) = 0
    !cout{"Could not allocate enough memory. PED closes down now."}
    !asm
    !exitasm
    RTS
  EndIf
  Poke.l ?_graphicsbase, OpenLibrary_("graphics.library",0)
  If Peek.l(?_graphicsbase) = 0 Then !asm : BRA.w close_libraries2
  Poke.l ?_intuibase, OpenLibrary_("intuition.library",0)
  If Peek.l(?_intuibase)    = 0 Then !asm : BRA.w close_libraries2
  Poke.l ?comPtr_IntuiBase,Peek.l(?_intuibase)
  Poke.l ?_gadtoolsbase, OpenLibrary_("gadtools.library",0)
  If Peek.l(?_gadtoolsbase) = 0 Then !asm : BRA.w close_libraries2

  If ted_OpenLib{0}
    TEDSetJumpTable  {?COMDATABASE}
    TEDSetFirstLine  {?comPtr_FirstSourceLine}
    TEDSetCurrentLine{?comPtr_CurrentSourceLine}
  Else
    error {!TRANS{"Unable to open ted.library !\\nThe IDE will crash."}}
  EndIf
  !asm

  JSR init_arexxport
  JSR init_clipboard ; for copy only, paste is done by clipboard.include
  BNE.w clipboard_ok
    MOVEA.l #str_no_clipboard_device,A0
    JSR show_errorrequester
  clipboard_ok:

  JSR make_MsgPort

  MOVEA.w #$2000,A0
  ADDA.w comWord_MaxColumns,A0
  ADDA.w comWord_MaxColumns,A0
  ADDA.w comWord_MaxColumns,A0
  ADDQ.w #6,A0
  MOVE.l A0,D0
  MOVEQ.l #$01,D1
  ;MOVEA.l _execbase,A6
  !newalloc;JSR _AllocVec(A6)
  MOVE.l D0,comPtr_DosBuffer
  BEQ.w close_libraries2

  MOVEA.l D0,A0
  LEA $2000(A0),A0
  MOVE.l A0,comPtr_Temp_TokenString1 : ADDA.w comWord_MaxColumns,A0 : ADDQ.w #2,A0
  MOVE.l A0,comPtr_Temp_TokenString2 : ADDA.w comWord_MaxColumns,A0 : ADDQ.w #2,A0
  MOVE.l A0,comPtr_Temp_TokenString3 : ADDA.w comWord_MaxColumns,A0 : ADDQ.w #2,A0
  MOVE.l A0,comPtr_Temp_TokenStringObsolete

  MOVE.l #$2F60+1000,D0
  MOVE.l #$10000,D1
  !newalloc ;JSR _AllocVec(A6)
  MOVE.l D0,AL_0_5B9A
  MOVEA.l D0,A0
  MOVE.l A0,AL_0_5B9E
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,AL_0_5BA2
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,AL_0_5BA6
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,AL_0_5BAA
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,expandstore
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,AL_0_5BB2
  ADD.l #MAX_Columns+4,a0
;  LEA $84(A0)  ,A0 : MOVE.l A0,AL_0_FA2C
;  LEA $108(A0) ,A0 : MOVE.l A0,AL_0_BC8       ; strptr to defaultdirectory
;  LEA $C0(A0)  ,A0 : MOVE.l A0,AL_0_B74C
;  LEA $C0(A0)  ,A0 : MOVE.l A0,AL_0_B750
  LEA $C0(A0)  ,A0 : MOVE.l A0,struct_textfont
;  LEA $C0(A0)  ,A0 : MOVE.l A0,ptr_pluginentry
  LEA $1000(A0),A0 : MOVE.l A0,str_windowtitle

  ; -- copy screentitle to windowtitle
  LEA str_screentitle,A1
  MOVE.l A0,-(A7)
  JL_0_2CA:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_2CA
  MOVEA.l (A7)+,A0

  ;  LEA $100(A0),A0                  ; old colorsettings
  JSR set_oldpreferences

  CLR.w comWord_PrefsWrittenState

  ; --
  ; -- return to compiler after initiation
  MOVE.l comLong_AB3IsAvailable,D0
  BEQ.w start_up_without_compiler
    LEA compiler_jumps_here,A0
    MOVEA.l comdata,A1               ; its now indirect, was moveA.l #comdata before
    MOVE.w #$FFFF,comWord_PEDIsAvailable
    RTS                              ; <-- return to compiler
  start_up_without_compiler:

  LEA str_tempfilename,A0
  compiler_jumps_here:               ; compiler offers str_tempfilename in A0 here
  MOVE.l A0,-(A7)
  !basic
  MOVE.l (a7)+,d0
  tempD0.l = PutD0
  If tempD0
    compiler_source$ = Peek$(tempD0)
  Else
    error{"NULL Pointer in compiler_source$!"}
  End If

  ; --
  ; -- fill mapping array with libnames from mapping-file
  ; -- and check consistency based on the mapping files and the internal libnums
  WZ_ShowMessage{!TRANS{"Building Token Index..."}}
  tokenbase = Peek.l(?comPtr_TokenBase)
  read_libmapping{dos_AddPart{my_systemdir$,"token_mapping_libs.txt"}}
  read_libmapping{dos_AddPart{my_systemdir$,"token_mapping_userlibs.txt"}}

  If *PreProcessor\tokens=#NULL     ; we have no hashmap loaded, create it!
    WZ_ShowMessage{!TRANS{"Creating Hashmaps..."}}
    preproc_QueryTokens{*PreProcessor}
    preproc_SaveTokens{*PreProcessor,TokenHashMapFile}
  End If

  WZ_HideMessage{}
  !asm

.START_GUI
  JSR open_gui
   BMI.w close_libraries

  JSR cursor_off
  JSR menu_opennew
  JSR cursor_on
  JSR update_statusline
  ; --
  ; -- if ptr_source_dir <> NULL then fill str_currentdir with this string
  ; -- and set it as the default directory
  JSR get_currentdir
  TST.l ptr_source_dir
   BEQ 'l2
  MOVE.l #comStr_CurrentDir,a1
  MOVE.l ptr_source_dir,a0
  MOVEQ #100,d0
 'l3
    MOVE.b (a0)+,(a1)+
  BNE 'l3
  BRA 'l1
 'l2
  MOVE.l #comStr_CurrentDir,D0
  JSR set_currentdir
 'l1
  MOVE.l lock_currentdir,lock_defaultdirectory
  CLR.l lock_currentdir

;  LEA comStr_CurrentDir,A0
;  MOVEA.l AL_0_BC8,A1
;  JL_0_3BA:
;    MOVE.b (A0)+,(A1)+
;  BNE.b JL_0_3BA
; JSR split_path_and_name

  !basic
  If Peek.b(?load_last_source)<>0 OR compiler_source$<>""
    If compiler_source$<>"" Then last_source$ = compiler_source$
    If last_source$<>""
      currentdir$ = dos_PathPart{last_source$}
      If Right$(currentdir$,1)<>":" Then currentdir$ + "/" ; dirty hack, but better than editing ASM
      Poke$ ?comStr_SourceName,dos_FilePart{last_source$}
      Poke$ ?comStr_CurrentDir,currentdir$
    EndIf
  EndIf
  !asm
  ; --
  ; -- jump to mainloop if no sourcename given, else
  ; -- load last Source
.AUTOLOAD_SOURCE
  MOVE.b comStr_SourceName,D0
   BEQ.w skip_autoload
  LEA comStr_CurrentDir,A0
  MOVEA.l comPtr_Temp_TokenString1,A1
  MOVE.l A1,D7
  JL_0_40E:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_40E
  SUBQ.w #1,A1
  LEA comStr_SourceName,A0
  JL_0_41A:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_41A
  JSR cursor_off
  JSR load_source
  JSR update_vertscroller
  JSR update_statusline
  JSR update_labelstuff
  JSR cursor_on_force
  skip_autoload:

  ; --
  ; -- show welcome requester if option selected
.WELCOME_REQUESTER
  TST.b no_welcome
  BNE 'skip_welcome
    JSR menu_about

 'skip_welcome:
  ; -- jump to main loop
  JSR main_loop

Exit_main:                                           ; insert to remove the evil stackmagic by/for
                                                     ; quit and have a clean way to exit the endless
                                                     ; main_loop without modifing it  tomsmart1
  ; --
  ; -- shutdown PED after return of the mainloop
  CLR.w comWord_PEDIsAvailable
  JSR close_gui

 close_libraries:
  !basic
  ; replace close of Sourcefonts here by a subroutine call because we need it more then once  tomsmart1
  Gosub close_sourcefont

  ;If Peek.l(?_diskfontbase)   Then CloseLibrary_   Peek.l(?_diskfontbase)  : CLR.l _diskfontbase
  ;If Peek.l(?ptr_aslrequest)  Then FreeAslRequest_ Peek.l(?ptr_aslrequest) : CLR.l ptr_aslrequest
  !asm

  MOVEA.l comPtr_DosBuffer,A1
  MOVE.l A0,D0
  ;MOVEA.l _execbase,A6
  !newfree                           ;a0: poolHeader, a1:memory, d0:memSize

 close_libraries2:
  JSR close_arexxport
  JSR close_clipboard   ; paste is done by clipboard.include

  !basic
  If *MyCatalog             Then CloseCatalog_ *MyCatalog ; If we used a Catalog so close it

  If Peek.l(?_gadtoolsbase) Then CloseLibrary_ Peek.l(?_gadtoolsbase)  : CLR.l _gadtoolsbase
;  If Peek.l(?_aslbase)      Then CloseLibrary_ Peek.l(?_aslbase)      : CLR.l _aslbase
  If Peek.l(?_intuibase)    Then CloseLibrary_ Peek.l(?_intuibase)                      ; is in use by compiler
  If Peek.l(?_graphicsbase) Then CloseLibrary_ Peek.l(?_graphicsbase)                   ; is in use by compiler
  If Peek.l(?_dosbase)      Then CloseLibrary_ Peek.l(?_dosbase)                        ; is in use by compiler
  ;If *tedlibbase            Then CloseLibrary_ *tedlibbase             : *tedlibbase = 0 ;: CLR.l _tedlibbase
  ted_CloseLib{}
  !asm

  MOVEA.l _execbase,A6
  JSR free_historyfilelist

  TST.l AL_0_5B9A
   BEQ.w JL_0_584
  MOVEA.l AL_0_5B9A,A2
  NOP

 JL_0_584:
  JSR kill_MsgPort

  MOVE.l lock_defaultdirectory,D1
  MOVEA.l _dosbase,A6
  JSR _CurrentDir(A6)

  MOVE.l lock_currentdir,D1
  BEQ.w JL_0_5BE
  JSR _UnLock(A6)

 JL_0_5BE:
  MOVE.w comWord_PEDIsAvailable,D0
  EXT.l D0

 exit_ped:
  MOVEA.l _execbase,A6
  MOVE.l comPtr_MemPool,a0
  JSR _DeletePool(a6)

  ; -- check if there is any message left and reply it
;  MOVE.l ptr_Message,D0
;   BEQ.w JL_0_6E8
;  MOVEA.l _execbase,A6
;  JSR _Forbid(A6)
;  MOVEA.l ptr_Message,A1
;  JSR _ReplyMsg(A6)
;  JSR _Permit(A6)
;  JL_0_6E8:
  !basic
;  If Peek.b(?load_last_source) = 0
;    dos_SetToolString{"LAST_SOURCE",""}
;  EndIf
  Gosub coutclose

  CNIF #use_NTUI ; free all NTUI related resoruces
    If *tuiPED Then ntui_FreeEngine{*tuiPED} : *tuiPED = #NULL
    _ntui_Free{}
  CEND

  preproc_Free{*PreProcessor} : *PreProcessor=#NULL
  If *rc_fib Then FreeDosObject_ #DOS_FIB,*rc_fib  : *rc_fib=#NULL
  rc_cacheptr.l = Peek.l(?readcache_cacheptr)
  If rc_cacheptr
    FreeVec_ rc_cacheptr
    Poke.l ?readcache_cacheptr,#NULL
    Poke.l ?readcache_cachelen,0
    Poke.l ?readcache_readlen ,0
  End If
  !asm
  !exitasm ; exitasm jumps into basic mode
End

; ----------------------------------- END OF MAINPROGRAM ------------------------------------------


.abnormal_exit:
  !asm
  CLR.w comWord_PEDIsAvailable
  MOVEA.l comdata,A1                 ; its now indirect, was #comdata before
  !exitasm ; exitasm jumps into basic mode
End





; ---------------------------------- THIS IS THE MAINLOOP -----------------------------------------
.main_loop:
CNIF #use_NTUI
  !basic
  ntui_Handle{}
  !asm
CEND

  ; -- ab hier Probleme ohne vorhandene FPU...
  CLR.w comWord_LabelListChanged
  CLR.w comWord__AL_0_86C0
  JSR PED_events
  MOVEA.l comPtr_CurrentSourceLine,A4

  ; --- check if an exe is running ---
  TST.b comByte_RunningFlag
  BEQ 'l1
    TST.w comWord_KeyBeforeReturn
    BEQ 'l1
      JSR _redraw
      CLR.w comWord_KeyBeforeReturn
 'l1

  MOVE.w comWord_KeyBeforeReturn,D0
  BEQ.w JL_0_CC6
    !basic
    ; --- get address of actual source line ---
    MOVE.l comLong_DisplayLine,D1
    ADD.l comLong_DisplayLineOffset,D1
    MOVE.l d1,lastedited_line
    MOVE.w comWord_KeyBeforeReturn,D0
    MOVE.w D0,comWord_SourceChanged

    MOVEQ #0,D0
    MOVEA.l textbufferaddr,A2
    ADDA.w comWord_TextBufferOffset,A2
    MOVE.l a2,d0 : lineaddr.l = PutD0

    ; --- store cursor column position ---
    MOVEQ #0,D0
    MOVE.w comWord_Column,D0
    ADD.w comWord_ColumnsOffset,D0
    columnpos.w = PutD0

    ; --- format source line and get new column position ---
    newcolumnpos.w = preparseline{columnpos,lineaddr,Peek.b(?auto_format),Peek.b(?correct_functions)}
    GetD0 newcolumnpos
    SUB.w comWord_ColumnsOffset,D0
    MOVE.w D0,comWord_Column
    old_search_label$ = "|"
    !asm

    ; -- parse the current line
    JSR parse_line

    ; --- draw block mark if existing
    SF comByte_StateBlockMark
    TST.l comLong_BlockEndY
    BMI.w exit_updateblock
      MOVEM.l D0-D3/A0-A2,-(A7)
      MOVE.l comLong_DisplayLine,D1
      ADD.l comLong_DisplayLineOffset,D1
      CMP.l comLong_BlockStartY,D1
       BLT.w JL_0_C66
      CMP.l comLong_BlockEndY,D1
       BGT.w JL_0_C66
      MOVE.w comLong_BlockStartX,D0
      MOVE.l comLong_BlockStartY,D1
      MOVE.w comLong_BlockEndX,D2
      MOVE.l comLong_BlockEndY,D3
      CMP.l D1,D3
       BNE.w JL_0_C50
      CMP.w D0,D2
       BNE.w JL_0_C50
      MOVE.w visiblecolumns,D2

 JL_0_C50:
      SUB.l comLong_DisplayLineOffset,D3
      SUB.l comLong_DisplayLineOffset,D1
      JSR JL_0_59BC
      ST comByte_StateBlockMark

 JL_0_C66:
      MOVEM.l (A7)+,D0-D3/A0-A2

 exit_updateblock:
    JSR JL_0_55AA

    MOVE.w comWord_DoTokenize,D0
    BEQ.w JL_0_CC6
      JSR print_current_sourceline

      TST.b comByte_StateBlockMark
      BEQ.w JL_0_CC6
        MOVEM.l D0-D3/D7/A0-A2,-(A7)
        MOVE.w comLong_BlockStartX,D0
        MOVE.l comLong_BlockStartY,D1
        MOVE.w comLong_BlockEndX,D2
        MOVE.l comLong_BlockEndY,D3
        CMP.l D1,D3
         BNE.w JL_0_CB2
        CMP.w D0,D2
         BNE.w JL_0_CB2
        MOVE.w visiblecolumns,D2

 JL_0_CB2:
        SUB.l comLong_DisplayLineOffset,D3
        SUB.l comLong_DisplayLineOffset,D1
        JSR JL_0_59BC
        MOVEM.l (A7)+,D0-D3/D7/A0-A2

 JL_0_CC6:
  ; -- auf bestimmte Events in D7 pruefen
  LEA comArray_KeyTable,A0

 JL_0_CCC:
    MOVE.b (A0)+,D0
     BEQ.w main_loop                 ; Tabelle zu Ende
    CMP.b D0,D7
     BEQ.w JL_0_CDC
    ADDQ.w #5,A0
BRA.b JL_0_CCC

 JL_0_CDC:
  MOVE.b (A0)+,-(A7)                 ; entsprechenden Wert aus keytable auslesen und auf stack packen
  MOVEA.l (A0)+,A0                   ; pointer zur entsprechenden Funktion nach A0

  ; --
  ; -- check if an executable is running and prevent IDE from doing things
  TST.b comByte_RunningFlag
  BEQ no_running_exe
  CMP.w #$1c,d7   ;crsr              ;runtask allows
  BEQ no_running_exe
  CMP.w #$1d,d7   ;crsr
  BEQ no_running_exe
  CMP.w ##MENU_SAVEAS,d6             ;save as
  BEQ no_running_exe
  CMP.w ##MENU_CUSTOM,d6             ;custom menu
  BGE no_running_exe
  CMP.w #$fffd,d7 ;mouseclick
  BEQ no_running_exe
  CMP.w #$8b,d7   ;help key
  BEQ no_running_exe
    BRA check_panic
    check_panic_exit:

 no_running_exe:
  CLR.b redraw_ped
  CMP.w #$fffd,d7                    ; mouseclick ?
  BNE 'n1a
    MOVE.b #1,redraw_ped

 'n1a
  JSR (a0)

  ; -- check for some tokens and automatically add the closing token
  ; --
  !regs2stack
  !basic
  If Peek.b(?auto_constructs)
    If last_key.l = $D
      a$ = check_constructs{?comPtr_CurrentSourceLine}
      If a$<>""
        !basic
        Gosub insertstring
        !asm
        Gosub insertreturn
        JSR movelineup
        JSR insertreturn
        JSR movelineup
        !basic
      EndIf
    EndIf
  EndIf
  !stack2regs
  !asm

  TST.b redraw_ped
  BNE 'n2a
    CMP.w #$fffd,d7                  ;mouseclick
    BNE 'l1_a

 'n2a
      MOVE.l a0,-(a7)
      JSR _redraw
      MOVE.l (a7)+,a0

 'l1_a
  CMP.w #$fffc,d7
  BNE 'n1
    !basic
    Gosub diag_redraw
    !asm

 'n1
 JL_0_CE2:                                              ;?? looks like double label ??

  MOVE.w comWord_LabelListChanged,D0
  BEQ.w JL_0_CFA
    JSR update_labelstuff

 JL_0_CFA:
  MOVE.b (A7)+,D0
  TST.b D0
   BEQ.w main_loop

  JSR update_vertscroller
BRA.w main_loop
; ----------------------------------------- END OF MAINLOOP -------------------------------------



.check_panic
  !basic
  *task.Task = 0
;  *task.Task = FindTask_(!TRANS{"AB3 Program Process"})
;  If *task=0 Then *task = FindTask_("AB3 Program Process")
  If *task=0 Then *task = FindTask_("Blitz ][ Program Proc")
  Poke.l ?taskaddr,*task
;  MOVE.l d0,taskaddr
  dummy.l= RTEZRequest("",!TRANS{"This action is not allowed while executing a program\\nShould PED do a PANIC program kill?"},!TRANS{"OK|CANCEL"})
  !asm
  TST.l d0
  BEQ 'lexit
    ; -- panic executable kill
    MOVE.l a0,-(a7)

    MOVE.l taskaddr,D0
    BEQ 'exit
      ; -- close all windows and screens of executable
      MOVEA.l D0,A1
      MOVEA.l _execbase,A6
      JSR _Forbid(a6)
      MOVE.l taskaddr,a1
      CLR.l ptr_exescreen
      MOVE.l _intuibase,a6
      MOVEM.l a2/a3,-(a7)
      MOVE.l $3c(a6),d0              ;Intuibase\Firstscreen

 'l4
        MOVE.l d0,a0
        MOVE.l $4(a0),d0             ;FirstScreen\Firstwindow
        BEQ 'l1

 'l3
        MOVE.l d0,a2
        MOVE.l $56(a2),a3            ;FirstWindow\UserPort
        CMP.l $10(a3),a1             ;UserPort\*mp_SigTask = taskaddr ??
        BNE 'l2

        MOVE.l a0,ptr_exescreen
        MOVEM.l a0/a1,-(a7)
        CLR.l $56(a2)
        MOVE.l _intuibase,a6
        MOVE.l a2,a0
        JSR _CloseWindow(a6)         ; Close the window
        MOVEM.l (a7)+,a0/a1
        MOVE.l a0,d0
        BNE 'l4

 'l2
        MOVE.l (a2),d0
      BNE 'l3

 'l1
      MOVE.l (a0),d0
      BNE 'l4
      MOVE.l ptr_exescreen,d0
      BEQ 'l10
        !basic
        CloseScreen_ Peek.l(?ptr_exescreen)
        !asm

 'l10
      MOVEM.l (a7)+,a2/a3
      MOVE.l _execbase,A6
      MOVE.l taskaddr,D0
      BEQ 'exit
      MOVEA.l D0,A1              ; remove the executable task
      JSR _RemTask(A6)
      JSR _Permit(a6)
      CLR.b comByte_RunningFlag

 'exit
    MOVE.l (a7)+,a0
BRA check_panic_exit

 'lexit
BRA JL_0_CE2







; -----------------------------------------------------------------------------------------------
_graphicsbase:           Dc.l 0
_intuibase:              Dc.l 0
;_aslbase:                Dc.l 0
_gadtoolsbase:           Dc.l 0
str_libname_dos:         Dc.b "dos.library",0 : Even
_dosbase:                Dc.l 0
str_libname_workb:       Dc.b "workbench.library",0 : Even
_workbenchbase:          Dc.l 0
ptr_sourcefont:          Dc.l 0
ptr_sourcefonti:         Dc.l 0
ptr_sourcefontb:         Dc.l 0
str_libname_diskfont:    Dc.b "diskfont.library",0 : Even
_diskfontbase:           Dc.l 0

ptr_AppMenuItem:         Ds.l 1
ptr_thisTask:            Ds.l 1
;ptr_Message:             Ds.l 1
str_tempfilename:        Ds.b #MAX_STRINGSIZE
AL_0_766:                Ds.w 59

str_pedname:             Dc.b "PED ",!versions,0: Even
                         Ds.b #MAX_STRINGSIZE
Even
str_screentitle:         Ds.b #MAX_STRINGSIZE  ;"AmiBlitz3 - PED V",!versions," (\\__DATE_GER__)",0

str_pedscreenname:
                         Dc.b "SCR1_0_AB",0
                         Ds.b 200
Even
str_version:             Dc.b "$VER: PED ",!versions,0
Even



;_tedlibbase:            Ds.l 1
ptr_msgport_clipboard:   Ds.l 1
AL_0_B90:                Ds.l 1
ptr_iorequest_clipboard: Ds.l 1
str_devname_clipboard:   Dc.b "clipboard.device",0 : Even
                         Ds.l 2
AL_0_802:                Dc.l AL_0_822
AL_0_806:                Dc.l str_defaultpubscreen
AL_0_80A:                Dc.l AL_0_838
AL_0_80E:                Dc.l str_Arexx_PortName
AL_0_812:                Dc.l AL_0_82C
AL_0_816:                Dc.l str_defaultpubscreen
                         Ds.l 2
AL_0_822:                Dc.b "TEDSCREEN",0
AL_0_82C:                Dc.b "TEDSSCREEN",0 : Even
AL_0_838:                Dc.b "TEDSPORT",0 : Even
                         Ds.l 1
Even

.open_doslibrary:
  MOVEA.l _execbase,A6
  LEA str_libname_dos,A1
  JSR _OldOpenLibrary(A6)
  MOVE.l D0,_dosbase
RTS




.init_clipboard:
  MOVEA.l _execbase,A6
  JSR _CreateMsgPortA(A6)

  MOVE.l D0,ptr_msgport_clipboard
  MOVEA.l D0,A0
  MOVEQ.l #$34,D0
  JSR _CreateIORequest(A6)

  MOVE.l D0,ptr_iorequest_clipboard
  LEA str_devname_clipboard,A0
  MOVEQ.l #$00,D0
  MOVEA.l ptr_iorequest_clipboard,A1
  MOVEQ.l #$00,D1
  JSR _OpenDevice(A6)

  TST.l D0
  BEQ.w JL_0_9DA
  MOVEQ.l #$00,D0
  RTS

  JL_0_9DA:
  ST AL_0_B90
  MOVEQ.l #-$01,D0
  TST.w D0
RTS

.close_clipboard:
  TST.l ptr_iorequest_clipboard
   BEQ.w exit_closeclipboard
  MOVEA.l _execbase,A6
  MOVEA.l ptr_iorequest_clipboard,A1
  JSR _CloseDevice(A6)

  MOVEA.l ptr_msgport_clipboard,A0
  JSR _DeleteMsgPort(A6)

  CLR.l ptr_msgport_clipboard
  MOVEA.l ptr_iorequest_clipboard,A0
  JSR _DeleteIORequest(A6)

  CLR.l ptr_iorequest_clipboard
  exit_closeclipboard:
RTS

.error_unable_screen:
  MOVEA.l #str_unable_screen,A0
  JSR show_errorrequester
RTS

.error_unable_window:
  MOVEA.l #str_unable_window,A0
  JSR show_errorrequester
RTS

.make_MsgPort:
  MOVEA.l _execbase,A6
  LEA str_libname_workb,A1
  MOVEQ.l #$24,D0
  JSR _OpenLibrary(A6)
  MOVE.l D0,_workbenchbase

  JSR _CreateMsgPortA(A6)
  MOVE.l D0,struct_MsgPort
RTS

.kill_MsgPort:
  TST.l _workbenchbase
  BEQ.w JL_0_A80

  MOVEA.l _execbase,A6
  MOVEA.l _workbenchbase,A1
  JSR _CloseLibrary(A6)

  CLR.l _workbenchbase
  MOVEA.l struct_MsgPort,A0
  JSR _DeleteMsgPort(A6)
  JL_0_A80:
RTS



.menu_settings:
 !basic
 used_win.l = Used Window
; WZWindow WZID("WIN_SETTINGS"),0,255,ScreenWidth/4,ScreenHeight/6,ScreenWidth/2,ScreenHeight/1.5,WZID("WIN_SETTINGS")
 WZWindow WZID("WIN_SETTINGS"),?wzgui,255,-2,-2,-2,-2,WZID("WIN_SETTINGS")
 Use Window WZID("WIN_SETTINGS")
 ; make tab 0 active
 WZPrint "SET_PAGES",0

 ; init tempcolors
 For i = 0 To 24
  AB3RGB_temp(i) = AB3RGB(i)
 Next i

 ; init gadgets
 If Peek.b(?auto_format)           Then WZPrint "SET_AUTO_FORMAT"        ,On
 If Peek.b(?auto_constructs)       Then WZPrint "SET_COMPLETE_CONSTRUCTS",On
 If Peek.b(?use_intellisense)      Then WZPrint "SET_INTELLISENSE"       ,On
 If Peek.b(?correct_functions)     Then WZPrint "SET_CORRECT_FUNCTIONS"  ,On
 If Peek.w(?smart_tokenization)    Then WZPrint "SET_SMART_TOKENIZATION" ,On
 If Peek.b(?new_editmode)          Then WZPrint "SET_STANDARD_EDITMODE"  ,On
 If Peek.b(?no_welcome)            Then WZPrint "SET_WELCOME"            ,On

 If Peek.b(?onlinehelp)            Then WZPrint "SET_ONLINEHELP"         ,On
 If Peek.w(?bold_tokens)           Then WZPrint "SET_BOLDTOKENS"         ,On
 If Peek.w(?italic_remarks)        Then WZPrint "SET_ITALICREMARKS"      ,On
 If Peek.w(?remember_saved)        Then WZPrint "SET_REMEMBER_SAVED"     ,On
 If Peek.b(?load_last_source)      Then WZPrint "SET_LAST_SOURCE"        ,On

 If Peek.w(?use_pubscreen)         Then WZPrint "SET_PUBSCREEN"          ,On
 If Peek.w(?use_default_pubscreen) Then WZPrint "SET_DEFAULTPUBSCREEN"   ,On
 If Peek.w(?use_filepattern)       Then WZPrint "SET_FILEPATTERN"        ,On
 If Peek.w(?auto_indent)           Then WZPrint "SET_AUTO_INDENT"        ,On
 If Peek.l(?nodisplaybeep)         Then  WZPrint "SET_NO_DISPLAYBEEP"    ,On
 If Peek.w(?oldsearch)= 1          Then WZPrint "SET_OLDSEARCH"          ,On

 If console_device$ <>""           Then WZPrint "SET_CONSOLE_DEVICE"     ,&console_device$
 If console_wb = True              Then WZPrint "SET_CONSOLE_ON_WB"      ,True
 If console_wait = True            Then WZPrint "SET_CONSOLE_WAIT"       ,True
 ;if console_dontclose = true       Then wzprint "SET_CONSOLE_

 WZPrint "SET_SORTLABELS",sort_labels

 If NOT Peek.b(?old_scrolling)
   WZDisable "SET_SCROLLRATE"
 Else
   WZPrint "SET_SCROLLRATE",scroll_rate
 EndIf

 WZPrint "SET_TAB_SIZE"       ,Peek.w(?tab_size)
 WZPrint "SET_CURSORBLINKRATE",Peek.b(?blinkrate)

 tsourcedir$  =sourcedir$
 tdeflibfile$ =deflibfile$
 tincludedir$ =includedir$
 tautodocdir$ =autodocdir$
 thelpdir$    =helpdir$

 WZPrint "SET_SOURCEDIR"  ,&tsourcedir$
 WZPrint "SET_DEFLIBS"    ,&tdeflibfile$
 WZPrint "SET_INCDIR"     ,&tincludedir$
 WZPrint "SET_AUTODOCDIR" ,&tautodocdir$
 WZPrint "SET_HELPDIR"    ,&thelpdir$

 ; get screen infos
 temp_id.l     = Peek.l(?ownscreen_modeid)
 temp_width.w  = Peek.w(?ownscreen_width)
 temp_height.w = Peek.w(?ownscreen_height)
 temp_depth.w  = Peek.w(?ownscreen_depth)
 ;get screenname
 temp_scr$ = screen_GetModeName{temp_id}
 ; check if is the ID unknown then get best match
 If temp_scr$ = "unknown"
   temp_id.l = screen_GetBestModeID{temp_width,temp_height,temp_depth}
   temp_scr$ = screen_GetModeName{temp_id}
 EndIf
 ;set screenrequester initials
 screen_SetASLInitialDims{temp_id,temp_width,temp_height,temp_depth}
 WZPrint "SET_SCREENNAME",&temp_scr$

 ;get Font infos
 newsourcefont$      = Peek.s(?str_sourcefontname)
 newsourcefontsize.l = Peek.w(?sourcefontsize)
 newguifont$         = guifont$
 newguifontsize.l    = guifontsize
 tempstr$            = newsourcefont$ + " ("+Str$(newsourcefontsize)+")"
 WZPrint "SET_SOURCEFONTNAME",&tempstr$
 tempstr2$           = guifont$+" ("+Str$(guifontsize)+")"
 WZPrint "SET_GUIFONTNAME",&tempstr2$
 olduse_wbfont.b     = use_wbfont               ; temp variables to check former stat
 olduse_wbscreen.b   = Peek.b(?use_wbscreen)


 If Peek.b(?use_wbscreen)<>0
   WZPrint "SET_USEWB"  ,On
   WZPrint "SET_CLONEWB",Off
   WZDisable "SET_SCREENNAME"
   WZDisable "SET_SCREEN"
   For i = 0 To 3
    WZDisable "SET_SCREENCOL"+Str$(i)   ; disable Screencolors
   Next i
   usewbscreen_tmp.b = True             ; temporay variable for prefs window
 Else
   For i = 0 To 3
    WZEnable "SET_SCREENCOL"+Str$(i)    ; enable Screencolors
   Next i
   usewbscreen_tmp.b = False
 EndIf

 If Peek.b(?clone_wbscreen)<>0
   WZPrint "SET_USEWB"  ,Off
   WZPrint "SET_CLONEWB",On
   WZDisable "SET_SCREENNAME"
   WZDisable "SET_SCREEN"
   usewbscreen_tmp.b = False
 EndIf

 If use_wbfont = True                   ;<>0
   WZPrint "SET_USEWBFONT",On
   WZDisable "SET_SOURCEFONT"
   WZDisable "SET_SOURCEFONTNAME"
   WZDisable "SET_GUIFONT"
   WZDisable "SET_GUIFONTNAME"
   usewbfont_tmp.b = True               ; temporay variable for prefs window
 Else
   WZPrint "SET_USEWBFONT",Off
   WZEnable "SET_SOURCEFONT"
   WZEnable "SET_SOURCEFONTNAME"
   usewbfont_tmp.b = False
   If usewbscreen_tmp.b = True          ; only active GuiFontsettings if we don't use WBscreen
     WZDisable "SET_GUIFONT"
     WZDisable "SET_GUIFONTNAME"
   Else
     WZEnable "SET_GUIFONTNAME"
     WZEnable "SET_GUIFONT"
   EndIf
 EndIf


 ; get asl information
 If Peek.w(?use_asldims) Then WZPrint "SET_asl_DIMENSIONS",On
 WZPrint "SET_ASLX",Peek.l(?aslreq_x)
 WZPrint "SET_ASLY",Peek.l(?aslreq_y)
 WZPrint "SET_ASLW",Peek.l(?aslreq_width)
 WZPrint "SET_ASLH",Peek.l(?aslreq_height)

 *cw_gad.Gadget = WZGadAddr("SET_COLORWHEEL")
 cw_open.l          = False
 colnum.w           = -1
 rebuild_gui.b      = False
 rebuild_menu.b     = False

 settings_loop:
  exit_settings.b   = False
  save_settings.b   = False
  use_settings.b    = False
  reopen_settings.b = False
  update_colors.b   = False


 Repeat
   !ev_WaitEvent

   If Peek.b(?onlinehelp)<>0
      If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) AND (ev<>#IDCMP_GADGETHELP)  AND (ev<>#IDCMP_CHANGEWINDOW)
        WZ_HideHelp{}
      EndIf
      If ev = #IDCMP_GADGETHELP Then WZ_ShowHelp{}
   EndIf

   Select ev
   Case #IDCMP_MOUSEMOVE
     If (WZInput("SET_PAGES") = 2) AND (cw_open = True)
       ; Get current RGB-Value in relation to the Gradient-slider
       _RGB.l = WZ_GetColorWheelRGB{}
       If _RGB <> old_RGB.l
         WZ_SetColorGradientSlider{_RGB}
         old_RGB = _RGB
         update_colors.b = True
         If colnum<>-1
           AB3RGB_temp(colnum)= _RGB
           Gosub update_colorboxes
         EndIf
       EndIf
     EndIf

   Case #IDCMP_VANILLAKEY
     Select EventCode
     Case $1B: exit_settings = True
     End Select

   Case #IDCMP_REFRESHWINDOW
     Gosub update_colorwheel
     Gosub update_colorboxes

   Case #IDCMP_CLOSEWINDOW
     exit_settings = True

   Case #IDCMP_IDCMPUPDATE
     ; check the colorgadgets
     If Left$(WZGadName,9) = "SET_COLOR"
       colnum = Vallong(StrChg(WZGadName,"SET_COLOR",""))
       update_colors = True
       Gosub update_colorboxes
       WZ_SetColorWheelRGB{AB3RGB_temp(colnum)}
     Else
       If Left$(WZGadName,13) = "SET_SCREENCOL"
         colnum.w = Vallong(StrChg(WZGadName,"SET_SCREENCOL","")) + 20
         update_colors = True
         rebuild_gui   = True
         Gosub update_colorboxes
         WZ_SetColorWheelRGB{AB3RGB_temp(colnum)}
       EndIf
     EndIf

     ; check all other gadgets
     Select WZGadName
     Case "SET_PAGES"
       Gosub update_colorwheel
       Gosub update_colorboxes

     Case "SET_SOURCEDIR"
       tsourcedir$ = WZInputstr
       WZPrint "SET_SOURCEDIR",&tsourcedir$

     Case "BUTTON_SOURCEDIR"
       aslfr_SetRequesterTitle {0,!TRANS{ "Please select source directory:"},"",""}
       aslfr_SetPath{0,tsourcedir$,"",""}
       If aslfr_Request{0,False,False,True}
         tsourcedir$ = aslfr_GetNextFile{}
         WZPrint "SET_SOURCEDIR",&tsourcedir$
       EndIf

     Case "SET_INCDIR"
       tincludedir$ = WZInputstr
       WZPrint "SET_INCDIR",&tincludedir$

     Case "BUTTON_INCDIR"
       aslfr_SetRequesterTitle {0,!TRANS{"Please select includes directory:"},"",""}
       aslfr_SetPath{0,tincludedir$,"",""}
       If aslfr_Request{0,False,False,True}
         tincludedir$ = aslfr_GetNextFile{}
         WZPrint "SET_INCDIR",&tincludedir$
       EndIf

     Case "SET_HELPDIR"
       thelpdir$ = WZInputstr
       WZPrint "SET_HELPDIR",&thelpdir$

     Case "BUTTON_HELPDIR"
       aslfr_SetRequesterTitle {0,!TRANS{"Please select help directory:"},"",""}
       aslfr_SetPath{0,thelpdir$,"",""}
       If aslfr_Request{0,False,False,True}
         thelpdir$ = aslfr_GetNextFile{};ASLPathRequest$("Select doc directory:",thelpdir$);,aslx,asly,aslw,aslh)
         WZPrint "SET_HELPDIR",&thelpdir$
       EndIf

     Case "SET_AUTODOCDIR"
       tautodocdir$ = WZInputstr
       WZPrint "SET_AUTODOCDIR",&tautodocdir$

     Case "BUTTON_AUTODOCDIR"
       aslfr_SetRequesterTitle {0,!TRANS{ "Please select AutoDocs directory:"},"",""}
       aslfr_SetPath{0,tautodocdir$,"",""}
       If aslfr_Request{0,False,False,True}
         tautodocdir$ = aslfr_GetNextFile{} ;ASLPathRequest$("Select autodoc directory:",tautodocdir$);,aslx,asly,aslw,aslh)
         WZPrint "SET_AUTODOCDIR",&tautodocdir$
       EndIf

     Case "BUTTON_DEFLIBS"
       aslfr_SetRequesterTitle {0,!TRANS{"Please select standard DefLibs file:"},"",""}
       aslfr_SetPath{0,dos_PathPart{tdeflibfile$},dos_FilePart{tdeflibfile$},"#?"}
       If aslfr_Request{0,False,False,False}
         tdeflibfile$ = aslfr_GetNextFile{} ; tdeflibs$ = ASLFileRequest$("Select deflibs file:",aslpath$,aslfile$,"",aslx,asly,aslw,aslh)
         WZPrint "SET_DEFLIBS",&tdeflibfile$
       EndIf

     Case "SET_asl_DIMENSIONS"
       If WZInput = 0
         WZDisable "SET_ASLX"
         WZDisable "SET_ASLY"
         WZDisable "SET_ASLW"
         WZDisable "SET_ASLH"
       Else
         WZEnable "SET_ASLX"
         WZEnable "SET_ASLY"
         WZEnable "SET_ASLW"
         WZEnable "SET_ASLH"
       EndIf

     Case "SET_PUBSCREEN"
       If WZInput = 0
         WZPrint "SET_DEFAULTPUBSCREEN",Off : WZDisable "SET_DEFAULTPUBSCREEN"
       Else
         WZEnable "SET_DEFAULTPUBSCREEN"
       EndIf
       rebuild_gui = True

     Case "SET_DEFAULTPUBSCREEN"
       rebuild_gui = True

     Case "SET_REMEMBER_SAVED"
       rebuild_menu = True

     Case "SET_CLONEWB"
       If WZInput
         WZDisable "SET_SCREENNAME"
         WZDisable "SET_SCREEN"
         WZPrint   "SET_USEWB",Off
         usewbscreen_tmp.b = False
         If usewbfont_tmp.b = False     ;only actived GUIfontsetting if we don't use WBFonts
           WZEnable "SET_GUIFONTNAME"
           WZEnable "SET_GUIFONT"
         EndIf
       Else
         WZEnable "SET_SCREENNAME"
         WZEnable "SET_SCREEN"
       EndIf
       rebuild_gui = True

     Case "SET_USEWB"
       If WZInput
         For i = 0 To 3
          WZDisable "SET_SCREENCOL"+Str$(i)
         Next i
         WZDisable "SET_SCREENNAME"
         WZDisable "SET_SCREEN"
         WZPrint   "SET_CLONEWB",Off
         usewbscreen_tmp.b = True       ; deactived GUIFontsettings we use WBScreen
         WZDisable "SET_GUIFONT"
         WZDisable "SET_GUIFONTNAME"
       Else
         For i = 0 To 3
          WZEnable "SET_SCREENCOL"+Str$(i)
         Next i
         WZEnable "SET_SCREENNAME"
         WZEnable "SET_SCREEN"
         usewbscreen_tmp.b = False
           If usewbfont_tmp.b = False    ;only actived GUIfontsetting if we don't use WBFonts
             WZEnable "SET_GUIFONTNAME"
             WZEnable "SET_GUIFONT"
         EndIf
       EndIf
       rebuild_gui = True

     Case "SET_SCREEN"
       aslsm_SetRequesterTitle {!TRANS{"Please select screenmode:"},!TRANS{ "Ok"},!TRANS{ "Cancel"}}
       If aslsm_Request{}
          temp_id.l     = screen_GetASLModeID{}
          temp_width.w  = screen_GetASLWidth{}
          temp_height.w = screen_GetASLHeight{}
          temp_depth.w  = screen_GetASLDepth{}
          temp_scr$     = screen_GetASLModeName{}
          WZPrint "SET_SCREENNAME",&temp_scr$
          rebuild_gui   = True
       EndIf

     Case "SET_GUIFONT"
       aslfo_SetRequesterTitle {!TRANS{"Please select GUI-Font:"},!TRANS{"Ok"},!TRANS{ "Cancel"}}
       aslfo_SetInitialFont{newguifont$,newguifontsize}
       If aslfo_Request{True}
         newguifont$      = aslfo_GetFontName{}
         newguifontsize   = aslfo_GetFontSize{}
         ;newguifontstyle = *finfo2\ta_Style
         tempstr2$= newguifont$ + " ("+Str$(newguifontsize)+")"
         WZPrint "SET_GUIFONTNAME",&tempstr2$
       EndIf

     Case "SET_USEWBFONT"
       If WZInput
         usewbfont_tmp.b = True
         WZDisable "SET_GUIFONT"
         WZDisable "SET_GUIFONTNAME"
         WZDisable "SET_SOURCEFONT"
         WZDisable "SET_SOURCEFONTNAME"
       Else
         usewbfont_tmp.b = False
         WZEnable "SET_SOURCEFONTNAME"
         WZEnable "SET_SOURCEFONT"
         If usewbscreen_tmp.b = False     ; make GUIfont selectable only if way don't use wbscreen
           WZEnable "SET_GUIFONT"
           WZEnable "SET_GUIFONTNAME"
         EndIf
       EndIf
       rebuild_gui = True

     Case "SET_SOURCEFONT"
       aslfo_SetRequesterTitle {!TRANS{"Please select Source-Font:"},!TRANS{"Ok"},!TRANS{"Cancel"}}
       aslfo_SetInitialFont{newsourcefont$,newsourcefontsize}
       If aslfo_Request{False}
         newsourcefont$     = aslfo_GetFontName{}
         newsourcefontsize  = aslfo_GetFontSize{}
         ;newsourcefontstyle = *finfo2\ta_Style
         tempstr$= newsourcefont$ + " ("+Str$(newsourcefontsize)+")"
         WZPrint "SET_SOURCEFONTNAME",&tempstr$
       EndIf

     Case "SET_F4"
       savewinpref{0,?ptr_sourcewindow} : JSR write_newprefs
     Case "SET_F5"
       savewinpref{1,?ptr_sourcewindow} : JSR write_newprefs
     Case "SET_F6"
       savewinpref{2,?ptr_sourcewindow} : JSR write_newprefs

     ; UNTERSTE BUTTON-ZEILE
     Case "SET_SAVE"
       save_settings   = True
       use_settings    = True
       exit_settings   = True
     Case "SET_USEEXIT"
       use_settings    = True
       exit_settings   = True
     Case "SET_USE"
       use_settings    = True
       exit_settings   = True
       reopen_settings = True
     Case "SET_CANCEL"
       use_settings    = False
       reopen_settings = False
       exit_settings   = True
     End Select

   End Select
   CNIF #use_NTUI
     ntui_Handle{}
   CEND
 Until exit_settings = True

 If use_settings = True

   WZ_LockWindow{"WIN_SETTINGS"}
   Poke.b ?auto_format,           WZInput("SET_AUTO_FORMAT")
   Poke.b ?auto_constructs,       WZInput("SET_COMPLETE_CONSTRUCTS")
   Poke.b ?use_intellisense,      WZInput("SET_INTELLISENSE")
   Poke.b ?correct_functions,     WZInput("SET_CORRECT_FUNCTIONS")
   Poke.w ?smart_tokenization,    Abs(WZInput("SET_SMART_TOKENIZATION"))
   Poke.b ?new_editmode,          WZInput("SET_STANDARD_EDITMODE")
   Poke.b ?no_welcome,            WZInput("SET_WELCOME")
   Poke.b ?onlinehelp,            WZInput("SET_ONLINEHELP")
   Poke.w ?bold_tokens,           WZInput("SET_BOLDTOKENS")
   Poke.w ?italic_remarks,        WZInput("SET_ITALICREMARKS")
   Poke.w ?use_wbcolors,          Off
   Poke.w ?remember_saved,        WZInput("SET_REMEMBER_SAVED")
   Poke.b ?load_last_source,      WZInput("SET_LAST_SOURCE")
   Poke.w ?use_asldims,           WZInput("SET_asl_DIMENSIONS")
   Poke.w ?use_pubscreen,         WZInput("SET_PUBSCREEN")
   Poke.w ?use_default_pubscreen, WZInput("SET_DEFAULTPUBSCREEN")
   Poke.w ?use_filepattern,       WZInput("SET_FILEPATTERN")
   Poke.b ?use_wbscreen,          WZInput("SET_USEWB")
   Poke.b ?clone_wbscreen,        WZInput("SET_CLONEWB")
   use_wbfont =                   -WZInput("SET_USEWBFONT")
   Poke.w ?auto_indent,           WZInput("SET_AUTO_INDENT")
   Poke.w ?oldsearch,             WZInput("SET_OLDSEARCH")
   Poke.b ?nodisplaybeep,         WZInput("SET_NO_DISPLAYBEEP")

   console_device$  = WZGetString("SET_CONSOLE_DEVICE")
   console_wb       = -WZInput("SET_CONSOLE_ON_WB")
   console_wait     = -WZInput("SET_CONSOLE_WAIT")
   ;console_keepopen = WZInput("SET_CONSOLE_KEEPOPEN")

   sort_labels = -WZInput("SET_SORTLABELS")
   scroll_rate = WZInput("SET_SCROLLRATE")
   If scroll_rate = 0 Then Poke.b ?old_scrolling,1 ;Else vvset_blank{scroll_rate}
   Poke.w ?tab_size      ,WZInput("SET_TAB_SIZE")
   Poke.b ?blinkrate     ,WZInput("SET_CURSORBLINKRATE")

   Poke.l ?aslreq_x      ,WZInput("SET_ASLX")
   Poke.l ?aslreq_y      ,WZInput("SET_ASLY")
   Poke.l ?aslreq_width  ,WZInput("SET_ASLW")
   Poke.l ?aslreq_height ,WZInput("SET_ASLH")
   If Peek.w(?use_asldims) = True
     asl_SetRequesterDims{Peek.l(?aslreq_x),Peek.l(?aslreq_y),Peek.l(?aslreq_width),Peek.l(?aslreq_height)}
   Else
     asl_SetRequesterDims{-1,-1,-1,-1}
   EndIf

   ; store directories
   sourcedir$=  tsourcedir$
   deflibfile$= tdeflibfile$
   includedir$= tincludedir$
   autodocdir$= tautodocdir$
   helpdir$=    thelpdir$
   Poke.l ?ptr_source_dir      ,&sourcedir$
   Poke$ ?comStr_CurrentDir    ,sourcedir$
   Poke.l ?ptr_incdirname      ,&includedir$
   Poke.l ?ptr_deflibsfilename ,&deflibfile$

   If temp_id<>Peek.l(?ownscreen_modeid)
     Poke.l ?ownscreen_modeid ,temp_id
     Poke.w ?ownscreen_height ,temp_height
     Poke.w ?ownscreen_width  ,temp_width
     Poke.w ?ownscreen_depth  ,temp_depth
   EndIf

   If ( (newguifont$<>guifont$) OR (newguifontsize<>guifontsize) ) AND ( (NOT use_wbfont) AND (Peek.b(?use_wbscreen)=0) )
     guifont$       = newguifont$
     guifontsize    = newguifontsize
     guifontstyle.l = newguifontstyle.l
     rebuild_gui    = True
   Else
    If ( (use_wbfont AND (NOT olduse_wbfont) ) AND olduse_wbscreen=0 ) OR ( ( (Peek.b(?use_wbscreen)<>0) AND (olduse_wbscreen=0) ) AND (NOT olduse_wbfont) )
      Gosub SetGuiFontToWBScreenFont
      rebuild_gui = True
    EndIf
   EndIf

   ; update colors
   If update_colors = True
     For i = 0 To 24
       AB3RGB(i) = AB3RGB_temp(i)
     Next i
     If rebuild_gui = False          ; update screencolors only if GUI not rebuild else we trash maybe the Wbscreencolors
       Gosub set_storedcolors
       update_colors.b = False
     EndIf
   EndIf

   If ( (newsourcefont$<>Peek.s(?str_sourcefontname)) OR (newsourcefontsize<>Peek.w(?sourcefontsize)) ) AND (NOT use_wbfont)
     sourcefont$      = newsourcefont$
     sourcefont_size  = newsourcefontsize
     sourcefont_style = newsourcefontstyle.l
     ;Gosub check_font               ; this is disabled because we dont mind if the font doesnt exist => will use system default
     Poke.s ?str_sourcefontname,sourcefont$  ; + StrClone(Chr$(0), 16 - Len(newsourcefont$) )
     Poke.w ?sourcefontsize    ,sourcefont_size
     Poke.b ?sourcefontstyle   ,sourcefont_style
     If rebuild_gui =False              ; check if we only need to update the source window  tomsmart1
       !asm
       JSR close_sourcewindow
       JSR change_sourcefont
       JSR open_sourcewindow
       !basic
     EndIf
   Else
     If use_wbfont AND (NOT olduse_wbfont)
       ;get WBfont for Sourcefont
       sourcefont$=""     ;that change_sourcefont get the WBfont
       Poke.s ?str_sourcefontname,sourcefont$
       If rebuild_gui =False            ; check if we only need to update the source window  tomsmart1
         !asm
         JSR close_sourcewindow
         JSR change_sourcefont
         JSR open_sourcewindow
         !basic
       EndIf
     EndIf
   EndIf

   !asm
   JSR _redraw
   !basic
   WZ_UnlockWindow{"WIN_SETTINGS"}
 EndIf

 If reopen_settings Then Goto settings_loop

 If save_settings
   WZ_LockWindow{"WIN_SETTINGS"}
   Gosub write_newprefs
   ;MOVE.w #$FFFF,prefswritten_state
   Gosub set_tooltypes
   WZ_UnlockWindow{"WIN_SETTINGS"}
 EndIf

 If cw_open Then WZ_KillColorWheel{} : cw_open = False
 WZCloseWindow WZID("WIN_SETTINGS")
 Use Window used_win
 If rebuild_gui
   !asm
   JSR close_gui
   JSR change_sourcefont
   JSR open_gui
   !basic
 EndIf
 If rebuild_menu
   Gosub init_menus
 EndIf

 JSR activatesource
 !asm
RTS

.update_colorboxes
   If WZInput("SET_PAGES") = 2
     *win.Window = Peek.l(Addr Window(WZID("WIN_SETTINGS")))
     DrPort *win\RPort
     For ii.l = 1 To 12
       If ii = colnum Then boxpen.w = 2 Else boxpen = 1
       *gad.Gadget = WZGadAddr("SET_COLOR"+Str$(ii))
       If *gad
         boxx.l = *gad\LeftEdge + *gad\Width + 16
         boxw.l = boxx + 24
         boxy.l = *gad\TopEdge
         boxh.l = boxy + *gad\Height
         DrBoxf boxx+1,boxy+1,boxw-1,boxh-1,GetBestPen{AB3RGB_temp(ii)}
         DrBox  boxx,boxy,boxw,boxh,boxpen
       EndIf
     Next ii
     For ii = 0 To 3
       If 20+ii = colnum Then boxpen.w = 2 Else boxpen = 1
       *gad.Gadget = WZGadAddr("SET_SCREENCOL"+Str$(ii))
       If *gad
         boxx = *gad\LeftEdge + *gad\Width + 16
         boxw = boxx + 24
         boxy = *gad\TopEdge
         boxh = boxy + *gad\Height
         DrBoxf boxx+1,boxy+1,boxw-1,boxh-1,GetBestPen{AB3RGB_temp(20+ii)}
         DrBox  boxx,boxy,boxw,boxh,boxpen
       EndIf
     Next ii
   EndIf
Return

.update_colorwheel:
  If WZInput("SET_PAGES") = 2
    If cw_open
      WZ_KillColorWheel{}
      RefreshWindowFrame_ Peek.l(Addr Window(WZID("WIN_SETTINGS")))
      cw_open = False
    EndIf

;    Repeat
;      ev2.l = WaitEvent
;    Until ev2 = #IDCMP_MOUSEBUTTONS

    cw_open = WZ_DrawColorWheel{*cw_gad\LeftEdge,*cw_gad\TopEdge,*cw_gad\Width,*cw_gad\Height}
    If cw_open
      If colnum <> -1
        WZ_SetColorWheelRGB{AB3RGB_temp(colnum)}
      Else
        WZ_SetColorWheelRGB{$FFFFFF}
      EndIf
    Else
      dummy.l= RTEZRequest( "",!TRANS{"error creating colorwheel"},!TRANS{"Ok"})
    EndIf
  Else
    If cw_open
      WZ_KillColorWheel{}
      cw_open = False
    EndIf
  EndIf
Return


.set_tooltypes
   If disk_object
       mypath$ = dos_GetProgDir{""}
       ; -- save colors
       dos_SetToolString{"FUNCTIONCOLOR"   ,"$"+Hex$(AB3RGB(#AB3_cfunction))}
       dos_SetToolString{"MACROCOLOR"      ,"$"+Hex$(AB3RGB(#AB3_cmacro))}
       dos_SetToolString{"STRINGCOLOR"     ,"$"+Hex$(AB3RGB(#AB3_cstring))}
       dos_SetToolString{"NEWTYPECOLOR"    ,"$"+Hex$(AB3RGB(#AB3_cnewtype))}
       dos_SetToolString{"CONSTANTCOLOR"   ,"$"+Hex$(AB3RGB(#AB3_cconstant))}
       dos_SetToolString{"REMARKFORG"      ,"$"+Hex$(AB3RGB(#AB3_cremarkforeground))}
       dos_SetToolString{"REMARKBACKG"     ,"$"+Hex$(AB3RGB(#AB3_cremarkbackground))}
       dos_SetToolString{"TOKENCOLOR"      ,"$"+Hex$(AB3RGB(#AB3_ctoken))}
       dos_SetToolString{"TOKENBACKPEN"    ,"$"+Hex$(AB3RGB(#AB3_ctokenbackground))}
       dos_SetToolString{"BACKGROUNDCOLOR" ,"$"+Hex$(AB3RGB(#AB3_cbackground))}
       dos_SetToolString{"OTHERCOLOR"      ,"$"+Hex$(AB3RGB(#AB3_cother))}
       dos_SetToolString{"CLASSICCOLOR"    ,"$"+Hex$(AB3RGB(#AB3_cclassic))}
       dos_SetToolString{"screenbackcolor" ,"$"+Hex$(AB3RGB(#AB3_screenback))}
       dos_SetToolString{"screentextcolor" ,"$"+Hex$(AB3RGB(#AB3_screentext))}
       dos_SetToolString{"screenshinecolor","$"+Hex$(AB3RGB(#AB3_screenshine))}
       dos_SetToolString{"screenfillcolor" ,"$"+Hex$(AB3RGB(#AB3_screenfill))}

       ; save Screen settings
       dos_SetToolSwitch{"USE_WBSCREEN"    ,-WZInput("SET_USEWB")}
       dos_SetToolSwitch{"CLONE_WBSCREEN"  ,-WZInput("SET_CLONEWB")}
       dos_SetToolSwitch{"DEFAULTPUBSCREEN",-WZInput("SET_DEFAULTPUBSCREEN")}
       ;save ownscreen parameters
       dos_SetToolValue{"SCREEN_ID"        ,Peek.l(?ownscreen_modeid)}
       dos_SetToolValue{"SCREEN_WIDTH"     ,Peek.w(?ownscreen_width)}
       dos_SetToolValue{"SCREEN_HEIGHT"    ,Peek.w(?ownscreen_height)}
       dos_SetToolValue{"SCREEN_DEPTH"     ,Peek.w(?ownscreen_depth)}

       ; save Font settings
       dos_SetToolSwitch{"USE_WBFONT"      ,-WZInput("SET_USEWBFONT")}
       If WZInput("SET_USEWBFONT") = False     ;
         If newsourcefont$ <>""
           dos_SetToolSwitch{"SOURCEFONT"  ,True}       ; actived tooltype maybe it was deactived
           dos_SetToolString{"SOURCEFONT"  ,newsourcefont$+","+Str$(newsourcefontsize)}
         Else
           dos_SetToolSwitch{"SOURCEFONT"  ,False}      ; deactived Sourcefont Tooltypes no font is set
         EndIf
         If newguifont$ <>"" AND WZInput("SET_USEWB")=False   ;
           dos_SetToolSwitch{"GUIFONT"     ,True}       ; actived tooltype maybe it was deactived
           dos_SetToolString{"GUIFONT"     ,newguifont$+","+Str$(newguifontsize)}
         Else
           dos_SetToolSwitch{"GUIFONT"     ,False}      ; deactived GUIfont Tooltypes no font is set or we use the WBscreen
         EndIf
       Else
         dos_SetToolSwitch{"GUIFONT"       ,False}      ; deactived GUIfont Tooltypes we use WBfonts
         dos_SetToolSwitch{"SOURCEFONT"    ,False}      ; deactived Sourcefont Tooltypes we use WBfonts
       EndIf

       ; save other settings
       dos_SetToolSwitch{"NO_WELCOME"        ,-WZInput("SET_WELCOME")}
       dos_SetToolSwitch{"STANDARDEDITMODE"  ,-WZInput("SET_STANDARD_EDITMODE")}
       dos_SetToolSwitch{"OLDSEARCH"         ,-WZInput("SET_OLDSEARCH")}
       dos_SetToolSwitch{"NODISPLAYBEEP"     ,-WZInput("SET_NO_DISPLAYBEEP")}
       dos_SetToolSwitch{"AUTO_FORMAT"       ,-WZInput("SET_AUTO_FORMAT")}
       dos_SetToolSwitch{"AUTO_CONSTRUCTS"   ,-WZInput("SET_COMPLETE_CONSTRUCTS")}
       dos_SetToolSwitch{"USE_INTELLISENSE"  ,-WZInput("SET_INTELLISENSE")}
       dos_SetToolSwitch{"CORRECT_FUNCTIONS" ,-WZInput("SET_CORRECT_FUNCTIONS")}
       dos_SetToolSwitch{"SMART_TOKENIZATION",-WZInput("SET_SMART_TOKENIZATION")}
       dos_SetToolSwitch{"TOKENBOLD"         ,-Peek.w(?bold_tokens)}
       dos_SetToolSwitch{"ITALIC_REMARKS"    ,-Peek.w(?italic_remarks)}
       dos_SetToolSwitch{"ONLINEHELP"        ,-WZInput("SET_ONLINEHELP")}

       dos_SetToolSwitch{"SOURCE_HISTORY"    ,-WZInput("SET_REMEMBER_SAVED")}
       dos_SetToolSwitch{"LOAD_LAST_SOURCE"  ,-WZInput("SET_LAST_SOURCE")}
       dos_SetToolSwitch{"SORT_LABELS"       ,sort_labels}
       dos_SetToolValue{"SCROLLRATE"         ,scroll_rate}

       ; save console settings
       dos_SetToolString{"CON_DEVICE" ,console_device$}
       dos_SetToolSwitch{"CON_ONWB"   ,console_wb}
       dos_SetToolSwitch{"CON_WAIT"   ,console_wait}

       ; save ASL parameters
       dos_SetToolSwitch{"USE_ASLDIMS",-WZInput("SET_asl_DIMENSIONS")}
       dos_SetToolValue{"ASLREQ_X"    ,Peek.l(?aslreq_x)}
       dos_SetToolValue{"ASLREQ_Y"    ,Peek.l(?aslreq_y)}
       dos_SetToolValue{"ASLREQ_W"    ,Peek.l(?aslreq_width)}
       dos_SetToolValue{"ASLREQ_H"    ,Peek.l(?aslreq_height)}

       If Peek.b(?blinkrate)>0 Then dos_SetToolValue{"CURSORBLINKRATE",Peek.b(?blinkrate)}

       ; save pathes
       dos_SetToolString{"HELPDIR"    ,helpdir$}
       dos_SetToolString{"AUTODOCDIR" ,autodocdir$}
       dos_SetToolString{"SOURCEDIR"  ,sourcedir$}
       dos_SetToolString{"LIBFILE"    ,deflibfile$}
       dos_SetToolString{"INCLUDEDIR" ,includedir$}

       ;update AND write Icon
       dos_FlushToolTypes{}
;   Else
;     !cout{"no icon available !"}
   EndIf
Return

.menu_iconify:
;!basic
;  !cout{"WBase: ",Peek.l(_workbenchbase)}
;!asm
;  If Peek.l(?_workbenchbase)
;    JSR close_gui
;    AddAppMenuItemA_ 0,0,?str_defaultpubscreen,?struct_MsgPort
;  EndIf
  !basic
  CNIF #use_NTUI
    ntui_Iconify{*tuiPED}
  CEND
  !asm
  TST.l _workbenchbase
  BEQ.w JL_0_B26
   JSR close_gui
    MOVEA.l _workbenchbase,A6
    MOVEQ.l #$00,D0
    MOVEQ.l #$00,D1
    LEA str_defaultpubscreen,A0
    MOVEA.l struct_MsgPort,A1
    SUBA.l A2,A2
    JSR _AddAppMenuItemA(A6)
    MOVE.l D0,ptr_AppMenuItem

    ; wait until AppMenuItem was called
    MOVEA.l _execbase,A6
    MOVEA.l struct_MsgPort,A0
    JSR _WaitPort(A6)

    MOVEA.l struct_MsgPort,A0
    JSR _GetMsg(A6)

    MOVEA.l D0,A1
    JSR _ReplyMsg(A6)

    MOVEA.l _workbenchbase,A6
    MOVEA.l ptr_AppMenuItem,A0
    JSR _RemoveAppMenuItem(A6)       ; hier gibt es noch einen Enforcerhit

    MOVEA.l comPtr_CurrentSourceLine,A2
    JSR open_gui
    BMI.w close_libraries_longjmp
  JL_0_B26:
RTS

close_libraries_longjmp:
JMP close_libraries

.get_currentdir:
  MOVE.l #comStr_CurrentDir,D1
  MOVEQ.l #$40,D2
  MOVEA.l _dosbase,A6
  JSR _GetCurrentDirName(A6)
RTS



.taglist_mousepointerbusy:
  Dc.b $80,$00,$00,$98               ; #WA_BusyPointer.
  Dc.b $FF,$FF,$FF,$FF
  Ds.l 1

.taglist_mousepointernormal:
  Dc.b $80,$00,$00,$97               ; #WA_Pointer
  Ds.l 2

.set_pointernormal:
  MOVEM.l D0-D1/A0-A1/A6,-(A7)

  LEA taglist_mousepointernormal,A1
  TST.l ptr_sourcewindow
   BEQ exit_pointernormal

  MOVEA.l ptr_sourcewindow,A0
  MOVEA.l _intuibase,A6
  JSR _SetWindowPointerA(A6)

  exit_pointernormal
  MOVEM.l (A7)+,D0-D1/A0-A1/A6
RTS

.set_pointerbusy:
  MOVEM.l D0-D1/A0-A1/A6,-(A7)

  LEA taglist_mousepointerbusy,A1
  TST.l ptr_sourcewindow
   BEQ exit_pointerbusy

  MOVEA.l ptr_sourcewindow,A0
  MOVEA.l _intuibase,A6
  JSR _SetWindowPointerA(A6)

  exit_pointerbusy:
  MOVEM.l (A7)+,D0-D1/A0-A1/A6
RTS


ptr_sourcefilename:      Ds.l 1
ptr_sourcefileextension: Ds.l 1
str_extentionxtra:       Dc.b ".xtra",0
str_extentioninfo:       Dc.b ".info",0
str_bakextention:        Dc.b ".bak",0,0


.open_infofile:
  LEA str_extentioninfo,A1
  JSR add_extention
  MOVEQ.l #-$02,D2
  MOVEA.l _dosbase,A6
  JSR _Lock(A6)
  MOVE.l D0,D1
  BEQ.w JL_0_DEA
  JSR _UnLock(A6)
  BRA.w JL_0_DFC

  JL_0_DEA:
  MOVE.l ptr_sourcefilename,D1
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  JSR _Open(A6)
  MOVE.l D0,D7
  RTS

  JL_0_DFC:
  MOVEQ.l #$00,D7
RTS


.open_xtrafile:
  LEA str_extentionxtra,A1
  JSR add_extention
   MOVEA.l _dosbase,A6
  JSR _Open(A6)
  MOVE.l D0,D7
RTS

.add_extention:
  MOVEA.l ptr_sourcefilename,A0
  MOVE.l A0,D1

  JL_0_E16:
    TST.b (A0)+
  BNE.b JL_0_E16

  SUBQ.w #1,A0
  MOVE.l A0,ptr_sourcefileextension

  JL_0_E22:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_E22
RTS

JL_0_E28:
  MOVEA.l ptr_sourcefileextension,A0
  CLR.b (A0)
RTS




.menu_load:
  MOVEA.l #str_newfile_req,A0
  MOVE.l #$4C6F6164,(A0)+           ; "Load File"
  MOVE.l #$2046696C,(A0)+
  MOVE.b #"e",(A0)+
  MOVE.b #$0,(A0)+
  JSR show_newfilerequest
  MOVEA.l #str_newfile_req,A0
  MOVE.l #$4E657720,(A0)+            ; "New File"
  MOVE.l #$46696C65,(A0)+
  MOVE.b #$0,(A0)+

  TST.l D0
  BNE.w JL_0_E78
  RTS

  JL_0_E78:
  JSR do_aslfilerequest
  TST.l D0
  BNE.w load_source
RTS

;.change_directory:
;  MOVE.l #$FFFFFFFF,asl_drawersonly
;  MOVEA.w #-$1,A3
;  LEA str_aslchangedir,A2
;  LEA comStr_CurrentDir,A0
;  JSR aslrequest_file
;  TST.l D0
;  BNE.w set_currentdir
;RTS


;AL_0_BC8:               Ds.l 1
lock_defaultdirectory:  Ds.l 1
lock_currentdir:        Ds.l 1


.set_currentdir:                     ;set default dir
  MOVE.l d2,-(a7)
  MOVEA.l _dosbase,A6
  MOVEA.l D0,A0
  TST.b (A0)
  BNE.w JL_0_EC2

  MOVEM.l D0-D3/A0-A1,-(A7)
  JSR get_currentdir                 ;get current dir name
  LEA blitzname,a0
  MOVE.l a0,d0
  MOVEM.l (A7)+,D0-D3/A0-A1

 JL_0_EC2:
  TST.l lock_currentdir
  BEQ.w JL_0_EDA
  MOVE.l D0,-(A7)
  MOVE.l lock_currentdir,D1
  MOVEA.l _dosbase,A6
  JSR _UnLock(A6)
  MOVE.l (A7)+,D0

 JL_0_EDA:
  MOVE.l D0,D1
  MOVEQ.l #-$02,D2
   MOVEA.l _dosbase,A6
  JSR _Lock(A6)
  MOVE.l D0,lock_currentdir
  MOVE.l D0,D1
  BEQ.w JL_0_EF2
   MOVEA.l _dosbase,A6
  JSR _CurrentDir(A6)

 JL_0_EF2:
  MOVE.l (a7)+,d2
RTS


split_filename:
  ;comStr_SourceFileComplete,A0
  ;comStr_CurrentDir,A1
  ;comStr_SourceName,A2
  MOVE.l A0,-(A7)

 JL_0_EFA:
    TST.b (A0)+
  BNE.b JL_0_EFA

 JL_0_EFE:
    MOVE.b -(A0),D0
    CMP.b #":",D0
    BEQ.w JL_0_F16
  CMP.b #$2F,D0
  BNE.b JL_0_EFE

  MOVEA.l A0,A3                      ; "/" gefunden
  ADDQ.l #1,A0
  BRA.w JL_0_F1A

 JL_0_F16:                           ; ":" hinten gefunden
  ADDQ.l #1,A0
  MOVEA.l A0,A3

 JL_0_F1A:                           ; nur den filename kopieren
    MOVE.b (A0)+,(A2)+
  BNE.b JL_0_F1A

  MOVEA.l (A7)+,A0

 JL_0_F20:
    MOVE.b (A0)+,(A1)+               ; nur den pfad kopieren
    CMPA.l A0,A3
  BNE.b JL_0_F20
  CLR.b (A1)
RTS



.load_source:  ;D7: sourcefilename
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
  MOVE.b #1,menuload
  MOVE.l D7,ptr_sourcefilename

  !basic
  filenameP.l = Peek.l(?ptr_sourcefilename)
  If filenameP
    filename.s = Peek.s(filenameP)
    ex.s = dos_GetExt{filename}
  Else
    ex.s = "???"
  End If

  MOVE.l #0,loading_done
  If ex.s = "ab3"
    !asm
    MOVE.l ptr_sourcefilename,D0
    !ComData_JSR{comFunc_LoadSource}
    !basic
    ;restore windows
    Gosub RestoreLabelAndNewtypeWin
    changelog$ = ""
    Gosub update_versiongadgets
    !asm
    ;Update Sourcewindow
    MOVE.l comLong_CursorPosStore,d0
    MOVEA.l comPtr_CurrentSourceLine,A4
    JSR gotoline
                                                                                                                                                                                                                                                      
    MOVEA.l actualfile,A0
    JSR delete_tempprefs
    JSR save_tempprefs
    ;JSR JL_0_E28 ; chop source file extension
    JSR update_horizscroller
    JSR update_labelstuff
    JSR StoreXtraData
    JSR _redraw
    JSR set_pointernormal
    JSR analyze_loadedsource
    JSR update_statusline
    CLR.b convert
    MOVE.l #1,loading_done
    !basic
  EndIf

  !asm
  TST.l loading_done
  BEQ old_loading_routine
RTS


cancel_loading_routine:
JMP clear_sourcebuffer;JL_0_6B7C

loading_done: Dc.l 0


old_loading_routine:
  JSR open_sourcefile
  CLR.w comWord_SourceChanged
  JSR source_readin
  BNE.w JL_0_F50
  JSR close_sourcefile

 JL_0_F50:
  MOVEM.l D0-D7/A0-A5,-(A7)
  MOVE.l D7,D1  ; filehandle nach D1
  MOVE.l #comStr_SourceFileComplete,D2
  MOVE.l #$FE,D3; bufflength nach D3
   MOVEA.l _dosbase,A6
  JSR _NameFromFH(A6)
  LEA comStr_SourceFileComplete,A0
  TST.b convert
  BEQ 'l1
  LEA comStr_SourceFileComplete,A0

 'l10
  TST.b (a0)+
  BNE 'l10
  LEA -5(a0),a0
  MOVE.l #".bb2",(a0)

 'l1
  LEA comStr_SourceFileComplete,A0
  LEA comStr_CurrentDir,A1
  LEA comStr_SourceName,A2
  BSR.b split_filename

  MOVE.l #comStr_CurrentDir,D0
  JSR set_currentdir
  MOVEM.l (A7)+,D0-D7/A0-A5
  JSR set_pointerbusy
  JSR JL_0_572C
  JSR clear_actualsource

  MOVE.l #$0001,comLong_TotalLines
  MOVE.l comPtr_Temp_TokenString2,tempstore
  JSR JL_0_4F5A
  JSR JL_0_4F1A
  MOVE.l A0,comPtr_FirstSourceLine
  MOVE.l A0,comPtr_CurrentSourceLine
  CLR.l $4(A0)
  MOVE.l A0,comPtr_LastSourceLine

  JL_0_FB4:
    MOVEA.l A0,A4
    MOVE.l comPtr_Temp_TokenString2,tempstore
    JSR JL_0_4F5A
    BMI.w JL_0_FD6
    JSR JL_0_4F1A
    MOVE.l A0,comPtr_LastSourceLine
    MOVE.l A0,(A4)
    ADDQ.l #1,comLong_TotalLines
    MOVE.l A4,$4(A0)
BRA.b JL_0_FB4

 JL_0_FD6:
  ;JSR JL_0_4E4A
  JSR close_sourcefile
;  CLR.l comLong__AL_0_868A
  CLR.w comWord_TextBufferOffset
  CLR.w comWord_Column        ; was .l
  CLR.w comWord_ColumnsOffset ; was .l
  CLR.l comLong_DisplayLineOffset
  CLR.l comLong_DisplayLine

  MOVE.l comFunc_ReadXtraFile,D0
  BEQ.w JL_0_100C
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2 ; read xtra
  JSR open_xtrafile                      ; returns D7: filehandle
  BEQ.w skip_loadingxtrafile

  MOVE.l comFunc_ReadXtraFile,D0
  MOVEA.l D0,A5

 L_0_FF2:
  JSR (A5)

  MOVE.l d7,d0
  !basic
  xtrafilehandle.l = PutD0
  JSR check_state_of_debuggertoggle
  Read_ xtrafilehandle,?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin ; xtrabuf,36

;  stackSize.l = Peek.l(?comLong_StackSizeStore)
;  If stackSize<4096 Then stackSize=4096
;  Poke.l ?stacksize,stackSize

  ; -- get the data for creating executables
  exefilename$ = ""
  exepathname$ = ""
  tempexename$ = SPACE$(96)

  Seek_ xtrafilehandle,$256,#OFFSET_BEGINNING
  Read_ xtrafilehandle,&tempexename$,96
  i = 1
  Repeat
    char$ = Mid$(tempexename$,i,1)
    If Asc(char$)<>0 Then exepathname$ + char$
    i + 1
  Until (i = FLen(tempexename$)) OR (Asc(char$) = 0)

  tempexename$ = SPACE$(96)
  Seek_ xtrafilehandle,$316,#OFFSET_BEGINNING
  Read_ xtrafilehandle,&tempexename$,96
  i = 1
  Repeat
    char$ = Mid$(tempexename$,i,1)
    If Asc(char$)<>0 Then exefilename$ + char$
    i + 1
  Until (i = FLen(tempexename$)) OR (Asc(char$) = 0)
;  exepathname$ = dos_Trim{exepathname$}
;  exefilename$ = dos_Trim{exefilename$}
;  !cout{exepathname$+"/"+exefilename$} ;$ , dos_GetFileSize2{exepathname$+"/"+exefilename$}}


  ; restore windows
  Gosub RestoreLabelAndNewtypeWin
  changelog$ = ""
  Gosub update_versiongadgets

  !asm
  MOVE.l D7,D1
   MOVEA.l _dosbase,A6
  JSR _Close(A6)

  ; update Sourcewindow
  MOVE.l comLong_CursorPosStore,d0
  MOVEA.l comPtr_CurrentSourceLine,A4
  JSR gotoline

  MOVEA.l actualfile,A0
  JSR delete_tempprefs
  JSR save_tempprefs

 skip_loadingxtrafile:
  JSR JL_0_E28

 JL_0_100C:
  JSR update_horizscroller
  JSR update_labelstuff
  JSR StoreXtraData
  JSR _redraw
  JSR set_pointernormal
  JSR analyze_loadedsource
  JSR update_statusline
  CLR.b convert
  MOVEQ.l #-$01,D0
RTS


;subroutine to restore Source_Browser(Label) and Definition_Browser(Newtype) window status after load and switch of Sourecode  tomsmart1
.RestoreLabelAndNewtypeWin
  search_label$ = Peek$(?comStr_LabelSearchString) ; set the searchlabel_string
  old_search_label$ = search_label$                ; set also old searchlabel_string to prevent a unessacary reset and jump of the labellist tomsmart1
  MOVE.l comLong_Label1VisableItemStore,comLong_Label1VisableItem          ;  move stored entry to tempbuffer manly for case of load a source  tomsmart1
  LabelList_FirstVisableItemNumber.l = Peek.l(?comLong_Label1VisableItem)  ;  set/restore the first visable entry of the labellist  tomsmart1
  LabelList_PreSelectItemNumber.l    = 0 ; set the preselected labellist entry to 0 because we done save/store it.  tomsmart1

  If WZ_CheckOpen{"WIN_LABELS"}
    Use Window WZID("WIN_LABELS")
    WZPrint "STRING_LABEL",search_label$
    WZPrint "rem"         ,Peek.w(?comWord_LabelRemark)
    WZPrint "all"         ,Peek.w(?comWord_LabelAll)
    WZListRemove lib_list.List
    WZPrint "LIBRARY_LIST",0,lib_list
  EndIf
  If WZ_CheckOpen{"WIN_NEWTYPE"}
    Use Window WZID("WIN_NEWTYPE")
    Gosub newtype_updatelist
  End If
Return


;set filenmae as screentitle
.analyze_loadedsource:
  LEA comStr_SourceName,A0
  ; --
  ; -- erzeugen des Fenstertitels
  MOVEA.l str_windowtitle,A1
  MOVE.l #$46696C65,(A1)+            ; "File - "
  MOVE.w #$202D,(A1)+
  MOVE.b #$20,(A1)+

  ; -- ist Dateiname angegeben ?
  TST.b (A0)
   BNE.w JL_0_1074
  ; -- nein
  MOVE.l #$556E6E61,(A1)+            ; "unnamed "
  MOVE.l #$6D656420,(A1)+
  CLR.b -$1(A1)
  TST.w smart_tokenization
   BEQ 'l1
  MOVE.w #$ffff,comWord_DoTokenize
 'l1
  BRA.w update_title_sourcewindow

  ; -- ja
  JL_0_1074:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_1074

  ; -- in A0 steht jetzt das Ende des Filenamens, wir checken die Dateiendung
  ; -- um zu schauen, ob tokeniziert werden soll
  JSR check_fileextension_for_tokenization

  MOVE.l #"  Di",-1(a1)
  ADDQ.l #3,a1
  MOVE.l #"r - ",(a1)+
  ;LEA comStr_SourceName,A0
  ;LEA -$c0(a0),a0
  LEA comStr_CurrentDir,A0
 'l2
    MOVE.b (A0)+,(A1)+
  BNE.b 'l2

  update_title_sourcewindow:
  MOVEA.l ptr_sourcewindow,A0
  MOVEA.l str_windowtitle,A1
  MOVE.l #-1,a2
  MOVEA.l _intuibase,A6
  JSR _SetWindowTitles(a6)

  !basic
  ;error{"New source:" + Peek$(?comStr_SourceFileComplete) + " = "+Peek$(?comStr_CurrentDir)+"::"+Peek$(?comStr_SourceName) }
  If Peek.b(?load_last_source)<>0
    last_source$ = Peek$(?comStr_SourceFileComplete)
    If last_source$<>""
      If Instr(last_source$,Peek$(?comStr_SourceName))<>0
        dos_SetToolString{"LAST_SOURCE",last_source$}
      EndIf
    EndIf
  EndIf
  !asm
RTS

.check_fileextension_for_tokenization
  TST.w smart_tokenization
   BEQ 'rt
  CMP.l #".bb2",-5(a1)
   BEQ 'do
  CMP.l #".ab2",-5(a1)
   BEQ 'do
  CMP.l #".ab3",-5(a1)
   BEQ 'do
  CMP.w #".b",-4(a1)
   BNE 'l1
  CMP.b #"b",-2(a1)
   BEQ 'do
  RTS

 'do
  MOVE.w #$ffff,comWord_DoTokenize
  MOVE.w #$ffff,flag_tokenization
  RTS

 'l1
  CMP.l #".txt",-5(a1)
  BEQ 'no
  CMP.l #".gui",-7(a1)
  BNE 'rt
  CMP.w #"de",-3(a1)
  BNE 'rt
  MOVE.b #1,amigaguide

 'no
  MOVE.w #0,comWord_DoTokenize
  MOVE.w #0,flag_tokenization
 'rt
RTS


.delete_tempprefs:
  MOVE.l comFunc_ReadXtraFile,D0
  BEQ.w exit_delete_tempprefs

  MOVE.l A0,D0
  LEA str_template_tempxtrafile,A0
  JSR generate_tempfilename
  MOVEA.l _dosbase,A6
  MOVE.l #str_temptedprefs,D1
  JSR _DeleteFile(A6)

  exit_delete_tempprefs:
RTS


.read_tempprefs:
  MOVE.l comFunc_ReadXtraFile,D0
  BEQ.w exit_read_tempprefs

  MOVE.l actualfile,D0
  LEA str_template_tempxtrafile,A0
  JSR generate_tempfilename
  MOVE.l comFunc_ReadXtraFile,D0
  MOVEA.l _dosbase,A6
  MOVEA.l D0,A5
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
  MOVE.l #str_temptedprefs,D1
  JSR _Open(A6)
  MOVE.l D0,D7
  ;BEQ.w exit_read_tempprefs
  MOVE.l D0,-(A7)
  L_0_10EA:
  JSR (A5)
  MOVE.l (A7)+,D1
   MOVEA.l _dosbase,A6
  JSR _Close(A6)

 exit_read_tempprefs:
RTS

.save_tempprefs:
  MOVE.l comFunc_WriteXtraFile,D0
  BEQ.w exit_save_tempprefs

  MOVE.l actualfile,D0
  LEA str_template_tempxtrafile,A0
  JSR generate_tempfilename
  MOVE.l comFunc_WriteXtraFile,D0
  MOVEA.l _dosbase,A6
  MOVEA.l D0,A5
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVE.l #str_temptedprefs,D1
  JSR _Open(A6)
  MOVE.l D0,D7
  BEQ.w exit_save_tempprefs
  MOVE.l D0,-(A7)
  L_0_112E:
  JSR (A5)
  MOVE.l (A7)+,D1
   MOVEA.l _dosbase,A6
  JSR _Close(A6)

 exit_save_tempprefs:
RTS


AL_0_15BC:    Ds.l 1
AL_0_15C0:    Ds.l 1
AL_0_1162:    Ds.w 1


.menu_saveas:
  ST AL_0_1162
  JSR StoreXtraData
  LEA comStr_ASLSaveFile,A2

  MOVEM.l D1-D6/A0-A6,-(A7)
  JSR JL_0_50D2
  MOVEM.l (A7)+,D1-D6/A0-A6

  TST.l D0
  BEQ.w JL_0_1158
    JSR menu_save
  JL_0_1158:

  SF AL_0_1162
  TST.l D0
RTS



JL_0_1164:
  LEA comStr_ASLSaveFile,A2
  MOVEM.l D1-D6/A0-A6,-(A7)
  JSR JL_0_50D2
  MOVEM.l (A7)+,D1-D6/A0-A6
RTS

.saverout
  MOVEM.l d0-d7/a0-a6,-(a7)
  BSR menu_save
  MOVEM.l (a7)+,d0-d7/a0-a6
RTS

.menu_save
;  TST.l _aslbase
;  BNE.w JL_0_1182
;    RTS
;  JL_0_1182:

  TST.b comStr_SourceName
  BNE.w JL_0_1196
  BSR.b JL_0_1164
  TST.l D0
  BNE.w JL_0_1196
RTS

 JL_0_1196:
  !basic
  BB2Filename$ = Peek$(?comStr_SourceFileComplete)
  directory.s = dos_FilePart{dos_PathPart{BB2Filename$}}
  If dos_Exist{BB2filename$} AND LCase$(directory) = "templates"
    If RTEZRequest("",!TRANS{"Do you really want to save this file into the templates drawer?"},!TRANS{"Ok|Cancel"})
      overwrite.l = True
    Else
      overwrite = False
    EndIf
  Else
    overwrite = True
  EndIf

  If NOT overwrite
    Pop If
    !asm
    RTS
  EndIf
  !asm

  MOVEM.l A0-A2,-(A7)
  MOVEA.l #comStr_CurrentDir,A1
  MOVEA.l #comStr_SourceName,A2
  MOVEA.l #comStr_SourceFileComplete,A0

  TST.b (A1)
  BEQ.w JL_0_11C6

  JL_0_11B2:
      MOVE.b (A1)+,(A0)+
    BNE.b JL_0_11B2

    SUBQ.w #1,A0
    CMPI.b #":",-$1(A0)
    BEQ.w JL_0_11C6
    MOVE.b #$2F,(A0)+

 JL_0_11C6:
  MOVE.l a0,namesizestore

 'l1a
  MOVE.b (A2)+,(A0)+
  BNE.b 'l1a
  CLR.b ab2mode
  CMP.l #$61623200,-4(a0)            ;ab2
  BNE 'os
  MOVE.b #1,ab2mode

 'os
  CMP.l #$61623300,-4(a0)            ;ab3
  BNE 'os3
  MOVE.b #3,ab2mode

 'os3
  SUB.l namesizestore,a0
  CMP.l #28,a0
  BLE 'l10
  !basic
  dummy.l= RTEZRequest("",!TRANS{"Warning: Filename is longer than 27 characters.\\nThis may cause problems with some filesystems."},!TRANS{"Continue"})
  !asm

 'l10
  MOVEM.l (A7)+,A0-A2
  MOVE.l #comStr_SourceFileComplete,D7
  JSR StoreXtraData
  TST.b AL_0_1162
  BEQ.w JL_0_1216
  MOVEA.l _dosbase,A6
  MOVE.l D7,D1
  MOVEQ.l #-$02,D2
  JSR _Lock(A6)
  TST.l D0
  BEQ.w JL_0_1216
  MOVE.l D0,-(A7)                    ; put lock from d0 to stack
  LEA easystruct_saveas,A1
  JSR show_requester
  MOVE.l (A7)+,D1                    ; get lock from stack to d1 for unlock
  TST.w D0
  BEQ.w JL_0_1214
  MOVEA.l _dosbase,A6
  JSR _UnLock(A6)
BRA.w JL_0_1216

 JL_0_1214:
RTS

 JL_0_1216:
  MOVE.l D7,ptr_sourcefilename
  MOVEA.l comPtr_DosBuffer,A1
  MOVE.l A1,D1
  MOVEA.l D7,A0

 JL_0_1224:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_1224

  SUBQ.w #1,A1
  LEA str_bakextention,A0

 JL_0_122E:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_122E

  MOVEA.l _dosbase,A6
  JSR _DeleteFile(A6)
  MOVE.l D7,D1
  MOVE.l comPtr_DosBuffer,D2
  JSR _Rename(A6)
  TST.b ab2mode
  BEQ old_saveroutine
  MOVE.l #comStr_SourceFileComplete,d0
  CMP.b #1,ab2mode
  BNE 'saveab3
  JSR saveab2

  JSR JL_0_1372
  TST.w remember_saved
  BEQ.w 'JL_0_1286b
  JSR AJL_0_B990

 'JL_0_1286b:
RTS

 'saveab3
  !basic
  ;error{"Save via new code!"}
  ;a.s = "Ram:Test.ab3"
  ;GetReg d0,&a.s
  !asm
  MOVE.l #comStr_SourceFileComplete,d0
  !ComData_JSR{comFunc_SaveSource}

  JSR set_pointernormal
  JSR analyze_loadedsource
  CLR.w comWord_SourceModifiedFlag
  CLR.w comWord_KeyBeforeReturn
  CLR.w comWord_SourceChanged
  JSR update_modifiermark

  TST.w remember_saved
  BEQ.w skip_historymenu
  JSR AJL_0_B990

 skip_historymenu:
RTS

 old_saveroutine:
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVE.b #1,menuload
  JSR open_sourcefile
  JSR set_pointerbusy
  MOVEA.l comPtr_FirstSourceLine,A2
  MOVE.l comLong_TotalLines,D5                 ;save routine
  ;SUBQ.l #1,D5
  TST.w AL_0_B7E0
  BEQ.w JL_0_1288
  MOVEM.l D1-D7/A0-A6,-(A7)
  JSR JL_0_12D6                      ;save write raw
  MOVEM.l (A7)+,D1-D7/A0-A6
  JSR JL_0_1372
  TST.w remember_saved
  BEQ.w JL_0_1286
  JSR AJL_0_B990

 JL_0_1286:
RTS

 JL_0_1288:
  JSR JL_0_1292
  JSR JL_0_1372
RTS

 JL_0_1292:
 JL_0_1298:
  MOVEQ.l #$00,D4
  MOVE.b $8(A2),D4
  LEA $9(A2),A3
  MOVE.w comWord_DoTokenize,D0
  BNE.w JL_0_12B2

  MOVE.b #$A,-$1(A3,D4.W)

 JL_0_12B2:
  MOVE.l D7,D1
  MOVE.l A3,D2
  MOVE.l D4,D3
  MOVEA.l _dosbase,A6
  JSR _Write(A6)
  CLR.b -$1(A3,D4.W)
  TST.l D0
  BEQ.w JL_0_1378
  MOVEA.l (A2),A2
  SUBQ.l #1,d5
  BNE JL_0_1298

   ;DBF D5,JL_0_1298
  CLR.w comWord_SourceChanged
  MOVEQ.l #-$01,D0
RTS

 JL_0_12D6:
  MOVEQ.l #$00,D0
  MOVEQ.l #$00,D1
  MOVE.l D5,D4

 JL_0_12Dca:
    MOVE.b $8(A2),D1
    ADD.l D1,D0
    MOVEA.l (A2),A2
    SUBQ.l #1,d5
  BNE JL_0_12Dca
   ;DBF D5,JL_0_12Dca
  MOVEA.l _execbase,A6
  MOVEQ.l #$00,D1
  MOVE.l D0,AL_0_15C0
  !newalloc
  MOVEA.l comPtr_FirstSourceLine,A2
  MOVEA.l D0,A5
  MOVE.l D4,D5
  MOVE.l D0,AL_0_15BC
  BNE.w JL_0_130C

BRA.b JL_0_1298

 JL_0_130C:
  MOVEA.l _dosbase,A6

  JL_0_1312:
    LEA $9(A2),A3
    MOVEQ.l #$00,D4
    MOVE.b $8(A2),D4
    SUBQ.w #1,D4

   JL_0_131E:
      MOVE.b (A3)+,(A5)+
    DBF D4,JL_0_131E

    TST.w comWord_DoTokenize
    BNE.w JL_0_1334

    MOVE.b #$A,-$1(A5)

 JL_0_1334:
    MOVEA.l (A2),A2
    SUBQ.l #1,d5
  BNE JL_0_1312
   ;DBF D5,JL_0_1312
  MOVE.l D7,D1
  MOVE.l AL_0_15BC,D2
  MOVE.l AL_0_15C0,D3
  MOVEA.l _dosbase,A6
  JSR _Write(A6)
  MOVE.l D0,-(A7)
  CLR.w comWord_SourceChanged
  MOVEA.l _execbase,A6
  MOVEA.l AL_0_15BC,A1
  !newfree
  MOVEA.l _dosbase,A6
  CLR.w comWord_SourceChanged
  MOVE.l (A7)+,D0
RTS

 JL_0_1372:
  TST.l D0
  BNE.w JL_0_1380

 JL_0_1378:
  LEA comStr_ErrorWriteFile,A0
  JSR show_errorrequester

 JL_0_1380:
;  JSR JL_0_4E4A
  JSR close_sourcefile
  MOVE.l comFunc_WriteXtraFile,D0
  BEQ.w JL_0_13A8
  MOVEA.l D0,A5
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  JSR open_xtrafile          ;write xtra
  BEQ.w skip_writingxtrafile

 L_0_139C:
  JSR (A5)

  !basic
  MOVE.l comLong_DisplayLineOffset,d0
  ADD.l comLong_DisplayLine,d0
  MOVE.l d0,comLong_CursorPosStore
  Poke$ ?comStr_LabelSearchString,search_label$
  MOVE.l LabelList_FirstVisableItemNumber@(a5),comLong_Label1VisableItemStore
  MOVE.l d7,d0
  xtrafilehandle.l = PutD0
  Write_ xtrafilehandle,?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin ; moved the write of the 4 extra fill/pad/termination bytes to the Compiler xtra save routine because the Compiler xtra load routine need it!  tomsmart1
  !asm
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  JSR _Close(A6)

 skip_writingxtrafile:
  JSR JL_0_E28

 JL_0_13A8:
  TST.w prefs_source_icon
   BEQ.w JL_0_13D6
  JSR open_infofile
  BEQ.w JL_0_13D2
  MOVE.l #sourceicon_datas,D2
  MOVE.l #SourceIconDatas_End-sourceicon_datas,D3
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  JSR _Write(A6)
  MOVE.l D7,D1
  JSR _Close(A6)

  JL_0_13D2:
  JSR JL_0_E28

  JL_0_13D6:
  JSR set_pointernormal
  JSR analyze_loadedsource
  CLR.w comWord_SourceModifiedFlag
  CLR.w comWord_KeyBeforeReturn
  CLR.w comWord_SourceChanged
  JSR update_modifiermark
RTS


.sourceicon_datas:
  Dc.b $E3,$10,$00,$01
  Dc.b $00,$00,$00,$00
  Dc.b $00,$63,$00,$11
  Dc.b $00,$2E,$00,$18
  Dc.b $00,$05,$00,$03
  Dc.b $00,$01,$00,$22
  Dc.b $7B,$20,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $04,$22,$00,$22
  Dc.b $70,$78,$00,$22
  Dc.b $72,$B8,$00,$00
  Dc.b $00,$5C,$00,$00
  Dc.b $00,$0E,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$2E
  Dc.b $00,$17,$00,$02
  Dc.b $00,$01,$8F,$98
  Dc.b $03,$00,$00,$00
  Dc.b $00,$00,$FF,$FF
  Dc.b $FF,$FF,$FF,$FC
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $80,$FF,$FF,$FF
  Dc.b $7C,$00,$81,$80
  Dc.b $00,$00,$06,$00
  Dc.b $81,$80,$00,$00
  Dc.b $06,$00,$81,$9A
  Dc.b $DE,$D5,$86,$00
  Dc.b $81,$97,$5B,$7D
  Dc.b $86,$00,$81,$82
  Dc.b $56,$E9,$86,$00
  Dc.b $81,$81,$AD,$5D
  Dc.b $86,$00,$81,$9F
  Dc.b $FF,$FF,$86,$00
  Dc.b $81,$80,$00,$00
  Dc.b $06,$00,$81,$FF
  Dc.b $FF,$FF,$FE,$00
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$7F
  Dc.b $FF,$FF,$F8,$00
  Dc.b $80,$80,$00,$00
  Dc.b $04,$00,$81,$3A
  Dc.b $AA,$AB,$52,$00
  Dc.b $81,$55,$55,$54
  Dc.b $2A,$00,$82,$00
  Dc.b $00,$00,$01,$00
  Dc.b $83,$FF,$FF,$FF
  Dc.b $FF,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$1F
  Dc.b $FF,$FF,$E0,$04
  Dc.b $00,$1A,$DE,$D4
  Dc.b $00,$04,$00,$17
  Dc.b $5B,$7C,$00,$04
  Dc.b $00,$02,$56,$E8
  Dc.b $00,$04,$00,$01
  Dc.b $AD,$5C,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$1F
  Dc.b $FF,$FF,$E0,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$7F
  Dc.b $FF,$FF,$F8,$04
  Dc.b $00,$C5,$55,$54
  Dc.b $AC,$04,$00,$AA
  Dc.b $AA,$AB,$D4,$04
  Dc.b $01,$FF,$FF,$FF
  Dc.b $FE,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $7F,$FF,$FF,$FF
  Dc.b $FF,$FC,$00,$00
  Dc.b $00,$0E,$42,$6C          ;0,$e4,"Bl"
  Dc.b $69,$74,$7A,$33          ;"itz3"
  Dc.b $3A,$41,$6D,$69          ;":Ami"
  Dc.b $42,$6C,$69,$74          ;"Blit"
  Dc.b $7A,$33,$00,$00          ;"z3",0,0
  Dc.b $00,$00,$04
Even
.SourceIconDatas_End


.menu_about:
  !regs2stack
  !basic
  CNIF #use_NTUI
    OpenAbout{}
  CELSE
    txt0$ = "PED "+!versions+"#AmiBlitz " + Peek$(Peek.l(?comPtr_CompilerVersion))
    txt1$ = !TRANS {"AREXX Port : "}+Peek$(?str_Arexx_PortName)
    txt2$ = !TRANS {"Public Screen : "}+Peek$(?str_defaultpubscreen)
    txt3$ = !TRANS {"AcidLibs: "}+acidlibdate$
    txt4$ = !TRANS {"DefLibs: "}+deflibdate$

    txt0$ = !versions+"#"+Peek$(Peek.l(?comPtr_CompilerVersion))
    txt1$ = Peek$(?str_Arexx_PortName)
    txt2$ = Peek$(?str_defaultpubscreen)
    txt3$ = acidlibdate$
    txt4$ = deflibdate$

    window_welcome{txt0$,txt1$, txt2$, txt3$, txt4$}
  CEND
  !asm
  !stack2regs
RTS




str_searchstring:   Ds.b #MAX_STRINGSIZE
str_replacestring:  Ds.b #MAX_STRINGSIZE
case_sensitive:     Dc.b $00,$00
Even

.search_string:
  MOVEQ.l #$00,D5

  JL_0_15C6:
  LEA $9(A4),A5
  MOVE.w flag_tokenization,D0
  BEQ.w JL_0_15E0
  MOVEA.l A5,A0
  MOVEA.l comPtr_Temp_TokenString1,A1
  MOVEA.l A1,A5
  JSR detokenize_line                ;detokenize_line

  JL_0_15E0:
  MOVEA.l A5,A1                      ;compare routine
  ADDA.w D5,A5

  JL_0_15E4:
  MOVEA.l A5,A3
  LEA str_oldsearchgadget,A2

  JL_0_15EA:
    MOVE.b (A2)+,D0
     BEQ.w JL_0_162E
    MOVE.b (A3)+,D2
     BEQ.w exit_search_string
    BTST #$7,case_sensitive
     BNE.w JL_0_1626
     !check
     ;jsr JL_0_60C6
     BNE.w JL_0_1626
    ANDI.w #$DF,D2

    JL_0_1626:
    CMP.b D0,D2
     BEQ.b JL_0_15EA
    ADDQ.w #1,A5
  BRA.b JL_0_15E4

  JL_0_162E:
  SUBA.l A1,A5
  MOVE.w A5,D0
  RTS

  exit_search_string:
  MOVEQ.l #-$01,D0
RTS

.replace_string:
  JSR search_string
   BMI.w exit_replace_string
  MOVE.w #$FFFF,comWord_SourceChanged

  JL_0_17Dca:
  MOVEA.l comPtr_Temp_TokenString2,A0
  MOVEQ.l #$00,D1

  JL_0_17E2:
    CMP.w D0,D1
    BCC.w JL_0_17EE
    MOVE.b (A1)+,(A0)+
    ADDQ.w #1,D1
  BRA.b JL_0_17E2

  JL_0_17EE:
  LEA str_searchstring,A2

  JL_0_17F2:
  TST.b (A2)+
  BEQ.w JL_0_17FC
  ADDQ.w #1,A1
  BRA.b JL_0_17F2

  JL_0_17FC:
  LEA str_replacestring,A2

  JL_0_1800:
    ADDQ.w #1,D1
    MOVE.b (A2)+,(A0)+
  BNE.b JL_0_1800

  SUBQ.w #1,A0
  SUBQ.w #1,D1
  MOVE.w D1,-(A7)

  JL_0_180C:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_180C

  SUBQ.w #1,A0

  JL_0_1812:
    CMPA.l comPtr_Temp_TokenString3,A0
    BCC.w JL_0_1820
    MOVE.b #$20,(A0)+
  BRA.b JL_0_1812

  JL_0_1820:
  MOVEA.l comPtr_Temp_TokenString2,A2
  JSR parse_line
  JSR JL_0_55AA
  MOVE.w (A7)+,D5
  JSR JL_0_15C6
  BPL.b JL_0_17Dca
  MOVEQ.l #$00,D0
  RTS

  exit_replace_string:
  MOVEQ.l #-$01,D0
RTS



.menu_find:                          ;find
  MOVE.w message_qualifier,d0
  AND.w #3,d0
  BNE 'os1
  JSR jump_addhistory
  TST.w oldsearch
  BEQ 'os1
  MOVEQ #0,d0
  JSR jumpline
 'os1
  !regs2stack
  !basic
  If Peek.l(Addr Window(WZID("WIN_SEARCH")))=0
    WZWindow WZID("WIN_SEARCH"),0,128,-2,-2,-2,-2,WZID("WIN_SEARCH")
    SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    Use Window WZID("WIN_SEARCH") : Delay_ 2
    WZPrint "FIND_FINDSTRING"   ,&oldfindstr$
    WZPrint "FIND_REPLACESTRING",&oldreplacestr$
    ActivateGadget_ WZGadAddr("FIND_FINDSTRING"),WZWindowAddr,0
  Else
    Use Window WZID("WIN_SEARCH")
    WindowToFront_ WZWindowAddr
  EndIf
  !asm
  !stack2regs
RTS

.menu_findnext:
  MOVE.l (A4),D0                     ;start code
  BEQ.w setpointer_to_normal
  MOVEA.l D0,A4
  MOVEQ.l #$01,D6

  JL_0_1754:
  MOVE.b str_searchstring,D0         ;find
  BEQ.w setpointer_to_normal
  JSR set_pointerbusy
  MOVE.l comLong_DisplayLineOffset,D7
  ADD.l comLong_DisplayLine,D7
  ADD.l D6,D7

  JL_0_176A:
    JSR search_string
     BPL.w JL_0_1790
    ADD.l D6,D7
    BMI.w setpointer_to_normal
    CMP.l comLong_TotalLines,D7
    BCC.w setpointer_to_normal
    TST.l D6
    BPL.w JL_0_178C
    MOVEA.l $4(A4),A4
    BRA.b JL_0_176A

    JL_0_178C:
    MOVEA.l (A4),A4
  BRA.b JL_0_176A

  JL_0_1790:
  JSR set_pointernormal
  MOVE.l D0,-(A7)
  MOVE.l D7,D0
  MOVEA.l comPtr_CurrentSourceLine,A4
  JSR sub_gotoline
  MOVE.l (A7)+,D1
  JSR JL_0_7ED2
JMP update_horizscroller

.menu_previous:
  MOVE.l $4(A4),D0
  BEQ.w setpointer_to_normal
  MOVEA.l D0,A4
  MOVEQ.l #-$01,D6
BRA.b JL_0_1754

.menu_replace:
  MOVE.b str_searchstring,D0
  BEQ.w setpointer_to_normal
  JSR replace_string
  BNE.w setpointer_to_normal
  JSR menu_findnext
JMP _redraw



.menu_quitall:
  MOVEA.l #str_newfile_req,A0
  MOVE.l #$51756974,(A0)+            ; "Quit"
  MOVE.b #$0,(A0)+
  JSR show_newfilerequest
  MOVEA.l #str_newfile_req,A0
  MOVE.l #$4E657720,(A0)+            ; "New File"
  MOVE.l #$46696C65,(A0)+
  MOVE.b #$0,(A0)+
  TST.l D0
   BEQ.w exit_quitall

  JSR dummy_compilercall
  JSR clear_labellist
  ; -- hier problem mit enforcer bei !newfree
  JSR clear_actualsource
  ; --
  MOVEA.l actualfile,A0
  JSR close_actualsource
  JSR print_filenames
  TST.l loadedfilesbase
   BNE.b menu_quitall

  JSR arexx_send_quitplease
;  LEA $E(A7),A7                      ;This is pure evil stackmagic that work only for on case that the
                                      ;jump to the routine comes form the asm event/message loop for the
                                      ;Sourcewindow and not form the Basic loop for the other windows
  JMP Exit_main                       ;Jump to real exit, this fix the Exit bug if the Sourcewindow not active  tomsmart1

 exit_quitall:
RTS


.menu_quit:
  MOVEA.l #str_newfile_req,A0
  MOVE.l #$51756974,(A0)+            ; "Quit"
  MOVE.b #$0,(A0)+
  JSR show_newfilerequest
  MOVEA.l #str_newfile_req,A0
  MOVE.l #$4E657720,(A0)+            ; "New File"
  MOVE.l #$46696C65,(A0)+
  MOVE.b #$0,(A0)+
  TST.l D0
   BEQ.w exit_quit

  JSR dummy_compilercall
  JSR clear_labellist
  JSR clear_actualsource             ;alle zeilen loeschen und freigeben

  MOVEA.l actualfile,A0
  JSR close_actualsource

  TST.l loadedfilesbase
   BNE.w exit_quit

  JSR arexx_send_quitplease
;  LEA $E(A7),A7                      ;This is pure evil stackmagic that work only for on case that the
                                      ;jump to the routine comes form the asm event/message loop for the
                                      ;Sourcewindow and not form the Basic loop for the other windows
  JMP Exit_main                       ;Jump to real exit, this fix the Exit bug if the Sourcewindow not active  tomsmart1

 exit_quit:
  JSR update_statusline
RTS


.menu_blockcomment:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w setpointer_to_normal

  JSR move_to_blockstarty
  MOVEA.l A5,A4

 JL_0_21F0:
    MOVEA.l comPtr_Temp_TokenString2,A1
    MOVE.b #";",(A1)+
    LEA $9(A4),A0
    MOVE.w comWord_DoTokenize,D0
    BNE.w JL_0_220E

 JL_0_2206:
      MOVE.b (A0)+,(A1)+
    BNE.b JL_0_2206
BRA.w JL_0_2212

 JL_0_220E:
    JSR detokenize_line

 JL_0_2212:
      CMPA.l comPtr_Temp_TokenString3,A1
      BCC.w JL_0_2220
      MOVE.b #$20,(A1)+
BRA.b JL_0_2212

 JL_0_2220:
    MOVE.l A4,comPtr_CurrentSourceLine
    JSR JL_0_55A2
    MOVEA.l (A4),A4
    ADDQ.l #1,D6
  CMP.l comLong_BlockEndY,D6
  BLS.b JL_0_21F0

  JSR update_currsourceline
JMP _redraw


.menu_blockuncomment:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w setpointer_to_normal

  JSR move_to_blockstarty
  MOVEA.l A5,A4

 JL_0_224E:
  MOVEA.l comPtr_Temp_TokenString2,A1
  LEA $9(A4),A0
  MOVE.w comWord_DoTokenize,D0
   BNE.w JL_0_2268

 JL_0_2260:
  MOVE.b (A0)+,(A1)+
   BNE.b JL_0_2260
BRA.w JL_0_226C

 JL_0_2268:
  JSR detokenize_line

 JL_0_226C:
  MOVEA.l comPtr_Temp_TokenString2,A1
  MOVEA.l A1,A0

 JL_0_2272:
  MOVE.b (A0)+,D1
   BEQ.w JL_0_2286
  CMP.b #";",D1
   BEQ.w JL_0_2288
  CMP.b #$20,D1
   BEQ.b JL_0_2272

 JL_0_2286:
  MOVEA.l A1,A0

 JL_0_2288:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_2288
  SUBQ.w #1,A1

 JL_0_228E:
  CMPA.l comPtr_Temp_TokenString3,A1
   BCC.w JL_0_229C
  MOVE.b #$20,(A1)+
  BRA.b JL_0_228E

 JL_0_229C:
  MOVE.l A4,comPtr_CurrentSourceLine
  JSR JL_0_55A2
  MOVEA.l (A4),A4
  ADDQ.l #1,D6
  CMP.l comLong_BlockEndY,D6
  BLS.b JL_0_224E
  JSR update_currsourceline
JMP _redraw


.menu_blocktab:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w setpointer_to_normal

  JSR update_currsourceline
  JSR move_to_blockstarty
  MOVEA.l A5,A4

 JL_0_22CA:
    MOVEA.l comPtr_Temp_TokenString2,A1     ; -- copy TAB-Spaces to A1
    MOVE.w tab_size,D0
    BEQ.w JL_0_22E2
    SUBQ.w #1,D0

 JL_0_22DA:
      MOVE.b #$20,(A1)+
 DBF D0,JL_0_22DA

 JL_0_22E2:
    LEA $9(A4),A0                    ; -- detokenize line in A0 and copy it in A1 behind TAB-Spaces
    MOVE.w comWord_DoTokenize,D0
    BNE.w JL_0_22F8

 JL_0_22F0:
      MOVE.b (A0)+,(A1)+
    BNE.b JL_0_22F0
BRA.w JL_0_22FC

 JL_0_22F8:
    JSR detokenize_line

 JL_0_22FC:
      CMPA.l comPtr_Temp_TokenString3,A1
      BCC.w JL_0_230A
      MOVE.b #$20,(A1)+
BRA.b JL_0_22FC

 JL_0_230A:
    MOVE.l A4,comPtr_CurrentSourceLine
    JSR JL_0_55A2
    MOVEA.l (A4),A4
    ADDQ.l #1,D6
  CMP.l comLong_BlockEndY,D6
  BLS.b JL_0_22CA                    ; -- next line until comLong_BlockEndY is reached

  JSR update_currsourceline
JMP _redraw


.menu_blockuntab:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w setpointer_to_normal

  JSR move_to_blockstarty
  MOVEA.l A5,A4

  JL_0_2338:
    MOVEA.l comPtr_Temp_TokenString2,A1
    LEA $9(A4),A0
    MOVE.w comWord_DoTokenize,D0
    BNE.w JL_0_2352

 JL_0_234A:
      MOVE.b (A0)+,(A1)+
    BNE.b JL_0_234A
BRA.w JL_0_2356

 JL_0_2352:
    JSR detokenize_line

 JL_0_2356:
    MOVEA.l comPtr_Temp_TokenString2,A1
    MOVEA.l A1,A0
    MOVE.w tab_size,D0
    BEQ.w JL_0_2378
    SUBQ.w #1,D0

 JL_0_2368:
      TST.b (A0)+
      BEQ.w JL_0_2378
 DBF D0,JL_0_2368

 JL_0_2372:
      MOVE.b (A0)+,(A1)+
    BNE.b JL_0_2372
    SUBQ.w #1,A1

 JL_0_2378:
      CMPA.l comPtr_Temp_TokenString3,A1
      BCC.w JL_0_2386
      MOVE.b #$20,(A1)+
BRA.b JL_0_2378

 JL_0_2386:
    MOVE.l A4,comPtr_CurrentSourceLine
    JSR JL_0_55A2
    MOVEA.l (A4),A4
    ADDQ.l #1,D6
  CMP.l comLong_BlockEndY,D6
  BLS.b JL_0_2338

  JSR update_currsourceline
JMP _redraw


.generate_tempfilename:
  LEA str_hexdigits,A1
  MOVEQ.l #$07,D2

 JL_0_23A8:
    ROL.l #4,D0
    MOVE.b D0,D1
    ANDI.w #$F,D1
    MOVE.b $0(A1,D1.W),(A0)+
 DBF D2,JL_0_23A8

RTS


str_hexdigits:             Dc.b "0123456789ABCDEF"
str_temptedprefs:          Dc.b "T:TED_"
;                           Ds.b #MAX_STRINGSIZE
str_template_tempxtrafile: Dc.b "        .xtra",0 : Even
;                           Ds.b #MAX_STRINGSIZE



.close_actualsource:
  CLR.w comWord_SourceChanged

  MOVEM.l D0-D2/A0-A1,-(A7)
  JSR delete_tempprefs
  MOVEM.l (A7)+,D0-D2/A0-A1

  MOVEA.l _execbase,A6
  MOVE.l A0,-(A7)
  TST.l $4(A0)
   BEQ.w rem_file_from_base;JL_0_2432
  TST.l (A0)
   BEQ.w JL_0_2482

  MOVEA.l (A0),A1
  MOVE.l A1,actualfile
  MOVEA.l $4(A0),A2
  MOVE.l A1,(A2)
  MOVE.l A2,$4(A1)
  MOVEA.l A0,A1
  !newfree

  MOVEA.l actualfile,A0
  JSR GetXtraData
  JSR read_tempprefs
  JSR JL_0_2Dca8
  MOVEA.l (A7)+,A0
RTS

rem_file_from_base:
  TST.l (A0)
   BEQ.w JL_0_2466
  MOVEA.l (A0),A1
  MOVE.l A1,loadedfilesbase
  MOVE.l A1,actualfile
  CLR.l $4(A1)
  MOVEA.l A0,A1
  !newfree
  MOVEA.l actualfile,A0
  JSR GetXtraData
  JSR read_tempprefs
  JSR JL_0_2Dca8
  MOVEA.l (A7)+,A0
RTS

 JL_0_2466:
  MOVEA.l A0,A1
  !newfree
  CLR.l loadedfilesbase
  CLR.l AL_0_84B2
  CLR.l actualfile
  MOVEA.l (A7)+,A0
RTS

 JL_0_2482:
  TST.l $4(A0)
   BEQ.w JL_0_24B8

  MOVEA.l $4(A0),A1
  MOVE.l A1,AL_0_84B2
  MOVE.l A1,actualfile
  CLR.l (A1)
  MOVEA.l A0,A1
  !newfree
  MOVEA.l actualfile,A0
  JSR GetXtraData
  JSR read_tempprefs
  JSR JL_0_2Dca8
  MOVEA.l (A7)+,A0
RTS

 JL_0_24B8:
  MOVEA.l A0,A1
  !newfree
  CLR.l loadedfilesbase
  CLR.l AL_0_84B2
  CLR.l actualfile
  MOVEA.l (A7)+,A0
RTS


.dummy_compilercall:
; this call to the compiler is useless, as the adress com_calldummy is always zero
  MOVE.l D0,-(A7)
  MOVE.l comFunc_CallDummy,D0
   BEQ.w exit_dummycall

  MOVEM.l D1-D7/A0-A6,-(A7)
  MOVEA.l D0,A0
  L_0_24E4: JSR (A0)
  MOVEM.l (A7)+,D1-D7/A0-A6
  !basic
  dummy.l = RTEZRequest("","The dummy call has been performed.","Ok")
  !asm
  exit_dummycall:
  MOVE.l (A7)+,D0
RTS


.select_thisline:
!basic
  error{"selected"}
!asm
RTS



;AJL_0_24EE:                          ;cursor_down
.key_cursordown:
  !regs2stack
  !basic
  mqualifier.w = Peek.w(?message_qualifier)
  mqualistor.w = Peek.w(?comWord_QualifierStore)
  Select mqualifier
     Case $0000                         ; -- CURSOR DOWN FOR FREEWHEEL
          Pop Select
          !asm
          !stack2regs
          MOVE.l comLong_DisplayLineOffset,d0
          ADD.l comLong_DisplayLine,D0
          ADD.l wheelstep,d0
          JMP gotoline
                                                                                                                                                                                                                                                      
    Case $8000                         ; -- CURSOR DOWN
      Pop Select
      !asm
      !stack2regs
      MOVE.b #1,doedit2
      JMP movelinedown

    Case $8200                         ; -- CURSOR DOWN PRESSING
      Pop Select
      !asm
      !stack2regs
      MOVE.b #1,doedit2
      JMP movelinedown

    ;Case $8001                         ; -- LSHIFT + CURSOR DOWN

    Case $8008                         ; -- CTRL + CURSOR DOWN
      Pop Select
      !asm
      !stack2regs
      JMP menu_bottom

    Case $8010                         ; -- LALT + CURSOR DOWN
      Pop Select
      !asm
      !stack2regs
      JMP jump_historydown

    Case $8009                         ; -- LSHIFT-CTRL + CURSOR DOWN
      Pop Select
      !asm
      ; -- set startposition
      CMPI.l #$ffffFFFF,comLong_BlockEndY
       BNE.w skip_setstart
      MOVE.w comWord_ColumnsOffset,D0
      ADD.w comWord_Column,D0
      JSR set_blockstart
      skip_setstart:
      !stack2regs
      BSR movelinedown
      MOVE.w comWord_ColumnsOffset,D0
      ADD.w comWord_Column,D0
      JMP set_blockend

      Default
        Pop Select
      !asm
      !stack2regs
      MOVE.l comLong_DisplayLineOffset,D0
      ADD.l comLong_DisplayLine,D0
      ADD.l viewablelines,D0
      CMP.l comLong_TotalLines,D0
       BCS.w gotoline
      MOVE.l comLong_TotalLines,D0
      SUBQ.l #1,D0
      BRA.w gotoline

  End Select

  !asm
  !stack2regs
BRA movelinedown


.movelinedown:
  BSR checkedit2
  CNIF #hardfold = 1
    MOVE.l a0,-(a7)
    MOVE.l comPtr_CurrentSourceLine,a0
    CMP.l #";@@1",9(a0)
    BNE 'n1

   'l2
    CMP.l #";@@0",9(a0)
    BNE 'n2
    MOVE.l 4(a0),a4
  BRA 'n1

   'n2
    MOVE.l (a0),d0
    MOVE.l d0,a0
    BNE 'l2

   'n1
    MOVE.l (a7)+,a0
  CELSE
    MOVE.l a0,-(a7)
    MOVE.l comLong_DisplayLineOffset,-(a7)
    MOVE.l comPtr_CurrentSourceLine,a0
    CMP.l #";@@1",9(a0)
    BNE 'l1

   'l2
    MOVE.l (a0),d0
    BEQ 'l1
    MOVE.l d0,a0
    ADDQ.l #1,comLong_DisplayLineOffset
    CMP.l #";@@1",9(a0)
    BEQ 'l1
    CMP.l #";@@0",9(a0)
    BNE 'l2
    MOVE.l a0,comPtr_CurrentSourceLine
    JSR _redraw
    ADDQ.l #4,a7
    MOVE.l (a7)+,a0
  RTS

   'l1
    MOVE.l (a7)+,comLong_DisplayLineOffset
    MOVE.l (a7)+,a0
  CEND
  MOVE.l (A4),D0
  BNE.w JL_0_252E

 setpointer_to_normal:
  JSR set_pointernormal
RTS


JL_0_252E:
  MOVE.l D0,comPtr_CurrentSourceLine

 JL_0_2534:
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l viewablelines,D0
  CMP.l comLong_TotalLines,D0
  BCC.w JUMP_JL_0_640C
  MOVE.l comLong_DisplayLine,D0
  ADDQ.l #1,D0
  ADD.l comLong_BoundLines,D0
  CMP.l viewablelines,D0
  BCS.w JUMP_JL_0_640C
  ADDQ.l #1,comLong_DisplayLineOffset
  JSR source_fullscroll_down
JMP JL_0_5B60


JUMP_JL_0_640C:
JMP JL_0_640C


;AJL_0_2566:                          ;cursor_up
.key_cursorup:
  !regs2stack
  !basic
  mqualifier.w = Peek.w(?message_qualifier)
  mqualistor.w = Peek.w(?comWord_QualifierStore)
  Select mqualifier
    Case $0000                         ; cursor_up for freewheel
          Pop Select
          !asm
          !stack2regs
          ;MOVE.b #1,doedit2
          MOVE.l comLong_DisplayLineOffset,d0
          ADD.l comLong_DisplayLine,D0
          SUB.l wheelstep,d0
          JMP gotoline
                                                                                                                                                                                                                                                      
    Case $8000                         ; -- just the key
      Pop Select
      !asm
      !stack2regs
      MOVE.b #1,doedit2
      JMP movelineup

    Case $8200                         ; -- pressing the key
      Pop Select
      !asm
      !stack2regs
      MOVE.b #1,doedit2
      JMP movelineup

    ;Case $8001                         ; -- LSHIFT

    Case $8008                         ; -- CTRL
      Pop Select
      !asm
      !stack2regs
      JMP menu_top

    Case $8010                         ; -- LALT
      Pop Select
      !asm
      !stack2regs
      JMP jump_historyup

    Case $8009                         ; -- LSHIFT-CTRL
      Pop Select
      !asm
      ; -- set startposition
      CMPI.l #$ffffFFFF,comLong_BlockEndY
       BNE.w skip_setstart2
      MOVE.w comWord_ColumnsOffset,D0
      ADD.w comWord_Column,D0
      JSR set_blockstart
      skip_setstart2:
      !stack2regs
      BSR movelineup
      MOVE.w comWord_ColumnsOffset,D0
      ADD.w comWord_Column,D0
      JMP set_blockend

    Default
      Pop Select
      !asm
      !stack2regs
      MOVE.l comLong_DisplayLineOffset,D0
      ADD.l comLong_DisplayLine,D0
      CMP.l viewablelines,D0
       BCC.w JL_0_2588
      MOVEQ.l #$00,D0
      BRA.w gotoline

     JL_0_2588:
      SUB.l viewablelines,D0
      BRA.w gotoline

  End Select

  !asm
  !stack2regs
;  MOVE.b #1,doedit2
BRA.w movelineup


.movelineup:
  BSR checkedit2
 CNIF #hardfold = 1
   MOVE.l a2,-(a7)
   MOVE.l a4,a2
   CMP.l #";@@0",9(a2)
   BNE 'n1
   BSR doreverse
   TST.l foldnum
   BEQ 'n1

  'w1
   CMP.l #";@@1",9(a2)
   BNE 'n2
   MOVE.l (a2),a4
  BRA 'n1

  'n2
  'n22
    MOVE.l 4(a2),d0
    MOVE.l d0,a2
    BNE 'w1

  'n1
   MOVE.l (a7)+,a2
 CELSE
   MOVE.l a2,-(a7)
   MOVE.l comPtr_CurrentSourceLine,a4
   MOVE.l a4,a2
   ;MOVE.l comPtr_CurrentSourceLine,a2
   CMP.l #";@@0",9(a2)
   BNE 'l1

  'l2
   JSR doreverse
   TST.l foldnum
   BEQ 'l1
   MOVE.l 4(a2),d0
   BEQ 'l1
   MOVE.l d0,a2
   SUBQ.l #1,comLong_DisplayLineOffset
   CMP.l #";@@1",9(a2)
   BNE 'l2
   MOVE.l a2,comPtr_CurrentSourceLine
   JSR _redraw
   MOVE.l (a7)+,a2
  RTS

  'l1
   MOVE.l (a7)+,a0
 CEND
  MOVE.l $4(A4),D0
  BEQ.b setpointer_to_normal
  MOVE.l D0,comPtr_CurrentSourceLine
  MOVE.l comLong_DisplayLineOffset,D0
  BEQ.w JUMP_JL_0_642A
  MOVE.l comLong_DisplayLine,D0
  CMP.l comLong_BoundLines,D0
  BHI.w JUMP_JL_0_642A
  SUBQ.l #1,comLong_DisplayLineOffset
  JSR source_fullscroll_up
JMP JL_0_5B24

JUMP_JL_0_642A:
JMP JL_0_642A


.menu_markindent:
  LEA $9(A4),A0
  TST.b (A0)
  BEQ.w setpointer_to_normal
  MOVEQ.l #-$01,D0

 JL_0_25CC:
  ADDQ.w #1,D0
  CMPI.b #$20,(A0)+
  BEQ.b JL_0_25CC
  MOVEA.l A4,A1
  MOVE.l comLong_DisplayLineOffset,D1
  ADD.l comLong_DisplayLine,D1
  MOVE.w D1,D2

 JL_0_25E0:
    BEQ.w JL_0_2606
    MOVEA.l $4(A1),A1
    LEA $9(A1),A0
    MOVEQ.l #-$01,D3

 JL_0_25EE:
    ADDQ.w #1,D3
    CMPI.b #$20,(A0)+
     BEQ.b JL_0_25EE
    TST.b -(A0)
     BEQ.w JL_0_2602
    CMP.w D0,D3
     BLT.w JL_0_2606

 JL_0_2602:
    SUBQ.w #1,D1
BRA.b JL_0_25E0

 JL_0_2606:
  MOVEA.l A4,A1

 JL_0_2608:
    MOVE.l (A1),D3
    BEQ.w JL_0_262E
    MOVEA.l D3,A1
    LEA $9(A1),A0
    MOVEQ.l #-$01,D3

 JL_0_2616:
    ADDQ.w #1,D3
    CMPI.b #$20,(A0)+
     BEQ.b JL_0_2616
    TST.b -(A0)
     BEQ.w JL_0_262A
    CMP.w D0,D3
     BLT.w JL_0_262E

 JL_0_262A:
    ADDQ.w #1,D2
BRA.b JL_0_2608

 JL_0_262E:
  MOVE.l D1,comLong_BlockStartY
  CLR.w comLong_BlockStartX
  MOVE.l D2,comLong_BlockEndY
  MOVE.w comWord_MaxColumns,D0
  SUBQ.w #1,D0
  MOVE.w D0,comLong_BlockEndX
  JSR JL_0_56BA
JMP _redraw

 JL_0_2654:
RTS


.checkedit2                          ;neweditmode
  CLR.b nodelete
  TST.b new_editmode
   BEQ 'l1
  TST.b doedit2
   BEQ 'l1
  MOVE.b doedit2,d0
  CLR.b doedit2
  CMP.l  #$ffffffff,comLong_BlockEndY
   BEQ 'l1
  MOVEM.l d0-d7/a0-a6,-(a7)
  CMP.b #2,d0
   BNE 'l2
  JSR arexxfunc_cut
  MOVE.l comLong_BlockStartY,d0
  JSR gotoline
  MOVE.w comLong_BlockStartX,comWord_Column
  TST.b nodisplaybeep
   BNE 'l2
  MOVEA.l ptr_pedscreen,A0
  MOVEA.l _intuibase,A6
  JSR _DisplayBeep(A6)

 'l2
  MOVE.l #$ffffffff,comLong_BlockEndY
  JSR cursor_off
  MOVE.b #1,nodelete

 'l5
  JSR _redraw
  MOVEM.l (a7)+,d0-d7/a0-a6

 'l1
RTS


.menu_insertline:
  JSR allocnewline
  BEQ.w JUMP_JL_0_4942

 JL_0_265E:
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  JSR JL_0_57B6
  ADDQ.l #1,comLong_TotalLines
  MOVE.l $4(A4),D1
  BEQ.w JL_0_268C
  MOVEA.l D1,A1
  MOVE.l A0,(A1)
  MOVE.l A1,$4(A0)
BRA.w JL_0_2692

JL_0_268C:
  MOVE.l A0,comPtr_FirstSourceLine

 JL_0_2692:
  MOVE.l A4,(A0)
  MOVE.l A0,$4(A4)
  MOVE.l A0,comPtr_CurrentSourceLine
  MOVE.l comLong_DisplayLine,D7
  JSR source_partscroll_up
JMP JL_0_57E0

JUMP_JL_0_4942:                                 ; move it out of the function  tomsmart1
JMP JL_0_4942


.menu_undeleteline:
  MOVEQ.l #$00,D5
  MOVE.w comWord__AL_0_8A6A,D5
  MOVEA.l AL_0_5BB2,A1
  TST.b (A1)
  BEQ.w JUMP_JL_0_76E8
  MOVE.l comPtr_Temp_TokenString2,-(A7)
  MOVE.l A1,comPtr_Temp_TokenString2
  JSR JL_0_4F1A
  MOVE.l (A7)+,comPtr_Temp_TokenString2
  BSR.b JL_0_265E
  JSR print_current_sourceline
  MOVEQ.l #$00,D0
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  JSR JL_0_57B6
RTS

JUMP_JL_0_76E8:
JMP JL_0_76E8


.menu_deleteline:
  MOVE.w #$FFFF,comWord_SourceChanged
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w JL_0_2738
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  CMP.l comLong_BlockStartY,D0
   BCS.w JL_0_272C
  CMP.l comLong_BlockEndY,D0
   BHI.w JL_0_2738
  SUBQ.l #1,comLong_BlockEndY
  MOVE.l comLong_BlockEndY,D0
  CMP.l comLong_BlockStartY,D0
   BCC.w JL_0_2738
  CLR.l comLong_BlockEndY

 JL_0_272C:
  SUBQ.l #1,comLong_BlockStartY
  SUBQ.l #1,comLong_BlockEndY

 JL_0_2738:                         ;delete line
  MOVE.l (A4),D7
   BEQ.w JL_0_2776
  SUBQ.l #1,comLong_TotalLines
  MOVE.l $4(A4),D6
   JSR JL_0_6BD2
  MOVEA.l D7,A1
  MOVE.l D6,$4(A1)
   BNE.w JL_0_2760
  MOVE.l A1,comPtr_FirstSourceLine
BRA.w JL_0_2764

 JL_0_2760:
  MOVEA.l D6,A0
  MOVE.l D7,(A0)

 JL_0_2764:
  MOVE.l D7,comPtr_CurrentSourceLine
  MOVE.l comLong_DisplayLine,D7
  JSR source_partscroll_down
JMP JL_0_5B60


JL_0_2776:
  MOVE.l $4(A4),D6
  BEQ.w JL_0_27C2
  SUBQ.l #1,comLong_TotalLines
  JSR JL_0_6BD2
  MOVEA.l D6,A0
  MOVE.l A0,comPtr_CurrentSourceLine
  MOVE.l A0,comPtr_LastSourceLine
  CLR.l (A0)
  MOVE.l comLong_DisplayLineOffset,D0
  BEQ.w JL_0_27B6
  SUBQ.l #1,comLong_DisplayLineOffset
  MOVE.l comLong_DisplayLine,D7
  JSR source_partscroll_down
  JSR source_fullscroll_up
JMP JL_0_5B24


JL_0_27B6:
  MOVE.l comLong_DisplayLine,D7
  JSR source_partscroll_down
JMP JL_0_642A


JL_0_27C2:
   JSR JL_0_6BD2
JMP JL_0_5B00


.menu_joinline:                      ;join line
  MOVE.l (A4),D0
  BEQ.w setpointer_to_normal
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVEA.l D0,A5
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVE.w comWord_MaxColumns,D0

 JL_0_27E6:
  SUBQ.w #1,D0
   BMI.w JL_0_27F4
  CMPI.b #$20,$0(A2,D0.W)
   BEQ.b JL_0_27E6

 JL_0_27F4:
  ADDQ.w #1,D0
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w JL_0_2880
  MOVE.l comLong_DisplayLineOffset,D1
  ADD.l comLong_DisplayLine,D1
  CMP.l comLong_BlockEndY,D1
   BCC.w JL_0_2880
  ADDQ.l #1,D1
  CMP.l comLong_BlockStartY,D1
   BEQ.w JL_0_282C
   BCS.w JL_0_2874
  CMP.l comLong_BlockEndY,D1
   BEQ.w JL_0_283E
BRA.w JL_0_287A

 JL_0_282C:
  CMP.l comLong_BlockEndY,D1
   BEQ.w JL_0_2854
  ADD.w D0,comLong_BlockStartX
BRA.w JL_0_2870

 JL_0_283E:
  CMP.l comLong_BlockStartY,D1
   BEQ.w JL_0_2854
  ADD.w D0,comLong_BlockEndX
   JSR JL_0_7A14
BRA.w JL_0_287A

 JL_0_2854:
  MOVE.w comLong_BlockEndX,D3
  SUB.w comLong_BlockStartX,D3
  MOVE.w comLong_BlockStartX,D2
  ADD.w D0,D2
  MOVE.w D2,comLong_BlockStartX
  ADD.w D3,D2
  MOVE.w D2,comLong_BlockEndX
  JL_0_2870:
  JSR JL_0_7A14

 JL_0_2874:
  SUBQ.l #1,comLong_BlockStartY

 JL_0_287A:
  SUBQ.l #1,comLong_BlockEndY

 JL_0_2880:
  MOVEA.l comPtr_Temp_TokenString2,A0
  LEA $0(A0,D0.W),A1

 JL_0_2888:
    SUBQ.w #1,D0
    BMI.w JL_0_2896
    MOVE.b $0(A2,D0.W),$0(A0,D0.W)
BRA.b JL_0_2888

 JL_0_2896:
  LEA $9(A5),A0

 'l2
    CMP.b #32,(a0)                 ;join without space
    BNE 'l1
    ADDQ.l #1,a0
BRA 'l2

 'l1
   MOVE.w comWord_DoTokenize,D0
   BNE.w JL_0_28AE

 JL_0_28A4:
  MOVE.b (A0)+,(A1)+
   BNE.b JL_0_28A4
  SUBQ.w #1,A1
BRA.w JL_0_28B2

 JL_0_28AE:
  JSR detokenize_line

 JL_0_28B2:
    CMPA.l comPtr_Temp_TokenString3,A1
    BCC.w JL_0_28C0
    MOVE.b #$20,(A1)+
BRA.b JL_0_28B2

 JL_0_28C0:
  MOVEA.l comPtr_Temp_TokenString2,A2
  JSR parse_line
  JSR JL_0_55AA
  MOVEA.l (A4),A1
  MOVE.l (A1),D0
   BEQ.w JL_0_28E0
  MOVEA.l D0,A0
  MOVE.l A0,(A4)
  MOVE.l A4,$4(A0)
BRA.w JL_0_28E8

 JL_0_28E0:
  MOVE.l A4,comPtr_LastSourceLine
  CLR.l (A4)

 JL_0_28E8:
  MOVEQ.l #$00,D0
  ADD.b $8(A1),D0
  MOVEA.l _execbase,A6
  ST comWord__AL_0_86C0
   !newfree
  SUBQ.l #1,comLong_TotalLines
JMP _redraw


JL_0_2906:
  TST.b new_editmode
  BNE AJL_0_2A82b

 JL_0_2906b
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVE.w comWord_ColumnsOffset,D0
  ADD.w comWord_Column,D0
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w JL_0_29BC
  MOVE.l comLong_DisplayLineOffset,D2
  ADD.l comLong_DisplayLine,D2
  CMP.l comLong_BlockEndY,D2
  BHI.w JL_0_29BC
  BEQ.w JL_0_2962
  CMP.l comLong_BlockStartY,D2
   BCS.w JL_0_29B0
   BNE.w JL_0_29B6
  CMP.l comLong_BlockEndY,D2
   BEQ.w JL_0_2982
  CMP.w comLong_BlockStartX,D0
   BHI.w JL_0_29B6
  MOVE.w comLong_BlockStartX,D2
  SUB.w D0,D2
  MOVE.w D2,comLong_BlockStartX
BRA.w JL_0_29B0

 JL_0_2962:
  CMP.l comLong_BlockStartY,D2
   BEQ.w JL_0_2982
  CMP.w comLong_BlockEndX,D0
   BHI.w JL_0_29BC

 JL_0_2972:
  MOVE.w comLong_BlockEndX,D2
  SUB.w D0,D2
  MOVE.w D2,comLong_BlockEndX
BRA.w JL_0_29B6

 JL_0_2982:
  CMP.w comLong_BlockEndX,D0
   BHI.w JL_0_29BC
  CMP.w comLong_BlockStartX,D0
   BHI.b JL_0_2972
  MOVE.w comLong_BlockEndX,D3
  SUB.w comLong_BlockStartX,D3
  MOVE.w comLong_BlockStartX,D2
  SUB.w D0,D2
  MOVE.w D2,comLong_BlockStartX
  ADD.w D3,D2
  MOVE.w D2,comLong_BlockEndX
   JSR JL_0_7A14

 JL_0_29B0:
  ADDQ.l #1,comLong_BlockStartY

 JL_0_29B6:
  ADDQ.l #1,comLong_BlockEndY

 JL_0_29BC:
  MOVEA.l comPtr_Temp_TokenString2,A0
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  TST.b new_editmode
  BEQ JL_0_29C8
  CLR.w comWord_Column
  MOVE.l d0,-(a7)
  MOVEQ #0,d0

 'l2
  CMP.b #$20,0(a2,d0)
  BNE 'l1
  ADDQ #1,d0
  MOVE.b #32,(a0)+                   ;split line to column
  CMP.l #MAX_Columns,d0
  BGE 'l3
BRA 'l2

 'l1
  TST.w comWord_ColumnsOffset
    BEQ 'ld
    CLR.w comWord_ColumnsOffset
    CMP.w visiblecolumns,d0
    BLE 'ld
    SUB.w visiblecolumns,d0
   MOVE.w visiblecolumns,comWord_ColumnsOffset
    CMP.w visiblecolumns,d0
    BLE 'ld
    SUB.w visiblecolumns,d0
    MOVE.l d0,-(a7)
    MOVE.w comWord_ColumnsOffset,d0
    ADD.w visiblecolumns,d0
    MOVE.w d0,comWord_ColumnsOffset
    MOVE.l (a7)+,d0

 'ld
    MOVE.w d0,comWord_Column

 'l3
  MOVE.l (a7)+,d0

 JL_0_29C8:
  MOVE.b $0(A2,D0.W),(A0)+
  MOVE.b #$20,$0(A2,D0.W)
  ADDQ.w #1,D0
  CMP.w comWord_MaxColumns,D0
   BCS.b JL_0_29C8

 JL_0_29DA:
  CMPA.l comPtr_Temp_TokenString3,A0
   BCC.w JL_0_29E8
  MOVE.b #$20,(A0)+
BRA.b JL_0_29DA

 JL_0_29E8:
   JSR parse_line
   JSR JL_0_55AA
  MOVEA.l comPtr_Temp_TokenString2,A2
   JSR parse_line
  MOVE.l D5,D0
  ADDI.w #$9,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  JSR JL_0_492E
  MOVEA.l D0,A0
  MOVE.b D5,$8(A0)
  LEA $9(A0),A0
  MOVEA.l comPtr_Temp_TokenString1,A1

 JL_0_2A16:
  MOVE.b (A1)+,(A0)+
   BNE.b JL_0_2A16
  MOVEA.l D0,A0
  MOVE.l A4,$4(A0)
  MOVE.l (A4),D1
   BEQ.w JL_0_2A32
  MOVEA.l D1,A1
  MOVE.l A0,$4(A1)
  MOVE.l A1,(A0)
BRA.w JL_0_2A3A

 JL_0_2A32:
  MOVE.l A0,comPtr_LastSourceLine
  CLR.l (A0)

 JL_0_2A3A:
  MOVE.l A0,(A4)
  ADDQ.l #1,comLong_TotalLines
  TST.b new_editmode
  BNE 'l1
  CLR.w comWord_Column

 'l1
  BSR movelinedown
JMP _redraw


JL_0_2A46:
  TST.w auto_indent
   BEQ.w JL_0_2A7A
  MOVEM.l D0/A0,-(A7)
  MOVEA.l comPtr_CurrentSourceLine,A0
  LEA $9(A0),A0
  MOVEQ.l #-$01,D1

 JL_0_2A60:
  ADDQ.w #1,D1
  MOVE.b (A0)+,D0
   BEQ.w JL_0_2A6E
  CMP.b #$20,D0
   BEQ.b JL_0_2A60

 JL_0_2A6E:
  MOVEM.l (A7)+,D0/A0
  MOVE.w D1,comWord_Column
RTS


JL_0_2A7A:
  CLR.w comWord_Column
RTS


;JUMP_JL_0_4942                         ;deactivaed because double  tomsmart1
;JMP JL_0_4942


.insertreturn:                       ;return_key
  MOVE.l comPtr_CurrentSourceLine,a4
  MOVE.w comWord_QualifierStore,D0
  ANDI.w #$3,D0
   BNE.w JL_0_2906
  TST.b new_editmode
   BNE JL_0_2906b

 AJL_0_2A82b
  JSR allocnewline
   BEQ.w JUMP_JL_0_4942
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  ADDQ.w #1,D0
   JSR JL_0_57B6
  ADDQ.l #1,comLong_TotalLines
   BSR.b JL_0_2A46
  ;MOVE.l comPtr_CurrentSourceLine,d1
  MOVE.l (A4),D1
   BNE.w JL_0_2AD0
  MOVE.l A0,(A4)
  MOVE.l A4,$4(A0)
  MOVE.l A0,comPtr_LastSourceLine
BRA.w JL_0_2ADE

 JL_0_2AD0:
  MOVEA.l D1,A1
  MOVE.l A0,$4(A1)
  MOVE.l A0,(A4)
  MOVE.l A1,(A0)
  MOVE.l A4,$4(A0)

 JL_0_2ADE:
  MOVE.l A0,comPtr_CurrentSourceLine
  MOVE.w comWord_ColumnsOffset,D0
  BEQ.w JL_0_2AF6
  CLR.w comWord_ColumnsOffset
  JSR JL_0_7962

 JL_0_2AF6:
  JSR update_horizscroller
  MOVE.l comLong_DisplayLine,D0
  ADDQ.w #1,D0
  ADD.w comLong_BoundLines,D0
  CMP.l viewablelines,D0
  BCS.w JL_0_2B6C
  ADDQ.l #1,comLong_DisplayLineOffset
  MOVE.l viewablelines,-(A7)
  MOVE.l comLong_DisplayLine,D0
  ADDQ.l #1,D0
  MOVE.l D0,viewablelines
  MOVE.w ypos_statusarea,-(A7)
;  MULU comWord__AL_0_86CC,D0
;  MOVE.w D0,ypos_statusarea
  JSR source_fullscroll_down
  MOVE.w (A7)+,ypos_statusarea
  MOVE.l (A7)+,viewablelines
  MOVEM.w D0-D1,-(A7)
  MOVEQ.l #$00,D0
  MOVE.l comLong_DisplayLine,D1
  ADD.l comLong_DisplayLineOffset,D1
  JSR JL_0_3154
  MOVEM.w (A7)+,D0-D1
  TST.b comByte_StateBlockMark
  BNE.w JL_0_2B68
RTS

 JL_0_2B68:
JMP _redraw

 JL_0_2B6C:
  MOVE.l comLong_DisplayLine,D7
  ADDQ.w #1,D7
  JSR source_partscroll_up
  JSR JL_0_2534
  MOVEM.w D0-D1,-(A7)
  MOVEQ.l #$00,D0
  MOVE.l comLong_DisplayLine,D1
  ADD.l comLong_DisplayLineOffset,D1
  JSR JL_0_3154
  MOVEM.w (A7)+,D0-D1
  TST.b comByte_StateBlockMark
  BNE.w JL_0_2BA0
RTS

 JL_0_2BA0:
JMP JL_0_7962


.menu_top:
  JSR jump_addhistory
  MOVEQ.l #$00,D0
BRA.w sub_gotoline


.menu_bottom:
  JSR jump_addhistory
  MOVE.l comLong_TotalLines,D0
  SUBQ.l #1,D0
BRA.w sub_gotoline


.event_vertscroller:
  MOVE.l viewablelines,D0
  CMP.l comLong_TotalLines,D0
   BCS.w JL_0_2BC2
RTS

 JL_0_2BC2:
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  MOVE.l D0,comLong_LinePosStartX
  JSR switch_cursordisplay

Macro mul48f
      _floattemp.f = (`1)
      _floattemp = _floattemp * (`2)
      _floattemp = _floattemp / (`3)
      `4 = Int(_floattemp+.5)
End Macro

 JL_0_2BD4:

    ; Thilo's integer code (>65536 lines possible!)
    !basic
    #max_slider_res = $7FFF
    If *vertiprop.Gadget
      GetAttr_ #PGA_Top    ,*vertiprop,&slider_top.l
      totallines.l = Peek.l(?comLong_TotalLines)
      If totallines>=#max_slider_res
        !mul48f{slider_top,totallines,#max_slider_res,realline.l}
      Else
        realline = slider_top
      End If
      realline + Peek.l(?comLong_DisplayLine)
    Else
      realline = 0
    End If
    GetD0 realline
    !asm

    ; old 16 bit code
    ;MOVEQ #0,d0
    ;MOVE.w pos_vertiprop,D0

    ; Bernd's float code
;    fmove.l d0,fp0
;    fmul.l comLong_TotalLines,fp0
;    fdiv.s #65536,fp0
    ;Dc.l $F2000003
;    fmove.l fp0,d0
    ;LSR.l #5,d0
    ;MOVE.l comLong_TotalLines,d1
    ;MULU.l d1,d0
    ;LSR.l #8,d0
    ;LSR.l #3,d0

    CMP.l comLong_LinePosStartX,D0
    BEQ.w JL_0_2C02
      MOVE.l D0,comLong_LinePosStartX
      JSR switch_cursordisplay
      MOVE.l comLong_LinePosStartX,D0
      JSR gotoline
      JSR switch_cursordisplay
      JSR update_statusline          ;JSR linetext

 JL_0_2C02:
    JSR check_events                 ; check ob gadget noch gedrueckt
    TST.l D7
  BEQ.b JL_0_2BD4

  JSR switch_cursordisplay

  ; Thilo's integer code (>65536 lines possible!)
  !basic

  If *vertiprop.Gadget
    GetAttr_ #PGA_Top    ,*vertiprop,&slider_top.l
    totallines.l = Peek.l(?comLong_TotalLines)
    If totallines>=#max_slider_res
      !mul48f{slider_top,totallines,#max_slider_res,realline.l}
    Else
      realline = slider_top
    End If
    realline + Peek.l(?comLong_DisplayLine)
  Else
    realline = 0
  End If
  GetD0 realline
  !asm

  ; old 16 bit code
  ;MOVEQ #0,d0
  ;MOVE.w pos_vertiprop,D0

  ; Bernd's float code
;  fmove.l d0,fp0
;  fmul.l comLong_TotalLines,fp0
;  fdiv.s #65536,fp0
  ;Dc.l $F2000003
;  fmove.l fp0,d0
  ;LSR.l #5,d0
  ;MOVE.l comLong_TotalLines,d1
  ;MULU.l d1,d0
  ;LSR.l #8,d0
  ;LSR.l #3,d0

BRA.w gotoline


.sub_gotoline:
  MOVE.w #$FFFF,-(A7)
  CLR.w comWord_Column
BRA.w JL_0_2C2E


gotoline:
  CLR.w -(A7)
  TST.l d0
  BGE JL_0_2C2E
  MOVEQ #0,d0
 JL_0_2C2E:
  CMP.l comLong_TotalLines,d0
  BLE 'l10
  MOVE.l comLong_TotalLines,d0
  SUBQ.l #1,d0

 'l10
  MOVE.l comLong_DisplayLineOffset,D1
  MOVE.l D1,-(A7)
  ADD.l comLong_DisplayLine,D1
  CMP.l D1,D0
  BEQ.w JL_0_2C58
  BCC.w JL_0_2C50

 JL_0_2C42:
  SUBQ.l #1,D1
    MOVEA.l $4(A4),A4
    CMP.l D1,D0              ;goto line in d0
  BNE.b JL_0_2C42
BRA.w JL_0_2C58

 JL_0_2C58b
  MOVE.l comLong_TotalLines,d0
  SUBQ.l #1,d0
  MOVE.l d0,d1
  BRA JL_0_2C58

 JL_0_2C50:
  ADDQ.l #1,D1
  TST.l (a4)
  BEQ JL_0_2C58b
  MOVEA.l (A4),A4
  CMP.l D1,D0
  BNE.b JL_0_2C50

 JL_0_2C58:
  MOVE.l A4,comPtr_CurrentSourceLine
  TST.b newsyntax
  BEQ 'l10
  JSR syntax_new1

 'l10
  MOVE.l comLong_BoundLines,D1
  CLR.b newsyntax
  MOVE.l D0,D2
  SUB.l D1,D0
  BPL.w JL_0_2C7C

 JL_0_2C6C:
  CLR.l comLong_DisplayLineOffset
  MOVE.w D2,comLong_DisplayLine+2
BRA.w JL_0_2CBA

 JL_0_2C7C:
  MOVE.l comLong_TotalLines,D3
  CMP.l viewablelines,D3
  BLS.b JL_0_2C6C
  SUB.l viewablelines,D3
  ADD.l comLong_BoundLines,D3
  CMP.l D3,D2
  BCS.w JL_0_2CAE
  SUB.l comLong_BoundLines,D3
  MOVE.l D3,comLong_DisplayLineOffset
  SUB.l D3,D2
  MOVE.w D2,comLong_DisplayLine+2
BRA.w JL_0_2CBA

 JL_0_2CAE:
  MOVE.w D1,comLong_DisplayLine+2
  MOVE.l D0,comLong_DisplayLineOffset

 JL_0_2CBA:
  JSR JL_0_775E
  MOVE.l (A7)+,D1
  CMP.l comLong_DisplayLineOffset,D1
  BEQ.w JL_0_2CCC
  JSR _redraw

 JL_0_2CCC:
  TST.w (A7)+
  BNE.w JUMP_update_horizscroller
RTS

JUMP_update_horizscroller
JMP update_horizscroller


; -- handle compilermenu
; menuids
; $5A: Leerzeile im Menu
; $50: Compile & Run
; $5b: Save & Create Exec
; $5c: Save & Compile & Run
; $5d: Debug / Runerrors On 10*slower Code
; $5e: Create Executable absolut Smallest

; $57: calculator
; $58: reload all libs
; $59: open sourcebrowser

.call_compilermenuitem:               ; (Menuitem in D6)
;!regs2stack
;!basic
;  MOVE.l D6,D0
;  _D0.l= PutD0
;  error{Str$(_D0)}
;!asm
;RTS

  CMP.w #$5A,D6    ; empty menu
  BNE.w JL_0_2CE0
 ;JMP change_directory
RTS

 JL_0_2CE0:
  CMP.w ##MENU_COMPILERUN,D6
   BEQ.w JL_0_2CF0
  CMP.w ##MENU_RUN,D6
   BNE.w JL_0_2D10

 JL_0_2CF0:
  !basic
;  If *tedlibbase
;    TEDSetLabelList_  ?comPtr_LabelList
;    TEDSetLabelCount_ ?comWord_LabelCounter
;  EndIf
    TEDSetLabelList {?comPtr_LabelList}
    TEDSetLabelCount{?comWord_LabelCounter}

  !asm

 JL_0_2D10:
  CMP.l ##MENU_CREATERELEASEEXE,d6
  BNE skip_comploop
  !basic  ; create executable as long as the file size does not decrease anymore
  ;dos_Delete{dos_AddPart{exepathname$,exefilename$}}
;  error {"Compilepath: "+dos_AddPart{exepathname$,exefilename$}}
  comp_exit.b = False : comp_counter.b = 0
  oldexesize.l = $7FFFFFFF
  total_counter.l = 0
  Repeat
    comp_counter + 1
    total_counter + 1
    !asm
    MOVEQ #$b,d6
    MOVE.l comFunc_CallMenuEntry,a0
    MOVEA.l comPtr_FirstSourceLine,A5
    MOVE.l comLong_TotalLines,D7
    ;MOVE.l d0,-(A7)
    JSR (A0)
    JSR check_state_of_debuggertoggle
    !basic
    newexesize.l = dos_GetFileSizeEx{dos_AddPart{exepathname$,exefilename$}}
    If newexesize<1 Then newexesize=oldexesize
;    !cout{"old: ",oldexesize,"newexelngth:",newexesize}
    If (oldexesize = newexesize) AND (comp_counter>2) Then comp_exit    = True
    If oldexesize>newexesize                          Then comp_counter = 0 : oldexesize=newexesize
  Until comp_exit OR total_counter>20
  !asm
RTS

skip_comploop:
  SUBI.l #$50,D6
  MOVE.l comFunc_CallMenuEntry,D0
  BEQ.w exit_callcompilermenuentry

  CMP.w #$b,d6                       ; Save & Create executable
  BNE 'l10
  JSR saverout

 'nosave
  MOVEQ #$b,d6

 'l10
  CMP.w #$c,d6                       ; Save & Compile & run
  BNE 'l20

  JSR menu_save
  !basic
  Delay_(50)
  !asm

 'nosave2
  MOVEQ #$0,d6

 'l20
  CMP.b #9,d6                        ; Open Sourcebrowser
  BNE 'l21
  !basic
  MOVEM.l a0/d0/d1,-(a7)
  Gosub open_labelwindow
  MOVEM.l (a7)+,d0/d1/a0
  !asm
RTS

 'l21
;  CMP.w #$4,D6
;  BNE.w no_createresident
;  MOVEM.l D0-D7/A0-A6,-(A7)
;  MOVEM.l (A7)+,D0-D7/A0-A6
;  no_createresident:


  MOVE.l d0,-(a7)
  MOVE.l #comStr_CurrentDir,D0       ;set default dir
  JSR set_currentdir
  MOVE.l (a7)+,d0
  MOVE.l comFunc_CallMenuEntry,a0
  MOVEA.l comPtr_FirstSourceLine,A5
  MOVE.l comLong_TotalLines,D7
  MOVE.l D6,-(A7)                    ;menu num

 L_0_2D2A:
  JSR (A0)                           ;call compiler menuentry

  JSR check_state_of_debuggertoggle
  !basic
  MOVEM.l a0/d0/d1,-(a7)
  previoussearch_instruction$ = "|"
  Gosub update_versiongadgets
  MOVEM.l (a7)+,d0/d1/a0
  !asm
  MOVE.l (A7)+,D6

 skipc
  CMP.w #$8,D6                       ; reload all libs
   BNE.w JL_0_2D42
  MOVEM.l D0-D7/A0-A6,-(A7)
  JSR read_tempprefs
  MOVEM.l (A7)+,D0-D7/A0-A6

 JL_0_2D42:
  CMP.w #$3,D6                       ; compiler settings
  BNE.w JL_0_2D56
  MOVEM.l D0-D7/A0-A6,-(A7)
  JSR save_tempprefs
  !basic
  If WZ_CheckOpen{"WIN_NEWTYPE"}
    Use Window WZID("WIN_NEWTYPE")
    Gosub newtype_updatelist
  End If
  !asm
  MOVEM.l (A7)+,D0-D7/A0-A6

 JL_0_2D56:
  MOVE.l D0,-(A7)
  JSR update_title_sourcewindow
  MOVE.l (A7)+,D0
  MOVEA.l comPtr_CurrentSourceLine,A4
  CMP.l #-$2,D0
   BEQ.w _redrawb
  CMP.l #-$1,D0
   BNE.w JL_0_2C1Eb

 exit_callcompilermenuentry:
RTS


JUMP_JL_0_5054
JMP JL_0_5054

JL_0_2C1Eb:                          ;??looks like double label??
.syntax_setcursor
  MOVE.w #$FFFF,-(A7)                ;syntax set cursor
  MOVE.b #1,newsyntax
BRA.w JL_0_2C2E

.syntax_new1
  MOVE.l d0,-(a7)
  MOVEA.l comPtr_Temp_TokenString1,A1

  MOVE.l a4,a0
  LEA 9(a0),a0
  MOVEQ #-1,d1

 syn1:
  TST.w comWord_DoTokenize
  BEQ.w JUMP_JL_0_5054

  CMP.l a0,a5
  BEQ  JL_0_5050b
  ADDQ.l #1,d1
  MOVEQ.l #$00,D0
  MOVE.b (A0)+,D0
  BEQ.w JL_0_5050b
  BMI.w JL_0_5040b
  MOVE.b D0,(A1)+
  BNE.b syn1

 JL_0_5040b:
  LSL.w #8,D0
  MOVE.b (A0)+,D0
  MOVE.l d1,-(a7)
  JSR token_to_ascii
  MOVE.l (a7)+,d1

 JL_0_5048b:
  ADDQ.l #1,d1
  MOVE.b (A3)+,(A1)+
  BNE.b JL_0_5048b
  SUBQ.w #1,A1
  SUBQ.l #1,d1
BRA.b syn1

 JL_0_5050b:
  SUBQ.l #1,d1
  CMP.w #MAX_Columns,d1
  BGE 'l1
  CMP.l #0,d1
  BGE 'l1
  MOVEQ #0,d1

 'l1
  MOVE.w d1,comWord_Column
  MOVE.l (a7)+,d0
RTS


.event_shortcut:
  CMP.l #$50,D6
   BLT.w handle_menucalls
  CMP.l #$65,D6
   BGE.w handle_menucalls
BRA.w call_compilermenuitem


.handle_menucalls:
  CMP.l #$258,D6                     ; ped menuitem
   BLE.w call_ownmenuitem
  CMP.l #$f00,D6                     ; compiler menuitem
   BGE call_ownmenuitem
JMP call_pluginmenuentry             ;plugin menuitem


.call_ownmenuitem:
  ; -- check for subitem with templates, base-id $200
  MOVE.l d6,-(a7)
  !basic
  MOVE.l (a7)+,D0
  menuentry.l = PutD0
  If menuentry >= #MENU_TEMPLATE AND menuentry<#MENU_TEMPLATE+#MAX_TEMPLATES
    Gosub load_template
    Pop If
    !asm
    JMP update_vertscroller
  EndIf
  !asm

  LEA menutable,A0

 JL_0_2DA2:
    MOVE.l (A0)+,D0
    CMP.l #$FFFFFFFF,D0
     BEQ.w exit_call_ownmenuitem
    CMP.l D6,D0
     BEQ.w JL_0_2DB8
    ADDQ.w #8,A0
BRA.b JL_0_2DA2

 JL_0_2DB8:
  MOVE.l (A0)+,-(A7)
  MOVEA.l (A0)+,A0

 L_0_2DBC:
  JSR (A0)                           ;call the menupoint
  MOVE.l (A7)+,D0

  TST.l D0
   BNE.w JUMP_update_vertscroller

 exit_call_ownmenuitem:
RTS

JUMP_update_vertscroller:
JMP update_vertscroller


JL_0_2Dca8:
  MOVE.w AL_0_B7EE,D0
  CMP.w comWord__AL_0_86C4,D0
  BEQ.w JL_0_2DEA

  MOVE.w AL_0_B7EE,comWord__AL_0_86C4
  JSR close_sourcewindow
  JSR open_sourcewindow

 JL_0_2DEA:
  JSR update_labelstuff
  JSR JL_0_57F2
  JSR analyze_loadedsource
  TST.b refreshonstore
  BNE 'l2
  TST.b AL_0_4734
  BNE.w JL_0_2E0E
  JSR update_statusline
  JSR _redraw

 'l2
  MOVE.l #comStr_CurrentDir,D0
  JSR set_currentdir

 JL_0_2E0E:
  MOVEA.l comPtr_CurrentSourceLine,A4
  CLR.w comWord_SourceModifiedFlag
;  JSR printlargestmem
RTS


.load_template:
  mcounter.l = menuentry-#MENU_TEMPLATE
;  error{"Menuentry is:"+Str$(menuentry)}
  ResetList templates()
  For n.l=0 To mcounter-1
    NextItem templates()
  Next
  If NextItem(templates())
; -- optinally check, if template already loaded
;    If Peek$(Peek.l(?actualfile)+$DE)<>""
;      !asm
;      JSR menu_opennew
;      !basic
;    EndIf
    templatefilename$ = templates()\filename
    GetD0 &templatefilename$
    !asm
    MOVE.l d0,-(a7)
    JSR menu_opennew
    MOVE.l (a7)+,d7
    JSR load_source
  Else
    templatefilename$=!TRANS{"unknown"}
    MOVE.l d0,-(a7)
    GetD0 &templatefilename$
    !asm
    JSR menu_opennew
     MOVE.l (a7)+,d0 ; clean stack
  EndIf
Return


.menu_openload
  MOVE.w #0,loadmode
BRA JL223


.menu_opennew:                       ;open new func
  MOVE.w #1,loadmode

 JL223:
  JSR storeline
  MOVE.l d0,-(a7)
  MOVE.l comFunc_ReadXtraFile,d0
  BEQ 'l10
    MOVE.l d0,a0
    CLR.l d0
    JSR (a0)

 'l10
  MOVE.l (a7)+,d0

  MOVEA.l _execbase,A6
  MOVE.l #comDef_XtraEnd-comLongLong_XtraBegin+10,d0
  ;MOVE.l #$50C+72,D0
  MOVE.l ##MEMF_CLEAR,D1
  !newalloc;JSR _AllocVec(A6)
  TST.l D0
   BEQ.w JUMP_display_memoryalert
  TST.l AL_0_84B2
   BNE.w JL_0_2E70
  MOVEM.l D0/A6,-(A7)
  JSR clear_sourcebuffer;JL_0_6B7C
  CLR.w comWord_SourceChanged
  MOVEM.l (A7)+,D0/A6
  MOVE.l D0,actualfile
  MOVE.l D0,AL_0_84B2
  MOVE.l d0,loadedfilesbase
  MOVEA.l D0,A0
  CLR.l $4(A0)
  CLR.l (A0)
RTS

JUMP_display_memoryalert:
JMP display_memoryalert


JL_0_2E70:
  JSR StoreXtraData
  CLR.w comWord_SourceChanged
  MOVEA.l D0,A0
  MOVEA.l actualfile,A1
  MOVE.l D0,actualfile
  TST.l (A1)
  BEQ.w JL_0_2EA6
  MOVEA.l (A1),A2
  MOVE.l D0,(A1)
  MOVE.l A1,$4(A0)
  MOVE.l A2,(A0)
  MOVE.l A0,$4(A2)
  JSR clear_sourcebuffer;JL_0_6B7C
  JSR JL_0_2Dca8
RTS

 JL_0_2EA6:
  MOVE.l D0,AL_0_84B2
  MOVE.l A1,$4(A0)
  MOVE.l A0,(A1)
  CLR.l (A0)
  JSR clear_sourcebuffer ; JL_0_6B7C
  JSR JL_0_2Dca8

  TST.w loadmode
  BNE 'no
    MOVEM.l d0-d7/a0-a6,-(a7)
    JSR menu_load
    JSR StoreXtraData
    JSR update_vertscroller
    MOVEM.l (a7)+,d0-d7/a0-a6

 'no
RTS


.StoreXtraData:                      ;copy view data
  ; this function is called after a succesfull load of a sourcecode and befor and after a switch of the sourcecode  tomsmart1
  MOVEM.l D0/A0-A1,-(A7)
  !basic
  MOVE.l LabelList_FirstVisableItemNumber@(a5),comLong_Label1VisableItem      ; same as Poke
  MOVE.l comLong_Label1VisableItem,comLong_Label1VisableItemStore             ; to update both for a unified LabelList restore routine that work by load and switch of a Sourcecode  tomsmart1
  !asm
  MOVEA.l actualfile,A0
  ADDQ.l #8,A0                       ; jump over list node header to xtra data
  LEA comLongLong_XtraBegin,A1
  MOVE.l #comDef_XtraEnd-comLongLong_XtraBegin,d0; #$504+72,D0
  ;MOVE.l #$504+72,D0
  SUBQ.w #1,D0

 'copyloop
    MOVE.b (A1)+,(A0)+
  DBF D0,'copyloop

  MOVEM.l (A7)+,D0/A0-A1
RTS


.GetXtraData:
  ; zurueckholen der xtra-settings nach sourcewechsel
  ADDQ.l #8,A0
  LEA comLongLong_XtraBegin,A1
  ;MOVE.l #$504+72,D0
  MOVE.l #comDef_XtraEnd-comLongLong_XtraBegin ,D0  ;MOVE.l #$504+72,D0
  SUBQ.w #1,D0

 'copyloop:
    MOVE.b (A0)+,(A1)+
  DBF D0,'copyloop

  !basic
  ; restore windows
  Gosub RestoreLabelAndNewtypeWin


;  If WZ_CheckOpen{"WIN_NEWTYPE"}
;
;    lev = 0
;    WZ_ClearTable{"TYPETABLE"}
;    cstr2$ = "blabla"
;  End If
  !asm
  MOVEA.l comPtr_CurrentSourceLine,A4
RTS


.selectfile:
  MOVE.l A0,-(A7)
  BSR.b StoreXtraData
  JSR save_tempprefs
  MOVEA.l (A7)+,A0
  MOVE.l A0,actualfile
  BSR.b GetXtraData
  JSR JL_0_2Dca8
  JSR read_tempprefs
  JSR update_statusline              ;JSR linetext
  JSR update_horizscroller
RTS


.menu_previousfile:
  BSR.b StoreXtraData
  JSR save_tempprefs
  MOVEA.l actualfile,A0
  TST.l $4(A0)
  BNE.w JL_0_2F38

  MOVEA.l AL_0_84B2,A0
  MOVE.l A0,D0
  CMP.l actualfile,D0
  BNE.w JL_0_2F3C
RTS

 JL_0_2F38:
  MOVEA.l $4(A0),A0

 JL_0_2F3C:
  MOVE.l A0,actualfile
  BSR.b GetXtraData
  JSR JL_0_2Dca8
  JSR read_tempprefs
  JSR update_statusline              ;JSR linetext
  JSR update_horizscroller
RTS


.menu_nextfile:
  JSR StoreXtraData
  JSR save_tempprefs
  MOVEA.l actualfile,A0
  TST.l (A0)
  BNE.w JL_0_2F72
  MOVEA.l loadedfilesbase,A0
  MOVE.l A0,D0
  CMP.l actualfile,D0
  BNE.w JL_0_2F74
RTS

 JL_0_2F72:
  MOVEA.l (A0),A0

 JL_0_2F74:
  MOVE.l A0,actualfile
  JSR GetXtraData
  JSR JL_0_2Dca8
  JSR read_tempprefs
  JSR update_statusline              ;JSR linetext
  JSR update_horizscroller
RTS


.menu_new:
  JSR show_newfilerequest
  TST.l D0
   BEQ.w JL_0_76E8c
  JSR clear_actualsource

  ; -- copy screentitle to windowtitle
  LEA str_screentitle,A0
  MOVEA.l str_windowtitle,A1

 JL_0_2FA0:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_2FA0
  JSR update_title_sourcewindow

  MOVE.l comFunc_ReadXtraFile,d0
  BEQ 'l10
  MOVE.l d0,a0
  CLR.l d0
  JSR (a0)

 'l10
  JMP clear_sourcebuffer;JL_0_6B7C

 JL_0_2FAC:
RTS

JL_0_76E8c
JMP JL_0_76E8


str_iffchunk_form:    Dc.b "FORM"
AL_0_2FD4:            Ds.l 1
str_iffchunk_ftxt:    Dc.b "FTXT"
str_iffchunk_chrs:    Dc.b "CHRS",0,0
                      Ds.w 9
Even


.menu_copy:
  MOVE.l #$464F524D,str_iffchunk_form
  MOVE.l #$46545854,str_iffchunk_ftxt
  MOVE.l #$43485253,str_iffchunk_chrs
  MOVEA.l _execbase,A6
  MOVEA.l ptr_iorequest_clipboard,A1
  MOVE.l #$0,$2C(A1)
  MOVE.b #$0,$1E(A1)
  MOVE.l #str_iffchunk_form,$28(A1)
  CLR.l $30(A1)
  MOVEA.l A1,A4
  MOVE.l #$14,$24(A1)
  MOVE.w #$0003,$1C(A1)
  JSR _DoIO(A6)
  MOVEM.l A2-A4,-(A7)
  MOVE.l comPtr_CurrentSourceLine,-(A7)
  JSR JL_0_3318
  MOVE.l (A7)+,comPtr_CurrentSourceLine
  MOVEA.l A0,A2
  MOVEQ.l #$00,D6
  TST.w D7
  BNE.w JL_0_3070
  JSR JL_0_30E0
BRA.w JL_0_3074

 JL_0_3070:
  JSR JL_0_319C

 JL_0_3074:
  BTST #0,d6
   BEQ 'no
  MOVEA.l A4,A1
  MOVE.l #AL_0_2FD4,$28(A1)
  CLR.l AL_0_2FD4
  MOVE.l #$1,$24(A1)
  MOVE.b #32,AL_0_2FD4
  MOVE.w #$0003,$1C(A1)
  JSR _DoIO(A6)

 'no
  MOVEA.l A4,A1
  MOVE.l D6,AL_0_2FD4
  MOVE.l #AL_0_2FD4,$28(A1)
  MOVE.l #$10,$2C(A1)
  MOVE.l #_execbase,$24(A1)
  MOVE.w #$0003,$1C(A1)
  JSR _DoIO(A6)
  MOVEA.l A4,A1
  ADDI.l #$C,D6
  BTST #0,d6
  BEQ 'ok
  ADDQ.l #1,d6

 'ok
  MOVE.l D6,AL_0_2FD4
  MOVE.l #_execbase,$24(A1)
  MOVE.l #_execbase,$2C(A1)
  MOVE.l #AL_0_2FD4,$28(A1)
  MOVE.w #$0003,$1C(A1)
  JSR _DoIO(A6)
  MOVEA.l A4,A1
  MOVE.w #$0004,$1C(A1)
  JSR _DoIO(A6)
  TST.b new_editmode
   BEQ 'l1
  TST.b cutmode
   BNE 'l1
  MOVEM.l d0-d7/a0-a6,-(a7)
;      CMP.b #2,d0
;      BNE 'l2
;     JSR arexxfunc_cut
;      MOVE.l comLong_BlockStartY,d0
;     JSR gotoline
;      MOVE.w comLong_BlockStartX,comWord_Column
;        MOVEA.l ptr_pedscreen,A0
;    MOVEA.l _intuibase,A6
;    JSR -$60(A6)
;    'l2

  MOVE.l #$ffffffff,comLong_BlockEndY        ;cursor off when do copy
  JSR cursor_off
  JSR _redraw
  MOVEM.l (a7)+,d0-d7/a0-a6

 'l1
  CLR.b cutmode
  MOVEM.l (A7)+,A2-A4
RTS

JL_0_30E0:                           ;write 1 line to clipboard
  MOVEA.l A4,A1
  LEA $9(A2),A3
  JSR JL_0_32E6

  CMP.w comLong_BlockEndX,D0
   BLT.w JL_0_3102
  MOVE.w comLong_BlockEndX,D0
  SUB.w comLong_BlockStartX,D0
  ADDQ.w #2,D0

 JL_0_3102:
  SUBQ.w #1,D0
  MOVE.l D0,$24(A1)
  ADD.l D0,D6
  ADDA.w comLong_BlockStartX,A3
  MOVEM.l a3/d0,-(a7)
  MOVEQ #0,d0

 'l
  TST.b (a3)+
  BEQ 'e
  ADDQ.l #1,d0
BRA 'l

 'e
  CMP.l d0,d6
   BLE 'l2
   MOVE.l d0,$24(a1)
   MOVE.l d0,d6

 'l2
  MOVEM.l (a7)+,a3/d0

  MOVE.l A3,$28(A1)
  MOVE.w #$0003,$1C(A1)
   JSR _DoIO(A6)
  MOVE.w comLong_BlockEndX,D0
  CMP.w #MAX_Columns-1,D0
  BNE.w JL_0_3152
  MOVEA.l A4,A1
  MOVE.l #AL_0_2FD4,$28(A1)
  CLR.l AL_0_2FD4
  ADDQ.l #1,D6
  MOVE.l #$1,$24(A1)

 'n3
  MOVE.b #$0A,AL_0_2FD4
  MOVE.w #$0003,$1C(A1)
  JSR _DoIO(A6)

 JL_0_3152:
;   BTST #0,d6
;   BEQ 'no
;   ADDQ.l #1,d6
;   MOVEA.l A4,A1
;   MOVE.l #AL_0_2FD4,$28(A1)
;   CLR.l AL_0_2FD4
;   MOVE.l #$1,$24(A1)
;   MOVE.b #32,AL_0_2FD4
;   MOVE.w #$0003,$1C(A1)
;   JSR _DoIO(A6)
; 'no
RTS

JL_0_3154:
  SF comByte_StateBlockMark
  TST.l comLong_BlockEndY
   BMI.w JL_0_319A
  CMP.l comLong_BlockStartY,D1
   BLT.w JL_0_319A
   BNE.w JL_0_317C
  CMP.w comLong_BlockStartX,D0
   BLT.w JL_0_319A

 JL_0_317C:
  CMP.l comLong_BlockEndY,D1
   BGT.w JL_0_319A
   BNE.w JL_0_3194
  CMP.w comLong_BlockEndX,D0
   BGT.w JL_0_319A

 JL_0_3194:
  ST comByte_StateBlockMark

 JL_0_319A:
RTS

JL_0_319C:                           ;copy lines to clipboard
  MOVE.w comLong_BlockStartX,firstcolumn+2
  MOVEA.l A4,A1
  LEA $9(A2),A3
   JSR JL_0_32E6
  CMP.w comLong_BlockStartX,D0
   BGT.w JL_0_31B4
BRA.w JL_0_31D6

 JL_0_31B4:
  ADDA.w comLong_BlockStartX,A3
  SUB.w comLong_BlockStartX,D0
  SUBQ.w #1,D0
  MOVE.l D0,$24(A1)
  MOVE.l A3,$28(A1)
  ADD.l D0,D6
  MOVE.w #$0003,$1C(A1)
   JSR _DoIO(A6)

 JL_0_31D6:
  MOVEA.l (A2),A2
  MOVEA.l A4,A1
  MOVE.l #AL_0_2FD4,$28(A1)
  MOVE.l #$1,$24(A1)
  MOVE.b #$A,AL_0_2FD4
  MOVE.w #$0003,$1C(A1)
   JSR _DoIO(A6)
  ADDQ.l #1,D6
  SUBQ.w #2,D7
   BMI.w JL_0_327A

 JL_0_3204:
    MOVEA.l A4,A1
    LEA $9(A2),A3
    JSR JL_0_32E6
    SUBQ.w #1,D0
    MOVE.l D0,$24(A1)
    MOVE.l A3,$28(A1)
    ADD.l D0,D6
    MOVE.w #$0003,$1C(A1)
    JSR _DoIO(A6)
    MOVEA.l A4,A1
    MOVE.l #AL_0_2FD4,$28(A1)
    MOVE.l #$1,$24(A1)
    MOVE.b #$A,AL_0_2FD4
    MOVE.w #$0003,$1C(A1)
    JSR _DoIO(A6)
    ADDQ.l #1,D6
    MOVEA.l (A2),A2
  DBF D7,JL_0_3204

BRA.w JL_0_327A

 JL_0_3254:
  MOVEA.l A4,A1
  MOVE.l #AL_0_2FD4,$28(A1)
  MOVE.l #$1,$24(A1)
  MOVE.b #$A,AL_0_2FD4
  MOVE.w #$0003,$1C(A1)
  JSR _DoIO(A6)
  ADDQ.l #1,D6

 JL_0_327A:
  MOVEA.l A4,A1
  LEA $9(A2),A3
   JSR JL_0_32E6
  CMPI.w #MAX_Columns-1,comLong_BlockEndX
   BEQ.w JL_0_32A8
  CMP.w comLong_BlockEndX,D0
   BGT.w JL_0_32A0
  xxl2b
    SUBQ.w #1,D0
BRA.w JL_0_32AA

 JL_0_32A0:
    MOVE.w comLong_BlockEndX,d1
    ADDQ.w #1,d1
    CMP.w d1,d0
  BEQ xxl2b

  MOVE.w comLong_BlockEndX,D0
  ADDQ.l #2,D0

 JL_0_32A8:
  SUBQ.l #1,D0

 JL_0_32AA:
  MOVE.l D0,$24(A1)
  MOVE.l A3,$28(A1)
  ADD.l D0,D6
  MOVE.w #$0003,$1C(A1)
  JSR _DoIO(A6)
  MOVEA.l A4,A1
  MOVE.l #AL_0_2FD4,$28(A1)
  MOVE.l #$1,$24(A1)
  MOVE.b #$A,AL_0_2FD4
  MOVE.w #$0003,$1C(A1)
  JSR _DoIO(A6)
  ADDQ.l #1,D6
RTS

JL_0_32E6:
  TST.w comWord_DoTokenize
   BEQ.w JL_0_3310
  MOVEM.l D1-D7/A0-A2/A4-A6,-(A7)
  MOVEQ.l #$00,D0
  MOVEA.l AL_0_5BA6,A1
  MOVEA.l A3,A0
  JSR detokenize_line
  MOVEA.l AL_0_5BA6,A3
  SUBA.l A3,A1
  MOVE.l A1,D0
  ADDQ.w #1,D0
  MOVEM.l (A7)+,D1-D7/A0-A2/A4-A6
  RTS

  JL_0_3310:
  MOVEQ.l #$00,D0
  MOVE.b $8(A2),D0
RTS

JL_0_3318:
  MOVEQ.l #$00,D7
  MOVE.l comLong_DisplayLine,D0
  ADD.l comLong_DisplayLineOffset,D0
  CMP.l comLong_BlockStartY,D0
   BLT.w JL_0_3348
   BGT.w JL_0_337C
  MOVEA.l comPtr_CurrentSourceLine,A0
  MOVE.l comLong_BlockEndY,D7
  SUB.l comLong_BlockStartY,D7
  RTS

  JL_0_3348:
  MOVE.l comLong_BlockStartY,D0
  SUB.l comLong_DisplayLine,D0
  SUB.l comLong_DisplayLineOffset,D0
  SUBQ.l #1,D0
  MOVEA.l comPtr_CurrentSourceLine,A0

  JL_0_3362:
  MOVEA.l (A0),A0
   DBF D0,JL_0_3362
  MOVE.l comLong_BlockEndY,D7
  SUB.l comLong_BlockStartY,D7
  MOVE.l A0,comPtr_CurrentSourceLine
  RTS

  JL_0_337C:
  SUB.l comLong_BlockStartY,D0
  SUBQ.w #1,D0
  MOVEA.l comPtr_CurrentSourceLine,A0

  JL_0_338A:
  MOVEA.l $4(A0),A0
   DBF D0,JL_0_338A
  MOVE.l comLong_BlockEndY,D7
  SUB.l comLong_BlockStartY,D7
  MOVE.l A0,comPtr_CurrentSourceLine
RTS


.menu_cut:
  MOVEM.l D0-D7/A0-A6,-(A7)
  MOVE.b #1,cutmode
  JSR menu_copy
  MOVEM.l (A7)+,D0-D7/A0-A6
  MOVE.l comPtr_CurrentSourceLine,a4
  JSR menu_kill
RTS

.menu_paste:
  ; -- read from clipboard
  MOVE.l A4,-(A7)
;  MOVEA.l _execbase,A6
;  MOVEA.l ptr_iorequest_clipboard,A1
;  MOVE.l #$0,$2C(A1)
;  MOVE.b #$0,$1E(A1)
;  MOVE.l #$0,$30(A1)
;  MOVEA.l A1,A4
;  MOVE.w #$0002,$1C(A1)
;  MOVE.l #$14,$24(A1)
;  MOVE.l #str_iffchunk_form,$28(A1)
;  JSR _DoIO(A6)
;  MOVEA.l A4,A1
;  MOVE.l $20(A1),D0
;  TST.l D0
;   BEQ.w exit_paste
;  LEA str_iffchunk_form,A0
;  CMPI.l #"FORM",(A0)
;   BNE.w JL_0_344A
;  CMPI.l #"FTXT",$8(A0)
;   BNE.w JL_0_344A
;  CMPI.l #"CHRS",$c(A0)
;   BEQ.w 's1
;  CMP.l #"COLS",$c(a0)
;  BNE 'c1
;  MOVEA.l A4,A1
;  MOVE.w #$0002,$1C(A1)
;  MOVE.l #$4,$24(A1)
;  MOVE.l #str_iffchunk_form,$28(A1)
;  JSR _DoIO(A6)
; 'c1
;  MOVEA.l A4,A1
;  MOVE.w #$0002,$1C(A1)
;  MOVE.l #$8,$24(A1)
;  MOVE.l #str_iffchunk_form,$28(A1)
;  JSR _DoIO(A6)
;  LEA str_iffchunk_form,A0
;  CMP.l #"STYL",(a0)
;   BEQ 'c1
;  CMPI.l #"CHRS",(A0)
;   BNE.w JL_0_344A
; 's1

  MOVE.w #$FFFF,comWord_PasteMode
  JSR JL_0_3748
  MOVE.w #$0000,comWord_PasteMode

;  MOVEA.l ptr_iorequest_clipboard,A4
;  TST.l $20(A4)
;   BEQ.w exit_paste
;  JL_0_344A:
;  MOVEA.l A4,A1
;  MOVE.w #$0002,$1C(A1)
;  MOVE.l #$14,$24(A1)
;  MOVE.l #str_iffchunk_form,$28(A1)
;  JSR _DoIO(A6)
;  MOVEA.l A4,A1
;  MOVE.l $20(A1),D0
;  TST.l D0
;   BNE.b JL_0_344A

  exit_paste:
  MOVEA.l (A7)+,A4
RTS


.menu_kill:
  CMPI.l #$ffffFFFF,comLong_BlockEndY        ;cut block
   BEQ.w setpointer_to_normal
  CLR.w comWord__AL_0_8AD8
  MOVE.w #$FFFF,comWord_SourceChanged
  JSR JL_0_5524
  MOVEQ.l #$00,D5
  MOVEA.l comPtr_Temp_TokenString2,A0

  JL_0_3498:
  CMP.w comLong_BlockStartX,D5
   BCC.w JL_0_34A8
  JSR JL_0_5650
  MOVE.b D0,(A0)+
  BRA.b JL_0_3498

  JL_0_34A8:
  MOVE.l A0,-(A7)

  JL_0_34AA:
    CMP.l comLong_BlockEndY,D6
     BCC.w JL_0_34BE
    MOVE.l (A5),-(A7)
    JSR JL_0_5474
    MOVEA.l (A7)+,A5

    ADDQ.l #1,D6
  BRA.b JL_0_34AA
  JL_0_34BE:

  CMP.l comLong_BlockStartY,D6
   BEQ.w JL_0_34CA
  JSR JL_0_553A
  JL_0_34CA:

  MOVEA.l (A7)+,A0
  MOVE.w comLong_BlockEndX,D5
  JL_0_34D0:
    ADDQ.w #1,D5
    CMP.w comWord_MaxColumns,D5
     BCC.w JL_0_34E4
    JSR JL_0_5650
    SUBQ.w #1,D5
    MOVE.b D0,(A0)+
  BRA.b JL_0_34D0
  JL_0_34E4:
    CMPA.l comPtr_Temp_TokenString3,A0
     BCC.w JL_0_34F2
    MOVE.b #$20,(A0)+
  BRA.b JL_0_34E4
  JL_0_34F2:

  MOVE.w comLong_BlockStartX,D0
   BNE.w JL_0_3510
  MOVE.w comLong_BlockEndX,D0
  ADDQ.w #1,D0
  CMP.w comWord_MaxColumns,D0
   BCS.w JL_0_3510
  JSR JL_0_5474
  BRA.w JL_0_351C

  JL_0_3510:
  MOVEA.l A5,A4
  MOVE.l A4,comPtr_CurrentSourceLine
  JSR JL_0_55A2

  JL_0_351C:
  JSR JL_0_572C
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  CMP.l comLong_TotalLines,D0
  BCS.w JL_0_3552
  MOVE.l comLong_TotalLines,D0
  SUBQ.l #1,D0
  MOVE.l D0,comLong_DisplayLineOffset
  CLR.l comLong_DisplayLine
  JSR update_currsourceline
  JSR _redraw
  MOVE.l comLong_DisplayLineOffset,D0
  BRA.w gotoline

  JL_0_3552:
  JSR update_currsourceline
JMP _redraw



str_title_ascreq: Dc.b "Select file to save as ASCII...",0
ptr_asciifile:    Ds.l 1

.saveab2
  MOVE.l a2,-(a7)
BRA saveab

.menu_saveascii:
  MOVE.l A2,-(A7)
  LEA str_title_ascreq,A2
  JSR get_filename
  TST.l D0
   BEQ.w saveascii_exit

  saveab:
  MOVE.l D0,-(a7)
  ;!basic
  ;WZ_ShowMessage{!TRANS{"Exporting source code as ASCII file..."}}
  ;!asm
  JSR set_pointerbusy
  MOVE.l (a7)+,D0

  MOVEA.l _dosbase,A6                ;d0 = filename
  MOVE.l D0,D1
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  JSR _Open(A6)
  TST.l D0
   BEQ.w saveascii_writeerror

  MOVE.l D0,ptr_asciifile
  MOVEQ.l #$00,D7
  MOVE.l comLong_TotalLines,D7
   BEQ.w saveascii_done

  MOVE.b #$A,comByte_EnteredCharacter
  MOVEA.l comPtr_FirstSourceLine,A2
  TST.w comWord_DoTokenize
   BEQ.w JL_0_3608
   BRA saveascii_writeline_fast

  saveascii_writeline:               ;-- detokenize and write to file
    LEA $9(A2),A0
    MOVEA.l comPtr_Temp_TokenString2,A1
    JSR detokenize_line
    MOVE.b #$A,(A1)
    ADDQ.w #1,A1
    MOVE.l ptr_asciifile,D1
    MOVE.l comPtr_Temp_TokenString2,D2
    SUBA.l D2,A1
    MOVE.l A1,D3
    JSR _Write(A6)
    MOVEA.l (A2),A2
    SUBQ.l #1,d7
  BNE saveascii_writeline
  BRA.w saveascii_done

  saveascii_writeline_fast:          ;-- detokenize and write to file
    MOVE.l A2,saveascii_node
    MOVE.l D7,saveascii_lines

    !basic
    node.l     = Peek.l(?saveascii_node)
    numlines.l = Peek.l(?saveascii_lines)
    fp.l       = Peek.l(?ptr_asciifile)

    totalLength.l = 0

    For n.l=0 To numlines-1
      baseptr.l = node+$9 ;Peek.l (node+$9)
      sptr.l = baseptr
      While Peek.b(sptr) : sptr+1 : Wend
      totalLength + sptr-baseptr+1
      node = Peek.l(node)
    Next

    tmp.l      = AllocVec_(totalLength,#MEMF_CLEAR)
    If tmp
      node.l     = Peek.l(?saveascii_node)
      dptr.l     = tmp
      For n.l=0 To numlines-1
        baseptr.l = node+$9 ;Peek.l (node+$9)
        sptr.l    = baseptr
        Repeat
           char.b = Peek.b(sptr)
           Poke.b dptr,char : sptr +1 : dptr+1
        Until char=0
        node = Peek.l(node)
      Next

      plainLength.l = preproc_DetokenizeFP{*PreProcessor,tmp,totalLength,fp}
      FreeVec_ tmp
    Else
      error{!TRANS{"Not enough memory for temp buffer!"}}
    End If
    Close_ fp
    !asm
    MOVE.l #0,d7

  BRA saveascii_exit
  saveascii_node:  Dc.l 0
  saveascii_lines: Dc.l 0



  JL_0_3608:                         ;-- directly write to file
    LEA $9(A2),A0
    MOVEQ.l #$00,D3
    MOVE.b $8(A2),D3
    SUBQ.w #1,D3
    MOVE.l ptr_asciifile,D1
    MOVE.l A0,D2
    JSR _Write(A6)
    MOVE.l #comByte_EnteredCharacter,D2
    MOVE.l ptr_asciifile,D1
    MOVEQ.l #$01,D3
    JSR _Write(A6)
    MOVEA.l (A2),A2
    SUBQ.l #1,d7
    BNE JL_0_3608
  DBF D7,JL_0_3608

  saveascii_done:
  MOVE.l ptr_asciifile,D1
  JSR _Close(A6)

  saveascii_exit:
  JSR set_pointernormal
  ;!basic
  ;WZ_HideMessage{}
  ;!asm
  MOVEA.l (A7)+,A2
RTS

.saveascii_writeerror:
  JSR set_pointernormal
  !basic
  WZ_HideMessage{}
  !asm
  MOVEA.l (A7)+,A2
  LEA comStr_ErrorWriteFile,A0
JMP show_errorrequester






.kill_or_save_block:
  ; -- check if L-SHIFT is pressed
  MOVE.w comWord_QualifierStore,D0
  ANDI.w #$3,D0
  ; -- if not, then save the block
  BEQ.b menu_saveblockas
  ; -- else kill the block
  JSR menu_kill
JMP update_vertscroller

.menu_saveblockas:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w setpointer_to_normal
  LEA comStr_ASLSaveBlock,A2
  JSR get_filename
  TST.l D0
  BEQ.w JL_0_3732
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVE.b #1,menuload
  JSR open_sourcefile
  MOVE.l D7,-(A7)
  MOVEA.l comPtr_CurrentSourceLine,A4
  JSR JL_0_5524
  MOVE.l (A7)+,D7
  MOVE.w #$FFFF,comWord__AL_0_8AD8

  JL_0_36A2:
      JSR JL_0_5630
      BMI.w JL_0_372E
      BEQ.w JL_0_36C4
      MOVE.b D0,comLong_LinePosStartX
      MOVE.l D7,D1
      MOVE.l #comLong_LinePosStartX,D2
      MOVEQ.l #$01,D3
      JSR _Write(A6)
    BRA.b JL_0_36A2

    JL_0_36C4:
    MOVE.b #$A,comLong_LinePosStartX
    MOVE.l D7,D1
    MOVE.l #comLong_LinePosStartX,D2
    MOVEQ.l #$01,D3
    JSR _Write(A6)
    MOVEQ.l #$00,D5

    JL_0_36Dca:
    CMP.l comLong_BlockEndY,D6
     BCS.w JL_0_36F4
    MOVE.w comWord_DoTokenize,D0
     BEQ.b JL_0_36A2
     JSR JL_0_553A
    MOVEQ.l #$00,D5
  BRA.b JL_0_36A2

  JL_0_36F4:
  JSR JL_0_553A
  MOVE.l D7,D1
  MOVEA.l comPtr_Temp_TokenString3,A0
  MOVEQ.l #$00,D3
  MOVE.b (A0),D3
  MOVE.b #$A,$0(A0,D3.W)
  ADDQ.w #1,A0
  MOVE.l A0,D2
  MOVE.l D7,D1
  JSR _Write(A6)
  TST.l D0
  BPL.w JL_0_3728
  SUBA.l A0,A0
  MOVEA.l #comStr_ErrorWriteFile,A0
  JSR show_errorrequester
  BRA.w JL_0_372E

  JL_0_3728:
  MOVEA.l (A5),A5
  ADDQ.l #1,D6
  BRA.b JL_0_36Dca

  JL_0_372E:
  BRA.w JL_0_4E4Ab

  JL_0_3732:
RTS

.menu_includeblock:
  CLR.w comWord__AL_0_8AD8
  LEA comStr_ASLLoadBlock,A2
  JSR get_filename
  TST.l D0
  BNE.b JL_0_3748
RTS

JL_0_4E4Ab
;JMP JL_0_4E4A
JMP close_sourcefile


JL_0_3748:
  MOVEA.l comPtr_CurrentSourceLine,A4
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
  CLR.b menuload
  JSR open_sourcefile
  JSR source_readin
  BEQ.w JL_0_4E4Ab
  MOVE.w #$FFFF,comWord_LabelListChanged
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVEA.l A2,A0
  ADDA.w comWord_MaxColumns,A0
  MOVE.l A0,comLong_LinePosStartX
  MOVE.w comWord_ColumnsOffset,D1
  ADD.w comWord_Column,D1
  MOVEA.l comPtr_Temp_TokenString1,A3
  MOVEQ.l #$00,D4
  CLR.b instring

  JL_0_3790:
    CMP.w D1,D4
    BCC.w JL_0_37A2
    MOVE.b (A2)+,D0
    CMP.b #$22,d0
    BNE 'l1
    NOT.b instring
   'l1
    TST.b instring
    BNE 'l2
    BCLR #$7,D0                      ;paste mix line
   'l2
    MOVE.b D0,(A3)+
    ADDQ.w #1,D4
  BRA.b JL_0_3790

  JL_0_37A2:
  MOVE.l A2,-(A7)
  CLR.w pastecolumn
;  MOVE.l a5,-(a7)
;'x2  MOVE.b (a5)+,d0
;  BEQ 'x1
;  CMP.b #$a,d0
;  BNE 'x2
;  CMP.b #$a,d0
;  BEQ 'x1
;  MOVE.w #1,pastecolumn
;  MOVE.l (a7)+,a5
;  BRA 'x3
;'x1  MOVE.l (a7)+,a5
  MOVEQ #0,d0
 'l1
  ADDQ.l #1,d0
  SUBQ.w #1,d6
 ;CMP.b #32,(a5)+
  ;BEQ 'l1
  SUBQ.l #1,d0
  ADDQ.w #1,d6
  MOVE.w d0,pastecolumn
  ;MOVE.l (a7)+,a5
  ;SUBQ.l #1,a5
 'x3
  MOVE.l comPtr_Temp_TokenString2,tempstore
  JSR JL_0_4F5A
  BEQ.w JL_0_37DE
  JSR JL_0_4E36
  JSR JL_0_5596
  CLR.b skipit

  JL_0_37B4:
  MOVEA.l comPtr_Temp_TokenString2,A0

 'n10
  TST.w pastecolumn
  BEQ 'l1a
  MOVE.w pastecolumn,d0
  BRA 'nc
 'l1a
  MOVE.l firstcolumn,d0
  BEQ 'w1
  ADDQ.l #2,d0
 'l1
  SUBQ.l #1,d0
  BEQ 'f1
  SUBQ.w #1,d6
  CMP.b #32,(a5)+                    ;paste at column
  BEQ 'l1
 'f1
  ADDQ.w #1,d6
  SUBQ.l #1,a5
 'w1
  MOVE.w comWord_Column,d0
  ADD.w comWord_ColumnsOffset,D0
  BEQ 'nc
 'w2
  CMP.w #MAX_Columns-10,d0
  BLE 'l1b
  MOVE.w #MAX_Columns-10,d0
 'l1b
    MOVE.b #32,(a0)+
    SUBQ.w #1,d0
  BNE 'l1b
 'nc
  MOVE.l a0,tempstore

  JSR JL_0_4F5A
  TST.w d0
  BMI.w JL_0_37CA
  ;BEQ.w JL_0_37F6
  JSR JL_0_4F1A
  JSR JL_0_4E08
  BRA.b JL_0_37B4

  JL_0_37CA:
  JSR allocnewline
  BEQ.w JL_0_4942
  JSR JL_0_4E08
  MOVEA.l comPtr_Temp_TokenString1,A3
  BRA.w JL_0_37F6

  JL_0_37DE:
  JSR JL_0_4E36
  BRA.w JL_0_37F6

  JL_0_37E6:
  JSR JL_0_4F1A
  JSR JL_0_4E08
  MOVEA.l comPtr_Temp_TokenString1,A3
  JSR JL_0_4E36

  JL_0_37F6:
   ;JSR JL_0_4E4A
   JSR close_sourcefile
  MOVEA.l (A7)+,A2
  CLR.b instring

  JL_0_37FC:
    CMPA.l comLong_LinePosStartX,A2
     BCC.w JL_0_3816
    CMPA.l comPtr_Temp_TokenString2,A3
     BCC.w JL_0_3816
    MOVE.b (A2)+,D0
    ;MOVE.b #44,d0
      ;BCLR #$7,D0                    ;morechar ?????????
   'l2
    MOVE.b D0,(A3)+
  BRA.b JL_0_37FC

  JL_0_3816:
  MOVEA.l comPtr_Temp_TokenString1,A2
  JSR parse_line
  JSR JL_0_55AA
  JSR update_currsourceline
  JSR JL_0_572C
BRA.w _redrawb
JL_0_382E:
RTS


.menu_dublicate:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w setpointer_to_normal
  CLR.w comWord__AL_0_8AD8
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVE.l comLong_DisplayLineOffset,D7
  ADD.l comLong_DisplayLine,D7
  CMP.l comLong_BlockStartY,D7
   BCS.w JL_0_387E
   BNE.w JL_0_386A
   JSR JL_0_79CC
   BNE.w JL_0_386A
 BRA.w JL_0_387E

JL_0_386A:
  CMP.l comLong_BlockEndY,D7
   BHI.w JL_0_387E
   BNE.w setpointer_to_normal
   JSR JL_0_79F0
   BEQ.w setpointer_to_normal
JL_0_387E:
   JSR JL_0_5524
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVEA.l A2,A1
  MOVE.w comWord_ColumnsOffset,D2
  ADD.w comWord_Column,D2
  MOVEQ.l #$00,D1
  MOVEA.l comPtr_Temp_TokenString2,A0
JL_0_389A:
  CMP.w D2,D1
   BCC.w JL_0_38AC
  MOVE.b (A1)+,D0
  ANDI.b #$7F,D0
  MOVE.b D0,(A0)+
  ADDQ.w #1,D1
 BRA.b JL_0_389A

JL_0_38AC:
  MOVEM.l D1/A1,-(A7)
JL_0_38B0:
   JSR JL_0_5630
   BMI.w JL_0_3982
   BEQ.w JL_0_38C8
  CMP.w comWord_MaxColumns,D1
   BCC.b JL_0_38B0
  MOVE.b D0,(A0)+
  ADDQ.w #1,D1
 BRA.b JL_0_38B0

JL_0_38C8:
  CMP.w comWord_MaxColumns,D1
   BCC.w JL_0_38D8
  MOVE.b #$20,(A0)+
  ADDQ.w #1,D1
 BRA.b JL_0_38C8

JL_0_38D8:
  MOVEA.l comPtr_Temp_TokenString2,A2
   JSR parse_line
  MOVE.l D5,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  ADDI.w #$9,D0
   JSR JL_0_492E
  MOVEA.l D0,A0
  LEA $9(A0),A0
  MOVEA.l comPtr_Temp_TokenString1,A1
JL_0_38FA:
  MOVE.b (A1)+,(A0)+
   BNE.b JL_0_38FA
  MOVEA.l D0,A0
JL_0_3900:
  ADDQ.l #1,comLong_TotalLines
  MOVE.b D5,$8(A0)
  MOVE.l $4(A4),D1
   BNE.w JL_0_3920
  MOVE.l A0,comPtr_FirstSourceLine
  CLR.l $4(A0)
 BRA.w JL_0_3928

JL_0_3920:
  MOVEA.l D1,A1
  MOVE.l A0,(A1)
  MOVE.l A1,$4(A0)
JL_0_3928:
  MOVE.l A0,$4(A4)
  MOVE.l A4,(A0)
  CMP.l comLong_BlockEndY,D6
   BCC.w JL_0_3968
  MOVEQ.l #$00,D0
  MOVE.b $8(A5),D0
  MOVE.w D0,D5
  ADDI.w #$9,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
   JSR JL_0_492E
  MOVEA.l D0,A0
  MOVEM.l A0/A5,-(A7)
  LEA $9(A0),A0
  LEA $9(A5),A5
JL_0_395A:
  MOVE.b (A5)+,(A0)+
   BNE.b JL_0_395A
  MOVEM.l (A7)+,A0/A5
  ADDQ.l #1,D6
  MOVEA.l (A5),A5
 BRA.b JL_0_3900

JL_0_3968:
  MOVE.w comWord_DoTokenize,D0
   BEQ.w JL_0_3976
   JSR JL_0_553A
JL_0_3976:
  MOVEA.l comPtr_Temp_TokenString2,A0
  MOVEQ.l #$00,D5
  MOVEQ.l #$00,D1
 BRA.w JL_0_38B0

JL_0_3982:
  MOVEM.l (A7)+,D1/A1
JL_0_3986:
  CMP.w comWord_MaxColumns,D1
   BCC.w JL_0_399A
  MOVE.b (A1)+,D0
  ANDI.b #$7F,D0
  MOVE.b D0,(A0)+
  ADDQ.w #1,D1
 BRA.b JL_0_3986

JL_0_399A:
  CMPA.l comPtr_Temp_TokenString3,A0
   BCC.w JL_0_39A8
  MOVE.b #$20,(A0)+
 BRA.b JL_0_399A

JL_0_39A8:
   JSR JL_0_55A2
  MOVE.w comWord_ColumnsOffset,D0
  ADD.w comWord_Column,D0
  MOVE.l comLong_DisplayLineOffset,D7
  ADD.l comLong_DisplayLine,D7
  CMP.l comLong_BlockEndY,D7
   BHI.w JL_0_3A42
   BNE.w JL_0_39D0
  CMP.w comLong_BlockEndX,D0
   BHI.w JL_0_3A42
JL_0_39D0:
  MOVE.l comLong_BlockEndY,D1
  SUB.l comLong_BlockStartY,D1
  MOVE.w comLong_BlockEndX,D2
  ADDQ.w #1,D2
  CMP.w comWord_MaxColumns,D2
   BCS.w JL_0_39FA
  ADDQ.l #1,D1
  CMP.l comLong_BlockStartY,D7
   BCS.w JL_0_3A36
  SUB.w D0,comLong_BlockStartX
 BRA.w JL_0_3A36

JL_0_39FA:
  CMP.l comLong_BlockStartY,D7
   BCS.w JL_0_3A36
  CMP.l comLong_BlockEndY,D7
   BEQ.w JL_0_3A1C
  MOVE.w comLong_BlockEndX,D2
  SUB.w D0,D2
  ADDQ.w #1,D2
  ADD.w D2,comLong_BlockStartX
 BRA.w JL_0_3A32

JL_0_3A1C:
  MOVE.w comLong_BlockEndX,D2
  SUB.w comLong_BlockStartX,D2
  ADDQ.w #1,D2
  ADD.w D2,comLong_BlockStartX
  ADD.w D2,comLong_BlockEndX

  JL_0_3A32:
  JSR JL_0_7A14

  JL_0_3A36:
  ADD.l D1,comLong_BlockStartY
  ADD.l D1,comLong_BlockEndY
  JL_0_3A42:
  JSR update_currsourceline
BRA.w _redrawb

.menu_forget:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w setpointer_to_normal
  JSR JL_0_572C
BRA.w _redrawb


;AJL_0_3A5E:                          ; mit maus in source-liste unten geklickt
;  MOVE.w visiblecolumns,D0
;  ADDQ.w #2,D0
;  CMP.w D0,D2
;    BCS.w JL_0_3A9A
;  CMP.w comWord_LabelCounter,D3
;    BCC.w JL_0_3A9A
;  LEA comPtr_LabelList,A0
;
;  JL_0_3A76:
;    MOVEA.l (A0),A0
;  DBF D3,JL_0_3A76

.jump_to_keyword:                    ; A0 = pointer zieltextzeile
  MOVEA.l comPtr_FirstSourceLine,A1
  MOVEQ.l #$00,D0
  MOVE.l comLong_TotalLines,D1
  SUBQ.l #1,D1
  BEQ JL_0_3A9A

  JL_0_3A88:
    CMPA.l $4(A0),A1
    ;BEQ.w sub_gotoline
    BNE.w 'l10
    ADDQ.l #1,d0
    JMP jumpline

   'l10
    MOVEA.l (A1),A1
    ADDQ.l #1,D0
    SUBQ.l #1,d1
  BNE JL_0_3A88
  MOVEQ.l #-$01,D0

  JL_0_3A9A:
RTS



.event_leftmousebutton:              ;leftmouse
  JSR get_mousepos
  BMI.w exit_leftmousebutton         ; ausserhalb source- und statusareabereich

;  CMP.w visiblecolumns,D2           ; ausserhalb der darstellbaren Spalten
;   BCC.b AJL_0_3A5E

  MOVE.l D3,D1                       ; ab hier: blockmarkieren bis loslassen
  ADD.l comLong_DisplayLineOffset,D1
  CMP.l comLong_TotalLines,D1
   BCC.w exit_leftmousebutton

  ;MOVE.l comLong_BlockStartX,-(A7)
  MOVE.w comLong_BlockStartX,-(a7)
  MOVE.l comLong_BlockStartY,-(a7)

    ;MOVE.l comLong_BlockEndX,-(A7)
  MOVE.w comLong_BlockEndX,-(a7)
  MOVE.l comLong_BlockEndY,-(a7)
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w JL_0_3ADC
   JSR JL_0_572C
  MOVEM.l D2-D3,-(A7)
  JSR _redraw
  MOVEM.l (A7)+,D2-D3

  JL_0_3ADC:
  MOVE.l D3,D1
  ADD.l comLong_DisplayLineOffset,D1
  MOVE.l D1,comLong_LinePosStartY
  MOVE.l D1,comLong_LinePosEndY
  ADD.w comWord_ColumnsOffset,D2
  MOVE.w D2,comLong_LinePosStartX
  MOVE.w D2,comWord_LinePosEndX
   JSR JL_0_57F2
  MOVE.w D2,D5
  MOVE.l D3,D6
  MOVE.w D2,D0
  MOVE.l D3,D1
  CLR.w comWord__AL_0_86B8
  MOVE.l comLong_DisplayLineOffset,-(A7)
  MOVE.w comWord_ColumnsOffset,-(A7)
  MOVE.l A4,-(A7)
  JSR JL_0_59BC

  JL_0_3B1E:
  JSR check_events
  CMP.w #-$4,D7
   BEQ.w JL_0_3DD0
  JSR get_mousepos                   ;mark block loop
                                     ;comLong_LinePosStartY = startline
                                     ;comLong_LinePosEndY = endline
   BPL.w JL_0_3C38                   ;ok
  CMP.w win_TopEdge,D1
   BCS.w JL_0_3BCE
  MOVE.l viewablelines,D3
  MOVE.l D3,D0
  ADD.l comLong_DisplayLineOffset,D0
  CMP.l comLong_TotalLines,D0
   BCC.b JL_0_3B1E
  SUBQ.l #1,D3
  MOVE.w comWord_MaxColumns,D2
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l viewablelines,D0
  CMP.l comLong_TotalLines,D0
   BCC.w JL_0_3D06
  MOVEM.l D5-D6,-(A7)
   JSR source_fullscroll_down
  MOVEA.l (A4),A4
  MOVE.l A4,comPtr_CurrentSourceLine
  ADDQ.l #1,comLong_DisplayLineOffset
   JSR JL_0_5B60
  MOVEM.l (A7)+,D5-D6
  SUBQ.w #1,D6
  MOVE.w comWord_MaxColumns,D2
  MOVE.l viewablelines,D3
  SUBQ.l #1,D3
  MOVE.l D3,D1
  ADD.l comLong_DisplayLineOffset,D1
  CMP.l comLong_LinePosStartY,D1
   BHI.w JL_0_3D06
  MOVE.l D1,-(A7)
  MOVE.w D5,D2
  MOVE.w D6,D3
  MOVE.w comWord_MaxColumns,D0
  MOVE.l viewablelines,D1
  SUBQ.l #2,D1
   JSR JL_0_59BC
  MOVE.w comWord_MaxColumns,D5
  MOVE.l viewablelines,D6
  SUBQ.l #1,D6
  MOVE.l D6,D3
  MOVEQ.l #-$01,D2
  MOVE.l (A7)+,D1
  CMP.l comLong_LinePosStartY,D1
   BNE.w JL_0_3D06
  MOVE.w comLong_LinePosStartX,D5
  ADDQ.w #1,D5
  BRA.w JL_0_3D06

  JL_0_3BCE:
  MOVEQ.l #$00,D2
  MOVEQ.l #$00,D3
  MOVE.l comLong_DisplayLineOffset,D0
   BEQ.w JL_0_3D06
  MOVEM.l D5-D6,-(A7)
   JSR source_fullscroll_up
  MOVEA.l $4(A4),A4
  MOVE.l A4,comPtr_CurrentSourceLine
  SUBQ.l #1,comLong_DisplayLineOffset
   JSR JL_0_5B24
  MOVEM.l (A7)+,D5-D6
  ADDQ.w #1,D6
  MOVEQ.l #$00,D3
  MOVEQ.l #$00,D2
  MOVE.l comLong_DisplayLineOffset,D1
  CMP.l comLong_LinePosStartY,D1
   BCS.w JL_0_3D06
  MOVE.w D5,D2
  MOVE.w D6,D3
  MOVEQ.l #$00,D0
  MOVEQ.l #$01,D1
   JSR JL_0_59BC
  MOVE.w comWord_MaxColumns,D2
  MOVEQ.l #$00,D3
  MOVEQ.l #-$01,D5
  MOVEQ.l #$00,D6
  MOVE.l comLong_DisplayLineOffset,D1
  CMP.l comLong_LinePosStartY,D1
   BNE.w JL_0_3D06
  MOVE.w comLong_LinePosStartX,D5
  SUBQ.w #1,D5
  BRA.w JL_0_3D06

  JL_0_3C38:
  ADD.w comWord_ColumnsOffset,D2
  MOVE.l D3,D1
  ADD.l comLong_DisplayLineOffset,D1
  CMP.l comLong_TotalLines,D1
   BCS.w JL_0_3C54
  MOVE.l comLong_TotalLines,D3
  SUB.l comLong_DisplayLineOffset,D3
  SUBQ.l #1,D3

  JL_0_3C54:
  TST.w D0
   BNE.w JL_0_3CA6                   ;ok
  SUBQ.w #1,D2
  MOVE.w comWord_ColumnsOffset,D0
   BEQ.w JL_0_3D06
  SUBQ.w #1,D2
  MOVEM.w D2-D3/D5-D6,-(A7)
  MOVE.w D5,comWord_LinePosEndX
  EXT.l d6
  MOVE.l D6,D1
  ADD.l comLong_DisplayLineOffset,D1
  MOVE.l D1,comLong_LinePosEndY
  MOVE.w comLong_LinePosStartX,comLong_BlockStartX
  MOVE.l comLong_LinePosStartY,comLong_BlockStartY
  ;MOVE.l comLong_LinePosStartX,comLong_BlockStartX
  MOVE.w comWord_LinePosEndX,comLong_BlockEndX
  MOVE.l comLong_LinePosEndY,comLong_BlockEndY
  ;MOVE.l comWord_LinePosEndX,comLong_BlockEndX
   JSR JL_0_5836
  SUBQ.w #2,comWord_ColumnsOffset
   JSR scroll_right
   JSR JL_0_572C
  MOVEM.w (A7)+,D2-D3/D5-D6
  BRA.w JL_0_3D06

  JL_0_3CA6:
  MOVE.w D2,D0
  SUB.w comWord_ColumnsOffset,D0
  CMP.w visiblecolumns,D0
   BCS.w JL_0_3D06
  MOVE.w comWord_ColumnsOffset,D2
  ADD.w visiblecolumns,D2
  CMP.w comWord_MaxColumns,D2
   BCC.w JL_0_3D06
  ADDQ.w #1,D2
  MOVEM.l D2-D3/D5-D6,-(A7)
  MOVE.w D5,comWord_LinePosEndX
  MOVE.l D6,D1
  ADD.l comLong_DisplayLineOffset,D1
  MOVE.l D1,comLong_LinePosEndY
  MOVE.w comLong_LinePosStartX,comLong_BlockStartX
  MOVE.l comLong_LinePosStartY,comLong_BlockStartY
  ;MOVE.l comLong_LinePosStartX,comLong_BlockStartX
  MOVE.w comWord_LinePosEndX,comLong_BlockEndX
  MOVE.l comLong_LinePosEndY,comLong_BlockEndY
  ;MOVE.l comWord_LinePosEndX,comLong_BlockEndX
   JSR JL_0_5836
  ADDQ.w #2,comWord_ColumnsOffset
   JSR scroll_left
   JSR JL_0_572C
  MOVEM.l (A7)+,D2-D3/D5-D6
  BRA.w JL_0_3D06

  JL_0_3D06:
  CMP.w D5,D2
   BNE.w JL_0_3D12
  CMP.w D6,D3
   BEQ.w JL_0_3B1E

  JL_0_3D12:
   JSR JL_0_57F2
  MOVE.w D2,comWord_LinePosEndX
  MOVE.l D3,D1
  ADD.l comLong_DisplayLineOffset,D1
  MOVE.l D1,comLong_LinePosEndY
  CMP.l comLong_LinePosStartY,D1
   BCS.w JL_0_3D5A
   BNE.w JL_0_3D3C
  CMP.w comLong_LinePosStartX,D2
   BLT.w JL_0_3D5A

  JL_0_3D3C:
  MOVE.w comWord__AL_0_86B8,D4
   BNE.w JL_0_3D78
  MOVE.w D5,D0
  MOVE.l D6,D1
  MOVE.w D2,D5
  MOVE.w D3,D6
   JSR JL_0_5874
  ADDQ.w #1,D0
   JSR JL_0_59C0
  BRA.w JL_0_3B1E

  JL_0_3D5A:
  MOVE.w comWord__AL_0_86B8,D4
   BEQ.w JL_0_3D78
  MOVE.w D5,D0
  MOVE.l D6,D1
  MOVE.w D2,D5
  MOVE.w D3,D6
   JSR JL_0_5874
  SUBQ.w #1,D2
   JSR JL_0_59C0
  BRA.w JL_0_3B1E

  JL_0_3D78:
  NOT.w comWord__AL_0_86B8
  MOVEM.w D2-D3,-(A7)
  MOVE.w D5,D2
  MOVE.w D6,D3
  MOVE.w comLong_LinePosStartX,D0
  MOVE.l comLong_LinePosStartY,D1
  SUB.l comLong_DisplayLineOffset,D1
  BPL.w JL_0_3D9E
  MOVEQ.l #$00,D0
  MOVEQ.l #$00,D1
  BRA.w JL_0_3DB2

  JL_0_3D9E:
  CMP.l viewablelines,D1
   BCS.w JL_0_3DB2
  MOVE.l viewablelines,D1
  SUBQ.l #1,D1
  MOVE.w comWord_MaxColumns,D0
  SUBQ.w #1,D0

  JL_0_3DB2:
  MOVEM.w D0-D1,-(A7)

  JSR JL_0_59BC
  MOVEM.w (A7)+,D0-D1
  MOVEM.w (A7)+,D2-D3
  MOVE.w D2,D5
  MOVE.w D3,D6
  JSR JL_0_59BC
  BRA.w JL_0_3B1E

  exit_leftmousebutton:
RTS


JL_0_3DD0:
  MOVE.l comLong_DisplayLineOffset,comLong_DisplayLineOffsetStore
  MOVE.w comWord_ColumnsOffset,ColumnsOffsetStore
  MOVE.l (A7)+,comPtr_CurrentSourceLine
  MOVE.w (A7)+,comWord_ColumnsOffset
  MOVE.l (A7)+,comLong_DisplayLineOffset
  MOVE.w comWord_LinePosEndX,D0
   BPL.w JL_0_3E16
  MOVE.l comLong_LinePosEndY,D1
  CMP.l comLong_LinePosStartY,D1
   BLS.w JL_0_3E10
  SUBQ.l #1,comLong_LinePosEndY
 BRA.w JL_0_3E1E

JL_0_3E10:
  MOVEQ.l #$00,D0
BRA.w JL_0_3E24

JL_0_3E16:
  CMP.w comWord_MaxColumns,D0
   BCS.w JL_0_3E24

JL_0_3E1E:
  MOVE.w comWord_MaxColumns,D0
  SUBQ.w #1,D0

  JL_0_3E24:
  MOVE.w D0,comWord_LinePosEndX
  ;MOVE.l comLong_LinePosStartX,D0
  ;MOVE.l comWord_LinePosEndX,D1
  MOVE.w comLong_LinePosStartX,d0
  MOVE.w comWord_LinePosEndX,d1
  CMP.w d1,d0
  BNE 'l10
  MOVE.l comLong_LinePosStartY,d0
  MOVE.l comLong_LinePosEndY,d1
  CMP.l D1,D0
   BEQ.w JL_0_3E5E
 'l10:
  MOVEM.l D0-D1,-(A7)
  JSR JL_0_56BA
  MOVEM.l (A7)+,D0-D1
  ;ADD.w #8,A7
  ADD.w #12,a7
  ;MOVE.l D0,comLong_BlockStartX
  MOVE.l comLong_LinePosStartY,comLong_BlockStartY
  MOVE.w comLong_LinePosStartX,comLong_BlockStartX
  MOVE.l comLong_LinePosEndY,comLong_BlockEndY
  MOVE.w comWord_LinePosEndX,comLong_BlockEndX
  ;MOVE.l D1,comLong_BlockEndX
  JSR JL_0_5836
  JSR update_horizscroller
BRA.w _redrawb

JL_0_3E5E:
  ;MOVE.l (A7)+,comLong_BlockEndX
  MOVE.l (a7)+,comLong_BlockEndY
  MOVE.w (a7)+,comLong_BlockEndX
  MOVE.l (a7)+,comLong_BlockStartY
  MOVE.w (a7)+,comLong_BlockStartX
  ;MOVE.l (A7)+,comLong_BlockStartX
  MOVE.w comLong_LinePosStartX,D0
  SUB.w comWord_ColumnsOffset,D0
  MOVE.w D0,comWord_Column
  CLR.l foldnum
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  MOVEA.l comPtr_CurrentSourceLine,A4

CNIF #hardfold = 1
'l11 CMP.l comLong_LinePosStartY,d0
 BCS JL_0_3E98b
  CMP.w #";@",9(a4)
  BNE JL_0_3E84
  MOVE.l a2,-(a7)
  MOVE.l a4,a2
  JSR doreverse
  MOVE.l (a7)+,a2
JL_0_3E84:                           ;mouseclick get comPtr_CurrentSourceLine
  CMP.l comLong_LinePosStartY,D0
   BEQ.w JL_0_3E9E
  MOVE.l $4(A4),d1
  BEQ JL_0_3E9E
  MOVE.l d1,a4
  CMP.w #";@",9(a4)
  BNE 'l2
  MOVE.l a2,-(a7)
  MOVE.l a4,a2
  JSR doreverse
  MOVE.l (a7)+,a2
  CMP.w #"@0",11(a4)
  BNE 'l2
'l1a TST.l foldnum
  BNE 'l1
'l2
  TST.l foldnum
  BNE JL_0_3E84
  ;SUBQ.l #1,comLong_DisplayLineOffset
  ;SUBQ.l #1,comLong_LinePosStartY
'l1  SUBQ.l #1,D0
 BRA.b JL_0_3E84
JL_0_3E98b:
  CMP.l #";@@1",9(a4)
  BNE 'l10
  MOVE.l #1,foldnum
'l10
  CMP.l #";@@0",9(a4)
  BNE 'l11
  MOVE.l #0,foldnum
'l11
JL_0_3E98:
  CMP.l comLong_LinePosStartY,D0
  BEQ.w JL_0_3E9E
  MOVE.l (A4),d1                     ;forward ok
  BEQ JL_0_3E9E
  MOVE.l d1,a4
  CMP.l #";@@1",9(a4)
  BNE 'l1
  MOVE.l #1,foldnum

  BRA 'l3
'l1  CMP.l #";@@0",9(a4)
  BNE 'l2
  CLR.l foldnum
'l2
  TST.l foldnum
  BNE JL_0_3E98
  ;ADDQ.l #1,comLong_DisplayLineOffset
  ;ADDQ.l #1,comLong_LinePosStartY
'l3  ADDQ.l #1,D0
 BRA.b JL_0_3E98
CELSE
JL_0_3E84:
  CMP.l comLong_LinePosStartY,D0
   BEQ.w JL_0_3E9E
   BCS.w JL_0_3E98
  MOVEA.l $4(A4),A4
  SUBQ.l #1,D0
 BRA.b JL_0_3E84

JL_0_3E98:
  MOVEA.l (A4),A4
  ADDQ.l #1,D0
 BRA.b JL_0_3E84
CEND
  JL_0_3E9E:
  SUB.l comLong_DisplayLineOffset,D0

  MOVE.w D0,comLong_DisplayLine+2
  MOVE.l A4,comPtr_CurrentSourceLine
  JSR JL_0_775E
  MOVE.w message_qualifier,d1
  AND.w #$3,d1
  BEQ 'l9
  MOVE.w comLong_LinePosStartX,comLong_BlockEndX          ;enhance block
  MOVE.l comLong_LinePosStartY,comLong_BlockEndY
  BRA 'l1
 'l9
  MOVE.b #1,doedit2
  JSR checkedit2
  MOVE.l comLong_LinePosStartY,d0
  MOVE.w comLong_LinePosStartX,d1
  CMP.l comLong_BlockStartY,d0
  BLT 'l1
  CMP.l comLong_BlockEndY ,d0
  BGT 'l1
  CMP.l comLong_BlockStartY,d0
  BNE 'l3
  CMP.w comLong_BlockStartX,d1
  BLT 'l1
 'l3
  CMP.l comLong_BlockEndY,d0
  BNE 'l2
  CMP.w comLong_BlockEndX,d1
  BGT 'l1

 'l2
  MOVE.l #$ffffffff,comLong_BlockEndY
 'l1
  CMPI.l #$ffffFFFF,comLong_BlockEndY        ;redraw mark
  BEQ.w JL_0_3EC6
  JSR JL_0_56BA
  MOVE.w message_qualifier,d1
  AND.w #$30,d1
  BEQ 'l10
  JSR jump_onclick
;  JSR cursor_off
  JSR _redraw
;  JSR cursor_on_force
  RTS
 'l10:
BRA.w _redrawb

JL_0_3EC6:
  MOVE.l comLong_DisplayLineOffset,D0
  CMP.l comLong_DisplayLineOffsetStore,D0
   BNE.w _redrawb
  MOVE.w comWord_ColumnsOffset,D0
  CMP.w ColumnsOffsetStore,D0
   BNE.w _redrawb

  altleftb:
  MOVE.w message_qualifier,d1
  AND.w #$30,d1
  BEQ 'l10
;  MOVE.w #-1,state_of_cursor
  JSR jump_onclick
RTS
'l10:
JMP draw_cursor

_redrawb
JMP _redraw


ColumnsOffsetStore:    Ds.w 1

;Dc.b "09"
;Dc.l comLong_DisplayLine
;  JL_0_3EEC:
;  MOVE.w D3,comLong_DisplayLine+2
;  MOVEA.l comPtr_CurrentSourceLine,A0
;
;  JL_0_3EF6:
;    MOVEA.l A0,A4
;    CMP.l D3,D0
;    BEQ.w JL_0_3F0E
;    SUBQ.l #1,D0
;    MOVEA.l $4(A4),A0
;    CMPA.l #$0,A0
;  BNE.b JL_0_3EF6
;
;  ADDQ.w #1,D0
;
;  JL_0_3F0E:
;  MOVE.w D0,comLong_DisplayLine+2
;  MOVE.l A4,comPtr_CurrentSourceLine
;  MOVEA.l A4,A2
;  LEA $9(A2),A2
;  JSR JL_0_775E
;RTS
;
;
;JL_0_3F26:
;  MOVE.l comLong_DisplayLine,D0
;  MOVE.w D3,comLong_DisplayLine+2
;  MOVEA.l comPtr_CurrentSourceLine,A0
;
;  JL_0_3F36:
;    MOVEA.l A0,A4
;    CMP.l D3,D0
;    BEQ.w JL_0_3F4C
;    ADDQ.l #1,D0
;    MOVEA.l (A4),A0
;    CMPA.l #$0,A0
;  BNE.b JL_0_3F36
;
;  SUBQ.w #1,D0
;
;  JL_0_3F4C:
;  MOVE.w D0,comLong_DisplayLine+2
;  MOVE.l A4,comPtr_CurrentSourceLine
;  MOVEA.l A4,A2
;  LEA $9(A2),A2
;  JSR JL_0_775E
;RTS


.activate_gad_in_compilerwin:        ;newtype function
  MOVE.l A0,-(A7)
  MOVEQ.l #$08,D1
  MOVEA.l _dosbase,A6
  JSR _Delay(A6)
  MOVEA.l (A7)+,A0
  MOVEA.l comPtr_CompilerWindow,A1
  SUBA.l A2,A2
  MOVEA.l _intuibase,A6
  JSR _ActivateGadget(A6)
RTS


.menu_gotoline:                      ;goto line
  !basic
  WZWindow WZID("WIN_GOTO"),0,32,-2,-2,-2,-2,WZID("WIN_GOTO")
  Use Window WZID("WIN_GOTO")
  ActivateGadget_ WZGadAddr("GOTO_LINE"),WZWindowAddr,0
  exit_goto.b = False
  Repeat
    !ev_WaitEvent
    Select ev
    Case #IDCMP_IDCMPUPDATE
      If WZGadName = "GOTO_LINE"
        _line.l = Abs(WZInput("GOTO_LINE")) - 1
        exit_goto = True
      EndIf

    Case #IDCMP_CLOSEWINDOW
      _line = 0
      exit_goto = True
    End Select
  Until exit_goto
  WZCloseWindow WZID("WIN_GOTO")

  JSR activatesource
  If _line > 0
    GetD0 _line
    !asm
    BRA.w sub_gotoline
  EndIf
  !asm
RTS


AL_0_4280:        Dc.b $FF,$FF

.set_blockstart:                     ; D0: Startposition
  MOVE.w D0,AL_0_4280
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  MOVE.l D0,comLong_BlockStartDisplayLine
RTS

.set_blockend:                       ; D0: Position
  MOVE.l D0,-(a7)
  MOVE.w AL_0_4280,D2
   BMI.w JUMP_setpointer_to_normal
  MOVE.w D0,comLong_BlockStartX
  MOVE.l comLong_BlockStartDisplayLine,D3

  MOVE.l comLong_DisplayLineOffset,D1
  ADD.l comLong_DisplayLine,D1

  MOVE.l (a7)+,D0
;  MOVE.w comWord_ColumnsOffset,D0
;  ADD.w comWord_Column,D0
  CMP.w D0,D2
   BNE.w JL_0_42D8
  CMP.l D1,D3
   BNE.w JL_0_42D8
  JSR JL_0_572C
  JMP _redraw

  JL_0_42D8:
  TST.w D0
   BNE.w JL_0_42EA
  TST.l D1
   BEQ.w JL_0_42EA
  SUBQ.l #1,D1
  MOVE.w comWord_MaxColumns,D0

  JL_0_42EA:
  MOVE.w D0,comLong_BlockEndX
  MOVE.l D1,comLong_BlockEndY
  MOVE.w D2,comLong_BlockStartX
  MOVE.l D3,comLong_BlockStartY
  JSR JL_0_5836
  JSR JL_0_56BA
JMP _redraw



.menu_closewb:
  MOVEA.l _intuibase,A6
  JSR _CloseWorkbench(A6)
RTS

.menu_openwb:
  MOVEA.l _intuibase,A6
  JSR _OpenWorkbench(A6)
  MOVEA.l ptr_pedscreen,A0
  JSR _ScreenToFront(A6)
  MOVEA.l ptr_sourcewindow,A0
JMP _ActivateWindow(A6)


.menu_newshell:
  !basic
  screen_
  If Peek.w(?use_wbscreen)<>0
    WBenchToFront_
    exescr$ = "Workbench"
  Else
    exescr$ = Peek$(?str_defaultpubscreen) ;Sreenname not Screentitle (?str_pedscreenname)
  EndIf
  exe.s = "NEWCLI WINDOW = \\22"+console_device$+"///196/AmiBlitz Shell/CLOSE/SCREEN "+exescr$+"\\22"   ; use select Consoledevice for Shell
  Execute_ &exe,0,0
  !asm
RTS

Even
;str_contitle:      Dc.b "CON:0/13/640//AmiBlitz3 CLI Window",0     ; seem not in use any more
;                   Ds.b #MAX_STRINGSIZE
;                   Even
CLI_input_stream:  Ds.l 1
CLI_output_stream: Ds.l 1
CLI_output_file:   Ds.l 1

.console_open:
  SUBA.l A1,A1
  MOVEA.l _execbase,A6
  JSR _FindTask(A6)
  MOVEA.l D0,A3
  MOVE.l $9C(A3),CLI_input_stream
  MOVE.l $A0(A3),CLI_output_stream

  MOVEM.l A2-A3,-(A7)
  !basic
  console_dontclose.l = False
  If console_wb = True Then WBenchToFront_

  ; -- if the console_settings are n/a, set them to something usefull
  If \console_h = 0
    \console_x = 0
    \console_y = *myscreen\BarHeight * 2
    \console_w = *myscreen\Width / 3
    \console_h = *myscreen\Height / 3
  EndIf

  ; -- build the window path for opening the con:-device
  con_windowpath$ = dos_PathPart{console_device$}
  con_windowpath$ + Str$(\console_x)
  con_windowpath$ + "/"+Str$(\console_y)
  con_windowpath$ + "/"+Str$(\console_w)
  con_windowpath$ + "/"+Str$(\console_h)
  con_windowpath$ + "/"+console_title$
  con_windowpath$ + "/ZOOM"
  If console_wb = True
    con_windowpath$ + "/SCREEN Workbench"
  Else
    con_windowpath$ + "/SCREEN "+Peek$(?str_defaultpubscreen)
  EndIf
  If console_device$ = "VNC:"
    con_windowpath$ + "/DRAG/QUIET/NOCLOSE/NOBUTTONS"
    If console_font$<>"" Then con_windowpath$ + "/FONT"+console_font$
  EndIf
;  If console_wait = True
;    con_windowpath$ + "/CLOSE"
;    con_windowpath$ + "/WAIT"
;  EndIf

  con_windowpath$ + Chr$(0)
  If Peek.l(?CLI_output_file) = 0
    Poke.l ?CLI_output_file, Open_( con_windowpath$,#HUNK_RELOC_8__MODE_NEWFILE)
  EndIf
  !asm
  MOVEM.l (A7)+,A2-A3

  MOVE.l CLI_output_file,D0
  BEQ.w JL_0_442A
  MOVE.l D0,$9C(A3) ; pr_CIS
  MOVE.l D0,$A0(A3) ; pr_COS
  JL_0_442A:
RTS

.console_close:
  SUBA.l A1,A1
  MOVEA.l _execbase,A6
  JSR _FindTask(A6)
  MOVEA.l D0,A3
  MOVE.l CLI_input_stream,$9C(A3)
  MOVE.l CLI_output_stream,$A0(A3)
  ;
  !basic
  If console_wb   = True Then WBenchToFront_
  If console_wait = True
    txt$ = Chr$(27) + "[1m"              ; make text bold via escape-sequence
    txt$ + Chr$(27) + "["+Str$(30+3)+"m" ; change textcolor
    txt$ + Chr$(10) + !TRANS{"Program terminated."}
    txt$ + Chr$(10) + !TRANS{"Press <ENTER> to return to AmiBlitz3..."}
    Write_ Peek.l(?CLI_output_file),&txt$,FLen(txt$)
    Flush_(Peek.l(?CLI_output_file))

    SetWindowPointerA_ Peek.l(?ptr_sourcewindow), ?taglist_mousepointerbusy
    console_dummy.b = 0
    ; (CheckWindow{console_title$} = True)
    While Read_(Peek.l(?CLI_output_file),&console_dummy,1) = 0
      Delay_ 2
    Wend
  EndIf
  Close_ Peek.l(?CLI_output_file) : Poke.l ?CLI_output_file,0
  SetWindowPointerA_ Peek.l(?ptr_sourcewindow) , ?taglist_mousepointernormal
  ActivateWindow_ Peek.l(?ptr_sourcewindow)
  If console_wb = True Then ScreenToFront_ Peek.l(?ptr_pedscreen)
  !asm
  ;
  ;MOVEA.l _dosbase,A6
  ;MOVE.l CLI_output_file,D1
  ;JSR _Close(A6)
  ;MOVEA.l ptr_pedscreen,A0
  ;MOVEA.l _intuibase,A6
  ;JSR _ScreenToFront(A6)
  ;MOVEA.l ptr_sourcewindow,A0
;JMP _ActivateWindow(A6)
RTS




.check_devicelist:
  MOVEA.l _dosbase,A1
  MOVEA.l $22(A1),A1
  MOVEA.l $18(A1),A1
  ADDA.l A1,A1
  ADDA.l A1,A1
  MOVE.l $4(A1),D1

 JL_0_434A:
  MOVEA.l D1,A1
  ADDA.l A1,A1
  ADDA.l A1,A1
  MOVEA.l $28(A1),A2
  ADDA.l A2,A2
  ADDA.l A2,A2
  CMP.b (A2)+,D0
  BNE.w JL_0_4372
  MOVEA.l A0,A3
  MOVE.w D0,D1
  SUBQ.w #1,D1

 JL_0_4364:
    CMPM.b (A3)+,(A2)+
    BNE.w JL_0_4372
  DBF D1,JL_0_4364
  MOVEQ.l #$00,D0
RTS

 JL_0_4372:
  MOVE.l (A1),D1
  BNE.b JL_0_434A
  MOVEQ.l #-$01,D0
RTS




.comwin_refreshglist:
  MOVEA.l comPtr_CompilerWindow,A1
  SUBA.l A2,A2
  MOVEA.l _intuibase,A6
JMP _RefreshGList(A6)                ; A0: Gadgets, A1: Window, A2: Requ, D0: NumGad


.com_0_44E2:
  MOVEA.l A0,A2
  MOVEQ.l #$00,D1

 JL_0_44E6:
    ADDQ.w #1,D1
    TST.b (A0)+
  BNE.b JL_0_44E6

  MOVEA.l A2,A1
  SUBQ.w #1,D1
  BPL.w JUMP_JL_0_5F62
RTS

JUMP_JL_0_5F62:
JMP JL_0_5F62


TokenizeSource:
  MOVE.w comWord_DoTokenize,D0
   BNE.w JUMP_setpointer_to_normal
  NOT.w comWord_DoTokenize
  MOVEA.l comPtr_FirstSourceLine,A4
  MOVE.l comLong_TotalLines,-(A7)

 JL_0_450E:
    MOVEQ.l #$00,D1
    MOVE.b $8(A4),D1
    SUBQ.w #1,D1
    BMI.w JL_0_4530
    LEA $9(A4),A2
    MOVEA.l comPtr_Temp_TokenString1,A1
    JSR JL_0_5F62
    MOVE.l A4,comPtr_CurrentSourceLine
    JSR JL_0_55AA

 JL_0_4530:
    MOVEA.l (A4),A4
    SUBQ.w #1,(A7)
  BNE.b JL_0_450E

  ADDQ.w #2,A7
BRA.w JL_0_458E


DetokenizeSource:
  MOVE.w comWord_DoTokenize,D0
   BEQ.w JUMP_setpointer_to_normal
  CLR.w comWord_DoTokenize

 JL_0_454C:
  MOVEA.l comPtr_FirstSourceLine,A4
  MOVE.l comLong_TotalLines,-(A7)

 JL_0_4554:
    LEA $9(A4),A0
    MOVEA.l comPtr_Temp_TokenString1,A1
    JSR detokenize_line
    SUBA.l comPtr_Temp_TokenString1,A1
    ADDQ.w #1,A1
    MOVE.l A1,D5
    MOVE.l A4,comPtr_CurrentSourceLine
    JSR JL_0_55AA
    MOVEA.l (A4),A4
    SUBQ.w #1,(A7)
  BNE.b JL_0_4554
  ADDQ.w #2,A7
RTS


JL_0_457C:
  MOVE.w comWord_DoTokenize,D0
   BEQ.w JUMP_setpointer_to_normal
  CLR.w comWord_DoTokenize
  BSR.b JL_0_454C

 JL_0_458E:
  JSR update_currsourceline
JMP _redraw

JUMP_setpointer_to_normal:
JMP setpointer_to_normal



.event_helpkey
RTS


.update_labellist:
  CLR.l numcount
  !basic
  InitArgParse search_label$
  word1$ = NextArg$
  word2$ = NextArg$
  MOVE.b #0,searchmode
  t.l = 0
  If word2$<>""
    t = 1
    MOVE.b #1,searchmode
  End If
  search_label$ = search_label$
  skip.l = 0
  MOVE.l (a2),straddr
  !asm
  MOVEA.l comPtr_FirstSourceLine,A0
  MOVE.l comLong_TotalLines,D0
  MOVE.b comByte_LabelIdentifier,D1
  MOVE.l A1,-(A7)
  TST.w comWord_LabelAll
   BNE alladd
  TST.w comWord_LabelRemark
   BNE click_remark

 JL_0_467C:
  LEA $9(A0),A1

 JL_0_4680:
  CMPI.b #$20,(A1)
   BNE.b 'no
  ADDQ.l #1,a1
BRA JL_0_4680

 'no
  CMP.w #$802d,(a1)
  BEQ 'l20                           ;stop
  CMP.w #$80ae,(a1)                  ;trap
  BEQ 'l20
  CMP.w #$8008,(a1)                  ;func
  BNE 'nex
  ADDQ #3,a1
  MOVE.l a1,-(a7)
  !skipspace a1
  CMP.w #$8007,(a1)
  BNE 'ok

  MOVE.l (a7)+,a1
BRA 'nex

 'ok
  MOVE.l (a7)+,a1
  MOVE.b #1,isfunction
BRA 'l20

 'nex
  CMP.w #$8009,(a1)                  ;state
   BNE 'nex2
  ADDQ #3,a1
  MOVE.l a1,-(a7)
  !skipspace a1
  CMP.w #$8007,(a1)
  BNE 'ok
  MOVE.l (a7)+,a1
BRA 'nex2

  MOVE.l (a7)+,a1                   ;??looks like dead code??
  MOVE.b #1,isfunction
BRA 'l20


 'nex2
  CMP.b (A1),D1
   BNE.w JL_0_4696

 'l10
  ADDQ.l #1,a1
  TST.b (a1)
  BEQ JL_0_4696

 'l20
  !skipspace a1
  CMP.b #".",-1(a1)
   BNE 'noformat
  ADDQ.l #1,a1
  !skipspace a1

 'noformat
  CMP.l #"FAST",(a1)
   BNE 'nf
  CMP.b #" ",4(a1)
   BNE 'nf
  ADDQ.l #5,a1

 'nf
  MOVE.w D1,comWord_LabelListChanged
  JSR JL_0_46D6

 JL_0_4696:
  MOVEA.l (A0),A0
  SUBQ .l #1,d0
  BNE JL_0_467C
  MOVEA.l (A7)+,A1
RTS


;.caseadd
;RTS


.alladd
  MOVEM.l d2-d3/a2/a3,-(a7)

  MOVE.l comLong_TotalLines,D0

.click_all
  MOVE.b comByte_LabelIdentifier,D1
  MOVEQ #0,d3
  MOVE.l comparetab,a3
'l15  MOVE.b #";",d1
  LEA $9(A0),A1
  TST.b (a1)
  BEQ 'nowrite
'lc1  CMP.b #" ",(a1)
  BNE 'l1
  ADDQ.l #1,a1
  BRA 'lc1
'l1 MOVE.l a1,straddr2
  CMP.b #".",(a1)
  BNE 'l1b
  ADDQ.l #1,a1
  ;BRA 'addlist
'l1b  CMP.w #$802d,(a1)              ;stop
  BEQ 'addstop
  CMP.w #$80ae,(a1)                  ;trap
  BEQ 'addstop
  MOVE.l straddr,a2
  CLR.l slen2
'cok  MOVE.b (a2)+,d2
  BEQ 'addlist
'cf  MOVE.b (a1)+,d3
  TST.b searchmode
  BEQ 'nopat
  BRA 'addlist
'nopat TST.b d3
  BEQ 'nowrite
   TST.b casemode
   BEQ 'lca1
   MOVE.b 0(a3,d3.w),d3
'lca1 ADD.l #1,slen2
  CMP.b d2,d3
  BEQ 'cok
  MOVE.l slen2,a2
  SUBQ.l #1,a2
  SUB.l a2,a1
  CLR.l slen2
  MOVE.l straddr,a2
  BRA 'cok
 'addstop
  MOVEM.l a0/d0,-(a7)
  MOVE.l a0,d0
  !basic
  s.l = PutD0
  WZTags #WENTRYA_TextPen,2
  s$ = " --Breakpoint---"
  WZListAdd list_labels,s$,0,s
  !asm
  MOVEM.l (a7)+,d0/a0
  BRA 'nowrite
 'v1
 'addlist
  CMP.l #maxlabels,numcount          ;reduce this for slow computer
  BGE 'nowrite
  MOVEM.l a0/d0,-(a7)
  MOVE.l a0,d0
  !basic
  s.l = PutD0
  MOVE.l straddr2,a1
  ;SUB.l slen2,a1
  ;SUBQ.l #5,a1
  MOVE.l a1,a0
  MOVE.l expandstore,a1
  JSR detokenize_line
  MOVE.l expandstore,d0
  i = PutD0
  If i Then s$ = Peek$(i) : Else s$="!NULL!"
   If t
     If Instr(s$,word1$)
         If Instr(s$,word2$)
           WZListAdd list_labels,s$,-1,s
           ADDQ.l #1,numcount
         End If
     End If
   Else
     WZListAdd list_labels,s$,-1,s
     ADDQ.l #1,numcount
   End If

  ADDQ.w #1,comWord_LabelCounter
  !asm
  MOVEM.l (a7)+,d0/a0
 'l15b
 'nowrite
  MOVEA.l (A0),A0
  SUBQ.l #1,d0
  BNE 'l15
 'out
  MOVEM.l (a7)+,d2-d3/a2/a3
  MOVEA.l (A7)+,A1
RTS

.click_remark
  CLR.b instring
  MOVE.b #";",d1
  LEA $9(A0),A1
  TST.b (a1)
  BEQ 'nowrite
'l1  CMP.b #" ",(a1)
  BNE 'l1b
  ADDQ.l #1,a1
  BRA 'l1
'l1b

'co
  CMP.b #".",(a1)
  ;BEQ 'addlist
  CMP.b #$22,(a1)
  BNE 'is1
  NOT.b instring

 'is1
  CMP.w #$802d,(a1)
  BEQ 'addlist
  CMP.w #$800f,(a1)
  BNE 'l10
  MOVE.l a0,-(a7)
  MOVE.l straddr,a0
  CMP.l #"Case",(a0)
  BNE 'l10a
  !basic
  skip = 1
  !asm
  MOVE.l (a7)+,a0
  ADDQ.l #3,a1
  BRA 'addlist
 'l10a
  MOVE.l (a7)+,a0
 'l10
  CMP.b (a1),d1
  BNE 'skip
 'l5
  ADDQ.l #1,a1
  TST.b instring
  BNE 'nowrite
  TST.b (a1)
  BEQ 'nowrite
  CMP.b #".",(a1)
  BEQ 'nowrite
 'l1s
  CMP.b #" ",(a1)
  BNE 'l1bs
  ADDQ.l #1,a1
  BRA 'l1s
 'l1bs
 'addlist
  CMP.l #maxlabels,numcount          ;reduce this for slow computer
  BGE 'out
  MOVE.w D1,comWord_LabelListChanged
  JSR JL_0_46D6                      ;remarklistadd

 'skip
  TST.b (a1)+
  BNE 'co
 'nowrite
  MOVEA.l (A0),A0
  SUBQ.l #1,d0
  BNE click_remark
 'out
  MOVEA.l (A7)+,A1
RTS

.clear_labellist:
  !basic
  WZListRemove list_labels
  !asm
  CLR.w comWord_LabelCounter
RTS

JL_0_46CC:
  MOVE.w #$FFFF,comWord_LabelListChanged
RTS

.oldlistadd
  MOVEM.l D0-D1/A1-A2,-(A7)
  MOVEQ.l #$08,D0
  MOVE.l #$10000,D1
  MOVEA.l _execbase,A6
  MOVE.l A0,-(A7)
  !newalloc
  TST.l D0
   BEQ.w JL_0_4942

  MOVEA.l (A7)+,A0
  MOVEA.l D0,A2
  MOVE.w comWord_LabelCounter,D1
  BEQ.w JL_0_4714

  MOVEA.l comPtr_LabelList,A1
  SUBQ.w #2,D1
  BMI.w JL_0_470E

  JL_0_4708:
    MOVEA.l (A1),A1
  DBF D1,JL_0_4708

  JL_0_470E:
  MOVE.l A2,(A1)
  BRA.w JL_0_471A

  JL_0_4714:
  MOVE.l A2,comPtr_LabelList

  JL_0_471A:
  MOVE.l A0,$4(A2)
  ADDQ.w #1,comWord_LabelCounter

  MOVEM.l (A7)+,D0-D1/A1-A2
RTS

JL_0_472A:
  MOVE.w #$FFFF,comWord_LabelListChanged
RTS


AL_0_4734:  Ds.l 1

.update_labelstuff:
  CLR.l AL_0_4734
  CMPI.b #$FF,comByte_LabelIdentifier
  BNE.w JL_0_474C
RTS

 JL_0_474C:
  JSR clear_labellist
  JSR update_labellist
  MOVE.w comWord_LabelCounter,D3

  TST.w comWord_LabelSize
   BEQ.w JL_0_47AA
  MOVE.w comWord_LabelSize,D0
  CMP.w comWord_LabelSizeC,D0
   BEQ.w redraw_labellist

 JL_0_47AA:
  ST AL_0_4734
  MOVE.w clickpos,comWord_LabelSize
  JSR _redraw
  JSR update_horizscroller
  JSR update_vertscroller
  CLR.w comWord_LabelListChanged

 redraw_labellist:
  MOVE.w comWord_LabelCounter,D5
  MOVEQ.l #$00,D1
  MOVEQ.l #$00,D4
  TST.w comWord_LabelCounter
BRA JL_0_47Dca ;BNE.w JL_0_47Dca
RTS

 JL_0_47Dca:
  !basic
  MOVEQ #0,d0
  MOVE.w comWord_LabelCounter,d0
  CMP.l comLong_Label1VisableItem,d0
  BGT 'g1
  CLR.l comLong_Label1VisableItem

 'g1
  MOVE.l comLong_Label1VisableItem,d0 : LabelList_FirstVisableItemNumber = PutD0
  If WZ_CheckOpen{"WIN_LABELS"}
    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels,LabelList_FirstVisableItemNumber
    WZListRemove lib_list.List
    WZPrint "LIBRARY_LIST",0,lib_list
  EndIf
  !asm
RTS

;.split_path_and_name:
;  LEA comStr_CurrentDir,A1
;  TST.b (A0)
;   BEQ.w JL_0_48E8
;  MOVEA.l A1,A2
;  CMPI.b #$22,(A0)                   ; anfuehrungszeichen ueberspringen
;   BNE.w JL_0_48A6
;  ADDQ.w #1,A0
;
;  JL_0_48A6:
;    MOVE.b (A0)+,(A1)+
;    BEQ.w JL_0_48C4
;    CMP.b #":",D0
;     BEQ.w JL_0_48C0
;    CMP.b #$2F,D0                    ; /
;     BNE.b JL_0_48A6
;    LEA -$1(A1),A2
;    BRA.b JL_0_48A6
;
;    JL_0_48C0:
;    MOVEA.l A1,A2
;  BRA.b JL_0_48A6
;
;  JL_0_48C4:
;  LEA comStr_SourceName,A1
;  MOVEA.l A2,A0
;  CMPI.b #$2F,(A2)                   ; /
;   BNE.w JL_0_48D4
;  ADDQ.w #1,A2
;
;  JL_0_48D4:
;    MOVE.b (A2)+,(A1)+
;  BNE.b JL_0_48D4
;
;  CMPI.b #$22,-$2(A1)
;   BNE.w JL_0_48E6
;  CLR.b -$2(A1)
;
;  JL_0_48E6:
;  CLR.b (A0)
;
;  JL_0_48E8:
;RTS
;

JL_0_492E:
  MOVE.w #$FFFF,comWord__AL_0_86C0
  !newalloc;JSR _AllocVec(A6)
  TST.l D0
  BEQ.w JL_0_4942
RTS

JL_0_4942:
  JSR display_memoryalert
  MOVE.l comPtr_SourceFileHandle,D1
  BEQ.w JL_0_4956
  MOVEA.l _dosbase,A6
  JSR _Close(A6)
  JL_0_4956:

  CLR.l comLong_DisplayLineOffset
  CLR.l comLong_DisplayLine
  MOVE.l comPtr_FirstSourceLine,comPtr_CurrentSourceLine
  JSR _redraw
JMP JL_0_CE2

old_CloseCompilerWin:
  JSR -$2AC(A6)
  TST.l D0
  BNE.w 'fail
  JSR comwin_close
  BRA.b JL_0_4942

  'fail:
RTS

.display_memoryalert:
  !basic
  alert$ = Chr$($00)  ; alert code
  alert$ + Chr$($38)  ; x-position
  alert$ + Chr$($16)  ; y-position
  alert$ + "Not enough memory for that operation! - Click Mousebutton to continue.\00\00"
  DisplayAlert_ $00,&alert$,$28
  !asm
RTS


.set_oldpreferences:
  MOVEM.l D0-D7/A0-A6,-(A7)

  ; -- load sourcefont
  JSR change_sourcefont
  ;!basic
  ;MOVE.w sourcefontsize,textfont_YSize
  ;MOVE.b sourcefontstyle,textfont_Style
  ;Poke.l ?struct_textfont,?str_sourcefontname
  ;Poke.l ?ptr_sourcefont, OpenDiskFont_ (?struct_textfont)
  ;!asm

  ; -- check/set tokenisation mode
  MOVE.w flag_tokenization,comWord_DoTokenize
  TST.w comWord_DoTokenize
  BEQ.w JL_0_4A76
    TST.l comPtr_TokenBase
    BNE.w JL_0_4A76
      CLR.w comWord_DoTokenize
  JL_0_4A76:

  ; -- add the source history to the menu
  JSR add_history_to_menu

  MOVEM.l (A7)+,D0-D7/A0-A6
RTS

AJL_0_4A8E:
  MOVEM.l A0-A1,-(A7)

  JL_0_4A92:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_4A92

  MOVEM.l (A7)+,A0-A1
RTS

.prefs_redo_gui:
  JSR close_sourcewindow
  BMI.w close_librariesb
  JSR open_sourcewindow
  BMI.w close_librariesb
  JL_0_4D40:
RTS
close_librariesb
JMP close_libraries

;.check_font:
;  If sourcefont$<>"topaz.font"
;    If Exists("fonts:"+sourcefont$) = 0
;      dummy.l= RTEZRequest("","Selected font "+Chr$(34)+sourcefont$ + Chr$(34)+" is not available.\\nChoosing standard font.","_Ok")
;      sourcefont$ = "topaz.font"
;      sourcefont_size = 8
;      sourcefont_style = 0
;      Poke.s ?str_sourcefontname, sourcefont$
;    EndIf
;  EndIf
;  If sourcefont_size<6 Then sourcefont_size = 8
;Return


; Subroutine to close the sourcefonts (was a copy&past from the exit code) because it was uptodate;) tomsmart1
.close_sourcefont
  If Peek.l(?ptr_sourcefonti)
    If Peek.l(?ptr_sourcefonti)><Peek.l(?ptr_sourcefont)
      CloseFont_ Peek.l(?ptr_sourcefonti)
    End If
    CLR.l ptr_sourcefonti
  End If

  If Peek.l(?ptr_sourcefontb)
    If Peek.l(?ptr_sourcefontb)><Peek.l(?ptr_sourcefont)
      CloseFont_ Peek.l(?ptr_sourcefontb)
    End If
    CLR.l ptr_sourcefontb
  End If

  If Peek.l(?ptr_sourcefont)
    CloseFont_ Peek.l(?ptr_sourcefont)
    CLR.l ptr_sourcefont
  EndIf
Return


.change_sourcefont:
  !basic
  ; replace close of Sourcefonts here by a subroutine call because we need it more then once  tomsmart1
  Gosub close_sourcefont

  MOVE.w sourcefontsize  ,textfont_YSize
  MOVE.b sourcefontstyle ,textfont_Style
  Poke.l ?struct_textfont,?str_sourcefontname
  *font.TextFont = OpenDiskFont_ (?struct_textfont)

  If *font = 0                       ; unable to open font => use system default
    InitRastPort_ rp.RastPort
    AskFont_ rp,ta.TextAttr ; might be better
    Poke.s ?str_sourcefontname,Peek.s(ta\ta_Name)
    Poke.w ?sourcefontsize    ,ta\ta_YSize
    *font = OpenDiskFont_(ta)
  EndIf

  Poke.l ?ptr_sourcefont,*font

  MOVE.w sourcefontsize,textfont_YSize
  MOVE.b ##FSF_ITALIC,textfont_Style
  Poke.l ?struct_textfont,?str_sourcefontname
  *fontI.TextFont = OpenDiskFont_ (?struct_textfont)

  If *fontI = 0  ; unable to open font => use system default
    InitRastPort_ rp.RastPort
    AskFont_ rp,ta.TextAttr ; might be better
    Poke.s ?str_sourcefontname,Peek.s(ta\ta_Name)
    Poke.w ?sourcefontsize    ,ta\ta_YSize
    *fontI = OpenDiskFont_(ta)
  EndIf

  Poke.l ?ptr_sourcefonti,*fontI

  MOVE.w sourcefontsize,textfont_YSize
  MOVE.b ##FSF_BOLD,textfont_Style
  Poke.l ?struct_textfont,?str_sourcefontname
  *fontB.TextFont = OpenDiskFont_ (?struct_textfont)

  If *fontB = 0  ; unable to open font => use system default
    InitRastPort_ rp.RastPort
    AskFont_ rp,ta.TextAttr ; might be better
    Poke.s ?str_sourcefontname,Peek.s(ta\ta_Name)
    Poke.w ?sourcefontsize    ,ta\ta_YSize
    *fontB = OpenDiskFont_(ta)
  EndIf

  Poke.l ?ptr_sourcefontb,*fontB

  If *fontI
    If *fontI\tf_XSize><*font\tf_XSize
      Poke.l ?ptr_sourcefonti,*font
      CloseFont_ *fontI : *fontI = *font
    End If
  End If

  If *fontB
    If *fontB\tf_XSize><*font\tf_XSize
      Poke.l ?ptr_sourcefontb,*font
      CloseFont_ *fontB : *fontB = *font
    End If
  End If

  !asm
RTS


valueaddr:  Ds.l 1

.format_value:                       ; A0 = stringbuffer, D0 = Zahl
  MOVE.l a0,valueaddr
  !basic
  value.l = PutD0
  formatstr$ = Peek$(Peek.l(?valueaddr))
  len_fmtstr.b = FLen(formatstr$)
  formatstr$ = StrRight(Str$(value),len_fmtstr,48)  ; mit nullen auff|llen
  Poke$ Peek.l(?valueaddr),formatstr$
  !asm
RTS


.show_newfilerequest:
  MOVE.w comWord_SourceChanged,D0
  BEQ.w JL_0_4DFC
    LEA easystruct_loosewarning,A1
    JSR show_requester
    RTS
  JL_0_4DFC:

  MOVE.w #$FFFF,comWord_LabelListChanged
  MOVEQ.l #-$01,D0
RTS

JL_0_4E08:
  ADDQ.l #1,comLong_TotalLines
  MOVE.l (A4),D0
  BEQ.w JL_0_4E20
  MOVEA.l D0,A1
  MOVE.l A1,(A0)
  MOVE.l A0,$4(A1)
  BRA.w JL_0_4E26

  JL_0_4E20:
  MOVE.l A0,comPtr_LastSourceLine

  JL_0_4E26:
  MOVE.l A4,$4(A0)
  MOVE.l A0,(A4)
  MOVEA.l A0,A4
  MOVE.l A4,comPtr_CurrentSourceLine
RTS

JL_0_4E36:
  MOVEA.l comPtr_Temp_TokenString2,A0
  JL_0_4E3A:
    MOVE.b (A0)+,(A3)+
    BEQ.w JL_0_4E46
    BPL.b JL_0_4E3A
    MOVE.b (A0)+,(A3)+
  BRA.b JL_0_4E3A

  JL_0_4E46:
  SUBQ.w #1,A3
RTS

close_sourcefile:
  TST.w comWord_PasteMode
   BNE.w JL_0_4E64
  CLR.l comPtr_SourceFileHandle
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
JMP _Close(A6)
JL_0_4E64:
RTS

.open_sourcefile:                    ; D7: filename & Path
  TST.w comWord_PasteMode
    BNE.w exit_opensourcefile

  MOVE.l D7,D1
  MOVE.l D1,A0
  CLR.b convert
  LEA comStr_SourceFileComplete,A0
 'l10
    TST.b (a0)+
  BNE 'l10
  MOVE.l a1,-(a7)
  MOVE.l a0,a1
  JSR check_fileextension_for_tokenization
  MOVE.l (a7)+,a1
  LEA -5(a0),a2
  CMP.l #".asm",(a2)
   BNE 'l11
  TST.w smart_tokenization
  BEQ 't1
  MOVE.w #$ffff,comWord_DoTokenize
 't1
  MOVE.b #1,convert
 'l11
  MOVEA.l _dosbase,A6
  JSR _Open(A6)                      ; D1: name, D2: accessmode
  MOVE.l D0,D7
   BNE.w file_found
  ADDQ.w #4,A7
  SUBA.l A0,A0
  MOVEA.l #comStr_ErrorOpenFile,A0
  TST.b menuload
  BNE 'lod1
    BRA.w show_errorrequester
 'lod1
  CLR.b menuload
  BRA loadfileerror

  file_found:
  MOVE.l D7,comPtr_SourceFileHandle

  exit_opensourcefile:
RTS

.readbyte:
  SUBQ.w #1,D6
  BMI.w JL_0_4EA2
  MOVE.b (A5)+,D0
  CMP.w D0,D0
RTS

JL_0_4EA2:
  JSR source_readin
  BNE.b readbyte
  MOVEQ.l #-$01,D0
RTS

source_readin:                       ; can be clipboard or file
  TST.w comWord_PasteMode
  BEQ.w source_read_from_file_cached ; well, it's from file



;  MOVE.l A6,-(A7)

;  MOVEA.l _execbase,A6                  ; original BlitzBasic2 Code
;  MOVEA.l ptr_iorequest_clipboard,A1
;  MOVE.l comPtr_DosBuffer,$28(A1)
;  MOVE.l #$2000,$24(A1)
;  MOVE.w #$0002,$1C(A1)
;  JSR _DoIO(A6)
;  MOVEA.l ptr_iorequest_clipboard,A1
;  MOVE.l $20(A1),D6
;  MOVE.l (a7)+,a6
;  MOVEA.l comPtr_DosBuffer,A5
;  TST.l D6 TST
;  RTS

  !regs2stack                           ; all-in-one block Code (Thilo)
  !basic
  If clipboard_tmpP.l = #NULL
    clipboard_length.l = clipboard_GetTextLength{}
    ;error{"Got clipboard =>"+Str$(clipboard_length)+" bytes!"}
    If clipboard_length>0
      clipboard_tmpP.l = AllocVec_(clipboard_length+8,#MEMF_ANY)
      If clipboard_tmpP
        clipboard_length = clipboard_GetText{clipboard_tmpP,clipboard_length+1}
        If clipboard_length>0

          ccount.l     = 0
          seenReturn.l = False
          For n.l=0 To clipboard_length-1
            cchar.w = Peek.b(clipboard_tmpP+n) & $FF
            If cchar = $0a Then seenReturn=True : ccount=0
            If cchar = $a0 Then cchar = $20
            If cchar > 127 Then cchar = Asc("?")
            ccount+1
            If ccount>249 Then cchar=$0A : ccount=0 : seenReturn=True
            Poke.b clipboard_tmpP+n,cchar
          Next
          If seenReturn
            If Peek.b(clipboard_tmpP+clipboard_length-1)><$0a
              Poke.b clipboard_tmpP+clipboard_length,$0A
              clipboard_length+1
            End If
          End If
          Poke.b clipboard_tmpP+clipboard_length,$0
        Else
          error{"Clipboard read error!"} : clipboard_length=0
        End If
      Else
        error{"Not enough memory for clipboard operation!"}
        clipboard_length=0
      End If
    Else
      clipboard_length=0
    End If ; nothing in clip!
  Else
    clipboard_length = 0
  End If

  If clipboard_length<=0
   ; error{"Free clipboard buffer!"}
    If clipboard_tmpP Then FreeVec_ clipboard_tmpP
    clipboard_tmpP   = #NULL
    clipboard_length = 0
  Else
    ;error{"Got clipboard!"+Str$(clipboard_length)+" bytes!"}
    fid.l = file_Open{"ram:cliptest.txt",#file_forcewrite}
    If fid>=0
      file_WriteMem{fid,clipboard_tmpP ,clipboard_length+1}
      file_Close{fid}
    End If
  End If

  Poke.l ?clipboard_copylen,clipboard_length
  Poke.l ?clipboard_copybuffer,clipboard_tmpP

  !asm
  !stack2regs
 ; MOVEA.l (A7)+,A6
  MOVE.l  clipboard_copylen,D6
  MOVEA.l clipboard_copybuffer,A5
  TST.l D6
  RTS

clipboard_copylen: Dc.l 0
clipboard_copybuffer: Dc.l 0

source_read_from_file:
  MOVE.l D7,D1                       ; file handle
  MOVEA.l comPtr_DosBuffer,A5
  MOVE.l A5,D2                       ; membuffer
  MOVE.l #$2000,D3                   ; length
  MOVEA.l _dosbase,A6
   JSR _Read(A6)
  MOVE.l D0,D6
   BPL.w JL_0_4F18
  SUBA.l A0,A0
  MOVEA.l #comStr_ErrorReadFile,A0
   JSR show_errorrequester
  MOVEQ.l #$00,D6
  JL_0_4F18:
RTS


source_read_from_file_cached:
  MOVE.l D7,readcache_fp
  MOVEA.l comPtr_DosBuffer,A5
  MOVE.l A5,readcache_destptr        ; membuffer
  MOVE.l #$2000,readcache_blocklen   ; length
  !basic
  rc_fp.l         = Peek.l(?readcache_fp)
  rc_destptr.l    = Peek.l(?readcache_destptr)
  rc_readlen.l    = Peek.l(?readcache_readlen)
  rc_offset.l     = Peek.l(?readcache_offset)
  rc_blocklen.l   = Peek.l(?readcache_blocklen)
  rc_cachelen.l   = Peek.l(?readcache_cachelen)
  rc_cacheptr.l   = Peek.l(?readcache_cacheptr)
  rc_dotokenize.l = Peek.l(?readcache_dotokenize)

  If rc_readlen<=0                   ; no file yet!
    ExamineFH_ rc_fp,*rc_fib
    rc_filelen.l = *rc_fib\fib_Size
    If rc_filelen>rc_cachelen
      If rc_cacheptr Then FreeVec_ rc_cacheptr
      rc_cacheptr = AllocVec_(rc_filelen,#MEMF_ANY)
      rc_cachelen = rc_filelen
    End If
    rc_readlen.l = Read_ (rc_fp,rc_cacheptr,rc_filelen)
    ex.s = LCase$(dos_GetExt{Peek.s(&*rc_fib\fib_FileName)})
    If ex="ab2" OR ex="ab3" OR ex="asc"
      rc_readlen = preproc_Tokenize{*PreProcessor,rc_cacheptr,rc_cacheptr,rc_readlen}
    End If
    rc_offset = 0
  End If

  rc_chunklen.l = rc_blocklen
  If rc_chunklen>rc_readlen-rc_offset Then rc_chunklen=rc_readlen-rc_offset
  If rc_chunklen>0
    CopyMem_ rc_cacheptr+rc_offset,rc_destptr,rc_chunklen
    rc_offset + rc_chunklen
  Else
    rc_chunklen   = 0
    rc_readlen = 0
  End If

  Poke.l ?readcache_chunklen ,rc_chunklen
  Poke.l ?readcache_readlen  ,rc_readlen
  Poke.l ?readcache_offset   ,rc_offset
  Poke.l ?readcache_cachelen ,rc_cachelen
  Poke.l ?readcache_cacheptr ,rc_cacheptr
  ;error{"Readfile cached! length="+Str$(rc_rlength)}
  !asm
  MOVE.l readcache_chunklen,d0
  MOVE.l readcache_chunklen,d6
  MOVEA.l comPtr_DosBuffer,A5
  MOVE.l readcache_fp,D7
  TST.l D6
RTS

readcache_fp:         Dc.l 0
readcache_destptr:    Dc.l 0
readcache_filelen:    Dc.l 0
readcache_offset:     Dc.l 0
readcache_blocklen:   Dc.l 0
readcache_readlen:    Dc.l 0
readcache_cacheptr:   Dc.l 0
readcache_cachelen:   Dc.l 0
readcache_chunklen:   Dc.l 0
readcache_dotokenize: Dc.l 0

JL_0_4F1A:
  MOVE.l D5,D0
  ADDI.w #$9,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  JSR JL_0_492E
  JL_0_4F2A:
  JSR JL_0_FBDE
  NOP
  MOVEA.l comPtr_Temp_TokenString2,A1
  LEA $9(A0),A0

  JL_0_4F3A:
  MOVE.b (A1)+,(A0)+
   BNE.b JL_0_4F3A
  MOVEA.l D0,A0
  MOVE.b comByte_LabelIdentifier,D0
  MOVE.l A1,-(A7)
  LEA $9(A0),A1

  JL_0_4F4A:
  CMPI.b #$20,(A1)+
   BEQ.b JL_0_4F4A
  CMP.b -(A1),D0
  MOVEA.l (A7)+,A1
   ;BEQ.w JL_0_46CC
   BRA.w JL_0_46CC
RTS

JL_0_4F5A:
  JSR readbyte
  BMI.w JL_0_500C                    ;move a line

  MOVEA.l tempstore,A0
  MOVEQ.l #$00,D4

  JL_0_4F68:
  TST.b D0
   BPL.w JL_0_4F82
  MOVE.b D0,(A0)+
  MOVE.l A0,-(A7)
   JSR readbyte
  MOVEA.l (A7)+,A0
   BMI.w JL_0_4FD2
  MOVE.b D0,(A0)+
  BRA.w JL_0_4FB6

  JL_0_4F82:
  CMP.b #$A,D0
   BNE.w JL_0_4F8E                   ;end line clipboard
  TST.b (a5)
  BNE 'c2
  SUBQ.l #$1,d6
  ADDQ #1,a5
 'c2
    CMP.l #"STYL",(a5)
    BEQ 's1
    CMP.l #"COLS",(a5)
    BNE 'c1
    MOVE.l 4(a5),d0
    ADDQ.l #8,a5
    SUBQ.l #8,d6
    ADD.l d0,a5
    SUB.l d0,d6
  BRA 'c2
 's1
  SUBQ.l #4,d6
  CMP.l #0,4(a5)
  BNE 'c1
  SUBQ.l #4,d6
  CMP.l #"CHRS",8(a5)
  BNE 'c1
  SUBQ.l #4,d6
  CMP.b #0,12(a5)
  BNE 'c1
  SUBQ.l #4,d6
  ADD.w # 16,a5
 'c1
  MOVEQ.l #$00,D0
  MOVEQ.l #-$01,D4

  JL_0_4F8E:
  MOVE.b D0,(A0)+
   BEQ.w JL_0_5002
  CMP.b #$9,D0
   BNE.w JL_0_4FB6
  SUBQ.w #1,A0
  MOVE.l A0,D0
  SUB.l comPtr_Temp_TokenString2,D0

  JL_0_4FA4:
  MOVE.b #$20,(A0)+
  ADDQ.w #1,D0
  MOVE.l D0,D1
  DIVU tab_size,D1
  SWAP D1
  TST.w D1
   BNE.b JL_0_4FA4

  JL_0_4FB6:
  ADDQ #3,a0
  CMPA.l comPtr_Temp_TokenString3,A0
   BCS.w JL_0_4FC8
  MOVEA.l comPtr_Temp_TokenString3,A0
  ;SUBQ.w #3,A0
  BRA.w JL_0_4FD2

  JL_0_4EA2b
  MOVE.l A0,-(a7)
  JSR JL_0_4EA2
  MOVE.l (A7)+,a0
  BRA load

  JL_0_4FC8:
  SUBQ #3,a0
  SUBQ.w #1,D6
  BMI.w JL_0_4EA2b
  MOVE.b (A5)+,D0
  CMP.w d0,d0
   ;jsr readbyte
load
  BPL.b JL_0_4F68
  JL_0_4FD2:
  CLR.b (A0)+
  SUBA.l comPtr_Temp_TokenString2,A0
  MOVE.l A0,D5
  MOVEQ.l #$00,D0

  JL_0_4FDC:
  MOVE.w D0,-(A7)
  TST.w D4                           ;-1 ascii
   BEQ.w JL_0_4FFE

  MOVE.w comWord_DoTokenize,D2
   BEQ.w JL_0_4FFE
  SUBQ.w #1,D5
   BPL.w JL_0_4FFA
  MOVEQ.l #$01,D5
  BRA.w JL_0_4FFE

  JL_0_4FFA:
  JSR import_start

  JL_0_4FFE:
  MOVE.w (A7)+,D0
RTS

JL_0_5002:
  SUBA.l comPtr_Temp_TokenString2,A0
  MOVE.l A0,D5
  MOVEQ.l #$01,D0
  BRA.b JL_0_4FDC

  JL_0_500C:
  MOVEQ.l #-$01,D0
RTS


.import_start:
  MOVEM.l D1-D4/D6-D7/A0-A6,-(A7)
  MOVE.w D5,D1
  MOVEA.l comPtr_Temp_TokenString2,A1
  CLR.b instring
  LEA tempbuf,a2
  TST.b convert
  BEQ 'l2b  ;'l1

  ;BRA 'l2b                         ; convert is done with preproc
  ;CMP.w #122,d1
  ;BLE 'noclip
  ;MOVE.w #122,d1
  ;MOVE.w d1,d5
'noclip
 CMP.b #".",(a1)
  BNE 'l1

  MOVE.w #"'l",(a2)+
  ADDQ.w #1,d5                       ;add 1 additional char
  ADDQ.l #1,a1
  BRA 'ln1
'l1 TST.b convert
  BNE 'l1a
'l1b
  MOVE.b (a1)+,d0
  BEQ 'exit
  MOVE.b d0,(a2)+
  DBF d1,'l1b
  BRA 'exit
'l1a
  CMP.w #"\@",(a1)
  BNE 'ln1
  MOVE.w #"'l",(a2)+
  ADDQ.l #2,a1
'n3 MOVE.b (a1)+,d0
  BEQ 'n2
  CMP.b #" ",d0
  BEQ 'n2
  CMP.b #":",d0
  BEQ 'n2
  MOVE.b d0,(a2)+
  BRA 'n3
 'n2
     SUBQ.l #1,a1
     MOVE.l #"l`@ ",(a2)+
     ADDQ.w #4,d5
 'ln1 CMP.b #";",(a1)   ;-1
      BEQ 'l2c
    CMP.b #$22,(a1)     ;-1
    BNE 'l2b
    TST.b instring
    BEQ 'l2c
    CLR.b instring
    BRA 'l2b
 'l2c   MOVE.b #1,instring
 'l2b
  MOVE.b (a1)+,d0
  BEQ 'exit
  TST.b instring                     ;do only if no string
  BNE 'l5
  TST.b convert
  BEQ 'l5
  ;BRA 'l5
  CMP.b #".",d0
  BNE 'l2
  CMP.b #",",-2(a1)
  BEQ 'l500
  CMP.b #" ",-2(a1)
  BNE 'l2
'l500  ADDQ.w #1,d5
  MOVE.b #"'",(a2)+
  MOVEQ #"l",d0
'l2 CMP.b #"_",-2(a1)
    BEQ 'l4
       ;TST.b instring
    ;BNE 'l5
  CMP.l #"grap",-1(a1)
  BEQ 'l3
  CMP.l #"dosb",-1(a1)
  BEQ 'l3
  CMP.l #"intu",-1(a1)
  BEQ 'l3
  CMP.l #"Allo",-1(a1)
  BEQ 'l3
  CMP.l #"Free",-1(a1)
  BEQ 'l3
  CMP.l #"Wait",-1(a1)
  BEQ 'l3
  CMP.l #"\",d0
  BNE 'p1
  MOVE.b #"`",d0
'p1 CMP.l #"end",-1(a1)
  BEQ 'l4a                           ;endm
  CMP.l #"END",-1(a1)
  BNE 'l4
'l4a
     CMP.b #"m",3(a1)
     BEQ 'l44a
     CMP.b #"M",3(a1)
     BNE 'l4
'l44a
  CMP.b #" ",4(a1)
  BEQ 'l444a
  CMP.b #";",4(a1)
  BEQ  'l444a
  TST.b 4(a1)
  BNE 'l4
'l444a  MOVE.l #"end ",(a2)+
  MOVE.l #"macr",(a2)+
  MOVE.b #"o",d0
  ADD.w #9,d5
  ADDQ.l #4,a1
'l4 CMP.l #" mac",-1(a1)
               ;BRA 'l4c              ;macro
    BEQ 'l4b
    CMP.l #" MAC",-1(a1)
     BNE 'l4c
'l4b
     CMP.w #"ro",3(a1)
     BEQ 'l44b
     CMP.w #"RO",3(a1)
     BNE 'l4c
'l44b
     CMP.b #" ",5(a1)
  BEQ 'l444b
  CMP.b #";",5(a1)
  BEQ  'l444b
  TST.b 5(a1)
  BNE 'l4c
'l444b
     ADDQ.l #5,a1
     ADDQ.w #2,d5
     MOVE.b #" ",(a2)+
     MOVE.l #"macr",(a2)+
     MOVE.w #"o ",(a2)+
     SUBQ.w #5,d1
     MOVE.l a1,-(a7)
     MOVEA.l comPtr_Temp_TokenString2,A1
'n3b MOVE.b (a1)+,d0
  BEQ 'n2b
  CMP.b #" ",d0
  BEQ 'n2b
  CMP.b #":",d0
  BEQ 'n2b
  MOVE.b d0,(a2)+
  ADDQ.w #1,d5
  BRA 'n3b
 'n2b MOVEQ #0,d0
     MOVE.l (a7)+,a1
'l4c
CMP.l #"ovem",(a1)
  BEQ 'mm
  CMP.l #"OVEM",(a1)
  BNE 'mm6
'mm  CMP.b #"m",-1(a1)
  BEQ 'mm2
  CMP.b #"M",-1(a1)
  BNE 'mm6
'mm2
 MOVE.l a1,a0
 MOVEQ #0,d2
'mm3 MOVE.b (a0)+,d3
 BEQ 'mm6
 CMP.b #"(",d3
 BEQ 'mm6
 CMP.b #"-",d3
 BNE 'mm4
 MOVEQ #1,d2
'mm4
 CMP.b #"/",d3
 BNE 'mm5
 MOVEQ #1,d2
'mm5 CMP.b #",",d3
 BNE 'mm3
 TST.l d2
 BNE 'mm6
 MOVE.b #$20,3(a1)
 SUBQ.l #1,a1
 MOVE.l (a1)+,(a2)+
 MOVE.w (a1)+,(a2)+
 SUBQ #6,d1
 BRA 'b1
'mm6
;CMP.w #".W",-1(a1)
;BNE 'l5
;TST.b 1(a1)
;BNE 'l5
;MOVEQ #0,d0
;SUBQ.l #2,d1
'l5  MOVE.b d0,(a2)+

'b1  DBF d1,'l1

'exit
   CMP.b #$0d,-1(a2)
   BNE 'nd0
   CLR.b -1(a2)
   SUBQ.w #1,d5

'nd0 CLR.b (a2)
  MOVE.w d5,d1
   MOVEA.l comPtr_Temp_TokenString2,A1
  LEA tempbuf,a2
   ;MOVEA.l A1,A2
'l10: JSR JL_0_5F62
  MOVEA.l comPtr_Temp_TokenString2,A2
  TST.b convert
  BEQ 'l21
  MOVEQ #0,d0
  MOVE.b (a2)+,d0
  CMP.b #" ",d0
  BNE 'l21
 'l20
  MOVE.b (a2)+,d0
  BEQ 'l21
  CMP.b #" ",d0
  BEQ 'l20
  CMP.b #";",d0
  BEQ 'l21
  CMP.w #$80,d0
  BGE 'l21
  MOVE.b #"!",-2(a2)
 'l21
  MOVEM.l (A7)+,D1-D4/D6-D7/A0-A6
  RTS

 'l3
  ADDQ.l #1,d5
  MOVE.b #"_",(a2)+
BRA 'l4


.detokenize_line:                    ; input A0: tokenized string; returns A1: detokenized string
  CLR.b instring3

  detokenize_line2
    TST.w comWord_DoTokenize
     BEQ.w JL_0_5054
    MOVEQ.l #$00,D0
    MOVE.b (A0)+,D0
    BEQ.w JL_0_5050
    CMP.b #$22,d0
     BNE 'l1
    NOT.b instring3
   'l1
    TST.b instring3
    BNE 'l2
    TST.b d0
    BMI.w JL_0_5040
   'l2
    MOVE.b D0,(A1)+
    BNE.b detokenize_line2

    JL_0_5040:
    LSL.w #8,D0
    MOVE.b (A0)+,D0
    JSR token_to_ascii

    JL_0_5048:
      MOVE.b (A3)+,(A1)+
    BNE.b JL_0_5048
    SUBQ.w #1,A1
  BRA.b detokenize_line2

  JL_0_5050:
  CLR.b (A1)
RTS

JL_0_5054:
  MOVE.l A3,-(A7)
  MOVEA.l A0,A3
  JSR AJL_0_4A8E
  MOVEA.l (A7)+,A3
RTS


JL_0_5060:
  TST.b keepstring
  BNE 'l1
    CLR.b instring2
 'l1
  TST.b comWord__AL_0_8668
   BEQ.w JL_0_5072

  JL_0_506A:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_506A
  SUBQ.w #1,A1
RTS

JL_0_5072:
JL_0_5072a
  MOVEQ.l #$00,D0
  MOVE.b (A0)+,D0
  BEQ.w JL_0_5096
  CMP.b #$22,d0
  BNE 'l10
  NOT.b instring2
 'l10
  TST.b instring2
  BNE 'l11
  TST.b d0
  BMI.w JL_0_5082                    ;morechar
 'l11
  MOVE.b D0,(A1)+
  BNE.b JL_0_5072a

  JL_0_5082:
  LSL.w #8,D0
  MOVE.b (A0)+,D0
  JSR token_to_ascii

  JL_0_508A:
    MOVE.b (A3)+,D1
    BEQ.b JL_0_5072a
    BSET #$7,D1
    MOVE.b D1,(A1)+
  BRA.b JL_0_508A

  JL_0_5096:
  CLR.b (A1)
RTS


.token_to_ascii:
  ;MOVEA.l comPtr_TokenBase,A3       ;findtokenlib $80
  BCLR #$F,D0
  LEA instrtab,a3

  Dc.l $26730400 ;Dc.l $26730600 MOVE.l 0(a3,d0.w*4),a3
  CMP.l #0,a3
  BNE 'l10
  MOVEA.l comPtr_TokenBase,A3
 'JL_0_50A2:
    CMP.w $4(A3),D0
     BEQ.w JL_0_50B4
    TST.l (A3)
     BEQ.w JL_0_50B8
    MOVEA.l (A3),A3
  BRA.b 'JL_0_50A2
 'l10
  ADDQ.w #6,A3
  RTS

  JL_0_50B4:
  MOVE.l a1,-(a7)
  LEA instrtab,a1

  Dc.l $238B0400 ; MOVE.l a3,0(a1,d0.w*4)
  MOVE.l (a7)+,a1
  ADDQ.w #6,A3
  RTS

 JL_0_50B8:
  ;LEA comStr_TokenError,A3
  ;RTS
  !basic
  i = PutD0
  temp$ = "????Lib "+Str$(i LSR 7)+"/"+Str$((i AND $7f)-1)
  MOVE.l temp@(a5),d0
  !asm
  MOVE.l d0,a3
RTS


.get_filename:
  LEA comStr_ASLDummyPath,A0
  LEA comStr_ASLDummyDir,A1
  LEA comStr_FilePattern_NoInfo,A3
BRA.w aslrequest_file


.do_aslfilerequest:
  LEA comStr_ASLLoadFile,A2          ; asl title
  JL_0_50D2:
  LEA comStr_CurrentDir,A0           ; asl dir
  LEA comStr_SourceName,A1           ; asl path
  LEA comStr_FilePattern,A3          ; file pattern (*.bb2 etc.)
BRA.b aslrequest_file


.aslrequest_file:
  MOVE.l #$FFFFFFFF,asl_usepattern
  JSR show_aslfilerequest
  MOVE.l D0,D7
  MOVE.l #$00,asl_usepattern
RTS


asl_usepattern:  Ds.l 1
asl_drawersonly: Ds.l 1
.show_aslfilerequest:
  ; input:
  ; a0: default dir
  ; a1: default file
  ; a2: req title
  ; a3: pattern
  ; a4: -1
  ; a5: -1
  ; a6: windowpointer
  MOVEM.l D1-D7/A0-A6,-(A7)
  MOVEM.l A0-A3,-(a7)
  !basic
  MOVEM.l (A7)+,a0-a3
  MOVE.l a0,D0 : _a0.l = PutD0
  MOVE.l a1,D0 : _a1.l = PutD0
  MOVE.l a2,D0 : _a2.l = PutD0
  MOVE.l a3,D0 : _a3.l = PutD0
  If _a0<>0 Then tmpdir$   = Peek$(_a0)
  If _a1<>0 Then tmpfile$  = Peek$(_a1)
  If _a2<>0 Then tmptitle$ = Peek$(_a2)
  If Peek.w(?use_filepattern)<>0
    If Peek.l(?asl_usepattern)<>0
      If _a3<>0 Then tmppattern$ = Peek$(_a3)
    Else
      tmppattern$ = Peek$(?comStr_FilePattern_NoInfo)
    EndIf
  Else
    tmppattern$ = ""
  EndIf
  If Peek.w(?use_asldims)
    asl_SetRequesterDims{Peek.l(?aslreq_x),Peek.l(?aslreq_y),Peek.l(?aslreq_width),Peek.l(?aslreq_height)}
  EndIf
  aslfr_SetRequesterTitle{1,!TRANS{tmptitle$},"",""}
  aslfr_SetPattern{1,tmppattern$}
  aslfr_SetPath{1,tmpdir$}
  aslfr_SetFile{1,tmpfile$}
  If aslfr_Request{1,False,False,Peek.l(?asl_drawersonly)}
    tempdir$      = aslfr_GetPath{1}
    tempfile$     = aslfr_GetFile{1}
    tempcomplete$ = dos_AddPart{tempdir$ , tempfile$}
  Else
    tempfile$ = ""
  EndIf
  If tempfile$<>""
    Poke.s ?comStr_SourceFileComplete,tempcomplete$
    Poke.s _a0,tempdir$
    Poke.s _a1,tempfile$
    GetD0 ?comStr_SourceFileComplete                       ; replaced &tempcomplete$to remove the Memtrashbug by quit PED and match the privios asmsource
  Else
    MOVEQ.l #0,D0
  EndIf
  !asm
  MOVE.l D0,-(a7)
  JSR save_tempprefs
  MOVE.l (a7)+,D0
  CLR.l asl_drawersonly
  MOVEM.l (A7)+,D1-D7/A0-A6
  MOVEA.l D0,A0
  TST.b D0
  BEQ.w exit_aslfilereq
    TST.b (A0)
    BNE.w exit_aslfilereq
      MOVEQ.l #$00,D0
  exit_aslfilereq:
RTS


;.show_aslfilerequest_old:
;  MOVE.w #-1,use_filepattern         ;bugfix for wrong pref file
;  MOVEM.l D1-D7/A0-A6,-(A7)
;  TST.w use_asldims
;  BNE.w JL_0_510E
;  MOVEQ.l #-$01,D0
;  MOVEQ.l #-$01,D1
;  MOVEQ.l #-$01,D2
;  MOVEQ.l #-$01,D3
;  BRA.w JL_0_5126
;
;  JL_0_510E:
;  MOVE.l aslreq_x,D0
;  MOVE.l aslreq_y,D1
;  MOVE.l aslreq_width,D2
;  MOVE.l aslreq_height,D3
;
;  JL_0_5126:
;  MOVEA.l ptr_sourcewindow,A6        ; window pointer
;  MOVEA.w #-$1,A4 ; positive text
;  MOVEA.w #-$1,A5 ; negativ text
;  JSR open_aslfilerequester
;
;  MOVE.l d0,-(a7)
;  JSR save_tempprefs
;  MOVE.l (a7)+,d0
;
;  CLR.l asl_drawersonly
;  MOVEM.l (A7)+,D1-D7/A0-A6
;  MOVEA.l D0,A0
;  TST.l D0
;  BEQ.w JL_0_5154
;  TST.b (A0)
;  BNE.w JL_0_5154
;  MOVEQ.l #$00,D0
;  JL_0_5154:
;RTS

.show_errorrequester:
  MOVE.l D7,-(A7)

  MOVE.l A0,ptr_errortext
  CMP.l #0,a5
  BNE 'l4
  LEA dummystr + 1,a5
 'l4
  MOVEQ #20,d0
  MOVE.l a5,a0                       ;macro title
  SUBQ.l #1,a0
 'l2
    MOVE.b -(a0),d1
    BEQ 'l1
    CMP.b #":",d1
    BEQ 'l1
    SUBQ.l #1,d0
  BNE 'l2
 'l1
  ADDQ #1,a0
  LEA helpstring,a1
  CMP.l #"INLN",a6
  BNE 'l1x
  LEA helpstring,a1
  ADDQ #4,a1
  MOVE.b #32,(a1)+
 'l1x

  MOVEQ #60,d1
 'l5
    MOVE.b (a0)+,d0
    BEQ 'n1
    MOVE.b d0,(a1)+
    SUBQ.l #1,d1
  BNE 'l5
 'n1
  CLR.b (a1)+
  LEA helpstring,a0
  TST.b (a0)
  BNE 'l1b
  ADDQ.l #4,a0
 'l1b
  MOVE.l expandstore,a1
  JSR detokenize_line
  MOVE.l expandstore,a1
  MOVE.l a1,ptr_errortitle
  ;MOVE.b #">",(a1)
 'l8
    MOVE.b (a1)+,d0
    BEQ 'l9
    CMP.b #":",d0
  BNE 'l8
  ;MOVE.b #"<",-1(a1)
 'l9
  ;LEA easystruct_error,A1
  ;JSR show_requester
  !basic
  MOVE.l D7,d0 : i.l = PutD0
  Format "####"
  Poke$ ?helpstring,Str$(i)
  Format ""

  fid.l = file_Open{dos_AddPart{my_systemdir$,"ab_compileerror.txt"},#file_read}
  If fid <> -1
    errormessage$  = file_ReadLine{fid}
    sourceline$    = file_ReadLine{fid}
    sourcename$    = file_ReadLine{fid}
    l$ = file_ReadLine{fid}
    compilestatus$ = file_ReadLine{fid}
    file_Close{fid}
    If sourcename$ <>"none"
     GetD0 &sourcename$
      If Exists (sourcename$)
        GetD0 &sourcename$
        !asm
        JSR loadfile
        JSR update_statusline
        JSR update_vertscroller
        !basic
      End If
    End If
  Else
    sourceline$ = ""
  End If
  ; building the inforequester:
  *easystruct.EasyStruct = ?easystruct_error

  errortitle$ = !TRANS{"Compile Error"}
  errortext$ = Peek$(*easystruct\es_TextFormat)
  If sourceline$<>""
    errortext$ = !TRANS{"Compile error in line"}+" " + sourceline$ + ":\\n\\n" + !TRANS{errortext$}
  EndIf
  ;  errortext$ + "Status: " + compilestatus$
  If Len(Peek$(?helpstring)) > 5
    errortext$ + "\\n" + Peek$(?helpstring)
  EndIf
;  If Len(Peek$( * easystruct\es_Title)) > 3
;    errortext$ + "\\nadditional info for macros:\\n" + Peek$( * easystruct\es_Title)
;  EndIf

  dummy = RTEZRequest(errortitle$,errortext$,Peek$(*easystruct\es_GadgetFormat))
  !asm
  MOVE.l (A7)+,D7
RTS

.loadfileerror
  MOVE.l D7,-(A7)
  MOVE.l A0,ptr_errortext
  LEA easystruct_error,A1
  JSR show_requester
  MOVE.l (a7)+,d7
RTS



newwindow_compilerwindow:
  Ds.w 1
comwin_y:
  Ds.w 1
comwin_width:
  Ds.w 1
comwin_height:
  Ds.w 1

  Dc.b $01,$02                       ; DetailPen,BlockPen,
  Dc.b $00,$00,$06,$60               ; IDCMPFlags
  Dc.b $00,$00,$10,$0A               ; Flags

comwin_firstgadget:
  Ds.l 2

comwin_title:                        ; ptr_title
  Ds.l 1
comwin_screenptr:                    ; Screen, Bitmap
  Ds.l 2
  Dc.b $FF,$FF,$FF,$FF               ; minwith,minheight
  Dc.b $FF,$FF,$FF,$FF               ; maxwidth,maxheight
  Dc.b $00,$0F                       ; type

AL_0_519C:
  Ds.l 1
AL_0_51A0:
  Ds.l 1
;ptr_ezreqwindow:
;  Ds.l 1


.show_requester
  MOVE.l a1,-(a7)
  !basic
  MOVE.l (a7)+,a1
  MOVE.l a1,d0
  *easystruct.EasyStruct = PutD0
  req_title.s  = Peek$(*easystruct\es_Title)
  req_text.s   = Peek$(*easystruct\es_TextFormat)
  req_gadtex.s = Peek$(*easystruct\es_GadgetFormat)
  dummy        = RTEZRequest (!TRANS{req_title},!TRANS{req_text},!TRANS{req_gadtex})
  !asm
RTS


.compiler_openwindow
  MOVE.l d2,-(a7)
  MOVE.l d1,-(a7)
  !basic
  reg_d0.l = PutD0
  MOVE.l (a7)+,d0
  reg_d1.l = PutD0
  MOVE.l (a7)+,d0
  reg_d2.l = PutD0

  Select reg_d0
  Case 1000
    Gosub open_newtype
    Pop Select
    !asm
    ADD.w #20,a7
    JMP JL_0_CE2

  Case 1001
    Gosub open_cliarguments

  Case 1002
    Gosub open_calculator

  End Select
  !asm
RTS

.comwin_open:                        ; fuer alle compilerfenster, etc.
  MOVE.l A0,comPtr_CompilerWindowStructur ; A0 enthaelt windowstruktur des compilers
  MOVEA.l A0,A2
  MOVEA.l $14(A2),A1                 ; pointer auf STOP-gadget
  !basic
  error{"routine comwin_open called. When does this occur ??"}
  !asm
  JL_0_527C:
    MOVE.l $4(A1),D0
    CMP.l #$2010103,D0
    BEQ.w JL_0_52A0
    CMP.l #$1020103,D0
    BNE.w JL_0_52A8
    MOVE.l #$2010103,$4(A1)
    BRA.w JL_0_52A8

    JL_0_52A0:
    MOVE.l #$1020103,$4(A1)

    JL_0_52A8:
    TST.l $8(A1)
    BEQ.w JL_0_52BA
    MOVEA.l $8(A1),A1
    LEA $C(A1),A1
  BRA.b JL_0_527C

  JL_0_52BA:
  MOVE.l $8(A0),comwin_width
  ADDI.w #$C,comwin_width
  ADDI.w #$F,comwin_height
  MOVE.w visiblecolumns,D0
  LSL.w #3,D0
  SUB.w comwin_width,D0
  LSR.w #1,D0
  MOVE.w D0,newwindow_compilerwindow ; hier xposition des Fensters im struct newwindow

  MOVE.l A1,-(A7)
  MOVEA.l ptr_pedscreen,A1
  MOVE.w $E(A1),D0
  MOVEA.l (A7)+,A1
  SUB.w comwin_height,D0
  LSR.w #1,D0
  MOVE.w D0,comwin_y
  MOVEA.l $10(A0),A1
  MOVE.l A1,comwin_firstgadget
  TST.w $28(A1)
  BNE.b JL_0_5324
  MOVE.w #$FFFF,$28(A1)

  JL_0_5314:
    ADDQ.w #6,$4(A1)
    ADDI.w #$C,$6(A1)
    MOVE.l (A1),D0
    MOVEA.l D0,A1
  BNE.b JL_0_5314

  JL_0_5324:
  MOVE.l ptr_pedscreen,comwin_screenptr
  LEA newwindow_compilerwindow,A0
  CMP.l #$011c00bb,4(a0)
  BEQ call_newtype

  MOVEA.l _intuibase,A6
  MOVE.l a0,d0
  MOVE.b #$0,$e+3(a0)
  !basic
  *nw_.NewWindow = PutD0
  *gad2_.Gadget = *nw_\FirstGadget
  While *gad2_
    If *gad2_\GadgetText
      *gad2_\GadgetText\ITextFont = ?topaz_font
    End If
    *gad2_ = *gad2_\NextGadget
  Wend
  !asm
  ;MOVE.l ptr_pedscreen,a1
  ;MOVE.l $28(a1),-(a7)
  ;MOVE.l topaz_font,$28(a1)
  JSR _OpenWindow(A6)                ; open find, goto, etc. windows
  ;MOVE.l (a7)+,d1
  ;MOVE.l ptr_pedscreen,a1
  ;MOVE.l d1,$28(a1)
  TST.l D0
  BEQ.w JL_0_4942
  MOVE.l AL_0_519C,AL_0_51A0
  MOVE.l comPtr_CompilerWindow,AL_0_519C
  MOVE.l D0,comPtr_CompilerWindow
;  JSR settopaz8
  MOVEA.l comPtr_CompilerWindow,A0
  MOVEA.l $32(A0),A0
  MOVEA.l comPtr_CompilerWindowStructur,A1
  MOVEA.l $18(A1),A1                 ; itext laden
  MOVEQ.l #$06,D0
  MOVEQ.l #$0C,D1
  MOVE.l A0,-(A7)
   JSR _PrintIText(A6)               ; a0:rp, a1:IText, d0: Leftoffset, d1: TopOffset
  MOVEA.l (A7)+,A0
  MOVEA.l comPtr_CompilerWindowStructur,A1
  MOVEA.l $14(A1),A1                 ; borderstruktur laden
  MOVEQ.l #$06,D0
  MOVEQ.l #$0C,D1
  JSR _DrawBorder(A6)
  ADDQ.w #1,AL_0_5388
RTS


.call_newtype
  !basic
  Gosub open_newtype
  !asm
  ADD.w #20,a7
JMP JL_0_CE2


;; fuer das alte compilestatus fenster
AL_0_5388:    Ds.w 1

comwin_close:
  MOVEM.l D0-D1/A0-A2/A6,-(A7)
  SUBQ.w #1,AL_0_5388
  MOVE.l comPtr_CompilerWindow,D0
  BEQ.w JL_0_543A
  MOVEA.l D0,A2
  MOVEA.l _execbase,A6
  MOVEA.l $56(A2),A2                 ; UserPort->MsgPort

  JL_0_53A6:
    MOVEA.l A2,A0
    JSR _GetMsg(A6)
    TST.l D0
    BEQ.b JL_0_53B8
    MOVEA.l D0,A1
    JSR _ReplyMsg(A6)
  BRA.b JL_0_53A6

  JL_0_53B8:
  MOVEA.l comPtr_CompilerWindow,A0
  MOVEA.l _intuibase,A6
  JSR _ClearPointer(A6)
  MOVEA.l comPtr_CompilerWindow,A0
  JSR _CloseWindow(A6)
  MOVE.l #$0,comwin_title
  MOVE.l AL_0_519C,comPtr_CompilerWindow
  MOVE.l AL_0_51A0,AL_0_519C
  CLR.l AL_0_51A0
  MOVEA.l comPtr_CompilerWindowStructur,A0
  MOVEA.l A0,A2
  MOVEA.l $14(A2),A1

  JL_0_53F8:
    MOVE.l $4(A1),D0
    CMP.l #$2010103,D0
    BEQ.w JL_0_541C
    CMP.l #$1020103,D0
    BNE.w JL_0_5424
    MOVE.l #$2010103,$4(A1)
    BRA.w JL_0_5424

    JL_0_541C:
    MOVE.l #$1020103,$4(A1)

    JL_0_5424:
    TST.l $8(A1)
    BEQ.w JL_0_5436
    MOVEA.l $8(A1),A1
    LEA $C(A1),A1
  BRA.b JL_0_53F8

  JL_0_5436:
  JSR check_intuimsg

  JL_0_543A:
;  JSR JL_0_D82
  JSR arexxfunc_activate
  MOVEM.l (A7)+,D0-D1/A0-A2/A6
RTS

.check_intuimsg:
  TST.l ptr_sourcewindow
   BEQ.w exit_check_intuimessage
  MOVEA.l ptr_sourcewindow,A2
  MOVEA.l _execbase,A6
  MOVEA.l $56(A2),A2                 ; Window\UserPort

  JL_0_5460:
    MOVEA.l A2,A0
    JSR _GetMsg(A6)
    TST.l D0
     BEQ.b exit_check_intuimessage
    MOVEA.l D0,A1
    JSR _ReplyMsg(A6)
  BRA.b JL_0_5460

  exit_check_intuimessage:
RTS

JL_0_5474:
  CMPI.l #$1,comLong_TotalLines
  BEQ.w JL_0_54EA
  SUBQ.l #1,comLong_TotalLines
  MOVE.l (A5),D1
  MOVE.l $4(A5),D2
  BEQ.w JL_0_54A4
  TST.l D1
  BEQ.w JL_0_54B4
  MOVEA.l D2,A0
  MOVE.l D1,(A0)
  MOVEA.l D1,A0
  MOVE.l D2,$4(A0)
  BRA.w JL_0_54BE

  JL_0_54A4:
  MOVE.l D1,comPtr_FirstSourceLine
  MOVEA.l D1,A0
  CLR.l $4(A0)
  BRA.w JL_0_54BE

  JL_0_54B4:
  MOVE.l D2,comPtr_LastSourceLine
  MOVEA.l D2,A0
  CLR.l (A0)
  JL_0_54BE:
  MOVEA.l A5,A1
  MOVE.b comByte_LabelIdentifier,D0
  MOVE.l A0,-(A7)
  LEA $9(A1),A0
  JL_0_54CA:
  CMPI.b #$20,(A0)+
  BEQ.b JL_0_54CA
  CMP.b -(A0),D0
  MOVEA.l (A7)+,A0
  BNE.w JL_0_54Dca
  JSR JL_0_472A
  JL_0_54Dca:
  ST comWord__AL_0_86C0
  MOVEA.l _execbase,A6
 !newfree
RTS
; JMP _FreeVec(A6)

JL_0_54EA:
   JSR JL_0_5B08
BRA.b JL_0_54BE


.move_to_blockstarty:                ; in A4: currentsourceline, out A5: adjusted currentsourceline
  MOVEA.l A4,A5                      ; -- copy currentline to A5
  MOVE.l comLong_DisplayLineOffset,D7
  ADD.l comLong_DisplayLine,D7
  MOVE.l D7,D6

  CMP.l comLong_BlockStartY,D6
   BEQ.w JL_0_5522
   BCC.w JL_0_5516

  JL_0_5508:
    MOVEA.l (A5),A5
    ADDQ.l #1,D6
  CMP.l comLong_BlockStartY,D6
  BNE.b JL_0_5508
  BRA.w JL_0_5522

  JL_0_5516:
    MOVEA.l $4(A5),A5
    SUBQ.l #1,D6
  CMP.l comLong_BlockStartY,D6
  BNE.b JL_0_5516

  JL_0_5522:
RTS

JL_0_5524:
  BSR.b move_to_blockstarty
  MOVE.w comLong_BlockStartX,D5

  MOVE.w comWord_DoTokenize,D0
  BEQ.w JL_0_5538
  BRA.w JL_0_553A

  JL_0_5538:
RTS

JL_0_553A:
  MOVEA.l comPtr_Temp_TokenString3,A0
  CMP.l #0,a5
    BEQ 'l1
  LEA $9(A5),A1
  ADDQ.w #1,A0
  JSR JL_0_5556
  MOVE.l A0,D0
  SUB.l comPtr_Temp_TokenString3,D0
  MOVEA.l comPtr_Temp_TokenString3,A0
  MOVE.b D0,(A0)
 'l1
RTS

JL_0_5556:
  CLR.b instring3
  JL_0_5556b:
  MOVE.b (A1)+,D0                    ;cut token
  BEQ.w JL_0_5574
  CMP.b #$22,d0
   BNE 'l1
  NOT.b instring3
 'l1
  TST.b instring3
  BNE 'l2
  TST.b d0
   BMI.w JL_0_5564
 'l2
  MOVE.b D0,(A0)+
  BRA.b JL_0_5556b

  JL_0_5564:
  LSL.w #8,D0
  MOVE.b (A1)+,D0
  JSR token_to_ascii
  JL_0_556C:
  MOVE.b (A3)+,(A0)+
   BNE.b JL_0_556C
  SUBQ.w #1,A0
  BRA.b JL_0_5556b

  JL_0_5574:
RTS

.update_currsourceline:
  MOVEA.l comPtr_FirstSourceLine,A4
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  BEQ.w JL_0_558E
  ;SUBQ.l #1,D0

  JL_0_5588:
    MOVEA.l (A4),A4
    SUBQ.l #1,d0
    ; DBF D0,JL_0_5588
  BNE JL_0_5588

  JL_0_558E:
  MOVE.l A4,comPtr_CurrentSourceLine
RTS

JL_0_5596:
  MOVE.l A3,D5
  SUB.l comPtr_Temp_TokenString1,D5
  ADDQ.l #1,D5
BRA.w JL_0_55AA

JL_0_55A2:
  MOVEA.l comPtr_Temp_TokenString2,A2
  JSR parse_line

  JL_0_55AA:
  MOVE.l D5,D0
  ADDI.w #$9,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
   JSR JL_0_492E
  MOVEA.l D0,A0
  MOVEA.l comPtr_Temp_TokenString1,A1
  MOVE.b comByte_LabelIdentifier,D0
  MOVE.l A1,-(A7)

  JL_0_55C6:
  CMPI.b #$20,(A1)+
   BEQ.b JL_0_55C6
  CMP.b -(A1),D0
   ;BNE.w JL_0_55D8                  ;clickpretest
    BEQ 'l10
 'l20
  MOVE.b (a1),d0                     ;pre clicksort
  BEQ JL_0_55D8
  CMP.b #";",d0
  BEQ 'l10
  CMP.b #$80,d0
  BNE 'l15
  CMP.b #$2d,1(a1)                   ;stop
  BEQ 'l10
  CMP.b #$ae,1(a1)                   ;trap
  BEQ 'l10
 'l15
  ADDQ.l #1,a1
  BRA 'l20
 'l10
  JSR JL_0_46CC

  JL_0_55D8:
  MOVEA.l (A7)+,A1
  CMPA.l comPtr_FirstSourceLine,A4
   BNE.w JL_0_55E6
  MOVE.l A0,comPtr_FirstSourceLine

  JL_0_55E6:
  CMPA.l comPtr_LastSourceLine,A4
   BNE.w JL_0_55F4
  MOVE.l A0,comPtr_LastSourceLine

  JL_0_55F4:
  MOVE.b D5,$8(A0)
  MOVE.l $4(A4),D1
   BEQ.w JL_0_5604
  MOVEA.l D1,A1
  MOVE.l A0,(A1)

  JL_0_5604:
  MOVE.l D1,$4(A0)
  MOVE.l (A4),D1
   BEQ.w JL_0_5614
  MOVEA.l D1,A1
  MOVE.l A0,$4(A1)

  JL_0_5614:
  MOVE.l D1,(A0)
  MOVEA.l A0,A4
  LEA $9(A0),A0
  MOVEA.l comPtr_Temp_TokenString1,A1

  JL_0_5620:
  MOVE.b (A1)+,(A0)+
   BNE.b JL_0_5620
  JSR JL_0_6C04
  MOVE.l A4,comPtr_CurrentSourceLine
RTS

JL_0_5630:
  CMP.w comWord_MaxColumns,D5
   BGE.w JL_0_568C
  CMP.l comLong_BlockEndY,D6
   BCS.w JL_0_5650
   BNE.w JL_0_564C
  CMP.w comLong_BlockEndX,D5
   BLS.w JL_0_5650

  JL_0_564C:
  MOVEQ.l #-$01,D0
RTS

JL_0_5650:
  ADDQ.w #1,D5
  MOVE.w comWord_DoTokenize,D0
   BEQ.w JL_0_5670
  MOVEA.l comPtr_Temp_TokenString3,A3
  CMP.b (A3),D5
   BCC.w JL_0_5680
  MOVEQ.l #$00,D0
  MOVE.b $0(A3,D5.W),D0
  TST.w D0
RTS

JL_0_5670:
  CMP.b $8(A5),D5
   BCC.w JL_0_5680
  MOVEQ.l #$00,D0
  MOVE.b $8(A5,D5.W),D0
RTS

JL_0_5680:
  MOVE.w comWord__AL_0_8AD8,D0
   BNE.w JL_0_568C
  MOVEQ.l #$20,D0
RTS

JL_0_568C:
  MOVEA.l (A5),A5
  ADDQ.l #1,D6
  MOVEQ.l #$00,D5
  MOVEQ.l #$00,D0
RTS

L_0_5696:
  Dc.b $00,$00,$00,$C9
  Dc.b $00,$00,$00,$CA
  Dc.b $00,$00,$00,$D8
  Dc.b $00,$00,$00,$CC
  Dc.b $00,$00,$00,$CD
  Dc.b $00,$00,$00,$D2
  Dc.b $00,$00,$00,$D3
  Dc.b $00,$00,$00,$D7

AL_0_56B6:  Dc.l $CB

JL_0_56BA:
  TST.l AL_0_B90
   BNE.w JL_0_56C6
RTS

JL_0_56C6:
  MOVEM.l D0-D3/A0-A1,-(A7)
  MOVEA.l addr_menustrip,A1
  LEA L_0_5696,A0
  MOVEA.l (A1),A1
  MOVEA.l $12(A1),A1
  MOVE.l (A0),D0

  JL_0_56Dca:
  CMP.l $22(A1),D0
   BEQ.w JL_0_56F2
  MOVEA.l (A1),A1
  CMPA.l #$0,A1
   BNE.b JL_0_56Dca
  BRA.w JL_0_570C

  JL_0_56F2:
  ORI.w #$10,$C(A1)
  MOVEA.l addr_menustrip,A1
  MOVEA.l (A1),A1
  MOVEA.l $12(A1),A1
  ADDQ.l #4,A0
  MOVE.l (A0),D0
  TST.l (A1)
  BNE.b JL_0_56Dca
  JL_0_570C:
;  LEA str_block,A0
;  MOVE.l #$626C6F63,(A0)             ; "block"
;  MOVE.b #"k",$4(A0)
;   JSR JL_0_5726
  MOVEM.l (A7)+,D0-D3/A0-A1
RTS

;JL_0_5726:
;!basic
;!cout{"called."}
;!asm
;  MOVEQ.l #$2C,D0
; JMP update_statusline

JL_0_572C:
  CLR.l AL_0_56B6
  TST.l AL_0_B90
  BNE.w JL_0_5746
  MOVE.l #$CB,AL_0_56B6

  JL_0_5746:
  MOVEM.l D0-D3/A0-A1,-(A7)
  MOVEA.l addr_menustrip,A1
  LEA L_0_5696,A0
  MOVEA.l (A1),A1
  MOVEA.l $12(A1),A1
  MOVE.l (A0),D0

  JL_0_575C:
    CMP.l $22(A1),D0
     BEQ.w JL_0_5772
    MOVEA.l (A1),A1
    CMPA.l #$0,A1
     BNE.b JL_0_575C
    BRA.w JL_0_578C

    JL_0_5772:
    ANDI.w #$FFEF,$C(A1)
    MOVEA.l addr_menustrip,A1
    MOVEA.l (A1),A1
    MOVEA.l $12(A1),A1
    ADDQ.l #4,A0
    MOVE.l (A0),D0
    TST.l (A1)
  BNE.b JL_0_575C

  JL_0_578C:
  MOVE.w #$FFFF,AL_0_4280
  MOVE.l #$ffffFFFF,comLong_BlockEndY
;  LEA str_block,A0
;  MOVE.l #$20202020,(A0)
;  MOVE.b #$20,$4(A0)
;   JSR JL_0_5726
  MOVEM.l (A7)+,D0-D3/A0-A1
RTS

JL_0_57B6:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w JL_0_57DE
  CMP.l comLong_BlockEndY,D0
   BHI.w JL_0_57DE
  ADDQ.l #1,comLong_BlockEndY
  CMP.l comLong_BlockStartY,D0
   BHI.w JL_0_57DE
  ADDQ.l #1,comLong_BlockStartY

  JL_0_57DE:
RTS


JL_0_57E0:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w JL_0_57F0
  JSR _redraw
  JL_0_57F0:
RTS

JL_0_57F2:
  ;MOVE.l comWord_Column,-(A7)
  MOVE.w comWord_Column,-(A7)
  MOVE.l comLong_DisplayLine,-(A7)
  MOVEM.w D2-D3/D5,-(A7)
  SUB.w comWord_ColumnsOffset,D2
   BPL.w JL_0_5808
  MOVEQ.l #$00,D2
  BRA.w JL_0_5816

  JL_0_5808:
  CMP.w comWord_MaxColumns,D2
   BCS.w JL_0_5816
  MOVE.w comWord_MaxColumns,D2
  SUBQ.w #1,D2

  JL_0_5816:
  MOVE.w D2,comWord_Column
  MOVE.w D3,comLong_DisplayLine+2
   JSR update_horizscroller
   JSR update_vertscroller
  MOVEM.w (A7)+,D2-D3/D5
  ;MOVE.l (A7)+,comWord_Column
  MOVE.l (A7)+,comLong_DisplayLine
  MOVE.w (A7)+,comWord_Column
RTS

JL_0_5836:
  MOVE.w comLong_BlockStartX,D0
  MOVE.l comLong_BlockStartY,D1
  MOVE.w comLong_BlockEndX,D2
  MOVE.l comLong_BlockEndY,D3
  CMP.l D3,D1
   BCS.w JL_0_5872
   BEQ.w JL_0_586E
  JL_0_5850:
  EXG.l D0,D2
  EXG.l D1,D3
  MOVE.w D0,comLong_BlockStartX
  MOVE.l D1,comLong_BlockStartY
  MOVE.w D2,comLong_BlockEndX
  MOVE.l D3,comLong_BlockEndY
RTS

JL_0_586E:
  CMP.w D2,D0
   BGT.b JL_0_5850
  JL_0_5872:
RTS

JL_0_5874:
  CMP.w D3,D1
   BCS.w JL_0_5888
   BNE.w JL_0_5884
  CMP.w D2,D0
   BLE.w JL_0_5888

  JL_0_5884:
  EXG.l D0,D2
  EXG.l D1,D3

  JL_0_5888:
RTS


._redraw:
  MOVE.l comLong_BlockEndY,-(A7)
  MOVE.l #$ffffFFFF,comLong_BlockEndY
  JSR save_cursorposition
  JSR clear_sourcewindow
  MOVEA.l comPtr_CurrentSourceLine,A2
  CMPA.l #$0,A2
  BNE.w JL_0_58B6
  MOVE.l (A7)+,comLong_BlockEndY
RTS

JL_0_58B6:
  CNIF #hardfold = 1
  JSR getfoldstatus
  CEND

  MOVE.l comLong_DisplayLine,D1

  JL_0_58BA:
  BEQ.w JL_0_58C6
  MOVE.l $4(A2),d0
  BEQ JL_0_58C6
  MOVE.l d0,a2

  CNIF #hardfold = 0
  BRA 'l3
  CEND

  CMP.w #";@",9(a2)
  BNE 'l2
  BSR doreverse
  CMP.w #"@0",11(a2)
  BNE 'l2
  TST.l foldnum
  BNE 'l3
 'l2
  TST.l foldnum
  BNE JL_0_58BA
 'l3
  SUBQ.l #1,D1
BRA.b JL_0_58BA


.getfoldstatus
  CLR.l foldnum
  MOVE.l a1,-(a7)
  MOVE.l comPtr_FirstSourceLine,d0
  BEQ 'out
 'l1
    MOVE.l d0,a1
    CMP.l a2,a1
    BEQ 'out
    CMP.w #";@",9(a1)
    BNE 'l2
    CMP.w #"@1",11(a1)
    BNE 'no1
    MOVE.l #1,foldnum
   'no1
    CMP.w #"@0",11(a1)
    BNE 'no2
    MOVE.l #0,foldnum
   'no2
   'l2
    MOVE.l (a1),d0
  BNE 'l1
 'out
  realline
  MOVE.l (a7)+,a1
RTS

doreverse
'dorev
CMP.w #"@0",11(a2)                   ;reverse ok !!!
BNE 'no1
MOVEM.l d0/a1,-(a7)
MOVE.l #0,foldnum
MOVE.l 4(a2),d0
BEQ 'lp4
'lp1 MOVE.l d0,a1                    ;check if previous is ;@@1
CMP.w #";@",9(a1)
BNE 'lp2
CMP.w #"@1",11(a1)
BNE 'lp3
MOVE.l #1,foldnum
BRA 'lp4                             ;block is folded
'lp3
CMP.w #"@0",11(a1)
BEQ 'lp4
'lp2
 MOVE.l 4(a1),d0
 BNE 'lp1
'lp4 MOVEM.l (a7)+,a1/d0
'no1
CMP.w #"@1",11(a2)
BNE 'no2
MOVE.l #0,foldnum
'no2
'l2
;MOVE.l a1,a2
RTS


JL_0_58C6:
  MOVE.w D1,comLong_DisplayLine+2
;  CLR.l comLong__AL_0_868A
  CLR.w comWord_TextBufferOffset
  CLR.l foldnum
  MOVE.l #-1,BetterRefresh_FillEndOfLine
  MOVE.l viewablelines,D7
  SUBQ.l #1,D7
  MOVE.w comWord_ColumnsOffset,comWord__AL_0_869A
  MOVE.l comLong_LinePosStartY,d0

  JL_0_58E8:                         ;print whole window
    CNIF #hardfold = 1
   'nr
      CMP.l #";@@1",9(a2)
      BNE 'l1
      MOVE.l #1,foldnum
      BRA 'do
     'l1
      CMP.l #";@@0",9(a2)
      BNE 'l2
      MOVE.l #0,foldnum
     'l2
      MOVE.l comLong_DisplayLine,d0
      CMP.l store_comLong_DisplayLine,d0
      BNE 'l3b
      ;MOVE.l a2,comPtr_CurrentSourceLine
     'l3b
      TST.l foldnum
      BEQ 'do
      MOVE.l (a2),d0
      BEQ JL_0_5902
      MOVE.l d0,a2
    BRA 'nr
   'do
    CEND

    MOVE.l (A2),-(A7)
    JSR print_sourceline
    JSR update_modifiermark
    MOVE.l (A7)+,D0
    BEQ.w JL_0_5902
    MOVEA.l D0,A2
    JSR JL_0_640C
  DBF D7,JL_0_58E8

  JL_0_5902:
   MOVE.l #0,BetterRefresh_FillEndOfLine
  ; better refresh: clear bottom
  MOVE.l backgroundcolor,d0   ;: ADD.l #3,d0
  MOVEA.l _graphicsbase,A6
  MOVEA.l rp_sourcewindow,A1
  JSR _SetAPen(A6)

  MOVEA.l _graphicsbase,A6
  MOVEA.l rp_sourcewindow,A1

  MOVE.w #0,D0

  MOVE.l comLong_DisplayLine,D1
  MULU fontheight,D1

 ; MOVE.w $26(A1),D1
;  SUB.w font_Baseline,D1
  ADD.w  fontheight,D1
  MOVE.w win_InnerWidth,D2
  MOVE.w ypos_statusarea ,D3
  JSR _RectFill(A6)                  ;A1:rp, D0:x min, D1:ymin, D2:xmax, D3:ymax  d0-d3:16

  JSR restore_cursorposition
  MOVE.l (A7)+,comLong_BlockEndY

  JL_0_590C:
  TST.l comLong_BlockEndY
   BMI.w JL_0_59BA
  MOVEA.l _graphicsbase,A6
  MOVEA.l comPtr_SourceAreaRastPort,A1
  MOVE.w comLong_BlockStartX,D0
  MOVE.w comLong_BlockEndX,D2
  MOVE.l comLong_BlockEndY,D3
  MOVE.l comLong_BlockStartY,D1
  MOVE.l comLong_DisplayLineOffset,D4
  MOVE.l D4,D5
  ADD.l viewablelines,D5
  SUB.w comWord_ColumnsOffset,D0
   BPL.w JL_0_5954
  MOVEQ.l #$00,D0

  JL_0_5954:
  CMP.l D4,D3
   BLT.w JL_0_59BA
  SUB.l comLong_DisplayLineOffset,D1
   BPL.w JL_0_5968
  MOVEQ.l #$00,D0
  MOVEQ.l #$00,D1

  JL_0_5968:
  SUB.w comWord_ColumnsOffset,D2
   BPL.w JL_0_5974
  MOVEQ.l #$00,D2

  JL_0_5974:
  SUB.l comLong_DisplayLineOffset,D3
   BPL.w JL_0_5980
  MOVEQ.l #$00,D3

  JL_0_5980:
  MOVE.l viewablelines,D5
  CMP.l D5,D1
   BGE.w JL_0_59BA
  CMP.l D5,D3
   BLE.w JL_0_5998
  MOVE.l viewablelines_m1,D3

  JL_0_5998:
  CMP.w visiblecolumns,D2
   BLT.w JL_0_59AA
  MOVE.w visiblecolumns,D2
  SUBQ.w #1,D2

  JL_0_59AA:
  ADD.w comWord_ColumnsOffset,D0
  ADD.w comWord_ColumnsOffset,D2
  BRA.w JL_0_59C0

  JL_0_59BA:
RTS

JL_0_59BC:                           ;redraw mark
  JSR JL_0_5874
  JL_0_59C0:
  MOVEM.l D0-D3/A0-A1,-(A7)

  TST.w D0
   BPL.w JL_0_59CC
  MOVEQ.l #$00,D0

  JL_0_59CC:
  TST.w D2
   BPL.w JL_0_59D8
  MOVEQ.l #$00,D2
  BRA.w JL_0_59DA

  JL_0_59D8:
  ADDQ.w #1,D2

  JL_0_59DA:
  TST.w D1
   BPL.w JL_0_59E2
  MOVEQ.l #$00,D1

  JL_0_59E2:
  TST.w D3
   BPL.w JL_0_59EA
  MOVEQ.l #$00,D3

  JL_0_59EA:
  MOVEA.l _graphicsbase,A6
  SUB.w comWord_ColumnsOffset,D2
  SUB.w comWord_ColumnsOffset,D0
  CMP.w visiblecolumns,D2
   BLE.w JL_0_5A08
  MOVE.w visiblecolumns,D2

  JL_0_5A08:
  CMP.l viewablelines_m1,D3
   BLE.w JL_0_5A18
  MOVE.l viewablelines_m1,D3

  JL_0_5A18:
  CMP.l viewablelines_m1,D1
   BLE.w JL_0_5A28
  MOVE.l viewablelines_m1,D1

  JL_0_5A28:
  MULU fontheight,D1
  MULU fontheight,D3
  ;ASL.w #3,D0
  ;ASL.w #3,D2
  MULU fontwidth,d0
  MULU fontwidth,d2
  CMP.l D1,D3
   BGE.w JL_0_5A3C
  EXG.l D1,D3

  JL_0_5A3C:
  CMP.w D1,D3
   BNE.w JL_0_5A52
  ADD.w font_Heightm1,D3
  JSR JL_0_5AA6
  MOVEM.l (A7)+,D0-D3/A0-A1
RTS

JL_0_5A52:
  MOVEM.l D0-D3,-(A7)
  MOVE.l D1,D3
  ADD.w font_Heightm1,D3
  MOVEQ.l #$00,D2
  MOVE.w visiblecolumns,D2
  ;ASL.w #3,D2
  MULU fontwidth,d2
   JSR JL_0_5AA6
  MOVEM.l (A7)+,D0-D3
  ADD.w fontheight,D1
  CMP.w D1,D3
   BLE.w JL_0_5A96
  MOVEM.l D0-D3,-(A7)
  SUBQ.w #1,D3
  MOVEQ.l #$00,D2
  MOVE.w visiblecolumns,D2
  ;ASL.w #3,D2
  MULU fontwidth,d2
  MOVEQ.l #$00,D0
   JSR JL_0_5AA6
  MOVEM.l (A7)+,D0-D3
  MOVEQ.l #$00,D0
  MOVE.l D3,D1

  JL_0_5A96:
  MOVEQ.l #$00,D0
  ADD.w font_Heightm1,D3
  JSR JL_0_5AA6
  MOVEM.l (A7)+,D0-D3/A0-A1
RTS


JL_0_5AA6:
  MOVEA.l _graphicsbase,A6           ; added by Thilo for security
  SUBQ.w #1,D2
  MOVEA.l comPtr_SourceAreaRastPort,A1
  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16
RTS


.get_mousepos:                       ;get screenpos for click
  MOVE.l ptr_sourcewindow,a0
  MOVE.w $C(A0),D1                   ; MouseY-Window
  ADD.w #1,D1

;  SUB.w AL_0_B7EE,D1
  TST.w D1
  BPL.w JL_0_5ACA
  MOVEQ.l #$00,D1

  JL_0_5ACA:
  MOVE.w win_BorTop,D2               ; win_TopEdge
  CMP.w D2,D1
   BLS.w JL_0_5AF4
  ADD.w ypos_statusarea,D2
  CMP.w D2,D1
   BCC.w JL_0_5AF4

  MOVE.w $e(A0),D0                   ; MouseX-Window
  SUB.w win_BorLef,D0
  BGT 'l1                            ; wenn weniger als borleft, auf borleft setzen
  MOVEQ #0,d0
 'l1
;  BRA 'n2
;  MOVE.w $12(A0),D0                 ; MinHeight-Window
; 'n2
  MOVE.w D0,D2
  MOVEQ.l #$00,D3
  MOVE.w D1,D3
  SUB.w win_BorTop,D3                ; win _TopEdge
  ;LSR.w #3,D2
  EXT.l d2
  DIVU fontwidth,d2
  DIVU fontheight,D3
  EXT.l d3
RTS

JL_0_5AF4:
  MOVE.w $12(A0),D0                  ; MinHeight
  MOVE.w D0,D2
  EXT.l d2
  ;LSR.w #3,D2
  DIVU fontwidth,d2
  MOVEQ.l #-$01,D3
RTS

JL_0_5B00:
  JSR JL_0_5B08
JMP clear_sourcewindow_visual

JL_0_5B08:
  JSR allocnewline
  BEQ.w JL_0_5B22
  MOVE.l A0,comPtr_FirstSourceLine
  MOVE.l A0,comPtr_LastSourceLine
  MOVE.l A0,comPtr_CurrentSourceLine
  JL_0_5B22:
RTS


JL_0_5B24:
  MOVEA.l comPtr_CurrentSourceLine,A2
   JSR save_cursorposition
;  CLR.l comLong__AL_0_868A
  CLR.w comWord_TextBufferOffset
  MOVE.l comLong_DisplayLine,D1

  JL_0_5B3C:
    BEQ.w JL_0_5B4E
    MOVE.l $4(A2),D0
    BEQ.w JL_0_5B58
    MOVEA.l D0,A2
    SUBQ.w #1,D1
  BRA.b JL_0_5B3C

JL_0_5B4E:                           ;Print 1 Line down
  MOVE.w D1,comLong_DisplayLine+2
  JSR print_sourceline
  JL_0_5B58:
  JSR restore_cursorposition
BRA.w JL_0_612C

JL_0_5B60:
  MOVEA.l comPtr_CurrentSourceLine,A2
  JSR save_cursorposition
  JL_0_5B68:
    MOVE.l comLong_DisplayLine,D0
    ADDQ.l #1,D0
    CMP.l viewablelines,D0
     BCC.w JL_0_5B84
    MOVE.l (A2),D0
     BEQ.w JL_0_5B88
    MOVEA.l D0,A2
     JSR JL_0_640C
  BRA.b JL_0_5B68

  JL_0_5B84:                         ;print 1 line up
  JSR print_sourceline
  JL_0_5B88:
  JSR restore_cursorposition
BRA.w JL_0_60FE

.print_current_sourceline:
  MOVEA.l comPtr_CurrentSourceLine,A2
BRA.w print_sourceline

AL_0_5B9A:    Ds.l 1
AL_0_5B9E:    Ds.l 1
AL_0_5BA2:    Ds.l 1
AL_0_5BA6:    Ds.l 1
AL_0_5BAA:    Ds.l 1
expandstore:  Ds.l 1
AL_0_5BB2:    Ds.l 1

JL_0_5BB6:                           ;type text
  TST.w comWord_CursorInMarkedBlock
  BEQ.w JL_0_5BF4
  !basic
  Request "","JL_0_5BB6","OK"
  !asm
  ; --- print actual character with blockbackgroundcolor
  MOVEM.l D0-D1/A0,-(A7)
  MOVEA.l _graphicsbase,A6
  MOVEA.l rp_sourcewindow,A1
  MOVEQ.l #$03,D0
  JSR _SetBPen(A6)
  MOVEM.l (A7)+,D0-D1/A0

  MOVEQ.l #$01,D2
  MOVE.w othercolor,D3
  JSR print_text                     ;type
  MOVEA.l rp_sourcewindow,A1
  MOVE.l backgroundcolor,D0
JMP _SetBPen(A6)

JL_0_5BF4:
  MOVEQ.l #$01,D2
  MOVEQ.l #$00,D3
  TST.w (A0)
   BPL.w JL_0_5C0C
  TST.w instru
   BEQ 'l1
  BCLR #$7,(A0)                      ;morechar ok
 'l1
  MOVE.w classiccolor,D3
  BRA.w print_text
  JL_0_5C0C:

  MOVE.w othercolor,D3
  JSR print_text
RTS


.print_complete_line:
  MOVE.l D2,-(A7)
  MOVEA.l AL_0_5BAA,A2
  MOVE.l #MAX_Columns/4,D2
  SUBQ.l #1,d2
  JL_0_5C20:
    CLR.l (A2)+
  DBF D2,JL_0_5C20

  MOVEA.l _intuibase,A6

  TST.w comWord_DoTokenize
  BNE.w tokenized_text

  JSR print_standard_text            ; print standard, non-tokenized text
  BRA.w exit_print_complete_line

  tokenized_text:
  MOVE.w comWord_MaxColumns,D4
  SUBQ.w #1,D4
  MOVEA.l AL_0_5BA6,A1

  JL_0_5C48:
    MOVE.b (A0)+,(A1)+               ;copy text to tempbuffer
    BEQ.w JL_0_5C52
  DBF D4,JL_0_5C48

  JL_0_5C52:
  MOVE.b #$0,(A1)+
  JSR print_tokenized_text

  exit_print_complete_line:
  TST.l BetterRefresh_FillEndOfLine
  BEQ skip_clearendofline
  ; better refresh: clear line at the end
  MOVEM.l D0-D7/A0-A6,-(A7)
  MOVE.l backgroundcolor,d0 ;: ADD.l #1,d0
  MOVEA.l _graphicsbase,A6
  MOVEA.l rp_sourcewindow,A1
  JSR _SetAPen(A6)

  MOVEA.l _graphicsbase,A6
  MOVEA.l rp_sourcewindow,A1

  MOVE.l comLong_DisplayLine,D1 ; calculate line y
  MULU fontheight,D1

;  MOVEA.l textbufferaddr,A0
;  ADDA.w comWord_TextBufferOffset,A0

;  CLR.l D0
;  'getlength
;  ADD.l #1,D0
;  TST.b (a0)+
;  BNE 'getlength

;  SUB.l comWord_ColumnsOffset,D0
;  MULU fontwidth,D0
;  MOVE.l #20,d0
 ; MOVE.l #200,D0

  MOVE.w $24(A1),D0
;  MOVE.w $26(A1),D1
;  SUB.w font_Baseline,D1
  MOVE.w win_InnerWidth,D2
  MOVE.w D1,D3
  ADD.w  font_Heightm1,D3

  JSR _RectFill(A6)                  ;A1:rp,  D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16
  MOVEM.l (a7)+,D0-D7/A0-A6
  skip_clearendofline:
  MOVE.l (A7)+,D2
  CLR.w comWord__AL_0_8660
RTS

;/* this is a flag to indicate if we need to clear the end of the line!
BetterRefresh_FillEndOfLine:
Dc.l 0


.print_tokenized_text
  MOVEA.l AL_0_5BA6,A0
  MOVEA.l AL_0_5BAA,A1

  MOVEM.l D0-D1/A1,-(A7)
  JSR JL_0_5060                      ;copy whole line from A0 to A1
  MOVEM.l (A7)+,D0-D1/A1

  TST.b keepstring
   BNE 'l3
  CLR.b instring2
  MOVEA.l AL_0_5BA6,A0
  MOVE.w #0,d2
  MOVEM.l d0/d1,-(a7)
  CMP.l #0,a0
  BEQ 'l2b
 'l1
    CMP.w comWord_ColumnsOffset,d2
    BGE 'l2b
    MOVE.b (a0)+,d0
    CMP.b #$22,d0
    BNE 'l2
    NOT.b instring2
   'l2
    ADDQ.w #1,d2
  BRA 'l1
 'l2b
  MOVEM.l (a7)+,d0/d1
 'l3
  ADDA.w comWord__AL_0_869A,A1                ;offset
  MOVE.w visiblecolumns,D4
  MOVE.b $0(A1,D4.W),comByte__AL_0_8662
  MOVEM.l D4/A1,-(A7)
  MOVE.b #$0,$0(A1,D4.W)
  MOVEA.l expandstore,A2
  MOVEA.l A1,A0
  ;ASR.w #3,D0
  EXT.l d0
  DIVU fontwidth,d0

  JL_0_5C9C:
  MOVE.b (A1)+,D2
   BEQ.w JL_0_5CAA
    CMP.b #$22,d2
    BNE 'l10
    NOT.b instring2
   'l10
    TST.b instring2
    BNE 'l11
    TST.b d2
    BMI.w JL_0_5CAA                     ;morechar
   'l11
    MOVE.b D2,(A2)+
  BRA.b JL_0_5C9C

  JL_0_5CAA:
  MOVE.b #$0,(A2)
  CMPA.l expandstore,A2
   BEQ.w JL_0_5CE6
  MOVE.w D0,-(A7)
  ;ASL.w #3,D0
  MULU fontwidth,d0
  MOVEA.l A1,A2
  SUBA.l A0,A2
  MOVE.b D2,D4
  MOVE.w A2,D2
  MOVE.w D2,D5
  SUBQ.w #1,D2
  MOVE.w othercolor,D3
  MOVEA.l expandstore,A0
  JSR print_text
  MOVE.w (A7)+,D0
  MOVE.b D4,D2
  ADD.w D5,D0
  SUBQ.w #1,D0
  TST.b D2
   BEQ.w exit_print_tokenized_text

  JL_0_5CE6:
  TST.b D2
   BEQ.w exit_print_tokenized_text
  ;find string state
  SUBQ.w #1,A1
  MOVEA.l A1,A0
  MOVEA.l expandstore,A2
  TST.b D2
   BPL.b JL_0_5C9C

  a_loop:
    MOVE.b (A1)+,D2
    BEQ.w JL_0_5D0A
    BPL.w JL_0_5D0A
    BCLR #$7,D2
    MOVE.b D2,(A2)+
  BRA.b a_loop

  JL_0_5D0A:
  MOVE.b #$0,(A2)
  CMPA.l expandstore,A2
   BEQ.w exit_print_tokenized_text

  MOVE.w D0,-(A7)
  ;ASL.w #3,D0
  MULU fontwidth,d0
  MOVEA.l A1,A2
  SUBA.l A0,A2
  MOVE.b D2,D4
  MOVE.w A2,D2
  MOVE.w D2,D5
  SUBQ.w #1,D2
  MOVEQ.l #$00,D3
  MOVE.w tokencolor,D3               ; echte tokenfarbe
  MOVEA.l expandstore,A0
  CMP.l #99,classiccolor
  BEQ 'no2
  MOVEM.l d0/d1/a1/a0,-(a7)
  MOVE.l a0,d0
  JSR ascii_to_token
  MOVE.l d0,-(a7)
  ASR.l #7,d0
  ; check for classiccommands
  LEA classiccommands,a0
 'again
    MOVE.w (a0)+,d1
    BEQ 'nomore
    CMP.w d1,d0
  BNE 'again
  MOVE.l classiccolor,d3
 'nomore
  MOVE.l (a7)+,d0

 'l2
    MOVE.w (a0)+,d1
    BEQ 'no2
    CMP.w d0,d1
  BNE 'l2
  MOVE.l classiccolor,d3
 'no2
  MOVEM.l (a7)+,d0/d1/a0/a1
  MOVEM.l a6/d0-d1/a0/a1,-(a7)
  MOVE.l tokenbackground,D0
  MOVEA.l _graphicsbase,A6
  MOVEA.l rp_sourcewindow,A1
  JSR _SetBPen(A6)

  TST.w bold_tokens
  BEQ.b 'no_bold

  MOVEA.l rp_sourcewindow,A1
  MOVEA.l ptr_sourcefontb,A0
  JSR _SetFont(A6)

  MOVEA.l rp_sourcewindow,A1
  MOVE.l #FSF_BOLD,D0
  MOVE.l #FSF_BOLD,D1
  JSR _SetSoftStyle(A6)
 'no_bold

  MOVEM.l (a7),a6/d0-d1/a0/a1
  JSR print_text                     ; print token
  MOVE.l backgroundcolor,d0
  MOVEA.l _graphicsbase,A6
  MOVEA.l rp_sourcewindow,A1
  JSR _SetBPen(A6)

  TST.w bold_tokens
  BEQ.b 'no_bold2

  MOVEA.l rp_sourcewindow,A1
  MOVEA.l ptr_sourcefont,A0
  JSR _SetFont(A6)

  MOVEA.l rp_sourcewindow,A1
  MOVE.l #FS_NORMAL,D0
  MOVE.l #FSF_BOLD,D1
  JSR _SetSoftStyle(A6)
 'no_bold2

  MOVEM.l (a7)+,a6/d0-d1/a0/a1
  MOVE.w (A7)+,D0
  MOVE.b D4,D2
  ADD.w D5,D0
  SUBQ.w #1,D0
  TST.b D2
  BEQ.w exit_print_tokenized_text
  SUBQ.w #1,A1
  MOVEA.l A1,A0
  MOVEA.l expandstore,A2
  BRA.w JL_0_5C9C

  exit_print_tokenized_text:

  MOVEM.l (A7)+,D4/A1
  MOVE.b comByte__AL_0_8662,$0(A1,D4.W)
RTS

.print_hightlight                    ;a0 = text,d0 = x,d2 = charslen,d3 = color
  MOVEM.l D0-D4/A0-A1/A4/A6,-(A7)
  MOVEA.l _graphicsbase,A6
  CMP.l textlinestart,a0
  BGE 'c1
  MOVE.l textlinestart,d4
  SUB.l a0,d4
  SUB.l d4,d2
  MOVE.l textlinestart,a0
  MOVEQ #0,d0
  BRA 'c2
 'c1
  SUB.w comWord_ColumnsOffset,d0
 'c2
  MOVE.l A0,-(A7)
  MOVE.l comLong_DisplayLine,D1
  MULU fontheight,D1
  MOVEQ #0,d4
  MOVE.w d0,d4
  ;ASL.w #3,D0
  MULU fontwidth,d0
  ADD.w font_Baseline,D1
  MOVEA.l rp_sourcewindow,A1
  JSR _Move(A6)

  MOVE.l (a7),a0
  MOVE.l D3,D0
  MOVEA.l rp_sourcewindow,A1
  JSR _SetAPen(A6)
;      ;
;      MOVEA.l rp_sourcewindow,A1
;      MOVE.l D5,D0
;      MOVE.l #0,D1
;      JSR _SetSoftStyle(A6)
;      ;

  MOVEA.l rp_sourcewindow,A1
  MOVEA.l (A7)+,A0
  MOVE.l D2,D0
  BMI 'x1
  MOVE.l d4,d3
  ADD.l d0,d4
  CMP.w visiblecolumns,D4
  BLE.w 'l1
 'l2
  MOVE.w visiblecolumns,D0
  SUB.l d3,d0
  BMI 'x1
 'l1
  JSR _Text(A6)
  ;
;  MOVEA.l rp_sourcewindow,A1
;  MOVE.l #0,D0
;  MOVE.l #0,d1
;  JSR _SetSoftStyle(A6)

 'x1
  MOVEM.l (A7)+,D0-D4/A0-A1/A4/A6
RTS


.print_text                          ;tokens, othertext, remarks
  ; A0: string
  ; D0: x-pos
  ; D1: y-pos
  ; D2: textlength
  ; D3: foregroundcolor

  MOVEM.l D0-D2/A0-A1/A4/A6,-(A7)
  MOVEA.l _graphicsbase,A6
  MOVE.l A0,-(A7)
  ADD.w font_Baseline,D1
  MOVEA.l rp_sourcewindow,A1
  JSR _Move(A6)

  MOVE.l (a7),a0
  MOVE.l D3,D0

  MOVEA.l rp_sourcewindow,A1
  JSR _SetAPen(A6)
  MOVEA.l rp_sourcewindow,A1
  MOVEA.l (A7)+,A0

  ; -- clip text to visible columns
  MOVE.l D2,D0
  BMI 'l1
  CMP.w visiblecolumns,D0
  BLE.w skip_clipping
 'l1
  MOVE.w visiblecolumns,D0
  skip_clipping:

  TST.l remarkcolor
   BNE check_comments_basic
  TST.l remarkbgcolor
   BNE check_comments_basic
  exit_check_comments:

  MOVEA.l rp_sourcewindow,A1
  JSR _Text(A6)

  MOVEM.l (A7)+,D0-D2/A0-A1/A4/A6
RTS

.check_comments_basic:
  ; -- save string address a0 in A4 and stringlength in d0 to stack
  MOVE.l a0,a4
  MOVE.l d0,-(a7)

  ; -- move data to stack for basic routine
  MOVE.l a0,-(a7)
  !basic
  str_length.w = PutD0
  MOVE.l (a7)+,d0 : *textaddr.l = PutD0

  semi_position.w = 0
  in_string.b = 0
  columnsoff.w = Peek.w(?comWord_ColumnsOffset)

  ; -- if templine is used, get it instead of textbuffer
;  If Peek.w(?columnsoffset) = 0
;    If Peek.l(?templine)<>0
;      mytext$ = Peek$(Peek.l(?templine))
;    EndIf
;    If mytext$=""
;      mytext$ = Peek$(Peek.l(?textbufferaddr)+Peek.l(?comWord_TextBufferOffset))
;    EndIf
;  Else
    mytext$ = Peek$(*textaddr)
;  EndIf

  ; -- search for a comment and save the starting position
  CLR.w semipos
  search_again:
  semi_position = Instr(mytext$,";",semi_position+1)
  If semi_position > 0
    ;  !cout{Peek$(*textaddr), Instr(Peek$(*textaddr),Chr$(0))}
    ; -- check if the comment-char +++ ; +++ is in a string
    acount.b = 0
    For i = 1 To semi_position
      If Mid$(mytext$,i,1)=Chr$($22) Then acount + 1
    Next i
    If (acount MOD 2) = 1
      ; -- ungerade Anzahl von +++ " +++ impliziert, das +++ ; +++ in einem String steckt...
      semi_position = 0
    Else
      If Mid$(mytext$,semi_position+1,2)=":@"
        ; -- nachschauen, ob dahinter ein echter Kommentar kommt
        Goto search_again
      EndIf
    EndIf
    If semi_position<=str_length Then Poke.w ?semipos,semi_position
  EndIf
  !asm
  MOVE.l (a7)+,d0
  MOVE.l d0,d2
  MOVE.l a4,a0
  TST.w semipos
   BNE semifound
BRA exit_check_comments


;.check_comments:
;  CLR.w semipos
;  MOVE.l a0,a4
;  CLR.b instring
;  TST.w comWord_ColumnsOffset
;   BEQ 'lc1
;  CMP.l #0,templine
;   BEQ 'tt1
;  MOVE.l templine,a0
;  BRA 'tt2
; 'tt1
;  MOVEA.l textbufferaddr,A0
;  ADD.w   comWord_TextBufferOffset,a0
; 'tt2
;  ; -- search for ';'
;  MOVE.w comWord_ColumnsOffset,d2
;  CMP.b #$22,0(a0,d2.w)
;  BNE 'tc1
;  BCHG.b #0,instring
;
; 'tc1
;    TST.b instring
;     BNE 'tc2
;    CMP.b #";",0(a0,d2)
;     BNE 'tc2
;    CMP.w #": @",1(a0,d2)
;     BEQ 'tc2
;    MOVE.w d0,d2
;    MOVE.w #0,semipos
;    BRA semifound
;   'tc2
;    SUBQ.w #1,d2
;  BNE 'tc1
;
; 'lc1
;  MOVE.l d0,d2                       ; d0 = ganz rechts, oder visiblecolumns
; 'l3
;    LEA 0(a4,d0),a0
;    CMP.b #$22,(a0)
;     BNE 't1
;    BCHG.b #0,instring
;   't1
;    TST.b instring
;     BNE 't2
;    CMP.b #";",(a0)
;     BNE 't2
;    CMP.w #": @",1(a0)
;     BEQ 't2
;    MOVE.w d0,semipos
;    ADDQ #1,semipos
;   't2
;    SUBQ.w #1,d0
;  BPL 'l3
; 'l2
;  TST.w semipos
;   BNE semifound
;  MOVE.l d2,d0
;  MOVE.l a4,a0
;  BRA exit_check_comments

  semifound:
  ; -- draw text until ";"
  MOVE.w semipos,d0
  ; ";" should be also colored
  CMP.w #1,d0
   BLT skip_sub
  SUB.w #1,semipos
  MOVE.w semipos,d0
  skip_sub:

  MOVE.l a4,a0
  MOVE.l d0,-(a7)
  MOVEA.l rp_sourcewindow,A1
  JSR _Text(A6)

  ; -- set remarks color
  MOVEQ #0,d0
  MOVE.l remarkcolor,D0
  MOVEA.l rp_sourcewindow,A1
  JSR _SetAPen(A6)
  MOVE.l remarkbgcolor,D0
  MOVEA.l rp_sourcewindow,A1
  JSR _SetBPen(A6)

  ; -- optional switch italic on
  TST.w italic_remarks
  BEQ.b 'no_italic

;  SetFont_  *rp,*fontI
  MOVEA.l rp_sourcewindow,A1
  MOVEA.l ptr_sourcefonti,A0
  JSR _SetFont(a6)
  MOVEA.l rp_sourcewindow,A1
  MOVE.l #FSF_ITALIC,D0
  MOVE.l #FSF_ITALIC,D1
  JSR _SetSoftStyle(A6)

 'no_italic

  ; -- print the comment text
  MOVE.l (a7)+,d0
  SUB.l d0,d2
  LEA 0(a4,d0),a0
  MOVE.l d2,d0
  MOVEA.l rp_sourcewindow,A1
  JSR _Text(A6)

  ; -- restore standard backgroundcolor
  MOVE.l backgroundcolor,D0
  MOVEA.l rp_sourcewindow,A1
  JSR _SetBPen(A6)

  ; -- optional switch italic off
  TST.w italic_remarks
  BEQ.b 'no_italic2

  MOVEA.l rp_sourcewindow,A1
  MOVEA.l ptr_sourcefont,A0
  JSR _SetFont(a6)

  MOVEA.l rp_sourcewindow,A1
  MOVE.l #FS_NORMAL,D0
  MOVE.l #FSF_ITALIC,D1
  JSR _SetSoftStyle(A6)

 'no_italic2

 'l4
  MOVEM.l (A7)+,D0-D2/A0-A1/A4/A6
RTS


.print_standard_text
  MOVEA.l _graphicsbase,A6
  MOVEA.l AL_0_5BAA,A1
  MOVE.w comWord_MaxColumns,D3

  JL_0_5DB8:
    MOVE.b (A0)+,(A1)+
    BEQ.w JL_0_5Dca2
  DBF D3,JL_0_5DB8

  JL_0_5Dca2:
  MOVE.b #$0,-$1(A1)
  MOVEA.l rp_sourcewindow,A1
  ANDI.w #$FFFF,D1
  ADD.w font_Baseline,D1
  SUBQ.w #1,D1
  JSR _Move(A6)

  MOVEA.l rp_sourcewindow,A1
  MOVEQ #0,d0
  MOVE.w othercolor,D0
  JSR _SetAPen(A6)

  MOVEA.l rp_sourcewindow,A1
  MOVEA.l AL_0_5BAA,A0
  ADDA.w comWord__AL_0_869A,A0
  MOVEQ.l #$00,D0
  MOVE.w comWord_MaxColumns,D0
  ADDQ.w #1,D3
  SUB.w D3,D0
  ADDQ.w #1,D0
  SUB.w comWord__AL_0_869A,D0
  CMP.w visiblecolumns,D0
  BLE.w JL_0_5E1C
  MOVE.w visiblecolumns,D0

  JL_0_5E1C:
  MOVE.l D0,-(A7)
  JSR _Text(A6)

  MOVE.l (A7)+,D0
RTS



.print_sourceline:
  CMPA.l #$0,A2
  BNE.w JL_0_5E32
  RTS

  JL_0_5E32:
  LEA $9(A2),A2
  MOVEA.l textbufferaddr,A3
  ADDA.w comWord_TextBufferOffset,A3
  TST.b (A2)
   BEQ.w JL_0_5E72

  MOVEM.l D1/A0-A3/A6,-(A7)
  MOVEA.l A2,A0
  MOVEQ.l #$00,D0
  MOVEQ.l #$00,D1
  MOVE.l comLong_DisplayLine,D1
  MULU fontheight,D1
  MOVE.w comWord_ColumnsOffset,comWord__AL_0_869A
  MOVE.l AL_0_5BAA,templine
  JSR print_complete_line
  CLR.l templine
  MOVEM.l (A7)+,D1/A0-A3/A6
  MOVEA.l AL_0_5BAA,A2
  BRA.w JL_0_5E78

  JL_0_5E72:

  ; better refresh: draw empty line
  MOVE.l backgroundcolor,d0 ;: ADD.l #2,d0
  MOVEA.l _graphicsbase,A6
  MOVEA.l rp_sourcewindow,A1
  JSR _SetAPen(A6)
  MOVEA.l _graphicsbase,A6
  MOVEA.l rp_sourcewindow,A1
  MOVE.w #0,D0
  MOVE.l comLong_DisplayLine,D1
  MULU fontheight,D1
  MOVE.w win_InnerWidth,D2
  MOVE.w D1,D3
  ADD.w  font_Heightm1,D3            ;font_Heightm1
  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16

  MOVEA.l _graphicsbase,A6           ; move to next line
  MOVEA.l rp_sourcewindow,A1
  MOVE.w #0,D0
  MOVE.l comLong_DisplayLine,D1
  MULU fontheight,D1
  ADD.w  fontheight,D1
  JSR _Move(a6)

  MOVEA.l AL_0_5BAA,A2
  CLR.l (A2)
  JL_0_5E78:
  MOVE.w comWord_Column,-(A7)
  MOVEQ.l #$00,D3
  MOVEQ.l #$00,D2
  MOVE.b (A2)+,D0
   BEQ.w JL_0_5EA0
  CMP.b comByte_LabelIdentifier,D0
  BNE.w JL_0_5E9A
  JSR JL_0_5EE0

  JL_0_5E92:
    ADDQ.w #1,D2
    MOVE.b (A2)+,D0                  ;copy to viewbuffer
    BEQ.w JL_0_5EA0
    JL_0_5E9A:
    JSR JL_0_5EE0
  BRA.b JL_0_5E92


.dostring
  TST.l stringcolor
  BEQ ready
  MOVEM.l a2/d2/a1,-(a7)
  SUBQ.l #1,a2
  MOVE.l a2,a0
  MOVE.l d2,d1
  MOVEQ #0,d0
  BRA 'l1
 'l2b
    MOVE.b (a2),d0
    CMP.b #$22,d0
    BEQ 'l3
   'l1
    ADDQ #1,d2
    CMP.w #MAX_Columns,d2            ; check the full line
    BEQ 'r1
    ADDQ #1,a2
  BRA 'l2b
 'l3
  ADDQ #1,d2
  SUB.l d1,d2
  MOVE.l d1,d0
  MOVE.l stringcolor,d3
  MOVE.l #0,D5
  BSR print_hightlight
  SUBQ.l #1,d2
  ADD.l d2,0(a7)
  ADD.l d2,8(a7)
 'l3b
 'r1
  MOVEM.l (a7)+,d2/a2/a1
  CLR.b instring
BRA ready


.domacro
  TST.l macrocolor
  BEQ ready
  MOVEM.l a2/d2/a1,-(a7)
  SUBQ.l #1,a2
  MOVE.l a2,a0
  MOVE.l d2,d1
 'l2b
    LEA chartab,a1
    MOVEQ #0,d0
    MOVE.b (a2),d0
    TST.b 0(a1,d0)
    BNE 'l3
   'l1
    ADDQ #1,d2
    CMP.w #MAX_Columns,d2            ; check the full line
    BEQ 'r1
    ADDQ #1,a2
  BRA 'l2b
 'l3
  SUB.l d1,d2
  MOVE.l d1,d0
  MOVE.l macrocolor,d3
  MOVE.l #0,D5
  BSR print_hightlight
 'l3b
 'r1
  MOVEM.l (a7)+,d2/a2/a1
  CLR.b instring
BRA ready

.donewtype
  TST.l newtypecolor
  BEQ ready
  MOVEM.l a2/d2/a1,-(a7)
  SUBQ.l #1,a2
  MOVE.l a2,a0
  MOVE.l d2,d1
 'l2b
    LEA chartab,a1
    MOVEQ #0,d0
    MOVE.b (a2),d0
    CMP.b #$22,d0
    BNE 'ls1
    NOT.b instring
   'ls1
    TST.b instring
    BNE 'l1
    CMP.b #"\",d0
    BEQ 'l1
    TST.b 0(a1,d0)
    BNE 'l3
   'l1
    ADDQ #1,d2
    CMP.w #MAX_Columns,d2
    BEQ 'r1
    ADDQ #1,a2
  BRA 'l2b
 'l3
  SUB.l d1,d2
  MOVE.l d1,d0
  MOVE.l newtypecolor,d3
  MOVE.l #0,D5
  BSR print_hightlight
 'l3b
 'r1
  MOVEM.l (a7)+,d2/a2/a1
  CLR.b instring
BRA ready

.doconstant
  TST.l constantcolor
  BEQ ready
  MOVEM.l a2/d2/a1,-(a7)
  SUBQ.l #1,a2
  MOVE.l a2,a0
  MOVE.l d2,d1
  'l2b
    LEA chartab,a1
    MOVEQ #0,d0
    MOVE.b (a2),d0
    CMP.b #$22,d0
    BNE 'ls1
    NOT.b instring
   'ls1
    TST.b instring
    BNE 'l1
    CMP.b #"$",d0
    BEQ 'l1
    CMP.b #"%",d0
    BEQ 'l1
    CMP.b #"-",d0
    ;BEQ 'l1
    TST.b 0(a1,d0)
    BNE 'l3
   'l1
    ADDQ #1,d2
    CMP.w #MAX_Columns,d2
    BEQ 'r1
    ADDQ #1,a2
  BRA 'l2b
 'l3
  SUB.l d1,d2
  MOVE.l d1,d0
  MOVE.l constantcolor,d3
  MOVE.l #1,D5
  BSR print_hightlight
 'l3b
 'r1
  MOVEM.l (a7)+,d2/a2/a1
  CLR.b instring
BRA ready

.dofunction
  TST.l functioncolor
  BEQ ready
  MOVEM.l a2/d2,-(a7)
  SUBQ.w #1,a2
  SUBQ.w #1,a2
 'l2
    CMP.b #32,(a2)
    BNE 'l1
    SUBQ #1,a2
    SUBQ #1,d2
    BEQ dofr1
  BRA 'l2
 'l1
  MOVE.l d2,d1
 'l2b
    LEA chartab,a0
    MOVE.b (a2),d0
    CMP.b #"!",d0
    BEQ dofr1
    TST.b 0(a0,d0)
    BNE 'l3
    SUBQ #1,d2
    BEQ 'l3b
    SUBQ #1,a2
  BRA 'l2b
 'l3
  ADDQ #1,a2
 'l3b
  CMP.b #$21,d0
  BEQ dofr1
  SUB.l d2,d1
  MOVE.l d2,d0
  MOVE.l d1,d2
  MOVE.l a2,a0
;  !basic
;  tempd0.l = PutD0
;  MOVE.l a2,d0
;  faddr.l = PutD0
;  MOVE.l d2,d0
;  clen.l = PutD0
;  functionstr$ = peek.s(faddr,clen)
;  functionstr$ = TED_GetIncludeFunction{functionstr$}
;  !cout{functionstr$,Hex$(faddr),clen}
;  If functionstr$<>"" Then poke.s faddr,functionstr$,clen
;  GetD0 tempd0
;  !asm
  MOVE.l functioncolor,d3
  MOVE.l #0,D5
  BSR print_hightlight
  dofr1:
  MOVEM.l (a7)+,d2/a2
BRA ready

.process_highlightning
  MOVEM.l a2/d2,-(a7)
  CLR.b instring
  MOVEA.l textbufferaddr,A0
  ADDA.w comWord_TextBufferOffset,A0
  MOVE.l a0,a2
  MOVE.l a2,textlinestart
  MOVEQ #0,d0
  MOVE.w comWord_ColumnsOffset,d0
  ADD.l d0,textlinestart
  MOVEQ #0,d2
  hl1:
    MOVE.b (a2)+,d0
    CMP.b #";",d0
    BEQ skipsyntax
    CMP.b #$22,d0
    BEQ dostring
    ;BNE 'ls1
    ;NOT.b instring
   'ls1  ;TST.b instring
    ;BNE ready
    CMP.b #"{",d0
    BEQ dofunction
    CMP.b #"!",d0
    BEQ domacro
   'ls2
    CMP.b #"#",d0
    BEQ doconstant
    CMP.b #"\",d0
    BEQ donewtype
   ready
    ADDQ.l #1,d2
    CMP.w #MAX_Columns,d2
  BLE hl1

  CLR.b instring
  skipsyntax:
  MOVEM.l (a7)+,a2/d2
RTS

JL_0_5EA0:
  BSR process_highlightning
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w JL_0_5ED8
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  CMP.l comLong_BlockStartY,D0
   BCS.w JL_0_5ED8
  CMP.l comLong_BlockEndY,D0
   BHI.w JL_0_5ED8

  JL_0_5EC4:
    CMP.w visiblecolumns,D3
    BCC.w JL_0_5ED8
    MOVEQ.l #$20,D0
    MOVE.w D3,comWord_Column
    ADDQ.w #1,D3
  BRA.b JL_0_5EC4

  JL_0_5ED8:
  MOVE.w (A7)+,comWord_Column
RTS



JL_0_5EE0:
  MOVE.b D0,$0(A3,D2.W)
  JL_0_5EE4:
  CMP.w comWord_ColumnsOffset,D2
   BCS.w JL_0_5EFC
  CMP.w visiblecolumns,D3
   BCC.w JL_0_5EFC
  MOVE.w D3,comWord_Column
  ADDQ.w #1,D3
  JL_0_5EFC:
RTS

JL_0_5EFE:
  TST.w comWord_DoTokenize
   BEQ.b JL_0_5EE0
  TST.b D0
   BPL.b JL_0_5EE0
  LSL.w #8,D0
  MOVE.b (A2)+,D0
  EXG.l A5,A3
   JSR token_to_ascii
  EXG.l A5,A3

  JL_0_5F16:
    MOVE.b (A5)+,D0
    BEQ.w JL_0_5F2C
    MOVE.b D0,$0(A3,D2.W)
    BSET #$7,$0(A3,D2.W)
    BSR.b JL_0_5EE4
    ADDQ.w #1,D2
  BRA.b JL_0_5F16

  JL_0_5F2C:
  SUBQ.w #1,D2
RTS

.parse_line:                         ; input A2: textstring, results in comPtr_Temp_TokenString1
  MOVEA.l comPtr_Temp_TokenString1,A1
  MOVE.l A1,-(A7)
  MOVE.w comWord_MaxColumns,D1
  SUBQ.w #1,D1
  MOVE.w comWord_DoTokenize,D0
  BNE.w JL_0_5F68

  MOVEA.l A1,A0
  JL_0_5F48:
    MOVE.b (A2)+,(A0)+
    CMPI.b #$20,-$1(A0)
     BEQ.w JL_0_5F56
    MOVEA.l A0,A1
    JL_0_5F56:
  DBF D1,JL_0_5F48

  JL_0_5F5A:                         ; tokenise line
  CLR.b (A1)+
  MOVE.l A1,D5
  SUB.l (A7)+,D5
  RTS

  JL_0_5F62:
  MOVE.l A1,-(A7)
  BRA.w JL_0_5F72

  JL_0_5F68:
  CMPI.b #$20,$0(A2,D1.W)
  BNE.w JL_0_5F7E

  JL_0_5F72:
  SUBQ.w #1,D1
   BPL.b JL_0_5F68
  ADDQ.w #4,A7
  CLR.b (A1)
  MOVEQ.l #$01,D5
  RTS

  JL_0_5F7E:
  MOVE.l A4,-(A7)
  MOVEQ.l #$00,D0
  MOVE.w D0,comWord__AL_0_86B8
  CLR.b instring2

  JL_0_5F88:
    MOVE.b (A2)+,D2
    CMP.b #$22,d2
    BNE 'l10
    NOT.b instring2
   'l10
    TST.b instring2
    BNE 'l11

    BCLR #$7,D2                      ;morechar
   'l11
    CMP.b comByte__L_0_8BCD,D2
    BNE.w JL_0_5FA2

    JL_0_5F96:
    NOT.w comWord__AL_0_86B8

    JL_0_5F9C:
    JSR JL_0_60B2
    BRA.b JL_0_5F88

    JL_0_5FA2:
    MOVE.w comWord__AL_0_86B8,D4
    BNE.b JL_0_5F9C
    JSR JL_0_60C6
    BEQ.w JL_0_6030
    .temp1
    JL_0_5FB0:
    CMP.b #$30,d2                    ;number 0-9
     BLT 'l10
    CMP.b #$39,d2
     BGT 'l10
    BRA JL_0_6066
   'l10:
    CMP.b #"_",D2
     BEQ.w JL_0_6066
    CMP.b #$2E,D2
     BEQ.w JL_0_6066
    CMP.b #"\",D2
     BEQ.w JL_0_6066
    CMP.b comByte__L_0_8BCF,D2
     BNE.w JL_0_5FDC

    JL_0_5FD0:
      JSR JL_0_60B2
      MOVE.b (A2)+,D2
      BCLR #$7,D2
    BRA.b JL_0_5FD0

    JL_0_5FDC:
    CMP.b #"'",d2
     BEQ JL_0_5FE4
    CMP.b #"#",D2
     BEQ.w JL_0_5FE4                 ;jump notokenize
    CMP.b #"$",D2                    ;tokenize $ #
     BNE.w JL_0_6018

    JL_0_5FE4:
      JSR JL_0_60B2
      MOVE.b (A2)+,D2
      BCLR #$7,D2
      CMP.b #$22,d2
      BNE 'l10
      BRA JL_0_5FE4
     'l10
      CMP.b #"_",d2
       BEQ JL_0_5FE4
      CMP.b #"0",D2
       BCS.w JL_0_6018
      CMP.b #"z",D2                  ;f
       BHI.w JL_0_6018
      CMP.b #"9",D2
       BLS.b JL_0_5FE4
      CMP.b #"A",D2
       BCS.w JL_0_6018
      CMP.b #"a",D2
       BCC.b JL_0_5FE4
      CMP.b #"Z",D2                  ;F
    BLS.b JL_0_5FE4

    JL_0_6018:
    JSR JL_0_60B2
    MOVE.b (A2)+,D2
    CMP.b #$22,d2
     BNE 'l10
    NOT.b instring2
   'l10
    TST.b instring2
     BNE 'l11
    BCLR #$7,D2                      ;morechar
   'l11
    CMP.b comByte__L_0_8BCD,D2
     BEQ.w JL_0_5F96
    JSR JL_0_60C6
    BNE.b JL_0_5FB0

    JL_0_6030:
    SUBQ.w #1,A2
    MOVEA.l comPtr_TokenBase,A3

    JL_0_6036:
    MOVEA.l A2,A4
    MOVE.l A3,-(A7)
    ADDQ.w #6,A3

    JL_0_603C:
    MOVE.b (A3)+,D3
     BEQ.w JL_0_6082
    MOVE.b (A4)+,D2
    BCLR #$7,D2
    ORI.b #$20,D3
    ORI.b #$20,D2
    CMP.b D3,D2
    BEQ.b JL_0_603C

    JL_0_6054:
    MOVEA.l (A7)+,A3
    MOVE.l (A3),D3
     BEQ.w JL_0_6060
    MOVEA.l D3,A3
    BRA.b JL_0_6036

    JL_0_6060:
    MOVE.b (A2)+,D2
    BCLR #$7,D2

    JL_0_6066:
     JSR JL_0_60B2
    MOVE.b (A2)+,D2
    CMP.b #$22,d2
    BNE 'l10
    NOT.b instring2
   'l10
    TST.b instring2
     BNE 'l11
    BCLR #$7,D2            ;morechar
   'l11
    CMP.b comByte__L_0_8BCD,D2
     BEQ.w JL_0_5F96
    JSR JL_0_60C6
    BEQ.b JL_0_6066
    BRA.w JL_0_5FB0

    JL_0_6082:
    MOVE.b (A4),D2
    BCLR #$7,D2
    JSR JL_0_60C6            ;ascii to token
     BEQ.b JL_0_6054
    CMP.b #$30,d2            ;number 0-9
     BLT 'l10
    CMP.b #$39,d2
     BGT 'l10
    BRA JL_0_6054
   'l10:
    CMP.b #"_",D2
     BEQ.b JL_0_6054
    MOVEA.l (A7)+,A3
    ADDQ.w #4,A3
    MOVE.b (A3)+,(A1)
    BSET #$7,(A1)+
    MOVE.b (A3),(A1)+
    MOVE.l A4,D4
    SUB.l A2,D4
    ADD.w D4,D0
    CMP.w D1,D0
     BHI.w JL_0_60C0
    MOVEA.l A4,A2
  BRA.w JL_0_5F88

JL_0_60B2:
  MOVE.b D2,(A1)+
  ADDQ.w #1,D0
  CMP.w D1,D0
  BHI.w JL_0_60BE
RTS

JL_0_60BE:
  ADDQ.w #4,A7

  JL_0_60C0:
  MOVEA.l (A7)+,A4
BRA.w JL_0_5F5A

JL_0_60C6:
  CMP.b #"A",D2
   BCS.w JL_0_60E8
  CMP.b #"z",D2
   BHI.w JL_0_60E8
  CMP.b #"[",D2
   BCS.w JL_0_60E6
  CMP.b #"a",D2
   BCS.w JL_0_60E8

  JL_0_60E6:
  CMP.w D2,D2

  JL_0_60E8:
RTS

JL_0_60EA:
  EXG.l D0,D2
  BSR.b JL_0_60C6
  EXG.l D0,D2
RTS

.source_fullscroll_down:
  MOVEQ.l #$00,D7
  source_partscroll_down:
  JSR source_scroll_down
  JSR JL_0_6290
RTS

JL_0_60FE:
  TST.l comLong_BlockEndY
   BMI.w JL_0_612A
  MOVE.w comWord_Column,D0
  MOVE.l viewablelines_m1,D1
  ADD.w comWord_ColumnsOffset,D0
  ADD.l comLong_DisplayLineOffset,D1
  MOVE.l viewablelines_m1,D6
  BRA.w JL_0_6150

  JL_0_612A:
RTS

JL_0_612C:
  TST.l comLong_BlockEndY
   BMI.w JL_0_614E
  MOVE.w comWord_Column,D0
  MOVE.l comLong_DisplayLineOffset,D1
  ADD.w comWord_ColumnsOffset,D0
  MOVEQ.l #$00,D6
 BRA.w JL_0_6150

JL_0_614E:
RTS

JL_0_6150:
  MOVE.w comLong_BlockStartX,D4
  SUB.w comWord_ColumnsOffset,D4
  BPL.w JL_0_6162
  MOVEQ.l #$00,D4

  JL_0_6162:
  MOVE.w comLong_BlockEndX,D5
  SUB.w comWord_ColumnsOffset,D5
  BPL.w JL_0_6174
  MOVEQ.l #$00,D5

  JL_0_6174:
  CMP.w visiblecolumns,D5
  BLT.w JL_0_6184
  MOVE.w comWord__AL_0_8670,D5

  JL_0_6184:
  MOVE.l comLong_BlockStartY,D2
  MOVE.l comLong_BlockEndY,D3
  MOVEA.l comPtr_SourceAreaRastPort,A1
  MOVEA.l _graphicsbase,A6
  CMP.l D2,D1
   BLT.w JL_0_61D0
   BEQ.w JL_0_61D2
  CMP.l D3,D1
   BGT.w JL_0_61D0
   BEQ.w JL_0_6220
  MOVE.l D6,D1
   BEQ.w JL_0_61BA
  MULU fontheight,D1
  JL_0_61BA:
  MOVEQ.l #$00,D0
  MOVE.w visiblecolumns,D2
  ;ASL.w #3,D2
  MULU fontwidth,d2
  SUBQ.w #1,D2
  MOVE.l D1,D3
  ADD.w font_Heightm1,D3
  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16

  JL_0_61D0:
RTS


JL_0_61D2:
  CMP.l comLong_BlockEndY,D1
   BNE.w JL_0_61FC
  MOVE.w D4,D0
  ;ASL.w #3,D0
  MULU fontwidth,d0
  MOVE.w D6,D1
   BEQ.w JL_0_61EA
  MULU fontheight,D1
  JL_0_61EA:
  MOVE.w D5,D2
  ;ASL.w #3,D2
  MULU fontwidth,d2
  ADDQ.w #7,D2
  MOVE.l D1,D3
  ADD.w font_Heightm1,D3
  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16
RTS

JL_0_61FC:
  MOVE.w D4,D0
  ;ASL.w #3,D0
  MULU fontwidth,d0
  MOVE.w D6,D1
   BEQ.w JL_0_620A
  MULU fontheight,D1

  JL_0_620A:
  MOVE.w visiblecolumns,D2
  ;ASL.w #3,D2
  MULU fontwidth,d2
  SUBQ.w #1,D2
  MOVE.l D1,D3
  ADD.w font_Heightm1,D3
  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16
RTS

JL_0_6220:
  MOVE.w D5,D2
  CMP.w visiblecolumns,D2
   BLE.w JL_0_6234
  MOVE.w visiblecolumns,D2
  SUBQ.w #1,D2

  JL_0_6234:
  ;ASL.w #3,D2
  MULU fontwidth,d2
  MOVE.w D6,D1
   BEQ.w JL_0_6240
  MULU fontheight,D1

  JL_0_6240:
  ADDQ.w #7,D2
  MOVE.l D1,D3
  ADD.w font_Heightm1,D3
  MOVEQ.l #$00,D0
  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16
RTS

.source_scroll_down:                 ;ymin aus D7
  MOVEM.l D0-D7/A0-A6,-(A7)
  MOVE.w D7,D3
  MOVE.l viewablelines,D5
  MULU fontheight,D3                 ;ymin
  MULU fontheight,D5                 ;ymax
  SUBQ.l #1,D5
  MOVEA.l rp_sourcewindow,A1
  MOVEQ.l #$00,D0                    ;dx
  MOVE.w fontheight,D1               ;dy
  MOVEQ.l #$00,D2                    ;xmin
  MOVE.w visiblecolumns,D4
  MULU fontwidth,d4                  ;xmax
  SUBQ.w #1,D4
  MOVEA.l _graphicsbase,A6
  JSR _ScrollRaster(A6)              ;A1:rp, D0:dx D1:dy D2:xmin D3:ymin D4:xmax D5:ymax
  JSR _WaitBlit(A6)
  JSR delay
  MOVEM.l (A7)+,D0-D7/A0-A6
RTS

JL_0_6290:
  MOVE.l viewablelines,D6
  SUB.l D7,D6
  SUBQ.l #1,D6
  TST.l D6
  BEQ.w fill2
  MOVE.l D7,D0
  MOVE.w comWord_MaxColumns,D1
  MULU D1,D0
  MOVEA.l textbufferaddr,A0
  ADDA.l D0,A0
  MOVE.l A0,a1
  ADDA.w D1,A1
  MOVE.l d6,d0
  MULS d1,d0
  ASR.l #1,d0
 'loop
    MOVE.w (a1)+,(a0)+
    SUBQ.l #1,d0
  BNE 'loop

  fill2:
  MOVE.l viewablelines,D0
  SUBQ.l #1,D0
  MULU comWord_MaxColumns,D0
  MOVEA.l textbufferaddr,A0
  ADDA.w D0,A0
  MOVE.w #$2020,d1
  MOVE.l #MAX_Columns/2,d0
 'loop
    MOVE.w d1,(a0)+
    SUBQ.l #1,d0
  BNE 'loop
RTS

.source_fullscroll_up:
  MOVEQ.l #$00,D7
  source_partscroll_up:
  JSR source_scroll_up
  JSR JL_0_6358
RTS

.source_scroll_up:
  MOVEM.l D0-D7/A0-A6,-(A7)
  MOVE.w D7,D3
  MOVE.l viewablelines,D5
  MULU fontheight,D3
  MULU fontheight,D5
  SUBQ.w #1,D5
  MOVEA.l rp_sourcewindow,A1
  MOVEQ.l #$00,D0
  MOVE.w fontheight,D1
  NEG.w D1
  MOVEQ.l #$00,D2
  MOVE.w visiblecolumns,D4
  ;ASL.w #3,D4
  MULU fontwidth,d4
  SUBQ.w #1,D4
  MOVEA.l _graphicsbase,A6
  JSR _ScrollRaster(A6)              ;A1:rp, D0:dx D1:dy D2:xmin D3:ymin D4:xmax D5:ymax
  JSR _WaitBlit(A6)
  JSR delay
  MOVEM.l (A7)+,D0-D7/A0-A6
RTS


JL_0_6358:                           ;return blit
checkd7
  MOVE.l viewablelines,D6
  SUB.l D7,D6
  SUBQ.l #1,D6
   BEQ.w fill
  MOVE.w comWord_MaxColumns,D1
  MOVE.w D1,D0
  MULU viewablelines+2,D0
  MOVEA.l textbufferaddr,A0
  ADDA.l D0,A0
  SUBQ.w #2,A0
  MOVE.l A0,a1          ;destaddr
  SUBA.w D1,A1
  MOVE.l d6,d0
  MULS d1,d0
  ASR.l #1,d0
 'loop
    MOVE.w -(a1),-(a0)
    SUBQ.l #1,d0
  BNE 'loop
  fill
  MULU comWord_MaxColumns,D7
  MOVEA.l textbufferaddr,A0
  ADDA.l D7,A0
  MOVE.w #$2020,d1
  MOVE.l #MAX_Columns/2,d0
 'loop
    MOVE.w d1,(a0)+
    SUBQ.l #1,d0
  BNE 'loop
RTS


JL_0_640C:
  ADDQ.l #1,comLong_DisplayLine
  MOVEQ.l #$00,D0
;  MOVE.w comWord__AL_0_86CC,D0
;  ADD.l D0,comLong__AL_0_868A
  MOVE.w comWord_MaxColumns,D0
  ADD.w D0,comWord_TextBufferOffset
RTS

JL_0_642A:
  SUBQ.l #1,comLong_DisplayLine
  MOVEQ.l #$00,D0
;  MOVE.w comWord__AL_0_86CC,D0
;  SUB.l D0,comLong__AL_0_868A
  MOVE.w comWord_MaxColumns,D0
  SUB.w D0,comWord_TextBufferOffset
RTS

JL_0_6448:
  MOVEA.l rp_sourcewindow,A1
  MOVE.w comWord_Column,D0
  ADD.w comWord_ColumnsOffset,D0
  MOVE.l comLong_DisplayLine,D1
  ADD.l comLong_DisplayLineOffset,D1

  TST.l comLong_BlockEndY
   BMI.w source_scroll_line_to_right
  CMP.l comLong_BlockEndY,D1
   BGT.w source_scroll_line_to_right
  CMP.l comLong_BlockStartY,D1
   BLT.w source_scroll_line_to_right
   BNE.w JL_0_6498
  CMP.w comLong_BlockStartX,D0
   BGE.w JL_0_6498
  SUBQ.w #1,comLong_BlockStartX

  JL_0_6498:
  CMPI.w #MAX_Columns-1,comLong_BlockEndX
   BEQ.w JL_0_64CA
  CMP.w comLong_BlockEndX,D0
   BGT.w source_scroll_line_to_right
  SUBQ.w #1,comLong_BlockEndX
  MOVE.w visiblecolumns,D1
  ADD.w comWord_ColumnsOffset,D1
  CMP.w comLong_BlockEndX,D1
   BGT.w source_scroll_line_to_right

  JL_0_64CA:
  MOVEM.l D0-D1/A0-A1,-(A7)
  MOVEA.l rp_sourcewindow,A1
  MOVEQ.l #$03,D0
  MOVEA.l _graphicsbase,A6
  JSR _SetBPen(A6)
  MOVEM.l (A7)+,D0-D1/A0-A1

  source_scroll_line_to_right:
  MOVE.w D7,-(A7)
  ;MOVEQ.l #$08,D0
  MOVEQ #0,d0
  MOVE.w fontwidth,d0
   JSR source_scroll_line
  MOVE.w (A7)+,D7
RTS

.source_scroll_line_to_left:
  MOVE.w D7,-(A7)
  ;MOVEQ.l #-$08,D0
  MOVEQ #0,d0
  SUB.w fontwidth,d0
  EXT.l d0
  JSR source_scroll_line
  MOVE.w (A7)+,D7
RTS

.source_scroll_line:
  MOVEA.l rp_sourcewindow,A1
  MOVEQ.l #$00,D1
  MOVEQ.l #$00,D2
  MOVEQ.l #$00,D3
  MOVEQ.l #$00,D4
  MOVE.w comWord_Column,D2
  MULU fontwidth,d2                  ; xmin

  MOVE.l comLong_DisplayLine,D3
  MULU fontheight,D3                 ; ymin

  MOVE.w visiblecolumns,D4
  MULU fontwidth,d4
  SUBQ.w #1,D4                       ; xmax

  MOVE.l D3,D5
  ADD.w fontheight,D5
  SUBQ.w #1,D5                       ; ymax

  MOVEA.l _graphicsbase,A6
  JSR _ScrollRaster(A6)              ;A1:rp, D0:dx D1:dy D2:xmin D3:ymin D4:xmax D5:ymax
  JSR _WaitBlit(A6)
  JSR delay
RTS

JL_0_653C:
  TST.l comLong_BlockEndY
   BMI.w JL_0_65A4
  MOVEQ.l #$00,D0
  MOVE.w comWord_Column,D0
  MOVE.l comLong_DisplayLine,D1
  ADD.w comWord_ColumnsOffset,D0
  ADD.l comLong_DisplayLineOffset,D1
  CMP.l comLong_BlockStartY,D1
   BLT.w JL_0_65A4
  CMP.l comLong_BlockEndY,D1
   BGT.w JL_0_65A4
  CMP.w comLong_BlockStartX,D0
   BLT.w JL_0_65A4
  CMP.w comLong_BlockEndX,D0
   BGT.w JL_0_65A4
  MOVEA.l comPtr_SourceAreaRastPort,A1
  ;ASL.w #3,D0
  MULU fontwidth,d0
  MOVE.l D0,D2
  ADDQ.w #7,D2
;ADD.w #fontwidth,D2
  MULU fontheight,D1
  MOVE.l D1,D3
  ADD.w font_Heightm1,D3
  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16

  JL_0_65A4:
RTS


.scroll_right:
  MOVE.l #1,blockmarking
  JSR source_scroll_to_left          ; scroll source to left <-
  JSR source_draw_new_columns        ; draw text after scroll
  JSR source_update_blockmark        ; blockmark selected text after scrolling
  MOVE.l #0,blockmarking
RTS


.source_update_blockmark:
  TST.l comLong_BlockEndY
   BMI.w exit_update_blockmark

  MOVEA.l _graphicsbase,A6
  MOVEA.l comPtr_SourceAreaRastPort,A1

  MOVE.l comLong_DisplayLineOffset,D1
  MOVE.w D1,D2
  ADD.l viewablelines,D2
  MOVE.w comWord_ColumnsOffset,D0    ; D0

  CMP.l comLong_BlockEndY,D1
   BGT.w exit_update_blockmark

  CMP.l comLong_BlockStartY,D2
   BLT.w exit_update_blockmark

  MOVE.l comLong_BlockStartY,D4
  CMP.l comLong_BlockEndY,D4
  BEQ.w JL_0_66F2

  JSR JL_0_6658                      ; blockmark first line of selected block until mousex

  MOVE.l comLong_BlockStartY,D1              ; ymin
  SUB.l comLong_DisplayLineOffset,D1          ; ymin
  ADDQ.l #1,D1                       ; ymin

  MOVE.l comLong_BlockEndY,D3                ; ymax
  SUB.l comLong_DisplayLineOffset,D3          ; ymax
  CMP.l viewablelines,D3             ; ymax
   BLE.w JL_0_6630
  MOVE.l viewablelines,D3            ; ymax
  JL_0_6630:

  CMP.l D1,D3                        ; ymin
   BLE.w JL_0_669A

  JSR JL_0_669A
;  MOVEM.l D0-D4/A1,-(A7)
  !basic
  xmin.w = (Peek.w(?comWord_ColumnsOffset)-Peek.w(?comWord_ColumnsOffset)) * Peek.w(?fontwidth)
  ymin.w = (Peek.l(?comLong_BlockStartY)-Peek.l(?comLong_DisplayLineOffset) + 1) * Peek.w(?fontheight)
  ymax.w =  Peek.l(?comLong_BlockEndY ) -Peek.l(?comLong_DisplayLineOffset)
  If ymax > Peek.l(?viewablelines) Then ymax = Peek.l(?viewablelines)
  xmax.w = xmin + Peek.w(?fontwidth)*2 - 1   ; warum 15 ?? muesste eigentlich die Fontbreite sein
  ymax.w = ymax * Peek.w(?fontheight) - 1
  RectFill_ Peek.l(?comPtr_SourceAreaRastPort),xmin,ymin,xmax,ymax
  !asm
;  MOVEM.l (A7)+,D0-D4/A1
  exit_update_blockmark:
RTS


JL_0_6658:                          ; mark first line of selected source
  CMP.w comLong_BlockStartX,D0
   BLT.w JL_0_6698

  MOVEM.l D0-D3/A1,-(A7)
  !basic
  xmin.w = (Peek.w(?comWord_ColumnsOffset)-Peek.w(?comWord_ColumnsOffset)) * Peek.w(?fontwidth)
  xmax.w = xmin + Peek.w(?fontwidth)*2 - 1

  ymin.w = (Peek.l(?comLong_BlockStartY)-Peek.l(?comLong_DisplayLineOffset)) * Peek.w(?fontheight)
  ymax.w = ymin + Peek.w(?font_Heightm1)
  RectFill_ Peek.l(?comPtr_SourceAreaRastPort),xmin,ymin,xmax,ymax
  !asm
  MOVEM.l (A7)+,D0-D3/A1

  JL_0_6698:
RTS


JL_0_669A:
  MOVEM.l D0-D3/A1,-(A7)
  CMP.w comLong_BlockEndX,D0
   BGT.w JL_0_66EC
  !basic
    xmin.w      = (Peek.w(?comWord_ColumnsOffset)-Peek.w(?comWord_ColumnsOffset)) * Peek.w(?fontwidth)
    xmax_temp.w = (Peek.l(?comLong_BlockEndX)-Peek.w(?comWord_ColumnsOffset)+1) * Peek.w(?fontwidth) -1
    If xmax_temp <(Peek.w(?fontwidth)*2-1) Then xmax_temp = Peek.w(?fontwidth)*2 - 1
    xmax.w      = xmin + xmax_temp
    ymin.w      = (Peek.l(?comLong_BlockEndY)-Peek.l(?comLong_DisplayLineOffset)) * Peek.w(?fontheight)
    ymax.w      = ymin + Peek.w(?font_Heightm1)

    RectFill_ Peek.l(?comPtr_SourceAreaRastPort),xmin,ymin,xmax,ymax
  !asm

  JL_0_66EC:
  MOVEM.l (A7)+,D0-D3/A1
RTS

JL_0_66F2:
  CMP.w comLong_BlockStartX,D0
   BLT.w exit_update_blockmark

  CMP.w comLong_BlockEndX,D0
   BGT.w exit_update_blockmark
  !basic
  xmin.w      = (Peek.w(?comWord_ColumnsOffset)-Peek.w(?comWord_ColumnsOffset)) * Peek.w(?fontwidth)
  xmax_temp.w = (Peek.l(?comLong_BlockEndX)-Peek.w(?comWord_ColumnsOffset)+1) * Peek.w(?fontwidth) -1
  If xmax_temp < $2 Then xmax_temp = $2 * Peek.w(?fontwidth) -1
  xmax.w      = xmin + xmax_temp
  ymin.w      = (Peek.l(?comLong_BlockStartY)-Peek.l(?comLong_DisplayLineOffset)) * Peek.w(?fontheight)
  ymax.w      = ymin + Peek.w(?font_Heightm1)
  RectFill_ Peek.l(?comPtr_SourceAreaRastPort),xmin,ymin,xmax,ymax
  !asm
RTS


.source_scroll_to_left:
  ;MOVEQ.l #-$10,D0
  MOVEQ #0,d0
  MOVE.w fontwidth,d0
  MULS.w #2,d0
  NEG.l d0
  MOVEA.l rp_sourcewindow,A1
  MOVEQ.l #$00,D1
  MOVEQ.l #$00,D2
  MOVEQ.l #$00,D3
  MOVEQ.l #$00,D4
  MOVEQ.l #$00,D5
  MOVE.w visiblecolumns,D4
  ;ASL.w #3,D4
  MULU fontwidth,d4
  SUBQ.w #1,D4
  MOVE.l viewablelines,D5
  MULU fontheight,D5
  SUBQ.w #1,D5
  MOVEA.l _graphicsbase,A6
  JSR _ScrollRaster(A6)              ; A1:rp, D0:dx D1:dy D2:xmin D3:ymin D4:xmax D5:ymax
  JSR _WaitBlit(A6)
  JSR delay
RTS


.source_draw_new_columns:            ;left scroll
  JSR save_cursorposition
  ;CLR.l comWord_Column
  CLR.w comWord_Column
  CLR.l comLong_DisplayLine
;  CLR.l comLong__AL_0_868A
  CLR.w comWord_TextBufferOffset
  MOVEA.l textbufferaddr,A5
  ADDA.w comWord_ColumnsOffset,A5
  MOVE.l viewablelines,D2
  SUBQ.w #1,D2
  CLR.w comWord__AL_0_869A

  JL_0_67AA:
    MOVEA.l AL_0_5B9E,A0
    MOVE.b (A5),(A0)
    MOVE.b $1(A5),$1(A0)
    MOVEQ.l #$00,D0
    MOVE.w comWord_Column,D0
    MOVE.l comLong_DisplayLine,D1
    MULU fontheight,D1
    ;ASL.w #3,D0
    MULU fontwidth,d0
    ST comWord__AL_0_8668

    MOVEM.l D2/A5,-(A7)
    MOVEM.l d0-d2/a0,-(a7)
    MOVE.l textbufferaddr,a0
    ADD.w comWord_TextBufferOffset,a0
    CLR.b instring2
    MOVE.w #0,d2
    CMP.l #0,a0
    BEQ 'l2b
    MOVE.w comWord_ColumnsOffset,d1
   'l1
      CMP.w d1,d2
      BGE 'l2b
      MOVE.b (a0)+,d0
      CMP.b #$22,d0
      BNE 'l2
      NOT.b instring2
     'l2
      ADDQ.w #1,d2
    BRA 'l1
   'l2b
    MOVEM.l (a7)+,d0-d2/a0

    MOVE.b #$1,keepstring
    JSR print_complete_line          ; print the text
    CLR.b keepstring
    MOVEM.l (A7)+,D2/A5
    BSR process_highlightning        ; beim markieren nicht verwenden, da sonst
                                     ; unter umstaenden mit flascher Hintergrundfarbe ueber den
                                     ; Block gemalt wird.
    SF comWord__AL_0_8668
    MOVEQ.l #$00,D0
;    MOVE.w comWord__AL_0_86CC,D0
;    ADD.l D0,comLong__AL_0_868A
    MOVE.w comWord_MaxColumns,D0
    ADDA.w D0,A5
    ADD.w D0,comWord_TextBufferOffset
    ADDQ.l #1,comLong_DisplayLine
  DBF D2,JL_0_67AA
  JSR restore_cursorposition
RTS


.scroll_left:
  JSR source_scroll_to_right
  JSR draw_new_columns
  JSR update_blockmark2
RTS

update_blockmark2:
  TST.l comLong_BlockEndY
   BMI.w JL_0_68C2
  MOVEA.l _graphicsbase,A6
  MOVEA.l comPtr_SourceAreaRastPort,A1
  MOVE.l comLong_DisplayLineOffset,D1
  MOVE.l D1,D2
  ADD.l viewablelines,D2
  MOVE.w comWord_ColumnsOffset,D0
  ADD.w visiblecolumns,D0
  SUBQ.w #2,D0
  CMP.l comLong_BlockEndY,D1
   BGT.w JL_0_68C2
  CMP.l comLong_BlockStartY,D2
   BLT.w JL_0_68C2
  MOVE.l comLong_BlockStartY,D4
  CMP.l comLong_BlockEndY,D4
   BEQ.w JL_0_695E
   JSR JL_0_68C4
  MOVE.l comLong_BlockStartY,D1
  SUB.l comLong_DisplayLineOffset,D1
  ADDQ.l #1,D1
  MOVE.l comLong_BlockEndY,D3
  SUB.l comLong_DisplayLineOffset,D3
  CMP.l viewablelines,D3
   BLE.w JL_0_689C
  MOVE.l viewablelines,D3

  JL_0_689C:
  CMP.w D1,D3
   BLE.w JL_0_6906
   JSR JL_0_6906
  SUB.w comWord_ColumnsOffset,D0
  ;ASL.w #3,D0
  MULU fontwidth,d0
  MOVE.w D0,D2
  ADDI.w #$F,D2
  MULU fontheight,D1
  MULU fontheight,D3
  SUBQ.w #1,D3
  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16

  JL_0_68C2:
RTS


JL_0_68C4:
  CMP.w comLong_BlockStartX,D0
   BLT.w JL_0_6904
  MOVEM.l D0-D3/A1,-(A7)
  SUB.w comWord_ColumnsOffset,D0
  ;ASL.w #3,D0
  MULU fontwidth,d0
  MOVE.w D0,D2
  ADDI.w #$F,D2
  MOVE.l comLong_BlockStartY,D1
  SUB.l comLong_DisplayLineOffset,D1
  MOVE.l D1,D3
  MULU fontheight,D1
  MULU fontheight,D3
  ADD.w font_Heightm1,D3
  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16
  MOVEM.l (A7)+,D0-D3/A1

  JL_0_6904:
RTS


JL_0_6906:
  MOVEM.l D0-D3/A1,-(A7)
  CMP.w comLong_BlockEndX,D0
   BGT.w JL_0_6958
  MOVE.w comLong_BlockEndX,D5
  SUB.w D0,D5
  ADDQ.w #1,D5
  ;ASL.w #3,D5
  MULU fontwidth,d5
  CMP.w #$10,D5
   BLE.w JL_0_692A
  MOVEQ.l #$10,D5

  JL_0_692A:
  SUB.w comWord_ColumnsOffset,D0
  ;ASL.w #3,D0
  MULU fontwidth,d0
  MOVE.w D0,D2
  ADD.w D5,D2
  SUBQ.w #1,D2
  MOVE.l comLong_BlockEndY,D1
  SUB.l comLong_DisplayLineOffset,D1
  MOVE.l D1,D3
  MULU fontheight,D1
  MULU fontheight,D3
  ADD.w font_Heightm1,D3
  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16

  JL_0_6958:
  MOVEM.l (A7)+,D0-D3/A1
RTS


JL_0_695E:
  CMP.w comLong_BlockStartX,D0
   BLT.w JL_0_68C2
  CMP.w comLong_BlockEndX,D0
   BGT.w JL_0_68C2
  MOVE.w comLong_BlockEndX,D4
  ADDQ.w #1,D4
  SUB.w D0,D4
  CMP.w #$2,D4
   BLT.w JL_0_6986
  MOVEQ.l #$02,D4

  JL_0_6986:
  ;ASL.w #3,D4
  MULU fontwidth,d4
  SUBQ.w #1,D4
  SUB.w comWord_ColumnsOffset,D0
  ;ASL.w #3,D0
  MULU fontwidth,d0
  MOVE.w D0,D2
  ADD.w D4,D2
  MOVE.l comLong_BlockStartY,D1
  SUB.l comLong_DisplayLineOffset,D1
  MOVE.w D1,D3
  MULU fontheight,D1
  MULU fontheight,D3
  ADD.w font_Heightm1,D3
  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16  JSR _RectFill(A6)
RTS


.source_scroll_to_right:
  ;MOVEQ.l #$10,D0
  MOVEQ #0,d0
  MOVE.w fontwidth,d0
  MULS.w #2,d0                       ; dx: fontwidth*2
  MOVEA.l rp_sourcewindow,A1
  MOVEQ.l #$00,D1
  MOVEQ.l #$00,D2
  MOVEQ.l #$00,D3
  MOVEQ.l #$00,D4
  MOVEQ.l #$00,D5
  MOVE.w visiblecolumns,D4
  MULU fontwidth,d4
  SUBQ.w #1,D4                      ; xmax: visiblecolumns*fontwidth

  MOVE.l viewablelines,D5
  MULU fontheight,D5
  SUBQ.w #1,D5                      ; ymax: visiblelines*fontheight

  MOVEA.l _graphicsbase,A6
  JSR _ScrollRaster(A6)             ; A1:rp, D0:dx D1:dy D2:xmin D3:ymin D4:xmax D5:ymax
  JSR _WaitBlit(A6)
  JSR delay
RTS

draw_new_columns:
  JSR save_cursorposition                   ;scroll right
  MOVE.w visiblecolumns,D0
  SUBQ.w #2,D0
  MOVE.w D0,comWord_Column
  CLR.l comLong_DisplayLine
;  CLR.l comLong__AL_0_868A
  CLR.w comWord_TextBufferOffset
  MOVEA.l textbufferaddr,A5
  ADDA.w comWord_ColumnsOffset,A5
  ADDA.w D0,A5
  MOVE.l viewablelines,D2
  SUBQ.w #1,D2
  CLR.w comWord__AL_0_869A

  JL_0_6AFA:
    MOVEA.l AL_0_5B9E,A0
    MOVE.b (A5),(A0)
    MOVE.b $1(A5),$1(A0)
    MOVEQ.l #$00,D0
    MOVE.w comWord_Column,D0
    MOVE.l comLong_DisplayLine,D1
    MULU fontheight,D1
    ;ASL.w #3,D0
    MULU fontwidth,d0
    ST comWord__AL_0_8668
    MOVEM.l d0-d2/a0,-(a7)
    MOVE.l textbufferaddr,a0
    ADD.w comWord_TextBufferOffset,a0
    CLR.b instring2
    MOVE.w #0,d2
    CMP.l #0,a0
    BEQ 'l2b
    MOVE.w comWord_ColumnsOffset,d1
    ADD.w visiblecolumns,d1
    SUBQ.w #1,d1
   'l1
      CMP.w d1,d2
      BGE 'l2b
      MOVE.b (a0)+,d0
      CMP.b #$22,d0
      BNE 'l2
      NOT.b instring2
     'l2
      ADDQ.w #1,d2
    BRA 'l1
   'l2b
    MOVEM.l (a7)+,d0-d2/a0

    MOVE.b #1,keepstring
    JSR print_complete_line
    CLR.b keepstring
    BSR process_highlightning
    SF comWord__AL_0_8668
    MOVEQ.l #$00,D0
;    MOVE.w comWord__AL_0_86CC,D0
;    ADD.l D0,comLong__AL_0_868A
    MOVE.w comWord_MaxColumns,D0
    ADDA.w D0,A5
    ADD.w D0,comWord_TextBufferOffset
    ADDQ.l #1,comLong_DisplayLine
  DBF D2,JL_0_6AFA
  JSR restore_cursorposition
RTS




.allocnewline:                ;alloc_new_line
  MOVEQ.l #$0A,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.w #$FFFF,comWord__AL_0_86C0
  !newalloc;JSR _AllocVec(A6)
  TST.l D0
  BEQ.w JL_0_6B7A
  MOVEA.l D0,A0
  CLR.l (A0)
  CLR.l $4(A0)
  MOVE.w #$0100,$8(A0)

  JL_0_6B7A:
RTS

clear_sourcebuffer:
  JSR JL_0_572C
  ;CLR.l comWord_Column
  CLR.w comWord_Column
  CLR.l comLong_DisplayLine
;  CLR.l comLong__AL_0_868A
  CLR.w comWord_TextBufferOffset
  CLR.l comLong_DisplayLineOffset
  CLR.w comWord_ColumnsOffset
  CLR.w comWord_SourceChanged
  CLR.l comPtr_LabelList
  CLR.w comWord_LabelCounter
  CLR.b comStr_SourceName
  MOVE.l #$0001,comLong_TotalLines
  JSR JL_0_5B00
  JSR update_horizscroller
  JSR update_modifiermark
  JSR update_vertscroller
  JSR update_statusline
  MOVEQ.l #-$01,D0
RTS

JL_0_6BD2:
  MOVEA.l comPtr_CurrentSourceLine,A1
  MOVE.b comByte_LabelIdentifier,D0
  MOVEM.l D0/A0-A2,-(A7)
  LEA $9(A1),A2
  MOVEA.l AL_0_5BB2,A0
  TST.b (A2)
   BEQ.b JL_0_6BFE
  MOVEQ.l #$00,D0
  MOVE.b $8(A1),D0
  MOVE.w D0,comWord__AL_0_8A6A
  SUBQ.w #1,D0

  JL_0_6BF8:
    MOVE.b (A2)+,(A0)+
  DBF D0,JL_0_6BF8
  JL_0_6BFE:
  MOVEM.l (A7)+,D0/A0-A2
  BRA.b JL_0_6C0C

  JL_0_6C04:
  MOVEA.l comPtr_CurrentSourceLine,A1
  MOVE.b comByte_LabelIdentifier,D0

  JL_0_6C0C:
  MOVE.l A1,-(A7)
  LEA $9(A1),A1
  JL_0_6C12:
  CMPI.b #$20,(A1)+
   BEQ.b JL_0_6C12
  CMP.b -(A1),D0
   ;BNE.w JL_0_6C24
  BEQ 'l10
 'l20
  MOVE.b (a1),d0                       ;pre clicksort
  BEQ JL_0_6C24
  CMP.b #";",d0
  BEQ 'l10
  CMP.b #$80,d0
  BNE 'l15
  CMP.b #$2d,1(a1)
  BEQ 'l10
 'l15
  ADDQ.l #1,a1
  BRA 'l20

 'l10
  JSR JL_0_472A

  JL_0_6C24:
  MOVEA.l (A7)+,A1
  MOVEA.l _execbase,A6
  ST comWord__AL_0_86C0
  !newfree
RTS

.clear_actualsource:
  MOVEA.l _execbase,A6
  MOVEA.l comPtr_FirstSourceLine,A2
  MOVE.l comLong_TotalLines,D2
  BEQ skip_freesource
  SUBQ.l #1,D2

  ;!basic
  ;dummy.l = RTEZRequest("comLong_TotalLines",Hex$(Peek.l(?comLong_TotalLines))+"/"+Hex$(Peek.l(?comPtr_MemPool)),"OK")
  ;!asm
  JL_0_6C40:
    MOVEA.l A2,A1
    MOVEA.l (A1),A2
    !newfree
  DBF D2,JL_0_6C40
skip_freesource:
  ST comWord__AL_0_86C0
  JSR clear_labellist
RTS


.create_whole_gui:
  JSR open_gui
   BMI.w JUMP_close_libraries
  JSR update_vertscroller
  JSR update_horizscroller
BRA.w _redraw

JUMP_close_libraries:
JMP close_libraries


ptr_visualinfo: Ds.l 1


.SetGuiFontToWBScreenFont:                               ;Subroutine to get the used Screenfont of the WB an set it as guifont  tomsmart1
    WbToScreen 0                                      ; set WB to screen 0
    *scr.Screen=Peek.l(Addr Screen(0))                ; get pointer of this screen
    If *scr<>0                                        ; check if we get a screenstructure

      *scrfont.TextAttr=*scr\Font                     ; try to get the font out of the screenstructur
      If *scrfont<>0                                  ; check if we get a TextAttrstructure

        ; In AmigaDOS we trust :
        guifontsize.w=(*scrfont.TextAttr\ta_YSize)    ; get size of the font
        guifont$=Peek$(*scrfont.TextAttr\ta_Name)     ; get name of the font

       ; message{"WB fontname="+guifont$+"("+Str$(guifontsize)+")"}  ; for debug only to see if we get the right font ;)
      EndIf

    EndIf
Return


.open_gui:
  !basic

  If (use_wbfont = True)  OR  (Peek.b(?use_wbscreen)<>0)              ; check if we use workbench fonts or screen for Gui tomsmart1

    ;Gosub SetGuiFontToWBScreenFont                                   ; try to get the workbench screen font settinge out of the screen structure tomsmart1
    ;*guifont.TextFont = screen_SetDefaultFont{guifont$,guifontsize}  ; and try to use it for the Gui of oure own screen  tomsmart1
    screen_SetDefaultSysFont{#scr_sysfont_wb_prop}                    ; switch on sysfont overwrite for use Workbench screen font  tomsmart1

  Else

    screen_SetDefaultSysFont{#scr_sysfont_wb_off}                     ; switch off sysfont overwrite we want to use the selected font for the Gui  tomsmart1

    If guifont$<>""
      If guifontsize <= 0 Then guifontsize = 6
      *guifont.TextFont = screen_SetDefaultFont{guifont$,guifontsize} ; try to set selected font for the Gui  tomsmart1
    EndIf

    If *guifont = 0                                                   ; unable to open font => use system default
      error{!TRANS{"Use of the selected font for the Gui fails,\\nwe try to get and use the font of the Workbench!"} }
      Gosub SetGuiFontToWBScreenFont                                  ; try to get the workbench screen font settinge out of the screen structure tomsmart1
      *guifont = screen_SetDefaultFont{guifont$,guifontsize}          ; and try to use it for the Gui of oure own screen  tomsmart1
    EndIf

    If *guifont
    ;  LoadFont 0,guifont$,guifontsize                                ; i am not 100% sure but i think it is not needed anymore?  tomsmart1
    Else
      error{!TRANS{"We fail also to get and use the font of the Workbench,\\nwe use now the default font."} }
      screen_SetDefaultSysFont{#scr_sysfont_wb_prop}                  ; switch on sysfont overwrite for use Workbench screen font  tomsmart1
    End If

  EndIf


  Poke$ ?str_screentitle,"AmiBlitz3 - PED V\\__VER_MAJOR.\\__VER_MINOR"
  scrname$ = Peek$(?str_screentitle)
  If Peek.b(?use_wbscreen)<>0                                    ; -- use workbench here
    If screen_Open{scrname$,#scr_mode_wb_use} = False
      !asm
      JMP error_openscreen
    Else
      Poke$ ?screen_number,"WB"
    EndIf
  Else
    If Peek.w(?use_pubscreen)<>0                                 ; -- searching for already opened ab3-screens
      screen_ziffer.b = 1 : exit_screensearch.b = False
      Repeat
        GetPubScreen 2,Peek$(?str_defaultpubscreen) + Str$(screen_ziffer)
        If Peek.l(Addr Screen(2))<>0
          ReleasePubScreen 2
          screen_ziffer + 1
        Else
          exit_screensearch = True
        EndIf
      Until exit_screensearch
      Poke$ ?screen_number,Str$(screen_ziffer)
      screen_SetPubName{Peek$(?str_defaultpubscreen)}
      WbToScreen 0 ; we need this, because GetPubScreen is steeling us the focus on screen 0
    EndIf

    If Peek.b(?clone_wbscreen)<>0                                ; -- clone the workbench for one screen
      If screen_Open{scrname$,#scr_mode_wb_clone} = False
        !asm
        JMP error_openscreen
      EndIf
    Else
      If screen_Open{scrname$,Peek.l(?ownscreen_modeid),Peek.w(?ownscreen_width),Peek.w(?ownscreen_height),Peek.w(?ownscreen_depth)} = False
        dummy.l= RTEZRequest( "",!TRANS{"Could not open selected screen.\\nTrying to open default screen."},!TRANS{"Ok"})
        Poke.b ?clone_wbscreen, 1    ;try Clone Wbscreen
        If screen_Open{scrname$,#scr_mode_wb_clone} = False
          dummy.l= RTEZRequest( "",!TRANS{"Could not open any screen, using WB."},!TRANS{"OK"})
          Poke.b ?clone_wbscreen, 0  ; no clone Wbscreen
          Poke.b ?use_wbscreen,   1  ; try use Wbscreen
          If screen_Open{scrname$,#scr_mode_wb_use} = False
            !asm
            JMP error_openscreen     ; no Screen can use => exit.
          ;Else                      ; ?
          ;  Poke.l ?use_wbscreen,0  ; ? we use the WBscreen why set it to False
          EndIf
        EndIf
        ;get current Screen infos and store it for a update prefs/save
        myscreen_Width  = screen_GetWidth{}
        myscreen_Height = screen_GetHeight{}
        myscreen_Depth  = screen_GetDepth{}
        myscreen_modeid = screen_GetBestModeID{myscreen_Width,myscreen_Height,myscreen_Depth}

        Poke.l ?ownscreen_modeid ,myscreen_modeid
        Poke.w ?ownscreen_height ,myscreen_Height
        Poke.w ?ownscreen_width  ,myscreen_Width
        Poke.w ?ownscreen_depth  ,myscreen_Depth
      Else
        ;;*scr.Screen = screen_GetPtr{}
        ;SetFont_ *scr\RastPort,*font
      EndIf
    EndIf
  EndIf
  If (screen_GetDepth{}<4); AND (Peek.b(?newcolormode)<>0)
    dummy.l = RTEZRequest("",!TRANS{"It is recommended to open a screen with\\nat least 16 colors."},!TRANS{"Ok"})
  EndIf
  Poke.s ?str_pedscreenname,Peek$(?str_screentitle)
  Poke.l ?ptr_pedscreen    ,Peek.l(Addr Screen(0))

  If screen_GetModeID{}<>#scr_mode_wb_use
    ;If Peek.w(?use_pubscreen)<>0  ; screen_Open is doing this for us
    ;  PubScreenStatus_ Peek.l(Addr Screen(0)),0   ; make the PubScreen public for real
    ;EndIf
    If Peek.w(?use_default_pubscreen)<>0
      SetDefaultPubScreen_ ?str_defaultpubscreen
    EndIf
  EndIf
  CNIF #use_NTUI ; transport the tuiPED to the screen
    ntui_PopUp{*tuiPED,"",Peek.l(?ptr_pedscreen)}
  CEND

  Gosub set_storedcolors
  !asm

  ; -- get the visualinfo-datas
  MOVE.l ptr_pedscreen,D0
  MOVEA.l _gadtoolsbase,A6
  MOVEA.l D0,A0
  MOVEA.l #0,A1
  JSR _GetVisualInfoA(A6)
  MOVE.l D0,ptr_visualinfo

  ; -- inform via arexx
  ; -- that the window is opened
  JSR arexx_send_openwindow

  !basic
  Gosub init_menus
  Gosub load_windowlayouts
  If autolayout><-1 Then AutoLayout{&wtemp,autolayout}
  Gosub do_windowlayout
  !asm
  MOVE.l #$00,D0
RTS

win_BorTop:   Dc.w 0
win_BorBot:   Dc.w 0
win_BorLef:   Dc.w 0
win_BorRig:   Dc.w 0
win_TopLeft:  Dc.w 0
win_Width:    Dc.w 1000
win_Height:   Dc.w 200

.open_sourcewindow:
  MOVEM.l D0-D7/A0-A6,-(A7)

  JL_0_6EEC:
    MOVEA.l _execbase,A6
    MOVEA.l struct_ArexxMsgPort,A0
    CMPA.l #$0,A0
     BEQ.w no_arexx_message
    JSR _GetMsg(A6)
    TST.l D0
     BEQ.w no_arexx_message
    MOVE.l D0,struct_RexxMsg
    JSR event_arexx
  BRA.b JL_0_6EEC
  no_arexx_message:

  ; -- fill font structure
  MOVEQ #0,d0
  MOVE.w sourcefontsize,D0
  MOVE.w D0,fontheight
  MOVE.l D0,fontheightl
  SUBQ.w #1,D0
  MOVE.w D0,font_Heightm1
  MOVEA.l ptr_sourcefont,A0
  MOVE.w $18(A0),fontwidth
  MOVE.w $1A(A0),D0
  MOVE.w D0,font_Baseline

  !basic
  DEFTYPE.Image       *img             ; An image which represents the size gadget
  DEFTYPE.Image       *sizeimage,*rarrowimage,*larrowimage,*darrowimage,*uarrowimage
  DEFTYPE.Gadget      *horizprop,*rarrowbutton,*larrowbutton,*darrowbutton,*uarrowbutton
  DEFTYPE.l sizew,sizeh,w,h,barh,exit

  Dim GTags.TagItem(4) ; -- Tags for getting the size gadget image
  If Used Screen < 0 Then WbToScreen 0
  *myscreen = Peek.l(Addr Screen(Used Screen))
  If *myscreen <> 0
    Poke.b ?comByte_ScreenBarHeight, *myscreen\BarHeight
    If Peek.w(?win_Width)<32  Then Poke.w ?win_Width, (*myscreen\Width - Peek.w(?win_TopLeft)-1)
    If Peek.w(?win_Height)<32 Then Poke.w ?win_Height ,(*myscreen\Height - Peek.w(?win_TopEdge)-1)
    If Peek.w(?win_TopEdge)+Peek.w(?win_Height )> *myscreen\Height Then Poke.w ?win_Height ,*myscreen\Height-Peek.w(?win_TopEdge)
    If Peek.w(?win_TopLeft)+Peek.w(?win_Width) > *myscreen\Width  Then Poke.w ?win_Width, *myscreen\Width-Peek.w(?win_TopLeft)

    Poke.w ?win_BorTop, *myscreen\WBorTop + *myscreen\Font\ta_YSize + 1
    Poke.w ?win_BorBot, 10
    Poke.w ?win_BorRig, 18
    Poke.w ?win_BorLef, *myscreen\WBorLeft

    *drawinfo = GetScreenDrawInfo_(*myscreen)
    If *drawinfo
      If (*myscreen\Flags & #SCREENHIRES) Then sis.l=#SYSISIZE_HIRES Else sis=#SYSISIZE_MEDRES
      GTags(0)\ti_Tag = #SYSIA_DrawInfo,*drawinfo
      GTags(1)\ti_Tag = #SYSIA_Which,#SIZEIMAGE
      GTags(2)\ti_Tag = #SYSIA_Size,sis
      GTags(3)\ti_Tag = #TAG_DONE
      *img = NewObjectA_(0,"sysiclass",&GTags(0))
      If *img
        Poke.w ?win_BorRig, *img\Width
        Poke.w ?win_BorBot, *img\Height
        DisposeObject_ *img
      EndIf
      FreeScreenDrawInfo_ *myscreen,*drawinfo
    EndIf
  Else
    !asm
    JSR close_gui
    JMP error_openscreen
  EndIf
  !asm
  MOVEM.l (A7)+,D0-D7/A0-A6


  MOVEM.l D2-D7/A2-A6,-(A7)
  TST.l ptr_sourcewindow
   BNE.w win_already_open
  ; --
  ; --Berechnung des Sourcelayouts, Groesse der Scroller etc.
  ; --
  JSR sub_calculatedimensions
  ;
  ; -- Speicher reservieren fuer sichtbaren Sourcebereich
  ;
  BSR allocate_textbuffer

  ; --
  ; -- Fenster erzeugen
  ; --
  !basic
  #GID_XPROP  =900
  #GID_YPROP  =901
  #GID_RARROW =910
  #GID_LARROW =911
  #GID_UARROW =912
  #GID_DARROW =913

  *drawinfo = GetScreenDrawInfo_(*myscreen)
  If (*myscreen\Flags & #SCREENHIRES)
    syssize.b = #SYSISIZE_MEDRES
  Else
    syssize = #SYSISIZE_LOWRES
  EndIf
  *sizeimage = NewObjectA_(0,"sysiclass",Tags(#SYSIA_Which,#SIZEIMAGE,@@
                                                #SYSIA_Size     ,syssize,@@
                                                #SYSIA_DrawInfo ,*drawinfo,@@
                                                #TAG_END        ,0))
  If (*sizeimage)
    GetAttr_ #IA_Width,*sizeimage ,&sizew
    GetAttr_ #IA_Height,*sizeimage,&sizeh
    DisposeObject_ *sizeimage
  Else
    sizew = 18
    sizeh = 10
  EndIf

  *darrowimage = NewObjectA_(0,"sysiclass",Tags(#SYSIA_Which,#DOWNIMAGE,@@
                                                   #SYSIA_Size     ,syssize,@@
                                                   #SYSIA_DrawInfo ,*drawinfo,@@
                                                   #TAG_END        ,0))
  If (*darrowimage)
    GetAttr_ #IA_Width ,*darrowimage,&w
    GetAttr_ #IA_Height,*darrowimage,&h
  EndIf

  *darrowbutton = NewObjectA_(0,"buttongclass",Tags(#GA_ID,#GID_DARROW,@@
    #GA_RelRight    ,-w+1,@@
    #GA_RelBottom   ,-sizeh-h+1,@@
    #GA_Width       ,w,@@
    #GA_Height      ,h,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,*drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #GA_Image       ,*darrowimage,@@
    #TAG_END        ,0))

  *uarrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#UPIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,*drawinfo,@@
    #TAG_END        ,0))

  If (*uarrowimage)
    GetAttr_ #IA_Width ,*uarrowimage,&w
    GetAttr_ #IA_Height,*uarrowimage,&h
  EndIf

  *uarrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous    ,*darrowbutton,@@
    #GA_ID          ,#GID_UARROW,@@
    #GA_RelRight    ,-w+1,@@
    #GA_RelBottom   ,-sizeh-h-h+1,@@
    #GA_Width       ,w,@@
    #GA_Height      ,h,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,*drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #GA_Image       ,*uarrowimage,@@
    #TAG_END        ,0))

  barh = *myscreen\WBorTop+*myscreen\RastPort\TxHeight+2

  *vertiprop = NewObjectA_(0,"propgclass",Tags(@@
    #GA_Previous    ,*uarrowbutton,@@
    #GA_ID          ,#GID_YPROP,@@
    #GA_RelRight    ,-sizew+4,@@
    #GA_Top         ,barh,@@
    #GA_Width       ,sizew-6,@@
    #GA_RelHeight   ,-sizeh-h-h-barh-1,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,*drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #PGA_Freedom    ,#FREEVERT,@@
    #PGA_Borderless ,True,@@
    #PGA_NewLook    ,True,@@
    #PGA_Total      ,1,@@
    #PGA_Visible    ,1,@@
    #TAG_END        ,0))

  *rarrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#RIGHTIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,*drawinfo,@@
    #TAG_END        ,0))

  If (*rarrowimage)
    GetAttr_ #IA_Width ,*rarrowimage,&w
    GetAttr_ #IA_Height,*rarrowimage,&h
  EndIf

  *rarrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous     ,*vertiprop,@@
    #GA_ID           ,#GID_RARROW,@@
    #GA_RelRight     ,-sizew-w+1,@@
    #GA_RelBottom    ,-h+1,@@
    #GA_Width        ,w,@@
    #GA_Height       ,h,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,*drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #GA_Image        ,*rarrowimage,@@
    #TAG_END         ,0))

  *larrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#LEFTIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,*drawinfo,@@
    #TAG_END        ,0))

  If (*larrowimage)
    GetAttr_ #IA_Width ,*larrowimage,&w
    GetAttr_ #IA_Height,*larrowimage,&h
  EndIf

  *larrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous     ,*rarrowbutton,@@
    #GA_ID           ,#GID_LARROW,@@
    #GA_RelRight     ,-sizew-w-w+1,@@
    #GA_RelBottom    ,-h+1,@@
    #GA_Width        ,w,@@
    #GA_Height       ,h,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,*drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #GA_Image        ,*larrowimage,@@
    #TAG_END         ,0))

  *horizprop = NewObjectA_(0,"propgclass",Tags(@@
    #GA_Previous     ,*larrowbutton,@@
    #GA_ID           ,#GID_XPROP,@@
    #GA_Left         ,*myscreen\WBorLeft,@@
    #GA_RelBottom    ,-sizeh+3,@@
    #GA_RelWidth     ,-sizew-w-w-*myscreen\WBorLeft-1,@@
    #GA_Height       ,sizeh-4,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,*drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #PGA_Freedom     ,#FREEHORIZ,@@
    #PGA_Borderless  ,True,@@
    #PGA_NewLook     ,True,@@
    #PGA_Total       ,#MAX_Columns,@@
    #PGA_Visible     ,20,@@
    #TAG_END         ,0))


  If (*vertiprop=0) OR( *horizprop=0)
    dummy= RTEZRequest("",Hex$(*vertiprop),Hex$(*horizprop))
    !asm
    CLR.l ptr_sourcewindow
    BRA.w error_opensourcewindow                   ; bei Fehler ...
  EndIf
  *sourcewin.Window = OpenWindowTagList_(0,Tags(@@
                      #WA_Title      ,Null("AmiBlitz"),@@
                      #WA_Left       ,Peek.w(?win_TopLeft),@@
                      #WA_Top        ,Peek.w(?win_TopEdge),@@
                      #WA_Height     ,Peek.w(?win_Height ),@@
                      #WA_Width      ,Peek.w(?win_Width),@@
                      #WA_MinWidth   ,256,@@
                      #WA_MaxWidth   ,-1,@@
                      #WA_MinHeight  ,80,@@
                      #WA_MaxHeight  ,-1,@@
                      #WA_Flags      ,#WFLG_NEWLOOKMENUS|#WFLG_WBENCHWINDOW|#WFLG_ACTIVATE|#WFLG_GIMMEZEROZERO|#WFLG_SIZEBBOTTOM|#WFLG_SIZEBRIGHT|#WFLG_CLOSEGADGET|#WFLG_DEPTHGADGET|#WFLG_DRAGBAR|#WFLG_SIZEGADGET,@@
                      #WA_IDCMP      ,#IDCMP_INTUITICKS|#IDCMP_CLOSEWINDOW|#IDCMP_VANILLAKEY|#IDCMP_RAWKEY|#IDCMP_MENUPICK|#IDCMP_GADGETUP|#IDCMP_GADGETDOWN|#IDCMP_MOUSEBUTTONS|#IDCMP_NEWSIZE|#IDCMP_REFRESHWINDOW,@@
                      #WA_Gadgets    ,*darrowbutton,@@
                      #WA_PubScreen  ,*myscreen))
  If *sourcewin = 0
    !asm
    CLR.l ptr_sourcewindow
    BRA.w error_opensourcewindow                   ; bei Fehler ...
  EndIf

  Poke.l ?ptr_sourcewindow,*sourcewin
  Poke.l ?rp_sourcewindow ,*sourcewin\RPort

  ; Anhaengen des Menus
  If Peek.l(?addr_menustrip) Then SetMenuStrip_ *sourcewin,Peek.l(?addr_menustrip)

  ; Setzen des Standardfonts
  SetFont_ *sourcewin\RPort,Peek.l(?ptr_sourcefont)
  !asm

  MOVE.w #$FFFF,comWord_LabelListChanged     ; was soll das ??
  MOVEA.l _execbase,A6
  SUBA.l A1,A1
  JSR _FindTask(A6)
  MOVEA.l D0,A0
  MOVE.l $B8(A0),AL_0_7356
  MOVE.l ptr_sourcewindow,$B8(A0)

  win_already_open:
  !basic
  ; -- Setzen des WindowTitles
  SetWindowTitles_ *sourcewin,?str_screentitle,-1
  !asm
  JSR update_statusline
  JSR set_pointernormal

  ; -- allocate memory for temp rastport
  MOVEM.l D0-D1/A0-A1/A6,-(A7)
  MOVEA.l _execbase,A6
  MOVEQ.l #$64,D0
  MOVEQ.l #$00,D1
  !newalloc
  MOVE.l D0,comPtr_SourceAreaRastPort
  MOVEA.l rp_sourcewindow,A0
  MOVEA.l D0,A1
  MOVEQ.l #$63,D0
  JL_0_7300:
    MOVE.b (A0)+,(A1)+
  DBF D0,JL_0_7300
  MOVEA.l _graphicsbase,A6
  MOVEA.l comPtr_SourceAreaRastPort,A1
  MOVEQ.l #$02,D0
  JSR _SetDrMd(A6)
  MOVEM.l (A7)+,D0-D1/A0-A1/A6

  JSR _redraw
  JSR update_horizscroller
  JSR update_vertscroller
  MOVEM.l (A7)+,D2-D7/A2-A6
  MOVEQ.l #$00,D0
RTS


.sub_calculatedimensions:
  !basic
  Poke.w ?win_InnerHeight, Peek.w(?win_Height ) - Peek.w(?win_BorTop) - Peek.w(?win_BorBot)
  Poke.w ?win_InnerWidth , Peek.w(?win_Width)   - Peek.w(?win_BorLef) - Peek.w(?win_BorRig)

  CLR.l d0
  MOVE.w win_InnerHeight,D0 : wih.l = PutD0
  MOVE.l fontheightl,D0     : fhl.l = PutD0

  visibleLines.l = (wih - 8) / fhl          ; 6 Pixel fehlen wg. Trennlinie etc.
  If visibleLines > 125 Then visibleLines = 125 ; why?
  GetD0 visibleLines
  SUBQ.l #1,D0
  MOVE.l d0,viewablelines
  !asm
  SUBQ.l #1,D0                          ;
  MOVE.l D0,viewablelines_m1
  ADDQ.l #1,D0
  MULU fontheight,D0
;  SUBQ.l #1,D0
  MOVE.w D0,ypos_statusarea             ; Y-Position Statusarea festlegen

  MOVE.w win_Width,D0
  SUB.w fontwidth,d0                    ;
  EXT.l d0
  DIVU fontwidth,d0
  BCLR #$0,D0
  BCLR #$0,AL_0_B7F4
;  MOVE.w D0,comWord__AL_0_8678
;  SUB.w comWord_LabelSize,D0                   ; clicklabels 0 = off >0 on
  BCLR #0,d0
  SUBQ.w #2,D0
  MOVE.w D0,visiblecolumns              ; x pos of clickwin *8+12
  SUBQ.w #1,D0
  BCLR #0,d0
  MOVE.w D0,comWord__AL_0_8670
;  ADDQ.w #1,D0

  MOVE.w comWord_LabelSize,comWord_LabelSizeC
RTS


.error_opensourcewindow:
  JSR free_textbuffer
  JSR close_sourcewindow
  JSR error_unable_window

  JL_0_7334:
  MOVEA.l ptr_pedscreen,A0
  MOVEA.l _intuibase,A6
  !basic
  !coutclose
  Gosub close_bubblehelp
  Gosub close_popupwindow
  WZCloseWindow WZID("WIN_AUTODOC")
  WZCloseWindow WZID("WIN_INSTRUCTIONBROWSER")
  WZCloseWindow WZID("WIN_NEWTYPE")
  WZCloseWindow WZID("WIN_LABELS")
  WZCloseWindow WZID("WIN_HELPDIAG")
  WZCloseWindow WZID("WIN_SHORTCUTS")
  WZCloseWindow WZID("WIN_LIBRARYBROWSER")
  WZCloseWindow WZID("WIN_SEARCH")
  WZCloseWindow WZID("WIN_HELP")

  ;If Peek.b(?use_wbscreen)=0
    screen_Close{} ;/* screen close knows if it is on wb! */
  ;EndIf
  !asm
JMP close_libraries
;  MOVEM.l (A7)+,D2-D7/A2-A6
  ; set Reg D0 to negative for return value of open_gui
;  MOVEQ.l #-$01,D0
;RTS

.error_openscreen:
  JSR free_textbuffer
  JSR error_unable_screen
  ; set Reg D0 to negative for return value of open_gui
  MOVEQ.l #-$01,D0
RTS

AL_0_7356:    Ds.l 1

.print_actualsourceline:
  MOVE.l #$20202020,str_actualline
  MOVE.l #$20200000,str_actualline+4    ; loeschen von "str_actualline" ; changed form #$20000000 to #$2020000 that the function "format_value" use 6 instead of 5 columns for up to 999999 lines  tomsmart1
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  ADDQ.l #1,D0
  LEA str_actualline,A0
  JSR format_value
  MOVEQ.l #$06,D0                 ; xpos=6 in D0 laden
  LEA str_actualline,A0                 ; text laden
  JSR print_statustext          ; text in statusarea darstellen
RTS

.print_actualsourcecolumn
  MOVE.l #$20202000,comLong_ActualColumn
  MOVEQ #0,d0
  MOVE.w comWord_ColumnsOffset,D0
  ADD.w comWord_Column,D0
  ADDQ.w #1,D0
  LEA comLong_ActualColumn,A0
  JSR format_value
  MOVEQ.l #$15,D0                 ; xpos=21   ; added 1 to move the print of the Columnnumber to the right to support up to 999999 Lines  tomsmart1
  LEA comLong_ActualColumn,A0
  JSR print_statustext      ; print column in statusarea
RTS




text_ptr:   Ds.l 1

.print_statustext:        ; d0:xpos, a0: textpointer
  ; X-Position ermitteln
  MULU fontwidth,D0
  MOVE.l A0,text_ptr
  !basic
  xpos_text.l = PutD0 + 2
  MOVE.l text_ptr,d0 :_d0.l = PutD0 : txt$ = Peek$(_d0)
  If FLen(txt$)>0
    *rastp.RastPort = Peek.l(?rp_sourcewindow)
    *swin.Window    = Peek.l(?ptr_sourcewindow)
    *tfont.TextFont = Peek.l(?ptr_sourcefont)

    ypos_sa.w = Peek.w(?ypos_statusarea) + 1
    ypos_text.w = ypos_sa + 2 + *tfont\tf_Baseline + 1

    SetAPen_ *rastp, AB3Pen(#AB3_screenshine)
    SetBPen_ *rastp, AB3Pen(#AB3_screenfill)
    Move_ *rastp, xpos_text, ypos_text
    If Vallong(txt$)= 0
      SetFont_ *rastp,Peek.l(?ptr_sourcefontb)
      SetSoftStyle_ *rastp,#FSF_BOLD,#FSF_BOLD
    EndIf
    Text_ *rastp,&txt$,FLen(txt$)
    SetFont_ *rastp,Peek.l(?ptr_sourcefont)
    SetSoftStyle_ *rastp,#FS_NORMAL,#FSF_BOLD
    SetBPen_ *rastp,Peek.l(?backgroundcolor)
  EndIf
  !asm
RTS

.update_statusline:               ; d0:xpos, a0: textpointer
  ; X-Position ermitteln
  !basic
  *rastp.RastPort = Peek.l(?rp_sourcewindow)
  *swin.Window    = Peek.l(?ptr_sourcewindow)
  *tfont.TextFont = Peek.l(?ptr_sourcefont)

  ypos_sa.w = Peek.w(?ypos_statusarea) + 1
  Poke.w ?yposlow, ypos_text

  SetAPen_ *rastp,AB3Pen(#AB3_screenfill)
  RectFill_ *rastp,0,ypos_sa + 2,*swin\Width-1,*swin\Height-12

  ; Draw separation lines
  SetAPen_ *rastp, AB3Pen(#AB3_screenshine)
  Move_ *rastp,0,ypos_sa
  Draw_ *rastp,*swin\Width-1,ypos_sa
  SetAPen_ *rastp, AB3Pen(#AB3_screentext)
  Move_ *rastp,0,ypos_sa + 1
  Draw_ *rastp,*swin\Width-1,ypos_sa + 1
  SetAPen_ *rastp, AB3Pen(#AB3_screentext)
  SetBPen_ *rastp, AB3Pen(#AB3_screenfill)

  xpos_text.l = (#filenamepos-1) * *tfont\tf_XSize - (*tfont\tf_XSize/2)
  SetAPen_ *rastp, AB3Pen(#AB3_screenshine)
  Move_ *rastp,xpos_text+1,ypos_sa + 2
  Draw_ *rastp,xpos_text+1,ypos_sa + 2 + *tfont\tf_YSize*3
  SetAPen_ *rastp, AB3Pen(#AB3_screentext)
  Move_ *rastp,xpos_text,ypos_sa + 2
  Draw_ *rastp,xpos_text,ypos_sa + 2 + *tfont\tf_YSize*3
  ;statusline.s = "Zeile" ; test for localizing the lien/column
  ;statuscolumn.s = "Spalte"
  ;GetReg d0,&statusline.s
  ;GetReg d1,&statuscolumn.s
  ;MOVE.l d0,statcolumn
  ;MOVE.l d1,statline
  !asm
  MOVEQ.l #$00,D0                        ; x postion to print the Line string on the screen
  LEA comStr_StatusString,A0             ; "Line"
  ;MOVE.l statline,A0
  JSR print_statustext
  MOVEQ.l #13,D0                         ; added 2 to the x postion to move it to the right to support up to 999999 Lines  tomsmart1
  LEA comStr_StatusString+13,A0          ; "Column" ; also here added 2 to get the new start position of the Column string  tomsmart1
  ;MOVE.l statcolumn,A0
  JSR print_statustext
  JSR print_actualsourceline
  JSR print_actualsourcecolumn
  JSR print_filenames
RTS
;statcolumn: Dc.l 0
;statline:   Dc.l 0

.free_textbuffer:
  TST.l textbufferaddr
  BEQ.w JL_0_74AE
  MOVEM.l D0-D1/A0-A1/A6,-(A7)
  MOVEA.l textbufferaddr,A1
  MOVEA.l _execbase,A6
  ST comWord__AL_0_86C0
  !newfree
  MOVEM.l (A7)+,D0-D1/A0-A1/A6
  JL_0_74AE:
RTS

.allocate_textbuffer:
  MOVEA.l _execbase,A6
  MOVE.w comWord_MaxColumns,D0
  MULU viewablelines+2,D0
  MOVEQ.l #$02,D1
  MOVE.w D1,comWord__AL_0_86C0
  !newalloc
  MOVE.l D0,textbufferaddr
  BEQ.w JL_0_7334 ; quit ped
RTS




.close_gui:
  !basic
  Gosub kill_menus
  Gosub close_bubblehelp
  Gosub close_popupwindow
  WZCloseWindow WZID("WIN_AUTODOC")
  WZCloseWindow WZID("WIN_INSTRUCTIONBROWSER")
  WZCloseWindow WZID("WIN_NEWTYPE")
  WZCloseWindow WZID("WIN_LABELS")
  WZCloseWindow WZID("WIN_HELPDIAG")
  WZCloseWindow WZID("WIN_SHORTCUTS")
  WZCloseWindow WZID("WIN_LIBRARYBROWSER")

  WZCloseWindow WZID("WIN_SEARCH")
  WZCloseWindow WZID("WIN_HELP")
  If Peek.l(?CLI_output_file)<>0
    Close_ Peek.l(?CLI_output_file)
    Poke.l ?CLI_output_file,0
  EndIf
  CNIF #use_NTUI
    ntui_Iconify{*tuiPED}
  CEND
  !asm
  JSR close_sourcewindow
  JSR arexx_send_closewindow

  MOVEA.l ptr_visualinfo,A0
  MOVEA.l _gadtoolsbase,A6
  JSR _FreeVisualInfo(A6)
  CLR.l ptr_visualinfo

  MOVEA.l _execbase,A6
  SUBA.l A1,A1
  JSR _FindTask(A6)
  MOVEA.l D0,A0
  MOVE.l AL_0_7356,$B8(A0)

  BSR.b free_textbuffer

  TST.w use_pubscreen
   BEQ.w JL_0_7518
  MOVEA.l _intuibase,A6
  MOVEA.l ptr_pedscreen,A0
  MOVEQ.l #$01,D0
  JSR _PubScreenStatus(A6)

 JL_0_7518:
  !basic
  vvblank_Free{}
  screen_Close{}   ; this release all pens for us  and close the used font
  !asm
RTS


.close_sourcewindow:
  MOVEM.l D2-D7/A2-A6,-(A7)

  CLR.l messagestore

  TST.l ptr_sourcewindow
   BEQ.w exit_closesourcewindow

  JSR check_intuimsg

  !basic
  CloseWindow_ *sourcewin : *sourcewin = 0
;  Poke.l Addr Window(0),0

  DisposeObject_ *larrowbutton
  DisposeObject_ *larrowimage
  DisposeObject_ *rarrowbutton
  DisposeObject_ *rarrowimage
  DisposeObject_ *horizprop
  DisposeObject_ *darrowbutton
  DisposeObject_ *darrowimage
  DisposeObject_ *uarrowbutton
  DisposeObject_ *uarrowimage
  DisposeObject_ *vertiprop
  FreeScreenDrawInfo_ *myscreen,*drawinfo
  !asm
  CLR.l ptr_sourcewindow
  ; -- clear rastport for source area
  TST.l comPtr_SourceAreaRastPort
   BEQ.w exit_closesourcewindow
  MOVEA.l _execbase,A6
  MOVEA.l comPtr_SourceAreaRastPort,A1
  !newfree
  exit_closesourcewindow:

  MOVEM.l (A7)+,D2-D7/A2-A6
RTS


.set_storedcolors:
  screen_ReleaseAllPens{} ; release all pens that have been previously obtained by screen.include

  If Peek.b(?use_wbscreen) = False
    screen_SetPenRGB{0             ,AB3RGB(#AB3_screenback) }
    screen_SetPenRGB{1             ,AB3RGB(#AB3_screentext) }
    screen_SetPenRGB{2             ,AB3RGB(#AB3_screenshine)}
    screen_SetPenRGB{3             ,AB3RGB(#AB3_screenfill) }
    AB3Pen(#AB3_screenback)        = screen_GetPenRGB{AB3RGB(#AB3_screenback) }
    AB3Pen(#AB3_screentext)        = screen_GetPenRGB{AB3RGB(#AB3_screentext) }
    AB3Pen(#AB3_screenshine)       = screen_GetPenRGB{AB3RGB(#AB3_screenshine)}
    AB3Pen(#AB3_screenfill)        = screen_GetPenRGB{AB3RGB(#AB3_screenfill) }
  Else
    AB3Pen(#AB3_screenback)        = 0
    AB3Pen(#AB3_screentext)        = 1
    AB3Pen(#AB3_screenshine)       = 2
    AB3Pen(#AB3_screenfill)        = 3
  EndIf

  AB3Pen(#AB3_cfunction)           = screen_GetPenRGB{AB3RGB(#AB3_cfunction)}
  AB3Pen(#AB3_cmacro)              = screen_GetPenRGB{AB3RGB(#AB3_cmacro)}
  AB3Pen(#AB3_cstring)             = screen_GetPenRGB{AB3RGB(#AB3_cstring)}
  AB3Pen(#AB3_cnewtype)            = screen_GetPenRGB{AB3RGB(#AB3_cnewtype)}
  AB3Pen(#AB3_cconstant)           = screen_GetPenRGB{AB3RGB(#AB3_cconstant)}
  AB3Pen(#AB3_cremarkforeground)   = screen_GetPenRGB{AB3RGB(#AB3_cremarkforeground)}
  AB3Pen(#AB3_cremarkbackground)   = screen_GetPenRGB{AB3RGB(#AB3_cremarkbackground)}
  AB3Pen(#AB3_ctoken)              = screen_GetPenRGB{AB3RGB(#AB3_ctoken)}
  AB3Pen(#AB3_ctokenbackground)    = screen_GetPenRGB{AB3RGB(#AB3_ctokenbackground)}
  AB3Pen(#AB3_cbackground)         = screen_GetPenRGB{AB3RGB(#AB3_cbackground)}
  AB3Pen(#AB3_cother)              = screen_GetPenRGB{AB3RGB(#AB3_cother)}
  AB3Pen(#AB3_cclassic)            = screen_GetPenRGB{AB3RGB(#AB3_cclassic)}

  Poke.l ?functioncolor            ,AB3Pen(#AB3_cfunction)
  Poke.l ?macrocolor               ,AB3Pen(#AB3_cmacro)
  Poke.l ?stringcolor              ,AB3Pen(#AB3_cstring)
  Poke.l ?newtypecolor             ,AB3Pen(#AB3_cnewtype)
  Poke.l ?constantcolor            ,AB3Pen(#AB3_cconstant)
  Poke.l ?remarkcolor              ,AB3Pen(#AB3_cremarkforeground)
  Poke.l ?remarkbgcolor            ,AB3Pen(#AB3_cremarkbackground)
  Poke.w ?tokencolor               ,AB3Pen(#AB3_ctoken)
  Poke.l ?tokenbackground          ,AB3Pen(#AB3_ctokenbackground)
  Poke.l ?backgroundcolor          ,AB3Pen(#AB3_cbackground)
  Poke.w ?othercolor               ,AB3Pen(#AB3_cother)
  Poke.l ?classiccolor             ,AB3Pen(#AB3_cclassic)

RTS



.save_cursorposition:
  MOVE.w comWord_Column,comWord_StoreColumn
  MOVE.l comLong_DisplayLine,comLong_StoreDisplayLine
  MOVE.w comWord_TextBufferOffset,comWord_StoreTextBufferOffset
RTS

.restore_cursorposition:
  MOVE.w comWord_StoreColumn,comWord_Column
  MOVE.l comLong_StoreDisplayLine,comLong_DisplayLine
  MOVE.w comWord_StoreTextBufferOffset, comWord_TextBufferOffset
RTS

.clear_sourcewindow_visual:
  ; -- clear the codelines in window
  MOVEA.l _graphicsbase,A6
  MOVEA.l rp_sourcewindow,A1
  MOVE.l backgroundcolor,D0
  JSR _SetAPen(A6)

  MOVEQ.l #$00,D0
  MOVEQ.l #$00,D1
  MOVE.w win_InnerWidth,D2
  MOVE.w ypos_statusarea,D3
  JSR _RectFill(A6)              ;A1:rp, D0:xm in, D1:ymin, D2:xmax, D3:ymax  d0-d3:16

.clear_sourcewindow:
  ; -- clear current text memoryarea
  MOVEA.l textbufferaddr,A0
  MOVE.w comWord_MaxColumns,D0
  LSR.w #1,D0
  MOVE.l viewablelines,D1
  MULS d0,d1
  SUBQ.w #1,D1

  JL_0_76A6:
    MOVE.w #$2020,(A0)+
  DBF D1,JL_0_76A6
  RTS

JL_0_76E8:
RTS

.delay:
  TST.b old_scrolling
  BNE 'old
  !basic
  vvblank_Wait{}
  ;vvblank_WaitSync{1}
  ;vvblank_ResetSync{}
  !asm
 'old
RTS

JL_0_76EA:
  MOVEA.l textbufferaddr,A0
  ADDA.w comWord_TextBufferOffset,A0
  ADDA.w comWord_ColumnsOffset,A0
  ADDA.w comWord_Column,A0
  MOVE.b D0,(A0)
  MOVE.b D0,comByte_EnteredCharacter
  MOVEQ.l #$00,D0
  MOVE.l comLong_DisplayLine,D1
  MOVE.w comWord_Column,D0

  TST.l comLong_BlockEndY
   BMI.w JL_0_7742
  MOVEM.l D0-D1,-(A7)
  ADD.w comWord_ColumnsOffset,D0
  ADD.l comLong_DisplayLineOffset,D1
  JSR JL_0_3154
  MOVEM.l (A7)+,D0-D1
  TST.b comByte_StateBlockMark
   BEQ.w JL_0_7742
  ST comWord_CursorInMarkedBlock
  JL_0_7742:

  ; -- print entered character to source window
  MULU fontheight,D1
  MULU fontwidth,D0
  LEA comByte_EnteredCharacter,A0
  CLR.w comWord__AL_0_869A
  JSR JL_0_5BB6
  SF comWord_CursorInMarkedBlock
RTS

JL_0_775E:
;  MOVE.l comLong_DisplayLine,D1
;  MULU comWord__AL_0_86CC,D1
;  MOVE.l D1,comLong__AL_0_868A
  MOVE.l comLong_DisplayLine,D1
  MULU comWord_MaxColumns,D1
  MOVE.w D1, comWord_TextBufferOffset
RTS

.cursor_on:
  TST.w state_of_cursor
   BNE.w exit_cursor_on

.cursor_on_force
  MOVEA.l comPtr_SourceAreaRastPort,A1
  MOVE.b #3,$18(a1)
  JSR switch_cursordisplay
  MOVEA.l comPtr_SourceAreaRastPort,A1
  MOVE.b #15,$18(a1)

  exit_cursor_on:
RTS

.cursor_off:
  TST.w state_of_cursor
  BEQ.w exit_cursor_off

  MOVEA.l comPtr_SourceAreaRastPort,A1
  MOVE.b #3,$18(a1)
  JSR switch_cursordisplay
  MOVEA.l comPtr_SourceAreaRastPort,A1
  MOVE.b #15,$18(a1)
  exit_cursor_off:
RTS

state_of_cursor:  Ds.w 1

.switch_cursordisplay:
  TST.l ptr_sourcewindow
   BEQ.w exit_switch_cursor
  NOT state_of_cursor

  draw_cursor:
  MOVEM.l D0-D3/A0-A1/A6,-(A7)
  !basic
  If Peek.l(?comLong_DisplayLine) > Peek.l(?viewablelines)-1
    Poke.l ?comLong_DisplayLine, Peek.l(?viewablelines)-1
  EndIf
  xmin.w = Peek.w(?comWord_Column) * Peek.w(?fontwidth)
  ymin.w = Peek.l(?comLong_DisplayLine) * Peek.w(?fontheight)
  xmax.w = xmin + Peek.w(?fontwidth) - 1
  ymax.w = ymin + Peek.w(?font_Heightm1)
  RectFill_ Peek.l(?comPtr_SourceAreaRastPort),xmin,ymin,xmax,ymax
  !asm
  MOVEM.l (A7)+,D0-D3/A0-A1/A6

  exit_switch_cursor
RTS

.update_vertscroller:
  BSR.b print_actualsourceline
  !basic

  ; Honitos' old code
;  ypot.l = PutD0
;  MOVE.l comLong_DisplayLineOffset,d0
;  ;ADD.l comLong_DisplayLine,d0
;  yact.l = PutD0
;  MOVE.l comLong_TotalLines,d0
;  ymax_slider.l = PutD0 ;+ 8
;  MOVE.l viewablelines,d0
;  yvis.l = PutD0
;  SetGadgetAttrsA_ *vertiprop,*sourcewin,0,Tags(@@;#PGA_VertBody,ypot,@@
;                                            #PGA_HorizPot,-1,@@
;                                            #PGA_HorizBody,-1,@@
;                                            #PGA_Top,yact,@@
;                                            #PGA_Total,ymax_slider,@@
;                                            #PGA_Visible,yvis)
;

  ; Thilo's new code for fix slider base
  MOVE.l comLong_DisplayLineOffset,d0  : slider_top.l     = PutD0
  MOVE.l comLong_TotalLines,d0         : slider_total.l   = PutD0
  MOVE.l viewablelines,d0              : slider_visible.l = PutD0

  ;/ scale
  If slider_total>0
    If slider_total>=#max_slider_res
      !mul48f{slider_visible,#max_slider_res,slider_total,slider_visible}  : If slider_visible<1 Then slider_visible=1
      !mul48f{slider_top    ,#max_slider_res,slider_total,slider_top}
      slider_total   = #max_slider_res
    End If
    SetGadgetAttrsA_ *vertiprop,*sourcewin,0,Tags(@@
                                            #PGA_Total  ,slider_total,@@
                                            #PGA_Top    ,slider_top,@@
                                            #PGA_Visible,slider_visible)
  End If
  !asm
RTS

.update_modifiermark:
  MOVEM.l D0/A0-A1/A3,-(A7)
  TST.w comWord_KeyBeforeReturn
  BNE.w JL_0_78B6
  TST.w comWord_SourceChanged
   BNE.w JL_0_78B6
  CMPI.w #$1,comWord_SourceModifiedFlag
  BEQ.w JL_0_78F6
  MOVE.w #$0001,comWord_SourceModifiedFlag
  MOVE.l #$20202020,comStr_Modified               ; clear string  tomsmart1
  MOVE.l #$20202020,comStr_Modified+4
  MOVE.b #$0,comStr_Modified+8                    ; terminate the string tomsmart
  BRA.w JL_0_78E6

  JL_0_78B6:
  CMPI.w #$2,comWord_SourceModifiedFlag
  BEQ.w JL_0_78F6
  MOVE.w #$0002,comWord_SourceModifiedFlag
  MOVE.l #$4D4F4449,comStr_Modified        ;write modified in the strind start with "MODI"
  MOVE.l #$46494544,comStr_Modified+4      ;then the rest "FIED"
  MOVE.b #$0,comStr_Modified+8             ; terminate the string  tomsmart1

  JL_0_78E6:
;  MOVEQ.l #$00,D0
;  MOVE.w visiblecolumns,D0
;  SUBQ.w #8,D0
;  LEA comStr_Modified,A0
  JSR update_statusline

  JL_0_78F6:
  MOVEM.l (A7)+,D0/A0-A1/A3
RTS

.update_horizscroller:
  JSR update_modifiermark
  JSR print_actualsourcecolumn
  !basic
  MOVE d1,d0
  xpot.l = PutD0

  MOVEQ #0,d0
  MOVE.w comWord_ColumnsOffset,D0
  ADD.w comWord_Column,D0
  ADDQ.w #1,D0
  xact.l = PutD0
  xmax_slider.l = #MAX_Columns
  MOVE.w visiblecolumns,d0
  xvis.w = PutD0 / xmax_slider
  SetGadgetAttrsA_ *horizprop,*sourcewin,0,Tags(#PGA_VertPot,-1,@@
                                            #PGA_VertBody,1,@@
                                            #PGA_HorizPot,xpot,@@
                                            #PGA_HorizBody,xvis,@@
                                            #PGA_Top,xact,@@
                                            #PGA_Total,xmax_slider,@@
                                            #TAG_END,0)

  !asm
RTS

JL_0_7962:                        ;horiz scroll
  JSR save_cursorposition
  CLR.w comWord_TextBufferOffset
  MOVEQ.l #$00,D7
  MOVE.l viewablelines,D7
  SUBQ.l #1,D7
  CLR.l comLong_DisplayLine
  CLR.w comWord_Column
  MOVEA.l textbufferaddr,A5
  ADDA.w comWord_TextBufferOffset,A5
  ADDA.w comWord_ColumnsOffset,A5
  MOVEQ.l #$00,D6
  CLR.w comWord__AL_0_869A

  JL_0_799A:
    MOVEA.l A5,A0
    MOVEQ.l #$00,D0
    MOVE.l D6,D1
    MOVEQ.l #$00,D3
    MOVE.w D7,-(A7)
    ST comWord__AL_0_8668
  ;  MOVE.l a0,-(a7)
  ;  SUBA.w comWord_TextBufferOffset,A0
  ;  SUBA.w comWord_ColumnsOffset,A0
  ;  ;MOVE.l a0,currdisplayaddr
  ;  MOVE.l (a7)+,a0
    MOVEM.l d0-d2/a0,-(a7)
    MOVE.l textbufferaddr,a0
    ADD.w comWord_TextBufferOffset,a0
    CLR.b instring2
    MOVE.w #0,d2
    CMP.l #0,a0
    BEQ 'l2b
    MOVE.w comWord_ColumnsOffset,d1
   'l1
    CMP.w d1,d2
    BGE 'l2b
    MOVE.b (a0)+,d0
    CMP.b #$22,d0
    BNE 'l2
    NOT.b instring2
   'l2
    ADDQ.w #1,d2
    BRA 'l1
   'l2b
    MOVEM.l (a7)+,d0-d2/a0
    MOVE.b #$1,keepstring
    JSR print_complete_line
    CLR.b keepstring
    MOVE.w (A7)+,D7
    SF comWord__AL_0_8668
    JSR process_highlightning
    ADDQ.l #1,comLong_DisplayLine
    ADD.w #MAX_Columns, comWord_TextBufferOffset
    MOVEQ.l #$00,D0
    ADD.l #MAX_Columns,A5
    ADD.w fontheight,D6
  DBF D7,JL_0_799A
  JSR restore_cursorposition
JMP JL_0_590C

JL_0_79CC:
  MOVE.l comLong_DisplayLineOffset,D2
  ADD.l comLong_DisplayLine,D2
  CMP.l comLong_BlockStartY,D2
  BNE.w JL_0_79EE
  MOVE.w comWord_Column,D2
  ADD.w comWord_ColumnsOffset,D2
  CMP.w comLong_BlockStartX,D2
  BHI.w JL_0_79EE
  MOVEQ.l #$00,D3

  JL_0_79EE:
RTS

JL_0_79F0:
  MOVE.l comLong_DisplayLineOffset,D2
  ADD.l comLong_DisplayLine,D2
  CMP.l comLong_BlockEndY,D2
  BNE.w JL_0_7A12
  MOVE.w comWord_Column,D2
  ADD.w comWord_ColumnsOffset,D2
  CMP.w comLong_BlockEndX,D2
  BHI.w JL_0_7A12
  MOVEQ.l #$00,D3

  JL_0_7A12:
RTS

JL_0_7A14:
  MOVE.w comLong_BlockStartX,D2
  CMP.w comWord_MaxColumns,D2
  BCS.w JL_0_7A3C
  CLR.w comLong_BlockStartX
  ADDQ.l #1,comLong_BlockStartY
  MOVE.l comLong_BlockStartY,D2
  CMP.l comLong_BlockEndY,D2
  BLS.w JL_0_7A3C
JMP JL_0_572C

JL_0_7A3C:
  MOVE.w comLong_BlockEndX,D2
  BPL.w JL_0_7A66
  MOVE.w comWord_MaxColumns,D2
  SUBQ.w #1,D2
  MOVE.w D2,comLong_BlockEndX
  SUBQ.l #1,comLong_BlockEndY
  MOVE.l comLong_BlockEndY,D2
  CMP.l comLong_BlockStartY,D2
  BCC.w JL_0_7A90
  JL_0_7A62:
JMP JL_0_572C

JL_0_7A66:
  MOVE.l comLong_BlockStartY,D2
  CMP.l comLong_BlockEndY,D2
  BNE.w JL_0_7A7C
  MOVE.w comLong_BlockEndX,D2
  CMP.w comLong_BlockStartX,D2
  BLT.b JL_0_7A62

  JL_0_7A7C:
  CMP.w comWord_MaxColumns,D2
  BCS.w JL_0_7A90
  MOVE.w comWord_MaxColumns,D2
  SUBQ.w #1,D2
  MOVE.w D2,comLong_BlockEndX

  JL_0_7A90:
RTS


.PED_events:
  CLR.w comWord_KeyBeforeReturn
  JSR cursor_on
;  BRA.w JL_0_7AA8

  JL_0_7AA0:
  JSR checkedit2

; 'l1
  JSR cursor_on
  CLR.b doedit2

  JSR update_horizscroller
  JSR print_actualsourceline

  ; -- update intellisense after DELETE_KEY
  !regs2stack
  !basic
  If Peek.b(?use_intellisense)<>0
    If WZ_CheckOpen{"WIN_POPUP"} AND last_key = $08
      Gosub intellisense
    EndIf
  EndIf
  !asm
  !stack2regs

;  JL_0_7AA8:
  JSR general_message_loop
  JSR cursor_off
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVE.w comWord_Column,D0

  ; -- update functioncompletion and close any subwindows on key-press
  !regs2stack
  !basic
  If Peek.b(?use_intellisense)<>0
    If WZ_CheckOpen{"WIn_PoPUP"} AND (last_key>$4B AND last_key<$50)
      Select last_key
      Case $4D : WZ_SetPopUpEntry{popupdata\selected_entry + 1}
      Case $4C : WZ_SetPopUpEntry{popupdata\selected_entry - 1}
      Case $4E : Gosub close_popupwindow
      Case $4F : Gosub close_popupwindow
      End Select
      Pop If :Pop If
      !asm
      !stack2regs
      BRA.w JL_0_7AA0
    EndIf
  EndIf
  Gosub close_bubblehelp
  !asm
  !stack2regs

  ; -- check for key-events
  TST.l D7
   BMI.w key_delete                      ; negative code
  BCLR #$1E,D7
   BNE.w JL_0_7ADA                       ; not equal
  CMP.w #$20,D7
   BCS.w key_cursorleft                  ; carry set, lower
  CMP.w #$7F,D7
   BLT JL_0_7ADA                         ; less than
  CMP.l #$8c,d7
   BLE key_delete                        ; less or equal
   ;BCC.w key_delete  ;morechar of

  JL_0_7ADA:
  JSR immediate_syntaxhelp
  JSR insertchar
BRA.w JL_0_7AA0




.insertchar:
  MOVE.b #2,doedit2                   ;change to 2 if char should cut block
  JSR checkedit2
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVE.w comWord_Column,D0
  MOVE.w D7,comWord_KeyBeforeReturn
  MOVE.w comWord_MaxColumns,D1
  ADD.w comWord_ColumnsOffset,D0

  JL_0_7AE8:
    SUBQ.w #1,D1
    CMP.w D1,D0
     BCC.w JL_0_7AF8
    MOVE.b -$1(A2,D1.W),$0(A2,D1.W)   ;insert char
  BRA.b JL_0_7AE8

  JL_0_7AF8:
  JSR source_scroll_line_to_left
  TST.l comLong_BlockEndY
   BMI.w JL_0_7BB0
  MOVE.w comWord_Column,D0
  ADD.w comWord_ColumnsOffset,D0
  MOVE.l comLong_DisplayLine,D1
  ADD.l comLong_DisplayLineOffset,D1
  JSR JL_0_3154
  CMP.l comLong_BlockStartY,D1
   BEQ.w JL_0_7B3A
  CMP.l comLong_BlockEndY,D1
   BEQ.w JL_0_7B6C
  BRA.w JL_0_7BB0

  JL_0_7B3A:
  CMP.w comLong_BlockStartX,D0
   BLE.w JL_0_7B94
  TST.b comByte_StateBlockMark
   BEQ.w JL_0_7BB0
  ADDQ.w #1,comLong_BlockEndX
  CMPI.w #MAX_Columns-1,comLong_BlockEndX
   BLE.w JL_0_7BB0
  MOVE.w #MAX_Columns-1,comLong_BlockEndX
  BRA.w JL_0_7BB0

  JL_0_7B6C:
  CMP.w comLong_BlockEndX,D0
   BGT.w JL_0_7BB0
  ADDQ.w #1,comLong_BlockEndX
  CMPI.w #MAX_Columns-1,comLong_BlockEndX
   BLE.w JL_0_7BB0
  MOVE.w #MAX_Columns-1,comLong_BlockEndX
  BRA.w JL_0_7BB0

  JL_0_7B94:
  ADDQ.w #1,comLong_BlockStartX
  ADDQ.w #1,comLong_BlockEndX
  ANDI.w #$7F,comLong_BlockStartX           ;????????
  ANDI.w #$7F,comLong_BlockEndX             ;????????

  JL_0_7BB0:
  MOVE.w D7,D0
  JSR JL_0_76EA
  MOVE.w comWord_Column,D0
  JSR JL_0_7F70
RTS


.key_cursorleft:
  CMP.w #$1F,D7
    BNE.w key_cursorright

  MOVE.w message_qualifier,d1
  AND.w #$8,d1
   BEQ 'noctrl
  MOVEM.l d0-d7/a0-a6,-(a7)
  JSR cursor_off
  JSR menu_blockuntab                   ;call untab
  MOVEM.l (a7)+,d0-d7/a0-a6
  RTS

 'noctrl
  MOVE.w comWord_QualifierStore,D1
  ANDI.w #$3,D1
   BEQ.w JL_0_7C1C

  MOVE.w D0,D1
  ADD.w comWord_ColumnsOffset,D1
   BEQ.w JL_0_7BE6

  MOVEQ.l #$00,D1
BRA.w JL_0_7C5C



.getactualword:
  nostring.l = 0
  lastcolumn.w = Peek.w(?comWord_Column)
  MOVE.l textbufferaddr,a0
  ADD.w comWord_TextBufferOffset,a0
  MOVE.l a0,d0:lineaddr = PutD0
  For i.l = lineaddr To lineaddr + #MAX_Columns    ;clear highlight info but dont trash strings
    If nostring.l = 0
      Poke.b i,Peek.b(i) AND $7f
       If Peek.b(i) = $22 Then nostring = 1
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
  Next
  MOVE.w comWord_Column,d1
  SUBQ.w #1,d1
  BGT 'w1
  MOVEQ #1,d1
 'w1
  MOVE.l textbufferaddr,a0
  ADD.w comWord_TextBufferOffset,a0
  ADD.w comWord_ColumnsOffset,d1
  ADD.w d1,a0
  JSR getwordnodetoke
  MOVE.l a0,d0 : i = PutD0
  actualword$ = Peek$(i)
  cursorposition.l = Peek.w(?comWord_Column)+1
  Poke.w ?comWord_Column,lastcolumn
RTS

.getactualword_new:
  nostring = 0 : already_displayed.b = False
;  lastcolumn.w = Peek.w(?comWord_Column)
  MOVE.l textbufferaddr,a0
  ADD.w comWord_TextBufferOffset,a0
  MOVE.l a0,d0 : lineaddr = PutD0
  For i.l = lineaddr To lineaddr + #MAX_Columns    ;clear highlight info but dont trash strings
    If nostring.l = 0
      Poke.b i,Peek.b(i) AND $7f
       If Peek.b(i) = $22 Then nostring = 1
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
  Next
  mytext$ = Peeks$(lineaddr,#MAX_Columns)

  cursorpos.l = Peek.w(?comWord_Column) + 1
  aword$ = "" : char$ =""
  tlen.l = FLen(mytext$)
  strhelp$ = ""
  If tlen
    token.l = False
    nextpos.l = cursorpos
    backpos.l = cursorpos - 1

    ; -- get everything right of cursor
    Repeat
      aword$ = aword$ + char$
      char$ = Mid$(mytext$,nextpos,1)
      nextpos + 1
    Until (Asc(char$)<48)  OR (char$="{") OR (char$="}") OR (nextpos>(tlen+1))

    ; -- get everything left of cursor
    char$ = ""
    Repeat
      aword$ = char$ + aword$
      char$ = Mid$(mytext$,backpos,1)
      backpos - 1
      ; Right$(Hex$(12345),2)
      If char$ = "(" OR char$ = "{"
        tokname$ = aword$
        Gosub syntax_help
        If strhelp$<>"" Then already_displayed.b = True
        aword$ = "" : char$="" : token = True
      EndIf
    Until (Asc(char$)>57 AND Asc(char$)<63) OR (Asc(char$)<48 AND char$<>"" AND char$<>"$") OR (char$="=") OR (backpos<0) OR already_displayed

    actualword$ = aword$
    mytext$ =""
;    cursorposition.l = Peek.w(?comWord_Column)+1
;    Poke.w ?comWord_Column,lastcolumn
  EndIf
RTS

.startguide:
  !basic
 ; Gosub getactualword
  Gosub getstring_new2
  ;error{"Found current token for guide: "+actualword$}
  If actualword$<>""
    Gosub instructionbrowser_startguide
  Else
    Gosub open_instructionbrowser
  EndIf
  strhelp$ = Peek$(?str_screentitle)
  PrintScreenTitle{strhelp$}
  !asm
RTS

.immediate_syntaxhelp:
  !basic
  ;MOVE.l D7,d0 : _key.l = PutD0       ; get actual key
  _key.l = last_key
  MOVE.l A2,d0 : lineaddr.l = PutD0   ; get pointer to current textline
  already_displayed.b = False
;!cout{Hex$(_key)}
  If (_key=@" ") OR (_key = @"(") OR (_key = @"{") ;OR (*PreProcessor\tokenFlags[_key&$FF]&#TOKENF_IS); " " "(" "{"

    If Peek.w(?comWord_Column) > 0

      If WZ_CheckOpen{"WIN_POPUP"} Then Gosub close_popupwindow
      strline$ = Peek.s(lineaddr) ;Peeks$(lineaddr,Peek.w(?comWord_Column))
      ;slen.w = FLen(strline$) : found.l = False
      ;Gosub getstring_new2
      ;tokname$ = actualword$
      ;error{"Line Pre:"+strline$}
      ;MaxLen linebuff$ = 256
      ;preproc_Detokenize{*PreProcessor,&strline$,&linebuff$,FLen(strline$)}
      ;strline$ = Peek.s(&linebuff$)
      ;error{"Line Post:"+strline$}

      bracketclose1.l = Instr(strline$,")")
      bracketclose2.l = Instr(strline$,"}")

      bracketopen1.l  = Instr(strline$,"(",bracketclose1)
      bracketopen2.l  = Instr(strline$,"{",bracketclose2)

      bracketopen.l   = 0

      If bracketopen1>bracketopen2 Then bracketopen=bracketopen1:Else bracketopen=bracketopen2

      searchpos.l = Peek.w(?comWord_Column)
      If bracketopen>0 AND bracketopen<searchpos Then searchpos=bracketopen

      tokname$ = preproc_CropToken{*PreProcessor,strline$,searchpos}
      If tokname$><""
        If *PreProcessor\tokenFlags[_key&$FF]&#TOKENF_IS
          tokname$+Chr$(_key)
        End If
      End If
;      tokname$ = "" : strhelp$ = ""
;      While (slen > 0) AND (found = False)
;        schar$ = Mid$(strline$,slen,1)
;        If (schar$ = " ") OR (schar$="=")
;          found = True
;        Else
;          tokname$ = schar$ + tokname$
;          slen - 1
;        EndIf
;      Wend

;      Gosub getstring_new2
      If tokname$
        Gosub syntax_help
        If strhelp$=""
          Gosub intellisense
        End If
      End If
    EndIf
  Else
    Select _key
    Case $8b ; "HELP"
      ;Gosub getactualword_new
      Gosub getstring_new2
      ;If NOT already_displayed
        tokname$ = actualword$
        If tokname$ <> ""
          If StrLower(tokname$) = "endif"
            Gosub help_checkforif
          Else
            !asm
            JSR help_checkfortype
            !basic
            type_found.b = PutD0
            If (type_found = False)
              Gosub syntax_help
            EndIf
          EndIf
;        Else
;          search_instruction$ = ""
;          ypos.l = Peek.l (?comLong_DisplayLine)*Peek.w (?fontheight)+(Peek.w (?fontheight)*3)
;          wtemp\ibrowser_x = Peek.w (?comWord_Column)*Peek.w (?fontwidth):wtemp\ibrowser_y = ypos
;          Gosub open_instructionbrowser
        EndIf
      ;EndIf

     Case $0D ; ENTER
       If Peek.b(?use_intellisense) = 1
         If WZ_CheckOpen{"WIN_POPUP"}
           a$ = WZ_GetPopUpEntry{WZ_GetPopUpMenu{}+1}
           a$ = dos_Trim{Left$(a$,Instr(a$,"{")-1)}
           PrintScreenTitle{a$ + " " + TED_GetIncludeHelp{a$}}
           a$ = UnRight$(a$,FLen(poptok$)) + "{"
           Gosub insertstring
           Gosub close_popupwindow
           Gosub activatesource
           Pop Select : Pop If :Pop If
           !asm
           MOVE.l #0,d7
           RTS
           ; replace text in textbuffer
;           MOVE.l textbufferaddr,d0
;           ADD.w comWord_TextBufferOffset,d0
;           ADD.w comWord_ColumnsOffset,d0
;           ADD.w comWord_Column,d0
;           faddr.l = PutD0 - 1
;           PokeS faddr-Len(poptok$), a$,FLen(a$)
;;           Poke.w ?comWord_ColumnsOffset,Peek.w(?comWord_Column)+FLen(a$)
;           Pop Select
;           !asm
;           MOVE.l #0,D7
;           RTS
         EndIf
       EndIf
    Default
      Gosub intellisense
    End Select
  EndIf
  !asm
RTS

Function.s FindTokenHelpStr{tokname$}

  If Left$(tokname$,1) = "!"
    MOVE.l comPtr_MacroBase,d0 : *macrobase.l = PutD0
    tokname$ = TED_GetMacroName{*macrobase,tokname$}
    strhelp$ = tokname$ + " "  + TED_GetMacroHelp{*macrobase,tokname$} + " // Macro"
  Else
    MOVE.l comPtr_TokenBase,D0  : *tokenbase.l = PutD0
    tokid.l = TED_GetTokenID{*tokenbase,tokname$}
    If tokid>=0
      tokname$ = TED_GetTokenName{*tokenbase,tokid}
      libnum.l = TED_GetTokenLibnum{*tokenbase,tokname$}
      If libnum>=0
        strhelp$ = tokname$ + " " + TED_GetTokenHelp{*tokenbase,tokname$} + " // BlitzLib: "+TED_GetLibname{libnum}
      End If
    Else
      tokname$ = TED_GetIncludeFunction{tokname$}
      If tokname$<>""
        strhelp$ = tokname$ + " " + TED_GetIncludeHelp{tokname$} + " // File: "+TED_GetIncludeName{tokname$}
      End If
    End If
  End If
  strhelp$ = Replace$(strhelp$,"  "," ")
  Function Return strhelp$
End Function

.syntax_help:
    strhelp$ = ""
    If tokname$ <> ""
      strhelp$ =  FindTokenHelpStr{tokname$}
;      If StrLeft(tokname$,1) = "!"
;        MOVE.l comPtr_MacroBase,d0 : *macrobase.l = PutD0
;        strhelp$= TED_GetMacroHelp{*macrobase,tokname$}
;      Else
;        Select _key
;         Case $20 ; Space pressed, search for tokenhelp
;           strhelp$ = FindTokenHelpStr{tokname$}
;
;        Case $28 ; "("
;          strhelp$ = FindTokenHelpStr{tokname$}
;
;        Case $7B ; "{"  -> search for includes
;          strhelp$ = FindTokenHelpStr{tokname$}
;          ;strhelp$ = FindTokenHelpStr{tokname$}
;          ;tokname$ = TED_GetIncludeFunction{tokname$}
;          ;If tokname$<>""
;          ;  strhelp$ = tokname$ + TED_GetIncludeHelp{tokname$}
;          ;  strhelp$ = StrChg(strhelp$,";","")
;
;            ; replace text in textbuffer
;            ; MOVE.l textbufferaddr,d0
;            ; ADD.w comWord_TextBufferOffset,d0
;            ; ADD.w comWord_ColumnsOffset,d0
;            ; ADD.w comWord_Column,d0
;            ; faddr.l = PutD0
;            ; poke.s faddr-Len(tokname$), tokname$,Len(tokname$)
;          ;EndIf
;
;        Case $8b ; just Help
;          strhelp$ = FindTokenHelpStr{tokname$}
;          ;MOVE.l comPtr_TokenBase,D0  : *tokenbase.l = PutD0
;          ;strhelp$ = TED_GetTokenHelp{*tokenbase,tokname$}
;          ;If strhelp$ = "" Then strhelp$ = TED_GetTokenHelp{*tokenbase,tokname$+"$"}
;
;          ;If strhelp$ <> ""
;          ;  commata.l = Instr(strhelp$,";")
;          ;  strhelp$ = StrLeft(strhelp$,commata-1)+"  " + Mid$(strhelp$,commata+1,Len(strhelp$)-commata+1)
;          ;Else
;          ;  strhelp$ = TED_GetIncludeFunction{tokname$}
;          ;  strhelp$ + TED_GetIncludeHelp{tokname$}
;          ;  strhelp$ = StrChg(strhelp$,";","")
;          ;EndIf
;          ; kein bekanntes token, Instruction Browser aufmachen
;          ;If (Len(strhelp$) = Len(tokname$)) OR
;          If (strhelp$="")
;            search_instruction$ = tokname$
;            ypos.l = Peek.l (?comLong_DisplayLine)*Peek.w (?fontheight)+(Peek.w (?fontheight)*3)
;            wtemp\ibrowser_x = Peek.w (?comWord_Column)*Peek.w (?fontwidth):wtemp\ibrowser_y = ypos
;            Gosub open_instructionbrowser
;            strhelp$ = Peek$(?str_screentitle)
;          EndIf
;
;        Default
;          strhelp$ = ""
;          strhelp$ = FindTokenHelpStr{tokname$}
;        End Select
;      EndIf
    EndIf

    If strhelp$=""
      ; keine Hilfe und kein Word unter Cursor
     ; PrintScreenTitle{Peek$(?str_screentitle)}
    Else
      PrintScreenTitle{strhelp$}
    EndIf
RTS

.intellisense:
  ; -- bei delete-key wird ?comWord_Column nicht aktualisiert
  If Peek.b(?use_intellisense) = 1
    If Peek.w(?comWord_Column) > 1
      ; -- get everything left of cursor until " " or "="
      If lineaddr.l

      strline$ = Peeks$(lineaddr,Peek.w(?comWord_Column))
      slen.w = Len(strline$) : found.l = False
      tokname$ = "" : strhelp$ = ""
      While (slen > 0) AND (found = False)
        schar$ = Mid$(strline$,slen,1)
        If (schar$ = " ") OR (schar$="=")
          found = True
        Else
          tokname$ = schar$ + tokname$
          slen - 1
        EndIf
      Wend
      End If

      tokname$ + Chr$(_key)
      ; -- search for any text that equals entered text
      If FLen(tokname$) > 2 AND Instr(tokname$,"_")
        poptok$ = LCase$(tokname$): tokenliste$ = ""
        ResetList HelpIndexCache() : popfound.w = 0
        While NextItemFast(HelpIndexCache())
          If Instr(HelpIndexCache()\lname,poptok$) = 1
            ; %%1, %%2 fuer farben
            pophelp$ = HelpIndexCache()\name + HelpIndexCache()\help
            If FLen(pophelp$) > 32
              pophelp$ = Left$(pophelp$,32) + " ... "
            EndIf
            tokenliste$ + "%%4" + pophelp$ + Chr$(10)
            popfound + 1
          End If
        Wend
        ; -- open list if something found
        If popfound > 0
          WZ_SetPopUpMenu{tokenliste$,1}
          xpos.l = Peek.w(?win_TopLeft)+ Peek.w(?win_BorLef) + (Peek.w (?comWord_Column)-2) * Peek.w (?fontwidth)
          ypos.l = Peek.w(?win_TopEdge) + Peek.w(?win_BorTop) + Peek.l (?comLong_DisplayLine) * Peek.w(?fontheight) + Peek.w(?fontheight) + 2
          WZ_PopUp_Nonmodal{xpos,ypos}
          Gosub activatesource
        Else
          Gosub close_popupwindow
        EndIf
      EndIf
    Else
      Gosub close_popupwindow
    EndIf
  End If
RTS

.scan_source_for_used_libs:
  ; --
  ; -- scan for number of lines
  ;*textline.l = TEDGetFirstLine_
  number_of_lines.l = 0
  *textline.l = Peek.l(?comPtr_FirstSourceLine)
;  !cout{Hex$(*textline)}
  While *textline<>0
    number_of_lines + 1
    *textline.l = Peek.l(*textline)
  Wend
  If number_of_lines = 0 Then Return

  ; --
  ; -- reset tables and arrays
  For i.l = 0 To 65535
    tokentable(i) = 0
  Next i
  HIERARCHY_Clear{&lib_list}

  Use Window WZID("WIN_LABELS")
  WZPrint "LIBRARY_LIST",0,lib_list

  DEFTYPE.tokendata tokeninfo
  MOVE.l comPtr_TokenBase,D0    : *tokenbase.l = PutD0
  ; Zeilenstruktur:
  ; 0 - 3 bytes : Adresse naechste Zeile
  ; 4 - 7 bytes : Adresse prev Zeile
  ; 8 byte      : Laenge der Zeile
  ; 9.. bytes   : tokenized Text
  ; kill any spaces before Token

  ; --
  ; -- scanning each line for tokens
  WZ_ShowMessage{!TRANS{"Analyzing source..."},0}

  *textline.l = Peek.l(?comPtr_FirstSourceLine) : zeile.l = 0
  While *textline<>0
    bytecount.w = 0
    anzbytes.w = Peek.b(*textline + 8)
    testaddr.l = *textline + 9
    acttoken.w = Peek.w(testaddr) AND $FFFF
    acttoke2.l = Peek.w(testaddr) AND $FFFF
    skip_string.b = False

    While (bytecount<=anzbytes)
      If (acttoken<0) AND (NOT skip_string)
        If (acttoke2 AND $FF) > 0
          If (zeile MOD 10)=0 Then !WZ_Update_Gauge{zeile,number_of_lines}

          If acttoke2 > $8000 Then acttoke2 = acttoke2 - $8000
          tokentable(acttoke2) = tokentable(acttoke2) + 1
          bytecount + 1 : testaddr + 1

;          If tokentable(acttoke2) = 1
;            tokname$ = TED_GetTokenName{*tokenbase,acttoke2}
;            If tokname$=""
;              !cout{zeile,Peek$(TEDDetoke_(testaddr))}
;              !cout{"found token ("+Hex$(acttoke2)+"): "+tokname$} ;,libname$,libnum}
;            EndIf
;          EndIf
        EndIf
      EndIf
      testaddr + 1 : bytecount + 1
      acttoken = Peek.w(testaddr) AND $FFFF
      acttoke2.l = Peek.w(testaddr) AND $FFFF
      actbyte.w = acttoke2 LSR 8
      ; skip comments ...
      If actbyte = Asc(";")
;        !cout{zeile,Peek$(TEDDetoke_(testaddr))}
        anzbytes = bytecount + 1
      Else
      ; skip strings ...
        If actbyte = 34
          If skip_string = False Then skip_string = True Else skip_string = False
        EndIf
      EndIf
    Wend
    *textline.l = Peek.l(*textline) : zeile = zeile + 1
  Wend

  ;
  ; build hierarchy table
  ;
  WZ_ShowMessage{!TRANS{"Building result tree..."},0}
  For i = 0 To 65535
    If tokentable(i) > 0
      acttoke2 = i
      tokname$ = TED_GetTokenName{*tokenbase,acttoke2}
      libnum.l = acttoke2 LSR 7 ;TED_GetTokenLibnumID{*tokenbase,tokname$})
      libname$ = lib_mapping$(libnum,0)

      If tokname$<>""
        entry$ = libname$ + ": " + tokname$ + " ("+Str$(tokentable(i))+")"
        hpos.w = Instr(entry$,":")
        If (hpos > 1)
          main$ = Left$(entry$,hpos - 1)
          child$= Right$(entry$,FLen(entry$) - hpos - 1)
          pid.l = HIERARCHY_GetParentID{main$}
          If pid > 0
            HIERARCHY_AddChild{pid,child$}
          Else
            dummy = HIERARCHY_AddParent{&lib_list,main$}
            If child$<>""
              pid.l = HIERARCHY_GetParentID{main$}
              If pid<>0 Then HIERARCHY_AddChild{pid,child$}
            EndIf
          EndIf
        Else
          dummy = HIERARCHY_AddParent{&lib_list,entry$}
        EndIf
      EndIf
    EndIf
    If (i MOD 1024) = 0 Then !WZ_Update_Gauge{i,65535}
  Next i
  ;
  WZ_HideMessage{}

  Use Window WZID("WIN_LABELS")
  WZPrint "LIBRARY_LIST",0,lib_list
RTS


JL_0_7BE6:
  MOVE.l comLong_DisplayLineOffset,D1
  ADD.l comLong_DisplayLine,D1
  BEQ.w JL_0_7AA0

  MOVE.l A0,-(A7)
  MOVEA.l comPtr_CurrentSourceLine,A0
  MOVEA.l $4(A0),A0
  LEA $9(A0),A0
  MOVEQ.l #-$01,D1

  JL_0_7C02:
    TST.b (A0)
    BEQ.w JL_0_7C16
    ADDQ.w #1,D1
    CMPI.b #$20,(A0)+
  BEQ.b JL_0_7C02

  MOVEA.l (A7)+,A0
  BRA.w JL_0_7C5C

  JL_0_7C16:
  MOVEA.l (A7)+,A0
BRA.w JL_0_7AA0

JL_0_7C1C:
  MOVE.b #1,doedit2
  JL_0_7C1Cb:
  JSR JL_0_7F40
BRA.w JL_0_7AA0



.deletechar:
  MOVEM.l d0-d1/a0-a2,-(a7)
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVE.b #1,doedit2
  ;MOVE.w D7,comWord_KeyBeforeReturn                ;delete char
  MOVEM.l D1/A0-A2,-(A7)
  JSR JL_0_6448
  MOVEM.l (A7)+,D1/A0-A2
  MOVE.w comWord_Column,D0
  ADD.w comWord_ColumnsOffset,D0

  JL_0_7E3Ab:
    ADDQ.w #1,D0
    CMP.w comWord_MaxColumns,D0
     BCC.w JL_0_7E4Cb
    MOVE.b $0(A2,D0.W),-$1(A2,D0.W)
  BRA.b JL_0_7E3Ab
  JL_0_7E4Cb:

  MOVE.b #$20,-$1(A2,D0.W)
  MOVE.w comWord_Column,-(A7)
  MOVE.w visiblecolumns,D0
  SUBQ.w #1,D0
  MOVE.w D0,comWord_Column
  MOVE.w visiblecolumns,D0
  ADD.w comWord_ColumnsOffset,D0
  SUBQ.w #1,D0
  MOVE.l d0,d1
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
 'l2
    CMP.b #$22,0(a2,d1.w)      ;hack
    BNE 'l1
    ADDQ.b #1,d0
   'l1
  DBF d1,'l2

  MOVE.l d0,d1
  MOVE.l (a7)+,d0
  MOVE.b $0(A2,D0.W),D0
  CLR.w instru
  BTST #0,d1
  BNE 'l3
  MOVE.w #1,instru
 'l3
  JSR JL_0_76EA
  CLR.w instru
  MOVE.w (A7)+,comWord_Column
  MOVEM.l (a7)+,d0-d1/a0-a2
BRA deletekey



.key_cursorright:
  CMP.w #$1E,D7
   BNE.w key_backspace

  MOVE.w message_qualifier,d1
  AND.w #$30,d1
  BEQ 'noalt
  ; -- alt-key pressed aswell
  JSR storeline
  JSR jump_onclick
  RTS

 'noalt:
  MOVE.w message_qualifier,d1
  AND.w #$8,d1
  BEQ 'noctrl
  ; -- ctrl-key pressed aswell
  MOVEM.l d0-d7/a0-a6,-(a7)
  JSR cursor_off
  JSR menu_blocktab
  MOVEM.l (a7)+,d0-d7/a0-a6
  RTS

 'noctrl:
  MOVE.w comWord_QualifierStore,D1
  ANDI.w #$3,D1
   BEQ.w noshift
  ; -- shift-key pressed aswell
  MOVE.w comWord_MaxColumns,D1

  ; -- search for rightmost character in actual line
  JL_0_7C3C:
    SUBQ.w #1,D1
    BPL.w JL_0_7C48
    MOVEQ.l #$00,D1
    BRA.w JL_0_7C5C
    JL_0_7C48:
  CMPI.b #$20,$0(A2,D1.W)
  BEQ.b JL_0_7C3C

  ADDQ.w #1,D1
  CMP.w comWord_MaxColumns,D1
  BCS.w JL_0_7C5C
  SUBQ.w #1,D1
  JL_0_7C5C:

  JSR JL_0_7ED2
  BRA.w JL_0_7AA0

  noshift:
  ; -- normal cursor_right function
  MOVE.b #1,doedit2
  JL_0_7C64b:
  JSR JL_0_7F70
BRA.w JL_0_7AA0


.key_backspace:
  CMP.w #$8,D7                  ; BACKSPACE-Key
   BNE.w key_tab

  MOVE.w D0,D1
  OR.w comWord_ColumnsOffset,D1
  BNE.w 'l1

  TST.b new_editmode
   BEQ JL_0_7AA0

  MOVEM.l a0-a3/a5/d0-d6,-(a7)
  MOVE.l comLong_DisplayLineOffset,d0
  ADD.l comLong_DisplayLine,d0
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w 'weit
  MOVEM.l (a7)+,a0-a3/a5/d0-d6
  BRA deletekey
 'weit
  CMP.l #0,d0
   BEQ 'l2
  MOVE.l comPtr_CurrentSourceLine,a4
  JSR storeline
  JSR movelineup
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVE.l #MAX_Columns,d0
  SUBQ .l #1,d0
 'loop
    CMP.b #$20,0(a2,d0.l)
    BNE 'f
    SUBQ.l #1,d0
  BPL 'loop
 'f
  ADDQ.l #1,d0
  MOVE.w d0,comWord_Column
  MOVE.l comPtr_CurrentSourceLine,a4
  JSR menu_joinline
 'l2
  MOVEM.l (a7)+,a0-a3/a5/d0-d6
  JMP JL_0_7AA0

 'l1
  MOVEM.l A0-A2,-(A7)
  JSR JL_0_7F40
  MOVEM.l (A7)+,A0-A2
  MOVE.w comWord_Column,D0
  MOVEQ.l #$08,D7
BRA.w deletekey


.key_tab:
  CMP.w #$9,D7
   BNE.w exit_key_tab

  TST.w tab_size
  BNE 'l1
  MOVE.w #1,tab_size
 'l1
  ADD.w comWord_ColumnsOffset,D0
  MOVE.w D0,D2
  MOVE.w comWord_QualifierStore,D1
  ANDI.w #$3,D1
  BEQ.w JL_0_7D1C
  MOVE.w D7,comWord_KeyBeforeReturn

  JL_0_7CB4:
  SUBQ.w #1,D0
  BMI.w JL_0_7AA0
  MOVEQ.l #$00,D1
  MOVE.w D0,D1
  DIVU tab_size,D1
  SWAP D1
 'l1
  TST.w D1
  BNE.b JL_0_7CB4
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w JL_0_7CF8
  MOVE.w D2,-(A7)
  MOVE.w D2,D4
  SUB.w D0,D4
  JSR JL_0_79CC
  BNE.w JL_0_7CE8
  SUB.w D4,comLong_BlockStartX

  JL_0_7CE8:
  JSR JL_0_79F0
  BNE.w JL_0_7CF6
  SUB.w D4,comLong_BlockEndX

  JL_0_7CF6:
  MOVE.w (A7)+,D2

  JL_0_7CF8:
  MOVE.w D0,-(A7)

  JL_0_7CFA:
  MOVE.b $0(A2,D2.W),$0(A2,D0.W)
  ADDQ.w #1,D2
  ADDQ.w #1,D0
  CMP.w comWord_MaxColumns,D2
  BCS.b JL_0_7CFA

  JL_0_7D0A:
  MOVE.b #$20,$0(A2,D0.W)
  ADDQ.w #1,D0
  CMP.w comWord_MaxColumns,D0
  BCS.b JL_0_7D0A
  BRA.w JL_0_7DDC

  JL_0_7D1C:
  ADDQ.w #1,D0
  CMP.w comWord_MaxColumns,D0
  BCC.w JL_0_7AA0
  MOVEQ.l #$00,D1
  MOVE.w D0,D1
  DIVU tab_size,D1
  SWAP D1
  TST.w D1
  BNE.b JL_0_7D1C
  MOVE.w D7,comWord_KeyBeforeReturn
  MOVE.w D0,-(A7)
  SUB.w D2,D0
  CMPI.w #$ffffFFFF,comLong_BlockEndY
   BEQ.w JL_0_7D6E
  MOVE.w D2,-(A7)
  JSR JL_0_79CC
  BNE.w JL_0_7D5A
  ADD.w D0,comLong_BlockStartX

  JL_0_7D5A:
   JSR JL_0_79F0
   BNE.w JL_0_7D68
  ADD.w D0,comLong_BlockEndX

  JL_0_7D68:
   JSR JL_0_7A14
  MOVE.w (A7)+,D2

  JL_0_7D6E:
  MOVE.w comWord_MaxColumns,D1

  JL_0_7D72:
    SUBQ.w #1,D1
    MOVE.w D1,D3
    SUB.w D0,D3
     BMI.w JL_0_7D8A
    CMP.w D2,D3
     BCS.w JL_0_7D8A
    MOVE.b $0(A2,D3.W),$0(A2,D1.W)
  BRA.b JL_0_7D72

  JL_0_7D8A:
  MOVE.w D1,-(A7)
  MOVE.w comWord_Column,D7
  ADD.w comWord_ColumnsOffset,D7
  MOVE.w D7,comWord_Column

  JL_0_7D9E:
  MOVE.b #$20,$0(A2,D1.W)
  MOVE.b $0(A2,D1.W),D0
  MOVEM.l D0-D2/A0-A2,-(A7)
   JSR source_scroll_line_to_left
  MOVEM.l (A7)+,D0-D2/A0-A2
  MOVEM.l D0-D2/A0-A2,-(A7)
   JSR JL_0_76EA
  MOVEM.l (A7)+,D0-D2/A0-A2
  SUBQ.w #1,D1
   BMI.w JL_0_7DCA
  CMP.w D2,D1
   BCC.b JL_0_7D9E

  JL_0_7DCA:
  MOVE.w (A7)+,D0
  ADDQ.w #1,D0
  ADD.w D0,comWord_Column
  MOVE.w D0,D1
  MOVE.w (A7)+,D7
  BRA.w JL_0_7C5C

  JL_0_7DDC:
  MOVE.w comWord_Column,-(A7)
  CLR.w comWord_Column
  ADDA.w comWord_ColumnsOffset,A2
  MOVE.w visiblecolumns,D7
  SUBQ.w #1,D7

  JL_0_7DF0:
  MOVE.b (A2)+,D0
  MOVEM.l D7/A2,-(A7)
   JSR JL_0_76EA
  MOVEM.l (A7)+,D7/A2
  ADDQ.w #1,comWord_Column
   DBF D7,JL_0_7DF0
  MOVE.w (A7)+,comWord_Column
  MOVE.w (A7)+,D1
  BRA.w JL_0_7C5C

  exit_key_tab:
BRA.w JL_0_7ED0



.key_delete:
  CMP.w #$7F,D7                            ; DEL-Key
   BNE.w event_horizslider

  deletekey:
  MOVE.b #2,doedit2
  MOVE.w D7,comWord_KeyBeforeReturn
  JSR checkedit2
  TST.b nodelete
   BNE JL_0_7AA0

  MOVEM.l D1/A0-A2,-(A7)
  JSR JL_0_6448
  MOVEM.l (A7)+,D1/A0-A2

  MOVE.w comWord_Column,D0
  ADD.w comWord_ColumnsOffset,D0
  JL_0_7E3A:
    ADDQ.w #1,D0
    CMP.w comWord_MaxColumns,D0
     BCC.w JL_0_7E4C
    MOVE.b $0(A2,D0.W),-$1(A2,D0.W)
  BRA.b JL_0_7E3A
  JL_0_7E4C:

  MOVE.b #$20,-$1(A2,D0.W)
  MOVE.w comWord_Column,-(A7)
  MOVE.w visiblecolumns,D0
  SUBQ.w #1,D0
  MOVE.w D0,comWord_Column
  MOVE.w visiblecolumns,D0
  ADD.w comWord_ColumnsOffset,D0
  SUBQ.w #1,D0
  MOVE.l d0,d1
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
 'l2
    CMP.b #$22,0(a2,d1.w)      ;hack
    BNE 'l1
    ADDQ.b #1,d0
   'l1
  DBF d1,'l2
  MOVE.l d0,d1
  MOVE.l (a7)+,d0
  MOVE.b $0(A2,D0.W),D0
  CLR.w instru
  BTST #0,d1
   BNE 'l3
  MOVE.w #1,instru
 'l3
  JSR JL_0_76EA
  CLR.w instru
  MOVE.w (A7)+,comWord_Column

  TST.w comWord_Column
   BNE 'x1
  TST.w comWord_ColumnsOffset
   BEQ 'x5
 'x1
  ; -- check if shift-backspace is pressed
  MOVE.w message_qualifier,d1
  AND.w #$3,d1
   BEQ JL_0_7AA0
  ; -- ok, delete all left of cursor ...
  TST.w comWord_Column
   BEQ 'x4
  SUBQ.w #1,comWord_Column
  BRA deletekey
 'x4
  TST.w comWord_ColumnsOffset
   BEQ 'x5
  SUBQ.w #1,comWord_ColumnsOffset
  BRA.w deletekey
 'x5
  JSR JL_0_7962
  JSR cursor_on
;BRA JL_0_7AA8
BRA JL_0_7AA0


.event_horizslider:
  CMP.w #-$1,D7
   BNE.w menu_addfilename
  CMP.w #GID_XPROP,D6
   BNE.w menu_addfilename

  horiz_loop:
    !basic
    DEFTYPE.l pos_hprop : GetAttr_ #PGA_Top,*horizprop,&pos_hprop
    Poke.l ?pos_horizprop,pos_hprop
    !asm
    MOVE.l pos_horizprop,D1
    JSR JL_0_7ED2                                  ; calculate new column ?

    MOVE.l a2,-(a7)
    MOVE.l ptr_sourcewindow,a2
    MOVEA.l $56(A2),A2                            ;Window\UserPort
    MOVEA.l A2,A0
    MOVE.l _execbase,A6
    JSR _GetMsg(A6)
    TST.l D0
    BEQ.w 'norep
    MOVE.l d0,a1                                  ;IntuiMessage > A1
    MOVE.l $14(a1),a2                             ;Class
    JSR _ReplyMsg(A6)
    CMP.l #IDCMP_GADGETUP,a2
     BNE 'norep
    MOVE.l (a7)+,a2
    BRA JL_0_7AA0                                 ; exit loop to JL_0_7AA0
   'norep
    MOVE.l (a7)+,a2
BRA.w horiz_loop


.menu_addfilename:
  MOVE.w D6,-(A7)

  CMP.w #-$2,D7
   BNE.w exit_addfilename
  !basic
;  CMP.l #$53,d6
;  BNE nocompileopt
;  nocompileopt
  CMP.l #$1000,d6           ; insert filename
  BNE 'nofileadd
  aslfr_SetRequesterTitle{0,!TRANS{"Select a filename to insert in source"},"",""}
  aslfr_SetPath{0,aslpath$,aslfile$,ptn$}
  If aslfr_Request{0,False,False,False}
    a$ = aslfr_GetNextFile{}
  EndIf
  Gosub insertstring
 'nofileadd

  CMP.l #$1001,d6           ; load file under cursor
   BNE 'noload
  JSR getstring
  MOVE.l a0,d0
  i = PutD0
  If i
  a$ = Peek$(i)
  If Exists (a$)
    GetD0 &a$
    !asm
    JSR loadfile
    JSR StoreXtraData
    !basic
  End If
  a$ = dos_AddPart{includedir$,Peek$(i)}
  If Exists (a$)
    GetD0 &a$
    !asm
    JSR loadfile
    JSR StoreXtraData
    !basic
  End If
  End If
 'noload

;  CMP.l #$1002,d6          ; build helpindexfile
;   BNE 'noHelpIndexFile
;  JSR build_HelpIndexFile
; 'noHelpIndexFile

  !asm
  CMP.l #$D9,D6
   BNE.w exit_addfilename
  MOVE.w (A7)+,comWord_KeyBeforeReturn
  ADD.w comWord_ColumnsOffset,D0
  MOVE.w D0,-(A7)

  JL_0_7EBC:
  MOVE.b #$20,$0(A2,D0.W)
  ADDQ.w #1,D0
  CMP.w comWord_MaxColumns,D0
   BCS.b JL_0_7EBC
  BRA.w JL_0_7DDC

  exit_addfilename:
  MOVE.w (A7)+,D6

  JL_0_7ED0:
RTS

JL_0_7ED2:
  MOVE.w comWord_ColumnsOffset,D4
  MOVE.w visiblecolumns,D2
  SUB.w AL_0_B7F4,D2
  CMP.w D2,D1
  BCC.w JL_0_7EFC
  CLR.w comWord_ColumnsOffset
  MOVE.w D1,comWord_Column

  JL_0_7EF0:
  CMP.w comWord_ColumnsOffset,D4
  BEQ.w JL_0_7F3E
  BRA.w JL_0_7962

  JL_0_7EFC:
  MOVE.w visiblecolumns,D2
  LSR.w #1,D2
  MOVE.w D1,D0
  SUB.w D2,D0
  MOVE.w comWord_MaxColumns,D3
  SUB.w visiblecolumns,D3
  CMP.w D3,D0
  BGT.w JL_0_7F2E
  BTST #$0,D0
  BEQ.w JL_0_7F20
  ADDQ.w #1,D0
  SUBQ.w #1,D2

  JL_0_7F20:
  MOVE.w D0,comWord_ColumnsOffset
  MOVE.w D2,comWord_Column
  BRA.b JL_0_7EF0

  JL_0_7F2E:
  MOVE.w D3,comWord_ColumnsOffset
  SUB.w D3,D1
  MOVE.w D1,comWord_Column
  BRA.b JL_0_7EF0
  JL_0_7F3E:
RTS

JL_0_7F40:
  CMP.w AL_0_B7F4,D0
  BCS.w JL_0_7F50
  JL_0_7F48:
  SUBQ.w #1,comWord_Column
RTS

JL_0_7F50:
  MOVE.w comWord_ColumnsOffset,D1
  CMP.w #1,d1
  ;BNE.w JL_0_7F5E
  BGT.w JL_0_7F5E
  TST.w d1
  BEQ 'l10
  MOVE.w #0,comWord_ColumnsOffset
  JSR scroll_right
  JSR _redraw
 'l10
  TST.w D0
  BNE.b JL_0_7F48
RTS

JL_0_7F5E:
  SUBQ.w #2,comWord_ColumnsOffset
  JSR scroll_right
  ADDQ.w #1,comWord_Column
RTS

JL_0_7F70:
  MOVE.w comWord_ColumnsOffset,D1
  MOVE.w visiblecolumns,D2
  ADD.w D2,D1
  CMP.w comWord_MaxColumns,D1
  BCS.w JL_0_7F8C
  SUBQ.w #1,D2
  CMP.w D2,D0
  BCS.w JL_0_7F9E
RTS

JL_0_7F8C:
  CMP.w AL_0_B7F4,D0
  BCS.w JL_0_7F9E
  SUB.w AL_0_B7F4,D2
  CMP.w D2,D0
  BCC.w JL_0_7FA6
  JL_0_7F9E:
  ADDQ.w #1,comWord_Column
RTS

JL_0_7FA6:
  ADDQ.w #2,comWord_ColumnsOffset
  JSR scroll_left
  SUBQ.w #1,comWord_Column
RTS

;JL_0_7FB8:
;  MOVE.w D0,-(A7)
;  MOVE.w #$FFFF,D0
;JL_0_7FBE:
;  MOVE.w D0,_custom+COLOR00
;   DBF D0,JL_0_7FBE
;  MOVE.w (A7)+,D0
; RTS

AJL_0_7FCC:
  !basic
  dummy = RTEZRequest("","AJL_07FCC called","Ok")
  !asm
  TST.w comWord_LabelCounter
   ;BEQ.w setpointer_to_normal
  LEA L_0_808E,A3
  CLR.l (A3)+
  CLR.l (A3)+
  CLR.l (A3)+
  CLR.l (A3)+
  CLR.l (A3)+
  CLR.l (A3)+
  CLR.l (A3)+
  CLR.l (A3)+
  LEA L_0_808E,A3
  MOVEQ.l #$00,D6
  MOVEA.l ptr_sourcewindow,A0
  MOVEA.l $56(A0),A2                                 ; Window\UserPort

  JL_0_7FF8:
    MOVEA.l A2,A0
    JSR _WaitPort(A6)
    MOVEA.l A2,A0
    JSR _ReplyMsg(A6)
    MOVEA.l D0,A1
    MOVE.l d0,messagestore
    MOVE.l $14(A1),D1
    CMP.l #IDCMP_VANILLAKEY,D1
    BNE.w JL_0_8030

    MOVE.w $18(A1),D2           ; keycode
    CMP.w #$D,D2
    BEQ.w JL_0_8036
    CMP.w #$10,D6
    BEQ.w JL_0_8036
    MOVE.b D2,(A3)+
    ;JSR JL_0_739E
    ADDQ.w #1,D6

    JL_0_8030:
    MOVE.l messagestore,d0
    BEQ 'l1
    MOVE.l d0,a1
    JSR _ReplyMsg(A6)
   'l1
    CLR.l messagestore
  BRA.b JL_0_7FF8

  JL_0_8036:
  MOVE.l messagestore,d0
  BEQ 'l1
  MOVE.l d0,a1
  JSR _ReplyMsg(A6)
 'l1
  CLR.l messagestore
  MOVEQ.l #$00,D0
  MOVEQ.l #$00,D7
  LEA L_0_808E,A1
  MOVEA.l comPtr_LabelList,A0
  MOVEQ.l #$00,D4

  JL_0_8048:
  MOVEA.l $4(A0),A2
  LEA $9(A2),A2
  ADDQ.l #1,A2
  LEA L_0_80B0,A3

  JL_0_8056:
  MOVE.b (A2)+,(A3)+
  BNE.b JL_0_8056
  LEA L_0_80B0,A3
  JSR compare_strings
  BNE.w JL_0_8076
  ADDQ.l #1,D4
  MOVEA.l (A0),A0
  CMPA.l #$0,A0
  BNE.b JL_0_8048
  BRA.w JL_0_808C

  JL_0_8076:
  MOVEQ.l #$00,D2
  MOVE.w visiblecolumns,D2
  ADDQ.w #4,D2
  MOVE.l D4,D3
  ;JSR AJL_0_3A5E
  ;JSR JL_0_73FA
  JL_0_808C:
RTS

L_0_808E: Ds.w 17
L_0_80B0: Ds.w 17

.checkfor_compilerwin:
  !basic
;  If Peek.l(Peek.l(?comPtr_CompilerWindow))<>0
    error{"checkfor_compilerwindow"}
;  EndIf
  !asm
;  MOVEA.l ptr_sourcewindow,A2
;  MOVE.l comPtr_CompilerWindow,D0
;  BEQ.b JL_0_80DE
;  MOVEA.l D0,A2
;  JL_0_80DE:
RTS

.check_events:
  MOVEA.l _execbase,A6
;  BSR.b checkfor_compilerwin
  TST.l ptr_sourcewindow
   BEQ.w JL_0_8104
  MOVEA.l ptr_sourcewindow,A2
  MOVEA.l $56(A2),A2             ; Window->UserPort
  MOVEA.l A2,A0
  JSR _GetMsg(A6)
  TST.l D0
  BNE.w event_sourcewindow  ;JL_0_81CA
  MOVEQ.l #$00,D7
RTS


.sub_mouseclicked
RTS
  !basic
  Request "","sub_mouseblicked","Ok"
  ; get the last entered word
  If Peek.w(?comWord_Column) > 0
    MOVE.l a2,d0 : lineaddr.l = PutD0
    strline$ = Peeks$(lineaddr,Peek.w(?comWord_Column))
    slen.w = FLen(strline$) : found = False
    tokname$ = "" : strhelp$ = ""
    While (slen > 0) AND (found = False)
      schar$ = Mid$(strline$,slen,1)
      If schar$ = " "
        found = True
      Else
        tokname$ = schar$ + tokname$
        slen - 1
      EndIf
    Wend
  EndIf
  !asm
RTS

.sub_newsizeparameters:
  MOVEA.l ptr_sourcewindow,A0
  CLR.w win_TopLeft
  CLR.w win_TopEdge
  CLR.w win_Width
  CLR.w win_Height
  MOVE.w $04(A0),win_TopLeft
  MOVE.w $06(A0),win_TopEdge
  MOVE.w $08(A0),win_Width
  MOVE.w $0A(A0),win_Height
  !basic
  Poke.w ?win_InnerHeight, Peek.w(?win_Height) - Peek.w(?win_BorTop) - Peek.w(?win_BorBot)
  Poke.w ?win_InnerWidth , Peek.w(?win_Width)  - Peek.w(?win_BorLef) - Peek.w(?win_BorRig)
  !asm


  MOVE.l messagestore,d0
  BEQ 'ls1
  MOVE.l d0,a1
  JSR _ReplyMsg(A6)
  MOVEQ.l #$00,D0
  CLR.l messagestore
 'ls1

  CMP.l #$FFFFC000,message_qualifier
  BNE resize_sourcewindow

;  CMP.w #$FFFF0000,message_qualifier
;  BNE resize_sourcewindow
RTS

.resize_sourcewindow:
  MOVEM.l d0-d7/a0-a6,-(a7)

  JSR cursor_off
  JSR free_textbuffer
  JSR sub_calculatedimensions
  JSR allocate_textbuffer
  JSR clear_sourcewindow_visual
  JSR update_statusline
  JSR _redraw
  JSR cursor_on

  MOVEM.l (a7)+,d0-d7/a0-a6
  exit_resizewin:
RTS


.sub_activatewindow:
  MOVEA.l D0,A1
  JSR _ReplyMsg(A6)
  MOVEA.l _intuibase,A6
  MOVEA.l ptr_sourcewindow,A0
  JSR _ActivateWindow(A6)
  MOVEQ.l #$00,D0
RTS


.set_tedlibbase
  MOVEM.l d0-d7/a0-a6,-(a7)
;  TST.l _tedlibbase
;   BEQ.w 'notedlib
;  MOVE.l _tedlibbase,a6
;  LEA comdata,A0
;  JSR _TEDSetJumpTable(A6)                  ;set_tedlibbase
;  LEA comPtr_FirstSourceLine,A0
;  JSR _TEDSetFirstLine(A6)
;  LEA comPtr_CurrentSourceLine,A0
;  MOVE.l comPtr_CurrentSourceLine,a0
;  MOVE.l (a0),d0
;  BEQ 'skip
;  JSR _TEDSetCurrentLine(A6)
; 'skip
;  MOVEA.l _tedlibbase,A6
;  LEA comPtr_LabelList,A0
;  JSR _TEDSetLabelList(A6)
;  LEA comWord_LabelCounter,A0
;  JSR _TEDSetLabelCount(A6)
; 'notedlib
  !basic
  TEDSetJumpTable  {?COMDATABASE}
  TEDSetFirstLine  {?comPtr_FirstSourceLine}
  TEDSetCurrentLine{?comPtr_CurrentSourceLine} ; or Peek.l(?comPtr_CurrentSourceLine) !?
  TEDSetLabelList  {?comPtr_LabelList}
  TEDSetLabelCount {?comWord_LabelCounter}
  !asm
  MOVEM.l (a7)+,a0-a6/d0-d7
RTS


JUMP_event_arexx:
JMP event_arexx

JL_0_8104:
  ; -- is there a message at the arexxport ?
  TST.l arexxport_available
   BEQ.w general_message_loop
  MOVEA.l _execbase,A6
  MOVEA.l struct_ArexxMsgPort,A0
  JSR _WaitPort(A6)
  MOVEA.l struct_ArexxMsgPort,A0
  JSR _GetMsg(A6)
  MOVE.l D0,struct_RexxMsg
   BNE.w JUMP_event_arexx

 .general_message_loop:
  MOVEA.l _execbase,A6

 JL_0_8134:
  CLR.w message_qualifier
;  BSR.b checkfor_compilerwin             ; Set focus to compilerwindow ?
  TST.l ptr_sourcewindow
   BEQ.b JL_0_8104
  MOVEA.l ptr_sourcewindow,A2
  MOVEA.l $56(A2),A2                      ; Window->UserPort

 JL_0_8142:
  JSR check_state_of_debuggertoggle
  MOVEA.l A2,A0
  MOVEA.l _execbase,A6
  JSR _GetMsg(A6)
  TST.l D0
   BNE.w message_loop

  TST.l struct_ArexxMsgPort
   BEQ.w JL_0_816C
  MOVEA.l struct_ArexxMsgPort,A0
  JSR _GetMsg(A6)
  TST.l D0
   BNE.w JL_0_81A0

 JL_0_816C:
  MOVE.l #$fffF0000,D0
  MOVE.b rexx_signalbits,D1
  BSET D1,D0
  CNIF #use_NTUI
   MOVE.l #$FFFFFFFF,D0
  CEND
  JSR _Wait(A6)

  .message
  MOVE.l a2,-(a7)                           ; sichern des Msg-Port in A2
  MOVE.l a1,-(a7)
  ADD.b #1,blinkcount
  MOVE.b blinkrate,d0
  BEQ 'l1
  CMP.b blinkcount,d0
  BGT 'l1
  MOVE.b #0,blinkcount
  MOVEA.l comPtr_SourceAreaRastPort,A1
  MOVE.b #3,$18(a1)
  JSR switch_cursordisplay
  MOVEA.l comPtr_SourceAreaRastPort,A1
;  TST.b newcolormode
;  BEQ 'l1
  MOVE.b #15,$18(a1)

 'l1
  MOVE.l (a7)+,a1

 .event_handler:        ; hier kommt die BB2 message
;  !regs2stack                                                               ;deactived 1. not nessecary 2. get not removed if Menu or hotkey is used  tomsmart1
  !basic
;  !cout{Hex$(Peek.l(?comPtr_Temp_TokenString1)),Hex$(Peek.l(TEDGetCurrentLine_))}
;  !cout{ Peek$(TEDDetoke_(Peek.l(?comPtr_Temp_TokenString3)))}
;  !cout{Hex$(Peek.l(?comPtr_DosBuffer))}
;!cout{"basic handler"}
  CNIF #use_NTUI
   ntui_Handle{}
  CEND
  ev.l = Event
  While ev
    ; bubble onlinehelp for most windows
    If Peek.b(?onlinehelp)<>0
      If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) AND (ev<>#IDCMP_GADGETHELP)  AND (ev<>#IDCMP_CHANGEWINDOW)
        WZ_HideHelp{}
      EndIf
      If ev = #IDCMP_GADGETHELP Then WZ_ShowHelp{}
    EndIf

    If ev = #IDCMP_MENUPICK
      addr_menuitem.l = ItemAddress_(Peek.l(?addr_menustrip),EventCode)
      itemnumber.l = Peek.l(addr_menuitem+$22)
      GetD0 itemnumber
      !asm
      MOVE.l d0,d6
      JSR event_shortcut
      !basic
    Else
      Use Window EventWindow
      Select EventWindow

        Case WZID("WIN_SEARCH")             : Gosub event_find

        Case WZID("WIN_CONTEXTHELP")        : If ev = #IDCMP_CLOSEWINDOW Then Gosub close_bubblehelp

        Case WZID("WIN_NEWTYPE")            : Gosub event_newtype

        Case WZID("WIN_INSTRUCTIONBROWSER") : Gosub event_instructionbrowser

        Case WZID("WIN_LIBRARYBROWSER")     : Gosub event_librarybrowser

        Case WZID("WIN_LABELS")             : Gosub event_label

        Case WZID("WIN_POPUP")              : Gosub event_popup

        Case WZID("WIN_HELPDIAG")           : Gosub event_diag

        Case WZID("WIN_SHORTCUTS")          : Gosub event_shortcuts

        ; -- fuer das sourcewindow, funktioniert aber noch nicht

        Default
; ;      !cout{"default"}
        If EventQualifier = $ffff8040
          Select EventCode

            Case 83 : savewinpref{0,?ptr_sourcewindow} : JSR write_newprefs

            Case 84 : savewinpref{1,?ptr_sourcewindow} : JSR write_newprefs

            Case 85 : savewinpref{2,?ptr_sourcewindow} : JSR write_newprefs

          End Select
        End If

        Select EventCode

          Case 83 : num.l = 0 : Gosub load_windowlayouts : Gosub do_windowlayout

          Case 84 : num = 1   : Gosub load_windowlayouts : Gosub do_windowlayout

          Case 85 : num = 2   : Gosub load_windowlayouts : Gosub do_windowlayout

          Case 86 : AutoLayout{&wtemp,0} : Gosub do_windowlayout

          Case 87 : AutoLayout{&wtemp,1} : Gosub do_windowlayout

;          Case 88 : AutoLayout{&wtemp,2} : Gosub do_windowlayout

          Default
        End Select
;        If RawKeyState($53) Then num.l = 0 : Gosub load_windowlayouts : Gosub do_windowlayout
;        If RawKeyState($54) Then num.l = 1 : Gosub load_windowlayouts : Gosub do_windowlayout
;        If RawKeyState($55) Then num.l = 2 : Gosub load_windowlayouts : Gosub do_windowlayout

      End Select
    EndIf
    ev = Event
  Wend

  ;-- check if a compiled program is running
  TST.b comByte_RunningFlag
  BEQ 'l1
  PrintScreenTitle{Peek$(?warningtitle)}
  rf.l = 1
BRA 'l2

 'l1
  If rf = 1 AND Peek.b(?comByte_RunningFlag) = 0
    PrintScreenTitle{Peek$(?str_screentitle)}
    rf = 0
  End If

 'l2
;  !cout{"zurueck in asm"}
  !asm                                                                         
;  !stack2regs                                                                 ;deactived 1. because !regs2stack is deactived 2.not nessecary  tomsmart1
  MOVE.l (a7)+,a2             ; zurueckholen vom MsgPort in A2
  MOVE.l _execbase,A6

  MOVEA.l A2,A0
  JSR _GetMsg(A6)
  TST.l D0
   BNE.w message_loop

  TST.l arexxport_available
  BEQ.b JL_0_8142

  MOVEA.l struct_ArexxMsgPort,A0
  JSR _GetMsg(A6)
  TST.l D0
  BEQ.b JL_0_8142

 JL_0_81A0:
  MOVE.l D0,struct_RexxMsg
  MOVEM.l D2-D5/A2-A6,-(A7)
  JSR event_arexx
  MOVEM.l (A7)+,D2-D5/A2-A6
  TST.l ptr_sourcewindow
  BEQ.w JL_0_8104
  MOVEA.l ptr_sourcewindow,A2
RTS
;BRA.w checkfor_compilerwin


.check_state_of_debuggertoggle
  MOVEM.l d0-d1/a0-a1/a6,-(a7)
  !basic
  If Peek.b(?comByte_DebugMode)<>Peek.b(?olddebugmode)
    Poke.b ?olddebugmode,Peek.b(?comByte_DebugMode)
  EndIf
  GTSetMenuChecked 0,4,12,Peek.b(?comByte_DebugMode)
  !asm
  MOVEM.l (a7)+,d0-d1/a0-a1/a6
RTS


message_loop:
  JSR event_sourcewindow       ;JL_0_81CA
  BEQ.w JL_0_8134
RTS



.event_sourcewindow:            ;JL_0_81CA:
  MOVEA.l D0,A1                  ; A1: IntuiMessage
  MOVE.l D0,messagestore
  !basic
  *intuimessage.IntuiMessage = PutD0
  !asm
  MOVE.l $14(A1),message_class        ;   MessageClass
  MOVE.l $14(A1),D1

  MOVE.w $18(A1),message_code         ;   MessageClass
  MOVE.w $1A(A1),message_qualifier

  CMP.l #IDCMP_REFRESHWINDOW,message_class
  BEQ.w sub_newsizeparameters
  CMP.l #IDCMP_NEWSIZE,message_class
  BEQ.w sub_newsizeparameters

  CMP.l #IDCMP_INACTIVEWINDOW,message_class
  BEQ.w message_inactivewindow

  CMP.l #IDCMP_GADGETDOWN,message_class
  BEQ.b message_gadgetevent

  CMP.l #IDCMP_GADGETUP,message_class
  BEQ.b message_gadgetevent

  MOVE.w message_code,D0               ; IntuiMessage->Code to D0
  CMP.l #IDCMP_MENUVERIFY,message_class
  BEQ.w JL_0_844C

  CMP.l #IDCMP_CLOSEWINDOW,message_class
  BEQ.w message_closewindow

  CMP.l #IDCMP_MENUPICK,message_class
  BEQ.w message_menupick

  CMP.l #IDCMP_MOUSEBUTTONS,message_class
  BEQ.w message_mousebuttons

  CMP.l #IDCMP_RAWKEY,message_class
  BEQ.w message_rawkey

  CMP.l #IDCMP_VANILLAKEY,message_class
  BEQ.w message_vanillakey

 JL_0_844C:
  MOVE.l _execbase,A6
  MOVE.l messagestore,d0
  BEQ 'l1
  MOVE.l d0,a1
  JSR _ReplyMsg(A6)

 'l1
  CLR.l messagestore
  MOVEQ.l #$00,D7
  MOVEQ.l #$00,D0
  RTS

 JL_0_822A:
  MOVEQ.l #$00,D0
RTS


.message_gadgetevent:              ;JL_0_8240
  MOVEA.l $1C(A1),A0            ; IntuiMessage -> IAdress -> hier Gadget

  JL_0_8244:
  MOVE.w $26(A0),D6             ; GadgetID
  MOVEQ.l #-$01,D7
  CMPI.w #910,D6                ; BOOPSI-Gadget (Pfeilgadgets) gedrueckt ?
   BGE.w message_boopsiarrow
  CMPI.b #$4,$11(A0)            ; GadgetType: 4 = StrGadget
   BNE.b JL_0_825C
  CMPI.w #$9,$18(A1)            ; MessageClass->Code: $9 =
   BEQ.w JL_0_844C

  JL_0_825C:
  BTST #$2,$F(A0)               ;
  BEQ.w reply_idcmp_message
  CMP.w #IDCMP_GADGETDOWN,message_class
  BEQ.w reply_idcmp_message
  MOVE.l messagestore,d0
  BEQ 'l1
  MOVE.l d0,a1
  JSR _ReplyMsg(A6)
 'l1
  CLR.l messagestore
  JSR comwin_close
  MOVEQ.l #-$01,D0
RTS

.message_inactivewindow
  MOVEA.l D0,A1
  MOVE.l messagestore,d0
  BEQ 'l1
  MOVE.l d0,a1
  JSR _ReplyMsg(A6)
 'l1
  CLR.l messagestore
  ;MOVEA.l comPtr_statuswindow,A2
  ;CMP.l #0,a2
  ;BEQ JL_0_822A
  ;MOVEA.l $56(A2),A2
  MOVEA.l A2,A0
  JSR _GetMsg(A6)
  TST.l D0
   BEQ.w JL_0_822A
  MOVEA.l D0,A1
;  MOVE.l $14(A1),D1              ;  MessageClass
  CMP.l #IDCMP_ACTIVEWINDOW,message_class
  BEQ.w sub_activatewindow
  MOVEA.l D0,A1
  JSR _ReplyMsg(A6)
  MOVEQ.l #$00,D0
RTS

.message_boopsiarrow:
  MOVE.l d6,d0
  !basic
  gadgetid.w = PutD0 : arrow_pressed.w = 0
  If *intuimessage\Class = #IDCMP_GADGETDOWN
    Select gadgetid
    Case #GID_RARROW
      arrow_pressed = $1E

    Case #GID_LARROW
      arrow_pressed = $1F

    Case #GID_UARROW
      arrow_pressed = $1C

    Case #GID_DARROW
      arrow_pressed = $1D

  ;  Case #GID_XPROP
  ;    DEFTYPE.l x
  ;    GetAttr_ #PGA_Top,*horizprop,&x
  ;    !cout{"horizontal scroller pressed:",x}
  ;  Case #GID_YPROP
  ;    DEFTYPE.l y
  ;    GetAttr_ #PGA_Top,*vertiprop,&y
  ;    !cout{"vertical scroller pressed:",y}
    End Select
    If arrow_pressed
      GetD0 arrow_pressed
      !asm
      MOVE.l #IDCMP_VANILLAKEY,message_class
      MOVE.w D0,message_code
      BRA.w message_vanillakey
    EndIf

  EndIf
  MOVEQ.l #$00,D7
BRA.w JL_0_844C

.message_closewindow
  MOVEQ.l #$6C,D6
  MOVEQ.l #-$02,D7
BRA.w reply_idcmp_message

.message_menupick
  CMP.w #-$1,D0
  BEQ.w JL_0_844C
  JSR set_tedlibbase
  MOVE.l A1,-(A7)
  ANDI.l #MaxWord,D0

  MOVEA.l addr_menustrip,A0
  MOVEA.l _intuibase,A6
  JSR _ItemAdress(A6)

  MOVEA.l _execbase,A6
  MOVEA.l D0,A0
  MOVE.l $22(A0),D6

; print out Userdata of selected item
;  !basic
;    me.l = PutD0
;    !cout{Hex$(Peek.l(me+$22))}
;  !asm

  ; check on "reload Blitzlibs"
  CMP.l #$58,d6
  BNE 'l10
  LEA instrtab,a1
  MOVE.l #32767,d0
 'l11:
    CLR.l (a1)+
  DBF d0,'l11
 'l10:

  MOVEQ.l #-$02,D7
  MOVEA.l (A7)+,A1
BRA.w reply_idcmp_message

.message_mousebuttons
  MOVEQ.l #-$03,D7
  TST.b comByte_RunningFlag
  BNE 'l1r
  ;MOVE.w message_code,D7
  ;AND.w #IECODE_UP_PREFIX,D7
  ;TST.w D7
  ;BEQ 'l1r
  JSR check_mouse_in_statusarea
 'l1r
  MOVE.w #$0001,comWord__AL_0_8520
  CMP.w #$68,D0
  BEQ.w 'l10
  MOVE.w #$0000,comWord__AL_0_8520
  MOVEQ.l #-$04,D7
  CMP.w #$e8,d0
  BNE 'noshift
  BRA  reply_idcmp_message

 'l10:
  MOVE.l _execbase,A6
  MOVE.l messagestore,d0
  BEQ 'l1
  MOVE.l d0,a1
  JSR _ReplyMsg(A6)

 'l1
  CLR.l messagestore
  MOVEQ.l #-$01,D0
  RTS
  BRA  reply_idcmp_message

 'noshift
  CMP.w #$6a,d0
  BNE nomid
  MOVE.w message_qualifier,d1
  AND.w #$30,d1
  BEQ nomid
  ; middle mousebutton pressed ...
  JSR jump_historyup
  MOVE.l _execbase,A6
  MOVE.l messagestore,d0
  BEQ 'l1b
  MOVE.l d0,a1
  JSR _ReplyMsg(A6)
 'l1b
  CLR.l messagestore
  MOVEQ #0,d0
  RTS

  nomid:
BRA.w reply_idcmp_message


.message_rawkey
  MOVE.w message_qualifier,comWord_QualifierStore   ; Message->Qualifier
;  MOVE.w $1A(A1),message_qualifier
  !basic
  last_key.l = Peek.w(?message_code)
  !asm
  MOVEQ.l #$00,D7
  MOVE.w message_code,D7               ; Message->Code

  JSR navigate_in_label_window
  CMP.w #$50,D7                   ; "F1"
   BLT.w JL_0_831E
  CMP.w #$59,D7                   ; "F10"
   BGT.w JL_0_831E
  ADDI.w #$31,D7
  BRA.w JL_0_8346

  JL_0_831E:
  CMP.w #$5F,D7                   ; "HELP"
   BEQ.w JL_0_8354
  CMP.w #$44,D7                   ; "RETURN"
   BEQ.w JL_0_8364
  CMP.w #$4F,D7                   ; "CURSOR <"
   BGT.w JL_0_844C
  CMP.w #$4C,D7                   ; "CURSOR up"
   BLT.w JL_0_844C
  SUBI.w #$30,D7                  ; ""
  BRA.w reply_idcmp_message

  JL_0_8346:
  MOVE.l #IDCMP_VANILLAKEY,message_class
  MOVE.w D7,message_code
  BRA.w check_for_vanillakey

  JL_0_8354:
  MOVE.l #IDCMP_VANILLAKEY,message_class
  MOVE.w #$008B,message_code     ; set message_code to HELP-Key
  BRA.w check_for_vanillakey

  JL_0_8364:
  MOVE.l #IDCMP_VANILLAKEY,message_class
  MOVE.w #$000D,message_code     ; set message_code to RETURN-Key

  check_for_vanillakey:
  CMP.l #IDCMP_VANILLAKEY,message_class
  BNE.w JL_0_844C    ;JL_0_8438
BRA message_vanillakey



.message_vanillakey
  !basic
  last_key.l = Peek.w(?message_code)
  !asm
  MOVEQ.l #$00,D7
  MOVE.w message_code,D7               ; Vanillakey
  MOVE.w message_qualifier,D1
  MOVE.w D1,comWord_QualifierStore

  CMP.w #$0d,d7                        ; check for "RETURN"
  BNE 'noreturn
  JSR immediate_syntaxhelp
 'noreturn

  CMP.w #$8b,d7                        ; check for "HELP"
  BNE 'nohelp

  CMP.w #$8000,D1
  BNE.w 'check_ctrlhelp
  JSR immediate_syntaxhelp

 'check_ctrlhelp
  CMP.w #$8008,D1
  BNE.w 'check_shifthelp
  JSR diag_help

 'check_shifthelp
  CMP.w #$8001,D1
  BNE.w 'nohelp
  JSR startguide

 'nohelp
  CMP.w #$1b,d7                        ; check for "ESC"
  BNE 'noesc
  !basic
  Gosub close_bubblehelp
  Gosub close_popupwindow
  !asm

 'noesc
  CMP.w #$15,d7                        ; check for "CTRL_U"
  BNE 'noCTRL_U
  MOVEM.l a0-a6/d0-d7,-(a7)
  JSR cursor_off
  JSR _redraw
  BSR cursor_on
  MOVEM.l (a7)+,a0-a6/d0-d7
  CLR.l d7
  BRA.w reply_idcmp_message
 'noCTRL_U

  CMP.w #$e,d7                         ; check for "CTRL_N"
  BNE 'noctrl_n   ;newtype
  !basic
  a$ = "newtype ."
  JSR cursor_off
  Gosub insertstring
  !asm
  JSR insertreturn
  JSR insertreturn
  !basic
  a$ = "end newtype "
  Gosub insertstring
  !asm
 'noctrl_n                             ; check for "CTRL_F"

  CMP.w #$6,d7
  BNE 'noctrl_f   ;function
  !basic
  a$ = "function.l { }"
  JSR cursor_off
  Gosub insertstring
  !asm
  JSR insertreturn
  JSR insertreturn
  !basic
  a$ = "function return 0"
  JSR cursor_off
  Gosub insertstring
  !asm
  JSR insertreturn
  !basic
  a$ = "end function "
  Gosub insertstring
  !asm
 'noctrl_f

  CMP.w #$5,d7                         ; check for "CTRL_E"
  BNE 'noctrl_e   ;end if
  !basic
  a$ = "end if "
  JSR cursor_off
  Gosub insertstring
  !asm
 'noctrl_e

  CMP.w #$8040,d1                      ; check for "L-AMIGA"
  BNE nolamiga
  CMP.w #$84,d7                        ; check for "LA-F4"
  BNE 'nof14
  !basic
  savewinpref{0,?ptr_sourcewindow} : JSR write_newprefs
  !asm
 'nof14

  CMP.w #$85,d7                        ; check for "LA-F5"
  BNE 'nof15
  !basic
  savewinpref{1,?ptr_sourcewindow } : JSR write_newprefs
  !asm
 'nof15

  CMP.w #$86,d7                        ; check for "LA-F6"
  BNE 'nof16
  !basic
  savewinpref{2,?ptr_sourcewindow } : JSR write_newprefs
  !asm
 'nof16

  CMP.w #$61,d7                        ; ???
  BNE 'noa
  MOVEM.l a0-a6/d0-d7,-(a7)
  MOVE.l lastedited_line,d0
 'doit
  MOVE.l comPtr_CurrentSourceLine,a4
  JSR cursor_off
  JSR gotoline
  BSR cursor_on
  MOVEM.l (a7)+,a0-a6/d0-d7
  CLR.l d7
  BRA reply_idcmp_message
 'noa

  CMP.w #$31,d7                       ; check for "1"
  BNE 'no1
  MOVEM.l a0-a6/d0-d7,-(a7)
  MOVE.l storeline1,d0
  BRA 'doit
 'no1
  CMP.w #$32,d7                       ; check for "2"
  BNE 'no2
  MOVEM.l a0-a6/d0-d7,-(a7)
  MOVE.l storeline2,d0
  BRA 'doit
 'no2
  CMP.w #$33,d7                       ; check for "3"
  BNE 'no3
  MOVEM.l a0-a6/d0-d7,-(a7)
  MOVE.l storeline3,d0
  BRA 'doit
 'no3
  nolamiga

  CMP.w #$84,d7                       ; check for "F4"
  BNE 'nof4
  !basic
  num = 0:Gosub load_windowlayouts: Gosub do_windowlayout
  !asm
  CLR d7
  CLR d1
 'nof4

  CMP.w #$85,d7                       ; check for "F5"
  BNE 'nof5
  !basic
  num = 1:Gosub load_windowlayouts: Gosub do_windowlayout
  !asm
  CLR d7
  CLR d1
 'nof5

  CMP.w #$86,d7                       ; check for "F6"
  BNE 'nof6
  !basic
  num = 2:Gosub load_windowlayouts: Gosub do_windowlayout
  !asm
  CLR d7
  CLR d1
 'nof6

  CMP.w #$87,d7                       ; check for "F7"
  BNE 'nof7
  !basic
  AutoLayout{&wtemp,0}
  Gosub do_windowlayout
  !asm
  CLR d7
  CLR d1
 'nof7

  CMP.w #$88,d7                       ; check for "F8"
  BNE 'nof8
  !basic
  AutoLayout{&wtemp,1}
  Gosub do_windowlayout
  !asm
  CLR d7
  CLR d1
 'nof8

;  CMP.w #$89,d7                       ; check for "F9"
;  BNE 'nof9
;  !basic
;  AutoLayout{&wtemp,2}
;  Gosub do_windowlayout
;  !asm
;  CLR d7
;  CLR d1
; 'nof9


  CMP.w #$8041,d1             ; check for ""
  BEQ 'ok
  CMP.w #$8042,d1             ; check for ""
  BNE 'nolsamiga
 'ok
  CMP.w #$21,d7               ; check for ""
  BNE 'no1
  MOVE.l d1,-(a7)
  MOVE.l comLong_DisplayLine,D1
  ADD.l comLong_DisplayLineOffset,D1
  MOVE.l d1,storeline1
  MOVE.l (a7)+,d1
  CLR.l d7
  BRA reply_idcmp_message
 'no1
  CMP.w #$22,d7               ; check for ""
  BNE 'no2
  MOVE.l d1,-(a7)
  MOVE.l comLong_DisplayLine,D1
  ADD.l comLong_DisplayLineOffset,D1
  MOVE.l d1,storeline2
  MOVE.l (a7)+,d1
  CLR.l d7
  BRA reply_idcmp_message
 'no2
  CMP.w #$23,d7               ; check for ""
  BNE 'no3
  MOVE.l d1,-(a7)
  MOVE.l comLong_DisplayLine,D1
  ADD.l comLong_DisplayLineOffset,D1
  MOVE.l d1,storeline3
  MOVE.l (a7)+,d1
  CLR.l d7
  BRA reply_idcmp_message
 'no3
 'nolsamiga

.reply_idcmp_message:
  MOVE.l _execbase,A6
  MOVE.l messagestore,d0
  BEQ 'l1
  MOVE.l d0,a1
  JSR _ReplyMsg(A6)
 'l1
  CLR.l messagestore
  MOVEQ.l #-$01,D0
RTS



Even
;L_0_849E:
;  Dc.b $e4
;  Dc.b $1A,$F6,$1B
;
;  Dc.b $fc
;  Dc.b $1C,$C4,$1D
;
;  Dc.b $d6
;  Dc.b $1E,$DC,$1F
;
;  Dc.b $df,$19,$a9,$18

actualfile:             Dc.l 0  ; current node
loadedfilesbase:        Dc.l 0  ; base node of file linked list
AL_0_84B2:              Dc.l 0

; -- these 2 addresses may be called by the compiler, too
;AL_0_84B6:              Dc.l close_gui
;AL_0_84BA:              Dc.l create_whole_gui





.fontdependent:
 viewablelines:         Dc.l 0
 visiblecolumns:        Dc.w 0
 fontheight:            Dc.l 0
 fontheightl:           Dc.l 0
 ;comWord__AL_0_8678:   Dc.w $0050
 ypos_statusarea        Dc.l 0
 viewablelines_m1:      Dc.l 0
 win_InnerHeight:       Dc.w 0
 win_InnerWidth:        Dc.w 0
 win_TopEdge:           Dc.w 0
 font_Heightm1:         Dc.w $0005
 font_Baseline:         Ds.l 1
 ptr_sourcewindow:      Dc.l 0
 rp_sourcewindow:       Dc.l 0
 ptr_pedscreen:         Dc.l 0
 ptr_exescreen:         Dc.l 0
 textbufferaddr:        Dc.l 0


.menu_helpshortcuts
  !basic
  Gosub open_shortcuts
  !asm
RTS

.menu_helplibrarybrowser
  !basic
  Gosub open_librarybrowser
  !asm
RTS

.menu_helpcompletion
  !basic
  wtemp\ibrowser_x = -2
  wtemp\ibrowser_y = -2
  wtemp\ibrowser_w = -2
  wtemp\ibrowser_h = -2
  Gosub open_instructionbrowser
  !asm
RTS

.menu_helpnews:
  !basic
  Show_Helpfile{"Changelog","main",Peek$(?str_defaultpubscreen)}
  !asm
RTS

.menu_helpblitzlibs:
  !basic
  Show_Helpfile{"BlitzLibs","main",Peek$(?str_defaultpubscreen)}
  !asm
RTS

.menu_helpgeneral:
  !basic
  Show_Helpfile{"AmiBlitz3","main",Peek$(?str_defaultpubscreen)}
  !asm
RTS

.menu_helpprogramming:
  !basic
  Show_Helpfile{"BlitzProgrammers","main",Peek$(?str_defaultpubscreen)}
  !asm
RTS

.menu_helpincludesguide:
  !basic
  Show_Helpfile{"Main","main",Peek$(?str_defaultpubscreen)}
  !asm
RTS


.menu_helpsyntax:
;  !basic
  MOVE.l #$8b,D7
  JSR immediate_syntaxhelp
;  !asm
RTS


.menu_helpbuildindex
  !basic
  Gosub build_HelpIndexFile
  !asm
RTS

.menu_prefs:
  JSR menu_settings
RTS

.write_newprefs
  If WriteFile (0,addonprefs$)
    WriteType 0,wpref(0)
    WriteType 0,wpref(1)
    WriteType 0,wpref(2)
    CloseFile 0
  End If
RTS

;AL_0_A17A:             Ds.l 63
;                       Ds.l 1
ptr_tempmsgport:       Ds.l 1
ptr_colormap:          Ds.l 1
str_title_palreq:      Dc.b "Choose A Colour Palette...",0
;AL_0_B74C:             Ds.l 1
;AL_0_B750:             Ds.l 1
str_tedhistory_env:    Dc.b "ENV:Ted.history",0
                       Dc.b "ENVARC:TED.history",0
Even                   ; make sure To have enough space reserved


.PREFSFORMAT
 use_wbcolors:                               ; use col 0-3 from wb         OBSOLETE
                        Dc.b $00,$00
 clone_wb:                                   ;clone wb                     TOOLTYPE
                        Dc.b $00,$00
 use_asldims:
                        Dc.b $FF,$FF
 aslreq_x:              Dc.l $18
 aslreq_y:              Dc.l $18
 aslreq_width:          Dc.l $17C
 aslreq_height:         Dc.l $17C
 flag_tokenization:                          ; irgendwas mit tokenize
                        Dc.b $FF,$FF
 prefs_source_icon:     Ds.w 3
 ownscreen_modeid:                           ;                              TOOLTYPE
                        Dc.l 0
 ;myscreen_Width:
                        Ds.w 1
 ownscreen_width:                            ;                              TOOLTYPE
                        Dc.b $02,$80
 ;myscreen_Height:
                        Ds.w 1
 ownscreen_height:                           ;                              TOOLTYPE
                        Dc.b $01,$00
 ;myscreen_Depth:
                        Dc.b $00,$00
                        Ds.w 1
 clickpos:
                        Dc.b $00,$0f
 othercolor:                                 ; ex-backgroundcolor           TOOLTYPE
                        Dc.b $00,$02

 tokencolor:                                 ;                              TOOLTYPE
                        Dc.b $00 ;.
                        Dc.b $03 ;.
 str_sourcefontname:                         ;                              TOOLTYPE
                        Dc.b 0
                        Ds.b #MAX_STRINGSIZE
                        Even
 sourcefontstyle:
                        Dc.b $00
 sourcefontflags:
                        Dc.b $03
 sourcefontsize:                             ;                               TOOLTYPE
                        Dc.b $00,$08

                        Dc.w 1               ;DUMMY
 auto_indent:                                ;                               TOOLTYPE
                        Dc.b $FF,$FF

 use_filepattern:
                        Dc.b $FF,$FF

 AL_0_B7E0:                                  ; save xtra-file ???
                        Dc.b $FF,$FF

 tab_size:                                   ;                               TOOLTYPE
                        Dc.b $00,$02

 use_pubscreen:                              ;                               TOOLTYPE
                        Dc.b $FF,$FF

 remember_saved:                             ;                               TOOLTYPE
                        Dc.b $FF,$FF

 use_default_pubscreen:                      ;                               TOOLTYPE
                        Ds.w 1
 ownscreen_depth:                            ;                               TOOLTYPE
                        Dc.b $00,$02

 startup_folder:
                        Dc.b $FF,$FF

 AL_0_B7EE:                                  ; ??? irgendwas mit Fensterpos  OBSOLETE ??
                        Ds.w 1
 AL_0_B7F0:                                  ; ??? irgendwas mit Fensterpos  OBSOLETE ??
                        Ds.w 1
 AL_0_B7F2:                                  ; ??? irgendwas mit Farben ??
                        Ds.w 1
 AL_0_B7F4:                                  ; ???
                        Dc.b $00,$0C

 ;comLong_BoundLines:
                        Dc.b $00 ;.
                        Dc.b $06 ;.
 ;AL_0_B7F8:
                        Dc.b "%1ld ",0
 ;L_0_B7FE:
                        Ds.l 4
 Even
.PREFSFORMAT_END



.update_tedhistoryfiles:
  CMP.w #$10,D6
   BEQ.w JL_0_B902
  CMP.w #$C,D6
   BEQ.w JL_0_B8A8
  CMP.w #$8,D6
   BEQ.w JL_0_B862
  CMP.w #$4,D6
   BEQ.w JL_0_B830
  RTS

  JL_0_B830:
  MOVEA.l AL_0_BFFA,A0
  MOVEA.l AL_0_BE28,A1
  MOVE.l AL_0_BFE6,AL_0_BFFA
  MOVE.l AL_0_BE24,AL_0_BE28
  MOVE.l A0,AL_0_BFE6
  MOVE.l A1,AL_0_BE24
  JSR update_historymenu
  RTS

  JL_0_B862:
  MOVEA.l AL_0_C00E,A0
  MOVEA.l AL_0_BE2C,A1
  MOVE.l AL_0_BFFA,AL_0_C00E
  MOVE.l AL_0_BFE6,AL_0_BFFA
  MOVE.l AL_0_BE28,AL_0_BE2C
  MOVE.l AL_0_BE24,AL_0_BE28
  MOVE.l A0,AL_0_BFE6
  MOVE.l A1,AL_0_BE24
  JSR update_historymenu
  RTS

  JL_0_B8A8:
  MOVEA.l AL_0_C022,A0
  MOVEA.l AL_0_BE30,A1
  MOVE.l AL_0_C00E,AL_0_C022
  MOVE.l AL_0_BFFA,AL_0_C00E
  MOVE.l AL_0_BFE6,AL_0_BFFA
  MOVE.l AL_0_BE2C,AL_0_BE30
  MOVE.l AL_0_BE28,AL_0_BE2C
  MOVE.l AL_0_BE24,AL_0_BE28
  MOVE.l A0,AL_0_BFE6
  MOVE.l A1,AL_0_BE24
  JSR update_historymenu
  RTS

  JL_0_B902:
  MOVEA.l AL_0_C036,A0
  MOVEA.l AL_0_BE34,A1
  MOVE.l AL_0_C022,AL_0_C036
  MOVE.l AL_0_C00E,AL_0_C022
  MOVE.l AL_0_BFFA,AL_0_C00E
  MOVE.l AL_0_BFE6,AL_0_BFFA
  MOVE.l AL_0_BE30,AL_0_BE34
  MOVE.l AL_0_BE2C,AL_0_BE30
  MOVE.l AL_0_BE28,AL_0_BE2C
  MOVE.l AL_0_BE24,AL_0_BE28
  MOVE.l A1,AL_0_BE24
  MOVE.l A0,AL_0_BFE6
  JSR update_historymenu
RTS

free_historyfilelist:
  TST.w remember_saved
   BEQ.w JL_0_B98E
  TST.l ptr_historyfilelist
   BEQ.w JL_0_B98E
  MOVEA.l ptr_historyfilelist,A1
  !newfree
  JL_0_B98E:
RTS

AJL_0_B990:
  MOVEQ.l #$00,D6
  MOVEA.l #AL_0_BE10,A0
  ANDI.l #MaxWord,D6
  LEA comStr_SourceName,A3
  JL_0_B9A2:
    MOVEA.l $0(A0,D6.W),A1
    MOVEA.l (A1),A1
    JSR compare_strings
    BNE.w JL_0_B9BE
    JL_0_B9B2:
    ADDQ.w #4,D6
    CMP.w #$14,D6
  BNE.b JL_0_B9A2
  BRA.w JL_0_B9E0

  JL_0_B9BE:
  MOVEQ.l #$00,D7
  MOVEA.l #AL_0_BE24,A2
  MOVEA.l $0(A2,D6.W),A1
  MOVEA.l (A1),A1
  LEA comStr_CurrentDir,A3
  JSR compare_strings
  BNE.w JL_0_BA3C
  LEA comStr_SourceName,A3
  BRA.b JL_0_B9B2

  JL_0_B9E0:
  MOVEQ.l #$10,D6
  MOVEA.l #AL_0_BE10,A0
  MOVEA.l #AL_0_BE24,A2
  MOVEA.l #str_unnamed,A3

  JL_0_B9F4:
  MOVEA.l $0(A0,D6.W),A1
  MOVEA.l (A1),A1
  JSR compare_strings
   BNE.w JL_0_BA0E
  SUBQ.w #4,D6
   BPL.b JL_0_B9F4
  MOVEQ.l #$10,D6
  BRA.w JL_0_BA1C

  JL_0_BA0E:
  ADDQ.l #4,D6
  CMP.l #$10,D6
   BLE.w JL_0_BA1C
  MOVEQ.l #$10,D6

  JL_0_BA1C:
  MOVEA.l $0(A0,D6.W),A1
  MOVEA.l (A1),A1
  LEA comStr_SourceName,A0
  MOVEA.l $0(A2,D6.W),A2
  JSR AJL_0_4A8E
  LEA comStr_CurrentDir,A0
  MOVEA.l (A2),A1
  JSR AJL_0_4A8E

  JL_0_BA3C:
   JSR update_tedhistoryfiles
   JSR write_tedhistoryfiles
RTS

.add_history_to_menu:
  TST.w remember_saved
   BEQ.w JL_0_BA58
  JSR load_tedhistoryfile
  BRA.w JL_0_BA5C

  JL_0_BA58:
  JSR update_historymenu

  JL_0_BA5C:
RTS

.write_tedhistoryfiles:
  MOVE.l #str_tedhistory_env,D1
  JSR write_historyfile
RTS

.write_historyfile:
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVEA.l _dosbase,A6
   JSR _Open(A6)
  MOVE.l D0,D7
   BEQ.w JL_0_BAE0      ; if open not possible, exit
  MOVE.l D7,D1
  MOVE.l AL_0_BFE6,D2
  MOVE.l #$100,D3
   JSR _Write(A6)
  MOVE.l D7,D1
  MOVE.l AL_0_BFFA,D2
  MOVE.l #$100,D3
   JSR _Write(A6)
  MOVE.l D7,D1
  MOVE.l AL_0_C00E,D2
  MOVE.l #$100,D3
   JSR _Write(A6)
  MOVE.l D7,D1
  MOVE.l AL_0_C022,D2
  MOVE.l #$100,D3
   JSR _Write(A6)
  MOVE.l D7,D1
  MOVE.l AL_0_C036,D2
  MOVE.l #$100,D3
   JSR _Write(A6)
  MOVE.l D7,D1
   JSR _Close(A6)
  JL_0_BAE0:
RTS

.load_tedhistoryfile:
  MOVE.l ptr_historyfilelist,D0
   BNE.w load_historyfile
  MOVEA.l _execbase,A6
  MOVE.l #$500,D0
  MOVE.l #$10000,D1
  !newalloc;JSR _AllocVec(A6)
  MOVE.l D0,ptr_historyfilelist

.load_historyfile:
  MOVEA.l D0,A0
  MOVE.l A0,AL_0_BFE6
  LEA $40(A0),A0
  MOVE.l A0,AL_0_BE38
  LEA $C0(A0),A0
  MOVE.l A0,AL_0_BFFA
  LEA $40(A0),A0
  MOVE.l A0,AL_0_BE3C
  LEA $C0(A0),A0
  MOVE.l A0,AL_0_C00E
  LEA $40(A0),A0
  MOVE.l A0,AL_0_BE40
  LEA $C0(A0),A0
  MOVE.l A0,AL_0_C022
  LEA $40(A0),A0
  MOVE.l A0,AL_0_BE44
  LEA $C0(A0),A0
  MOVE.l A0,AL_0_C036
  LEA $40(A0),A0
  MOVE.l A0,AL_0_BE48
  LEA $C0(A0),A0
  JSR JL_0_BBCC
  MOVE.l #str_tedhistory_env,D1
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
  MOVEA.l _dosbase,A6
  JSR _Open(A6)
  MOVE.l D0,D7
  BEQ.w JL_0_BBA6
  MOVE.l D7,D1
  MOVE.l AL_0_BFE6,D2
  MOVE.l #$500,D3
  JSR _Read(A6)
  MOVE.l D7,D1
  JSR _Close(A6)
  JSR update_historymenu
  JL_0_BBA6:
RTS



JL_0_BBCC:
  MOVEA.l #str_unnamed,A0
  MOVEA.l AL_0_BFE6,A1
  JSR AJL_0_4A8E
  MOVEA.l AL_0_BFFA,A1
  JSR AJL_0_4A8E
  MOVEA.l AL_0_C00E,A1
  JSR AJL_0_4A8E
  MOVEA.l AL_0_C022,A1
  JSR AJL_0_4A8E
  MOVEA.l AL_0_C036,A1
  JSR AJL_0_4A8E
RTS

.update_historymenu:
  TST.l ptr_sourcewindow
  BEQ.w exit_updatemenus
  !basic
  Gosub init_menus
  !asm

  exit_updatemenus:
RTS

.load_remembered:
  TST.w remember_saved
   BNE.w JL_0_BCD6
  RTS

  JL_0_BCD6:
   SUBI.w #$78,D6
   LEA AL_0_BE10,A0
   ASL.w #2,D6
   ANDI.l #MaxWord,D6
   MOVEA.l $0(A0,D6.W),A1
   MOVEA.l (A1),A1

   ; check if unused, <unnamed> entry in menu item
   LEA str_unnamed,A3
   JSR compare_strings
   BNE.w no_source_loaded

;  MOVE.l A1,-(a7)
;  !basic
;  MOVE.l (a7)+,d0
;  i.l = PutD0
;  !cout{"filename to load",Peek$(i)}
;  !asm

  ; check if source already loaded.
  MOVEA.l loadedfilesbase,A2
  JL_0_BCFC:
    MOVEA.l A2,A3
    LEA $DE(A3),A3
    JSR compare_strings
    BNE.w source_already_opened
    JL_0_BD0A:
    MOVEA.l (A2),A2
    CMPA.l #$0,A2
  BNE.b JL_0_BCFC

  ;
  ; -- check if actual source is unnamed to decide to open new or just open
  ;
  !basic
  af.l = Peek.l(?actualfile)
  If af
    If Peek$(af+$DE)<>""
  ;    !cout{"need to open a new tab."}
      !asm
      JSR menu_opennew
      !basic
    EndIf
  End If
  !asm
  BRA.w load_sourcefile

  source_already_opened:
   LEA AL_0_BE24,A0
   MOVEA.l $0(A0,D6.W),A1
   MOVEA.l (A1),A1
   MOVEA.l A2,A3
   LEA $1E(A3),A3
   JSR compare_strings
   BEQ.b JL_0_BD0A
   MOVEA.l A2,A0
   JSR selectfile
  RTS

  no_source_loaded:
   MOVE.w D6,-(A7)
   JSR menu_load
   TST.l D0
   BEQ.w JL_0_BD5A
   JSR analyze_loadedsource
   MOVE.w (A7)+,D6
   JSR set_remembered_filename
   JSR update_statusline
   JSR write_tedhistoryfiles
  RTS

  JL_0_BD5A:
   MOVE.w (A7)+,D6
RTS

.set_remembered_filename:
  LEA AL_0_BE10,A1
  MOVEA.l $0(A1,D6.W),A1
  MOVEA.l (A1),A1
  LEA comStr_SourceName,A0
  JSR AJL_0_4A8E
  LEA AL_0_BE24,A1
  MOVEA.l $0(A1,D6.W),A1
  MOVEA.l (A1),A1
  LEA comStr_CurrentDir,A0
  JSR AJL_0_4A8E
RTS

.get_remembered_filename:
  LEA AL_0_BE10,A0
  MOVEA.l $0(A0,D6.W),A1

  LEA comStr_SourceName,A2
  MOVEA.l (A1),A1
  JL_0_BD96:
    MOVE.b (A1)+,(A2)+
  BNE.b JL_0_BD96

  LEA comStr_CurrentDir,A2
  LEA AL_0_BE24,A0
  MOVEA.l $0(A0,D6.W),A1
  MOVEA.l (A1),A1
  JL_0_BDA8:
    MOVE.b (A1)+,(A2)+
  BNE.b JL_0_BDA8
RTS


.load_sourcefile:
  JSR show_newfilerequest
  TST.l D0
  BNE.w JL_0_BDBA
  RTS

  JL_0_BDBA:
  LEA AL_0_BE24,A0
  MOVEA.l $0(A0,D6.W),A1
  MOVEA.l (A1),A1
  LEA AL_0_BE10,A2
  MOVEA.l $0(A2,D6.W),A2
  MOVEA.l (A2),A2
  MOVEA.l #comStr_SourceFileComplete,A0
  TST.b (A1)
  BEQ.w JL_0_BDEE

  JL_0_BDDA:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_BDDA

  SUBQ.w #1,A0
  CMPI.b #":",-$1(A0)
  BEQ.w JL_0_BDEE
  MOVE.b #$2F,(A0)+    ; add a "/" if no ":" found

  JL_0_BDEE:
    MOVE.b (A2)+,(A0)+
  BNE.b JL_0_BDEE

  MOVE.l #comStr_SourceFileComplete,D7
  MOVE.l D6,-(A7)
  JSR load_source
  MOVE.l (A7)+,D6
  JSR get_remembered_filename
  JSR analyze_loadedsource
  JSR update_statusline
RTS


ptr_historyfilelist:  Ds.l 1
AL_0_BE10:            Dc.l AL_0_BFE6
AL_0_BE14:            Dc.l AL_0_BFFA
AL_0_BE18:            Dc.l AL_0_C00E
AL_0_BE1C:            Dc.l AL_0_C022
AL_0_BE20:            Dc.l AL_0_C036
AL_0_BE24:            Dc.l AL_0_BE38
AL_0_BE28:            Dc.l AL_0_BE3C
AL_0_BE2C:            Dc.l AL_0_BE40
AL_0_BE30:            Dc.l AL_0_BE44
AL_0_BE34:            Dc.l AL_0_BE48
AL_0_BE38:            Ds.l 1
AL_0_BE3C:            Ds.l 1
AL_0_BE40:            Ds.l 1
AL_0_BE44:            Ds.l 1
AL_0_BE48:            Ds.l 1
                      Dc.b "tEdMeNuS"

; -- string pointers to the menuitems for source history
; thilo's attempt to make this flexible, but the code is such a f****** mess that I gave up!
;#MENU_MAXLASTSOURCES = 10
;LastSourceList:       Ds.l #MENU_MAXLASTSOURCES
AL_0_BFE6:            Ds.l 1
AL_0_BFFA:            Ds.l 1
AL_0_C00E:            Ds.l 1
AL_0_C022:            Ds.l 1
AL_0_C036:            Ds.l 1
addr_menustrip:       Ds.l 1
                      Dc.b "tEdMeNuS oK!"


.kill_menus
  If Peek.l(Addr GTMenuList(0))<>0
    If *sourcewin<>0 Then ClearMenuStrip_ *sourcewin
    If WZ_CheckOpen{"WIN_NEWTYPE"} Then Use Window WZID("WIN_NEWTYPE") : ClearMenuStrip_ WZWindowAddr
    If WZ_CheckOpen{"WIN_LABELS"} Then Use Window WZID("WIN_INSTRUCTIONWINDOW"): ClearMenuStrip_ WZWindowAddr
    Free GTMenuList 0
  EndIf
Return


.init_menus
  Gosub kill_menus
  GTMenuTitle    0,0,   !TRANS{"Project"                     }
   GTMenuItem  0,0,0, 0,!TRANS{"Project Settings"            },"M"         ,0,#MENU_PROJECTSETTINGS
   GTMenuItem  0,0,0, 1,!TRANS{"IDE Preferences"             },""          ,0,#MENU_IDEPREFERENCES
   GTMenuItem  0,0,0, 2
   GTMenuItem  0,0,0, 3,!TRANS{"Open WB"                     },""          ,0,#MENU_OPENWORKBENCH
   GTMenuItem  0,0,0, 4,!TRANS{"Close WB"                    },""          ,0,#MENU_CLOSEWORKBENCH
   GTMenuItem  0,0,0, 5,!TRANS{"Open Shell"                  },""          ,0,#MENU_OPENSHELL
   GTMenuItem  0,0,0, 6,!TRANS{"Calculator"                  },""          ,0,#MENU_CALCULATOR
   GTMenuItem  0,0,0, 7
   GTMenuItem  0,0,0, 8,!TRANS{"About AmiBlitz3"             },""          ,0,#MENU_ABOUT
   GTMenuItem  0,0,0, 9
   GTMenuItem  0,0,0,10,!TRANS{"Iconify"                     },""          ,0,#MENU_ICONIFY
   GTMenuItem  0,0,0,11,!TRANS{"Quit"                        },"Q"         ,0,#MENU_QUIT

  GTMenuTitle    0,1,   !TRANS{"Source File"                 }
   GTMenuItem  0,0,1, 0,!TRANS{"New..."                      },""          ,0,#MENU_NEW
   ; -- scan for any templates
   ClearList templates()
   templatepath.s = dos_AddPart{sourcedir$ , "Templates"}
   *root.ml_node  = ml_AddPathNode{0,templatepath.s,"#?.(bb2|ab2|ab3|asc)"}
   *node.ml_node  = *root
   templates.w    = 0
   While *node><0 AND templates < #MAX_TEMPLATES
     fil.s = ml_GetUserString{*node}
     If dos_IsDir{fil} = False
        mtitle.s = Replace$(dos_RemExt{dos_FilePart{fil}},"_"," ")
        shortc.l = #MENU_TEMPLATE + templates
        GTSubItem  0,0,1, 0,templates,mtitle.s                    ,""          ,0,shortc
        If AddLast(templates()) Then templates()\filename = fil
        templates + 1
     End If
     *node = ml_GetNextNode{*node}
   Wend
   ml_RemoveAllNodes{*root}
   GTMenuItem  0,0,1, 1,!TRANS{"Open"                        },"O"         ,0,#MENU_OPEN
   GTMenuItem  0,0,1, 2,!TRANS{"Open New"                    },""          ,0,#MENU_OPENNEW
   GTMenuItem  0,0,1, 3,!TRANS{"Include File"                },"I"         ,0,#MENU_INCLUDEFILE
   GTMenuItem  0,0,1, 4
   GTMenuItem  0,0,1, 5,!TRANS{"Save"                        },"S"         ,0,#MENU_SAVE
   GTMenuItem  0,0,1, 6,!TRANS{"Save As..."                  },"A"         ,0,#MENU_SAVEAS
;  GTMenuItem  0,0,1, 7,!TRANS{"Export ASCII As..."          },""          ,0,#MENU_EXPORTASCII
   GTMenuItem  0,0,1, 7
   GTMenuItem  0,0,1, 8,!TRANS{"Print..."                    },""          ,0,#MENU_PRINT
   GTMenuItem  0,0,1, 9
   GTMenuItem  0,0,1,10,!TRANS{"Close"                       },""          ,0,#MENU_CLOSE
   If Peek.w(?remember_saved)
     GTMenuItem  0,0,1,11
     ; thilo's attempt to make this flexible, but the code is such a f****** mess that I gave up!
     ;For m.l=0 To #MENU_MAXLASTSOURCES-1
     ;  itemP.l = Peek.l(?LastSourceList + SizeOf.l*m)
     ;  If itemP Then itemT.s = Peek.s(itemP) : Else itemP = "-"
     ;  If m<5 Then short.s = Str$(m+1) : Else short=""
     ;  GTMenuItem  0,0,1,12+m,itemT,short,0,#MENU_LASTSOURCE1+m
     ;Next
     GTMenuItem  0,0,1,12,Peek$(Peek.l(?AL_0_BFE6))             ,"1"         ,0,#MENU_LASTSOURCE1
     GTMenuItem  0,0,1,13,Peek$(Peek.l(?AL_0_BFFA))             ,"2"         ,0,#MENU_LASTSOURCE2
     GTMenuItem  0,0,1,14,Peek$(Peek.l(?AL_0_C00E))             ,"3"         ,0,#MENU_LASTSOURCE3
     GTMenuItem  0,0,1,15,Peek$(Peek.l(?AL_0_C022))             ,"4"         ,0,#MENU_LASTSOURCE4
     GTMenuItem  0,0,1,16,Peek$(Peek.l(?AL_0_C036))             ,"5"         ,0,#MENU_LASTSOURCE5
   EndIf


  GTMenuTitle    0,2,   !TRANS{"Edit"                        }
   GTMenuItem  0,0,2, 0,!TRANS{"Cut"                         },"X"         ,0,#MENU_CUT
   GTMenuItem  0,0,2, 1,!TRANS{"Copy"                        },"C"         ,0,#MENU_COPY
   GTMenuItem  0,0,2, 2,!TRANS{"Paste"                       },"V"         ,0,#MENU_PASTE
   GTMenuItem  0,0,2, 3,!TRANS{"Duplicate"                   },"Z"         ,0,#MENU_DUPLICATE
   GTMenuItem  0,0,2, 4,!TRANS{"Forget"                      },"W"         ,0,#MENU_FORGET
   GTMenuItem  0,0,2, 5,!TRANS{"Kill"                        },"K"         ,0,#MENU_KILL
   GTMenuItem  0,0,2, 6,!TRANS{"Save Block As..."            },""          ,0,#MENU_SAVEBLOCKAS
   GTMenuItem  0,0,2, 7
   GTMenuItem  0,0,2, 8,!TRANS{"Insert Line"                 },""          ,0,#MENU_INSERTLINE
   GTMenuItem  0,0,2,09,!TRANS{"Delete Line"                 },"D"         ,0,#MENU_DELETELINE
   GTMenuItem  0,0,2,10,!TRANS{"Undelete Line"               },"U"         ,0,#MENU_UNDELETELINE
   GTMenuItem  0,0,2,11,!TRANS{"Join Lines"                  },"J"         ,0,#MENU_JOINLINES
   GTMenuItem  0,0,2,12,!TRANS{"Delete to EOL"               },"Y"         ,0,#MENU_DELETETOEOL
   GTMenuItem  0,0,2,13
   GTMenuItem  0,4,2,14,!TRANS{"Block Tab"                   },"CTRL+Right",0,#MENU_BLOCKTAB
   GTMenuItem  0,4,2,15,!TRANS{"Block Untab"                 },"CTRL+Left" ,0,#MENU_BLOCKUNTAB
   GTMenuItem  0,0,2,16,!TRANS{"Block Comment"               },"{"         ,0,#MENU_BLOCKCOMMENT
   GTMenuItem  0,0,2,17,!TRANS{"Block Uncomment"             },"}"         ,0,#MENU_BLOCKUNCOMMENT
   GTMenuItem  0,0,2,18,!TRANS{"Mark Indent"                 },""          ,0,#MENU_MARKINDENT
   GTMenuItem  0,0,2,19,!TRANS{"Insert Filename"             },""          ,0,#MENU_INSERTFILENAME
   GTMenuItem  0,0,2,20,!TRANS{"Open Filename Under Cursor"  },""          ,0,#MENU_OPENFILEUNDERCURSOR



  GTMenuTitle    0,3,   !TRANS{"Navigation"                  }
   GTMenuItem  0,0,3, 0,!TRANS{"Find..."                     },"F"         ,0,#MENU_OPENFIND
   GTMenuItem  0,0,3, 1,!TRANS{"Find Next"                   },"N"         ,0,#MENU_FIND
   GTMenuItem  0,0,3, 2,!TRANS{"Find Previous"               },"P"         ,0,#MENU_PREVIOUS
   GTMenuItem  0,0,3, 3,!TRANS{"Replace & Find"              },"R"         ,0,#MENU_REPLACE
   GTMenuItem  0,0,3, 4
   GTMenuItem  0,4,3, 5,!TRANS{"Top"                         },"CTRL+Up"   ,0,#MENU_TOP
   GTMenuItem  0,4,3, 6,!TRANS{"Bottom"                      },"CTRL+Down" ,0,#MENU_BOTTOM
   GTMenuItem  0,0,3, 7,!TRANS{"Goto Line..."                },"G"         ,0,#MENU_GOTOLINE
   GTMenuItem  0,0,3, 8
   GTMenuItem  0,4,3,09,!TRANS{"Previous Page"               },"F9"        ,0,#MENU_PREVPAGE
   GTMenuItem  0,4,3,10,!TRANS{"Next Page"                   },"F10"       ,0,#MENU_NEXTPAGE


  GTMenuTitle    0,4,   !TRANS{"Compiler"                    }
   GTMenuItem  0,0,4, 0,!TRANS{"Compile & Run"               },"#"         ,0,#MENU_COMPILERUN
   GTMenuItem  0,0,4, 1,!TRANS{"Save & Compile & Run"        },"B"         ,0,#MENU_SAVECOMPILERUN
   GTMenuItem  0,0,4, 2,!TRANS{"Run"                         },""          ,0,#MENU_RUN
   GTMenuItem  0,0,4, 3,!TRANS{"Create Executable..."        },"E"         ,0,#MENU_CREATEEXE
   GTMenuItem  0,0,4, 4,!TRANS{"Save & Create Executable"    },"T"         ,0,#MENU_SAVECREATEEXE
   GTMenuItem  0,0,4, 5,!TRANS{"Create minimized Executable" },""          ,0,#MENU_CREATERELEASEEXE
   GTMenuItem  0,0,4, 6,!TRANS{"Create Resident..."          },""          ,0,#MENU_CREATERESIDENT
   GTMenuItem  0,0,4, 7
   GTMenuItem  0,0,4, 8,!TRANS{"Set CLI Arguments"           },""          ,0,#MENU_SETCLIARGS
   GTMenuItem  0,0,4, 9,!TRANS{"Reload Blitzlibs"            },"\"         ,0,#MENU_RELOADBLITZLIBS
   GTMenuItem  0,0,4,10
   GTMenuItem  0,0,4,11,!TRANS{"Compiler Settings"           },""          ,0,#MENU_COMPILERSETTINGS
   GTMenuItem  0,1,4,12,!TRANS{"Create Debug Code"           },""          ,0,#MENU_CREATEDEBUGCODE


  GTMenuTitle    0,5,   !TRANS{"Help"                        }
   GTMenuItem  0,0,5, 0,!TRANS{"What's New?"                 },""          ,0,#MENU_WHATSNEW
   GTMenuItem  0,0,5, 1
   GTMenuItem  0,0,5, 2,!TRANS{"General AB3 Guide"           },""          ,0,#MENU_GENERALGUIDE
   GTMenuItem  0,0,5, 3,!TRANS{"Programming in Blitz"        },""          ,0,#MENU_PROGRAMGUIDE
   GTMenuItem  0,0,5, 4,!TRANS{"Includes Guide"              },""          ,0,#MENU_INCLUDEGUIDE
   GTMenuItem  0,0,5, 5,!TRANS{"Blitzlibs Guide"             },""          ,0,#MENU_BLITZLIBSGUIDE
   GTMenuItem  0,0,5, 6,!TRANS{"Shortcuts Reference"         },""          ,0,#MENU_SHORTCUTREFERENCE
   GTMenuItem  0,0,5, 7
   GTMenuItem  0,0,5, 8,!TRANS{"Instruction Browser"         },""          ,0,#MENU_INSTRUCTIONBROWSER
   GTMenuItem  0,0,5, 9,!TRANS{"Source Browser"              },""          ,0,#MENU_SOURCEBROWSER
   GTMenuItem  0,0,5,10,!TRANS{"Definition Browser"          },""          ,0,#MENU_DEFINITIONBROWSER
   GTMenuItem  0,0,5,11,!TRANS{"Library Browser"             },""          ,0,#MENU_LIBRARYBROWSER
   GTMenuItem  0,0,5,12
   GTMenuItem  0,0,5,13,!TRANS{"Update Instruction Index"    },""          ,0,#MENU_UPDATEHELPINDEX

  Gosub load_custommenus
  If LastItem(custommenu())
    GTMenuTitle 0,6,"Custom"
    If FirstItem(custommenu())
      menuentry = 0
      Repeat
        If custommenu()\itemname = "~"
          GTMenuItem 0,0,6,menuentry
        Else
          shortc = #MENU_CUSTOM+menuentry
          GTMenuItem 0,0,6,menuentry,custommenu()\itemname,"",0,shortc
        EndIf
        menuentry + 1
      Until NOT NextItem(custommenu())
    EndIf
  EndIf

  CreateMenuStrip 0
  ;If templates = 0 Then GTMenuState 0,1,0,Off
  If Peek.l(Addr GTMenuList(0))<>0
    Poke.l ?addr_menustrip,Peek.l(Addr GTMenuList(0))

    If *sourcewin<>0               Then SetMenuStrip_ *sourcewin,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_NEWTYPE"} Then Use Window WZID("WIN_NEWTYPE") : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_LABELS"}  Then Use Window WZID("WIN_INSTRUCTIONWINDOW"): SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
  EndIf
Return

.load_custommenus:
  If dos_Exist{tedmenufile$}
    fid.l = file_Open{tedmenufile$,#file_read}
    If fid>=0
      ClearList custommenu()
      While file_EOF{fid} = False
        textline.s = file_ReadLine{fid}
        If textline<>"" AND AddLast(custommenu())
          InitArgParse textline
          custommenu()\itemname = NextArgChar$(@",")
          custommenu()\shortcut = NextArgChar$(@",")
          custommenu()\id = Vallong(NextArgChar$(@","))
          custommenu()\command = NextArgChar$(@",")
        EndIf
      Wend
      file_Close{fid}
    End If
  EndIf
Return


Even
.menutable:
;   $5A: Leerzeile im Menu
;   $50: Compile & Run
;   $5b: Save & Create Exec
;   $5c: Save & Compile & Run
;   $5d: Debug / Runerrors On 10*slower Code
;   $5e: Create Executable absolut Smallest

;   $56: CLI arguments
;   $57: calculator
;   $58: reload all libs
;   $59: open sourcebrowser

  Ds.w 1
  Dc.b $00,$65,$00,$00
  Ds.w 1
  Dc.l menu_opennew                   ;new

  Ds.w 1
  Dc.b $00,$66,$00,$00
  Ds.w 1
  Dc.l menu_openload                  ;open new and load

  Ds.w 1
  Dc.b $00,$67,$00,$00
  Dc.b $00,$01
  Dc.l menu_load                      ;load

  Ds.w 1
  Dc.b $00,$68,$00,$00
  Dc.b $00,$01
  Dc.l menu_includeblock              ;include block

  Ds.w 1
  Dc.b $00,$69,$00,$00
  Ds.w 1
  Dc.l menu_save                      ;save

  Ds.w 1
  Dc.b $00,$6A,$00,$00
  Ds.w 1
  Dc.l menu_saveas                    ;save as

  Ds.w 1
  Dc.b $00,$6B,$00,$00
  Ds.w 1
  Dc.l menu_saveascii                 ;save ascii

  Ds.w 1
  Dc.b $00,$6C,$00,$00
  Ds.w 1
  Dc.l menu_quit                      ;quit

  Ds.w 1
  Dc.b $00,$6D,$00,$00
  Ds.w 1
  Dc.l menu_quitall                   ;quitall

  Ds.w 1
  Dc.b $00,$6E,$00,$00
  Ds.w 1
  Dc.l menu_print                     ;print

  Ds.w 1
  Dc.b $00,$6F,$00,$00
  Ds.w 1
  Dc.l menu_openwb                    ;openwb

  Ds.w 1
  Dc.b $00,$70,$00,$00
  Ds.w 1
  Dc.l menu_closewb                   ;closewb

  Ds.w 1
  Dc.b $00,$71,$00,$00
  Ds.w 1
  Dc.l menu_iconify                   ;iconify

  Ds.w 1
  Dc.b $00,$72,$00,$00
  Ds.w 1
  Dc.l menu_newshell                  ;newcli

  Ds.w 1
  Dc.b $00,$73,$00,$00
  Ds.w 1
  Dc.l menu_prefs                     ;prefs

  Ds.w 1
  Dc.b $00,$74,$00,$00
  Ds.w 1
  Dc.l menu_about                     ; about

  Ds.w 1
  ;
  Dc.b $00,$78,$00,$00                ; remembered sources
  Dc.b $00,$01
  Dc.l load_remembered

  Ds.w 1
  Dc.b $00,$79,$00,$00
  Dc.b $00,$01
  Dc.l load_remembered

  Ds.w 1
  Dc.b $00,$7A,$00,$00
  Dc.b $00,$01
  Dc.l load_remembered

  Ds.w 1
  Dc.b $00,$7B,$00,$00
  Dc.b $00,$01
  Dc.l load_remembered

  Ds.w 1
  Dc.b $00,$7C,$00,$00
  Dc.b $00,$01
  Dc.l load_remembered

  Ds.w 1
  ; -- MENU SOURCE
  Dc.b $00,$C9,$00,$00
  Dc.b $00,$01
  Dc.l menu_cut

  Ds.w 1
  Dc.b $00,$CA,$00,$00
  Dc.b $00,$01
  Dc.l menu_copy

  Ds.w 1
  Dc.b $00,$CB,$00,$00
  Dc.b $00,$01
  Dc.l menu_paste

  Ds.w 1
  Dc.b $00,$D8,$00,$00
  Dc.b $00,$01
  Dc.l menu_dublicate

  Ds.w 1
  Dc.b $00,$CC,$00,$00
  Dc.b $00,$01
  Dc.l menu_forget

  Ds.w 1
  Dc.b $00,$D7,$00,$00
  Dc.b $00,$01
  Dc.l menu_kill

  Ds.w 1
  Dc.b $00,$CD,$00,$00
  Dc.b $00,$01
  Dc.l menu_saveblockas

  Ds.w 1
  Dc.b $00,$CE,$00,$00
  Ds.w 1
  Dc.l menu_insertline

  Ds.w 1
  Dc.b $00,$CF,$00,$00
  Ds.w 1
  Dc.l menu_deleteline

  Ds.w 1
  Dc.b $00,$D0,$00,$00
  Ds.w 1
  Dc.l menu_undeleteline            ; undelete

  Ds.w 1
  Dc.b $00,$D1,$00,$00
  Ds.w 1
  Dc.l menu_joinline                ; join

  Ds.w 1
  Dc.b $00,$D2,$00,$00
  Dc.b $00,$01
  Dc.l menu_blocktab                ; block Tab

  Ds.w 1
  Dc.b $00,$D3,$00,$00
  Dc.b $00,$01
  Dc.l menu_blockuntab              ; block untab

  Ds.w 1
  Dc.b $00,$D4,$00,$00
  Dc.b $00,$01
  Dc.l menu_blockcomment            ; block comment

  Ds.w 1
  Dc.b $00,$D5,$00,$00
  Dc.b $00,$01
  Dc.l menu_blockuncomment

  Ds.w 1
  Dc.b $00,$D6,$00,$00
  Dc.b $00,$01
  Dc.l menu_markindent

  Ds.w 1
  Dc.b $01,$32,$00,$00
  Ds.w 1
  Dc.l menu_project

  Ds.w 1
  Dc.b $01,$2D,$00,$00
  Dc.b $00,$01
  Dc.l menu_top

  Ds.w 1
  Dc.b $01,$2E,$00,$00
  Dc.b $00,$01
  Dc.l menu_bottom

  Ds.w 1
  Dc.b $01,$2F,$00,$00
  Dc.b $00,$01
  Dc.l menu_gotoline

  Ds.w 1
  Dc.b $01,$30,$00,$00
  Ds.w 1
  Dc.l menu_previousfile

  Ds.w 1
  Dc.b $01,$31,$00,$00
  Ds.w 1
  Dc.l menu_nextfile

  Ds.w 1
  Dc.b $01,$91,$00,$00
  Dc.b $00,$01
  Dc.l menu_find

  Ds.w 1
  Dc.b $01,$92,$00,$00
  Dc.b $00,$01
  Dc.l menu_findnext

  Ds.w 1
  Dc.b $01,$93,$00,$00
  Dc.b $00,$01
  Dc.l menu_previous

  Ds.w 1
  Dc.b $01,$94,$00,$00
  Dc.b $00,$01
  Dc.l menu_replace

  Ds.w 1
  Dc.b $01,$F0,$00,$00
  Dc.w 1
  Dc.l menu_helpnews

  Ds.w 1
  Dc.b $01,$F1,$00,$00
  Dc.w 1
  Dc.l menu_helpgeneral

  Ds.w 1
  Dc.b $01,$F2,$00,$00
  Dc.w 1
  Dc.l menu_helpprogramming

  Ds.w 1
  Dc.b $01,$F3,$00,$00
  Dc.w 1
  Dc.l menu_helpblitzlibs

  Ds.w 1
  Dc.b $01,$F4,$00,$00
  Dc.w 1
  Dc.l menu_helpincludesguide ;syntax

  Ds.w 1
  Dc.b $01,$F5,$00,$00
  Dc.w 1
  Dc.l menu_helpcompletion

  Ds.w 1
  Dc.b $01,$F6,$00,$00
  Dc.w 1
  Dc.l menu_helpshortcuts

  Ds.w 1
  Dc.b $01,$F7,$00,$00
  Dc.w 1
  Dc.l menu_helplibrarybrowser

  Ds.w 1
  Dc.b $01,$F8,$00,$00
  Dc.w 1
  Dc.l menu_helpbuildindex

  ; end of menutable
  Dc.b $FF,$FF,$FF,$FF
Even


;.taglist_NewScreen:
;  Dc.l  #SA_Width
;  _screenwidth:
;  Ds.w 1
;  screen_GetWidth2:
;  Ds.w 1
;
;  Dc.l #SA_Height
;  _screenheight:
;  Ds.w 1
;  screen_GetHeight2:
;  Ds.w 1
;
;  Dc.l #SA_DisplayID
;  screen_modeid:
;  Ds.l 1
;
;  Dc.l #SA_Depth
;  screendepth:
;  Ds.w 1
;  screen_GetDepth2:
;  Dc.b $00,$02
;
;  Dc.l #SA_Title
;  str_windowtitle:
;  Ds.l 1
;
;  Dc.l #SA_Type
;  screentype:
;  Ds.w 1
;  screen_type:
;  Dc.b $00,$0F
;
;  Dc.l #SA_AutoScroll
;  screen_autoscroll:
;  Dc.l 1
;
;  Dc.l #SA_Pens
;  Dc.l AL_0_D1BE
;
;  tagitem_Font:
;  Dc.l #SA_Font
;  screen_font:
;  Dc.l struct_textfont
;
;  Dc.l #SA_Interleaved
;  Dc.b $ff,$ff
;  Dc.b $ff,$ff
;
;
;  tagitem_PubScreen:
;  Dc.l #SA_PubName
;  Dc.l str_defaultpubscreen
;
;  Dc.l #SA_FullPalette
;  Dc.l $ffffffff
;  Ds.l 2
;
;AL_0_D1BE:
;Dc.b $FF,$FF
;
;
;

.struct_textfont:
                         Ds.l 1
  textfont_YSize:
                         Dc.b $00,$08
  textfont_Style:
                         Dc.b $00
  textfont_Flags:
                         Dc.b $00
                         Ds.l 2
  L_0_D1D0:
                         Ds.l 2
                         Dc.b $FF,$FF,$00,$00
                         Ds.w 1
                         Dc.b $00,$20,$09,$00
                         Ds.l 7
                         Dc.b $00,$0F

Even

str_unable_screen:
                         Dc.b "Unable to open screen!",0 : Even
str_unable_window:
                         Dc.b "Unable to open window!",0 : Even
str_no_asl_library:
                         Dc.b "Unable to open asl.library V36 or newer",0 : Even
str_no_clipboard_device:
                         Dc.b "Unable to open clipboard.device",0 : Even
Even


easystruct_closescreen:
                         Ds.w 1
                         Dc.b $00,$14,$00,$00
                         Ds.w 1
  AL_0_D3D0:             Dc.l AL_0_D3Dca
  AL_0_D3D4:             Dc.l AL_0_D3EA
  AL_0_D3D8:             Dc.l AL_0_D430

  AL_0_D3Dca:            Dc.b "Public Screen",0 : Even
  AL_0_D3EA:             Dc.b "I'm attempting to close my screen.",10,"Please close all visitor windows.",0 : Even
  AL_0_D430:             Dc.b "Retry",0 :Even


easystruct_saveas:
                          Ds.w 1
                          Dc.b $00,$14,$00,$00
                          Ds.w 1
  AL_0_D43E:              Dc.l AL_0_D44A
  AL_0_D442:              Dc.l AL_0_D45A
  AL_0_D446:              Dc.l AL_0_D47A

  AL_0_D44A:              Dc.b "Save File As...",0 : Even
  AL_0_D45A:              Dc.b "File already exists!",0 : Even
  AL_0_D47A:              Dc.b "Overwrite|Cancel",0 : Even


easystruct_error:
                          Ds.w 1
                          Dc.b $00,$14,$00,$00
                          Ds.w 1
  ptr_errortitle:         Dc.l AL_0_D5E8        ; Title
  ptr_errortext:          Ds.l 1                ; Text
                          Dc.l AL_0_D5F0        ; Gadget

  AL_0_D5E8:              Dc.b "Error!",0 : Even
  AL_0_D5F0:              Dc.b "Ok",0 : Even


easystruct_loosewarning:
                          Ds.w 1
                          Dc.b $00,$14,$00,$00
                          Ds.w 1
  AL_0_D5FE:              Dc.l str_newfile_req
  AL_0_D602:              Dc.l AL_0_D614
  AL_0_D606:              Dc.l AL_0_D63C


str_newfile_req:          Dc.b "New File ",0 : Even                     ; added a space to the string because the code at label "load_menu" copy the string "Load File" in to avoid a overwrite
  AL_0_D614:              Dc.b "This will erase altered file!",0 : Even
  AL_0_D63C:              Dc.b "Continue|Cancel",0 : Even

;str_memoryalert:
;                          Dc.b $00,$38
;                          Dc.b $16
;                          Dc.b "Not enough memory for operation! - Click Mouse Button to Continue.",0,0
;                          Dc.b $00
Even

AL_0_D68E:                Dc.b "topaz.font",0 : Even
topaz_font:               Dc.l AL_0_D68E
                          Dc.b $00,$08,$00,$00
str_unnamed:              Dc.b "<unnamed>",0 : Even
Even
str_printerdevice:        Dc.b "PRT:",0 : Even
                          Ds.w 29
Even
str_Arexx_PortName:       Dc.b "TED_"
str_Arexx_availability:   Dc.b "REXX"
str_Arexx_portnumber:     Dc.b $31
                          Dc.b $00,$20,$0A
str_label_publicscreen:   Dc.b "Public Screen : "
str_defaultpubscreen:     Dc.b "AmiBlitz3_"
screen_number:            Dc.b 0,0,0
                          Dc.b $00
Even
str_windowtitle:          Ds.l 1
struct_MsgPort:           Ds.l 1
ptr_tempstring:           Ds.l 1


.compare_strings:                  ; compare string in A1/A3     (AJL_0_DD12)
  MOVEQ.l #$00,D0
  MOVEQ.l #$00,D1
  MOVEM.l A1/A3,-(A7)

  JL_0_DD1A:
    MOVE.b (A1)+,D2
    MOVE.b (A3)+,D3
    CMP.b #$20,D2
     BNE.w JL_0_DD2C
    TST.b D3
     BEQ.w JL_0_DD4C

    JL_0_DD2C:
    TST.b D2
     BNE.w JL_0_DD38
    TST.b D3
     BEQ.w JL_0_DD4C

    JL_0_DD38:
    BSET #$5,D2
    BSET #$5,D3
    CMP.b D2,D3
  BEQ.b JL_0_DD1A

  MOVEM.l (A7)+,A1/A3
  MOVEQ.l #$00,D0
  RTS

  JL_0_DD4C:
  MOVEM.l (A7)+,A1/A3
  MOVEQ.l #-$01,D0          ; string not equal
RTS


.menu_project:
  JSR StoreXtraData
  !basic
  If NOT WZ_CheckOpen{"WIN_PROJECT"}
    WZWindow WZID("WIN_PROJECT"),0,192,-2,-2,-2,-2,WZID("WIN_PROJECT")
    Use Window WZID("WIN_PROJECT")
    WZ_InitTable{"WIN_PROJECT","PROJECTTABLE",2}
    WZ_SetTableTitle{"PROJECTTABLE","File","Category"}
    WZ_SetTableColors{"PROJECTTABLE",1,0,1,0}
    WZ_SetPriority{"PROJECTTABLE",3,1}
    WZ_SetSortable{"PROJECTTABLE",Off}
    project_tab.b = WZInput("PROJECT_TABS")
    Gosub update_versiongadgets
  EndIf

  MaxLen lf$=64
  MaxLen pa$=64
  DEFTYPE.l *ptr_filename
  MOVE.l actualfile,D0 : *ptr_filename.l = PutD0
  actual_file$ = Peek.s(*ptr_filename + $DE)
  actual_drawer$ = Peek.s(?comStr_CurrentDir)

  If project_tab = 1
    WZ_DrawTable{"PROJECTTABLE"}
    Gosub project_updatesourcelist
  EndIf

  exit_project.b = False
  Repeat
    !ev_WaitEvent
    Select ev
    Case #IDCMP_IDCMPUPDATE
      Select WZGadName
      Case "PROJECT_TABS"
        project_tab.b = WZInput("PROJECT_TABS")
        If project_tab = 1
          WZ_DrawTable{"PROJECTTABLE"}
          Gosub project_updatesourcelist
        EndIf

      Case "PROJECT_NAME"
        ab2_project\name = WZInputstr

      Case "PROJECT_DRAWER"
        ab2_project\drawer = WZInputstr

      Case "PROJECT_VERSION"
        ab2_project\version = WZInput

      Case "PROJECT_REVISION"
        ab2_project\revision = WZInput


      Case "PROJECT_CREATE"
        If ab2_project\name<>""
          If RTEZRequest(!TRANS{"Create Project"},!TRANS{"The current project and its files will be closed,\\nand all source files will be saved."},!TRANS{"_Ok|_Cancel"})
            WZ_ClearTable{"PROJECTTABLE"}
            WZ_UpdateTable{"PROJECTTABLE"}
            Gosub project_closeallfiles
            ClearType ab2_project
            Gosub project_updatesourcelist
            ActivateGadget_ WZGadAddr("PROJECT_NAME"),WZWindowAddr,0
          EndIf
        Else
          dummy = RTEZRequest(!TRANS{"Create Project"},!TRANS{"Illegal Projectname"},"_Ok")
        EndIf

      Case "PROJECT_LOAD"
        RTEZSetPattern 0,"(#?.a2p)"
        lf$ = RTEZLoadFile(!TRANS{"Choose Project"},lf$)
        If Exists(lf$)>0
          Gosub project_load
          If ab2_project\sourcecounter > 0
            For pc.l = 1 To ab2_project\sourcecounter
              fext$ = dos_GetExt{ab2_project\sourcefile[pc]}
              If fext$="ab2" OR fext$="bb2" OR fext$="bb"
                sourcefile$ = ab2_project\sourcepath[pc]+ab2_project\sourcefile[pc]
                GetD0 &sourcefile$
                !asm
                JSR loadfile
                !basic
              EndIf
            Next pc
            JSR activatesource
            Gosub project_updatesourcelist
            Use Window WZID("WIN_PROJECT")
            WindowToFront_ WZWindowAddr
          EndIf
        Else
          If lf$ <> "" Then dummy = RTEZRequest("",!TRANS{"This project does not exist."},"_Ok")
        EndIf

      Case "PROJECT_SAVE"
        ab2_project\name = WZGetString("PROJECT_NAME")
        ab2_project\drawer = WZGetString("PROJECT_DRAWER")
        If ab2_project\name <> ""
          Gosub project_save
        Else
          dummy = RTEZRequest("",!TRANS{"Illegal Projectname"},"_Ok")
        EndIf

      Case "PROJECT_ADDFILE"
        RTEZSetPattern 0,""
        RTEZSetDefaultDirectory 0,ab2_project\drawer
        actual_file$ = RTEZLoadFile("Add File",lf$)
        If Exists(actual_file$) > 0
          ab2_project\sourcecounter + 1
          ab2_project\sourcefile[ab2_project\sourcecounter] = dos_FilePart{actual_file$}

          Gosub project_loadfile
          actual_file$ = dos_FilePart{actual_file$}
          Gosub project_updatesourcelist
          Use Window WZID("WIN_PROJECT")
          WindowToFront_ WZWindowAddr
        Else
          If lf$<>"" Then dummy = RTEZRequest("",!TRANS{"This file does not exist."},"_Ok")
        EndIf

      Case "PROJECT_REMOVEFILE"
        actual_file$ = WZ_GetCell{"PROJECTTABLE",WZ_Row{"PROJECTTABLE"},1}
        For pc = 1 To ab2_project\sourcecounter
          If actual_file$ = ab2_project\sourcefile[pc]
            Gosub project_removefile
            ab2_project\sourcefile[pc] = ""
            ab2_project\sourcepath[pc] = ""
            Gosub project_sortsourcelist
            Gosub project_updatesourcelist
          EndIf
        Next pc
;        JSR activatesource
;        !asm
;        JSR menu_quit
;        !basic

; -- TAB Versionmanagement --

      Case "INTEGER_VER_MAJOR"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_MINOR"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_PATCH"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_BUILD"
        Gosub get_versiondata_from_gui

; -- TAB Changelog --

      Case "CHANGELOG_ADDENTRY"
        If Peek.l(?comPtr_VersionInformation) AND Peek.l(?comPtr_NumberOfBuilds)
          If (Peek.l(?comPtr_VersionInformation)<>0) AND (Peek.l(?comPtr_NumberOfBuilds )<>0)
            version_code.l = Peek.l(Peek.l(?comPtr_VersionInformation))
            anz_builds.l   = Peek.l(Peek.l(?comPtr_NumberOfBuilds))
            vercode$ = Str$(version_code LSR 24 )+"."
            vercode$ + Str$((version_code LSL 8) LSR 24 )+"."
            vercode$ + Str$((version_code LSL 16)LSR 24 )+" (build: "
            vercode$ + Str$(anz_builds)+")"
            changelog$ =  "V"+vercode$ + ":\\0a\\0a" + changelog$
            WZPrint "CHANGELOG_TEXTFIELD",&changelog$
          EndIf
        EndIf

      Case "CHANGELOG_TEXTFIELD"
        changelog$ = WZ_GetStringField{"CHANGELOG_TEXTFIELD"}

      End Select

   Case #IDCMP_VANILLAKEY
     Select EventCode
     Case $1B: exit_project = True
     End Select


    Case #IDCMP_CLOSEWINDOW
      exit_project = True
    End Select

    If project_tab = 1
      wev.l = WZ_CheckTableEvent{ev}
      If wev = #WZTABLEEVENT_DOUBLECLICK
        _sf$ = WZ_GetCell{"PROJECTTABLE",WZ_Row{"PROJECTTABLE"},1}
        If (_sf$<>actual_file$) AND (_sf$<>Peek.s(?str_unnamed))
          actual_file$ = _sf$
          Gosub project_loadfile
;        For pc = 1 To ab2_project\sourcecounter
;          t$ = ab2_project\sourcefile[pc]
;          If t$ = actual_source$ Then WZ_SetActiveRow{"PROJECTTABLE",pc}
;        Next pc
;        WZ_UpdateTable{"PROJECTTABLE"}
          Use Window WZID("WIN_PROJECT")
          WindowToFront_ WZWindowAddr
;        exit_project = True
        EndIf
      EndIf
    EndIf
  Until exit_project = True

  WZ_KillTable{"PROJECTTABLE"}
  WZCloseWindow WZID("WIN_PROJECT")
  ActivateWindow_(?ptr_sourcewindow)

  !asm
RTS

.project_sortsourcelist
  tempcounter.w = 0
  For i = 1 To #MAX_SOURCEFILES
    If ab2_project\sourcefile[i]<> ""
      tempcounter + 1
      tempproject$(tempcounter,0) = ab2_project\sourcefile[i]
      tempproject$(tempcounter,1) = ab2_project\sourcepath[i]
    EndIf
    ab2_project\sourcefile[i] = ""
    ab2_project\sourcepath[i] = ""
  Next i

  For i = 1 To tempcounter
    ab2_project\sourcefile[i] = tempproject$(i,0)
    ab2_project\sourcepath[i] = tempproject$(i,1)
  Next i
  ab2_project\sourcecounter = tempcounter
Return

.project_updatesourcelist:
  If project_tab = 1
    WZ_ClearTable{"PROJECTTABLE"}
    If ab2_project\sourcecounter > 0
      For pc = 1 To ab2_project\sourcecounter
        t$ = ab2_project\sourcefile[pc]
        If Instr(t$,".include") Then u$ = "Include" Else
        If Instr(t$,".bb2")     Then u$ = "AB2-Source" Else
        If Instr(t$,".ab2")     Then u$ = "AB2-Source" Else
        If Instr(t$,".ab3")     Then u$ = "AB3-Source" Else
        If Instr(t$,".bb")      Then u$ = "BB2-Source" Else
        If Instr(t$,".wizard")  Then u$ = "Wizard-GUI-File" Else u$ = dos_GetExt{t$}+" File"
        WZ_AddRow{"PROJECTTABLE",t$,u$}
        If t$ = actual_file$ Then WZ_SetActiveRow{"PROJECTTABLE",pc}
      Next pc
    EndIf
    WZ_UpdateTable{"PROJECTTABLE"}

    ab2p$ = ab2_project\name
    ab2d$ = ab2_project\drawer
    WZPrint "PROJECT_NAME",&ab2p$
    WZPrint "PROJECT_DRAWER",&ab2d$
;    WZPrint "PROJECT_VERSION",ab2_project\version
;    WZPrint "PROJECT_REVISION",ab2_project\revision
  EndIf
Return

.project_closeallfiles
  JSR activatesource
  !asm
  go_on_closing:
  JSR dummy_compilercall
  JSR clear_labellist
  JSR clear_actualsource
  MOVEA.l actualfile,A0
  JSR close_actualsource
  TST.l loadedfilesbase
  BNE.b go_on_closing
  exit_closing:
  !basic
  JSR activatesource
Return

.project_removefile:
  t$ = actual_file$
  If Instr(t$,".bb2")     OR Instr(t$,".ab2") OR Instr(t$,".ab3")     OR Instr(t$,".bb")
    Gosub project_loadfile
    !asm
    JSR menu_quit
    !basic
    MOVE.l actualfile,D0 : *ptr_filename = PutD0
    actual_file$ = Peek.s(*ptr_filename + $DE)
  EndIf
Return

.project_loadfile:
  t$ = actual_file$
  If Instr(t$,".bb2")     OR Instr(t$,".ab2")  OR Instr(t$,".ab3")    OR Instr(t$,".bb")
    GetD0 &actual_file$
    !asm
    JSR loadfile
    !basic
  EndIf
Return

.project_load
  If OpenFile(1,lf$)
    ClearType ab2_project
    ReadType 1,ab2_project
    CloseFile 1
  Else
    dummy = RTEZRequest("",!TRANS{"This project could not be loaded."},"_Ok")
  EndIf
Return

.project_save
  lf$ = ab2_project\name+".a2p"
  RTEZSetPattern 1,"(#?.a2p)"
  RTEZSetDefaultDirectory 1,ab2_project\drawer
  lf$ = RTEZSaveFile("Save Projectfile",lf$)
  If OpenFile(1,lf$)
    WriteType 1,ab2_project
    CloseFile 1
  Else
    dummy = RTEZRequest("",!TRANS{"The project could not be saved."},"_Ok")
  EndIf
Return

.get_versiondata_from_gui:
  If WZ_CheckOpen{"WIN_PROJECT"}
    If Peek.l(?comPtr_VersionInformation)
      version_code = WZInput("INTEGER_VER_MAJOR") LSL 24
      version_code + (WZInput("INTEGER_VER_MINOR") LSL 16)
      version_code + (WZInput("INTEGER_VER_PATCH") LSL 8)
      Poke.l Peek.l(?comPtr_VersionInformation),version_code

      Poke.l Peek.l(?comPtr_NumberOfBuilds), WZInput("INTEGER_VER_BUILD")
    EndIf
  EndIf
Return

.update_versiongadgets
  If Peek.l(?comPtr_VersionInformation) AND Peek.l(?comPtr_NumberOfBuilds)
    If (Peek.l(?comPtr_VersionInformation)<>0) AND (Peek.l(?comPtr_NumberOfBuilds)<>0)
      version_code.l = Peek.l(Peek.l(?comPtr_VersionInformation))
      anz_builds.l   = Peek.l(Peek.l(?comPtr_NumberOfBuilds))
      If WZ_CheckOpen{"WIN_PROJECT"}
        Use Window WZID("WIN_PROJECT")
        WZPrint "INTEGER_VER_MAJOR",version_code LSR 24
        WZPrint "INTEGER_VER_MINOR",(version_code LSL 8) LSR 24
        WZPrint "INTEGER_VER_PATCH",(version_code LSL 16)LSR 24
        WZPrint "INTEGER_VER_BUILD",anz_builds
        WZPrint "CHANGELOG_TEXTFIELD",&changelog$
      EndIf
    EndIf
  EndIf
Return



; --
; --      hier kommt u.a. die ganze AREXX geschichte
; --
.event_arexx:
  MOVE.l D0,struct_RexxMsg
  MOVEA.l D0,A0
  MOVE.l $A(A0),ptr_arexx_sendername

  MOVEA.l A0,A1
  MOVE.l $28(A1),ptr_arexx_commandstr
  CMPI.b #$7,$8(A0)
   BEQ.w ignore_arexx_message
  CMPI.b #$5,$8(A0)
   BEQ.w handle_arexx_message
  MOVEA.l A0,A1
  JSR _ReplyMsg(A6)
  RTS

  ignore_arexx_message:
  MOVE.l struct_RexxMsg,D0
  JSR free_RexxMsg
  RTS


  handle_arexx_message:
  SF checked_arexxcmd
  JSR cursor_off
  LEA ptr_arexxcmd_list,A2
  MOVEA.l (A2)+,A3
  MOVEA.l ptr_arexx_commandstr,A1

  JL_0_DF90:
    JSR compare_strings
    BNE.w command_found
    ADDQ.l #4,A2
    MOVEA.l (A2)+,A3
    CMPA.l #$0,A3
  BNE.b JL_0_DF90
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
  BRA.w arexx_answer_message

  command_found:
  MOVEA.l (A2),A0

  MOVEM.l D1-D7/A0-A3,-(A7)
  JSR arexx_count_parameters
  MOVEM.l (A7)+,D1-D7/A0-A3

  ; -- call the arexx-function
  L_0_DFBA:
  JSR (A0)
  JSR arexx_answer_message
JMP cursor_on


.get_strlength: ; A0: String, D0: returns length
  MOVEQ.l #-$01,D0

  JL_0_DFCA:
    ADDQ.l #1,D0
    TST.b (A0)+
  BNE.b JL_0_DFCA
RTS

.arexx_answer_message:
  TST.b checked_arexxcmd
   BNE.w exit_answerarexx

  MOVE.l D0,-(A7)           ; return code, geht unten in $20(A1)

  CMPA.l #$0,A0
   BEQ.w no_return_string

  MOVE.l A0,-(A7)
  BSR.b get_strlength
  MOVEA.l (A7)+,A0

  MOVEA.l _rexxsyslibbase,A6
  JSR _CreateArgstring(A6)            ; create the return string
  MOVEA.l D0,A0

  MOVE.l a0,-(a7)
;  !basic
;  MOVE.l (a7)+,d0 :  i.l = PutD0
;  !cout{"arexx-message wird beantwortet von ",Peek$(Peek.l(?ptr_arexx_sendername))}
;  !cout{"command:",Peek$(Peek.l(?ptr_arexx_commandstr))}
;  MOVE.l (a7),d0 : rc.l = PutD0
;  !cout{"rn_Result2: *",Peek$(i),"*  return code:",rc}
;  !asm

  no_return_string:
  MOVEA.l struct_RexxMsg,A1
  MOVE.l A0,$24(A1)                   ; AtrString -> rn_Result2
  MOVE.l (A7)+,$20(A1)                ; return code -> rm_Result1
  MOVE.b #NT_REPLYMSG,$8(A1)          ; Message has been replied -> ln_Type
  MOVEA.l _execbase,A6
  JSR _ReplyMsg(A6)
  MOVEQ.l #$00,D7

  exit_answerarexx:
RTS

.init_arexxport:
  MOVE.l #$10000,D1
  MOVE.l #$200,D0
  !newalloc;JSR _AllocVec(A6)         ;for arexxfunc_getword
  MOVE.l D0,ptr_tempstring

  ; -- search for any arexx-ports
  MOVEA.l _execbase,A6
  LEA str_REXX,A1
  JSR _FindPort(A6)
  TST.l D0
  BEQ.w no_arexx_port_available
  MOVE.l D0,ptr_arexxport

  ; -- search for amiblitz-arexxports and get the next free number
  JL_0_E032:
    LEA str_Arexx_PortName,A1
    JSR _FindPort(A6)
    TST.l D0
    BEQ.w JL_0_E054
    MOVE.b str_Arexx_portnumber,D1
    ADDQ.b #1,D1
    MOVE.b D1,str_Arexx_portnumber
    CMP.b #"9",D1
  BNE.b JL_0_E032

  JL_0_E054:
  MOVE.l #$1000,D0
  MOVE.l #$10000,D1
  !newalloc;JSR _AllocVec(A6)

  MOVEQ.l #$0F,D1
  LEA arexx_table,A1
  JL_0_E080:
    MOVE.l D0,(A1)+
    ADDI.l #$100,D0
  DBF D1,JL_0_E080

  ; -- try to open rexxsys.library for creating my own arexxports
  LEA str_libname_rexxsyslib,A1
  MOVEQ.l #$00,D0
  JSR _OpenLibrary(A6)
  MOVE.l D0,_rexxsyslibbase
  BEQ.w no_arexx_port_available

  JSR _CreateMsgPortA(A6)
  MOVE.l D0,struct_ArexxMsgPort
  BEQ.w no_arexx_port_available

  MOVEA.l D0,A1
  MOVE.b #"2",$9(A1)
  MOVE.l #str_Arexx_PortName,$A(A1)
  JSR _AddPort(A6)

  MOVEA.l struct_ArexxMsgPort,A0
  MOVE.b $F(A0),rexx_signalbits
  JL_0_E0CE:
    MOVEA.l struct_ArexxMsgPort,A0
    JSR _GetMsg(A6)
    TST.l D0
  BNE.b JL_0_E0CE
  MOVE.l #$FFFFFFFF,arexxport_available
  MOVE.l #$5445445F,str_Arexx_PortName     ; "TED_"
  MOVE.l #$52455858,str_Arexx_availability             ; "REXX"
  RTS

  no_arexx_port_available:
  MOVE.l #$4E2F4120,str_Arexx_PortName
  MOVE.l #$20202020,str_Arexx_availability             ; "N/A "
  MOVE.b #$20,str_Arexx_portnumber
  CLR.l arexxport_available
RTS


.close_arexxport:
  MOVEA.l _execbase,A6
  MOVEA.l ptr_tempstring,a1
  !newfree
  TST.l arexxport_available
   BEQ.w exit_closearexxport

  JSR clear_arexxtable
  JSR init_RexxMsg
  MOVEA.l struct_RexxMsg,A0
  MOVE.l #$9000000,$1C(A0)
  MOVE.l #str_Arexx_PortName,$28(A0)
  LEA str_REXX,A1
  JSR _FindPort(A6)
  TST.l D0
  BEQ.w JL_0_E192

  MOVEA.l D0,A0
  MOVEA.l struct_RexxMsg,A1
  JSR _PutMsg(A6)
  MOVEA.l struct_ArexxMsgPort,A0
  JSR _WaitPort(A6)
  MOVEA.l struct_ArexxMsgPort,A0
  JSR _GetMsg(A6)
  MOVEA.l struct_RexxMsg,A0
  MOVE.l #$0,$28(A0)

  JL_0_E192:
  MOVEA.l struct_ArexxMsgPort,A1
  JSR _RemPort(A6)
  MOVEA.l struct_ArexxMsgPort,A0
  JSR _DeleteMsgPort(A6)
  CLR.l struct_ArexxMsgPort

  exit_closearexxport:
RTS

.free_RexxMsg:
  MOVEM.l D1/A0-A1/A6,-(A7)
  MOVEA.l _execbase,A6
  MOVEA.l D0,A1
  MOVE.l #MinByteSgnd,D0
  JSR _FreeMem(A6)

  MOVEM.l (A7)+,D1/A0-A1/A6
RTS


.init_RexxMsg:
  CLR.l struct_RexxMsg
  MOVEA.l _execbase,A6
  MOVE.l #$10000,D1
  MOVE.l #MinByteSgnd,D0
  JSR _AllocMem(A6)

  MOVEA.l D0,A1
  TST.l d0
   BEQ.w JL_0_E21E
                                      ; set bits in RexxMsg
  MOVE.b #$5,$8(A1)                   ; rm_Node\ln_Type
  MOVE.b #$1,$9(A1)                   ; rm_Node\ln_Pri
  MOVE.l #str_Arexx_PortName,$A(A1)   ; rm_Node\ln_Name
  MOVE.w #$0080,$12(A1)               ; rm_Node\mn_Length
  MOVE.l struct_ArexxMsgPort,$E(A1)   ; rm_Node\*mn_ReplyPort
  MOVE.l #$1060000,$1C(A1)            ; rm_Action
  MOVE.l A1,D0
  MOVE.l D0,struct_RexxMsg

  JL_0_E21E:
RTS

.arexx_send_closewindow:
  MOVE.l #str_CLOSEWINDOW,ptr_own_arexxcommand
  LEA str_own_arexx_message,A0
  JSR arexx_sendmessage
RTS

.arexx_send_quitplease:
  LEA str_own_arexx_message,A0
  MOVEQ.l #$1F,D1
  JL_0_E23A:
    TST.l (A0)
    BNE.w JL_0_E246
  DBF D1,JL_0_E23A
  RTS
  JL_0_E246:

  MOVE.l #str_QUITPLEASE,ptr_own_arexxcommand
  LEA str_own_arexx_message,A0
  JSR arexx_sendmessage
  LEA str_own_arexx_message,A0
  MOVEQ.l #$1F,D1
  JL_0_E25E:
    CLR.l (A0)+
  DBF D1,JL_0_E25E
RTS

.arexx_send_openwindow:
  MOVE.l #str_OPENWINDOW,ptr_own_arexxcommand
  LEA str_own_arexx_message,A0
  JSR arexx_sendmessage
RTS

;JL_0_E27A:
;  MOVEM.l D0-D7/A0-A6,-(A7)
;  MOVE.l #str_DOCLISTCHANGED,ptr_own_arexxcommand
;  LEA str_arexx_message_doclist,A0
;  JSR arexx_sendmessage
;  MOVEM.l (A7)+,D0-D7/A0-A6
;RTS
;
;JL_0_E296:
;  MOVEM.l D0-D7/A0-A6,-(A7)
;  MOVE.l #str_DOCNUMCHANGED,ptr_own_arexxcommand
;  LEA str_arexx_message_doclist,A0
;  JSR arexx_sendmessage
;  MOVEM.l (A7)+,D0-D7/A0-A6
;RTS

.arexx_sendmessage:
  ; A0: Stringpointer with AREXX-COMMAND
  MOVEM.l D0-D2/A0-A1/A6,-(A7)
  ; -- bis ans ende des Strings gehen
  MOVEQ.l #$1F,D1
  JL_0_E2B8:
      MOVE.l (A0)+,D2
      BNE.w JL_0_E2C6
    DBF D1,JL_0_E2B8
    BRA.w exit_sendmessage

    JL_0_E2C6:
    MOVEM.l D1/A0,-(A7)
    JSR init_RexxMsg
    MOVE.l D0,ptr_own_ArexxMsg
    MOVEA.l D0,A1
    MOVE.l ptr_own_arexxcommand,$28(A1)
    MOVEM.l D1/A1,-(A7)

    MOVEA.l D2,A1
    MOVEA.l _execbase,A6
    JSR _FindPort(A6)     ; A0 : Portname
    MOVEM.l (A7)+,D1/A1

    TST.l D0
     BEQ.w no_port_found

    MOVEA.l D0,A0
    JSR _PutMsg(A6)
    JL_0_E2FC:
      MOVEA.l struct_ArexxMsgPort,A0
      JSR _WaitPort(A6)

      MOVEA.l struct_ArexxMsgPort,A0
      JSR _GetMsg(A6)

      CMP.l ptr_own_ArexxMsg,D0
       BEQ.w no_port_found
      MOVEA.l D0,A0
      MOVE.l $A(A0),ptr_arexx_sendername
      MOVEA.l A0,A1
      MOVE.l $28(A1),ptr_arexx_commandstr
      CMPI.b #$7,$8(A0)
       BNE.w JL_0_E33E
      JSR free_RexxMsg
    BRA.b JL_0_E2FC

    JL_0_E33E:
    MOVEA.l A0,A1
    JSR _ReplyMsg(A6)
    BRA.b JL_0_E2FC

    no_port_found:
    MOVE.l struct_RexxMsg,D0
    JSR free_RexxMsg
    MOVEM.l (A7)+,D1/A0
  DBF D1,JL_0_E2B8

  exit_sendmessage:
  MOVEM.l (A7)+,D0-D2/A0-A1/A6
RTS

.clear_arexxtable:
  MOVEA.l _execbase,A6
  MOVEA.l arexx_table,A1
  !newfree
RTS

ptr_own_arexxcommand:        Ds.l 1
ptr_own_ArexxMsg:            Ds.l 4
struct_RexxMsg:              Ds.l 1
arexxport_available:         Ds.l 1
struct_ArexxMsgPort:         Ds.l 1
ptr_arexxport:               Ds.l 1
rexx_signalbits:             Ds.w 1
arexx_number_of_parameters:  Ds.w 1
checked_arexxcmd:            Ds.w 1
ptr_arexx_sendername:        Ds.l 1
ptr_arexx_commandstr:        Ds.l 1
ptr_arexx_currsourceline:    Ds.l 1
str_libname_rexxsyslib:      Dc.b "rexxsyslib.library",0,0
_rexxsyslibbase:             Ds.l 1

str_REXX:                    Dc.b "REXX",0,0
str_CLOSEWINDOW:             Dc.b "CLOSEWINDOW",0
str_OPENWINDOW:              Dc.b "OPENWINDOW",0,0
str_QUITPLEASE:              Dc.b "QUITPLEASE",0,0
str_DOCLISTCHANGED:          Dc.b "DOCLISTCHANGED",0,0
str_DOCNUMCHANGED:           Dc.b "DOCNUMCHANGED",0
str_own_arexx_message:       Ds.l 32
str_arexx_message_doclist:   Ds.l 32



; --
; -- Arexx-Command, pointer to function:
; --
ptr_arexxcmd_list:
 Dc.l AL_0_E66C
 Dc.l arexxfunc_runexe             ;runfunc
 Dc.l AL_0_E57C
 Dc.l arexxfunc_compilerun         ;compilefunc
 Dc.l AL_0_E600
 Dc.l arexxfunc_prevsource         ;prevdoc
 Dc.l AL_0_E608
 Dc.l arexxfunc_nextsource         ;nextdoc
 Dc.l AL_0_E6B6
 Dc.l arexxfunc_cut                ;cut
 Dc.l AL_0_E6BA
 Dc.l arexxfunc_copy               ;copy
 Dc.l AL_0_E6C0
 Dc.l arexxfunc_paste              ;paste
 Dc.l AL_0_E63C
 Dc.l arexxfunc_load               ;load file
 Dc.l AL_0_E636
 Dc.l arexxfunc_quit               ;quit
 Dc.l AL_0_E642
 Dc.l arexxfunc_loadnew            ;loadnew
 Dc.l AL_0_E64A
 Dc.l arexxfunc_save               ;save
 Dc.l AL_0_E632
 Dc.l arexxfunc_new                ;new
 Dc.l AL_0_E650
 Dc.l arexxfunc_print              ;print
 Dc.l AL_0_E61C
 Dc.l arexxfunc_erase              ;erase
 Dc.l AL_0_E6A4
 Dc.l arexxfunc_doclist            ;doclist
 Dc.l AL_0_E5BC
 Dc.l arexxfunc_topline            ;topline
 Dc.l AL_0_E5C4
 Dc.l arexxfunc_bottomline         ;bottomline
 Dc.l AL_0_E5E0
 Dc.l arexxfunc_nextline           ;nextline
 Dc.l AL_0_E5D0
 Dc.l arexxfunc_getline            ;getline
 Dc.l AL_0_E5F6
 Dc.l arexxfunc_prevline           ;prevline
 Dc.l AL_0_E5EA
 Dc.l arexxfunc_screentoback       ;hidescreen
 Dc.l AL_0_E5D8
 Dc.l arexxfunc_redraw             ;redraw
 Dc.l AL_0_E610
 Dc.l arexxfunc_screenname         ;screenname
 Dc.l AL_0_E59C
 Dc.l arexxfunc_iconify            ;iconify
 Dc.l AL_0_E670
 Dc.l arexxfunc_notifynewdoc       ;notifynewdoc
 Dc.l AL_0_E67E
 Dc.l arexxfunc_dontnotifynewdoc   ;dontnotifynewdoc
 Dc.l AL_0_E690
 Dc.l arexxfunc_getdoclist         ;getdoclist
 Dc.l AL_0_E584
 Dc.l arexxfunc_screentofront      ;showscreen
 Dc.l AL_0_E574
 Dc.l arexxfunc_getword
 Dc.l AL_0_E622
 Dc.l arexxfunc_help               ;help
 Dc.l AL_0_E628
 Dc.l arexxfunc_helptext           ;helptext
 Dc.l AL_0_E6C6
 Dc.l arexxfunc_libguide           ;libguide
 Dc.l AL_0_E6D0
 Dc.l arexxfunc_activate           ;activate
 Dc.l AL_0_E69C
 Dc.l arexx_gotodoc                ;gotodoc
 Dc.l AL_0_E6AC
 Dc.l arexxfunc_getdocnum          ;getdocnum
 Dc.l AL_0_E656
 Dc.l arexxfunc_rememberme         ;rememberme
 Dc.l AL_0_E662
 Dc.l arexxfunc_forgetme           ;forgetme
 Dc.l AL_0_E5A4
 Dc.l arexxfunc_about              ;about
 Dc.l AL_0_E5B4
 Dc.l arexxfunc_version            ;version
 Dc.l AL_0_E5AA
 Dc.l arexxfunc_numlines           ;numlines
 Dc.l AL_0_E590
 Dc.l rebuild_menus                ;reloadmenus
 Dc.l AL_0_E6E4
 Dc.l arexxfunc_windowshorten      ;windowshorten
 Dc.l AL_0_E6DA
 Dc.l arexxfunc_windowpos          ;windowpos
 Dc.l AL_0_E6F2
 Dc.l arexxfunc_makeexec           ;makeexec
 Ds.l 4

 ; --
 ; -- arexx-commandlabels
 ; --
 AL_0_E574:  Dc.b "GETWORD",0
 AL_0_E57C:  Dc.b "COMPILE",0
 AL_0_E584:  Dc.b "SHOWSCREEN",0,0
 AL_0_E590:  Dc.b "RELOADMENUS",0
 AL_0_E59C:  Dc.b "ICONIFY",0
 AL_0_E5A4:  Dc.b "ABOUT",0
 AL_0_E5AA:  Dc.b "NUMLINES",0,0
 AL_0_E5B4:  Dc.b "VERSION",0
 AL_0_E5BC:  Dc.b "TOPLINE",0
 AL_0_E5C4:  Dc.b "BOTTOMLINE",0,0
 AL_0_E5D0:  Dc.b "GETLINE",0
 AL_0_E5D8:  Dc.b "REDRAW",0,0
 AL_0_E5E0:  Dc.b "NEXTLINE",0,0
 AL_0_E5EA:  Dc.b "HIDESCREEN",0,0
 AL_0_E5F6:  Dc.b "PREVLINE",0,0
 AL_0_E600:  Dc.b "PREVDOC",0
 AL_0_E608:  Dc.b "NEXTDOC",0
 AL_0_E610:  Dc.b "SCREENNAME",0,0
 AL_0_E61C:  Dc.b "ERASE",0
 AL_0_E622:  Dc.b "HELP",0,0
 AL_0_E628:  Dc.b "HELPTEXT",0,0
 AL_0_E632:  Dc.b "NEW",0
 AL_0_E636:  Dc.b "QUIT",0,0
 AL_0_E63C:  Dc.b "LOAD",0,0
 AL_0_E642:  Dc.b "LOADNEW",0
 AL_0_E64A:  Dc.b "SAVE",0,0
 AL_0_E650:  Dc.b "PRINT",0
 AL_0_E656:  Dc.b "REMEMBERME",0,0
 AL_0_E662:  Dc.b "FORGETME",0,0
 AL_0_E66C:  Dc.b "RUN",0
 AL_0_E670:  Dc.b "NOTIFYNEWDOC",0,0
 AL_0_E67E:  Dc.b "DONTNOTIFYNEWDOC",0,0
 AL_0_E690:  Dc.b "GETDOCLIST",0,0
 AL_0_E69C:  Dc.b "GOTODOC",0
 AL_0_E6A4:  Dc.b "DOCLIST",0
 AL_0_E6AC:  Dc.b "GETDOCNUM",0
 AL_0_E6B6:  Dc.b "CUT",0
 AL_0_E6BA:  Dc.b "COPY",0,0
 AL_0_E6C0:  Dc.b "PASTE",0
 AL_0_E6C6:  Dc.b "LIBGUIDE",0,0
 AL_0_E6D0:  Dc.b "ACTIVATE",0,0
 AL_0_E6DA:  Dc.b "WINDOWPOS",0
 AL_0_E6E4:  Dc.b "WINDOWSHORTEN",0
 AL_0_E6F2:  Dc.b "MAKEEXEC",0,0


; --
; -- funtions to be executed by appropriate arexx-command
; --
.arexxfunc_activate:
  TST.l ptr_sourcewindow
  BEQ.w JL_0_E826
  MOVEA.l ptr_sourcewindow,A0
  TST.w AL_0_5388
  BEQ.w JL_0_E818
  MOVEA.l comPtr_CompilerWindow,A0

  JL_0_E818:
  MOVE.l A6,-(A7)
  MOVEA.l _intuibase,A6
  JSR _ActivateWindow(A6)
  MOVEA.l (A7)+,A6

  JL_0_E826:
  MOVEQ.l #$00,D0
  SUBA.l A0,A0
RTS

.arexxfunc_rememberme:
  LEA str_own_arexx_message,A0
  MOVEQ.l #$1F,D0
  JL_0_E832:
    TST.l (A0)+
     BEQ.w JL_0_E842
  DBF D0,JL_0_E832
  MOVEQ.l #$00,D0
  SUBA.l A0,A0
  RTS

  JL_0_E842:
  MOVE.l ptr_arexx_sendername,-(A0)
  MOVEQ.l #$00,D0
  SUBA.l A0,A0
RTS

.arexxfunc_forgetme:
  LEA str_own_arexx_message,A0
  MOVE.l ptr_arexx_sendername,D0
  MOVEQ.l #$1F,D1
  JL_0_E85A:
    CMP.l (A0)+,D0
     BEQ.w JL_0_E868
  DBF D1,JL_0_E85A
  BRA.w JL_0_E86A

  JL_0_E868:
  CLR.l -(A0)

  JL_0_E86A:
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_iconify:
  SUBA.l A0,A0
  MOVEQ.l #$01,D0
  JSR arexx_answer_message
  JSR menu_settings
  ST checked_arexxcmd
  MOVEQ.l #$00,D7
RTS

.arexxfunc_doclist:
  JSR menu_project
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_getdocnum:
  MOVEA.l _execbase,A6
  MOVEA.l struct_RexxMsg,A1
  JSR _ReplyMsg(A6)
  ST checked_arexxcmd
  MOVEQ.l #$00,D7
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

JL_0_E8B2:
  MOVEA.l ptr_tempstring,A0
  MOVE.l #$30000000,(A0)
  MOVEQ.l #$00,D0
RTS

JL_0_E8C2:
  MOVEM.l D1-D7/A1-A6,-(A7)
  MOVEA.l actualfile,A1
  MOVEA.l loadedfilesbase,A0
  MOVEQ.l #$00,D0

  JL_0_E8D4:
    CMPA.l A0,A1
     BEQ.w JL_0_E8E6
    MOVEA.l (A0),A0
    ADDQ.l #1,D0
    CMPA.l #$0,A0
  BNE.b JL_0_E8D4

  JL_0_E8E6:
  MOVEA.l ptr_tempstring,A0
  CLR.l (A0)
  CLR.l $4(A0)
  JSR format_value
  MOVEM.l (A7)+,D1-D7/A1-A6
  MOVEQ.l #$00,D0
  MOVEA.l ptr_tempstring,A0
RTS

.arexx_gotodoc:
  MOVEA.l loadedfilesbase,A0
  TST.l D0
  BEQ.w JL_0_E918

  JL_0_E912:
  MOVEA.l (A0),A0
  SUBQ.l #1,D0
  BNE.b JL_0_E912

  JL_0_E918:
  MOVE.l A0,D0
  CMP.l actualfile,D0
  BEQ.w JL_0_E92A
  JSR selectfile
  JL_0_E92A:

  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_getdoclist:
  JSR StoreXtraData
  MOVE.l loadedfilesbase,D0
  MOVEA.l ptr_tempstring,A0
  JSR generate_tempfilename
  MOVEA.l ptr_tempstring,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_windowpos:
  CMPI.w #$2,arexx_number_of_parameters
    BNE.w JL_0_E9A4

  MOVEA.l AL_0_EEC6,A0
  JSR JL_0_EA02
  MOVE.w AL_0_B7EE,D6
  CMP.w D6,D7
    BEQ.w JL_0_E9A4

  MOVE.w D7,AL_0_B7EE
  MOVE.w D7,comWord__AL_0_86C4
  CLR.w AL_0_B7F0
  CLR.w comWord__AL_0_86C6
  TST.l ptr_sourcewindow
    BEQ.w JL_0_E9A4
  !basic
  Request "","close id! E9A4","Ok"
  !asm

  JSR close_sourcewindow
  JSR open_sourcewindow
  JSR update_labelstuff

  JL_0_E9A4:
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_windowshorten:
  CMPI.w #$2,arexx_number_of_parameters
   BNE.w JL_0_E9FC
  MOVEA.l AL_0_EEC6,A0
   JSR JL_0_EA02
  MOVE.w AL_0_B7F0,D6
  CMP.w D6,D7
   BEQ.w JL_0_E9FC
  MOVE.w D7,AL_0_B7F0
  MOVE.w D7,comWord__AL_0_86C6
  CLR.w AL_0_B7EE
  CLR.w comWord__AL_0_86C4
  TST.l ptr_sourcewindow
   BEQ.w JL_0_E9FC
  !basic
  Request "","close id! E9AA","Ok"
  !asm

   JSR close_sourcewindow
   JSR open_sourcewindow
   JSR update_labelstuff

  JL_0_E9FC:
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

JL_0_EA02:
  MOVEQ.l #$00,D7
  MOVEQ.l #$00,D0
  JL_0_EA06:
    MOVE.b (A0)+,D0
     BEQ.w JL_0_EA18
    SUBI.b #"0",D0
    MULU #$A,D7
    ADD.b D0,D7
  BRA.b JL_0_EA06

  JL_0_EA18:
RTS

.arexxfunc_cut:
  JSR menu_cut
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_copy:
  JSR menu_copy
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_paste:
  JSR menu_paste
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_notifynewdoc:
  LEA str_arexx_message_doclist,A0
  MOVEQ.l #$1F,D0

  JL_0_EA44:
    TST.l (A0)+
     BEQ.w JL_0_EA54
  DBF D0,JL_0_EA44
  MOVEQ.l #$00,D0
  SUBA.l A0,A0
  RTS

  JL_0_EA54:
  MOVE.l ptr_arexx_sendername,-(A0)
  MOVEQ.l #$00,D0
  SUBA.l A0,A0
RTS

.arexxfunc_dontnotifynewdoc:
  LEA str_arexx_message_doclist,A0
  MOVE.l ptr_arexx_sendername,D0
  MOVEQ.l #$1F,D1

  JL_0_EA6C:
  CMP.l (A0)+,D0
   BEQ.w JL_0_EA7A
   DBF D1,JL_0_EA6C
 BRA.w JL_0_EA7C

  JL_0_EA7A:
  CLR.l -(A0)
  JL_0_EA7C:
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_erase:
  SF checked_arexxcmd
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
  JSR arexx_answer_message
  ST checked_arexxcmd
  MOVEQ.l #$65,D6
  MOVEQ.l #-$02,D7
RTS

.arexxfunc_quit:
  SF checked_arexxcmd
  SUBA.l A0,A0
  MOVEQ.l #$01,D0
  JSR arexx_answer_message
  ST checked_arexxcmd
  MOVEQ.l #$73,D6
  MOVEQ.l #-$02,D7
RTS

.arexxfunc_new:
  JSR menu_opennew
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_loadnew:
  CMPI.w #$2,arexx_number_of_parameters
   BNE.w JL_0_EAF2
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
  JSR arexx_answer_message
  ST checked_arexxcmd
  JSR menu_opennew
  MOVE.l AL_0_EEC6,D7
  JSR load_source
  MOVEQ.l #$00,D7
  RTS

  JL_0_EAF2:
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
  JSR arexx_answer_message
  ST checked_arexxcmd
  JSR menu_opennew
  JSR menu_load
  MOVEQ.l #$00,D7
RTS

.arexxfunc_load:
  CMPI.w #$2,arexx_number_of_parameters
   BNE.w JL_0_EB3A
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
  JSR arexx_answer_message
  ST checked_arexxcmd
  MOVE.l AL_0_EEC6,D7
  JSR load_source
  MOVEQ.l #$00,D7
  RTS

  JL_0_EB3A:
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
  JSR arexx_answer_message
  ST checked_arexxcmd
  JSR menu_load
  MOVEQ.l #$00,D7
RTS

.arexxfunc_save:
  SF AL_0_1162
  JSR menu_save
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_print:
  JSR menu_print
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_prevsource:
   JSR menu_previousfile
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_nextsource:
   JSR menu_nextfile
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_screenname:
  LEA str_defaultpubscreen,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_redraw:
  JSR _redraw
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_about:
  JSR menu_about
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_numlines:
  MOVEQ.l #$00,D0
  MOVE.l comLong_TotalLines,D0
  LEA L_0_EF02,A0
  JSR format_value
  LEA L_0_EF02,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_version:
;  LEA JL_0_ED6C,A0
  LEA str_pedname,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_topline:
  MOVE.l comPtr_FirstSourceLine,ptr_arexx_currsourceline
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_bottomline:
  MOVE.l comPtr_LastSourceLine,ptr_arexx_currsourceline
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_nextline:
  MOVEA.l ptr_arexx_currsourceline,A0
  CMPA.l #$0,A0
   BEQ.w JL_0_EC0A
  TST.l (A0)
   BEQ.w JL_0_EC0A
  MOVEA.l (A0),A0
  MOVE.l A0,ptr_arexx_currsourceline
  SUBA.l A0,A0
  JL_0_EC0A:
  MOVEQ.l #$00,D0
RTS

.arexxfunc_screentoback:
  MOVEA.l _intuibase,A6
  MOVEA.l ptr_pedscreen,A0
   JSR _ScreenToBack(A6)
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_screentofront:
  MOVEA.l _intuibase,A6
  MOVEA.l ptr_pedscreen,A0
  JSR _ScreenToFront(A6)
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_getline:
  MOVEA.l ptr_arexx_currsourceline,A0
  CMPA.l #$0,A0
   BEQ.w JL_0_EC60
  LEA $9(A0),A0
  MOVEA.l ptr_tempstring,A1
  JSR detokenize_line
  MOVEA.l ptr_tempstring,A0
  MOVEQ.l #$00,D0
  ;!basic
  ;!cout{Hex$(Peek.l(?ptr_tempstring)),Peek$(Peek.l(?ptr_tempstring))}
  ;!asm
  RTS

  JL_0_EC60:
  MOVEQ.l #$05,D0
RTS

.arexxfunc_prevline:
  MOVEA.l ptr_arexx_currsourceline,A0
  CMPA.l #$0,A0
  BEQ.w JL_0_EC88
  TST.l $4(A0)
  BEQ.w JL_0_EC88
  MOVEA.l $4(A0),A0
  MOVE.l A0,ptr_arexx_currsourceline
  SUBA.l A0,A0

  JL_0_EC88:
  MOVEQ.l #$00,D0
  RTS

  JL_0_EC8C:
RTS

.getwordnodetoke  ;a0  = cursor pos
  MOVEA.l ptr_tempstring,A1
  JSR JL_0_ECD6
  MOVEA.l ptr_tempstring,A0
  MOVE.w replacestartcolumn,d0
  ;SUBQ.w #1,d0
  MOVE.w d0,comWord_Column
  CLR.w comWord_ColumnsOffset
  MOVEQ.l #$00,D0
RTS

.arexxfunc_getword:
  MOVEA.l ptr_tempstring,A1
  JSR JL_0_ECA2
  MOVEA.l ptr_tempstring,A0
  MOVEQ.l #$00,D0
  RTS

  JL_0_ECA2:
  CLR.b macro_
  MOVEA.l comPtr_CurrentSourceLine,A0
  LEA $9(A0),A0
  MOVE.l A1,-(A7)
  MOVEA.l expandstore,A1
  MOVEQ #120/4,d0
 'lo
    CLR.l (a1)+
  DBF d0,'lo

  MOVEA.l expandstore,A1
  JSR detokenize_line
  MOVEA.l expandstore,A0
  MOVE.l (A7)+,A1
  MOVEQ.l #$00,D1
  MOVE.w comWord_Column,D1
  ADD.w comWord_ColumnsOffset,D1
  ;SUBQ.w #1,D1
  ADDA.l D1,A0

  JL_0_ECD6:
    TST.w D1
     BMI.w JL_0_ED14
    MOVE.b (A0),D0
    CMP.b #"!",d0
    BNE 'l1
    MOVE.b #1,macro_
   'l1
    CMP.b #"_",d0
     BEQ JL_0_ED0E
    CMP.b #"z",D0
     BGT.w JL_0_ED14
    CMP.b #"a",D0
     BGE.w JL_0_ED0E
    CMP.b #"Z",D0
     BGT.w JL_0_ED14
    CMP.b #"A",D0
     BGE.w JL_0_ED0E
    CMP.b #"9",D0
     BGT.w JL_0_ED14
    CMP.b #"0",D0
     BLT.w JL_0_ED14

    JL_0_ED0E:
    SUBQ.l #1,A0
    SUBQ.w #1,D1
  BRA.b JL_0_ECD6

  JL_0_ED14:
  ADDQ.l #1,a0
  MOVE.w d1,replacestartcolumn

  JL_0_ED14b:
  MOVE.b (A0)+,D0
  ;CMP.b #$20,d0
  ;BEQ JL_0_ED46
  CMP.b #"{",d0
  BEQ JL_0_ED46
  CMP.b #"_",d0
  BEQ JL_0_ED48
  CMP.b #"z",D0
   BGT.w JL_0_ED46
  CMP.b #"a",D0
   BGE.w JL_0_ED48
  CMP.b #"Z",D0
   BGT.w JL_0_ED46
  CMP.b #"A",D0
   BGE.w JL_0_ED48
  CMP.b #"9",D0
   BGT.w JL_0_ED46
  CMP.b #"0",D0
   BGE.w JL_0_ED48

  JL_0_ED46:
  MOVEQ.l #$00,D0

  JL_0_ED48:
  MOVE.b D0,(A1)+
  TST.b D0
  BNE.b JL_0_ED14b
RTS


.getstring_new2
  *textline.l = TEDGetCurrentLine{} + 9
  *detokened.l = TEDDetoke{*textline}
  text$ = Peek$(*detokened)
  cursorpos.l = Peek.w(?comWord_Column)
  actualword$ = preproc_CropToken{*PreProcessor,text$,cursorpos}
RTS



.getstring_new
  ;*textline.l = TEDGetCurrentLine_ + 9
  ;*detokened.l = TEDDetoke_(*textline)
  *textline.l = TEDGetCurrentLine{} + 9
  *detokened.l = TEDDetoke{*textline}

;  !cout{Peek.w(?comWord_ColumnsOffset),Peek.w(?comWord_Column),Hex$(*detokened),Hex$(*textline)}
;  !cout{"*"+Peek$(*detokened)+"*",Peek$(*textline)}
  text$ = Peek$(*detokened)
  cursorpos.l = Peek.w(?comWord_Column)+1
  aword$ = "" : char$ =""
  tlen = FLen(text$)
  nextpos.l = cursorpos
  backpos.l = cursorpos - 1
  ;error{"Search here: "+text$}
  Repeat
    aword$ = char$ + aword$
    char$ = Mid$(text$,backpos,1)
    backpos - 1
  Until (char$=" ") OR (char$="(") OR (char$=")") OR (char$="{") OR (char$=Chr$(34)) OR (char$ = "{") OR (char$="}") OR (char$=",") OR (backpos<0)
  char$ = ""

  Repeat
    aword$ = aword$ + char$
    char$ = Mid$(text$,nextpos,1)
    nextpos + 1
  Until (char$=" ") OR (char$=")") OR (char$="(") OR (char$="}") OR (char$=Chr$(34)) OR (char$ = "{") OR (char$="}") OR (char$=",") OR (nextpos>(tlen+1))
  actualword$ = aword$
  ;error{"Found: "+actualword$}
RTS

.getstring:
  MOVEA.l ptr_tempstring,A1
  MOVEA.l comPtr_CurrentSourceLine,A0
  LEA $9(A0),A0
  MOVE.l A1,-(A7)
  MOVEA.l expandstore,A1
  MOVEQ #120/4,d0
 'lo
    CLR.l (a1)+
  DBF d0,'lo

  MOVEA.l expandstore,A1
  JSR detokenize_line
  MOVEA.l expandstore,A0
  MOVE.l (A7)+,A1
  MOVEQ.l #$00,D1
  MOVE.w comWord_Column,D1
  ADD.w comWord_ColumnsOffset,D1
  ;SUBQ.w #1,D1
  ADDA.l D1,A0
 'l1
  MOVE.b (a0),d0
  CMP.b #$22,d0
  BEQ 'x1
  SUBQ.l #1,A0
  SUBQ.w #1,D1
  TST.w d1
  BNE 'l1
 'x1
  MOVEA.l ptr_tempstring,A1
  ADDQ.l #1,a0
 'l2
    MOVE.b (a0)+,d0
    BEQ 'x2
    CMP.b #$22,d0
    BEQ 'x2
    MOVE.b d0,(a1)+
  BRA 'l2
 'x2
  CLR.b (a1)+
  MOVEA.l ptr_tempstring,A0
  MOVEQ.l #$00,D0
RTS



.arexxfunc_compilerun:
  SUBA.l     A0,A0
  MOVEQ.l    #$01,D0
  JSR        arexx_answer_message
  ST         checked_arexxcmd

  MOVEM.l    D2-D7/A1-A6,-(A7)
  MOVEQ.l    #$50,D6
  JSR        call_compilermenuitem
  MOVEM.l    (A7)+,D2-D7/A1-A6
RTS

.arexxfunc_runexe:
  SUBA.l     A0,A0
  MOVEQ.l    #$01,D0
  BSR.w      arexx_answer_message
  ST         checked_arexxcmd
  MOVEM.l    D2-D7/A1-A6,-(A7)
  MOVEQ.l    #$51,D6
  JSR        call_compilermenuitem
  MOVEM.l    (A7)+,D2-D7/A1-A6
RTS


.arexxfunc_makeexec:
  SUBA.l     A0,A0
  MOVEQ.l    #$01,D0
  BSR.w      arexx_answer_message
  ST         checked_arexxcmd
  MOVEM.l    D2-D7/A1-A6,-(A7)
  MOVEQ.l    ##MENU_CREATEEXE,D6
  JSR        call_compilermenuitem
  MOVEM.l    (A7)+,D2-D7/A1-A6
RTS



.arexxfunc_help:
  MOVEM.l    A0-A4,-(A7)
  MOVEA.l    comPtr_CurrentSourceLine,A4
  ; -- not implemented
  MOVEM.l    (A7)+,A0-A4
  MOVEQ.l    #$00,D0
  SUBA.l     A0,A0
RTS

.arexxfunc_helptext:
  MOVEM.l    A0-A4,-(A7)
  MOVE.w     comWord_DoTokenize,D0
  BEQ.w      JL_0_EE70
  MOVEA.l    comPtr_CurrentSourceLine,A4
  LEA        $9(A4),A4
  MOVE.w     comWord_ColumnsOffset,D3
  ADD.w      comWord_Column,D3
  MOVEQ.l    #$00,D1
  MOVEQ.l    #$00,D2

  JL_0_EE10:
  MOVEQ.l    #$00,D0
  MOVE.b     (A4)+,D0
  MOVE.b     (A4)+,D0
  BEQ.w      JL_0_EE3E
  BPL.w      JL_0_EE38
  LSL.w      #8,D0
  MOVE.b     (A4)+,D0
;  MOVE.w     D0,AL_0_4658
  JSR        token_to_ascii
  MOVE.l     A3,D1

  JL_0_EE2E:
  ADDQ.w     #1,D2
  TST.b      (A3)+
  BNE.b      JL_0_EE2E
  MOVEA.l    A3,A2
  SUBQ.w     #2,D2

  JL_0_EE38:
  ADDQ.w     #1,D2
  CMP.w      D3,D2
  BLS.b      JL_0_EE10

  JL_0_EE3E:
  TST.l      D1
  BEQ.w      JL_0_EE70
  MOVEA.l    D1,A0
  MOVEA.l    ptr_tempstring,A1

  JL_0_EE4C:
  MOVE.b     (A0)+,(A1)+
  BNE.b      JL_0_EE4C
  SUBQ.w     #1,A1
  CMPI.b     #$28,(A2)
  BEQ.w      JL_0_EE5E
  MOVE.b     #$20,(A1)+

  JL_0_EE5E:
  MOVE.b     (A2)+,(A1)+
  BNE.b      JL_0_EE5E
  MOVEM.l    (A7)+,A0-A4
  MOVEQ.l    #$00,D0
  MOVEA.l    ptr_tempstring,A0
RTS

JL_0_EE70:
  SUBA.l     A0,A0
  MOVEQ.l    #$00,D0
RTS

.arexxfunc_libguide:
  !basic
  dummy = RTEZRequest("",!TRANS{"This AREXX command is not available anymore."},!TRANS{"Ok"})
  !asm
  MOVEQ.l #$00,D0
RTS
;  MOVEM.l    A1-A6,-(A7)
;  MOVEA.l    comPtr_CurrentSourceLine,A4
;  MOVEA.l    comPtr_Temp_TokenString3,A2
;  CLR.b      (A2)
;  MOVE.l     A2,-(A7)
;  BSR.w      AJL_0_F8C0
;  CLR.b      (A2)
;  MOVEA.l    (A7)+,A2
;  TST.b      (A2)
;  BEQ.w      JL_0_EEA2
;  MOVEA.l    A2,A0
;  MOVEM.l    (A7)+,A1-A6
;  MOVEQ.l    #$00,D0
;RTS
;
;JL_0_EEA2:
;  MOVEM.l    (A7)+,A1-A6
;  SUBA.l     A0,A0
;  MOVEQ.l    #$00,D0
;RTS

.rebuild_menus:
  !basic
  Gosub init_menus
  !asm
  SUBA.l  A0,A0
  MOVEQ.l #$00,D0
RTS


arexx_table:    Ds.l 1
AL_0_EEC6:      Ds.l 15
L_0_EF02:       Ds.w 7

.arexx_count_parameters:
  MOVEA.l struct_RexxMsg,A1
  LEA $28(A1),A0              ; string: AREXX-Command
  LEA arexx_table,A1
  MOVEQ.l #$00,D6

  JL_0_EF20:
  CMP.b #$10,D6
   BEQ.w exit_counting
  JL_0_EF28:
  MOVEA.l (A0)+,A2
  CMPA.l #$0,A2
   BEQ.w exit_counting

  JL_0_EF34:
  MOVEA.l (A1)+,A3
  MOVE.b (A2)+,D1
   BEQ.b JL_0_EF20
  CMP.b #$22,D1
   BEQ.w JL_0_EF74
  CMP.b #$27,D1
   BEQ.w JL_0_EF60
  ADDQ.w #1,D6
  MOVE.b D1,(A3)+
  JL_0_EF4E:
    MOVE.b (A2)+,D0
    CLR.b (A3)
    TST.b D0
     BEQ.b JL_0_EF28
    CMP.b #$20,D0
     BEQ.b JL_0_EF34
    MOVE.b D0,(A3)+
  BRA.b JL_0_EF4E

  JL_0_EF60:
  ADDQ.w #1,D6

  JL_0_EF62:
    MOVE.b (A2)+,D0
    CLR.b (A3)
    TST.b D0
     BEQ.b JL_0_EF28
    CMP.b #$22,D0
     BEQ.b JL_0_EF34
    MOVE.b D0,(A3)+
  BRA.b JL_0_EF62

  JL_0_EF74:
  ADDQ.w #1,D6

  JL_0_EF76:
    MOVE.b (A2)+,D0
    CLR.b (A3)
    TST.b D0
     BEQ.b JL_0_EF28
    CMP.b #$22,D0
     BEQ.b JL_0_EF34
    MOVE.b D0,(A3)+
  BRA.b JL_0_EF76

  exit_counting:
  MOVE.w D6,arexx_number_of_parameters
RTS



;.open_aslfilerequester:
;  ; fill the tagstructure for aslrequest
;  ; dimensions:
;  MOVE.l D0,AL_0_F1EE : BPL.b JL_0_EFA2 : MOVE.l #$1,AL_0_F1EA
;  JL_0_EFA2:
;  MOVE.l D1,AL_0_F1F6 : BPL.b JL_0_EFB4 : MOVE.l #$1,AL_0_F1F2
;  JL_0_EFB4:
;  MOVE.l D2,AL_0_F1FE : BPL.b JL_0_EFC6 : MOVE.l #$1,AL_0_F1FA
;  JL_0_EFC6:
;  MOVE.l D3,AL_0_F206 : BPL.b JL_0_EFD8 : MOVE.l #$1,AL_0_F202
;  JL_0_EFD8:
;  ; drawer
;  MOVE.l A0,AL_0_F216 : BPL.b JL_0_EFEA : MOVE.l #$1,AL_0_F212
;  JL_0_EFEA:
;  ; default file
;  MOVE.l A1,AL_0_F20E : BPL.b JL_0_EFFC : MOVE.l #$1,AL_0_F20A
;  JL_0_EFFC:
;  ; req title
;  MOVE.l A2,AL_0_F1D6 : BPL.b JL_0_F00E : MOVE.l #str_titlefilereq,AL_0_F1D6
;  JL_0_F00E:
;  TST.w use_filepattern : BNE.w JL_0_F01C : MOVEA.w #-$1,A3
;  JL_0_F01C:
;  ; file pattern
;  MOVE.l A3,AL_0_F21E : BPL.b JL_0_F02E : MOVE.l #$1,AL_0_F21A
;  JL_0_F02E:
;  ; positive text
;  MOVE.l A4,AL_0_F1E6 : BPL.b JL_0_F040 : MOVE.l #AL_0_F1C2,AL_0_F1E6
;  JL_0_F040:
;  ; negative text
;  MOVE.l A5,AL_0_F1DE : BPL.b JL_0_F052 : MOVE.l #AL_0_F1C6,AL_0_F1DE
;  JL_0_F052:
;  ; window pointer
;  MOVE.l A6,AL_0_F226 : BPL.b JL_0_F064 : MOVE.l #$1,AL_0_F222
;  JL_0_F064:
;
;
;  MOVE.l A0,ptr_asldrawername
;  MOVE.l A1,ptr_aslfilename
;  MOVE.l A3,ptr_aslpattern
;  MOVE.l #$0,AL_0_F236
;
;  TST.l ptr_aslpattern
;  BMI.b JL_0_F0BA
;  CMPA.l #comStr_str_FilePattern,A3
;  BEQ.w JL_0_F0A6
;  CMPA.l #comStr_str_FilePattern_standalone,A3
;  BEQ.w JL_0_F0A6
;  CMPA.l #comStr_str_FilePattern_noinfo,A3
;  BNE.w JL_0_F0BA
;  JL_0_F0A6:
;  MOVE.l #$FFFFFFFF,AL_0_F236
;  MOVE.l A3,AL_0_F21E
;  BRA.w JL_0_F0CE
;  JL_0_F0BA:
;
;  MOVE.l #AL_0_F512,AL_0_F21E
;  MOVE.l #$FFFFFFFF,ptr_aslpattern
;
;  JL_0_F0CE:
;  TST.l _aslbase
;  BNE.w aslrequest_file
;  MOVEQ.l #$00,D0
;  RTS
;
;  aslrequest_file:
;  MOVEA.l _aslbase,A6
;  TST.l ptr_aslrequest
;  BNE.w JL_0_F0FE
;  SUBA.l A0,A0
;  MOVEQ.l #asl_FileRequest,D0
;  JSR _AllocASLRequest(A6)
;  MOVE.l D0,ptr_aslrequest
;  BEQ.w exit_aslfilerequester
;  JL_0_F0FE:
;
;  MOVEA.l ptr_aslrequest,A0
;  LEA tags_aslreq,A1
;  JSR _ASLRequest(A6)           ; A0: requester, A1: tags
;  TST.l D0
;  BEQ.w exit_aslfilerequester
;
;  MOVEA.l ptr_aslrequest,A0
;
;  ;-- analyse the return struct of the requester
;
;  ;irgendwas mit pattern
;  TST.l ptr_aslpattern
;  BMI.w JL_0_F130
;    MOVEA.l $34(A0),A2
;    MOVEA.l ptr_aslpattern,A1
;    JL_0_F12C:
;      MOVE.b (A2)+,(A1)+
;    BNE.b JL_0_F12C
;  JL_0_F130:
;
;  ;-- get the drawer
;  MOVEA.l $8(A0),A2
;  TST.l ptr_asldrawername
;  BEQ.b JL_0_F146
;    MOVEA.l ptr_asldrawername,A1
;    JL_0_F142:
;      MOVE.b (A2)+,(A1)+
;    BNE.b JL_0_F142
;  JL_0_F146:
;
;  ;-- get the file
;  TST.l ptr_aslfilename
;  BEQ.b JL_0_F15C
;    MOVEA.l $4(A0),A2
;    MOVEA.l ptr_aslfilename,A1
;    JL_0_F158:
;      MOVE.b (A2)+,(A1)+
;    BNE.b JL_0_F158
;  JL_0_F15C:
;
;  ; -- copy returned to comStr_SourceFileComplete
;  MOVEA.l $8(A0),A2
;  LEA comStr_SourceFileComplete,A1
;  MOVEQ.l #-$01,D1
;  TST.b (A2)
;  BNE.b JL_0_F170
;    MOVEA.l $4(A0),A2
;    BRA.b JL_0_F18E
;  JL_0_F170:
;    ADDQ.l #1,D1
;    MOVE.b (A2)+,(A1)+
;  BNE.b JL_0_F170
;
;  SUBQ.l #1,A1
;  MOVEA.l $4(A0),A2
;  CMPI.b #$2F,(A1)  ; "/"
;  BEQ.b JL_0_F18E
;    CMPI.b #":",-$1(A1)
;    BEQ.b JL_0_F18E
;      MOVE.b #$2F,(A1)+
;  JL_0_F18E:
;
;  ADDQ.l #1,D1
;  CMP.l #-1,a3
;  BNE 'n1
;    CLR.b (a1)
;    BRA 'n2
; 'n1
;  MOVE.b (A2)+,(A1)+
;  BNE.b JL_0_F18E
;
;  MOVE.l D1,-(A7)
;  MOVE.l (A7)+,D1
; 'n2
;  MOVE.l #comStr_SourceFileComplete,D0
;  MOVEA.l D0,A0
;  TST.b (A0)
;  BNE.w JL_0_F1A8
;    MOVEQ.l #$00,D0
;  JL_0_F1A8:
;  RTS
;
;  exit_aslfilerequester:
;  MOVEQ.l #$00,D1
;  MOVEQ.l #$00,D0
;RTS

;str_titlefilereq:
;CNIF #lang = 0
;  Dc.b "Choose A File...",0,0
;CELSE
;  Dc.b "Wdhle eine Datei...",0,0
;CEND
;AL_0_F1C2:
;  Dc.b "Ok",0,0
;AL_0_F1C6:
;  CNIF #lang = 0
;  Dc.b "Cancel",0,0
;CELSE
;  Dc.b "Abbruch",0,0
;CEND


;ptr_aslrequest: Ds.l 1
;
;tags_aslreq:
;  Dc.b $80,$08,$00,$01
;
;AL_0_F1D6:; title text
;  Ds.l 1
;  Dc.b $80,$08,$00,$13
;
;AL_0_F1DE:; negative text
;  Ds.l 1
;  Dc.b $80,$08,$00,$12
;
;AL_0_F1E6:; positive text
;  Ds.l 1
;AL_0_F1EA:
;  Dc.b $80,$08,$00,$03
;
;AL_0_F1EE:; leftedge
;  Ds.l 1
;AL_0_F1F2:
;  Dc.b $80,$08,$00,$04
;
;AL_0_F1F6:
;  Ds.l 1
;AL_0_F1FA:
;  Dc.b $80,$08,$00,$05
;
;AL_0_F1FE:
;  Ds.l 1
;AL_0_F202:
;  Dc.b $80,$08,$00,$06
;
;AL_0_F206:
;  Ds.l 1
;AL_0_F20A:
;  Dc.b $80,$08,$00,$08
;
;AL_0_F20E:; initial file
;  Ds.l 1
;AL_0_F212:
;  Dc.b $80,$08,$00,$09
;
;AL_0_F216:; initial drawer
;  Ds.l 1
;AL_0_F21A:
;  Dc.b $80,$08,$00,$0A
;
;AL_0_F21E:; initial pattern
;  Ds.l 1
;AL_0_F222:
;  Dc.b $80,$08,$00,$02
;
;AL_0_F226:
;  Ds.l 1 ; window
;  Dc.b $80,$08
;
;  Dc.b $00,$2B,$FF,$FF ;.+..
;  Dc.b $FF,$FF,$80,$08
;
;  Dc.b $00,$2E
;
;AL_0_F236:
;  Ds.l 1
;  Dc.b $80,$08
;
;  Dc.b $00,$2F ;./
;asl_drawersonly:
;  Ds.l 3
;ptr_aslfilename:
;  Ds.l 1
;ptr_asldrawername:
;  Ds.l 1
;ptr_aslpattern:
;  Ds.l 1
;
;AL_0_F512:
;  Dc.b "#?#?",0,0
;Even
;
;
;.aslrequest_font:
;  MOVEA.l _aslbase,A6
;  TST.l struct_aslfontrequest
;  BNE.w JL_0_F27C
;  MOVEM.l D0-D3,-(A7)
;  MOVEQ.l #asl_FontRequest,D0
;  SUBA.l A0,A0
;  JSR _AllocASLRequest(A6)                         ;alloc asl fontrequester
;  MOVE.l D0,struct_aslfontrequest
;  MOVEM.l (A7)+,D0-D3
;
;  JL_0_F27C:
;  MOVEA.l struct_aslfontrequest,A0
;  MOVE.l D0,AL_0_F43A
;  BEQ 'l1
;  BPL.b JL_0_F294
; 'l1
;  MOVE.l #$1,AL_0_F436
;
;  JL_0_F294:
;  MOVE.l D1,AL_0_F442
;  BEQ 'l1
;  BPL.b JL_0_F2A6
; 'l1
;  MOVE.l #$1,AL_0_F43E
;
;  JL_0_F2A6:
;  MOVE.l D2,AL_0_F44A
;  BEQ 'l1
;  BPL.b JL_0_F2B8
; 'l1
;  MOVE.l #$1,AL_0_F446
;
;  JL_0_F2B8:
;  MOVE.l D3,AL_0_F452
;  BEQ 'l1
;  BPL.b JL_0_F2CA
; 'l1
;  MOVE.l #$1,AL_0_F44E
;
;  JL_0_F2CA:
;  MOVE.l ptr_sourcewindow,AL_0_F42A         ; Pointers in ASLtaglist
;  MOVE.l ptr_pedscreen,AL_0_F432
;  MOVE.w sourcefontsize,AL_0_F462
;  LEA taglist_aslfilerequest,A1
;  JSR _ASLRequest(A6)
;  TST.l D0
;  BEQ.w exit_aslfontrequester
;  MOVEA.l struct_aslfontrequest,A0
;  MOVE.l 8(a0),a1
;  LEA $C(A0),A0
;  ;MOVEA.l D0,A1
;  MOVE.l #sourcefontsize,D0
;  SUBI.l #str_sourcefontname,D0
;  MOVEA.l #str_sourcefontname,A2
;  SUBQ.w #1,D0
;
;  JL_0_F316:
;    MOVE.b #$0,(A2)+
;  DBF D0,JL_0_F316
;
;  MOVEA.l #str_sourcefontname,A2
;
;  JL_0_F324:
;    MOVE.b (A1)+,(A2)+
;  BNE.b JL_0_F324
;
;  MOVE.w #$0000,sourcefontsize
;  MOVE.w (A0),sourcefontsize
;  MOVEQ.l #-$01,D0
;  RTS
;
;  exit_aslfontrequester:
;  MOVEQ.l #$00,D0
;RTS
;
;
;struct_aslfontrequest:
;  Ds.l 1
;
;taglist_aslfilerequest:
;  Dc.b $80,$08,$00,$02

;AL_0_F42A:
;  Ds.l 1
;  Dc.b $80,$08,$00,$28 ;.(
;AL_0_F432:
;  Ds.l 1
;AL_0_F436:
;  Dc.b $80,$08,$00,$03

;AL_0_F43A:
;  Ds.l 1
;AL_0_F43E:
;  Dc.b $80,$08,$00,$04

;AL_0_F442:
;  Ds.l 1
;AL_0_F446:
;  Dc.b $80,$08,$00,$05

;AL_0_F44A:
;  Ds.l 1
;AL_0_F44E:
;  Dc.b $80,$08,$00,$06

;AL_0_F452:
;  Ds.l 1
;  Dc.b $80,$08,$00,$0A

;  Dc.l str_sourcefontname
;  Dc.b $80,$08,$00,$0B

;AL_0_F462:
;  Ds.l 1
;  Dc.b $80,$08

;  Dc.b $00,$30,$FF,$FF ;.0..
;  Dc.b $FF,$FF,$80,$08

;  Dc.b $00,$10,$00,$00

;  Dc.b $00,$06,$80,$08

;  Dc.b $00,$11,$00,$00

;  Dc.b $00,$1C,$80,$08     ;max font size $0c standard
;  Dc.b $00,$2B,$FF,$FF ;.+..
;  Dc.b $FF,$FF,$00,$00

;  Ds.w 1
;AL_0_F48A:
;  Ds.l 1
;



.menu_print:
  !basic
  If Peek.l(Addr Window(WZID("WIN_PRINT")))=0
    WZWindow WZID("WIN_PRINT"),0,128,-2,-2,-2,-2,WZID("WIN_PRINT")
    Use Window WZID("WIN_PRINT")
    exit_print.b = False
    Repeat
      !ev_WaitEvent
      Select ev
      Case #IDCMP_CLOSEWINDOW
        exit_print = True
      Case #IDCMP_IDCMPUPDATE
        Select WZGadName
        Case "PRINT_CANCEL"
          exit_print = True
        Case "PRINT_PRINT"
          Poke.s ?str_printerdevice,WZGetString("PRINT_DEVICE")
          !asm
          JSR printout_source
          !basic
          exit_print = True
        End Select
      End Select
    Until exit_print = True
    WZCloseWindow WZID("WIN_PRINT")

  EndIf
  !asm
RTS

.printout_source:
  MOVE.l #str_printerdevice,D1
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVEA.l _dosbase,A6
   JSR _Open(A6)
  MOVE.l D0,D7
   BEQ.w JL_0_F5F4
   CLR.b instring
  MOVE.l comLong_TotalLines,D6
  MOVEA.l comPtr_FirstSourceLine,A4

  JL_0_F58E:
    MOVEA.l comPtr_Temp_TokenString1,A0
    LEA $9(A4),A1
    MOVE.l A0,D2

    JL_0_F598:                        ;print code
      MOVE.b (A1)+,(A0)+
      BEQ.w JL_0_F5D8
      CMP.b #$22,-1(a0)
      BNE 'l1
      NOT.b instring
     'l1
      TST.b -1(a0)
      BPL.b JL_0_F598
      TST.b instring
      BNE JL_0_F598
     'l2
      MOVE.b -(A0),D0
      LSL.w #8,D0
      MOVE.b (A1)+,D0
      MOVE.b #$1B,(A0)+
      MOVE.b #"[",(A0)+
      MOVE.b #"1",(A0)+
      MOVE.b #"m",(A0)+
      JSR token_to_ascii

      JL_0_F5BC:
      MOVE.b (A3)+,(A0)+
      BNE.b JL_0_F5BC
      MOVE.b #$1B,-$1(A0)
      MOVE.b #"[",(A0)+
      MOVE.b #"2",(A0)+
      MOVE.b #"2",(A0)+
      MOVE.b #"m",(A0)+
    BRA.b JL_0_F598

    JL_0_F5D8:
    MOVE.b #$A,-$1(A0)
    MOVE.l A0,D3
    SUB.l D2,D3
    MOVE.l D7,D1
    JSR _Write(A6)
    MOVEA.l (A4),A4
    SUBQ.l #1,D6
  BNE.b JL_0_F58E
  MOVE.l D7,D1
  JSR _Close(A6)
  JL_0_F5F4:
RTS

;ptr_pluginentry:  Ds.l 1
;Even

.call_pluginmenuentry:
  TST.w use_pubscreen
   BEQ.w JL_0_FB72
  TST.w use_default_pubscreen
   BEQ.w JL_0_FB72
  MOVEA.l _intuibase,A6
  LEA str_defaultpubscreen,A0
  JSR _SetDefaultPubScreen(A6)

  JL_0_FB72:
  MOVE d6,-(a7)
  !basic
  MOVE (a7)+,D0 : id_menuitem.w = PutD0 - $258
  If id_menuitem = 1
    Gosub open_menueditor
    Gosub init_menus
  Else
    If FirstItem(custommenu())
      menuentry = 1
      While id_menuitem > menuentry
        dummy = NextItem(custommenu())
        menuentry + 1
      Wend
      If custommenu()\command = ""
        dummy = RTEZRequest("",custommenu()\itemname+" "+!TRANS{"has no assigned command."},"_Ok")
      Else
        Execute_ Null(custommenu()\command),0,0
      EndIf
    EndIf
  EndIf
  !asm
RTS

.open_menueditor
  If NOT WZ_CheckOpen{"WIN_MENUED"}
    WZWindow WZID("WIN_MENUED"),?wzgui,255,-2,-2,-2,-2,WZID("WIN_MENUED")
  End If
  DEFTYPE.List menuedlist
  ; -- get all the defined menuentries
  If FirstItem(custommenu())
    Repeat
      WZListAdd menuedlist,custommenu()\itemname,-2
    Until NOT NextItem(custommenu())
  EndIf
  WZPrint "MENUED_LIST",0,menuedlist
  menued_exit.b = False
  Repeat
    menued_ev.l = WaitEvent
    Select menued_ev
    Case #IDCMP_CLOSEWINDOW
      menued_exit = True
    Case #IDCMP_IDCMPUPDATE
      Select WZGadName
      Case "MENUED_EXIT" : menued_exit = True
      Case "MENUED_LIST" : selected_item.b = WZInput
        item_counter.b = 0
        ResetList custommenu()
        While (item_counter < selected_item) AND NextItem(custommenu())
          item_counter + 1
        Wend
        If item_counter = selected_item
          WZPrint "MENUED_ITEMNAME",custommenu()\itemname
          WZPrint "MENUED_COMMAND",custommenu()\command
        EndIf
      End Select
    End Select
  Until menued_exit = True

  WZListRemove menuedlist
  WZCloseWindow WZID("WIN_MENUED")
Return


JL_0_FBDE:
  MOVEA.l D0,A0
  CLR.l (A0)
  CLR.l $4(A0)
  MOVE.b D5,$8(A0)
RTS

.reset_currsourceline
  MOVEQ #0,d0
  TST.l 4(a4)
  BEQ 'l20
 'l10:
    MOVE.l 4(a4),a4
    ADDQ.l #1,d0
    TST.l 4(a4)
  BNE 'l10

  'l20:
RTS

.prev_currsourceline
  TST.l 4(a4)
  BEQ 'l20
  MOVE.l 4(a4),a4
  MOVE.l a4,d0
  RTS

 'l20
  MOVEQ #0,d0
RTS


.jump_addhistory         ;d0 linenum
  MOVEM.l a0/d1,-(a7)
  LEA history,a0
   MOVEQ #0,d1
  MOVE.w historypointer,d1
  MOVE.l comLong_DisplayLineOffset,d0
  ADD.l comLong_DisplayLine,d0
  MOVE.l d0,0(a0,d1)
  ADDQ.w #4,d1
  CMP.w  #maxhistory,d1
  BLE 'nowrap
  MOVEQ #0,d1
 'nowrap:
  MOVE.w d1,historypointer
  MOVEM.l (a7)+,a0/d1
RTS

.jump_historyup
  MOVE.l a1,-(a7)
  JSR storeline
  LEA history,a0
  MOVE.w historypointer,d1
  SUBQ #4,d1
  BPL 'l10
  MOVEQ #maxhistory,d1
 'l10
  MOVE.w d1,historypointer
  MOVE.l 0(a0,d1.w),d0
  JSR jumpline
  MOVE.l (a7)+,a1
RTS

.jump_historydown
  MOVE.l a1,-(a7)
  JSR storeline
  LEA history,a0
  MOVE.w historypointer,d1
  ADDQ #4,d1
  CMP.w #maxhistory,d1
  BLE 'l10
  MOVEQ #0,d1
 'l10
  MOVE.w d1,historypointer
  MOVE.l 0(a0,d1.w),d0
  JSR jumpline
  MOVE.l (a7)+,a1
RTS

.jump_onclick:
  MOVEM.l d2-d7/a1/a5-a6,-(a7)
  MOVEA.l comPtr_CurrentSourceLine,A4
  MOVE.l a4,olda4
  CLR.b foundf2
 'lp1
  MOVE.b (a4)+,d0
   BEQ 'ex1
  CMP.b #"{",d0
   BNE 'lp1
  MOVE.b #1,foundf2
 'ex1
  MOVEA.l comPtr_CurrentSourceLine,A4
  JSR arexxfunc_getword
  JSR reset_currsourceline
  JSR jump_addhistory
  MOVE.l #0,clickjump_fromfile ; in-same-file search first

  MOVEQ #0,d3
  begin_search:
    CLR.b foundf
    LEA 9(a4),a0
    CMP.l olda4,a4
    BEQ 'nextline
   'l5:
      CMP.b #" ",(a0)
      BNE 'l5b
      ADDQ.l #1,a0
      BRA 'l5
     'l5b
      CMP.w #$8008,(a0)
      BNE 'nostatement
      MOVE.b #1,foundf
      ADDQ.w #2,a0
    BRA 'l5

   'nostatement:
    CMP.w #$8009,(a0)
    BNE 'nofunction
    MOVE.b #1,foundf
    ADDQ.w #2,a0
    CMP.b #".",(a0)
    BNE 'nod
    ADDQ.l #2,a0
    !skipspace a0
   'nod
    BRA 'l5

   'nofunction
    CMP.w #$800d,(a0)
    BNE 'nomacro
    MOVE.b #1,foundf
    ADDQ.w #2,a0
    BRA 'l5

   'nomacro
    CMP.b #".",(a0)
    BNE 'l100
    ADDQ #1,a0
   'l51:
      CMP.b #" ",(a0)
      BNE 'l51b
      ADDQ.l #1,a0
    BRA 'l51
   'l51b

   'l100:
    TST.b (a0)
    BEQ 'nextline
    CMP.l #"FAST",(a0)
    BNE 'la1
    ADDQ.l #4,a0
    !skipspace a0
   'la1
    MOVE.l ptr_tempstring,a1
   'l1:
    CMPM.b (a0)+,(a1)+
    BNE 'nextline
    TST.b (a1)
     BNE 'l1
    TST.w foundf2
     BEQ 'lb2
    TST.w foundf
     BEQ 'nextline
   'lb2
    CMP.b #" ",(a0)
     BEQ 'do
    CMP.b #";",(a0)
     BEQ 'do
    CMP.b #":",(a0)
     BEQ 'do
    CMP.b #"{",(a0)
     BEQ 'do
    TST.b (a0)
     BNE 'nextline
   'do
    MOVE.l d3,d0
    JSR jumpline
    MOVEM.l (a7)+,d2-d7/a1/a5-a6
   'no:
    RTS

   'nextline
    TST.l (a4)
    BEQ 'l20
    ADDQ.l #1,d3
    MOVE.l (a4),a4
  BRA begin_search

 'l20                                 ;not found search other files
  TST.l clickjump_fromfile
  BNE clickjump_exit
  MOVE.l #1,clickjump_fromfile

  JSR set_pointerbusy
  !basic
  ;TEDSetCurrentLine_ ?comPtr_CurrentSourceLine
  TEDSetCurrentLine{?comPtr_CurrentSourceLine}
  Gosub getstring_new2
  word1$ = dos_Trim{actualword$}
  ;  !cout{word1$}
  ; -- searching in HelpIndexFile for macro or function name
;  fid.l = file_Open{HelpIndexFile$,#file_read}
;  If (fid<>-1) AND (dos_Trim{word1$} <> "")
;    file_Cache{fid}
;    CaseSense Off
;    temp_lof.l = file_GetLength{fid}
;    Repeat
;      a$ = file_ReadLine{fid}
;      entry$ = Mid$(a$,12,50)
;      entry$ = dos_Trim{entry$}
;      If entry$
;        If Left$(a$,4) = "file"
;          filename$ = entry$
;        EndIf
;
;        If Instr(entry$,word1$) OR Instr(filename$,word1$)
;          file_Close{fid}
;          Pop Repeat
;          temp_filename$ = dos_AddPart{includedir$,filename$}
;          GetD0 &temp_filename$
;          !asm
;          JSR loadfile
;          JSR update_vertscroller
;          JSR update_statusline
;          JSR set_pointernormal
;          ; --
;          ; -- jump to first line of source and search again
;          MOVEA.l comPtr_CurrentSourceLine,A4
;          JSR reset_currsourceline
;          MOVEQ #0,D3
;          BRA begin_search
;        EndIf
;      EndIf
;    Until file_GetSeekPos{fid} = temp_lof
;    file_Close{fid}
;  End If

  ; actually, now that we have everything in cache, do this: (Thilo)
  found.l = False
  If word1$><""
    ResetList HelpIndexCache()
    While NextItemFast(HelpIndexCache()) AND found=False
      If word1$=HelpIndexCache()\name OR word1$=HelpIndexCache()\includefile
        temp_filename$ = dos_AddPart{includedir$,HelpIndexCache()\includefile}
        found=True
        ;error{"Looking for "+temp_filename$+" (from search string"+word1$+"=="+HelpIndexCache()\name+")"}
        GetD0 &temp_filename$
        !asm
        JSR loadfile
        JSR update_vertscroller
        JSR update_statusline
        JSR set_pointernormal
        !basic
      End If
    Wend
  End If

  If found
    !asm
    ; -- jump to first line of source and search again
    MOVEA.l comPtr_CurrentSourceLine,A4
    JSR reset_currsourceline
    MOVEQ #0,D3
    BRA begin_search
    !basic
  End If

  !asm
  clickjump_exit:
  JSR set_pointernormal
  MOVE.l olda4,a4
  MOVEM.l (a7)+,d2-d7/a1/a5-a6
RTS

clickjump_fromfile: Dc.l 0

.jumpline     ; D0: Zielzeile
  CMP.l comLong_TotalLines,d0
  BGE 'ret
  MOVEA.l comPtr_CurrentSourceLine,A4
  JSR cursor_off
  CLR.w comWord_Column
  CLR.w comWord_ColumnsOffset
  JSR gotoline
  ;JSR cursor_on
  ;JSR linetext
  JSR update_vertscroller
;  JSR _redraw
;  JSR cursor_on_force
 'ret:
RTS

.diag_help                ;ctr help
  MOVE.l a0,d0
  !basic
  If diag.l = 0
    WZWindow WZID("WIN_HELPDIAG"),?wzgui,80,wtemp\diag_x,wtemp\diag_y,wtemp\diag_w,wtemp\diag_h,WZID("WIN_HELPDIAG")
    diag = 1
  End If
  Gosub diag_redraw
;  activategadget{"val1"}
  !asm
RTS


.diag_redraw
  If diag = 0 Then Return
  ;Gosub getactualword
  Gosub getstring_new2   ; getstring_new2 should be better (uses preprocessor)
  w$ = actualword$
  tokname$ = actualword$
  res$ = ""
  MOVE.l comPtr_TokenBase,token@(a5)
  While token.l
    b$ = Peek$(token+6)
    If b$ = w$
      res$ = Peek$(token+7+Len(b$))
      i = Instr(res$,";")
      If i Then res$ = Left$(res$,i)
    End If
    token = Peek.l(token)
  Wend
  If res$ = ""
    MOVE.l comPtr_MacroBase,a0:MOVE.l (a0),token@(a5)
    c.l = 0
    While token
      b$ = Peek$(token+13)
      If b$ = w$
        i = Peek.w(token+8)
        If i>100 Then i = 100
        res$ = Peeks$(Peek.l(token+4),i)
        res$ = Replace$(res$,";","")
        i = Instr(res$,"}")
        If i Then res$ = Left$(res$,i)
      End If
      token = Peek.l(token)
    Wend
  End If
  addcodesize.l = 0:linesize.l = 0
  If res$<>""
       Use Window WZID("WIN_HELPDIAG")
       tokname$ + "   " + res$
       WZPrint "DIAG_TOKEN",&tokname$
       InitArgParse res$
       For i =  1 To 12
       diag_lab$(i) = NextArgChar$ (@",")
       If diag_lab$(i) = "[" Then i = i-1:diag_lab$(i)+"["
       WZPrint "lab"+UStr$(i),&diag_lab$(i)
       diag_val$(i) = ""
       WZPrint "val"+UStr$(i),&diag_val$(i)
       Next
       linesize.l = 0
       MOVEA.l textbufferaddr,A0
       ADDA.w comWord_TextBufferOffset,A0
       MOVE.l a0,a1
       ADD.w comWord_MaxColumns,a1
       SUBQ.l #1,a1
's2    CMP.b #" ",(a1)
       BNE 's1
       SUBQ.l #1,a1
       CMP.l a0,a1
       BNE 's2
's1    SUB.l a0,a1
       MOVE.l a1,d1
       MOVE.l d1,linesize@(a5)
       ;MOVE.l comPtr_CurrentSourceLine,a0
       ;LEA 9(a0),a0
       MOVE.w comWord_Column,d0
       BEQ 'l3
'l1    CMP.b #" ",0(a0,d0)
       BEQ 'l2
       CMP.b #"{",0(a0,d0)
       BEQ 'l2
       TST.b 0(a0,d0)
       BMI 'l3
       ADDQ.w #1,d0
       BNE 'l1
'l3    ADDQ.w #1,d0
       CMP.b #":",0(a0,d0)
       BEQ 'q
       CMP.b #";",0(a0,d0)
       BEQ 'q
       CMP.w d1,d0
       BEQ 'q
       CMP.b #" ",0(a0,d0)
       BEQ 'l2
       CMP.b #"(",0(a0,d0)
       BEQ 'l2
       CMP.b #"{",0(a0,d0)
       BEQ 'l2
       BRA 'l3
'q     RTS
'l2    ADD.l d0,a0
       MOVE.l #MAX_Columns,d0
       SUB.w comWord_Column,d0
       SUBQ.l #1,d0
'la1   CMP.b #$20,(a0)+
       BNE 'la2
       SUBQ.l #1,d0
       BNE 'la1
'la3   CMP.b #$20,-(a0)
       BEQ 'la3
       ADDQ.l #3,a0
'la2   MOVE.l a0,d0
       addcodepos.l = PutD0-1
       MOVE.l addcodepos@(a5),a0
       SUBQ #2,a0
       SUB.l textbufferaddr,A0
       SUB.w comWord_TextBufferOffset,A0
       MOVE.l a0,d0
       SUB.l d0,linesize@(a5)
       If linesize >1 Then linesize-1
       If linesize >0 Then res$ = Peeks$(addcodepos,linesize):Else res$ = ""
       i.l = 0:i2.l = 0
       Repeat
       w.l = PeekUB(&res$+i)
       If w = $22 Then i2 BitChg 0
       If i2 = 0
          If w>$80 Then Poke.b &res$+i,w BitClr 7
          If w = @";" OR w = @":" Then w = 0:
       End If
       i+1
       Until w = 0
       addcodesize.l = i
       addstr$ = ""
       If i Then res$ = Left$(res$,i-1)
       If Peek.b (&res$) = @"(" Then res$ = Right$(res$,Len(res$)-1):addstr$ = "("
       If Peek.b (&res$) = @"{" Then res$ = Right$(res$,Len(res$)-1):addstr$ = "{"
nopeek:  InitArgParse res$
       For i = 1 To 12
       diag_val$(i) = NextArgChar$(@",","{[(\\22",")]}\\22")
       If diag_lab$(i)<>"" Then WZPrint "val"+UStr$(i),&diag_val$(i)
       Next
 EndIf
RTS

.newhelp:
  !basic
  Request "debug","old newhelp routine called.","  Ok  "
  !asm
RTS

.help_checkfortype:
  MOVE.w comWord_Column,d1
  MOVE.w d1,columnstore
  SUBQ.w #2,d1
  BGT 'w1
  MOVEQ #1,d1
 'w1
  MOVE.l textbufferaddr,a0
  ADD.w comWord_TextBufferOffset,a0
  MOVE.l a0,a1
  SUBQ.l #1,a1
  ADD.w comWord_Column,a0
  CMP.b #"\",-1(a0)
  BEQ typehelp1
  CMP.b #"\",(a0)
  BEQ typehelp2
;  BRA notypehelp
  RTS

  typehelp1:
  SUBQ #1,a0
  typehelp2:
  CMP.b #$20,-(a0)
  BNE 't2b
  CMP.l a0,a1
  BNE typehelp2
 't2b
  CMP.b #")",(a0)
  BNE 't2
 'rb
  CMP.b #"(",-(a0)
  BEQ 't2c
  CMP.l a0,a1
  BNE 'rb
 't2c
  SUBQ.l #1,a0
 't2
  CMP.b #"_",(a0)
  BEQ 'ok
  CMP.b #$30,(a0)
  BLT 'path
  CMP.b #":",(a0)
  BLT 'p2
  CMP.b #"A",(a0)
  BLT 'path
 'p2
  CMP.b #"z",(a0)
  BGT 'path
 'ok
  MOVEQ #0,d0
  LEA chartab,a1
  ADDQ.l #1,a0
 'x1
    MOVE.b -(a0),d0
    TST.b 0(a1,d0)
    BNE 'x
  BRA 'x1
 'x
  CMP.b #"*",d0
  BEQ 'x1
  CMP.b #".",d0
  BNE 't1
  MOVE.w d1,comWord_Column
  BSR arexxfunc_getword
  MOVE.w columnstore,comWord_Column
  BRA typehelp
 't1
  MOVE.l a2,-(a7)
  LEA typestr,a2
  ADDQ.l #1,a0
 'x111
    MOVE.b (a0)+,d0
    TST.b 0(a1,d0)
    BNE 'xc
   'x12
    MOVE.b d0,(a2)+
  BRA 'x111
 'xc
  CMP.b #"*",d0
  BEQ 'x12
  CLR.b (a2)
  MOVE.l comPtr_CurrentSourceLine,a0
  JSR gettype
  TST.l d0
  BNE 'found
  JSR findvar
 'found
  MOVE.l (a7)+,a2
  LEA typestr,a0
  BRA typehelp
 'path
  MOVE.l comPtr_CurrentSourceLine,a0
 'nl2
  MOVE.l 4(a0),d0
;  BEQ notypehelp
  RTS

  MOVE.l d0,a0
  LEA 9(a0),a1
 'l1
    MOVE.b (a1)+,d0
    BEQ 'nl
    CMP.b #$80,d0
    BNE 'l1
    MOVE.b (a1)+,d0
    CMP.b #$ca,d0            ;find usepath
  BNE 'l1
 'u1
    CMP.b #$20,(a1)+
  BEQ 'u1
  MOVE.l a2,-(a7)
  MOVE.l a0,-(a7)
  LEA typestr,a0
  LEA chartab,a2
  MOVEQ #0,d0
  SUBQ.l #1,a1
 'n2
  MOVE.b (a1)+,d0
  CMP.b #"*",d0
  BEQ 'do2
  TST.b 0(a2,d0)
  BNE 'n1
 'do2
  MOVE.b d0,(a0)+
  BRA 'n2
 'n1
  CLR.b (a0)+
  MOVE.l (a7)+,a0
  JSR gettype
  TST.l d0
  BNE 'found2
  JSR findvar
 'found2
  MOVE.l (a7)+,a2
  LEA typestr,a0
  BRA typehelp
 'nl
  BRA 'nl2
  ;  BRA notypehelp
  RTS

  gettype:
  MOVEM.l a0-a1,-(a7)
  LEA typestr,a2
 'nl2
  MOVE.l 4(a0),d0
  BEQ 'exit
  CLR.b deftypefound
  MOVE.l d0,a0
  LEA 9(a0),a1
 'l1
  MOVE.b (a1)+,d0
  BEQ 'nl
  CMP.b #$80,d0
  BNE 'notok
  MOVE.b (a1)+,d0
  CMP.b #$33,d0            ;find deftype
  BNE 'notok
  MOVE.b #1,deftypefound
 'notok
  CMP.b (a2),d0
  BNE 'l1
  MOVE.l a1,d1
  SUB.l #10,d1
  SUB.l a0,d1
  BEQ 'bg1
  CMP.b #",",-2(a1)
  BEQ 'bg1
  CMP.b #" ",-2(a1)
  BNE 'l1
 'bg1 ADDQ.l #1,a2
 'l2 MOVE.b (a2)+,d0
  BEQ 'f1
  CMP.b (a1)+,d0
  BEQ 'l2
  LEA typestr,a2
  BRA 'l1
 'f1
 'r1 CMP.b #$20,(a1)+
  BEQ 'r1

  SUBQ.l #1,a1
  TST.b deftypefound
  BEQ 'nod
  LEA 9(a0),a1
 'lop MOVE.b (a1)+,d0
  BEQ 'nl
  CMP.b #".",d0
  BNE 'lop
  SUBQ.l #1,a1
 'nod
  CMP.b #".",(a1)+
  BEQ 'c1
  LEA typestr,a2
  BRA 'l1
 'c1
  LEA typestr,a2
  LEA chartab,a0
  MOVEQ #0,d0
 'loop
  MOVE.b (a1)+,d0
  TST.b 0(a0,d0)
  BNE 'e1
  MOVE.b d0,(a2)+
  BRA 'loop
 'e1
  CLR.b (a2)+
  MOVEM.l (a7)+,a0-a1
  MOVEQ #1,d0
  RTS
 'nl
  BRA 'nl2
 'exit
  MOVEM.l (a7)+,a0-a1
  MOVEQ #0,d0
RTS

;.notypehelp
.help_checkforif
  actline.l   = ?comPtr_CurrentSourceLine
  nestcount.b = 1
  Repeat
    iffound.b = 0
    *textline.l = Peek.l(actline) + 9

    ; kill any spaces before Token
    testaddr.l = Peek.l(*textline) : bytecount = 0
    While (testaddr LSR 16) <> $0000
      testaddr = Peek.l(*textline + bytecount)
      actword.w = testaddr LSR 16

      ; check the token for parts of an if-loop
      Select actword
      Case $80C0    ; EndIf
        nestcount + 1

;      Case $8002    ; End
;        nestcount + 1

      Case $800b    ; If
        nestcount - 1
        iffound  = 1

      Case $8021    ; Then
        nestcount + 1
      End Select

;      !cout{nestcount, Hex$(testaddr),linestr$}
      bytecount + 1
    Wend
    If (nestcount = 1) Then Pop Repeat : Goto foundif

    ; get previous line pointer
    actline.l = Peek.l(actline) + 4
  Until Peek.l(actline) = 0
  foundif:
  If (iffound = 1)
    *detokened.l = TEDDetoke{*textline}
    ;*detokened.l = TEDDetoke_(*textline)
    linestr$ = StripLead$(Peek$(*detokened),31)
    PrintScreenTitle{"Corresponding Header: " + linestr$}
  EndIf
Return

; the bubble help is acutally not used (Thilo)
.showbubblehelp
; If ReadFile(0,HelpIndexFile$)
;   FileInput 0
;   b2$ = "!" + b$
;   Repeat
;     a$ = Edit$("",200)
;     If Left$(a$,5) = "file " Then libfile$ = Mid$(a$,12)
;     c$ = Mid$(a$,12,50)
;     c$ = StripTrail$(c$,32)
;     If c$ = b$ OR c$ = b2$
;       command$ = c$ + Mid$(a$,62)
;       c$ = c$+" ;"+Mid$(a$,62)
;;       MOVE.l (a2),d1
;;       MOVEQ #0,d0
;;       JSR showtitle
;       MOVE.l a0,-(a7)
;       i = 0:help$(0) = ""
;       fontheight.l = Peek.w(?fontheight)
;       fontwidth.l = Peek.w(?fontwidth)
;       textwidth.l = (StrLen(libfile$)+12) * fontwidth
;       morehelp:
;       a$ = Edit$("",200)
;       If Left$(a$,2) = ";/"
;         help$(i) = Mid$(a$,3)
;         textwidth2.l = (StrLen(help$(i))+3)*fontwidth
;         If textwidth2>textwidth Then textwidth = textwidth2
;         i+1
;         If i < 398 Then Goto morehelp
;       End If
;       For i2 = i To 398:help$(i2) = "" : Next
;       CloseFile 0
;       fontheight.l = Peek.w(?fontheight)
;       sourcewiny.l = Peek.w(?win_TopEdge)
;       ypos.l = Peek.l (?comLong_DisplayLine)*fontheight+fontheight*3+sourcewiny
;       help2_y.l = ypos
;
;       DEFTYPE.List helpme
;       WZListRemove helpme
;       WZWindow WZID("WIN_CONTEXTHELP") ,?wzgui,4,8,help2_y,48 + textwidth,64 + (fontheight+1) * (i+1),WZID("WIN_CONTEXTHELP")
;       WTitle libfile$
;       WZPrint "HELP_OBJECT",&command$
;       If help$(0) <> ""
;         For i = 0 To 398
;           If help$(i)<>""
;             WZListAdd helpme.List,help$(i),-2
;           EndIf
;           If help$(i+1) = "" Then i = 500
;         Next
;      Else
;        WZListAdd helpme.List,"No context help available."
;      End If
;      WZPrint "HELPDESK",-1,&helpme
;
;       MOVE.l (a7)+,a0
;       MOVE.l a0,d0
;       RTS
;     End If
;   Until Eof(0) = True
;  CloseFile 0
; End If


;   b2$ = "!" + b$
  error{"Bubble hlep!?"}
   ResetList HelpIndexCache()
   While NextItemFast(HelpIndexCache())
     If b$=HelpIndexCache()\name

     End If
   Wend
;     a$ = Edit$("",200)
;     If Left$(a$,5) = "file " Then libfile$ = Mid$(a$,12)
;     c$ = Mid$(a$,12,50)
;     c$ = StripTrail$(c$,32)
;     If c$ = b$ OR c$ = b2$
;       command$ = c$ + Mid$(a$,62)
;       c$ = c$+" ;"+Mid$(a$,62)
;;       MOVE.l (a2),d1
;;       MOVEQ #0,d0
;;       JSR showtitle
;       MOVE.l a0,-(a7)
;       i = 0:help$(0) = ""
;       fontheight.l = Peek.w(?fontheight)
;       fontwidth.l = Peek.w(?fontwidth)
;       textwidth.l = (StrLen(libfile$)+12) * fontwidth
;       morehelp:
;       a$ = Edit$("",200)
;       If Left$(a$,2) = ";/"
;         help$(i) = Mid$(a$,3)
;         textwidth2.l = (StrLen(help$(i))+3)*fontwidth
;         If textwidth2>textwidth Then textwidth = textwidth2
;         i+1
;         If i < 398 Then Goto morehelp
;       End If
;       For i2 = i To 398:help$(i2) = "" : Next
;       CloseFile 0
;       fontheight.l = Peek.w(?fontheight)
;       sourcewiny.l = Peek.w(?win_TopEdge)
;       ypos.l = Peek.l (?comLong_DisplayLine)*fontheight+fontheight*3+sourcewiny
;       help2_y.l = ypos
;
;       DEFTYPE.List helpme
;       WZListRemove helpme
;       WZWindow WZID("WIN_CONTEXTHELP") ,?wzgui,4,8,help2_y,48 + textwidth,64 + (fontheight+1) * (i+1),WZID("WIN_CONTEXTHELP")
;       WTitle libfile$
;       WZPrint "HELP_OBJECT",&command$
;       If help$(0) <> ""
;         For i = 0 To 398
;           If help$(i)<>""
;             WZListAdd helpme.List,help$(i),-2
;           EndIf
;           If help$(i+1) = "" Then i = 500
;         Next
;      Else
;        WZListAdd helpme.List,"No context help available."
;      End If
;      WZPrint "HELPDESK",-1,&helpme
;
;       MOVE.l (a7)+,a0
;       MOVE.l a0,d0
;       RTS
;     End If
;   Until Eof(0) = True
;  CloseFile 0
; End If




 MOVEQ #0,d0
RTS

.close_bubblehelp
  If WZ_CheckOpen{"WIN_CONTEXTHELP"}
    WZListRemove helpme.List
    WZCloseWindow WZID("WIN_CONTEXTHELP")
  EndIf
RTS

.close_popupwindow
  If Peek.b(?use_intellisense)<>0
    If WZ_CheckOpen{"WIN_POPUP"}
      WZListRemove popupliste
      ClearType popupdata
      WZCloseWindow WZID("WIN_POPUP")
      popup_selected.l = 0
    EndIf
  EndIf
RTS


.findvar
  !basic
  MOVE.l comPtr_VarBase,d0
  BEQ 'oldped
  MOVE.l d0,a0
  CMP.l #0,(a0)
  BEQ 'oldped
  *nt.l = PutD0:*nt = Peek.l(*nt):
  fvar$ = Peek$(?typestr)
  fvar$ = StripLead$(fvar$,@"*")
  While *nt
    a$ = Peek$(*nt+$13)
    If a$ = fvar$
      it.l = Peek.l(*nt+10)
      If it
        Poke$ ?typestr,Peek$(it+$b)
      End If
    End If
    *nt = Peek.l(*nt)
  Wend
 'oldped
  !asm
RTS

.typehelp
  MOVE.l a0,d0
  !basic
  i = PutD0
  str2$ = Peek$(i)
  a$ = str2$
  If NOT WZ_CheckOpen{"WIN_NEWTYPE"}
    WZWindow WZID("WIN_NEWTYPE"),?wzgui,255,\type_x,\type_y,\type_w,\type_h,WZID("WIN_NEWTYPE")
    SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    ;GTSetMenuChecked 0,5,9,On
    MOVE.l comPtr_VarBase,d0
    BEQ 'oldped
    MOVE.l d0,a0
    CMP.l #0,(a0)
    BNE 'nocompile
    WTitle "Compile the file to see all"
    'nocompile
    'oldped
    Gosub activatesource
  End If
  Use Window WZID("WIN_NEWTYPE")
  WZPrint "STRING2",&str2$
  WZPrint "newtype_const",0
  WZPrint "newtype_var",0
  WZPrint "newtype_struct",1
  newtype_mode = 2

  lev.l = 0
  find.l = 0
  Gosub newtype_selecttype
  lev = 1
  MOVE.l newtypebase,d0
  *nt.l = PutD0
  If *nt
    *nt = Peek.l(*nt):
    While *nt
      b$ = Peek$(*nt+11)
      If b$ = a$:
        quicktype = 1:*nt2(lev) = Peek.l(*nt+4):Gosub newtype_listsubtype:find = 1:Pop If:Goto f1ab
      End If
      *nt = Peek.l(*nt)
    Wend
  EndIf
  quicktype = 0
  f1ab:
  !asm
RTS

.open_librarybrowser:
;  If NOT WZ_CheckOpen{"WIN_LIBRARYBROWSER"}
    WZWindow WZID("WIN_LIBRARYBROWSER"),?wzgui,255,\lbrowser_x,\lbrowser_y,\lbrowser_w,\lbrowser_h,WZID("WIN_LIBRARYBROWSER")
    Use Window WZID("WIN_LIBRARYBROWSER")
    WZ_InitTable{"WIN_LIBRARYBROWSER","FUNCTIONSTABLE",2}
    WZ_SetTableTitle{"FUNCTIONSTABLE","Function","Syntax"};,"Library"}
    WZ_SetPriority{"FUNCTIONSTABLE",2,3}
    WZ_DrawTable{"FUNCTIONSTABLE"}
    Gosub update_librarylist
    Gosub update_functiontable
;  Else
    Use Window WZID("WIN_LIBRARYBROWSER")
    Activate WZID("WIN_LIBRARYBROWSER")
    WZ_UpdateTable{"FUNCTIONSTABLE"}
;  End If
Return


.event_librarybrowser:
; swaped the Select functions to remove the undefind situation of the Tableevent if the the window get closed this remove the Hits i had  tomsmart1

  ; check for events occured with the functiontable
  wev.l = WZ_CheckTableEvent{ev}
  Select wev

    Case #WZTABLEEVENT_CELLSELECTED
      pos.l = WZ_Row{"FUNCTIONSTABLE"}
      actualword$ = WZ_GetCell{"FUNCTIONSTABLE",WZ_Row{"FUNCTIONSTABLE"},1}
      If actualword$<>""
        libinfo$ = lib_mapping$(libnumber.l,0)+" (LibNr. "+Str$(libnumber)+" Token "+Hexw$(TED_GetTokenID{?comPtr_TokenBase,actualword$}) +")"
        WZPrint "ARGS_LIBRARYNAME",&libinfo$
      EndIf

    Case #WZTABLEEVENT_DOUBLECLICK
      pos = WZ_Row{"FUNCTIONSTABLE"}
      actualword$ = WZ_GetCell{"FUNCTIONSTABLE",WZ_Row{"FUNCTIONSTABLE"},1}
      If actualword$<>""
        Gosub instructionbrowser_startguide
      EndIf

  End Select

  Select ev
    Case #IDCMP_IDCMPUPDATE
      Select WZGadName

        Case "LIST_LIBRARIES"
          Gosub update_functiontable

        Case "CYCLE_SORTORDER"
          Gosub update_librarylist
          Gosub update_functiontable

        Case "BUTTON_LIB_FREEIDS"
          message$ = !TRANS{"The following lib-IDs are not in use:"}+"\\n\\n"
          For i = 1 To 255
            If Instr(lib_mapping$(i,0),"unused")<>0
              message$ + Str$(i)+ "  "
            EndIf
          Next i
          WZ_LockWindow{"WIN_LIBRARYBROWSER"}
          dummy = RTEZRequest("",message$,"_Ok")
          WZ_UnlockWindow{"WIN_LIBRARYBROWSER"}

        Case "BUTTON_LIB_CHECK_CONSISTENCY"
          WZ_LockWindow{"WIN_LIBRARYBROWSER"}
          WZ_ShowMessage{!TRANS{"Checking BlitzLib consistency..."},1}
          message$ = ""
          For i = 0 To 255 : lib_check(i)=False : Next i
          ;DEFTYPE.tokendata tokeninfo
          *tpointer.l = Peek.l(?comPtr_TokenBase)
;          fid = file_Open{"ram:tokenlist.csv",#file_forcewrite}
          Repeat
            tokeninfo\next_token = Peek.l(*tpointer)
            tokeninfo\number     = Peek.w(*tpointer+4)
            tokeninfo\name       = Peek$(*tpointer+6)
            tokeninfo\help       = Peek$(*tpointer+6+FLen(tokeninfo\name)+1)
            libID.l = (tokeninfo\number LSR 7)

            If libID.l<>olibID.l
              If lib_check(libID) = False
                lib_check(libID) = True
;                If fid<>-1 Then file_WriteLine{fid,LSet$(lib_mapping$(libID),30)+";"+LSet$(tokeninfo\name,30)+";"+Str$(tokeninfo\number)}
              Else
                For i = 0 To 255
                  If lib_mapping$(i,1) = tokeninfo\name
                    old_libname$ = StripTrail$(UnRight$(lib_mapping$(i,0),Instr(lib_mapping$(libID,0),"with ")+4),Asc(")"))
                    Pop If : Pop For : Goto exit_for2
                  EndIf
                Next i
                exit_for2:
                error_libname$ = Left$(lib_mapping$(libID,0),Instr(lib_mapping$(libID,0)," ")-1)
                message$ + "+ " + old_libname$ + " has been overwritten by\\n"
                message$ + "\\22" + error_libname$ + "\\22 with same LibID: "+Str$(libID)+"\\n\\n"
              EndIf
              olibID = libID
              !WZ_GaugeInfo{&lib_mapping$(libID,0)}
            EndIf
            *tpointer.l = tokeninfo\next_token
          Until (*tpointer = 0)

;          file_Close{fid}
          WZ_HideMessage{}
          If message$=""
            message$ = !TRANS{"The internal library structure seems to be correct."}
          EndIf
          dummy = RTEZRequest("",message$,"_Ok")
          WZ_UnlockWindow{"WIN_LIBRARYBROWSER"}

      End Select

    Case #IDCMP_CLOSEWINDOW:
      WZ_KillTable{"FUNCTIONSTABLE"}
      WZCloseWindow WZID("WIN_LIBRARYBROWSER")
      WZListRemove libslist.List

  End Select

Return


.update_librarylist:
  sortorder.b = WZInput("CYCLE_SORTORDER")
  WZListRemove libslist.List
  Format "000"
  For i = 0 To 255
    If Instr(lib_mapping$(i,0),"unused") = 0
      If sortorder = 0
        WZListAdd libslist.List,lib_mapping$(i,0),-1,i
      Else
        WZListAdd libslist.List,Str$(i)+ " | "+ lib_mapping$(i,0),-1,i
      EndIf
    EndIf
  Next i
  Format ""
  WZPrint "LIST_LIBRARIES",0,libslist
Return


.update_functiontable:
  selected.l = WZInput("LIST_LIBRARIES")
  libnumber = WZListData(libslist,selected)
  libinfo$ = lib_mapping$(libnumber,0)+" (LibNr. "+Str$(libnumber)+")"

  WZPrint "ARGS_LIBRARYNAME",&libinfo$

  WZ_ClearTable{"FUNCTIONSTABLE"}
;  DEFTYPE.tokendata tokeninfo
  MOVE.l comPtr_TokenBase,D0    : tokenbase.l = PutD0
  If tokenbase<>0
    *tpointer.l = tokenbase : tfound.b = False : tcounter.l = 0 : tname$ = ""
    Repeat
      tokeninfo\next_token = Peek.l(*tpointer)
      tokeninfo\number     = Peek.w(*tpointer+4)
      tokeninfo\name       = Peek$(*tpointer+6)
      tokeninfo\help       = Peek$(*tpointer+6+FLen(tokeninfo\name)+1)

      If (tokeninfo\number LSR 7) = libnumber
        WZ_AddRow{"FUNCTIONSTABLE",tokeninfo\name,tokeninfo\help}
      EndIf
      *tpointer.l = tokeninfo\next_token : tcounter + 1
    Until (*tpointer = 0)
  EndIf
  WZ_TableSort{"FUNCTIONSTABLE",1}
  WZ_UpdateTable{"FUNCTIONSTABLE"}
Return


.open_instructionbrowser
  Gosub close_popupwindow
  If NOT WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"} ; thilo: why this was commented out!?
    WZWindow WZID("WIN_INSTRUCTIONBROWSER"),?wzgui,255,wtemp\ibrowser_x,wtemp\ibrowser_y,wtemp\ibrowser_w,wtemp\ibrowser_h,WZID("WIN_INSTRUCTIONBROWSER")
    Use Window WZID("WIN_INSTRUCTIONBROWSER")
    If search_instruction$<>"" Then WZPrint "INSTRUCTION_STRING",search_instruction$
    WZPrint "macros",browse_macros
    WZPrint "instr",browse_instructions
    WZPrint "incdir",browse_includes
    WZ_InitTable{"WIN_INSTRUCTIONBROWSER","INSTRUCTIONTABLE",2}
    WZ_SetTableTitle{"INSTRUCTIONTABLE","Function","Syntax"};,"Library"}
    WZ_SetPriority{"INSTRUCTIONTABLE",2,3}
    WZ_DrawTable{"INSTRUCTIONTABLE"}
    previoussearch_instruction$="|"
    Gosub update_instructiontable
  Else
    Use Window WZID("WIN_INSTRUCTIONBROWSER")
    Activate WZID("WIN_INSTRUCTIONBROWSER")
    WZ_UpdateTable{"INSTRUCTIONTABLE"}
    WZPrint "INSTRUCTION_STRING",search_instruction$
  End If
  activategadget{"INSTRUCTION_STRING"}
RTS


.event_instructionbrowser
  ; TAB
  If RawKeyState($42)  Then Gosub activatesource : ev = 0
  ; ESC
  If RawKeyState($45)  Then ev = #IDCMP_CLOSEWINDOW

; swaped the Select functions to remove the undefind situation of the Tableevent if the the window get closed this remove the Hits i had  tomsmart1

  ; check for events occured with the instructiontable
  wev.l = WZ_CheckTableEvent{ev}
  Select wev

    Case #WZTABLEEVENT_CELLSELECTED
      MOVE.l comPtr_TokenBase,token@(a5)
      MOVE.l comPtr_TokenBase,d0 : *tokenbase = PutD0
      b$ = WZ_GetCell{"INSTRUCTIONTABLE",WZ_Row{"INSTRUCTIONTABLE"},1}
      bstr$ = b$
      While token
        If b$ = Peek$(token+6) Then Pop While: Goto tfound
        token = Peek.l(token)
      Wend

     tfound:
      If token
        tok.l = Peek.w(token+4)
        iinfo$ = "Library: " + TED_GetLibname{tok LSR 7}
        iinfo$ + " - LibNr.: "+Str$(tok LSR 7)+" - TokenID: "+Hexw$((tok AND $7f)-1)+" - MemPointer $"+Hex$(tok)
      Else
        iinfo$ = "Include: " + TED_GetIncludeName{bstr$}
      EndIf
      WZTags #WARGSA_TextPen,2
      WZPrint "INSTRUCTION_INFO",&iinfo$

    Case #WZTABLEEVENT_DOUBLECLICK
      pos = WZ_Row{"INSTRUCTIONTABLE"}
      actualword$ = WZ_GetCell{"INSTRUCTIONTABLE",WZ_Row{"INSTRUCTIONTABLE"},1}
      Gosub instructionbrowser_startguide

  End Select

  Select ev

    Case #IDCMP_INTUITICKS
      Gosub update_instructiontable

    Case #IDCMP_CLOSEWINDOW:
      wtemp\ibrowser_x = WindowX
      wtemp\ibrowser_y = WindowY
      wtemp\ibrowser_w = WindowWidth
      wtemp\ibrowser_h = WindowHeight
      WZ_KillTable{"INSTRUCTIONTABLE"}
;      ClearMenuStrip_ Peek.l(Addr Window(WZID("WIN_INSTRUCTIONBROWSER")))
      WZCloseWindow WZID("WIN_INSTRUCTIONBROWSER")

    Case #IDCMP_RAWKEY:
      Select EventCode

        Case  $45
          WZ_KillTable{"INSTRUCTIONTABLE"}
;          ClearMenuStrip_ Peek.l(Addr Window(WZID("WIN_INSTRUCTIONBROWSER")))
          WZCloseWindow WZID("WIN_INSTRUCTIONBROWSER")

      End Select

    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "add" ;addcode
          a$ = bstr$
          !asm
          MOVE.l textbufferaddr,a0
          ADD.w comWord_TextBufferOffset,a0
          ADD.w comWord_ColumnsOffset,a0
          ADD.w comWord_Column,a0
          CMP.b #" ",(a0)
          BEQ nocharunder
          MOVEQ #-1,d0

         'loop
          ADDQ.l #1,d0
          CMP.b #" ",(a0)+
          BNE 'loop
          i2 = PutD0
          JSR cursor_off
          !basic
          For i = 1 To i2
            JSR deletechar
          Next
          !asm
          JSR cursor_on
          
         nocharunder:
          !basic
          Gosub insertstring
          JSR activatesource

        Case "macros"
          browse_macros = WZInput
          previoussearch_instruction$ = "|"
          activategadget{"INSTRUCTION_STRING"}

        Case "instr"
          browse_instructions = WZInput
          previoussearch_instruction$ = "|"
          activategadget{"INSTRUCTION_STRING"}

        Case "incdir"
          browse_includes = WZInput
          previoussearch_instruction$ = "|"
          activategadget {"INSTRUCTION_STRING"}

      End Select

  End Select

Return


.update_instructiontable
  search_instruction$ = WZGetString("INSTRUCTION_STRING")
  If (search_instruction$<>previoussearch_instruction$) AND (Len(search_instruction$) > 1)
    previoussearch_instruction$ = search_instruction$
    WZ_ClearTable{"INSTRUCTIONTABLE"}
    InitArgParse search_instruction$
    word1$ = NextArg$
    word2$ = NextArg$
    MOVE.l comPtr_TokenBase,token@(a5)
    numcount.l = 0
    If browse_instructions
      While token
        b$ = Peek$(token+6)
        c$ = Peek$(token+6+Len(b$)+1)
;        d$ = TED_GetLibname{Peek.w(token+4) LSR 7}
        If Instr(b$,word1$) AND numcount < #maxlabels
          If Instr(b$,word2$)
            numcount = numcount+1
            c$ = Peek$(token+7+Len(b$))
            TST.l classiccolor
            BEQ 'nomore
            LEA classiccommands,a0
            MOVE.l token@(a5),a1
            MOVE.w 4(a1),d0
            LSR.w #7,d0

           'again
              MOVE.w (a0)+,d1
              BEQ 'nomore
              CMP.w d1,d0
            BNE 'again

            CMP.l #99,classiccolor
            BEQ 'skip
            ;                  WZTags #WENTRYA_TextPen,Peek.b(?tokencolor)

           'nomore
            ;                  WZListAdd lst,b$
            WZ_AddRow{"INSTRUCTIONTABLE",b$,c$}

           'skip
          End If
        End If
        token = Peek.l(token)
      Wend
    End If
    ;
    If browse_macros
      MOVE.l comPtr_MacroBase,a0:MOVE.l (a0),token@(a5)
      c.l = 0
      While token
        b$ = Peek$(token+13)
;        !cout{word1$,b$}
        If Instr(b$,word1$) AND numcount<#maxlabels
          If Instr(b$,word2$)
            numcount = numcount + 1
            i = Peek.w(token+8)
            If i > 90 Then i = 90
            b$ = "!" + b$
            c$ = Peeks$(Peek.l(token+4),i)
            ;                  WZTags #WENTRYA_TextPen,Peek.l(?macrocolor)
            ;                  WZListAdd lst,b$
            WZ_AddRow{"INSTRUCTIONTABLE",b$,c$}
          End If
        End If
        token = Peek.l(token)
      Wend
    End If

    ;
    If browse_includes
;      If ReadFile(0,HelpIndexFile$)
;        FileInput 0
;        Repeat
;          a$ = Edit$("",200)
;          If Instr(a$,".bb2") = 0
;
;           loop2:
;            b$ = Mid$(a$,12,50)
;            If Instr(b$,word1$) AND numcount<#maxlabels
;              If Instr(b$,word2$)
;                numcount = numcount+1
;                ;                    WZTags #WENTRYA_TextPen,Peek.l(?functioncolor)
;                b$ = StripTrail$(b$,32)
;                ;                    WZListAdd lst,b$+" ;"+Mid$(a$,63)
;                WZ_AddRow{"INSTRUCTIONTABLE",b$,Mid$(a$,62)}
;                FileInput 0
;
;               loop1:
;                a$ = Edit$("",200)
;                If Instr(a$,";*") Then Goto loop1
;                If Eof(0) = False Then Goto loop2
;              End If
;            End If
;          EndIf
;        Until Eof(0) = True
;        CloseFile 0
;      End If
      ResetList HelpIndexCache()
      While NextItemFast(HelpIndexCache())
        If Instr(HelpIndexCache()\name,word1$) AND numcount<#maxlabels
          If Instr(HelpIndexCache()\name,word2$)
            numcount = numcount+1
            WZ_AddRow{"INSTRUCTIONTABLE",HelpIndexCache()\name,HelpIndexCache()\help}
          End If
        End If
      Wend
    End If
    pos = 0
    ;          WZPrint "list",pos,lst,0
    WZ_TableSort{"INSTRUCTIONTABLE",1}
    WZ_UpdateTable{"INSTRUCTIONTABLE"}
  Else
    If (search_instruction$<>previoussearch_instruction$) AND (Len(search_instruction$)<2)
      previoussearch_instruction$ = search_instruction$
      WZ_ClearTable{"INSTRUCTIONTABLE"}
     WZ_UpdateTable{"INSTRUCTIONTABLE"}
    EndIf
  End If
Return


.event_popup:
   Select ev

     Case #IDCMP_IDCMPUPDATE
       If Left$(WZGadName,9) = "POPUPMENU"
         popup_selected = WZInput + 1
         popexit.l = True
       EndIf

     Case #IDCMP_MOUSEBUTTONS
;       mb.b = MButtons
;       If (mb = 1) OR (mb=2)
;          popexit = True
;       EndIf

   End Select

   If popexit = True
     a$ = WZ_GetPopUpEntry{popup_selected}
     a$ = dos_Trim{Left$(a$,Instr(a$,"{")-1)}
     If a$<>""
       PrintScreenTitle{a$ + " " + TED_GetIncludeHelp{a$}}
       a$ = UnRight$(a$,Len(poptok$)) + "{"
       Gosub insertstring
     EndIf
     Gosub close_popupwindow
   EndIf
   Gosub activatesource
Return


.insertstring:
  ; --
  ; -- check for a comment
  i = SearchBegin(a$,Asc(";"),1)
  If i
    a$ = Left$(a$,i-2) ;+" "
  End If
;  !cout{a$+"*"}
  GetD0 &a$
  MOVE.l d0,a2
  MOVE.l d7,-(a7)

 'l1
    MOVE.b (a2)+,d7
    BEQ 'e1
    CMP.w #$7d,comWord_Column
    BGE 'e1
    MOVEM.l a2/a5,-(a7)
    JSR insertchar
    MOVEM.l (a7)+,a2/a5
BRA 'l1

 'e1
  MOVE.l (a7)+,d7
Return


.instructionbrowser_startguide   ;actualword$: zu suchende Funktion
  MOVE.l comPtr_TokenBase,token@(a5)
  MOVE.l comPtr_TokenBase,d0 : *tokenbase = PutD0

  b$=actualword$
  While token
    If b$ = Peek$(token+6) Then Pop While:Goto found
    token = Peek.l(token)
  Wend

 found:
  If token
    tok.l = Peek.w(token+4)
    tokname$ = b$
    libnumber = tok LSR 7
    Gosub open_helptool
  Else ;no token, but a function or macro
    tokname$ = b$
    libnumber = 0
    Gosub open_helptool
  End If
Return


.open_helptool:
  tokid.l = TED_GetTokenID{*tokenbase,tokname$}
  libnumber = TED_GetTokenLibnum{*tokenbase,tokname$}
  myhelpdir$ = helpdir$

  ;If tokid <= 0
  ;  tokname$ = Left$(tokname$,FLen(tokname$)-1)
  ;  tokid = TED_GetTokenID{*tokenbase,tokname$}
  ;  libnumber = TED_GetTokenLibnum{*tokenbase,tokname$}
  ;EndIf

  If tokid>0
    If Right$(tokname$,1)="_"
      tokname$ = Left$(tokname$,Len(tokname$)-1)
      helpdir$ = autodocdir$ + " -d " + helpdir$
    EndIf
    libname$ =  lib_mapping$( libnumber,0)
    mostright$ = Right$(libname$,1)
    If mostright$ = "1" OR mostright$ = "2" Then libname$ = Left$(libname$,Len(libname$)-1)
  Else
    libname$ = TED_GetIncludeName{tokname$}
  EndIf

  If Instr(libname$,"unused")=0 AND (libname$<>"")
    Show_Helpfile{libname$,tokname$,Peek$(?str_defaultpubscreen)}
  Else
    search_instruction$ = tokname$
    Gosub open_instructionbrowser
    ;dummy.l = RTEZRequest("","No help available","Ok")
  EndIf
  helpdir$ = myhelpdir$ ; restore standard helpdir$
Return


.open_shortcuts
  If NOT WZ_CheckOpen{"WIN_SHORTCUTS"}
    WZWindow WZID("WIN_SHORTCUTS"),0,255,wtemp\short_x,wtemp\short_y,wtemp\short_w,wtemp\short_h,WZID("WIN_SHORTCUTS")
    If Peek.l(?addr_menustrip) Then SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)

    WZ_InitTable{"WIN_SHORTCUTS","SHORTCUTS",2}
    WZ_SetTableTitle{"SHORTCUTS",!TRANS{"Key"},!TRANS{"Function"}}
    WZ_SetPriority{"SHORTCUTS",1,2}
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<ALT> + Left Mousebutton"}   ,!TRANS{"Jump to label/func"} }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<ALT> + Middle Mousebutton" },!TRANS{"Back from Label/func"}}
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<ALT> + click on a filename"},!TRANS{"save and compile and run (see above)"}  }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<CTRL> + click on filename"} ,!TRANS{"save and create exe(save both if you click on diffrent)"}}
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<CTRL> + <U>" }              ,!TRANS{"undo current line"}   }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<ESC>" }                     ,!TRANS{"closes any active helpwindow"}  }
    WZ_AddRow{"SHORTCUTS","####","####"}
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<ALT> + <CURSOR UP>"}        ,!TRANS{"move history up"}  }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<ALT> + <CURSOR DOWN>"}      ,!TRANS{"move history down"}}
    WZ_AddRow{"SHORTCUTS","####","####"}
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<HELP> + <SHIFT>"  }         ,!TRANS{"opens guide/autodoc of instruction under cursor"} }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<HELP> + <CTRL>"   }         ,!TRANS{"opens parameter diagnostic for actual function"} }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<HELP> on any function"}     ,!TRANS{"displays correct syntax in screens titlebar"}   }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<HELP> on unknown word"}     ,!TRANS{"opens instruction browser"}                      }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<HELP> on '\'"     }         ,!TRANS{"opens window 'type browser' and shows newtype information"} }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<HELP> on 'EndIf" }          ,!TRANS{"shows corresponding IF-Blockheader"} }
    WZ_AddRow{"SHORTCUTS","####","####"}
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<L-Amiga> + <F4>-<F6>"}      ,!TRANS{"save winconfig"}       }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<F4> - <F6>"}                ,!TRANS{"load winconfig (F4 also startconfig)"}   }
;    WZ_AddRow{"SHORTCUTS",!TRANS{ "<F7>" }                      ,!TRANS{"choose next entry in source browser"}    }
;    WZ_AddRow{"SHORTCUTS",!TRANS{ "<F8>" }                      ,!TRANS{"choose previous entry in source browser"} }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<F7>"  }                     ,!TRANS{"window autolayout variant #1"}    }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<F8>"  }                     ,!TRANS{"window autolayout variant #2"} }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<F9>"  }                     ,!TRANS{"goto previous document"}    }
    WZ_AddRow{"SHORTCUTS",!TRANS{ "<F10>" }                     ,!TRANS{"goto next document"} }


    WZ_DrawTable{"SHORTCUTS"}
    WZ_UpdateTable{"SHORTCUTS"}
  EndIf
Return


.event_shortcuts:
; swaped the Select functions to remove the undefind situation of the Tableevent if the the window get closed this remove the Hits i had  tomsmart1

  wev.l = WZ_CheckTableEvent{ev}
;  Select ewv
;  End Select

  Select ev

    Case #IDCMP_CLOSEWINDOW
      WZ_KillTable{"SHORTCUTS"}
      WZCloseWindow WZID("WIN_SHORTCUTS")

  End Select

Return


.open_cliarguments
  If reg_d1
    clistr$ = Peek$(reg_d1)
  Else
    clistr$ = ""
  End If
  old_clistr$ = clistr$
  FindScreen 0
  WZWindow 17,?wzgui,64,-1,-1,-1,-1,17
  If clistr$<>"" Then WZPrint "CLI_ARGUMENTS",&clistr$
  activategadget{"CLI_ARGUMENTS"}
  exit_cli.b = False : get_arguments.b = False
  Repeat
    !ev_WaitEvent

    ; bubble onlinehelp for most windows
   ; If Peek.b(?onlinehelp)<>0
   ;   If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) AND (ev<>#IDCMP_GADGETHELP)  AND (ev<>#IDCMP_CHANGEWINDOW)
   ;     WZ_HideHelp{}
   ;   EndIf
   ;   If ev = #IDCMP_GADGETHELP Then WZ_ShowHelp{}
   ; EndIf

    Select ev

      Case #IDCMP_CLOSEWINDOW
        exit_cli = True

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName

;          Case "CLI_ARGUMENTS"
;            get_arguments = True

          Case "CLI_OK"
            exit_cli = True
            get_arguments = True

          Case "CLI_CANCEL"
            get_arguments = False
            exit_cli = True

        End Select

      Default
        activategadget{"CLI_ARGUMENTS"}

    End Select
  Until exit_cli = True
  If get_arguments = True
    clistr$ = WZGetString("CLI_ARGUMENTS")
    Poke.s reg_d1,Left$(clistr$,127)
  Else
    clistr$ = old_clistr$
  EndIf
  WZCloseWindow 17
Return



.open_calculator
Return




.open_newtype:
   WZWindow WZID("WIN_NEWTYPE"),?wzgui,255,wtemp\type_x,wtemp\type_y,wtemp\type_w,wtemp\type_h,WZID("WIN_NEWTYPE")
   If Peek.l(?addr_menustrip) Then SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)

   ;GTSetMenuChecked 0,5,9,On
   Use Window WZID("WIN_NEWTYPE")
   WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
   WZ_SetTableTitle{"TYPETABLE","Type","Value"}
   WZ_SetTableColors{"TYPETABLE",1,0,1,0}
   WZ_SetPriority{"TYPETABLE",2,1}
   WZ_DrawTable{"TYPETABLE"}

   Select newtype_mode

     Case 0
       WZPrint "STRING2",cstr$
       WZPrint "NEWTYPE_CONST",1
       WZPrint "NEWTYPE_VAR",0
       WZPrint "NEWTYPE_STRUCT",0
       Gosub newtype_listconsts

     Case 1
       WZPrint "STRING2",str2$
       WZPrint "NEWTYPE_CONST",0
       WZPrint "NEWTYPE_VAR",1
       WZPrint "NEWTYPE_STRUCT",0
       Gosub newtype_listvars

     Case 2
       WZPrint "STRING2",str2$
       WZPrint "NEWTYPE_CONST",0
       WZPrint "NEWTYPE_VAR",0
       WZPrint "NEWTYPE_STRUCT",1

       Gosub newtype_selecttype
       a$ = ""
       For i = 1 To lev:
         If i>1
            a$ = a$+"\"+pos$(i):
         Else
            a$ = a$+"."+pos$(i):
         End If
       Next
       typestr$ = a$
       WZTags #WZRD_TEXTPEN,Peek.l(?newtypecolor)
       WZPrint "NEWTYPE_ENTRY",&a$
   End Select

   ActivateGadget_ WZGadAddr ("STRING2"),WZWindowAddr,0
Return


.event_newtype
;  move_cursor{"list2",lst2,-1}
  If RawKeyState($42)  Then Gosub activatesource:ev = 0
  If RawKeyState($45)  Then ev = #IDCMP_CLOSEWINDOW

; swaped the Select functions to remove the undefind situation of the Tableevent if the the window get closed this remove the Hits i had  tomsmart1

  tev.l = WZ_CheckTableEvent{ev}
  If tev = #WZTABLEEVENT_DOUBLECLICK
    Select newtype_mode

      Case 0 ; Constants
        temp$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},1} ;WZListString(lst2.List,WZInput)
        typestr$ = temp$
        WZTags #WZRD_TEXTPEN,Peek.l(?newtypecolor)
        WZPrint "NEWTYPE_ENTRY",&typestr$

      Default
        ;str2$ = "" : str2b$ = ""
        ;WZPrint "STRING2",&str2$
        temp$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},1} ;WZListString(lst2.List,WZInput)
        c2$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},2}
        If c2$<>"" Then c2$ = " ."+c2$
        c3$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},3}
        If c3$<>"" Then c3$ = " $"+c3$
        temp$ + c2$ + c3$

        If newtype_mode = 1 AND lev  = 0
          i = SearchEnd (temp$,@".",1)
          If lev = 0 Then var$ = Left$(temp$,i-1)
          temp$ = Mid$(temp$,i + 1)
        End If

        If newtype_mode <> 1 Then var$ = ""
        a$ = temp$
        lev = lev + 1 : If lev > 13 Then lev = 13
        pos2(lev) = 0
        find = 0
        pos2(lev-1) = WZ_Row{"TYPETABLE"} ;WZListPos("list2")
        t$ = Left$(a$,Instr(a$," ")-1)
        If lev > 1
          i = SearchEnd(a$,Asc("."),1)
          i2 = SearchEnd(a$,Asc("$"),1)
          a$ = Mid$(a$,i+1,i2-i-3)
        End If
        MOVE.l newtypebase,d0
        *nt.l = PutD0
        If *nt
          *nt = Peek.l(*nt):
          While *nt
            b$ = Peek$(*nt+11)
            If b$ = a$
              *nt2(lev) = Peek.l(*nt+4)
              Gosub newtype_listsubtype
              find = 1
              Pop If : Goto f1a
            End If
            *nt = Peek.l(*nt)

           f1a:
          Wend
        Else
          error{"newtypebase = NULL => GURU!!!"}
        End If
        If find = 0
          lev = lev - 1 ;:WZPrint "list2",-1:
          a$ = ""
          For i = 1 To lev:
            If i > 1
               a$ = a$ + "\" + pos$(i):
            Else
               a$ = a$ + "." + pos$(i):
            End If
          Next
          i = Instr(temp$," ")
          temp$ = Replace$ (temp$,"*","")
          typestr$ = var$ + a$ + "\" + Left$(temp$,i)
          WZTags #WZRD_TEXTPEN,Peek.l(?newtypecolor)
          WZPrint "NEWTYPE_ENTRY",&typestr$
        End If

    End Select

  EndIf

  Select ev

    Case #IDCMP_INTUITICKS
      Select newtype_mode

        Case 0
          cpos.l = 0
          cpos.l = WZ_Column{"TYPETABLE"} ;WZListPos ("list2")
          cstr$ = WZGetString("STRING2")
          If cstr$<>cstr2$
            cstr2$ = cstr$
            ;cpos = 0
            Gosub newtype_listconsts
          End If

        Case 1
          str2$ = WZGetString("STRING2")
          If str2$<>str2b$
            str2b$ = str2$
            pos2(lev) = 0
            Gosub newtype_listvars
          End If

        Case 2
          str2$ = WZGetString("STRING2")
          If str2$<>str2b$
            str2b$ = str2$
            find.l = 0
            pos2(lev) = 0
            p$ = str2$
            Gosub newtype_selecttype
          End If

      End Select

    Case #IDCMP_CLOSEWINDOW:
      wtemp\type_x = WindowX
      wtemp\type_y = WindowY
      wtemp\type_w = WindowWidth
      wtemp\type_h = WindowHeight
      WZ_KillTable{"TYPETABLE"}
      WZCloseWindow WZID("WIN_NEWTYPE")
      ;GTSetMenuChecked 0,5,9,Off

    Case #IDCMP_RAWKEY:
      Select EventCode
        ;move_cursor{"list2",lst2,-1}

        Case  $45:
          wtemp\type_x = WindowX
          wtemp\type_y = WindowY
          wtemp\type_w = WindowWidth
          wtemp\type_h = WindowHeight
          WZ_KillTable{"TYPETABLE"}
          WZCloseWindow WZID("WIN_NEWTYPE")
          ;GTSetMenuChecked 0,5,9,Off

      End Select

    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "typeadd"
          a$ = typestr$
          If Instr(a$,"\",StrLen(a$)-1)<>0
            a$ = Left$(a$,StrLen(a$)-1)
          End If
          If quicktype
            a$ = Mid$(typestr$,Instr (typestr$,"\")+1)
          End If
          If newtype_mode <> 1
            a$ = Replace$(a$,"*","")
          End If
          Gosub insertstring
          JSR activatesource

        Case "string2"
         ;JSR activatesource

        Case "parent" :
          quicktype = 0
          If newtype_mode = 0
          Else
            If lev Then lev = lev - 1
            If lev = 0
              If newtype_mode = 1
                Gosub newtype_listvars
              Else
                If str2$<>"" Gosub newtype_selecttype Else Gosub newtype_listtype
              End If
            Else
              a$ = pos$(lev)
              JSR newtype_listsubtype
            End If
            a$ = "":pos$(lev+1) = ""
            For i = 1 To lev:
              If i>1
                a$ = a$+"\"+pos$(i):
              Else
                a$ = a$+"."+pos$(i):
              End If
            Next
            typestr$ = a$
            WZTags #WZRD_TEXTPEN,Peek.l(?newtypecolor)
            WZPrint "NEWTYPE_ENTRY",&a$
          End If

        Case "clear":
          If newtype_mode = 0
            cstr$ = "":
            WZPrint "STRING2",&cstr$
          Else
            str2$ = "":
            Gosub newtype_selecttype
            WZPrint "STRING2",&str2$
          End If

        Case "newtype_const"
          newtype_mode = 0 : Gosub newtype_updatelist

        Case "newtype_var"
          newtype_mode = 1 : Gosub newtype_updatelist

        Case "newtype_struct"
          newtype_mode = 2 : Gosub newtype_updatelist

      End Select

  End Select

Return


.newtype_updatelist
  str2b$ = ""
  WZ_KillTable{"TYPETABLE"}

  Select newtype_mode

    Case 0
      WZPrint "STRING2",cstr$
      WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
      WZ_SetTableTitle{"TYPETABLE","Identifier","Value"}
      WZ_SetTableColors{"TYPETABLE",1,0,1,0}
      WZ_SetPriority{"TYPETABLE",2,1}
      WZ_DrawTable{"TYPETABLE"}

      ptr.l = &str2b$
      If ptr>4096
        WZPrint "NEWTYPE_ENTRY",&str2b$
      Else
        error{"Pointer to str2b$ is not valid! \\22"+str2b$+"\\22"}
      End If

      Gosub newtype_listconsts

    Case 1
      WZPrint "STRING2",str2$
      WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
      WZ_SetTableTitle{"TYPETABLE","Identifier","Value"}
      WZ_SetTableColors{"TYPETABLE",1,0,1,0}
      WZ_SetPriority{"TYPETABLE",1,1}
      WZ_DrawTable{"TYPETABLE"}
      ptr.l = &str2$
      If ptr>4096
        WZPrint "NEWTYPE_ENTRY",&str2$
      Else
        error{"1: Pointer to str2$ is not valid! \\22"+str2$+"\\22"}
      End If

      Gosub newtype_listvars

    Case 2
      WZPrint "STRING2",str2$
      ptr.l = &str2$
      If ptr>4096
        WZPrint "NEWTYPE_ENTRY",&str2$
      Else
        error{"2: Pointer to str2$ is not valid! \\22"+str2$+"\\22"}
      End If

      Gosub newtype_selecttype
      a$ = ""
      For i = 1 To lev:
        If i>1
           a$ = a$+"\"+pos$(i):
        Else
           a$ = a$+"."+pos$(i):
        End If
      Next
      typestr$ = a$
      WZTags #WZRD_TEXTPEN,Peek.l(?newtypecolor)
      WZPrint "NEWTYPE_ENTRY",&a$

  End Select
Return


.newtype_listvars
  WZ_ClearTable{"TYPETABLE"}
  InitArgParse str2$
  word1$ = NextArg$
  word2$ = NextArg$
  MOVE.l comPtr_VarBase,d0
  *nt = PutD0
  If *nt
    *nt = Peek.l(*nt):
    While *nt
      a$ = Peek$(*nt + $13)
      If Peek.w(*nt + 6) AND 2 Then arr$ = "()" Else arr$ = ""
      If Peek.w(*nt + 6) AND 1 Then poin$ = "*" Else poin$ = ""
      If Instr (a$,word1$)
        If Instr(a$,word2$)
          it.l = Peek.l(*nt+10)
          WZ_AddRow{"TYPETABLE",poin$ + a$ + arr$,Peek$(it + $b)}
        EndIf
      End If
      *nt = Peek.l(*nt)
    Wend
  Else
    error{"comPtr_VarBase = NULL => GURU!!!"}
  End If
  WZ_TableSort{"TYPETABLE",1}
  WZ_UpdateTable{"TYPETABLE"}
Return


.newtype_listconsts
  WZ_ClearTable{"TYPETABLE"}
;  !cout{"sdfsfd"}
  If FLen(cstr$) => 2
    InitArgParse cstr$
    word1$ = NextArg$
    word2$ = NextArg$
    MOVE.l constantbase,d0
    *nt = PutD0
    If *nt
      *nt = Peek.l(*nt)
      While *nt
        a$ = Peek$(*nt+$13)
        If Instr (a$,word1$) Then If Instr(a$,word2$)
          WZ_AddRow{"TYPETABLE",a$,"$"+Hex$(Peek.l(*nt+8))}
        End If
        *nt = Peek.l(*nt)
      Wend
    Else
      error{"constantbase = NULL => GURU!!!"}
    End If

  End If

  WZ_TableSort{"TYPETABLE",1}
  WZ_UpdateTable{"TYPETABLE"}
Return


.newtype_listtype
  lev = 0
  WZ_KillTable{"TYPETABLE"}
  WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",1}
  WZ_SetTableColors{"TYPETABLE",1,0,1,0}
  WZ_SetTableTitle{"TYPETABLE","Identifier"}
  WZ_DrawTable{"TYPETABLE"}

  MOVE.l newtypebase,d0
  *nt = PutD0
  If *nt
    *nt = Peek.l(*nt)
    While *nt
      a$ = Peek$(*nt+11)
      WZ_AddRow{"TYPETABLE",a$}
      *nt = Peek.l(*nt)
    Wend
  Else
    error{"newtypebase = NULL => GURU!!!"}
  End If

;  WZ_TableSort{"TYPETABLE",1}
  WZ_UpdateTable{"TYPETABLE"}
Return


.newtype_selecttype
  WZ_KillTable{"TYPETABLE"}
  If lev = 0
    WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",1}
    WZ_SetTableTitle{"TYPETABLE","Identifier"}
    WZ_SetTableColors{"TYPETABLE",1,0,1,0}
    WZ_DrawTable{"TYPETABLE"}
  Else
    WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",3}
    WZ_SetTableTitle{"TYPETABLE","Identifier","Type","Offset"}
    WZ_SetTableColors{"TYPETABLE",1,0,1,0}
    WZ_SetPriority{"TYPETABLE",3,2,2}
    WZ_DrawTable{"TYPETABLE"}
  EndIf

  i = 0
  InitArgParse p$
  word1$ = NextArg$
  word2$ = NextArg$
  If lev
    *nt = *nt2(lev)
    While *nt
      If Peek.w(*nt+6) = 1 Then b$ = "*" Else b$ = ""
      b$ = b$ + Peek$(*nt+15)
      c$ = Peek$(Peek.l(*nt+10)+11)
      If Instr(b$,word1$) Then If Instr(b$,word2$)
        WZ_AddRow{"TYPETABLE",b$,c$,"$"+Right$(Hex$(Peek.w(*nt+4)),4)}
      End If
      b$ + "  ."+c$
      *nt = Peek.l(*nt)
    Wend
  Else
    MOVE.l newtypebase,d0
    *nt = PutD0
    If *nt
      *nt = Peek.l(*nt)
    Else
      error{"newtypebase = NULL => GURU!!!"}
    End If
  End If
  While *nt
    b$ = Peek$(*nt+11)
    If Instr(b$,word1$) Then If Instr(b$,word2$)
      WZ_AddRow{"TYPETABLE",b$,""}
      find = find + 1
      f$ = b$
    EndIf
    *nt = Peek.l(*nt)
  Wend
  WZ_TableSort{"TYPETABLE",1}
  WZ_UpdateTable{"TYPETABLE"}
Return


.newtype_listsubtype
  WZ_KillTable{"TYPETABLE"}
  If lev = 0
    WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",1}
    WZ_SetTableTitle{"TYPETABLE","Identifier"}
    WZ_SetTableColors{"TYPETABLE",1,0,1,0}
    WZ_DrawTable{"TYPETABLE"}
  Else
    WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",3}
    WZ_SetTableTitle{"TYPETABLE","Identifier","Type","Offset"}
    WZ_SetTableColors{"TYPETABLE",1,0,1,0}
    WZ_SetPriority{"TYPETABLE",3,2,2}
    WZ_DrawTable{"TYPETABLE"}
  EndIf

  If lev > 1
    pos$(lev) = t$
  Else
    pos$(lev) = a$
  End If
  a$ = ""
  For i = 1 To lev:
    If i > 1
      a$ = a$+"\"+pos$(i):
    Else
      a$ = a$+"."+pos$(i):
    End If
  Next
  typestr$ = a$
  WZTags #WZRD_TEXTPEN,Peek.l(?newtypecolor)
  WZPrint "NEWTYPE_ENTRY",&a$
  WZ_ClearTable{"TYPETABLE"}
  i = 0
  *nt = *nt2(lev)
  While *nt
    If Peek.w(*nt+6) = 1 Then a$ = "*" Else a$ = ""
    a$ = a$ + Peek$(*nt+15)
    c$ = Peek$(Peek.l(*nt+10)+11)
    WZ_AddRow{"TYPETABLE",a$,c$,"$" + Right$(Hex$(Peek.w(*nt+4)),4)}
    a$ = a$ + " ."+c$
    *nt = Peek.l(*nt)
    i = i + 1
  Wend
  WZ_TableSort{"TYPETABLE",3}
  WZ_UpdateTable{"TYPETABLE"}
Return


.event_diag:
  Select ev

    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "addcode"
          MOVE.l comLong_DisplayLineOffset,d0
          ADD.l comLong_DisplayLine,d0
          CMP.l ctrlhelpline,d0
          BNE skip2
          a$ = addstr$
          For i =  1 To 12
           diag_val$(i) = WZGetString("val"+UStr$(i))
          Next
          For i = 1 To 12
           a$ = a$+diag_val$(i):If diag_val$(i+1) <>"" Then a$ = a$+","
          Next
          If addcodesize >1 Then t$ = Peeks$(addcodepos,addcodesize):Else t$ = ""
          t$ = StripLead$(t$,32)
          MOVE.w comWord_Column,colstore
          JSR cursor_off
          MOVE.l addcodepos@(a5),a0
          SUB.l textbufferaddr,a0
          SUB.w comWord_TextBufferOffset,a0
          MOVE.w a0,comWord_Column
          MOVE.w comWord_ColumnsOffset,oldcolumnsoffset
          CLR.w comWord_ColumnsOffset
          i = FLen(t$)
          PrintScreenTitle{Str$(i)+" "+t$}
          If i
             MOVE.l addcodepos@(a5),a0
             SUB.l textbufferaddr,a0
             SUB.w comWord_TextBufferOffset,a0
             MOVE.w a0,comWord_Column
             For i2 = 1 To i-1
               JSR deletechar
             Next
          End If
          Gosub insertstring
          MOVE.w oldcolumnsoffset,comWord_ColumnsOffset
          MOVE.w colstore,comWord_Column
          JSR activatesource
          JSR cursor_on
          Gosub diag_redraw
          WZCloseWindow WZID("WIN_HELPDIAG"):diag = 0

         skip2:

        Case "diagclear"
          For i = 1 To 12
            diag_val$(i) = ""
            WZPrint "val"+UStr$(i),diag_val$(i)
          Next
          activategadget{"val1"}

      End Select

    Case #IDCMP_CLOSEWINDOW
      Gosub diag_close

    Case #IDCMP_VANILLAKEY
      If EventCode = $1B ; ESC
        Gosub diag_close
      EndIf

  End Select

Return


.diag_close
  wtemp\diag_x = WindowX
  wtemp\diag_y = WindowY
  wtemp\diag_w = WindowWidth
  wtemp\diag_h = WindowHeight
  WZCloseWindow WZID("WIN_HELPDIAG")
  diag = 0
Return


.load_windowlayouts:
  USEPATH wtemp
  CopyMem_ &wpref(num),&wtemp,SizeOf .winprefs
  If (\lbrowser_w<=0) OR (\lbrowser_h<=0)
    \lbrowser_x = -2
    \lbrowser_y = -2
    \lbrowser_w = -2
    \lbrowser_h = -2
  EndIf
  If (\source_h>0) AND (\source_w>0)
    Poke.w ?win_TopLeft,\source_x
    Poke.w ?win_TopEdge,\source_y
    Poke.w ?win_Width,\source_w
    Poke.w ?win_Height,\source_h
  Else
    *myscreen.Screen = Peek.l(Addr Screen(0))
    Poke.w ?win_TopLeft,0
    Poke.w ?win_TopEdge, *myscreen\WBorTop + *myscreen\Font\ta_YSize + 1
    Poke.w ?win_Width,ScreenWidth
    Poke.w ?win_Height,ScreenHeight - (*myscreen\WBorTop + *myscreen\Font\ta_YSize + 1)
  EndIf
Return


.do_windowlayout:
  If *sourcewin
    If *sourcewin<>0
      ChangeWindowBox_ *sourcewin,Peek.w(?win_TopLeft),Peek.w(?win_TopEdge),Peek.w(?win_Width),Peek.w(?win_Height)
      RefreshWindowFrame_ *sourcewin
      Delay_ 5
      !asm
      JSR resize_sourcewindow
      !basic
    EndIf
  Else
    JSR open_sourcewindow
    JSR cursor_on
  EndIf

  If \lbrowser_on
    Gosub open_librarybrowser
  Else
    WZ_KillTable{"LIBRARYBROWSER"}
    WZCloseWindow WZID("WIN_LIBRARYBROWSER")
  End If

  If \ibrowser_on
    Gosub open_instructionbrowser
  Else
    WZ_KillTable{"INSTRUCTIONBROWSER"}
    WZCloseWindow WZID("WIN_INSTRUCTIONBROWSER")
  End If

  If \diag_on
    WZWindow WZID("WIN_HELPDIAG"),?wzgui,80,\diag_x,\diag_y,\diag_w,\diag_h,4
    diag = 1
    Gosub diag_redraw
  Else
    WZCloseWindow WZID("WIN_HELPDIAG")
    diag = 0
  End If

  If \click_on
    Gosub open_labelwindow
  Else
    WZCloseWindow WZID("WIN_LABELS")
    ;GTSetMenuChecked 0,5,8,Off
  End If

  If \short_on
    Gosub open_shortcuts
  Else
    WZ_KillTable{"SHORTCUTS"}
    WZCloseWindow WZID("WIN_SHORTCUTS")
  End If

  If \type_on
    Gosub open_newtype
  Else
    WZCloseWindow WZID("WIN_NEWTYPE")
    ;GTSetMenuChecked 0,5,9,Off
  End If

  FlushEvents
  If \activewin > 0
    Activate \activewin
    Use Window \activewin
    If Peek.l(Addr Window(\activewin)) <> 0
      Select \activewin
        Case 3 : activategadget{"STRING_LABEL"}
        Case 2 : activategadget{"STRING2"}
        Case 1 : activategadget{"STRING"}
        Case 4 : activategadget{"VAL1"}
      End Select
    EndIf
  Else
    Gosub activatesource
  EndIf
  ev = 0
Return



.open_labelwindow
  WZWindow WZID("WIN_LABELS"),?wzgui,255,\click_x,\click_y,\click_w,\click_h,WZID("WIN_LABELS")
  Use Window WZID("WIN_LABELS")
  If Peek.l(?addr_menustrip) Then SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
  ;GTSetMenuChecked 0,5,8,On
  WZPrint "rem",Peek.w(?comWord_LabelRemark)
  WZPrint "all",Peek.w(?comWord_LabelAll)
  WZPrint "STRING_LABEL",search_label$
  WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels,LabelList_FirstVisableItemNumber
  Gosub update_versiongadgets
Return


.event_label:
  If RawKeyState($42)  Then Gosub activatesource : ev = 0

  Select ev

    Case #IDCMP_INTUITICKS
      LabelList_NewSelectItemNumber.l = WZListNum("LISTVIEW_LABELS")
      LabelList_FirstVisableItemNumber = WZListPos ("LISTVIEW_LABELS")
      MOVE.l d0,comLong_Label1VisableItem
      search_label$ = LCase$( WZGetString("STRING_LABEL") )

      If LabelList_NewSelectItemNumber<>LabelList_PreSelectItemNumber
        JSR jump_addhistory
        i = WZListData (list_labels,LabelList_NewSelectItemNumber)
        !asm
        MOVEA.l comPtr_CurrentSourceLine,A4
        MOVE.l d0,a0:
        JSR storeline
        JSR jump_to_keyword
        JSR cursor_on
        MOVE.l a4,oldcurrsourceline
        !basic
        LabelList_PreSelectItemNumber = LabelList_NewSelectItemNumber
      End If
      If search_label$<>old_search_label$
        CLR.l comLong_Label1VisableItem
        LabelList_FirstVisableItemNumber = 0 : LabelList_NewSelectItemNumber = 0
        old_search_label$ = search_label$
        !asm
        JSR clear_labellist
        JSR update_labellist
        JSR redraw_labellist
        !basic
        Poke$ ?comStr_LabelSearchString ,search_label$
      End If

    Case #IDCMP_RAWKEY
       ;move_cursor{"LISTVIEW_LABELS",list_labels,LabelList_PreSelectItemNumber}

    Case #IDCMP_CLOSEWINDOW
      wtemp\click_x = WindowX
      wtemp\click_y = WindowY
      wtemp\click_w = WindowWidth
      wtemp\click_h = WindowHeight
      WZCloseWindow WZID("WIN_LABELS")
      ;GTSetMenuChecked 0,5,8,Off

    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "string_label"
          ;Gosub activatesource

        Case "case"
          search_label$ = "Case"
          WZPrint "STRING_LABEL",search_label$
          Poke.w ?comWord_LabelRemark,1
          Poke.w ?comWord_LabelAll,0
          WZPrint "rem",1
          WZPrint "all",0
          LabelList_FirstVisableItemNumber = 0
          !asm
          JSR clear_labellist
          JSR update_labellist
          JSR redraw_labellist
          !basic
          activategadget {"STRING_LABEL"}

        Case "listview_labels"
          ;JSR jump_addhistory
          JSR activatesource
          If LabelList_PreSelectItemNumber<>WZListNum("LISTVIEW_LABELS")
            CLR.l oldcurrsourceline
          End If
          ;LabelList_PreSelectItemNumber = i
          i = WZListData (list_labels,WZInput)
          !asm
          MOVE.l comPtr_CurrentSourceLine,a4
          CMP.l oldcurrsourceline,a4
          BEQ 'l1
          MOVE.l d0,a0:
          JSR storeline
          JSR jump_to_keyword
          JSR cursor_on

         'l1
          MOVE.l a4,oldcurrsourceline
          !basic
          LabelList_FirstVisableItemNumber = WZListPos ("LISTVIEW_LABELS")
          MOVE.l d0,comLong_Label1VisableItem
          LabelList_PreSelectItemNumber = WZListNum("LISTVIEW_LABELS")
          ;WZPrint "LISTVIEW_LABELS",-1,list_labels,LabelList_FirstVisableItemNumber

        Case "rem"
          Poke.w ?comWord_LabelRemark,WZInput
          Poke.w ?comWord_LabelAll,0
          WZPrint "all",0
          ;search_label$ = "":WZGadSet "STRING_LABEL",search_label$
          LabelList_FirstVisableItemNumber = 0
          !asm
          JSR clear_labellist
          JSR update_labellist
          JSR redraw_labellist
          !basic
          activategadget{"STRING_LABEL"}

        Case "all"
          Poke.w ?comWord_LabelAll,WZInput
          Poke.w ?comWord_LabelRemark,0
          WZPrint "rem",0
          LabelList_FirstVisableItemNumber = 0
          !asm
          JSR clear_labellist
          JSR update_labellist
          JSR redraw_labellist
          !basic
          activategadget{"STRING_LABEL"}

        Case "clr"
          search_label$ = ""
          WZPrint "STRING_LABEL",search_label$
          LabelList_FirstVisableItemNumber = 0
          !asm
          JSR clear_labellist
          JSR update_labellist
          JSR redraw_labellist
          !basic
          activategadget{"STRING_LABEL"}

        Case "button_update_liblist"
          ; MOVE.l comPtr_TokenBase,D0    : *tokenbase.l = PutD0
          ; MOVE.l comdata,D0  : *cd.l = PutD0
          ; MOVE.l varbase,D0  : *vb.l = PutD0
          ; MOVE.l instrbase,D0: *intructionbase.l = PutD0
          ; MOVE.l libpointer,D0:*librarybase.l = PutD0
          ; DEFTYPE.tokendata tokeninfo
          Gosub scan_source_for_used_libs

        Case "library_list"
          cmd_node.l = WZGetNode(lib_list.List)
          cmd$ = WZListString(cmd_node,0)
          klammer.b = Instr(cmd$,"(")
          If klammer
            used_win = Used Window
            searchcmd$ = StrChg(Left$(cmd$,klammer-1)," ","")
            ; !cout{"*"+searchcmd$+"*"}
            BSET #7,case_sensitive
            Poke$ ?str_searchstring,searchcmd$;,60
            Poke$ ?str_oldsearchgadget,searchcmd$;,60
            ActivateWindow_(?ptr_sourcewindow)

            If oldsearchcmd$ <> searchcmd$
              oldsearchcmd$ = searchcmd$
              !asm
              MOVEQ #0,d0
              JSR jumpline
              !basic
            EndIf

            !asm
            JSR storeline
            JSR cursor_off
            MOVE.l comPtr_CurrentSourceLine,a4
            JSR menu_findnext
            JSR update_vertscroller
            JSR cursor_on
            !basic
            Use Window used_win
            ; gewaehlte Suchmethode wieder einschalten
            If WZInput("FIND_SENSITIVE")<>0 Then BSET #7,case_sensitive
          EndIf

      End Select

  End Select
  move_cursor{"LISTVIEW_LABELS",list_labels,LabelList_PreSelectItemNumber}
RTS


JL_0_46D6:
  MOVE.l d0,-(a7)
  MOVEM.l a0-a1,-(a7)
  MOVE.l a1,a0
  CMP.b #".",-1(a0)
  BEQ 'sk1
  CMP.b #";",-1(a0)
  BEQ 'sk1
  SUBQ.l #1,a0
 'sk1
  MOVE.l expandstore,a1
  JSR detokenize_line
  MOVEM.l (a7)+,a0-a1
  MOVE.l a0,d0
  MOVE.l a1,temp
  !basic
  s = PutD0
  MOVE.l expandstore,d0
  i = PutD0
  If i Then s$ = Peek$(i) : Else s$=""
  If Instr(s$,"Stop") OR Instr(s$,"Trap")
    MOVE.l temp,a0
   'l1
    MOVE.b (a0)+,d0
    BEQ no_breakpoint
    CMP.b #$80,d0
    BNE 'l1
    CMP.b #$ae,(a0)
    BEQ 'l2
    CMP.b #$2d,(a0)
    BNE 'l1
   'l2
    WZTags #WENTRYA_TextPen,2
    If sort_labels = -1
      WZListAdd list_labels," --Breakpoint---",0,s
    Else
      WZListAdd list_labels," --Breakpoint---",2000,s
    End If
    ADDQ.w #1,comWord_LabelCounter
    ADDQ.l #1,numcount
    Goto nostr
  End If

  no_breakpoint:
  If Peek.b(?isfunction)
    s$ = Mid$(s$,2)
    WZTags #WENTRYA_TextPen,Peek.l(?functioncolor)
  Else
    WZTags #WENTRYA_TextPen,1
  End If
  If t
    If Instr(s$,word1$) OR skip = 1
      If Instr(s$,word2$) OR skip = 1
        WZListAdd list_labels,s$,sort_labels,s
        ADDQ.w #1,comWord_LabelCounter
        ADDQ.l #1,numcount
        skip = 0
      End If
    End If
  Else
    If Instr(s$,search_label$) OR skip = 1
      WZListAdd list_labels,s$,sort_labels,s
      ADDQ.w #1,comWord_LabelCounter
      ADDQ.l #1,numcount
      skip = 0
    End If
  End If

  nostr:
  !asm
  MOVE.l (a7)+,d0
  CLR.b isfunction
RTS


.storeline
  MOVE.w comWord_KeyBeforeReturn,D0
  BEQ.w exit_storeline

  MOVEM.l d0-d7/a0-a6,-(a7)
  MOVE.l comPtr_CurrentSourceLine,a4
  JSR cursor_off
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVE.w D0,comWord_SourceChanged

  JSR parse_line

  ; -- draw selecting block if existing
  SF comByte_StateBlockMark
  TST.l comLong_BlockEndY
   BMI.w exit_updateblocka
  MOVEM.l D0-D3/A0-A2,-(A7)
  MOVE.l comLong_DisplayLine,D1
  ADD.l comLong_DisplayLineOffset,D1
  CMP.l comLong_BlockStartY,D1
   BLT.w JL_0_C66a
  CMP.l comLong_BlockEndY,D1
   BGT.w JL_0_C66a
  MOVE.w comLong_BlockStartX,D0
  MOVE.l comLong_BlockStartY,D1
  MOVE.w comLong_BlockEndX,D2
  MOVE.l comLong_BlockEndY,D3
  CMP.l D1,D3
   BNE.w JL_0_C50a
  CMP.w D0,D2
   BNE.w JL_0_C50a
  MOVE.w visiblecolumns,D2
  JL_0_C50a:
  SUB.l comLong_DisplayLineOffset,D3
  SUB.l comLong_DisplayLineOffset,D1
  JSR JL_0_59BC
  ST comByte_StateBlockMark
  JL_0_C66a:
  MOVEM.l (A7)+,D0-D3/A0-A2
  exit_updateblocka:

  JSR JL_0_55AA
  MOVE.w comWord_DoTokenize,D0
   BEQ.w JL_0_CC6b
  JSR print_current_sourceline
  TST.b comByte_StateBlockMark
   BEQ.w JL_0_CC6b
  MOVEM.l D0-D3/D7/A0-A2,-(A7)
  MOVE.w comLong_BlockStartX,D0
  MOVE.l comLong_BlockStartY,D1
  MOVE.w comLong_BlockEndX,D2
  MOVE.l comLong_BlockEndY,D3
  CMP.l D1,D3
   BNE.w JL_0_CB2a
  CMP.w D0,D2
   BNE.w JL_0_CB2a
  MOVE.w visiblecolumns,D2

  JL_0_CB2a:
  SUB.l comLong_DisplayLineOffset,D3
  SUB.l comLong_DisplayLineOffset,D1
  JSR JL_0_59BC
  MOVEM.l (A7)+,D0-D3/D7/A0-A2

  JL_0_CC6b
  MOVE.l a4,comPtr_CurrentSourceLine
  MOVEM.l (a7)+,d0-d7/a0-a6

  exit_storeline:
  CLR.w comWord_KeyBeforeReturn
  MOVE.l comPtr_CurrentSourceLine,a4
RTS


.ascii_to_token  ;a2 = text
  MOVEM.l d1-d7/a0-a6,-(a7)
  MOVE.l d0,a2
  MOVEA.l comPtr_TokenBase,A3

 JL_0_6036b:
  MOVEA.l A2,A4
  MOVE.l A3,-(A7)
  ADDQ.w #6,A3

 JL_0_603Cb:
    MOVE.b (A3)+,D3
     BEQ.w JL_0_6082b     ;found
    MOVE.b (A4)+,D2
    ;BCLR #$7,D2
    ;ORI.b #$20,D3
    ;ORI.b #$20,D2
    CMP.b D3,D2
     BEQ.b JL_0_603Cb

 JL_0_6054b:
    MOVEA.l (A7)+,A3
    MOVE.l (A3),D3
     BEQ.w JL_0_6060b
    MOVEA.l D3,A3
BRA.b JL_0_6036b

 JL_0_6082b:
  MOVE.b (A4),D2
  BNE JL_0_6054b
  BCLR #$7,D2
   BNE.b JL_0_6054b       ;not found
  MOVEA.l (A7)+,A3
  ADDQ.w #4,A3
  MOVEQ #0,d0
  MOVE.b (A3)+,d0
  ASL.l #8,d0
  MOVE.b (a3),d0
  MOVEM.l (a7)+,d1-d7/a0-a6
RTS

 JL_0_6060b
  MOVEQ #0,d0
  MOVEM.l (a7)+,d1-d7/a0-a6
RTS


.navigate_in_label_window
  !basic
  CMP.w #$57,d7      ; check for "F8"
  BNE 'l1
  If WZ_CheckOpen{"WIN_LABELS"}
    LabelList_PreSelectItemNumber = LabelList_PreSelectItemNumber+1
    If LabelList_PreSelectItemNumber = >WZListItems (list_labels) Then LabelList_PreSelectItemNumber = WZListItems (list_labels)-1
    LabelList_NewSelectItemNumber = LabelList_PreSelectItemNumber
    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels
    i = WZListData (list_labels,LabelList_NewSelectItemNumber)
    !asm
    MOVEM.l a0-a6/d1-d7,-(a7)
    MOVEA.l comPtr_CurrentSourceLine,A4
    MOVE.l d0,a0:
    JSR storeline
    JSR jump_to_keyword
    JSR cursor_on
    MOVE.l a4,oldcurrsourceline
    MOVEM.l (a7)+,a0-a6/d1-d7
    !basic
  End If

 'l1
  CMP.w #$56,D7       ; check for "F7"
  BNE 'l2
  If WZ_CheckOpen{"WIN_LABELS"}
    LabelList_PreSelectItemNumber = LabelList_PreSelectItemNumber-1
    If LabelList_PreSelectItemNumber<0 Then LabelList_PreSelectItemNumber = 0
    LabelList_NewSelectItemNumber = LabelList_PreSelectItemNumber
    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels
    i = WZListData (list_labels,LabelList_NewSelectItemNumber)
    !asm
    MOVEM.l a0-a6/d1-d7,-(a7)
    MOVEA.l comPtr_CurrentSourceLine,A4
    MOVE.l d0,a0:
    JSR storeline
    JSR jump_to_keyword
    JSR cursor_on
    MOVE.l a4,oldcurrsourceline
    MOVEM.l (a7)+,a0-a6/d1-d7
    !basic
  End If

 'l2
  !asm
RTS


.activatesource
  MOVE.l ptr_sourcewindow,d0 : i = PutD0
  If i Then ActivateWindow_ i
RTS


.print_filenames
  !basic
  MOVE.l #filenamepos,d2
  MULS fontwidth,d2
  MOVE.l d2,d0 : xpos_text.l = PutD0

  *rastp.RastPort = Peek.l(?rp_sourcewindow)
  *swin.Window = Peek.l(?ptr_sourcewindow)
  *tfont.TextFont = Peek.l(?ptr_sourcefont)
  SetAPen_ *rastp, AB3Pen(#AB3_screenfill)
  xpos_text.l = #filenamepos * *tfont\tf_XSize
  RectFill_ *rastp,xpos_text - 4,ypos_sa + 2,*swin\Width-*swin\BorderRight,ypos_sa + 2 + *tfont\tf_YSize + 2

  MOVEA.l rp_sourcewindow,A1
  MOVEA.l _graphicsbase,A6
  MOVE.l ptr_sourcewindow,A0

  MOVE.l loadedfilesbase,d0
  BEQ 'skip_filenames

  MOVE.l #filenamepos,d2
  MULS fontwidth,d2
 'again:
    MOVE.l d0,a0
    MOVEQ #0,d1
    MOVE.l d2,d0 : xpos_text.l = PutD0
    Move_ *rastp,xpos_text,ypos_text

    fcol.w = AB3Pen(#AB3_screentext)    ; selected
    bcol.w = AB3Pen(#AB3_cbackground)
    bevel_recessed.b = True
    stylestate.w = #FSF_BOLD
    CMP.l actualfile,a0
    BEQ 'l1
    fcol.w = AB3Pen(#AB3_screentext)  ; unselected
    bcol.w = AB3Pen(#AB3_screenback)
    bevel_recessed.b = False
    stylestate.w = #FS_NORMAL
   'l1
    MOVEM.l a0/a1,-(a7)

    MOVE.l d2,-(a7)
    JSR draw_bevel
    MOVE.l (a7)+,d2


    SetDrMd_ *rastp, 1
    SetAPen_ *rastp, fcol
    SetBPen_ *rastp, bcol

    If stylestate = #FSF_BOLD Then SetFont_ *rastp,Peek.l(?ptr_sourcefontb) : Else SetFont_ *rastp,Peek.l(?ptr_sourcefont)
    SetSoftStyle_ *rastp,stylestate.w,#FSF_BOLD

    MOVEM.l (a7)+,a1/a0

    MOVE.l #filenameoffs,d0
    MULS fontwidth,d0
    ADD.w d0,d2
    MOVEQ #10,d0

    CMP.l actualfile,a0
    BNE 'nom
    CMP.l #$4D4F4449,comStr_Modified     ; "MODI"
    BNE 'nom2

    MOVEM.l d0/a0/a1,-(a7)
    ;MOVEQ #1,d0
    ;LEA modifymark,a0
    ;JSR _Text(a6)
    Text_ *rastp,?modifymark, 1
    MOVEM.l (a7)+,d0/a0/a1
    SUB.l #1,d0 ; we show the modify mark, so 1 letter less in text
    BRA 'nom2

   'nom
    CMP.l #$4D4F4449,$1e6(a0)     ; "MODI"
    BNE 'nom2
    MOVEM.l d0/a0/a1,-(a7)
;    MOVEQ #1,d0
;    LEA modifymark,a0
;    JSR _Text(a6)
    Text_ *rastp,?modifymark, 1
    MOVEM.l (a7)+,d0/a0/a1
    SUB.l #1,d0 ; we show the modify mark, so 1 letter less in text

   'nom2

    MOVE.l a0,-(a7)
    LEA $de(a0),a0
    TST.b (a0)
    BNE 'sk1
    LEA none,a0
   'sk1
    MOVE.l a1,-(a7)
    CLR.l d4
    MOVE.l d0,bltlen
    LEA filebuff,a1
    MOVE.l #$20202020,(a1)
    MOVE.l #$20202020,4(a1)
    MOVE.l #$20202020,8(a1)
    MOVE.l #$20202020,12(a1)

   'copy
      ADD.l #1,d4
      MOVE.b (a0)+,(a1)+
    BNE 'copy
    SUB.l #1,D4
    MOVE.l d4,reallen
    MOVE.b #$20,-1(a1)
    LEA filebuff,a0
    MOVE.l (a7),a1
    JSR _Text(a6)

    MOVE.l bltlen,D0
    MOVE.l reallen,D4

    CMP.l D0,D4
    BLE 'nodots

    MOVEM.l d1-d7,-(a7)
    WritePixel_ *rastp,*rastp\cp_x+1,*rastp\cp_y-4-*rastp\TxBaseline +*rastp\TxHeight/2
    WritePixel_ *rastp,*rastp\cp_x+1,*rastp\cp_y-2-*rastp\TxBaseline +*rastp\TxHeight/2
    WritePixel_ *rastp,*rastp\cp_x+1,*rastp\cp_y  -*rastp\TxBaseline +*rastp\TxHeight/2
    WritePixel_ *rastp,*rastp\cp_x+1,*rastp\cp_y+2-*rastp\TxBaseline +*rastp\TxHeight/2
    WritePixel_ *rastp,*rastp\cp_x+1,*rastp\cp_y+4-*rastp\TxBaseline +*rastp\TxHeight/2
     MOVEM.l (a7)+,d1-d7
   'nodots:

;    MOVE.l d2,-(a7)
;    JSR draw_bevel
;    MOVE.l (a7)+,d2

    MOVE.l (a7)+,a1
    MOVE.l (a7)+,a0
;    MOVEQ #1,d0
    MOVEM.l a0/a1,-(a7)
;    JSR _SetDrMd(a6)
    SetDrMd_ *rastp, 1
    MOVEM.l (a7)+,a1/a0
    MOVE.l (a0),d0
  BNE 'again
 'skip_filenames
;  MOVEA.l rp_sourcewindow,A1
;  MOVE.l backgroundcolor,D0
;  JSR _SetBPen(A6)
  SetBPen_ *rastp,Peek.l(?backgroundcolor)
  SetFont_ *rastp,Peek.l(?ptr_sourcefont)
  SetSoftStyle_ *rastp,#FS_NORMAL,#FSF_BOLD
  !asm
RTS
bltlen:
Dc.l  0
reallen:
Dc.l  0

.draw_bevel:
  ;*visualinfo.l = GetVisualInfoA_(ActiveScreen,0)
  xsa.l = *tfont\tf_XSize/2
  xsb.l = *tfont\tf_XSize-xsa
  bx1.l = xpos_text - xsa
  by1.l = ypos_sa +1;+ 3
  bx2.l = *tfont\tf_XSize*10 + *tfont\tf_XSize-1 + bx1
  by2.l = *tfont\tf_YSize + 4    + by1
  cp_x.l = *rastp\cp_x
  cp_y.l = *rastp\cp_y

  If bevel_recessed = False
    ;DrawBevelBoxA_ *rastp,xpos_text - 2,ypos_sa + 3,*tfont\tf_XSize*10 + 4,*tfont\tf_YSize + 2,Tags(#GT_VisualInfo,*visualinfo,#TAG_DONE,0)
    SetAPen_ *rastp,AB3Pen(#AB3_screenback)
    RectFill_ *rastp,bx1+1,by1+1,bx2-1+1,by2
    SetAPen_ *rastp,AB3Pen(#AB3_screentext)
    Move_ *rastp,bx1,by1
    Draw_ *rastp,bx1,by2
    Draw_ *rastp,bx2+1,by2
    Draw_ *rastp,bx2+1,by1
  Else
    ;DrawBevelBoxA_ *rastp,xpos_text - 2,ypos_sa + 3,*tfont\tf_XSize*10 + 4,*tfont\tf_YSize + 2,Tags(#GTBB_Recessed,True,#GT_VisualInfo,*visualinfo,#TAG_DONE,0)
    SetAPen_ *rastp,AB3Pen(#AB3_cbackground)
    RectFill_ *rastp,bx1+1,by1-1,bx2-1+1,by2

    SetAPen_ *rastp,AB3Pen(#AB3_screentext)
    Move_ *rastp,bx1,by1 : Draw_ *rastp,bx1,by2+1
    Draw_ *rastp,bx2+1,by2+1
    Draw_ *rastp,bx2+1,by1
    cp_y+1
  EndIf
  Move_ *rastp,cp_x,cp_y
RTS


.check_mouse_in_statusarea
  MOVEM.l a0/a1/d0/d7,-(a7)
  !basic
;  MOVEQ #0,d0
;  MOVE.w $20(a1),d0
;  i5 = PutD0
;  MOVE.w $22(a1),d0
;  i6 = PutD0
;  MOVE.w #0,d0
;  !cout{i5,i6,Peek.w(?ypos_statusarea)+Peek.w(?win_BorTop)}
  CMP.w #$68,D0
  BEQ.w 'no
  MOVE.l loadedfilesbase,d0
  BEQ 'no
  MOVEQ #0,d6
  MOVEQ #0,d7
  MOVE.w $20(a1),d6           ; d6 = x-pos, d7 = y-pos  of  mouse
  MOVE.w $22(a1),d7
;  ADDQ.l #7,d7

  MOVEQ #0,d5
  MOVE.l #filenamepos,d1
  MULS fontwidth,d1           ; get x-position of first sourcename

  MOVEQ #0,d3
  MOVE.w fontwidth,d3
;  MULS #filenameoffs-1,d3                  ;character show
  MULS #filenameoffs,d3                  ;character show
  ADD.w d1,d3
;  ADD.w #8,d3

 'again:
  MOVE.l d0,a0
  TST.b $de(a0)
  ;BEQ 'n1

  MOVEQ #0,d2                 ; load y-Position of statusarea + some pixels until button starts
  MOVE.w ypos_statusarea,d2
  ADD.w win_BorTop,d2
  ;ADD.w #5,d2

  MOVE.l d2,d4                ; load bottom-pos for buttons
  ADD.w fontheight,d4
  ADD.w #8,d4

  CMP.l d1,d6                 ; check if mouse was in buttonarea
  BLE 'n1
  CMP.l d3,d6
  BGE 'n1
  CMP.l d2,d7
  BLE 'n1
  CMP.l d4,d7
  BGE 'n1
  MOVEM.l d0-d7/a0-a6,-(a7)
  CMP.l actualfile,D0
  BNE.w 'noctrl
  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_CONTROL|#IEQUALIFIER_LALT|#IEQUALIFIER_RALT,d1
  BEQ 'noctrl
  CMP.l #$4D4F4449,comStr_Modified    ; "MODI"
  BNE 'noc
  !asm
  JSR storeline
  ;JSR saverout
  !basic
  Delay_ 2

 'noc
  JSR set_tedlibbase
  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_CONTROL,d1
  BEQ 'nocreateexe
  !asm
  JSR cursor_off
  MOVEM.l    D2-D7/A1-A6,-(A7)
  MOVEQ.l    #$5b,D6
  JSR        call_compilermenuitem
  MOVEM.l    (A7)+,D2-D7/A1-A6
  !basic
  BRA 'out2

 'nocreateexe
  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_LALT|#IEQUALIFIER_RALT ,d1
  BEQ 'out2
  !asm
  JSR cursor_off
  MOVEM.l    D2-D7/A1-A6,-(A7)
  MOVEQ.l    #$50,D6
  JSR        call_compilermenuitem
  MOVEM.l    (A7)+,D2-D7/A1-A6
  !basic

 'out2
  MOVEM.l (A7)+,D0-d7/a0-a6
  !asm
  MOVEM.l (a7)+,d7/d0/a1/a0
  MOVEQ #-4,d7
  RTS

 'noctrl
  MOVEM.l (A7)+,D0-d7/a0-a6
  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_CONTROL|#IEQUALIFIER_LALT|#IEQUALIFIER_RALT ,d1
  BEQ 'nos2
  CMP.l #$4D4F4449,comStr_Modified     ; "MODI"
  BNE 'nos2
  MOVEM.l a0-a6/d0-d7,-(a7)
  !asm
  JSR storeline
  JSR saverout
  !basic
  Delay_ 2
  MOVEM.l (a7)+,d0-d7/a0-a6

 'nos2
  CMP.l actualfile,D0
   BEQ.w 'no
  MOVE.l messagestore,d1
  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_CONTROL|#IEQUALIFIER_LALT|#IEQUALIFIER_RALT ,d1
  BNE 'no4
  ;MOVE.b #1,refreshonstore

 'no4
  JSR storeline
  JSR cursor_off
  JSR selectfile
  !asm
  JSR StoreXtraData
  !basic
  MOVE.b #0,refreshonstore
  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_CONTROL|#IEQUALIFIER_LALT|#IEQUALIFIER_RALT ,d1
  BEQ 'no
  ;CMP.l #$4D4F4449,comStr_Modified
  ;BNE 'nos
  ; !asm
  ; JSR saverout
  ; !basic
  Delay_ 2

 'nos
  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_CONTROL,d1
  BEQ 'nocreate
  !asm
  JSR set_tedlibbase
  JSR cursor_off
  MOVEM.l    D2-D7/A1-A6,-(A7)
  MOVEQ.l    #$5b,D6
  JSR        call_compilermenuitem
  MOVEM.l    (A7)+,D2-D7/A1-A6
  !basic
  BRA 'noctrl2

 'nocreate
  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_LALT|#IEQUALIFIER_RALT ,d1
  BEQ 'noctrl2
  !asm
  JSR set_tedlibbase
  JSR cursor_off
  MOVEM.l    D2-D7/A1-A6,-(A7)
  MOVEQ.l    #$50,D6
  JSR        call_compilermenuitem
  MOVEM.l    (A7)+,D2-D7/A1-A6
  !basic

 'noctrl2
  !asm
  MOVEM.l (a7)+,d7/d0/a1/a0
  MOVEQ #-4,d7
  RTS

 'n1
  ADDQ.l #1,d5
  MOVE.l #filenameoffs,d0
  MULS fontwidth,d0
  ADD.l d0,d1
  ADD.l d0,d3
  MOVE.l (a0),d0
  BNE 'again

 'no
  !asm
  MOVEM.l (a7)+,d7/d0/a1/a0
RTS



.loadfile
  MOVEM.l a0-a6/d0-d7,-(a7)

  ; -- copy filename-strpointer to A1
  MOVE.l D0,A1

  ; --- check if actual file is source to load
  LEA str_unnamed,A3
  JSR compare_strings
  BNE.w exit_loadfile

  ; --- check if source is already loaded
  MOVEA.l loadedfilesbase,A2

 JL_0_BCFCb:
  MOVEA.l A2,A3
  MOVE.l A1,-(a7)           ; A1 auf den Stack

 'l1
    TST.b (a1)+
  BNE 'l1
  MOVEQ #60,d1

 'loop
    MOVE.b -(a1),d0
    CMP.l (a7),a1
     BEQ 'out2
    CMP.b #"/",d0
     BEQ 'out
    CMP.b #":",d0
     BEQ 'out
    SUBQ.l #1,d1
  BNE 'loop

 'out
  ADDQ.l #1,a1

 'out2
  LEA $DE(A3),A3
  JSR compare_strings
  MOVE.l (a7)+,a1         ; A1 vom Stack
  TST.l d0
   BNE.w JL_0_BD18b

 JL_0_BD0Ab:
  MOVEA.l (A2),A2
  CMPA.l #$0,A2
   BNE.b JL_0_BCFCb
BRA.w load_sourcefileb

 JL_0_BD18b:
  MOVEA.l A2,A0
  JSR selectfile
  MOVEM.l (a7)+,a0-a6/d0-d7
RTS


load_sourcefileb:
  MOVE.l A1,D0

  MOVE.l D0,-(a7)       ; D0 auf Stack
  JSR menu_opennew
  MOVE.l (a7)+,D7       ; D0 vom Stack nach D7

  JSR load_source

  MOVEM.l (a7)+,a0-a6/d0-d7

 exit_loadfile:
RTS


Function.l ab3_IsTokenChar{char.l}
  If char>=@"a" AND char<=@"z" Then Function Return True
  If char>=@"A" AND char<=@"Z" Then Function Return True
  If char>=@"0" AND char<=@"9" Then Function Return True
  If char=@"_" OR char=@"@" OR char=@"`" Then Function Return True
  Function Return False
End Function


Function.l ab3_InstrToken{code.s,token.s}
  pos.l = Instr(code,token)
  If pos
    If ab3_IsTokenChar{Peek.b(&code+pos-1+FLen(token))} Then pos=0
    If pos>1
      If ab3_IsTokenChar{Peek.b(&code+pos-1-1)} Then pos=0
    End If
  End If
  Function Return pos
End Function


.build_HelpIndexFile
  DosBuffLen 32000
  CaseSense On
    #TOKEN_Function  = $8009
    #TOKEN_Statement = $8008
    #TOKEN_Object    = $80d7
    #TOKEN_Macro     = $800d
    #TOKEN_End       = $8002
    #TOKEN_Return    = $8007

  Statement writeentry{mode$,instruction$}

    ; -- don't add it if it contains @H
    If Instr(instruction$,"@H") Then Statement Return

    ; -- token return found
    If Instr(instruction$,Mki$(#TOKEN_Return)) Then Statement Return

    ; -- token End found
    If Instr(instruction$,Mki$(#TOKEN_End)) Then Statement Return

    startpos.l = 0
    Select mode$
      Case "FUNC"  : startpos = Instr(instruction$,Mki$(#TOKEN_Function)) +2
        i3.l = Instr (instruction$,".",startpos)
        If (i3 < startpos+5) AND (i3 <> 0)
          startpos = i3+2
        End If

        If Instr(instruction$,"FAST",startpos)
          startpos.l = Instr(instruction$,"FAST",startpos) + 4
        End If

      Case "STAT" : startpos = Instr(instruction$,Mki$(#TOKEN_Statement)) +2
        If Instr(instruction$,"FAST",startpos)
          startpos.l = Instr(instruction$,"FAST",startpos) + 4
        End If

      Case "MACR"     : startpos = Instr(instruction$,Mki$(#TOKEN_Macro))     +2
    End Select

    ; -- get string positions --
    instruction$ = dos_Trim{Mid$(instruction$,startpos)}

    endpos.l  =1
    stopchar.l=False
    While endpos<=FLen(instruction$) AND stopchar=False
      If ab3_IsTokenChar{Peek.b(&instruction$+endpos-1)}=False Then stopchar=True:Else endpos+1
    Wend

    ; -- write infos to indexfile
    If endpos <> 0
      funcname$ = Mid$( instruction$ , 1 , endpos - 1)
      ;If Right$(funcname$,1)=";" Then funcname$ = UnLeft$(funcname$,1)
      ;funcname$ = StripLead$(StrLeft(funcname$,50,32),32)
      funcname$ = StripLead$(funcname$,32)
      If mode$ = "MACR" Then funcname$ = "!" + funcname$

      description$ = Mid$(instruction$,endpos)
      description$ = StripLead$(description$,32)
      If Left$(description$,1)=";" Then description$ = UnRight$(description$,1)
      description$ = StripLead$(description$,32)
      ;NPrint LSet$(mode$,11) + LSet$(funcname$,50) + description$
      NPrint mode$+"\\09"+funcname$+"\\09"+description$
    End If
  End Statement

  Statement scanfile{rootpath$,filename$}
    functoken$      = Mki$($8009)
    statementtoken$ = Mki$($8008)
    objecttoken$    = Mki$($80d7)
    macrotoken$     = Mki$($800d)
    endtoken$       = Mki$($8002)
    returntoken$    = Mki$($8007)
    tok80.s         = Str$($80)
    fid.l = file_Open{dos_AddPart{rootpath$,filename$},#file_read}
    If dos_GetExt{filename$}="bb2" Then tokenized.l=True:Else tokenized=False

    If fid>=0 ; ReadFile(0,filename$)
      ;file_Cache{fid}
      ;FileInput 0
      ; -- get current path
      ;dir_name$ = SPACE$(512)
      ;GetCurrentDirName_ &dir_name$,FLen(dir_name$)
      ;dir_name$ = StripTrail$(dir_name$,0)
      ;dir_name$ = dos_Trim{dir_name$}
      ;dir_name$ = dos_FilePart{dir_name$}

      ; -- add parent path to filename, if not in includes-drawer
      ;If LCase$(dir_name$)<>"includes" Then filename$ = dos_AddPart{dir_name$,filename$}

      ; -- print filename into indexfile
      NPrint "FILE\\09",filename$

      Repeat
        ;code.s = ReadLine$
        If tokenized
          code.s = file_ReadBB2Line{fid}
        Else
          code.s = file_ReadLine{fid}
        End If

        maxpos.l = Instr(code,";")
        If maxpos = 0 Then maxpos = FLen(code)-1

        ; in case its ASCII...
        If tokenized=False
          pos.l = ab3_InstrToken{code,"Function"}
          If pos>0 AND pos<maxpos
            ;If Instr(code,"GetObjectBy") Then error{"Found Function in "+filename$+" line:\\n"+code}
            code.s = Left$(code,pos-1) + functoken$ + Right$(code,FLen(code)-pos-8+1)
            If pos<maxpos Then maxpos=pos
          End If

          pos = ab3_InstrToken{code,"Statement"}
          If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + statementtoken$ + Right$(code,FLen(code)-pos-9+1)
            If pos<maxpos Then maxpos=pos
          End If

          pos = ab3_InstrToken{code,"Macro"}
          If pos>0 AND pos<maxpos
              code.s = Left$(code,pos-1) + macrotoken$ + Right$(code,FLen(code)-pos-5+1)
              If pos<maxpos Then maxpos=pos
          End If

          pos = ab3_InstrToken{code,"End "}
          If pos>0 AND pos<maxpos
              code.s = Left$(code,pos-1) + endtoken$ + Right$(code,FLen(code)-pos-3+1)
              If pos<maxpos Then maxpos=pos
          End If

          pos = ab3_InstrToken{code,"Return"}
          If pos>0 AND pos<maxpos
              code.s = Left$(code,pos-1) + returntoken$ + Right$(code,FLen(code)-pos-6+1)
              If pos<maxpos Then maxpos=pos
          End If
        End If
;        If Left$(a$,2) = ";/"
;          NPrint a$
;        Else
          pos = Instr(code,functoken$)
          If pos>0 AND pos<=maxpos Then writeentry{"FUNC",code}

          pos = Instr(code,statementtoken$)
          If pos>0 AND pos<=maxpos Then writeentry{"STAT",code}

          pos = Instr(code,macrotoken$)
          If pos>0 AND pos<=maxpos Then writeentry{"MACR",code}

;        EndIf
      Until file_EOF{fid}
      file_Close{fid}
    Else
      dummy.l= RTEZRequest( "","Cant open file "+filename$,"ok")
    End If
  End Statement

  DeleteFile_ HelpIndexFile$
  ClearList HelpIndexCache()
  ClearList dirs()
  If WriteFile (1,HelpIndexFile$)
    WZ_ShowMessage{!TRANS{"Updating indexfile for onlinehelp..."},0}

   ; set windowtitle for progresswindow                                ;tomsmart1
   ;*win.Window = WZWindowAddr                                         ;get window pointer works, but i find it not save  tomsmart1
   *win.Window = Peek.l(Addr Window(WZID("WIN_PROGRESS")))             ;get window pointer  tomsmart1
   newwintitle.s="(Re)Building..."                                     ;new window title tomsmart1
   SetWindowTitles_ *win,&newwintitle,-1                                ;show new window title  tomsmart1

    If ChDir (includedir$)
      ; scan files for functions
      num_files.l = 0
      While MoreEntries
        If EntryDIR
          If AddLast(dirs())
            dirs()\name = EntryName$
          EndIf
        Else
          num_files + 1
        EndIf
      Wend
      If FirstItem(dirs()) Then dirname$ = dirs()\name Else exitscan.l = True
      ChDir (includedir$)
      subpath.s = ""
      act_file.l = 0
      Repeat
        While MoreEntries
          If (NOT EntryDIR)
            ex.s = dos_GetExt{EntryName$}
            If (ex="bb2" OR ex="ab2" OR ex="ab3")
              FileOutput 1
              If subpath
                scanfile{includedir$,dos_AddPart{subpath,EntryName$}}
              Else
                scanfile{includedir$,EntryName$}
              End If
;              !cout{"scanned:",EntryName$}
;           Else
;              !cout{"no include:",EntryName$}
            EndIf
            act_file + 1 : act_file = Min(act_file,num_files)
            !WZ_Update_Gauge{act_file,num_files}
;          Else
;            !cout{"skipped:",EntryName$}
          End If
        Wend
        If dirname$ <> ""
          ChDir dos_AddPart{includedir$,dirname$}
          ;ChDir (includedir$)
          subpath = dirname$
;          !cout{"chdir:",includedir$+dirname$,"++++++ ",includedir$ +  dirs()\name}
          If NextItem(dirs()) Then dirname$ = dirs()\name Else dirname$ = ""
        Else
          exitscan = True
        EndIf
      Until exitscan = True
      ClearList dirs()
    Else
      dummy.l= RTEZRequest( "",!TRANS{"Could not determine Include directory"}+":\\n"+includedir$+"!",!TRANS{"OK"})
    EndIf
  ; bernd's code
  ;   If ChDir (includedir$)
  ;     While MoreEntries
  ;     If EntryDIR = False AND Right$(EntryName$,4) = ".include.bb2"
  ;        scanfile{fullpath$+EntryName$}
  ;     End If
  ;     Wend
  ;   End If
    CloseFile 1
    WZ_ShowMessage{!TRANS{"Updating Helpindex..."}}
    TED_LoadHelpIndexFile{HelpIndexFile$}
    WZ_ShowMessage{!TRANS{"Saving Helpindex to Disc..."}}
    TED_WriteHelpIndexCache{HelpIndexCacheFile$}
    WZ_ShowMessage{!TRANS{"Creating Hashmaps..."}}
    preproc_QueryTokens{*PreProcessor}
    preproc_SaveTokens{*PreProcessor,TokenHashMapFile}
    WZ_HideMessage{}
  End If

  CaseSense Off
RTS


findmode:   Dc.w 0


.event_find
;    Use Window WZID("WIN_SEARCH")
;    ActivateGadget_ WZGadAddr("FIND_FINDSTRING"),WZWindowAddr,0
;    !cout{"event_find  " + Hex$(ev)}
    ;
    BSET #7,case_sensitive
    a$ = WZGetString("FIND_FINDSTRING")
    b$ = WZGetString("FIND_REPLACESTRING")

    If WZInput("FIND_SENSITIVE")= 0 Then a$ = StrUpper(a$) : BCLR #7,case_sensitive
    Poke$ ?str_oldsearchgadget,a$;,60
    Poke$ ?str_searchstring,a$;,60
    Poke$ ?str_replacestring,b$;,60

    ;

    Select ev

      Case #IDCMP_CLOSEWINDOW
        WZCloseWindow WZID("WIN_SEARCH")
        ActivateWindow_(?ptr_sourcewindow)
        FlushEvents

      Case #IDCMP_VANILLAKEY
        Select EventCode

          Case 13
            !asm
            JSR storeline
            JSR cursor_off
            MOVE.l comPtr_CurrentSourceLine,a4
            JSR menu_findnext
            JSR update_vertscroller
            JSR cursor_on
            !basic
            FlushEvents : Delay_ 2 ; VWait 3

          Case $1B
            WZCloseWindow WZID("WIN_SEARCH")
            ActivateWindow_(?ptr_sourcewindow)
            FlushEvents

        End Select

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName

          Case "FIND_FINDSTRING"
            !asm
            JSR storeline
            JSR cursor_off
            MOVE.l comPtr_CurrentSourceLine,a4
            JSR menu_findnext
            JSR update_vertscroller
            JSR cursor_on
            !basic
            FlushEvents : Delay_ 2;VWait 3


          Case "FIND_NEXT"
            !asm
            JSR storeline
            JSR cursor_off
            MOVE.l comPtr_CurrentSourceLine,a4
            JSR menu_findnext
            JSR update_vertscroller
            JSR cursor_on
            !basic

          Case "FIND_PREVIOUS"
            !asm
            JSR storeline
            JSR cursor_off
            MOVE.l comPtr_CurrentSourceLine,a4
            JSR menu_previous
            JSR update_vertscroller
            JSR cursor_on
            !basic

          Case "FIND_REPLACE"
            !asm
            JSR storeline
            JSR cursor_off
            MOVE.l comPtr_CurrentSourceLine,a4
            JSR menu_replace
            JSR cursor_on
            !basic

          Case "FIND_REPLACE_ALL"
            Poke.w ?findmode, Abs(WZInput("FIND_FINDMODE"))
            If a$<>"" AND b$<>""
              !asm
              JSR storeline
              JSR cursor_off
              JSR set_pointerbusy

              MOVE.l A4,D0
              TST.w findmode
               BNE.b replace_loop
              MOVE.l comPtr_FirstSourceLine,D0

              replace_loop:
                MOVEA.l D0,A4
                MOVE.l A4,comPtr_CurrentSourceLine
                JSR replace_string
                MOVE.l (A4),D0
              BNE.b replace_loop

              JSR update_currsourceline
              JSR _redraw
              JSR set_pointernormal
              JSR cursor_on
              !basic
            EndIf

          Case "FIND_EXIT"
            WZCloseWindow WZID("WIN_SEARCH")
            ActivateWindow_(?ptr_sourcewindow)

        End Select

        If WZ_CheckOpen{"WIN_SEARCH"}
          oldfindstr$ = WZGetString("FIND_FINDSTRING" )
          oldreplacestr$ = WZGetString("FIND_REPLACESTRING" )
        EndIf

    End Select
Return



.coutclose:
  !coutclose
Return





; ---------------------------------------------------------------------
; Declarations of Variables
; ---------------------------------------------------------------------
.DECLARATIONS
warningtitle:         Ds.b #MAX_STRINGSIZE
;CNIF #lang = 0
;menu1                 Dc.b "Save & Create Exec",0,0
;menu2                 Dc.b "Save & Compile & Run",0,0
;menu3                 Dc.b "Debug / Runerrors On (10*slower Code)",0,0
;menu4                 Dc.b "Create Executable absolut smallest",0,0
;fileadd               Dc.b "Choose file and add to Code",0,0
;cursoradd             Dc.b "Load file under cursor",0,0
;buildincludehelp      Dc.b "Update Help-Indexfile   ",0,0
;warningtitle          Dc.b "!!! PROGRAMM IS RUNNING: ONLY SAVE AS/NAVIGATION/HELP WILL WORK ...",0
;CELSE
;menu1                 Dc.b "Speichern & Erzeuge Executable",0,0
;menu2                 Dc.b "Speichern, Kompilieren & Ausf|hren",0,0
;menu3                 Dc.b "Debug / Runerrors On (10*langsamerer Code)",0,0
;menu4                 Dc.b "Erzeugt absolut kleinster Code",0,0
;fileadd               Dc.b "Wdhle file und f|ge es zum Source",0,0
;cursoradd             Dc.b "Lddt das file unter dem Cursor",0,0
;buildincludehelp      Dc.b "Erzeugt Hilfeindex",0,0
;warningtitle          Dc.b "!!! PROGRAMM LDUFT: NUR SPEICHERN ALS/NAVIGATION/HILFE ERLAUBT ...",0
;CEND
short1                Dc.b "T"
short2                Dc.b "B"
short3                Dc.b 0
Even

wzgui:                IncBin "ped.wizard"

instring              Dc.b 0
instring2             Dc.b 0
instring3             Dc.b 0
modifymark            Dc.b "*"
none                  Dc.b "unnamed",0 : Even
historypointer:       Dc.l 0
oldsearch             Dc.w 0
ptr_deflibsfilename   Dc.l 0
ptr_incdirname        Dc.l 0
taskaddr              Dc.l 0
str_spaces            Dcb.b 200,32
str_pedpalfile        Ds.b #MAX_STRINGSIZE
.classiccommands
                      ; memory reservations for libs that where introduced with old blitz2
                      ; here come whole libs
                      Dc.w 11    ;Ricopperfxlib.obj
                      Dc.w 45    ;Risoundlib.obj
                      Dc.w 56    ;Xbciatrackerlib.obj
                      Dc.w 60    ;loadpt
                      Dc.w 82    ;medlib
                      Dc.w 98    ;blitzkeyslib
                      Dc.w 112   ; #spriteslib
                      Dc.w 113   ;cd32lib
                      Dc.w 116   ;audiolib
                      Dc.w 117   ;blitzoslib
                      Dc.w 119   ;2dlib
                      Dc.w 143   ;displaylib
                      Dc.w 144   ;#blitzcoplib
                      Dc.w 146   ;bblitlib
                      Dc.w 148   ;qblitlib
                      Dc.w 150   ;blitlib
                      Dc.w 156   ; #palettelib
                      Dc.w 152   ; #freqlib
                      Dc.w 204   ;bfbplaymaster.library1
                      Dc.w 209   ;thxplay.library1
                      Dc.w 96    ;#trackerlib
                      Dc.w 190   ;gameiolib

                      Dc.w 0     ;say end
                                 ;set breakpoint
                      Dc.w $3385 ;timer commands here come single commands
                      Dc.w $2588 ;timer
                      Dc.w $1784 ;timer
                      Dc.w $4d08 ;get a shape

                      Dc.w 0     ;say end
;othercolor            Dc.w 1
classiccolor          Dc.l 1
olddebugmode          Dc.w $0101
cutmode               Dc.w 0
NOP
blitzname             Dc.b "Blitz3:",0
                      Ds.b #MAX_STRINGSIZE
Even
dummystr              Dc.b ":",0,0
wheelstep             Dc.l 6
Even

BSS
Even
doresize              Ds.b 1
blinkrate             Ds.b 1
blinkcount            Ds.b 1
foundf                Ds.w 1
foundf2               Ds.w 1
yhorizscroll          Ds.w 1
clone_wbscreen        Ds.b 1
no_welcome            Ds.b 1
tokenbackground       Ds.l 1
use_wbscreen          Ds.b 1
clipbuf               Ds.b 300
old_scrolling         Ds.b 1
loadmode              Ds.w 1
filebuff              Ds.b 256
nodelete              Ds.w 1
menuload              Ds.w 1
replacestartcolumn    Ds.w 1
fontwidth             Ds.w 1
topaz8                Ds.l 1
messagestore          Ds.l 1
yposlow               Ds.w 1
nestcount             Ds.l 1
iffound               Ds.b 1
pad                   Ds.b 1
ctrlhelpline          Ds.l 1
oldcolumnsoffset      Ds.w 1
menuitem_debugtoggle  Ds.l 1
firstcolumn           Ds.l 1
skipit                Ds.b 1
redraw_ped            Ds.b 1
foldnum               Ds.l 1
pastecolumn           Ds.w 1
tempstore             Ds.l 1
typestr               Ds.b 80
regstore1             Ds.l 4
colstore              Ds.w 1
storeline1            Ds.l 1
storeline2            Ds.l 1
storeline3            Ds.l 1
lastedited_line       Ds.l 1
templine              Ds.l 1
semipos               Ds.w 1
ptr_source_dir        Ds.l 1
amigaguide            Ds.w 1
smart_tokenization    Ds.w 1
textlinestart         Ds.l 1
doedit2               Ds.b 1
isfunction            Ds.b 1
keepstring            Ds.b 1
new_editmode          Ds.b 1
newtypecolor          Ds.l 1
stringcolor           Ds.l 1
macrocolor            Ds.l 1
constantcolor         Ds.l 1
functioncolor         Ds.l 1
macro_                Ds.w 1
;newcolormode          Ds.w 1
remarkcolor           Ds.l 1
remarkbgcolor         Ds.l 1
;currdisplayaddr   ;same label
backgroundcolor       Dc.l 0
oldcurrsourceline     Ds.l 1
helpstring            Ds.b 260
searchmode            Ds.w 1
auto_format           Ds.b 1
columnstore           Ds.w 1
ab2mode               Ds.w 1
slen2                 Ds.l 1
straddr2              Dc.l 0
straddr               Dc.l 0
numcount              Dc.l 0
constantbase          Dc.l 0
newtypebase           Dc.l 0
newsyntax             Dc.l 0
nohelp                Dc.l 0
;mempool               Dc.l 0 ; => moved to common.bb2/comPtr_MemPool
str_oldsearchgadget   Ds.b 260
instrtab              Ds.l 32769
newted                Dc.l 0
message_qualifier     Dc.l 0
message_code          Dc.l 0
message_class         Dc.l 0
olda4                 Dc.l 0
history               Ds.l 10
helpsourceline        Dc.l 0
str_actualline        Dc.b 0,0,0,0,0,0,0,0,0,0
tempbuf               Ds.b 260
convert               Dc.b 0
count                 Ds.l 1
instru                Ds.w 1
chartab               Ds.b 260      ;last
comparetab            Ds.l 1
casemode              Ds.w 1
temp                  Ds.w 1
;_Screen               Ds.l 1
;rastport_             Ds.l 1
namesizestore         Ds.l 1
nodisplaybeep         Ds.l 1
refreshonstore        Ds.w 1        ; zuruecksetzen von PED beim Speichern der Preferences
deftypefound          Ds.w 1
bold_tokens           Dc.w 0
italic_remarks        Dc.w 0
onlinehelp            Dc.b 1
;pos_vertiprop         Ds.w 1       ; obsolete
pos_horizprop         Ds.w 1
blockmarking          Dc.l 0
correct_functions     Dc.b 0
load_last_source      Dc.b 0
use_intellisense      Dc.b 0
auto_constructs       Dc.b 0
