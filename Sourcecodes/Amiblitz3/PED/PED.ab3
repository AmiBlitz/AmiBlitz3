; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "///System"
; ExeFile         = "PED_beta"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 64000
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 3.8.0
; NumberOfBuilds  = 731
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8192
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 16390
; CursorColumn    = 44
; LabelSearch     = "event_arexx"
; LabelRemark     = 0
; LabelAll        = 1
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 25
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 25
; Max Anim        = 1
; Max Sound       = 1
; Max Bank        = 5
; Max Buffer      = 10
; Max Slice       = 10
; Max Page        = 1
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 25
; Max BitMap      = 10
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 25
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: PED                                                                   /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, AmigaOS4, MOS                         /
;/                                                                             /
;/ Date: 01.09.2009                                                            /
;/                                                                             /
;/ Authors: 1990...1996 Mark Silby                                             /
;/          1991...2003 Red When Excited                                       /
;/          2003...2009 Bernd Roesch, Sven Droege                              /
;/          2009...     The Opensource Team                                    /
;/                                                                             /
;/ Requirements: AmigaOS3.1+                                                   /
;/                                                                             /
;/ Purpose:                                                                    /
;/ GUI for AmiBlitz3 programming language.                                     /
;/                                                                             /
;/ Abstract:                                                                   /
;/ This is not a stand alone program. It is launched by the AmiBlitz3 compiler./
;/ See AmiBlitz3 abstract.                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
DEBUG
; -------------------------------------------------------
; KONSTANTENDEFINITIONEN
; -------------------------------------------------------
.CONST
#hardfold                    = 0     ;not working
#filenamepos                 = 1     ;startpos of fileclocknames, was 27 honitos 20191123
#filenameoffs                = 11    ;space betweeen a filename

#maxlabels                   = 512
#maxhistory                  = 4*8
#MAX_SOURCEFILES             = 16

#WZ_singletable              = 1     ; new moved from compiler  tomsmart1
#Max_WZWindows               = 22    ; max of WZ windows (IDs) needed for the functions to (un)lock all WZ windows, at the moment IDs 1-22 are used ( 0 = source window)  tomsmart1


; OS Version to enable/disable various features
#AmigaOS3 = 1
#AmigaOS4 = 2
#MorphOS  = 3
#AROS     = 4



; Tokens IDs
#TOKEN_End       = $8002
#TOKEN_Return    = $8007
#TOKEN_Statement = $8008
#TOKEN_Function  = $8009
#TOKEN_If        = $800B
#TOKEN_While     = $800C
#TOKEN_Macro     = $800D
#TOKEN_Select    = $800E
#TOKEN_Case      = $800F
#TOKEN_For       = $8016
#TOKEN_Then      = $8021
#TOKEN_Stop      = $802D
#TOKEN_TRAP      = $80AE
#TOKEN_Repeat    = $80BB
#TOKEN_EndIf     = $80C0
#TOKEN_Object    = $80D7

;Keycodes
;Raw
#RAWKEY_TAB        = $42
#RAWKEY_ESC        = $45
#RAWKEY_UP         = $4C
#RAWKEY_DOWN       = $4D
#RAWKEY_RIGHT      = $4E
#RAWKEY_LEFT       = $4F

; Vanilla
#VANILLAKEY_RETURN = $0D
#VANILLAKEY_ESC    = $1B
#VANILLAKEY_F1     = $81
#VANILLAKEY_F2     = $82
#VANILLAKEY_F3     = $83
#VANILLAKEY_F4     = $84
#VANILLAKEY_F5     = $85
#VANILLAKEY_F6     = $86
#VANILLAKEY_F7     = $87
#VANILLAKEY_F8     = $88
#VANILLAKEY_F9     = $89
#VANILLAKEY_F10    = $8A
#VANILLAKEY_HELP   = $8B
;---------------

;@@1
!initasm
!basic
optimize 5
Syntax 6
; ---------------------------------------------------- ADD INCLUDEFILES
; ------------------------------------------------------
#use_bbscreen      = 0     ; workaround for screen_close crash
#USE_WBSTARTUPMSG  = 0
#CLIARGMODE        = 0     ; OS-Calls
#MAX_MENUTEMPLATES = 16    ; max custom menuentries

XINCLUDE "/Shared/library_offsets.ab3"
XINCLUDE "/Shared/common.ab3"
XINCLUDE "/Shared/preprocessor.include.ab3"
XINCLUDE "/Shared/ted.include.ab3"

XINCLUDE "v43+.definitions.ab3"                       ; for MouseWheel support  tomsmart1
XINCLUDE "dos.include.ab3"
XINCLUDE "asl.include.ab3"
XINCLUDE "multilist.include.ab3"
XINCLUDE "screen.include.ab3"
XINCLUDE "semaphore.include.ab3"
XINCLUDE "vvblank.include.ab3"
XINCLUDE "cpu.include.ab3"
XINCLUDE "file.include.ab3"
XINCLUDE "clipboard2.include.ab3"
XINCLUDE "translation.include.ab3"

; --------------------------------------------------- Wizard-Extensions
optimize 5 : Syntax 6
#USE_WIZARD = 1
#WZ_USE_IMAGES = 0
XINCLUDE "PE/wizard_Tools.include.ab3"
XINCLUDE "PE/wizard_Table.include.ab3"
XINCLUDE "PE/wizard_ColorWheel.include.ab3"
ColorWheelError.b = False

; --------------------------------------------------- LOGGING
.LOGGING
XINCLUDE "PE/logging.include.ab3"
log_SetLevel{#log_nothing}
log_SetDestination{#log_toconsole,"System/PED.log"}
log_Print{"===================================================================",#log_debug}
!log_AvailMem{"BEGIN"}


; --------------------------------------------------- TYPE DEFINITIONS
.TYPES
DEFTYPE.l quicktype,vars
DEFTYPE.l

NEWTYPE.sourceWindow
  *pedScreen.Screen
  *win.Window
  *font.TextFont
  *fontI.TextFont
  *fontB.TextFont

  statusAreaY.w
  visibleLines.w
  currentLine.l
  currentColumn.w
End NEWTYPE
DEFTYPE.sourceWindow sourceWindow

NEWTYPE.sourceLine              ; offset
  *nextLine.sourceLine          ; 0000
  *previousLine.sourceLine      ; 0004
  strLength.b                   ; 0009
  *strSourceLine.b              ; 000A
End NEWTYPE

NEWTYPE.project
  name.s
  drawer.s
  wizardfile.s
  sourcefile.s[#MAX_SOURCEFILES]
  sourcepath.s[#MAX_SOURCEFILES]
  sourcecounter.b
  pad.b         ; make it even
  ;
  version.w
  revision.w
  ;
  use_wbstartup.b
  use_nocli.b
  use_syntax.b
  use_optimize.b
  value_syntax.b
  value_optimize.b
End NEWTYPE
DEFTYPE.project ab2_project
Dim tempproject$(#MAX_SOURCEFILES,1)

NEWTYPE .pedfilelist
 dummy.b[$DE]
 filename.s
End NEWTYPE


NEWTYPE.tokendata
  *next_token.l
  number.w
  name.s
  help.s
End NEWTYPE
DEFTYPE.tokendata tokeninfo          ; moved to the Newtype definion  tomsmart1 2012 06 18


NEWTYPE .winprefs
  diag_x.w
  diag_y.w
  diag_w.w
  diag_h.w
  diag_on.b

  click_x.w
  click_y.w
  click_w.w
  click_h.w
  click_on.b

  ibrowser_x.w
  ibrowser_y.w
  ibrowser_w.w
  ibrowser_h.w
  ibrowser_on.b

  type_x.w
  type_y.w
  type_w.w
  type_h.w
  type_on.b
  activewin.b

  source_x.w
  source_y.w
  source_w.w
  source_h.w

  short_x.w
  short_y.w
  short_w.w
  short_h.w
  short_on.b

  lbrowser_x.w
  lbrowser_y.w
  lbrowser_w.w
  lbrowser_h.w
  lbrowser_on.b

  console_x.w
  console_y.w
  console_w.w
  console_h.w
  console_on.b
End NEWTYPE

NEWTYPE.custommenu
  itemname.s
  shortcut.s
  id.l
  path.s
  runwbmode.l
  stacksize.l
  prio.l
End NEWTYPE

NEWTYPE.templates
  filename.s
  description.s
End NEWTYPE

; temporaere liste zur Erstellung des browsefiles
NEWTYPE.dirs
  name.s
End NEWTYPE


Dim List dirs.dirs(0)
Dim List custommenu.custommenu(0)
Dim List templates.templates(0)
Dim wpref.winprefs(3)
Dim help$(400)
DEFTYPE .winprefs wtemp
diag_x.l = 0
diag_y.l = 180
diag_w.l = 600
diag_h.l = 80

Dim diag_lab$(15)
Dim diag_val$(15)

; --------------------------- Color settings --------------------------
Dim cmap.rgbval(256)
#AB3_cfunction         = 1
#AB3_cmacro            = 2
#AB3_cstring           = 3
#AB3_cnewtype          = 4
#AB3_cconstant         = 5
#AB3_cremarkforeground = 6
#AB3_cremarkbackground = 7
#AB3_ctoken            = 8
#AB3_ctokenbackground  = 9
#AB3_cbackground       = 10
#AB3_cother            = 11
#AB3_cclassic          = 12

#AB3_screenback        = 20
#AB3_screentext        = 21
#AB3_screenshine       = 22
#AB3_screenfill        = 23
#MAX_AB3Pens           = 24     ; added to replace Array dimension and maxindex for loops  tomsmart1
Dim AB3Pen.w(#MAX_AB3Pens)
Dim AB3RGB.l(#MAX_AB3Pens)
Dim AB3RGB_temp.l(#MAX_AB3Pens)
AB3RGB_copytemp.l = 0           ; added for temporary copy of the select color  tomsmart1

; --------------------------- Cursor modes -----------------------------
#AB3_cursorStyle_block      = 0
#AB3_cursorStyle_line       = 1
#AB3_cursorStyle_underline  = 2
cursorStyle.w               = #AB3_cursorStyle_block

Function.s cursorStyleGetString{value.w}
  Select value
  Case #AB3_cursorStyle_block
    Function Return "block"
  Case #AB3_cursorStyle_line
    Function Return "line"
  Case #AB3_cursorStyle_underline
    Function Return "underline"
  Default
    Function Return "block"
  End Select
End Function

Function.w cursorStyleGetValue{stylestring.s}
  Select LCase$(stylestring)
  Case "block"
    Function Return #AB3_cursorStyle_block
  Case "line"
    Function Return #AB3_cursorStyle_line
  Case "underline"
    Function Return #AB3_cursorStyle_underline
  Default
    Function Return #AB3_cursorStyle_block
  End Select
End Function
; -----------------------------------------------------------------------


Dim operators$(32)                  ; array to store characters to structurize (auto_format-option)
SHARED num_operators.b
Restore key_chars
Repeat
  Read key_char$
  If key_char$<>""
    operators$(num_operators) = key_char$
    num_operators + 1
  EndIf
Until key_char$ = ""

key_chars:
Data.s "=",":","<",">","+","-","/","*","&","|",";",""

Dim lowerchars.b(129)                  ; create a chartable with all characters lowercase
For i.l = 1 To 127
  a$ = LCase$(Chr$(i))
  lowerchars(i) = Asc(a$)
Next
Poke.l ?lowerchartable,&lowerchars(0)      ; make it basic!
Poke.b ?casemode,1
CaseSense Off

browse_macros.l           = Off
browse_instructions.l     = On
browse_includes.l         = On

Dim pos2(15),pos$(15),postype$(15)
MaxLen tmp$               = 512

MaxLen sourcename$        = 96
MaxLen exepathname$       = 96
MaxLen exefilename$       = 96

MaxLen a$                 = 300      ;need for read .xtra
MaxLen aslpath$           = 250
MaxLen aslfile$           = 250
aslpath$ = "" : aslfile$ = "" : a$ = "" : ptn$ = "#?"

MaxLen tsourcedir$        = 192
MaxLen tincludedir$       = 192
MaxLen thepdir$           = 192
MaxLen tautodocdir$       = 192
MaxLen templatefilename$  =  96      ; fuer laden von templates
MaxLen temp_filename$     = 144      ; fuer laden von "jump_onclick"

MaxLen changelog$         = 1024


WZListAdd lst.List         ," "
WZListAdd lst2.List        ," "
WZListAdd list_labels.List ," "
oldfindstr$                = ""
oldreplacestr$             = ""
MaxLen screentitle$        = 96
Dim autodoc_nodes$(256)                            ; was 255 because we use 0 to 255 make 256 entrys Array dimension was to small  tomsmart1
#Max_BlitzLibs             = 256                   ; added and set to 256 to replace wrong 255 hardcoded Array dimension because we use entry 0 to 255 and this are 256 entrys  tomsmart1
Dim lib_mapping$(#Max_BlitzLibs,1)                 ; replaced the wrong 255 with the #Max_Blitzlibs Constant  tomsmart1
Dim lib_check.b(#Max_BlitzLibs)                    ; replaced the wrong 255 with the #Max_Blitzlibs Constant  tomsmart1
For i = 0 To (#Max_BlitzLibs-1)                    ; replaced the hardcoded 255 with (#Max_Blitzlibs-1) because we start at 0  tomsmart1
  lib_mapping$(i,0) = "* unused ID"+Str$(i)+" *"
  lib_mapping$(i,1) = ""
Next i
lib_mapping$(0,0) = "system1.lib"
lib_mapping$(0,1) = "ABCD"
Dim tokentable.b(65536)

; -------------------------------------- structs for source window
DEFTYPE.Screen      *myscreen        ; pointer to a screen
DEFTYPE.DrawInfo    *drawinfo        ; drawing information of that screen

; ------------------------------------------------------
; MACRODEFINITIONS
; ------------------------------------------------------
.MACROS
Macro versions
  "\\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH (\\__DATE_GER__) Build \\__VER_BUILD"
End Macro

Macro regs2stack
  MOVEM.l d0-d7/a0-a6,-(a7)
End Macro

Macro stack2regs
  MOVEM.l (a7)+,d0-d7/a0-a6
End Macro

Macro skipspace
 'nspace1`@
    CMP.b #" ",(`1)
    BNE 'nspace`@
      ADDQ.l #1,`1
  BRA 'nspace1`@
 'nspace`@
End Macro

Macro isLetter
  CMP.b #"A",D2
  BCS.w 'JL_0_60E8`@
    CMP.b #"z",D2
    BHI.w 'JL_0_60E8`@
      CMP.b #"[",D2
      BCS.w 'JL_0_60E6`@
        CMP.b #"a",D2
        BCS.w 'JL_0_60E8`@
     'JL_0_60E6`@:
      CMP.w D2,D2
 'JL_0_60E8`@:
End Macro

Macro newalloc                 ; d0: memSize
  ADDQ.l #4,d0
  MOVE.l _execbase,a6
  MOVE.l comPtr_MemPool,a0
  MOVE.l d0,-(a7)
  JSR _AllocPooled(a6)         ; (a0: poolHeader, d0: memSize)
  MOVE.l (a7)+,d1
  TST.l d0                      ; allocpooled returns memadress in d0
  BEQ 'avp_fail1`@
    MOVE.l d0,a0
    MOVE.l d1,(a0)+
    MOVE.l a0,d0
 'avp_fail1`@
End Macro

Macro newfree
  MOVE.l _execbase,a6
  MOVE.l comPtr_MemPool,a0
  MOVE.l -(a1),d0
  JSR _FreePooled(a6)                                      ; a0: poolHeader, a1: memory, d0: memsize
End Macro

Macro setregsformenuexit                                   ; added to clear the last IDCMP-event to prevent a repeat of it if a new event happends to the sourcewindow if the general_messageloop was not active  tomsmart1
  MOVEQ.l #$00,D6                                          ; to clear the menuitem that was selected
  MOVEQ.l #$00,D7                                          ; to clear the key that was pressed
End Macro


; ------------------------------------------------------
; FUNCTIONDEFINITIONS
; ------------------------------------------------------
.FUNCTIONS
Function TEDGetConstantValue{ptr_constantbase.l,cname$}
  *cb.l = ptr_constantbase
  If *cb
    cfound.b = False
    ;*cb = Peek.l(*cb)
    While *cb AND NOT cfound
      a$ = Peek$(*cb + $13)
      If a$ = cname$
        cfound = True
      Else
        *cb = Peek.l(*cb)
      EndIf
    Wend
    If cfound Then Function Return Peek.l(*cb+8)
  EndIf
End Function

Function.b CheckChr{char$,table$}
  For i.b = 1 To Len(table$)
    If char$ = Mid$(table$,i,1)
      Pop If : Pop For
      Function Return True
    End If
  Next i
  Function Return False
End Function

Function.s PED_GetWordAtPos{text$, textX.w}
  ;*textline.l = TEDGetCurrentLine{} + 9
  ;*detokened.l = TEDDetoke{*textline}
  ;text$ = Peek$(*detokened)
  tlen.w = FLen(text$)
  If tlen < 2 Then Function Return ""

  If Mid$(text$,textX,1) = "" Then Function Return ""

  result$ = "" : char$ =""
  cursorpos.w = textX
  nextpos.w = cursorpos
  backpos.w = cursorpos - 1
  Repeat
    result$ = char$ + result$
    char$ = Mid$(text$,backpos,1)
    backpos - 1
  Until CheckChr{char$," .,+&!|(){}[]<>"+Chr$(34)} OR (backpos<0)
  char$ = ""

  Repeat
    result$ = result$ + char$
    char$ = Mid$(text$,nextpos,1)
    nextpos + 1
  Until CheckChr{char$," .,+&!|(){}[]<>"+Chr$(34)} OR (nextpos>(tlen+1))
  Function Return StripLead$(result$,32)
End Function



Statement Show_Helpfile{libname$,node$,pubscreen$}
  SHARED my_maindir$,helpdir$

  If node$="" Then node$ = "main"
  commandlineStr.s + " -q -t " + node$
  If libname$<>"" Then commandlineStr + " -l " + dos_RemExt{libname$}
  If helpdir$<>"" Then commandlineStr + " -d " + helpdir$

  log_Print{"seaching for <" + commandlineStr + ">"}
  If pubscreen$<>"" AND (use_wbscreen.b = 0)
    commandlineStr + " -s " + Peek$(?str_defaultpubscreen)
  Else
    commandlineStr + " -s Workbench"
  EndIf
  dos_RunCli{dos_AddPart{my_maindir$,"Tools/AB3HelpViewer"},0,8192,False,commandlineStr} ; changed to match up the last dos.include this fix the show of the help/doc files
End Statement

Function.b CheckWindow{title$}

  succ.b = True
  *thisscreen.Screen = Peek.l(Addr Screen(0))
  *conwin.Window = *thisscreen\FirstWindow
  While (*conwin<>0) AND Peek$(*conwin\Title)<>console_title$
    *conwin = Peek.l(*conwin)
  Wend
  If *conwin=0 Then succ = False

  Function Return succ
End Function


Statement SetScreenTitle{text$}
  SHARED screentitle$            ; has to be shared, because on exit of function the variable will be discarded
  winaddr.l = ActiveWindow
  If winaddr
    screentitle$ = text$
    If screentitle$ <> ""
      SetWindowTitles_ winaddr,-1,&screentitle$
    EndIf
  EndIf
End Statement

Function.s PED_GetLibname{libnum.w}
  SHARED lib_mapping$()
  Function Return lib_mapping$(libnum,0)
End Function


Function.s PED_GetFirstTokenname{libnum.w}
  SHARED lib_mapping$()
  Function Return lib_mapping$(libnum,1)
End Function


Function.s PED_GetTokenName{*tokeninfo.tokeninfo,tnumber.w}
  While *tokeninfo
    If *tokeninfo\number = tnumber Then Function Return Peek.s(&*tokeninfo\dat)
    *tokeninfo = *tokeninfo\next_token
  Wend
  Function Return "" ; token not found
End Function


Function.w PED_GetTokenID{*tokeninfo.tokeninfo,tname$}
  lname$ = LCase$(tname$)
  While *tokeninfo
    If LCase$(Peek.s(&*tokeninfo\dat)) = lname$ Then Function Return *tokeninfo\number
    *tokeninfo = *tokeninfo\next_token
  Wend
  Function Return -1 ; token not found
End Function


Function.w PED_GetTokenLibnum{*tokeninfo.tokeninfo,tname$}
  number.w = PED_GetTokenID{*tokeninfo.tokeninfo,tname$}
  If number><-1 Then Function Return (number LSR 7)
  Function Return -1 ; token not found
End Function


Function.s PED_GetTokenHelp{*tokeninfo.tokeninfo,tname$}
  lname$ = LCase$(tname$)
  While *tokeninfo
    If LCase$(Peek.s(&*tokeninfo\dat)) = lname$
      ;Function Return tname$ + "  ; " + Peek.s(&*tokeninfo\dat+FLen(tname$)+1)
      Function Return Peek.s(&*tokeninfo\dat+FLen(tname$)+1)
    End If
    *tokeninfo = *tokeninfo\next_token
  Wend
  Function Return "" ; token not found
End Function


NEWTYPE .HelpIndexCacheItem
  name.s
  lname.s
  help.s
  includefile.s
End NEWTYPE
Dim List HelpIndexCache.HelpIndexCacheItem(0)


Statement PED_LoadHelpIndexFile{HelpIndexFile$}
  SHARED HelpIndexCache()
  ;fidW.l = file_Open{"sys:pedbug.txt",#file_forcewrite}
  fid.l = file_Open{HelpIndexFile$,#file_read}
  If fid<>-1
    ClearList HelpIndexCache()
    ;file_Cache{fid}
    While file_EOF{fid}=False
      zeile$ = file_ReadLine{fid}

      pos_name.l  = Instr(zeile$,"\\09",1)
      If pos_name=0 Then pos_name=FLen(zeile$)+1

      pos_desc.l  = Instr(zeile$,"\\09",pos_name+1)
      If pos_desc=0 Then pos_desc=FLen(zeile$)+1

      typ$  = Mid$(zeile$,1,pos_name-1)
      name$ = Mid$(zeile$,pos_name+1,pos_desc-pos_name-1)
      help$ = Mid$(zeile$,pos_desc+1)

      ;file_WriteLine{fidW,typ$+"::"+name$+"::"+help$}
      If typ$><""
      If typ$ = "FILE"
        filename$ = name$
      Else

        lname$ = LCase$(name$)
        If name$><""
          If help$=""
            Select typ$
              Case "FUNC" : help$ = "{...} ; Function"
              Case "MACR" : help$ = "{...} ; Macro"
              Case "STAT" : help$ = "{...} ; Statement"
              Default
                help$ = typ$
            End Select
          End If
          If AddItem(HelpIndexCache())
            HelpIndexCache()\name  = name$
            HelpIndexCache()\lname = lname$
            HelpIndexCache()\help  = help$
            HelpIndexCache()\includefile = filename$
          End If
        End If
      End If
      End If
    Wend
    file_Close{fid}
  End If
  ;If fidW><-1 Then file_Close{fidW}

End Statement


Statement PED_WriteHelpIndexCache{HelpIndexCacheFile$}
  SHARED HelpIndexCache()

  If dos_Exist{HelpIndexCacheFile$}        ; test if it already exists
    dos_Delete{HelpIndexCacheFile$}        ; then delete to prevent problem if the new file is smaller then the old   tomsmart1
  EndIf
  If OpenFile(1,HelpIndexCacheFile$)
    ResetList HelpIndexCache()
    While NextItem(HelpIndexCache())
      WriteType 1,HelpIndexCache()
    Wend
    CloseFile 1
  End If
End Statement


Statement PED_ReadHelpIndexCache{HelpIndexCacheFile$}
  SHARED HelpIndexCache()
;  fidW.l = file_Open{"sys:pedbug.txt",#file_forcewrite}

  If OpenFile(1,HelpIndexCacheFile$)
    ClearList HelpIndexCache()
    _lof.l = Lof(1)
    While _lof > Loc(1)
      If AddLast(HelpIndexCache())
        ReadType 1,HelpIndexCache()
        ;!cout{"*"+HelpIndexCache()\name+"*"}
        ;file_WriteLine{fidW,HelpIndexCache()\name}

      Else
        error{!TRANS{"Could not build index cache."}}
        Pop While: Goto exit_while
      EndIf
    Wend
    exit_while:
    CloseFile 1
  Else
    error{HelpIndexCacheFile$ + " "+!TRANS{"not found."}}
  End If

;  If fidW><-1 Then file_Close{fidW}

End Statement


Function.s PED_GetIncludeHelp{tname$}
  SHARED HelpIndexCacheFile$,HelpIndexCache()
  lname$ = LCase$(tname$)
  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then PED_ReadHelpIndexCache{HelpIndexCacheFile$}
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache())
    If HelpIndexCache()\lname = lname$
      Function Return HelpIndexCache()\help
    End If
  Wend
  Function Return ""                 ; function not found
End Function


Function.s PED_GetIncludeFunction{tname$}
  SHARED HelpIndexCacheFile$,HelpIndexCache()
  lname$ = LCase$(tname$)
  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then PED_ReadHelpIndexCache{HelpIndexCacheFile$}
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache())
    If HelpIndexCache()\lname = lname$
      Function Return HelpIndexCache()\name
    End If
  Wend
  Function Return ""                 ; function not found
End Function


Function.s PED_GetIncludeName{tname$}
  SHARED HelpIndexCacheFile$,HelpIndexCache()
  lname$ = LCase$(tname$)
  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then PED_ReadHelpIndexCache{HelpIndexCacheFile$}
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache())
    If HelpIndexCache()\lname = lname$
      Function Return HelpIndexCache()\includefile
    End If
  Wend
  Function Return "" ; function not found
End Function


Function.s PED_GetMacroHelp{macrobase.l,mname$}
  *mpointer.b = macrobase : mfound.b = False : mcounter.l = 0 : mname$ = StripLead$(StrLower(mname$),Asc("!"))
;  MOVE.l macrobase,a0:MOVE.l (a0),token@(a5)
  Repeat
    b$ = Peek$(*mpointer + 13)
    If StrLower(b$) = mname$
      i.l = Peek.w(*mpointer + 8)
      If i > 90 Then i = 90
      macroP.l = Peek.l(*mpointer + 4)
      If macroP Then help.s = StripLead$(Peek.s(macroP),32)
      help = StripLead$(help,@";")
      Function Return help
    End If
    *mpointer = Peek.l(*mpointer)
  Until *mpointer = 0
  Function Return ""
End Function


Function.s PED_GetMacroName{macrobase.l,mname$}
  *mpointer.b = macrobase : mfound.b = False : mcounter.l = 0 : mname$ = StripLead$(StrLower(mname$),Asc("!"))
;  MOVE.l macrobase,a0:MOVE.l (a0),token@(a5)
  Repeat
    b$ = Peek$(*mpointer + 13)
    If StrLower(b$) = mname$
      Function Return b$
    End If
    *mpointer = Peek.l(*mpointer)
  Until *mpointer = 0
  Function Return ""
End Function


Function PED_PrintStatus{txt$,xpos.w,@ypos.w}
  SHARED sourceWindow,AB3Pen()

  USEPATH sourceWindow
  If \win
    If FLen(txt$) > 0
      xpos_text.l = \win\GZZWidth - (\font\tf_XSize) * xpos - 4
      If ypos <> -1
        ypos_text.w = \statusAreaY + (\font\tf_YSize) * ypos
      Else
        ypos_text.w = \statusAreaY + (\font\tf_YSize)
      EndIf

      SetAPen_ \win\RPort, AB3Pen(#AB3_screenshine)
      SetBPen_ \win\RPort, AB3Pen(#AB3_screenfill)
      Move_ \win\RPort, xpos_text, ypos_text

      If Vallong(txt$) > 0                                   ; boldtext for numbers
        SetFont_ \win\RPort,\fontB
        SetSoftStyle_ \win\RPort,#FSF_BOLD,#FSF_BOLD
      EndIf
      Text_ \win\RPort,&txt$,FLen(txt$)

      SetFont_ \win\RPort,\font
      SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_BOLD
      SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    EndIf
  Else
    log_Print{"PrintStatus(): window pointer empty!"}
  EndIf
End Function



Statement move_cursor {a$,lst.l,pos.l}
         ;Select EventCode
;loopm1:vvblank_resetsync{}
;           If RawKeyState(#RAWKEY_UP)
;                   i.l = WZListPos (a$)
;                   If i Then i = i-1 : WZPrint a$,pos,lst,i
;                   vvblank_wait_sync{4}:Goto loopm1
;           End If
;           If RawKeyState(RAWKEY_DOWN)
;                   i = WZListPos (a$):
;                   If i <WZListItems(lst)-2 Then i = i+1:WZPrint a$,pos,lst,i
;                   vvblank_wait_sync{4}:Goto loopm1
;           End If
;         ;End Select
End Statement


Statement ActivateWZGadget{ag$}  ;ag$ = gadget         ; renamed to better match what it did  tomsmart1 2012 03 09
  ActivateGadget_ WZGadAddr(ag$),WZWindowAddr,0
End Statement


Statement ChangeWZWindowTitle{wzwinname.s,newtitle.s}  ; made a Statement to remove double code tomsmart1 2012 03 09
   SHARED NewWZWindowTitle.s                           ; make it global else it get freed after the Statement is finshed
   ; set windowtitle for wizard window                                ;tomsmart1
   ;*win.Window = WZWindowAddr                                         ;get window pointer works, but i find it not save  tomsmart1
   *wzwin.Window = Peek.l(Addr Window(WZID(wzwinname) ) )               ;get window pointer  tomsmart1
   NewWZWindowTitle = newtitle                                             ;new window title tomsmart1
   SetWindowTitles_ *wzwin,&NewWZWindowTitle,-1                              ;show new window title  tomsmart1
End Statement


; lock all open WZ windows  tomsmart1
Statement LockAllOpenWZWin{ }
  usedwin.l = Used Window                     ; save the current active window
  Statement Return
  log_Print{"locking all windows..."}
  For i.l = 1 To #Max_WZWindows               ; 0 = source win , 1 the first WZ win
    If (Peek.l(Addr Window(i) ) >< 0 )        ; test if window is open
      Use Window i
      *w.Window = Peek.l(Addr Window(i) )
      wname$ = Trim$(Peek$(*w\Title))
      log_Print{Str$(i) + "  [" + wname$ + "]"}
      If wname$<>""
        If WZHandle
          ;WZ_LockWindow_ WZHandle  ; lock the window
        EndIf
      EndIf
    EndIf
  Next i
  log_Print{"...done"}
  If (usedwin >< -1) Then Use Window usedwin  ; reactive the active window
End Statement

; unlock all open WZ windows  tomsmart1
Statement UnlockAllOpenWZWin{ }
  usedwin.l = Used Window                     ; save the current active window
  Statement Return
  For i.l=1 To #Max_WZWindows                 ; 0 = source win , 1 the first WZ win
    If (Peek.l(Addr Window(i) ) >< 0 )        ; test if window is open
      Use Window i
      WZ_UnlockWindow_ WZHandle               ; unlock the window
    EndIf
  Next

  If (usedwin >< -1) Then Use Window usedwin  ; reactive the active window
End Statement


Statement window_welcome{txt0$,@txt1$,@txt2$,@txt3$,@txt4$}
 SHARED my_systemdir$
  pngimage.l = -1
  ; -- es kommt zu einem Enforcerhit beim beenden von Amiblitz3, wenn dieses Fenster geoeffnet wurde !??
  Gosub set_pointer_busy_bas
  LockAllOpenWZWin{}

  WZWindow WZID("WIN_WELCOME"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_WELCOME")

  If (txt0$<>"")
    sharp.b = Instr(txt0$,"#")
    vlen.b = Len(txt0$)
    pv$ = Left$(txt0$,sharp - 1)
    cv$ = Right$(txt0$,vlen - sharp)
    WZPrint "PED",&pv$
    WZPrint "COMPILER",&cv$
  EndIf

  If (txt1$<>"") AND (txt2$<>"")
    WZPrint "TEXT1",&txt1$
    WZPrint "TEXT2",&txt2$
  EndIf

  WZPrint "ACIDLIBS_TEXT",&txt3$
  WZPrint "DEFLIBS_TEXT",&txt4$

  welcome_Exit.b = False
  Repeat
    ev.l = WaitEvent

    If RawKeyState(#RAWKEY_ESC) Then ev = 0 : welcome_Exit = True

    Select ev
    Case #IDCMP_IDCMPUPDATE
      If WZGadName = "WELCOME_OK"
        welcome_Exit = True
      EndIf
    Case #IDCMP_CLOSEWINDOW
      welcome_Exit = True
    End Select
  Until welcome_Exit

  WZCloseWindow WZID("WIN_WELCOME")
  FlushEvents

  Gosub activatesourcewindow
  UnlockAllOpenWZWin{}
  Gosub set_pointer_normal_bas
End Statement


Function.w getLineLength{lineaddr.l}
  _length.w = #MAX_Columns - 1
  exit_loop.b = False
  ;log_Print{"**" + Peeks$(lineaddr,_length) + "**"}
  Repeat
    char.b = Peek.b(lineaddr + _length)
    If char<>$20
      exit_loop = True
    Else
      _length - 1
    EndIf
  Until exit_loop OR _length < 1
  _length + 1
  ;log_Print{Str$(_length)}
  ;!log_AvailMemhex{lineaddr,255}
  Function Return _length
End Function

Function.b cutLine{*sl.sourceLine}
    *prevLine.sourceLine = *sl\previousLine
    *nextLine.sourceLine = *sl\nextLine
    If (*prevLine = 0) AND (*nextLine = 0)
      Function Return False
    End If
    ; clear old references to other lines
    *sl\previousLine = 0
    *sl\nextLine = 0

    ; connect previous and next line to cut current line off
    If *prevLine <> 0
      *prevLine\nextLine = *nextLine
    End If
    If *nextLine <> 0
      *nextLine\previousLine = *prevLine
    End If

    Function Return True
End Function

Statement appendLine{*afterLine.sourceLine, *appendLine.sourceLine, tempfsl.l}
  ; afterLine: the line to append the appendLine to
  ; appendLine: the line to append after the afterLine
  ; tempfsl: Pointer to FirstSourceLine

  If *afterLine = 0                           ; previous line has no previous line
    ;log_Print{"no previousline"}

    *exfirstLine.sourceLine = Peek.l(tempfsl)
    *exfirstLine\previousLine = *appendLine

    *appendLine\previousLine = 0
    *appendLine\nextLine = *exfirstLine

    Poke.l tempfsl, *appendLine

  Else
    *nextLine.sourceLine = *afterLine\nextLine
    *appendLine\previousLine = *afterLine
    *appendLine\nextLine = *nextLine

    If *nextLine <> 0
      *nextLine\previousLine = *appendLine
    EndIf
    *afterLine\nextLine = *appendLine
  EndIf
End Statement

Function.s check_constructs{*currentline.l}    ; fixed this function  tomsmart1

  a$ = ""
  ;!cout{"currentline=",Hex$(*currentline) }
  *previusline.l = Peek.l(*currentline) + 4    ; get pointer of previus sourceline
  ;!cout{"previusline=",Hex$(*previusline) }
  If *previusline >< Null
    *textline.l = Peek.l(*previusline) + 9     ; get pointer of previus sourceline text
    ;!cout{"textline=",Hex$(*textline) }
    If *textline >< Null
      textaddr.l = Peek.l(*textline)           ; get address of the text
      bytecount.w = 0
      ;!cout{"textaddr=",Hex$(textaddr)}
      While (textaddr LSR 16) <> $0000
        textaddr = Peek.l(*textline + bytecount)
        ;!cout{"testaddr+bytecount=",Hex$(textaddr)}
        actword.w = textaddr LSR 16

        ; check the token too select the end token(s)
        Select actword
          Case #TOKEN_Then      : a$ = ""
          Case #TOKEN_Statement : a$ = "End Statement"
          Case #TOKEN_Function  : a$ = "End Function"
          Case #TOKEN_If        : a$ = "EndIf"
          Case #TOKEN_While     : a$ = "Wend"
          Case #TOKEN_Macro     : a$ = "End Macro"
          Case #TOKEN_Select    : a$ = "End Select"
          Case #TOKEN_Repeat    : a$ = "Until"
          Case #TOKEN_For       : a$ = "Next"
        End Select
        bytecount + 1
      Wend
    EndIf
  EndIf
 Function Return a$
End Function


Function.w preparseline{columnpos.w,lineaddr.l,auto_format.b,correct_funcnames.b}
  SHARED operators$(),num_operators

  ; clear highlight info but dont trash strings
  ;If (lineaddr MOD 2) <> 0 Then !cout{"alert: odd address " + Hex$(lineaddr)}
  If (lineaddr & $1) <> 0 Then !cout{"alert: odd address " + Hex$(lineaddr)}
  nostring.b = 0
  For i.l = lineaddr To lineaddr + #MAX_Columns
    If nostring = 0
      Poke.b i,Peek.b(i) AND $7f
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
    If Peek.b(i) = $22 Then nostring = 1
    ; workaround:
    ; sometimes there is a 0 in a linestring perhaps due
    ; to a wrong lineaddr
    ; the 0 is been replaced by a space
    If Peek.b(i) = 0 Then Poke.b i,32
  Next

  strg$ = Peeks$(lineaddr,#MAX_Columns) ; check this, was Peeks$$ before!

  ; --
  ; -- checking if editing a comment
  test_semi$ = StripLead$(strg$,@" ")
  kommata.w  = Instr(test_semi$,";")
  If kommata AND (kommata < columnpos) Then Function Return columnpos

  len_strg.w = StrLen(StripTrail$(strg$,@" ") )

  line_changed.b = False

  ; --
  ; -- replace lower written functionames with correct cases
  If correct_funcnames
    correctpos.w = 0                                               ; added to make a test of the complete line and begin at position 0  tomsmart1
    Repeat                                                         ; added loop to test the complete line  tomsmart1
      correctklammer.w = 0                                         ; added to clear it every loop entry and renamed it to make it unique  tomsmart1
      correctklammer   = Instr(strg$,"{",correctpos) - 1           ; expand search command to begin search at a spezific position  tomsmart1

      If correctklammer > 0
        run_left.l = -1

       again:
        Repeat
          run_left + 1
          char.l = Asc( Mid$(strg$,correctklammer - run_left,1) )
        Until ( ( (char<65) AND (char<>33) AND ( (char<48) OR (char>57) ) ) OR (char>122) OR ( (char>90) AND (char<95) ) OR (run_left >= correctklammer) )
        If (char = Asc(" ") AND run_left = 0) Then Goto again
        ; ! = 33
        ; 0 = 48; 9 = 57
        ; A = 65, Z = 90
        ; a = 97, z = 122
        funcname$ = StrSub(strg$,correctklammer - run_left + 1,run_left)
        funcname$ = StrChg(funcname$," ","")
        newfuncname$ = PED_GetIncludeFunction{funcname$}
        If newfuncname$<>""
          strg$ = StrChg(strg$,funcname$,newfuncname$)
          line_changed = True
        EndIf
        correctpos = correctklammer + 2                           ; added to let the next test begin at behind the first find position  tomsmart1
        If correctpos >= FLen(strg$) Then correctklammer = -1     ; added to test if we are in the string/line if not set the exit loop condition  tomsmart1
      EndIf
    Until correctklammer = -1                                     ; added loop to test the complete line  tomsmart1
  EndIf

  ; structurization of source
  If auto_format
    neustrg$ = ""
    make_struct.b = On
    For j.w = 1 To len_strg
      double_operator.b = False
      temp_disabled.b = Off
      no_pre_pad.b = Off
      no_post_pad.b = Off
      comment_mode.b = Off

      char$ = Mid$(strg$,j,1)
      If char$<>" "
        For k.w = 0 To num_operators-1
          If char$ = operators$(k)
            For l.w = 0 To num_operators - 1
              If last_op$ = operators$(l) Then double_operator = True
            Next
            If NOT double_operator
              op_found.b = True
              Pop For
              Goto exit_for
            EndIf
          Else
            op_found = False
          EndIf
        Next k
        exit_for:
        If char$ = Chr$(34) Then make_struct = -1 + Abs(make_struct)

        If (op_found = True) AND (last_op$ <> "=")
          last_op$ = char$

          Select char$
            Case ";"      ; innerhalb von Kommentaren nicht strukturieren
              comment_mode = On

            Case "-"      ; eine Zuweisung mit neg. Wert nicht formatieren
              If Mid$(strg$,j - 2,2) = "= " OR Mid$(strg$,j - 1,1) = "="
                temp_disabled = On
              EndIf

            Case "<"
              If Mid$(strg$,j-2,2) = "> " OR Mid$(strg$,j-1,1)=">"
                no_pre_pad = On
              EndIf
              If Mid$(strg$,j+2,2) = "> " OR Mid$(strg$,j+1,1)=">"
                no_post_pad = On
              EndIf

            Case ">"
              If Mid$(strg$,j-2,2) = "< " OR Mid$(strg$,j-1,1)="<"
                no_pre_pad = On
              EndIf
              If Mid$(strg$,j+2,2) = "< " OR Mid$(strg$,j+1,1)="<"
                no_post_pad = On
              EndIf

          End Select

          If make_struct AND (j > 1) AND (NOT temp_disabled) AND (NOT comment_mode = On)
            pad_pre$ = "" : pad_post$ =""
            If Mid$(strg$,j - 1,1) <>" " Then pad_pre$  = " " : columnpos + 1
            If Mid$(strg$,j + 1,1) <>" " Then pad_post$ = " " : columnpos + 1
            If no_pre_pad                Then pad_pre$  = ""  : columnpos - 1
            If no_post_pad               Then pad_post$ = ""  : columnpos - 1
            char$ = pad_pre$ + char$ + pad_post$
            line_changed = True
          EndIf
        Else
          last_op$ = ""
        EndIf
      EndIf
      neustrg$ + char$
    Next j
    strg$ = neustrg$
  EndIf

  ; --- write formated textline into textbuffer
  If line_changed
    strg$ = StrLeft(strg$,#MAX_Columns,32)
    For i.l = lineaddr To lineaddr + (#MAX_Columns - 6)
      achar.b = Asc(Mid$(strg$,i + 1 - lineaddr,1))
      Poke.b i,achar
    Next
  EndIf

  ; --- return new cursorposition if something as changed
  Function Return columnpos
End Function


Statement savewinpref{num.l,@sourcewin.l}
  SHARED wpref(),wtemp,console_title$,sourceWindow

  used_win.l = Used Window
  ret.l = ask{!TRANS{"The window settings have been saved.\\nPress appropriate FN-Key (F4-F6) to set window configuration."},!TRANS{"Ok"},!TRANS{"Info"}}
  USEPATH wtemp

  \lbrowser_on = 0
  \ibrowser_on = 0
  \type_on = 0
  \diag_on = 0
  \click_on = 0
  \short_on = 0
  \activewin = 0

  If WZ_CheckOpen{"WIN_LIBRARYBROWSER"}
     Use Window WZID("WIN_LIBRARYBROWSER")
     \lbrowser_x  = WindowX
     \lbrowser_y  = WindowY
     \lbrowser_w  = WindowWidth
     \lbrowser_h  = WindowHeight
     \lbrowser_on = 1
  End If
  If WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"}
     Use Window WZID("WIN_INSTRUCTIONBROWSER")
     \ibrowser_x  = WindowX
     \ibrowser_y  = WindowY
     \ibrowser_w  = WindowWidth
     \ibrowser_h  = WindowHeight
     \ibrowser_on = 1
  End If
  If WZ_CheckOpen{"WIN_NEWTYPE"}
     Use Window WZID("WIN_NEWTYPE")
     \type_x  = WindowX
     \type_y  = WindowY
     \type_w  = WindowWidth
     \type_h  = WindowHeight
     \type_on = 1
  End If
  If WZ_CheckOpen{"WIN_HELPDIAG"}
     Use Window WZID("WIN_HELPDIAG")
     \diag_x  = WindowX
     \diag_y  = WindowY
     \diag_w  = WindowWidth
     \diag_h  = WindowHeight
     \diag_on = 1
  End If
  If WZ_CheckOpen{"WIN_LABELS"}
     Use Window WZID("WIN_LABELS")
     \click_x  = WindowX
     \click_y  = WindowY
     \click_w  = WindowWidth
     \click_h  = WindowHeight
     \click_on = 1
  End If
  If WZ_CheckOpen{"WIN_SHORTCUTS"}
     Use Window WZID("WIN_SHORTCUTS")
     \short_x  = WindowX
     \short_y  = WindowY
     \short_w  = WindowWidth
     \short_h  = WindowHeight
     \short_on = 1
  EndIf

  If sourcewin > 0
    \source_x = sourceWindow\win\LeftEdge
    \source_y = sourceWindow\win\TopEdge
    \source_w = sourceWindow\win\Width
    \source_h = sourceWindow\win\Height
  EndIf

  ; -- check if console is open and store its position
  *thisscreen.Screen = Peek.l(Addr Screen(0))
  *conwin.Window = *thisscreen\FirstWindow
;  message{"error"}
  security.l=0
  If *conwin
    While (*conwin<>0)
      If Peek$(*conwin\Title)<>console_title$
        If Peek.l(*conwin) Then *conwin = Peek.l(*conwin) Else *conwin = 0
      Else
        Pop While
        Goto exit_consearch
      EndIf
      ; notbremse fuer while-loop
      security + 1
      If security > 30 Then *conwin = 0
    Wend
  EndIf
  exit_consearch:
  If *conwin
    \console_x = *conwin\LeftEdge
    \console_y = *conwin\TopEdge
    \console_w = *conwin\Width
    \console_h = *conwin\Height
  EndIf
  Use Window used_win
  CopyMem_ &wtemp,&wpref(num),SizeOf .winprefs
End Statement


Statement read_libmapping{_file.s}
  SHARED *tokenbase.tokeninfo
  SHARED lib_mapping$()

  Dim templist$(#Max_BlitzLibs,1)          ;replaced hardcoded 255 with #Max_BlitzLibs because we start with 0 to 255 makes 256 entrys max  tomsmart1
  DEFTYPE.w libcounter,i

  fid.l = file_Open{_file,#file_read}
  If fid<>-1
    file_Cache{fid}
    log_Print{"loading libslist..."}
    Repeat
      zeile$ = file_ReadLine{fid}
      qpos.w = Instr(zeile$,";")
      If qpos
        lstring$ = Left$(zeile$,qpos-1)
        rstring$ = Right$(zeile$,FLen(zeile$)-qpos)

        ; get libnumber from internal structure
        templist$(libcounter,0) = StrChg(lstring$," ","")
        templist$(libcounter,1) = StrChg(rstring$," ","")
        libcounter + 1
      EndIf
    Until file_EOF{fid}
    file_Close{fid}
    If libcounter = 0 Then Statement Return

    log_Print{"scanning tokenlist..."}
    *tpointer.l = *tokenbase
    If *tpointer
      Repeat
        token_next.l   = Peek.l(*tpointer)
        token_name$    = Peek$(*tpointer+6)
        libnum.w = Peek.w(*tpointer+4) LSR 7

        For i = 0 To libcounter
          If templist$(i,1) = token_name$
            If libnum > 0
              libname$ = templist$(i,0)
              firsttoken$ =  templist$(i,1)
              If (Instr(lib_mapping$(libnum,0),"unused")=0)
                message$= !TRANS{"Library clash!\\n" }
                message$+ !TRANS{"The dynamic added lib"}+" \\22"+libname$+"\\22\\n"
                message$+ !TRANS{"has overwritten"}+" \\22"+lib_mapping$(libnum,0)+"\\22 "+!TRANS{"stored in acidlibs/deflibs"}+".\\n"
                message$+ !TRANS{"Both libs have the same Lib-ID"}+" "+ Str$(libnum)+".\\n\\n"
                message$+ !TRANS{"Sourcecode that uses"}+" "+ lib_mapping$(libnum,0) + " "+!TRANS{"might not work,\\n"}
                message$+ !TRANS{"because these functions are now mapped to"}+" "+libname$+".\\n\\n"
                message$+ !TRANS{"You should remove the appropriate library from userlibs-directory,\\nor change the Lib-ID to a free one."}
                dummy.l = ask{message$,!TRANS{"Ok"},!TRANS{"Error"}}
                lib_mapping$(libnum,0) = libname$ + " ("+!TRANS{ "clashing with"}+" "+lib_mapping$(libnum,0)+")"
              Else
                lib_mapping$(libnum,0) = libname$
              EndIf
              lib_mapping$(libnum,1) = firsttoken$
              Pop If : Pop If : Pop For : Goto exit_this_loop
            EndIf
          EndIf
        Next i
        exit_this_loop:

        *tpointer.l = token_next
      Until (*tpointer = 0)
      log_Print{"scanning finished."}
    EndIf
  EndIf
End Statement


Statement map_tokens_to_libs{_file.s}
  SHARED *tokenbase.tokeninfo
  SHARED lib_mapping$()

  fid.l = file_Open{_file,#file_read}
  If fid<>-1
    ; check content of file, if there is only little garbage, then ignore it
    If file_GetLength{fid} < 5
      file_Close{fid}
      Statement Return
    EndIf

    log_Print{"building hashmap..."}
    *hm.hashmap = hashmap_Create{8}
    file_Cache{fid}
    Repeat
      zeile$ = file_ReadLine{fid}
      qpos.w = Instr(zeile$,";")
      If qpos
        lstring$ = Left$(zeile$,qpos-1)
        rstring$ = Right$(zeile$,FLen(zeile$)-qpos)

        ; get libnumber from internal structure
        libname$ = StrChg(lstring$," ","")
        firsttoken$ = StrLower(StrChg(rstring$," ",""))
        hashmap_AddItem{*hm, firsttoken$, libname$}
      EndIf
    Until file_EOF{fid}
    file_Close{fid}

    ; running through the tokenindex and map tokens to library names
    log_Print{"scanning tokenlist..."}
    *tpointer.l = *tokenbase
    If *tpointer
      currentLibName$ = ""
      Repeat
        token_next.l   = Peek.l(*tpointer)
        token_name$    = Peek$(*tpointer+6)
        libnum.w       = Peek.w(*tpointer+4) LSR 7

        If libnum > 0
          ; check if token is first token of a blitzlib
          libname$ = hashmap_GetItem{*hm, StrLower(token_name$)}
          If libname$ = ""
            libname$ = currentLibName$
          End If

          ; check if token is part of library, that is already used
          ; if libnum is unused, map libname to libnum
          ; if a libnum appears, here a libname has been mapped, we have a libclash!
          If libname$ <> ""
            ;log_Print{"first token of library "+libname$+ ": " + lib_mapping$(libnum,0)}
            If Instr(lib_mapping$(libnum,0),"unused") = 0
              message$ = !TRANS{"Library clash!\\n" }
              message$ + !TRANS{"The dynamic added lib"}+" \\22" + libname$ + "\\22\\n"
              message$ + !TRANS{"has overwritten"}+" \\22"+lib_mapping$(libnum,0)+"\\22 "+!TRANS{"stored in acidlibs/deflibs"}+".\\n"
              message$ + !TRANS{"Both libs have the same Lib-ID"}+" "+ Str$(libnum)+".\\n\\n"
              message$ + !TRANS{"Sourcecode that uses"}+" "+ lib_mapping$(libnum,0) + " "+!TRANS{"might not work,\\n"}
              message$ + !TRANS{"because these functions are now mapped to"}+" "+libname$+".\\n\\n"
              message$ + !TRANS{"You should remove the appropriate library from userlibs-directory,\\nor change the Lib-ID to a free one."}
              dummy.l = ask{message$,!TRANS{"Ok"},!TRANS{"Error"}}
              lib_mapping$(libnum,0) = libname$ + " ("+!TRANS{ "clashing with"}+" "+lib_mapping$(libnum,0)+")"
            Else
              lib_mapping$(libnum,0) = libname$
            EndIf
            lib_mapping$(libnum,1) = token_name$
          End If
        EndIf
        *tpointer.l = token_next
      Until (*tpointer = 0)
      log_Print{"scanning finished."}
    EndIf
    hashmap_Free{*hm}
  EndIf
End Statement


Function.l AutoLayout{*wprefs.winprefs,mode.l}
  SHARED al_leftspace.l,al_rightspace.l,al_topspace.l,al_bottomspace.l
  USEPATH *wprefs
  *scr.Screen = Peek.l(Addr Screen(0))
  If *scr=0 Then Function Return False
;  WZ_KillTable{"INSTRUCTIONBROWSER"}
;  ClearMenuStrip_ Peek.l(Addr Window(WZID("WIN_INSTRUCTIONBROWSER")))
;  WZCloseWindow WZID("WIN_INSTRUCTIONBROWSER")
  top.l    = *scr\BarHeight +1 + al_topspace
  bottom.l = *scr\Height-1     - al_bottomspace
  left.l   = 0                 + al_leftspace
  right.l  = *scr\Width-1      - al_rightspace

  lock.l = LockIBase_ (0)
    *myWindow.Window = *scr\FirstWindow

    While *myWindow
      rx.l = *myWindow\Width/*myWindow\Height
      ry.l = *myWindow\Height/*myWindow\Width
      ;If *myWindow\Title Then rx=1 : ry=1
      If *myWindow\Flags&#WFLG_BORDERLESS = 0 Then rx=1 : ry=1
      If rx>2
        If *myWindow\TopEdge+*myWindow\Height-1 >= bottom
          bottom = Min(bottom,*myWindow\TopEdge-1)
        End If
        If *myWindow\TopEdge<*scr\BarHeight
          top    = Max(top,*myWindow\TopEdge+*myWindow\Height)
        End If
      End If

      If ry>2
        If *myWindow\LeftEdge+*myWindow\Width-1 >= right
          right = Min(right,*myWindow\LeftEdge-1)
        End If
        If *myWindow\LeftEdge<=0
          left  = Max(left,*myWindow\LeftEdge+*myWindow\Width)
        End If
      End If
      *myWindow = *myWindow\NextWindow
    Wend

  UnlockIBase_ lock

  width.l  = right-left+1
  height.l = bottom-top+1


  Select mode
    Case 0    ; Layout A
      splitpointY.l  = (bottom-top) * 3/4
      splitpointX.l  = (right-left) * 3/4

      If splitpointY<700              Then splitpointY=height
      If (right-left)-splitpointX<250 Then splitpointX=right-left-250

      ;\source_on   = True            ; source code window
      \source_x    = left,top,splitpointX,splitpointY
      Poke.w ?win_TopLeft,\source_x
      Poke.w ?win_TopEdge,\source_y
      Poke.w ?win_Width  ,\source_w
      Poke.w ?win_Height ,\source_h
      If (splitpointY<bottom-top+1)
        If (splitpointX>1024)
          \ibrowser_on = True        ; Instruction Browser
          \ibrowser_x  = left,(top+splitpointY),(splitpointX/2),bottom-(top+splitpointY)+1
          \lbrowser_on = True
          \lbrowser_x  = left+splitpointX/2,(top+splitpointY),splitpointX-(splitpointX/2),bottom-(top+splitpointY)+1
        Else
          \ibrowser_on = True        ; Instruction Browser
          \ibrowser_x  = left,(top+splitpointY),(splitpointX),bottom-(top+splitpointY)+1
          \lbrowser_on = False
        End If
      Else
        \lbrowser_on = False
        \ibrowser_on = False
      End If
      \click_on    = True            ; Source Browser
      \click_x     = (left+splitpointX),top,width-splitpointX,height*3/5
      \type_on     = True            ; Definition Browser
      \type_x      = (left+splitpointX),(top+height*3/5),width-splitpointX,bottom-((height)*3/5)+1-top

      If splitpointY<height
        \console_x   = left,(top+splitpointY),splitpointX,height-splitpointY
      Else
        \console_x   = left,(top),splitpointX,height
      End If

    Case 1    ; Layout B
      splitpointX1.l  = (width)  * 1/4 : If splitpointX1<400       Then splitpointX1=400
      splitpointX2.l  = (width)  * 3/4 : If width-splitpointX2<250 Then splitpointX2=width-250
      splitpointY.l   = (height) * 3/5

      If splitpointX2-splitpointX1<320 Then splitpointX1=0 ;: splitpointX2.l  = (right-left) * 1/3
      If splitpointY <400              Then splitpointY=0

      ;\source_on   = True ; source code window
      \source_x    = left+splitpointX1,top,splitpointX2-splitpointX1,height
      Poke.w ?win_TopLeft,\source_x
      Poke.w ?win_TopEdge,\source_y
      Poke.w ?win_Width  ,\source_w
      Poke.w ?win_Height ,\source_h

      If (splitpointX1>0)
        If (splitpointY>0)
          \ibrowser_on = True ; Instruction Browser
          \ibrowser_x  = left,top,splitpointX1,splitpointY
          \lbrowser_on = True
          \lbrowser_x  = left,top+splitpointY,splitpointX1,height-splitpointY
        Else
          \ibrowser_on = True ; Instruction Browser
          \ibrowser_x  = left,top,splitpointX1,height
          \lbrowser_on = False
        End If
      Else
        \lbrowser_on = False
        \ibrowser_on = False
      End If
      If (splitpointY>0)
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX2 ,top,width-splitpointX2,splitpointY
        \type_on     = True ; Definition Browser
        \type_x      = left+splitpointX2 ,top+splitpointY,width-splitpointX2,height-splitpointY
      Else
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX2,top,width-splitpointX2,height
        \type_on     = False ; Definition Browser
      End If
      \console_x    = left,(top+splitpointY),width,height-splitpointY

    Case 2    ; Layout C
      splitpointX.l  = (width) * 3/4 : If width-splitpointX<250 Then splitpointX=width-250
      splitpointY.l  = (height) * 3/5
      If splitpointY <400 Then splitpointY=0

      ;\source_on   = True ; source code window
      \source_x    = left,top,splitpointX,height
      Poke.w ?win_TopLeft,\source_x
      Poke.w ?win_TopEdge,\source_y
      Poke.w ?win_Width  ,\source_w
      Poke.w ?win_Height ,\source_h

      \lbrowser_on = False
      \ibrowser_on = False

      If (splitpointY>0)
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX ,top,width-splitpointX,splitpointY
        \type_on     = True ; Definition Browser
        \type_x      = left+splitpointX ,top+splitpointY,width-splitpointX,height-splitpointY
      Else
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX,top,width-splitpointX,height
        \type_on     = False ; Definition Browser
      End If
      \console_x   = left,(top+splitpointY),width,height-splitpointY


  End Select
  USELASTPATH
  Function Return True
End Function


Statement CloseAllWZWindows{}                    ; made a Statement to close all (used) Wizard Windows to remove double code  tomsmart1
  Gosub close_bubblehelp
  Gosub close_popupwindow
  WZ_HideHelp{}                                  ; added because it used for the wz_bubblehelp
  Gosub kill_menus                               ; moved in that everytime tis statment are called the menues are detached fom the wz windows  tomsmart1
  ; windows with menu added
  WZCloseWindow WZID("WIN_INSTRUCTIONBROWSER")
  WZCloseWindow WZID("WIN_NEWTYPE")
  WZCloseWindow WZID("WIN_LABELS")
  WZCloseWindow WZID("WIN_LIBRARYBROWSER")
  WZCloseWindow WZID("WIN_SEARCH")
  WZCloseWindow WZID("WIN_SHORTCUTS")
  WZCloseWindow WZID("WIN_HELPDIAG")
  ; windows with no menu added
  WZCloseWindow WZID("WIN_AUTODOC")
  WZCloseWindow WZID("WIN_HELP")
  WZCloseWindow WZID("WIN_SETTINGS")
End Statement


; Added the menu to the open WZ window
Statement AddedMenu2WZWin{wzwinname.s}
  Use Window WZID(wzwinname)
  If Peek.l(?addr_menustrip)
    SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
  EndIf
End Statement

; Remove the menu and than close WZ window
Statement CloseWZWinWithMenu{wzwinname.s}
  If Peek.l(?addr_menustrip)
    ClearMenuStrip_ Peek.l(Addr Window(WZID(wzwinname) ) )
  EndIf
  WZCloseWindow WZID(wzwinname)
End Statement



;@@0
; -------------------------------------------------------------------------------------
; START DER PROGRAMM ROUTINE
; -------------------------------------------------------------------------------------
.STARTUP_PED
!log_AvailMem{"at PED start"}
FindScreen 0

;
; -- checking for TEDY as input of D1 ...
; -- TEDY nicht in D1, also nicht vom Compiler gestartet
;
!asm
CMP.l #"TEDY",D1
BEQ 'no_exit
  !basic
  error{"PED is not a standalone editor anymore.\\nPlease start the AmiBlitz3-IDE via Compiler."}
  Goto abnormal_exit
'no_exit
!basic

!TRANS_INIT{"AmiBlitz3"}
; -- checking internal data structures...
;
; init the comdata structure
;!ComData_LEA{comFunc_OpenWindow             ,A0}       : MOVE.l #comwin_open                 ,(A0)          ;deactivated because it is not called form the compiler anymore  tomsmart1 2013 12 28
;!ComData_LEA{comFunc_CloseWindow            ,A0}       : MOVE.l #comwin_close                ,(A0) ;$04     ;deactivated because it is not called form the compiler anymore  tomsmart1 2013 12 28
!ComData_LEA{comFunc_MessageLoop            ,A0}        : MOVE.l #general_message_loop        ,(A0) ;$08
!ComData_LEA{comFunc_ErrorRequest           ,A0}        : MOVE.l #show_errorrequester         ,(A0) ;$0C
!ComData_LEA{comFunc_DetokenizeSource       ,A0}        : MOVE.l #DetokenizeSource            ,(A0) ;$10
!ComData_LEA{comFunc_TokenizeSource         ,A0}        : MOVE.l #TokenizeSource              ,(A0) ;$14
!ComData_LEA{comFunc_ASLFileRequest         ,A0}        : MOVE.l #show_aslfilerequest         ,(A0) ;$18
;!ComData_LEA{comFunc_RefreshGadList         ,A0}        : MOVE.l #comwin_refreshglist         ,(A0) ;$1c     ;deactivated because it is not called form the compiler anymore  tomsmart1 2013 12 28
;!ComData_LEA{comFunc_CheckEvents            ,A0}        : MOVE.l #check_events                ,(A0) ;$20
!ComData_LEA{comFunc_SetStoredColors        ,A0}        : MOVE.l #set_storedcolors            ,(A0) ;$30
!ComData_LEA{comFunc_SetStoredColors2       ,A0}        : MOVE.l #set_storedcolors            ,(A0) ;$34
!ComData_LEA{comFunc_DebugTrap              ,A0}        : MOVE.l #com_0_44E2                  ,(A0) ;$38
!ComData_LEA{comFunc_OpenConsole            ,A0}        : MOVE.l #console_open                ,(A0) ;$3C
!ComData_LEA{comFunc_CloseConsole           ,A0}        : MOVE.l #console_close               ,(A0) ;$40
;!ComData_LEA{comFunc_ActivateGadCompilerWin ,A0}        : MOVE.l #activate_gad_in_compilerwin ,(A0) ;$44  ;deactivated because it is not called form the compiler anymore  tomsmart1 2013 12 28
!ComData_LEA{comFunc_SetNormalPointer       ,A0}        : MOVE.l #set_pointer_normal           ,(A0) ;$48
!ComData_LEA{comFunc_SetBusyPointer         ,A0}        : MOVE.l #set_pointer_busy             ,(A0) ;$4C     4c 4d 4e 4f
;!ComData_LEA{comFunc_CloseCompilerWin       ,A0}        : MOVE.l #old_CloseCompilerWin        ,(A0) ;$58  ;deactivated because it is not called form the compiler anymore  tomsmart1 2013 12 28
!ComData_LEA{comFunc_DetokenizeLine         ,A0}        : MOVE.l #detokenize_line             ,(A0) ;$64
!ComData_LEA{comPtr_CurrentDir              ,A0}        : MOVE.l #comStr_CurrentDir           ,(A0) ;$68
!ComData_LEA{comPtr_SourceName              ,A0}        : MOVE.l #comStr_SourceName           ,(A0) ;$6C
!ComData_LEA{comFunc_AL_0_852E              ,A0}        : MOVE.l #AL_0_8BD2                   ,(A0) ;$70
!ComData_LEA{comFunc_AL_0_8532              ,A0}        : MOVE.l #AL_0_8BD6                   ,(A0)
!ComData_LEA{comWord_MaxColumns             ,A0}        : MOVE.w #MAX_Columns                 ,(A0)
;!ComData_LEA{comPtr_CLIArgumentsString      ,A0}       : MOVE.l #compiler_openwindow         ,(A0)  ;was comFunc_OpenCompilerWindow; deactivated for CLIArgs set win in PED  tomsmart1 2013 12 2
!ComData_SetL{comFunc_CloseGUI              ,#close_gui}
!ComData_SetL{comFunc_CreateGUI             ,#create_whole_gui}
!ComData_SetL{comData_Magic                 ,##MagicIdentifier_Long}        ;#"~::~"}  ;

;.comArray_KeyTable:                                           ; vanillakeys
;                                Dc.b $1C,$01                  ; CURSORUP
;                                Dc.l 0;key_cursorup
;                                Dc.b $1D,$01                  ; CURSORDOWN
;                                Dc.l 0;key_cursordown
;                                Dc.b 13,$01                   ; RETURN
;                                Dc.l 0;insertreturn
;                                Dc.b $81,$00                  ; F1               !
;                                Dc.l 0;menu_helpgeneral
;                                Dc.b $82,$00                  ; F2               !
;                                Dc.l 0;menu_helpincludesguide
;                                Dc.b $83,$00                  ; F3               !
;                                Dc.l 0;menu_helpblitzlibs
;                                Dc.b $84,$00                  ; F4               !
;                                Dc.l 0;menu_dublicate
;                                Dc.b $89,$00                  ; F9               !
;                                Dc.l 0;menu_previousfile
;                                Dc.b $8A,$00                  ; F10              !
;                                Dc.l 0;menu_nextfile
;                                Dc.b $8B,$00                  ; HELP             !
;                                Dc.l 0;event_helpkey
;                                Dc.b $FF,$01                  ; VERTICAL SCROLLER
;                                Dc.l 0;event_vertscroller
;                                Dc.b $FE,$00
;                                Dc.l 0;event_shortcut         ; SHORTCUT
;                                Dc.b $FD,$01
;                                Dc.l 0;event_leftmousebutton  ; L-MOUSEBUTTON
;                                Dc.b $FB,$01
;                                Dc.l 0;AJL_0_7FCC
;                                Ds.w 1
!ComData_LEA{comArray_KeyTable              ,A0}
MOVE.l #key_cursorup                        ,02(A0)
MOVE.l #key_cursordown                      ,08(A0)
MOVE.l #insertreturn                        ,14(A0)

;MOVE.l #menu_helpgeneral                    ,20(A0)  ; removed
;MOVE.l #menu_helpincludesguide              ,26(A0)  ; removed
;MOVE.l #menu_helpblitzlibs                  ,32(A0)  ; removed
;MOVE.l #menu_dublicate                      ,38(A0)  ; removed
;MOVE.l #menu_previousfile                   ,44(A0)  ; removed
;MOVE.l #menu_nextfile                       ,50(A0)  ; removed
;MOVE.l #event_helpkey                       ,56(A0)  ; removed

MOVE.l #event_vertscroller                  ,62(A0)
MOVE.l #event_shortcut                      ,68(A0)
MOVE.l #event_leftmousebutton               ,74(A0)
MOVE.l #AJL_0_7FCC                          ,80(A0)


; add for compile status window by tomsmart1 2012 02 25
; set the address for the gui routines in comData that the compiler can access it with "!comData_JSR{...}
; removed the set of comFunc_ open and clos of the compile status Window becaus it is now controled by the GUI  tomsmart1 2015 08 23
!ComData_SetL{comFunc_UpdateCompileStatusWin,#Update_CompileStatus_Window}    ; update the window ; the only nessecary


;--- TODO: Check if an instance of AmiBlitz3 ist already running ...
;*ped_task.Task = 0
;*ped_task = FindTask_(0)

ende.b     = False   ; abort indicater

;---  Check  if  all  needed  Librarys  are  available  with  the  needed  min  Version
errorout.s = ""      ; for the error text

If dos_CheckLib{"wizard.library",42} = False        ; needed for Compiler, PED and REDDebugger
  errorout + "Missing 'wizard.library':\\nVersion 42 of this library is required by the IDE.\\n\\n"
  ende = True
EndIf

If dos_CheckLib{"ted.library",1} = False           ; needed for PED and REDDebugger
  errorout + "Missing 'ted.library':\\nVersion 1 of this library by the IDE.\\n\\n"
  ende = True
End If

If dos_CheckLib{"disassembler.library",40} = False ; only needed for REDDebugger
  errorout + "Missing 'disassembler.library':\\nVersion 40 of this library is required by REDDebugger.\\nASM debugging won't work.\\n\\n"
End If

If errorout <> ""     ; check if somthing to show
   errorout = "Please reinstall AmiBlitz3 or copy the librarys to LIBS:\\n\\n" + errorout
   If ende
     errorout + "...that the PED can start!" ; for abort
   Else
     errorout + "...for a full working IDE!" ; for limited start
   End If
   error{!TRANS{errorout}}
End If

;--- End if needed library or Version is not available
If ende Then Goto abnormal_exit

*MyCatalog.l = OpenCatalogA_(0,"PED.catalog",0)
;Set Tags so Wizardlibrary Use catalog File
If *MyCatalog
   WZTags #SFH_Catalog,*MyCatalog,#TAG_DONE,0,#TAG_END,0
EndIf

;-- init Wizard GUI
WZLoadGUI ?wzgui
WZ_ShowMessage{!TRANS{"Initiating AmiBlitz3 Environment..."} }
ChangeWZWindowTitle{"WIN_PROGRESS","Amiblitz3 V" + !versions}  ; use Statement to remove double code tomsmart1 2012 03 09



;--- Check to identify on with OS we are running         ; added to disable the Mousewheel settings in the IDE prefs for OS4 because we use the System values with OS4  tomsmart1
SHARED OSVersion.l
OSVersion = #AmigaOS3
If ( dos_CheckLib{"exec.library",50} ) Then OSVersion = #AmigaOS4 ;: message{"REDDebugger: I think I run on OS4, because I was able to open exec.library v50+!"}
If ( FindResident_("MorphOS") )        Then OSVersion = #MorphOS  ;: message{"REDDebugger: I think I run on MOS, because I found the 'MorphOS' Resident!"}
;-----

; ------------------------------------------------------------------------------------
; AUSWERTEN DER TOOLTYPES
; ------------------------------------------------------------------------------------
.SET_DEFAULT_SETTINGS
;  MOVE.w #0,comWord_DoTokenize
;  MOVE.w #0,flag_tokenization
a$ = dos_GetProgIcon{dos_AddPart{default_assign$,"AmiBlitz3"} }   ;  replaces hardcode string "blitz3:" tomsmart 2012 03 12

.TOOLTYPES
  disk_object.l = dos_OpenToolTypes{a$}
  If disk_object
    ; ---- LOGGING --------------------------------------------------
    logging_level.b = dos_GetToolValue{"LOG_LEVEL",#log_nothing}
    log_SetLevel{logging_level}
    log_mode.b = dos_GetToolValue{"LOG_MODE",#log_tofile}
    log_SetDestination{log_mode,"System/PED.log"}
    !log_AvailMem{"at tooltype begin"}

    If dos_GetToolState{"no_welcome"}          = -1 Then no_welcome.b        = True  : Else no_welcome = 0
    If dos_GetToolState{"askbeforequit"}       = -1 Then ask_before_quit.b   = True  : Else ask_before_quit = 0
    If dos_GetToolState{"standardeditmode"}    = -1 Then Poke.b ?new_editmode       ,1 : Else Poke.b ?new_editmode       ,0
    If dos_GetToolState{"oldsearch"}           = -1 Then Poke.w ?oldsearch          ,1 : Else Poke.w ?oldsearch          ,0
    If dos_GetToolState{"nodisplaybeep"}       = -1 Then Poke.b ?nodisplaybeep      ,1 : Else Poke.b ?nodisplaybeep      ,0
    If dos_GetToolState{"auto_format"}         = -1 Then auto_format.b       = True  : Else auto_format = 0
    If dos_GetToolState{"auto_indent"}         = -1 Then Poke.w ?auto_indent        ,1 : Else Poke.w ?auto_indent        ,0  ; added because was not loaded befor tomsmart1
    If dos_GetToolState{"AUTO_CONSTRUCTS"}     = -1 Then auto_constructs.b   = True  : Else auto_constructs = 0
    If dos_GetToolState{"correct_functions"}   = -1 Then correct_functions.b = True  : Else correct_functions = 0
    If dos_GetToolState{"smart_tokenization"}  = -1 Then Poke.b ?smart_tokenization ,1 : Else Poke.b ?smart_tokenization ,0
    If dos_GetToolState{"tokenbold"}           = -1 Then bold_tokens.b       = True  : Else bold_tokens = 0
    If dos_GetToolState{"italic_remarks"}      = -1 Then italic_remarks.b    = True  : Else italic_remarks = 0
    If dos_GetToolState{"linenumbers"}         = -1 Then linenumbers.b       = True  : Else linenumbers = 0
    If dos_GetToolState{"onlinehelp"}          = -1 Then onlinehelp.b        = True  : Else onlinehelp = 0
    If dos_GetToolState{"onlinehelp_extended"} = -1 Then onlinehelp_extended.b = True : Else onlinehelp_extended = 0
    If dos_GetToolState{"USE_INTELLISENSE"}    = -1 Then use_intellisense.b  = True  : Else use_intellisense = 0
    If dos_GetToolState{"DISABLE_INCLUDEHELP"} = -1 Then HelpForIncludes.b   = True  : Else HelpForIncludes = 0
    If AvailMem_(#MEMF_FAST) < 4000000
      errormessage$ = "The available memory is low.\\n"
      errormessage$ + "Online-Help and intellisense for Include-functions will be disabled\\n"
      errormessage$ + "You should check following tooltypes:\\n"
      errormessage$ + "- DISABLE_INCLUDEHELP\\n"
      errormessage$ + "- INTELLISENSE"
      error{errormessage$}
      HelpForIncludes = False
    End If
    use_intellisense = HelpForIncludes
    If dos_GetToolState{"HELPFORPRIVATFUNCTIONS"}  = -1 Then HelpForPrivatFunctions.b = True : Else HelpForPrivatFunctions = 0
    If dos_GetToolState{"USE_COMMANDSINTELLISENSE"} = -1 Then Poke.b ?use_commandsintellisens,1 : Else Poke.b ?use_commandsintellisens,0 ; for command autocomplettion  switchable  tomsmart1

    If dos_GetToolState{"USE_ASLDIMS"}             = -1 Then use_asldims.b         = True  : Else use_asldims = 0
    If dos_GetToolState{"SOURCE_HISTORY"}          = -1 Then Poke.w ?remember_saved     ,1 : Else Poke.w ?remember_saved     ,0
    If dos_GetToolState{"LOAD_LAST_SOURCE"}        = -1 Then Poke.b ?load_last_source   ,1 : Else Poke.b ?load_last_source   ,0
    If dos_GetToolState{"SORT_LABELS"}             = -1 Then sort_labels.b         = True  : Else sort_labels = 0
    If dos_GetToolState{"CON_ONWB"}                = -1 Then console_wb.b          = True  : Else console_wb  = 0
    If dos_GetToolState{"CON_WAIT"}                = -1 Then console_wait.b        = True  : Else console_wait = 0

    If dos_GetToolState{"CLONE_WBSCREEN"}   = True
      clone_wbscreen.b = True : use_wbscreen.b = False
    Else
      If dos_GetToolState{"USE_WBSCREEN"}   = True
        use_wbscreen = True : clone_wbscreen = False
      EndIf
    EndIf
    If dos_GetToolState{"PUBSCREEN"}          = -1 Then use_pubscreen.b         = True : Else use_pubscreen = 0
    If dos_GetToolState{"DEFAULTPUBSCREEN"}   = -1 Then use_default_pubscreen.b = True : Else use_default_pubscreen = 0
    If dos_GetToolState{"USE_WBFONT"}         = -1 Then use_wbfont.b            = True : Else use_wbfont = 0
  Else
    bold_tokens           = True
    MOVE.b #1,new_editmode
    onlinehelp            = True
    onlinehelp_extended   = False
    use_wbscreen          = True
    clone_wbscreen        = False
    use_pubscreen         = False
    use_default_pubscreen = False
    use_wbfont            = True
  End If

  autolayout.l     = dos_GetToolValue{"autolayout"      ,-1}
  al_leftspace.l   = dos_GetToolValue{"autolayout_left"  ,0}
  al_topspace.l    = dos_GetToolValue{"autolayout_top"   ,0}
  al_rightspace.l  = dos_GetToolValue{"autolayout_right" ,0}
  al_bottomspace.l = dos_GetToolValue{"autolayout_bottom",0}

  console_device$ = dos_GetToolString{"CON_DEVICE","CON:"}
  console_font$   = dos_GetToolString{"CON_FONT",""}
  console_title$  = !TRANS{"AmiBlitz3 Console Output"}

  cursorStyle.w = cursorStyleGetValue{dos_GetToolString{"cursorstyle","block"}}
  scroll_rate.l = dos_GetToolValue{"scrollrate",0}
  If scroll_rate<>0
    If vvblank_SetFreq{scroll_rate} = False Then no_scrollrate.b = True
  Else
    no_scrollrate = True
  EndIf

  blinkrate.b = dos_GetToolValue{"cursorblinkrate",5}
  Poke.l ?wheelstep, dos_GetToolValue{"MOUSEWHEELSTEP",6}     ; added to make Mousewheelsteprate changeable  tomsmart1


  ; --- ASL-Requestersettings ------------------------------
  Poke.l ?aslreq_x      ,dos_GetToolValue{"ASLREQ_X" ,20}
  Poke.l ?aslreq_y      ,dos_GetToolValue{"ASLREQ_Y" ,20}
  Poke.l ?aslreq_width  ,dos_GetToolValue{"ASLREQ_W",320}
  Poke.l ?aslreq_height ,dos_GetToolValue{"ASLREQ_H",200}
  Poke.s ?comStr_FilePattern,dos_GetToolString{"ASLREQ_Pattern","#?.(bb2|ab2|ab3|asc|txt)"}

  If use_asldims <> 0
    asl_SetRequesterDims{Peek.l(?aslreq_x),Peek.l(?aslreq_y),Peek.l(?aslreq_width),Peek.l(?aslreq_height)}
  Else
    asl_SetRequesterDims{-1,-1,-1,-1}
  EndIf

  ; --- COLORS ---------------------------------------------
  AB3RGB(#AB3_ctoken)            = dos_GetToolValue{"tokencolor"      ,$646bd7} ;: Poke.b ?tokencolor,AB3RGB(#AB3_ctoken
  AB3RGB(#AB3_cfunction)         = dos_GetToolValue{"functioncolor"   ,$396635} ;: Poke.l ?functioncolor,AB3RGB(#AB3_cfunction
  AB3RGB(#AB3_cconstant)         = dos_GetToolValue{"constantcolor"   ,$8C338A} ;: Poke.l ?constantcolor,AB3RGB(#AB3_cconstant
  AB3RGB(#AB3_cnewtype)          = dos_GetToolValue{"newtypecolor"    ,$153492} ;: Poke.l ?newtypecolor,AB3RGB(#AB3_cnewtype
  AB3RGB(#AB3_cstring)           = dos_GetToolValue{"stringcolor"     ,$7D8A83} ;: Poke.w ?stringcolor,AB3RGB(#AB3_cstring
  AB3RGB(#AB3_cmacro)            = dos_GetToolValue{"macrocolor"      ,$CB3817} ;: Poke.l ?macrocolor,AB3RGB(#AB3_cmacro
  AB3RGB(#AB3_cother)            = dos_GetToolValue{"othercolor"      ,$000000} ;: Poke.w ?othercolor,AB3RGB(#AB3_cother
  AB3RGB(#AB3_cremarkforeground) = dos_GetToolValue{"remarkforg"      ,$6a9a66} ;: Poke.b ?remarkcolor,AB3RGB(#AB3_cremarkforg
  AB3RGB(#AB3_cremarkbackground) = dos_GetToolValue{"remarkbackg"     ,$f9f9f9} ;: Poke.b ?remarkbgcolor,AB3RGB(#AB3_cremarkbackg
  AB3RGB(#AB3_ctokenbackground)  = dos_GetToolValue{"tokenbackpen"    ,$ffffff} ;: Poke.b ?tokenbackground,AB3RGB(#AB3_ctokenbackground
  AB3RGB(#AB3_cbackground)       = dos_GetToolValue{"backgroundcolor" ,$ffffff} ;: Poke.l ?backgroundcolor,AB3RGB(#AB3_cbackgroundcolor
  AB3RGB(#AB3_cclassic)          = dos_GetToolValue{"classiccolor"    ,$ff0500} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screenback)        = dos_GetToolValue{"screenbackcolor" ,$c8c8c8} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screentext)        = dos_GetToolValue{"screentextcolor" ,$000000} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screenshine)       = dos_GetToolValue{"screenshinecolor",$FFFFFF} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screenfill)        = dos_GetToolValue{"screenfillcolor" ,$6e94e2} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic

  ; --- SCREEN ---------------------------------------------
  myscreen_modeid.l  = dos_GetToolValue{"SCREEN_ID"     ,0} ;: Poke.l ?ownscreen_modeid ,myscreen_modeid
  myscreen_Width.l   = dos_GetToolValue{"SCREEN_WIDTH"  ,0} ;: Poke.w ?ownscreen_width  ,myscreen_Width
  myscreen_Height.l  = dos_GetToolValue{"SCREEN_HEIGHT" ,0} ;: Poke.w ?ownscreen_height ,myscreen_Height
  myscreen_Depth.l   = dos_GetToolValue{"SCREEN_DEPTH"  ,0} ;: Poke.w ?ownscreen_depth  ,myscreen_Depth

  ; check if any Screentooltype set
  If (clone_wbscreen=0) AND (use_wbscreen = 0) AND myscreen_modeid.l=0
     use_wbscreen = True  ; we use WBScreen if no Screen Tooltype is set
  EndIf

  MaxLen str2$   = 4096   ; this is important since Honitos used some string pointers, that might be empty
  MaxLen cstr$   = 4096   ; pointers to empty string might be NULL, that's why!
  MaxLen cstr2$  = 4096   ; pointers to empty string might be NULL, that's why!
  MaxLen str2b$  = 4096
  str2$          = ""
  cstr$          = ""
  cstr2$         = ""
  str2b$         = ""
  changelog$     = ""
  oldfindstr$    = ""
  oldreplacestr$ = ""

  ; --- FONTS ----------------------------------------------
  If use_wbfont = False
    ;no Tooltype use_wbfont so check for GUI and Source font tooltypes
    str_guifont$    = dos_GetToolString{"guifont",""}       ; no predefine Font use WB fonts instead
    str_sourcefont$ = dos_GetToolString{"sourcefont",""}

    If str_guifont$<>"" OR str_sourcefont$<>""
      ; check and set GUIfont
      If str_guifont$<>""
        InitArgParse str_guifont$
        guifont$ = NextArgChar$(@",")
        a$ = NextArg$
        guifontsize.w = Vallong(a$)
      EndIf
      ; check and set Sourcefont
      If str_sourcefont$<>""
        InitArgParse str_sourcefont$
        sourcefont_name$ = NextArgChar$(@",")
        a$ = NextArg$
        sourcefont_size.w = Vallong(a$)
        Poke.s ?str_sourcefontname ,sourcefont$ + StrClone(Chr$(0),79 - Len(sourcefont$))
        Poke.w ?sourcefontsize     ,sourcefont_size
        Poke.b ?sourcefontstyle    ,sourcefont_style.b
      EndIf
    Else
      ; no guifont and sourcefont set so use WBfonts
      use_wbfont.b = True
    EndIf
  EndIf

  ; --- DIRECTORIES ---------------------------------------
  my_maindir$      = dos_GetToolString{"ASSIGN",default_assign$}
  If my_maindir$ = "" Then my_maindir$ = default_assign$ ; in case someone sets assign to ""
  my_systemdir$    = dos_AddPart{my_maindir$,"System"}
  my_blitzlibsdir$ = dos_AddPart{my_maindir$,"Blitzlibs"}
  last_source$     = dos_GetToolString{"last_source",""}

  includedir$      = dos_GetToolString{"INCLUDEDIR" ,dos_AddPart{my_maindir$,"Sourcecodes/Includes"}} : Poke.l ?ptr_incdirname,&includedir$
  helpdir$         = dos_GetToolString{"HELPDIR"    ,dos_AddPart{my_maindir$,"Docs"}}
  autodocdir$      = dos_GetToolString{"AUTODOCDIR" ,dos_AddPart{my_maindir$,"Docs"}}
  sourcedir$       = dos_GetToolString{"SOURCEDIR"  ,dos_AddPart{my_maindir$,"Sourcecodes"}} : Poke.l ?ptr_source_dir,&sourcedir$
  addonprefs$      = dos_GetToolString{"WINDOWPREFS",dos_AddPart{my_maindir$,"System/ped_addon.prefs"}}

  pedhistoryfile$ = dos_AddPart{my_systemdir$,"PED.history"}
  pedmenufile$ = dos_AddPart{my_systemdir$,"PED.menus"}

  CLR.l ptr_deflibsfilename
  deflibfile$      = dos_GetToolString{"LIBFILE",dos_AddPart{my_blitzlibsdir$,"DefLibs"}} : Poke.l ?ptr_deflibsfilename,&deflibfile$
  If dos_Exist{deflibfile$}
    deflibdate$ = dos_GetFileDate{deflibfile$}
  Else
    dummy.l = ask{!TRANS{"Libsfile [" + deflibsfile$ + "] not found, trying [DefLibs]"},!TRANS{"Ok"},!TRANS{"Info!"}}
    deflibdate$ = dos_GetFileDate{dos_AddPart{my_blitzlibsdir$,"DefLibs"}}
  End If
  deflibdate$  = StrChg(deflibdate$,"/",".")
  acidlibdate$ = StrChg(dos_GetFileDate{dos_AddPart{my_blitzlibsdir$,"AcidLibs"}},"/",".")

  !log_AvailMem{"after tooltypes"}


; ------------------------------------------------------
; EINBINDEN DER KONFIGURATIONSDATEIEN
; ------------------------------------------------------
.CONFIGFILES

WZ_ShowMessage{!TRANS{"Preparing preprocessor/tokenizer ..."}}
HelpIndexFile$             = dos_AddPart{my_systemdir$,"HelpIndex.txt"}
HelpIndexCacheFile$        = dos_AddPart{my_systemdir$,"HelpIndexCache.bin"}
TokenHashMapFile.s         = dos_AddPart{my_systemdir$,"TokenList.hashmap"}
*PreProcessor.preprocessor = preproc_Create{}
Poke.l ?comPtr_PreProcessor,*PreProcessor
preproc_LoadTokens{*PreProcessor,TokenHashMapFile}
*rc_fib.FileInfoBlock = AllocDosObject_ (#DOS_FIB,0)

!log_AvailMem{"after preparing preprocessor/tokenizer"}


If HelpForIncludes
  WZ_ShowMessage{!TRANS{"Loading helpindex for include-functions ..."}}
  If dos_Exist{HelpIndexCacheFile$}
    PED_ReadHelpIndexCache{HelpIndexCacheFile$}
  Else
    BuildHelpIndexWinTitle$ = "Building"                         ;added so the window title match the function  tomsmart1 ; remove !TRANS{} because it will translated with befor it will displayed  tomsmart1
    Gosub build_HelpIndexFile
  End If
  !log_AvailMem{"after loading includehelpindex"}
Else
  !log_AvailMem{"index for includefiles skipped."}
End If



If ReadFile (0,addonprefs$)
  WZ_ShowMessage{!TRANS{"Loading window layouts ..."}}
  ReadType 0,wpref(0)
  ReadType 0,wpref(1)
  ReadType 0,wpref(2)
  CloseFile 0
End If

!log_AvailMem{"after loading configfiles"}

; settings for type browser
newtype_mode.l = 0

; ---------------------------------------- MAINPROGRAM ----------------------------------------------
WZ_ShowMessage{!TRANS{"Starting IDE ..."} }
.MAINPROGRAM
!asm
begin1:
  MOVE.l A1,comLong_AB3IsAvailable   ; A1 is teddata of compiler

  ; --
  ; -- initiation of compiler data-interface
  MOVEA.l #comPtr_TokenBase,A0       ;teddata for compiler
  MOVEQ.l #$11,D0
  JL_0_1E:
    MOVE.w (A1)+,(A0)+
  DBF D0,JL_0_1E

  MOVE.l -8(a1),newted
  MOVE.l (a1),constantbase
  MOVE.l ptr_deflibsfilename,4(a1)
  MOVE.l ptr_incdirname,8(a1)

  MOVE.l -4(a1),d0
  BEQ 'l10
    MOVE.l d0,a0
    MOVEQ #6,d1
   'l11
      MOVE.l (a0),a0
    DBF d1,'l11
    MOVE.l a0,newtypebase
 'l10:

  ; --
  ; -- initiation of some editor datas
.begin
  MOVEQ #127,d0                      ; clear char-table
  LEA chartab,a0
 'l12
    MOVE.b #1,128(a0)
    CLR.b (a0)+
  DBF d0,'l12

  LEA chartab,a0                     ; init char-table
  MOVE.b #1,(a0)
  MOVE.b #1,","(a0)
  MOVE.b #1,";"(a0)
  MOVE.b #1,":"(a0)
  MOVE.b #1,"("(a0)
  MOVE.b #1,")"(a0)
  MOVE.b #1,"="(a0)
  MOVE.b #1,"+"(a0)
  MOVE.b #1,"-"(a0)
  MOVE.b #1,"*"(a0)
  MOVE.b #1,"/"(a0)
  MOVE.b #1,"$"(a0)
  MOVE.b #1,"%"(a0)
  MOVE.b #1,"."(a0)
  MOVE.b #1,"["(a0)
  MOVE.b #1,"]"(a0)
  MOVE.b #1,"{"(a0)
  MOVE.b #1,"}"(a0)
  MOVE.b #1,"\"(a0)
  MOVE.b #1,">"(a0)
  MOVE.b #1,"<"(a0)
  MOVE.b #1,"&"(a0)
  MOVE.b #1,"|"(a0)
  MOVE.b #1,"^"(a0)
  MOVE.w #0101,1(a0)
  MOVE.b #1,$20(a0)

  !basic
  Poke.l ?comPtr_MemPool, CreatePool_(#MEMF_CLEAR,40000,40000)
  If Peek.l(?comPtr_MemPool) = 0
     log_Print{"Could not allocate enough memory. PED closes down now.",#log_error}
     Goto exit_PED_nomem
  EndIf

  Poke.l ?_dosbase, OpenLibrary_("dos.library",0)
  If Peek.l(?_dosbase) = 0 Then !asm : BRA.w exit_PED_nodoslib

  ;Poke.l ?_graphicsbase, OpenLibrary_("graphics.library",0)
  ;If Peek.l(?_graphicsbase) = 0 Then !asm : BRA.w exit_PED_closelibraries

  If ted_OpenLib{0}
    TEDSetJumpTable  {?COMDATABASE}
    TEDSetFirstLine  {?comPtr_FirstSourceLine}
    TEDSetCurrentLine{?comPtr_CurrentSourceLine}
  Else
    error {!TRANS{"Unable to open ted.library !\\nThe IDE will crash."}}
  EndIf

  !log_AvailMem{"after loading libraries"}

  ; create a msgport for Iconification
  *WBMsgPort.MsgPort = CreateMsgPort_
  Gosub init_arexxport_bas
  !asm
  ;JSR init_arexxport

  MOVEA.w #$2000,A0
  ADDA.w comWord_MaxColumns,A0
  ADDA.w comWord_MaxColumns,A0
  ADDA.w comWord_MaxColumns,A0
  ADDQ.w #6,A0
  MOVE.l A0,D0
  !newalloc
  MOVE.l D0,comPtr_DosBuffer
  BEQ.w exit_PED_closelibraries

  MOVEA.l D0,A0
  LEA $2000(A0),A0
  MOVE.l A0,comPtr_Temp_TokenString1 : ADDA.w comWord_MaxColumns,A0 : ADDQ.w #2,A0
  MOVE.l A0,comPtr_Temp_TokenString2 : ADDA.w comWord_MaxColumns,A0 : ADDQ.w #2,A0
  MOVE.l A0,comPtr_Temp_TokenString3 : ADDA.w comWord_MaxColumns,A0 : ADDQ.w #2,A0
  MOVE.l A0,comPtr_Temp_TokenStringObsolete

  MOVE.l #$2F60 + 1000,D0
  !newalloc
  MOVE.l D0,AL_0_5B9A
  BEQ.w exit_PED_closelibraries

  MOVEA.l D0,A0 : MOVE.l A0,AL_0_5B9E
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,AL_0_5BA2
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,AL_0_5BA6
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,textbufferPrint
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,expandstore
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,lineundeletestore
  ADD.l #MAX_Columns+4,a0

  !regs2stack
  !basic
  !log_AvailMem{"after reserve of buffers for source code"}
  !asm
  !stack2regs

  JSR set_oldpreferences
  CLR.w comWord_PrefsWrittenState

  !regs2stack
  !basic
  !log_AvailMem{"after loading old config, jumping back to compiler to load blitzlibs"}
  !asm
  !stack2regs

  ; --
  ; -- return to compiler after initiation
  MOVE.l comLong_AB3IsAvailable,D0
  BEQ.w start_up_without_compiler
    LEA compiler_jumps_here,A0
    MOVEA.l comdata,A1               ; its now indirect, was moveA.l #comdata before
    MOVE.w ##ComDataVersionID,comWord_PEDIsAvailable   ; new to indicate update PED V3.6  tomsmart1  changed to a constant  tomsmart1
    RTS                              ; <-- return to compiler
  start_up_without_compiler:
    LEA str_tempfilename,A0

  compiler_jumps_here:               ; compiler offers str_tempfilename in A0 here
  MOVE.l A0,-(A7)
  !basic
  MOVE.l (a7)+,d0
  tempD0.l = PutD0
  If tempD0
    compiler_source$ = Peek$(tempD0)
  Else
    error{"NULL Pointer in compiler_source$!"}
  End If
  !log_AvailMem{"after Compiler has given control back"}

  ; --
  ; -- fill mapping array with libnames from mapping-file
  ; -- and check consistency based on the mapping files and the internal libnums
  WZ_ShowMessage{!TRANS{"Building tokenindex..."}}
  *tokenbase.tokeninfo = Peek.l(?comPtr_TokenBase)
  map_tokens_to_libs{dos_AddPart{my_systemdir$,"token_mapping_libs.txt"}}
  map_tokens_to_libs{dos_AddPart{my_systemdir$,"token_mapping_userlibs.txt"}}
  ;read_libmapping{dos_AddPart{my_systemdir$,"token_mapping_libs.txt"}}
  ;read_libmapping{dos_AddPart{my_systemdir$,"token_mapping_userlibs.txt"}}



  !log_AvailMem{"after doing token index"}

  If *PreProcessor\tokens = Null     ; we have no hashmap loaded, create it!
    WZ_ShowMessage{!TRANS{"Creating Hashmaps..."}}
    preproc_QueryTokens{*PreProcessor}
    preproc_SaveTokens{*PreProcessor,TokenHashMapFile}
  End If

  !log_AvailMem{"after preproc hashmap"}

  WZ_HideMessage{}
  !asm

.START_GUI
  JSR open_gui
  BMI.w exit_PED_closeall

  JSR cursor_off
  JSR menu_opennew
  JSR cursor_on
  JSR draw_statusarea

  !basic
  Gosub set_CurrentDir
  *flock_defaultDir.l = *flock_currentDir.l
  log_Print{"check lastsource option"}
  If Peek.b(?load_last_source)<>0 OR compiler_source$<>""
    If compiler_source$<>"" Then last_source$ = compiler_source$
    If last_source$<>""
      currentdir$ = dos_PathPart{last_source$}
      If Right$(currentdir$,1)<>":" Then currentdir$ + "/" ; dirty hack, but better than editing ASM
      Poke$ ?comStr_SourceName,dos_FilePart{last_source$}
      Poke$ ?comStr_CurrentDir,currentdir$
    EndIf
  EndIf
  !asm
  ; --
  ; -- jump to mainloop if no sourcename given, else
  ; -- load last Source
.AUTOLOAD_SOURCE
  MOVE.b comStr_SourceName,D0
  BEQ.w skip_autoload
    LEA comStr_CurrentDir,A0
    MOVEA.l comPtr_Temp_TokenString1,A1
    MOVE.l A1,D7
    JL_0_40E:
      MOVE.b (A0)+,(A1)+
    BNE.b JL_0_40E
    SUBQ.w #1,A1
    LEA comStr_SourceName,A0
    JL_0_41A:
      MOVE.b (A0)+,(A1)+
    BNE.b JL_0_41A

    JSR cursor_off

    JSR load_source
    JSR update_vertscroller
    JSR draw_statusarea
    JSR update_labelstuff
    JSR cursor_onoff_force
  skip_autoload:

  ; --
  ; -- show welcome requester if option selected
  .WELCOME_REQUESTER
  !basic
  log_Print{"check welcome requester"}
  If no_welcome = 0
    !asm
    JSR menu_about
    !basic
  EndIf
  !asm

  ; -- jump to main loop
  JSR main_loop

; ---------------------------------------------------------------------------------------------------
Exit_main:                                           ; insert to remove the evil stackmagic by/for
                                                     ; quit and have a clean way to exit the endless
                                                     ; main_loop without modifing it  tomsmart1
; --
; -- shutdown PED after return of the mainloop
  !basic
  log_Print{"closing GUI..."}
  !asm
  JSR close_gui

exit_PED_closeall:
  CLR.w comWord_PEDIsAvailable        ; moved to clear to clear it if a error happend too  tomsmart1
  !basic
  log_Print{"closing fonts..."}
  Gosub close_sourcefonts
  !asm

  exit_PED_closelibraries:
  !basic
  log_Print{"closing arexxport.."}
  Gosub close_arexxport_bas
  ;!asm
  ;JSR close_arexxport
  ;!basic

  log_Print{"closing catalog an libs..."}
  If *MyCatalog             Then CloseCatalog_ *MyCatalog
  ;If Peek.l(?_graphicsbase) Then CloseLibrary_ Peek.l(?_graphicsbase)  : CLR.l _graphicsbase

  ted_CloseLib{}

  !asm
  JSR free_historyfilelist
  !basic

  If *WBMsgPort Then DeleteMsgPort_ *WBMsgPort

  log_Print{"unlocking directory..."}
  CurrentDir_(*flock_defaultDir)
  If *flock_currentDir Then UnLock_ *flock_currentDir

  If Peek.l(?_dosbase) Then CloseLibrary_ Peek.l(?_dosbase) : CLR.l _dosbase

  exit_PED_nodoslib:
  log_Print{"freeing memory..."}
  preproc_Free{*PreProcessor} : *PreProcessor = Null
  If *rc_fib Then FreeDosObject_ #DOS_FIB,*rc_fib  : *rc_fib = Null
  rc_cacheptr.l = Peek.l(?readcache_cacheptr)
  If rc_cacheptr
    FreeVec_ rc_cacheptr
    Poke.l ?readcache_cacheptr,Null
    Poke.l ?readcache_cachelen,0
    Poke.l ?readcache_readlen ,0
  End If

  exit_PED_nomem:
  DeletePool_ Peek.l(?comPtr_MemPool)

  !asm
  !exitasm             ; exitasm jumps into basic mode
  Gosub coutclose      ; move to the real end  tomsmart1
End

; ----------------------------------- END OF MAINPROGRAM ------------------------------------------


.abnormal_exit:
  !asm
  CLR.w comWord_PEDIsAvailable
  MOVEA.l comdata,A1            ; its now indirect, was #comdata before
  !exitasm                      ; exitasm jumps into basic mode
End



; ---------------------------------- THIS IS THE MAINLOOP -----------------------------------------
.main_loop:
  CLR.w comWord_LabelListChanged
  ;CLR.w comWord__AL_0_86C0

  JSR PED_events

  MOVEA.l comPtr_CurrentSourceLine,A4

  ; --- check if an exe is running ---
  TST.b comByte_RunningFlag
  BEQ 'l1
    TST.w comWord_KeyBeforeReturn
    BEQ 'l1
      JSR _redraw
      CLR.w comWord_KeyBeforeReturn
 'l1

  MOVE.w comWord_KeyBeforeReturn,D0
  BEQ.w JL_0_CC6
    !basic
    ; --- get address of actual source line ---
    MOVE.l comLong_DisplayLine,D1 : ADD.l comLong_DisplayLineOffset,D1
    MOVE.l d1,lastedited_line
    MOVE.w comWord_KeyBeforeReturn,D0 : MOVE.w D0,comWord_SourceChanged

    MOVEQ #0,D0
    MOVEA.l textbufferaddr,A2 : ADDA.w comWord_TextBufferOffset,A2
    MOVE.l a2,d0 : lineaddr.l = PutD0

    ; --- store cursor column position ---
    MOVEQ #0,D0
    MOVE.w comWord_Column,D0 : ADD.w comWord_ColumnsOffset,D0
    columnpos.w = PutD0

    ; --- format source line and get new column position ---
    newcolumnpos.w = preparseline{columnpos, lineaddr, auto_format, correct_functions}
    GetD0 newcolumnpos
    SUB.w comWord_ColumnsOffset,D0 : MOVE.w D0,comWord_Column
    old_search_label$ = "|"
    !asm

    ; -- parse the current line
    JSR parse_line

    ; --- draw block mark if existing
    SF comByte_StateBlockMark
    TST.l comLong_BlockEndY
    BMI.w exit_updateblock
      MOVEM.l D0-D3/A0-A2,-(A7)
      MOVE.l comLong_DisplayLine,D1
      ADD.l comLong_DisplayLineOffset,D1
      CMP.l comLong_BlockStartY,D1
      BLT.w JL_0_C66
      CMP.l comLong_BlockEndY,D1
      BGT.w JL_0_C66
        MOVE.w comLong_BlockStartX,D0
        MOVE.l comLong_BlockStartY,D1
        MOVE.w comLong_BlockEndX,D2
        MOVE.l comLong_BlockEndY,D3
        CMP.l D1,D3
        BNE.w JL_0_C50
          CMP.w D0,D2
          BNE.w JL_0_C50
            MOVE.w visiblecolumns,D2
        JL_0_C50:
        SUB.l comLong_DisplayLineOffset,D3
        SUB.l comLong_DisplayLineOffset,D1
        JSR JL_0_59BC
        ST comByte_StateBlockMark
      JL_0_C66:
      MOVEM.l (A7)+,D0-D3/A0-A2
    exit_updateblock:

    JSR JL_0_55AA

    MOVE.w comWord_DoTokenize,D0
    BEQ.w JL_0_CC6
      JSR print_current_sourceline

      TST.b comByte_StateBlockMark
      BEQ.w JL_0_CC6
        MOVEM.l D0-D3/D7/A0-A2,-(A7)
        MOVE.w comLong_BlockStartX,D0
        MOVE.l comLong_BlockStartY,D1
        MOVE.w comLong_BlockEndX,D2
        MOVE.l comLong_BlockEndY,D3
        CMP.l D1,D3
        BNE.w JL_0_CB2
          CMP.w D0,D2
          BNE.w JL_0_CB2
            MOVE.w visiblecolumns,D2
        JL_0_CB2:
        SUB.l comLong_DisplayLineOffset,D3
        SUB.l comLong_DisplayLineOffset,D1
        JSR JL_0_59BC
        MOVEM.l (A7)+,D0-D3/D7/A0-A2
  JL_0_CC6:


  ; -- auf bestimmte Events in D7 pruefen
  LEA comArray_KeyTable,A0

  JL_0_CCC:
    MOVE.b (A0)+,D0
    BEQ.w main_loop                 ; end of table, jump to main_loop

    CMP.b D0,D7                     ; messagecode match in array
    BEQ.w JL_0_CDC

    ADDQ.w #5,A0                    ; next entry
  BRA.b JL_0_CCC

  JL_0_CDC:
  MOVE.b (A0)+,-(A7)                 ; flag to update vertscroller to stack
  MOVEA.l (A0)+,A0                   ; function pointer to A0

  ; --
  ; -- check if an executable is running and prevent IDE from doing things
  TST.b comByte_RunningFlag
  BEQ no_running_exe
    CMP.w #$1c,d7                         ; crsr up             ;runtask allows
    BEQ no_running_exe
      CMP.w #$1d,d7                       ; crsr down
      BEQ no_running_exe
        CMP.l ##MENU_SAVEAS,d6            ; save as
        BEQ no_running_exe
          CMP.l ##MENU_CUSTOMEDIT,d6      ; custom menu
          BGE no_running_exe
            CMP.w #$fffd,d7               ; mouseclick
              BEQ no_running_exe
                CMP.w #$8b,d7             ; help key
                BEQ no_running_exe
                  BRA check_panic
                  check_panic_exit:
  no_running_exe:
  CLR.b redraw_ped
  CMP.w #$fffd,d7                    ; mouseclick ?
  BNE 'n1a
    MOVE.b #1,redraw_ped
 'n1a
  ; call function selected in comArray_KeyTable
  JSR (a0)

  ; -- check for some tokens and automatically add the closing token
  ; --
  !regs2stack
  !basic
  If auto_constructs
    If last_vankey.l = #VANILLAKEY_RETURN
      a$ = check_constructs{?comPtr_CurrentSourceLine}
      If a$<>""
        !basic
        Gosub insertstring
        !asm
        Gosub insertreturn
        JSR movecursorlineup
        JSR insertreturn
        JSR movecursorlineup
        !basic
      EndIf
    EndIf
  EndIf
  !stack2regs
  !asm

  ; redraw ped if redraw_ped is set or mouseclick-event
  TST.b redraw_ped
  BNE 'n2a
    CMP.w #$fffd,d7                  ;mouseclick
    BNE 'l1_a
 'n2a
    MOVE.l a0,-(a7)
    JSR _redraw
    MOVE.l (a7)+,a0
 'l1_a

  ; update diag_redraw on event $fffc
  CMP.w #$fffc,d7
  BNE 'n1
    !basic
    Gosub diag_redraw
    !asm
 'n1

  JL_0_CE2:                                              ;?? looks like double label ??
  MOVE.w comWord_LabelListChanged,D0
  BEQ.w JL_0_CFA
    JSR update_labelstuff
  JL_0_CFA:

  MOVE.b (A7)+,D0                                         ; get flag from stack (from keytable)
  TST.b D0
  BEQ.w main_loop
    JSR update_vertscroller
BRA.w main_loop
; ----------------------------------------- END OF MAINLOOP -------------------------------------



.check_panic:
  !regs2stack
  !basic
  *exeTask.Task = FindTask_("Blitz ][ Program Proc")
  If *exeTask <> 0
    dummy.l = ask{!TRANS{"This action is not allowed while executing a program\\nShould PED do a PANIC program kill?"},!TRANS{"Ok|Cancel"},!TRANS{"Error"}}
    If dummy <> 0
      log_Print{"found running exe task [" + Hex$(*exeTask) + "], removing all windows, screen and kill task..."}
      ;-- stop multitasking
      Forbid_

      ;-- close all windows and the screen of the task
      *intuibase.IntuitionBase = intuitionbase
      log_Print{"Intuitionbase: " + Hex$(*intuibase) + ", version " + Str$(*intuibase\LibNode\lib_Version)}
      *exeScreen.Screen = 0
      *tmpScreen.Screen = *intuibase\FirstScreen
      While *tmpScreen
        log_Print{"... checking Screen: " + Hex$(*tmpScreen) + " >> " + Peek$(*tmpScreen\Title)}
        *tmpWindow.Window = *tmpScreen\FirstWindow
        While *tmpWindow
          *nextWindow.Window = *tmpWindow\NextWindow
          log_Print{"... checking Window " + Hex$(*tmpWindow) + " >> " + Peek$(*tmpWindow\Title) + " Sigtask: " +  Hex$(*tmpWindow\UserPort\mp_SigTask)}
          If *tmpWindow\UserPort\mp_SigTask = *exeTask
            log_Print{"... window belongs to task, closing it!"}
            *exeScreen = *tmpScreen
            *tmpWindow\UserPort = 0
            CloseWindow_ *tmpWindow
          EndIf
          *tmpWindow = *nextWindow
        Wend
        *tmpScreen = *tmpScreen\NextScreen
      Wend
      If *exeScreen <> 0
        log_Print{"... screen belongs to task window, closing it ..."}
        CloseScreen_ *exeScreen
      EndIf

      ;-- kill the exe task
      log_Print{"... removing task"}
      RemTask_ *exeTask

      ;-- emable multitasking
      log_Print{"... enabling multitasking"}
      Permit_

      Poke.b ?comByte_RunningFlag,0
    Else
      !stack2regs
      !asm
      BRA JL_0_CE2
    EndIf
  Else
    log_Print{"runningflag is set, but no running task found!"}
  EndIf
  !stack2regs
  !asm
BRA check_panic_exit


; -----------------------------------------------------------------------------------------------
;_graphicsbase:           Dc.l 0
_dosbase:                Dc.l 0
;_workbenchbase:          Dc.l 0
;str_libname_workb:       Dc.b "workbench.library",0 : Even
;ptr_AppMenuItem:         Ds.l 1

ptr_sourcefont:          Dc.l 0
ptr_sourcefonti:         Dc.l 0
ptr_sourcefontb:         Dc.l 0
str_tempfilename:        Ds.b #MAX_STRINGSIZE

str_pedname:             Dc.b "PED ",!versions,0: Even
                         Ds.b #MAX_STRINGSIZE
Even
str_version:             Dc.b "$VER: PED ",!versions,0
Even


.menu_settings:
 !basic
 Gosub set_pointer_busy_bas
 LockAllOpenWZWin{}
 WZWindow WZID("WIN_SETTINGS"),?wzgui,255,-2,-2,-2,-2,WZID("WIN_SETTINGS")
 Use Window WZID("WIN_SETTINGS")
 ; make tab 0 active
 WZPrint "SET_PAGES",0

 ; init tempcolors
 For i = 0 To (#MAX_AB3Pens-1) ; relaced wrong 24 by #Max_AB3Pens -1, -1 because 0 to 23  tomsmart1
  AB3RGB_temp(i) = AB3RGB(i)
 Next i

 ; init gadgets
 If auto_format           Then WZPrint "SET_AUTO_FORMAT"        ,On
 If auto_constructs       Then WZPrint "SET_COMPLETE_CONSTRUCTS",On
 If use_intellisense      Then WZPrint "SET_INTELLISENSE"       ,On
 If correct_functions     Then WZPrint "SET_CORRECT_FUNCTIONS"  ,On
 If Peek.b(?smart_tokenization)    Then WZPrint "SET_SMART_TOKENIZATION" ,On
 If Peek.b(?new_editmode)          Then WZPrint "SET_STANDARD_EDITMODE"  ,On
 If no_welcome            Then WZPrint "SET_WELCOME"            ,On
 If ask_before_quit       Then WZPrint "SET_ASKBEFOREQUIT"      ,On

 If onlinehelp            Then WZPrint "SET_ONLINEHELP"         ,On
 If bold_tokens           Then WZPrint "SET_BOLDTOKENS"         ,On
 If italic_remarks        Then WZPrint "SET_ITALICREMARKS"      ,On
 If linenumbers           Then WZPrint "SET_LINENUMBERS"        ,On
 oldlinenumbers.b = linenumbers
 If Peek.w(?remember_saved)        Then WZPrint "SET_REMEMBER_SAVED"     ,On
 If Peek.b(?load_last_source)      Then WZPrint "SET_LAST_SOURCE"        ,On

 If use_pubscreen.b         Then WZPrint "SET_PUBSCREEN"          ,On
 If use_default_pubscreen Then WZPrint "SET_DEFAULTPUBSCREEN"   ,On
 If use_filepattern.b       Then WZPrint "SET_FILEPATTERN"        ,On
 If Peek.w(?auto_indent)           Then WZPrint "SET_AUTO_INDENT"        ,On
 If Peek.l(?nodisplaybeep)         Then WZPrint "SET_NO_DISPLAYBEEP"     ,On
 If Peek.w(?oldsearch)= 1          Then WZPrint "SET_OLDSEARCH"          ,On

 If console_device$ <> ""          Then WZPrint "SET_CONSOLE_DEVICE"     ,&console_device$
 If console_wb      =  True        Then WZPrint "SET_CONSOLE_ON_WB"      ,True
 If console_wait    =  True        Then WZPrint "SET_CONSOLE_WAIT"       ,True
 ;if console_dontclose = true       Then wzprint "SET_CONSOLE_

 WZPrint "SET_SORTLABELS"     ,sort_labels

; If NOT no_scrollrate
;   WZDisable "SET_SCROLLRATE"
; Else
   WZPrint "SET_SCROLLRATE"   ,scroll_rate
; EndIf

 WZPrint "SET_TAB_SIZE"       , Peek.w(?tab_size)
 WZPrint "SET_CURSORBLINKRATE", blinkrate
 If OSVersion = #AmigaOS4                           ; check if OS4
   WZDisable "SET_MOUSEWHEELSTEP"                   ; yes disable it becau we use the System value
 Else                                               ; no print used value.
   WZPrint "SET_MOUSEWHEELSTEP",Peek.l(?wheelstep)  ; add to make Mousewheelsteprate configuratable and saveable tomsmart1
 EndIf

 tsourcedir$  = sourcedir$
 tdeflibfile$ = deflibfile$
 tincludedir$ = includedir$
 tautodocdir$ = autodocdir$
 thelpdir$    = helpdir$

 WZPrint "SET_SOURCEDIR"  ,&tsourcedir$
 WZPrint "SET_DEFLIBS"    ,&tdeflibfile$
 WZPrint "SET_INCDIR"     ,&tincludedir$
 WZPrint "SET_AUTODOCDIR" ,&tautodocdir$
 WZPrint "SET_HELPDIR"    ,&thelpdir$

 ;-- get screen infos
 temp_id.l     = myscreen_modeid
 temp_width.w  = myscreen_Width
 temp_height.w = myscreen_Height
 temp_depth.w  = myscreen_Depth

 ;-- get screenname
 log_Print{"getting screenmodename for id: " + Str$(temp_id)}
 temp_scr$ = screen_GetModeName{temp_id}
 log_Print{"modename = " + Str$(temp_scr$)}

 ;--  check if the ID unknown then get best match
 If temp_scr$ = "unknown"
   log_Print{"screenmode unknown, searching for best match available mode..."}
   If NOT KickVersion(39)
     temp_id.l = 0
     log_Print{"we need OS3+ to do this!"}
   Else
     temp_id.l = screen_GetBestModeID{temp_width,temp_height,temp_depth}
     log_Print{"most matching id: " + Str$(temp_id)}
   EndIf
   temp_scr$ = screen_GetModeName{temp_id}
   log_Print{"modename = " + temp_scr$}
 EndIf

 ;-- set screenrequester initials
 screen_SetASLInitialDims{temp_id,temp_width,temp_height,temp_depth}
 WZPrint "SET_SCREENNAME",&temp_scr$

 ;-- get font infos
 newsourcefont$      = sourcefont_name$
 newsourcefontsize.l = sourcefont_size
 newguifont$         = guifont$
 newguifontsize.l    = guifontsize
 tempstr$            = newsourcefont_name$ + " ("+Str$(newsourcefontsize)+")"
 WZPrint "SET_SOURCEFONTNAME",&tempstr$
 tempstr2$           = guifont$+" ("+Str$(guifontsize)+")"
 WZPrint "SET_GUIFONTNAME",&tempstr2$
 olduse_wbfont.b     = use_wbfont               ; temp variables to check former stat
 olduse_wbscreen.b   = use_wbscreen

 If use_wbscreen <> 0
   WZPrint "SET_USEWB"  ,On
   WZPrint "SET_CLONEWB",Off
   WZDisable "SET_SCREENNAME"
   WZDisable "SET_SCREEN"
   For i = 0 To 3
    WZDisable "SET_SCREENCOL" + Str$(i)   ; disable Screencolors
   Next i
   usewbscreen_tmp.b = True             ; temporay variable for prefs window
 Else
   For i = 0 To 3
    WZEnable "SET_SCREENCOL" + Str$(i)    ; enable Screencolors
   Next i
   usewbscreen_tmp.b = False
 EndIf

 If clone_wbscreen <> 0
   WZPrint "SET_USEWB"  ,Off
   WZPrint "SET_CLONEWB",On
   WZDisable "SET_SCREENNAME"
   WZDisable "SET_SCREEN"
   usewbscreen_tmp.b = False
 EndIf

 If use_wbfont = True                   ;<>0
   WZPrint "SET_USEWBFONT", On
   WZDisable "SET_SOURCEFONT"
   WZDisable "SET_SOURCEFONTNAME"
   WZDisable "SET_GUIFONT"
   WZDisable "SET_GUIFONTNAME"
   usewbfont_tmp.b = True               ; temporay variable for prefs window
 Else
   WZPrint "SET_USEWBFONT", Off
   WZEnable "SET_SOURCEFONT"
   WZEnable "SET_SOURCEFONTNAME"
   usewbfont_tmp.b = False
   If usewbscreen_tmp.b = True          ; only active GuiFontsettings if we don't use WBscreen
     WZDisable "SET_GUIFONT"
     WZDisable "SET_GUIFONTNAME"
   Else
     WZEnable "SET_GUIFONTNAME"
     WZEnable "SET_GUIFONT"
   EndIf
 EndIf


 ;-- get asl information
 If use_asldims Then WZPrint "SET_ASL_DIMENSIONS",On
 WZPrint "SET_ASLX",Peek.l(?aslreq_x)
 WZPrint "SET_ASLY",Peek.l(?aslreq_y)
 WZPrint "SET_ASLW",Peek.l(?aslreq_width)
 WZPrint "SET_ASLH",Peek.l(?aslreq_height)

 *cw_gad.Gadget = WZGadAddr("SET_COLORWHEEL")
 cw_open.b          = False                             ; type was .l changed to .b because function return is only .b  tomsmart
 colnum.w           = -1
 rebuild_gui.b      = False
 rebuild_sourcewindow.b = False
 rebuild_menu.b     = False

 settings_loop:
 exit_settings.b    = False
 save_settings.b    = False
 use_settings.b     = False
 reopen_settings.b  = False
 update_colors.b    = False
 SliderUsed.b       = False

 Repeat
   ev.l = WaitEvent

   If onlinehelp <> 0
      If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) AND (ev<>#IDCMP_GADGETHELP)  AND (ev<>#IDCMP_CHANGEWINDOW)
        WZ_HideHelp{}
      Else
        If (ev = #IDCMP_GADGETHELP) Then WZ_ShowHelp{}
      End If
   EndIf

   ;If ev<>#IDCMP_INTUITICKS AND (ev<>#IDCMP_MOUSEMOVE) Then log_Print{Hex$(ev)}

   Select ev
     Case #IDCMP_MOUSEMOVE
       If SliderUsed = True       ; check if colorslider used before
         SliderUsed = False       ; set it back
       Else
         If (WZInput("SET_PAGES") = 2) AND (cw_open = True)
           ; Get current RGB-Value in relation to the Gradient-slider
           _RGB.l = WZ_GetColorWheelRGB{}
           If _RGB <> old_RGB.l
             WZ_SetColorGradientSlider{_RGB}
             Gosub update_colorsliders    ; added to update the colorsilders to the values of the Colorwheel  tomsmart1
             old_RGB = _RGB
             update_colors.b = True
             If colnum<>-1
               AB3RGB_temp(colnum)= _RGB
               Gosub update_colorboxes
             EndIf
           EndIf
         EndIf
       EndIf

     Case #IDCMP_VANILLAKEY
       Select EventCode
         Case #VANILLAKEY_ESC : exit_settings = True
       End Select

     Case #IDCMP_REFRESHWINDOW
       Gosub update_colorwheel
       Gosub update_colorboxes

     Case #IDCMP_CLOSEWINDOW
       exit_settings = True

     Case #IDCMP_IDCMPUPDATE
       ; check the colorgadgets
       ;log_Print{"event: IDCMPUPDATE"}
       ;log_Print{"eventwindow: " + Str$(EventWindow)}
       ;log_Print{"gadid: " + Str$(WZGadHit)}
       ;log_Print{"gadname: " + Str$(WZGadName)}

       If Left$(WZGadName,9) = "SET_COLOR"
         colnum = Vallong(StrChg(WZGadName,"SET_COLOR",""))
         update_colors = True
         Gosub update_colorboxes
         If (ColorWheelError = False)
           WZ_SetColorWheelRGB{AB3RGB_temp(colnum)}
         EndIf
         _RGB = AB3RGB_temp(colnum) : old_RGB = _RGB       ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
         Gosub update_colorsliders  ; added to set the colorsilders to the select color  tomsmart1
       Else
         If Left$(WZGadName,13) = "SET_SCREENCOL"
           colnum.w = Vallong(StrChg(WZGadName,"SET_SCREENCOL","")) + 20
           update_colors = True
           rebuild_gui   = True
           Gosub update_colorboxes
           If (ColorWheelError = False)
             WZ_SetColorWheelRGB{AB3RGB_temp(colnum)}
           EndIf
            _RGB = AB3RGB_temp(colnum) : old_RGB = _RGB    ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
           Gosub update_colorsliders ; added to set the colorsilders to the select color  tomsmart1
         EndIf
       EndIf
       ;log_Print{"check other gadget..."}
       ;-- check all other gadgets
       Select WZGadName

         Case "SET_PAGES"
           If WZInput("SET_PAGES") = 2
             If KickVersion(39)
               Gosub update_colorwheel
               Gosub update_colorboxes
             Else
              error{"Color settings are not available with Workbench <V3.0."}
              WZPrint "SET_PAGES",0
             EndIf
           EndIf
         ; begin check new Gadgets of color page, tempstorage, sliders and integers  tomsmart1
         Case "COPYTOTEMP"        ; copy used color to tempstorage
           AB3RGB_copytemp = _RGB
           Gosub update_colorboxes

         Case "COPYTEMPTO"        ; used color of tempstorage
           _RGB = AB3RGB_copytemp
           Gosub set_color_slider_wheel_boxes

         Case "REDSLIDER"
           RedSlider.l = WZInput
           _RGB = (_RGB & $FF00FFFF) + (RedSlider LSL 16)
           Gosub set_color_slider_wheel_boxes
           SliderUsed = True

         Case "GREENSLIDER"
           GreenSlider.l = WZInput
           _RGB = (_RGB & $FFFF00FF) + (GreenSlider LSL 8)
           Gosub set_color_slider_wheel_boxes
           SliderUsed = True

         Case "BLUESLIDER"
           BlueSlider.l = WZInput
           _RGB = (_RGB & $FFFFFF00) + BlueSlider
           Gosub set_color_slider_wheel_boxes
           SliderUsed = True

         Case "REDIN"
           RedSlider = WZInput
           _RGB = (_RGB & $FF00FFFF) + (RedSlider LSL 16)
           Gosub set_color_slider_wheel_boxes

         Case "GREENIN"
           GreenSlider = WZInput
           _RGB = (_RGB & $FFFF00FF) + (GreenSlider LSL 8)
           Gosub set_color_slider_wheel_boxes

         Case "BLUEIN"
           BlueSlider = WZInput
           _RGB = (_RGB & $FFFFFF00) + BlueSlider
           Gosub set_color_slider_wheel_boxes
         ; end new gadgets of colors page

         Case "SET_SOURCEDIR"
           tsourcedir$ = WZInputstr
           WZPrint "SET_SOURCEDIR",&tsourcedir$

         Case "BUTTON_SOURCEDIR"
           aslfr_SetRequesterTitle {0,!TRANS{ "Please select source directory:"},"",""}
           aslfr_SetPath{0,tsourcedir$,"",""}
           If aslfr_Request{0,False,False,True}
             tsourcedir$ = aslfr_GetNextFile{}
             WZPrint "SET_SOURCEDIR",&tsourcedir$
           EndIf

         Case "SET_INCDIR"
           tincludedir$ = WZInputstr
           WZPrint "SET_INCDIR",&tincludedir$

         Case "BUTTON_INCDIR"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select includes directory:"},"",""}
           aslfr_SetPath{0,tincludedir$,"",""}
           If aslfr_Request{0,False,False,True}
             tincludedir$ = aslfr_GetNextFile{}
             WZPrint "SET_INCDIR",&tincludedir$
           EndIf

         Case "SET_HELPDIR"
           thelpdir$ = WZInputstr
           WZPrint "SET_HELPDIR",&thelpdir$

         Case "BUTTON_HELPDIR"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select help directory:"},"",""}
           aslfr_SetPath{0,thelpdir$,"",""}
           If aslfr_Request{0,False,False,True}
             thelpdir$ = aslfr_GetNextFile{};ASLPathRequest$("Select doc directory:",thelpdir$);,aslx,asly,aslw,aslh)
             WZPrint "SET_HELPDIR",&thelpdir$
           EndIf

         Case "SET_AUTODOCDIR"
           tautodocdir$ = WZInputstr
           WZPrint "SET_AUTODOCDIR",&tautodocdir$

         Case "BUTTON_AUTODOCDIR"
           aslfr_SetRequesterTitle {0,!TRANS{ "Please select AutoDocs directory:"},"",""}
           aslfr_SetPath{0,tautodocdir$,"",""}
           If aslfr_Request{0,False,False,True}
             tautodocdir$ = aslfr_GetNextFile{} ;ASLPathRequest$("Select autodoc directory:",tautodocdir$);,aslx,asly,aslw,aslh)
             WZPrint "SET_AUTODOCDIR",&tautodocdir$
           EndIf

         Case "BUTTON_DEFLIBS"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select standard DefLibs file:"},"",""}
           aslfr_SetPath{0,dos_PathPart{tdeflibfile$},dos_FilePart{tdeflibfile$},"#?"}
           If aslfr_Request{0,False,False,False}
             tdeflibfile$ = aslfr_GetNextFile{} ; tdeflibs$ = ASLFileRequest$("Select deflibs file:",aslpath$,aslfile$,"",aslx,asly,aslw,aslh)
             WZPrint "SET_DEFLIBS",&tdeflibfile$
           EndIf

         Case "SET_ASL_DIMENSIONS"
           If WZInput = 0
             WZDisable "SET_ASLX"
             WZDisable "SET_ASLY"
             WZDisable "SET_ASLW"
             WZDisable "SET_ASLH"
           Else
             WZEnable "SET_ASLX"
             WZEnable "SET_ASLY"
             WZEnable "SET_ASLW"
             WZEnable "SET_ASLH"
           EndIf

         Case "SET_PUBSCREEN"
           If WZInput = 0
             WZPrint "SET_DEFAULTPUBSCREEN",Off : WZDisable "SET_DEFAULTPUBSCREEN"
           Else
             WZEnable "SET_DEFAULTPUBSCREEN"
           EndIf
           rebuild_gui = True

         Case "SET_DEFAULTPUBSCREEN"
           rebuild_gui = True

         Case "SET_REMEMBER_SAVED"
           rebuild_menu = True

         Case "SET_CLONEWB"
           If WZInput
             WZDisable "SET_SCREENNAME"
             WZDisable "SET_SCREEN"
             WZPrint   "SET_USEWB",Off
             usewbscreen_tmp.b = False
             If usewbfont_tmp.b = False     ;only actived GUIfontsetting if we don't use WBFonts
               WZEnable "SET_GUIFONTNAME"
               WZEnable "SET_GUIFONT"
             EndIf
           Else
             WZEnable "SET_SCREENNAME"
             WZEnable "SET_SCREEN"
           EndIf
           rebuild_gui = True

         Case "SET_USEWB"
           If WZInput
             For i = 0 To 3
              WZDisable "SET_SCREENCOL"+Str$(i)
             Next i
             WZDisable "SET_SCREENNAME"
             WZDisable "SET_SCREEN"
             WZPrint   "SET_CLONEWB",Off
             usewbscreen_tmp.b = True       ; deactived GUIFontsettings we use WBScreen
             WZDisable "SET_GUIFONT"
             WZDisable "SET_GUIFONTNAME"
           Else
             For i = 0 To 3
              WZEnable "SET_SCREENCOL"+Str$(i)
             Next i
             WZEnable "SET_SCREENNAME"
             WZEnable "SET_SCREEN"
             usewbscreen_tmp.b = False
               If usewbfont_tmp.b = False    ;only actived GUIfontsetting if we don't use WBFonts
                 WZEnable "SET_GUIFONTNAME"
                 WZEnable "SET_GUIFONT"
             EndIf
           EndIf
           rebuild_gui = True

         Case "SET_SCREEN"
           aslsm_SetRequesterTitle {!TRANS{"Please select screenmode:"},"",""} ;!TRANS{"Ok"},!TRANS{"Cancel"}}  ; use system default  tomsmart1
           aslsm_SetMinDims{640,480,2}
           If aslsm_Request{}
              temp_id.l     = screen_GetASLModeID{}
              temp_width.w  = screen_GetASLWidth{}
              temp_height.w = screen_GetASLHeight{}
              temp_depth.w  = screen_GetASLDepth{}
              temp_scr$     = screen_GetASLModeName{}
              log_Print{"selected screen depth: " + Str$(temp_depth),#log_debug}
              WZPrint "SET_SCREENNAME",&temp_scr$
              log_Print{"written screenname... " + temp_scr$}
              rebuild_gui   = True
           EndIf

         Case "SET_GUIFONT"
           aslfo_SetRequesterTitle {!TRANS{"Please select GUI-Font:"},"",""} ;!TRANS{"Ok"},!TRANS{"Cancel"}}  ; use system default  tomsmart1
           aslfo_SetInitialFont{newguifont$,newguifontsize}
           If aslfo_Request{True}
             newguifont$      = aslfo_GetFontName{}
             newguifontsize   = aslfo_GetFontSize{}
             ;newguifontstyle = *finfo2\ta_Style
             tempstr2$= newguifont$ + " ("+Str$(newguifontsize)+")"
             WZPrint "SET_GUIFONTNAME",&tempstr2$
           EndIf

         Case "SET_USEWBFONT"
           If WZInput
             usewbfont_tmp.b = True
             WZDisable "SET_GUIFONT"
             WZDisable "SET_GUIFONTNAME"
             WZDisable "SET_SOURCEFONT"
             WZDisable "SET_SOURCEFONTNAME"
           Else
             usewbfont_tmp.b = False
             WZEnable "SET_SOURCEFONTNAME"
             WZEnable "SET_SOURCEFONT"
             If usewbscreen_tmp.b = False     ; make GUIfont selectable only if we don't use wbscreen
               WZEnable "SET_GUIFONT"
               WZEnable "SET_GUIFONTNAME"
             EndIf
           EndIf
           rebuild_gui = True

         Case "SET_SOURCEFONT"
           aslfo_SetRequesterTitle {!TRANS{"Please select Source-Font:"},"",""} ;!TRANS{"Ok"},!TRANS{"Cancel"}}  ; use system default tomsmart1
           aslfo_SetInitialFont{newsourcefont$,newsourcefontsize}
           If aslfo_Request{False}
             newsourcefont$     = aslfo_GetFontName{}
             newsourcefontsize  = aslfo_GetFontSize{}
             ;newsourcefontstyle = *finfo2\ta_Style
             tempstr$= newsourcefont$ + " ("+Str$(newsourcefontsize)+")"
             WZPrint "SET_SOURCEFONTNAME",&tempstr$
           EndIf


         Case "SET_F4"
           savewinpref{0,?ptr_sourcewindow} : JSR write_newprefs

         Case "SET_F5"
           savewinpref{1,?ptr_sourcewindow} : JSR write_newprefs

         Case "SET_F6"
           savewinpref{2,?ptr_sourcewindow} : JSR write_newprefs


         ; UNTERSTE BUTTON-ZEILE
         Case "SET_SAVE"
           save_settings   = True
           use_settings    = True
           exit_settings   = True

         Case "SET_USEEXIT"
           use_settings    = True
           exit_settings   = True

         Case "SET_USE"
           use_settings    = True
           exit_settings   = True
           reopen_settings = True

         Case "SET_CANCEL"
           use_settings    = False
           reopen_settings = False
           exit_settings   = True

       End Select

      ;log_Print{"end_of_event"}
   End Select
 Until exit_settings = True

 ;log_Print{"settings loop finished."}
 If use_settings = True
   log_Print{"storing all settings"}
   WZ_LockWindow{"WIN_SETTINGS"}
   auto_format =           WZInput("SET_AUTO_FORMAT")
   auto_constructs  =      WZInput("SET_COMPLETE_CONSTRUCTS")
   use_intellisense =      WZInput("SET_INTELLISENSE")
   correct_functions=      WZInput("SET_CORRECT_FUNCTIONS")
   Poke.b ?smart_tokenization,    Abs(WZInput("SET_SMART_TOKENIZATION"))
   Poke.b ?new_editmode,          WZInput("SET_STANDARD_EDITMODE")
   no_welcome =            WZInput("SET_WELCOME")
   ask_before_quit =       WZInput("SET_ASKBEFOREQUIT")
   onlinehelp =            WZInput("SET_ONLINEHELP")
   bold_tokens =           WZInput("SET_BOLDTOKENS")
   italic_remarks =        WZInput("SET_ITALICREMARKS")
   linenumbers =           WZInput("SET_LINENUMBERS")
   Poke.w ?remember_saved,        WZInput("SET_REMEMBER_SAVED")
   Poke.b ?load_last_source,      WZInput("SET_LAST_SOURCE")
   use_asldims           =        WZInput("SET_ASL_DIMENSIONS")
   use_pubscreen         =        WZInput("SET_PUBSCREEN")
   use_default_pubscreen =        WZInput("SET_DEFAULTPUBSCREEN")
   use_filepattern       =        WZInput("SET_FILEPATTERN")
   use_wbscreen =                 WZInput("SET_USEWB")
   clone_wbscreen =               WZInput("SET_CLONEWB")
   use_wbfont =                   -WZInput("SET_USEWBFONT")
   Poke.w ?auto_indent,           WZInput("SET_AUTO_INDENT")
   Poke.w ?oldsearch,             WZInput("SET_OLDSEARCH")
   Poke.b ?nodisplaybeep,         WZInput("SET_NO_DISPLAYBEEP")

   console_device$  =      WZGetString("SET_CONSOLE_DEVICE")
   console_wb       =      -WZInput("SET_CONSOLE_ON_WB")
   console_wait     =      -WZInput("SET_CONSOLE_WAIT")
   ;console_keepopen = WZInput("SET_CONSOLE_KEEPOPEN")

   sort_labels = -WZInput("SET_SORTLABELS")
   scroll_rate = WZInput("SET_SCROLLRATE")
   If scroll_rate = 0 Then no_scrollrate = True Else vvblank_SetFreq{scroll_rate}
   Poke.w ?tab_size      ,WZInput("SET_TAB_SIZE")
   blinkrate = WZInput("SET_CURSORBLINKRATE")
   Poke.l ?wheelstep     ,WZInput("SET_MOUSEWHEELSTEP")     ; added to make Mousewheelsteprate changeable, no special OS4 handling nessacary because the System settings are used by any event  tomsmart1

   Poke.l ?aslreq_x      ,WZInput("SET_ASLX")
   Poke.l ?aslreq_y      ,WZInput("SET_ASLY")
   Poke.l ?aslreq_width  ,WZInput("SET_ASLW")
   Poke.l ?aslreq_height ,WZInput("SET_ASLH")
   If use_asldims <> 0
     asl_SetRequesterDims{Peek.l(?aslreq_x),Peek.l(?aslreq_y),Peek.l(?aslreq_width),Peek.l(?aslreq_height)}
   Else
     asl_SetRequesterDims{-1,-1,-1,-1}
   EndIf

   ; store directories
   sourcedir$  = tsourcedir$
   deflibfile$ = tdeflibfile$
   includedir$ = tincludedir$
   autodocdir$ = tautodocdir$
   helpdir$    = thelpdir$

   Poke.l ?ptr_source_dir      ,&sourcedir$
   Poke.l ?ptr_incdirname      ,&includedir$
   Poke.l ?ptr_deflibsfilename ,&deflibfile$

   ;If temp_id <> myscreen_modeid OR temp_depth <> myscreen_Depth
   ;  Poke.l ?ownscreen_modeid ,temp_id
   ;  Poke.w ?ownscreen_height ,temp_height
   ;  Poke.w ?ownscreen_width  ,temp_width
   ;  Poke.w ?ownscreen_depth  ,temp_depth
   ;EndIf

   If ( (newguifont$<>guifont$) OR (newguifontsize<>guifontsize) ) AND ( (NOT use_wbfont) AND (use_wbscreen=0) )
     guifont$       = newguifont$
     guifontsize    = newguifontsize
     guifontstyle.l = newguifontstyle.l
     rebuild_gui    = True
   Else
     If ( (use_wbfont AND (NOT olduse_wbfont) ) AND olduse_wbscreen=0 ) OR ( ( (use_wbscreen<>0) AND (olduse_wbscreen=0) ) AND (NOT olduse_wbfont) )
      Gosub SetGuiFontToWBScreenFont
      rebuild_gui = True
     EndIf
   EndIf


   ; update colors
   If update_colors = True
     For i = 0 To (#MAX_AB3Pens-1) ; relaced wrong 24 by #Max_AB3Pens -1, -1 because 0 to 23  tomsmart1
       AB3RGB(i) = AB3RGB_temp(i)
     Next i
     If rebuild_gui = False          ; update screencolors only if GUI not rebuild else we trash maybe the Wbscreencolors
       Gosub set_storedcolors
       update_colors.b = False
     EndIf
   EndIf


   If ( (newsourcefont$ <> sourcefont_name$) OR (newsourcefontsize <> sourcefont_size) ) AND (NOT use_wbfont)
     sourcefont_name$ = newsourcefont$
     sourcefont_size.w  = newsourcefontsize
     sourcefont_style.b = newsourcefontstyle.b
     Poke.s ?str_sourcefontname,sourcefont_name$  ; + StrClone(Chr$(0), 16 - Len(newsourcefont$) )
     Poke.w ?sourcefontsize    ,sourcefont_size
     Poke.b ?sourcefontstyle   ,sourcefont_style
     JSR open_sourcefonts
     rebuild_sourcewindow = True
   EndIf

   If use_wbfont AND (NOT olduse_wbfont)
     ; get WBfont for Sourcefont
     sourcefont_name$ = ""     ;that open_sourcefonts get the WBfont
     Poke.s ?str_sourcefontname,sourcefont_name$
     JSR open_sourcefonts
     rebuild_sourcewindow = True
   EndIf

   If oldlinenumbers <> linenumbers Then rebuild_sourcewindow = True

   If (rebuild_sourcewindow = True) AND (rebuild_gui = False)
     Gosub set_pointer_busy_bas
     !asm
     JSR free_textbuffer
     JSR close_sourcewindow
     JSR open_sourcewindow
     JSR allocate_textbuffer
     !basic
     Gosub set_pointer_normal_bas
     WindowToFront_ Peek.l(Addr Window(WZID("WIN_SETTINGS")))
   Else
     !asm
     JSR _redraw
     !basic
   EndIf

   WZ_UnlockWindow{"WIN_SETTINGS"}
 EndIf

 If reopen_settings Then Goto settings_loop

 If save_settings
   log_Print{"saving settings..."}
   WZ_LockWindow{"WIN_SETTINGS"}
   Gosub write_newprefs
   ;MOVE.w #$FFFF,prefswritten_state
   Gosub set_tooltypes
   WZ_UnlockWindow{"WIN_SETTINGS"}
 EndIf

 If cw_open Then WZ_KillColorWheel{} : cw_open = False
 WZCloseWindow WZID("WIN_SETTINGS")
 FlushEvents
 UnlockAllOpenWZWin{}
 Gosub set_pointer_normal_bas
 If rebuild_gui
   log_Print{"rebuilding the gui..."}
   !asm
   JSR close_gui
   JSR open_sourcefonts
   JSR open_gui
   !basic
 EndIf
 If rebuild_menu
   Gosub init_menus
 EndIf

 Gosub activatesourcewindow
 !asm
 !setregsformenuexit
RTS


.update_colorboxes
   If WZInput("SET_PAGES") = 2
     WZ_LockWindow{"WIN_SETTINGS"}    ; added to prevent page switch during drawing  tomsmart1
     *winSettings.Window = Peek.l(Addr Window(WZID("WIN_SETTINGS")))
     boxpen.w = 1
     boxcolor.w = 0
     For ii.l = 1 To 12
       If ii = colnum Then boxpen = 2 Else boxpen = 1
       *gad.Gadget = WZGadAddr("SET_COLOR"+Str$(ii))
       If *gad
         boxx.w = *gad\LeftEdge + *gad\Width + 2
         boxw.w = boxx + 16
         boxy.w = *gad\TopEdge
         boxh.w = boxy + *gad\Height
         boxcolor.w = screen_GetPenRGB{AB3RGB_temp(ii)}
         SetAPen_ *winSettings\RPort,boxcolor : RectFill_ *winSettings\RPort,boxx+1,boxy+1,boxw-1,boxh-1
         SetAPen_ *winSettings\RPort,boxpen
         Move_ *winSettings\RPort,boxx,boxy
         Draw_ *winSettings\RPort,boxw,boxy
         Draw_ *winSettings\RPort,boxw,boxh
         Draw_ *winSettings\RPort,boxx,boxh
         Draw_ *winSettings\RPort,boxx,boxy
       EndIf
     Next ii

     For ii = 0 To 3
       If 20+ii = colnum Then boxpen = 2 Else boxpen = 1
       *gad.Gadget = WZGadAddr("SET_SCREENCOL"+Str$(ii))
       If *gad
         boxx = *gad\LeftEdge + *gad\Width + 2
         boxw = boxx + 16
         boxy = *gad\TopEdge
         boxh = boxy + *gad\Height
         SetAPen_ *winSettings\RPort,screen_GetPenRGB{AB3RGB_temp(20+ii)}
         RectFill_ *winSettings\RPort,boxx+1,boxy+1,boxw-1,boxh-1
         SetAPen_ *winSettings\RPort,boxpen
         Move_ *winSettings\RPort,boxx,boxy
         Draw_ *winSettings\RPort,boxw,boxy
         Draw_ *winSettings\RPort,boxw,boxh
         Draw_ *winSettings\RPort,boxx,boxh
         Draw_ *winSettings\RPort,boxx,boxy
       EndIf
     Next ii

     ; begin temporaycopy color
      *gad.Gadget = WZGadAddr("COPYTOTEMP")
       If *gad
         boxx = *gad\LeftEdge + *gad\Width + 2
         boxw = boxx + 16
         boxy = *gad\TopEdge
         boxh = boxy + *gad\Height
         SetAPen_ *winSettings\RPort,screen_GetPenRGB{AB3RGB_copytemp}
         RectFill_ *winSettings\RPort,boxx+1,boxy+1,boxw-1,boxh-1
         SetAPen_ *winSettings\RPort,boxpen
         Move_ *winSettings\RPort,boxx,boxy
         Draw_ *winSettings\RPort,boxw,boxy
         Draw_ *winSettings\RPort,boxw,boxh
         Draw_ *winSettings\RPort,boxx,boxh
         Draw_ *winSettings\RPort,boxx,boxy
       EndIf
     WZ_UnlockWindow{"WIN_SETTINGS"}  ; added to prevent page switch during drawing  tomsmart1
   EndIf
Return


.update_colorwheel:
  If (WZInput("SET_PAGES") = 2) AND (ColorWheelError = False)
    If cw_open
      WZ_KillColorWheel{}
      RefreshWindowFrame_ Peek.l(Addr Window(WZID("WIN_SETTINGS")))
      cw_open = False
    EndIf

    WZ_LockWindow{"WIN_SETTINGS"}  ; added to prevent page switch during drawing  tomsmart1
    cw_open = WZ_DrawColorWheel{*cw_gad\LeftEdge,*cw_gad\TopEdge,*cw_gad\Width,*cw_gad\Height,False}; added flag to not show the error message of the include  tomsmart1
    If cw_open
      If colnum <> -1
        WZ_SetColorWheelRGB{AB3RGB_temp(colnum)} : _RGB = AB3RGB_temp(colnum) : old_RGB = _RGB    ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
      Else
        WZ_SetColorWheelRGB{$FFFFFF}             : _RGB = $FFFFFF : old_RGB = _RGB                ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
        Gosub update_colorsliders  ; added to set the silder to the default settings  tomsmart1
      EndIf
    Else
      ColorWheelError = True
      error{!TRANS{"error creating colorwheel"} }   ; convert to a normal error message  tomsmart1
    EndIf
    WZ_UnlockWindow{"WIN_SETTINGS"}  ; added to prevent page switch during drawing  tomsmart1
  Else     ; not page 2
    If cw_open
      WZ_KillColorWheel{}
      cw_open = False
    EndIf
  EndIf
Return


.update_colorsliders:     ; added to set the colorsliders position and value of the colorintger gadgets  tomsmart1
  RedSlider   = ( (_RGB & $00FF0000) LSR 16)
  GreenSlider = ( (_RGB & $0000FF00) LSR 8)
  BlueSlider  =   (_RGB & $000000FF)
  WZPrint "REDSLIDER"  , RedSlider
  WZPrint "GREENSLIDER", GreenSlider
  WZPrint "BLUESLIDER" , BlueSlider
  WZPrint "REDIN"      , RedSlider
  WZPrint "GREENIN"    , GreenSlider
  WZPrint "BLUEIN"     , BlueSlider
Return


.set_color_slider_wheel_boxes:  ;added to set the color -wheel, -boxes, -slider and -intger gadgets for a colorslider or intger gadget change  tomsmart1
  old_RGB = _RGB
  If (ColorWheelError = False)
    WZ_SetColorWheelRGB{_RGB}     ; update the ColorWheel and GradientSlider
  EndIf
  Gosub update_colorsliders     ; update the sliders and the intger gadgets
  If colnum <> -1               ; check if a AB3color is set to change
    update_colors = True
    AB3RGB_temp(colnum) = _RGB  ; set it to the color we set by the slider or get intger gadget
    Gosub update_colorboxes     ; redraw the boxes
  EndIf
Return


.set_tooltypes
   If disk_object
       mypath$ = dos_GetProgDir{""}
       ; -- save colors
       dos_SetToolString{"FUNCTIONCOLOR"   ,"$"+Hex$(AB3RGB(#AB3_cfunction))}
       dos_SetToolString{"MACROCOLOR"      ,"$"+Hex$(AB3RGB(#AB3_cmacro))}
       dos_SetToolString{"STRINGCOLOR"     ,"$"+Hex$(AB3RGB(#AB3_cstring))}
       dos_SetToolString{"NEWTYPECOLOR"    ,"$"+Hex$(AB3RGB(#AB3_cnewtype))}
       dos_SetToolString{"CONSTANTCOLOR"   ,"$"+Hex$(AB3RGB(#AB3_cconstant))}
       dos_SetToolString{"REMARKFORG"      ,"$"+Hex$(AB3RGB(#AB3_cremarkforeground))}
       dos_SetToolString{"REMARKBACKG"     ,"$"+Hex$(AB3RGB(#AB3_cremarkbackground))}
       dos_SetToolString{"TOKENCOLOR"      ,"$"+Hex$(AB3RGB(#AB3_ctoken))}
       dos_SetToolString{"TOKENBACKPEN"    ,"$"+Hex$(AB3RGB(#AB3_ctokenbackground))}
       dos_SetToolString{"BACKGROUNDCOLOR" ,"$"+Hex$(AB3RGB(#AB3_cbackground))}
       dos_SetToolString{"OTHERCOLOR"      ,"$"+Hex$(AB3RGB(#AB3_cother))}
       dos_SetToolString{"CLASSICCOLOR"    ,"$"+Hex$(AB3RGB(#AB3_cclassic))}
       dos_SetToolString{"screenbackcolor" ,"$"+Hex$(AB3RGB(#AB3_screenback))}
       dos_SetToolString{"screentextcolor" ,"$"+Hex$(AB3RGB(#AB3_screentext))}
       dos_SetToolString{"screenshinecolor","$"+Hex$(AB3RGB(#AB3_screenshine))}
       dos_SetToolString{"screenfillcolor" ,"$"+Hex$(AB3RGB(#AB3_screenfill))}

       ; save Screen settings
       dos_SetToolSwitch{"USE_WBSCREEN"    ,-WZInput("SET_USEWB")}
       dos_SetToolSwitch{"CLONE_WBSCREEN"  ,-WZInput("SET_CLONEWB")}
       dos_SetToolSwitch{"DEFAULTPUBSCREEN",-WZInput("SET_DEFAULTPUBSCREEN")}
       dos_SetToolSwitch{"PUBSCREEN",-WZInput("SET_PUBSCREEN")}
       ;save ownscreen parameters
       dos_SetToolValue{"SCREEN_ID"        ,myscreen_modeid}
       dos_SetToolValue{"SCREEN_WIDTH"     ,myscreen_Width}
       dos_SetToolValue{"SCREEN_HEIGHT"    ,myscreen_Height}
       dos_SetToolValue{"SCREEN_DEPTH"     ,myscreen_Depth}

       ; save Font settings
       dos_SetToolSwitch{"USE_WBFONT"      ,-WZInput("SET_USEWBFONT")}
       If WZInput("SET_USEWBFONT") = False     ;
         If newsourcefont$ <>""
           dos_SetToolSwitch{"SOURCEFONT"  ,True}       ; actived tooltype maybe it was deactived
           dos_SetToolString{"SOURCEFONT"  ,newsourcefont$+","+Str$(newsourcefontsize)}
         Else
           dos_SetToolSwitch{"SOURCEFONT"  ,False}      ; deactived Sourcefont Tooltypes no font is set
         EndIf
         If newguifont$ <>"" AND WZInput("SET_USEWB")=False   ;
           dos_SetToolSwitch{"GUIFONT"     ,True}       ; actived tooltype maybe it was deactived
           dos_SetToolString{"GUIFONT"     ,newguifont$+","+Str$(newguifontsize)}
         Else
           dos_SetToolSwitch{"GUIFONT"     ,False}      ; deactived GUIfont Tooltypes no font is set or we use the WBscreen
         EndIf
       Else
         dos_SetToolSwitch{"GUIFONT"       ,False}      ; deactived GUIfont Tooltypes we use WBfonts
         dos_SetToolSwitch{"SOURCEFONT"    ,False}      ; deactived Sourcefont Tooltypes we use WBfonts
       EndIf

       ; save other settings
       dos_SetToolSwitch{"NO_WELCOME"        , -WZInput("SET_WELCOME")}
       dos_SetToolSwitch{"ASKBEFOREQUIT"     , -WZInput("SET_ASKBEFOREQUIT")}
       dos_SetToolSwitch{"STANDARDEDITMODE"  , -WZInput("SET_STANDARD_EDITMODE")}
       dos_SetToolSwitch{"OLDSEARCH"         , -WZInput("SET_OLDSEARCH")}
       dos_SetToolSwitch{"NODISPLAYBEEP"     , -WZInput("SET_NO_DISPLAYBEEP")}
       dos_SetToolSwitch{"AUTO_FORMAT"       , -WZInput("SET_AUTO_FORMAT")}
       dos_SetToolSwitch{"AUTO_INDENT"       , -WZInput("SET_AUTO_INDENT")}     ; add because was not saved before  tomsmart1
       dos_SetToolSwitch{"AUTO_CONSTRUCTS"   , -WZInput("SET_COMPLETE_CONSTRUCTS")}
       dos_SetToolSwitch{"USE_INTELLISENSE"  , -WZInput("SET_INTELLISENSE")}
       dos_SetToolSwitch{"CORRECT_FUNCTIONS" , -WZInput("SET_CORRECT_FUNCTIONS")}
       dos_SetToolSwitch{"SMART_TOKENIZATION", -WZInput("SET_SMART_TOKENIZATION")}
       dos_SetToolSwitch{"TOKENBOLD"         , bold_tokens}
       dos_SetToolSwitch{"ITALIC_REMARKS"    , italic_remarks}
       dos_SetToolSwitch{"LINENUMBERS"       , linenumbers}
       dos_SetToolSwitch{"ONLINEHELP"        , -WZInput("SET_ONLINEHELP")}

       dos_SetToolSwitch{"SOURCE_HISTORY"    , -WZInput("SET_REMEMBER_SAVED")}
       dos_SetToolSwitch{"LOAD_LAST_SOURCE"  , -WZInput("SET_LAST_SOURCE")}
       dos_SetToolSwitch{"SORT_LABELS"       , sort_labels}
       dos_SetToolString{"CURSORSTYLE"       , cursorStyleGetString{cursorStyle}}
       dos_SetToolValue{"SCROLLRATE"         , scroll_rate}
       If OSVersion <> #AmigaOS4                                     ; check if not OS4 than save the value, because on OS4 the System value is used  tomsmart1
         dos_SetToolValue{"MOUSEWHEELSTEP"   , Peek.l(?wheelstep)}   ; added to make Mousewheelsteprate configuatable and saveable  tomsmart1
       EndIf

       ; save console settings
       dos_SetToolString{"CON_DEVICE" ,console_device$}
       dos_SetToolSwitch{"CON_ONWB"   ,console_wb}
       dos_SetToolSwitch{"CON_WAIT"   ,console_wait}

       ; save ASL parameters
       dos_SetToolSwitch{"USE_ASLDIMS",-WZInput("SET_ASL_DIMENSIONS")}
       dos_SetToolValue{"ASLREQ_X"    ,Peek.l(?aslreq_x)}
       dos_SetToolValue{"ASLREQ_Y"    ,Peek.l(?aslreq_y)}
       dos_SetToolValue{"ASLREQ_W"    ,Peek.l(?aslreq_width)}
       dos_SetToolValue{"ASLREQ_H"    ,Peek.l(?aslreq_height)}

       If blinkrate > 0 Then dos_SetToolValue{"CURSORBLINKRATE",blinkrate}

       ; save pathes
       dos_SetToolString{"HELPDIR"    ,helpdir$}
       dos_SetToolString{"AUTODOCDIR" ,autodocdir$}
       dos_SetToolString{"SOURCEDIR"  ,sourcedir$}
       dos_SetToolString{"LIBFILE"    ,deflibfile$}
       dos_SetToolString{"INCLUDEDIR" ,includedir$}

       ;update AND write Icon
       dos_FlushToolTypes{}
   EndIf
Return

.menu_iconify:
!basic
  If KickVersion(36)
    !asm
    JSR close_gui
    !basic
    *appMenuItem.l = AddAppMenuItemA_(0,0,Peek$(?str_defaultpubscreen),*WBMsgPort,Tags(#TAG_DONE,#TAG_END))
    log_Print{"generated appmenuitem, waiting for uniconify command..."}
    WaitPort_ *WBMsgPort
    *msg.Message = GetMsg_(*WBMsgPort)
    ReplyMsg_ *msg
    log_Print{"... got message, reopening."}
    RemoveAppMenuItem_ *appMenuItem
    Pop If
    !asm
    MOVEA.l comPtr_CurrentSourceLine,A2
    JSR open_gui
    BMI.w exit_PED_closeall_longjmp
    RTS
  EndIf
!asm
Return

exit_PED_closeall_longjmp:
JMP exit_PED_closeall


.taglist_mousepointerbusy:
  Dc.b $80,$00,$00,$98               ; #WA_BusyPointer.
  Dc.b $FF,$FF,$FF,$FF
  Ds.l 1

.taglist_mousepointernormal:
  Dc.b $80,$00,$00,$97               ; #WA_Pointer
  Ds.l 2

.set_pointer_normal:
  !regs2stack
  !basic
  Gosub set_pointer_normal_bas
  !asm
  !stack2regs
RTS

.set_pointer_normal_bas:
  USEPATH sourceWindow
  If \win
    If KickVersion(39) Then SetWindowPointerA_ \win, ?taglist_mousepointernormal;Tags(#WA_Pointer,#TAG_END)
    If (Peek.l(?addr_menustrip) <> 0)
      ResetMenuStrip_ \win,Peek.l(?addr_menustrip)
      ; set it back to the flags that are used by open the window  tomsmart1
      ModifyIDCMP_ \win, SourceWindowIDCMPFlags.l
    EndIf
  EndIf
Return


.set_pointer_busy:
  !regs2stack
  !basic
  Gosub set_pointer_busy_bas
  !asm
  !stack2regs
RTS

.set_pointer_busy_bas:
  USEPATH sourceWindow
  If \win
    If KickVersion(39) Then SetWindowPointerA_ \win, ?taglist_mousepointerbusy;Tags(#WA_BusyPointer,True)
    ClearMenuStrip_ \win
    ; only allow following flags to lock the sourcewin
    ModifyIDCMP_ \win, #IDCMP_NEWSIZE|#IDCMP_REFRESHWINDOW|#WFLG_REPORTMOUSE
  EndIf
Return

Even
ptr_sourcefilename:      Ds.l 1
str_extentionxtra:       Dc.b ".xtra",0
str_extentioninfo:       Dc.b ".info",0
str_bakextention:        Dc.b ".bak",0,0


.write_infofile:
  *flock.l = Lock_(Peek$(Peek.l(?ptr_sourcefilename)) + Peek$(?str_extentioninfo), #ACCESS_READ)
  If *flock = 0
    *fh.l = Open_(Peek$(Peek.l(?ptr_sourcefilename)) + Peek$(?str_extentioninfo),#HUNK_RELOC_8__MODE_NEWFILE)
    Write_ *fh,Peek.l(?sourceicon_datas),?sourceicondatas_end-?sourceicon_datas
    Close_ *fh
  Else
    UnLock_ *flock
  EndIf
RTS


.open_xtrafile:
  !basic
  MOVE.l d2,d0                      ; get accessmode from d2
  accessmode.l = PutD0
  *fh.l = Open_(Peek$(Peek.l(?ptr_sourcefilename)) + Peek$(?str_extentionxtra),accessmode)
  MOVE.l d0,d7
  !asm
RTS

.menu_load:
  MOVEA.l #str_newfile_req,A0
  MOVE.l #$4C6F6164,(A0)+           ; "Load File"
  MOVE.l #$2046696C,(A0)+
  MOVE.b #"e",(A0)+
  MOVE.b #$0,(A0)+
  JSR show_newfilerequest
  MOVEA.l #str_newfile_req,A0
  MOVE.l #$4E657720,(A0)+           ; "New File"
  MOVE.l #$46696C65,(A0)+
  MOVE.b #$0,(A0)+

  TST.l D0
  BNE.w JL_0_E78
    RTS
  JL_0_E78:

  JSR do_aslloadfilerequest
  TST.l D0
  BNE.w load_source
RTS


.set_CurrentDir:
  If Peek$(?comStr_CurrentDir) = "" Then GetCurrentDirName_ ?comStr_CurrentDir,$40

  If *flock_currentDir Then UnLock_ *flock_currentDir
  *flock_currentDir.l = Lock_(Peek$(?comStr_CurrentDir),#ACCESS_READ)
  If *flock_currentDir Then CurrentDir_ *flock_currentDir
Return


.split_filename:
  ;comStr_SourceFileComplete,A0
  ;comStr_CurrentDir,A1
  ;comStr_SourceName,A2
  MOVE.l A0,-(A7)

 JL_0_EFA:
    TST.b (A0)+
  BNE.b JL_0_EFA

 JL_0_EFE:
    MOVE.b -(A0),D0
    CMP.b #":",D0
    BEQ.w JL_0_F16
  CMP.b #$2F,D0
  BNE.b JL_0_EFE

  MOVEA.l A0,A3                      ; "/" gefunden
  ADDQ.l #1,A0
  BRA.w JL_0_F1A

 JL_0_F16:                           ; ":" hinten gefunden
  ADDQ.l #1,A0
  MOVEA.l A0,A3

 JL_0_F1A:                           ; nur den filename kopieren
    MOVE.b (A0)+,(A2)+
  BNE.b JL_0_F1A

  MOVEA.l (A7)+,A0

 JL_0_F20:
    MOVE.b (A0)+,(A1)+               ; nur den pfad kopieren
    CMPA.l A0,A3
  BNE.b JL_0_F20
  CLR.b (A1)
RTS


.load_source:  ;D7: sourcefilename
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
  MOVE.b #1,menuload
  MOVE.l D7,ptr_sourcefilename

  !basic
  Gosub set_pointer_busy_bas
  LockAllOpenWZWin{}
  filenameP.l = Peek.l(?ptr_sourcefilename)
  If filenameP
    filename.s = Peek.s(filenameP)
    log_Print{"loading source <" + filename.s + ">"}
    ex.s = dos_GetExt{filename}
  Else
    ex.s = "???"
  End If
  MOVE.l #0,loading_done
  If ex.s = "ab3"
    !asm
    MOVE.l ptr_sourcefilename,D0
    !ComData_JSR{comFunc_LoadSource}
    !basic
    ;-- restore windows
    Gosub RestoreLabelAndNewtypeWin
    changelog$ = ""
    Gosub update_versiongadgets
    !asm
    ;-- update Sourcewindow
    JSR calc_SourceWindowDimensions
    MOVE.l comLong_CursorPosStore,d0
    MOVEA.l comPtr_CurrentSourceLine,A4
    JSR gotoline
    MOVEA.l actualfile,A0
    JSR delete_tempprefs
    JSR save_tempprefs

    JSR update_horizscroller
    JSR update_labelstuff
    JSR StoreXtraData
    ;JSR clear_sourcewindow
    JSR _redraw
    JSR analyze_loadedsource

    JSR draw_statusarea
    CLR.b convert
    MOVE.l #1,loading_done

    !basic
    Gosub set_pointer_normal_bas
    UnlockAllOpenWZWin{}
  EndIf

  !asm
  TST.l loading_done
  BEQ old_loading_routine
RTS


cancel_loading_routine:
JMP clear_sourcebuffer;JL_0_6B7C

loading_done: Dc.l 0


old_loading_routine:
  !regs2stack
  !basic
  log_Print{"OLD LOADING ROUTINE..."}
  !asm
  !stack2regs
  JSR open_sourcefile
  CLR.w comWord_SourceChanged

  JSR source_readin
  BNE.w JL_0_F50
    JSR close_sourcefile
  JL_0_F50:

  MOVEM.l D0-D7/A0-A5,-(A7)

  MOVE.l D7,D1                                    ; filehandle nach D1
  MOVE.l #comStr_SourceFileComplete,D2
  MOVE.l #$FE,D3                                  ; bufflength nach D3
  MOVEA.l _dosbase,A6
  JSR _NameFromFH(A6)

  LEA comStr_SourceFileComplete,A0
  TST.b convert
  BEQ 'l1
    LEA comStr_SourceFileComplete,A0
   'l10
      TST.b (a0)+
    BNE 'l10
    LEA -5(a0),a0
    MOVE.l #".bb2",(a0)
 'l1
  LEA comStr_SourceFileComplete,A0
  LEA comStr_CurrentDir,A1
  LEA comStr_SourceName,A2
  BSR.b split_filename

  !regs2stack
  !basic
  JSR set_CurrentDir
  !asm
  !stack2regs

  MOVEM.l (A7)+,D0-D7/A0-A5
  JSR set_pointer_busy
  JSR reset_Blockflag
  JSR clear_actualsource

  MOVE.l #$0001,comLong_TotalLines
  MOVE.l comPtr_Temp_TokenString2,tempstore
  JSR JL_0_4F5A
  JSR newSourcelineFromTempString
  MOVE.l A0,comPtr_FirstSourceLine
  MOVE.l A0,comPtr_CurrentSourceLine
  CLR.l $4(A0)
  MOVE.l A0,comPtr_LastSourceLine

  JL_0_FB4:
    MOVEA.l A0,A4
    MOVE.l comPtr_Temp_TokenString2,tempstore
    JSR JL_0_4F5A
    BMI.w JL_0_FD6
      JSR newSourcelineFromTempString
      MOVE.l A0,comPtr_LastSourceLine
      MOVE.l A0,(A4)
      ADDQ.l #1,comLong_TotalLines
      MOVE.l A4,$4(A0)
  BRA.b JL_0_FB4
  JL_0_FD6:
  ;JSR JL_0_4E4A
  JSR close_sourcefile
;  CLR.l comLong__AL_0_868A
  CLR.w comWord_TextBufferOffset
  CLR.w comWord_Column        ; was .l
  CLR.w comWord_ColumnsOffset ; was .l
  CLR.l comLong_DisplayLineOffset
  CLR.l comLong_DisplayLine

  MOVE.l comFunc_ReadXtraFile,D0
  BEQ.w JL_0_100C
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2 ; read xtra
  JSR open_xtrafile                      ; returns D7: filehandle
  BEQ.w skip_loadingxtrafile

  MOVE.l comFunc_ReadXtraFile,D0
  MOVEA.l D0,A5
  JSR (A5)

  MOVE.l d7,d0
  !basic
  xtrafilehandle.l = PutD0
  JSR update_debuggertoggle
  Read_ xtrafilehandle,?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin ; xtrabuf,36

;  stackSize.l = Peek.l(?comLong_StackSizeStore)
;  If stackSize<4096 Then stackSize=4096
;  Poke.l ?stacksize,stackSize

  ; -- get the data for creating executables
  exefilename$ = ""
  exepathname$ = ""
  tempexename$ = SPACE$(96)

  Seek_ xtrafilehandle,$256,#OFFSET_BEGINNING
  Read_ xtrafilehandle,&tempexename$,96
  i = 1
  Repeat
    char$ = Mid$(tempexename$,i,1)
    If Asc(char$)<>0 Then exepathname$ + char$
    i + 1
  Until (i = FLen(tempexename$)) OR (Asc(char$) = 0)

  tempexename$ = SPACE$(96)
  Seek_ xtrafilehandle,$316,#OFFSET_BEGINNING
  Read_ xtrafilehandle,&tempexename$,96
  i = 1
  Repeat
    char$ = Mid$(tempexename$,i,1)
    If Asc(char$)<>0 Then exefilename$ + char$
    i + 1
  Until (i = FLen(tempexename$)) OR (Asc(char$) = 0)
;  exepathname$ = dos_Trim{exepathname$}
;  exefilename$ = dos_Trim{exefilename$}
;  !cout{exepathname$+"/"+exefilename$} ;$ , dos_GetFileSize2{exepathname$+"/"+exefilename$}}


  ; restore windows
  Gosub RestoreLabelAndNewtypeWin
  changelog$ = ""
  Gosub update_versiongadgets

  Close_ xtrafilehandle
  !asm
  ;MOVE.l D7,D1
  ;MOVEA.l _dosbase,A6
  ;JSR _Close(A6)

  !regs2stack
  !ComData_SetB{comByte_FuncOptimize,#1}                   ; added for compatiblity because it is not stored in the xtra file  tomsmart1
  !ComData_SetW{comWord_CreateDebugFile,#0}                ; to match the old default settings  tomsmart1
  !stack2regs

  ; update Sourcewindow
  MOVE.l comLong_CursorPosStore,d0
  MOVEA.l comPtr_CurrentSourceLine,A4
  JSR gotoline

  MOVEA.l actualfile,A0
  JSR delete_tempprefs
  JSR save_tempprefs

 skip_loadingxtrafile:

 JL_0_100C:
  JSR update_horizscroller
  JSR update_labelstuff
  JSR StoreXtraData
  JSR _redraw
  JSR analyze_loadedsource
  JSR draw_statusarea
  CLR.b convert

  !basic
  UnlockAllOpenWZWin{ }
  Gosub set_pointer_normal_bas
  !asm
  MOVEQ.l #-$01,D0
RTS


;subroutine to restore Source_Browser(Label) and Definition_Browser(Newtype) window status after load and switch of Sourecode  tomsmart1
.RestoreLabelAndNewtypeWin
  search_label$ = Peek$(?comStr_LabelSearchString) ; set the searchlabel_string
  old_search_label$ = search_label$                ; set also old searchlabel_string to prevent a unessacary reset and jump of the labellist tomsmart1
  MOVE.l comLong_Label1VisableItemStore,comLong_Label1VisableItem          ;  move stored entry to tempbuffer manly for case of load a source  tomsmart1
  LabelList_FirstVisableItemNumber.l = Peek.l(?comLong_Label1VisableItem)  ;  set/restore the first visable entry of the labellist  tomsmart1
  LabelList_PreSelectItemNumber.l    = -1          ; set the preselected labellist entry to -1 because we don't save/store it. ; change from 0 to -1 so not the first entry was preselect  tomsmart1

  If WZ_CheckOpen{"WIN_LABELS"}
    Use Window WZID("WIN_LABELS")
    WZPrint "STRING_LABEL",search_label$
    WZPrint "rem"         ,Peek.w(?comWord_LabelRemark)
    WZPrint "all"         ,Peek.w(?comWord_LabelAll)
    WZListRemove lib_list.List
    WZPrint "LIBRARY_LIST",0,lib_list
  EndIf
  If WZ_CheckOpen{"WIN_NEWTYPE"}
    Use Window WZID("WIN_NEWTYPE")
    Gosub newtype_updatelist
  End If
Return


.analyze_loadedsource:
  !regs2stack
  !basic
  log_Print{"analyze_loadedsource"}
  windowtitle$ = "File - "
  If Peek.b(?comStr_SourceName) = 0
    windowtitle$ + "unnamed "
    If Peek.b(?smart_tokenization) Then Poke.w ?comWord_DoTokenize,$FFFF
  Else
    windowtitle$ + Peek$(?comStr_SourceName) + " (" + Peek$(?comStr_CurrentDir) + ")"
    ; -- check extension
    fext$ = LCase$(dos_GetExt{Peek$(?comStr_SourceName)})
    log_Print{"checking file extention of loaded file: " + fext$}
    If fext$ = "bb2" OR fext$ = "ab2" OR fext$ = "ab3" OR fext$ = "bb"
      log_Print{"activating tokenization"}
      Poke.w ?comWord_DoTokenize, $FFFF
      Poke.w ?flag_tokenization, $FFFF
    EndIf
    If fext$ = "txt" OR fext$ = "guide"
      log_Print{"deactivating tokenization"}
      Poke.w ?comWord_DoTokenize, 0
      Poke.w ?flag_tokenization, 0
      If fext$ = "guide" Then Poke.b ?amigaguide,1
    EndIf
  EndIf

  SetWindowTitles_ sourceWindow\win, &windowtitle$, -1

  ; -- update tooltype "LAST_SOURCE"
  If Peek.b(?load_last_source) <> 0
    last_source$ = Peek$(?comStr_SourceFileComplete)
    If last_source$<>""
      If Instr(last_source$,Peek$(?comStr_SourceName))<>0
        dos_SetToolString{"LAST_SOURCE",last_source$}
      EndIf
    EndIf
  EndIf
  !asm
  !stack2regs
RTS


.delete_tempprefs_new:
  !basic
  If Peek.l(?comFunc_ReadXtraFile) <> 0
    !asm
    MOVE.l A0,D0
    LEA str_template_tempxtrafile,A0
    JSR generate_tempfilename
    !basic
    DeleteFile_(Peek$(?str_temptedprefs))
  EndIf
  !asm
RTS


.delete_tempprefs:
  MOVE.l comFunc_ReadXtraFile,D0
  BEQ.w exit_delete_tempprefs
    MOVE.l A0,D0
    LEA str_template_tempxtrafile,A0
    JSR generate_tempfilename
    MOVEA.l _dosbase,A6
    MOVE.l #str_temptedprefs,D1
    JSR _DeleteFile(A6)
    ;DeleteFile_ Peek$(?str_temptedprefs)
  exit_delete_tempprefs:
RTS


.read_tempprefs_new:
  !basic
  If Peek.l(?comFunc_ReadXtraFile) <> 0
    !asm
    MOVE.l actualfile,D0
    LEA str_template_tempxtrafile,A0
    JSR generate_tempfilename
    !basic
    tpfhandle.l = Open_( Peek$(?str_temptedprefs),#HUNK_RELOC_16__MODE_OLDFILE)
    If tpfhandle <> 0
      GetD0 Peek.l(?comFunc_ReadXtraFile) : MOVE.l d0,-(a7)
      GetD0 tpfhandle : MOVE.l d0,-(a7)
      !asm
      MOVE.l (a7)+,D7
      MOVEA.l (a7)+,A5
      MOVEA.l _dosbase,A6
      JSR (A5)
      !basic
      Close_ tpfhandle
    EndIf
  EndIf
  !asm
RTS

.read_tempprefs:
  MOVE.l comFunc_ReadXtraFile,D0
  BEQ.w exit_read_tempprefs
    MOVE.l actualfile,D0
    LEA str_template_tempxtrafile,A0
    JSR generate_tempfilename
    MOVE.l comFunc_ReadXtraFile,D0
    MOVEA.l D0,A5
    MOVEA.l _dosbase,A6
    MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
    MOVE.l #str_temptedprefs,D1
    JSR _Open(A6)
    ;Open_ Peek$(?str_temptedprefs,#HUNK_RELOC_16__MODE_OLDFILE
    MOVE.l D0,D7
    ;BEQ.w exit_read_tempprefs
    MOVE.l D0,-(A7)
    JSR (A5)
    MOVE.l (A7)+,D1
    MOVEA.l _dosbase,A6
    JSR _Close(A6)

  exit_read_tempprefs:
RTS

.save_tempprefs_new:
  !basic
  If Peek.l(?comFunc_WriteXtraFile) <> 0
    !asm
    MOVE.l actualfile,D0
    LEA str_template_tempxtrafile,A0
    JSR generate_tempfilename
    !basic
    tpfhandle.l = Open_( Peek$(?str_temptedprefs),#HUNK_RELOC_8__MODE_NEWFILE)
    If tpfhandle <> 0
      GetD0 Peek.l(?comFunc_WriteXtraFile) : MOVE.l d0,-(a7)
      GetD0 tpfhandle : MOVE.l d0,-(a7)
      !asm
      MOVE.l (a7)+,D7
      MOVEA.l (a7)+,A5
      MOVEA.l _dosbase,A6
      JSR (A5)
      !basic
      Close_ tpfhandle
    EndIf
  EndIf
  !asm
Return

.save_tempprefs:
  MOVE.l comFunc_WriteXtraFile,D0
  BEQ.w exit_save_tempprefs
    MOVE.l actualfile,D0
    LEA str_template_tempxtrafile,A0
    JSR generate_tempfilename
    MOVE.l comFunc_WriteXtraFile,D0
    MOVEA.l _dosbase,A6
    MOVEA.l D0,A5
    MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
    MOVE.l #str_temptedprefs,D1
    JSR _Open(A6)
    MOVE.l D0,D7
    BEQ.w exit_save_tempprefs
    MOVE.l D0,-(A7)
    JSR (A5)
    MOVE.l (A7)+,D1
    MOVEA.l _dosbase,A6
    JSR _Close(A6)
 exit_save_tempprefs:
RTS


AL_0_15BC:    Ds.l 1
AL_0_15C0:    Ds.l 1
AL_0_1162:    Ds.w 1


.menu_saveas:
  ST AL_0_1162
  JSR StoreXtraData
  LEA comStr_ASLSaveFile,A2

  MOVEM.l D1-D6/A0-A6,-(A7)
  JSR do_aslsavefilerequest
  MOVEM.l (A7)+,D1-D6/A0-A6

  TST.l D0
  BEQ.w JL_0_1158
    JSR menu_save
  JL_0_1158:

  SF AL_0_1162
  TST.l D0
RTS



JL_0_1164:
  LEA comStr_ASLSaveFile,A2
  MOVEM.l D1-D6/A0-A6,-(A7)
  JSR do_aslsavefilerequest
  MOVEM.l (A7)+,D1-D6/A0-A6
RTS

.saverout
  !regs2stack
  BSR menu_save
  !stack2regs
RTS

.menu_save
  TST.b comStr_SourceName
  BNE.w JL_0_1196
    BSR.b JL_0_1164
    TST.l D0
    BNE.w JL_0_1196
      RTS
  JL_0_1196:
  !basic
  BB2Filename$ = Peek$(?comStr_SourceFileComplete)
  directory.s = dos_FilePart{dos_PathPart{BB2Filename$}}
  If dos_Exist{BB2filename$} AND LCase$(directory) = "templates"
    If ask{!TRANS{"Do you really want to save this file into the templates drawer?"},!TRANS{"Ok|Cancel"},!TRANS{"Question"}}
      overwrite.l = True
    Else
      overwrite = False
    EndIf
  Else
    overwrite = True
  EndIf

  If NOT overwrite
    Pop If
    !asm
    RTS
  EndIf
  !asm

  MOVEM.l A0-A2,-(A7)
  MOVEA.l #comStr_CurrentDir,A1
  MOVEA.l #comStr_SourceName,A2
  MOVEA.l #comStr_SourceFileComplete,A0

  TST.b (A1)
  BEQ.w JL_0_11C6
    JL_0_11B2:
      MOVE.b (A1)+,(A0)+
    BNE.b JL_0_11B2

    SUBQ.w #1,A0
    CMPI.b #":",-$1(A0)
    BEQ.w JL_0_11C6
      MOVE.b #$2F,(A0)+
  JL_0_11C6:
  MOVE.l a0,namesizestore

 'l1a
    MOVE.b (A2)+,(A0)+
  BNE.b 'l1a

  CLR.b ab2mode

  CMP.l #$61623200,-4(a0)            ;ab2
  BNE 'os
    MOVE.b #1,ab2mode
 'os

  CMP.l #$61623300,-4(a0)            ;ab3
  BNE 'os3
    MOVE.b #3,ab2mode
 'os3

  CMP.l #$41423300,-4(a0)            ;AB3
  BNE 'os3a
    MOVE.b #3,ab2mode
 'os3a

  SUB.l namesizestore,a0
  CMP.l #28,a0
  BLE 'l10
    !basic
    dummy.l = ask{!TRANS{"Warning: Filename is longer than 27 characters.\\nThis may cause problems with some filesystems."},!TRANS{"Continue"},!TRANS{"Info"}}
    !asm
 'l10

  MOVEM.l (A7)+,A0-A2
  MOVE.l #comStr_SourceFileComplete,D7
  JSR StoreXtraData

  TST.b AL_0_1162
  BEQ.w JL_0_1216
    MOVEA.l _dosbase,A6
    MOVE.l D7,D1
    MOVEQ.l #-$02,D2
    JSR _Lock(A6)
    TST.l D0
    BEQ.w JL_0_1216
      MOVE.l D0,-(A7)                    ; put lock from d0 to stack
      LEA easystruct_saveas,A1
      JSR show_requester
      MOVE.l (A7)+,D1                    ; get lock from stack to d1 for unlock

      TST.w D0
      BEQ.w JL_0_1214
        MOVEA.l _dosbase,A6
        JSR _UnLock(A6)
        BRA.w JL_0_1216
     JL_0_1214:
        RTS
  JL_0_1216:

  MOVE.l D7,ptr_sourcefilename
  MOVEA.l comPtr_DosBuffer,A1
  MOVE.l A1,D1
  MOVEA.l D7,A0

  JL_0_1224:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_1224

  SUBQ.w #1,A1
  LEA str_bakextention,A0

  JL_0_122E:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_122E

  MOVEA.l _dosbase,A6
  JSR _DeleteFile(A6)
  MOVE.l D7,D1
  MOVE.l comPtr_DosBuffer,D2
  JSR _Rename(A6)

  !basic
  LockAllOpenWZWin{}
  Gosub set_pointer_busy_bas
  !asm

  TST.b ab2mode
  BEQ old_saveroutine
    MOVE.l #comStr_SourceFileComplete,d0
    CMP.b #1,ab2mode
    BNE 'saveab3
      JSR saveab2

      JSR JL_0_1372
      TST.w remember_saved
      BEQ.w 'JL_0_1286b
        JSR AJL_0_B990
     'JL_0_1286b:
      !basic
      UnlockAllOpenWZWin{}
      Gosub set_pointer_normal_bas
      !asm
      RTS
   'saveab3
    ;!basic
    ;error{"Save via new code!"}
    ;a.s = "Ram:Test.ab3"
    ;GetReg d0,&a.s
    ;!asm
    MOVE.l #comStr_SourceFileComplete,d0
    !ComData_JSR{comFunc_SaveSource}

    JSR analyze_loadedsource
    CLR.w comWord_SourceModifiedFlag
    CLR.w comWord_KeyBeforeReturn
    CLR.w comWord_SourceChanged
    JSR update_modifiermark

    TST.w remember_saved
    BEQ.w skip_historymenu
      JSR AJL_0_B990
    skip_historymenu:

    !basic
    UnlockAllOpenWZWin{}
    Gosub set_pointer_normal_bas
    !asm
    RTS
  old_saveroutine:

  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVE.b #1,menuload
  JSR open_sourcefile

  ;JSR set_pointer_busy

  MOVEA.l comPtr_FirstSourceLine,A2
  MOVE.l comLong_TotalLines,D5
  ;SUBQ.l #1,D5
  TST.w AL_0_B7E0
  BEQ.w JL_0_1288
    MOVEM.l D1-D7/A0-A6,-(A7)
    JSR JL_0_12D6                      ;save write raw
    MOVEM.l (A7)+,D1-D7/A0-A6
    JSR JL_0_1372
    TST.w remember_saved
    BEQ.w JL_0_1286
      JSR AJL_0_B990
    JL_0_1286:
    RTS
  JL_0_1288:

  JSR JL_0_1292
  JSR JL_0_1372
RTS

JL_0_1292:
  JL_0_1298:
    MOVEQ.l #$00,D4
    MOVE.b $8(A2),D4
    LEA $9(A2),A3

    MOVE.w comWord_DoTokenize,D0
    BNE.w JL_0_12B2
      MOVE.b #$A,-$1(A3,D4.W)
    JL_0_12B2:

    MOVE.l D7,D1
    MOVE.l A3,D2
    MOVE.l D4,D3
    MOVEA.l _dosbase,A6
    JSR _Write(A6)
    CLR.b -$1(A3,D4.W)

    TST.l D0
    BEQ.w JL_0_1378
      MOVEA.l (A2),A2
      SUBQ.l #1,d5
  BNE JL_0_1298

  ;DBF D5,JL_0_1298
  CLR.w comWord_SourceChanged
  MOVEQ.l #-$01,D0
RTS

JL_0_12D6:
  MOVEQ.l #$00,D0
  MOVEQ.l #$00,D1
  MOVE.l D5,D4

  JL_0_12Dca:
    MOVE.b $8(A2),D1
    ADD.l D1,D0
    MOVEA.l (A2),A2
    SUBQ.l #1,d5
  BNE JL_0_12Dca
  ;DBF D5,JL_0_12Dca

  MOVE.l D0,AL_0_15C0
  !newalloc
  MOVEA.l comPtr_FirstSourceLine,A2
  MOVEA.l D0,A5
  MOVE.l D4,D5
  MOVE.l D0,AL_0_15BC
  BNE.w JL_0_130C
    BRA.b JL_0_1298
  JL_0_130C:
  MOVEA.l _dosbase,A6

  JL_0_1312:
    LEA $9(A2),A3
    MOVEQ.l #$00,D4
    MOVE.b $8(A2),D4
    SUBQ.w #1,D4

    JL_0_131E:
      MOVE.b (A3)+,(A5)+
    DBF D4,JL_0_131E

    TST.w comWord_DoTokenize
    BNE.w JL_0_1334
      MOVE.b #$A,-$1(A5)
    JL_0_1334:

    MOVEA.l (A2),A2
    SUBQ.l #1,d5
  BNE JL_0_1312
   ;DBF D5,JL_0_1312
  MOVE.l D7,D1
  MOVE.l AL_0_15BC,D2
  MOVE.l AL_0_15C0,D3
  MOVEA.l _dosbase,A6
  JSR _Write(A6)
  MOVE.l D0,-(A7)
  CLR.w comWord_SourceChanged
  MOVEA.l _execbase,A6
  MOVEA.l AL_0_15BC,A1
  !newfree
  MOVEA.l _dosbase,A6
  CLR.w comWord_SourceChanged
  MOVE.l (A7)+,D0
RTS

JL_0_1372:
  TST.l D0
  BNE.w JL_0_1380
    JL_0_1378:
    LEA comStr_ErrorWriteFile,A0
    JSR show_errorrequester
  JL_0_1380:

;  JSR JL_0_4E4A
  JSR close_sourcefile
  MOVE.l comFunc_WriteXtraFile,D0
  BEQ.w JL_0_13A8
    MOVEA.l D0,A5
    MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
    JSR open_xtrafile
    BEQ.w skip_writingxtrafile
      JSR (A5)

      !basic
      MOVE.l comLong_DisplayLineOffset,d0
      ADD.l comLong_DisplayLine,d0
      MOVE.l d0,comLong_CursorPosStore
      Poke$ ?comStr_LabelSearchString,search_label$
      MOVE.l LabelList_FirstVisableItemNumber@(a5),comLong_Label1VisableItemStore
      MOVE.l d7,d0
      xtrafilehandle.l = PutD0
      ; moved the write of the 4 extra fill/pad/termination bytes to the Compiler xtra save routine because the Compiler xtra load routine needs it!  tomsmart1
      Write_ xtrafilehandle,?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin
      Close_ xtrafilehandle
      !asm
    skip_writingxtrafile:
  JL_0_13A8:

  ;MOVE.w #1,prefs_source_icon
  !basic
  If Peek.w(?prefs_source_icon) Then Gosub write_infofile
  !asm

  JSR analyze_loadedsource
  CLR.w comWord_SourceModifiedFlag
  CLR.w comWord_KeyBeforeReturn
  CLR.w comWord_SourceChanged
  JSR update_modifiermark
  !basic
  UnlockAllOpenWZWin{}
  Gosub set_pointer_normal_bas
  !asm
RTS


.sourceicon_datas:
  Dc.b $E3,$10,$00,$01
  Dc.b $00,$00,$00,$00
  Dc.b $00,$63,$00,$11
  Dc.b $00,$2E,$00,$18
  Dc.b $00,$05,$00,$03
  Dc.b $00,$01,$00,$22
  Dc.b $7B,$20,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $04,$22,$00,$22
  Dc.b $70,$78,$00,$22
  Dc.b $72,$B8,$00,$00
  Dc.b $00,$5C,$00,$00
  Dc.b $00,$0E,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$2E
  Dc.b $00,$17,$00,$02
  Dc.b $00,$01,$8F,$98
  Dc.b $03,$00,$00,$00
  Dc.b $00,$00,$FF,$FF
  Dc.b $FF,$FF,$FF,$FC
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $80,$FF,$FF,$FF
  Dc.b $7C,$00,$81,$80
  Dc.b $00,$00,$06,$00
  Dc.b $81,$80,$00,$00
  Dc.b $06,$00,$81,$9A
  Dc.b $DE,$D5,$86,$00
  Dc.b $81,$97,$5B,$7D
  Dc.b $86,$00,$81,$82
  Dc.b $56,$E9,$86,$00
  Dc.b $81,$81,$AD,$5D
  Dc.b $86,$00,$81,$9F
  Dc.b $FF,$FF,$86,$00
  Dc.b $81,$80,$00,$00
  Dc.b $06,$00,$81,$FF
  Dc.b $FF,$FF,$FE,$00
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$7F
  Dc.b $FF,$FF,$F8,$00
  Dc.b $80,$80,$00,$00
  Dc.b $04,$00,$81,$3A
  Dc.b $AA,$AB,$52,$00
  Dc.b $81,$55,$55,$54
  Dc.b $2A,$00,$82,$00
  Dc.b $00,$00,$01,$00
  Dc.b $83,$FF,$FF,$FF
  Dc.b $FF,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$1F
  Dc.b $FF,$FF,$E0,$04
  Dc.b $00,$1A,$DE,$D4
  Dc.b $00,$04,$00,$17
  Dc.b $5B,$7C,$00,$04
  Dc.b $00,$02,$56,$E8
  Dc.b $00,$04,$00,$01
  Dc.b $AD,$5C,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$1F
  Dc.b $FF,$FF,$E0,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$7F
  Dc.b $FF,$FF,$F8,$04
  Dc.b $00,$C5,$55,$54
  Dc.b $AC,$04,$00,$AA
  Dc.b $AA,$AB,$D4,$04
  Dc.b $01,$FF,$FF,$FF
  Dc.b $FE,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $7F,$FF,$FF,$FF
  Dc.b $FF,$FC,$00,$00
  Dc.b $00,$0E,$42,$6C          ;0,$e4,"Bl"
  Dc.b $69,$74,$7A,$33          ;"itz3"
  Dc.b $3A,$41,$6D,$69          ;":Ami"
  Dc.b $42,$6C,$69,$74          ;"Blit"
  Dc.b $7A,$33,$00,$00          ;"z3",0,0
  Dc.b $00,$00,$04
Even
.sourceicondatas_end


.menu_about:
  !basic
  txt0$ = !versions + "#" + Peek$(Peek.l(?comPtr_CompilerVersion))
  txt1$ = Peek$(?str_Arexx_PortName)
  txt2$ = Peek$(?str_defaultpubscreen)
  txt3$ = acidlibdate$
  txt4$ = deflibdate$

  window_welcome{txt0$,txt1$, txt2$, txt3$, txt4$}
  !asm
  !setregsformenuexit
RTS


str_searchstring:   Ds.b #MAX_STRINGSIZE
str_replacestring:  Ds.b #MAX_STRINGSIZE
case_sensitive:     Dc.b $00,$00
Even

.search_string:
  MOVEQ.l #$00,D5

  JL_0_15C6:
  LEA $9(A4),A5
  MOVE.w flag_tokenization,D0
  BEQ.w JL_0_15E0
  MOVEA.l A5,A0
  MOVEA.l comPtr_Temp_TokenString1,A1
  MOVEA.l A1,A5
  JSR detokenize_line                ;detokenize_line

  JL_0_15E0:
  MOVEA.l A5,A1                      ;compare routine
  ADDA.w D5,A5

  JL_0_15E4:
  MOVEA.l A5,A3
  LEA str_oldsearchgadget,A2

  JL_0_15EA:
    MOVE.b (A2)+,D0
     BEQ.w JL_0_162E
    MOVE.b (A3)+,D2
     BEQ.w exit_search_string
    BTST #$7,case_sensitive
     BNE.w JL_0_1626
     !isLetter
     ;jsr checkForLetter
     BNE.w JL_0_1626
    ANDI.w #$DF,D2

    JL_0_1626:
    CMP.b D0,D2
     BEQ.b JL_0_15EA
    ADDQ.w #1,A5
  BRA.b JL_0_15E4

  JL_0_162E:
  SUBA.l A1,A5
  MOVE.w A5,D0
  RTS

  exit_search_string:
  MOVEQ.l #-$01,D0
RTS

.replace_string:
  JSR search_string
   BMI.w exit_replace_string
  MOVE.w #$FFFF,comWord_SourceChanged

  JL_0_17Dca:
  MOVEA.l comPtr_Temp_TokenString2,A0
  MOVEQ.l #$00,D1

  JL_0_17E2:
    CMP.w D0,D1
    BCC.w JL_0_17EE
    MOVE.b (A1)+,(A0)+
    ADDQ.w #1,D1
  BRA.b JL_0_17E2

  JL_0_17EE:
  LEA str_searchstring,A2

  JL_0_17F2:
  TST.b (A2)+
  BEQ.w JL_0_17FC
  ADDQ.w #1,A1
  BRA.b JL_0_17F2

  JL_0_17FC:
  LEA str_replacestring,A2

  JL_0_1800:
    ADDQ.w #1,D1
    MOVE.b (A2)+,(A0)+
  BNE.b JL_0_1800

  SUBQ.w #1,A0
  SUBQ.w #1,D1
  MOVE.w D1,-(A7)

  JL_0_180C:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_180C

  SUBQ.w #1,A0

  JL_0_1812:
    CMPA.l comPtr_Temp_TokenString3,A0
    BCC.w JL_0_1820
    MOVE.b #$20,(A0)+
  BRA.b JL_0_1812

  JL_0_1820:
  MOVEA.l comPtr_Temp_TokenString2,A2
  JSR parse_line
  JSR JL_0_55AA
  MOVE.w (A7)+,D5
  JSR JL_0_15C6
  BPL.b JL_0_17Dca
  MOVEQ.l #$00,D0
  RTS

  exit_replace_string:
  MOVEQ.l #-$01,D0
RTS



.menu_find:                          ;find
  MOVE.w message_qualifier,d0
  AND.w #3,d0                        ;#IEQUALIFIER_LSHIFT|#IEQUALIFIER_RSHIFT
  BNE 'os1
    JSR jump_addhistory
    TST.w oldsearch
    BEQ 'os1
     MOVEQ #0,d0
     JSR jumpline
 'os1
  !regs2stack
  !basic
  ;Gosub getstring_new2               ; set current source word as search phrase
  *textline.l = TEDGetCurrentLine{} + 9
  *detokened.l = TEDDetoke{*textline}
  actualword$ = PED_GetWordAtPos{Peek$(*detokened), Peek.w(?comWord_Column)}
  If actualword$ <> ""
    oldfindstr$ = actualword$
  EndIf

  If WZ_CheckOpen{"WIN_SEARCH"} = False
    WZWindow WZID("WIN_SEARCH"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_SEARCH")
    AddedMenu2WZWin{"WIN_SEARCH"}
    Delay_ 2
    WZPrint "FIND_FINDSTRING"   ,&oldfindstr$
    WZPrint "FIND_REPLACESTRING",&oldreplacestr$
    ActivateWZGadget{"FIND_FINDSTRING"}      ; replaced to use the statement  tomsmart1 2012 03 09
  Else
    Use Window WZID("WIN_SEARCH")
    WindowToFront_ WZWindowAddr
    ActivateWZGadget{"FIND_FINDSTRING"}
  EndIf
  !asm
  !stack2regs
  !setregsformenuexit
RTS

.menu_findnext:
  MOVE.l (A4),D0                     ;start code
  BEQ.w setpointer_to_normal

  MOVEA.l D0,A4
  MOVEQ.l #$01,D6

  JL_0_1754:
  MOVE.b str_searchstring,D0         ;find
  BEQ.w setpointer_to_normal

  JSR set_pointer_busy
  MOVE.l comLong_DisplayLineOffset,D7
  ADD.l comLong_DisplayLine,D7
  ADD.l D6,D7

  JL_0_176A:
    JSR search_string
    BPL.w JL_0_1790
      ADD.l D6,D7
      BMI.w setpointer_to_normal
        CMP.l comLong_TotalLines,D7
        BCC.w setpointer_to_normal
          TST.l D6
          BPL.w JL_0_178C
            MOVEA.l $4(A4),A4
            BRA.b JL_0_176A
          JL_0_178C:
          MOVEA.l (A4),A4
  BRA.b JL_0_176A
  JL_0_1790:

  JSR set_pointer_normal
  MOVE.l D0,-(A7)
  MOVE.l D7,D0
  MOVEA.l comPtr_CurrentSourceLine,A4
  JSR sub_gotoline
  MOVE.l (A7)+,D1
  JSR moveCursorToX
JMP update_horizscroller

.menu_previous:
  MOVE.l $4(A4),D0
  BEQ.w setpointer_to_normal
  MOVEA.l D0,A4
  MOVEQ.l #-$01,D6
BRA.b JL_0_1754

.menu_replace:
  MOVE.b str_searchstring,D0
  BEQ.w setpointer_to_normal
  JSR replace_string
  BNE.w setpointer_to_normal
  JSR menu_findnext
JMP _redraw



.menu_quitall:
  MOVEA.l #str_newfile_req,A0
  MOVE.l #$51756974,(A0)+            ; "Quit"
  MOVE.b #$0,(A0)+
  JSR show_newfilerequest
  MOVEA.l #str_newfile_req,A0
  MOVE.l #$4E657720,(A0)+            ; "New File"
  MOVE.l #$46696C65,(A0)+
  MOVE.b #$0,(A0)+

  TST.l D0
  BEQ.w exit_quitall

    JSR dummy_compilercall
    ;JSR clear_labellist    called in clear_actualsource
    ; -- hier problem mit enforcer bei !newfree
    JSR clear_actualsource
    ; --
    MOVEA.l actualfile,A0
    JSR close_actualsource

    !basic
    Gosub draw_tabs
    !asm

    TST.l loadedfilesbase
    BNE.b menu_quitall
      JSR arexx_send_quitplease
      ;  LEA $E(A7),A7                  ;This is pure evil stackmagic that work only for on case that the
                                        ;jump to the routine comes form the asm event/message loop for the
                                        ;Sourcewindow and not form the Basic loop for the other windows
      JMP Exit_main                     ;Jump to real exit, this fix the Exit bug if the Sourcewindow not active  tomsmart1

  exit_quitall:
RTS


.menu_quit:
  MOVEA.l #str_newfile_req,A0         ; patch the requester name
  MOVE.l #"Quit",(A0)+
  MOVE.b #$0,(A0)+
  JSR show_newfilerequest
  MOVEA.l #str_newfile_req,A0         ; unpatch the requester name
  MOVE.l #"New ",(A0)+
  MOVE.l #"File",(A0)+
  MOVE.b #$0,(A0)+

  TST.l D0
  BEQ.w exit_quit
    JSR dummy_compilercall
    ;JSR clear_labellist              called in clear_actualsource
    JSR clear_actualsource            ;alle zeilen loeschen und freigeben

    MOVEA.l actualfile,A0
    JSR close_actualsource

    TST.l loadedfilesbase
    BNE.w exit_quit
      !regs2stack
      !basic
      dummy.l = 1
      If ask_before_quit
        dummy.l = ask{!TRANS{"Closing last source, do you really want to quit?"},!TRANS{"Ok|Cancel"},!TRANS{"Question"}}
      EndIf
      If dummy = 0
        Pop If
        !stack2regs
        !asm
        JSR menu_opennew
        BRA exit_quit
      EndIf
      !stack2regs
      !asm
      JSR arexx_send_quitplease
      ;LEA $E(A7),A7                  ;This is pure evil stackmagic that work only for on case that the
                                      ;jump to the routine comes form the asm event/message loop for the
                                      ;Sourcewindow and not form the Basic loop for the other windows
      JMP Exit_main                   ;Jump to real exit, this fix the Exit bug if the Sourcewindow not active  tomsmart1
  exit_quit:

  JSR draw_statusarea
RTS


.menu_blockcomment:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w setpointer_to_normal

  JSR move_to_blockstarty
  MOVEA.l A5,A4

 JL_0_21F0:
    MOVEA.l comPtr_Temp_TokenString2,A1
    MOVE.b #";",(A1)+
    LEA $9(A4),A0
    MOVE.w comWord_DoTokenize,D0
    BNE.w JL_0_220E

 JL_0_2206:
      MOVE.b (A0)+,(A1)+
    BNE.b JL_0_2206
BRA.w JL_0_2212

 JL_0_220E:
    JSR detokenize_line

 JL_0_2212:
      CMPA.l comPtr_Temp_TokenString3,A1
      BCC.w JL_0_2220
      MOVE.b #$20,(A1)+
BRA.b JL_0_2212

 JL_0_2220:
    MOVE.l A4,comPtr_CurrentSourceLine
    JSR JL_0_55A2
    MOVEA.l (A4),A4
    ADDQ.l #1,D6
  CMP.l comLong_BlockEndY,D6
  BLS.b JL_0_21F0

  JSR update_currsourceline
JMP _redraw


.menu_blockuncomment:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w setpointer_to_normal

  JSR move_to_blockstarty
  MOVEA.l A5,A4

 JL_0_224E:
  MOVEA.l comPtr_Temp_TokenString2,A1
  LEA $9(A4),A0
  MOVE.w comWord_DoTokenize,D0
   BNE.w JL_0_2268

 JL_0_2260:
  MOVE.b (A0)+,(A1)+
   BNE.b JL_0_2260
BRA.w JL_0_226C

 JL_0_2268:
  JSR detokenize_line

 JL_0_226C:
  MOVEA.l comPtr_Temp_TokenString2,A1
  MOVEA.l A1,A0

 JL_0_2272:
  MOVE.b (A0)+,D1
   BEQ.w JL_0_2286
  CMP.b #";",D1
   BEQ.w JL_0_2288
  CMP.b #$20,D1
   BEQ.b JL_0_2272

 JL_0_2286:
  MOVEA.l A1,A0

 JL_0_2288:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_2288
  SUBQ.w #1,A1

 JL_0_228E:
  CMPA.l comPtr_Temp_TokenString3,A1
   BCC.w JL_0_229C
  MOVE.b #$20,(A1)+
  BRA.b JL_0_228E

 JL_0_229C:
  MOVE.l A4,comPtr_CurrentSourceLine
  JSR JL_0_55A2
  MOVEA.l (A4),A4
  ADDQ.l #1,D6
  CMP.l comLong_BlockEndY,D6
  BLS.b JL_0_224E
  JSR update_currsourceline
JMP _redraw


.menu_blocktab:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w setpointer_to_normal

  JSR update_currsourceline
  JSR move_to_blockstarty
  MOVEA.l A5,A4

 JL_0_22CA:
    MOVEA.l comPtr_Temp_TokenString2,A1     ; -- copy TAB-Spaces to A1
    MOVE.w tab_size,D0
    BEQ.w JL_0_22E2
    SUBQ.w #1,D0

 JL_0_22DA:
      MOVE.b #$20,(A1)+
 DBF D0,JL_0_22DA

 JL_0_22E2:
    LEA $9(A4),A0                    ; -- detokenize line in A0 and copy it in A1 behind TAB-Spaces
    MOVE.w comWord_DoTokenize,D0
    BNE.w JL_0_22F8

 JL_0_22F0:
      MOVE.b (A0)+,(A1)+
    BNE.b JL_0_22F0
BRA.w JL_0_22FC

 JL_0_22F8:
    JSR detokenize_line

 JL_0_22FC:
      CMPA.l comPtr_Temp_TokenString3,A1
      BCC.w JL_0_230A
      MOVE.b #$20,(A1)+
BRA.b JL_0_22FC

 JL_0_230A:
    MOVE.l A4,comPtr_CurrentSourceLine
    JSR JL_0_55A2
    MOVEA.l (A4),A4
    ADDQ.l #1,D6
  CMP.l comLong_BlockEndY,D6
  BLS.b JL_0_22CA                    ; -- next line until comLong_BlockEndY is reached

  JSR update_currsourceline
JMP _redraw


.menu_blockuntab:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w setpointer_to_normal

  JSR move_to_blockstarty
  MOVEA.l A5,A4

  JL_0_2338:
    MOVEA.l comPtr_Temp_TokenString2,A1
    LEA $9(A4),A0
    MOVE.w comWord_DoTokenize,D0
    BNE.w JL_0_2352

 JL_0_234A:
      MOVE.b (A0)+,(A1)+
    BNE.b JL_0_234A
BRA.w JL_0_2356

 JL_0_2352:
    JSR detokenize_line

 JL_0_2356:
    MOVEA.l comPtr_Temp_TokenString2,A1
    MOVEA.l A1,A0
    MOVE.w tab_size,D0
    BEQ.w JL_0_2378
    SUBQ.w #1,D0

 JL_0_2368:
      TST.b (A0)+
      BEQ.w JL_0_2378
 DBF D0,JL_0_2368

 JL_0_2372:
      MOVE.b (A0)+,(A1)+
    BNE.b JL_0_2372
    SUBQ.w #1,A1

 JL_0_2378:
      CMPA.l comPtr_Temp_TokenString3,A1
      BCC.w JL_0_2386
      MOVE.b #$20,(A1)+
BRA.b JL_0_2378

 JL_0_2386:
    MOVE.l A4,comPtr_CurrentSourceLine
    JSR JL_0_55A2
    MOVEA.l (A4),A4
    ADDQ.l #1,D6
  CMP.l comLong_BlockEndY,D6
  BLS.b JL_0_2338

  JSR update_currsourceline
JMP _redraw


.generate_tempfilename:
  LEA str_hexdigits,A1
  MOVEQ.l #$07,D2
  JL_0_23A8:
    ROL.l #4,D0
    MOVE.b D0,D1
    ANDI.w #$F,D1
    MOVE.b 0(A1,D1.W),(A0)+
  DBF D2,JL_0_23A8
RTS
str_hexdigits:             Dc.b "0123456789ABCDEF"
str_temptedprefs:          Dc.b "T:PED_"
str_template_tempxtrafile: Dc.b "        .xtra",0 : Even

.close_actualsource:
  CLR.w comWord_SourceChanged

  MOVEM.l D0-D2/A0-A1,-(A7)
  JSR delete_tempprefs
  MOVEM.l (A7)+,D0-D2/A0-A1

  MOVEA.l _execbase,A6
  MOVE.l A0,-(A7)
  TST.l $4(A0)
  BEQ.w rem_file_from_base;JL_0_2432

  TST.l (A0)
  BEQ.w JL_0_2482

  MOVEA.l (A0),A1
  MOVE.l A1,actualfile
  MOVEA.l $4(A0),A2
  MOVE.l A1,(A2)
  MOVE.l A2,$4(A1)
  MOVEA.l A0,A1
  !newfree

  MOVEA.l actualfile,A0
  JSR GetXtraData
  JSR read_tempprefs
  JSR JL_0_2Dca8
  MOVEA.l (A7)+,A0
RTS

rem_file_from_base:
  TST.l (A0)
  BEQ.w JL_0_2466
    MOVEA.l (A0),A1
    MOVE.l A1,loadedfilesbase
    MOVE.l A1,actualfile
    CLR.l $4(A1)
    MOVEA.l A0,A1
    !newfree
    MOVEA.l actualfile,A0
    JSR GetXtraData
    JSR read_tempprefs
    JSR JL_0_2Dca8
    MOVEA.l (A7)+,A0
    RTS
  JL_0_2466:

  MOVEA.l A0,A1
  !newfree
  CLR.l loadedfilesbase
  CLR.l AL_0_84B2
  CLR.l actualfile
  MOVEA.l (A7)+,A0
RTS

 JL_0_2482:
  TST.l $4(A0)
   BEQ.w JL_0_24B8

  MOVEA.l $4(A0),A1
  MOVE.l A1,AL_0_84B2
  MOVE.l A1,actualfile
  CLR.l (A1)
  MOVEA.l A0,A1
  !newfree
  MOVEA.l actualfile,A0
  JSR GetXtraData
  JSR read_tempprefs
  JSR JL_0_2Dca8
  MOVEA.l (A7)+,A0
RTS

 JL_0_24B8:
  MOVEA.l A0,A1
  !newfree
  CLR.l loadedfilesbase
  CLR.l AL_0_84B2
  CLR.l actualfile
  MOVEA.l (A7)+,A0
RTS


.dummy_compilercall:
  ; this call to the compiler is useless, as the adress com_calldummy is always zero
  MOVE.l D0,-(A7)
  MOVE.l comFunc_CallDummy,D0
  BEQ.w exit_dummycall
    MOVEM.l D1-D7/A0-A6,-(A7)
    MOVEA.l D0,A0
    L_0_24E4: JSR (A0)
    MOVEM.l (A7)+,D1-D7/A0-A6
    !basic
    dummy.l = ask{!TRANS{"The dummy call has been performed"},!TRANS{"Ok"}}
    !asm
  exit_dummycall:

  MOVE.l (A7)+,D0
RTS


.key_cursordown:
  !regs2stack
  !basic
  mqualifier.w = Peek.w(?message_qualifier) AND (NOT #IEQUALIFIER_REPEAT) ; remove "repeat" flag
  mqualistor.w = Peek.w(?comWord_QualifierStore)
  ;log_Print{"cursordown: " +Hex$(mqualifier)}

  ; convert right qualifiers to left qualifiers to make selctblock smarter
  If (mqualifier AND #IEQUALIFIER_RSHIFT)
    mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
  EndIf
  If (mqualifier AND #IEQUALIFIER_RALT)
    mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
  EndIf

  Select mqualifier
    Case #IEQUALIFIER_RELATIVEMOUSE                         ; $8000: one line down
      Pop Select
      !asm
      !stack2regs
      MOVE.b #1,doedit2
      JMP movecursorlinedown

    Case #IEQUALIFIER_RELATIVEMOUSE + #IEQUALIFIER_LSHIFT   ; $8001: page down
      Pop Select
      !asm
      !stack2regs
      MOVE.l comLong_DisplayLineOffset,D0
      ADD.l comLong_DisplayLine,D0
      ADD.l viewablelines,D0
      CMP.l comLong_TotalLines,D0
      BCS.w gotoline
      MOVE.l comLong_TotalLines,D0
      SUBQ.l #1,D0
      BRA.w gotoline

    Case #IEQUALIFIER_RELATIVEMOUSE + #IEQUALIFIER_CONTROL  ; $8008: jump to bottomline
      Pop Select
      !asm
      !stack2regs
      JMP menu_bottom

    Case #IEQUALIFIER_RELATIVEMOUSE + #IEQUALIFIER_LALT     ; $8010: move current line down
      Pop Select
      Goto movelinedown

    Case #IEQUALIFIER_RELATIVEMOUSE + #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL  ; $8009: select block downwarts
      Pop Select
      Goto selectblockdown

    Case #IEQUALIFIER_RELATIVEMOUSE + #IEQUALIFIER_LSHIFT + #IEQUALIFIER_LALT     ; $800A: select block downwarts
      Pop Select
      Goto selectblockdown

    Case $0000                         ; -- CURSOR DOWN FOR FREEWHEEL
      Pop Select
      !asm
      !stack2regs
      RTS
      ;partly disabled to prevent double event if FreeWheel active
      ;MOVE.l comLong_DisplayLineOffset,d0
      ;ADD.l comLong_DisplayLine,D0
      ;ADD.l wheelstep,d0
      ;JMP gotoline

  End Select

  !asm
  !stack2regs
BRA movecursorlinedown

.selectblockdown:
  !asm
  ; -- set startposition
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BNE.w skip_setstart
    MOVE.w comWord_ColumnsOffset,D0
    ADD.w comWord_Column,D0
    JSR set_blockstart
  skip_setstart:

  !stack2regs
  BSR movecursorlinedown
  MOVE.w comWord_ColumnsOffset,D0
  ADD.w comWord_Column,D0
JMP set_blockend


.movelinedown:
  *currentLine.sourceLine = Peek.l(?comPtr_CurrentSourceLine)
  *prevLine.sourceLine = *currentLine\previousLine
  *nextLine.sourceLine = *currentLine\nextLine
  tmpCurrentLine.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
  tmpTotalLines.l = Peek.l(?comLong_TotalLines)
  If tmpCurrentLine < tmpTotalLines AND *nextLine <> 0 ; if no nextline, we cannot move up
    If cutLine{*currentLine}
      temp_FirstSourceLine.l = ?comPtr_FirstSourceLine
      appendLine{*nextLine, *currentLine, temp_FirstSourceLine}
      ;Poke.l ?comPtr_CurrentSourceLine,*nextLine
      Poke.w ?comWord_SourceChanged,$FFFF

      Pop If : Pop If
      ; check if text is scrolled
      tmpDisplayLine.l = Peek.l(?comLong_DisplayLine)
      tmpDisplayLineOffset.l = Peek.l(?comLong_DisplayLineOffset)
      tmpViewableLines.l = Peek.l(?viewablelines)
      If tmpDisplayLineOffset + tmpViewableLines > tmpTotalLines
        Pop If
        !asm
        !stack2regs
        JSR increase_DisplayLine
        JMP _redraw
      Else
        Pop If
        If tmpViewableLines > (tmpDisplayLine + 1 + Peek.l(?comLong_BoundLinesY))
          Pop If
          !asm
          !stack2regs
          JSR increase_DisplayLine
          JMP _redraw
        End If
        !asm
        !stack2regs
        ADDQ.l #1,comLong_DisplayLineOffset
        JSR source_fullscroll_down
        JSR JL_0_5B60
        JMP _redraw
      EndIf
    Else
      log_Print{"*** cut not successfull ***"}
    EndIf
  Else
    log_Print{"no alt-cursor down available."}
  EndIf
  !asm
  !stack2regs
  ;      JMP jump_historydown      now mapped to cursr right + alt
  RTS

.movecursorlinedown:
  BSR checkedit2
  CNIF #hardfold = 1
    MOVE.l a0,-(a7)
    MOVE.l comPtr_CurrentSourceLine,a0
    CMP.l #";@@1",9(a0)
    BNE 'n1

   'l2
    CMP.l #";@@0",9(a0)
    BNE 'n2
    MOVE.l 4(a0),a4
  BRA 'n1

   'n2
    MOVE.l (a0),d0
    MOVE.l d0,a0
    BNE 'l2

   'n1
    MOVE.l (a7)+,a0
  CELSE
    MOVE.l a0,-(a7)
    MOVE.l comLong_DisplayLineOffset,-(a7)
    MOVE.l comPtr_CurrentSourceLine,a0
    CMP.l #";@@1",9(a0)
    BNE 'l1

   'l2
    MOVE.l (a0),d0
    BEQ 'l1
    MOVE.l d0,a0
    ADDQ.l #1,comLong_DisplayLineOffset
    CMP.l #";@@1",9(a0)
    BEQ 'l1
    CMP.l #";@@0",9(a0)
    BNE 'l2
    MOVE.l a0,comPtr_CurrentSourceLine
    JSR _redraw
    ADDQ.l #4,a7
    MOVE.l (a7)+,a0
  RTS

   'l1
    MOVE.l (a7)+,comLong_DisplayLineOffset
    MOVE.l (a7)+,a0
  CEND
  MOVE.l (A4),D0
  BNE.w JL_0_252E

 setpointer_to_normal:
  JSR set_pointer_normal
RTS


JL_0_252E:
  MOVE.l D0,comPtr_CurrentSourceLine

  JL_0_2534:
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l viewablelines,D0
  CMP.l comLong_TotalLines,D0
  BCC.w JUMP_increase_DisplayLine
    MOVE.l comLong_DisplayLine,D0
    ADDQ.l #1,D0
    ADD.w comLong_BoundLinesY,D0
    CMP.l viewablelines,D0
    BCS.w JUMP_increase_DisplayLine
      ADDQ.l #1,comLong_DisplayLineOffset
      JSR source_fullscroll_down
JMP JL_0_5B60


JUMP_increase_DisplayLine:
JMP increase_DisplayLine


;AJL_0_2566:                          ;cursor_up
.key_cursorup:
  !regs2stack
  !basic
  mqualifier.w = Peek.w(?message_qualifier) AND NOT $200; remove "pressing" flag
  mqualistor.w = Peek.w(?comWord_QualifierStore)
  ;log_Print{"cursorup: " +Hex$(mqualifier)}

  ; convert right qualifiers to left qualifiers to make selctblock smarter
  If (mqualifier AND #IEQUALIFIER_RSHIFT)
    mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
  EndIf
  If (mqualifier AND #IEQUALIFIER_RALT)
    mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
  EndIf

  Select mqualifier
    Case #IEQUALIFIER_RELATIVEMOUSE   ; $8000 (just the key)
      Pop Select
      !asm
      !stack2regs
      MOVE.b #1,doedit2
      JMP movecursorlineup

    Case #IEQUALIFIER_RELATIVEMOUSE + #IEQUALIFIER_LSHIFT   ; $8001
      Pop Select
      !asm
      !stack2regs
      MOVE.l comLong_DisplayLineOffset,D0
      ADD.l comLong_DisplayLine,D0
      CMP.l viewablelines,D0
      BCC.w JL_0_2588
        MOVEQ.l #$00,D0
        BRA.w gotoline
      JL_0_2588:
      SUB.l viewablelines,D0
      BRA.w gotoline

    Case #IEQUALIFIER_RELATIVEMOUSE + #IEQUALIFIER_CONTROL  ; $8008
      Pop Select
      !asm
      !stack2regs
      JMP menu_top

    Case #IEQUALIFIER_RELATIVEMOUSE + #IEQUALIFIER_LALT     ; $8010
      Pop Select
      Goto movelineup

    Case #IEQUALIFIER_RELATIVEMOUSE + #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL ; $8009
      Pop Select
      Goto selectblockup

    Case #IEQUALIFIER_RELATIVEMOUSE + #IEQUALIFIER_LSHIFT + #IEQUALIFIER_LALT    ; $800A: select block upwarts
      Pop Select
      Goto selectblockup


    Case $0000                         ; cursor_up for freewheel
      Pop Select
      !asm
      !stack2regs
      RTS
      ;partly disabled to prevent double event if FreeWheel active  tomsmart1
      ;MOVE.l comLong_DisplayLineOffset,d0
      ;ADD.l comLong_DisplayLine,D0
      ;SUB.l wheelstep,d0
      ;JMP gotoline

  End Select

  !asm
  !stack2regs
;  MOVE.b #1,doedit2
BRA.w movecursorlineup


.selectblockup:
  ; -- set startposition
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BNE.w skip_setstart2
    MOVE.w comWord_ColumnsOffset,D0
    ADD.w comWord_Column,D0
    JSR set_blockstart
  skip_setstart2:

  !stack2regs
  BSR movecursorlineup
  MOVE.w comWord_ColumnsOffset,D0
  ADD.w comWord_Column,D0
JMP set_blockend


.movelineup:
  *currentLine.sourceLine = Peek.l(?comPtr_CurrentSourceLine)
  *prevLine.sourceLine = *currentLine\previousLine
  *nextLine.sourceLine = *currentLine\nextLine
  tmpCurrentLine.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
  If tmpCurrentLine > 0 AND *prevLine <> 0 ; if no previousline, we cannot move up
    If cutLine{*currentLine}
      temp_FirstSourceLine.l = ?comPtr_FirstSourceLine
      appendLine{*prevLine\previousLine, *currentLine, temp_FirstSourceLine}
      ;Poke.l ?comPtr_CurrentSourceLine,*nextLine
      Poke.w ?comWord_SourceChanged,$FFFF

      Pop If : Pop If
      ; check if text is scrolled
      If Peek.w(?comLong_DisplayLineOffset) = 0 OR (Peek.l(?comLong_DisplayLine) > Peek.l(?comLong_BoundLinesY))
        Pop If
        !asm
        !stack2regs
        JSR decrease_DisplayLine
        JMP _redraw
      Else
        Poke.l ?comLong_DisplayLineOffset, Peek.l(?comLong_DisplayLineOffset)-1
        Pop If
        !asm
        !stack2regs
        JSR source_fullscroll_up
        JSR JL_0_5B24
        JMP _redraw
      EndIf
    Else
      log_Print{"*** cut not successfull ***"}
    EndIf
  Else
    log_Print{"no alt-cursor up available."}
  EndIf
  !asm
  !stack2regs
  ;      JMP jump_historyup       now mapped to cursr left + alt
  RTS


.movecursorlineup:
  BSR checkedit2                                  ; check if marked Block shall be deleted

CNIF #hardfold = 1
  MOVE.l a2,-(a7)
  MOVE.l a4,a2
  CMP.l #";@@0",9(a2)
  BNE 'n1
    BSR doreverse
    TST.l foldnum
      BEQ 'n1
 'w1
  CMP.l #";@@1",9(a2)
  BNE 'n2
    MOVE.l (a2),a4
    BRA 'n1
 'n2
 'n22
    MOVE.l 4(a2),d0
    MOVE.l d0,a2
  BNE 'w1
 'n1
    MOVE.l (a7)+,a2

CELSE
  MOVE.l a2,-(a7)                                ; push A2 to Stack
  MOVE.l comPtr_CurrentSourceLine,a4             ; currentLine to A4
  MOVE.l a4,a2                                   ; currentLine to A2

  CMP.l #";@@0",9(a2)
  BNE 'l1
   'l2
    JSR doreverse
    TST.l foldnum
    BEQ 'l1
      MOVE.l 4(a2),d0
      BEQ 'l1
        MOVE.l d0,a2
        SUBQ.l #1,comLong_DisplayLineOffset
        CMP.l #";@@1",9(a2)
        BNE 'l2
          MOVE.l a2,comPtr_CurrentSourceLine
          JSR _redraw
          MOVE.l (a7)+,a2
          RTS
 'l1
  MOVE.l (a7)+,a0                               ; get A2 back from Stack but in A0
 CEND

  MOVE.l $4(A4),D0                              ; get currentLine.PrevLine in D0
  BEQ.b setpointer_to_normal                    ; if null, exit  here

  MOVE.l D0,comPtr_CurrentSourceLine            ; set prevline as new currentline
  MOVE.l comLong_DisplayLineOffset,D0           ; if text is not scrolled just decrease displayLine
  BEQ.w JUMP_decrease_DisplayLine

  MOVE.l comLong_DisplayLine,D0                 ; if displayLine>BoundLines just decrease displayLine
  CMP.w comLong_BoundLinesY,D0
  BHI.w JUMP_decrease_DisplayLine
    SUBQ.l #1,comLong_DisplayLineOffset         ; otherwise scroll whole text one line up
    JSR source_fullscroll_up
    JMP JL_0_5B24

JUMP_decrease_DisplayLine:
JMP decrease_DisplayLine


.menu_markindent:
  LEA $9(A4),A0
  TST.b (A0)
  BEQ.w setpointer_to_normal
  MOVEQ.l #-$01,D0

  JL_0_25CC:
    ADDQ.w #1,D0
  CMPI.b #$20,(A0)+
  BEQ.b JL_0_25CC

  MOVEA.l A4,A1
  MOVE.l comLong_DisplayLineOffset,D1
  ADD.l comLong_DisplayLine,D1
  MOVE.w D1,D2

  JL_0_25E0:
    BEQ.w JL_0_2606

    MOVEA.l $4(A1),A1
    LEA $9(A1),A0
    MOVEQ.l #-$01,D3

    JL_0_25EE:
      ADDQ.w #1,D3
      CMPI.b #$20,(A0)+
    BEQ.b JL_0_25EE

    TST.b -(A0)
    BEQ.w JL_0_2602
      CMP.w D0,D3
      BLT.w JL_0_2606
    JL_0_2602:
    SUBQ.w #1,D1
  BRA.b JL_0_25E0

  JL_0_2606:
  MOVEA.l A4,A1

  JL_0_2608:
  MOVE.l (A1),D3
  BEQ.w JL_0_262E

  MOVEA.l D3,A1
  LEA $9(A1),A0
  MOVEQ.l #-$01,D3

  JL_0_2616:
    ADDQ.w #1,D3
    CMPI.b #$20,(A0)+
    BEQ.b JL_0_2616
      TST.b -(A0)
      BEQ.w JL_0_262A
        CMP.w D0,D3
        BLT.w JL_0_262E
      JL_0_262A:
      ADDQ.w #1,D2
      BRA.b JL_0_2608

  JL_0_262E:
  MOVE.l D1,comLong_BlockStartY
  CLR.w comLong_BlockStartX
  MOVE.l D2,comLong_BlockEndY
  MOVE.w comWord_MaxColumns,D0
  SUBQ.w #1,D0
  MOVE.w D0,comLong_BlockEndX

  ;JSR JL_0_56BA

  JMP _redraw

  JL_0_2654:
RTS


.checkedit2                          ;neweditmode
  CLR.b nodelete
  TST.b new_editmode
  BEQ 'l1
    TST.b doedit2
    BEQ 'l1
      MOVE.b doedit2,d0
      CLR.b doedit2
      CMP.l  #$ffffffff,comLong_BlockEndY
      BEQ 'l1
        !regs2stack
        CMP.b #2,d0                                       ; if doedit2, then cut the marked block
        BNE 'l2
        !regs2stack
        !basic
        log_Print{"delete marked block"}
        !asm
        !stack2regs
                                                                                                                                                                                                                                                        
          JSR arexxfunc_cut
          MOVE.l comLong_BlockStartY,d0
          JSR gotoline
          MOVE.w comLong_BlockStartX,comWord_Column
          TST.b nodisplaybeep
          BNE 'l2
            !basic
            DisplayBeep_ sourceWindow\pedScreen
            !asm
            ;MOVEA.l ptr_pedscreen,A0
            ;MOVEA.l _intuibase,A6
            ;JSR _DisplayBeep(A6)
         'l2
          MOVE.l #$ffffffff,comLong_BlockEndY
          JSR cursor_off
          MOVE.b #1,nodelete
         'l5
          JSR _redraw
          !stack2regs
 'l1
RTS


.menu_insertline:
  JSR alloc_newline
  BEQ.w JUMP_memAlert_CloseSource

  insertline:
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  JSR JL_0_57B6                               ; increase blockendY if paste within a block
  ADDQ.l #1,comLong_TotalLines

  MOVE.l $4(A4),D1                            ; ptr to previousline to D1
  BEQ.w JL_0_268C                             ; if null it must be the firstline
    MOVEA.l D1,A1                             ; ... otherwise insert the new line (A0)
    MOVE.l A0,(A1)
    MOVE.l A1,$4(A0)
    BRA.w JL_0_2692
  JL_0_268C:
    MOVE.l A0,comPtr_FirstSourceLine
  JL_0_2692:
  MOVE.l A4,(A0)
  MOVE.l A0,$4(A4)
  MOVE.l A0,comPtr_CurrentSourceLine

  MOVE.l comLong_DisplayLine,D7
  JSR source_partscroll_up
JMP JL_0_57E0

JUMP_memAlert_CloseSource:                                 ; move it out of the function  tomsmart1
JMP memAlert_CloseSource



.menu_undeleteline:
  MOVEQ.l #$00,D5
  MOVE.w comWord_UndeleteStoreStrLen,D5
  MOVEA.l lineundeletestore,A1
  TST.b (A1)
  BEQ.w JUMP_JL_0_76E8
    MOVE.l comPtr_Temp_TokenString2,-(A7)
    MOVE.l A1,comPtr_Temp_TokenString2
    JSR newSourcelineFromTempString             ; returns ptr in A0
    MOVE.l (A7)+,comPtr_Temp_TokenString2

    BSR.b insertline                            ; insert the newline into source

    JSR print_current_sourceline

    MOVEQ.l #$00,D0
    MOVE.l comLong_DisplayLineOffset,D0
    ADD.l comLong_DisplayLine,D0
    JSR JL_0_57B6                               ; increase BlockEndY if inserted into block
    RTS

  JUMP_JL_0_76E8:
  ;JMP JL_0_76E8                                 ; nothing as RTS
RTS


.menu_deleteline:
  MOVE.w #$FFFF,comWord_SourceChanged

  CMPI.l #$ffffFFFF,comLong_BlockEndY           ; update Blockmark if available
  BEQ.w JL_0_2738

  MOVE.l comLong_DisplayLineOffset,D0           ;
  ADD.l comLong_DisplayLine,D0
  CMP.l comLong_BlockStartY,D0
  BCS.w JL_0_272C
    CMP.l comLong_BlockEndY,D0                    ;
    BHI.w JL_0_2738
      SUBQ.l #1,comLong_BlockEndY                   ;
      MOVE.l comLong_BlockEndY,D0
      CMP.l comLong_BlockStartY,D0
      BCC.w JL_0_2738
        CLR.l comLong_BlockEndY                       ;
  JL_0_272C:
    SUBQ.l #1,comLong_BlockStartY                 ;
    SUBQ.l #1,comLong_BlockEndY                   ;
  JL_0_2738:
                                                ; ----- delete current line in A4
  MOVE.l (A4),D7                                ; pointer to currentLine.nextline to D7
  BEQ.w JL_0_2776                               ; if no nextline jump down

  SUBQ.l #1,comLong_TotalLines                  ; reduce TotalLines
  MOVE.l $4(A4),D6                              ; pointer to currentLine.prevLine to D6
  JSR StoreCurrentSourceLine                    ; store current source line

  MOVEA.l D7,A1                                 ; Pointer to currentLine.nextline To A1
  MOVE.l D6,$4(A1)                              ; pointer to currentLine.prevLine to nextLine.prevLine
  BNE.w JL_0_2760                               ; if no prevLine
    MOVE.l A1,comPtr_FirstSourceLine            ;   set nextline as new FirstSourceLine
    BRA.w JL_0_2764                             ; else
  JL_0_2760:
    MOVEA.l D6,A0                               ;   pointer to currentLine.prevLine to A0
    MOVE.l D7,(A0)                              ;   set currentLine.nextLine to prevLine.nextLine
  JL_0_2764:

  MOVE.l D7,comPtr_CurrentSourceLine            ; set currentLine.nextLine as new CurrentSourceLine

  MOVE.l comLong_DisplayLine,D7                 ; scroll down
  JSR source_partscroll_down
JMP JL_0_5B60


JL_0_2776:
  MOVE.l $4(A4),D6                              ; pointer to currentLine.prevLine to D6
  BEQ.w JL_0_27C2                               ; if not available jump down
  SUBQ.l #1,comLong_TotalLines
  JSR StoreCurrentSourceLine
  MOVEA.l D6,A0
  MOVE.l A0,comPtr_CurrentSourceLine
  MOVE.l A0,comPtr_LastSourceLine
  CLR.l (A0)
  MOVE.l comLong_DisplayLineOffset,D0
  BEQ.w JL_0_27B6
    SUBQ.l #1,comLong_DisplayLineOffset
    MOVE.l comLong_DisplayLine,D7
    JSR source_partscroll_down
    JSR source_fullscroll_up
    JMP JL_0_5B24
  JL_0_27B6:

  MOVE.l comLong_DisplayLine,D7
  JSR source_partscroll_down
JMP decrease_DisplayLine


JL_0_27C2:
   JSR StoreCurrentSourceLine                   ; store currentLine
JMP JL_0_5B00



.menu_joinline:                      ;join line
!regs2stack
!basic
log_Print{"joinline"}
!asm
!stack2regs
  MOVE.l (A4),D0
  BEQ.w setpointer_to_normal
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVEA.l D0,A5
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVE.w comWord_MaxColumns,D0

  JL_0_27E6:
  SUBQ.w #1,D0
  BMI.w JL_0_27F4
    CMPI.b #$20,$0(A2,D0.W)
    BEQ.b JL_0_27E6
  JL_0_27F4:

  ADDQ.w #1,D0
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w JL_0_2880
  MOVE.l comLong_DisplayLineOffset,D1
  ADD.l comLong_DisplayLine,D1
  CMP.l comLong_BlockEndY,D1
  BCC.w JL_0_2880
  ADDQ.l #1,D1
  CMP.l comLong_BlockStartY,D1
  BEQ.w JL_0_282C
  BCS.w JL_0_2874
  CMP.l comLong_BlockEndY,D1
  BEQ.w JL_0_283E
  BRA.w JL_0_287A

  JL_0_282C:
  CMP.l comLong_BlockEndY,D1
  BEQ.w JL_0_2854
  ADD.w D0,comLong_BlockStartX
  BRA.w JL_0_2870

  JL_0_283E:
  CMP.l comLong_BlockStartY,D1
  BEQ.w JL_0_2854
    ADD.w D0,comLong_BlockEndX
    JSR JL_0_7A14
    BRA.w JL_0_287A
  JL_0_2854:
  MOVE.w comLong_BlockEndX,D3
  SUB.w comLong_BlockStartX,D3
  MOVE.w comLong_BlockStartX,D2
  ADD.w D0,D2
  MOVE.w D2,comLong_BlockStartX
  ADD.w D3,D2
  MOVE.w D2,comLong_BlockEndX
  JL_0_2870:
  JSR JL_0_7A14

  JL_0_2874:
  SUBQ.l #1,comLong_BlockStartY

  JL_0_287A:
  SUBQ.l #1,comLong_BlockEndY

  JL_0_2880:
  MOVEA.l comPtr_Temp_TokenString2,A0
  LEA $0(A0,D0.W),A1

  JL_0_2888:
    SUBQ.w #1,D0
    BMI.w JL_0_2896
    MOVE.b $0(A2,D0.W),$0(A0,D0.W)
  BRA.b JL_0_2888

  JL_0_2896:
  LEA $9(A5),A0

 'l2
    CMP.b #32,(a0)                 ;join without space
    BNE 'l1
      ADDQ.l #1,a0
  BRA 'l2
 'l1

  MOVE.w comWord_DoTokenize,D0
  BNE.w JL_0_28AE

  JL_0_28A4:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_28A4
  SUBQ.w #1,A1
  BRA.w JL_0_28B2

  JL_0_28AE:
  JSR detokenize_line

  JL_0_28B2:
    CMPA.l comPtr_Temp_TokenString3,A1
    BCC.w JL_0_28C0
      MOVE.b #$20,(A1)+
  BRA.b JL_0_28B2
  JL_0_28C0:

  MOVEA.l comPtr_Temp_TokenString2,A2
  JSR parse_line
  JSR JL_0_55AA
  MOVEA.l (A4),A1
  MOVE.l (A1),D0
  BEQ.w JL_0_28E0
    MOVEA.l D0,A0
    MOVE.l A0,(A4)
    MOVE.l A4,$4(A0)
    BRA.w JL_0_28E8
  JL_0_28E0:
    MOVE.l A4,comPtr_LastSourceLine
    CLR.l (A4)
  JL_0_28E8:

  MOVEQ.l #$00,D0
  ADD.b $8(A1),D0
  ;MOVEA.l _execbase,A6
  ;ST comWord__AL_0_86C0
  !newfree
  SUBQ.l #1,comLong_TotalLines
  !regs2stack
  !basic
  log_Print{"joinline end"}
  !asm
  !stack2regs
JMP _redraw


JL_0_2906:
  TST.b new_editmode
  BNE AJL_0_2A82b

 JL_0_2906b
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVE.w comWord_ColumnsOffset,D0
  ADD.w comWord_Column,D0
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w JL_0_29BC
  MOVE.l comLong_DisplayLineOffset,D2
  ADD.l comLong_DisplayLine,D2
  CMP.l comLong_BlockEndY,D2
  BHI.w JL_0_29BC
  BEQ.w JL_0_2962
  CMP.l comLong_BlockStartY,D2
   BCS.w JL_0_29B0
   BNE.w JL_0_29B6
  CMP.l comLong_BlockEndY,D2
   BEQ.w JL_0_2982
  CMP.w comLong_BlockStartX,D0
   BHI.w JL_0_29B6
  MOVE.w comLong_BlockStartX,D2
  SUB.w D0,D2
  MOVE.w D2,comLong_BlockStartX
BRA.w JL_0_29B0

 JL_0_2962:
  CMP.l comLong_BlockStartY,D2
   BEQ.w JL_0_2982
  CMP.w comLong_BlockEndX,D0
   BHI.w JL_0_29BC

 JL_0_2972:
  MOVE.w comLong_BlockEndX,D2
  SUB.w D0,D2
  MOVE.w D2,comLong_BlockEndX
BRA.w JL_0_29B6

 JL_0_2982:
  CMP.w comLong_BlockEndX,D0
   BHI.w JL_0_29BC
  CMP.w comLong_BlockStartX,D0
   BHI.b JL_0_2972
  MOVE.w comLong_BlockEndX,D3
  SUB.w comLong_BlockStartX,D3
  MOVE.w comLong_BlockStartX,D2
  SUB.w D0,D2
  MOVE.w D2,comLong_BlockStartX
  ADD.w D3,D2
  MOVE.w D2,comLong_BlockEndX
   JSR JL_0_7A14

 JL_0_29B0:
  ADDQ.l #1,comLong_BlockStartY

 JL_0_29B6:
  ADDQ.l #1,comLong_BlockEndY

 JL_0_29BC:
  MOVEA.l comPtr_Temp_TokenString2,A0
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  TST.b new_editmode
  BEQ JL_0_29C8
  CLR.w comWord_Column
  MOVE.l d0,-(a7)
  MOVEQ #0,d0

 'l2
  CMP.b #$20,0(a2,d0)
  BNE 'l1
  ADDQ #1,d0
  MOVE.b #32,(a0)+                   ;split line to column
  CMP.l #MAX_Columns,d0
  BGE 'l3
BRA 'l2

 'l1
  TST.w comWord_ColumnsOffset
    BEQ 'ld
    CLR.w comWord_ColumnsOffset
    CMP.w visiblecolumns,d0
    BLE 'ld
    SUB.w visiblecolumns,d0
   MOVE.w visiblecolumns,comWord_ColumnsOffset
    CMP.w visiblecolumns,d0
    BLE 'ld
    SUB.w visiblecolumns,d0
    MOVE.l d0,-(a7)
    MOVE.w comWord_ColumnsOffset,d0
    ADD.w visiblecolumns,d0
    MOVE.w d0,comWord_ColumnsOffset
    MOVE.l (a7)+,d0

 'ld
    MOVE.w d0,comWord_Column

 'l3
  MOVE.l (a7)+,d0

 JL_0_29C8:
  MOVE.b $0(A2,D0.W),(A0)+
  MOVE.b #$20,$0(A2,D0.W)
  ADDQ.w #1,D0
  CMP.w comWord_MaxColumns,D0
   BCS.b JL_0_29C8

 JL_0_29DA:
  CMPA.l comPtr_Temp_TokenString3,A0
   BCC.w JL_0_29E8
  MOVE.b #$20,(A0)+
BRA.b JL_0_29DA

 JL_0_29E8:
  JSR parse_line
  JSR JL_0_55AA
  MOVEA.l comPtr_Temp_TokenString2,A2
  JSR parse_line
  MOVE.l D5,D0
  ADDI.w #$9,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  JSR AllocPoolMem
  MOVEA.l D0,A0
  MOVE.b D5,$8(A0)
  LEA $9(A0),A0
  MOVEA.l comPtr_Temp_TokenString1,A1

  JL_0_2A16:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_2A16

  MOVEA.l D0,A0
  MOVE.l A4,$4(A0)
  MOVE.l (A4),D1
  BEQ.w JL_0_2A32
    MOVEA.l D1,A1
    MOVE.l A0,$4(A1)
    MOVE.l A1,(A0)
    BRA.w JL_0_2A3A
  JL_0_2A32:
    MOVE.l A0,comPtr_LastSourceLine
    CLR.l (A0)
  JL_0_2A3A:

  MOVE.l A0,(A4)
  ADDQ.l #1,comLong_TotalLines
  TST.b new_editmode
  BNE 'l1
    CLR.w comWord_Column
 'l1
  BSR movecursorlinedown
JMP _redraw


JL_0_2A46:
  TST.w auto_indent
  BEQ.w JL_0_2A7A

  MOVEM.l D0/A0,-(A7)
  MOVEA.l comPtr_CurrentSourceLine,A0
  LEA $9(A0),A0
  MOVEQ.l #-$01,D1

 JL_0_2A60:
  ADDQ.w #1,D1
  MOVE.b (A0)+,D0
   BEQ.w JL_0_2A6E
  CMP.b #$20,D0
   BEQ.b JL_0_2A60

 JL_0_2A6E:
  MOVEM.l (A7)+,D0/A0
  MOVE.w D1,comWord_Column
RTS


JL_0_2A7A:
  CLR.w comWord_Column
RTS


.insertreturn:                       ;return_key
  MOVE.l comPtr_CurrentSourceLine,a4
  MOVE.w comWord_QualifierStore,D0
  ANDI.w #$3,D0
  BNE.w JL_0_2906

  TST.b new_editmode
  BNE JL_0_2906b

  AJL_0_2A82b
  JSR alloc_newline
  BEQ.w JUMP_memAlert_CloseSource
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  ADDQ.w #1,D0
  JSR JL_0_57B6
  ADDQ.l #1,comLong_TotalLines
  BSR.b JL_0_2A46
  ;MOVE.l comPtr_CurrentSourceLine,d1
  MOVE.l (A4),D1
  BNE.w JL_0_2AD0
    MOVE.l A0,(A4)
    MOVE.l A4,$4(A0)
    MOVE.l A0,comPtr_LastSourceLine
    BRA.w JL_0_2ADE
  JL_0_2AD0:
    MOVEA.l D1,A1
    MOVE.l A0,$4(A1)
    MOVE.l A0,(A4)
    MOVE.l A1,(A0)
    MOVE.l A4,$4(A0)
  JL_0_2ADE:

  MOVE.l A0,comPtr_CurrentSourceLine
  MOVE.w comWord_ColumnsOffset,D0
  BEQ.w JL_0_2AF6
  CLR.w comWord_ColumnsOffset
  JSR JL_0_7962

  JL_0_2AF6:
  JSR update_horizscroller
  MOVE.l comLong_DisplayLine,D0
  ADDQ.w #1,D0
  ADD.w comLong_BoundLinesY,D0
  CMP.l viewablelines,D0
  BCS.w JL_0_2B6C
  ADDQ.l #1,comLong_DisplayLineOffset
  MOVE.l viewablelines,-(A7)
  MOVE.l comLong_DisplayLine,D0
  ADDQ.l #1,D0
  MOVE.l D0,viewablelines
  MOVE.w ypos_statusarea,-(A7)
;  MULU comWord__AL_0_86CC,D0
;  MOVE.w D0,ypos_statusarea
  JSR source_fullscroll_down
  MOVE.w (A7)+,ypos_statusarea
  MOVE.l (A7)+,viewablelines
  MOVEM.w D0-D1,-(A7)
  MOVEQ.l #$00,D0
  MOVE.l comLong_DisplayLine,D1
  ADD.l comLong_DisplayLineOffset,D1
  JSR JL_0_3154
  MOVEM.w (A7)+,D0-D1

  TST.b comByte_StateBlockMark
  BNE.w JL_0_2B68
    RTS
  JL_0_2B68:
JMP _redraw

JL_0_2B6C:
  MOVE.l comLong_DisplayLine,D7
  ADDQ.w #1,D7
  JSR source_partscroll_up
  JSR JL_0_2534
  MOVEM.w D0-D1,-(A7)
  MOVEQ.l #$00,D0
  MOVE.l comLong_DisplayLine,D1
  ADD.l comLong_DisplayLineOffset,D1
  JSR JL_0_3154
  MOVEM.w (A7)+,D0-D1
  TST.b comByte_StateBlockMark
  BNE.w JL_0_2BA0
RTS

JL_0_2BA0:
JMP JL_0_7962


.menu_top:
  JSR jump_addhistory
  MOVEQ.l #$00,D0
BRA.w sub_gotoline


.menu_bottom:
  JSR jump_addhistory
  MOVE.l comLong_TotalLines,D0
  SUBQ.l #1,D0
BRA.w sub_gotoline


.event_vertscroller:
  MOVE.l viewablelines,D0
  CMP.l comLong_TotalLines,D0
  BCS.w JL_0_2BC2
    RTS
  JL_0_2BC2:

  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  MOVE.l D0,comLong_LinePosStartX
  JSR switch_cursordisplay

Macro mul48f
  _floattemp.f = (`1)
  _floattemp = _floattemp * (`2)
  _floattemp = _floattemp / (`3)
  `4 = Int(_floattemp+.5)
End Macro

  JL_0_2BD4:
  !basic
  #max_slider_res = $7FFF
  If *vertiprop.Gadget
    GetAttr_ #PGA_Top    ,*vertiprop,&slider_top.l
    totallines.l = Peek.l(?comLong_TotalLines)
    If totallines >= #max_slider_res
      !mul48f{slider_top,totallines,#max_slider_res,realline.l}
    Else
      realline = slider_top
    End If
    realline + Peek.l(?comLong_DisplayLine)
  Else
    realline = 0
  End If
  GetD0 realline
  !asm

  CMP.l comLong_LinePosStartX,D0
  BEQ.w JL_0_2C02
    MOVE.l D0,comLong_LinePosStartX
    JSR switch_cursordisplay
    MOVE.l comLong_LinePosStartX,D0
    JSR gotoline
    JSR switch_cursordisplay
    JSR update_statusarea          ;JSR linetext

  JL_0_2C02:
  JSR check_events                 ; check ob gadget noch gedrueckt
  TST.l D7
  BEQ.b JL_0_2BD4

  JSR switch_cursordisplay

  !basic
  If *vertiprop.Gadget
    GetAttr_ #PGA_Top    ,*vertiprop,&slider_top.l
    totallines.l = Peek.l(?comLong_TotalLines)
    If totallines>=#max_slider_res
      !mul48f{slider_top,totallines,#max_slider_res,realline.l}
    Else
      realline = slider_top
    End If
    realline + Peek.l(?comLong_DisplayLine)
  Else
    realline = 0
  End If
  GetD0 realline
  !asm
BRA.w gotoline



.sub_gotoline:                          ; d0: linenumber
  MOVE.w #$FFFF,-(A7)
  CLR.w comWord_Column
BRA.w JL_0_2C2E


.gotoline:                      ; d0: linenumber
  CLR.w -(A7)
  TST.l d0
  BGE JL_0_2C2E
    MOVEQ #0,d0
  JL_0_2C2E:

  CMP.l comLong_TotalLines,d0
  BLE 'l10
    MOVE.l comLong_TotalLines,d0
    SUBQ.l #1,d0
 'l10
  MOVE.l comLong_DisplayLineOffset,D1
  MOVE.l D1,-(A7)
  ADD.l comLong_DisplayLine,D1
  CMP.l D1,D0
  BEQ.w JL_0_2C58
  BCC.w JL_0_2C50

  JL_0_2C42:
    SUBQ.l #1,D1
    MOVEA.l $4(A4),A4
    CMP.l D1,D0                ; move line pointer from last line up until gotoline in d0 reached
  BNE.b JL_0_2C42

  BRA.w JL_0_2C58

  JL_0_2C58b
  MOVE.l comLong_TotalLines,d0
  SUBQ.l #1,d0
  MOVE.l d0,d1
  BRA JL_0_2C58

  JL_0_2C50:
    ADDQ.l #1,D1
    TST.l (a4)
    BEQ JL_0_2C58b
      MOVEA.l (A4),A4
  CMP.l D1,D0
  BNE.b JL_0_2C50

  JL_0_2C58:
  MOVE.l A4,comPtr_CurrentSourceLine
  TST.b newsyntax
  BEQ 'l10
    JSR syntax_new1
 'l10

  MOVE.w comLong_BoundLinesY,D1
  CLR.b newsyntax
  MOVE.l D0,D2
  SUB.l D1,D0
  BPL.w JL_0_2C7C

  JL_0_2C6C:
  CLR.l comLong_DisplayLineOffset
  MOVE.w D2,comLong_DisplayLine+2
  BRA.w JL_0_2CBA

  JL_0_2C7C:
  MOVE.l comLong_TotalLines,D3
  CMP.l viewablelines,D3
  BLS.b JL_0_2C6C
  SUB.l viewablelines,D3
  ADD.w comLong_BoundLinesY,D3
  CMP.l D3,D2
  BCS.w JL_0_2CAE
  SUB.w comLong_BoundLinesY,D3
  MOVE.l D3,comLong_DisplayLineOffset
  SUB.l D3,D2
  MOVE.w D2,comLong_DisplayLine+2
  BRA.w JL_0_2CBA

  JL_0_2CAE:
  MOVE.w D1,comLong_DisplayLine+2
  MOVE.l D0,comLong_DisplayLineOffset

  JL_0_2CBA:
  JSR update_TextBufferOffset

  MOVE.l (A7)+,D1
  CMP.l comLong_DisplayLineOffset,D1
  BEQ.w JL_0_2CCC
    JSR _redraw
  JL_0_2CCC:

  TST.w (A7)+
  BNE.w JUMP_update_horizscroller
    RTS
  JUMP_update_horizscroller:
JMP update_horizscroller


; -- handle compilermenu
; menuids
; $5A: Leerzeile im Menu
; $50: Compile & Run
; $5b: Save & Create Exec
; $5c: Save & Compile & Run
; $5d: Debug / Runerrors On 10*slower Code
; $5e: Create Executable absolut Smallest

; $57: calculator
; $58: reload all libs
; $59: open sourcebrowser

.call_compilermenuitem:              ; (Menuitem in D6)
  CMP.l #$5A,D6                      ; empty menuitem number
  BNE.w 'noemptymenu
    RTS
 'noemptymenu                        ; check For calculator  tomsmart1 2012 03

  CMP.l ##MENU_CALCULATOR,D6         ; replaced hardcode ID with the constants  tomsmart1
  BNE 'nocalculator                  ; no check next
    JSR set_pointer_busy
    JSR save_tempprefs                 ; save data to prevent crashes if the calculation routine is called an it coms back to Ped
    !basic
      LockAllOpenWZWin{}
      Gosub open_calculator
      UnlockAllOpenWZWin{}
    !asm
    JSR read_tempprefs                 ; restore data to prevent crashes if the calculation routine is called an it comes back to Ped
    JSR set_pointer_normal
    !setregsformenuexit
    RTS
 'nocalculator

  CMP.l ##MENU_DEFINITIONBROWSER,D6  ; added because Newtype window have no need to jump to the compiler tomsmart1
  BNE 'nodefinitionbrowser
    !basic
    Gosub open_newtype
    !asm
    !setregsformenuexit
    RTS
 'nodefinitionbrowser

  CMP.l ##MENU_SETCLIARGS,D6         ; added because CLIArgs window have no need to jump to the compiler tomsmart1
  BNE 'nocliarguments
    !basic
    Gosub set_pointer_busy_bas
    LockAllOpenWZWin{}
    Gosub open_cliarguments
    UnlockAllOpenWZWin{}
    Gosub set_pointer_normal_bas
    !asm
    !setregsformenuexit
    RTS
 'nocliarguments

  CMP.l ##MENU_SOURCEBROWSER,D6      ; moved because no jump to compiler needed for the labelbrowser  tomsmart1 ; was 9  ; replaced with the constant  tomsmart1
  BNE 'nosourcebrowser
    !basic
    Gosub open_labelwindow             ; Open Sourcebrowser
    !asm
    !setregsformenuexit
    RTS
 'nosourcebrowser

  CMP.l ##MENU_COMPILERSETTINGS,D6   ; check if compiler settings ; was $3  ; replaced with the constant  tomsmart1
  BNE 'nocomsettings
    !basic
    Gosub set_pointer_busy_bas
    LockAllOpenWZWin{}
    Gosub menu_compilersettings
    If WZ_CheckOpen{"WIN_NEWTYPE"}
      Use Window WZID("WIN_NEWTYPE")
      Gosub newtype_updatelist
    End If
    UnlockAllOpenWZWin{}
    !asm
    JSR update_debuggertoggle
    !regs2stack
    JSR save_tempprefs
    !stack2regs
    JSR set_pointer_normal
    !setregsformenuexit
    RTS
 'nocomsettings

  CMP.l ##MENU_COMPILERUN,D6
   BEQ 'setinfofordebug
  CMP.l ##MENU_RUN,D6
   BNE 'noinfofordebugneeded

 'setinfofordebug
  !basic
    TEDSetLabelList {?comPtr_LabelList}
    TEDSetLabelCount{?comWord_LabelCounter}
  !asm

 'noinfofordebugneeded
  ; create minimized exe moved to the compiler  tomsmart1
  CMP.l ##MENU_SAVECREATEEXE,d6                            ; Save & Create executable  ; was $b  ; replaced with the constant  tomsmart1
  BNE 'nosavecreateexe
    JSR saverout
    MOVEQ.l ##MENU_SAVECREATEEXE,d6                        ; was $b  ; replaced with the constant  tomsmart1
 'nosavecreateexe

  CMP.l ##MENU_SAVECOMPILERUN,d6                           ; Save & Compile & run    ; was $c  ; replaced with the constant  tomsmart1
  BNE 'nosavecompilerun
    JSR menu_save
    !basic
    Delay_(50)
    !asm
    MOVEQ.l ##MENU_COMPILERUN,d6                           ; was $0  ; replaced with the constant  tomsmart1
 'nosavecompilerun

;  CMP.l ##MENU_CREATERESIDENT,D6                          ; was $4  ; replaced with the constant  tomsmart1
;  BNE no_createresident
;  !regs2stack
;  !stack2regs
; 'no_createresident

  ; set infos for Compiler to run functions
  MOVE.l comFunc_CallMenuEntry,D0
  BEQ 'exit                                                ; test if we have a compiler

  MOVE.l D6,-(A7)                                          ; store menu num

  !basic
  PutReg D6,CompileMenuCallID.l                           ; save it to basic for the open of the compile status win
  log_Print{"call compiler with function [" + Str$(CompileMenuCallID)+"]"}
  LockAllOpenWZWin{}
  Gosub Open_CompileStatus_Window                         ; open Compile status window if we need it
  ;Gosub set_CurrentDir
  !asm
  JSR set_CurrentDir
  SUBI.l ##MENU_COMPILERUN,D6                              ; was $50  ; replaced with the constant  tomsmart1  ; compiler only accept ID 0-F so we have to subtract $50 from the menu ID
  MOVE.l comFunc_CallMenuEntry,a0
  MOVEA.l comPtr_FirstSourceLine,A5
  MOVE.l comLong_TotalLines,D7
  JSR (A0)                                                 ; call compilerfunction for the menuentry

  JSR update_debuggertoggle                                ; set the state to the commenu "Create Debug Code"

  !basic
  MOVEM.l a0/d0/d1,-(a7)
  previoussearch_instruction$ = "|"
  Gosub update_versiongadgets
  Gosub Close_CompileStatus_Window                         ; close compile status window if it is open
  UnlockAllOpenWZWin{}
  log_Print{"compiler finished"}
  MOVEM.l (a7)+,d0/d1/a0
  !asm

  MOVE.l (A7)+,D6                                          ; restore menu num
  CMP.l ##MENU_RELOAD_USERLIBS,D6                          ; reload all libs  ; was $8   ; replaced with the constant  tomsmart1
  BNE 'compileerrorcheck
    !regs2stack
    JSR read_tempprefs
    !stack2regs
 'compileerrorcheck                                        ; after compiler function (compiling) check and update

  MOVE.l D0,-(A7)
  JSR update_title_sourcewindow
  MOVE.l (A7)+,D0

  MOVEA.l comPtr_CurrentSourceLine,A4
  CMP.l #-$2,D0
  BEQ.w JUMP_redraw
  CMP.l #-$1,D0                                            ; test in no error happens during compiling
  BNE.w syntax_setcursor                                  ; no we have a error show it

 'exit
 !setregsformenuexit
RTS


JUMP_JL_0_5054
JMP JL_0_5054


.syntax_setcursor                                          ; show errormessage and jump to the sourceline after compiling
   MOVE.w #$FFFF,-(A7)                                     ;syntax set cursor
   MOVE.b #1,newsyntax
 BRA.w JL_0_2C2E                                           ; jump to the line with the error

.syntax_new1
  MOVE.l d0,-(a7)
  MOVEA.l comPtr_Temp_TokenString1,A1

  MOVE.l a4,a0
  LEA 9(a0),a0
  MOVEQ #-1,d1

 syn1:
  TST.w comWord_DoTokenize
  BEQ.w JUMP_JL_0_5054

  CMP.l a0,a5
  BEQ  JL_0_5050b
  ADDQ.l #1,d1
  MOVEQ.l #$00,D0
  MOVE.b (A0)+,D0
  BEQ.w JL_0_5050b
  BMI.w JL_0_5040b
  MOVE.b D0,(A1)+
  BNE.b syn1

 JL_0_5040b:
  LSL.w #8,D0
  MOVE.b (A0)+,D0
  MOVE.l d1,-(a7)
  JSR token_to_ascii
  MOVE.l (a7)+,d1

 JL_0_5048b:
  ADDQ.l #1,d1
  MOVE.b (A3)+,(A1)+
  BNE.b JL_0_5048b
  SUBQ.w #1,A1
  SUBQ.l #1,d1
BRA.b syn1

 JL_0_5050b:
  SUBQ.l #1,d1
  CMP.w #MAX_Columns,d1
  BGE 'l1
  CMP.l #0,d1
  BGE 'l1
  MOVEQ #0,d1

 'l1
  MOVE.w d1,comWord_Column
  MOVE.l (a7)+,d0
RTS


.event_shortcut:
  CMP.l ##MENU_COMPILERUN,D6                                  ;was $50  ; replaced with the constant  tomsmart1
   BLT.w handle_menucalls
  CMP.l ##MENU_NEW,D6                                         ;was $65  ; replaced with the constant  tomsmart1
   BGE.w handle_menucalls
BRA.w call_compilermenuitem


.handle_menucalls:
  CMP.l ##MENU_CUSTOMEDIT-1,D6       ; ped menuitem  ; was $258  ; replaced with the constant  tomsmart1
   BLE.w call_ownmenuitem
  CMP.l #$f00,D6                     ; compiler menuitem
   BGE call_ownmenuitem
JMP call_pluginmenuentry             ;plugin menuitem


.call_ownmenuitem:
  ; -- check for subitem with templates, base-id $200
  MOVE.l d6,-(a7)
  !basic
  MOVE.l (a7)+,D0
  menuentry.l = PutD0
  If menuentry >= #MENU_TEMPLATE AND menuentry<#MENU_TEMPLATE+#MAX_MENUTEMPLATES
    Gosub load_template
    Pop If
    !asm
    JMP update_vertscroller
  EndIf
  !asm

  LEA menutable,A0                          ; get first entry of the menutabel

 JL_0_2DA2:
    MOVE.l (A0)+,D0                         ; get menuID form the table
    CMP.l #$FFFFFFFF,D0                     ; test if we reach the end of the menutable
     BEQ.w exit_call_ownmenuitem            ; yes exit ownmenuitem
    CMP.l D6,D0                             ; compare  IDs
     BEQ.w JL_0_2DB8                        ; yes the same
    ADDQ.w #8,A0                            ; no add 2 Longs to get to the next ID
BRA.b JL_0_2DA2                             ; repeat

 JL_0_2DB8:                                 ; yes same id
  MOVE.l (A0)+,-(A7)                        ; get and save refresh info
  MOVEA.l (A0)+,A0                          ; get address of the menufunction

 L_0_2DBC:
  JSR (A0)                                  ;call the menupoint
  MOVE.l (A7)+,D0                           ; reload refresh info

  TST.l D0                                  ; test refresh info
   BNE.w JUMP_update_vertscroller           ; refresh is needed

 exit_call_ownmenuitem:                     ; exit end
RTS

JUMP_update_vertscroller:
JMP update_vertscroller


JL_0_2Dca8:
  JSR calc_SourceWindowDimensions
  JSR clear_sourcewindow
  JSR update_labelstuff

  JSR update_scroller

  JSR analyze_loadedsource
  TST.b refreshonstore
  BNE 'l2
    TST.b AL_0_4734
    BNE.w JL_0_2E0E
      JSR draw_statusarea
      JSR _redraw
 'l2
  !basic
  Gosub set_CurrentDir
  !asm
  JL_0_2E0E:
  MOVEA.l comPtr_CurrentSourceLine,A4
  CLR.w comWord_SourceModifiedFlag
RTS


.load_template:
  mcounter.l = menuentry-#MENU_TEMPLATE
  ResetList templates()
  For n.l = 0 To mcounter - 1
    NextItem templates()
  Next
  If NextItem(templates())
    templatefilename$ = templates()\filename
    GetD0 &templatefilename$
    !asm
    MOVE.l d0,-(a7)
    JSR menu_opennew
    MOVE.l (a7)+,d7
    JSR load_source
  Else
    templatefilename$=!TRANS{"unknown"}
    MOVE.l d0,-(a7)
    GetD0 &templatefilename$
    !asm
    JSR menu_opennew
     MOVE.l (a7)+,d0 ; clean stack
  EndIf
Return


.menu_openload:
  MOVE.w #0,loadAsNew
BRA JL223


.menu_opennew:                       ;open new func
  MOVE.w #1,loadAsNew

  JL223:
  !regs2stack
  !basic
  log_Print{"menu_open called"}
  !asm
  !stack2regs

  JSR storeline
  MOVE.l d0,-(a7)
  MOVE.l comFunc_ReadXtraFile,d0
  BEQ 'l10
    MOVE.l d0,a0
    CLR.l d0
    JSR (a0)
 'l10
  MOVE.l (a7)+,d0

  MOVE.l #comDef_XtraEnd-comLongLong_XtraBegin+10,d0
  !newalloc
  TST.l D0
  BEQ.w error_xtramem
    TST.l AL_0_84B2
    BNE.w JL_0_2E70

    MOVEM.l D0/A6,-(A7)
    JSR clear_sourcebuffer;JL_0_6B7C
    CLR.w comWord_SourceChanged
    MOVEM.l (A7)+,D0/A6
    MOVE.l D0,actualfile
    MOVE.l D0,AL_0_84B2
    MOVE.l D0,loadedfilesbase
    MOVEA.l D0,A0
    CLR.l $4(A0)
    CLR.l (A0)
    RTS
  error_xtramem:
JMP display_memoryalert


JL_0_2E70:
  JSR StoreXtraData
  CLR.w comWord_SourceChanged
  MOVEA.l D0,A0
  MOVEA.l actualfile,A1
  MOVE.l D0,actualfile
  TST.l (A1)
  BEQ.w JL_0_2EA6
    MOVEA.l (A1),A2
    MOVE.l D0,(A1)
    MOVE.l A1,$4(A0)
    MOVE.l A2,(A0)
    MOVE.l A0,$4(A2)
    JSR clear_sourcebuffer
    JSR JL_0_2Dca8
    RTS
  JL_0_2EA6:
    MOVE.l D0,AL_0_84B2
    MOVE.l A1,$4(A0)
    MOVE.l A0,(A1)
    CLR.l (A0)

    JSR clear_sourcebuffer
    JSR JL_0_2Dca8

    TST.w loadAsNew
    BNE 'no
      !regs2stack
      JSR menu_load
      JSR StoreXtraData
      JSR update_vertscroller
      !stack2regs
   'no
RTS


.StoreXtraData:                      ;copy view data
  ; this function is called after a succesfull load of a sourcecode and befor and after a switch of the sourcecode  tomsmart1
  MOVEM.l D0/A0-A1,-(A7)
  !basic
  MOVE.l LabelList_FirstVisableItemNumber@(a5),comLong_Label1VisableItem      ; same as Poke
  MOVE.l comLong_Label1VisableItem,comLong_Label1VisableItemStore             ; to update both for a unified LabelList restore routine that work by load and switch of a Sourcecode  tomsmart1
  !asm
  MOVEA.l actualfile,A0
  ADDQ.l #8,A0                       ; jump over list node header to xtra data
  LEA comLongLong_XtraBegin,A1
  MOVE.l #comDef_XtraEnd-comLongLong_XtraBegin,d0; #$504+72,D0
  SUBQ.w #1,D0

 'copyloop
    MOVE.b (A1)+,(A0)+
  DBF D0,'copyloop

  MOVEM.l (A7)+,D0/A0-A1
RTS


.GetXtraData:
  ; zurueckholen der xtra-settings nach sourcewechsel
  ADDQ.l #8,A0
  LEA comLongLong_XtraBegin,A1
  MOVE.l #comDef_XtraEnd-comLongLong_XtraBegin ,D0  ;MOVE.l #$504+72,D0
  SUBQ.w #1,D0

 'copyloop:
    MOVE.b (A0)+,(A1)+
  DBF D0,'copyloop

  !basic
  ; restore windows
  Gosub RestoreLabelAndNewtypeWin
  !asm
  MOVEA.l comPtr_CurrentSourceLine,A4
RTS


.selectfile:
  MOVE.l A0,-(A7)
  BSR.b StoreXtraData
  JSR save_tempprefs
  MOVEA.l (A7)+,A0

  MOVE.l A0,actualfile
  BSR.b GetXtraData

  JSR JL_0_2Dca8

  JSR read_tempprefs
  JSR draw_statusarea              ;JSR linetext
  JSR update_horizscroller
RTS


.menu_previousfile:
  BSR.b StoreXtraData
  JSR save_tempprefs
  MOVEA.l actualfile,A0
  TST.l $4(A0)
  BNE.w JL_0_2F38

  MOVEA.l AL_0_84B2,A0
  MOVE.l A0,D0
  CMP.l actualfile,D0
  BNE.w JL_0_2F3C
RTS

 JL_0_2F38:
  MOVEA.l $4(A0),A0

 JL_0_2F3C:
  MOVE.l A0,actualfile
  BSR.b GetXtraData
  JSR JL_0_2Dca8
  JSR read_tempprefs
  JSR draw_statusarea              ;JSR linetext
  JSR update_horizscroller
RTS


.menu_nextfile:
  JSR StoreXtraData
  JSR save_tempprefs
  MOVEA.l actualfile,A0
  TST.l (A0)
  BNE.w JL_0_2F72
    MOVEA.l loadedfilesbase,A0
    MOVE.l A0,D0
    CMP.l actualfile,D0
    BNE.w JL_0_2F74
      RTS
  JL_0_2F72:
  MOVEA.l (A0),A0

  JL_0_2F74:
  MOVE.l A0,actualfile
  JSR GetXtraData
  JSR JL_0_2Dca8
  JSR read_tempprefs
  JSR draw_statusarea
  JSR update_horizscroller
RTS


.menu_new:                                          ;currently not used
  JSR show_newfilerequest

  TST.l D0
  BEQ.w JL_0_76E8c
    JSR clear_actualsource

    ; -- copy screentitle to windowtitle
    ;LEA str_screentitle,A0
    ;MOVEA.l str_windowtitle,A1
    ;JL_0_2FA0:
    ;  MOVE.b (A0)+,(A1)+
    ;BNE.b JL_0_2FA0
    ;JSR update_title_sourcewindow

    MOVE.l comFunc_ReadXtraFile,d0
    BEQ 'l10
      MOVE.l d0,a0
      CLR.l d0
      JSR (a0)
   'l10
    JMP clear_sourcebuffer

  JL_0_76E8c:
  ;JMP JL_0_76E8
RTS


str_iffchunk_form:    Dc.b "FORM"
AL_0_2FD4:            Ds.l 1
str_iffchunk_ftxt:    Dc.b "FTXT"
str_iffchunk_chrs:    Dc.b "CHRS",0,0
                      Ds.w 9
Even


.menu_copy:
  MOVEM.l A2-A4,-(A7)
  !basic
  Gosub getCountOfMarkedLines
  *detokened.l = TEDDetoke{*tempLine.sourceLine + 9}
  strlng.w = Len(Peek$(*detokened))
  ;log_Print{Peek$(*detokened)}

  If getCountOfMarkedLines.l < 2
    If strlng >= Peek.w(?comLong_BlockEndX)
      strlng = Peek.w(?comLong_BlockEndX) - Peek.w(?comLong_BlockStartX) + 2
    EndIf
    strlng = strlng - 1
    strline$ = Peeks$(*detokened + Peek.w(?comLong_BlockStartX), strlng) ;+ Chr$(10)
    ;log_Print{">>" + strline$}
    clipboard_WriteText{&strline$}

  Else
    *iff.IFFHandle = AllocIFF_()
    If *iff
      *iff\iff_Stream = OpenClipboard_ (0)
      If *iff\iff_Stream
        InitIFFasClip_ *iff
        If (OpenIFF_ (*iff, #IFFF_WRITE)=0)
          If (PushChunk_ (*iff, #ID_FTXT, #ID_FORM, #IFFSIZE_UNKNOWN)=0)
            If (PushChunk_ (*iff, 0, #ID_CHRS, #IFFSIZE_UNKNOWN)=0)
              ; VerticalCopyMode mssing ??
              If strlng <= Peek.w(?comLong_BlockStartX)
                ; end of String...
                strlng = 1
                strline$ = Chr$(10)
              Else
                strlng = strlng - Peek.w(?comLong_BlockStartX)
                strline$ = Peeks$(*detokened + Peek.w(?comLong_BlockStartX), strlng) + Chr$(10)
              EndIf
              ;log_Print{Str$(Len(strline$))}
              ;log_Print{">"+strline$+"<"}
              WriteChunkBytes_ *iff, &strline$, Len(strline$)

              ; copy most lines
              ;error{"copy other lines"}
              For si.w = 1 To getCountOfMarkedLines - 2
                If *tempLine\nextLine
                  *tempLine = *tempLine\nextLine
                  detokened.l = TEDDetoke{*tempLine + 9}
                  strlng.w = Len(Peek$(*detokened))
                  If Peek.b(?VerticalCopyMode)<>0 AND (strlng > Peek.w(?comLong_BlockStartX))
                    strline$ = Peeks$(*detokened + Peek.w(?comLong_BlockStartX), strlng - Peek.w(?comLong_BlockStartX)) + Chr$(10)
                  Else
                    strline$ = Peeks$(*detokened, strlng) + Chr$(10)
                  EndIf
                  WriteChunkBytes_ *iff,&strline$,Len(strline$)
                Else
                  error{"Error copying to clipboard: no next line!",#log_error}
                EndIf
              Next si

              ; copy last selected Line
              ;error{"copy last line"}
              *tempLine = *tempLine\nextLine
              If *tempLine
                *detokened.l = TEDDetoke{*tempLine + 9}
                strline$ = Left$(Peek$(*detokened),Peek.w(?comLong_BlockEndX))
                strlng = Len(strline$)
                If Peek.b(?VerticalCopyMode)<>0 AND (strlng > Peek.w(?comLong_BlockStartX))
                  strline$ = UnRight$(strline$,Peek.w(?comLong_BlockStartX)-1) + Chr$(10)
                Else
                  strline$ = strline$ + Chr$(10)
                EndIf
                WriteChunkBytes_ *iff, &strline$, Len(strline$)
              EndIf

              PopChunk_ *iff
            End If

            PopChunk_ *iff
          Else
            error{"Could not write chunks."}
          End If
          CloseIFF_ *iff
        Else
          error{"Could not open IFF."}
        End If
        CloseClipboard_ *iff\iff_Stream
      Else
        error{"Could not open Clipboard."}
      End If
      FreeIFF_ *iff
    Else
      error{"Could not AllocIFF."}
    End If
  EndIf
  !asm

  TST.b new_editmode
  BEQ 'l1
    TST.b cutmode
    BNE 'l1
      !regs2stack
      MOVE.l #$ffffffff,comLong_BlockEndY            ; set to clear Block mark
      JSR cursor_off                                 ; cursor off
      JSR _redraw                                    ; clear block mark
      !stack2regs
      CLR.b cutmode
 'l1
  MOVEM.l (A7)+,A2-A4
RTS



JL_0_3154:
  SF comByte_StateBlockMark
  TST.l comLong_BlockEndY
  BMI.w JL_0_319A
    CMP.l comLong_BlockStartY,D1
    BLT.w JL_0_319A
    BNE.w JL_0_317C
      CMP.w comLong_BlockStartX,D0
      BLT.w JL_0_319A
    JL_0_317C:
    CMP.l comLong_BlockEndY,D1
    BGT.w JL_0_319A
    BNE.w JL_0_3194
      CMP.w comLong_BlockEndX,D0
      BGT.w JL_0_319A
    JL_0_3194:
    ST comByte_StateBlockMark
 JL_0_319A:
RTS



.getCountOfMarkedLines:
  diff.l = 0
  *tempLine.sourceLine = Peek.l(?comPtr_CurrentSourceLine)
  currLine.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
  If currLine < Peek.l(?comLong_BlockStartY)
    diff = Peek.l(?comLong_BlockStartY) - currLine
    For si.w = 1 To diff
      If *tempLine\nextLine Then *tempLine = *tempLine\nextLine Else error{"Error copying to clipboard!"}
    Next si
  Else
    If currLine > Peek.l(?comLong_BlockStartY)
      diff = currLine - Peek.l(?comLong_BlockStartY)
      For si.w = 1 To diff
        If *tempLine\previousLine Then *tempLine = *tempLine\previousLine Else error{"Error copying to clipboard!"}
      Next si
    EndIf
  EndIf
  getCountOfMarkedLines.l = Peek.l(?comLong_BlockEndY) - Peek.l(?comLong_BlockStartY) + 1
Return

.menu_cut:
  !regs2stack
  MOVE.b #1,cutmode
  JSR menu_copy
  !stack2regs
  MOVE.l comPtr_CurrentSourceLine,a4
  JSR menu_kill
RTS


.menu_paste:
  ; -- read from clipboard
  MOVE.l A4,-(A7)
  MOVE.w #$FFFF,comWord_PasteMode
  JSR JL_0_3748
  MOVE.w #$0000,comWord_PasteMode
  MOVEA.l (A7)+,A4
RTS


.menu_kill:
  CMPI.l #$ffffFFFF,comLong_BlockEndY        ;cut block
  BEQ.w setpointer_to_normal

  CLR.w comWord__AL_0_8AD8
  MOVE.w #$FFFF,comWord_SourceChanged
  JSR JL_0_5524                                 ; move to Blockbegin, returns pointer in A5
  MOVEQ.l #$00,D5
  MOVEA.l comPtr_Temp_TokenString2,A0

  JL_0_3498:
  CMP.w comLong_BlockStartX,D5
  BCC.w JL_0_34A8
    JSR JL_0_5650
    MOVE.b D0,(A0)+
    BRA.b JL_0_3498
  JL_0_34A8:
  MOVE.l A0,-(A7)

  JL_0_34AA:
    CMP.l comLong_BlockEndY,D6
    BCC.w JL_0_34BE
      MOVE.l (A5),-(A7)
      JSR JL_0_5474
      MOVEA.l (A7)+,A5
      ADDQ.l #1,D6
  BRA.b JL_0_34AA
  JL_0_34BE:

  CMP.l comLong_BlockStartY,D6
  BEQ.w JL_0_34CA
    JSR JL_0_553A
  JL_0_34CA:

  MOVEA.l (A7)+,A0
  MOVE.w comLong_BlockEndX,D5
  JL_0_34D0:
    ADDQ.w #1,D5
    CMP.w comWord_MaxColumns,D5
    BCC.w JL_0_34E4
      JSR JL_0_5650
      SUBQ.w #1,D5
      MOVE.b D0,(A0)+
  BRA.b JL_0_34D0
  JL_0_34E4:
    CMPA.l comPtr_Temp_TokenString3,A0
    BCC.w JL_0_34F2
      MOVE.b #$20,(A0)+
  BRA.b JL_0_34E4
  JL_0_34F2:

  MOVE.w comLong_BlockStartX,D0
  BNE.w JL_0_3510
    MOVE.w comLong_BlockEndX,D0
    ADDQ.w #1,D0
    CMP.w comWord_MaxColumns,D0
    BCS.w JL_0_3510
      JSR JL_0_5474
      BRA.w JL_0_351C
  JL_0_3510:
    MOVEA.l A5,A4
    MOVE.l A4,comPtr_CurrentSourceLine
    JSR JL_0_55A2
  JL_0_351C:

  JSR reset_Blockflag

  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  CMP.l comLong_TotalLines,D0
  BCS.w JL_0_3552
    MOVE.l comLong_TotalLines,D0
    SUBQ.l #1,D0
    MOVE.l D0,comLong_DisplayLineOffset
    CLR.l comLong_DisplayLine
    JSR update_currsourceline
    JSR _redraw
    MOVE.l comLong_DisplayLineOffset,D0
    BRA.w gotoline
  JL_0_3552:

  JSR update_currsourceline
JMP _redraw



str_title_ascreq: Dc.b "Select file to save as ASCII...",0
ptr_asciifile:    Ds.l 1

.saveab2
  MOVE.l A2,-(a7)
BRA saveab

.menu_saveascii:
  MOVE.l A2,-(A7)
  LEA str_title_ascreq,A2
  JSR do_aslfilerequest
  TST.l D0
  BEQ.w saveascii_exit

 .saveab:
  MOVE.l D0,-(a7)
  JSR set_pointer_busy
  MOVE.l (a7)+,D0

  MOVEA.l _dosbase,A6                ;d0 = filename
  MOVE.l D0,D1
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  JSR _Open(A6)
  TST.l D0
   BEQ.w saveascii_writeerror

  MOVE.l D0,ptr_asciifile
  MOVEQ.l #$00,D7
  MOVE.l comLong_TotalLines,D7
   BEQ.w saveascii_done

  MOVE.b #$A,comByte_EnteredCharacter
  MOVEA.l comPtr_FirstSourceLine,A2
  TST.w comWord_DoTokenize
   BEQ.w JL_0_3608
   BRA saveascii_writeline_fast

  saveascii_writeline:               ;-- detokenize and write to file
    LEA $9(A2),A0
    MOVEA.l comPtr_Temp_TokenString2,A1
    JSR detokenize_line
    MOVE.b #$A,(A1)
    ADDQ.w #1,A1
    MOVE.l ptr_asciifile,D1
    MOVE.l comPtr_Temp_TokenString2,D2
    SUBA.l D2,A1
    MOVE.l A1,D3
    JSR _Write(A6)
    MOVEA.l (A2),A2
    SUBQ.l #1,d7
  BNE saveascii_writeline
  BRA.w saveascii_done

  saveascii_writeline_fast:          ;-- detokenize and write to file
    MOVE.l A2,saveascii_node
    MOVE.l D7,saveascii_lines

    !basic
    node.l     = Peek.l(?saveascii_node)
    numlines.l = Peek.l(?saveascii_lines)
    fp.l       = Peek.l(?ptr_asciifile)

    totalLength.l = 0

    For n.l=0 To numlines-1
      baseptr.l = node+$9 ;Peek.l (node+$9)
      sptr.l = baseptr
      While Peek.b(sptr) : sptr+1 : Wend
      totalLength + sptr-baseptr+1
      node = Peek.l(node)
    Next

    tmp.l      = AllocVec_(totalLength,#MEMF_CLEAR)
    If tmp
      node.l     = Peek.l(?saveascii_node)
      dptr.l     = tmp
      For n.l=0 To numlines-1
        baseptr.l = node+$9 ;Peek.l (node+$9)
        sptr.l    = baseptr
        Repeat
           char.b = Peek.b(sptr)
           Poke.b dptr,char : sptr +1 : dptr+1
        Until char=0
        node = Peek.l(node)
      Next

      plainLength.l = preproc_DetokenizeFP{*PreProcessor,tmp,totalLength,fp}
      FreeVec_ tmp
    Else
      error{!TRANS{"Not enough memory for temp buffer!"}}
    End If
    Close_ fp
    !asm
    MOVE.l #0,d7

  BRA saveascii_exit
  saveascii_node:  Dc.l 0
  saveascii_lines: Dc.l 0



  JL_0_3608:                         ;-- directly write to file
    LEA $9(A2),A0
    MOVEQ.l #$00,D3
    MOVE.b $8(A2),D3
    SUBQ.w #1,D3
    MOVE.l ptr_asciifile,D1
    MOVE.l A0,D2
    JSR _Write(A6)
    MOVE.l #comByte_EnteredCharacter,D2
    MOVE.l ptr_asciifile,D1
    MOVEQ.l #$01,D3
    JSR _Write(A6)
    MOVEA.l (A2),A2
    SUBQ.l #1,d7
    BNE JL_0_3608
  DBF D7,JL_0_3608

  saveascii_done:
  MOVE.l ptr_asciifile,D1
  JSR _Close(A6)

  saveascii_exit:
  MOVEA.l (A7)+,A2
RTS

.saveascii_writeerror:
  !basic
  UnlockAllOpenWZWin{}
  Gosub set_pointer_normal_bas

  WZ_HideMessage{}
  !asm
  MOVEA.l (A7)+,A2
  LEA comStr_ErrorWriteFile,A0
JMP show_errorrequester


.kill_or_save_block:
  ; -- check if L-SHIFT is pressed
  MOVE.w comWord_QualifierStore,D0
  ANDI.w #$3,D0
  ; -- if not, then save the block
  BEQ.b menu_saveblockas
  ; -- else kill the block
  JSR menu_kill
JMP update_vertscroller

.menu_saveblockas:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w setpointer_to_normal
  LEA comStr_ASLSaveBlock,A2
  JSR do_aslfilerequest
  TST.l D0
  BEQ.w JL_0_3732
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVE.b #1,menuload
  JSR open_sourcefile
  MOVE.l D7,-(A7)
  MOVEA.l comPtr_CurrentSourceLine,A4
  JSR JL_0_5524
  MOVE.l (A7)+,D7
  MOVE.w #$FFFF,comWord__AL_0_8AD8

  JL_0_36A2:
      JSR JL_0_5630
      BMI.w JL_0_372E
      BEQ.w JL_0_36C4
      MOVE.b D0,comLong_LinePosStartX
      MOVE.l D7,D1
      MOVE.l #comLong_LinePosStartX,D2
      MOVEQ.l #$01,D3
      JSR _Write(A6)
    BRA.b JL_0_36A2

    JL_0_36C4:
    MOVE.b #$A,comLong_LinePosStartX
    MOVE.l D7,D1
    MOVE.l #comLong_LinePosStartX,D2
    MOVEQ.l #$01,D3
    JSR _Write(A6)
    MOVEQ.l #$00,D5

    JL_0_36Dca:
    CMP.l comLong_BlockEndY,D6
     BCS.w JL_0_36F4
    MOVE.w comWord_DoTokenize,D0
     BEQ.b JL_0_36A2
     JSR JL_0_553A
    MOVEQ.l #$00,D5
  BRA.b JL_0_36A2

  JL_0_36F4:
  JSR JL_0_553A
  MOVE.l D7,D1
  MOVEA.l comPtr_Temp_TokenString3,A0
  MOVEQ.l #$00,D3
  MOVE.b (A0),D3
  MOVE.b #$A,$0(A0,D3.W)
  ADDQ.w #1,A0
  MOVE.l A0,D2
  MOVE.l D7,D1
  JSR _Write(A6)
  TST.l D0
  BPL.w JL_0_3728
  SUBA.l A0,A0
  MOVEA.l #comStr_ErrorWriteFile,A0
  JSR show_errorrequester
  BRA.w JL_0_372E

  JL_0_3728:
  MOVEA.l (A5),A5
  ADDQ.l #1,D6
  BRA.b JL_0_36Dca

  JL_0_372E:
  BRA.w JL_0_4E4Ab

  JL_0_3732:
RTS

.menu_includeblock:
  CLR.w comWord__AL_0_8AD8
  LEA comStr_ASLLoadBlock,A2
  JSR do_aslfilerequest
  TST.l D0
  BNE.b JL_0_3748
    RTS

JL_0_4E4Ab
;JMP JL_0_4E4A
JMP close_sourcefile


JL_0_3748:
  MOVEA.l comPtr_CurrentSourceLine,A4
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
  CLR.b menuload
  JSR open_sourcefile
  JSR source_readin
  BEQ.w JL_0_4E4Ab
  MOVE.w #$FFFF,comWord_LabelListChanged
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVEA.l A2,A0
  ADDA.w comWord_MaxColumns,A0
  MOVE.l A0,comLong_LinePosStartX
  MOVE.w comWord_ColumnsOffset,D1
  ADD.w comWord_Column,D1
  MOVEA.l comPtr_Temp_TokenString1,A3
  MOVEQ.l #$00,D4
  CLR.b instring

  JL_0_3790:
    CMP.w D1,D4
    BCC.w JL_0_37A2
      MOVE.b (A2)+,D0
      CMP.b #$22,d0
      BNE 'l1
        NOT.b instring
     'l1
      TST.b instring
      BNE 'l2
        BCLR #$7,D0                      ;paste mix line
     'l2
      MOVE.b D0,(A3)+
      ADDQ.w #1,D4
  BRA.b JL_0_3790
  JL_0_37A2:

  MOVE.l A2,-(A7)
  MOVE.l comPtr_Temp_TokenString2,tempstore
  JSR JL_0_4F5A
  BEQ.w JL_0_37DE

  JSR JL_0_4E36
  JSR JL_0_5596
  ;CLR.b skipit

  JL_0_37B4:
  MOVEA.l comPtr_Temp_TokenString2,A0

 'n10
  TST.w VerticalPasteMode                        ; test PasteMode for normal paste mode if "0" or column paste mode if "1" tomsmart1
  BNE 'l1a
    MOVE.w #0,d0                                   ; was VerticalPasteMode,d0 tomsmart1
    BRA 'nc
 'l1a
    MOVE.l #0,d0                                   ; was VerticalCopyMode,d0 tomsmart1
    BEQ 'w1
    ADDQ.l #2,d0

   'l1
      SUBQ.l #1,d0
      BEQ 'f1
        SUBQ.w #1,d6
    CMP.b #32,(a5)+                     ;paste at column
    BEQ 'l1

   'f1
    ADDQ.w #1,d6
    SUBQ.l #1,a5

   'w1
    MOVE.w comWord_Column,d0
    ADD.w comWord_ColumnsOffset,D0
    BEQ 'nc

   'w2
    CMP.w #MAX_Columns-10,d0
    BLE 'l1b
      MOVE.w #MAX_Columns-10,d0
   'l1b
      MOVE.b #32,(a0)+
      SUBQ.w #1,d0
    BNE 'l1b
 'nc
  MOVE.l a0,tempstore

  JSR JL_0_4F5A
  TST.w d0
  BMI.w JL_0_37CA
    JSR newSourcelineFromTempString
    JSR JL_0_4E08
    BRA.b JL_0_37B4
  JL_0_37CA:

  JSR alloc_newline
  BEQ.w memAlert_CloseSource

  JSR JL_0_4E08
  MOVEA.l comPtr_Temp_TokenString1,A3
  BRA.w JL_0_37F6

  JL_0_37DE:
  JSR JL_0_4E36
  BRA.w JL_0_37F6

  JL_0_37E6:
  JSR newSourcelineFromTempString
  JSR JL_0_4E08
  MOVEA.l comPtr_Temp_TokenString1,A3
  JSR JL_0_4E36

  JL_0_37F6:
  ;JSR JL_0_4E4A
  JSR close_sourcefile
  MOVEA.l (A7)+,A2
  CLR.b instring

  JL_0_37FC:
    CMPA.l comLong_LinePosStartX,A2
     BCC.w JL_0_3816
    CMPA.l comPtr_Temp_TokenString2,A3
     BCC.w JL_0_3816
    MOVE.b (A2)+,D0
    ;MOVE.b #44,d0
      ;BCLR #$7,D0                    ;morechar ?????????
   'l2
    MOVE.b D0,(A3)+
  BRA.b JL_0_37FC

  JL_0_3816:
  MOVEA.l comPtr_Temp_TokenString1,A2
  JSR parse_line
  JSR JL_0_55AA
  JSR update_currsourceline
  JSR reset_Blockflag
BRA.w JUMP_redraw


.menu_dublicate:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w setpointer_to_normal

  CLR.w comWord__AL_0_8AD8
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVE.l comLong_DisplayLineOffset,D7
  ADD.l comLong_DisplayLine,D7
  CMP.l comLong_BlockStartY,D7
  BCS.w JL_0_387E
  BNE.w JL_0_386A
  JSR JL_0_79CC
  BNE.w JL_0_386A
  BRA.w JL_0_387E

  JL_0_386A:
  CMP.l comLong_BlockEndY,D7
  BHI.w JL_0_387E
  BNE.w setpointer_to_normal
  JSR JL_0_79F0
  BEQ.w setpointer_to_normal
  JL_0_387E:
  JSR JL_0_5524
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVEA.l A2,A1
  MOVE.w comWord_ColumnsOffset,D2
  ADD.w comWord_Column,D2
  MOVEQ.l #$00,D1
  MOVEA.l comPtr_Temp_TokenString2,A0
  JL_0_389A:
  CMP.w D2,D1
  BCC.w JL_0_38AC
    MOVE.b (A1)+,D0
    ANDI.b #$7F,D0
    MOVE.b D0,(A0)+
    ADDQ.w #1,D1
    BRA.b JL_0_389A
  JL_0_38AC:
  MOVEM.l D1/A1,-(A7)
  JL_0_38B0:
    JSR JL_0_5630
    BMI.w JL_0_3982
    BEQ.w JL_0_38C8
      CMP.w comWord_MaxColumns,D1
      BCC.b JL_0_38B0
        MOVE.b D0,(A0)+
        ADDQ.w #1,D1
  BRA.b JL_0_38B0
  JL_0_38C8:

  CMP.w comWord_MaxColumns,D1
  BCC.w JL_0_38D8
    MOVE.b #$20,(A0)+
    ADDQ.w #1,D1
    BRA.b JL_0_38C8
  JL_0_38D8:

  MOVEA.l comPtr_Temp_TokenString2,A2
  JSR parse_line
  MOVE.l D5,D0                                      ; allocmem for sourceline-structentry
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  ADDI.w #$9,D0
  JSR AllocPoolMem
  MOVEA.l D0,A0
  LEA $9(A0),A0
  MOVEA.l comPtr_Temp_TokenString1,A1
  JL_0_38FA:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_38FA
  MOVEA.l D0,A0

  JL_0_3900:
  ADDQ.l #1,comLong_TotalLines
  MOVE.b D5,$8(A0)
  MOVE.l $4(A4),D1
   BNE.w JL_0_3920
  MOVE.l A0,comPtr_FirstSourceLine
  CLR.l $4(A0)
 BRA.w JL_0_3928

JL_0_3920:
  MOVEA.l D1,A1
  MOVE.l A0,(A1)
  MOVE.l A1,$4(A0)
JL_0_3928:
  MOVE.l A0,$4(A4)
  MOVE.l A4,(A0)
  CMP.l comLong_BlockEndY,D6
   BCC.w JL_0_3968
  MOVEQ.l #$00,D0
  MOVE.b $8(A5),D0
  MOVE.w D0,D5
  ADDI.w #$9,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
   JSR AllocPoolMem
  MOVEA.l D0,A0
  MOVEM.l A0/A5,-(A7)
  LEA $9(A0),A0
  LEA $9(A5),A5
JL_0_395A:
  MOVE.b (A5)+,(A0)+
   BNE.b JL_0_395A
  MOVEM.l (A7)+,A0/A5
  ADDQ.l #1,D6
  MOVEA.l (A5),A5
 BRA.b JL_0_3900

JL_0_3968:
  MOVE.w comWord_DoTokenize,D0
   BEQ.w JL_0_3976
   JSR JL_0_553A
JL_0_3976:
  MOVEA.l comPtr_Temp_TokenString2,A0
  MOVEQ.l #$00,D5
  MOVEQ.l #$00,D1
 BRA.w JL_0_38B0

JL_0_3982:
  MOVEM.l (A7)+,D1/A1
JL_0_3986:
  CMP.w comWord_MaxColumns,D1
   BCC.w JL_0_399A
  MOVE.b (A1)+,D0
  ANDI.b #$7F,D0
  MOVE.b D0,(A0)+
  ADDQ.w #1,D1
 BRA.b JL_0_3986

JL_0_399A:
  CMPA.l comPtr_Temp_TokenString3,A0
   BCC.w JL_0_39A8
  MOVE.b #$20,(A0)+
 BRA.b JL_0_399A

JL_0_39A8:
   JSR JL_0_55A2
  MOVE.w comWord_ColumnsOffset,D0
  ADD.w comWord_Column,D0
  MOVE.l comLong_DisplayLineOffset,D7
  ADD.l comLong_DisplayLine,D7
  CMP.l comLong_BlockEndY,D7
   BHI.w JL_0_3A42
   BNE.w JL_0_39D0
  CMP.w comLong_BlockEndX,D0
   BHI.w JL_0_3A42
JL_0_39D0:
  MOVE.l comLong_BlockEndY,D1
  SUB.l comLong_BlockStartY,D1
  MOVE.w comLong_BlockEndX,D2
  ADDQ.w #1,D2
  CMP.w comWord_MaxColumns,D2
   BCS.w JL_0_39FA
  ADDQ.l #1,D1
  CMP.l comLong_BlockStartY,D7
   BCS.w JL_0_3A36
  SUB.w D0,comLong_BlockStartX
 BRA.w JL_0_3A36

JL_0_39FA:
  CMP.l comLong_BlockStartY,D7
   BCS.w JL_0_3A36
  CMP.l comLong_BlockEndY,D7
   BEQ.w JL_0_3A1C
  MOVE.w comLong_BlockEndX,D2
  SUB.w D0,D2
  ADDQ.w #1,D2
  ADD.w D2,comLong_BlockStartX
 BRA.w JL_0_3A32

JL_0_3A1C:
  MOVE.w comLong_BlockEndX,D2
  SUB.w comLong_BlockStartX,D2
  ADDQ.w #1,D2
  ADD.w D2,comLong_BlockStartX
  ADD.w D2,comLong_BlockEndX

  JL_0_3A32:
  JSR JL_0_7A14

  JL_0_3A36:
  ADD.l D1,comLong_BlockStartY
  ADD.l D1,comLong_BlockEndY
  JL_0_3A42:
  JSR update_currsourceline
BRA.w JUMP_redraw

.menu_forget:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w setpointer_to_normal
  JSR reset_Blockflag
BRA.w JUMP_redraw


.jump_to_keyword:                    ; A0 = pointer zieltextzeile
  MOVEA.l comPtr_FirstSourceLine,A1
  MOVEQ.l #$00,D0
  MOVE.l comLong_TotalLines,D1
  SUBQ.l #1,D1
  BEQ 'exit

  CMPA.l A0,A1                       ; added to fix jump to line 1  tomsmart1
  BEQ 'match

  'loop
    CMPA.l $4(A0),A1
    ;BEQ.w sub_gotoline
    BNE 'notmatch
    ADDQ.l #1,d0

  'match
    JMP jumpline

   'notmatch
    MOVEA.l (A1),A1
    ADDQ.l #1,D0
    SUBQ.l #1,d1
  BNE 'loop
  MOVEQ.l #-$01,D0

 'exit
RTS



.event_leftmousebutton:
  JSR get_mousepos                   ; return D2: TextX, D3: TextY
  BMI.w exit_leftmousebutton         ; ausserhalb source- und statusareabereich
;  !basic
;  Gosub get_TextPosMouse
;  GetD0 textX.w : MOVE.l D0,D2
;  GetD0 textY.w : MOVE.l D0,D3
;  GetReg D2,textX.w
;  GetReg D3,textY.w
;  If textY.w < 0
;    Pop If
;    !asm
;    BRA.w exit_leftmousebutton
;  EndIf
;  !asm

  MOVE.l D3,D1                        ; d3: textY
  ADD.l comLong_DisplayLineOffset,D1
  CMP.l comLong_TotalLines,D1
  BCC.w exit_leftmousebutton

  MOVE.w comLong_BlockStartX,-(a7)
  MOVE.l comLong_BlockStartY,-(a7)
  MOVE.w comLong_BlockEndX,-(a7)
  MOVE.l comLong_BlockEndY,-(a7)
  CMPI.l #$ffffFFFF,comLong_BlockEndY ; check if a marked block is set
  BEQ.w JL_0_3ADC                     ; if it is the case, remove the block from sourcearea
    JSR reset_Blockflag
    MOVEM.l D2-D3,-(A7)
    JSR _redraw
    MOVEM.l (A7)+,D2-D3
  JL_0_3ADC:

  MOVE.l D3,D1                        ; d3: TextY
  ADD.l comLong_DisplayLineOffset,D1
  MOVE.l D1,comLong_LinePosStartY
  MOVE.l D1,comLong_LinePosEndY
  ADD.w comWord_ColumnsOffset,D2      ; d2: TextX
  MOVE.w D2,comLong_LinePosStartX
  MOVE.w D2,comWord_LinePosEndX

  JSR update_scroller

  MOVE.w D2,D5
  MOVE.l D3,D6
  MOVE.w D2,D0
  MOVE.l D3,D1
  CLR.w comWord__AL_0_86B8
  MOVE.l comLong_DisplayLineOffset,-(A7)
  MOVE.w comWord_ColumnsOffset,-(A7)
  MOVE.l A4,-(A7)
  JSR JL_0_59BC

  JL_0_3B1E:
    JSR check_events
    ;JSR delay                          ; include a wait, because on emulation, mouse scrolls VERY fast

    CMP.w #-$4,D7                      ; compileand run from statusarea?
    BEQ.w JL_0_3DD0

    JSR get_mousepos                   ; return D0:x, D1:y, D2: TextX, D3: TextY
    BPL.w JL_0_3C38                    ; ok

                                       ; comLong_LinePosStartY = startline
                                       ; comLong_LinePosEndY = endline
    CMP.w win_TopEdge,D1
    BCS.w JL_0_3BCE
      MOVE.l viewablelines,D3
      MOVE.l D3,D0
      ADD.l comLong_DisplayLineOffset,D0
  CMP.l comLong_TotalLines,D0
  BCC.b JL_0_3B1E

  SUBQ.l #1,D3
  MOVE.w comWord_MaxColumns,D2
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l viewablelines,D0
  CMP.l comLong_TotalLines,D0
  BCC.w JL_0_3D06

  MOVEM.l D5-D6,-(A7)
  JSR source_fullscroll_down
  MOVEA.l (A4),A4
  MOVE.l A4,comPtr_CurrentSourceLine
  ADDQ.l #1,comLong_DisplayLineOffset
  JSR JL_0_5B60
  MOVEM.l (A7)+,D5-D6
  SUBQ.w #1,D6
  MOVE.w comWord_MaxColumns,D2
  MOVE.l viewablelines,D3
  SUBQ.l #1,D3
  MOVE.l D3,D1
  ADD.l comLong_DisplayLineOffset,D1
  CMP.l comLong_LinePosStartY,D1
  BHI.w JL_0_3D06

  MOVE.l D1,-(A7)
  MOVE.w D5,D2
  MOVE.w D6,D3
  MOVE.w comWord_MaxColumns,D0
  MOVE.l viewablelines,D1
  SUBQ.l #2,D1
  JSR JL_0_59BC
  MOVE.w comWord_MaxColumns,D5
  MOVE.l viewablelines,D6
  SUBQ.l #1,D6
  MOVE.l D6,D3
  MOVEQ.l #-$01,D2
  MOVE.l (A7)+,D1
  CMP.l comLong_LinePosStartY,D1
  BNE.w JL_0_3D06

  MOVE.w comLong_LinePosStartX,D5
  ADDQ.w #1,D5
  BRA.w JL_0_3D06

  JL_0_3BCE:
  MOVEQ.l #$00,D2
  MOVEQ.l #$00,D3
  MOVE.l comLong_DisplayLineOffset,D0
  BEQ.w JL_0_3D06

  MOVEM.l D5-D6,-(A7)
  JSR source_fullscroll_up
  MOVEA.l $4(A4),A4
  MOVE.l A4,comPtr_CurrentSourceLine
  SUBQ.l #1,comLong_DisplayLineOffset
  JSR JL_0_5B24
  MOVEM.l (A7)+,D5-D6
  ADDQ.w #1,D6
  MOVEQ.l #$00,D3
  MOVEQ.l #$00,D2
  MOVE.l comLong_DisplayLineOffset,D1
  CMP.l comLong_LinePosStartY,D1
  BCS.w JL_0_3D06

  MOVE.w D5,D2
  MOVE.w D6,D3
  MOVEQ.l #$00,D0
  MOVEQ.l #$01,D1
  JSR JL_0_59BC
  MOVE.w comWord_MaxColumns,D2
  MOVEQ.l #$00,D3
  MOVEQ.l #-$01,D5
  MOVEQ.l #$00,D6
  MOVE.l comLong_DisplayLineOffset,D1
  CMP.l comLong_LinePosStartY,D1
  BNE.w JL_0_3D06

  MOVE.w comLong_LinePosStartX,D5
  SUBQ.w #1,D5
  BRA.w JL_0_3D06

  JL_0_3C38:
  ADD.w comWord_ColumnsOffset,D2
  MOVE.l D3,D1
  ADD.l comLong_DisplayLineOffset,D1
  CMP.l comLong_TotalLines,D1
  BCS.w JL_0_3C54
    MOVE.l comLong_TotalLines,D3
    SUB.l comLong_DisplayLineOffset,D3
    SUBQ.l #1,D3
  JL_0_3C54:

  TST.w D0
  BNE.w JL_0_3CA6
    SUBQ.w #1,D2
    MOVE.w comWord_ColumnsOffset,D0
    BEQ.w JL_0_3D06

    SUBQ.w #1,D2
    MOVEM.w D2-D3/D5-D6,-(A7)
    MOVE.w D5,comWord_LinePosEndX
    EXT.l d6
    MOVE.l D6,D1
    ADD.l comLong_DisplayLineOffset,D1
    MOVE.l D1,comLong_LinePosEndY
    MOVE.w comLong_LinePosStartX,comLong_BlockStartX
    MOVE.l comLong_LinePosStartY,comLong_BlockStartY
    MOVE.w comWord_LinePosEndX,comLong_BlockEndX
    MOVE.l comLong_LinePosEndY,comLong_BlockEndY
    JSR AbsBlockDimensions
    SUBQ.w #2,comWord_ColumnsOffset
    JSR scroll_right
    JSR reset_Blockflag
    MOVEM.w (A7)+,D2-D3/D5-D6
    BRA.w JL_0_3D06
  JL_0_3CA6:

  MOVE.w D2,D0
  SUB.w comWord_ColumnsOffset,D0

  CMP.w visiblecolumns,D0
  BCS.w JL_0_3D06
    MOVE.w comWord_ColumnsOffset,D2
    ADD.w visiblecolumns,D2
    CMP.w comWord_MaxColumns,D2
    BCC.w JL_0_3D06
      ADDQ.w #1,D2
      MOVEM.l D2-D3/D5-D6,-(A7)
      MOVE.w D5,comWord_LinePosEndX
      MOVE.l D6,D1
      ADD.l comLong_DisplayLineOffset,D1
      MOVE.l D1,comLong_LinePosEndY
      MOVE.w comLong_LinePosStartX,comLong_BlockStartX
      MOVE.l comLong_LinePosStartY,comLong_BlockStartY
      ;MOVE.l comLong_LinePosStartX,comLong_BlockStartX
      MOVE.w comWord_LinePosEndX,comLong_BlockEndX
      MOVE.l comLong_LinePosEndY,comLong_BlockEndY
      ;MOVE.l comWord_LinePosEndX,comLong_BlockEndX
      JSR AbsBlockDimensions
      ADDQ.w #2,comWord_ColumnsOffset
      JSR scroll_left
      JSR reset_Blockflag
      MOVEM.l (A7)+,D2-D3/D5-D6
      BRA.w JL_0_3D06
  JL_0_3D06:

  CMP.w D5,D2
  BNE.w JL_0_3D12
    CMP.w D6,D3
    BEQ.w JL_0_3B1E
  JL_0_3D12:

  JSR update_scroller
  MOVE.w D2,comWord_LinePosEndX
  MOVE.l D3,D1
  ADD.l comLong_DisplayLineOffset,D1
  MOVE.l D1,comLong_LinePosEndY
  CMP.l comLong_LinePosStartY,D1
  BCS.w JL_0_3D5A
  BNE.w JL_0_3D3C

  CMP.w comLong_LinePosStartX,D2
  BLT.w JL_0_3D5A

  JL_0_3D3C:
  MOVE.w comWord__AL_0_86B8,D4
  BNE.w JL_0_3D78

    MOVE.w D5,D0
    MOVE.l D6,D1
    MOVE.w D2,D5
    MOVE.w D3,D6
    JSR AbsDimensions
    ADDQ.w #1,D0
    JSR draw_blockselection
    BRA.w JL_0_3B1E

    JL_0_3D5A:
    MOVE.w comWord__AL_0_86B8,D4
    BEQ.w JL_0_3D78
    MOVE.w D5,D0
    MOVE.l D6,D1
    MOVE.w D2,D5
    MOVE.w D3,D6
    JSR AbsDimensions
    SUBQ.w #1,D2
    JSR draw_blockselection
    BRA.w JL_0_3B1E

  JL_0_3D78:
  NOT.w comWord__AL_0_86B8
  MOVEM.w D2-D3,-(A7)
  MOVE.w D5,D2
  MOVE.w D6,D3
  MOVE.w comLong_LinePosStartX,D0
  MOVE.l comLong_LinePosStartY,D1
  SUB.l comLong_DisplayLineOffset,D1
  BPL.w JL_0_3D9E
    MOVEQ.l #$00,D0
    MOVEQ.l #$00,D1
    BRA.w JL_0_3DB2
  JL_0_3D9E:
    CMP.l viewablelines,D1
    BCS.w JL_0_3DB2
      MOVE.l viewablelines,D1
      SUBQ.l #1,D1
      MOVE.w comWord_MaxColumns,D0
      SUBQ.w #1,D0
  JL_0_3DB2:
  MOVEM.w D0-D1,-(A7)

  JSR JL_0_59BC
  MOVEM.w (A7)+,D0-D1
  MOVEM.w (A7)+,D2-D3
  MOVE.w D2,D5
  MOVE.w D3,D6
  JSR JL_0_59BC

  BRA.w JL_0_3B1E                     ; jump upwarts until no leftmousebutton pressed

  exit_leftmousebutton:
RTS


JL_0_3DD0:
  MOVE.l comLong_DisplayLineOffset,comLong_DisplayLineOffsetStore
  MOVE.w comWord_ColumnsOffset,ColumnsOffsetStore
  MOVE.l (A7)+,comPtr_CurrentSourceLine
  MOVE.w (A7)+,comWord_ColumnsOffset
  MOVE.l (A7)+,comLong_DisplayLineOffset
  MOVE.w comWord_LinePosEndX,D0
  BPL.w JL_0_3E16
    MOVE.l comLong_LinePosEndY,D1
    CMP.l comLong_LinePosStartY,D1
    BLS.w JL_0_3E10
      SUBQ.l #1,comLong_LinePosEndY
      BRA.w JL_0_3E1E
    JL_0_3E10:
      MOVEQ.l #$00,D0
      BRA.w JL_0_3E24
  JL_0_3E16:

  CMP.w comWord_MaxColumns,D0
  BCS.w JL_0_3E24
    JL_0_3E1E:
    MOVE.w comWord_MaxColumns,D0
    SUBQ.w #1,D0
  JL_0_3E24:

  MOVE.w D0,comWord_LinePosEndX
  MOVE.w comLong_LinePosStartX,d0
  MOVE.w comWord_LinePosEndX,d1
  CMP.w d1,d0
  BNE 'l10
    MOVE.l comLong_LinePosStartY,d0
    MOVE.l comLong_LinePosEndY,d1
    CMP.l D1,D0
    BEQ.w JL_0_3E5E
 'l10:
  ;MOVEM.l D0-D1,-(A7)
  ;JSR JL_0_56BA        ; set "block"flag
  ;MOVEM.l (A7)+,D0-D1
  ;ADD.w #8,A7
  ADD.w #12,A7
  ;MOVE.l D0,comLong_BlockStartX
  MOVE.l comLong_LinePosStartY,comLong_BlockStartY
  MOVE.w comLong_LinePosStartX,comLong_BlockStartX
  MOVE.l comLong_LinePosEndY,comLong_BlockEndY
  MOVE.w comWord_LinePosEndX,comLong_BlockEndX
  ;MOVE.l D1,comLong_BlockEndX
  JSR AbsBlockDimensions
  JSR update_horizscroller
  BRA.w JUMP_redraw

  JL_0_3E5E:
  ;MOVE.l (A7)+,comLong_BlockEndX
  MOVE.l (a7)+,comLong_BlockEndY
  MOVE.w (a7)+,comLong_BlockEndX
  MOVE.l (a7)+,comLong_BlockStartY
  MOVE.w (a7)+,comLong_BlockStartX
  ;MOVE.l (A7)+,comLong_BlockStartX
  MOVE.w comLong_LinePosStartX,D0
  SUB.w comWord_ColumnsOffset,D0
  MOVE.w D0,comWord_Column
  CLR.l foldnum
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  MOVEA.l comPtr_CurrentSourceLine,A4

CNIF #hardfold = 1
'l11 CMP.l comLong_LinePosStartY,d0
 BCS JL_0_3E98b
  CMP.w #";@",9(a4)
  BNE JL_0_3E84
  MOVE.l a2,-(a7)
  MOVE.l a4,a2
  JSR doreverse
  MOVE.l (a7)+,a2
JL_0_3E84:                           ;mouseclick get comPtr_CurrentSourceLine
  CMP.l comLong_LinePosStartY,D0
   BEQ.w JL_0_3E9E
  MOVE.l $4(A4),d1
  BEQ JL_0_3E9E
  MOVE.l d1,a4
  CMP.w #";@",9(a4)
  BNE 'l2
  MOVE.l a2,-(a7)
  MOVE.l a4,a2
  JSR doreverse
  MOVE.l (a7)+,a2
  CMP.w #"@0",11(a4)
  BNE 'l2
'l1a TST.l foldnum
  BNE 'l1
'l2
  TST.l foldnum
  BNE JL_0_3E84
  ;SUBQ.l #1,comLong_DisplayLineOffset
  ;SUBQ.l #1,comLong_LinePosStartY
'l1  SUBQ.l #1,D0
 BRA.b JL_0_3E84
JL_0_3E98b:
  CMP.l #";@@1",9(a4)
  BNE 'l10
  MOVE.l #1,foldnum
'l10
  CMP.l #";@@0",9(a4)
  BNE 'l11
  MOVE.l #0,foldnum
'l11
JL_0_3E98:
  CMP.l comLong_LinePosStartY,D0
  BEQ.w JL_0_3E9E
  MOVE.l (A4),d1                     ;forward ok
  BEQ JL_0_3E9E
  MOVE.l d1,a4
  CMP.l #";@@1",9(a4)
  BNE 'l1
  MOVE.l #1,foldnum

  BRA 'l3
'l1  CMP.l #";@@0",9(a4)
  BNE 'l2
  CLR.l foldnum
'l2
  TST.l foldnum
  BNE JL_0_3E98
  ;ADDQ.l #1,comLong_DisplayLineOffset
  ;ADDQ.l #1,comLong_LinePosStartY
'l3  ADDQ.l #1,D0
 BRA.b JL_0_3E98
CELSE
JL_0_3E84:
  CMP.l comLong_LinePosStartY,D0
   BEQ.w JL_0_3E9E
   BCS.w JL_0_3E98
  MOVEA.l $4(A4),A4
  SUBQ.l #1,D0
 BRA.b JL_0_3E84

JL_0_3E98:
  MOVEA.l (A4),A4
  ADDQ.l #1,D0
 BRA.b JL_0_3E84
CEND
  JL_0_3E9E:
  SUB.l comLong_DisplayLineOffset,D0

  MOVE.w D0,comLong_DisplayLine+2
  MOVE.l A4,comPtr_CurrentSourceLine
  JSR update_TextBufferOffset
  MOVE.w message_qualifier,d1
  AND.w #$3,d1                                            ; lshift or rshift
  BEQ 'l9
    MOVE.w comLong_LinePosStartX,comLong_BlockEndX        ;enhance block
    MOVE.l comLong_LinePosStartY,comLong_BlockEndY
    BRA 'l1
 'l9
    MOVE.b #1,doedit2
    JSR checkedit2
    MOVE.l comLong_LinePosStartY,d0
    MOVE.w comLong_LinePosStartX,d1
    CMP.l comLong_BlockStartY,d0
    BLT 'l1
      CMP.l comLong_BlockEndY ,d0
      BGT 'l1
        CMP.l comLong_BlockStartY,d0
        BNE 'l3
          CMP.w comLong_BlockStartX,d1
          BLT 'l1
       'l3
        CMP.l comLong_BlockEndY,d0
        BNE 'l2
          CMP.w comLong_BlockEndX,d1
          BGT 'l1
       'l2
        MOVE.l #$ffffffff,comLong_BlockEndY
 'l1

  CMPI.l #$ffffFFFF,comLong_BlockEndY        ; redraw mark
  BEQ.w JL_0_3EC6
    ;JSR JL_0_56BA
    MOVE.w message_qualifier,d1              ; check LeftAlt or RightAlt
    AND.w #$30,d1
    BEQ 'l10
      JSR jump_onclick
      ;JSR cursor_off
      JSR _redraw
      ;JSR cursor_onoff_force
      RTS
   'l10:
    BRA.w JUMP_redraw
  JL_0_3EC6:
    MOVE.l comLong_DisplayLineOffset,D0
    CMP.l comLong_DisplayLineOffsetStore,D0
    BNE.w JUMP_redraw
      MOVE.w comWord_ColumnsOffset,D0
      CMP.w ColumnsOffsetStore,D0
      BNE.w JUMP_redraw
        MOVE.w message_qualifier,d1             ; alt + lmb
        AND.w #$30,d1
        BEQ 'l10
          ;  MOVE.w #-1,state_of_cursor
          JSR jump_onclick
          RTS
       'l10:
        JMP draw_cursor

JUMP_redraw:
  JMP _redraw

ColumnsOffsetStore:    Ds.w 1


.menu_gotoline:                      ;goto line
  !basic
  Gosub set_pointer_busy_bas
  LockAllOpenWZWin{}
  WZWindow WZID("WIN_GOTO"),?wzgui,32,-2,-2,-2,-2,WZID("WIN_GOTO")
  Use Window WZID("WIN_GOTO")
  ActivateWZGadget{"GOTO_LINE"}   ; replaced to use the statement  tomsmart1 2012 03 09
  exit_goto.b = False

  Repeat
    ev.l = WaitEvent
    Select ev

      Case #IDCMP_IDCMPUPDATE
        If WZGadName = "GOTO_LINE"
          _line.l = Abs(WZInput("GOTO_LINE")) - 1
           If _line >= 0                                   ; fixed so we can jump to line 1  tomsmart1
             GetD0 _line
             !asm
              JSR sub_gotoline                             ; changed form BRA to get back after the jump  tomsmart
             !basic                                        ; added for the return
           EndIf
          exit_goto = True
        EndIf

      Case #IDCMP_CLOSEWINDOW
        _line = -1
        exit_goto = True

    End Select

  Until exit_goto

  WZCloseWindow WZID("WIN_GOTO")

  UnlockAllOpenWZWin{}
  Gosub set_pointer_normal_bas
  Gosub activatesourcewindow
  !asm
  !setregsformenuexit
RTS


store_BlockStartX:        Dc.b $FF,$FF

.set_blockstart:                     ; D0: Startposition
  MOVE.w D0,store_BlockStartX
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  MOVE.l D0,comLong_BlockStartDisplayLine
RTS

.set_blockend:                       ; D0: Position
  MOVE.l D0,-(a7)
  MOVE.w store_BlockStartX,D2
  BMI.w JUMP_setpointer_to_normal

  MOVE.w D0,comLong_BlockStartX
  MOVE.l comLong_BlockStartDisplayLine,D3
  MOVE.l comLong_DisplayLineOffset,D1
  ADD.l comLong_DisplayLine,D1

  MOVE.l (a7)+,D0
;  MOVE.w comWord_ColumnsOffset,D0
;  ADD.w comWord_Column,D0
  CMP.w D0,D2
  BNE.w JL_0_42D8
    CMP.l D1,D3
    BNE.w JL_0_42D8
      JSR reset_Blockflag
      JMP _redraw
  JL_0_42D8:

  TST.w D0
  BNE.w JL_0_42EA
    TST.l D1
    BEQ.w JL_0_42EA
      SUBQ.l #1,D1
      MOVE.w comWord_MaxColumns,D0
  JL_0_42EA:

  MOVE.w D0,comLong_BlockEndX
  MOVE.l D1,comLong_BlockEndY
  MOVE.w D2,comLong_BlockStartX
  MOVE.l D3,comLong_BlockStartY
  JSR AbsBlockDimensions

  ;JSR JL_0_56BA

JMP _redraw


.menu_closewb:
  !basic
  If NOT CloseWorkBench_
    log_Print{"could not close the workbench due to open windows...",#log_warning}
  EndIf
  !asm
RTS

.menu_openwb:
  !basic
  If OpenWorkBench_ = 0
    log_Print{"could not open the workbench...",#log_error}
  EndIf
  ScreenToFront_ sourceWindow\pedScreen
  ActivateWindow_ sourceWindow\win
  !asm
RTS

.menu_newshell:
  !basic
  screen_
  If use_wbscreen <> 0
    WBenchToFront_
    exescr$ = "Workbench"
  Else
    exescr$ = Peek$(?str_defaultpubscreen)
  EndIf
  exe.s = "NEWCLI WINDOW = \\22"+console_device$+"///196/AmiBlitz Shell/CLOSE/SCREEN "+exescr$+"\\22"   ; use select Consoledevice for Shell
  Execute_ &exe,0,0
  !asm
  !setregsformenuexit
RTS

CLI_input_stream:  Ds.l 1
CLI_output_stream: Ds.l 1
CLI_output_file:   Ds.l 1

.console_open:
  SUBA.l A1,A1
  MOVEA.l _execbase,A6
  JSR _FindTask(A6)
  MOVEA.l D0,A3
  MOVE.l $9C(A3),CLI_input_stream
  MOVE.l $A0(A3),CLI_output_stream

  MOVEM.l A2-A3,-(A7)
  !basic
  console_dontclose.l = False
  If console_wb = True Then WBenchToFront_

  ; -- if the console_settings are n/a, set them to something usefull
  USEPATH wtemp
  If \console_h = 0
    \console_x = 0
    \console_y = *myscreen\BarHeight * 2
    \console_w = *myscreen\Width / 3
    \console_h = *myscreen\Height / 3
  EndIf

  ; -- build the window path for opening the con:-device
  con_windowpath$ = dos_PathPart{console_device$}
  con_windowpath$ + Str$(\console_x)
  con_windowpath$ + "/"+Str$(\console_y)
  con_windowpath$ + "/"+Str$(\console_w)
  con_windowpath$ + "/"+Str$(\console_h)
  con_windowpath$ + "/"+console_title$
  con_windowpath$ + "/ZOOM"
  If console_wb = True
    con_windowpath$ + "/SCREEN Workbench"
  Else
    con_windowpath$ + "/SCREEN "+Peek$(?str_defaultpubscreen)
  EndIf
  If console_device$ = "VNC:"
    con_windowpath$ + "/DRAG/QUIET/NOCLOSE/NOBUTTONS"
    If console_font$<>"" Then con_windowpath$ + "/FONT"+console_font$
  EndIf
;  If console_wait = True
;    con_windowpath$ + "/CLOSE"
;    con_windowpath$ + "/WAIT"
;  EndIf

  con_windowpath$ + Chr$(0)
  If Peek.l(?CLI_output_file) = 0
    Poke.l ?CLI_output_file, Open_( con_windowpath$,#HUNK_RELOC_8__MODE_NEWFILE)
  EndIf
  !asm
  MOVEM.l (A7)+,A2-A3

  MOVE.l CLI_output_file,D0
  BEQ.w JL_0_442A
  MOVE.l D0,$9C(A3) ; pr_CIS
  MOVE.l D0,$A0(A3) ; pr_COS
  JL_0_442A:
RTS

.console_close:
  SUBA.l A1,A1
  MOVEA.l _execbase,A6
  JSR _FindTask(A6)
  MOVEA.l D0,A3
  MOVE.l CLI_input_stream,$9C(A3)
  MOVE.l CLI_output_stream,$A0(A3)
  ;
  !basic
  If console_wb   = True Then WBenchToFront_
  If console_wait = True
    txt$ = Chr$(27) + "[1m"              ; make text bold via escape-sequence
    txt$ + Chr$(27) + "["+Str$(30+3)+"m" ; change textcolor
    txt$ + Chr$(10) + !TRANS{"Program terminated."}
    txt$ + Chr$(10) + !TRANS{"Press <ENTER> to return to AmiBlitz3..."}
    Write_ Peek.l(?CLI_output_file),&txt$,FLen(txt$)
    Flush_(Peek.l(?CLI_output_file))

    If KickVersion(39)
      SetWindowPointerA_ Peek.l(?ptr_sourcewindow), ?taglist_mousepointerbusy
    EndIf
    console_dummy.b = 0
    ; (CheckWindow{console_title$} = True)
    While Read_(Peek.l(?CLI_output_file),&console_dummy,1) = 0
      Delay_ 2
    Wend
  EndIf
  Close_ Peek.l(?CLI_output_file) : Poke.l ?CLI_output_file,0
  If KickVersion(39)
    SetWindowPointerA_ Peek.l(?ptr_sourcewindow), ?taglist_mousepointernormal
  EndIf
  Gosub activatesourcewindow
  If console_wb = True Then ScreenToFront_ sourceWindow\pedScreen
  !asm
RTS

.com_0_44E2:
  MOVEA.l A0,A2
  MOVEQ.l #$00,D1

 JL_0_44E6:
    ADDQ.w #1,D1
    TST.b (A0)+
  BNE.b JL_0_44E6

  MOVEA.l A2,A1
  SUBQ.w #1,D1
  BPL.w JUMP_JL_0_5F62
RTS

JUMP_JL_0_5F62:
JMP JL_0_5F62


TokenizeSource:
  MOVE.w comWord_DoTokenize,D0
   BNE.w JUMP_setpointer_to_normal
  NOT.w comWord_DoTokenize
  MOVEA.l comPtr_FirstSourceLine,A4
  MOVE.l comLong_TotalLines,-(A7)

 JL_0_450E:
    MOVEQ.l #$00,D1
    MOVE.b $8(A4),D1
    SUBQ.w #1,D1
    BMI.w JL_0_4530
    LEA $9(A4),A2
    MOVEA.l comPtr_Temp_TokenString1,A1
    JSR JL_0_5F62
    MOVE.l A4,comPtr_CurrentSourceLine
    JSR JL_0_55AA

 JL_0_4530:
    MOVEA.l (A4),A4
    SUBQ.w #1,(A7)
  BNE.b JL_0_450E

  ADDQ.w #2,A7
BRA.w JL_0_458E


DetokenizeSource:
  MOVE.w comWord_DoTokenize,D0
   BEQ.w JUMP_setpointer_to_normal
  CLR.w comWord_DoTokenize

 JL_0_454C:
  MOVEA.l comPtr_FirstSourceLine,A4
  MOVE.l comLong_TotalLines,-(A7)

 JL_0_4554:
    LEA $9(A4),A0
    MOVEA.l comPtr_Temp_TokenString1,A1
    JSR detokenize_line
    SUBA.l comPtr_Temp_TokenString1,A1
    ADDQ.w #1,A1
    MOVE.l A1,D5
    MOVE.l A4,comPtr_CurrentSourceLine
    JSR JL_0_55AA
    MOVEA.l (A4),A4
    SUBQ.w #1,(A7)
  BNE.b JL_0_4554
  ADDQ.w #2,A7
RTS


JL_0_457C:
  MOVE.w comWord_DoTokenize,D0
   BEQ.w JUMP_setpointer_to_normal
  CLR.w comWord_DoTokenize
  BSR.b JL_0_454C

 JL_0_458E:
  JSR update_currsourceline
JMP _redraw

JUMP_setpointer_to_normal:
JMP setpointer_to_normal



.event_helpkey
RTS


.update_labellist:
  CLR.l numcount
  !basic
  InitArgParse search_label$
  word1$ = NextArg$
  word2$ = NextArg$
  MOVE.b #0,searchmode
  t.l = 0
  If word2$<>""
    t = 1
    MOVE.b #1,searchmode
  End If
  search_label$ = search_label$
  skip.l = 0
  MOVE.l (a2),straddr
  !asm
  MOVEA.l comPtr_FirstSourceLine,A0
  MOVE.l comLong_TotalLines,D0
  MOVE.b comByte_LabelIdentifier,D1
  MOVE.l A1,-(A7)

  TST.w comWord_LabelAll
  BNE alladd

  TST.w comWord_LabelRemark
  BNE click_remark

 JL_0_467C:
  LEA $9(A0),A1

 JL_0_4680:
  CMPI.b #$20,(A1)                   ;space
  BNE.b 'no
    ADDQ.l #1,a1
    BRA JL_0_4680
 'no
  CMP.w ##TOKEN_Stop,(a1)
  BEQ 'l20
  CMP.w ##TOKEN_TRAP,(a1)
  BEQ 'l20
  CMP.w ##TOKEN_Macro,(a1)          ; added to show Macros in labellist  tomsmart1
  BNE 'nomacro                     ; no, macro
  MOVE.b #2,is_stat_func_macro      ; yes, set it to 2 to identify as macro
  ADDQ.l #2,a1                      ; add 2 to position to get the macroname
  BRA 'l20

 'nomacro
  CMP.w ##TOKEN_Statement,(a1)
   BNE 'nex
  ADDQ #3,a1
  MOVE.l a1,-(a7)
  !skipspace a1
  CMP.w ##TOKEN_Return,(a1)
  BNE 'ok
    MOVE.l (a7)+,a1
    BRA 'nex
 'ok
  MOVE.l (a7)+,a1
  MOVE.b #1,is_stat_func_macro        ; set it to 1 to identify it as Statement or Function
  BRA 'l20

 'nex
  CMP.w ##TOKEN_Function,(a1)
  BNE 'nex2
    ADDQ #3,a1
    MOVE.l a1,-(a7)
    !skipspace a1
    CMP.w ##TOKEN_Return,(a1)
    BNE 'ok
    MOVE.l (a7)+,a1
 'nex2
  CMP.b (A1),D1
  BNE.w JL_0_4696

 'l10
  ADDQ.l #1,a1
  TST.b (a1)
   BEQ JL_0_4696

 'l20
  !skipspace a1
  CMP.b #".",-1(a1)
   BNE 'noformat

 'lnewtype                       ; added to support correct display the name of newtype functions in the labellist  tomsmart1
  ADDQ.l #1,a1                   ; pos +1
  CMP.b #1,is_stat_func_macro    ; test if we have a Statement or Function
   BNE 'nostatfunc               ; no, skip
  CMP.b #" ",(a1)                ; yes, test if it a space
   BNE 'lnewtype                 ; no, we have a newtype
                                 ; yes, end of the functiontype
 'nostatfunc
  !skipspace a1

 'noformat
  CMP.l #"FAST",(a1)
   BNE 'nf
  CMP.b #" ",4(a1)
   BNE 'nf
  ADDQ.l #5,a1

 'nf
  MOVE.w D1,comWord_LabelListChanged
  JSR JL_0_46D6

  JL_0_4696:
  MOVEA.l (A0),A0
  SUBQ .l #1,d0
  BNE JL_0_467C
  MOVEA.l (A7)+,A1
RTS

.alladd
  MOVEM.l d2-d3/a2/a3,-(a7)

  MOVE.l comLong_TotalLines,D0

.click_all
  MOVE.b comByte_LabelIdentifier,D1
  MOVEQ #0,d3
  MOVE.l lowerchartable,a3
 'l15
  MOVE.b #";",d1
  LEA $9(A0),A1
  TST.b (a1)
  BEQ 'nowrite

 'lc1
    CMP.b #" ",(a1)
    BNE 'l1
      ADDQ.l #1,a1
  BRA 'lc1
 'l1

  MOVE.l a1,straddr2
  CMP.b #".",(a1)
  BNE 'l1b
    ADDQ.l #1,a1
    ;BRA 'addlist
 'l1b

  CMP.w ##TOKEN_Stop,(a1)
  BEQ 'addstop
    CMP.w ##TOKEN_TRAP,(a1)
    BEQ 'addstop
      MOVE.l straddr,a2
      CLR.l slen2
 'cok
  MOVE.b (a2)+,d2
  BEQ 'addlist
 'cf
  MOVE.b (a1)+,d3
  TST.b searchmode
  BEQ 'nopat
    BRA 'addlist
 'nopat

  TST.b d3
  BEQ 'nowrite
    TST.b casemode
    BEQ 'lca1
      MOVE.b 0(a3,d3.w),d3            ; convert character to lowercase
 'lca1

  ADD.l #1,slen2
  CMP.b d2,d3
  BEQ 'cok
  MOVE.l slen2,a2
  SUBQ.l #1,a2
  SUB.l a2,a1
  CLR.l slen2
  MOVE.l straddr,a2
  BRA 'cok
 'addstop
  MOVEM.l a0/d0,-(a7)
  MOVE.l a0,d0
  !basic
  s.l = PutD0
  WZTags #WENTRYA_TextPen,2
  s$ = " --Breakpoint---"
  WZListAdd list_labels,s$,0,s
  !asm
  MOVEM.l (a7)+,d0/a0
  BRA 'nowrite
 'v1
 'addlist
  CMP.l #maxlabels,numcount          ;reduce this for slower computers
  BGE 'nowrite
  MOVEM.l a0/d0,-(a7)
  MOVE.l a0,d0
  !basic
  s.l = PutD0
  MOVE.l straddr2,a1
  ;SUB.l slen2,a1
  ;SUBQ.l #5,a1
  MOVE.l a1,a0
  MOVE.l expandstore,a1
  JSR detokenize_line
  MOVE.l expandstore,d0
  i = PutD0
  If i Then s$ = Peek$(i) : Else s$="!NULL!"
   If t
     If Instr(s$,word1$)
         If Instr(s$,word2$)
           WZListAdd list_labels,s$,-1,s
           ADDQ.l #1,numcount
         End If
     End If
   Else
     WZListAdd list_labels,s$,-1,s
     ADDQ.l #1,numcount
   End If

  ADDQ.w #1,comWord_LabelCounter
  !asm
  MOVEM.l (a7)+,d0/a0
 'l15b
 'nowrite
  MOVEA.l (A0),A0
  SUBQ.l #1,d0
  BNE 'l15
 'out
  MOVEM.l (a7)+,d2-d3/a2/a3
  MOVEA.l (A7)+,A1
RTS

.click_remark
  CLR.b instring
  MOVE.b #";",d1
  LEA $9(A0),A1
  TST.b (a1)
  BEQ 'nowrite
'l1  CMP.b #" ",(a1)
  BNE 'l1b
  ADDQ.l #1,a1
  BRA 'l1
'l1b

'co
  CMP.b #".",(a1)
  ;BEQ 'addlist
  CMP.b #$22,(a1)
  BNE 'is1
  NOT.b instring

 'is1
  CMP.w ##TOKEN_Stop,(a1)
  BEQ 'addlist
  CMP.w ##TOKEN_Case,(a1)
  BNE 'l10
  MOVE.l a0,-(a7)
  MOVE.l straddr,a0
  CMP.l #"Case",(a0)
  BNE 'l10a
  !basic
  skip = 1
  !asm
  MOVE.l (a7)+,a0
  ADDQ.l #3,a1
  BRA 'addlist
 'l10a
  MOVE.l (a7)+,a0
 'l10
  CMP.b (a1),d1
  BNE 'skip
 'l5
  ADDQ.l #1,a1
  TST.b instring
  BNE 'nowrite
  TST.b (a1)
  BEQ 'nowrite
  CMP.b #".",(a1)
  BEQ 'nowrite
 'l1s
  CMP.b #" ",(a1)
  BNE 'l1bs
  ADDQ.l #1,a1
  BRA 'l1s
 'l1bs
 'addlist
  CMP.l #maxlabels,numcount          ;reduce this for slow computer
  BGE 'out
  MOVE.w D1,comWord_LabelListChanged
  JSR JL_0_46D6                      ;remarklistadd

 'skip
  TST.b (a1)+
  BNE 'co
 'nowrite
  MOVEA.l (A0),A0
  SUBQ.l #1,d0
  BNE click_remark
 'out
  MOVEA.l (A7)+,A1
RTS

.clear_labellist:
  !basic
  WZListRemove list_labels
  !asm
  CLR.w comWord_LabelCounter
RTS

JL_0_46CC:
  MOVE.w #$FFFF,comWord_LabelListChanged
RTS

.oldlistadd
  MOVEM.l D0-D1/A1-A2,-(A7)
  MOVEQ.l #$08,D0
  MOVE.l #$10000,D1
  MOVEA.l _execbase,A6
  MOVE.l A0,-(A7)
  !newalloc
  TST.l D0
   BEQ.w memAlert_CloseSource

  MOVEA.l (A7)+,A0
  MOVEA.l D0,A2
  MOVE.w comWord_LabelCounter,D1
  BEQ.w JL_0_4714

  MOVEA.l comPtr_LabelList,A1
  SUBQ.w #2,D1
  BMI.w JL_0_470E

  JL_0_4708:
    MOVEA.l (A1),A1
  DBF D1,JL_0_4708

  JL_0_470E:
  MOVE.l A2,(A1)
  BRA.w JL_0_471A

  JL_0_4714:
  MOVE.l A2,comPtr_LabelList

  JL_0_471A:
  MOVE.l A0,$4(A2)
  ADDQ.w #1,comWord_LabelCounter

  MOVEM.l (A7)+,D0-D1/A1-A2
RTS

JL_0_472A:
  MOVE.w #$FFFF,comWord_LabelListChanged
RTS


AL_0_4734:  Ds.l 1

.update_labelstuff:
  CLR.l AL_0_4734
  CMPI.b #$FF,comByte_LabelIdentifier
  BNE.w JL_0_474C
    RTS
  JL_0_474C:

  JSR clear_labellist
  JSR update_labellist
  MOVE.w comWord_LabelCounter,D3

  TST.w comWord_LabelSize
  BEQ.w JL_0_47AA
    MOVE.w comWord_LabelSize,D0
    CMP.w comWord_LabelSizeC,D0
    BEQ.w redraw_labellist
  JL_0_47AA:

  ST AL_0_4734
  MOVE.w clickpos,comWord_LabelSize
  CLR.w comWord_LabelListChanged

  redraw_labellist:
  !basic
  MOVEQ #0,d0
  MOVE.w comWord_LabelCounter,d0
  CMP.l comLong_Label1VisableItem,d0
  BGT 'g1
    CLR.l comLong_Label1VisableItem
 'g1
  MOVE.l comLong_Label1VisableItem,d0 : LabelList_FirstVisableItemNumber = PutD0
  If WZ_CheckOpen{"WIN_LABELS"}
    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels,LabelList_FirstVisableItemNumber
    WZListRemove lib_list.List
    WZPrint "LIBRARY_LIST",0,lib_list
    ;log_Print{"updated labellist: " + Str$(Peek.w(?comWord_LabelCounter))}
  EndIf
  !asm
RTS


AllocPoolMem:
  ;MOVE.w #$FFFF,comWord__AL_0_86C0
  !newalloc  ;AllocPooled(a0:poolHeader, d0:memSize
  TST.l D0
  BEQ.w memAlert_CloseSource
    RTS

memAlert_CloseSource:
  JSR display_memoryalert
  !basic
  If Peek.l(?comPtr_SourceFileHandle) <> 0 Then Close_ Peek.l(?comPtr_SourceFileHandle)
  !asm
  ;MOVE.l comPtr_SourceFileHandle,D1
  ;BEQ.w JL_0_4956
  ;  MOVEA.l _dosbase,A6
  ;  JSR _Close(A6)
  ;JL_0_4956:
  CLR.l comLong_DisplayLineOffset
  CLR.l comLong_DisplayLine
  MOVE.l comPtr_FirstSourceLine,comPtr_CurrentSourceLine
  JSR _redraw
JMP JL_0_CE2


.display_memoryalert:
  !basic
  alert$ = Chr$($00)  ; alert code
  alert$ + Chr$($38)  ; x-position
  alert$ + Chr$($16)  ; y-position
  alert$ + "Not enough memory for that operation! - Click Mousebutton to continue.\00\00"
  DisplayAlert_ $00,&alert$,$28
  !asm
RTS


.set_oldpreferences:
  LEA $C0(A0)  ,A0 : MOVE.l A0,struct_textfont
  ;LEA $1000(A0),A0 : MOVE.l A0,str_windowtitle ; obsolete

  !regs2stack

  ; -- load sourcefont
  JSR open_sourcefonts

  ; -- check/set tokenisation mode
  MOVE.w flag_tokenization,comWord_DoTokenize
  TST.w comWord_DoTokenize
  BEQ.w JL_0_4A76
    TST.l comPtr_TokenBase
    BNE.w JL_0_4A76
      CLR.w comWord_DoTokenize
  JL_0_4A76:

  ; -- add the source history to the menu
  JSR add_history_to_menu

  !stack2regs
RTS

copy_A0_to_A1:
  MOVEM.l A0-A1,-(A7)

  JL_0_4A92:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_4A92

  MOVEM.l (A7)+,A0-A1
RTS


.close_sourcefonts
  If Peek.l(?ptr_sourcefonti)
    If Peek.l(?ptr_sourcefonti)><Peek.l(?ptr_sourcefont)
      CloseFont_ Peek.l(?ptr_sourcefonti)
    End If
    CLR.l ptr_sourcefonti
  End If

  If Peek.l(?ptr_sourcefontb)
    If Peek.l(?ptr_sourcefontb)><Peek.l(?ptr_sourcefont)
      CloseFont_ Peek.l(?ptr_sourcefontb)
    End If
    CLR.l ptr_sourcefontb
  End If

  If Peek.l(?ptr_sourcefont)
    CloseFont_ Peek.l(?ptr_sourcefont)
    CLR.l ptr_sourcefont
  EndIf
Return


.open_sourcefonts:
  !basic
  Gosub close_sourcefonts

  ; open source font
  Poke.w ?textfont_YSize, Peek.w(?sourcefontsize)
  Poke.b ?textfont_Style, Peek.b(?sourcefontstyle)
  Poke.l ?struct_textfont,?str_sourcefontname
  *font.TextFont = OpenDiskFont_ (?struct_textfont)
  If *font = 0
    InitRastPort_ rp.RastPort
    AskFont_ rp,ta.TextAttr ; might be better
    Poke.s ?str_sourcefontname,Peek.s(ta\ta_Name)
    Poke.w ?sourcefontsize    ,ta\ta_YSize
    *font = OpenDiskFont_(ta)
  EndIf
  sourceWindow.sourceWindow\font = *font
  Poke.l ?ptr_sourcefont,*font

  ; open italic font
  Poke.w ?textfont_YSize, Peek.w(?sourcefontsize)
  Poke.b ?textfont_Style, #FSF_ITALIC
  Poke.l ?struct_textfont,?str_sourcefontname
  *fontI.TextFont = OpenDiskFont_ (?struct_textfont)
  If *fontI = 0
    InitRastPort_ rp.RastPort
    AskFont_ rp,ta.TextAttr
    Poke.s ?str_sourcefontname,Peek.s(ta\ta_Name)
    Poke.w ?sourcefontsize    ,ta\ta_YSize
    *fontI = OpenDiskFont_(ta)
  EndIf
  If *fontI\tf_XSize><*font\tf_XSize
    Poke.l ?ptr_sourcefonti,*font
    CloseFont_ *fontI : *fontI = *font
  End If
  sourceWindow\fontI = *fontI
  Poke.l ?ptr_sourcefonti,*fontI

  ; open bold font
  Poke.w ?textfont_YSize, Peek.w(?sourcefontsize)
  Poke.b ?textfont_Style, #FSF_BOLD
  Poke.l ?struct_textfont,?str_sourcefontname
  *fontB.TextFont = OpenDiskFont_ (?struct_textfont)
  If *fontB = 0
    InitRastPort_ rp.RastPort
    AskFont_ rp,ta.TextAttr
    Poke.s ?str_sourcefontname,Peek.s(ta\ta_Name)
    Poke.w ?sourcefontsize    ,ta\ta_YSize
    *fontB = OpenDiskFont_(ta)
  EndIf
  If *fontB
    If *fontB\tf_XSize><*font\tf_XSize
      Poke.l ?ptr_sourcefontb,*font
      CloseFont_ *fontB : *fontB = *font
    End If
  End If
  Poke.l ?ptr_sourcefontb,*fontB
  sourceWindow\fontB = *fontB
  !asm
RTS


valueaddr:  Ds.l 1

.format_value:                       ; A0 = stringbuffer, D0 = Zahl
  MOVE.l a0,valueaddr
  !basic
  value.l = PutD0
  formatstr$ = Peek$(Peek.l(?valueaddr))
  len_fmtstr.b = FLen(formatstr$)
  formatstr$ = StrRight(Str$(value),len_fmtstr,48)  ; mit nullen auffuellen
  Poke$ Peek.l(?valueaddr),formatstr$
  !asm
RTS


.show_newfilerequest:
  MOVE.w comWord_SourceChanged,D0
  BEQ.w JL_0_4DFC
    !basic
    *easystruct.EasyStruct = ?easystruct_loosewarning
    Gosub show_requester
    !asm
    RTS
  JL_0_4DFC:

  MOVE.w #$FFFF,comWord_LabelListChanged
  MOVEQ.l #-$01,D0
RTS

JL_0_4E08:
  ADDQ.l #1,comLong_TotalLines
  MOVE.l (A4),D0
  BEQ.w JL_0_4E20
  MOVEA.l D0,A1
  MOVE.l A1,(A0)
  MOVE.l A0,$4(A1)
  BRA.w JL_0_4E26

  JL_0_4E20:
  MOVE.l A0,comPtr_LastSourceLine

  JL_0_4E26:
  MOVE.l A4,$4(A0)
  MOVE.l A0,(A4)
  MOVEA.l A0,A4
  MOVE.l A4,comPtr_CurrentSourceLine
RTS

JL_0_4E36:
  MOVEA.l comPtr_Temp_TokenString2,A0
  JL_0_4E3A:
    MOVE.b (A0)+,(A3)+
    BEQ.w JL_0_4E46
    BPL.b JL_0_4E3A
    MOVE.b (A0)+,(A3)+
  BRA.b JL_0_4E3A

  JL_0_4E46:
  SUBQ.w #1,A3
RTS

.close_sourcefile:
  TST.w comWord_PasteMode
  BNE.w JL_0_4E64
    CLR.l comPtr_SourceFileHandle
    MOVE.l D7,D1
    MOVEA.l _dosbase,A6
    JMP _Close(A6)
  JL_0_4E64:
;  !basic
;  If Peek.w(?comWord_PasteMode) = 0
;    Poke.l ?comPtr_SourceFileHandle,0
;    Close_
;  EndIf
;  !asm
RTS


.update_title_sourcewindow:
  !basic
  log_Print{"update_title_sourcewindow"}
  SetWindowTitles_ sourceWindow\win,&windowtitle$,-1
  If Peek.b(?load_last_source) <> 0
    last_source$ = Peek$(?comStr_SourceFileComplete)
    If last_source$<>""
      If Instr(last_source$,Peek$(?comStr_SourceName))<>0
        dos_SetToolString{"LAST_SOURCE",last_source$}
      EndIf
    EndIf
  EndIf
  !asm
RTS


.check_fileextension_for_tokenization
  TST.b smart_tokenization
  BEQ 'rt
    CMP.l #".bb2",-5(a1)
    BEQ 'do
      CMP.l #".ab2",-5(a1)
      BEQ 'do
        CMP.l #".ab3",-5(a1)
        BEQ 'do
          CMP.l #".AB3",-5(a1)
          BEQ 'do
            CMP.w #".b",-4(a1)
            BNE 'l1
              CMP.b #"b",-2(a1)
              BEQ 'do
                RTS
   'do
    MOVE.w #$ffff,comWord_DoTokenize
    MOVE.w #$ffff,flag_tokenization
    RTS
 'l1
    CMP.l #".txt",-5(a1)
    BEQ 'no
      CMP.l #".gui",-7(a1)
      BNE 'rt
        CMP.w #"de",-3(a1)
        BNE 'rt
          MOVE.b #1,amigaguide
   'no
    MOVE.w #0,comWord_DoTokenize
    MOVE.w #0,flag_tokenization
 'rt
RTS



.open_sourcefile:                    ; D7: filename & Path
  TST.w comWord_PasteMode
    BNE.w exit_opensourcefile

  MOVE.l D7,D1
  MOVE.l D1,A0
  CLR.b convert
  LEA comStr_SourceFileComplete,A0
 'l10
    TST.b (a0)+
  BNE 'l10
  MOVE.l a1,-(a7)
  MOVE.l a0,a1
  JSR check_fileextension_for_tokenization
  MOVE.l (a7)+,a1
  LEA -5(a0),a2
  CMP.l #".asm",(a2)
  BNE 'l11
    TST.b smart_tokenization
    BEQ 't1
      MOVE.w #$ffff,comWord_DoTokenize
   't1
    MOVE.b #1,convert
 'l11
  MOVEA.l _dosbase,A6
  JSR _Open(A6)                      ; D1: name, D2: accessmode
  MOVE.l D0,D7
  BNE.w file_found
    ADDQ.w #4,A7
    SUBA.l A0,A0
    MOVEA.l #comStr_ErrorOpenFile,A0
    TST.b menuload
    BNE 'lod1
      BRA.w show_errorrequester
   'lod1
    CLR.b menuload
    BRA loadfileerror
  file_found:
  MOVE.l D7,comPtr_SourceFileHandle

  exit_opensourcefile:
RTS



.open_sourcefile_basic:             ; D7: filename & Path, D2: accessmode
  MOVEM.l d2/d7,-(a7)
  !basic
  MOVE.l (a7)+,d0 : accessmode.l = PutD0
  MOVE.l (a7)+,d0 : fptr.l = PutD0
  log_Print{"open_sourcefile"}
  ;-- check if Paste is from File not from Clipboard
  If Peek.w(?comWord_PasteMode) = 0
    fname$ = Peek$(fptr)
    log_Print{"pastemode: insertfile <" + fname$ + ">"}
    Poke.l ?convert,0
    f$ = Peek$(?comStr_SourceFileComplete)
    fext$ = LCase$(dos_GetExt{f$})
    If fext$ = "asm"
      If Peek.b(?smart_tokenization)
        Poke.w ?comWord_DoTokenize, $FFFF
      EndIf
      Poke.b ?convert, 1
    EndIf
    *fh.l = Open_(&fname$, accessmode)
    If *fh
      log_Print{"file opened successfully"}
      Poke.l ?comPtr_SourceFileHandle,*fh
      GetD0 *fh
      MOVE.l d0,d7
    Else
      log_Print{"could not open file <" + fname$ + ">"}
      !asm
      ADDQ.w #4,A7              ; dont know why the stack pointer has to be changed ?
      MOVEA.l #comStr_ErrorOpenFile,A0
      TST.b menuload
      BNE 'lod1
        BRA.w show_errorrequester
     'lod1
      CLR.b menuload
      BRA loadfileerror
    EndIf
  EndIf
  !asm
RTS

.readbyte:
    SUBQ.w #1,D6
    BMI.w JL_0_4EA2
      MOVE.b (A5)+,D0
      CMP.w D0,D0
        RTS
    JL_0_4EA2:

    JSR source_readin
  BNE.b readbyte

  MOVEQ.l #-$01,D0
RTS

.source_readin:                       ; can be clipboard or file
  TST.w comWord_PasteMode
  BEQ.w source_read_from_file_cached ; well, it's from file

  !regs2stack                           ; new line-by-line Code (Thilo)
  !basic
  Poke.l ?clipboard_copylen,0
  Poke.l ?clipboard_copybuffer,?clipboard_dummystr
  clipboard_text.s=""
  If *cH.clipboardHandle = Null Then *cH=clipboard_Open{0} : clipboard_linecount.l=0 ; open clipboard and reset line count

  If *cH
    If clipboard_HasMoreLines{*cH}
      clipboard_text.s = clipboard_GetNextLine{*cH}
      quoted.w = False
      comment.w = False
      For n.l=0 To FLen(clipboard_text)-1
        cchar.w = Peek.b(&clipboard_text+n) & $FF
        If cchar = $22 Then quoted = 1-quoted ; detect quotes
        If quoted=False AND cchar=@";" Then comment = True
        If cchar = $a0 Then cchar = @" "      ; non-breaking space => standard space
        If cchar > 127 AND quoted=False AND comment=False Then cchar = @"?"  ; replace non-ASCII characters with ?, if not in string
        Poke.b &clipboard_text+n,cchar
      Next

      Poke.l ?clipboard_copylen,FLen(clipboard_text) ; put this line to copy buffer
      Poke.l ?clipboard_copybuffer,&clipboard_text
      clipboard_linecount+1

      ; PED clipboard fix: if we have more than 1 line in clipboard,
      ; add the 0-Byte To the last line to keep PED from freezing
      If clipboard_HasMoreLines{*cH}=False AND clipboard_linecount>1 Then Poke.l ?clipboard_copylen,FLen(clipboard_text)+1
    Else
      clipboard_Free{*cH}
      *cH = Null
      clipboard_linecount=0
    End If
  End If
  ;If Peek.l(?clipboard_copylen)>0 Then error{"Send clip: "+clipboard_text}:Else error{"clipboard end!"}
  !asm
  !stack2regs
  MOVE.l  clipboard_copylen,D6
  MOVEA.l clipboard_copybuffer,A5
  TST.l D6
  RTS

clipboard_dummystr:   Dc.l 0
clipboard_copylen:    Dc.l 0
clipboard_copybuffer: Dc.l 0

;.source_read_from_file:
;  MOVE.l D7,D1                       ; file handle
;  MOVEA.l comPtr_DosBuffer,A5
;  MOVE.l A5,D2                       ; membuffer
;  MOVE.l #$2000,D3                   ; length
;  MOVEA.l _dosbase,A6
;  JSR _Read(A6)
;  MOVE.l D0,D6
;  BPL.w JL_0_4F18
;    SUBA.l A0,A0
;    MOVEA.l #comStr_ErrorReadFile,A0
;    JSR show_errorrequester
;    MOVEQ.l #$00,D6
;  JL_0_4F18:
;RTS


.source_read_from_file_cached:
;  MOVE.l D7,readcache_fp
  MOVE.l comPtr_SourceFileHandle,readcache_fp
  MOVEA.l comPtr_DosBuffer,A5
  MOVE.l A5,readcache_destptr        ; membuffer
  MOVE.l #$2000,readcache_blocklen   ; length
  !basic
  rc_fp.l         = Peek.l(?readcache_fp)
  rc_destptr.l    = Peek.l(?readcache_destptr)
  rc_readlen.l    = Peek.l(?readcache_readlen)
  rc_offset.l     = Peek.l(?readcache_offset)
  rc_blocklen.l   = Peek.l(?readcache_blocklen)
  rc_cachelen.l   = Peek.l(?readcache_cachelen)
  rc_cacheptr.l   = Peek.l(?readcache_cacheptr)
  rc_dotokenize.l = Peek.l(?readcache_dotokenize)

  If rc_readlen<=0                   ; no file yet!
    ExamineFH_ rc_fp,*rc_fib
    rc_filelen.l = *rc_fib\fib_Size
    If rc_filelen>rc_cachelen
      If rc_cacheptr Then FreeVec_ rc_cacheptr
      rc_cacheptr = AllocVec_(rc_filelen,#MEMF_ANY)
      rc_cachelen = rc_filelen
    End If
    rc_readlen.l = Read_ (rc_fp,rc_cacheptr,rc_filelen)
    ex.s = LCase$(dos_GetExt{Peek.s(&*rc_fib\fib_FileName)})
    If ex="ab2" OR ex="ab3" OR ex="asc"
      rc_readlen = preproc_Tokenize{*PreProcessor,rc_cacheptr,rc_cacheptr,rc_readlen}
    End If
    rc_offset = 0
  End If

  rc_chunklen.l = rc_blocklen
  If rc_chunklen>rc_readlen-rc_offset Then rc_chunklen=rc_readlen-rc_offset
  If rc_chunklen>0
    CopyMem_ rc_cacheptr+rc_offset,rc_destptr,rc_chunklen
    rc_offset + rc_chunklen
  Else
    rc_chunklen   = 0
    rc_readlen = 0
  End If

  Poke.l ?readcache_chunklen ,rc_chunklen
  Poke.l ?readcache_readlen  ,rc_readlen
  Poke.l ?readcache_offset   ,rc_offset
  Poke.l ?readcache_cachelen ,rc_cachelen
  Poke.l ?readcache_cacheptr ,rc_cacheptr
  ;error{"Readfile cached! length="+Str$(rc_rlength)}
  !asm
  MOVE.l readcache_chunklen,d0
  MOVE.l readcache_chunklen,d6
  MOVEA.l comPtr_DosBuffer,A5
  MOVE.l readcache_fp,D7
  TST.l D6
RTS

readcache_fp:         Dc.l 0
readcache_destptr:    Dc.l 0
readcache_filelen:    Dc.l 0
readcache_offset:     Dc.l 0
readcache_blocklen:   Dc.l 0
readcache_readlen:    Dc.l 0
readcache_cacheptr:   Dc.l 0
readcache_cachelen:   Dc.l 0
readcache_chunklen:   Dc.l 0
readcache_dotokenize: Dc.l 0

.newSourcelineFromTempString:
  MOVE.l D5,D0                            ; strlen form D5 to D0
  ADDI.w #$9,D0                           ; add 9
  JSR AllocPoolMem                        ; return memaddress in D0/A0

  JSR init_sourceline                     ; init sourcelinestruct at New memadress
                                          ; clr pointer to previous/next line, set stringlength byte

  MOVEA.l comPtr_Temp_TokenString2,A1     ; copy stored source string to new sourceline
  LEA $9(A0),A0
  JL_0_4F3A:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_4F3A

  ;-- check if there is an label in the new line and set update flag for labellist
  MOVEA.l D0,A0                           ; memaddress again in A0
  MOVE.b comByte_LabelIdentifier,D0

  MOVE.l A1,-(A7)                         ; skip spaces
  LEA $9(A0),A1
  JL_0_4F4A:
    CMPI.b #$20,(A1)+
  BEQ.b JL_0_4F4A
  CMP.b -(A1),D0                          ; and check if Label at the beginning?
  MOVEA.l (A7)+,A1
  BRA.w JL_0_46CC                         ; set labelchangedflag an return
  ;MOVE.w #$FFFF,comWord_LabelListChanged
RTS

JL_0_4F5A:
  JSR readbyte
  BMI.w JL_0_500C                    ;move a line

  MOVEA.l tempstore,A0
  MOVEQ.l #$00,D4

  JL_0_4F68:
  TST.b D0
  BPL.w JL_0_4F82
    MOVE.b D0,(A0)+
    MOVE.l A0,-(A7)
    JSR readbyte
    MOVEA.l (A7)+,A0
    BMI.w JL_0_4FD2
    MOVE.b D0,(A0)+
    BRA.w JL_0_4FB6
  JL_0_4F82:

  CMP.b #$A,D0
  BNE.w JL_0_4F8E                   ;end line clipboard

  TST.b (a5)
  BNE 'c2
    SUBQ.l #$1,d6
    ADDQ #1,a5
 'c2
  CMP.l #"STYL",(a5)
  BEQ 's1
    CMP.l #"COLS",(a5)
    BNE 'c1
      MOVE.l 4(a5),d0
      ADDQ.l #8,a5
      SUBQ.l #8,d6
      ADD.l d0,a5
      SUB.l d0,d6
    BRA 'c2
 's1
    SUBQ.l #4,d6
    CMP.l #0,4(a5)
    BNE 'c1
      SUBQ.l #4,d6
      CMP.l #"CHRS",8(a5)
      BNE 'c1
        SUBQ.l #4,d6
        CMP.b #0,12(a5)
        BNE 'c1
        SUBQ.l #4,d6
        ADD.w # 16,a5
 'c1
  MOVEQ.l #$00,D0
  MOVEQ.l #-$01,D4

  JL_0_4F8E:
  MOVE.b D0,(A0)+
  BEQ.w JL_0_5002

  CMP.b #$9,D0
  BNE.w JL_0_4FB6

  SUBQ.w #1,A0
  MOVE.l A0,D0
  SUB.l comPtr_Temp_TokenString2,D0

  JL_0_4FA4:
  MOVE.b #$20,(A0)+
  ADDQ.w #1,D0
  MOVE.l D0,D1
  DIVU tab_size,D1
  SWAP D1
  TST.w D1
   BNE.b JL_0_4FA4

  JL_0_4FB6:
  ADDQ #3,a0
  CMPA.l comPtr_Temp_TokenString3,A0
   BCS.w JL_0_4FC8
  MOVEA.l comPtr_Temp_TokenString3,A0
  ;SUBQ.w #3,A0
  BRA.w JL_0_4FD2

  JL_0_4EA2b
  MOVE.l A0,-(a7)
  JSR JL_0_4EA2
  MOVE.l (A7)+,a0
  BRA load

  JL_0_4FC8:
  SUBQ #3,a0
  SUBQ.w #1,D6
  BMI.w JL_0_4EA2b
  MOVE.b (A5)+,D0
  CMP.w d0,d0
   ;jsr readbyte
load
  BPL.b JL_0_4F68
  JL_0_4FD2:
  CLR.b (A0)+
  SUBA.l comPtr_Temp_TokenString2,A0
  MOVE.l A0,D5
  MOVEQ.l #$00,D0

  JL_0_4FDC:
  MOVE.w D0,-(A7)
  TST.w D4                           ;-1 ascii
  BEQ.w JL_0_4FFE
    MOVE.w comWord_DoTokenize,D2
    BEQ.w JL_0_4FFE
      SUBQ.w #1,D5
      BPL.w JL_0_4FFA
        MOVEQ.l #$01,D5
        BRA.w JL_0_4FFE
      JL_0_4FFA:
        JSR import_start
  JL_0_4FFE:
  MOVE.w (A7)+,D0
RTS

JL_0_5002:
  SUBA.l comPtr_Temp_TokenString2,A0
  MOVE.l A0,D5
  MOVEQ.l #$01,D0
  BRA.b JL_0_4FDC

  JL_0_500C:
  MOVEQ.l #-$01,D0
RTS


.import_start:
  MOVEM.l D1-D4/D6-D7/A0-A6,-(A7)
  MOVE.w D5,D1
  MOVEA.l comPtr_Temp_TokenString2,A1
  CLR.b instring
  LEA tempbuf,a2
  TST.b convert
  BEQ 'l2b  ;'l1

  ;BRA 'l2b                         ; convert is done with preproc
  ;CMP.w #122,d1
  ;BLE 'noclip
  ;MOVE.w #122,d1
  ;MOVE.w d1,d5
 'noclip
  CMP.b #".",(a1)
  BNE 'l1

  MOVE.w #"'l",(a2)+
  ADDQ.w #1,d5                       ;add 1 additional char
  ADDQ.l #1,a1
  BRA 'ln1
 'l1 TST.b convert
  BNE 'l1a
 'l1b
  MOVE.b (a1)+,d0
  BEQ 'exit
  MOVE.b d0,(a2)+
  DBF d1,'l1b
  BRA 'exit
 'l1a
  CMP.w #"\@",(a1)
  BNE 'ln1
  MOVE.w #"'l",(a2)+
  ADDQ.l #2,a1
 'n3
  MOVE.b (a1)+,d0
  BEQ 'n2
  CMP.b #" ",d0
  BEQ 'n2
  CMP.b #":",d0
  BEQ 'n2
  MOVE.b d0,(a2)+
  BRA 'n3
 'n2
     SUBQ.l #1,a1
     MOVE.l #"l`@ ",(a2)+
     ADDQ.w #4,d5
 'ln1 CMP.b #";",(a1)   ;-1
      BEQ 'l2c
    CMP.b #$22,(a1)     ;-1
    BNE 'l2b
    TST.b instring
    BEQ 'l2c
    CLR.b instring
    BRA 'l2b
 'l2c   MOVE.b #1,instring
 'l2b
  MOVE.b (a1)+,d0
  BEQ 'exit
  TST.b instring                     ;do only if no string
  BNE 'l5
  TST.b convert
  BEQ 'l5
  ;BRA 'l5
  CMP.b #".",d0
  BNE 'l2
  CMP.b #",",-2(a1)
  BEQ 'l500
    CMP.b #" ",-2(a1)
    BNE 'l2
 'l500
  ADDQ.w #1,d5
  MOVE.b #"'",(a2)+
  MOVEQ #"l",d0
 'l2
  CMP.b #"_",-2(a1)
  BEQ 'l4
   ;TST.b instring
   ;BNE 'l5
  CMP.l #"grap",-1(a1) : BEQ 'l3
  CMP.l #"dosb",-1(a1) : BEQ 'l3
  CMP.l #"intu",-1(a1) : BEQ 'l3
  CMP.l #"Allo",-1(a1) : BEQ 'l3
  CMP.l #"Free",-1(a1) : BEQ 'l3
  CMP.l #"Wait",-1(a1) : BEQ 'l3
  CMP.l #"\",d0
  BNE 'p1
    MOVE.b #"`",d0
 'p1
  CMP.l #"end",-1(a1)
  BEQ 'l4a                           ;endm
    CMP.l #"END",-1(a1)
    BNE 'l4
 'l4a
  CMP.b #"m",3(a1)
  BEQ 'l44a
    CMP.b #"M",3(a1)
    BNE 'l4
'l44a
  CMP.b #" ",4(a1)
  BEQ 'l444a
    CMP.b #";",4(a1)
    BEQ  'l444a
      TST.b 4(a1)
      BNE 'l4
 'l444a
  MOVE.l #"end ",(a2)+
  MOVE.l #"macr",(a2)+
  MOVE.b #"o",d0
  ADD.w #9,d5
  ADDQ.l #4,a1
 'l4
  CMP.l #" mac",-1(a1)
               ;BRA 'l4c              ;macro
  BEQ 'l4b

  CMP.l #" MAC",-1(a1)
  BNE 'l4c
 'l4b
  CMP.w #"ro",3(a1)
  BEQ 'l44b

  CMP.w #"RO",3(a1)
  BNE 'l4c

 'l44b
  CMP.b #" ",5(a1)
  BEQ 'l444b
  CMP.b #";",5(a1)
  BEQ  'l444b
  TST.b 5(a1)
  BNE 'l4c

 'l444b
     ADDQ.l #5,a1
     ADDQ.w #2,d5
     MOVE.b #" ",(a2)+
     MOVE.l #"macr",(a2)+
     MOVE.w #"o ",(a2)+
     SUBQ.w #5,d1
     MOVE.l a1,-(a7)
     MOVEA.l comPtr_Temp_TokenString2,A1

 'n3b
    MOVE.b (a1)+,d0
    BEQ 'n2b

    CMP.b #" ",d0
    BEQ 'n2b

    CMP.b #":",d0
    BEQ 'n2b

    MOVE.b d0,(a2)+
    ADDQ.w #1,d5
  BRA 'n3b
 'n2b

  MOVEQ #0,d0
  MOVE.l (a7)+,a1
'l4c
  CMP.l #"ovem",(a1)
  BEQ 'mm
  CMP.l #"OVEM",(a1)
  BNE 'mm6
'mm  CMP.b #"m",-1(a1)
  BEQ 'mm2
  CMP.b #"M",-1(a1)
  BNE 'mm6
'mm2
  MOVE.l a1,a0
  MOVEQ #0,d2
'mm3
  MOVE.b (a0)+,d3
  BEQ 'mm6

  CMP.b #"(",d3
  BEQ 'mm6

  CMP.b #"-",d3
  BNE 'mm4
    MOVEQ #1,d2
 'mm4
  CMP.b #"/",d3
  BNE 'mm5
    MOVEQ #1,d2
 'mm5
  CMP.b #",",d3
  BNE 'mm3
  TST.l d2
  BNE 'mm6
  MOVE.b #$20,3(a1)
  SUBQ.l #1,a1
  MOVE.l (a1)+,(a2)+
  MOVE.w (a1)+,(a2)+
  SUBQ #6,d1
  BRA 'b1
 'mm6
;CMP.w #".W",-1(a1)
;BNE 'l5
;TST.b 1(a1)
;BNE 'l5
;MOVEQ #0,d0
;SUBQ.l #2,d1
 'l5
  MOVE.b d0,(a2)+
 'b1
  DBF d1,'l1

 'exit
  CMP.b #$0d,-1(a2)
  BNE 'nd0
    CLR.b -1(a2)
    SUBQ.w #1,d5
 'nd0
  CLR.b (a2)
  MOVE.w d5,d1
  MOVEA.l comPtr_Temp_TokenString2,A1
  LEA tempbuf,a2
  ;MOVEA.l A1,A2
 'l10:
  JSR JL_0_5F62
  MOVEA.l comPtr_Temp_TokenString2,A2
  TST.b convert
  BEQ 'l21
  MOVEQ #0,d0
  MOVE.b (a2)+,d0
  CMP.b #" ",d0
  BNE 'l21
 'l20
  MOVE.b (a2)+,d0
  BEQ 'l21
  CMP.b #" ",d0
  BEQ 'l20
  CMP.b #";",d0
  BEQ 'l21
  CMP.w #$80,d0
  BGE 'l21
  MOVE.b #"!",-2(a2)
 'l21
  MOVEM.l (A7)+,D1-D4/D6-D7/A0-A6
  RTS

 'l3
  ADDQ.l #1,d5
  MOVE.b #"_",(a2)+
BRA 'l4


.detokenize_line:                    ; input A0: tokenized string; returns A1: detokenized string
  CLR.b instring3

  detokenize_line2
    TST.w comWord_DoTokenize
     BEQ.w JL_0_5054
    MOVEQ.l #$00,D0
    MOVE.b (A0)+,D0
    BEQ.w JL_0_5050
    CMP.b #$22,d0
     BNE 'l1
    NOT.b instring3
   'l1
    TST.b instring3
    BNE 'l2
    TST.b d0
    BMI.w JL_0_5040
   'l2
    MOVE.b D0,(A1)+
    BNE.b detokenize_line2

    JL_0_5040:
    LSL.w #8,D0
    MOVE.b (A0)+,D0
    JSR token_to_ascii

    JL_0_5048:
      MOVE.b (A3)+,(A1)+
    BNE.b JL_0_5048
    SUBQ.w #1,A1
  BRA.b detokenize_line2

  JL_0_5050:
  CLR.b (A1)
RTS

JL_0_5054:
  MOVE.l A3,-(A7)
  MOVEA.l A0,A3
  JSR copy_A0_to_A1
  MOVEA.l (A7)+,A3
RTS


JL_0_5060:
  TST.b keepstring
  BNE 'l1
    CLR.b instring2
 'l1
  TST.b comWord__AL_0_8668
   BEQ.w JL_0_5072

  JL_0_506A:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_506A
  SUBQ.w #1,A1
RTS

JL_0_5072:
JL_0_5072a
  MOVEQ.l #$00,D0
  MOVE.b (A0)+,D0
  BEQ.w JL_0_5096
  CMP.b #$22,d0
  BNE 'l10
  NOT.b instring2
 'l10
  TST.b instring2
  BNE 'l11
  TST.b d0
  BMI.w JL_0_5082                    ;morechar
 'l11
  MOVE.b D0,(A1)+
  BNE.b JL_0_5072a

  JL_0_5082:
  LSL.w #8,D0
  MOVE.b (A0)+,D0
  JSR token_to_ascii

  JL_0_508A:
    MOVE.b (A3)+,D1
    BEQ.b JL_0_5072a
    BSET #$7,D1
    MOVE.b D1,(A1)+
  BRA.b JL_0_508A

  JL_0_5096:
  CLR.b (A1)
RTS


.token_to_ascii:
  ;MOVEA.l comPtr_TokenBase,A3       ;findtokenlib $80
  BCLR #$F,D0
  LEA instrtab,a3

  Dc.l $26730400 ;Dc.l $26730600 MOVE.l 0(a3,d0.w*4),a3
  CMP.l #0,a3
  BNE 'l10
  MOVEA.l comPtr_TokenBase,A3
 'JL_0_50A2:
    CMP.w $4(A3),D0
     BEQ.w JL_0_50B4
    TST.l (A3)
     BEQ.w JL_0_50B8
    MOVEA.l (A3),A3
  BRA.b 'JL_0_50A2
 'l10
  ADDQ.w #6,A3
  RTS

  JL_0_50B4:
  MOVE.l a1,-(a7)
  LEA instrtab,a1

  Dc.l $238B0400 ; MOVE.l a3,0(a1,d0.w*4)
  MOVE.l (a7)+,a1
  ADDQ.w #6,A3
  RTS

 JL_0_50B8:
  ;LEA comStr_TokenError,A3
  ;RTS
  !basic
  i = PutD0
  temp$ = "????Lib "+Str$(i LSR 7)+"/"+Str$((i AND $7f)-1)
  MOVE.l temp@(a5),d0
  !asm
  MOVE.l d0,a3
RTS


.do_aslfilerequest:
  LEA comStr_ASLDummyPath,A0
  LEA comStr_ASLDummyDir,A1
  LEA comStr_FilePattern_NoInfo,A3
BRA.w aslrequest_file


.do_aslloadfilerequest:
  LEA comStr_ASLLoadFile,A2          ; asl title
  do_aslsavefilerequest:
  LEA comStr_CurrentDir,A0           ; asl dir
  LEA comStr_SourceName,A1           ; asl path
  LEA comStr_FilePattern,A3          ; file pattern (*.bb2 etc.)
BRA.b aslrequest_file


.aslrequest_file:
  MOVE.l #$FFFFFFFF,asl_usepattern
  JSR show_aslfilerequest
  MOVE.l D0,D7
  MOVE.l #$00,asl_usepattern
RTS


asl_usepattern:  Ds.l 1
asl_drawersonly: Ds.l 1
.show_aslfilerequest:
  ; input:
  ; a0: default dir
  ; a1: default file
  ; a2: req title
  ; a3: pattern
  ; a4: -1
  ; a5: -1
  ; a6: windowpointer
  MOVEM.l D1-D7/A0-A6,-(A7)
  MOVEM.l A0-A3,-(a7)
  !basic
  MOVEM.l (A7)+,a0-a3
  MOVE.l a0,D0 : _a0.l = PutD0
  MOVE.l a1,D0 : _a1.l = PutD0
  MOVE.l a2,D0 : _a2.l = PutD0
  MOVE.l a3,D0 : _a3.l = PutD0
  If _a0<>0 Then tmpdir$   = Peek$(_a0)
  If _a1<>0 Then tmpfile$  = Peek$(_a1)
  If _a2<>0 Then tmptitle$ = Peek$(_a2)
  If use_filepattern <> 0
    If Peek.l(?asl_usepattern)<>0
      If _a3<>0 Then tmppattern$ = Peek$(_a3)
    Else
      tmppattern$ = Peek$(?comStr_FilePattern_NoInfo)
    EndIf
  Else
    tmppattern$ = ""
  EndIf
  If use_asldims
    asl_SetRequesterDims{Peek.l(?aslreq_x),Peek.l(?aslreq_y),Peek.l(?aslreq_width),Peek.l(?aslreq_height)}
  EndIf
  aslfr_SetRequesterTitle{1,!TRANS{tmptitle$},"",""}
  aslfr_SetPattern{1,tmppattern$}
  aslfr_SetPath{1,tmpdir$}
  aslfr_SetFile{1,tmpfile$}
  If aslfr_Request{1,False,False,Peek.l(?asl_drawersonly)}
    tempdir$      = aslfr_GetPath{1}
    tempfile$     = aslfr_GetFile{1}
    tempcomplete$ = dos_AddPart{tempdir$ , tempfile$}
  Else
    tempfile$ = ""
  EndIf
  If tempfile$<>""
    Poke.s ?comStr_SourceFileComplete,tempcomplete$
    Poke.s _a0,tempdir$
    Poke.s _a1,tempfile$
    GetD0 ?comStr_SourceFileComplete
  Else
    MOVEQ.l #0,D0
  EndIf
  !asm
  MOVE.l D0,-(a7)
  JSR save_tempprefs
  MOVE.l (a7)+,D0
  CLR.l asl_drawersonly
  MOVEM.l (A7)+,D1-D7/A0-A6
  MOVEA.l D0,A0
  TST.b D0
  BEQ.w exit_aslfilereq
    TST.b (A0)
    BNE.w exit_aslfilereq
      MOVEQ.l #$00,D0
  exit_aslfilereq:
RTS

.show_errorrequester:  ; A0: Errortext, A1:
  MOVE.l D7,-(A7)

  MOVE.l A0,ptr_errortext
  CMP.l #0,a5
  BNE 'l4
    LEA dummystr + 1,a5
 'l4
  MOVEQ #20,d0
  MOVE.l a5,a0                       ;macro title
  SUBQ.l #1,a0
 'l2
    MOVE.b -(a0),d1
    BEQ 'l1
      CMP.b #":",d1
      BEQ 'l1
        SUBQ.l #1,d0
  BNE 'l2
 'l1
  ADDQ #1,a0
  LEA helpstring,a1
  CMP.l #"INLN",a6
  BNE 'l1x
    LEA helpstring,a1
    ADDQ #4,a1
    MOVE.b #32,(a1)+
 'l1x

  MOVEQ #60,d1
 'l5
    MOVE.b (a0)+,d0
    BEQ 'n1
    MOVE.b d0,(a1)+
    SUBQ.l #1,d1
  BNE 'l5
 'n1
  CLR.b (a1)+
  LEA helpstring,a0
  TST.b (a0)
  BNE 'l1b
    ADDQ.l #4,a0
 'l1b
  MOVE.l expandstore,a1
  JSR detokenize_line
  MOVE.l expandstore,a1

  MOVE.l a1,ptr_errortitle
  ;MOVE.b #">",(a1)
 'l8
    MOVE.b (a1)+,d0
    BEQ 'l9
    CMP.b #":",d0
  BNE 'l8
  ;MOVE.b #"<",-1(a1)
 'l9
  !regs2stack
  !basic
  fid.l = file_Open{dos_AddPart{my_systemdir$,"ab_compileerror.txt"},#file_read}
  If fid <> -1
    errormessage$  = file_ReadLine{fid}
    sourceline$    = file_ReadLine{fid}
    sourcename$    = file_ReadLine{fid}
    l$             = file_ReadLine{fid}
    compilestatus$ = file_ReadLine{fid}
    file_Close{fid}
    If sourcename$ <> "none"              ; open source file with error
      GetD0 &sourcename$
      If Exists (sourcename$)
        GetD0 &sourcename$
        !asm
        JSR loadfile
        JSR draw_statusarea
        JSR update_vertscroller
        !basic
      End If
    End If
  Else
    sourceline$ = ""
  End If

  ; building the inforequester:
  errortitle$ = !TRANS{"Compile Error"}
  errortext$ = Peek.s(Peek.l(?ptr_errortext))
  If sourceline$<>""
    errortext$ = !TRANS{"Compile error in line"} + " " + sourceline$ + ":\\n\\n" + errortext$
  EndIf
  dummy.l = ask{errortext$,!TRANS{"OK"},errortitle$}
  !asm
  !stack2regs
  MOVE.l (A7)+,D7
RTS

.loadfileerror
  MOVE.l D7,-(A7)
  MOVE.l A0,ptr_errortext
  !basic
  log_Print{"showing load error requester"}
  *easystruct.EasyStruct = ?easystruct_error
  *easystruct\es_TextFormat = Peek.l(?ptr_errortext)
  Gosub show_requester
  UnlockAllOpenWZWin{}
  Gosub set_pointer_normal_bas
  !asm
  MOVE.l (a7)+,d7
RTS

.show_requester:
  If *easystruct <> 0
    req_title.s  = Peek$(*easystruct\es_Title)
    req_text.s   = Peek$(*easystruct\es_TextFormat)
    req_gadtex.s = Peek$(*easystruct\es_GadgetFormat)
    dummy.l      = ask{!TRANS{req_text},!TRANS{req_gadtex},!TRANS{req_title}}
    *easystruct = 0
  EndIf
Return


.flush_intuimessages:
  TST.l ptr_sourcewindow
  BEQ.w exit_check_intuimessage
    MOVEA.l ptr_sourcewindow,A2
    MOVEA.l _execbase,A6
    MOVEA.l $56(A2),A2                 ; Window\UserPort

    JL_0_5460:
      MOVEA.l A2,A0
      JSR _GetMsg(A6)
      TST.l D0
      BEQ.b exit_check_intuimessage
        MOVEA.l D0,A1
        JSR _ReplyMsg(A6)
    BRA.b JL_0_5460
  exit_check_intuimessage:
RTS


JL_0_5474:
  CMPI.l #$1,comLong_TotalLines
  BEQ.w JL_0_54EA
  SUBQ.l #1,comLong_TotalLines
  MOVE.l (A5),D1
  MOVE.l $4(A5),D2
  BEQ.w JL_0_54A4
  TST.l D1
  BEQ.w JL_0_54B4
  MOVEA.l D2,A0
  MOVE.l D1,(A0)
  MOVEA.l D1,A0
  MOVE.l D2,$4(A0)
  BRA.w JL_0_54BE

  JL_0_54A4:
  MOVE.l D1,comPtr_FirstSourceLine
  MOVEA.l D1,A0
  CLR.l $4(A0)
  BRA.w JL_0_54BE

  JL_0_54B4:
  MOVE.l D2,comPtr_LastSourceLine
  MOVEA.l D2,A0
  CLR.l (A0)

  JL_0_54BE:
  MOVEA.l A5,A1
  MOVE.b comByte_LabelIdentifier,D0
  MOVE.l A0,-(A7)
  LEA $9(A1),A0

  JL_0_54CA:
    CMPI.b #$20,(A0)+
  BEQ.b JL_0_54CA

  CMP.b -(A0),D0
  MOVEA.l (A7)+,A0
  BNE.w JL_0_54Dca
    JSR JL_0_472A
  JL_0_54Dca:
  ;ST comWord__AL_0_86C0
  MOVEA.l _execbase,A6
  !newfree
RTS

JL_0_54EA:
   JSR JL_0_5B08
BRA.b JL_0_54BE


.move_to_blockstarty:                ; in A4: currentsourceline, out A5: adjusted currentsourceline
  MOVEA.l A4,A5                      ; -- copy currentline to A5
  MOVE.l comLong_DisplayLineOffset,D7
  ADD.l comLong_DisplayLine,D7
  MOVE.l D7,D6

  CMP.l comLong_BlockStartY,D6
  BEQ.w JL_0_5522
    BCC.w JL_0_5516

    JL_0_5508:
      MOVEA.l (A5),A5
      ADDQ.l #1,D6
    CMP.l comLong_BlockStartY,D6
    BNE.b JL_0_5508

    BRA.w JL_0_5522

    JL_0_5516:
      MOVEA.l $4(A5),A5
      SUBQ.l #1,D6
    CMP.l comLong_BlockStartY,D6
    BNE.b JL_0_5516
  JL_0_5522:
RTS

JL_0_5524:
  BSR.b move_to_blockstarty
  MOVE.w comLong_BlockStartX,D5

  MOVE.w comWord_DoTokenize,D0
  BEQ.w JL_0_5538
    BRA.w JL_0_553A
  JL_0_5538:

RTS

JL_0_553A:                                  ; sourcelinepointer in A5, returns
  MOVEA.l comPtr_Temp_TokenString3,A0
  CMP.l #0,a5
  BEQ 'l1
    LEA $9(A5),A1
    ADDQ.w #1,A0
    JSR JL_0_5556
    MOVE.l A0,D0
    SUB.l comPtr_Temp_TokenString3,D0
    MOVEA.l comPtr_Temp_TokenString3,A0
    MOVE.b D0,(A0)
 'l1
RTS

JL_0_5556:
  CLR.b instring3

  JL_0_5556b:
    MOVE.b (A1)+,D0                    ;cut token
    BEQ.w JL_0_5574

      CMP.b #$22,d0
      BNE 'l1
        NOT.b instring3
     'l1
      TST.b instring3
      BNE 'l2
        TST.b d0
        BMI.w JL_0_5564
     'l2
        MOVE.b D0,(A0)+
        BRA.b JL_0_5556b
      JL_0_5564:

      LSL.w #8,D0
      MOVE.b (A1)+,D0
      JSR token_to_ascii
      JL_0_556C:
        MOVE.b (A3)+,(A0)+
      BNE.b JL_0_556C
      SUBQ.w #1,A0
    BRA.b JL_0_5556b

  JL_0_5574:
RTS

.update_currsourceline:
  MOVEA.l comPtr_FirstSourceLine,A4
  MOVE.l comLong_DisplayLineOffset,D0
  ADD.l comLong_DisplayLine,D0
  BEQ.w JL_0_558E
  ;SUBQ.l #1,D0
  JL_0_5588:
    MOVEA.l (A4),A4
    SUBQ.l #1,d0
    ; DBF D0,JL_0_5588
  BNE JL_0_5588

  JL_0_558E:
  MOVE.l A4,comPtr_CurrentSourceLine
RTS

JL_0_5596:
  MOVE.l A3,D5
  SUB.l comPtr_Temp_TokenString1,D5
  ADDQ.l #1,D5
BRA.w JL_0_55AA

JL_0_55A2:
  MOVEA.l comPtr_Temp_TokenString2,A2
  JSR parse_line

  JL_0_55AA:
  MOVE.l D5,D0
  ADDI.w #$9,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  JSR AllocPoolMem
  MOVEA.l D0,A0
  MOVEA.l comPtr_Temp_TokenString1,A1
  MOVE.b comByte_LabelIdentifier,D0
  MOVE.l A1,-(A7)

  JL_0_55C6:
    CMPI.b #$20,(A1)+
  BEQ.b JL_0_55C6
  CMP.b -(A1),D0
  ;BNE.w JL_0_55D8                  ;clickpretest
  BEQ 'l10
 'l20
    MOVE.b (a1),d0                     ;pre clicksort
    BEQ JL_0_55D8
      CMP.b #";",d0
      BEQ 'l10
        CMP.b #$80,d0
        BNE 'l15
          CMP.b #$2d,1(a1)                   ;token stop
          BEQ 'l10
            CMP.b #$ae,1(a1)                 ;token trap
            BEQ 'l10
       'l15
          ADDQ.l #1,a1
  BRA 'l20
 'l10
  ;JSR JL_0_46CC
  MOVE.w #$FFFF,comWord_LabelListChanged

  JL_0_55D8:
  MOVEA.l (A7)+,A1
  CMPA.l comPtr_FirstSourceLine,A4
  BNE.w JL_0_55E6
    MOVE.l A0,comPtr_FirstSourceLine
  JL_0_55E6:

  CMPA.l comPtr_LastSourceLine,A4
  BNE.w JL_0_55F4
    MOVE.l A0,comPtr_LastSourceLine
  JL_0_55F4:

  MOVE.b D5,$8(A0)
  MOVE.l $4(A4),D1
  BEQ.w JL_0_5604
    MOVEA.l D1,A1
    MOVE.l A0,(A1)
  JL_0_5604:

  MOVE.l D1,$4(A0)
  MOVE.l (A4),D1
  BEQ.w JL_0_5614
    MOVEA.l D1,A1
    MOVE.l A0,$4(A1)
  JL_0_5614:

  MOVE.l D1,(A0)
  MOVEA.l A0,A4
  LEA $9(A0),A0
  MOVEA.l comPtr_Temp_TokenString1,A1

  JL_0_5620:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_5620
  JSR JL_0_6C04
  MOVE.l A4,comPtr_CurrentSourceLine
RTS

JL_0_5630:
  CMP.w comWord_MaxColumns,D5
  BGE.w JL_0_568C                        ; if D5>Maxcolumns, d5=0,d6=0, exit
    CMP.l comLong_BlockEndY,D6
    BCS.w JL_0_5650
    BNE.w JL_0_564C
      CMP.w comLong_BlockEndX,D5
      BLS.w JL_0_5650
    JL_0_564C:
  MOVEQ.l #-$01,D0
RTS

JL_0_5650:
  ADDQ.w #1,D5
  MOVE.w comWord_DoTokenize,D0
  BEQ.w JL_0_5670
    MOVEA.l comPtr_Temp_TokenString3,A3
    CMP.b (A3),D5
    BCC.w JL_0_5680
      MOVEQ.l #$00,D0
      MOVE.b $0(A3,D5.W),D0
      TST.w D0
        RTS
  JL_0_5670:
  CMP.b $8(A5),D5
  BCC.w JL_0_5680
    MOVEQ.l #$00,D0
    MOVE.b $8(A5,D5.W),D0
    RTS
  JL_0_5680:
  MOVE.w comWord__AL_0_8AD8,D0
  BNE.w JL_0_568C
    MOVEQ.l #$20,D0
    RTS
  JL_0_568C:
  MOVEA.l (A5),A5
  ADDQ.l #1,D6
  MOVEQ.l #$00,D5
  MOVEQ.l #$00,D0
RTS

.reset_Blockflag:
  MOVE.w #$FFFF,store_BlockStartX
  MOVE.l #$ffffFFFF,comLong_BlockEndY
RTS

JL_0_57B6:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w JL_0_57DE
    CMP.l comLong_BlockEndY,D0
    BHI.w JL_0_57DE
      ADDQ.l #1,comLong_BlockEndY
      CMP.l comLong_BlockStartY,D0
        BHI.w JL_0_57DE
          ADDQ.l #1,comLong_BlockStartY
  JL_0_57DE:
RTS


JL_0_57E0:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w JL_0_57F0
    JSR _redraw
  JL_0_57F0:
RTS

.update_scroller:
  MOVE.w comWord_Column,-(A7)
  MOVE.l comLong_DisplayLine,-(A7)
  MOVEM.w D2-D3/D5,-(A7)

  SUB.w comWord_ColumnsOffset,D2
  BPL.w JL_0_5808
    MOVEQ.l #$00,D2
    BRA.w JL_0_5816
  JL_0_5808:
    CMP.w comWord_MaxColumns,D2
    BCS.w JL_0_5816
      MOVE.w comWord_MaxColumns,D2
      SUBQ.w #1,D2
  JL_0_5816:

  MOVE.w D2,comWord_Column
  MOVE.w D3,comLong_DisplayLine+2
  JSR update_horizscroller
  JSR update_vertscroller

  MOVEM.w (A7)+,D2-D3/D5
  MOVE.l (A7)+,comLong_DisplayLine
  MOVE.w (A7)+,comWord_Column
RTS


.AbsBlockDimensions:
  MOVE.w comLong_BlockStartX,D0
  MOVE.l comLong_BlockStartY,D1
  MOVE.w comLong_BlockEndX,D2
  MOVE.l comLong_BlockEndY,D3
  CMP.l D3,D1
  BCS.w JL_0_5872
    BEQ.w JL_0_586E
      JL_0_5850:
      EXG.l D0,D2
      EXG.l D1,D3
      MOVE.w D0,comLong_BlockStartX
      MOVE.l D1,comLong_BlockStartY
      MOVE.w D2,comLong_BlockEndX
      MOVE.l D3,comLong_BlockEndY
      RTS
    JL_0_586E:
    CMP.w D2,D0
    BGT.b JL_0_5850
  JL_0_5872:
RTS

.AbsDimensions:
  CMP.w D3,D1
  BCS.w JL_0_5888
    BNE.w JL_0_5884
      CMP.w D2,D0
      BLE.w JL_0_5888
    JL_0_5884:
    EXG.l D0,D2
    EXG.l D1,D3

  JL_0_5888:
RTS



.getfoldstatus
  CLR.l foldnum
  MOVE.l a1,-(a7)
  MOVE.l comPtr_FirstSourceLine,d0
  BEQ 'out
 'l1
    MOVE.l d0,a1
    CMP.l a2,a1
    BEQ 'out
      CMP.w #";@",9(a1)
      BNE 'l2
        CMP.w #"@1",11(a1)
        BNE 'no1
          MOVE.l #1,foldnum
       'no1
        CMP.w #"@0",11(a1)
        BNE 'no2
          MOVE.l #0,foldnum
       'no2
     'l2
  MOVE.l (a1),d0
  BNE 'l1
 'out
  realline
  MOVE.l (a7)+,a1
RTS

doreverse
'dorev
  CMP.w #"@0",11(a2)                   ;reverse ok !!!
  BNE 'no1
    MOVEM.l d0/a1,-(a7)
    MOVE.l #0,foldnum
    MOVE.l 4(a2),d0
    BEQ 'lp4
   'lp1
      MOVE.l d0,a1                    ;check if previous is ;@@1
      CMP.w #";@",9(a1)
      BNE 'lp2
        CMP.w #"@1",11(a1)
        BNE 'lp3
          MOVE.l #1,foldnum
          BRA 'lp4                             ;block is folded
       'lp3
        CMP.w #"@0",11(a1)
        BEQ 'lp4
     'lp2
      MOVE.l 4(a1),d0
    BNE 'lp1
  'lp4
   MOVEM.l (a7)+,a1/d0
  'no1
  CMP.w #"@1",11(a2)
  BNE 'no2
    MOVE.l #0,foldnum
 'no2
 'l2
;MOVE.l a1,a2
RTS


._redraw:
  MOVEA.l comPtr_CurrentSourceLine,A2       ; if no source available, quit redraw!
  CMPA.l #$0,A2
  BNE.w JL_0_58B6
    RTS
  JL_0_58B6:

  MOVE.l comLong_BlockEndY,-(A7)
  MOVE.l #$ffffFFFF,comLong_BlockEndY
  JSR save_cursorposition
  JSR clear_sourcetextbuffer

CNIF #hardfold = 1
  JSR getfoldstatus
CEND

  MOVE.l comLong_DisplayLine,D1

  JL_0_58BA:
    BEQ.w JL_0_58C6

    MOVE.l $4(A2),d0
    BEQ JL_0_58C6
    MOVE.l d0,a2

CNIF #hardfold = 0
    BRA 'l3
CEND

    CMP.w #";@",9(a2)
    BNE 'l2
      BSR doreverse
      CMP.w #"@0",11(a2)
      BNE 'l2
        TST.l foldnum
        BNE 'l3
   'l2
    TST.l foldnum
    BNE JL_0_58BA
   'l3
    SUBQ.l #1,D1
  BRA.b JL_0_58BA
  JL_0_58C6:

  MOVE.w D1,comLong_DisplayLine+2
;  CLR.l comLong__AL_0_868A
  CLR.w comWord_TextBufferOffset
  CLR.l foldnum
  MOVE.l #-1,ClearEndOfLine
  MOVE.l viewablelines,D7
  SUBQ.l #1,D7
  MOVE.w comWord_ColumnsOffset,comWord_ColumnsOffsetTmp
  MOVE.l comLong_LinePosStartY,d0

  JL_0_58E8:                         ;print whole window
    CNIF #hardfold = 1
   'nr
      CMP.l #";@@1",9(a2)
      BNE 'l1
      MOVE.l #1,foldnum
      BRA 'do
     'l1
      CMP.l #";@@0",9(a2)
      BNE 'l2
      MOVE.l #0,foldnum
     'l2
      MOVE.l comLong_DisplayLine,d0
      CMP.l store_comLong_DisplayLine,d0
      BNE 'l3b
      ;MOVE.l a2,comPtr_CurrentSourceLine
     'l3b
      TST.l foldnum
      BEQ 'do
      MOVE.l (a2),d0
      BEQ JL_0_5902
      MOVE.l d0,a2
    BRA 'nr
   'do
    CEND

    MOVE.l (A2),-(A7)
    JSR print_sourceline
    JSR update_modifiermark
    MOVE.l (A7)+,D0

    BEQ.w JL_0_5902           ; no next line left
      MOVEA.l D0,A2
      JSR increase_DisplayLine
  DBF D7,JL_0_58E8
  JL_0_5902:

  ; -- better refresh: clear bottom
  MOVE.l #0,ClearEndOfLine
  !basic
  USEPATH sourceWindow
  SetAPen_  \win\RPort, AB3Pen(#AB3_cbackground)
  rectx.w = Peek.w(?source_BoxLeft)
  recty.w = Peek.l(?comLong_DisplayLine) * \font\tf_YSize
  rectw.w = Peek.w(?source_BoxWidth)
  recth.w = \statusAreaY
  If (rectw => rectx) AND (recth => recty)
    RectFill_ \win\RPort, rectx, recty, rectw, recth
  Else
    ;SetAPen_ \win\RPort,3
    ;Move_ \win\RPort,rectx,recty
    ;Draw_ \win\RPort,rectx + rectw,recth
    log_Print{"illegal area for clear bottom:",#log_error}
    log_Print{Str$(rectx) + ", " + Str$(rectw)}
    log_Print{Str$(recty) + ", " + Str$(recth)}
  EndIf
  !asm

  JSR restore_cursorposition
  MOVE.l (A7)+,comLong_BlockEndY

  JL_0_590C:
  TST.l comLong_BlockEndY                                 ; draw block if existing
  BMI.w JL_0_59BA
    ;MOVEA.l _graphicsbase,A6
    ;MOVEA.l rp_rectfill,A1
    MOVE.w comLong_BlockStartX,D0
    MOVE.w comLong_BlockEndX,D2
    MOVE.l comLong_BlockEndY,D3
    MOVE.l comLong_BlockStartY,D1
    MOVE.l comLong_DisplayLineOffset,D4
    MOVE.l D4,D5
    ADD.l viewablelines,D5
    SUB.w comWord_ColumnsOffset,D0
    BPL.w JL_0_5954
      MOVEQ.l #$00,D0
    JL_0_5954:

    CMP.l D4,D3
    BLT.w JL_0_59BA
      SUB.l comLong_DisplayLineOffset,D1
      BPL.w JL_0_5968
        MOVEQ.l #$00,D0
        MOVEQ.l #$00,D1
      JL_0_5968:

      SUB.w comWord_ColumnsOffset,D2
      BPL.w JL_0_5974
        MOVEQ.l #$00,D2
      JL_0_5974:

      SUB.l comLong_DisplayLineOffset,D3
      BPL.w JL_0_5980
        MOVEQ.l #$00,D3
      JL_0_5980:

      MOVE.l viewablelines,D5
      CMP.l D5,D1
      BGE.w JL_0_59BA
        CMP.l D5,D3
        BLE.w JL_0_5998
          MOVE.l viewablelines_m1,D3
        JL_0_5998:

        CMP.w visiblecolumns,D2
        BLT.w JL_0_59AA
          MOVE.w visiblecolumns,D2
          SUBQ.w #1,D2
        JL_0_59AA:

        ADD.w comWord_ColumnsOffset,D0
        ADD.w comWord_ColumnsOffset,D2
        BRA.w draw_blockselection
  JL_0_59BA:
RTS


JL_0_59BC:                           ;redraw blockmark
  JSR AbsDimensions

.draw_blockselection:
  MOVEM.l D0-D3/A0-A1,-(A7)
  !basic
  xMin.w = PutD0
  MOVE.l d1,d0 : yMin.w = PutD0
  MOVE.l d2,d0 : xMax.w = PutD0
  MOVE.l d3,d0 : yMax.w = PutD0
  ;xMin = xMin - Peek.w(?comWord_ColumnsOffset)
  ;SetScreenTitle{"Xmin:" + Str$(xMin)}

  If xMin < 0 Then xMin = 0
  If xMax < 0 Then xMax = 0 : Else : xMax = xMax + 1
  If yMin < 0 Then yMin = 0
  If yMax < 0 Then yMax = 0
  xMax = xMax - Peek.w(?comWord_ColumnsOffset)
  xMin = xMin - Peek.w(?comWord_ColumnsOffset)
  If xMax > Peek.w(?visiblecolumns) Then xMax = Peek.w(?visiblecolumns)
  If yMax > Peek.l(?viewablelines_m1) Then yMax = Peek.l(?viewablelines_m1)
  If yMin > Peek.l(?viewablelines_m1) Then yMin = Peek.l(?viewablelines_m1)

  xMin = xMin * \font\tf_XSize
  yMin = yMin * \font\tf_YSize
  xMax = xMax * \font\tf_XSize
  yMax = yMax * \font\tf_YSize
  If yMin > yMax Then Exchange yMax,yMin

  If yMin = yMax
      yMax = yMax + Peek.w(?fontHeightm1)
      Gosub rectfill
  Else
      yMaxold.l = yMax : xMaxold.l = xMax : yMinold.l = yMin : xMinold.l = xMin
      yMax = yMin + Peek.w(?fontHeightm1)
      xMax = Peek.w(?visiblecolumns) * \font\tf_XSize
      Gosub rectfill
      yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold

      yMin = yMin + \font\tf_YSize
      If yMin < yMax
          yMaxold.l = yMax : xMaxold.l = xMax : yMinold.l = yMin : xMinold.l = xMin
          yMax = yMax - 1
          xMax = Peek.w(?visiblecolumns) * \font\tf_XSize
          xMin = 0
          Gosub rectfill
          yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
          xMin = 0
          yMin = yMax
      EndIf

      xMin = 0
      yMax = yMax + Peek.w(?fontHeightm1)
      Gosub rectfill
  EndIf

  !asm
  MOVEM.l (A7)+,D0-D3/A0-A1
RTS

rectfill:
  If (xMax >= xMin) AND (yMax >= yMin)
    xMin = Peek.w(?source_BoxLeft) + xMin
    xMax = Peek.w(?source_BoxLeft) + xMax - 1
;    msg$ =  Str$(xMin) + ", " + Str$(yMin) + ", " + Str$(xMax) + ", " + Str$(yMax)
 ;   log_Print{msg$}
    RectFill_ Peek.l(?rp_rectfill), xMin, yMin, xMax, yMax
;              SetBPen_ Peek.l(?rp_rectfill),3
;               SetDrMd_ Peek.l(?rp_rectfill),#JAM1
;               Move_ Peek.l(?rp_rectfill), xMin,yMin
;               Draw_ Peek.l(?rp_rectfill), xMax,yMax
;               SetDrMd_ Peek.l(?rp_rectfill),#COMPLEMENT

  EndIf
Return


.get_TextPosMouse:
  USEPATH sourceWindow
  mx.w = \win\MouseX - \win\BorderLeft
  my.w = \win\MouseY - \win\BorderTop
  If (mx > Peek.w(?source_BoxLeft)) AND (my > 0) AND (my < \statusAreaY + \win\BorderTop)
    textX.w = mx
    If textX < 0 Then textX = 0
    textX = textX / \font\tf_XSize                                                                                ;
    textY.w = my / \font\tf_YSize
  Else
    textX = -1
    textY = -1
  EndIf
  ;msg$ =  Str$(x) +  ", " + Str$(y) + "      " + Str$(textX) + ", " + Str$(textY)
  ;SetScreenTitle{msg$}
Return


.get_mousepos:                       ; get screenpos for click: return D2: TextX, D3: TextY
  MOVE.l ptr_sourcewindow,a0

  MOVE.w $C(A0),D1                   ; Window\MouseY
  ADD.w #1,D1
  TST.w D1
  BPL.w JL_0_5ACA
    MOVEQ.l #$00,D1
  JL_0_5ACA:

  MOVEQ #0,D2
  MOVE.w win_BorTop,D2               ; Window\BorderTop was win_BorTop    $37(A0)
  CMP.w D2,D1
  BLS.w JL_0_5AF4
    ADD.w ypos_statusarea,D2
    CMP.w D2,D1
    BCC.w JL_0_5AF4
      MOVE.w $E(A0),D0               ; Window\MouseX
      SUB.w win_BorLef,D0            ; was win\BorLef    $36(A0)
      BGT 'l1                        ; wenn weniger als BorLeft, auf borleft setzen
        MOVEQ #0,d0
     'l1
      MOVE.w D0,D2                   ; X
      SUB.w source_BoxLeft,D2
      BGE 'l2
        MOVEQ #0,d2
     'l2
      EXT.l D2
      DIVU fontWidth,D2

      MOVEQ.l #$00,D3
      MOVE.w D1,D3                   ; Y
      SUB.w win_BorTop,D3            ; was win_BorTop $37(A0)
      DIVU fontHeight,D3
      EXT.l D3
      RTS
  JL_0_5AF4:
  MOVE.w $12(A0),D0                  ; Window\MinHeight
  MOVE.w D0,D2
  EXT.l D2
  DIVU fontWidth,d2
  MOVEQ.l #-$01,D3
RTS

JL_0_5B00:
  JSR JL_0_5B08
JMP clear_sourcewindow

JL_0_5B08:
  JSR alloc_newline
  BEQ.w JL_0_5B22
    MOVE.l A0,comPtr_FirstSourceLine
    MOVE.l A0,comPtr_LastSourceLine
    MOVE.l A0,comPtr_CurrentSourceLine
  JL_0_5B22:
RTS


JL_0_5B24:
  MOVEA.l comPtr_CurrentSourceLine,A2
  JSR save_cursorposition
;  CLR.l comLong__AL_0_868A
  CLR.w comWord_TextBufferOffset
  MOVE.l comLong_DisplayLine,D1

  JL_0_5B3C:
    BEQ.w JL_0_5B4E
    MOVE.l $4(A2),D0
    BEQ.w JL_0_5B58
    MOVEA.l D0,A2
    SUBQ.w #1,D1
  BRA.b JL_0_5B3C
  JL_0_5B4E:                           ;Print 1 Line down
  MOVE.w D1,comLong_DisplayLine+2
  JSR print_sourceline

  JL_0_5B58:
  JSR restore_cursorposition
BRA.w JL_0_612C

JL_0_5B60:
  MOVEA.l comPtr_CurrentSourceLine,A2
  JSR save_cursorposition
  JL_0_5B68:
    MOVE.l comLong_DisplayLine,D0
    ADDQ.l #1,D0
    CMP.l viewablelines,D0
    BCC.w JL_0_5B84
      MOVE.l (A2),D0
      BEQ.w JL_0_5B88
        MOVEA.l D0,A2
        JSR increase_DisplayLine
  BRA.b JL_0_5B68
  JL_0_5B84:
  JSR print_sourceline     ;print 1 line up

  JL_0_5B88:
  JSR restore_cursorposition
BRA.w JL_0_60FE

.print_current_sourceline:
  MOVEA.l comPtr_CurrentSourceLine,A2
BRA.w print_sourceline

AL_0_5B9A:    Ds.l 1
AL_0_5B9E:    Ds.l 1
AL_0_5BA2:    Ds.l 1        ; not used anymore ?
AL_0_5BA6:    Ds.l 1
textbufferPrint:    Ds.l 1
expandstore:  Ds.l 1
lineundeletestore:    Ds.l 1

.print_entered_char:                           ;type text
  TST.w comWord_CursorInMarkedBlock
  BEQ.w JL_0_5BF4
    !basic
    dummy.l=ask{!TRANS{"print_entered_char subroutine is called"},!TRANS{"OK"},!TRANS{"INFO"} } ; replaced "Request" command with a error include function  tomsmart1
    ; --- print actual character with blockbackgroundcolor
    SetBPen_ \win\RPort,3
    !asm
    MOVEQ.l #$01,D2
    MOVE.w othercolor,D3
    JSR print_text                     ; A0: string, D0: x-pos, D1: y-pos, D2: textlength, D3: foregroundcolor
    !basic
    SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    !asm
    RTS
  JL_0_5BF4:
    MOVEQ.l #$01,D2
    MOVEQ.l #$00,D3
    TST.w (A0)
    BPL.w JL_0_5C0C
      TST.w instru
      BEQ 'l1
        BCLR #$7,(A0)                      ;morechar ok
     'l1
      MOVE.w classiccolor,D3
      BRA.w print_text                   ; A0: string, D0: x-pos, D1: y-pos, D2: textlength, D3: foregroundcolor
    JL_0_5C0C:
    MOVE.w othercolor,D3
    JSR print_text                       ; A0: string, D0: x-pos, D1: y-pos, D2: textlength, D3: foregroundcolor
RTS


.print_complete_line:                  ; d0:x, d1:y, a0: text
  MOVE.l D2,-(A7)

  MOVEA.l textbufferPrint,A2
  MOVE.l #MAX_Columns/4,D2             ; textbufferPrint leeren
  SUBQ.l #1,d2
  JL_0_5C20:
    CLR.l (A2)+
  DBF D2,JL_0_5C20

  TST.w comWord_DoTokenize
  BNE.w tokenized_text
    JSR print_standard_text            ; print standard, non-tokenized text >> d0:x, d1:y, a0: text, d3, length
    BRA.w exit_print_complete_line
  tokenized_text:
    MOVE.w comWord_MaxColumns,D4
    SUBQ.w #1,D4
    MOVEA.l AL_0_5BA6,A1
    JL_0_5C48:
      MOVE.b (A0)+,(A1)+               ;copy text to tempbuffer
      BEQ.w JL_0_5C52
    DBF D4,JL_0_5C48
    JL_0_5C52:
    MOVE.b #$0,(A1)+
    JSR print_tokenized_text
  exit_print_complete_line:

  !basic                               ; clear until end of line
  If Peek.l(?ClearEndOfLine)
    !regs2stack
    USEPATH sourceWindow
    SetAPen_  \win\RPort, AB3Pen(#AB3_cbackground) ;Peek.l(?backgroundcolor)

    rectx.w = \win\RPort\cp_x
    recty.w = Peek.l(?comLong_DisplayLine) * \font\tf_YSize ;Peek.w(?fontHeight)
    rectw.w = Peek.w(?source_BoxWidth)
    recth.w = recty + Peek.w(?fontHeightm1)
    If (rectw => rectx) AND (recth => recty)
      RectFill_ \win\RPort, rectx, recty, rectw, recth
    Else
      log_Print{"illegal area for clear bottom:",#log_error}
      log_Print{Str$(rectx) + ", " + Str$(rectw)}
      log_Print{Str$(recty) + ", " + Str$(recth)}
    EndIf
                                                                                                                                                                                                                                                    
    !stack2regs
  EndIf
  !asm

  MOVE.l (A7)+,D2
;  CLR.w comWord__AL_0_8660
RTS

;/* this is a flag to indicate if we need to clear the end of the line!
ClearEndOfLine: Dc.l 0


.print_tokenized_text:
  MOVEA.l AL_0_5BA6,A0
  MOVEA.l textbufferPrint,A1

  MOVEM.l D0-D1/A1,-(A7)
  JSR JL_0_5060                               ;copy whole line from A0 to A1 and detokenize
  MOVEM.l (A7)+,D0-D1/A1

  TST.b keepstring
  BNE 'l3
    CLR.b instring2
    MOVEA.l AL_0_5BA6,A0
    MOVE.w #0,d2
    MOVEM.l d0/d1,-(a7)
    CMP.l #0,a0
    BEQ 'l2b
   'l1
      CMP.w comWord_ColumnsOffset,d2
      BGE 'l2b
        MOVE.b (a0)+,d0
        CMP.b #$22,d0
        BNE 'l2
          NOT.b instring2
       'l2
        ADDQ.w #1,d2
    BRA 'l1
   'l2b
    MOVEM.l (a7)+,d0/d1
 'l3
  ADDA.w comWord_ColumnsOffsetTmp,A1                ;offset
  MOVE.w visiblecolumns,D4
  MOVE.b $0(A1,D4.W),comByte__AL_0_8662
  MOVEM.l D4/A1,-(A7)
  MOVE.b #$0,$0(A1,D4.W)
  MOVEA.l expandstore,A2
  MOVEA.l A1,A0

  EXT.l d0
  DIVU fontWidth,d0

  JL_0_5C9C:
  MOVE.b (A1)+,D2
  BEQ.w JL_0_5CAA
    CMP.b #$22,d2
    BNE 'l10
      NOT.b instring2
   'l10
    TST.b instring2
    BNE 'l11
      TST.b d2
      BMI.w JL_0_5CAA                     ;morechar
   'l11
    MOVE.b D2,(A2)+
  BRA.b JL_0_5C9C
  JL_0_5CAA:

  MOVE.b #$0,(A2)
  CMPA.l expandstore,A2
  BEQ.w JL_0_5CE6
    MOVE.w D0,-(A7)
    MULU fontWidth,D0
    ADD.w source_BoxLeft,D0

    MOVEA.l A1,A2
    SUBA.l A0,A2
    MOVE.b D2,D4
    MOVE.w A2,D2
    MOVE.w D2,D5
    SUBQ.w #1,D2
    MOVE.w othercolor,D3
    MOVEA.l expandstore,A0
    JSR print_text
    MOVE.w (A7)+,D0
    MOVE.b D4,D2
    ADD.w D5,D0
    SUBQ.w #1,D0
    TST.b D2
    BEQ.w exit_print_tokenized_text
  JL_0_5CE6:
  TST.b D2
  BEQ.w exit_print_tokenized_text

  ;find string state
  SUBQ.w #1,A1
  MOVEA.l A1,A0
  MOVEA.l expandstore,A2
  TST.b D2
  BPL.b JL_0_5C9C

  a_loop:
    MOVE.b (A1)+,D2
    BEQ.w JL_0_5D0A
    BPL.w JL_0_5D0A
    BCLR #$7,D2
    MOVE.b D2,(A2)+
  BRA.b a_loop

  JL_0_5D0A:
  MOVE.b #$0,(A2)
  CMPA.l expandstore,A2
   BEQ.w exit_print_tokenized_text

  MOVE.w D0,-(A7)                   ; get x position
  MULU fontWidth,d0
  ADD.w source_BoxLeft,D0

  MOVEA.l A1,A2
  SUBA.l A0,A2
  MOVE.b D2,D4
  MOVE.w A2,D2
  MOVE.w D2,D5
  SUBQ.w #1,D2
  MOVEQ.l #$00,D3
  MOVE.w tokencolor,D3
  MOVEA.l expandstore,A0
  CMP.l #99,classiccolor
  BEQ 'no2
    MOVEM.l d0/d1/a1/a0,-(a7)
    MOVE.l a0,d0
    JSR ascii_to_token
    MOVE.l d0,-(a7)
    ASR.l #7,d0
    ; check for classiccommands
    LEA classiccommands,a0
   'again
      MOVE.w (a0)+,d1
      BEQ 'nomore
        CMP.w d1,d0
        BNE 'again
          MOVE.l classiccolor,d3
     'nomore
      MOVE.l (a7)+,d0

     'l2
        MOVE.w (a0)+,d1
        BEQ 'no2
      CMP.w d0,d1
      BNE 'l2
      MOVE.l classiccolor,d3
 'no2
  MOVEM.l (a7)+,d0/d1/a0/a1

  MOVEM.l a6/d0-d1/a0/a1,-(a7)

  !basic
  SetBPen_ \win\RPort, AB3Pen(#AB3_ctokenbackground)
  If bold_tokens
    SetFont_ \win\RPort, \fontB
    SetSoftStyle_ \win\RPort,#FSF_BOLD,#FSF_BOLD
  EndIf
  !asm
  MOVEM.l (a7),a6/d0-d1/a0/a1
  JSR print_text                     ; A0: string, D0: x-pos, D1: y-pos, D2: textlength, D3: foregroundcolor
  !basic
  SetBPen_ \win\RPort, AB3Pen(#AB3_cbackground)
  If bold_tokens
    SetFont_ \win\RPort, \font
    SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_BOLD
  EndIf
  !asm
  MOVEM.l (a7)+,a6/d0-d1/a0/a1

  MOVE.w (A7)+,D0
  MOVE.b D4,D2
  ADD.w D5,D0
  SUBQ.w #1,D0
  TST.b D2
  BEQ.w exit_print_tokenized_text
    SUBQ.w #1,A1
    MOVEA.l A1,A0
    MOVEA.l expandstore,A2
    BRA.w JL_0_5C9C
  exit_print_tokenized_text:

  MOVEM.l (A7)+,D4/A1
  MOVE.b comByte__AL_0_8662,$0(A1,D4.W)
RTS

.print_hightlight:                    ;a0 = text,d0 = x,d2 = charslen,d3 = color, d5 = style
  MOVEM.l D0-D4/A0-A1/A4/A6,-(A7)
  MOVE.l a0,-(a7)
  !basic
  xPos.w = PutD0
  MOVE.l d2,d0 : textlen.w = PutD0
  MOVE.l d3,d0 : textcolor.w = PutD0
  MOVE.l d5,d0 : textstyle.w = PutD0
  MOVE.l (a7)+,d0: lineaddr.l = PutD0

  If Peek.l(?textlinestart) > lineaddr
    textlen = textlen - (Peek.l(?textlinestart) - lineaddr)
    lineaddr = Peek.l(?textlinestart)
    xPos = 0
  Else
    xPos = xPos - Peek.w(?comWord_ColumnsOffset)
  EndIf

  If textlen > 0
    If (textlen + xPos) > Peek.w(?visiblecolumns)
      textlen = Peek.w(?visiblecolumns) - xPos
    EndIf
    If textlen > 0
      xText.w = Peek.w(?source_BoxLeft) + xPos * \font\tf_XSize
      yText.w = Peek.l(?comLong_DisplayLine) * \font\tf_YSize + \font\tf_Baseline
      Move_ \win\RPort, xText, yText

      SetAPen_ \win\RPort,textcolor
      ;SetSoftStyle_ \win\RPort,textstyle,textstyle
      Text_ \win\RPort,lineaddr, textlen
    EndIf
  EndIf
  !asm
;  MOVEA.l _graphicsbase,A6
;
;  CMP.l textlinestart,a0
;  BGE 'c1
;    MOVE.l textlinestart,d4
;    SUB.l a0,d4
;    SUB.l d4,d2
;    MOVE.l textlinestart,a0
;    MOVEQ #0,d0
;    BRA 'c2
; 'c1
;    SUB.w comWord_ColumnsOffset,d0
; 'c2
;  MOVE.l A0,-(A7)
;
;  MOVEQ #0,D4
;  MOVE.w D0,D4
;  MULU fontWidth,D0
;  ADD.w source_BoxLeft,D0
;  MOVE.l comLong_DisplayLine,D1
;  MULU fontHeight,D1
;  ADD.w font_Baseline,D1
;  MOVEA.l rp_sourcewindow,A1
;  JSR _Move(A6)
;
;  MOVE.l (a7),a0
;  MOVE.l D3,D0
;  MOVEA.l rp_sourcewindow,A1
;  JSR _SetAPen(A6)
;
;  MOVEA.l rp_sourcewindow,A1
;  MOVEA.l (A7)+,A0
;  MOVE.l D2,D0
;  BMI 'x1
;    MOVE.l d4,d3
;    ADD.l d0,d4
;    CMP.w visiblecolumns,D4
;    BLE.w 'l1
;      MOVE.w visiblecolumns,D0
;      SUB.l d3,d0
;      BMI 'x1
;   'l1
;    JSR _Text(A6)
; 'x1
  MOVEM.l (A7)+,D0-D4/A0-A1/A4/A6
RTS



.print_text:
  !regs2stack
  MOVE.l A0,-(a7)   ; string
  MOVE.l D0,-(a7)   ; x-pos
  MOVE.l D1,-(a7)   ; y-pos
  MOVE.l D2,-(a7)   ; textlength
  MOVE.l D3,-(a7)   ; foregroundcolor
  !basic
  MOVE.l (a7)+,d0 : tcolor.w = PutD0
  MOVE.l (a7)+,d0 : tlength.w = PutD0
  MOVE.l (a7)+,d0 : tposy.w = PutD0 + \font\tf_Baseline
  MOVE.l (a7)+,d0 : tposx.w = PutD0
  MOVE.l (a7)+,d0 : *textaddr.l = PutD0

  ;log_Print{"print_text"}
  Move_ \win\RPort, tposx, tposy
  SetAPen_ \win\RPort, tcolor

  ; -- clip text to visible columns
  If (tlength > Peek.w(?visiblecolumns)) Then tlength = Peek.w(?visiblecolumns)

  If remarkcolor.l OR remarkbgcolor.l
    Gosub print_textcomments
  Else
    Text_ \win\RPort,Peek$(*textaddr), tlength
  EndIf

  !asm
  !stack2regs
RTS

.print_textcomments:
  semi_position.w = 0
  in_string.b = 0
  columnsoff.w = Peek.w(?comWord_ColumnsOffset)
  mytext$ = Peek$(*textaddr)

  ; -- search for a comment and save the starting position
  search_again2:
  semi_position = Instr(mytext$,";",semi_position + 1)
  If semi_position > 0
    ; -- check if the comment-char +++ ; +++ is in a string
    acount.b = 0
    For i = 1 To semi_position
      If Mid$(mytext$,i,1) = Chr$($22) Then acount + 1
    Next i
    If (acount MOD 2) = 1
      ; -- ungerade Anzahl von +++ " +++ impliziert, das +++ ; +++ in einem String steckt...
      semi_position = 0
    Else
      If Mid$(mytext$,semi_position + 1,2)=":@"
        ; -- nachschauen, ob dahinter ein echter Kommentar kommt
        Goto search_again2
      EndIf
    EndIf
    If semi_position > tlength Then semi_position = 0
  EndIf
  If semi_position > 0
    semi_position - 1 ; hightlight +++ ; ++ as well
    ; -- print text before +++ ; +++
    Text_ \win\RPort,mytext$,semi_position

    ; -- set remarks color
    SetAPen_ \win\RPort, AB3Pen(#AB3_cremarkforeground)
    SetBPen_ \win\RPort, AB3Pen(#AB3_cremarkbackground)

    ; -- optional switch italic on
    If italic_remarks
      SetFont_ \win\RPort,\fontI
      SetSoftStyle_ \win\RPort, #FSF_ITALIC,#FSF_ITALIC
    EndIf

    Text_ \win\RPort,UnRight$(mytext$,semi_position),tlength-semi_position

    ; -- restore standard backgroundcolor and font if changed
    SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    If italic_remarks
      SetFont_ \win\RPort,\font
      SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_ITALIC
    EndIf
  Else
    Text_ \win\RPort,mytext$, tlength
  EndIf

Return

.print_linenumber:
  !regs2stack
  !basic
  USEPATH sourceWindow

  dl.l = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) + 1
  linenum$ = Str$(dl)

  lx.w = Peek.w(?source_BoxLeft) - 3 - (FLen(linenum$) * \font\tf_XSize) ;Peek.w(?fontWidth))
  ly.w = Peek.l(?comLong_DisplayLine) * \font\tf_YSize ; Peek.w(?fontHeight)

  SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground) ;Peek.l(?backgroundcolor)
  RectFill_ \win\RPort,0,ly,Peek.w(?source_BoxLeft),ly + \font\tf_YSize ;Peek.w(?fontHeight)

  SetAPen_ \win\RPort,AB3Pen(#AB3_cother) ;Peek.w(?othercolor)
  Move_ \win\RPort,lx,ly + \font\tf_Baseline ;Peek.w(?font_Baseline)
  Text_ \win\RPort,&linenum$,FLen(linenum$)

  Move_ \win\RPort,Peek.w(?source_BoxLeft)-2,ly
  Draw_ \win\RPort,Peek.w(?source_BoxLeft)-2,ly + \font\tf_YSize
  !asm
  !stack2regs
RTS

.print_standard_text:         ;d0:x, d1:y, a0: text
  MOVE.l A0,-(a7)   ; string
  MOVE.l D0,-(a7)   ; x-pos
  MOVE.l D1,-(a7)   ; y-pos
  !basic
  MOVE.l (a7)+,d0 : tposy.w = PutD0 AND $FFFF
  MOVE.l (a7)+,d0 : tposx.w = PutD0
  MOVE.l (a7)+,d0 : *textaddr.l = PutD0

  log_Print{"print_standard_text"}

  ; copy the current line to a tempBuffer
  For i = 0 To Len(Peek$(*textaddr))
    Poke.b Peek.l(?textbufferPrint) + i, Peek.b(*textaddr+i)
  Next i

  Move_ \win\RPort, tposx,tposy + \font\tf_Baseline
  SetAPen_ \win\RPort,AB3Pen(#AB3_cother)

  startPos.w = Peek.w(?comWord_ColumnsOffsetTmp)
  tmpString$ = UnRight$(Peek$(*textaddr),startPos)
  tlength = Len(tmpString$)
  If tlength > Peek.w(?visiblecolumns) Then tlength = Peek.w(?visiblecolumns)
  Text_ \win\RPort,&tmpString$,tlength
  !asm
RTS

.print_sourceline:                     ; a2: pointer to sourceline
;  !regs2stack
;  MOVE.l a2, d0
;  !basic
;  *sourceline.sourceLine = PutD0
;  log_Print{"print_sourceline"}
;  log_Print{">" + Peek$(*sourceline+9)}
;
;  If Peek.b(?linenumbers)
;    !asm
;    Gosub print_linenumber
;    !basic
;  EndIf
;
;  If *sourceline <> 0
;    MOVEA.l textbufferaddr,A3
;    ADDA.w comWord_TextBufferOffset,A3
;
;    If Peek.b(*sourceline + 9)<>0   ; first character of text
;      Poke.w ?comWord_ColumnsOffsetTmp,Peek.w(?comWord_ColumnsOffset)
;;      Poke.l ?templine,Peek.l(?textbufferPrint)
;      GetD0 *sourceline + 9
;      !asm
;      MOVEA.l d0,A0
;      MOVEQ.l #0,d0
;      MOVE.l comLong_DisplayLine,d1
;      MULU fontHeight,D1
;      JSR print_complete_line         ; d0:x, d1:y, d3, length, a0: text
;      !basic
;;      Poke.l ?templine,0
;      *sourceline = Peek.l(?textbufferPrint)
;    Else
;      USEPATH sourceWindow
;      SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)
;      xMin = Peek.w(?source_BoxLeft)
;      yMin = Peek.l(?comLong_DisplayLine) * \font\tf_YSize
;      xMax = Peek.w(?source_BoxWidth)
;      yMax = yMin + \font\tf_YSize - 1
;      RectFill_ \win\RPort, xMin, yMin, xMax, yMax
;      Move_ \win\RPort, 0, Peek.l(?comLong_DisplayLine) * \font\tf_YSize + \font\tf_YSize
;
;      *sourceline = Peek.l(?textbufferPrint)
;    EndIf
;  EndIf
;  !asm
;  !stack2regs
;RTS

  TST.b linenumbers
  BEQ 'no_linenumbers
    BSR print_linenumber
  'no_linenumbers

  CMPA.l #$0,A2
  BNE.w JL_0_5E32
    RTS
  JL_0_5E32:

  LEA $9(A2),A2
  MOVEA.l textbufferaddr,A3
  ADDA.w comWord_TextBufferOffset,A3
  TST.b (A2)
  BEQ.w JL_0_5E72                      ; print textline
    MOVEM.l D1/A0-A3/A6,-(A7)
    MOVEA.l A2,A0

    MOVEQ.l #$00,D0
    MOVEQ.l #$00,D1
    MOVE.l comLong_DisplayLine,D1
    MULU fontHeight,D1

    MOVE.w comWord_ColumnsOffset,comWord_ColumnsOffsetTmp
;    MOVE.l textbufferPrint,templine
    JSR print_complete_line
;    CLR.l templine
    MOVEM.l (A7)+,D1/A0-A3/A6
    MOVEA.l textbufferPrint,A2
    BRA.w JL_0_5E78
  JL_0_5E72:                           ; draw an empty line
    !basic
    USEPATH sourceWindow
    SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    xMin = Peek.w(?source_BoxLeft)
    yMin = Peek.l(?comLong_DisplayLine) * \font\tf_YSize
    xMax = Peek.w(?source_BoxWidth)
    yMax = yMin + \font\tf_YSize - 1
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ \win\RPort, xMin, yMin, xMax, yMax
    Else
      log_Print{"illegal area for JL_0_5E72!",#log_error}
      log_Print{Str$(xMin) + ", " + Str$(xMax)}
      log_Print{Str$(yMin) + ", " + Str$(yMax)}
    EndIf
                                                                                                                                                                                                                                                         
    Move_ \win\RPort, 0, Peek.l(?comLong_DisplayLine) * \font\tf_YSize + \font\tf_YSize ; move cursor to next line
    !asm
;    MOVEA.l _graphicsbase,A6
;    MOVEA.l rp_sourcewindow,A1
;    MOVE.l backgroundcolor,d0
;    JSR _SetAPen(A6)
;
;    MOVEA.l rp_sourcewindow,A1
;    MOVE.w source_BoxLeft,D0           ; xmin = 0
;    MOVE.l comLong_DisplayLine,D1
;    MULU fontHeight,D1                 ; ymin = displayline * fontHeight
;    MOVE.w source_BoxWidth,D2          ; xmax = innerwidth
;    MOVE.w D1,D3
;    ADD.w  fontHeightm1,D3            ; ymax = ymin + fontHeightm1
;    JSR _RectFill(A6)                  ; A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16
;
;    MOVEA.l rp_sourcewindow,A1
;    MOVE.w #0,D0
;    MOVE.l comLong_DisplayLine,D1
;    MULU fontHeight,D1
;    ADD.w fontHeight,D1
;    JSR _Move(a6)                      ; move cursor to next line

    MOVEA.l textbufferPrint,A2
    CLR.l (A2)
  JL_0_5E78:

  MOVE.w comWord_Column,-(A7)
  MOVEQ.l #$00,D3
  MOVEQ.l #$00,D2
  MOVE.b (A2)+,D0
  BEQ.w JL_0_5EA0
    CMP.b comByte_LabelIdentifier,D0
    BNE.w JL_0_5E9A
      JSR JL_0_5EE0
      JL_0_5E92:
        ADDQ.w #1,D2
        MOVE.b (A2)+,D0                  ;copy to viewbuffer
        BEQ.w JL_0_5EA0
    JL_0_5E9A:
    JSR JL_0_5EE0
  BRA.b JL_0_5E92


.dostring
  TST.l stringcolor
  BEQ ready

  MOVEM.l a2/d2/a1,-(a7)
  SUBQ.l #1,a2
  MOVE.l a2,a0
  MOVE.l d2,d1
  MOVEQ #0,d0
  BRA 'l1
 'l2b
    MOVE.b (a2),d0
    CMP.b #$22,d0
    BEQ 'l3
   'l1
      ADDQ #1,d2
      CMP.w #MAX_Columns,d2            ; check the full line
      BEQ 'r1
        ADDQ #1,a2
  BRA 'l2b
 'l3
  ADDQ #1,d2
  SUB.l d1,d2
  MOVE.l d1,d0
  MOVE.l stringcolor,d3
  MOVE.l #0,D5
  BSR print_hightlight
  SUBQ.l #1,d2
  ADD.l d2,0(a7)
  ADD.l d2,8(a7)
 'l3b
 'r1
  MOVEM.l (a7)+,d2/a2/a1
  CLR.b instring
BRA ready


.domacro
  TST.l macrocolor
  BEQ ready
  MOVEM.l a2/d2/a1,-(a7)
  SUBQ.l #1,a2
  MOVE.l a2,a0
  MOVE.l d2,d1
 'l2b
    LEA chartab,a1
    MOVEQ #0,d0
    MOVE.b (a2),d0
    TST.b 0(a1,d0)
    BNE 'l3
   'l1
    ADDQ #1,d2
    CMP.w #MAX_Columns,d2            ; check the full line
    BEQ 'r1
    ADDQ #1,a2
  BRA 'l2b
 'l3
  SUB.l d1,d2
  MOVE.l d1,d0
  MOVE.l macrocolor,d3
  MOVE.l #0,D5
  BSR print_hightlight
 'l3b
 'r1
  MOVEM.l (a7)+,d2/a2/a1
  CLR.b instring
BRA ready

.donewtype
  TST.l newtypecolor
  BEQ ready
  MOVEM.l a2/d2/a1,-(a7)
  SUBQ.l #1,a2
  MOVE.l a2,a0
  MOVE.l d2,d1
 'l2b
    LEA chartab,a1
    MOVEQ #0,d0
    MOVE.b (a2),d0
    CMP.b #$22,d0
    BNE 'ls1
      NOT.b instring
   'ls1
    TST.b instring
    BNE 'l1
      CMP.b #"\",d0
      BEQ 'l1
        TST.b 0(a1,d0)
        BNE 'l3
   'l1
    ADDQ #1,d2
    CMP.w #MAX_Columns,d2
    BEQ 'r1
    ADDQ #1,a2
  BRA 'l2b
 'l3
  SUB.l d1,d2
  MOVE.l d1,d0
  MOVE.l newtypecolor,d3
  MOVE.l #0,D5
  BSR print_hightlight
 'l3b
 'r1
  MOVEM.l (a7)+,d2/a2/a1
  CLR.b instring
BRA ready

.doconstant
  TST.l constantcolor
  BEQ ready
  MOVEM.l a2/d2/a1,-(a7)
  SUBQ.l #1,a2
  MOVE.l a2,a0
  MOVE.l d2,d1
  'l2b
    LEA chartab,a1
    MOVEQ #0,d0
    MOVE.b (a2),d0
    CMP.b #$22,d0
    BNE 'ls1
      NOT.b instring
   'ls1
    TST.b instring
    BNE 'l1
      CMP.b #"$",d0
      BEQ 'l1
        CMP.b #"%",d0
        BEQ 'l1
          CMP.b #"-",d0
          ;BEQ 'l1
          TST.b 0(a1,d0)
          BNE 'l3
   'l1
    ADDQ #1,d2
    CMP.w #MAX_Columns,d2
    BEQ 'r1
      ADDQ #1,a2
  BRA 'l2b
 'l3
  SUB.l d1,d2
  MOVE.l d1,d0
  MOVE.l constantcolor,d3
  MOVE.l #1,D5
  BSR print_hightlight
 'l3b
 'r1
  MOVEM.l (a7)+,d2/a2/a1
  CLR.b instring
BRA ready

.dofunction
  TST.l functioncolor
  BEQ ready
  MOVEM.l a2/d2,-(a7)
  SUBQ.w #1,a2
  SUBQ.w #1,a2
 'l2
    CMP.b #32,(a2)
    BNE 'l1
    SUBQ #1,a2
    SUBQ #1,d2
    BEQ dofr1
  BRA 'l2
 'l1
  MOVE.l d2,d1
 'l2b
    LEA chartab,a0
    MOVE.b (a2),d0
    CMP.b #"!",d0
    BEQ dofr1
      TST.b 0(a0,d0)
      BNE 'l3
        SUBQ #1,d2
        BEQ 'l3b
          SUBQ #1,a2
  BRA 'l2b
 'l3
  ADDQ #1,a2
 'l3b
  CMP.b #$21,d0
  BEQ dofr1
    SUB.l d2,d1
    MOVE.l d2,d0
    MOVE.l d1,d2
    MOVE.l a2,a0
;  !basic
;  tempd0.l = PutD0
;  MOVE.l a2,d0
;  faddr.l = PutD0
;  MOVE.l d2,d0
;  clen.l = PutD0
;  functionstr$ = peek.s(faddr,clen)
;  functionstr$ = PED_GetIncludeFunction{functionstr$}
;  !cout{functionstr$,Hex$(faddr),clen}
;  If functionstr$<>"" Then poke.s faddr,functionstr$,clen
;  GetD0 tempd0
;  !asm
    MOVE.l functioncolor,d3
    MOVE.l #0,D5
    BSR print_hightlight
  dofr1:
  MOVEM.l (a7)+,d2/a2
BRA ready

.process_highlightning:
  MOVEM.l a2/d2,-(a7)
  CLR.b instring
  MOVEA.l textbufferaddr,A0
  ADDA.w comWord_TextBufferOffset,A0
  MOVE.l a0,a2
  MOVE.l a2,textlinestart

  MOVEQ #0,d0
  MOVE.w comWord_ColumnsOffset,d0
  ADD.l d0,textlinestart

  MOVEQ #0,d2
  hl1:
    MOVE.b (a2)+,d0
    CMP.b #";",d0
    BEQ skipsyntax

    CMP.b #$22,d0
    BEQ dostring
    ;BNE 'ls1
    ;NOT.b instring
   'ls1  ;TST.b instring
    ;BNE ready
    CMP.b #"{",d0
    BEQ dofunction

    CMP.b #"!",d0
    BEQ domacro
   'ls2
    CMP.b #"#",d0
    BEQ doconstant

    CMP.b #"\",d0
    BEQ donewtype
   ready
    ADDQ.l #1,d2
    CMP.w #MAX_Columns,d2
  BLE hl1
  CLR.b instring

  skipsyntax:
  MOVEM.l (a7)+,a2/d2
RTS

JL_0_5EA0:
  BSR process_highlightning

  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w JL_0_5ED8
    MOVE.l comLong_DisplayLineOffset,D0
    ADD.l comLong_DisplayLine,D0
    CMP.l comLong_BlockStartY,D0
    BCS.w JL_0_5ED8
      CMP.l comLong_BlockEndY,D0
      BHI.w JL_0_5ED8
        JL_0_5EC4:
          CMP.w visiblecolumns,D3
          BCC.w JL_0_5ED8
            MOVEQ.l #$20,D0
            MOVE.w D3,comWord_Column
            ADDQ.w #1,D3
        BRA.b JL_0_5EC4
  JL_0_5ED8:
  MOVE.w (A7)+,comWord_Column
RTS



JL_0_5EE0:
  MOVE.b D0,$0(A3,D2.W)
  JL_0_5EE4:
  CMP.w comWord_ColumnsOffset,D2
  BCS.w JL_0_5EFC
    CMP.w visiblecolumns,D3
    BCC.w JL_0_5EFC
      MOVE.w D3,comWord_Column
      ADDQ.w #1,D3
  JL_0_5EFC:
RTS

JL_0_5EFE:
  TST.w comWord_DoTokenize
  BEQ.b JL_0_5EE0
    TST.b D0
    BPL.b JL_0_5EE0
      LSL.w #8,D0
      MOVE.b (A2)+,D0
      EXG.l A5,A3
      JSR token_to_ascii
      EXG.l A5,A3

  JL_0_5F16:
    MOVE.b (A5)+,D0
    BEQ.w JL_0_5F2C
    MOVE.b D0,$0(A3,D2.W)
    BSET #$7,$0(A3,D2.W)
    BSR.b JL_0_5EE4
    ADDQ.w #1,D2
  BRA.b JL_0_5F16

  JL_0_5F2C:
  SUBQ.w #1,D2
RTS

.parse_line:                         ; input A2: textstring, results in comPtr_Temp_TokenString1
  MOVEA.l comPtr_Temp_TokenString1,A1
  MOVE.l A1,-(A7)
  MOVE.w comWord_MaxColumns,D1
  SUBQ.w #1,D1
  MOVE.w comWord_DoTokenize,D0
  BNE.w JL_0_5F68

  MOVEA.l A1,A0
  JL_0_5F48:
    MOVE.b (A2)+,(A0)+
    CMPI.b #$20,-$1(A0)
    BEQ.w JL_0_5F56
      MOVEA.l A0,A1
    JL_0_5F56:
  DBF D1,JL_0_5F48

  JL_0_5F5A:                         ; tokenise line
  CLR.b (A1)+
  MOVE.l A1,D5
  SUB.l (A7)+,D5
  RTS

  JL_0_5F62:
  MOVE.l A1,-(A7)
  BRA.w JL_0_5F72

  JL_0_5F68:
  CMPI.b #$20,$0(A2,D1.W)
  BNE.w JL_0_5F7E

  JL_0_5F72:
  SUBQ.w #1,D1
   BPL.b JL_0_5F68
  ADDQ.w #4,A7
  CLR.b (A1)
  MOVEQ.l #$01,D5
  RTS

  JL_0_5F7E:
  MOVE.l A4,-(A7)
  MOVEQ.l #$00,D0
  MOVE.w D0,comWord__AL_0_86B8
  CLR.b instring2

  JL_0_5F88:
    MOVE.b (A2)+,D2
    CMP.b #$22,d2
    BNE 'l10
      NOT.b instring2
   'l10
    TST.b instring2
    BNE 'l11
      BCLR #$7,D2                      ;morechar
   'l11
    CMP.b comByte__L_0_8BCD,D2
    BNE.w JL_0_5FA2

    JL_0_5F96:
    NOT.w comWord__AL_0_86B8

    JL_0_5F9C:
    JSR JL_0_60B2
    BRA.b JL_0_5F88

    JL_0_5FA2:
    MOVE.w comWord__AL_0_86B8,D4
    BNE.b JL_0_5F9C
    JSR checkForLetter
    BEQ.w JL_0_6030
    .temp1
    JL_0_5FB0:
    CMP.b #$30,d2                    ;number 0-9
     BLT 'l10
    CMP.b #$39,d2
     BGT 'l10
    BRA JL_0_6066
   'l10:
    CMP.b #"_",D2
     BEQ.w JL_0_6066
    CMP.b #$2E,D2
     BEQ.w JL_0_6066
    CMP.b #"\",D2
     BEQ.w JL_0_6066
    CMP.b comByte__L_0_8BCF,D2
     BNE.w JL_0_5FDC

    JL_0_5FD0:
      JSR JL_0_60B2
      MOVE.b (A2)+,D2
      BCLR #$7,D2
    BRA.b JL_0_5FD0

    JL_0_5FDC:
    CMP.b #"'",d2
     BEQ JL_0_5FE4
    CMP.b #"#",D2
     BEQ.w JL_0_5FE4                 ;jump notokenize
    CMP.b #"$",D2                    ;tokenize $ #
     BNE.w JL_0_6018

    JL_0_5FE4:
      JSR JL_0_60B2
      MOVE.b (A2)+,D2
      BCLR #$7,D2
      CMP.b #$22,d2
      BNE 'l10
      BRA JL_0_5FE4
     'l10
      CMP.b #"_",d2
       BEQ JL_0_5FE4
      CMP.b #"0",D2
       BCS.w JL_0_6018
      CMP.b #"z",D2                  ;f
       BHI.w JL_0_6018
      CMP.b #"9",D2
       BLS.b JL_0_5FE4
      CMP.b #"A",D2
       BCS.w JL_0_6018
      CMP.b #"a",D2
       BCC.b JL_0_5FE4
      CMP.b #"Z",D2                  ;F
    BLS.b JL_0_5FE4

    JL_0_6018:
    JSR JL_0_60B2
    MOVE.b (A2)+,D2
    CMP.b #$22,d2
     BNE 'l10
    NOT.b instring2
   'l10
    TST.b instring2
     BNE 'l11
    BCLR #$7,D2                      ;morechar
   'l11
    CMP.b comByte__L_0_8BCD,D2
     BEQ.w JL_0_5F96
    JSR checkForLetter
    BNE.b JL_0_5FB0

    JL_0_6030:
    SUBQ.w #1,A2
    MOVEA.l comPtr_TokenBase,A3

    JL_0_6036:
    MOVEA.l A2,A4
    MOVE.l A3,-(A7)
    ADDQ.w #6,A3

    JL_0_603C:
    MOVE.b (A3)+,D3
     BEQ.w JL_0_6082
    MOVE.b (A4)+,D2
    BCLR #$7,D2
    ORI.b #$20,D3
    ORI.b #$20,D2
    CMP.b D3,D2
    BEQ.b JL_0_603C

    JL_0_6054:
    MOVEA.l (A7)+,A3
    MOVE.l (A3),D3
     BEQ.w JL_0_6060
    MOVEA.l D3,A3
    BRA.b JL_0_6036

    JL_0_6060:
    MOVE.b (A2)+,D2
    BCLR #$7,D2

    JL_0_6066:
     JSR JL_0_60B2
    MOVE.b (A2)+,D2
    CMP.b #$22,d2
    BNE 'l10
    NOT.b instring2
   'l10
    TST.b instring2
     BNE 'l11
    BCLR #$7,D2            ;morechar
   'l11
    CMP.b comByte__L_0_8BCD,D2
     BEQ.w JL_0_5F96
    JSR checkForLetter
    BEQ.b JL_0_6066
    BRA.w JL_0_5FB0

    JL_0_6082:
    MOVE.b (A4),D2
    BCLR #$7,D2
    JSR checkForLetter            ;ascii to token
     BEQ.b JL_0_6054
    CMP.b #$30,d2            ;number 0-9
     BLT 'l10
    CMP.b #$39,d2
     BGT 'l10
    BRA JL_0_6054
   'l10:
    CMP.b #"_",D2
     BEQ.b JL_0_6054
    MOVEA.l (A7)+,A3
    ADDQ.w #4,A3
    MOVE.b (A3)+,(A1)
    BSET #$7,(A1)+
    MOVE.b (A3),(A1)+
    MOVE.l A4,D4
    SUB.l A2,D4
    ADD.w D4,D0
    CMP.w D1,D0
     BHI.w JL_0_60C0
    MOVEA.l A4,A2
  BRA.w JL_0_5F88

JL_0_60B2:
  MOVE.b D2,(A1)+
  ADDQ.w #1,D0
  CMP.w D1,D0
  BHI.w JL_0_60BE
    RTS
  JL_0_60BE:
  ADDQ.w #4,A7

  JL_0_60C0:
  MOVEA.l (A7)+,A4
BRA.w JL_0_5F5A


checkForLetter:
  CMP.b #"A",D2
   BCS.w JL_0_60E8
  CMP.b #"z",D2
   BHI.w JL_0_60E8
  CMP.b #"[",D2
   BCS.w JL_0_60E6
  CMP.b #"a",D2
   BCS.w JL_0_60E8

  JL_0_60E6:
  CMP.w D2,D2

  JL_0_60E8:
RTS

.source_fullscroll_down:
  MOVEQ.l #$00,D7
  source_partscroll_down:
  JSR source_scroll_down
  JSR JL_0_6290
RTS

JL_0_60FE:
  TST.l comLong_BlockEndY
  BMI.w JL_0_612A
    MOVE.w comWord_Column,D0
    MOVE.l viewablelines_m1,D1
    ADD.w comWord_ColumnsOffset,D0
    ADD.l comLong_DisplayLineOffset,D1
    MOVE.l viewablelines_m1,D6
    BRA.w JL_0_6150
  JL_0_612A:
RTS

JL_0_612C:
  TST.l comLong_BlockEndY
  BMI.w JL_0_614E
    MOVE.w comWord_Column,D0
    MOVE.l comLong_DisplayLineOffset,D1
    ADD.w comWord_ColumnsOffset,D0
    MOVEQ.l #$00,D6
    BRA.w JL_0_6150
  JL_0_614E:
RTS

JL_0_6150:
RTS

;  MOVE.w comLong_BlockStartX,D4
;  SUB.w comWord_ColumnsOffset,D4
;  BPL.w JL_0_6162
;    MOVEQ.l #$00,D4
;  JL_0_6162:
;
;  MOVE.w comLong_BlockEndX,D5
;  SUB.w comWord_ColumnsOffset,D5
;  BPL.w JL_0_6174
;    MOVEQ.l #$00,D5
;  JL_0_6174:
;
;  CMP.w visiblecolumns,D5
;  BLT.w JL_0_6184
;    MOVE.w comWord__AL_0_8670,D5
;  JL_0_6184:
;
;  MOVE.l comLong_BlockStartY,D2
;  MOVE.l comLong_BlockEndY,D3
;  MOVEA.l rp_rectfill,A1
;  MOVEA.l _graphicsbase,A6
;  CMP.l D2,D1
;  BLT.w JL_0_61D0
;    BEQ.w JL_0_61D2
;      CMP.l D3,D1
;      BGT.w JL_0_61D0
;        BEQ.w JL_0_6220
;          MOVE.l D6,D1
;          BEQ.w JL_0_61BA
;            MULU fontHeight,D1
;          JL_0_61BA:
;          MOVEQ.l #$00,D0
;          ADD.w source_BoxLeft,D0
;          MOVE.w visiblecolumns,D2
;          MULU fontWidth,D2
;          ADD.w source_BoxLeft,D2
;          SUBQ.w #1,D2
;          MOVE.l D1,D3
;          ADD.w fontHeightm1,D3
;          JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16
;  JL_0_61D0:
;  RTS
;
;  JL_0_61D2:
;  CMP.l comLong_BlockEndY,D1
;  BNE.w JL_0_61FC
;    MOVE.w D4,D0
;    MULU fontWidth,D0
;    ADD.w source_BoxLeft,D0
;    MOVE.w D6,D1
;    BEQ.w JL_0_61EA
;      MULU fontHeight,D1
;    JL_0_61EA:
;    MOVE.w D5,D2
;    MULU fontWidth,D2
;    ADD.w source_BoxLeft,D0
;    ADDQ.w #7,D2
;    MOVE.l D1,D3
;    ADD.w fontHeightm1,D3
;    JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16
;    RTS
;  JL_0_61FC:
;
;  MOVE.w D4,D0
;  MULU fontWidth,d0
;  ADD.w source_BoxLeft,D0
;  MOVE.w D6,D1
;  BEQ.w JL_0_620A
;    MULU fontHeight,D1
;  JL_0_620A:
;
;  MOVE.w visiblecolumns,D2
;  MULU fontWidth,d2
;  ADD.w source_BoxLeft,D2
;  SUBQ.w #1,D2
;  MOVE.l D1,D3
;  ADD.w fontHeightm1,D3
;  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16
;  RTS
;
;  JL_0_6220:
;  MOVE.w D5,D2
;  CMP.w visiblecolumns,D2
;  BLE.w JL_0_6234
;    MOVE.w visiblecolumns,D2
;    SUBQ.w #1,D2
;  JL_0_6234:
;  MULU fontWidth,d2
;  ADD.w source_BoxLeft,D2
;  MOVE.w D6,D1
;  BEQ.w JL_0_6240
;    MULU fontHeight,D1
;  JL_0_6240:
;
;  ADDQ.w #7,D2
;  MOVE.l D1,D3
;  ADD.w fontHeightm1,D3
;  MOVEQ.l #$00,D0
;  ADD.w source_BoxLeft,D0
;  JSR _RectFill(A6)                  ;A1:rp, D0:xmin, D1:ymin, D2:xmax, D3:ymax  d0-d3:16
;RTS


.source_scroll_down:                 ;ymin aus D7
  !regs2stack
  !basic
  MOVE.w d7,d0 : yMin.w = PutD0
  USEPATH sourceWindow
  dx.w = 0
  dy.w = \font\tf_YSize
  xMin.w = 0
  yMin.w = yMin * \font\tf_YSize
  xMax.w = Peek.w(?source_BoxLeft) + Peek.w(?visiblecolumns) * \font\tf_XSize - 1
  yMax.w = Peek.l(?viewablelines) * \font\tf_YSize - 1
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax
  WaitBlit_
  !asm
  JSR delay

  !stack2regs
RTS

JL_0_6290:
  MOVE.l viewablelines,D6
  SUB.l D7,D6
  SUBQ.l #1,D6
  TST.l D6
  BEQ.w fill2
    MOVE.l D7,D0
    MOVE.w comWord_MaxColumns,D1
    MULU D1,D0
    MOVEA.l textbufferaddr,A0
    ADDA.l D0,A0
    MOVE.l A0,a1
    ADDA.w D1,A1
    MOVE.l d6,d0
    MULS d1,d0
    ASR.l #1,d0
   'loop
      MOVE.w (a1)+,(a0)+
      SUBQ.l #1,d0
    BNE 'loop
  fill2:

  MOVE.l viewablelines,D0
  SUBQ.l #1,D0
  MULU comWord_MaxColumns,D0
  MOVEA.l textbufferaddr,A0
  ADDA.w D0,A0
  MOVE.w #$2020,d1
  MOVE.l #MAX_Columns/2,d0
 'loop
    MOVE.w d1,(a0)+
    SUBQ.l #1,d0
  BNE 'loop
RTS

.source_fullscroll_up:
  MOVEQ.l #$00,D7
  source_partscroll_up:
  JSR source_scroll_up
  JSR JL_0_6358
RTS

.source_scroll_up:
  !regs2stack
  !basic
  MOVE.w d7,d0 : yMin.w = PutD0
  USEPATH sourceWindow
  dx.w = 0
  dy.w = -\font\tf_YSize
  xMin.w = 0
  yMin.w = yMin * \font\tf_YSize
  xMax.w = Peek.w(?source_BoxLeft) + Peek.w(?visiblecolumns) * \font\tf_XSize - 1
  yMax.w = Peek.l(?viewablelines) * \font\tf_YSize - 1
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax
  WaitBlit_
  !asm
  JSR delay
  !stack2regs
RTS


JL_0_6358:                           ;return blit
checkd7
  MOVE.l viewablelines,D6
  SUB.l D7,D6
  SUBQ.l #1,D6
  BEQ.w fill
    MOVE.w comWord_MaxColumns,D1
    MOVE.w D1,D0
    MULU viewablelines+2,D0
    MOVEA.l textbufferaddr,A0
    ADDA.l D0,A0
    SUBQ.w #2,A0
    MOVE.l A0,a1          ;destaddr
    SUBA.w D1,A1
    MOVE.l d6,d0
    MULS d1,d0
    ASR.l #1,d0
   'loop
      MOVE.w -(a1),-(a0)
      SUBQ.l #1,d0
    BNE 'loop
  fill:

  MULU comWord_MaxColumns,D7
  MOVEA.l textbufferaddr,A0
  ADDA.l D7,A0
  MOVE.w #$2020,d1
  MOVE.l #MAX_Columns/2,d0
 'loop
    MOVE.w d1,(a0)+
    SUBQ.l #1,d0
  BNE 'loop
RTS


increase_DisplayLine:
  ADDQ.l #1,comLong_DisplayLine
  MOVEQ.l #$00,D0
;  MOVE.w comWord__AL_0_86CC,D0
;  ADD.l D0,comLong__AL_0_868A
  MOVE.w comWord_MaxColumns,D0
  ADD.w D0,comWord_TextBufferOffset
RTS

decrease_DisplayLine:
  ; decrease DisplayLine
  ;Poke.l ?comLong_DisplayLine, Peek.l(?comLong_DisplayLine)-1
  ;Poke.w ?comWord_TextBufferOffset, Peek.w(?comWord_TextBufferOffset)-Peek.w(?comWord_MaxColumns)

  SUBQ.l #1,comLong_DisplayLine
  MOVEQ.l #$00,D0
;  MOVE.w comWord__AL_0_86CC,D0
;  SUB.l D0,comLong__AL_0_868A
  MOVE.w comWord_MaxColumns,D0
  SUB.w D0,comWord_TextBufferOffset
RTS

JL_0_6448_bas:
  !basic
  xPos.w = Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)
  yPos.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
  ;log_Print{"scroll line to left xpos "+ Str$(xPos)+  ", ypos " + Str$(yPos) + " BlockEndY " +Str$(Peek.l(?comLong_BlockEndY))}
  If Peek.l(?comLong_BlockEndY) > -1
    If (yPos <= Peek.l(?comLong_BlockEndY)) AND (yPos >= Peek.l(?comLong_BlockStartY))
      If yPos = Peek.l(?comLong_BlockStartY)
        If xPos <= Peek.w(?comLong_BlockStartX) Then Poke.w ?comLong_BlockStartX, Peek.w(?comLong_BlockStartX) - 1
        If Peek.w(?comLong_BlockEndX) <> #MAX_Columns - 1
          If xPos <= Peek.w(?comLong_BlockEndX)
            Poke.w ?comLong_BlockEndX, Peek.w(?comLong_BlockEndX) - 1
            xPos = Peek.w(?visiblecolumns) + Peek.w(?comWord_ColumnsOffset)
            If xPos > Peek.w(?comLong_BlockEndX)
              Goto scroll_rest_of_line_left2
            EndIf
          Else
            Goto scroll_rest_of_line_left2
          EndIf
        EndIf
        USEPATH sourceWindow
        SetBPen_ \win\RPort,3
      EndIf
    EndIf
  EndIf

  scroll_rest_of_line_left2:
  !asm
  MOVE.w D7,-(A7)
  MOVEQ #0,d0
  MOVE.w fontWidth,d0
  JSR source_scroll_line
  MOVE.w (A7)+,D7
RTS

;JL_0_6448:
;  MOVEA.l rp_sourcewindow,A1
;  MOVE.w comWord_Column,D0
;  ADD.w comWord_ColumnsOffset,D0
;  MOVE.l comLong_DisplayLine,D1
;  ADD.l comLong_DisplayLineOffset,D1
;
;  TST.l comLong_BlockEndY
;  BMI.w scroll_rest_of_line_left
;
;  CMP.l comLong_BlockEndY,D1
;  BGT.w scroll_rest_of_line_left
;
;  CMP.l comLong_BlockStartY,D1
;  BLT.w scroll_rest_of_line_left
;  BNE.w JL_0_6498
;    CMP.w comLong_BlockStartX,D0
;    BGE.w JL_0_6498
;      SUBQ.w #1,comLong_BlockStartX
;  JL_0_6498:
;
;  CMPI.w #MAX_Columns-1,comLong_BlockEndX
;  BEQ.w JL_0_64CA
;    CMP.w comLong_BlockEndX,D0
;    BGT.w scroll_rest_of_line_left
;      SUBQ.w #1,comLong_BlockEndX
;      MOVE.w visiblecolumns,D1
;      ADD.w comWord_ColumnsOffset,D1
;      CMP.w comLong_BlockEndX,D1
;      BGT.w scroll_rest_of_line_left
;  JL_0_64CA:
;
;  MOVEM.l D0-D1/A0-A1,-(A7)
;  MOVEA.l rp_sourcewindow,A1
;  MOVEQ.l #$03,D0
;  MOVEA.l _graphicsbase,A6
;  JSR _SetBPen(A6)
;  MOVEM.l (A7)+,D0-D1/A0-A1
;
;  scroll_rest_of_line_left:
;  MOVE.w D7,-(A7)
;  MOVEQ #0,d0
;  MOVE.w fontWidth,d0
;  JSR source_scroll_line
;  MOVE.w (A7)+,D7
;RTS

.scroll_rest_of_line_right:
  MOVE.w D7,-(A7)
  MOVEQ #0,d0
  SUB.w fontWidth,d0
  EXT.l d0
  JSR source_scroll_line
  MOVE.w (A7)+,D7
RTS

.source_scroll_line:                 ; by "dx" in D0
  !regs2stack
  !basic
  USEPATH sourceWindow
  dx.w = PutD0
  dy.w = 0
  xMin.w = Peek.w(?source_BoxLeft) + Peek.w(?comWord_Column) * \font\tf_XSize
  yMin.w = Peek.l(?comLong_DisplayLine) * \font\tf_YSize
  xMax.w = Peek.w(?visiblecolumns) * \font\tf_XSize - 1
  yMax.w = yMin + \font\tf_YSize - 1
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax
  WaitBlit_
  !asm
  !stack2regs
  ;JSR delay
RTS

.scroll_right:
  MOVE.l #1,blockmarking
  JSR source_scroll_to_right         ; scroll source to right <-
  JSR source_draw_new_columns        ; draw text after scroll
  JSR update_blockmark_left          ; blockmark selected text after scrolling
  MOVE.l #0,blockmarking
RTS


.update_blockmark_left:
  ;!regs2stack
  !basic
  If Peek.l(?comLong_BlockEndY) > -1
    ;        log_Print{" blockendX: " + Str$(Peek.w(?comLong_BlockEndX))}
    ;        log_Print{" blockendy: " + Str$(Peek.w(?comLong_BlockEndY))}
    ;        log_Print{" blockstartX: " + Str$(Peek.w(?comLong_BlockStartX))}
    xMin = Peek.w(?comWord_ColumnsOffset)
    yMin = Peek.l(?comLong_DisplayLineOffset)
    yMax = yMin + Peek.l(?viewablelines)
    If (yMin <= Peek.l(?comLong_BlockEndY)) AND (yMax >= Peek.l(?comLong_BlockStartY))
      If Peek.l(?comLong_BlockStartY) = Peek.l(?comLong_BlockEndY)
        Gosub JL_0_66F2
        Pop If
        !asm
        ;!stack2regs
        RTS
      EndIf

      Gosub JL_0_6658   ; draw missing blockmark in first line while scrollin left

      yMin = Peek.l(?comLong_BlockStartY) - Peek.l(?comLong_DisplayLineOffset) + 1
      yMax = Peek.l(?comLong_BlockEndY) - Peek.l(?comLong_DisplayLineOffset)
      If yMax > Peek.l(?viewablelines) Then yMax = Peek.l(?viewablelines)

      If yMax <= yMin
        Gosub JL_0_669A ; update missing blockmark in last line
        Pop If
        !asm
        ;!stack2regs
        RTS
      EndIf
      Gosub JL_0_669A

      ;-- draw left blockparts while scrolling leftside except first and last line
      xMin = 0
      yMin = (Peek.l(?comLong_BlockStartY)-Peek.l(?comLong_DisplayLineOffset) + 1) * Peek.w(?fontHeight)

      yMax =  Peek.l(?comLong_BlockEndY) - Peek.l(?comLong_DisplayLineOffset)
      If yMax > Peek.l(?viewablelines) Then yMax = Peek.l(?viewablelines)
      xMax = xMin + Peek.w(?fontWidth) * 2 - 1  ; we scroll always 2 lines
      yMax = yMax * Peek.w(?fontHeight) - 1
      If (xMax => xMin) AND (yMax => yMin)
         RectFill_ Peek.l(?rp_rectfill),Peek.w(?source_BoxLeft) + xMin,yMin,Peek.w(?source_BoxLeft) + xMax,yMax
      Else
        log_Print{"illegal area for update blockmark left"}
      EndIf
      ;    SetBPen_ Peek.l(?rp_rectfill),3
      ;    SetDrMd_ Peek.l(?rp_rectfill),#JAM1
      ;    Move_ Peek.l(?rp_rectfill),Peek.w(?source_BoxLeft) + xMin,yMin
      ;    Draw_ Peek.l(?rp_rectfill),Peek.w(?source_BoxLeft) + xMax,yMax
      ;    SetDrMd_ Peek.l(?rp_rectfill),#COMPLEMENT
    EndIf
  EndIf
  !asm
  ;!stack2regs
RTS


JL_0_6658:      ; draw missing blockparts in first line when scrolling left
  If xMin >= Peek.w(?comLong_BlockStartX)
    yMaxold = yMax : xMaxold = xMax : yMinold = yMin : xMinold = xMin

    xMin = 0
    xMax = xMin + Peek.w(?fontWidth) * 2 - 1
    yMin = (Peek.l(?comLong_BlockStartY)-Peek.l(?comLong_DisplayLineOffset)) * Peek.w(?fontHeight)
    yMax = yMin + Peek.w(?fontHeightm1)
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ Peek.l(?rp_rectfill),Peek.w(?source_BoxLeft) + xMin,yMin,Peek.w(?source_BoxLeft) + xMax,yMax
    Else
      log_Print{"illegal area for JL_0_6658"}
    EndIf

    yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return


JL_0_669A:  ; update missing blockmark in last line
  If xMin <= Peek.w(?comLong_BlockEndX)
    ;yMaxold = yMax : xMaxold = xMax : yMinold = yMin : xMinold = xMin
    xMin      = 0
    xmax_temp.w = (Peek.w(?comLong_BlockEndX)-Peek.w(?comWord_ColumnsOffset)+1) * Peek.w(?fontWidth) -1
    If xmax_temp < 2 Then xmax_temp = 2
    xmax_temp = xmax_temp * Peek.w(?fontWidth) - 1
    xMax      = xMin + xmax_temp
    yMin      = (Peek.l(?comLong_BlockEndY)-Peek.l(?comLong_DisplayLineOffset)) * Peek.w(?fontHeight)
    yMax      = yMin + Peek.w(?fontHeightm1)
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ Peek.l(?rp_rectfill),Peek.w(?source_BoxLeft) + xMin,yMin,Peek.w(?source_BoxLeft) + xMax,yMax
    Else
      log_Print{"illegal area for JL_0669A"}
    EndIf
    ;yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return

JL_0_66F2:
  If (xMin >= Peek.w(?comLong_BlockStartX)) AND (xMin <= Peek.w(?comLong_BlockEndX))
    ;yMaxold = yMax : xMaxold = xMax : yMinold = yMin : xMinold = xMin

    xMin      = 0
    xmax_temp.w = (Peek.w(?comLong_BlockEndX)-Peek.w(?comWord_ColumnsOffset)+1) * Peek.w(?fontWidth) -1
    If xmax_temp < $2 Then xmax_temp = $2
    xmax_temp = xmax_temp * Peek.w(?fontWidth) -1
    xMax      = xMin + xmax_temp
    yMin      = (Peek.l(?comLong_BlockStartY)-Peek.l(?comLong_DisplayLineOffset)) * Peek.w(?fontHeight)
    yMax      = yMin + Peek.w(?fontHeightm1)
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ Peek.l(?rp_rectfill),Peek.w(?source_BoxLeft) + xMin,yMin,Peek.w(?source_BoxLeft) + xMax,yMax
    Else
      log_Print{"illegal area for JL_0_66F2"}
    EndIf
    ;yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return


.source_scroll_to_right:
;  !regs2stack
  !basic
  USEPATH sourceWindow
  dx.w = -(\font\tf_XSize * 2)
  dy.w = 0
  xMin.w = Peek.w(?source_BoxLeft)
  yMin.w = 0
  xMax.w = Peek.w(?source_BoxLeft) + Peek.w(?visiblecolumns) * \font\tf_XSize - 1
  yMax.w = Peek.l(?viewablelines) * \font\tf_YSize - 1

  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax
  WaitBlit_
  !asm
;  !stack2regs
  JSR delay
RTS


.source_draw_new_columns:            ;left scroll
  JSR save_cursorposition
  ;CLR.l comWord_Column
  CLR.w comWord_Column
  CLR.l comLong_DisplayLine
;  CLR.l comLong__AL_0_868A
  CLR.w comWord_TextBufferOffset
  MOVEA.l textbufferaddr,A5
  ADDA.w comWord_ColumnsOffset,A5
  MOVE.l viewablelines,D2
  SUBQ.w #1,D2
  CLR.w comWord_ColumnsOffsetTmp

  JL_0_67AA:
    MOVEA.l AL_0_5B9E,A0
    MOVE.b (A5),(A0)
    MOVE.b $1(A5),$1(A0)

    MOVEQ.l #$00,D0
    MOVE.w comWord_Column,D0
    MULU fontWidth,d0

    MOVE.l comLong_DisplayLine,D1
    MULU fontHeight,D1
    ST comWord__AL_0_8668

    MOVEM.l D2/A5,-(A7)
    MOVEM.l d0-d2/a0,-(a7)
    MOVE.l textbufferaddr,a0
    ADD.w comWord_TextBufferOffset,a0
    CLR.b instring2
    MOVE.w #0,d2
    CMP.l #0,a0
    BEQ 'l2b
    MOVE.w comWord_ColumnsOffset,d1
   'l1
      CMP.w d1,d2
      BGE 'l2b
      MOVE.b (a0)+,d0
      CMP.b #$22,d0
      BNE 'l2
      NOT.b instring2
     'l2
      ADDQ.w #1,d2
    BRA 'l1
   'l2b
    MOVEM.l (a7)+,d0-d2/a0

    MOVE.b #$1,keepstring
    JSR print_complete_line          ; print the text ; d0:x, d1:y, a0: text
    CLR.b keepstring
    MOVEM.l (A7)+,D2/A5
    BSR process_highlightning        ; beim markieren nicht verwenden, da sonst
                                     ; unter umstaenden mit flascher Hintergrundfarbe ueber den
                                     ; Block gemalt wird.
    SF comWord__AL_0_8668
    MOVEQ.l #$00,D0
;    MOVE.w comWord__AL_0_86CC,D0
;    ADD.l D0,comLong__AL_0_868A
    MOVE.w comWord_MaxColumns,D0
    ADDA.w D0,A5
    ADD.w D0,comWord_TextBufferOffset
    ADDQ.l #1,comLong_DisplayLine
  DBF D2,JL_0_67AA
  JSR restore_cursorposition
RTS


.scroll_left:
  JSR source_scroll_to_left
  JSR draw_new_columns
  JSR update_blockmark_right
RTS


.update_blockmark_right:
  !basic
  If Peek.l(?comLong_BlockEndY) > -1            ; check if we have a Blockmark
    SetScreenTitle{Str$(Peek.w(?comWord_ColumnsOffset))}
    xMin = Peek.w(?comWord_ColumnsOffset) + Peek.w(?visiblecolumns) - 2 ;d0
    yMin = Peek.l(?comLong_DisplayLineOffset)       ;d1
    yMax = yMin + Peek.l(?viewablelines)            ;d2

    ;log_Print{"blockstartX: " + Str$(Peek.w(?comLong_BlockStartX))}
    ;log_Print{"blockstartY: " + Str$(Peek.l(?comLong_BlockStartY))}
    ;log_Print{"blockendX: " + Str$(Peek.w(?comLong_BlockEndX))}
    ;log_Print{"blockendY: " + Str$(Peek.l(?comLong_BlockEndY))}
    ;log_Print{"xmin:" + Str$(xMin)+" yMin:" + Str$(yMin)+ " yMax: " + Str$(yMax)}
    If (yMin <= Peek.l(?comLong_BlockEndY)) AND (yMax >= Peek.l(?comLong_BlockStartY))
      If Peek.l(?comLong_BlockStartY) = Peek.l(?comLong_BlockEndY)
        Gosub JL_0_695E
        Pop If
        !asm
        RTS
      Else
        Gosub JL_0_68C4
        yMin = Peek.l(?comLong_BlockStartY) - Peek.l(?comLong_DisplayLineOffset) + 1
        yMax = Peek.l(?comLong_BlockEndY) - Peek.l(?comLong_DisplayLineOffset)
        If yMax > Peek.l(?viewablelines) Then yMax = Peek.l(?viewablelines)

        If yMax < yMin      ; when does that happen???
          Gosub JL_0_6906   ; update missing block last line
          Pop If
          !asm
          RTS
        EndIf
        Gosub JL_0_6906 ;update missing block last line

        ; add missing block on the right except first and last line
        ;xMin = Peek.w(?source_BoxLeft) + xMin * \font\tf_XSize
        xMin = (xMin - Peek.w(?comWord_ColumnsOffset)) * \font\tf_XSize
        xMax = xMin + \font\tf_XSize * 2 - 1
        yMin = yMin * \font\tf_YSize
        yMax = yMax * \font\tf_YSize - 1
        If (xMax => xMin) AND (yMax => yMin)
          RectFill_ Peek.l(?rp_rectfill), Peek.w(?source_BoxLeft) + xMin, yMin, Peek.w(?source_BoxLeft) + xMax, yMax
        Else
          log_Print{"illegal area for update_blockmark right"}
        EndIf
      EndIf
    EndIf
  EndIf
  !asm
RTS

.JL_0_68C4:
  If xMin >= Peek.w(?comLong_BlockStartX)
    yMaxold.l = yMax : xMaxold.l = xMax : yMinold.l = yMin : xMinold.l = xMin

    xMin = (xMin - Peek.w(?comWord_ColumnsOffset)) * \font\tf_XSize
    xMax = xMin + \font\tf_XSize * 2 - 1
    yMin = Peek.l(?comLong_BlockStartY) - Peek.l(?comLong_DisplayLineOffset)
    yMin = yMin * \font\tf_YSize
    yMax = yMin + Peek.w(?fontHeightm1)
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ Peek.l(?rp_rectfill), Peek.w(?source_BoxLeft) + xMin, yMin, Peek.w(?source_BoxLeft) + xMax, yMax
    Else
      log_Print{"illegal area for JL_0_68C4"}
    EndIf

    yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return

.JL_0_6906: ; update mission block last line
  If xMin <= Peek.w(?comLong_BlockEndX) + 1
    yMaxold.l = yMax : xMaxold.l = xMax : yMinold.l = yMin : xMinold.l = xMin

    d4.l = Peek.w(?comLong_BlockEndX) - xMin + 1 + 2
    If d4 > 2 Then d4 = 2     ; we scroll always 2 characters
    d4 = d4 * \font\tf_XSize

    xMin = xMin - Peek.w(?comWord_ColumnsOffset)
    xMin = xMin * \font\tf_XSize
    xMax = xMin + d4 - 1
    yMin = Peek.l(?comLong_BlockEndY) - Peek.l(?comLong_DisplayLineOffset)
    yMin = yMin * \font\tf_YSize
    yMax = yMin + Peek.w(?fontHeightm1)
    ;log_Print{"d4: " +Str$(d4) + " blockendX: " + Str$(Peek.w(?comLong_BlockEndX))}
    ;log_Print{"d4: " +Str$(d4) + " blockendy: " + Str$(Peek.l(?comLong_BlockEndY))}
    ;log_Print{"d4: " +Str$(d4) + " blockstartX: " + Str$(Peek.w(?comLong_BlockStartX))}
    ;log_Print{">> xMin:"+Str$(xMin) + " ymin:"+Str$(yMin) + " xMax:"+Str$(xMax) + " ymax:"+Str$(yMax)}
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ Peek.l(?rp_rectfill), Peek.w(?source_BoxLeft) + xMin, yMin, Peek.w(?source_BoxLeft) + xMax, yMax
    Else
      log_Print{"illegal area for JL_0_6906"}
    EndIf


    yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return

.JL_0_695E: ; all in the same line
  If (xMin >= Peek.w(?comLong_BlockStartX)) AND (xMin <= Peek.w(?comLong_BlockEndX))
    log_Print{"JL_0_695E"}
    d4.l = Peek.w(?comLong_BlockEndX) - xMin + 1
    If d4 > 2 Then d4 = 2
    d4 = d4 * \font\tf_XSize

    xMin = xMin - Peek.w(?comWord_ColumnsOffset)
    xMin = xMin * \font\tf_XSize
    xMax = xMin + d4
    yMin = Peek.l(?comLong_BlockStartY) - Peek.l(?comLong_DisplayLineOffset)
    yMax = yMin * \font\tf_YSize + Peek.w(?fontHeightm1)
    yMin = yMin * \font\tf_YSize
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ Peek.l(?rp_rectfill), Peek.w(?source_BoxLeft) + xMin, yMin, Peek.w(?source_BoxLeft) + xMax, yMax
    Else
      log_Print{"illegal area for JL_0_695E"}
    EndIf

  EndIf
Return


.source_scroll_to_left:
;  !regs2stack
  !basic
  USEPATH sourceWindow
  dx.w = \font\tf_XSize * 2
  dy.w = 0
  xMin.w = Peek.w(?source_BoxLeft)
  yMin.w = 0
  xMax.w = Peek.w(?source_BoxLeft) + Peek.w(?visiblecolumns) * \font\tf_XSize - 1
  yMax.w = Peek.l(?viewablelines) * \font\tf_YSize - 1

  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax
  WaitBlit_
  !asm
;  !stack2regs
  JSR delay
RTS

.draw_new_columns:
  JSR save_cursorposition
  MOVE.w visiblecolumns,D0
  SUBQ.w #2,D0
  MOVE.w D0,comWord_Column
  CLR.l comLong_DisplayLine
;  CLR.l comLong__AL_0_868A
  CLR.w comWord_TextBufferOffset
  MOVEA.l textbufferaddr,A5
  ADDA.w comWord_ColumnsOffset,A5
  ADDA.w D0,A5
  MOVE.l viewablelines,D2
  SUBQ.w #1,D2
  CLR.w comWord_ColumnsOffsetTmp

  JL_0_6AFA:
    MOVEA.l AL_0_5B9E,A0
    MOVE.b (A5),(A0)
    MOVE.b $1(A5),$1(A0)
    MOVEQ.l #$00,D0
    MOVE.w comWord_Column,D0
    MULU fontWidth,D0
    MOVE.l comLong_DisplayLine,D1
    MULU fontHeight,D1
    ST comWord__AL_0_8668
    MOVEM.l d0-d2/a0,-(a7)
    MOVE.l textbufferaddr,a0
    ADD.w comWord_TextBufferOffset,a0
    CLR.b instring2
    MOVE.w #0,d2
    CMP.l #0,a0
    BEQ 'l2b
    MOVE.w comWord_ColumnsOffset,d1
    ADD.w visiblecolumns,d1
    SUBQ.w #1,d1
   'l1
      CMP.w d1,d2
      BGE 'l2b
      MOVE.b (a0)+,d0
      CMP.b #$22,d0
      BNE 'l2
      NOT.b instring2
     'l2
      ADDQ.w #1,d2
    BRA 'l1
   'l2b
    MOVEM.l (a7)+,d0-d2/a0

    MOVE.b #1,keepstring
    JSR print_complete_line               ; inputs d0:x, d1:y, a0: text
    CLR.b keepstring
    BSR process_highlightning
    SF comWord__AL_0_8668
    MOVEQ.l #$00,D0
;    MOVE.w comWord__AL_0_86CC,D0
;    ADD.l D0,comLong__AL_0_868A
    MOVE.w comWord_MaxColumns,D0
    ADDA.w D0,A5
    ADD.w D0,comWord_TextBufferOffset
    ADDQ.l #1,comLong_DisplayLine
  DBF D2,JL_0_6AFA
  JSR restore_cursorposition
RTS




.alloc_newline:
  MOVEQ.l #$0A,D0
  ;MOVEQ.l #$01,D1               ; not needed with AllocPooled
  ;MOVEA.l _execbase,A6          ; execbase is set in macro
  ;MOVE.w #$FFFF,comWord__AL_0_86C0
  !newalloc                      ; d0= AllocPooled(A0:poolHeader,D0:memSize)
  TST.l D0
  BEQ.w JL_0_6B7A
    MOVEA.l D0,A0                ; init sourceline struct
    CLR.l (A0)
    CLR.l $4(A0)
    MOVE.w #$0100,$8(A0)
  JL_0_6B7A:
RTS

.clear_sourcebuffer:
  JSR reset_Blockflag
  CLR.w comWord_Column
  CLR.l comLong_DisplayLine
  CLR.w comWord_TextBufferOffset
  CLR.l comLong_DisplayLineOffset
  CLR.w comWord_ColumnsOffset
  CLR.w comWord_SourceChanged
  CLR.l comPtr_LabelList
  CLR.w comWord_LabelCounter
  CLR.b comStr_SourceName

  MOVE.l #$0001,comLong_TotalLines
  JSR JL_0_5B00

  JSR update_horizscroller
  JSR update_modifiermark
  JSR update_vertscroller
  JSR draw_statusarea
  MOVEQ.l #-$01,D0
RTS

.StoreCurrentSourceLine:
  MOVEA.l comPtr_CurrentSourceLine,A1
  MOVE.b comByte_LabelIdentifier,D0
  MOVEM.l D0/A0-A2,-(A7)
  LEA $9(A1),A2                           ; save current source line to undeletestore
  MOVEA.l lineundeletestore,A0
  TST.b (A2)
  BEQ.b JL_0_6BFE
    MOVEQ.l #$00,D0
    MOVE.b $8(A1),D0                      ; stringlength of source line
    MOVE.w D0,comWord_UndeleteStoreStrLen
    SUBQ.w #1,D0
    JL_0_6BF8:
      MOVE.b (A2)+,(A0)+
    DBF D0,JL_0_6BF8
  JL_0_6BFE:
  MOVEM.l (A7)+,D0/A0-A2
  BRA.b JL_0_6C0C

  JL_0_6C04:
  MOVEA.l comPtr_CurrentSourceLine,A1
  MOVE.b comByte_LabelIdentifier,D0

  JL_0_6C0C:
  MOVE.l A1,-(A7)                      ; currentsoureline struct
  LEA $9(A1),A1                        ; begin of string
  JL_0_6C12:
    CMPI.b #$20,(A1)+                  ; skip spaces
  BEQ.b JL_0_6C12

  CMP.b -(A1),D0                       ; first character to d0
  BEQ 'l10                             ; if not null ...
 'l20
    MOVE.b (A1),D0
    BEQ JL_0_6C24                      ; if null free memory and return
    CMP.b #";",d0                      ; stop if comment found

    BEQ 'l10
      CMP.b #$80,d0                    ; 128 ? why this check?
      BNE 'l15
        CMP.b #$2d,1(a1)               ; "-" as second character?
        BEQ 'l10
     'l15
      ADDQ.l #1,a1
      BRA 'l20
 'l10
  JSR JL_0_472A                        ; set LabelListchanged-Flag

  JL_0_6C24:
  MOVEA.l (A7)+,A1
  ;ST comWord__AL_0_86C0
  !newfree
RTS

.clear_actualsource:
  MOVEA.l _execbase,A6
  MOVEA.l comPtr_FirstSourceLine,A2
  MOVE.l comLong_TotalLines,D2
  BEQ skip_freesource
    SUBQ.l #1,D2
    JL_0_6C40:
      MOVEA.l A2,A1
      MOVEA.l (A1),A2
      !newfree
    DBF D2,JL_0_6C40
  skip_freesource:
  ;ST comWord__AL_0_86C0
  JSR clear_labellist
RTS


.create_whole_gui:
  JSR open_gui
   BMI.w JUMP_exit_PED_closeall
  JSR update_vertscroller
  JSR update_horizscroller
BRA.w _redraw

JUMP_exit_PED_closeall:
JMP exit_PED_closeall

.SetGuiFontToWBScreenFont:                            ;Subroutine to get the used Screenfont of the WB an set it as guifont  tomsmart1
    WbToScreen 0                                      ; set WB to screen 0
    *scr.Screen = Peek.l(Addr Screen(0))              ; get pointer of this screen
    If *scr <> 0                                      ; check if we get a screenstructure
      *scrfont.TextAttr=*scr\Font                     ; try to get the font out of the screenstructur
      If *scrfont<>0                                  ; check if we get a TextAttrstructure

        ; In AmigaDOS we trust :
        guifontsize.w=(*scrfont.TextAttr\ta_YSize)    ; get size of the font
        guifont$=Peek$(*scrfont.TextAttr\ta_Name)     ; get name of the font

       ; message{"WB fontname="+guifont$+"("+Str$(guifontsize)+")"}  ; for debug only to see if we get the right font ;)
      EndIf

    EndIf
Return


.open_gui:
  !basic
  log_Print{"opening gui..."}
  If (use_wbfont = True)  OR  (use_wbscreen<>0)              ; check if we use workbench fonts or screen for Gui tomsmart1

    ;Gosub SetGuiFontToWBScreenFont                                   ; try to get the workbench screen font settinge out of the screen structure tomsmart1
    ;*guifont.TextFont = screen_SetDefaultFont{guifont$,guifontsize}  ; and try to use it for the Gui of oure own screen  tomsmart1
    screen_SetDefaultSysFont{#scr_sysfont_wb_prop}                    ; switch on sysfont overwrite for use Workbench screen font  tomsmart1

  Else

    screen_SetDefaultSysFont{#scr_sysfont_wb_off}                     ; switch off sysfont overwrite we want to use the selected font for the Gui  tomsmart1

    If guifont$<>""
      If guifontsize <= 0 Then guifontsize = 6
      *guifont.TextFont = screen_SetDefaultFont{guifont$,guifontsize} ; try to set selected font for the Gui  tomsmart1
    EndIf

    If *guifont = 0                                                   ; unable to open font => use system default
      log_Print{"Could not open selected font <" + guifont$ + ">, using Workbench Font instead.",#log_warning}
      Gosub SetGuiFontToWBScreenFont                                  ; try to get the workbench screen font settinge out of the screen structure tomsmart1
      *guifont = screen_SetDefaultFont{guifont$,guifontsize}          ; and try to use it for the Gui of oure own screen  tomsmart1
    EndIf
    If *guifont = 0
      log_Print{"We also failed to get the font of the Workbench, we now use the default font.",#log_warning}
      screen_SetDefaultSysFont{#scr_sysfont_wb_prop}                  ; switch on sysfont overwrite for use Workbench screen font  tomsmart1
    End If

  EndIf

  default_screentitle$ = "AmiBlitz3 - PED V\\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH"
  If use_wbscreen <> 0                                    ; -- use workbench here
    If screen_Open{default_screentitle$,#scr_mode_wb_use} = False
      !asm
      JMP error_openscreen
    Else
      Poke$ ?screen_number,"WB"
    EndIf
  Else
    If use_pubscreen                                 ; -- searching for already opened ab3-screens
      screen_ziffer.b = 1 : exit_screensearch.b = False
      Poke.w ?screen_number,0  ; to set the termination (end)to str_defaultpubscreen string without a number if the gui reopen  tomsmart1
      Repeat
        GetPubScreen 2,Peek$(?str_defaultpubscreen) + Str$(screen_ziffer)
        If Peek.l(Addr Screen(2))<>0
          ReleasePubScreen 2
          screen_ziffer + 1
        Else
          exit_screensearch = True
        EndIf
      Until exit_screensearch
      Poke$ ?screen_number,Str$(screen_ziffer)
      screen_SetPubName{Peek$(?str_defaultpubscreen)}        ; set name "str_defaultpubscreen+screen_number"
      WbToScreen 0 ; we need this, because GetPubScreen is steeling us the focus on screen 0
    EndIf

    If clone_wbscreen <> 0                                ; -- clone the workbench for one screen
      If screen_Open{default_screentitle$,#scr_mode_wb_clone} = False
        !asm
        JMP error_openscreen
      EndIf
    Else
      If screen_Open{default_screentitle$,myscreen_modeid,myscreen_Width,myscreen_Height,myscreen_Depth} = False
        err_msg$ = "Could not open selected screen.\\nTrying to open default screen."
        log_Print{err_msg$,#log_warning}
        dummy.l = ask{!TRANS{err_msg$},!TRANS{"Ok"},!TRANS{"Error"}}

        clone_wbscreen = 1    ;try clone Wbscreen
        If screen_Open{default_screentitle$,#scr_mode_wb_clone} = False
          err_msg$ = "Could not clone WB-screen, using WB itself."
          dummy.l = ask{!TRANS{err_msg$},!TRANS{"Ok"},!TRANS{"Error"}}
          clone_wbscreen = False  ; no clone Wbscreen
          use_wbscreen = True     ; try use Wbscreen
          If screen_Open{default_screentitle$,#scr_mode_wb_use} = False
            !asm
            JMP error_openscreen
          EndIf
        EndIf

        ;-- get current Screen infos and store it for a update prefs/save
        myscreen_Width  = screen_GetWidth{}
        myscreen_Height = screen_GetHeight{}
        myscreen_Depth  = screen_GetDepth{}
        log_Print{"getting best screenmodeid..."}
        If NOT KickVersion(39)
          myscreen_modeid = screen_GetBestModeID{myscreen_Width,myscreen_Height,myscreen_Depth}
        Else
          err_msg$ = "Sorry, to obtain best matching screen mode, we need at least OS3.0!\\n"
          error{err_msg$,!TRANS{"Error"}}
          myscreen_modeid = 0
        EndIf
        ;Poke.l ?ownscreen_modeid ,myscreen_modeid
        ;Poke.w ?ownscreen_height ,myscreen_Height
        ;Poke.w ?ownscreen_width  ,myscreen_Width
        ;Poke.w ?ownscreen_depth  ,myscreen_Depth
      EndIf
    EndIf
  EndIf
  If (screen_GetDepth{} < 4) ; AND (Peek.b(?newcolormode)<>0)
    log_Print{"screen colors: " + Str$(1 LSL screen_GetDepth{}),#log_debug}
    log_Print{"screen_GetDepth(): "+ Str$(screen_GetDepth{}),#log_debug}
    dummy.l = ask{!TRANS{"It is recommended to open a screen with at least 16 colors."},!TRANS{"Ok"},!TRANS{"Info"}}
  EndIf
  sourceWindow\pedScreen = Peek.l(Addr Screen(0))

  If screen_GetModeID{}<>#scr_mode_wb_use
    If use_default_pubscreen
      log_Print{"settings defaultpubscreen"}
      SetDefaultPubScreen_ ?str_defaultpubscreen
    EndIf
  EndIf
  log_Print{"setting colors..."}
  Gosub set_storedcolors

  !asm
  ; -- inform via arexx
  ; -- that the window is opened
  JSR arexx_send_openwindow
  !basic

  log_Print{"init menues"}
  Gosub init_menus
  log_Print{"init windowlayouts"}
  Gosub load_windowlayouts
  If autolayout><-1 Then AutoLayout{&wtemp,autolayout}
  log_Print{"do window layout"}
  Gosub do_windowlayout
  log_Print{"do window layout finished"}
  !asm
  MOVE.l #$00,D0
RTS

win_BorTop:   Dc.w 0
win_BorBot:   Dc.w 0
win_BorLef:   Dc.w 0
win_BorRig:   Dc.w 0
win_TopLeft:  Dc.w 0
win_Width:    Dc.w 1000
win_Height:   Dc.w 200

.open_sourcewindow:
  !regs2stack

  ; -- check arexx
  !basic
  If *ArexxMsgPort.MsgPort <> 0
    *incomingRexxMsg.RexxMsg = GetMsg_(*ArexxMsgPort)
    Poke.l ?struct_RexxMsg,*incomingRexxMsg
    If *incomingRexxMsg <> 0 Then Gosub event_arexx_bas
  EndIf
  !asm
;  JL_0_6EEC:
;  MOVEA.l _execbase,A6
;  MOVEA.l struct_ArexxMsgPort,A0
;  CMPA.l #$0,A0
;  BEQ.w no_arexx_message
;    JSR _GetMsg(A6)
;    TST.l D0
;    BEQ.w no_arexx_message
;      MOVE.l D0,struct_RexxMsg
;      JSR event_arexx
;  BRA.b JL_0_6EEC
;  no_arexx_message:





  ; -- fill font structure
  MOVEQ #0,d0
  MOVE.w sourcefontsize,D0
  MOVE.w D0,fontHeight
  SUBQ.w #1,D0
  MOVE.w D0,fontHeightm1
  MOVEA.l ptr_sourcefont,A0
  MOVE.w $18(A0),fontWidth
  MOVE.w $1A(A0),font_Baseline

  !basic
  DEFTYPE.Image       *img             ; An image which represents the size gadget
  DEFTYPE.Image       *sizeimage,*rarrowimage,*larrowimage,*darrowimage,*uarrowimage
  DEFTYPE.Gadget      *horizprop,*rarrowbutton,*larrowbutton,*darrowbutton,*uarrowbutton
  DEFTYPE.l sizew,sizeh,w,h,barh,exit

  Dim GTags.TagItem(4) ; -- Tags for getting the size gadget image
  If Used Screen < 0 Then WbToScreen 0
  *myscreen = Peek.l(Addr Screen(Used Screen))
  If *myscreen <> 0
    Poke.b ?comByte_ScreenBarHeight, *myscreen\BarHeight
    If Peek.w(?win_Width)<32  Then Poke.w ?win_Width, (*myscreen\Width - Peek.w(?win_TopLeft)-1)
    If Peek.w(?win_Height)<32 Then Poke.w ?win_Height ,(*myscreen\Height - Peek.w(?win_TopEdge)-1)
    If Peek.w(?win_TopEdge)+Peek.w(?win_Height )> *myscreen\Height Then Poke.w ?win_Height ,*myscreen\Height-Peek.w(?win_TopEdge)
    If Peek.w(?win_TopLeft)+Peek.w(?win_Width) > *myscreen\Width  Then Poke.w ?win_Width, *myscreen\Width-Peek.w(?win_TopLeft)

    Poke.w ?win_BorTop, *myscreen\WBorTop + *myscreen\Font\ta_YSize + 1
    Poke.w ?win_BorBot, 10
    Poke.w ?win_BorRig, 18
    Poke.w ?win_BorLef, *myscreen\WBorLeft

    *drawinfo = GetScreenDrawInfo_(*myscreen)
    If *drawinfo
      If (*myscreen\Flags & #SCREENHIRES) Then sis.l=#SYSISIZE_HIRES Else sis=#SYSISIZE_MEDRES
      GTags(0)\ti_Tag = #SYSIA_DrawInfo,*drawinfo
      GTags(1)\ti_Tag = #SYSIA_Which,#SIZEIMAGE
      GTags(2)\ti_Tag = #SYSIA_Size,sis
      GTags(3)\ti_Tag = #TAG_DONE
      *img = NewObjectA_(0,"sysiclass",&GTags(0))
      If *img
        Poke.w ?win_BorRig, *img\Width
        Poke.w ?win_BorBot, *img\Height
        DisposeObject_ *img
      EndIf
      FreeScreenDrawInfo_ *myscreen,*drawinfo
    EndIf
  Else
    !asm
    JSR close_gui
    JMP error_openscreen
  EndIf
  !asm
  !stack2regs


  MOVEM.l D2-D7/A2-A6,-(A7)
  TST.l ptr_sourcewindow
  BNE.w win_already_open
  ; --
  ; -- Berechnung des Sourcelayouts, Groesse der Scroller etc.
  ; --
  JSR calc_SourceWindowDimensions
  ;
  ; -- Speicher reservieren fuer sichtbaren Sourcebereich
  ;
  BSR allocate_textbuffer

  ; --
  ; -- Fenster erzeugen
  ; --
  !basic
  #GID_XPROP  =900
  #GID_YPROP  =901
  #GID_RARROW =910
  #GID_LARROW =911
  #GID_UARROW =912
  #GID_DARROW =913

  *drawinfo = GetScreenDrawInfo_(*myscreen)
  If (*myscreen\Flags & #SCREENHIRES)
    syssize.b = #SYSISIZE_MEDRES
  Else
    syssize = #SYSISIZE_LOWRES
  EndIf
  *sizeimage = NewObjectA_(0,"sysiclass",Tags(#SYSIA_Which,#SIZEIMAGE,@@
                                                #SYSIA_Size     ,syssize,@@
                                                #SYSIA_DrawInfo ,*drawinfo,@@
                                                #TAG_END        ,0))
  If (*sizeimage)
    GetAttr_ #IA_Width,*sizeimage ,&sizew
    GetAttr_ #IA_Height,*sizeimage,&sizeh
    DisposeObject_ *sizeimage
  Else
    sizew = 18
    sizeh = 10
  EndIf

  *darrowimage = NewObjectA_(0,"sysiclass",Tags(#SYSIA_Which,#DOWNIMAGE,@@
                                                   #SYSIA_Size     ,syssize,@@
                                                   #SYSIA_DrawInfo ,*drawinfo,@@
                                                   #TAG_END        ,0))
  If (*darrowimage)
    GetAttr_ #IA_Width ,*darrowimage,&w
    GetAttr_ #IA_Height,*darrowimage,&h
  EndIf

  *darrowbutton = NewObjectA_(0,"buttongclass",Tags(#GA_ID,#GID_DARROW,@@
    #GA_RelRight    ,-w+1,@@
    #GA_RelBottom   ,-sizeh-h+1,@@
    #GA_Width       ,w,@@
    #GA_Height      ,h,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,*drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #GA_Image       ,*darrowimage,@@
    #TAG_END        ,0))

  *uarrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#UPIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,*drawinfo,@@
    #TAG_END        ,0))

  If (*uarrowimage)
    GetAttr_ #IA_Width ,*uarrowimage,&w
    GetAttr_ #IA_Height,*uarrowimage,&h
  EndIf

  *uarrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous    ,*darrowbutton,@@
    #GA_ID          ,#GID_UARROW,@@
    #GA_RelRight    ,-w+1,@@
    #GA_RelBottom   ,-sizeh-h-h+1,@@
    #GA_Width       ,w,@@
    #GA_Height      ,h,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,*drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #GA_Image       ,*uarrowimage,@@
    #TAG_END        ,0))

  barh = *myscreen\WBorTop+*myscreen\RastPort\TxHeight+2

  *vertiprop = NewObjectA_(0,"propgclass",Tags(@@
    #GA_Previous    ,*uarrowbutton,@@
    #GA_ID          ,#GID_YPROP,@@
    #GA_RelRight    ,-sizew+4,@@
    #GA_Top         ,barh,@@
    #GA_Width       ,sizew-6,@@
    #GA_RelHeight   ,-sizeh-h-h-barh-1,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,*drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #PGA_Freedom    ,#FREEVERT,@@
    #PGA_Borderless ,True,@@
    #PGA_NewLook    ,True,@@
    #PGA_Total      ,1,@@
    #PGA_Visible    ,1,@@
    #TAG_END        ,0))

  *rarrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#RIGHTIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,*drawinfo,@@
    #TAG_END        ,0))

  If (*rarrowimage)
    GetAttr_ #IA_Width ,*rarrowimage,&w
    GetAttr_ #IA_Height,*rarrowimage,&h
  EndIf

  *rarrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous     ,*vertiprop,@@
    #GA_ID           ,#GID_RARROW,@@
    #GA_RelRight     ,-sizew-w+1,@@
    #GA_RelBottom    ,-h+1,@@
    #GA_Width        ,w,@@
    #GA_Height       ,h,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,*drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #GA_Image        ,*rarrowimage,@@
    #TAG_END         ,0))

  *larrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#LEFTIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,*drawinfo,@@
    #TAG_END        ,0))

  If (*larrowimage)
    GetAttr_ #IA_Width ,*larrowimage,&w
    GetAttr_ #IA_Height,*larrowimage,&h
  EndIf

  *larrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous     ,*rarrowbutton,@@
    #GA_ID           ,#GID_LARROW,@@
    #GA_RelRight     ,-sizew-w-w+1,@@
    #GA_RelBottom    ,-h+1,@@
    #GA_Width        ,w,@@
    #GA_Height       ,h,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,*drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #GA_Image        ,*larrowimage,@@
    #TAG_END         ,0))

  *horizprop = NewObjectA_(0,"propgclass",Tags(@@
    #GA_Previous     ,*larrowbutton,@@
    #GA_ID           ,#GID_XPROP,@@
    #GA_Left         ,*myscreen\WBorLeft,@@
    #GA_RelBottom    ,-sizeh+3,@@
    #GA_RelWidth     ,-sizew-w-w-*myscreen\WBorLeft-1,@@
    #GA_Height       ,sizeh-4,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,*drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #PGA_Freedom     ,#FREEHORIZ,@@
    #PGA_Borderless  ,True,@@
    #PGA_NewLook     ,True,@@
    #PGA_Total       ,#MAX_Columns,@@
    #PGA_Visible     ,20,@@
    #TAG_END         ,0))


  If (*vertiprop=0) OR( *horizprop=0)
    dummy.l = ask{Hex$(*vertiprop),Hex$(*horizprop),!TRANS{"Info"}}
    !asm
    CLR.l ptr_sourcewindow
    BRA.w error_opensourcewindow                   ; bei Fehler ...
  EndIf

  ; only added OS4 only IDCMP Flags if we are running on OS4  tomsmart1
  SourceWindowIDCMPFlags.l = #IDCMP_INTUITICKS|#IDCMP_CLOSEWINDOW|#IDCMP_VANILLAKEY
  SourceWindowIDCMPFlags | #IDCMP_RAWKEY|#IDCMP_MENUPICK|#IDCMP_GADGETUP|#IDCMP_GADGETDOWN
  SourceWindowIDCMPFlags | #IDCMP_MOUSEMOVE|#IDCMP_MOUSEBUTTONS|#IDCMP_NEWSIZE|#IDCMP_REFRESHWINDOW
  SourceWindowIDCMPFlags | #IDCMP_ACTIVEWINDOW|#IDCMP_INACTIVEWINDOW   ; added to get info if the source win (in)active
  If OSVersion = #AmigaOS4
    SourceWindowIDCMPFlags|#IDCMP_EXTENDEDMOUSE  ;added #IDCMP_EXTENDEDMOUSE for OS4 Mousewheel support
  EndIf

  SourceWindowWFlags.l = #WFLG_NEWLOOKMENUS|#WFLG_WBENCHWINDOW|#WFLG_ACTIVATE|#WFLG_GIMMEZEROZERO
  SourceWindowWFlags   | #WFLG_SIZEBBOTTOM|#WFLG_SIZEBRIGHT|#WFLG_SIZEGADGET|#WFLG_CLOSEGADGET|#WFLG_DEPTHGADGET
  SourceWindowWFlags   | #WFLG_DRAGBAR|#WFLG_REPORTMOUSE
  log_Print{"opening source window"}


  sourceWindow.sourceWindow\win = OpenWindowTagList_(0,Tags(@@
                      #WA_Title      ,"AmiBlitz3",@@
                      #WA_Left       ,Peek.w(?win_TopLeft),@@
                      #WA_Top        ,Peek.w(?win_TopEdge),@@
                      #WA_Height     ,Peek.w(?win_Height ),@@
                      #WA_Width      ,Peek.w(?win_Width),@@
                      #WA_MinWidth   ,256,@@
                      #WA_MaxWidth   ,-1,@@
                      #WA_MinHeight  ,80,@@
                      #WA_MaxHeight  ,-1,@@
                      #WA_Flags      ,SourceWindowWFlags,@@
                      #WA_IDCMP      ,SourceWindowIDCMPFlags,@@
                      #WA_Gadgets    ,*darrowbutton,@@
                      #WA_PubScreen  ,*myscreen))
  If sourceWindow\win = 0
    Pop If
    !asm
    CLR.l ptr_sourcewindow
    BRA.w error_opensourcewindow                   ; bei Fehler ...
  EndIf

  log_Print{"setting window pointers for asmcode"}
  Poke.l ?ptr_sourcewindow,sourceWindow\win
  Poke.l ?rp_sourcewindow ,sourceWindow\win\RPort
  Poke.l (Addr Window(0) ),sourceWindow\win  ; to set the Window address in the BlitzBasic structure so we can use  "Use Window 0" this helps to shown the requesters of the error.include one the Amiblitz screen and not on the WB

  log_Print{"attaching menustrip to window"}
  ; Anhaengen des Menus
  If Peek.l(?addr_menustrip) Then SetMenuStrip_ sourceWindow\win,Peek.l(?addr_menustrip)

  log_Print{"setting font"}
  ; Setzen des Standardfonts
  SetFont_ sourceWindow\win\RPort,Peek.l(?ptr_sourcefont)

  ; attach sourcewindow to peds process
  log_Print{"find current task"}
  *this_process.Process = FindTask_("")
  Poke.l ?ptr_windowPtrTemp, *this_process\pr_WindowPtr
  *this_process\pr_WindowPtr = sourceWindow\win
  !asm
  MOVE.w #$FFFF,comWord_LabelListChanged     ; indicate that label window has to be updated too
  ;MOVEA.l _execbase,A6
  ;SUBA.l A1,A1
  ;JSR _FindTask(A6)
  ;MOVEA.l D0,A0
  ;MOVE.l $B8(A0),ptr_windowPtrTemp
  ;MOVE.l ptr_sourcewindow,$B8(A0)

  win_already_open:
  !basic
  ; -- Setzen des WindowTitles
  log_Print{"set window title"}
  SetWindowTitles_ sourceWindow\win,&default_screentitle$,-1
  log_Print{"update statusarea"}
  !asm
  JSR draw_statusarea
  JSR set_pointer_normal

  ; -- allocate memory for temp rastport
  MOVEM.l D0-D1/A0-A1/A6,-(A7)
  MOVEQ.l #$64,D0
  !newalloc
  MOVE.l D0,rp_rectfill
  MOVEA.l rp_sourcewindow,A0
  MOVEA.l D0,A1
  MOVEQ.l #$63,D0
  JL_0_7300:
    MOVE.b (A0)+,(A1)+
  DBF D0,JL_0_7300

  !basic
  log_Print{"set drawmode for blockselection rastport"}
  SetDrMd_ Peek.l(?rp_rectfill), #COMPLEMENT
  !asm
  MOVEM.l (A7)+,D0-D1/A0-A1/A6

  JSR clear_sourcewindow
  JSR _redraw
  JSR update_horizscroller
  JSR update_vertscroller
  MOVEM.l (A7)+,D2-D7/A2-A6
  MOVEQ.l #$00,D0
RTS


.calc_SourceWindowDimensions:
  !basic
  Poke.w ?source_BoxHeight, Peek.w(?win_Height ) - Peek.w(?win_BorTop) - Peek.w(?win_BorBot)
  Poke.w ?source_BoxWidth , Peek.w(?win_Width)   - Peek.w(?win_BorLef) - Peek.w(?win_BorRig)

  If Peek.b(?linenumbers)
    digits.b = 5
    If Peek.l(?comLong_TotalLines) < 10000 Then digits = 4
    If Peek.l(?comLong_TotalLines) < 1000 Then digits = 3
    If Peek.l(?comLong_TotalLines) < 100 Then digits = 2
    If Peek.l(?comLong_TotalLines) < 10 Then digits = 2
    linenumberWidth.w = digits * Peek.w(?fontWidth)

    Poke.w ?source_BoxLeft, linenumberWidth + 3
  Else
    Poke.w ?source_BoxLeft, 0
  EndIf

  USEPATH sourceWindow
  \visibleLines = (Peek.w(?source_BoxHeight) - 6) / Peek.w(?fontHeight)  ; 6 Pixel fehlen wg. Trennlinie etc.
  ;If \visibleLines > 125 Then \visibleLines = 125 ; why?

  \visibleLines - 2       ; subtract two lines for status area

  Poke.l ?viewablelines,\visibleLines
  Poke.l ?viewablelines_m1, \visibleLines - 1
  Poke.w ?ypos_statusarea, \visibleLines * Peek.w(?fontHeight)
  sourceWindow\statusAreaY = \visibleLines * Peek.w(?fontHeight)

  ;visibleColumns.w = (Peek.w(?source_BoxWidth) - Peek.w(?source_BoxLeft)) / Peek.w(?fontWidth)
  ;visibleColumns = visibleColumns AND (NOT 1)
  ;Poke.w ?visiblecolumns,visibleColumns
  ;Poke.w ?comWord__AL_0_8670, (visibleColumns - 1) AND (NOT 1)
  !asm
  MOVE.w source_BoxWidth,D0
  SUB.w source_BoxLeft,D0
  EXT.l d0
  DIVU fontWidth,d0
  BCLR #0,D0
  MOVE.w D0,visiblecolumns
  SUBQ.w #1,D0
  BCLR #0,D0
  MOVE.w D0,comWord__AL_0_8670

  BCLR #0,comLong_BoundLinesX
  MOVE.w comWord_LabelSize,comWord_LabelSizeC
RTS


.error_opensourcewindow:
  JSR free_textbuffer
  JSR close_sourcewindow

  !basic
  *easystruct.EasyStruct = ?easystruct_error
  *easystruct\es_TextFormat = ?str_unable_window
  Gosub show_requester
  !asm

  JL_0_7334:
  !basic
  !coutclose
  CloseAllWZWindows{}

  screen_Close{} ;/* screen close knows if it is on wb! */

  !asm
JMP exit_PED_closeall

.error_openscreen:
  JSR free_textbuffer
  !basic
  *easystruct.EasyStruct = ?easystruct_error
  *easystruct\es_TextFormat = ?str_unable_screen
  Gosub show_requester
  !asm
  ; set Reg D0 to negative for return value of open_gui
  MOVEQ.l #-$01,D0
RTS

ptr_windowPtrTemp:    Ds.l 1

.print_actualsourceline:
  !basic
  sourceWindow\currentLine = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) + 1
  formatstr$ = "      " : len_fmtstr.b = FLen(formatstr$)
  formatstr$ = StrRight(Str$(sourceWindow\currentLine),len_fmtstr,48)  ; mit nullen auffuellen
  PED_PrintStatus{formatstr$,18}
  !asm
RTS

.print_actualsourcecolumn
  !basic
  sourceWindow\currentColumn = Peek.w(?comWord_ColumnsOffset) + Peek.w(?comWord_Column) + 1
  formatstr$ = "   " : len_fmtstr.b = FLen(formatstr$)
  formatstr$ = StrRight(Str$(sourceWindow\currentColumn),len_fmtstr,48)  ; mit nullen auffuellen
  PED_PrintStatus{formatstr$,3}
  !asm
RTS

.print_availmem:
  availchip.l = AvailMem_(#MEMF_CHIP) / 1024
  availfast.l = AvailMem_(#MEMF_FAST) / 1024
  Format "###0,000"
  availmem$ = "CHIP " + StrPack(Str$(availchip)) + "kb"
  availmem$ + " | FAST " + StrPack(Str$(availfast)) + "kb"
  Format ""

  PED_PrintStatus{availmem$,Len(availmem$),2}
RTS


.update_statusarea:
  !basic
  JSR print_availmem
  !asm
  JSR print_actualsourceline
  JSR print_actualsourcecolumn
RTS

.draw_statusarea:
  !basic
  USEPATH sourceWindow

  ;-- clear area
  SetAPen_  \win\RPort, AB3Pen(#AB3_screenfill)
  If \statusAreaY <= \win\GZZHeight
    RectFill_ \win\RPort, 0,\statusAreaY,\win\GZZWidth,\win\GZZHeight
  Else
    log_Print{"illegal area for draw statusara"}
  EndIf

  ;-- Draw separation lines
  SetAPen_ \win\RPort, AB3Pen(#AB3_screenshine)
  Move_ \win\RPort,0,\statusAreaY : Draw_ \win\RPort,\win\GZZWidth,\statusAreaY
  SetAPen_ \win\RPort, AB3Pen(#AB3_screentext)
  Move_ \win\RPort,0,\statusAreaY + 1 : Draw_ \win\RPort,\win\GZZWidth,\statusAreaY + 1

  ; update EACH TIME ??? WHY??
  Gosub draw_tabs

  PED_PrintStatus{"Line:        ", 24}
  PED_PrintStatus{"Column:    ", 11}
  log_Print{"drawing statusarea"}
  !asm

  BRA.b update_statusarea
RTS

.free_textbuffer:
  TST.l textbufferaddr
  BEQ.w JL_0_74AE
    MOVEM.l D0-D1/A0-A1/A6,-(A7)
    MOVEA.l textbufferaddr,A1
    ;MOVEA.l _execbase,A6
    ;ST comWord__AL_0_86C0
    !newfree
    MOVEM.l (A7)+,D0-D1/A0-A1/A6
  JL_0_74AE:
RTS

.allocate_textbuffer:
  MOVE.w comWord_MaxColumns,D0
  MULU viewablelines+2,D0
  ;MOVEQ.l #$02,D1                ; memtype not needed with AllocPooled
  ;MOVE.w D1,comWord__AL_0_86C0
  !newalloc
  MOVE.l D0,textbufferaddr
  BEQ.w JL_0_7334 ; quit ped
RTS




.close_gui:
  !basic
  log_Print{"closing gui..."}
  CloseAllWZWindows{}                                      ; replaced the close of all WZ Windows with a statement call  tomsmart1

  If Peek.l(?CLI_output_file)<>0
    Close_ Peek.l(?CLI_output_file)
    Poke.l ?CLI_output_file,0
  EndIf

  !asm
  JSR close_sourcewindow
  JSR arexx_send_closewindow

  ;MOVEA.l ptr_visualinfo,A0
  ;MOVEA.l _gadtoolsbase,A6
  ;JSR _FreeVisualInfo(A6)
  ;CLR.l ptr_visualinfo
  ;!basic
  ;FreeVisualInfo_ (?ptr_visualinfo)
  ;!asm

;  MOVEA.l _execbase,A6
;  SUBA.l A1,A1
;  JSR _FindTask(A6)
;  MOVEA.l D0,A0
;  MOVE.l ptr_windowPtrTemp,$B8(A0)
  !basic
  *this_process.Process = FindTask_("")
  *this_process\pr_WindowPtr = ?ptr_windowPtrTemp
  !asm

  BSR.b free_textbuffer

  !basic
  If use_pubscreen Then PubScreenStatus_ sourceWindow\pedScreen,#PSNF_PRIVATE

  vvblank_Free{}
  screen_Close{}   ; this release all pens for us  and close the used font
  log_Print{"closed gui"}
  !asm
RTS


.close_sourcewindow:
  MOVEM.l D2-D7/A2-A6,-(A7)

  CLR.l messagestore

  TST.l ptr_sourcewindow
  BEQ.w exit_closesourcewindow

    JSR flush_intuimessages

    !basic
    CloseWindow_ sourceWindow\win : sourceWindow\win = 0
    Poke.l Addr Window(0),0  ; to clear the window structure of BlitzBasic to prevent a crash at exit.
    Poke.l ?ptr_sourcewindow,0
    DisposeObject_ *larrowbutton
    DisposeObject_ *larrowimage
    DisposeObject_ *rarrowbutton
    DisposeObject_ *rarrowimage
    DisposeObject_ *horizprop
    DisposeObject_ *darrowbutton
    DisposeObject_ *darrowimage
    DisposeObject_ *uarrowbutton
    DisposeObject_ *uarrowimage
    DisposeObject_ *vertiprop
    FreeScreenDrawInfo_ *myscreen,*drawinfo
    !asm
    ; -- clear rastport for source area
    TST.l rp_rectfill
    BEQ.w exit_closesourcewindow
      MOVEA.l rp_rectfill,A1
      !newfree

  exit_closesourcewindow:

  MOVEM.l (A7)+,D2-D7/A2-A6
RTS


.set_storedcolors:
  screen_ReleaseAllPens{} ; release all pens that have been previously obtained by screen.include

  If (use_wbscreen = False) AND KickVersion(39)
    screen_SetPenRGB{0             ,AB3RGB(#AB3_screenback) }
    screen_SetPenRGB{1             ,AB3RGB(#AB3_screentext) }
    screen_SetPenRGB{2             ,AB3RGB(#AB3_screenshine)}
    screen_SetPenRGB{3             ,AB3RGB(#AB3_screenfill) }
    AB3Pen(#AB3_screenback)        = screen_GetPenRGB{AB3RGB(#AB3_screenback) }
    AB3Pen(#AB3_screentext)        = screen_GetPenRGB{AB3RGB(#AB3_screentext) }
    AB3Pen(#AB3_screenshine)       = screen_GetPenRGB{AB3RGB(#AB3_screenshine)}
    AB3Pen(#AB3_screenfill)        = screen_GetPenRGB{AB3RGB(#AB3_screenfill) }
  Else
    AB3Pen(#AB3_screenback)        = 0
    AB3Pen(#AB3_screentext)        = 1
    AB3Pen(#AB3_screenshine)       = 2
    AB3Pen(#AB3_screenfill)        = 3
  EndIf

  If KickVersion(39)
    AB3Pen(#AB3_cfunction)           = screen_GetPenRGB{AB3RGB(#AB3_cfunction)}
    AB3Pen(#AB3_cmacro)              = screen_GetPenRGB{AB3RGB(#AB3_cmacro)}
    AB3Pen(#AB3_cstring)             = screen_GetPenRGB{AB3RGB(#AB3_cstring)}
    AB3Pen(#AB3_cnewtype)            = screen_GetPenRGB{AB3RGB(#AB3_cnewtype)}
    AB3Pen(#AB3_cconstant)           = screen_GetPenRGB{AB3RGB(#AB3_cconstant)}
    AB3Pen(#AB3_cremarkforeground)   = screen_GetPenRGB{AB3RGB(#AB3_cremarkforeground)}
    AB3Pen(#AB3_cremarkbackground)   = screen_GetPenRGB{AB3RGB(#AB3_cremarkbackground)}
    AB3Pen(#AB3_ctoken)              = screen_GetPenRGB{AB3RGB(#AB3_ctoken)}
    AB3Pen(#AB3_ctokenbackground)    = screen_GetPenRGB{AB3RGB(#AB3_ctokenbackground)}
    AB3Pen(#AB3_cbackground)         = screen_GetPenRGB{AB3RGB(#AB3_cbackground)}
    AB3Pen(#AB3_cother)              = screen_GetPenRGB{AB3RGB(#AB3_cother)}
    AB3Pen(#AB3_cclassic)            = screen_GetPenRGB{AB3RGB(#AB3_cclassic)}
  Else
    AB3Pen(#AB3_cfunction)           = 1;screen_GetPenRGB{AB3RGB(#AB3_cfunction)}
    AB3Pen(#AB3_cmacro)              = 1;screen_GetPenRGB{AB3RGB(#AB3_cmacro)}
    AB3Pen(#AB3_cstring)             = 1;screen_GetPenRGB{AB3RGB(#AB3_cstring)}
    AB3Pen(#AB3_cnewtype)            = 1;screen_GetPenRGB{AB3RGB(#AB3_cnewtype)}
    AB3Pen(#AB3_cconstant)           = 1;screen_GetPenRGB{AB3RGB(#AB3_cconstant)}
    AB3Pen(#AB3_cremarkforeground)   = 1;screen_GetPenRGB{AB3RGB(#AB3_cremarkforeground)}
    AB3Pen(#AB3_cremarkbackground)   = 0;screen_GetPenRGB{AB3RGB(#AB3_cremarkbackground)}
    AB3Pen(#AB3_ctoken)              = 2;screen_GetPenRGB{AB3RGB(#AB3_ctoken)}
    AB3Pen(#AB3_ctokenbackground)    = 0;screen_GetPenRGB{AB3RGB(#AB3_ctokenbackground)}
    AB3Pen(#AB3_cbackground)         = 0;screen_GetPenRGB{AB3RGB(#AB3_cbackground)}
    AB3Pen(#AB3_cother)              = 1;screen_GetPenRGB{AB3RGB(#AB3_cother)}
    AB3Pen(#AB3_cclassic)            = 1;screen_GetPenRGB{AB3RGB(#AB3_cclassic)}
  EndIf

  Poke.l ?functioncolor            ,AB3Pen(#AB3_cfunction)
  Poke.l ?macrocolor               ,AB3Pen(#AB3_cmacro)
  Poke.l ?stringcolor              ,AB3Pen(#AB3_cstring)
  Poke.l ?newtypecolor             ,AB3Pen(#AB3_cnewtype)
  Poke.l ?constantcolor            ,AB3Pen(#AB3_cconstant)
  remarkcolor.l              = AB3Pen(#AB3_cremarkforeground)
  remarkbgcolor.l            = AB3Pen(#AB3_cremarkbackground)
  Poke.w ?tokencolor               ,AB3Pen(#AB3_ctoken)
  Poke.l ?tokenbackground          ,AB3Pen(#AB3_ctokenbackground)
  Poke.l ?backgroundcolor          ,AB3Pen(#AB3_cbackground)
  Poke.w ?othercolor               ,AB3Pen(#AB3_cother)
  Poke.l ?classiccolor             ,AB3Pen(#AB3_cclassic)

RTS



.save_cursorposition:
  MOVE.w comWord_Column,comWord_StoreColumn
  MOVE.l comLong_DisplayLine,comLong_StoreDisplayLine
  MOVE.w comWord_TextBufferOffset,comWord_StoreTextBufferOffset
RTS

.restore_cursorposition:
  MOVE.w comWord_StoreColumn,comWord_Column
  MOVE.l comLong_StoreDisplayLine,comLong_DisplayLine
  MOVE.w comWord_StoreTextBufferOffset, comWord_TextBufferOffset
RTS

.clear_sourcewindow:
  ; -- clear the codelines in window
  !basic
  USEPATH sourceWindow
  SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)
  RectFill_ \win\RPort,0,0,Peek.w(?source_BoxWidth),Peek.w(?ypos_statusarea)

  ; draw vertical line to seperate numbers and source code
  If linenumbers
    SetAPen_ \win\RPort,AB3Pen(#AB3_cother)
    lx.w = Peek.w(?source_BoxLeft) - 2
    Move_ \win\RPort,lx, Peek.w(?source_BoxTop)
    Draw_ \win\RPort,lx, \statusAreaY
  EndIf
  !asm
  TST.b linenumbers
  BEQ 'no_linenumbers
    BSR print_linenumber
  'no_linenumbers

.clear_sourcetextbuffer:
  ; -- clear current text memoryarea
  MOVEA.l textbufferaddr,A0
  MOVE.w comWord_MaxColumns,D0
  LSR.w #1,D0
  MOVE.l viewablelines,D1
  MULS d0,d1
  SUBQ.w #1,D1

  JL_0_76A6:
    MOVE.w #$2020,(A0)+
  DBF D1,JL_0_76A6
RTS

.delay:
  !basic
  If no_scrollrate
    Delay_ 1
  Else
    vvblank_Wait{}
    ;vvblank_WaitSync{1}
    ;vvblank_ResetSync{}
  EndIf
  !asm
RTS

JL_0_76EA:
  MOVEA.l textbufferaddr,A0
  ADDA.w comWord_TextBufferOffset,A0
  ADDA.w comWord_ColumnsOffset,A0
  ADDA.w comWord_Column,A0
  MOVE.b D0,(A0)
  MOVE.b D0,comByte_EnteredCharacter

  MOVEQ.l #$00,D0
  MOVE.w comWord_Column,D0
  MOVE.l comLong_DisplayLine,D1

  TST.l comLong_BlockEndY
  BMI.w JL_0_7742
    MOVEM.l D0-D1,-(A7)
    ADD.w comWord_ColumnsOffset,D0
    ADD.l comLong_DisplayLineOffset,D1
    JSR JL_0_3154
    MOVEM.l (A7)+,D0-D1
    TST.b comByte_StateBlockMark
    BEQ.w JL_0_7742
      ST comWord_CursorInMarkedBlock
  JL_0_7742:

  ; -- print entered character to source window
  LEA comByte_EnteredCharacter,A0
  MULU fontWidth,D0
  ADD.w source_BoxLeft,D0
  MULU fontHeight,D1

  CLR.w comWord_ColumnsOffsetTmp
  JSR print_entered_char
  SF comWord_CursorInMarkedBlock
RTS

.update_TextBufferOffset:                                    ; calculate Textbufferoffset
;  MOVE.l comLong_DisplayLine,D1
;  MULU comWord__AL_0_86CC,D1
;  MOVE.l D1,comLong__AL_0_868A
  MOVE.l comLong_DisplayLine,D1
  MULU comWord_MaxColumns,D1
  MOVE.w D1, comWord_TextBufferOffset
RTS




state_of_cursor:  Ds.w 1

.cursor_on:
  TST.w state_of_cursor
  BNE.w exit_cursor_switch

.cursor_onoff_force                                 ; rename it, was cursor_on_ force tomsmart1
  MOVEA.l rp_rectfill,A1
  MOVE.b #3,$18(a1)                                 ; Rastport\Mask.b
  JSR switch_cursordisplay
  MOVEA.l rp_rectfill,A1
  MOVE.b #15,$18(a1)                                ; Rastport\Mask.b

  exit_cursor_switch:
RTS

.cursor_off:
  TST.w state_of_cursor
  BEQ.w exit_cursor_switch
BRA cursor_onoff_force


.switch_cursordisplay:
  TST.l ptr_sourcewindow
  BEQ.w exit_switch_cursor

  NOT state_of_cursor

  draw_cursor:
  MOVEM.l D0-D3/A0-A1/A6,-(A7)
  !basic
  If Peek.l(?comLong_DisplayLine) > Peek.l(?viewablelines)-1
    Poke.l ?comLong_DisplayLine, Peek.l(?viewablelines)-1
  EndIf

  Select cursorStyle

  Case #AB3_cursorStyle_line
    xmin.w = Peek.w(?source_BoxLeft) + Peek.w(?comWord_Column) * Peek.w(?fontWidth)
    ymin.w = Peek.l(?comLong_DisplayLine) * Peek.w(?fontHeight)
    xmax.w = xmin + 1
    ymax.w = ymin + Peek.w(?fontHeightm1)

  Case #AB3_cursorStyle_underline
    xmin.w = Peek.w(?source_BoxLeft) + Peek.w(?comWord_Column) * Peek.w(?fontWidth)
    ymin.w = Peek.l(?comLong_DisplayLine) * Peek.w(?fontHeight) + Peek.w(?fontHeightm1) - 1
    xmax.w = xmin + Peek.w(?fontWidth) - 1
    ymax.w = ymin + 1

  Default
    xmin.w = Peek.w(?source_BoxLeft) + Peek.w(?comWord_Column) * Peek.w(?fontWidth)
    ymin.w = Peek.l(?comLong_DisplayLine) * Peek.w(?fontHeight)
    xmax.w = xmin + Peek.w(?fontWidth) - 1
    ymax.w = ymin + Peek.w(?fontHeightm1)
  End Select
  If (xMax => xMin) AND (yMax => yMin)
    RectFill_ Peek.l(?rp_rectfill),xmin,ymin,xmax,ymax
  Else
    log_Print{"illegal area for draw cursor"}
  EndIf

  !asm
  MOVEM.l (A7)+,D0-D3/A0-A1/A6

 exit_switch_cursor:
RTS



.update_vertscroller:
  BSR.b print_actualsourceline

  !basic
  MOVE.l comLong_DisplayLineOffset,d0  : slider_top.l     = PutD0
  MOVE.l comLong_TotalLines,d0         : slider_total.l   = PutD0
  MOVE.l viewablelines,d0              : slider_visible.l = PutD0

  ;/ scale
  If slider_total > 0
    If slider_total >= #max_slider_res
      !mul48f{slider_visible,#max_slider_res,slider_total,slider_visible}  : If slider_visible<1 Then slider_visible=1
      !mul48f{slider_top    ,#max_slider_res,slider_total,slider_top}
      slider_total   = #max_slider_res
    EndIf
    SetGadgetAttrsA_ *vertiprop,sourceWindow\win,0,Tags(@@
                                            #PGA_Total  ,slider_total,@@
                                            #PGA_Top    ,slider_top,@@
                                            #PGA_Visible,slider_visible)
  End If
  !asm
RTS

.update_modifiermark:
  MOVEM.l D0/A0-A1/A3,-(A7)
  TST.w comWord_KeyBeforeReturn
  BNE.w JL_0_78B6
    TST.w comWord_SourceChanged
    BNE.w JL_0_78B6
      CMPI.w #$1,comWord_SourceModifiedFlag
      BEQ.w JL_0_78F6
        MOVE.w #$0001,comWord_SourceModifiedFlag
        MOVE.l #$20202020,comStr_Modified               ; clear string  tomsmart1
        MOVE.l #$20202020,comStr_Modified+4
        MOVE.b #$0,comStr_Modified+8                    ; terminate the string tomsmart
        BRA.w JL_0_78E6
  JL_0_78B6:
    CMPI.w #$2,comWord_SourceModifiedFlag
    BEQ.w JL_0_78F6
      MOVE.w #$0002,comWord_SourceModifiedFlag
      MOVE.l #$4D4F4449,comStr_Modified        ;write modified in the strind start with "MODI"
      MOVE.l #$46494544,comStr_Modified+4      ;then the rest "FIED"
      MOVE.b #$0,comStr_Modified+8             ; terminate the string  tomsmart1
  JL_0_78E6:
;  !basic
;  If Peek.w(?comWord_KeyBeforeReturn)
;    If Peek.w(?comWord_SourceChanged)
;      If Peek.w(?comWord_SourceModifiedFlag) <> 1
;        Poke.w ?comWord_SourceModifiedFlag, 1
;        Poke.s ?comStr_Modified,"        " + Chr$(0)
;      EndIf
;    EndIf
;  EndIf
;  If Peek.w(?comWord_SourceModifiedFlag) <> 2
;    Poke.w ?comWord_SourceModifiedFlag, 2
;    Poke.s ?comStr_Modified,"MODIFIED" + Chr$(0)
;  EndIf
;  !asm
  JSR draw_statusarea

  JL_0_78F6:
  MOVEM.l (A7)+,D0/A0-A1/A3
RTS

.update_horizscroller:
  JSR update_modifiermark
  JSR print_actualsourcecolumn
  !basic
  MOVE d1,d0 : xpot.l = PutD0

  ;MOVEQ #0,d0
  ;MOVE.w comWord_ColumnsOffset,D0
  ;ADD.w comWord_Column,D0
  ;ADDQ.w #1,D0
  ;xact.l = PutD0
  xact.l = Peek.w(?comWord_ColumnsOffset) + Peek.w(?comWord_Column) + 1
  xmax_slider.l = #MAX_Columns
  ;MOVE.w visiblecolumns,d0
  xvis.w = Peek.w(?visiblecolumns) / xmax_slider
  SetGadgetAttrsA_ *horizprop,sourceWindow\win,0,Tags(#PGA_VertPot,-1,@@
                                            #PGA_VertBody,1,@@
                                            #PGA_HorizPot,xpot,@@
                                            #PGA_HorizBody,xvis,@@
                                            #PGA_Top,xact,@@
                                            #PGA_Total,xmax_slider,@@
                                            #TAG_END,0)

  !asm
RTS

JL_0_7962:                        ;horiz scroll
  JSR save_cursorposition
  CLR.w comWord_TextBufferOffset
  MOVEQ.l #$00,D7
  MOVE.l viewablelines,D7
  SUBQ.l #1,D7
  CLR.l comLong_DisplayLine
  CLR.w comWord_Column
  MOVEA.l textbufferaddr,A5
  ADDA.w comWord_TextBufferOffset,A5
  ADDA.w comWord_ColumnsOffset,A5
  MOVEQ.l #$00,D6
  CLR.w comWord_ColumnsOffsetTmp

  JL_0_799A:
    MOVEA.l A5,A0
    MOVEQ.l #$00,D0
    MOVE.l D6,D1
    MOVEQ.l #$00,D3
    MOVE.w D7,-(A7)
    ST comWord__AL_0_8668
  ;  MOVE.l a0,-(a7)
  ;  SUBA.w comWord_TextBufferOffset,A0
  ;  SUBA.w comWord_ColumnsOffset,A0
  ;  ;MOVE.l a0,currdisplayaddr
  ;  MOVE.l (a7)+,a0
    MOVEM.l d0-d2/a0,-(a7)
    MOVE.l textbufferaddr,a0
    ADD.w comWord_TextBufferOffset,a0
    CLR.b instring2
    MOVE.w #0,d2
    CMP.l #0,a0
    BEQ 'l2b
      MOVE.w comWord_ColumnsOffset,d1
     'l1
      CMP.w d1,d2
      BGE 'l2b
        MOVE.b (a0)+,d0
        CMP.b #$22,d0
        BNE 'l2
          NOT.b instring2
       'l2
        ADDQ.w #1,d2
      BRA 'l1
   'l2b
    MOVEM.l (a7)+,d0-d2/a0

    MOVE.b #$1,keepstring
    JSR print_complete_line                             ; inputs: d0:x, d1:y, a0: text
    CLR.b keepstring
    MOVE.w (A7)+,D7
    SF comWord__AL_0_8668
    JSR process_highlightning
    ADDQ.l #1,comLong_DisplayLine
    ADD.w #MAX_Columns, comWord_TextBufferOffset
    MOVEQ.l #$00,D0
    ADD.l #MAX_Columns,A5
    ADD.w fontHeight,D6
  DBF D7,JL_0_799A

  JSR restore_cursorposition
JMP JL_0_590C


JL_0_79CC:
  MOVE.l comLong_DisplayLineOffset,D2
  ADD.l comLong_DisplayLine,D2                           ; d2 = current Linenumber

  CMP.l comLong_BlockStartY,D2                           ; if blockstartY = d2
  BNE.w JL_0_79EE
    MOVE.w comWord_Column,D2                             ;   d2 = current Columnnumber
    ADD.w comWord_ColumnsOffset,D2
    CMP.w comLong_BlockStartX,D2                         ;   if d2 <= blockstartX
    BHI.w JL_0_79EE
      MOVEQ.l #$00,D3                                    ;     d3 = 0
                                                         ;   endif
  JL_0_79EE:                                             ; endif
RTS

JL_0_79F0:
  MOVE.l comLong_DisplayLineOffset,D2
  ADD.l comLong_DisplayLine,D2
  CMP.l comLong_BlockEndY,D2
  BNE.w JL_0_7A12
    MOVE.w comWord_Column,D2
    ADD.w comWord_ColumnsOffset,D2
    CMP.w comLong_BlockEndX,D2
    BHI.w JL_0_7A12
      MOVEQ.l #$00,D3
  JL_0_7A12:
RTS

JL_0_7A14:
  MOVE.w comLong_BlockStartX,D2
  CMP.w comWord_MaxColumns,D2
  BCS.w JL_0_7A3C
    CLR.w comLong_BlockStartX
    ADDQ.l #1,comLong_BlockStartY
    MOVE.l comLong_BlockStartY,D2
    CMP.l comLong_BlockEndY,D2
    BLS.w JL_0_7A3C
      JMP reset_Blockflag
  JL_0_7A3C:
  MOVE.w comLong_BlockEndX,D2
  BPL.w JL_0_7A66
    MOVE.w comWord_MaxColumns,D2
    SUBQ.w #1,D2
    MOVE.w D2,comLong_BlockEndX
    SUBQ.l #1,comLong_BlockEndY
    MOVE.l comLong_BlockEndY,D2
    CMP.l comLong_BlockStartY,D2
    BCC.w JL_0_7A90

    JL_0_7A62:
    JMP reset_Blockflag
  JL_0_7A66:
    MOVE.l comLong_BlockStartY,D2
    CMP.l comLong_BlockEndY,D2
    BNE.w JL_0_7A7C
      MOVE.w comLong_BlockEndX,D2
      CMP.w comLong_BlockStartX,D2
      BLT.b JL_0_7A62
    JL_0_7A7C:
    CMP.w comWord_MaxColumns,D2
    BCS.w JL_0_7A90
      MOVE.w comWord_MaxColumns,D2
      SUBQ.w #1,D2
      MOVE.w D2,comLong_BlockEndX
  JL_0_7A90:
RTS


.PED_events:
  CLR.w comWord_KeyBeforeReturn
  JSR cursor_on

  JL_0_7AA0:
  JSR checkedit2

  JSR cursor_on
  CLR.b doedit2

  JSR update_horizscroller
  JSR print_actualsourceline
  JSR general_message_loop
  JSR cursor_off

  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVE.w comWord_Column,D0

  ; -- update functioncompletion and close any subwindows on key-press
  !regs2stack
  !basic
  If use_intellisense
    ; -- update intellisense after DELETE_KEY or SPACE_KEY                        ; moved it too remove double switch asm-basic-asm and expand with Space-Key support  tomsmart1
    If (last_vankey = $08) OR (last_vankey = $20)
      Gosub intellisense
    EndIf
    ; -- CURSOR_KEYs navigation
    If WZ_CheckOpen{"WIN_POPUP"} AND (last_rawkey.l>(#RAWKEY_UP-1) AND last_rawkey<(#RAWKEY_LEFT+1) )
      Select last_rawkey                                             ; test only rawkey code for cursor keys  tomsmart1
        Case #RAWKEY_UP    : WZ_SetPopUpEntry{popupdata\selected_entry - 1}
        Case #RAWKEY_DOWN  : WZ_SetPopUpEntry{popupdata\selected_entry + 1}
        Case #RAWKEY_RIGHT : Gosub close_popupwindow
        Case #RAWKEY_LEFT  : Gosub close_popupwindow
      End Select
      Pop If : Pop If
      !asm
      !stack2regs
      BRA.w JL_0_7AA0
    EndIf
  EndIf
  Gosub close_bubblehelp
  !asm
  !stack2regs

  ; -- check for key-events
  TST.l D7
  BMI.w key_delete                      ; negative code

  BCLR #$1E,D7
  BNE.w JL_0_7ADA                       ; not equal

  CMP.w #$20,D7
  BCS.w key_cursorleft                  ; carry set, lower

  CMP.w #$7F,D7
  BLT JL_0_7ADA                         ; less than

  CMP.l #$8c,d7
  BLE key_delete                        ; less or equal

  JL_0_7ADA:
  JSR immediate_syntaxhelp
  JSR insertchar
BRA.w JL_0_7AA0



.insertchar:
  MOVE.b #2,doedit2                   ;change to 2 if char should cut block
  JSR checkedit2
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVE.w comWord_Column,D0
  MOVE.w D7,comWord_KeyBeforeReturn
  MOVE.w comWord_MaxColumns,D1
  ADD.w comWord_ColumnsOffset,D0

  JL_0_7AE8:
    SUBQ.w #1,D1
    CMP.w D1,D0
    BCC.w JL_0_7AF8
      MOVE.b -$1(A2,D1.W),$0(A2,D1.W)   ;insert char
  BRA.b JL_0_7AE8
  JL_0_7AF8:

  JSR scroll_rest_of_line_right

  TST.l comLong_BlockEndY
  BMI.w JL_0_7BB0
    MOVE.w comWord_Column,D0
    ADD.w comWord_ColumnsOffset,D0
    MOVE.l comLong_DisplayLine,D1
    ADD.l comLong_DisplayLineOffset,D1
    JSR JL_0_3154

    CMP.l comLong_BlockStartY,D1
    BEQ.w JL_0_7B3A
      CMP.l comLong_BlockEndY,D1
      BEQ.w JL_0_7B6C
        BRA.w JL_0_7BB0
    JL_0_7B3A:

    CMP.w comLong_BlockStartX,D0
    BLE.w JL_0_7B94
      TST.b comByte_StateBlockMark
      BEQ.w JL_0_7BB0
        ADDQ.w #1,comLong_BlockEndX
        CMPI.w #MAX_Columns-1,comLong_BlockEndX
        BLE.w JL_0_7BB0
          MOVE.w #MAX_Columns-1,comLong_BlockEndX
          BRA.w JL_0_7BB0

    JL_0_7B6C:
    CMP.w comLong_BlockEndX,D0
    BGT.w JL_0_7BB0
      ADDQ.w #1,comLong_BlockEndX
      CMPI.w #MAX_Columns-1,comLong_BlockEndX
      BLE.w JL_0_7BB0
        MOVE.w #MAX_Columns-1,comLong_BlockEndX
        BRA.w JL_0_7BB0

    JL_0_7B94:
    ADDQ.w #1,comLong_BlockStartX
    ADDQ.w #1,comLong_BlockEndX
    ANDI.w #$7F,comLong_BlockStartX           ;????????
    ANDI.w #$7F,comLong_BlockEndX             ;????????
  JL_0_7BB0:

  MOVE.w D7,D0
  JSR JL_0_76EA
  MOVE.w comWord_Column,D0
  JSR moveCursorRight
RTS


.key_cursorleft:
  CMP.w #$1F,D7
    BNE.w key_cursorright

  MOVE.w message_qualifier,d1                  ; added to support ALT+CURSOR LEFT to jump back in history  tomsmart1
  ANDI.w #$30,d1                               ; #IEQUALIFIER_LALT | #IEQUALIFIER_RALT
  BEQ 'noalt
    ; -- alt-key pressed aswell
    JSR jump_historyup
    RTS
 'noalt:
  MOVE.w message_qualifier,d1
  ANDI.w ##IEQUALIFIER_CONTROL,d1              ; $8
  BEQ 'noctrl
    ; -- ctrl-key pressed aswell
    CMPI.l #$ffffFFFF,comLong_BlockEndY
    BEQ.w 'noblock
      !regs2stack
      JSR cursor_off
      JSR menu_blockuntab
      !stack2regs
      RTS
   'noblock
    !basic
    Gosub moveCursorToBeginOfWord
    !asm
    MOVE.w D0,D1
    JSR moveCursorToX
    BRA.w JL_0_7AA0
 'noctrl
  MOVE.w comWord_QualifierStore,D1
  ANDI.w #$3,D1                               ; check for lshsift/rshift
  BEQ.w 'noshift
    MOVE.w D0,D1
    ADD.w comWord_ColumnsOffset,D1
    BEQ.w JL_0_7BE6
      MOVEQ.l #$00,D1
      JSR moveCursorToX
      BRA.w JL_0_7AA0
 'noshift
  MOVE.b #1,doedit2
  JSR moveCursorLeft
BRA.w JL_0_7AA0



.getactualword:
  nostring.b = 0
  lastcolumn.w = Peek.w(?comWord_Column)
  MOVE.l textbufferaddr,a0
  ADD.w comWord_TextBufferOffset,a0
  MOVE.l a0,d0:lineaddr = PutD0
  For i.l = lineaddr To lineaddr + #MAX_Columns    ;clear highlight info but dont trash strings
    If nostring = 0
      Poke.b i,Peek.b(i) AND $7f
       If Peek.b(i) = $22 Then nostring = 1
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
  Next
  MOVE.w comWord_Column,d1
  SUBQ.w #1,d1
  BGT 'w1
    MOVEQ #1,d1
 'w1
  MOVE.l textbufferaddr,a0
  ADD.w comWord_TextBufferOffset,a0
  ADD.w comWord_ColumnsOffset,d1
  ADD.w d1,a0
  JSR getwordnodetoke
  MOVE.l a0,d0 : i = PutD0
  actualword$ = Peek$(i)
  cursorposition.w = Peek.w(?comWord_Column)+1
  Poke.w ?comWord_Column,lastcolumn
RTS

.getactualword_new:
  nostring = 0 : already_displayed.b = False
;  lastcolumn.w = Peek.w(?comWord_Column)
  MOVE.l textbufferaddr,a0
  ADD.w comWord_TextBufferOffset,a0
  MOVE.l a0,d0 : lineaddr = PutD0
  For i.l = lineaddr To lineaddr + #MAX_Columns    ;clear highlight info but dont trash strings
    If nostring = 0
      Poke.b i,Peek.b(i) AND $7f
       If Peek.b(i) = $22 Then nostring = 1
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
  Next
  mytext$ = Peeks$(lineaddr,#MAX_Columns)

  cursorpos.w = Peek.w(?comWord_Column) + 1
  aword$ = "" : char$ =""
  tlen.w = FLen(mytext$)
  strhelp$ = ""
  If tlen
    token.l = False
    nextpos.w = cursorpos
    backpos.w = cursorpos - 1

    ; -- get everything right of cursor
    Repeat
      aword$ = aword$ + char$
      char$ = Mid$(mytext$,nextpos,1)
      nextpos + 1
    Until (Asc(char$)<48) OR (char$="{") OR (char$="}") OR (nextpos>(tlen+1) )

    ; -- get everything left of cursor
    char$ = ""
    Repeat
      aword$ = char$ + aword$
      char$ = Mid$(mytext$,backpos,1)
      backpos - 1
      ; Right$(Hex$(12345),2)
      If char$ = "(" OR char$ = "{"
        tokname$ = aword$
        Gosub syntax_help
        If strhelp$<>"" Then already_displayed.b = True
        aword$ = "" : char$="" : token = True
      EndIf
    Until (Asc(char$)>57 AND Asc(char$)<63) OR (Asc(char$)<48 AND char$<>"" AND char$<>"$") OR (char$="=") OR (backpos<0) OR already_displayed

    actualword$ = aword$
    mytext$ =""
;    cursorposition.l = Peek.w(?comWord_Column)+1
;    Poke.w ?comWord_Column,lastcolumn
  EndIf
RTS

.moveCursorToBeginOfWord:
  ; get lineaddress in textbuffer (detokenized text!)
  lineaddr = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
  ; get length of source line
  textlen.w = getLineLength{lineaddr}

  ;clear highlight info but dont trash strings
  nostring.b = 0
  For i.l = lineaddr To lineaddr + textlen
    If nostring = 0
      Poke.b i,Peek.b(i) AND $7f
      If Peek.b(i) = $22 Then nostring = 1
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
  Next

  cursorpos.w = Peek.w(?comWord_Column)
  If cursorpos > 1
    cursorpos - 1
    skip_spaces.b = False
    If Peek.b(lineaddr+cursorpos) = 32 Then skip_spaces = True ; check if current char is a space

    exit_loop.b = False
    Repeat
      cursorpos - 1
      char.b = Peek.b(lineaddr+cursorpos)
      log_Print{Peeks$(lineaddr,textlen)}
      log_Print{Str$(char) + "  " + Chr$(char) + "  "+Str$(cursorpos)}
      If skip_spaces
        If char <> 32 Then skip_spaces = False
      Else
        If (char < 48) OR (char = Asc("{")) OR (char = Asc("}"))
          exit_loop = True
        EndIf
      EndIf
    Until exit_loop OR (cursorpos < 1)

  EndIf
  GetD0 cursorpos
RTS


.moveCursorToEndOfWord:
  ; get lineaddress in textbuffer (detokenized text!)
  lineaddr = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
  ; get length of source line
  textlen.w = getLineLength{lineaddr}

  ;clear highlight info but dont trash strings
  nostring.b = 0
  For i.l = lineaddr To lineaddr + textlen
    If nostring = 0
      Poke.b i,Peek.b(i) AND $7f
      If Peek.b(i) = $22 Then nostring = 1
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
  Next

  cursorpos.w = Peek.w(?comWord_Column)
  If cursorpos < textlen
    cursorpos + 1
    skip_spaces.b = False
    If Peek.b(lineaddr+cursorpos) = 32 Then skip_spaces = True ; check if current char is a space

    exit_loop.b = False
    Repeat
      cursorpos + 1
      char.b = Peek.b(lineaddr+cursorpos)

      If skip_spaces
        If char <> 32 Then skip_spaces = False
      Else
        If (char < 48) OR (char = Asc("{")) OR (char = Asc("}"))
          exit_loop = True
        EndIf
      EndIf
    Until exit_loop OR (cursorpos => textlen)
    ;If cursorpos > 1 Then cursorpos - 1     ; internal counter starts at 0!
  EndIf
  GetD0 cursorpos
RTS


.startguide:
  !basic
  Gosub getstring_new2

  If actualword$ <> ""
    Gosub instructionbrowser_startguide
  Else
    Gosub open_instructionbrowser
  EndIf

  SetScreenTitle{default_screentitle$}
  !asm
RTS


.immediate_syntaxhelp:
  !basic
  _key.l = last_vankey
  MOVE.l A2,d0 : lineaddr.l = PutD0   ; get pointer to current textline
  already_displayed.b = False
  If (_key=@" ") OR (_key = @"(") OR (_key = @"{") ;OR (*PreProcessor\tokenFlags[_key&$FF]&#TOKENF_IS); " " "(" "{"

    If Peek.w(?comWord_Column) > 0

      If WZ_CheckOpen{"WIN_POPUP"} Then Gosub close_popupwindow

      strline$ = Peek.s(lineaddr) ;Peeks$(lineaddr,Peek.w(?comWord_Column))
      ;slen.w = FLen(strline$) : found.l = False
      ;Gosub getstring_new2
      ;tokname$ = actualword$
      ;error{"Line Pre:"+strline$}
      ;MaxLen linebuff$ = 256
      ;preproc_Detokenize{*PreProcessor,&strline$,&linebuff$,FLen(strline$)}
      ;strline$ = Peek.s(&linebuff$)
      ;error{"Line Post:"+strline$}

      bracketclose1.l = Instr(strline$,")")
      bracketclose2.l = Instr(strline$,"}")

      bracketopen1.l  = Instr(strline$,"(",bracketclose1)
      bracketopen2.l  = Instr(strline$,"{",bracketclose2)

      bracketopen.l   = 0

      If bracketopen1>bracketopen2 Then bracketopen=bracketopen1 : Else bracketopen=bracketopen2

      searchpos.l = Peek.w(?comWord_Column)
      If bracketopen>0 AND bracketopen<searchpos Then searchpos=bracketopen

      tokname$ = preproc_CropToken{*PreProcessor,strline$,searchpos}
      If tokname$ <> ""
        If *PreProcessor\tokenFlags[_key&$FF]&#TOKENF_IS
          tokname$ + Chr$(_key)
        End If
      End If
      If tokname$
        Gosub syntax_help
        If strhelp$ = ""
          Gosub intellisense
        End If
      End If
    EndIf
  Else
    Select _key
    Case $8b ; "HELP"
      ;Gosub getactualword_new
      Gosub getstring_new2
      ;If NOT already_displayed
      tokname$ = actualword$
      If tokname$ <> ""
        If StrLower(tokname$) = "endif"
          Gosub help_checkforif
        Else
          !asm
          JSR help_checkfortype
          !basic
          type_found.b = PutD0
          If (type_found = False)
            Gosub syntax_help
          EndIf
        EndIf
;        Else
;          search_instruction$ = ""
;          ypos.l = Peek.l (?comLong_DisplayLine)*Peek.w (?fontHeight)+(Peek.w (?fontHeight)*3)
;          wtemp\ibrowser_x = Peek.w (?comWord_Column)*Peek.w (?fontWidth):wtemp\ibrowser_y = ypos
;          Gosub open_instructionbrowser
      EndIf
      ;EndIf

     Case $0D ; ENTER
       If use_intellisense AND HelpForIncludes
         If WZ_CheckOpen{"WIN_POPUP"}
           a$ = WZ_GetPopUpEntry{WZ_GetPopUpMenu{}+1}

           ; include function
           a_new$ = dos_Trim{Left$(a$,Instr(a$,"{")-1)}
           If (a_new$ <> "") ;test if include function
             SetScreenTitle{a_new$ + " " + PED_GetIncludeHelp{a_new$} }
             a$ = a_new$ + "{"
           Else          ; is command
             SetScreenTitle{a$ + " " + PED_GetTokenHelp{*tokenbase,a$} }
           EndIf

           a$ = UnRight$(a$,FLen(poptok$)) ; cut string

           Gosub insertstring
           Gosub close_popupwindow
           Gosub activatesourcewindow
           Pop Select : Pop If :Pop If
           !asm
           MOVE.l #0,d7
           RTS
           ; replace text in textbuffer
;           MOVE.l textbufferaddr,d0
;           ADD.w comWord_TextBufferOffset,d0
;           ADD.w comWord_ColumnsOffset,d0
;           ADD.w comWord_Column,d0
;           faddr.l = PutD0 - 1
;           PokeS faddr-Len(poptok$), a$,FLen(a$)
;;           Poke.w ?comWord_ColumnsOffset,Peek.w(?comWord_Column)+FLen(a$)
;           Pop Select
;           !asm
;           MOVE.l #0,D7
;           RTS
           !basic
         EndIf
       EndIf
    Default
      Gosub intellisense
    End Select
  EndIf
  !asm
RTS


Function.s FindTokenHelpStr{tokname$}
  SHARED *tokenbase.tokeninfo         ;add because it is global now  tomsmart1 2012 06 16

  If Left$(tokname$,1) = "!"
    MOVE.l comPtr_MacroBase,d0 : *macrobase.l = PutD0
    tokname$ = PED_GetMacroName{*macrobase,tokname$}
    tokhelp$ = PED_GetMacroHelp{*macrobase,tokname$}
    tokexte$ = "Macro"
  Else
    tokid.l = PED_GetTokenID{*tokenbase,tokname$}
    If tokid>=0
      tokname$ = PED_GetTokenName{*tokenbase,tokid}
      libnum.l = PED_GetTokenLibnum{*tokenbase,tokname$}
      If libnum>=0
        tokhelp$ = PED_GetTokenHelp{*tokenbase,tokname$}
        tokexte$ = "BlitzLib: " + PED_GetLibname{libnum}
      End If
    Else
      tokname$ = PED_GetIncludeFunction{tokname$}
      If tokname$<>""
        tokhelp$ = PED_GetIncludeHelp{tokname$}
        tokexte$ = "Include: " + PED_GetIncludeName{tokname$}
      End If
    End If
  End If
  strhelp$ = tokname$
  If tokhelp$ <> ""
    strhelp$ + " " + tokhelp$
  End If
  If tokexte$ <> ""
    strhelp$ + " | " + tokexte$
  End If

  Function Return strhelp$
End Function


.syntax_help:
  strhelp$ = ""
  If tokname$ <> ""
    strhelp$ =  FindTokenHelpStr{tokname$}
    If Len(strhelp$) < 3
      ; keine Hilfe und kein Word unter Cursor
      SetScreenTitle{default_screentitle$}
    Else
      SetScreenTitle{strhelp$}
    EndIf
  EndIf
RTS


.intellisense:
  ; -- bei delete-key wird ?comWord_Column nicht aktualisiert
  If use_intellisense
    If Peek.w(?comWord_Column) > 1
      ; -- get everything left of cursor until " " or "=" , ":", "(", "{", ",", "+"    ; check expand to allow the following chars  : ( { , +  too tomsmart1
      If lineaddr.l

        strline$ = Peeks$(lineaddr,Peek.w(?comWord_Column))
        slen.w = FLen(strline$) : sfound.l = False
        stokname$ = "" : strhelp$ = ""
        While (slen > 0) AND (sfound = False)
          schar$ = Mid$(strline$,slen,1)
          If (schar$ = " ") OR (schar$ = "=") OR (schar$ = ":") OR (schar$ = "(") OR (schar$ = "{") OR (schar$ = ",") OR (schar$ = "+")   ; expand check too allowed this chars : ( { , + too  tomsmart1
            sfound = True
          Else
            stokname$ = schar$ + stokname$
            slen - 1
          EndIf
        Wend
      End If

      Select last_vankey                            ; check for the last pressed key  tomsmart1
        Case $00 ; no key  added to support CTRL I update
          ; nothing to do because stokname = stokname
        Case $08 ; DEL key
          stokname$ = UnLeft$(stokname$,1)          ; remove the most right chararter of the string too support the DELETE-KEY  tomsmart1
          Gosub close_popupwindow                   ; added to aviod hits  tomsmart1

       Default ; all other keys
         stokname$ + Chr$(_key)                     ; normal added key to the string
      End Select

      ; -- search for any text that equals entered text
      If (FLen(stokname$) > 2)
        poptok$ = LCase$(stokname$) : tokenliste$ = "" : popfound.w = 0

        ; in Helptext for Functionnames
        If (Instr(stokname$,"_") > 0)
          ; helptext
          ResetList HelpIndexCache()
          While NextItemFast(HelpIndexCache())
            If Instr(HelpIndexCache()\lname,poptok$) = 1
              ; %%1 = green, %%2 = rot, %%3= white, %%4= blue  fuer farben
              pophelp$ = HelpIndexCache()\name + HelpIndexCache()\help
              If FLen(pophelp$) > 32
                pophelp$ = Left$(pophelp$,32) + " ... "
              EndIf
              tokenliste$ + "%%1" + pophelp$ + Chr$(10)
              popfound + 1
            End If
          Wend
        EndIf

        ; in Commands
        If Peek.b(?use_commandsintellisens) = 1
          *tokenpointer.l = *tokenbase

          While *tokenpointer
            temptoken.s  = Peek$(*tokenpointer+6)
            ltemptoken.s = LCase$(temptoken)
            If Instr(ltemptoken,poptok$) = 1
              ; %%1 = green, %%2 = rot, %%3= white, %%4= blue  fuer farben
              pophelp$ = temptoken
              If FLen(pophelp$) > 32
                pophelp$ = Left$(pophelp$,32) + " ... "
              EndIf
              tokenliste$ + "%%4" + pophelp$ + Chr$(10)
              popfound + 1
            End If

            *tokenpointer = Peek.l(*tokenpointer)  ; nexttoken
          Wend
        End If

        ; -- open list if something found
        If popfound > 0
          WZ_SetPopUpMenu{tokenliste$,1}
          USEPATH sourceWindow
          xpos.l = \win\LeftEdge + \win\BorderLeft + \font\tf_XSize * (Peek.w(?comWord_Column)-2)
          ypos.l = \win\TopEdge +  \win\BorderTop +  \font\tf_YSize * Peek.l(?comLong_DisplayLine) + \font\tf_YSize + 2
          WZ_PopUp_Nonmodal{xpos,ypos,-1,-1,*myscreen\RastPort}
        Else
          Gosub close_popupwindow
        EndIf
      Else
        Gosub close_popupwindow             ; added to support DELETE_KEY  tomsmart1
      EndIf
    Else
      Gosub close_popupwindow
    EndIf
    Gosub activatesourcewindow              ; if we change popupwin (open, close, change) so we need to activate sourcewin again  tomsmart1
  End If
RTS

.scan_source_for_used_libs:
  Gosub set_pointer_busy_bas
  LockAllOpenWZWin{}

  ; --
  ; -- scan for number of lines
  number_of_lines.l = 0
  *textline.l = Peek.l(?comPtr_FirstSourceLine)
  While *textline<>0
    number_of_lines + 1
    *textline.l = Peek.l(*textline)
  Wend
  If number_of_lines = 0 Then Return

  ; --
  ; -- reset tables and arrays
  For i.l = 0 To 65535
    tokentable(i) = 0
  Next i
  HIERARCHY_Clear{&lib_list}

  Use Window WZID("WIN_LABELS")
  WZPrint "LIBRARY_LIST",0,lib_list

  ; Zeilenstruktur:
  ; 0 - 3 bytes : Adresse naechste Zeile
  ; 4 - 7 bytes : Adresse prev Zeile
  ; 8 byte      : Laenge der Zeile
  ; 9.. bytes   : tokenized Text
  ; kill any spaces before Token

  ; --
  ; -- scanning each line for tokens
  WZ_ShowMessage{!TRANS{"Analyzing source..."},0}

  *textline.l = Peek.l(?comPtr_FirstSourceLine) : zeile.l = 0
  While *textline<>0
    bytecount.w = 0
    anzbytes.w = Peek.b(*textline + 8)
    testaddr.l = *textline + 9
    acttoken.w = Peek.w(testaddr) AND $FFFF
    acttoke2.l = Peek.w(testaddr) AND $FFFF
    skip_string.b = False

    While (bytecount<=anzbytes)
      If (acttoken<0) AND (NOT skip_string)
        If (acttoke2 AND $FF) > 0
          If (zeile MOD 10)=0 Then !WZ_Update_Gauge{zeile,number_of_lines}

          If acttoke2 > $8000 Then acttoke2 = acttoke2 - $8000
          tokentable(acttoke2) = tokentable(acttoke2) + 1
          bytecount + 1 : testaddr + 1

;          If tokentable(acttoke2) = 1
;            tokname$ = PED_GetTokenName{*tokenbase,acttoke2}
;            If tokname$=""
;              !cout{zeile,Peek$(TEDDetoke_(testaddr))}
;              !cout{"found token ("+Hex$(acttoke2)+"): "+tokname$} ;,libname$,libnum}
;            EndIf
;          EndIf
        EndIf
      EndIf
      testaddr + 1 : bytecount + 1
      acttoken = Peek.w(testaddr) AND $FFFF
      acttoke2.l = Peek.w(testaddr) AND $FFFF
      actbyte.w = acttoke2 LSR 8
      ; skip comments ...
      If actbyte = Asc(";")
        anzbytes = bytecount + 1
      Else
        ; skip strings ...
        If actbyte = 34
          If skip_string = False Then skip_string = True Else skip_string = False
        EndIf
      EndIf
    Wend
    *textline.l = Peek.l(*textline) : zeile = zeile + 1
  Wend

  ;
  ; build hierarchy table
  ;
  WZ_ShowMessage{!TRANS{"Building result tree..."},0}
  For i = 0 To 65535
    If tokentable(i) > 0
      acttoke2 = i
      tokname$ = PED_GetTokenName{*tokenbase,acttoke2}
      libnum.l = acttoke2 LSR 7 ;PED_GetTokenLibnumID{*tokenbase,tokname$})
      libname$ = lib_mapping$(libnum,0)

      If tokname$<>""
        entry$ = libname$ + ": " + tokname$ + " ("+Str$(tokentable(i))+")"
        hpos.w = Instr(entry$,":")
        If (hpos > 1)
          main$ = Left$(entry$,hpos - 1)
          child$= Right$(entry$,FLen(entry$) - hpos - 1)
          pid.l = HIERARCHY_GetParentID{main$}
          If pid > 0
            HIERARCHY_AddChild{pid,child$}
          Else
            dummy = HIERARCHY_AddParent{&lib_list,main$}
            If child$<>""
              pid.l = HIERARCHY_GetParentID{main$}
              If pid<>0 Then HIERARCHY_AddChild{pid,child$}
            EndIf
          EndIf
        Else
          dummy = HIERARCHY_AddParent{&lib_list,entry$}
        EndIf
      EndIf
    EndIf
    If (i MOD 1024) = 0 Then !WZ_Update_Gauge{i,65535}
  Next i
  ;
  WZ_HideMessage{}

  Use Window WZID("WIN_LABELS")
  WZPrint "LIBRARY_LIST",0,lib_list

  UnlockAllOpenWZWin{}
  Gosub set_pointer_normal_bas
 Return



JL_0_7BE6:
  MOVE.l comLong_DisplayLineOffset,D1
  ADD.l comLong_DisplayLine,D1
  BEQ.w JL_0_7AA0

  MOVE.l A0,-(A7)
  MOVEA.l comPtr_CurrentSourceLine,A0
  MOVEA.l $4(A0),A0
  LEA $9(A0),A0
  MOVEQ.l #-$01,D1

  JL_0_7C02:
    TST.b (A0)
    BEQ.w JL_0_7C16
      ADDQ.w #1,D1
      CMPI.b #$20,(A0)+
  BEQ.b JL_0_7C02
  MOVEA.l (A7)+,A0
  ;BRA.w JL_0_7C5C
  JSR moveCursorToX
  BRA.w JL_0_7AA0

  JL_0_7C16:
  MOVEA.l (A7)+,A0
BRA.w JL_0_7AA0


.deletechar:
  MOVEM.l d0-d1/a0-a2,-(a7)
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVE.b #1,doedit2
  ;MOVE.w D7,comWord_KeyBeforeReturn       ;delete char

  MOVEM.l D1/A0-A2,-(A7)
  JSR JL_0_6448_bas                           ;scroll rest of line left
  MOVEM.l (A7)+,D1/A0-A2

  MOVE.w comWord_Column,D0
  ADD.w comWord_ColumnsOffset,D0

  JL_0_7E3Ab:                                   ; copy characters 1 to left
    ADDQ.w #1,D0
    CMP.w comWord_MaxColumns,D0
     BCC.w JL_0_7E4Cb
    MOVE.b $0(A2,D0.W),-$1(A2,D0.W)
  BRA.b JL_0_7E3Ab
  JL_0_7E4Cb:
  MOVE.b #$20,-$1(A2,D0.W)                      ; add space to end end of the line

  MOVE.w comWord_Column,-(A7)
  MOVE.w visiblecolumns,D0
  SUBQ.w #1,D0
  MOVE.w D0,comWord_Column
  MOVE.w visiblecolumns,D0
  ADD.w comWord_ColumnsOffset,D0
  SUBQ.w #1,D0
  MOVE.l d0,d1
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
 'l2
    CMP.b #$22,0(a2,d1.w)      ;hack
    BNE 'l1
      ADDQ.b #1,d0
   'l1
  DBF d1,'l2

  MOVE.l d0,d1
  MOVE.l (a7)+,d0
  MOVE.b $0(A2,D0.W),D0
  CLR.w instru
  BTST #0,d1
  BNE 'l3
    MOVE.w #1,instru
 'l3
  JSR JL_0_76EA
  CLR.w instru
  MOVE.w (A7)+,comWord_Column
  MOVEM.l (a7)+,d0-d1/a0-a2
BRA deletekey



.key_cursorright:
  CMP.w #$1E,D7
  BNE.w key_backspace

  MOVE.w message_qualifier,d1
  ANDI.w #$30,d1                            ;#IEQUALIFIER_LALT | #IEQUALIFIER_RALT  $30
  BEQ 'noalt
    ; -- alt-key pressed aswell
    ;JSR storeline
    ;JSR jump_onclick
    JSR jump_historydown
    RTS
 'noalt:

  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_CONTROL,d1          ; $8 tab the marked block
  BEQ 'noctrl
    ; -- ctrl-key pressed aswell
    CMPI.l #$ffffFFFF,comLong_BlockEndY
    BEQ.w 'noblock
      !regs2stack
      JSR cursor_off
      JSR menu_blocktab
      !stack2regs
      RTS
   'noblock
    !basic
    Gosub moveCursorToEndOfWord
    !asm
    MOVE.w D0,D1
    JSR moveCursorToX
    BRA.w JL_0_7AA0
  'noctrl:

  MOVE.w comWord_QualifierStore,D1
  ANDI.w #$3,D1                           ; $3 #IEQUALIFIER_LSHIFT | #IEQUALIFIER_RSHIFT
  BEQ.w 'noshift
    ; -- shift-key pressed aswell
    !basic
    lineaddr = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
    textlen.w = getLineLength{lineaddr}
    GetD0 textlen
    !asm
    MOVE.w d0,d1
    ;JL_0_7C5C:
    JSR moveCursorToX
    BRA.w JL_0_7AA0
 'noshift:

  ; -- normal cursor_right function
  MOVE.b #1,doedit2
  ;JL_0_7C64b:
  JSR moveCursorRight
BRA.w JL_0_7AA0


.key_backspace:
  CMP.w #$8,D7                  ; BACKSPACE-Key
  BNE.w key_tab

  MOVE.w D0,D1
  OR.w comWord_ColumnsOffset,D1
  BNE.w 'l1

  TST.b new_editmode
  BEQ JL_0_7AA0

  MOVEM.l a0-a3/a5/d0-d6,-(a7)
  MOVE.l comLong_DisplayLineOffset,d0
  ADD.l comLong_DisplayLine,d0
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w 'weit
    MOVEM.l (a7)+,a0-a3/a5/d0-d6
    BRA deletekey
 'weit
  CMP.l #0,d0
  BEQ 'l2
    MOVE.l comPtr_CurrentSourceLine,a4
    JSR storeline
    JSR movecursorlineup
    MOVEA.l textbufferaddr,A2
    ADDA.w comWord_TextBufferOffset,A2
    MOVE.l #MAX_Columns,d0
    SUBQ .l #1,d0

   'loop
      CMP.b #$20,0(a2,d0.l)
      BNE 'f
        SUBQ.l #1,d0
        BPL 'loop
     'f
      ADDQ.l #1,d0
      MOVE.w d0,comWord_Column
      MOVE.l comPtr_CurrentSourceLine,a4
      JSR menu_joinline
 'l2
  MOVEM.l (a7)+,a0-a3/a5/d0-d6
  JMP JL_0_7AA0

 'l1
  MOVEM.l A0-A2,-(A7)
  JSR moveCursorLeft
  MOVEM.l (A7)+,A0-A2
  MOVE.w comWord_Column,D0
  MOVEQ.l #$08,D7
BRA.w deletekey


.key_tab:
  CMP.w #$9,D7
   BNE.w exit_key_tab

  TST.w tab_size
  BNE 'l1
    MOVE.w #1,tab_size
 'l1

  ADD.w comWord_ColumnsOffset,D0
  MOVE.w D0,D2
  MOVE.w comWord_QualifierStore,D1
  ANDI.w #$3,D1
  BEQ.w JL_0_7D1C
  MOVE.w D7,comWord_KeyBeforeReturn

  JL_0_7CB4:
  SUBQ.w #1,D0
  BMI.w JL_0_7AA0
  MOVEQ.l #$00,D1
  MOVE.w D0,D1
  DIVU tab_size,D1
  SWAP D1

 'l1
  TST.w D1
  BNE.b JL_0_7CB4
  CMPI.l #$ffffFFFF,comLong_BlockEndY
   BEQ.w JL_0_7CF8
  MOVE.w D2,-(A7)
  MOVE.w D2,D4
  SUB.w D0,D4
  JSR JL_0_79CC
  BNE.w JL_0_7CE8
  SUB.w D4,comLong_BlockStartX

 JL_0_7CE8:
  JSR JL_0_79F0
  BNE.w JL_0_7CF6
  SUB.w D4,comLong_BlockEndX

 JL_0_7CF6:
  MOVE.w (A7)+,D2

 JL_0_7CF8:
  MOVE.w D0,-(A7)

 JL_0_7CFA:
  MOVE.b $0(A2,D2.W),$0(A2,D0.W)
  ADDQ.w #1,D2
  ADDQ.w #1,D0
  CMP.w comWord_MaxColumns,D2
  BCS.b JL_0_7CFA

  JL_0_7D0A:
  MOVE.b #$20,$0(A2,D0.W)
  ADDQ.w #1,D0
  CMP.w comWord_MaxColumns,D0
  BCS.b JL_0_7D0A
  BRA.w JL_0_7DDC

  JL_0_7D1C:
  ADDQ.w #1,D0
  CMP.w comWord_MaxColumns,D0
  BCC.w JL_0_7AA0
  MOVEQ.l #$00,D1
  MOVE.w D0,D1
  DIVU tab_size,D1
  SWAP D1
  TST.w D1
  BNE.b JL_0_7D1C
  MOVE.w D7,comWord_KeyBeforeReturn
  MOVE.w D0,-(A7)
  SUB.w D2,D0
  CMPI.w #$ffffFFFF,comLong_BlockEndY
  BEQ.w JL_0_7D6E
    MOVE.w D2,-(A7)
    JSR JL_0_79CC
    BNE.w JL_0_7D5A
      ADD.w D0,comLong_BlockStartX
    JL_0_7D5A:

    JSR JL_0_79F0
    BNE.w JL_0_7D68
      ADD.w D0,comLong_BlockEndX
    JL_0_7D68:
    JSR JL_0_7A14
    MOVE.w (A7)+,D2
  JL_0_7D6E:

  MOVE.w comWord_MaxColumns,D1

  JL_0_7D72:
    SUBQ.w #1,D1
    MOVE.w D1,D3
    SUB.w D0,D3
    BMI.w JL_0_7D8A
      CMP.w D2,D3
      BCS.w JL_0_7D8A
        MOVE.b $0(A2,D3.W),$0(A2,D1.W)
  BRA.b JL_0_7D72
  JL_0_7D8A:

  MOVE.w D1,-(A7)
  MOVE.w comWord_Column,D7
  ADD.w comWord_ColumnsOffset,D7
  MOVE.w D7,comWord_Column

  JL_0_7D9E:
  MOVE.b #$20,$0(A2,D1.W)
  MOVE.b $0(A2,D1.W),D0

  MOVEM.l D0-D2/A0-A2,-(A7)
  JSR scroll_rest_of_line_right
  MOVEM.l (A7)+,D0-D2/A0-A2

  MOVEM.l D0-D2/A0-A2,-(A7)
  JSR JL_0_76EA
  MOVEM.l (A7)+,D0-D2/A0-A2

  SUBQ.w #1,D1
  BMI.w JL_0_7DCA
    CMP.w D2,D1
    BCC.b JL_0_7D9E
  JL_0_7DCA:

  MOVE.w (A7)+,D0
  ADDQ.w #1,D0
  ADD.w D0,comWord_Column
  MOVE.w D0,D1
  MOVE.w (A7)+,D7
  JSR moveCursorToX
  BRA.w JL_0_7AA0

  JL_0_7DDC:
  MOVE.w comWord_Column,-(A7)
  CLR.w comWord_Column
  ADDA.w comWord_ColumnsOffset,A2
  MOVE.w visiblecolumns,D7
  SUBQ.w #1,D7

 JL_0_7DF0:
    MOVE.b (A2)+,D0
    MOVEM.l D7/A2,-(A7)
    JSR JL_0_76EA
    MOVEM.l (A7)+,D7/A2
    ADDQ.w #1,comWord_Column
  DBF D7,JL_0_7DF0
  MOVE.w (A7)+,comWord_Column
  MOVE.w (A7)+,D1
  JSR moveCursorToX
  BRA.w JL_0_7AA0

 exit_key_tab:
BRA.w JL_0_7ED0



.key_delete:
  CMP.w #$7F,D7                            ; DEL-Key
  BNE.w event_horizslider

  MOVE.w message_qualifier,d1              ; test for SHIFT-Key  tomsmart1
  AND.w #$3,d1                             ; left and right SHIFT
  BEQ.w deletekey                          ; no Delete-Key only

  MOVE.w D7,comWord_KeyBeforeReturn        ; save keycode
  MOVE.w comWord_Column,D0                 ; get cursor postion
  ADD.w comWord_ColumnsOffset,D0
  MOVE.w D0,-(A7)                          ; save to Stack
BRA.w JL_0_7D0A                            ; jump to


deletekey:
  MOVE.b #2,doedit2
  MOVE.w D7,comWord_KeyBeforeReturn
  JSR checkedit2

  TST.b nodelete
  BNE JL_0_7AA0

  MOVEM.l D1/A0-A2,-(A7)
  JSR JL_0_6448_bas                           ; scroll rightmost line to left
  MOVEM.l (A7)+,D1/A0-A2

  MOVE.w comWord_Column,D0
  ADD.w comWord_ColumnsOffset,D0

  JL_0_7E3A:                                  ; copy all characters one byte left
    ADDQ.w #1,D0
    CMP.w comWord_MaxColumns,D0
    BCC.w JL_0_7E4C
      MOVE.b $0(A2,D0.W),-$1(A2,D0.W)
  BRA.b JL_0_7E3A
  JL_0_7E4C:
  MOVE.b #$20,-$1(A2,D0.W)                    ; add space at the end (overwritelast char)

  MOVE.w comWord_Column,-(A7)
  MOVE.w visiblecolumns,D0
  SUBQ.w #1,D0
  MOVE.w D0,comWord_Column
  MOVE.w visiblecolumns,D0
  ADD.w comWord_ColumnsOffset,D0
  SUBQ.w #1,D0
  MOVE.l d0,d1
  MOVE.l d0,-(a7)
  MOVEQ #0,d0

 'l2
    CMP.b #$22,0(a2,d1.w)      ;hack
    BNE 'l1
      ADDQ.b #1,d0
   'l1
  DBF d1,'l2

  MOVE.l d0,d1
  MOVE.l (a7)+,d0
  MOVE.b $0(A2,D0.W),D0
  CLR.w instru
  BTST #0,d1
  BNE 'l3
    MOVE.w #1,instru
 'l3
  JSR JL_0_76EA
  CLR.w instru
  MOVE.w (A7)+,comWord_Column

  TST.w comWord_Column
  BNE 'x1
   TST.w comWord_ColumnsOffset
   BEQ 'x5
 'x1
  ; -- check if shift-backspace is pressed
  MOVE.w message_qualifier,d1
  AND.w #$3,d1
  BEQ JL_0_7AA0

  ; test for BACKSPACE-KEY
  CMP.b #$08,d7                ; add to fix SHIFT+DEL Key (before it acts like SHIFT+BACKSPACE KEY)
  BNE 'x5

  ; -- ok, delete all left of cursor ...
  TST.w comWord_Column
  BEQ 'x4
    SUBQ.w #1,comWord_Column
    BRA deletekey
 'x4

  TST.w comWord_ColumnsOffset
  BEQ 'x5
    SUBQ.w #1,comWord_ColumnsOffset
    BRA.w deletekey
 'x5

  JSR JL_0_7962
  JSR cursor_on
;BRA JL_0_7AA8
BRA JL_0_7AA0



.event_horizslider:
  CMP.w #-$1,D7
  BNE.w menu_addfilename

  CMP.w #GID_XPROP,D6
  BNE.w menu_addfilename

  horiz_loop:
    !basic
    log_Print{"horizontal slider"}
    DEFTYPE.l pos_hprop : GetAttr_ #PGA_Top,*horizprop,&pos_hprop
    Poke.l ?pos_horizprop,pos_hprop
    !asm
    MOVE.l pos_horizprop,D1
    JSR moveCursorToX                                  ; calculate new column ?

    MOVE.l a2,-(a7)
    MOVE.l ptr_sourcewindow,a2
    MOVEA.l $56(A2),A2                            ;Window\UserPort
    MOVEA.l A2,A0
    MOVE.l _execbase,A6
    JSR _GetMsg(A6)
    TST.l D0
    BEQ.w 'norep
      MOVE.l d0,a1                                  ;IntuiMessage > A1
      MOVE.l $14(a1),a2                             ;Class
      JSR _ReplyMsg(A6)
      CMP.l #IDCMP_GADGETUP,a2
      BNE 'norep
        MOVE.l (a7)+,a2
        BRA JL_0_7AA0                                 ; exit loop to JL_0_7AA0
   'norep
    MOVE.l (a7)+,a2
BRA.w horiz_loop


.menu_addfilename:
  MOVE.w D6,-(A7)

  CMP.w #-$2,D7
  BNE.w exit_addfilename

  !basic
;  CMP.l ##MENU_COMPILERSETTINGS,D6         ; was $53  ; replaced with the constant  tomsmart1
;  BNE nocompileopt
;  nocompileopt
  CMP.l ##MENU_INSERTFILENAME,d6           ; insert filename  ; was $1000  ; replaced with the constant  tomsmart1
  BNE 'nofileadd
    aslfr_SetRequesterTitle{0,!TRANS{"Select a filename to insert in source"},"",""}
    aslfr_SetPath{0,aslpath$,aslfile$,ptn$}
    If aslfr_Request{0,False,False,False}
      a$ = aslfr_GetNextFile{}
    EndIf
    Gosub insertstring
 'nofileadd

  CMP.l ##MENU_OPENFILEUNDERCURSOR,d6           ; load file under cursor  ;was $1001  ; replaced with the constant  tomsmart1
  BNE 'noload
    JSR getstring
    MOVE.l a0,d0
    i = PutD0
    If i
      a$ = Peek$(i)
      If Exists (a$)
        GetD0 &a$
        !asm
        JSR loadfile
        JSR StoreXtraData
        !basic
      End If
      a$ = dos_AddPart{includedir$,Peek$(i)}
      If Exists (a$)
        GetD0 &a$
        !asm
        JSR loadfile
        JSR StoreXtraData
        !basic
      End If
    End If
 'noload
  !asm

  CMP.l ##MENU_DELETETOEOL,D6             ; was $D9  ; replaced with the constant  tomsmart1
  BNE.w exit_addfilename
    MOVE.w (A7)+,comWord_KeyBeforeReturn
    ADD.w comWord_ColumnsOffset,D0
    MOVE.w D0,-(A7)
    BRA JL_0_7D0A                             ; added to remove double code  tomsmart1
  exit_addfilename:

  MOVE.w (A7)+,D6

  JL_0_7ED0:
RTS

moveCursorToX:                            ; D1: X-position
  MOVE.w comWord_ColumnsOffset,D4
  MOVE.w visiblecolumns,D2
  SUB.w comLong_BoundLinesX,D2
  CMP.w D2,D1
  BCC.w JL_0_7EFC
    CLR.w comWord_ColumnsOffset
    MOVE.w D1,comWord_Column

    JL_0_7EF0:
    CMP.w comWord_ColumnsOffset,D4
    BEQ.w JL_0_7F3E
      BRA.w JL_0_7962
  JL_0_7EFC:

  MOVE.w visiblecolumns,D2
  LSR.w #1,D2
  MOVE.w D1,D0
  SUB.w D2,D0
  MOVE.w comWord_MaxColumns,D3
  SUB.w visiblecolumns,D3
  CMP.w D3,D0
  BGT.w JL_0_7F2E
    BTST #$0,D0
    BEQ.w JL_0_7F20
      ADDQ.w #1,D0
      SUBQ.w #1,D2
    JL_0_7F20:
    MOVE.w D0,comWord_ColumnsOffset
    MOVE.w D2,comWord_Column
    BRA.b JL_0_7EF0
  JL_0_7F2E:

  MOVE.w D3,comWord_ColumnsOffset
  SUB.w D3,D1
  MOVE.w D1,comWord_Column
  BRA.b JL_0_7EF0

  JL_0_7F3E:
RTS

moveCursorLeft:
  CMP.w comLong_BoundLinesX,D0
  BCS.w JL_0_7F50
    JL_0_7F48:
    SUBQ.w #1,comWord_Column
    RTS
  JL_0_7F50:

  MOVE.w comWord_ColumnsOffset,D1
  CMP.w #1,d1
  ;BNE.w JL_0_7F5E
  BGT.w JL_0_7F5E
    TST.w d1
    BEQ 'l10
      MOVE.w #0,comWord_ColumnsOffset
      JSR scroll_right
      JSR _redraw
   'l10
    TST.w D0
    BNE.b JL_0_7F48
      RTS
  JL_0_7F5E:
  SUBQ.w #2,comWord_ColumnsOffset
  JSR scroll_right
  ADDQ.w #1,comWord_Column
RTS

.moveCursorRight:
  MOVE.w comWord_ColumnsOffset,D1
  MOVE.w visiblecolumns,D2
  ADD.w D2,D1
  CMP.w comWord_MaxColumns,D1
  BCS.w JL_0_7F8C
    SUBQ.w #1,D2
    CMP.w D2,D0
    BCS.w JL_0_7F9E
      RTS
  JL_0_7F8C:

  CMP.w comLong_BoundLinesX,D0
  BCS.w JL_0_7F9E
    SUB.w comLong_BoundLinesX,D2
    CMP.w D2,D0
    BCC.w JL_0_7FA6
  JL_0_7F9E:
    ADDQ.w #1,comWord_Column
    RTS
  JL_0_7FA6:
    ADDQ.w #2,comWord_ColumnsOffset
    JSR scroll_left
    SUBQ.w #1,comWord_Column
RTS

AJL_0_7FCC:
  !basic
  dummy.l = ask{"AJL_07FCC called",!TRANS{"Ok"},!TRANS{"Info"}}
  !asm
  TST.w comWord_LabelCounter
   ;BEQ.w setpointer_to_normal
  LEA L_0_808E,A3
  CLR.l (A3)+
  CLR.l (A3)+
  CLR.l (A3)+
  CLR.l (A3)+
  CLR.l (A3)+
  CLR.l (A3)+
  CLR.l (A3)+
  CLR.l (A3)+
  LEA L_0_808E,A3
  MOVEQ.l #$00,D6
  MOVEA.l ptr_sourcewindow,A0
  MOVEA.l $56(A0),A2                                 ; Window\UserPort

  JL_0_7FF8:
    MOVEA.l A2,A0
    JSR _WaitPort(A6)
    MOVEA.l A2,A0
    JSR _ReplyMsg(A6)
    MOVEA.l D0,A1
    MOVE.l d0,messagestore
    MOVE.l $14(A1),D1
    CMP.l #IDCMP_VANILLAKEY,D1
    BNE.w JL_0_8030

    MOVE.w $18(A1),D2           ; keycode
    CMP.w ##VANILLAKEY_RETURN,D2
    BEQ.w JL_0_8036
    CMP.w #$10,D6
    BEQ.w JL_0_8036
    MOVE.b D2,(A3)+
    ;JSR JL_0_739E
    ADDQ.w #1,D6

    JL_0_8030:
    MOVE.l messagestore,d0
    BEQ 'l1
      MOVE.l d0,a1
      JSR _ReplyMsg(A6)
   'l1
    CLR.l messagestore
  BRA.b JL_0_7FF8

  JL_0_8036:
  MOVE.l messagestore,d0
  BEQ 'l1
    MOVE.l d0,a1
    JSR _ReplyMsg(A6)
 'l1
  CLR.l messagestore
  MOVEQ.l #$00,D0
  MOVEQ.l #$00,D7

  LEA L_0_808E,A1
  MOVEA.l comPtr_LabelList,A0
  MOVEQ.l #$00,D4

  JL_0_8048:
  MOVEA.l $4(A0),A2
  LEA $9(A2),A2
  ADDQ.l #1,A2
  LEA L_0_80B0,A3

  JL_0_8056:
  MOVE.b (A2)+,(A3)+
  BNE.b JL_0_8056
  LEA L_0_80B0,A3
  JSR compare_strings
  BNE.w JL_0_8076
  ADDQ.l #1,D4
  MOVEA.l (A0),A0
  CMPA.l #$0,A0
  BNE.b JL_0_8048
  BRA.w JL_0_808C

  JL_0_8076:
  MOVEQ.l #$00,D2
  MOVE.w visiblecolumns,D2
  ADDQ.w #4,D2
  MOVE.l D4,D3
  ;JSR AJL_0_3A5E
  ;JSR JL_0_73FA
  JL_0_808C:
RTS

L_0_808E: Ds.w 17
L_0_80B0: Ds.w 17


.check_events:
  MOVEA.l _execbase,A6

  TST.l ptr_sourcewindow
  BEQ.w JL_0_8104

  MOVEA.l ptr_sourcewindow,A2
  MOVEA.l $56(A2),A2             ; Window->UserPort
  MOVEA.l A2,A0
  JSR _GetMsg(A6)
  TST.l D0
  BNE.w event_sourcewindow_new

  MOVEQ.l #$00,D7
RTS

.handle_event_newsizewindow:
  !basic
  Poke.w ?win_TopLeft,sourceWindow\win\LeftEdge
  Poke.w ?win_TopEdge,sourceWindow\win\TopEdge
  Poke.w ?win_Width,sourceWindow\win\Width
  Poke.w ?win_Height,sourceWindow\win\Height
  ;Poke.w ?win_InnerHeight, Peek.w(?win_Height) - Peek.w(?win_BorTop) - Peek.w(?win_BorBot)
  ;Poke.w ?win_InnerWidth , Peek.w(?win_Width)  - Peek.w(?win_BorLef) - Peek.w(?win_BorRig)

  *intuimessage.IntuiMessage = Peek.l(?messagestore)
  If *intuimessage
    ReplyMsg_ *intuimessage
    Poke.l ?messagestore,0
  EndIf

  If *intuimessage\Qualifier <> $FFFFC000   ; update only if mousebutton has been released
    Pop If
    !asm
    BRA resize_sourcewindow
  EndIf
  !asm
RTS

.resize_sourcewindow:
  !regs2stack

  JSR cursor_off
  JSR free_textbuffer
  JSR calc_SourceWindowDimensions
  JSR allocate_textbuffer
  JSR clear_sourcewindow
  JSR draw_statusarea
  JSR _redraw
  JSR cursor_on

  !stack2regs
  exit_resizewin:
RTS


.set_tedlibbase
  !regs2stack
  !basic
  TEDSetJumpTable  {?COMDATABASE}
  TEDSetFirstLine  {?comPtr_FirstSourceLine}
  TEDSetCurrentLine{?comPtr_CurrentSourceLine} ; or Peek.l(?comPtr_CurrentSourceLine) !?
  TEDSetLabelList  {?comPtr_LabelList}
  TEDSetLabelCount {?comWord_LabelCounter}
  !asm
  MOVEM.l (a7)+,a0-a6/d0-d7
RTS


JUMP_event_arexx:
JMP event_arexx

JL_0_8104:
  ; -- is there a message at the arexxport ?
  TST.l arexxport_available
  BEQ.w general_message_loop
    MOVEA.l _execbase,A6
    MOVEA.l struct_ArexxMsgPort,A0
    JSR _WaitPort(A6)
    MOVEA.l struct_ArexxMsgPort,A0
    JSR _GetMsg(A6)
    MOVE.l D0,struct_RexxMsg
    BNE.w JUMP_event_arexx

.general_message_loop:
  MOVEA.l _execbase,A6

  JL_0_8134:
  CLR.w message_qualifier
  TST.l ptr_sourcewindow
  BEQ.b JL_0_8104                         ; if no sourcewindow jump up, (only arexxport available?)


  MOVEA.l ptr_sourcewindow,A2
  MOVEA.l $56(A2),A2                      ; Window->UserPort

  JL_0_8142:
  ;JSR update_debuggertoggle

  MOVEA.l A2,A0
  MOVEA.l _execbase,A6
  JSR _GetMsg(A6)
  TST.l D0
  BNE.w handle_sourcewindow_event

  TST.l struct_ArexxMsgPort
  BEQ.w JL_0_816C
    MOVEA.l struct_ArexxMsgPort,A0
    JSR _GetMsg(A6)
    TST.l D0
    BNE.w JL_0_81A0
  JL_0_816C:

  MOVE.l #$FFFF0000,D0
  MOVE.b rexx_signalbits,D1
  BSET D1,D0
  JSR _Wait(A6)

  .message
  MOVE.l a2,-(a7)                           ; sichern des Msg-Port in A2

  ; -- ----- cursor blinking
  !regs2stack
  !basic
  blinkcount.b + 1
  If blinkrate > 0
    If blinkcount >= blinkrate
      blinkcount = 0
      !asm
      JSR cursor_onoff_force
      !basic
    EndIf
  EndIf
  !asm
  !stack2regs

  ; -- ----------------------

 .event_handler:        ; hier kommt die BB2 message (all windows but sourcewindow)
  !basic
  ev.l = Event
  While ev
    If ev<>#IDCMP_INTUITICKS
      ;log_Print{"new eventmessage: " + Hex$(ev) + ", " + Hex$(EventQualifier) + ", " + Hex$(EventCode)}
    End If

    ; bubble onlinehelp for most windows
    If onlinehelp <> 0
      If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) AND (ev<>#IDCMP_GADGETHELP)  AND (ev<>#IDCMP_CHANGEWINDOW)
        WZ_HideHelp{}
      EndIf
      If ev = #IDCMP_GADGETHELP Then WZ_ShowHelp{}
    EndIf

    If ev = #IDCMP_MENUPICK
      addr_menuitem.l = ItemAddress_(Peek.l(?addr_menustrip),EventCode)
      If addr_menuitem    ; added to protect agains MENUNULL  tomsmart1
        itemnumber.l = Peek.l(addr_menuitem+$22)
        GetD0 itemnumber
        !asm
        MOVE.l d0,d6
        JSR event_shortcut
        !basic
      EndIf
    Else
      Use Window EventWindow
      Select EventWindow
        Case WZID("WIN_SEARCH")             : Gosub event_find
        Case WZID("WIN_CONTEXTHELP")        : If ev = #IDCMP_CLOSEWINDOW Then Gosub close_bubblehelp
        Case WZID("WIN_NEWTYPE")            : Gosub event_newtype
        Case WZID("WIN_INSTRUCTIONBROWSER") : Gosub event_instructionbrowser
        Case WZID("WIN_LIBRARYBROWSER")     : Gosub event_librarybrowser
        Case WZID("WIN_LABELS")             : Gosub event_label
        Case WZID("WIN_POPUP")              : Gosub event_popup
        Case WZID("WIN_HELPDIAG")           : Gosub event_diag
        Case WZID("WIN_SHORTCUTS")          : Gosub event_shortcuts

        Default ; eventhandling for source window, not working at the moment
          ;log_Print{"new event for sourcewin: " + Str$(EventWindow)+" / " + Hex$(EventQualifier)}
          If EventQualifier = $ffff8040
            Select EventCode
              Case 83 : savewinpref{0,?ptr_sourcewindow} : JSR write_newprefs
              Case 84 : savewinpref{1,?ptr_sourcewindow} : JSR write_newprefs
              Case 85 : savewinpref{2,?ptr_sourcewindow} : JSR write_newprefs
            End Select
          End If

          Select EventCode
            Case 83 : num.l = 0 : Gosub load_windowlayouts : Gosub do_windowlayout
            Case 84 : num = 1   : Gosub load_windowlayouts : Gosub do_windowlayout
            Case 85 : num = 2   : Gosub load_windowlayouts : Gosub do_windowlayout
            Case 86 : AutoLayout{&wtemp,0} : Gosub do_windowlayout
            Case 87 : AutoLayout{&wtemp,1} : Gosub do_windowlayout
           ;Case 88 : AutoLayout{&wtemp,2} : Gosub do_windowlayout
            Default
          End Select
      End Select
    EndIf
    ev = Event
  Wend

  If Peek.b(?comByte_RunningFlag)<>0
    SetScreenTitle{!TRANS{"!!!PROGRAM IS RUNNING: ONLY SAVE/NAVIGATION/HELP WILL WORK..."}}
    rf.l = 1
  Else
    If rf = 1 AND Peek.b(?comByte_RunningFlag) = 0
      SetScreenTitle{default_screentitle$}
      rf = 0
    End If
  EndIf
  !asm

  MOVE.l (a7)+,a2             ; zurueckholen vom MsgPort in A2
  MOVE.l _execbase,A6

  MOVEA.l A2,A0
  JSR _GetMsg(A6)
  TST.l D0
  BNE.w handle_sourcewindow_event


  ; -- check arrexxport again, if available
  TST.l arexxport_available
  BEQ.b JL_0_8142
    MOVEA.l struct_ArexxMsgPort,A0
    JSR _GetMsg(A6)
    TST.l D0
    BEQ.b JL_0_8142

  JL_0_81A0:
  MOVE.l D0,struct_RexxMsg
  MOVEM.l D2-D5/A2-A6,-(A7)
  JSR event_arexx
  MOVEM.l (A7)+,D2-D5/A2-A6

  TST.l ptr_sourcewindow
  BEQ.w JL_0_8104

  MOVEA.l ptr_sourcewindow,A2
RTS


.update_debuggertoggle
  MOVEM.l d0-d1/a0-a1/a6,-(a7)
  !basic
  If Peek.b(?comByte_DebugMode)<>Peek.b(?olddebugmode)
    Poke.b ?olddebugmode,Peek.b(?comByte_DebugMode)
  EndIf
  GTSetMenuChecked 0,4,12,Peek.b(?comByte_DebugMode)
  !asm
  MOVEM.l (a7)+,d0-d1/a0-a1/a6
RTS


.handle_sourcewindow_event:
  JSR event_sourcewindow_new
  BEQ.w JL_0_8134                 ; if D0=0, then >JL_0_8134
RTS

.event_sourcewindow_new:
  MOVE.l D0,messagestore
  MOVEA.l D0,A1                 ; D0: IntuiMessage
  MOVE.l $14(A1),D1
  MOVE.l $14(A1),message_class
  MOVE.w $18(A1),message_code
  MOVE.w $1A(A1),message_qualifier

  !basic
  *intuimessage.IntuiMessage = Peek.l(?messagestore)
  ;If *intuimessage\Class<>$400000
  ;  log_Print{"source window event: " +Hex$(*intuimessage\Class) + ", " + Hex$(*intuimessage\Qualifier)+ ", " + Hex$(*intuimessage\Code)}
  ;EndIf
  If (*intuimessage\Class <> #IDCMP_INTUITICKS) AND (*intuimessage\Class <> #IDCMP_ACTIVEWINDOW) AND (*intuimessage\Class <> #IDCMP_GADGETHELP) AND (*intuimessage\Class <> #IDCMP_CHANGEWINDOW)
    WZ_HideHelp{}
  EndIf

  Select *intuimessage\Class
  Case #IDCMP_REFRESHWINDOW
    Pop Select
    !asm
    BRA handle_event_newsizewindow

  Case #IDCMP_NEWSIZE
    Pop Select
    !asm
    BRA handle_event_newsizewindow

  Case #IDCMP_ACTIVEWINDOW
    Pop Select
    !asm
    BRA.w handle_event_activewindow


  Case #IDCMP_INACTIVEWINDOW
    Pop Select
    !asm
    BRA.w handle_event_inactivewindow

  Case #IDCMP_GADGETDOWN
    Pop Select
    *gadget.Gadget = *intuimessage\IAddress
    ;log_Print{"GADGETDOWN"}
    ;log_Print{"GadgetID " + Str$(*gadget\GadgetID) + ", Type " + Hex$(*gadget\GadgetType) + ", Activation " + Hex$(*gadget\Activation)}
    ;log_Print{"byte type " + Str$(*gadget\GadgetType AND $00FF)}
    If *gadget\GadgetID >= 910
      arrow_pressed.w = 0
      Select *gadget\GadgetID
      Case #GID_UARROW: arrow_pressed = $1C
      Case #GID_DARROW: arrow_pressed = $1D
      Case #GID_RARROW: arrow_pressed = $1E
      Case #GID_LARROW: arrow_pressed = $1F
      End Select

      If arrow_pressed
        Pop If : Pop If
        GetD0 arrow_pressed
        !asm
        MOVE.w D0,message_code
        MOVE.l #IDCMP_VANILLAKEY,message_class
        ;MOVEQ #-1,D7
        BRA.w handle_event_vanillakey
      EndIf
      Pop If
      !asm
      MOVEQ.l #$00,D7
      BRA.w JL_0_844C
    EndIf
    !asm
    MOVEQ.l #-1,D7
    MOVEA.l messagestore,A1
    MOVEA.l $1C(A1),A0            ; IntuiMessage -> IAdress -> hier Gadget
    MOVE.w $26(A0),D6             ; GadgetID

    CMPI.b #$4,$11(A0)            ; GadgetType: 4 = StrGadget
    BNE.b JL_0_825C

    CMPI.w #$9,$18(A1)            ; MessageClass->Code: $9 =
    BEQ.w JL_0_844C

    BRA JL_0_825C

  Case #IDCMP_GADGETUP
    ;*gadget.Gadget = *intuimessage\IAddress
    ;log_Print{"GADGETUP"}
    ;log_Print{"GadgetID " + Str$(*gadget\GadgetID) + ", Type " + Hex$(*gadget\GadgetType) + ", Activation " + Hex$(*gadget\Activation)}
    ;log_Print{"byte type " + Str$(*gadget\GadgetType AND $00FF)}

  Case #IDCMP_MENUVERIFY
    ; do nothing

  Case #IDCMP_CLOSEWINDOW
    Pop Select
    !asm
    BRA handle_event_closewindow

  Case #IDCMP_MENUPICK
    Pop Select
    !asm
    MOVE.w message_code,D0
    BRA handle_event_menupick

  Case #IDCMP_MOUSEBUTTONS
    Pop Select
    !asm
    MOVE.w message_code,D0
    BRA handle_event_mousebuttons

  Case #IDCMP_RAWKEY
    Pop Select
    !asm
    MOVE.w message_code,D0
    BRA handle_event_rawkey

  Case #IDCMP_VANILLAKEY
    Pop Select
    !asm
    MOVE.w message_code,D0
    BRA handle_event_vanillakey

  Case #IDCMP_EXTENDEDMOUSE
    Pop Select
    !asm
    MOVE.w message_code,D0
    BRA handle_event_extendedmouse

  Case #IDCMP_MOUSEMOVE
    Pop Select
    !asm
    MOVE.w message_code,D0
    BRA handle_event_mousemove

  Case #IDCMP_INTUITICKS
    Pop Select
    !asm
    MOVE.w message_code,D0
    BRA handle_event_intuiticks
  End Select

  If *intuimessage
    ReplyMsg_ (*intuimessage)
    If *intuimessage\Class <> #IDCMP_INTUITICKS
      log_Print{"replied to unhandled message " + Hex$(Peek.l(*intuimessage))}
    EndIf
  EndIf
  !asm
  CLR.l messagestore
  MOVEQ #$00,D7
  MOVEQ #$00,D0
RTS

JL_0_844C:
  MOVE.l _execbase,A6
  MOVE.l messagestore,d0
  BEQ 'l1
    MOVE.l d0,a1
    JSR _ReplyMsg(A6)
 'l1
  CLR.l messagestore
  MOVEQ.l #$00,D7
  MOVEQ.l #$00,D0
RTS


.handle_event_gadget:              ;JL_0_8240
  MOVEA.l $1C(A1),A0            ; IntuiMessage -> IAdress -> hier Gadget

  MOVE.w $26(A0),D6             ; GadgetID
  MOVEQ.l #-$01,D7

  CMPI.w #GID_RARROW,D6                ; BOOPSI-Gadget (Pfeilgadgets oder hoeher) gedrueckt ?
  BGE.w handle_event_boopsiarrow

  CMPI.b #$4,$11(A0)            ; GadgetType: 4 = StrGadget
  BNE.b JL_0_825C

  CMPI.w #$9,$18(A1)            ; MessageClass->Code: $9 =
  BEQ.w JL_0_844C

  JL_0_825C:
  BTST #$2,$F(A0)               ; Activation-Flag
  BEQ.w reply_idcmp_message

  CMP.w #IDCMP_GADGETDOWN,message_class
  BEQ.w reply_idcmp_message

  MOVE.l messagestore,d0
  BEQ 'l1
    MOVE.l d0,a1
    JSR _ReplyMsg(A6)
 'l1
  CLR.l messagestore
  MOVEQ.l #-$01,D0
RTS


.handle_event_activewindow   ; added to set the source window as used window for blitzbasic
  !regs2stack
  !basic
  Use Window 0
  !asm
  JSR cursor_on
  !stack2regs
BRA.w JL_0_844C


.handle_event_inactivewindow   ; changed to deactived the cursor old code is not used anymore
  !regs2stack
   JSR cursor_off
  !stack2regs
BRA.w JL_0_844C


.handle_event_boopsiarrow:
  MOVE.l d6,d0    ; contains GadgetId
  !basic
  gadgetid.w = PutD0 : arrow_pressed.w = 0
  If *intuimessage\Class = #IDCMP_GADGETDOWN
    Select gadgetid
      Case #GID_RARROW
        arrow_pressed = $1E

      Case #GID_LARROW
        arrow_pressed = $1F

      Case #GID_UARROW
        arrow_pressed = $1C

      Case #GID_DARROW
        arrow_pressed = $1D

;     Case #GID_XPROP
;       DEFTYPE.l x
;       GetAttr_ #PGA_Top, * horizprop, & x
;       !cout{"horizontal scroller pressed:",x}

;     Case #GID_YPROP
;       DEFTYPE.l y
;       GetAttr_ #PGA_Top,*vertiprop,&y
;      !cout{"vertical scroller pressed:",y}
    End Select

    If arrow_pressed
      GetD0 arrow_pressed
      !asm
      MOVE.l #IDCMP_VANILLAKEY,message_class
      MOVE.w D0,message_code
      BRA.w handle_event_vanillakey
      !basic                                    ; added for better readabilitiy  tomsmart1
    EndIf

  EndIf
  !asm                                          ; added because we return to asm code  tomsmart1
  MOVEQ.l #$00,D7
BRA.w JL_0_844C

.handle_event_intuiticks:
  !regs2stack
  !basic
  If onlinehelp_extended AND *intuimessage<>0
    ; -- wait for at least 1 second before displaying the bubble
    help_ticks.b + 1 : If help_ticks < 10 Goto skip_this

    ; -- check sourcearea
    USEPATH sourceWindow
    If *intuimessage\MouseX - \win\BorderLeft<0 Then Goto skip_this
    If *intuimessage\MouseY - \win\BorderTop <0 Then Goto skip_this
    If *intuimessage\MouseY - \win\BorderTop - \statusAreaY > 0 Then Goto skip_this
    If *intuimessage\MouseX - \win\BorderRight - \win\Width > 0 Then Goto skip_this
    If (*intuimessage\MouseX = ocmousex.w) AND (*intuimessage\MouseY = ocmousey.w) Then Goto skip_this

    ; -- check mouseposition in source area
    textX.w = (*intuimessage\MouseX - \win\BorderLeft - Peek.w(?source_BoxLeft)) / \font\tf_XSize + Peek.w(?comWord_ColumnsOffset) + 1
    textY.w = (*intuimessage\MouseY - \win\BorderTop) / \font\tf_YSize + Peek.l(?comLong_DisplayLineOffset) + 1

    ; -- get the currentsourceline and move to mouse cursor-line
    actualLine.l = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) + 1
    totalLines.l = Peek.l(?comLong_TotalLines)
    *tempLine.sourceLine = Peek.l(?comPtr_CurrentSourceLine)
    delta.w = textY - actualLine
    If (delta <= totalLines) AND (actualLine + delta > 0)
      If delta > 0
        For si.w = 1 To delta
          If *tempLine\nextLine Then *tempLine = *tempLine\nextLine
        Next si
      Else
        If delta < 0
          For si.w = -1 To delta Step -1
            If *tempLine\previousLine Then *tempLine = *tempLine\previousLine
          Next si
        EndIf
      EndIf

      ; -- check out the help and display it
      If *tempLine
        *detokened.l = TEDDetoke{*tempLine + 9}
        helptext$ = PED_GetWordAtPos{Peek$(*detokened),textX}
        If helptext$ <> ""
          helpvalue.l = 0 : msg$ = ""
          ;-- check for a constant
          If Left$(helptext$,1) = "#"
            helptext$ = UnRight$(helptext$,1)
            helpvalue = TEDGetConstantValue{Peek.l(?constantbase),helptext$}
          Else
            ;-- check for a newtype
          EndIf
          ;            $45464748
          SetScreenTitle{helptext$}
          If helpvalue = 0 Then helpvalue = Vallong(helptext$)
          If helpvalue <> 0
            msg$ = helptext$
            ;log_Print{ Str$(helpvalue) }
            helpvaluestr.s = Str$(helpvalue)
            msg$ + Chr$(10) + Chr$(10) + "# " + helpvaluestr
            msg$ + Chr$(10) + "$ " + Hex$(helpvalue)
            msg$ + Chr$(10) + "% " + Bin$(helpvalue)

            msg$ + Chr$(10) + Chr$(34) + Mkl$(helpvalue) + Chr$(34)
          EndIf
          If msg$ <> ""
            WZ_ShowHelp{msg$}
          Else
            WZ_HideHelp{}
          EndIf
          help_ticks = 0
          ocmousex.w = *intuimessage\MouseX : ocmousey.w = *intuimessage\MouseY
        EndIf
      EndIf
    EndIf
    skip_this:
  EndIf
  !asm
  !stack2regs
BRA.w JL_0_844C

.handle_event_closewindow
  MOVEQ.l ##MENU_CLOSE,D6
  MOVEQ.l #-$02,D7                    ; Keytable action: event_shortcut
BRA.w reply_idcmp_message

.handle_event_menupick
  CMP.w #-$1,D0
  BEQ.w JL_0_844C

  JSR set_tedlibbase                          ; why ??

  MOVE.l A1,-(A7)
  !basic
  _menuNumber.w = PutD0
  _menuItem.l = ItemAddress_(Peek.l(?addr_menustrip),_menuNumber AND #MaxWord)
  GetD0 _menuItem
  !asm
  MOVEA.l D0,A0
  MOVE.l $22(A0),D6

  ;-- check on "reload Blitzlibs"
  CMP.l ##MENU_RELOAD_USERLIBS,d6              ;was $58  ; replaced with the constant  tomsmart1
  BNE 'l10
    LEA instrtab,a1
    MOVE.l #32767,d0
   'l11:
      CLR.l (a1)+
    DBF d0,'l11
 'l10:

  MOVEQ.l #-$02,D7
  MOVEA.l (A7)+,A1
BRA.w reply_idcmp_message


.handle_event_mousebuttons
  MOVEQ.l #-$03,D7

  ; messagecode in D0

  TST.b comByte_RunningFlag
  BNE 'l1r
    JSR check_mouse_in_statusarea
 'l1r
    MOVE.w #$0001,comWord__AL_0_8520
    CMP.w #$68,D0                                ; test for Left Mouse Button
    BEQ.w 'l10
      ; check for doubleclick
      !regs2stack
      !basic
      isDoubleClick.b = DoubleClick_(SSeconds.l,SMicros.l,*intuimessage\Seconds,*intuimessage\Micros)
      SSeconds = *intuimessage\Seconds
      SMicros = *intuimessage\Micros
      If isDoubleClick
        Gosub getstring_new2
        ;log_Print{"doubleclick on ==>" + actualword$}
        If WZ_CheckOpen{"WIN_LABELS"}
          search_label$ = StripLead$(LCase$(actualword$),32)
          If StrLeft(search_label$,1)="." Then search_label$ = StrRight(search_label$,-1)
          Use Window WZID("WIN_LABELS")
          WZPrint "STRING_LABEL",search_label$
          MOVE.w #$FFFF,comWord_LabelListChanged
        EndIf
      EndIf
      !asm
      !stack2regs
      MOVE.w #$0000,comWord__AL_0_8520
      MOVEQ.l #-$04,D7
      CMP.w #$e8,d0                                ; test for release of the Mouse Button
      BNE 'noshift
        BRA  reply_idcmp_message
   'l10:
      MOVE.l _execbase,A6
      MOVE.l messagestore,d0
      BEQ 'l1
        MOVE.l d0,a1
        JSR _ReplyMsg(A6)
     'l1
      CLR.l messagestore
      MOVEQ.l #-$01,D0
      RTS
 'noshift
  CMP.w #$6a,d0                                ; test for Middle Mouse Button
  BNE nomid
  MOVE.w message_qualifier,d1                  ; get pressed qualifier
  AND.w #$30,d1                                ; test for ALT-Key (left and right)
  BEQ nomid
    ; middle mousebutton pressed ...
    JSR jump_historyup

    MOVE.l _execbase,A6
    MOVE.l messagestore,d0
    BEQ 'l1b
      MOVE.l d0,a1
      JSR _ReplyMsg(A6)
   'l1b
    CLR.l messagestore
    MOVEQ #0,d0
    RTS
  nomid:
BRA.w reply_idcmp_message


.handle_event_rawkey
  MOVE.w message_qualifier,comWord_QualifierStore   ; Message->Qualifier
  !basic
  last_rawkey = Peek.w(?message_code)               ; rename it to avoid clashes with vanillakey tomsmart1
  last_vankey = 0
  !asm
  MOVEQ.l #$00,D7
  MOVE.w message_code,D7          ; Message->Code


  ;-- F-keys
  CMP.w #$50,D7 : BLT.w JL_0_831E ; "F1"
  CMP.w #$59,D7 : BGT.w JL_0_831E ; "F10"
    ADDI.w #$31,D7
    BRA.w JL_0_8346
  JL_0_831E:

  ;-- Mousewheel Rawkey events from the newmouse definition   tomsmart1
  CMP.w #NM_WHEEL_DOWN,D7         ; check for "wheel DOWN" event
  BEQ.w wheel_down               ; yes scroll the sourcetext

  CMP.w #NM_WHEEL_UP,D7           ; check for "wheel UP" event
  BEQ.w wheel_up                 ; yes scroll the sourcetext

  ;-- further keys
  CMP.w #$5F,D7                   ; "HELP"
  BEQ.w JL_0_8354

  CMP.w #$44,D7                   ; "RETURN"
  BEQ.w JL_0_8364

  CMP.w ##RAWKEY_LEFT,D7          ; "CURSOR <"
  BGT.w JL_0_844C

  CMP.w ##RAWKEY_UP  ,D7          ; "CURSOR up"
  BLT.w JL_0_844C

  SUBI.w #$30,D7                  ; if cursor keys, then sub $30 and reply
  BRA.w reply_idcmp_message

  JL_0_8346:
  MOVE.l #IDCMP_VANILLAKEY,message_class
  MOVE.w D7,message_code
  BRA.w check_for_vanillakey

  JL_0_8354:
  MOVE.l #IDCMP_VANILLAKEY,message_class
  MOVE.w #$008B,message_code     ; set message_code to HELP-Key
  BRA.w check_for_vanillakey

  JL_0_8364:
  MOVE.l #IDCMP_VANILLAKEY,message_class
  MOVE.w #$000D,message_code     ; set message_code to RETURN-Key

  check_for_vanillakey:
  CMP.l #IDCMP_VANILLAKEY,message_class
  BNE.w JL_0_844C    ;JL_0_8438
BRA handle_event_vanillakey



.handle_event_vanillakey
  !basic
  last_vankey = Peek.w(?message_code)    ; rename it tomsmart1
  last_rawkey = 0
  ;log_Print{"event vanillakey: " + Hex$(last_vankey)}
  !asm
  MOVEQ.l #$00,D7
  MOVE.w message_code,D7                 ; Vanillakey
  MOVE.w message_qualifier,D1
  MOVE.w D1,comWord_QualifierStore

  CMP.w ##VANILLAKEY_RETURN,d7           ; check for "RETURN"
  BNE 'noreturn
    JSR immediate_syntaxhelp
 'noreturn

  CMP.w ##VANILLAKEY_HELP,d7             ; check for "HELP"
  BNE 'nohelp
    CMP.w #$8000,D1                        ; no extra Qualifier
    BNE.w 'check_ctrlhelp
      JSR immediate_syntaxhelp
   'check_ctrlhelp

    CMP.w #$8008,D1                        ; check for "CTRL-Key" Qualifier
    BNE.w 'check_lshifthelp
      JSR diag_help
   'check_lshifthelp

    CMP.w #$8001,D1                        ; check for "Left SHIFT-Key" Qualifier
    BNE.w 'check_rshifthelp
      JSR startguide
   'check_rshifthelp                       ; add because i always press "Right SHIFT" and "HELP"  tomsmart1

    CMP.w #$8002,D1                        ; check for "Rigth SHIFT-Key" Qualifier
    BNE.w 'nohelp
      JSR startguide
 'nohelp

  CMP.w ##VANILLAKEY_ESC,d7              ; check for "ESC"
  BNE 'noesc
    !basic
    Gosub close_bubblehelp
    Gosub close_popupwindow
    !asm
 'noesc

  CMP.w #$8008,d1                        ; check for CTRL Qualifier
  BNE 'noCTRL_Qualifier                  ; no so skip all Contol-Key Hotkeys
    ; begin Control-Key Hotkeys
    CMP.w #$15,d7                        ; check for "CTRL_U"
    BNE 'noCTRL_U
      MOVEM.l a0-a6/d0-d7,-(a7)
      JSR cursor_off
      JSR _redraw
      BSR cursor_on
      MOVEM.l (a7)+,a0-a6/d0-d7
      CLR.l d7
      BRA.w reply_idcmp_message
   'noCTRL_U

    CMP.w #$e,d7                         ; check for "CTRL_N"
    BNE 'noctrl_n
      !basic                               ; insert 'NewType' skeleton
      a$ = "newtype ."
      JSR cursor_off
      Gosub insertstring
      !asm
      JSR insertreturn
      JSR insertreturn
      !basic
      a$ = "end newtype "
      Gosub insertstring
      !asm
   'noctrl_n

    CMP.w #$6,d7                         ; check for "CTRL_F"
    BNE 'noctrl_f   ;function
      !basic                               ; insert 'Function' skeleton
      a$ = "function.l { }"
      JSR cursor_off
      Gosub insertstring
      !asm
      JSR insertreturn
      JSR insertreturn
      !basic
      a$ = "function return 0"
      JSR cursor_off
      Gosub insertstring
      !asm
      JSR insertreturn
      !basic
      a$ = "end function "
      Gosub insertstring
      !asm
   'noctrl_f

    CMP.w #$13,d7                         ; check for "CTRL_S"  tomsmart1
    BNE 'noctrl_s
      !basic                                ; insert 'Statement' skeleton
      a$ = "statement { }"
      JSR cursor_off
      Gosub insertstring
      !asm
      JSR insertreturn
      JSR insertreturn
      !basic
      a$ = "end statement "
      Gosub insertstring
      !asm
   'noctrl_s

    CMP.w #$5,d7                         ; check for "CTRL_E"
    BNE 'noctrl_e
      !basic                               ; insert 'end if '
      a$ = "end if "
      JSR cursor_off
      Gosub insertstring
      !asm
   'noctrl_e

    ; begin PC standard copy, paste, cut keys added  tomsmart1
    CMP.w #$3,d7                         ; check for "CTRL_C"
    BNE 'noctrl_c
      MOVE.b #1,VerticalCopyMode           ; set it for column copy
      JSR menu_copy                        ; do normal copy
      MOVE.b #0,VerticalCopyMode           ; set it to normal copy
      MOVE #$0,d7
   'noctrl_c

    CMP.w #$16,d7                        ; check for "CTRL_V"
    BNE 'noctrl_v
      MOVE.w #1,VerticalPasteMode          ; for vertical (Column) paste
      JSR menu_paste                       ; do paste
      MOVE.w #0,VerticalPasteMode          ; restore it for normal paste
      MOVE #$0,d7
   'noctrl_v

    CMP.w #$18,d7                        ; check for "CTRL_X"
    BNE 'noctrl_x
      JSR menu_cut                         ; do cut
      MOVE #$0,d7
   'noctrl_x
    ; end PC standart copy,paste,cut keys
    ; begin CTRL I
    CMP.w #$09,d7                        ; check for CTRL_I"
    BNE 'noctrl_i
      TST.b use_commandsintellisens        ; test if 0 = off  tomsmart1
      BNE 'ctrl_i_off
        MOVE.b #1,use_commandsintellisens    ; turn it on
        BRA 'ctrl_i_exit
     'ctrl_i_off
        MOVE.b #0,use_commandsintellisens    ; turn it off
     'ctrl_i_exit
      MOVE #$0,d7                          ; clear key
      !basic
      last_vankey = 0                      ; clear Key (Basic) to
      Gosub intellisense                   ; update popupwin
      !asm
   'noctrl_i
    ; end CTRL I
 'noCTRL_Qualifier

  CMP.w #$8040,d1                        ; check for "L-AMIGA"
  BNE nolamiga
    CMP.w ##VANILLAKEY_F4,d7             ; check for "L-AMIGA-F4"
    BNE 'nof14
      !basic
      savewinpref{0,?ptr_sourcewindow} : JSR write_newprefs
      !asm
   'nof14

    CMP.w ##VANILLAKEY_F5,d7             ; check for "L-AMIGA-F5"
    BNE 'nof15
      !basic
      savewinpref{1,?ptr_sourcewindow } : JSR write_newprefs
      !asm
   'nof15

    CMP.w ##VANILLAKEY_F6,d7             ; check for "L-AMIGA-F6"
    BNE 'nof16
      !basic
      savewinpref{2,?ptr_sourcewindow } : JSR write_newprefs
      !asm
   'nof16

    CMP.w #$61,d7                        ; check for "L-AMIGA_A"
    BNE 'noa
      MOVEM.l a0-a6/d0-d7,-(a7)
      MOVE.l lastedited_line,d0

   'doit
    MOVE.l comPtr_CurrentSourceLine,a4
    JSR cursor_off
    JSR gotoline
    BSR cursor_on
    MOVEM.l (a7)+,a0-a6/d0-d7
    CLR.l d7
    BRA reply_idcmp_message

   'noa
    CMP.w #$31,d7                       ; check for "L-AMIGA_1"
    BNE 'no1
      MOVEM.l a0-a6/d0-d7,-(a7)
      MOVE.l storeline1,d0
      BRA 'doit

   'no1
    CMP.w #$32,d7                       ; check for "L-AMIGA_2"
    BNE 'no2
      MOVEM.l a0-a6/d0-d7,-(a7)
      MOVE.l storeline2,d0
      BRA 'doit

   'no2
    CMP.w #$33,d7                       ; check for "L-AMIGA_3"
    BNE 'no3
      MOVEM.l a0-a6/d0-d7,-(a7)
      MOVE.l storeline3,d0
      BRA 'doit
   'no3
  nolamiga

  CMP.w ##VANILLAKEY_F1,d7              ; check for "F1"
  BNE 'nof1
    JSR menu_helpgeneral
    BRA reply_idcmp_message
 'nof1

  CMP.w ##VANILLAKEY_F2,d7              ; check for "F2"
  BNE 'nof2
    JSR menu_helpincludesguide
    BRA reply_idcmp_message
 'nof2

  CMP.w ##VANILLAKEY_F3,d7              ; check for "F3"
  BNE 'nof3
    JSR menu_helpblitzlibs
    BRA reply_idcmp_message
 'nof3

  CMP.w ##VANILLAKEY_F4,d7              ; check for "F4"
  BNE 'nof4
    !basic
    num = 0:Gosub load_windowlayouts: Gosub do_windowlayout
    !asm
    CLR d7
    CLR d1
    BRA reply_idcmp_message
 'nof4

  CMP.w ##VANILLAKEY_F5,d7                         ; check for "F5"
  BNE 'nof5
    !basic
    num = 1:Gosub load_windowlayouts: Gosub do_windowlayout
    !asm
    CLR d7
    CLR d1
    BRA reply_idcmp_message
 'nof5

  CMP.w ##VANILLAKEY_F6,d7                         ; check for "F6"
  BNE 'nof6
    !basic
    num = 2:Gosub load_windowlayouts: Gosub do_windowlayout
    !asm
    CLR d7
    CLR d1
    BRA reply_idcmp_message
 'nof6

  CMP.w ##VANILLAKEY_F7,d7                         ; check for "F7"
  BNE 'nof7
    !basic
    ;AutoLayout{&wtemp,0}
    ;Gosub do_windowlayout
    Gosub navigate_to_previous_label
    !asm
    CLR d7
    CLR d1
 'nof7

  CMP.w ##VANILLAKEY_F8,d7                         ; check for "F8"
  BNE 'nof8
    !basic
    ;AutoLayout{&wtemp,1}
    ;Gosub do_windowlayout
    Gosub navigate_to_next_label
    !asm
    CLR d7
    CLR d1
 'nof8

  CMP.w ##VANILLAKEY_F9,d7                         ; check for "F9"
  BNE 'nof9
    JSR menu_previousfile
    CLR.l d7
    BRA reply_idcmp_message
 'nof9

  CMP.w ##VANILLAKEY_F10,d7                         ; check for "F10"
  BNE 'nof10
    JSR menu_nextfile
    CLR.l d7
    BRA reply_idcmp_message
 'nof10

  CMP.w #$8041,d1                       ; check for "LEFT AMIGA + LEFT SHIFT"
  BEQ 'ok
    CMP.w #$8042,d1                     ; check for "LEFT AMIGA + RIGHT SHIFT"
    BNE 'nolsamiga
 'ok

  CMP.w #$21,d7                         ; check for "L-AMiGA_!", "LEFT AMIGA + SHIFT + 1"
  BNE 'nos1
    MOVE.l d1,-(a7)
    MOVE.l comLong_DisplayLine,D1
    ADD.l comLong_DisplayLineOffset,D1
    MOVE.l d1,storeline1
    MOVE.l (a7)+,d1
    CLR.l d7
    BRA reply_idcmp_message
 'nos1

  CMP.w #$22,d7                         ; check for 'L-AMiGA_"', "LEFT AMIGA + SHIFT + 2"
  BNE 'nos2
    MOVE.l d1,-(a7)
    MOVE.l comLong_DisplayLine,D1
    ADD.l comLong_DisplayLineOffset,D1
    MOVE.l d1,storeline2
    MOVE.l (a7)+,d1
    CLR.l d7
    BRA reply_idcmp_message
 'nos2

  CMP.w #$23,d7                         ; check for "L-AMiGA_#", "LEFT AMIGA + SHIFT + 3"
  BNE 'nos3
    MOVE.l d1,-(a7)
    MOVE.l comLong_DisplayLine,D1
    ADD.l comLong_DisplayLineOffset,D1
    MOVE.l d1,storeline3
    MOVE.l (a7)+,d1
    CLR.l d7
    BRA reply_idcmp_message
 'nos3
 'nolsamiga

.reply_idcmp_message:
  MOVE.l _execbase,A6
  MOVE.l messagestore,d0
  BEQ 'l1
    MOVE.l d0,a1
    JSR _ReplyMsg(A6)
 'l1
  CLR.l messagestore
  MOVEQ.l #-$01,D0
RTS


;Scroll Sourcetext at MouseWheelY events  tomsmart1
.wheel_down:
  BSR reply_idcmp_message
  JSR storeline                                            ; added to save the changes of the corrent line
  JSR cursor_off
  MOVE.l comLong_DisplayLineOffset,d0
  ADD.l comLong_DisplayLine,d0
  ADD.l wheelstep,d0
  MOVEA.l comPtr_CurrentSourceLine,A4
  JSR gotoline                                             ; scroll the sourcetext
  BSR update_vertscroller                                  ; update position of the vertical scroller
  JSR cursor_on
  MOVEQ.l #0,d7                                            ; clear it to prevent a false detected Key press
  MOVEQ.l #0,d0
RTS


.wheel_up:
  BSR reply_idcmp_message
  JSR storeline                                            ; added to save the changes of the corrent line
  JSR cursor_off
  MOVE.l comLong_DisplayLineOffset,d0
  ADD.l comLong_DisplayLine,d0
  SUB.l wheelstep,d0
  MOVEA.l comPtr_CurrentSourceLine,A4
  JSR gotoline                                             ; scroll the sourcetext
  BSR update_vertscroller                                  ; update position of the vertical scroller
  JSR cursor_on
  MOVEQ.l #0,d7
  MOVEQ.l #0,d0                                            ; clear it to prevent a false detected Key press
RTS

.handle_event_mousemove:
  !basic
  If onlinehelp_extended
    help_ticks.b = 0 : WZ_HideHelp{}
  EndIf
  !asm
;RTS
BRA.w JL_0_844C

;OS4 MouseWheel events handling  tomsmart1
.handle_event_extendedmouse:
  !basic
  mcode.l = *intuimessage\Code & $FFFF
  If (mcode = #IMSGCODE_INTUIWHEELDATA)

    *wd.IntuiWheelData  = *intuimessage\IAddress
    ; vertical move
    If *wd\WheelY > 0
      OS4WheelStep.l = (*wd\WheelY)                        ; get the stepdelta
      Poke.l ?wheelstep,OS4WheelStep                       ; override Ped stepdelta with the OS4 one
      !asm
      BSR wheel_down                                       ; scroll the sourcetext
      !basic
    End If
    If *wd\WheelY < 0
      OS4WheelStep = (*wd\WheelY) * -1                     ; get the stepdelta an make it to a postiv value
      Poke.l ?wheelstep,OS4WheelStep                       ; override Ped stepdelta with the OS4 one
      !asm
      BSR wheel_up                                         ; scroll the sourcetext
      !basic
    End If

    ; horizontal move
    ;If *wd\WheelX><0
    ;  error{"WheelX=$"+Hex$(*wd\WheelX)}
    ;End If
  Else
    !asm
    BSR reply_idcmp_message
    !basic
  End If
  !asm
RTS




Even
actualfile:             Dc.l 0  ; current node
loadedfilesbase:        Dc.l 0  ; base node of file linked list
AL_0_84B2:              Dc.l 0  ; some other file, maybe last file

.fontdependent:
 viewablelines:         Dc.l 0
 visiblecolumns:        Dc.w 0
 fontHeight:            Dc.w 0
 ypos_statusarea        Dc.l 0
 viewablelines_m1:      Dc.l 0
 ;win_InnerHeight:       Dc.w 0
 ;win_InnerWidth:        Dc.w 0
 win_TopEdge:           Dc.w 0

 source_BoxLeft:        Dc.w 0
 source_BoxTop:         Dc.w 0
 source_BoxWidth:       Dc.w 0
 source_BoxHeight:      Dc.w 0

 fontHeightm1:          Dc.w 5
 font_Baseline:         Ds.l 1
 ptr_sourcewindow:      Dc.l 0
 rp_sourcewindow:       Dc.l 0
 rp_rectfill:           Dc.l 0
; ptr_pedscreen:         Dc.l 0
; ptr_exescreen:         Dc.l 0
 textbufferaddr:        Dc.l 0


.menu_helpshortcuts
  !basic
  Gosub open_shortcuts
  !asm
  !setregsformenuexit
RTS

.menu_helplibrarybrowser
  !basic
  Gosub open_librarybrowser
  !asm
  !setregsformenuexit
RTS

.menu_helpcompletion
  !basic
  wtemp\ibrowser_x = -2
  wtemp\ibrowser_y = -2
  wtemp\ibrowser_w = -2
  wtemp\ibrowser_h = -2
  Gosub open_instructionbrowser
  !asm
  !setregsformenuexit
RTS

.menu_helpnews:
  !basic
  Show_Helpfile{"Changelog","main",Peek$(?str_defaultpubscreen)}
  !asm
  !setregsformenuexit
RTS

.menu_helpblitzlibs:
  !basic
  Show_Helpfile{"BlitzLibs","main",Peek$(?str_defaultpubscreen)}
  !asm
  !setregsformenuexit
RTS

.menu_helpgeneral:
  !basic
  Show_Helpfile{"AmiBlitz3","main",Peek$(?str_defaultpubscreen)}
  !asm
  !setregsformenuexit
RTS

.menu_helpprogramming:
  !basic
  Show_Helpfile{"BlitzProgrammers","main",Peek$(?str_defaultpubscreen)}
  !asm
  !setregsformenuexit
RTS

.menu_helpincludesguide:
  !basic
  Show_Helpfile{"Main","main",Peek$(?str_defaultpubscreen)}
  !asm
  !setregsformenuexit
RTS


.menu_helpbuildindex
  !basic
  Gosub set_pointer_busy_bas
  LockAllOpenWZWin{}
  BuildHelpIndexWinTitle$ = "Rebuilding"                         ;added so the window title match the function  tomsmart1 ; remove !TRANS{} because it will translated with befor it will displayed  tomsmart1
  Gosub build_HelpIndexFile
  UnlockAllOpenWZWin{}
  Gosub set_pointer_normal_bas
  !asm
  !setregsformenuexit
RTS

.write_newprefs
  If WriteFile (0,addonprefs$)
    WriteType 0,wpref(0)
    WriteType 0,wpref(1)
    WriteType 0,wpref(2)
    CloseFile 0
  End If
RTS

Even                   ; make sure to have enough space reserved
.PREFSFORMAT
 ;use_wbcolors:
                        Dc.b $00,$00        ; OBSOLETE
 ;clone_wb:
                        Dc.b $00,$00        ; TOOLTYPE
 use_asldims:           Dc.b $FF,$FF
 aslreq_x:              Dc.l $18
 aslreq_y:              Dc.l $18
 aslreq_width:          Dc.l $17C
 aslreq_height:         Dc.l $17C
 flag_tokenization:     Dc.w $FF,$FF
 prefs_source_icon:     Ds.w 3
 ownscreen_modeid:      Dc.l 0              ; TOOLTYPE
 ;myscreen_Width:
                        Ds.w 1
 ownscreen_width:       Dc.b $02,$80        ; TOOLTYPE
 ;myscreen_Height:
                        Ds.w 1
 ownscreen_height:      Dc.b $01,$00        ; TOOLTYPE
 ;myscreen_Depth:
                        Dc.b $00,$00
                        Ds.w 1
 clickpos:              Dc.b $00,$0F        ; labelsize??
 othercolor:            Dc.b $00,$02        ; TOOLTYPE ex. backgroundcoler
 tokencolor:            Dc.b $00,$03        ; TOOLTYPE
 str_sourcefontname:    Dc.b 0              ; TOOLTYPE
                        Ds.b #MAX_STRINGSIZE
                        Even
 sourcefontstyle:       Dc.b $00            ; TOOLTYPE
 sourcefontflags:       Dc.b $03            ; TOOLTYPE
 sourcefontsize:        Dc.b $00,$08        ; TOOLTYPE
                        Dc.w 1              ; DUMMY
 auto_indent:           Dc.b $FF,$FF        ; TOOLTYPE
 use_filepattern:       Dc.b $FF,$FF        ; TOOLTYPE
 AL_0_B7E0:             Dc.b $FF,$FF        ; Save xtra-File ???
 tab_size:              Dc.b $00,$02        ; TOOLTYPE
 ;use_pubscreen:
                        Dc.b $FF,$FF        ; TOOLTYPE
 remember_saved:        Dc.b $FF,$FF        ; TOOLTYPE
 ;use_default_pubscreen:
                        Ds.w 1              ; TOOLTYPE
 ownscreen_depth:       Dc.b $00,$04        ; TOOLTYPE
 startup_folder:        Dc.b $FF,$FF
 ;oldWindowPos:                             ; ??? irgendwas mit Fensterpos  OBSOLETE ??
                        Ds.w 1
 ;oldWindowNumber:                          ; ??? irgendwas mit Fensterpos  OBSOLETE ??
                        Ds.w 1
 ;AL_0_B7F2:                                ; OBSOLETE
                        Ds.w 1
 ;comLong_BoundLinesX:                       ; moved to common.ab3
                        Dc.b $00,$02
 ;comLong_BoundLinesY:
                        Dc.b $00,$06
 ;AL_0_B7F8:
                        Dc.b "%1ld ",0
 ;L_0_B7FE:
                        Ds.l 4
 Even
.PREFSFORMAT_END



.update_pedhistoryfiles:
  CMP.w #$10,D6 : BEQ.w JL_0_B902
  CMP.w #$C,D6  : BEQ.w JL_0_B8A8
  CMP.w #$8,D6  : BEQ.w JL_0_B862
  CMP.w #$4,D6  : BEQ.w JL_0_B830
  RTS

  JL_0_B830:
  MOVEA.l AL_0_BFFA,A0
  MOVEA.l AL_0_BE28,A1
  MOVE.l AL_0_BFE6,AL_0_BFFA
  MOVE.l AL_0_BE24,AL_0_BE28
  MOVE.l A0,AL_0_BFE6
  MOVE.l A1,AL_0_BE24
  JSR update_historymenu
  RTS

  JL_0_B862:
  MOVEA.l AL_0_C00E,A0
  MOVEA.l AL_0_BE2C,A1
  MOVE.l AL_0_BFFA,AL_0_C00E
  MOVE.l AL_0_BFE6,AL_0_BFFA
  MOVE.l AL_0_BE28,AL_0_BE2C
  MOVE.l AL_0_BE24,AL_0_BE28
  MOVE.l A0,AL_0_BFE6
  MOVE.l A1,AL_0_BE24
  JSR update_historymenu
  RTS

  JL_0_B8A8:
  MOVEA.l AL_0_C022,A0
  MOVEA.l AL_0_BE30,A1
  MOVE.l AL_0_C00E,AL_0_C022
  MOVE.l AL_0_BFFA,AL_0_C00E
  MOVE.l AL_0_BFE6,AL_0_BFFA
  MOVE.l AL_0_BE2C,AL_0_BE30
  MOVE.l AL_0_BE28,AL_0_BE2C
  MOVE.l AL_0_BE24,AL_0_BE28
  MOVE.l A0,AL_0_BFE6
  MOVE.l A1,AL_0_BE24
  JSR update_historymenu
  RTS

  JL_0_B902:
  MOVEA.l AL_0_C036,A0
  MOVEA.l AL_0_BE34,A1
  MOVE.l AL_0_C022,AL_0_C036
  MOVE.l AL_0_C00E,AL_0_C022
  MOVE.l AL_0_BFFA,AL_0_C00E
  MOVE.l AL_0_BFE6,AL_0_BFFA
  MOVE.l AL_0_BE30,AL_0_BE34
  MOVE.l AL_0_BE2C,AL_0_BE30
  MOVE.l AL_0_BE28,AL_0_BE2C
  MOVE.l AL_0_BE24,AL_0_BE28
  MOVE.l A1,AL_0_BE24
  MOVE.l A0,AL_0_BFE6
  JSR update_historymenu
RTS

.free_historyfilelist:
  TST.w remember_saved
  BEQ.w JL_0_B98E
    TST.l ptr_historyfilelist
    BEQ.w JL_0_B98E
      MOVEA.l ptr_historyfilelist,A1
      !newfree
  JL_0_B98E:
RTS

.AJL_0_B990:
  MOVEQ.l #$00,D6
  MOVEA.l #historyfile_entry1,A0
  ANDI.l #MaxWord,D6
  LEA comStr_SourceName,A3
  JL_0_B9A2:
    MOVEA.l $0(A0,D6.W),A1
    MOVEA.l (A1),A1
    JSR compare_strings
    BNE.w JL_0_B9BE
    JL_0_B9B2:
      ADDQ.w #4,D6
      CMP.w #$14,D6
      BNE.b JL_0_B9A2
        BRA.w JL_0_B9E0

      JL_0_B9BE:
      MOVEQ.l #$00,D7
      MOVEA.l #AL_0_BE24,A2
      MOVEA.l $0(A2,D6.W),A1
      MOVEA.l (A1),A1
      LEA comStr_CurrentDir,A3
      JSR compare_strings
      BNE.w JL_0_BA3C
      LEA comStr_SourceName,A3
    BRA.b JL_0_B9B2

  JL_0_B9E0:
  MOVEQ.l #$10,D6
  MOVEA.l #historyfile_entry1,A0
  MOVEA.l #AL_0_BE24,A2
  MOVEA.l #str_unnamed,A3

  JL_0_B9F4:
  MOVEA.l $0(A0,D6.W),A1
  MOVEA.l (A1),A1
  JSR compare_strings
  BNE.w JL_0_BA0E
    SUBQ.w #4,D6
    BPL.b JL_0_B9F4
    MOVEQ.l #$10,D6
    BRA.w JL_0_BA1C
  JL_0_BA0E:
    ADDQ.l #4,D6
    CMP.l #$10,D6
    BLE.w JL_0_BA1C
      MOVEQ.l #$10,D6
  JL_0_BA1C:

  MOVEA.l $0(A0,D6.W),A1
  MOVEA.l (A1),A1
  LEA comStr_SourceName,A0
  MOVEA.l $0(A2,D6.W),A2
  JSR copy_A0_to_A1
  LEA comStr_CurrentDir,A0
  MOVEA.l (A2),A1
  JSR copy_A0_to_A1

  JL_0_BA3C:
   JSR update_pedhistoryfiles
   JSR write_pedhistoryfiles
RTS

.add_history_to_menu:
  TST.w remember_saved
  BEQ.w JL_0_BA58
    JSR load_pedhistoryfile
    BRA.w JL_0_BA5C
  JL_0_BA58:
    JSR update_historymenu
  JL_0_BA5C:
RTS

.write_pedhistoryfiles:
  !basic
  *tedfile.l = Open_(pedhistoryfile$,#HUNK_RELOC_8__MODE_NEWFILE)
  If *tedfile = 0 Then Return
  Write_ *tedfile,Peek.l(?AL_0_BFE6), $100
  Write_ *tedfile,Peek.l(?AL_0_BFFA), $100
  Write_ *tedfile,Peek.l(?AL_0_C00E), $100
  Write_ *tedfile,Peek.l(?AL_0_C022), $100
  Write_ *tedfile,Peek.l(?AL_0_C036), $100
  Close_ *tedfile
  !asm
RTS

.load_pedhistoryfile:
  MOVE.l ptr_historyfilelist,D0
  BNE.w load_historyfile
    MOVEA.l _execbase,A6
    MOVE.l #$500,D0
    !newalloc;JSR _AllocVec(A6)
    MOVE.l D0,ptr_historyfilelist
  load_historyfile:
  MOVEA.l D0,A0
  MOVE.l A0,AL_0_BFE6
  LEA $40(A0),A0 : MOVE.l A0,AL_0_BE38
  LEA $C0(A0),A0 : MOVE.l A0,AL_0_BFFA
  LEA $40(A0),A0 : MOVE.l A0,AL_0_BE3C
  LEA $C0(A0),A0 : MOVE.l A0,AL_0_C00E
  LEA $40(A0),A0 : MOVE.l A0,AL_0_BE40
  LEA $C0(A0),A0 : MOVE.l A0,AL_0_C022
  LEA $40(A0),A0 : MOVE.l A0,AL_0_BE44
  LEA $C0(A0),A0 : MOVE.l A0,AL_0_C036
  LEA $40(A0),A0 : MOVE.l A0,AL_0_BE48
  LEA $C0(A0),A0
  JSR reset_rememberedlist

  !basic
  *tedfile.l = Open_(pedhistoryfile$,#HUNK_RELOC_16__MODE_OLDFILE)
  If *tedfile <> 0
    Read_ *tedfile,Peek.l(?AL_0_BFE6),$500
    Close_ *tedfile
    !asm
    JSR update_historymenu
    !basic
  EndIf
  !asm

RTS

reset_rememberedlist:
  MOVEA.l #str_unnamed,A0
  MOVEA.l AL_0_BFE6,A1 : JSR copy_A0_to_A1
  MOVEA.l AL_0_BFFA,A1 : JSR copy_A0_to_A1
  MOVEA.l AL_0_C00E,A1 : JSR copy_A0_to_A1
  MOVEA.l AL_0_C022,A1 : JSR copy_A0_to_A1
  MOVEA.l AL_0_C036,A1 : JSR copy_A0_to_A1
RTS

.update_historymenu:
  !basic
  If Peek.l(?ptr_sourcewindow) <> 0 Then Gosub init_menus
  !asm
RTS

.load_remembered:
  TST.w remember_saved
  BNE.w JL_0_BCD6
    RTS
  JL_0_BCD6:

  SUBI.w #$78,D6
  LEA historyfile_entry1,A0
  ASL.w #2,D6
  ANDI.l #MaxWord,D6
  MOVEA.l $0(A0,D6.W),A1
  MOVEA.l (A1),A1

  ; check if unused, <unnamed> entry in menu item
  LEA str_unnamed,A3
  JSR compare_strings
  BNE.w no_source_loaded

  ; check if source already loaded.
  MOVEA.l loadedfilesbase,A2
  JL_0_BCFC:
    MOVEA.l A2,A3
    LEA $DE(A3),A3
    JSR compare_strings
    BNE.w source_already_opened

   JL_0_BD0A:
    MOVEA.l (A2),A2
    CMPA.l #$0,A2
  BNE.b JL_0_BCFC

  ;
  ; -- check if actual source is unnamed to decide to open new or just open
  ;
  !basic
  af.l = Peek.l(?actualfile)
  If af
    If Peek$(af + $DE)<>""
  ;    !cout{"need to open a new tab."}
      !asm
      JSR menu_opennew
      !basic
    EndIf
  End If
  !asm
  BRA.w load_sourcefile

  source_already_opened:
   LEA AL_0_BE24,A0
   MOVEA.l $0(A0,D6.W),A1
   MOVEA.l (A1),A1
   MOVEA.l A2,A3
   LEA $1E(A3),A3
   JSR compare_strings
   BEQ.b JL_0_BD0A
   MOVEA.l A2,A0
   JSR selectfile
  RTS

  no_source_loaded:
   MOVE.w D6,-(A7)
   JSR menu_load
   TST.l D0
   BEQ.w JL_0_BD5A
   JSR analyze_loadedsource
   MOVE.w (A7)+,D6
   JSR set_remembered_filename
   JSR draw_statusarea
   JSR write_pedhistoryfiles
  RTS

  JL_0_BD5A:
   MOVE.w (A7)+,D6
RTS

.set_remembered_filename:
  LEA historyfile_entry1,A1
  MOVEA.l $0(A1,D6.W),A1
  MOVEA.l (A1),A1
  LEA comStr_SourceName,A0
  JSR copy_A0_to_A1
  LEA AL_0_BE24,A1
  MOVEA.l $0(A1,D6.W),A1
  MOVEA.l (A1),A1
  LEA comStr_CurrentDir,A0
  JSR copy_A0_to_A1
RTS

.get_remembered_filename:
  LEA historyfile_entry1,A0
  MOVEA.l $0(A0,D6.W),A1

  LEA comStr_SourceName,A2
  MOVEA.l (A1),A1
  JL_0_BD96:
    MOVE.b (A1)+,(A2)+
  BNE.b JL_0_BD96

  LEA comStr_CurrentDir,A2
  LEA AL_0_BE24,A0
  MOVEA.l $0(A0,D6.W),A1
  MOVEA.l (A1),A1
  JL_0_BDA8:
    MOVE.b (A1)+,(A2)+
  BNE.b JL_0_BDA8
RTS


.load_sourcefile:
  JSR show_newfilerequest
  TST.l D0
  BNE.w JL_0_BDBA
  RTS

  JL_0_BDBA:
  LEA AL_0_BE24,A0
  MOVEA.l $0(A0,D6.W),A1
  MOVEA.l (A1),A1
  LEA historyfile_entry1,A2
  MOVEA.l $0(A2,D6.W),A2
  MOVEA.l (A2),A2
  MOVEA.l #comStr_SourceFileComplete,A0
  TST.b (A1)
  BEQ.w JL_0_BDEE

  JL_0_BDDA:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_BDDA

  SUBQ.w #1,A0
  CMPI.b #":",-$1(A0)
  BEQ.w JL_0_BDEE
  MOVE.b #$2F,(A0)+    ; add a "/" if no ":" found

  JL_0_BDEE:
    MOVE.b (A2)+,(A0)+
  BNE.b JL_0_BDEE

  MOVE.l #comStr_SourceFileComplete,D7
  MOVE.l D6,-(A7)
  JSR load_source
  MOVE.l (A7)+,D6
  JSR get_remembered_filename
  JSR analyze_loadedsource
  JSR draw_statusarea
RTS


ptr_historyfilelist:  Ds.l 1
historyfile_entry1:   Dc.l AL_0_BFE6
AL_0_BE14:            Dc.l AL_0_BFFA
AL_0_BE18:            Dc.l AL_0_C00E
AL_0_BE1C:            Dc.l AL_0_C022
AL_0_BE20:            Dc.l AL_0_C036
AL_0_BE24:            Dc.l AL_0_BE38
AL_0_BE28:            Dc.l AL_0_BE3C
AL_0_BE2C:            Dc.l AL_0_BE40
AL_0_BE30:            Dc.l AL_0_BE44
AL_0_BE34:            Dc.l AL_0_BE48

AL_0_BE38:            Ds.l 1
AL_0_BE3C:            Ds.l 1
AL_0_BE40:            Ds.l 1
AL_0_BE44:            Ds.l 1
AL_0_BE48:            Ds.l 1
                      Dc.b "tEdMeNuS"

; -- string pointers to the menuitems for source history
; thilo's attempt to make this flexible, but the code is such a f****** mess that I gave up!
;#MENU_MAXLASTSOURCES = 10
;LastSourceList:       Ds.l #MENU_MAXLASTSOURCES
AL_0_BFE6:            Ds.l 1
AL_0_BFFA:            Ds.l 1
AL_0_C00E:            Ds.l 1
AL_0_C022:            Ds.l 1
AL_0_C036:            Ds.l 1
addr_menustrip:       Ds.l 1
                      Dc.b "tEdMeNuS oK!"


.kill_menus
  If Peek.l(Addr GTMenuList(0))<>0
    If sourceWindow\win <> 0 Then ClearMenuStrip_ sourceWindow\win
    If WZ_CheckOpen{"WIN_NEWTYPE"}            Then Use Window WZID("WIN_NEWTYPE")            : ClearMenuStrip_ WZWindowAddr
    If WZ_CheckOpen{"WIN_LABELS"}             Then Use Window WZID("WIN_LABELS")             : ClearMenuStrip_ WZWindowAddr
    If WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"} Then Use Window WZID("WIN_INSTRUCTIONBROWSER") : ClearMenuStrip_ WZWindowAddr
    If WZ_CheckOpen{"WIN_LIBRARYBROWSER"}     Then Use Window WZID("WIN_LIBRARYBROWSER")     : ClearMenuStrip_ WZWindowAddr
    If WZ_CheckOpen{"WIN_SEARCH"}             Then Use Window WZID("WIN_SEARCH")             : ClearMenuStrip_ WZWindowAddr
    If WZ_CheckOpen{"WIN_SHORTCUTS"}          Then Use Window WZID("WIN_SHORTCUTS")          : ClearMenuStrip_ WZWindowAddr
    Free GTMenuList 0
    Poke.l ?addr_menustrip,0
  EndIf
Return


.init_menus
  Gosub kill_menus
  GTMenuTitle    0,0,   !TRANS{"Project"                     }
   GTMenuItem  0,0,0, 0,!TRANS{"Project Settings"            },"M"         ,0,#MENU_PROJECTSETTINGS
   GTMenuItem  0,0,0, 1,!TRANS{"IDE Preferences"             },""          ,0,#MENU_IDEPREFERENCES
   GTMenuItem  0,0,0, 2,!TRANS{"Menu Edit..."                },""          ,0,#MENU_CUSTOMEDIT       ; entry moved to Project menu  tomsmart1
   GTMenuItem  0,0,0, 3
   GTMenuItem  0,0,0, 4,!TRANS{"Open WB"                     },""          ,0,#MENU_OPENWORKBENCH
   GTMenuItem  0,0,0, 5,!TRANS{"Close WB"                    },""          ,0,#MENU_CLOSEWORKBENCH
   GTMenuItem  0,0,0, 6,!TRANS{"Open Shell"                  },""          ,0,#MENU_OPENSHELL
   GTMenuItem  0,0,0, 7,!TRANS{"Calculator"                  },""          ,0,#MENU_CALCULATOR
   GTMenuItem  0,0,0, 8
   GTMenuItem  0,0,0, 9,!TRANS{"About AmiBlitz3"             },""          ,0,#MENU_ABOUT
   GTMenuItem  0,0,0,10
   GTMenuItem  0,0,0,11,!TRANS{"Iconify"                     },""          ,0,#MENU_ICONIFY
   GTMenuItem  0,0,0,12,!TRANS{"Quit"                        },"Q"         ,0,#MENU_QUIT

  GTMenuTitle    0,1,   !TRANS{"Source File"                 }
   GTMenuItem  0,0,1, 0,!TRANS{"New..."                      },""          ,0,#MENU_NEW
   ; -- scan for any templates
   ClearList templates()
   templatepath.s = dos_AddPart{sourcedir$ , "Templates"}
   *root.ml_node  = ml_AddPathNode{0,templatepath.s,"#?.(bb2|ab2|ab3|asc)"}
   *node.ml_node  = *root
   templates.w    = 0
   While *node><0 AND templates < #MAX_MENUTEMPLATES
     fil.s = ml_GetUserString{*node}
     If dos_IsDir{fil} = False
        mtitle.s = Replace$(dos_RemExt{dos_FilePart{fil}},"_"," ")
        shortc.l = #MENU_TEMPLATE + templates
        GTSubItem  0,0,1, 0,templates,mtitle.s                    ,""          ,0,shortc
        If AddLast(templates()) Then templates()\filename = fil
        templates + 1
     End If
     *node = ml_GetNextNode{*node}
   Wend
   ml_RemoveAllNodes{*root}
   GTMenuItem  0,0,1, 1,!TRANS{"Open"                        },"O"         ,0,#MENU_OPEN
   GTMenuItem  0,0,1, 2,!TRANS{"Open New"                    },""          ,0,#MENU_OPENNEW
   GTMenuItem  0,0,1, 3,!TRANS{"Include File"                },"I"         ,0,#MENU_INCLUDEFILE
   GTMenuItem  0,0,1, 4
   GTMenuItem  0,0,1, 5,!TRANS{"Save"                        },"S"         ,0,#MENU_SAVE
   GTMenuItem  0,0,1, 6,!TRANS{"Save As..."                  },"A"         ,0,#MENU_SAVEAS
;  GTMenuItem  0,0,1, 7,!TRANS{"Export ASCII As..."          },""          ,0,#MENU_EXPORTASCII
   GTMenuItem  0,0,1, 7
   GTMenuItem  0,0,1, 8,!TRANS{"Print..."                    },""          ,0,#MENU_PRINT
   GTMenuItem  0,0,1, 9
   GTMenuItem  0,0,1,10,!TRANS{"Close"                       },""          ,0,#MENU_CLOSE
   If Peek.w(?remember_saved)
     GTMenuItem  0,0,1,11
     ; thilo's attempt to make this flexible, but the code is such a f****** mess that I gave up!
     ;For m.l=0 To #MENU_MAXLASTSOURCES-1
     ;  itemP.l = Peek.l(?LastSourceList + SizeOf.l*m)
     ;  If itemP Then itemT.s = Peek.s(itemP) : Else itemP = "-"
     ;  If m<5 Then short.s = Str$(m+1) : Else short=""
     ;  GTMenuItem  0,0,1,12+m,itemT,short,0,#MENU_LASTSOURCE1+m
     ;Next
     GTMenuItem  0,0,1,12,Peek$(Peek.l(?AL_0_BFE6))             ,"1"         ,0,#MENU_LASTSOURCE1
     GTMenuItem  0,0,1,13,Peek$(Peek.l(?AL_0_BFFA))             ,"2"         ,0,#MENU_LASTSOURCE2
     GTMenuItem  0,0,1,14,Peek$(Peek.l(?AL_0_C00E))             ,"3"         ,0,#MENU_LASTSOURCE3
     GTMenuItem  0,0,1,15,Peek$(Peek.l(?AL_0_C022))             ,"4"         ,0,#MENU_LASTSOURCE4
     GTMenuItem  0,0,1,16,Peek$(Peek.l(?AL_0_C036))             ,"5"         ,0,#MENU_LASTSOURCE5
   EndIf


  GTMenuTitle    0,2,   !TRANS{"Edit"                        }
   GTMenuItem  0,0,2, 0,!TRANS{"Cut"                         },"X"         ,0,#MENU_CUT
   GTMenuItem  0,0,2, 1,!TRANS{"Copy"                        },"C"         ,0,#MENU_COPY
   GTMenuItem  0,0,2, 2,!TRANS{"Paste"                       },"V"         ,0,#MENU_PASTE
   GTMenuItem  0,0,2, 3,!TRANS{"Duplicate"                   },"Z"         ,0,#MENU_DUPLICATE
   GTMenuItem  0,0,2, 4,!TRANS{"Forget"                      },"W"         ,0,#MENU_FORGET
   GTMenuItem  0,0,2, 5,!TRANS{"Kill"                        },"K"         ,0,#MENU_KILL
   GTMenuItem  0,0,2, 6,!TRANS{"Save Block As..."            },""          ,0,#MENU_SAVEBLOCKAS
   GTMenuItem  0,0,2, 7
   GTMenuItem  0,0,2, 8,!TRANS{"Insert Line"                 },""          ,0,#MENU_INSERTLINE
   GTMenuItem  0,0,2,09,!TRANS{"Delete Line"                 },"D"         ,0,#MENU_DELETELINE
   GTMenuItem  0,0,2,10,!TRANS{"Undelete Line"               },"U"         ,0,#MENU_UNDELETELINE
   GTMenuItem  0,0,2,11,!TRANS{"Join Lines"                  },"J"         ,0,#MENU_JOINLINES
   GTMenuItem  0,0,2,12,!TRANS{"Delete to EOL"               },"Y"         ,0,#MENU_DELETETOEOL
   GTMenuItem  0,0,2,13
   GTMenuItem  0,4,2,14,!TRANS{"Block Tab"                   },"CTRL+Right",0,#MENU_BLOCKTAB
   GTMenuItem  0,4,2,15,!TRANS{"Block Untab"                 },"CTRL+Left" ,0,#MENU_BLOCKUNTAB
   GTMenuItem  0,0,2,16,!TRANS{"Block Comment"               },"{"         ,0,#MENU_BLOCKCOMMENT
   GTMenuItem  0,0,2,17,!TRANS{"Block Uncomment"             },"}"         ,0,#MENU_BLOCKUNCOMMENT
   GTMenuItem  0,0,2,18,!TRANS{"Mark Indent"                 },""          ,0,#MENU_MARKINDENT
   GTMenuItem  0,0,2,19,!TRANS{"Insert Filename"             },""          ,0,#MENU_INSERTFILENAME
   GTMenuItem  0,0,2,20,!TRANS{"Open Filename Under Cursor"  },""          ,0,#MENU_OPENFILEUNDERCURSOR



  GTMenuTitle    0,3,   !TRANS{"Navigation"                  }
   GTMenuItem  0,0,3, 0,!TRANS{"Find..."                     },"F"         ,0,#MENU_OPENFIND
   GTMenuItem  0,0,3, 1,!TRANS{"Find Next"                   },"N"         ,0,#MENU_FIND
   GTMenuItem  0,0,3, 2,!TRANS{"Find Previous"               },"P"         ,0,#MENU_PREVIOUS
   GTMenuItem  0,0,3, 3,!TRANS{"Replace & Find"              },"R"         ,0,#MENU_REPLACE
   GTMenuItem  0,0,3, 4
   GTMenuItem  0,4,3, 5,!TRANS{"Top"                         },"CTRL+Up"   ,0,#MENU_TOP
   GTMenuItem  0,4,3, 6,!TRANS{"Bottom"                      },"CTRL+Down" ,0,#MENU_BOTTOM
   GTMenuItem  0,0,3, 7,!TRANS{"Goto Line..."                },"G"         ,0,#MENU_GOTOLINE
   GTMenuItem  0,0,3, 8
   GTMenuItem  0,4,3,09,!TRANS{"Previous Page"               },"F9"        ,0,#MENU_PREVPAGE
   GTMenuItem  0,4,3,10,!TRANS{"Next Page"                   },"F10"       ,0,#MENU_NEXTPAGE


  GTMenuTitle    0,4,   !TRANS{"Compiler"                    }
   GTMenuItem  0,0,4, 0,!TRANS{"Compile & Run"               },"#"         ,0,#MENU_COMPILERUN
   GTMenuItem  0,0,4, 1,!TRANS{"Save & Compile & Run"        },"B"         ,0,#MENU_SAVECOMPILERUN
   GTMenuItem  0,0,4, 2,!TRANS{"Run"                         },""          ,0,#MENU_RUN
   GTMenuItem  0,0,4, 3,!TRANS{"Create Executable..."        },"E"         ,0,#MENU_CREATEEXE
   GTMenuItem  0,0,4, 4,!TRANS{"Save & Create Executable"    },"T"         ,0,#MENU_SAVECREATEEXE
   GTMenuItem  0,0,4, 5,!TRANS{"Create minimized Executable" },""          ,0,#MENU_CREATERELEASEEXE
   GTMenuItem  0,0,4, 6,!TRANS{"Create Resident..."          },""          ,0,#MENU_CREATERESIDENT
   GTMenuItem  0,0,4, 7
   GTMenuItem  0,0,4, 8,!TRANS{"Set CLI Arguments"           },""          ,0,#MENU_SETCLIARGS
   GTMenuItem  0,0,4, 9,!TRANS{"Reload Userlibs"             },"\"         ,0,#MENU_RELOAD_USERLIBS
   GTMenuItem  0,0,4,10
   GTMenuItem  0,0,4,11,!TRANS{"Compiler Settings"           },""          ,0,#MENU_COMPILERSETTINGS
   GTMenuItem  0,1,4,12,!TRANS{"Create Debug Code"           },""          ,0,#MENU_CREATEDEBUGCODE


  GTMenuTitle    0,5,   !TRANS{"Help"                        }
   GTMenuItem  0,0,5, 0,!TRANS{"What's New?"                 },""          ,0,#MENU_WHATSNEW
   GTMenuItem  0,0,5, 1
   GTMenuItem  0,4,5, 2,!TRANS{"General AB3 Guide"           },"F1"        ,0,#MENU_GENERALGUIDE
   GTMenuItem  0,0,5, 3,!TRANS{"Programming in Blitz"        },""          ,0,#MENU_PROGRAMGUIDE
   GTMenuItem  0,4,5, 4,!TRANS{"Includes Guide"              },"F2"        ,0,#MENU_INCLUDEGUIDE
   GTMenuItem  0,4,5, 5,!TRANS{"Blitzlibs Guide"             },"F3"        ,0,#MENU_BLITZLIBSGUIDE
   GTMenuItem  0,0,5, 6,!TRANS{"Shortcuts Reference"         },""          ,0,#MENU_SHORTCUTREFERENCE
   GTMenuItem  0,0,5, 7
   GTMenuItem  0,0,5, 8,!TRANS{"Instruction Browser"         },""          ,0,#MENU_INSTRUCTIONBROWSER
   GTMenuItem  0,0,5, 9,!TRANS{"Source Browser"              },""          ,0,#MENU_SOURCEBROWSER
   GTMenuItem  0,0,5,10,!TRANS{"Definition Browser"          },""          ,0,#MENU_DEFINITIONBROWSER
   GTMenuItem  0,0,5,11,!TRANS{"Library Browser"             },""          ,0,#MENU_LIBRARYBROWSER
   GTMenuItem  0,0,5,12
   GTMenuItem  0,0,5,13,!TRANS{"Update Instruction Index"    },""          ,0,#MENU_UPDATEHELPINDEX

  Gosub load_custommenus
  If FirstItem(custommenu())                                                   ; changed code the CustomMenu only apear if there ar an entry  tomsmart1
    GTMenuTitle 0,6,    !TRANS{"Custom"                      }                 ; move MenuEdit entry to ProjectMenu  tomsmart1
      menuentry = 0                                                            ; change startentry  tomsmart1
      Repeat
        ;If custommenu()\itemname = "~"
        ;  GTMenuItem 0,0,6,menuentry
        ;Else
          shortc = #MENU_CUSTOMITEM1+menuentry                                 ; changed because CostomMenuEntry got its own ID  tomsmart1
          GTMenuItem 0,0,6,menuentry,custommenu()\itemname,"",0,shortc         ; changed because CostomMenuEntry got its own ID  tomsmart1
        ;EndIf
        menuentry + 1
      Until NOT NextItem(custommenu())
  EndIf

  CreateMenuStrip 0
  ;If templates = 0 Then GTMenuState 0,1,0,Off
  If Peek.l(Addr GTMenuList(0))<>0
    Poke.l ?addr_menustrip,Peek.l(Addr GTMenuList(0))

    If sourceWindow\win <> 0                  Then                                             SetMenuStrip_  sourceWindow\win,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_SHORTCUTS"}          Then Use Window WZID("WIN_SHORTCUTS")          : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_SEARCH"}             Then Use Window WZID("WIN_SEARCH")             : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_NEWTYPE"}            Then Use Window WZID("WIN_NEWTYPE")            : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_LABELS"}             Then Use Window WZID("WIN_LABELS")             : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"} Then Use Window WZID("WIN_INSTRUCTIONBROWSER") : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_LIBRARYBROWSER"}     Then Use Window WZID("WIN_LIBRARYBROWSER")     : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
  EndIf
Return


.load_custommenus:
  If dos_Exist{pedmenufile$}
    fid.l = file_Open{pedmenufile$,#file_read}
    If fid >= 0
      ClearList custommenu()
      While file_EOF{fid} = False
        textline.s = file_ReadLine{fid}
        If textline <> "" AND AddLast(custommenu())
          InitArgParse textline
          custommenu()\itemname  = NextArgChar$(@",")
          custommenu()\shortcut  = NextArgChar$(@",")
          custommenu()\id        = Vallong(NextArgChar$(@","))
          custommenu()\path      = NextArgChar$(@",")
          custommenu()\runwbmode = Vallong(NextArgChar$(@","))
          custommenu()\stacksize = Vallong(NextArgChar$(@","))
          custommenu()\prio      = Vallong(NextArgChar$(@","))
        EndIf
      Wend
      file_Close{fid}
    End If
  EndIf
Return


Even
.menutable:
;   $5A: Leerzeile im Menu
;   $50: Compile & Run
;   $5b: Save & Create Exec
;   $5c: Save & Compile & Run
;   $5d: Debug / Runerrors On 10*slower Code
;   $5e: Create Executable absolut Smallest

;   $56: CLI arguments
;   $57: calculator
;   $58: reload all libs
;   $59: open sourcebrowser

  Dc.l #MENU_NEW                      ; menu/shortcut ID            ; replaced hardcode values with constants  tomsmart1
  Dc.l 0                              ; refresh after function call 0= No  1 Yes
  Dc.l menu_opennew                   ;new      (function call address)

  Dc.l #MENU_OPENNEW
  Dc.l 0
  Dc.l menu_openload                  ;open new and load

  Dc.l #MENU_OPEN
  Dc.l 1
  Dc.l menu_load                      ;load

  Dc.l #MENU_INCLUDEFILE
  Dc.l 1
  Dc.l menu_includeblock              ;include block

  Dc.l #MENU_SAVE
  Dc.l 0
  Dc.l menu_save                      ;save

  Dc.l #MENU_SAVEAS
  Dc.l 0
  Dc.l menu_saveas                    ;save as

  Dc.l #MENU_EXPORTASCII
  Dc.l 0
  Dc.l menu_saveascii                 ;save ascii

  Dc.l #MENU_CLOSE
  Dc.l 0
  Dc.l menu_quit                      ;quit

  Dc.l #MENU_QUIT
  Dc.l 0
  Dc.l menu_quitall                   ;quitall

  Dc.l #MENU_PRINT
  Dc.l 0
  Dc.l menu_print                     ;print

  Dc.l #MENU_OPENWORKBENCH
  Dc.l 0
  Dc.l menu_openwb                    ;openwb

  Dc.l #MENU_CLOSEWORKBENCH
  Dc.l 0
  Dc.l menu_closewb                   ;closewb

  Dc.l #MENU_ICONIFY
  Dc.l 0
  Dc.l menu_iconify                   ;iconify

  Dc.l #MENU_OPENSHELL
  Dc.l 0
  Dc.l menu_newshell                  ;newcli

  Dc.l #MENU_IDEPREFERENCES
  Dc.l 0
  Dc.l menu_settings                  ;prefs       ; changed to jump direct to the function  tomsmart1

  Dc.l #MENU_ABOUT
  Dc.l 0
  Dc.l menu_about                     ; about
  ;
  Dc.l #MENU_LASTSOURCE1
  Dc.l 1
  Dc.l load_remembered                ; remembered sources

  Dc.l #MENU_LASTSOURCE2
  Dc.l 1
  Dc.l load_remembered

  Dc.l #MENU_LASTSOURCE3
  Dc.l 1
  Dc.l load_remembered

  Dc.l #MENU_LASTSOURCE4
  Dc.l 1
  Dc.l load_remembered

  Dc.l #MENU_LASTSOURCE5
  Dc.l 1
  Dc.l load_remembered

  ; -- MENU SOURCE
  Dc.l #MENU_CUT
  Dc.l 1
  Dc.l menu_cut

  Dc.l #MENU_COPY
  Dc.l 1
  Dc.l menu_copy

  Dc.l #MENU_PASTE
  Dc.l 1
  Dc.l menu_paste

  Dc.l #MENU_DUPLICATE
  Dc.l 1
  Dc.l menu_dublicate

  Dc.l #MENU_FORGET
  Dc.l 1
  Dc.l menu_forget

  Dc.l #MENU_KILL
  Dc.l 1
  Dc.l menu_kill

  Dc.l #MENU_SAVEBLOCKAS
  Dc.l 1
  Dc.l menu_saveblockas

  Dc.l #MENU_INSERTLINE
  Dc.l 0
  Dc.l menu_insertline

  Dc.l #MENU_DELETELINE
  Dc.l 0
  Dc.l menu_deleteline

  Dc.l #MENU_UNDELETELINE
  Dc.l 0
  Dc.l menu_undeleteline            ; undelete

  Dc.l #MENU_JOINLINES
  Dc.l 0
  Dc.l menu_joinline                ; join

  Dc.l #MENU_BLOCKTAB
  Dc.l 1
  Dc.l menu_blocktab                ; block Tab

  Dc.l #MENU_BLOCKUNTAB
  Dc.l 1
  Dc.l menu_blockuntab              ; block untab

  Dc.l #MENU_BLOCKCOMMENT
  Dc.l 1
  Dc.l menu_blockcomment            ; block comment

  Dc.l #MENU_BLOCKUNCOMMENT
  Dc.l 1
  Dc.l menu_blockuncomment

  Dc.l #MENU_MARKINDENT
  Dc.l 1
  Dc.l menu_markindent

  Dc.l #MENU_PROJECTSETTINGS
  Dc.l 0
  Dc.l menu_project

  Dc.l #MENU_TOP
  Dc.l 1
  Dc.l menu_top

  Dc.l #MENU_BOTTOM
  Dc.l 1
  Dc.l menu_bottom

  Dc.l #MENU_GOTOLINE
  Dc.l 1
  Dc.l menu_gotoline

  Dc.l #MENU_PREVPAGE
  Dc.l 0
  Dc.l menu_previousfile

  Dc.l #MENU_NEXTPAGE
  Dc.l 0
  Dc.l menu_nextfile

  Dc.l #MENU_OPENFIND
  Dc.l 1
  Dc.l menu_find

  Dc.l #MENU_FIND
  Dc.l 1
  Dc.l menu_findnext

  Dc.l #MENU_PREVIOUS
  Dc.l 1
  Dc.l menu_previous

  Dc.l #MENU_REPLACE
  Dc.l 1
  Dc.l menu_replace

  Dc.l #MENU_WHATSNEW
  Dc.l 0
  Dc.l menu_helpnews

  Dc.l #MENU_GENERALGUIDE
  Dc.l 0
  Dc.l menu_helpgeneral

  Dc.l #MENU_PROGRAMGUIDE
  Dc.l 0
  Dc.l menu_helpprogramming

  Dc.l #MENU_BLITZLIBSGUIDE
  Dc.l 0
  Dc.l menu_helpblitzlibs

  Dc.l #MENU_INCLUDEGUIDE
  Dc.l 0
  Dc.l menu_helpincludesguide           ;syntax

  Dc.l #MENU_INSTRUCTIONBROWSER
  Dc.l 0
  Dc.l menu_helpcompletion

  Dc.l #MENU_SHORTCUTREFERENCE
  Dc.l 0
  Dc.l menu_helpshortcuts

  Dc.l #MENU_LIBRARYBROWSER
  Dc.l 0
  Dc.l menu_helplibrarybrowser

  Dc.l #MENU_UPDATEHELPINDEX
  Dc.l 0
  Dc.l menu_helpbuildindex

  ; end of menutable
  Dc.l $FFFFFFFF                        ; end of menutable  tomsmart1
Even


.struct_textfont:       Ds.l 1
  textfont_YSize:       Dc.b $00,$08
  textfont_Style:       Dc.b $00
  textfont_Flags:       Dc.b $00
                        Ds.l 2
  L_0_D1D0:             Ds.l 2
                        Dc.b $FF,$FF,$00,$00
                        Ds.w 1
                        Dc.b $00,$20,$09,$00
                        Ds.l 7
                        Dc.b $00,$0F

str_unable_screen:      Dc.b "Unable to open screen!",0 : Even
str_unable_window:      Dc.b "Unable to open window!",0 : Even
str_no_clipboard_device:Dc.b "Unable to open clipboard.device",0 : Even

easystruct_saveas:      Ds.w 1
                        Dc.b $00,$14,$00,$00
                        Ds.w 1
  AL_0_D43E:            Dc.l AL_0_D44A
  AL_0_D442:            Dc.l AL_0_D45A
  AL_0_D446:            Dc.l AL_0_D47A

  AL_0_D44A:            Dc.b "Save File As...",0 : Even
  AL_0_D45A:            Dc.b "File already exists!",0 : Even
  AL_0_D47A:            Dc.b "Overwrite|Cancel",0 : Even


easystruct_error:       Dc.l $14                ; 0000 Structsize
  flags:                Dc.l $00
  ptr_errortitle:       Dc.l AL_0_D5E8        ; Title
  ptr_errortext:        Ds.l 1                ; Text
  ptr_textgadget:       Dc.l AL_0_D5F0        ; Gadget

  AL_0_D5E8:            Dc.b "Error!",0 : Even
  AL_0_D5F0:            Dc.b "Ok",0 : Even


easystruct_loosewarning:Ds.w 1
                        Dc.b $00,$14,$00,$00
                        Ds.w 1
  AL_0_D5FE:            Dc.l str_newfile_req
  AL_0_D602:            Dc.l str_unsaved
  AL_0_D606:            Dc.l str_continue

str_newfile_req:        Dc.b "New File ",0 : Even
str_unsaved:            Dc.b "You have unsaved changes!",0 : Even
str_continue:           Dc.b "Continue|Cancel",0 : Even
Even

;str_topaz:              Dc.b "topaz.font",0 : Even
;topaz_font:             Dc.l str_topaz
;                        Dc.b $00,$08,$00,$00
str_unnamed:            Dc.b "<unnamed>",0 : Even

str_printerdevice:      Dc.b "PRT:",0 : Even
                        Ds.w 29

str_Arexx_PortName:     Dc.b "PED_"
str_Arexx_availability: Dc.b "REXX"
str_Arexx_portnumber:   Dc.b "1"                       ; portnumber as string
                        Dc.b 0                         ; string termination

str_defaultpubscreen:   Dc.b "AmiBlitz3_"
screen_number:          Dc.b 0,0,0                     ; Screennumber, max 3 chars 1-255 or string "WB"
                        Dc.b 0                         ; string termination
;str_windowtitle:        Ds.l 1
;struct_WBMsgPort        Ds.l 1
ptr_tempstring:         Ds.l 1


.compare_strings:       ; compare string in A1/A3     (AJL_0_DD12)
  MOVEQ.l #$00,D0
  MOVEQ.l #$00,D1
  MOVEM.l A1/A3,-(A7)

  JL_0_DD1A:
    MOVE.b (A1)+,D2
    MOVE.b (A3)+,D3
    CMP.b #$20,D2
     BNE.w JL_0_DD2C
    TST.b D3
     BEQ.w JL_0_DD4C

    JL_0_DD2C:
    TST.b D2
     BNE.w JL_0_DD38
    TST.b D3
     BEQ.w JL_0_DD4C

    JL_0_DD38:
    BSET #$5,D2
    BSET #$5,D3
    CMP.b D2,D3
  BEQ.b JL_0_DD1A

  MOVEM.l (A7)+,A1/A3
  MOVEQ.l #$00,D0
  RTS

  JL_0_DD4C:
  MOVEM.l (A7)+,A1/A3
  MOVEQ.l #-$01,D0          ; string not equal
RTS


.menu_project:
  JSR set_pointer_busy
  JSR StoreXtraData
  !basic
  LockAllOpenWZWin{}
  If NOT WZ_CheckOpen{"WIN_PROJECT"}
    WZWindow WZID("WIN_PROJECT"),?wzgui,192,-2,-2,-2,-2,WZID("WIN_PROJECT")
    Use Window WZID("WIN_PROJECT")
    WZ_InitTable{"WIN_PROJECT","PROJECTTABLE",2}
    WZ_SetTableTitle{"PROJECTTABLE","File","Category"}
    WZ_SetTableColors{"PROJECTTABLE",1,0,1,0}
    WZ_SetPriority{"PROJECTTABLE",3,1}
    WZ_SetSortable{"PROJECTTABLE",Off}
    project_tab.b = WZInput("PROJECT_TABS")
    Gosub update_versiongadgets
  EndIf

  MaxLen lf$=64
  MaxLen pa$=64
  DEFTYPE.l *ptr_filename
  MOVE.l actualfile,D0 : *ptr_filename.l = PutD0
  actual_file$ = Peek.s(*ptr_filename + $DE)
  actual_drawer$ = Peek.s(?comStr_CurrentDir)

  If project_tab = 1
    WZ_DrawTable{"PROJECTTABLE"}
    Gosub project_updatesourcelist
  EndIf

  exit_project.b = False
  Repeat
    ev.l = WaitEvent
    Select ev
    Case #IDCMP_IDCMPUPDATE
      Select WZGadName
      Case "PROJECT_TABS"
        project_tab.b = WZInput("PROJECT_TABS")
        If project_tab = 1
          WZ_DrawTable{"PROJECTTABLE"}
          Gosub project_updatesourcelist
        EndIf

      Case "PROJECT_NAME"
        ab2_project\name = WZInputstr

      Case "PROJECT_DRAWER"
        ab2_project\drawer = WZInputstr

      Case "PROJECT_VERSION"
        ab2_project\version = WZInput

      Case "PROJECT_REVISION"
        ab2_project\revision = WZInput


      Case "PROJECT_CREATE"
        If ab2_project\name<>""
          If ask{!TRANS{"The current project and its files will be closed,\\nand all source files will be saved."},!TRANS{"Ok|Cancel"},!TRANS{"Create Project"}}
            WZ_ClearTable{"PROJECTTABLE"}
            WZ_UpdateTable{"PROJECTTABLE"}
            Gosub project_closeallfiles
            ClearType ab2_project
            Gosub project_updatesourcelist
            ActivateWZGadget{"PROJECT_NAME"}      ; replaced to use the statement  tomsmart1 2012 03 09
          EndIf
        Else
          dummy.l = ask{!TRANS{"Illegal Projectname"},!TRANS{"Ok"},!TRANS{"Create Project"}}
        EndIf

      Case "PROJECT_LOAD"
        aslfr_SetRequesterTitle {1,!TRANS{"Choose Project"},!TRANS{"Ok"},!TRANS{"Cancel"}}
        aslfr_SetPath  {1,"",lf$,"#?.a2p",False}
        If aslfr_Request {1,False,False,False,-1,True}
          lf$=aslfr_GetNextFile{}
        ;If Exists(lf$)>0
          Gosub project_load
          If ab2_project\sourcecounter > 0
            For pc.l = 1 To ab2_project\sourcecounter
              fext$ = dos_GetExt{ab2_project\sourcefile[pc]}
              If fext$="ab2" OR fext$="bb2" OR fext$="bb"
                sourcefile$ = ab2_project\sourcepath[pc]+ab2_project\sourcefile[pc]
                GetD0 &sourcefile$
                !asm
                JSR loadfile
                !basic
              EndIf
            Next pc
            Gosub activatesourcewindow
            Gosub project_updatesourcelist
            Use Window WZID("WIN_PROJECT")
            WindowToFront_ WZWindowAddr
          EndIf
        Else
          If lf$ <> "" Then dummy.l = ask{!TRANS{"This project does not exist."},!TRANS{"Ok"},!TRANS{"Info"}}
        EndIf

      Case "PROJECT_SAVE"
        ab2_project\name = WZGetString("PROJECT_NAME")
        ab2_project\drawer = WZGetString("PROJECT_DRAWER")
        If ab2_project\name <> ""
          Gosub project_save
        Else
          dummy.l = ask{!TRANS{"Illegal Projectname"},!TRANS{"Ok"},!TRANS{"Error"}}
        EndIf

      Case "PROJECT_ADDFILE"
        aslfr_SetRequesterTitle {1,!TRANS{"Add File"},!TRANS{"Ok"},!TRANS{"Cancel"}}
        aslfr_SetPath  {1,ab2_project\drawer,lf$,"",False}
        If aslfr_Request {1,False,False,False,-1,False}
          actual_file$=aslfr_GetNextFile{}
        ;If Exists(actual_file$) > 0
          ab2_project\sourcecounter + 1
          ab2_project\sourcefile[ab2_project\sourcecounter] = dos_FilePart{actual_file$}

          Gosub project_loadfile
          actual_file$ = dos_FilePart{actual_file$}
          Gosub project_updatesourcelist
          Use Window WZID("WIN_PROJECT")
          WindowToFront_ WZWindowAddr
        Else
          If lf$ <> "" Then dummy.l = ask{!TRANS{"This file does not exist"},!TRANS{"Ok"},!TRANS{"Error"}}
        EndIf

      Case "PROJECT_REMOVEFILE"
        actual_file$ = WZ_GetCell{"PROJECTTABLE",WZ_Row{"PROJECTTABLE"},1}
        For pc = 1 To ab2_project\sourcecounter
          If actual_file$ = ab2_project\sourcefile[pc]
            Gosub project_removefile
            ab2_project\sourcefile[pc] = ""
            ab2_project\sourcepath[pc] = ""
            Gosub project_sortsourcelist
            Gosub project_updatesourcelist
          EndIf
        Next pc
;        Gosub activatesourcewindow                              ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1
;        !asm
;        JSR menu_quit
;        !basic

; -- TAB Versionmanagement --

      Case "INTEGER_VER_MAJOR"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_MINOR"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_PATCH"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_BUILD"
        Gosub get_versiondata_from_gui

      ; -- TAB Changelog --

      Case "CHANGELOG_ADDENTRY"
        If Peek.l(?comPtr_VersionInformation) AND Peek.l(?comPtr_NumberOfBuilds)
          If (Peek.l(?comPtr_VersionInformation)<>0) AND (Peek.l(?comPtr_NumberOfBuilds )<>0)
            version_code.l = Peek.l(Peek.l(?comPtr_VersionInformation))
            anz_builds.l   = Peek.l(Peek.l(?comPtr_NumberOfBuilds))
            vercode$ = Str$(version_code LSR 24 )+"."
            vercode$ + Str$((version_code LSL 8) LSR 24 )+"."
            vercode$ + Str$((version_code LSL 16)LSR 24 )+" (build: "
            vercode$ + Str$(anz_builds)+")"
            changelog$ =  "V"+vercode$ + ":\\0a\\0a" + changelog$
            WZPrint "CHANGELOG_TEXTFIELD",&changelog$
          EndIf
        EndIf

      Case "CHANGELOG_TEXTFIELD"
        changelog$ = WZ_GetStringField{"CHANGELOG_TEXTFIELD"}

      End Select

   Case #IDCMP_VANILLAKEY
     Select EventCode
       Case #VANILLAKEY_ESC : exit_project = True
     End Select


    Case #IDCMP_CLOSEWINDOW
      exit_project = True
    End Select

    If project_tab = 1
      wev.l = WZ_CheckTableEvent{ev}
      If wev = #WZTABLEEVENT_DOUBLECLICK
        _sf$ = WZ_GetCell{"PROJECTTABLE",WZ_Row{"PROJECTTABLE"},1}
        If (_sf$<>actual_file$) AND (_sf$<>Peek.s(?str_unnamed))
          actual_file$ = _sf$
          Gosub project_loadfile
;        For pc = 1 To ab2_project\sourcecounter
;          t$ = ab2_project\sourcefile[pc]
;          If t$ = actual_source$ Then WZ_SetActiveRow{"PROJECTTABLE",pc}
;        Next pc
;        WZ_UpdateTable{"PROJECTTABLE"}
          Use Window WZID("WIN_PROJECT")
          WindowToFront_ WZWindowAddr
;        exit_project = True
        EndIf
      EndIf
    EndIf
  Until exit_project = True

  WZ_KillTable{"PROJECTTABLE"}
  WZCloseWindow WZID("WIN_PROJECT")
  FlushEvents
  Gosub activatesourcewindow
  UnlockAllOpenWZWin{}
  Gosub set_pointer_normal_bas
  !asm
  !setregsformenuexit
RTS

.project_sortsourcelist
  tempcounter.w = 0
  For i = 1 To #MAX_SOURCEFILES
    If ab2_project\sourcefile[i]<> ""
      tempcounter + 1
      tempproject$(tempcounter,0) = ab2_project\sourcefile[i]
      tempproject$(tempcounter,1) = ab2_project\sourcepath[i]
    EndIf
    ab2_project\sourcefile[i] = ""
    ab2_project\sourcepath[i] = ""
  Next i

  For i = 1 To tempcounter
    ab2_project\sourcefile[i] = tempproject$(i,0)
    ab2_project\sourcepath[i] = tempproject$(i,1)
  Next i
  ab2_project\sourcecounter = tempcounter
Return

.project_updatesourcelist:
  If project_tab = 1
    WZ_ClearTable{"PROJECTTABLE"}
    If ab2_project\sourcecounter > 0
      For pc = 1 To ab2_project\sourcecounter
        t$ = LCase$(ab2_project\sourcefile[pc])
        If Instr(t$,".include") Then u$ = "Include" Else
        If Instr(t$,".bb2")     Then u$ = "AB2-Source" Else
        If Instr(t$,".ab2")     Then u$ = "AB2-Source" Else
        If Instr(t$,".ab3")     Then u$ = "AB3-Source" Else
        If Instr(t$,".bb")      Then u$ = "BB2-Source" Else
        If Instr(t$,".wizard")  Then u$ = "Wizard-GUI-File" Else u$ = dos_GetExt{t$}+" File"
        WZ_AddRow{"PROJECTTABLE",t$,u$}
        If t$ = LCase$(actual_file$) Then WZ_SetActiveRow{"PROJECTTABLE",pc}
      Next pc
    EndIf
    WZ_UpdateTable{"PROJECTTABLE"}

    ab2p$ = ab2_project\name
    ab2d$ = ab2_project\drawer
    WZPrint "PROJECT_NAME",&ab2p$
    WZPrint "PROJECT_DRAWER",&ab2d$
;    WZPrint "PROJECT_VERSION",ab2_project\version
;    WZPrint "PROJECT_REVISION",ab2_project\revision
  EndIf
Return

.project_closeallfiles
  Gosub activatesourcewindow
  !asm
  go_on_closing:
  JSR dummy_compilercall
  JSR clear_labellist
  JSR clear_actualsource
  MOVEA.l actualfile,A0
  JSR close_actualsource
  TST.l loadedfilesbase
  BNE.b go_on_closing
  exit_closing:
  !basic
  Gosub activatesourcewindow
Return

.project_removefile:
  t$ = actual_file$
  If Instr(t$,".bb2")     OR Instr(t$,".ab2") OR Instr(t$,".ab3")     OR Instr(t$,".bb")
    Gosub project_loadfile
    !asm
    JSR menu_quit
    !basic
    MOVE.l actualfile,D0 : *ptr_filename = PutD0
    actual_file$ = Peek.s(*ptr_filename + $DE)
  EndIf
Return

.project_loadfile:
  t$ = LCase$(actual_file$)
  If Instr(t$,".bb2")     OR Instr(t$,".ab2")  OR Instr(t$,".ab3")    OR Instr(t$,".bb")
    GetD0 &actual_file$
    !asm
    JSR loadfile
    !basic
  EndIf
Return

.project_load
  If OpenFile(1,lf$)
    ClearType ab2_project
    ReadType 1,ab2_project
    CloseFile 1
  Else
    dummy.l = ask{!TRANS{"This project could not be loaded"},!TRANS{"Ok"},"Error"}
  EndIf
Return

.project_save
  lf$ = ab2_project\name+".a2p"
  aslfr_SetRequesterTitle {1,!TRANS{"Save Projectfile"},!TRANS{"Ok"},!TRANS{"Cancel"}}
  aslfr_SetPath  {1,ab2_project\drawer,lf$,"(#?.a2p)",False}
  If aslfr_Request {1,True,False,False,-1,True}
    lf$=aslfr_GetNextFile{}
    If OpenFile(1,lf$)
      WriteType 1,ab2_project
      CloseFile 1
    Else
      dummy.l = ask{!TRANS{"The project could not be saved."},!TRANS{"Ok"},!TRANS{"Error"}}
    EndIf
  EndIf
Return

.get_versiondata_from_gui:
  If WZ_CheckOpen{"WIN_PROJECT"}
    If Peek.l(?comPtr_VersionInformation)
      version_code = WZInput("INTEGER_VER_MAJOR") LSL 24
      version_code + (WZInput("INTEGER_VER_MINOR") LSL 16)
      version_code + (WZInput("INTEGER_VER_PATCH") LSL 8)
      Poke.l Peek.l(?comPtr_VersionInformation),version_code

      Poke.l Peek.l(?comPtr_NumberOfBuilds), WZInput("INTEGER_VER_BUILD")
    EndIf
  EndIf
Return

.update_versiongadgets
  If Peek.l(?comPtr_VersionInformation) AND Peek.l(?comPtr_NumberOfBuilds)
    If (Peek.l(?comPtr_VersionInformation)<>0) AND (Peek.l(?comPtr_NumberOfBuilds)<>0)
      version_code.l = Peek.l(Peek.l(?comPtr_VersionInformation))
      anz_builds.l   = Peek.l(Peek.l(?comPtr_NumberOfBuilds))
      If WZ_CheckOpen{"WIN_PROJECT"}
        Use Window WZID("WIN_PROJECT")
        WZPrint "INTEGER_VER_MAJOR",version_code LSR 24
        WZPrint "INTEGER_VER_MINOR",(version_code LSL 8) LSR 24
        WZPrint "INTEGER_VER_PATCH",(version_code LSL 16)LSR 24
        WZPrint "INTEGER_VER_BUILD",anz_builds
        WZPrint "CHANGELOG_TEXTFIELD",&changelog$
      EndIf
    EndIf
  EndIf
Return



; --
; --      hier kommt u.a. die ganze AREXX geschichte
; --
.event_arexx_bas:
  ArexxSenderName$ = Peek$(*incomingRexxMsg\rm_Node\mn_Node\ln_Name)
  Poke.l ?ptr_arexx_sendername, &ArexxSenderName$
  ArexxCommand$ = Peek$(*incomingRexxMsg\rm_Args)
  log_Print{"received Arexxmessage from [" + ArexxSenderName$ + "]: " + ArexxCommand$}

  If *incomingRexxMsg\rm_Node\mn_Node\ln_Type = #NT_REPLYMSG
    ; ignore these message types
    ;!asm
    ;MOVE.l struct_RexxMsg,D0
    ;JSR free_RexxMsg
    ;!basic
  Else
    If *incomingRexxMsg\rm_Node\mn_Node\ln_Type = #NT_MESSAGE
      ; handle these messages
    Else
      ReplyMsg_ *incomingRexxMsg
    EndIf
  EndIf
Return

.event_arexx:
  MOVE.l D0,struct_RexxMsg
  MOVEA.l D0,A0
  MOVE.l $A(A0),ptr_arexx_sendername

  MOVEA.l A0,A1
  MOVE.l $28(A1),ptr_arexx_commandstr
  CMPI.b #$7,$8(A0)
  BEQ.w ignore_arexx_message
    CMPI.b #$5,$8(A0)
    BEQ.w handle_arexx_message
      MOVEA.l A0,A1
      JSR _ReplyMsg(A6)
      RTS
  ignore_arexx_message:
    MOVE.l struct_RexxMsg,D0
    JSR free_RexxMsg
    RTS

  handle_arexx_message:
  SF checked_arexxcmd
  JSR cursor_off
  LEA ptr_arexxcmd_list,A2
  MOVEA.l (A2)+,A3
  MOVEA.l ptr_arexx_commandstr,A1

  JL_0_DF90:
    JSR compare_strings
    BNE.w command_found
    ADDQ.l #4,A2
    MOVEA.l (A2)+,A3
    CMPA.l #$0,A3
  BNE.b JL_0_DF90
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
  BRA.w arexx_answer_message

  command_found:
  MOVEA.l (A2),A0

  MOVEM.l D1-D7/A0-A3,-(A7)
  JSR arexx_count_parameters
  MOVEM.l (A7)+,D1-D7/A0-A3

  ; -- call the arexx-function
  JSR (A0)
  JSR arexx_answer_message
JMP cursor_on


.get_strlength: ; A0: String, D0: returns length
  MOVEQ.l #-$01,D0

  JL_0_DFCA:
    ADDQ.l #1,D0
    TST.b (A0)+
  BNE.b JL_0_DFCA
RTS

.arexx_answer_message:
  TST.b checked_arexxcmd
   BNE.w exit_answerarexx

  MOVE.l D0,-(A7)           ; return code, geht unten in $20(A1)

  CMPA.l #$0,A0
   BEQ.w no_return_string

  MOVE.l A0,-(A7)
  BSR.b get_strlength
  MOVEA.l (A7)+,A0

  MOVEA.l _rexxsyslibbase,A6
  JSR _CreateArgstring(A6)            ; create the return string
  MOVEA.l D0,A0

  MOVE.l a0,-(a7)
;  !basic
;  MOVE.l (a7)+,d0 :  i.l = PutD0
;  !cout{"arexx-message wird beantwortet von ",Peek$(Peek.l(?ptr_arexx_sendername))}
;  !cout{"command:",Peek$(Peek.l(?ptr_arexx_commandstr))}
;  MOVE.l (a7),d0 : rc.l = PutD0
;  !cout{"rn_Result2: *",Peek$(i),"*  return code:",rc}
;  !asm

  no_return_string:
  MOVEA.l struct_RexxMsg,A1
  MOVE.l A0,$24(A1)                   ; AtrString -> rn_Result2
  MOVE.l (A7)+,$20(A1)                ; return code -> rm_Result1
  MOVE.b #NT_REPLYMSG,$8(A1)          ; Message has been replied -> ln_Type
  MOVEA.l _execbase,A6
  JSR _ReplyMsg(A6)
  MOVEQ.l #$00,D7

  exit_answerarexx:
RTS


.init_arexxport_bas:
  !asm
  MOVE.l #$200,D0
  !newalloc;JSR _AllocVec(A6)         ;for arexxfunc_getword
  MOVE.l D0,ptr_tempstring
  !basic

  ;-- check if Rexx is available
  *ArexxPort.MsgPort = FindPort_("REXX")
  ;Poke.l ?ptr_arexxport,*ArexxPort
  If *ArexxPort <> 0
     ;-- bereits vorhandenen AB3-Port suchen
     ArexxPortName$ = "PED_REXX_"
     For ArexxPortNumber.b = 1 To 9
       If NOT FindPort_(ArexxPortname$+Str$(ArexxPortNumber))
        Pop For : Goto exit_arexxloop
       EndIf
     Next ArexxPortNumber
     exit_arexxloop:
     !asm
     MOVE.l #$1000,D0
     !newalloc
     MOVEQ.l #$0F,D1
     LEA arexx_table,A1
     arexx_clearloop:
       MOVE.l D0,(A1)+
       ADDI.l #$100,D0
     DBF D1,arexx_clearloop
     !basic
     ;-- open rexxsslib
     Poke.l ?_rexxsyslibbase,RexxSysBase
     *ArexxMsgPort.MsgPort = CreateMsgPort_ : Poke.l ?struct_ArexxMsgPort,*ArexxMsgPort
     If *ArexxMsgPort
       *ArexxMsgPort\mp_Node\ln_Pri = Asc("2")
       *ArexxMsgPort\mp_Node\ln_Name = &ArexxPortName$
       AddPort_ *ArexxMsgPort

       ;-- get all pending messages
       Poke.b ?rexx_signalbits,*ArexxMsgPort\mp_SigBit
       Repeat
         *tmpMsg.RexxMsg = GetMsg_(*ArexxMsgPort)
       Until *tmpMsg = 0

       Poke.l ?arexxport_available, $FFFFFFFF
       Return
     EndIf
  EndIf
  ArexxPortName$ = "N/A     "
  ArexxPortNumber$ = " "
  Poke.l ?arexxport_available, 0
Return

;.init_arexxport:
;  MOVE.l #$200,D0
;  !newalloc;JSR _AllocVec(A6)         ;for arexxfunc_getword
;  MOVE.l D0,ptr_tempstring
;
;  ; -- search for any arexx-ports
;  MOVEA.l _execbase,A6
;  LEA str_REXX,A1
;  JSR _FindPort(A6)
;  TST.l D0
;  BEQ.w no_arexx_port_available
;  MOVE.l D0,ptr_arexxport
;
;  ; -- search for amiblitz-arexxports and get the next free number
;  JL_0_E032:
;    LEA str_Arexx_PortName,A1
;    JSR _FindPort(A6)
;    TST.l D0
;    BEQ.w JL_0_E054
;      MOVE.b str_Arexx_portnumber,D1
;      ADDQ.b #1,D1
;      MOVE.b D1,str_Arexx_portnumber
;  CMP.b #"9",D1
;  BNE.b JL_0_E032
;
;  JL_0_E054:
;  MOVE.l #$1000,D0
;  !newalloc
;
;  MOVEQ.l #$0F,D1
;  LEA arexx_table,A1
;  JL_0_E080:
;    MOVE.l D0,(A1)+
;    ADDI.l #$100,D0
;  DBF D1,JL_0_E080
;
;  ; -- try to open rexxsys.library for creating my own arexxports
;  LEA str_libname_rexxsyslib,A1
;  MOVEQ.l #$00,D0
;  JSR _OpenLibrary(A6)
;  MOVE.l D0,_rexxsyslibbase
;  BEQ.w no_arexx_port_available
;
;    JSR _CreateMsgPortA(A6)
;    MOVE.l D0,struct_ArexxMsgPort
;    BEQ.w no_arexx_port_available
;
;    MOVEA.l D0,A1
;    MOVE.b #"2",$9(A1)
;    MOVE.l #str_Arexx_PortName,$A(A1)
;    JSR _AddPort(A6)
;
;    MOVEA.l struct_ArexxMsgPort,A0
;    MOVE.b $F(A0),rexx_signalbits
;    JL_0_E0CE:
;      MOVEA.l struct_ArexxMsgPort,A0
;      JSR _GetMsg(A6)
;    TST.l D0
;    BNE.b JL_0_E0CE
;    MOVE.l #$FFFFFFFF,arexxport_available
;    MOVE.l #$5045445F,str_Arexx_PortName                 ; "PED_"
;    MOVE.l #$52455858,str_Arexx_availability             ; "REXX"
;    RTS
;
;  no_arexx_port_available:
;    MOVE.l #$4E2F4120,str_Arexx_PortName
;    MOVE.l #$20202020,str_Arexx_availability             ; "N/A "
;    MOVE.b #$20,str_Arexx_portnumber
;    CLR.l arexxport_available
;RTS


.close_arexxport_bas:
  !asm
  MOVEA.l ptr_tempstring,a1
  !newfree
  !basic
  If Peek.l(?arexxport_available)
    ; clear arexxtable
    !asm
    MOVEA.l arexx_table,A1
    !newfree
    !basic
    Gosub init_rexxmsg_bas
    rexxMsg\rm_Action = $9000000
    rexxMsg\rm_Args   = &ArexxPortName$
    *ArexxPort.MsgPort = FindPort_("REXX")
    If *ArexxPort <> 0
      PutMsg_ *ArexxPort, rexxMsg
      WaitPort_ *ArexxMsgPort
      *tmpMsg.RexxMsg = GetMsg_(*ArexxMsgPort)
      *tmpMsg\rm_Args = 0
    EndIf
    RemPort_ *ArexxMsgPort
    DeleteMsgPort_ *ArexxMsgPort
    *ArexxMsgPort = 0
  EndIf
Return

;.close_arexxport:
;  MOVEA.l ptr_tempstring,a1
;  !newfree
;
;  TST.l arexxport_available
;  BEQ.w exit_closearexxport
;    JSR clear_arexxtable
;    JSR init_RexxMsg
;    MOVEA.l struct_RexxMsg,A0
;    MOVE.l #$9000000,$1C(A0)
;    MOVE.l #str_Arexx_PortName,$28(A0)
;    LEA str_REXX,A1
;    JSR _FindPort(A6)
;    TST.l D0
;    BEQ.w JL_0_E192
;      MOVEA.l D0,A0
;      MOVEA.l struct_RexxMsg,A1      : JSR _PutMsg(A6)
;      MOVEA.l struct_ArexxMsgPort,A0 : JSR _WaitPort(A6)
;      MOVEA.l struct_ArexxMsgPort,A0 : JSR _GetMsg(A6)
;      MOVEA.l struct_RexxMsg,A0
;      MOVE.l #$0,$28(A0)
;    JL_0_E192:
;
;    MOVEA.l struct_ArexxMsgPort,A1 : JSR _RemPort(A6)
;    MOVEA.l struct_ArexxMsgPort,A0 : JSR _DeleteMsgPort(A6)
;    CLR.l struct_ArexxMsgPort
;
;  exit_closearexxport:
;RTS

.free_RexxMsg:
  MOVEM.l D1/A0-A1/A6,-(A7)
  MOVEA.l _execbase,A6
  MOVEA.l D0,A1
  MOVE.l #MinByteSgnd,D0
  JSR _FreeMem(A6)

  MOVEM.l (A7)+,D1/A0-A1/A6
RTS

.init_RexxMsg_bas:
  ; init RexxMsg
  DEFTYPE.RexxMsg rexxMsg
  rexxMsg\rm_Node\mn_Node\ln_Type   = 5
  rexxMsg\rm_Node\mn_Node\ln_Pri    = 1
  rexxMsg\rm_Node\mn_Node\ln_Name   = &ArexxPortName$
  rexxMsg\rm_Node\mn_Length         = $80
  rexxMsg\rm_Node\mn_ReplyPort      = *ArexxMsgPort
  rexxMsg\rm_Action                 = $1060000
Return


.init_RexxMsg:
  CLR.l struct_RexxMsg
  MOVEA.l _execbase,A6
  MOVE.l #$10000,D1
  MOVE.l #MinByteSgnd,D0
  JSR _AllocMem(A6)

  MOVEA.l D0,A1
  TST.l d0
  BEQ.w JL_0_E21E                       ; set bits in RexxMsg
    MOVE.b #$5,$8(A1)                   ; rm_Node\ln_Type
    MOVE.b #$1,$9(A1)                   ; rm_Node\ln_Pri
    MOVE.l #str_Arexx_PortName,$A(A1)   ; rm_Node\ln_Name
    MOVE.w #$0080,$12(A1)               ; rm_Node\mn_Length
    MOVE.l struct_ArexxMsgPort,$E(A1)   ; rm_Node\*mn_ReplyPort
    MOVE.l #$1060000,$1C(A1)            ; rm_Action
    MOVE.l A1,D0
    MOVE.l D0,struct_RexxMsg
  JL_0_E21E:
RTS

.arexx_send_closewindow:
  MOVE.l #str_CLOSEWINDOW,ptr_own_arexxcommand
  LEA str_own_arexx_message,A0
  JSR arexx_sendmessage
RTS

.arexx_send_quitplease:
  LEA str_own_arexx_message,A0
  MOVEQ.l #$1F,D1
  JL_0_E23A:
    TST.l (A0)
    BNE.w JL_0_E246
  DBF D1,JL_0_E23A
  RTS
  JL_0_E246:

  MOVE.l #str_QUITPLEASE,ptr_own_arexxcommand
  LEA str_own_arexx_message,A0
  JSR arexx_sendmessage
  LEA str_own_arexx_message,A0
  MOVEQ.l #$1F,D1
  JL_0_E25E:
    CLR.l (A0)+
  DBF D1,JL_0_E25E
RTS

.arexx_send_openwindow:
  MOVE.l #str_OPENWINDOW,ptr_own_arexxcommand
  LEA str_own_arexx_message,A0
  JSR arexx_sendmessage
RTS

.arexx_sendmessage:
  ; A0: Stringpointer with AREXX-COMMAND
  MOVEM.l D0-D2/A0-A1/A6,-(A7)
  ; -- bis ans ende des Strings gehen
  MOVEQ.l #$1F,D1
  JL_0_E2B8:
    MOVE.l (A0)+,D2
    BNE.w JL_0_E2C6
  DBF D1,JL_0_E2B8
  BRA.w exit_sendmessage

  JL_0_E2C6:
  MOVEM.l D1/A0,-(A7)
  JSR init_RexxMsg
  MOVE.l D0,ptr_own_ArexxMsg
  MOVEA.l D0,A1
  MOVE.l ptr_own_arexxcommand,$28(A1)
  MOVEM.l D1/A1,-(A7)

  MOVEA.l D2,A1
  MOVEA.l _execbase,A6
  JSR _FindPort(A6)     ; A0 : Portname
  MOVEM.l (A7)+,D1/A1

  TST.l D0
  BEQ.w no_port_found

    MOVEA.l D0,A0
    JSR _PutMsg(A6)
    JL_0_E2FC:
      MOVEA.l struct_ArexxMsgPort,A0
      JSR _WaitPort(A6)

      MOVEA.l struct_ArexxMsgPort,A0
      JSR _GetMsg(A6)

      CMP.l ptr_own_ArexxMsg,D0
       BEQ.w no_port_found
      MOVEA.l D0,A0
      MOVE.l $A(A0),ptr_arexx_sendername
      MOVEA.l A0,A1
      MOVE.l $28(A1),ptr_arexx_commandstr
      CMPI.b #$7,$8(A0)
       BNE.w JL_0_E33E
      JSR free_RexxMsg
    BRA.b JL_0_E2FC

    JL_0_E33E:
    MOVEA.l A0,A1
    JSR _ReplyMsg(A6)
    BRA.b JL_0_E2FC

    no_port_found:
    MOVE.l struct_RexxMsg,D0
    JSR free_RexxMsg
    MOVEM.l (A7)+,D1/A0
  DBF D1,JL_0_E2B8

  exit_sendmessage:
  MOVEM.l (A7)+,D0-D2/A0-A1/A6
RTS

.clear_arexxtable:
;  MOVEA.l _execbase,A6
  MOVEA.l arexx_table,A1
  !newfree
RTS

ptr_own_arexxcommand:        Ds.l 1
ptr_own_ArexxMsg:            Ds.l 4
struct_RexxMsg:              Ds.l 1
arexxport_available:         Ds.l 1
struct_ArexxMsgPort:         Ds.l 1
;ptr_arexxport:               Ds.l 1
rexx_signalbits:             Ds.w 1
arexx_number_of_parameters:  Ds.w 1
checked_arexxcmd:            Ds.w 1
ptr_arexx_sendername:        Ds.l 1
ptr_arexx_commandstr:        Ds.l 1
ptr_arexx_currsourceline:    Ds.l 1
str_libname_rexxsyslib:      Dc.b "rexxsyslib.library",0,0
_rexxsyslibbase:             Ds.l 1

str_REXX:                    Dc.b "REXX",0,0
str_CLOSEWINDOW:             Dc.b "CLOSEWINDOW",0
str_OPENWINDOW:              Dc.b "OPENWINDOW",0,0
str_QUITPLEASE:              Dc.b "QUITPLEASE",0,0
str_DOCLISTCHANGED:          Dc.b "DOCLISTCHANGED",0,0
str_DOCNUMCHANGED:           Dc.b "DOCNUMCHANGED",0
str_own_arexx_message:       Ds.l 32
str_arexx_message_doclist:   Ds.l 32



; --
; -- Arexx-Command, pointer to function:
; --
ptr_arexxcmd_list:
 Dc.l AL_0_E66C
 Dc.l arexxfunc_runexe             ;runfunc
 Dc.l AL_0_E57C
 Dc.l arexxfunc_compilerun         ;compilefunc
 Dc.l AL_0_E600
 Dc.l arexxfunc_prevsource         ;prevdoc
 Dc.l AL_0_E608
 Dc.l arexxfunc_nextsource         ;nextdoc
 Dc.l AL_0_E6B6
 Dc.l arexxfunc_cut                ;cut
 Dc.l AL_0_E6BA
 Dc.l arexxfunc_copy               ;copy
 Dc.l AL_0_E6C0
 Dc.l arexxfunc_paste              ;paste
 Dc.l AL_0_E63C
 Dc.l arexxfunc_load               ;load file
 Dc.l AL_0_E636
 Dc.l arexxfunc_quit               ;quit
 Dc.l AL_0_E642
 Dc.l arexxfunc_loadnew            ;loadnew
 Dc.l AL_0_E64A
 Dc.l arexxfunc_save               ;save
 Dc.l AL_0_E632
 Dc.l arexxfunc_new                ;new
 Dc.l AL_0_E650
 Dc.l arexxfunc_print              ;print
 Dc.l AL_0_E61C
 Dc.l arexxfunc_erase              ;erase
 Dc.l AL_0_E6A4
 Dc.l arexxfunc_doclist            ;doclist
 Dc.l AL_0_E5BC
 Dc.l arexxfunc_topline            ;topline
 Dc.l AL_0_E5C4
 Dc.l arexxfunc_bottomline         ;bottomline
 Dc.l AL_0_E5E0
 Dc.l arexxfunc_nextline           ;nextline
 Dc.l AL_0_E5D0
 Dc.l arexxfunc_getline            ;getline
 Dc.l AL_0_E5F6
 Dc.l arexxfunc_prevline           ;prevline
 Dc.l AL_0_E5EA
 Dc.l arexxfunc_screentoback       ;hidescreen
 Dc.l AL_0_E5D8
 Dc.l arexxfunc_redraw             ;redraw
 Dc.l AL_0_E610
 Dc.l arexxfunc_screenname         ;screenname
 Dc.l AL_0_E59C
 Dc.l arexxfunc_iconify            ;iconify
 Dc.l AL_0_E670
 Dc.l arexxfunc_notifynewdoc       ;notifynewdoc
 Dc.l AL_0_E67E
 Dc.l arexxfunc_dontnotifynewdoc   ;dontnotifynewdoc
 Dc.l AL_0_E690
 Dc.l arexxfunc_getdoclist         ;getdoclist
 Dc.l AL_0_E584
 Dc.l arexxfunc_screentofront      ;showscreen
 Dc.l AL_0_E574
 Dc.l arexxfunc_getword
 Dc.l AL_0_E622
 Dc.l arexxfunc_help               ;help
 Dc.l AL_0_E628
 Dc.l arexxfunc_helptext           ;helptext
 Dc.l AL_0_E6D0
 Dc.l arexxfunc_activate           ;activate
 Dc.l AL_0_E69C
 Dc.l arexx_gotodoc                ;gotodoc
 Dc.l AL_0_E6AC
 Dc.l arexxfunc_getdocnum          ;getdocnum
 Dc.l AL_0_E656
 Dc.l arexxfunc_rememberme         ;rememberme
 Dc.l AL_0_E662
 Dc.l arexxfunc_forgetme           ;forgetme
 Dc.l AL_0_E5A4
 Dc.l arexxfunc_about              ;about
 Dc.l AL_0_E5B4
 Dc.l arexxfunc_version            ;version
 Dc.l AL_0_E5AA
 Dc.l arexxfunc_numlines           ;numlines
 Dc.l AL_0_E590
 Dc.l rebuild_menus                ;reloadmenus
 Dc.l AL_0_E6F2
 Dc.l arexxfunc_makeexec           ;makeexec
 Ds.l 4

 ; --
 ; -- arexx-commandlabels
 ; --
 AL_0_E574:  Dc.b "GETWORD",0
 AL_0_E57C:  Dc.b "COMPILE",0
 AL_0_E584:  Dc.b "SHOWSCREEN",0,0
 AL_0_E590:  Dc.b "RELOADMENUS",0
 AL_0_E59C:  Dc.b "ICONIFY",0
 AL_0_E5A4:  Dc.b "ABOUT",0
 AL_0_E5AA:  Dc.b "NUMLINES",0,0
 AL_0_E5B4:  Dc.b "VERSION",0
 AL_0_E5BC:  Dc.b "TOPLINE",0
 AL_0_E5C4:  Dc.b "BOTTOMLINE",0,0
 AL_0_E5D0:  Dc.b "GETLINE",0
 AL_0_E5D8:  Dc.b "REDRAW",0,0
 AL_0_E5E0:  Dc.b "NEXTLINE",0,0
 AL_0_E5EA:  Dc.b "HIDESCREEN",0,0
 AL_0_E5F6:  Dc.b "PREVLINE",0,0
 AL_0_E600:  Dc.b "PREVDOC",0
 AL_0_E608:  Dc.b "NEXTDOC",0
 AL_0_E610:  Dc.b "SCREENNAME",0,0
 AL_0_E61C:  Dc.b "ERASE",0
 AL_0_E622:  Dc.b "HELP",0,0
 AL_0_E628:  Dc.b "HELPTEXT",0,0
 AL_0_E632:  Dc.b "NEW",0
 AL_0_E636:  Dc.b "QUIT",0,0
 AL_0_E63C:  Dc.b "LOAD",0,0
 AL_0_E642:  Dc.b "LOADNEW",0
 AL_0_E64A:  Dc.b "SAVE",0,0
 AL_0_E650:  Dc.b "PRINT",0
 AL_0_E656:  Dc.b "REMEMBERME",0,0
 AL_0_E662:  Dc.b "FORGETME",0,0
 AL_0_E66C:  Dc.b "RUN",0
 AL_0_E670:  Dc.b "NOTIFYNEWDOC",0,0
 AL_0_E67E:  Dc.b "DONTNOTIFYNEWDOC",0,0
 AL_0_E690:  Dc.b "GETDOCLIST",0,0
 AL_0_E69C:  Dc.b "GOTODOC",0
 AL_0_E6A4:  Dc.b "DOCLIST",0
 AL_0_E6AC:  Dc.b "GETDOCNUM",0
 AL_0_E6B6:  Dc.b "CUT",0
 AL_0_E6BA:  Dc.b "COPY",0,0
 AL_0_E6C0:  Dc.b "PASTE",0
 AL_0_E6D0:  Dc.b "ACTIVATE",0,0
 AL_0_E6F2:  Dc.b "MAKEEXEC",0,0


; --
; -- funtions to be executed by appropriate arexx-command
; --
.arexxfunc_activate:
  !basic
  If Peek.l(?ptr_sourcewindow)
    ActivateWindow_ Peek.l(?ptr_sourcewindow)
  EndIf
  !asm
  MOVEQ.l #$00,D0
  SUBA.l A0,A0
RTS

.arexxfunc_rememberme:
  LEA str_own_arexx_message,A0
  MOVEQ.l #$1F,D0
  JL_0_E832:
    TST.l (A0)+
    BEQ.w JL_0_E842
  DBF D0,JL_0_E832
  MOVEQ.l #$00,D0
  SUBA.l A0,A0
  RTS

  JL_0_E842:
  MOVE.l ptr_arexx_sendername,-(A0)
  MOVEQ.l #$00,D0
  SUBA.l A0,A0
RTS

.arexxfunc_forgetme:
  LEA str_own_arexx_message,A0
  MOVE.l ptr_arexx_sendername,D0
  MOVEQ.l #$1F,D1
  JL_0_E85A:
    CMP.l (A0)+,D0
     BEQ.w JL_0_E868
  DBF D1,JL_0_E85A
  BRA.w JL_0_E86A

  JL_0_E868:
  CLR.l -(A0)

  JL_0_E86A:
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_iconify:
  SUBA.l A0,A0
  MOVEQ.l #$01,D0
  JSR arexx_answer_message
  JSR menu_iconify
  ST checked_arexxcmd
  MOVEQ.l #$00,D7
RTS

.arexxfunc_doclist:
  JSR menu_project
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_getdocnum:
  MOVEA.l _execbase,A6
  MOVEA.l struct_RexxMsg,A1
  JSR _ReplyMsg(A6)
  ST checked_arexxcmd
  MOVEQ.l #$00,D7
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

JL_0_E8B2:
  MOVEA.l ptr_tempstring,A0
  MOVE.l #$30000000,(A0)
  MOVEQ.l #$00,D0
RTS

JL_0_E8C2:
  MOVEM.l D1-D7/A1-A6,-(A7)
  MOVEA.l actualfile,A1
  MOVEA.l loadedfilesbase,A0
  MOVEQ.l #$00,D0

  JL_0_E8D4:
    CMPA.l A0,A1
     BEQ.w JL_0_E8E6
    MOVEA.l (A0),A0
    ADDQ.l #1,D0
    CMPA.l #$0,A0
  BNE.b JL_0_E8D4

  JL_0_E8E6:
  MOVEA.l ptr_tempstring,A0
  CLR.l (A0)
  CLR.l $4(A0)
  JSR format_value
  MOVEM.l (A7)+,D1-D7/A1-A6
  MOVEQ.l #$00,D0
  MOVEA.l ptr_tempstring,A0
RTS

.arexx_gotodoc:
  MOVEA.l loadedfilesbase,A0
  TST.l D0
  BEQ.w JL_0_E918
    JL_0_E912:
      MOVEA.l (A0),A0
      SUBQ.l #1,D0
    BNE.b JL_0_E912
  JL_0_E918:
  MOVE.l A0,D0
  CMP.l actualfile,D0
  BEQ.w JL_0_E92A
    JSR selectfile
  JL_0_E92A:

  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_getdoclist:
  JSR StoreXtraData
  MOVE.l loadedfilesbase,D0
  MOVEA.l ptr_tempstring,A0
  JSR generate_tempfilename
  MOVEA.l ptr_tempstring,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_cut:
  JSR menu_cut
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_copy:
  JSR menu_copy
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_paste:
  JSR menu_paste
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_notifynewdoc:
  LEA str_arexx_message_doclist,A0
  MOVEQ.l #$1F,D0

  JL_0_EA44:
    TST.l (A0)+
    BEQ.w JL_0_EA54
  DBF D0,JL_0_EA44
  MOVEQ.l #$00,D0
  SUBA.l A0,A0
  RTS

  JL_0_EA54:
  MOVE.l ptr_arexx_sendername,-(A0)
  MOVEQ.l #$00,D0
  SUBA.l A0,A0
RTS

.arexxfunc_dontnotifynewdoc:
  LEA str_arexx_message_doclist,A0
  MOVE.l ptr_arexx_sendername,D0
  MOVEQ.l #$1F,D1

  JL_0_EA6C:
  CMP.l (A0)+,D0
   BEQ.w JL_0_EA7A
   DBF D1,JL_0_EA6C
 BRA.w JL_0_EA7C

  JL_0_EA7A:
  CLR.l -(A0)
  JL_0_EA7C:
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_erase:
  SF checked_arexxcmd
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
  JSR arexx_answer_message
  ST checked_arexxcmd
  MOVEQ.l #$65,D6
  MOVEQ.l #-$02,D7
RTS

.arexxfunc_quit:
  SF checked_arexxcmd
  SUBA.l A0,A0
  MOVEQ.l #$01,D0
  JSR arexx_answer_message
  ST checked_arexxcmd
  MOVEQ.l #$73,D6
  MOVEQ.l #-$02,D7
RTS

.arexxfunc_new:
  JSR menu_opennew
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_loadnew:
  CMPI.w #$2,arexx_number_of_parameters
  BNE.w JL_0_EAF2
    SUBA.l A0,A0
    MOVEQ.l #$00,D0
    JSR arexx_answer_message
    ST checked_arexxcmd
    JSR menu_opennew
    MOVE.l arexx_parameterlist,D7
    JSR load_source
    MOVEQ.l #$00,D7
    RTS
  JL_0_EAF2:
    SUBA.l A0,A0
    MOVEQ.l #$00,D0
    JSR arexx_answer_message
    ST checked_arexxcmd
    JSR menu_opennew
    JSR menu_load
    MOVEQ.l #$00,D7
RTS

.arexxfunc_load:
  CMPI.w #$2,arexx_number_of_parameters
  BNE.w JL_0_EB3A
    SUBA.l A0,A0
    MOVEQ.l #$00,D0
    JSR arexx_answer_message
    ST checked_arexxcmd
    MOVE.l arexx_parameterlist,D7
    JSR load_source
    MOVEQ.l #$00,D7
    RTS
  JL_0_EB3A:
    SUBA.l A0,A0
    MOVEQ.l #$00,D0
    JSR arexx_answer_message
    ST checked_arexxcmd
    JSR menu_load
    MOVEQ.l #$00,D7
RTS

.arexxfunc_save:
  SF AL_0_1162
  JSR menu_save
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_print:
  JSR menu_print
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_prevsource:
  JSR menu_previousfile
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_nextsource:
  JSR menu_nextfile
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_screenname:
  LEA str_defaultpubscreen,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_redraw:
  JSR _redraw
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_about:
  JSR menu_about
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_numlines:
  MOVEQ.l #$00,D0
  MOVE.l comLong_TotalLines,D0
  LEA L_0_EF02,A0
  JSR format_value
  LEA L_0_EF02,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_version:
  LEA str_pedname,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_topline:
  MOVE.l comPtr_FirstSourceLine,ptr_arexx_currsourceline
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_bottomline:
  MOVE.l comPtr_LastSourceLine,ptr_arexx_currsourceline
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_nextline:
  MOVEA.l ptr_arexx_currsourceline,A0
  CMPA.l #$0,A0
  BEQ.w JL_0_EC0A
    TST.l (A0)
    BEQ.w JL_0_EC0A
      MOVEA.l (A0),A0
      MOVE.l A0,ptr_arexx_currsourceline
      SUBA.l A0,A0
  JL_0_EC0A:
  MOVEQ.l #$00,D0
RTS

.arexxfunc_screentoback:
  !basic
  ScreenToBack_ sourceWindow\pedScreen
  !asm
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_screentofront:
  !basic
  ScreenToFront_ sourceWindow\pedScreen
  !asm
  SUBA.l A0,A0
  MOVEQ.l #$00,D0
RTS

.arexxfunc_getline:
  MOVEA.l ptr_arexx_currsourceline,A0
  CMPA.l #$0,A0
  BEQ.w JL_0_EC60
    LEA $9(A0),A0
    MOVEA.l ptr_tempstring,A1
    JSR detokenize_line
    MOVEA.l ptr_tempstring,A0
    MOVEQ.l #$00,D0
    ;!basic
    ;!cout{Hex$(Peek.l(?ptr_tempstring)),Peek$(Peek.l(?ptr_tempstring))}
    ;!asm
    RTS
  JL_0_EC60:
    MOVEQ.l #$05,D0
RTS

.arexxfunc_prevline:
  MOVEA.l ptr_arexx_currsourceline,A0
  CMPA.l #$0,A0
  BEQ.w JL_0_EC88
  TST.l $4(A0)
  BEQ.w JL_0_EC88
  MOVEA.l $4(A0),A0
  MOVE.l A0,ptr_arexx_currsourceline
  SUBA.l A0,A0

  JL_0_EC88:
  MOVEQ.l #$00,D0
  RTS

  JL_0_EC8C:
RTS

.getwordnodetoke  ;a0  = cursor pos
  MOVEA.l ptr_tempstring,A1
  JSR JL_0_ECD6
  MOVEA.l ptr_tempstring,A0
  MOVE.w replacestartcolumn,d0
  ;SUBQ.w #1,d0
  MOVE.w d0,comWord_Column
  CLR.w comWord_ColumnsOffset
  MOVEQ.l #$00,D0
RTS

.arexxfunc_getword:
  MOVEA.l ptr_tempstring,A1
  JSR JL_0_ECA2
  MOVEA.l ptr_tempstring,A0
  MOVEQ.l #$00,D0
RTS

  JL_0_ECA2:
  CLR.b macro_
  MOVEA.l comPtr_CurrentSourceLine,A0
  LEA $9(A0),A0
  MOVE.l A1,-(A7)
  MOVEA.l expandstore,A1
  MOVEQ #120/4,d0
 'lo
    CLR.l (a1)+
  DBF d0,'lo

  MOVEA.l expandstore,A1
  JSR detokenize_line
  MOVEA.l expandstore,A0
  MOVE.l (A7)+,A1
  MOVEQ.l #$00,D1
  MOVE.w comWord_Column,D1
  ADD.w comWord_ColumnsOffset,D1
  ;SUBQ.w #1,D1
  ADDA.l D1,A0

  JL_0_ECD6:
    TST.w D1
     BMI.w JL_0_ED14
    MOVE.b (A0),D0
    CMP.b #"!",d0
    BNE 'l1
    MOVE.b #1,macro_
   'l1
    CMP.b #"_",d0
     BEQ JL_0_ED0E
    CMP.b #"z",D0
     BGT.w JL_0_ED14
    CMP.b #"a",D0
     BGE.w JL_0_ED0E
    CMP.b #"Z",D0
     BGT.w JL_0_ED14
    CMP.b #"A",D0
     BGE.w JL_0_ED0E
    CMP.b #"9",D0
     BGT.w JL_0_ED14
    CMP.b #"0",D0
     BLT.w JL_0_ED14

    JL_0_ED0E:
    SUBQ.l #1,A0
    SUBQ.w #1,D1
  BRA.b JL_0_ECD6

  JL_0_ED14:
  ADDQ.l #1,a0
  MOVE.w d1,replacestartcolumn

  JL_0_ED14b:
    MOVE.b (A0)+,D0
    ;CMP.b #$20,d0
    ;BEQ JL_0_ED46
    CMP.b #"{",d0
    BEQ JL_0_ED46
    CMP.b #"_",d0
    BEQ JL_0_ED48
    CMP.b #"z",D0
     BGT.w JL_0_ED46
    CMP.b #"a",D0
     BGE.w JL_0_ED48
    CMP.b #"Z",D0
     BGT.w JL_0_ED46
    CMP.b #"A",D0
     BGE.w JL_0_ED48
    CMP.b #"9",D0
     BGT.w JL_0_ED46
    CMP.b #"0",D0
     BGE.w JL_0_ED48

    JL_0_ED46:
    MOVEQ.l #$00,D0

    JL_0_ED48:
    MOVE.b D0,(A1)+
  TST.b D0
  BNE.b JL_0_ED14b
RTS


.getstring_new2
  *textline.l = TEDGetCurrentLine{} + 9
  *detokened.l = TEDDetoke{*textline}
  text$ = Peek$(*detokened)
  cursorpos.w = Peek.w(?comWord_Column)
  actualword$ = preproc_CropToken{*PreProcessor,text$,cursorpos}
RTS

.getstring_new
  *textline.l = TEDGetCurrentLine{} + 9
  *detokened.l = TEDDetoke{*textline}
  text$ = Peek$(*detokened)
  cursorpos.w = Peek.w(?comWord_Column)+1
  aword$ = "" : char$ =""
  tlen = FLen(text$)
  nextpos.w = cursorpos
  backpos.w = cursorpos - 1
  Repeat
    aword$ = char$ + aword$
    char$ = Mid$(text$,backpos,1)
    backpos - 1
  Until (char$=" ") OR (char$="(") OR (char$=")") OR (char$="{") OR (char$=Chr$(34)) OR (char$ = "{") OR (char$="}") OR (char$=",") OR (backpos<0)
  char$ = ""

  Repeat
    aword$ = aword$ + char$
    char$ = Mid$(text$,nextpos,1)
    nextpos + 1
  Until (char$=" ") OR (char$=")") OR (char$="(") OR (char$="}") OR (char$=Chr$(34)) OR (char$ = "{") OR (char$="}") OR (char$=",") OR (nextpos>(tlen+1))
  actualword$ = aword$
RTS

.getstring:
  MOVEA.l ptr_tempstring,A1
  MOVEA.l comPtr_CurrentSourceLine,A0
  LEA $9(A0),A0
  MOVE.l A1,-(A7)
  MOVEA.l expandstore,A1
  MOVEQ #120/4,d0
 'lo
    CLR.l (a1)+
  DBF d0,'lo

  MOVEA.l expandstore,A1
  JSR detokenize_line
  MOVEA.l expandstore,A0
  MOVE.l (A7)+,A1
  MOVEQ.l #$00,D1
  MOVE.w comWord_Column,D1
  ADD.w comWord_ColumnsOffset,D1
  ;SUBQ.w #1,D1
  ADDA.l D1,A0
 'l1
  MOVE.b (a0),d0
  CMP.b #$22,d0
  BEQ 'x1
  SUBQ.l #1,A0
  SUBQ.w #1,D1
  TST.w d1
  BNE 'l1
 'x1
  MOVEA.l ptr_tempstring,A1
  ADDQ.l #1,a0
 'l2
    MOVE.b (a0)+,d0
    BEQ 'x2
    CMP.b #$22,d0
    BEQ 'x2
    MOVE.b d0,(a1)+
  BRA 'l2
 'x2
  CLR.b (a1)+
  MOVEA.l ptr_tempstring,A0
  MOVEQ.l #$00,D0
RTS



.arexxfunc_compilerun:
  SUBA.l     A0,A0
  MOVEQ.l    #$01,D0
  JSR        arexx_answer_message
  ST         checked_arexxcmd

  MOVEM.l    D2-D7/A1-A6,-(A7)
  MOVEQ.l    ##MENU_COMPILERUN,D6             ; replaced with the constant  tomsmart1
  JSR        call_compilermenuitem
  MOVEM.l    (A7)+,D2-D7/A1-A6
RTS

.arexxfunc_runexe:
  SUBA.l     A0,A0
  MOVEQ.l    #$01,D0
  BSR.w      arexx_answer_message
  ST         checked_arexxcmd
  MOVEM.l    D2-D7/A1-A6,-(A7)
  MOVEQ.l    ##MENU_RUN,D6                    ; replaced with the constant  tomsmart1
  JSR        call_compilermenuitem
  MOVEM.l    (A7)+,D2-D7/A1-A6
RTS


.arexxfunc_makeexec:
  SUBA.l     A0,A0
  MOVEQ.l    #$01,D0
  BSR.w      arexx_answer_message
  ST         checked_arexxcmd
  MOVEM.l    D2-D7/A1-A6,-(A7)
  MOVEQ.l    ##MENU_CREATEEXE,D6
  JSR        call_compilermenuitem
  MOVEM.l    (A7)+,D2-D7/A1-A6
RTS



.arexxfunc_help:
  MOVEM.l    A0-A4,-(A7)
  MOVEA.l    comPtr_CurrentSourceLine,A4
  ; -- not implemented
  MOVEM.l    (A7)+,A0-A4
  MOVEQ.l    #$00,D0
  SUBA.l     A0,A0
RTS

.arexxfunc_helptext:
  MOVEM.l    A0-A4,-(A7)
  MOVE.w     comWord_DoTokenize,D0
  BEQ.w      JL_0_EE70
  MOVEA.l    comPtr_CurrentSourceLine,A4
  LEA        $9(A4),A4
  MOVE.w     comWord_ColumnsOffset,D3
  ADD.w      comWord_Column,D3
  MOVEQ.l    #$00,D1
  MOVEQ.l    #$00,D2

  JL_0_EE10:
  MOVEQ.l    #$00,D0
  MOVE.b     (A4)+,D0
  MOVE.b     (A4)+,D0
  BEQ.w      JL_0_EE3E
  BPL.w      JL_0_EE38
  LSL.w      #8,D0
  MOVE.b     (A4)+,D0
;  MOVE.w     D0,AL_0_4658
  JSR        token_to_ascii
  MOVE.l     A3,D1

  JL_0_EE2E:
  ADDQ.w     #1,D2
  TST.b      (A3)+
  BNE.b      JL_0_EE2E
  MOVEA.l    A3,A2
  SUBQ.w     #2,D2

  JL_0_EE38:
  ADDQ.w     #1,D2
  CMP.w      D3,D2
  BLS.b      JL_0_EE10

  JL_0_EE3E:
  TST.l      D1
  BEQ.w      JL_0_EE70
  MOVEA.l    D1,A0
  MOVEA.l    ptr_tempstring,A1

  JL_0_EE4C:
  MOVE.b     (A0)+,(A1)+
  BNE.b      JL_0_EE4C
  SUBQ.w     #1,A1
  CMPI.b     #$28,(A2)
  BEQ.w      JL_0_EE5E
  MOVE.b     #$20,(A1)+

  JL_0_EE5E:
  MOVE.b     (A2)+,(A1)+
  BNE.b      JL_0_EE5E
  MOVEM.l    (A7)+,A0-A4
  MOVEQ.l    #$00,D0
  MOVEA.l    ptr_tempstring,A0
RTS

JL_0_EE70:
  SUBA.l     A0,A0
  MOVEQ.l    #$00,D0
RTS

.rebuild_menus:
  !basic
  Gosub init_menus
  !asm
  SUBA.l  A0,A0
  MOVEQ.l #$00,D0
RTS


arexx_table:        Ds.l 1
arexx_parameterlist:Ds.l 15
L_0_EF02:           Ds.w 7

.arexx_count_parameters:
  MOVEA.l struct_RexxMsg,A1
  LEA $28(A1),A0              ; string: AREXX-Command
  LEA arexx_table,A1
  MOVEQ.l #$00,D6

  JL_0_EF20:
    CMP.b #$10,D6
    BEQ.w exit_counting

    JL_0_EF28:
    MOVEA.l (A0)+,A2
    CMPA.l #$0,A2
    BEQ.w exit_counting

    JL_0_EF34:
    MOVEA.l (A1)+,A3
    MOVE.b (A2)+,D1
  BEQ.b JL_0_EF20

  CMP.b #$22,D1
  BEQ.w JL_0_EF74
    CMP.b #$27,D1
    BEQ.w JL_0_EF60
      ADDQ.w #1,D6
      MOVE.b D1,(A3)+
      JL_0_EF4E:
        MOVE.b (A2)+,D0
        CLR.b (A3)
        TST.b D0
        BEQ.b JL_0_EF28
          CMP.b #$20,D0
          BEQ.b JL_0_EF34
            MOVE.b D0,(A3)+
      BRA.b JL_0_EF4E
    JL_0_EF60:
    ADDQ.w #1,D6

    JL_0_EF62:
      MOVE.b (A2)+,D0
      CLR.b (A3)
      TST.b D0
      BEQ.b JL_0_EF28
        CMP.b #$22,D0
        BEQ.b JL_0_EF34
          MOVE.b D0,(A3)+
    BRA.b JL_0_EF62
  JL_0_EF74:

  ADDQ.w #1,D6

  JL_0_EF76:
    MOVE.b (A2)+,D0
    CLR.b (A3)
    TST.b D0
    BEQ.b JL_0_EF28
      CMP.b #$22,D0
      BEQ.b JL_0_EF34
        MOVE.b D0,(A3)+
  BRA.b JL_0_EF76

  exit_counting:
  MOVE.w D6,arexx_number_of_parameters
RTS

.menu_print:
  !basic
  Gosub set_pointer_busy_bas
  LockAllOpenWZWin{}
  If Peek.l(Addr Window(WZID("WIN_PRINT")))=0
    WZWindow WZID("WIN_PRINT"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_PRINT")
    Use Window WZID("WIN_PRINT")
    exit_print.b = False

    Repeat
      ev.l = WaitEvent
      Select ev

        Case #IDCMP_CLOSEWINDOW
          exit_print = True

        Case #IDCMP_IDCMPUPDATE
          Select WZGadName

            Case "PRINT_CANCEL"
              exit_print = True

            Case "PRINT_PRINT"
              Poke.s ?str_printerdevice,WZGetString("PRINT_DEVICE")
              !asm
              JSR printout_source
              !basic
              exit_print = True

          End Select

      End Select
    Until exit_print = True

    WZCloseWindow WZID("WIN_PRINT")
  EndIf
  UnlockAllOpenWZWin{}
  Gosub set_pointer_normal_bas
  Gosub activatesourcewindow
  !asm
  !setregsformenuexit
RTS

.printout_source:
  !basic
  *prthandle.l = Open_ (Peek$(?str_printerdevice),#HUNK_RELOC_8__MODE_NEWFILE)
  If *prthandle = 0
    Pop If
    error{"Couldnot open Printer."}
    !asm
    RTS
  EndIf
  GetD0 *prthandle
  !asm
  MOVE.l d0,d7  ; prthandle

  ;MOVE.l #str_printerdevice,D1
  ;MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  ;MOVEA.l _dosbase,A6
  ;JSR _Open(A6)
  ;MOVE.l D0,D7
  ;BEQ.w JL_0_F5F4

  CLR.b instring
  MOVE.l comLong_TotalLines,D6
  MOVEA.l comPtr_FirstSourceLine,A4

  JL_0_F58E:
    MOVEA.l comPtr_Temp_TokenString1,A0
    LEA $9(A4),A1
    MOVE.l A0,D2

    JL_0_F598:                        ;print code
      MOVE.b (A1)+,(A0)+
      BEQ.w JL_0_F5D8
      CMP.b #$22,-1(a0)
      BNE 'l1
      NOT.b instring
     'l1
      TST.b -1(a0)
      BPL.b JL_0_F598
      TST.b instring
      BNE JL_0_F598
     'l2
      MOVE.b -(A0),D0
      LSL.w #8,D0
      MOVE.b (A1)+,D0
      MOVE.b #$1B,(A0)+
      MOVE.b #"[",(A0)+
      MOVE.b #"1",(A0)+
      MOVE.b #"m",(A0)+
      JSR token_to_ascii

      JL_0_F5BC:
      MOVE.b (A3)+,(A0)+
      BNE.b JL_0_F5BC
      MOVE.b #$1B,-$1(A0)
      MOVE.b #"[",(A0)+
      MOVE.b #"2",(A0)+
      MOVE.b #"2",(A0)+
      MOVE.b #"m",(A0)+
    BRA.b JL_0_F598

    JL_0_F5D8:
    MOVE.b #$A,-$1(A0)
    MOVE.l A0,D3
    SUB.l D2,D3
    !regs2stack
    MOVE.l D3,-(a7)
    MOVE.l D2,-(a7)
    !basic
    MOVE.l (a7)+,d0 : *pbuffer.l = PutD0
    MOVE.l (a7)+,d0 : plength.l = PutD0
    Write_ *prthandle, *pbuffer, plength
    !asm
    !stack2regs
    ;JSR _Write(A6)
    ; write_ (d1:buffer, d2:buffer, d3:length)
    MOVEA.l (A4),A4
    SUBQ.l #1,D6
  BNE.b JL_0_F58E

  !basic
  Close_ *prthandle
  !asm
  ;MOVE.l D7,D1
  ;JSR _Close(A6)
  ;JL_0_F5F4:
RTS


.call_pluginmenuentry:
  MOVE.l d6,-(a7)
  !basic
  MOVE.l (a7)+,D0 : id_menuitem.l = PutD0                  ; changed because MenuEditor and CustomMenuItems have now it own ID  tomsmart1
  If id_menuitem = #MENU_CUSTOMEDIT
    Gosub open_menueditor
    Gosub init_menus
  Else
    id_menuitem - #MENU_CUSTOMITEM1                        ; to get the correct CostumMenu entry  tomsmart 1
    If id_menuitem >= 0
      ResetList custommenu()
      menuentry = 0
      While id_menuitem >= menuentry                       ; changed to get the correct entry  tomsmart1
        dummy = NextItem(custommenu())
        menuentry + 1
      Wend
      If custommenu()\path <> ""
        If custommenu()\runwbmode = False
          dos_RunCli{custommenu()\path,custommenu()\prio,custommenu()\stacksize,False}
        Else
          dos_RunWB{custommenu()\path}
        EndIf
      EndIf
    EndIf
  EndIf
  !asm
  !setregsformenuexit
RTS


.update_menueditorgadgets                                  ; moved to subroutine to remove double code tomsmart1
    WZPrint "MENUED_ITEMNAME",custommenu()\itemname
    WZPrint "MENUED_STACK"   ,custommenu()\stacksize
    WZPrint "MENUED_PRIO"    ,custommenu()\prio
    If custommenu()\runwbmode = 1
      WZPrint "MENUED_RUNMODE",On
      WZDisable "MENUED_STACK" : WZDisable "MENUED_PRIO"
    Else
      WZPrint "MENUED_RUNMODE",Off
      WZEnable "MENUED_STACK" : WZEnable "MENUED_PRIO"
    EndIf
    WZEnable "MENUED_DEL" : WZEnable "MENUED_SORT"
    WZEnable "MENUED_RUNMODE"
    WZEnable "MENUED_PATH"
Return

.disable_menueditorgadgets                                 ; moved to subroutine to remove double code tomsmart1
    WZPrint "MENUED_ITEMNAME",""
    WZPrint "MENUED_STACK"   ,8192
    WZPrint "MENUED_PRIO"    ,-1
    WZPrint "MENUED_RUNMODE" ,Off
    WZDisable "MENUED_DEL"   : WZDisable "MENUED_SORT"
    WZDisable "MENUED_STACK" : WZDisable "MENUED_PRIO"
    WZDisable "MENUED_RUNMODE"
    WZDisable "MENUED_PATH"
Return

.open_menueditor
  Gosub set_pointer_busy_bas
  LockAllOpenWZWin{}
  If NOT WZ_CheckOpen{"WIN_MENUED"}
    WZWindow WZID("WIN_MENUED"),?wzgui,255,-2,-2,-2,-2,WZID("WIN_MENUED")
  End If
  DEFTYPE.List menuedlist
  ; -- get all the defined menuentries
  If FirstItem(custommenu())                               ; test if we have a (first) entry in the list
    item_counter.b = 0
    Repeat
      WZListAdd menuedlist,custommenu()\itemname,-2
      item_counter+1
    Until NOT NextItem(custommenu())
    WZPrint "MENUED_LIST",0,menuedlist                     ; merged two IF-Thens to one and that fixed Hits if ther are no entrys in the list  tomsmart1
    item_counter = 0
    dummy = FirstItem(custommenu())                        ; back to entry 1 to set the status gadgets
    Gosub update_menueditorgadgets
  Else
    Gosub disable_menueditorgadgets
  EndIf
  menued_exit.b = False

;event_menueditor
  Repeat
    menued_ev.l = WaitEvent

    If RawKeyState(#RAWKEY_ESC) Then menued_ev = #IDCMP_CLOSEWINDOW

    Select menued_ev
      Case #IDCMP_CLOSEWINDOW
        menued_exit = True
      Case #IDCMP_IDCMPUPDATE
        Select WZGadName
          Case "MENUED_ADD"
            ResetList custommenu()
            If AddLast (custommenu())
                WZListAdd menuedlist,"",-2
                custommenu()\itemname = ""
                custommenu()\path     = ""
                custommenu()\runwbmode = False
                custommenu()\stacksize = 8192
                custommenu()\prio = -1
            EndIf
            item_counter = WZListItems (menuedlist)-1
            WZPrint "MENUED_LIST",item_counter,menuedlist,0 ; neue Position in der Liste anspringen und Liste erneuern ; changed that the selection get not lost  tomsmart1
            dummy.l = LastItem(custommenu())
            Gosub update_menueditorgadgets
            WZDisable "MENUED_SAVE"                         ; added to only allow 1 new entry to prevent empty entrys  tomsmart1
            WZDisable "MENUED_ADD"
            WZDisable "MENUED_SORT"
            WZDisable "MENUED_LIST"

          Case "MENUED_DEL"
            ResetList custommenu()
            item_counter = 0
            While (item_counter < WZListNum ("MENUED_LIST")) AND NextItem(custommenu())
              item_counter + 1
            Wend
            If item_counter = WZListNum ("MENUED_LIST")
              KillItem custommenu()
              WZListRemove menuedlist,WZListNum ("MENUED_LIST")
              WZPrint "MENUED_LIST",0,menuedlist,0
            EndIf
            If FirstItem(custommenu())
              Gosub update_menueditorgadgets
            Else
              Gosub disable_menueditorgadgets
            EndIf
            WZEnable "MENUED_SAVE"
            WZEnable "MENUED_ADD"                          ; added to only allow 1 new entry to prevent empty entrys  tomsmart1
            WZEnable "MENUED_LIST"

          Case "MENUED_SORT"
            If FirstItem(custommenu())                     ; merged If-Thens to one  tomsmart1

              StringSort custommenu(),SizeOf.custommenu    ; command changed to fix sorting  tomsmart1

              WZListRemove menuedlist
              dummy = FirstItem(custommenu())
              Repeat
                WZListAdd menuedlist,custommenu()\itemname,-2
              Until NOT NextItem (custommenu())

              WZPrint "MENUED_LIST",0,menuedlist,0
              dummy = FirstItem(custommenu())              ; back to entry 1 to set the status gadgets
              Gosub update_menueditorgadgets
              WZEnable "MENUED_SAVE"
            Else
              Gosub disable_menueditorgadgets
            EndIf


          Case "MENUED_LIST"
            item_counter = 0
            ResetList custommenu()
            While (item_counter < WZListNum ("MENUED_LIST")) AND NextItem(custommenu())
              item_counter + 1
            Wend
            If item_counter = WZListNum ("MENUED_LIST")
              Gosub update_menueditorgadgets
            Else
              Gosub disable_menueditorgadgets
            EndIf

          Case "MENUED_PATH"
            aslfr_SetRequesterTitle {0,!TRANS{"Select a Programm"},"Ok","Cancel"}
            ; replaced to set always a vaild path  tomsmart1
            If custommenu()\path <> ""
              aslfr_SetPath {0,dos_PathPart{custommenu()\path},dos_FilePart{custommenu()\path} }
            Else
              aslfr_SetPath {0,default_assign$,""}
            EndIf
            If aslfr_Request {0,False,False,False}
              custommenu()\path = aslfr_GetNextFile{}
              If custommenu()\path <>""
                custommenu()\itemname = dos_FilePart{custommenu()\path}
                WZPrint "MENUED_ITEMNAME",custommenu()\itemname

                WZListRemove menuedlist
                ResetList custommenu()
                While NextItem (custommenu())
                  WZListAdd menuedlist,custommenu()\itemname,-2
                Wend

                WZPrint "MENUED_LIST",item_counter,menuedlist,0  ; changed that the selection get not lost  tomsmart1
                WZEnable "MENUED_SAVE"
                WZEnable "MENUED_ADD"                            ; added to only allow 1 new entry to prevent empty entrys  tomsmart1
                WZEnable "MENUED_SORT"
                WZEnable "MENUED_LIST"
              EndIf
            EndIf

          Case "MENUED_STACK"
            stacksize.l = WZInput
            custommenu()\stacksize = stacksize
            If custommenu()\itemname<>"" Then WZEnable "MENUED_SAVE"  ; changed to prevent empty entrys  tomsmart1

          Case "MENUED_PRIO"
            prio.l = WZInput
            custommenu()\prio = prio
            If custommenu()\itemname<>"" Then WZEnable "MENUED_SAVE"  ; changed to prevent empty entrys  tomsmart1

          Case "MENUED_RUNMODE"
            checked.l = WZInput
            If checked = 1
              custommenu()\runwbmode = 1
              WZDisable "MENUED_STACK" : WZDisable "MENUED_PRIO"
            Else
              custommenu()\runwbmode = False
              WZEnable "MENUED_STACK" : WZEnable "MENUED_PRIO"
            EndIf
            If custommenu()\itemname<>"" Then WZEnable "MENUED_SAVE"  ; changed to prevent empty entrys  tomsmart1

          Case "MENUED_SAVE"
            ; removed code to fix Hits if entrys are deleted  tomsmart1
            fid.l = file_Open{pedmenufile$,#file_forcewrite}
            If fid >= 0
              If FirstItem(custommenu())
                Repeat
                  file_WriteLine{fid,custommenu()\itemname+",~,0,"+custommenu()\path+","+Str$(custommenu()\runwbmode)+","+Str$(custommenu()\stacksize)+","+Str$(custommenu()\prio)}
                Until NOT NextItem(custommenu())
              EndIf
            EndIf
            file_Close{fid}
            WZDisable "MENUED_SAVE"

          Case "MENUED_EXIT" : menued_exit = True
        End Select
    End Select
  Until menued_exit = True

  FlushEvents
  WZListRemove menuedlist
  WZCloseWindow WZID("WIN_MENUED")
  UnlockAllOpenWZWin{}
  Gosub set_pointer_normal_bas
Return


init_sourceline:
  MOVEA.l D0,A0
  CLR.l (A0)
  CLR.l $4(A0)
  MOVE.b D5,$8(A0)
RTS

.reset_currentLine
  MOVEQ #0,d0
  TST.l 4(a4)             ; previousline available ?
  BEQ 'l20
 'l10:
    MOVE.l 4(a4),a4
    ADDQ.l #1,d0
    TST.l 4(a4)
  BNE 'l10

  'l20:
RTS

.prev_currsourceline
  TST.l 4(a4)
  BEQ 'l20
  MOVE.l 4(a4),a4
  MOVE.l a4,d0
  RTS

 'l20
  MOVEQ #0,d0
RTS


.jump_addhistory         ;d0 linenum
  MOVEM.l a0/d0-d1,-(a7)
  LEA history,a0
  MOVEQ #0,d1
  MOVE.w historypointer,d1
  MOVE.l comLong_DisplayLineOffset,d0
  ADD.l comLong_DisplayLine,d0
  MOVE.l d0,0(a0,d1)
  ADDQ.w #4,d1
  CMP.w  #maxhistory,d1
  BLE 'nowrap
    MOVEQ #0,d1
 'nowrap:
  MOVE.w d1,historypointer
  MOVEM.l (a7)+,a0/d0-d1
RTS

.jump_historyup
  MOVE.l a1,-(a7)
  JSR storeline
  LEA history,a0
  MOVE.w historypointer,d1
  SUBQ #4,d1
  BPL 'l10
  MOVEQ #maxhistory,d1
 'l10
  MOVE.w d1,historypointer
  MOVE.l 0(a0,d1.w),d0
  JSR jumpline
  MOVE.l (a7)+,a1
RTS

.jump_historydown
  MOVE.l a1,-(a7)
  JSR storeline
  LEA history,a0
  MOVE.w historypointer,d1
  ADDQ #4,d1
  CMP.w #maxhistory,d1
  BLE 'l10
  MOVEQ #0,d1
 'l10
  MOVE.w d1,historypointer
  MOVE.l 0(a0,d1.w),d0
  JSR jumpline
  MOVE.l (a7)+,a1
RTS

.jump_onclick:
  !regs2stack
  !basic
  *currLine.sourceLine = Peek.l(?comPtr_CurrentSourceLine)
  *detokened.l = TEDDetoke{*currLine + 9}
  strline$ = Peek$(*detokened)
  If Instr(strline$,"{") > 0 Then statement_in_line.b = True

  actualword$ = PED_GetWordAtPos{strline$, Peek.w(?comWord_Column)}
  actualword_len.w = Len(actualword$)
  If actualword_len < 2
    Pop If
    !asm
    !stack2regs
    RTS
  EndIf

  clickjump_fromfile.b = 0
  jump_search:
  log_Print{"search for <" + actualword$ + ">"}
  ;-- go to firstline
  *tempLine = *currLine
  While *tempLine\previousLine
    *tempLine = *tempLine\previousLine
    ;*detokened = TEDDetoke{*tempLine + 9}
    ;log_Print{">>" + Peek$(*detokened)}
  Wend

  linecounter.l = 0 : found_definition.b = False
  Repeat
    ;log_Print{Hex$(*currLine) + " " + Hex$(*tempLine) + "  " + Str$(linecounter + 1)}

    If *tempLine = *currLine
      ;log_Print{"skipping actual line <" + Str$(linecounter+1)+">"}
    Else
      found_definition = False
      ;*detokened = TEDDetoke{*tempLine + 9}
      ;log_Print{Peek$(*detokened)}
      strline$ = Trim$(Peek$(*tempLine + 9))

      ; check if it is the definition of a Statement/Function/Macro, we skip it!
      tokenID.l = Peek.w(&strline$) AND $FFFF
      Select tokenID
      Case #TOKEN_Statement : found_definition = True
      Case #TOKEN_Function : found_definition = True
      Case #TOKEN_Macro : found_definition = True
      End Select
      If found_definition Then strline$ = UnRight$(strline$,2)

      ; search for clicked word
      found_at.w = Instr(strline$, actualword$)
      If found_at > 0
        ;log_Print{"found_at: " + Str$(found_at) + " in line" + Str$(linecounter+1) + ":" + strline$}
        If statement_in_line AND NOT found_definition Then Goto skip_jump
        If found_at>1 Then char_before$ = Mid$(strline$,found_at-1,1)
        char_after$ = Mid$(strline$,found_at + actualword_len,1)
        ;log_Print{"after <" + char_after$ + ">" + Str$(linecounter+1) + "  "  +strline$}
        If CheckChr{char_after$, ":;{"} OR (char_before$=".")
          log_Print{"<"+actualword$ + "> in Zeile <" + Str$(linecounter + 1) + "> gefunden, jump!"}
          Pop Repeat : Pop If : Pop If : Pop If : Pop If
          GetD0 linecounter
          !asm
          JSR jump_addhistory
          JSR jumpline
          !stack2regs
          RTS
        EndIf
        skip_jump:
      EndIf
    EndIf
    linecounter + 1
    *tempLine = *tempLine\nextLine
  Until *tempLine = 0

  ;-- nothing found in current source search in helpcache
  If clickjump_fromfile = 0
    clickjump_fromfile = 1
    Gosub set_pointer_busy_bas

    ;-- searching in HelpIndexFile for macro or function name
    found_in_cache.b = False
    If actualword$ <> ""
      log_Print{"not found in current source, searching in helpcache for <" + actualword$ + ">"}
      ResetList HelpIndexCache()
      While NextItemFast(HelpIndexCache()) AND found_in_cache = False
        If actualword$ = HelpIndexCache()\name OR actualword$ = HelpIndexCache()\includefile
          found_in_cache = True
        End If
      Wend

      If found_in_cache
        temp_filename$ = dos_AddPart{includedir$, HelpIndexCache()\includefile}
        log_Print{"found in HelpIndexCache(), will open it:" + temp_filename$}
        GetD0 &temp_filename$
        !asm
        JSR loadfile
        JSR update_vertscroller
        JSR update_statusarea
        !basic
        *currLine = Peek.l(?comPtr_CurrentSourceLine)
        ;-- jump upwards and search again in file ...
        Goto jump_search
      Else
        log_Print{"not found in cache"}
      EndIf
    EndIf
  EndIf
  Gosub set_pointer_normal_bas
  !asm
  !stack2regs
RTS


.jumpline     ; D0: Zielzeile
  CMP.l comLong_TotalLines,d0
  BGE 'ret
    MOVEA.l comPtr_CurrentSourceLine,A4
    JSR cursor_off
    CLR.w comWord_Column
    CLR.w comWord_ColumnsOffset
    JSR gotoline
    JSR update_vertscroller
 'ret:
RTS


.diag_help                ;ctr help
  MOVE.l a0,d0
  !basic
  Gosub open_helpdiag
  !asm
RTS


.open_helpdiag
  If diag.l = 0
    WZWindow WZID("WIN_HELPDIAG"),?wzgui,80,wtemp\diag_x,wtemp\diag_y,wtemp\diag_w,wtemp\diag_h,WZID("WIN_HELPDIAG")
    AddedMenu2WZWin{"WIN_HELPDIAG"}
    diag = 1
  End If
  Gosub diag_redraw
Return


.diag_redraw
  If diag = 0 Then Return
  ;Gosub getactualword
  Gosub getstring_new2   ; getstring_new2 should be better (uses preprocessor)
  w$ = actualword$
  tokname$ = actualword$
  res$ = ""
  MOVE.l comPtr_TokenBase,token@(a5)
  While token.l
    b$ = Peek$(token+6)
    If b$ = w$
      res$ = Peek$(token+7+Len(b$))
      i = Instr(res$,";")
      If i Then res$ = Left$(res$,i)
    End If
    token = Peek.l(token)
  Wend
  If res$ = ""
    MOVE.l comPtr_MacroBase,a0:MOVE.l (a0),token@(a5)
    c.l = 0
    While token
      b$ = Peek$(token+13)
      If b$ = w$
        i = Peek.w(token+8)
        If i>100 Then i = 100
        res$ = Peeks$(Peek.l(token+4),i)
        res$ = Replace$(res$,";","")
        i = Instr(res$,"}")
        If i Then res$ = Left$(res$,i)
      End If
      token = Peek.l(token)
    Wend
  End If
  addcodesize.l = 0:linesize.l = 0
  If res$<>""
       Use Window WZID("WIN_HELPDIAG")
       tokname$ + "   " + res$
       WZPrint "DIAG_TOKEN",&tokname$
       InitArgParse res$
       For i =  1 To 12
       diag_lab$(i) = NextArgChar$ (@",")
       If diag_lab$(i) = "[" Then i = i-1:diag_lab$(i)+"["
       WZPrint "lab"+UStr$(i),&diag_lab$(i)
       diag_val$(i) = ""
       WZPrint "val"+UStr$(i),&diag_val$(i)
       Next
       linesize.l = 0
       MOVEA.l textbufferaddr,A0
       ADDA.w comWord_TextBufferOffset,A0
       MOVE.l a0,a1
       ADD.w comWord_MaxColumns,a1
       SUBQ.l #1,a1
's2    CMP.b #" ",(a1)
       BNE 's1
       SUBQ.l #1,a1
       CMP.l a0,a1
       BNE 's2
's1    SUB.l a0,a1
       MOVE.l a1,d1
       MOVE.l d1,linesize@(a5)
       ;MOVE.l comPtr_CurrentSourceLine,a0
       ;LEA 9(a0),a0
       MOVE.w comWord_Column,d0
       BEQ 'l3
'l1    CMP.b #" ",0(a0,d0)
       BEQ 'l2
       CMP.b #"{",0(a0,d0)
       BEQ 'l2
       TST.b 0(a0,d0)
       BMI 'l3
       ADDQ.w #1,d0
       BNE 'l1
'l3    ADDQ.w #1,d0
       CMP.b #":",0(a0,d0)
       BEQ 'q
       CMP.b #";",0(a0,d0)
       BEQ 'q
       CMP.w d1,d0
       BEQ 'q
       CMP.b #" ",0(a0,d0)
       BEQ 'l2
       CMP.b #"(",0(a0,d0)
       BEQ 'l2
       CMP.b #"{",0(a0,d0)
       BEQ 'l2
       BRA 'l3
'q     RTS
'l2    ADD.l d0,a0
       MOVE.l #MAX_Columns,d0
       SUB.w comWord_Column,d0
       SUBQ.l #1,d0
'la1   CMP.b #$20,(a0)+
       BNE 'la2
       SUBQ.l #1,d0
       BNE 'la1
'la3   CMP.b #$20,-(a0)
       BEQ 'la3
       ADDQ.l #3,a0
'la2   MOVE.l a0,d0
       addcodepos.l = PutD0-1
       MOVE.l addcodepos@(a5),a0
       SUBQ #2,a0
       SUB.l textbufferaddr,A0
       SUB.w comWord_TextBufferOffset,A0
       MOVE.l a0,d0
       SUB.l d0,linesize@(a5)
       If linesize >1 Then linesize-1
       If linesize >0 Then res$ = Peeks$(addcodepos,linesize):Else res$ = ""
       i.l = 0:i2.l = 0
       Repeat
       w.l = PeekUB(&res$+i)
       If w = $22 Then i2 BitChg 0
       If i2 = 0
          If w>$80 Then Poke.b &res$+i,w BitClr 7
          If w = @";" OR w = @":" Then w = 0:
       End If
       i+1
       Until w = 0
       addcodesize.l = i
       addstr$ = ""
       If i Then res$ = Left$(res$,i-1)
       If Peek.b (&res$) = @"(" Then res$ = Right$(res$,Len(res$)-1):addstr$ = "("
       If Peek.b (&res$) = @"{" Then res$ = Right$(res$,Len(res$)-1):addstr$ = "{"
nopeek:  InitArgParse res$
       For i = 1 To 12
       diag_val$(i) = NextArgChar$(@",","{[(\\22",")]}\\22")
       If diag_lab$(i)<>"" Then WZPrint "val"+UStr$(i),&diag_val$(i)
       Next
 EndIf
RTS


.help_checkfortype:
  MOVE.w comWord_Column,d1
  MOVE.w d1,columnstore
  SUBQ.w #2,d1
  BGT 'w1
  MOVEQ #1,d1
 'w1
  MOVE.l textbufferaddr,a0
  ADD.w comWord_TextBufferOffset,a0
  MOVE.l a0,a1
  SUBQ.l #1,a1
  ADD.w comWord_Column,a0
  CMP.b #"\",-1(a0)
  BEQ typehelp1
  CMP.b #"\",(a0)
  BEQ typehelp2
;  BRA notypehelp
  RTS

  typehelp1:
  SUBQ #1,a0
  typehelp2:
  CMP.b #$20,-(a0)
  BNE 't2b
  CMP.l a0,a1
  BNE typehelp2
 't2b
  CMP.b #")",(a0)
  BNE 't2
 'rb
  CMP.b #"(",-(a0)
  BEQ 't2c
  CMP.l a0,a1
  BNE 'rb
 't2c
  SUBQ.l #1,a0
 't2
  CMP.b #"_",(a0)
  BEQ 'ok
  CMP.b #$30,(a0)
  BLT 'path
  CMP.b #":",(a0)
  BLT 'p2
  CMP.b #"A",(a0)
  BLT 'path
 'p2
  CMP.b #"z",(a0)
  BGT 'path
 'ok
  MOVEQ #0,d0
  LEA chartab,a1
  ADDQ.l #1,a0
 'x1
    MOVE.b -(a0),d0
    TST.b 0(a1,d0)
    BNE 'x
  BRA 'x1
 'x
  CMP.b #"*",d0
  BEQ 'x1
  CMP.b #".",d0
  BNE 't1
  MOVE.w d1,comWord_Column
  BSR arexxfunc_getword
  MOVE.w columnstore,comWord_Column
  BRA typehelp
 't1
  MOVE.l a2,-(a7)
  LEA typestr,a2
  ADDQ.l #1,a0
 'x111
    MOVE.b (a0)+,d0
    TST.b 0(a1,d0)
    BNE 'xc
   'x12
    MOVE.b d0,(a2)+
  BRA 'x111
 'xc
  CMP.b #"*",d0
  BEQ 'x12
  CLR.b (a2)
  MOVE.l comPtr_CurrentSourceLine,a0
  JSR gettype
  TST.l d0
  BNE 'found
  JSR findvar
 'found
  MOVE.l (a7)+,a2
  LEA typestr,a0
  BRA typehelp
 'path
  MOVE.l comPtr_CurrentSourceLine,a0
 'nl2
  MOVE.l 4(a0),d0
;  BEQ notypehelp
  RTS

  MOVE.l d0,a0
  LEA 9(a0),a1
 'l1
    MOVE.b (a1)+,d0
    BEQ 'nl
    CMP.b #$80,d0
    BNE 'l1
    MOVE.b (a1)+,d0
    CMP.b #$ca,d0            ;find usepath
  BNE 'l1
 'u1
    CMP.b #$20,(a1)+
  BEQ 'u1
  MOVE.l a2,-(a7)
  MOVE.l a0,-(a7)
  LEA typestr,a0
  LEA chartab,a2
  MOVEQ #0,d0
  SUBQ.l #1,a1
 'n2
    MOVE.b (a1)+,d0
    CMP.b #"*",d0
    BEQ 'do2
      TST.b 0(a2,d0)
      BNE 'n1
   'do2
    MOVE.b d0,(a0)+
  BRA 'n2
 'n1
  CLR.b (a0)+
  MOVE.l (a7)+,a0

  JSR gettype
  TST.l d0
  BNE 'found2
    JSR findvar
 'found2
  MOVE.l (a7)+,a2
  LEA typestr,a0
  BRA typehelp
 'nl
  BRA 'nl2
  ;  BRA notypehelp
  RTS

  gettype:
  MOVEM.l a0-a1,-(a7)
  LEA typestr,a2
 'nl2
  MOVE.l 4(a0),d0
  BEQ 'exit
  CLR.b deftypefound
  MOVE.l d0,a0
  LEA 9(a0),a1
 'l1
  MOVE.b (a1)+,d0
  BEQ 'nl
  CMP.b #$80,d0
  BNE 'notok
  MOVE.b (a1)+,d0
  CMP.b #$33,d0            ;find deftype
  BNE 'notok
  MOVE.b #1,deftypefound
 'notok
  CMP.b (a2),d0
  BNE 'l1
  MOVE.l a1,d1
  SUB.l #10,d1
  SUB.l a0,d1
  BEQ 'bg1
  CMP.b #",",-2(a1)
  BEQ 'bg1
  CMP.b #" ",-2(a1)
  BNE 'l1
 'bg1
  ADDQ.l #1,a2
 'l2
  MOVE.b (a2)+,d0
  BEQ 'f1
  CMP.b (a1)+,d0
  BEQ 'l2
  LEA typestr,a2
  BRA 'l1
 'f1
 'r1
  CMP.b #$20,(a1)+
  BEQ 'r1

  SUBQ.l #1,a1
  TST.b deftypefound
  BEQ 'nod
    LEA 9(a0),a1
   'lop
      MOVE.b (a1)+,d0
      BEQ 'nl
    CMP.b #".",d0
    BNE 'lop
    SUBQ.l #1,a1
 'nod
  CMP.b #".",(a1)+
  BEQ 'c1
    LEA typestr,a2
    BRA 'l1
 'c1
  LEA typestr,a2
  LEA chartab,a0
  MOVEQ #0,d0
 'loop
    MOVE.b (a1)+,d0
    TST.b 0(a0,d0)
    BNE 'e1
      MOVE.b d0,(a2)+
  BRA 'loop
 'e1
  CLR.b (a2)+
  MOVEM.l (a7)+,a0-a1
  MOVEQ #1,d0
  RTS

 'nl
  BRA 'nl2
 'exit
  MOVEM.l (a7)+,a0-a1
  MOVEQ #0,d0
RTS

;.notypehelp
.help_checkforif:
  actline.l   = ?comPtr_CurrentSourceLine
  nestcount.b = 1
  Repeat
    iffound.b = 0
    *textline.l = Peek.l(actline) + 9

    ; kill any spaces before Token
    testaddr.l = Peek.l(*textline) : bytecount = 0
    While (testaddr LSR 16) <> $0000
      testaddr = Peek.l(*textline + bytecount)
      actword.w = testaddr LSR 16

      ; check the token for parts of an if-loop
      Select actword
      Case #TOKEN_EndIf    ; EndIf
        nestcount + 1

;      Case #TOKEN_End    ; End
;        nestcount + 1

      Case #TOKEN_If    ; If
        nestcount - 1
        iffound  = 1

      Case #TOKEN_Then    ; Then
        nestcount + 1
      End Select

;      !cout{nestcount, Hex$(testaddr),linestr$}
      bytecount + 1
    Wend
    If (nestcount = 1) Then Pop Repeat : Goto foundif

    ; get previous line pointer
    actline.l = Peek.l(actline) + 4
  Until Peek.l(actline) = 0
  foundif:
  If (iffound = 1)
    *detokened.l = TEDDetoke{*textline}
    ;*detokened.l = TEDDetoke_(*textline)
    linestr$ = StripLead$(Peek$(*detokened),31)
    SetScreenTitle{"Corresponding Header: " + linestr$}
  EndIf
Return

.close_bubblehelp
  If WZ_CheckOpen{"WIN_CONTEXTHELP"}
    WZListRemove helpme.List
    WZCloseWindow WZID("WIN_CONTEXTHELP")
  EndIf
RTS


.close_popupwindow
  If use_intellisense
    WZ_PopUpCloseNonmodal{}   ; move the code to the new include function  tomsmart1
    popup_selected.l = 0
  EndIf
RTS


.findvar
  !basic
  MOVE.l comPtr_VarBase,d0
  BEQ 'oldped
  MOVE.l d0,a0
  CMP.l #0,(a0)
  BEQ 'oldped
  *nt.l = PutD0:*nt = Peek.l(*nt):
  fvar$ = Peek$(?typestr)
  fvar$ = StripLead$(fvar$,@"*")
  While *nt
    a$ = Peek$(*nt+$13)
    If a$ = fvar$
      it.l = Peek.l(*nt+10)
      If it
        Poke$ ?typestr,Peek$(it+$b)
      End If
    End If
    *nt = Peek.l(*nt)
  Wend
 'oldped
  !asm
RTS

.typehelp
  MOVE.l a0,d0
  !basic
  i = PutD0
  str2$ = Peek$(i)
  a$ = str2$
  If NOT WZ_CheckOpen{"WIN_NEWTYPE"}
    USEPATH wtemp
    WZWindow WZID("WIN_NEWTYPE"),?wzgui,255,\type_x,\type_y,\type_w,\type_h,WZID("WIN_NEWTYPE")
    AddedMenu2WZWin{"WIN_NEWTYPE"}
    ;GTSetMenuChecked 0,5,9,On
    MOVE.l comPtr_VarBase,d0
    BEQ 'oldped
    MOVE.l d0,a0
    CMP.l #0,(a0)
    BNE 'nocompile
    WTitle "Compile the file to see all"
    'nocompile
    'oldped
    Gosub activatesourcewindow
  End If
  Use Window WZID("WIN_NEWTYPE")
  WZPrint "STRING2",&str2$
  WZPrint "newtype_const",0
  WZPrint "newtype_var",0
  WZPrint "newtype_struct",1
  newtype_mode = 2

  lev.l = 0
  find.l = 0
  Gosub newtype_selecttype
  lev = 1
  MOVE.l newtypebase,d0
  *nt.l = PutD0
  If *nt
    *nt = Peek.l(*nt):
    While *nt
      b$ = Peek$(*nt+11)
      If b$ = a$:
        quicktype = 1:Gosub newtype_listsubtype:find = 1:Pop If:Goto f1ab
      End If
      *nt = Peek.l(*nt)
    Wend
  EndIf
  quicktype = 0
  f1ab:
  !asm
RTS

.open_librarybrowser:
  If NOT WZ_CheckOpen{"WIN_LIBRARYBROWSER"}
    WZWindow WZID("WIN_LIBRARYBROWSER"),?wzgui,255,\lbrowser_x,\lbrowser_y,\lbrowser_w,\lbrowser_h,WZID("WIN_LIBRARYBROWSER")
    AddedMenu2WZWin{"WIN_LIBRARYBROWSER"}
  EndIf
    Use Window WZID("WIN_LIBRARYBROWSER")
    WZ_InitTable{"WIN_LIBRARYBROWSER","FUNCTIONSTABLE",2}
    WZ_SetTableTitle{"FUNCTIONSTABLE","Function","Syntax"};,"Library"}
    WZ_SetPriority{"FUNCTIONSTABLE",2,3}
    WZ_DrawTable{"FUNCTIONSTABLE"}
    Gosub update_librarylist
    Gosub update_functiontable
;  Else
;    Use Window WZID("WIN_LIBRARYBROWSER")
    Activate WZID("WIN_LIBRARYBROWSER")
    WZ_UpdateTable{"FUNCTIONSTABLE"}
;  End If
Return


.event_librarybrowser:
  If RawKeyState(#RAWKEY_TAB) Then Gosub activatesourcewindow : ev = 0       ;  TAB Key hit
  If RawKeyState(#RAWKEY_ESC) Then ev = #IDCMP_CLOSEWINDOW

; swaped the Select functions to remove the undefind situation of the Tableevent if the the window get closed this remove the Hits i had  tomsmart1

  ; check for events occured with the functiontable
  wev.l = WZ_CheckTableEvent{ev}
  Select wev

    Case #WZTABLEEVENT_CELLSELECTED
      pos.l = WZ_Row{"FUNCTIONSTABLE"}
      actualword$ = WZ_GetCell{"FUNCTIONSTABLE",WZ_Row{"FUNCTIONSTABLE"},1}
      If actualword$<>""
        libinfo$ = lib_mapping$(libnumber.l,0)+" (LibNr. "+Str$(libnumber)+" Token "+Hexw$(PED_GetTokenID{*tokenbase,actualword$}) +")"
        WZPrint "ARGS_LIBRARYNAME",&libinfo$
      EndIf

    Case #WZTABLEEVENT_DOUBLECLICK
      pos = WZ_Row{"FUNCTIONSTABLE"}
      actualword$ = WZ_GetCell{"FUNCTIONSTABLE",WZ_Row{"FUNCTIONSTABLE"},1}
      If actualword$<>""
        Gosub instructionbrowser_startguide
      EndIf

  End Select

  Select ev
    Case #IDCMP_IDCMPUPDATE
      Select WZGadName

        Case "LIST_LIBRARIES"
          Gosub update_functiontable

        Case "CYCLE_SORTORDER"
          Gosub update_librarylist
          Gosub update_functiontable

        Case "BUTTON_LIB_FREEIDS"
          message$ = !TRANS{"The following lib-IDs are not in use:"}+"\\n\\n"
          For i = 1 To (#Max_BlitzLibs-1)             ; replaced hardcoded 255 with (#Max_BlitzLibs-1) because we start with 0  tomsmart1
            If Instr(lib_mapping$(i,0),"unused")<>0
              message$ + Str$(i)+ "  "
            EndIf
          Next i
          WZ_LockWindow{"WIN_LIBRARYBROWSER"}
          dummy.l = ask{message$,!TRANS{"Ok"},!TRANS{"Info"}}
          WZ_UnlockWindow{"WIN_LIBRARYBROWSER"}

        Case "BUTTON_LIB_CHECK_CONSISTENCY"
          WZ_LockWindow{"WIN_LIBRARYBROWSER"}
          WZ_ShowMessage{!TRANS{"Checking BlitzLib consistency..."},1}
          message$ = ""
          For i = 0 To (#Max_BlitzLibs-1) : lib_check(i)=False : Next i      ; replaced hardcoded 255 with (#Max_BlitzLibs-1) because we start with 0  tomsmart1
          *tpointer.l = *tokenbase               ; replaced  Peek.l(?comPtr_TokenBase)  tomsmart1 2012 06 16
;          fid = file_Open{"ram:tokenlist.csv",#file_forcewrite}
          Repeat
            tokeninfo\next_token = Peek.l(*tpointer)
            tokeninfo\number     = Peek.w(*tpointer+4)
            tokeninfo\name       = Peek$(*tpointer+6)
            tokeninfo\help       = Peek$(*tpointer+6+FLen(tokeninfo\name)+1)
            libID.l = (tokeninfo\number LSR 7)

            If libID.l<>olibID.l
              If lib_check(libID) = False
                lib_check(libID) = True
;                If fid<>-1 Then file_WriteLine{fid,LSet$(lib_mapping$(libID),30)+";"+LSet$(tokeninfo\name,30)+";"+Str$(tokeninfo\number)}
              Else
                For i = 0 To (#Max_BlitzLibs-1)       ; replaced hardcoded 255 with (#Max_BlitzLibs-1) because we start with 0  tomsmart1
                  If lib_mapping$(i,1) = tokeninfo\name
                    old_libname$ = StripTrail$(UnRight$(lib_mapping$(i,0),Instr(lib_mapping$(libID,0),"with ")+4),Asc(")"))
                    Pop If : Pop For : Goto exit_for2
                  EndIf
                Next i
                exit_for2:
                error_libname$ = Left$(lib_mapping$(libID,0),Instr(lib_mapping$(libID,0)," ")-1)
                message$ + "+ " + old_libname$ + " has been overwritten by\\n"
                message$ + "\\22" + error_libname$ + "\\22 with same LibID: "+Str$(libID)+"\\n\\n"
              EndIf
              olibID = libID
              !WZ_GaugeInfo{&lib_mapping$(libID,0)}
            EndIf
            *tpointer.l = tokeninfo\next_token
          Until (*tpointer = 0)

;          file_Close{fid}
          WZ_HideMessage{}
          If message$=""
            message$ = !TRANS{"The internal library structure seems to be correct."}
          EndIf
          dummy.l = ask{message$,!TRANS{"Ok"},!TRANS{"Info"}}
          WZ_UnlockWindow{"WIN_LIBRARYBROWSER"}

      End Select

    Case #IDCMP_CLOSEWINDOW:
      WZ_KillTable{"FUNCTIONSTABLE"}
      CloseWZWinWithMenu{"WIN_LIBRARYBROWSER"}
      WZListRemove libslist.List

  End Select

Return


.update_librarylist:
  sortorder.b = WZInput("CYCLE_SORTORDER")
  WZListRemove libslist.List
  Format "000"
  For i = 0 To (#Max_BlitzLibs-1)                     ; replaced hardcodes 255 with (#Max_BlitzLibs-1) because we start with 0  tomsmart1
    If Instr(lib_mapping$(i,0),"unused") = 0
      If sortorder = 0
        WZListAdd libslist.List,lib_mapping$(i,0),-1,i
      Else
        WZListAdd libslist.List,Str$(i)+ " | "+ lib_mapping$(i,0),-1,i
      EndIf
    EndIf
  Next i
  Format ""
  WZPrint "LIST_LIBRARIES",0,libslist
Return


.update_functiontable:
  selected.l = WZInput("LIST_LIBRARIES")
  libnumber = WZListData(libslist,selected)
  libinfo$ = lib_mapping$(libnumber,0)+" (LibNr. "+Str$(libnumber)+")"

  WZPrint "ARGS_LIBRARYNAME",&libinfo$

  WZ_ClearTable{"FUNCTIONSTABLE"}

  If *tokenbase<>0
    *tpointer.l = *tokenbase : tfound.b = False : tcounter.l = 0 : tname$ = ""
    Repeat
      tokeninfo\next_token = Peek.l(*tpointer)
      tokeninfo\number     = Peek.w(*tpointer+4)
      tokeninfo\name       = Peek$(*tpointer+6)
      tokeninfo\help       = Peek$(*tpointer+6+FLen(tokeninfo\name)+1)

      If (tokeninfo\number LSR 7) = libnumber
        WZ_AddRow{"FUNCTIONSTABLE",tokeninfo\name,tokeninfo\help}
      EndIf
      *tpointer.l = tokeninfo\next_token : tcounter + 1
    Until (*tpointer = 0)
  EndIf
  WZ_TableSort{"FUNCTIONSTABLE",1}
  WZ_UpdateTable{"FUNCTIONSTABLE"}
Return


.open_instructionbrowser
  Gosub close_popupwindow
  If NOT WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"} ; thilo: why this was commented out!?
    WZWindow WZID("WIN_INSTRUCTIONBROWSER"),?wzgui,255,wtemp\ibrowser_x,wtemp\ibrowser_y,wtemp\ibrowser_w,wtemp\ibrowser_h,WZID("WIN_INSTRUCTIONBROWSER")
    AddedMenu2WZWin{"WIN_INSTRUCTIONBROWSER"}
    If search_instruction$<>"" Then WZPrint "INSTRUCTION_STRING",search_instruction$
    WZPrint "macros",browse_macros
    WZPrint "instr",browse_instructions
    WZPrint "incdir",browse_includes
    WZ_InitTable{"WIN_INSTRUCTIONBROWSER","INSTRUCTIONTABLE",2}
    WZ_SetTableTitle{"INSTRUCTIONTABLE","Function","Syntax"};,"Library"}
    WZ_SetPriority{"INSTRUCTIONTABLE",2,3}
    WZ_DrawTable{"INSTRUCTIONTABLE"}
    previoussearch_instruction$="|"
    Gosub update_instructiontable
  Else
    Use Window WZID("WIN_INSTRUCTIONBROWSER")
    Activate WZID("WIN_INSTRUCTIONBROWSER")
    WZ_UpdateTable{"INSTRUCTIONTABLE"}
    WZPrint "INSTRUCTION_STRING",search_instruction$
  End If
  ActivateWZGadget{"INSTRUCTION_STRING"}
RTS


.event_instructionbrowser
  If RawKeyState(#RAWKEY_TAB) Then Gosub activatesourcewindow : ev = 0
  If RawKeyState(#RAWKEY_ESC) Then ev = #IDCMP_CLOSEWINDOW

; swaped the Select functions to remove the undefind situation of the Tableevent if the the window get closed this remove the Hits i had  tomsmart1

  ; check for events occured with the instructiontable
  wev.l = WZ_CheckTableEvent{ev}
  Select wev

    Case #WZTABLEEVENT_CELLSELECTED
      MOVE.l comPtr_TokenBase,token@(a5)

      b$ = WZ_GetCell{"INSTRUCTIONTABLE",WZ_Row{"INSTRUCTIONTABLE"},1}
      bstr$ = b$
      While token
        If b$ = Peek$(token+6) Then Pop While: Goto tfound
        token = Peek.l(token)
      Wend

     tfound:
      If token
        tok.l = Peek.w(token+4)
        iinfo$ = "Library: " + PED_GetLibname{tok LSR 7}
        iinfo$ + " - LibNr.: "+Str$(tok LSR 7)+" - TokenID: "+Str$((tok AND $7f)-1)+" - MemPointer $"+Hex$(tok)
      Else
        iinfo$ = "Include: " + PED_GetIncludeName{bstr$}
      EndIf
      WZTags #WARGSA_TextPen,2
      WZPrint "INSTRUCTION_INFO",&iinfo$

    Case #WZTABLEEVENT_DOUBLECLICK
      pos = WZ_Row{"INSTRUCTIONTABLE"}
      actualword$ = WZ_GetCell{"INSTRUCTIONTABLE",WZ_Row{"INSTRUCTIONTABLE"},1}
      Gosub instructionbrowser_startguide

  End Select

  Select ev

    Case #IDCMP_INTUITICKS
      Gosub update_instructiontable

    Case #IDCMP_CLOSEWINDOW:
      wtemp\ibrowser_x = WindowX
      wtemp\ibrowser_y = WindowY
      wtemp\ibrowser_w = WindowWidth
      wtemp\ibrowser_h = WindowHeight
      WZ_KillTable{"INSTRUCTIONTABLE"}
      CloseWZWinWithMenu{"WIN_INSTRUCTIONBROWSER"}

    Case #IDCMP_RAWKEY

    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "add" ;addcode
          a$ = bstr$
          log_Print{"adding to code: " + a$}
          !asm
          MOVE.l textbufferaddr,a0
          ADD.w comWord_TextBufferOffset,a0
          ADD.w comWord_ColumnsOffset,a0
          ADD.w comWord_Column,a0
          CMP.b #" ",(a0)
          BEQ nocharunder
            MOVEQ #-1,d0
           'loop
              ADDQ.l #1,d0
            CMP.b #" ",(a0)+
            BNE 'loop
            i2 = PutD0
            JSR cursor_off
            !basic
            For i = 1 To i2
              JSR deletechar
            Next
            !asm
            JSR cursor_on
          nocharunder:
          !basic
          Gosub insertstring
          Gosub activatesourcewindow

        Case "macros"
          browse_macros = WZInput
          previoussearch_instruction$ = "|"
          ActivateWZGadget{"INSTRUCTION_STRING"}

        Case "instr"
          browse_instructions = WZInput
          previoussearch_instruction$ = "|"
          ActivateWZGadget{"INSTRUCTION_STRING"}

        Case "incdir"
          browse_includes = WZInput
          previoussearch_instruction$ = "|"
          ActivateWZGadget{"INSTRUCTION_STRING"}

      End Select

  End Select

Return


.update_instructiontable
  search_instruction$ = WZGetString("INSTRUCTION_STRING")
  If (search_instruction$<>previoussearch_instruction$) AND (Len(search_instruction$) > 1)
    previoussearch_instruction$ = search_instruction$
    WZ_ClearTable{"INSTRUCTIONTABLE"}
    InitArgParse search_instruction$
    word1$ = NextArg$
    word2$ = NextArg$
    MOVE.l comPtr_TokenBase,token@(a5)
    numcount.l = 0
    If browse_instructions
      While token
        b$ = Peek$(token+6)
        c$ = Peek$(token+6+Len(b$)+1)
;        d$ = PED_GetLibname{Peek.w(token+4) LSR 7}
        If Instr(b$,word1$) AND numcount < #maxlabels
          If Instr(b$,word2$)
            numcount = numcount+1
            c$ = Peek$(token+7+Len(b$))
            TST.l classiccolor
            BEQ 'nomore
            LEA classiccommands,a0
            MOVE.l token@(a5),a1
            MOVE.w 4(a1),d0
            LSR.w #7,d0

           'again
              MOVE.w (a0)+,d1
              BEQ 'nomore
              CMP.w d1,d0
            BNE 'again

            CMP.l #99,classiccolor
            BEQ 'skip
            ;                  WZTags #WENTRYA_TextPen,Peek.b(?tokencolor)

           'nomore
            ;                  WZListAdd lst,b$
            WZ_AddRow{"INSTRUCTIONTABLE",b$,c$}

           'skip
          End If
        End If
        token = Peek.l(token)
      Wend
    End If
    ;
    If browse_macros
      MOVE.l comPtr_MacroBase,a0:MOVE.l (a0),token@(a5)
      c.l = 0
      While token
        b$ = Peek$(token+13)
;        !cout{word1$,b$}
        If Instr(b$,word1$) AND numcount<#maxlabels
          If Instr(b$,word2$)
            numcount = numcount + 1
            i = Peek.w(token+8)
            If i > 90 Then i = 90
            b$ = "!" + b$
            c$ = Peeks$(Peek.l(token+4),i)
            ;                  WZTags #WENTRYA_TextPen,Peek.l(?macrocolor)
            ;                  WZListAdd lst,b$
            WZ_AddRow{"INSTRUCTIONTABLE",b$,c$}
          End If
        End If
        token = Peek.l(token)
      Wend
    End If

    If browse_includes
      ResetList HelpIndexCache()
      While NextItemFast(HelpIndexCache())
        If Instr(HelpIndexCache()\name,word1$) AND numcount<#maxlabels
          If Instr(HelpIndexCache()\name,word2$)
            numcount = numcount+1
            WZ_AddRow{"INSTRUCTIONTABLE",HelpIndexCache()\name,HelpIndexCache()\help}
          End If
        End If
      Wend
    End If
    pos = 0
    ;          WZPrint "list",pos,lst,0
    WZ_TableSort{"INSTRUCTIONTABLE",1}
    WZ_UpdateTable{"INSTRUCTIONTABLE"}
  Else
    If (search_instruction$<>previoussearch_instruction$) AND (Len(search_instruction$)<2)
      previoussearch_instruction$ = search_instruction$
      WZ_ClearTable{"INSTRUCTIONTABLE"}
     WZ_UpdateTable{"INSTRUCTIONTABLE"}
    EndIf
  End If
Return


.event_popup:
  popexit.l = False                                              ; added to set the init value that fix the bug that after select a item with a doubleclick the next popup win are autoclosed  tomsmart1
  Select ev

    Case #IDCMP_IDCMPUPDATE
      If Left$(WZGadName,9) = "POPUPMENU"
        popup_selected = WZInput + 1
        popexit = True
      EndIf

    Case #IDCMP_MOUSEBUTTONS
;      mb.b = MButtons
;      If (mb = 1) OR (mb=2)
;         popexit = True
;      EndIf

  End Select

  If popexit = True
    a$ = WZ_GetPopUpEntry{popup_selected}
    a$ = dos_Trim{Left$(a$,Instr(a$,"{")-1)}
    SetScreenTitle{a$ + " " + PED_GetIncludeHelp{a$} }    ; removed a$ test because it is not needed  tomsmart1
    a$ = UnRight$(a$,Len(poptok$)) + "{"
    Gosub insertstring
    Gosub close_popupwindow
  EndIf
  Gosub activatesourcewindow                                ; always active sourcewin if a popupwin event happend like mouse click or scroll  tomsmart1
Return


.insertstring:
  ; --
  ; -- check for a comment
  i = SearchBegin(a$,Asc(";"),1)
  If i
    a$ = Left$(a$,i-2) ;+" "
  End If
;  !cout{a$+"*"}
  GetD0 &a$
  MOVE.l d0,a2
  MOVE.l d7,-(a7)

 'l1
    MOVE.b (a2)+,d7
    BEQ 'e1
      CMP.w #$7d,comWord_Column
      BGE 'e1
        MOVEM.l a2/a5,-(a7)
        JSR insertchar
        MOVEM.l (a7)+,a2/a5
  BRA 'l1
 'e1
  MOVE.l (a7)+,d7
Return


.instructionbrowser_startguide   ;actualword$: zu suchende Funktion
  MOVE.l comPtr_TokenBase,token@(a5)

  b$ = actualword$
  While token
    If b$ = Peek$(token+6) Then Pop While:Goto found
    token = Peek.l(token)
  Wend

 found:
  If token
    tok.l = Peek.w(token+4)
    tokname$ = b$
    libnumber = tok LSR 7
    Gosub open_helptool
  Else ;no token, but a function or macro
    tokname$ = b$
    libnumber = 0
    Gosub open_helptool
  End If
Return


.open_helptool:
  tokid.l = PED_GetTokenID{*tokenbase,tokname$}
  libnumber = PED_GetTokenLibnum{*tokenbase,tokname$}
  myhelpdir$ = helpdir$

  ;If tokid <= 0
  ;  tokname$ = Left$(tokname$,FLen(tokname$)-1)
  ;  tokid = PED_GetTokenID{*tokenbase,tokname$}
  ;  libnumber = PED_GetTokenLibnum{*tokenbase,tokname$}
  ;EndIf

  If tokid>0
    If Right$(tokname$,1)="_"
      tokname$ = Left$(tokname$,Len(tokname$)-1)
      helpdir$ = autodocdir$ + " -d " + helpdir$
    EndIf
    libname$ =  lib_mapping$( libnumber,0)
    mostright$ = Right$(libname$,1)
    If mostright$ = "1" OR mostright$ = "2" Then libname$ = Left$(libname$,Len(libname$)-1)
  Else
    libname$ = PED_GetIncludeName{tokname$}
  EndIf

  If Instr(libname$,"unused")=0 AND (libname$<>"")
    Show_Helpfile{libname$,tokname$,Peek$(?str_defaultpubscreen)}
  Else
    search_instruction$ = tokname$
    Gosub open_instructionbrowser
    ;dummy.l = ask{"No help available",!TRANS{"Ok"},!TRANS{"Info"}}
  EndIf
  helpdir$ = myhelpdir$ ; restore standard helpdir$
Return


.open_shortcuts
  If NOT WZ_CheckOpen{"WIN_SHORTCUTS"}
    WZWindow WZID("WIN_SHORTCUTS"),?wzgui,255,wtemp\short_x,wtemp\short_y,wtemp\short_w,wtemp\short_h,WZID("WIN_SHORTCUTS")
    AddedMenu2WZWin{"WIN_SHORTCUTS"}

    WZ_InitTable{"WIN_SHORTCUTS","SHORTCUTS",2}
    WZ_SetPriority{"SHORTCUTS",1,2}
    WZ_SetTableReadOnly{"SHORTCUTS",True}        ; disabled row selection
    WZ_SetEditable{"SHORTCUTS",False,False}      ; disabled editing of the table  tomsmart1
    WZ_SetSortable{"SHORTCUTS",False}            ; disabled sorting for the table  tomsmart1
    ; update keys and changed order  tomsmart1
    WZ_SetTableTitle{"SHORTCUTS",!TRANS{"Key"}                       ,!TRANS{"Function"}}
           WZ_AddRow{"SHORTCUTS",       "Navigation"           ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+LeftArrow"}             ,!TRANS{"Go Back in history"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+RightArrow"}            ,!TRANS{"Go Forward in history"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+Left Mousebutton"}      ,!TRANS{"Jump to Label/Func-Definition"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+Middle Mousebutton"}    ,!TRANS{"Back from Label/func"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+UpArrow"}              ,!TRANS{"Jump to first line"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+DownArrow"}            ,!TRANS{"Jump to last line"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+LeftArrow"}            ,!TRANS{"Move cursor to start of word"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+RightArrow"}           ,!TRANS{"Move cursor to end of word"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+A"}                 ,!TRANS{"Jump to the last line in that something was added"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+SHIFT+1-3"}         ,!TRANS{"Set bookmark 1-3"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+1-3"}               ,!TRANS{"Jump to bookmark 1-3"} }

           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",       "Edit"               ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+X"}                    ,!TRANS{"CUT same as <AMIGA>+<X>"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+C"}                    ,!TRANS{"COPY vertical, all select lines only copyed at the select column"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+V"}                    ,!TRANS{"PASTE vertical, all lines pasted at the cursor column"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+U"}                    ,!TRANS{"undo delete current line"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+UpArrow"}               ,!TRANS{"Move Line Up"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+DownArrow"}             ,!TRANS{"Move Line Down"} }

           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+E"}                    ,!TRANS{"Insert 'end if'"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+F"}                    ,!TRANS{"Insert a 'Function' skeleton"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+N"}                    ,!TRANS{"Insert a 'Newtype' skeleton"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+S"}                    ,!TRANS{"Insert a 'Statement' skeleton"} }

           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+RightArrow on block"}  ,!TRANS{"TAB marked Block"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+LeftArrow on block"}   ,!TRANS{"Un-TAB marked Block"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+SHIFT+UpArrow"}        ,!TRANS{"Extend blockmark upwards"}   }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+SHIFT+DownArrow"}      ,!TRANS{"Extend blockmark downwards"} }

           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",       "Help"                 ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP+SHIFT"}                ,!TRANS{"Opens guide/autodoc of instruction under cursor"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP+CTRL"}                 ,!TRANS{"Opens parameter diagnostic for actual function"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP on any function"}      ,!TRANS{"Displays correct syntax in screens titlebar"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP on '\'"}               ,!TRANS{"Opens window 'type browser' and shows newtype information"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP on 'EndIf'"}           ,!TRANS{"Shows corresponding IF-Blockheader"} }

           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",       "Editor-Actions"       ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"TAB"}                       ,!TRANS{"Activates sourcewindow"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ESC"}                       ,!TRANS{"Closes any active helpwindow"} }
           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+Click on filename"}     ,!TRANS{"Save and compile and run"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+Click on filename"}    ,!TRANS{"Save and create exe (save both if you click on different)"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+I"}                    ,!TRANS{"Switch Intellisense for Commands 'on/off' if Intellisens is enabled"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+F4-F6"}             ,!TRANS{"save winconfig"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F4-F6"}                     ,!TRANS{"load winconfig (F4 also startconfig)"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F7"}                        ,!TRANS{"window autolayout variant #1"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F8"}                        ,!TRANS{"window autolayout variant #2"} }
           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",!TRANS{"F9"}                        ,!TRANS{"goto previous document"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F10"}                       ,!TRANS{"goto next document"} }
    WZ_DrawTable{"SHORTCUTS"}
    WZ_UpdateTable{"SHORTCUTS"}
  EndIf
Return


.event_shortcuts:
  If RawKeyState(#RAWKEY_TAB) Then Gosub activatesourcewindow : ev = 0       ;  TAB Key hit
  If RawKeyState(#RAWKEY_ESC) Then ev = #IDCMP_CLOSEWINDOW

; swaped the Select functions to remove the undefind situation of the Tableevent if the the window get closed this remove the Hits i had  tomsmart1

  wev.l = WZ_CheckTableEvent{ev}
  !cout{wev}

  Select ev
    Case #IDCMP_NEWSIZE

    Case #IDCMP_CLOSEWINDOW
      WZ_KillTable{"SHORTCUTS"}
      CloseWZWinWithMenu{"WIN_SHORTCUTS"}

  End Select
Return


.open_cliarguments
  *clistringptr.l = Peek.l(?comPtr_CLIArgumentsString)
  If *clistringptr >< 0
    clistr.s = Peek.s(*clistringptr)
  Else
    Return
  End If
  old_clistr.s = clistr
  ;FindScreen 0
  WZWindow WZID("WIN_CLIARGUMENTS"),?wzgui,64,-1,-1,-1,-1,WZID("WIN_CLIARGUMENTS")
  If clistr<>"" Then WZPrint "CLI_ARGUMENTS",&clistr
  ActivateWZGadget{"CLI_ARGUMENTS"}
  exit_cli.b = False : get_arguments.b = False

  Repeat
    ev.l = WaitEvent

    ; bubble onlinehelp for most windows
   ; If onlinehelp <> 0
   ;   If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) AND (ev<>#IDCMP_GADGETHELP)  AND (ev<>#IDCMP_CHANGEWINDOW)
   ;     WZ_HideHelp{}
   ;   EndIf
   ;   If ev = #IDCMP_GADGETHELP Then WZ_ShowHelp{}
   ; EndIf

    Select ev

      Case #IDCMP_CLOSEWINDOW
        exit_cli = True

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName

;          Case "CLI_ARGUMENTS"
;            get_arguments = True

          Case "CLI_OK"
            exit_cli = True
            get_arguments = True

          Case "CLI_CANCEL"
            get_arguments = False
            exit_cli = True

        End Select

      Default
        ActivateWZGadget{"CLI_ARGUMENTS"}

    End Select

  Until exit_cli = True

  If get_arguments = True
    clistr = WZGetString("CLI_ARGUMENTS")
    Poke.s *clistringptr,Left$(clistr,127)
  Else
    clistr = old_clistr
  EndIf
  WZCloseWindow WZID("WIN_CLIARGUMENTS")
  FlushEvents
  Gosub activatesourcewindow
Return



.open_calculator
  calc_expression.s = ""
  !ComData_GetL{comPtr_CalculatorExpressionString,D0} : CalculatorExpressionStringPointer.l = PutD0
  Poke.s CalculatorExpressionStringPointer,calc_expression
  If Peek.l(Addr Window(WZID("WIN_CALCULATOR")))=0
    WZWindow WZID("WIN_CALCULATOR"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_CALCULATOR")
    !ComData_SetW{comWord_CalculatorButtonBinFlag,#$00}
    !ComData_SetW{comWord_CalculatorButtonDecFlag,#$80}

    ;event_Calculator
    calc_exit.l = False
    calc_test.l = False
    Repeat
     ActivateWZGadget{"CALC_EXPRESSION"}
     ev_calculator.l = WaitEvent

     If RawKeyState(#RAWKEY_ESC) Then ev_calculator = #IDCMP_CLOSEWINDOW

      Select ev_calculator

        Case #IDCMP_CLOSEWINDOW
          calc_exit = True

        Case #IDCMP_IDCMPUPDATE
          Select WZGadName

            Case "CALC_CLOSE"
              calc_exit = True

            Case "CALC_EXPRESSION"
              calc_expression = WZGetString("CALC_EXPRESSION")

            Case "BIN"
              !ComData_SetW{comWord_CalculatorButtonBinFlag,#$80}
              !ComData_SetW{comWord_CalculatorButtonDecFlag,#$00}
              calc_test = True

            Case "HEX"
              !ComData_SetW{comWord_CalculatorButtonBinFlag,#$00}
              !ComData_SetW{comWord_CalculatorButtonDecFlag,#$00}
              calc_test = True

            Case "DEC"
              !ComData_SetW{comWord_CalculatorButtonBinFlag,#$00}
              !ComData_SetW{comWord_CalculatorButtonDecFlag,#$80}
              calc_test = True

          End Select

          If FLen(calc_expression)<128                      ; test if the string is not longer than 128 byte because this is the limit that is set in the compiler source  tomsmart1 2012 05 30
            If (calc_expression<>"") AND (calc_exit = False)
              If (calc_expression<>Peek.s(CalculatorExpressionStringPointer) ) OR (calc_test = True)
                Poke.s CalculatorExpressionStringPointer,calc_expression
                !asm
                !ComData_JSR{comFunc_CalculatExpression} ;examine_expression
                !basic
                calc_expression = Peek.s(CalculatorExpressionStringPointer)
                WZPrint "CALC_EXPRESSION",&calc_expression
              EndIf
              calc_test = False
            EndIf
         Else
           error{!TRANS{"The expression is to long please reduce it to max 127 characters!"} }
         EndIf

      End Select

    Until calc_exit

    WZCloseWindow WZID("WIN_CALCULATOR")
    FlushEvents
    Gosub activatesourcewindow
  EndIf
Return




.open_newtype:
   WZWindow WZID("WIN_NEWTYPE"),?wzgui,255,wtemp\type_x,wtemp\type_y,wtemp\type_w,wtemp\type_h,WZID("WIN_NEWTYPE")
   AddedMenu2WZWin{"WIN_NEWTYPE"}

   ;GTSetMenuChecked 0,5,9,On
   Use Window WZID("WIN_NEWTYPE")
   WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
   WZ_SetTableTitle{"TYPETABLE","Type","Value"}
   WZ_SetTableColors{"TYPETABLE",1,0,1,0}
   WZ_SetPriority{"TYPETABLE",2,1}
   WZ_DrawTable{"TYPETABLE"}

   Select newtype_mode

     Case 0
       WZPrint "STRING2",cstr$
       WZPrint "NEWTYPE_CONST",1
       WZPrint "NEWTYPE_VAR",0
       WZPrint "NEWTYPE_STRUCT",0
       Gosub newtype_listconsts

     Case 1
       WZPrint "STRING2",str2$
       WZPrint "NEWTYPE_CONST",0
       WZPrint "NEWTYPE_VAR",1
       WZPrint "NEWTYPE_STRUCT",0
       Gosub newtype_listvars

     Case 2
       WZPrint "STRING2",str2$
       WZPrint "NEWTYPE_CONST",0
       WZPrint "NEWTYPE_VAR",0
       WZPrint "NEWTYPE_STRUCT",1

       Gosub newtype_selecttype
       a$ = ""
       For i = 1 To lev:
         If i>1
            a$ = a$+"\"+pos$(i):
         Else
            a$ = a$+"."+pos$(i):
         End If
       Next
       typestr$ = a$
       WZTags #WZRD_TEXTPEN,Peek.l(?newtypecolor)
       WZPrint "NEWTYPE_ENTRY",&a$
   End Select

   ActivateWZGadget{"STRING2"}   ; replaced to use the statement  tomsmart1 2012 03 09
Return


.event_newtype
  If RawKeyState(#RAWKEY_TAB)  Then Gosub activatesourcewindow : ev = 0
  If RawKeyState(#RAWKEY_ESC)  Then ev = #IDCMP_CLOSEWINDOW
;  move_cursor{"list2",lst2,-1}

; swaped the Select functions to remove the undefind situation of the Tableevent if the the window get closed this remove the Hits i had  tomsmart1

  tev.l = WZ_CheckTableEvent{ev}
  If tev = #WZTABLEEVENT_DOUBLECLICK
    Select newtype_mode

      Case 0 ; Constants
        temp$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},1} ;WZListString(lst2.List,WZInput)
        typestr$ = temp$
        WZTags #WZRD_TEXTPEN,Peek.l(?newtypecolor)
        WZPrint "NEWTYPE_ENTRY",&typestr$

      Default
        ;str2$ = "" : str2b$ = ""
        ;WZPrint "STRING2",&str2$
        temp$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},1} ;WZListString(lst2.List,WZInput)
        c2$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},2}
        If c2$<>"" Then c2$ = " ."+c2$
        c3$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},3}
        If c3$<>"" Then c3$ = " $"+c3$
        temp$ + c2$ + c3$

        If newtype_mode = 1 AND lev  = 0
          i = SearchEnd (temp$,@".",1)
          If lev = 0 Then var$ = Left$(temp$,i-1)
          temp$ = Mid$(temp$,i + 1)
        End If

        If newtype_mode <> 1 Then var$ = ""
        a$ = temp$
        lev = lev + 1 : If lev > 13 Then lev = 13
        pos2(lev) = 0
        find = 0
        pos2(lev-1) = WZ_Row{"TYPETABLE"} ;WZListPos("list2")
        t$ = Left$(a$,Instr(a$," ")-1)
        If lev > 1
          i = SearchEnd(a$,Asc("."),1)
          i2 = SearchEnd(a$,Asc("$"),1)
          a$ = Mid$(a$,i+1,i2-i-3)
        End If
        MOVE.l newtypebase,d0
        *nt.l = PutD0
        If *nt
          *nt = Peek.l(*nt):
          While *nt
            b$ = Peek$(*nt+11)
            If b$ = a$
              ;*nt2(lev) = Peek.l(*nt+4)
              Gosub newtype_listsubtype
              find = 1
              Pop If : Goto f1a
            End If
            *nt = Peek.l(*nt)

           f1a:
          Wend
        Else
          error{"newtypebase = NULL => GURU!!!"}
        End If
        If find = 0
          lev = lev - 1 ;:WZPrint "list2",-1:
          a$ = ""
          For i = 1 To lev:
            If i > 1
               a$ = a$ + "\" + pos$(i):
            Else
               a$ = a$ + "." + pos$(i):
            End If
          Next
          i = Instr(temp$," ")
          temp$ = Replace$ (temp$,"*","")
          typestr$ = var$ + a$ + "\" + Left$(temp$,i)
          WZTags #WZRD_TEXTPEN,Peek.l(?newtypecolor)
          WZPrint "NEWTYPE_ENTRY",&typestr$
        End If

    End Select

  EndIf

  Select ev

    Case #IDCMP_INTUITICKS
      Select newtype_mode

        Case 0
          cpos.l = 0
          cpos.l = WZ_Column{"TYPETABLE"} ;WZListPos ("list2")
          cstr$ = WZGetString("STRING2")
          If cstr$<>cstr2$
            cstr2$ = cstr$
            ;cpos = 0
            Gosub newtype_listconsts
          End If

        Case 1
          str2$ = WZGetString("STRING2")
          If str2$<>str2b$
            str2b$ = str2$
            pos2(lev) = 0
            Gosub newtype_listvars
          End If

        Case 2
          str2$ = WZGetString("STRING2")
          If str2$<>str2b$
            str2b$ = str2$
            find.l = 0
            pos2(lev) = 0
            p$ = str2$
            Gosub newtype_selecttype
          End If

      End Select

    Case #IDCMP_CLOSEWINDOW
      wtemp\type_x = WindowX
      wtemp\type_y = WindowY
      wtemp\type_w = WindowWidth
      wtemp\type_h = WindowHeight
      WZ_KillTable{"TYPETABLE"}
      CloseWZWinWithMenu{"WIN_NEWTYPE"}


    Case #IDCMP_RAWKEY
      ;move_cursor{"list2",lst2,-1}

    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "typeadd"
          a$ = typestr$
          If Instr(a$,"\",StrLen(a$)-1)<>0 Then a$ = Left$(a$,StrLen(a$)-1)
          If quicktype Then a$ = Mid$(typestr$,Instr (typestr$,"\")+1)
          If newtype_mode <> 1 Then a$ = Replace$(a$,"*","")
          Gosub insertstring
          Gosub activatesourcewindow

        Case "string2"
         ;Gosub activatesourcewindow                             ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1

        Case "parent" :
          quicktype = 0
          If newtype_mode = 0
          Else
            If lev Then lev = lev - 1
            If lev = 0
              If newtype_mode = 1
                Gosub newtype_listvars
              Else
                If str2$<>"" Gosub newtype_selecttype Else Gosub newtype_listtype
              End If
            Else
              a$ = pos$(lev)
              JSR newtype_listsubtype
            End If
            a$ = "":pos$(lev+1) = ""
            For i = 1 To lev:
              If i>1
                a$ = a$+"\"+pos$(i):
              Else
                a$ = a$+"."+pos$(i):
              End If
            Next
            typestr$ = a$
            WZTags #WZRD_TEXTPEN,Peek.l(?newtypecolor)
            WZPrint "NEWTYPE_ENTRY",&a$
          End If

        Case "clear":
          If newtype_mode = 0
            cstr$ = "":
            WZPrint "STRING2",&cstr$
          Else
            str2$ = "":
            Gosub newtype_selecttype
            WZPrint "STRING2",&str2$
          End If

        Case "newtype_const"
          newtype_mode = 0 : Gosub newtype_updatelist

        Case "newtype_var"
          newtype_mode = 1 : Gosub newtype_updatelist

        Case "newtype_struct"
          newtype_mode = 2 : Gosub newtype_updatelist

      End Select

  End Select

Return


.newtype_updatelist
  str2b$ = ""
  WZ_KillTable{"TYPETABLE"}

  Select newtype_mode

    Case 0
      WZPrint "STRING2",cstr$
      WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
      WZ_SetTableTitle{"TYPETABLE","Identifier","Value"}
      WZ_SetTableColors{"TYPETABLE",1,0,1,0}
      WZ_SetPriority{"TYPETABLE",2,1}
      WZ_DrawTable{"TYPETABLE"}

      ptr.l = &str2b$
      If ptr>4096
        WZPrint "NEWTYPE_ENTRY",&str2b$
      Else
        error{"Pointer to str2b$ is not valid! \\22"+str2b$+"\\22"}
      End If

      Gosub newtype_listconsts

    Case 1
      WZPrint "STRING2",str2$
      WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
      WZ_SetTableTitle{"TYPETABLE","Identifier","Value"}
      WZ_SetTableColors{"TYPETABLE",1,0,1,0}
      WZ_SetPriority{"TYPETABLE",1,1}
      WZ_DrawTable{"TYPETABLE"}
      ptr.l = &str2$
      If ptr>4096
        WZPrint "NEWTYPE_ENTRY",&str2$
      Else
        error{"1: Pointer to str2$ is not valid! \\22"+str2$+"\\22"}
      End If

      Gosub newtype_listvars

    Case 2
      WZPrint "STRING2",str2$
      ptr.l = &str2$
      If ptr>4096
        WZPrint "NEWTYPE_ENTRY",&str2$
      Else
        error{"2: Pointer to str2$ is not valid! \\22"+str2$+"\\22"}
      End If

      Gosub newtype_selecttype
      a$ = ""
      For i = 1 To lev:
        If i>1
           a$ = a$+"\"+pos$(i):
        Else
           a$ = a$+"."+pos$(i):
        End If
      Next
      typestr$ = a$
      WZTags #WZRD_TEXTPEN,Peek.l(?newtypecolor)
      WZPrint "NEWTYPE_ENTRY",&a$

  End Select
Return


.newtype_listvars
  WZ_ClearTable{"TYPETABLE"}
  InitArgParse str2$
  word1$ = NextArg$
  word2$ = NextArg$
  MOVE.l comPtr_VarBase,d0
  *nt = PutD0
  If *nt
    *nt = Peek.l(*nt):
    While *nt
      a$ = Peek$(*nt + $13)
      If Peek.w(*nt + 6) AND 2 Then arr$ = "()" Else arr$ = ""
      If Peek.w(*nt + 6) AND 1 Then poin$ = "*" Else poin$ = ""
      If Instr (a$,word1$)
        If Instr(a$,word2$)
          it.l = Peek.l(*nt+10)
          WZ_AddRow{"TYPETABLE",poin$ + a$ + arr$,Peek$(it + $b)}
        EndIf
      End If
      *nt = Peek.l(*nt)
    Wend
  Else
    error{"comPtr_VarBase = NULL => GURU!!!"}
  End If
  WZ_TableSort{"TYPETABLE",1}
  WZ_UpdateTable{"TYPETABLE"}
Return


.newtype_listconsts
  WZ_ClearTable{"TYPETABLE"}
  If FLen(cstr$) => 2
    ;log_Print{"listconstants:" + cstr$}
    InitArgParse cstr$
    word1$ = NextArg$
    word2$ = NextArg$
    MOVE.l constantbase,d0
    *nt = PutD0
    If *nt
      *nt = Peek.l(*nt)
      While *nt
        a$ = Peek$(*nt+$13)
        If Instr (a$,word1$) Then If Instr(a$,word2$)
          WZ_AddRow{"TYPETABLE",a$,"$"+Hex$(Peek.l(*nt+8))}
        End If
        *nt = Peek.l(*nt)
      Wend
    Else
      error{"constantbase = NULL => GURU!!!"}
    End If

  End If

  WZ_TableSort{"TYPETABLE",1}
  WZ_UpdateTable{"TYPETABLE"}
Return


.newtype_listtype                   ;called when press parent
  lev = 0
  WZ_KillTable{"TYPETABLE"}
  WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",1}
  WZ_SetTableColors{"TYPETABLE",1,0,1,0}
  WZ_SetTableTitle{"TYPETABLE","Identifier"}
  WZ_DrawTable{"TYPETABLE"}

  MOVE.l newtypebase,d0
  *nt = PutD0

  If *nt
    *nt = Peek.l(*nt)
    While *nt
      a$ = Peek$(*nt+11)
      WZ_AddRow{"TYPETABLE",a$}
      *nt = Peek.l(*nt)
    Wend
  Else
    error{"newtypebase = NULL => GURU!!!"}
  End If

;  WZ_TableSort{"TYPETABLE",1}
  WZ_UpdateTable{"TYPETABLE"}
Return


.newtype_selecttype

  WZ_KillTable{"TYPETABLE"}
  If lev = 0
    WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",1}
    WZ_SetTableTitle{"TYPETABLE","Identifier"}
    WZ_SetTableColors{"TYPETABLE",1,0,1,0}
    WZ_DrawTable{"TYPETABLE"}
  Else
    WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",3}
    WZ_SetTableTitle{"TYPETABLE","Identifier","Type","Offset"}
    WZ_SetTableColors{"TYPETABLE",1,0,1,0}
    WZ_SetPriority{"TYPETABLE",3,2,2}
    WZ_DrawTable{"TYPETABLE"}
  EndIf

  i = 0
  InitArgParse p$
  word1$ = NextArg$
  word2$ = NextArg$
  If lev
    MOVE.l newtypebase,d0
    *nt = PutD0
    If *nt
;       *nt = *nt2(lev)
;       While *nt
;       If Peek.w(*nt+6) = 1 Then b$ = "*" Else b$ = ""
;         b$ = b$ + Peek$(*nt+15)
;         c$ = Peek$(Peek.l(*nt+10)+11)
;         If Instr(b$,word1$) Then If Instr(b$,word2$)
;         WZ_AddRow{"TYPETABLE",b$,c$,"$"+Right$(Hex$(Peek.w(*nt+4)),4)}
;       End If
;      b$ + "  ."+c$
;      *nt = Peek.l(*nt)
     If *nt
          *nt = Peek.l(*nt)
        Else
          error{"newtypebase = NULL => GURU!!!"}
        End If
;      Wend
        While *nt
        b$ = Peek$(*nt+11)
        If postype$(lev) = b$
                  *nt3.l = Peek.l(*nt+4):
                  While *nt3
                  If Peek.w(*nt3+6) = 1 Then b$ = "*" Else b$ = ""
                    b$ = b$ + Peek$(*nt3+15)
                    c$ = Peek$(Peek.l(*nt3+10)+11)
                    ;If Instr(b$,word1$) Then If Instr(b$,word2$)
                    WZ_AddRow{"TYPETABLE",b$,c$,"$"+Right$(Hex$(Peek.w(*nt3+4)),4)}
                    ;End If
                 b$ + "  ."+c$
                 *nt3 = Peek.l(*nt3)
                 Wend
                 *nt = 0:Goto out2
        EndIf
        *nt = Peek.l(*nt)
out2        Wend
        WZ_TableSort{"TYPETABLE",3}
        WZ_UpdateTable{"TYPETABLE"}
    End If
  Else
    MOVE.l newtypebase,d0
    *nt = PutD0
    If *nt
      *nt = Peek.l(*nt)
    Else
      error{"newtypebase = NULL => GURU!!!"}
    End If
   While *nt
     b$ = Peek$(*nt+11)
     If Instr(b$,word1$) Then If Instr(b$,word2$)
       WZ_AddRow{"TYPETABLE",b$,""}
       find = find + 1
       f$ = b$
     EndIf
     *nt = Peek.l(*nt)
   Wend
   WZ_TableSort{"TYPETABLE",1}
   WZ_UpdateTable{"TYPETABLE"}
  End If
Return


.newtype_listsubtype
  WZ_KillTable{"TYPETABLE"}
  If lev = 0
    WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",1}
    WZ_SetTableTitle{"TYPETABLE","Identifier"}
    WZ_SetTableColors{"TYPETABLE",1,0,1,0}
    WZ_DrawTable{"TYPETABLE"}
  Else
    WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",3}
    WZ_SetTableTitle{"TYPETABLE","Identifier","Type","Offset"}
    WZ_SetTableColors{"TYPETABLE",1,0,1,0}
    WZ_SetPriority{"TYPETABLE",3,2,2}
    WZ_DrawTable{"TYPETABLE"}
  EndIf
  postype$(lev)=a$
  If lev > 1
    pos$(lev) = t$
  Else
    pos$(lev) = a$
  End If
  a$ = ""
  For i = 1 To lev:
    If i > 1
      a$ = a$+"\"+pos$(i):
    Else
      a$ = a$+"."+pos$(i):
    End If
  Next
  typestr$ = a$
  WZTags #WZRD_TEXTPEN,Peek.l(?newtypecolor)
  WZPrint "NEWTYPE_ENTRY",&a$
  WZ_ClearTable{"TYPETABLE"}
  i = 0
;  *nt = *nt2(lev)
;  While *nt
;    If Peek.w(*nt+6) = 1 Then a$ = "*" Else a$ = ""
;    a$ = a$ + Peek$(*nt+15)
;    c$ = Peek$(Peek.l(*nt+10)+11)
;    WZ_AddRow{"TYPETABLE",a$,c$,"$" + Right$(Hex$(Peek.w(*nt+4)),4)}
;    a$ = a$ + " ."+c$
;    *nt = Peek.l(*nt)
;    i = i + 1
;  Wend
  MOVE.l newtypebase,d0
  *nt = PutD0
  If *nt
    *nt = Peek.l(*nt)
    While *nt
      b$ = Peek$(*nt+11)
      If postype$(lev) = b$
        *nt3.l = Peek.l(*nt+4):
        While *nt3
          If Peek.w(*nt3+6) = 1 Then b$ = "*" Else b$ = ""
          b$ = b$ + Peek$(*nt3+15)
          c$ = Peek$(Peek.l(*nt3+10)+11)
          ;If Instr(b$,word1$) Then If Instr(b$,word2$)
          WZ_AddRow{"TYPETABLE",b$,c$,"$"+Right$(Hex$(Peek.w(*nt3+4)),4)}
          ;End If
          b$ + "  ." + c$
          *nt3 = Peek.l(*nt3)
        Wend
      EndIf
      *nt = Peek.l(*nt)
    Wend
    WZ_TableSort{"TYPETABLE",3}
    WZ_UpdateTable{"TYPETABLE"}
  End If
Return


.event_diag:
  If RawKeyState(#RAWKEY_TAB)  Then Gosub activatesourcewindow : ev = 0
  If RawKeyState(#RAWKEY_ESC)  Then ev = #IDCMP_CLOSEWINDOW

  Select ev

    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "addcode"
          MOVE.l comLong_DisplayLineOffset,d0
          ADD.l comLong_DisplayLine,d0
          CMP.l ctrlhelpline,d0
          BNE skip2
          a$ = addstr$
          For i =  1 To 12
           diag_val$(i) = WZGetString("val"+UStr$(i))
          Next
          Gosub diag_close
          Gosub activatesourcewindow
          For i = 1 To 12
           a$ = a$+diag_val$(i):If diag_val$(i+1) <>"" Then a$ = a$+","
          Next
          If addcodesize >1 Then t$ = Peeks$(addcodepos,addcodesize):Else t$ = ""
          t$ = StripLead$(t$,32)
          MOVE.w comWord_Column,colstore
          JSR cursor_off
          MOVE.l addcodepos@(a5),a0
          SUB.l textbufferaddr,a0
          SUB.w comWord_TextBufferOffset,a0
          MOVE.w a0,comWord_Column
          MOVE.w comWord_ColumnsOffset,oldcolumnsoffset
          CLR.w comWord_ColumnsOffset
          i = FLen(t$)
          SetScreenTitle{Str$(i)+" "+t$}
          If i
             MOVE.l addcodepos@(a5),a0
             SUB.l textbufferaddr,a0
             SUB.w comWord_TextBufferOffset,a0
             MOVE.w a0,comWord_Column
             For i2 = 1 To i-1
               JSR deletechar
             Next
          End If
          Gosub insertstring
          ;Gosub diag_close
          MOVE.w oldcolumnsoffset,comWord_ColumnsOffset
          MOVE.w colstore,comWord_Column
          ;Gosub activatesourcewindow
          JSR cursor_on

         skip2:

        Case "diagclear"
          For i = 1 To 12
            diag_val$(i) = ""
            WZPrint "val"+UStr$(i),diag_val$(i)
          Next
          ActivateWZGadget{"val1"}

      End Select

    Case #IDCMP_CLOSEWINDOW
      Gosub diag_close

    Case #IDCMP_VANILLAKEY
      If EventCode = #VANILLAKEY_ESC
        Gosub diag_close
      EndIf

  End Select

Return


.diag_close
  wtemp\diag_x = WindowX
  wtemp\diag_y = WindowY
  wtemp\diag_w = WindowWidth
  wtemp\diag_h = WindowHeight
  CloseWZWinWithMenu{"WIN_HELPDIAG"}
  diag = 0
Return


.load_windowlayouts:
  USEPATH wtemp
  CopyMem_ &wpref(num),&wtemp,SizeOf .winprefs
  If (\lbrowser_w<=0) OR (\lbrowser_h<=0)
    \lbrowser_x = -2
    \lbrowser_y = -2
    \lbrowser_w = -2
    \lbrowser_h = -2
  EndIf
  If (\source_h>0) AND (\source_w>0)
    Poke.w ?win_TopLeft,\source_x
    Poke.w ?win_TopEdge,\source_y
    Poke.w ?win_Width,\source_w
    Poke.w ?win_Height,\source_h
  Else
    *myscreen.Screen = Peek.l(Addr Screen(0))
    Poke.w ?win_TopLeft,0
    Poke.w ?win_TopEdge, *myscreen\WBorTop + *myscreen\Font\ta_YSize + 1
    Poke.w ?win_Width,ScreenWidth
    Poke.w ?win_Height,ScreenHeight - (*myscreen\WBorTop + *myscreen\Font\ta_YSize + 1)
  EndIf
Return


.do_windowlayout:
  If sourceWindow\win
    If sourceWindow\win <> 0
      ChangeWindowBox_ sourceWindow\win,Peek.w(?win_TopLeft),Peek.w(?win_TopEdge),Peek.w(?win_Width),Peek.w(?win_Height)
      RefreshWindowFrame_ sourceWindow\win
      Delay_ 5
      !asm
      JSR resize_sourcewindow
      !basic
    EndIf
  Else
    JSR open_sourcewindow
    JSR cursor_on
  EndIf

  If \lbrowser_on
    Gosub open_librarybrowser
  Else
    If WZ_CheckOpen{"WIN_LIBRARYBROWSER"}
      WZ_KillTable{"FUNCTIONSTABLE"}
      CloseWZWinWithMenu{"WIN_LIBRARYBROWSER"}
    EndIf
  End If

  If \ibrowser_on
    Gosub open_instructionbrowser
  Else
    If WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"}
      WZ_KillTable{"INSTRUCTIONTABLE"}
      CloseWZWinWithMenu{"WIN_INSTRUCTIONBROWSER"}
    EndIf
  End If

  If \diag_on
    Gosub open_helpdiag
  Else
    If WZ_CheckOpen{"WIN_HELPDIAG"}
      CloseWZWinWithMenu{"WIN_HELPDIAG"}
      diag = 0
    EndIf
  End If

  If \click_on
    Gosub open_labelwindow
  Else
    If WZ_CheckOpen{"WIN_LABELS"}
      CloseWZWinWithMenu{"WIN_LABELS"}
    EndIf
  End If

  If \short_on
    Gosub open_shortcuts
  Else
    If WZ_CheckOpen{"WIN_SHORTCUTS"}
      WZ_KillTable{"SHORTCUTS"}
      CloseWZWinWithMenu{"WIN_SHORTCUTS"}
    EndIf
  End If

  If \type_on
    Gosub open_newtype
  Else
    If WZ_CheckOpen{"WIN_NEWTYPE"}
      WZ_KillTable{"TYPETABLE"}
      CloseWZWinWithMenu{"WIN_NEWTYPE"}
    EndIf
  End If

  FlushEvents
  If \activewin > 0
    Activate \activewin
    Use Window \activewin
    If Peek.l(Addr Window(\activewin)) <> 0
      Select \activewin
        Case 3 : ActivateWZGadget{"STRING_LABEL"}
        Case 2 : ActivateWZGadget{"STRING2"}
        Case 1 : ActivateWZGadget{"STRING"}
        Case 4 : ActivateWZGadget{"VAL1"}
      End Select
    EndIf
  Else
    Gosub activatesourcewindow
  EndIf
  ev = 0
Return



.open_labelwindow
  WZWindow WZID("WIN_LABELS"),?wzgui,255,\click_x,\click_y,\click_w,\click_h,WZID("WIN_LABELS")
  AddedMenu2WZWin{"WIN_LABELS"}
  ;GTSetMenuChecked 0,5,8,On
  LabelList_PreSelectItemNumber = -1                             ;added because we don't know what was the preselectitem  tomsmart1
  WZPrint "rem",Peek.w(?comWord_LabelRemark)
  WZPrint "all",Peek.w(?comWord_LabelAll)
  WZPrint "STRING_LABEL",search_label$
  WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels,LabelList_FirstVisableItemNumber
  Gosub update_versiongadgets
Return


.event_label:
  If RawKeyState(#RAWKEY_TAB) Then Gosub activatesourcewindow : ev = 0       ;  TAB Key hit
  If RawKeyState(#RAWKEY_ESC) Then ev = #IDCMP_CLOSEWINDOW

  Select ev

    Case #IDCMP_INTUITICKS
      ;all activities of the window like mouse move

      ;only need this to auto update the listview by typ in the search string   tomsmart1
      search_label$ = LCase$( WZGetString("STRING_LABEL") )
      If search_label$<>old_search_label$
        LabelList_FirstVisableItemNumber = 0
        CLR.l comLong_Label1VisableItem
        LabelList_PreSelectItemNumber = -1                       ; added to clear all old list datas  tomsmart1
        LabelList_NewSelectItemNumber.l = 0
        old_search_label$ = search_label$
        !asm
        JSR clear_labellist
        JSR update_labellist
        JSR redraw_labellist
        !basic
        Poke$ ?comStr_LabelSearchString ,search_label$
      End If

    Case #IDCMP_RAWKEY
       ;move_cursor{"LISTVIEW_LABELS",list_labels,LabelList_PreSelectItemNumber}

    Case #IDCMP_CLOSEWINDOW
      wtemp\click_x = WindowX
      wtemp\click_y = WindowY
      wtemp\click_w = WindowWidth
      wtemp\click_h = WindowHeight
      CloseWZWinWithMenu{"WIN_LABELS"}


    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "string_label"
          ; no needed becaus is handled in #IDCMP_INTUITICKS
          ;Gosub activatesourcewindow                            ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1

        Case "case"
          search_label$ = "Case"
          WZPrint "STRING_LABEL",search_label$
          Poke.w ?comWord_LabelRemark,1
          Poke.w ?comWord_LabelAll,0
          WZPrint "rem",1
          WZPrint "all",0
          LabelList_FirstVisableItemNumber = 0
          CLR.l comLong_Label1VisableItem                        ; added to clear all old list datas  tomsmart1
          LabelList_PreSelectItemNumber = -1
          !asm
          JSR clear_labellist
          JSR update_labellist
          JSR redraw_labellist
          !basic
          ActivateWZGadget{"STRING_LABEL"}

        Case "listview_labels"
          ; removed code the checked if the last and the new select item was the same because wizard.lib do it and by overwritable by doubleclick  tomsmart1
          lineaddress.l = WZListData (list_labels,WZInput)
          LabelList_FirstVisableItemNumber = WZListPos("LISTVIEW_LABELS")
          MOVE.l d0,comLong_Label1VisableItem
          LabelList_PreSelectItemNumber = WZListNum("LISTVIEW_LABELS")
          ;WZPrint "LISTVIEW_LABELS",-1,list_labels,LabelList_FirstVisableItemNumber
          Gosub activatesourcewindow                             ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1
          GetD0 lineaddress
          !asm
          MOVE.l comPtr_CurrentSourceLine,a4
          ;CMP.l oldcurrsourceline,a4                            ; deactivate because it prevent sometimes jumps to the select item  tomsmart1
          ;BEQ 'l1
          MOVE.l d0,a0
          JSR storeline
          JSR jump_addhistory                                    ; moved it because it is a asm rountine, and don't trash a0  tomsmart1
          JSR jump_to_keyword
          JSR cursor_on
          ;MOVE.l a4,oldcurrsourceline                           ; deactivate because it prevent somtimes jumps to the select item  tomsmart1

         ;'l1
          !basic

        Case "rem"
          Poke.w ?comWord_LabelRemark,WZInput
          Poke.w ?comWord_LabelAll,0
          WZPrint "all",0
          ;search_label$ = "":WZGadSet "STRING_LABEL",search_label$
          LabelList_FirstVisableItemNumber = 0
          CLR.l comLong_Label1VisableItem                        ; added to clear all old list datas  tomsmart1
          LabelList_PreSelectItemNumber = -1
          !asm
          JSR clear_labellist
          JSR update_labellist
          JSR redraw_labellist
          !basic
          ActivateWZGadget{"STRING_LABEL"}

        Case "all"
          Poke.w ?comWord_LabelAll,WZInput
          Poke.w ?comWord_LabelRemark,0
          WZPrint "rem",0
          LabelList_FirstVisableItemNumber = 0
          CLR.l comLong_Label1VisableItem                        ; added to clear all old list datas  tomsmart1
          LabelList_PreSelectItemNumber = -1
          !asm
          JSR clear_labellist
          JSR update_labellist
          JSR redraw_labellist
          !basic
          ActivateWZGadget{"STRING_LABEL"}

        Case "clr"
          search_label$ = ""
          WZPrint "STRING_LABEL",search_label$
          LabelList_FirstVisableItemNumber = 0
          CLR.l comLong_Label1VisableItem                        ; added to clear all old list datas  tomsmart1
          LabelList_PreSelectItemNumber = -1
          !asm
          JSR clear_labellist
          JSR update_labellist
          JSR redraw_labellist
          !basic
          ActivateWZGadget{"STRING_LABEL"}

        Case "button_update_liblist"

          ; MOVE.l comdata,D0   : *cd.l = PutD0
          ; MOVE.l varbase,D0   : *vb.l = PutD0
          ; MOVE.l instrbase,D0 : *intructionbase.l = PutD0
          ; MOVE.l libpointer,D0: *librarybase.l = PutD0
          Gosub scan_source_for_used_libs

        Case "library_list"
          cmd_node.l = WZGetNode(lib_list.List)
          cmd$ = WZListString(cmd_node,0)
          klammer.b = Instr(cmd$,"(")
          If klammer
            used_win.l = Used Window
            searchcmd$ = StrChg(Left$(cmd$,klammer-1)," ","")
            ; !cout{"*"+searchcmd$+"*"}
            casesens_backup.w = Peek.w(?case_sensitive)
            BSET #7,case_sensitive
            Poke$ ?str_searchstring   ,searchcmd$;,60
            Poke$ ?str_oldsearchgadget,searchcmd$;,60

            If oldsearchcmd$ <> searchcmd$
              oldsearchcmd$ = searchcmd$
              !asm
              MOVEQ #0,d0
              JSR jumpline
              !basic
            EndIf

            !asm
            JSR storeline
            JSR cursor_off
            MOVE.l comPtr_CurrentSourceLine,a4
            JSR menu_findnext
            JSR update_vertscroller
            JSR cursor_on
            !basic
            If (used_win >< -1) Then Use Window used_win
            ; gewaehlte Suchmethode wieder einschalten
            Poke.w ?case_sensitive,casesens_backup
            Gosub activatesourcewindow
          EndIf

      End Select

  End Select
  move_cursor{"LISTVIEW_LABELS",list_labels,LabelList_PreSelectItemNumber}
RTS



.navigate_to_previous_label:
  If WZ_CheckOpen{"WIN_LABELS"}
    LabelList_PreSelectItemNumber = LabelList_PreSelectItemNumber-1
    If LabelList_PreSelectItemNumber<0 Then LabelList_PreSelectItemNumber = 0
    LabelList_NewSelectItemNumber = LabelList_PreSelectItemNumber
    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels
    i = WZListData (list_labels,LabelList_NewSelectItemNumber)
    !asm
    MOVEM.l a0-a6/d1-d7,-(a7)
    MOVEA.l comPtr_CurrentSourceLine,A4
    MOVE.l d0,a0
    JSR storeline
    JSR jump_to_keyword
    JSR cursor_on
;    MOVE.l a4,oldcurrsourceline                           ; deactivate because it prevent somtimes jumps to the select item  tomsmart1
    MOVEM.l (a7)+,a0-a6/d1-d7
    !basic
  End If
Return

.navigate_to_next_label:
  If WZ_CheckOpen{"WIN_LABELS"}
    LabelList_PreSelectItemNumber = LabelList_PreSelectItemNumber+1
    If LabelList_PreSelectItemNumber = >WZListItems (list_labels) Then LabelList_PreSelectItemNumber = WZListItems (list_labels)-1
    LabelList_NewSelectItemNumber = LabelList_PreSelectItemNumber
    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels
    i = WZListData (list_labels,LabelList_NewSelectItemNumber)
    !asm
    MOVEM.l a0-a6/d1-d7,-(a7)
    MOVEA.l comPtr_CurrentSourceLine,A4
    MOVE.l d0,a0
    JSR storeline
    JSR jump_to_keyword
    JSR cursor_on
 ;    MOVE.l a4,oldcurrsourceline                           ; deactivate because it prevent somtimes jumps to the select item  tomsmart1
    MOVEM.l (a7)+,a0-a6/d1-d7
    !basic
  End If
Return


JL_0_46D6:
  MOVE.l d0,-(a7)
  MOVEM.l a0-a1,-(a7)
  MOVE.l a1,a0
  CMP.b #".",-1(a0)
  BEQ 'sk1
    CMP.b #";",-1(a0)
    BEQ 'sk1
      SUBQ.l #1,a0
 'sk1
  MOVE.l expandstore,a1
  JSR detokenize_line
  MOVEM.l (a7)+,a0-a1
  MOVE.l a0,d0
  MOVE.l a1,temp
  !basic
  s = PutD0
  MOVE.l expandstore,d0
  i = PutD0
  If i Then s$ = Peek$(i) : Else s$=""
  If Instr(s$,"Stop") OR Instr(s$,"Trap")
    MOVE.l temp,a0
   'l1
    MOVE.b (a0)+,d0
    BEQ no_breakpoint
      CMP.b #$80,d0
      BNE 'l1
        CMP.b #$ae,(a0)
        BEQ 'l2
          CMP.b #$2d,(a0)
          BNE 'l1
   'l2
    WZTags #WENTRYA_TextPen,2
    If sort_labels = -1
      WZListAdd list_labels," --Breakpoint---",0,s
    Else
      WZListAdd list_labels," --Breakpoint---",2000,s
    End If
    ADDQ.w #1,comWord_LabelCounter
    ADDQ.l #1,numcount
    Goto nostr
  End If

  no_breakpoint:
  Select Peek.b(?is_stat_func_macro)                                          ; replaced IF... with Select... to support Macros  tomsmart1
    Case 1 : s$ = Mid$(s$,2) : WZTags #WENTRYA_TextPen,Peek.l(?functioncolor)
    Case 2 : s$ = Mid$(s$,2) : WZTags #WENTRYA_TextPen,Peek.l(?macrocolor)
   Default :                   WZTags #WENTRYA_TextPen,1
  End Select

  If t
    If Instr(s$,word1$) OR skip = 1
      If Instr(s$,word2$) OR skip = 1
        WZListAdd list_labels,s$,sort_labels,s
        ADDQ.w #1,comWord_LabelCounter
        ADDQ.l #1,numcount
        skip = 0
      End If
    End If
  Else
    If Instr(s$,search_label$) OR skip = 1
      WZListAdd list_labels,s$,sort_labels,s
      ADDQ.w #1,comWord_LabelCounter
      ADDQ.l #1,numcount
      skip = 0
    End If
  End If

  nostr:
  !asm
  MOVE.l (a7)+,d0
  CLR.b is_stat_func_macro
RTS


.storeline
  MOVE.w comWord_KeyBeforeReturn,D0
  BEQ.w exit_storeline

  !regs2stack
  MOVE.l comPtr_CurrentSourceLine,a4
  JSR cursor_off
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVE.w D0,comWord_SourceChanged

  JSR parse_line

  ; -- draw selecting block if existing
  SF comByte_StateBlockMark
  TST.l comLong_BlockEndY
   BMI.w exit_updateblocka
  MOVEM.l D0-D3/A0-A2,-(A7)
  MOVE.l comLong_DisplayLine,D1
  ADD.l comLong_DisplayLineOffset,D1
  CMP.l comLong_BlockStartY,D1
   BLT.w JL_0_C66a
  CMP.l comLong_BlockEndY,D1
   BGT.w JL_0_C66a
  MOVE.w comLong_BlockStartX,D0
  MOVE.l comLong_BlockStartY,D1
  MOVE.w comLong_BlockEndX,D2
  MOVE.l comLong_BlockEndY,D3
  CMP.l D1,D3
   BNE.w JL_0_C50a
  CMP.w D0,D2
   BNE.w JL_0_C50a
  MOVE.w visiblecolumns,D2
  JL_0_C50a:
  SUB.l comLong_DisplayLineOffset,D3
  SUB.l comLong_DisplayLineOffset,D1
  JSR JL_0_59BC
  ST comByte_StateBlockMark
  JL_0_C66a:
  MOVEM.l (A7)+,D0-D3/A0-A2
  exit_updateblocka:

  JSR JL_0_55AA
  MOVE.w comWord_DoTokenize,D0
  BEQ.w JL_0_CC6b
    JSR print_current_sourceline
    TST.b comByte_StateBlockMark
    BEQ.w JL_0_CC6b
      MOVEM.l D0-D3/D7/A0-A2,-(A7)
      MOVE.w comLong_BlockStartX,D0
      MOVE.l comLong_BlockStartY,D1
      MOVE.w comLong_BlockEndX,D2
      MOVE.l comLong_BlockEndY,D3
      CMP.l D1,D3
      BNE.w JL_0_CB2a
        CMP.w D0,D2
        BNE.w JL_0_CB2a
          MOVE.w visiblecolumns,D2
      JL_0_CB2a:
      SUB.l comLong_DisplayLineOffset,D3
      SUB.l comLong_DisplayLineOffset,D1
      JSR JL_0_59BC
      MOVEM.l (A7)+,D0-D3/D7/A0-A2
  JL_0_CC6b:
  MOVE.l a4,comPtr_CurrentSourceLine
  !stack2regs

  exit_storeline:
  CLR.w comWord_KeyBeforeReturn
  MOVE.l comPtr_CurrentSourceLine,a4
RTS


.ascii_to_token  ;a2 = text
  MOVEM.l d1-d7/a0-a6,-(a7)
  MOVE.l d0,a2
  MOVEA.l comPtr_TokenBase,A3

 JL_0_6036b:
  MOVEA.l A2,A4
  MOVE.l A3,-(A7)
  ADDQ.w #6,A3

 JL_0_603Cb:
    MOVE.b (A3)+,D3
     BEQ.w JL_0_6082b     ;found
    MOVE.b (A4)+,D2
    ;BCLR #$7,D2
    ;ORI.b #$20,D3
    ;ORI.b #$20,D2
    CMP.b D3,D2
     BEQ.b JL_0_603Cb

 JL_0_6054b:
    MOVEA.l (A7)+,A3
    MOVE.l (A3),D3
     BEQ.w JL_0_6060b
    MOVEA.l D3,A3
BRA.b JL_0_6036b

 JL_0_6082b:
  MOVE.b (A4),D2
  BNE JL_0_6054b
  BCLR #$7,D2
   BNE.b JL_0_6054b       ;not found
  MOVEA.l (A7)+,A3
  ADDQ.w #4,A3
  MOVEQ #0,d0
  MOVE.b (A3)+,d0
  ASL.l #8,d0
  MOVE.b (a3),d0
  MOVEM.l (a7)+,d1-d7/a0-a6
RTS

 JL_0_6060b
  MOVEQ #0,d0
  MOVEM.l (a7)+,d1-d7/a0-a6
RTS

.activatesourcewindow                                                         ; changed name to better show it pourpos  tomsmart1
  If Peek.l(?ptr_sourcewindow)
     ActivateWindow_ Peek.l(?ptr_sourcewindow)
  ;If sourceWindow\win
  ;   ActivateWindow_ sourceWindow\win                                         ; replaced ASM part with Basic commands  tomsmart1
     Use Window 0                                                             ; added sourcewinid  tomsmart1
  EndIf
Return                                                                        ; replaced RTS with Return  tomsmart1


.draw_tabs:
  USEPATH sourceWindow
  SetAPen_ \win\RPort, AB3Pen(#AB3_screenfill)

  xpos_text.l = #filenamepos * \font\tf_XSize
  ypos_sa.w = \statusAreaY + 1
  ypos_text.w = ypos_sa + 2 + \font\tf_Baseline

  RectFill_ \win\RPort,xpos_text - 4,ypos_sa + 2,\win\Width - \win\BorderRight,ypos_sa + 1 + \font\tf_YSize

  ; -- draw all sourcefilename tabs
  *loadedfiles.l = Peek(?loadedfilesbase)
  If *loadedfiles
    *actualfile.l = Peek.l(?actualfile)
    *sourcefile.l = Peek.l(?loadedfilesbase)

;    xpos_text.l= #filenamepos * Peek.w(?fontWidth)
    Repeat
      modifiedFlag.b = False
      textlen.w = 10                        ; width of tab in characters

      Move_ \win\RPort, xpos_text, ypos_text

      If *actualfile = *sourcefile
        fcol.w = AB3Pen(#AB3_screentext)    ; selected
        bcol.w = AB3Pen(#AB3_cbackground)
        bevel_recessed.b = True
        stylestate.w = #FSF_BOLD
      Else
        fcol.w = AB3Pen(#AB3_screentext)    ; unselected
        bcol.w = AB3Pen(#AB3_screenback)
        bevel_recessed.b = False
        stylestate.w = #FS_NORMAL
      EndIf

      Gosub draw_bevel

      SetDrMd_ \win\RPort, 1
      SetAPen_ \win\RPort, fcol
      SetBPen_ \win\RPort, bcol

      If stylestate = #FSF_BOLD
        SetFont_ \win\RPort,\fontB ;Peek.l(?ptr_sourcefontb)
      Else
        SetFont_ \win\RPort,\font ;Peek.l(?ptr_sourcefont)
      EndIf
      SetSoftStyle_ \win\RPort,stylestate.w,#FSF_BOLD


      If *actualfile = *sourcefile
        If Peek.l(?comStr_Modified) = $4D4F4449 Then modifiedFlag = True
      Else
        If Peek.l(*sourcefile + $1e6) = $4D4F4449 Then modifiedFlag = True
      EndIf
      If modifiedFlag
        Text_ \win\RPort,"*", 1
        textlen - 1
      EndIf

      sourcename$ = Peek$(*sourcefile + 222)
      If sourcename$ = "" Then sourcename$ = "none"
      sourcename_len.w = Len(sourcename$)

      sourcename$ = StrLeft(sourcename$,16)
      Text_ \win\RPort, &sourcename$, textlen    ;A1, A0, D0

      If sourcename_len > textlen             ;indicator for more characters
        WritePixel_ \win\RPort, \win\RPort\cp_x + 1 ,\win\RPort\cp_y - 4 - \win\RPort\TxBaseline + \win\RPort\TxHeight / 2
        WritePixel_ \win\RPort, \win\RPort\cp_x + 1, \win\RPort\cp_y - 2 - \win\RPort\TxBaseline + \win\RPort\TxHeight / 2
        WritePixel_ \win\RPort, \win\RPort\cp_x + 1, \win\RPort\cp_y     - \win\RPort\TxBaseline + \win\RPort\TxHeight / 2
        WritePixel_ \win\RPort, \win\RPort\cp_x + 1, \win\RPort\cp_y + 2 - \win\RPort\TxBaseline + \win\RPort\TxHeight / 2
        WritePixel_ \win\RPort, \win\RPort\cp_x + 1, \win\RPort\cp_y + 4 - \win\RPort\TxBaseline + \win\RPort\TxHeight / 2
      EndIf

      ;SetDrMd_ \win\RPort, 1
      xpos_text = xpos_text + #filenameoffs * \font\tf_XSize
      *sourcefile = Peek.l(*sourcefile)
    Until *sourcefile = 0
  EndIf

  SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground) ;Peek.l(?backgroundcolor)
  SetFont_ \win\RPort,\font ;Peek.l(?ptr_sourcefont)
  SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_BOLD
Return

.draw_bevel:
  xsa.l = \font\tf_XSize / 2
  xsb.l = \font\tf_XSize - xsa
  bx1.l = xpos_text - xsa
  by1.l = ypos_sa +1;+ 3
  bx2.l = \font\tf_XSize * 10 + \font\tf_XSize-1 + bx1
  by2.l = \font\tf_YSize + 1  + by1
  cp_x.l = \win\RPort\cp_x
  cp_y.l = \win\RPort\cp_y

  If bevel_recessed = False
    SetAPen_ \win\RPort,AB3Pen(#AB3_screenback)
    RectFill_ \win\RPort,bx1+1,by1+1,bx2-1+1,by2
    SetAPen_ \win\RPort,AB3Pen(#AB3_screentext)
    Move_ \win\RPort,bx1,by1
    Draw_ \win\RPort,bx1,by2
    Draw_ \win\RPort,bx2+1,by2
    Draw_ \win\RPort,bx2+1,by1
  Else
    SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    RectFill_ \win\RPort,bx1+1,by1-1,bx2-1+1,by2
    SetAPen_ \win\RPort,AB3Pen(#AB3_cother)
    Move_ \win\RPort,bx1,by1
    Draw_ \win\RPort,bx1,by2+1
    Draw_ \win\RPort,bx2+1,by2+1
    Draw_ \win\RPort,bx2+1,by1
    cp_y+1
  EndIf
  Move_ \win\RPort,cp_x,cp_y
Return


.check_mouse_in_statusarea:
  ; a1: IntuiMessage
  MOVEM.l a0/a1/d0/d7,-(a7)
  !basic
;  MOVEQ #0,d0
;  MOVE.w $20(a1),d0
;  i5 = PutD0
;  MOVE.w $22(a1),d0
;  i6 = PutD0
;  MOVE.w #0,d0
;  !cout{i5,i6,Peek.w(?ypos_statusarea)+Peek.w(?win_BorTop)}

  CMP.w #$68,D0
  BEQ.w 'no

  MOVE.l loadedfilesbase,d0
  BEQ 'no

  MOVEQ #0,d6
  MOVEQ #0,d7
  MOVE.w $20(a1),d6           ; d6 = x-pos, d7 = y-pos  of  mouse
  MOVE.w $22(a1),d7

  MOVEQ #0,d5
  MOVE.l #filenamepos,d1
  MULS fontWidth,d1           ; get x-position of first sourcename

  MOVEQ #0,d3
  MOVE.w fontWidth,d3
  MULS #filenameoffs,d3                  ;character show
  ADD.w d1,d3

 'again:
  MOVE.l d0,a0
  TST.b $de(a0)               ; filename
  ;BEQ 'n1

  MOVEQ #0,d2                 ; load y-Position of statusarea + some pixels until filetab starts
  MOVE.w ypos_statusarea,d2
  ADD.w win_BorTop,d2

  MOVE.l d2,d4                ; load bottom-pos for buttons
  ADD.w fontHeight,d4
  ADD.w #8,d4

  CMP.l d1,d6                 ; check if mouse was in buttonarea
  BLE 'n1
    CMP.l d3,d6
    BGE 'n1
      CMP.l d2,d7
      BLE 'n1
        CMP.l d4,d7
        BGE 'n1

  !regs2stack
  CMP.l actualfile,D0
  BNE.w 'noctrl
  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_CONTROL|#IEQUALIFIER_LALT|#IEQUALIFIER_RALT,d1
  BEQ 'noctrl
    CMP.l #$4D4F4449,comStr_Modified    ; "MODI"
    BNE 'notchanged
      !asm
      JSR storeline
      ;JSR saverout
      !basic
      Delay_ 2
   'notchanged

    JSR set_tedlibbase
    MOVE.w message_qualifier,d1
    AND.w ##IEQUALIFIER_CONTROL,d1
    BEQ 'nocreateexe
      !asm
      JSR cursor_off
      MOVEM.l    D2-D7/A1-A6,-(A7)
      MOVEQ.l    ##MENU_SAVECREATEEXE,D6
      JSR        call_compilermenuitem
      MOVEM.l    (A7)+,D2-D7/A1-A6
      !basic
      BRA 'out2
   'nocreateexe
      MOVE.w message_qualifier,d1
      AND.w ##IEQUALIFIER_LALT|#IEQUALIFIER_RALT ,d1
      BEQ 'out2
        !asm
        JSR cursor_off
        MOVEM.l    D2-D7/A1-A6,-(A7)
        MOVEQ.l    ##MENU_COMPILERUN,D6
        JSR        call_compilermenuitem
        MOVEM.l    (A7)+,D2-D7/A1-A6
        !basic
     'out2
      !stack2regs
      !asm
      MOVEM.l (a7)+,d7/d0/a1/a0
      MOVEQ #-4,d7
      RTS
 'noctrl

  !stack2regs
  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_CONTROL|#IEQUALIFIER_LALT|#IEQUALIFIER_RALT ,d1
  BEQ 'nos2
    CMP.l #$4D4F4449,comStr_Modified     ; "MODI"
    BNE 'nos2
      MOVEM.l a0-a6/d0-d7,-(a7)
      !asm
      JSR storeline
      JSR saverout
      !basic
      Delay_ 2
      !stack2regs
 'nos2
  CMP.l actualfile,D0
  BEQ.w 'no
  MOVE.l messagestore,d1
  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_CONTROL|#IEQUALIFIER_LALT|#IEQUALIFIER_RALT ,d1
  BNE 'no4
    ;MOVE.b #1,refreshonstore
 'no4
  JSR storeline
  JSR cursor_off
  JSR selectfile
  !asm
  JSR StoreXtraData
  !basic
  MOVE.b #0,refreshonstore
  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_CONTROL|#IEQUALIFIER_LALT|#IEQUALIFIER_RALT ,d1
  BEQ 'no
  ;CMP.l #$4D4F4449,comStr_Modified
  ;BNE 'nos
  ; !asm
  ; JSR saverout
  ; !basic
    Delay_ 2
 'nos

  MOVE.w message_qualifier,d1
  AND.w ##IEQUALIFIER_CONTROL,d1
  BEQ 'nocreate
    !asm
    JSR set_tedlibbase
    JSR cursor_off
    MOVEM.l    D2-D7/A1-A6,-(A7)
    MOVEQ.l    ##MENU_SAVECREATEEXE,D6         ; replaced with the constant  tomsmart1
    JSR        call_compilermenuitem
    MOVEM.l    (A7)+,D2-D7/A1-A6
    !basic
    BRA 'noctrl2
 'nocreate
    MOVE.w message_qualifier,d1
    AND.w ##IEQUALIFIER_LALT|#IEQUALIFIER_RALT ,d1
    BEQ 'noctrl2
    !asm
    JSR set_tedlibbase
    JSR cursor_off
    MOVEM.l    D2-D7/A1-A6,-(A7)
    MOVEQ.l    ##MENU_COMPILERUN,D6            ; replaced with the constant  tomsmart1
    JSR        call_compilermenuitem
    MOVEM.l    (A7)+,D2-D7/A1-A6
    !basic
 'noctrl2
  !asm
  MOVEM.l (a7)+,d7/d0/a1/a0
  MOVEQ #-4,d7
  RTS

 'n1
  ADDQ.l #1,d5
  MOVE.l #filenameoffs,d0
  MULS fontWidth,d0
  ADD.l d0,d1
  ADD.l d0,d3
  MOVE.l (a0),d0
  BNE 'again

 'no
  !asm
  MOVEM.l (a7)+,d7/d0/a1/a0
RTS



.loadfile
  MOVEM.l a0-a6/d0-d7,-(a7)

  ; -- copy filename-strpointer to A1
  MOVE.l D0,A1

  ; --- check if actual file is source to load
  LEA str_unnamed,A3
  JSR compare_strings
  BNE.w exit_loadfile

  ; --- check if source is already loaded
  MOVEA.l loadedfilesbase,A2

  JL_0_BCFCb:
  MOVEA.l A2,A3
  MOVE.l A1,-(a7)           ; A1 auf den Stack

 'l1
    TST.b (a1)+
  BNE 'l1
  MOVEQ #60,d1

 'loop
    MOVE.b -(a1),d0
    CMP.l (a7),a1
     BEQ 'out2
    CMP.b #"/",d0
     BEQ 'out
    CMP.b #":",d0
     BEQ 'out
    SUBQ.l #1,d1
  BNE 'loop

 'out
  ADDQ.l #1,a1

 'out2
  LEA $DE(A3),A3
  JSR compare_strings
  MOVE.l (a7)+,a1         ; A1 vom Stack
  TST.l d0
  BNE.w JL_0_BD18b
    MOVEA.l (A2),A2
    CMPA.l #$0,A2
    BNE.b JL_0_BCFCb
    BRA.w load_sourcefileb
  JL_0_BD18b:
    MOVEA.l A2,A0
    JSR selectfile
    MOVEM.l (a7)+,a0-a6/d0-d7
    RTS
  load_sourcefileb:

  MOVE.l A1,D0

  MOVE.l D0,-(a7)       ; D0 auf Stack
  JSR menu_opennew
  MOVE.l (a7)+,D7       ; D0 vom Stack nach D7

  JSR load_source

  MOVEM.l (a7)+,a0-a6/d0-d7

 exit_loadfile:
RTS


; Begin routines for function .build_HelpIndexFile  ; moved the functions and statemend defination out of the build index rountine for a better overview  tomsmart1
Function.l ab3_IsTokenChar{char.l}
  If char>=@"a" AND char<=@"z" Then Function Return True
  If char>=@"A" AND char<=@"Z" Then Function Return True
  If char>=@"0" AND char<=@"9" Then Function Return True
  If char=@"_" OR char=@"@" OR char=@"`" Then Function Return True
  Function Return False
End Function


Statement writeentry{mode$,instruction$}
 SHARED HelpForPrivatFunctions

  ;#TOKEN_Function  = $8009
  ;#TOKEN_Statement = $8008
  ;#TOKEN_Object    = $80d7
  ;#TOKEN_Macro     = $800d
  ;#TOKEN_End       = $8002
  ;#TOKEN_Return    = $8007

  ; -- don't add it if it contains @H
  If Instr(instruction$,"@H") Then Statement Return

  ; -- token return found
  If Instr(instruction$,Mki$(#TOKEN_Return)) Then Statement Return

  ; -- token End found
  If Instr(instruction$,Mki$(#TOKEN_End)) Then Statement Return

  startpos.l = 0
  Select mode$
    Case "FUNC"
      startpos = Instr(instruction$,Mki$(#TOKEN_Function))  + 2
      i3.l = Instr (instruction$,".",startpos)
      If (i3 < startpos+5) AND (i3 <> 0)
        startpos = i3+1                              ; change it to 1 to make the test of spaces possible  tomsmart1

         While Mid$(instruction$,startpos,1)<>" "    ; test if we have no space  so it is still the function type (newtype)  tomsmart1
           startpos + 1
         Wend

      End If
      If Instr(instruction$,"FAST",startpos)
        startpos.l = Instr(instruction$,"FAST",startpos)    + 4
      End If

    Case "STAT"
      startpos = Instr(instruction$,Mki$(#TOKEN_Statement)) + 2
      If Instr(instruction$,"FAST",startpos)
        startpos.l = Instr(instruction$,"FAST",startpos)    + 4
      End If

    Case "MACR"
      startpos = Instr(instruction$,Mki$(#TOKEN_Macro))     + 2

  End Select

  ; -- get string positions --
  instruction$ = dos_Trim{Mid$(instruction$,startpos)}

  endpos.l  =1
  stopchar.l=False
  While endpos<=FLen(instruction$) AND stopchar=False
    If ab3_IsTokenChar{Peek.b(&instruction$+endpos-1)}=False Then stopchar=True:Else endpos+1
  Wend

  ; -- write infos to indexfile
  If endpos <> 0
    funcname$ = Mid$( instruction$ , 1 , endpos - 1)
    ;If Right$(funcname$,1)=";" Then funcname$ = UnLeft$(funcname$,1)
    ;funcname$ = StripLead$(StrLeft(funcname$,50,32),32)
    funcname$ = StripLead$(funcname$,32)

    If FLen(funcname$) >= 6                                   ; test if functionname leng <= 6  tomsmart1
      If Left$(funcname$,6) = "Return" Then Statement Return  ; yes then test if function or statement RETURN then we have nothing to print back again  tomsmart1
    EndIf

    If mode$ = "MACR" Then funcname$ = "!" + funcname$

    description$ = Mid$(instruction$,endpos)
    description$ = StripLead$(description$,32)
    If Left$(description$,1)=";" Then description$ = UnRight$(description$,1)
    description$ = StripLead$(description$,32)

    If (Left$(funcname$,1) = "_") OR (Left$(funcname$,2) = "!_")             ; test for privat routines  tomsmart
      If HelpForPrivatFunctions = True                                       ; test if we show help for it  tomsmart1
        NPrint mode$+"\\09"+funcname$+"\\09"+description$+ " ; private!"     ; show help but indentifiy privat routines tomsmart1
      End If
    Else
      ;NPrint LSet$(mode$,11) + LSet$(funcname$,50) + description$
      NPrint mode$+"\\09"+funcname$+"\\09"+description$                      ; public routines
    End If

  End If
End Statement



Function.l ab3_InstrToken{code.s,token.s}
  pos.l = Instr(code,token)
  If pos
    If ab3_IsTokenChar{Peek.b(&code+pos-1+FLen(token))} Then pos=0
    If pos>1
      If ab3_IsTokenChar{Peek.b(&code+pos-1-1)} Then pos=0
    End If
  End If
  Function Return pos
End Function



Statement scanfile{rootpath$,filename$}
  functoken$      = Mki$(#TOKEN_Function)
  statementtoken$ = Mki$(#TOKEN_Statement)
  objecttoken$    = Mki$(#TOKEN_Object)
  macrotoken$     = Mki$(#TOKEN_Macro)
  endtoken$       = Mki$(#TOKEN_End)
  returntoken$    = Mki$(#TOKEN_Return)
  tok80.s         = Str$($80)
  fid.l = file_Open{dos_AddPart{rootpath$,filename$},#file_read}
  If dos_GetExt{filename$}="bb2" Then tokenized.l=True : Else tokenized=False

  If fid>=0 ; ReadFile(0,filename$)
    ;file_Cache{fid}
    ;FileInput 0
    ; -- get current path
    ;dir_name$ = SPACE$(512)
    ;GetCurrentDirName_ &dir_name$,FLen(dir_name$)
    ;dir_name$ = StripTrail$(dir_name$,0)
    ;dir_name$ = dos_Trim{dir_name$}
    ;dir_name$ = dos_FilePart{dir_name$}

    ; -- add parent path to filename, if not in includes-drawer
    ;If LCase$(dir_name$)<>"includes" Then filename$ = dos_AddPart{dir_name$,filename$}

    ; -- print filename into indexfile
    NPrint "FILE\\09",filename$

    Repeat
      ;code.s = ReadLine$
      If tokenized
        code.s = file_ReadBB2Line{fid}
      Else
        code.s = file_ReadLine{fid}
      End If

      maxpos.l = Instr(code,";")
      If maxpos = 0 Then maxpos = FLen(code)-1

      ; in case its ASCII...
      If tokenized=False
        pos.l = ab3_InstrToken{code,"Function"}
        If pos>0 AND pos<maxpos
          ;If Instr(code,"GetObjectBy") Then error{"Found Function in "+filename$+" line:\\n"+code}
          code.s = Left$(code,pos-1) + functoken$ + Right$(code,FLen(code)-pos-8+1)
          If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"Statement"}
        If pos>0 AND pos<maxpos
          code.s = Left$(code,pos-1) + statementtoken$ + Right$(code,FLen(code)-pos-9+1)
          If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"Macro"}
        If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + macrotoken$ + Right$(code,FLen(code)-pos-5+1)
            If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"End "}
        If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + endtoken$ + Right$(code,FLen(code)-pos-3+1)
            If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"Return"}
        If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + returntoken$ + Right$(code,FLen(code)-pos-6+1)
            If pos<maxpos Then maxpos=pos
        End If
      End If
;      If Left$(a$,2) = ";/"
;        NPrint a$
;      Else
        pos = Instr(code,functoken$)
        If pos>0 AND pos<=maxpos Then writeentry{"FUNC",code}

        pos = Instr(code,statementtoken$)
        If pos>0 AND pos<=maxpos Then writeentry{"STAT",code}

        pos = Instr(code,macrotoken$)
        If pos>0 AND pos<=maxpos Then writeentry{"MACR",code}

;       EndIf
    Until file_EOF{fid}
    file_Close{fid}
  Else
    dummy.l = ask{!TRANS{"Can't open file "}+filename$,!TRANS{"Ok"},!TRANS{"Error"}}
  End If
End Statement


.build_HelpIndexFile
  DosBuffLen 32000
  CaseSense On

  If dos_Exist{HelpIndexFile$}
    dos_Delete{HelpIndexFile$}
  EndIf

  ClearList HelpIndexCache()
  ClearList dirs()
  If WriteFile (1,HelpIndexFile$)
    WZ_ShowMessage{!TRANS{"Updating indexfile for onlinehelp..."},0}

    ChangeWZWindowTitle{"WIN_PROGRESS",!TRANS{BuildHelpIndexWinTitle$} }  ; use Statement to remove double code tomsmart1 2012 03 09 ; use a variable so the title match the function tomsmart1

    If ChDir (includedir$)
      ; scan files for functions
      ; begin count include files
      num_files.l      = 0
      subincludedirs.b = False
      exitscan.b       = True
      dirname$         = ""
      Repeat

        While MoreEntries
          If EntryDIR                               ; test for subdir
            If dirname$=""                          ; test if we on main include dir, only 1 Level subdirectorys allowed/supported  tomsmart1
              If AddLast(dirs())
                dirs()\name = EntryName$            ; added subdirectory name to the list
                subincludedirs = True               ; yes we have subdirs   tomsmart1
              EndIf
            EndIf
          Else
            num_files + 1                           ; it is a file count +1
          EndIf
        Wend

        If subincludedirs = True                    ; test if we have subdirectorys  tomsmart1
          dirname$ = dirs()\name                    ; set first subdirectory
          ChDir(dos_AddPart{includedir$,dirname$})  ; change scan dir to subdirectory
          exitscan = False                          ; test subdirs don't exit
          If PrevItem(dirs())=False                 ; test if we have more subdirsectory and go to prev item in the list
            exitscan = True                         ; no more Items we have count all files
          EndIf
        EndIf

      Until exitscan = True
      ;end  count Include files

      ;begin scan Include files
      ChDir (includedir$)
      exitscan = False
      subpath.s = ""
      act_file.l = 0
      Repeat
        While MoreEntries
          If (NOT EntryDIR)
            ex.s = dos_GetExt{EntryName$}
            If (ex="bb2" OR ex="ab2" OR ex="ab3")
              FileOutput 1
              If subpath
                scanfile{includedir$,dos_AddPart{subpath,EntryName$}}
              Else
                scanfile{includedir$,EntryName$}
              End If
;              !cout{"scanned:",EntryName$}
;           Else
;              !cout{"no include:",EntryName$}
            EndIf
            act_file + 1 : act_file = Min(act_file,num_files)
            !WZ_Update_Gauge{act_file,num_files}
;          Else
;            !cout{"skipped:",EntryName$}
          End If
        Wend
        If dirname$ <> ""
          ChDir dos_AddPart{includedir$,dirname$}
          ;ChDir (includedir$)
          subpath = dirname$
;          !cout{"chdir:",includedir$+dirname$,"++++++ ",includedir$ +  dirs()\name}
          If NextItem(dirs()) Then dirname$ = dirs()\name Else dirname$ = ""
        Else
          exitscan = True
        EndIf
      Until exitscan = True
      ; end scan Include files

      ClearList dirs()
    Else
      dummy.l = ask{!TRANS{"Could not determine Include directory"}+":\\n"+includedir$+"!",!TRANS{"Ok"},!TRANS{"Error"}}
    EndIf
  ; bernd's code
  ;   If ChDir (includedir$)
  ;     While MoreEntries
  ;     If EntryDIR = False AND Right$(EntryName$,4) = ".include.bb2"
  ;        scanfile{fullpath$+EntryName$}
  ;     End If
  ;     Wend
  ;   End If
    CloseFile 1
    WZ_ShowMessage{!TRANS{"Updating Helpindex..."}}
    PED_LoadHelpIndexFile{HelpIndexFile$}
    WZ_ShowMessage{!TRANS{"Saving Helpindex to Disc..."}}
    PED_WriteHelpIndexCache{HelpIndexCacheFile$}
    WZ_ShowMessage{!TRANS{"Creating Hashmaps..."}}
    preproc_QueryTokens{*PreProcessor}
    preproc_SaveTokens{*PreProcessor,TokenHashMapFile}
    WZ_HideMessage{}
  End If

  CaseSense Off
RTS


findmode:   Dc.w 0


.event_find

;    Use Window WZID("WIN_SEARCH")
;    ActivateWZGadget{"FIND_FINDSTRING"}    ; replaced to use the statement  tomsmart1 2012 03 09
;    !cout{"event_find  " + Hex$(ev)}
    ;
    BSET #7,case_sensitive
    a_prev$ = a$
    a$ = WZGetString("FIND_FINDSTRING")
    b$ = WZGetString("FIND_REPLACESTRING")
    ; moved to make a active sourcewin possible after gadget hit remove the double access of the gadgets tomsmart1
    oldfindstr$    = a$
    oldreplacestr$ = b$

    If WZInput("FIND_SENSITIVE")= 0 Then a$ = StrUpper(a$) : BCLR #7,case_sensitive
    Poke$ ?str_oldsearchgadget,a$;,60
    Poke$ ?str_searchstring   ,a$;,60
    Poke$ ?str_replacestring  ,b$;,60

    ;If RawKeyState(#RAWKEY_TAB)  Then Gosub activatesourcewindow : ev = 0  ; removed to enable the tab-jump to the replace-textfield honitos 20191114
    If RawKeyState(#RAWKEY_ESC)  Then ev = #IDCMP_CLOSEWINDOW

    Select ev

      Case #IDCMP_INTUITICKS
        ; do nothing here

      Case #IDCMP_CLOSEWINDOW
        CloseWZWinWithMenu{"WIN_SEARCH"}
        Gosub activatesourcewindow
        FlushEvents

      Case #IDCMP_VANILLAKEY
        Select EventCode

;          Case #VANILLAKEY_RETURN                    ; deactivated, search only via shortcut "N"
;            !asm
;            JSR storeline
;            JSR cursor_off
;            MOVE.l comPtr_CurrentSourceLine,a4
;            JSR menu_findnext
;            JSR update_vertscroller
;            JSR cursor_on
;            !basic
;            Gosub activatesourcewindow
;            FlushEvents : Delay_ 2 ; VWait 3

          Case #VANILLAKEY_ESC
            CloseWZWinWithMenu{"WIN_SEARCH"}
            Gosub activatesourcewindow
            FlushEvents

        End Select

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName

          Case "FIND_FINDSTRING"
            If StrUpper(oldsearch$) <> StrUpper(a$)
              oldsearch$ = a$
              !asm
              JSR storeline
              JSR cursor_off
              MOVE.l comPtr_CurrentSourceLine,a4
              JSR menu_findnext
              JSR update_vertscroller
              JSR cursor_on
              !basic
              FlushEvents : Delay_ 1
            End If

          Case "FIND_NEXT"
            !asm
            JSR storeline
            JSR cursor_off
            MOVE.l comPtr_CurrentSourceLine,a4
            JSR menu_findnext
            JSR update_vertscroller
            JSR cursor_on
            !basic
            Gosub activatesourcewindow                ; added to make source win active that edit is possible  tomsmart1

          Case "FIND_PREVIOUS"
            !asm
            JSR storeline
            JSR cursor_off
            MOVE.l comPtr_CurrentSourceLine,a4
            JSR menu_previous
            JSR update_vertscroller
            JSR cursor_on
            !basic
            Gosub activatesourcewindow

          Case "FIND_REPLACE"
            !asm
            JSR storeline
            JSR cursor_off
            MOVE.l comPtr_CurrentSourceLine,a4
            JSR menu_replace
            JSR cursor_on
            !basic
            Gosub activatesourcewindow                ; added to make source win active that edit is possible  tomsmart1

          Case "FIND_REPLACE_ALL"
            Poke.w ?findmode, Abs(WZInput("FIND_FINDMODE"))
            If a$<>"" AND b$<>""
              !asm
              JSR storeline
              JSR cursor_off
              JSR set_pointer_busy

              MOVE.l A4,D0
              TST.w findmode
               BNE.b replace_loop
              MOVE.l comPtr_FirstSourceLine,D0

              replace_loop:
                MOVEA.l D0,A4
                MOVE.l A4,comPtr_CurrentSourceLine
                JSR replace_string
                MOVE.l (A4),D0
              BNE.b replace_loop

              JSR update_currsourceline
              JSR _redraw
              JSR cursor_on
              !basic
              Gosub set_pointer_normal_bas
            EndIf
            Gosub activatesourcewindow                ; added to make source win active that edit is possible  tomsmart1

          Case "FIND_EXIT"
            CloseWZWinWithMenu{"WIN_SEARCH"}
            Gosub activatesourcewindow

        End Select

    End Select
Return



.coutclose:
  !coutclose
Return

;####################################################################
; BEGIN  routines compiler settings window  tomsmart 2012 03 21     #
;####################################################################
.BackupCompilerSettings:
  !asm
  !ComData_JSR{comFunc_BackupXtraData}
  !basic

; get pointer to the settings from the compiler
  !ComData_GetL{comPtr_Residents_Table       ,D0} : Ptr_Residents_Table.l        = PutD0
  !ComData_GetL{comPtr_Number_of_Objects_Word,D0} : Ptr_Number_of_Objects_Word.l = PutD0
  !ComData_GetL{comPtr_StringBuffer_Long     ,D0} : Ptr_Stringbuffer_Long.l      = PutD0
  !ComData_GetL{comPtr_Stacksize_Long        ,D0} : Ptr_Stacksize_Long.l         = PutD0
  !ComData_GetL{comPtr_Create_IconFile_Byte  ,D0} : Ptr_Create_Iconfile_Byte.l   = PutD0
  !ComData_GetL{comPtr_Make_SmallestCode_Byte,D0} : Ptr_Make_Smallestcode_Byte.l = PutD0
  !ComData_GetL{comPtr_Link_DebugInfo_Byte   ,D0} : Ptr_Link_Debuginfo_Byte.l    = PutD0
  !ComData_GetL{comPtr_Use_Debugger_Byte     ,D0} : Ptr_Use_Debugger_Byte.l      = PutD0
  !ComData_GetL{comPtr_Autorun_Byte          ,D0} : Ptr_Autorun_Byte.l           = PutD0
  !ComData_GetL{comPtr_InterruptCheck_Byte   ,D0} : Ptr_Interruptcheck_Byte.l    = PutD0
  !ComData_GetL{comPtr_AssemblerCheck_Byte   ,D0} : Ptr_Assemblercheck_Byte.l    = PutD0
  !ComData_GetL{comPtr_OverflowCheck_Byte    ,D0} : Ptr_Overflowcheck_Byte.l     = PutD0
  !ComData_GetL{comPtr_MaxObjects_Value_Word ,D0} : Ptr_MaxObjects_Value_Word.l  = PutD0
  !ComData_GetL{comPtr_MaxObject_Pos_Word    ,D0} : Ptr_MaxObject_Pos_Word.l     = PutD0

  !ComData_GetW{comWord_CreateDebugFile      ,D0} : comWord_CreateDebugFile_Back.w = PutD0 ; get status of Create.dbg file  tomsmart1
  !ComData_GetB{comByte_FuncOptimize         ,D0} : comByte_FuncOptimize_Back.b    = PutD0 ; get status of Function Optimizer  tomsmart1
  StringbufferValue_Backup.l = Peek.l(Ptr_Stringbuffer_Long)              ;get sringbuffersize  tomsmart1
  StackSizeValue_Backup.l    = Peek.l(Ptr_Stacksize_Long)                 ;get stacksize  tomsmart1
Return

.RestoreCompilerSettings:
  GetD0 comWord_CreateDebugFile_Back : !ComData_SetW{comWord_CreateDebugFile,D0}   ;restore settings that not stored in the xtradata
  GetD0 comByte_FuncOptimize_Back    : !ComData_SetB{comByte_FuncOptimize   ,D0}   ;restore settings
  Poke.l Ptr_Stringbuffer_Long,StringbufferValue_Backup
  Poke.l Ptr_Stacksize_Long   ,StackSizeValue_Backup
  !asm
  !ComData_JSR{comFunc_RestoreXtraData}
  !basic
Return


.menu_compilersettings   ; was .newoptionsfunc

  Gosub BackupCompilerSettings    ; make a Backup of the active settings

  MaxLen a$ = 5000

  If ScreenHeight>400
    com_scr_y.w = ScreenHeight/6
    com_scr_h.w = ScreenHeight/1.5
  Else
    com_scr_y.w = -2
    com_scr_h.w = -2
  End If

  WZWindow WZID("WIN_CPREFS"),?wzgui,256,-2,com_scr_y,-2,com_scr_h,WZID("WIN_CPREFS")
  WZ_SetFont{"WIN_CPREFS"}
  WZ_InitTable{"WIN_CPREFS","OBJECTS",2,0}
  WZ_SetTableColors{"OBJECTS",1,0,2,3,3}

  ; Setzen der Spaltentitel fuer die erste Zeile
  WZ_SetTableTitle{"OBJECTS","Objects","Max"}

  ; Legt die Prioritaet der 6 Spalten fest
  WZ_SetPriority{"OBJECTS",3,1}

  ; Setzt die zweite Spalte der Tabelle "OBJECTS" auf nicht editierbar
  WZ_SetEditable{"OBJECTS",False,True}

  ; Sortieren verboten
  WZ_SetSortable{"OBJECTS",Off}

  ; Fuegt Zeilen an die Tabelle "OBJECTS" an
  For i.l = 0 To Peek.w(Ptr_Number_of_Objects_Word)-1
    a$ = ""
    GetD0 &a$,i
    !ComData_JSR{comFunc_GetObjectEntry}    ;stringaddress in d0 , indexnumber d1
    a.l = PutD0
    WZ_AddRow{"OBJECTS",Peek$(&a$),Str$(a)}
  Next
  WZ_DrawTable{"OBJECTS"}
  ; Fuellt die Tabelle mit den Werten, die mit WZAddRow{} erstellt wurden
  WZ_UpdateTable{"OBJECTS"}

  ;get Residents and convert it to a string
  var.l = Ptr_Residents_Table
  a$ = Peek$(var)              ; get first entry
  For i = 0 To 6               ; get up to 7 entry
    a$ = a$ + "\\0a"           ; added a newline
    var + #ResidentEntryStep   ; update pointer to the next entry
    a$ = a$ + Peek$(var)       ; added next entry
  Next
  WZPrint "RESIDENTS",&a$      ; print string in gadget

  WZPrint "STRINGBUFFER",StringbufferValue_Backup

  WZPrint "STACKSIZE",StackSizeValue_Backup                       ;print it  tomsmart1

; get and set status of the checkmarks
  If Peek.b(Ptr_Create_Iconfile_Byte)=-128
    WZPrint "ICON",1
  Else
    WZPrint "ICON",0
  EndIf

  If Peek.b(Ptr_Make_Smallestcode_Byte)=-128
    WZPrint "SMALLEST",1
    WZDisable "FUNCOPTIMIZE"                           ; added to prevent senceless settings  and possible endless compile runs tomsmart1
  Else
    WZPrint "SMALLEST",0
    WZEnable "FUNCOPTIMIZE"                            ; added  tomsmart1
  EndIf

  If Peek.b(Ptr_Link_Debuginfo_Byte)=-128
    WZPrint "DEBUGINFO",1
  Else
    WZPrint "DEBUGINFO",0
  EndIf

  WZPrint "FUNCOPTIMIZE",comByte_FuncOptimize_Back     ; show status in the GUI tomsmart1
  If comByte_FuncOptimize_Back = 0                     ; added to prevent endless compile runs  tomsmart1
    WZDisable "SMALLEST"
  Else
    WZEnable "SMALLEST"                                ; added  tomsmart1
  EndIf

  WZPrint "DBGFILE",comWord_CreateDebugFile_Back       ; show status in the GUI tomsmart1


  ;runtime Debugging
  If Peek.b(Ptr_Use_Debugger_Byte)=-128
    WZPrint "DEBUG",1
    WZEnable "AUTORUN"                                   ; enable all Debugger settings  tomsmart1
    WZEnable "CHECK_INTERRUPT"                           ;               "
    WZEnable "CHECK_ASSEMBLER"                           ;               "
    WZEnable "CHECK_OVERFLOW"                            ;               "
  Else
    WZPrint "DEBUG",0
    WZDisable "AUTORUN"                                  ; disable all Debugger settings  tomsmart1
    WZDisable "CHECK_INTERRUPT"                          ;                "
    WZDisable "CHECK_ASSEMBLER"                          ;                "
    WZDisable "CHECK_OVERFLOW"                           ;                "
  EndIf

  If Peek.b(Ptr_Autorun_Byte)=-128
    WZPrint "AUTORUN",1
  Else
    WZPrint "AUTORUN",0
  EndIf

  If Peek.b(Ptr_Interruptcheck_Byte)=-128
    WZPrint "CHECK_INTERRUPT",1
  Else
    WZPrint "CHECK_INTERRUPT",0
  EndIf

  If Peek.b(Ptr_Assemblercheck_Byte)=-128
    WZPrint "CHECK_ASSEMBLER",1
  Else
    WZPrint "CHECK_ASSEMBLER",0
  EndIf

  If Peek.b(Ptr_Overflowcheck_Byte)=-128
    WZPrint "CHECK_OVERFLOW",1
  Else
    WZPrint "CHECK_OVERFLOW",0
  EndIf


  ;Event handling of the compiler settings window
  CompilerSettingsWin_Exit.l  = False

  Repeat  ;new

    comsettings_ev.l = WaitEvent


    If onlinehelp <> 0
      If (comsettings_ev <> #IDCMP_INTUITICKS) AND (comsettings_ev <> #IDCMP_ACTIVEWINDOW) AND (comsettings_ev <> #IDCMP_GADGETHELP) AND (comsettings_ev <> #IDCMP_CHANGEWINDOW)
        WZ_HideHelp{}
      EndIf
      If comsettings_ev = #IDCMP_GADGETHELP Then WZ_ShowHelp{}
    EndIf


    WZ_CheckTableEvent{comsettings_ev} ; handel events of the objecttabel

    Select comsettings_ev  ; handel events of the rest of the window

       Case #IDCMP_CLOSEWINDOW
         CompilerSettingsWin_Exit = True
         Gosub RestoreCompilerSettings

       Case #IDCMP_VANILLAKEY
         If EventCode = #VANILLAKEY_ESC
           CompilerSettingsWin_Exit = True
           Gosub RestoreCompilerSettings
         EndIf

       Case #IDCMP_IDCMPUPDATE
         Select LCase$(WZGadName)

           Case "autorun"
             If WZInput
               Poke.b Ptr_Autorun_Byte,-128
             Else
               Poke.b Ptr_Autorun_Byte,0
             End If

           Case "check_interrupt"
             If WZInput
               Poke.b Ptr_Interruptcheck_Byte,-128
             Else
               Poke.b Ptr_Interruptcheck_Byte,0
             End If

           Case "check_assembler"
             If WZInput
               Poke.b Ptr_Assemblercheck_Byte,-128
             Else
               Poke.b Ptr_Assemblercheck_Byte,0
             End If

           Case "check_overflow"
             If WZInput
               Poke.b Ptr_Overflowcheck_Byte,-128
             Else
               Poke.b Ptr_Overflowcheck_Byte,0
             End If

           Case "residents"

           Case "stacksize"                                   ; stacksize changed  tomsmart1
             tempsize.l=WZInput                               ; save the valu to a temporay variable  tomsmart1
             If tempsize >= #MIN_STACKSIZE                    ; check size  tomsmart1
               Poke.l Ptr_Stacksize_Long,tempsize                     ; save it.  tomsmart1
             Else                                             ; its not big enough  tomsmart1
               tempsize = #MIN_STACKSIZE                      ; set it to the min size  tomsmart1
               Poke.l Ptr_Stacksize_Long,tempsize                     ; save it  tomsmart1
               WZPrint "STACKSIZE",tempsize                   ; print it  tomsmart1
             EndIf

           Case "stringbuffer"
             Poke.l Ptr_Stringbuffer_Long,WZInput

           Case "debug"
             If WZInput
               Poke.b Ptr_Use_Debugger_Byte,-128                           ; yes runtime Debugging
               WZEnable "AUTORUN"                             ; enable all Debugger settings  tomsmart1
               WZEnable "CHECK_INTERRUPT"                     ;               "
               WZEnable "CHECK_ASSEMBLER"                     ;               "
               WZEnable "CHECK_OVERFLOW"                      ;               "
             Else
               Poke.b Ptr_Use_Debugger_Byte,0                           ; no runtime Debugging
               WZDisable "AUTORUN"                            ; disable all Debugger settings  tomsmart1
               WZDisable "CHECK_INTERRUPT"                    ;                "
               WZDisable "CHECK_ASSEMBLER"                    ;                "
               WZDisable "CHECK_OVERFLOW"                     ;                "
             End If

           Case "icon"
             If WZInput
               Poke.b Ptr_Create_Iconfile_Byte,-128
             Else
               Poke.b Ptr_Create_Iconfile_Byte,0
             End If

           Case "smallest"
             If WZInput
               Poke.b Ptr_Make_Smallestcode_Byte,-128
               WZDisable "FUNCOPTIMIZE"
             Else
               Poke.b Ptr_Make_Smallestcode_Byte,0
               WZEnable "FUNCOPTIMIZE"
             End If

           Case "debuginfo"                                      ; check "Create Debug info" (Symbols)
             If WZInput
               Poke.b Ptr_Link_Debuginfo_Byte,-128
             Else
               Poke.b Ptr_Link_Debuginfo_Byte,0
             End If

           Case "funcoptimize"                                   ; check "Use Function Optimizer"   tomsmart1
             If WZInput
               !ComData_SetB{comByte_FuncOptimize,#1}            ; yes we use it  tomsmart1
               WZEnable "SMALLEST"
             Else
               !ComData_SetB{comByte_FuncOptimize,#0}            ; no we don't  tomsmart1
               WZDisable "SMALLEST"
             EndIf

           Case "dbgfile"                                        ; check "Create .dbg File"   tomsmart1
             If WZInput
               !ComData_SetW{comWord_CreateDebugFile,#1}         ; yes we create it  tomsmart1
             Else
               !ComData_SetW{comWord_CreateDebugFile,#0}         ; no we don't  tomsmart1
             EndIf

          ;check main window buttons
           Case "cancel"
            CompilerSettingsWin_Exit = True
            Gosub RestoreCompilerSettings


           Case "ok"
            CompilerSettingsWin_Exit = True
            Gosub UseMaxObjectsAndResidentsSettings

         End Select

    End Select

  Until CompilerSettingsWin_Exit

  WZ_KillTable{"OBJECTS"}
  WZCloseWindow WZID("WIN_CPREFS")
  FlushEvents
  Gosub activatesourcewindow
Return


.UseMaxObjectsAndResidentsSettings:
  ; update save max objects settings  tomsmart1 2012 03 21
  For i.l = 1 To Peek.w(Ptr_Number_of_Objects_Word)
    a$ = WZ_GetCell{"OBJECTS",i,2}
    i2.l = Vallong(a$) : If i2 = 0 Then i2 = 1
    Poke.w Ptr_MaxObjects_Value_Word,i2
    Poke.w Ptr_MaxObject_Pos_Word   ,i-1
    !ComData_JSR{comFunc_StoreMaxObjects}
  Next

  ; the compiler have to free all loaded residents and to clear the space for safty  tomsmart1 2012 06 09
  !asm
  !ComData_JSR{comFunc_FreeClearResidentsForPED}
  !basic

  ; convert strings to Residents entrys  tomsmart1 2012 03 21
  i.l = WZInput("RESIDENTS")
  a$ = Peek$(i)
  InitArgParse a$
  var.l = Ptr_Residents_Table
  For i = 0 To 7
    p$ = NextArgChar$ ($a)
    Poke$ var,p$
    var + #ResidentEntryStep
  Next

  ; the compiler have to reload the residents   tomsmart1 2012 03 21
  !asm
  !ComData_JSR{comFunc_ReloadResidentsForPED}
  !basic
Return
;####################################################################
; END routines compiler settings window  tomsmart 2012 03 21       #
;####################################################################


;######################################################################
;# BEGIN        routines for the compile status Window                #
;#                                                                    #
;#   moved form the compiler to Ped and modified by tomsmart 20120224 #
;######################################################################
.Open_CompileStatus_Window:                                             ; open the compile status window
  Select CompileMenuCallID

    Case #MENU_RUN              ; we don't need to open the window
    Case #MENU_CREATEDEBUGCODE  ;   "
    Case #MENU_RELOAD_USERLIBS  ;   "

    Default
     If CompileStatusWindow_Pointer.l = 0
       WZWindow WZID("WIN_COMPILESTATUS"),?wzgui,64,-2,-2,-2,-2,WZID("WIN_COMPILESTATUS") ; try to open the wizard window
       CompileStatusWindow_Pointer = Peek.l(Addr Window(WZID("WIN_COMPILESTATUS")))       ; get and store the pointer to window
       ;set init data for the update of the status gadgets
       CompileStatus_String_Pointer.l            = Peek.l(?comPtr_CompileStatusString)    ; get the pointer of status string set by the compiler
       CompileStatus_CalculatedProcent_Pointer.l = Peek.l(?comPtr_CompileCalcProLong)     ; get the pointer of calculated procent value set by the compiler
       CompileStatus_String_Old.s                = ""                            ; set to default
       CompileStatus_CalculatedProcent.l         = 0                             ; set to default
       CompileStatus_CalculatedProcent_Old.l     = 0                             ; set to default
       CompileStatus_GaugeString.s               = "0%%"                         ; set to default
       CompileStatusWindow_Event.l               = 0

       ;set init data for the abort handling
       Poke.b ?comByte_CompileStatusAbortByte,0                                ; set default
       CompileStatusWindow_Abort.l = False                                     ; abort status default for the event loop

       ;print initstring
       If CompileStatusWindow_Pointer <> 0                                     ; check if window is open
         CompileStatus_String_Old = !TRANS{"Initializing Compiler..."}         ; set the init string
         WZPrint "COMPILE_INFO",CompileStatus_String_Old                       ; show the init string
       EndIf

     EndIf

  End Select
Return


.Update_CompileStatus_Window:                                             ; update the compile status window
  !regs2stack
  !basic
  If CompileStatusWindow_Pointer <> 0                                     ; check if window is open
    CompileStatusWindow_Event = Event                                     ; get the event
    ;update gadgets if needed
    CompileStatus_String_Pointer = Peek.l(?comPtr_CompileStatusString)
    If CompileStatus_String_Pointer <> 0                                  ; check if pointer is set
      If (CompileStatus_String_Old <> Peek.s(CompileStatus_String_Pointer)) ; check is status sting changed => Print it
        CompileStatus_String_Old = Peek.s(CompileStatus_String_Pointer)
        WZPrint "COMPILE_INFO",CompileStatus_String_Pointer
      End If
    EndIf

    CompileStatus_CalculatedProcent_Pointer = Peek.l(?comPtr_CompileCalcProLong)  ; get the pointer of calculated procent value set by the compiler
    If (CompileStatus_CalculatedProcent_Pointer <> 0)                     ; check if pointer is set
       CompileStatus_CalculatedProcent = Peek.l(CompileStatus_CalculatedProcent_Pointer)  ; get the value
      If (CompileStatus_CalculatedProcent >< CompileStatus_CalculatedProcent_Old) ; check if procent value changed => update gauge
         CompileStatus_CalculatedProcent_Old = CompileStatus_CalculatedProcent
         If (((CompileStatus_CalculatedProcent & $3)=0) OR (CompileStatus_CalculatedProcent=100))
            CompileStatus_GaugeString = Str$(CompileStatus_CalculatedProcent)+"%%"
            WZPrint "COMPILE_GAUGE",CompileStatus_CalculatedProcent,100,&CompileStatus_GaugeString
         End If
      End If
    EndIf
   ;test abort button (instead of a separte routine)

    If RawKeyState(#RAWKEY_ESC)
      Poke.b ?comByte_CompileStatusAbortByte,1                            ; set abort condition
    Else
      While (CompileStatusWindow_Event <> 0)
        If ( (CompileStatusWindow_Event = #IDCMP_IDCMPUPDATE) AND (CompileStatusWindow_Abort = False) ) ; go if a event happend and the button are not allready pressed
          If WZGadName = "COMPILE_ABORT"                                  ; check if "Abort" gadget is pressed
             Poke.b ?comByte_CompileStatusAbortByte,1                     ; set abort condition
             CompileStatusWindow_Abort = True                             ; set abort condition so the event checking can skiped if a next window update is happend befor the abort is handeled by the compiler
          EndIf
        EndIf
        CompileStatusWindow_Event = Event                                 ; get next event
      Wend
    EndIf
    FlushEvents
  EndIf
  JSR print_availmem
  !asm
  !stack2regs
RTS


.Close_CompileStatus_Window:                                            ; close the compile status window
  If CompileStatusWindow_Pointer<>0
    WZCloseWindow WZID("WIN_COMPILESTATUS")                             ;turn off the requester
    CompileStatusWindow_Pointer             = 0                         ;set pointer to 0 because we close the window
    CompileStatus_String_Pointer            = 0
    CompileStatus_CalculatedProcent_Pointer = 0                         ;set pointer to 0 because we close the window
  EndIf
Return
;######################################################################
;# END          routines for the compile status Window                #
;######################################################################


; ---------------------------------------------------------------------
; Declarations of Variables
; ---------------------------------------------------------------------
.DECLARATIONS
wzgui:                IncBin "ped.wizard"

instring              Dc.b 0
instring2             Dc.b 0
instring3             Dc.b 0
historypointer:       Dc.l 0
oldsearch             Dc.w 0
ptr_deflibsfilename   Dc.l 0
ptr_incdirname        Dc.l 0

.classiccommands
                      ; memory reservations for libs that where introduced with old blitz2
                      ; here come whole libs
                      Dc.w 11    ; Ricopperfxlib.obj
                      Dc.w 45    ; Risoundlib.obj
                      Dc.w 56    ; Xbciatrackerlib.obj
                      Dc.w 60    ; loadpt
                      Dc.w 82    ; medlib
                      Dc.w 96    ; trackerlib
                      Dc.w 98    ; blitzkeyslib
                      Dc.w 112   ; spriteslib
                      Dc.w 113   ; cd32lib
                      Dc.w 116   ; audiolib
                      Dc.w 117   ; blitzoslib
                      Dc.w 119   ; 2dlib
                      Dc.w 143   ; displaylib
                      Dc.w 144   ; blitzcoplib
                      Dc.w 146   ; bblitlib
                      Dc.w 148   ; qblitlib
                      Dc.w 150   ; blitlib
                      Dc.w 152   ; freqlib
                      Dc.w 156   ; palettelib
                      Dc.w 190   ; gameiolib
                      Dc.w 204   ; bfbplaymaster.library1
                      Dc.w 209   ; thxplay.library1

                      Dc.w 0     ;say end
                                 ;set breakpoint
                      Dc.w $3385 ;timer commands here come single commands
                      Dc.w $2588 ;timer
                      Dc.w $1784 ;timer
                      Dc.w $4d08 ;get a shape

                      Dc.w 0     ;say end
classiccolor          Dc.l 1
olddebugmode          Dc.w $0101
cutmode               Dc.w 0
dummystr              Dc.b ":",0,0 : Even

BSS
Even
;foundf                Ds.w 1
;foundf2               Ds.w 1
;clone_wbscreen        Ds.b 1
;no_welcome            Ds.b 1
tokenbackground       Ds.l 1
;use_wbscreen          Ds.b 1
;no_scrollrate         Ds.b 1
loadAsNew             Ds.w 1
nodelete              Ds.w 1
menuload              Ds.w 1
replacestartcolumn    Ds.w 1
fontWidth             Ds.w 1
messagestore          Ds.l 1
ctrlhelpline          Ds.l 1                ; insert text into sourcetext?
oldcolumnsoffset      Ds.w 1
VerticalCopyMode      Ds.b 1                ; was firstcolumn  renamed to match is new purpos tomsmart1
redraw_ped            Ds.b 1
foldnum               Ds.l 1
VerticalPasteMode     Ds.w 1                ; was pastecolumn  renamed to match is new purpos  tomsmart1
tempstore             Ds.l 1
typestr               Ds.b 80
colstore              Ds.w 1
storeline1            Ds.l 1
storeline2            Ds.l 1
storeline3            Ds.l 1
lastedited_line       Ds.l 1
;templine              Ds.l 1
semipos               Ds.w 1
ptr_source_dir        Ds.l 1
amigaguide            Ds.w 1
smart_tokenization    Ds.b 1
textlinestart         Ds.l 1
doedit2               Ds.b 1
is_stat_func_macro    Ds.b 1                ; labellist identifier for statement, function or macro  tomsmart1 ; was isfunction
keepstring            Ds.b 1
new_editmode          Ds.b 1
newtypecolor          Ds.l 1
stringcolor           Ds.l 1
macrocolor            Ds.l 1
constantcolor         Ds.l 1
functioncolor         Ds.l 1
macro_                Ds.w 1
backgroundcolor       Dc.l 0
helpstring            Ds.b 260
searchmode            Ds.w 1
columnstore           Ds.w 1
ab2mode               Ds.w 1
slen2                 Ds.l 1
straddr2              Dc.l 0
straddr               Dc.l 0
numcount              Dc.l 0
constantbase          Dc.l 0
newtypebase           Dc.l 0
newsyntax             Dc.l 0
nohelp                Dc.l 0
str_oldsearchgadget   Ds.b 260
instrtab              Ds.l 32769
newted                Dc.l 0
message_qualifier     Dc.l 0
message_code          Dc.l 0
message_class         Dc.l 0
olda4                 Dc.l 0
history               Ds.l 10
tempbuf               Ds.b 260
convert               Dc.b 0
instru                Ds.w 1
chartab               Ds.b 260      ;last
lowerchartable        Ds.l 1
casemode              Ds.w 1
temp                  Ds.w 1
namesizestore         Ds.l 1
nodisplaybeep         Ds.l 1
refreshonstore        Ds.w 1        ; zuruecksetzen von PED beim Speichern der Preferences
deftypefound          Ds.w 1
linenumbers           Dc.b 0
;pos_vertiprop         Ds.w 1       ; obsolete
pos_horizprop         Ds.w 1
blockmarking          Dc.l 0
load_last_source      Dc.b 0
wheelstep             Ds.l 1        ; moved to BSS section because it is now set by init with a default of 6 if it not set in the Icontooltypes  tomsmart1
use_commandsintellisens      Dc.b 0      ; added   tomsmart1
