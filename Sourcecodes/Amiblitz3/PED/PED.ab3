; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Development:AmiBlitz3/System"
; ExeFile         = "PED"
; CreateIcon      = 0
; Residents       = "all_new.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 64000
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 3.9.9
; NumberOfBuilds  = 3135
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8192
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 15469
; CursorColumn    = 36
; LabelSearch     = "linestr"
; LabelRemark     = 0
; LabelAll        = 0
; LabelCase       = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 25
; Max GadgetList  = 5
; Max Shape       = 100
; Max Bank        = 5
; Max MenuList    = 5
; Max GTList      = 25
; Max Palette     = 4
; Max BitMap      = 1
; Max Screen      = 5
; Max IntuiFont   = 5
; Max BlitzFont   = 4
; Max Window      = 25
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/ Name: PED                                                                   /
;/                                                                             /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, AmigaOS4, MOS                         /
;/                                                                             /
;/ Date: 01.07.2022                                                            /
;/                                                                             /
;/ Authors: 1990...1996 Mark Silby                                             /
;/          1991...2003 Red When Excited                                       /
;/          2003...2009 Bernd Roesch, Sven Droege                              /
;/          2009...     The Opensource Team                                    /
;/          2019...     Sven Droege                                            /
;/                                                                             /
;/ Requirements: AmigaOS 2.05+                                                 /
;/                                                                             /
;/ Purpose:                                                                    /
;/ GUI for AmiBlitz3 programming language.                                     /
;/                                                                             /
;/ Abstract:                                                                   /
;/ This is not a stand alone program. It is launched by the AmiBlitz3 compiler./
;/ See AmiBlitz3 abstract.                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
DEBUG
; -------------------------------------------------------
; KONSTANTENDEFINITIONEN
; -------------------------------------------------------
.CONST

#USE_AREXX           = 1     ; include the arrexport?

#USE_WIZARD          = 1     ; use wizard library?
#WZ_USE_IMAGES       = 0     ; use pictures in tables
#WZ_singletable      = 1     ; only one table at the same time

#maxlabels           = 512
#maxhistory          = 8
#MAX_SOURCEFILES     = 16
#MAX_MENUTEMPLATES   = 16    ; max custom menuentries
#slowdown            = 0     ; reduce scrolling speed (for very fast machines)
#hardfold            = 0     ; not working
#leftoffset          = 1     ; startpos of filename tabs
#bevelsize           = 11    ; size of filename tabs


; -- OS version to enable/disable various features
#AmigaOS3 = 1
#AmigaOS4 = 2
#MorphOS  = 3
#AROS     = 4

; -- for gotoline
#LINE_START = 1
#LINE_END = 2

; -- for slider gadgets
#GID_XPROP  =900
#GID_YPROP  =901
#GID_RARROW =910
#GID_LARROW =911
#GID_UARROW =912
#GID_DARROW =913
#max_slider_res = $7FFF

; -- PED Errors
#PEDERROR_NOERROR        = $0000
#PEDERROR_OPENSCREEN     = $1001
#PEDERROR_OPENPUBSCREEN  = $1002
#PEDERROR_OPENWINDOW     = $1011

; -- Tokens IDs
#TOKEN_End       = $8002
#TOKEN_Return    = $8007
#TOKEN_Statement = $8008
#TOKEN_Function  = $8009
#TOKEN_If        = $800B
#TOKEN_While     = $800C
#TOKEN_Macro     = $800D
#TOKEN_Select    = $800E
#TOKEN_Case      = $800F
#TOKEN_For       = $8016
#TOKEN_Then      = $8021
#TOKEN_Stop      = $802D
#TOKEN_TRAP      = $80AE
#TOKEN_Repeat    = $80BB
#TOKEN_EndIf     = $80C0
#TOKEN_Object    = $80D7
#TOKEN_DEFTYPE   = $8033

; -- scrolling options for sourceWindow
#SCROLL_UP       = 1
#SCROLL_DOWN     = -1
#SCROLL_LEFT     = 1
#SCROLL_RIGHT    = -1
#SCROLL_CURRENT_LINE = 1

; -- Keycodes
; Raw
#RAWKEY_TAB        = $42
#RAWKEY_RETURN     = $44
#RAWKEY_ESC        = $45
#RAWKEY_UP         = $4C
#RAWKEY_DOWN       = $4D
#RAWKEY_RIGHT      = $4E
#RAWKEY_LEFT       = $4F
#RAWKEY_F1         = $50
#RAWKEY_F10        = $59
#RAWKEY_HELP       = $5F

; Vanilla
#VANILLAKEY_BACKSPACE = $08
#VANILLAKEY_TAB    = $09
#VANILLAKEY_RETURN = $0D
#VANILLAKEY_ESC    = $1B
#VANILLAKEY_UP     = $1C
#VANILLAKEY_DOWN   = $1D
#VANILLAKEY_RIGHT  = $1E
#VANILLAKEY_LEFT   = $1F
#VANILLAKEY_DELETE = $7F
#VANILLAKEY_F1     = $81
#VANILLAKEY_F2     = $82
#VANILLAKEY_F3     = $83
#VANILLAKEY_F4     = $84
#VANILLAKEY_F5     = $85
#VANILLAKEY_F6     = $86
#VANILLAKEY_F7     = $87
#VANILLAKEY_F8     = $88
#VANILLAKEY_F9     = $89
#VANILLAKEY_F10    = $8A
#VANILLAKEY_HELP   = $8B


;/* Project */
#MENU_PROJECTSETTINGS     = $00000132
#MENU_IDEPREFERENCES      = $00000073
#MENU_AUTOLAYOUT          = $00000075
#MENU_GETLAYOUT1          = $00000171
#MENU_GETLAYOUT2          = $00000172
#MENU_GETLAYOUT3          = $00000173
#MENU_SETLAYOUT1          = $00000174
#MENU_SETLAYOUT2          = $00000175
#MENU_SETLAYOUT3          = $00000176
#MENU_CUSTOMEDIT          = $00000259
#MENU_OPENWORKBENCH       = $0000006F
#MENU_CLOSEWORKBENCH      = $00000070
#MENU_OPENSHELL           = $00000072
#MENU_CALCULATOR          = $00000057
#MENU_ABOUT               = $00000074
#MENU_ICONIFY             = $00000071
#MENU_QUIT                = $0000006D

;/* Source */
#MENU_NEW                 = $00000065
#MENU_OPEN                = $00000067
#MENU_OPENNEW             = $00000066
#MENU_INCLUDEFILE         = $00000068
#MENU_SAVE                = $00000069
#MENU_SAVEAS              = $0000006A
#MENU_EXPORTASCII         = $0000006B
#MENU_PRINT               = $0000006E
#MENU_CLOSE               = $0000006C

#MENU_LASTSOURCE1         = $00000078
#MENU_LASTSOURCE2         = $00000079
#MENU_LASTSOURCE3         = $0000007A
#MENU_LASTSOURCE4         = $0000007B
#MENU_LASTSOURCE5         = $0000007C
#MENU_TEMPLATE            = $00000200

;/* Edit */
#MENU_CUT                 = $000000C9
#MENU_COPY                = $000000CA
#MENU_PASTE               = $000000CB
#MENU_DUPLICATE           = $000000D8
#MENU_FORGET              = $000000CC
#MENU_KILL                = $000000D7
#MENU_SAVEBLOCKAS         = $000000CD
#MENU_INSERTLINE          = $000000CE
#MENU_DELETELINE          = $000000CF
#MENU_UNDELETELINE        = $000000D0
#MENU_JOINLINES           = $000000D1
#MENU_DELETETOEOL         = $000000D9
#MENU_BLOCKTAB            = $000000D2
#MENU_BLOCKUNTAB          = $000000D3
#MENU_BLOCKCOMMENT        = $000000D4
#MENU_BLOCKUNCOMMENT      = $000000D5
#MENU_MARKINDENT          = $000000D6
#MENU_INSERTFILENAME      = $00001000
#MENU_OPENFILEUNDERCURSOR = $00001001

;/* Naviagation */
#MENU_OPENFIND            = $00000191
#MENU_FIND                = $00000192
#MENU_PREVIOUS            = $00000193
#MENU_REPLACE             = $00000194
#MENU_TOP                 = $0000012D
#MENU_BOTTOM              = $0000012E
#MENU_GOTOLINE            = $0000012F
#MENU_PREVPAGE            = $00000130
#MENU_NEXTPAGE            = $00000131

;/* Compiler */
#MENU_COMPILERUN          = $00000050
#MENU_SAVECOMPILERUN      = $0000005C
#MENU_RUN                 = $00000051
#MENU_CREATEEXE           = $00000052
#MENU_SAVECREATEEXE       = $0000005B
#MENU_CREATERELEASEEXE    = $0000005E
#MENU_CREATERESIDENT      = $00000054
#MENU_SETCLIARGS          = $00000056
#MENU_RELOAD_USERLIBS     = $00000058
#MENU_COMPILERSETTINGS    = $00000053
#MENU_CREATEDEBUGCODE     = $0000005D

;/* Help */
#MENU_WHATSNEW            = $000001F0
#MENU_GENERALGUIDE        = $000001F1
#MENU_PROGRAMGUIDE        = $000001F2
#MENU_INCLUDEGUIDE        = $000001F4
#MENU_BLITZLIBSGUIDE      = $000001F3
#MENU_SHORTCUTREFERENCE   = $000001F6
#MENU_INSTRUCTIONBROWSER  = $000001F5
#MENU_SOURCEBROWSER       = $00000059
#MENU_DEFINITIONBROWSER   = $00000055
#MENU_LIBRARYBROWSER      = $000001F7
#MENU_UPDATEHELPINDEX     = $000001F8

;/* Custom */
#MENU_CUSTOMITEM1         = $00000260      ; must be greater than #MENU_CUSTOMEDIT because hat now its own ID  tomsmart1

;---------------







;@@1
!initasm
!basic
OPTIMIZE 5
SYNTAX 6
; ---------------------------------------------------- ADD INCLUDEFILES
; ------------------------------------------------------
#use_bbscreen      = 0     ; workaround for screen_close crash   (->screeen.include)
#USE_WBSTARTUPMSG  = 0
#CLIARGMODE        = 0     ; OS-Calls

XINCLUDE "/BlitzLibs/Residents/blitzbasic/libnums.ab3"
XINCLUDE "/Shared/library_offsets.ab3"      ; only for Macro newalloc
XINCLUDE "/Shared/common.ab3"
XINCLUDE "/Shared/preprocessor.include.ab3" 
XINCLUDE "/Shared/ted.include.ab3"
DEFTYPE.tokendata *tokenbase
DEFTYPE.l *macrobase
DEFTYPE.l *newtypebase
DEFTYPE.l *constantbase
DEFTYPE.l *varbase

;XINCLUDE "eclock.include.ab3"
XINCLUDE "v43+.definitions.ab3"                       ; for MouseWheel support  tomsmart1
XINCLUDE "dos.include.ab3"
XINCLUDE "file.include.ab3"
XINCLUDE "asl.include.ab3"
XINCLUDE "clipboard2.include.ab3"
XINCLUDE "translation.include.ab3"
XINCLUDE "vvblank.include.ab3"

; --------------------------------------------------- Wizard-Extensions
OPTIMIZE 5 : SYNTAX 6
XINCLUDE "PE/wizard_Tools.include.ab3"
XINCLUDE "PE/wizard_Table.include.ab3"
XINCLUDE "PE/wizard_ColorWheel.include.ab3"
ColorWheelError.b = False

; --------------------------------------------------- LOGGING
.LOGGING
XINCLUDE "logging.include.ab3"
log_Init{"CON:0/19/1200/200/AmiBlitz3 Log"}
log_SetLevel{#log_nothing}
log_SetDestination{#log_toconsole,"System/PED.log"}
log_Print{"===================================================================",#log_debug}
!log_AvailMem{"BEGIN"}


; --------------------------------------------------- AREXX
CNIF #USE_AREXX = 1
XINCLUDE "arexx.include.ab3"
Dim registeredArexxHosts$(8)
CEND


; --------------------------------------------------- TYPE DEFINITIONS
.TYPES
DEFTYPE.l quicktype
DEFTYPE.l


Macro PED_CheckUnAllowedChar
  Peek.b(?chartab + `1)
End Macro

Macro mul48f
  _floattemp.f = (`1)
  _floattemp = _floattemp * (`2)
  _floattemp = _floattemp / (`3)
  `4 = Int(_floattemp + .5)
End Macro


NEWTYPE.readcache
  *fib.FileInfoBlock

  filehandle.l
  filelen.l

  bufferptr.l       ; pointer to memarea allocated for cache
  bufferoffset.l    ; current read byte in buffer

  cacheptr.l
  cachelen.l
  offset.l
  currentbyte.b

  readlen.l
  chunklen.l
  blocklen.l

  *cH.clipboardHandle
  cb_linecount.l
  cb_eol.b

  mode.b           ; PasteMode: File or Clipboard
  moreBytes.b
End NEWTYPE
DEFTYPE.readcache readcache



NEWTYPE.pedconfig
  no_welcome.b
  ask_before_quit.b
  load_last_source.b
  remember_saved.b

  no_display_beep.b
  use_pubscreen.b
  use_wbscreen.b
  use_default_pubscreen.b
  use_wbfont.b
  clone_wbscreen.b

  auto_indent.b
  auto_format.b
  auto_constructs.b
  correct_functions.b
  use_source_icon.b
  use_commandsintellisens.b
  intellisense.b
  localization.b
  onlinehelp.b
  onlinehelp_extended.b
  onlinehelp_includes.b
  HelpForPrivateFunctions.b

  smart_tokenization.b
  highlighting.b

  linenumbers.b
  cursorStyle.b
  blinkrate.b
  italic_remarks.b
  bold_tokens.b
  tabSize.w

  autolayout.b
  al_leftspace.w
  al_topspace.w
  al_rightspace.w
  al_bottomspace.w

  scroll_rate.b
  wheelStep.l

  console_device.s
  console_title.s
  console_font.s
  console_wb.b
  console_wait.b

  screen_modeID.l
  screen_Height.l
  screen_Width.l
  screen_Depth.l

  use_filepattern.b
  asl_use_dims.b
  asl_x.w          ; asl-requester dims
  asl_y.w
  asl_w.w
  asl_h.w

  sort_labels.b

  rememberFile.s
  lastSourceFile.s
  menuFile.s
  winprefsFile.s

  HelpIndexFile.s
  HelpIndexCacheFile.s

  mainDir.s
  systemDir.s
  blitzlibDir.s
  includeDir.s
  autodocDir.s
  helpDir.s
  sourceDir.s

  useBaseLib.b
  useUtilLib.b
  useOsLib.b
  useCsLib.b

  baselibFile.s
  utillibFile.s
  oslibFile.s
  cslibFile.s

End NEWTYPE
DEFTYPE.pedconfig pedconfig

NEWTYPE.ped
  taskWinPtr.l                           ; save possibly set window to thisTask
  *screen.Screen
  *menuStrip.Menu

  mempool.l
  tokenCache.l
  errorCode.w

  currentDir.s
  currentFile.s
  filePattern.s
  sourceFileComplete.s
  amiblitzmode.b

  check_existsfile.b
  extention_info.s
  extention_xtra.s
  extention_bak.s

  *firstSourceEntry.sourceEntry
  *currentSourceEntry.sourceEntry
  *firstLoadedEntry.sourceEntry

  *ptrCurrentSourceData.sourceEntry       ; needed as long as comPtr_CurrentSourceLine ist converted

  sourceFileHandle.l
  inString.b
  keepString.b
  convert.b
  DoTokenize.w
  amigaguide.b
  debugMode.b

  caseSensitive.b

  lastAutoLayout.b
  lastLayout.b
  pubScreenNumber.s
  pubscreenName.s
  defaultPubscreenName.s
  defaultScreenTitle.s


  ;-- Definitionbrowser
  definitionMode.b
  structLevel.b
  lastStructLevel.b
  currentConstantStr.s
  currentVariableStr.s
  currentNewtypeStr.s
  previousNewtypeStr.s
  lastConstantStr.s
  lastVariableStr.s
  lastNewtypeStr.s

  ;-- biglibs data
  baselibFileSize.l
  baselibFileDate.s
  utillibFileSize.l
  utillibFileDate.s
  oslibFileSize.l
  oslibFileDate.s
  cslibFileSize.l
  cslibFileDate.s

  LabelIdentifier.b
  LabelListChanged.w
  LabelIsFunction.b
  labelSearchMode.b

  verticalCopyMode.b
  verticalPasteMode.b
  pasteMode.b
  cutMode.b
  blockmarkRemovalMode.b

  undeleteStrLen.w
  no_scrollrate.b
  foldNumber.l

  historyPointer.l
  historyTable.l[#maxhistory]

  ptrTextbufferPrint.l
  ptrLineUndeleteStore.l
End NEWTYPE
DEFTYPE.ped ped

; -- set initial source metadata
ped\ptrCurrentSourceData = ?comLongLong_XtraBegin
ped\LabelIdentifier = Peek.b(?comByte_LabelIdentifier)
ped\check_existsfile = False
ped\extention_info = ".info"
ped\extention_xtra = ".xtra"
ped\extention_bak = ".bak"
ped\filePattern = "(#?.bb|#?.bb2|#?.asm|#?.ab2|#?.ab3|#?.txt|#?.guide)"

NEWTYPE.sourceWindow
  *pedScreen.Screen
  *drawinfo.DrawInfo
  *win.Window
  *rp.RastPort
  *vertiprop.Gadget
  *horizprop.Gadget

  *font.TextFont
  *fontI.TextFont
  *fontB.TextFont

  redrawFlag.b
  deleteMode.b

  statusAreaY.w
  visibleLines.l
  visibleColumns.w

  boundLinesX.w
  boundLinesY.w
  scrollSize.w

  WinLeft.w                      ; store window dimensions
  WinTop.w
  WinWidth.w
  WinHeight.w

  BoxLeft.w
  BoxTop.w
  BoxWidth.w
  BoxHeight.w
 
  cursorState.b
  ColumnsOffsetStore.w

  lastEditedLine.l
  bookmarkLine1.l
  bookmarkLine2.l
  bookmarkLine3.l

  Title.s
End NEWTYPE
DEFTYPE.sourceWindow sourceWindow
DEFTYPE.RastPort *sourcerp

NEWTYPE.bmark
  xMin.w
  yMin.l
  xMax.w
  yMax.l
End NEWTYPE
DEFTYPE.bmark bmark
;DEFTYPE.bmark BlockDims
DEFTYPE.bmark oldBlockDims

NEWTYPE.mousePos
  X.w
  Y.w
  textX.w
  textY.w
End NEWTYPE
DEFTYPE.mousePos mousePos

NEWTYPE.project
  name.s
  drawer.s
  wizardfile.s
  sourcefile.s[#MAX_SOURCEFILES]
  sourcepath.s[#MAX_SOURCEFILES]
  sourcecounter.b
  pad.b         ; make it even
  ;
  version.w
  revision.w
  ;
  use_wbstartup.b
  use_nocli.b
  use_syntax.b
  use_optimize.b
  value_syntax.b
  value_optimize.b
End NEWTYPE
DEFTYPE.project ab2_project
Dim tempproject$(#MAX_SOURCEFILES,1)
MaxLen project_changelog$         = 1024


Dim rememberfiles$(5)

NEWTYPE .pedfilelist
 dummy.b[$DE]
 filename.s
End NEWTYPE

NEWTYPE .winprefs
  diag_x.w
  diag_y.w
  diag_w.w
  diag_h.w
  diag_on.b

  click_x.w
  click_y.w
  click_w.w
  click_h.w
  click_on.b

  ibrowser_x.w
  ibrowser_y.w
  ibrowser_w.w
  ibrowser_h.w
  ibrowser_on.b

  type_x.w
  type_y.w
  type_w.w
  type_h.w
  type_on.b
  activewin.b

  source_x.w
  source_y.w
  source_w.w
  source_h.w

  short_x.w
  short_y.w
  short_w.w
  short_h.w
  short_on.b

  lbrowser_x.w
  lbrowser_y.w
  lbrowser_w.w
  lbrowser_h.w
  lbrowser_on.b

  console_x.w
  console_y.w
  console_w.w
  console_h.w
  console_on.b
End NEWTYPE
Dim wpref.winprefs(3)
DEFTYPE.winprefs wtemp

NEWTYPE.custommenu
  itemname.s
  shortcut.s
  id.l
  path.s
  runwbmode.l
  stacksize.l
  prio.l
End NEWTYPE
Dim List custommenu.custommenu(0)

NEWTYPE.templates
  filename.s
  description.s
End NEWTYPE
Dim List templates.templates(0)

; temporary list for browsefile creation
NEWTYPE.dirs
  name.s
End NEWTYPE
Dim List dirs.dirs(0)

Dim diag_lab$(15)
Dim diag_val$(15)

; --------------------------- Color settings --------------------------
#AB3_cfunction         = 1
#AB3_cmacro            = 2
#AB3_cstring           = 3
#AB3_cnewtype          = 4
#AB3_cconstant         = 5
#AB3_cremarkforeground = 6
#AB3_cremarkbackground = 7
#AB3_ctoken            = 8
#AB3_ctokenbackground  = 9
#AB3_cbackground       = 10
#AB3_cother            = 11
#AB3_cclassic          = 12

#AB3_screenback        = 20
#AB3_screentext        = 21
#AB3_screenshine       = 22
#AB3_screenfill        = 23
#MAX_AB3Pens           = 24     ; added to replace Array dimension and maxindex for loops  tomsmart1
Dim AB3Pen.w(#MAX_AB3Pens)
Dim AB3RGB.l(#MAX_AB3Pens)
Dim AB3RGB_temp.l(#MAX_AB3Pens)
AB3RGB_copytemp.l = 0           ; added for temporary copy of the select color  tomsmart1


; --------------------------- Cursor modes -----------------------------
#AB3_cursorStyle_block      = 0
#AB3_cursorStyle_line       = 1
#AB3_cursorStyle_underline  = 2

Function.s cursorStyleGetString{value.w}
  Select value
  Case #AB3_cursorStyle_block
    Function Return "block"
  Case #AB3_cursorStyle_line
    Function Return "line"
  Case #AB3_cursorStyle_underline
    Function Return "underline"
  Default
    Function Return "block"
  End Select
End Function

Function.w cursorStyleGetValue{stylestring.s}
  Select LCase$(stylestring)
  Case "block"
    Function Return #AB3_cursorStyle_block
  Case "line"
    Function Return #AB3_cursorStyle_line
  Case "underline"
    Function Return #AB3_cursorStyle_underline
  Default
    Function Return #AB3_cursorStyle_block
  End Select
End Function
; -----------------------------------------------------------------------

SHARED num_operators.b  : num_operators = 0
Restore key_chars
Repeat
  Read key_char$
  If key_char$<>""
    Dim KEEP operators$(num_operators)                  ; array to store characters to structurize (auto_format-option)
    operators$(num_operators) = key_char$
    num_operators + 1
  EndIf
Until key_char$ = ""
key_chars:
Data.s "=",":","<",">","+","-","/","*","&","|",";",""

CaseSense Off

browse_macros.l           = Off
browse_instructions.l     = On
browse_includes.l         = Off

; for listtype window
Dim pos2(15),pos$(15),postype$(15)

MaxLen a$                 = 300      ;need for read .xtra
a$ = ""


;-- for Macro PED_LoadSsource
loadsourcefilename.s = ""
loadnewtab.b = False
loadchecktab.b = False
loadcheckchanged.b = False

messageErrorWriteFile.s = "Error writing file!"

MaxLen tsourcedir$        = 192
MaxLen tincludedir$       = 192
MaxLen thelpdir$          = 192
MaxLen tautodocdir$       = 192

MaxLen tmp_string.s       = 1024                   ; used for passing strings to os-functions
MaxLen pedmessage.s       = 96                     ; used for display the text area
MaxLen tmpDetokeStr.s     = #MAX_Columns
MaxLen tmpTokeStr.s       = #MAX_Columns

WZListAdd list_labels.List ," "

#Max_BlitzLibs             = 256                   ; added and set to 256 to replace wrong 255 hardcoded Array dimension because we use entry 0 to 255 and this are 256 entrys  tomsmart1
Dim lib_mapping$(#Max_BlitzLibs,1)                 ; replaced the wrong 255 with the #Max_Blitzlibs Constant  tomsmart1
Dim lib_check.b(#Max_BlitzLibs)                    ; replaced the wrong 255 with the #Max_Blitzlibs Constant  tomsmart1
For i.l = 0 To (#Max_BlitzLibs-1)                    ; replaced the hardcoded 255 with (#Max_Blitzlibs-1) because we start at 0  tomsmart1
  lib_mapping$(i,0) = "* unused ID"+Str$(i)+" *"
  lib_mapping$(i,1) = ""
Next i
Dim tokentable.b(65536)

; -------------------------------------- structs for source window
NEWTYPE.pedMessage
  _Class.l
  _Code.w
  _Qualifier.w
  _IAddress.l
  _MouseX.w
  _MouseY.w
  _Seconds.l
  _Micros.l
  _Window.l
End NEWTYPE

DEFTYPE.pedMessage pedMessage
DEFTYPE.preprocessor *PreProcessor

; ------------------------------------------------------
; MACRODEFINITIONS
; ------------------------------------------------------
.MACROS
Macro versions
  "\\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH (\\__DATE_GER__) Build \\__VER_BUILD"
End Macro

Macro regs2stack
  MOVEM.l d0-d7/a0-a6,-(a7)
End Macro

Macro stack2regs
  MOVEM.l (a7)+,d0-d7/a0-a6
End Macro

Macro checkOption ; 1:variable, 2:optionValue
  (`1 AND `2)
End Macro

Macro PED_UpdateTextBufferOffset
  ped\ptrCurrentSourceData\TextBufferOffset = ped\ptrCurrentSourceData\DisplayLine * #MAX_Columns
End Macro


Macro PED_storeCursorPosition
  USEPATH ped\ptrCurrentSourceData
  \StoreColumn = \Column
  \StoreDisplayLine = \DisplayLine
  \StoreTextBufferOffset = \TextBufferOffset
End Macro

Macro PED_RestoreCursorPosition                                                                                                                                                                                                                          
  USEPATH ped\ptrCurrentSourceData
  \Column = \StoreColumn
  \DisplayLine = \StoreDisplayLine
  \TextBufferOffset = \StoreTextBufferOffset
End Macro

Macro PED_IncreaseDisplayLine
  ped\ptrCurrentSourceData\DisplayLine + 1
  ped\ptrCurrentSourceData\TextBufferOffset + #MAX_Columns
End Macro

Macro PED_DecreaseDisplayLine
  ped\ptrCurrentSourceData\DisplayLine - 1
  ped\ptrCurrentSourceData\TextBufferOffset - #MAX_Columns
End Macro

Macro updateBlockMark ;{d1 = currentLine, d0 = currentColumn}
  ped\ptrCurrentSourceData\StateBlockMark = False

  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
    If (ped\ptrCurrentSourceData\BlockStartY < `1) OR (ped\ptrCurrentSourceData\BlockStartY = `1 AND ped\ptrCurrentSourceData\BlockStartX <= `2)
      If (ped\ptrCurrentSourceData\BlockEndY > `1) OR (ped\ptrCurrentSourceData\BlockEndY = `1 AND ped\ptrCurrentSourceData\BlockEndX <= `2)
        ped\ptrCurrentSourceData\StateBlockMark = True
      EndIf
    EndIf
  EndIf
End Macro

Macro PED_CursorOn
  If sourceWindow\cursorState = False Then PED_SwitchCursor{}
End Macro

Macro PED_CursorOff
  If sourceWindow\cursorState = True Then PED_SwitchCursor{}
End Macro


SHARED storeBlockStartX.w : storeBlockStartX = $FFFF
Macro PED_ResetBlockflag
  storeBlockStartX = $FFFF
  ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
End Macro

Macro PED_LoadSource ; filename, checkchanged, checktab, newtab
  loadsourcefilename.s = `1
  loadcheckchanged.b = `2
  loadchecktab.b = `3
  loadnewtab.b = `4
  Gosub load_source
End Macro

; ------------------------------------------------------
; FUNCTIONDEFINITIONS
; ------------------------------------------------------
.FUNCTIONS

Statement WZ_CloseAllWindows{}                    ; made a Statement to close all (used) Wizard Windows to remove double code  tomsmart1
  Gosub close_contexthelp
  Gosub close_popupwindow
  WZ_HideHelp{}                                  ; added because it used for the wz_contexthelp
  Gosub kill_menus                               ; moved in that everytime tis statment are called the menues are detached fom the wz windows  tomsmart1
  ; windows with menu added
  WZCloseWindow WZID("WIN_INSTRUCTIONBROWSER")
  WZCloseWindow WZID("WIN_NEWTYPE")
  WZCloseWindow WZID("WIN_LABELS")
  WZCloseWindow WZID("WIN_LIBRARYBROWSER")
  WZCloseWindow WZID("WIN_SEARCH")
  WZCloseWindow WZID("WIN_SHORTCUTS")
  WZCloseWindow WZID("WIN_HELPDIAG")
  ; windows with no menu added
  WZCloseWindow WZID("WIN_HELP")
  WZCloseWindow WZID("WIN_SETTINGS")
End Statement


; Added the menu to the open WZ window
Statement WZ_AddMenuStrip{wzwinname.s, *menuStrip.Menu}
  winaddr.l = Peek.l(Addr Window(WZID(wzwinname)))
  If *menuStrip AND winaddr
    SetMenuStrip_ winaddr, *menuStrip
  EndIf
End Statement

; Remove the menu and than close WZ window
Statement WZ_CloseWindowAndRemoveMenu{wzwinname.s}
  wzwinid.l = WZID(wzwinname)
  *win.Window = Peek.l(Addr Window(wzwinid))
  If *win
    ClearMenuStrip_ *win
    WZCloseWindow wzwinid
  Else
    log_Print{"WZ_CloseWindowAndRemoveMenu: Window [" + wzwinname + "] ist not open.",#log_warning}
  EndIf
End Statement

Function.l PED_AllocMem{memsize.l}
SHARED ped
  memptr.l = AllocPooled_(ped\mempool, memsize + 4)
  If memptr <> 0
    Poke.l memptr, memsize + 4
    Function Return memptr + 4
  Else
    Function Return False
  EndIf 
End Function

Statement PED_FreeMem{memptr.l}
SHARED ped
  FreePooled_ ped\mempool,memptr-4,Peek.l(memptr-4)
End Statement

Statement PED_ClearTokencache{}
SHARED ped
  GetReg A1, ped\tokenCache
  MOVE.l #32767,d0
  'l11:
    CLR.l (a1)+
  DBF d0,'l11
'l10:
End Statement


Statement PED_ClearTextbuffer{}
SHARED sourceWindow

  ;_from.l = Peek.l(?textbufferaddr)
  ;_to.l = _from + (#MAX_Columns / 2) * sourceWindow\visibleLines - 1
  ;For tb.l = _from To _to Step 2
  ;  Poke.w tb, $2020
  ;Next tb

  GetReg D1,sourceWindow\visibleLines
  MOVE.w #MAX_Columns,D0 : LSR.w #1,D0 : MULS d0,d1 : SUBQ.w #1,D1
  MOVEA.l textbufferaddr,A0
  JL_0_76A6:
    MOVE.w #$2020,(A0)+
  DBF D1,JL_0_76A6
End Statement


Function PED_PrintStatus{txt$,xpos.w,@ypos.w}
  SHARED sourceWindow,AB3Pen()

  USEPATH sourceWindow
  If \win
    If FLen(txt$) > 0
      xpos_text.l = \win\GZZWidth - (\font\tf_XSize) * xpos - 4
      If ypos <> -1
        ypos_text.w = \statusAreaY + (\font\tf_YSize) * ypos
      Else
        ypos_text.w = \statusAreaY + (\font\tf_YSize)
      EndIf

      SetAPen_ \win\RPort, AB3Pen(#AB3_screenshine)
      SetBPen_ \win\RPort, AB3Pen(#AB3_screenfill)
      Move_ \win\RPort, xpos_text, ypos_text

      If Vallong(txt$) > 0                                   ; boldtext for numbers
        SetFont_ \win\RPort,\fontB
        SetSoftStyle_ \win\RPort,#FSF_BOLD,#FSF_BOLD
      EndIf
      Text_ \win\RPort,&txt$,FLen(txt$)

      SetFont_ \win\RPort,\font
      SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_BOLD
      SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    EndIf
  Else
    log_Print{"PrintStatus(): window pointer empty!"}
  EndIf
End Function

Statement PED_DrawStatusArea{}
SHARED sourceWindow, ped, AB3Pen()                                                                                                                                                                                                                       
USEPATH sourceWindow                                                                                                                                                                                                                                     

  ;log_Print{"draw statusarea"}

  ;-- clear areas
  SetAPen_  \win\RPort, AB3Pen(#AB3_screenfill)
  If \statusAreaY <= \win\GZZHeight
    RectFill_ \win\RPort, 0,\statusAreaY,\win\GZZWidth,\win\GZZHeight
    RectFill_ \win\RPort, 0,0, \win\GZZWidth,\font\tf_YSize
  Else
    log_Print{"illegal area for draw statusara"}
  EndIf

  ;-- Draw separation lines
  SetAPen_ \win\RPort, AB3Pen(#AB3_screenshine)
  Move_ \win\RPort,0,\statusAreaY : Draw_ \win\RPort,\win\GZZWidth,\statusAreaY

  SetAPen_ \win\RPort, AB3Pen(#AB3_screentext)
  Move_ \win\RPort,0,\statusAreaY + 1 : Draw_ \win\RPort,\win\GZZWidth,\statusAreaY + 1
  Move_ \win\RPort,0,\BoxTop-1 : Draw_ \win\RPort,\win\GZZWidth,\BoxTop-1

  ;-- Draw the tabs for each source file
  xpos_text.w = #leftoffset * \font\tf_XSize                                                                                                                                                                                                             
  ypos_text.w = \statusAreaY + 4 + \font\tf_Baseline

  ;-- clear statusarea
  ;-- statusarea has to seperator lines, a white and a black one
  SetAPen_ \win\RPort, AB3Pen(#AB3_screenfill)
  RectFill_ \win\RPort, xpos_text - 4, \statusAreaY + 2, \win\Width - \win\BorderRight,\statusAreaY + 2 + \font\tf_YSize + 1

  ; -- draw all sourcefilename tabs
  If ped\firstSourceEntry
    *fileEntry.sourceEntry = ped\firstSourceEntry
    Repeat
      bevelsize.w = #bevelsize - 1
            
      If *fileEntry = ped\currentSourceEntry
        stylestate.w = #FSF_BOLD
        fcol.w = AB3Pen(#AB3_screenshine)    ; selected
        bcol.w = AB3Pen(#AB3_screenback)
        bevel_recessed.b = True
      Else
        stylestate.w = #FS_NORMAL
        fcol.w = AB3Pen(#AB3_screenshine)    ; unselected
        bcol.w = AB3Pen(#AB3_screenback)
        bevel_recessed.b = False
      EndIf

      xsa.l = \font\tf_XSize / 2

      bx1.l = xpos_text - xsa
      by1.l = \statusAreaY + 2
      bx2.l = bx1 + \font\tf_XSize * #bevelsize - 1
      by2.l = by1 + \font\tf_YSize + 2

      cp_x.l = \win\RPort\cp_x
      cp_y.l = \win\RPort\cp_y

      If bevel_recessed = False
        SetAPen_ \win\RPort,AB3Pen(#AB3_screenback)
        RectFill_ \win\RPort,bx1,by1, bx2, by2
        SetAPen_ \win\RPort,AB3Pen(#AB3_screentext)
        Move_ \win\RPort,bx1,by1
        Draw_ \win\RPort,bx1,by2
        Draw_ \win\RPort,bx2,by2
        Draw_ \win\RPort,bx2,by1
      Else
        SetAPen_ \win\RPort,AB3Pen(#AB3_screenback)
        RectFill_ \win\RPort,bx1,by1, bx2, by2
        SetAPen_ \win\RPort,AB3Pen(#AB3_screenshine)
        Move_ \win\RPort,bx1,by1
        Draw_ \win\RPort,bx1,by2 + 1
        Draw_ \win\RPort,bx2,by2 + 1
        Draw_ \win\RPort,bx2,by1
        cp_y + 1
      EndIf

      ;-- check the name
      modifiedFlag.b = False
      tmp_string.s = Peek.s(&*fileEntry\SourceName)                                                                                                                                                                                                        
      If tmp_string = "" Then tmp_string = "unnamed" 
      If *fileEntry = ped\currentSourceEntry
        modifiedFlag = ped\ptrCurrentSourceData\SourceChanged
      Else
        modifiedFlag = *fileEntry\SourceChanged
      EndIf
      If modifiedFlag Then tmp_string = "*" + tmp_string


      ;-- optionally draw indicator for more chars
      If FLen(tmp_string) > bevelsize
        Move_ \win\RPort,bx2,by1
        For wp.w = by1 To by2-1 Step 3
          Move_ \win\RPort, bx2 - 1, wp + 1
          Draw_ \win\RPort, bx2 - 3, wp + 1
        Next wp
      EndIf 

      ;-- print the bevel caption
      SetAPen_ \win\RPort, fcol
      SetBPen_ \win\RPort, bcol

      If stylestate = #FSF_BOLD
        SetFont_ \win\RPort,\fontB
      Else
        SetFont_ \win\RPort,\font
      EndIf
      SetSoftStyle_ \win\RPort,stylestate.w,#FSF_BOLD

      tmp_string = Left$(tmp_string, bevelsize)
      Move_ \win\RPort, xpos_text-2, ypos_text
      Text_ \win\RPort, &tmp_string, FLen(tmp_string)


      xpos_text = xpos_text + #bevelsize * \font\tf_XSize

      *fileEntry = *fileEntry\nextEntry
    Until *fileEntry = 0
  EndIf

  SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
  SetFont_ \win\RPort,\font
 SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_BOLD

  ;----------------------------------------------------------------------------
  PED_PrintStatus{"Line:        ", 24}
  PED_PrintStatus{"Column:    ", 11}
End Statement


#STATUS_REDRAW     = -1
#STATUS_SCROLLERS  = 1
#STATUS_MEMORY     = 2
#STATUS_CURSOR     = 4                                                                                                                                                                                                                                   
#STATUS_ADDITIONAL = 8
#STATUS_MODIFIER   = 16

Statement PED_UpdateStatusArea{@statusmode.w}
SHARED sourceWindow, ped
SHARED oldSourceChanged.w                                                                                                                                                                                                                                

  ;log_Print{"UpdateStatusArea: " + Binw$(statusmode)}
  If ped\ptrCurrentSourceData = 0
    error{"no sourcecontext available!"}
  EndIf

  USEPATH ped\ptrCurrentSourceData

  If \SourceChanged  <> oldSourceChanged
      oldSourceChanged = \SourceChanged
      statusmode = #STATUS_REDRAW
  EndIf

  ;-- redraw everything   
  If statusmode = #STATUS_REDRAW
    PED_DrawStatusArea{}                                                                                                                                                                                                                                 
  EndIf                                                                                                                                                                                                                                                  

  tmpCurrentLine.l = \DisplayLineOffset + \DisplayLine + 1
  tmpCurrentColumn.w = \ColumnsOffset + \Column + 1

  ;-- update Scrollers
  If !checkOption{statusmode,#STATUS_CURSOR|#STATUS_SCROLLERS}
    ;log_Print{"updating scrollers"}
    slider_top.l     = \DisplayLineOffset
    slider_total.l   = \TotalLines
    slider_visible.l = sourceWindow\visibleLines
    ;/ scale
    If slider_total > 0
      If slider_total >= #max_slider_res
        !mul48f{slider_visible,#max_slider_res,slider_total,slider_visible}  : If slider_visible<1 Then slider_visible=1
        !mul48f{slider_top    ,#max_slider_res,slider_total,slider_top}
        slider_total   = #max_slider_res
      EndIf
      SetGadgetAttrsA_ sourceWindow\vertiprop,sourceWindow\win,0,Tags(@@                                                                                                                                                                                 
                                              #PGA_Total  ,slider_total,@@
                                              #PGA_Top    ,slider_top,@@
                                              #PGA_Visible,slider_visible)
    EndIf                                                                                                                                                                                                                                                

    SetGadgetAttrsA_ sourceWindow\horizprop,sourceWindow\win,0,Tags(#PGA_VertPot,-1,@@                                                                                                                                                                   
                                              #PGA_VertBody,1,@@
                                              #PGA_HorizPot,\Column,@@
                                              #PGA_HorizBody,sourceWindow\visibleColumns / #MAX_Columns,@@
                                              #PGA_Top,tmpCurrentColumn,@@
                                              #PGA_Total,#MAX_Columns,@@
                                              #TAG_END,0)
  EndIf

  ;-- print current cursorposition
  If !checkOption{statusmode,#STATUS_CURSOR|#STATUS_SCROLLERS}
    Format "000000"
    formatstr.s = Right$(Str$(tmpCurrentLine), 6) : PED_PrintStatus{formatstr,18}
    Format "000"
    formatstr = Right$(Str$(tmpCurrentColumn), 3) : PED_PrintStatus{formatstr,3}
    Format ""
  EndIf
  
  ;-- print memory data
  If !checkOption{statusmode,#STATUS_MEMORY}
    ;log_Print{"printing memory data"}
    availchip.l = AvailMem_(#MEMF_CHIP) / 1024
    availfast.l = AvailMem_(#MEMF_FAST) / 1024
    Format "###0,000"
    availmem.s = "CHIP " + StripLead$(Str$(availchip),@" ") + "kb"
    availmem + " | FAST " + StripLead$(Str$(availfast),@" ") + "kb"
    Format ""
    PED_PrintStatus{availmem,FLen(availmem),2}
  EndIf

  ;-- print additional datas
  If !checkOption{statusmode,#STATUS_ADDITIONAL}
    If ped\debugMode Then info.s = "  Debug: On " Else info = "  Debug: Off"
    If ped\DoTokenize Then info + "  Tokenize: On " Else info + "  Tokenize: Off"
    PED_PrintStatus{info,74,2}
  EndIf
End Statement



Statement PED_SwitchCursor{}
SHARED sourceWindow, ped, pedconfig, AB3Pen()                                                                                                                                                                                                            
USEPATH sourceWindow                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                         
  \cursorState = NOT \cursorState                                                                                                                                                                                                                        

  If ped\ptrCurrentSourceData\DisplayLine > sourceWindow\visibleLines-1
    ped\ptrCurrentSourceData\DisplayLine = sourceWindow\visibleLines-1
  EndIf

  Select pedconfig\cursorStyle
  Case #AB3_cursorStyle_line
    xmin.w = \BoxLeft + \font\tf_XSize * ped\ptrCurrentSourceData\Column
    ymin.w = \BoxTop  + \font\tf_YSize * ped\ptrCurrentSourceData\DisplayLine
    xmax.w = xmin + 1
    ymax.w = ymin + \font\tf_YSize - 1

  Case #AB3_cursorStyle_underline
    xmin.w = \BoxLeft + \font\tf_XSize * ped\ptrCurrentSourceData\Column
    ymin.w = \BoxTop  + \font\tf_YSize * ped\ptrCurrentSourceData\DisplayLine  + \font\tf_YSize - 1  - 1
    xmax.w = xmin + \font\tf_XSize - 1
    ymax.w = ymin + 1

  Default
    xmin.w = \BoxLeft + \font\tf_XSize * ped\ptrCurrentSourceData\Column
    ymin.w = \BoxTop  + \font\tf_YSize * ped\ptrCurrentSourceData\DisplayLine
    xmax.w = xmin + \font\tf_XSize - 1
    ymax.w = ymin + \font\tf_YSize - 1
  End Select

  If (xmax => xmin) AND (ymax => ymin)
    SetAPen_ \win\RPort, AB3Pen(#AB3_screenshine)
    ;SetBPen_ \win\RPort, AB3Pen(#AB3_cbackground)
    ;SetAPen_ *sourcerp, AB3Pen(#AB3_screenfill)
    ;SetBPen_ *sourcerp, AB3Pen(#AB3_cbackground)
    ;SetDrMd_ *sourcerp,#COMPLEMENT
    \rp\Mask = %11                                                                                                                                                                                                                                       
    RectFill_ \rp, xmin, ymin, xmax, ymax                                                                                                                                                                                                                
    ;log_Print{"update cursor " + Str$(sourceWindow\cursorState)}
  Else
    log_Print{"illegal area for draw cursor",#log_error}
  EndIf
End Statement

Function.b PED_CheckLabelRelevance{testString.s}
SHARED ped

  tmppos.w = 1
  While Mid$(testString,tmppos,1) = " "
    tmppos + 1
  Wend
  Repeat
    tmpchar.b = Asc(Mid$(testString,tmppos,1))
    If tmpchar = ped\LabelIdentifier Then Function Return True
    If tmpchar = 59 Then Function Return True    ; ";"
    If tmpchar = $80
      If Asc(Mid$(testString,tmppos+1,1))= $2d OR Asc(Mid$(testString,tmppos+1,1)) = $ae ; Token "Stop" or Token "TRAP"
        Function Return True
      EndIf
    EndIf
    tmppos + 1
  Until tmpchar <= 0
  Function Return False
End Function

Function.b PED_ReadFileCache{}
SHARED ped,readcache, *PreProcessor.preprocessor

  log_Print{"read file to cache ..."}
  If ped\sourceFileHandle  = 0
    error{"No file handle set!!"}
    Function Return False
  EndIf

  readcache\mode = $00

  readcache\filehandle = ped\sourceFileHandle                 ; file
  readcache\blocklen   = $2000                                 ; length
  readcache\bufferoffset = 0

  If readcache\readlen <= 0                   ; no file yet!
;    log_Print{"no file yet in cache"}
    ExamineFH_ readcache\filehandle,readcache\fib
    readcache\filelen = readcache\fib\fib_Size

    If readcache\filelen > readcache\cachelen
 ;     log_Print{"allocating cachememory..."}
      If readcache\cacheptr Then FreeVec_ readcache\cacheptr
      readcache\cacheptr = AllocVec_(readcache\filelen,#MEMF_ANY)
      readcache\cachelen = readcache\filelen
    End If

;    log_Print{"Filelen : " + Str$(readcache\filelen)}
;    log_Print{"Cachelen: " + Str$(readcache\cachelen)}
;    log_Print{"start reading to ..." + Hex$(readcache\cacheptr) + " from filehandle " + Hex$(readcache\filehandle)}
    readcache\readlen = Read_ (readcache\filehandle,readcache\cacheptr,readcache\filelen)
;    log_Print{"Readlen : " + Str$(readcache\readlen) + " from " + Hex$(readcache\filehandle)}

    ;ex.s = LCase$(dos_GetExt{Peek.s(&readcache\fib\fib_FileName)})
    ;If ex = "ab2" OR ex = "ab3" OR ex = "asc"
;    If ped\DoTokenize
;      log_Print{"tokenizing imported text..."}
      ; process the ascii data in sourcebuff length and write the tokenized source into destbuffer
      ; the return value is the length of the tokenized text
      ; sourcebuff and destbuff might be the same pointer
      ; preproc_Tokenize{*tn.preprocessor,sourcebuff.l,destbuff.l,bytelength.l}
;      log_Print{Peeks$(readcache\cacheptr,readcache\readlen)}
;      readcache\readlen = preproc_Tokenize{*PreProcessor,readcache\cacheptr,readcache\cacheptr,readcache\readlen}
 ;     log_Print{"done "+ Str$(readcache\readlen) + " bytes"}
;    End If
    readcache\offset = 0
  End If

  readcache\chunklen = readcache\blocklen
  If readcache\chunklen > readcache\readlen-readcache\offset Then readcache\chunklen = readcache\readlen-readcache\offset

;  log_Print{"chunklen: " + Str$(readcache\chunklen)}
;  log_Print{"cacheptr: " + Str$(readcache\cacheptr)}

  If readcache\chunklen > 0
    CopyMem_ readcache\cacheptr + readcache\offset,readcache\bufferptr,readcache\chunklen
    readcache\offset + readcache\chunklen
    Function Return True
  Else
    readcache\chunklen = 0
    readcache\readlen = 0
    Function Return False
  End If

  ;MOVE.l readcache_chunklen,d0
  ;MOVE.l readcache_chunklen,d6
  ;MOVEA.l comPtr_DosBuffer,A5
  ;MOVE.l comPtr_SourceFileHandle,D7
  ;TST.l D6

End Function

Function.b PED_ReadClipboard{}
SHARED ped,readcache

  ;log_Print{"read from clipboard"}
  readcache\mode = $FF : readcache\cb_eol = False
  readcache\chunklen = -1
  readcache\bufferoffset = 0
  If readcache\cH = Null Then readcache\cH = clipboard_Open{0} : readcache\cb_linecount = 0 ; open clipboard and reset line count

  If readcache\cH
    clipboard_text.s = ""
    If clipboard_HasMoreLines{readcache\cH}
      clipboard_text.s = clipboard_GetNextLine{readcache\cH}
      quoted.w = False
      comment.w = False
      For n.l = 0 To FLen(clipboard_text) - 1
        cchar.w = Peek.b(&clipboard_text+n) & $FF
        If cchar = $22 Then quoted = 1-quoted ; detect quotes
        If quoted=False AND cchar=@";" Then comment = True
        If cchar = $a0 Then cchar = @" "      ; non-breaking space => standard space
        If cchar > 127 AND quoted=False AND comment=False Then cchar = @"?"  ; replace non-ASCII characters with ?, if not in string
        Poke.b &clipboard_text+n,cchar
      Next
      ;log_Print{"cbline: " + clipboard_text}
      ;log_Print{"first char: " + Str$(Peek.b(&clipboard_text))}
      ;log_Print{"cblen: " + Str$(FLen(clipboard_text))}

      readcache\chunklen = FLen(clipboard_text) ; put this line to copy buffer
      If readcache\chunklen > 0 Then CopyMem_ &clipboard_text,readcache\bufferptr,readcache\chunklen
      readcache\cb_linecount + 1

    Else
      ;log_Print{"clipboard empty."}
      clipboard_Free{readcache\cH}
      readcache\cH = Null
      readcache\cb_linecount = 0
      readcache\cb_eol = True
      readcache\chunklen = -1
    End If
  End If

  If readcache\chunklen = -1
    Function Return False
  Else
    Function Return True
  EndIf
End Function

Function.b PED_ReadNextByte{}
SHARED ped,readcache

  morebytes.b = True
  readcache\currentbyte = 0

  Repeat
    readcache\chunklen - 1

    If readcache\chunklen >=0
      readcache\currentbyte = Peek.b(readcache\bufferptr + readcache\bufferoffset)
      readcache\bufferoffset + 1
      readcache\moreBytes = True
      Function Return True
    Else
      If readcache\mode = $00
        morebytes = PED_ReadFileCache{}
      Else
        morebytes = PED_ReadClipboard{}
      EndIf
    EndIf
  Until morebytes = False

  readcache\moreBytes = morebytes
  Function Return morebytes
End Function

Function.s PED_ReadNextLine{}
SHARED ped,readcache

  resultString.s = "NoCOntenTwasDelivered"

  If readcache\mode AND readcache\cb_eol Then Function Return resultString

  If PED_ReadNextByte{}
    resultString = ""
    Repeat
      ; this is the EOL of ClipBoard!
      If readcache\currentbyte = $0A Then Function Return resultString
      ; no further bytes left
      If readcache\currentbyte = $00 Then Function Return resultString

      If readcache\currentbyte = $9  Then readcache\currentbyte = $20 ; replace TAB by space

      If readcache\currentbyte <> $0D Then resultString + Chr$(readcache\currentbyte)
      ; do to import_start
    Until NOT PED_ReadNextByte{}
  EndIf
  ;log_Print{"ReadNextLine: [" + resultString + "]"}
  Function Return resultString
End Function

Function.b PED_StoreSourceLine{*storeLine.sourceLine}
SHARED ped

  If *storeLine = 0 Then Function Return False

  If Peek.b(*storeLine + 9) <> 0
    tempLen.b = Peek.b(*storeLine + 8)
    log_Print{"storing line: " + Peek.s(*storeLine + 9)}
    ped\undeleteStrLen = tempLen
    For i.b = 0 To tempLen-1
      Poke.b ped\ptrLineUndeleteStore + i, Peek.b(*storeLine + 9 + i)
    Next i
  EndIf
  Function Return True

End Function

Function.b PED_DeleteSourceLine{*delLine.sourceLine,@docheck.b}
SHARED ped

  If *delLine = 0 Then Function Return False

  If docheck
    tmpStr.s = Peek.s(*delLine + 9)
    If PED_CheckLabelRelevance{tmpStr} Then ped\LabelListChanged = True
  EndIf

  PED_FreeMem{*delLine} : Poke.l *delLine, 0
  Function Return True
End Function


Function.l PED_CreateNewSourceLine{newline.s}
SHARED ped,*PreProcessor

;  If ped\DoTokenize
;    MaxLen linebuff$ = 256
;    preproc_Tokenize{*PreProcessor,&newline,&linebuff$,FLen(newline)}
;    newline = Peek.s(&linebuff$)
;  EndIf

  _strLen.w = FLen(newline) + 1
  If _strLen = 1 Then newline = Chr$(0)

  lineaddr.l = PED_AllocMem{_strLen + 9}

  Poke.l lineaddr,0          ;clear pointer to prevline
  Poke.l lineaddr+4,0        ;clear pointer to nextline
  Poke.b lineaddr+8,_strLen  ;store length of string

                             ;copy string to new sourceline
  For i.w = 0 To _strLen - 1
    Poke.b lineaddr + 9 + i,Peek.b(&newline + i)
    If Asc(Mid$(newline,i+1,1)) = ped\LabelIdentifier Then ped\LabelListChanged = True
  Next i
  Poke.b lineaddr + 9 + _strLen,0

  Function Return lineaddr
 
End Function

Function.b PED_ReplaceCurrentSourceLine{*newLine.sourceLine}
SHARED ped
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine

  *previousLine.sourceLine = *currentLine\previousLine
  If *previousLine
    *previousLine\nextLine = *newLine
    *newLine\previousLine = *previousLine
  EndIf
  *nextLine.sourceLine = *currentLine\nextLine
  If *nextLine
    *nextLine\previousLine = *newLine
  EndIf
  *newLine\nextLine = *nextLine

  PED_DeleteSourceLine{*currentLine}                                                                                                                                                                                                                     
  If *currentLine = ped\ptrCurrentSourceData\FirstSourceLine Then ped\ptrCurrentSourceData\FirstSourceLine = *newLine
  If *currentLine = ped\ptrCurrentSourceData\LastSourceLine Then ped\ptrCurrentSourceData\LastSourceLine = *newLine
  ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
End Function

Function PED_InsertSourceLine{*newLine.sourceLine}
SHARED ped

   *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
   If *currentLine
    *prevLine.sourceLine = *currentLine\previousLine
    If *prevLine = 0
      ;log_Print{"current line has no previousline, setting newline as new firstline."}
      ped\ptrCurrentSourceData\FirstSourceLine = *newLine
    Else
      *newLine\previousLine = *prevLine
      *prevLine\nextLine = *newLine
    EndIf

    *currentLine\previousLine = *newLine
    *newLine\nextLine = *currentLine
  Else
    log_Print{"as there is no sourceline left, this will be the first and last one."}
    ped\ptrCurrentSourceData\FirstSourceLine = *newLine
    ped\ptrCurrentSourceData\LastSourceLine = *newLine
  EndIf

  ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
  ped\ptrCurrentSourceData\TotalLines + 1

  tmpStr.s = Peek.s(*newLine + 9)
  If PED_CheckLabelRelevance{tmpStr} Then ped\LabelListChanged = True

  Function Return True

End Function


Function.l PED_GetBlockStartSourceLine{}
SHARED ped

  USEPATH ped\ptrCurrentSourceData
  currentY.l = \DisplayLineOffset + \DisplayLine

  ;log_Print{"currentY: "  + Str$(currentY)}
  ;log_Print{"BlockStartY: "  + Str$(\BlockStartY)}
  If \BlockStartY = currentY Then Function Return \CurrentSourceLine

  *tempLine.sourceLine = \CurrentSourceLine
  If \BlockStartY < currentY
    Repeat 
      *tempLine.sourceLine = *tempLine\previousLine
      currentY - 1
    Until currentY = \BlockStartY
  Else
    Repeat 
      *tempLine.sourceLine = *tempLine\nextLine
      currentY + 1
    Until currentY = \BlockStartY
  EndIf
  Function Return *tempLine  
End Function


Function.b CheckChr{char$,table$}
  For i.b = 1 To FLen(table$)
    If char$ = Mid$(table$,i,1)
      Pop If : Pop For
      Function Return True
    End If
  Next i
  Function Return False
End Function

Function.s PED_GetWordAtPos{text$, textX.w, removechars.b, @preproc.b}
SHARED *PreProcessor.preprocessor

  tlen.w = FLen(text$)
  If tlen < 2 Then Function Return ""

  If Mid$(text$,textX,1) = "" Then Function Return ""

  If preproc
    ;log_Print{"using preprocessor to find string in source: " + text$}
    Function Return Trim$(preproc_CropToken{*PreProcessor,text$,textX})
  Else
    If removechars Then checklist.s = " .,+&!|(){}[]<>" Else checklist = ""

    result$ = "" : char$ =""
    cursorpos.w = textX
    nextpos.w = cursorpos
    backpos.w = cursorpos - 1
    Repeat
      result$ = char$ + result$
      char$ = Mid$(text$,backpos,1)
      backpos - 1
    Until CheckChr{char$,checklist + Chr$(34)} OR (backpos<0)
    char$ = ""

    Repeat
      result$ = result$ + char$
      char$ = Mid$(text$,nextpos,1)
      nextpos + 1
    Until CheckChr{char$,checklist + Chr$(34)} OR (nextpos>(tlen+1))
    Function Return StripLead$(result$,32)
  EndIf
End Function


Statement PED_ShowMessage{textMessage.s,@target.b,@style.b}
  SHARED pedmessage,sourceWindow,AB3Pen()            ; has to be shared, because on exit of function the variable will be discarded

  If sourceWindow\win;ActiveWindow
    pedmessage = textMessage

    If target = -1
      SetAPen_ sourceWindow\win\RPort,AB3Pen(#AB3_screenfill)
      RectFill_ sourceWindow\win\RPort, 0,0, sourceWindow\win\GZZWidth,sourceWindow\font\tf_YSize

      SetAPen_ sourceWindow\win\RPort,AB3Pen(#AB3_screenshine)
      SetBPen_ sourceWindow\win\RPort,AB3Pen(#AB3_screenfill)
      If style<>-1
        SetSoftStyle_ sourceWindow\win\RPort,style,style
      ;Else
        ;SetSoftStyle_ sourceWindow\win\RPort,#FSF_BOLD,#FSF_BOLD
      EndIf
      Move_ sourceWindow\win\RPort,0,sourceWindow\font\tf_Baseline
      Text_ sourceWindow\win\RPort,&pedmessage,FLen(pedmessage)
    Else
      SetWindowTitles_ sourceWindow\win,-1,&pedmessage
    EndIf

  EndIf
End Statement


Statement Show_Helpfile{libname$, node$, helpdir$}
  SHARED pedconfig,ped

  If node$ = "" Then node$ = "main"
  commandlineStr.s = " -t " + node$

  If helpdir$ <> ""
    commandlineStr + " -d " + helpdir$
  Else
    commandlineStr + " -d " + pedconfig\helpDir
  EndIf

  If libname$ <> "" Then commandlineStr + " -l " + dos_FilePart{dos_RemExt{libname$}}

  If pedconfig\use_pubscreen
    commandlineStr + " -s " + ped\defaultPubscreenName
  Else
    If pedconfig\clone_wbscreen
      commandlineStr + " -s " + Chr$(34) + ped\defaultScreenTitle + Chr$(34)
    Else
      commandlineStr + " -s Workbench"
    EndIf
  EndIf

  ;-- adjusting the window size
  Format ""
  commandlineStr + " w " + Str$(screen_GetWidth{} / 2) + " h " + Str$(screen_GetHeight{} / 1.5)

  log_Print{"opening Helpviewer for ["+ libname$ + "/" + node$ + "] ..."}
  log_Print{"commandstring <" + commandlineStr + ">"}

  PED_ShowMessage{"Opening Helpviewer for "+ libname$ + "/" + node$ + " ..."}
  dos_RunCli{dos_AddPart{pedconfig\mainDir,"Tools/AB3HelpViewer"},0,8192,False,commandlineStr}
End Statement

Function.b CheckWindow{title$}
SHARED pedconfig
  succ.b = True
  *thisscreen.Screen = Peek.l(Addr Screen(0))
  *conwin.Window = *thisscreen\FirstWindow
  While (*conwin<>0) AND Peek$(*conwin\Title) <> pedconfig\console_title
    *conwin = Peek.l(*conwin)
  Wend
  If *conwin=0 Then succ = False

  Function Return succ
End Function


Macro IsIllegalChar
  Peek.b(?chartab + `1)
End Macro

Function.l PED_GetNewtypeByName{newtypename.s}
SHARED *newtypebase

  *nt.l = 0

  If *newtypebase = 0
    error{"No newtypebase-Pointer available!"}
  Else
    newtypename = Trim$(newtypename)  
    log_Print{"GetNewtypeByName [" + newtypename + "]"}  
    *nt = Peek.l(*newtypebase)
    While *nt AND NOT Peek.s(*nt + 11) = newtypename
      *nt = Peek.l(*nt)
    Wend
  EndIf
  Function Return *nt  

End Function

Function.l PED_GetVariableByName{varname.s}
SHARED *varbase

  *vb.l = 0

  If *varbase = 0
    error{"No varbase-Pointer available!"}
  Else
    varname = Trim$(StripLead$(varname, @"*"))
    log_Print{"GetVariableByName [" + varname + "]"}
    *vb.l = Peek.l(*varbase)
    While *vb AND NOT Peek.s(*vb + $13) = varname
      *vb = Peek.l(*vb)
    Wend
  EndIf
  Function Return *vb
  
End Function


Function.s PED_GetNewtypeOf{varname.s}
  *var.l = PED_GetVariableByName{varname}
  If *var
    ntp.l = Peek.l(*var + 10)            ; get the newtype-pointer of that var
    If ntp
      Function Return Peek$(ntp + $b)    ; get the newtype-name of that var
    End If
  EndIf
End Function



Function.l PED_GetConstantByName{constname.s}
SHARED *constantbase

  *cb.l = 0

  If *constantbase = 0
    error{"No contantbase-Pointer available!"}
  Else
    log_Print{"GetConstantByName [" + constname + "]"}
    *cb.l = Peek.l(*constantbase)
    While *cb AND NOT Peek.s(*cb + $13) = constname
      *cb = Peek.l(*cb)
    Wend
  EndIf
  Function Return *cb
  
End Function

Function.l PED_GetConstantValue{constname.s}
  *cb.l = PED_GetConstantByName{constname.s}
  If *cb
    Function Return Peek.l(*cb + 8)
  EndIf
End Function



Function.s PED_GetDefinitionOf{varname.s}
SHARED ped
  ; search all previous code if we can find a definition for the current varname
  ; a definition may be a DEFTYPE-command or an indirect type definition by using the type extention at the first time

  log_Print{"searching type for variable [" + varname + "]"}
  If Trim$(varname)="" Then Function Return ""

  typename.s = ""

  *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine\previousLine
  While *tempLine
    lineAddr.l = *tempLine + 9
    lineStr.s = Peek.s(lineAddr)

    runner.w = 0 : deftype_found.b = False
    While Peek.b(lineAddr + runner) <> 0
      actlong.l = Peek.l(lineAddr + runner)
      actword.l = actlong LSR 16
      ;log_Print{Hexw$(actword) + " " + Hexw$(#TOKEN_DEFTYPE)}
      If actword = #TOKEN_DEFTYPE
        log_Print{"DEFTYPE!"}
        deftype_found = True
        runner + 2
      Else 
        runner + 1
      EndIf 
                                                                                                                                                                                                                                                         
      ; search for the first character of the varname in the current line
      If Peek.b(lineAddr + runner) = Peek.b(&varname)
        ;If runner - 10 > 0
          ; check if variable has an "," or " "
          If Peek.b(lineAddr + runner-1) = @"," OR Peek.b(lineAddr + runner-1) = @" "
            If Peeks$(lineAddr + runner, FLen(varname)) = varname ;AND !IsIllegalChar{Peek.b(lineAddr + runner + FLen(varname) + 1)}

              runner + FLen(varname)
              While Peek.b(lineAddr + runner) = @" "
                runner + 1
              Wend
              If deftype_found
                runner.w = Instr(lineStr,".") - 1
                If runner < 0
                  error{"DEFTYPE without . found!"}
                  Pop While : Goto move2nextline
                EndIf
              EndIf
              If Peek.b(lineAddr + runner) = @"."
                runner + 1
                While !IsIllegalChar{Peek.b(lineAddr + runner)} = 0
                  typename + Chr$(Peek.b(lineAddr + runner))
                  runner + 1
                Wend
                Pop While : Pop While : Function Return typename
              Else
                Pop While : Goto move2nextline
              EndIf
            EndIf
          EndIf
        ;EndIf
      EndIf
    Wend
    move2nextline:
    *tempLine = *tempLine\previousLine
  Wend
End Function

                                                                                                                                                                                                                                                         
#DEFBROWSER_RESET = 0
#DEFBROWSER_RESETTYPE = 1
#DEFBROWSER_SELECTTYPE = 2
#DEFBROWSER_LISTSUBTYPE = 3
#DEFBROWSER_NEWTYPE = 10
#DEFBROWSER_VARIABLE = 20
#DEFBROWSER_CONSTANT = 30
                                                                                                                                                                                                                                 
Function.b PED_UpdateDefinitionBrowser{action.b, @defname.s,@openwin.b}
SHARED *newtypebase, *varbase, *constantbase
SHARED wtemp, ped, AB3Pen()
SHARED lev, newtype_found, quicktype, pos$(), postype$()

  log_Print{"UpdateDefinitionBrowser action [" + Str$(action) + "], string [" + Str$(defname) + "]"}

  ;-- optionally open window if requested
  If openwin = -1
    If NOT WZ_IsOpen{"WIN_NEWTYPE"}
      log_Print{"opening definitionbrowser."}
      USEPATH wtemp
      WZWindow WZID("WIN_NEWTYPE"),?wzgui,255,\type_x,\type_y,\type_w,\type_h,WZID("WIN_NEWTYPE")
      WZ_AddMenuStrip{"WIN_NEWTYPE", ped\menuStrip}
      If Peek.l(*varbase) = 0
          WTitle "Compile the source to see all vars!"
      EndIf
      Gosub activatesourcewindow
    EndIf
  EndIf
  If NOT WZ_IsOpen{"WIN_NEWTYPE"} Then Function Return False
  Use Window WZID("WIN_NEWTYPE")

  ;-- switch to correct view
  defmode.b = ped\definitionMode
  If action = #DEFBROWSER_LISTSUBTYPE OR action = #DEFBROWSER_NEWTYPE OR action = #DEFBROWSER_SELECTTYPE OR action=#DEFBROWSER_RESETTYPE
    defmode = 2
  EndIf
  If action = #DEFBROWSER_CONSTANT Then defmode = 0
  If action = #DEFBROWSER_VARIABLE Then defmode = 1

  If ped\definitionMode <> defmode OR ped\lastStructLevel <> lev
    log_Print{"setting new definitionmode: " + Str$(defmode) + ", was " + Str$(ped\definitionMode)}
    log_Print{"setting new structlevel: " + Str$(lev) + ", was " + Str$(ped\lastStructLevel)}
    ped\lastStructLevel = lev

    WZ_KillTable{"TYPETABLE"}
    Use Window WZID("WIN_NEWTYPE")

    Select defmode
    Case 0
      WZPrint "newtype_const",1
      WZPrint "newtype_var",0
      WZPrint "newtype_struct",0
      WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
      WZ_SetTableTitle{"TYPETABLE","Identifier","Value"}
      WZ_SetTableColors{"TYPETABLE",1,0,1,0}
      WZ_SetPriority{"TYPETABLE",2,1}
      WZ_DrawTable{"TYPETABLE"}

    Case 1
      WZPrint "newtype_const",0
      WZPrint "newtype_var",1
      WZPrint "newtype_struct",0
      WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
      WZ_SetTableTitle{"TYPETABLE","Identifier","Value"}
      WZ_SetTableColors{"TYPETABLE",1,0,1,0}
      WZ_SetPriority{"TYPETABLE",2,1}
      WZ_DrawTable{"TYPETABLE"}
 
    Case 2
      WZPrint "newtype_const",0
      WZPrint "newtype_var",0
      WZPrint "newtype_struct",1
      If action  = #DEFBROWSER_RESETTYPE OR action = #DEFBROWSER_RESET Then lev = 0
      If lev = 0
        WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",1}
        WZ_SetTableTitle{"TYPETABLE","Identifier"}
        WZ_SetTableColors{"TYPETABLE",1,0,1,0}
        WZ_DrawTable{"TYPETABLE"}
      Else
        WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",3}
        WZ_SetTableTitle{"TYPETABLE","Identifier","Type","Offset"}
        WZ_SetTableColors{"TYPETABLE",1,0,1,0}
        WZ_SetPriority{"TYPETABLE",3,2,2}
        WZ_DrawTable{"TYPETABLE"}
      EndIf
    End Select
                                                                                                                                                                                                                                                
    ;WZPrint "LABEL_PAGE",0
    ped\definitionMode = defmode
  EndIf
  
  ;WZPrint "NEWTYPE_ENTRY",&defname                                                                                                                                                                                                                      
  If action = #DEFBROWSER_RESET OR action = #DEFBROWSER_RESETTYPE Then defname = ""
  If defname <> WZGetString("STRING2")
    WZPrint "STRING2",&defname
    If defmode = 2 Then action = #DEFBROWSER_SELECTTYPE
  EndIf

  If FLen(defname) > 2
    InitArgParse defname
    word1$ = NextArg$
    word2$ = NextArg$
  EndIf

  Select defmode
  Case 0 ; constantlist
    WZ_ClearTable{"TYPETABLE"}

    If word1$ <> ""
      *cb.l = *constantbase
      If *cb
        *cb = Peek.l(*cb)
        While *cb
          a$ = Peek$(*cb + $13)
          If Instr (a$,word1$)
            If Instr(a$,word2$)
              WZ_AddRow{"TYPETABLE",a$,"$" + Hex$(Peek.l(*cb + 8))}
            EndIf
          EndIf
          *cb = Peek.l(*cb)
        Wend
      Else
        error{"constantbase = NULL => GURU!!!"}
      EndIf
    EndIf

    WZ_TableSort{"TYPETABLE",1}
    WZ_UpdateTable{"TYPETABLE"}

  Case 1 ; variableslist
    WZ_ClearTable{"TYPETABLE"}
    If *varbase
      *vb.l = Peek.l(*varbase)
      While *vb
        a$ = Peek$(*vb + $13)
        If Peek.w(*vb + 6) AND 2 Then arr$ = "()" Else arr$ = ""
        If Peek.w(*vb + 6) AND 1 Then poin$ = "*" Else poin$ = ""
        If Instr(a$,word1$)
          If Instr(a$,word2$)
            it.l = Peek.l(*vb + 10)
            WZ_AddRow{"TYPETABLE",poin$ + a$ + arr$, Peek$(it + $b)}
          EndIf
        EndIf
        *vb = Peek.l(*vb)
      Wend
    Else
      error{"*varbase = NULL => GURU!!!"}
    EndIf
    WZ_TableSort{"TYPETABLE",1}
    WZ_UpdateTable{"TYPETABLE"}

  Case 2
    Select action
    Case #DEFBROWSER_RESETTYPE
      WZ_ClearTable{"TYPETABLE"}
      *nt.l = *newtypebase
      If *nt
        *nt = Peek.l(*nt)
        While *nt
          WZ_AddRow{"TYPETABLE", Peek.s(*nt + 11)}
          *nt = Peek.l(*nt)
        Wend
      Else
        error{"newtypebase = NULL => GURU!!!"}
      EndIf

    ;  WZ_TableSort{"TYPETABLE",1}
      WZ_UpdateTable{"TYPETABLE"}


    Case #DEFBROWSER_SELECTTYPE
      If *newtypebase = 0
        error{"newtypebase = NULL => GURU!!!"}    
      Else
        ;WZPrint "LABEL_PAGE",0
        WZ_ClearTable{"TYPETABLE"}
        *nt = *newtypebase
        If lev
          *nt = Peek.l(*nt)
          While *nt
            If Peek$(*nt + 11) = postype$(lev)
              *nt3.l = Peek.l(*nt + 4)
              While *nt3
                If Peek.w(*nt3 + 6) = 1 Then b$ = "*" Else b$ = ""
                b$ = b$ + Peek$(*nt3 + 15)
                c$ = Peek$(Peek.l(*nt3 + 10) + 11)
                ;If Instr(b$,word1$) Then If Instr(b$,word2$)
                nt_value.w = Peek.w(*nt3+4)
                nt_displayvalue.s = "$"+Right$(Hex$(nt_value),4) + "(" + Str$(nt_value) + ")"
                ;nt_displayvalue.s = Str$(nt_value)
                WZ_AddRow{"TYPETABLE",b$,c$,nt_displayvalue}
                ;End If
                b$ + "  ." + c$
                *nt3 = Peek.l(*nt3)
              Wend
              *nt = 0 : Goto out2
            EndIf
            *nt = Peek.l(*nt)
            out2        
          Wend
          WZ_TableSort{"TYPETABLE",3}
        Else
          log_Print{"building typeslist word1$[" + word1$ + "], word1$["+word2$+"]"}
          *nt = Peek.l(*nt)
          While *nt
            b$ = Peek$(*nt + 11)
            If Instr(b$,word1$) 
              If Instr(b$,word2$)
                WZ_AddRow{"TYPETABLE",b$,""}
                newtype_found = newtype_found + 1
                f$ = b$
              EndIf
            EndIf
            *nt = Peek.l(*nt)
          Wend
          WZ_TableSort{"TYPETABLE",1}
        EndIf
        WZ_UpdateTable{"TYPETABLE"}    
      EndIf

      ; -- update selected entry gadget
      ;a$ = ""
      ;For i.w = 1 To lev
      ;  If i > 1
      ;      a$ = a$ + "\" + pos$(i)
      ;  Else
      ;      a$ = a$ + "." + pos$(i)
      ;  EndIf
      ;Next
      ;typestr$ = a$
      ;WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
      ;WZPrint "NEWTYPE_ENTRY",&a$
      ; --

    Case #DEFBROWSER_LISTSUBTYPE
      postype$(lev) = defname
      If lev > 1
        pos$(lev) = ped\previousNewtypeStr
      Else
        pos$(lev) = defname
      EndIf
      a$ = ""
      For i.b = 1 To lev
        If i > 1
          a$ = a$ + "\" + pos$(i)
        Else
          a$ = a$ + "." + pos$(i)
        EndIf
      Next

      typestr$ = a$
      WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
      WZPrint "NEWTYPE_ENTRY",&a$

      WZ_ClearTable{"TYPETABLE"}
      *nt = *newtypebase
      If *nt
        *nt = Peek.l(*nt)
        Format ""
        While *nt
          b$ = Peek$(*nt + 11)
          If postype$(lev) = b$
            *nt3.l = Peek.l(*nt + 4)
            While *nt3
              If Peek.w(*nt3 + 6) = 1 Then b$ = "*" Else b$ = ""
              b$ = b$ + Peek$(*nt3 + 15)
              c$ = Peek$(Peek.l(*nt3 + 10) + 11)
              ;If Instr(b$,word1$) Then If Instr(b$, word2$)
              nt_value.w = Peek.w(*nt3 + 4)
              nt_displayvalue.s = "$" + Right$(Hex$(nt_value),4) + "(" + Str$(nt_value) + ")"
              WZ_AddRow{"TYPETABLE",b$,c$,nt_displayvalue}
              ;End If
              b$ + "  ." + c$
              *nt3 = Peek.l(*nt3)
            Wend
          EndIf
          *nt = Peek.l(*nt)
        Wend 
        WZ_TableSort{"TYPETABLE",3}
        WZ_UpdateTable{"TYPETABLE"}
      EndIf
 
    End Select

    ;lev.l = 0
    ;newtype_found.l = 0
    ;Gosub definitionbrowser_SelectType
    ;lev = 1

    ;*nt.l = *newtypebase
    ;If *nt
    ;  *nt = Peek.l(*nt)
    ;  While *nt
    ;    If Peek$(*nt + 11) = defname
    ;      quicktype = 1 : Gosub definitionbrowser_ListSubType
    ;      newtype_found = 1 : Pop If : Pop While : Goto f1ab
    ;    EndIf
    ;    *nt = Peek.l(*nt)
    ;  Wend
    ;EndIf 
    ;quicktype = 0
    ;f1ab:
  End Select
End Function

Function.s PED_GetLibname{libnum.w}
  SHARED lib_mapping$()
  If libnum > 255 OR libnum < 0
    libname.s = ""
    Select libnum
    Case #varslib         : libname = "varslib"
    Case #wbstartuplib    : libname = "wbstartuplib"
    Case #memlib          : libname = "memlib"
    Case #intlib          : libname = "intlib"
    Case #switchlib       : libname = "switchlib"
    Case #runerrlib       : libname = "runerrlib"
    Case #arrayslib       : libname = "arrayslib"
    Case #staticslib      : libname = "staticslib"
    Case #strings1lib     : libname = "strings1lib"
    Case #strings2lib     : libname = "strings2lib"
    Case #exitslib        : libname = "exitslib"
    Case #ffplib          : libname = "ffplib1"
    Case #lmullib         : libname = "lmullib"
    Case #ldivlib         : libname = "ldivlib"
    Case #clrlib          : libname = "clrlib"
    Case #datalib         : libname = "datalib"
    Case #strcomplib      : libname = "strcomplib"
    Case #maxslib         : libname = "maxslib"
    Case #maxlenlib       : libname = "maxlenlib"
    Case #chipbaselib     : libname = "chipbaselib"
    Case #floatquicklib   : libname = "floatquicklib"
    Case #modlib          : libname = "modlib"
    Case #debuglib        : libname = "debuglib"
    Case #rundebuglib     : libname = "rundebuglib"
    Case #errtraplib      : libname = "errtraplib"
    Default
      libname = "unknown syslib #"+Str$(libname)
    End Select
    Function Return libname
  Else
    Function Return lib_mapping$(libnum,0)
  EndIf
End Function

Function.s PED_GetFirstTokenname{libnum.w}
  SHARED lib_mapping$()
  If libnum>255
    error{"Couldnot get Token of a syslib!"}
  Else
    Function Return lib_mapping$(libnum,1)
  EndIf
End Function


Function.w FAST PED_GetToken{toknameptr.l}
SHARED *tokenbase

  *token.tokendata = *tokenbase
  log_Print{"search for: " + Peek.s(toknameptr)}                                                                                                                                                                                                         
  log_Print{".." + Peek.s(&*token\dat)}
  While *token                                                                                                                                                                                                                                           

    If Peek.s(toknameptr) = Peek.s(&*token\dat)                                                                                                                                                                                                          
      Pop If : Pop While : Function Return *token\number
    EndIf
    *token = *token\next_token
  Wend
End Function

Function.s PED_GetTokenName{tokenNumber.l}
SHARED *tokenbase, ped
 
  ;-- search in tokencache
  _tn.w = tokenNumber BitClr $F
  _libnum.w = _tn LSR 7

  ;log_Print{"searching for token " + Hexw$(_tn) + ", libnum " + Hexb$(_libnum),#log_debug}

  *token.tokendata = Peek.l(ped\tokenCache + _tn * 4)
  If *token
    ;log_Print{"token " + Hexw$(tokenNumber) + ": " + Peek.s(&*token\dat) + " found in cache.", #log_debug}
    Function Return Peek.s(&*token\dat)
  Else
    *token = *tokenbase 
    While *token
      If *token\number = _tn
        ;log_Print{"token " + Hexw$(tokenNumber) + " cached.", #log_debug}
        ; add token to tokencache
        Poke.l ped\tokenCache + _tn * 4, *token

        Pop If : Pop While
        Function Return Peek.s(&*token\dat)
      EndIf
      *token = *token\next_token
    Wend 
  EndIf
  Function Return "????Lib "+ Str$(_libnum) + "/" + Str$(tokenNumber AND $7f)
End Function

Function.l PED_GetTokenPointer{tname.s}
SHARED *tokenbase

  tname.s = LCase$(tname.s)

  *token.tokendata = *tokenbase
  While *token
    If LCase$(Peek.s(&*token\dat)) = tname Then Function Return *token
    *token = *token\next_token
  Wend
End Function

Function.w PED_GetTokenLibnum{tname.s}
  *token.tokendata = PED_GetTokenPointer{tname}
  If *token Then Function Return (*token\number LSR 7)
  Function Return -1 ; token not found
End Function

Function.w PED_GetTokenID{tname.s}
  *token.tokendata = PED_GetTokenPointer{tname}
  If *token Then Function Return *token\number
  Function Return -1
End Function

Function.s PED_GetTokenHelp{tname.s}
  *token.tokendata = PED_GetTokenPointer{tname}
  If *token Then Function Return Peek.s(&*token\dat + FLen(tname.s) + 1)
  Function Return ""
End Function

Function.l PED_GetMacroPointer{macname.s}
SHARED *macrobase

  macname.s = StripLead$(LCase$(macname.s),@"!")
  log_Print{"searching for macro [" + macname + "], "+ Hex$(*macrobase)}

  *macroP.l = *macrobase
  While *macroP
    result.s = Peek.s(*macroP + 13)
    If LCase$(result) = macname Then Function Return *macroP
    *macroP = Peek.l(*macroP)
  Wend
  Function Return 0
End Function

Function.s PED_GetMacroName{macname.s}
  *macroP.l = PED_GetMacroPointer{macname}
  If *macroP
    result.s = Peek.s(*macroP + 13)
    Function Return result
  EndIf
  Function Return ""
End Function


Function.s PED_GetMacroHelp{macname.s}
  *macroP.l = PED_GetMacroPointer{macname}
  If *macroP
    maclen.w = Peek.w(*macroP + 8)
    If maclen > 32 Then maclen = 32
    macroP.l = Peek.l(*macroP + 4)
    If macroP Then help.s = StripLead$(Peeks$(macroP,maclen),32)
    help.s = StripLead$(help,@";")
    Function Return help.s
  End If
  Function Return ""
End Function


Function.b PED_CheckForClassicToken{_token.l}
    _libnum.l = _token ASR 7

    ; check for a classic lib
    ccounter.b = 0
    Repeat
      classicID.l = Peek.w(?classiccommands + ccounter)
      If (classicID > 0) AND (classicID = _libnum)
        Pop Repeat:Pop If
        Function Return True
      EndIf
      ccounter + 2
    Until classicID = 0

    ; check for a classic command
    exit_classicloop.b = False
    Repeat
      classicID.l = Peek.w(?classiccommands + ccounter)
      If (classicID > 0) AND (classicID = _token)
        Pop Repeat : Pop If
        Function Return True
      EndIf
      ccounter + 2
    Until classicID = 0 OR exit_classicloop
    Function Return False
End Function


Function.s PED_ParseText{strLine.s}

  If FLen(strLine) > #MAX_Columns
    error{"Cannot past: string to long: " + Str$(FLen(strLine))}
  EndIf

  GetReg D0,&strLine : MOVE.l D0,-(a7)
  !asm
  MOVE.l (a7)+,D2 : MOVE.l D2,A2      ; pointer to String to parse to be in A2
  MOVEA.l comPtr_CurrentSourceLine,A4 : JSR parse_line
  ;MOVE.l D5,-(a7)                     ; returns length of string in D5
  !basic
  ;MOVE.l (a7)+,D0 : PutReg d0,tmpd0.l
  ;MOVE.l comPtr_Temp_TokenString1,D0 : PutReg D0,ptrTokenString1.l
  ;result.s = Peeks$(Peek.l(ptrTokenString1),tmpd0)
  result.s = ""
  Function Return result
End Function


Function.s PED_DetokeText{strLine.s}
SHARED ped, tmpDetokeStr.s

  If strLine = "" Then Function Return ""
 
  _strLen.w = FLen(strLine)
  If _strLen

    If Peek.b(?noDetokenizing)
      tmpDetokeStr = strLine
    Else
      ped\inString = False
      tmpDetokeStr = "" ;String$(Chr$(0),#MAX_Columns)
      For i.w = 0 To _strLen - 1
        curChar.b  = Peek.b(&strLine +  i)
        If curChar = $22 Then ped\inString = NOT ped\inString
        If ped\inString = 0 AND (curChar < 0)
          _token.l = Peek.w(&strLine + i)
          _tokname.s = PED_GetTokenName{_token}
          tmpDetokeStr + _tokname
          i + 1
        Else
          tmpDetokeStr + Chr$(curChar)
        EndIf
      Next i      
    EndIf
  EndIf
  ;log_Print{">>" + tmpDetokeStr}
  Function Return tmpDetokeStr
End Function

Function.s PED_Detoke{*sourceLine.sourceLine}
  If *sourceLine = 0 Then Function Return ""
  Function Return PED_DetokeText{Peek.s(*sourceLine + 9)}
End Function



Function.b PED_Detokenize2Textbuffer{ptrOrgString.l}
SHARED ped

  _strLen.w = Len(Peek.s(ptrOrgString))
  If _strLen
    If ped\keepString = 0 Then ped\inString = False

    If Peek.b(?noDetokenizing)
      For i.w = 0 To _strLen - 1
        Poke.b ped\ptrTextbufferPrint + i, Peek.b(ptrOrgString + i)
      Next i
      runnerP.w = i + 1
    Else
      runnerP.w = 0
      For i.w = 0 To _strLen - 1
        curChar.b  = Peek.b(ptrOrgString + i)
        If curChar = $22 Then ped\inString = NOT ped\inString
        If ped\inString = 0 AND (curChar < 0)
          _token.l = Peek.w(ptrOrgString + i)
          _tokname.s = PED_GetTokenName{_token}
          For j.b = 0 To FLen(_tokname)-1
            Poke.b ped\ptrTextbufferPrint + runnerP, Peek.b(&_tokname + j) BitSet 7
            runnerP + 1
          Next j
          i + 1
        Else
          Poke.b ped\ptrTextbufferPrint + runnerP, curChar
          runnerP + 1
        EndIf
      Next i      
    EndIf
    Poke.b ped\ptrTextbufferPrint + runnerP,0 
  EndIf

  Function Return True
End Function




Function.s PED_DetokenizeText{strLine.s}
SHARED ped,*PreProcessor

  If ped\DoTokenize
    MaxLen linebuff$ = 256
    preproc_Detokenize{*PreProcessor,&strline$,&linebuff$,FLen(strline$)}
    strLine = Peek.s(&linebuff$)
  EndIf

  Function Return strLine

End Function


Function.s PED_TokenizeText{strLine.s}
SHARED ped,*PreProcessor

  If ped\DoTokenize
    MaxLen linebuff$ = 256
    preproc_Tokenize{*PreProcessor,&strLine.s,&linebuff$,FLen(strLine)}
    strLine.s = Peek.s(&linebuff$)
  Else
    log_Print{"PED_TokenizeText: tokenization turned off"}
  EndIf

  Function Return strLine
End Function


NEWTYPE .HelpIndexCacheItem
  name.s
  lname.s
  help.s
  includefile.s
End NEWTYPE
Dim List HelpIndexCache.HelpIndexCacheItem(0)


Statement PED_UpdateHelpIndexCache{HelpIndexFile$}
  SHARED HelpIndexCache()
  ;fidW.l = file_Open{"sys:pedbug.txt",#file_forcewrite}
  fid.l = file_Open{HelpIndexFile$,#file_read}
  If fid<>-1
    ClearList HelpIndexCache()
    ;file_Cache{fid}
    While file_EOF{fid} = False
      zeile$ = file_ReadLine{fid}

      pos_name.l  = Instr(zeile$,"\\09",1)
      If pos_name=0 Then pos_name=FLen(zeile$)+1

      pos_desc.l  = Instr(zeile$,"\\09",pos_name+1)
      If pos_desc=0 Then pos_desc=FLen(zeile$)+1

      typ$  = Mid$(zeile$,1,pos_name-1)
      name$ = Mid$(zeile$,pos_name+1,pos_desc-pos_name-1)
      help$ = Mid$(zeile$,pos_desc+1)

      ;file_WriteLine{fidW,typ$+"::"+name$+"::"+help$}
      If typ$><""
      If typ$ = "FILE"
        filename$ = name$
      Else

        lname$ = LCase$(name$)
        If name$><""
          If help$=""
            Select typ$
              Case "FUNC" : help$ = "{...} ; Function"
              Case "MACR" : help$ = "{...} ; Macro"
              Case "STAT" : help$ = "{...} ; Statement"
              Default
                help$ = typ$
            End Select
          End If
          If AddItem(HelpIndexCache())
            HelpIndexCache()\name  = name$
            HelpIndexCache()\lname = lname$
            HelpIndexCache()\help  = help$
            HelpIndexCache()\includefile = filename$
          End If
        End If
      End If
      End If
    Wend
    file_Close{fid}
  Else
    error{"Could not open Helpindexfile for read."}
  End If
  ;If fidW><-1 Then file_Close{fidW}

End Statement


Statement PED_WriteHelpIndexCache{HelpIndexCacheFile$}
  SHARED HelpIndexCache()

  If dos_Exist{HelpIndexCacheFile$} Then dos_Delete{HelpIndexCacheFile$}

  If OpenFile(1,HelpIndexCacheFile$)
    ResetList HelpIndexCache()
    While NextItem(HelpIndexCache())
      WriteType 1,HelpIndexCache()
    Wend
    CloseFile 1
  End If
End Statement


Statement PED_LoadHelpIndexCache{HelpIndexCacheFile$}
  SHARED HelpIndexCache()
;  fidW.l = file_Open{"sys:pedbug.txt",#file_forcewrite}

  If OpenFile(1,HelpIndexCacheFile$)
    ClearList HelpIndexCache()
    _lof.l = Lof(1)
    While _lof > Loc(1)
      If AddLast(HelpIndexCache())
        ReadType 1,HelpIndexCache()
        ;!cout{"*"+HelpIndexCache()\name+"*"}
        ;file_WriteLine{fidW,HelpIndexCache()\name}
      Else
        error{!TRANS{"Could not build index cache."}}
        Pop While: Goto exit_while1
      EndIf
    Wend
    exit_while1:
    CloseFile 1
  Else
    error{HelpIndexCacheFile$ + " "+!TRANS{"not found."}}
  End If

;  If fidW><-1 Then file_Close{fidW}

End Statement


Function.s PED_GetIncludeHelp{tname$}
  SHARED pedconfig,HelpIndexCache()
  lname$ = LCase$(tname$)
  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then PED_LoadHelpIndexCache{pedconfig\HelpIndexCacheFile}
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache())
    If HelpIndexCache()\lname = lname$
      Function Return HelpIndexCache()\help
    End If
  Wend
  Function Return ""                 ; function not found
End Function


Function.s PED_GetIncludeFunction{tname$}
  SHARED pedconfig,HelpIndexCache()
  lname$ = LCase$(tname$)
  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then PED_LoadHelpIndexCache{pedconfig\HelpIndexCacheFile}
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache())
    If HelpIndexCache()\lname = lname$
      Function Return HelpIndexCache()\name
    End If
  Wend
  Function Return ""                 ; function not found
End Function


Function.s PED_GetIncludeName{tname$}
  SHARED pedconfig,HelpIndexCache()
  lname$ = LCase$(tname$)
  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then PED_LoadHelpIndexCache{pedconfig\HelpIndexCacheFile}
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache())
    If HelpIndexCache()\lname = lname$
      Function Return HelpIndexCache()\includefile
    End If
  Wend
  Function Return "" ; function not found
End Function



Function.s PED_GetHelptextFor{tokname$}
                                                                                                                                                                                                                                         
  If Left$(tokname$,1) = "!"

    tokname$ = PED_GetMacroName{tokname$}
;    tokhelp$ = PED_GetMacroHelp{tokname$}
    tokexte$ = "Macro"
  Else
    tokid.w = PED_GetTokenID{tokname$}
    If tokid >= 0
      tokname$ = PED_GetTokenName{tokid}
      libnum.l = PED_GetTokenLibnum{tokname$}
      If libnum>=0
        tokhelp$ = PED_GetTokenHelp{tokname$}
        tokexte$ = "BlitzLib: " + PED_GetLibname{libnum}
      End If
    Else
      tokname$ = PED_GetIncludeFunction{tokname$}
      If tokname$<>""
        tokhelp$ = PED_GetIncludeHelp{tokname$}
        tokexte$ = "Include: " + PED_GetIncludeName{tokname$}
      End If
    End If
  End If

  strhelp$ = tokname$
  If tokhelp$ <> "" Then strhelp$ + " " + tokhelp$
  If tokexte$ <> "" Then strhelp$ + " | " + tokexte$

  Function Return strhelp$
End Function

                                                                                                                                                                                                                                                         
Function.b PED_ShowHelptextFor{tokname.s}
  log_Print{"ShowHelpTextFor{}"}

  result.b = False
  If tokname <> ""
    strhelp.s =  PED_GetHelptextFor{tokname}
    If FLen(strhelp) < 3
      PED_ShowMessage{""}                                                                                                                                                                                                                                
    Else
      PED_ShowMessage{strhelp}                                                                                                                                                                                                                           
      result.b = True
    EndIf
  EndIf                                                                                                                                                                                                                                                  
  Function Return result
End Function



Statement PED_PrintTextStandard{*textaddr.l, tx.w, ty.w}
SHARED ped,sourceWindow,AB3Pen()

  ;log_Print{"print_standard_text"}

  ; copy the current Line To a tempBuffer
  For i.w = 0 To Len(Peek$(*textaddr))
    Poke.b ped\ptrTextbufferPrint + i, Peek.b(*textaddr + i)
  Next i

  startPos.w = ped\ptrCurrentSourceData\ColumnsOffsetTmp
  tmpString$ = UnRight$(Peek$(*textaddr),startPos)

  tlength.w = Len(tmpString$)
  If tlength > sourceWindow\visibleColumns Then tlength = sourceWindow\visibleColumns

  tposy.w = ty * sourceWindow\font\tf_YSize + sourceWindow\font\tf_Baseline + sourceWindow\BoxTop
  tposx.w = tx * sourceWindow\font\tf_XSize + sourceWindow\BoxLeft

  Move_ sourceWindow\win\RPort, tposx, tposy
  SetAPen_ sourceWindow\win\RPort,AB3Pen(#AB3_cother)
  SetBPen_ sourceWindow\win\RPort,AB3Pen(#AB3_cbackground)
  Text_ sourceWindow\win\RPort,&tmpString$,tlength

End Statement



Statement PED_PrintText{*textaddr.l, xPos.w, yPos.w, textlength.w, textcolor.w}
SHARED pedconfig, sourceWindow, AB3RGB(), AB3Pen()

  printtext.s = Peeks$(*textaddr, textlength)
  ;log_Print{"[" + printtext + "]"}
  ; -- clip text to visible columns
  If (textlength > sourceWindow\visibleColumns) Then textlength = sourceWindow\visibleColumns

  mx.w = xPos * sourceWindow\font\tf_XSize + sourceWindow\BoxLeft
  my.w = yPos * sourceWindow\font\tf_YSize + sourceWindow\BoxTop + sourceWindow\font\tf_Baseline
  Move_ sourceWindow\win\RPort ,mx ,my

  SetAPen_ sourceWindow\win\RPort, textcolor
  SetBPen_ sourceWindow\win\RPort, AB3Pen(#AB3_cbackground)

  If (AB3RGB(#AB3_cremarkforeground) OR AB3RGB(#AB3_cremarkbackground)) AND pedconfig\highlighting
    semi_position.w = 0
    in_string.b = 0
;    columnsoff.w = ped\ptrCurrentSourceData\ColumnsOffset
;
    ; -- search for a comment and save the starting position
    search_again2:
    semi_position = Instr(printtext,";",semi_position + 1)
    If semi_position > 0
       ;log_Print{"; found at " + Str$(semi_position)}
       ; -- check if the comment-char +++ ; +++ is in a string
       acount.b = 0
       For i.w = 1 To semi_position
         If Mid$(printtext,i,1) = Chr$($22) Then acount + 1
       Next i
       If (acount MOD 2) = 1
         ; -- ungerade Anzahl von +++ " +++ impliziert, das +++ ; +++ in einem String steckt...
         semi_position = 0
       Else
         If Mid$(printtext,semi_position + 1,2)=":@"
           ; -- nachschauen, ob dahinter ein echter Kommentar kommt
           Goto search_again2
         EndIf
       EndIf
       If semi_position > textlength Then semi_position = 0
     EndIf
     If semi_position > 0
       semi_position - 1 ; highlight +++ ; ++ as well

       ; -- print text before +++ ; +++

       If semi_position > 0
         Text_ sourceWindow\win\RPort,&printtext,semi_position
       EndIf

       ; -- print comment
       SetAPen_ sourceWindow\win\RPort, AB3Pen(#AB3_cremarkforeground)
       SetBPen_ sourceWindow\win\RPort, AB3Pen(#AB3_cremarkbackground)
       If pedconfig\italic_remarks
         SetFont_ sourceWindow\win\RPort,sourceWindow\fontI
         SetSoftStyle_ sourceWindow\win\RPort, #FSF_ITALIC,#FSF_ITALIC
       EndIf

       printtext = UnRight$(printtext,semi_position)
       ;log_Print{"comment: " + printtext}
       Text_ sourceWindow\win\RPort,&printtext,FLen(printtext)

       ; -- restore standard backgroundcolor and font if changed
       SetBPen_ sourceWindow\win\RPort,AB3Pen(#AB3_cbackground)
       If pedconfig\italic_remarks
         SetFont_ sourceWindow\win\RPort,sourceWindow\font
         SetSoftStyle_ sourceWindow\win\RPort,#FS_NORMAL,#FSF_ITALIC
       EndIf
     Else
       Text_ sourceWindow\win\RPort,&printtext, textlength
     EndIf
  Else
    Text_ sourceWindow\win\RPort,&printtext, textlength
  EndIf 

End Statement

Statement PED_PrintTokenizedText{*textaddr.l, tposx.w, tposy.w}
SHARED sourceWindow, ped, pedconfig, AB3Pen()
USEPATH sourceWindow

  ;-- clear textBufferPrint
  For i.w = 0 To #MAX_Columns/4-1 Step 4
    Poke.l  ped\ptrTextbufferPrint + i, 0
  Next i

  ;-- original string
  tmpString1.s = Peeks$(*textaddr,#MAX_Columns)

  ;-- detokenize it but keep token indicator (bit7)  
  PED_Detokenize2Textbuffer{&tmpString1}
  tmpString2.s = Peek.s(ped\ptrTextbufferPrint)
 
  ;-- check if source left of display start position has an opened string literal
  If ped\keepString = 0
    chkString.b = 0

    If tmpString1 <> ""
      runner.w = 0
      While runner < ped\ptrCurrentSourceData\ColumnsOffset
        If Peek.b(&tmpString1 + runner) = $22 Then chkString = NOT chkString
        runner + 1
      Wend
    EndIf
  EndIf
  ;log_Print{"we are in a string: " + Str$(chkString)}

  tmpPrint.s = UnRight$(tmpString2, ped\ptrCurrentSourceData\ColumnsOffsetTmp)
  lastVisibleChar$ = Mid$(tmpPrint,\visibleColumns,1)
  tmpPrint = Left$(tmpPrint,\visibleColumns)

  tposx = tposx / \font\tf_XSize
  runner.w = -1

  print_loop:
  tmpExpand.s = ""
  Repeat
    runner + 1
    curChar.b = Peek.b(&tmpPrint + runner)
    If curChar <> 0
      If curChar = $22 Then chkString.b = NOT chkString
      If chkString = 0
        If curChar < 0 Then Goto exit_printloop
      EndIf
      tmpExpand + Chr$(curChar)
    EndIf
  Until curChar = 0
  exit_printloop:

  ; print all normal characters we found so far...
  If FLen(tmpExpand)
    PED_PrintText{&tmpExpand, tposx, tposy, FLen(tmpExpand), AB3Pen(#AB3_cother)}
    tposx + FLen(tmpExpand)
  EndIf
  If curChar = 0 Then Goto exit_print
  If curChar > 0 Then Goto print_loop

  ; if we have a token, print it ...
  tmpExpand.s = ""
  While curChar < 0
    tmpExpand + Chr$(curChar BitClr 7)
    runner + 1
    curChar = Peek.b(&tmpPrint + runner)
  Wend
  runner - 1

  If FLen(tmpExpand)
    ;-- check for classic token and set color else set standard token color
    tcolor.w = AB3Pen(#AB3_ctoken)
    If AB3Pen(#AB3_cclassic) > 0
      _token.l = PED_GetTokenID{tmpExpand}
      If PED_CheckForClassicToken{_token} Then tcolor.w = AB3Pen(#AB3_cclassic)
    EndIf

    ;-- print the token
    SetBPen_ \win\RPort, AB3Pen(#AB3_ctokenbackground)
    If pedconfig\bold_tokens
     SetFont_ \win\RPort, \fontB
      SetSoftStyle_ \win\RPort,#FSF_BOLD,#FSF_BOLD
    EndIf

    PED_PrintText{&tmpExpand, tposx, tposy, FLen(tmpExpand), tcolor}

    ;-- reset font and style
    SetBPen_ \win\RPort, AB3Pen(#AB3_cbackground)
    If pedconfig\bold_tokens
      SetFont_ \win\RPort, \font
      SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_BOLD
    EndIf

    tposx + FLen(tmpExpand)

    If curChar <> 0 Then Goto print_loop
  EndIf

  exit_print:
End Statement

Function PED_PrintChar{enteredChar.b}
SHARED sourceWindow,ped,AB3Pen()
USEPATH ped\ptrCurrentSourceData

  currentColumn.w = \Column + \ColumnsOffset

  ;-- write character to textbuffer
  plineaddr.l = Peek.l(?textbufferaddr) + \TextBufferOffset + currentColumn
  Poke.b plineaddr,enteredChar

  ;-- check if cursor in block
  If \BlockEndY <> $ffffFFFF
    currentLine.l = \DisplayLine + \DisplayLineOffset
    !updateBlockMark{currentLine, currentColumn}
  EndIf

  ; -- print entered character to source window
  \ColumnsOffsetTmp = 0

  tposx.w = \Column
  tposy.w = \DisplayLine
  textaddr.l = &enteredChar ;?comByte_EnteredCharacter

  If \StateBlockMark
    log_Print{"cursor in block, routine called."}
     ; --- print actual character with blockbackgroundcolor
     SetBPen_ sourceWindow\win\RPort,3
     PED_PrintText{&enteredChar,tposx,tposy,1,AB3Pen(#AB3_cother)}
     SetBPen_ sourceWindow\win\RPort,AB3Pen(#AB3_cbackground)
  Else 
    If Peek.b(&enteredChar) > 0
      ;log_Print{"Print ["  + Chr$(enteredChar) + "] at " + Str$(tposx) + ", " + Str$(tposy) + " - offset " + Str$(\ColumnsOffset)}
      PED_PrintText{&enteredChar, tposx, tposy, 1, AB3Pen(#AB3_cother)}
    Else
      textaddr.l = &enteredChar
      If Peek.w(?instru)
        log_Print{"instru handling missing.",#log_warning}
        textaddr = textaddr BitClr 7
      Else
        log_Print{"whats up?",#log_warning}
      EndIf
      PED_PrintText{textaddr,tposx,tposy,1,AB3Pen(#AB3_cclassic)}
    EndIf
  EndIf
End Function


Statement PED_PrintHighlight{lineaddr.l, xPos.w, textlen.w, textcolor.w, textstyle.w}
SHARED ped, sourceWindow
;  If False
  If textlen > 0
    ;log_Print{"macro to print: " + Peeks$(lineaddr,textlen)}
    xPos = xPos - ped\ptrCurrentSourceData\ColumnsOffset

    If (textlen + xPos) > sourceWindow\visibleColumns
      textlen = sourceWindow\visibleColumns - xPos
    EndIf
    If textlen > 0
      lineaddr2.l = lineaddr
      If xPos < 0
        textlen + xPos
        lineaddr = lineaddr - xPos
        xPos = 0
      EndIf
      If textlen > 0
        xText.w = sourceWindow\BoxLeft + xPos * sourceWindow\font\tf_XSize
        yText.w = sourceWindow\BoxTop  + ped\ptrCurrentSourceData\DisplayLine * sourceWindow\font\tf_YSize + sourceWindow\font\tf_Baseline
        Move_ sourceWindow\win\RPort, xText, yText
        SetAPen_ sourceWindow\win\RPort,textcolor
        ;SetSoftStyle_ \win\RPort,textstyle,textstyle
        Text_ sourceWindow\win\RPort,lineaddr, textlen
      EndIf
    EndIf
   EndIf
End Statement


Statement PED_ProcessHighlighting{}
SHARED pedconfig, ped, sourceWindow, AB3Pen()

 If NOT pedconfig\highlighting Then Goto skip_highlighting

  lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
  ;log_Print{"process highlighting -  textbufferaddr:"}
  ;log_Print{Peeks$(lineaddr,20)}
  runner.w = 0 : exit_highlight.b = False
  Repeat
    curchar.s = Chr$(Peek.b(lineaddr + runner)) : textlen.w = 0
    Select curchar
    Case ";"
      ;skip parsing as we have a comment here
      ;log_Print{"comment found" + Peeks$(lineaddr + runner,40)}
      exit_highlight = True

    Case Chr$($22)
      If AB3Pen(#AB3_cstring) <> AB3Pen(#AB3_cother)
        ;log_Print { "search string [" + Peeks$(lineaddr + runner + 1,40) + "]"}
        textlen = Instr(Peek.s(lineaddr + runner + 1),Chr$($22))   ; search for string mark
        If textlen
          textlen + 1
          ;log_Print { "string [" + Peeks$(lineaddr+runner+1 ,textlen) + "], " + Str$(textlen)}
          PED_PrintHighlight{lineaddr + runner, runner , textlen, AB3Pen(#AB3_cstring), 0}
        EndIf
      EndIf

    Case "{"
      ;log_Print{"statement found ??"}
      If AB3Pen(#AB3_cfunction) <> AB3Pen(#AB3_cother)
        ; skip all spaces backwards
        i.w = -1
        While (runner+i => 0) AND Peek.b(lineaddr + runner + i) = 32
          ;log_Print{Str$(runner+i) + " ["+Peeks$(lineaddr+runner+i,1)+"]"}
          i - 1
        Wend
        If runner + i => 0
          For i.w = runner + i To 0 Step -1
            checkchr.b = Peek.b(lineaddr + i)
            ;log_Print{"function checking [" + Chr$(checkchr) +  "] in "+ Peeks$(lineaddr + i,20)}
            If checkchr = @"!" OR (checkchr < 0) ; check if we have a token before "{"
              Pop For : Pop If : Pop If : Pop If
              Goto Exit_function
            EndIf

            If !PED_CheckUnAllowedChar{checkchr} OR (i = 0)
              textlen = runner - i
              PED_PrintHighlight{lineaddr + i, i , textlen, AB3Pen(#AB3_cfunction), 0}
              Pop For : Pop If : Pop If : Pop If
              Goto Exit_function
            EndIf
          Next i
        EndIf
        Exit_function:
        ped\inString = False
        textlen = 0
      EndIf


    Case "!"
      ;log_Print{"macro found: " + Peeks$(lineaddr,20)}
      If AB3Pen(#AB3_cmacro) <> AB3Pen(#AB3_cother)
        For i.w = runner + 1 To #MAX_Columns - 1
          ;log_Print{"macro checking [" + Peeks$(lineaddr + i,1) +  "] in "+ Peeks$(lineaddr,20)}
          If !PED_CheckUnAllowedChar{Peek.b(lineaddr + i)}
            textlen = i - runner
            PED_PrintHighlight{lineaddr + runner, runner, textlen, AB3Pen(#AB3_cmacro), 0}
            Pop For : Pop If
            Goto Exit_macro
          EndIf
        Next i
        Exit_macro:
      EndIf

    Case "#"
      If AB3Pen(#AB3_cconstant) <> AB3Pen(#AB3_cother)
        For i.w = runner + 1 To #MAX_Columns - 1
          checkchr.b = Peek.b(lineaddr + i)

          If checkchr = $22 Then ped\inString = NOT ped\inString

          If ped\inString = False
            ;log_Print{"macro checking [" + Chr$(checkchr) +  "] in "+ Peeks$(lineaddr,20)}
            If checkchr <> @"$" AND checkchr <> @"%"; OR checkchr = @"-"
              If !PED_CheckUnAllowedChar{Peek.b(lineaddr + i)}
                textlen = i - runner
                PED_PrintHighlight{lineaddr + runner, runner , textlen, AB3Pen(#AB3_cconstant), 0}
                Pop For : Pop If : Pop If : Pop If
                Goto Exit_constant
              EndIf
            EndIf
          EndIf
        Next i
        Exit_constant:
        ped\inString = False
      EndIf

    Case "\"
      If AB3Pen(#AB3_cnewtype) <> AB3Pen(#AB3_cother)
        For i.w = runner + 1 To #MAX_Columns - 1
          checkchr.b = Peek.b(lineaddr + i)

          If checkchr = $22 Then ped\inString = NOT ped\inString

          If ped\inString = False
            ;log_Print{"macro checking [" + Chr$(checkchr) +  "] in "+ Peeks$(lineaddr,20)}
            If checkchr <> @"\"
              If !PED_CheckUnAllowedChar{Peek.b(lineaddr + i)}
                textlen = i - runner
                PED_PrintHighlight{lineaddr + runner, runner , textlen, AB3Pen(#AB3_cnewtype), 0}
                Pop For : Pop If : Pop If : Pop If
                Goto Exit_newtype
              EndIf
            EndIf
          EndIf
        Next i
        Exit_newtype:
        ped\inString = False
       EndIf
    End Select
    If textlen Then runner = runner + textlen - 1
    runner + 1
  Until exit_highlight OR runner >= #MAX_Columns - 1
  skip_highlighting:
End Statement


Statement PED_PrintSourceText{*textaddr.l, tposx.w, tposy.w, @clearEndOfLine.b}
SHARED sourceWindow, ped, AB3Pen()

  If ped\DoTokenize
    PED_PrintTokenizedText{*textaddr, tposx, tposy}
  Else
    PED_PrintTextStandard{*textaddr, tposx, tposy}
  EndIf

  If clearEndOfLine = True
    USEPATH sourceWindow

    If \win\RPort\cp_x <= \BoxLeft
      rectx.w = \win\RPort\cp_x + 1
    Else
      rectx.w = \win\RPort\cp_x
    EndIf 
    recty.w = \BoxTop + ped\ptrCurrentSourceData\DisplayLine * \font\tf_YSize
    rectw.w = \BoxWidth
    recth.w = recty + \font\tf_YSize-1
    If (rectw => rectx) AND (recth => recty)
      SetAPen_  \win\RPort, AB3Pen(#AB3_cbackground)
      RectFill_ \win\RPort, rectx, recty, rectw, recth
    Else
      log_Print{"illegal area for clear bottom:",#log_error}
      log_Print{Str$(rectx) + ", " + Str$(rectw)}
      log_Print{Str$(recty) + ", " + Str$(recth)}
    EndIf
  EndIf
End Statement

Statement PED_PrintLineNumber{}
SHARED sourceWindow, ped, AB3Pen()
USEPATH sourceWindow

  dl.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine + 1
  linenum$ = Str$(dl)

  lx.w = \BoxLeft - (FLen(linenum$) * \font\tf_XSize) - 2                                                                                                                                                                                               
  ly.w = \BoxTop + ped\ptrCurrentSourceData\DisplayLine * \font\tf_YSize

  SetAPen_ \win\RPort,AB3Pen(#AB3_screenfill)
  RectFill_ \win\RPort,0,ly,\BoxLeft-1,ly + \font\tf_YSize - 1                                                                                                                                                                                           

  SetAPen_ \win\RPort,AB3Pen(#AB3_screenshine)
  SetBPen_ \win\RPort,AB3Pen(#AB3_screenfill)                                                                                                                                                                                                          
  Move_ \win\RPort,lx,ly + \font\tf_Baseline
  Text_ \win\RPort,&linenum$,FLen(linenum$)

  ;Move_ \win\RPort,0,ly; + \font\tf_Baseline
  ;Draw_ \win\RPort,\BoxLeft,ly

  SetAPen_ \win\RPort,AB3Pen(#AB3_screenshine)
  Move_ \win\RPort,\BoxLeft-1,ly                                                                                                                                                                                                                         
  Draw_ \win\RPort,\BoxLeft-1,ly + \font\tf_YSize - 1
End Statement

Statement PED_PrintCurrentSourceLine{@clearEndOfLine.b}
SHARED pedconfig, ped, sourceWindow, AB3Pen()

  If pedconfig\linenumbers Then PED_PrintLineNumber{}

  *sl.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine

  If *sl = 0 Then Statement Return

  If Peek.b(*sl + 9) <> 0   ; first character of text
    ped\ptrCurrentSourceData\ColumnsOffsetTmp = ped\ptrCurrentSourceData\ColumnsOffset
    PED_PrintSourceText{*sl + 9,0,ped\ptrCurrentSourceData\DisplayLine, clearEndOfLine}
  Else
    USEPATH sourceWindow
    SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    ;SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    xMin.w = \BoxLeft
    yMin.w = \BoxTop + ped\ptrCurrentSourceData\DisplayLine * \font\tf_YSize
    xMax.w = \BoxWidth
    yMax.w = yMin + \font\tf_YSize - 1
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ \win\RPort, xMin, yMin, xMax, yMax
    Else
      log_Print{"illegal area for JL_0_5E72!",#log_error}
      log_Print{Str$(xMin) + ", " + Str$(xMax)}
      log_Print{Str$(yMin) + ", " + Str$(yMax)}
    EndIf
    Move_ \win\RPort, 0, ped\ptrCurrentSourceData\DisplayLine * \font\tf_YSize + \font\tf_YSize ; move cursor to next line

    Poke.l ped\ptrTextbufferPrint,0
  EndIf                                                                                                                                                                                                                                                ;


  ;-- copy current printed line to textbuffer
  tmpColumn.w = ped\ptrCurrentSourceData\Column                           ; save Columnpos as it is changed for process_highlighting

  char.b = Peek.b(ped\ptrTextbufferPrint)
  If char <> 0
    tmpD2.w = 0
    tmpD3.w = 0
    textBufferPos.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
    If char <> ped\LabelIdentifier Then Goto jump_into_it
    Gosub copy_to_textBuffer
    Repeat
      tmpD2 + 1
      char = Peek.b(ped\ptrTextbufferPrint + tmpD2)
      If char <> 0
jump_into_it:
        Gosub copy_to_textBuffer
      End If
    Until char = 0
  EndIf

  ;-- do highlighting
  PED_ProcessHighlighting{}

  ; -- handle blockmark - seems useless ?
  ;If ped\ptrCurrentSourceData\BlockEndY<> $ffffFFFF
  ;  If ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine > ped\ptrCurrentSourceData\BlockStartY
  ;    If ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine < ped\ptrCurrentSourceData\BlockEndY
  ;      While tmpD3 <= \visibleColumns
  ;        ; fill with blanks
  ;        ;  MOVEQ.l #$20,D0 (displaylineoffset + displayline)
  ;        ped\ptrCurrentSourceData\Column = tmpD3
  ;        tmpD3 + 1
  ;      Wend
  ;    EndIf
  ;  EndIf
  ;EndIf

  ;-- restore Columnposition
  ped\ptrCurrentSourceData\Column = tmpColumn
  Statement Return

.copy_to_textBuffer:
  Poke.b textBufferPos + tmpD2, char
  If tmpD2 <= ped\ptrCurrentSourceData\ColumnsOffset
    If tmpD3 <= sourceWindow\visibleColumns
      ped\ptrCurrentSourceData\Column = tmpD3
      tmpD3 + 1
    EndIf
  EndIf
Return

End Statement


Statement PED_AbsBlockDimensions{}
SHARED ped
  ;  log_Print{"abs blockdims"}
  tempD0.w = ped\ptrCurrentSourceData\BlockStartX
  tempD1.l = ped\ptrCurrentSourceData\BlockStartY
  tempD2.w = ped\ptrCurrentSourceData\BlockEndX
  tempD3.l = ped\ptrCurrentSourceData\BlockEndY
  If tempD1 >= tempD3
    If tempD1 <> tempD3
      absloop:
      Exchange tempD0, tempD2
      Exchange tempD1, tempD3
      ped\ptrCurrentSourceData\BlockStartX = tempD0
      ped\ptrCurrentSourceData\BlockStartY = tempD1
      ped\ptrCurrentSourceData\BlockEndX   = tempD2
      ped\ptrCurrentSourceData\BlockEndY   = tempD3
    EndIf
    If tempD0 > tempD2
      Goto absloop
    EndIf
  EndIf
End Statement

Statement PED_DrawBlock{*bmark.bmark} ;xMin.w,yMin.w, xMax.w, yMax.w, absolute.b}
SHARED ped, sourceWindow

  CopyType *bmark,bm.bmark
  ;msg$ = "PED_DrawBlock() 1 called: "
  ;msg$ + Str$(bmark\xMin) + ", " + Str$(bmark\yMin) + " - "
  ;msg$ + Str$(bmark\xMax) + ", " + Str$(bmark\yMax)
  ;log_Print{msg$}

  If bm\xMin < 0 Then bm\xMin = 0
  If bm\xMax < 0 Then bm\xMax = 0 : Else : bm\xMax + 1
  If bm\yMin < 0 Then bm\yMin = 0
  If bm\yMax < 0 Then bm\yMax = 0

  bm\xMax - ped\ptrCurrentSourceData\ColumnsOffset
  bm\xMin - ped\ptrCurrentSourceData\ColumnsOffset

  If bm\xMax > \visibleColumns Then bm\xMax = \visibleColumns
  If bm\yMax > \visibleLines - 1 Then bm\yMax = \visibleLines - 1
  If bm\yMin > \visibleLines - 1 Then bm\yMin = \visibleLines - 1

  bm\xMin * \font\tf_XSize
  bm\yMin * \font\tf_YSize
  bm\xMax * \font\tf_XSize
  bm\yMax * \font\tf_YSize

  If bm\yMin > bm\yMax Then Exchange bm\yMax,bm\yMin
  If bm\xMin > bm\xMax Then Exchange bm\xMax,bm\xMin

  If bm\yMin = bm\yMax
    bm\yMax = bm\yMax + \font\tf_YSize - 1
    Gosub rectfill2
  Else
    ; draw three parts of the block: first line, block of full marked lines, last line
    DEFTYPE.bmark bmOld
    CopyType bm, bmOld

    bm\yMax = bm\yMin + \font\tf_YSize - 1
    bm\xMax = \visibleColumns * \font\tf_XSize
    Gosub rectfill2

    CopyType bmOld, bm

    bm\yMin = bm\yMin + \font\tf_YSize
    If bm\yMin < bm\yMax
        CopyType bm, bmOld
        bm\xMin = 0
        bm\xMax = \visibleColumns * \font\tf_XSize
        bm\yMax - 1
        Gosub rectfill2

        CopyType bmOld,bm
        bm\xMin = 0
        bm\yMin = bm\yMax
    EndIf

    bm\xMin = 0
    bm\yMax + \font\tf_YSize - 1
    Gosub rectfill2
  EndIf

  ;msg$ = "PED_DrawBlock() 2 called: "
  ;msg$ + Str$(bm\xMin) + ", " + Str$(bm\yMin) + " - "
  ;msg$ + Str$(bm\xMax) + ", " + Str$(bm\yMax)
  ;log_Print{msg$}

  Statement Return

  rectfill2:
  If (bm\xMax >= bm\xMin) AND (bm\yMax >= bm\yMin)
    sourceWindow\rp\Mask = %1111
    RectFill_ sourceWindow\rp, sourceWindow\BoxLeft + bm\xMin, sourceWindow\BoxTop + bm\yMin, sourceWindow\BoxLeft + bm\xMax - 1, sourceWindow\BoxTop + bm\yMax
  EndIf
  Return
End Statement

Statement PED_UpdateBlockPosY{y.l}
SHARED ped
  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
    If y <= ped\ptrCurrentSourceData\BlockEndY
      ped\ptrCurrentSourceData\BlockEndY + 1
      If y <= ped\ptrCurrentSourceData\BlockStartY
        ped\ptrCurrentSourceData\BlockStartY + 1
      EndIf
    EndIf
  EndIf
End Statement




Statement PED_RedrawSource{@onlyBlock.b}                                                                                                                                                                                                                 
SHARED pedconfig, ped, sourceWindow, AB3Pen()                                                                                                                                                                                                            
  ;log_Print{"redraw, displayline: " + Str$(ped\ptrCurrentSourceData\DisplayLine)  

  If onlyBlock = 0 then Goto draw_block_after_refresh

  *tmpcsl.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  If *tmpcsl = 0 Then Statement Return

  ;log_Print{"displayline: " + Str$(ped\ptrCurrentSourceData\DisplayLine)}
  ;log_Print{"csl : " + Hex$(ped\ptrCurrentSourceData\CurrentSourceLine)}
  ;log_Print{"fsl : " + Hex$(ped\ptrCurrentSourceData\FirstSourceLine)}

  *storeCurrentSourceLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  storeBlockEndY.l = ped\ptrCurrentSourceData\BlockEndY
  ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
  !PED_storeCursorPosition
  PED_ClearTextbuffer{}

  CNIF #hardfold = 1
    ped\foldNumber = PED_CheckFoldingState{}
  CEND

  *tmpcsl.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine

  tmpdl.l = ped\ptrCurrentSourceData\DisplayLine
  While (tmpdl > 0) AND (*tmpcsl <> 0)
    *tmpcsl = *tmpcsl\previousLine

    If *tmpcsl

      CNIF #hardfold = 1
      If Peek.w(*tmpcsl + 9) = @";@"
        PED_CheckFoldingReverse{*tmpcsl}
        If Peek.w(*tmpcsl + 11) = @"@0"
          If ped\foldNumber <> 0
            Pop If : Pop If : Pop If : Goto cont_redraw
          EndIf
        EndIf
      EndIf
      If ped\foldNumber <> 0
        ; jump to beginning of loop without reducing tmpdl
      EndIf
      cont_redraw:
      CEND

      tmpdl - 1
    EndIf
   
  Wend
  ped\ptrCurrentSourceData\DisplayLine = tmpdl
  ped\ptrCurrentSourceData\TextBufferOffset = 0
  ped\ptrCurrentSourceData\ColumnsOffsetTmp = ped\ptrCurrentSourceData\ColumnsOffset

  !PED_CursorOff 

  ;-- draw all the lines

  For cl.l = 1 To sourceWindow\visibleLines
    ped\ptrCurrentSourceData\CurrentSourceLine = *tmpcsl

;    CNIF #hardfold = 1
;   'nr
;      CMP.l #";@@1",9(a2)
;      BNE 'l1
;        MOVE.l #1,foldnum
;        BRA 'do
;     'l1
;      CMP.l #";@@0",9(a2)
;      BNE 'l2
;      MOVE.l #0,foldnum
;     'l2
;      MOVE.l comLong_DisplayLine,d0
;      CMP.l store_comLong_DisplayLine,d0
;      BNE 'l3b
;      ;MOVE.l a2,comPtr_CurrentSourceLine
;     'l3b
;      TST.l foldnum
;      BEQ 'do
;        MOVE.l (a2),d0
;        BEQ JL_0_5902
;          MOVE.l d0,a2
;    BRA 'nr 
;   'do
;    CEND

    If ped\ptrCurrentSourceData\CurrentSourceLine
      PED_PrintCurrentSourceLine{True}
      *tmpcsl = *tmpcsl\nextLine
      !PED_IncreaseDisplayLine
      ;log_Print{"redraw: next line at displayline " + Str$(ped\ptrCurrentSourceData\DisplayLine)}                                                                                                                                                       
    ;Else                                                                                                                                                                                                                                                
     ; log_Print{"redraw: no next line at displayline " + Str$(cl)}                                                                                                                                                                                      
    EndIf
  Next cl 

  ; -- better refresh: clear bottom
  USEPATH sourceWindow
  If ped\ptrCurrentSourceData\DisplayLine < sourceWindow\visibleLines
    ;log_Print{"redraw: clear rest of window at displayline: " + Str$(ped\ptrCurrentSourceData\DisplayLine+1)}
    SetAPen_  \win\RPort, AB3Pen(#AB3_cbackground)
    rectx.w = \BoxLeft
    recty.w = \BoxTop + (ped\ptrCurrentSourceData\DisplayLine) * \font\tf_YSize
    rectw.w = \BoxWidth
    recth.w = \statusAreaY-1
    If (rectw => rectx) AND (recth => recty)
      RectFill_ \win\RPort, rectx, recty, rectw, recth
      If pedconfig\linenumbers 
        SetAPen_  \win\RPort, AB3Pen(#AB3_screenfill)
        RectFill_ \win\RPort, 0, recty, rectx-1,recth
        SetAPen_ \win\RPort,AB3Pen(#AB3_screenshine)
        Move_ \win\RPort,rectx - 1, recty                                                                                                                                                                                                                   
        Draw_ \win\RPort,rectx - 1, recth
      EndIf
    Else
      log_Print{"illegal area for clear bottom:",#log_error}
      log_Print{"displayline: " + Str$(ped\ptrCurrentSourceData\DisplayLine+1) + "   visibleLines: " + Str$(sourceWindow\visibleLines-1)}
      log_Print{Str$(rectx) + ", " + Str$(rectw),#log_error}
      log_Print{Str$(recty) + ", " + Str$(recth),#log_error}
    EndIf
  EndIf

  ; -- restore saved values
  ped\ptrCurrentSourceData\CurrentSourceLine = *storeCurrentSourceLine
  ped\ptrCurrentSourceData\BlockEndY = storeBlockEndY
  !PED_RestoreCursorPosition

  draw_block_after_refresh:
  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF                                                                                                                                                                                                     
                                                                                                                                                                                                        
    ;log_Print{"draw block (after refresh.)"}                                                                                                                                                                                                            
    DEFTYPE.bmark bmark                                                                                                                                                                                                                                  
    bmark\xMin = ped\ptrCurrentSourceData\BlockStartX
    bmark\yMin = ped\ptrCurrentSourceData\BlockStartY
    bmark\xMax = ped\ptrCurrentSourceData\BlockEndX
    bmark\yMax = ped\ptrCurrentSourceData\BlockEndY

    If bmark\xMin - ped\ptrCurrentSourceData\ColumnsOffset < 0
      bmark\xMin = 0
    End If

    If bmark\yMax >= ped\ptrCurrentSourceData\DisplayLineOffset
      bmark\yMin - ped\ptrCurrentSourceData\DisplayLineOffset
      If bmark\yMin < 0
        bmark\xMin = 0
        bmark\yMin = 0
      EndIf

      bmark\xMax - ped\ptrCurrentSourceData\ColumnsOffset
      If bmark\xMax < 0 Then bmark\xMax = 0

      bmark\yMax - ped\ptrCurrentSourceData\DisplayLineOffset
      If bmark\yMax < 0 Then bmark\yMax = 0

      If bmark\yMin < sourceWindow\visibleLines
        If bmark\yMax > sourceWindow\visibleLines
          bmark\yMax = sourceWindow\visibleLines - 1
        EndIf

        If bmark\xMax > sourceWindow\visibleColumns
          bmark\xMax = sourceWindow\visibleColumns - 1
        EndIf

        bmark\xMin + ped\ptrCurrentSourceData\ColumnsOffset
        bmark\xMax + ped\ptrCurrentSourceData\ColumnsOffset

        ;msg$ = Str$(bmark\xMin) + ", "
        ;msg$ + Str$(bmark\yMin) + " - "
        ;msg$ + Str$(bmark\xMax) + ", "
        ;msg$ + Str$(bmark\yMax)
        ;log_Print{msg$}

        PED_DrawBlock{bmark}
      EndIf
    EndIf
  EndIf
  !PED_CursorOn
End Statement


Statement PED_SetBlockStart{}
SHARED ped
USEPATH ped\ptrCurrentSourceData
  storeBlockStartX      = \ColumnsOffset + \Column
  \BlockStartDisplayLine = \DisplayLineOffset + \DisplayLine
  log_Print{"set blockstart to: " + Str$(storeBlockStartX)}
End Statement

Statement PED_SetBlockEnd{}
SHARED ped
USEPATH ped\ptrCurrentSourceData
  If storeBlockStartX < 0
    log_Print{"setblockend: no blockstart set!"}
  Else
    log_Print{"setblockend"}
    newX.l = \ColumnsOffset + \Column
    \BlockStartX = newX
    tmpDL.l = \DisplayLineOffset + \DisplayLine
    If \BlockStartX = storeBlockStartX
      If \BlockStartDisplayLine = tmpDL
        !PED_ResetBlockflag
        PED_RedrawSource{}
        Statement Return
      EndIf
    EndIf

    If newX = 0
      If tmpDL
        If \BlockStartDisplayLine >= tmpDL
          \BlockStartDisplayLine - 1
          ;newX = #MAX_Columns
        Else
          tmpDL - 1
          ;newX = #MAX_Columns
        EndIf
      EndIf
    EndIf
    \BlockEndX = newX
    \BlockEndY = tmpDL
    \BlockStartX = storeBlockStartX
    \BlockStartY = \BlockStartDisplayLine
    PED_AbsBlockDimensions{}
    PED_RedrawSource{}  
  EndIf
End Statement



Function.w getLineLength{lineaddr.l}
  _length.w = #MAX_Columns - 1
  exit_loop.b = False

  Repeat
    char.b = Peek.b(lineaddr + _length)
    If char <> $20
      exit_loop = True
    Else
      _length - 1
    EndIf
  Until exit_loop OR _length < 1
  _length + 1
  Function Return _length
End Function

Statement PED_GotoLine{lineNum.l, @columnMode.b}                                                                                                                                                                                                         
SHARED ped, sourceWindow                                                                                                                                                                                                                                 
  ;log_Print{"Gotoline: " + Str$(lineNum)}
  If lineNum.l < 0 Then lineNum = 0
  If lineNum > ped\ptrCurrentSourceData\TotalLines Then lineNum = ped\ptrCurrentSourceData\TotalLines - 1

  ; same code as in routine mouseclick_in_source
  *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  tempY.l = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset

  While lineNum <> tempY
    If lineNum > tempY
      If *tempLine\nextLine
        *tempLine = *tempLine\nextLine
        tempY + 1
      Else
        log_Print{"GotoLine: no next line!",#log_error}
        lineNum = ped\ptrCurrentSourceData\TotalLines - 1
        tempY = lineNum
      EndIf 
    Else
      *tempLine = *tempLine\previousLine
      tempY - 1
    EndIf
  Wend
  ped\ptrCurrentSourceData\CurrentSourceLine = *tempLine
  ;strline$ = PED_Detoke{*tempLine}
  
  ;-- adjust the display and offset to match the new current line
  tmpDisplayLineOffset.l = ped\ptrCurrentSourceData\DisplayLineOffset

  tempY - sourceWindow\boundLinesY
  If tempY > 0
    If ped\ptrCurrentSourceData\TotalLines > sourceWindow\visibleLines
      temp.l = ped\ptrCurrentSourceData\TotalLines - sourceWindow\visibleLines + sourceWindow\boundLinesY
      If lineNum > temp
        temp - sourceWindow\boundLinesY
        newDLO.l = temp
        newDL.l = tempY - temp
      Else
        newDLO.l = tempY
        newDL.l = sourceWindow\boundLinesY
      EndIf
    Else
      newDLO.l = 0
      newDL.l = lineNum
    EndIf
  Else
    newDLO.l = 0
    newDL.l = lineNum
  EndIf
  ped\ptrCurrentSourceData\DisplayLineOffset = newDLO
  ped\ptrCurrentSourceData\DisplayLine = newDL
  !PED_UpdateTextBufferOffset
  
  If tmpDisplayLineOffset <> ped\ptrCurrentSourceData\DisplayLineOffset
    PED_RedrawSource{}
  EndIf

  !PED_CursorOff
  Select columnMode
  Case #LINE_START
    ped\ptrCurrentSourceData\ColumnsOffset = 0
    ped\ptrCurrentSourceData\Column = 0
    PED_UpdateStatusArea{#STATUS_SCROLLERS}                                                                                                                                                                                                              
  Case #LINE_END
    lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset                                                                                                                                                                     
    ped\ptrCurrentSourceData\Column = getLineLength{lineaddr}
  End Select 
  !PED_CursorOn

End Statement

Function.b PED_GotoLineAddress{ptrSourceLine.l}                                                                                                                                                                                                          
SHARED ped, sourceWindow                                                                                                                                                                                                                                 
  found.b = False
  If ped\ptrCurrentSourceData\TotalLines > 1
    *nextline.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
    lineNum.l = 0
    While *nextline AND (found = False)
      If ptrSourceLine = *nextline Then found = True                                                                                                                                                                                                     
      If found = False 
        *nextline = *nextline\nextLine
        lineNum + 1
      EndIf
    Wend
    If found 
      PED_GotoLine{lineNum, #LINE_START}
      PED_UpdateStatusArea{#STATUS_SCROLLERS}
    EndIf                                                                                                                                                                                                                                                
  EndIf
  Function Return found
End Function


Statement PED_ScrollDelay{}
SHARED ped
  CNIF #slowdown <> 0
    If ped\no_scrollrate
      Delay_ 1
    Else
      vvblank_Wait{}
      vvblank_WaitSync{1}
      vvblank_ResetSync{}
    EndIf
  CEND
End Statement

Statement PED_ScrollHorizontal{direction.b, @scrollMode.b}
  SHARED sourceWindow, ped
  USEPATH sourceWindow

  If scrollMode = #SCROLL_CURRENT_LINE
    dx.w = direction * \font\tf_XSize
    dy.w = 0
    xMin.w = \BoxLeft + \font\tf_XSize * ped\ptrCurrentSourceData\Column
    yMin.w = \BoxTop  + \font\tf_YSize * ped\ptrCurrentSourceData\DisplayLine
    xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
    yMax.w = yMin + \font\tf_YSize - 1
  Else
    ; WIP: shall replace gosub scroll_left/right for whole screen
    dx.w = direction * (\font\tf_XSize * \scrollSize)
    dy.w = 0
    xMin.w = \BoxLeft
    yMin.w = \BoxTop
    xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
    yMax.w = \BoxTop  + sourceWindow\visibleLines * \font\tf_YSize - 1
  EndIf
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax
End Statement

Statement PED_ScrollVertical{direction.b, @yStart.w}
SHARED sourceWindow,ped
USEPATH sourceWindow

  If yStart = -1 Then yStart = 0

  dx.w = 0
  dy.w = direction * \font\tf_YSize
  xMin.w = 0
  yMin.w = \BoxTop + yStart * \font\tf_YSize
  xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
  yMax.w = \BoxTop + sourceWindow\visibleLines * \font\tf_YSize - 1
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax
  PED_ScrollDelay{}

  ; "scroll" the textbuffer one line
  If direction = #SCROLL_DOWN
    temp.l = sourceWindow\visibleLines - yStart - 1
    If temp <> 0
      bytes.l = #MAX_Columns * sourceWindow\visibleLines
      textAddr.l = Peek.l(?textbufferaddr) + bytes - 2
      textAddr2.l = textAddr - #MAX_Columns
      count.l = temp * #MAX_Columns
      For i.l = 2 To count Step 2
        Poke.w textAddr - i, Peek.w(textAddr2 - i)
      Next i
    EndIf
    textAddr.l = Peek.l(?textbufferaddr) + (yStart * #MAX_Columns)
  Else
    temp.l = sourceWindow\visibleLines - yStart - 1
    If temp <> 0
      bytes.l = #MAX_Columns * yStart
      textAddr.l = Peek.l(?textbufferaddr) + bytes
      textAddr2.l = textAddr + #MAX_Columns
      count.l = temp * #MAX_Columns
      For i.l = 0 To count Step 2
        Poke.w textAddr + i, Peek.w(textAddr2 + i)
      Next i
    EndIf
    textAddr.l = Peek.l(?textbufferaddr) + (sourceWindow\visibleLines-1)*#MAX_Columns
  EndIf

  ; fill the last line with spaces
  For i.l = 0 To #MAX_Columns Step 2
    Poke.w textAddr + i,$2020
  Next i

End Statement






Statement PED_GetMousePos{*mp.mousePos}
  SHARED sourceWindow
  USEPATH sourceWindow

  *mp\X = \win\MouseX - \win\BorderLeft + 1
  *mp\Y = \win\MouseY - \win\BorderTop + 1
  If *mp\X < 0 Then *mp\X = 0
  If *mp\Y < 0 Then *mp\Y = 0

  If (*mp\X > \BoxLeft)
    *mp\textX = *mp\X - \BoxLeft
    If *mp\textX < 0 Then *mp\textX = 0
    *mp\textX = *mp\textX / \font\tf_XSize
  Else
    *mp\textX = 0
  EndIf

  If (*mp\Y > \BoxTop) AND (*mp\Y < \statusAreaY)
    *mp\textY = *mp\Y - \BoxTop
    If *mp\textY < 0 Then *mp\textY = 0
    *mp\textY = *mp\textY / \font\tf_YSize
  Else
    *mp\textY = -1
  EndIf

  ;msg$ = Str$(*mp\X) +  ", " + Str$(*mp\Y) + " - "
  ;msg$ + Str$(*mp\textX) + ", " + Str$(*mp\textY)
  ;msg$ + " / storeXY: " + Str$(storeX.w) + ", " + Str$(storeY.l)
  ;PED_ShowMessage{msg$}
End Statement


Statement AbsDimensions{*bm.bmark}

  If *bm\yMin < *bm\yMax Then Statement Return

  If (*bm\yMin = *bm\yMax) OR (*bm\xMin > *bm\xMax)
    Exchange *bm\xMin,*bm\xMax
    Exchange *bm\yMin,*bm\yMax
  EndIf
End Statement


 

Statement PED_HistoryAddEntry{}
SHARED ped
  ped\historyTable[ped\historyPointer] = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
  ped\historyPointer + 1
  If ped\historyPointer >= #maxhistory Then ped\historyPointer = 0                                                                                                                                                                                       
  log_Print{"adding historypointer " + Str$(ped\historyPointer) + ", line " + Str$(ped\historyTable[ped\historyPointer])}
End Statement

Statement HistoryUp{}
End Statement



Statement window_welcome{txt0.s,@txt1.s,@txt2.s,@txt3.s,@txt4.s,@txt5.s,@txt6.s}
 SHARED pedconfig
  pngimage.l = -1
  ; -- es kommt zu einem Enforcerhit beim beenden von Amiblitz3, wenn dieses Fenster geoeffnet wurde !??
  Gosub set_pointer_busy
  WZ_LockAllOpenWindows{}                                                                                                                                                                                                                                

  WZWindow WZID("WIN_WELCOME"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_WELCOME")

  If (txt0 <> "")
    sharp.b = Instr(txt0,"#")
    vlen.b = FLen(txt0)
    pv.s = Left$(txt0,sharp - 1)
    cv.s = Right$(txt0,vlen - sharp)
    WZPrint "PED",&pv
    WZPrint "COMPILER",&cv
  EndIf

  If (txt1 <> "") AND (txt2<>"")
    WZPrint "TEXT1",&txt1
    WZPrint "TEXT2",&txt2
  EndIf

  ltxt1.s = "BaseLibs:" : WZPrint "LACIDLIBS_TEXT",&ltxt1
  WZPrint "ACIDLIBS_TEXT",&txt3
  ltxt2.s = "UtilLibs:" : WZPrint "LDEFLIBS_TEXT",&ltxt2
  WZPrint "DEFLIBS_TEXT",&txt4
  ltxt3.s = "OsLibs:" : WZPrint "LOSLIBS_TEXT",&ltxt3
  WZPrint "OSLIBS_TEXT",&txt5
  ltxt4.s = "CsLibs:" : WZPrint "LCSLIBS_TEXT",&ltxt4
  WZPrint "CSLIBS_TEXT",&txt6


  welcome_Exit.b = False
  Repeat
    welcome_ev.l = WaitEvent

    Select welcome_ev
    Case #IDCMP_VANILLAKEY:
      ;error{"VAN: " + Hexw$(EventCode)}
      If EventCode = #VANILLAKEY_ESC Then welcome_Exit = True

    Case #IDCMP_IDCMPUPDATE
      If WZGadName = "WELCOME_OK" Then welcome_Exit = True

    Case #IDCMP_CLOSEWINDOW
      welcome_Exit = True

    End Select
  Until welcome_Exit

  WZCloseWindow WZID("WIN_WELCOME")
  FlushEvents

  Gosub activatesourcewindow
  WZ_UnlockAllOpenWindows{}
  Gosub set_pointer_normal
End Statement

Function.b cutLine{*sl.sourceLine}                              ; remove the current line out of linked list
SHARED ped
    *prevLine.sourceLine = *sl\previousLine
    *nextLine.sourceLine = *sl\nextLine
    If (*prevLine = 0) AND (*nextLine = 0)
      Function Return False
    End If

    ; clear old references to other lines
    *sl\previousLine = 0
    *sl\nextLine = 0

    ; connect previous and next line to cut current line off and update firstline if the firstline has been cut
    If *prevLine <> 0
      *prevLine\nextLine = *nextLine
    Else
      ped\ptrCurrentSourceData\FirstSourceLine = *nextLine
    EndIf
    If *nextLine <> 0 Then *nextLine\previousLine = *prevLine

    Function Return True
End Function

Statement appendLine{*afterLine.sourceLine, *newLine.sourceLine}
SHARED ped
  ; insert a new line into the linked list, previous/nextLine of *newLine is null

  ; afterLine:  the line to append the newLine to
  ; newLine  :  the line to append after the afterLine

  If *afterLine = 0                           ; previous line has no previous line
    log_Print{"line to append to has no previousline, setting appendline as first sourceline"}

    *exfirstLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
    *exfirstLine\previousLine = *newLine
    *newLine\nextLine = *exfirstLine

    ped\ptrCurrentSourceData\FirstSourceLine = *newLine

  Else
    *nextLine.sourceLine = *afterLine\nextLine        ; get the old nextline
    If *nextLine
      *nextLine\previousLine = *newLine
      *newLine\nextLine = *nextLine
    Else
      ped\ptrCurrentSourceData\LastSourceLine = *newLine
    EndIf
    *newLine\previousLine = *afterLine
    *afterLine\nextLine = *newLine
  EndIf
End Statement

Function.w PED_SearchString{searchStr.s, casesensitive.b, startpos.w, *currentLine.sourceLine}
SHARED ped,*PreProcessor

  strline$ = Peek.s(*currentLine+9)
  If FLen(strline$) = 0 Then Function Return 0

  If ped\DoTokenize
    MaxLen linebuff$ = 256
    preproc_Detokenize{*PreProcessor,&strline$,&linebuff$,FLen(strline$)}
    strline$ = Peek.s(&linebuff$)
  EndIf

  ;log_Print{"detokenized: " + strline$}
  ;log_Print{"length: " + Str$(FLen(strline$))}
  ;log_Print{"search for [" + searchStr + "] in line [" + strline$ + "]"}
  If casesensitive Then CaseSense True Else CaseSense False

  Function Return Instr(strline$, searchStr, startpos)
End Function

Function.b PED_ReplaceString{search.s, replacement.s, *currentLine.sourceLine}
SHARED ped,*PreProcessor,sourceWindow

  success.b = False

  tmpX.w = PED_SearchString{search, 0, 1, *currentLine}
  ;log_Print{"search for line complete."}
  If tmpX > 0
    strline.s = Peek.s(*currentLine+9)

    If ped\DoTokenize
      MaxLen linebuff$ = 256
      preproc_Detokenize{*PreProcessor,&strline.s,&linebuff$,FLen(strline)}
      strline.s = StripTrail$(Peek.s(&linebuff$),$20)
    EndIf

    replacedline.s = Replace$(strline,search,replacement)
    ;log_Print{"length after replace: " + Str$(FLen(replacedline))}
    If ped\DoTokenize
      MaxLen linebuff$ = 256
      ; process the ascii data in sourcebuff length and write the tokenized source into destbuffer
      ; the return value is the length of the tokenized text
      ; sourcebuff and destbuff might be the same pointer
      ; preproc_Tokenize{*tn.preprocessor,sourcebuff.l,destbuff.l,bytelength.l}
      preproc_Tokenize{*PreProcessor,&replacedline.s,&linebuff$,FLen(replacedline)}
      replacedline.s = Peek.s(&linebuff$)
    EndIf

    If FLen(replacedline) < #MAX_Columns Then replacedline + SPACE$(#MAX_Columns - FLen(replacedline))
    If FLen(replacedline) > #MAX_Columns Then replacedline = Left$(replacedline,#MAX_Columns)

    *previousLine.sourceLine = *currentLine\previousLine
    If cutLine{*currentLine}
      *newLine.sourceLine = PED_CreateNewSourceLine{replacedline}
      appendLine{*previousLine,*newLine}
      PED_FreeMem{*currentLine}
      ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
      success = True
    Else
      error{"Could not replace the current source line"}
    EndIf
  EndIf
  Function Return success
End Function




Function.s check_constructs{*currentline.sourceLine}    ; fixed this function  tomsmart1

  If *currentline = 0 Then Function Return ""

  construct.s = ""

  *prevLine.sourceLine = *currentline\previousLine

  If *prevLine >< Null
    *textline.l = *prevLine + 9     ; get pointer of previus sourceline text
    If *textline >< Null
      textaddr.l = Peek.l(*textline)           ; get address of the text
      bytecount.w = 0

      While (textaddr LSR 16) <> $0000
        textaddr = Peek.l(*textline + bytecount)

        actword.w = textaddr LSR 16

        ; check the token too select the end token(s)
        Select actword
          Case #TOKEN_Then      : construct = ""
          Case #TOKEN_Statement : construct = "End Statement"
          Case #TOKEN_Function  : construct = "End Function"
          Case #TOKEN_If        : construct = "EndIf"
          Case #TOKEN_While     : construct = "Wend"
          Case #TOKEN_Macro     : construct = "End Macro"
          Case #TOKEN_Select    : construct = "End Select"
          Case #TOKEN_Repeat    : construct = "Until"
          Case #TOKEN_For       : construct = "Next"
        End Select
        bytecount + 1
      Wend
    EndIf
  EndIf

  Function Return construct
End Function

Function.w PED_PreparseTextLine{lineaddr.l}
  SHARED ped, pedconfig, operators$(),num_operators

  columnpos.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset

  ;--  clear highlight info but dont trash strings
  If (lineaddr & $1) <> 0 Then error{"alert: odd address " + Hex$(lineaddr)}
  nostring.b = 0
  For i.l = lineaddr To lineaddr + #MAX_Columns
    If nostring = 0
      Poke.b i,Peek.b(i) AND $7f
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
    If Peek.b(i) = $22 Then nostring = 1
    ; workaround:
    ; sometimes there is a 0 in a linestring perhaps due
    ; to a wrong lineaddr
    ; the 0 is been replaced by a space
    If Peek.b(i) = 0 Then Poke.b i,32
  Next

  strg$ = Peeks$(lineaddr,#MAX_Columns)

  ; --
  ; -- checking if editing a comment
  test_semi$ = StripLead$(strg$,@" ")
  kommata.w  = Instr(test_semi$,";")
  If kommata AND (kommata < columnpos) 
    ped\ptrCurrentSourceData\Column = columnpos - ped\ptrCurrentSourceData\ColumnsOffset
    Function Return columnpos
  EndIf 

  len_strg.w = Len(StripTrail$(strg$,@" "))

  line_changed.b = False

  ; --
  ; -- replace lower written functionames with correct cases
  If pedconfig\correct_functions
    startAt.w = 0                                               ; added to make a test of the complete line and begin at position 0  tomsmart1
    Repeat                                                         ; added loop to test the complete line  tomsmart1
      bracketPos.w = Instr(strg$,"{",startAt) - 1

      If bracketPos > 0
        startOfName.l = bracketPos

        again:
        ;log_Print{"searching begin of function name:"}
        Repeat
          startOfName - 1
        Until !IsIllegalChar{Peek.b(&strg$ + startOfName)} OR startOfName = 0
        If Peek.b(&strg$ + startOfName) = @" " AND startOfName = bracketPos Then Goto again
        startOfName + 1
        funcname$ = Mid$(strg$,startOfName, bracketPos + 1 - startOfName)
        funcname$ = Trim$(funcname$)
        ;log_Print{"found function name to correct [" + funcname$ + "]"}
        newfuncname$ = PED_GetIncludeFunction{funcname$}
        If newfuncname$ <> "" 
          If newfuncname$ <> funcname$ 
            ;log_Print{"correct function name: " + newfuncname$}
            strg$ = Left$(strg$,startOfName)  + newfuncname$ + UnRight$(strg$,bracketPos)
            line_changed = True 
          EndIf
        Else
          ;log_Print{"no better name found for function name ..."}
        EndIf
        startAt = bracketPos + 2
        If startAt >= FLen(strg$) Then bracketPos = -1
      EndIf
    Until bracketPos = -1
    ;log_Print{"replacing function names finished"}
  EndIf 

  ; -- structurization of source
  If pedconfig\auto_format
    neustrg$ = ""
    make_struct.b = On
    For j.w = 1 To len_strg
      double_operator.b = False
      temp_disabled.b = Off
      no_pre_pad.b = Off
      no_post_pad.b = Off
      comment_mode.b = Off

      char$ = Mid$(strg$,j,1)
      If char$<>" "
        For k.w = 0 To num_operators-1
          If char$ = operators$(k)
            For l.w = 0 To num_operators - 1
              If last_op$ = operators$(l) Then double_operator = True
            Next
            If NOT double_operator
              op_found.b = True
              Pop For
              Goto exit_for
            EndIf
          Else
            op_found = False
          EndIf
        Next k
        exit_for:
        If char$ = Chr$(34) Then make_struct = -1 + Abs(make_struct)

        If (op_found = True) AND (last_op$ <> "=")
          last_op$ = char$

          Select char$
            Case ";"      ; innerhalb von Kommentaren nicht strukturieren
              comment_mode = On

            Case "-"      ; eine Zuweisung mit neg. Wert nicht formatieren
              If Mid$(strg$,j - 2,2) = "= " OR Mid$(strg$,j - 1,1) = "="
                temp_disabled = On
              EndIf

            Case "<"
              If Mid$(strg$,j-2,2) = "> " OR Mid$(strg$,j-1,1)=">"
                no_pre_pad = On
              EndIf
              If Mid$(strg$,j+2,2) = "> " OR Mid$(strg$,j+1,1)=">"
                no_post_pad = On
              EndIf

            Case ">"
              If Mid$(strg$,j-2,2) = "< " OR Mid$(strg$,j-1,1)="<"
                no_pre_pad = On
              EndIf
              If Mid$(strg$,j+2,2) = "< " OR Mid$(strg$,j+1,1)="<"
                no_post_pad = On
              EndIf

          End Select

          If make_struct AND (j > 1) AND (NOT temp_disabled) AND (NOT comment_mode = On)
            pad_pre$ = "" : pad_post$ =""
            If Mid$(strg$,j - 1,1) <>" " Then pad_pre$  = " " : columnpos + 1
            If Mid$(strg$,j + 1,1) <>" " Then pad_post$ = " " : columnpos + 1
            If no_pre_pad                Then pad_pre$  = ""  : columnpos - 1
            If no_post_pad               Then pad_post$ = ""  : columnpos - 1
            char$ = pad_pre$ + char$ + pad_post$
            line_changed = True
          EndIf
        Else
          last_op$ = ""
        EndIf
      EndIf
      neustrg$ + char$
    Next j
    strg$ = neustrg$
  EndIf
 
  ; --- write formated textline into textbuffer
  If line_changed
    strg$ = Left$(strg$,#MAX_Columns)
    strg$ + SPACE$(#MAX_Columns - FLen(strg$))
    ;log_Print{"pushing to textbuffer: [" + strg$ + "]"}
    For i.l = 0 To #MAX_Columns-1
      Poke.b lineaddr + i, Peek.b(&strg$ + i)
    Next
  EndIf

  ; --- return new cursorposition if something as changed
  ped\ptrCurrentSourceData\Column = columnpos - ped\ptrCurrentSourceData\ColumnsOffset
  Function Return columnpos
End Function


Statement savewinpref{layoutNum.l}
  SHARED wpref(),wtemp,pedconfig,sourceWindow

  used_win.l = Used Window
  ret.l = ask{!TRANS{"The window settings have been saved.\\nPress appropriate FN-Key (F4-F6) to set window configuration."},!TRANS{"Ok"},!TRANS{"Info"}}
  USEPATH wtemp

  \lbrowser_on = 0
  \ibrowser_on = 0
  \type_on = 0
  \diag_on = 0
  \click_on = 0
  \short_on = 0
  \activewin = 0

  If WZ_IsOpen{"WIN_LIBRARYBROWSER"}
     Use Window WZID("WIN_LIBRARYBROWSER")
     \lbrowser_x  = WindowX
     \lbrowser_y  = WindowY
     \lbrowser_w  = WindowWidth
     \lbrowser_h  = WindowHeight
     \lbrowser_on = 1
  End If
  If WZ_IsOpen{"WIN_INSTRUCTIONBROWSER"}
     Use Window WZID("WIN_INSTRUCTIONBROWSER")
     \ibrowser_x  = WindowX
     \ibrowser_y  = WindowY
     \ibrowser_w  = WindowWidth
     \ibrowser_h  = WindowHeight
     \ibrowser_on = 1
  End If
  If WZ_IsOpen{"WIN_NEWTYPE"}
     Use Window WZID("WIN_NEWTYPE")
     \type_x  = WindowX
     \type_y  = WindowY
     \type_w  = WindowWidth
     \type_h  = WindowHeight
     \type_on = 1
  End If
  If WZ_IsOpen{"WIN_HELPDIAG"}
     Use Window WZID("WIN_HELPDIAG")
     \diag_x  = WindowX
     \diag_y  = WindowY
     \diag_w  = WindowWidth
     \diag_h  = WindowHeight
     \diag_on = 1
  End If
  If WZ_IsOpen{"WIN_LABELS"}
     Use Window WZID("WIN_LABELS")
     \click_x  = WindowX
     \click_y  = WindowY
     \click_w  = WindowWidth
     \click_h  = WindowHeight
     \click_on = 1
  End If
  If WZ_IsOpen{"WIN_SHORTCUTS"}
     Use Window WZID("WIN_SHORTCUTS")
     \short_x  = WindowX
     \short_y  = WindowY
     \short_w  = WindowWidth
     \short_h  = WindowHeight
     \short_on = 1
  EndIf

  If sourceWindow\win
    \source_x = sourceWindow\win\LeftEdge
    \source_y = sourceWindow\win\TopEdge
    \source_w = sourceWindow\win\Width
    \source_h = sourceWindow\win\Height
  EndIf

  ; -- check if console is open and store its position
  *thisscreen.Screen = Peek.l(Addr Screen(0))
  *conwin.Window = *thisscreen\FirstWindow
;  message{"error"}
  security.l = 0
  If *conwin
    While *conwin <> 0
      If Peek$(*conwin\Title) <> pedconfig\console_title
        If Peek.l(*conwin) Then *conwin = Peek.l(*conwin) Else *conwin = 0
      Else
        Pop While
        Goto exit_consearch
      EndIf
      ; notbremse fuer while-loop
      security + 1
      If security > 30 Then *conwin = 0
    Wend
  EndIf
  exit_consearch:
  If *conwin
    \console_x = *conwin\LeftEdge
    \console_y = *conwin\TopEdge
    \console_w = *conwin\Width
    \console_h = *conwin\Height
  EndIf
  Use Window used_win
  CopyMem_ &wtemp,&wpref(layoutNum),SizeOf .winprefs
End Statement


Statement write_libmapping{_file.s}
  SHARED lib_mapping$()

  If dos_Exist{_file} Then dos_Delete{_file}

  fid.l = file_Open{_file,#file_write}
  If fid<>-1
    log_Print{"writing libslist..."}
    For i.w = 0 To #Max_BlitzLibs-1
      textline.s = Left$(lib_mapping$(i,0),31)
      textline + LSet$(textline,31)
      textline + ";" + lib_mapping$(i,1)
      file_WriteLine{fid,textline}
    Next i
    file_Close{fid}
  EndIf

End Statement


Statement read_libmapping{_file.s}
  SHARED *tokenbase
  SHARED lib_mapping$()

  Dim templist$(#Max_BlitzLibs,1)
  DEFTYPE.w libcounter,i

  fid.l = file_Open{_file,#file_read}
  If fid<>-1
    file_Cache{fid}
    log_Print{"loading libslist..."}
    Repeat
      zeile$ = file_ReadLine{fid}
      qpos.w = Instr(zeile$,";")
      If qpos
        lstring$ = Left$(zeile$,qpos-1)
        rstring$ = Right$(zeile$,FLen(zeile$)-qpos)

        ; get libnumber from internal structure
        templist$(libcounter,0) = Replace$(lstring$," ","")
        templist$(libcounter,1) = Replace$(rstring$," ","")
        libcounter + 1
      EndIf
    Until file_EOF{fid}
    file_Close{fid}
    If libcounter = 0 Then Statement Return

    log_Print{"scanning tokenlist..."}
    *token.tokendata = *tokenbase
    If *token
      Repeat
        libnum.w = *token\number LSR 7

        For i = 0 To libcounter
          If templist$(i,1) = Peek.s(&*token\dat)
            If libnum > 0
              libname$ = templist$(i,0)
              firsttoken$ =  templist$(i,1)
              If (Instr(lib_mapping$(libnum,0),"unused")=0)
                message$= !TRANS{"Library clash!\\n" }
                message$+ !TRANS{"The dynamic added lib"}+" \\22"+libname$+"\\22\\n"
                message$+ !TRANS{"has overwritten"}+" \\22"+lib_mapping$(libnum,0)+"\\22 "+!TRANS{"stored in acidlibs/deflibs"}+".\\n"
                message$+ !TRANS{"Both libs have the same Lib-ID"}+" "+ Str$(libnum)+".\\n\\n"
                message$+ !TRANS{"Sourcecode that uses"}+" "+ lib_mapping$(libnum,0) + " "+!TRANS{"might not work,\\n"}
                message$+ !TRANS{"because these functions are now mapped to"}+" "+libname$+".\\n\\n"
                message$+ !TRANS{"You should remove the appropriate library from userlibs-directory,\\nor change the Lib-ID to a free one."}
                dummy.l = ask{message$,!TRANS{"Ok"},!TRANS{"Error"}}
                lib_mapping$(libnum,0) = libname$ + " ("+!TRANS{ "clashing with"}+" "+lib_mapping$(libnum,0)+")"
              Else
                lib_mapping$(libnum,0) = libname$
              EndIf
              lib_mapping$(libnum,1) = firsttoken$
              Pop If : Pop If : Pop For : Goto exit_this_loop
            EndIf
          EndIf
        Next i
        exit_this_loop:

        *token = *token\next_token
      Until (*token = 0)
      log_Print{"scanning finished."}
    EndIf
  EndIf
End Statement


Statement map_tokens_to_libs{_file.s}
  SHARED *tokenbase
  SHARED lib_mapping$()

  fid.l = file_Open{_file,#file_read}
  If fid<>-1
    ; check content of file, if there is only little garbage, then ignore it
    If file_GetLength{fid} < 5
      file_Close{fid}
      Statement Return
    EndIf

    log_Print{"building hashmap..."}
    *hm.hashmap = hashmap_Create{8}
    file_Cache{fid}
    lineCounter.w = 0
    Repeat
      zeile$ = file_ReadLine{fid}
      qpos.w = Instr(zeile$,";")
      If qpos
        lstring$ = Left$(zeile$,qpos-1)
        rstring$ = Right$(zeile$,FLen(zeile$)-qpos)

        ; get libnumber from internal structure
        libname$ = Trim$(lstring$)
        firsttoken$ = LCase$(Trim$(rstring$))
        If firsttoken$ <> ""
          hashmap_AddItem{*hm, firsttoken$, libname$}
        Else
          ; set the libname directly, as there is no token to map
          lib_mapping$(lineCounter,0) = libname$
        EndIf

        ;If linecounter < 138 AND linecounter >130
        ;log_Print{Str$(linecounter) + ":adding token [" + firsttoken$ + "] with libname [" + libname$ + "]"}
        ;EndIf
      EndIf
      lineCounter + 1
    Until file_EOF{fid}
    file_Close{fid}
    log_Print{"building hashmap done."}
 
    ; running through the tokenindex and map tokens to library names
    log_Print{"scanning tokenlist..."}
    *token.tokendata = *tokenbase
    If *token
      libCounter.w = 0
      oldlibnum.w = -1
      Repeat
        libname$ = ""

        token_name.s    = Peek.s(&*token\dat)
        libnum.w       = *token\number LSR 7

        If token_name = ""
          log_Print{ "#" + Str$(libnum) + ": nulltoken found"}
        EndIf

        If  (libnum <> oldlibnum) AND token_name<>""
          libCounter + 1
          oldlibnum = libnum

          ; check if token is first token of a blitzlib
          libname$ = hashmap_GetItem{*hm, LCase$(token_name)}
          ;log_Print{"#"+Str$(libnum) + " [" + libname$ + "] -  first token [" + token_name + "]"}


          ; check if token is part of library, that is already used
          ; if libnum is unused, map libname to libnum
          ; if a libnum appears, here a libname has been mapped, we have a libclash!
          If libname$ = ""
            log_Print{"could not identify libnum #" + Str$(libnum)+ " with first token [" + token_name + "]"}
          Else
            ;log_Print{"first token of library #" + Str$(libnum) + " [" + libname$ + "]: [" + token_name + "]"}

            If Instr(lib_mapping$(libnum,0),"unused") = 0
              log_Print{"lib has already been mapped!",#log_warning}
              message$ = !TRANS{"Library clash!\\n" }
              message$ + !TRANS{"The dynamic added blitzlib"} + " \\22" + libname$ + "\\22 " + !TRANS{"overwrites the already loaded blitzlib "} + " \\22" + lib_mapping$(libnum,0)+"\\22\\n\\n"

              message$ + !TRANS{"Both libs have the same Lib-ID"} + " #"+ Str$(libnum) + ".\\n\\n"

              message$ + !TRANS{"Sourcecode that uses that blitzlib might not work, because these functions are now mapped to"} + " \\22" + libname$ + "\\22.\\n"

              message$ + !TRANS{"You should remove the appropriate library from userlibs-directory,\\nor change the Lib-ID to a free one."}
              dummy.l = ask{message$,!TRANS{"Ok"},!TRANS{"Error"}}
              lib_mapping$(libnum,0) = libname$ + " ("+!TRANS{ "clashing with"}+" "+lib_mapping$(libnum,0)+")"
            Else
              lib_mapping$(libnum,0) = libname$
            EndIf
            lib_mapping$(libnum,1) = token_name
          End If
        EndIf
        *token = *token\next_token
      Until (*token = 0)
      log_Print{"scanning tokenlist done, processed " + Str$(libCounter) +" libs"}

;      write_libmapping{_file}    ; update the token_mapping file
    EndIf
    hashmap_Free{*hm}
  EndIf
End Statement


Function.l AutoLayout{*wprefs.winprefs,mode.l}
  SHARED sourceWindow, pedconfig
  USEPATH *wprefs
  *scr.Screen = Peek.l(Addr Screen(0))
  If *scr=0 Then Function Return False
;  WZ_KillTable{"INSTRUCTIONBROWSER"}
;  ClearMenuStrip_ Peek.l(Addr Window(WZID("WIN_INSTRUCTIONBROWSER")))
;  WZCloseWindow WZID("WIN_INSTRUCTIONBROWSER")
  top.l    = *scr\BarHeight +1 + pedconfig\al_topspace
  bottom.l = *scr\Height-1     - pedconfig\al_bottomspace
  left.l   = 0                 + pedconfig\al_leftspace
  right.l  = *scr\Width-1      - pedconfig\al_rightspace

  lock.l = LockIBase_ (0)
    *myWindow.Window = *scr\FirstWindow

    While *myWindow
      rx.l = *myWindow\Width/*myWindow\Height
      ry.l = *myWindow\Height/*myWindow\Width
      ;If *myWindow\Title Then rx=1 : ry=1
      If *myWindow\Flags&#WFLG_BORDERLESS = 0 Then rx=1 : ry=1
      If rx>2
        If *myWindow\TopEdge+*myWindow\Height-1 >= bottom
          bottom = Min(bottom,*myWindow\TopEdge-1)
        End If
        If *myWindow\TopEdge<*scr\BarHeight
          top    = Max(top,*myWindow\TopEdge+*myWindow\Height)
        End If
      End If

      If ry>2
        If *myWindow\LeftEdge+*myWindow\Width-1 >= right
          right = Min(right,*myWindow\LeftEdge-1)
        End If
        If *myWindow\LeftEdge<=0
          left  = Max(left,*myWindow\LeftEdge+*myWindow\Width)
        End If
      End If
      *myWindow = *myWindow\NextWindow
    Wend

  UnlockIBase_ lock

  width.l  = right-left+1
  height.l = bottom-top+1


  Select mode
    Case 0    ; Layout A
      splitpointY.l  = (bottom-top) * 3/4
      splitpointX.l  = (right-left) * 3/4

      If splitpointY<700              Then splitpointY=height
      If (right-left)-splitpointX<250 Then splitpointX=right-left-250

      ;\source_on   = True            ; source code window
      \source_x    = left,top,splitpointX,splitpointY
      sourceWindow\WinLeft  = left,top,splitpointX,splitpointY
      ;Poke.w ?win_TopLeft,\source_x
      ;Poke.w ?win_TopEdge,\source_y
      ;Poke.w ?win_Width  ,\source_w
      ;Poke.w ?win_Height ,\source_h
      If (splitpointY<bottom-top+1)
        If (splitpointX>1024)
          \ibrowser_on = True        ; Instruction Browser
          \ibrowser_x  = left,(top+splitpointY),(splitpointX/2),bottom-(top+splitpointY)+1
          \lbrowser_on = True
          \lbrowser_x  = left+splitpointX/2,(top+splitpointY),splitpointX-(splitpointX/2),bottom-(top+splitpointY)+1
        Else
          \ibrowser_on = True        ; Instruction Browser
          \ibrowser_x  = left,(top+splitpointY),(splitpointX),bottom-(top+splitpointY)+1
          \lbrowser_on = False
        End If
      Else
        \lbrowser_on = False
        \ibrowser_on = False
      End If
      \click_on    = True            ; Source Browser
      \click_x     = (left+splitpointX),top,width-splitpointX,height*3/5
      \type_on     = True            ; Definition Browser
      \type_x      = (left+splitpointX),(top+height*3/5),width-splitpointX,bottom-((height)*3/5)+1-top

      If splitpointY<height
        \console_x   = left,(top+splitpointY),splitpointX,height-splitpointY
      Else
        \console_x   = left,(top),splitpointX,height
      End If

    Case 1    ; Layout B
      splitpointX1.l  = (width)  * 1/4 : If splitpointX1<400       Then splitpointX1=400
      splitpointX2.l  = (width)  * 3/4 : If width-splitpointX2<250 Then splitpointX2=width-250
      splitpointY.l   = (height) * 3/5

      If splitpointX2-splitpointX1<320 Then splitpointX1=0 ;: splitpointX2.l  = (right-left) * 1/3
      If splitpointY <400              Then splitpointY=0

      ;\source_on   = True ; source code window
      \source_x    = left+splitpointX1,top,splitpointX2-splitpointX1,height
      sourceWindow\WinLeft = left+splitpointX1,top,splitpointX2-splitpointX1,height
      ;Poke.w ?win_TopLeft,\source_x
      ;Poke.w ?win_TopEdge,\source_y
      ;Poke.w ?win_Width  ,\source_w
      ;Poke.w ?win_Height ,\source_h

      If (splitpointX1>0)
        If (splitpointY>0)
          \ibrowser_on = True ; Instruction Browser
          \ibrowser_x  = left,top,splitpointX1,splitpointY
          \lbrowser_on = True
          \lbrowser_x  = left,top+splitpointY,splitpointX1,height-splitpointY
        Else
          \ibrowser_on = True ; Instruction Browser
          \ibrowser_x  = left,top,splitpointX1,height
          \lbrowser_on = False
        End If
      Else
        \lbrowser_on = False
        \ibrowser_on = False
      End If
      If (splitpointY>0)
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX2 ,top,width-splitpointX2,splitpointY
        \type_on     = True ; Definition Browser
        \type_x      = left+splitpointX2 ,top+splitpointY,width-splitpointX2,height-splitpointY
      Else
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX2,top,width-splitpointX2,height
        \type_on     = False ; Definition Browser
      End If
      \console_x    = left,(top+splitpointY),width,height-splitpointY

    Case 2    ; Layout C
      splitpointX.l  = (width) * 3/4 : If width-splitpointX<250 Then splitpointX=width-250
      splitpointY.l  = (height) * 3/5
      If splitpointY <400 Then splitpointY=0

      ;\source_on   = True ; source code window
      \source_x    = left,top,splitpointX,height
      sourceWindow\WinLeft  = left,top,splitpointX,height
      ;Poke.w ?win_TopLeft,\source_x
      ;Poke.w ?win_TopEdge,\source_y
      ;Poke.w ?win_Width  ,\source_w
      ;Poke.w ?win_Height ,\source_h

      \lbrowser_on = False
      \ibrowser_on = False

      If (splitpointY>0)
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX ,top,width-splitpointX,splitpointY
        \type_on     = True ; Definition Browser
        \type_x      = left+splitpointX ,top+splitpointY,width-splitpointX,height-splitpointY
      Else
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX,top,width-splitpointX,height
        \type_on     = False ; Definition Browser
      End If
      \console_x   = left,(top+splitpointY),width,height-splitpointY


  End Select
  USELASTPATH
  Function Return True
End Function

Function.l PED_CheckSourceAlreadyOpen{fname.s}
SHARED ped

  log_Print{"check if file [" + fname + "] is already opened."}
 
  found.b = False
  *fileEntry.sourceEntry = ped\firstSourceEntry
  While *fileEntry AND (found = False)
    log_Print{"... checking [" + Peek.s(&*fileEntry\SourceName)+ "]"}
    If Peek.s(&*fileEntry\SourceName) = fname
      found = True
    Else
      *fileEntry = *fileEntry\nextEntry
    EndIf
  Wend
  Function Return *fileEntry
End Function

Statement PED_CloseFile{fh.l}
  SHARED ped,readcache
  If fh <> 0
    log_Print{"closing file handle: " + Hex$(fh)}
    Close_ fh : ped\sourceFileHandle = 0
    If readcache\cacheptr
      FreeVec_ readcache\cacheptr
      readcache\cacheptr = Null
      readcache\cachelen = 0
      readcache\readlen = 0
      readcache\chunklen = 0
      readcache\filelen = 0
      ;ClearType readcache
    EndIf
  Else
    log_Print{"file already closed at " + Hex$(fh)}
  EndIf
End Statement

Function.l PED_OpenFile{ofname.s, accessmode.l, menuload.b}
SHARED ped, pedconfig

  ped\convert = False

  ;If fname$="" Then fname$ = ped\sourceFileComplete
  log_Print{"open_file <" + ofname + ">"}

  ; -- check extension
  fext.s = LCase$(dos_GetExt{ofname})
  log_Print{"checking file extention of file: " + ofname + " [" + fext + "]"}
  log_Print{"smart tok: " +Str$(pedconfig\smart_tokenization)}
  log_Print{"do tok: " + Str$(ped\DoTokenize)}
  If pedconfig\smart_tokenization <> 0
    If fext = "bb2" OR fext = "ab2" OR fext = "ab3" OR fext = "bb"
      log_Print{"activating tokenization"}
      ped\DoTokenize = $FFFF
    Else
;      If fext = "txt" OR fext = "guide"
        log_Print{"deactivating tokenization"}
        ped\DoTokenize = False
        If fext = "guide" Then ped\amigaguide = True
;      EndIf
    EndIf
  EndIf

  If fext = "asm"
    log_Print{"it seems to be an asm file, tokenization and conversion mode is active."}
    If pedconfig\smart_tokenization Then ped\DoTokenize = $FFFF
    ped\convert = True
  EndIf

  fh.l = Open_(&ofname, accessmode)
  If fh
;    log_Print{"file opened successfully, handle: " + Hex$(fh)}
    Function Return fh
  Else
    fileerror.l = IoErr_
    log_Print{"could not open file <" + ofname + "> for reason: " + Str$(fileerror)}
    log_Print{"menuload: " + Str$(menuload)}

    If menuload = False
      error{"Couldn't open file, DOS-Error: " + Str$(fileerror)}
    Else
      error{"Couldn't open file, DOS-Error: " + Str$(fileerror)}
    EndIf
  EndIf

End Function



Function.s PED_RequestFile{tmpdir$, tmpfile$, tmptitle$, tmppattern$}
SHARED ped, pedconfig, sourceWindow

 ;If _a0<>0 Then tmpdir$   = Peek$(_a0)
 ;If _a1<>0 Then tmpfile$  = Peek$(_a1)
 ;If _a2<>0 Then tmptitle$ = Peek$(_a2)
 If pedconfig\use_filepattern <> 0
   If tmppattern$ = "" Then tmppattern$ = "(#?.info)"
 Else
   tmppattern$ = ""
 EndIf

 asl_SetRequesterDims{pedconfig\asl_x,pedconfig\asl_y,pedconfig\asl_w,pedconfig\asl_h}
 aslfr_SetRequesterTitle{1,!TRANS{tmptitle$},"",""}
 aslfr_SetPattern{1,tmppattern$}
 aslfr_SetPath{1,tmpdir$}
 aslfr_SetFile{1,tmpfile$}

 If aslfr_Request{1,False,False,False,sourceWindow\pedScreen}
   tempdir$      = aslfr_GetPath{1}
   tempfile$     = aslfr_GetFile{1}
   tempcomplete$ = dos_AddPart{tempdir$ , tempfile$}
 Else
   tempfile$ = ""
 EndIf

 If tempfile$ <> ""
   ped\currentDir = tempdir$
   ped\currentFile = tempfile$
   ped\sourceFileComplete = tempcomplete$
   Function Return tempcomplete$
 EndIf
End Function

Function.l PED_GetMessage{_wait.b}
SHARED pedMessage,sourceWindow

  pedMessage\_Class = 0
  pedMessage\_Code  = 0
  pedMessage\_Qualifier = 0
  pedMessage\_IAddress  = 0
  pedMessage\_MouseX    = 0
  pedMessage\_MouseY    = 0
  pedMessage\_Window    = 0
  pedMessage\_Seconds   = 0
  pedMessage\_Micros    = 0

  If _wait = True
    pedMessage\_Class     = WaitEvent
  Else
    pedMessage\_Class     = Event
  ;*msg.IntuiMessage = GetMsg_(sourceWindow\win\UserPort)
  EndIf

  ;If *msg Then ReplyMsg_ *msg
  pedMessage\_Code      = EventCode
  pedMessage\_Qualifier = EventQualifier
  pedMessage\_IAddress  = EventiAddress
  pedMessage\_MouseX    = EMouseX
  pedMessage\_MouseY    = EMouseY
  pedMessage\_Window    = EventWindow
  pedMessage\_Seconds   = EventSeconds
  pedMessage\_Micros    = EventMicros

  Function Return pedMessage\_Class
End Function


;@@0
.STARTUP_PED 
; -------------------------------------------------------------------------------------
; START OF CODE
; -------------------------------------------------------------------------------------

; -- check for TEDY as input of D1, if NOT, program was not run from IDE
; -- we have to switch to asm-context, as the registers have been stored there
!asm
MOVE.l A1,comLong_AB3IsAvailable   ; only used as indicator if started by compiler
MOVEM.l D1/A1,-(A7)
!basic
MOVEM.l (A7)+,D1/A1
PutReg D1, tedy.l      ; should be "TEDY
PutReg A1, teddata.l      ; should contain pointer to compilers "teddata"-structure
If tedy <> @"TEDY"
  error{"PED is not a standalone editor anymore.\\nPlease start the AmiBlitz3-IDE via Compiler."}
  Goto immediate_exit
EndIf

; -- copy received teddata of compiler in A1 to local data structures
Poke.l ?comPtr_TokenBase        , Peek.l(teddata)     
Poke.l ?comFunc_ReadXtraFile    , Peek.l(teddata+4)
Poke.l ?comFunc_WriteXtraFile   , Peek.l(teddata+8)
Poke.l ?comFunc_CallMenuEntry   , Peek.l(teddata+12)
Poke.l ?comByte_ColonIdentifier , Peek.l(teddata+16)
*tokenbase = Peek.l(?comPtr_TokenBase)
*newtypebase = Peek.l(teddata+20)
*constantbase = Peek.l(teddata+24)
*macrobase = Peek.l(teddata+28)

; skip simple newtypes b,w,l,q,s
For _nt.b = 1 To 5
  *newtypebase = Peek.l(*newtypebase)
Next _nt

; --
; -- check/set tokenisation mode, If no tokens available, Disable tokenization
If *tokenbase = 0 
  ped\DoTokenize = 0
Else
  ped\DoTokenize = $ffff
EndIf
Poke.w ?comWord_DoTokenize, ped\DoTokenize

; --
; -- initiation of the disallowed characters table
MOVEQ #127,d0                      ; clear char-table
LEA chartab,a0
'l12
  MOVE.b #1,128(a0)
  CLR.b (a0)+
DBF d0,'l12

LEA chartab,a0                     ; init char-table
MOVE.b #1,(a0)
MOVE.b #1,","(a0)
MOVE.b #1,";"(a0)
MOVE.b #1,":"(a0)
MOVE.b #1,"("(a0)
MOVE.b #1,")"(a0)
MOVE.b #1,"="(a0)
MOVE.b #1,"+"(a0)
MOVE.b #1,"-"(a0)
MOVE.b #1,"*"(a0)
MOVE.b #1,"/"(a0)
MOVE.b #1,"$"(a0)
MOVE.b #1,"%"(a0)
MOVE.b #1,"."(a0)
MOVE.b #1,"["(a0)
MOVE.b #1,"]"(a0)
MOVE.b #1,"{"(a0)
MOVE.b #1,"}"(a0)
MOVE.b #1,"\"(a0)
MOVE.b #1,">"(a0)
MOVE.b #1,"<"(a0)
MOVE.b #1,"&"(a0)
MOVE.b #1,"|"(a0)
MOVE.b #1,"^"(a0)
MOVE.w #0101,1(a0)
MOVE.b #1,$20(a0)
 
; -- setting comdatas
!ComData_LEA{comFunc_ErrorRequest           ,A0}        : MOVE.l #com_showErrorRequest        ,(A0) ;$0C
!ComData_LEA{comFunc_DebugTrap              ,A0}        : MOVE.l #com_debugTrap               ,(A0) ;$38
!ComData_LEA{comFunc_OpenConsole            ,A0}        : MOVE.l #com_consoleOpen             ,(A0) ;$3C
!ComData_LEA{comFunc_CloseConsole           ,A0}        : MOVE.l #com_consoleClose            ,(A0) ;$40
!ComData_LEA{comFunc_LogPrint               ,A0}        : MOVE.l #com_logPrint                ,(A0) ;$44
!ComData_LEA{comFunc_DetokenizeLine         ,A0}        : MOVE.l #com_detokenizeLine          ,(A0) ;$64
!ComData_LEA{comPtr_SourceDir               ,A0}        : MOVE.l #comStr_SourceDir            ,(A0) ;$68
!ComData_LEA{comPtr_SourceName              ,A0}        : MOVE.l #comStr_SourceName           ,(A0) ;$6C
!ComData_SetL{comFunc_CloseGUI              ,#close_gui}
!ComData_SetL{comFunc_CreateGUI             ,#create_whole_gui}
!ComData_SetL{comData_Magic                 ,##MagicIdentifier_Long}
!ComData_SetL{comFunc_UpdateCompileStatusWin,#com_updateCompileWindow}

 
;****************** ted.library is only needed for sharing comdata with the Debugger!
If ted_OpenLib{0}
  Gosub set_tedlibbase
Else
  error {!TRANS{"Unable to open ted.library!"}}
  Goto exit_PED_nomem
EndIf


; ########################################################################################
; # memory allocations
; ########################################################################################
ped\mempool = CreatePool_(#MEMF_CLEAR,40000,40000)
If ped\mempool = 0
  log_Print{"Could not allocate enough memory. PED closes down now.",#log_error}
  Pop If
  Goto exit_PED_nomem
EndIf
Poke.l ?comPtr_MemPool,ped\mempool

; -- 
; -- alloc some memory for filereading
readcache\bufferptr = PED_AllocMem{8192}
If readcache\bufferptr = 0 Then Goto exit_PED_closelibraries
readcache\fib = AllocDosObject_ (#DOS_FIB,0)
*rc_fib.FileInfoBlock = readcache\fib

; --
; -- alloc some memory for tokenization
tokenstringptr.l = PED_AllocMem{(#MAX_Columns + 2) * 3}
If tokenstringptr = 0 Then Goto exit_PED_closelibraries
Poke.l ?comPtr_Temp_TokenString1, tokenstringptr + (#MAX_Columns + 2) * 0
Poke.l ?comPtr_Temp_TokenString2, tokenstringptr + (#MAX_Columns + 2) * 1
Poke.l ?comPtr_Temp_TokenString3, tokenstringptr + (#MAX_Columns + 2) * 2

; --
; -- alloc memory for textbuffer of source editor
textbuffers.l = PED_AllocMem{(#MAX_Columns + 4) * 2}
If textbuffers = 0 Then Goto exit_PED_closelibraries
ped\ptrTextbufferPrint   = textbuffers + (#MAX_Columns + 4) * 0
ped\ptrLineUndeleteStore = textbuffers + (#MAX_Columns + 4) * 1

; --
; -- alloc memory for tokencache
ped\tokenCache = PED_AllocMem{32768 * 4}
If ped\tokenCache = 0 Then Goto exit_PED_closelibraries

; ########################################################################################
; # return to compiler and continue after being recalled by compiler
; ########################################################################################
!log_AvailMem{"after reserve of buffers for source code, giving control back to compiler..."}
; --
; -- return to compiler after initiation
!asm
MOVE.l comLong_AB3IsAvailable,D0
BEQ.w start_up_without_compiler
  LEA compiler_jumps_here,A0
  MOVEA.l comdata,A1
  MOVE.w ##ComDataVersionID,comWord_PEDIsAvailable
  RTS                              ; <-- return to compiler
start_up_without_compiler:
LEA str_tempfilename,A0

compiler_jumps_here:               ; compiler offers str_tempfilename in A0 here                                                                                                                                                                         
MOVE.l A0,-(a7)
!basic
MOVE.l (a7)+,A0 : PutReg A0,tmpA0.l
If tmpA0
  compiler_source$ = Peek.s(tmpA0)
Else
  error{"NULL Pointer in compiler_source$!"}
End If
!log_AvailMem{"after Compiler has given control back"}

; ======================================================================================
.MAINPORGRAM
; ======================================================================================
*varbase = Peek.l(?comPtr_VarBase)

FindScreen 0

; ---  Check  if  all  needed  Librarys  are  available  with  the  needed  min  Version
; --------------------------------------------------------------------------------------
ende.b     = False   ; abort indicater
errorout.s = ""      ; for the error text

If dos_CheckLib{"wizard.library",42} = False        ; needed for PED and REDDebugger
  errorout + "Missing 'wizard.library':\\nVersion 42 of this library is required by the IDE.\\n\\n"
  ende = True
EndIf

;If dos_CheckLib{"ted.library",1} = False            ; needed for PED and REDDebugger
;  errorout + "Missing 'ted.library':\\nVersion 1 of this library is required by the IDE.\\n\\n"
;  ende = True
;End If
If dos_CheckLib{"disassembler.library",40} = False  ; only needed for REDDebugger
  errorout + "Missing 'disassembler.library':\\nVersion 40 of this library is required by REDDebugger.\\nASM debugging won't work.\\n\\n"
End If
If errorout <> ""
   errorout = "Please reinstall AmiBlitz3 or copy the following librarys to LIBS:\\n\\n" + errorout
   If ende
     errorout + "... that the PED can start!" ; for abort
   Else
     errorout + "... for a full working IDE!" ; for limited start
   End If
   error{!TRANS{errorout}}
End If
If ende Then Goto immediate_exit
; -----------------------------------------------------------------------------------


; ------------------------------------------------------------------------------------
; AUSWERTEN DER TOOLTYPES
; ------------------------------------------------------------------------------------
.TOOLTYPES
  tt.s = dos_GetProgIcon{dos_AddPart{default_assign,"AmiBlitz3"} }   ;  replaces hardcode string "blitz3:" tomsmart 2012 03 12
  log_Print{"opening tooltypes for <" + tt.s + ">"}
  disk_object.l = dos_OpenToolTypes{tt.s}
  If disk_object
    ; ---- LOGGING --------------------------------------------------    
    tmp_string = UCase$(dos_GetToolString{"LOG_LEVEL","NOTHING"})                                                                                                                                                                                            
    logging_level.b = #log_nothing
    If tmp_string = "NOTHING" Then logging_level = #log_nothing                                                                                                                                                                                            
    If tmp_string = "DEBUG" Then logging_level = #log_debug                                                                                                                                                                                                
    If tmp_string = "INFO" Then logging_level = #log_information                                                                                                                                                                                           
    If tmp_string = "WARN" Then logging_level = #log_warning                                                                                                                                                                                               
    If tmp_string = "ERROR" Then logging_level = #log_error                                                                                                                                                                                                
    log_SetLevel{logging_level}

    log_mode.b = #log_toconsole
    tmp_string = UCase$(dos_GetToolString{"LOG_MODE","CONSOLE"})                                                                                                                                                                                             
    If tmp_string = "FILE" Then log_mode = #log_tofile                                                                                                                                                                                                     
    If tmp_string = "CONSOLE" Then log_mode = #log_toconsole                                                                                                                                                                                               
    If tmp_string = "BOTH" Then log_mode = #log_toboth                                                                                                                                                                                                     
    log_SetDestination{log_mode,"System/PED.log"}

    ; ----- OTHER TOOLTYPES
    !log_AvailMem{"at tooltype begin"}

    If dos_GetToolState{"disable_welcome"}     = -1 Then pedconfig\no_welcome      = True  : Else pedconfig\no_welcome = 0
    If dos_GetToolState{"askbeforequit"}       = -1 Then pedconfig\ask_before_quit = True  : Else pedconfig\ask_before_quit = 0
    If dos_GetToolState{"smart_tokenization"}  = -1 Then pedconfig\smart_tokenization = True  : Else pedconfig\smart_tokenization = 0
    If dos_GetToolState{"disable_displaybeep"} = -1 Then pedconfig\no_display_beep = True  : Else pedconfig\no_display_beep =   0
    If dos_GetToolState{"auto_format"}         = -1 Then pedconfig\auto_format     = True  : Else pedconfig\auto_format = 0
    If dos_GetToolState{"auto_indent"}         = -1 Then pedconfig\auto_indent     = True  : Else pedconfig\auto_indent = 0  ; added because was not loaded befor tomsmart1
    If dos_GetToolState{"auto_constructs"}     = -1 Then pedconfig\auto_constructs = True  : Else pedconfig\auto_constructs = 0
    If dos_GetToolState{"correct_functions"}   = -1 Then pedconfig\correct_functions = True  : Else pedconfig\correct_functions = 0
    If dos_GetToolState{"bold_tokens"}         = -1 Then pedconfig\bold_tokens       = True  : Else pedconfig\bold_tokens = 0
    If dos_GetToolState{"italic_remarks"}      = -1 Then pedconfig\italic_remarks  = True  : Else pedconfig\italic_remarks = 0
    If dos_GetToolState{"linenumbers"}         = -1 Then pedconfig\linenumbers     = True  : Else pedconfig\linenumbers = 0
    If dos_GetToolState{"DISABLE_HIGHLIGHTING"}= -1 Then pedconfig\highlighting  = False  : Else pedconfig\highlighting = True
    If dos_GetToolState{"DISABLE_LOCALIZATION"}  = -1 Then pedconfig\localization = False : Else pedconfig\localization = True
    If dos_GetToolState{"HELPFORPRIVATFUNCTIONS"}  = -1 Then pedconfig\HelpForPrivateFunctions = True : Else pedconfig\HelpForPrivateFunctions = 0
    If dos_GetToolState{"USE_INTELLISENSE"}        = -1 Then pedconfig\intellisense = True  : Else pedconfig\intellisense = 0
    If dos_GetToolState{"USE_INTELLISENSE_COMMANDS"}= -1 Then pedconfig\use_commandsintellisens = True  :Else pedconfig\use_commandsintellisens = False
    If dos_GetToolState{"onlinehelp"}          = -1 Then pedconfig\onlinehelp      = True  : Else pedconfig\onlinehelp = 0
    If dos_GetToolState{"onlinehelp_extended"} = -1 Then pedconfig\onlinehelp_extended = True : Else pedconfig\onlinehelp_extended = 0
    If dos_GetToolState{"DISABLE_INCLUDEHELP"} = -1 Then pedconfig\onlinehelp_includes   = False  : Else pedconfig\onlinehelp_includes = True
    If AvailMem_(#MEMF_FAST) < 4000000 AND (pedconfig\onlinehelp_includes OR pedconfig\intellisense)
      errormessage$ = "The available memory is low.\\n"
      errormessage$ + "Online-Help and intellisense for Include-functions will be disabled.\\n"
      errormessage$ + "You should check following tooltypes:\\n\\n"
      errormessage$ + "- DISABLE_INCLUDEHELP\\n"
      errormessage$ + "- DISABLE_LOCALIZATION\\n"
      errormessage$ + "- USE_INTELLISENSE"
      error{errormessage$}
      pedconfig\intellisense = False
      pedconfig\onlinehelp_includes = False
    End If
    ;pedconfig\intellisense = pedconfig\onlinehelp_includes

    If dos_GetToolState{"SOURCE_HISTORY"}          = -1 Then pedconfig\remember_saved    = True : Else pedconfig\remember_saved = 0
    If dos_GetToolState{"LOAD_LAST_SOURCE"}        = -1 Then pedconfig\load_last_source  = 1 : Else pedconfig\load_last_source = 0
    If dos_GetToolState{"USE_FILEPATTERN"}         = -1 Then pedconfig\use_filepattern=1 : Else pedconfig\use_filepattern=0
    If dos_GetToolState{"SORT_LABELS"}             = -1 Then pedconfig\sort_labels       = True  : Else pedconfig\sort_labels = 0
    If dos_GetToolState{"CON_ONWB"}                = -1 Then pedconfig\console_wb        = True  : Else pedconfig\console_wb  = 0
    If dos_GetToolState{"CON_WAIT"}                = -1 Then pedconfig\console_wait      = True  : Else pedconfig\console_wait = 0

    If dos_GetToolState{"CLONE_WBSCREEN"}   = True
      pedconfig\clone_wbscreen = True : pedconfig\use_wbscreen = False
    Else
      If dos_GetToolState{"USE_WBSCREEN"}   = True
        pedconfig\use_wbscreen = True : pedconfig\clone_wbscreen = False
      EndIf
    EndIf
    If dos_GetToolState{"PUBSCREEN"}          = -1 Then pedconfig\use_pubscreen         = True : Else pedconfig\use_pubscreen = 0
    If dos_GetToolState{"DEFAULTPUBSCREEN"}   = -1 Then pedconfig\use_default_pubscreen = True : Else pedconfig\use_default_pubscreen = 0
    If dos_GetToolState{"USE_WBFONT"}         = -1 Then pedconfig\use_wbfont            = True : Else pedconfig\use_wbfont = 0
  Else
    log_Print{"Could not open tooltypes",#log_warning}
    pedconfig\bold_tokens       = True
    pedconfig\onlinehelp        = True
    pedconfig\onlinehelp_extended = False
    pedconfig\clone_wbscreen     = False
    pedconfig\use_wbscreen       = True
    pedconfig\use_pubscreen      = False
    pedconfig\use_default_pubscreen = False
    pedconfig\use_wbfont         = True
    pedconfig\use_filepattern    = True
  End If

  If dos_GetToolState{"CREATE_ICONS"}=-1 Then pedconfig\use_source_icon = True Else pedconfig\use_source_icon = False
  If dos_GetToolState{"AUTOLAYOUT"}=-1 Then pedconfig\autolayout     = True Else pedconfig\autolayout = False

  pedconfig\al_leftspace   = dos_GetToolValue{"autolayout_left"  ,0}
  pedconfig\al_topspace    = dos_GetToolValue{"autolayout_top"   ,0}
  pedconfig\al_rightspace  = dos_GetToolValue{"autolayout_right" ,0}
  pedconfig\al_bottomspace = dos_GetToolValue{"autolayout_bottom",0}

  pedconfig\console_device = dos_GetToolString{"CON_DEVICE","CON:"}
  pedconfig\console_font   = dos_GetToolString{"CON_FONT",""}


  pedconfig\cursorStyle = cursorStyleGetValue{dos_GetToolString{"cursorstyle","block"}}
  pedconfig\scroll_rate = dos_GetToolValue{"scrollrate",0}
  If pedconfig\scroll_rate <> 0
    If vvblank_SetFreq{pedconfig\scroll_rate} = False Then ped\no_scrollrate = True
  Else
    ped\no_scrollrate = True
  EndIf

  pedconfig\tabSize =  dos_GetToolValue{"tabsize",2}
  pedconfig\blinkrate = dos_GetToolValue{"cursorblinkrate",5}
  pedconfig\wheelStep = dos_GetToolValue{"MOUSEWHEELSTEP",6}     ; added to make Mousewheelsteprate changeable  tomsmart1

  ; --- ASL-Requestersettings ------------------------------
  pedconfig\asl_x = dos_GetToolValue{"ASLREQ_X" ,20}
  pedconfig\asl_y = dos_GetToolValue{"ASLREQ_Y" ,20}
  pedconfig\asl_w = dos_GetToolValue{"ASLREQ_W",320}
  pedconfig\asl_h = dos_GetToolValue{"ASLREQ_H",200}
  asl_SetRequesterDims{pedconfig\asl_x,pedconfig\asl_y,pedconfig\asl_w,pedconfig\asl_h}

  ; --- COLORS ---------------------------------------------
  AB3RGB(#AB3_ctoken)            = dos_GetToolValue{"tokencolor"      ,$646bd7} ;: Poke.b ?tokencolor,AB3RGB(#AB3_ctoken
  AB3RGB(#AB3_cfunction)         = dos_GetToolValue{"functioncolor"   ,$396635} ;: Poke.l ?functioncolor,AB3RGB(#AB3_cfunction
  AB3RGB(#AB3_cconstant)         = dos_GetToolValue{"constantcolor"   ,$8C338A} ;: Poke.l ?constantcolor,AB3RGB(#AB3_cconstant
  AB3RGB(#AB3_cnewtype)          = dos_GetToolValue{"newtypecolor"    ,$153492} ;: Poke.l ?newtypecolor,AB3RGB(#AB3_cnewtype
  AB3RGB(#AB3_cstring)           = dos_GetToolValue{"stringcolor"     ,$7D8A83} ;: Poke.w ?stringcolor,AB3RGB(#AB3_cstring
  AB3RGB(#AB3_cmacro)            = dos_GetToolValue{"macrocolor"      ,$CB3817} ;: Poke.l ?macrocolor,AB3RGB(#AB3_cmacro
  AB3RGB(#AB3_cother)            = dos_GetToolValue{"othercolor"      ,$000000} ;: Poke.w ?othercolor,AB3RGB(#AB3_cother
  AB3RGB(#AB3_cremarkforeground) = dos_GetToolValue{"remarkforg"      ,$6a9a66} ;: Poke.b ?remarkcolor,AB3RGB(#AB3_cremarkforg
  AB3RGB(#AB3_cremarkbackground) = dos_GetToolValue{"remarkbackg"     ,$f9f9f9} ;: Poke.b ?remarkbgcolor,AB3RGB(#AB3_cremarkbackg
  AB3RGB(#AB3_ctokenbackground)  = dos_GetToolValue{"tokenbackpen"    ,$ffffff} ;: Poke.b ?tokenbackground,AB3RGB(#AB3_ctokenbackground
  AB3RGB(#AB3_cbackground)       = dos_GetToolValue{"backgroundcolor" ,$ffffff} ;: Poke.l ?backgroundcolor,AB3RGB(#AB3_cbackgroundcolor
  AB3RGB(#AB3_cclassic)          = dos_GetToolValue{"classiccolor"    ,$ff0500} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screenback)        = dos_GetToolValue{"screenbackcolor" ,$c8c8c8} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screentext)        = dos_GetToolValue{"screentextcolor" ,$000000} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screenshine)       = dos_GetToolValue{"screenshinecolor",$FFFFFF} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screenfill)        = dos_GetToolValue{"screenfillcolor" ,$6e94e2} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic

  ; --- SCREEN ---------------------------------------------
  pedconfig\screen_modeID  = dos_GetToolValue{"SCREEN_ID"     ,0} ;: Poke.l ?ownscreen_modeid ,pedconfig\screen_modeid
  pedconfig\screen_Width   = dos_GetToolValue{"SCREEN_WIDTH"  ,0} ;: Poke.w ?ownscreen_width  ,pedconfig\screen_Width
  pedconfig\screen_Height  = dos_GetToolValue{"SCREEN_HEIGHT" ,0} ;: Poke.w ?ownscreen_height ,pedconfig\screen_Height
  pedconfig\screen_Depth   = dos_GetToolValue{"SCREEN_DEPTH"  ,0} ;: Poke.w ?ownscreen_depth  ,pedconfig\screen_Depth

  ; check if any Screentooltype set
  If (pedconfig\clone_wbscreen = 0) AND (pedconfig\use_wbscreen = 0) AND (pedconfig\screen_modeID = 0)
     pedconfig\use_wbscreen = True  ; we use WBScreen if no Screen Tooltype is set
  EndIf

  project_changelog$ = ""
  find_strold.s    = ""                                                                                                                                                                                                                                  
  find_replaceStrOld.s = ""                                                                                                                                                                                                                              

  ; --- FONTS ----------------------------------------------
  If pedconfig\use_wbfont = False
    ;no Tooltype use_wbfont so check for GUI and Source font tooltypes
    str_guifont$    = dos_GetToolString{"guifont",""}       ; no predefine Font use WB fonts instead
    str_sourcefont$ = dos_GetToolString{"sourcefont",""}

    If str_guifont$<>"" OR str_sourcefont$<>""
      ; check and set GUIfont
      If str_guifont$<>""
        InitArgParse str_guifont$
        guifont_name$ = NextArgChar$(@",")
        a$ = NextArg$
        guifont_size.w = Vallong(a$)
      EndIf
      ; check and set Sourcefont
      If str_sourcefont$<>""
        InitArgParse str_sourcefont$
        sourcefont_name$ = NextArgChar$(@",")
        a$ = NextArg$
        sourcefont_size.w = Val(a$)
        ;Poke.s ?str_sourcefontname ,sourcefont$ + StrClone(Chr$(0),79 - Len(sourcefont$))
        ;Poke.w ?sourcefontsize     ,sourcefont_size
        ;Poke.b ?sourcefontstyle    ,sourcefont_style.w
      EndIf
    Else
      ; no guifont and sourcefont set so use WBfonts
      pedconfig\use_wbfont = True
    EndIf
  EndIf

  ; --- DIRECTORIES ---------------------------------------
  pedconfig\mainDir      = dos_GetToolString{"ASSIGN",default_assign}
  If pedconfig\mainDir = "" Then pedconfig\mainDir = default_assign ; in case someone sets assign to ""
  pedconfig\systemDir    = dos_AddPart{pedconfig\mainDir,"System"}
  pedconfig\blitzlibDir = dos_AddPart{pedconfig\mainDir,"Blitzlibs"}
  pedconfig\lastSourceFile     = dos_GetToolString{"last_source",""}

  pedconfig\includeDir      = dos_GetToolString{"INCLUDEDIR" ,dos_AddPart{pedconfig\mainDir,"Sourcecodes/Includes"}}
  pedconfig\helpDir         = dos_GetToolString{"HELPDIR"    ,dos_AddPart{pedconfig\mainDir,"Docs"}}
  pedconfig\autodocDir      = dos_GetToolString{"AUTODOCDIR" ,dos_AddPart{pedconfig\mainDir,"Docs"}}
  pedconfig\sourceDir       = dos_GetToolString{"SOURCEDIR"  ,dos_AddPart{pedconfig\mainDir,"Sourcecodes"}}
  pedconfig\winprefsFile = dos_GetToolString{"WINDOWPREFS",dos_AddPart{pedconfig\mainDir,"System/ped_addon.prefs"}}
  pedconfig\rememberFile = dos_AddPart{pedconfig\systemDir,"PED.history"}
  pedconfig\menuFile = dos_AddPart{pedconfig\systemDir,"PED.menus"}

  ; -- lib collections
  If dos_GetToolState{"BASELIBS"} <> 0
    If dos_GetToolState{"BASELIBS"} =-1 Then pedconfig\useBaseLib = True
    pedconfig\baselibFile = dos_GetToolString{"BASELIBS",dos_AddPart{pedconfig\blitzlibDir,"AcidLibs"}}
    log_Print{"BASELIBS = " + pedconfig\baselibFile}
  EndIf
  If pedconfig\baselibFile <> ""
    If dos_Exist{pedconfig\baselibFile}
      ped\baselibFileDate = Replace$(dos_GetFileDate{pedconfig\baselibFile},"/",".")
      ped\baselibFileSize = dos_GetFileSize{pedconfig\baselibFile}
    EndIf
  EndIf

  If dos_GetToolState{"UTILLIBS"} <> 0
    If dos_GetToolState{"UTILLIBS"} =-1 Then pedconfig\useUtilLib = True
    pedconfig\utillibFile = dos_GetToolString{"UTILLIBS",dos_AddPart{pedconfig\blitzlibDir,"DefLibs"}} 
    log_Print{"UTILLIBS = " + pedconfig\utillibFile}
  EndIf
  If pedconfig\utillibFile <> ""
    If dos_Exist{pedconfig\utillibFile}
      ped\utillibFileDate = Replace$(dos_GetFileDate{pedconfig\utillibFile},"/",".")
      ped\utillibFileSize = dos_GetFileSize{pedconfig\utillibFile}
    EndIf
  EndIf

  If dos_GetToolState{"OSLIBS"} <> 0
    If dos_GetToolState{"OSLIBS"} =-1 Then pedconfig\useOsLib = True
    pedconfig\oslibFile = dos_GetToolString{"OSLIBS",dos_AddPart{pedconfig\blitzlibDir,"OsLibs"}}
    log_Print{"OSLIBS = " + pedconfig\oslibFile}
  EndIf
  If pedconfig\oslibFile <> ""
    If dos_Exist{pedconfig\oslibFile}
      ped\oslibFileDate  = Replace$(dos_GetFileDate{pedconfig\oslibFile},"/",".")
      ped\oslibFileSize  = dos_GetFileSize{pedconfig\oslibFile}
    EndIf
  EndIf

  If dos_GetToolState{"CSLIBS"} <> 0
    If dos_GetToolState{"CSLIBS"} =-1 Then pedconfig\useCsLib = True
    pedconfig\cslibFile = dos_GetToolString{"CSLIBS",dos_AddPart{pedconfig\blitzlibDir,"CsLibs"}}
    log_Print{"CSLIBS = " + pedconfig\cslibFile}
  EndIf
  If pedconfig\cslibFile <> ""
    If dos_Exist{pedconfig\cslibFile}
      ped\cslibFileDate  = Replace$(dos_GetFileDate{pedconfig\cslibFile},"/",".")
      ped\cslibFileSize  = dos_GetFileSize{pedconfig\cslibFile}
    EndIf
  EndIf

  ; settings for type browser
  ped\definitionMode = -1


  !log_AvailMem{"after tooltypes"}

  ; -- localization
  If pedconfig\localization
    !log_AvailMem{"before preparing localization"}
    !TRANS_INIT{"AmiBlitz3"}
    !log_AvailMem{"preparing localization done"}
  EndIf

  pedconfig\console_title  = !TRANS{"AmiBlitz3 Console Output"}

  If pedconfig\localization
    *MyCatalog.Catalog = OpenCatalogA_(0,"PED.catalog",0)
    If *MyCatalog
      ;set tags so Wizardlibrary Use catalog File
      log_Print{"language: " + Peek.s(*MyCatalog\cat_Language)}
      WZTags #SFH_Catalog,*MyCatalog,#TAG_DONE,0,#TAG_END,0
    Else
      log_Print{"could not open catalog file",#log_warning}
    EndIf
  EndIf

  ; -- setup wizard GUI
  WZLoadGUI ?wzgui

WZ_ShowMessage{!TRANS{"Initiating AmiBlitz3 Environment..."} }
WZ_ChangeTitle{"WIN_PROGRESS","Amiblitz3 V" + !versions}  ; use Statement to remove double code tomsmart1 2012 03 09                                                                                                                                     


;--- Check to identify on with OS we are running         ; added to disable the Mousewheel settings in the IDE prefs for OS4 because we use the System values with OS4  tomsmart1
SHARED OSVersion.l
OSVersion = #AmigaOS3
If ( dos_CheckLib{"exec.library",50} ) Then OSVersion = #AmigaOS4 ;: message{"REDDebugger: I think I run on OS4, because I was able to open exec.library v50+!"}
If ( FindResident_("MorphOS") )        Then OSVersion = #MorphOS  ;: message{"REDDebugger: I think I run on MOS, because I found the 'MorphOS' Resident!"}
;-----


; ------------------------------------------------------
; EINBINDEN DER KONFIGURATIONSDATEIEN
; ------------------------------------------------------
.CONFIGFILES

WZ_ShowMessage{!TRANS{"Preparing preprocessor/tokenizer ..."}}
pedconfig\HelpIndexFile          = dos_AddPart{pedconfig\systemDir,"HelpIndex.txt"}
pedconfig\HelpIndexCacheFile        = dos_AddPart{pedconfig\systemDir,"HelpIndexCache.bin"}
TokenHashMapFile.s         = dos_AddPart{pedconfig\systemDir,"TokenList.hashmap"}
*PreProcessor = preproc_Create{}
Poke.l ?comPtr_PreProcessor,*PreProcessor
preproc_LoadTokens{*PreProcessor,TokenHashMapFile}

!log_AvailMem{"after preparing preprocessor/tokenizer"}


If pedconfig\onlinehelp_includes
  WZ_ShowMessage{!TRANS{"Loading helpindex for include-functions ..."}}
  If dos_Exist{pedconfig\HelpIndexCacheFile} AND dos_GetFileSize{pedconfig\HelpIndexCacheFile} > 0
    ;log_Print{"loading help index cache file: " + pedconfig\HelpIndexCacheFile}
    PED_LoadHelpIndexCache{pedconfig\HelpIndexCacheFile}
  Else
    log_Print{"building help index cache file: " + pedconfig\HelpIndexCacheFile}
    BuildHelpIndexWinTitle$ = "Building"                         ;added so the window title match the function  tomsmart1 ; remove !TRANS{} because it will translated with befor it will displayed  tomsmart1
    Gosub build_HelpIndexFile
  End If
  !log_AvailMem{"after loading includehelpindex"}
Else
  !log_AvailMem{"index for includefiles skipped."}
End If

If ReadFile (0,pedconfig\winprefsFile)
  WZ_ShowMessage{!TRANS{"Loading window layouts ..."}}
  ReadType 0,wpref(0)
  ReadType 0,wpref(1)
  ReadType 0,wpref(2)
  CloseFile 0
End If

WZ_ShowMessage{!TRANS{"Starting IDE ..."} }



; ########################################################################################
; # create ports
; ########################################################################################
; --
; -- create a msgport for Iconification
*WBMsgPort.MsgPort = CreateMsgPort_

; -- 
; -- init arrexport
CNIF #USE_AREXX = 1
  !log_AvailMem{"before init arexx-port..."}
  Gosub arexx_init
  AddWaitEvent PortSigBit(*ArexxMsgPort.MsgPort),$8000000
CEND


; --
; -- load sourcefont
Gosub open_sourcefonts

; --
; -- add the source history to the menu
If pedconfig\remember_saved
  Gosub load_pedrememberfile
Else
  Gosub update_remembermenu
EndIf

; --
; -- fill mapping array with libnames from mapping-file
; -- and check consistency based on the mapping files and the internal libnums
WZ_ShowMessage{!TRANS{"Building tokenindex..."}}
map_tokens_to_libs{dos_AddPart{pedconfig\systemDir,"token_mapping_libs.txt"}}
map_tokens_to_libs{dos_AddPart{pedconfig\systemDir,"token_mapping_userlibs.txt"}}

!log_AvailMem{"after doing token index"}

If *PreProcessor\tokens = Null     ; we have no hashmap loaded, create it!
  WZ_ShowMessage{!TRANS{"Creating Hashmaps..."}}
  preproc_QueryTokens{*PreProcessor}
  preproc_SaveTokens{*PreProcessor,TokenHashMapFile}
End If

!log_AvailMem{"after preproc hashmap"}

WZ_HideMessage{}

.START_GUI
Gosub open_gui
Gosub menu_new
Gosub update_debuggertoggle

Gosub set_CurrentDir
*flock_defaultDir.l = *flock_currentDir.l

log_Print{"source file given by compiler: [" + compiler_source$ + "]"}
log_Print{"check lastsource option"}
If pedconfig\load_last_source <> 0 OR compiler_source$<>""
  If compiler_source$<>"" Then pedconfig\lastSourceFile = compiler_source$
  If pedconfig\lastSourceFile <> ""
    tmp_sourceDir.s = dos_PathPart{pedconfig\lastSourceFile}
    If Right$(tmp_sourceDir,1)<>":" Then tmp_sourceDir + "/" ; dirty hack, but better than editing ASM
    ped\currentFile = dos_FilePart{pedconfig\lastSourceFile}
    ped\currentDir = tmp_sourceDir
    ped\sourceFileComplete =  pedconfig\lastSourceFile
    Poke.s ?comStr_SourceDir,tmp_sourceDir
    Poke.s ?comStr_SourceName,dos_FilePart{pedconfig\lastSourceFile}
  EndIf
EndIf

  ; --
  ; -- jump to mainloop if no sourcename given, else
  ; -- load last Source
.AUTOLOAD_SOURCE
If ped\currentFile <> ""
  ;!PED_CursorOff
  !PED_LoadSource{ped\sourceFileComplete,False,False,False}
  ;!PED_CursorOn
Else
  log_Print{"no file to autoload."}
  PED_UpdateStatusArea{#STATUS_REDRAW}                                                                                                                                                                                                                   
  PED_RedrawSource{}
EndIf

; -- show welcome requester if option selected
If NOT pedconfig\no_welcome Then Gosub menu_about

; ============================================================================
; -- jump to main loop                                                                                                                                                                                                                                   
; --
log_Print{"Tokenbase   = " + Hex$(*tokenbase)}
log_Print{"NewTypebase = " + Hex$(*newtypebase)}
log_Print{"Constantbase= " + Hex$(*constantbase)}
log_Print{"Macrobase   = " + Hex$(*macrobase)}
log_Print{"allocated Buffer for TokenString1 at " + Hex$(?comPtr_Temp_TokenString1)}

Gosub main_loop
; --
; -- shutdown PED after return of the mainloop
; ============================================================================

log_Print{"closing GUI..."}
Gosub close_gui

exit_PED_closeall:
  log_Print{"freeing textbuffer..."}
  Gosub free_textbuffer

  log_Print{"closing fonts..."}
  Gosub close_sourcefonts

exit_PED_closelibraries:
  log_Print{"closing ted.library ..."}
  ted_CloseLib{}

  log_Print{"closing catalog an libs..."}
  If *MyCatalog Then CloseCatalog_ *MyCatalog

  log_Print{"closing ports..."}
  If *WBMsgPort Then DeleteMsgPort_ *WBMsgPort
  CNIF #USE_AREXX = 1
    log_Print{"sending AREXX-message QUITPLEASE"}
    ArexxMyMessage$ = "QUITPLEASE" : Gosub arexx_sendmessage

    log_Print{"closing arexxport.."}
    Gosub arexx_free
  CEND

  log_Print{"unlocking directory..."}
  CurrentDir_(*flock_defaultDir)
  If *flock_currentDir Then UnLock_ *flock_currentDir

  exit_PED_nodoslib:
  log_Print{"freeing memory..."}
  preproc_Free{*PreProcessor} : *PreProcessor = Null

  If readcache\fib Then FreeDosObject_ #DOS_FIB,readcache\fib  : readcache\fib = Null

  If readcache\cacheptr
    FreeVec_ readcache\cacheptr 
    readcache\cacheptr = Null
    readcache\readlen = 0
  End If

  exit_PED_nomem:
  log_Print{"deleting mempool..."}
  DeletePool_ ped\mempool

.immediate_exit:
  !asm
  CLR.w comWord_PEDIsAvailable
  ;MOVEA.l comdata,A1           ; not needed as ped is gone in a few moments
  !exitasm                      ; exitasm jumps into basic mode
End
; ----------------------------------- END OF MAINPROGRAM ------------------------------------------


; ---------------------------------- THIS IS THE MAINLOOP -----------------------------------------
.main_loop:
  exit_mainloop.b = False

  While NOT exit_mainloop
    ped\LabelListChanged = False
    sourceWindow\redrawFlag = False

    ;log_Print{"### handlePedevents"}
    Gosub handlePedEvents
    ;log_Print{"### handlpepedevents end"}

    ; --- check if an exe is running and revert the entered key ---
    If Peek.b(?comByte_RunningFlag)
      If ped\ptrCurrentSourceData\KeyBeforeReturn
        log_Print{"as an exe is running, revert the entered key"}
        PED_RedrawSource{}
        ped\ptrCurrentSourceData\KeyBeforeReturn = 0
      EndIf
    EndIf

    If ped\ptrCurrentSourceData\KeyBeforeReturn
      ;log_Print{"** parse the line after event, lastkey = " + Hexw$(ped\ptrCurrentSourceData\KeyBeforeReturn)}

      ; --- get address of actual source line ---
      sourceWindow\lastEditedLine = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
      ped\ptrCurrentSourceData\SourceChanged = $FFFF

      ; --- format source line and get new column position ---
      lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
      PED_PreparseTextLine{lineaddr}
      
      ; -- parse the current line
      newline$ = Peeks$(lineaddr,#MAX_Columns)
      newline$ = PED_ParseText{newline$}

      newline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))
      newline$ = StripTrail$(newline$,@" ")
      ;log_Print{"len: " + Str$(FLen(newline$))}
      *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
      PED_ReplaceCurrentSourceLine{*newLine}

      ; --- draw block mark if existing
      !PED_CursorOff      
  ;    SF comByte_StateBlockMark
  ;    TST.l comLong_BlockEndY
  ;    BMI.w exit_updateblock
  ;      MOVEM.l D0-D3/A0-A2,-(A7)
  ;      MOVE.l comLong_DisplayLine,D1 : ADD.l comLong_DisplayLineOffset,D1 
  ;      CMP.l comLong_BlockStartY,D1
  ;      BLT.w JL_0_C66
  ;        CMP.l comLong_BlockEndY,D1
  ;        BGT.w JL_0_C66
  ;          !basic
  ;          log_Print{"update block marking"}
  ;          !asm
  ;          MOVE.w comWord_BlockStartX,D0
  ;          MOVE.l comLong_BlockStartY,D1
  ;          MOVE.w comWord_BlockEndX,D2
  ;          MOVE.l comLong_BlockEndY,D3
  ;          CMP.l D1,D3
  ;          BNE.w JL_0_C50
  ;            CMP.w D0,D2
  ;            BNE.w JL_0_C50
  ;              MOVE.w visiblecolumns,D2
  ;          JL_0_C50:
  ;          SUB.l comLong_DisplayLineOffset,D3
  ;          SUB.l comLong_DisplayLineOffset,D1
  ;          JSR _redrawBlock
  ;          ST comByte_StateBlockMark
  ;      JL_0_C66:
  ;      MOVEM.l (A7)+,D0-D3/A0-A2
  ;    exit_updateblock:

      If ped\DoTokenize Then PED_PrintCurrentSourceLine{False}
  ;
  ;      TST.b comByte_StateBlockMark
  ;      BEQ.w JL_0_CC6
  ;        MOVEM.l D0-D3/D7/A0-A2,-(A7)
  ;        MOVE.w comWord_BlockStartX,D0
  ;        MOVE.l comLong_BlockStartY,D1
  ;        MOVE.w comWord_BlockEndX,D2
  ;        MOVE.l comLong_BlockEndY,D3
  ;        CMP.l D1,D3
  ;        BNE.w JL_0_CB2
  ;          CMP.w D0,D2
  ;          BNE.w JL_0_CB2
  ;            MOVE.w visiblecolumns,D2
  ;        JL_0_CB2:
  ;        SUB.l comLong_DisplayLineOffset,D3
  ;        SUB.l comLong_DisplayLineOffset,D1
  ;        JSR _redrawBlock
  ;        MOVEM.l (A7)+,D0-D3/D7/A0-A2
  ;    JL_0_CC6:
    EndIf

    ; -- check if an executable is running and prevent IDE from doing things
    skip_update.b = False
    If Peek.b(?comByte_RunningFlag)
      If last_vankey.b = #VANILLAKEY_UP OR last_vankey= #VANILLAKEY_DOWN OR last_menuentry.l = #MENU_SAVEAS OR last_menuentry > #MENU_CUSTOMEDIT OR exit_loop_class.b = -3 OR last_vankey = #VANILLAKEY_HELP
        Gosub check_panic
      EndIf
    EndIf
 
    If NOT skip_update
      sourceWindow\redrawFlag = False
      If exit_loop_class.b = -3 Then sourceWindow\redrawFlag = True

      ; -- call function selected in comArray_KeyTable
      ;log_Print{"***** Last_vankey = " + Hex$(last_vankey.b)}
      ;log_Print{"***** Last_Menuentry = " + Hex$(last_menuentry)}
      ;log_Print{"***** exit class:" + Str$(exit_loop_class.b)}

      If exit_eventloop.b <> 0
  ;      log_Print{"***** executing actions hold back ..."}

        Select last_vankey
        Case #VANILLAKEY_RETURN: Gosub do_VANILLAKEY_RETURN
        Case #VANILLAKEY_UP:     mqualifier.w = last_mqualifier.w : Gosub do_VANILLAKEY_UP
        Case #VANILLAKEY_DOWN:   mqualifier = last_mqualifier : Gosub do_VANILLAKEY_DOWN
        End Select

        Gosub close_popupwindow

        If exit_loop_class = -3 OR exit_loop_class= -4
          Gosub event_leftmousebutton
        EndIf

        If exit_loop_class = -2
          ; _menuitem will be set in the first menu event handler
          Gosub event_menu
        EndIf

        PED_UpdateStatusArea{#STATUS_SCROLLERS}                                                                                                                                                                                                          
 ;       log_Print{"actions end"}
      EndIf

      ; -- check for some tokens and automatically add the closing token
      ; --
      If pedconfig\auto_constructs AND NOT exit_mainloop
        If last_vankey.b = #VANILLAKEY_RETURN
          a$ = check_constructs{ped\ptrCurrentSourceData\CurrentSourceLine}
          If a$<>""
            Gosub insertstring
            Gosub insertreturn
            Gosub movecursorlinedown
          EndIf
        EndIf
      EndIf

      ; update diag_redraw on event $fffc
      If exit_loop_code.l = -4 AND NOT exit_mainloop
        Gosub diag_redraw
      EndIf

    Else
;      log_Print{"update skipped"}
    EndIf

    bottom_of_mainloop:
    If NOT exit_mainloop
      If ped\LabelListChanged Then Gosub reset_labellist
      PED_UpdateStatusArea{#STATUS_SCROLLERS}                                                                                                                                                                                                            
    EndIf
  Wend
  ;log_Print{"exiting loop..."}
Return
; ----------------------------------------- END OF MAINLOOP -------------------------------------



.check_panic:
  *exeTask.Task = FindTask_("Blitz ][ Program Proc")
  If *exeTask <> 0
    dummy.l = ask{!TRANS{"This action is not allowed while executing a program\\nShould PED do a PANIC program kill?"},!TRANS{"Ok|Cancel"},!TRANS{"Error"}}
    If dummy <> 0
      log_Print{"found running exe task [" + Hex$(*exeTask) + "], removing all windows, screen and kill task..."}

      ;-- stop multitasking
      Forbid_
      ;-- close all windows and the screen of the task
      *iBase.IntuitionBase = IntuitionBase
      log_Print{"Intuitionbase: " + Hex$(*iBase) + ", version " + Str$(*iBase\LibNode\lib_Version)}                                                                                                                                                          
      *exeScreen.Screen = 0
      *tmpScreen.Screen = *iBase\FirstScreen                                                                                                                                                                                                             
      While *tmpScreen
        log_Print{"... checking Screen: " + Hex$(*tmpScreen) + " >> " + Peek$(*tmpScreen\Title)}
        *tmpWindow.Window = *tmpScreen\FirstWindow
        While *tmpWindow
          *nextWindow.Window = *tmpWindow\NextWindow
          log_Print{"... checking Window " + Hex$(*tmpWindow) + " >> " + Peek$(*tmpWindow\Title) + " Sigtask: " +  Hex$(*tmpWindow\UserPort\mp_SigTask)}
          If *tmpWindow\UserPort\mp_SigTask = *exeTask
            log_Print{"... window belongs to task, closing it!"}
            *exeScreen = *tmpScreen
            *tmpWindow\UserPort = 0
            CloseWindow_ *tmpWindow
          EndIf
          *tmpWindow = *nextWindow
        Wend
        *tmpScreen = *tmpScreen\NextScreen
      Wend
      If *exeScreen <> 0
        log_Print{"... screen belongs to task window, closing it ..."}
        CloseScreen_ *exeScreen
      EndIf

      ;-- kill the exe task
      log_Print{"... removing task"}
      RemTask_ *exeTask

      ;-- emable multitasking
      log_Print{"... enabling multitasking"}
      Permit_

      Poke.b ?comByte_RunningFlag,0
    Else
      skip_update = True
    EndIf
  Else
    log_Print{"runningflag is set, but no running task found!"}
  EndIf
Return


; -----------------------------------------------------------------------------------------------
str_tempfilename:        Ds.b #MAX_STRINGSIZE
Even

.menu_autolayout:
  Select _menuitem.l
  Case $171 : ped\lastAutoLayout = 0
  Case $172 : ped\lastAutoLayout = 1
  Case $173 : ped\lastAutoLayout = 2
  End Select
  log_Print{"doing autolayout " + Str$(ped\lastAutoLayout)}
  AutoLayout{&wtemp,ped\lastAutoLayout}
  Gosub do_windowlayout
;  pedconfig\autolayout + 1
;  If pedconfig\autolayout > 2 Then pedconfig\autolayout = 0
Return

.menu_settings:
 Gosub set_pointer_busy
 WZ_LockAllOpenWindows{}                                                                                                                                                                                                                                 
 WZWindow WZID("WIN_SETTINGS"),?wzgui,255,-2,-2,-2,-2,WZID("WIN_SETTINGS")
 Use Window WZID("WIN_SETTINGS")

 ; make tab 0 active
 WZPrint "SET_PAGES",0

  ; init tempcolors
 For i = 0 To (#MAX_AB3Pens-1) ; relaced wrong 24 by #Max_AB3Pens -1, -1 because 0 to 23  tomsmart1
  AB3RGB_temp(i) = AB3RGB(i)
 Next i

 ;-- init gadgets
 If pedconfig\auto_format       Then WZPrint "SET_AUTO_FORMAT"        ,On
 If pedconfig\auto_constructs   Then WZPrint "SET_COMPLETE_CONSTRUCTS",On
 If pedconfig\intellisense      Then WZPrint "SET_INTELLISENSE"       ,On
 If pedconfig\correct_functions Then WZPrint "SET_CORRECT_FUNCTIONS"  ,On
 If pedconfig\smart_tokenization Then WZPrint "SET_SMART_TOKENIZATION" ,On

 If pedconfig\no_welcome        Then WZPrint "SET_WELCOME"            ,On
 If pedconfig\ask_before_quit   Then WZPrint "SET_ASKBEFOREQUIT"      ,On
 If NOT pedconfig\localization  Then WZPrint "SET_LOCALIZATION",On

 If pedconfig\onlinehelp        Then WZPrint "SET_ONLINEHELP"         ,On
 If pedconfig\highlighting      Then WZPrint "SET_HIGHLIGHTING"       ,On
 If pedconfig\bold_tokens       Then WZPrint "SET_BOLDTOKENS"         ,On
 If pedconfig\italic_remarks    Then WZPrint "SET_ITALICREMARKS"      ,On
 If pedconfig\linenumbers       Then WZPrint "SET_LINENUMBERS"        ,On : oldlinenumbers.b = pedconfig\linenumbers
 If pedconfig\remember_saved    Then WZPrint "SET_REMEMBER_SAVED"     ,On
 If pedconfig\load_last_source  Then WZPrint "SET_LAST_SOURCE"        ,On

 If pedconfig\use_pubscreen     Then WZPrint "SET_PUBSCREEN"          ,On
 If pedconfig\use_default_pubscreen Then WZPrint "SET_DEFAULTPUBSCREEN",On
 If pedconfig\use_filepattern   Then WZPrint "SET_FILEPATTERN"        ,On
 If pedconfig\auto_indent       Then WZPrint "SET_AUTO_INDENT"        ,On
 If pedconfig\autolayout        Then WZPrint "SET_AUTOLAYOUT"         ,On
 If pedconfig\no_display_beep   Then WZPrint "SET_NO_DISPLAYBEEP"     ,On

 If pedconfig\console_device <> ""    Then WZPrint "SET_CONSOLE_DEVICE"     ,&pedconfig\console_device
 If pedconfig\console_wb      =  True  Then WZPrint "SET_CONSOLE_ON_WB"      ,True
 If pedconfig\console_wait    =  True  Then WZPrint "SET_CONSOLE_WAIT"       ,True
 ;if console_dontclose = true       Then wzprint "SET_CONSOLE_

 WZPrint "SET_SORTLABELS"     ,pedconfig\sort_labels
 WZPrint "SET_CURSORSTYLE"    ,pedconfig\cursorStyle

; If NOT ped\no_scrollrate
;   WZDisable "SET_SCROLLRATE"
; Else
   WZPrint "SET_SCROLLRATE"   , pedconfig\scroll_rate
; EndIf

 WZPrint "SET_TAB_SIZE"       , pedconfig\tabSize
 WZPrint "SET_CURSORBLINKRATE", pedconfig\blinkrate
 If OSVersion = #AmigaOS4                           ; check if OS4
   WZDisable "SET_MOUSEWHEELSTEP"                   ; yes disable it becau we use the System value
 Else                                               ; no print used value.
   WZPrint "SET_MOUSEWHEELSTEP",pedconfig\wheelStep  ; add to make Mousewheelsteprate configuratable and saveable tomsmart1
 EndIf

 tsourcedir$  = pedconfig\sourceDir
 tincludedir$ = pedconfig\includeDir
 tautodocdir$ = pedconfig\autodocDir
 thelpdir$    = pedconfig\helpDir

 tutillibfile$ = pedconfig\utillibFile
 toslibfile$  = pedconfig\oslibFile
 tcslibfile$  = pedconfig\cslibFile

 WZPrint "SET_SOURCEDIR"  ,&tsourcedir$
 WZPrint "SET_INCDIR"     ,&tincludedir$
 WZPrint "SET_AUTODOCDIR" ,&tautodocdir$
 WZPrint "SET_HELPDIR"    ,&thelpdir$

 WZPrint "SET_UTILLIBS",pedconfig\useUtilLib
 WZPrint "SET_OSLIBS",pedconfig\useOsLib
 WZPrint "SET_CSLIBS",pedconfig\useCsLib

 WZPrint "SET_UTILLIBS_PATH",&tutillibfile$
 WZPrint "SET_OSLIBS_PATH"  ,&toslibfile$
 WZPrint "SET_CSLIBS_PATH"  ,&tcslibfile$

 ;-- get screen infos
 temp_id.l     = pedconfig\screen_modeID
 temp_width.w  = pedconfig\screen_Width
 temp_height.w = pedconfig\screen_Height
 temp_depth.w  = pedconfig\screen_Depth

 ;-- get screenname
 log_Print{"getting screenmodename for id: " + Str$(temp_id)}
 temp_scr$ = screen_GetModeName{temp_id}
 log_Print{"modename = " + Str$(temp_scr$)}

 ;--  check if the ID unknown then get best match
 If temp_scr$ = "unknown"
   log_Print{"screenmode unknown, searching for best match available mode..."}
   If ExecVersion < 39
     temp_id.l = 0
     log_Print{"we need OS3+ to do this!"}
   Else
     temp_id.l = screen_GetBestModeID{temp_width,temp_height,temp_depth}
     log_Print{"most matching id: " + Str$(temp_id)}
   EndIf
   temp_scr$ = screen_GetModeName{temp_id}
   log_Print{"modename = " + temp_scr$}
 EndIf

 ;-- set screenrequester initials
 screen_SetASLInitialDims{temp_id,temp_width,temp_height,temp_depth}
 WZPrint "SET_SCREENNAME",&temp_scr$

 ;-- get font infos
 newsourcefont_name$  = sourcefont_name$
 newsourcefont_size.l = sourcefont_size
 newguifont_name$     = guifont_name$
 newguifont_size.l    = guifont_size
 tempstr$             = newsourcefont_name$ + " ("+Str$(newsourcefont_size)+")"
 WZPrint "SET_SOURCEFONTNAME",&tempstr$
 tempstr2$            = guifont_name$+" ("+Str$(guifont_size)+")"
 WZPrint "SET_GUIFONTNAME",&tempstr2$
 olduse_wbfont.b      = pedconfig\use_wbfont               ; temp variables to check former stat
 olduse_wbscreen.b    = pedconfig\use_wbscreen

 If pedconfig\use_wbscreen <> 0
   WZPrint "SET_USEWB"  ,On
   WZPrint "SET_CLONEWB",Off
   WZDisable "SET_SCREENNAME"
   WZDisable "SET_SCREEN"
   For i = 0 To 3
    WZDisable "SET_SCREENCOL" + Str$(i)   ; disable Screencolors
   Next i
   usewbscreen_tmp.b = True             ; temporay variable for prefs window
 Else
   For i = 0 To 3
    WZEnable "SET_SCREENCOL" + Str$(i)    ; enable Screencolors
   Next i
   usewbscreen_tmp.b = False
 EndIf

 If pedconfig\clone_wbscreen <> 0
   WZPrint "SET_USEWB"  ,Off
   WZPrint "SET_CLONEWB",On
   WZDisable "SET_SCREENNAME"
   WZDisable "SET_SCREEN"
   usewbscreen_tmp.b = False
 EndIf

 If pedconfig\use_wbfont = True                   ;<>0
   WZPrint "SET_USEWBFONT", On
   WZDisable "SET_SOURCEFONT"
   WZDisable "SET_SOURCEFONTNAME"
   WZDisable "SET_GUIFONT"
   WZDisable "SET_GUIFONTNAME"
   usewbfont_tmp.b = True               ; temporay variable for prefs window
 Else
   WZPrint "SET_USEWBFONT", Off
   WZEnable "SET_SOURCEFONT"
   WZEnable "SET_SOURCEFONTNAME"
   usewbfont_tmp.b = False
   If usewbscreen_tmp.b = True          ; only active GuiFontsettings if we don't use WBscreen
     WZDisable "SET_GUIFONT"
     WZDisable "SET_GUIFONTNAME"
   Else
     WZEnable "SET_GUIFONTNAME"
     WZEnable "SET_GUIFONT"
   EndIf
 EndIf

 ;-- color wheel
 *cw_gad.Gadget = WZGadAddr("SET_COLORWHEEL")
 cw_open.b          = False                             ; type was .l changed to .b because function return is only .b  tomsmart
 colnum.w           = -1
 rebuild_gui.b      = False
 rebuild_sourcewindow.b = False
 rebuild_menu.b     = False

 settings_loop:
 exit_settings.b    = False
 save_settings.b    = False
 use_settings.b     = False
 reopen_settings.b  = False
 update_colors.b    = False
 SliderUsed.b       = False

 Repeat
   ev.l = WaitEvent

   If pedconfig\onlinehelp <> 0
      If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) AND (ev<>#IDCMP_GADGETHELP)  AND (ev<>#IDCMP_CHANGEWINDOW)
        WZ_HideHelp{}
      Else
        If (ev = #IDCMP_GADGETHELP) Then WZ_ShowHelp{}
      End If
   EndIf

   ;If ev<>#IDCMP_INTUITICKS AND (ev<>#IDCMP_MOUSEMOVE) Then log_Print{Hex$(ev)}

   Select ev
     Case #IDCMP_MOUSEMOVE
       If SliderUsed = True       ; check if colorslider used before
         SliderUsed = False       ; set it back
       Else
         If (WZInput("SET_PAGES") = 3) AND (cw_open = True)
           ; Get current RGB-Value in relation to the Gradient-slider
           _RGB.l = WZ_GetColorWheelRGB{}
           If _RGB <> old_RGB.l
             WZ_SetColorGradientSlider{_RGB}
             Gosub update_colorsliders    ; added to update the colorsilders to the values of the Colorwheel  tomsmart1
             old_RGB = _RGB
             update_colors.b = True
             If colnum<>-1
               AB3RGB_temp(colnum)= _RGB
               Gosub update_colorboxes
             EndIf
           EndIf
         EndIf
       EndIf

     Case #IDCMP_VANILLAKEY
       Select EventCode
         Case #VANILLAKEY_ESC : exit_settings = True
       End Select

     Case #IDCMP_REFRESHWINDOW
       Gosub update_colorwheel
       Gosub update_colorboxes

     Case #IDCMP_CLOSEWINDOW
       exit_settings = True

     Case #IDCMP_IDCMPUPDATE
       ; check the colorgadgets
       ;log_Print{"event: IDCMPUPDATE"}
       ;log_Print{"eventwindow: " + Str$(EventWindow)}
       ;log_Print{"gadid: " + Str$(WZGadHit)}
       ;log_Print{"gadname: " + Str$(WZGadName)}

       If Left$(WZGadName,9) = "SET_COLOR"
         colnum = Vallong(Replace$(WZGadName,"SET_COLOR",""))
         update_colors = True
         Gosub update_colorboxes
         If (ColorWheelError = False)
           WZ_SetColorWheelRGB{AB3RGB_temp(colnum)}
         EndIf
         _RGB = AB3RGB_temp(colnum) : old_RGB = _RGB       ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
         Gosub update_colorsliders  ; added to set the colorsilders to the select color  tomsmart1
       Else
         If Left$(WZGadName,13) = "SET_SCREENCOL"
           colnum.w = Vallong(Replace$(WZGadName,"SET_SCREENCOL","")) + 20
           update_colors = True
           rebuild_gui   = True
           Gosub update_colorboxes
           If (ColorWheelError = False)
             WZ_SetColorWheelRGB{AB3RGB_temp(colnum)}
           EndIf
            _RGB = AB3RGB_temp(colnum) : old_RGB = _RGB    ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
           Gosub update_colorsliders ; added to set the colorsilders to the select color  tomsmart1
         EndIf
       EndIf
       ;log_Print{"check other gadget..."}
       ;-- check all other gadgets
       Select WZGadName

         Case "SET_PAGES"
           If WZInput("SET_PAGES") = 3
             If (ExecVersion > 38)
               Gosub update_colorwheel
               Gosub update_colorboxes
             Else
              error{"Color settings are not available with Workbench <V3.0."}
              WZPrint "SET_PAGES",0
             EndIf
           EndIf
         ; begin check new Gadgets of color page, tempstorage, sliders and integers  tomsmart1
         Case "COPYTOTEMP"        ; copy used color to tempstorage
           AB3RGB_copytemp = _RGB
           Gosub update_colorboxes

         Case "COPYTEMPTO"        ; used color of tempstorage
           _RGB = AB3RGB_copytemp
           Gosub set_color_slider_wheel_boxes

         Case "REDSLIDER"
           RedSlider.l = WZInput
           _RGB = (_RGB & $FF00FFFF) + (RedSlider LSL 16)
           Gosub set_color_slider_wheel_boxes
           SliderUsed = True

         Case "GREENSLIDER"
           GreenSlider.l = WZInput
           _RGB = (_RGB & $FFFF00FF) + (GreenSlider LSL 8)
           Gosub set_color_slider_wheel_boxes
           SliderUsed = True

         Case "BLUESLIDER"
           BlueSlider.l = WZInput
           _RGB = (_RGB & $FFFFFF00) + BlueSlider
           Gosub set_color_slider_wheel_boxes
           SliderUsed = True

         Case "REDIN"
           RedSlider = WZInput
           _RGB = (_RGB & $FF00FFFF) + (RedSlider LSL 16)
           Gosub set_color_slider_wheel_boxes

         Case "GREENIN"
           GreenSlider = WZInput
           _RGB = (_RGB & $FFFF00FF) + (GreenSlider LSL 8)
           Gosub set_color_slider_wheel_boxes

         Case "BLUEIN"
           BlueSlider = WZInput
           _RGB = (_RGB & $FFFFFF00) + BlueSlider
           Gosub set_color_slider_wheel_boxes
         ; end new gadgets of colors page

         Case "SET_SOURCEDIR"
           tsourcedir$ = WZInputstr
           WZPrint "SET_SOURCEDIR",&tsourcedir$

         Case "BUTTON_SOURCEDIR"
           aslfr_SetRequesterTitle {0,!TRANS{ "Please select source directory:"},"",""}
           aslfr_SetPath{0,tsourcedir$,"",""}
           If aslfr_Request{0,False,False,True,sourceWindow\pedScreen}
             tsourcedir$ = aslfr_GetNextFile{}
             WZPrint "SET_SOURCEDIR",&tsourcedir$
           EndIf

         Case "SET_INCDIR"
           tincludedir$ = WZInputstr
           WZPrint "SET_INCDIR",&tincludedir$

         Case "BUTTON_INCDIR"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select includes directory:"},"",""}
           aslfr_SetPath{0,tincludedir$,"",""}
           If aslfr_Request{0,False,False,True,sourceWindow\pedScreen}
             tincludedir$ = aslfr_GetNextFile{}
             WZPrint "SET_INCDIR",&tincludedir$
           EndIf

         Case "SET_HELPDIR"
           thelpdir$ = WZInputstr
           WZPrint "SET_HELPDIR",&thelpdir$

         Case "BUTTON_HELPDIR"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select help directory:"},"",""}
           aslfr_SetPath{0,thelpdir$,"",""}
           If aslfr_Request{0,False,False,True,sourceWindow\pedScreen}
             thelpdir$ = aslfr_GetNextFile{}
             WZPrint "SET_HELPDIR",&thelpdir$
           EndIf

         Case "SET_AUTODOCDIR"
           tautodocdir$ = WZInputstr
           WZPrint "SET_AUTODOCDIR",&tautodocdir$

         Case "BUTTON_AUTODOCDIR"
           aslfr_SetRequesterTitle {0,!TRANS{ "Please select AutoDocs directory:"},"",""}
           aslfr_SetPath{0,tautodocdir$,"",""}
           If aslfr_Request{0,False,False,True,sourceWindow\pedScreen}
             tautodocdir$ = aslfr_GetNextFile{}
             WZPrint "SET_AUTODOCDIR",&tautodocdir$
           EndIf

         Case "BUTTON_UTILLIBS"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select UtilLibs file:"},"",""}
           aslfr_SetPath{0,dos_PathPart{tutillibfile$},dos_FilePart{tutillibfile$},"#?"}
           If aslfr_Request{0,False,False,False,sourceWindow\pedScreen}
             tutillibfile$ = aslfr_GetNextFile{}
             WZPrint "SET_UTILLIBS_PATH",&tutillibfile$
           EndIf

         Case "BUTTON_OSLIBS"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select OsLibs file:"},"",""}
           aslfr_SetPath{0,dos_PathPart{toslibfile$},dos_FilePart{toslibfile$},"#?"}
           If aslfr_Request{0,False,False,False,sourceWindow\pedScreen}
             toslibfile$ = aslfr_GetNextFile{}
             WZPrint "SET_OSLIBS_PATH",&toslibfile$
           EndIf

         Case "BUTTON_CSLIBS"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select CsLibs file:"},"",""}
           aslfr_SetPath{0,dos_PathPart{tcslibfile$},dos_FilePart{toslibfile$},"#?"}
           If aslfr_Request{0,False,False,False,sourceWindow\pedScreen}
             toslibfile$ = aslfr_GetNextFile{}
             WZPrint "SET_CSLIBS_PATH",&tcslibfile$
           EndIf

         Case "SET_PUBSCREEN"
           If WZInput = 0
             WZPrint "SET_DEFAULTPUBSCREEN",Off : WZDisable "SET_DEFAULTPUBSCREEN"
           Else
             WZEnable "SET_DEFAULTPUBSCREEN"
           EndIf
           rebuild_gui = True

         Case "SET_DEFAULTPUBSCREEN"
           rebuild_gui = True

         Case "SET_REMEMBER_SAVED"
           rebuild_menu = True

         Case "SET_CLONEWB"
           If WZInput
             WZDisable "SET_SCREENNAME"
             WZDisable "SET_SCREEN"
             WZPrint   "SET_USEWB",Off
             usewbscreen_tmp.b = False
             If usewbfont_tmp.b = False     ;only actived GUIfontsetting if we don't use WBFonts
               WZEnable "SET_GUIFONTNAME"
               WZEnable "SET_GUIFONT"
             EndIf
           Else
             WZEnable "SET_SCREENNAME"
             WZEnable "SET_SCREEN"
           EndIf
           rebuild_gui = True

         Case "SET_USEWB"
           If WZInput
             For i = 0 To 3
              WZDisable "SET_SCREENCOL"+Str$(i)
             Next i
             WZDisable "SET_SCREENNAME"
             WZDisable "SET_SCREEN"
             WZPrint   "SET_CLONEWB",Off
             usewbscreen_tmp.b = True       ; deactived GUIFontsettings we use WBScreen
             WZDisable "SET_GUIFONT"
             WZDisable "SET_GUIFONTNAME"
           Else
             For i = 0 To 3
              WZEnable "SET_SCREENCOL"+Str$(i)
             Next i
             WZEnable "SET_SCREENNAME"
             WZEnable "SET_SCREEN"
             usewbscreen_tmp.b = False
               If usewbfont_tmp.b = False    ;only actived GUIfontsetting if we don't use WBFonts
                 WZEnable "SET_GUIFONTNAME"
                 WZEnable "SET_GUIFONT"
             EndIf
           EndIf
           rebuild_gui = True

         Case "SET_SCREEN"
           aslsm_SetRequesterTitle {!TRANS{"Please select screenmode:"},"",""} ;!TRANS{"Ok"},!TRANS{"Cancel"}}  ; use system default  tomsmart1
           aslsm_SetMinDims{640,480,2}
           If aslsm_Request{}
              temp_id.l     = screen_GetASLModeID{}
              temp_width.w  = screen_GetASLWidth{}
              temp_height.w = screen_GetASLHeight{}
              temp_depth.w  = screen_GetASLDepth{}
              temp_scr$     = screen_GetASLModeName{}
              log_Print{"selected screen depth: " + Str$(temp_depth),#log_debug}
              WZPrint "SET_SCREENNAME",&temp_scr$
              log_Print{"written screenname... " + temp_scr$}
              rebuild_gui   = True
           EndIf

         Case "SET_GUIFONT"
           aslfo_SetRequesterTitle {!TRANS{"Please select GUI-Font:"},"",""} ;!TRANS{"Ok"},!TRANS{"Cancel"}}  ; use system default  tomsmart1
           aslfo_SetInitialFont{newguifont_name$,newguifont_size}
           If aslfo_Request{True}
             newguifont_name$      = aslfo_GetFontName{}
             newguifont_size   = aslfo_GetFontSize{}
             ;newguifontstyle = *finfo2\ta_Style
             tempstr2$= newguifont_name$ + " ("+Str$(newguifont_size)+")"
             WZPrint "SET_GUIFONTNAME",&tempstr2$
           EndIf

         Case "SET_USEWBFONT"
           If WZInput
             usewbfont_tmp.b = True
             WZDisable "SET_GUIFONT"
             WZDisable "SET_GUIFONTNAME"
             WZDisable "SET_SOURCEFONT"
             WZDisable "SET_SOURCEFONTNAME"
           Else
             usewbfont_tmp.b = False
             WZEnable "SET_SOURCEFONTNAME"
             WZEnable "SET_SOURCEFONT"
             If usewbscreen_tmp.b = False     ; make GUIfont selectable only if we don't use wbscreen
               WZEnable "SET_GUIFONT"
               WZEnable "SET_GUIFONTNAME"
             EndIf
           EndIf
           rebuild_gui = True

         Case "SET_SOURCEFONT"
           aslfo_SetRequesterTitle {!TRANS{"Please select Source-Font:"},"",""} ;!TRANS{"Ok"},!TRANS{"Cancel"}}  ; use system default tomsmart1
           aslfo_SetInitialFont{newsourcefont_name$,newsourcefont_size}
           If aslfo_Request{False}
             newsourcefont_name$     = aslfo_GetFontName{}
             newsourcefont_size  = aslfo_GetFontSize{}
             ;newsourcefontstyle = *finfo2\ta_Style
             tempstr$= newsourcefont_name$ + " ("+Str$(newsourcefont_size)+")"
             WZPrint "SET_SOURCEFONTNAME",&tempstr$
           EndIf


         Case "SET_F4"
           savewinpref{0} : Gosub write_newprefs

         Case "SET_F5"
           savewinpref{1} : Gosub write_newprefs

         Case "SET_F6"
           savewinpref{2} : Gosub write_newprefs


         ; UNTERSTE BUTTON-ZEILE
         Case "SET_SAVE"
           save_settings   = True
           use_settings    = True
           exit_settings   = True

         Case "SET_USEEXIT"
           use_settings    = True
           exit_settings   = True

         Case "SET_USE"
           use_settings    = True
           exit_settings   = True
           reopen_settings = True

         Case "SET_CANCEL"
           use_settings    = False
           reopen_settings = False
           exit_settings   = True

       End Select

      ;log_Print{"end_of_event"}
   End Select
 Until exit_settings = True

 ;log_Print{"settings loop finished."}
 If use_settings = True
   log_Print{"storing all settings"}
   WZ_LockWindow{"WIN_SETTINGS"}

   pedconfig\auto_indent =       -WZInput("SET_AUTO_INDENT")
   pedconfig\auto_format =       -WZInput("SET_AUTO_FORMAT")
   pedconfig\auto_constructs =   -WZInput("SET_COMPLETE_CONSTRUCTS")
   pedconfig\intellisense =      -WZInput("SET_INTELLISENSE")
   pedconfig\correct_functions=  -WZInput("SET_CORRECT_FUNCTIONS")
   pedconfig\smart_tokenization= -WZInput("SET_SMART_TOKENIZATION")
   pedconfig\no_welcome =        -WZInput("SET_WELCOME")
   pedconfig\ask_before_quit =   -WZInput("SET_ASKBEFOREQUIT")
   pedconfig\localization =      NOT(-WZInput("SET_LOCALIZATION"))
   pedconfig\onlinehelp =        -WZInput("SET_ONLINEHELP")
   pedconfig\bold_tokens =       -WZInput("SET_BOLDTOKENS")
   pedconfig\highlighting =      -WZInput("SET_HIGHLIGHTING")
   pedconfig\italic_remarks =    -WZInput("SET_ITALICREMARKS")
   pedconfig\linenumbers =       -WZInput("SET_LINENUMBERS")
   pedconfig\remember_saved =    -WZInput("SET_REMEMBER_SAVED")
   pedconfig\load_last_source =  -WZInput("SET_LAST_SOURCE")
   pedconfig\use_pubscreen    =  -WZInput("SET_PUBSCREEN")
   pedconfig\use_default_pubscreen = -WZInput("SET_DEFAULTPUBSCREEN")
   pedconfig\use_filepattern  =  -WZInput("SET_FILEPATTERN")
   pedconfig\use_wbscreen =      -WZInput("SET_USEWB")
   pedconfig\clone_wbscreen =    -WZInput("SET_CLONEWB")
   pedconfig\use_wbfont =        -WZInput("SET_USEWBFONT")
   pedconfig\no_display_beep =   -WZInput("SET_NO_DISPLAYBEEP")
   pedconfig\console_device  =    WZGetString("SET_CONSOLE_DEVICE")
   ;console_keepopen = WZInput("SET_CONSOLE_KEEPOPEN")
   pedconfig\console_wb       =  -WZInput("SET_CONSOLE_ON_WB")
   pedconfig\console_wait     =  -WZInput("SET_CONSOLE_WAIT")
   pedconfig\sort_labels =       -WZInput("SET_SORTLABELS")
   pedconfig\scroll_rate =        WZInput("SET_SCROLLRATE")
   pedconfig\cursorStyle =        WZInput("SET_CURSORSTYLE")
   If pedconfig\scroll_rate = 0 Then ped\no_scrollrate = True Else vvblank_SetFreq{pedconfig\scroll_rate}

   pedconfig\tabSize =  WZInput("SET_TAB_SIZE")
   pedconfig\blinkrate =  WZInput("SET_CURSORBLINKRATE")
   pedconfig\wheelStep =  WZInput("SET_MOUSEWHEELSTEP")     ; added to make Mousewheelsteprate changeable, no special OS4 handling nessacary because the System settings are used by any event  tomsmart1
   pedconfig\autolayout= -WZInput("SET_AUTOLAYOUT")

   ; store directories
   pedconfig\sourceDir  = tsourcedir$
   pedconfig\includeDir = tincludedir$
   pedconfig\autodocDir = tautodocdir$
   pedconfig\helpDir    = thelpdir$


   pedconfig\useUtilLib  = -WZInput("SET_UTILLIBS")
   pedconfig\useOsLib  = -WZInput("SET_OSLIBS")
   pedconfig\useCsLib  = -WZInput("SET_CSLIBS")

   pedconfig\utillibFile = tutillibfile$
   pedconfig\oslibFile  = toslibfile$
   pedconfig\cslibFile  = tcslibfile$

   If temp_id <> pedconfig\screen_modeID
     pedconfig\screen_modeID = temp_id
     pedconfig\screen_Width = temp_width
     pedconfig\screen_Height = temp_height
     pedconfig\screen_Depth = temp_depth
     rebuild_gui    = True
   EndIf

   If ( (newguifont_name$<>guifont_name$) OR (newguifont_size<>guifont_size) ) AND ( (NOT pedconfig\use_wbfont) AND (pedconfig\use_wbscreen=0) )
     guifont_name$   = newguifont_name$
     guifont_size    = newguifont_size
     guifont_style.l = newguifont_style.l
     rebuild_gui    = True
   Else
     If ( (pedconfig\use_wbfont AND (NOT olduse_wbfont) ) AND olduse_wbscreen=0 ) OR ( ( (pedconfig\use_wbscreen<>0) AND (olduse_wbscreen=0) ) AND (NOT olduse_wbfont) )
      log_Print{"setguifonttowbscreenfont"}
      Gosub SetGuiFontToWBScreenFont
      rebuild_gui = True
     EndIf
   EndIf


   ; update colors
   If update_colors = True
     For i = 0 To (#MAX_AB3Pens-1) ; relaced wrong 24 by #Max_AB3Pens -1, -1 because 0 to 23  tomsmart1
       AB3RGB(i) = AB3RGB_temp(i)
     Next i
     If rebuild_gui = False          ; update screencolors only if GUI not rebuild else we trash maybe the Wbscreencolors
       Gosub set_storedcolors
       update_colors.b = False
     EndIf
   EndIf

   If ( (newsourcefont_name$ <> sourcefont_name$) OR (newsourcefont_size <> sourcefont_size) ) AND (NOT pedconfig\use_wbfont)
     sourcefont_name$ = newsourcefont_name$
     sourcefont_size  = newsourcefont_size
     sourcefont_style.b = newsourcefont_style.b
     Gosub open_sourcefonts
     rebuild_sourcewindow = True
   EndIf

   If pedconfig\use_wbfont AND (NOT olduse_wbfont)
     ; get WBfont for Sourcefont
     sourcefont_name$ = ""     ;that open_sourcefonts get the WBfont
     Gosub open_sourcefonts
     rebuild_sourcewindow = True
   EndIf

   If oldlinenumbers <> pedconfig\linenumbers Then rebuild_sourcewindow = True

   If (rebuild_sourcewindow = True) AND (rebuild_gui = False)
     log_Print{"rebuilding the source window..."}

     Gosub set_pointer_busy
     Gosub close_sourcewindow
     Gosub open_sourcewindow
     If ped\errorCode = #PEDERROR_OPENWINDOW
       dummy.l = ask{!TRANS{"Unable to open window"},!TRANS{"Ok"},!TRANS{"Error"}}
       Pop If
       Goto exit_PED_closeall
     EndIf

     ;Gosub allocate_textbuffer   ; its done in open_sourcewindow
     Gosub set_pointer_normal
     WindowToFront_ Peek.l(Addr Window(WZID("WIN_SETTINGS")))
   Else
     log_Print{"just redraw source"}
     PED_RedrawSource{}
   EndIf

   WZ_UnlockWindow{"WIN_SETTINGS"}
 EndIf

 If reopen_settings Then Goto settings_loop

 If save_settings
   log_Print{"saving settings..."}
   WZ_LockWindow{"WIN_SETTINGS"}
   Gosub write_newprefs
   Gosub set_tooltypes
   WZ_UnlockWindow{"WIN_SETTINGS"}
   log_Print{"saving settings done"}
 EndIf

 If cw_open Then WZ_KillColorWheel{} : cw_open = False
 WZCloseWindow WZID("WIN_SETTINGS")
 FlushEvents
 WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                               
 Gosub set_pointer_normal

 If rebuild_gui
   log_Print{"rebuilding the gui..."}
   Gosub close_gui
   Gosub open_sourcefonts
   Gosub open_gui
 EndIf
 If rebuild_menu
   Gosub init_menus
 EndIf

 Gosub activatesourcewindow
Return


.update_colorboxes
   If WZInput("SET_PAGES") = 3
     WZ_LockWindow{"WIN_SETTINGS"}    ; added to prevent page switch during drawing  tomsmart1
     *winSettings.Window = Peek.l(Addr Window(WZID("WIN_SETTINGS")))
     boxpen.w = 1
     boxcolor.w = 0
     For ii.l = 1 To 12
       If ii = colnum Then boxpen = 2 Else boxpen = 1
       *gad.Gadget = WZGadAddr("SET_COLOR"+Str$(ii))
       If *gad
         boxx.w = *gad\LeftEdge + *gad\Width + 2
         boxw.w = boxx + 20
         boxy.w = *gad\TopEdge
         boxh.w = boxy + *gad\Height - 1
         boxcolor.w = screen_GetPenRGB{AB3RGB_temp(ii)}
         SetAPen_ *winSettings\RPort,boxcolor : RectFill_ *winSettings\RPort,boxx+1,boxy+1,boxw-1,boxh-1
         SetAPen_ *winSettings\RPort,boxpen
         Move_ *winSettings\RPort,boxx,boxy
         Draw_ *winSettings\RPort,boxw,boxy
         Draw_ *winSettings\RPort,boxw,boxh
         Draw_ *winSettings\RPort,boxx,boxh
         Draw_ *winSettings\RPort,boxx,boxy
       EndIf
     Next ii

     For ii = 0 To 3
       If 20+ii = colnum Then boxpen = 2 Else boxpen = 1
       *gad.Gadget = WZGadAddr("SET_SCREENCOL"+Str$(ii))
       If *gad
         boxx = *gad\LeftEdge + *gad\Width + 2
         boxw = boxx + 20
         boxy = *gad\TopEdge
         boxh = boxy + *gad\Height - 1
         SetAPen_ *winSettings\RPort,screen_GetPenRGB{AB3RGB_temp(20+ii)}
         RectFill_ *winSettings\RPort,boxx+1,boxy+1,boxw-1,boxh-1
         SetAPen_ *winSettings\RPort,boxpen
         Move_ *winSettings\RPort,boxx,boxy
         Draw_ *winSettings\RPort,boxw,boxy
         Draw_ *winSettings\RPort,boxw,boxh
         Draw_ *winSettings\RPort,boxx,boxh
         Draw_ *winSettings\RPort,boxx,boxy
       EndIf
     Next ii

     ; begin temporaycopy color
      *gad.Gadget = WZGadAddr("COPYTOTEMP")
       If *gad
         boxx = *gad\LeftEdge + *gad\Width + 2
         boxw = boxx + 16
         boxy = *gad\TopEdge
         boxh = boxy + *gad\Height
         SetAPen_ *winSettings\RPort,screen_GetPenRGB{AB3RGB_copytemp}
         RectFill_ *winSettings\RPort,boxx+1,boxy+1,boxw-1,boxh-1
         SetAPen_ *winSettings\RPort,boxpen
         Move_ *winSettings\RPort,boxx,boxy
         Draw_ *winSettings\RPort,boxw,boxy
         Draw_ *winSettings\RPort,boxw,boxh
         Draw_ *winSettings\RPort,boxx,boxh
         Draw_ *winSettings\RPort,boxx,boxy
       EndIf
     WZ_UnlockWindow{"WIN_SETTINGS"}  ; added to prevent page switch during drawing  tomsmart1
   EndIf
Return


.update_colorwheel:
  If (WZInput("SET_PAGES") = 3) AND (ColorWheelError = False)
    If cw_open
      WZ_KillColorWheel{}
      RefreshWindowFrame_ Peek.l(Addr Window(WZID("WIN_SETTINGS")))
      cw_open = False
    EndIf

    WZ_LockWindow{"WIN_SETTINGS"}  ; added to prevent page switch during drawing  tomsmart1
    cw_open = WZ_DrawColorWheel{*cw_gad\LeftEdge,*cw_gad\TopEdge,*cw_gad\Width,*cw_gad\Height,False}; added flag to not show the error message of the include  tomsmart1
    If cw_open
      If colnum <> -1
        WZ_SetColorWheelRGB{AB3RGB_temp(colnum)} : _RGB = AB3RGB_temp(colnum) : old_RGB = _RGB    ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
      Else
        WZ_SetColorWheelRGB{$FFFFFF}             : _RGB = $FFFFFF : old_RGB = _RGB                ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
        Gosub update_colorsliders  ; added to set the silder to the default settings  tomsmart1
      EndIf
    Else
      ColorWheelError = True
      error{!TRANS{"error creating colorwheel"} }   ; convert to a normal error message  tomsmart1
    EndIf
    WZ_UnlockWindow{"WIN_SETTINGS"}  ; added to prevent page switch during drawing  tomsmart1
  Else     ; not page 2
    If cw_open
      WZ_KillColorWheel{}
      cw_open = False
    EndIf
  EndIf
Return


.update_colorsliders:     ; added to set the colorsliders position and value of the colorintger gadgets  tomsmart1
  RedSlider   = ( (_RGB & $00FF0000) LSR 16)
  GreenSlider = ( (_RGB & $0000FF00) LSR 8)
  BlueSlider  =   (_RGB & $000000FF)
  ;log_Print{Hex$(_RGB) + "  " + Hex$(RedSlider) + "  " + Hex$(GreenSlider) + "  " + Hex$(BlueSlider)}
  WZPrint "REDSLIDER"  , RedSlider
  WZPrint "GREENSLIDER", GreenSlider
  WZPrint "BLUESLIDER" , BlueSlider
  WZPrint "REDIN"      , RedSlider
  WZPrint "GREENIN"    , GreenSlider
  WZPrint "BLUEIN"     , BlueSlider
Return


.set_color_slider_wheel_boxes:  ;added to set the color -wheel, -boxes, -slider and -intger gadgets for a colorslider or intger gadget change  tomsmart1
  old_RGB = _RGB
  If (ColorWheelError = False)
    WZ_SetColorWheelRGB{_RGB}     ; update the ColorWheel and GradientSlider
  EndIf
  Gosub update_colorsliders     ; update the sliders and the intger gadgets
  If colnum <> -1               ; check if a AB3color is set to change
    update_colors = True
    AB3RGB_temp(colnum) = _RGB  ; set it to the color we set by the slider or get intger gadget
    Gosub update_colorboxes     ; redraw the boxes
  EndIf
Return


.set_tooltypes:
   If disk_object
      log_Print{"saving tooltypes"}
       mypath$ = dos_GetProgDir{""}

       ; -- save colors
       dos_SetToolString{"FUNCTIONCOLOR"   ,"$"+Hex$(AB3RGB(#AB3_cfunction))}
       dos_SetToolString{"MACROCOLOR"      ,"$"+Hex$(AB3RGB(#AB3_cmacro))}
       dos_SetToolString{"STRINGCOLOR"     ,"$"+Hex$(AB3RGB(#AB3_cstring))}
       dos_SetToolString{"NEWTYPECOLOR"    ,"$"+Hex$(AB3RGB(#AB3_cnewtype))}
       dos_SetToolString{"CONSTANTCOLOR"   ,"$"+Hex$(AB3RGB(#AB3_cconstant))}
       dos_SetToolString{"REMARKFORG"      ,"$"+Hex$(AB3RGB(#AB3_cremarkforeground))}
       dos_SetToolString{"REMARKBACKG"     ,"$"+Hex$(AB3RGB(#AB3_cremarkbackground))}
       dos_SetToolString{"TOKENCOLOR"      ,"$"+Hex$(AB3RGB(#AB3_ctoken))}
       dos_SetToolString{"TOKENBACKPEN"    ,"$"+Hex$(AB3RGB(#AB3_ctokenbackground))}
       dos_SetToolString{"BACKGROUNDCOLOR" ,"$"+Hex$(AB3RGB(#AB3_cbackground))}
       dos_SetToolString{"OTHERCOLOR"      ,"$"+Hex$(AB3RGB(#AB3_cother))}
       dos_SetToolString{"CLASSICCOLOR"    ,"$"+Hex$(AB3RGB(#AB3_cclassic))}
       dos_SetToolString{"screenbackcolor" ,"$"+Hex$(AB3RGB(#AB3_screenback))}
       dos_SetToolString{"screentextcolor" ,"$"+Hex$(AB3RGB(#AB3_screentext))}
       dos_SetToolString{"screenshinecolor","$"+Hex$(AB3RGB(#AB3_screenshine))}
       dos_SetToolString{"screenfillcolor" ,"$"+Hex$(AB3RGB(#AB3_screenfill))}

       ; save Screen settings
       dos_SetToolSwitch{"USE_WBSCREEN"    ,pedconfig\use_wbscreen}  ;-WZInput("SET_USEWB")}
       dos_SetToolSwitch{"CLONE_WBSCREEN"  ,pedconfig\clone_wbscreen};-WZInput("SET_CLONEWB")}
       dos_SetToolSwitch{"DEFAULTPUBSCREEN",pedconfig\use_default_pubscreen};-WZInput("SET_DEFAULTPUBSCREEN")}
       dos_SetToolSwitch{"PUBSCREEN"       ,pedconfig\use_pubscreen} ;-WZInput("SET_PUBSCREEN")}

       ;save ownscreen parameters
       dos_SetToolValue{"SCREEN_ID"        ,pedconfig\screen_modeID}
       dos_SetToolValue{"SCREEN_WIDTH"     ,pedconfig\screen_Width}
       dos_SetToolValue{"SCREEN_HEIGHT"    ,pedconfig\screen_Height}
       dos_SetToolValue{"SCREEN_DEPTH"     ,pedconfig\screen_Depth}

       ; save Font settings
       dos_SetToolSwitch{"USE_WBFONT"      ,pedconfig\use_wbfont} ;-WZInput("SET_USEWBFONT")}
       If pedconfig\use_wbfont = False
         If newsourcefont_name$ <>""
           dos_SetToolSwitch{"SOURCEFONT"  ,True}       ; actived tooltype maybe it was deactived
           dos_SetToolString{"SOURCEFONT"  ,newsourcefont_name$ + "," + Str$(newsourcefont_size)}
         Else
           dos_SetToolSwitch{"SOURCEFONT"  ,False}      ; deactived Sourcefont Tooltypes no font is set
         EndIf
         If newguifont_name$ <>"" AND pedconfig\use_wbscreen = False ;WZInput("SET_USEWB")=False   ;
           dos_SetToolSwitch{"GUIFONT"     ,True}       ; actived tooltype maybe it was deactived
           dos_SetToolString{"GUIFONT"     ,newguifont_name$ + "," + Str$(newguifont_size)}
         Else
           dos_SetToolSwitch{"GUIFONT"     ,False}      ; deactived GUIfont Tooltypes no font is set or we use the WBscreen
         EndIf
       Else
         dos_SetToolSwitch{"GUIFONT"       ,False}      ; deactived GUIfont Tooltypes we use WBfonts
         dos_SetToolSwitch{"SOURCEFONT"    ,False}      ; deactived Sourcefont Tooltypes we use WBfonts
       EndIf

       ; save other settings
       dos_SetToolSwitch{"ASKBEFOREQUIT"        , pedconfig\ask_before_quit};-WZInput("SET_ASKBEFOREQUIT")}
       dos_SetToolSwitch{"DISABLE_WELCOME"      , pedconfig\no_welcome}     ;-WZInput("SET_WELCOME")}
       dos_SetToolSwitch{"DISABLE_DISPLAYBEEP"  , pedconfig\no_display_beep};-WZInput("SET_NO_DISPLAYBEEP")}
       dos_SetToolSwitch{"DISABLE_LOCALIZATION" , NOT pedconfig\localization}
       dos_SetToolSwitch{"AUTO_FORMAT"          , pedconfig\auto_format}    ;-WZInput("SET_AUTO_FORMAT")}
       dos_SetToolSwitch{"AUTO_INDENT"          , pedconfig\auto_indent}    ;-WZInput("SET_AUTO_INDENT")}     ; add because was not saved before  tomsmart1
       dos_SetToolSwitch{"AUTO_CONSTRUCTS"      , pedconfig\auto_constructs};-WZInput("SET_COMPLETE_CONSTRUCTS")}
       dos_SetToolSwitch{"USE_INTELLISENSE"     , pedconfig\intellisense}   ;-WZInput("SET_INTELLISENSE")}
       dos_SetToolSwitch{"CORRECT_FUNCTIONS"    , pedconfig\correct_functions};-WZInput("SET_CORRECT_FUNCTIONS")}
       dos_SetToolSwitch{"SMART_TOKENIZATION"   , pedconfig\smart_tokenization} ;-WZInput("SET_SMART_TOKENIZATION")}
       dos_SetToolSwitch{"DISABLE_HIGHLIGHTING" , NOT pedconfig\highlighting}
       dos_SetToolSwitch{"BOLD_TOKENS"          , pedconfig\bold_tokens}
       dos_SetToolSwitch{"ITALIC_REMARKS"       , pedconfig\italic_remarks}
       dos_SetToolSwitch{"LINENUMBERS"          , pedconfig\linenumbers}
       dos_SetToolSwitch{"ONLINEHELP"           , pedconfig\onlinehelp}    ;-WZInput("SET_ONLINEHELP")}

       dos_SetToolSwitch{"AUTOLAYOUT"           , pedconfig\autolayout}
       dos_SetToolSwitch{"USE_FILEPATTERN"      , pedconfig\use_filepattern}
       dos_SetToolSwitch{"SOURCE_HISTORY"       , pedconfig\remember_saved};-WZInput("SET_REMEMBER_SAVED")}
       dos_SetToolSwitch{"LOAD_LAST_SOURCE"     , pedconfig\load_last_source};-WZInput("SET_LAST_SOURCE")}
       dos_SetToolSwitch{"SORT_LABELS"          , pedconfig\sort_labels}
       dos_SetToolString{"CURSORSTYLE"          , cursorStyleGetString{pedconfig\cursorStyle}}
       dos_SetToolValue{"SCROLLRATE"            , pedconfig\scroll_rate}
       If OSVersion <> #AmigaOS4                                        ; check if not OS4 than save the value, because on OS4 the System value is used  tomsmart1
         dos_SetToolValue{"MOUSEWHEELSTEP"      , pedconfig\wheelStep}   ; added to make Mousewheelsteprate configuatable and saveable  tomsmart1
       EndIf

       ; save console settings
       dos_SetToolString{"CON_DEVICE" ,pedconfig\console_device}
       dos_SetToolSwitch{"CON_ONWB"   ,pedconfig\console_wb}
       dos_SetToolSwitch{"CON_WAIT"   ,pedconfig\console_wait}

       dos_SetToolValue{"CURSORBLINKRATE",pedconfig\blinkrate}
       dos_SetToolValue{"TABSIZE",pedconfig\tabSize}

       ; save pathes
       dos_SetToolString{"HELPDIR"    ,pedconfig\helpDir}
       dos_SetToolString{"AUTODOCDIR" ,pedconfig\autodocDir}
       dos_SetToolString{"SOURCEDIR"  ,pedconfig\sourceDir}
       dos_SetToolString{"INCLUDEDIR" ,pedconfig\includeDir}

       dos_SetToolString{"UTILLIBS"   ,pedconfig\utillibFile} : dos_SetToolState{"UTILLIBS",pedconfig\useUtilLib}
       dos_SetToolString{"OSLIBS"     ,pedconfig\oslibFile} : dos_SetToolState{"OSLIBS",pedconfig\useOsLib}
       dos_SetToolString{"CSLIBS"     ,pedconfig\cslibFile} : dos_SetToolState{"CSLIBS",pedconfig\useCsLib}

       ;update AND write Icon
       dos_FlushToolTypes{}

   EndIf
Return

.menu_iconify:
  If ExecVersion >= 36
    Gosub close_gui
    *appMenuItem.l = AddAppMenuItemA_(0,0,&ped\defaultPubscreenName,*WBMsgPort,Tags(#TAG_DONE,#TAG_END))
    log_Print{"generated appmenuitem, waiting for uniconify command..."}
    WaitPort_ *WBMsgPort
    *msg.Message = GetMsg_(*WBMsgPort)
    ReplyMsg_ *msg
    log_Print{"... got message, reopening."}
    RemoveAppMenuItem_ *appMenuItem
    MOVEA.l comPtr_CurrentSourceLine,A2
    Gosub open_gui
  EndIf
Return

.taglist_pointer_normal:
  Dc.b $80,$00,$00,$97               ; #WA_Pointer
  Ds.l 2

.set_pointer_normal:
  USEPATH sourceWindow
  If \win
    If (ExecVersion > 38) Then SetWindowPointerA_ \win, Tags(#WA_Pointer,Null,#TAG_END,0)
    If (ped\menuStrip <> 0)
      ResetMenuStrip_ \win,ped\menuStrip
      ; set it back to the flags that are used by open the window  tomsmart1
      ModifyIDCMP_ \win, SourceWindowIDCMPFlags.l
    EndIf
  EndIf
Return

.taglist_pointer_busy:
  Dc.b $80,$00,$00,$98               ; #WA_BusyPointer.
  Dc.b $FF,$FF,$FF,$FF
  Ds.l 1

.set_pointer_busy:
  USEPATH sourceWindow
  If \win
    If (ExecVersion > 38) Then SetWindowPointerA_ \win, ?taglist_pointer_busy ;Tags(#WA_BusyPointer,$FFFFffff,#TAG_END,0)
    ; remove menustrip to prevent use of menu
    ClearMenuStrip_ \win
    ; only allow following flags to lock the sourcewin
    ModifyIDCMP_ \win, #IDCMP_NEWSIZE|#IDCMP_REFRESHWINDOW|#WFLG_REPORTMOUSE
  EndIf
Return


.write_infofile:
  tmp_string.s = ped\sourceFileComplete
  If Exists(tmp_string + ped\extention_info)
    do_info.b = False
  Else
    do_info = True
  EndIf

  If do_info
    *ni.DiskObject = GetDiskObject_(Null)
    If *ni
      log_Print{"writing info-file for [" + ped\sourceFileComplete + "]"}
      iTT.s = "Blitz3:AmiBlitz3"
      iImg.Image\LeftEdge = 0,0,46,23,2,?iconImageData,3,0,0
      *ni\do_Type = #WBPROJECT
      *ni\do_Gadget\NextGadget = 0,0,0,46,24,5,3,1,iImg,0,0,0,0,0,0
      *ni\do_DefaultTool = &iTT
      *ni\do_CurrentX = #NO_ICON_POSITION ; 92
      *ni\do_CurrentY = #NO_ICON_POSITION ; 14

      If PutDiskObject_(&tmp_string, *ni)
      Else
        log_Print{"Could not write DiskObject, error " + Str$(IoErr_),#log_error}
      EndIf                                                                                                                                                                                                                                                
    Else                                                                                                                                                                                                                                                   
      log_Print{"Could not init Diskobject structure",#log_error}
    EndIf
  EndIf
Return

iconImageData:
  Dc.b $FF,$FF
  Dc.b $FF,$FF,$FF,$FC
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $80,$FF,$FF,$FF
  Dc.b $7C,$00,$81,$80
  Dc.b $00,$00,$06,$00
  Dc.b $81,$80,$00,$00
  Dc.b $06,$00,$81,$9A
  Dc.b $DE,$D5,$86,$00
  Dc.b $81,$97,$5B,$7D
  Dc.b $86,$00,$81,$82
  Dc.b $56,$E9,$86,$00
  Dc.b $81,$81,$AD,$5D
  Dc.b $86,$00,$81,$9F
  Dc.b $FF,$FF,$86,$00
  Dc.b $81,$80,$00,$00
  Dc.b $06,$00,$81,$FF
  Dc.b $FF,$FF,$FE,$00
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$7F
  Dc.b $FF,$FF,$F8,$00
  Dc.b $80,$80,$00,$00
  Dc.b $04,$00,$81,$3A
  Dc.b $AA,$AB,$52,$00
  Dc.b $81,$55,$55,$54
  Dc.b $2A,$00,$82,$00
  Dc.b $00,$00,$01,$00
  Dc.b $83,$FF,$FF,$FF
  Dc.b $FF,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$1F
  Dc.b $FF,$FF,$E0,$04
  Dc.b $00,$1A,$DE,$D4
  Dc.b $00,$04,$00,$17
  Dc.b $5B,$7C,$00,$04
  Dc.b $00,$02,$56,$E8
  Dc.b $00,$04,$00,$01
  Dc.b $AD,$5C,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$1F
  Dc.b $FF,$FF,$E0,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$7F
  Dc.b $FF,$FF,$F8,$04
  Dc.b $00,$C5,$55,$54
  Dc.b $AC,$04,$00,$AA
  Dc.b $AA,$AB,$D4,$04
  Dc.b $01,$FF,$FF,$FF
  Dc.b $FE,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $7F,$FF,$FF,$FF
  Dc.b $FF,$FC
Even

.open_xtrafile:
  !basic
  MOVE.l d2,d0 : accessmode.l = PutD0
  tmp_string.s = ped\sourceFileComplete + ped\extention_xtra
  log_Print{"open xtrafile: " + tmp_string}
  *xtra_fh.l = Open_(&tmp_string,accessmode)
  MOVE.l d0,d7
  !asm
RTS

.set_CurrentDir:

  log_Print{"current dir is [" + ped\currentDir + "]"}

  If ped\currentDir = "" Then ped\currentDir = dos_GetCurrentDir{}
  
  log_Print{"lock current directory [" + ped\currentDir + "]"}

  If *flock_currentDir.l Then UnLock_ *flock_currentDir

  *flock_currentDir = Lock_(&ped\currentDir,#ACCESS_READ)
  If *flock_currentDir
    CurrentDir_ *flock_currentDir
  Else
    log_Print{"could not lock the given dir, error #" + Str$(IoErr_),#log_warning}
  EndIf
Return


.load_source:
  log_Print{"load_source called"}

  ; -- security requester
  If loadcheckchanged = True
    If ped\ptrCurrentSourceData
      If ped\ptrCurrentSourceData\SourceChanged
        dummy.l = ask{!TRANS{"You have unsaved changes!"},!TRANS{"Continue|Cancel"},!TRANS{"Load File"}}
        If dummy = 0 Then Return
      EndIf
    EndIf
  EndIf

  ; -- select tab, if source is already opened
  *fileEntry.sourceEntry = 0
  If loadchecktab = True
    *fileEntry = PED_CheckSourceAlreadyOpen{ dos_FilePart{loadsourcefilename} }
    If *fileEntry
      GetD0 *fileEntry : Gosub selectTab
      dummy.l = ask{!TRANS{"The file is already open. Do you want to reload it?"},!TRANS{"Yes|Cancel"},!TRANS{"Load File"}}
      If dummy = 0
        Pop If : Pop If : Pop If : Return
      EndIf
      loadnewtab = False
    EndIf
  EndIf

  ; -- check if actual source is unnamed to decide to open new or just open
  If loadnewtab = True
    If ped\ptrCurrentSourceData
      log_Print{"Current sourcename [" + Peek$(&ped\ptrCurrentSourceData\SourceName) + "]"}
      If Peek.s(&ped\ptrCurrentSourceData\SourceName) <> ""
        log_Print{"opening a new tab"}
        Gosub menu_new
      EndIf
    Else
      log_Print{"no actual file"}
    EndIf
  EndIf

  ; -- load the source file 
  Gosub set_pointer_busy
  WZ_LockAllOpenWindows{}
  PED_ShowMessage{!TRANS{"Loading file"} + " " + loadsourcefilename + "..."}
  If loadsourcefilename.s <> ""
    log_Print{"getting extension for ["+loadsourcefilename.s + "]"}
    ex.s = dos_GetExt{loadsourcefilename.s}
    log_Print{"loading source <" + loadsourcefilename.s + ">, <" + ex + ">"}
  Else
    ex.s = "???"
  End If

  If ex.s = "ab3" OR ex.s = "ab2" OR ex.s = "bb2"
    log_Print{"loading source via compiler ..."}
    GetD0 &loadsourcefilename.s
    !asm
    MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
    !ComData_JSR{comFunc_LoadSource}
    !basic
    log_Print{"loaded " + Str$(ped\ptrCurrentSourceData\TotalLines) + " lines of text"}

    Gosub storeCurrentSourceData 

    ;-- restore windows
    Gosub RestoreLabelAndNewtypeWin
    project_changelog$ = ""

    Gosub update_versiongadgets
    Gosub analyze_loadedsource
    Gosub calc_SourceWindowDimensions

    log_Print{"goto stored cursor line: " + Str$(ped\ptrCurrentSourceData\CursorPosStore)}
    PED_GotoLine{ped\ptrCurrentSourceData\CursorPosStore-1,#LINE_START}                                                                                                                                                                                  

    log_Print{"deleting and restoring prefs..."}
    Gosub delete_tempprefs
    Gosub save_tempprefs

  Else 
    Gosub other_loading_routine
    Gosub storeCurrentSourceData
    Gosub analyze_loadedsource
    Gosub calc_SourceWindowDimensions
  EndIf


  log_Print{"updating sourcewindow..."}
  PED_UpdateStatusArea{#STATUS_REDRAW}                                                                                                                                                                                                                   
  Gosub reset_labellist
  PED_RedrawSource{}

  log_Print{"unlock wizard windows."}
  PED_ShowMessage{""}

  WZ_UnlockAllOpenWindows{}
  Gosub set_pointer_normal
  Poke.b ?convert, 0
Return

.other_loading_routine:
  log_Print{"other loading routine called..."}

  ped\sourceFileHandle = PED_OpenFile{loadsourcefilename.s,#HUNK_RELOC_16__MODE_OLDFILE,True}
  ped\sourceFileComplete = loadsourcefilename

  log_Print{"... file " + loadsourcefilename + " opened with handle " + Hex$(ped\sourceFileHandle)}

  Poke.w ?comWord_DoTokenize, ped\DoTokenize
  Poke.b ?convert, ped\convert

  log_Print{"loading file to cache"}
  If NOT PED_ReadFileCache{}
    log_Print{"could not read file...",#log_error}
    PED_CloseFile{ped\sourceFileHandle}
    Pop If : Return
  EndIf

  If Peek.b(?convert) = 1
    ped\sourceFileComplete = UnLeft$(ped\sourceFileComplete,4) + ".ab3"
  EndIf

  ped\currentDir = dos_PathPart{ped\sourceFileComplete}
  ped\currentFile = dos_FilePart{ped\sourceFileComplete}
  Poke.s ?comStr_SourceName,dos_FilePart{ped\sourceFileComplete}
  Poke.s ?comStr_SourceDir,dos_PathPart{ped\sourceFileComplete}
  Gosub set_CurrentDir

  Gosub set_pointer_busy
  !PED_ResetBlockflag
  Gosub free_actualsource

  ped\ptrCurrentSourceData\TotalLines = 1

  tmpLine.s = PED_ReadNextLine{}

  *newLine.sourceLine = PED_CreateNewSourceLine{tmpLine}
  ped\ptrCurrentSourceData\FirstSourceLine = *newLine
  ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
  ped\ptrCurrentSourceData\LastSourceLine = *newLine

  Repeat
    *currLine.sourceLine = *newLine
    tmpLine = PED_ReadNextLine{}
    tmpLen.w = FLen(tmpLine)
;    log_Print{Str$(tmpLen) + " [" + tmpLine + "]"}

    If tmpLine <> "NoCOntenTwasDelivered"
      If ped\DoTokenize
        MaxLen linebuff$ = 256
        ; process the ascii data in sourcebuff length and write the tokenized source into destbuffer
        ; the return value is the length of the tokenized text
        ; sourcebuff and destbuff might be the same pointer
        ; preproc_Tokenize{*tn.preprocessor,sourcebuff.l,destbuff.l,bytelength.l}
        preproc_Tokenize{*PreProcessor,&tmpLine,&linebuff$,FLen(tmpLine)}
        tmpLine = Peek.s(&linebuff$)
      Else
        tmpLine = Replace$(tmpLine,Chr$(9)," ")
      EndIf
      *newLine = PED_CreateNewSourceLine{tmpLine}

;      log_Print{"[" + Str$(*newLine\strLength)+ "] >> " + Peek.s(*newLine+9)}

      ped\ptrCurrentSourceData\LastSourceLine = *newLine
      *currLine\nextLine = *newLine
      *newLine\previousLine = *currLine
      ped\ptrCurrentSourceData\TotalLines + 1
    Else
      tmpLen = 0
    EndIf
  Until tmpLen = 0 AND (readcache\moreBytes = False)

  PED_CloseFile{ped\sourceFileHandle}

  ped\ptrCurrentSourceData\TextBufferOffset = 0
  ped\ptrCurrentSourceData\SourceChanged = 0
  ped\ptrCurrentSourceData\Column = 0
  ped\ptrCurrentSourceData\ColumnsOffset = 0
  ped\ptrCurrentSourceData\DisplayLineOffset = 0
  ped\ptrCurrentSourceData\DisplayLine = 0
 
  ;--
  ;-- read optional xtrafile
  ;--

  !asm
  BRA skip_loadingxtrafile

  MOVE.l comFunc_ReadXtraFile,D0
  BEQ.w skip_loadingxtrafile

  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2 ; read xtra
  JSR open_xtrafile                      ; returns D7: filehandle
  BEQ.w skip_loadingxtrafile

  MOVE.l comFunc_ReadXtraFile,D0
  MOVEA.l D0,A5
  JSR (A5)

  !basic
  log_Print{"opening xtrafile  done."}
  Read_ *xtra_fh, ?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin ; xtrabuf,36

;  stackSize.l = Peek.l(?comLong_StackSizeStore)
;  If stackSize<4096 Then stackSize=4096
;  Poke.l ?stacksize,stackSize
;
  ; -- get the data for creating executables
  exefilename$ = ""
  exepathname$ = ""
  tempexename$ = SPACE$(96)

  Seek_ *xtra_fh,$256,#OFFSET_BEGINNING
  Read_ *xtra_fh,&tempexename$,96
  i = 1
  Repeat
    char$ = Mid$(tempexename$,i,1)
    If Asc(char$)<>0 Then exepathname$ + char$
    i + 1
  Until (i = FLen(tempexename$)) OR (Asc(char$) = 0)

  tempexename$ = SPACE$(96)
  Seek_ *xtra_fh,$316,#OFFSET_BEGINNING
  Read_ *xtra_fh,&tempexename$,96
  i = 1
  Repeat 
    char$ = Mid$(tempexename$,i,1)
    If Asc(char$)<>0 Then exefilename$ + char$
    i + 1
  Until (i = FLen(tempexename$)) OR (Asc(char$) = 0)

;  exepathname$ = dos_Trim{exepathname$}
;  exefilename$ = dos_Trim{exefilename$}
;  !cout{exepathname$+"/"+exefilename$} ;$ , dos_GetFileSize2{exepathname$+"/"+exefilename$}}


  ; -- restore windows
  Gosub RestoreLabelAndNewtypeWin
  project_changelog$ = ""
  Gosub update_versiongadgets

  Close_ *xtra_fh

  ; update Sourcewindow
  PED_GotoLine{ped\ptrCurrentSourceData\CursorPosStore+1, #LINE_START}                                                                                                                                                                                   

  ; set default as these options are not stored in old xtra-file
  ped\ptrCurrentSourceData\FuncOptimize = 1
  ped\ptrCurrentSourceData\CreateDebugFile = 0

  Gosub delete_tempprefs
  Gosub save_tempprefs
  !asm
  skip_loadingxtrafile:
  !basic 
Return


;subroutine to restore Source_Browser(Label) and Definition_Browser(Newtype) window status after load and switch of Sourecode  tomsmart1
.RestoreLabelAndNewtypeWin
  LabelListSearchString.s = Peek$(?comStr_LabelSearchString) ; set the searchlabel_string
  old_LabelListSearchString.s = LabelListSearchString                ; set also old searchlabel_string to prevent a unessacary reset and jump of the labellist tomsmart1
  MOVE.l comLong_Label1VisableItemStore,comLong_Label1VisableItem          ;  move stored entry to tempbuffer manly for case of load a source  tomsmart1
  LabelList_FirstVisableItemNumber.l = Peek.l(?comLong_Label1VisableItem)  ;  set/restore the first visable entry of the labellist  tomsmart1
  LabelList_PreSelectItemNumber.l    = -1          ; set the preselected labellist entry to -1 because we don't save/store it. ; change from 0 to -1 so not the first entry was preselect  tomsmart1

  If WZ_IsOpen{"WIN_LABELS"}
    Use Window WZID("WIN_LABELS")
    WZPrint "STRING_LABEL",LabelListSearchString
    WZPrint "case"        ,Peek.w(?comWord_LabelCase)
    WZPrint "rem"         ,Peek.w(?comWord_LabelRemark)
    WZPrint "all"         ,Peek.w(?comWord_LabelAll)
    WZListRemove lib_list.List
    WZPrint "LIBRARY_LIST",0,lib_list
  EndIf
  If WZ_IsOpen{"WIN_NEWTYPE"}
    PED_UpdateDefinitionBrowser{#DEFBROWSER_RESET}
  End If
Return


.analyze_loadedsource:
  log_Print{"analyze_loadedsource"}

  sourceWindow\Title = "unnamed"
  If pedconfig\smart_tokenization Then ped\DoTokenize = $FFFF

  ped\currentDir = Peek.s(&ped\ptrCurrentSourceData\CurrentDir)
  ped\currentFile = Peek.s(&ped\ptrCurrentSourceData\SourceName)
  ped\sourceFileComplete = dos_AddPart{ped\currentDir,ped\currentFile}

  If ped\currentFile <> ""
    sourceWindow\Title = ped\currentFile + " (" + ped\currentDir + ")"

    ; -- check extension
    fext$ = LCase$(dos_GetExt{ped\currentFile})
    log_Print{"checking file extention of loaded file: " + fext$}
    If fext$ = "bb2" OR fext$ = "ab2" OR fext$ = "ab3" OR fext$ = "bb"
      log_Print{"activating tokenization"}
      ped\DoTokenize = $FFFF
    EndIf
    If fext$ = "txt" OR fext$ = "guide"
      log_Print{"deactivating tokenization"}
      ped\DoTokenize = 0
      If fext$ = "guide" Then ped\amigaguide = True
    EndIf
  EndIf
  Poke.w ?comWord_DoTokenize, ped\DoTokenize

  SetWindowTitles_ sourceWindow\win, &sourceWindow\Title, -1

  ; -- update tooltype "LAST_SOURCE"
  If pedconfig\load_last_source <> 0
    log_Print{"updateing tooltype LAST_SOURCE..."}
    pedconfig\lastSourceFile = ped\sourceFileComplete
    If pedconfig\lastSourceFile <> ""
      If Instr(pedconfig\lastSourceFile, ped\currentFile) <> 0
        dos_SetToolString{"LAST_SOURCE",pedconfig\lastSourceFile}
      EndIf
    EndIf
  EndIf

  ; -- update modified flags
  ped\ptrCurrentSourceData\KeyBeforeReturn = 0
  ;Gosub update_modifiermark
  Gosub update_debuggertoggle
Return


.delete_tempprefs:
  If Peek.l(?comFunc_ReadXtraFile) <> 0
    tmp_string = "T:PED_" + Hex$(ped\currentSourceEntry) + ".xtra"
    log_Print{"deleting <" + tmp_string + ">"}
    DeleteFile_ &tmp_string
  EndIf
Return

.read_tempprefs:
  If Peek.l(?comFunc_ReadXtraFile) <> 0
    tmp_string = "T:PED_" + Hex$(ped\currentSourceEntry) + ".xtra"
    tpfhandle.l = Open_(&tmp_string, #HUNK_RELOC_16__MODE_OLDFILE)
    If tpfhandle <> 0
      log_Print{"reading xtrafile <" + tmp_string + ">"}
      GetD0 Peek.l(?comFunc_ReadXtraFile) : MOVE.l d0,-(a7)
      GetD0 tpfhandle : MOVE.l d0,-(a7)
      !asm
      MOVE.l (a7)+,D7
      MOVEA.l (a7)+,A5
      JSR (A5)
      !basic
      Close_ tpfhandle
    EndIf
  EndIf
Return

.save_tempprefs:
  If Peek.l(?comFunc_WriteXtraFile) <> 0
    tmp_string.s = "T:PED_" + Hex$(ped\currentSourceEntry) + ".xtra"
    tpfhandle.l = Open_(&tmp_string, #HUNK_RELOC_8__MODE_NEWFILE)
    If tpfhandle <> 0
      log_Print{"writing xtrafile for " + Peek$(&ped\ptrCurrentSourceData\SourceName) + " <" + tmp_string + ">"}
      GetD0 Peek.l(?comFunc_WriteXtraFile) : MOVE.l d0,-(a7)
      GetD0 tpfhandle : MOVE.l d0,-(a7)
      !asm
      MOVE.l (a7)+,D7
      MOVEA.l (a7)+,A5
      JSR (A5)
      !basic
      Close_ tpfhandle
    EndIf
  EndIf
Return

.menu_saveas:
  log_Print{"menu_saveas called."}
  Gosub storeCurrentSourceData

  tmp_string.s = PED_RequestFile{Peek.s(&ped\ptrCurrentSourceData\CurrentDir),Peek.s(&ped\ptrCurrentSourceData\SourceName),"Name of file to open",ped\filePattern}
  ;Poke.s ?comStr_SourceFileComplete,BB2Filename$
  If tmp_string <> ""
    ped\check_existsfile = True
    Gosub menu_save
    ped\check_existsfile = False

    PED_UpdateStatusArea{#STATUS_REDRAW}                                                                                                                                                                                                                 
 EndIf
Return

.menu_save:
  log_Print{"menu_save called on sourcefile: " + ped\currentFile}
  If ped\currentFile = ""
    BB2Filename$ = PED_RequestFile{ped\currentDir,ped\currentFile,"Name to save file as",ped\filePattern}
    ;ped\sourceFileComplete will be set in function as wekk
    Poke.s ?comStr_SourceName,ped\currentFile   ; info for compiler
    Poke.s ?comStr_SourceDir,ped\currentDir
  EndIf
  If ped\currentFile = "" Then Return

  directory.s = dos_FilePart{dos_PathPart{ped\sourceFileComplete}}
  If dos_Exist{ped\sourceFileComplete} AND LCase$(directory) = "templates"
    If NOT ask{!TRANS{"Do you really want to save this file into the templates drawer?"},!TRANS{"Ok|Cancel"},!TRANS{"Question"}}
      Return
    EndIf
  EndIf

  ped\amiblitzmode = 0
  ex.s = dos_GetExt{ped\sourceFileComplete}
  If LCase$(ex) = "bb2" Then ped\amiblitzmode = 1
  If LCase$(ex) = "ab2" Then ped\amiblitzmode = 2
  If LCase$(ex) = "ab3" Then ped\amiblitzmode = 3

  If Len(ped\currentFile) > 27
    dummy.l = ask{!TRANS{"Warning: Filename is longer than 27 characters.\\n" + ped\currentFile + "\\nThis may cause problems with some filesystems."},!TRANS{"Continue"},!TRANS{"Info"}}
  EndIf
  log_Print{"ped\sourceFileComplete : " + ped\sourceFileComplete }

  If ped\check_existsfile
    log_Print{"check if file <" + ped\sourceFileComplete + "> already exists, requester if so  ..."}
    *flock.l = Lock_(&ped\sourceFileComplete,#ACCESS_WRITE)
    If *flock <> 0
      If ask{!TRANS{"File already exists!"},!TRANS{"Overwrite|Cancel"},!TRANS{"Save File As..."}}
        log_Print{"overwrite is ok"}
        UnLock_ *flock
      Else
        log_Print{"operation cancelled"}
        Pop If : Pop If
        Return
      EndIf
    Else
      ; file does not exist, that is ok!
    EndIf
  EndIf 

  Poke.l ?comPtr_SourceName, &ped\currentFile
  Poke.l ?comPtr_SourceDir, &ped\currentDir
  Poke.s ?comStr_SourceName, ped\currentFile
  Poke.s ?comStr_SourceDir, ped\currentDir

  Gosub storeCurrentSourceData

  log_Print{"updated current source name: " + Peek.s(Peek.l(?comPtr_SourceName))}

  tmp_string.s = ped\sourceFileComplete + ped\extention_bak
  DeleteFile_ &tmp_string
  Rename_ &ped\sourceFileComplete, tmp_string


  WZ_LockAllOpenWindows{}
  Gosub set_pointer_busy
  PED_ShowMessage{!TRANS{"Saving file"} + "..."}

  log_Print{"writing mode: " + Str$(ped\amiblitzmode)}
  Select ped\amiblitzmode
  Case 1 : Gosub save_source_as_tokenized
           ;!asm
           ;write_xtrafile
           ;!basic
  Case 2 : Gosub save_source_as_text
  Case 3 : Gosub save_source_as_ab3
  Default: Gosub save_source_as_text
  End Select

  If pedconfig\remember_saved Then Gosub update_rememberlist

  ped\ptrCurrentSourceData\SourceChanged = 0

  PED_ShowMessage{""}
  WZ_UnlockAllOpenWindows{}
  Gosub set_pointer_normal
Return


.save_source_as_ab3:
  log_Print{"ped\sourceFileComplete = " + ped\sourceFileComplete + ">"}
  GetD0 &ped\sourceFileComplete : MOVE.l D0,-(a7)
  !asm
  MOVE.l (a7)+,D0
  !ComData_JSR{comFunc_SaveSource}

  !basic                                                                                                                                                                                                                                                 
  If pedconfig\use_source_icon Then Gosub write_infofile
  Gosub analyze_loadedsource
Return

.save_source_as_text:
  log_Print{"write as text: opening file"}
  Gosub set_pointer_busy

  *write_fh.l = Open_(&ped\sourceFileComplete, #HUNK_RELOC_8__MODE_NEWFILE)
  If *write_fh = 0
    WZ_UnlockAllOpenWindows{}
    Gosub set_pointer_normal
    WZ_HideMessage{}
    error{!TRANS{messageErrorWriteFile}}
  Else
    If ped\ptrCurrentSourceData\TotalLines > 0
      *tempLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine

      If ped\DoTokenize <> 0
        log_Print{"write as text: writing detokenized file"}

        ;-- detokenize and write to file
        numlines.l = ped\ptrCurrentSourceData\TotalLines
        totalLength.l = 0
        For n.l = 0 To numlines - 1
          baseptr.l = *tempLine + 9
          sptr.l = baseptr
          While Peek.b(sptr) : sptr + 1 : Wend
          totalLength + sptr - baseptr + 1
          *tempLine = *tempLine\nextLine
        Next
        ;-- alloc buffer
        tmp.l      = AllocVec_(totalLength,#MEMF_CLEAR)
        If tmp
          node.l     = ped\ptrCurrentSourceData\FirstSourceLine
          dptr.l     = tmp
          For n.l=0 To numlines-1
            baseptr.l = node+$9 ;Peek.l (node+$9)
            sptr.l    = baseptr
            Repeat
              char.b = Peek.b(sptr)
              Poke.b dptr,char : sptr +1 : dptr+1
            Until char=0
            node = Peek.l(node)
          Next
          plainLength.l = preproc_DetokenizeFP{*PreProcessor, tmp, totalLength, *write_fh}
          FreeVec_ tmp
        Else
          error{!TRANS{"Not enough memory for temp buffer!"}}
        End If
      Else
        ;-- directly write to file
        log_Print{"write as text: writing text line-by-line to file"}
        Repeat
          strLine.s = ""
          strLength.w = *tempLine\strLength - 1
          If strLength > 0 Then strLine.s = Peeks$(*tempLine + 9, strLength)
          ;log_Print{"writing [" + Str$(FLen(strLine))+ "]: [" + strLine + "]"}
          strLine + Chr$(10)
          Write_ *write_fh, &strLine, FLen(strLine)
          *tempLine = *tempLine\nextLine
        Until *tempLine = 0
      EndIf
    EndIf
    log_Print{"write as text: closing file"}
    Close_ *write_fh : *write_fh = 0
  EndIf
Return

.save_source_as_tokenized:
  log_Print{"write as tokenized: opening file"}
  Gosub set_pointer_busy

  *write_fh.l = Open_(&ped\sourceFileComplete, #HUNK_RELOC_8__MODE_NEWFILE)
  If *write_fh = 0
    WZ_UnlockAllOpenWindows{}
    Gosub set_pointer_normal
    WZ_HideMessage{}
    error{!TRANS{messageErrorWriteFile}}
  Else
    *tempLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
    Repeat
      baseptr.l = *tempLine + 9
      strLength.w = *tempLine\strLength

      If ped\DoTokenize = 0
        strLine$ = Peeks$(baseptr,strLength) + Chr$(10)
      Else
        strLine$ = Peeks$(baseptr,strLength)
      EndIf
      ;log_Print{Str$(strLength) + " >> " + strLine$}
      Write_ *write_fh, &strLine$, FLen(strLine$)
      *tempLine = *tempLine\nextLine
    Until *tempLine = 0
    log_Print{"write as tokenized: closing file"}
    Close_ *write_fh
  EndIf
Return

.write_xtrafile:
  MOVE.l comFunc_WriteXtraFile,D0
  BEQ.w skip_writingxtrafile
    MOVEA.l D0,A5
    MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
    JSR open_xtrafile
    BEQ.w skip_writingxtrafile
      JSR (A5)

      !basic
      If *xtra_fh <> 0
        log_Print{"writing additional stuff..."}
        ped\ptrCurrentSourceData\CursorPosStore = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine
        Poke$ ?comStr_LabelSearchString,LabelListSearchString
        MOVE.l LabelList_FirstVisableItemNumber@(a5),comLong_Label1VisableItemStore
        ; moved the write of the 4 extra fill/pad/termination bytes to the Compiler xtra save routine because the Compiler xtra load routine needs it!  tomsmart1
        Write_ *xtra_fh,?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin
        log_Print{"close xtrafile"}
        Close_ *xtra_fh
      EndIf
      !asm
  skip_writingxtrafile:
  !basic
  If pedconfig\use_source_icon Then Gosub write_infofile
  Gosub analyze_loadedsource
  PED_UpdateStatusArea{#STATUS_REDRAW}                                                                                                                                                                                                                   
  WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                              
  Gosub set_pointer_normal
  !asm
RTS

.menu_about:
  txt0.s = !versions + "#" + Peek$(Peek.l(?comPtr_CompilerVersion))
  txt1.s = ArexxPortName$
  txt2.s = ped\defaultPubscreenName
  txt3.s = "n/a"
  txt4.s = "n/a"
  txt5.s = "n/a"
  txt6.s = "n/a"
  If pedconfig\useBaseLib Then txt3 = ped\baselibFileDate + " - " + Str$(ped\baselibFileSize) + " bytes"
  If pedconfig\useUtilLib Then txt4 = ped\utillibFileDate + " - " + Str$(ped\utillibFileSize) + " bytes"
  If pedconfig\useOsLib   Then txt5 = ped\oslibFileDate + " - " + Str$(ped\oslibFileSize) + " bytes"
  If pedconfig\useCsLib   Then txt6 = ped\cslibFileDate + " - " + Str$(ped\cslibFileSize) + " bytes"
  window_welcome{txt0,txt1, txt2, txt3, txt4, txt5, txt6}
Return


str_searchstring:   Ds.b #MAX_STRINGSIZE
str_replacestring:  Ds.b #MAX_STRINGSIZE
Even

.menu_find:
  ts.s = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
  actualword$ = PED_GetWordAtPos{ts, ped\ptrCurrentSourceData\Column,False}
  If actualword$ <> ""
    find_findStrOld.s = actualword$
  EndIf

  If WZ_IsOpen{"WIN_SEARCH"} = False
    WZWindow WZID("WIN_SEARCH"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_SEARCH")
    WZ_AddMenuStrip{"WIN_SEARCH",ped\menuStrip}
    Delay_ 2
    WZPrint "FIND_FINDSTRING"   ,&find_findStrOld
    WZPrint "FIND_REPLACESTRING",&find_replaceStrOld
    ;WZPrint "FIND_FINDMODE",-1
    WZ_ActivateGadget{"FIND_FINDSTRING"}
  Else
    Use Window WZID("WIN_SEARCH")
    WindowToFront_ WZWindowAddr
    WZ_ActivateGadget{"FIND_FINDSTRING"}
  EndIf
Return


.menu_findnext:
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *currentLine = *currentLine\nextLine
  direction.b = 1

nextOccurence:
  If *currentLine <> 0
    search.s = Peek.s(?str_searchstring)

    If direction = 1
      log_Print{"find next for [" + search + "]"}
    Else
      log_Print{"find previous for [" + search + "]"}
    EndIf

    Gosub set_pointer_busy

    curLine.l = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset + direction
    Repeat
      tmpX.w = PED_SearchString{search,ped\caseSensitive,1,*currentLine}
      If tmpX = 0
        If direction = 1
          *currentLine = *currentLine\nextLine
        Else
          *currentLine = *currentLine\previousLine
       EndIf
        curLine + direction
      EndIf
    Until (tmpX > 0) OR (curLine > ped\ptrCurrentSourceData\TotalLines) OR (curLine < 0)

    If tmpX > 0
      log_Print{"found [" + search + "] in Line " + Str$(curLine) + ", Column " + Str$(tmpX)}
      PED_GotoLine{curLine}
      newColumn.w = tmpX - 1 : Gosub moveCursorToX
      PED_UpdateStatusArea{#STATUS_SCROLLERS}
    EndIf

    Gosub set_pointer_normal
  EndIf
Return


.menu_findprevious:
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *currentLine = *currentLine\previousLine
  direction.b = -1
Goto nextOccurence

.menu_replace:
  If Peek.s(?str_searchstring)<>""
    log_Print{"menu replace called: " + Peek.s(?str_searchstring) + " >> " + Peek.s(?str_replacestring)}
    *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    If PED_ReplaceString{Peek.s(?str_searchstring),Peek.s(?str_replacestring),*currentLine}
      log_Print{"replace done."}
      Gosub menu_findnext
      PED_RedrawSource{}
    EndIf
  Else
    log_Print{"no searchstring set."}
  EndIf
Return

.menu_replaceall:
  If Peek.s(?str_searchstring)<>""
    log_Print{"menu replaceall called: " + Peek.s(?str_searchstring) + " >> " + Peek.s(?str_replacestring)}
    findmode.b = WZInput("FIND_FINDMODE")
    If findmode
      *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    Else
      *currentLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
    EndIf

    Repeat
      If PED_ReplaceString{Peek.s(?str_searchstring),Peek.s(?str_replacestring),*currentLine}
        *currentLine = ped\ptrCurrentSourceData\CurrentSourceLine
      EndIf
      *currentLine = *currentLine\nextLine
    Until *currentLine = 0
  Else
    log_Print{"no searchstring set."}
  EndIf
Return


.menu_quitall:
  log_Print{"close all sources."}

  While ped\firstSourceEntry
    If ped\ptrCurrentSourceData\SourceChanged 
      dummy.l = ask{!TRANS{"You have unsaved changes!"},!TRANS{"Continue|Cancel"},!TRANS{"Quit"}}
      If dummy = 0 Then Pop If: Return
    EndIf

    Gosub free_actualsource
    Gosub close_actualsource
    PED_UpdateStatusArea{#STATUS_REDRAW}                                                                                                                                                                                                                 
  Wend

  exit_eventloop = True : exit_mainloop = True
Return


.menu_quit:
  If pedMessage\_Code = 1
    log_Print{"new Iconify message was send by intuition"}
    Gosub menu_iconify
    Return
  EndIf

  log_Print{"close current source."}
  If ped\ptrCurrentSourceData\SourceChanged 
    dummy.l = ask{!TRANS{"You have unsaved changes!"},!TRANS{"Continue|Cancel"},!TRANS{"Quit"}}
    If dummy = 0 Then Pop If : Return
  EndIf

  Gosub free_actualsource
  Gosub close_actualsource

  If ped\firstSourceEntry = 0
    dummy.l = 1
    If pedconfig\ask_before_quit
      dummy.l = ask{!TRANS{"Closing last source, do you really want to quit?"},!TRANS{"Ok|Cancel"},!TRANS{"Question"}}
    EndIf
    If dummy = 0
      Gosub menu_new
    Else
      log_Print{"telling mainloop to stop, no open file left"}
      exit_eventloop = True : exit_mainloop = True
    EndIf
  EndIf

  PED_UpdateStatusArea{#STATUS_REDRAW}                                                                                                                                                                                                                   
Return


.menu_blockcomment:
  USEPATH ped\ptrCurrentSourceData

  log_Print{"menu blockcomment called."}

  If \BlockEndY = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal
    Pop If: Return
  EndIf

  Gosub update_currsourceline
 
  \CurrentSourceLine = PED_GetBlockStartSourceLine{}
  startY.l = \BlockStartY
  log_Print{"startY: " + Str$(\BlockStartY)}
  log_Print{"endY: "  + Str$(\BlockEndY)}

  Repeat
    If ped\DoTokenize
      strline$ = PED_Detoke{\CurrentSourceLine}
    Else
      strline$ = Peek.s(\CurrentSourceLine + 9)
    EndIf
    strline$ = ";" + strline$
    log_Print{">> " + strline$}

    newline$ = PED_ParseText{strline$}
    newline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))

    *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
    PED_ReplaceCurrentSourceLine{*newLine}

    \CurrentSourceLine = \CurrentSourceLine\nextLine
    startY + 1
  Until startY = \BlockEndY + 1
  
  Gosub update_currsourceline
  PED_RedrawSource{}
Return


.menu_blockuncomment:
  log_Print{"menu blockuncomment called."}
  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal
    Pop If: Return
  EndIf

  Gosub update_currsourceline

  \CurrentSourceLine = PED_GetBlockStartSourceLine{}
  startY.l = \BlockStartY
  log_Print{"startY: " + Str$(\BlockStartY)}
  log_Print{"endY: "  + Str$(\BlockEndY)}

  Repeat
    If ped\DoTokenize
      strline$ = PED_Detoke{\CurrentSourceLine}
    Else
      strline$ = Peek.s(\CurrentSourceLine + 9)
    EndIf
 
    If Instr(strline$,";")
      strline$ = StripLead$(strline$,@" ")
      If Left$(strline$,1) = ";"
        strline$ = UnRight$(strline$,1)
        newline$ = PED_ParseText{strline$}
        newline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))
        *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
        PED_ReplaceCurrentSourceLine{*newLine}
      EndIf
    EndIf

    \CurrentSourceLine = \CurrentSourceLine\nextLine
    startY + 1
  Until startY = \BlockEndY + 1
  
  Gosub update_currsourceline
  PED_RedrawSource{}
Return

.menu_blocktab:
  log_Print{"menu blocktab called."}
  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal
    Pop If: Return
  EndIf

  Gosub update_currsourceline  

  \CurrentSourceLine = PED_GetBlockStartSourceLine{}
  startY.l = \BlockStartY
  log_Print{"startY: " + Str$(\BlockStartY)}
  log_Print{"endY: "  + Str$(\BlockEndY)}

  Repeat
    If ped\DoTokenize
      strline$ = PED_Detoke{\CurrentSourceLine}
    Else
      strline$ = Peek.s(\CurrentSourceLine + 9)
    EndIf
    
    strline$ = SPACE$(pedconfig\tabSize) + strline$
    newline$ = PED_ParseText{strline$}
    newline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))

    *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
    PED_ReplaceCurrentSourceLine{*newLine}

    \CurrentSourceLine = \CurrentSourceLine\nextLine
    startY + 1
  Until startY = \BlockEndY + 1

  Gosub update_currsourceline
  PED_RedrawSource{}
Return


.menu_blockuntab:
  log_Print{"menu blockuntab called."}
  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal
    Pop If: Return
  EndIf

  Gosub update_currsourceline
  startY.l = \BlockStartY
  log_Print{"startY: " + Str$(\BlockStartY)}
  log_Print{"endY: "  + Str$(\BlockEndY)}

  Repeat
    If ped\DoTokenize
      strline$ = PED_Detoke{\CurrentSourceLine}
    Else
      strline$ = Peek.s(\CurrentSourceLine + 9)
    EndIf
 
    If FLen(strline$) > 0
      For runner.w = 1 To pedconfig\tabSize
        If Left$(strline$,1) = " " Then strline$ = UnRight$(strline$,1)
      Next runner
      ;strline$ + SPACE$(#MAX_Columns - FLen(strline$))
      newline$ = PED_ParseText{strline$}
      newline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))
      *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
      PED_ReplaceCurrentSourceLine{*newLine}
    EndIf

    \CurrentSourceLine = \CurrentSourceLine\nextLine
    startY + 1
  Until startY = \BlockEndY + 1

  Gosub update_currsourceline
  PED_RedrawSource{}                                                                                                                                                                                                                                     
  log_Print{"menu blockuntab done."}
Return

.close_actualsource:
  Gosub delete_tempprefs

  *sourceEntry.sourceEntry = ped\currentSourceEntry
  *nextEntry.sourceEntry = *sourceEntry\nextEntry
  *prevEntry.sourceEntry = *sourceEntry\previousEntry

  If *prevEntry <> 0
    If *nextEntry <> 0
      ped\currentSourceEntry = *nextEntry
      *prevEntry\nextEntry = *nextEntry
      *nextEntry\previousEntry = *prevEntry
    Else
      ped\currentSourceEntry = *prevEntry
      ped\firstLoadedEntry = *prevEntry
      *prevEntry\nextEntry = 0
    EndIf
  Else
    If *nextEntry <> 0
      ped\firstSourceEntry = *nextEntry
      ped\currentSourceEntry = *nextEntry
      *nextEntry\previousEntry = 0
    Else
      ped\firstSourceEntry = 0
      ped\firstLoadedEntry = 0
      ped\currentSourceEntry = 0
    EndIf
  EndIf
  PED_FreeMem{*sourceEntry}

  If ped\currentSourceEntry
    Gosub getCurrentSourceData
    Gosub read_tempprefs
    Gosub reset_sourcewindow
  EndIf
Return

.movelinedown:
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *prevLine.sourceLine = *currentLine\previousLine
  *nextLine.sourceLine = *currentLine\nextLine
  tmpCurrentLine.l = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
  tmpTotalLines.l = ped\ptrCurrentSourceData\TotalLines
  log_Print{"current " + Str$(tmpCurrentLine) + "   total " + Str$(tmpTotalLines)}
;  log_Print{Hex$(*prevLine)}
;  log_Print{Hex$(*currentLine)}
;  log_Print{Hex$(*nextLine)}
  If (tmpCurrentLine < tmpTotalLines) AND (*nextLine <> 0) ; if no nextline, we cannot move down
    If cutLine{*currentLine}
      appendLine{*nextLine, *currentLine}
      ;Poke.l ?comPtr_CurrentSourceLine,*nextLine

      ped\ptrCurrentSourceData\SourceChanged = $FFFF
      ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine

      If *currentLine\nextLine = *currentLine
        log_Print{"=========================== PONG"}
        log_Print{Hex$(*prevLine) + Peeks$(*prevLine+9,32)}
        log_Print{Hex$(*currentLine) + Peeks$(*currentLine+9,32)}
        log_Print{Hex$(*nextLine) + Peeks$(*nextLine+9,32)}
      EndIf

      ; check if text is scrolled
      tmpDisplayLine.l = ped\ptrCurrentSourceData\DisplayLine
      tmpDisplayLineOffset.l = ped\ptrCurrentSourceData\DisplayLineOffset
      tmpVisibleLines.l = sourceWindow\visibleLines
      If tmpDisplayLineOffset + tmpVisibleLines > tmpTotalLines
        log_Print{"increase displayline, current: " + Str$(tmpDisplayLine)}
        !PED_IncreaseDisplayLine
        PED_RedrawSource{}
      Else
        If tmpVisibleLines > (tmpDisplayLine + 1 + sourceWindow\boundLinesY)
          !PED_IncreaseDisplayLine
          PED_RedrawSource{}
        Else
          ped\ptrCurrentSourceData\DisplayLineOffset + 1
          PED_ScrollVertical{#SCROLL_UP}
          Gosub draw_new_sourceline_bottom
          PED_RedrawSource{}
        EndIf
      EndIf
    Else
      log_Print{"*** cut not successfull ***"}
    EndIf
  Else
    log_Print{"no alt-cursor down available."}
  EndIf
Return


.movecursorlinedown:
  !PED_CursorOff
  Gosub handle_blockmark

  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *nextLine.sourceLine = *currentLine\nextLine

  If Peeks$(*currentLine+9,4)=";@@1"
    tmpDLO.l = ped\ptrCurrentSourceData\DisplayLineOffset
    *_next.sourceLine = *nextLine
    While *_next
      ped\ptrCurrentSourceData\DisplayLineOffset + 1
      If Peeks$(*_next + 9,4) <> ";@@1"
        If Peeks$(*_next + 9,4) = ";@@0"
          ped\ptrCurrentSourceData\CurrentSourceLine = *_next
          PED_RedrawSource{}
          Return
        EndIf
      EndIf
      *_next = *_next\nextLine
    Wend
    ped\ptrCurrentSourceData\DisplayLineOffset = tmpDLO
  EndIf

  If *nextLine = 0
    !PED_CursorOn
    Gosub set_pointer_normal
  Else
    ped\ptrCurrentSourceData\CurrentSourceLine = *nextLine
    Gosub update_sourcewindow_bottom
  EndIf

Return

.setpointer_to_normal:
  JSR set_pointer_normal
RTS

.update_linenumbers
  If pedconfig\linenumbers
    storeCurrentLineNumber.l = ped\ptrCurrentSourceData\DisplayLine
    maxLineNumber.l = Min(ped\ptrCurrentSourceData\TotalLines,sourceWindow\visibleLines)-1
    For y.w = storeCurrentLineNumber To maxLineNumber
      ped\ptrCurrentSourceData\DisplayLine = y
      PED_PrintLineNumber{}
    Next y
    ped\ptrCurrentSourceData\DisplayLine = storeCurrentLineNumber
  EndIf
Return

.update_sourcewindow_bottom:
  If ped\ptrCurrentSourceData\TotalLines >= ped\ptrCurrentSourceData\DisplayLineOffset + sourceWindow\visibleLines
    If ped\ptrCurrentSourceData\DisplayLine + 1 + sourceWindow\boundLinesY => sourceWindow\visibleLines
      ped\ptrCurrentSourceData\DisplayLineOffset + 1
      PED_ScrollVertical{#SCROLL_UP}
      Gosub draw_new_sourceline_bottom
      Return
    EndIf
  EndIf

  !PED_IncreaseDisplayLine

  ;-- update linenumbers from here
  Gosub update_linenumbers

  !PED_CursorOn
Return

.selectblockdown:
  If ped\ptrCurrentSourceData\BlockEndY = $FFFFffff Then PED_SetBlockStart{}
  Gosub movecursorlinedown
  PED_SetBlockEnd{}
Return

.selectblockup:
  If ped\ptrCurrentSourceData\BlockEndY = $FFFFffff Then PED_SetBlockStart{}
  Gosub movecursorlineup
  PED_SetBlockEnd{}
Return

.selectblockright:
  If ped\ptrCurrentSourceData\BlockEndY = $FFFFffff Then PED_SetBlockStart{}
  Gosub moveCursorRight
  PED_SetBlockEnd{}
Return

.selectblockleft:
  If ped\ptrCurrentSourceData\BlockEndY = $FFFFffff Then PED_SetBlockStart{}
  Gosub moveCursorLeft
  PED_SetBlockEnd{}
Return


.movelineup:
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *prevLine.sourceLine = *currentLine\previousLine
  *nextLine.sourceLine = *currentLine\nextLine
  tmpCurrentLine.l = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
;  log_Print{"current " + Str$(tmpCurrentLine) + "dl " + Str$(ped\ptrCurrentSourceData\DisplayLine) + "prevline " + Hex$(*prevLine)}
;  log_Print{Hex$(*prevLine) + Peeks$(*prevLine+9,32)}
;  log_Print{Hex$(*currentLine) + Peeks$(*currentLine+9,32)}
;  log_Print{Hex$(*nextLine) + Peeks$(*nextLine+9,32)}
 
  If (tmpCurrentLine > 0) AND (*prevLine <> 0) ; if no previousline, we cannot move up
    If cutLine{*currentLine}
      ;log_Print{"cutted out  " + Hex$(*currentLine) + " " + Peeks$(*currentLine+9,32) }
      ;log_Print{"append after: " + Hex$(*prevLine\previousLine) + " " + Peeks$(*prevLine\previousLine + 9,32)}

      appendLine{*prevLine\previousLine, *currentLine}

      ped\ptrCurrentSourceData\SourceChanged = $FFFF
      ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine

      If *currentLine\nextLine = *currentLine
        log_Print{"=========================== PING"}
        log_Print{Hex$(*prevLine) + Peeks$(*prevLine+9,32)}
        log_Print{Hex$(*currentLine) + Peeks$(*currentLine+9,32)}
        log_Print{Hex$(*nextLine) + Peeks$(*nextLine+9,32)}
      EndIf

      ; check if text is scrolled
      If ped\ptrCurrentSourceData\DisplayLineOffset = 0 OR (ped\ptrCurrentSourceData\DisplayLine > sourceWindow\boundLinesY)
        log_Print{"decrease displayline, current: " + Str$(ped\ptrCurrentSourceData\DisplayLine)}
        !PED_DecreaseDisplayLine
        PED_RedrawSource{}
      Else
        ped\ptrCurrentSourceData\DisplayLineOffset - 1
        log_Print{"fullscrollup"}
        PED_ScrollVertical{#SCROLL_DOWN}
        Gosub draw_new_sourceline_top
        PED_RedrawSource{}
      EndIf
    Else
      log_Print{"*** cut not successfull ***"}
    EndIf
  Else
    log_Print{"no alt-cursor up available."}
  EndIf
Return

Function.b PED_CheckFoldingState{}
SHARED ped
  If ped\currentSourceEntry\FirstSourceLine <> 0
    foldstatus.b = 0
    *tmpcsl.sourceLine = ped\currentSourceEntry\FirstSourceLine
    While *tmpcsl <> ped\currentSourceEntry\CurrentSourceLine
      If Peek.w(*tmpcsl + 9) = @";@"
        foldstr.w = Peek.w(*tmpcsl + 11)
        Select foldstr
        Case @"@1" : foldstatus = 1
        Case @"@0" : foldstatus = 0
        End Select
      EndIf
      *tmpcsl = *tmpcsl\nextLine
    Wend
    Function Return foldstatus
  Else
    Function Return 0
  EndIf
End Function

Function.l PED_CheckFoldingReverse{*tmpLine.sourceLine}
SHARED ped
  ped\foldNumber = 0
  linePtr.l = 0

  log_Print{"check line:  [" + Peeks$(*tmpLine + 9,8) + "]"}
  marker.s = Peeks$(*tmpLine + 11,2)
  If marker = "@0"
    ped\foldNumber = 0
    *tmpPrev.sourceLine = *tmpLine\previousLine
    While *tmpPrev
      marker2.s = Peeks$(*tmpPrev + 9,4)
      If Left$(marker2,2) = ";@"
        log_Print{" found a marker upwarts: " + marker2}
        If Right$(marker2,2) = "@1"
          ped\foldNumber = 1
          linePtr = *tmpPrev
          Pop If: Pop If : Pop While
          Goto exit_while
        EndIf
        If Right$(marker2,2) = "@0"
          Goto exit_while
        EndIf
      EndIf
      *tmpPrev = *tmpPrev\previousLine
    Wend
    exit_while:
  EndIf

  If marker = "@1" Then ped\foldNumber = 0

  Function Return linePtr
End Function


.movecursorlineup:
  !PED_CursorOff
  Gosub handle_blockmark

  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *prevLine.sourceLine = *currentLine\previousLine

  If Peeks$(*currentLine + 9,4) = ";@@0"
    log_Print{"jump marker found, searching corresponding previous marker."}
    *_prev.sourceLine = *currentLine
    linePtr.l = PED_CheckFoldingReverse{*_prev}
    If linePtr <> 0
      log_Print{"previous marker for [" + Peeks$(*_prev + 9,4) + "] found, jumping to that line."}
      Repeat
        *_prev = *_prev\previousLine
        ped\ptrCurrentSourceData\DisplayLineOffset - 1
      Until *_prev = linePtr
      ped\ptrCurrentSourceData\CurrentSourceLine = *_prev
      PED_RedrawSource{}
      Return
    EndIf

  EndIf

  If *prevLine = 0
    !PED_CursorOn
    Gosub set_pointer_normal
  Else
    ped\ptrCurrentSourceData\CurrentSourceLine = *prevLine

    If ped\ptrCurrentSourceData\DisplayLineOffset > 0
      If ped\ptrCurrentSourceData\DisplayLine <= sourceWindow\boundLinesY
        ped\ptrCurrentSourceData\DisplayLineOffset - 1        ; otherwise scroll whole text one line up
        PED_ScrollVertical{#SCROLL_DOWN}
        Gosub draw_new_sourceline_top
        Return
      EndIf
    EndIf
    !PED_DecreaseDisplayLine
    !PED_CursorOn
  EndIf
Return


.menu_markindent:
  log_Print{"menu markindent called."}
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  If Peek.b(*currentLine + 9) <> 0
    actualLine.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine

    ; -- get current indent position
    currentXPos.w = 0
    While Peek.b(*currentLine + 9 + currentXPos) = $20
      currentXPos + 1
    Wend

    ; -- search for block start
    indentBegin.l = actualLine
    While indentBegin > 0
      upperXPos.w = 0
      *currentLine = *currentLine\previousLine
      While Peek.b(*currentLine + 9 + upperXPos) = $20
        upperXPos + 1
      Wend
      If Peek.b(*currentLine + 9 + upperXPos) <> 0
        If upperXPos < currentXPos Then Goto exit_upperindent
      EndIf
      indentBegin - 1
    Wend
    exit_upperindent:

    ; -- search for end of block
    *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    indentEnd.l = actualLine
    *currentLine = *currentLine\nextLine
    While *currentLine <> 0
      lowerXPos.w = 0
      While Peek.b(*currentLine + 9 + lowerXPos) = $20
        lowerXPos + 1
      Wend
      If Peek.b(*currentLine + 9 + lowerXPos) <> 0
        If lowerXPos < currentXPos Then Goto exit_lowerindent
      EndIf
      indentEnd + 1

      *currentLine = *currentLine\nextLine
    Wend
    exit_lowerindent:

    ; draw the blockmark
    ped\ptrCurrentSourceData\BlockStartY = indentBegin
    ped\ptrCurrentSourceData\BlockStartX = 0
    ped\ptrCurrentSourceData\BlockEndY   = indentEnd
    ped\ptrCurrentSourceData\BlockEndX   = #MAX_Columns - 1
    PED_RedrawSource{}
  EndIf
  Gosub set_pointer_normal
Return


.handle_blockmark:
  ;log_Print{"handle blockmark"}
  sourceWindow\deleteMode = 0

  If ped\blockmarkRemovalMode <> 0
    If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
      If ped\blockmarkRemovalMode = 2
        Gosub menu_cut
        If pedconfig\no_display_beep = False Then DisplayBeep_ sourceWindow\pedScreen
      Else
        ; for blockmarkRemovalMode = 1 only remove blockmark
        Poke.l ?comLong_BlockEndY,$ffffFFFF
        sourceWindow\deleteMode = True
        PED_RedrawSource{}
      EndIf
    EndIf
    ped\blockmarkRemovalMode = 0
  EndIf
Return


.menu_insertline:  ; insertStr may come from menu_undeleteline...
  If insertStr.s = "" Then insertStr = "leere Zeile"
  *newLine.sourceLine = PED_CreateNewSourceLine{insertStr.s}
  If *newLine <> 0
    ped\ptrCurrentSourceData\SourceChanged = $FFFF
    PED_UpdateBlockPosY{ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine}
    If PED_InsertSourceLine{*newLine}
      PED_ScrollVertical{#SCROLL_DOWN, ped\ptrCurrentSourceData\DisplayLine}
      PED_PrintCurrentSourceLine{False}
      ;PED_RedrawSource{}
      Gosub update_linenumbers
    Else
      error{"Couldn't insert sourceline!"}
    EndIf
    insertStr = ""
  Else
    Pop If
    Goto memAlert_CloseSource
  EndIf
Return


.menu_undeleteline:
  log_Print{"menu undeleteline called"}
  insertStr.s = Peek.s(ped\ptrLineUndeleteStore)
  If FLen(insertStr) > 0
    log_Print{"undeleting line: " + insertStr}
    Gosub menu_insertline
  Else
    log_Print{"no data to undelete."}
  EndIf
Return


.menu_deleteline:
  log_Print{"menu deleteline called"}

  ped\ptrCurrentSourceData\SourceChanged = $FFFF

  ; update the blockmark if set
  If ped\ptrCurrentSourceData\BlockEndY<> $ffffFFFF
    If ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine > ped\ptrCurrentSourceData\BlockStartY
      If ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine < ped\ptrCurrentSourceData\BlockEndY
        ped\ptrCurrentSourceData\BlockEndY - 1
        If ped\ptrCurrentSourceData\BlockEndY < ped\ptrCurrentSourceData\BlockStartY
          ped\ptrCurrentSourceData\BlockEndY = 0
        EndIf
      EndIf
    Else
      ped\ptrCurrentSourceData\BlockStartY - 1
      ped\ptrCurrentSourceData\BlockEndY - 1
    EndIf
  EndIf


  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *nextLine.sourceLine = *currentLine\nextLine
  *prevLine.sourceLine = *currentLine\previousLine
  If *nextLine <> 0
    If cutLine{*currentLine}
      ped\ptrCurrentSourceData\CurrentSourceLine = *nextLine
      PED_StoreSourceLine{*currentLine}
      PED_DeleteSourceLine{*currentLine}
      ped\ptrCurrentSourceData\TotalLines - 1
      PED_ScrollVertical{#SCROLL_UP, ped\ptrCurrentSourceData\DisplayLine}
      Gosub draw_new_sourceline_bottom
    EndIf
  Else
    If *prevLine <> 0
      If cutLine{*currentLine}
        ped\ptrCurrentSourceData\CurrentSourceLine = *prevLine
        ped\ptrCurrentSourceData\LastSourceLine = *prevLine
        PED_StoreSourceLine{*currentLine}
        PED_DeleteSourceLine{*currentLine}
        ped\ptrCurrentSourceData\TotalLines - 1
        If ped\ptrCurrentSourceData\DisplayLineOffset
          ped\ptrCurrentSourceData\DisplayLineOffset - 1
          PED_ScrollVertical{#SCROLL_UP,ped\ptrCurrentSourceData\DisplayLine}
          Gosub draw_new_sourceline_top
        Else
          PED_ScrollVertical{#SCROLL_UP, ped\ptrCurrentSourceData\DisplayLine}
          !PED_DecreaseDisplayLine
        EndIf
      EndIf
    Else
      PED_StoreSourceLine{*currentLine}
      PED_DeleteSourceLine{*currentLine}
      *newLine.sourceLine = PED_CreateNewSourceLine{""}
      ped\ptrCurrentSourceData\FirstSourceLine = *newLine
      ped\ptrCurrentSourceData\LastSourceLine = *newLine
      ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
      Gosub clear_sourcewindow
    EndIf
  EndIf
  log_Print{"menu deleteline finished"}
Return

.menu_joinline:
USEPATH ped\ptrCurrentSourceData

  log_Print{"menu joinlines called."}
  *currLine.sourceLine = \CurrentSourceLine
  If *currLine\nextLine = 0
    log_Print{"no next line to join."}

    Gosub set_pointer_normal
    Pop If: Return
  Else
    *nextLine.sourceLine = *currLine\nextLine
  EndIf

  \SourceChanged = $FFFF

  ; -- adjust blockmark
  ; TODO: currently not necessary, as the blockmark ist resetted after each key event

  ; -- get end of line in textbuffer
  lineaddr.l = Peek.l(?textbufferaddr) + \TextBufferOffset
  strline$ = ""
  runner.w = #MAX_Columns
  Repeat
    runner - 1
    actbyte.b = Peek.b(lineaddr + runner)
  Until actbyte <> $20 OR runner = 0  
  If runner 
    runner + 1
    strline$ = Peeks$(lineaddr,runner)
  EndIf

  strline$ + StripTrail$(PED_Detoke{*nextLine},@" ")
  strline$ = PED_ParseText{strline$}
  strline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))
  *newLine.sourceLine = PED_CreateNewSourceLine{strline$}
  PED_ReplaceCurrentSourceLine{*newLine}
  If cutLine{*nextLine}
    PED_DeleteSourceLine{*nextLine}
    \TotalLines - 1
  EndIf
  PED_RedrawSource{}
Return

 
.splitlines:
  USEPATH ped\ptrCurrentSourceData
  \SourceChanged = True

  tmpColumn.w = \ColumnsOffset + \Column
  ;TODO: Blockhandling, if PED supports writing in Blockmarks again, see old asmcode in JL_0_2906

  ;-- get the string until cursorposition
  \Column = 0
  lineaddr.l = Peek.l(?textbufferaddr) + \TextBufferOffset
  While Peek.b(lineaddr + \Column) = $20 AND (\Column < #MAX_Columns)
    \Column + 1
  Wend
  ;log_Print{">>" + Peeks$(lineaddr,#MAX_Columns)}
  ; add spaces for auto indentation: align to beginning of current line
  If \Column = #MAX_Columns OR \Column = tmpColumn Then \Column = 0                                                                                                                                                                                      

  ;-- calculate ColumnsOffset
  If \ColumnsOffset
    \ColumnsOffset = 0
    If \Column > sourceWindow\visibleColumns
      \Column - sourceWindow\visibleColumns
      \ColumnsOffset = sourceWindow\visibleColumns
      If \Column > sourceWindow\visibleColumns
        \Column - sourceWindow\visibleColumns
        \ColumnsOffset + sourceWindow\visibleColumns
      EndIf
    EndIf 
  EndIf
  ;log_Print{"columnsoffset: " + Str$(\ColumnsOffset)}
  ;log_Print{"columns      : " + Str$(\Column)}

  ;-- save rest of line and remove from current line
  restString.s = ""                                                                                                                                                                                                                                      
  For tcol.w = tmpColumn To #MAX_Columns-1
    restString + Chr$(Peek.b(lineaddr + tcol))    ; copy rest of line to parsebuffer
    Poke.b lineaddr + tcol, $20                 ; remove rest of line from textbuffer
  Next tcol
  restString = SPACE$(\Column) + restString
  ;log_Print{"length of restline: " + Str$(Len(restString))}

  ;-- update current line
  strline$ = Peeks$(lineaddr,#MAX_Columns)
  strline$ = PED_ParseText{strline$}
  strline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))
  *newLine.sourceLine = PED_CreateNewSourceLine{strline$}
  PED_ReplaceCurrentSourceLine{*newLine}

  ;-- append rest of line as new line
  newline$ = PED_ParseText{restString}
  newline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))
  ;log_Print{"new line *" + newline$ + "*"}
  *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
  appendLine{\CurrentSourceLine,*newLine} : \TotalLines + 1

  Gosub movecursorlinedown
  PED_RedrawSource{}
Return


.insertreturn: 
  USEPATH ped\ptrCurrentSourceData

  If \BlockEndY <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : Gosub handle_blockmark
  EndIf

  sourceWindow\redrawFlag = True
  !PED_CursorOff

  ; SHIFT pressed as well ?
  ; if pressed, do notsplit current line at cursor pos!
  ;log_Print{"qualifier: " + Hexw$(\QualifierStore AND 3)}                                                                                                                                                                                               
  If (\QualifierStore AND 3) = 0                                                                                                                                                                                                                         
    log_Print{"split current line, BlockEndY = " + Hex$(\BlockEndY)}
    Goto splitlines                      
  EndIf

  ;-- if autoindent, align cursor for line
  If NOT pedconfig\auto_indent
    \Column = 0
  Else
    \Column = -1
    Repeat
      \Column + 1
    Until Peek.b(\CurrentSourceLine + 9 + \Column) <> $20
    ;log_Print{"indent after return: " + Str$(\Column)}
  EndIf

  *newLine.sourceLine = PED_CreateNewSourceLine{""}
  If *newLine = 0
    Pop If
    Goto memAlert_CloseSource
  EndIf
  appendLine{\CurrentSourceLine,*newLine} : \CurrentSourceLine = *newLine
  \SourceChanged = True
  \TotalLines + 1

  PED_UpdateBlockPosY{\DisplayLineOffset + \DisplayLine}

  If \ColumnsOffset > 0
    log_Print{"reset columnsoffset, redraw with offset"}
    \ColumnsOffset = 0
    Gosub redrawWithOffset
  EndIf

  PED_UpdateStatusArea{#STATUS_SCROLLERS}                                                                                                                                                                                                                

  If sourceWindow\visibleLines <= \DisplayLine + 1 + sourceWindow\boundLinesY
    log_Print{"scroll up"}
    Gosub update_sourcewindow_bottom

    tmpCurrentColumn.w = 0
    tmpCurrentLine.l = \DisplayLine + \DisplayLineOffset
    !updateBlockMark{tmpCurrentLine, tmpCurrentColumn}
    If \StateBlockMark Then PED_RedrawSource{}
  Else
    log_Print{"scroll down"}
    ;-- scroll rest of source downwarts
    PED_ScrollVertical{#SCROLL_DOWN,\DisplayLine + 1}
    Gosub update_sourcewindow_bottom

    tmpCurrentColumn.w = 0
    tmpCurrentLine.l = \DisplayLine + \DisplayLineOffset
    !updateBlockMark{tmpCurrentLine, tmpCurrentColumn}
    If \StateBlockMark Then Gosub redrawWithOffset
  EndIf
Return

.menu_top:
  PED_HistoryAddEntry{}
  PED_GotoLine{0,#LINE_START}
Return

.menu_bottom:
  PED_HistoryAddEntry{}
  PED_GotoLine{ped\ptrCurrentSourceData\TotalLines, #LINE_START}
Return


; -- handle compilermenu
; menuids
; $5A: Leerzeile im Menu
; $50: Compile & Run
; $5b: Save & Create Exec
; $5c: Save & Compile & Run
; $5d: Debug / Runerrors On 10*slower Code
; $5e: Create Executable absolut Smallest

; $57: calculator
; $58: reload all libs
; $59: open sourcebrowser

.call_compilermenuitem:              ; (Menuitem in D6)
  compile_state.l = 0
  log_Print{"we call the compiler with menu " + Hex$(_menuitem.l)}

  Select _menuitem.l
  Case $5A                             ; empty menuitem number
    Return

  Case #MENU_CALCULATOR
    Gosub set_pointer_busy
    Gosub save_tempprefs                 ; save data to prevent crashes if the calculation routine is called an it coms back to Ped

    WZ_LockAllOpenWindows{}                                                                                                                                                                                                                              
    Gosub open_calculator
    WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                            
    Gosub read_tempprefs                 ; restore data to prevent crashes if the calculation routine is called an it comes back to Ped

    Gosub set_pointer_normal

  Case #MENU_DEFINITIONBROWSER
    Gosub open_definitionbrowser

  Case #MENU_SETCLIARGS
    Gosub set_pointer_busy
    WZ_LockAllOpenWindows{}                                                                                                                                                                                                                              
    Gosub open_cliarguments
    WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                            
    Gosub set_pointer_normal

  Case #MENU_SOURCEBROWSER
    Gosub open_sourcebrowser

  Case #MENU_COMPILERSETTINGS
    Gosub set_pointer_busy
    WZ_LockAllOpenWindows{}                                                                                                                                                                                                                              
    Gosub menu_compilersettings
    If WZ_IsOpen{"WIN_NEWTYPE"}
       Use Window WZID("WIN_NEWTYPE")
       PED_UpdateDefinitionBrowser{#DEFBROWSER_RESET}
    End If
    WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                            
    Gosub update_debuggertoggle
    Gosub save_tempprefs
    Gosub set_pointer_normal

  Case #MENU_COMPILERUN
    ;TEDSetLabelList {?comPtr_LabelList}
    ;TEDSetLabelCount{ped\ptrCurrentSourceData\LabelCounter}
    Gosub call_compiler

  Case #MENU_RUN
    Gosub call_compiler

  Case #MENU_SAVECREATEEXE
    log_Print{"savecreateexe"}
    Gosub menu_save
    Gosub call_compiler

  Case #MENU_SAVECOMPILERUN
    Gosub menu_save
    _menuitem = #MENU_COMPILERUN
    Gosub call_compiler

  Case #MENU_RELOAD_USERLIBS
    log_Print{"reload libs"}

    ; clear intructioncache as the tokennumbers may change
    PED_ClearTokencache{}    

    Gosub call_compiler

    Gosub read_tempprefs

  Default
    Gosub call_compiler
  End Select

  log_Print{"doing stuff after compiler has finished."}                                                                                                                                                                                                  
  Gosub update_title_sourcewindow
  PED_UpdateStatusArea{}                                                                                                                                                                                                                                 
  log_Print{"checking compiler return state " + Str$(compile_state) }

  ;-- handle compile error??
  Select compile_state.l
  Case -1 : 
    ; everything went ok, nothing to do
  Case -2
    PED_RedrawSource{}
  Default ; we have got an error line, jump to that pos                                                                                                                                                                                                  
    PED_GotoLine{compile_state, #LINE_END}                                                                                                                                                                                                               
  End Select

  log_Print{"all done with compiler, returning to IDE..."}
Return

.call_compiler:
  ; set infos for Compiler to run functions
  If Peek.l(?comFunc_CallMenuEntry) = 0
    error{"Compiler not available!"}
    Return
  EndIf

  Gosub set_CurrentDir

  WZ_LockAllOpenWindows{}

  CompileMenuCallID.l = _menuitem - #MENU_COMPILERUN
  log_Print{"*** calling compiler with function id [" + Hex$(CompileMenuCallID) + "]"}
  Gosub Open_CompileStatus_Window                         ; open Compile status window if we need it
  GetD0 CompileMenuCallID : MOVE.l D0,-(a7)
  !asm
  MOVE.l (a7)+,D6
  MOVEA.l comPtr_FirstSourceLine,A5
  MOVE.l comLong_TotalLines,D7
  MOVE.l comFunc_CallMenuEntry,a0 : JSR (A0)               ; call compilerfunction for the menuentry
  MOVE.l D0,-(a7)
  !basic
  MOVE.l (a7)+,D0
  compile_state.l = PutD0                                  ; get the return code of compiler

  Delay_ 10                                                ; without waiting we get s serious crash, dont know why!!

  Gosub update_debuggertoggle                              ; update the state to the commenu "Create Debug Code"

  previoussearch_instruction$ = "|"

  Gosub update_versiongadgets

  Gosub Close_CompileStatus_Window                         ; close compile status window if it is open
  WZ_UnlockAllOpenWindows{}
  log_Print{"*** compiler finished with return code [" + Hex$(compile_state) + "]"}
Return

.event_menu:
  log_Print{"selected menuitem: " + Hex$(_menuitem.l)}

  ;-- handle compiler menues
  If (_menuitem >= #MENU_COMPILERUN) AND (_menuitem < #MENU_NEW)    ;$64 - $50
    Gosub call_compilermenuitem
    Return
  EndIf

  ;-- handle custom menues
  If (_menuitem >= #MENU_CUSTOMEDIT-1) AND (_menuitem < $F00)       ; 259 -$f00
    Gosub call_pluginmenuentry             ;plugin menuitem
    Return
  EndIf

  ;-- handle dynamic menuentries, ( last filenames )
  If _menuitem >= #MENU_TEMPLATE AND _menuitem<#MENU_TEMPLATE+#MAX_MENUTEMPLATES
    Gosub load_template
    PED_UpdateStatusArea{#STATUS_SCROLLERS}
    Return
  EndIf


  ;-- handle other menues
  Select _menuitem
  Case #MENU_INSERTFILENAME
    aslfr_SetRequesterTitle{0,!TRANS{"Select a filename to insert in source"},"",""}
    aslfr_SetPath{0,pedconfig\mainDir,"",""}
    If aslfr_Request{0,False,False,False,sourceWindow\pedScreen}
      a$ = aslfr_GetNextFile{} : Gosub insertstring
    EndIf

  Case #MENU_OPENFILEUNDERCURSOR
    strline$ = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
    _file$ = PED_GetWordAtPos{strline$, ped\ptrCurrentSourceData\Column,False,False}
    log_Print{"open file under cursor [" + _file$+ "]"}
    If _file$ <> ""
      tmp_string = _file$
      If NOT dos_Exist{tmp_string}
        tmp_string = dos_AddPart{pedconfig\includeDir,_file$}
        log_Print{"not found, trying " + tmp_string}
      EndIf
      If NOT dos_Exist{tmp_string}
        tmp_string = dos_AddPart{Peek.s(&ped\ptrCurrentSourceData\CurrentDir),_file$}
        log_Print{"not found, trying " + tmp_string}
      EndIf
      If dos_Exist{tmp_string}
        log_Print{"open file under cursor: " + tmp_string}
        !PED_LoadSource{tmp_string,False,True,True}  
      Else
        log_Print{"could not find file: " + tmp_string}
      EndIf
    EndIf

  Case #MENU_DELETETOEOL
    log_Print{"menuentry DELETE TO EOL"}
    ped\ptrCurrentSourceData\KeyBeforeReturn = last_vankey       ; save keycode
    CursorXTarget.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset
    ; delete all until end of line (replace with spaces)
    lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
    For cupos.w = CursorXTarget To #MAX_Columns-1
      Poke.b lineaddr + cupos, $20
    Next cupos
    Gosub updateSourceLine

  Default
      _menutable.l = ?menutable
      menu_found.b = False : menu_ptr.l = 0 : menu_number.w = 0
      menu_refresh.l = 0
      While (NOT menu_found) AND Peek.l(_menutable) <> 0
        menu_number = Peek.l(_menutable)
        If menu_number = _menuitem
          menu_found = True
          menu_refresh = Peek.l(_menutable + 4)
          menu_ptr = Peek.l(_menutable + 8)
        Else
          _menutable + 12
        EndIf
      Wend
      If menu_ptr
        log_Print{"menu call execute at " + Hex$(menu_ptr) + "..."}
        GetD0 _menuitem : MOVE.l d0,D6 : Call menu_ptr
        log_Print{"menu call ended."}
        If menu_refresh
          PED_UpdateStatusArea{#STATUS_SCROLLERS}
        EndIf
      EndIf
  End Select
Return


.reset_sourcewindow:
  log_Print{"*** reset_sourcewindow called."}

  Gosub calc_SourceWindowDimensions
  Gosub clear_sourcewindow
  Gosub reset_labellist
  ;PED_UpdateStatusArea{#STATUS_SCROLLERS}

  Gosub analyze_loadedsource
  Gosub set_CurrentDir

  log_Print{"redraw of sourcewindow"}
  PED_UpdateStatusArea{#STATUS_REDRAW}                                                                                                                                                                                                                   
  PED_RedrawSource{}
Return

.load_template:
  mcounter.l = _menuitem-#MENU_TEMPLATE
  log_Print{"called menu new template with subitem: " + Str$(mcounter)}

  ResetList templates()
  For n.l = 0 To mcounter - 1
    NextItem templates()
  Next
  If NextItem(templates())
    log_Print{"opening new source tab."}

    loadsourcefilename.s = templates()\filename
    log_Print{"selected template: " + loadsourcefilename}
    ;Gosub menu_new
    ;Gosub load_source
    !PED_LoadSource{templates()\filename,False,False,True}

  Else
    log_Print{"unknown template, opening a new file instead."}
    tmp_string = !TRANS{"unnamed"}
    Gosub menu_loadAsNew
  EndIf
Return



.menu_new:
  log_Print{"*** menu new called."}
  ;log_Print{"value of ped\firstLoadedEntry: " + Hex$(ped\firstLoadedEntry)}

  ; -- alloc memory for a new fileentry
  MOVE.l #comDef_XtraEnd-comLongLong_XtraBegin,d0 : tmpMemSize.l = PutD0
  *newEntry.sourceEntry = PED_AllocMem{tmpMemSize}
  If *newEntry = 0
    Gosub display_memoryalert
    Return
  EndIf
  log_Print{"new fileentry allocated at: " + Hex$(*newEntry) }
  log_Print{"entry size: " + Str$(tmpMemSize)}
  log_Print{"newtype size: " + Str$(SizeOf.sourceEntry)}

  ; -- adding the new source into the source list
  If ped\firstLoadedEntry = 0
    log_Print{"no current fileentry available, creating first one ..."}
    ped\firstLoadedEntry = *newEntry
    ped\firstSourceEntry = *newEntry
    ped\currentSourceEntry = *newEntry
    *newEntry\previousEntry = 0
    *newEntry\nextEntry = 0
    ;log_Print{"currentEntry at " + Hex$(ped\currentSourceEntry)}
    Gosub getCurrentSourceData
    Gosub clear_sourcebuffer
    ;log_Print{"Totallines = " + Str$(ped\ptrCurrentSourceData\TotalLines)}
  Else
    log_Print{"we already have an opened source file, so adding a new tab..."}
    ; -- save changes to current source line
    Gosub storeline
    Gosub storeCurrentSourceData
    
    log_Print{"currentEntry at " + Hex$(ped\currentSourceEntry)}
    *sourceEntry.sourceEntry = ped\currentSourceEntry
    *nextEntry.sourceEntry = *sourceEntry\nextEntry
    If *nextEntry <> 0                         ; insert new source between current source an next source entry ?
      *sourceEntry\nextEntry = *newEntry       ; nextfile -> newentry
      *newEntry\previousEntry = *sourceEntry   ; newentry\prev -> currentEntry
      *newEntry\nextEntry = *nextEntry         ; newentry\next -> nextfile
      *nextEntry\previousEntry = *newEntry     ; nextfile\prev -> newentry
    Else
      ped\firstLoadedEntry = *newEntry
      *sourceEntry\nextEntry = *newEntry       ; nextfile -> newentry
      *newEntry\previousEntry = *sourceEntry
      *newEntry\nextEntry = 0
    EndIf
    ped\currentSourceEntry = *newEntry
    Gosub clear_sourcebuffer
    Gosub reset_sourcewindow
  EndIf
Return

.menu_loadAsNew:
  log_Print{"*** menu opennew called."}
  Gosub menu_new
  Gosub menu_load
  Gosub storeCurrentSourceData
  PED_UpdateStatusArea{#STATUS_SCROLLERS}
Return

.menu_load:
  log_Print{"*** menu load called."}

  If ped\ptrCurrentSourceData\SourceChanged
    dummy.l = ask{!TRANS{"You have unsaved changes!"},!TRANS{"Continue|Cancel"},!TRANS{"Load File"}}
    If dummy = 0
      Pop If : Pop If
      Return
    EndIf
  EndIf

  aslfr_SetRequesterTitle {1,!TRANS{"Load source file"},!TRANS{"Load"},!TRANS{"Cancel"}}
  If pedconfig\use_filepattern
    aslfr_SetPath  {1,ped\currentDir,ped\currentFile,ped\filePattern,False}
  Else
    aslfr_SetPath  {1,ped\currentDir,ped\currentFile,"",False}
  EndIf
  ASL_x = 14
  ASL_y = 36
  If aslfr_Request {1,False,False,False,-1,False}
    loadsourcefilename.s = aslfr_GetNextFile{}
    If loadsourcefilename.s <> ""
      ;Gosub load_source
      !PED_LoadSource{loadsourcefilename,False,True,True}
    EndIf
  EndIf
  log_Print{"menu load finished."}
Return

.storeCurrentSourceData:                      ;copy view data
  ; this function is called after a succesfull load of a sourcecode and befor and after a switch of the sourcecode  tomsmart1
  MOVE.l LabelList_FirstVisableItemNumber@(a5),comLong_Label1VisableItem      ; same as Poke
  MOVE.l comLong_Label1VisableItem,comLong_Label1VisableItemStore             ; to update both for a unified LabelList restore routine that work by load and switch of a Sourcecode  tomsmart1

  GetReg A0, ped\currentSourceEntry : ADDQ.l #8,A0    ; skip listentries (next/previous sourceentry)
  LEA comLongLong_XtraBegin + 8,A1                    ; skip "tedsdoc!"
  MOVE.l #comDef_XtraEnd-comLongLong_XtraBegin - 8, D0 : SUBQ.w #1,D0
 'copyloop
    MOVE.b (A1)+,(A0)+
  DBF D0,'copyloop
Return

 
.getCurrentSourceData:
  ; zurueckholen der xtra-settings nach sourcewechsel
  GetReg A0,ped\currentSourceEntry : ADDQ.l #8,A0    ; skip listentries (next/previous sourceentry)
  LEA comLongLong_XtraBegin + 8,A1                   ; skip "tedsdoc!"
  MOVE.l #comDef_XtraEnd-comLongLong_XtraBegin - 8, D0 : SUBQ.w #1,D0
 'copyloop:
    MOVE.b (A0)+,(A1)+
  DBF D0,'copyloop

  ped\ptrCurrentSourceData = ?comLongLong_XtraBegin
  ;-- restore some windows
  Gosub RestoreLabelAndNewtypeWin
Return

.selectTab:  ; D0: current entry in opened file table
  selectedEntry.l = PutD0

  If ped\currentSourceEntry <> selectedEntry
    log_Print{"switching to tab."}
    Gosub storeCurrentSourceData
    Gosub save_tempprefs
    ped\currentSourceEntry = selectedEntry
    Gosub getCurrentSourceData
    Gosub read_tempprefs

    Gosub reset_sourcewindow
    PED_UpdateStatusArea{#STATUS_REDRAW}                                                                                                                                                                                                                 
  Else
    log_Print{"source is already at current tab."}
  EndIf
Return


.menu_previousfile:
  Gosub storeCurrentSourceData
  Gosub save_tempprefs

  If ped\currentSourceEntry\previousEntry
    ped\currentSourceEntry = ped\currentSourceEntry\previousEntry
  Else
    If ped\firstLoadedEntry = ped\currentSourceEntry
      Pop If : Pop If : Return
    Else
      ped\currentSourceEntry = ped\firstLoadedEntry
    EndIf
  EndIf
  Gosub getCurrentSourceData
  Gosub reset_sourcewindow
  Gosub read_tempprefs

  PED_UpdateStatusArea{#STATUS_REDRAW}                                                                                                                                                                                                                   
Return


.menu_nextfile:
  Gosub storeCurrentSourceData
  Gosub save_tempprefs

  If ped\currentSourceEntry\nextEntry
    ped\currentSourceEntry = ped\currentSourceEntry\nextEntry
  Else
    If ped\firstSourceEntry = ped\currentSourceEntry
      Pop If : Pop If : Return
    Else
        ped\currentSourceEntry = ped\firstSourceEntry
    EndIf
  EndIf
  Gosub getCurrentSourceData
  Gosub reset_sourcewindow
  Gosub read_tempprefs

  PED_UpdateStatusArea{#STATUS_REDRAW}                                                                                                                                                                                                                   
Return

.menu_copy:
  log_Print{"menu copy called."}
  If ped\ptrCurrentSourceData\BlockEndY = -1 Then Return

  Gosub getCountOfMarkedLines
  strline$ = PED_Detoke{*tempLine}
  strlng.w = FLen(strline$)
  If strlng = 0
    log_Print{"no text to copy..."}
  Else
    If getCountOfMarkedLines.l < 2
      If strlng >= ped\ptrCurrentSourceData\BlockEndX + 1
        strlng = ped\ptrCurrentSourceData\BlockEndX - ped\ptrCurrentSourceData\BlockStartX + 1
      Else
        strlng = strlng - (ped\ptrCurrentSourceData\BlockStartX + 1)
      EndIf
      ;log_Print{"before peeking " + Str$(strlng)}
      strline$ = Mid$(strline$,ped\ptrCurrentSourceData\BlockStartX + 1, strlng)
      log_Print{">> [" + strline$ + "]"}

      clipboard_WriteText{&strline$}
      log_Print{"moved to clipboard"}
    Else
      *iff.IFFHandle = AllocIFF_()
      If *iff
        *iff\iff_Stream = OpenClipboard_ (0)
        If *iff\iff_Stream
          InitIFFasClip_ *iff
          If (OpenIFF_ (*iff, #IFFF_WRITE)=0)
            If (PushChunk_ (*iff, #ID_FTXT, #ID_FORM, #IFFSIZE_UNKNOWN)=0)
              If (PushChunk_ (*iff, 0, #ID_CHRS, #IFFSIZE_UNKNOWN)=0)
                ; VerticalCopyMode mssing ??
                If strlng <= (ped\ptrCurrentSourceData\BlockStartX + 1)
                  ; end of String...
                  strlng = 1
                  strline$ = Chr$(10)
                Else
                  strlng = strlng - (ped\ptrCurrentSourceData\BlockStartX + 1)
                  strline$ = Mid$(strline$, ped\ptrCurrentSourceData\BlockStartX + 1, strlng) + Chr$(10)
                EndIf
                ;log_Print{Str$(Len(strline$))}
                ;log_Print{">"+strline$+"<"}
                WriteChunkBytes_ *iff, &strline$, Len(strline$)

                ; copy most lines
                ;log_Print{"copy other lines"}
                For si.w = 1 To getCountOfMarkedLines - 2
                  If *tempLine\nextLine
                    *tempLine = *tempLine\nextLine
                    strline$ = PED_Detoke{*tempLine}
                    strlng.w = FLen(strline$)
                    If ped\verticalCopyMode <> 0 AND (strlng > ped\ptrCurrentSourceData\BlockStartX+1)
                      strlng = strlng - (ped\ptrCurrentSourceData\BlockStartX+1)
                      strline$ = Mid$(strline$, ped\ptrCurrentSourceData\BlockStartX+1, strlng)  + Chr$(10)
                    Else
                      strline$ + Chr$(10)
                    EndIf
                    WriteChunkBytes_ *iff,&strline$,Len(strline$)
                  Else
                    error{"Error copying to clipboard: no next line!",#log_error}
                  EndIf
                Next si

                ; copy last selected Line
                ;log_Print{"copy last line"}
                *tempLine = *tempLine\nextLine
                If *tempLine
                  strline$ = PED_Detoke{*tempLine}
                  strline$ = Left$(strline$,ped\ptrCurrentSourceData\BlockEndX+1)
                  strlng = FLen(strline$)
                  If ped\verticalCopyMode <> 0 AND (strlng > ped\ptrCurrentSourceData\BlockStartX+1)
                    strline$ = UnRight$(strline$,ped\ptrCurrentSourceData\BlockStartX+1) + Chr$(10)
                  Else
                    strline$ = strline$ + Chr$(10)
                  EndIf
                  WriteChunkBytes_ *iff, &strline$, Len(strline$)
                EndIf
                PopChunk_ *iff
              End If

              PopChunk_ *iff
            Else
              error{"Could not write chunks."}
            End If
            CloseIFF_ *iff
          Else
            error{"Could not open IFF."}
          End If
          CloseClipboard_ *iff\iff_Stream
        Else
          error{"Could not open Clipboard."}
        End If
        FreeIFF_ *iff
      Else
        error{"Could not AllocIFF."}
      End If
    EndIf
  EndIf

  If ped\cutMode = 0
    !PED_CursorOff
    ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
    PED_RedrawSource{}                                    ; clear block mark
    ped\cutMode = 0
  EndIf
exit_copy:
  log_Print{"copy finished."}
Return

.getCountOfMarkedLines:
  diff.l = 0
  log_Print{"BlockStartX: " + Str$(ped\ptrCurrentSourceData\BlockStartX)}
  log_Print{"BlockStartY: " + Str$(ped\ptrCurrentSourceData\BlockStartY)}
  log_Print{"BlockEndX  : " + Str$(ped\ptrCurrentSourceData\BlockEndX)}
  log_Print{"BlockEndY  : " + Str$(ped\ptrCurrentSourceData\BlockEndY)}
  *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  currLine.l = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
  log_Print{"currline   : " + Str$(currLine)}
  If currLine < ped\ptrCurrentSourceData\BlockStartY
    diff = ped\ptrCurrentSourceData\BlockStartY - currLine
    For si.w = 1 To diff
      If *tempLine\nextLine Then *tempLine = *tempLine\nextLine Else error{"Error copying to clipboard!"}
    Next si
  Else
    If currLine > ped\ptrCurrentSourceData\BlockStartY
      diff = currLine - ped\ptrCurrentSourceData\BlockStartY
      For si.w = 1 To diff
        If *tempLine\previousLine Then *tempLine = *tempLine\previousLine Else error{"Error copying to clipboard!"}
      Next si
    EndIf
  EndIf
  getCountOfMarkedLines.l = ped\ptrCurrentSourceData\BlockEndY - ped\ptrCurrentSourceData\BlockStartY + 1
Return

.menu_cut:
  log_Print{"menu cut called."}

  If ped\ptrCurrentSourceData\BlockEndY = $FFFFffff
    log_Print{"no block selected."}
    Return
  EndIf 

  ped\cutMode = True : Gosub menu_copy
  Gosub menu_kill
Return


.menu_paste:
  log_Print{"menu paste called."}

  ped\pasteMode = $FFFF
  Gosub do_paste
  ped\pasteMode = $0000
Return


.menu_kill:
  log_Print{"menu Kill called."}

  If ped\ptrCurrentSourceData\BlockEndY = $FFFFffff
    log_Print{"no block selected."}
    Return
  EndIf

  Gosub getCountOfMarkedLines
  log_Print{"marked Lines: " + Str$(getCountOfMarkedLines)}
  strline$ = PED_Detoke{*tempLine}
  log_Print{"source of first blockline: " + Left$(strline$,20)}
  *previousLine.sourceLine = *tempLine\previousLine

  For si.w = 1 To getCountOfMarkedLines
    strline$ = PED_Detoke{*tempLine}
    log_Print{Str$(si) + " deleting " + Left$(strline$, 20)}

    ptr_line.l = *tempLine
    *tempLine = *tempLine\nextLine
    PED_FreeMem{ptr_line}

    ped\ptrCurrentSourceData\TotalLines - 1
  Next si

  If *tempLine
    *previousLine\nextLine = *tempLine          ; set templine as next line of line before block
    *tempLine\previousLine = *previousLine      ; set line after block as nextline of line before block
  Else
    *previousLine\nextLine = 0
    ped\ptrCurrentSourceData\LastSourceLine = *newLine
  EndIf

  ped\ptrCurrentSourceData\CurrentSourceLine = *previousLine

  !PED_ResetBlockflag

  If ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine > ped\ptrCurrentSourceData\TotalLines
    ped\ptrCurrentSourceData\TotalLines - 1

    ped\ptrCurrentSourceData\DisplayLineOffset = ped\ptrCurrentSourceData\TotalLines
    ped\ptrCurrentSourceData\DisplayLine = 0

    ped\ptrCurrentSourceData\Column = ped\ptrCurrentSourceData\BlockStartX
    Gosub update_currsourceline
    PED_RedrawSource{}
    PED_GotoLine{ped\ptrCurrentSourceData\DisplayLineOffset}
  Else
    ped\ptrCurrentSourceData\Column = ped\ptrCurrentSourceData\BlockStartX
    Gosub update_currsourceline
    PED_RedrawSource{}
  EndIf
Return

.menu_saveascii:
  tmp_string = PED_RequestFile{"", "", "Select file to save as ASCII...", "(#?.info)"}
  If tmp_string ="" Then Return

  log_Print{"write ab2: opening file"}
  Gosub set_pointer_busy
  PED_ShowMessage{!TRANS{"Exporting to ASCII-File"} + "..."}

  *write_fh.l = Open_(&tmp_string, #HUNK_RELOC_8__MODE_NEWFILE)
  If *write_fh = 0
    dummy.l = ask{!TRANS{messageErrorWriteFile},!TRANS{"OK"},"Error!"}
  Else
    If ped\ptrCurrentSourceData\TotalLines > 0
      *tempLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine

      If ped\DoTokenize <> 0
        log_Print{"write ab2: writing detokenized file"}

        ;-- detokenize and write to file
        numlines.l = ped\ptrCurrentSourceData\TotalLines
        totalLength.l = 0
        For n.l = 0 To numlines - 1
          baseptr.l = *tempLine + 9
          sptr.l = baseptr
          While Peek.b(sptr) : sptr + 1 : Wend
          totalLength + sptr - baseptr + 1
          *tempLine = *tempLine\nextLine
        Next
        tmp.l      = AllocVec_(totalLength,#MEMF_CLEAR)
        If tmp
          node.l     = ped\ptrCurrentSourceData\FirstSourceLine
          dptr.l     = tmp
          For n.l=0 To numlines-1
            baseptr.l = node+$9 ;Peek.l (node+$9)
            sptr.l    = baseptr
            Repeat
              char.b = Peek.b(sptr)
              Poke.b dptr,char : sptr +1 : dptr+1
            Until char=0
            node = Peek.l(node)
          Next
          plainLength.l = preproc_DetokenizeFP{*PreProcessor, tmp, totalLength, *write_fh}
          FreeVec_ tmp
        Else
          error{!TRANS{"Not enough memory for temp buffer!"}}
        End If
      Else
        ;-- directly write to file
        log_Print{"write ab2: writing text line-by-line to file"}
        Repeat
          baseptr.l = *tempLine + 9
          strLength.w = Peek.b(baseptr + 8) - 1
          strLine$ = Peeks$(baseptr,strLength) + Chr$(10)
          Write_ *write_fh, &strLine$, Len(strLine$)
          *tempLine = *tempLine\nextLine
        Until *tempLine = 0
      EndIf
    EndIf
    log_Print{"write ab2: closing file"}
    Close_ *write_fh : *write_fh = 0
  EndIf

  WZ_UnlockAllOpenWindows{}
  Gosub set_pointer_normal
  WZ_HideMessage{}
  PED_ShowMessage{""}
Return

.menu_saveblockas:
  If ped\ptrCurrentSourceData\BlockEndY > -1
    blockfn$ = PED_RequestFile{"","","Name to save block as","(#?.info)"}
    If blockfn$ <> ""
      *write_fh.l = Open_(&blockfn$, #HUNK_RELOC_8__MODE_NEWFILE)
      If *write_fh <> 0
        Gosub set_pointer_busy
        Gosub getCountOfMarkedLines
        strline$ = PED_Detoke{*tempLine}
        strlng.w = FLen(strline$)

        If getCountOfMarkedLines.l < 2
          If strlng >= ped\ptrCurrentSourceData\BlockEndX
            strlng = ped\ptrCurrentSourceData\BlockEndX - ped\ptrCurrentSourceData\BlockStartX + 2
          EndIf
          strlng = strlng - 1
          strline$ = Mid$(strline$, ped\ptrCurrentSourceData\BlockStartX, strlng) ;+ Chr$(10)
          ;log_Print{">>" + strline$}
          Write_ *write_fh,&strline$,FLen(strline$)
        Else
          If strlng <= ped\ptrCurrentSourceData\BlockStartX
            ; end of String...
            strline$ = Chr$(10)
            WriteChunkBytes_ *write_fh, &strline$,1
          EndIf

           ; copy first line
           strlng = strlng - ped\ptrCurrentSourceData\BlockStartX
           strline$ = Mid$(strline$, ped\ptrCurrentSourceData\BlockStartX, strlng) + Chr$(10)
           Write_ *write_fh, &strline$, Len(strline$)

           ; copy most lines
           For si.w = 1 To getCountOfMarkedLines - 2
             If *tempLine\nextLine
               *tempLine = *tempLine\nextLine
               strline$ = PED_Detoke{*tempLine}
               strlng.w = FLen(strline$)
               If ped\verticalCopyMode <> 0 AND (strlng > ped\ptrCurrentSourceData\BlockStartX)
                 strline$ = Mid$(strline$, ped\ptrCurrentSourceData\BlockStartX, strlng - ped\ptrCurrentSourceData\BlockStartX) + Chr$(10)
               Else
                 strline$ = Left$(strline$, strlng) + Chr$(10)
               EndIf
               Write_ *write_fh,&strline$,FLen(strline$)
             Else
               error{"Error copying to clipboard: no next line!",#log_error}
             EndIf
           Next si

           ; copy last selected Line
           *tempLine = *tempLine\nextLine
           If *tempLine
             strline$ = PED_Detoke{*tempLine}
             strline$ = Left$(strline$,ped\ptrCurrentSourceData\BlockEndX)
             strlng = Len(strline$)
             If ped\verticalCopyMode <> 0 AND (strlng > ped\ptrCurrentSourceData\BlockStartX)
               strline$ = UnRight$(strline$,ped\ptrCurrentSourceData\BlockStartX-1) + Chr$(10)
             Else
               strline$ = strline$ + Chr$(10)
             EndIf
             Write_ *write_fh, &strline$, Len(strline$)
           EndIf
        EndIf
        Close_ *write_fh
        Gosub set_pointer_normal
      Else
        dummy.l = ask{!TRANS{messageErrorWriteFile},!TRANS{"OK"},"Error!"}
      End If
    End If
  Else
    log_Print{"no block marked."}
  EndIf

Return


.menu_includeblock:
  log_Print{"includeblock"}

  Poke.w ?comWord__AL_0_8AD8,0
  includeblockfile$ = PED_RequestFile{"","","Name of block to load","(#?.info)"}
  If includeblockfile$ <> ""
    Gosub do_paste
  EndIf
Return

.do_paste:
  log_Print{"pastemode " + Hexw$(ped\pasteMode)}

  If ped\pasteMode
    ; clipboard mode                                                                                                                                                                                                                                     
    log_Print{"checking clipboard"}                                                                                                                                                                                                                      
    If NOT PED_ReadClipboard{}                                                                                                                                                                                                                           
      log_Print{"clipboard is empty"}                                                                                                                                                                                                                    
      Return                                                                                                                                                                                                                                             
    EndIf                                                                                                                                                                                                                                                
  Else
    ; includeblock mode
    ped\sourceFileHandle = PED_OpenFile{includeblockfile$,#HUNK_RELOC_16__MODE_OLDFILE,False}
    Poke.w ?comWord_DoTokenize, ped\DoTokenize
    Poke.b ?convert, ped\convert
    If NOT PED_ReadFileCache{}
      PED_CloseFile{ped\sourceFileHandle}
      Return
    EndIf
  EndIf

  ped\LabelListChanged = True
  ped\ptrCurrentSourceData\SourceChanged = $FFFF

  lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
  currentColumn.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset

  ; -- get first part of current line
  ped\inString = 0
  beginString.s = ""
  For p.w = 0 To currentColumn - 1
    currentbyte.b = Peek.b(lineaddr + p)
    If currentbyte = $22 Then ped\inString = NOT ped\inString
    If NOT ped\inString Then currentbyte = currentbyte BitClr 7
    beginString + Chr$(currentbyte)
  Next p

  ;-- get rest of current line
  restString.s = ""
  For p.w = currentColumn To #MAX_Columns-1
    currentbyte.b = Peek.b(lineaddr + p)
    restString + Chr$(currentbyte)
  Next p
  restString = StripTrail$(restString,@" ")

  ;-- get first line and join it with currentline
  beginString = beginString + PED_ReadNextLine{}
 
  ;-- check labelidentifier, update labellist ?
  If PED_CheckLabelRelevance{beginString} Then ped\LabelListChanged = True

  ;-- replace line with current one
  newline$ = PED_ParseText{beginString}
  newline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))
  *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
  PED_ReplaceCurrentSourceLine{*newLine}                                                                                                                                                                                                                 
                                                                                                                                                                                                                    
  storeCurrentSourceLine.l = *newLine                                                                                                                                                                                                                    
                                                                                                                                                                                                                       
  ;-- import all further lines
  morelines.b = False
  pasteString.s = ""
  Repeat
    tmpLine = PED_ReadNextLine{}
    tmpLen = FLen(tmpLine)
    If tmpLine <> "NoCOntenTwasDelivered"
      morelines = True
      If ped\verticalCopyMode
        If currentColumn > #MAX_Columns-10 Then currentColumn = #MAX_Columns-10
        pasteString = SPACE$(currentColumn)
        pasteString = pasteString + tmpLine
      Else
        pasteString = tmpLine
      EndIf
      newline$ = PED_ParseText{pasteString}      
      newline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))
      *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
      appendLine{ped\ptrCurrentSourceData\CurrentSourceLine, *newLine}
      ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
      ;ped\ptrCurrentSourceData\DisplayLine + 1                           ;-> increase displayline if cursor should walk with inserted lines
      ped\ptrCurrentSourceData\TotalLines + 1
    Else
      tmpLen = 0
    EndIf
  Until tmpLen = 0 AND (readcache\moreBytes = False)
  
  ;-- add the rest to an new line
  If FLen(restString) > 0
    log_Print{"handling rest of former line: [" + restString + "]"}
    If morelines
      restString = pasteString + restString
      newline$ = PED_ParseText{restString}
      newline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))
      ped\ptrCurrentSourceData\CurrentSourceLine = storeCurrentSourceLine
    Else
      restString = beginString + pasteString + restString
      newline$ = PED_ParseText{restString}
      newline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))
      *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
      PED_ReplaceCurrentSourceLine{*newLine}
      ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
    EndIf
  ;Else
  ;  log_Print{"no restString: " + restString}
  EndIf
 
  If ped\pasteMode = 0 Then PED_CloseFile{ped\sourceFileHandle}
  ped\inString = False

  
  PED_UpdateStatusArea{}                                                                                                                                                                                                                                 
  !PED_ResetBlockflag
  PED_RedrawSource{}
Return


.menu_dublicate:
  log_Print{"menu dublicate called."}
  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal
    Pop If: Return
  EndIf

  error{"Function disabled, WIP."}

  PED_RedrawSource{}
  log_Print{"menu dublicate finished."}
Return


.menu_forget:
  log_Print{"menu forget called."}
  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal
    Pop If : Return
  EndIf
  !PED_ResetBlockflag
  PED_RedrawSource{}
Return

.event_leftmousebutton:
;  log_Print{"event left mousebutton"}
  PED_GetMousePos{mousePos}
  If (mousePos\textY < 0) OR (mousePos\textY + ped\ptrCurrentSourceData\DisplayLineOffset > ped\ptrCurrentSourceData\TotalLines)
    Return
  EndIf

  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF     ; if blockmark is set, clear the block
    !PED_ResetBlockflag
    PED_RedrawSource{}
  EndIf
  oldBlockDims\xMin = ped\ptrCurrentSourceData\BlockStartX ; why store the old block ?? it has been killed with the clause above
  oldBlockDims\yMin = ped\ptrCurrentSourceData\BlockStartY
  oldBlockDims\xMax = ped\ptrCurrentSourceData\BlockEndX
  oldBlockDims\yMax = ped\ptrCurrentSourceData\BlockEndY

  !PED_CursorOff

  ped\ptrCurrentSourceData\LinePosStartX = mousePos\textX + ped\ptrCurrentSourceData\ColumnsOffset
  If mousePos\textY + ped\ptrCurrentSourceData\DisplayLineOffset < ped\ptrCurrentSourceData\TotalLines
    ped\ptrCurrentSourceData\LinePosStartY = mousePos\textY + ped\ptrCurrentSourceData\DisplayLineOffset
  Else
    ped\ptrCurrentSourceData\LinePosStartY = ped\ptrCurrentSourceData\TotalLines - 1
  EndIf
  ped\ptrCurrentSourceData\LinePosEndX = ped\ptrCurrentSourceData\LinePosStartX
  ped\ptrCurrentSourceData\LinePosEndY = ped\ptrCurrentSourceData\LinePosStartY

  PED_UpdateStatusArea{#STATUS_SCROLLERS}

  storeDisplayLineOffset.l = ped\ptrCurrentSourceData\DisplayLineOffset
  storeColumnsOffset.w = ped\ptrCurrentSourceData\ColumnsOffset
  storeCurrentSourceLine.l = ped\ptrCurrentSourceData\CurrentSourceLine

  ;log_Print{"initial block draw"}
  Poke.w ?comWord__QuoteFlag, 0
  storeX.w = mousePos\textX + ped\ptrCurrentSourceData\ColumnsOffset
  storeY.l = mousePos\textY

  bmark\xMin = storeX
  bmark\yMin = storeY
  bmark\xMax = storeX
  bmark\yMax = storeY
  AbsDimensions{bmark}
  PED_DrawBlock{bmark}

  exit_mouse_loop.b = False
  Repeat
    PED_GetMessage{True}

    If pedMessage\_Class <> 0
      If pedMessage\_Code = #SELECTUP
        mqualifier.w = pedMessage\_Qualifier
        If (mqualifier AND #IEQUALIFIER_RSHIFT) Then mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
        If (mqualifier AND #IEQUALIFIER_RALT) Then mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
        exit_mouse_loop = True
      Else
        PED_GetMousePos{mousePos}

        If mousePos\textY => 0
          Gosub mouse_scrollno
        Else
          If mousePos\Y <= sourceWindow\BoxTop
            Gosub mouse_scrollup
          Else
            If sourceWindow\visibleLines + ped\ptrCurrentSourceData\DisplayLineOffset <= ped\ptrCurrentSourceData\TotalLines
              Gosub mouse_scrolldown
            EndIf
          EndIf
        EndIf
      EndIf
    EndIf
  Until exit_mouse_loop

  Gosub mouseclick_in_source
Return


.mouse_scrolldown:
  ;log_Print{"scroll down"}
  tmpX.w = #MAX_Columns               ;D2
  tmpY.l = sourceWindow\visibleLines - 1 ;D3

  If ped\ptrCurrentSourceData\DisplayLineOffset + sourceWindow\visibleLines <= ped\ptrCurrentSourceData\TotalLines
    PED_ScrollVertical{#SCROLL_UP}

    *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine\nextLine
    ped\ptrCurrentSourceData\DisplayLineOffset + 1

    Gosub draw_new_sourceline_bottom

    storeY - 1

    If tmpY + ped\ptrCurrentSourceData\DisplayLineOffset <= ped\ptrCurrentSourceData\LinePosStartY
      bmark\xMin = #MAX_Columns
      bmark\yMin = sourceWindow\visibleLines - 2
      bmark\xMax = storeX
      bmark\yMax = storeY
      PED_DrawBlock{bmark}
      storeX = #MAX_Columns
      storeY = sourceWindow\visibleLines - 1
      If tmpY + ped\ptrCurrentSourceData\DisplayLineOffset = ped\ptrCurrentSourceData\LinePosStartY
        storeX = ped\ptrCurrentSourceData\LinePosStartX - 1
      EndIf
      tmpX = -1
      tmpY = storeY

    EndIf

  EndIf

  Gosub update_blockmark
Return

.mouse_scrollup:
  ;log_Print{"scroll up"}
  tmpX.w = 0  ;D2
  tmpY.l = 0  ;D3

  If ped\ptrCurrentSourceData\DisplayLineOffset > 0
    PED_ScrollVertical{#SCROLL_DOWN}

    *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine\previousLine
    ped\ptrCurrentSourceData\DisplayLineOffset - 1

    Gosub draw_new_sourceline_top

    storeY + 1

    If ped\ptrCurrentSourceData\DisplayLineOffset >= ped\ptrCurrentSourceData\LinePosStartY
      bmark\xMin = 0
      bmark\yMin = 1
      bmark\xMax = storeX
      bmark\yMax = storeY
      PED_DrawBlock{bmark}
      tmpX = #MAX_Columns
      tmpY = 0
      storeX = -1
      storeY = 0
      If ped\ptrCurrentSourceData\DisplayLineOffset = ped\ptrCurrentSourceData\LinePosStartY
        storeX = ped\ptrCurrentSourceData\LinePosStartX - 1
      EndIf

    EndIf

  EndIf

  Gosub update_blockmark
Return

.mouse_scrollno:
;  log_Print{"scroll no"}
  tmpX = mousePos\textX + ped\ptrCurrentSourceData\ColumnsOffset     ; >D2
  tmpY = mousePos\textY ; >D3
  If tmpY + ped\ptrCurrentSourceData\DisplayLineOffset > ped\ptrCurrentSourceData\TotalLines
    tmpY = ped\ptrCurrentSourceData\TotalLines - ped\ptrCurrentSourceData\DisplayLineOffset - 1
  EndIf

  If mousePos\X = 0        ; mouse is left of source, scroll to right if not at column 1
    tmpX - 1
    If ped\ptrCurrentSourceData\ColumnsOffset > 0
      tmpX - 1
      ped\ptrCurrentSourceData\LinePosEndX = storeX
      ped\ptrCurrentSourceData\LinePosEndY = storeY + ped\ptrCurrentSourceData\DisplayLineOffset ; mousePos\textY

      ped\ptrCurrentSourceData\BlockStartX = ped\ptrCurrentSourceData\LinePosStartX
      ped\ptrCurrentSourceData\BlockStartY = ped\ptrCurrentSourceData\LinePosStartY
      ped\ptrCurrentSourceData\BlockEndX   = ped\ptrCurrentSourceData\LinePosEndX
      ped\ptrCurrentSourceData\BlockEndY   = ped\ptrCurrentSourceData\LinePosEndY
      PED_AbsBlockDimensions{}

      ped\ptrCurrentSourceData\ColumnsOffset - sourceWindow\scrollSize
      Gosub scroll_right
      !PED_ResetBlockflag
    EndIf
  Else            ; scroll to left if where are not at the rightmost column
    If (mousePos\textX - ped\ptrCurrentSourceData\ColumnsOffset) => sourceWindow\visibleColumns
      tmpX = ped\ptrCurrentSourceData\ColumnsOffset + sourceWindow\visibleColumns
      If tmpX < #MAX_Columns
        tmpX + 1
        ped\ptrCurrentSourceData\LinePosEndX = mousePos\textX
        ped\ptrCurrentSourceData\LinePosEndY = mousePos\textY + ped\ptrCurrentSourceData\DisplayLineOffset
        ped\ptrCurrentSourceData\BlockStartX = ped\ptrCurrentSourceData\LinePosStartX
        ped\ptrCurrentSourceData\BlockStartY = ped\ptrCurrentSourceData\LinePosStartY
        ped\ptrCurrentSourceData\BlockEndX   = ped\ptrCurrentSourceData\LinePosEndX
        ped\ptrCurrentSourceData\BlockEndY   = ped\ptrCurrentSourceData\LinePosEndY
        PED_AbsBlockDimensions{}

        ped\ptrCurrentSourceData\ColumnsOffset + sourceWindow\scrollSize
        Gosub scroll_left
        !PED_ResetBlockflag
      EndIf
    EndIf
  EndIf

  Gosub update_blockmark
Return

.update_blockmark:
      If (storeX = mousePos\textX) AND (storeY = mousePos\textY)
        Return
      EndIf
      ;log_Print{"update block ..."}

      PED_UpdateStatusArea{#STATUS_SCROLLERS}

      ;msg$ = "tmpX: " + Str$(tmpX) + ", tmpY: " + Str$(tmpY)
      ;log_Print{msg$}
      ped\ptrCurrentSourceData\LinePosEndX = tmpX
      If tmpY + ped\ptrCurrentSourceData\DisplayLineOffset < ped\ptrCurrentSourceData\TotalLines
        ped\ptrCurrentSourceData\LinePosEndY = tmpY + ped\ptrCurrentSourceData\DisplayLineOffset
      EndIf
 
      If ped\ptrCurrentSourceData\LinePosEndY <= ped\ptrCurrentSourceData\LinePosStartY
        ;log_Print{"lineposendy < lineposstarty " + Str$(storeY)}
        If (ped\ptrCurrentSourceData\LinePosEndX => ped\ptrCurrentSourceData\LinePosStartX) OR (ped\ptrCurrentSourceData\LinePosEndY = ped\ptrCurrentSourceData\LinePosStartY)
          If Peek.w(?comWord__QuoteFlag) = 0
            bmark\xMin = storeX
            bmark\yMin = storeY
            bmark\xMax = tmpX
            bmark\yMax = tmpY
            storeX = tmpX
            storeY = tmpY
            AbsDimensions{bmark}
            bmark\xMin + 1
            PED_DrawBlock{bmark}
            Return
          EndIf
        Else
          Goto other_path
        EndIf
      Else
        other_path:
        ;log_Print{"lineposendy > lineposstarty"}
        If Peek.w(?comWord__QuoteFlag) = 0
          bmark\xMin = storeX
          bmark\yMin = storeY
          bmark\xMax = tmpX
          bmark\yMax = tmpY
          storeX = tmpX
          storeY = tmpY
          AbsDimensions{bmark}
          bmark\xMax - 1
          PED_DrawBlock{bmark}
          Return
        EndIf
      EndIf

      ;------------------------------------------------------------------------
      log_Print{"mouseclick in same line"}
      Poke.w ?comWord__QuoteFlag, NOT Peek.w(?comWord__QuoteFlag)

      bmark\xMax = storeX
      bmark\yMax = storeY
      bmark\xMin = ped\ptrCurrentSourceData\LinePosStartX
      bmark\yMin = ped\ptrCurrentSourceData\LinePosStartY - ped\ptrCurrentSourceData\DisplayLineOffset
      If bmark\yMin < 0
        bmark\xMin = 0
        bmark\yMin = 0
      Else
        If bmark\yMin >= sourceWindow\visibleLines
          bmark\yMin = sourceWindow\visibleLines - 1
          bmark\xMin = #MAX_Columns - 1
        EndIf
      EndIf
      ;obx.w = bmark\xMin
      ;oby.l = bmark\yMin
      PED_DrawBlock{bmark}

      ;bmark\xMin = obx
      ;bmark\yMin = oby
      bmark\xMax = tmpX
      bmark\yMax = tmpY
      PED_DrawBlock{bmark}

      storeX = tmpX
      storeY = tmpY
Return


.mouseclick_in_source:
;  log_Print{"mousebutton released in source, qualifier: " + Hex$(mqualifier) }
  ped\ptrCurrentSourceData\DisplayLineOffset = storeDisplayLineOffset
  ped\ptrCurrentSourceData\ColumnsOffset = storeColumnsOffset
  ped\ptrCurrentSourceData\CurrentSourceLine = storeCurrentSourceLine

  ped\ptrCurrentSourceData\DisplayLineOffsetStore = ped\ptrCurrentSourceData\DisplayLineOffset
  sourceWindow\ColumnsOffsetStore = ped\ptrCurrentSourceData\ColumnsOffset

  tempX.w = ped\ptrCurrentSourceData\LinePosEndX
  If tempX < 1
    If ped\ptrCurrentSourceData\LinePosEndY > ped\ptrCurrentSourceData\LinePosStartY
      ped\ptrCurrentSourceData\LinePosEndY - 1
      Goto jump_crude
    Else
      tempX = 0
    EndIf
  EndIf
  If tempX > #MAX_Columns
    jump_crude:
    tempX = #MAX_Columns - 1
  EndIf
  ped\ptrCurrentSourceData\LinePosEndX = tempX

  ;msg$ = "LinePosStartX " + Str$(ped\ptrCurrentSourceData\LinePosStartX) + ", "
  ;msg$ + Str$(ped\ptrCurrentSourceData\LinePosStartY)  + " - "
  ;msg$ + Str$(ped\ptrCurrentSourceData\LinePosEndX) + ", "
  ;msg$ + Str$(ped\ptrCurrentSourceData\LinePosEndY)
  ;log_Print{msg$}

  ;-- todo: add hardfold support (compare with old asm code at this place!
  ped\foldNumber = 0

  ;-- set cursor position to beginning of block mark
  ped\ptrCurrentSourceData\Column = ped\ptrCurrentSourceData\LinePosStartX - ped\ptrCurrentSourceData\ColumnsOffset

  *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  tempY.l = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
  While ped\ptrCurrentSourceData\LinePosStartY <> tempY
    If ped\ptrCurrentSourceData\LinePosStartY > tempY
      *tempLine = *tempLine\nextLine
      tempY + 1
    Else
      *tempLine = *tempLine\previousLine
      tempY - 1
    EndIf
  Wend
  tempY = tempY - ped\ptrCurrentSourceData\DisplayLineOffset
  ped\ptrCurrentSourceData\DisplayLine = tempY
  ped\ptrCurrentSourceData\CurrentSourceLine = *tempLine
  !PED_UpdateTextBufferOffset


  ; if a block is marked, then quit routine
  If (ped\ptrCurrentSourceData\LinePosStartX <> ped\ptrCurrentSourceData\LinePosEndX) OR (ped\ptrCurrentSourceData\LinePosStartY <> ped\ptrCurrentSourceData\LinePosEndY)
      ;log_Print{"LinePosEnd  equals not LinePosStart"}

      ped\ptrCurrentSourceData\BlockStartX = ped\ptrCurrentSourceData\LinePosStartX
      ped\ptrCurrentSourceData\BlockStartY = ped\ptrCurrentSourceData\LinePosStartY
      ped\ptrCurrentSourceData\BlockEndX = ped\ptrCurrentSourceData\LinePosEndX
      ped\ptrCurrentSourceData\BlockEndY = ped\ptrCurrentSourceData\LinePosEndY
      PED_AbsBlockDimensions{}
      PED_UpdateStatusArea{#STATUS_SCROLLERS}
      PED_RedrawSource{}
      Return
  EndIf

  ; it was just a click...
  ; log_Print{"just a click, no block marked."}
  ped\ptrCurrentSourceData\BlockStartX = oldBlockDims\xMin
  ped\ptrCurrentSourceData\BlockStartY = oldBlockDims\yMin
  ped\ptrCurrentSourceData\BlockEndX   = oldBlockDims\xMax
  ped\ptrCurrentSourceData\BlockEndY   = oldBlockDims\yMax

;  msg$ = "Blockdimensions:" + Chr$(10)
;  msg$ + Str$(ped\ptrCurrentSourceData\BlockStartX) + ", "
;  msg$ + Str$(ped\ptrCurrentSourceData\BlockStartY)  + " - "
;  msg$ + Str$(ped\ptrCurrentSourceData\BlockEndX) + ", "
;  msg$ + Str$(ped\ptrCurrentSourceData\BlockEndY)
;  log_Print{msg$}

  ; -- check if some keys are pressed aswell
  If mqualifier AND #IEQUALIFIER_LSHIFT                 ; lshift or rshift
;    log_Print{">> SHIFT pressed aswell!"}
    ped\blockmarkRemovalMode = 1 : Gosub handle_blockmark

    ;-- whatfor is this ? the block is deleting right one line up!
    ;If ped\ptrCurrentSourceData\BlockStartY <= ped\ptrCurrentSourceData\LinePosStartY
    ;  If ped\ptrCurrentSourceData\BlockEndY => ped\ptrCurrentSourceData\LinePosStartY
    ;    If ped\ptrCurrentSourceData\BlockStartY = ped\ptrCurrentSourceData\LinePosStartY AND ped\ptrCurrentSourceData\BlockStartX <= ped\ptrCurrentSourceData\LinePosStartX
    ;      If ped\ptrCurrentSourceData\BlockEndY = ped\ptrCurrentSourceData\LinePosStartY AND ped\ptrCurrentSourceData\BlockEndX <= ped\ptrCurrentSourceData\LinePosStartX
    ;        Poke.l ?comLong_BlockEndY, $ffffFFFF
    ;      EndIf
    ;    EndIf
    ; EndIf
    ;EndIf
  Else                                                  ; enhance the block
    ped\ptrCurrentSourceData\BlockEndX   = ped\ptrCurrentSourceData\LinePosEndX
    ped\ptrCurrentSourceData\BlockStartY = ped\ptrCurrentSourceData\LinePosStartY
  EndIf

  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
    If mqualifier AND #IEQUALIFIER_LALT                ; LeftAlt or RightAlt
 ;     log_Print{">> ALT pressed aswell!"}
      Gosub jump_onclick
    Else
      PED_RedrawSource{}
    EndIf
  Else
    If ped\ptrCurrentSourceData\DisplayLineOffset <> ped\ptrCurrentSourceData\DisplayLineOffsetStore
      PED_RedrawSource{}
    Else
      If ped\ptrCurrentSourceData\ColumnsOffset <> sourceWindow\ColumnsOffsetStore
        PED_RedrawSource{}      
      Else
        If mqualifier AND #IEQUALIFIER_LALT ;$30
          Gosub jump_onclick
        Else
          PED_RedrawSource{}
        EndIf
      EndIf
    EndIf
  EndIf
Return

.menu_gotoline:                      ;goto line
  Gosub set_pointer_busy
  WZ_LockAllOpenWindows{}
  WZWindow WZID("WIN_GOTO"),?wzgui,32,-2,-2,-2,-2,WZID("WIN_GOTO")
  Use Window WZID("WIN_GOTO")
  WZ_ActivateGadget{"GOTO_LINE"}
  exit_goto.b = False

  Repeat
    ev.l = WaitEvent
    Select ev

      Case #IDCMP_IDCMPUPDATE
        If WZGadName = "GOTO_LINE"
          _line.l = Abs(WZInput("GOTO_LINE")) - 1
           If _line >= 0                                   ; fixed so we can jump to line 1  tomsmart1
             PED_GotoLine{_line, #LINE_START}
           EndIf
          exit_goto = True
        EndIf

      Case #IDCMP_CLOSEWINDOW
        _line = -1
        exit_goto = True

    End Select

  Until exit_goto

  WZCloseWindow WZID("WIN_GOTO")

  WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                              
  Gosub set_pointer_normal
  Gosub activatesourcewindow
Return

.menu_closewb:
  If NOT CloseWorkBench_
    log_Print{"Could not close the Workbench due to open windows...",#log_warning}
  Else
    log_Print{"Workbench successfully closed."}
  EndIf
Return

.menu_openwb:
  If OpenWorkBench_ = 0
    log_Print{"Could not open the Workbench...",#log_error}
  EndIf
  ScreenToFront_ sourceWindow\pedScreen
  ActivateWindow_ sourceWindow\win
Return

.menu_newshell:
  If pedconfig\use_wbscreen <> 0
    WBenchToFront_
    exescr$ = "Workbench"
  Else
    exescr$ = ped\defaultPubscreenName
  EndIf
  exe.s = "NEWCLI WINDOW = \\22"+pedconfig\console_device + "///196/AmiBlitz Shell/CLOSE/SCREEN "+exescr$+"\\22"   ; use select Consoledevice for Shell
  Execute_ &exe,0,0
Return

;================================================================================================================================
;=                                                                                                                              =
;=                   functions to be called by compiler or other programs                                                       =
;=                                                                                                                              =
;================================================================================================================================
CLI_input_stream:  Ds.l 1
CLI_output_stream: Ds.l 1
CLI_output_file:   Ds.l 1
Even

.com_consoleOpen:
  MOVEM.l A2-A3,-(A7)

  SUBA.l A1,A1
  MOVEA.l _execbase,A6
  JSR _FindTask(A6)
  MOVEA.l D0,A3
  MOVE.l $9C(A3),CLI_input_stream
  MOVE.l $A0(A3),CLI_output_stream

  !basic
  ;log_Print{"search current task..."}
  ;*exeProcess.Process = FindTask_(0)
  ;log_Print{"I am task with num "  + Hex$(*exeProcess)}
  ;Poke.l ?CLI_input_stream,  *exeProcess\pr_CIS
  ;Poke.l ?CLI_output_stream, *exeProcess\pr_COS
  console_dontclose.l = False
  If pedconfig\console_wb = True Then WBenchToFront_

  ; -- if the console_settings are n/a, set them to something usefull
  USEPATH wtemp
  If \console_h = 0
    \console_x = 0
    \console_y = ped\screen\BarHeight * 2
    \console_w = ped\screen\Width / 3
    \console_h = ped\screen\Height / 3
  EndIf

  ; -- build the window path for opening the con:-device
  Format ""
  con_windowpath.s = Trim$(dos_PathPart{pedconfig\console_device})
  If con_windowpath = "" Then con_windowpath = "CON:"
  con_windowpath + Str$(\console_x)
  con_windowpath + "/"+Str$(\console_y)
  con_windowpath + "/"+Str$(\console_w)
  con_windowpath + "/"+Str$(\console_h)
  con_windowpath + "/" + pedconfig\console_title
  con_windowpath + "/ZOOM"
  If pedconfig\console_wb = True OR (screen_GetModeID{}=#scr_mode_wb_use)
    con_windowpath + "/SCREEN Workbench"
  Else
    con_windowpath + "/SCREEN " + screen_GetTitle{}
  EndIf

  If pedconfig\console_device = "VNC:"
    con_windowpath + "/DRAG/QUIET/NOCLOSE/NOBUTTONS"
    If pedconfig\console_font <> "" Then con_windowpath + "/FONT" + pedconfig\console_font
  EndIf
;  If console_wait = True
;    con_windowpath$ + "/CLOSE"
;    con_windowpath$ + "/WAIT"
;  EndIf

  con_windowpath + Chr$(0)
  If Peek.l(?CLI_output_file) = 0
    log_Print{"opening console: " + con_windowpath}

    Poke.l ?CLI_output_file, Open_(&con_windowpath,#HUNK_RELOC_8__MODE_NEWFILE)
  Else
    log_Print{"console is already open..."}
  EndIf
  ;If Peek.l(?CLI_output_file) <> 0
  ;  *exeProcess\pr_CIS = Peek.l(?CLI_output_file)
  ;  *exeProcess\pr_COS = Peek.l(?CLI_output_file)
  ;EndIf
  !asm

  MOVE.l CLI_output_file,D0
  BEQ.w JL_0_442A
    MOVE.l D0,$9C(A3) ; pr_CIS
    MOVE.l D0,$A0(A3) ; pr_COS
  JL_0_442A:
  MOVEM.l (A7)+,A2-A3
RTS

.com_consoleClose:
  SUBA.l A1,A1
  MOVEA.l _execbase,A6
  JSR _FindTask(A6)
  MOVEA.l D0,A3
  MOVE.l CLI_input_stream,$9C(A3)
  MOVE.l CLI_output_stream,$A0(A3)

  !basic
  ;log_Print{"console close"}
  ;*exeProcess.Process = FindTask_(0)
  ;*exeProcess\pr_CIS = Peek.l(?CLI_input_stream)
  ;*exeProcess\pr_COS = Peek.l(?CLI_output_stream)
                                                                                                                                                                                                                                                        
  If pedconfig\console_wb   = True Then WBenchToFront_
  If pedconfig\console_wait = True
    txt$ = Chr$(27) + "[1m"              ; make text bold via escape-sequence
    txt$ + Chr$(27) + "["+Str$(30+3)+"m" ; change textcolor
    txt$ + Chr$(10) + !TRANS{"Program terminated."}
    txt$ + Chr$(10) + !TRANS{"Press <ENTER> to return to AmiBlitz3..."}
    Write_ Peek.l(?CLI_output_file),&txt$,FLen(txt$)
    Flush_ Peek.l(?CLI_output_file)

    If (ExecVersion > 38) Then SetWindowPointerA_ sourceWindow\win, Tags(#WA_BusyPointer,$FFFFffff, #TAG_END,0)

    log_Print{"console close: waiting for input..."}
    console_dummy.b = 0
    ; (CheckWindow{console_title$} = True)
    While Read_(Peek.l(?CLI_output_file),&console_dummy,1) = 0
      Delay_ 2
    Wend
  EndIf
  log_Print{"closing console"}
  Close_ Peek.l(?CLI_output_file) : Poke.l ?CLI_output_file,0
  If (ExecVersion > 38) Then SetWindowPointerA_ sourceWindow\win, Tags(#WA_Pointer, Null, #TAG_END,0)

  Gosub activatesourcewindow
  If pedconfig\console_wb = True Then ScreenToFront_ sourceWindow\pedScreen
  !asm
RTS

.com_logPrint: ;A1: pointer to string, D0: optional value, d3: sourceline
  MOVEM.l a1/d0-d2,-(a7)
  !basic
  MOVEM.l (a7)+,a1/d0-d2
  PutReg D0, log_value0.l
  PutReg D1, ptr_includefile.l
  PutReg D2, log_value1.l
  PutReg D3, ptr_sourceline.l
  PutReg A1, ptr_logtext.l

  If log_value0 > 255
    logmess.s = "syslib  : "
  Else
    logmess.s = "blitzlib: "
  EndIf
  If Peek.b(ptr_includefile) <> 0
      incfile.s = Peek.s(ptr_includefile)
  Else
      incfile = ""
  EndIf

  MaxLen linebuff$ = 256

  strline.s = Peek.s(ptr_logtext)
  If FLen(strline) > 255
    strline.s = Peek.s(ptr_sourceline + 9)
  EndIf
  preproc_Detokenize{*PreProcessor,&strline,&linebuff$,FLen(strline)}
  strline.s = StripTrail$(Peek.s(&linebuff$),$20)

  Format "####00"
  logmess + Str$(log_value0) + ": " + LSet$(PED_GetLibname{log_value0},12) + " "
  Format ""
  logmess + LSet$(incfile,12)
  logmess + " L. " + LSet$(Str$(log_value1),5) + "/"
  logmess + Left$(strline,50)
  log_Print{logmess}
  Format ""
 !asm
RTS


.com_debugTrap:
  MOVEA.l A0,A2
  MOVEQ.l #$00,D1

 JL_0_44E6:
    ADDQ.w #1,D1
    TST.b (A0)+
  BNE.b JL_0_44E6

  MOVEA.l A2,A1
  SUBQ.w #1,D1
  BPL.w JUMP_tokenizeToA1
RTS

JUMP_tokenizeToA1:
JMP tokenizeToA1

                                                                                                                                                                                                                                                        
.com_detokenizeLine:
  !regs2stack
  !basic
  MOVE.l (a7)+,D0 : *strptr.l = PutD0                                                                                                                                                                                                                    
  MOVE.l (a7)+,D0 : *destptr.l = PutD0
  tmp_string.s = PED_DetokeText{Peek.s(*strptr)}
  For i = 0 To FLen(tmp_string) - 1
      Poke.b *destptr + i, Peek.b(&tmp_string + i)
  Next i
  !asm                                                                                                                                                                                                                                                   
  !stack2regs
RTS


.com_showErrorRequest:  ; A0: ptr to Errortext,            only to be called by compiler
                       ; A5: ptr current sourceline
                       ; A6: "INLN" if in INCLUDE
                       ; D7: includeline
  !regs2stack
  !basic
  fid.l = file_Open{dos_AddPart{pedconfig\systemDir,"ab_compileerror.txt"},#file_read}
  If fid <> -1
    error_type.s    = Mid$(file_ReadLine{fid},9)
    error_code.s    = Mid$(file_ReadLine{fid},9)
    error_line.s    = Mid$(file_ReadLine{fid},9)
    error_lineptr.s = Mid$(file_ReadLine{fid},9)
    error_cause1.s  = Mid$(file_ReadLine{fid},9)
    error_cause2.s  = Mid$(file_ReadLine{fid},9)
    error_source.s  = Mid$(file_ReadLine{fid},9)
    error_libnum.s  = Mid$(file_ReadLine{fid},9)
    error_incname.s = Mid$(file_ReadLine{fid},9)
    error_incline.s = Mid$(file_ReadLine{fid},9)
    compilestatus.s = Mid$(file_ReadLine{fid},9)
    file_Close{fid}

    If error_incname <> "none"              ; open source file with error
      If Exists (error_incname)
        log_Print{"Error in include ["+ error_incname + "], opening it and jumping to errorline ["+ error_incline + "]..."}
        !PED_LoadSource{error_incname,False,True,True}
        PED_GotoLine{Val(error_incline)-1,#LINE_END}
        PED_UpdateStatusArea{#STATUS_REDRAW}
      End If
    End If
                                                                                                                                                                                                                                                    
    msg$ = !TRANS{Replace$(error_type,"\n","\\n")} + "\\n"
  Else
    error_line$ = ""
    log_Print{"no error file from compiler",#log_warning}
  End If

  ; building the inforequester:
  If error_line <> ""

    If error_incname <> "none"
      msg$ + "Include " + !TRANS{"file"} + ": " + error_incname + "\\n"
      msg$ + "Include " + !TRANS{"line"} + ": " + error_incline + " - " + !TRANS{"Source line"} + ": " + error_line
    Else
      msg$ + !TRANS{"Source line"} + ": " + error_line
    EndIf
                                                                                                                                                                                                                                                         
    msg$ + "\\n"                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                              
    If error_lineptr <> ""                                                                                                                                                                                                                               
      *errorline.sourceLine = Vallong(error_lineptr)
      log_Print{"Source line pointer provided by compiler:" + Hex$(*errorline)}
      error_source2.s = Trim$(PED_Detoke{*errorline})
      log_Print{"affected sourceline: [" + error_source2 + "]"}
      msg$ + "\\n" + error_source2
    EndIf
    msg$ + "\\n" + error_source + "\\n"
     
    If error_cause1 <> "" OR error_cause2 <> ""
      msg$ + "\\n\\n------ " + !TRANS{"Details"} + " ------\\n"
      If error_cause1 <> "" Then msg$ + error_cause1 + "\\n"
      If error_cause2 <> "" Then msg$ + error_cause2
    EndIf
  EndIf
  dummy.l = ask{msg$,!TRANS{"OK"},!TRANS{"Compile Error"}}
  !asm
  !stack2regs
;  MOVE.l (A7)+,D7
RTS


.import_start:                              ; was used with import block and paste
  MOVEM.l D1-D4/D6-D7/A0-A6,-(A7)
  MOVE.w D5,D1
  MOVEA.l comPtr_Temp_TokenString2,A1
  CLR.b instring
  LEA tempbuf,a2

  TST.b convert
  BEQ 'l2b  ;'l1

    ;BRA 'l2b                         ; convert is done with preproc
    ;CMP.w #122,d1
    ;BLE 'noclip
    ;MOVE.w #122,d1
    ;MOVE.w d1,d5
    ;'noclip
    CMP.b #".",(a1)
    BNE 'l1
      MOVE.w #"'l",(a2)+
      ADDQ.w #1,d5                       ;add 1 additional char
      ADDQ.l #1,a1
      BRA 'ln1
   'l1

  TST.b convert
  BNE 'l1a
   'l1b
      MOVE.b (a1)+,d0
      BEQ 'exit
      MOVE.b d0,(a2)+
    DBF d1,'l1b
    BRA 'exit
 'l1a

  CMP.w #"\@",(a1)
  BNE 'ln1
    MOVE.w #"'l",(a2)+
    ADDQ.l #2,a1
   'n3
      MOVE.b (a1)+,d0
      BEQ 'n2
        CMP.b #" ",d0
        BEQ 'n2
          CMP.b #":",d0
          BEQ 'n2
            MOVE.b d0,(a2)+
      BRA 'n3
   'n2
    SUBQ.l #1,a1
    MOVE.l #"l`@ ",(a2)+
    ADDQ.w #4,d5
 'ln1

  CMP.b #";",(a1)   ;-1
  BEQ 'l2c
    CMP.b #$22,(a1)     ;-1       ;"
    BNE 'l2b
      TST.b instring
      BEQ 'l2c
        CLR.b instring
        BRA 'l2b
 'l2c
  MOVE.b #1,instring
 'l2b

  MOVE.b (a1)+,d0
  BEQ 'exit

  TST.b instring                     ;do only if no string
  BNE 'l5
    TST.b convert
    BEQ 'l5
      ;BRA 'l5
      CMP.b #".",d0
      BNE 'l2
       CMP.b #",",-2(a1)
        BEQ 'l500
          CMP.b #" ",-2(a1)
          BNE 'l2
       'l500
        ADDQ.w #1,d5
        MOVE.b #"'",(a2)+
        MOVEQ #"l",d0
     'l2
      CMP.b #"_",-2(a1)
      BEQ 'l4
      ;TST.b instring
      ;BNE 'l5
      CMP.l #"grap",-1(a1) : BEQ 'l3
      CMP.l #"dosb",-1(a1) : BEQ 'l3
      CMP.l #"intu",-1(a1) : BEQ 'l3
      CMP.l #"Allo",-1(a1) : BEQ 'l3
      CMP.l #"Free",-1(a1) : BEQ 'l3
      CMP.l #"Wait",-1(a1) : BEQ 'l3
      CMP.l #"\",d0
      BNE 'p1
        MOVE.b #"`",d0
     'p1
      CMP.l #"end",-1(a1)
      BEQ 'l4a                           ;endm
        CMP.l #"END",-1(a1)
        BNE 'l4
     'l4a
      CMP.b #"m",3(a1)
      BEQ 'l44a
        CMP.b #"M",3(a1)
        BNE 'l4
     'l44a
      CMP.b #" ",4(a1)
      BEQ 'l444a
        CMP.b #";",4(a1)
        BEQ  'l444a
          TST.b 4(a1)
          BNE 'l4
     'l444a
      MOVE.l #"end ",(a2)+
      MOVE.l #"macr",(a2)+
      MOVE.b #"o",d0
      ADD.w #9,d5
      ADDQ.l #4,a1
    'l4
      CMP.l #" mac",-1(a1)
                  ;BRA 'l4c              ;macro
      BEQ 'l4b

      CMP.l #" MAC",-1(a1)
      BNE 'l4c
    'l4b
      CMP.w #"ro",3(a1)
      BEQ 'l44b

      CMP.w #"RO",3(a1)
      BNE 'l4c

    'l44b
      CMP.b #" ",5(a1)
      BEQ 'l444b
      CMP.b #";",5(a1)
      BEQ  'l444b
      TST.b 5(a1)
      BNE 'l4c

    'l444b
        ADDQ.l #5,a1
        ADDQ.w #2,d5
        MOVE.b #" ",(a2)+
        MOVE.l #"macr",(a2)+
        MOVE.w #"o ",(a2)+
        SUBQ.w #5,d1
        MOVE.l a1,-(a7)
        MOVEA.l comPtr_Temp_TokenString2,A1

    'n3b
        MOVE.b (a1)+,d0
        BEQ 'n2b

        CMP.b #" ",d0
        BEQ 'n2b

        CMP.b #":",d0
        BEQ 'n2b

        MOVE.b d0,(a2)+
        ADDQ.w #1,d5
      BRA 'n3b
    'n2b

      MOVEQ #0,d0
      MOVE.l (a7)+,a1
    'l4c
      CMP.l #"ovem",(a1)
      BEQ 'mm
       CMP.l #"OVEM",(a1)
        BNE 'mm6
     'mm
      CMP.b #"m",-1(a1)
      BEQ 'mm2
        CMP.b #"M",-1(a1)
        BNE 'mm6
     'mm2
      MOVE.l a1,a0
      MOVEQ #0,d2

     'mm3
        MOVE.b (a0)+,d3
        BEQ 'mm6

        CMP.b #"(",d3
        BEQ 'mm6

        CMP.b #"-",d3
        BNE 'mm4
          MOVEQ #1,d2
       'mm4
        CMP.b #"/",d3
        BNE 'mm5
          MOVEQ #1,d2
       'mm5
      CMP.b #",",d3
      BNE 'mm3

      TST.l d2
      BNE 'mm6
        MOVE.b #$20,3(a1)
        SUBQ.l #1,a1
        MOVE.l (a1)+,(a2)+
        MOVE.w (a1)+,(a2)+
        SUBQ #6,d1
        BRA 'b1
     'mm6
        ;CMP.w #".W",-1(a1)
        ;BNE 'l5
        ;TST.b 1(a1)
        ;BNE 'l5
        ;MOVEQ #0,d0
        ;SUBQ.l #2,d1
   'l5
    MOVE.b d0,(a2)+
 'b1
  DBF d1,'l1

 'exit
  CMP.b #$0d,-1(a2)   ; check of ASC 13 carriage return
  BNE 'nd0
    CLR.b -1(a2)
    SUBQ.w #1,d5
 'nd0
  CLR.b (a2)
  MOVE.w d5,d1
  MOVEA.l comPtr_Temp_TokenString2,A1
  LEA tempbuf,a2
                                                       ;MOVEA.l A1,A2
                                               'l10:   ; maybe obsolete ?
  JSR tokenizeToA1

  MOVEA.l comPtr_Temp_TokenString2,A2
  TST.b convert
  BEQ 'l21
    MOVEQ #0,d0
    MOVE.b (a2)+,d0
    CMP.b #" ",d0
    BNE 'l21
   'l20
    MOVE.b (a2)+,d0
    BEQ 'l21
    CMP.b #" ",d0
    BEQ 'l20
    CMP.b #";",d0
    BEQ 'l21
    CMP.w #$80,d0
    BGE 'l21
    MOVE.b #"!",-2(a2)
 'l21
  MOVEM.l (A7)+,D1-D4/D6-D7/A0-A6
  RTS

 'l3
  ADDQ.l #1,d5
  MOVE.b #"_",(a2)+
BRA 'l4

Function.b FAST IsLetter{c.b}
  If (c > 64 AND c < 92) OR (c > 96 AND c < 123 )
    Function Return True
  EndIf
End Function

Function.s PED_ParseText2{strLine.s}
SHARED ped, tmpTokeStr

  If ped\DoTokenize = 0
    tmpTokeStr = strLine
  Else  
    If Trim$(strLine) = ""
      tmpTokeStr = ""
    Else
      strLen.w = FLen(strLine)
      runner.w = 0
      ped\inString = False
      CLR.w comWord__QuoteFlag

      Repeat
        curChar.b = Peek.b(&strLine + runner)
        If curChar = $22 Then ped\inString = NOT ped\inString
        If ped\inString = False Then curChar = curChar BitClr 7     

        If curChar = $22 ;Peek.b(?comByte_QuotationIdentifier)
          NOT.w comWord__QuoteFlag
          tmpTokeStr + Chr$(curChar)
        EndIf

;        If Peek.w(?comWord__QuoteFlag)
          tmpTokeStr + Chr$(curChar)
 ;       EndIf

        If NOT IsLetter{curChar}
          If (curChar > $29 AND curChar < $58) OR curChar = @"_" OR curChar = @"." OR curChar = @"\"  ; check if char is a number or special char
          EndIf
        EndIf

        ; we found a comment, so just copy the rest of the string
        If curChar.b = $22 ;Peek.b(?comByte_QuotationIdentifier)
          For i.w = runner To strLen
            curChar = Peek.b(&strLine + runner) BitClr 7
            tmpTokeStr + Chr$(curChar)
          Next i
          Pop If : Pop Repeat : Pop If : Pop If 
          Goto exitsub
        EndIf


        If curChar = @"'" OR curChar = @"#" OR curChar = @"$"
        EndIf

        runner + 1
      Until runner = #MAX_Columns - 1
    EndIf
  EndIf
  exitsub:
  Function Return tmpTokeStr
End Function


.parse_line:                         ; input A2: textstring, results: comPtr_Temp_TokenString1 = parsed string, D5: length of string
  MOVEA.l comPtr_Temp_TokenString1,A1
  MOVE.l A1,-(A7)
  MOVE.w #MAX_Columns,D1 : SUBQ.w #1,D1

  MOVE.w comWord_DoTokenize,D0
  BNE.w JL_0_5F68

    MOVEA.l A1,A0                      ; ---- just copy the textstring to comPtr_temp_tokenstring
    JL_0_5F48:
      MOVE.b (A2)+,(A0)+
      CMPI.b #$20,-$1(A0)              ; space
      BEQ.w JL_0_5F56
        MOVEA.l A0,A1                  ; A1 points to the last char that is not a space
      JL_0_5F56:
    DBF D1,JL_0_5F48

    exitParsing:                         ; return the copied string
      CLR.b (A1)+
      MOVE.l A1,D5
      SUB.l (A7)+,D5                   ; return the length of the string in D5
      RTS

  tokenizeToA1:                          ;A1 string to parse
    MOVE.l A1,-(A7)
  BRA.w JL_0_5F72
  
  JL_0_5F68:
  CMPI.b #$20,$0(A2,D1.W)              ; -------  check spaces from right to left
  BNE.w JL_0_5F7E
    JL_0_5F72:
    SUBQ.w #1,D1
    BPL.b JL_0_5F68
      ADDQ.w #4,A7                     ; Stack richten
      CLR.b (A1)
      MOVEQ.l #$01,D5                  ; only spaces in string, so return length 1 as we dont store only 1 space
      RTS
  JL_0_5F7E:



  MOVE.l A4,-(A7)                      ; currentLine to Stack
  MOVEQ.l #$00,D0
  MOVE.w D0,comWord__QuoteFlag
  CLR.b instring2

  JL_0_5F88:
    MOVE.b (A2)+,D2

    CMP.b #$22,d2                      ; ------------------ check for string "
    BNE 'l10
      NOT.b instring2
   'l10
    TST.b instring2
    BNE 'l11
      BCLR #$7,D2                      ; remove tokenflag in string
   'l11

    CMP.b comByte_QuotationIdentifier,D2
    BNE.w JL_0_5FA2
      JL_0_5F96:
      NOT.w comWord__QuoteFlag

      JL_0_5F9C:
      JSR copyD2toA1
      BRA.b JL_0_5F88
    JL_0_5FA2:

    MOVE.w comWord__QuoteFlag,D4
    BNE.b JL_0_5F9C                    ; ----------------------------------------------------

    JSR checkD2ForLetter
    BEQ.w findToken                  ; go to tokenfinder

    JL_0_5FB0:
    CMP.b #$30,d2                    ;number 0-9
    BLT 'l10
      CMP.b #$39,d2
      BGT 'l10
        BRA JL_0_6066
   'l10:

    CMP.b #"_",D2
    BEQ.w JL_0_6066

    CMP.b #$2E,D2                  ; "."
    BEQ.w JL_0_6066

    CMP.b #"\",D2
    BEQ.w JL_0_6066

    CMP.b comByte_SemicolonIdentifier,D2
    BNE.w JL_0_5FDC
      JL_0_5FD0:
        JSR copyD2toA1
        MOVE.b (A2)+,D2
        BCLR #$7,D2
      BRA.b JL_0_5FD0
    JL_0_5FDC:

    CMP.b #"'",d2                       ; do not tokenize ' $ #
    BEQ JL_0_5FE4
      CMP.b #"#",D2
      BEQ.w JL_0_5FE4                  
        CMP.b #"$",D2                    
        BNE.w JL_0_6018

      JL_0_5FE4:
        JSR copyD2toA1
        MOVE.b (A2)+,D2
        BCLR #$7,D2
        CMP.b #$22,d2                  ; "
        BNE 'l10
          BRA JL_0_5FE4
       'l10
        CMP.b #"_",d2
        BEQ JL_0_5FE4
        CMP.b #"0",D2
        BCS.w JL_0_6018
        CMP.b #"z",D2                  ;f
        BHI.w JL_0_6018
        CMP.b #"9",D2
        BLS.b JL_0_5FE4
        CMP.b #"A",D2
        BCS.w JL_0_6018
        CMP.b #"a",D2
        BCC.b JL_0_5FE4
        CMP.b #"Z",D2                  ;F
      BLS.b JL_0_5FE4
    JL_0_6018:

    JSR copyD2toA1
    MOVE.b (A2)+,D2
    CMP.b #$22,d2
    BNE 'l10
      NOT.b instring2
   'l10
    TST.b instring2
    BNE 'l11
      BCLR #$7,D2                      ;morechar
   'l11
    CMP.b comByte_QuotationIdentifier,D2
    BEQ.w JL_0_5F96

    JSR checkD2ForLetter
    BNE.b JL_0_5FB0

    findToken:                         ; ------ start tokenizing
    SUBQ.w #1,A2
    MOVEA.l comPtr_TokenBase,A3

    JL_0_6036:
    MOVEA.l A2,A4
    MOVE.l A3,-(A7)
    ADDQ.w #6,A3

    JL_0_603C:
    MOVE.b (A3)+,D3                    ; char of Tokenname -> D3
    BEQ.w JL_0_6082
      MOVE.b (A4)+,D2                  ; char of string    -> D2
      BCLR #$7,D2
      ORI.b #$20,D3                    ; or space ?
      ORI.b #$20,D2
      CMP.b D3,D2
      BEQ.b JL_0_603C

      JL_0_6054:
      MOVEA.l (A7)+,A3
      MOVE.l (A3),D3                   ; move to next token
      BEQ.w JL_0_6060                  ; no token left
      MOVEA.l D3,A3                    
      BRA.b JL_0_6036

      JL_0_6060:                       ; no token found, so write the char
      MOVE.b (A2)+,D2
      BCLR #$7,D2

      JL_0_6066:
      JSR copyD2toA1
      MOVE.b (A2)+,D2
      CMP.b #$22,d2
      BNE 'l10
        NOT.b instring2
     'l10
      TST.b instring2
      BNE 'l11
        BCLR #$7,D2
     'l11
      CMP.b comByte_QuotationIdentifier,D2
      BEQ.w JL_0_5F96

      JSR checkD2ForLetter
      BEQ.b JL_0_6066

      BRA.w JL_0_5FB0
    JL_0_6082:

    MOVE.b (A4),D2
    BCLR #$7,D2
    JSR checkD2ForLetter
    BEQ.b JL_0_6054

    CMP.b #$30,d2            ;number 0-9
    BLT 'l10
      CMP.b #$39,d2
      BGT 'l10
        BRA JL_0_6054
   'l10:
    CMP.b #"_",D2
    BEQ.b JL_0_6054

    MOVEA.l (A7)+,A3        ; copy token word to destination string
    ADDQ.w #4,A3
    MOVE.b (A3)+,(A1)
    BSET #$7,(A1)+
    MOVE.b (A3),(A1)+
    MOVE.l A4,D4
    SUB.l A2,D4
    ADD.w D4,D0
    CMP.w D1,D0             ; d1: maxcolumns - 1
    BHI.w leaveParsing
    MOVEA.l A4,A2
  BRA.w JL_0_5F88

.copyD2toA1:
  MOVE.b D2,(A1)+
  ADDQ.w #1,D0
  CMP.w D1,D0
  BHI.w JL_0_60BE
    RTS
  JL_0_60BE:
  ADDQ.w #4,A7

  leaveParsing:
  MOVEA.l (A7)+,A4
BRA.w exitParsing


.checkD2ForLetter:
  CMP.b #"A",D2
   BCS.w JL_0_60E8
  CMP.b #"z",D2
   BHI.w JL_0_60E8
  CMP.b #"[",D2
   BCS.w JL_0_60E6
  CMP.b #"a",D2
   BCS.w JL_0_60E8

  JL_0_60E6:
  CMP.w D2,D2

  JL_0_60E8:
RTS




.update_labellist:
  ped\ptrCurrentSourceData\LabelCounter = 0

  *nextline.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
  If *nextline = 0 Then Return
 
  ;eclock_Open{1000}
  ;eclock_Start{1000}

  ;log_Print{"updating labellist, search string [" + LabelListSearchString + "]"}

  ped\labelSearchMode = 0
  If LabelListSearchString <> ""
    InitArgParse LabelListSearchString
    labelWord1.s = NextArg$
    labelWord2.s = NextArg$
    If labelWord2 <> ""
      ped\labelSearchMode = 2
    Else
      If labelWord1 <> "" Then ped\labelSearchMode = 1
    EndIf
  EndIf

  labelBreak.b = False
  If Peek.w(?comWord_LabelAll) OR Peek.w(?comWord_LabelRemark) OR Peek.w(?comWord_LabelCase) 
    Gosub LabelSpecial
  Else
    Gosub LabelStandard
  EndIf
  
  ;log_Print{"updating labellist done"}
  ;ttt.l = eclock_Stop{}
  ;log_Print{"time elapsed " + Str$(ttt/1000.0)}
  ;eclock_Close{}
Return

.LabelStandard:
  log_Print{"LabelStandard: " + Str$(ped\labelSearchMode)}
  log_Print{">>" + labelWord1}

  While *nextline AND (labelBreak = False)
    tmpStr.s = Trim$(Peek.s(*nextline + 9))
    found.b = False

    If tmpStr <> ""
      ;-- check for some tokens
      Select Cvi(tmpStr)
      Case #TOKEN_Stop : found.b = True
      Case #TOKEN_TRAP : found.b = True
      Case #TOKEN_Macro
        tmpStr = UnRight$(tmpStr,2)
        ped\LabelIsFunction = 2
        found = True

      Case #TOKEN_Statement
        tmpStr = UnRight$(tmpStr,2)
        tmpStr = Trim$(tmpStr)
        If Left$(tmpStr,5) = "FAST "            ; skip token "FAST"
          tmpStr = UnRight$(tmpStr,5)
          tmpStr = Trim$(tmpStr)
        EndIf
        If Cvi(tmpStr) <> #TOKEN_Return 
          ped\LabelIsFunction = 1
          found = True
        EndIf

      Case #TOKEN_Function
        tmpStr = UnRight$(tmpStr,2)
        tmpStr = Trim$(tmpStr)
        If Left$(tmpStr,5) = "FAST "            ; skip token "FAST"
          tmpStr = UnRight$(tmpStr,5)
          tmpStr = Trim$(tmpStr)
        EndIf
        If Cvi(tmpStr) <> #TOKEN_Return 
          ped\LabelIsFunction = 1
          found = True
        EndIf

      Default
        If Peek.b(&tmpStr) = Peek.b(?comByte_LabelIdentifier)
          found = True
        EndIf
      End Select

      If found
        If ped\ptrCurrentSourceData\LabelCounter >= #maxlabels 
          log_Print{"maximum labels reached: " + Str$(#maxlabels),#log_warning}
          labelBreak = True 
        Else
          If Left$(tmpStr,1) = "."            
            If ped\LabelIsFunction = 1    ; skip datatypes
              While Left$(tmpStr,1) <> " "
                tmpStr = UnRight$(tmpStr,1)
              Wend
            Else
              tmpStr = UnRight$(tmpStr,1)
            EndIf
            tmpStr = Trim$(tmpStr)
          Else
            tmpStr = Trim$(tmpStr)
          EndIf
          Gosub label_add
        EndIf
      EndIf
    EndIf

    *nextline = *nextline\nextLine
  Wend
Return

.LabelSpecial:
  ;If Peek.w(?comWord_LabelAll) Then log_Print{"LabelAll"}
  ;If Peek.w(?comWord_LabelRemark) Then log_Print{"LabelRemark"}
  ;If Peek.w(?comWord_LabelCase) Then log_Print{"LabelCase"}  

  While *nextline AND (labelBreak = False)
    tmpStr.s = Trim$(Peek.s(*nextline + 9))
    found.b = False

    If Peek.w(?comWord_LabelAll)
      If tmpStr <> "" 
        tmpStr = Trim$(tmpStr)

        checkWord.w = Peek.w(&tmpStr)
        If checkWord = #TOKEN_Stop OR checkWord = #TOKEN_TRAP
          WZTags #WENTRYA_TextPen,2
          labelCaption.s = " --Breakpoint---"
          WZListAdd list_labels, labelCaption, 0, *nextline
        Else      
          found = True
        EndIf
      EndIf
    EndIf

    If Peek.w(?comWord_LabelRemark)
      ped\inString = 0
      found.b = False
      Repeat
        checkByte.b = Peek.b(&tmpStr)
        If checkByte = $22 Then ped\inString = NOT ped\inString
        If checkByte = @";" AND (ped\inString = 0) Then found = True
        tmpStr = UnRight$(tmpStr,1)
      Until found OR tmpStr = ""
    EndIf

    If Peek.w(?comWord_LabelCase)
      checkWord.w = Peek.w(&tmpStr)
      If checkWord = #TOKEN_Case Then found = True
    EndIf

    If found 
      If ped\ptrCurrentSourceData\LabelCounter >= #maxlabels 
        log_Print{"maximum labels reached: " + Str$(#maxlabels),#log_warning}
        labelBreak = True
      Else
        Gosub label_add
      EndIf
    EndIf

    *nextline = *nextline\nextLine
  Wend
Return


.label_add:
  If Left$(tmpStr,1)="." ;OR Left$(tmpStr,1)=";"
    tmpStr = UnRight$(tmpStr,1)
  EndIf
  labelCaption.s = PED_DetokeText{tmpStr}

  addok.b = False

  If ped\labelSearchMode = 2
    If Instr(labelCaption, labelWord1) 
      If Instr(labelCaption, labelWord2) Then addok = True
    EndIf
  Else 
    If ped\labelSearchMode = 1
      If Instr(labelCaption,LabelListSearchString) Then addok = True
    Else
      addok = True
    EndIf
  EndIf
  
  If addok
    ;log_Print{"adding <" + tmpStr + "> <" + labelCaption + "> data " + Hex$(*nextline)}
    If labelCaption = ""
      log_Print{"label is empty!",#log_error}
    EndIf 

    Select ped\LabelIsFunction
      Case 1 : ;labelCaption = UnRight$(labelCaption,2) 
                WZTags #WENTRYA_TextPen,AB3Pen(#AB3_cfunction)
      Case 2 : ;labelCaption = UnRight$(labelCaption,2) 
                WZTags #WENTRYA_TextPen,AB3Pen(#AB3_cmacro)
      Default : WZTags #WENTRYA_TextPen,1
    End Select
                                                                                                                                                                                                                                                         
    If pedconfig\sort_labels = 0                                                                                                                                                                                                                         
      WZListAdd list_labels,labelCaption,-2,*nextline                                                                                                                                                                                                    
    Else                                                                                                                                                                                                                                                 
      WZListAdd list_labels,labelCaption,-1,*nextline                                                                                                                                                                                                    
    EndIf                                                                                                                                                                                                                                                
    ped\ptrCurrentSourceData\LabelCounter + 1
    ped\LabelListChanged = True
  EndIf

  ped\LabelIsFunction = 0
Return



.free_labellist:
  WZListRemove list_labels

  ped\ptrCurrentSourceData\LabelCounter = 0
  CLR.l comLong_Label1VisableItem                        ; added to clear all old list datas  tomsmart1
  LabelList_FirstVisableItemNumber = 0
  LabelList_PreSelectItemNumber = -1
Return


.reset_labellist:
  ;log_Print{"resetting labellist?"}

  Gosub free_labellist
  Gosub update_labellist
  ped\LabelListChanged = False

  ;log_Print{"redrawing labellist..."}
  If ped\ptrCurrentSourceData\LabelCounter <= Peek.l(?comLong_Label1VisableItem)
    Poke.l ?comLong_Label1VisableItem,0
  EndIf
  LabelList_FirstVisableItemNumber = Peek.l(?comLong_Label1VisableItem)

  If WZ_IsOpen{"WIN_LABELS"}
    Use Window WZID("WIN_LABELS")

    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels,LabelList_FirstVisableItemNumber
    WZListRemove lib_list.List
    WZPrint "LIBRARY_LIST",0,lib_list
  EndIf
Return

.memAlert_CloseSource:
  Gosub display_memoryalert
  PED_CloseFile{ped\sourceFileHandle}

  ped\ptrCurrentSourceData\DisplayLineOffset = 0
  ped\ptrCurrentSourceData\DisplayLine = 0
  ped\ptrCurrentSourceData\CurrentSourceLine = ped\ptrCurrentSourceData\FirstSourceLine
  PED_RedrawSource{}
Goto bottom_of_mainloop


.display_memoryalert:
  alert$ = Chr$($00)  ; alert code
  alert$ + Chr$($38)  ; x-position
  alert$ + Chr$($16)  ; y-position
  alert$ + "Not enough memory for that operation! - Click Mousebutton to continue.\00\00"
  DisplayAlert_ $00,&alert$,$28
Return

.close_sourcefonts:
  USEPATH sourceWindow
  If (\fontI <> 0)  AND (\fontI <> \font) Then CloseFont_ \fontI
  If (\fontB <> 0)  AND (\fontB <> \font) Then CloseFont_ \fontB
  If \font <> 0 Then CloseFont_ \font

  \fontI = 0
  \fontB = 0
  \font = 0
Return

.open_sourcefonts:
  !log_AvailMem{"open fonts..."}
  Gosub close_sourcefonts

  ; open source font
  DEFTYPE.TextAttr fontsettings
  fontsettings\ta_Name = &sourcefont_name$
  fontsettings\ta_YSize = sourcefont_size
  fontsettings\ta_Style = sourcefont_style

  \font = OpenDiskFont_ (fontsettings)
  If \font = 0                                                  ; open standard font if config not font
    InitRastPort_ defaultrp.RastPort
    AskFont_ defaultrp,ta.TextAttr                                     ; might be better
    log_Print{"sourcefont [" + sourcefont_name$ + "] not found, using default [" + Peek.s(ta\ta_Name) + "]"}
    sourcefont_name$ = Peek.s(ta\ta_Name)
    sourcefont_size = ta\ta_YSize
    sourcefont_style = ta\ta_Style
    fontsettings\ta_Name =  &sourcefont_name$
    fontsettings\ta_YSize = sourcefont_size
    fontsettings\ta_Style = sourcefont_style
    \font = OpenDiskFont_(ta)
  EndIf

  ; open italic font
  fontsettings\ta_Style = #FSF_ITALIC
  \fontI = OpenDiskFont_ (fontsettings)
  If \fontI = 0
    InitRastPort_ defaultrp.RastPort
    AskFont_ defaultrp,ta.TextAttr
    \fontI = OpenDiskFont_(ta)
    If \fontI\tf_XSize><\font\tf_XSize
      CloseFont_ \fontI
      \fontI = \font
    End If
  EndIf

  ; open bold font
  fontsettings\ta_Style = #FSF_BOLD
  \fontB = OpenDiskFont_ (fontsettings)
  If \fontB = 0
    InitRastPort_ defaultrp.RastPort
    AskFont_ defaultrp,ta.TextAttr
    \fontB = OpenDiskFont_(ta)
    If \fontB
      If \fontB\tf_XSize>< \font\tf_XSize
        CloseFont_ \fontB
        \fontB = \font
      EndIf
    EndIf
  EndIf

Return

.update_title_sourcewindow:
  log_Print{"update_title_sourcewindow: "  + sourceWindow\Title}
  SetWindowTitles_ sourceWindow\win,&sourceWindow\Title,-1
  If pedconfig\load_last_source <> 0
    pedconfig\lastSourceFile = ped\sourceFileComplete
    If pedconfig\lastSourceFile <> ""
      If Instr(pedconfig\lastSourceFile,Peek.s(?comStr_SourceName)) <> 0
        dos_SetToolString{"LAST_SOURCE",pedconfig\lastSourceFile}
      EndIf
    EndIf
  EndIf
Return

 
.flush_intuimessages:
  FlushEvents
  ;If sourceWindow\win
  ;  *intuimessage.IntuiMessage = GetMsg_(sourceWindow\win\UserPort)
  ;  While *intuimessage
  ;    ReplyMsg_ *intuimessage : *intuimessage = 0
  ;    *intuimessage.IntuiMessage = GetMsg_(sourceWindow\win\UserPort)
  ;  Wend
  ;EndIf
Return


.update_currsourceline:
  *currentSourceLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
  currentLine.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine
  If currentLine > 0
    Repeat
      *currentSourceLine = *currentSourceLine\nextLine
      currentLine - 1
    Until currentLine = 0
  EndIf

  ped\ptrCurrentSourceData\CurrentSourceLine = *currentSourceLine
Return

.draw_new_sourceline_top:
  ;log_Print{"print 1 line up from line " + Str$(ped\ptrCurrentSourceData\DisplayLine)}

  !PED_storeCursorPosition

  *currentline.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  ped\ptrCurrentSourceData\TextBufferOffset = 0
  tmpDL.l = ped\ptrCurrentSourceData\DisplayLine
  While tmpDL > 0
    *currentline = *currentline\previousLine
    If *currentline = 0
     Pop If : Pop While : Goto no_prev_line
    EndIf
    tmpDL - 1
  Wend
  ped\ptrCurrentSourceData\DisplayLine = tmpDL
  PED_PrintCurrentSourceLine{False}
  no_prev_line:

  !PED_RestoreCursorPosition

  ; what for ? the result is returned in registers D0, D1, D6 ??
  ;TST.l comLong_BlockEndY
  ;BMI.w JL_0_614E2
  ;  MOVE.w comWord_Column,D0
  ;  MOVE.l comLong_DisplayLineOffset,D1 : ADD.w comWord_ColumnsOffset,D0
  ;  MOVEQ.l #$00,D6
  ;JL_0_614E2:
Return

.draw_new_sourceline_bottom:
  ;log_Print{"print 1 line down from line " + Str$(ped\ptrCurrentSourceData\DisplayLine)}

  !PED_storeCursorPosition

  *currentline.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  While sourceWindow\visibleLines > (ped\ptrCurrentSourceData\DisplayLine + 1)
    *currentline = *currentline\nextLine
    If *currentline = 0
      Pop If : Pop While : Goto no_next_line
    EndIf
    !PED_IncreaseDisplayLine
  Wend
  PED_PrintCurrentSourceLine{False}
  no_next_line:

  !PED_RestoreCursorPosition
Return


.scroll_rest_of_line_left:
  USEPATH ped\ptrCurrentSourceData
  xPos.w = \Column + \ColumnsOffset
  yPos.l = \DisplayLine + \DisplayLineOffset
  ;log_Print{"scroll line to left xpos "+ Str$(xPos)+  ", ypos " + Str$(yPos) + " BlockEndY " +Str$(\BlockEndY)}

  ;-- scroll block
  If \BlockEndY <> -1
    If (yPos <= \BlockEndY) AND (yPos >= \BlockStartY)
      If yPos = \BlockStartY
        If xPos <= \BlockStartX Then \BlockStartX - 1
        If \BlockEndX <> #MAX_Columns - 1
          If xPos <= \BlockEndX
            \BlockEndX - 1
            xPos = sourceWindow\visibleColumns + \ColumnsOffset
            If xPos > \BlockEndX
              PED_ScrollHorizontal{#SCROLL_LEFT,  #SCROLL_CURRENT_LINE}
            EndIf
          Else
            PED_ScrollHorizontal{#SCROLL_LEFT,  #SCROLL_CURRENT_LINE}
          EndIf
        EndIf
        USEPATH sourceWindow
        SetBPen_ \win\RPort,3
      EndIf
    EndIf
  EndIf

  PED_ScrollHorizontal{#SCROLL_LEFT,  #SCROLL_CURRENT_LINE}
Return


.update_blockmark_left:
  If ped\ptrCurrentSourceData\BlockEndY > -1
    xMin.w = ped\ptrCurrentSourceData\ColumnsOffset
    yMin.w = ped\ptrCurrentSourceData\DisplayLineOffset
    yMax.w = yMin + sourceWindow\visibleLines
    If (yMin <= ped\ptrCurrentSourceData\BlockEndY) AND (yMax >= ped\ptrCurrentSourceData\BlockStartY)
      If ped\ptrCurrentSourceData\BlockStartY = ped\ptrCurrentSourceData\BlockEndY
        Gosub JL_0_66F2
        Pop If
        Return
      EndIf
      Gosub JL_0_6658   ; draw missing blockmark in first line while scrollin left

      yMin = ped\ptrCurrentSourceData\BlockStartY - ped\ptrCurrentSourceData\DisplayLineOffset + 1
      yMax = ped\ptrCurrentSourceData\BlockEndY - ped\ptrCurrentSourceData\DisplayLineOffset
      If yMax > sourceWindow\visibleLines Then yMax = sourceWindow\visibleLines

      If yMax <= yMin
        Gosub JL_0_669A ; update missing blockmark in last line
        Pop If
        Return
      EndIf
      Gosub JL_0_669A

      ;-- draw left blockparts while scrolling leftside except first and last line
      xMin = 0
      yMin = (ped\ptrCurrentSourceData\BlockStartY-ped\ptrCurrentSourceData\DisplayLineOffset + 1) * \font\tf_YSize

      yMax =  ped\ptrCurrentSourceData\BlockEndY - ped\ptrCurrentSourceData\DisplayLineOffset
      If yMax > sourceWindow\visibleLines Then yMax = sourceWindow\visibleLines
      xMax.w = xMin + \font\tf_YSize * 2 - 1  ; we scroll always 2 lines
      yMax = yMax * \font\tf_YSize - 1
      If (xMax => xMin) AND (yMax => yMin)
         RectFill_ *sourcerp,sourceWindow\BoxLeft + xMin,sourceWindow\BoxTop + yMin,sourceWindow\BoxLeft + xMax,sourceWindow\BoxTop + yMax
      Else
        log_Print{"illegal area for update blockmark left"}
      EndIf
      ;    SetAPen_ *sourcerp,5
      ;    SetDrMd_ *sourcerp,#JAM1
      ;    Move_ *sourcerp,sourceWindow\BoxLeft + xMin,yMin
      ;    Draw_ *sourcerp,sourceWindow\BoxLeft + xMax,yMax
      ;    SetDrMd_ *sourcerp,#COMPLEMENT
    EndIf
  EndIf
Return


JL_0_6658:      ; draw missing blockparts in first line when scrolling left
  If xMin >= ped\ptrCurrentSourceData\BlockStartX
    yMaxold.w = yMax : xMaxold.w = xMax : yMinold.w = yMin : xMinold.w = xMin

    xMin = 0
    xMax = xMin + \font\tf_XSize * 2 - 1
    yMin = (ped\ptrCurrentSourceData\BlockStartY-ped\ptrCurrentSourceData\DisplayLineOffset) * \font\tf_YSize
    yMax = yMin + \font\tf_YSize - 1
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ *sourcerp,sourceWindow\BoxLeft + xMin,sourceWindow\BoxTop + yMin,sourceWindow\BoxLeft + xMax,sourceWindow\BoxTop + yMax
    Else
      log_Print{"illegal area for JL_0_6658"}
    EndIf

    yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return


JL_0_669A:  ; update missing blockmark in last line
  If xMin <= ped\ptrCurrentSourceData\BlockEndX
    ;yMaxold = yMax : xMaxold = xMax : yMinold = yMin : xMinold = xMin
    xMin      = 0
    xmax_temp.w = (ped\ptrCurrentSourceData\BlockEndX-ped\ptrCurrentSourceData\ColumnsOffset+1) * \font\tf_XSize - 1
    If xmax_temp < 2 Then xmax_temp = 2
    xmax_temp = xmax_temp * \font\tf_XSize - 1
    xMax      = xMin + xmax_temp
    yMin      = (ped\ptrCurrentSourceData\BlockEndY-ped\ptrCurrentSourceData\DisplayLineOffset) * \font\tf_YSize
    yMax      = yMin + \font\tf_YSize - 1
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ *sourcerp,sourceWindow\BoxLeft + xMin,sourceWindow\BoxTop + yMin,sourceWindow\BoxLeft + xMax,sourceWindow\BoxTop + yMax
    Else
      log_Print{"illegal area for JL_0669A"}
    EndIf
    ;yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return

JL_0_66F2:
  If (xMin >= ped\ptrCurrentSourceData\BlockStartX) AND (xMin <= ped\ptrCurrentSourceData\BlockEndX)
    ;yMaxold = yMax : xMaxold = xMax : yMinold = yMin : xMinold = xMin

    xMin      = 0
    xmax_temp.w = (ped\ptrCurrentSourceData\BlockEndX-ped\ptrCurrentSourceData\ColumnsOffset+1) * \font\tf_XSize - 1
    If xmax_temp < $2 Then xmax_temp = $2
    xmax_temp = xmax_temp * \font\tf_XSize - 1
    xMax      = xMin + xmax_temp
    yMin      = (ped\ptrCurrentSourceData\BlockStartY-ped\ptrCurrentSourceData\DisplayLineOffset) * \font\tf_YSize
    yMax      = yMin + \font\tf_YSize - 1
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ *sourcerp,sourceWindow\BoxLeft + xMin,sourceWindow\BoxTop + yMin,sourceWindow\BoxLeft + xMax,sourceWindow\BoxTop + yMax
    Else
      log_Print{"illegal area for JL_0_66F2"}
    EndIf
    ;yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return
 

.draw_new_columns_right:
  log_Print{"draw_new_columns_left"}
  !PED_storeCursorPosition

  ped\ptrCurrentSourceData\ColumnsOffsetTmp = 0
  ped\ptrCurrentSourceData\TextBufferOffset = 0
  ped\ptrCurrentSourceData\DisplayLine = 0

  ped\ptrCurrentSourceData\Column = sourceWindow\visibleColumns - 2
  lineAddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\ColumnsOffset + ped\ptrCurrentSourceData\Column
  tmpVisibleLines = sourceWindow\visibleLines - 1
  Repeat
    newChars.s = Peeks$(lineAddr,2)

    ; -- check if we are in a string
    lineAddr2.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
    Poke.b ?instring2, 0
    tmpRunner.w = 0
    tmpColumnsOffset.w = ped\ptrCurrentSourceData\ColumnsOffset + sourceWindow\visibleColumns - 1
    While Peek.b(lineAddr2 + tmpRunner) <> 0 AND (tmpRunner < tmpColumnsOffset)
      If Peek.b(lineAddr2 + tmpRunner) = $22 Then NOT.b instring2
      tmpRunner + 1
    Wend

    ; -- print the characters
    ST noDetokenizing
    ped\keepString = 1
    PED_PrintSourceText{&newChars, ped\ptrCurrentSourceData\Column * sourceWindow\font\tf_XSize, ped\ptrCurrentSourceData\DisplayLine, False}
    ped\keepString = 0
    PED_ProcessHighlighting{}
    SF noDetokenizing

    ; -- increase text line
    lineAddr + #MAX_Columns
    ped\ptrCurrentSourceData\TextBufferOffset + #MAX_Columns
    ped\ptrCurrentSourceData\DisplayLine + 1

    tmpVisibleLines - 1
  Until tmpVisibleLines = 0
  !PED_RestoreCursorPosition
Return

.draw_new_columns_left:
  log_Print{"draw_new_columns_left"}

  !PED_storeCursorPosition

  ped\ptrCurrentSourceData\ColumnsOffsetTmp = 0 
  ped\ptrCurrentSourceData\Column = 0 
  ped\ptrCurrentSourceData\DisplayLine = 0 
  ped\ptrCurrentSourceData\TextBufferOffset = 0 

  lineAddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\ColumnsOffset
  tmpVisibleLines = sourceWindow\visibleLines - 1
  Repeat
    newChars.s = Peeks$(lineAddr,2)

    ; -- check if we are in a string
    lineAddr2.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
    Poke.b ?instring2, 0
    tmpRunner.w = 0
    tmpColumnsOffset.w = ped\ptrCurrentSourceData\ColumnsOffset
    While Peek.b(lineAddr2 + tmpRunner) <> 0 AND (tmpRunner < tmpColumnsOffset)
      If Peek.b(lineAddr2 + tmpRunner) = $22 Then NOT.b instring2
      tmpRunner + 1
    Wend

    ; -- print the characters
    ST noDetokenizing
    ped\keepString = 1
    PED_PrintSourceText{&newChars, ped\ptrCurrentSourceData\Column * sourceWindow\font\tf_XSize, ped\ptrCurrentSourceData\DisplayLine, False}
    ped\keepString = 0
    PED_ProcessHighlighting{}
    SF noDetokenizing

    ; -- increase text line
    lineAddr + #MAX_Columns
    ped\ptrCurrentSourceData\TextBufferOffset + #MAX_Columns
    ped\ptrCurrentSourceData\DisplayLine + 1

    tmpVisibleLines - 1
  Until tmpVisibleLines = 0
  !PED_RestoreCursorPosition
Return

.scroll_right:
  !PED_CursorOff
  USEPATH sourceWindow
  dx.w = -(\font\tf_XSize * \scrollSize)
  dy.w = 0
  xMin.w = \BoxLeft
  yMin.w = \BoxTop
  xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
  yMax.w = \BoxTop + sourceWindow\visibleLines * \font\tf_YSize - 1
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax

  Gosub ScrollDelay
  Gosub draw_new_columns_left          ; draw text after scroll
  Gosub update_blockmark_left          ; blockmark selected text after scrolling
  !PED_CursorOn
Return

.scroll_left:
  ;!PED_CursorOff
  USEPATH sourceWindow
  dx.w = \font\tf_XSize * \scrollSize
  dy.w = 0
  xMin.w = \BoxLeft
  xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
  yMin.w = \BoxTop
  yMax.w = \BoxTop + sourceWindow\visibleLines * \font\tf_YSize - 1
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax

  Gosub ScrollDelay
  Gosub draw_new_columns_right
  Gosub update_blockmark_right
  ;!PED_CursorOn
Return


.update_blockmark_right:
  If ped\ptrCurrentSourceData\BlockEndY > -1            ; check if we have a Blockmark
    xMin = ped\ptrCurrentSourceData\ColumnsOffset + \visibleColumns - 2 ;d0
    yMin = ped\ptrCurrentSourceData\DisplayLineOffset       ;d1
    yMax = yMin + sourceWindow\visibleLines            ;d2

    ;log_Print{"blockstartX: " + Str$(ped\ptrCurrentSourceData\BlockStartX)}
    ;log_Print{"blockstartY: " + Str$(ped\ptrCurrentSourceData\BlockStartY)}
    ;log_Print{"blockendX: " + Str$(ped\ptrCurrentSourceData\BlockEndX)}
    ;log_Print{"blockendY: " + Str$(ped\ptrCurrentSourceData\BlockEndY)}
    ;log_Print{"xmin:" + Str$(xMin)+" yMin:" + Str$(yMin)+ " yMax: " + Str$(yMax)}
    If (yMin <= ped\ptrCurrentSourceData\BlockEndY) AND (yMax >= ped\ptrCurrentSourceData\BlockStartY)
      If ped\ptrCurrentSourceData\BlockStartY = ped\ptrCurrentSourceData\BlockEndY
        Gosub JL_0_695E
      Else
        Gosub JL_0_68C4
        yMin = ped\ptrCurrentSourceData\BlockStartY - ped\ptrCurrentSourceData\DisplayLineOffset + 1
        yMax = ped\ptrCurrentSourceData\BlockEndY - ped\ptrCurrentSourceData\DisplayLineOffset
        If yMax > sourceWindow\visibleLines Then yMax = sourceWindow\visibleLines

        If yMax < yMin      ; when does that happen???
          Gosub JL_0_6906   ; update missing block last line
          Pop If : Return
        EndIf
        Gosub JL_0_6906 ;update missing block last line

        ; add missing block on the right except first and last line
        ;xMin = Peek.w(?source_BoxLeft) + xMin * \font\tf_XSize
        xMin = (xMin - ped\ptrCurrentSourceData\ColumnsOffset) * \font\tf_XSize
        xMax = xMin + \font\tf_XSize * 2 - 1
        yMin = yMin * \font\tf_YSize
        yMax = yMax * \font\tf_YSize - 1
        If (xMax => xMin) AND (yMax => yMin)
          RectFill_ *sourcerp, sourceWindow\BoxLeft + xMin, sourceWindow\BoxTop + yMin,sourceWindow\BoxLeft + xMax, sourceWindow\BoxTop + yMax
        Else
          log_Print{"illegal area for update_blockmark right"}
        EndIf
      EndIf
    EndIf
  EndIf
Return

.JL_0_68C4:
  If xMin >= ped\ptrCurrentSourceData\BlockStartX
    yMaxold.w = yMax : xMaxold.w = xMax : yMinold.w = yMin : xMinold.w = xMin

    xMin = (xMin - ped\ptrCurrentSourceData\ColumnsOffset) * \font\tf_XSize
    xMax = xMin + \font\tf_XSize * 2 - 1
    yMin = ped\ptrCurrentSourceData\BlockStartY - ped\ptrCurrentSourceData\DisplayLineOffset
    yMin = yMin * \font\tf_YSize
    yMax = yMin + \font\tf_YSize-1
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ *sourcerp, sourceWindow\BoxLeft + xMin, sourceWindow\BoxTop + yMin, sourceWindow\BoxLeft + xMax, sourceWindow\BoxTop + yMax
    Else
      log_Print{"illegal area for JL_0_68C4"}
    EndIf

    yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return

.JL_0_6906: ; update mission block last line
  If xMin <= ped\ptrCurrentSourceData\BlockEndX + 1
    yMaxold.w = yMax : xMaxold.w = xMax : yMinold.w = yMin : xMinold.w = xMin

    d4.l = ped\ptrCurrentSourceData\BlockEndX - xMin + 1 + 2
    If d4 > 2 Then d4 = 2     ; we scroll always 2 characters
    d4 = d4 * \font\tf_XSize

    xMin = xMin - ped\ptrCurrentSourceData\ColumnsOffset
    xMin = xMin * \font\tf_XSize
    xMax = xMin + d4 - 1
    yMin = ped\ptrCurrentSourceData\BlockEndY - ped\ptrCurrentSourceData\DisplayLineOffset
    yMin = yMin * \font\tf_YSize
    yMax = yMin + \font\tf_YSize - 1
    ;log_Print{"d4: " +Str$(d4) + " blockendX: " + Str$(ped\ptrCurrentSourceData\BlockEndX)}
    ;log_Print{"d4: " +Str$(d4) + " blockendy: " + Str$(ped\ptrCurrentSourceData\BlockEndY)}
    ;log_Print{"d4: " +Str$(d4) + " blockstartX: " + Str$(ped\ptrCurrentSourceData\BlockStartX)}
    ;log_Print{">> xMin:"+Str$(xMin) + " ymin:"+Str$(yMin) + " xMax:"+Str$(xMax) + " ymax:"+Str$(yMax)}
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ *sourcerp, sourceWindow\BoxLeft + xMin, yMin, sourceWindow\BoxTop + sourceWindow\BoxLeft + xMax, sourceWindow\BoxTop + yMax
    Else
      log_Print{"illegal area for JL_0_6906"}
    EndIf


    yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return

.JL_0_695E: ; all in the same line
  If (xMin >= ped\ptrCurrentSourceData\BlockStartX) AND (xMin <= ped\ptrCurrentSourceData\BlockEndX)
    log_Print{"JL_0_695E"}
    d4.l = ped\ptrCurrentSourceData\BlockEndX - xMin + 1
    If d4 > 2 Then d4 = 2
    d4 = d4 * \font\tf_XSize

    xMin = xMin - ped\ptrCurrentSourceData\ColumnsOffset
    xMin = xMin * \font\tf_XSize
    xMax = xMin + d4
    yMin = ped\ptrCurrentSourceData\BlockStartY - ped\ptrCurrentSourceData\DisplayLineOffset
    yMax = yMin * \font\tf_YSize * 2 - 1
    yMin = yMin * \font\tf_YSize
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ *sourcerp, sourceWindow\BoxLeft + xMin, sourceWindow\BoxTop + yMin, sourceWindow\BoxLeft + xMax, sourceWindow\BoxTop + yMax
    Else
      log_Print{"illegal area for JL_0_695E"}
    EndIf

  EndIf
Return

.clear_sourcebuffer:
  !PED_ResetBlockflag

  ped\ptrCurrentSourceData\Column = 0
  ped\ptrCurrentSourceData\DisplayLine = 0
  ped\ptrCurrentSourceData\TextBufferOffset = 0
  ped\ptrCurrentSourceData\DisplayLineOffset = 0
  ped\ptrCurrentSourceData\ColumnsOffset = 0 
  ped\ptrCurrentSourceData\SourceChanged = 0
  ped\ptrCurrentSourceData\LabelList = 0
  ped\ptrCurrentSourceData\LabelCounter = 0
  ped\ptrCurrentSourceData\SourceName[0] = 0
  ped\ptrCurrentSourceData\TotalLines = 1
  
  Gosub clear_sourcewindow

  *tempLine.sourceLine = PED_CreateNewSourceLine{""}
  If *tempLine
    ped\ptrCurrentSourceData\FirstSourceLine = *tempLine
    ped\ptrCurrentSourceData\CurrentSourceLine = *tempLine
    ped\ptrCurrentSourceData\LastSourceLine = *tempLine
  Else
    error{"Could not allocate a new sourceline!"}
  EndIf

  PED_UpdateStatusArea{#STATUS_SCROLLERS}
Return

.free_actualsource:
  log_Print{"freeing current source..."}
  *tempLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
  While *tempLine <> 0
    *nextLine = *tempLine\nextLine
    PED_DeleteSourceLine{*tempLine, False}
    *tempLine = *nextLine
  Wend

  Gosub free_labellist
  log_Print{"...done"}
Return

.create_whole_gui:
  Gosub open_gui
  PED_UpdateStatusArea{#STATUS_SCROLLERS}
  PED_RedrawSource{}
Return

.SetGuiFontToWBScreenFont:                            ;Subroutine to get the used Screenfont of the WB an set it as guifont  tomsmart1
    WbToScreen 0                                      ; set WB to screen 0
    *scr.Screen = Peek.l(Addr Screen(0))              ; get pointer of this screen
    If *scr <> 0                                      ; check if we get a screenstructure
      *scrfont.TextAttr = *scr\Font                   ; try to get the font out of the screenstructur
      If *scrfont<>0                                  ; check if we get a TextAttrstructure

        ; In AmigaDOS we trust :
        guifont_size.w = (*scrfont.TextAttr\ta_YSize)    ; get size of the font
        guifont_name$ = Peek$(*scrfont.TextAttr\ta_Name)     ; get name of the font

       ; message{"WB fontname="+guifont$+"("+Str$(guifontsize)+")"}  ; for debug only to see if we get the right font ;)
      EndIf

    EndIf
Return


.open_gui:
  ped\errorCode = #PEDERROR_NOERROR

  log_Print{"opening gui...",#log_debug}
  If (pedconfig\use_wbfont = True)  OR  (pedconfig\use_wbscreen<>0)              ; check if we use workbench fonts or screen for Gui tomsmart1

    ;Gosub SetGuiFontToWBScreenFont                                   ; try to get the workbench screen font settinge out of the screen structure tomsmart1
    ;*guifont.TextFont = screen_SetDefaultFont{guifont_name$,guifont_size}  ; and try to use it for the Gui of oure own screen  tomsmart1
    screen_SetDefaultSysFont{#scr_sysfont_wb_prop}                    ; switch on sysfont overwrite for use Workbench screen font  tomsmart1

  Else

    screen_SetDefaultSysFont{#scr_sysfont_wb_off}                     ; switch off sysfont overwrite we want to use the selected font for the Gui  tomsmart1

    If guifont_name$ <> ""
      If guifont_size <= 0 Then guifont_size = 6
      *guifont.TextFont = screen_SetDefaultFont{guifont_name$,guifont_size} ; try to set selected font for the Gui  tomsmart1
    EndIf

    If *guifont = 0                                                   ; unable to open font => use system default
      log_Print{"Could not open selected font <" + guifont_name$ + ">, using Workbench Font instead.",#log_warning}
      Gosub SetGuiFontToWBScreenFont                                  ; try to get the workbench screen font settinge out of the screen structure tomsmart1
      *guifont = screen_SetDefaultFont{guifont_name$,guifont_size}          ; and try to use it for the Gui of oure own screen  tomsmart1
    EndIf
    If *guifont = 0
      log_Print{"We also failed to get the font of the Workbench, we now use the default font.",#log_warning}
      screen_SetDefaultSysFont{#scr_sysfont_wb_prop}                  ; switch on sysfont overwrite for use Workbench screen font  tomsmart1
    End If

  EndIf

  ped\defaultPubscreenName = "AmiBlitz3"
  ped\defaultScreenTitle = "AmiBlitz3 - PED V\\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH"
  If pedconfig\use_wbscreen <> 0                                    ; -- use workbench here
    If screen_Open{ped\defaultScreenTitle,#scr_mode_wb_use} = False
      ped\errorCode = #PEDERROR_OPENSCREEN
    Else
      ped\pubScreenNumber = "WB"
    EndIf
  Else
    If pedconfig\use_pubscreen                                 ; -- searching for already opened ab3-screens
      screen_ziffer.b = 1 : exit_screensearch.b = False
      ped\pubScreenNumber = ""
      Repeat
        GetPubScreen 2,ped\defaultPubscreenName + "_" + Str$(screen_ziffer)
        If Peek.l(Addr Screen(2))<>0
          ReleasePubScreen 2
          screen_ziffer + 1
        Else
          exit_screensearch = True
        EndIf
      Until exit_screensearch
      ped\pubScreenNumber = Str$(screen_ziffer)
      ped\defaultPubscreenName = ped\defaultPubscreenName + "_" + ped\pubScreenNumber
      screen_SetPubName{ped\defaultPubscreenName}        ; set name "str_defaultpubscreen+screen_number"
      WbToScreen 0 ; we need this, because GetPubScreen is steeling us the focus on screen 0
    EndIf

    If pedconfig\clone_wbscreen <> 0                                ; -- clone the workbench for one screen
      If screen_Open{ped\defaultScreenTitle,#scr_mode_wb_clone} = False
        ped\errorCode = #PEDERROR_OPENPUBSCREEN
      EndIf
    Else
      If screen_Open{ped\defaultScreenTitle,pedconfig\screen_modeID,pedconfig\screen_Width,pedconfig\screen_Height,pedconfig\screen_Depth} = False
        err_msg$ = "Could not open selected screen.\\nTrying to open default screen."
        log_Print{err_msg$,#log_warning}
        dummy.l = ask{!TRANS{err_msg$},!TRANS{"Ok"},!TRANS{"Error"}}

        pedconfig\clone_wbscreen = 1    ;try clone Wbscreen
        If screen_Open{ped\defaultScreenTitle,#scr_mode_wb_clone} = False
          err_msg$ = "Could not clone WB-screen, using WB itself."
          dummy.l = ask{!TRANS{err_msg$},!TRANS{"Ok"},!TRANS{"Error"}}
          pedconfig\clone_wbscreen = False  ; no clone Wbscreen
          pedconfig\use_wbscreen = True     ; try use Wbscreen
          If screen_Open{ped\defaultScreenTitle,#scr_mode_wb_use} = False
            ped\errorCode = #PEDERROR_OPENSCREEN
          EndIf
        EndIf

        ;-- get current Screen infos and store it for a update prefs/save
        pedconfig\screen_Width  = screen_GetWidth{}
        pedconfig\screen_Height = screen_GetHeight{}
        pedconfig\screen_Depth  = screen_GetDepth{}
        log_Print{"getting best screenmodeid..."}
        If ExecVersion < 39
          err_msg$ = "Sorry, to obtain best matching screen mode, we need at least OS3.0!\\n"
          error{err_msg$,!TRANS{"Error"}}
          pedconfig\screen_modeID = 0
        Else
          pedconfig\screen_modeID = screen_GetBestModeID{pedconfig\screen_Width,pedconfig\screen_Height,pedconfig\screen_Depth}
        EndIf
      EndIf
    EndIf
  EndIf
  If ped\errorCode
    Select ped\errorCode
    Case #PEDERROR_OPENSCREEN
      dummy.l = ask{!TRANS{"Unable to open screen"},!TRANS{"Ok"},!TRANS{"Error"}}
    Case #PEDERROR_OPENPUBSCREEN
      dummy.l = ask{!TRANS{"Unable to open pubscreen, it is already in use."},!TRANS{"Ok"},!TRANS{"Error"}}
    End Select
    Goto exit_PED_closeall
  EndIf

  If (screen_GetDepth{} < 4) ; AND (Peek.b(?newcolormode)<>0)
    log_Print{"screen colors: " + Str$(1 LSL screen_GetDepth{}),#log_debug}
    log_Print{"screen_GetDepth(): "+ Str$(screen_GetDepth{}),#log_debug}
    dummy.l = ask{!TRANS{"It is recommended to open a screen with at least 16 colors."},!TRANS{"Ok"},!TRANS{"Info"}}
  EndIf

  sourceWindow\pedScreen = Peek.l(Addr Screen(0))
  Poke.l ?comPtr_pedScreen,sourceWindow\pedScreen

  If screen_GetModeID{}<>#scr_mode_wb_use
    If pedconfig\use_default_pubscreen
      log_Print{"settings defaultpubscreen"}
      SetDefaultPubScreen_ &ped\defaultPubscreenName
    EndIf
  EndIf
  log_Print{"setting colors..."}
  Gosub set_storedcolors

  CNIF #USE_AREXX = 1
  ; -- inform via arexx that the Window is opened
  ArexxMyMessage$ = "OPENWINDOW" : Gosub arexx_sendmessage
  CEND

  log_Print{"init menues"}
  Gosub init_menus

  log_Print{"init windowlayouts"}
  Gosub load_windowlayouts

  If pedconfig\autolayout Then AutoLayout{&wtemp,ped\lastAutoLayout}

  log_Print{"do window layout"}
  Gosub do_windowlayout
  log_Print{"do window layout finished"}
Return

.create_sourcewindow:

  If sourceWindow\WinWidth < 32 Then sourceWindow\WinWidth = ped\screen\Width - sourceWindow\WinLeft - 1
  If sourceWindow\WinHeight < 32 Then sourceWindow\WinHeight = ped\screen\Height - sourceWindow\WinTop - 1
  If sourceWindow\WinLeft + sourceWindow\WinWidth > ped\screen\Width  Then sourceWindow\WinWidth = ped\screen\Width - sourceWindow\WinLeft
  If sourceWindow\WinTop + sourceWindow\WinHeight > ped\screen\Height Then sourceWindow\WinHeight = ped\screen\Height - sourceWindow\WinTop

  DEFTYPE.Image  *img             ; An image which represents the size gadget                                                                                                                                                                            
  DEFTYPE.Image  *sizeimage,*rarrowimage,*larrowimage,*darrowimage,*uarrowimage                                                                                                                                                                          
  DEFTYPE.Gadget *rarrowbutton,*larrowbutton,*darrowbutton,*uarrowbutton
  DEFTYPE.l sizew,sizeh,w,h,barh,exit
  Dim GTags.TagItem(4) ; -- Tags for getting the size gadget image

  sourceWindow\drawinfo = GetScreenDrawInfo_(ped\screen)
  If sourceWindow\drawinfo
    If (ped\screen\Flags & #SCREENHIRES) Then sis.l=#SYSISIZE_HIRES Else sis=#SYSISIZE_MEDRES
    GTags(0)\ti_Tag = #SYSIA_DrawInfo,sourceWindow\drawinfo
    GTags(1)\ti_Tag = #SYSIA_Which,#SIZEIMAGE
    GTags(2)\ti_Tag = #SYSIA_Size,sis
    GTags(3)\ti_Tag = #TAG_DONE
    *img = NewObjectA_(0,"sysiclass",&GTags(0))
    If *img Then DisposeObject_ *img
    FreeScreenDrawInfo_ ped\screen,sourceWindow\drawinfo
  EndIf

  ; --
  ; -- Fenster erzeugen
  ; --
  sourceWindow\drawinfo = GetScreenDrawInfo_(ped\screen)
  If (ped\screen\Flags & #SCREENHIRES)
    syssize.b = #SYSISIZE_MEDRES
  Else
    syssize = #SYSISIZE_LOWRES
  EndIf
  *sizeimage = NewObjectA_(0,"sysiclass",Tags(#SYSIA_Which,#SIZEIMAGE,@@
                                                #SYSIA_Size     ,syssize,@@
                                                #SYSIA_DrawInfo ,sourceWindow\drawinfo,@@
                                                #TAG_END        ,0))
  If (*sizeimage)
    GetAttr_ #IA_Width,*sizeimage ,&sizew
    GetAttr_ #IA_Height,*sizeimage,&sizeh
    DisposeObject_ *sizeimage
  Else
    sizew = 18
    sizeh = 10
  EndIf

  *darrowimage = NewObjectA_(0,"sysiclass",Tags(#SYSIA_Which,#DOWNIMAGE,@@
                                                   #SYSIA_Size     ,syssize,@@
                                                   #SYSIA_DrawInfo ,sourceWindow\drawinfo,@@
                                                   #TAG_END        ,0))
  If (*darrowimage)
    GetAttr_ #IA_Width ,*darrowimage,&w
    GetAttr_ #IA_Height,*darrowimage,&h
  EndIf

  *darrowbutton = NewObjectA_(0,"buttongclass",Tags(#GA_ID,#GID_DARROW,@@
    #GA_RelRight    ,-w+1,@@
    #GA_RelBottom   ,-sizeh-h+1,@@
    #GA_Width       ,w,@@
    #GA_Height      ,h,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,sourceWindow\drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #GA_Image       ,*darrowimage,@@
    #TAG_END        ,0))

  *uarrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#UPIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,sourceWindow\drawinfo,@@
    #TAG_END        ,0))

  If (*uarrowimage)
    GetAttr_ #IA_Width ,*uarrowimage,&w
    GetAttr_ #IA_Height,*uarrowimage,&h
  EndIf

  *uarrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous    ,*darrowbutton,@@
    #GA_ID          ,#GID_UARROW,@@
    #GA_RelRight    ,-w+1,@@
    #GA_RelBottom   ,-sizeh-h-h+1,@@
    #GA_Width       ,w,@@
    #GA_Height      ,h,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,sourceWindow\drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #GA_Image       ,*uarrowimage,@@
    #TAG_END        ,0))

  barh = ped\screen\WBorTop+ped\screen\RastPort\TxHeight+2

  sourceWindow\vertiprop = NewObjectA_(0,"propgclass",Tags(@@                                                                                                                                                                                            
    #GA_Previous    ,*uarrowbutton,@@
    #GA_ID          ,#GID_YPROP,@@
    #GA_RelRight    ,-sizew+4,@@
    #GA_Top         ,barh,@@
    #GA_Width       ,sizew-6,@@
    #GA_RelHeight   ,-sizeh-h-h-barh-1,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,sourceWindow\drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #PGA_Freedom    ,#FREEVERT,@@
    #PGA_Borderless ,True,@@
    #PGA_NewLook    ,True,@@
    #PGA_Total      ,1,@@
    #PGA_Visible    ,1,@@
    #TAG_END        ,0))

  *rarrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#RIGHTIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,sourceWindow\drawinfo,@@
    #TAG_END        ,0))

  If (*rarrowimage)
    GetAttr_ #IA_Width ,*rarrowimage,&w
    GetAttr_ #IA_Height,*rarrowimage,&h
  EndIf

  *rarrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous     ,sourceWindow\vertiprop,@@                                                                                                                                                                                                          
    #GA_ID           ,#GID_RARROW,@@
    #GA_RelRight     ,-sizew-w+1,@@
    #GA_RelBottom    ,-h+1,@@
    #GA_Width        ,w,@@
    #GA_Height       ,h,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,sourceWindow\drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #GA_Image        ,*rarrowimage,@@
    #TAG_END         ,0))

  *larrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#LEFTIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,sourceWindow\drawinfo,@@
    #TAG_END        ,0))

  If (*larrowimage)
    GetAttr_ #IA_Width ,*larrowimage,&w
    GetAttr_ #IA_Height,*larrowimage,&h
  EndIf

  *larrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous     ,*rarrowbutton,@@
    #GA_ID           ,#GID_LARROW,@@
    #GA_RelRight     ,-sizew-w-w+1,@@
    #GA_RelBottom    ,-h+1,@@
    #GA_Width        ,w,@@
    #GA_Height       ,h,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,sourceWindow\drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #GA_Image        ,*larrowimage,@@
    #TAG_END         ,0))

  sourceWindow\horizprop = NewObjectA_(0,"propgclass",Tags(@@                                                                                                                                                                                            
    #GA_Previous     ,*larrowbutton,@@
    #GA_ID           ,#GID_XPROP,@@
    #GA_Left         ,ped\screen\WBorLeft,@@
    #GA_RelBottom    ,-sizeh+3,@@
    #GA_RelWidth     ,-sizew-w-w-ped\screen\WBorLeft-1,@@
    #GA_Height       ,sizeh-4,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,sourceWindow\drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #PGA_Freedom     ,#FREEHORIZ,@@
    #PGA_Borderless  ,True,@@
    #PGA_NewLook     ,True,@@
    #PGA_Total       ,#MAX_Columns,@@
    #PGA_Visible     ,20,@@
    #TAG_END         ,0))


  If (sourceWindow\vertiprop=0) OR (sourceWindow\horizprop=0)                                                                                                                                                                                            
    sourceWindow\win = 0
    Goto error_opensourcewindow                   ; bei Fehler ...
  EndIf

  ; only added OS4 only IDCMP Flags if we are running on OS4  tomsmart1
  SourceWindowIDCMPFlags.l = #IDCMP_INTUITICKS|#IDCMP_CLOSEWINDOW|#IDCMP_VANILLAKEY|#IDCMP_RAWKEY
  SourceWindowIDCMPFlags | #IDCMP_MENUPICK|#IDCMP_GADGETUP|#IDCMP_GADGETDOWN
  SourceWindowIDCMPFlags | #IDCMP_MOUSEMOVE|#IDCMP_MOUSEBUTTONS|#IDCMP_NEWSIZE|#IDCMP_CHANGEWINDOW|#IDCMP_REFRESHWINDOW
  SourceWindowIDCMPFlags | #IDCMP_ACTIVEWINDOW|#IDCMP_INACTIVEWINDOW   ; added to get info if the source win (in)active
  If OSVersion = #AmigaOS4
    SourceWindowIDCMPFlags|#IDCMP_EXTENDEDMOUSE  ;added #IDCMP_EXTENDEDMOUSE for OS4 Mousewheel support
  EndIf

  SourceWindowWFlags.l = #WFLG_NEWLOOKMENUS|#WFLG_WBENCHWINDOW|#WFLG_ACTIVATE|#WFLG_GIMMEZEROZERO
  SourceWindowWFlags   | #WFLG_SIZEBBOTTOM|#WFLG_SIZEBRIGHT|#WFLG_SIZEGADGET|#WFLG_CLOSEGADGET|#WFLG_DEPTHGADGET
  SourceWindowWFlags   | #WFLG_DRAGBAR|#WFLG_REPORTMOUSE
  log_Print{"opening source window"}


  ; --- OPEN the WINDOW
  Use Screen 0
  DefaultIDCMP SourceWindowIDCMPFlags    ; we have to add these IDCMP-Flags to the list that "event" is going to listen for
  WindowTags 0,SourceWindowWFlags,"AmiBlitz3",Tags(@@
                      #WA_Left       ,sourceWindow\WinLeft,@@
                      #WA_Top        ,sourceWindow\WinTop,@@
                      #WA_Height     ,sourceWindow\WinHeight,@@
                      #WA_Width      ,sourceWindow\WinWidth,@@
                      #WA_MinWidth   ,320,@@
                      #WA_MaxWidth   ,-1,@@
                      #WA_MinHeight  ,120,@@
                      #WA_MaxHeight  ,-1,@@
                      #WA_Gadgets    ,*darrowbutton,@@
                      #WA_PubScreen  ,ped\screen,@@
                      (#WA_Dummy + $60),-1)
  sourceWindow\win = Peek.l(Addr Window(0))

;  sourceWindow\win = OpenWindowTagList_(0,Tags(@@
;                      #WA_Title      ,"AmiBlitz3",@@
;                      #WA_Left       ,sourceWindow\WinLeft,@@
;                      #WA_Top        ,sourceWindow\WinTop,@@
;                      #WA_Height     ,sourceWindow\WinHeight,@@
;                      #WA_Width      ,sourceWindow\WinWidth,@@
;                      #WA_MinWidth   ,320,@@
;                      #WA_MaxWidth   ,-1,@@
;                      #WA_MinHeight  ,120,@@
;                      #WA_MaxHeight  ,-1,@@
;                      #WA_Flags      ,SourceWindowWFlags,@@
;                      #WA_IDCMP      ,SourceWindowIDCMPFlags,@@
;                      #WA_Gadgets    ,*darrowbutton,@@
;                      #WA_PubScreen  ,ped\screen,@@
;                      (#WA_Dummy + $60),-1  ))

  If sourceWindow\win = 0
    Goto error_opensourcewindow                   ; bei Fehler ...
  EndIf

  log_Print{"setting window pointers for asmcode"}
  Poke.l (Addr Window(0)),sourceWindow\win  ; to set the Window address in the BlitzBasic structure so we can use  "Use Window 0" this helps to shown the requesters of the error.include one the Amiblitz screen and not on the WB

  log_Print{"attaching menustrip to window"}
  If ped\menuStrip Then SetMenuStrip_ sourceWindow\win,ped\menuStrip

  log_Print{"setting sourcefont"}
  SetFont_ sourceWindow\win\RPort,sourceWindow\font                                                                                                                                                                                                      

  ; attach sourcewindow to peds process
  log_Print{"find current task to attach window to it"}
  *this_process.Process = FindTask_(0)
  ped\taskWinPtr = *this_process\pr_WindowPtr
  *this_process\pr_WindowPtr = sourceWindow\win
Return


.open_sourcewindow:
  log_Print{"open sourcewindow."}

  ; -- check arexx
  CNIF #USE_AREXX = 1
    If arexx_GetMsg{True} Then Gosub arexx_event
  CEND

  If Used Screen < 0 Then WbToScreen 0
  ped\screen = Peek.l(Addr Screen(Used Screen))
  If ped\screen = 0
    Gosub close_gui
    ped\errorCode = #PEDERROR_OPENWINDOW
    Return
  EndIf

  If sourceWindow\win = 0 
    Gosub create_sourcewindow
  EndIf 

  ped\LabelListChanged = True  ; indicate that label window has to be updated too
  
  ; --
  ; -- Berechnung des Sourcelayouts, Groesse der Scroller etc.
  ; --
  Gosub calc_SourceWindowDimensions

  ;
  ; -- Speicher reservieren fuer sichtbaren Sourcebereich
  ;
  Gosub allocate_textbuffer

  ; -- allocate memory for temp rastport
  *sourcerp.RastPort = PED_AllocMem{$64}
  sourceWindow\rp = *sourcerp
  CopyMem_ sourceWindow\win\RPort,*sourcerp,$64                                                                                                                                                                                                          
  SetDrMd_ *sourcerp, #COMPLEMENT

  ;*mask.l = AllocMem(4,0)
  ;If (*mask > 0)
  ;  Poke.w *mask,   %000100010001000100
  ;  Poke.w *mask +2,%100010001000100010
  ;  *sourcerp\AreaPtrn = *mask
  ;  *sourcerp\AreaPtSz = 1
  ;EndIf
 
  SetWindowTitles_ sourceWindow\win,&ped\defaultScreenTitle,-1
  Gosub clear_sourcewindow
  Gosub set_pointer_normal
  PED_RedrawSource{}
Return

.calc_SourceWindowDimensions:
  log_Print{"calculating sourcewindow dimensions..."}
  USEPATH sourceWindow
  \BoxHeight = \win\Height - \win\BorderTop - \win\BorderBottom
  \BoxWidth = \win\Width   - \win\BorderLeft - \win\BorderRight

  If pedconfig\linenumbers
    If ped\ptrCurrentSourceData ; maybe there is no source loaded at begin
      ;log_Print{"TotalLines: " + Str$(ped\ptrCurrentSourceData\TotalLines)}
      digits.b = 5
      If ped\ptrCurrentSourceData\TotalLines < 10000 Then digits = 4
      If ped\ptrCurrentSourceData\TotalLines < 1000 Then digits = 3
      If ped\ptrCurrentSourceData\TotalLines < 100 Then digits = 2
      If ped\ptrCurrentSourceData\TotalLines < 10 Then digits = 2
    Else
      digits = 2
    EndIf
    linenumberWidth.w = digits * \font\tf_XSize
    \BoxLeft = linenumberWidth + 3
  Else
    \BoxLeft = 0
  EndIf
 
  \BoxTop = \font\tf_YSize + 2

  \visibleLines = (\BoxHeight - \BoxTop - 6) / \font\tf_YSize  ; 6 Pixel fehlen wg. Trennlinie etc.
  \visibleLines - 2                        ; subtract two lines for status area
  \statusAreaY = \BoxTop + \visibleLines * \font\tf_YSize + 1
  \visibleColumns = (\BoxWidth - \BoxLeft) / \font\tf_XSize
  \boundLinesX = 0 ; does not work atm
  \boundLinesY = 0 ; does not work atm
  \scrollSize = 1
Return


.error_opensourcewindow:
  dummy.l = ask{!TRANS{"Unable to open window!"},!TRANS{"Ok"},!TRANS{"Error"}}
  Gosub close_sourcewindow
  WZ_CloseAllWindows{}

  screen_Close{} ;/* screen close knows if it is on wb! */
Goto exit_PED_closeall

.allocate_textbuffer:
  Gosub free_textbuffer

  Poke.l ?textbufferaddr, PED_AllocMem{#MAX_Columns * sourceWindow\visibleLines + 2}
  
  If Peek.l(?textbufferaddr) = 0 
    dummy.l = ask{!TRANS{"Unable to allocate memory for text buffer!"},!TRANS{"Ok"},!TRANS{"Error"}}
    Gosub close_sourcewindow
    WZ_CloseAllWindows{}

    screen_Close{} ;/* screen close knows if it is on wb! */
    Pop If : Goto exit_PED_closeall
  EndIf
Return

.free_textbuffer:
  If Peek.l(?textbufferaddr)
    PED_FreeMem{Peek.l(?textbufferaddr)}
    Poke.l ?textbufferaddr, 0
  EndIf
Return



.close_gui:
  log_Print{"closing gui..."}
  WZ_CloseAllWindows{}                                      ; replaced the close of all WZ Windows with a statement call  tomsmart1

  If Peek.l(?CLI_output_file) <> 0
    Close_ Peek.l(?CLI_output_file) : Poke.l ?CLI_output_file,0
  EndIf

  CNIF #USE_AREXX = 1
    ArexxMyMessage$ = "CLOSEWINDOW" : Gosub arexx_sendmessage
  CEND

  Gosub close_sourcewindow  
  If pedconfig\use_pubscreen Then PubScreenStatus_ sourceWindow\pedScreen,#PSNF_PRIVATE
  

  vvblank_Free{}
  screen_Close{}   ; this release all pens for us  and close the used font
  log_Print{"closed gui"}
Return


.close_sourcewindow:
  If sourceWindow\win
    Gosub free_textbuffer
    Gosub flush_intuimessages

    CloseWindow 0 : sourceWindow\win = 0
    ;Poke.l Addr Window(0),0  ; to clear the window structure of BlitzBasic to prevent a crash at exit.

    DisposeObject_ *larrowbutton
    DisposeObject_ *larrowimage
    DisposeObject_ *rarrowbutton
    DisposeObject_ *rarrowimage
    DisposeObject_ sourceWindow\horizprop                                                                                                                                                                                                                
    DisposeObject_ *darrowbutton
    DisposeObject_ *darrowimage
    DisposeObject_ *uarrowbutton
    DisposeObject_ *uarrowimage
    DisposeObject_ sourceWindow\vertiprop                                                                                                                                                                                                                
    FreeScreenDrawInfo_ ped\screen,sourceWindow\drawinfo

    ; -- clear rastport for source area
    If *sourcerp Then PED_FreeMem{*sourcerp}

    ; -- restore previous attached window to this task: not needed but save
    *this_process.Process = FindTask_(0)
    *this_process\pr_WindowPtr = ped\taskWinPtr
  EndIf
Return


.set_storedcolors:
  screen_ReleaseAllPens{} ; release all pens that have been previously obtained by screen.include

  If (pedconfig\use_wbscreen = False) AND (ExecVersion > 38)
    screen_SetPenRGB{0             ,AB3RGB(#AB3_screenback) }
    screen_SetPenRGB{1             ,AB3RGB(#AB3_screentext) }
    screen_SetPenRGB{2             ,AB3RGB(#AB3_screenshine)}
    screen_SetPenRGB{3             ,AB3RGB(#AB3_screenfill) }
    AB3Pen(#AB3_screenback)        = screen_GetPenRGB{AB3RGB(#AB3_screenback) }
    AB3Pen(#AB3_screentext)        = screen_GetPenRGB{AB3RGB(#AB3_screentext) }
    AB3Pen(#AB3_screenshine)       = screen_GetPenRGB{AB3RGB(#AB3_screenshine)}
    AB3Pen(#AB3_screenfill)        = screen_GetPenRGB{AB3RGB(#AB3_screenfill) }
  Else
    AB3Pen(#AB3_screenback)        = 0
    AB3Pen(#AB3_screentext)        = 1
    AB3Pen(#AB3_screenshine)       = 2
    AB3Pen(#AB3_screenfill)        = 3
  EndIf

  If (ExecVersion > 38)
    AB3Pen(#AB3_cfunction)           = screen_GetPenRGB{AB3RGB(#AB3_cfunction)}
    AB3Pen(#AB3_cmacro)              = screen_GetPenRGB{AB3RGB(#AB3_cmacro)}
    AB3Pen(#AB3_cstring)             = screen_GetPenRGB{AB3RGB(#AB3_cstring)}
    AB3Pen(#AB3_cnewtype)            = screen_GetPenRGB{AB3RGB(#AB3_cnewtype)}
    AB3Pen(#AB3_cconstant)           = screen_GetPenRGB{AB3RGB(#AB3_cconstant)}
    AB3Pen(#AB3_cremarkforeground)   = screen_GetPenRGB{AB3RGB(#AB3_cremarkforeground)}
    AB3Pen(#AB3_cremarkbackground)   = screen_GetPenRGB{AB3RGB(#AB3_cremarkbackground)}
    AB3Pen(#AB3_ctoken)              = screen_GetPenRGB{AB3RGB(#AB3_ctoken)}
    AB3Pen(#AB3_ctokenbackground)    = screen_GetPenRGB{AB3RGB(#AB3_ctokenbackground)}
    AB3Pen(#AB3_cbackground)         = screen_GetPenRGB{AB3RGB(#AB3_cbackground)}
    AB3Pen(#AB3_cother)              = screen_GetPenRGB{AB3RGB(#AB3_cother)}
    AB3Pen(#AB3_cclassic)            = screen_GetPenRGB{AB3RGB(#AB3_cclassic)}
  Else
    AB3Pen(#AB3_cfunction)           = 1;screen_GetPenRGB{AB3RGB(#AB3_cfunction)}
    AB3Pen(#AB3_cmacro)              = 1;screen_GetPenRGB{AB3RGB(#AB3_cmacro)}
    AB3Pen(#AB3_cstring)             = 1;screen_GetPenRGB{AB3RGB(#AB3_cstring)}
    AB3Pen(#AB3_cnewtype)            = 1;screen_GetPenRGB{AB3RGB(#AB3_cnewtype)}
    AB3Pen(#AB3_cconstant)           = 1;screen_GetPenRGB{AB3RGB(#AB3_cconstant)}
    AB3Pen(#AB3_cremarkforeground)   = 1;screen_GetPenRGB{AB3RGB(#AB3_cremarkforeground)}
    AB3Pen(#AB3_cremarkbackground)   = 0;screen_GetPenRGB{AB3RGB(#AB3_cremarkbackground)}
    AB3Pen(#AB3_ctoken)              = 2;screen_GetPenRGB{AB3RGB(#AB3_ctoken)}
    AB3Pen(#AB3_ctokenbackground)    = 0;screen_GetPenRGB{AB3RGB(#AB3_ctokenbackground)}
    AB3Pen(#AB3_cbackground)         = 0;screen_GetPenRGB{AB3RGB(#AB3_cbackground)}
    AB3Pen(#AB3_cother)              = 1;screen_GetPenRGB{AB3RGB(#AB3_cother)}
    AB3Pen(#AB3_cclassic)            = 1;screen_GetPenRGB{AB3RGB(#AB3_cclassic)}
  EndIf

  ;remarkcolor.l              = AB3Pen(#AB3_cremarkforeground)
  ;remarkbgcolor.l            = AB3Pen(#AB3_cremarkbackground)
RTS



.clear_sourcewindow:
  ; -- clear the codelines in window
  USEPATH sourceWindow
  SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)                                                                                                                                                                                                           
  RectFill_ \win\RPort,\BoxLeft,\BoxTop,\BoxWidth,\statusAreaY-1

  ; draw vertical line to seperate numbers and source code
  If pedconfig\linenumbers
    lx.w = \BoxLeft - 1
    SetAPen_ \win\RPort,AB3Pen(#AB3_screenfill)                                                                                                                                                                                                          
    RectFill_ \win\RPort,0,\BoxTop,lx,\statusAreaY-1

    lx - 1
    SetAPen_ \win\RPort,AB3Pen(#AB3_screenshine)                                                                                                                                                                                                         
    Move_ \win\RPort,lx, \BoxTop
    Draw_ \win\RPort,lx, \statusAreaY-1
  EndIf

  PED_UpdateStatusArea{#STATUS_REDRAW}                                                                                                                                                                                                                   
  PED_ShowMessage{""}
  PED_ClearTextbuffer{}
Return

.ScrollDelay:
  CNIF #slowdown <> 0
    If ped\no_scrollrate
      Delay_ 1
    Else
      vvblank_Wait{}
      vvblank_WaitSync{1}
      vvblank_ResetSync{}
    EndIf
  CEND
Return

.redrawWithOffset:
  log_Print{"redrawWithOffset"}
  !PED_storeCursorPosition
  ped\ptrCurrentSourceData\TextBufferOffset = 0
  ped\ptrCurrentSourceData\DisplayLine = 0
  ped\ptrCurrentSourceData\Column = 0
  ped\ptrCurrentSourceData\ColumnsOffsetTmp = 0
  
  ST noDetokenizing

  curline.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset + ped\ptrCurrentSourceData\ColumnsOffset
  For curY.w = 0 To sourceWindow\visibleLines - 1    
    lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
    If Peek.b(lineaddr) <> 0
      CLR.b instring2
      tmpd2.l = 0
      While ped\ptrCurrentSourceData\ColumnsOffset > tmpd2
        If Peek.b(lineaddr + tmpd2) = $22
          NOT.b instring2
        EndIf
        tmpd2 = tmpd2 + 1
      Wend

      ped\keepString = 1
      PED_PrintSourceText{curline, 0, curY, True}
      ped\keepString = 0

      PED_ProcessHighlighting{} 
    EndIf

    ped\ptrCurrentSourceData\DisplayLine + 1
    ped\ptrCurrentSourceData\TextBufferOffset + #MAX_Columns

    curline = curline + #MAX_Columns
  Next curY

  SF noDetokenizing
   
  !PED_RestoreCursorPosition

  ;PED_RedrawSource{0}
Return


Macro checkBeforeBlockStartX
  `1 = False
  If ped\ptrCurrentSourceData\BlockStartY = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine
    If ped\ptrCurrentSourceData\BlockStartX > ped\ptrCurrentSourceData\ColumnsOffset + ped\ptrCurrentSourceData\Column
      `1 = True
    EndIf
  EndIf
End Macro

Macro checkBeforeBlockEndX
  `1 = False
  If ped\ptrCurrentSourceData\BlockEndY = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine
    If ped\ptrCurrentSourceData\BlockEndX > ped\ptrCurrentSourceData\ColumnsOffset + ped\ptrCurrentSourceData\Column
      `1 = True
    EndIf
  EndIf

End Macro

.adjustBlockPosition:
  If ped\ptrCurrentSourceData\BlockStartX >= #MAX_Columns
    ped\ptrCurrentSourceData\BlockStartX = 0
    ped\ptrCurrentSourceData\BlockStartY + 1
    If ped\ptrCurrentSourceData\BlockStartY > ped\ptrCurrentSourceData\BlockEndY
      !PED_ResetBlockflag
      Return
    EndIf
  EndIf

  If ped\ptrCurrentSourceData\BlockEndX > ped\ptrCurrentSourceData\BlockStartX
    ped\ptrCurrentSourceData\BlockEndX = #MAX_Columns-1
    ped\ptrCurrentSourceData\BlockStartY - 1
    If ped\ptrCurrentSourceData\BlockStartY <= ped\ptrCurrentSourceData\BlockEndY
      Return
    Else
      !PED_ResetBlockflag
      Return
    EndIf
  EndIf

  If ped\ptrCurrentSourceData\BlockStartY = ped\ptrCurrentSourceData\BlockEndY
    If ped\ptrCurrentSourceData\BlockEndX <= ped\ptrCurrentSourceData\BlockStartX
      !PED_ResetBlockflag
      Return
    EndIf
  EndIf

  If ped\ptrCurrentSourceData\BlockEndX >= #MAX_Columns
    ped\ptrCurrentSourceData\BlockEndX = #MAX_Columns-1
  EndIf
Return


.handlePedEvents:
  ped\ptrCurrentSourceData\KeyBeforeReturn = 0
  exit_eventloop.b = False

  While exit_eventloop = False
    ;Gosub handle_blockmark      ; if new editmode, delete a marked block if insertchar or deletechar happens

    ;-- handle Window events
    If sourceWindow\win <> 0
      Gosub eventHandler 
    EndIf

    ; -- update functioncompletion and close any subwindows on key-press
;    If pedconfig\intellisense
; -- update intellisense after DELETE_KEY OR SPACE_KEY                        ; moved it too remove double switch asm-basic-asm and expand with Space-Key support  tomsmart1
;      If (last_vankey = $08) OR (last_vankey = $20)
;        Gosub intellisense
;      EndIf
; -- CURSOR_KEYs navigation
;      If WZ_IsOpen{"WIN_POPUP"} AND (last_rawkey.l>(#RAWKEY_UP-1) AND last_rawkey<(#RAWKEY_LEFT+1) )
;        Select last_rawkey                                             ; test only rawkey code for cursor keys  tomsmart1
;          Case #RAWKEY_UP    : WZ_SetPopUpEntry{popupdata\selected_entry - 1}
;          Case #RAWKEY_DOWN  : WZ_SetPopUpEntry{popupdata\selected_entry + 1}
;          Case #RAWKEY_RIGHT : Gosub close_popupwindow
;          Case #RAWKEY_LEFT  : Gosub close_popupwindow
;        End Select
;      EndIf

    Gosub close_contexthelp

    If last_vankey > 0 Then Gosub immediate_syntaxhelp
  Wend
  ;log_Print{"exit pedevents =================================="}
Return




.insertchar:
  USEPATH ped\ptrCurrentSourceData
  \KeyBeforeReturn = last_vankey

  If \BlockEndY <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : Gosub handle_blockmark
  EndIf


  ;-- move everything right from cursor 1 to right
  lineaddr.l = Peek.l(?textbufferaddr) + \TextBufferOffset
  currentColumn.w = \Column + \ColumnsOffset
  tempColumn.w = #MAX_Columns
  While tempColumn > currentColumn
    tempColumn - 1
    Poke.b lineaddr + tempColumn, Peek.b(lineaddr + tempColumn - 1)
  Wend

  !PED_CursorOff

  PED_ScrollHorizontal{#SCROLL_RIGHT, #SCROLL_CURRENT_LINE}

  ;-- update blockmarking
  If \BlockEndY <> $ffffFFFF
    currentColumn = \Column + \ColumnsOffset
    currentLine.l = \DisplayLine + \DisplayLineOffset
    !updateBlockMark{currentLine, currentColumn}

    If \BlockStartY <> currentLine AND \BlockEndY <> currentLine
      If \BlockStartX > currentColumn
        If Peek.b(?comByte_StateBlockMark) <> 0
          \BlockEndX + 1
          If \BlockEndX > #MAX_Columns-1
            \BlockEndX = #MAX_Columns-1
          EndIf
        EndIf
      EndIf
      If \BlockEndX < currentColumn
        \BlockEndX + 1
        If \BlockEndX > #MAX_Columns-1
          \BlockEndX = #MAX_Columns-1
        EndIf
      EndIf

      \BlockStartX = (\BlockStartX + 1) AND $7F
      \BlockEndX = (\BlockEndX + 1) AND $7F
    EndIf
  EndIf
  ;--
  PED_PrintChar{\KeyBeforeReturn}
  Gosub moveCursorRight
Return



.moveCursorToBeginOfWord:
  ; get lineaddress in textbuffer (detokenized text!)
  lineaddr = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
  ; get length of source line
  textlen.w = getLineLength{lineaddr}

  ;clear highlight info but dont trash strings
  nostring.b = 0
  For i.l = lineaddr To lineaddr + textlen
    If nostring = 0
      Poke.b i,Peek.b(i) AND $7f
      If Peek.b(i) = $22 Then nostring = 1
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
  Next

  cursorpos.w = ped\ptrCurrentSourceData\Column
  If cursorpos > 1
    cursorpos - 1
    skip_spaces.b = False
    If Peek.b(lineaddr+cursorpos) = 32 Then skip_spaces = True ; check if current char is a space

    exit_loop.b = False
    Repeat
      cursorpos - 1
      char.b = Peek.b(lineaddr+cursorpos)
      log_Print{Peeks$(lineaddr,textlen)}
      log_Print{Str$(char) + "  " + Chr$(char) + "  "+Str$(cursorpos)}
      If skip_spaces
        If char <> 32 Then skip_spaces = False
      Else
        If (char < 48) OR (char = Asc("{")) OR (char = Asc("}"))
          exit_loop = True
        EndIf
      EndIf
    Until exit_loop OR (cursorpos < 1)

  EndIf
  ;GetD0 cursorpos
RTS


.moveCursorToEndOfWord:
  ; get lineaddress in textbuffer (detokenized text!)
  lineaddr = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
  ; get length of source line
  textlen.w = getLineLength{lineaddr}

  ;clear highlight (token) info but dont trash strings
  nostring.b = 0
  For i.l = lineaddr To lineaddr + textlen
    If nostring = 0
      Poke.b i,Peek.b(i) AND $7f
      If Peek.b(i) = $22 Then nostring = 1
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
  Next

  cursorpos.w = ped\ptrCurrentSourceData\Column
  If cursorpos < textlen
    cursorpos + 1
    skip_spaces.b = False
    If Peek.b(lineaddr+cursorpos) = 32 Then skip_spaces = True ; check if current char is a space

    exit_loop.b = False
    Repeat
      cursorpos + 1
      char.b = Peek.b(lineaddr+cursorpos)

      If skip_spaces
        If char <> 32 Then skip_spaces = False
      Else
        If (char < 48) OR (char = Asc("{")) OR (char = Asc("}"))
          exit_loop = True
        EndIf
      EndIf
    Until exit_loop OR (cursorpos => textlen)
    ;If cursorpos > 1 Then cursorpos - 1     ; internal counter starts at 0!
  EndIf
  newColumn.w = cursorpos : Gosub moveCursorToX
Return


.startguide:
  log_Print{"startguide"}
  strline$ = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
  actualword$ = PED_GetWordAtPos{strline$, ped\ptrCurrentSourceData\Column,True}
  If actualword$ <> ""
    Gosub instructionbrowser_startguide
  Else
    Gosub open_instructionbrowser
  EndIf

  PED_ShowMessage{""}
Return                                                                                                                                                                                                                                                   


.immediate_syntaxhelp:
  _key.b = last_vankey
  already_displayed.b = False
  ;log_Print{"immediate help ? : last_key " + Hex$(last_vankey)}
  If (_key=@" ") OR (_key = @"(") OR (_key = @"{") ;OR (*PreProcessor\tokenFlags[_key&$FF]&#TOKENF_IS); " " "(" "{"

    If ped\ptrCurrentSourceData\Column > 0

      If WZ_IsOpen{"WIN_POPUP"} Then Gosub close_popupwindow

      lineaddr = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
      strline$ = Peek.s(lineaddr)

      bracketclose1.l = Instr(strline$,")")
      bracketclose2.l = Instr(strline$,"}")

      bracketopen1.l  = Instr(strline$,"(",bracketclose1)
      bracketopen2.l  = Instr(strline$,"{",bracketclose2)

      bracketopen.l   = 0

      If bracketopen1>bracketopen2 Then bracketopen=bracketopen1 : Else bracketopen=bracketopen2

      searchpos.l = ped\ptrCurrentSourceData\Column
      If bracketopen>0 AND bracketopen<searchpos Then searchpos=bracketopen

      tokname$ = preproc_CropToken{*PreProcessor,strline$,searchpos}
      If tokname$ <> ""
        If *PreProcessor\tokenFlags[_key&$FF]&#TOKENF_IS
          tokname$ + Chr$(_key)
        End If
      End If
      If tokname$
        If PED_ShowHelptextFor{tokname$} = False
          Gosub intellisense
        End If
      End If
    EndIf
  Else
    Select _key
    Case $8b ; "HELP"
      strline$ = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
      tokname$ = PED_GetWordAtPos{strline$, ped\ptrCurrentSourceData\Column,True}
      If tokname$ <> ""
        log_Print{"HELP on <" + tokname$ + ">"}
        If LCase$(tokname$) = "endif"
          Gosub help_checkforif
        Else
          Gosub help_checkfortype
          If typestr$ = ""
            log_Print{"as there is no typehelp available, trying to get a token help text..."}
            PED_ShowHelptextFor{tokname$}
          EndIf
        EndIf
      EndIf

     Case $0D ; ENTER
       If pedconfig\intellisense AND pedconfig\onlinehelp_includes
         If WZ_IsOpen{"WIN_POPUP"}
           a$ = WZ_GetPopUpEntry{WZ_GetPopUpMenu{}+1}

           ; include function
           a_new$ = dos_Trim{Left$(a$,Instr(a$,"{")-1)}
           If (a_new$ <> "") ;test if include function
             PED_ShowMessage{a_new$ + " " + PED_GetIncludeHelp{a_new$} }
             a$ = a_new$ + "{"
           Else          ; is command
             PED_ShowMessage{a$ + " " + PED_GetTokenHelp{a$} }
           EndIf

           a$ = UnRight$(a$,FLen(poptok$)) ; cut string
           Gosub insertstring
           
           Gosub close_popupwindow
           Gosub activatesourcewindow
           Pop Select : Pop If :Pop If
           Return
         EndIf
       EndIf
    Default
      Gosub intellisense
    End Select
  EndIf
Return

.intellisense:
  ; -- bei delete-key wird ?comWord_Column nicht aktualisiert
  ;log_Print{"lastvankey " + Hex$(last_vankey)}
  If pedconfig\intellisense
    If last_vankey=#VANILLAKEY_BACKSPACE OR (last_vankey>=$20 AND last_vankey <= $7A)
      If ped\ptrCurrentSourceData\Column > 1
        ; -- get everything left of cursor until " " or "=" , ":", "(", "{", ",", "+"    ; check expand to allow the following chars  : ( { , +  too tomsmart1
        If lineaddr.l

          strline$ = Peeks$(lineaddr,ped\ptrCurrentSourceData\Column) : slen.w = FLen(strline$)
          ;log_Print{"intellisense for [" + strline$ +"]"}

          stokname$ = "" : strhelp$ = "" : sfound.l = False
          While (slen > 0) AND (sfound = False)
            schar$ = Mid$(strline$,slen,1)
            If (schar$ = " ") OR (schar$ = "=") OR (schar$ = ":") OR (schar$ = "(") OR (schar$ = "{") OR (schar$ = ",") OR (schar$ = "+")   ; expand check too allowed this chars : ( { , + too  tomsmart1
              sfound = True
            Else
              stokname$ = schar$ + stokname$
              slen - 1
            EndIf
          Wend
        End If

        Select last_vankey                            ; check for the last pressed key  tomsmart1
          Case $00                                    ; no key  added to support CTRL I update
                                                      ; nothing to do because stokname = stokname
          Case $08 ; DEL key
            stokname$ = UnLeft$(stokname$,1)          ; remove the most right chararter of the string too support the DELETE-KEY  tomsmart1
            Gosub close_popupwindow                   ; added to aviod hits  tomsmart1

         Default                                      ; all other keys
           ;stokname$ + Chr$(_key)                     ; normal added key to the string
        End Select

        ; -- search for any text that equals entered text
        If (FLen(stokname$) > 2)
          ;log_Print{"intellisense, searching for [" + stokname$+ "]"}
          poptok$ = Trim$(LCase$(stokname$)) : tokenliste$ = "" : popfound.w = 0

          ; in Helptext for Functionnames
          If (Instr(stokname$,"_") > 0)
            ; helptext
            ResetList HelpIndexCache()
            While NextItemFast(HelpIndexCache())
              If Instr(HelpIndexCache()\lname,poptok$) = 1
                ; %%1 = green, %%2 = rot, %%3= white, %%4= blue  fuer farben
                pophelp$ = HelpIndexCache()\name + HelpIndexCache()\help
                If FLen(pophelp$) > 32
                  pophelp$ = Left$(pophelp$,32) + " ... "
                EndIf
                tokenliste$ + "%%4" + pophelp$ + Chr$(10)
                popfound + 1
              End If
            Wend
          EndIf

          ; in Commands
          If pedconfig\use_commandsintellisens
            *tokenpointer.l = *tokenbase

            While *tokenpointer
              temptoken.s  = Peek$(*tokenpointer+6)
              ltemptoken.s = LCase$(temptoken)
              If Instr(ltemptoken,poptok$) = 1
                ; %%1 = green, %%2 = rot, %%3= white, %%4= blue  fuer farben
                pophelp$ = temptoken
                If FLen(pophelp$) > 32
                  pophelp$ = Left$(pophelp$,32) + " ... "
                EndIf
                tokenliste$ + "%%4" + pophelp$ + Chr$(10)
                popfound + 1
              End If

              *tokenpointer = Peek.l(*tokenpointer)  ; nexttoken
            Wend
          End If

          ; -- open list if something found
          If popfound > 0
            WZ_SetPopUpMenu{tokenliste$,1}
            USEPATH sourceWindow
            xpos.w = \WinLeft + \BoxLeft + ped\ptrCurrentSourceData\Column * \font\tf_XSize
            ypos.w = \WinTop  + \BoxTop  + (ped\ptrCurrentSourceData\DisplayLine+1) * \font\tf_YSize + \font\tf_Baseline
            log_Print{"opening popup at " + Str$(xpos) + ", " + Str$(ypos)}
            WZ_PopUp_Nonmodal{xpos,ypos,-1,-1,ped\screen\RastPort}
          Else
            ;log_Print{"nothing found"}
            Gosub close_popupwindow
          EndIf
        Else
          Gosub close_popupwindow             ; added to support DELETE_KEY  tomsmart1
        EndIf
      Else
        Gosub close_popupwindow
      EndIf
      Gosub activatesourcewindow              ; if we change popupwin (open, close, change) so we need to activate sourcewin again  tomsmart1
    EndIf
  EndIf
Return

.scan_source_for_used_libs:
  log_Print{"scan source for used libs..."}
  If ped\ptrCurrentSourceData\TotalLines = 0 Then Return

  Gosub set_pointer_busy
  WZ_LockAllOpenWindows{}
  Use Window WZID("WIN_LABELS")

  ; --
  ; -- reset tables and arrays
  For i.l = 0 To 65535
    tokentable(i) = 0
  Next i
  HIERARCHY_Clear{&lib_list}
  WZPrint "LIBRARY_LIST",0,lib_list

  ; --
  ; -- scanning each line for tokens
  WZ_ShowMessage{!TRANS{"Analyzing source..."},0}

  scanned_lines.l = 0
  *sourceLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
  While *sourceLine
    ptrString.l = *sourceLine + 9
    ped\inString = 0
    skip_rest_of_line.b = False
    Repeat
      curchar.b = Peek.b(ptrString)

      If curchar = $22 Then ped\inString = NOT ped\inString      
      If curchar = @";" AND NOT ped\inString Then skip_rest_of_line = True
      If curchar < 0 AND NOT ped\inString
        toknum2.l = Peek.w(ptrString) AND $FFFF
        If toknum2 > $8000 Then toknum2 - $8000
        tokentable(toknum2) = tokentable(toknum2) + 1
        ptrString + 1
      EndIf

      ptrString + 1
    Until skip_rest_of_line OR curchar = 0

    If (scanned_lines MOD 10) = 0 Then !WZ_Update_Gauge{scanned_lines, ped\ptrCurrentSourceData\TotalLines}
    scanned_lines = scanned_lines + 1                                                                                                                                                                                                   
    *sourceLine = *sourceLine\nextLine                                                                                                                                                                                                                   
  Wend

  ;-- build hierarchy tree
  log_Print{Str$(scanned_lines) + " lines scanned, building result tree..."}
  WZ_ShowMessage{!TRANS{"Building result tree..."}, 0}

  For toknum2 = 0 To 65535
    If tokentable(toknum2)
      tokname.s = PED_GetTokenName{toknum2}
      If tokname <> ""
        libnum.l = toknum2 LSR 7
        libname.s = lib_mapping$(libnum,0)

        entry.s = tokname + " (" + Str$(tokentable(toknum2)) + ")"
        If libname <> ""
          main.s = libname
          child.s= entry
          pid.l = HIERARCHY_GetParentID{main}
          If pid > 0
            HIERARCHY_AddChild{pid,child}
          Else
            HIERARCHY_AddParent{&lib_list,main}
            If child <> ""
              pid.l = HIERARCHY_GetParentID{main}
              If pid <> 0 Then HIERARCHY_AddChild{pid, child}
            EndIf
          EndIf
        Else
          HIERARCHY_AddParent{&lib_list, entry}
        EndIf
      EndIf
    EndIf
    If (toknum2 MOD 1024) = 0 Then !WZ_Update_Gauge{toknum2,65535}
  Next toknum2
  ;
  WZ_HideMessage{}

  Use Window WZID("WIN_LABELS")
  WZPrint "LIBRARY_LIST",0,lib_list

  WZ_UnlockAllOpenWindows{}
  Gosub set_pointer_normal
Return

.deletechar:
  ped\blockmarkRemovalMode = 1
  lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
  Gosub scroll_rest_of_line_left

  currentColumn.w =  ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset
  For cupos.w = currentColumn + 1 To #MAX_Columns-1
    Poke.b lineaddr + cupos - 1, Peek.b(lineaddr + cupos)
  Next cupos
  Poke.b lineaddr + #MAX_Columns-1, $20 ; add space at the end (overwriting last character)

  ; check for "" in line and prevent parsing of instructions
  quotation.b = 0
  storcol.w = ped\ptrCurrentSourceData\Column
  ped\ptrCurrentSourceData\Column = \visibleColumns - 1
  newcol.w = \visibleColumns + ped\ptrCurrentSourceData\ColumnsOffset - 1
  For cupos.w = newcol To 0 Step -1
    If Peek.b(lineaddr + cupos) = $22 Then quotation + 1
  Next cupos
  Poke.b ?instru, 0
  If NOT (quotation AND 1) Then Poke.b ?instru,1

  ;-- show character that comes visible at the right if line is longer than visiblecolumns
  PED_PrintChar{Peek.b(lineaddr + newcol)}
  Poke.b ?instru, 0
  ped\ptrCurrentSourceData\Column = storcol

  Gosub deletekey
Return

.updateSourceLine:        ; CursorXTarget: new Cursorposition
  log_Print{"update sourceline and moving cursor to x:" + Str$(CursorXTarget)}
  !PED_CursorOff

  lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
  storcol.w = ped\ptrCurrentSourceData\Column
  ped\ptrCurrentSourceData\Column = 0
  For cupos.w = 0 To \visibleColumns - 1
    enteredChar.b = Peek.b(lineaddr + ped\ptrCurrentSourceData\ColumnsOffset + cupos)
    PED_PrintChar{enteredChar}
    ADDQ.w #1,comWord_Column
  Next cupos
  ped\ptrCurrentSourceData\Column = storcol

  newColumn.w = CursorXTarget : Gosub moveCursorToX

  !PED_CursorOn
Return


.deletekey:
  ;log_Print{"deletekey, mode= " + Str$(sourceWindow\deleteMode)}
  ped\blockmarkRemovalMode = 2
  ped\ptrCurrentSourceData\KeyBeforeReturn = last_vankey

  ;If Peek.b(?nodelete) = 0
  If sourceWindow\deleteMode = False
    ; -- scroll to left by 1
    !PED_CursorOff
    Gosub scroll_rest_of_line_left

    ; -- move textbuffer left by 1 and append a space
    lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
    currentColumn.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset

    For cupos.w = currentColumn + 1 To #MAX_Columns-1
      Poke.b lineaddr + cupos - 1, Peek.b(lineaddr + cupos)
    Next cupos
    Poke.b lineaddr + #MAX_Columns-1, $20 ; add space at the end (overwriting last character)

    ; check for "" in line and prevent parsing of instructions
    storcol.w = ped\ptrCurrentSourceData\Column
    ped\ptrCurrentSourceData\Column = \visibleColumns - 1
    newcol.w = \visibleColumns - 1 + ped\ptrCurrentSourceData\ColumnsOffset
    quotation.b = 0
    For cupos.w = newcol To 0 Step -1
      If Peek.b(lineaddr + cupos) = $22 Then quotation + 1
    Next cupos
    Poke.b ?instru, 0
    If NOT (quotation AND 1) Then Poke.b ?instru,1

    ; show character that comes visible at the right if line is longer than visiblecolumns
    PED_PrintChar{Peek.b(lineaddr + newcol)}
    Poke.b ?instru, 0
    ped\ptrCurrentSourceData\Column = storcol

    ; check if Shift is pressed as well
    If ped\ptrCurrentSourceData\Column > 0 OR ped\ptrCurrentSourceData\ColumnsOffset > 0
      If (mqualifier.w AND #IEQUALIFIER_RSHIFT) OR (mqualifier AND #IEQUALIFIER_LSHIFT)
        ;log_Print{"shift"}
        If delete_mode.l = #VANILLAKEY_BACKSPACE
          If ped\ptrCurrentSourceData\Column > 0
            ped\ptrCurrentSourceData\Column - 1
            Goto deletekey
          EndIf
          If ped\ptrCurrentSourceData\ColumnsOffset > 0
            ped\ptrCurrentSourceData\ColumnsOffset - 1
            Goto deletekey
          EndIf
        EndIf
      Else
        Return
      EndIf
    EndIf
    Gosub redrawWithOffset ; horizontal scroll
  EndIf
  delete_mode = 0
Return

.moveCursorToX:     ; newColumn: new X-Position
  !PED_CursorOff
  log_Print{"move cursor to column: "  + Str$(newColumn.w)}
  oldColumnsOffset.w = ped\ptrCurrentSourceData\ColumnsOffset

  If newColumn <= sourceWindow\visibleColumns - sourceWindow\boundLinesX
    ped\ptrCurrentSourceData\ColumnsOffset = 0
    ped\ptrCurrentSourceData\Column = newColumn
  Else
    tmpvisColumns.w = sourceWindow\visibleColumns - 1
    newCursorPosX.w = newColumn - tmpvisColumns
    offColumns.w = #MAX_Columns - sourceWindow\visibleColumns
    If newCursorPosX < offColumns
      If newCursorPosX BitTst 0
        newCursorPosX + 1
        tmpvisColumns - 1
      EndIf
      ped\ptrCurrentSourceData\ColumnsOffset = newCursorPosX
      ped\ptrCurrentSourceData\Column = tmpvisColumns
    Else
      ped\ptrCurrentSourceData\ColumnsOffset = offColumns
      ped\ptrCurrentSourceData\Column = newColumn - offColumns
    EndIf
  EndIf

  If ped\ptrCurrentSourceData\ColumnsOffset <> oldColumnsOffset
    Gosub redrawWithOffset
  EndIf

  !PED_CursorOn
Return

.moveCursorLeft:
  !PED_CursorOff
  If ped\ptrCurrentSourceData\Column > \boundLinesX
    ped\ptrCurrentSourceData\Column - 1
    Goto exit_cursorleft
  EndIf

  If ped\ptrCurrentSourceData\ColumnsOffset > 1
    ped\ptrCurrentSourceData\ColumnsOffset - \scrollSize
    Gosub scroll_right
    ;ped\ptrCurrentSourceData\Column + 1
  Else
    If ped\ptrCurrentSourceData\ColumnsOffset = 1
      ped\ptrCurrentSourceData\ColumnsOffset = 0
      Gosub scroll_right
      PED_RedrawSource{}
    Else
      If ped\ptrCurrentSourceData\Column > 0
        ped\ptrCurrentSourceData\Column - 1
      EndIf
    EndIf
  EndIf

  exit_cursorleft:
  !PED_CursorOn
Return

.moveCursorRight:
  !PED_CursorOff
  If ped\ptrCurrentSourceData\ColumnsOffset + \visibleColumns => #MAX_Columns
    If ped\ptrCurrentSourceData\Column < \visibleColumns-1
      ped\ptrCurrentSourceData\Column + 1
    EndIf
  Else
    If \boundLinesX <= ped\ptrCurrentSourceData\Column
      If ped\ptrCurrentSourceData\Column > \visibleColumns - \boundLinesX
        ped\ptrCurrentSourceData\ColumnsOffset + \scrollSize
        Gosub scroll_left
        ;ped\ptrCurrentSourceData\Column - 1
        Goto exit_cursorright
      EndIf
    EndIf
    ped\ptrCurrentSourceData\Column + 1
  EndIf

  exit_cursorright:
  !PED_CursorOn
Return


.handle_event_newsizewindow:
  log_Print{"handle newsizewindow"}
  sourceWindow\WinTop = sourceWindow\win\TopEdge
  sourceWindow\WinLeft = sourceWindow\win\LeftEdge

  If pedMessage\_Qualifier <> $FFFFC000   ; update only if mousebutton has been released
    sourceWindow\WinWidth = sourceWindow\win\Width
    sourceWindow\WinHeight = sourceWindow\win\Height
    Gosub resize_sourcewindow
    FlushEvents
  EndIf
Return

.resize_sourcewindow:
  !PED_CursorOff
  ;Gosub free_textbuffer ;is fone in allocate_textbuffer
  Gosub calc_SourceWindowDimensions
  Gosub allocate_textbuffer
  Gosub clear_sourcewindow
  PED_RedrawSource{}
  !PED_CursorOn
Return


.eventHandler:
  pedEventClass.l = PED_GetMessage{True}

;  While pedEventClass <> 0

    ;If pedMessage\_Class<>#IDCMP_INTUITICKS AND pedMessage\_Class<>#IDCMP_MOUSEMOVE
    ;  log_Print{"eventmessage: " + Hex$(pedMessage\_Class) + ", " + Hexw$(pedMessage\_Qualifier) + ", " + Hexw$(pedMessage\_Code)}
    ;  log_Print{"window: " + Str$(pedMessage\_Window) + "  MouseX:"  + Str$(pedMessage\_MouseX)}
    ;End If

    ; context onlinehelp for most windows
    If pedconfig\onlinehelp <> 0
      If (pedMessage\_Class<>#IDCMP_INTUITICKS) AND (pedMessage\_Class<>#IDCMP_ACTIVEWINDOW) AND (pedMessage\_Class<>#IDCMP_GADGETHELP)  AND (pedMessage\_Class<>#IDCMP_CHANGEWINDOW)
        WZ_HideHelp{}
      EndIf
      If pedMessage\_Class = #IDCMP_GADGETHELP Then WZ_ShowHelp{}
    EndIf


    If pedMessage\_Class = #IDCMP_MENUPICK
      ;addr_menuitem.l = ItemAddress_(ped\menuStrip,pedMessage\_Code)
      ;If addr_menuitem    ; added to protect agains MENUNULL  tomsmart1
      ;  _menuitem.l = Peek.l(addr_menuitem+$22)
      ;  Gosub event_menu
      ;EndIf
      Gosub handle_event_menupick
      exit_eventloop = True
    Else
      Use Window pedMessage\_Window
      Select pedMessage\_Window
        Case 0                              : Gosub event_sourcewindow
        Case WZID("WIN_SEARCH")             : Gosub event_find
        Case WZID("WIN_CONTEXTHELP")        : If pedMessage\_Class = #IDCMP_CLOSEWINDOW Then Gosub close_contexthelp
        Case WZID("WIN_NEWTYPE")            : Gosub event_definitionbrowser
        Case WZID("WIN_INSTRUCTIONBROWSER") : Gosub event_instructionbrowser
        Case WZID("WIN_LIBRARYBROWSER")     : Gosub event_librarybrowser
        Case WZID("WIN_LABELS")             : Gosub event_sourcebrowser
        Case WZID("WIN_POPUP")              : Gosub event_popup
        Case WZID("WIN_HELPDIAG")           : Gosub event_diag
        Case WZID("WIN_SHORTCUTS")          : Gosub event_shortcuts
      Default
        error{"received message from unknown window [" + Str$(pedMessage\_Window) + "]"}
      End Select
    EndIf

;    pedEventClass = PED_GetMessage{True}
;  Wend


  ;--  handle Arexx events
  CNIF #USE_AREXX = 1
    If arexx_GetMsg{True} Then Gosub arexx_event
  CEND

  If Peek.b(?comByte_RunningFlag) <> 0
    PED_ShowMessage{!TRANS{"!!!PROGRAM IS RUNNING: ONLY SAVE/NAVIGATION/HELP WILL WORK..."}}
    rf.l = 1
  Else
    If rf = 1 AND Peek.b(?comByte_RunningFlag) = 0
      PED_ShowMessage{""}
      rf = 0
    End If
  EndIf
Return




; ########################################################################################
.AREXX
CNIF #USE_AREXX = 1
  XINCLUDE "PED_arexx.ab3"
CEND
; ########################################################################################

.set_tedlibbase:
  TEDSetJumpTable  {?COMDATABASE}
  TEDSetFirstLine  {?comPtr_FirstSourceLine}
  TEDSetCurrentLine{?comPtr_CurrentSourceLine} ; or Peek.l(?comPtr_CurrentSourceLine) !?
  TEDSetLabelList  {?comPtr_LabelList}
  TEDSetLabelCount {?comWord_LabelCounter}
Return


.update_debuggertoggle:
  ped\debugMode = Peek.b(?comByte_DebugMode)
  GTSetMenuChecked 0,4,12,ped\debugMode                                                                                                                                                                                                                  
  ;log_Print{"updated Debugstatus: " + Str$(ped\debugMode)}                                                                                                                                                                                              
Return


.event_sourcewindow:
  exit_loop_class.b = 0
  exit_loop_code.l = 0
  last_vankey.b = 0
  last_rawkey.l = 0
  last_mqualifier.w = 0
  last_menuentry.l = 0
  last_event.l = pedMessage\_Class

  ;If pedMessage\_Class<>$400000 AND pedMessage\_Class<>$10
  ;  log_Print{"source window event: " +Hex$(pedMessage\_Class) + ", " + Hex$(pedMessage\_Qualifier)+ ", " + Hex$(pedMessage\_Code)}
  ;EndIf

  ;If (pedMessage\_Class <> #IDCMP_INTUITICKS) AND (pedMessage\_Class <> #IDCMP_ACTIVEWINDOW) AND (pedMessage\_Class <> #IDCMP_GADGETHELP) AND (pedMessage\_Class <> #IDCMP_CHANGEWINDOW)
  ;  WZ_HideHelp{}
  ;EndIf

  Select pedMessage\_Class
  Case #IDCMP_INTUITICKS
    Gosub handle_event_intuiticks

  Case #IDCMP_REFRESHWINDOW
    Gosub handle_event_newsizewindow

  Case #IDCMP_NEWSIZE
    Gosub handle_event_newsizewindow

  Case #IDCMP_CHANGEWINDOW
    Gosub handle_event_newsizewindow

  Case #IDCMP_ACTIVEWINDOW
    Use Window 0
    !PED_CursorOn

  Case #IDCMP_INACTIVEWINDOW
    !PED_CursorOff

  Case #IDCMP_GADGETDOWN
    Gosub handle_event_gadget

  Case #IDCMP_GADGETUP
    *gadget.Gadget = pedMessage\_IAddress
    ;log_Print{"GADGETUP"}
    ;log_Print{"GadgetID " + Str$(*gadget\GadgetID) + ", Type " + Hex$(*gadget\GadgetType) + ", Activation " + Hex$(*gadget\Activation)}
    ;log_Print{"byte type " + Str$(*gadget\GadgetType AND $00FF)}

  Case #IDCMP_MENUVERIFY
    ; do nothing

  Case #IDCMP_CLOSEWINDOW
    ; exit_loop_code = #MENU_CLOSE
    ; exit_loop_class = -2

    log_Print{"CLOSEWINDOW"}
    _menuitem = #MENU_CLOSE
    Gosub event_menu

  Case #IDCMP_MOUSEBUTTONS
    Gosub handle_event_mousebuttons

  Case #IDCMP_RAWKEY
    Gosub handle_event_rawkey
    ; some events are converted to vanilla events, handle them now:
    If last_vankey <> 0 Then Gosub handle_event_vanillakey
    ;exit_eventloop = True

  Case #IDCMP_VANILLAKEY
    last_vankey = 0
    Gosub handle_event_vanillakey
    ;exit_eventloop = True

  Case #IDCMP_EXTENDEDMOUSE
    Gosub handle_event_extendedmouse

  Case #IDCMP_MOUSEMOVE
    Gosub handle_event_mousemove

  End Select
Return

.handle_event_intuiticks:
  ; ------------ cursor blinking
  blinkcount.b + 1
  If pedconfig\blinkrate > 0
    If blinkcount >= pedconfig\blinkrate
      blinkcount = 0
      ;log_Print{"blink " + Str$(Peek.b(?state_of_cursor))}
      PED_SwitchCursor{}
    EndIf
  EndIf
 
  ; ---------------------------------
  If pedconfig\onlinehelp_extended AND pedMessage <> 0
    ; -- wait for at least 1 second before displaying the context
    help_ticks.b + 1 : If help_ticks < 10 Goto skip_this

    ; -- check sourcearea
    USEPATH sourceWindow
    If pedMessage\_MouseX - \win\BorderLeft<0 Then Goto skip_this
    If pedMessage\_MouseY - \win\BorderTop <0 Then Goto skip_this
    If pedMessage\_MouseY - \win\BorderTop - \statusAreaY > 0 Then Goto skip_this
    If pedMessage\_MouseX - \win\BorderRight - \win\Width > 0 Then Goto skip_this
    If (pedMessage\_MouseX = ocmousex.w) AND (pedMessage\_MouseY = ocmousey.w) Then Goto skip_this

    ;log_Print{"checking context help"}
    ; -- check mouseposition in source area
    textX.w = (pedMessage\_MouseX - \win\BorderLeft - \BoxLeft) / \font\tf_XSize + ped\ptrCurrentSourceData\ColumnsOffset + 1
    textY.w = (pedMessage\_MouseY - \win\BorderTop - \BoxTop) / \font\tf_YSize + ped\ptrCurrentSourceData\DisplayLineOffset + 1

    If textX = otextX.w AND textY = otextY.w Then Goto skip_this
    otextX = textX : otextY = textY
    ; -- get the currentsourceline and move to mouse cursor-line
    actualLine.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine + 1
    totalLines.l = ped\ptrCurrentSourceData\TotalLines
    *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    delta.w = textY - actualLine
    If (delta <= totalLines) AND (actualLine + delta > 0)
      If delta > 0
        For si.w = 1 To delta
          If *tempLine\nextLine Then *tempLine = *tempLine\nextLine
        Next si
      Else
        If delta < 0
          For si.w = -1 To delta Step -1
            If *tempLine\previousLine Then *tempLine = *tempLine\previousLine
          Next si
        EndIf
      EndIf

      ; -- check out the help and display it
      If *tempLine
        strline$ = PED_Detoke{*tempLine}
        helptext$ = PED_GetWordAtPos{strline$,textX, True}
        If helptext$ <> ""
          helpvalue.l = 0 : msg$ = ""
          ;-- check for a constant
          If Left$(helptext$,1) = "#"
            helptext$ = UnRight$(helptext$,1)
            helpvalue = PED_GetConstantValue{helptext$}
          Else
            ;-- check for a newtype
            *var.l = PED_GetVariableByName{helptext$}
          EndIf
          ;            $45464748
          ;PED_ShowMessage{helptext$}
          If helpvalue = 0 Then helpvalue = Vallong(helptext$)
          If helpvalue <> 0
            msg$ = helptext$
            ;log_Print{ Str$(helpvalue) }
            helpvaluestr.s = Str$(helpvalue)
            msg$ + Chr$(10) + Chr$(10) + "# " + helpvaluestr
            msg$ + Chr$(10) + "$ " + Hex$(helpvalue)
            msg$ + Chr$(10) + "% " + Bin$(helpvalue)
            msg$ + Chr$(10) + Mkl$(helpvalue)
          Else
            If *var
              msg$ = helptext$
              msg$ + Chr$(10) + Chr$(10) + "(variable) " + PED_GetNewtypeOf{helptext$}
            EndIf
          EndIf
          If msg$ <> ""
            log_Print{"showing context help: " + msg$}
            WZ_ShowHelp{msg$}
          Else
            WZ_HideHelp{}
          EndIf
          help_ticks = 0
          ocmousex.w = pedMessage\_MouseX : ocmousey.w = pedMessage\_MouseY
        EndIf
      EndIf
    EndIf
    skip_this:
    ;log_Print{"check context end"}
  EndIf
Return

.handle_event_menupick:
  log_Print{"handle_event_menupick - selected menuitem: " + Hex$(_menuitem.l)}
  If pedMessage\_Code <> -1
    ;Gosub set_tedlibbase
    _menuNumber.w = pedMessage\_Code
    _ItemAddress.l = ItemAddress_(ped\menuStrip,_menuNumber AND #MaxWord)
    _menuitem.l = Peek.l(_ItemAddress + $22)             ; Userdata of GadTools, longword right after MenuItem-struct
    exit_loop_class.b = -2
    exit_eventloop.b = True
  EndIf
Return

.handle_event_gadget:
   *gadget.Gadget = pedMessage\_IAddress

    exit_gadgetloop.b = False
    ;log_Print{"GADGETDOWN " + Hex$(pedMessage\_Class)}
    ;log_Print{"GadgetID " + Str$(*gadget\GadgetID) + ", Type " + Hex$(*gadget\GadgetType) + ", Activation " + Hex$(*gadget\Activation)}
    ;log_Print{"byte type " + Str$(*gadget\GadgetType AND $00FF)}

    Select *gadget\GadgetID
    Case #GID_UARROW: last_vankey = $1C : Gosub handle_event_vanillakey
    Case #GID_DARROW: last_vankey = $1D : Gosub handle_event_vanillakey
    Case #GID_RARROW: last_vankey = $1E : Gosub handle_event_vanillakey
    Case #GID_LARROW: last_vankey = $1F : Gosub handle_event_vanillakey
    Case #GID_XPROP
      DEFTYPE.l pos_hprop
      FlushEvents
      Repeat
        If pedMessage\_Class <> 0
          If pedMessage\_Class <> #IDCMP_GADGETUP
            GetAttr_ #PGA_Top, sourceWindow\horizprop, &pos_hprop                                                                                                                                                                                        
            newColumn.w = pos_hprop : Gosub moveCursorToX
            ;!PED_CursorOn
            PED_UpdateStatusArea{#STATUS_CURSOR|#STATUS_SCROLLERS}                                                                                                                                                                                       
          Else
            *g.Gadget = pedMessage\_IAddress
            ;If pedMessage\_Class = #IDCMP_GADGETUP AND pedMessage\_Code <> 0 OR pedMessage\_Window<>0
            If *g\GadgetID = #GID_XPROP  Then exit_gadgetloop = True
          EndIf
        EndIf
        PED_GetMessage{False}
      Until exit_gadgetloop = True
      !PED_CursorOn

    Case #GID_YPROP
      If ped\ptrCurrentSourceData\DisplayLineOffset < ped\ptrCurrentSourceData\TotalLines
        ped\ptrCurrentSourceData\LinePosStartX = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine

        Repeat
          If pedMessage\_Class <> 0
            *g.Gadget = pedMessage\_IAddress

            If pedMessage\_Class <> #IDCMP_GADGETUP
              GetAttr_ #PGA_Top,sourceWindow\vertiprop,&slider_top.l                                                                                                                                                                                     
              totallines.l = ped\ptrCurrentSourceData\TotalLines
              If totallines >= #max_slider_res
                !mul48f{slider_top,totallines,#max_slider_res,realline.l}
              Else
                realline = slider_top
              EndIf
              realline + ped\ptrCurrentSourceData\DisplayLine

              If Peek.l(?comWord_LinePosStartX) <> realline
                Poke.l ?comWord_LinePosStartX, realline
                PED_GotoLine{realline}
                PED_UpdateStatusArea{#STATUS_CURSOR|#STATUS_SCROLLERS}
              EndIf

              ;If pedMessage\_Class = #IDCMP_RAWKEY Then exit_gadgetloop = True
              If pedMessage\_Class = #IDCMP_MOUSEBUTTONS Then exit_gadgetloop = True
            Else
              ; cannot check For GadgetID because of tools like FreeWheel, I do not get the correct GadgetID everytime !?
              If *g\GadgetID = #GID_YPROP AND pedMessage\_Class = #IDCMP_GADGETUP Then exit_gadgetloop = True
            EndIf
            ;log_Print{"YPROP " + Hex$(pedMessage\_Class) + " " + Hexw$(pedMessage\_Code) + " " + Str$(pedMessage\_Window) + "  GadID: " + Str$(*g\GadgetID)}
            ;log_Print{"IAddress: " +Str$(pedMessage\_IAddress) + "  type: " + Hex$(*g\GadgetType) + " x:" + Str$(*g\LeftEdge) + ", y:" + Str$(*g\TopEdge)}
          EndIf
          PED_GetMessage{False}
        Until exit_gadgetloop = True
        ;log_Print{"exit proploop"}
        !PED_CursorOn
      EndIf
    End Select
Return


.handle_event_mousebuttons:
  ;log_Print{"handle event mousebuttons..."}
  If NOT Peek.b(?comByte_RunningFlag)            ; only available when no exe is running
    Gosub check_mouse_in_statusarea
  EndIf
; exit_Loop_classes:
;                     Dc.b $FF,$01                  ; VERTICAL SCROLLER      ; -1
;                     Dc.b $FE,$00                  ; SHORTCUT               ; -2
;                     Dc.b $FD,$01                  ; L-MOUSEBUTTON          ; -3
;                     Dc.b $FB,$01                  ; AJL_0_7FCC             ; -4
  Select pedMessage\_Code
  Case #SELECTUP
    If was_selectdown_before.b = True
;      log_Print{"Mouse-Event SELECTUP",#log_debug}
      was_selectdown_before = False
      ;exit_loop_class = -4 ; AJL_0_7FCC
      ;exit_eventloop = True
    EndIf

  Case #SELECTDOWN
    was_selectdown_before.b = True
;    log_Print{"Mouse-Event SELECTDOWN",#log_debug}
    exit_loop_class = -3
    ; left mb not pressed anymore, check doubleclick
    isDoubleClick.b = DoubleClick_(SSeconds.l,SMicros.l,pedMessage\_Seconds,pedMessage\_Micros)
    SSeconds = pedMessage\_Seconds
    SMicros = pedMessage\_Micros
    If pedMessage\_MouseX = Mmx.w AND pedMessage\_MouseY = Mmy.w Then isSameMousePosition.b = True Else isSameMousePosition = False
    Mmx = pedMessage\_MouseX
    Mmy = pedMessage\_MouseY
    If isDoubleClick AND isSameMousePosition
      strline$ = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
      actualword$ = PED_GetWordAtPos{strline$, ped\ptrCurrentSourceData\Column,True}
      log_Print{"doubleclick on ==>" + actualword$}
      If WZ_IsOpen{"WIN_LABELS"}
        LabelListSearchString = StripLead$(LCase$(actualword$),32)
        If Left$(LabelListSearchString,1)="." Then LabelListSearchString = Right$(LabelListSearchString,-1)
        Use Window WZID("WIN_LABELS")
        WZPrint "STRING_LABEL",LabelListSearchString
        Gosub reset_labellist
      EndIf
    Else
      exit_eventloop = True
    EndIf

  Case #MIDDLEDOWN
    log_Print{"Mouse-Event MIDDLEDOWN",#log_debug}
    If NOT (pedMessage\_Qualifier AND (#IEQUALIFIER_LALT | #IEQUALIFIER_RALT))
      Gosub jump_historyup
    EndIf
  End Select
Return

.handle_event_rawkey:
  mqualifier.w = pedMessage\_Qualifier
  mcode.w = pedMessage\_Code
  ;log_Print{"========= rawkey    code: "+ Hexw$(mcode) + " / quali: "+ Hex$(mqualifier)}
  last_rawkey = pedMessage\_Code       ; rename it to avoid clashes with vanillakey tomsmart1
  last_vankey = 0
  ped\ptrCurrentSourceData\QualifierStore = mqualifier

  ; check for Mousewheel Rawkey events from newmouse definition
  Select last_rawkey
  Case #NM_WHEEL_DOWN
    log_Print{"wheel down"}
    Gosub wheel_down

  Case #NM_WHEEL_UP
    log_Print{"wheel up"}
    Gosub wheel_up
  End Select

  ; check for F-Keys / HELP / RETURN / CURSOR
  If mcode = #RAWKEY_HELP Then last_vankey = #VANILLAKEY_HELP
  If mcode = #RAWKEY_TAB Then last_vankey = #VANILLAKEY_TAB
  If mcode = #RAWKEY_RETURN Then last_vankey = #VANILLAKEY_RETURN
  If (mcode => #RAWKEY_F1) AND (mcode <= #RAWKEY_F10) Then last_vankey = mcode + $31 ; convert F-KEYs to vanillakey
  If (mcode => #RAWKEY_UP) AND (mcode <= #RAWKEY_LEFT) Then last_vankey = mcode - $30
Return

.handle_event_vanillakey:
  If last_vankey = 0 Then last_vankey = pedMessage\_Code
  last_rawkey = 0
  mqualifier.w  = pedMessage\_Qualifier AND (NOT #IEQUALIFIER_RELATIVEMOUSE)
  last_mqualifier.w = mqualifier
  ped\ptrCurrentSourceData\QualifierStore = mqualifier
  ;log_Print{"event vanillakey: " + Hexw$(last_vankey) + " qualifier: " + Hexw$(mqualifier)}

  ; check key first
  Select last_vankey
  Case #VANILLAKEY_RETURN
    Gosub immediate_syntaxhelp
    ;Gosub do_VANILLAKEY_RETURN
    exit_eventloop.b = True
    Pop Select: Return

  Case #VANILLAKEY_HELP
    log_Print{"HELP"}
    Select mqualifier
    Case #IEQUALIFIER_CONTROL
      log_Print{" + CONTROL"}
      Gosub open_helpdiag

    Case #IEQUALIFIER_LSHIFT
      Gosub startguide

    Case #IEQUALIFIER_RSHIFT
      Gosub startguide

    Default
      log_Print{"default"}
      Gosub immediate_syntaxhelp
    End Select
    Pop Select: Return

  Case #VANILLAKEY_ESC
    Gosub close_contexthelp
    Gosub close_popupwindow
    Pop Select: Return

  Case #VANILLAKEY_DELETE
    Gosub do_VANILLAKEY_DELETE
    exit_eventloop = True
    Pop Select : Return

  Case #VANILLAKEY_BACKSPACE
    Gosub do_VANILLAKEY_BACKSPACE
    exit_eventloop.b = True
    Pop Select : Return

  Case #VANILLAKEY_TAB
    Gosub do_VANILLAKEY_TAB
    exit_eventloop.b = True
    Pop Select : Return

  Case #VANILLAKEY_UP       ; ---------------------------------------------------------------- Cursor Up
    exit_eventloop.b = True
    Pop Select : Return

  Case #VANILLAKEY_DOWN    ; ------------------------------------------------------------------------------------- Cursor Down
    exit_eventloop.b = True
    Pop Select: Return

  Case #VANILLAKEY_LEFT         ; -------------------------------------------------------------- Cursor Left
    If (mqualifier AND #IEQUALIFIER_RSHIFT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
    EndIf
    If (mqualifier AND #IEQUALIFIER_RALT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
    EndIf
    ;log_Print{"cursor left: " +Hex$(mqualifier)}

    Select mqualifier
    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL    ; $800A: select block right
      log_Print{"shift + alt"}
      Gosub selectblockleft

    Case #IEQUALIFIER_LSHIFT          ; move cursor to beginning of line
      ;log_Print{"shift"}
      If ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset > 0
        newColumn.w = 0 : Gosub moveCursorToX
      Else
        If ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine > 0
          runner.w = 0
          Repeat
            curbyte.b = Peek.b(ped\ptrCurrentSourceData\CurrentSourceLine + 9 + runner)
            runner + 1
          Until (curbyte <> $20) OR (curbyte = 0) OR (runner = #MAX_Columns)
          If (curbyte <> 0) AND (runner > 0)
            runner - 1
            newColumn.w = runner : Gosub moveCursorToX
          EndIf
        EndIf
      EndIf

    Case #IEQUALIFIER_LALT
      log_Print{"alt"}
      Gosub jump_historyup

    Case #IEQUALIFIER_CONTROL                   ; ctrl
      log_Print{"control"}
      If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
        !PED_CursorOff
        Gosub menu_blockuntab
      Else
        Gosub moveCursorToBeginOfWord
        newColumn.w = cursorpos : Gosub moveCursorToX
      EndIf

    Default
      ;log_Print{"no qualifier key"}
      ped\blockmarkRemovalMode = 1
      Gosub moveCursorLeft
    End Select
    PED_UpdateStatusArea{#STATUS_SCROLLERS}                                                                                                                                                                                                              

    Pop Select: Return

  Case #VANILLAKEY_RIGHT            ; ----------------------------------------------------------------------- Cursor Right
    ;log_Print{"cursor right"}
    If (mqualifier AND #IEQUALIFIER_RSHIFT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
    EndIf
    If (mqualifier AND #IEQUALIFIER_RALT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
    EndIf

    Select mqualifier
    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL    ; $800A: select block right
      log_Print{"shift + alt"}
      Gosub selectblockright

    Case #IEQUALIFIER_LSHIFT         ; move to end of line
      log_Print{"shift"}
      lineaddr = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
      textlen.w = getLineLength{lineaddr}
      newColumn.w = textlen : Gosub moveCursorToX

    Case #IEQUALIFIER_LALT           ; move in history
      log_Print{"alt"}
      Gosub jump_historydown

    Case #IEQUALIFIER_CONTROL        ; $8 tab the marked block
      log_Print{"control"}
      If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
        !PED_CursorOff
        Gosub menu_blocktab
      Else
        Gosub moveCursorToEndOfWord
      EndIf
 
    Default
      ped\blockmarkRemovalMode = 1
      Gosub moveCursorRight

    End Select

    PED_UpdateStatusArea{#STATUS_SCROLLERS}                                                                                                                                                                                                              
    Pop Select : Return

  End Select

  ;----------------------------------- check QUALIFIER first
  ; convert right qualifiers to left qualifiers to make selectblock smarter
  If (mqualifier AND #IEQUALIFIER_RSHIFT)
     mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
  EndIf

  Select mqualifier
  Case #IEQUALIFIER_CONTROL         ; CTRL   ---------------------------------------------------------------------------------------
    log_Print{"CONTROL + $" + Hexb$(last_vankey)}
    Select last_vankey
    Case $15                        ; ctrl-u
      PED_RedrawSource{}

    Case $0e                        ; ctrl-n
      a$ = "newtype ." : Gosub insertstring
      Gosub insertreturn
      Gosub insertreturn
      a$ = "end newtype " : Gosub insertstring

    Case $06                        ; ctrl-f
      a$ = "function.l { }" : Gosub insertstring
      Gosub insertreturn
      Gosub insertreturn
      a$ = "function return 0" : Gosub insertstring
      Gosub insertreturn
      a$ = "end function " : Gosub insertstring

    Case $13                        ; ctrl-s
      a$ = "statement { }" : Gosub insertstring
      Gosub insertreturn
      Gosub insertreturn
      a$ = "end statement " : Gosub insertstring

    Case $05                        ; ctrl-e
      a$ = "end if "
      !PED_CursorOff
      Gosub insertstring

    Case $03                        ; ctrl-c
      ped\verticalCopyMode = True    ; set it for column copy
      Gosub menu_copy                         ; do normal copy
      ped\verticalCopyMode = False   ; set it to normal copy

    Case $16                        ; ctrl-v
      ped\verticalCopyMode = True   ; for vertical (Column) paste
      Gosub menu_paste                        ; do paste
      ped\verticalCopyMode = False  ; restore it for normal paste

    Case $18                        ; ctrl-x
      Gosub menu_cut

    Case $09                        ; ctrl-i
      log_Print{"toggle intellisense for commands "}
      If pedconfig\use_commandsintellisens
        pedconfig\use_commandsintellisens = False
      Else
        pedconfig\use_commandsintellisens = True
      EndIf
      last_vankey = 0               ; clear Key
      Gosub intellisense            ; update popupwin
    End Select
    exit_eventloop = True

    Pop Select : Return

  Case #IEQUALIFIER_LCOMMAND + #IEQUALIFIER_LSHIFT
    log_Print{"lcommand and lshift"}
    Select last_vankey
    Case $21                                ; check for "L-AMiGA_!", "LEFT AMIGA + SHIFT + 1"
      sourceWindow\bookmarkLine1 = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset

    Case $22                                ; check for "L-AMiGA_!", "LEFT AMIGA + SHIFT + 2"
      sourceWindow\bookmarkLine2 = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset

    Case $23                                ; check for "L-AMiGA_!", "LEFT AMIGA + SHIFT + 3"
      sourceWindow\bookmarkLine3 = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
    End Select

    Pop Select : Return

  Case #IEQUALIFIER_LCOMMAND        ; LAMIGA -----------------------------------------------------------------------------------------------
    goto_line.l = 0
    log_Print{"lamiga"}
    Select last_vankey
    Case #VANILLAKEY_F4             ; L-AMIGA-F4
       savewinpref{0} : Gosub write_newprefs

    Case #VANILLAKEY_F5             ; L-AMIGA-F5
       savewinpref{1} : Gosub write_newprefs

    Case #VANILLAKEY_F6             ; L-AMIGA-F6
       savewinpref{2} : Gosub write_newprefs

    Case $61                       ; L-AMIGA-A
      goto_line = sourceWindow\lastEditedLine

    Case $31                       ; L-AMIGA-1
      goto_line = sourceWindow\bookmarkLine1

    Case $32                       ; L-AMIGA-2
      goto_line = sourceWindow\bookmarkLine2

    Case $33                       ; L-AMIGA-3
      goto_line = sourceWindow\bookmarkLine3

    End Select

    If goto_line
      PED_GotoLine{goto_line}
    EndIf
    Pop Select : Return
  End Select

  Select last_vankey
  Case #VANILLAKEY_F1               ; F1
    Gosub menu_helpgeneral

  Case #VANILLAKEY_F2               ; check for "F2"
    Gosub menu_helpincludesguide

  Case #VANILLAKEY_F3               ; check for "F3"
    Gosub menu_helpblitzlibs

  Case #VANILLAKEY_F4               ; check for "F4"
    ped\lastLayout = 0
    Gosub load_windowlayouts
    Gosub do_windowlayout

  Case #VANILLAKEY_F5               ; check for "F5"
    ped\lastLayout  = 1
    Gosub load_windowlayouts
    Gosub do_windowlayout

  Case #VANILLAKEY_F6               ; check for "F6"
    ped\lastLayout  = 2
    Gosub load_windowlayouts
    Gosub do_windowlayout

  Case #VANILLAKEY_F7               ; check for "F7"
    Gosub navigate_to_previous_label

  Case #VANILLAKEY_F8               ; check for "F8"
    Gosub navigate_to_next_label

  Case #VANILLAKEY_F9               ; check for "F9"
    Gosub menu_previousfile

  Case #VANILLAKEY_F10              ; check for "F10"
    Gosub menu_nextfile

  Default
    ;log_Print{"no special handling of vanillakey: " + Hexw$(last_vankey) + " *** INSERT CHAR*"}
    Gosub insertchar
    ;exit_loop_class = last_vankey
    ;exit_eventloop.b = True
  End Select
Return

.do_VANILLAKEY_RETURN:
  log_Print{"RETURN"}
  Gosub close_popupwindow
  Gosub insertreturn
Return

.do_VANILLAKEY_DELETE
  log_Print{"DELETE"}
  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : Gosub handle_blockmark
    Return
  EndIf

  If (mqualifier AND #IEQUALIFIER_RSHIFT)
    mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
  EndIf

  Select mqualifier
  Case #IEQUALIFIER_LSHIFT
    log_Print{"SHIFT"}
    ped\ptrCurrentSourceData\KeyBeforeReturn = last_vankey       ; save keycode
    CursorXTarget.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset
    ; delete all until end of line (replace with spaces)
    lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
    For cupos.w = CursorXTarget To #MAX_Columns-1
      Poke.b lineaddr + cupos, $20
    Next cupos
    Gosub updateSourceLine

  Default
    Gosub deletekey

  End Select
Return

.do_VANILLAKEY_BACKSPACE
  log_Print{"BACKSPACE"}
  If ped\ptrCurrentSourceData\Column > 0 OR ped\ptrCurrentSourceData\ColumnsOffset > 0
    Gosub moveCursorLeft
    delete_mode.l = #VANILLAKEY_BACKSPACE
    Gosub deletekey
    delete_mode = 0
  Else
      If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
        ped\blockmarkRemovalMode = 2 : Gosub handle_blockmark
        ;Gosub deletekey
      Else
        actualLine.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine
        If actualLine > 0
          log_Print{"join lines!"}
          Gosub storeline
          Gosub movecursorlineup
          ; find last character in previous line
          lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
          tempOffset.w = #MAX_Columns - 1
          While Peek.b(lineaddr+tempOffset) = $20 AND tempOffset>-1
            tempOffset - 1
          Wend
          tempOffset + 1
          ;log_Print{"calculated column: " + Str$(tempOffset)}

          ped\ptrCurrentSourceData\Column = tempOffset
          Gosub menu_joinline
        EndIf
      EndIf
  EndIf
Return

.do_VANILLAKEY_TAB:
  log_Print{"TAB   " + Hexw$(last_vankey)}
  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : Gosub handle_blockmark
  EndIf

  ;log_Print{Hex$(mqualifier)}
  ped\ptrCurrentSourceData\KeyBeforeReturn = last_vankey

  If pedconfig\tabSize = 0 Then pedconfig\tabSize = 1
  currentColumn.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset

  If (mqualifier AND #IEQUALIFIER_RSHIFT) OR (mqualifier AND #IEQUALIFIER_LSHIFT)
    ;log_Print{"shift"}
    newColumn.w = currentColumn - pedconfig\tabSize
  Else
    newColumn.w = currentColumn + pedconfig\tabSize
  EndIf
  moveCount.b = newColumn - currentColumn

  ;log_Print{"move " + Str$(moveCount) + "  newColumn: " + Str$(newColumn)}
 
  If (newColumn < #MAX_Columns) AND (newColumn >= 0)
    ; check blockmark
    If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
      result.b = 0
      !checkBeforeBlockStartX{result}
      If result Then ped\ptrCurrentSourceData\BlockStartX + moveCount
      !checkBeforeBlockEndX{result}
      If result Then ped\ptrCurrentSourceData\BlockEndX + moveCount
      Gosub adjustBlockPosition
    EndIf

    ;-- move rest of line to right or left
    lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
    ;log_Print{"currentcolumn: " +Str$(currentColumn)}
    ;log_Print{Peeks$(lineaddr, 30)}
    If moveCount > 0
      For cupos.w = #MAX_Columns-1 To currentColumn Step -1
        Poke.b lineaddr + cupos, Peek.b(lineaddr + cupos - moveCount)
      Next cupos

      ;-- scroll tabSize to right and fill with new space characters
      ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset
      For cupos.w = 0 To moveCount - 1
        Poke.b lineaddr + currentColumn + cupos,$20 ; insert space character
        PED_ScrollHorizontal{#SCROLL_RIGHT, #SCROLL_CURRENT_LINE}
        PED_PrintChar{$20}
      Next cupos
 
      ;-- set new cursor position
      newColumn.w = ped\ptrCurrentSourceData\Column + moveCount : Gosub moveCursorToX

    Else
      ; move characters to left an fill with empty spaces
      For aaa.b = 1 To Abs(moveCount)
        For cupos.w = newColumn To #MAX_Columns-1
          Poke.b lineaddr + cupos, Peek.b(lineaddr + cupos + 1)
        Next cupos
      Next aaa
      For cupos.w = #MAX_Columns-1 + moveCount To #MAX_Columns-1
        Poke.b lineaddr + cupos, $20 ; insert space character
      Next cupos

      ped\ptrCurrentSourceData\Column + moveCount
      CursorXTarget.w = ped\ptrCurrentSourceData\Column
      Gosub updateSourceLine

    EndIf
    ;log_Print{Peeks$(lineaddr, 30)}

  EndIf
Return



.do_VANILLAKEY_UP:
    Gosub close_popupwindow

    ; convert right qualifiers to left qualifiers to make selectblock smarter
    If (mqualifier AND #IEQUALIFIER_RSHIFT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
    EndIf
    If (mqualifier AND #IEQUALIFIER_RALT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
    EndIf

    ; remove REPEAT qualifier
    mqualifier = mqualifier & (NOT #IEQUALIFIER_REPEAT); remove "pressing" flag

    Select mqualifier
    Case 0  ;#IEQUALIFIER_RELATIVEMOUSE   ; $8000 (just the key)
      ped\blockmarkRemovalMode = 1
      Gosub movecursorlineup

    Case #IEQUALIFIER_LSHIFT   ; $8001
      log_Print{"shift"}
      tmpvalue.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine
      log_Print{"current line: " + Str$(tmpvalue)}
      If tmpvalue < sourceWindow\visibleLines
        tmpvalue = 0
      Else
        tmpvalue = tmpvalue - sourceWindow\visibleLines
      EndIf
      log_Print{"going to line: " + Str$(tmpvalue)}
      PED_GotoLine{tmpvalue}

    Case #IEQUALIFIER_CONTROL  ; $8008
      log_Print{"control"}
      Gosub menu_top

    Case #IEQUALIFIER_LALT     ; $8010
      log_Print{"alt"}
      Gosub movelineup

    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL ; $8009
      log_Print{"shift + control"}
      Gosub selectblockup

    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_LALT    ; $800A: select block upwarts
      log_Print{"shift + alt"}
      Gosub selectblockup

    ;Case $0000                         ; cursor_up for freewheel

    Default
      log_Print{"default"}
      Gosub movecursorlineup
    End Select
Return

.do_VANILLAKEY_DOWN:
  ;log_Print{"cursor down"}
    Gosub close_popupwindow

    ; convert right qualifiers to left qualifiers to make selectblock smarter
    If (mqualifier AND #IEQUALIFIER_RSHIFT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
    EndIf
    If (mqualifier AND #IEQUALIFIER_RALT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
    EndIf
    ; remove REPEAT qualifier
    mqualifier = mqualifier & (NOT #IEQUALIFIER_REPEAT); remove "pressing" flag

    Select mqualifier
    Case 0  ;#IEQUALIFIER_RELATIVEMOUSE                         ; $8000: one line down
      ped\blockmarkRemovalMode = 1
      Gosub movecursorlinedown

    Case #IEQUALIFIER_LSHIFT   ; $8001: page down
      log_Print{"shift"}
      lineNum.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine
      log_Print{"current line: " + Str$(lineNum)}
      lineNum + sourceWindow\visibleLines
      If lineNum > ped\ptrCurrentSourceData\TotalLines Then lineNum = ped\ptrCurrentSourceData\TotalLines - 1
      PED_GotoLine{lineNum}

    Case #IEQUALIFIER_CONTROL  ; $8008: jump to bottomline
      log_Print{"control"}
      Gosub menu_bottom

    Case #IEQUALIFIER_LALT     ; $8010: move current line down
      log_Print{"alt"}
      Gosub movelinedown

    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL  ; $8009: select block downwarts
      log_Print{"shift + control: selectblockdown"}
      Gosub selectblockdown

    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_LALT     ; $800A: select block downwarts
      log_Print{"shift + alt: selectblockdown"}
      Gosub selectblockdown

    ;Case $0000                         ; -- CURSOR DOWN FOR FREEWHEEL

    Default
      log_Print{"default"}
      Gosub movecursorlinedown
    End Select
Return


;Scroll Sourcetext at MouseWheelY events  tomsmart1
.wheel_down:
  Gosub storeline
  PED_GotoLine{ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine + pedconfig\wheelStep}
  PED_UpdateStatusArea{#STATUS_SCROLLERS}
Return


.wheel_up:
  Gosub storeline                                            ; added to save the changes of the corrent line
  PED_GotoLine{ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine - pedconfig\wheelStep}
  PED_UpdateStatusArea{#STATUS_SCROLLERS}                                  ; update position of the vertical scroller
Return

.handle_event_mousemove:
  If pedconfig\onlinehelp_extended
    help_ticks.b = 0 : WZ_HideHelp{}
  EndIf
Return

;OS4 MouseWheel events handling  tomsmart1
.handle_event_extendedmouse:
  mcode.w = pedMessage\_Code & $FFFF

  If (mcode = #IMSGCODE_INTUIWHEELDATA)
    log_Print{"extended mouse: wheelevent"}
    *wd.IntuiWheelData  = pedMessage\_IAddress
    ; vertical move
    If *wd\WheelY > 0
      pedconfig\wheelStep = (*wd\WheelY)                     ; get the stepdelta
      Gosub wheel_down                                       ; scroll the sourcetext
    End If
    If *wd\WheelY < 0
      pedconfig\wheelStep = (*wd\WheelY) * -1                ; get the stepdelta an make it to a postiv value
      Gosub wheel_up                                         ; scroll the sourcetext
    End If
  End If
Return

.menu_helpshortcuts
  Gosub open_shortcuts
Return

.menu_helplibrarybrowser
  Gosub open_librarybrowser
Return

.menu_helpcompletion
  wtemp\ibrowser_x = -2
  wtemp\ibrowser_y = -2
  wtemp\ibrowser_w = -2
  wtemp\ibrowser_h = -2
  Gosub open_instructionbrowser
Return

.menu_helpnews:
  Show_Helpfile{"Changelog","main",""}
Return

.menu_helpblitzlibs:
  Show_Helpfile{"BlitzLibs","main",""}
Return

.menu_helpgeneral:
  Show_Helpfile{"AmiBlitz3","main",""}
Return

.menu_helpprogramming:
  Show_Helpfile{"BlitzProgrammers","main",""}
Return

.menu_helpincludesguide:
  Show_Helpfile{"Main","main",""}
Return


.menu_helpbuildindex
  Gosub set_pointer_busy
  WZ_LockAllOpenWindows{}                                                                                                                                                                                                                                
  BuildHelpIndexWinTitle$ = "Rebuilding"                         ;added so the window title match the function  tomsmart1 ; remove !TRANS{} because it will translated with befor it will displayed  tomsmart1
  Gosub build_HelpIndexFile
  WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                              
  Gosub set_pointer_normal
Return

.write_newprefs
  If WriteFile (0,pedconfig\winprefsFile)
    WriteType 0,wpref(0)
    WriteType 0,wpref(1)
    WriteType 0,wpref(2)
    CloseFile 0
  EndIf
Return


.update_rememberlist:
  tmpfile$ = Peek.s(&ped\ptrCurrentSourceData\SourceName)
  tmppath$ = Peek.s(&ped\ptrCurrentSourceData\CurrentDir)
  log_Print{"updating remember menu for " + tmppath$ + "/" + tmpfile$}
  h = 0 : exit_rlupdate.b = False
  Repeat
    If dos_FilePart{rememberfiles$(h)} = tmpfile$
      rememberfiles$(h) = dos_AddPart{tmppath$,tmpfile$}
      exit_rlupdate = True
    EndIf
    h + 1
  Until exit_rlupdate OR h = 4

  ; if no empty entry left, roll last out and replace with current one
  If NOT exit_rlupdate
    For h = 3 To 0 Step -1
      rememberfiles$(h+1) = rememberfiles$(h)
    Next h
    rememberfiles$(0) = dos_AddPart{tmppath$,tmpfile$}
  EndIf
  Gosub update_remembermenu
  Gosub write_pedrememberfiles
Return


.write_pedrememberfiles:
  tedfile.l = file_Open{pedconfig\rememberFile,#file_forcewrite}
  If tedfile <> -1
    For h = 0 To 4
      file_WriteString{tedfile,rememberfiles$(h)}
    Next h
    file_Close{tedfile}
  EndIf
Return

.load_pedrememberfile:
  ;-- reset list
  For h = 0 To 4
    rememberfiles$(h) = "<unnamed>"
  Next h

  ;-- load the files
  If dos_Exist{pedconfig\rememberFile}
    tedfile.l = file_Open{pedconfig\rememberFile,#file_read}
    If tedfile >= 0

      If file_GetLength{tedfile} = 1280 ; old format since ab2
        log_Print{"reading old rememberfiles format and converting it."}                                                                                                                                                                                 
        tmpfile$ = SPACE$($40)
        tmppath$ = SPACE$($60)
        For h = 0 To 4
          file_Seek{tedfile,h * $100}
          file_ReadMem{tedfile,&tmpfile$,$40}
          file_ReadMem{tedfile,&tmppath$,$60}
          rememberfiles$(h) = dos_AddPart{Peek.s(&tmppath$), Peek.s(&tmpfile$)}
          ;log_Print{"["+rememberfiles$(h)+"]"}
        Next h
      Else
        For h = 0 To 4
          rememberfiles$(h) = file_ReadString{tedfile}
        Next h
      EndIf
      file_Close{tedfile}
    EndIf
  EndIf
  Gosub update_remembermenu
Return

.update_remembermenu:
  If sourceWindow\win Then Gosub init_menus
Return

.load_remembered:
  If pedconfig\remember_saved = False
    log_Print{"loading remembered source is deactivated."}
    Return
  EndIf

  _rememberitem.w = _menuitem - $78
  log_Print{"load remembered [" + Str$(_rememberitem) + "]"}
  log_Print{"selected remembered source: " + rememberfiles$(_rememberitem)}

  If rememberfiles$(_rememberitem) = "<unnamed>"
     Gosub menu_load
     Return
  EndIf

  log_Print{"loading remembered sourcefile"}
  
  ;loadsourcefilename.s = rememberfiles$(_rememberitem) : Gosub load_source
  !PED_LoadSource{rememberfiles$(_rememberitem),False,True,True}  
  Gosub analyze_loadedsource
  PED_UpdateStatusArea{#STATUS_REDRAW}
Return

.set_remembered_filename:
  tmpfile$ = Peek.s(&ped\ptrCurrentSourceData\SourceName)
  tmppath$ = Peek.s(&ped\ptrCurrentSourceData\CurrentDir)
  rememberfiles$(_rememberitem-1) = dos_AddPart{tmppath$,tmpfile$}
  log_Print{"set [" + rememberfiles$(_rememberitem) + "] to item [" +Str$(_rememberitem) + "]"}
Return

.kill_menus
  If Peek.l(Addr GTMenuList(0))<>0
    If sourceWindow\win <> 0 Then ClearMenuStrip_ sourceWindow\win
    If WZ_IsOpen{"WIN_NEWTYPE"}            Then Use Window WZID("WIN_NEWTYPE")            : ClearMenuStrip_ WZWindowAddr
    If WZ_IsOpen{"WIN_LABELS"}             Then Use Window WZID("WIN_LABELS")             : ClearMenuStrip_ WZWindowAddr
    If WZ_IsOpen{"WIN_INSTRUCTIONBROWSER"} Then Use Window WZID("WIN_INSTRUCTIONBROWSER") : ClearMenuStrip_ WZWindowAddr
    If WZ_IsOpen{"WIN_LIBRARYBROWSER"}     Then Use Window WZID("WIN_LIBRARYBROWSER")     : ClearMenuStrip_ WZWindowAddr
    If WZ_IsOpen{"WIN_SEARCH"}             Then Use Window WZID("WIN_SEARCH")             : ClearMenuStrip_ WZWindowAddr
    If WZ_IsOpen{"WIN_SHORTCUTS"}          Then Use Window WZID("WIN_SHORTCUTS")          : ClearMenuStrip_ WZWindowAddr
    Free GTMenuList 0 : ped\menuStrip = 0
  EndIf
Return


.init_menus
  Gosub kill_menus
  GTMenuTitle    0,0,   !TRANS{"Project"                     }
   GTMenuItem  0,0,0, 0,!TRANS{"Project Settings"            },"M"         ,0,#MENU_PROJECTSETTINGS
   GTMenuItem  0,0,0, 1,!TRANS{"IDE Preferences"             },""          ,0,#MENU_IDEPREFERENCES
   GTMenuItem  0,0,0, 2,!TRANS{"Autolayout   "               },""          ,0,#MENU_AUTOLAYOUT
   GTSubItem  0,0,0,2,0,!TRANS{"Set autolayout 1"            },""        ,0,#MENU_GETLAYOUT1
   GTSubItem  0,0,0,2,1,!TRANS{"Set autolayout 2"            },""        ,0,#MENU_GETLAYOUT2
   GTSubItem  0,0,0,2,2,!TRANS{"Set autolayout 3"            },""        ,0,#MENU_GETLAYOUT3
   GTMenuItem  0,0,0, 3,!TRANS{"Menu Edit..."                },""          ,0,#MENU_CUSTOMEDIT       ; entry moved to Project menu  tomsmart1
   GTMenuItem  0,0,0, 4
   GTMenuItem  0,0,0, 5,!TRANS{"Open WB"                     },""          ,0,#MENU_OPENWORKBENCH
   GTMenuItem  0,0,0, 6,!TRANS{"Close WB"                    },""          ,0,#MENU_CLOSEWORKBENCH
   GTMenuItem  0,0,0, 7,!TRANS{"Open Shell"                  },""          ,0,#MENU_OPENSHELL
   GTMenuItem  0,0,0, 8,!TRANS{"Calculator"                  },""          ,0,#MENU_CALCULATOR
   GTMenuItem  0,0,0, 9
   GTMenuItem  0,0,0,10,!TRANS{"About AmiBlitz3"             },""          ,0,#MENU_ABOUT
   GTMenuItem  0,0,0,11
   GTMenuItem  0,0,0,12,!TRANS{"Iconify"                     },""          ,0,#MENU_ICONIFY
   GTMenuItem  0,0,0,13,!TRANS{"Quit"                        },"Q"         ,0,#MENU_QUIT

  GTMenuTitle    0,1,   !TRANS{"Source File"                 }
   GTMenuItem  0,0,1, 0,!TRANS{"New..."                      },""          ,0,#MENU_NEW
   ; -- scan for any templates
   ClearList templates()
   templatepath.s = dos_AddPart{pedconfig\sourceDir , "Templates"}
   *root.ml_node  = ml_AddPathNode{0,templatepath.s,"#?.(bb2|ab2|ab3|asc)"}
   *node.ml_node  = *root
   templates.w    = 0
   While *node><0 AND templates < #MAX_MENUTEMPLATES
     fil.s = ml_GetUserString{*node}
     If dos_IsDir{fil} = False
        mtitle.s = Replace$(dos_RemExt{dos_FilePart{fil}},"_"," ")
        shortc.l = #MENU_TEMPLATE + templates
        GTSubItem  0,0,1, 0,templates,mtitle.s                    ,""          ,0,shortc
        If AddLast(templates()) Then templates()\filename = fil
        templates + 1
     End If
     *node = ml_GetNextNode{*node}
   Wend
   ml_RemoveAllNodes{*root}
   GTMenuItem  0,0,1, 1,!TRANS{"Open"                        },"O"         ,0,#MENU_OPEN
   GTMenuItem  0,0,1, 2,!TRANS{"Open New"                    },""          ,0,#MENU_OPENNEW
   GTMenuItem  0,0,1, 3,!TRANS{"Include File"                },"I"         ,0,#MENU_INCLUDEFILE
   GTMenuItem  0,0,1, 4
   GTMenuItem  0,0,1, 5,!TRANS{"Save"                        },"S"         ,0,#MENU_SAVE
   GTMenuItem  0,0,1, 6,!TRANS{"Save As..."                  },"A"         ,0,#MENU_SAVEAS
   GTMenuItem  0,0,1, 7
   GTMenuItem  0,0,1, 8,!TRANS{"Print..."                    },""          ,0,#MENU_PRINT
   GTMenuItem  0,0,1, 9
   GTMenuItem  0,0,1,10,!TRANS{"Close"                       },""          ,0,#MENU_CLOSE
   If pedconfig\remember_saved
     GTMenuItem  0,0,1,11
     For h = 0 To 4
       GTMenuItem  0,0,1,12+h,dos_FilePart{rememberfiles$(h)} ,Str$(h+1)    ,0,#MENU_LASTSOURCE1 + h
     Next h
   EndIf


  GTMenuTitle    0,2,   !TRANS{"Edit"                        }
   GTMenuItem  0,0,2, 0,!TRANS{"Cut"                         },"X"         ,0,#MENU_CUT
   GTMenuItem  0,0,2, 1,!TRANS{"Copy"                        },"C"         ,0,#MENU_COPY
   GTMenuItem  0,0,2, 2,!TRANS{"Paste"                       },"V"         ,0,#MENU_PASTE
   GTMenuItem  0,0,2, 3,!TRANS{"Duplicate"                   },"Z"         ,0,#MENU_DUPLICATE
   GTMenuItem  0,0,2, 4,!TRANS{"Forget"                      },"W"         ,0,#MENU_FORGET
   GTMenuItem  0,0,2, 5,!TRANS{"Kill"                        },"K"         ,0,#MENU_KILL
   GTMenuItem  0,0,2, 6,!TRANS{"Save Block As..."            },""          ,0,#MENU_SAVEBLOCKAS
   GTMenuItem  0,0,2, 7
   GTMenuItem  0,0,2, 8,!TRANS{"Insert Line"                 },""          ,0,#MENU_INSERTLINE
   GTMenuItem  0,0,2,09,!TRANS{"Delete Line"                 },"D"         ,0,#MENU_DELETELINE
   GTMenuItem  0,0,2,10,!TRANS{"Undelete Line"               },"U"         ,0,#MENU_UNDELETELINE
   GTMenuItem  0,0,2,11,!TRANS{"Join Lines"                  },"J"         ,0,#MENU_JOINLINES
   GTMenuItem  0,0,2,12,!TRANS{"Delete to EOL"               },"Y"         ,0,#MENU_DELETETOEOL
   GTMenuItem  0,0,2,13
   GTMenuItem  0,4,2,14,!TRANS{"Block Tab"                   },"CTRL+Right",0,#MENU_BLOCKTAB
   GTMenuItem  0,4,2,15,!TRANS{"Block Untab"                 },"CTRL+Left" ,0,#MENU_BLOCKUNTAB
   GTMenuItem  0,0,2,16,!TRANS{"Block Comment"               },"{"         ,0,#MENU_BLOCKCOMMENT
   GTMenuItem  0,0,2,17,!TRANS{"Block Uncomment"             },"}"         ,0,#MENU_BLOCKUNCOMMENT
   GTMenuItem  0,0,2,18,!TRANS{"Mark Indent"                 },""          ,0,#MENU_MARKINDENT
   GTMenuItem  0,0,2,19,!TRANS{"Insert Filename"             },""          ,0,#MENU_INSERTFILENAME
   GTMenuItem  0,0,2,20,!TRANS{"Open Filename Under Cursor"  },""          ,0,#MENU_OPENFILEUNDERCURSOR



  GTMenuTitle    0,3,   !TRANS{"Navigation"                  }
   GTMenuItem  0,0,3, 0,!TRANS{"Find..."                     },"F"         ,0,#MENU_OPENFIND
   GTMenuItem  0,0,3, 1,!TRANS{"Find Next"                   },"N"         ,0,#MENU_FIND
   GTMenuItem  0,0,3, 2,!TRANS{"Find Previous"               },"P"         ,0,#MENU_PREVIOUS
   GTMenuItem  0,0,3, 3,!TRANS{"Replace & Find"              },"R"         ,0,#MENU_REPLACE
   GTMenuItem  0,0,3, 4
   GTMenuItem  0,4,3, 5,!TRANS{"Top"                         },"CTRL+Up"   ,0,#MENU_TOP
   GTMenuItem  0,4,3, 6,!TRANS{"Bottom"                      },"CTRL+Down" ,0,#MENU_BOTTOM
   GTMenuItem  0,0,3, 7,!TRANS{"Goto Line..."                },"G"         ,0,#MENU_GOTOLINE
   GTMenuItem  0,0,3, 8
   GTMenuItem  0,4,3,09,!TRANS{"Previous Page"               },"F9"        ,0,#MENU_PREVPAGE
   GTMenuItem  0,4,3,10,!TRANS{"Next Page"                   },"F10"       ,0,#MENU_NEXTPAGE


  GTMenuTitle    0,4,   !TRANS{"Compiler"                    }
   GTMenuItem  0,0,4, 0,!TRANS{"Compile & Run"               },"#"         ,0,#MENU_COMPILERUN
   GTMenuItem  0,0,4, 1,!TRANS{"Save & Compile & Run"        },"B"         ,0,#MENU_SAVECOMPILERUN
   GTMenuItem  0,0,4, 2,!TRANS{"Run"                         },""          ,0,#MENU_RUN
   GTMenuItem  0,0,4, 3,!TRANS{"Create Executable..."        },"E"         ,0,#MENU_CREATEEXE
   GTMenuItem  0,0,4, 4,!TRANS{"Save & Create Executable"    },"T"         ,0,#MENU_SAVECREATEEXE
   GTMenuItem  0,0,4, 5,!TRANS{"Create minimized Executable" },""          ,0,#MENU_CREATERELEASEEXE
   GTMenuItem  0,0,4, 6,!TRANS{"Create Resident..."          },""          ,0,#MENU_CREATERESIDENT
   GTMenuItem  0,0,4, 7
   GTMenuItem  0,0,4, 8,!TRANS{"Set CLI Arguments"           },""          ,0,#MENU_SETCLIARGS
   GTMenuItem  0,0,4, 9,!TRANS{"Reload Userlibs"             },"\"         ,0,#MENU_RELOAD_USERLIBS
   GTMenuItem  0,0,4,10
   GTMenuItem  0,0,4,11,!TRANS{"Compiler Settings"           },""          ,0,#MENU_COMPILERSETTINGS
   GTMenuItem  0,1,4,12,!TRANS{"Create Debug Code"           },""          ,0,#MENU_CREATEDEBUGCODE


  GTMenuTitle    0,5,   !TRANS{"Help"                        }
   GTMenuItem  0,0,5, 0,!TRANS{"What's New?"                 },""          ,0,#MENU_WHATSNEW
   GTMenuItem  0,0,5, 1
   GTMenuItem  0,4,5, 2,!TRANS{"General AB3 Guide"           },"F1"        ,0,#MENU_GENERALGUIDE
   GTMenuItem  0,0,5, 3,!TRANS{"Programming in Blitz"        },""          ,0,#MENU_PROGRAMGUIDE
   GTMenuItem  0,4,5, 4,!TRANS{"Includes Guide"              },"F2"        ,0,#MENU_INCLUDEGUIDE
   GTMenuItem  0,4,5, 5,!TRANS{"Blitzlibs Guide"             },"F3"        ,0,#MENU_BLITZLIBSGUIDE
   GTMenuItem  0,0,5, 6,!TRANS{"Shortcuts Reference"         },""          ,0,#MENU_SHORTCUTREFERENCE
   GTMenuItem  0,0,5, 7
   GTMenuItem  0,0,5, 8,!TRANS{"Instruction Browser"         },""          ,0,#MENU_INSTRUCTIONBROWSER
   GTMenuItem  0,0,5, 9,!TRANS{"Source Browser"              },""          ,0,#MENU_SOURCEBROWSER
   GTMenuItem  0,0,5,10,!TRANS{"Definition Browser"          },""          ,0,#MENU_DEFINITIONBROWSER
   GTMenuItem  0,0,5,11,!TRANS{"Library Browser"             },""          ,0,#MENU_LIBRARYBROWSER
   GTMenuItem  0,0,5,12
   GTMenuItem  0,0,5,13,!TRANS{"Update Instruction Index"    },""          ,0,#MENU_UPDATEHELPINDEX

  Gosub load_custommenus
  If FirstItem(custommenu())                                                   ; changed code the CustomMenu only apear if there ar an entry  tomsmart1
    GTMenuTitle 0,6,    !TRANS{"Custom"                      }                 ; move MenuEdit entry to ProjectMenu  tomsmart1
      menuentry.b = 0                                                            ; change startentry  tomsmart1
      Repeat
        ;If custommenu()\itemname = "~"
        ;  GTMenuItem 0,0,6,menuentry
        ;Else
          shortc = #MENU_CUSTOMITEM1+menuentry                                 ; changed because CostomMenuEntry got its own ID  tomsmart1
          GTMenuItem 0,0,6,menuentry,custommenu()\itemname,"",0,shortc         ; changed because CostomMenuEntry got its own ID  tomsmart1
        ;EndIf
        menuentry + 1
      Until NOT NextItem(custommenu())
  EndIf

  CreateMenuStrip 0
  ped\menuStrip = Peek.l(Addr GTMenuList(0))
  If ped\menuStrip
    If sourceWindow\win <> 0                  Then                                             SetMenuStrip_ sourceWindow\win,ped\menuStrip
    If WZ_IsOpen{"WIN_SHORTCUTS"}          Then Use Window WZID("WIN_SHORTCUTS")          : SetMenuStrip_ WZWindowAddr,ped\menuStrip
    If WZ_IsOpen{"WIN_SEARCH"}             Then Use Window WZID("WIN_SEARCH")             : SetMenuStrip_ WZWindowAddr,ped\menuStrip
    If WZ_IsOpen{"WIN_NEWTYPE"}            Then Use Window WZID("WIN_NEWTYPE")            : SetMenuStrip_ WZWindowAddr,ped\menuStrip
    If WZ_IsOpen{"WIN_LABELS"}             Then Use Window WZID("WIN_LABELS")             : SetMenuStrip_ WZWindowAddr,ped\menuStrip
    If WZ_IsOpen{"WIN_INSTRUCTIONBROWSER"} Then Use Window WZID("WIN_INSTRUCTIONBROWSER") : SetMenuStrip_ WZWindowAddr,ped\menuStrip
    If WZ_IsOpen{"WIN_LIBRARYBROWSER"}     Then Use Window WZID("WIN_LIBRARYBROWSER")     : SetMenuStrip_ WZWindowAddr,ped\menuStrip
  EndIf
Return


.load_custommenus:
  If dos_Exist{pedconfig\menuFile}
    fid.l = file_Open{pedconfig\menuFile,#file_read}
    If fid >= 0
      ClearList custommenu()
      While file_EOF{fid} = False
        textline.s = file_ReadLine{fid}
        If textline <> "" AND AddLast(custommenu())
          InitArgParse textline
          custommenu()\itemname  = NextArgChar$(@",")
          custommenu()\shortcut  = NextArgChar$(@",")
          custommenu()\id        = Vallong(NextArgChar$(@","))
          custommenu()\path      = NextArgChar$(@",")
          custommenu()\runwbmode = Vallong(NextArgChar$(@","))
          custommenu()\stacksize = Vallong(NextArgChar$(@","))
          custommenu()\prio      = Vallong(NextArgChar$(@","))
        EndIf
      Wend
      file_Close{fid}
    End If
  EndIf
Return


Even
.menutable:
  ;    menu/ShortcutID   refresh   pointer to menuaction code

  ; -- MENU PROJECT
  Dc.l #MENU_OPENWORKBENCH,  0,    menu_openwb
  Dc.l #MENU_CLOSEWORKBENCH, 0,    menu_closewb
  Dc.l #MENU_ICONIFY,        0,    menu_iconify
  Dc.l #MENU_OPENSHELL,      0,    menu_newshell
  Dc.l #MENU_IDEPREFERENCES, 0,    menu_settings
  Dc.l #MENU_PROJECTSETTINGS,0,    menu_project  
  Dc.l #MENU_AUTOLAYOUT,     0,    menu_autolayout
  Dc.l #MENU_GETLAYOUT1,     0,    menu_autolayout
  Dc.l #MENU_GETLAYOUT2,     0,    menu_autolayout
  Dc.l #MENU_GETLAYOUT3,     0,    menu_autolayout
  Dc.l #MENU_ABOUT,          0,    menu_about
  Dc.l #MENU_QUIT,           0,    menu_quitall

  ; -- MENU SOURCE
  Dc.l #MENU_NEW,            0,    menu_new                       
  Dc.l #MENU_OPENNEW,        0,    menu_loadAsNew
  Dc.l #MENU_OPEN,           1,    menu_load
  Dc.l #MENU_INCLUDEFILE,    1,    menu_includeblock
  Dc.l #MENU_SAVE,           0,    menu_save
  Dc.l #MENU_SAVEAS,         0,    menu_saveas
  Dc.l #MENU_EXPORTASCII,    0,    menu_saveascii
  Dc.l #MENU_PRINT,          0,    menu_print
  Dc.l #MENU_CLOSE,          0,    menu_quit  
  Dc.l #MENU_LASTSOURCE1,    1,    load_remembered
  Dc.l #MENU_LASTSOURCE2,    1,    load_remembered
  Dc.l #MENU_LASTSOURCE3,    1,    load_remembered
  Dc.l #MENU_LASTSOURCE4,    1,    load_remembered
  Dc.l #MENU_LASTSOURCE5,    1,    load_remembered

  ; -- MENU EDIT
  Dc.l #MENU_CUT,            1,    menu_cut
  Dc.l #MENU_COPY,1, menu_copy
  Dc.l #MENU_PASTE,1, menu_paste
  Dc.l #MENU_DUPLICATE,1,menu_dublicate
  Dc.l #MENU_FORGET,1,menu_forget
  Dc.l #MENU_KILL,1, menu_kill
  Dc.l #MENU_SAVEBLOCKAS,1,menu_saveblockas
  Dc.l #MENU_INSERTLINE,0,menu_insertline
  Dc.l #MENU_DELETELINE,0,menu_deleteline
  Dc.l #MENU_UNDELETELINE,0,menu_undeleteline           
  Dc.l #MENU_JOINLINES,0,menu_joinline                
  Dc.l #MENU_BLOCKTAB,1,menu_blocktab
  Dc.l #MENU_BLOCKUNTAB,1,menu_blockuntab           
  Dc.l #MENU_BLOCKCOMMENT,1,menu_blockcomment           
  Dc.l #MENU_BLOCKUNCOMMENT,1,menu_blockuncomment
  Dc.l #MENU_MARKINDENT,1,menu_markindent

  ;-- MENU NAVIGATION
  Dc.l #MENU_OPENFIND,1, menu_find  
  Dc.l #MENU_FIND,1,menu_findnext
  Dc.l #MENU_PREVIOUS,1,menu_findprevious
  Dc.l #MENU_REPLACE,1,menu_replace
  Dc.l #MENU_TOP,1,  menu_top
  Dc.l #MENU_BOTTOM,1,   menu_bottom
  Dc.l #MENU_GOTOLINE,1,menu_gotoline
  Dc.l #MENU_PREVPAGE,0,menu_previousfile
  Dc.l #MENU_NEXTPAGE,0,menu_nextfile

  ; -- MENU COMPILER

  ; -- MENU HELP
  Dc.l #MENU_WHATSNEW,0,menu_helpnews
  Dc.l #MENU_GENERALGUIDE,0, menu_helpgeneral
  Dc.l #MENU_PROGRAMGUIDE,0,menu_helpprogramming
  Dc.l #MENU_BLITZLIBSGUIDE,0,menu_helpblitzlibs
  Dc.l #MENU_INCLUDEGUIDE,0,menu_helpincludesguide
  Dc.l #MENU_INSTRUCTIONBROWSER,0, menu_helpcompletion
  Dc.l #MENU_SHORTCUTREFERENCE,0, menu_helpshortcuts
  Dc.l #MENU_LIBRARYBROWSER,0,  menu_helplibrarybrowser
  Dc.l #MENU_UPDATEHELPINDEX,0,menu_helpbuildindex
  ; end of menutable
  Dc.l $FFFFFFFF
Even


.menu_project:
  Gosub set_pointer_busy

  Gosub storeCurrentSourceData

  WZ_LockAllOpenWindows{}
  If NOT WZ_IsOpen{"WIN_PROJECT"}
    WZWindow WZID("WIN_PROJECT"),?wzgui,192,-2,-2,-2,-2,WZID("WIN_PROJECT")
    Use Window WZID("WIN_PROJECT")
    WZ_InitTable{"WIN_PROJECT","PROJECTTABLE",2}
    WZ_SetTableTitle{"PROJECTTABLE","File","Category"}
    WZ_SetTableColors{"PROJECTTABLE",1,0,1,0}
    WZ_SetPriority{"PROJECTTABLE",3,1}
    WZ_SetSortable{"PROJECTTABLE",Off}
    project_tab.b = WZInput("PROJECT_TABS")
    Gosub update_versiongadgets
  EndIf

  MaxLen lf$=64
  MaxLen pa$=64

  actual_file$ = Peek.s(&ped\ptrCurrentSourceData\SourceName)
  actual_drawer$ = Peek.s(&ped\ptrCurrentSourceData\CurrentDir)

  If project_tab = 1
    WZ_DrawTable{"PROJECTTABLE"}
    Gosub project_updatesourcelist
  EndIf

  exit_project.b = False
  Repeat
    ev.l = WaitEvent
    Select ev
    Case #IDCMP_IDCMPUPDATE
      Select WZGadName
      Case "PROJECT_TABS"
        project_tab.b = WZInput("PROJECT_TABS")
        If project_tab = 1
          WZ_DrawTable{"PROJECTTABLE"}
          Gosub project_updatesourcelist
        EndIf

      Case "PROJECT_NAME"
        ab2_project\name = WZInputstr

      Case "PROJECT_DRAWER"
        ab2_project\drawer = WZInputstr

      Case "PROJECT_VERSION"
        ab2_project\version = WZInput

      Case "PROJECT_REVISION"
        ab2_project\revision = WZInput


      Case "PROJECT_CREATE"
        If ab2_project\name<>""
          If ask{!TRANS{"The current project and its files will be closed,\\nand all source files will be saved."},!TRANS{"Ok|Cancel"},!TRANS{"Create Project"}}
            WZ_ClearTable{"PROJECTTABLE"}
            WZ_UpdateTable{"PROJECTTABLE"}
            Gosub project_closeallfiles
            ClearType ab2_project
            Gosub project_updatesourcelist
            WZ_ActivateGadget{"PROJECT_NAME"}      ; replaced to use the statement  tomsmart1 2012 03 09                                                                                                                                                 
          EndIf
        Else
          dummy.l = ask{!TRANS{"Illegal Projectname"},!TRANS{"Ok"},!TRANS{"Create Project"}}
        EndIf

      Case "PROJECT_LOAD"
        aslfr_SetRequesterTitle {1,!TRANS{"Choose Project"},!TRANS{"Ok"},!TRANS{"Cancel"}}
        aslfr_SetPath  {1,"",lf$,"#?.a2p",False}
        If aslfr_Request {1,False,False,False,sourceWindow\pedScreen,True}
          lf$=aslfr_GetNextFile{}
        ;If Exists(lf$)>0
          Gosub project_load
          If ab2_project\sourcecounter > 0
            For pc.l = 1 To ab2_project\sourcecounter
              fext$ = dos_GetExt{ab2_project\sourcefile[pc]}
              If fext$="ab2" OR fext$="bb2" OR fext$="bb"
                sourcefile$ = ab2_project\sourcepath[pc]+ab2_project\sourcefile[pc]
                !PED_LoadSource{sourcefile$,False,True,True}  
              EndIf
            Next pc
            Gosub activatesourcewindow
            Gosub project_updatesourcelist
            Use Window WZID("WIN_PROJECT")
            WindowToFront_ WZWindowAddr
          EndIf
        Else
          If lf$ <> "" Then dummy.l = ask{!TRANS{"This project does not exist."},!TRANS{"Ok"},!TRANS{"Info"}}
        EndIf

      Case "PROJECT_SAVE"
        ab2_project\name = WZGetString("PROJECT_NAME")
        ab2_project\drawer = WZGetString("PROJECT_DRAWER")
        If ab2_project\name <> ""
          Gosub project_save
        Else
          dummy.l = ask{!TRANS{"Illegal Projectname"},!TRANS{"Ok"},!TRANS{"Error"}}
        EndIf

      Case "PROJECT_ADDFILE"
        aslfr_SetRequesterTitle {1,!TRANS{"Add File"},!TRANS{"Ok"},!TRANS{"Cancel"}}
        aslfr_SetPath  {1,ab2_project\drawer,lf$,"",False}
        If aslfr_Request {1,False,False,False,sourceWindow\pedScreen,False}
          actual_file$=aslfr_GetNextFile{}
        ;If Exists(actual_file$) > 0
          ab2_project\sourcecounter + 1
          ab2_project\sourcefile[ab2_project\sourcecounter] = dos_FilePart{actual_file$}

          Gosub project_loadfile
          actual_file$ = dos_FilePart{actual_file$}
          Gosub project_updatesourcelist
          Use Window WZID("WIN_PROJECT")
          WindowToFront_ WZWindowAddr
        Else
          If lf$ <> "" Then dummy.l = ask{!TRANS{"This file does not exist"},!TRANS{"Ok"},!TRANS{"Error"}}
        EndIf

      Case "PROJECT_REMOVEFILE"
        actual_file$ = WZ_GetCell{"PROJECTTABLE",WZ_Row{"PROJECTTABLE"},1}
        For pc = 1 To ab2_project\sourcecounter
          If actual_file$ = ab2_project\sourcefile[pc]
            Gosub project_removefile
            ab2_project\sourcefile[pc] = ""
            ab2_project\sourcepath[pc] = ""
            Gosub project_sortsourcelist
            Gosub project_updatesourcelist
          EndIf
        Next pc
;        Gosub activatesourcewindow                              ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1
;        Gosub menu_quit


; -- TAB Versionmanagement --

      Case "INTEGER_VER_MAJOR"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_MINOR"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_PATCH"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_BUILD"
        Gosub get_versiondata_from_gui

      ; -- TAB Changelog --

      Case "CHANGELOG_ADDENTRY"
        If Peek.l(?comPtr_VersionInformation) AND Peek.l(?comPtr_NumberOfBuilds)
          If (Peek.l(?comPtr_VersionInformation)<>0) AND (Peek.l(?comPtr_NumberOfBuilds )<>0)
            version_code.l = Peek.l(Peek.l(?comPtr_VersionInformation))
            anz_builds.l   = Peek.l(Peek.l(?comPtr_NumberOfBuilds))
            vercode$ = Str$(version_code LSR 24 )+"."
            vercode$ + Str$((version_code LSL 8) LSR 24 )+"."
            vercode$ + Str$((version_code LSL 16)LSR 24 )+" (build: "
            vercode$ + Str$(anz_builds)+")"
            project_changelog$ =  "V"+vercode$ + ":\\0a\\0a" + project_changelog$
            WZPrint "CHANGELOG_TEXTFIELD",&project_changelog$
          EndIf
        EndIf

      Case "CHANGELOG_TEXTFIELD"
        project_changelog$ = WZ_GetStringField{"CHANGELOG_TEXTFIELD"}

      End Select

   Case #IDCMP_VANILLAKEY
     Select EventCode
       Case #VANILLAKEY_ESC : exit_project = True
     End Select


    Case #IDCMP_CLOSEWINDOW
      exit_project = True
    End Select

    If project_tab = 1
      wev.l = WZ_CheckTableEvent{ev}
      If wev = #WZTABLEEVENT_DOUBLECLICK
        _sf$ = WZ_GetCell{"PROJECTTABLE",WZ_Row{"PROJECTTABLE"},1}
        If (_sf$<>actual_file$) AND (_sf$<>"<unnamed>")
          actual_file$ = _sf$
          Gosub project_loadfile
;        For pc = 1 To ab2_project\sourcecounter
;          t$ = ab2_project\sourcefile[pc]
;          If t$ = actual_source$ Then WZ_SetActiveRow{"PROJECTTABLE",pc}
;        Next pc
;        WZ_UpdateTable{"PROJECTTABLE"}
          Use Window WZID("WIN_PROJECT")
          WindowToFront_ WZWindowAddr
;        exit_project = True
        EndIf
      EndIf
    EndIf
  Until exit_project = True

  WZ_KillTable{"PROJECTTABLE"}
  WZCloseWindow WZID("WIN_PROJECT")
  FlushEvents
  Gosub activatesourcewindow
  WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                              
  Gosub set_pointer_normal
Return

.project_sortsourcelist
  tempcounter.w = 0
  For i = 1 To #MAX_SOURCEFILES
    If ab2_project\sourcefile[i]<> ""
      tempcounter + 1
      tempproject$(tempcounter,0) = ab2_project\sourcefile[i]
      tempproject$(tempcounter,1) = ab2_project\sourcepath[i]
    EndIf
    ab2_project\sourcefile[i] = ""
    ab2_project\sourcepath[i] = ""
  Next i

  For i = 1 To tempcounter
    ab2_project\sourcefile[i] = tempproject$(i,0)
    ab2_project\sourcepath[i] = tempproject$(i,1)
  Next i
  ab2_project\sourcecounter = tempcounter
Return

.project_updatesourcelist:
  If project_tab = 1
    WZ_ClearTable{"PROJECTTABLE"}
    If ab2_project\sourcecounter > 0
      For pc = 1 To ab2_project\sourcecounter
        t$ = LCase$(ab2_project\sourcefile[pc])
        If Instr(t$,".include") Then u$ = "Include" Else
        If Instr(t$,".bb2")     Then u$ = "AB2-Source" Else
        If Instr(t$,".ab2")     Then u$ = "AB2-Source" Else
        If Instr(t$,".ab3")     Then u$ = "AB3-Source" Else
        If Instr(t$,".bb")      Then u$ = "BB2-Source" Else
        If Instr(t$,".wizard")  Then u$ = "Wizard-GUI-File" Else u$ = dos_GetExt{t$}+" File"
        WZ_AddRow{"PROJECTTABLE",t$,u$}
        If t$ = LCase$(actual_file$) Then WZ_SetActiveRow{"PROJECTTABLE",pc}
      Next pc
    EndIf
    WZ_UpdateTable{"PROJECTTABLE"}

    ab2p$ = ab2_project\name
    ab2d$ = ab2_project\drawer
    WZPrint "PROJECT_NAME",&ab2p$
    WZPrint "PROJECT_DRAWER",&ab2d$
;    WZPrint "PROJECT_VERSION",ab2_project\version
;    WZPrint "PROJECT_REVISION",ab2_project\revision
  EndIf
Return

.project_closeallfiles:
  Gosub activatesourcewindow

  While ped\firstSourceEntry
    Gosub free_actualsource
    Gosub close_actualsource
  Wend

  Gosub activatesourcewindow
Return

.project_removefile:
  t$ = actual_file$
  If Instr(t$,".bb2")     OR Instr(t$,".ab2") OR Instr(t$,".ab3")     OR Instr(t$,".bb")
    Gosub project_loadfile
    Gosub menu_quit
    actual_file$ = Peek.s(ped\ptrCurrentSourceData + $DE)
  EndIf
Return

.project_loadfile:
  t$ = LCase$(actual_file$)
  If Instr(t$,".bb2")     OR Instr(t$,".ab2")  OR Instr(t$,".ab3")    OR Instr(t$,".bb")
    !PED_LoadSource{actual_file$,False,True,True}  
  EndIf
Return

.project_load
  If OpenFile(1,lf$)
    ClearType ab2_project
    ReadType 1,ab2_project
    CloseFile 1
  Else
    dummy.l = ask{!TRANS{"This project could not be loaded"},!TRANS{"Ok"},"Error"}
  EndIf
Return

.project_save
  lf$ = ab2_project\name+".a2p"
  aslfr_SetRequesterTitle {1,!TRANS{"Save Projectfile"},!TRANS{"Ok"},!TRANS{"Cancel"}}
  aslfr_SetPath  {1,ab2_project\drawer,lf$,"(#?.a2p)",False}
  If aslfr_Request {1,True,False,False,sourceWindow\pedScreen,True}
    lf$=aslfr_GetNextFile{}
    If OpenFile(1,lf$)
      WriteType 1,ab2_project
      CloseFile 1
    Else
      dummy.l = ask{!TRANS{"The project could not be saved."},!TRANS{"Ok"},!TRANS{"Error"}}
    EndIf
  EndIf
Return

.get_versiondata_from_gui:
  If WZ_IsOpen{"WIN_PROJECT"}
    If Peek.l(?comPtr_VersionInformation)
      version_code = WZInput("INTEGER_VER_MAJOR") LSL 24
      version_code + (WZInput("INTEGER_VER_MINOR") LSL 16)
      version_code + (WZInput("INTEGER_VER_PATCH") LSL 8)
      Poke.l Peek.l(?comPtr_VersionInformation),version_code

      Poke.l Peek.l(?comPtr_NumberOfBuilds), WZInput("INTEGER_VER_BUILD")
    EndIf
  EndIf
Return

.update_versiongadgets
  If Peek.l(?comPtr_VersionInformation) AND Peek.l(?comPtr_NumberOfBuilds)
    If (Peek.l(?comPtr_VersionInformation)<>0) AND (Peek.l(?comPtr_NumberOfBuilds)<>0)
      version_code.l = Peek.l(Peek.l(?comPtr_VersionInformation))
      anz_builds.l   = Peek.l(Peek.l(?comPtr_NumberOfBuilds))
      If WZ_IsOpen{"WIN_PROJECT"}
        Use Window WZID("WIN_PROJECT")
        WZPrint "INTEGER_VER_MAJOR",version_code LSR 24
        WZPrint "INTEGER_VER_MINOR",(version_code LSL 8) LSR 24
        WZPrint "INTEGER_VER_PATCH",(version_code LSL 16)LSR 24
        WZPrint "INTEGER_VER_BUILD",anz_builds
        WZPrint "CHANGELOG_TEXTFIELD",&project_changelog$
      EndIf
    EndIf
  EndIf
Return


.menu_print:
  Gosub set_pointer_busy

  WZ_LockAllOpenWindows{}                                                                                                                                                                                                                                
  If Peek.l(Addr Window(WZID("WIN_PRINT")))=0
    WZWindow WZID("WIN_PRINT"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_PRINT")
  EndIf
  Use Window WZID("WIN_PRINT")
  
  exit_print.b = False
  Repeat
    ev.l = WaitEvent
    log_Print{"event " + Hex$(ev)}
    Select ev

    Case #IDCMP_CLOSEWINDOW
      exit_print = True

    Case #IDCMP_IDCMPUPDATE
      log_Print{"Button: " + WZGadName}
      Select WZGadName
        Case "PRINT_CANCEL"
          exit_print = True
        Case "PRINT_PRINT"
          printerDevice.s = WZGetString("PRINT_DEVICE")
          Gosub printout_source
          exit_print = True
      End Select

    End Select
  Until exit_print = True

  WZCloseWindow WZID("WIN_PRINT")
  WZ_UnlockAllOpenWindows{}
  Gosub set_pointer_normal
  Gosub activatesourcewindow
Return

.printout_source:
  *prthandle.l = Open_ (&printerDevice,#HUNK_RELOC_8__MODE_NEWFILE)
  If *prthandle
    *currentline.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
    ped\inString = 0
    While *currentline
      newstr.s = ""
      ptrString.l = *currentline + 9
      Repeat
        curchar.b = Peek.b(ptrString)
        If curchar
          If curchar = $22 Then ped\inString = NOT ped\inString
          ;-- here comes a token
          If (curchar < 0) AND (ped\inString = 0)
            toknum.w = Peek.w(ptrString)
            newstr + "\\1B[1m"
            newstr + PED_GetTokenName{toknum}
            newstr + "\\1B[22m"
            ptrString + 2
          Else
            newstr + Chr$(curchar)
            ptrString + 1
          EndIf
        EndIf
      Until curchar = 0                                                                                                                                                                                                                                  
      newstr = Trim$(newstr) + "\\0A"
      
      ;log_Print{">>" + Hex$(Cvl(newstr)) + " : " + newstr}
      Write_ *prthandle, &newstr, FLen(newstr)

      *currentline = *currentline\nextLine
    Wend
    Close_ *prthandle
  Else
    error{"Couldnot open printer [" + printerDevice + "]"}
  EndIf
Return


.call_pluginmenuentry:
  If _menuitem = #MENU_CUSTOMEDIT
    Gosub open_menueditor
    Gosub init_menus
  Else
    _menuitem - #MENU_CUSTOMITEM1                        ; to get the correct CostumMenu entry  tomsmart 1
    If _menuitem >= 0
      ResetList custommenu()
      menuentry = 0
      While _menuitem >= menuentry                       ; changed to get the correct entry  tomsmart1
        dummy = NextItem(custommenu())
        menuentry + 1
      Wend
      If custommenu()\path <> ""
        If custommenu()\runwbmode = False
          dos_RunCli{custommenu()\path,custommenu()\prio,custommenu()\stacksize,False}
        Else
          dos_RunWB{custommenu()\path}
        EndIf
      EndIf
    EndIf
  EndIf
Return


.update_menueditorgadgets                                  ; moved to subroutine to remove double code tomsmart1
    WZPrint "MENUED_ITEMNAME",custommenu()\itemname
    WZPrint "MENUED_STACK"   ,custommenu()\stacksize
    WZPrint "MENUED_PRIO"    ,custommenu()\prio
    If custommenu()\runwbmode = 1
      WZPrint "MENUED_RUNMODE",On
      WZDisable "MENUED_STACK" : WZDisable "MENUED_PRIO"
    Else
      WZPrint "MENUED_RUNMODE",Off
      WZEnable "MENUED_STACK" : WZEnable "MENUED_PRIO"
    EndIf
    WZEnable "MENUED_DEL" : WZEnable "MENUED_SORT"
    WZEnable "MENUED_RUNMODE"
    WZEnable "MENUED_PATH"
Return

.disable_menueditorgadgets                                 ; moved to subroutine to remove double code tomsmart1
    WZPrint "MENUED_ITEMNAME",""
    WZPrint "MENUED_STACK"   ,8192
    WZPrint "MENUED_PRIO"    ,-1
    WZPrint "MENUED_RUNMODE" ,Off
    WZDisable "MENUED_DEL"   : WZDisable "MENUED_SORT"
    WZDisable "MENUED_STACK" : WZDisable "MENUED_PRIO"
    WZDisable "MENUED_RUNMODE"
    WZDisable "MENUED_PATH"
Return

.open_menueditor
  Gosub set_pointer_busy
  WZ_LockAllOpenWindows{}                                                                                                                                                                                                                                
  If NOT WZ_IsOpen{"WIN_MENUED"}
    WZWindow WZID("WIN_MENUED"),?wzgui,255,-2,-2,-2,-2,WZID("WIN_MENUED")
  End If
  DEFTYPE.List menuedlist
  ; -- get all the defined menuentries
  If FirstItem(custommenu())                               ; test if we have a (first) entry in the list
    item_counter.b = 0
    Repeat
      WZListAdd menuedlist,custommenu()\itemname,-2
      item_counter+1
    Until NOT NextItem(custommenu())
    WZPrint "MENUED_LIST",0,menuedlist                     ; merged two IF-Thens to one and that fixed Hits if ther are no entrys in the list  tomsmart1
    item_counter = 0
    dummy = FirstItem(custommenu())                        ; back to entry 1 to set the status gadgets
    Gosub update_menueditorgadgets
  Else
    Gosub disable_menueditorgadgets
  EndIf
  menued_exit.b = False

  Repeat
    menued_ev.l = WaitEvent

    Select menued_ev
      Case #IDCMP_CLOSEWINDOW
        menued_exit = True

      Case #IDCMP_VANILLAKEY:
        If EventCode = #VANILLAKEY_ESC Then menued_exit = True

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName
          Case "MENUED_ADD"
            ResetList custommenu()
            If AddLast (custommenu())
                WZListAdd menuedlist,"",-2
                custommenu()\itemname = ""
                custommenu()\path     = ""
                custommenu()\runwbmode = False
                custommenu()\stacksize = 8192
                custommenu()\prio = -1
            EndIf
            item_counter = WZListItems (menuedlist)-1
            WZPrint "MENUED_LIST",item_counter,menuedlist,0 ; neue Position in der Liste anspringen und Liste erneuern ; changed that the selection get not lost  tomsmart1
            dummy.l = LastItem(custommenu())
            Gosub update_menueditorgadgets
            WZDisable "MENUED_SAVE"                         ; added to only allow 1 new entry to prevent empty entrys  tomsmart1
            WZDisable "MENUED_ADD"
            WZDisable "MENUED_SORT"
            WZDisable "MENUED_LIST"

          Case "MENUED_DEL"
            ResetList custommenu()
            item_counter = 0
            While (item_counter < WZListNum ("MENUED_LIST")) AND NextItem(custommenu())
              item_counter + 1
            Wend
            If item_counter = WZListNum ("MENUED_LIST")
              KillItem custommenu()
              WZListRemove menuedlist,WZListNum ("MENUED_LIST")
              WZPrint "MENUED_LIST",0,menuedlist,0
            EndIf
            If FirstItem(custommenu())
              Gosub update_menueditorgadgets
            Else
              Gosub disable_menueditorgadgets
            EndIf
            WZEnable "MENUED_SAVE"
            WZEnable "MENUED_ADD"                          ; added to only allow 1 new entry to prevent empty entrys  tomsmart1
            WZEnable "MENUED_LIST"

          Case "MENUED_SORT"
            If FirstItem(custommenu())                     ; merged If-Thens to one  tomsmart1

              StringSort custommenu(),SizeOf.custommenu    ; command changed to fix sorting  tomsmart1

              WZListRemove menuedlist
              dummy = FirstItem(custommenu())
              Repeat
                WZListAdd menuedlist,custommenu()\itemname,-2
              Until NOT NextItem (custommenu())

              WZPrint "MENUED_LIST",0,menuedlist,0
              dummy = FirstItem(custommenu())              ; back to entry 1 to set the status gadgets
              Gosub update_menueditorgadgets
              WZEnable "MENUED_SAVE"
            Else
              Gosub disable_menueditorgadgets
            EndIf


          Case "MENUED_LIST"
            item_counter = 0
            ResetList custommenu()
            While (item_counter < WZListNum ("MENUED_LIST")) AND NextItem(custommenu())
              item_counter + 1
            Wend
            If item_counter = WZListNum ("MENUED_LIST")
              Gosub update_menueditorgadgets
            Else
              Gosub disable_menueditorgadgets
            EndIf

          Case "MENUED_PATH"
            aslfr_SetRequesterTitle {0,!TRANS{"Select a Programm"},"Ok","Cancel"}
            ; replaced to set always a vaild path  tomsmart1
            If custommenu()\path <> ""
              aslfr_SetPath {0,dos_PathPart{custommenu()\path},dos_FilePart{custommenu()\path} }
            Else
              aslfr_SetPath {0,pedconfig\mainDir,""}
            EndIf
            If aslfr_Request {0,False,False,False,sourceWindow\pedScreen}
              custommenu()\path = aslfr_GetNextFile{}
              If custommenu()\path <>""
                custommenu()\itemname = dos_FilePart{custommenu()\path}
                WZPrint "MENUED_ITEMNAME",custommenu()\itemname

                WZListRemove menuedlist
                ResetList custommenu()
                While NextItem (custommenu())
                  WZListAdd menuedlist,custommenu()\itemname,-2
                Wend

                WZPrint "MENUED_LIST",item_counter,menuedlist,0  ; changed that the selection get not lost  tomsmart1
                WZEnable "MENUED_SAVE"
                WZEnable "MENUED_ADD"                            ; added to only allow 1 new entry to prevent empty entrys  tomsmart1
                WZEnable "MENUED_SORT"
                WZEnable "MENUED_LIST"
              EndIf
            EndIf

          Case "MENUED_STACK"
            stacksize.l = WZInput
            custommenu()\stacksize = stacksize
            If custommenu()\itemname<>"" Then WZEnable "MENUED_SAVE"  ; changed to prevent empty entrys  tomsmart1

          Case "MENUED_PRIO"
            prio.l = WZInput
            custommenu()\prio = prio
            If custommenu()\itemname<>"" Then WZEnable "MENUED_SAVE"  ; changed to prevent empty entrys  tomsmart1

          Case "MENUED_RUNMODE"
            checked.l = WZInput
            If checked = 1
              custommenu()\runwbmode = 1
              WZDisable "MENUED_STACK" : WZDisable "MENUED_PRIO"
            Else
              custommenu()\runwbmode = False
              WZEnable "MENUED_STACK" : WZEnable "MENUED_PRIO"
            EndIf
            If custommenu()\itemname<>"" Then WZEnable "MENUED_SAVE"  ; changed to prevent empty entrys  tomsmart1

          Case "MENUED_SAVE"
            ; removed code to fix Hits if entrys are deleted  tomsmart1
            fid.l = file_Open{pedconfig\menuFile,#file_forcewrite}
            If fid >= 0
              If FirstItem(custommenu())
                Repeat
                  file_WriteLine{fid,custommenu()\itemname+",~,0,"+custommenu()\path+","+Str$(custommenu()\runwbmode)+","+Str$(custommenu()\stacksize)+","+Str$(custommenu()\prio)}
                Until NOT NextItem(custommenu())
              EndIf
            EndIf
            file_Close{fid}
            WZDisable "MENUED_SAVE"

          Case "MENUED_EXIT" : menued_exit = True
        End Select
    End Select
  Until menued_exit = True

  FlushEvents
  WZListRemove menuedlist
  WZCloseWindow WZID("WIN_MENUED")
  WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                              
  Gosub set_pointer_normal
Return

.jump_historyup:
  Gosub storeline
  ped\historyPointer - 1
  If ped\historyPointer < 0 Then ped\historyPointer = #maxhistory
  PED_GotoLine{ped\historyTable[ped\historyPointer], #LINE_START}
Return

.jump_historydown:
  Gosub storeline
  ped\historyPointer + 1
  If ped\historyPointer > #maxhistory Then ped\historyPointer = 0
  PED_GotoLine{ped\historyTable[ped\historyPointer], #LINE_START}
Return

.jump_onclick:
  strline$ = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
  If Instr(strline$,"{") > 0 Then statement_in_line.b = True

  actualword$ = PED_GetWordAtPos{strline$, ped\ptrCurrentSourceData\Column,True}
  actualword_len.w = Len(actualword$)
  If actualword_len < 2
    Pop If : Return
  EndIf

  clickjump_fromfile.b = 0
  jump_search:
  log_Print{"search for <" + actualword$ + ">"}

  linecounter.l = 0 : found_definition.b = False : found_to_jump.b = False
  *tempLine = ped\ptrCurrentSourceData\FirstSourceLine
  Repeat
    ;log_Print{Hex$(ped\ptrCurrentSourceData\CurrentSourceLine) + " " + Hex$(*tempLine) + "  " + Str$(linecounter + 1)}

    If *tempLine = ped\ptrCurrentSourceData\CurrentSourceLine
      ;log_Print{"skipping actual line <" + Str$(linecounter+1)+">"}
    Else
      char_before$ = ""
      found_definition = False

      ; check if it is the definition of a Statement/Function/Macro, we skip it!
      strline$ = Trim$(Peek.s(*tempLine + 9))
      tokenID.l = Peek.w(&strline$) AND $FFFF
      Select tokenID
      Case #TOKEN_Statement : found_definition = True
      Case #TOKEN_Function : found_definition = True
      Case #TOKEN_Macro : found_definition = True
      End Select
      If found_definition Then strline$ = UnRight$(strline$,2)

      ; search for clicked word
      found_at.w = Instr(strline$, actualword$)
      If found_at > 0
        log_Print{"found_at: " + Str$(found_at) + " in line " + Str$(linecounter+1) + ":  " + strline$}
        If statement_in_line AND NOT found_definition Then Goto skip_jump
        If found_at > 1 Then char_before$ = Mid$(strline$,found_at-1,1)
        char_after$ = Mid$(strline$,found_at + actualword_len,1)
        log_Print{"before <" + char_before$ + "> after <" + char_after$ + ">" + Str$(linecounter+1) + "  "  +strline$}
        If CheckChr{char_after$, ":;{"} OR (char_before$=".")
          log_Print{"<"+actualword$ + "> found in line <" + Str$(linecounter + 1) + ">, jump!"}
          found_to_jump = True
        EndIf
        skip_jump:
      EndIf
    EndIf
    linecounter + 1
    *tempLine = *tempLine\nextLine
  Until found_to_jump OR (*tempLine = 0)
  If found_to_jump
    Pop If
    PED_HistoryAddEntry{}
    PED_GotoLine{linecounter-1,#LINE_START}
    Return
  EndIf 

  ;-- nothing found in current source search in helpcache
  If clickjump_fromfile = 0
    clickjump_fromfile = 1
    Gosub set_pointer_busy

    ;-- searching in HelpIndexFile for macro or function name
    found_in_cache.b = False
    If actualword$ <> ""
      log_Print{"definition not found in current source, searching in helpcache for <" + actualword$ + ">"}
      ResetList HelpIndexCache()
      While NextItemFast(HelpIndexCache()) AND found_in_cache = False
        If actualword$ = HelpIndexCache()\name OR actualword$ = HelpIndexCache()\includefile
          found_in_cache = True
        End If
      Wend

      If found_in_cache
        tmp_string = dos_AddPart{pedconfig\includeDir, HelpIndexCache()\includefile}
        log_Print{"found in HelpIndexCache(), will open it:" + tmp_string}
        !PED_LoadSource{tmp_string,False,True,True}  
        PED_UpdateStatusArea{}                                                                                                                                                                                                                           
        Gosub set_pointer_normal
        *currLine = ped\ptrCurrentSourceData\CurrentSourceLine
        ;-- jump upwards and search again in file ...
        Goto jump_search
      Else
        log_Print{"not found in cache"}
      EndIf
    EndIf
    Gosub set_pointer_normal

  EndIf
Return

.open_helpdiag
  If diag.l = 0
    WZWindow WZID("WIN_HELPDIAG"),?wzgui,80,wtemp\diag_x,wtemp\diag_y,wtemp\diag_w,wtemp\diag_h,WZID("WIN_HELPDIAG")
    WZ_AddMenuStrip{"WIN_HELPDIAG", ped\menuStrip}
    diag = 1
  End If
  Gosub diag_redraw
Return


.diag_redraw:
  If diag = 0 Then Return

  strline$ = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
  actualword$ = PED_GetWordAtPos{strline$, ped\ptrCurrentSourceData\Column,True}
  w$ = actualword$
  tokname$ = actualword$

  log_Print{"diag_redraw, searching for [" + w$ + "]"}

  parlist.s = ""

  ;-- search in tokenlist
  parlist = PED_GetTokenHelp{w$}
  If parlist <> ""
    ;-- remove comments in helptext
    i = Instr(parlist, ";")
    If i Then parlist = Left$(parlist,i)
  End If

  diag_addcodesize.l = 0 : lineSize.l = 0
  If parlist <> ""
    log_Print{"found: " + parlist}
    Use Window WZID("WIN_HELPDIAG")

    tokname$ + " " + parlist
    WZPrint "DIAG_TOKEN",&tokname$

    ; build parameter table
    InitArgParse parlist
    For i =  1 To 12
      diag_lab$(i) = NextArgChar$ (@",")

      If  Left$(diag_lab$(i),1) = "(" Then diag_lab$(i) = UnRight$(diag_lab$(i),1)
      If Right$(diag_lab$(i),1) = ")" Then diag_lab$(i) =  UnLeft$(diag_lab$(i),1)       
      If Right$(diag_lab$(i),1) = "[" Then diag_lab$(i) =  UnLeft$(diag_lab$(i),1)       
      If Right$(diag_lab$(i),1) = "]" Then diag_lab$(i) =  UnLeft$(diag_lab$(i),1)              
      If Right$(diag_lab$(i),2) = "][" Then diag_lab$(i)=  UnLeft$(diag_lab$(i),2)              

      If diag_lab$(i) = "[" Then i = i - 1 : diag_lab$(i) + "["
      WZPrint "lab" + UStr$(i), &diag_lab$(i)
      diag_val$(i) = ""
      WZPrint "val" + UStr$(i), &diag_val$(i)
    Next

    lineStr.s = StripTrail$(Peeks$(Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset,#MAX_Columns),@" ")
    lineSize.l = FLen(lineStr)
    linePos.w = ped\ptrCurrentSourceData\Column
    If linePos > 0
      dFound.b = False
      Repeat
        lineChar.b = Peek.b(&lineStr+linePos)
        linePos + 1
        If lineChar = @" " OR lineChar = @"{" Then dFound = True
      Until lineChar < 0 OR linePos = lineSize OR dFound
      If NOT dFound
        dExit.b = False
        Repeat
          lineChar.b = Peek.b(&lineStr + linePos)
          linePos + 1
          If lineChar = @":" OR lineChar = @";" OR linePos = lineSize Then dExit = True
          If lineChar = @" " OR lineChar = @"{" OR lineChar = @"(" Then dFound = True
        Until dExit OR dFound
      EndIf
      If NOT dExit
        log_Print{"used pars: [" + Mid$(lineStr,linePos,lineSize-linePos) + "]"}
        parlist = Mid$(lineStr,linePos,lineSize-linePos)
        i.l = 0 : i2.l = 0
        Repeat
          w.l = PeekUB(&parlist + i)
          If w = $22 Then i2 BitChg 0
          If i2 = 0
            If w > $80 Then Poke.b &parlist + i, w BitClr 7
            If w = @";" OR w = @":" Then w = 0
          End If
          i + 1
        Until w = 0
        diag_addcodepos.l = linePos
        diag_addcodesize.l = i
        diag_addstr$ = ""
        If i Then parlist = Left$(parlist,i-1)
        If Peek.b(&parlist) = @"(" Then parlist = Right$(parlist,FLen(parlist)-1) : diag_addstr$ = "("
        If Peek.b(&parlist) = @"{" Then parlist = Right$(parlist,FLen(parlist)-1) : diag_addstr$ = "{"
        InitArgParse parlist
        For i = 1 To 12
          diag_val$(i) = NextArgChar$(@",","{[(\\22",")]}\\22")
          If diag_lab$(i) <> "" Then WZPrint "val" + UStr$(i), &diag_val$(i)
        Next
      EndIf
    EndIf
  EndIf
Return



.help_checkfortype:
  typestr$ = ""
  tmpColumn.w = ped\ptrCurrentSourceData\Column - 2
  If tmpColumn < 0 Then tmpColumn = 1
                                                                                                                                                                                
  lineAddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset + ped\ptrCurrentSourceData\Column
  lineAddrStore.l = lineAddr
  log_Print{"check current char <" + Chr$(Peek.b(lineAddr)) + "> for type help"}

  If Peek.b(lineAddr-1) = @"\" 
    lineAddr - 1
  Else
    If Peek.b(lineAddr) <> @"\" 
      log_Print{"no \ found nearby."}
      Return
    EndIf
  EndIf
 
  ; -- skip spaces 
  Repeat                                                  
    lineAddr - 1
  Until Peek.b(lineAddr) <> @" " OR (lineAddr = lineAddrStore)

  ; -- skip brackets if we have an array
  If Peek.b(lineAddr) = @")"
    log_Print{"skipping array brackets"}
    Repeat
      lineAddr - 1
    Until Peek.b(lineAddr) = @"(" OR (lineAddr = lineAddrStore)
  EndIf

  ; -- skip characters not allowed for typedefs
  actbyte.b = Peek.b(lineAddr)                            
  If actbyte <> @"_" AND actbyte < @"0" AND (actbyte < @":" OR actbyte < @"A") OR actbyte > @"z"
    log_Print{"no printable character found, exiting help routine for type"}
    Goto exit_checkfortype
  EndIf

  ; -- skip illegal characters
  type_again:
  Repeat
    lineAddr - 1
  Until !IsIllegalChar{Peek.b(lineAddr)} OR (lineAddr = lineAddrStore)
  If Peek.b(lineAddr) = @"*" Then Goto type_again

  ; -- we have dot, that means the typename is right here!
  If Peek.b(lineAddr) = @"."                            
    log_Print{"we have a dot, so the typename is right here:" + Peeks$(lineAddr,10)+ "..."}
    PED_UpdateDefinitionBrowser{#DEFBROWSER_SELECTTYPE,Peek.s(lineAddr),True}
    Return
  EndIf

  ;----------------------------------------------------------------------------------
  ; -- no dot we have to determine the type by searching for type definitions in previous code
  log_Print{"no dot, searching for type defintions in previous code"}
  typestr$ = ""
  ; -- skip illegal characters again
  lineAddr + 1
  While !IsIllegalChar{Peek.b(lineAddr)} = False OR Peek.b(lineAddr) = @"*"
    typestr$ + Chr$(Peek.b(lineAddr))
    lineAddr + 1
  Wend
 
  log_Print{"this is what we have so far as the variable name: [" + typestr$ + "]"}
  ;-- try to get the type
  typestr$ = PED_GetDefinitionOf{typestr$}
  If typestr$ <> ""
    log_Print{"type [" + typestr$ + "] found, showing in Browser..."}
    PED_UpdateDefinitionBrowser{#DEFBROWSER_SELECTTYPE, typestr$, True}
  Else
    If PED_GetVariableByName{typestr$}
      log_Print{"variable found, showing in Browser..."}
      PED_UpdateDefinitionBrowser{#DEFBROWSER_VARIABLE, typestr$, True}
    EndIf
  EndIf
  If typestr$ = ""
    log_Print{"no type or var information found."}
  EndIf

  exit_checkfortype:
Return

.help_checkforif:
  *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  nestcount.b = 1                                                                                                                                                                                                                                        
  bytecount.w = 0
  Repeat
    iffound.b = 0
    *textline.l = *tempLine + 9

    ; kill any spaces before Token
    testaddr.l = Peek.l(*textline) : bytecount = 0
    While (testaddr LSR 16) <> $0000
      testaddr = Peek.l(*textline + bytecount)
      actword.w = testaddr LSR 16

      ; check the token for parts of an if-loop
      Select actword
      Case #TOKEN_EndIf    ; EndIf
        nestcount + 1

;      Case #TOKEN_End    ; End
;        nestcount + 1

      Case #TOKEN_If    ; If
        nestcount - 1
        iffound  = 1

      Case #TOKEN_Then    ; Then
        nestcount + 1
      End Select

;      !cout{nestcount, Hex$(testaddr),linestr$}
      bytecount + 1
    Wend
    If (nestcount = 1) Then Pop Repeat : Goto foundif

    ; get previous line pointer
    *tempLine = *tempLine\nextLine
  Until *tempLine = 0
  foundif:
  If (iffound = 1)
    strline$ = PED_Detoke{*tempLine}
    strline$ = Trim$(strline$)
    PED_ShowMessage{"Corresponding Header: " + strline$}
  EndIf
Return

.close_contexthelp
  If WZ_IsOpen{"WIN_CONTEXTHELP"}
    WZListRemove helpme.List
    WZCloseWindow WZID("WIN_CONTEXTHELP")
  EndIf
RTS

.close_popupwindow
  If pedconfig\intellisense
    WZ_PopUpCloseNonmodal{}   ; move the code to the new include function  tomsmart1
    popup_selected.l = 0
  EndIf
RTS

.open_librarybrowser:
  If NOT WZ_IsOpen{"WIN_LIBRARYBROWSER"}                                                                                                                                                                                                              
    USEPATH wtemp
    WZWindow WZID("WIN_LIBRARYBROWSER"),?wzgui,255,\lbrowser_x,\lbrowser_y,\lbrowser_w,\lbrowser_h,WZID("WIN_LIBRARYBROWSER")
    WZ_AddMenuStrip{"WIN_LIBRARYBROWSER", ped\menuStrip}
  EndIf
    Use Window WZID("WIN_LIBRARYBROWSER")
    WZ_InitTable{"WIN_LIBRARYBROWSER","FUNCTIONSTABLE",2}
    WZ_SetTableTitle{"FUNCTIONSTABLE","Function","Syntax"};,"Library"}
    WZ_SetPriority{"FUNCTIONSTABLE",2,3}
    WZ_DrawTable{"FUNCTIONSTABLE"}
    Gosub update_librarylist
    Gosub update_functiontable
;  Else
;    Use Window WZID("WIN_LIBRARYBROWSER")
    Activate WZID("WIN_LIBRARYBROWSER")
    WZ_UpdateTable{"FUNCTIONSTABLE"}
;  End If
Return


event_librarybrowser:
  ; check for events occured with the functiontable
  wev.l = WZ_CheckTableEvent{pedMessage\_Class}
  Select wev

    Case #WZTABLEEVENT_CELLSELECTED
      pos.l = WZ_Row{"FUNCTIONSTABLE"}
      actualword$ = WZ_GetCell{"FUNCTIONSTABLE",WZ_Row{"FUNCTIONSTABLE"},1}
      If actualword$<>""
        libinfo$ = lib_mapping$(libnumber.l,0)+" (LibNr. "+Str$(libnumber)+" Token "+Hexw$(PED_GetTokenID{actualword$}) +")"
        WZPrint "ARGS_LIBRARYNAME",&libinfo$
      EndIf

    Case #WZTABLEEVENT_DOUBLECLICK
      pos = WZ_Row{"FUNCTIONSTABLE"}
      actualword$ = WZ_GetCell{"FUNCTIONSTABLE",WZ_Row{"FUNCTIONSTABLE"},1}
      If actualword$<>""
        Gosub instructionbrowser_startguide
      EndIf
  End Select

  Select pedMessage\_Class
    Case #IDCMP_CLOSEWINDOW:
      Gosub close_librarybrowser

    Case #IDCMP_VANILLAKEY:
      ;error{"VAN: " + Hexw$(EventCode)}
      If pedMessage\_Code = #VANILLAKEY_ESC Then Gosub close_librarybrowser
      If pedMessage\_Code = #VANILLAKEY_TAB Then Gosub activatesourcewindow

    Case #IDCMP_IDCMPUPDATE
      Select WZGadName

        Case "LIST_LIBRARIES"
          Gosub update_functiontable

        Case "CYCLE_SORTORDER"
          Gosub update_librarylist
          Gosub update_functiontable

        Case "BUTTON_LIB_FREEIDS"
          message$ = !TRANS{"The following lib-IDs are not in use:"}+"\\n\\n"
          For i = 1 To (#Max_BlitzLibs-1)             ; replaced hardcoded 255 with (#Max_BlitzLibs-1) because we start with 0  tomsmart1
            If Instr(lib_mapping$(i,0),"unused")<>0
              message$ + Str$(i)+ "  "
            EndIf
          Next i
          WZ_LockWindow{"WIN_LIBRARYBROWSER"}
          dummy.l = ask{message$,!TRANS{"Ok"},!TRANS{"Info"}}
          WZ_UnlockWindow{"WIN_LIBRARYBROWSER"}

        Case "BUTTON_LIB_CHECK_CONSISTENCY"
          WZ_LockWindow{"WIN_LIBRARYBROWSER"}

          WZ_ShowMessage{!TRANS{"Checking BlitzLib consistency..."},1}

          tmp_string = ""
          libID.l = 0 : olibID.l = 0
          For i = 0 To (#Max_BlitzLibs-1) : lib_check(i) = False : Next i

          *token.tokendata = *tokenbase
          Repeat 
            libID.l = (*token\number LSR 7)

            If (libID.l <> olibID.l) AND (libID>1) ; skip internal systemlib and dhandlerlib
              If lib_check(libID) = False
                lib_check(libID) = True
              Else
                For i = 0 To (#Max_BlitzLibs-1)
                  If lib_mapping$(i,1) = Peek.s(&*token\dat)
                    old_libname.s = StripTrail$(UnRight$(lib_mapping$(i,0),Instr(lib_mapping$(libID,0),"with ")+4),@")")
                    Pop If : Pop For : Goto exit_for2
                  EndIf
                Next i
                log_Print{"nothing found for token [" + Peek.s(&*token\dat) + "], libID #" + Str$(libID)}
                exit_for2:
                error_libname.s = Left$(lib_mapping$(libID,0),Instr(lib_mapping$(libID,0)," ")-1)
                tmp_string + "+ " + old_libname + " has been overwritten by\\n"
                tmp_string + "\\22" + error_libname + "\\22 with same LibID: "+Str$(libID)+"\\n\\n"
              EndIf
              olibID = libID
              !WZ_GaugeInfo{&lib_mapping$(libID,0)}
            EndIf
            *token = *token\next_token
          Until (*token = 0)

          WZ_HideMessage{}
          If tmp_string = ""
            tmp_string = !TRANS{"The internal library structure seems to be correct."}
          EndIf
          dummy.l = ask{tmp_string,!TRANS{"Ok"},!TRANS{"Info"}}

          WZ_UnlockWindow{"WIN_LIBRARYBROWSER"}
      End Select
  End Select
Return

.close_librarybrowser:
  WZ_KillTable{"FUNCTIONSTABLE"}
  WZ_CloseWindowAndRemoveMenu{"WIN_LIBRARYBROWSER"}                                                                                                                                                                                                      
  WZListRemove libslist.List
Return

.update_librarylist:
  sortorder.b = WZInput("CYCLE_SORTORDER")
  WZListRemove libslist.List
  Format "000"
  For i = 0 To (#Max_BlitzLibs-1)
    If Instr(lib_mapping$(i,0),"unused") = 0
      If sortorder = 0
        listvalue.s = lib_mapping$(i,0)
      Else
        listvalue.s = Str$(i)+ " | " + lib_mapping$(i,0)
      EndIf
      WZListAdd libslist.List,listvalue,-1,i
    EndIf
  Next i
  Format ""
  WZPrint "LIST_LIBRARIES",0,libslist
Return


.update_functiontable:
  selected.l = WZInput("LIST_LIBRARIES")
  libnumber = WZListData(libslist,selected)
  libinfo$ = lib_mapping$(libnumber,0)+" (LibNr. "+Str$(libnumber)+")"

  WZPrint "ARGS_LIBRARYNAME",&libinfo$

  WZ_ClearTable{"FUNCTIONSTABLE"}

  If *tokenbase
    *token.tokendata = *tokenbase : tfound.b = False : tcounter.l = 0 : tname$ = ""
    Repeat
      If (*token\number LSR 7) = libnumber
        tname.s = Peek.s(&*token\dat)
        WZ_AddRow{"FUNCTIONSTABLE",tname ,Peek.s(&*token\dat + FLen(tname) + 1)}
      EndIf
      *token = *token\next_token : tcounter + 1
    Until *token = 0
  EndIf
  WZ_TableSort{"FUNCTIONSTABLE",1}
  WZ_UpdateTable{"FUNCTIONSTABLE"}
Return


.open_instructionbrowser
  Gosub close_popupwindow
  If NOT WZ_IsOpen{"WIN_INSTRUCTIONBROWSER"} ; thilo: why this was commented out!?
    WZWindow WZID("WIN_INSTRUCTIONBROWSER"),?wzgui,255,wtemp\ibrowser_x,wtemp\ibrowser_y,wtemp\ibrowser_w,wtemp\ibrowser_h,WZID("WIN_INSTRUCTIONBROWSER")
    WZ_AddMenuStrip{"WIN_INSTRUCTIONBROWSER", ped\menuStrip}
    If search_instruction$<>"" Then WZPrint "INSTRUCTION_STRING",search_instruction$
    WZPrint "macros",browse_macros
    WZPrint "instr",browse_instructions
    WZPrint "incdir",browse_includes
    WZ_InitTable{"WIN_INSTRUCTIONBROWSER","INSTRUCTIONTABLE",2}
    WZ_SetTableTitle{"INSTRUCTIONTABLE","Function","Syntax"};,"Library"}
    WZ_SetPriority{"INSTRUCTIONTABLE",2,3}
    WZ_DrawTable{"INSTRUCTIONTABLE"}
    previoussearch_instruction$="|"
    Gosub update_instructiontable
  Else
    Use Window WZID("WIN_INSTRUCTIONBROWSER")
    Activate WZID("WIN_INSTRUCTIONBROWSER")
    WZ_UpdateTable{"INSTRUCTIONTABLE"}
    WZPrint "INSTRUCTION_STRING",search_instruction$
  End If
  WZ_ActivateGadget{"INSTRUCTION_STRING"}
RTS


.event_instructionbrowser:
  ; check for events occured with the instructiontable
  wev.l = WZ_CheckTableEvent{pedMessage\_Class}
  Select wev

    Case #WZTABLEEVENT_CELLSELECTED
      b$ = WZ_GetCell{"INSTRUCTIONTABLE",WZ_Row{"INSTRUCTIONTABLE"},1}
      bstr$ = b$
      *token.tokendata = *tokenbase
      While *token
        If b$ = Peek.s(&*token\dat) Then Pop While: Goto tfound
        *token = *token\next_token
      Wend

     tfound:
      If *token
        tokenNumber.w = *token\number
        iinfo$ = "Library: " + PED_GetLibname{tokenNumber LSR 7}
        iinfo$ + " - LibNr.: " + Str$(tokenNumber LSR 7) + " - TokenNr: " + Str$((tokenNumber AND $7f)-1) + " - TokenId: $" + Hexw$(tokenNumber)
      Else
        iinfo$ = "Include: " + PED_GetIncludeName{bstr$}
      EndIf
      WZTags #WARGSA_TextPen,2
      WZPrint "INSTRUCTION_INFO",&iinfo$

    Case #WZTABLEEVENT_DOUBLECLICK
      pos = WZ_Row{"INSTRUCTIONTABLE"}
      actualword$ = WZ_GetCell{"INSTRUCTIONTABLE",WZ_Row{"INSTRUCTIONTABLE"},1}
      Gosub instructionbrowser_startguide

  End Select

  Select pedMessage\_Class

    Case #IDCMP_INTUITICKS
      Gosub update_instructiontable

    Case #IDCMP_CLOSEWINDOW:
      Gosub close_instructionbrowser

    Case #IDCMP_RAWKEY:
      ;error{"RAW: " + Hexw$(EventCode)}

    Case #IDCMP_VANILLAKEY:
      ;error{"VAN: " + Hexw$(EventCode)}
      Select EventCode
      Case #VANILLAKEY_ESC : Gosub close_instructionbrowser
      Case #VANILLAKEY_TAB : Gosub activatesourcewindow
      End Select

    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "add" ;add to code
          a$ = Trim$(bstr$)
          If a$<>""
           log_Print{"adding to code: " + a$}
            lineaddr.l = Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset
            lineaddr + ped\ptrCurrentSourceData\ColumnsOffset + ped\ptrCurrentSourceData\Column
            log_Print{"current source area: [" + Peek$(lineaddr) + "]"}
            tempph.w = 0
            If Peek.b(lineaddr-tempph) = $20
              While Peek.b(lineaddr-tempph) = $20
                tempph + 1
              Wend
              log_Print{Str$(tempph) + " spaces after last char"}
              !PED_CursorOff
              For i = 1 To tempph
                Gosub deletechar
              Next i
            EndIf
            Gosub insertstring
            Gosub activatesourcewindow
          EndIf

        Case "macros"
          browse_macros = WZInput
          previoussearch_instruction$ = "|"
          WZ_ActivateGadget{"INSTRUCTION_STRING"}

        Case "instr"
          browse_instructions = WZInput
          previoussearch_instruction$ = "|"
          WZ_ActivateGadget{"INSTRUCTION_STRING"}

        Case "incdir"
          browse_includes = WZInput
          previoussearch_instruction$ = "|"
          WZ_ActivateGadget{"INSTRUCTION_STRING"}
      End Select

  End Select
Return

.close_instructionbrowser:
  wtemp\ibrowser_x = WindowX
  wtemp\ibrowser_y = WindowY
  wtemp\ibrowser_w = WindowWidth
  wtemp\ibrowser_h = WindowHeight
  WZ_KillTable{"INSTRUCTIONTABLE"}
  WZ_CloseWindowAndRemoveMenu{"WIN_INSTRUCTIONBROWSER"}                                                                                                                                                                                                  
Return

.update_instructiontable:
  search_instruction$ = WZGetString("INSTRUCTION_STRING")
  If (search_instruction$<>previoussearch_instruction$) AND (Len(search_instruction$) > 1)
    previoussearch_instruction$ = search_instruction$
    WZ_ClearTable{"INSTRUCTIONTABLE"}
    InitArgParse search_instruction$
    word1$ = NextArg$
    word2$ = NextArg$
    instruction_counter.l = 0

    If browse_instructions
      log_Print{"instruction browser: searching for token <" + word1$ + "/" + word2$+ ">"}
      *token.tokendata = *tokenbase
      While *token
        token_name.s = Peek.s(&*token\dat)
        If Instr(token_name, word1$) AND instruction_counter < #maxlabels
          token_help.s = Peek.s(&*token\dat + FLen(token_name) + 1)
          If Instr(token_help, word2$)
            instruction_counter = instruction_counter + 1
            WZ_AddRow{"INSTRUCTIONTABLE",token_name, token_help}
            If PED_CheckForClassicToken{*token\number} Then WZ_SetRowPen{"INSTRUCTIONTABLE",AB3Pen(#AB3_cclassic),0}
          EndIf
        EndIf
        *token = *token\next_token
      Wend
    EndIf
     
    If browse_macros
      log_Print{"instruction browser: searching for macro <" + word1$ + ">"}
      *macroP.l = *macrobase
      c.l = 0
      While *macroP
        macro_name.s = Peek.s(*macroP + 13)
        If Instr(macro_name, word1$) AND instruction_counter < #maxlabels
          If Instr(macro_name, word2$)
            instruction_counter = instruction_counter + 1
            i = Peek.w(*macroP + 8)
            If i > 90 Then i = 90
            macro_name = "!" + macro_name
            macro_help.s = Peeks$(Peek.l(*macroP + 4),i)
            WZ_AddRow{"INSTRUCTIONTABLE", macro_name, macro_help}
          End If
        End If
        *macroP = Peek.l(*macroP)
      Wend
    End If

    If browse_includes
      ResetList HelpIndexCache()
      While NextItemFast(HelpIndexCache())
        If Instr(HelpIndexCache()\name,word1$) AND instruction_counter<#maxlabels
          If Instr(HelpIndexCache()\name,word2$)
            instruction_counter = instruction_counter+1
            WZ_AddRow{"INSTRUCTIONTABLE",HelpIndexCache()\name,HelpIndexCache()\help}
          End If
        End If
      Wend
    End If
    pos = 0
    WZ_TableSort{"INSTRUCTIONTABLE",1}
    WZ_UpdateTable{"INSTRUCTIONTABLE"}
  Else
    If (search_instruction$<>previoussearch_instruction$) AND (Len(search_instruction$)<2)
      previoussearch_instruction$ = search_instruction$
      WZ_ClearTable{"INSTRUCTIONTABLE"}
     WZ_UpdateTable{"INSTRUCTIONTABLE"}
    EndIf
  End If
Return

.event_popup:
  log_Print{"processing poupevent " + Hex$(pedMessage\_Class)}
  popexit.l = False
                                                ; added to set the init value that fix the bug that after select a item with a doubleclick the next popup win are autoclosed  tomsmart1
  Select pedMessage\_Class
    Case #IDCMP_IDCMPUPDATE
      If Left$(WZGadName,9) = "POPUPMENU"
        popup_selected = WZInput + 1
        popexit = True
      EndIf

    Case #IDCMP_RAWKEY
      log_Print{"RAWKEY " + Hex$(pedMessage\_Code)}
    Case #IDCMP_MOUSEBUTTONS
;      mb.b = MButtons
;      If (mb = 1) OR (mb=2)
;         popexit = True
;      EndIf
  End Select

  If popexit = True
    a$ = WZ_GetPopUpEntry{popup_selected}
    ;log_Print{"selected: " + a$}
    brackpos.w = Instr(a$,"{")
    If brackpos > 0
      a$ = Trim$(Left$(a$,brackpos-1))
      a$ = UnRight$(a$,Len(poptok$)) + "{"
    Else
      a$ = UnRight$(a$,Len(poptok$)) 
    EndIf
    ;log_Print{"inserting: " + a$} 
    Gosub insertstring
    PED_ShowMessage{a$ + " " + PED_GetIncludeHelp{a$} }    ; removed a$ test because it is not needed  tomsmart1
    Gosub close_popupwindow
  EndIf
  Gosub activatesourcewindow                                ; always active sourcewin if a popupwin event happend like mouse click or scroll  tomsmart1
Return


.insertstring:
  ; --
  ; -- check for a comment
  i = SearchBegin(a$,Asc(";"),1)
  If i Then a$ = Left$(a$,i-2) ;+" "

  If a$ <> ""
    For i = 1 To Len(a$)
      last_vankey = Asc(Mid$(a$,i,1) )
      If ped\ptrCurrentSourceData\Column < $7d      ;#MAX_Columns - 1
        Gosub insertchar
      EndIf
    Next i
  EndIf
Return


.instructionbrowser_startguide   ;actualword$: zu suchende Funktion

  PED_ShowMessage{!TRANS{"Searching help for <" + actualword$ + ">"}}

  *token.tokendata = PED_GetTokenPointer{actualword$}
  If *token
    libnumber = *token\number LSR 7
    If Right$(actualword$,1) = "_"
      actualword$ = Left$(actualword$,FLen(actualword$) - 1)
      helpdir$ = pedconfig\autodocDir
    EndIf
    libname$ = lib_mapping$(libnumber,0)

    ;-- check if library has an number extention (e.g. for libraries that have more than 128 tokens)
    mostright$ = Right$(libname$,1)
    If mostright$ = "1" OR mostright$ = "2" Then libname$ = Left$(libname$,FLen(libname$)-1)
  Else
    libname$ = PED_GetIncludeName{actualword$}
  EndIf

  If (libname$ <> "") AND Instr(libname$,"unused") = 0
    Show_Helpfile{libname$, actualword$, helpdir$}
  Else
    search_instruction$ = actualword$
    Gosub open_instructionbrowser
    ;dummy.l = ask{"No help available",!TRANS{"Ok"},!TRANS{"Info"}}
  EndIf

  PED_ShowMessage{""}
Return


.open_shortcuts
  If NOT WZ_IsOpen{"WIN_SHORTCUTS"}
    WZWindow WZID("WIN_SHORTCUTS"),?wzgui,255,wtemp\short_x,wtemp\short_y,wtemp\short_w,wtemp\short_h,WZID("WIN_SHORTCUTS")
    WZ_AddMenuStrip{"WIN_SHORTCUTS", ped\menuStrip}

    WZ_InitTable{"WIN_SHORTCUTS","SHORTCUTS",2}
    WZ_SetPriority{"SHORTCUTS",1,2}
    WZ_SetTableReadOnly{"SHORTCUTS",True}        ; disabled row selection
    WZ_SetEditable{"SHORTCUTS",False,False}      ; disabled editing of the table  tomsmart1
    WZ_SetSortable{"SHORTCUTS",False}            ; disabled sorting for the table  tomsmart1
    ; update keys and changed order  tomsmart1
    WZ_SetTableTitle{"SHORTCUTS",!TRANS{"Key"}                       ,!TRANS{"Function"}}
           WZ_AddRow{"SHORTCUTS",       "Navigation"           ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+LeftArrow"}             ,!TRANS{"Go Back in history"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+RightArrow"}            ,!TRANS{"Go Forward in history"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+Left Mousebutton"}      ,!TRANS{"Jump to Label/Func-Definition"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+Middle Mousebutton"}    ,!TRANS{"Back from Label/func"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+UpArrow"}              ,!TRANS{"Jump to first line"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+DownArrow"}            ,!TRANS{"Jump to last line"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+LeftArrow"}            ,!TRANS{"Move cursor to start of word"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+RightArrow"}           ,!TRANS{"Move cursor to end of word"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+A"}                 ,!TRANS{"Jump to the last line in that something was added"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+SHIFT+1-3"}         ,!TRANS{"Set bookmark 1-3"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+1-3"}               ,!TRANS{"Jump to bookmark 1-3"} }

           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",       "Edit"               ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+X"}                    ,!TRANS{"CUT same as <AMIGA>+<X>"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+C"}                    ,!TRANS{"COPY vertical, all select lines only copyed at the select column"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+V"}                    ,!TRANS{"PASTE vertical, all lines pasted at the cursor column"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+U"}                    ,!TRANS{"undo delete current line"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+UpArrow"}               ,!TRANS{"Move Line Up"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+DownArrow"}             ,!TRANS{"Move Line Down"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+E"}                    ,!TRANS{"Insert 'End If'"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+F"}                    ,!TRANS{"Insert a 'Function' skeleton"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+N"}                    ,!TRANS{"Insert a 'Newtype' skeleton"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+S"}                    ,!TRANS{"Insert a 'Statement' skeleton"} }

           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+RightArrow on block"}  ,!TRANS{"TAB marked Block"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+LeftArrow on block"}   ,!TRANS{"Un-TAB marked Block"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+SHIFT+UpArrow"}        ,!TRANS{"Extend blockmark upwards"}   }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+SHIFT+DownArrow"}      ,!TRANS{"Extend blockmark downwards"} }

           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",       "Help"                 ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP+SHIFT"}                ,!TRANS{"Opens guide/autodoc of instruction under cursor"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP+CTRL"}                 ,!TRANS{"Opens parameter diagnostic for actual function"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP on any function"}      ,!TRANS{"Displays correct syntax in screens titlebar"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP on '\'"}               ,!TRANS{"Opens window 'type browser' and shows newtype information"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP on 'EndIf'"}           ,!TRANS{"Shows corresponding IF-Blockheader"} }

           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",       "Editor-Actions"       ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"TAB"}                       ,!TRANS{"Activates sourcewindow"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ESC"}                       ,!TRANS{"Closes any active helpwindow"} }
           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+Click on filename"}     ,!TRANS{"Save and compile and run"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+Click on filename"}    ,!TRANS{"Save and create exe (save both if you click on different)"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+I"}                    ,!TRANS{"Switch Intellisense for Commands 'on/off' if Intellisens is enabled"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+F4-F6"}             ,!TRANS{"save winconfig"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F4-F6"}                     ,!TRANS{"load winconfig (F4 also startconfig)"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F7"}                        ,!TRANS{"window autolayout variant #1"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F8"}                        ,!TRANS{"window autolayout variant #2"} }
           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",!TRANS{"F9"}                        ,!TRANS{"goto previous document"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F10"}                       ,!TRANS{"goto next document"} }
    WZ_DrawTable{"SHORTCUTS"}
    WZ_UpdateTable{"SHORTCUTS"}
  EndIf
Return


.event_shortcuts:
  wev.l = WZ_CheckTableEvent{pedMessage\_Class}
  Select pedMessage\_Class
    Case #IDCMP_VANILLAKEY:
      If EventCode = #VANILLAKEY_ESC Then Gosub close_shortcuts
      If EventCode = #VANILLAKEY_TAB Then Gosub activatesourcewindow

    Case #IDCMP_CLOSEWINDOW
      Gosub close_shortcuts
  End Select
Return

.close_shortcuts:
  WZ_KillTable{"SHORTCUTS"}
  WZ_CloseWindowAndRemoveMenu{"WIN_SHORTCUTS"}                                                                                                                                                                                                           
Return


.open_cliarguments
  *clistringptr.l = Peek.l(?comPtr_CLIArgumentsString)
  If *clistringptr >< 0
    clistr.s = Peek.s(*clistringptr)
  Else
    Return
  End If
  old_clistr.s = clistr
  ;FindScreen 0
  WZWindow WZID("WIN_CLIARGUMENTS"),?wzgui,64,-1,-1,-1,-1,WZID("WIN_CLIARGUMENTS")
  If clistr<>"" Then WZPrint "CLI_ARGUMENTS",&clistr
  WZ_ActivateGadget{"CLI_ARGUMENTS"}                                                                                                                                                                                                                     
  exit_cli.b = False : get_arguments.b = False

  Repeat
    ev.l = WaitEvent

    ; context onlinehelp for most windows
   ; If onlinehelp <> 0
   ;   If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) AND (ev<>#IDCMP_GADGETHELP)  AND (ev<>#IDCMP_CHANGEWINDOW)
   ;     WZ_HideHelp{}
   ;   EndIf
   ;   If ev = #IDCMP_GADGETHELP Then WZ_ShowHelp{}
   ; EndIf

    Select ev

      Case #IDCMP_CLOSEWINDOW
        exit_cli = True

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName

;          Case "CLI_ARGUMENTS"
;            get_arguments = True

          Case "CLI_OK"
            exit_cli = True
            get_arguments = True

          Case "CLI_CANCEL"
            get_arguments = False
            exit_cli = True

        End Select

      Default
        WZ_ActivateGadget{"CLI_ARGUMENTS"}                                                                                                                                                                                                               

    End Select

  Until exit_cli = True

  If get_arguments = True
    clistr = WZGetString("CLI_ARGUMENTS")
    Poke.s *clistringptr,Left$(clistr,127)
  Else
    clistr = old_clistr
  EndIf
  WZCloseWindow WZID("WIN_CLIARGUMENTS")
  FlushEvents
  Gosub activatesourcewindow
Return



.open_calculator:
  calc_expression.s = ""
  !ComData_GetL{comPtr_CalculatorExpressionString,D0} : CalculatorExpressionStringPointer.l = PutD0
  Poke.s CalculatorExpressionStringPointer,calc_expression
  If Peek.l(Addr Window(WZID("WIN_CALCULATOR")))=0
    WZWindow WZID("WIN_CALCULATOR"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_CALCULATOR")
    !ComData_SetW{comWord_CalculatorButtonBinFlag,#$00}
    !ComData_SetW{comWord_CalculatorButtonDecFlag,#$80}

    ;event_Calculator
    calc_exit.l = False
    calc_test.l = False
    Repeat
     WZ_ActivateGadget{"CALC_EXPRESSION"}                                                                                                                                                                                                                
     ev_calculator.l = WaitEvent

      Select ev_calculator
        Case #IDCMP_VANILLAKEY:
          If EventCode = #VANILLAKEY_ESC Then calc_exit = True

        Case #IDCMP_CLOSEWINDOW
          calc_exit = True

        Case #IDCMP_IDCMPUPDATE
          Select WZGadName

            Case "CALC_CLOSE"
              calc_exit = True

            Case "CALC_EXPRESSION"
              calc_expression = WZGetString("CALC_EXPRESSION")

            Case "BIN"
              !ComData_SetW{comWord_CalculatorButtonBinFlag,#$80}
              !ComData_SetW{comWord_CalculatorButtonDecFlag,#$00}
              calc_test = True

            Case "HEX"
              !ComData_SetW{comWord_CalculatorButtonBinFlag,#$00}
              !ComData_SetW{comWord_CalculatorButtonDecFlag,#$00}
              calc_test = True

            Case "DEC"
              !ComData_SetW{comWord_CalculatorButtonBinFlag,#$00}
              !ComData_SetW{comWord_CalculatorButtonDecFlag,#$80}
              calc_test = True

          End Select

          If FLen(calc_expression)<128                      ; test if the string is not longer than 128 byte because this is the limit that is set in the compiler source  tomsmart1 2012 05 30
            If (calc_expression<>"") AND (calc_exit = False)
              If (calc_expression<>Peek.s(CalculatorExpressionStringPointer) ) OR (calc_test = True)
                Poke.s CalculatorExpressionStringPointer,calc_expression
                !asm
                !ComData_JSR{comFunc_CalculatExpression} ;examine_expression
                !basic
                calc_expression = Peek.s(CalculatorExpressionStringPointer)
                WZPrint "CALC_EXPRESSION",&calc_expression
              EndIf
              calc_test = False
            EndIf
         Else
           error{!TRANS{"The expression is to long please reduce it to max 127 characters!"} }
         EndIf

      End Select

    Until calc_exit

    WZCloseWindow WZID("WIN_CALCULATOR")
    FlushEvents
    Gosub activatesourcewindow
  EndIf
Return


.open_definitionbrowser:
  PED_UpdateDefinitionBrowser{#DEFBROWSER_RESET,"",True}
  WZ_ActivateGadget{"STRING2"}
Return


.event_definitionbrowser:

  tev.l = WZ_CheckTableEvent{pedMessage\_Class}
  If tev = #WZTABLEEVENT_DOUBLECLICK
    Select ped\definitionMode
      Case 0 ; Constants
        temp$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},1}
        typestr$ = temp$
        WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
        WZPrint "NEWTYPE_ENTRY",&typestr$

      Default
        temp$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},1}

        c2$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},2}
        If c2$ <> "" Then c2$ = " ." + c2$

        c3$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},3}
        If c3$ <> "" Then c3$ = " $" + c3$

        temp$ + c2$ + c3$

        If ped\definitionMode = 1 AND lev  = 0
          i = SearchEnd (temp$,@".",1)
          If lev = 0 Then var$ = Left$(temp$,i - 1)
          temp$ = Mid$(temp$,i + 1)
        EndIf

        If ped\definitionMode <> 1 Then var$ = ""
        a$ = temp$

        lev = lev + 1 : If lev > 13 Then lev = 13

        pos2(lev) = 0        
        pos2(lev-1) = WZ_Row{"TYPETABLE"}

        ped\previousNewtypeStr = Left$(a$,Instr(a$," ")-1)

        If lev > 1
          i = SearchEnd(a$, @".", 1)
          i2 = SearchEnd(a$, @"$", 1)
          a$ = Mid$(a$, i+1, i2-i-3)
        EndIf

        log_Print{"search for type: " + a$ + " - " + ped\previousNewtypeStr}
        newtype_found = 0
        *nt.l = *newtypebase
        If *nt = 0
          error{"newtypebase = NULL => GURU!!!"}
        Else
          *nt = Peek.l(*nt)          
          While *nt AND newtype_found = False
            If Peek$(*nt + 11) = a$
              log_Print{"Found the type in newtypes-list [" + a$ + "]"}
              PED_UpdateDefinitionBrowser{#DEFBROWSER_LISTSUBTYPE, a$}
              newtype_found = 1
            EndIf
            *nt = Peek.l(*nt)
          Wend
        EndIf

        If newtype_found = 0
          lev = lev - 1
          a$ = ""
          For i = 1 To lev
            If i > 1
               a$ = a$ + "\" + pos$(i)
            Else
               a$ = a$ + "." + pos$(i)
            EndIf
          Next
          i = Instr(temp$," ")
          temp$ = Replace$ (temp$,"*","")
          typestr$ = var$ + a$ + "\" + Left$(temp$,i)
          WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
          WZPrint "NEWTYPE_ENTRY",&typestr$
        EndIf

    End Select

  EndIf

  Select pedMessage\_Class

    Case #IDCMP_INTUITICKS
      Select ped\definitionMode

        Case 0
          ped\currentConstantStr = WZGetString("STRING2")
          If ped\currentConstantStr <> ped\lastConstantStr
            ped\lastConstantStr = ped\currentConstantStr
            PED_UpdateDefinitionBrowser{#DEFBROWSER_CONSTANT, ped\currentConstantStr,False}
          EndIf

        Case 1
          ped\currentVariableStr = WZGetString("STRING2")
          If ped\currentVariableStr <> ped\lastVariableStr
            ped\lastVariableStr = ped\currentVariableStr
            pos2(lev) = 0
            PED_UpdateDefinitionBrowser{#DEFBROWSER_VARIABLE, ped\currentVariableStr,False}
          EndIf

        Case 2
          ped\currentNewtypeStr = WZGetString("STRING2")
          If ped\currentNewtypeStr <> ped\lastNewtypeStr
            ped\lastNewtypeStr = ped\currentNewtypeStr
            newtype_found.l = 0
            pos2(lev) = 0
            PED_UpdateDefinitionBrowser{#DEFBROWSER_SELECTTYPE, ped\currentNewtypeStr,False}
          EndIf
      End Select

    Case #IDCMP_CLOSEWINDOW
      Gosub close_definitionbrowser

    Case #IDCMP_VANILLAKEY:
      If pedMessage\_Code = #VANILLAKEY_ESC Then Gosub close_definitionbrowser
      If pedMessage\_Code = #VANILLAKEY_TAB Then Gosub activatesourcewindow


    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "typeadd"
          a$ = typestr$
          If Instr(a$,"\",FLen(a$)-1)<>0 Then a$ = Left$(a$,FLen(a$)-1)
          If quicktype Then a$ = Mid$(typestr$,Instr (typestr$,"\")+1)
          If ped\definitionMode <> 1 Then a$ = Replace$(a$,"*","")
          Gosub insertstring
          Gosub activatesourcewindow

        Case "string2"
         ;Gosub activatesourcewindow                             ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1

        Case "parent" :
          quicktype = 0
          If ped\definitionMode = 0
          Else
            If lev Then lev = lev - 1
            If lev = 0
              If ped\definitionMode = 1
                PED_UpdateDefinitionBrowser{#DEFBROWSER_VARIABLE,"",False}
              Else
                If ped\currentNewtypeStr <> ""
                  PED_UpdateDefinitionBrowser{#DEFBROWSER_SELECTTYPE, ped\currentNewtypeStr}
                Else 
                  PED_UpdateDefinitionBrowser{#DEFBROWSER_RESETTYPE}
                EndIf
              EndIf
            Else
              PED_UpdateDefinitionBrowser{#DEFBROWSER_LISTSUBTYPE, pos$(lev)}
            EndIf

            a$ = "" : pos$(lev+1) = ""
            For i = 1 To lev:
              If i > 1
                a$ = a$ + "\" + pos$(i)
              Else
                a$ = a$ + "." + pos$(i)
              EndIf
            Next
            typestr$ = a$
            WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
            WZPrint "NEWTYPE_ENTRY",&a$
          End If

        Case "clear": ; button "reset"
          Select ped\definitionMode
          Case 0
            ped\currentConstantStr = ""
            WZPrint "STRING2",&ped\currentConstantStr
          Case 1
            ped\currentVariableStr = ""
            WZPrint "STRING2",&ped\currentVariableStr
          Case 2
            ped\currentNewtypeStr = ""
            WZPrint "STRING2",&ped\currentNewtypeStr
          End Select
          PED_UpdateDefinitionBrowser{#DEFBROWSER_RESET}

        Case "newtype_const"
          PED_UpdateDefinitionBrowser{#DEFBROWSER_CONSTANT,"",False}

        Case "newtype_var"
          PED_UpdateDefinitionBrowser{#DEFBROWSER_VARIABLE,"",False}

        Case "newtype_struct"
          PED_UpdateDefinitionBrowser{#DEFBROWSER_NEWTYPE,"",False}

      End Select
  End Select
Return

.close_definitionbrowser:
  wtemp\type_x = WindowX
  wtemp\type_y = WindowY
  wtemp\type_w = WindowWidth
  wtemp\type_h = WindowHeight
  WZ_KillTable{"TYPETABLE"}
  WZ_CloseWindowAndRemoveMenu{"WIN_NEWTYPE"}                                                                                                                                                                                                             
Return

.event_diag:
  Select pedMessage\_Class
    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "addcode"
            a$ = diag_addstr$
            For i =  1 To 12
              diag_val$(i) = WZGetString("val" + UStr$(i))
            Next
            Gosub close_diag

            For i = 1 To 12
              a$ = a$ + diag_val$(i)
              If diag_val$(i + 1) <> "" Then a$ = a$ + ","
            Next


            Gosub activatesourcewindow
            !PED_CursorOff
            tmpColumn.w = ped\ptrCurrentSourceData\Column
            tmpColumnsOffset.w = ped\ptrCurrentSourceData\ColumnsOffset

            MOVE.l diag_addcodepos@(a5),a0 : SUB.l textbufferaddr,a0 : SUB.w comWord_TextBufferOffset,a0
            MOVE.w a0,comWord_Column
            CLR.w comWord_ColumnsOffset

            ; remove code to be replaced by diag code
            If diag_addcodesize > 1 Then t$ = Peeks$(diag_addcodepos,diag_addcodesize) : Else t$ = ""
            t$ = StripLead$(t$,32) : i = FLen(t$)
            If i > 0
               MOVE.l diag_addcodepos@(a5),a0 : SUB.l textbufferaddr,a0 : SUB.w comWord_TextBufferOffset,a0
               MOVE.w a0,comWord_Column
               For i2 = 1 To i - 1
                 Gosub deletechar
               Next
            End If

            ; insert new code
            Gosub insertstring

            ped\ptrCurrentSourceData\ColumnsOffset = tmpColumnsOffset
            ped\ptrCurrentSourceData\Column = tmpColumn
            !PED_CursorOn

        Case "diagclear"
          For i = 1 To 12
            diag_val$(i) = ""
            WZPrint "val" + UStr$(i), diag_val$(i)
          Next
          WZ_ActivateGadget{"val1"}

      End Select

    Case #IDCMP_CLOSEWINDOW
      Gosub close_diag

    Case #IDCMP_VANILLAKEY
      If pedMessage\_Code = #VANILLAKEY_ESC Then Gosub close_diag

  End Select

Return


.close_diag:
  wtemp\diag_x = WindowX
  wtemp\diag_y = WindowY
  wtemp\diag_w = WindowWidth
  wtemp\diag_h = WindowHeight
  WZ_CloseWindowAndRemoveMenu{"WIN_HELPDIAG"}                                                                                                                                                                                                            
  diag = 0
Return


.load_windowlayouts:
  USEPATH wtemp
  CopyMem_ &wpref(ped\lastLayout),&wtemp,SizeOf .winprefs

  If (\lbrowser_w<=0) OR (\lbrowser_h<=0)
    \lbrowser_x = -2
    \lbrowser_y = -2
    \lbrowser_w = -2
    \lbrowser_h = -2
  EndIf

  If (\source_h > 0) AND (\source_w > 0)
    sourceWindow\WinLeft = \source_x
    sourceWindow\WinTop = \source_y
    sourceWindow\WinWidth = \source_w
    sourceWindow\WinHeight = \source_h
  Else
    ped\screen = Peek.l(Addr Screen(0))
    sourceWindow\WinLeft = 0
    sourceWindow\WinTop  = ped\screen\WBorTop + ped\screen\Font\ta_YSize + 1
    sourceWindow\WinWidth= ScreenWidth
    sourceWindow\WinHeight = ScreenHeight - (ped\screen\WBorTop + ped\screen\Font\ta_YSize + 1)
  EndIf
Return


.do_windowlayout:
  If \lbrowser_on
    log_Print{"opening library browser"}
    Gosub open_librarybrowser
  Else
    If WZ_IsOpen{"WIN_LIBRARYBROWSER"}
      WZ_KillTable{"FUNCTIONSTABLE"}
      WZ_CloseWindowAndRemoveMenu{"WIN_LIBRARYBROWSER"}                                                                                                                                                                                                  
    EndIf
  End If

  If \ibrowser_on
    log_Print{"opening instruction browser"}
    Gosub open_instructionbrowser
  Else
    If WZ_IsOpen{"WIN_INSTRUCTIONBROWSER"}
      WZ_KillTable{"INSTRUCTIONTABLE"}
      WZ_CloseWindowAndRemoveMenu{"WIN_INSTRUCTIONBROWSER"}                                                                                                                                                                                              
    EndIf
  End If

  If \diag_on
    Gosub open_helpdiag
  Else
    If WZ_IsOpen{"WIN_HELPDIAG"}
      WZ_CloseWindowAndRemoveMenu{"WIN_HELPDIAG"}                                                                                                                                                                                                        
      diag = 0
    EndIf
  End If

  If \click_on
    log_Print{"opening label window"}
    Gosub open_sourcebrowser
  Else
    If WZ_IsOpen{"WIN_LABELS"}
      WZ_CloseWindowAndRemoveMenu{"WIN_LABELS"}                                                                                                                                                                                                          
    EndIf
  End If

  If \short_on
    Gosub open_shortcuts
  Else
    If WZ_IsOpen{"WIN_SHORTCUTS"}
      WZ_KillTable{"SHORTCUTS"}
      WZ_CloseWindowAndRemoveMenu{"WIN_SHORTCUTS"}                                                                                                                                                                                                       
    EndIf
  End If

  If \type_on
    log_Print{"opening newtype window"}
    Gosub open_definitionbrowser
  Else
    If WZ_IsOpen{"WIN_NEWTYPE"}
      WZ_KillTable{"TYPETABLE"}
      WZ_CloseWindowAndRemoveMenu{"WIN_NEWTYPE"}                                                                                                                                                                                                         
    EndIf
  End If
 
  log_Print{"opening/updating source window"}
  If sourceWindow\win <> 0
    ChangeWindowBox_ sourceWindow\win,sourceWindow\WinLeft,sourceWindow\WinTop,sourceWindow\WinWidth,sourceWindow\WinHeight
    RefreshWindowFrame_ sourceWindow\win
    VWait 1
    Gosub resize_sourcewindow
  Else
    Gosub open_sourcewindow
    If ped\errorCode = #PEDERROR_OPENWINDOW
      dummy.l = ask{!TRANS{"Unable to open window"},!TRANS{"Ok"},!TRANS{"Error"}}
      Pop If
      Goto exit_PED_closeall
    EndIf
    !PED_CursorOn
  EndIf
 
  FlushEvents
  If \activewin > 0
    Activate \activewin
    Use Window \activewin
    If Peek.l(Addr Window(\activewin)) <> 0
      Select \activewin
        Case 3 : WZ_ActivateGadget{"STRING_LABEL"}
        Case 2 : WZ_ActivateGadget{"STRING2"}
        Case 1 : WZ_ActivateGadget{"STRING"}
        Case 4 : WZ_ActivateGadget{"VAL1"}
      End Select
    EndIf
  Else
    Gosub activatesourcewindow
  EndIf
Return



.open_sourcebrowser:
  WZWindow WZID("WIN_LABELS"),?wzgui,255,\click_x,\click_y,\click_w,\click_h,WZID("WIN_LABELS")
  WZ_AddMenuStrip{"WIN_LABELS", ped\menuStrip}

  Use Window WZID("WIN_LABELS")
  LabelList_PreSelectItemNumber = -1                             ;added because we don't know what was the preselectitem  tomsmart1
  WZPrint "rem",Peek.w(?comWord_LabelRemark)
  WZPrint "all",Peek.w(?comWord_LabelAll)
  WZPrint "STRING_LABEL",LabelListSearchString
  WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels,LabelList_FirstVisableItemNumber
  ;Gosub update_versiongadgets
Return


.event_sourcebrowser:
  Select pedMessage\_Class
    Case #IDCMP_INTUITICKS
      ;all activities of the window like mouse move
      ;only need this to auto update the listview by typ in the search string   tomsmart1

      LabelListSearchString = LCase$( WZGetString("STRING_LABEL") )
      If LabelListSearchString <> old_LabelListSearchString
        old_LabelListSearchString = LabelListSearchString
        LabelList_NewSelectItemNumber.l = 0
        Gosub reset_labellist

        Poke$ ?comStr_LabelSearchString ,LabelListSearchString
      End If

    Case #IDCMP_VANILLAKEY:
      If EventCode = #VANILLAKEY_ESC Then Gosub close_sourcebrowser
      If EventCode = #VANILLAKEY_TAB Then Gosub activatesourcewindow

    Case #IDCMP_CLOSEWINDOW
      Gosub close_sourcebrowser

    Case #IDCMP_IDCMPUPDATE
      ;log_Print{"event sourcebrowser: IDCMPUPDATE - " + WZGadName}
      Select LCase$(WZGadName)

        Case "string_label"
          ; no need because event is handled in #IDCMP_INTUITICKS
          ;Gosub activatesourcewindow                            ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1

        Case "listview_labels"
          ; removed code that checked if the last and the new select item
          ; was the same because wizard.lib do it and by overwritable by doublellick  tomsmart1
          LabelList_PreSelectItemNumber = WZListNum("LISTVIEW_LABELS")
          LabelList_FirstVisableItemNumber = WZListPos("LISTVIEW_LABELS")
          Poke.l ?comLong_Label1VisableItem,LabelList_FirstVisableItemNumber
          ;WZPrint "LISTVIEW_LABELS",-1,list_labels,LabelList_FirstVisableItemNumber
          Gosub activatesourcewindow
          Gosub storeline
          lineAddress.l = WZListData (list_labels, WZInput)
          log_Print{"jump to corresponding source line, (address: " + Hex$(lineAddress)+ ") itemnumber:"+ Str$(WZInput)}
          PED_HistoryAddEntry{}
          PED_GotoLineAddress{lineAddress}

        Case "case"
          Poke.w ?comWord_LabelCase,WZInput
          Poke.w ?comWord_LabelRemark,0
          Poke.w ?comWord_LabelAll,0
          WZPrint "rem",0
          WZPrint "all",0
          Gosub reset_labellist
          WZ_ActivateGadget{"STRING_LABEL"}

        Case "rem"
          Poke.w ?comWord_LabelCase,0
          Poke.w ?comWord_LabelRemark,WZInput
          Poke.w ?comWord_LabelAll,0
          WZPrint "case",0
          WZPrint "all",0
          Gosub reset_labellist
          WZ_ActivateGadget{"STRING_LABEL"}

        Case "all"
          Poke.w ?comWord_LabelCase,0
          Poke.w ?comWord_LabelRemark,0
          Poke.w ?comWord_LabelAll,WZInput
          WZPrint "case",0
          WZPrint "rem",0
          Gosub reset_labellist          
          WZ_ActivateGadget{"STRING_LABEL"}

        Case "clr"
          LabelListSearchString = ""
          WZPrint "STRING_LABEL",LabelListSearchString
          Gosub reset_labellist
          WZ_ActivateGadget{"STRING_LABEL"}

        Case "button_update_liblist"
          Gosub scan_source_for_used_libs

        Case "library_list"
          cmd_node.l = WZGetNode(lib_list.List)
          searchcmd.s = WZListString(cmd_node,0)
          klammer.b = Instr(searchcmd,"(")
          If klammer
            used_win.l = Used Window

            casesens_backup.w = ped\caseSensitive       ; store searchmode

            searchcmd.s = Replace$(Left$(searchcmd,klammer-1)," ","")
            ped\caseSensitive = True
            Poke.s ?str_searchstring   ,searchcmd
            If searchcmdStore.s <> searchcmd
              searchcmdStore.s = searchcmd
              PED_GotoLine{0,#LINE_START}
            EndIf
            Gosub storeline
            !PED_CursorOff
            Gosub menu_findnext
            PED_UpdateStatusArea{#STATUS_SCROLLERS}
            !PED_CursorOn

            ped\caseSensitive = casesens_backup          ; restore searchmode

            If (used_win >< -1) Then Use Window used_win
            Gosub activatesourcewindow
          EndIf

      End Select
  End Select
Return

.close_sourcebrowser:
  wtemp\click_x = WindowX
  wtemp\click_y = WindowY
  wtemp\click_w = WindowWidth
  wtemp\click_h = WindowHeight
  WZ_CloseWindowAndRemoveMenu{"WIN_LABELS"}                                                                                                                                                                                                              
Return



.navigate_to_previous_label:
  If WZ_IsOpen{"WIN_LABELS"}
    LabelList_PreSelectItemNumber = LabelList_PreSelectItemNumber-1
    If LabelList_PreSelectItemNumber<0 Then LabelList_PreSelectItemNumber = 0
    LabelList_NewSelectItemNumber = LabelList_PreSelectItemNumber
    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels
    Gosub storeline
    lineAddress.l = WZListData (list_labels,LabelList_NewSelectItemNumber)
    PED_GotoLineAddress{lineAddress}
  End If
Return 

.navigate_to_next_label:
  If WZ_IsOpen{"WIN_LABELS"}
    LabelList_PreSelectItemNumber = LabelList_PreSelectItemNumber+1
    If LabelList_PreSelectItemNumber = >WZListItems (list_labels) Then LabelList_PreSelectItemNumber = WZListItems (list_labels)-1
    LabelList_NewSelectItemNumber = LabelList_PreSelectItemNumber
    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels
    Gosub storeline
    lineAddress.l = WZListData (list_labels,LabelList_NewSelectItemNumber)
    PED_GotoLineAddress{lineAddress}    
  End If
Return

.storeline:
  If ped\ptrCurrentSourceData\KeyBeforeReturn = 0 Then Return
  ped\ptrCurrentSourceData\SourceChanged = $FFFF

  !PED_CursorOff

  ; -- draw selecting block if existing
  ped\ptrCurrentSourceData\StateBlockMark = False
  If ped\ptrCurrentSourceData\BlockEndY >= 0
    log_Print{"storeline, erasing block"}
    displayline.l = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
    If ped\ptrCurrentSourceData\BlockStartY =< displayline
      If ped\ptrCurrentSourceData\BlockEndY => displayline
          bmark\xMin = ped\ptrCurrentSourceData\BlockStartX
          bmark\yMin = ped\ptrCurrentSourceData\BlockStartY
          bmark\xMax = ped\ptrCurrentSourceData\BlockEndX
          bmark\yMax = ped\ptrCurrentSourceData\BlockEndY
          If bmark\yMin = bmark\yMax
            If bmark\xMin = bmark\xMax
              bmark\xMax = sourceWindow\visibleColumns
            EndIf
          EndIf
          AbsDimensions{bmark}
          PED_DrawBlock{bmark}
          ped\ptrCurrentSourceData\StateBlockMark = True
      EndIf
    EndIf
  EndIf

  pasteString.s = Peeks$(Peek.l(?textbufferaddr) + ped\ptrCurrentSourceData\TextBufferOffset,#MAX_Columns)
  newline$ = PED_ParseText{pasteString}
  newline$ = Peek.s(Peek.l(?comPtr_Temp_TokenString1))
  *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
  PED_ReplaceCurrentSourceLine{*newLine}

  If ped\DoTokenize
    PED_PrintCurrentSourceLine{False}

    If ped\ptrCurrentSourceData\StateBlockMark
      log_Print{"storeline: redrawing blockmark"}
      AbsDimensions{bmark}
      PED_DrawBlock{bmark}
    EndIf
  EndIf

  ped\ptrCurrentSourceData\KeyBeforeReturn = 0
Return


;
;.ascii_to_token: ;d0 = token
;  MOVEM.l d1-d7/a0-a6,-(a7)
;  MOVE.l d0,a2                    ; D0: expandstore
;  MOVEA.l comPtr_TokenBase,A3
;
;  JL_0_6036b:
;    MOVEA.l A2,A4
;    MOVE.l A3,-(A7)
;    ADDQ.w #6,A3
;
;    JL_0_603Cb:
;      MOVE.b (A3)+,D3
;      BEQ.w JL_0_6082b     ;found
;        MOVE.b (A4)+,D2
;        ;BCLR #$7,D2
;        ;ORI.b #$20,D3
;        ;ORI.b #$20,D2
;    CMP.b D3,D2
;    BEQ.b JL_0_603Cb
;
;    JL_0_6054b:
;    MOVEA.l (A7)+,A3
;    MOVE.l (A3),D3
;    BEQ.w JL_0_6060b
;      MOVEA.l D3,A3
;  BRA.b JL_0_6036b
;  JL_0_6082b:
;
;  MOVE.b (A4),D2
;  BNE JL_0_6054b
;  BCLR #$7,D2
;  BNE.b JL_0_6054b       ;not found
;  MOVEA.l (A7)+,A3
;  ADDQ.w #4,A3
;  MOVEQ #0,d0
;  MOVE.b (A3)+,d0
;  ASL.l #8,d0
;  MOVE.b (a3),d0
;  MOVEM.l (a7)+,d1-d7/a0-a6
;RTS
;
; JL_0_6060b
;  MOVEQ #0,d0
;  MOVEM.l (a7)+,d1-d7/a0-a6
;RTS
;
.activatesourcewindow                                                         ; changed name to better show it pourpos  tomsmart1
  If sourceWindow\win
     ActivateWindow_ sourceWindow\win                                         ; replaced ASM part with Basic commands  tomsmart1
     Use Window 0                                                             ; added sourcewinid  tomsmart1
  EndIf
Return                                                                        ; replaced RTS with Return  tomsmart1

.check_mouse_in_statusarea:
  If pedMessage\_Code = #SELECTDOWN

    USEPATH sourceWindow                                                                                                                                                                                                                                 
    If ped\firstSourceEntry
      mx.w = pedMessage\_MouseX - \win\BorderLeft
      my.w = pedMessage\_MouseY - \win\BorderTop

      xsa.l = \font\tf_XSize / 2
      xpos_start.w = #leftoffset * \font\tf_XSize - xsa                                                                                                                                                                                                  
      xpos_end.w = 0
      ypos_start.w = \statusAreaY + 1
      ypos_end.w = ypos_start + 2 + \font\tf_Baseline + \font\tf_YSize

      *fileEntry.sourceEntry = ped\firstSourceEntry
      Repeat
        xpos_end = xpos_start + (#bevelsize * \font\tf_XSize)
        ;-- check click position
        If (mx > xpos_start) AND (mx < xpos_end) AND (my > ypos_start) AND (my < ypos_end)
          log_Print{"mouse clicked at tab: " + Peek.s(&*fileEntry\SourceName)}
          If *fileEntry = ped\currentSourceEntry
            log_Print{"tab is actual file"}
            If pedMessage\_Qualifier AND (#IEQUALIFIER_CONTROL|#IEQUALIFIER_LALT|#IEQUALIFIER_RALT)
              log_Print{"control or alt pressed with mouse"}
              If ped\ptrCurrentSourceData\SourceChanged
                Gosub storeline
                Delay_ 2
              EndIf

              ;Gosub set_tedlibbase

              If pedMessage\_Qualifier AND #IEQUALIFIER_CONTROL
                log_Print{"control: create exe"}
                !PED_CursorOff
                _menuitem = #MENU_SAVECREATEEXE
                Gosub call_compilermenuitem
              EndIf
              If pedMessage\_Qualifier AND (#IEQUALIFIER_LALT|#IEQUALIFIER_RALT)
                log_Print{"alt: compile & run"}
                !PED_CursorOff
                _menuitem = #MENU_COMPILERUN
                Gosub call_compilermenuitem
              EndIf
            EndIf
          Else
            log_Print{"tab is not actual file."}
            Gosub storeline

            GetD0 *fileEntry : Gosub selectTab

            Gosub storeCurrentSourceData
          EndIf
          log_Print{"exiting mouse routine"}
          Return
        EndIf
        xpos_start = xpos_end
        *fileEntry = *fileEntry\nextEntry
      Until *fileEntry = 0

    EndIf
  EndIf
Return

; Begin routines for function build_HelpIndexFile  ; moved the functions and statemend defination out of the build index rountine for a better overview  tomsmart1
Function.l ab3_IsTokenChar{char.w}
  If char>=@"a" AND char<=@"z" Then Function Return True
  If char>=@"A" AND char<=@"Z" Then Function Return True
  If char>=@"0" AND char<=@"9" Then Function Return True
  If char=@"_" OR char=@"@" OR char=@"`" Then Function Return True
  Function Return False
End Function


Statement writeentry{destfile.l, mode$,instruction$}
SHARED pedconfig

  ;#TOKEN_Function  = $8009
  ;#TOKEN_Statement = $8008
  ;#TOKEN_Object    = $80d7
  ;#TOKEN_Macro     = $800d
  ;#TOKEN_End       = $8002
  ;#TOKEN_Return    = $8007

  ; -- don't add it if it contains @H
  If Instr(instruction$,"@H") Then Statement Return

  ; -- token return found
  If Instr(instruction$,Mki$(#TOKEN_Return)) Then Statement Return

  ; -- token End found
  If Instr(instruction$,Mki$(#TOKEN_End)) Then Statement Return

  startpos.l = 0
  Select mode$
    Case "FUNC"
      startpos = Instr(instruction$,Mki$(#TOKEN_Function))  + 2
      i3.l = Instr (instruction$,".",startpos)
      If (i3 < startpos+5) AND (i3 <> 0)
        startpos = i3+1                              ; change it to 1 to make the test of spaces possible  tomsmart1

         While Mid$(instruction$,startpos,1)<>" "    ; test if we have no space  so it is still the function type (newtype)  tomsmart1
           startpos + 1
         Wend

      End If
      If Instr(instruction$,"FAST",startpos)
        startpos.l = Instr(instruction$,"FAST",startpos)    + 4
      End If

    Case "STAT"
      startpos = Instr(instruction$,Mki$(#TOKEN_Statement)) + 2
      If Instr(instruction$,"FAST",startpos)
        startpos.l = Instr(instruction$,"FAST",startpos)    + 4
      End If

    Case "MACR"
      startpos = Instr(instruction$,Mki$(#TOKEN_Macro))     + 2

  End Select

  ; -- get string positions --
  instruction$ = dos_Trim{Mid$(instruction$,startpos)}

  endpos.l  =1
  stopchar.l=False
  While endpos<=FLen(instruction$) AND stopchar=False
    If ab3_IsTokenChar{Peek.b(&instruction$+endpos-1)}=False Then stopchar=True:Else endpos+1
  Wend

  ; -- write infos to indexfile
  If endpos <> 0
    funcname$ = Mid$( instruction$ , 1 , endpos - 1)
    ;If Right$(funcname$,1)=";" Then funcname$ = UnLeft$(funcname$,1)
    ;funcname$ = StripLead$(Left$(funcname$,50,32),32)
    funcname$ = StripLead$(funcname$,32)

    If FLen(funcname$) >= 6                                   ; test if functionname leng <= 6  tomsmart1
      If Left$(funcname$,6) = "Return" Then Statement Return  ; yes then test if function or statement RETURN then we have nothing to print back again  tomsmart1
    EndIf

    If mode$ = "MACR" Then funcname$ = "!" + funcname$

    description$ = Mid$(instruction$,endpos)
    description$ = StripLead$(description$,32)
    If Left$(description$,1)=";" Then description$ = UnRight$(description$,1)
    description$ = StripLead$(description$,32)

    If (Left$(funcname$,1) = "_") OR (Left$(funcname$,2) = "!_")             ; test for privat routines  tomsmart
      If pedconfig\HelpForPrivateFunctions = True                                   ; test if we show help for it  tomsmart1
        file_WriteLine{destfile, mode$ + "\\09" + funcname$ + "\\09" + description$ + " ; private!"}     ; show help but indentify private routines tomsmart1
      End If
    Else
      ;NPrint LSet$(mode$,11) + LSet$(funcname$,50) + description$
      file_WriteLine{destfile, mode$ + "\\09" + funcname$ + "\\09" + description$}                      ; public routines
    End If

  End If
End Statement

 

Function.l ab3_InstrToken{code.s,token.s}
  pos.l = Instr(code,token)
  If pos
    If ab3_IsTokenChar{Peek.b(&code+pos-1+FLen(token))} Then pos=0
    If pos>1
      If ab3_IsTokenChar{Peek.b(&code+pos-1-1)} Then pos=0
    End If
  End If
  Function Return pos
End Function



Statement scanfile{rootpath$,filename$, destfile.l}
  functoken$      = Mki$(#TOKEN_Function)
  statementtoken$ = Mki$(#TOKEN_Statement)
  objecttoken$    = Mki$(#TOKEN_Object)
  macrotoken$     = Mki$(#TOKEN_Macro)
  endtoken$       = Mki$(#TOKEN_End)
  returntoken$    = Mki$(#TOKEN_Return)
  tok80.s         = Str$($80)
  fid.l = file_Open{dos_AddPart{rootpath$,filename$},#file_read}
  If dos_GetExt{filename$}="bb2" Then tokenized.l=True : Else tokenized=False

  If fid>=0 ; ReadFile(0,filename$)
    ;file_Cache{fid}
    ;FileInput 0
    ; -- get current path
    ;dir_name$ = SPACE$(512)
    ;GetCurrentDirName_ &dir_name$,FLen(dir_name$)
    ;dir_name$ = StripTrail$(dir_name$,0)
    ;dir_name$ = dos_Trim{dir_name$}
    ;dir_name$ = dos_FilePart{dir_name$}

    ; -- add parent path to filename, if not in includes-drawer
    ;If LCase$(dir_name$)<>"includes" Then filename$ = dos_AddPart{dir_name$,filename$}

    ; -- write filename into indexfile
    file_WriteLine{destfile,"FILE\\09"+filename$}

    Repeat
      ;code.s = ReadLine$
      If tokenized
        code.s = file_ReadBB2Line{fid}
      Else
        code.s = file_ReadLine{fid}
      End If

      maxpos.l = Instr(code,";")
      If maxpos = 0 Then maxpos = FLen(code)-1

      ; in case its ASCII...
      If tokenized=False
        pos.l = ab3_InstrToken{code,"Function"}
        If pos>0 AND pos<maxpos
          ;If Instr(code,"GetObjectBy") Then error{"Found Function in "+filename$+" line:\\n"+code}
          code.s = Left$(code,pos-1) + functoken$ + Right$(code,FLen(code)-pos-8+1)
          If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"Statement"}
        If pos>0 AND pos<maxpos
          code.s = Left$(code,pos-1) + statementtoken$ + Right$(code,FLen(code)-pos-9+1)
          If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"Macro"}
        If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + macrotoken$ + Right$(code,FLen(code)-pos-5+1)
            If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"End "}
        If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + endtoken$ + Right$(code,FLen(code)-pos-3+1)
            If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"Return"}
        If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + returntoken$ + Right$(code,FLen(code)-pos-6+1)
            If pos<maxpos Then maxpos=pos
        End If
      End If
;      If Left$(a$,2) = ";/"
;        NPrint a$
;      Else
        pos = Instr(code,functoken$)
        If pos>0 AND pos<=maxpos Then writeentry{destfile, "FUNC",code}

        pos = Instr(code,statementtoken$)
        If pos>0 AND pos<=maxpos Then writeentry{destfile, "STAT",code}

        pos = Instr(code,macrotoken$)
        If pos>0 AND pos<=maxpos Then writeentry{destfile, "MACR",code}

;       EndIf
    Until file_EOF{fid}
    file_Close{fid}
  Else
    dummy.l = ask{!TRANS{"Can't open file "}+filename$,!TRANS{"Ok"},!TRANS{"Error"}}
  End If
End Statement


.build_HelpIndexFile
  DosBuffLen 32000
  CaseSense On

  log_Print{"****** Building a new HelpIndexFile..."}

  If dos_Exist{pedconfig\includeDir}

    ;-- check if Indexfile is available and delete it
    If dos_Exist{pedconfig\HelpIndexFile} Then dos_Delete{pedconfig\HelpIndexFile}

    ;-- create a new indexfile
    log_Print{"opening help index file: " + pedconfig\HelpIndexFile}
    destfid.l = file_Open{pedconfig\HelpIndexFile, #file_forcewrite}
    If destfid >= 0
      WZ_ShowMessage{!TRANS{"Updating indexfile for onlinehelp..."},0}
      WZ_ChangeTitle{"WIN_PROGRESS",!TRANS{BuildHelpIndexWinTitle$} }  ; use Statement to remove double code tomsmart1 2012 03 09 ; use a variable so the title match the function tomsmart1                                                             


      ClearList HelpIndexCache()

      ; scan for subdirs
      ClearList dirs()
      If AddLast(dirs()) Then dirs()\name = pedconfig\includeDir
      log_Print{"*** scan includedir <" + pedconfig\includeDir + ">"}
      Repeat
        name$ = dos_ScanDir{pedconfig\includeDir,"",#dos_scan_dirs}
        If dos_IsDir{name$}
          If AddLast(dirs()) Then dirs()\name = dos_AddPart{pedconfig\includeDir,name$}
          log_Print{"found subdir <" + name$ + ">"}
        EndIf
      Until name$ = ""

      ; count number of files
      num_files.l = 0
      ResetList dirs()
      While NextItem(dirs())
        dirname$ = dirs()\name                    ; set first subdirectory
        Repeat
          name$ = dos_ScanDir{dirname$,"#?",#dos_scan_files}
          num_files + 1
        Until name$ = ""
      Wend
      log_Print{"counted files: " + Str$(num_files)}


      ; scan files for functions
      ; begin count include files
      subincludedirs.b = False
      exitscan.b       = True
      dirname$         = ""
      act_file.l = 0
      ResetList dirs()
      act_file.l = 0
      While NextItem(dirs())
        dirname$ = dirs()\name                    ; set first subdirectory
        log_Print{"*** scanning dir <" + dirname$ + ">",#log_debug}
        Repeat
          name$ = dos_ScanDir{dirname$,"#?",#dos_scan_files}
          If name$<>""
            log_Print{"scanning file <" + name$ + ">"}
            act_file + 1 : act_file = Min(act_file,num_files)
            ex.s = dos_GetExt{name$}
            If (ex="bb2" OR ex="ab2" OR ex="ab3")
               scanfile{pedconfig\includeDir,name$, destfid}
            EndIf
            !WZ_Update_Gauge{act_file,num_files}
          End If
        Until name$ = ""
      Wend
      ClearList dirs()
      file_Close{destfid}

      WZ_ShowMessage{!TRANS{"Updating Helpindex..."}} : PED_UpdateHelpIndexCache{pedconfig\HelpIndexFile}
      WZ_ShowMessage{!TRANS{"Saving Helpindex to Disc..."}} : PED_WriteHelpIndexCache{pedconfig\HelpIndexCacheFile}
      WZ_ShowMessage{!TRANS{"Creating Hashmaps..."}}
      preproc_QueryTokens{*PreProcessor}
      preproc_SaveTokens{*PreProcessor,TokenHashMapFile}
      WZ_HideMessage{}
    End If
  Else
    dummy.l = ask{!TRANS{"Could not determine Include directory"}+":\\n"+pedconfig\includeDir+"!",!TRANS{"Ok"},!TRANS{"Error"}}
  EndIf

  CaseSense Off
RTS

.event_find:
    ped\caseSensitive = True
    find_findStr.s = WZGetString("FIND_FINDSTRING")
    find_replaceStr.s = WZGetString("FIND_REPLACESTRING")
    find_findStrOld.s    = find_findStr
    find_replaceStrOld.s = find_replaceStr

    If WZInput("FIND_SENSITIVE") = 0
      find_findStr.s = UCase$(find_findStr)
      ped\caseSensitive = False
    EndIf

    Poke.s ?str_searchstring   ,find_findStr
    Poke.s ?str_replacestring  ,find_replaceStr

    Select pedMessage\_Class
      Case #IDCMP_CLOSEWINDOW
        WZ_CloseWindowAndRemoveMenu{"WIN_SEARCH"}                                                                                                                                                                                                        
        Gosub activatesourcewindow
        FlushEvents

      Case #IDCMP_VANILLAKEY
        Select pedMessage\_Code

          Case #VANILLAKEY_RETURN
            ; not enabled anymore, jump to next now via shortcut amiga-N

          Case #VANILLAKEY_ESC
            WZ_CloseWindowAndRemoveMenu{"WIN_SEARCH"}                                                                                                                                                                                                    
            Gosub activatesourcewindow
            FlushEvents
 
        End Select

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName

          Case "FIND_FINDSTRING"
            If UCase$(findStrStore.s) <> UCase$(find_findStr)
              findStrStore = find_findStr
              Gosub storeline
              !PED_CursorOff
              Gosub menu_findnext
              PED_UpdateStatusArea{#STATUS_SCROLLERS}
              !PED_CursorOn
              FlushEvents : Delay_ 1
            End If

          Case "FIND_NEXT"
            Gosub storeline
            !PED_CursorOff
            Gosub menu_findnext
            PED_UpdateStatusArea{#STATUS_SCROLLERS}
            !PED_CursorOn
            Gosub activatesourcewindow                ; added to make source win active that edit is possible  tomsmart1

          Case "FIND_PREVIOUS"
            Gosub storeline
            !PED_CursorOff
            Gosub menu_findprevious
            PED_UpdateStatusArea{#STATUS_SCROLLERS}
            !PED_CursorOn
            Gosub activatesourcewindow

          Case "FIND_REPLACE"
            Gosub storeline
            !PED_CursorOff
            Gosub menu_replace
            !PED_CursorOn
            Gosub activatesourcewindow                ; added to make source win active that edit is possible  tomsmart1

          Case "FIND_REPLACE_ALL"
            If find_findStr <> "" AND find_replaceStr <> ""
              Gosub storeline
              !PED_CursorOff
              Gosub set_pointer_busy
              Gosub menu_replaceall
              Gosub update_currsourceline
              PED_RedrawSource{}
              !PED_CursorOn
              Gosub set_pointer_normal
            EndIf
            Gosub activatesourcewindow                ; added to make source win active that edit is possible  tomsmart1

          Case "FIND_EXIT"
            WZ_CloseWindowAndRemoveMenu{"WIN_SEARCH"}                                                                                                                                                                                                    
            Gosub activatesourcewindow

        End Select

    End Select
Return


;####################################################################
; BEGIN  routines compiler settings window  tomsmart 2012 03 21     #
;####################################################################
.BackupCompilerSettings:
  !asm
  !ComData_JSR{comFunc_BackupXtraData}
  !basic

; get pointer to the settings from the compiler
  !ComData_GetL{comPtr_Residents_Table       ,D0} : Ptr_Residents_Table.l        = PutD0
  !ComData_GetL{comPtr_Number_of_Objects_Word,D0} : Ptr_Number_of_Objects_Word.l = PutD0
  !ComData_GetL{comPtr_StringBuffer_Long     ,D0} : Ptr_Stringbuffer_Long.l      = PutD0
  !ComData_GetL{comPtr_Stacksize_Long        ,D0} : Ptr_Stacksize_Long.l         = PutD0
  !ComData_GetL{comPtr_Create_IconFile_Byte  ,D0} : Ptr_Create_Iconfile_Byte.l   = PutD0
  !ComData_GetL{comPtr_Make_SmallestCode_Byte,D0} : Ptr_Make_Smallestcode_Byte.l = PutD0
  !ComData_GetL{comPtr_Link_DebugInfo_Byte   ,D0} : Ptr_Link_Debuginfo_Byte.l    = PutD0
  !ComData_GetL{comPtr_Use_Debugger_Byte     ,D0} : Ptr_Use_Debugger_Byte.l      = PutD0
  !ComData_GetL{comPtr_Autorun_Byte          ,D0} : Ptr_Autorun_Byte.l           = PutD0
  !ComData_GetL{comPtr_InterruptCheck_Byte   ,D0} : Ptr_Interruptcheck_Byte.l    = PutD0
  !ComData_GetL{comPtr_AssemblerCheck_Byte   ,D0} : Ptr_Assemblercheck_Byte.l    = PutD0
  !ComData_GetL{comPtr_OverflowCheck_Byte    ,D0} : Ptr_Overflowcheck_Byte.l     = PutD0
  !ComData_GetL{comPtr_MaxObjects_Value_Word ,D0} : Ptr_MaxObjects_Value_Word.l  = PutD0
  !ComData_GetL{comPtr_MaxObject_Pos_Word    ,D0} : Ptr_MaxObject_Pos_Word.l     = PutD0

  !ComData_GetW{comWord_CreateDebugFile      ,D0} : comWord_CreateDebugFile_Back.w = PutD0 ; get status of Create.dbg file  tomsmart1
  !ComData_GetB{comByte_FuncOptimize         ,D0} : comByte_FuncOptimize_Back.b    = PutD0 ; get status of Function Optimizer  tomsmart1
  StringbufferValue_Backup.l = Peek.l(Ptr_Stringbuffer_Long)              ;get sringbuffersize  tomsmart1
  StackSizeValue_Backup.l    = Peek.l(Ptr_Stacksize_Long)                 ;get stacksize  tomsmart1
Return

.RestoreCompilerSettings:
  GetD0 comWord_CreateDebugFile_Back : !ComData_SetW{comWord_CreateDebugFile,D0}   ;restore settings that not stored in the xtradata
  GetD0 comByte_FuncOptimize_Back    : !ComData_SetB{comByte_FuncOptimize   ,D0}   ;restore settings
  Poke.l Ptr_Stringbuffer_Long,StringbufferValue_Backup
  Poke.l Ptr_Stacksize_Long   ,StackSizeValue_Backup
  !asm
  !ComData_JSR{comFunc_RestoreXtraData}
  !basic
Return


.menu_compilersettings   ; was .newoptionsfunc

  Gosub BackupCompilerSettings    ; make a Backup of the active settings

  MaxLen a$ = 5000

  If ScreenHeight>400
    com_scr_y.w = ScreenHeight/6
    com_scr_h.w = ScreenHeight/1.5
  Else
    com_scr_y.w = -2
    com_scr_h.w = -2
  End If

  WZWindow WZID("WIN_CPREFS"),?wzgui,256,-2,com_scr_y,-2,com_scr_h,WZID("WIN_CPREFS")
  WZ_SetFont{"WIN_CPREFS"}
  WZ_InitTable{"WIN_CPREFS","OBJECTS",2,0}
  WZ_SetTableColors{"OBJECTS",1,0,2,3,3}

  ; Setzen der Spaltentitel fuer die erste Zeile
  WZ_SetTableTitle{"OBJECTS","Objects","Max"}

  ; Legt die Prioritaet der 6 Spalten fest
  WZ_SetPriority{"OBJECTS",3,1}

  ; Setzt die zweite Spalte der Tabelle "OBJECTS" auf nicht editierbar
  WZ_SetEditable{"OBJECTS",False,True}

  ; Sortieren verboten
  WZ_SetSortable{"OBJECTS",Off}

  ; Fuegt Zeilen an die Tabelle "OBJECTS" an
  For i.l = 0 To Peek.w(Ptr_Number_of_Objects_Word)-1
    a$ = ""
    GetD0 &a$,i
    !ComData_JSR{comFunc_GetObjectEntry}    ;stringaddress in d0 , indexnumber d1
    a.l = PutD0
    WZ_AddRow{"OBJECTS",Peek$(&a$),Str$(a)}
  Next
  WZ_DrawTable{"OBJECTS"}
  ; Fuellt die Tabelle mit den Werten, die mit WZAddRow{} erstellt wurden
  WZ_UpdateTable{"OBJECTS"}

  ;get Residents and convert it to a string
  var.l = Ptr_Residents_Table
  a$ = Peek$(var)              ; get first entry
  For i = 0 To 6               ; get up to 7 entry
    a$ = a$ + "\\0a"           ; added a newline
    var + #ResidentEntryStep   ; update pointer to the next entry
    a$ = a$ + Peek$(var)       ; added next entry
  Next
  WZPrint "RESIDENTS",&a$      ; print string in gadget

  WZPrint "STRINGBUFFER",StringbufferValue_Backup

  WZPrint "STACKSIZE",StackSizeValue_Backup                       ;print it  tomsmart1

; get and set status of the checkmarks
  If Peek.b(Ptr_Create_Iconfile_Byte)=-128
    WZPrint "ICON",1
  Else
    WZPrint "ICON",0
  EndIf

  If Peek.b(Ptr_Make_Smallestcode_Byte)=-128
    WZPrint "SMALLEST",1
    WZDisable "FUNCOPTIMIZE"                           ; added to prevent senceless settings  and possible endless compile runs tomsmart1
  Else
    WZPrint "SMALLEST",0
    WZEnable "FUNCOPTIMIZE"                            ; added  tomsmart1
  EndIf

  If Peek.b(Ptr_Link_Debuginfo_Byte)=-128
    WZPrint "DEBUGINFO",1
  Else
    WZPrint "DEBUGINFO",0
  EndIf

  WZPrint "FUNCOPTIMIZE",comByte_FuncOptimize_Back     ; show status in the GUI tomsmart1
  If comByte_FuncOptimize_Back = 0                     ; added to prevent endless compile runs  tomsmart1
    WZDisable "SMALLEST"
  Else
    WZEnable "SMALLEST"                                ; added  tomsmart1
  EndIf

  WZPrint "DBGFILE",comWord_CreateDebugFile_Back       ; show status in the GUI tomsmart1


  ;runtime Debugging
  If Peek.b(Ptr_Use_Debugger_Byte)=-128
    WZPrint "DEBUG",1
    WZEnable "AUTORUN"                                   ; enable all Debugger settings  tomsmart1
    WZEnable "CHECK_INTERRUPT"                           ;               "
    WZEnable "CHECK_ASSEMBLER"                           ;               "
    WZEnable "CHECK_OVERFLOW"                            ;               "
  Else
    WZPrint "DEBUG",0
    WZDisable "AUTORUN"                                  ; disable all Debugger settings  tomsmart1
    WZDisable "CHECK_INTERRUPT"                          ;                "
    WZDisable "CHECK_ASSEMBLER"                          ;                "
    WZDisable "CHECK_OVERFLOW"                           ;                "
  EndIf

  If Peek.b(Ptr_Autorun_Byte)=-128
    WZPrint "AUTORUN",1
  Else
    WZPrint "AUTORUN",0
  EndIf

  If Peek.b(Ptr_Interruptcheck_Byte)=-128
    WZPrint "CHECK_INTERRUPT",1
  Else
    WZPrint "CHECK_INTERRUPT",0
  EndIf

  If Peek.b(Ptr_Assemblercheck_Byte)=-128
    WZPrint "CHECK_ASSEMBLER",1
  Else
    WZPrint "CHECK_ASSEMBLER",0
  EndIf

  If Peek.b(Ptr_Overflowcheck_Byte)=-128
    WZPrint "CHECK_OVERFLOW",1
  Else
    WZPrint "CHECK_OVERFLOW",0
  EndIf


  ;Event handling of the compiler settings window
  CompilerSettingsWin_Exit.l  = False

  Repeat  ;new

    comsettings_ev.l = WaitEvent


    If pedconfig\onlinehelp <> 0
      If (comsettings_ev <> #IDCMP_INTUITICKS) AND (comsettings_ev <> #IDCMP_ACTIVEWINDOW) AND (comsettings_ev <> #IDCMP_GADGETHELP) AND (comsettings_ev <> #IDCMP_CHANGEWINDOW)
        WZ_HideHelp{}
      EndIf
      If comsettings_ev = #IDCMP_GADGETHELP Then WZ_ShowHelp{}
    EndIf


    WZ_CheckTableEvent{comsettings_ev} ; handle events of the objecttable

    Select comsettings_ev  ; handle events of the rest of the window

       Case #IDCMP_CLOSEWINDOW
         CompilerSettingsWin_Exit = True
         Gosub RestoreCompilerSettings

       Case #IDCMP_VANILLAKEY
         If EventCode = #VANILLAKEY_ESC
           CompilerSettingsWin_Exit = True
           Gosub RestoreCompilerSettings
         EndIf

       Case #IDCMP_IDCMPUPDATE
         Select LCase$(WZGadName)

           Case "autorun"
             If WZInput
               Poke.b Ptr_Autorun_Byte,-128
             Else
               Poke.b Ptr_Autorun_Byte,0
             End If

           Case "check_interrupt"
             If WZInput
               Poke.b Ptr_Interruptcheck_Byte,-128
             Else
               Poke.b Ptr_Interruptcheck_Byte,0
             End If

           Case "check_assembler"
             If WZInput
               Poke.b Ptr_Assemblercheck_Byte,-128
             Else
               Poke.b Ptr_Assemblercheck_Byte,0
             End If

           Case "check_overflow"
             If WZInput
               Poke.b Ptr_Overflowcheck_Byte,-128
             Else
               Poke.b Ptr_Overflowcheck_Byte,0
             End If
 
           Case "residents"

           Case "stacksize"                                   ; stacksize changed  tomsmart1
             tempsize.l=WZInput                               ; save the valu to a temporay variable  tomsmart1
             If tempsize >= #MIN_STACKSIZE                    ; check size  tomsmart1
               Poke.l Ptr_Stacksize_Long,tempsize                     ; save it.  tomsmart1
             Else                                             ; its not big enough  tomsmart1
               tempsize = #MIN_STACKSIZE                      ; set it to the min size  tomsmart1
               Poke.l Ptr_Stacksize_Long,tempsize                     ; save it  tomsmart1
               WZPrint "STACKSIZE",tempsize                   ; print it  tomsmart1
             EndIf

           Case "stringbuffer"
             Poke.l Ptr_Stringbuffer_Long,WZInput

           Case "debug"
             If WZInput
               Poke.b Ptr_Use_Debugger_Byte,-128                           ; yes runtime Debugging
               WZEnable "AUTORUN"                             ; enable all Debugger settings  tomsmart1
               WZEnable "CHECK_INTERRUPT"                     ;               "
               WZEnable "CHECK_ASSEMBLER"                     ;               "
               WZEnable "CHECK_OVERFLOW"                      ;               "
             Else
               Poke.b Ptr_Use_Debugger_Byte,0                           ; no runtime Debugging
               WZDisable "AUTORUN"                            ; disable all Debugger settings  tomsmart1
               WZDisable "CHECK_INTERRUPT"                    ;                "
               WZDisable "CHECK_ASSEMBLER"                    ;                "
               WZDisable "CHECK_OVERFLOW"                     ;                "
             End If

           Case "icon"
             If WZInput
               Poke.b Ptr_Create_Iconfile_Byte,-128
             Else
               Poke.b Ptr_Create_Iconfile_Byte,0
             End If

           Case "smallest"
             If WZInput
               Poke.b Ptr_Make_Smallestcode_Byte,-128
               WZDisable "FUNCOPTIMIZE"
             Else
               Poke.b Ptr_Make_Smallestcode_Byte,0
               WZEnable "FUNCOPTIMIZE"
             End If

           Case "debuginfo"                                      ; check "Create Debug info" (Symbols)
             If WZInput
               Poke.b Ptr_Link_Debuginfo_Byte,-128
             Else
               Poke.b Ptr_Link_Debuginfo_Byte,0
             End If

           Case "funcoptimize"                                   ; check "Use Function Optimizer"   tomsmart1
             If WZInput
               !ComData_SetB{comByte_FuncOptimize,#1}            ; yes we use it  tomsmart1
               WZEnable "SMALLEST"
             Else
               !ComData_SetB{comByte_FuncOptimize,#0}            ; no we don't  tomsmart1
               WZDisable "SMALLEST"
             EndIf

           Case "dbgfile"                                        ; check "Create .dbg File"   tomsmart1
             If WZInput
               !ComData_SetW{comWord_CreateDebugFile,#1}         ; yes we create it  tomsmart1
             Else
               !ComData_SetW{comWord_CreateDebugFile,#0}         ; no we don't  tomsmart1
             EndIf

          ;check main window buttons
           Case "cancel"
            CompilerSettingsWin_Exit = True
            Gosub RestoreCompilerSettings


           Case "ok"
            CompilerSettingsWin_Exit = True
            Gosub UseMaxObjectsAndResidentsSettings

         End Select

    End Select

  Until CompilerSettingsWin_Exit

  WZ_KillTable{"OBJECTS"}
  WZCloseWindow WZID("WIN_CPREFS")
  FlushEvents
  Gosub activatesourcewindow
Return


.UseMaxObjectsAndResidentsSettings:
  ; update save max objects settings  tomsmart1 2012 03 21
  For i.l = 1 To Peek.w(Ptr_Number_of_Objects_Word)
    a$ = WZ_GetCell{"OBJECTS",i,2}
    i2.l = Vallong(a$) : If i2 = 0 Then i2 = 1
    Poke.w Ptr_MaxObjects_Value_Word,i2
    Poke.w Ptr_MaxObject_Pos_Word   ,i-1
    !ComData_JSR{comFunc_StoreMaxObjects}
  Next

  ; the compiler have to free all loaded residents and to clear the space for safty  tomsmart1 2012 06 09
  !asm
  !ComData_JSR{comFunc_FreeClearResidentsForPED}
  !basic

  ; convert strings to Residents entrys  tomsmart1 2012 03 21
  i.l = WZInput("RESIDENTS")
  a$ = Peek$(i)
  InitArgParse a$
  var.l = Ptr_Residents_Table
  For i = 0 To 7
    p$ = NextArgChar$ ($a)
    Poke$ var,p$
    var + #ResidentEntryStep
  Next

  ; the compiler have to reload the residents   tomsmart1 2012 03 21
  !asm
  !ComData_JSR{comFunc_ReloadResidentsForPED}
  !basic
Return
;####################################################################
; END routines compiler settings window  tomsmart 2012 03 21       #
;####################################################################


;######################################################################
;# BEGIN        routines for the compile status Window                #
;#                                                                    #
;#   moved form the compiler to Ped and modified by tomsmart 20120224 #
;######################################################################
.Open_CompileStatus_Window:                                             ; open the compile status window
  Select CompileMenuCallID

    Case #MENU_RUN              ; we don't need to open the window
    Case #MENU_CREATEDEBUGCODE  ;   "
    Case #MENU_RELOAD_USERLIBS  ;   "

    Default
     If CompileStatusWindow_Pointer.l = 0
       WZWindow WZID("WIN_COMPILESTATUS"),?wzgui,64,-2,-2,-2,-2,WZID("WIN_COMPILESTATUS") ; try to open the wizard window
       CompileStatusWindow_Pointer = Peek.l(Addr Window(WZID("WIN_COMPILESTATUS")))       ; get and store the pointer to window
       ;set init data for the update of the status gadgets
       CompileStatus_String_Pointer.l            = Peek.l(?comPtr_CompileStatusString)    ; get the pointer of status string set by the compiler
       CompileStatus_CalculatedProcent_Pointer.l = Peek.l(?comPtr_CompileCalcProLong)     ; get the pointer of calculated procent value set by the compiler
       CompileStatus_String_Old.s                = ""                            ; set to default
       CompileStatus_CalculatedProcent.l         = 0                             ; set to default
       CompileStatus_CalculatedProcent_Old.l     = 0                             ; set to default
       CompileStatus_GaugeString.s               = "0%%"                         ; set to default
       CompileStatusWindow_Event.l               = 0

       ;set init data for the abort handling
       Poke.b ?comByte_CompileStatusAbortByte,0                                ; set default
       CompileStatusWindow_Abort.l = False                                     ; abort status default for the event loop

       ;print initstring
       If CompileStatusWindow_Pointer <> 0                                     ; check if window is open
         CompileStatus_String_Old = !TRANS{"Initializing Compiler..."}         ; set the init string
         WZPrint "COMPILE_INFO",CompileStatus_String_Old                       ; show the init string
       EndIf

     EndIf

  End Select
Return



;######################################################################
;# END          routines for the compile status Window                #
;######################################################################
.com_updateCompileWindow:                                             ; update the compile status window
  !regs2stack
  !basic
  If CompileStatusWindow_Pointer <> 0                                     ; check if window is open
    CompileStatusWindow_Event = Event                                     ; get the event
    ;update gadgets if needed
    CompileStatus_String_Pointer = Peek.l(?comPtr_CompileStatusString)
    If CompileStatus_String_Pointer <> 0                                  ; check if pointer is set
      If (CompileStatus_String_Old <> Peek.s(CompileStatus_String_Pointer)) ; check is status sting changed => Print it
        CompileStatus_String_Old = Peek.s(CompileStatus_String_Pointer)
        WZPrint "COMPILE_INFO",CompileStatus_String_Pointer
      End If
    EndIf

    CompileStatus_CalculatedProcent_Pointer = Peek.l(?comPtr_CompileCalcProLong)  ; get the pointer of calculated procent value set by the compiler
    If (CompileStatus_CalculatedProcent_Pointer <> 0)                     ; check if pointer is set
       CompileStatus_CalculatedProcent = Peek.l(CompileStatus_CalculatedProcent_Pointer)  ; get the value
      If (CompileStatus_CalculatedProcent >< CompileStatus_CalculatedProcent_Old) ; check if procent value changed => update gauge
         CompileStatus_CalculatedProcent_Old = CompileStatus_CalculatedProcent
         If (((CompileStatus_CalculatedProcent & $3)=0) OR (CompileStatus_CalculatedProcent=100))
            CompileStatus_GaugeString = Str$(CompileStatus_CalculatedProcent)+"%%"
            WZPrint "COMPILE_GAUGE",CompileStatus_CalculatedProcent,100,&CompileStatus_GaugeString
         End If
      End If
    EndIf
   ;test abort button (instead of a separte routine)

    While (CompileStatusWindow_Event <> 0)
      If CompileStatusWindow_Event = #IDCMP_VANILLAKEY
        Poke.b ?comByte_CompileStatusAbortByte,1
      EndIf
      If ( (CompileStatusWindow_Event = #IDCMP_IDCMPUPDATE) AND (CompileStatusWindow_Abort = False) ) ; go if a event happend and the button are not allready pressed
        If WZGadName = "COMPILE_ABORT"                                  ; check if "Abort" gadget is pressed
           Poke.b ?comByte_CompileStatusAbortByte,1                     ; set abort condition
           CompileStatusWindow_Abort = True                             ; set abort condition so the event checking can skiped if a next window update is happend befor the abort is handeled by the compiler
        EndIf
      EndIf
      CompileStatusWindow_Event = Event                                 ; get next event
    Wend
    FlushEvents
  EndIf

  PED_UpdateStatusArea{#STATUS_MEMORY}                                                                                                                                                                                                                   

  !asm
  !stack2regs
RTS


.Close_CompileStatus_Window:                                            ; close the compile status window
  If CompileStatusWindow_Pointer <> 0
    WZCloseWindow WZID("WIN_COMPILESTATUS")                             ;turn off the requester
    CompileStatusWindow_Pointer             = 0                         ;set pointer to 0 because we close the window
    CompileStatus_String_Pointer            = 0
    CompileStatus_CalculatedProcent_Pointer = 0                         ;set pointer to 0 because we close the window
  EndIf
Return

; ---------------------------------------------------------------------
; Declarations of Variables
; ---------------------------------------------------------------------
.DECLARATIONS
wzgui:                IncBin "ped.wizard"

.classiccommands
                      ; memory reservations for libs that where introduced with old blitz2
                      ; here come whole libs
                      Dc.w 11    ; Ricopperfxlib.obj
                      Dc.w 45    ; Risoundlib.obj
                      Dc.w 56    ; Xbciatrackerlib.obj
                      Dc.w 60    ; EML (enhanced music library)
                      Dc.w 65    ; rigfxlib
                      Dc.w 82    ; medlib
                      Dc.w 96    ; trackerlib
                      Dc.w 98    ; blitzkeyslib
                      Dc.w 112   ; spriteslib
                      Dc.w 113   ; cd32lib
                      Dc.w 116   ; audiolib
                      Dc.w 117   ; blitzoslib
                      Dc.w 119   ; 2dlib
                      Dc.w 143   ; displaylib
                      Dc.w 144   ; blitzcoplib
                      Dc.w 146   ; bblitlib
                      Dc.w 148   ; qblitlib
                      Dc.w 150   ; blitlib
                      Dc.w 152   ; freqlib
                      Dc.w 156   ; palettelib
                      Dc.w 190   ; gameiolib
                      Dc.w 204   ; bfbplaymaster.library1
                      Dc.w 209   ; thxplay.library1

                      Dc.w 0     ;say end
                                 ;set breakpoint
                      Dc.w $3385 ;timer commands here come single commands
                      Dc.w $2588 ;timer
                      Dc.w $1784 ;timer
                      Dc.w $4d08 ;get a shape

                      Dc.w 0     ;say end

BSS
Even
textbufferaddr:       Dc.l 0
convert               Dc.b 0        ; > import_start
tempbuf               Ds.b 260      ; > import_start
instring              Dc.b 0        ; > import_start
instring2             Dc.b 0        ; > parse_line
noDetokenizing:       Ds.w 1
instru                Ds.w 1
chartab               Ds.b 260 
comLong_Label1VisableItem: Dc.l 0

