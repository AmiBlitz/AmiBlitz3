; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Development:AmiBlitz3/System"
; ExeFile         = "PED"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 64000
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 3.9.9
; NumberOfBuilds  = 2655
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8192
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 5838
; CursorColumn    = 1
; LabelSearch     = "actualsource"
; LabelRemark     = 0
; LabelAll        = 1
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 25
; Max GadgetList  = 5
; Max Shape       = 100
; Max Bank        = 5
; Max MenuList    = 5
; Max GTList      = 25
; Max Palette     = 4
; Max BitMap      = 1
; Max Screen      = 5
; Max IntuiFont   = 5
; Max BlitzFont   = 4
; Max Window      = 25
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/ Name: PED                                                                   /
;/                                                                             /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, AmigaOS4, MOS                         /
;/                                                                             /
;/ Date: 01.07.2022                                                            /
;/                                                                             /
;/ Authors: 1990...1996 Mark Silby                                             /
;/          1991...2003 Red When Excited                                       /
;/          2003...2009 Bernd Roesch, Sven Droege                              /
;/          2009...     The Opensource Team                                    /
;/          2019...     Sven Droege                                            /
;/                                                                             /
;/ Requirements: AmigaOS 2.05+                                                 /
;/                                                                             /
;/ Purpose:                                                                    /
;/ GUI for AmiBlitz3 programming language.                                     /
;/                                                                             /
;/ Abstract:                                                                   /
;/ This is not a stand alone program. It is launched by the AmiBlitz3 compiler./
;/ See AmiBlitz3 abstract.                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
DEBUG
; -------------------------------------------------------
; KONSTANTENDEFINITIONEN
; -------------------------------------------------------
.CONST
#USE_AREXX           = 1     ; include the arrexport?
#hardfold            = 0     ; not working
#filenamepos         = 1     ; startpos of fileclocknames, was 27 honitos 20191123
#filenameoffs        = 11    ; space betweeen filenames

#maxlabels           = 512
#maxhistory          = 4*8
#MAX_SOURCEFILES     = 16

#USE_WIZARD          = 1     ; use wizard library
#WZ_USE_IMAGES       = 0     ; use pictures in tables
#WZ_singletable      = 1     ; only on table at the same time
#Max_WZWindows       = 22    ; max of WZ windows (IDs) needed for the functions to (un)lock all WZ windows, at the moment IDs 1-22 are used ( 0 = source window)  tomsmart1

#slowdown            = 0     ; reduce scrolling speed (for very fast machines)

; OS Version to enable/disable various features
#AmigaOS3 = 1
#AmigaOS4 = 2
#MorphOS  = 3
#AROS     = 4

; for slider gadgets
#GID_XPROP  =900
#GID_YPROP  =901
#GID_RARROW =910
#GID_LARROW =911
#GID_UARROW =912
#GID_DARROW =913
#max_slider_res = $7FFF

; PED Errors
#PEDERROR_NOERROR        = $0000
#PEDERROR_OPENSCREEN     = $1001
#PEDERROR_OPENPUBSCREEN  = $1002
#PEDERROR_OPENWINDOW     = $1011

; Tokens IDs
#TOKEN_End       = $8002
#TOKEN_Return    = $8007
#TOKEN_Statement = $8008
#TOKEN_Function  = $8009
#TOKEN_If        = $800B
#TOKEN_While     = $800C
#TOKEN_Macro     = $800D
#TOKEN_Select    = $800E
#TOKEN_Case      = $800F
#TOKEN_For       = $8016
#TOKEN_Then      = $8021
#TOKEN_Stop      = $802D
#TOKEN_TRAP      = $80AE
#TOKEN_Repeat    = $80BB
#TOKEN_EndIf     = $80C0
#TOKEN_Object    = $80D7

; scrolling options for sourceWindow
#SCROLL_UP       = 1
#SCROLL_DOWN     = -1
#SCROLL_LEFT     = 1
#SCROLL_RIGHT    = -1
#SCROLL_CURRENT_LINE = 1

;Keycodes
;Raw
#RAWKEY_TAB        = $42
#RAWKEY_RETURN     = $44
#RAWKEY_ESC        = $45
#RAWKEY_UP         = $4C
#RAWKEY_DOWN       = $4D
#RAWKEY_RIGHT      = $4E
#RAWKEY_LEFT       = $4F
#RAWKEY_F1         = $50
#RAWKEY_F10        = $59
#RAWKEY_HELP       = $5F

; Vanilla
#VANILLAKEY_BACKSPACE = $08
#VANILLAKEY_TAB    = $09
#VANILLAKEY_RETURN = $0D
#VANILLAKEY_ESC    = $1B
#VANILLAKEY_UP     = $1C
#VANILLAKEY_DOWN   = $1D
#VANILLAKEY_RIGHT  = $1E
#VANILLAKEY_LEFT   = $1F
#VANILLAKEY_DELETE = $7F
#VANILLAKEY_F1     = $81
#VANILLAKEY_F2     = $82
#VANILLAKEY_F3     = $83
#VANILLAKEY_F4     = $84
#VANILLAKEY_F5     = $85
#VANILLAKEY_F6     = $86
#VANILLAKEY_F7     = $87
#VANILLAKEY_F8     = $88
#VANILLAKEY_F9     = $89
#VANILLAKEY_F10    = $8A
#VANILLAKEY_HELP   = $8B


;/* Project */
#MENU_PROJECTSETTINGS     = $00000132
#MENU_IDEPREFERENCES      = $00000073
#MENU_AUTOLAYOUT          = $00000075
#MENU_GETLAYOUT1          = $00000171
#MENU_GETLAYOUT2          = $00000172
#MENU_GETLAYOUT3          = $00000173
#MENU_SETLAYOUT1          = $00000174
#MENU_SETLAYOUT2          = $00000175
#MENU_SETLAYOUT3          = $00000176
#MENU_CUSTOMEDIT          = $00000259
#MENU_OPENWORKBENCH       = $0000006F
#MENU_CLOSEWORKBENCH      = $00000070
#MENU_OPENSHELL           = $00000072
#MENU_CALCULATOR          = $00000057
#MENU_ABOUT               = $00000074
#MENU_ICONIFY             = $00000071
#MENU_QUIT                = $0000006D

;/* Source */
#MENU_NEW                 = $00000065
#MENU_OPEN                = $00000067
#MENU_OPENNEW             = $00000066
#MENU_INCLUDEFILE         = $00000068
#MENU_SAVE                = $00000069
#MENU_SAVEAS              = $0000006A
#MENU_EXPORTASCII         = $0000006B
#MENU_PRINT               = $0000006E
#MENU_CLOSE               = $0000006C

#MENU_LASTSOURCE1         = $00000078
#MENU_LASTSOURCE2         = $00000079
#MENU_LASTSOURCE3         = $0000007A
#MENU_LASTSOURCE4         = $0000007B
#MENU_LASTSOURCE5         = $0000007C
#MENU_TEMPLATE            = $00000200

;/* Edit */
#MENU_CUT                 = $000000C9
#MENU_COPY                = $000000CA
#MENU_PASTE               = $000000CB
#MENU_DUPLICATE           = $000000D8
#MENU_FORGET              = $000000CC
#MENU_KILL                = $000000D7
#MENU_SAVEBLOCKAS         = $000000CD
#MENU_INSERTLINE          = $000000CE
#MENU_DELETELINE          = $000000CF
#MENU_UNDELETELINE        = $000000D0
#MENU_JOINLINES           = $000000D1
#MENU_DELETETOEOL         = $000000D9
#MENU_BLOCKTAB            = $000000D2
#MENU_BLOCKUNTAB          = $000000D3
#MENU_BLOCKCOMMENT        = $000000D4
#MENU_BLOCKUNCOMMENT      = $000000D5
#MENU_MARKINDENT          = $000000D6
#MENU_INSERTFILENAME      = $00001000
#MENU_OPENFILEUNDERCURSOR = $00001001

;/* Naviagation */
#MENU_OPENFIND            = $00000191
#MENU_FIND                = $00000192
#MENU_PREVIOUS            = $00000193
#MENU_REPLACE             = $00000194
#MENU_TOP                 = $0000012D
#MENU_BOTTOM              = $0000012E
#MENU_GOTOLINE            = $0000012F
#MENU_PREVPAGE            = $00000130
#MENU_NEXTPAGE            = $00000131

;/* Compiler */
#MENU_COMPILERUN          = $00000050
#MENU_SAVECOMPILERUN      = $0000005C
#MENU_RUN                 = $00000051
#MENU_CREATEEXE           = $00000052
#MENU_SAVECREATEEXE       = $0000005B
#MENU_CREATERELEASEEXE    = $0000005E
#MENU_CREATERESIDENT      = $00000054
#MENU_SETCLIARGS          = $00000056
#MENU_RELOAD_USERLIBS     = $00000058
#MENU_COMPILERSETTINGS    = $00000053
#MENU_CREATEDEBUGCODE     = $0000005D

;/* Help */
#MENU_WHATSNEW            = $000001F0
#MENU_GENERALGUIDE        = $000001F1
#MENU_PROGRAMGUIDE        = $000001F2
#MENU_INCLUDEGUIDE        = $000001F4
#MENU_BLITZLIBSGUIDE      = $000001F3
#MENU_SHORTCUTREFERENCE   = $000001F6
#MENU_INSTRUCTIONBROWSER  = $000001F5
#MENU_SOURCEBROWSER       = $00000059
#MENU_DEFINITIONBROWSER   = $00000055
#MENU_LIBRARYBROWSER      = $000001F7
#MENU_UPDATEHELPINDEX     = $000001F8

;/* Custom */
#MENU_CUSTOMITEM1         = $00000260      ; must be greater than #MENU_CUSTOMEDIT because hat now its own ID  tomsmart1



;---------------







;@@1
!initasm
!basic
OPTIMIZE 5
SYNTAX 6
; ---------------------------------------------------- ADD INCLUDEFILES
; ------------------------------------------------------
#use_bbscreen      = 0     ; workaround for screen_close crash   (->screeen.include)
#USE_WBSTARTUPMSG  = 0
#CLIARGMODE        = 0     ; OS-Calls
#MAX_MENUTEMPLATES = 16    ; max custom menuentries

XINCLUDE "/BlitzLibs/Residents/libnums.ab3"
XINCLUDE "/Shared/library_offsets.ab3"      ; only for Macro newalloc
XINCLUDE "/Shared/common.ab3"
XINCLUDE "/Shared/preprocessor.include.ab3"
DEFTYPE.tokendata tokeninfo          ; moved to the Newtype definion  tomsmart1 2012 06 18

XINCLUDE "v43+.definitions.ab3"                       ; for MouseWheel support  tomsmart1
XINCLUDE "dos.include.ab3"
XINCLUDE "file.include.ab3"
XINCLUDE "asl.include.ab3"
XINCLUDE "clipboard2.include.ab3"
XINCLUDE "translation.include.ab3"
XINCLUDE "vvblank.include.ab3"

; --------------------------------------------------- Wizard-Extensions
OPTIMIZE 5 : SYNTAX 6
XINCLUDE "PE/wizard_Tools.include.ab3"
XINCLUDE "PE/wizard_Table.include.ab3"
XINCLUDE "PE/wizard_ColorWheel.include.ab3"
ColorWheelError.b = False

; --------------------------------------------------- LOGGING
.LOGGING
XINCLUDE "logging.include.ab3"
log_SetLevel{#log_nothing}
log_SetDestination{#log_toconsole,"System/PED.log"}
log_Print{"===================================================================",#log_debug}
!log_AvailMem{"BEGIN"}


; --------------------------------------------------- AREXX
CNIF #USE_AREXX = 1
XINCLUDE "arexx.include.ab3"
Dim registeredArexxHosts$(8)
CEND


; --------------------------------------------------- TYPE DEFINITIONS
.TYPES
DEFTYPE.l quicktype
DEFTYPE.l


Macro PED_CheckUnAllowedChar
  Peek.b(?chartab + `1)
End Macro

Macro mul48f
  _floattemp.f = (`1)
  _floattemp = _floattemp * (`2)
  _floattemp = _floattemp / (`3)
  `4 = Int(_floattemp + .5)
End Macro


NEWTYPE.readcache
  *fib.FileInfoBlock

  filehandle.l
  filelen.l

  bufferptr.l       ; pointer to memarea allocated for cache
  bufferoffset.l    ; current read byte in buffer

  cacheptr.l
  cachelen.l
  offset.l
  currentbyte.b

  readlen.l
  chunklen.l
  blocklen.l

  *cH.clipboardHandle
  cb_linecount.l
  cb_eol.b

  mode.b           ; PasteMode: File or Clipboard
  moreBytes.b
End NEWTYPE
DEFTYPE.readcache readcache



NEWTYPE.pedconfig
  no_welcome.b
  ask_before_quit.b
  load_last_source.b
  remember_saved.b

  no_display_beep.b
  use_pubscreen.b
  use_wbscreen.b
  use_default_pubscreen.b
  use_wbfont.b
  clone_wbscreen.b

  auto_indent.b
  auto_format.b
  auto_constructs.b
  correct_functions.b
  use_source_icon.b
  use_commandsintellisens.b
  intellisense.b
  localization.b
  onlinehelp.b
  onlinehelp_extended.b
  onlinehelp_includes.b
  HelpForPrivateFunctions.b

  smart_tokenization.b
  highlighting.b

  linenumbers.b
  cursorStyle.b
  blinkrate.b
  italic_remarks.b
  bold_tokens.b
  tab_size.w

  autolayout.b
  al_leftspace.w
  al_topspace.w
  al_rightspace.w
  al_bottomspace.w

  scroll_rate.b
  wheelStep.l

  console_device.s
  console_title.s
  console_font.s
  console_wb.b
  console_wait.b

  screen_modeID.l
  screen_Height.l
  screen_Width.l
  screen_Depth.l

  use_filepattern.b
  asl_use_dims.b
  asl_x.w          ; asl-requester dims
  asl_y.w
  asl_w.w
  asl_h.w

  sort_labels.b

  rememberFile.s
  lastSourceFile.s
  menuFile.s
  winprefsFile.s

  HelpIndexFile.s
  HelpIndexCacheFile.s

  mainDir.s
  systemDir.s
  blitzlibDir.s
  includeDir.s
  autodocDir.s
  helpDir.s
  sourceDir.s

  useBaseLib.b
  useUtilLib.b
  useOsLib.b
  useCsLib.b

  baselibFile.s
  utillibFile.s
  oslibFile.s
  cslibFile.s

End NEWTYPE
DEFTYPE.pedconfig pedconfig

NEWTYPE.ped
  currentDir.s
  currentFile.s
  filePattern.s
  sourceFileComplete.s
  amiblitzmode.b

  check_existsfile.b
  extention_info.s
  extention_xtra.s
  extention_bak.s

  *firstSourceEntry.sourceEntry
  *currentSourceEntry.sourceEntry
  *firstLoadedEntry.sourceEntry

  *ptrCurrentSourceData.sourceEntry       ; needed as long as comPtr_CurrentSourceLine ist converted

  sourceFileHandle.l
  convert.b
;  flag_tokenization.w
  DoTokenize.w
  amigaguide.b
  debugmode.b

  caseSensitive.b

  lastAutoLayout.b
  lastLayout.b
  newtype_mode.b

  baselibFileSize.l
  baselibFileDate.s
  utillibFileSize.l
  utillibFileDate.s
  oslibFileSize.l
  oslibFileDate.s
  cslibFileSize.l
  cslibFileDate.s

  pubScreenNumber.s
  pubscreenName.s
  defaultPubscreenName.s
  defaultScreenTitle.s

  errorCode.w

  mempool.l
  LabelIdentifier.b
  LabelListChanged.w

  verticalCopyMode.b
  verticalPasteMode.b
  pasteMode.b
  cutMode.b
  blockmarkRemovalMode.b

  undeleteStrLen.w
  no_scrollrate.b
End NEWTYPE
DEFTYPE.ped ped

ped\LabelIdentifier = Peek.b(?comByte_LabelIdentifier)
ped\check_existsfile = False
ped\extention_info = ".info"
ped\extention_xtra = ".xtra"
ped\extention_bak = ".bak"
ped\filePattern = "(#?.bb|#?.bb2|#?.asm|#?.ab2|#?.ab3|#?.txt|#?.guide)"
 
NEWTYPE.sourceWindow
  *pedScreen.Screen
  *win.Window
  *rp.RastPort

  *font.TextFont
  *fontI.TextFont
  *fontB.TextFont

  redrawFlag.b
  deleteMode.b

  statusAreaY.w
  visibleLines.w
  visibleColumns.w
  currentLine.l
  currentColumn.w

  boundLinesX.w
  boundLinesY.w
  scrollSize.w

  WinLeft.w                      ; store window dimensions
  WinTop.w
  WinWidth.w
  WinHeight.w

  BoxLeft.w
  BoxTop.w
  BoxWidth.w
  BoxHeight.w

  cursorState.b
  ColumnsOffset.w
  ColumnsOffsetTmp.w
  ColumnsOffsetStore.w
  Column.w
  DisplayLine.l

  clearEndOfLine.b

  lastEditedLine.l
  bookmarkLine1.l
  bookmarkLine2.l
  bookmarkLine3.l

  Title.s
End NEWTYPE
DEFTYPE.sourceWindow sourceWindow
DEFTYPE.RastPort *sourcerp

NEWTYPE.bmark
  xMin.w
  yMin.l
  xMax.w
  yMax.l
End NEWTYPE
DEFTYPE.bmark bmark
;DEFTYPE.bmark BlockDims
DEFTYPE.bmark oldBlockDims

NEWTYPE.mousePos
  X.w
  Y.w
  textX.w
  textY.w
End NEWTYPE
DEFTYPE.mousePos mousePos

NEWTYPE.project
  name.s
  drawer.s
  wizardfile.s
  sourcefile.s[#MAX_SOURCEFILES]
  sourcepath.s[#MAX_SOURCEFILES]
  sourcecounter.b
  pad.b         ; make it even
  ;
  version.w
  revision.w
  ;
  use_wbstartup.b
  use_nocli.b
  use_syntax.b
  use_optimize.b
  value_syntax.b
  value_optimize.b
End NEWTYPE
DEFTYPE.project ab2_project
Dim tempproject$(#MAX_SOURCEFILES,1)
MaxLen project_changelog$         = 1024


Dim rememberfiles$(5)

NEWTYPE .pedfilelist
 dummy.b[$DE]
 filename.s
End NEWTYPE

NEWTYPE .winprefs
  diag_x.w
  diag_y.w
  diag_w.w
  diag_h.w
  diag_on.b

  click_x.w
  click_y.w
  click_w.w
  click_h.w
  click_on.b

  ibrowser_x.w
  ibrowser_y.w
  ibrowser_w.w
  ibrowser_h.w
  ibrowser_on.b

  type_x.w
  type_y.w
  type_w.w
  type_h.w
  type_on.b
  activewin.b

  source_x.w
  source_y.w
  source_w.w
  source_h.w

  short_x.w
  short_y.w
  short_w.w
  short_h.w
  short_on.b

  lbrowser_x.w
  lbrowser_y.w
  lbrowser_w.w
  lbrowser_h.w
  lbrowser_on.b

  console_x.w
  console_y.w
  console_w.w
  console_h.w
  console_on.b
End NEWTYPE
Dim wpref.winprefs(3)
DEFTYPE.winprefs wtemp

NEWTYPE.custommenu
  itemname.s
  shortcut.s
  id.l
  path.s
  runwbmode.l
  stacksize.l
  prio.l
End NEWTYPE
Dim List custommenu.custommenu(0)

NEWTYPE.templates
  filename.s
  description.s
End NEWTYPE
Dim List templates.templates(0)

; temporary list for browsefile creation
NEWTYPE.dirs
  name.s
End NEWTYPE
Dim List dirs.dirs(0)

Dim diag_lab$(15)
Dim diag_val$(15)

; --------------------------- Color settings --------------------------
#AB3_cfunction         = 1
#AB3_cmacro            = 2
#AB3_cstring           = 3
#AB3_cnewtype          = 4
#AB3_cconstant         = 5
#AB3_cremarkforeground = 6
#AB3_cremarkbackground = 7
#AB3_ctoken            = 8
#AB3_ctokenbackground  = 9
#AB3_cbackground       = 10
#AB3_cother            = 11
#AB3_cclassic          = 12

#AB3_screenback        = 20
#AB3_screentext        = 21
#AB3_screenshine       = 22
#AB3_screenfill        = 23
#MAX_AB3Pens           = 24     ; added to replace Array dimension and maxindex for loops  tomsmart1
Dim AB3Pen.w(#MAX_AB3Pens)
Dim AB3RGB.l(#MAX_AB3Pens)
Dim AB3RGB_temp.l(#MAX_AB3Pens)
AB3RGB_copytemp.l = 0           ; added for temporary copy of the select color  tomsmart1


; --------------------------- Cursor modes -----------------------------
#AB3_cursorStyle_block      = 0
#AB3_cursorStyle_line       = 1
#AB3_cursorStyle_underline  = 2

Function.s cursorStyleGetString{value.w}
  Select value
  Case #AB3_cursorStyle_block
    Function Return "block"
  Case #AB3_cursorStyle_line
    Function Return "line"
  Case #AB3_cursorStyle_underline
    Function Return "underline"
  Default
    Function Return "block"
  End Select
End Function

Function.w cursorStyleGetValue{stylestring.s}
  Select LCase$(stylestring)
  Case "block"
    Function Return #AB3_cursorStyle_block
  Case "line"
    Function Return #AB3_cursorStyle_line
  Case "underline"
    Function Return #AB3_cursorStyle_underline
  Default
    Function Return #AB3_cursorStyle_block
  End Select
End Function
; -----------------------------------------------------------------------

SHARED num_operators.b  : num_operators = 0
Restore key_chars
Repeat
  Read key_char$
  If key_char$<>""
    Dim KEEP operators$(num_operators)                  ; array to store characters to structurize (auto_format-option)
    operators$(num_operators) = key_char$
    num_operators + 1
  EndIf
Until key_char$ = ""
key_chars:
Data.s "=",":","<",">","+","-","/","*","&","|",";",""

Dim lowerchars.b(129)                  ; create a chartable with all characters lowercase
For i.l = 1 To 127
  a$ = LCase$(Chr$(i))
  lowerchars(i) = Asc(a$)
Next
Poke.l ?lowerchartable,&lowerchars(0)      ; make it basic!
Poke.b ?casemode,1
CaseSense Off

browse_macros.l           = Off
browse_instructions.l     = On
browse_includes.l         = Off

; for listtype window
Dim pos2(15),pos$(15),postype$(15)

MaxLen sourcename$        = 96
MaxLen a$                 = 300      ;need for read .xtra
a$ = ""

messageErrorWriteFile.s = "Error writing file!"


MaxLen tsourcedir$        = 192
MaxLen tincludedir$       = 192
MaxLen thelpdir$          = 192
MaxLen tautodocdir$       = 192

MaxLen tmp_string.s       = 1024     ; used for passing strings to os-functions
MaxLen pedmessage.s       = 96       ; used for display the text area
MaxLen tmpDetokeStr.s     = #MAX_Columns

WZListAdd lst.List         ," "
WZListAdd lst2.List        ," "
WZListAdd list_labels.List ," "

#Max_BlitzLibs             = 256                   ; added and set to 256 to replace wrong 255 hardcoded Array dimension because we use entry 0 to 255 and this are 256 entrys  tomsmart1
Dim lib_mapping$(#Max_BlitzLibs,1)                 ; replaced the wrong 255 with the #Max_Blitzlibs Constant  tomsmart1
Dim lib_check.b(#Max_BlitzLibs)                    ; replaced the wrong 255 with the #Max_Blitzlibs Constant  tomsmart1
For i = 0 To (#Max_BlitzLibs-1)                    ; replaced the hardcoded 255 with (#Max_Blitzlibs-1) because we start at 0  tomsmart1
  lib_mapping$(i,0) = "* unused ID"+Str$(i)+" *"
  lib_mapping$(i,1) = ""
Next i
Dim tokentable.b(65536)

; -------------------------------------- structs for source window
DEFTYPE.Screen       *myscreen        ; pointer to a screen
DEFTYPE.DrawInfo     *drawinfo        ; drawing information of that screen

NEWTYPE.pedMessage
  _Class.l
  _Code.w
  _Qualifier.w
  _IAddress.l
  _MouseX.w
  _MouseY.w
  _Seconds.l
  _Micros.l
  _Window.l
End NEWTYPE

DEFTYPE.pedMessage pedMessage
DEFTYPE.preprocessor *PreProcessor

; ------------------------------------------------------
; MACRODEFINITIONS
; ------------------------------------------------------
.MACROS
Macro versions
  "\\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH (\\__DATE_GER__) Build \\__VER_BUILD"
End Macro

Macro regs2stack
  MOVEM.l d0-d7/a0-a6,-(a7)
End Macro

Macro stack2regs
  MOVEM.l (a7)+,d0-d7/a0-a6
End Macro

Macro skipspace
 'nspace1`@
    CMP.b #" ",(`1)
    BNE 'nspace`@
      ADDQ.l #1,`1
  BRA 'nspace1`@
 'nspace`@
End Macro

Macro isLetter
  CMP.b #"A",D2
  BCS.w 'JL_0_60E8`@
    CMP.b #"z",D2
    BHI.w 'JL_0_60E8`@
      CMP.b #"[",D2
      BCS.w 'JL_0_60E6`@
        CMP.b #"a",D2
        BCS.w 'JL_0_60E8`@
     'JL_0_60E6`@:
      CMP.w D2,D2
 'JL_0_60E8`@:
End Macro

Function.l PED_AllocMem{memsize.l}
SHARED ped
  memptr.l = AllocPooled_(ped\mempool, memsize + 4)
  If memptr <> 0
    Poke.l memptr, memsize + 4
    Function Return memptr + 4
  Else
    Function Return False
  EndIf
End Function

Statement PED_FreeMem{memptr.l}
SHARED ped
;  log_Print{"loesche zeile: " + Peek.s(memptr+9)}
;  log_Print{"speicher: " + Str$(Peek.l(memptr-4))}
  FreePooled_ ped\mempool,memptr-4,Peek.l(memptr-4)
End Statement

;Macro newalloc                 ; d0: memSize
;  ADDQ.l #4,d0
;  MOVE.l _execbase,a6
;  MOVE.l comPtr_MemPool,a0
;  MOVE.l d0,-(a7)
;  JSR _AllocPooled(a6)         ; (a0: poolHeader, d0: memSize)
;  MOVE.l (a7)+,d1
;  TST.l d0                      ; allocpooled returns memadress in d0
;  BEQ 'avp_fail1`@
;    MOVE.l d0,a0
;    MOVE.l d1,(a0)+
;    MOVE.l a0,d0
; 'avp_fail1`@
;End Macro

Macro newfree      ; A1: memoryentry in Pool
  MOVE.l _execbase,a6
  MOVE.l comPtr_MemPool,a0
  MOVE.l -(a1),d0
  JSR _FreePooled(a6)                                      ; a0: poolHeader, a1: memory, d0: memsize
End Macro


; ------------------------------------------------------
; FUNCTIONDEFINITIONS
; ------------------------------------------------------
.FUNCTIONS
Function.b PED_CheckLabelRelevance{testString.s}
SHARED ped

  tmppos.w = 1
  While Mid$(testString,tmppos,1) = " "
    tmppos + 1
  Wend
  Repeat
    tmpchar.b = Asc(Mid$(testString,tmppos,1))
    If tmpchar = ped\LabelIdentifier Then Function Return True
    If tmpchar = 59 Then Function Return True    ; ";"
    If tmpchar = $80
      If Asc(Mid$(testString,tmppos+1,1))= $2d OR Asc(Mid$(testString,tmppos+1,1)) = $ae ; Token "Stop" or Token "TRAP"
        Function Return True
      EndIf
    EndIf
    tmppos + 1
  Until tmpchar <= 0
  Function Return False
End Function

Function.b PED_ReadFileCache{}
SHARED ped,readcache, *PreProcessor.preprocessor

  log_Print{"read file to cache ..."}
  If ped\sourceFileHandle  = 0
    error{"No file handle set!!"}
    Function Return False
  EndIf

  readcache\mode = $00

  readcache\filehandle = ped\sourceFileHandle                 ; file
  readcache\blocklen   = $2000                                 ; length
  readcache\bufferoffset = 0

  If readcache\readlen <= 0                   ; no file yet!
;    log_Print{"no file yet in cache"}
    ExamineFH_ readcache\filehandle,readcache\fib
    readcache\filelen = readcache\fib\fib_Size

    If readcache\filelen > readcache\cachelen
 ;     log_Print{"allocating cachememory..."}
      If readcache\cacheptr Then FreeVec_ readcache\cacheptr
      readcache\cacheptr = AllocVec_(readcache\filelen,#MEMF_ANY)
      readcache\cachelen = readcache\filelen
    End If

;    log_Print{"Filelen : " + Str$(readcache\filelen)}
;    log_Print{"Cachelen: " + Str$(readcache\cachelen)}
;    log_Print{"start reading to ..." + Hex$(readcache\cacheptr) + " from filehandle " + Hex$(readcache\filehandle)}
    readcache\readlen = Read_ (readcache\filehandle,readcache\cacheptr,readcache\filelen)
;    log_Print{"Readlen : " + Str$(readcache\readlen) + " from " + Hex$(readcache\filehandle)}

    ;ex.s = LCase$(dos_GetExt{Peek.s(&readcache\fib\fib_FileName)})
    ;If ex = "ab2" OR ex = "ab3" OR ex = "asc"
;    If ped\DoTokenize
;      log_Print{"tokenizing imported text..."}
      ; process the ascii data in sourcebuff length and write the tokenized source into destbuffer
      ; the return value is the length of the tokenized text
      ; sourcebuff and destbuff might be the same pointer
      ; preproc_Tokenize{*tn.preprocessor,sourcebuff.l,destbuff.l,bytelength.l}
;      log_Print{Peeks$(readcache\cacheptr,readcache\readlen)}
;      readcache\readlen = preproc_Tokenize{*PreProcessor,readcache\cacheptr,readcache\cacheptr,readcache\readlen}
 ;     log_Print{"done "+ Str$(readcache\readlen) + " bytes"}
;    End If
    readcache\offset = 0
  End If

  readcache\chunklen = readcache\blocklen
  If readcache\chunklen > readcache\readlen-readcache\offset Then readcache\chunklen = readcache\readlen-readcache\offset

;  log_Print{"chunklen: " + Str$(readcache\chunklen)}
;  log_Print{"cacheptr: " + Str$(readcache\cacheptr)}

  If readcache\chunklen > 0
    CopyMem_ readcache\cacheptr + readcache\offset,readcache\bufferptr,readcache\chunklen
    readcache\offset + readcache\chunklen
    Function Return True
  Else
    readcache\chunklen = 0
    readcache\readlen = 0
    Function Return False
  End If

  ;MOVE.l readcache_chunklen,d0
  ;MOVE.l readcache_chunklen,d6
  ;MOVEA.l comPtr_DosBuffer,A5
  ;MOVE.l comPtr_SourceFileHandle,D7
  ;TST.l D6

End Function

Function.b PED_ReadClipboard{}
SHARED ped,readcache

  ;log_Print{"read from clipboard"}
  readcache\mode = $FF : readcache\cb_eol = False
  readcache\chunklen = -1
  readcache\bufferoffset = 0
  If readcache\cH = Null Then readcache\cH = clipboard_Open{0} : readcache\cb_linecount = 0 ; open clipboard and reset line count

  If readcache\cH
    clipboard_text.s = ""
    If clipboard_HasMoreLines{readcache\cH}
      clipboard_text.s = clipboard_GetNextLine{readcache\cH}
      quoted.w = False
      comment.w = False
      For n.l = 0 To FLen(clipboard_text) - 1
        cchar.w = Peek.b(&clipboard_text+n) & $FF
        If cchar = $22 Then quoted = 1-quoted ; detect quotes
        If quoted=False AND cchar=@";" Then comment = True
        If cchar = $a0 Then cchar = @" "      ; non-breaking space => standard space
        If cchar > 127 AND quoted=False AND comment=False Then cchar = @"?"  ; replace non-ASCII characters with ?, if not in string
        Poke.b &clipboard_text+n,cchar
      Next
      ;log_Print{"cbline: " + clipboard_text}
      ;log_Print{"first char: " + Str$(Peek.b(&clipboard_text))}
      ;log_Print{"cblen: " + Str$(FLen(clipboard_text))}

      readcache\chunklen = FLen(clipboard_text) ; put this line to copy buffer
      If readcache\chunklen > 0 Then CopyMem_ &clipboard_text,readcache\bufferptr,readcache\chunklen
      readcache\cb_linecount + 1

    Else
      ;log_Print{"clipboard empty."}
      clipboard_Free{readcache\cH}
      readcache\cH = Null
      readcache\cb_linecount = 0
      readcache\cb_eol = True
      readcache\chunklen = -1
    End If
  End If

  If readcache\chunklen = -1
    Function Return False
  Else
    Function Return True
  EndIf
End Function

Function.b PED_ReadNextByte{}
SHARED ped,readcache

  morebytes.b = True
  readcache\currentbyte = 0

  Repeat
    readcache\chunklen - 1

    If readcache\chunklen >=0
      readcache\currentbyte = Peek.b(readcache\bufferptr + readcache\bufferoffset)
      readcache\bufferoffset + 1
      readcache\moreBytes = True
      Function Return True
    Else
      If readcache\mode = $00
        morebytes = PED_ReadFileCache{}
      Else
        morebytes = PED_ReadClipboard{}
      EndIf
    EndIf
  Until morebytes = False

  readcache\moreBytes = morebytes
  Function Return morebytes
End Function

Function.s PED_ReadNextLine{}
SHARED ped,readcache

  resultString.s = "NoCOntenTwasDelivered"

  If readcache\mode AND readcache\cb_eol Then Function Return resultString

  If PED_ReadNextByte{}
    resultString = ""
    Repeat
      ; this is the EOL of ClipBoard!
      If readcache\currentbyte = $0A Then Function Return resultString
      ; no further bytes left
      If readcache\currentbyte = $00 Then Function Return resultString

      If readcache\currentbyte = $9  Then readcache\currentbyte = $20 ; replace TAB by space

      If readcache\currentbyte <> $0D Then resultString + Chr$(readcache\currentbyte)
      ; do to import_start
    Until NOT PED_ReadNextByte{}
  EndIf
  ;log_Print{"ReadNextLine: [" + resultString + "]"}
  Function Return resultString
End Function

Function.b PED_StoreSourceLine{*storeLine.sourceLine}
SHARED ped

  If *storeLine = 0 Then Function Return False

  If Peek.b(*storeLine + 9) <> 0
    storeAddr.l = Peek.l(?lineundeletestore)
    tempLen.b = Peek.b(*storeLine + 8)
    log_Print{"storing line: " + Peek.s(*storeLine + 9)}
    ped\undeleteStrLen = tempLen
    For i.b = 0 To tempLen-1
      Poke.b storeAddr + i, Peek.b(*storeLine + 9 + i)
    Next i
  EndIf
  Function Return True

End Function

Function.b PED_DeleteSourceLine{*delLine.sourceLine}
SHARED ped

   If *delLine = 0 Then Function Return False

   tmpStr.s = Peek.s(*delLine + 9)
   If PED_CheckLabelRelevance{tmpStr} Then ped\LabelListChanged = True

   PED_FreeMem{*delLine} : Poke.l *delLine, 0
   Function Return True
End Function


Function.l PED_CreateNewSourceLine{newline.s}
SHARED ped,*PreProcessor

;  If ped\DoTokenize
;    MaxLen linebuff$ = 256
;    preproc_Tokenize{*PreProcessor,&newline,&linebuff$,FLen(newline)}
;    newline = Peek.s(&linebuff$)
;  EndIf

  _strLen.w = FLen(newline) + 1
  If _strLen = 1 Then newline = Chr$(0)

  lineaddr.l = PED_AllocMem{_strLen + 9}

  Poke.l lineaddr,0          ;clear pointer to prevline
  Poke.l lineaddr+4,0        ;clear pointer to nextline
  Poke.b lineaddr+8,_strLen  ;store length of string

                             ;copy string to new sourceline
  For i.w = 0 To _strLen - 1
    Poke.b lineaddr + 9 + i,Peek.b(&newline + i)
    If Asc(Mid$(newline,i+1,1)) = ped\LabelIdentifier Then ped\LabelListChanged = True
  Next i
  Poke.b lineaddr + 9 + _strLen,0

  Function Return lineaddr
 
End Function

Function.b PED_ReplaceCurrentSourceLine{*newLine.sourceLine}
SHARED ped
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  If *currentLine = ped\ptrCurrentSourceData\FirstSourceLine Then ped\ptrCurrentSourceData\FirstSourceLine = *newLine
  If *currentLine = ped\ptrCurrentSourceData\LastSourceLine Then ped\ptrCurrentSourceData\LastSourceLine = *newLine

  *previousLine.sourceLine = *currentLine\previousLine
  If *previousLine
    *previousLine\nextLine = *newLine
    *newLine\previousLine = *previousLine
  EndIf
  *nextLine.sourceLine = *currentLine\nextLine
  If *nextLine
    *nextLine\previousLine = *newLine
  EndIf
  *newLine\nextLine = *nextLine

  PED_DeleteSourceLine{*currentLine}
  ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
End Function

Function PED_InsertSourceLine{*newLine.sourceLine}
SHARED ped

   *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
   If *currentLine
    *prevLine.sourceLine = *currentLine\previousLine
    If *prevLine = 0
      ;log_Print{"current line has no previousline, setting newline as new firstline."}
      ped\ptrCurrentSourceData\FirstSourceLine = *newLine
    Else
      *newLine\previousLine = *prevLine
      *prevLine\nextLine = *newLine
    EndIf

    *currentLine\previousLine = *newLine
    *newLine\nextLine = *currentLine
  Else
    log_Print{"as there is no sourceline left, this will be the first and last one."}
    ped\ptrCurrentSourceData\FirstSourceLine = *newLine
    ped\ptrCurrentSourceData\LastSourceLine = *newLine
  EndIf

  ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
  ped\ptrCurrentSourceData\TotalLines + 1

  tmpStr.s = Peek.s(*newLine + 9)
  If PED_CheckLabelRelevance{tmpStr} Then ped\LabelListChanged = True

  Function Return True

End Function


Function PED_GetConstantValue{ptr_constantbase.l,cname$}
  *cb.l = ptr_constantbase
  If *cb
    cfound.b = False
    ;*cb = Peek.l(*cb)
    While *cb AND NOT cfound
      a$ = Peek$(*cb + $13)
      If a$ = cname$
        cfound = True
      Else
        *cb = Peek.l(*cb)
      EndIf
    Wend
    If cfound Then Function Return Peek.l(*cb+8)
  EndIf
End Function

Function.b CheckChr{char$,table$}
  For i.b = 1 To FLen(table$)
    If char$ = Mid$(table$,i,1)
      Pop If : Pop For
      Function Return True
    End If
  Next i
  Function Return False
End Function

Function.s PED_GetWordAtPos{text$, textX.w, removechars.b, @preproc.b}
SHARED *PreProcessor.preprocessor

  tlen.w = FLen(text$)
  If tlen < 2 Then Function Return ""

  If Mid$(text$,textX,1) = "" Then Function Return ""

  If preproc
    ;log_Print{"using preprocessor to find string in source: " + text$}
    Function Return Trim$(preproc_CropToken{*PreProcessor,text$,textX})
  Else
    If removechars Then checklist.s = " .,+&!|(){}[]<>" Else checklist = ""

    result$ = "" : char$ =""
    cursorpos.w = textX
    nextpos.w = cursorpos
    backpos.w = cursorpos - 1
    Repeat
      result$ = char$ + result$
      char$ = Mid$(text$,backpos,1)
      backpos - 1
    Until CheckChr{char$,checklist + Chr$(34)} OR (backpos<0)
    char$ = ""

    Repeat
      result$ = result$ + char$
      char$ = Mid$(text$,nextpos,1)
      nextpos + 1
    Until CheckChr{char$,checklist + Chr$(34)} OR (nextpos>(tlen+1))
    Function Return StripLead$(result$,32)
  EndIf
End Function


Statement PED_ShowMessage{textMessage.s,@target.b,@style.b}
  SHARED pedmessage,sourceWindow,AB3Pen()            ; has to be shared, because on exit of function the variable will be discarded

  If sourceWindow\win;ActiveWindow
    pedmessage = textMessage

    If target = -1
      SetAPen_ sourceWindow\win\RPort,AB3Pen(#AB3_screenfill)
      RectFill_ sourceWindow\win\RPort, 0,0, sourceWindow\win\GZZWidth,sourceWindow\font\tf_YSize

      SetAPen_ sourceWindow\win\RPort,AB3Pen(#AB3_screenshine)
      SetBPen_ sourceWindow\win\RPort,AB3Pen(#AB3_screenfill)
      If style<>-1
        SetSoftStyle_ sourceWindow\win\RPort,style,style
      ;Else
        ;SetSoftStyle_ sourceWindow\win\RPort,#FSF_BOLD,#FSF_BOLD
      EndIf
      Move_ sourceWindow\win\RPort,0,sourceWindow\font\tf_Baseline
      Text_ sourceWindow\win\RPort,&pedmessage,FLen(pedmessage)
    Else
      SetWindowTitles_ sourceWindow\win,-1,&pedmessage
    EndIf

  EndIf
End Statement


Statement Show_Helpfile{libname$,node$,helpdir$}
  SHARED pedconfig,ped

  If node$ = "" Then node$ = "main"
  commandlineStr.s + "  -t " + node$
  If helpdir$ <> ""
    commandlineStr + " -d " + helpdir$
  Else
    commandlineStr + " -d " + pedconfig\helpDir
  EndIf

  If libname$ <> "" Then commandlineStr + " -l " + dos_FilePart{dos_RemExt{libname$}}

  If pedconfig\use_pubscreen
    commandlineStr + " -s " + ped\defaultPubscreenName
  Else
    If pedconfig\clone_wbscreen
      commandlineStr + " -s " + Chr$(34) + ped\defaultScreenTitle + Chr$(34)
    Else
      commandlineStr + " -s Workbench"
    EndIf
  EndIf
  ; adjusting the window size
  commandlineStr + " w " + Str$(screen_GetWidth{} / 2) + " h " + Str$(screen_GetHeight{} / 1.5)

  log_Print{"opening Helpviewer for ["+ libname$ + "/" + node$ + "] ..."}
  log_Print{"commandstring <" + commandlineStr + ">"}
  PED_ShowMessage{"Opening Helpviewer for "+ libname$ + "/" + node$ + " ..."}
  dos_RunCli{dos_AddPart{pedconfig\mainDir,"Tools/AB3HelpViewer"},0,8192,False,commandlineStr} ; changed to match up the last dos.include this fix the show of the help/doc files
End Statement

Function.b CheckWindow{title$}
SHARED pedconfig
  succ.b = True
  *thisscreen.Screen = Peek.l(Addr Screen(0))
  *conwin.Window = *thisscreen\FirstWindow
  While (*conwin<>0) AND Peek$(*conwin\Title) <> pedconfig\console_title
    *conwin = Peek.l(*conwin)
  Wend
  If *conwin=0 Then succ = False

  Function Return succ
End Function


Function.s PED_GetLibname{libnum.w}
  SHARED lib_mapping$()
  If libnum > 255 OR libnum < 0
    libname.s = ""
    Select libnum
    Case #varslib         : libname = "varslib"
    Case #wbstartuplib    : libname = "wbstartuplib"
    Case #memlib          : libname = "memlib"
    Case #intlib          : libname = "intlib"
    Case #switchlib       : libname = "switchlib"
    Case #runerrlib       : libname = "runerrlib"
    Case #arrayslib       : libname = "arrayslib"
    Case #staticslib      : libname = "staticslib"
    Case #strings1lib     : libname = "strings1lib"
    Case #strings2lib     : libname = "strings2lib"
    Case #exitslib        : libname = "exitslib"
    Case #ffplib          : libname = "ffplib1"
    Case #lmullib         : libname = "lmullib"
    Case #ldivlib         : libname = "ldivlib"
    Case #clrlib          : libname = "clrlib"
    Case #datalib         : libname = "datalib"
    Case #strcomplib      : libname = "strcomplib"
    Case #maxslib         : libname = "maxslib"
    Case #maxlenlib       : libname = "maxlenlib"
    Case #chipbaselib     : libname = "chipbaselib"
    Case #floatquicklib   : libname = "floatquicklib"
    Case #modlib          : libname = "modlib"
    Case #debuglib        : libname = "debuglib"
    Case #rundebuglib     : libname = "rundebuglib"
    Case #errtraplib      : libname = "errtraplib"
    Default
      libname = "unknown syslib #"+Str$(libname)
    End Select
    Function Return libname
  Else
    Function Return lib_mapping$(libnum,0)
  EndIf
End Function


Function.s PED_GetFirstTokenname{libnum.w}
  SHARED lib_mapping$()
  If libnum>255
    error{"Couldnot get Token of a syslib!"}
  Else
    Function Return lib_mapping$(libnum,1)
  EndIf
End Function

Function.s PED_Detoke{*sourceLine.sourceLine}
SHARED tmpDetokeStr.s

  If *sourceLine = 0 Then Function Return ""
  
  tmpDetokeStr = String$(Chr$(0),#MAX_Columns) 
  GetReg A0, *sourceLine + 9
  GetReg A1, &tmpDetokeStr
  MOVEM.l A0-a1,-(a7)
  !asm
  MOVEM.l (a7)+,A0-a1
  JSR detokenize_line   ;input A0: tokenized string; returns A1: detokenized string
  !basic
  result.s = Peek.s(&tmpDetokeStr)
  Function Return result

End Function





Function.s PED_GetTokenName{*tokeninfo.tokeninfo,tnumber.w}
  While *tokeninfo
    If *tokeninfo\number = tnumber Then Function Return Peek.s(&*tokeninfo\dat)
    *tokeninfo = *tokeninfo\next_token
  Wend
  Function Return "" ; token not found
End Function


Function.w PED_GetTokenID{*tokeninfo.tokeninfo,tname$}
  lname$ = LCase$(tname$)
  While *tokeninfo
    If LCase$(Peek.s(&*tokeninfo\dat)) = lname$ Then Function Return *tokeninfo\number
    *tokeninfo = *tokeninfo\next_token
  Wend
  Function Return -1 ; token not found
End Function


Function.w PED_GetTokenLibnum{*tokeninfo.tokeninfo,tname$}
  number.w = PED_GetTokenID{*tokeninfo.tokeninfo,tname$}
  If number><-1 Then Function Return (number LSR 7)
  Function Return -1 ; token not found
End Function


Function.s PED_GetTokenHelp{*tokeninfo.tokeninfo,tname$}
  lname$ = LCase$(tname$)
  While *tokeninfo
    If LCase$(Peek.s(&*tokeninfo\dat)) = lname$
      ;Function Return tname$ + "  ; " + Peek.s(&*tokeninfo\dat+FLen(tname$)+1)
      Function Return Peek.s(&*tokeninfo\dat+FLen(tname$)+1)
    End If
    *tokeninfo = *tokeninfo\next_token
  Wend
  Function Return "" ; token not found
End Function

Function.b PED_CheckForClassicToken{_token.l}
    _libnum.l = _token ASR 7

    ; check for a classic lib
    ccounter.b = 0
    Repeat
      classicID.l = Peek.w(?classiccommands + ccounter)
      If (classicID > 0) AND (classicID = _libnum)
        Pop Repeat:Pop If
        Function Return True
      EndIf
      ccounter + 2
    Until classicID = 0

    ; check for a classic command
    exit_classicloop.b = False
    Repeat
      classicID.l = Peek.w(?classiccommands + ccounter)
      If (classicID > 0) AND (classicID = _token)
        Pop Repeat : Pop If
        Function Return True
      EndIf
      ccounter + 2
    Until classicID = 0 OR exit_classicloop
    Function Return False
End Function




NEWTYPE .HelpIndexCacheItem
  name.s
  lname.s
  help.s
  includefile.s
End NEWTYPE
Dim List HelpIndexCache.HelpIndexCacheItem(0)


Statement PED_UpdateHelpIndexCache{HelpIndexFile$}
  SHARED HelpIndexCache()
  ;fidW.l = file_Open{"sys:pedbug.txt",#file_forcewrite}
  fid.l = file_Open{HelpIndexFile$,#file_read}
  If fid<>-1
    ClearList HelpIndexCache()
    ;file_Cache{fid}
    While file_EOF{fid} = False
      zeile$ = file_ReadLine{fid}

      pos_name.l  = Instr(zeile$,"\\09",1)
      If pos_name=0 Then pos_name=FLen(zeile$)+1

      pos_desc.l  = Instr(zeile$,"\\09",pos_name+1)
      If pos_desc=0 Then pos_desc=FLen(zeile$)+1

      typ$  = Mid$(zeile$,1,pos_name-1)
      name$ = Mid$(zeile$,pos_name+1,pos_desc-pos_name-1)
      help$ = Mid$(zeile$,pos_desc+1)

      ;file_WriteLine{fidW,typ$+"::"+name$+"::"+help$}
      If typ$><""
      If typ$ = "FILE"
        filename$ = name$
      Else

        lname$ = LCase$(name$)
        If name$><""
          If help$=""
            Select typ$
              Case "FUNC" : help$ = "{...} ; Function"
              Case "MACR" : help$ = "{...} ; Macro"
              Case "STAT" : help$ = "{...} ; Statement"
              Default
                help$ = typ$
            End Select
          End If
          If AddItem(HelpIndexCache())
            HelpIndexCache()\name  = name$
            HelpIndexCache()\lname = lname$
            HelpIndexCache()\help  = help$
            HelpIndexCache()\includefile = filename$
          End If
        End If
      End If
      End If
    Wend
    file_Close{fid}
  Else
    error{"Could not open Helpindexfile for read."}
  End If
  ;If fidW><-1 Then file_Close{fidW}

End Statement


Statement PED_WriteHelpIndexCache{HelpIndexCacheFile$}
  SHARED HelpIndexCache()

  If dos_Exist{HelpIndexCacheFile$} Then dos_Delete{HelpIndexCacheFile$}

  If OpenFile(1,HelpIndexCacheFile$)
    ResetList HelpIndexCache()
    While NextItem(HelpIndexCache())
      WriteType 1,HelpIndexCache()
    Wend
    CloseFile 1
  End If
End Statement


Statement PED_LoadHelpIndexCache{HelpIndexCacheFile$}
  SHARED HelpIndexCache()
;  fidW.l = file_Open{"sys:pedbug.txt",#file_forcewrite}

  If OpenFile(1,HelpIndexCacheFile$)
    ClearList HelpIndexCache()
    _lof.l = Lof(1)
    While _lof > Loc(1)
      If AddLast(HelpIndexCache())
        ReadType 1,HelpIndexCache()
        ;!cout{"*"+HelpIndexCache()\name+"*"}
        ;file_WriteLine{fidW,HelpIndexCache()\name}
      Else
        error{!TRANS{"Could not build index cache."}}
        Pop While: Goto exit_while1
      EndIf
    Wend
    exit_while1:
    CloseFile 1
  Else
    error{HelpIndexCacheFile$ + " "+!TRANS{"not found."}}
  End If

;  If fidW><-1 Then file_Close{fidW}

End Statement


Function.s PED_GetIncludeHelp{tname$}
  SHARED pedconfig,HelpIndexCache()
  lname$ = LCase$(tname$)
  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then PED_LoadHelpIndexCache{pedconfig\HelpIndexCacheFile}
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache())
    If HelpIndexCache()\lname = lname$
      Function Return HelpIndexCache()\help
    End If
  Wend
  Function Return ""                 ; function not found
End Function


Function.s PED_GetIncludeFunction{tname$}
  SHARED pedconfig,HelpIndexCache()
  lname$ = LCase$(tname$)
  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then PED_LoadHelpIndexCache{pedconfig\HelpIndexCacheFile}
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache())
    If HelpIndexCache()\lname = lname$
      Function Return HelpIndexCache()\name
    End If
  Wend
  Function Return ""                 ; function not found
End Function


Function.s PED_GetIncludeName{tname$}
  SHARED pedconfig,HelpIndexCache()
  lname$ = LCase$(tname$)
  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then PED_LoadHelpIndexCache{pedconfig\HelpIndexCacheFile}
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache())
    If HelpIndexCache()\lname = lname$
      Function Return HelpIndexCache()\includefile
    End If
  Wend
  Function Return "" ; function not found
End Function


Function.s PED_GetMacroHelp{macrobase.l,macname.s}
  macfound.b = False
  maccounter.l = 0
  mname.s = StripLead$(StrLower(macname),@"!")

  *mpointer.b = macrobase
  Repeat
    result.s = Peek$(*mpointer + 13)
    If StrLower(result) = macname
      maclen.w = Peek.w(*mpointer + 8)
      If maclen > 32 Then maclen = 32
      macroP.l = Peek.l(*mpointer + 4)
      If macroP Then help.s = StripLead$(Peeks$(macroP,maclen),32)

      help.s = StripLead$(help,@";")
      Function Return help.s
    End If
    *mpointer = Peek.l(*mpointer)
  Until *mpointer = 0
  Function Return ""
End Function


Function.s PED_GetMacroName{macrobase.l,macname.s}
  macfound.b = False
  maccounter.l = 0
  macname.s = StripLead$(StrLower(macname.s),@"!")

  *mpointer.b = macrobase
  Repeat
    result.s = Peek.s(*mpointer + 13)
    If StrLower(result) = macname.s
      Function Return result
    End If
    *mpointer = Peek.l(*mpointer)
  Until *mpointer = 0
  Function Return ""
End Function


Statement PED_PrintTextStandard{tx.w, ty.w, *textaddr.l}
SHARED pedconfig,sourceWindow,AB3Pen()

  ;log_Print{"print_standard_text"}

  ; copy the current Line To a tempBuffer
  For i.w = 0 To Len(Peek$(*textaddr))
    Poke.b Peek.l(?textbufferPrint) + i, Peek.b(*textaddr+i)
  Next i

  startPos.w = sourceWindow\ColumnsOffsetTmp
  tmpString$ = UnRight$(Peek$(*textaddr),startPos)

  tlength.w = Len(tmpString$)
  If tlength > sourceWindow\visibleColumns Then tlength = sourceWindow\visibleColumns

  tposy.w = ty * sourceWindow\font\tf_YSize + sourceWindow\font\tf_Baseline + sourceWindow\BoxTop
  tposx.w = tx * sourceWindow\font\tf_XSize + sourceWindow\BoxLeft

  Move_ sourceWindow\win\RPort, tposx, tposy
  SetAPen_ sourceWindow\win\RPort,AB3Pen(#AB3_cother)
  SetBPen_ sourceWindow\win\RPort,AB3Pen(#AB3_cbackground)
  Text_ sourceWindow\win\RPort,&tmpString$,tlength

End Statement



Statement PED_PrintText{*textaddr.l, xPos.w, yPos.w, textlength.w, textcolor.w}
SHARED pedconfig, sourceWindow, AB3RGB(), AB3Pen()

  printtext.s = Peek.s(*textaddr)

  ; -- clip text to visible columns
  If (textlength > sourceWindow\visibleColumns) Then textlength = sourceWindow\visibleColumns

  mx.w = xPos * sourceWindow\font\tf_XSize + sourceWindow\BoxLeft
  my.w = yPos * sourceWindow\font\tf_YSize + sourceWindow\BoxTop + sourceWindow\font\tf_Baseline
  Move_ sourceWindow\win\RPort ,mx ,my

  SetAPen_ sourceWindow\win\RPort, textcolor
  SetBPen_ sourceWindow\win\RPort, AB3Pen(#AB3_cbackground)

  If (AB3RGB(#AB3_cremarkforeground) OR AB3RGB(#AB3_cremarkbackground)) AND pedconfig\highlighting
    semi_position.w = 0
    in_string.b = 0
;    columnsoff.w = Peek.w(?comWord_ColumnsOffset)

    ; -- search for a comment and save the starting position
    search_again2:
    semi_position = Instr(printtext,";",semi_position + 1)
    If semi_position > 0
       ; -- check if the comment-char +++ ; +++ is in a string
       acount.b = 0
       For i.w = 1 To semi_position
         If Mid$(printtext,i,1) = Chr$($22) Then acount + 1
       Next i
       If (acount MOD 2) = 1
         ; -- ungerade Anzahl von +++ " +++ impliziert, das +++ ; +++ in einem String steckt...
         semi_position = 0
       Else
         If Mid$(printtext,semi_position + 1,2)=":@"
           ; -- nachschauen, ob dahinter ein echter Kommentar kommt
           Goto search_again2
         EndIf
       EndIf
       If semi_position > textlength Then semi_position = 0
     EndIf
     If semi_position > 0
       semi_position - 1 ; highlight +++ ; ++ as well

       ; -- print text before +++ ; +++
       If semi_position > 1
         Text_ sourceWindow\win\RPort,&printtext,semi_position
       EndIf

       ; -- print comment
       SetAPen_ sourceWindow\win\RPort, AB3Pen(#AB3_cremarkforeground)
       SetBPen_ sourceWindow\win\RPort, AB3Pen(#AB3_cremarkbackground)
       If pedconfig\italic_remarks
         SetFont_ sourceWindow\win\RPort,sourceWindow\fontI
         SetSoftStyle_ sourceWindow\win\RPort, #FSF_ITALIC,#FSF_ITALIC
       EndIf

       printtext = UnRight$(printtext,semi_position)
       Text_ sourceWindow\win\RPort,&printtext,FLen(printtext)
       ;log_Print{"[" + printtext + "]  " + Str$(FLen(printtext))}

       ; -- restore standard backgroundcolor and font if changed
       SetBPen_ sourceWindow\win\RPort,AB3Pen(#AB3_cbackground)
       If pedconfig\italic_remarks
         SetFont_ sourceWindow\win\RPort,sourceWindow\font
         SetSoftStyle_ sourceWindow\win\RPort,#FS_NORMAL,#FSF_ITALIC
       EndIf
     Else
       Text_ sourceWindow\win\RPort,&printtext, textlength
     EndIf
  Else
    Text_ sourceWindow\win\RPort,&printtext, textlength
  EndIf

End Statement

Statement PED_PrintHighlight{lineaddr.l, xPos.w, textlen.w, textcolor.w, textstyle.w}
SHARED pedconfig,sourceWindow
  If textlen > 0
    ;log_Print{"macro to print: " + Peeks$(lineaddr,textlen)}
    xPos = xPos - sourceWindow\ColumnsOffset

    If (textlen + xPos) > sourceWindow\visibleColumns
      textlen = sourceWindow\visibleColumns - xPos
    EndIf
    If textlen > 0
      lineaddr2.l = lineaddr
      If xPos < 0
        textlen + xPos
        lineaddr = lineaddr - xPos
        xPos = 0
      EndIf
      If textlen > 0
        xText.w = sourceWindow\BoxLeft + xPos * sourceWindow\font\tf_XSize
        yText.w = sourceWindow\BoxTop  + sourceWindow\DisplayLine * sourceWindow\font\tf_YSize + sourceWindow\font\tf_Baseline
        Move_ sourceWindow\win\RPort, xText, yText
        SetAPen_ sourceWindow\win\RPort,textcolor
        ;SetSoftStyle_ \win\RPort,textstyle,textstyle
        Text_ sourceWindow\win\RPort,lineaddr, textlen
      EndIf
    EndIf
   EndIf
End Statement




Function PED_PrintStatus{txt$,xpos.w,@ypos.w}
  SHARED sourceWindow,AB3Pen()

  USEPATH sourceWindow
  If \win
    If FLen(txt$) > 0
      xpos_text.l = \win\GZZWidth - (\font\tf_XSize) * xpos - 4
      If ypos <> -1
        ypos_text.w = \statusAreaY + (\font\tf_YSize) * ypos
      Else
        ypos_text.w = \statusAreaY + (\font\tf_YSize)
      EndIf

      SetAPen_ \win\RPort, AB3Pen(#AB3_screenshine)
      SetBPen_ \win\RPort, AB3Pen(#AB3_screenfill)
      Move_ \win\RPort, xpos_text, ypos_text

      If Vallong(txt$) > 0                                   ; boldtext for numbers
        SetFont_ \win\RPort,\fontB
        SetSoftStyle_ \win\RPort,#FSF_BOLD,#FSF_BOLD
      EndIf
      Text_ \win\RPort,&txt$,FLen(txt$)

      SetFont_ \win\RPort,\font
      SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_BOLD
      SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    EndIf
  Else
    log_Print{"PrintStatus(): window pointer empty!"}
  EndIf
End Function



Statement move_cursor {a$,lst.l,pos.l}
         ;Select EventCode
;loopm1:vvblank_resetsync{}
;           If RawKeyState(#RAWKEY_UP)
;                   i.l = WZListPos (a$)
;                   If i Then i = i-1 : WZPrint a$,pos,lst,i
;                   vvblank_wait_sync{4}:Goto loopm1
;           End If
;           If RawKeyState(RAWKEY_DOWN)
;                   i = WZListPos (a$):
;                   If i <WZListItems(lst)-2 Then i = i+1:WZPrint a$,pos,lst,i
;                   vvblank_wait_sync{4}:Goto loopm1
;           End If
;         ;End Select
End Statement



Statement PED_ScrollDelay{}
SHARED ped
  CNIF #slowdown <> 0
    If ped\no_scrollrate
      Delay_ 1
    Else
      vvblank_Wait{}
      vvblank_WaitSync{1}
      vvblank_ResetSync{}
    EndIf
  CEND
End Statement

Statement PED_ScrollHorizontal{direction.b, @scrollMode.b}
  SHARED sourceWindow
  USEPATH sourceWindow

  If scrollMode = #SCROLL_CURRENT_LINE
    ; WIP: shall replace gosub scroll_left/right
    dx.w = direction * \font\tf_XSize
    dy.w = 0
    xMin.w = \BoxLeft + \Column * \font\tf_XSize
    yMin.w = \BoxTop  + \DisplayLine * \font\tf_YSize
    xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
    yMax.w = yMin + \font\tf_YSize - 1
  Else
    dx.w = direction * (\font\tf_XSize * \scrollSize)
    dy.w = 0
    xMin.w = \BoxLeft
    yMin.w = \BoxTop
    xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
    yMax.w = \BoxTop  + Peek.l(?viewablelines) * \font\tf_YSize - 1
  EndIf
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax
End Statement

Statement PED_ScrollVertical{direction.b, @yStart.w}
SHARED sourceWindow,ped
USEPATH sourceWindow

  If yStart = -1 Then yStart = 0

  dx.w = 0
  dy.w = direction * \font\tf_YSize
  xMin.w = 0
  yMin.w = \BoxTop + yStart * \font\tf_YSize
  xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
  yMax.w = \BoxTop + Peek.l(?viewablelines) * \font\tf_YSize - 1
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax
  PED_ScrollDelay{}

  ; "scroll" the textbuffer one line
  If direction = #SCROLL_DOWN
    temp.l = Peek.l(?viewablelines) - yStart - 1
    If temp <> 0
      bytes.l = #MAX_Columns * Peek.l(?viewablelines)
      textAddr.l = Peek.l(?textbufferaddr) + bytes - 2
      textAddr2.l = textAddr - #MAX_Columns
      count.l = temp * #MAX_Columns
      For i.l = 2 To count Step 2
        Poke.w textAddr - i, Peek.w(textAddr2 - i)
      Next i
    EndIf
    textAddr.l = Peek.l(?textbufferaddr) + (yStart * #MAX_Columns)
  Else
    temp.l = Peek.l(?viewablelines) - yStart - 1
    If temp <> 0
      bytes.l = #MAX_Columns * yStart
      textAddr.l = Peek.l(?textbufferaddr) + bytes
      textAddr2.l = textAddr + #MAX_Columns
      count.l = temp * #MAX_Columns
      For i.l = 0 To count Step 2
        Poke.w textAddr + i, Peek.w(textAddr2 + i)
      Next i
    EndIf
    textAddr.l = Peek.l(?textbufferaddr) + (Peek.l(?viewablelines)-1)*#MAX_Columns
  EndIf

  ; fill the last line with spaces
  For i.l = 0 To #MAX_Columns Step 2
    Poke.w textAddr + i,$2020
  Next i

End Statement






Statement PED_GetMousePos{*mp.mousePos}
  SHARED sourceWindow
  USEPATH sourceWindow

  *mp\X = \win\MouseX - \win\BorderLeft + 1
  *mp\Y = \win\MouseY - \win\BorderTop + 1
  If *mp\X < 0 Then *mp\X = 0
  If *mp\Y < 0 Then *mp\Y = 0

  If (*mp\X > \BoxLeft)
    *mp\textX = *mp\X - \BoxLeft
    If *mp\textX < 0 Then *mp\textX = 0
    *mp\textX = *mp\textX / \font\tf_XSize
  Else
    *mp\textX = 0
  EndIf

  If (*mp\Y > \BoxTop) AND (*mp\Y < \statusAreaY)
    *mp\textY = *mp\Y - \BoxTop
    If *mp\textY < 0 Then *mp\textY = 0
    *mp\textY = *mp\textY / \font\tf_YSize
  Else
    *mp\textY = -1
  EndIf

  ;msg$ = Str$(*mp\X) +  ", " + Str$(*mp\Y) + " - "
  ;msg$ + Str$(*mp\textX) + ", " + Str$(*mp\textY)
  ;msg$ + " / storeXY: " + Str$(storeX.w) + ", " + Str$(storeY.l)
  ;PED_ShowMessage{msg$}
End Statement


Statement AbsDimensions{*bm.bmark}

  If *bm\yMin < *bm\yMax Then Statement Return

  If (*bm\yMin = *bm\yMax) OR (*bm\xMin > *bm\xMax)
    Exchange *bm\xMin,*bm\xMax
    Exchange *bm\yMin,*bm\yMax
  EndIf

End Statement

Statement PED_DrawBlock{*bmark.bmark, ColumnsOffset.w} ;xMin.w,yMin.w, xMax.w, yMax.w, absolute.b}
SHARED sourceWindow

  CopyType *bmark,bm.bmark
  ;msg$ = "PED_DrawBlock() 1 called: "
  ;msg$ + Str$(bmark\xMin) + ", " + Str$(bmark\yMin) + " - "
  ;msg$ + Str$(bmark\xMax) + ", " + Str$(bmark\yMax)
  ;log_Print{msg$}

  If bm\xMin < 0 Then bm\xMin = 0
  If bm\xMax < 0 Then bm\xMax = 0 : Else : bm\xMax + 1
  If bm\yMin < 0 Then bm\yMin = 0
  If bm\yMax < 0 Then bm\yMax = 0

  bm\xMax - ColumnsOffset
  bm\xMin - ColumnsOffset

  If bm\xMax > \visibleColumns Then bm\xMax = \visibleColumns
  If bm\yMax > \visibleLines - 1 Then bm\yMax = \visibleLines - 1
  If bm\yMin > \visibleLines - 1 Then bm\yMin = \visibleLines - 1

  bm\xMin * \font\tf_XSize
  bm\yMin * \font\tf_YSize
  bm\xMax * \font\tf_XSize
  bm\yMax * \font\tf_YSize

  If bm\yMin > bm\yMax Then Exchange bm\yMax,bm\yMin
  If bm\xMin > bm\xMax Then Exchange bm\xMax,bm\xMin

  If bm\yMin = bm\yMax
    bm\yMax = bm\yMax + \font\tf_YSize - 1
    Gosub rectfill2
  Else
    ; draw three parts of the block: first line, block of full marked lines, last line
    DEFTYPE.bmark bmOld
    CopyType bm, bmOld

    bm\yMax = bm\yMin + \font\tf_YSize - 1
    bm\xMax = \visibleColumns * \font\tf_XSize
    Gosub rectfill2

    CopyType bmOld, bm

    bm\yMin = bm\yMin + \font\tf_YSize
    If bm\yMin < bm\yMax
        CopyType bm, bmOld
        bm\xMin = 0
        bm\xMax = \visibleColumns * \font\tf_XSize
        bm\yMax - 1
        Gosub rectfill2

        CopyType bmOld,bm
        bm\xMin = 0
        bm\yMin = bm\yMax
    EndIf

    bm\xMin = 0
    bm\yMax + \font\tf_YSize - 1
    Gosub rectfill2
  EndIf

  ;msg$ = "PED_DrawBlock() 2 called: "
  ;msg$ + Str$(bm\xMin) + ", " + Str$(bm\yMin) + " - "
  ;msg$ + Str$(bm\xMax) + ", " + Str$(bm\yMax)
  ;log_Print{msg$}

  Statement Return

  rectfill2:
  If (bm\xMax >= bm\xMin) AND (bm\yMax >= bm\yMin)
    sourceWindow\rp\Mask = %1111
    RectFill_ sourceWindow\rp, sourceWindow\BoxLeft + bm\xMin, sourceWindow\BoxTop + bm\yMin, sourceWindow\BoxLeft + bm\xMax - 1, sourceWindow\BoxTop + bm\yMax
  EndIf
  Return
End Statement


Statement window_welcome{txt0.s,@txt1.s,@txt2.s,@txt3.s,@txt4.s,@txt5.s,@txt6.s}
 SHARED pedconfig
  pngimage.l = -1
  ; -- es kommt zu einem Enforcerhit beim beenden von Amiblitz3, wenn dieses Fenster geoeffnet wurde !??
  Gosub set_pointer_busy_bas
  WZ_LockAllOpenWindows{}                                                                                                                                                                                                                                

  WZWindow WZID("WIN_WELCOME"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_WELCOME")

  If (txt0 <> "")
    sharp.b = Instr(txt0,"#")
    vlen.b = FLen(txt0)
    pv.s = Left$(txt0,sharp - 1)
    cv.s = Right$(txt0,vlen - sharp)
    WZPrint "PED",&pv
    WZPrint "COMPILER",&cv
  EndIf

  If (txt1 <> "") AND (txt2<>"")
    WZPrint "TEXT1",&txt1
    WZPrint "TEXT2",&txt2
  EndIf

  ltxt1.s = "BaseLibs:" : WZPrint "LACIDLIBS_TEXT",&ltxt1
  WZPrint "ACIDLIBS_TEXT",&txt3
  ltxt2.s = "UtilLibs:" : WZPrint "LDEFLIBS_TEXT",&ltxt2
  WZPrint "DEFLIBS_TEXT",&txt4
  ltxt3.s = "OsLibs:" : WZPrint "LOSLIBS_TEXT",&ltxt3
  WZPrint "OSLIBS_TEXT",&txt5
  ltxt4.s = "CsLibs:" : WZPrint "LCSLIBS_TEXT",&ltxt4
  WZPrint "CSLIBS_TEXT",&txt6


  welcome_Exit.b = False
  Repeat
    welcome_ev.l = WaitEvent

    Select welcome_ev
    Case #IDCMP_VANILLAKEY:
      ;error{"VAN: " + Hexw$(EventCode)}
      If EventCode = #VANILLAKEY_ESC Then welcome_Exit = True

    Case #IDCMP_IDCMPUPDATE
      If WZGadName = "WELCOME_OK" Then welcome_Exit = True

    Case #IDCMP_CLOSEWINDOW
      welcome_Exit = True

    End Select
  Until welcome_Exit

  WZCloseWindow WZID("WIN_WELCOME")
  FlushEvents

  Gosub activatesourcewindow
  WZ_UnlockAllOpenWindows{}
  Gosub set_pointer_normal_bas
End Statement


Function.w getLineLength{lineaddr.l}
  _length.w = #MAX_Columns - 1
  exit_loop.b = False
  ;log_Print{"**" + Peeks$(lineaddr,_length) + "**"}
  Repeat
    char.b = Peek.b(lineaddr + _length)
    If char <> $20
      exit_loop = True
    Else
      _length - 1
    EndIf
  Until exit_loop OR _length < 1
  _length + 1
  ;log_Print{Str$(_length)}
  ;!log_AvailMemhex{lineaddr,255}
  Function Return _length
End Function

Function.b cutLine{*sl.sourceLine}                              ; remove the current line out of linked list
SHARED ped
    *prevLine.sourceLine = *sl\previousLine
    *nextLine.sourceLine = *sl\nextLine
    If (*prevLine = 0) AND (*nextLine = 0)
      Function Return False
    End If

    ; clear old references to other lines
    *sl\previousLine = 0
    *sl\nextLine = 0

    ; connect previous and next line to cut current line off and update firstline if the firstline has been cut
    If *prevLine <> 0
      *prevLine\nextLine = *nextLine
    Else
      ped\ptrCurrentSourceData\FirstSourceLine = *nextLine
    EndIf
    If *nextLine <> 0 Then *nextLine\previousLine = *prevLine

    Function Return True
End Function

Statement appendLine{*afterLine.sourceLine, *newLine.sourceLine}
SHARED ped
  ; insert a new line into the linked list, previous/nextLine of *newLine is null

  ; afterLine:  the line to append the newLine to
  ; newLine  :  the line to append after the afterLine

  If *afterLine = 0                           ; previous line has no previous line
    log_Print{"line to append to has no previousline, setting appendline as first sourceline"}

    *exfirstLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
    *exfirstLine\previousLine = *newLine
    *newLine\nextLine = *exfirstLine

    ped\ptrCurrentSourceData\FirstSourceLine = *newLine

  Else
    *nextLine.sourceLine = *afterLine\nextLine        ; get the old nextline
    If *nextLine
      *nextLine\previousLine = *newLine
      *newLine\nextLine = *nextLine
    Else
      ped\ptrCurrentSourceData\LastSourceLine = *newLine
    EndIf
    *newLine\previousLine = *afterLine
    *afterLine\nextLine = *newLine
  EndIf
End Statement

Function.w PED_SearchString{searchStr.s, casesensitive.b, startpos.w, *currentLine.sourceLine}
SHARED ped,*PreProcessor

  strline$ = Peek.s(*currentLine+9)
  If FLen(strline$) = 0 Then Function Return 0

  If ped\DoTokenize
    MaxLen linebuff$ = 256
    preproc_Detokenize{*PreProcessor,&strline$,&linebuff$,FLen(strline$)}
    strline$ = Peek.s(&linebuff$)
  EndIf

  ;log_Print{"detokenized: " + strline$}
  ;log_Print{"length: " + Str$(FLen(strline$))}
  ;log_Print{"search for [" + searchStr + "] in line [" + strline$ + "]"}
  If casesensitive Then CaseSense True Else CaseSense False

  Function Return Instr(strline$, searchStr, startpos)
End Function

Function.b PED_ReplaceString{search.s, replacement.s, *currentLine.sourceLine}
SHARED ped,*PreProcessor,sourceWindow

  success.b = False

  tmpX.w = PED_SearchString{search, 0, 1, *currentLine}
  ;log_Print{"search for line complete."}
  If tmpX > 0
    strline.s = Peek.s(*currentLine+9)

    If ped\DoTokenize
      MaxLen linebuff$ = 256
      preproc_Detokenize{*PreProcessor,&strline.s,&linebuff$,FLen(strline)}
      strline.s = StripTrail$(Peek.s(&linebuff$),$20)
    EndIf

    replacedline.s = Replace$(strline,search,replacement)
    ;log_Print{"length after replace: " + Str$(FLen(replacedline))}
    If ped\DoTokenize
      MaxLen linebuff$ = 256
      ; process the ascii data in sourcebuff length and write the tokenized source into destbuffer
      ; the return value is the length of the tokenized text
      ; sourcebuff and destbuff might be the same pointer
      ; preproc_Tokenize{*tn.preprocessor,sourcebuff.l,destbuff.l,bytelength.l}
      preproc_Tokenize{*PreProcessor,&replacedline.s,&linebuff$,FLen(replacedline)}
      replacedline.s = Peek.s(&linebuff$)
    EndIf

    If FLen(replacedline) < #MAX_Columns Then replacedline + SPACE$(#MAX_Columns - FLen(replacedline))
    If FLen(replacedline) > #MAX_Columns Then replacedline = Left$(replacedline,#MAX_Columns)

    *previousLine.sourceLine = *currentLine\previousLine
    If cutLine{*currentLine}
      *newLine.sourceLine = PED_CreateNewSourceLine{replacedline}
      appendLine{*previousLine,*newLine}
      PED_FreeMem{*currentLine}
      ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
      success = True
    Else
      error{"Could not replace the current source line"}
    EndIf
  EndIf
  Function Return success
End Function




Function.s check_constructs{*currentline.sourceLine}    ; fixed this function  tomsmart1

  If *currentline = 0 Then Function Return ""

  construct.s = ""

  *prevLine.sourceLine = *currentline\previousLine

  If *prevLine >< Null
    *textline.l = *prevLine + 9     ; get pointer of previus sourceline text
    If *textline >< Null
      textaddr.l = Peek.l(*textline)           ; get address of the text
      bytecount.w = 0

      While (textaddr LSR 16) <> $0000
        textaddr = Peek.l(*textline + bytecount)

        actword.w = textaddr LSR 16

        ; check the token too select the end token(s)
        Select actword
          Case #TOKEN_Then      : construct = ""
          Case #TOKEN_Statement : construct = "End Statement"
          Case #TOKEN_Function  : construct = "End Function"
          Case #TOKEN_If        : construct = "EndIf"
          Case #TOKEN_While     : construct = "Wend"
          Case #TOKEN_Macro     : construct = "End Macro"
          Case #TOKEN_Select    : construct = "End Select"
          Case #TOKEN_Repeat    : construct = "Until"
          Case #TOKEN_For       : construct = "Next"
        End Select
        bytecount + 1
      Wend
    EndIf
  EndIf

  Function Return construct
End Function

Function.w preparseline{columnpos.w,lineaddr.l,auto_format.b,correct_funcnames.b}
  SHARED operators$(),num_operators

  ; clear highlight info but dont trash strings
  ;If (lineaddr MOD 2) <> 0 Then !cout{"alert: odd address " + Hex$(lineaddr)}
  If (lineaddr & $1) <> 0 Then !cout{"alert: odd address " + Hex$(lineaddr)}
  nostring.b = 0
  For i.l = lineaddr To lineaddr + #MAX_Columns
    If nostring = 0
      Poke.b i,Peek.b(i) AND $7f
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
    If Peek.b(i) = $22 Then nostring = 1
    ; workaround:
    ; sometimes there is a 0 in a linestring perhaps due
    ; to a wrong lineaddr
    ; the 0 is been replaced by a space
    If Peek.b(i) = 0 Then Poke.b i,32
  Next

  strg$ = Peeks$(lineaddr,#MAX_Columns) ; check this, was Peeks$$ before!

  ; --
  ; -- checking if editing a comment
  test_semi$ = StripLead$(strg$,@" ")
  kommata.w  = Instr(test_semi$,";")
  If kommata AND (kommata < columnpos) Then Function Return columnpos

  len_strg.w = StrLen(StripTrail$(strg$,@" ") )

  line_changed.b = False

  ; --
  ; -- replace lower written functionames with correct cases
  If correct_funcnames
    correctpos.w = 0                                               ; added to make a test of the complete line and begin at position 0  tomsmart1
    Repeat                                                         ; added loop to test the complete line  tomsmart1
      correctklammer.w = 0                                         ; added to clear it every loop entry and renamed it to make it unique  tomsmart1
      correctklammer   = Instr(strg$,"{",correctpos) - 1           ; expand search command to begin search at a spezific position  tomsmart1

      If correctklammer > 0
        run_left.l = -1

       again:
        Repeat
          run_left + 1
          char.l = Asc( Mid$(strg$,correctklammer - run_left,1) )
        Until ( ( (char<65) AND (char<>33) AND ( (char<48) OR (char>57) ) ) OR (char>122) OR ( (char>90) AND (char<95) ) OR (run_left >= correctklammer) )
        If (char = Asc(" ") AND run_left = 0) Then Goto again
        ; ! = 33
        ; 0 = 48; 9 = 57
        ; A = 65, Z = 90
        ; a = 97, z = 122
        funcname$ = StrSub(strg$,correctklammer - run_left + 1,run_left)
        funcname$ = StrChg(funcname$," ","")
        newfuncname$ = PED_GetIncludeFunction{funcname$}
        If newfuncname$<>""
          strg$ = StrChg(strg$,funcname$,newfuncname$)
          line_changed = True
        EndIf
        correctpos = correctklammer + 2                           ; added to let the next test begin at behind the first find position  tomsmart1
        If correctpos >= FLen(strg$) Then correctklammer = -1     ; added to test if we are in the string/line if not set the exit loop condition  tomsmart1
      EndIf
    Until correctklammer = -1                                     ; added loop to test the complete line  tomsmart1
  EndIf 

  ; structurization of source
  If auto_format
    neustrg$ = ""
    make_struct.b = On
    For j.w = 1 To len_strg
      double_operator.b = False
      temp_disabled.b = Off
      no_pre_pad.b = Off
      no_post_pad.b = Off
      comment_mode.b = Off

      char$ = Mid$(strg$,j,1)
      If char$<>" "
        For k.w = 0 To num_operators-1
          If char$ = operators$(k)
            For l.w = 0 To num_operators - 1
              If last_op$ = operators$(l) Then double_operator = True
            Next
            If NOT double_operator
              op_found.b = True
              Pop For
              Goto exit_for
            EndIf
          Else
            op_found = False
          EndIf
        Next k
        exit_for:
        If char$ = Chr$(34) Then make_struct = -1 + Abs(make_struct)

        If (op_found = True) AND (last_op$ <> "=")
          last_op$ = char$

          Select char$
            Case ";"      ; innerhalb von Kommentaren nicht strukturieren
              comment_mode = On

            Case "-"      ; eine Zuweisung mit neg. Wert nicht formatieren
              If Mid$(strg$,j - 2,2) = "= " OR Mid$(strg$,j - 1,1) = "="
                temp_disabled = On
              EndIf

            Case "<"
              If Mid$(strg$,j-2,2) = "> " OR Mid$(strg$,j-1,1)=">"
                no_pre_pad = On
              EndIf
              If Mid$(strg$,j+2,2) = "> " OR Mid$(strg$,j+1,1)=">"
                no_post_pad = On
              EndIf

            Case ">"
              If Mid$(strg$,j-2,2) = "< " OR Mid$(strg$,j-1,1)="<"
                no_pre_pad = On
              EndIf
              If Mid$(strg$,j+2,2) = "< " OR Mid$(strg$,j+1,1)="<"
                no_post_pad = On
              EndIf

          End Select

          If make_struct AND (j > 1) AND (NOT temp_disabled) AND (NOT comment_mode = On)
            pad_pre$ = "" : pad_post$ =""
            If Mid$(strg$,j - 1,1) <>" " Then pad_pre$  = " " : columnpos + 1
            If Mid$(strg$,j + 1,1) <>" " Then pad_post$ = " " : columnpos + 1
            If no_pre_pad                Then pad_pre$  = ""  : columnpos - 1
            If no_post_pad               Then pad_post$ = ""  : columnpos - 1
            char$ = pad_pre$ + char$ + pad_post$
            line_changed = True
          EndIf
        Else
          last_op$ = ""
        EndIf
      EndIf
      neustrg$ + char$
    Next j
    strg$ = neustrg$
  EndIf

  ; --- write formated textline into textbuffer
  If line_changed
    strg$ = StrLeft(strg$,#MAX_Columns,32)
    For i.l = lineaddr To lineaddr + (#MAX_Columns - 6)
      achar.b = Asc(Mid$(strg$,i + 1 - lineaddr,1))
      Poke.b i,achar
    Next
  EndIf

  ; --- return new cursorposition if something as changed
  Function Return columnpos
End Function


Statement savewinpref{layoutNum.l}
  SHARED wpref(),wtemp,pedconfig,sourceWindow

  used_win.l = Used Window
  ret.l = ask{!TRANS{"The window settings have been saved.\\nPress appropriate FN-Key (F4-F6) to set window configuration."},!TRANS{"Ok"},!TRANS{"Info"}}
  USEPATH wtemp

  \lbrowser_on = 0
  \ibrowser_on = 0
  \type_on = 0
  \diag_on = 0
  \click_on = 0
  \short_on = 0
  \activewin = 0

  If WZ_CheckOpen{"WIN_LIBRARYBROWSER"}
     Use Window WZID("WIN_LIBRARYBROWSER")
     \lbrowser_x  = WindowX
     \lbrowser_y  = WindowY
     \lbrowser_w  = WindowWidth
     \lbrowser_h  = WindowHeight
     \lbrowser_on = 1
  End If
  If WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"}
     Use Window WZID("WIN_INSTRUCTIONBROWSER")
     \ibrowser_x  = WindowX
     \ibrowser_y  = WindowY
     \ibrowser_w  = WindowWidth
     \ibrowser_h  = WindowHeight
     \ibrowser_on = 1
  End If
  If WZ_CheckOpen{"WIN_NEWTYPE"}
     Use Window WZID("WIN_NEWTYPE")
     \type_x  = WindowX
     \type_y  = WindowY
     \type_w  = WindowWidth
     \type_h  = WindowHeight
     \type_on = 1
  End If
  If WZ_CheckOpen{"WIN_HELPDIAG"}
     Use Window WZID("WIN_HELPDIAG")
     \diag_x  = WindowX
     \diag_y  = WindowY
     \diag_w  = WindowWidth
     \diag_h  = WindowHeight
     \diag_on = 1
  End If
  If WZ_CheckOpen{"WIN_LABELS"}
     Use Window WZID("WIN_LABELS")
     \click_x  = WindowX
     \click_y  = WindowY
     \click_w  = WindowWidth
     \click_h  = WindowHeight
     \click_on = 1
  End If
  If WZ_CheckOpen{"WIN_SHORTCUTS"}
     Use Window WZID("WIN_SHORTCUTS")
     \short_x  = WindowX
     \short_y  = WindowY
     \short_w  = WindowWidth
     \short_h  = WindowHeight
     \short_on = 1
  EndIf

  If sourceWindow\win
    \source_x = sourceWindow\win\LeftEdge
    \source_y = sourceWindow\win\TopEdge
    \source_w = sourceWindow\win\Width
    \source_h = sourceWindow\win\Height
  EndIf

  ; -- check if console is open and store its position
  *thisscreen.Screen = Peek.l(Addr Screen(0))
  *conwin.Window = *thisscreen\FirstWindow
;  message{"error"}
  security.l = 0
  If *conwin
    While *conwin <> 0
      If Peek$(*conwin\Title) <> pedconfig\console_title
        If Peek.l(*conwin) Then *conwin = Peek.l(*conwin) Else *conwin = 0
      Else
        Pop While
        Goto exit_consearch
      EndIf
      ; notbremse fuer while-loop
      security + 1
      If security > 30 Then *conwin = 0
    Wend
  EndIf
  exit_consearch:
  If *conwin
    \console_x = *conwin\LeftEdge
    \console_y = *conwin\TopEdge
    \console_w = *conwin\Width
    \console_h = *conwin\Height
  EndIf
  Use Window used_win
  CopyMem_ &wtemp,&wpref(layoutNum),SizeOf .winprefs
End Statement


Statement write_libmapping{_file.s}
  SHARED lib_mapping$()

  If dos_Exist{_file} Then dos_Delete{_file}

  fid.l = file_Open{_file,#file_write}
  If fid<>-1
    log_Print{"writing libslist..."}
    For i.w = 0 To #Max_BlitzLibs-1
      textline.s = StrLeft(lib_mapping$(i,0),31,Asc(" ")) + ";" + lib_mapping$(i,1)
      file_WriteLine{fid,textline}
    Next i
    file_Close{fid}
  EndIf

End Statement


Statement read_libmapping{_file.s}
  SHARED *tokenbase.tokeninfo
  SHARED lib_mapping$()

  Dim templist$(#Max_BlitzLibs,1)
  DEFTYPE.w libcounter,i

  fid.l = file_Open{_file,#file_read}
  If fid<>-1
    file_Cache{fid}
    log_Print{"loading libslist..."}
    Repeat
      zeile$ = file_ReadLine{fid}
      qpos.w = Instr(zeile$,";")
      If qpos
        lstring$ = Left$(zeile$,qpos-1)
        rstring$ = Right$(zeile$,FLen(zeile$)-qpos)

        ; get libnumber from internal structure
        templist$(libcounter,0) = StrChg(lstring$," ","")
        templist$(libcounter,1) = StrChg(rstring$," ","")
        libcounter + 1
      EndIf
    Until file_EOF{fid}
    file_Close{fid}
    If libcounter = 0 Then Statement Return

    log_Print{"scanning tokenlist..."}
    *tpointer.l = *tokenbase
    If *tpointer
      Repeat
        token_next.l   = Peek.l(*tpointer)
        token_name$    = Peek$(*tpointer+6)
        libnum.w = Peek.w(*tpointer+4) LSR 7

        For i = 0 To libcounter
          If templist$(i,1) = token_name$
            If libnum > 0
              libname$ = templist$(i,0)
              firsttoken$ =  templist$(i,1)
              If (Instr(lib_mapping$(libnum,0),"unused")=0)
                message$= !TRANS{"Library clash!\\n" }
                message$+ !TRANS{"The dynamic added lib"}+" \\22"+libname$+"\\22\\n"
                message$+ !TRANS{"has overwritten"}+" \\22"+lib_mapping$(libnum,0)+"\\22 "+!TRANS{"stored in acidlibs/deflibs"}+".\\n"
                message$+ !TRANS{"Both libs have the same Lib-ID"}+" "+ Str$(libnum)+".\\n\\n"
                message$+ !TRANS{"Sourcecode that uses"}+" "+ lib_mapping$(libnum,0) + " "+!TRANS{"might not work,\\n"}
                message$+ !TRANS{"because these functions are now mapped to"}+" "+libname$+".\\n\\n"
                message$+ !TRANS{"You should remove the appropriate library from userlibs-directory,\\nor change the Lib-ID to a free one."}
                dummy.l = ask{message$,!TRANS{"Ok"},!TRANS{"Error"}}
                lib_mapping$(libnum,0) = libname$ + " ("+!TRANS{ "clashing with"}+" "+lib_mapping$(libnum,0)+")"
              Else
                lib_mapping$(libnum,0) = libname$
              EndIf
              lib_mapping$(libnum,1) = firsttoken$
              Pop If : Pop If : Pop For : Goto exit_this_loop
            EndIf
          EndIf
        Next i
        exit_this_loop:

        *tpointer.l = token_next
      Until (*tpointer = 0)
      log_Print{"scanning finished."}
    EndIf
  EndIf
End Statement


Statement map_tokens_to_libs{_file.s}
  SHARED *tokenbase.tokeninfo
  SHARED lib_mapping$()

  fid.l = file_Open{_file,#file_read}
  If fid<>-1
    ; check content of file, if there is only little garbage, then ignore it
    If file_GetLength{fid} < 5
      file_Close{fid}
      Statement Return
    EndIf

    log_Print{"building hashmap..."}
    *hm.hashmap = hashmap_Create{8}
    file_Cache{fid}
    lineCounter.w = 0
    Repeat
      zeile$ = file_ReadLine{fid}
      qpos.w = Instr(zeile$,";")
      If qpos
        lstring$ = Left$(zeile$,qpos-1)
        rstring$ = Right$(zeile$,FLen(zeile$)-qpos)

        ; get libnumber from internal structure
        libname$ = Trim$(lstring$)
        firsttoken$ = StrLower(Trim$(rstring$))
        If firsttoken$ <> ""
          hashmap_AddItem{*hm, firsttoken$, libname$}
        Else
          ; set the libname directly, as there is no token to map
          lib_mapping$(lineCounter,0) = libname$
        EndIf

        ;If linecounter < 138 AND linecounter >130
        ;log_Print{Str$(linecounter) + ":adding token [" + firsttoken$ + "] with libname [" + libname$ + "]"}
        ;EndIf
      EndIf
      lineCounter + 1
    Until file_EOF{fid}
    file_Close{fid}
    log_Print{"building hashmap done."}
 
    ; running through the tokenindex and map tokens to library names
    log_Print{"scanning tokenlist..."}
    *tpointer.l = *tokenbase
    If *tpointer
      libCounter.w = 0
      oldlibnum.w = -1
      Repeat
        libname$ = ""

        token_next.l   = Peek.l(*tpointer)
        token_name$    = Peek.s(*tpointer+6)
        libnum.w       = Peek.w(*tpointer+4) LSR 7

        If token_name$ = ""
          log_Print{ "#" + Str$(libnum) + ": nulltoken found"}
        EndIf

        If  (libnum <> oldlibnum) AND token_name$<>""
          libCounter + 1
          oldlibnum = libnum

          ; check if token is first token of a blitzlib
          libname$ = hashmap_GetItem{*hm, StrLower(token_name$)}
          ;log_Print{"#"+Str$(libnum) + " [" + libname$ + "] -  first token [" + token_name$ + "]"}


          ; check if token is part of library, that is already used
          ; if libnum is unused, map libname to libnum
          ; if a libnum appears, here a libname has been mapped, we have a libclash!
          If libname$ = ""
            log_Print{"could not identify libnum #" + Str$(libnum)+ " with first token [" + token_name$ + "]"}
          Else
            ;log_Print{"first token of library #" + Str$(libnum) + " [" + libname$ + "]: [" + token_name$ + "]"}

            If Instr(lib_mapping$(libnum,0),"unused") = 0
              log_Print{"lib has already been mapped!",#log_warning}
              message$ = !TRANS{"Library clash!\\n" }
              message$ + !TRANS{"The dynamic added blitzlib"} + " \\22" + libname$ + "\\22 " + !TRANS{"overwrites the already loaded blitzlib "} + " \\22" + lib_mapping$(libnum,0)+"\\22\\n\\n"

              message$ + !TRANS{"Both libs have the same Lib-ID"} + " #"+ Str$(libnum) + ".\\n\\n"

              message$ + !TRANS{"Sourcecode that uses that blitzlib might not work, because these functions are now mapped to"} + " \\22" + libname$ + "\\22.\\n"

              message$ + !TRANS{"You should remove the appropriate library from userlibs-directory,\\nor change the Lib-ID to a free one."}
              dummy.l = ask{message$,!TRANS{"Ok"},!TRANS{"Error"}}
              lib_mapping$(libnum,0) = libname$ + " ("+!TRANS{ "clashing with"}+" "+lib_mapping$(libnum,0)+")"
            Else
              lib_mapping$(libnum,0) = libname$
            EndIf
            lib_mapping$(libnum,1) = token_name$
          End If
        EndIf
        *tpointer.l = token_next
      Until (*tpointer = 0)
      log_Print{"scanning tokenlist done, processed " + Str$(libCounter) +" libs"}

;      write_libmapping{_file}    ; update the token_mapping file
    EndIf
    hashmap_Free{*hm}
  EndIf
End Statement


Function.l AutoLayout{*wprefs.winprefs,mode.l}
  SHARED sourceWindow, pedconfig
  USEPATH *wprefs
  *scr.Screen = Peek.l(Addr Screen(0))
  If *scr=0 Then Function Return False
;  WZ_KillTable{"INSTRUCTIONBROWSER"}
;  ClearMenuStrip_ Peek.l(Addr Window(WZID("WIN_INSTRUCTIONBROWSER")))
;  WZCloseWindow WZID("WIN_INSTRUCTIONBROWSER")
  top.l    = *scr\BarHeight +1 + pedconfig\al_topspace
  bottom.l = *scr\Height-1     - pedconfig\al_bottomspace
  left.l   = 0                 + pedconfig\al_leftspace
  right.l  = *scr\Width-1      - pedconfig\al_rightspace

  lock.l = LockIBase_ (0)
    *myWindow.Window = *scr\FirstWindow

    While *myWindow
      rx.l = *myWindow\Width/*myWindow\Height
      ry.l = *myWindow\Height/*myWindow\Width
      ;If *myWindow\Title Then rx=1 : ry=1
      If *myWindow\Flags&#WFLG_BORDERLESS = 0 Then rx=1 : ry=1
      If rx>2
        If *myWindow\TopEdge+*myWindow\Height-1 >= bottom
          bottom = Min(bottom,*myWindow\TopEdge-1)
        End If
        If *myWindow\TopEdge<*scr\BarHeight
          top    = Max(top,*myWindow\TopEdge+*myWindow\Height)
        End If
      End If

      If ry>2
        If *myWindow\LeftEdge+*myWindow\Width-1 >= right
          right = Min(right,*myWindow\LeftEdge-1)
        End If
        If *myWindow\LeftEdge<=0
          left  = Max(left,*myWindow\LeftEdge+*myWindow\Width)
        End If
      End If
      *myWindow = *myWindow\NextWindow
    Wend

  UnlockIBase_ lock

  width.l  = right-left+1
  height.l = bottom-top+1


  Select mode
    Case 0    ; Layout A
      splitpointY.l  = (bottom-top) * 3/4
      splitpointX.l  = (right-left) * 3/4

      If splitpointY<700              Then splitpointY=height
      If (right-left)-splitpointX<250 Then splitpointX=right-left-250

      ;\source_on   = True            ; source code window
      \source_x    = left,top,splitpointX,splitpointY
      sourceWindow\WinLeft  = left,top,splitpointX,splitpointY
      ;Poke.w ?win_TopLeft,\source_x
      ;Poke.w ?win_TopEdge,\source_y
      ;Poke.w ?win_Width  ,\source_w
      ;Poke.w ?win_Height ,\source_h
      If (splitpointY<bottom-top+1)
        If (splitpointX>1024)
          \ibrowser_on = True        ; Instruction Browser
          \ibrowser_x  = left,(top+splitpointY),(splitpointX/2),bottom-(top+splitpointY)+1
          \lbrowser_on = True
          \lbrowser_x  = left+splitpointX/2,(top+splitpointY),splitpointX-(splitpointX/2),bottom-(top+splitpointY)+1
        Else
          \ibrowser_on = True        ; Instruction Browser
          \ibrowser_x  = left,(top+splitpointY),(splitpointX),bottom-(top+splitpointY)+1
          \lbrowser_on = False
        End If
      Else
        \lbrowser_on = False
        \ibrowser_on = False
      End If
      \click_on    = True            ; Source Browser
      \click_x     = (left+splitpointX),top,width-splitpointX,height*3/5
      \type_on     = True            ; Definition Browser
      \type_x      = (left+splitpointX),(top+height*3/5),width-splitpointX,bottom-((height)*3/5)+1-top

      If splitpointY<height
        \console_x   = left,(top+splitpointY),splitpointX,height-splitpointY
      Else
        \console_x   = left,(top),splitpointX,height
      End If

    Case 1    ; Layout B
      splitpointX1.l  = (width)  * 1/4 : If splitpointX1<400       Then splitpointX1=400
      splitpointX2.l  = (width)  * 3/4 : If width-splitpointX2<250 Then splitpointX2=width-250
      splitpointY.l   = (height) * 3/5

      If splitpointX2-splitpointX1<320 Then splitpointX1=0 ;: splitpointX2.l  = (right-left) * 1/3
      If splitpointY <400              Then splitpointY=0

      ;\source_on   = True ; source code window
      \source_x    = left+splitpointX1,top,splitpointX2-splitpointX1,height
      sourceWindow\WinLeft = left+splitpointX1,top,splitpointX2-splitpointX1,height
      ;Poke.w ?win_TopLeft,\source_x
      ;Poke.w ?win_TopEdge,\source_y
      ;Poke.w ?win_Width  ,\source_w
      ;Poke.w ?win_Height ,\source_h

      If (splitpointX1>0)
        If (splitpointY>0)
          \ibrowser_on = True ; Instruction Browser
          \ibrowser_x  = left,top,splitpointX1,splitpointY
          \lbrowser_on = True
          \lbrowser_x  = left,top+splitpointY,splitpointX1,height-splitpointY
        Else
          \ibrowser_on = True ; Instruction Browser
          \ibrowser_x  = left,top,splitpointX1,height
          \lbrowser_on = False
        End If
      Else
        \lbrowser_on = False
        \ibrowser_on = False
      End If
      If (splitpointY>0)
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX2 ,top,width-splitpointX2,splitpointY
        \type_on     = True ; Definition Browser
        \type_x      = left+splitpointX2 ,top+splitpointY,width-splitpointX2,height-splitpointY
      Else
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX2,top,width-splitpointX2,height
        \type_on     = False ; Definition Browser
      End If
      \console_x    = left,(top+splitpointY),width,height-splitpointY

    Case 2    ; Layout C
      splitpointX.l  = (width) * 3/4 : If width-splitpointX<250 Then splitpointX=width-250
      splitpointY.l  = (height) * 3/5
      If splitpointY <400 Then splitpointY=0

      ;\source_on   = True ; source code window
      \source_x    = left,top,splitpointX,height
      sourceWindow\WinLeft  = left,top,splitpointX,height
      ;Poke.w ?win_TopLeft,\source_x
      ;Poke.w ?win_TopEdge,\source_y
      ;Poke.w ?win_Width  ,\source_w
      ;Poke.w ?win_Height ,\source_h

      \lbrowser_on = False
      \ibrowser_on = False

      If (splitpointY>0)
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX ,top,width-splitpointX,splitpointY
        \type_on     = True ; Definition Browser
        \type_x      = left+splitpointX ,top+splitpointY,width-splitpointX,height-splitpointY
      Else
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX,top,width-splitpointX,height
        \type_on     = False ; Definition Browser
      End If
      \console_x   = left,(top+splitpointY),width,height-splitpointY


  End Select
  USELASTPATH
  Function Return True
End Function


Statement CloseAllWZWindows{}                    ; made a Statement to close all (used) Wizard Windows to remove double code  tomsmart1
  Gosub close_contexthelp
  Gosub close_popupwindow
  WZ_HideHelp{}                                  ; added because it used for the wz_contexthelp
  Gosub kill_menus                               ; moved in that everytime tis statment are called the menues are detached fom the wz windows  tomsmart1
  ; windows with menu added
  WZCloseWindow WZID("WIN_INSTRUCTIONBROWSER")
  WZCloseWindow WZID("WIN_NEWTYPE")
  WZCloseWindow WZID("WIN_LABELS")
  WZCloseWindow WZID("WIN_LIBRARYBROWSER")
  WZCloseWindow WZID("WIN_SEARCH")
  WZCloseWindow WZID("WIN_SHORTCUTS")
  WZCloseWindow WZID("WIN_HELPDIAG")
  ; windows with no menu added
  WZCloseWindow WZID("WIN_AUTODOC")
  WZCloseWindow WZID("WIN_HELP")
  WZCloseWindow WZID("WIN_SETTINGS")
End Statement


; Added the menu to the open WZ window
Statement AddedMenu2WZWin{wzwinname.s}
  Use Window WZID(wzwinname)
  If Peek.l(?addr_menustrip)
    SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
  EndIf
End Statement

; Remove the menu and than close WZ window
Statement CloseWZWinWithMenu{wzwinname.s}
  winid.l = WZID(wzwinname)
  If Addr Window(winid) <> 0
    If Peek.l(?addr_menustrip)
      ClearMenuStrip_ Peek.l(Addr Window(winid))
    EndIf
    WZCloseWindow winid
  EndIf
End Statement


Statement PED_CloseFile{fh.l}
  SHARED ped,readcache
  If fh <> 0
    log_Print{"closing file handle: " + Hex$(fh)}
    Close_ fh : ped\sourceFileHandle = 0
    If readcache\cacheptr
      FreeVec_ readcache\cacheptr
      readcache\cacheptr = Null
      readcache\cachelen = 0
      readcache\readlen = 0
      readcache\chunklen = 0
      readcache\filelen = 0
      ;ClearType readcache
    EndIf
  Else
    log_Print{"file already closed at " + Hex$(fh)}
  EndIf
End Statement

Function.l PED_OpenFile{ofname.s, accessmode.l, menuload.b}
SHARED ped, pedconfig

  ped\convert = False

  ;If fname$="" Then fname$ = ped\sourceFileComplete
  log_Print{"open_file <" + ofname + ">"}

  ; -- check extension
  fext.s = LCase$(dos_GetExt{ofname})
  log_Print{"checking file extention of file: " + ofname + " [" + fext + "]"}
  log_Print{"smart tok: " +Str$(pedconfig\smart_tokenization)}
  log_Print{"do tok: " + Str$(ped\DoTokenize)}
  If pedconfig\smart_tokenization <> 0
    If fext = "bb2" OR fext = "ab2" OR fext = "ab3" OR fext = "bb"
      log_Print{"activating tokenization"}
      ped\DoTokenize = $FFFF
;      ped\flag_tokenization = $FFFF
    Else
;      If fext = "txt" OR fext = "guide"
        log_Print{"deactivating tokenization"}
        ped\DoTokenize = False
;        ped\flag_tokenization = False
        If fext = "guide" Then ped\amigaguide = True
;      EndIf
    EndIf
  EndIf

  If fext = "asm"
    log_Print{"it seems to be an asm file, tokenization and conversion mode is active."}
    If pedconfig\smart_tokenization Then ped\DoTokenize = $FFFF
    ped\convert = True
  EndIf

  fh.l = Open_(&ofname, accessmode)
  If fh
;    log_Print{"file opened successfully, handle: " + Hex$(fh)}
    Function Return fh
  Else
    fileerror.l = IoErr_
    log_Print{"could not open file <" + ofname + "> for reason: " + Str$(fileerror)}
    log_Print{"menuload: " + Str$(menuload)}

    If menuload = False
      error{"Couldn't open file, DOS-Error: " + Str$(fileerror)}
    Else
      error{"Couldn't open file, DOS-Error: " + Str$(fileerror)}
    EndIf
  EndIf

End Function



Function.s PED_RequestFile{tmpdir$, tmpfile$, tmptitle$, tmppattern$}
SHARED ped, pedconfig, sourceWindow

 ;If _a0<>0 Then tmpdir$   = Peek$(_a0)
 ;If _a1<>0 Then tmpfile$  = Peek$(_a1)
 ;If _a2<>0 Then tmptitle$ = Peek$(_a2)
 If pedconfig\use_filepattern <> 0
   If tmppattern$ = "" Then tmppattern$ = "(#?.info)"
 Else
   tmppattern$ = ""
 EndIf

 asl_SetRequesterDims{pedconfig\asl_x,pedconfig\asl_y,pedconfig\asl_w,pedconfig\asl_h}
 aslfr_SetRequesterTitle{1,!TRANS{tmptitle$},"",""}
 aslfr_SetPattern{1,tmppattern$}
 aslfr_SetPath{1,tmpdir$}
 aslfr_SetFile{1,tmpfile$}

 If aslfr_Request{1,False,False,False,sourceWindow\pedScreen}
   tempdir$      = aslfr_GetPath{1}
   tempfile$     = aslfr_GetFile{1}
   tempcomplete$ = dos_AddPart{tempdir$ , tempfile$}
 Else
   tempfile$ = ""
 EndIf

 If tempfile$ <> ""
   ped\currentDir = tempdir$
   ped\currentFile = tempfile$
   ped\sourceFileComplete = tempcomplete$
   Function Return tempcomplete$
 EndIf
End Function

Function.l PED_GetMessage{_wait.b}
SHARED pedMessage,sourceWindow

  pedMessage\_Class = 0
  pedMessage\_Code  = 0
  pedMessage\_Qualifier = 0
  pedMessage\_IAddress  = 0
  pedMessage\_MouseX    = 0
  pedMessage\_MouseY    = 0
  pedMessage\_Window    = 0
  pedMessage\_Seconds   = 0
  pedMessage\_Micros    = 0

  If _wait = True
    pedMessage\_Class     = WaitEvent
  Else
    pedMessage\_Class     = Event
  ;*msg.IntuiMessage = GetMsg_(sourceWindow\win\UserPort)
  EndIf

  ;If *msg Then ReplyMsg_ *msg
  pedMessage\_Code      = EventCode
  pedMessage\_Qualifier = EventQualifier
  pedMessage\_IAddress  = EventiAddress
  pedMessage\_MouseX    = EMouseX
  pedMessage\_MouseY    = EMouseY
  pedMessage\_Window    = EventWindow
  pedMessage\_Seconds   = EventSeconds
  pedMessage\_Micros    = EventMicros

  Function Return pedMessage\_Class
End Function


;@@0
.STARTUP_PED
; -------------------------------------------------------------------------------------
; START OF CODE
; -------------------------------------------------------------------------------------

; -- check for TEDY as input of D1, if NOT, program was not run from IDE
!asm
CMP.l #"TEDY",D1
BEQ 'no_exit
  !basic
  error{"PED is not a standalone editor anymore.\\nPlease start the AmiBlitz3-IDE via Compiler."}
  Goto abnormal_exit
'no_exit
!basic

; -- setting comdatas
!ComData_LEA{comFunc_ErrorRequest           ,A0}        : MOVE.l #show_errorrequester         ,(A0) ;$0C
!ComData_LEA{comFunc_DebugTrap              ,A0}        : MOVE.l #com_0_44E2                  ,(A0) ;$38
!ComData_LEA{comFunc_OpenConsole            ,A0}        : MOVE.l #console_open                ,(A0) ;$3C
!ComData_LEA{comFunc_CloseConsole           ,A0}        : MOVE.l #console_close               ,(A0) ;$40
!ComData_LEA{comFunc_LogPrint               ,A0}        : MOVE.l #log_print                   ,(A0) ;$44
!ComData_LEA{comFunc_SetNormalPointer       ,A0}        : MOVE.l #set_pointer_normal           ,(A0) ;$48
!ComData_LEA{comFunc_SetBusyPointer         ,A0}        : MOVE.l #set_pointer_busy             ,(A0) ;$4C     4c 4d 4e 4f
!ComData_LEA{comFunc_DetokenizeLine         ,A0}        : MOVE.l #detokenize_line             ,(A0) ;$64
!ComData_LEA{comPtr_CurrentDir              ,A0}        : MOVE.l #comStr_CurrentDir           ,(A0) ;$68
!ComData_LEA{comPtr_SourceName              ,A0}        : MOVE.l #comStr_SourceName           ,(A0) ;$6C
!ComData_LEA{comFunc_AL_0_852E              ,A0}        : MOVE.l #AL_0_8BD2                   ,(A0) ;$70
!ComData_LEA{comFunc_AL_0_8532              ,A0}        : MOVE.l #AL_0_8BD6                   ,(A0)
!ComData_SetL{comFunc_CloseGUI              ,#close_gui}
!ComData_SetL{comFunc_CreateGUI             ,#create_whole_gui}
!ComData_SetL{comData_Magic                 ,##MagicIdentifier_Long}        ;#"~::~"}  ;
!ComData_SetL{comFunc_UpdateCompileStatusWin,#Update_CompileStatus_Window}

FindScreen 0

; ---  Check  if  all  needed  Librarys  are  available  with  the  needed  min  Version
; --------------------------------------------------------------------------------------
ende.b     = False   ; abort indicater
errorout.s = ""      ; for the error text

If dos_CheckLib{"wizard.library",42} = False        ; needed for PED and REDDebugger
  errorout + "Missing 'wizard.library':\\nVersion 42 of this library is required by the IDE.\\n\\n"
  ende = True
EndIf

;If dos_CheckLib{"ted.library",1} = False            ; needed for PED and REDDebugger
;  errorout + "Missing 'ted.library':\\nVersion 1 of this library is required by the IDE.\\n\\n"
;  ende = True
;End If
If dos_CheckLib{"disassembler.library",40} = False  ; only needed for REDDebugger
  errorout + "Missing 'disassembler.library':\\nVersion 40 of this library is required by REDDebugger.\\nASM debugging won't work.\\n\\n"
End If
If errorout <> ""
   errorout = "Please reinstall AmiBlitz3 or copy the following librarys to LIBS:\\n\\n" + errorout
   If ende
     errorout + "... that the PED can start!" ; for abort
   Else
     errorout + "... for a full working IDE!" ; for limited start
   End If
   error{!TRANS{errorout}}
End If
If ende Then Goto abnormal_exit
; -----------------------------------------------------------------------------------


; ------------------------------------------------------------------------------------
; AUSWERTEN DER TOOLTYPES
; ------------------------------------------------------------------------------------
.TOOLTYPES
  default_assign.s = "Blitz3:"
  tt.s = dos_GetProgIcon{dos_AddPart{default_assign,"AmiBlitz3"} }   ;  replaces hardcode string "blitz3:" tomsmart 2012 03 12
  log_Print{"opening tooltypes for <" + tt.s + ">"}
  disk_object.l = dos_OpenToolTypes{tt.s}
  If disk_object
    ; ---- LOGGING --------------------------------------------------
    tmp_string = StrUpper(dos_GetToolString{"LOG_LEVEL","NOTHING"})                                                                                                                                                                                            
    logging_level.b = #log_nothing
    If tmp_string = "NOTHING" Then logging_level = #log_nothing                                                                                                                                                                                            
    If tmp_string = "DEBUG" Then logging_level = #log_debug                                                                                                                                                                                                
    If tmp_string = "INFO" Then logging_level = #log_information                                                                                                                                                                                           
    If tmp_string = "WARN" Then logging_level = #log_warning                                                                                                                                                                                               
    If tmp_string = "ERROR" Then logging_level = #log_error                                                                                                                                                                                                
    log_SetLevel{logging_level}

    log_mode.b = #log_toconsole
    tmp_string = StrUpper(dos_GetToolString{"LOG_MODE","CONSOLE"})                                                                                                                                                                                             
    If tmp_string = "FILE" Then log_mode = #log_tofile                                                                                                                                                                                                     
    If tmp_string = "CONSOLE" Then log_mode = #log_toconsole                                                                                                                                                                                               
    If tmp_string = "BOTH" Then log_mode = #log_toboth                                                                                                                                                                                                     
    log_SetDestination{log_mode,"System/PED.log"}

    ; ----- OTHER TOOLTYPES
    !log_AvailMem{"at tooltype begin"}

    If dos_GetToolState{"disable_welcome"}     = -1 Then pedconfig\no_welcome      = True  : Else pedconfig\no_welcome = 0
    If dos_GetToolState{"askbeforequit"}       = -1 Then pedconfig\ask_before_quit = True  : Else pedconfig\ask_before_quit = 0
    If dos_GetToolState{"smart_tokenization"}  = -1 Then pedconfig\smart_tokenization = True  : Else pedconfig\smart_tokenization = 0
    If dos_GetToolState{"disable_displaybeep"} = -1 Then pedconfig\no_display_beep = True  : Else pedconfig\no_display_beep =   0
    If dos_GetToolState{"auto_format"}         = -1 Then pedconfig\auto_format     = True  : Else pedconfig\auto_format = 0
    If dos_GetToolState{"auto_indent"}         = -1 Then pedconfig\auto_indent     = True  : Else pedconfig\auto_indent = 0  ; added because was not loaded befor tomsmart1
    If dos_GetToolState{"auto_constructs"}     = -1 Then pedconfig\auto_constructs = True  : Else pedconfig\auto_constructs = 0
    If dos_GetToolState{"correct_functions"}   = -1 Then pedconfig\correct_functions = True  : Else pedconfig\correct_functions = 0
    If dos_GetToolState{"bold_tokens"}         = -1 Then pedconfig\bold_tokens       = True  : Else pedconfig\bold_tokens = 0
    If dos_GetToolState{"italic_remarks"}      = -1 Then pedconfig\italic_remarks  = True  : Else pedconfig\italic_remarks = 0
    If dos_GetToolState{"linenumbers"}         = -1 Then pedconfig\linenumbers     = True  : Else pedconfig\linenumbers = 0
    If dos_GetToolState{"DISABLE_HIGHLIGHTING"}= -1 Then pedconfig\highlighting  = False  : Else pedconfig\highlighting = True
    If dos_GetToolState{"DISABLE_LOCALIZATION"}  = -1 Then pedconfig\localization = False : Else pedconfig\localization = True
    If dos_GetToolState{"HELPFORPRIVATFUNCTIONS"}  = -1 Then pedconfig\HelpForPrivateFunctions = True : Else pedconfig\HelpForPrivateFunctions = 0
    If dos_GetToolState{"USE_INTELLISENSE"}        = -1 Then pedconfig\intellisense = True  : Else pedconfig\intellisense = 0
    If dos_GetToolState{"USE_INTELLISENSE_COMMANDS"}= -1 Then pedconfig\use_commandsintellisens = True  :Else pedconfig\use_commandsintellisens = False
    If dos_GetToolState{"onlinehelp"}          = -1 Then pedconfig\onlinehelp      = True  : Else pedconfig\onlinehelp = 0
    If dos_GetToolState{"onlinehelp_extended"} = -1 Then pedconfig\onlinehelp_extended = True : Else pedconfig\onlinehelp_extended = 0
    If dos_GetToolState{"DISABLE_INCLUDEHELP"} = -1 Then pedconfig\onlinehelp_includes   = False  : Else pedconfig\onlinehelp_includes = True
    If AvailMem_(#MEMF_FAST) < 4000000 AND (pedconfig\onlinehelp_includes OR pedconfig\intellisense)
      errormessage$ = "The available memory is low.\\n"
      errormessage$ + "Online-Help and intellisense for Include-functions will be disabled.\\n"
      errormessage$ + "You should check following tooltypes:\\n\\n"
      errormessage$ + "- DISABLE_INCLUDEHELP\\n"
      errormessage$ + "- DISABLE_LOCALIZATION\\n"
      errormessage$ + "- USE_INTELLISENSE"
      error{errormessage$}
      pedconfig\intellisense = False
      pedconfig\onlinehelp_includes = False
    End If
    ;pedconfig\intellisense = pedconfig\onlinehelp_includes

    If dos_GetToolState{"SOURCE_HISTORY"}          = -1 Then pedconfig\remember_saved    = True : Else pedconfig\remember_saved = 0
    If dos_GetToolState{"LOAD_LAST_SOURCE"}        = -1 Then pedconfig\load_last_source  = 1 : Else pedconfig\load_last_source = 0
    If dos_GetToolState{"USE_FILEPATTERN"}         = -1 Then pedconfig\use_filepattern=1 : Else pedconfig\use_filepattern=0
    If dos_GetToolState{"SORT_LABELS"}             = -1 Then pedconfig\sort_labels       = True  : Else pedconfig\sort_labels = 0
    If dos_GetToolState{"CON_ONWB"}                = -1 Then pedconfig\console_wb        = True  : Else pedconfig\console_wb  = 0
    If dos_GetToolState{"CON_WAIT"}                = -1 Then pedconfig\console_wait      = True  : Else pedconfig\console_wait = 0

    If dos_GetToolState{"CLONE_WBSCREEN"}   = True
      pedconfig\clone_wbscreen = True : pedconfig\use_wbscreen = False
    Else
      If dos_GetToolState{"USE_WBSCREEN"}   = True
        pedconfig\use_wbscreen = True : pedconfig\clone_wbscreen = False
      EndIf
    EndIf
    If dos_GetToolState{"PUBSCREEN"}          = -1 Then pedconfig\use_pubscreen         = True : Else pedconfig\use_pubscreen = 0
    If dos_GetToolState{"DEFAULTPUBSCREEN"}   = -1 Then pedconfig\use_default_pubscreen = True : Else pedconfig\use_default_pubscreen = 0
    If dos_GetToolState{"USE_WBFONT"}         = -1 Then pedconfig\use_wbfont            = True : Else pedconfig\use_wbfont = 0
  Else
    log_Print{"Could not open tooltypes",#log_warning}
    pedconfig\bold_tokens       = True
    pedconfig\onlinehelp        = True
    pedconfig\onlinehelp_extended = False
    pedconfig\clone_wbscreen     = False
    pedconfig\use_wbscreen       = True
    pedconfig\use_pubscreen      = False
    pedconfig\use_default_pubscreen = False
    pedconfig\use_wbfont         = True
    pedconfig\use_filepattern    = True
  End If

  pedconfig\use_source_icon = False

  If dos_GetToolState{"AUTOLAYOUT"}=-1 Then pedconfig\autolayout     = True Else pedconfig\autolayout = False
  pedconfig\al_leftspace   = dos_GetToolValue{"autolayout_left"  ,0}
  pedconfig\al_topspace    = dos_GetToolValue{"autolayout_top"   ,0}
  pedconfig\al_rightspace  = dos_GetToolValue{"autolayout_right" ,0}
  pedconfig\al_bottomspace = dos_GetToolValue{"autolayout_bottom",0}

  pedconfig\console_device = dos_GetToolString{"CON_DEVICE","CON:"}
  pedconfig\console_font   = dos_GetToolString{"CON_FONT",""}


  pedconfig\cursorStyle = cursorStyleGetValue{dos_GetToolString{"cursorstyle","block"}}
  pedconfig\scroll_rate = dos_GetToolValue{"scrollrate",0}
  If pedconfig\scroll_rate <> 0
    If vvblank_SetFreq{pedconfig\scroll_rate} = False Then ped\no_scrollrate = True
  Else
    ped\no_scrollrate = True
  EndIf

  pedconfig\tab_size = Peek.w (?tab_size)
  pedconfig\blinkrate = dos_GetToolValue{"cursorblinkrate",5}
  pedconfig\wheelStep = dos_GetToolValue{"MOUSEWHEELSTEP",6}     ; added to make Mousewheelsteprate changeable  tomsmart1

  ; --- ASL-Requestersettings ------------------------------
  pedconfig\asl_x = dos_GetToolValue{"ASLREQ_X" ,20}
  pedconfig\asl_y = dos_GetToolValue{"ASLREQ_Y" ,20}
  pedconfig\asl_w = dos_GetToolValue{"ASLREQ_W",320}
  pedconfig\asl_h = dos_GetToolValue{"ASLREQ_H",200}
  asl_SetRequesterDims{pedconfig\asl_x,pedconfig\asl_y,pedconfig\asl_w,pedconfig\asl_h}

  ; --- COLORS ---------------------------------------------
  AB3RGB(#AB3_ctoken)            = dos_GetToolValue{"tokencolor"      ,$646bd7} ;: Poke.b ?tokencolor,AB3RGB(#AB3_ctoken
  AB3RGB(#AB3_cfunction)         = dos_GetToolValue{"functioncolor"   ,$396635} ;: Poke.l ?functioncolor,AB3RGB(#AB3_cfunction
  AB3RGB(#AB3_cconstant)         = dos_GetToolValue{"constantcolor"   ,$8C338A} ;: Poke.l ?constantcolor,AB3RGB(#AB3_cconstant
  AB3RGB(#AB3_cnewtype)          = dos_GetToolValue{"newtypecolor"    ,$153492} ;: Poke.l ?newtypecolor,AB3RGB(#AB3_cnewtype
  AB3RGB(#AB3_cstring)           = dos_GetToolValue{"stringcolor"     ,$7D8A83} ;: Poke.w ?stringcolor,AB3RGB(#AB3_cstring
  AB3RGB(#AB3_cmacro)            = dos_GetToolValue{"macrocolor"      ,$CB3817} ;: Poke.l ?macrocolor,AB3RGB(#AB3_cmacro
  AB3RGB(#AB3_cother)            = dos_GetToolValue{"othercolor"      ,$000000} ;: Poke.w ?othercolor,AB3RGB(#AB3_cother
  AB3RGB(#AB3_cremarkforeground) = dos_GetToolValue{"remarkforg"      ,$6a9a66} ;: Poke.b ?remarkcolor,AB3RGB(#AB3_cremarkforg
  AB3RGB(#AB3_cremarkbackground) = dos_GetToolValue{"remarkbackg"     ,$f9f9f9} ;: Poke.b ?remarkbgcolor,AB3RGB(#AB3_cremarkbackg
  AB3RGB(#AB3_ctokenbackground)  = dos_GetToolValue{"tokenbackpen"    ,$ffffff} ;: Poke.b ?tokenbackground,AB3RGB(#AB3_ctokenbackground
  AB3RGB(#AB3_cbackground)       = dos_GetToolValue{"backgroundcolor" ,$ffffff} ;: Poke.l ?backgroundcolor,AB3RGB(#AB3_cbackgroundcolor
  AB3RGB(#AB3_cclassic)          = dos_GetToolValue{"classiccolor"    ,$ff0500} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screenback)        = dos_GetToolValue{"screenbackcolor" ,$c8c8c8} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screentext)        = dos_GetToolValue{"screentextcolor" ,$000000} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screenshine)       = dos_GetToolValue{"screenshinecolor",$FFFFFF} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic
  AB3RGB(#AB3_screenfill)        = dos_GetToolValue{"screenfillcolor" ,$6e94e2} ;: Poke.w ?classiccolor,AB3RGB(#AB3_cclassic

  ; --- SCREEN ---------------------------------------------
  pedconfig\screen_modeID  = dos_GetToolValue{"SCREEN_ID"     ,0} ;: Poke.l ?ownscreen_modeid ,pedconfig\screen_modeid
  pedconfig\screen_Width   = dos_GetToolValue{"SCREEN_WIDTH"  ,0} ;: Poke.w ?ownscreen_width  ,pedconfig\screen_Width
  pedconfig\screen_Height  = dos_GetToolValue{"SCREEN_HEIGHT" ,0} ;: Poke.w ?ownscreen_height ,pedconfig\screen_Height
  pedconfig\screen_Depth   = dos_GetToolValue{"SCREEN_DEPTH"  ,0} ;: Poke.w ?ownscreen_depth  ,pedconfig\screen_Depth

  ; check if any Screentooltype set
  If (pedconfig\clone_wbscreen = 0) AND (pedconfig\use_wbscreen = 0) AND (pedconfig\screen_modeID = 0)
     pedconfig\use_wbscreen = True  ; we use WBScreen if no Screen Tooltype is set
  EndIf

  MaxLen str2$   = 4096   ; this is important since Honitos used some string pointers, that might be empty
  MaxLen cstr$   = 4096   ; pointers to empty string might be NULL, that's why!
  MaxLen cstr2$  = 4096   ; pointers to empty string might be NULL, that's why!
  MaxLen str2b$  = 4096
  str2$          = ""
  cstr$          = ""
  cstr2$         = ""
  str2b$         = ""
  project_changelog$ = ""
  find_strold.s    = ""                                                                                                                                                                                                                                  
  find_replaceStrOld.s = ""                                                                                                                                                                                                                              

  ; --- FONTS ----------------------------------------------
  If pedconfig\use_wbfont = False
    ;no Tooltype use_wbfont so check for GUI and Source font tooltypes
    str_guifont$    = dos_GetToolString{"guifont",""}       ; no predefine Font use WB fonts instead
    str_sourcefont$ = dos_GetToolString{"sourcefont",""}

    If str_guifont$<>"" OR str_sourcefont$<>""
      ; check and set GUIfont
      If str_guifont$<>""
        InitArgParse str_guifont$
        guifont_name$ = NextArgChar$(@",")
        a$ = NextArg$
        guifont_size.w = Vallong(a$)
      EndIf
      ; check and set Sourcefont
      If str_sourcefont$<>""
        InitArgParse str_sourcefont$
        sourcefont_name$ = NextArgChar$(@",")
        a$ = NextArg$
        sourcefont_size.w = Val(a$)
        ;Poke.s ?str_sourcefontname ,sourcefont$ + StrClone(Chr$(0),79 - Len(sourcefont$))
        ;Poke.w ?sourcefontsize     ,sourcefont_size
        ;Poke.b ?sourcefontstyle    ,sourcefont_style.w
      EndIf
    Else
      ; no guifont and sourcefont set so use WBfonts
      pedconfig\use_wbfont = True
    EndIf
  EndIf

  ; --- DIRECTORIES ---------------------------------------
  pedconfig\mainDir      = dos_GetToolString{"ASSIGN",default_assign}
  If pedconfig\mainDir = "" Then pedconfig\mainDir = default_assign ; in case someone sets assign to ""
  pedconfig\systemDir    = dos_AddPart{pedconfig\mainDir,"System"}
  pedconfig\blitzlibDir = dos_AddPart{pedconfig\mainDir,"Blitzlibs"}
  pedconfig\lastSourceFile     = dos_GetToolString{"last_source",""}

  pedconfig\includeDir      = dos_GetToolString{"INCLUDEDIR" ,dos_AddPart{pedconfig\mainDir,"Sourcecodes/Includes"}} : Poke.l ?ptr_incdirname,&pedconfig\includeDir
  pedconfig\helpDir         = dos_GetToolString{"HELPDIR"    ,dos_AddPart{pedconfig\mainDir,"Docs"}}
  pedconfig\autodocDir      = dos_GetToolString{"AUTODOCDIR" ,dos_AddPart{pedconfig\mainDir,"Docs"}}
  pedconfig\sourceDir       = dos_GetToolString{"SOURCEDIR"  ,dos_AddPart{pedconfig\mainDir,"Sourcecodes"}}
  pedconfig\winprefsFile = dos_GetToolString{"WINDOWPREFS",dos_AddPart{pedconfig\mainDir,"System/ped_addon.prefs"}}
  pedconfig\rememberFile = dos_AddPart{pedconfig\systemDir,"PED.history"}
  pedconfig\menuFile = dos_AddPart{pedconfig\systemDir,"PED.menus"}

  ; -- lib collections
  If dos_GetToolState{"BASELIBS"} <> 0
    If dos_GetToolState{"BASELIBS"} =-1 Then pedconfig\useBaseLib = True
    pedconfig\baselibFile = dos_GetToolString{"BASELIBS",dos_AddPart{pedconfig\blitzlibDir,"AcidLibs"}}
    log_Print{"BASELIBS = " + pedconfig\baselibFile}
  EndIf
  If pedconfig\baselibFile <> ""
    If dos_Exist{pedconfig\baselibFile}
      ped\baselibFileDate = StrChg(dos_GetFileDate{pedconfig\baselibFile},"/",".")
      ped\baselibFileSize = dos_GetFileSize{pedconfig\baselibFile}
    EndIf
  EndIf

  If dos_GetToolState{"UTILLIBS"} <> 0
    If dos_GetToolState{"UTILLIBS"} =-1 Then pedconfig\useUtilLib = True
    pedconfig\utillibFile = dos_GetToolString{"UTILLIBS",dos_AddPart{pedconfig\blitzlibDir,"DefLibs"}} : Poke.l ?ptr_deflibsfilename,&pedconfig\utillibFile
    log_Print{"UTILLIBS = " + pedconfig\utillibFile}
  EndIf
  If pedconfig\utillibFile <> ""
    If dos_Exist{pedconfig\utillibFile}
      ped\utillibFileDate = StrChg(dos_GetFileDate{pedconfig\utillibFile},"/",".")
      ped\utillibFileSize = dos_GetFileSize{pedconfig\utillibFile}
    EndIf
  EndIf

  If dos_GetToolState{"OSLIBS"} <> 0
    If dos_GetToolState{"OSLIBS"} =-1 Then pedconfig\useOsLib = True
    pedconfig\oslibFile = dos_GetToolString{"OSLIBS",dos_AddPart{pedconfig\blitzlibDir,"OsLibs"}}
    log_Print{"OSLIBS = " + pedconfig\oslibFile}
  EndIf
  If pedconfig\oslibFile <> ""
    If dos_Exist{pedconfig\oslibFile}
      ped\oslibFileDate  = StrChg(dos_GetFileDate{pedconfig\oslibFile},"/",".")
      ped\oslibFileSize  = dos_GetFileSize{pedconfig\oslibFile}
    EndIf
  EndIf

  If dos_GetToolState{"CSLIBS"} <> 0
    If dos_GetToolState{"CSLIBS"} =-1 Then pedconfig\useCsLib = True
    pedconfig\cslibFile = dos_GetToolString{"CSLIBS",dos_AddPart{pedconfig\blitzlibDir,"CsLibs"}}
    log_Print{"CSLIBS = " + pedconfig\cslibFile}
  EndIf
  If pedconfig\cslibFile <> ""
    If dos_Exist{pedconfig\cslibFile}
      ped\cslibFileDate  = StrChg(dos_GetFileDate{pedconfig\cslibFile},"/",".")
      ped\cslibFileSize  = dos_GetFileSize{pedconfig\cslibFile}
    EndIf
  EndIf

  ; settings for type browser
  ped\newtype_mode = 0


  !log_AvailMem{"after tooltypes"}

  ; -- localization
  If pedconfig\localization
    !log_AvailMem{"before preparing localization"}
    !TRANS_INIT{"AmiBlitz3"}
    !log_AvailMem{"preparing localization done"}
  EndIf

  pedconfig\console_title  = !TRANS{"AmiBlitz3 Console Output"}

  If pedconfig\localization
    *MyCatalog.Catalog = OpenCatalogA_(0,"PED.catalog",0)
    If *MyCatalog
      ;set tags so Wizardlibrary Use catalog File
      log_Print{"language: " + Peek.s(*MyCatalog\cat_Language)}
      WZTags #SFH_Catalog,*MyCatalog,#TAG_DONE,0,#TAG_END,0
    Else
      log_Print{"could not open catalog file",#log_warning}
    EndIf
  EndIf

  ; -- setup wizard GUI
  WZLoadGUI ?wzgui

WZ_ShowMessage{!TRANS{"Initiating AmiBlitz3 Environment..."} }
WZ_ChangeTitle{"WIN_PROGRESS","Amiblitz3 V" + !versions}  ; use Statement to remove double code tomsmart1 2012 03 09                                                                                                                                     


;--- Check to identify on with OS we are running         ; added to disable the Mousewheel settings in the IDE prefs for OS4 because we use the System values with OS4  tomsmart1
SHARED OSVersion.l
OSVersion = #AmigaOS3
If ( dos_CheckLib{"exec.library",50} ) Then OSVersion = #AmigaOS4 ;: message{"REDDebugger: I think I run on OS4, because I was able to open exec.library v50+!"}
If ( FindResident_("MorphOS") )        Then OSVersion = #MorphOS  ;: message{"REDDebugger: I think I run on MOS, because I found the 'MorphOS' Resident!"}
;-----


; ------------------------------------------------------
; EINBINDEN DER KONFIGURATIONSDATEIEN
; ------------------------------------------------------
.CONFIGFILES

WZ_ShowMessage{!TRANS{"Preparing preprocessor/tokenizer ..."}}
pedconfig\HelpIndexFile          = dos_AddPart{pedconfig\systemDir,"HelpIndex.txt"}
pedconfig\HelpIndexCacheFile        = dos_AddPart{pedconfig\systemDir,"HelpIndexCache.bin"}
TokenHashMapFile.s         = dos_AddPart{pedconfig\systemDir,"TokenList.hashmap"}
*PreProcessor = preproc_Create{}
Poke.l ?comPtr_PreProcessor,*PreProcessor
preproc_LoadTokens{*PreProcessor,TokenHashMapFile}

!log_AvailMem{"after preparing preprocessor/tokenizer"}


If pedconfig\onlinehelp_includes
  WZ_ShowMessage{!TRANS{"Loading helpindex for include-functions ..."}}
  If dos_Exist{pedconfig\HelpIndexCacheFile} AND dos_GetFileSize{pedconfig\HelpIndexCacheFile} > 0
    ;log_Print{"loading help index cache file: " + pedconfig\HelpIndexCacheFile}
    PED_LoadHelpIndexCache{pedconfig\HelpIndexCacheFile}
  Else
    log_Print{"building help index cache file: " + pedconfig\HelpIndexCacheFile}
    BuildHelpIndexWinTitle$ = "Building"                         ;added so the window title match the function  tomsmart1 ; remove !TRANS{} because it will translated with befor it will displayed  tomsmart1
    Gosub build_HelpIndexFile
  End If
  !log_AvailMem{"after loading includehelpindex"}
Else
  !log_AvailMem{"index for includefiles skipped."}
End If

If ReadFile (0,pedconfig\winprefsFile)
  WZ_ShowMessage{!TRANS{"Loading window layouts ..."}}
  ReadType 0,wpref(0)
  ReadType 0,wpref(1)
  ReadType 0,wpref(2)
  CloseFile 0
End If


; ---------------------------------------- MAINPROGRAM ----------------------------------------------
WZ_ShowMessage{!TRANS{"Starting IDE ..."} }
.MAINPROGRAM
!asm
begin1:
  MOVE.l A1,comLong_AB3IsAvailable   ; A1 is teddata of compiler

  ; --
  ; -- initiation of compiler data-interface
  MOVEA.l #comPtr_TokenBase,A0       ;teddata for compiler
  MOVEQ.l #$11,D0
  JL_0_1E:
    MOVE.w (A1)+,(A0)+
  DBF D0,JL_0_1E

  MOVE.l -8(a1),newted
  MOVE.l (a1),constantbase
  MOVE.l ptr_deflibsfilename,4(a1)
  MOVE.l ptr_incdirname,8(a1)

  MOVE.l -4(a1),d0
  BEQ 'l10
    MOVE.l d0,a0
    MOVEQ #6,d1
   'l11
      MOVE.l (a0),a0
    DBF d1,'l11
    MOVE.l a0,newtypebase
 'l10:

  ; --
  ; -- initiation of some editor datas
.begin
  MOVEQ #127,d0                      ; clear char-table
  LEA chartab,a0
 'l12
    MOVE.b #1,128(a0)
    CLR.b (a0)+
  DBF d0,'l12

  LEA chartab,a0                     ; init char-table
  MOVE.b #1,(a0)
  MOVE.b #1,","(a0)
  MOVE.b #1,";"(a0)
  MOVE.b #1,":"(a0)
  MOVE.b #1,"("(a0)
  MOVE.b #1,")"(a0)
  MOVE.b #1,"="(a0)
  MOVE.b #1,"+"(a0)
  MOVE.b #1,"-"(a0)
  MOVE.b #1,"*"(a0)
  MOVE.b #1,"/"(a0)
  MOVE.b #1,"$"(a0)
  MOVE.b #1,"%"(a0)
  MOVE.b #1,"."(a0)
  MOVE.b #1,"["(a0)
  MOVE.b #1,"]"(a0)
  MOVE.b #1,"{"(a0)
  MOVE.b #1,"}"(a0)
  MOVE.b #1,"\"(a0)
  MOVE.b #1,">"(a0)
  MOVE.b #1,"<"(a0)
  MOVE.b #1,"&"(a0)
  MOVE.b #1,"|"(a0)
  MOVE.b #1,"^"(a0)
  MOVE.w #0101,1(a0)
  MOVE.b #1,$20(a0)

  !basic
  ped\mempool = CreatePool_(#MEMF_CLEAR,40000,40000)
  If ped\mempool = 0
    log_Print{"Could not allocate enough memory. PED closes down now.",#log_error}
    Pop If
    Goto exit_PED_nomem
  EndIf
  Poke.l ?comPtr_MemPool,ped\mempool

  ; create a msgport for Iconification
  *WBMsgPort.MsgPort = CreateMsgPort_

  CNIF #USE_AREXX = 1
    !log_AvailMem{"before init arexx-port..."}
    Gosub arexx_init
    AddWaitEvent PortSigBit(*ArexxMsgPort.MsgPort),$8000000
  CEND

  requestmemsize.l = $2000
  requestmemsize   + #MAX_Columns * 3
  requestmemsize   + 6
  readcache\bufferptr = PED_AllocMem{requestmemsize}
  If readcache\bufferptr = 0 Then Goto exit_PED_closelibraries
  readcache\fib = AllocDosObject_ (#DOS_FIB,0)
  *rc_fib.FileInfoBlock = readcache\fib

  GetReg d0,readcache\bufferptr
  MOVEA.l D0,A0
  LEA $2000(A0),A0
  MOVE.l A0,comPtr_Temp_TokenString1 : ADDA.w #MAX_Columns,A0 : ADDQ.w #2,A0
  MOVE.l A0,comPtr_Temp_TokenString2 : ADDA.w #MAX_Columns,A0 : ADDQ.w #2,A0
  MOVE.l A0,comPtr_Temp_TokenString3 : ADDA.w #MAX_Columns,A0 : ADDQ.w #2,A0
  ;MOVE.l A0,comPtr_Temp_TokenStringObsolete

  requestmemsize = $2F60 + 1000   ;12128 bytes
  textbuffers.l = PED_AllocMem{requestmemsize}
  If textbuffers = 0 Then Goto exit_PED_closelibraries

  GetReg d0,textbuffers
  MOVEA.l D0,A0 : MOVE.l A0,AL_0_5B9E
  ;ADD.l #MAX_Columns+4,a0 : MOVE.l A0,                 ; memory not used anymore
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,AL_0_5BA6
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,textbufferPrint
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,expandstore
  ADD.l #MAX_Columns+4,a0 : MOVE.l A0,lineundeletestore
  ;ADD.l #MAX_Columns+4,a0

  Gosub set_oldpreferences
  !log_AvailMem{"after reserve of buffers for source code, giving control back to compiler..."}

  !asm
  ; --
  ; -- return to compiler after initiation
  MOVE.l comLong_AB3IsAvailable,D0
  BEQ.w start_up_without_compiler
    LEA compiler_jumps_here,A0
    MOVEA.l comdata,A1
    MOVE.w ##ComDataVersionID,comWord_PEDIsAvailable
    RTS                              ; <-- return to compiler
  start_up_without_compiler:
  LEA str_tempfilename,A0

  compiler_jumps_here:               ; compiler offers str_tempfilename in A0 here
  !basic

  PutReg A0,tmpA0.l
  If tmpA0
    compiler_source$ = Peek$(tmpA0)
    log_Print{"source file given by compiler: [" + compiler_source$ + "]"}
  Else
    error{"NULL Pointer in compiler_source$!"}
  End If
  !log_AvailMem{"after Compiler has given control back"}

  ; --
  ; -- fill mapping array with libnames from mapping-file
  ; -- and check consistency based on the mapping files and the internal libnums
  WZ_ShowMessage{!TRANS{"Building tokenindex..."}}
  *tokenbase.tokeninfo = Peek.l(?comPtr_TokenBase)
  map_tokens_to_libs{dos_AddPart{pedconfig\systemDir,"token_mapping_libs.txt"}}
  map_tokens_to_libs{dos_AddPart{pedconfig\systemDir,"token_mapping_userlibs.txt"}}

  !log_AvailMem{"after doing token index"}

  If *PreProcessor\tokens = Null     ; we have no hashmap loaded, create it!
    WZ_ShowMessage{!TRANS{"Creating Hashmaps..."}}
    preproc_QueryTokens{*PreProcessor}
    preproc_SaveTokens{*PreProcessor,TokenHashMapFile}
  End If

  !log_AvailMem{"after preproc hashmap"}

  WZ_HideMessage{}

.START_GUI
  Gosub open_gui
  Gosub cursor_off
  Gosub menu_opennew

  Gosub update_debuggertoggle

  Gosub set_CurrentDir
  *flock_defaultDir.l = *flock_currentDir.l

  log_Print{"check lastsource option"}
  If pedconfig\load_last_source <> 0 OR compiler_source$<>""
    If compiler_source$<>"" Then pedconfig\lastSourceFile = compiler_source$
    If pedconfig\lastSourceFile <> ""
      tmp_currentdir.s = dos_PathPart{pedconfig\lastSourceFile}
      If Right$(tmp_currentdir,1)<>":" Then tmp_currentdir + "/" ; dirty hack, but better than editing ASM
      ped\currentFile = dos_FilePart{pedconfig\lastSourceFile}
      ped\currentDir = tmp_currentdir
      ped\sourceFileComplete =  pedconfig\lastSourceFile
      Poke.s ?comStr_CurrentDir,tmp_currentdir
      Poke.s ?comStr_SourceName,dos_FilePart{pedconfig\lastSourceFile}
    EndIf
  EndIf

  ; --
  ; -- jump to mainloop if no sourcename given, else
  ; -- load last Source
.AUTOLOAD_SOURCE
  If ped\currentFile <> ""
    Gosub cursor_off
    loadsourcefilename.s = ped\sourceFileComplete
    Gosub load_source
    Gosub cursor_on
  Else
    log_Print{"no file to autoload."}
    Gosub draw_statusarea
    !asm
    JSR _redraw
    !basic
  EndIf

  ; -- show welcome requester if option selected
  If NOT pedconfig\no_welcome Then Gosub menu_about

  ; ----------------------------------------------------------------------------
  ; -- jump to main loop
  Gosub cursor_on
  Gosub main_loop
  ; --
  ; ----------------------------------------------------------------------------

  ; --
  ; -- shutdown PED after return of the mainloop
  CNIF #USE_AREXX = 1
  log_Print{"sending AREXX-message QUITPLEASE"}
  ArexxMyMessage$ = "QUITPLEASE" : Gosub arexx_sendmessage
  CEND

  log_Print{"closing GUI..."}
  Gosub close_gui

exit_PED_closeall:
  Poke.w ?comWord_PEDIsAvailable,0

  log_Print{"freeing textbuffer..."}
  Gosub free_textbuffer

  log_Print{"closing fonts..."}
  Gosub close_sourcefonts

exit_PED_closelibraries:
  CNIF #USE_AREXX = 1
    log_Print{"closing arexxport.."}
    Gosub arexx_free
  CEND

  log_Print{"closing catalog an libs..."}
  If *MyCatalog Then CloseCatalog_ *MyCatalog
  
  ;ted_CloseLib{}

  If *WBMsgPort Then DeleteMsgPort_ *WBMsgPort

  log_Print{"unlocking directory..."}
  CurrentDir_(*flock_defaultDir)
  If *flock_currentDir Then UnLock_ *flock_currentDir

  exit_PED_nodoslib:
  log_Print{"freeing memory..."}
  preproc_Free{*PreProcessor} : *PreProcessor = Null

  If readcache\fib Then FreeDosObject_ #DOS_FIB,readcache\fib  : readcache\fib = Null

  If readcache\cacheptr
    FreeVec_ readcache\cacheptr
    readcache\cacheptr = Null
    readcache\readlen = 0
  End If

  exit_PED_nomem:
  log_Print{"deleting mempool..."}
  DeletePool_ ped\mempool

  !asm
  !exitasm             ; exitasm jumps into basic mode
  Gosub coutclose      ; move to the real end  tomsmart1
End

; ----------------------------------- END OF MAINPROGRAM ------------------------------------------


.abnormal_exit:
  !asm
  CLR.w comWord_PEDIsAvailable
  MOVEA.l comdata,A1            ; its now indirect, was #comdata before
  !exitasm                      ; exitasm jumps into basic mode
End



; ---------------------------------- THIS IS THE MAINLOOP -----------------------------------------
.main_loop:
  exit_mainloop.b = False
  While NOT exit_mainloop
    ped\LabelListChanged = False
    sourceWindow\redrawFlag = False

;    log_Print{"handlePedevents"}
    Gosub handlePedEvents
;    log_Print{"handlpepedevents end"}

    ; --- check if an exe is running and revert the entered key ---
    If Peek.b(?comByte_RunningFlag)
      If Peek.w(?comWord_KeyBeforeReturn)
        log_Print{"as an exe is running, revert the entered key"}
        !asm
        JSR _redraw
        !basic
        Poke.w ?comWord_KeyBeforeReturn,0
      EndIf
    EndIf

    If Peek.w(?comWord_KeyBeforeReturn) <> 0
      ;log_Print{"** parse the line after event, lastkey = " + Hexw$(Peek.w(?comWord_KeyBeforeReturn))}

      ; --- get address of actual source line ---
      sourceWindow\lastEditedLine = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)

      ped\ptrCurrentSourceData\SourceChanged = $FFFF

      lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)

      ; --- store cursor column position ---
      columnpos.w =  Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)


      ; --- format source line and get new column position ---
      newcolumnpos.w = preparseline{columnpos, lineaddr, pedconfig\auto_format, pedconfig\correct_functions}
      Poke.w ?comWord_Column, newcolumnpos - Peek.w(?comWord_ColumnsOffset)
      ;old_search_label$ = "|"  ;              WHY ?
      Gosub cursor_off
      !asm

      ; -- parse the current line
      MOVEA.l comPtr_CurrentSourceLine,A4
      MOVEA.l textbufferaddr,A2 : ADDA.w comWord_TextBufferOffset,A2
      JSR parse_line

      ; --- draw block mark if existing
  ;    SF comByte_StateBlockMark
  ;    TST.l comLong_BlockEndY
  ;    BMI.w exit_updateblock
  ;      MOVEM.l D0-D3/A0-A2,-(A7)
  ;      MOVE.l comLong_DisplayLine,D1 : ADD.l comLong_DisplayLineOffset,D1
  ;      CMP.l comLong_BlockStartY,D1
  ;      BLT.w JL_0_C66
  ;        CMP.l comLong_BlockEndY,D1
  ;        BGT.w JL_0_C66
  ;          !basic
  ;          log_Print{"update block marking"}
  ;          !asm
  ;          MOVE.w comWord_BlockStartX,D0
  ;          MOVE.l comLong_BlockStartY,D1
  ;          MOVE.w comWord_BlockEndX,D2
  ;          MOVE.l comLong_BlockEndY,D3
  ;          CMP.l D1,D3
  ;          BNE.w JL_0_C50
  ;            CMP.w D0,D2
  ;            BNE.w JL_0_C50
  ;              MOVE.w visiblecolumns,D2
  ;          JL_0_C50:
  ;          SUB.l comLong_DisplayLineOffset,D3
  ;          SUB.l comLong_DisplayLineOffset,D1
  ;          JSR _redrawBlock
  ;          ST comByte_StateBlockMark
  ;      JL_0_C66:
  ;      MOVEM.l (A7)+,D0-D3/A0-A2
  ;    exit_updateblock:

      JSR replaceCurrentLine  ; insert new parsed line into source
  ;
      MOVE.w comWord_DoTokenize,D0
      BEQ.w JL_0_CC6
        MOVEA.l comPtr_CurrentSourceLine,A2
        JSR print_sourceline
  ;
  ;      TST.b comByte_StateBlockMark
  ;      BEQ.w JL_0_CC6
  ;        MOVEM.l D0-D3/D7/A0-A2,-(A7)
  ;        MOVE.w comWord_BlockStartX,D0
  ;        MOVE.l comLong_BlockStartY,D1
  ;        MOVE.w comWord_BlockEndX,D2
  ;        MOVE.l comLong_BlockEndY,D3
  ;        CMP.l D1,D3
  ;        BNE.w JL_0_CB2
  ;          CMP.w D0,D2
  ;          BNE.w JL_0_CB2
  ;            MOVE.w visiblecolumns,D2
  ;        JL_0_CB2:
  ;        SUB.l comLong_DisplayLineOffset,D3
  ;        SUB.l comLong_DisplayLineOffset,D1
  ;        JSR _redrawBlock
  ;        MOVEM.l (A7)+,D0-D3/D7/A0-A2
      JL_0_CC6:
      !basic
    EndIf

    ; -- check if an executable is running and prevent IDE from doing things
    skip_update.b = False
    If Peek.b(?comByte_RunningFlag)
      If last_vankey.b = #VANILLAKEY_UP OR last_vankey= #VANILLAKEY_DOWN OR last_menuentry.l = #MENU_SAVEAS OR last_menuentry > #MENU_CUSTOMEDIT OR exit_loop_class.b = -3 OR last_vankey = #VANILLAKEY_HELP
        Gosub check_panic
      EndIf
    EndIf

    If NOT skip_update
      sourceWindow\redrawFlag = False
      If exit_loop_class.b = -3 Then sourceWindow\redrawFlag = True

      ; -- call function selected in comArray_KeyTable
      ;log_Print{"***** Last_vankey = " + Hex$(last_vankey.b)}
      ;log_Print{"***** Last_Menuentry = " + Hex$(last_menuentry)}
      ;log_Print{"***** exit class:" + Str$(exit_loop_class.b)}

      If exit_eventloop.b <> 0
  ;      log_Print{"***** executing actions hold back ..."}

        Select last_vankey
        Case #VANILLAKEY_RETURN: Gosub do_VANILLAKEY_RETURN
        Case #VANILLAKEY_UP:     mqualifier.w = last_mqualifier.w : Gosub do_VANILLAKEY_UP
        Case #VANILLAKEY_DOWN:   mqualifier = last_mqualifier : Gosub do_VANILLAKEY_DOWN
        End Select

        If exit_loop_class = -2
          ; _menuitem will be set in the first menu event handler
          Gosub close_popupwindow
          Gosub event_menu
        EndIf

        If exit_loop_class = -3 OR exit_loop_class= -4
          Gosub close_popupwindow
          Gosub event_leftmousebutton
        EndIf
 ;       log_Print{"actions end"}
      EndIf

      ; -- check for some tokens and automatically add the closing token
      ; --
      If pedconfig\auto_constructs
        If last_vankey.b = #VANILLAKEY_RETURN
          a$ = check_constructs{ped\ptrCurrentSourceData\CurrentSourceLine}
          If a$<>""
            Gosub insertstring
            !asm
            JSR insertreturn
            !basic
            Gosub movecursorlinedown
          EndIf
        EndIf
      EndIf

      ; update diag_redraw on event $fffc
      If exit_loop_code.l = -4
        Gosub diag_redraw
      EndIf

    Else
;      log_Print{"update skipped"}
    EndIf

    bottom_of_mainloop:
    If ped\LabelListChanged Then Gosub update_labelstuff
    Gosub update_vertscroller
  Wend
  ;log_Print{"exiting loop..."}
Return
; ----------------------------------------- END OF MAINLOOP -------------------------------------



.check_panic:
  *exeTask.Task = FindTask_("Blitz ][ Program Proc")
  If *exeTask <> 0
    dummy.l = ask{!TRANS{"This action is not allowed while executing a program\\nShould PED do a PANIC program kill?"},!TRANS{"Ok|Cancel"},!TRANS{"Error"}}
    If dummy <> 0
      log_Print{"found running exe task [" + Hex$(*exeTask) + "], removing all windows, screen and kill task..."}
      ;-- stop multitasking
      Forbid_

      ;-- close all windows and the screen of the task
      *intuibase.IntuitionBase = intuitionbase
      log_Print{"Intuitionbase: " + Hex$(*intuibase) + ", version " + Str$(*intuibase\LibNode\lib_Version)}
      *exeScreen.Screen = 0
      *tmpScreen.Screen = *intuibase\FirstScreen
      While *tmpScreen
        log_Print{"... checking Screen: " + Hex$(*tmpScreen) + " >> " + Peek$(*tmpScreen\Title)}
        *tmpWindow.Window = *tmpScreen\FirstWindow
        While *tmpWindow
          *nextWindow.Window = *tmpWindow\NextWindow
          log_Print{"... checking Window " + Hex$(*tmpWindow) + " >> " + Peek$(*tmpWindow\Title) + " Sigtask: " +  Hex$(*tmpWindow\UserPort\mp_SigTask)}
          If *tmpWindow\UserPort\mp_SigTask = *exeTask
            log_Print{"... window belongs to task, closing it!"}
            *exeScreen = *tmpScreen
            *tmpWindow\UserPort = 0
            CloseWindow_ *tmpWindow
          EndIf
          *tmpWindow = *nextWindow
        Wend
        *tmpScreen = *tmpScreen\NextScreen
      Wend
      If *exeScreen <> 0
        log_Print{"... screen belongs to task window, closing it ..."}
        CloseScreen_ *exeScreen
      EndIf

      ;-- kill the exe task
      log_Print{"... removing task"}
      RemTask_ *exeTask

      ;-- emable multitasking
      log_Print{"... enabling multitasking"}
      Permit_

      Poke.b ?comByte_RunningFlag,0
    Else
      skip_update = True
    EndIf
  Else
    log_Print{"runningflag is set, but no running task found!"}
  EndIf
Return


; -----------------------------------------------------------------------------------------------
str_tempfilename:        Ds.b #MAX_STRINGSIZE
Even

.menu_autolayout:
  Select _menuitem.l
  Case $171 : ped\lastAutoLayout = 0
  Case $172 : ped\lastAutoLayout = 1
  Case $173 : ped\lastAutoLayout = 2
  End Select
  log_Print{"doing autolayout " + Str$(ped\lastAutoLayout)}
  AutoLayout{&wtemp,ped\lastAutoLayout}
  Gosub do_windowlayout
;  pedconfig\autolayout + 1
;  If pedconfig\autolayout > 2 Then pedconfig\autolayout = 0
Return

.menu_settings:
 Gosub set_pointer_busy_bas
 WZ_LockAllOpenWindows{}                                                                                                                                                                                                                                 
 WZWindow WZID("WIN_SETTINGS"),?wzgui,255,-2,-2,-2,-2,WZID("WIN_SETTINGS")
 Use Window WZID("WIN_SETTINGS")
 ; make tab 0 active
 WZPrint "SET_PAGES",0

 ; init tempcolors
 For i = 0 To (#MAX_AB3Pens-1) ; relaced wrong 24 by #Max_AB3Pens -1, -1 because 0 to 23  tomsmart1
  AB3RGB_temp(i) = AB3RGB(i)
 Next i

 ;-- init gadgets
 If pedconfig\auto_format       Then WZPrint "SET_AUTO_FORMAT"        ,On
 If pedconfig\auto_constructs   Then WZPrint "SET_COMPLETE_CONSTRUCTS",On
 If pedconfig\intellisense      Then WZPrint "SET_INTELLISENSE"       ,On
 If pedconfig\correct_functions Then WZPrint "SET_CORRECT_FUNCTIONS"  ,On
 If pedconfig\smart_tokenization Then WZPrint "SET_SMART_TOKENIZATION" ,On

 If pedconfig\no_welcome        Then WZPrint "SET_WELCOME"            ,On
 If pedconfig\ask_before_quit   Then WZPrint "SET_ASKBEFOREQUIT"      ,On
 If NOT pedconfig\localization  Then WZPrint "SET_LOCALIZATION",On

 If pedconfig\onlinehelp        Then WZPrint "SET_ONLINEHELP"         ,On
 If pedconfig\highlighting      Then WZPrint "SET_HIGHLIGHTING"       ,On
 If pedconfig\bold_tokens       Then WZPrint "SET_BOLDTOKENS"         ,On
 If pedconfig\italic_remarks    Then WZPrint "SET_ITALICREMARKS"      ,On
 If pedconfig\linenumbers       Then WZPrint "SET_LINENUMBERS"        ,On : oldlinenumbers.b = pedconfig\linenumbers
 If pedconfig\remember_saved    Then WZPrint "SET_REMEMBER_SAVED"     ,On
 If pedconfig\load_last_source  Then WZPrint "SET_LAST_SOURCE"        ,On

 If pedconfig\use_pubscreen     Then WZPrint "SET_PUBSCREEN"          ,On
 If pedconfig\use_default_pubscreen Then WZPrint "SET_DEFAULTPUBSCREEN",On
 If pedconfig\use_filepattern   Then WZPrint "SET_FILEPATTERN"        ,On
 If pedconfig\auto_indent       Then WZPrint "SET_AUTO_INDENT"        ,On
 If pedconfig\autolayout        Then WZPrint "SET_AUTOLAYOUT"         ,On
 If pedconfig\no_display_beep   Then WZPrint "SET_NO_DISPLAYBEEP"     ,On

 If pedconfig\console_device <> ""    Then WZPrint "SET_CONSOLE_DEVICE"     ,&pedconfig\console_device
 If pedconfig\console_wb      =  True  Then WZPrint "SET_CONSOLE_ON_WB"      ,True
 If pedconfig\console_wait    =  True  Then WZPrint "SET_CONSOLE_WAIT"       ,True
 ;if console_dontclose = true       Then wzprint "SET_CONSOLE_

 WZPrint "SET_SORTLABELS"     ,pedconfig\sort_labels
 WZPrint "SET_CURSORSTYLE"    ,pedconfig\cursorStyle

; If NOT ped\no_scrollrate
;   WZDisable "SET_SCROLLRATE"
; Else
   WZPrint "SET_SCROLLRATE"   , pedconfig\scroll_rate
; EndIf

 WZPrint "SET_TAB_SIZE"       , pedconfig\tab_size
 WZPrint "SET_CURSORBLINKRATE", pedconfig\blinkrate
 If OSVersion = #AmigaOS4                           ; check if OS4
   WZDisable "SET_MOUSEWHEELSTEP"                   ; yes disable it becau we use the System value
 Else                                               ; no print used value.
   WZPrint "SET_MOUSEWHEELSTEP",pedconfig\wheelStep  ; add to make Mousewheelsteprate configuratable and saveable tomsmart1
 EndIf

 tsourcedir$  = pedconfig\sourceDir
 tincludedir$ = pedconfig\includeDir
 tautodocdir$ = pedconfig\autodocDir
 thelpdir$    = pedconfig\helpDir

 tutillibfile$ = pedconfig\utillibFile
 toslibfile$  = pedconfig\oslibFile
 tcslibfile$  = pedconfig\cslibFile

 WZPrint "SET_SOURCEDIR"  ,&tsourcedir$
 WZPrint "SET_INCDIR"     ,&tincludedir$
 WZPrint "SET_AUTODOCDIR" ,&tautodocdir$
 WZPrint "SET_HELPDIR"    ,&thelpdir$

 WZPrint "SET_UTILLIBS",pedconfig\useUtilLib
 WZPrint "SET_OSLIBS",pedconfig\useOsLib
 WZPrint "SET_CSLIBS",pedconfig\useCsLib

 WZPrint "SET_UTILLIBS_PATH",&tutillibfile$
 WZPrint "SET_OSLIBS_PATH"  ,&toslibfile$
 WZPrint "SET_CSLIBS_PATH"  ,&tcslibfile$

 ;-- get screen infos
 temp_id.l     = pedconfig\screen_modeID
 temp_width.w  = pedconfig\screen_Width
 temp_height.w = pedconfig\screen_Height
 temp_depth.w  = pedconfig\screen_Depth

 ;-- get screenname
 log_Print{"getting screenmodename for id: " + Str$(temp_id)}
 temp_scr$ = screen_GetModeName{temp_id}
 log_Print{"modename = " + Str$(temp_scr$)}

 ;--  check if the ID unknown then get best match
 If temp_scr$ = "unknown"
   log_Print{"screenmode unknown, searching for best match available mode..."}
   If NOT KickVersion(39)
     temp_id.l = 0
     log_Print{"we need OS3+ to do this!"}
   Else
     temp_id.l = screen_GetBestModeID{temp_width,temp_height,temp_depth}
     log_Print{"most matching id: " + Str$(temp_id)}
   EndIf
   temp_scr$ = screen_GetModeName{temp_id}
   log_Print{"modename = " + temp_scr$}
 EndIf

 ;-- set screenrequester initials
 screen_SetASLInitialDims{temp_id,temp_width,temp_height,temp_depth}
 WZPrint "SET_SCREENNAME",&temp_scr$

 ;-- get font infos
 newsourcefont_name$  = sourcefont_name$
 newsourcefont_size.l = sourcefont_size
 newguifont_name$     = guifont_name$
 newguifont_size.l    = guifont_size
 tempstr$             = newsourcefont_name$ + " ("+Str$(newsourcefont_size)+")"
 WZPrint "SET_SOURCEFONTNAME",&tempstr$
 tempstr2$            = guifont_name$+" ("+Str$(guifont_size)+")"
 WZPrint "SET_GUIFONTNAME",&tempstr2$
 olduse_wbfont.b      = pedconfig\use_wbfont               ; temp variables to check former stat
 olduse_wbscreen.b    = pedconfig\use_wbscreen

 If pedconfig\use_wbscreen <> 0
   WZPrint "SET_USEWB"  ,On
   WZPrint "SET_CLONEWB",Off
   WZDisable "SET_SCREENNAME"
   WZDisable "SET_SCREEN"
   For i = 0 To 3
    WZDisable "SET_SCREENCOL" + Str$(i)   ; disable Screencolors
   Next i
   usewbscreen_tmp.b = True             ; temporay variable for prefs window
 Else
   For i = 0 To 3
    WZEnable "SET_SCREENCOL" + Str$(i)    ; enable Screencolors
   Next i
   usewbscreen_tmp.b = False
 EndIf

 If pedconfig\clone_wbscreen <> 0
   WZPrint "SET_USEWB"  ,Off
   WZPrint "SET_CLONEWB",On
   WZDisable "SET_SCREENNAME"
   WZDisable "SET_SCREEN"
   usewbscreen_tmp.b = False
 EndIf

 If pedconfig\use_wbfont = True                   ;<>0
   WZPrint "SET_USEWBFONT", On
   WZDisable "SET_SOURCEFONT"
   WZDisable "SET_SOURCEFONTNAME"
   WZDisable "SET_GUIFONT"
   WZDisable "SET_GUIFONTNAME"
   usewbfont_tmp.b = True               ; temporay variable for prefs window
 Else
   WZPrint "SET_USEWBFONT", Off
   WZEnable "SET_SOURCEFONT"
   WZEnable "SET_SOURCEFONTNAME"
   usewbfont_tmp.b = False
   If usewbscreen_tmp.b = True          ; only active GuiFontsettings if we don't use WBscreen
     WZDisable "SET_GUIFONT"
     WZDisable "SET_GUIFONTNAME"
   Else
     WZEnable "SET_GUIFONTNAME"
     WZEnable "SET_GUIFONT"
   EndIf
 EndIf

 ;-- color wheel
 *cw_gad.Gadget = WZGadAddr("SET_COLORWHEEL")
 cw_open.b          = False                             ; type was .l changed to .b because function return is only .b  tomsmart
 colnum.w           = -1
 rebuild_gui.b      = False
 rebuild_sourcewindow.b = False
 rebuild_menu.b     = False

 settings_loop:
 exit_settings.b    = False
 save_settings.b    = False
 use_settings.b     = False
 reopen_settings.b  = False
 update_colors.b    = False
 SliderUsed.b       = False

 Repeat
   ev.l = WaitEvent

   If pedconfig\onlinehelp <> 0
      If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) AND (ev<>#IDCMP_GADGETHELP)  AND (ev<>#IDCMP_CHANGEWINDOW)
        WZ_HideHelp{}
      Else
        If (ev = #IDCMP_GADGETHELP) Then WZ_ShowHelp{}
      End If
   EndIf

   ;If ev<>#IDCMP_INTUITICKS AND (ev<>#IDCMP_MOUSEMOVE) Then log_Print{Hex$(ev)}

   Select ev
     Case #IDCMP_MOUSEMOVE
       If SliderUsed = True       ; check if colorslider used before
         SliderUsed = False       ; set it back
       Else
         If (WZInput("SET_PAGES") = 3) AND (cw_open = True)
           ; Get current RGB-Value in relation to the Gradient-slider
           _RGB.l = WZ_GetColorWheelRGB{}
           If _RGB <> old_RGB.l
             WZ_SetColorGradientSlider{_RGB}
             Gosub update_colorsliders    ; added to update the colorsilders to the values of the Colorwheel  tomsmart1
             old_RGB = _RGB
             update_colors.b = True
             If colnum<>-1
               AB3RGB_temp(colnum)= _RGB
               Gosub update_colorboxes
             EndIf
           EndIf
         EndIf
       EndIf

     Case #IDCMP_VANILLAKEY
       Select EventCode
         Case #VANILLAKEY_ESC : exit_settings = True
       End Select

     Case #IDCMP_REFRESHWINDOW
       Gosub update_colorwheel
       Gosub update_colorboxes

     Case #IDCMP_CLOSEWINDOW
       exit_settings = True

     Case #IDCMP_IDCMPUPDATE
       ; check the colorgadgets
       ;log_Print{"event: IDCMPUPDATE"}
       ;log_Print{"eventwindow: " + Str$(EventWindow)}
       ;log_Print{"gadid: " + Str$(WZGadHit)}
       ;log_Print{"gadname: " + Str$(WZGadName)}

       If Left$(WZGadName,9) = "SET_COLOR"
         colnum = Vallong(StrChg(WZGadName,"SET_COLOR",""))
         update_colors = True
         Gosub update_colorboxes
         If (ColorWheelError = False)
           WZ_SetColorWheelRGB{AB3RGB_temp(colnum)}
         EndIf
         _RGB = AB3RGB_temp(colnum) : old_RGB = _RGB       ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
         Gosub update_colorsliders  ; added to set the colorsilders to the select color  tomsmart1
       Else
         If Left$(WZGadName,13) = "SET_SCREENCOL"
           colnum.w = Vallong(StrChg(WZGadName,"SET_SCREENCOL","")) + 20
           update_colors = True
           rebuild_gui   = True
           Gosub update_colorboxes
           If (ColorWheelError = False)
             WZ_SetColorWheelRGB{AB3RGB_temp(colnum)}
           EndIf
            _RGB = AB3RGB_temp(colnum) : old_RGB = _RGB    ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
           Gosub update_colorsliders ; added to set the colorsilders to the select color  tomsmart1
         EndIf
       EndIf
       ;log_Print{"check other gadget..."}
       ;-- check all other gadgets
       Select WZGadName

         Case "SET_PAGES"
           If WZInput("SET_PAGES") = 3
             If KickVersion(39)
               Gosub update_colorwheel
               Gosub update_colorboxes
             Else
              error{"Color settings are not available with Workbench <V3.0."}
              WZPrint "SET_PAGES",0
             EndIf
           EndIf
         ; begin check new Gadgets of color page, tempstorage, sliders and integers  tomsmart1
         Case "COPYTOTEMP"        ; copy used color to tempstorage
           AB3RGB_copytemp = _RGB
           Gosub update_colorboxes

         Case "COPYTEMPTO"        ; used color of tempstorage
           _RGB = AB3RGB_copytemp
           Gosub set_color_slider_wheel_boxes

         Case "REDSLIDER"
           RedSlider.l = WZInput
           _RGB = (_RGB & $FF00FFFF) + (RedSlider LSL 16)
           Gosub set_color_slider_wheel_boxes
           SliderUsed = True

         Case "GREENSLIDER"
           GreenSlider.l = WZInput
           _RGB = (_RGB & $FFFF00FF) + (GreenSlider LSL 8)
           Gosub set_color_slider_wheel_boxes
           SliderUsed = True

         Case "BLUESLIDER"
           BlueSlider.l = WZInput
           _RGB = (_RGB & $FFFFFF00) + BlueSlider
           Gosub set_color_slider_wheel_boxes
           SliderUsed = True

         Case "REDIN"
           RedSlider = WZInput
           _RGB = (_RGB & $FF00FFFF) + (RedSlider LSL 16)
           Gosub set_color_slider_wheel_boxes

         Case "GREENIN"
           GreenSlider = WZInput
           _RGB = (_RGB & $FFFF00FF) + (GreenSlider LSL 8)
           Gosub set_color_slider_wheel_boxes

         Case "BLUEIN"
           BlueSlider = WZInput
           _RGB = (_RGB & $FFFFFF00) + BlueSlider
           Gosub set_color_slider_wheel_boxes
         ; end new gadgets of colors page

         Case "SET_SOURCEDIR"
           tsourcedir$ = WZInputstr
           WZPrint "SET_SOURCEDIR",&tsourcedir$

         Case "BUTTON_SOURCEDIR"
           aslfr_SetRequesterTitle {0,!TRANS{ "Please select source directory:"},"",""}
           aslfr_SetPath{0,tsourcedir$,"",""}
           If aslfr_Request{0,False,False,True,sourceWindow\pedScreen}
             tsourcedir$ = aslfr_GetNextFile{}
             WZPrint "SET_SOURCEDIR",&tsourcedir$
           EndIf

         Case "SET_INCDIR"
           tincludedir$ = WZInputstr
           WZPrint "SET_INCDIR",&tincludedir$

         Case "BUTTON_INCDIR"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select includes directory:"},"",""}
           aslfr_SetPath{0,tincludedir$,"",""}
           If aslfr_Request{0,False,False,True,sourceWindow\pedScreen}
             tincludedir$ = aslfr_GetNextFile{}
             WZPrint "SET_INCDIR",&tincludedir$
           EndIf

         Case "SET_HELPDIR"
           thelpdir$ = WZInputstr
           WZPrint "SET_HELPDIR",&thelpdir$

         Case "BUTTON_HELPDIR"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select help directory:"},"",""}
           aslfr_SetPath{0,thelpdir$,"",""}
           If aslfr_Request{0,False,False,True,sourceWindow\pedScreen}
             thelpdir$ = aslfr_GetNextFile{}
             WZPrint "SET_HELPDIR",&thelpdir$
           EndIf

         Case "SET_AUTODOCDIR"
           tautodocdir$ = WZInputstr
           WZPrint "SET_AUTODOCDIR",&tautodocdir$

         Case "BUTTON_AUTODOCDIR"
           aslfr_SetRequesterTitle {0,!TRANS{ "Please select AutoDocs directory:"},"",""}
           aslfr_SetPath{0,tautodocdir$,"",""}
           If aslfr_Request{0,False,False,True,sourceWindow\pedScreen}
             tautodocdir$ = aslfr_GetNextFile{}
             WZPrint "SET_AUTODOCDIR",&tautodocdir$
           EndIf

         Case "BUTTON_UTILLIBS"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select UtilLibs file:"},"",""}
           aslfr_SetPath{0,dos_PathPart{tutillibfile$},dos_FilePart{tutillibfile$},"#?"}
           If aslfr_Request{0,False,False,False,sourceWindow\pedScreen}
             tutillibfile$ = aslfr_GetNextFile{}
             WZPrint "SET_UTILLIBS_PATH",&tutillibfile$
           EndIf

         Case "BUTTON_OSLIBS"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select OsLibs file:"},"",""}
           aslfr_SetPath{0,dos_PathPart{toslibfile$},dos_FilePart{toslibfile$},"#?"}
           If aslfr_Request{0,False,False,False,sourceWindow\pedScreen}
             toslibfile$ = aslfr_GetNextFile{}
             WZPrint "SET_OSLIBS_PATH",&toslibfile$
           EndIf

         Case "BUTTON_CSLIBS"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select CsLibs file:"},"",""}
           aslfr_SetPath{0,dos_PathPart{tcslibfile$},dos_FilePart{toslibfile$},"#?"}
           If aslfr_Request{0,False,False,False,sourceWindow\pedScreen}
             toslibfile$ = aslfr_GetNextFile{}
             WZPrint "SET_CSLIBS_PATH",&tcslibfile$
           EndIf

         Case "SET_PUBSCREEN"
           If WZInput = 0
             WZPrint "SET_DEFAULTPUBSCREEN",Off : WZDisable "SET_DEFAULTPUBSCREEN"
           Else
             WZEnable "SET_DEFAULTPUBSCREEN"
           EndIf
           rebuild_gui = True

         Case "SET_DEFAULTPUBSCREEN"
           rebuild_gui = True

         Case "SET_REMEMBER_SAVED"
           rebuild_menu = True

         Case "SET_CLONEWB"
           If WZInput
             WZDisable "SET_SCREENNAME"
             WZDisable "SET_SCREEN"
             WZPrint   "SET_USEWB",Off
             usewbscreen_tmp.b = False
             If usewbfont_tmp.b = False     ;only actived GUIfontsetting if we don't use WBFonts
               WZEnable "SET_GUIFONTNAME"
               WZEnable "SET_GUIFONT"
             EndIf
           Else
             WZEnable "SET_SCREENNAME"
             WZEnable "SET_SCREEN"
           EndIf
           rebuild_gui = True

         Case "SET_USEWB"
           If WZInput
             For i = 0 To 3
              WZDisable "SET_SCREENCOL"+Str$(i)
             Next i
             WZDisable "SET_SCREENNAME"
             WZDisable "SET_SCREEN"
             WZPrint   "SET_CLONEWB",Off
             usewbscreen_tmp.b = True       ; deactived GUIFontsettings we use WBScreen
             WZDisable "SET_GUIFONT"
             WZDisable "SET_GUIFONTNAME"
           Else
             For i = 0 To 3
              WZEnable "SET_SCREENCOL"+Str$(i)
             Next i
             WZEnable "SET_SCREENNAME"
             WZEnable "SET_SCREEN"
             usewbscreen_tmp.b = False
               If usewbfont_tmp.b = False    ;only actived GUIfontsetting if we don't use WBFonts
                 WZEnable "SET_GUIFONTNAME"
                 WZEnable "SET_GUIFONT"
             EndIf
           EndIf
           rebuild_gui = True

         Case "SET_SCREEN"
           aslsm_SetRequesterTitle {!TRANS{"Please select screenmode:"},"",""} ;!TRANS{"Ok"},!TRANS{"Cancel"}}  ; use system default  tomsmart1
           aslsm_SetMinDims{640,480,2}
           If aslsm_Request{}
              temp_id.l     = screen_GetASLModeID{}
              temp_width.w  = screen_GetASLWidth{}
              temp_height.w = screen_GetASLHeight{}
              temp_depth.w  = screen_GetASLDepth{}
              temp_scr$     = screen_GetASLModeName{}
              log_Print{"selected screen depth: " + Str$(temp_depth),#log_debug}
              WZPrint "SET_SCREENNAME",&temp_scr$
              log_Print{"written screenname... " + temp_scr$}
              rebuild_gui   = True
           EndIf

         Case "SET_GUIFONT"
           aslfo_SetRequesterTitle {!TRANS{"Please select GUI-Font:"},"",""} ;!TRANS{"Ok"},!TRANS{"Cancel"}}  ; use system default  tomsmart1
           aslfo_SetInitialFont{newguifont_name$,newguifont_size}
           If aslfo_Request{True}
             newguifont_name$      = aslfo_GetFontName{}
             newguifont_size   = aslfo_GetFontSize{}
             ;newguifontstyle = *finfo2\ta_Style
             tempstr2$= newguifont_name$ + " ("+Str$(newguifont_size)+")"
             WZPrint "SET_GUIFONTNAME",&tempstr2$
           EndIf

         Case "SET_USEWBFONT"
           If WZInput
             usewbfont_tmp.b = True
             WZDisable "SET_GUIFONT"
             WZDisable "SET_GUIFONTNAME"
             WZDisable "SET_SOURCEFONT"
             WZDisable "SET_SOURCEFONTNAME"
           Else
             usewbfont_tmp.b = False
             WZEnable "SET_SOURCEFONTNAME"
             WZEnable "SET_SOURCEFONT"
             If usewbscreen_tmp.b = False     ; make GUIfont selectable only if we don't use wbscreen
               WZEnable "SET_GUIFONT"
               WZEnable "SET_GUIFONTNAME"
             EndIf
           EndIf
           rebuild_gui = True

         Case "SET_SOURCEFONT"
           aslfo_SetRequesterTitle {!TRANS{"Please select Source-Font:"},"",""} ;!TRANS{"Ok"},!TRANS{"Cancel"}}  ; use system default tomsmart1
           aslfo_SetInitialFont{newsourcefont_name$,newsourcefont_size}
           If aslfo_Request{False}
             newsourcefont_name$     = aslfo_GetFontName{}
             newsourcefont_size  = aslfo_GetFontSize{}
             ;newsourcefontstyle = *finfo2\ta_Style
             tempstr$= newsourcefont_name$ + " ("+Str$(newsourcefont_size)+")"
             WZPrint "SET_SOURCEFONTNAME",&tempstr$
           EndIf


         Case "SET_F4"
           savewinpref{0} : Gosub write_newprefs

         Case "SET_F5"
           savewinpref{1} : Gosub write_newprefs

         Case "SET_F6"
           savewinpref{2} : Gosub write_newprefs


         ; UNTERSTE BUTTON-ZEILE
         Case "SET_SAVE"
           save_settings   = True
           use_settings    = True
           exit_settings   = True

         Case "SET_USEEXIT"
           use_settings    = True
           exit_settings   = True

         Case "SET_USE"
           use_settings    = True
           exit_settings   = True
           reopen_settings = True

         Case "SET_CANCEL"
           use_settings    = False
           reopen_settings = False
           exit_settings   = True

       End Select

      ;log_Print{"end_of_event"}
   End Select
 Until exit_settings = True

 ;log_Print{"settings loop finished."}
 If use_settings = True
   log_Print{"storing all settings"}
   WZ_LockWindow{"WIN_SETTINGS"}

   pedconfig\auto_indent =       -WZInput("SET_AUTO_INDENT")
   pedconfig\auto_format =       -WZInput("SET_AUTO_FORMAT")
   pedconfig\auto_constructs =   -WZInput("SET_COMPLETE_CONSTRUCTS")
   pedconfig\intellisense =      -WZInput("SET_INTELLISENSE")
   pedconfig\correct_functions=  -WZInput("SET_CORRECT_FUNCTIONS")
   pedconfig\smart_tokenization= -WZInput("SET_SMART_TOKENIZATION")
   pedconfig\no_welcome =        -WZInput("SET_WELCOME")
   pedconfig\ask_before_quit =   -WZInput("SET_ASKBEFOREQUIT")
   pedconfig\localization =      NOT(-WZInput("SET_LOCALIZATION"))
   pedconfig\onlinehelp =        -WZInput("SET_ONLINEHELP")
   pedconfig\bold_tokens =       -WZInput("SET_BOLDTOKENS")
   pedconfig\highlighting =      -WZInput("SET_HIGHLIGHTING")
   pedconfig\italic_remarks =    -WZInput("SET_ITALICREMARKS")
   pedconfig\linenumbers =       -WZInput("SET_LINENUMBERS")
   pedconfig\remember_saved =    -WZInput("SET_REMEMBER_SAVED")
   pedconfig\load_last_source =  -WZInput("SET_LAST_SOURCE")
   pedconfig\use_pubscreen    =  -WZInput("SET_PUBSCREEN")
   pedconfig\use_default_pubscreen = -WZInput("SET_DEFAULTPUBSCREEN")
   pedconfig\use_filepattern  =  -WZInput("SET_FILEPATTERN")
   pedconfig\use_wbscreen =      -WZInput("SET_USEWB")
   pedconfig\clone_wbscreen =    -WZInput("SET_CLONEWB")
   pedconfig\use_wbfont =        -WZInput("SET_USEWBFONT")
   pedconfig\no_display_beep =   -WZInput("SET_NO_DISPLAYBEEP")
   pedconfig\console_device  =    WZGetString("SET_CONSOLE_DEVICE")
   ;console_keepopen = WZInput("SET_CONSOLE_KEEPOPEN")
   pedconfig\console_wb       =  -WZInput("SET_CONSOLE_ON_WB")
   pedconfig\console_wait     =  -WZInput("SET_CONSOLE_WAIT")
   pedconfig\sort_labels =       -WZInput("SET_SORTLABELS")
   pedconfig\scroll_rate =        WZInput("SET_SCROLLRATE")
   pedconfig\cursorStyle =        WZInput("SET_CURSORSTYLE")
   If pedconfig\scroll_rate = 0 Then ped\no_scrollrate = True Else vvblank_SetFreq{pedconfig\scroll_rate}

   pedconfig\tab_size =  WZInput("SET_TAB_SIZE")
   Poke.w ?tab_size, pedconfig\tab_size

   pedconfig\blinkrate =  WZInput("SET_CURSORBLINKRATE")
   pedconfig\wheelStep =  WZInput("SET_MOUSEWHEELSTEP")     ; added to make Mousewheelsteprate changeable, no special OS4 handling nessacary because the System settings are used by any event  tomsmart1
   pedconfig\autolayout= -WZInput("SET_AUTOLAYOUT")

   ; store directories
   pedconfig\sourceDir  = tsourcedir$
   pedconfig\includeDir = tincludedir$
   pedconfig\autodocDir = tautodocdir$
   pedconfig\helpDir    = thelpdir$


   pedconfig\useUtilLib  = -WZInput("SET_UTILLIBS")
   pedconfig\useOsLib  = -WZInput("SET_OSLIBS")
   pedconfig\useCsLib  = -WZInput("SET_CSLIBS")

   pedconfig\utillibFile = tutillibfile$
   pedconfig\oslibFile  = toslibfile$
   pedconfig\cslibFile  = tcslibfile$

   Poke.l ?ptr_incdirname      ,&pedconfig\includeDir
   Poke.l ?ptr_deflibsfilename ,&pedconfig\utillibFile


   If temp_id <> pedconfig\screen_modeID
     pedconfig\screen_modeID = temp_id
     pedconfig\screen_Width = temp_width
     pedconfig\screen_Height = temp_height
     pedconfig\screen_Depth = temp_depth
     rebuild_gui    = True
   EndIf

   If ( (newguifont_name$<>guifont_name$) OR (newguifont_size<>guifont_size) ) AND ( (NOT pedconfig\use_wbfont) AND (pedconfig\use_wbscreen=0) )
     guifont_name$   = newguifont_name$
     guifont_size    = newguifont_size
     guifont_style.l = newguifont_style.l
     rebuild_gui    = True
   Else
     If ( (pedconfig\use_wbfont AND (NOT olduse_wbfont) ) AND olduse_wbscreen=0 ) OR ( ( (pedconfig\use_wbscreen<>0) AND (olduse_wbscreen=0) ) AND (NOT olduse_wbfont) )
      log_Print{"setguifonttowbscreenfont"}
      Gosub SetGuiFontToWBScreenFont
      rebuild_gui = True
     EndIf
   EndIf


   ; update colors
   If update_colors = True
     For i = 0 To (#MAX_AB3Pens-1) ; relaced wrong 24 by #Max_AB3Pens -1, -1 because 0 to 23  tomsmart1
       AB3RGB(i) = AB3RGB_temp(i)
     Next i
     If rebuild_gui = False          ; update screencolors only if GUI not rebuild else we trash maybe the Wbscreencolors
       Gosub set_storedcolors
       update_colors.b = False
     EndIf
   EndIf

   If ( (newsourcefont_name$ <> sourcefont_name$) OR (newsourcefont_size <> sourcefont_size) ) AND (NOT pedconfig\use_wbfont)
     sourcefont_name$ = newsourcefont_name$
     sourcefont_size  = newsourcefont_size
     sourcefont_style.b = newsourcefont_style.b
     Gosub open_sourcefonts
     rebuild_sourcewindow = True
   EndIf

   If pedconfig\use_wbfont AND (NOT olduse_wbfont)
     ; get WBfont for Sourcefont
     sourcefont_name$ = ""     ;that open_sourcefonts get the WBfont
     Gosub open_sourcefonts
     rebuild_sourcewindow = True
   EndIf

   If oldlinenumbers <> pedconfig\linenumbers Then rebuild_sourcewindow = True

   If (rebuild_sourcewindow = True) AND (rebuild_gui = False)
     log_Print{"rebuilding the source window..."}

     Gosub set_pointer_busy_bas
     Gosub free_textbuffer
     Gosub close_sourcewindow
     Gosub open_sourcewindow
     If ped\errorCode = #PEDERROR_OPENWINDOW
       dummy.l = ask{!TRANS{"Unable to open window"},!TRANS{"Ok"},!TRANS{"Error"}}
       Pop If
       Goto exit_PED_closeall
     EndIf

     Gosub allocate_textbuffer
     Gosub set_pointer_normal_bas
     WindowToFront_ Peek.l(Addr Window(WZID("WIN_SETTINGS")))
   Else
     log_Print{"just redraw source"}
     !asm
     JSR _redraw
     !basic
   EndIf

   WZ_UnlockWindow{"WIN_SETTINGS"}
 EndIf

 If reopen_settings Then Goto settings_loop

 If save_settings
   log_Print{"saving settings..."}
   WZ_LockWindow{"WIN_SETTINGS"}
   Gosub write_newprefs
   Gosub set_tooltypes
   WZ_UnlockWindow{"WIN_SETTINGS"}
   log_Print{"saving settings done"}
 EndIf

 If cw_open Then WZ_KillColorWheel{} : cw_open = False
 WZCloseWindow WZID("WIN_SETTINGS")
 FlushEvents
 WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                               
 Gosub set_pointer_normal_bas

 If rebuild_gui
   log_Print{"rebuilding the gui..."}
   Gosub close_gui
   Gosub open_sourcefonts
   Gosub open_gui
 EndIf
 If rebuild_menu
   Gosub init_menus
 EndIf

 Gosub activatesourcewindow
Return


.update_colorboxes
   If WZInput("SET_PAGES") = 3
     WZ_LockWindow{"WIN_SETTINGS"}    ; added to prevent page switch during drawing  tomsmart1
     *winSettings.Window = Peek.l(Addr Window(WZID("WIN_SETTINGS")))
     boxpen.w = 1
     boxcolor.w = 0
     For ii.l = 1 To 12
       If ii = colnum Then boxpen = 2 Else boxpen = 1
       *gad.Gadget = WZGadAddr("SET_COLOR"+Str$(ii))
       If *gad
         boxx.w = *gad\LeftEdge + *gad\Width + 2
         boxw.w = boxx + 20
         boxy.w = *gad\TopEdge
         boxh.w = boxy + *gad\Height - 1
         boxcolor.w = screen_GetPenRGB{AB3RGB_temp(ii)}
         SetAPen_ *winSettings\RPort,boxcolor : RectFill_ *winSettings\RPort,boxx+1,boxy+1,boxw-1,boxh-1
         SetAPen_ *winSettings\RPort,boxpen
         Move_ *winSettings\RPort,boxx,boxy
         Draw_ *winSettings\RPort,boxw,boxy
         Draw_ *winSettings\RPort,boxw,boxh
         Draw_ *winSettings\RPort,boxx,boxh
         Draw_ *winSettings\RPort,boxx,boxy
       EndIf
     Next ii

     For ii = 0 To 3
       If 20+ii = colnum Then boxpen = 2 Else boxpen = 1
       *gad.Gadget = WZGadAddr("SET_SCREENCOL"+Str$(ii))
       If *gad
         boxx = *gad\LeftEdge + *gad\Width + 2
         boxw = boxx + 20
         boxy = *gad\TopEdge
         boxh = boxy + *gad\Height - 1
         SetAPen_ *winSettings\RPort,screen_GetPenRGB{AB3RGB_temp(20+ii)}
         RectFill_ *winSettings\RPort,boxx+1,boxy+1,boxw-1,boxh-1
         SetAPen_ *winSettings\RPort,boxpen
         Move_ *winSettings\RPort,boxx,boxy
         Draw_ *winSettings\RPort,boxw,boxy
         Draw_ *winSettings\RPort,boxw,boxh
         Draw_ *winSettings\RPort,boxx,boxh
         Draw_ *winSettings\RPort,boxx,boxy
       EndIf
     Next ii

     ; begin temporaycopy color
      *gad.Gadget = WZGadAddr("COPYTOTEMP")
       If *gad
         boxx = *gad\LeftEdge + *gad\Width + 2
         boxw = boxx + 16
         boxy = *gad\TopEdge
         boxh = boxy + *gad\Height
         SetAPen_ *winSettings\RPort,screen_GetPenRGB{AB3RGB_copytemp}
         RectFill_ *winSettings\RPort,boxx+1,boxy+1,boxw-1,boxh-1
         SetAPen_ *winSettings\RPort,boxpen
         Move_ *winSettings\RPort,boxx,boxy
         Draw_ *winSettings\RPort,boxw,boxy
         Draw_ *winSettings\RPort,boxw,boxh
         Draw_ *winSettings\RPort,boxx,boxh
         Draw_ *winSettings\RPort,boxx,boxy
       EndIf
     WZ_UnlockWindow{"WIN_SETTINGS"}  ; added to prevent page switch during drawing  tomsmart1
   EndIf
Return


.update_colorwheel:
  If (WZInput("SET_PAGES") = 3) AND (ColorWheelError = False)
    If cw_open
      WZ_KillColorWheel{}
      RefreshWindowFrame_ Peek.l(Addr Window(WZID("WIN_SETTINGS")))
      cw_open = False
    EndIf

    WZ_LockWindow{"WIN_SETTINGS"}  ; added to prevent page switch during drawing  tomsmart1
    cw_open = WZ_DrawColorWheel{*cw_gad\LeftEdge,*cw_gad\TopEdge,*cw_gad\Width,*cw_gad\Height,False}; added flag to not show the error message of the include  tomsmart1
    If cw_open
      If colnum <> -1
        WZ_SetColorWheelRGB{AB3RGB_temp(colnum)} : _RGB = AB3RGB_temp(colnum) : old_RGB = _RGB    ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
      Else
        WZ_SetColorWheelRGB{$FFFFFF}             : _RGB = $FFFFFF : old_RGB = _RGB                ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
        Gosub update_colorsliders  ; added to set the silder to the default settings  tomsmart1
      EndIf
    Else
      ColorWheelError = True
      error{!TRANS{"error creating colorwheel"} }   ; convert to a normal error message  tomsmart1
    EndIf
    WZ_UnlockWindow{"WIN_SETTINGS"}  ; added to prevent page switch during drawing  tomsmart1
  Else     ; not page 2
    If cw_open
      WZ_KillColorWheel{}
      cw_open = False
    EndIf
  EndIf
Return


.update_colorsliders:     ; added to set the colorsliders position and value of the colorintger gadgets  tomsmart1
  RedSlider   = ( (_RGB & $00FF0000) LSR 16)
  GreenSlider = ( (_RGB & $0000FF00) LSR 8)
  BlueSlider  =   (_RGB & $000000FF)
  ;log_Print{Hex$(_RGB) + "  " + Hex$(RedSlider) + "  " + Hex$(GreenSlider) + "  " + Hex$(BlueSlider)}
  WZPrint "REDSLIDER"  , RedSlider
  WZPrint "GREENSLIDER", GreenSlider
  WZPrint "BLUESLIDER" , BlueSlider
  WZPrint "REDIN"      , RedSlider
  WZPrint "GREENIN"    , GreenSlider
  WZPrint "BLUEIN"     , BlueSlider
Return


.set_color_slider_wheel_boxes:  ;added to set the color -wheel, -boxes, -slider and -intger gadgets for a colorslider or intger gadget change  tomsmart1
  old_RGB = _RGB
  If (ColorWheelError = False)
    WZ_SetColorWheelRGB{_RGB}     ; update the ColorWheel and GradientSlider
  EndIf
  Gosub update_colorsliders     ; update the sliders and the intger gadgets
  If colnum <> -1               ; check if a AB3color is set to change
    update_colors = True
    AB3RGB_temp(colnum) = _RGB  ; set it to the color we set by the slider or get intger gadget
    Gosub update_colorboxes     ; redraw the boxes
  EndIf
Return


.set_tooltypes:
   If disk_object
      log_Print{"saving tooltypes"}
       mypath$ = dos_GetProgDir{""}

       ; -- save colors
       dos_SetToolString{"FUNCTIONCOLOR"   ,"$"+Hex$(AB3RGB(#AB3_cfunction))}
       dos_SetToolString{"MACROCOLOR"      ,"$"+Hex$(AB3RGB(#AB3_cmacro))}
       dos_SetToolString{"STRINGCOLOR"     ,"$"+Hex$(AB3RGB(#AB3_cstring))}
       dos_SetToolString{"NEWTYPECOLOR"    ,"$"+Hex$(AB3RGB(#AB3_cnewtype))}
       dos_SetToolString{"CONSTANTCOLOR"   ,"$"+Hex$(AB3RGB(#AB3_cconstant))}
       dos_SetToolString{"REMARKFORG"      ,"$"+Hex$(AB3RGB(#AB3_cremarkforeground))}
       dos_SetToolString{"REMARKBACKG"     ,"$"+Hex$(AB3RGB(#AB3_cremarkbackground))}
       dos_SetToolString{"TOKENCOLOR"      ,"$"+Hex$(AB3RGB(#AB3_ctoken))}
       dos_SetToolString{"TOKENBACKPEN"    ,"$"+Hex$(AB3RGB(#AB3_ctokenbackground))}
       dos_SetToolString{"BACKGROUNDCOLOR" ,"$"+Hex$(AB3RGB(#AB3_cbackground))}
       dos_SetToolString{"OTHERCOLOR"      ,"$"+Hex$(AB3RGB(#AB3_cother))}
       dos_SetToolString{"CLASSICCOLOR"    ,"$"+Hex$(AB3RGB(#AB3_cclassic))}
       dos_SetToolString{"screenbackcolor" ,"$"+Hex$(AB3RGB(#AB3_screenback))}
       dos_SetToolString{"screentextcolor" ,"$"+Hex$(AB3RGB(#AB3_screentext))}
       dos_SetToolString{"screenshinecolor","$"+Hex$(AB3RGB(#AB3_screenshine))}
       dos_SetToolString{"screenfillcolor" ,"$"+Hex$(AB3RGB(#AB3_screenfill))}

       ; save Screen settings
       dos_SetToolSwitch{"USE_WBSCREEN"    ,pedconfig\use_wbscreen}  ;-WZInput("SET_USEWB")}
       dos_SetToolSwitch{"CLONE_WBSCREEN"  ,pedconfig\clone_wbscreen};-WZInput("SET_CLONEWB")}
       dos_SetToolSwitch{"DEFAULTPUBSCREEN",pedconfig\use_default_pubscreen};-WZInput("SET_DEFAULTPUBSCREEN")}
       dos_SetToolSwitch{"PUBSCREEN"       ,pedconfig\use_pubscreen} ;-WZInput("SET_PUBSCREEN")}

       ;save ownscreen parameters
       dos_SetToolValue{"SCREEN_ID"        ,pedconfig\screen_modeID}
       dos_SetToolValue{"SCREEN_WIDTH"     ,pedconfig\screen_Width}
       dos_SetToolValue{"SCREEN_HEIGHT"    ,pedconfig\screen_Height}
       dos_SetToolValue{"SCREEN_DEPTH"     ,pedconfig\screen_Depth}

       ; save Font settings
       dos_SetToolSwitch{"USE_WBFONT"      ,pedconfig\use_wbfont} ;-WZInput("SET_USEWBFONT")}
       If pedconfig\use_wbfont = False
         If newsourcefont_name$ <>""
           dos_SetToolSwitch{"SOURCEFONT"  ,True}       ; actived tooltype maybe it was deactived
           dos_SetToolString{"SOURCEFONT"  ,newsourcefont_name$ + "," + Str$(newsourcefont_size)}
         Else
           dos_SetToolSwitch{"SOURCEFONT"  ,False}      ; deactived Sourcefont Tooltypes no font is set
         EndIf
         If newguifont_name$ <>"" AND pedconfig\use_wbscreen = False ;WZInput("SET_USEWB")=False   ;
           dos_SetToolSwitch{"GUIFONT"     ,True}       ; actived tooltype maybe it was deactived
           dos_SetToolString{"GUIFONT"     ,newguifont_name$ + "," + Str$(newguifont_size)}
         Else
           dos_SetToolSwitch{"GUIFONT"     ,False}      ; deactived GUIfont Tooltypes no font is set or we use the WBscreen
         EndIf
       Else
         dos_SetToolSwitch{"GUIFONT"       ,False}      ; deactived GUIfont Tooltypes we use WBfonts
         dos_SetToolSwitch{"SOURCEFONT"    ,False}      ; deactived Sourcefont Tooltypes we use WBfonts
       EndIf

       ; save other settings
       dos_SetToolSwitch{"ASKBEFOREQUIT"        , pedconfig\ask_before_quit};-WZInput("SET_ASKBEFOREQUIT")}
       dos_SetToolSwitch{"DISABLE_WELCOME"      , pedconfig\no_welcome}     ;-WZInput("SET_WELCOME")}
       dos_SetToolSwitch{"DISABLE_DISPLAYBEEP"  , pedconfig\no_display_beep};-WZInput("SET_NO_DISPLAYBEEP")}
       dos_SetToolSwitch{"DISABLE_LOCALIZATION" , NOT pedconfig\localization}
       dos_SetToolSwitch{"AUTO_FORMAT"          , pedconfig\auto_format}    ;-WZInput("SET_AUTO_FORMAT")}
       dos_SetToolSwitch{"AUTO_INDENT"          , pedconfig\auto_indent}    ;-WZInput("SET_AUTO_INDENT")}     ; add because was not saved before  tomsmart1
       dos_SetToolSwitch{"AUTO_CONSTRUCTS"      , pedconfig\auto_constructs};-WZInput("SET_COMPLETE_CONSTRUCTS")}
       dos_SetToolSwitch{"USE_INTELLISENSE"     , pedconfig\intellisense}   ;-WZInput("SET_INTELLISENSE")}
       dos_SetToolSwitch{"CORRECT_FUNCTIONS"    , pedconfig\correct_functions};-WZInput("SET_CORRECT_FUNCTIONS")}
       dos_SetToolSwitch{"SMART_TOKENIZATION"   , pedconfig\smart_tokenization} ;-WZInput("SET_SMART_TOKENIZATION")}
       dos_SetToolSwitch{"DISABLE_HIGHLIGHTING" , NOT pedconfig\highlighting}
       dos_SetToolSwitch{"BOLD_TOKENS"          , pedconfig\bold_tokens}
       dos_SetToolSwitch{"ITALIC_REMARKS"       , pedconfig\italic_remarks}
       dos_SetToolSwitch{"LINENUMBERS"          , pedconfig\linenumbers}
       dos_SetToolSwitch{"ONLINEHELP"           , pedconfig\onlinehelp}    ;-WZInput("SET_ONLINEHELP")}

       dos_SetToolSwitch{"AUTOLAYOUT"           , pedconfig\autolayout}
       dos_SetToolSwitch{"USE_FILEPATTERN"      , pedconfig\use_filepattern}
       dos_SetToolSwitch{"SOURCE_HISTORY"       , pedconfig\remember_saved};-WZInput("SET_REMEMBER_SAVED")}
       dos_SetToolSwitch{"LOAD_LAST_SOURCE"     , pedconfig\load_last_source};-WZInput("SET_LAST_SOURCE")}
       dos_SetToolSwitch{"SORT_LABELS"          , pedconfig\sort_labels}
       dos_SetToolString{"CURSORSTYLE"          , cursorStyleGetString{pedconfig\cursorStyle}}
       dos_SetToolValue{"SCROLLRATE"            , pedconfig\scroll_rate}
       If OSVersion <> #AmigaOS4                                        ; check if not OS4 than save the value, because on OS4 the System value is used  tomsmart1
         dos_SetToolValue{"MOUSEWHEELSTEP"      , pedconfig\wheelStep}   ; added to make Mousewheelsteprate configuatable and saveable  tomsmart1
       EndIf

       ; save console settings
       dos_SetToolString{"CON_DEVICE" ,pedconfig\console_device}
       dos_SetToolSwitch{"CON_ONWB"   ,pedconfig\console_wb}
       dos_SetToolSwitch{"CON_WAIT"   ,pedconfig\console_wait}

       dos_SetToolValue{"CURSORBLINKRATE",pedconfig\blinkrate}

       ; save pathes
       dos_SetToolString{"HELPDIR"    ,pedconfig\helpDir}
       dos_SetToolString{"AUTODOCDIR" ,pedconfig\autodocDir}
       dos_SetToolString{"SOURCEDIR"  ,pedconfig\sourceDir}
       dos_SetToolString{"INCLUDEDIR" ,pedconfig\includeDir}

       dos_SetToolString{"UTILLIBS"   ,pedconfig\utillibFile} : dos_SetToolState{"UTILLIBS",pedconfig\useUtilLib}
       dos_SetToolString{"OSLIBS"     ,pedconfig\oslibFile} : dos_SetToolState{"OSLIBS",pedconfig\useOsLib}
       dos_SetToolString{"CSLIBS"     ,pedconfig\cslibFile} : dos_SetToolState{"CSLIBS",pedconfig\useCsLib}

       ;update AND write Icon
       dos_FlushToolTypes{}

   EndIf
Return

.menu_iconify:
  If KickVersion(36)
    Gosub close_gui
    *appMenuItem.l = AddAppMenuItemA_(0,0,&ped\defaultPubscreenName,*WBMsgPort,Tags(#TAG_DONE,#TAG_END))
    log_Print{"generated appmenuitem, waiting for uniconify command..."}
    WaitPort_ *WBMsgPort
    *msg.Message = GetMsg_(*WBMsgPort)
    ReplyMsg_ *msg
    log_Print{"... got message, reopening."}
    RemoveAppMenuItem_ *appMenuItem
    MOVEA.l comPtr_CurrentSourceLine,A2
    Gosub open_gui
  EndIf
Return

.taglist_pointer_normal:
  Dc.b $80,$00,$00,$97               ; #WA_Pointer
  Ds.l 2

.set_pointer_normal:
  !regs2stack
  !basic
  Gosub set_pointer_normal_bas
  !asm
  !stack2regs
RTS

.set_pointer_normal_bas:
  USEPATH sourceWindow
  If \win
    If KickVersion(39) Then SetWindowPointerA_ \win, Tags(#WA_Pointer,Null,#TAG_END,0)
    If (Peek.l(?addr_menustrip) <> 0)
      ResetMenuStrip_ \win,Peek.l(?addr_menustrip)
      ; set it back to the flags that are used by open the window  tomsmart1
      ModifyIDCMP_ \win, SourceWindowIDCMPFlags.l
    EndIf
  EndIf
Return

.taglist_pointer_busy:
  Dc.b $80,$00,$00,$98               ; #WA_BusyPointer.
  Dc.b $FF,$FF,$FF,$FF
  Ds.l 1

.set_pointer_busy:
  !regs2stack
  !basic
  Gosub set_pointer_busy_bas
  !asm
  !stack2regs
RTS

.set_pointer_busy_bas:
  USEPATH sourceWindow
  If \win
    If KickVersion(39) Then SetWindowPointerA_ \win, ?taglist_pointer_busy ;Tags(#WA_BusyPointer,$FFFFffff,#TAG_END,0)
    ; remove menustrip to prevent use of menu
    ClearMenuStrip_ \win
    ; only allow following flags to lock the sourcewin
    ModifyIDCMP_ \win, #IDCMP_NEWSIZE|#IDCMP_REFRESHWINDOW|#WFLG_REPORTMOUSE
  EndIf
Return


.write_infofile:
  tmp_string.s = ped\sourceFileComplete + ped\extention_info
  *icon_flock.l = Lock_(&tmp_string, #ACCESS_READ)
  If *icon_flock = 0
    *icon_fh.l = Open_(&tmp_string,#HUNK_RELOC_8__MODE_NEWFILE)
    Write_ *icon_fh,Peek.l(?sourceicon_datas),?sourceicondatas_end-?sourceicon_datas
    Close_ *icon_fh
  Else
    log_Print{"iconfile is locked.",#log_warning}
    UnLock_ *icon_flock
  EndIf
RTS


.open_xtrafile:
  !basic
  MOVE.l d2,d0 : accessmode.l = PutD0
  tmp_string.s = ped\sourceFileComplete + ped\extention_xtra
  log_Print{"open xtrafile: " + tmp_string}
  *xtra_fh.l = Open_(&tmp_string,accessmode)
  MOVE.l d0,d7
  !asm
RTS

.menu_load:
  log_Print{"menu Load called."}

  If ped\ptrCurrentSourceData\SourceChanged
    dummy.l = ask{!TRANS{"You have unsaved changes!"},!TRANS{"Continue|Cancel"},!TRANS{"Load File"}}
    If dummy = 0
      Pop If : Pop If
      Return
    EndIf
  EndIf

  aslfr_SetRequesterTitle {1,!TRANS{"Load source file"},!TRANS{"Load"},!TRANS{"Cancel"}}

  If pedconfig\use_filepattern
    aslfr_SetPath  {1,ped\currentDir,ped\currentFile,ped\filePattern,False}
  Else
    aslfr_SetPath  {1,ped\currentDir,ped\currentFile,"",False}
  EndIf
  ASL_x = 14
  ASL_y = 36
  If aslfr_Request {1,False,False,False,-1,False}
    loadsourcefilename.s = aslfr_GetNextFile{}
    If loadsourcefilename.s <> ""
      Gosub load_source
    EndIf
  EndIf
  log_Print{"menu load finished."}
Return


.set_CurrentDir:

  log_Print{"current dir is [" + ped\currentDir + "]"}

  If ped\currentDir = "" Then ped\currentDir = dos_GetCurrentDir{}
  
  log_Print{"lock current directory [" + ped\currentDir + "]"}

  If *flock_currentDir.l Then UnLock_ *flock_currentDir

  *flock_currentDir = Lock_(&ped\currentDir,#ACCESS_READ)
  If *flock_currentDir
    CurrentDir_ *flock_currentDir
  Else
    log_Print{"could not lock the given dir, error #" + Str$(IoErr_),#log_warning}
  EndIf
Return



.load_source:  ;D7: sourcefilename: not used anymore
  Gosub set_pointer_busy_bas
  WZ_LockAllOpenWindows{}                                                                                                                                                                                                                                
  PED_ShowMessage{!TRANS{"Loading file"} + " " + loadsourcefilename + "..."}
  If loadsourcefilename.s <> ""
    log_Print{"getting extension for ["+loadsourcefilename.s + "]"}
    ex.s = dos_GetExt{loadsourcefilename.s}
    log_Print{"loading source <" + loadsourcefilename.s + ">, <" + ex + ">"}
  Else
    ex.s = "???"
  End If

  If ex.s = "ab3" OR ex.s = "ab2" OR ex.s = "bb2"
    log_Print{"using routine for loading source..."}

    ; call sourceload routine from compiler
    GetD0 &loadsourcefilename.s
    !asm
    MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
    !ComData_JSR{comFunc_LoadSource}
    !basic

    log_Print{"loaded " + Str$(Peek.l(?comLong_TotalLines)) + " lines of text"}

    Gosub storeCurrentSourceData

    ;-- restore windows
    Gosub RestoreLabelAndNewtypeWin
    project_changelog$ = ""

    Gosub update_versiongadgets
    Gosub analyze_loadedsource
    Gosub calc_SourceWindowDimensions

    lineNum.l = Peek.l(?comLong_CursorPosStore)
    log_Print{"goto last line: " + Str$(lineNum)}
    clearColumn.b = False : Gosub gotoline

    log_Print{"deleting and restoring prefs..."}
    Gosub delete_tempprefs
    Gosub save_tempprefs

  Else
    Gosub other_loading_routine
    Gosub storeCurrentSourceData
    Gosub analyze_loadedsource
    Gosub calc_SourceWindowDimensions
  EndIf


  log_Print{"updating sourcewindow..."}
  Gosub draw_statusarea
  Gosub update_labelstuff
  Gosub update_scrollers

  !asm
  JSR _redraw
  !basic

  log_Print{"unlock wizard windows."}
  PED_ShowMessage{""}

  WZ_UnlockAllOpenWindows{}
  Gosub set_pointer_normal_bas
  Poke.b ?convert, 0
Return

.other_loading_routine:
  log_Print{"other loading routine called..."}

  ped\sourceFileHandle = PED_OpenFile{loadsourcefilename.s,#HUNK_RELOC_16__MODE_OLDFILE,True}
  ped\sourceFileComplete = loadsourcefilename

  log_Print{"... file " + loadsourcefilename + " opened with handle " + Hex$(ped\sourceFileHandle)}

  Poke.w ?comWord_DoTokenize, ped\DoTokenize
;  Poke.w ?flag_tokenization, ped\flag_tokenization
  Poke.b ?convert, ped\convert

  log_Print{"loading file to cache"}
  If NOT PED_ReadFileCache{}
    log_Print{"could not read file...",#log_error}
    PED_CloseFile{ped\sourceFileHandle}
    Pop If : Return
  EndIf

  If Peek.b(?convert) = 1
    ped\sourceFileComplete = UnLeft$(ped\sourceFileComplete,4) + ".ab3"
  EndIf

  ped\currentDir = dos_PathPart{ped\sourceFileComplete}
  ped\currentFile = dos_FilePart{ped\sourceFileComplete}
  Poke.s ?comStr_SourceName,dos_FilePart{ped\sourceFileComplete}
  Poke.s ?comStr_CurrentDir,dos_PathPart{ped\sourceFileComplete}
  Gosub set_CurrentDir

  Gosub set_pointer_busy_bas
  Gosub reset_Blockflag
  Gosub free_actualsource

  Poke.l ?comLong_TotalLines, 1

  tmpLine.s = PED_ReadNextLine{}

  *newLine.sourceLine = PED_CreateNewSourceLine{tmpLine}
  ped\ptrCurrentSourceData\FirstSourceLine = *newLine
  ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
  ped\ptrCurrentSourceData\LastSourceLine = *newLine

  Repeat
    *currLine.sourceLine = *newLine
    tmpLine = PED_ReadNextLine{}
    tmpLen.w = FLen(tmpLine)
;    log_Print{Str$(tmpLen) + " [" + tmpLine + "]"}

    If tmpLine <> "NoCOntenTwasDelivered"
      If ped\DoTokenize
        MaxLen linebuff$ = 256
        ; process the ascii data in sourcebuff length and write the tokenized source into destbuffer
        ; the return value is the length of the tokenized text
        ; sourcebuff and destbuff might be the same pointer
        ; preproc_Tokenize{*tn.preprocessor,sourcebuff.l,destbuff.l,bytelength.l}
        preproc_Tokenize{*PreProcessor,&tmpLine,&linebuff$,FLen(tmpLine)}
        tmpLine = Peek.s(&linebuff$)
      Else
        tmpLine = Replace$(tmpLine,Chr$(9)," ")
      EndIf
      *newLine = PED_CreateNewSourceLine{tmpLine}

;      log_Print{"[" + Str$(*newLine\strLength)+ "] >> " + Peek.s(*newLine+9)}

      ped\ptrCurrentSourceData\LastSourceLine = *newLine
      *currLine\nextLine = *newLine
      *newLine\previousLine = *currLine
      Poke.l ?comLong_TotalLines, Peek.l(?comLong_TotalLines) + 1
    Else
      tmpLen = 0
    EndIf
  Until tmpLen = 0 AND (readcache\moreBytes = False)

  PED_CloseFile{ped\sourceFileHandle}

  ped\ptrCurrentSourceData\SourceChanged = 0
  CLR.w comWord_TextBufferOffset
  CLR.w comWord_Column        ; was .l
  CLR.w comWord_ColumnsOffset ; was .l
  CLR.l comLong_DisplayLineOffset
  CLR.l comLong_DisplayLine

  ;--
  ;-- read optional xtrafile
  ;--

  !asm
  BRA skip_loadingxtrafile

  MOVE.l comFunc_ReadXtraFile,D0
  BEQ.w skip_loadingxtrafile

  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2 ; read xtra
  JSR open_xtrafile                      ; returns D7: filehandle
  BEQ.w skip_loadingxtrafile

  MOVE.l comFunc_ReadXtraFile,D0
  MOVEA.l D0,A5
  JSR (A5)

  !basic
  log_Print{"opening xtrafile  done."}
  Read_ *xtra_fh, ?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin ; xtrabuf,36

;  stackSize.l = Peek.l(?comLong_StackSizeStore)
;  If stackSize<4096 Then stackSize=4096
;  Poke.l ?stacksize,stackSize
;
  ; -- get the data for creating executables
  exefilename$ = ""
  exepathname$ = ""
  tempexename$ = SPACE$(96)

  Seek_ *xtra_fh,$256,#OFFSET_BEGINNING
  Read_ *xtra_fh,&tempexename$,96
  i = 1
  Repeat
    char$ = Mid$(tempexename$,i,1)
    If Asc(char$)<>0 Then exepathname$ + char$
    i + 1
  Until (i = FLen(tempexename$)) OR (Asc(char$) = 0)

  tempexename$ = SPACE$(96)
  Seek_ *xtra_fh,$316,#OFFSET_BEGINNING
  Read_ *xtra_fh,&tempexename$,96
  i = 1
  Repeat
    char$ = Mid$(tempexename$,i,1)
    If Asc(char$)<>0 Then exefilename$ + char$
    i + 1
  Until (i = FLen(tempexename$)) OR (Asc(char$) = 0)
;  exepathname$ = dos_Trim{exepathname$}
;  exefilename$ = dos_Trim{exefilename$}
;  !cout{exepathname$+"/"+exefilename$} ;$ , dos_GetFileSize2{exepathname$+"/"+exefilename$}}


  ; -- restore windows
  Gosub RestoreLabelAndNewtypeWin
  project_changelog$ = ""
  Gosub update_versiongadgets

  Close_ *xtra_fh

  ; update Sourcewindow
  lineNum.l = Peek.l(?comLong_CursorPosStore) : clearColumn.b = False : Gosub gotoline

  !asm
  !regs2stack
  !ComData_SetB{comByte_FuncOptimize,#1}                   ; added for compatiblity because it is not stored in the xtra file  tomsmart1
  !ComData_SetW{comWord_CreateDebugFile,#0}                ; to match the old default settings  tomsmart1
  !stack2regs

  !basic
  Gosub delete_tempprefs
  Gosub save_tempprefs
  !asm

  skip_loadingxtrafile:
  !basic
Return


;subroutine to restore Source_Browser(Label) and Definition_Browser(Newtype) window status after load and switch of Sourecode  tomsmart1
.RestoreLabelAndNewtypeWin
  search_label$ = Peek$(?comStr_LabelSearchString) ; set the searchlabel_string
  old_search_label$ = search_label$                ; set also old searchlabel_string to prevent a unessacary reset and jump of the labellist tomsmart1
  MOVE.l comLong_Label1VisableItemStore,comLong_Label1VisableItem          ;  move stored entry to tempbuffer manly for case of load a source  tomsmart1
  LabelList_FirstVisableItemNumber.l = Peek.l(?comLong_Label1VisableItem)  ;  set/restore the first visable entry of the labellist  tomsmart1
  LabelList_PreSelectItemNumber.l    = -1          ; set the preselected labellist entry to -1 because we don't save/store it. ; change from 0 to -1 so not the first entry was preselect  tomsmart1

  If WZ_CheckOpen{"WIN_LABELS"}
    Use Window WZID("WIN_LABELS")
    WZPrint "STRING_LABEL",search_label$
    WZPrint "rem"         ,Peek.w(?comWord_LabelRemark)
    WZPrint "all"         ,Peek.w(?comWord_LabelAll)
    WZListRemove lib_list.List
    WZPrint "LIBRARY_LIST",0,lib_list
  EndIf
  If WZ_CheckOpen{"WIN_NEWTYPE"}
    Use Window WZID("WIN_NEWTYPE")
    Gosub newtype_updatelist
  End If
Return


.analyze_loadedsource:
  log_Print{"analyze_loadedsource"}

  ;!log_HexDump{?comStr_CurrentDir,64}
  ;log_Print{"---"}
  ;!log_HexDump{&ped\currentDir,64}

  ped\currentDir = Peek.s(?comStr_CurrentDir)
  ;!log_HexDump{&ped\currentDir,64}

  ped\currentFile = Peek.s(?comStr_SourceName)
  ped\sourceFileComplete = dos_AddPart{ped\currentDir,ped\currentFile}

  ;sourceWindow\Title = ""
  If ped\currentFile = ""
    sourceWindow\Title = "unnamed"
    If pedconfig\smart_tokenization Then Poke.w ?comWord_DoTokenize,$FFFF
  Else
    sourceWindow\Title = ped\currentFile + " (" + ped\currentDir + ")"

    ; -- check extension
    fext$ = LCase$(dos_GetExt{ped\currentFile})
    log_Print{"checking file extention of loaded file: " + fext$}
    If fext$ = "bb2" OR fext$ = "ab2" OR fext$ = "ab3" OR fext$ = "bb"
      log_Print{"activating tokenization"}
      Poke.w ?comWord_DoTokenize, $FFFF
    EndIf
    If fext$ = "txt" OR fext$ = "guide"
      log_Print{"deactivating tokenization"}
      Poke.w ?comWord_DoTokenize, 0
      If fext$ = "guide" Then ped\amigaguide = True
    EndIf
  EndIf

  SetWindowTitles_ sourceWindow\win, &sourceWindow\Title, -1

  ; -- update tooltype "LAST_SOURCE"
  If pedconfig\load_last_source <> 0
    log_Print{"updateing tooltype LAST_SOURCE..."}
    pedconfig\lastSourceFile = ped\sourceFileComplete
    If pedconfig\lastSourceFile <> ""
      If Instr(pedconfig\lastSourceFile, ped\currentFile) <> 0
        dos_SetToolString{"LAST_SOURCE",pedconfig\lastSourceFile}
      EndIf
    EndIf
  EndIf

  ; -- update modified flags
  CLR.w comWord_KeyBeforeReturn
  ;Gosub update_modifiermark
  Gosub update_debuggertoggle
Return


.delete_tempprefs:
  If Peek.l(?comFunc_ReadXtraFile) <> 0
    tmp_string = "T:PED_" + Hex$(ped\currentSourceEntry) + ".xtra"
    log_Print{"deleting <" + tmp_string + ">"}
    DeleteFile_ &tmp_string
  EndIf
Return

.read_tempprefs:
  If Peek.l(?comFunc_ReadXtraFile) <> 0
    tmp_string = "T:PED_" + Hex$(ped\currentSourceEntry) + ".xtra"
    tpfhandle.l = Open_(&tmp_string, #HUNK_RELOC_16__MODE_OLDFILE)
    If tpfhandle <> 0
      log_Print{"reading <" + tmp_string + ">"}
      GetD0 Peek.l(?comFunc_ReadXtraFile) : MOVE.l d0,-(a7)
      GetD0 tpfhandle : MOVE.l d0,-(a7)
      !asm
      MOVE.l (a7)+,D7
      MOVEA.l (a7)+,A5
      JSR (A5)
      !basic
      Close_ tpfhandle
    EndIf
  EndIf
Return

.save_tempprefs:
  If Peek.l(?comFunc_WriteXtraFile) <> 0
     tmp_string.s = "T:PED_" + Hex$(ped\currentSourceEntry) + ".xtra"
    tpfhandle.l = Open_(&tmp_string, #HUNK_RELOC_8__MODE_NEWFILE)
    If tpfhandle <> 0
      log_Print{"writing xtrafile for " + Peek$(ped\ptrCurrentSourceData + 222) + " <" + tmp_string + ">"}
      GetD0 Peek.l(?comFunc_WriteXtraFile) : MOVE.l d0,-(a7)
      GetD0 tpfhandle : MOVE.l d0,-(a7)
      !asm
      MOVE.l (a7)+,D7
      MOVEA.l (a7)+,A5
      JSR (A5)
      !basic
      Close_ tpfhandle
    EndIf
  EndIf
Return

.menu_saveas:
  log_Print{"menu_saveas called."}
  Gosub storeCurrentSourceData

  tmp_string.s = PED_RequestFile{Peek.s(?comStr_CurrentDir),Peek.s(?comStr_SourceName),"Name of file to open",ped\filePattern}
  ;Poke.s ?comStr_SourceFileComplete,BB2Filename$
  If tmp_string <> ""
    ped\check_existsfile = True
    Gosub menu_save
    ped\check_existsfile = False

    Gosub draw_statusarea
 EndIf
Return

.menu_save:
  log_Print{"menu_save called on sourcefile: " + ped\currentFile}
  If ped\currentFile = ""
    BB2Filename$ = PED_RequestFile{ped\currentDir,ped\currentFile,"Name to save file as",ped\filePattern}
    ;ped\sourceFileComplete will be set in function as wekk
    Poke.s ?comStr_SourceName,ped\currentFile   ; info for compiler
    Poke.s ?comStr_CurrentDir,ped\currentDir
  EndIf
  If ped\currentFile = "" Then Return

  directory.s = dos_FilePart{dos_PathPart{ped\sourceFileComplete}}
  If dos_Exist{ped\sourceFileComplete} AND LCase$(directory) = "templates"
    If NOT ask{!TRANS{"Do you really want to save this file into the templates drawer?"},!TRANS{"Ok|Cancel"},!TRANS{"Question"}}
      Return
    EndIf
  EndIf

  ped\amiblitzmode = 0
  ex.s = dos_GetExt{ped\sourceFileComplete}
  If LCase$(ex) = "bb2" Then ped\amiblitzmode = 1
  If LCase$(ex) = "ab2" Then ped\amiblitzmode = 2
  If LCase$(ex) = "ab3" Then ped\amiblitzmode = 3

  If Len(ped\currentFile) > 27
    dummy.l = ask{!TRANS{"Warning: Filename is longer than 27 characters.\\n" + ped\currentFile + "\\nThis may cause problems with some filesystems."},!TRANS{"Continue"},!TRANS{"Info"}}
  EndIf
  log_Print{"ped\sourceFileComplete : " + ped\sourceFileComplete }

  If ped\check_existsfile
    log_Print{"check if file <" + ped\sourceFileComplete + "> already exists, requester if so  ..."}
    *flock.l = Lock_(&ped\sourceFileComplete,#ACCESS_WRITE)
    If *flock <> 0
      If ask{!TRANS{"File already exists!"},!TRANS{"Overwrite|Cancel"},!TRANS{"Save File As..."}}
        log_Print{"overwrite is ok"}
        UnLock_ *flock
      Else
        log_Print{"operation cancelled"}
        Pop If : Pop If
        Return
      EndIf
    Else
      ; file does not exist, that is ok!
    EndIf
  EndIf

  Poke.l ?comPtr_SourceName, &ped\currentFile
  Poke.l ?comPtr_CurrentDir, &ped\currentDir
  Poke.s ?comStr_SourceName, ped\currentFile
  Poke.s ?comStr_CurrentDir, ped\currentDir

  Gosub storeCurrentSourceData

  log_Print{"updated current source name: " + Peek.s(Peek.l(?comPtr_SourceName))}

  tmp_string.s = ped\sourceFileComplete + ped\extention_bak
  DeleteFile_ &tmp_string
  Rename_ &ped\sourceFileComplete, tmp_string


  WZ_LockAllOpenWindows{}
  Gosub set_pointer_busy_bas
  PED_ShowMessage{!TRANS{"Saving file"} + "..."}

  log_Print{"writing mode: " + Str$(ped\amiblitzmode)}
  Select ped\amiblitzmode
  Case 1 : Gosub save_source_as_tokenized
           ;!asm
           ;write_xtrafile
           ;!basic
  Case 2 : Gosub save_source_as_text
  Case 3 : Gosub save_source_as_ab3
  Default: Gosub save_source_as_text
  End Select

  If pedconfig\remember_saved Then Gosub update_rememberlist

  ped\ptrCurrentSourceData\SourceChanged = 0

  PED_ShowMessage{""}
  WZ_UnlockAllOpenWindows{}
  Gosub set_pointer_normal_bas
Return


.save_source_as_ab3:
  log_Print{"ped\sourceFileComplete = " + ped\sourceFileComplete + ">"}
  GetD0 &ped\sourceFileComplete : MOVE.l D0,-(a7)
  !asm
  MOVE.l (a7)+,D0
  !ComData_JSR{comFunc_SaveSource}

  !basic
  Gosub analyze_loadedsource
  !asm

  !basic
Return

.save_source_as_text:
  log_Print{"write as text: opening file"}
  Gosub set_pointer_busy_bas

  *write_fh.l = Open_(&ped\sourceFileComplete, #HUNK_RELOC_8__MODE_NEWFILE)
  If *write_fh = 0
    WZ_UnlockAllOpenWindows{}
    Gosub set_pointer_normal_bas
    WZ_HideMessage{}
    error{!TRANS{messageErrorWriteFile}}
  Else
    If Peek.l(?comLong_TotalLines) > 0
      *tempLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine

      If Peek.w(?comWord_DoTokenize) <> 0
        log_Print{"write as text: writing detokenized file"}

        ;-- detokenize and write to file
        numlines.l = Peek.l(?comLong_TotalLines)
        totalLength.l = 0
        For n.l = 0 To numlines - 1
          baseptr.l = *tempLine + 9
          sptr.l = baseptr
          While Peek.b(sptr) : sptr + 1 : Wend
          totalLength + sptr - baseptr + 1
          *tempLine = *tempLine\nextLine
        Next
        ;-- alloc buffer
        tmp.l      = AllocVec_(totalLength,#MEMF_CLEAR)
        If tmp
          node.l     = ped\ptrCurrentSourceData\FirstSourceLine
          dptr.l     = tmp
          For n.l=0 To numlines-1
            baseptr.l = node+$9 ;Peek.l (node+$9)
            sptr.l    = baseptr
            Repeat
              char.b = Peek.b(sptr)
              Poke.b dptr,char : sptr +1 : dptr+1
            Until char=0
            node = Peek.l(node)
          Next
          plainLength.l = preproc_DetokenizeFP{*PreProcessor, tmp, totalLength, *write_fh}
          FreeVec_ tmp
        Else
          error{!TRANS{"Not enough memory for temp buffer!"}}
        End If
      Else
        ;-- directly write to file
        log_Print{"write as text: writing text line-by-line to file"}
        Repeat
          strLine.s = ""
          strLength.l = *tempLine\strLength - 1
          If strLength > 0 Then strLine.s = Peeks$(*tempLine + 9, strLength)
          ;log_Print{"writing [" + Str$(FLen(strLine))+ "]: [" + strLine + "]"}
          strLine + Chr$(10)
          Write_ *write_fh, &strLine, FLen(strLine)
          *tempLine = *tempLine\nextLine
        Until *tempLine = 0
      EndIf
    EndIf
    log_Print{"write as text: closing file"}
    Close_ *write_fh : *write_fh = 0
  EndIf
Return

.save_source_as_tokenized:
  log_Print{"write as tokenized: opening file"}
  Gosub set_pointer_busy_bas

  *write_fh.l = Open_(&ped\sourceFileComplete, #HUNK_RELOC_8__MODE_NEWFILE)
  If *write_fh = 0
    WZ_UnlockAllOpenWindows{}
    Gosub set_pointer_normal_bas
    WZ_HideMessage{}
    error{!TRANS{messageErrorWriteFile}}
  Else
    *tempLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
    Repeat
      baseptr.l = *tempLine + 9
      linelength.l = *tempLine\strLength

      If Peek.w(?comWord_DoTokenize) = 0
        strLine$ = Peeks$(baseptr,linelength) + Chr$(10)
      Else
        strLine$ = Peeks$(baseptr,linelength)
      EndIf
      ;log_Print{Str$(linelength) + " >> " + strLine$}
      Write_ *write_fh, &strLine$, FLen(strLine$)
      *tempLine = *tempLine\nextLine
    Until *tempLine = 0
    log_Print{"write as tokenized: closing file"}
    Close_ *write_fh
  EndIf
Return

.write_xtrafile:
  MOVE.l comFunc_WriteXtraFile,D0
  BEQ.w skip_writingxtrafile
    MOVEA.l D0,A5
    MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
    JSR open_xtrafile
    BEQ.w skip_writingxtrafile
      JSR (A5)

      !basic
      If *xtra_fh <> 0
        log_Print{"writing additional stuff..."}
        MOVE.l comLong_DisplayLineOffset,d0 : ADD.l comLong_DisplayLine,d0
        MOVE.l d0,comLong_CursorPosStore
        Poke$ ?comStr_LabelSearchString,search_label$
        MOVE.l LabelList_FirstVisableItemNumber@(a5),comLong_Label1VisableItemStore
        ; moved the write of the 4 extra fill/pad/termination bytes to the Compiler xtra save routine because the Compiler xtra load routine needs it!  tomsmart1
        Write_ *xtra_fh,?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin
        log_Print{"close xtrafile"}
        Close_ *xtra_fh
      EndIf
      !asm
  skip_writingxtrafile:
  !basic
  If pedconfig\use_source_icon Then Gosub write_infofile
  Gosub analyze_loadedsource
  Gosub update_modifiermark
  WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                              
  Gosub set_pointer_normal_bas
  !asm
RTS


.sourceicon_datas:
  Dc.b $E3,$10,$00,$01
  Dc.b $00,$00,$00,$00
  Dc.b $00,$63,$00,$11
  Dc.b $00,$2E,$00,$18
  Dc.b $00,$05,$00,$03
  Dc.b $00,$01,$00,$22
  Dc.b $7B,$20,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $04,$22,$00,$22
  Dc.b $70,$78,$00,$22
  Dc.b $72,$B8,$00,$00
  Dc.b $00,$5C,$00,$00
  Dc.b $00,$0E,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$2E
  Dc.b $00,$17,$00,$02
  Dc.b $00,$01,$8F,$98
  Dc.b $03,$00,$00,$00
  Dc.b $00,$00,$FF,$FF
  Dc.b $FF,$FF,$FF,$FC
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $80,$FF,$FF,$FF
  Dc.b $7C,$00,$81,$80
  Dc.b $00,$00,$06,$00
  Dc.b $81,$80,$00,$00
  Dc.b $06,$00,$81,$9A
  Dc.b $DE,$D5,$86,$00
  Dc.b $81,$97,$5B,$7D
  Dc.b $86,$00,$81,$82
  Dc.b $56,$E9,$86,$00
  Dc.b $81,$81,$AD,$5D
  Dc.b $86,$00,$81,$9F
  Dc.b $FF,$FF,$86,$00
  Dc.b $81,$80,$00,$00
  Dc.b $06,$00,$81,$FF
  Dc.b $FF,$FF,$FE,$00
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$7F
  Dc.b $FF,$FF,$F8,$00
  Dc.b $80,$80,$00,$00
  Dc.b $04,$00,$81,$3A
  Dc.b $AA,$AB,$52,$00
  Dc.b $81,$55,$55,$54
  Dc.b $2A,$00,$82,$00
  Dc.b $00,$00,$01,$00
  Dc.b $83,$FF,$FF,$FF
  Dc.b $FF,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$1F
  Dc.b $FF,$FF,$E0,$04
  Dc.b $00,$1A,$DE,$D4
  Dc.b $00,$04,$00,$17
  Dc.b $5B,$7C,$00,$04
  Dc.b $00,$02,$56,$E8
  Dc.b $00,$04,$00,$01
  Dc.b $AD,$5C,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$1F
  Dc.b $FF,$FF,$E0,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$7F
  Dc.b $FF,$FF,$F8,$04
  Dc.b $00,$C5,$55,$54
  Dc.b $AC,$04,$00,$AA
  Dc.b $AA,$AB,$D4,$04
  Dc.b $01,$FF,$FF,$FF
  Dc.b $FE,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $7F,$FF,$FF,$FF
  Dc.b $FF,$FC,$00,$00
  Dc.b $00,$0E,$42,$6C          ;0,$e4,"Bl"
  Dc.b $69,$74,$7A,$33          ;"itz3"
  Dc.b $3A,$41,$6D,$69          ;":Ami"
  Dc.b $42,$6C,$69,$74          ;"Blit"
  Dc.b $7A,$33,$00,$00          ;"z3",0,0
  Dc.b $00,$00,$04
Even
.sourceicondatas_end


.menu_about:
  txt0.s = !versions + "#" + Peek$(Peek.l(?comPtr_CompilerVersion))
  txt1.s = ArexxPortName$
  txt2.s = ped\defaultPubscreenName
  txt3.s = "n/a"
  txt4.s = "n/a"
  txt5.s = "n/a"
  txt6.s = "n/a"
  If pedconfig\useBaseLib Then txt3 = ped\baselibFileDate + " - " + Str$(ped\baselibFileSize) + " bytes"
  If pedconfig\useUtilLib Then txt4 = ped\utillibFileDate + " - " + Str$(ped\utillibFileSize) + " bytes"
  If pedconfig\useOsLib   Then txt5 = ped\oslibFileDate + " - " + Str$(ped\oslibFileSize) + " bytes"
  If pedconfig\useCsLib   Then txt6 = ped\cslibFileDate + " - " + Str$(ped\cslibFileSize) + " bytes"
  window_welcome{txt0,txt1, txt2, txt3, txt4, txt5, txt6}
Return


str_searchstring:   Ds.b #MAX_STRINGSIZE
str_replacestring:  Ds.b #MAX_STRINGSIZE
Even

.menu_find:
  ts.s = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
  actualword$ = PED_GetWordAtPos{ts, Peek.w(?comWord_Column),False}
  If actualword$ <> ""
    find_findStrOld.s = actualword$
  EndIf

  If WZ_CheckOpen{"WIN_SEARCH"} = False
    WZWindow WZID("WIN_SEARCH"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_SEARCH")
    AddedMenu2WZWin{"WIN_SEARCH"}
    Delay_ 2
    WZPrint "FIND_FINDSTRING"   ,&find_findStrOld
    WZPrint "FIND_REPLACESTRING",&find_replaceStrOld
    ;WZPrint "FIND_FINDMODE",-1
    WZ_ActivateGadget{"FIND_FINDSTRING"}      ; replaced to use the statement  tomsmart1 2012 03 09                                                                                                                                                      
  Else
    Use Window WZID("WIN_SEARCH")
    WindowToFront_ WZWindowAddr
    WZ_ActivateGadget{"FIND_FINDSTRING"}
  EndIf
Return


.menu_findnext:
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *currentLine = *currentLine\nextLine
  direction.b = 1

nextOccurence:
  If *currentLine <> 0
    search.s = Peek.s(?str_searchstring)

    If direction = 1
      log_Print{"find next for [" + search + "]"}
    Else
      log_Print{"find previous for [" + search + "]"}
    EndIf

    Gosub set_pointer_busy_bas

    curLine.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset) + direction
    Repeat
      tmpX.w = PED_SearchString{search,ped\caseSensitive,1,*currentLine}
      If tmpX = 0
        If direction = 1
          *currentLine = *currentLine\nextLine
        Else
          *currentLine = *currentLine\previousLine
       EndIf
        curLine + direction
      EndIf
    Until (tmpX > 0) OR (curLine > ped\ptrCurrentSourceData\TotalLines) OR (curLine < 0)

    If tmpX > 0
      log_Print{"found [" + search + "] in Line " + Str$(curLine) + ", Column " + Str$(tmpX)}
      lineNum.l = curLine : Gosub gotoline
      newColumn.w = tmpX - 1 : Gosub moveCursorToX
      Gosub update_horizscroller
    EndIf

    Gosub set_pointer_normal_bas
  EndIf
Return


.menu_findprevious:
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *currentLine = *currentLine\previousLine
  direction.b = -1
Goto nextOccurence

.menu_replace:
  If Peek.s(?str_searchstring)<>""
    log_Print{"menu replace called: " + Peek.s(?str_searchstring) + " >> " + Peek.s(?str_replacestring)}
    *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    If PED_ReplaceString{Peek.s(?str_searchstring),Peek.s(?str_replacestring),*currentLine}
      log_Print{"replace done."}
      Gosub menu_findnext
      !asm
      JSR _redraw
      !basic
    EndIf
  Else
    log_Print{"no searchstring set."}
  EndIf
Return

.menu_replaceall:
  If Peek.s(?str_searchstring)<>""
    log_Print{"menu replaceall called: " + Peek.s(?str_searchstring) + " >> " + Peek.s(?str_replacestring)}
    findmode.b = WZInput("FIND_FINDMODE")
    If findmode
      *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    Else
      *currentLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
    EndIf

    Repeat
      If PED_ReplaceString{Peek.s(?str_searchstring),Peek.s(?str_replacestring),*currentLine}
        *currentLine = ped\ptrCurrentSourceData\CurrentSourceLine
      EndIf
      *currentLine = *currentLine\nextLine
    Until *currentLine = 0
  Else
    log_Print{"no searchstring set."}
  EndIf
Return


.menu_quitall:
  log_Print{"close all sources."}

  While ped\firstSourceEntry
    If ped\ptrCurrentSourceData\SourceChanged 
      dummy.l = ask{!TRANS{"You have unsaved changes!"},!TRANS{"Continue|Cancel"},!TRANS{"Quit"}}
      If dummy = 0 Then Pop If: Return
    EndIf

    Gosub free_actualsource
    Gosub close_actualsource
    Gosub draw_tabs
  Wend

  exit_eventloop = True : exit_mainloop = True
Return


.menu_quit:
  If pedMessage\_Code = 1
    log_Print{"new Iconify message was send by intuition"}
    Gosub menu_iconify
    Return
  EndIf

  log_Print{"close current source."}
  If ped\ptrCurrentSourceData\SourceChanged 
    dummy.l = ask{!TRANS{"You have unsaved changes!"},!TRANS{"Continue|Cancel"},!TRANS{"Quit"}}
    If dummy = 0 Then Pop If : Return
  EndIf

  Gosub free_actualsource
  Gosub close_actualsource

  If ped\firstSourceEntry = 0
    dummy.l = 1
    If pedconfig\ask_before_quit
      dummy.l = ask{!TRANS{"Closing last source, do you really want to quit?"},!TRANS{"Ok|Cancel"},!TRANS{"Question"}}
    EndIf
    If dummy = 0
      Gosub menu_opennew
    Else
      log_Print{"telling mainloop to stop, no open file left"}
      exit_eventloop = True : exit_mainloop = True
    EndIf
  EndIf

  Gosub draw_statusarea
Return


.menu_blockcomment:
  log_Print{"menu blockcomment called."}
  If Peek.l(?comLong_BlockEndY) = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal_bas
    Pop If: Return
  EndIf

  !asm
  JSR update_currsourceline
  JSR move_to_blockstarty

  MOVEA.l A5,A4

  JL_0_21F0:
    MOVEA.l comPtr_Temp_TokenString2,A1
    MOVE.b #";",(A1)+
    LEA $9(A4),A0
    MOVE.w comWord_DoTokenize,D0
    BNE.w JL_0_220E
      JL_0_2206:
        MOVE.b (A0)+,(A1)+
      BNE.b JL_0_2206
      BRA.w JL_0_2212
    JL_0_220E:
      JSR detokenize_line
    JL_0_2212:

    CMPA.l comPtr_Temp_TokenString3,A1
    BCC.w JL_0_2220
      MOVE.b #$20,(A1)+
      BRA.b JL_0_2212
    JL_0_2220:

    MOVE.l A4,comPtr_CurrentSourceLine
    JSR tokenizeAndInsertNewLine
    MOVEA.l (A4),A4
    ADDQ.l #1,D6
  CMP.l comLong_BlockEndY,D6
  BLS.b JL_0_21F0

  JSR update_currsourceline
  JSR _redraw
  !basic
Return

.menu_blockuncomment:
  log_Print{"menu blockuncomment called."}
  If Peek.l(?comLong_BlockEndY) = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal_bas
    Pop If: Return
  EndIf

  !asm
  JSR update_currsourceline
  JSR move_to_blockstarty

  MOVEA.l A5,A4

  JL_0_224E:
  MOVEA.l comPtr_Temp_TokenString2,A1
  LEA $9(A4),A0
  MOVE.w comWord_DoTokenize,D0
  BNE.w JL_0_2268
    JL_0_2260:
     MOVE.b (A0)+,(A1)+
    BNE.b JL_0_2260
    BRA.w JL_0_226C
  JL_0_2268:
    JSR detokenize_line
  JL_0_226C:

  MOVEA.l comPtr_Temp_TokenString2,A1
  MOVEA.l A1,A0

 JL_0_2272:
  MOVE.b (A0)+,D1
   BEQ.w JL_0_2286
  CMP.b #";",D1
   BEQ.w JL_0_2288
  CMP.b #$20,D1
   BEQ.b JL_0_2272

 JL_0_2286:
  MOVEA.l A1,A0

 JL_0_2288:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_2288
  SUBQ.w #1,A1

 JL_0_228E:
  CMPA.l comPtr_Temp_TokenString3,A1
   BCC.w JL_0_229C
  MOVE.b #$20,(A1)+
  BRA.b JL_0_228E

 JL_0_229C:
  MOVE.l A4,comPtr_CurrentSourceLine
  JSR tokenizeAndInsertNewLine
  MOVEA.l (A4),A4
  ADDQ.l #1,D6
  CMP.l comLong_BlockEndY,D6
  BLS.b JL_0_224E
  JSR update_currsourceline
  JSR _redraw
  !basic
Return

.menu_blocktab:
  log_Print{"menu blocktab called."}
  If Peek.l(?comLong_BlockEndY) = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal_bas
    Pop If: Return
  EndIf

  !asm
  JSR update_currsourceline
  JSR move_to_blockstarty

  MOVEA.l A5,A4

  JL_0_22CA:
    MOVEA.l comPtr_Temp_TokenString2,A1

    MOVE.w tab_size,D0               ; -- copy TAB-Spaces to A1
    BEQ.w JL_0_22E2
      SUBQ.w #1,D0
      JL_0_22DA:
        MOVE.b #$20,(A1)+
      DBF D0,JL_0_22DA
    JL_0_22E2:

    LEA $9(A4),A0                    ; -- detokenize line in A0 and copy it in A1 behind TAB-Spaces
    MOVE.w comWord_DoTokenize,D0
    BNE.w JL_0_22F8
      JL_0_22F0:
        MOVE.b (A0)+,(A1)+
      BNE.b JL_0_22F0
      BRA.w JL_0_22FC
    JL_0_22F8:
      JSR detokenize_line
    JL_0_22FC:

    CMPA.l comPtr_Temp_TokenString3,A1
    BCC.w JL_0_230A
      MOVE.b #$20,(A1)+
      BRA.b JL_0_22FC
    JL_0_230A:

    MOVE.l A4,comPtr_CurrentSourceLine
    JSR tokenizeAndInsertNewLine
    MOVEA.l (A4),A4
    ADDQ.l #1,D6
  CMP.l comLong_BlockEndY,D6
  BLS.b JL_0_22CA                    ; -- next line until comLong_BlockEndY is reached

  JSR update_currsourceline
  JSR _redraw
  !basic
Return

.menu_blockuntab:
  log_Print{"menu blockuntab called."}
  If Peek.l(?comLong_BlockEndY) = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal_bas
    Pop If: Return
  EndIf

  !asm
  JSR update_currsourceline
  JSR move_to_blockstarty
  MOVEA.l A5,A4

  JL_0_2338:
    MOVEA.l comPtr_Temp_TokenString2,A1

    LEA $9(A4),A0
    MOVE.w comWord_DoTokenize,D0
    BNE.w JL_0_2352
      JL_0_234A:
        MOVE.b (A0)+,(A1)+
      BNE.b JL_0_234A
      BRA.w JL_0_2356
    JL_0_2352:
      JSR detokenize_line
    JL_0_2356:

    MOVEA.l comPtr_Temp_TokenString2,A1
    MOVEA.l A1,A0
    MOVE.w tab_size,D0
    BEQ.w JL_0_2378
      SUBQ.w #1,D0
      JL_0_2368:
        TST.b (A0)+
        BEQ.w JL_0_2378
      DBF D0,JL_0_2368

      JL_0_2372:
        MOVE.b (A0)+,(A1)+
      BNE.b JL_0_2372
      SUBQ.w #1,A1
    JL_0_2378:
      CMPA.l comPtr_Temp_TokenString3,A1
      BCC.w JL_0_2386
        MOVE.b #$20,(A1)+
        BRA.b JL_0_2378
    JL_0_2386:

    MOVE.l A4,comPtr_CurrentSourceLine
    JSR tokenizeAndInsertNewLine
    MOVEA.l (A4),A4
    ADDQ.l #1,D6
  CMP.l comLong_BlockEndY,D6
  BLS.b JL_0_2338

  JSR update_currsourceline
  JSR _redraw
  !basic
Return

.close_actualsource:
  Gosub delete_tempprefs

  *sourceEntry.sourceEntry = ped\currentSourceEntry
  *nextEntry.sourceEntry = *sourceEntry\nextEntry
  *prevEntry.sourceEntry = *sourceEntry\previousEntry

  If *prevEntry <> 0
    If *nextEntry <> 0
      ped\currentSourceEntry = *nextEntry
      *prevEntry\nextEntry = *nextEntry
      *nextEntry\previousEntry = *prevEntry
    Else
      ped\currentSourceEntry = *prevEntry
      ped\firstLoadedEntry = *prevEntry
      *prevEntry\nextEntry = 0
    EndIf
  Else
    If *nextEntry <> 0
      ped\firstSourceEntry = *nextEntry
      ped\currentSourceEntry = *nextEntry
      *nextEntry\previousEntry = 0
    Else
      ped\firstSourceEntry = 0
      ped\firstLoadedEntry = 0
      ped\currentSourceEntry = 0
    EndIf
  EndIf
  PED_FreeMem{*sourceEntry}

  If ped\currentSourceEntry
    Gosub getCurrentSourceData
    Gosub read_tempprefs
    !asm
    JSR JL_0_2Dca8
    !basic
  EndIf
Return

.dummy_compilercall:
  ; this call to the compiler is useless, as the adress com_calldummy is always zero
  MOVE.l D0,-(A7)
  MOVE.l comFunc_CallDummy,D0
  BEQ.w exit_dummycall
    MOVEM.l D1-D7/A0-A6,-(A7)
    MOVEA.l D0,A0
    L_0_24E4: JSR (A0)
    MOVEM.l (A7)+,D1-D7/A0-A6
    !basic
    dummy.l = ask{!TRANS{"The dummy call has been performed"},!TRANS{"Ok"}}
    !asm
  exit_dummycall:

  MOVE.l (A7)+,D0
RTS


.movelinedown:
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *prevLine.sourceLine = *currentLine\previousLine
  *nextLine.sourceLine = *currentLine\nextLine
  tmpCurrentLine.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
  tmpTotalLines.l = Peek.l(?comLong_TotalLines)
  log_Print{"current " + Str$(tmpCurrentLine) + "   total " + Str$(tmpTotalLines)}
;  log_Print{Hex$(*prevLine)}
;  log_Print{Hex$(*currentLine)}
;  log_Print{Hex$(*nextLine)}
  If (tmpCurrentLine < tmpTotalLines) AND (*nextLine <> 0) ; if no nextline, we cannot move down
    If cutLine{*currentLine}
      appendLine{*nextLine, *currentLine}
      ;Poke.l ?comPtr_CurrentSourceLine,*nextLine

      ped\ptrCurrentSourceData\SourceChanged = $FFFF
      ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine

      If *currentLine\nextLine = *currentLine
        log_Print{"=========================== PONG"}
        log_Print{Hex$(*prevLine) + Peeks$(*prevLine+9,32)}
        log_Print{Hex$(*currentLine) + Peeks$(*currentLine+9,32)}
        log_Print{Hex$(*nextLine) + Peeks$(*nextLine+9,32)}
      EndIf

      ; check if text is scrolled
      tmpDisplayLine.l = Peek.l(?comLong_DisplayLine)
      tmpDisplayLineOffset.l = Peek.l(?comLong_DisplayLineOffset)
      tmpViewableLines.l = Peek.l(?viewablelines)
      If tmpDisplayLineOffset + tmpViewableLines > tmpTotalLines
        log_Print{"increase displayline, current: " + Str$(tmpDisplayLine)}
        !asm
        JSR increase_DisplayLine
        JSR _redraw
        !basic
      Else
        If tmpViewableLines > (tmpDisplayLine + 1 + Peek.w(?comWord_BoundLinesY))
          !asm
          JSR increase_DisplayLine
          JSR _redraw
          !basic
        Else
          ADDQ.l #1,comLong_DisplayLineOffset
          PED_ScrollVertical{#SCROLL_UP}
          Gosub draw_new_sourceline_bottom
          !asm
          JSR _redraw
          !basic
        EndIf
      EndIf
    Else
      log_Print{"*** cut not successfull ***"}
    EndIf
  Else
    log_Print{"no alt-cursor down available."}
  EndIf
Return


.movecursorlinedown:
  Gosub cursor_off
  Gosub handle_blockmark

  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *nextLine.sourceLine = *currentLine\nextLine

  If Peeks$(*currentLine+9,4)=";@@1"
    tmpDLO.l = Peek.l(?comLong_DisplayLineOffset)
    *_next.sourceLine = *nextLine
    While *_next
      ADDQ.l #1,comLong_DisplayLineOffset
      If Peeks$(*_next + 9,4) <> ";@@1"
        If Peeks$(*_next + 9,4) = ";@@0"
          ped\ptrCurrentSourceData\CurrentSourceLine = *_next
          !asm
          JSR _redraw
          !basic
          Return
        EndIf
      EndIf
      *_next = *_next\nextLine
    Wend
    Poke.l ?comLong_DisplayLineOffset,tmpDLO
  EndIf

  If *nextLine = 0
    Gosub cursor_on
    Gosub set_pointer_normal_bas
  Else
    ped\ptrCurrentSourceData\CurrentSourceLine = *nextLine
    Gosub update_sourcewindow_bottom
  EndIf

Return

.setpointer_to_normal:
  JSR set_pointer_normal
RTS

.update_linenumbers
  If pedconfig\linenumbers
    storeCurrentLineNumber.l = Peek.l(?comLong_DisplayLine)
    maxLineNumber.l = Min(Peek.l(?comLong_TotalLines),Peek.l(?viewablelines))-1
    For y.w = storeCurrentLineNumber To maxLineNumber
      Poke.l ?comLong_DisplayLine, y
      Gosub print_linenumber
    Next y
    Poke.l ?comLong_DisplayLine, storeCurrentLineNumber
  EndIf
Return

.update_sourcewindow_bottom:
  If Peek.l(?comLong_TotalLines) >= Peek.l(?comLong_DisplayLineOffset) + Peek.l(?viewablelines)
    If Peek.l(?comLong_DisplayLine) + 1 + Peek.w(?comWord_BoundLinesY) => Peek.l(?viewablelines)
      ADDQ.l #1,comLong_DisplayLineOffset
      PED_ScrollVertical{#SCROLL_UP}
      Gosub draw_new_sourceline_bottom
      Return
    EndIf
  EndIf

  JSR increase_DisplayLine

  ;-- update linenumbers from here
  Gosub update_linenumbers

  Gosub cursor_on
Return



.selectblockdown:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BNE.w skip_setstart
    MOVE.w comWord_ColumnsOffset,D0 : ADD.w comWord_Column,D0
    JSR set_blockstart
  skip_setstart:
  !basic
  Gosub movecursorlinedown
  !asm
  ;MOVEA.l textbufferaddr,A2 : ADDA.w comWord_TextBufferOffset,A2
  MOVE.w comWord_ColumnsOffset,D0 : ADD.w comWord_Column,D0
JMP set_blockend

.selectblockup:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BNE.w skip_setstart2
    MOVE.w comWord_ColumnsOffset,D0 : ADD.w comWord_Column,D0
    JSR set_blockstart
  skip_setstart2:
  !basic
  Gosub movecursorlineup
  !asm
  ;MOVEA.l textbufferaddr,A2 : ADDA.w comWord_TextBufferOffset,A2
  ;BSR movecursorlineup
  MOVE.w comWord_ColumnsOffset,D0 : ADD.w comWord_Column,D0
JMP set_blockend

.selectblockright:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BNE.w skip_setstart3
    MOVE.w comWord_ColumnsOffset,D0 : ADD.w comWord_Column,D0
    JSR set_blockstart
  skip_setstart3:
  !basic
  Gosub moveCursorRight
  !asm
  MOVE.w comWord_ColumnsOffset,D0 : ADD.w comWord_Column,D0
JMP set_blockend

.selectblockleft:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BNE.w skip_setstart4
    MOVE.w comWord_ColumnsOffset,D0 : ADD.w comWord_Column,D0
    JSR set_blockstart
  skip_setstart4:
  !basic
  Gosub moveCursorLeft
  !asm
  MOVE.w comWord_ColumnsOffset,D0 : ADD.w comWord_Column,D0
JMP set_blockend


.movelineup:
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *prevLine.sourceLine = *currentLine\previousLine
  *nextLine.sourceLine = *currentLine\nextLine
  tmpCurrentLine.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
;  log_Print{"current " + Str$(tmpCurrentLine) + "dl " + Str$(Peek.l(?comLong_DisplayLine)) + "prevline " + Hex$(*prevLine)}
;  log_Print{Hex$(*prevLine) + Peeks$(*prevLine+9,32)}
;  log_Print{Hex$(*currentLine) + Peeks$(*currentLine+9,32)}
;  log_Print{Hex$(*nextLine) + Peeks$(*nextLine+9,32)}

  If (tmpCurrentLine > 0) AND (*prevLine <> 0) ; if no previousline, we cannot move up
    If cutLine{*currentLine}
      ;log_Print{"cutted out  " + Hex$(*currentLine) + " " + Peeks$(*currentLine+9,32) }
      ;log_Print{"append after: " + Hex$(*prevLine\previousLine) + " " + Peeks$(*prevLine\previousLine + 9,32)}

      appendLine{*prevLine\previousLine, *currentLine}

      ped\ptrCurrentSourceData\SourceChanged = $FFFF
      ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine

      If *currentLine\nextLine = *currentLine
        log_Print{"=========================== PING"}
        log_Print{Hex$(*prevLine) + Peeks$(*prevLine+9,32)}
        log_Print{Hex$(*currentLine) + Peeks$(*currentLine+9,32)}
        log_Print{Hex$(*nextLine) + Peeks$(*nextLine+9,32)}
      EndIf

      ; check if text is scrolled
      If Peek.l(?comLong_DisplayLineOffset) = 0 OR (Peek.l(?comLong_DisplayLine) > Peek.w(?comWord_BoundLinesY))
        log_Print{"decrease displayline, current: " + Str$(Peek.l(?comLong_DisplayLine))}
        !asm
        ;!stack2regs
        JSR decrease_DisplayLine
        JSR _redraw
        !basic
      Else
        Poke.l ?comLong_DisplayLineOffset, Peek.l(?comLong_DisplayLineOffset)-1
        log_Print{"fullscrollup"}
        PED_ScrollVertical{#SCROLL_DOWN}
        Gosub draw_new_sourceline_top
        !asm
        JSR _redraw
        !basic
      EndIf
    Else
      log_Print{"*** cut not successfull ***"}
    EndIf
  Else
    log_Print{"no alt-cursor up available."}
  EndIf
Return

Function.l PED_CheckFoldingReverse{*tmpLine.sourceLine}
  foldnumber.l = 0
  linePtr.l = 0

  log_Print{"check line:  [" + Peeks$(*tmpLine + 9,8) + "]"}
  marker.s = Peeks$(*tmpLine + 11,2)
  If marker = "@0"
    foldnumber = 0
    *tmpPrev.sourceLine = *tmpLine\previousLine
    While *tmpPrev
      marker2.s = Peeks$(*tmpPrev + 9,4)
      If Left$(marker2,2) = ";@"
        log_Print{" found a marker upwarts: " + marker2}
        If Right$(marker2,2) = "@1"
          foldnumber = 1
          linePtr = *tmpPrev
          Pop If: Pop If : Pop While
          Goto exit_while
        EndIf
        If Right$(marker2,2) = "@0"
          Goto exit_while
        EndIf
      EndIf
      *tmpPrev = *tmpPrev\previousLine
    Wend
    exit_while:
  EndIf

  If marker = "@1" Then foldnumber = 0

  Function Return linePtr
End Function


.movecursorlineup:
  Gosub cursor_off
  Gosub handle_blockmark

  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *prevLine.sourceLine = *currentLine\previousLine

  If Peeks$(*currentLine + 9,4) = ";@@0"
    log_Print{"jump marker found, searching corresponding previous marker."}
    *_prev.sourceLine = *currentLine
    linePtr.l = PED_CheckFoldingReverse{*_prev}
    If linePtr <> 0
      log_Print{"previous marker for [" + Peeks$(*_prev + 9,4) + "] found, jumping to that line."}
      Repeat
        *_prev = *_prev\previousLine
        SUBQ.l #1,comLong_DisplayLineOffset
      Until *_prev = linePtr
     ped\ptrCurrentSourceData\CurrentSourceLine = *_prev
      !asm
      JSR _redraw
      !basic
      Return
    EndIf

  EndIf

  If *prevLine = 0
    Gosub cursor_on
    Gosub set_pointer_normal_bas
  Else
    ped\ptrCurrentSourceData\CurrentSourceLine = *prevLine

    If Peek.l(?comLong_DisplayLineOffset) > 0
      If Peek.l(?comLong_DisplayLine) <= Peek.w(?comWord_BoundLinesY)
        SUBQ.l #1,comLong_DisplayLineOffset         ; otherwise scroll whole text one line up
        PED_ScrollVertical{#SCROLL_DOWN}
        Gosub draw_new_sourceline_top
        Return
      EndIf
    EndIf
    !asm
    JSR decrease_DisplayLine
    !basic
    Gosub cursor_on
  EndIf
Return


.menu_markindent:
  log_Print{"menu markindent called."}
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  If Peek.b(*currentLine + 9) <> 0
    actualLine.l = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine)

    ; -- get current indent position
    currentXPos.w = 0
    While Peek.b(*currentLine + 9 + currentXPos) = $20
      currentXPos + 1
    Wend

    ; -- search for block start
    indentBegin.l = actualLine
    While indentBegin > 0
      upperXPos.w = 0
      *currentLine = *currentLine\previousLine
      While Peek.b(*currentLine + 9 + upperXPos) = $20
        upperXPos + 1
      Wend
      If Peek.b(*currentLine + 9 + upperXPos) <> 0
        If upperXPos < currentXPos Then Goto exit_upperindent
      EndIf
      indentBegin - 1
    Wend
    exit_upperindent:

    ; -- search for end of block
    *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    indentEnd.l = actualLine
    *currentLine = *currentLine\nextLine
    While *currentLine <> 0
      lowerXPos.w = 0
      While Peek.b(*currentLine + 9 + lowerXPos) = $20
        lowerXPos + 1
      Wend
      If Peek.b(*currentLine + 9 + lowerXPos) <> 0
        If lowerXPos < currentXPos Then Goto exit_lowerindent
      EndIf
      indentEnd + 1

      *currentLine = *currentLine\nextLine
    Wend
    exit_lowerindent:

    ; draw the blockmark
    Poke.l ?comLong_BlockStartY, indentBegin
    Poke.w ?comWord_BlockStartX, 0
    Poke.l ?comLong_BlockEndY, indentEnd
    Poke.w ?comWord_BlockEndX, #MAX_Columns - 1
    !asm
    JSR _redraw
    !basic
  EndIf
  Gosub set_pointer_normal_bas
Return


.handle_blockmark:
;  log_Print{"handle blockmark"}
  sourceWindow\deleteMode = 0

  If ped\blockmarkRemovalMode <> 0
    If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
      If ped\blockmarkRemovalMode = 2
        Gosub menu_cut
        If pedconfig\no_display_beep = False Then DisplayBeep_ sourceWindow\pedScreen
      Else
        ; for blockmarkRemovalMode = 1 only remove blockmark
        Poke.l ?comLong_BlockEndY,$ffffFFFF
        sourceWindow\deleteMode = True
        !asm
        JSR _redraw
        !basic
      EndIf
    EndIf
    ped\blockmarkRemovalMode = 0
  EndIf
Return


.menu_insertline:
  ; insertStr may come from menu_undeleteline...
  If insertStr.s = "" Then insertStr = "leere Zeile"
  *newLine.sourceLine = PED_CreateNewSourceLine{insertStr.s}
  If *newLine <> 0
    ped\ptrCurrentSourceData\SourceChanged = $FFFF
    !asm
    MOVE.l comLong_DisplayLineOffset,D0 : ADD.l comLong_DisplayLine,D0
    JSR block_updatePosY                        ; increase blockendY if paste within a block
    !basic
    If PED_InsertSourceLine{*newLine}
      ;MOVE.l comLong_DisplayLine,D7 : JSR source_partscroll_up
      PED_ScrollVertical{#SCROLL_DOWN, Peek.l(?comLong_DisplayLine)}
      !asm
      MOVE.l comPtr_CurrentSourceLine,A2 : JSR print_sourceline
      ;JSR _redraw
      !basic
      Gosub update_linenumbers
    Else
      error{"Couldn't insert sourceline!"}
    EndIf
    insertStr = ""
  Else
    Pop If
    Goto memAlert_CloseSource
  EndIf
Return


.menu_undeleteline:
  log_Print{"menu undeleteline called"}
  insertStr.s = Peek.s(Peek.l(?lineundeletestore))
  If FLen(insertStr) > 0
    log_Print{"undeleting line: " + insertStr}
    Gosub menu_insertline
  Else
    log_Print{"no data to undelete."}
  EndIf
Return


.menu_deleteline:
  log_Print{"menu deleteline called"}

  ped\ptrCurrentSourceData\SourceChanged = $FFFF

  ; update the blockmark if set
  If Peek.l(?comLong_BlockEndY)<> $ffffFFFF
    If Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) > Peek.l(?comLong_BlockStartY)
      If Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) < Peek.l(?comLong_BlockEndY)
        SUBQ.l #1,comLong_BlockEndY
        If Peek.l(?comLong_BlockEndY) < Peek.l(?comLong_BlockStartY)
          CLR.l comLong_BlockEndY
        EndIf
      EndIf
    Else
      SUBQ.l #1,comLong_BlockStartY
      SUBQ.l #1,comLong_BlockEndY
    EndIf
  EndIf


  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *nextLine.sourceLine = *currentLine\nextLine
  *prevLine.sourceLine = *currentLine\previousLine
  If *nextLine <> 0
    If cutLine{*currentLine}
      ped\ptrCurrentSourceData\CurrentSourceLine = *nextLine
      PED_StoreSourceLine{*currentLine}
      PED_DeleteSourceLine{*currentLine}
      ped\ptrCurrentSourceData\TotalLines - 1
      PED_ScrollVertical{#SCROLL_UP, Peek.l(?comLong_DisplayLine)}
      Gosub draw_new_sourceline_bottom
    EndIf
  Else
    If *prevLine <> 0
      If cutLine{*currentLine}
        ped\ptrCurrentSourceData\CurrentSourceLine = *prevLine
        ped\ptrCurrentSourceData\LastSourceLine = *prevLine
        PED_StoreSourceLine{*currentLine}
        PED_DeleteSourceLine{*currentLine}
        ped\ptrCurrentSourceData\TotalLines - 1
        If Peek.l(?comLong_DisplayLineOffset)
          SUBQ.l #1,comLong_DisplayLineOffset
          PED_ScrollVertical{#SCROLL_UP,Peek.l(?comLong_DisplayLine)}
          Gosub draw_new_sourceline_top
        Else
          ;MOVE.l comLong_DisplayLine,d7 : JSR source_partscroll_down
          PED_ScrollVertical{#SCROLL_UP, Peek.l(?comLong_DisplayLine)}
          !asm
          JSR decrease_DisplayLine
          !basic
        EndIf
      EndIf
    Else
      PED_StoreSourceLine{*currentLine}
      PED_DeleteSourceLine{*currentLine}
      *newLine.sourceLine = PED_CreateNewSourceLine{""}
      ped\ptrCurrentSourceData\FirstSourceLine = *newLine
      ped\ptrCurrentSourceData\LastSourceLine = *newLine
      ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
      Gosub clear_sourcewindow
    EndIf
  EndIf
  log_Print{"menu deleteline finished"}
Return

.menu_joinline:
  log_Print{"menu joinlines called."}
  *currLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  If *currLine\nextLine = 0
    log_Print{"no next line to join."}

    Gosub set_pointer_normal_bas
    Pop If: Return
  else
    *nextLine.sourceLine = *currLine\nextLine
  EndIf

  ped\ptrCurrentSourceData\SourceChanged = $FFFF
  !asm
  MOVE.l comPtr_CurrentSourceLine,A4
  MOVE.l (A4),A5
  MOVEA.l textbufferaddr,A2 : ADDA.w comWord_TextBufferOffset,A2

  MOVE.w #MAX_Columns,D0
  JL_0_27E6:                                    ; get end of current line
  SUBQ.w #1,D0
  BMI.w JL_0_27F4
    CMPI.b #$20,$0(A2,D0.W)
    BEQ.b JL_0_27E6
  JL_0_27F4:
  ADDQ.w #1,D0

  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w JL_0_2880
    MOVE.l comLong_DisplayLineOffset,D1 : ADD.l comLong_DisplayLine,D1
    CMP.l comLong_BlockEndY,D1
    BCC.w JL_0_2880
      ADDQ.l #1,D1
      CMP.l comLong_BlockStartY,D1
      BEQ.w JL_0_282C
        BCS.w JL_0_2874
          CMP.l comLong_BlockEndY,D1
          BEQ.w JL_0_283E
            BRA.w JL_0_287A
      JL_0_282C:
      CMP.l comLong_BlockEndY,D1
      BEQ.w JL_0_2854
        ADD.w D0,comWord_BlockStartX
        BRA.w JL_0_2870

      JL_0_283E:
      CMP.l comLong_BlockStartY,D1
      BEQ.w JL_0_2854
        ADD.w D0,comWord_BlockEndX
        JSR JL_0_7A14
        BRA.w JL_0_287A
      JL_0_2854:
      MOVE.w comWord_BlockEndX,D3
      SUB.w comWord_BlockStartX,D3
      MOVE.w comWord_BlockStartX,D2
      ADD.w D0,D2
      MOVE.w D2,comWord_BlockStartX
      ADD.w D3,D2
      MOVE.w D2,comWord_BlockEndX

      JL_0_2870:
      JSR JL_0_7A14

      JL_0_2874:
      SUBQ.l #1,comLong_BlockStartY

      JL_0_287A:
      SUBQ.l #1,comLong_BlockEndY
  JL_0_2880:                                    ; **********************************


                                                ; d0 contains endposition of line to join with
  MOVEA.l comPtr_Temp_TokenString2,A0           ; copy line to TokenString2
  LEA $0(A0,D0.W),A1
  JL_0_2888:
    SUBQ.w #1,D0
    BMI.w JL_0_2896
    MOVE.b $0(A2,D0.W),$0(A0,D0.W)
  BRA.b JL_0_2888
  JL_0_2896:
  LEA $9(A5),A0
 'l2
    CMP.b #32,(a0)                              ; skip leading spaces
    BNE 'l1
      ADDQ.l #1,a0
  BRA 'l2
 'l1

  MOVE.w comWord_DoTokenize,D0
  BNE.w JL_0_28AE
    JL_0_28A4:
      MOVE.b (A0)+,(A1)+
    BNE.b JL_0_28A4
    SUBQ.w #1,A1
    BRA.w JL_0_28B2
  JL_0_28AE:
    JSR detokenize_line

  JL_0_28B2:
    CMPA.l comPtr_Temp_TokenString3,A1
    BCC.w JL_0_28C0
      MOVE.b #$20,(A1)+
  BRA.b JL_0_28B2
  JL_0_28C0:

  MOVEA.l comPtr_Temp_TokenString2,A2
  JSR parse_line
  JSR replaceCurrentLine

  ;!basic
  ;*currLine = Peek.l(?comPtr_CurrentSourceLine)
  ;*nextLine = *currLine\nextLine
  ;If *nextLine\nextLine
  ;  *nextLine = *nextLine\nextLine
  ;  *currLine\nextLine = *nextLine
  ;  *nextLine\previousLine = *currentLine
  ;Else

  ;EndIf
  MOVEA.l (A4),A1                         ; remove deleted line from linked list
  MOVE.l (A1),D0
  BEQ.w JL_0_28E0
    MOVEA.l D0,A0
    MOVE.l A0,(A4)
    MOVE.l A4,$4(A0)
    BRA.w JL_0_28E8
  JL_0_28E0:
    MOVE.l A4,comPtr_LastSourceLine
    CLR.l (A4)
  JL_0_28E8:

  MOVEQ.l #$00,D0                         ; free memory for deleted line
  ADD.b $8(A1),D0
  !newfree

  SUBQ.l #1,comLong_TotalLines
  JSR _redraw
  !basic
Return

JL_0_2906:
  MOVE.w #$FFFF,comWord_SourceChanged
  MOVE.w comWord_ColumnsOffset,D0 : ADD.w comWord_Column,D0

  ;------------------------------------
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w JL_0_29BC
    MOVE.l comLong_DisplayLineOffset,D2 : ADD.l comLong_DisplayLine,D2
    CMP.l comLong_BlockEndY,D2
    BHI.w JL_0_29BC
    BEQ.w JL_0_2962
      CMP.l comLong_BlockStartY,D2
      BCS.w JL_0_29B0
      BNE.w JL_0_29B6
        CMP.l comLong_BlockEndY,D2
        BEQ.w JL_0_2982
          CMP.w comWord_BlockStartX,D0
          BHI.w JL_0_29B6
            MOVE.w comWord_BlockStartX,D2
            SUB.w D0,D2
            MOVE.w D2,comWord_BlockStartX
            BRA.w JL_0_29B0
    JL_0_2962:
      CMP.l comLong_BlockStartY,D2
      BEQ.w JL_0_2982
        CMP.w comWord_BlockEndX,D0
        BHI.w JL_0_29BC

    JL_0_2972:
    MOVE.w comWord_BlockEndX,D2
    SUB.w D0,D2
    MOVE.w D2,comWord_BlockEndX
    BRA.w JL_0_29B6

  JL_0_2982:
  CMP.w comWord_BlockEndX,D0
  BHI.w JL_0_29BC

  CMP.w comWord_BlockStartX,D0
  BHI.b JL_0_2972

  MOVE.w comWord_BlockEndX,D3
  SUB.w comWord_BlockStartX,D3
  MOVE.w comWord_BlockStartX,D2
  SUB.w D0,D2
  MOVE.w D2,comWord_BlockStartX
  ADD.w D3,D2
  MOVE.w D2,comWord_BlockEndX
  JSR JL_0_7A14

  JL_0_29B0:
  ADDQ.l #1,comLong_BlockStartY

  JL_0_29B6:
  ADDQ.l #1,comLong_BlockEndY
  JL_0_29BC:
  ;----------------------------------

  MOVEA.l comPtr_Temp_TokenString2,A0
  MOVEA.l textbufferaddr,A2 : ADDA.w comWord_TextBufferOffset,A2
  CLR.w comWord_Column
  MOVE.l d0,-(a7)                        ; x-position of cursor
  MOVEQ #0,d0

 'l2
    CMP.b #$20,0(a2,d0)
    BNE 'l1
      ADDQ #1,d0
      MOVE.b #32,(a0)+                   ;split line to column
      CMP.l #MAX_Columns,d0
      BGE 'l3
  BRA 'l2

 'l1
  TST.w comWord_ColumnsOffset
  BEQ 'ld
    CLR.w comWord_ColumnsOffset
    CMP.w visiblecolumns,d0
    BLE 'ld
      SUB.w visiblecolumns,d0
      MOVE.w visiblecolumns,comWord_ColumnsOffset
      CMP.w visiblecolumns,d0
      BLE 'ld
        SUB.w visiblecolumns,d0
        MOVE.l d0,-(a7)
        MOVE.w comWord_ColumnsOffset,d0 : ADD.w visiblecolumns,d0
        MOVE.w d0,comWord_ColumnsOffset
        MOVE.l (a7)+,d0
 'ld
  MOVE.w d0,comWord_Column

 'l3
  MOVE.l (a7)+,d0

  JL_0_29C8:
    MOVE.b $0(A2,D0.W),(A0)+
    MOVE.b #$20,$0(A2,D0.W)
    ADDQ.w #1,D0
  CMP.w #MAX_Columns,D0
  BCS.b JL_0_29C8

  JL_0_29DA:
    CMPA.l comPtr_Temp_TokenString3,A0
    BCC.w JL_0_29E8
      MOVE.b #$20,(A0)+
  BRA.b JL_0_29DA
  JL_0_29E8:

  JSR parse_line
  JSR replaceCurrentLine
  MOVEA.l comPtr_Temp_TokenString2,A2
  JSR parse_line

  MOVE.l D5,D0
  ADDI.w #$9,D0
  JSR AllocPoolMem

  MOVEA.l D0,A0
  MOVE.b D5,$8(A0)
  LEA $9(A0),A0
  MOVEA.l comPtr_Temp_TokenString1,A1
  JL_0_2A16:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_2A16

  MOVEA.l D0,A0
  MOVE.l A4,$4(A0)
  MOVE.l (A4),D1
  BEQ.w JL_0_2A32
    MOVEA.l D1,A1
    MOVE.l A0,$4(A1)
    MOVE.l A1,(A0)
    BRA.w JL_0_2A3A
  JL_0_2A32:
    MOVE.l A0,comPtr_LastSourceLine
    CLR.l (A0)


  JL_0_2A3A:

  MOVE.l A0,(A4)
  ADDQ.l #1,comLong_TotalLines
;  CLR.w comWord_Column
  !regs2stack
  !basic
  Gosub movecursorlinedown
  !asm
  !stack2regs
JMP _redraw


.indent:
  !regs2stack
  !basic
  If NOT pedconfig\auto_indent
    log_Print{"no auto indent."}
    CLR.w comWord_Column
  Else
    *currentLine = ped\ptrCurrentSourceData\CurrentSourceLine
    tmpColumn.w = -1
    Repeat
      tmpColumn + 1
    Until Peek.b(*currentLine + 9 + tmpColumn) <> $20
    Poke.w ?comWord_Column,tmpColumn
    log_Print{"indent: " + Str$(tmpColumn)}
  EndIf
  !asm
  !stack2regs
RTS

.insertreturn:                       ;return_key
  !basic
  If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : Gosub handle_blockmark
  EndIf

  sourceWindow\redrawFlag = True
  !asm

  MOVE.l comPtr_CurrentSourceLine,a4

  MOVE.w comWord_QualifierStore,D0 : ANDI.w #$3,D0  ; SHIFT pressed as well ?
  BEQ.w JL_0_2906                                   ; if not pressed, dont split current line at cursor pos

  !basic
  Gosub cursor_off
  *newLine.sourceLine = PED_CreateNewSourceLine{""}
  If *newLine = 0
    Pop If
    Goto memAlert_CloseSource
  EndIf
  PutReg A0,*newLine
  MOVE.l A0,-(a7)
  !asm
  MOVE.l (a7)+,A0


  MOVE.w #$FFFF,comWord_SourceChanged

  MOVE.l comLong_DisplayLineOffset,D0 : ADD.l comLong_DisplayLine,D0 : ADDQ.w #1,D0
  JSR block_updatePosY
  ADDQ.l #1,comLong_TotalLines

  BSR.b indent

  MOVE.l (A4),D1
  BNE.w JL_0_2AD0
    MOVE.l A0,(A4)
    MOVE.l A4,$4(A0)
    MOVE.l A0,comPtr_LastSourceLine
    BRA.w JL_0_2ADE
  JL_0_2AD0:
    MOVEA.l D1,A1
    MOVE.l A0,$4(A1)
    MOVE.l A0,(A4)
    MOVE.l A1,(A0)
    MOVE.l A4,$4(A0)
  JL_0_2ADE:
  MOVE.l A0,comPtr_CurrentSourceLine

  MOVE.w comWord_ColumnsOffset,D0
  BEQ.w JL_0_2AF6
    CLR.w comWord_ColumnsOffset
    JSR JL_0_7962_bas                        ;horiz scroll
  JL_0_2AF6:

  !basic
  Gosub update_horizscroller
  !asm
  MOVE.l comLong_DisplayLine,D0 : ADDQ.w #1,D0 : ADD.w comWord_BoundLinesY,D0
  CMP.l viewablelines,D0
  BCS.w JL_0_2B6C
    ADDQ.l #1,comLong_DisplayLineOffset

    MOVE.l viewablelines,-(A7)
    MOVE.l comLong_DisplayLine,D0 : ADDQ.l #1,D0 : MOVE.l D0,viewablelines
    !basic
    PED_ScrollVertical{#SCROLL_UP}
    !asm
    MOVE.l (A7)+,viewablelines

    MOVEM.w D0-D1,-(A7)
    MOVEQ.l #$00,D0
    MOVE.l comLong_DisplayLine,D1 : ADD.l comLong_DisplayLineOffset,D1
    JSR checkCursorInBlockmark
    MOVEM.w (A7)+,D0-D1

    TST.b comByte_StateBlockMark
    BNE.w JL_0_2B68
      RTS
    JL_0_2B68:
    JMP _redraw
  JL_0_2B6C:

  ;-- scroll rest of source downwarts
  !basic
  PED_ScrollVertical{#SCROLL_DOWN,Peek.l(?comLong_DisplayLine) + 1}
  Gosub update_sourcewindow_bottom
  !asm

  MOVEM.w D0-D1,-(A7)
  MOVEQ.l #$00,D0
  MOVE.l comLong_DisplayLine,D1 : ADD.l comLong_DisplayLineOffset,D1
  JSR checkCursorInBlockmark
  MOVEM.w (A7)+,D0-D1

  TST.b comByte_StateBlockMark
  BNE.w JL_0_2BA0
    RTS
  JL_0_2BA0:
JMP JL_0_7962_bas


.menu_top:
  !asm
  JSR jump_addhistory
  !basic
  Gosub cursor_off
  lineNum.l = 0 : clearColumn.b = True : Gosub gotoline
Return

.menu_bottom:
  !asm
  JSR jump_addhistory
  !basic
  Gosub cursor_off
  lineNum.l = Peek.l(?comLong_TotalLines)-1 : clearColumn.b = True : Gosub gotoline
Return



.gotoline: ;input: lineNum.l, clearColumn.b
  If lineNum.l < 0 Then lineNum = 0
  If lineNum > Peek.l(?comLong_TotalLines) Then lineNum = Peek.l(?comLong_TotalLines) - 1
  log_Print{"gotoline: " + Str$(lineNum)}

  Gosub cursor_off

  ; same code as in routine mouseclick_in_source
  *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  tempY.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
  log_Print{"current line is: " + Str$(tempY)}
  While lineNum <> tempY
    If lineNum > tempY
      If *tempLine\nextLine
        *tempLine = *tempLine\nextLine
        tempY + 1
      Else
        error{"GotoLine: no next line!"}
        lineNum = Peek.l(?comLong_TotalLines) - 1
        tempY = lineNum
      EndIf
    Else
      *tempLine = *tempLine\previousLine
      tempY - 1
    EndIf
  Wend
  ped\ptrCurrentSourceData\CurrentSourceLine = *tempLine

  strline$ = PED_Detoke{*tempLine}
  log_Print{"current sourceline : " + strline$}
  log_Print{"currentline: " + Str$(tempY)}

  ; TODO: move cursor to end of line
  ;TST.b newsyntax
  ;BEQ 'l10
  ;  JSR syntax_new1
  ;'l10
  ;CLR.b newsyntax


  ; adjust the display and offset to match the new current line
  tmpDisplayLineOffset.l = Peek.l(?comLong_DisplayLineOffset)

  tempY - Peek.w(?comWord_BoundLinesY)
  If tempY > 0
    If Peek.l(?comLong_TotalLines) > Peek.l(?viewablelines)
      temp.l = Peek.l(?comLong_TotalLines) - Peek.l(?viewablelines) + Peek.w(?comWord_BoundLinesY)
      If lineNum > temp
        temp - Peek.w(?comWord_BoundLinesY)
        newDLO.l = temp
        newDL.l = tempY - temp
      Else
        newDLO.l = tempY
        newDL.l = Peek.w(?comWord_BoundLinesY)
      EndIf
    Else
      newDLO.l = 0
      newDL.l = lineNum
    EndIf
  Else
    newDLO.l = 0
    newDL.l = lineNum
  EndIf
  Poke.l ?comLong_DisplayLineOffset, newDLO
  Poke.l ?comLong_DisplayLine, newDL
  Gosub update_TextBufferOffset

  If tmpDisplayLineOffset <> Peek.l(?comLong_DisplayLineOffset)
    !asm
    JSR _redraw
    !basic
  EndIf

  If clearColumn
    Poke.w ?comWord_ColumnsOffset,0
    Poke.w ?comWord_Column, 0
    Gosub update_horizscroller
    clearColumn = False
  EndIf
Return





; -- handle compilermenu
; menuids
; $5A: Leerzeile im Menu
; $50: Compile & Run
; $5b: Save & Create Exec
; $5c: Save & Compile & Run
; $5d: Debug / Runerrors On 10*slower Code
; $5e: Create Executable absolut Smallest

; $57: calculator
; $58: reload all libs
; $59: open sourcebrowser

.call_compilermenuitem:              ; (Menuitem in D6)
  compile_state.l = 0
  log_Print{"we call the compiler with menu " + Hex$(_menuitem.l)}

  Select _menuitem.l
  Case $5A                             ; empty menuitem number
    Return

  Case #MENU_CALCULATOR
    Gosub set_pointer_busy_bas
    Gosub save_tempprefs                 ; save data to prevent crashes if the calculation routine is called an it coms back to Ped

    WZ_LockAllOpenWindows{}                                                                                                                                                                                                                              
    Gosub open_calculator
    WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                            
    Gosub read_tempprefs                 ; restore data to prevent crashes if the calculation routine is called an it comes back to Ped

    Gosub set_pointer_normal_bas

  Case #MENU_DEFINITIONBROWSER
    Gosub open_newtype

  Case #MENU_SETCLIARGS
    Gosub set_pointer_busy_bas
    WZ_LockAllOpenWindows{}                                                                                                                                                                                                                              
    Gosub open_cliarguments
    WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                            
    Gosub set_pointer_normal_bas

  Case #MENU_SOURCEBROWSER
    Gosub open_labelwindow

  Case #MENU_COMPILERSETTINGS
    Gosub set_pointer_busy_bas
    WZ_LockAllOpenWindows{}                                                                                                                                                                                                                              
    Gosub menu_compilersettings
    If WZ_CheckOpen{"WIN_NEWTYPE"}
       Use Window WZID("WIN_NEWTYPE")
       Gosub newtype_updatelist
    End If
    WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                            
    Gosub update_debuggertoggle
    Gosub save_tempprefs
    Gosub set_pointer_normal_bas

  Case #MENU_COMPILERUN
    ;TEDSetLabelList {?comPtr_LabelList}
    ;TEDSetLabelCount{?comWord_LabelCounter}
    Gosub call_compiler

  Case #MENU_RUN
    Gosub call_compiler

  Case #MENU_SAVECREATEEXE
    log_Print{"savecreateexe"}
    Gosub menu_save
    Gosub call_compiler

  Case #MENU_SAVECOMPILERUN
    Gosub menu_save
    _menuitem = #MENU_COMPILERUN
    Gosub call_compiler

  Case #MENU_RELOAD_USERLIBS
    log_Print{"reload libs"}
    !asm
    LEA instrtab,a1               ; clear intructionstable, but why?
    MOVE.l #32767,d0
   'l11:
      CLR.l (a1)+
    DBF d0,'l11
   'l10:
    !basic

    Gosub call_compiler

    Gosub read_tempprefs

  Default
    Gosub call_compiler
  End Select

  log_Print{"doing stuff after compiler as finished."}
  Gosub update_title_sourcewindow
  Gosub update_statusarea
  log_Print{"checking compiler return state " + Str$(compile_state) }

  ;-- handle compile error??
  Select compile_state.l
  Case -1 : ; everything went ok, nothing to do
  Case -2
    !asm
    MOVEA.l comPtr_CurrentSourceLine,A4
    JSR _redraw
    !basic
  Default ; we have got an error line, jump to that pos
    lineNum.l = compile_state : Gosub gotoline ; hier newsyntax = 1 f|r ans ende der Zeile springen setzen!
  End Select

  log_Print{"all done with compiler, returning to IDE..."}
Return

.call_compiler:
  ; set infos for Compiler to run functions
  If Peek.l(?comFunc_CallMenuEntry) = 0
    error{"Compiler not available!"}
    Return
  EndIf

  Gosub set_CurrentDir

  WZ_LockAllOpenWindows{}

  CompileMenuCallID.l = _menuitem - #MENU_COMPILERUN
  log_Print{"*** calling compiler with function id [" + Hex$(CompileMenuCallID) + "]"}
  Gosub Open_CompileStatus_Window                         ; open Compile status window if we need it
  GetD0 CompileMenuCallID : MOVE.l D0,-(a7)
  !asm
  MOVE.l (a7)+,D6
  MOVEA.l comPtr_FirstSourceLine,A5
  MOVE.l comLong_TotalLines,D7
  MOVE.l comFunc_CallMenuEntry,a0 : JSR (A0)               ; call compilerfunction for the menuentry
  MOVE.l D0,-(a7)
  !basic
  MOVE.l (a7)+,D0
  compile_state.l = PutD0                                  ; get the return code of compiler

  Delay_ 10                                                ; without wating we get s serious crash, dont know why!!

  Gosub update_debuggertoggle                              ; set the state to the commenu "Create Debug Code"

  previoussearch_instruction$ = "|"

  Gosub update_versiongadgets

  Gosub Close_CompileStatus_Window                         ; close compile status window if it is open
  WZ_UnlockAllOpenWindows{}
  log_Print{"*** compiler finished with return code [" + Hex$(compile_state) + "]"}
Return


.moveToEndOfLine:
  MOVE.l d0,-(a7)
  MOVEA.l comPtr_Temp_TokenString1,A1

  MOVE.l a4,a0
  LEA 9(a0),a0
  MOVEQ #-1,d1

  syn1:
  TST.w comWord_DoTokenize
  BEQ.w JUMP_JL_0_5054

    CMP.l a0,a5
    BEQ  JL_0_5050b
      ADDQ.l #1,d1
      MOVEQ.l #$00,D0
      MOVE.b (A0)+,D0
      BEQ.w JL_0_5050b                                    ; current character is NULL
      BMI.w JL_0_5040b                                    ; current character is beginning of a token
  MOVE.b D0,(A1)+
  BNE.b syn1

  JL_0_5040b:
  LSL.w #8,D0
  MOVE.b (A0)+,D0
  MOVE.l d1,-(a7)
  JSR token_to_ascii
  MOVE.l (a7)+,d1

  JL_0_5048b:
    ADDQ.l #1,d1
    MOVE.b (A3)+,(A1)+
  BNE.b JL_0_5048b
  SUBQ.w #1,A1
  SUBQ.l #1,d1
  BRA.b syn1

  JL_0_5050b:
  SUBQ.l #1,d1
  CMP.w #MAX_Columns,d1
  BGE 'l1
    CMP.l #0,d1
    BGE 'l1
      MOVEQ #0,d1
 'l1
  MOVE.w d1,comWord_Column
  MOVE.l (a7)+,d0
RTS

JUMP_JL_0_5054: JMP JL_0_5054

.event_menu:
  log_Print{"selected menuitem: " + Hex$(_menuitem.l)}

  ;-- handle compiler menues
  If (_menuitem >= #MENU_COMPILERUN) AND (_menuitem < #MENU_NEW)    ;$64 - $50
    Gosub call_compilermenuitem
    Return
  EndIf

  ;-- handle custom menues
  If (_menuitem >= #MENU_CUSTOMEDIT-1) AND (_menuitem < $F00)       ; 259 -$f00
    Gosub call_pluginmenuentry             ;plugin menuitem
    Return
  EndIf

  ;-- handle dynamic menuentries, ( last filenames )
  If _menuitem >= #MENU_TEMPLATE AND _menuitem<#MENU_TEMPLATE+#MAX_MENUTEMPLATES
    Gosub load_template
    Gosub update_vertscroller
    Return
  EndIf


  ;-- handle other menues
  Select _menuitem
  Case #MENU_INSERTFILENAME
    aslfr_SetRequesterTitle{0,!TRANS{"Select a filename to insert in source"},"",""}
    aslfr_SetPath{0,pedconfig\mainDir,"",""}
    If aslfr_Request{0,False,False,False,sourceWindow\pedScreen}
      a$ = aslfr_GetNextFile{}
      Gosub insertstring
    EndIf

  Case #MENU_OPENFILEUNDERCURSOR
    strline$ = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
    _file$ = PED_GetWordAtPos{strline$, Peek.w(?comWord_Column),False,False}
    log_Print{"open file under cursor [" + _file$+ "]"}
    If _file$ <> ""
      a$ = _file$
      If NOT dos_Exist{a$}
        a$ = dos_AddPart{pedconfig\includeDir,_file$}
        log_Print{"not found, trying " + a$}
      EndIf
      If NOT dos_Exist{a$}
        a$ = dos_AddPart{Peek$(?comStr_CurrentDir),_file$}
        log_Print{"not found, trying " + a$}
      EndIf
      If dos_Exist{a$}
        log_Print{"open file under cursor: " + a$}
        GetD0 &a$
        !asm
        JSR loadfile
        !basic
        Gosub storeCurrentSourceData
      Else
        log_Print{"could not find file: " +a$}
      EndIf
    EndIf

  Case #MENU_DELETETOEOL
    log_Print{"menuentry DELETE TO EOL"}
    Poke.w ?comWord_KeyBeforeReturn,last_vankey       ; save keycode
    CursorXTarget.w = Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)
    ; delete all until end of line (replace with spaces)
    lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
    For cupos.w = CursorXTarget To #MAX_Columns-1
      Poke.b lineaddr + cupos, $20
    Next cupos
    Gosub updateSourceLine

  Default
      _menutable.l = ?menutable
      menu_found.b = False : menu_ptr.l = 0 : menu_number.w = 0
      menu_refresh.l = 0
      While (NOT menu_found) AND Peek.l(_menutable) <> 0
        menu_number = Peek.l(_menutable)
        If menu_number = _menuitem
          menu_found = True
          menu_refresh = Peek.l(_menutable + 4)
          menu_ptr = Peek.l(_menutable + 8)
        Else
          _menutable + 12
        EndIf
      Wend
      If menu_ptr
        log_Print{"menu call execute at " + Hex$(menu_ptr) + "..."}
        GetD0 _menuitem : MOVE.l d0,D6 : Call menu_ptr
        log_Print{"menu call ended."}
        If menu_refresh
          Gosub update_vertscroller
        EndIf
      EndIf
  End Select
Return


.JL_0_2Dca8:
  !basic
  log_Print{"*** JL_0_2Dca8 called."}

  Gosub calc_SourceWindowDimensions
  Gosub clear_sourcewindow
  Gosub update_labelstuff
  Gosub update_scrollers

  Gosub analyze_loadedsource
  Gosub set_CurrentDir

  log_Print{"redraw of sourcewindow"}
  Gosub draw_statusarea

  !asm
  JSR _redraw
  MOVEA.l comPtr_CurrentSourceLine,A4
RTS


.load_template:
  mcounter.l = _menuitem-#MENU_TEMPLATE
  log_Print{"called menu new template with subitem: " + Str$(mcounter)}

  ResetList templates()
  For n.l = 0 To mcounter - 1
    NextItem templates()
  Next
  If NextItem(templates())
    log_Print{"opening new source tab."}

    Gosub menu_opennew

    loadsourcefilename.s = templates()\filename
    log_Print{"selected template: " + loadsourcefilename}
    Gosub load_source

  Else
    log_Print{"unknown template, opening a new file instead."}
    tmp_string = !TRANS{"unnamed"}
    ;MOVE.l d0,-(a7)
    ;GetD0 &tmp_string
    ;!asm
    Gosub menu_opennew
    ;MOVE.l (a7)+,d0 ; clean stack
    ;!basic
  EndIf
Return


.menu_openload:
  MOVE.w #0,loadAsNew
  Goto open_source

.menu_opennew:
  MOVE.w #1,loadAsNew

  open_source:

  !basic
  log_Print{"menu opennew: value of ped\firstLoadedEntry: " + Hex$(ped\firstLoadedEntry)}

  ; -- save changes to current source line
  Gosub storeline_bas

  ; -- alloc memory for a new fileentry
  MOVE.l #comDef_XtraEnd-comLongLong_XtraBegin+10,d0 : tmpMemSize.l = PutD0
  *newEntry.sourceEntry = PED_AllocMem{tmpMemSize}
  If *newEntry = 0
    Gosub display_memoryalert
    Return
  EndIf
  log_Print{"new fileentry allocated at: " + Hex$(*newEntry) }
  log_Print{"entry size: " + Str$(tmpMemSize)}
  If ped\firstLoadedEntry = 0
    log_Print{"no fileentry available, creating an empty file entry..."}
    ped\firstLoadedEntry = *newEntry
    ped\firstSourceEntry = *newEntry
    ped\currentSourceEntry = *newEntry
    *newEntry\previousEntry = 0
    *newEntry\nextEntry = 0
    log_Print{"currentEntry at " + Hex$(ped\currentSourceEntry)}
    Gosub getCurrentSourceData
    Gosub clear_sourcebuffer
    log_Print{"Totallines = " + Str$(ped\ptrCurrentSourceData\TotalLines)}
    Return
  EndIf

  Gosub storeCurrentSourceData

  log_Print{"currentEntry at " + Hex$(ped\currentSourceEntry)}
  *sourceEntry.sourceEntry = ped\currentSourceEntry
  *nextEntry.sourceEntry = *sourceEntry\nextEntry
  If *nextEntry <> 0                         ; insert new source between current source an next source entry ?
    *sourceEntry\nextEntry = *newEntry       ; nextfile -> newentry
    *newEntry\previousEntry = *sourceEntry   ; newentry\prev -> currentEntry
    *newEntry\nextEntry = *nextEntry         ; newentry\next -> nextfile
    *nextEntry\previousEntry = *newEntry     ; nextfile\prev -> newentry
  Else
    ped\firstLoadedEntry = *newEntry
    *sourceEntry\nextEntry = *newEntry       ; nextfile -> newentry
    *newEntry\previousEntry = *sourceEntry
    *newEntry\nextEntry = 0
  EndIf
  ped\currentSourceEntry = *newEntry

  Gosub clear_sourcebuffer
  !asm
  JSR JL_0_2Dca8
  !basic

  If Peek.w(?loadAsNew)
    Gosub menu_load
    Gosub storeCurrentSourceData
    Gosub update_vertscroller
  EndIf
Return

.storeCurrentSourceData:                      ;copy view data
  ; this function is called after a succesfull load of a sourcecode and befor and after a switch of the sourcecode  tomsmart1
  MOVE.l LabelList_FirstVisableItemNumber@(a5),comLong_Label1VisableItem      ; same as Poke
  MOVE.l comLong_Label1VisableItem,comLong_Label1VisableItemStore             ; to update both for a unified LabelList restore routine that work by load and switch of a Sourcecode  tomsmart1

  GetReg A0, ped\currentSourceEntry : ADDQ.l #8,A0
  LEA comLongLong_XtraBegin,A1
  MOVE.l #comDef_XtraEnd-comLongLong_XtraBegin, D0 : SUBQ.w #1,D0
 'copyloop
    MOVE.b (A1)+,(A0)+
  DBF D0,'copyloop
Return


.getCurrentSourceData:
  ; zurueckholen der xtra-settings nach sourcewechsel
  GetReg A0,ped\currentSourceEntry : ADDQ.l #8,A0
  LEA comLongLong_XtraBegin,A1
  MOVE.l #comDef_XtraEnd-comLongLong_XtraBegin, D0 : SUBQ.w #1,D0
 'copyloop:
    MOVE.b (A0)+,(A1)+
  DBF D0,'copyloop

  ped\ptrCurrentSourceData = ?comLongLong_XtraBegin
  ;-- restore some windows
  Gosub RestoreLabelAndNewtypeWin
Return

.selectfile:  ; A0: current entry in opened file table
  selectedEntry.l = PutD0

  Gosub storeCurrentSourceData
  Gosub save_tempprefs

  ped\currentSourceEntry = selectedEntry
  Gosub getCurrentSourceData

  !asm
  JSR JL_0_2Dca8
  !basic

  Gosub read_tempprefs

  Gosub draw_statusarea              ;JSR linetext
  Gosub update_horizscroller
Return


.menu_previousfile:
  Gosub storeCurrentSourceData
  Gosub save_tempprefs

  If ped\currentSourceEntry\previousEntry
    ped\currentSourceEntry = ped\currentSourceEntry\previousEntry
  Else
    If ped\firstLoadedEntry = ped\currentSourceEntry
      Pop If : Pop If : Return
    Else
      ped\currentSourceEntry = ped\firstLoadedEntry
    EndIf
  EndIf
  Gosub getCurrentSourceData

  !asm
  JSR JL_0_2Dca8
  !basic

  Gosub read_tempprefs
  Gosub draw_statusarea              ;JSR linetext
  Gosub update_horizscroller
Return


.menu_nextfile:
  Gosub storeCurrentSourceData
  Gosub save_tempprefs

  If ped\currentSourceEntry\nextEntry
    ped\currentSourceEntry = ped\currentSourceEntry\nextEntry
  Else
    If ped\firstSourceEntry = ped\currentSourceEntry
      Pop If : Pop If : Return
    Else
        ped\currentSourceEntry = ped\firstSourceEntry
    EndIf
  EndIf
  Gosub getCurrentSourceData

  !asm
  JSR JL_0_2Dca8
  !basic

  Gosub read_tempprefs
  Gosub draw_statusarea
  Gosub update_horizscroller
Return

.menu_copy:
  log_Print{"menu copy called."}
  If Peek.l(?comLong_BlockEndY) = -1 Then Return

  Gosub getCountOfMarkedLines
  strline$ = PED_Detoke{*tempLine}
  strlng.w = FLen(strline$)
  If strlng = 0
    log_Print{"no text to copy..."}
  Else
    ;log_Print{"first marked sourceline: " + strline$}
    ;log_Print{"marked lines: " + Str$(getCountOfMarkedLines.l)}

    ;log_Print{"BlockEndX =" + Str$(Peek.w(?comWord_BlockEndX))}
    ;log_Print{"BlockStartX = " + Str$(Peek.w(?comWord_BlockStartX))}

    If getCountOfMarkedLines.l < 2
      If strlng >= Peek.w(?comWord_BlockEndX)
        strlng = Peek.w(?comWord_BlockEndX) - Peek.w(?comWord_BlockStartX) + 1
      Else
        strlng = strlng - Peek.w(?comWord_BlockStartX)
      EndIf
      ;log_Print{"before peeking " + Str$(strlng)}
      strline$ = Mid$(strline$,Peek.w(?comWord_BlockStartX), strlng) ;+ Chr$(10)
      ;log_Print{">> [" + strline$ + "]"}

      clipboard_WriteText{&strline$}
      log_Print{"moved to clipboard"}
    Else
      *iff.IFFHandle = AllocIFF_()
      If *iff
        *iff\iff_Stream = OpenClipboard_ (0)
        If *iff\iff_Stream
          InitIFFasClip_ *iff
          If (OpenIFF_ (*iff, #IFFF_WRITE)=0)
            If (PushChunk_ (*iff, #ID_FTXT, #ID_FORM, #IFFSIZE_UNKNOWN)=0)
              If (PushChunk_ (*iff, 0, #ID_CHRS, #IFFSIZE_UNKNOWN)=0)
                ; VerticalCopyMode mssing ??
                If strlng <= Peek.w(?comWord_BlockStartX)
                  ; end of String...
                  strlng = 1
                  strline$ = Chr$(10)
                Else
                  strlng = strlng - Peek.w(?comWord_BlockStartX)
                  strline$ = Mid$(strline$, Peek.w(?comWord_BlockStartX), strlng) + Chr$(10)
                EndIf
                ;log_Print{Str$(Len(strline$))}
                ;log_Print{">"+strline$+"<"}
                WriteChunkBytes_ *iff, &strline$, Len(strline$)

                ; copy most lines
                ;log_Print{"copy other lines"}
                For si.w = 1 To getCountOfMarkedLines - 2
                  If *tempLine\nextLine
                    *tempLine = *tempLine\nextLine
                    strline$ = PED_Detoke{*tempLine}
                    strlng.w = FLen(strline$)
                    If ped\verticalCopyMode <> 0 AND (strlng > Peek.w(?comWord_BlockStartX))
                      strlng = strlng - Peek.w(?comWord_BlockStartX)
                      strline$ = Mid$(strline$, Peek.w(?comWord_BlockStartX), strlng)  + Chr$(10)
                    Else
                      strline$ + Chr$(10)
                    EndIf
                    WriteChunkBytes_ *iff,&strline$,Len(strline$)
                  Else
                    error{"Error copying to clipboard: no next line!",#log_error}
                  EndIf
                Next si

                ; copy last selected Line
                ;log_Print{"copy last line"}
                *tempLine = *tempLine\nextLine
                If *tempLine
                  strline$ = PED_Detoke{*tempLine}
                  strline$ = Left$(strline$,Peek.w(?comWord_BlockEndX))
                  strlng = Len(strline$)
                  If ped\verticalCopyMode <> 0 AND (strlng > Peek.w(?comWord_BlockStartX))
                    strline$ = UnRight$(strline$,Peek.w(?comWord_BlockStartX)) + Chr$(10)
                  Else
                    strline$ = strline$ + Chr$(10)
                  EndIf
                  WriteChunkBytes_ *iff, &strline$, Len(strline$)
                EndIf
                PopChunk_ *iff
              End If

              PopChunk_ *iff
            Else
              error{"Could not write chunks."}
            End If
            CloseIFF_ *iff
          Else
            error{"Could not open IFF."}
          End If
          CloseClipboard_ *iff\iff_Stream
        Else
          error{"Could not open Clipboard."}
        End If
        FreeIFF_ *iff
      Else
        error{"Could not AllocIFF."}
      End If
    EndIf
  EndIf

  If ped\cutMode = 0
    Gosub cursor_off                                                                                                                                                                                                                                        
    !asm
    MOVE.l #$ffffffff,comLong_BlockEndY            ; set to clear Block mark
    JSR _redraw                                    ; clear block mark
    ped\cutMode = 0
    !basic
  EndIf
exit_copy:
  log_Print{"copy finished."}
Return


Macro updateBlockMark ;{d1 = currentLine, d0 = currentColumn}
  SF comByte_StateBlockMark

  If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
    If (Peek.l(?comLong_BlockStartY) < `1) OR (Peek.l(?comLong_BlockStartY) = `1 AND Peek.w(?comWord_BlockStartX) <= `2)
      If (Peek.l(?comLong_BlockEndY) > `1) OR (Peek.l(?comLong_BlockEndY) = `1 AND Peek.w(?comWord_BlockEndX) <= `2)
        ST comByte_StateBlockMark
      EndIf
    EndIf
  EndIf
End Macro

checkCursorInBlockmark:
  SF comByte_StateBlockMark
  TST.l comLong_BlockEndY
  BMI.w JL_0_319A
    CMP.l comLong_BlockStartY,D1
    BLT.w JL_0_319A
    BNE.w JL_0_317C
      CMP.w comWord_BlockStartX,D0
      BLT.w JL_0_319A
    JL_0_317C:
    CMP.l comLong_BlockEndY,D1
    BGT.w JL_0_319A
    BNE.w JL_0_3194
      CMP.w comWord_BlockEndX,D0
      BGT.w JL_0_319A
    JL_0_3194:
    ST comByte_StateBlockMark
 JL_0_319A:
RTS

.getCountOfMarkedLines:
  diff.l = 0
  log_Print{"BlockStartY: " + Str$(Peek.l(?comLong_BlockStartY))}
  log_Print{"BlockEndY  : " + Str$(Peek.l(?comLong_BlockEndY))}
  *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  currLine.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
  log_Print{"currline   : " + Str$(currLine)}
  If currLine < Peek.l(?comLong_BlockStartY)
    diff = Peek.l(?comLong_BlockStartY) - currLine
    For si.w = 1 To diff
      If *tempLine\nextLine Then *tempLine = *tempLine\nextLine Else error{"Error copying to clipboard!"}
    Next si
  Else
    If currLine > Peek.l(?comLong_BlockStartY)
      diff = currLine - Peek.l(?comLong_BlockStartY)
      For si.w = 1 To diff
        If *tempLine\previousLine Then *tempLine = *tempLine\previousLine Else error{"Error copying to clipboard!"}
      Next si
    EndIf
  EndIf
  getCountOfMarkedLines.l = Peek.l(?comLong_BlockEndY) - Peek.l(?comLong_BlockStartY) + 1
Return

.menu_cut:
  ped\cutMode = True : Gosub menu_copy
  Gosub menu_kill
Return


.menu_paste:
  ped\pasteMode = $FFFF
  Gosub do_paste
  ped\pasteMode = $0000
Return


.menu_kill_bas:
  log_Print{"menu Kill called."}

  If Peek.l(?comLong_BlockEndY) = $FFFFffff
    log_Print{"no block selected."}
    Return
  EndIf

  Gosub getCountOfMarkedLines
  log_Print{"marked Lines: " + Str$(getCountOfMarkedLines)}
  strline$ = PED_Detoke{*tempLine}
  log_Print{"source of first blockline: " + Left$(strline$,20)}
  *previousLine.sourceLine = *tempLine\previousLine

  For si.w = 1 To getCountOfMarkedLines
    strline$ = PED_Detoke{*tempLine}
    log_Print{Str$(si) + " deleting " + Left$(strline$, 20)}

    ptr_line.l = *tempLine
    *tempLine = *tempLine\nextLine
    PED_FreeMem{ptr_line}

    ped\ptrCurrentSourceData\TotalLines - 1
  Next si

  If *tempLine
    *previousLine\nextLine = *tempLine          ; set templine as next line of line before block
    *tempLine\previousLine = *previousLine      ; set line after block as nextline of line before block
  Else
    *previousLine\nextLine = 0
    ped\ptrCurrentSourceData\LastSourceLine = *newLine
  EndIf

  ped\ptrCurrentSourceData\CurrentSourceLine = *previousLine

  Gosub reset_Blockflag

  If Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) > Peek.l(?comLong_TotalLines)
    Poke.l ?comLong_TotalLines, Peek.l(?comLong_TotalLines) - 1

    Poke.l ?comLong_DisplayLineOffset, Peek.l(?comLong_TotalLines)
    Poke.l ?comLong_DisplayLine, 0

    Poke.w ?comWord_Column,Peek.w(?comWord_BlockStartX)
    Gosub update_currsourceline_bas
    !asm
    JSR _redraw
    !basic
    lineNum.l = Peek.l(?comLong_DisplayLineOffset) : Gosub gotoline
  Else
    Poke.w ?comWord_Column,Peek.w(?comWord_BlockStartX)
    Gosub update_currsourceline_bas
    !asm
    JSR _redraw
    !basic
  EndIf
Return

.menu_kill:
  log_Print{"menu kill called."}
  If Peek.l(?comLong_BlockEndY) = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal_bas
    Pop If : Return
  EndIf

  !asm
  MOVE.l comPtr_CurrentSourceLine,a4

  CLR.w comWord__AL_0_8AD8
  MOVE.w #$FFFF,comWord_SourceChanged
  JSR JL_0_5524                                 ; move to Blockbegin, returns pointer in A5; D6: blockStartY

  MOVEQ.l #$00,D5
  MOVEA.l comPtr_Temp_TokenString2,A0
  JL_0_3498:
    CMP.w comWord_BlockStartX,D5                ; save the string before BlockStartX to TokenString2
    BCC.w JL_0_34A8
      JSR JL_0_5650
      MOVE.b D0,(A0)+
  BRA.b JL_0_3498
  JL_0_34A8:

  MOVE.l A0,-(A7)
  JL_0_34AA:
    CMP.l comLong_BlockEndY,D6
    BCC.w JL_0_34BE
      MOVE.l (A5),-(A7)
      JSR JL_0_5474                            ; delete the lines
      MOVEA.l (A7)+,A5
      ADDQ.l #1,D6
  BRA.b JL_0_34AA
  JL_0_34BE:

  CMP.l comLong_BlockStartY,D6
  BEQ.w JL_0_34CA
    JSR JL_0_553A                                   ; ?? copy marked string of last marked line ??
  JL_0_34CA:
  MOVEA.l (A7)+,A0

  MOVE.w comWord_BlockEndX,D5
  JL_0_34D0:
    ADDQ.w #1,D5
    CMP.w #MAX_Columns,D5
    BCC.w JL_0_34E4
      JSR JL_0_5650
      SUBQ.w #1,D5
      MOVE.b D0,(A0)+
  BRA.b JL_0_34D0
  JL_0_34E4:
    CMPA.l comPtr_Temp_TokenString3,A0
    BCC.w JL_0_34F2
      MOVE.b #$20,(A0)+
  BRA.b JL_0_34E4
  JL_0_34F2:

  MOVE.w comWord_BlockStartX,D0
  BNE.w JL_0_3510
    MOVE.w comWord_BlockEndX,D0
    ADDQ.w #1,D0
    CMP.w #MAX_Columns,D0
    BCS.w JL_0_3510
      JSR JL_0_5474                                ; delete the line
      BRA.w JL_0_351C
  JL_0_3510:
    MOVEA.l A5,A4
    MOVE.l A4,comPtr_CurrentSourceLine
    JSR tokenizeAndInsertNewLine                   ; parse the newline in TokenString2 and allocate memory for it
  JL_0_351C:

  !basic
  Gosub reset_Blockflag
  If Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) > Peek.l(?comLong_TotalLines)
    Poke.l ?comLong_TotalLines, Peek.l(?comLong_TotalLines) - 1
    Poke.l ?comLong_DisplayLineOffset, Peek.l(?comLong_TotalLines)
    Poke.l ?comLong_DisplayLine, 0

    Gosub update_currsourceline_bas
    !asm
    JSR _redraw
    !basic
    lineNum.l = Peek.l(?comLong_DisplayLineOffset) : Gosub gotoline
  Else
    Gosub update_currsourceline_bas
    !asm
    JSR _redraw
    !basic
  EndIf
Return


.menu_saveascii:
  tmp_string = PED_RequestFile{"", "", "Select file to save as ASCII...", "(#?.info)"}
  If tmp_string ="" Then Return

  log_Print{"write ab2: opening file"}
  Gosub set_pointer_busy_bas
  PED_ShowMessage{!TRANS{"Exporting to ASCII-File"} + "..."}

  *write_fh.l = Open_(&tmp_string, #HUNK_RELOC_8__MODE_NEWFILE)
  If *write_fh = 0
    dummy.l = ask{!TRANS{messageErrorWriteFile},!TRANS{"OK"},"Error!"}
  Else
    If Peek.l(?comLong_TotalLines) > 0
      *tempLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine

      If Peek.w(?comWord_DoTokenize) <> 0
        log_Print{"write ab2: writing detokenized file"}

        ;-- detokenize and write to file
        numlines.l = Peek.l(?comLong_TotalLines)
        totalLength.l = 0
        For n.l = 0 To numlines - 1
          baseptr.l = *tempLine + 9
          sptr.l = baseptr
          While Peek.b(sptr) : sptr + 1 : Wend
          totalLength + sptr - baseptr + 1
          *tempLine = *tempLine\nextLine
        Next
        tmp.l      = AllocVec_(totalLength,#MEMF_CLEAR)
        If tmp
          node.l     = ped\ptrCurrentSourceData\FirstSourceLine
          dptr.l     = tmp
          For n.l=0 To numlines-1
            baseptr.l = node+$9 ;Peek.l (node+$9)
            sptr.l    = baseptr
            Repeat
              char.b = Peek.b(sptr)
              Poke.b dptr,char : sptr +1 : dptr+1
            Until char=0
            node = Peek.l(node)
          Next
          plainLength.l = preproc_DetokenizeFP{*PreProcessor, tmp, totalLength, *write_fh}
          FreeVec_ tmp
        Else
          error{!TRANS{"Not enough memory for temp buffer!"}}
        End If
      Else
        ;-- directly write to file
        log_Print{"write ab2: writing text line-by-line to file"}
        Repeat
          baseptr.l = *tempLine + 9
          linelength.l = Peek.b(baseptr + 8) - 1
          strLine$ = Peeks$(baseptr,linelength) + Chr$(10)
          Write_ *write_fh, &strLine$, Len(strLine$)
          *tempLine = *tempLine\nextLine
        Until *tempLine = 0
      EndIf
    EndIf
    log_Print{"write ab2: closing file"}
    Close_ *write_fh : *write_fh = 0
  EndIf

  WZ_UnlockAllOpenWindows{}
  Gosub set_pointer_normal_bas
  WZ_HideMessage{}
  PED_ShowMessage{""}
Return

.menu_saveblockas:
  If Peek.l(?comLong_BlockEndY) > -1
    blockfn$ = PED_RequestFile{"","","Name to save block as","(#?.info)"}
    If blockfn$ <> ""
      *write_fh.l = Open_(&blockfn$, #HUNK_RELOC_8__MODE_NEWFILE)
      If *write_fh <> 0
        Gosub set_pointer_busy_bas
        Gosub getCountOfMarkedLines
        strline$ = PED_Detoke{*tempLine}
        strlng.w = FLen(strline$)

        If getCountOfMarkedLines.l < 2
          If strlng >= Peek.w(?comWord_BlockEndX)
            strlng = Peek.w(?comWord_BlockEndX) - Peek.w(?comWord_BlockStartX) + 2
          EndIf
          strlng = strlng - 1
          strline$ = Mid$(strline$, Peek.w(?comWord_BlockStartX), strlng) ;+ Chr$(10)
          ;log_Print{">>" + strline$}
          Write_ *write_fh,&strline$,FLen(strline$)
        Else
          If strlng <= Peek.w(?comWord_BlockStartX)
            ; end of String...
            strline$ = Chr$(10)
            WriteChunkBytes_ *write_fh, &strline$,1
          EndIf

           ; copy first line
           strlng = strlng - Peek.w(?comWord_BlockStartX)
           strline$ = Mid$(strline$, Peek.w(?comWord_BlockStartX), strlng) + Chr$(10)
           Write_ *write_fh, &strline$, Len(strline$)

           ; copy most lines
           For si.w = 1 To getCountOfMarkedLines - 2
             If *tempLine\nextLine
               *tempLine = *tempLine\nextLine
               strline$ = PED_Detoke{*tempLine}
               strlng.w = FLen(strline$)
               If ped\verticalCopyMode <> 0 AND (strlng > Peek.w(?comWord_BlockStartX))
                 strline$ = Mid$(strline$, Peek.w(?comWord_BlockStartX), strlng - Peek.w(?comWord_BlockStartX)) + Chr$(10)
               Else
                 strline$ = Left$(strline$, strlng) + Chr$(10)
               EndIf
               Write_ *write_fh,&strline$,FLen(strline$)
             Else
               error{"Error copying to clipboard: no next line!",#log_error}
             EndIf
           Next si

           ; copy last selected Line
           *tempLine = *tempLine\nextLine
           If *tempLine
             strline$ = PED_Detoke{*tempLine}
             strline$ = Left$(strline$,Peek.w(?comWord_BlockEndX))
             strlng = Len(strline$)
             If ped\verticalCopyMode <> 0 AND (strlng > Peek.w(?comWord_BlockStartX))
               strline$ = UnRight$(strline$,Peek.w(?comWord_BlockStartX)-1) + Chr$(10)
             Else
               strline$ = strline$ + Chr$(10)
             EndIf
             Write_ *write_fh, &strline$, Len(strline$)
           EndIf
        EndIf
        Close_ *write_fh
        Gosub set_pointer_normal_bas
      Else
        dummy.l = ask{!TRANS{messageErrorWriteFile},!TRANS{"OK"},"Error!"}
      End If
    End If
  Else
    log_Print{"no block marked."}
  EndIf

Return


.menu_includeblock:
  log_Print{"includeblock"}

  Poke.w ?comWord__AL_0_8AD8,0
  includeblockfile$ = PED_RequestFile{"","","Name of block to load","(#?.info)"}
  If includeblockfile$ <> ""
    Gosub do_paste
  EndIf
Return

Function.s PED_DetokenizeText{strLine.s}
SHARED ped,*PreProcessor

  If ped\DoTokenize
    MaxLen linebuff$ = 256
    preproc_Detokenize{*PreProcessor,&strline$,&linebuff$,FLen(strline$)}
    strLine = Peek.s(&linebuff$)
  EndIf

  Function Return strLine

End Function

Function.s PED_TokenizeText{strLine.s}
SHARED ped,*PreProcessor

  If ped\DoTokenize
    MaxLen linebuff$ = 256
    preproc_Tokenize{*PreProcessor,&replacedline.s,&linebuff$,FLen(replacedline)}
    strLine.s = Peek.s(&linebuff$)
  EndIf

  Function Return strLine
End Function


.do_paste:
  log_Print{"pastemode " + Hexw$(ped\pasteMode)}

  If ped\pasteMode
    ; clipboard mode
    If NOT PED_ReadClipboard{} Then Return
  Else
    ; includeblock mode
    ped\sourceFileHandle = PED_OpenFile{includeblockfile$,#HUNK_RELOC_16__MODE_OLDFILE,False}
    Poke.w ?comWord_DoTokenize, ped\DoTokenize
;    Poke.w ?flag_tokenization, ped\flag_tokenization
    Poke.b ?convert, ped\convert
    If NOT PED_ReadFileCache{}
      PED_CloseFile{ped\sourceFileHandle}
      Return
    EndIf
  EndIf

  ped\LabelListChanged = True
  ped\ptrCurrentSourceData\SourceChanged = $FFFF

  lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
  currentColumn.w = Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)

  ; get first part of current line
  pasteString.s = ""
  For p.w = 0 To currentColumn - 1
    currentbyte.b = Peek.b(lineaddr + p)
    If currentbyte = $22 Then Poke.b ?instring, NOT Peek.b(?instring)
    If NOT Peek.b(?instring) Then currentbyte = currentbyte BitClr 7
    pasteString + Chr$(currentbyte)
  Next p
  ; get rest of current line
  restString.s = ""
  For p.w = currentColumn To #MAX_Columns-1
    currentbyte.b = Peek.b(lineaddr + p)
    restString + Chr$(currentbyte)
  Next p
  For p = 0 To currentColumn - 1
    restString + " "
  Next p

  ; get first line and join it with currentline
  pasteString = pasteString + PED_ReadNextLine{}
 
  ; check labelidentifier, update labellist ?
  If PED_CheckLabelRelevance{pasteString} Then ped\LabelListChanged = True

  ; replace line with current one
  GetReg D0,&pasteString : MOVE.l D0,-(a7)
  !asm
  MOVE.l (a7)+,D2 : MOVE.l D2,A2      ; pointer to String to parse to be in A2
  MOVEA.l comPtr_CurrentSourceLine,A4
  JSR parse_line
  MOVE.l d5,-(a7)                     ; returns length of string in D5
  !basic
  MOVE.l (a7)+,D0 : PutReg d0,tmpd0.l

  *newLine.sourceLine = PED_CreateNewSourceLine{ Peeks$(Peek.l(?comPtr_Temp_TokenString1),tmpd0) }
  ;*newLine.sourceLine = PED_CreateNewSourceLine{pasteString}

  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *previousLine.sourceLine = *currentLine\previousLine
  If cutLine{*currentLine}
    appendLine{*previousLine, *newLine}
    PED_FreeMem{*currentLine}
  Else
    PED_InsertSourceLine{*newLine}
  EndIf
  ped\ptrCurrentSourceData\CurrentSourceLine = *newLine

  ; import all further lines
  Repeat
    tmpLine = PED_ReadNextLine{}
    tmpLen = FLen(tmpLine)
    If tmpLine <> "NoCOntenTwasDelivered"
      If ped\verticalCopyMode
        If currentColumn > #MAX_Columns-10 Then currentColumn = #MAX_Columns-10
        pasteString = SPACE$(currentColumn)
        pasteString = pasteString + tmpLine
      Else
        pasteString = tmpLine
      EndIf
      ;log_Print{"got line: " + pasteString}
      GetReg D0,&pasteString : MOVE.l D0,-(a7)
      !asm
      MOVE.l (a7)+,D2 : MOVE.l D2,A2      ; pointer to String to parse to be in A2
      MOVEA.l comPtr_CurrentSourceLine,A4
      JSR parse_line
      MOVE.l d5,-(a7)                     ; returns length of string in D5
      !basic
      MOVE.l (a7)+,D0 : PutReg d0,tmpd0.l
      *newLine = PED_CreateNewSourceLine{ Peeks$(Peek.l(?comPtr_Temp_TokenString1),tmpd0)}
      appendLine{ped\ptrCurrentSourceData\CurrentSourceLine, *newLine}
      ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
      ped\ptrCurrentSourceData\TotalLines + 1
      ;PED_InsertSourceLine{*newLine}
    Else
      tmpLen = 0
    EndIf
  Until tmpLen = 0 AND (readcache\moreBytes = False)


  ; add the rest to an new line
  If Len(Trim$(restString)) > 0
    restString = pasteString + restString

    GetReg D0,&restString : MOVE.l D0,-(a7)
    !asm
    MOVE.l (a7)+,D2 : MOVE.l D2,A2      ; pointer to String to parse to be in A2
    MOVEA.l comPtr_CurrentSourceLine,A4
    JSR parse_line
    MOVE.l d5,-(a7)                     ; returns length of string in D5
    !basic
    MOVE.l (a7)+,D0 : PutReg d0,tmpd0.l
    pasteString = Peeks$(Peek.l(?comPtr_Temp_TokenString1),tmpd0)

    *currentLine = ped\ptrCurrentSourceData\CurrentSourceLine
    *newLine = PED_CreateNewSourceLine{pasteString}
    *currentLine =ped\ptrCurrentSourceData\CurrentSourceLine
    *previousLine.sourceLine = *currentLine\previousLine
    If cutLine{*currentLine}
      appendLine{*previousLine,*newLine}
      PED_FreeMem{*currentLine}
      ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
    Else
      error{"Could not replace the current source line"}
      Return
    EndIf
  ;Else
  ;  log_Print{"no restString: " + restString}
  EndIf

  If ped\pasteMode = 0 Then PED_CloseFile{ped\sourceFileHandle}
  Poke.b ?instring,0

  Gosub update_currsourceline_bas
  ;storcol.w = Peek.w(?comWord_Column)
  ;Poke.w ?comWord_Column, 5
  ;CursorXTarget = Len(StripTrail$(restString,$20))
  ;GetD0 CursorXTarget.w : MOVE.w D0,-(a7)
  ;!asm
  ;MOVE.w (a7)+,D1 : JSR moveCursorToX
  ;!basic

  Gosub update_statusarea
  Gosub reset_Blockflag
  !asm
  JSR _redraw
  !basic
Return


.menu_dublicate:
  log_Print{"menu dublicate called."}
  If Peek.l(?comLong_BlockEndY) = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal_bas
    Pop If: Return
  EndIf

  !asm
  CLR.w comWord__AL_0_8AD8
  MOVE.w #$FFFF,comWord_SourceChanged

  MOVE.l comLong_DisplayLineOffset,D7 : ADD.l comLong_DisplayLine,D7
  CMP.l comLong_BlockStartY,D7
  BCS.w JL_0_387E
    BNE.w JL_0_386A
      JSR checkBeforeBlockStartX
      BNE.w JL_0_386A
        BRA.w JL_0_387E
    JL_0_386A:
    CMP.l comLong_BlockEndY,D7
      BHI.w JL_0_387E
      BNE.w setpointer_to_normal
        JSR checkBeforeBlockEndX
      BEQ.w setpointer_to_normal
  JL_0_387E:

  JSR JL_0_5524                               ; move to Blockbegin, returns pointer in A5
  MOVEA.l textbufferaddr,A2
  ADDA.w comWord_TextBufferOffset,A2
  MOVEA.l A2,A1
  MOVE.w comWord_ColumnsOffset,D2
  ADD.w comWord_Column,D2
  MOVEQ.l #$00,D1
  MOVEA.l comPtr_Temp_TokenString2,A0
  JL_0_389A:
  CMP.w D2,D1
  BCC.w JL_0_38AC
    MOVE.b (A1)+,D0
    ANDI.b #$7F,D0
    MOVE.b D0,(A0)+
    ADDQ.w #1,D1
    BRA.b JL_0_389A
  JL_0_38AC:
  MOVEM.l D1/A1,-(A7)
  JL_0_38B0:
    JSR JL_0_5630
    BMI.w JL_0_3982
    BEQ.w JL_0_38C8
      CMP.w #MAX_Columns,D1
      BCC.b JL_0_38B0
        MOVE.b D0,(A0)+
        ADDQ.w #1,D1
  BRA.b JL_0_38B0
  JL_0_38C8:

  CMP.w #MAX_Columns,D1
  BCC.w JL_0_38D8
    MOVE.b #$20,(A0)+
    ADDQ.w #1,D1
    BRA.b JL_0_38C8
  JL_0_38D8:

  MOVEA.l comPtr_Temp_TokenString2,A2
  JSR parse_line

  MOVE.l D5,D0                                      ; allocmem for sourceline-structentry
  ADDI.w #$9,D0
  JSR AllocPoolMem
  MOVEA.l D0,A0

  LEA $9(A0),A0
  MOVEA.l comPtr_Temp_TokenString1,A1
  JL_0_38FA:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_38FA
  MOVEA.l D0,A0

  JL_0_3900:
  ADDQ.l #1,comLong_TotalLines
  MOVE.b D5,$8(A0)
  MOVE.l $4(A4),D1
   BNE.w JL_0_3920
  MOVE.l A0,comPtr_FirstSourceLine
  CLR.l $4(A0)
 BRA.w JL_0_3928

JL_0_3920:
  MOVEA.l D1,A1
  MOVE.l A0,(A1)
  MOVE.l A1,$4(A0)
JL_0_3928:
  MOVE.l A0,$4(A4)
  MOVE.l A4,(A0)
  CMP.l comLong_BlockEndY,D6
   BCC.w JL_0_3968
  MOVEQ.l #$00,D0
  MOVE.b $8(A5),D0
  MOVE.w D0,D5
  ADDI.w #$9,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
   JSR AllocPoolMem
  MOVEA.l D0,A0
  MOVEM.l A0/A5,-(A7)
  LEA $9(A0),A0
  LEA $9(A5),A5
JL_0_395A:
  MOVE.b (A5)+,(A0)+
   BNE.b JL_0_395A
  MOVEM.l (A7)+,A0/A5
  ADDQ.l #1,D6
  MOVEA.l (A5),A5
 BRA.b JL_0_3900

JL_0_3968:
  MOVE.w comWord_DoTokenize,D0
   BEQ.w JL_0_3976
   JSR JL_0_553A
JL_0_3976:
  MOVEA.l comPtr_Temp_TokenString2,A0
  MOVEQ.l #$00,D5
  MOVEQ.l #$00,D1
 BRA.w JL_0_38B0

JL_0_3982:
  MOVEM.l (A7)+,D1/A1
JL_0_3986:
  CMP.w #MAX_Columns,D1
   BCC.w JL_0_399A
  MOVE.b (A1)+,D0
  ANDI.b #$7F,D0
  MOVE.b D0,(A0)+
  ADDQ.w #1,D1
 BRA.b JL_0_3986

JL_0_399A:
  CMPA.l comPtr_Temp_TokenString3,A0
   BCC.w JL_0_39A8
  MOVE.b #$20,(A0)+
 BRA.b JL_0_399A

JL_0_39A8:
   JSR tokenizeAndInsertNewLine
  MOVE.w comWord_ColumnsOffset,D0
  ADD.w comWord_Column,D0
  MOVE.l comLong_DisplayLineOffset,D7
  ADD.l comLong_DisplayLine,D7
  CMP.l comLong_BlockEndY,D7
   BHI.w JL_0_3A42
   BNE.w JL_0_39D0
  CMP.w comWord_BlockEndX,D0
   BHI.w JL_0_3A42
JL_0_39D0:
  MOVE.l comLong_BlockEndY,D1
  SUB.l comLong_BlockStartY,D1
  MOVE.w comWord_BlockEndX,D2
  ADDQ.w #1,D2
  CMP.w #MAX_Columns,D2
   BCS.w JL_0_39FA
  ADDQ.l #1,D1
  CMP.l comLong_BlockStartY,D7
   BCS.w JL_0_3A36
  SUB.w D0,comWord_BlockStartX
 BRA.w JL_0_3A36

JL_0_39FA:
  CMP.l comLong_BlockStartY,D7
   BCS.w JL_0_3A36
  CMP.l comLong_BlockEndY,D7
   BEQ.w JL_0_3A1C
  MOVE.w comWord_BlockEndX,D2
  SUB.w D0,D2
  ADDQ.w #1,D2
  ADD.w D2,comWord_BlockStartX
 BRA.w JL_0_3A32

JL_0_3A1C:
  MOVE.w comWord_BlockEndX,D2
  SUB.w comWord_BlockStartX,D2
  ADDQ.w #1,D2
  ADD.w D2,comWord_BlockStartX
  ADD.w D2,comWord_BlockEndX

  JL_0_3A32:
  JSR JL_0_7A14

  JL_0_3A36:
  ADD.l D1,comLong_BlockStartY
  ADD.l D1,comLong_BlockEndY
  JL_0_3A42:
  JSR update_currsourceline
  JSR _redraw
  !basic
  log_Print{"menu dublicate finished."}
Return


.menu_forget:
  log_Print{"menu forget called."}
  If Peek.l(?comLong_BlockEndY) = $ffffFFFF
    log_Print{"no block selected."}
    Gosub set_pointer_normal_bas
    Pop If : Return
  EndIf
  Gosub reset_Blockflag
  !asm
  JSR _redraw
  !basic
Return


.jump_to_keyword:                    ; A0 = pointer zieltextzeile
  MOVEA.l comPtr_FirstSourceLine,A1
  MOVEQ.l #00,D0
  MOVE.l comLong_TotalLines,D1 : SUBQ.l #1,D1
  BEQ 'exit
    CMPA.l A0,A1                       ; added to fix jump to line 1  tomsmart1
    BEQ 'match

   'loop
      CMPA.l $4(A0),A1
      BNE 'notmatch
        ADDQ.l #1,d0
       'match
        JMP jumpline
     'notmatch
      MOVEA.l (A1),A1
      ADDQ.l #1,D0
      SUBQ.l #1,D1
    BNE 'loop
    MOVEQ.l #-$01,D0
 'exit
RTS

.event_leftmousebutton:
;  log_Print{"event left mousebutton"}
  PED_GetMousePos{mousePos}
  If (mousePos\textY < 0) OR (mousePos\textY + Peek.l(?comLong_DisplayLineOffset) > Peek.l(?comLong_TotalLines))
    Return
  EndIf

  If Peek.l(?comLong_BlockEndY) <> $ffffFFFF     ; if blockmark is set, clear the block
    Gosub reset_Blockflag
    !asm
    JSR _redraw
    !basic
  EndIf
  oldBlockDims\xMin = Peek.w(?comWord_BlockStartX) ; why store the old block ?? it has been killed with the clause above
  oldBlockDims\yMin = Peek.l(?comLong_BlockStartY)
  oldBlockDims\xMax = Peek.w(?comWord_BlockEndX)
  oldBlockDims\yMax = Peek.l(?comLong_BlockEndY)

  Gosub cursor_off

  Poke.w ?comWord_LinePosStartX, mousePos\textX + Peek.w(?comWord_ColumnsOffset)
  If mousePos\textY + Peek.l(?comLong_DisplayLineOffset) < Peek.l(?comLong_TotalLines)
    Poke.l ?comLong_LinePosStartY, mousePos\textY + Peek.l(?comLong_DisplayLineOffset)
  Else
    Poke.l ?comLong_LinePosStartY, Peek.l(?comLong_TotalLines)-1
  EndIf
  Poke.w ?comWord_LinePosEndX, Peek.w(?comWord_LinePosStartX)
  Poke.l ?comLong_LinePosEndY, Peek.l(?comLong_LinePosStartY)

  Gosub update_scrollers

  storeDisplayLineOffset.l = Peek.l(?comLong_DisplayLineOffset)
  storeColumnsOffset.w = Peek.w(?comWord_ColumnsOffset)
  storeCurrentSourceLine.l = ped\ptrCurrentSourceData\CurrentSourceLine

  ;log_Print{"initial block draw"}
  Poke.w ?comWord__AL_0_86B8, 0
  storeX.w = mousePos\textX + Peek.w(?comWord_ColumnsOffset)
  storeY.l = mousePos\textY

  bmark\xMin = storeX
  bmark\yMin = storeY
  bmark\xMax = storeX
  bmark\yMax = storeY
  AbsDimensions{bmark}
  PED_DrawBlock{bmark, Peek.w(?comWord_ColumnsOffset)}

  exit_mouse_loop.b = False
  Repeat
    PED_GetMessage{True}

    If pedMessage\_Class <> 0
      If pedMessage\_Code = #SELECTUP
        mqualifier.w = pedMessage\_Qualifier
        If (mqualifier AND #IEQUALIFIER_RSHIFT) Then mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
        If (mqualifier AND #IEQUALIFIER_RALT) Then mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
        exit_mouse_loop = True
      Else
        PED_GetMousePos{mousePos}

        If mousePos\textY => 0
          Gosub mouse_scrollno
        Else
          If mousePos\Y <= \BoxTop
            Gosub mouse_scrollup
          Else
            If Peek.l(?viewablelines) + Peek.l(?comLong_DisplayLineOffset) <= Peek.l(?comLong_TotalLines)
              Gosub mouse_scrolldown
            EndIf
          EndIf
        EndIf
      EndIf
    EndIf
  Until exit_mouse_loop

  Gosub mouseclick_in_source
Return


.mouse_scrolldown:
  ;log_Print{"scroll down"}
  tmpX.w = #MAX_Columns               ;D2
  tmpY.l = Peek.l(?viewablelines) - 1 ;D3

  If Peek.l(?comLong_DisplayLineOffset) + Peek.l(?viewablelines) <= Peek.l(?comLong_TotalLines)
    PED_ScrollVertical{#SCROLL_UP}

    *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine\nextLine
    Poke.l ?comLong_DisplayLineOffset, Peek.l(?comLong_DisplayLineOffset) + 1

    Gosub draw_new_sourceline_bottom

    storeY - 1

    If tmpY + Peek.l(?comLong_DisplayLineOffset) <= Peek.l(?comLong_LinePosStartY)
      bmark\xMin = #MAX_Columns
      bmark\yMin = Peek.l(?viewablelines) - 2
      bmark\xMax = storeX
      bmark\yMax = storeY
      PED_DrawBlock{bmark, Peek.w(?comWord_ColumnsOffset)}
      storeX = #MAX_Columns
      storeY = Peek.l(?viewablelines) - 1
      If tmpY + Peek.l(?comLong_DisplayLineOffset) = Peek.l(?comLong_LinePosStartY)
        storeX = Peek.l(?comWord_LinePosStartX) - 1
      EndIf
      tmpX = -1
      tmpY = storeY

    EndIf

  EndIf

  Gosub update_blockmark
Return

.mouse_scrollup:
  ;log_Print{"scroll up"}
  tmpX.w = 0  ;D2
  tmpY.l = 0  ;D3

  If Peek.l(?comLong_DisplayLineOffset) > 0
    PED_ScrollVertical{#SCROLL_DOWN}

    *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine\previousLine
    Poke.l ?comLong_DisplayLineOffset, Peek.l(?comLong_DisplayLineOffset) - 1

    Gosub draw_new_sourceline_top

    storeY + 1

    If Peek.l(?comLong_DisplayLineOffset) >= Peek.l(?comLong_LinePosStartY)
      bmark\xMin = 0
      bmark\yMin = 1
      bmark\xMax = storeX
      bmark\yMax = storeY
      PED_DrawBlock{bmark, Peek.w(?comWord_ColumnsOffset)}
      tmpX = #MAX_Columns
      tmpY = 0
      storeX = -1
      storeY = 0
      If Peek.l(?comLong_DisplayLineOffset) = Peek.l(?comLong_LinePosStartY)
        storeX = Peek.l(?comWord_LinePosStartX) - 1
      EndIf

    EndIf

  EndIf

  Gosub update_blockmark
Return

.mouse_scrollno:
;  log_Print{"scroll no"}
  tmpX = mousePos\textX + Peek.w(?comWord_ColumnsOffset)     ; >D2
  tmpY = mousePos\textY ; >D3
  If tmpY + Peek.l(?comLong_DisplayLineOffset) > Peek.l(?comLong_TotalLines)
    tmpY = Peek.l(?comLong_TotalLines) - Peek.l(?comLong_DisplayLineOffset) - 1
  EndIf

  If mousePos\X = 0        ; mouse is left of source, scroll to right if not at column 1
    tmpX - 1
    If Peek.w(?comWord_ColumnsOffset) > 0
      tmpX - 1
      Poke.w ?comWord_LinePosEndX, storeX
      Poke.l ?comLong_LinePosEndY, storeY + Peek.l(?comLong_DisplayLineOffset) ; mousePos\textY

      Poke.w ?comWord_BlockStartX, Peek.w(?comWord_LinePosStartX)
      Poke.l ?comLong_BlockStartY, Peek.l(?comLong_LinePosStartY)
      Poke.w ?comWord_BlockEndX, Peek.w(?comWord_LinePosEndX)
      Poke.l ?comLong_BlockEndY, Peek.l(?comLong_LinePosEndY)
      Gosub AbsBlockDimensions_bas

      Poke.w ?comWord_ColumnsOffset, Peek.w(?comWord_ColumnsOffset) - \scrollSize
      Gosub scroll_right
      Gosub reset_Blockflag
    EndIf
  Else            ; scroll to left if where are not at the rightmost column
    If (mousePos\textX - Peek.w(?comWord_ColumnsOffset)) => Peek.w(?visiblecolumns)
      tmpX = Peek.w(?comWord_ColumnsOffset) + Peek.w(?visiblecolumns)
      If tmpX < #MAX_Columns
        tmpX + 1
        Poke.w ?comWord_LinePosEndX, mousePos\textX
        Poke.l ?comLong_LinePosEndY, mousePos\textY + Peek.l(?comLong_DisplayLineOffset)

        Poke.w ?comWord_BlockStartX, Peek.w(?comWord_LinePosStartX)
        Poke.l ?comLong_BlockStartY, Peek.l(?comLong_LinePosStartY)
        Poke.w ?comWord_BlockEndX, Peek.w(?comWord_LinePosEndX)
        Poke.l ?comLong_BlockEndY, Peek.l(?comLong_LinePosEndY)
        Gosub AbsBlockDimensions_bas

        Poke.w ?comWord_ColumnsOffset, Peek.w(?comWord_ColumnsOffset) + \scrollSize
        Gosub scroll_left
        Gosub reset_Blockflag
      EndIf
    EndIf
  EndIf

  Gosub update_blockmark
Return

.update_blockmark:
      If (storeX = mousePos\textX) AND (storeY = mousePos\textY)
        Return
      EndIf
      ;log_Print{"update block ..."}

      Gosub update_scrollers

      ;msg$ = "tmpX: " + Str$(tmpX) + ", tmpY: " + Str$(tmpY)
      ;log_Print{msg$}
      Poke.w ?comWord_LinePosEndX, tmpX
      If tmpY + Peek.l(?comLong_DisplayLineOffset) < Peek.l(?comLong_TotalLines)
        Poke.l ?comLong_LinePosEndY, tmpY + Peek.l(?comLong_DisplayLineOffset)
      EndIf

      If Peek.l(?comLong_LinePosEndY) <= Peek.l(?comLong_LinePosStartY)
        ;log_Print{"lineposendy < lineposstarty " + Str$(storeY)}
        If (Peek.l(?comWord_LinePosEndX) => Peek.l(?comWord_LinePosStartX)) OR (Peek.l(?comLong_LinePosEndY) = Peek.l(?comLong_LinePosStartY))
          If Peek.w(?comWord__AL_0_86B8) = 0
            bmark\xMin = storeX
            bmark\yMin = storeY
            bmark\xMax = tmpX
            bmark\yMax = tmpY
            storeX = tmpX
            storeY = tmpY
            AbsDimensions{bmark}
            bmark\xMin + 1
            PED_DrawBlock{bmark, Peek.w(?comWord_ColumnsOffset)}
            Return
          EndIf
        Else
          Goto other_path
        EndIf
      Else
        other_path:
        ;log_Print{"lineposendy > lineposstarty"}
        If Peek.w(?comWord__AL_0_86B8) = 0
          bmark\xMin = storeX
          bmark\yMin = storeY
          bmark\xMax = tmpX
          bmark\yMax = tmpY
          storeX = tmpX
          storeY = tmpY
          AbsDimensions{bmark}
          bmark\xMax - 1
          PED_DrawBlock{bmark, Peek.w(?comWord_ColumnsOffset)}
          Return
        EndIf
      EndIf

      ;------------------------------------------------------------------------
      log_Print{"mouseclick in same line"}
      Poke.w ?comWord__AL_0_86B8, NOT Peek.w(?comWord__AL_0_86B8)

      bmark\xMax = storeX
      bmark\yMax = storeY
      bmark\xMin = Peek.w(?comWord_LinePosStartX)
      bmark\yMin = Peek.l(?comLong_LinePosStartY) - Peek.l(?comLong_DisplayLineOffset)
      If bmark\yMin < 0
        bmark\xMin = 0
        bmark\yMin = 0
      Else
        If bmark\yMin >= Peek.l(?viewablelines)
          bmark\yMin = Peek.l(?viewablelines) - 1
          bmark\xMin = #MAX_Columns - 1
        EndIf
      EndIf
      ;obx.w = bmark\xMin
      ;oby.l = bmark\yMin
      PED_DrawBlock{bmark, Peek.w(?comWord_ColumnsOffset)}

      ;bmark\xMin = obx
      ;bmark\yMin = oby
      bmark\xMax = tmpX
      bmark\yMax = tmpY
      PED_DrawBlock{bmark, Peek.w(?comWord_ColumnsOffset)}

      storeX = tmpX
      storeY = tmpY
Return


.mouseclick_in_source:
;  log_Print{"mousebutton released in source, qualifier: " + Hex$(mqualifier) }
  Poke.l ?comLong_DisplayLineOffset, storeDisplayLineOffset
  Poke.w ?comWord_ColumnsOffset, storeColumnsOffset
  ped\ptrCurrentSourceData\CurrentSourceLine = storeCurrentSourceLine

  Poke.l ?comLong_DisplayLineOffsetStore, Peek.l(?comLong_DisplayLineOffset)
  sourceWindow\ColumnsOffsetStore = Peek.w(?comWord_ColumnsOffset)

  tempX.w = Peek.w(?comWord_LinePosEndX)
  If tempX < 1
    If Peek.l(?comLong_LinePosEndY) > Peek.l(?comLong_LinePosStartY)
      Poke.l ?comLong_LinePosEndY, Peek.l(?comLong_LinePosEndY) - 1
      Goto jump_crude
    Else
      tempX = 0
    EndIf
  EndIf
  If tempX > #MAX_Columns
    jump_crude:
    tempX = #MAX_Columns - 1
  EndIf
  Poke.w ?comWord_LinePosEndX, tempX

  msg$ = "LinePosStartX " + Str$(Peek.w(?comWord_LinePosStartX)) + ", "
  msg$ + Str$(Peek.l(?comLong_LinePosStartY))  + " - "
  msg$ + Str$(Peek.w(?comWord_LinePosEndX)) + ", "
  msg$ + Str$(Peek.l(?comLong_LinePosEndY))
  log_Print{msg$}

  ;-- todo: add hardfold support (compare with old asm code at this place!
  Poke.l ?foldnum,0

  ;-- set cursor position to beginning of block mark
  Poke.w ?comWord_Column, Peek.w(?comWord_LinePosStartX) - Peek.w(?comWord_ColumnsOffset)

  *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  tempY.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
  While Peek.l(?comLong_LinePosStartY) <> tempY
    If Peek.l(?comLong_LinePosStartY) > tempY
      *tempLine = *tempLine\nextLine
      tempY + 1
    Else
      *tempLine = *tempLine\previousLine
      tempY - 1
    EndIf
  Wend
  tempY = tempY - Peek.l(?comLong_DisplayLineOffset)
  Poke.l ?comLong_DisplayLine,tempY
  ped\ptrCurrentSourceData\CurrentSourceLine = *tempLine
  Gosub update_TextBufferOffset


  ; if a block is marked, then quit routine
  If (Peek.w(?comWord_LinePosStartX) <> Peek.w(?comWord_LinePosEndX)) OR (Peek.l(?comLong_LinePosStartY) <> Peek.l(?comLong_LinePosEndY))
      ;log_Print{"LinePosEnd  equals not LinePosStart"}

      Poke.w ?comWord_BlockStartX, Peek.w(?comWord_LinePosStartX)
      Poke.l ?comLong_BlockStartY, Peek.l(?comLong_LinePosStartY)
      Poke.w ?comWord_BlockEndX, Peek.w(?comWord_LinePosEndX)
      Poke.l ?comLong_BlockEndY, Peek.l(?comLong_LinePosEndY)
      Gosub AbsBlockDimensions_bas
      Gosub update_horizscroller
      !asm
      JSR _redraw
      !basic
      Return
  EndIf

  ; it was just a click...
  ; log_Print{"just a click, no block marked."}
  Poke.w ?comWord_BlockStartX, oldBlockDims\xMin
  Poke.l ?comLong_BlockStartY, oldBlockDims\yMin
  Poke.w ?comWord_BlockEndX, oldBlockDims\xMax
  Poke.l ?comLong_BlockEndY, oldBlockDims\yMax

;  msg$ = "Blockdimensions:" + Chr$(10)
;  msg$ + Str$(Peek.w(?comWord_BlockStartX)) + ", "
;  msg$ + Str$(Peek.l(?comLong_BlockStartY))  + " - "
;  msg$ + Str$(Peek.w(?comWord_BlockEndX)) + ", "
;  msg$ + Str$(Peek.l(?comLong_BlockEndY))
;  log_Print{msg$}

  ; -- check if some keys are pressed aswell
  If mqualifier AND #IEQUALIFIER_LSHIFT                 ; lshift or rshift
;    log_Print{">> SHIFT pressed aswell!"}
    ped\blockmarkRemovalMode = 1 : Gosub handle_blockmark

    ;-- whatfor is this ? the block is deleting right one line up!
    ;If Peek.l(?comLong_BlockStartY) <= Peek.l(?comLong_LinePosStartY)
    ;  If Peek.l(?comLong_BlockEndY) => Peek.l(?comLong_LinePosStartY)
    ;    If Peek.l(?comLong_BlockStartY) = Peek.l(?comLong_LinePosStartY) AND Peek.w(?comWord_BlockStartX) <= Peek.w(?comWord_LinePosStartX)
    ;      If Peek.l(?comLong_BlockEndY) = Peek.l(?comLong_LinePosStartY) AND Peek.w(?comWord_BlockEndX) <= Peek.w(?comWord_LinePosStartX)
    ;        Poke.l ?comLong_BlockEndY, $ffffFFFF
    ;      EndIf
    ;    EndIf
    ; EndIf
    ;EndIf
  Else                                                  ; enhance the block
    Poke.w ?comWord_BlockEndX, Peek.w(?comWord_LinePosEndX)
    Poke.l ?comLong_BlockStartY, Peek.l(?comLong_LinePosStartY)
  EndIf

  If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
    If mqualifier AND #IEQUALIFIER_LALT                ; LeftAlt or RightAlt
 ;     log_Print{">> ALT pressed aswell!"}
      Gosub jump_onclick
    Else
      !asm
      JSR _redraw
      !basic
    EndIf
  Else
    If Peek.l(?comLong_DisplayLineOffset) <> Peek.l(?comLong_DisplayLineOffsetStore)
      !asm
      JSR _redraw
      !basic
    Else
      If Peek.w(?comWord_ColumnsOffset) <> sourceWindow\ColumnsOffsetStore
        !asm
        JSR _redraw
        !basic
      Else
        If mqualifier AND #IEQUALIFIER_LALT ;$30
          Gosub jump_onclick
        Else
          !asm
          JSR _redraw
          !basic
        EndIf
      EndIf
    EndIf
  EndIf
Return

.menu_gotoline:                      ;goto line
  Gosub set_pointer_busy_bas
  WZ_LockAllOpenWindows{}                                                                                                                                                                                                                                
  WZWindow WZID("WIN_GOTO"),?wzgui,32,-2,-2,-2,-2,WZID("WIN_GOTO")
  Use Window WZID("WIN_GOTO")
  WZ_ActivateGadget{"GOTO_LINE"}   ; replaced to use the statement  tomsmart1 2012 03 09                                                                                                                                                                 
  exit_goto.b = False

  Repeat
    ev.l = WaitEvent
    Select ev

      Case #IDCMP_IDCMPUPDATE
        If WZGadName = "GOTO_LINE"
          _line.l = Abs(WZInput("GOTO_LINE")) - 1
           If _line >= 0                                   ; fixed so we can jump to line 1  tomsmart1
             lineNum.l = _line : clearColumn.b = True : Gosub gotoline
           EndIf
          exit_goto = True
        EndIf

      Case #IDCMP_CLOSEWINDOW
        _line = -1
        exit_goto = True

    End Select

  Until exit_goto

  WZCloseWindow WZID("WIN_GOTO")

  WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                              
  Gosub set_pointer_normal_bas
  Gosub activatesourcewindow
RTS


store_BlockStartX:        Dc.b $FF,$FF

.set_blockstart:                     ; D0: Startposition
  MOVE.w D0,store_BlockStartX
  MOVE.l comLong_DisplayLineOffset,D0 : ADD.l comLong_DisplayLine,D0
  MOVE.l D0,comLong_BlockStartDisplayLine
RTS

.set_blockend:                       ; D0: Position
  MOVE.w store_BlockStartX,D2
  BMI.w JUMP_setpointer_to_normal

  MOVE.l D0,-(a7)
  MOVE.w D0,comWord_BlockStartX
  MOVE.l comLong_BlockStartDisplayLine,D3
  MOVE.l comLong_DisplayLineOffset,D1 : ADD.l comLong_DisplayLine,D1
  MOVE.l (a7)+,D0

  ;MOVE.w comWord_ColumnsOffset,D0 :  ADD.w comWord_Column,D0
  CMP.w D0,D2
  BNE.w JL_0_42D8
    CMP.l D1,D3
    BNE.w JL_0_42D8
      !basic
      Gosub reset_Blockflag
      !asm
      JMP _redraw
  JL_0_42D8:

  TST.w D0                ; Column
  BNE.w JL_0_42EA
    TST.l D1              ; Line
    BEQ.w JL_0_42EA
;      CMP.l D1,D3          ; if StartY < EndY
;      BCC JL_0_42EAb       ; skip it
        SUBQ.l #1,D1
        MOVE.w #MAX_Columns,D0
;        BRA JL_0_42EA
;      JL_0_42EAb:
;        SUBQ.l #1,D3
;        MOVE.w #MAX_Columns,D0
  JL_0_42EA:

  MOVE.w D0,comWord_BlockEndX
  MOVE.l D1,comLong_BlockEndY
  MOVE.w D2,comWord_BlockStartX
  MOVE.l D3,comLong_BlockStartY

  ;  JSR AbsBlockDimensions
  !basic
  Gosub AbsBlockDimensions_bas
  !asm

JMP _redraw

.menu_closewb:
  If NOT CloseWorkBench_
    log_Print{"Could not close the Workbench due to open windows...",#log_warning}
  Else
    log_Print{"Workbench successfully closed."}
  EndIf
Return

.menu_openwb:
  If OpenWorkBench_ = 0
    log_Print{"Could not open the Workbench...",#log_error}
  EndIf
  ScreenToFront_ sourceWindow\pedScreen
  ActivateWindow_ sourceWindow\win
Return

.menu_newshell:
  If pedconfig\use_wbscreen <> 0
    WBenchToFront_
    exescr$ = "Workbench"
  Else
    exescr$ = ped\defaultPubscreenName
  EndIf
  exe.s = "NEWCLI WINDOW = \\22"+pedconfig\console_device + "///196/AmiBlitz Shell/CLOSE/SCREEN "+exescr$+"\\22"   ; use select Consoledevice for Shell
  Execute_ &exe,0,0
Return

CLI_input_stream:  Ds.l 1
CLI_output_stream: Ds.l 1
CLI_output_file:   Ds.l 1
Even

.console_open:
  MOVEM.l A2-A3,-(A7)

  SUBA.l A1,A1
  MOVEA.l _execbase,A6
  JSR _FindTask(A6)
  MOVEA.l D0,A3
  MOVE.l $9C(A3),CLI_input_stream
  MOVE.l $A0(A3),CLI_output_stream

  !basic
  ;log_Print{"search current task..."}
  ;*exeProcess.Process = FindTask_(0)
  ;log_Print{"I am task with num "  + Hex$(*exeProcess)}
  ;Poke.l ?CLI_input_stream,  *exeProcess\pr_CIS
  ;Poke.l ?CLI_output_stream, *exeProcess\pr_COS
  console_dontclose.l = False
  If pedconfig\console_wb = True Then WBenchToFront_

  ; -- if the console_settings are n/a, set them to something usefull
  USEPATH wtemp
  If \console_h = 0
    \console_x = 0
    \console_y = *myscreen\BarHeight * 2
    \console_w = *myscreen\Width / 3
    \console_h = *myscreen\Height / 3
  EndIf

  ; -- build the window path for opening the con:-device
  Format ""
  con_windowpath.s = Trim$(dos_PathPart{pedconfig\console_device})
  If con_windowpath = "" Then con_windowpath = "CON:"
  con_windowpath + Str$(\console_x)
  con_windowpath + "/"+Str$(\console_y)
  con_windowpath + "/"+Str$(\console_w)
  con_windowpath + "/"+Str$(\console_h)
  con_windowpath + "/" + pedconfig\console_title
  con_windowpath + "/ZOOM"
  If pedconfig\console_wb = True OR (screen_GetModeID{}=#scr_mode_wb_use)
    con_windowpath + "/SCREEN Workbench"
  Else
    con_windowpath + "/SCREEN " + screen_GetTitle{}
  EndIf

  If pedconfig\console_device = "VNC:"
    con_windowpath + "/DRAG/QUIET/NOCLOSE/NOBUTTONS"
    If pedconfig\console_font <> "" Then con_windowpath + "/FONT" + pedconfig\console_font
  EndIf
;  If console_wait = True
;    con_windowpath$ + "/CLOSE"
;    con_windowpath$ + "/WAIT"
;  EndIf

  con_windowpath + Chr$(0)
  If Peek.l(?CLI_output_file) = 0
    log_Print{"opening console: " + con_windowpath}

    Poke.l ?CLI_output_file, Open_(&con_windowpath,#HUNK_RELOC_8__MODE_NEWFILE)
  Else
    log_Print{"console is already open..."}
  EndIf
  ;If Peek.l(?CLI_output_file) <> 0
  ;  *exeProcess\pr_CIS = Peek.l(?CLI_output_file)
  ;  *exeProcess\pr_COS = Peek.l(?CLI_output_file)
  ;EndIf
  !asm

  MOVE.l CLI_output_file,D0
  BEQ.w JL_0_442A
    MOVE.l D0,$9C(A3) ; pr_CIS
    MOVE.l D0,$A0(A3) ; pr_COS
  JL_0_442A:
  MOVEM.l (A7)+,A2-A3
RTS

.console_close:
  SUBA.l A1,A1
  MOVEA.l _execbase,A6
  JSR _FindTask(A6)
  MOVEA.l D0,A3
  MOVE.l CLI_input_stream,$9C(A3)
  MOVE.l CLI_output_stream,$A0(A3)

  !basic
  ;log_Print{"console close"}
  ;*exeProcess.Process = FindTask_(0)
  ;*exeProcess\pr_CIS = Peek.l(?CLI_input_stream)
  ;*exeProcess\pr_COS = Peek.l(?CLI_output_stream)
                                                                                                                                                                                                                                                        
  If pedconfig\console_wb   = True Then WBenchToFront_
  If pedconfig\console_wait = True
    txt$ = Chr$(27) + "[1m"              ; make text bold via escape-sequence
    txt$ + Chr$(27) + "["+Str$(30+3)+"m" ; change textcolor
    txt$ + Chr$(10) + !TRANS{"Program terminated."}
    txt$ + Chr$(10) + !TRANS{"Press <ENTER> to return to AmiBlitz3..."}
    Write_ Peek.l(?CLI_output_file),&txt$,FLen(txt$)
    Flush_ Peek.l(?CLI_output_file)

    If KickVersion(39) Then SetWindowPointerA_ sourceWindow\win, Tags(#WA_BusyPointer,$FFFFffff, #TAG_END,0)

    log_Print{"console close: waiting for input..."}
    console_dummy.b = 0
    ; (CheckWindow{console_title$} = True)
    While Read_(Peek.l(?CLI_output_file),&console_dummy,1) = 0
      Delay_ 2
    Wend
  EndIf
  log_Print{"closing console"}
  Close_ Peek.l(?CLI_output_file) : Poke.l ?CLI_output_file,0
  If KickVersion(39) Then SetWindowPointerA_ sourceWindow\win, Tags(#WA_Pointer, Null, #TAG_END,0)

  Gosub activatesourcewindow
  If pedconfig\console_wb = True Then ScreenToFront_ sourceWindow\pedScreen
  !asm
RTS

.log_print: ;A1: pointer to string, D0: optional value
 MOVEM.l a1/d0-d2,-(a7)
 !basic
 MOVEM.l (a7)+,a1/d0-d2
 PutReg D0, log_value0.l
 PutReg D2, log_value1.l
 PutReg A1, ptr_logtext.l : strline.s = Peek.s(ptr_logtext)
 Format "####0"

 If log_value0 > 255
   logmess.s = "syslib  : "
 Else
   logmess.s = "blitzlib: "
 EndIf
 MaxLen linebuff$ = 256
 preproc_Detokenize{*PreProcessor,&strline,&linebuff$,FLen(strline)} : strline.s = StripTrail$(Peek.s(&linebuff$),$20)
 log_Print{logmess + Str$(log_value0) + ": " + StrLeft(PED_GetLibname{log_value0},20) + "/" + Str$(log_value1)+ ": " + Left$(strline,16)}
 Format ""
 !asm
RTS


.com_0_44E2:
  MOVEA.l A0,A2
  MOVEQ.l #$00,D1

 JL_0_44E6:
    ADDQ.w #1,D1
    TST.b (A0)+
  BNE.b JL_0_44E6

  MOVEA.l A2,A1
  SUBQ.w #1,D1
  BPL.w JUMP_tokenizeA1
RTS

JUMP_tokenizeA1:
JMP tokenizeA1


;TokenizeSource:
;  MOVE.w comWord_DoTokenize,D0
;  BNE.w JUMP_setpointer_to_normal
;
;  NOT.w comWord_DoTokenize
;  MOVEA.l comPtr_FirstSourceLine,A4
;  MOVE.l comLong_TotalLines,-(A7)
;
; JL_0_450E:
;    MOVEQ.l #$00,D1
;    MOVE.b $8(A4),D1
;    SUBQ.w #1,D1
;    BMI.w JL_0_4530
;      LEA $9(A4),A2
;      MOVEA.l comPtr_Temp_TokenString1,A1
;      JSR tokenizeA1
;      MOVE.l A4,comPtr_CurrentSourceLine
;      JSR replaceCurrentLine
;    JL_0_4530:
;    MOVEA.l (A4),A4
;    SUBQ.w #1,(A7)
;  BNE.b JL_0_450E
;
;  ADDQ.w #2,A7
;BRA.w JL_0_458E
;
;
;DetokenizeSource:
;  MOVE.w comWord_DoTokenize,D0
;   BEQ.w JUMP_setpointer_to_normal
;  CLR.w comWord_DoTokenize
;
; JL_0_454C:
;  MOVEA.l comPtr_FirstSourceLine,A4
;  MOVE.l comLong_TotalLines,-(A7)
;
; JL_0_4554:
;    LEA $9(A4),A0
;    MOVEA.l comPtr_Temp_TokenString1,A1
;    JSR detokenize_line
;    SUBA.l comPtr_Temp_TokenString1,A1
;    ADDQ.w #1,A1
;    MOVE.l A1,D5
;    MOVE.l A4,comPtr_CurrentSourceLine
;    JSR replaceCurrentLine
;    MOVEA.l (A4),A4
;    SUBQ.w #1,(A7)
;  BNE.b JL_0_4554
;  ADDQ.w #2,A7
;RTS
;
;
;JL_0_457C:
;  MOVE.w comWord_DoTokenize,D0
;   BEQ.w JUMP_setpointer_to_normal
;  CLR.w comWord_DoTokenize
;  BSR.b JL_0_454C
;
; JL_0_458E:
;  JSR update_currsourceline
;JMP _redraw
;
JUMP_setpointer_to_normal:
JMP setpointer_to_normal

.update_labellist:
  CLR.l numcount
  !basic
  InitArgParse search_label$
  word1$ = NextArg$
  word2$ = NextArg$
  MOVE.b #0,searchmode
  t.l = 0
  If word2$<>""
    t = 1
    MOVE.b #1,searchmode
  End If
  search_label$ = search_label$
  skip.l = 0
  MOVE.l (a2),straddr
  !asm
  MOVEA.l comPtr_FirstSourceLine,A0
  MOVE.l comLong_TotalLines,D0
  MOVE.b comByte_LabelIdentifier,D1
  MOVE.l A1,-(A7)

  TST.w comWord_LabelAll
  BNE alladd

  TST.w comWord_LabelRemark
  BNE click_remark

  ; loop the source
  JL_0_467C:
    LEA $9(A0),A1

    JL_0_4680:
    CMPI.b #$20,(A1)                   ;space
    BNE.b 'no
      ADDQ.l #1,a1
      BRA JL_0_4680
   'no
    CMP.w ##TOKEN_Stop,(a1)
    BEQ 'l20
    CMP.w ##TOKEN_TRAP,(a1)
    BEQ 'l20
    CMP.w ##TOKEN_Macro,(a1)          ; added to show Macros in labellist  tomsmart1
    BNE 'nomacro                      ; no, macro
      MOVE.b #2,is_stat_func_macro      ; yes, set it to 2 to identify as macro
      ADDQ.l #2,a1                      ; add 2 to position to get the macroname
      BRA 'l20
   'nomacro
    CMP.w ##TOKEN_Statement,(a1)
    BNE 'nex
      ADDQ #3,a1
      MOVE.l a1,-(a7)
      !skipspace a1
      CMP.w ##TOKEN_Return,(a1)
      BNE 'ok
        MOVE.l (a7)+,a1
        BRA 'nex
     'ok
      MOVE.l (a7)+,a1
      MOVE.b #1,is_stat_func_macro        ; set it to 1 to identify it as Statement or Function
      BRA 'l20
   'nex
    CMP.w ##TOKEN_Function,(a1)
    BNE 'nex2
      ADDQ #3,a1
      MOVE.l a1,-(a7)
      !skipspace a1
      CMP.w ##TOKEN_Return,(a1)
      BNE 'ok
        MOVE.l (a7)+,a1
   'nex2
    CMP.b (A1),D1
    BNE.w JL_0_4696

   'l10
    ADDQ.l #1,a1
    TST.b (a1)
    BEQ JL_0_4696

   'l20
    !skipspace a1
    CMP.b #".",-1(a1)
    BNE 'noformat

   'lnewtype                       ; added to support correct display the name of newtype functions in the labellist  tomsmart1
    ADDQ.l #1,a1                   ; pos +1
    CMP.b #1,is_stat_func_macro    ; test if we have a Statement or Function
    BNE 'nostatfunc                ; no, skip
    CMP.b #" ",(a1)                ; yes, test if it a space
    BNE 'lnewtype                  ; no, we have a newtype
                                   ; yes, end of the functiontype
   'nostatfunc
    !skipspace a1

   'noformat
    CMP.l #"FAST",(a1)
    BNE 'nf
      CMP.b #" ",4(a1)
      BNE 'nf
        ADDQ.l #5,a1
   'nf
   !regs2stack
   !basic
   ped\LabelListChanged = True
   !asm
   !stack2regs
   ;MOVE.w D1,comWord_LabelListChanged
    JSR JL_0_46D6

    JL_0_4696:
    MOVEA.l (A0),A0
    SUBQ .l #1,d0
  BNE JL_0_467C

  MOVEA.l (A7)+,A1
RTS

.alladd
  MOVEM.l d2-d3/a2/a3,-(a7)

  MOVE.l comLong_TotalLines,D0

.click_all
  MOVE.b comByte_LabelIdentifier,D1
  MOVEQ #0,d3
  MOVE.l lowerchartable,a3
 'l15
  MOVE.b #";",d1
  LEA $9(A0),A1
  TST.b (a1)
  BEQ 'nowrite

 'lc1
    CMP.b #" ",(a1)
    BNE 'l1
      ADDQ.l #1,a1
  BRA 'lc1
 'l1

  MOVE.l a1,straddr2
  CMP.b #".",(a1)
  BNE 'l1b
    ADDQ.l #1,a1
    ;BRA 'addlist
 'l1b

  CMP.w ##TOKEN_Stop,(a1)
  BEQ 'addstop
    CMP.w ##TOKEN_TRAP,(a1)
    BEQ 'addstop
      MOVE.l straddr,a2
      CLR.l slen2
 'cok
  MOVE.b (a2)+,d2
  BEQ 'addlist
 'cf
  MOVE.b (a1)+,d3
  TST.b searchmode
  BEQ 'nopat
    BRA 'addlist
 'nopat

  TST.b d3
  BEQ 'nowrite
    TST.b casemode
    BEQ 'lca1
      MOVE.b 0(a3,d3.w),d3            ; convert character to lowercase
 'lca1

  ADD.l #1,slen2
  CMP.b d2,d3
  BEQ 'cok
  MOVE.l slen2,a2
  SUBQ.l #1,a2
  SUB.l a2,a1
  CLR.l slen2
  MOVE.l straddr,a2
  BRA 'cok
 'addstop
  MOVEM.l a0/d0,-(a7)
  MOVE.l a0,d0
  !basic
  s.l = PutD0
  WZTags #WENTRYA_TextPen,2
  s$ = " --Breakpoint---"
  WZListAdd list_labels,s$,0,s
  !asm
  MOVEM.l (a7)+,d0/a0
  BRA 'nowrite
 'v1
 'addlist
  CMP.l #maxlabels,numcount          ;reduce this for slower computers
  BGE 'nowrite
  MOVEM.l a0/d0,-(a7)
  MOVE.l a0,d0
  !basic
  s.l = PutD0
  MOVE.l straddr2,a1
  ;SUB.l slen2,a1
  ;SUBQ.l #5,a1
  MOVE.l a1,a0
  MOVE.l expandstore,a1
  JSR detokenize_line
  MOVE.l expandstore,d0
  i = PutD0
  If i Then s$ = Peek$(i) : Else s$="!NULL!"
   If t
     If Instr(s$,word1$)
         If Instr(s$,word2$)
           WZListAdd list_labels,s$,-1,s
           ADDQ.l #1,numcount
         End If
     End If
   Else
     WZListAdd list_labels,s$,-1,s
     ADDQ.l #1,numcount
   End If

  ADDQ.w #1,comWord_LabelCounter
  !asm
  MOVEM.l (a7)+,d0/a0
 'l15b
 'nowrite
  MOVEA.l (A0),A0
  SUBQ.l #1,d0
  BNE 'l15
 'out
  MOVEM.l (a7)+,d2-d3/a2/a3
  MOVEA.l (A7)+,A1
RTS

.click_remark
  CLR.b instring
  MOVE.b #";",d1
  LEA $9(A0),A1
  TST.b (a1)
  BEQ 'nowrite
'l1  CMP.b #" ",(a1)
  BNE 'l1b
  ADDQ.l #1,a1
  BRA 'l1
'l1b

'co
  CMP.b #".",(a1)
  ;BEQ 'addlist
  CMP.b #$22,(a1)
  BNE 'is1
  NOT.b instring

 'is1
  CMP.w ##TOKEN_Stop,(a1)
  BEQ 'addlist
  CMP.w ##TOKEN_Case,(a1)
  BNE 'l10
  MOVE.l a0,-(a7)
  MOVE.l straddr,a0
  CMP.l #"Case",(a0)
  BNE 'l10a
  !basic
  skip = 1
  !asm
  MOVE.l (a7)+,a0
  ADDQ.l #3,a1
  BRA 'addlist
 'l10a
  MOVE.l (a7)+,a0
 'l10
  CMP.b (a1),d1
  BNE 'skip
 'l5
  ADDQ.l #1,a1
  TST.b instring
  BNE 'nowrite
  TST.b (a1)
  BEQ 'nowrite
  CMP.b #".",(a1)
  BEQ 'nowrite
 'l1s
  CMP.b #" ",(a1)
  BNE 'l1bs
  ADDQ.l #1,a1
  BRA 'l1s
 'l1bs
 'addlist
  CMP.l #maxlabels,numcount          ;reduce this for slow computer
  BGE 'out
  !regs2stack
  !basic
  ped\LabelListChanged = True
  !asm
  !stack2regs
  ;MOVE.w D1,comWord_LabelListChanged
  JSR JL_0_46D6                      ;remarklistadd

 'skip
  TST.b (a1)+
  BNE 'co
 'nowrite
  MOVEA.l (A0),A0
  SUBQ.l #1,d0
  BNE click_remark
 'out
  MOVEA.l (A7)+,A1
RTS

.free_labellist:
  WZListRemove list_labels
  CLR.w comWord_LabelCounter
Return

;JL_0_46CC:
;  MOVE.w #$FFFF,comWord_LabelListChanged
;RTS

;.oldlistadd:
;  MOVEM.l D0-D1/A1-A2,-(A7)
;  MOVEQ.l #$08,D0
;  MOVE.l #$10000,D1
;  MOVEA.l _execbase,A6
;  MOVE.l A0,-(A7)
;  !newalloc
;  TST.l D0
;  BEQ.w memAlert_CloseSource
;
;  MOVEA.l (A7)+,A0
;  MOVEA.l D0,A2
;  MOVE.w comWord_LabelCounter,D1
;  BEQ.w JL_0_4714
;
;  MOVEA.l comPtr_LabelList,A1
;  SUBQ.w #2,D1
;  BMI.w JL_0_470E
;
;  JL_0_4708:
;    MOVEA.l (A1),A1
;  DBF D1,JL_0_4708
;
;  JL_0_470E:
;  MOVE.l A2,(A1)
;  BRA.w JL_0_471A
;
;  JL_0_4714:
;  MOVE.l A2,comPtr_LabelList
;
;  JL_0_471A:
;  MOVE.l A0,$4(A2)
;  ADDQ.w #1,comWord_LabelCounter
;
;  MOVEM.l (A7)+,D0-D1/A1-A2
;RTS
;
;JL_0_472A:
;  MOVE.w #$FFFF,comWord_LabelListChanged
;RTS


.update_labelstuff:
  If Peek.b(?comByte_LabelIdentifier) <> $FF
    Gosub free_labellist
    !asm
    JSR update_labellist
    !basic
    ped\LabelListChanged = False
  EndIf

.redraw_labellist:
  If Peek.w(?comWord_LabelCounter) <= Peek.l(?comLong_Label1VisableItem)
    Poke.l ?comLong_Label1VisableItem,0
  EndIf
  LabelList_FirstVisableItemNumber = Peek.l(?comLong_Label1VisableItem)

  If WZ_CheckOpen{"WIN_LABELS"}
    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels,LabelList_FirstVisableItemNumber
    WZListRemove lib_list.List
    WZPrint "LIBRARY_LIST",0,lib_list
  EndIf
Return


.AllocPoolMem:
 
  !basic
  tmpMemSize.l = PutD0
  ptr_MemAlloc.l = PED_AllocMem{tmpMemSize}
  If ptr_MemAlloc = 0
    Pop If
    Goto memAlert_CloseSource
  EndIf
  GetD0 ptr_MemAlloc
  !asm
RTS

.memAlert_CloseSource:
  Gosub display_memoryalert
  PED_CloseFile{ped\sourceFileHandle}

  CLR.l comLong_DisplayLineOffset
  CLR.l comLong_DisplayLine
  MOVE.l comPtr_FirstSourceLine,comPtr_CurrentSourceLine

  !asm
  JSR _redraw
  !basic
Goto bottom_of_mainloop


.display_memoryalert:
  alert$ = Chr$($00)  ; alert code
  alert$ + Chr$($38)  ; x-position
  alert$ + Chr$($16)  ; y-position
  alert$ + "Not enough memory for that operation! - Click Mousebutton to continue.\00\00"
  DisplayAlert_ $00,&alert$,$28
Return


.set_oldpreferences:

  ; -- load sourcefont
  Gosub open_sourcefonts

  ; -- check/set tokenisation mode
  ped\DoTokenize = $ffff
  Poke.w ?comWord_DoTokenize,ped\DoTokenize
  TST.w comWord_DoTokenize
  BEQ.w JL_0_4A76
    TST.l comPtr_TokenBase
    BNE.w JL_0_4A76
      CLR.w comWord_DoTokenize
  JL_0_4A76:

  ; -- add the source history to the menu
  If pedconfig\remember_saved
    Gosub load_pedrememberfile
  Else
    Gosub update_remembermenu
  EndIf
Return

.copy_A0_to_A1:
  MOVEM.l A0-A1,-(A7)

  JL_0_4A92:
    MOVE.b (A0)+,(A1)+
  BNE.b JL_0_4A92

  MOVEM.l (A7)+,A0-A1
RTS


.close_sourcefonts:
  USEPATH sourceWindow
  If (\fontI <> 0)  AND (\fontI <> \font) Then CloseFont_ \fontI
  If (\fontB <> 0)  AND (\fontB <> \font) Then CloseFont_ \fontB
  If \font <> 0 Then CloseFont_ \font

  \fontI = 0
  \fontB = 0
  \font = 0
Return


.open_sourcefonts:
  !log_AvailMem{"open fonts..."}
  Gosub close_sourcefonts

  ; open source font
  DEFTYPE.TextAttr fontsettings
  fontsettings\ta_Name = &sourcefont_name$
  fontsettings\ta_YSize = sourcefont_size
  fontsettings\ta_Style = sourcefont_style

  \font = OpenDiskFont_ (fontsettings)
  log_Print{"Font Baseline: "  +Str$(\font\tf_Baseline)}
  If \font = 0                                                  ; open standard font if config not font
    InitRastPort_ defaultrp.RastPort
    AskFont_ defaultrp,ta.TextAttr                                     ; might be better
    log_Print{"sourcefont [" + sourcefont_name$ + "] not found, using default [" + Peek.s(ta\ta_Name) + "]"}
    sourcefont_name$ = Peek.s(ta\ta_Name)
    sourcefont_size = ta\ta_YSize
    sourcefont_style = ta\ta_Style
    fontsettings\ta_Name =  &sourcefont_name$
    fontsettings\ta_YSize = sourcefont_size
    fontsettings\ta_Style = sourcefont_style
    \font = OpenDiskFont_(ta)
  EndIf

  ; open italic font
  fontsettings\ta_Style = #FSF_ITALIC
  \fontI = OpenDiskFont_ (fontsettings)
  If \fontI = 0
    InitRastPort_ defaultrp.RastPort
    AskFont_ defaultrp,ta.TextAttr
    \fontI = OpenDiskFont_(ta)
    If \fontI\tf_XSize><\font\tf_XSize
      CloseFont_ \fontI
      \fontI = \font
    End If
  EndIf

  ; open bold font
  fontsettings\ta_Style = #FSF_BOLD
  \fontB = OpenDiskFont_ (fontsettings)
  If \fontB = 0
    InitRastPort_ defaultrp.RastPort
    AskFont_ defaultrp,ta.TextAttr
    \fontB = OpenDiskFont_(ta)
    If \fontB
      If \fontB\tf_XSize>< \font\tf_XSize
        CloseFont_ \fontB
        \fontB = \font
      EndIf
    EndIf
  EndIf


  ; -- fill font structure
  Poke.w ?fontWidth, \font\tf_XSize
  ;Poke.w ?fontHeight, \font\tf_YSize
Return

.update_title_sourcewindow:
  log_Print{"update_title_sourcewindow: "  + sourceWindow\Title}
  SetWindowTitles_ sourceWindow\win,&sourceWindow\Title,-1
  If pedconfig\load_last_source <> 0
    pedconfig\lastSourceFile = ped\sourceFileComplete
    If pedconfig\lastSourceFile <> ""
      If Instr(pedconfig\lastSourceFile,Peek.s(?comStr_SourceName)) <> 0
        dos_SetToolString{"LAST_SOURCE",pedconfig\lastSourceFile}
      EndIf
    EndIf
  EndIf
Return


;.newSourcelineFromTempString:
;  MOVE.l D5,D0                            ; strlen form D5 to D0
;  ADDI.w #$9,D0                           ; add 9
;  JSR AllocPoolMem                        ; return memaddress in D0/A0
;
;  JSR init_sourceline                     ; init sourcelinestruct at New memadress
;                                          ; clr pointer to previous/next line, set stringlength byte
;
;  MOVEA.l comPtr_Temp_TokenString2,A1     ; copy stored source string to new sourceline
;  LEA $9(A0),A0
;  JL_0_4F3A:
;    MOVE.b (A1)+,(A0)+
;  BNE.b JL_0_4F3A
;
;  ;-- check if there is an label in the new line and set update flag for labellist
;  MOVEA.l D0,A0                           ; memaddress again in A0
;  MOVE.b comByte_LabelIdentifier,D0
;
;  MOVE.l A1,-(A7)                         ; skip spaces
;  LEA $9(A0),A1
;  JL_0_4F4A:
;    CMPI.b #$20,(A1)+
;  BEQ.b JL_0_4F4A
;  CMP.b -(A1),D0                          ; and check if Label at the beginning?
;  MOVEA.l (A7)+,A1
;
;  !basic
;  ped\LabelListChanged = True
;  !asm
;  ;MOVE.w #$FFFF,comWord_LabelListChanged
;RTS




.import_start:                              ; was used with import block and paste
  MOVEM.l D1-D4/D6-D7/A0-A6,-(A7)
  MOVE.w D5,D1
  MOVEA.l comPtr_Temp_TokenString2,A1
  CLR.b instring
  LEA tempbuf,a2

  TST.b convert
  BEQ 'l2b  ;'l1

    ;BRA 'l2b                         ; convert is done with preproc
    ;CMP.w #122,d1
    ;BLE 'noclip
    ;MOVE.w #122,d1
    ;MOVE.w d1,d5
    ;'noclip
    CMP.b #".",(a1)
    BNE 'l1
      MOVE.w #"'l",(a2)+
      ADDQ.w #1,d5                       ;add 1 additional char
      ADDQ.l #1,a1
      BRA 'ln1
   'l1

  TST.b convert
  BNE 'l1a
   'l1b
      MOVE.b (a1)+,d0
      BEQ 'exit
      MOVE.b d0,(a2)+
    DBF d1,'l1b
    BRA 'exit
 'l1a

  CMP.w #"\@",(a1)
  BNE 'ln1
    MOVE.w #"'l",(a2)+
    ADDQ.l #2,a1
   'n3
      MOVE.b (a1)+,d0
      BEQ 'n2
        CMP.b #" ",d0
        BEQ 'n2
          CMP.b #":",d0
          BEQ 'n2
            MOVE.b d0,(a2)+
      BRA 'n3
   'n2
    SUBQ.l #1,a1
    MOVE.l #"l`@ ",(a2)+
    ADDQ.w #4,d5
 'ln1

  CMP.b #";",(a1)   ;-1
  BEQ 'l2c
    CMP.b #$22,(a1)     ;-1       ;"
    BNE 'l2b
      TST.b instring
      BEQ 'l2c
        CLR.b instring
        BRA 'l2b
 'l2c
  MOVE.b #1,instring
 'l2b

  MOVE.b (a1)+,d0
  BEQ 'exit

  TST.b instring                     ;do only if no string
  BNE 'l5
    TST.b convert
    BEQ 'l5
      ;BRA 'l5
      CMP.b #".",d0
      BNE 'l2
       CMP.b #",",-2(a1)
        BEQ 'l500
          CMP.b #" ",-2(a1)
          BNE 'l2
       'l500
        ADDQ.w #1,d5
        MOVE.b #"'",(a2)+
        MOVEQ #"l",d0
     'l2
      CMP.b #"_",-2(a1)
      BEQ 'l4
      ;TST.b instring
      ;BNE 'l5
      CMP.l #"grap",-1(a1) : BEQ 'l3
      CMP.l #"dosb",-1(a1) : BEQ 'l3
      CMP.l #"intu",-1(a1) : BEQ 'l3
      CMP.l #"Allo",-1(a1) : BEQ 'l3
      CMP.l #"Free",-1(a1) : BEQ 'l3
      CMP.l #"Wait",-1(a1) : BEQ 'l3
      CMP.l #"\",d0
      BNE 'p1
        MOVE.b #"`",d0
     'p1
      CMP.l #"end",-1(a1)
      BEQ 'l4a                           ;endm
        CMP.l #"END",-1(a1)
        BNE 'l4
     'l4a
      CMP.b #"m",3(a1)
      BEQ 'l44a
        CMP.b #"M",3(a1)
        BNE 'l4
     'l44a
      CMP.b #" ",4(a1)
      BEQ 'l444a
        CMP.b #";",4(a1)
        BEQ  'l444a
          TST.b 4(a1)
          BNE 'l4
     'l444a
      MOVE.l #"end ",(a2)+
      MOVE.l #"macr",(a2)+
      MOVE.b #"o",d0
      ADD.w #9,d5
      ADDQ.l #4,a1
    'l4
      CMP.l #" mac",-1(a1)
                  ;BRA 'l4c              ;macro
      BEQ 'l4b

      CMP.l #" MAC",-1(a1)
      BNE 'l4c
    'l4b
      CMP.w #"ro",3(a1)
      BEQ 'l44b

      CMP.w #"RO",3(a1)
      BNE 'l4c

    'l44b
      CMP.b #" ",5(a1)
      BEQ 'l444b
      CMP.b #";",5(a1)
      BEQ  'l444b
      TST.b 5(a1)
      BNE 'l4c

    'l444b
        ADDQ.l #5,a1
        ADDQ.w #2,d5
        MOVE.b #" ",(a2)+
        MOVE.l #"macr",(a2)+
        MOVE.w #"o ",(a2)+
        SUBQ.w #5,d1
        MOVE.l a1,-(a7)
        MOVEA.l comPtr_Temp_TokenString2,A1

    'n3b
        MOVE.b (a1)+,d0
        BEQ 'n2b

        CMP.b #" ",d0
        BEQ 'n2b

        CMP.b #":",d0
        BEQ 'n2b

        MOVE.b d0,(a2)+
        ADDQ.w #1,d5
      BRA 'n3b
    'n2b

      MOVEQ #0,d0
      MOVE.l (a7)+,a1
    'l4c
      CMP.l #"ovem",(a1)
      BEQ 'mm
       CMP.l #"OVEM",(a1)
        BNE 'mm6
     'mm
      CMP.b #"m",-1(a1)
      BEQ 'mm2
        CMP.b #"M",-1(a1)
        BNE 'mm6
     'mm2
      MOVE.l a1,a0
      MOVEQ #0,d2

     'mm3
        MOVE.b (a0)+,d3
        BEQ 'mm6

        CMP.b #"(",d3
        BEQ 'mm6

        CMP.b #"-",d3
        BNE 'mm4
          MOVEQ #1,d2
       'mm4
        CMP.b #"/",d3
        BNE 'mm5
          MOVEQ #1,d2
       'mm5
      CMP.b #",",d3
      BNE 'mm3

      TST.l d2
      BNE 'mm6
        MOVE.b #$20,3(a1)
        SUBQ.l #1,a1
        MOVE.l (a1)+,(a2)+
        MOVE.w (a1)+,(a2)+
        SUBQ #6,d1
        BRA 'b1
     'mm6
        ;CMP.w #".W",-1(a1)
        ;BNE 'l5
        ;TST.b 1(a1)
        ;BNE 'l5
        ;MOVEQ #0,d0
        ;SUBQ.l #2,d1
   'l5
    MOVE.b d0,(a2)+
 'b1
  DBF d1,'l1

 'exit
  CMP.b #$0d,-1(a2)   ; check of ASC 13 carriage return
  BNE 'nd0
    CLR.b -1(a2)
    SUBQ.w #1,d5
 'nd0
  CLR.b (a2)
  MOVE.w d5,d1
  MOVEA.l comPtr_Temp_TokenString2,A1
  LEA tempbuf,a2
                                                       ;MOVEA.l A1,A2
                                               'l10:   ; maybe obsolete ?
  JSR tokenizeA1

  MOVEA.l comPtr_Temp_TokenString2,A2
  TST.b convert
  BEQ 'l21
    MOVEQ #0,d0
    MOVE.b (a2)+,d0
    CMP.b #" ",d0
    BNE 'l21
   'l20
    MOVE.b (a2)+,d0
    BEQ 'l21
    CMP.b #" ",d0
    BEQ 'l20
    CMP.b #";",d0
    BEQ 'l21
    CMP.w #$80,d0
    BGE 'l21
    MOVE.b #"!",-2(a2)
 'l21
  MOVEM.l (A7)+,D1-D4/D6-D7/A0-A6
  RTS

 'l3
  ADDQ.l #1,d5
  MOVE.b #"_",(a2)+
BRA 'l4


.detokenize_line:                    ; input A0: tokenized string; returns A1: detokenized string
  CLR.b instring3

  detokenize_line2
    TST.w comWord_DoTokenize
    BEQ.w JL_0_5054

    MOVEQ.l #$00,D0
    MOVE.b (A0)+,D0
    BEQ.w JL_0_5050

    CMP.b #$22,d0
    BNE 'l1
      NOT.b instring3
   'l1
    TST.b instring3
    BNE 'l2
      TST.b d0
      BMI.w JL_0_5040               ; beginning of token found
   'l2
    MOVE.b D0,(A1)+
    BNE.b detokenize_line2

    JL_0_5040:
    LSL.w #8,D0
    MOVE.b (A0)+,D0
    JSR token_to_ascii
    JL_0_5048:
      MOVE.b (A3)+,(A1)+
    BNE.b JL_0_5048
    SUBQ.w #1,A1

  BRA.b detokenize_line2

  JL_0_5050:
  CLR.b (A1)
RTS

.JL_0_5054:
  MOVE.l A3,-(A7)
  MOVEA.l A0,A3
  JSR copy_A0_to_A1
  MOVEA.l (A7)+,A3
RTS


.JL_0_5060:
  TST.b keepstring
  BNE 'l1
    CLR.b instring2
 'l1

  TST.b noDetokenizing       ; if set, just copy whole line and return                                                                                                                                                                                    
  BEQ.w JL_0_5072
    JL_0_506A:
      MOVE.b (A0)+,(A1)+
    BNE.b JL_0_506A
    SUBQ.w #1,A1
    RTS
  JL_0_5072:

  MOVEQ.l #$00,D0
  MOVE.b (A0)+,D0
  BEQ.w JL_0_5096

    CMP.b #$22,d0                ; check string
    BNE 'l10
      NOT.b instring2
   'l10

    TST.b instring2              ; if not in string
    BNE 'l11
      TST.b d0
      BMI.w JL_0_5082            ; if character byte < 0 we have a token!
   'l11
      MOVE.b D0,(A1)+            ; else copy the character
      BNE.b JL_0_5072
    JL_0_5082:

    LSL.w #8,D0                  ; get next byte to get the complete tokennumber
    MOVE.b (A0)+,D0
    JSR token_to_ascii           ; returns the detokenized string in A3!

    JL_0_508A:
      MOVE.b (A3)+,D1
      BEQ.b JL_0_5072
      BSET #$7,D1
      MOVE.b D1,(A1)+
    BRA.b JL_0_508A
  JL_0_5096:
  CLR.b (A1)
RTS


.token_to_ascii:
  ;MOVEA.l comPtr_TokenBase,A3       ;findtokenlib $80
  BCLR #$F,D0
  LEA instrtab,a3

  Dc.l $26730400 ;Dc.l $26730600 MOVE.l 0(a3,d0.w*4),a3

  CMP.l #0,a3
  BNE 'l10
    MOVEA.l comPtr_TokenBase,A3
   'JL_0_50A2:
      CMP.w $4(A3),D0
      BEQ.w JL_0_50B4
        TST.l (A3)
        BEQ.w unknowntoken
          MOVEA.l (A3),A3
    BRA.b 'JL_0_50A2
 'l10
  ADDQ.w #6,A3
RTS

.JL_0_50B4:
  MOVE.l a1,-(a7)
  LEA instrtab,a1

  Dc.l $238B0400 ; MOVE.l a3,0(a1,d0.w*4)
  MOVE.l (a7)+,a1
  ADDQ.w #6,A3
RTS

.unknowntoken:
  !basic
  i = PutD0
  temp$ = "????Lib " + Str$(i LSR 7) + "/" + Str$((i AND $7f)-1)
  MOVE.l temp@(a5),d0
  !asm
  MOVE.l d0,a3
RTS

;ptr_errortitle:       Dc.l 0;AL_0_D5E8        ; Title
;ptr_errortext:        Ds.l 1                  ; Text
.show_errorrequester:  ; A0: ptr to Errortext,
                       ; A5: ptr current sourceline
                       ; A6: "INLN" If in INCLUDE
                       ; D7: includeline
;  MOVE.l D7,-(A7)
;
;  MOVE.l A0,ptr_errortext
;
;  CMP.l #0,a5
;  BNE 'l4
;    LEA dummystr + 1,a5
; 'l4
;  MOVEQ #20,d0
;  MOVE.l a5,a0                       ;macro title
;  SUBQ.l #1,a0
; 'l2
;    MOVE.b -(a0),d1
;    BEQ 'l1
;      CMP.b #":",d1
;      BEQ 'l1
;        SUBQ.l #1,d0
;  BNE 'l2
; 'l1
;  ADDQ #1,a0
;
;  LEA helpstring,a1
;  CMP.l #"INLN",a6
;  BNE 'l1x
;    LEA helpstring,a1
;    ADDQ #4,a1
;    MOVE.b #32,(a1)+
; 'l1x
;
;  MOVEQ #60,d1
; 'l5
;    MOVE.b (a0)+,d0
;    BEQ 'n1
;    MOVE.b d0,(a1)+
;    SUBQ.l #1,d1
;  BNE 'l5
; 'n1
;  CLR.b (a1)+
;  LEA helpstring,a0
;  TST.b (a0)
;  BNE 'l1b
;    ADDQ.l #4,a0
; 'l1b
;  MOVE.l expandstore,a1
;  JSR detokenize_line
;  MOVE.l expandstore,a1
;
;  MOVE.l a1,ptr_errortitle
;  ;MOVE.b #">",(a1)
; 'l8
;    MOVE.b (a1)+,d0
;    BEQ 'l9
;    CMP.b #":",d0
;  BNE 'l8
;  ;MOVE.b #"<",-1(a1)
; 'l9
  !regs2stack
  !basic
  fid.l = file_Open{dos_AddPart{pedconfig\systemDir,"ab_compileerror.txt"},#file_read}
  If fid <> -1
    error_type.s  = StrRight(file_ReadLine{fid},-8)
    error_line.s  = StrRight(file_ReadLine{fid},-8)
    error_lineptr.s=StrRight(file_ReadLine{fid},-8)
    error_cause1.s = StrRight(file_ReadLine{fid},-8)
    error_cause2.s = StrRight(file_ReadLine{fid},-8)
    error_source.s = StrRight(file_ReadLine{fid},-8)
    error_libnum.s = StrRight(file_ReadLine{fid},-8)
    error_incname.s = StrRight(file_ReadLine{fid},-8)
    error_incline.s = StrRight(file_ReadLine{fid},-8)
    compilestatus.s = StrRight(file_ReadLine{fid},-8)
    file_Close{fid}

    If error_incname <> "none"              ; open source file with error
      GetD0 &error_incname
      If Exists (error_incname)
        log_Print{"Error in include ["+ error_incname + "], opening it and jumping to errorline ["+ error_incline + "]..."}
        GetD0 &error_incname
        !asm
        JSR loadfile
        !basic
        lineNum.l = Val(error_incline)-1 : Gosub gotoline
        Gosub draw_statusarea
        Gosub update_vertscroller
      End If
    End If
  Else
    error_line$ = ""
  End If

  ; building the inforequester:
  If error_line <> ""
    msg$ = !TRANS{Replace$(error_type,"\\0a","\n")}
    msg$ = Replace$(msg$,"\n","\\0a")

    If error_incname <> "none"
      msg$ + "\\nInclude " + !TRANS{"file"} + ": " + error_incname
      msg$ + "\\nInclude " + !TRANS{"line"} + ": " + error_incline + " - " + !TRANS{"Source line"} + ": " + error_line
    Else
      msg$ + "\\n" + !TRANS{"Source line"} + ": " + error_line
      msg$ + "\\n" + !TRANS{"Pointer"} + ": " + error_lineptr
    EndIf

    msg$ + "\\n\\n" + !TRANS{"Affected source"} + ": " + error_source
    If error_cause1 <> "" OR error_cause2 <> ""
      msg$ + "\\n" + !TRANS{"Details"} + ": "
      If error_cause1 <> "" Then msg$ + error_cause1 + "\\n"
      If error_cause2 <> "" Then msg$ + error_cause2
    EndIf
  EndIf
  dummy.l = ask{msg$,!TRANS{"OK"},!TRANS{"Compile Error"}}
  !asm
  !stack2regs
;  MOVE.l (A7)+,D7
RTS

.flush_intuimessages:
  FlushEvents
  ;If sourceWindow\win
  ;  *intuimessage.IntuiMessage = GetMsg_(sourceWindow\win\UserPort)
  ;  While *intuimessage
  ;    ReplyMsg_ *intuimessage : *intuimessage = 0
  ;    *intuimessage.IntuiMessage = GetMsg_(sourceWindow\win\UserPort)
  ;  Wend
  ;EndIf
Return

JL_0_5474:
  CMPI.l #$1,comLong_TotalLines
  BEQ.w JL_0_54EA
    SUBQ.l #1,comLong_TotalLines
    MOVE.l (A5),D1
    MOVE.l $4(A5),D2
    BEQ.w JL_0_54A4
      TST.l D1
      BEQ.w JL_0_54B4
        MOVEA.l D2,A0
        MOVE.l D1,(A0)
        MOVEA.l D1,A0
        MOVE.l D2,$4(A0)
        BRA.w JL_0_54BE
    JL_0_54A4:
      MOVE.l D1,comPtr_FirstSourceLine
      MOVEA.l D1,A0
      CLR.l $4(A0)
      BRA.w JL_0_54BE

    JL_0_54B4:
    MOVE.l D2,comPtr_LastSourceLine
    MOVEA.l D2,A0
    CLR.l (A0)

  JL_0_54BE:

  MOVEA.l A5,A1
  MOVE.b comByte_LabelIdentifier,D0
  MOVE.l A0,-(A7)                          ;
  LEA $9(A1),A0

  JL_0_54CA:
    CMPI.b #$20,(A0)+
  BEQ.b JL_0_54CA

  CMP.b -(A0),D0
  MOVEA.l (A7)+,A0                         ;
  BNE.w JL_0_54Dca
   !regs2stack
   !basic
   ped\LabelListChanged = True
   !asm
   !stack2regs
   ; MOVE.w #$FFFF,comWord_LabelListChanged
  JL_0_54Dca:

  !newfree                            ; A1: memory , -(a1) is size
RTS

JL_0_54EA:
  !basic
  Gosub alloc_firstsourceline
  !asm
BRA.b JL_0_54BE


.move_to_blockstarty:                ; in A4: currentsourceline, out A5: adjusted currentsourceline
  MOVEA.l A4,A5

  MOVE.l comLong_DisplayLineOffset,D7 : ADD.l comLong_DisplayLine,D7 : MOVE.l D7,D6
  CMP.l comLong_BlockStartY,D6
  BEQ.w JL_0_5522
    BCC.w JL_0_5516

    JL_0_5508:
      MOVEA.l (A5),A5
      ADDQ.l #1,D6
    CMP.l comLong_BlockStartY,D6
    BNE.b JL_0_5508

    BRA.w JL_0_5522

    JL_0_5516:
      MOVEA.l $4(A5),A5
      SUBQ.l #1,D6
    CMP.l comLong_BlockStartY,D6
    BNE.b JL_0_5516
  JL_0_5522:
RTS

JL_0_5524:
  BSR.b move_to_blockstarty
  MOVE.w comWord_BlockStartX,D5

  MOVE.w comWord_DoTokenize,D0
  BEQ.w JL_0_5538
    BRA.w JL_0_553A
  JL_0_5538:
RTS

JL_0_553A:                                  ; sourcelinepointer in A5, returns
  MOVEA.l comPtr_Temp_TokenString3,A0
  CMP.l #0,a5
  BEQ 'l1
    LEA $9(A5),A1
    ADDQ.w #1,A0
    JSR JL_0_5556
    MOVE.l A0,D0
    SUB.l comPtr_Temp_TokenString3,D0
    MOVEA.l comPtr_Temp_TokenString3,A0
    MOVE.b D0,(A0)
 'l1
RTS

JL_0_5556:
  CLR.b instring3

  JL_0_5556b:
    MOVE.b (A1)+,D0                    ;cut token
    BEQ.w JL_0_5574

      CMP.b #$22,d0
      BNE 'l1
        NOT.b instring3
     'l1
      TST.b instring3
      BNE 'l2
        TST.b d0
        BMI.w JL_0_5564
     'l2
        MOVE.b D0,(A0)+
        BRA.b JL_0_5556b
      JL_0_5564:

      LSL.w #8,D0
      MOVE.b (A1)+,D0
      JSR token_to_ascii
      JL_0_556C:
        MOVE.b (A3)+,(A0)+
      BNE.b JL_0_556C
      SUBQ.w #1,A0
    BRA.b JL_0_5556b

  JL_0_5574:
RTS

.update_currsourceline_bas:
  *currentSourceLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
  currentLine.l = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine)
  If currentLine > 0
    Repeat
      *currentSourceLine = *currentSourceLine\nextLine
      currentLine - 1
    Until currentLine = 0
  EndIf

  ped\ptrCurrentSourceData\CurrentSourceLine = *currentSourceLine
Return

.update_currsourceline:
  MOVEA.l comPtr_FirstSourceLine,A4
  MOVE.l comLong_DisplayLineOffset,D0 : ADD.l comLong_DisplayLine,D0
  BEQ.w JL_0_558E
  ;SUBQ.l #1,D0
  JL_0_5588:
    MOVEA.l (A4),A4
    SUBQ.l #1,d0
    ; DBF D0,JL_0_5588
  BNE JL_0_5588

  JL_0_558E:
  MOVE.l A4,comPtr_CurrentSourceLine
RTS

JL_0_5596:
  MOVE.l A3,D5
  SUB.l comPtr_Temp_TokenString1,D5
  ADDQ.l #1,D5                                      ; get length of TokenString1
BRA.w replaceCurrentLine

.tokenizeAndInsertNewLine:
  MOVEA.l comPtr_Temp_TokenString2,A2
  JSR parse_line


  replaceCurrentLine:
  ; Input:  d5 = length of parsed string?
  ;         a4 = current sourceline
  ;         ptr_temp_tokenstring1 = tokenized text to insert
  MOVE.l D5,-(a7)                     ; returns length of string in D5
  !basic
  MOVE.l (a7)+,D0 : PutReg D0,tmpd0.l
  newsourceline.s = Peeks$(Peek.l(?comPtr_Temp_TokenString1),tmpd0)
  *newLine.sourceLine = PED_CreateNewSourceLine{newsourceline}
  PED_ReplaceCurrentSourceLine{*newLine.sourceLine}
  !asm
  MOVE.l comPtr_CurrentSourceLine,A4
RTS


JL_0_5630:
  CMP.w #MAX_Columns,D5
  BGE.w JL_0_568C                        ; if D5>Maxcolumns, d5=0,d6=0, exit
    CMP.l comLong_BlockEndY,D6
    BCS.w JL_0_5650
    BNE.w JL_0_564C
      CMP.w comWord_BlockEndX,D5
      BLS.w JL_0_5650
    JL_0_564C:
  MOVEQ.l #-$01,D0
RTS

JL_0_5650:
  ADDQ.w #1,D5
  MOVE.w comWord_DoTokenize,D0
  BEQ.w JL_0_5670
    MOVEA.l comPtr_Temp_TokenString3,A3
    CMP.b (A3),D5
    BCC.w JL_0_5680
      MOVEQ.l #$00,D0
      MOVE.b $0(A3,D5.W),D0
      TST.w D0
        RTS
  JL_0_5670:
    CMP.b $8(A5),D5
    BCC.w JL_0_5680
      MOVEQ.l #$00,D0
      MOVE.b $8(A5,D5.W),D0
      RTS
    JL_0_5680:
    MOVE.w comWord__AL_0_8AD8,D0
    BNE.w JL_0_568C
      MOVEQ.l #$20,D0
      RTS
    JL_0_568C:
    MOVEA.l (A5),A5
    ADDQ.l #1,D6
    MOVEQ.l #$00,D5
    MOVEQ.l #$00,D0
RTS

.reset_Blockflag:
  Poke.w ?store_BlockStartX, $FFFF
  Poke.l ?comLong_BlockEndY, $ffffFFFF
Return

.reset_Blockflag_asm:
  MOVE.w #$FFFF, store_BlockStartX
  MOVE.l #$ffffFFFF, comLong_BlockEndY
RTS



.block_updatePosY:
  CMPI.l #$ffffFFFF,comLong_BlockEndY
  BEQ.w JL_0_57DE
    CMP.l comLong_BlockEndY,D0
    BHI.w JL_0_57DE
      ADDQ.l #1,comLong_BlockEndY
      CMP.l comLong_BlockStartY,D0
        BHI.w JL_0_57DE
          ADDQ.l #1,comLong_BlockStartY
  JL_0_57DE:
RTS

.update_scrollers:
  Gosub update_horizscroller
  Gosub update_vertscroller
Return

.AbsBlockDimensions_bas:
;  log_Print{"abs blockdims"}
  tempD0.w = Peek.w(?comWord_BlockStartX)
  tempD1.l = Peek.l(?comLong_BlockStartY)
  tempD2.w = Peek.w(?comWord_BlockEndX)
  tempD3.l = Peek.l(?comLong_BlockEndY)
;  log_Print{"BlockStartX = " + Str$(tempD0) + ", BlockStartY = " + Str$(tempD1)}
;  log_Print{"BlockEndX = " + Str$(tempD2) + ",  BlockEndY = " + Str$(tempD3)}
  If tempD1 >= tempD3
    If tempD1 <> tempD3
      absloop:
      Exchange tempD0, tempD2
      Exchange tempD1, tempD3
      Poke.w ?comWord_BlockStartX, tempD0
      Poke.l ?comLong_BlockStartY, tempD1
      Poke.w ?comWord_BlockEndX, tempD2
      Poke.l ?comLong_BlockEndY, tempD3
    EndIf
    If tempD0 > tempD2
      Goto absloop
    EndIf
  EndIf
  ;tempD0.w = Peek.w(?comWord_BlockStartX)
  ;tempD1.l = Peek.l(?comLong_BlockStartY)
  ;tempD2.w = Peek.w(?comWord_BlockEndX)
  ;tempD3.l = Peek.l(?comLong_BlockEndY)
  ;log_Print{"BlockStartX = " + Str$(tempD0) + ", BlockStartY = " + Str$(tempD1)}
  ;log_Print{"BlockEndX = " + Str$(tempD2) + ", BlockEndY = " + Str$(tempD3)}
Return

.AbsDimensions:
  CMP.w D3,D1
  BCS.w JL_0_5888
    BNE.w JL_0_5884
      CMP.w D2,D0
      BLE.w JL_0_5888
    JL_0_5884:
    EXG.l D0,D2
    EXG.l D1,D3

  JL_0_5888:
RTS



.getfoldstatus
  CLR.l foldnum
  MOVE.l a1,-(a7)
  MOVE.l comPtr_FirstSourceLine,d0
  BEQ 'out
 'l1
    MOVE.l d0,a1
    CMP.l a2,a1
    BEQ 'out
      CMP.w #";@",9(a1)
      BNE 'l2
        CMP.w #"@1",11(a1)
        BNE 'no1
          MOVE.l #1,foldnum
       'no1
        CMP.w #"@0",11(a1)
        BNE 'no2
          MOVE.l #0,foldnum
       'no2
     'l2
  MOVE.l (a1),d0
  BNE 'l1
 'out
  realline
  MOVE.l (a7)+,a1
RTS

.doreverse:
  CMP.w #"@0",11(a2)                   ;reverse ok !!!
  BNE 'no1
    MOVEM.l d0/a1,-(a7)
    MOVE.l #0,foldnum
    MOVE.l 4(a2),d0
    BEQ 'lp4
   'lp1
      MOVE.l d0,a1                    ;check if previous is ;@@1
      CMP.w #";@",9(a1)
      BNE 'lp2
        CMP.w #"@1",11(a1)
        BNE 'lp3
          MOVE.l #1,foldnum
          BRA 'lp4                             ;block is folded
       'lp3
        CMP.w #"@0",11(a1)
        BEQ 'lp4
     'lp2
      MOVE.l 4(a1),d0
     BNE 'lp1
   'lp4
    MOVEM.l (a7)+,a1/d0
 'no1
  CMP.w #"@1",11(a2)
  BNE 'no2
    MOVE.l #0,foldnum
 'no2
 'l2
;MOVE.l a1,a2
RTS


._redraw:
;!regs2stack
;!basic
;log_Print{"redraw, displayline: " + Str$(Peek.l(?comLong_DisplayLine))}
;!asm
;!stack2regs

  MOVEA.l comPtr_CurrentSourceLine,A2       ; if no source available, quit redraw!
  CMPA.l #$0,A2
  BNE.w JL_0_58B6
    RTS
  JL_0_58B6:

  MOVE.l comLong_BlockEndY,-(A7)

  MOVE.l #$ffffFFFF,comLong_BlockEndY
  JSR save_cursorposition
  JSR clear_sourcetextbuffer

  CNIF #hardfold = 1
    JSR getfoldstatus
  CEND

  MOVE.l comLong_DisplayLine,D1

  JL_0_58BA:
    BEQ.w JL_0_58C6

    MOVE.l $4(A2),d0
    BEQ JL_0_58C6
      MOVE.l d0,a2

      CNIF #hardfold = 0
        BRA 'l3
      CEND

      CMP.w #";@",9(a2)
      BNE 'l2
        BSR doreverse
        CMP.w #"@0",11(a2)
        BNE 'l2
          TST.l foldnum
          BNE 'l3
     'l2
      TST.l foldnum
      BNE JL_0_58BA
     'l3
      SUBQ.l #1,D1
  BRA.b JL_0_58BA
  JL_0_58C6:
  MOVE.l D1,comLong_DisplayLine

  CLR.w comWord_TextBufferOffset
  CLR.l foldnum
  !regs2stack
  !basic
  sourceWindow\clearEndOfLine = True
  Gosub cursor_off                                                                                                                                                                                                                                          
  !asm
  !stack2regs
  MOVE.l viewablelines,D7 : SUBQ.l #1,D7
  MOVE.w comWord_ColumnsOffset,comWord_ColumnsOffsetTmp
  MOVE.l comLong_LinePosStartY,d0

  JL_0_58E8:                         ;print whole window
    CNIF #hardfold = 1
   'nr
      CMP.l #";@@1",9(a2)
      BNE 'l1
        MOVE.l #1,foldnum
        BRA 'do
     'l1
      CMP.l #";@@0",9(a2)
      BNE 'l2
      MOVE.l #0,foldnum
     'l2
;      MOVE.l comLong_DisplayLine,d0
;      CMP.l store_comLong_DisplayLine,d0
;      BNE 'l3b
;      ;MOVE.l a2,comPtr_CurrentSourceLine
;     'l3b
      TST.l foldnum
      BEQ 'do
        MOVE.l (a2),d0
        BEQ JL_0_5902
          MOVE.l d0,a2
    BRA 'nr
   'do
    CEND

    MOVE.l (A2),-(A7)
    JSR print_sourceline
    MOVE.l (A7)+,D0

    BEQ.w JL_0_5902           ; no next line left
      MOVEA.l D0,A2
      JSR increase_DisplayLine
  DBF D7,JL_0_58E8
  JL_0_5902:

  !basic

  ; -- better refresh: clear bottom
  sourceWindow\clearEndOfLine = False
  USEPATH sourceWindow
  If Peek.l(?comLong_DisplayLine) < Peek.l(?viewablelines)
    ;log_Print{"redraw: clear rest of window at displayline: " + Str$(Peek.l(?comLong_DisplayLine)+1)}
    SetAPen_  \win\RPort, AB3Pen(#AB3_cbackground)
    rectx.w = \BoxLeft
    recty.w = \BoxTop + (Peek.l(?comLong_DisplayLine)+1) * \font\tf_YSize
    rectw.w = \BoxWidth
    recth.w = \statusAreaY
    If (rectw => rectx) AND (recth => recty)
      RectFill_ \win\RPort, rectx, recty, rectw, recth
      If pedconfig\linenumbers
        RectFill_ \win\RPort, 0, recty, rectx-3,recth
      EndIf
    Else
      log_Print{"illegal area for clear bottom:",#log_error}
      log_Print{"displayline: " + Str$(Peek.l(?comLong_DisplayLine)+1) + "   viewablelines: " + Str$(Peek.l(?viewablelines)-1)}
      log_Print{Str$(rectx) + ", " + Str$(rectw),#log_error}
      log_Print{Str$(recty) + ", " + Str$(recth),#log_error}
    EndIf
  EndIf
  !asm

  JSR restore_cursorposition
  MOVE.l (A7)+,comLong_BlockEndY

  JL_0_590C:
  !basic
  If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
    ;log_Print{"draw block (after refresh.)"}
    bmark\xMin = Peek.w(?comWord_BlockStartX)
    bmark\yMin = Peek.l(?comLong_BlockStartY)
    bmark\xMax = Peek.w(?comWord_BlockEndX)
    bmark\yMax = Peek.l(?comLong_BlockEndY)

    If bmark\xMin - Peek.w(?comWord_ColumnsOffset) < 0
      bmark\xMin = 0
    End If

    If bmark\yMax >= Peek.l(?comLong_DisplayLineOffset)
      bmark\yMin - Peek.l(?comLong_DisplayLineOffset)
      If bmark\yMin < 0
        bmark\xMin = 0
        bmark\yMin = 0
      EndIf

      bmark\xMax - Peek.w(?comWord_ColumnsOffset)
      If bmark\xMax < 0 Then bmark\xMax = 0

      bmark\yMax - Peek.l(?comLong_DisplayLineOffset)
      If bmark\yMax < 0 Then bmark\yMax = 0

      If bmark\yMin < Peek.l(?viewablelines)
        If bmark\yMax > Peek.l(?viewablelines)
          bmark\yMax = Peek.l(?viewablelines) - 1
        EndIf

        If bmark\xMax > Peek.w(?visiblecolumns)
          bmark\xMax = Peek.w(?visiblecolumns) - 1
        EndIf

        bmark\xMin + Peek.w(?comWord_ColumnsOffset)
        bmark\xMax + Peek.w(?comWord_ColumnsOffset)

        ;msg$ = Str$(bmark\xMin) + ", "
        ;msg$ + Str$(bmark\yMin) + " - "
        ;msg$ + Str$(bmark\xMax) + ", "
        ;msg$ + Str$(bmark\yMax)
        ;log_Print{msg$}

        PED_DrawBlock{bmark, Peek.w(?comWord_ColumnsOffset)}
      EndIf
    EndIf
  EndIf

  Gosub update_modifiermark
  Gosub cursor_on
  !asm
RTS



._redrawBlock:                           ;redraw blockmark
  JSR AbsDimensions

  MOVEM.l D0-D3/A0-A1,-(A7)
  !basic
  xMin.w = PutD0
  MOVE.l d1,d0 : yMin.w = PutD0
  MOVE.l d2,d0 : xMax.w = PutD0
  MOVE.l d3,d0 : yMax.w = PutD0
  log_Print{"draw block"}
  ;xMin = xMin - Peek.w(?comWord_ColumnsOffset)
  ;PED_ShowMessage{"Xmin:" + Str$(xMin)}

  If xMin < 0 Then xMin = 0
  If xMax < 0 Then xMax = 0 : Else : xMax = xMax + 1
  If yMin < 0 Then yMin = 0
  If yMax < 0 Then yMax = 0
  xMax = xMax - Peek.w(?comWord_ColumnsOffset)
  xMin = xMin - Peek.w(?comWord_ColumnsOffset)
  If xMax > \visibleColumns Then xMax = \visibleColumns
  If yMax > Peek.l(?viewablelines)-1 Then yMax = Peek.l(?viewablelines)-1
  If yMin > Peek.l(?viewablelines)-1 Then yMin = Peek.l(?viewablelines)-1

  xMin = xMin * \font\tf_XSize
  yMin = yMin * \font\tf_YSize
  xMax = xMax * \font\tf_XSize
  yMax = yMax * \font\tf_YSize
  If yMin > yMax Then Exchange yMax,yMin

  If yMin = yMax
      yMax = yMax + \font\tf_YSize - 1
      Gosub rectfill
  Else
      yMaxold.l = yMax : xMaxold.l = xMax : yMinold.l = yMin : xMinold.l = xMin
      yMax = yMin + \font\tf_YSize - 1
      xMax = \visibleColumns * \font\tf_XSize
      Gosub rectfill
      yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold

      yMin = yMin + \font\tf_YSize
      If yMin < yMax
          yMaxold.l = yMax : xMaxold.l = xMax : yMinold.l = yMin : xMinold.l = xMin
          yMax = yMax - 1
          xMax = \visibleColumns * \font\tf_XSize
          xMin = 0
          Gosub rectfill
          yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
          xMin = 0
          yMin = yMax
      EndIf

      xMin = 0
      yMax = yMax + \font\tf_YSize - 1
      Gosub rectfill
  EndIf
  !asm
  MOVEM.l (A7)+,D0-D3/A0-A1
RTS

.rectfill:
  If (xMax >= xMin) AND (yMax >= yMin)
    xMin = sourceWindow\BoxLeft + xMin
    xMax = sourceWindow\BoxLeft + xMax - 1
    ;    msg$ =  Str$(xMin) + ", " + Str$(yMin) + ", " + Str$(xMax) + ", " + Str$(yMax)
    ;   log_Print{msg$}
    RectFill_ *sourcerp, xMin, yMin, xMax, yMax
  EndIf
Return

.alloc_firstsourceline:
  *tempLine.sourceLine = PED_CreateNewSourceLine{""}
  If *tempLine
    ped\ptrCurrentSourceData\FirstSourceLine = *tempLine
    ped\ptrCurrentSourceData\CurrentSourceLine = *tempLine
    ped\ptrCurrentSourceData\LastSourceLine = *tempLine
  Else
    error{"Could not allocate a new sourceline!"}
  EndIf
Return


.draw_new_sourceline_top:
  log_Print{"print 1 line up from line " + Str$(Peek.l(?comLong_DisplayLine))}
  *currentline.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine 

  JSR save_cursorposition

  CLR.w comWord_TextBufferOffset

  tmpDL.l = Peek.l(?comLong_DisplayLine)
  While tmpDL > 0
    *currentline = *currentline\previousLine
    If *currentline = 0
     Pop If : Pop While : Goto no_prev_line
    EndIf
    tmpDL - 1
  Wend
  Poke.l ?comLong_DisplayLine, tmpDL
  GetReg A2, *currentline
  MOVE.l A2,-(a7)
  !asm
  MOVE.l (a7)+,A2
  JSR print_sourceline
  !basic

  no_prev_line:
  JSR restore_cursorposition

  ; what for ? the result is returned in registers D0, D1, D6 ??
  ;TST.l comLong_BlockEndY
  ;BMI.w JL_0_614E2
  ;  MOVE.w comWord_Column,D0
  ;  MOVE.l comLong_DisplayLineOffset,D1 : ADD.w comWord_ColumnsOffset,D0
  ;  MOVEQ.l #$00,D6
  ;JL_0_614E2:
Return

.draw_new_sourceline_bottom:
  log_Print{"print 1 line down from line " + Str$(Peek.l(?comLong_DisplayLine))}
  *currentline.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine

  JSR save_cursorposition

  While Peek.l(?viewablelines) > (Peek.l(?comLong_DisplayLine) + 1)
    *currentline = *currentline\nextLine
    If *currentline = 0
      Pop If : Pop While : Goto no_next_line
    EndIf

    JSR increase_DisplayLine

  Wend
  
  GetReg A2,*currentline
  MOVE.l A2,-(a7)
  !asm
  MOVE.l (a7)+,A2
  JSR print_sourceline
  !basic

  no_next_line:
  JSR restore_cursorposition
Return



;AL_0_5B9A:    Ds.l 1
AL_0_5B9E:    Ds.l 1
;AL_0_5BA2:    Ds.l 1        ; not used anymore ?
AL_0_5BA6:    Ds.l 1
textbufferPrint:    Ds.l 1
expandstore:  Ds.l 1
lineundeletestore:    Ds.l 1

.print_complete_line:                  ; d0:x, d1:y, a0: text
  MOVE.l D2,-(A7)
  !regs2stack
  MOVE.l A0,-(a7)   ; string
  MOVE.l D0,-(a7)   ; x-pos
  MOVE.l D1,-(a7)   ; y-pos
  !basic
  MOVE.l (a7)+,d0 : tposy.w = PutD0
  MOVE.l (a7)+,d0 : tposx.w = PutD0
  MOVE.l (a7)+,d0 : *textaddr.l = PutD0

  If Peek.w(?comWord_DoTokenize)
    ; clear textBufferPrint
    tmpAddr.l = Peek.l(?textbufferPrint)
    For i = 0 To #MAX_Columns/4-1 Step 4
      Poke.l  tmpAddr + i, 0
    Next i
    ; copy the current line to a tempBuffer
    For i = 0 To #MAX_Columns - 1
      Poke.b Peek.l(?AL_0_5BA6) + i, Peek.b(*textaddr+i)
    Next i
    Poke.b Peek.l(?AL_0_5BA6) + #MAX_Columns-1, 0
    GetReg d0,tposx
    GetReg d1,tposy
    !asm
    JSR print_tokenized_text
    !basic
  Else
    sourceWindow\ColumnsOffsetTmp = Peek.w(?comWord_ColumnsOffsetTmp)
    PED_PrintTextStandard{tposx, tposy, *textaddr}
  EndIf

  If sourceWindow\clearEndOfLine
    USEPATH sourceWindow

    If \win\RPort\cp_x <= \BoxLeft
      rectx.w = \win\RPort\cp_x + 1
    Else
      rectx.w = \win\RPort\cp_x
    EndIf
    recty.w = \BoxTop + Peek.l(?comLong_DisplayLine) * \font\tf_YSize
    rectw.w = \BoxWidth
    recth.w = recty + \font\tf_YSize-1
    If (rectw => rectx) AND (recth => recty)
      SetAPen_  \win\RPort, AB3Pen(#AB3_cbackground)
      RectFill_ \win\RPort, rectx, recty, rectw, recth
    Else
      log_Print{"illegal area for clear bottom:",#log_error}
      log_Print{Str$(rectx) + ", " + Str$(rectw)}
      log_Print{Str$(recty) + ", " + Str$(recth)}
    EndIf
  EndIf
  !asm
  !stack2regs
  MOVE.l (A7)+,D2
RTS

.print_tokenized_text_bas:
  MOVEA.l AL_0_5BA6,A0
  MOVEA.l textbufferPrint,A1

  MOVEM.l D0-D1/A1,-(A7)
  JSR JL_0_5060                               ;copy whole line from A0 to A1 and detokenize
  MOVEM.l (A7)+,D0-D1/A1

  !basic
  PutReg d1,tposy
  PutReg d0,tposx
  PutReg a1,tmpA1.l
  log_Print{Str$(tposx) + ", " + Str$(tposy)}
  log_Print{Peek.s(Peek.l(tmpA1))}
  tmpString.s = Peek.s(Peek.l(?AL_0_5BA6))

  ;-- check if source left of display start position has an opened string
  If Peek.b(?keepstring) = 0
    Poke.b ?instring,0

    If tmpString <> ""
      tmpD2.w = 1
      While Peek.w(?comWord_ColumnsOffset) > tmpD2
        If Mid$(tmpString,tmpD2,1) = Chr$($22) Then NOT.b instring2
        tmpD2 + 1
      Wend
    EndIf
  EndIf
  log_Print{"instring: " + Str$(Peek.b(?instring2))}
  log_Print{">" + tmpString + "<"}
  tmpPrint.s = UnRight$(Peek.s(Peek.l(?textbufferPrint)), Peek.w(?comWord_ColumnsOffsetTmp)  )
  log_Print{">" + tmpPrint + "<"}

  lastVisibleChar$ = Mid$(tmpPrint,\visibleColumns,1)
  tmpPrint = Left$(tmpPrint,\visibleColumns)

  tposx = tposx / \font\tf_XSize
  tlength.w = Len(tmpPrint)
  log_Print{tmpPrint}
  PED_PrintText{&tmpPrint,tposx,tposy,tlength,AB3Pen(#AB3_cother)}
  !asm
RTS


.print_tokenized_text:
  MOVEA.l AL_0_5BA6,A0
  MOVEA.l textbufferPrint,A1

  MOVEM.l D0-D1/A1,-(A7)
  JSR JL_0_5060                               ;copy whole line from A0 to A1 and detokenize
  MOVEM.l (A7)+,D0-D1/A1

  !regs2stack
  !basic
  PutReg a1,tmpA1
;  log_Print{Peek.s(tmpA1)}
;  log_Print{Peek.s(Peek.l(tmpA1))}
;  log_Print{Peek.s(Peek.l(?expandstore))}
  !asm
  !stack2regs

  TST.b keepstring
  BNE 'l3
    CLR.b instring2
    MOVEA.l AL_0_5BA6,A0
    MOVE.w #0,d2
    MOVEM.l d0/d1,-(a7)
    CMP.l #0,a0
    BEQ 'l2b
   'l1
      CMP.w comWord_ColumnsOffset,d2
      BGE 'l2b
        MOVE.b (a0)+,d0
        CMP.b #$22,d0
        BNE 'l2
          NOT.b instring2
       'l2
        ADDQ.w #1,d2
    BRA 'l1
   'l2b
    MOVEM.l (a7)+,d0/d1
 'l3
  ADDA.w comWord_ColumnsOffsetTmp,A1                ;offset
  MOVE.w visiblecolumns,D4
  MOVE.b $0(A1,D4.W),comByte__AL_0_8662
  MOVEM.l D4/A1,-(A7)
  MOVE.b #$0,$0(A1,D4.W)
  MOVEA.l expandstore,A2
  MOVEA.l A1,A0

  EXT.l d0 : DIVU fontWidth,d0                          ; d0: xPos

  JL_0_5C9C:
    MOVE.b (A1)+,D2
    BEQ.w JL_0_5CAA
      CMP.b #$22,d2                        ; "
      BNE 'l10
        NOT.b instring2
     'l10
      TST.b instring2
      BNE 'l11
        TST.b d2
        BMI.w JL_0_5CAA                     ;morechar
     'l11
      MOVE.b D2,(A2)+
    BRA.b JL_0_5C9C
    JL_0_5CAA:

    MOVE.b #$0,(A2)
    CMPA.l expandstore,A2
    BEQ.w JL_0_5CE6
      MOVEM.l a6/d0-d1/a0/a1,-(a7)
      MOVE.w D0,-(A7)      ; x-position

      MOVEA.l A1,A2 : SUBA.l A0,A2
      MOVE.b D2,D4                          ; store last read character
      MOVE.w A2,D2
      MOVE.w D2,D5
      SUBQ.w #1,D2
      MOVEA.l expandstore,A0

      MOVE.l A0,-(a7)   ; string
      MOVE.l D0,-(a7)   ; x-pos
      MOVE.l D1,-(a7)   ; y-pos
      MOVE.l D2,-(a7)   ; textlength
      !basic
      MOVE.l (a7)+,d0 : tlength.w = PutD0
      MOVE.l (a7)+,d0 : tposy.w = (PutD0 AND $FFFF)
      MOVE.l (a7)+,d0 : tposx.w = PutD0
      MOVE.l (a7)+,d0 : *textaddr.l = PutD0
      ;log_Print{"call PrintText: " + Str$(tlength) + "... " + Str$(tposx) + ", " + Str$(tposy) + " : [" + Peek.s(*textaddr) + "]"}
      PED_PrintText{*textaddr,tposx,tposy,tlength,AB3Pen(#AB3_cother)}
      !asm
      MOVE.w (A7)+,D0
      MOVEM.l (a7)+,a6/d0-d1/a0/a1
      MOVE.b D4,D2                          ; restore last read character to D2
      ADD.w D5,D0
      SUBQ.w #1,D0
      TST.b D2
      BEQ.w exit_print_tokenized_text
    JL_0_5CE6:
    TST.b D2
    BEQ.w exit_print_tokenized_text

    ;find string state
    SUBQ.w #1,A1
    MOVEA.l A1,A0
    MOVEA.l expandstore,A2
  TST.b D2 
  BPL.b JL_0_5C9C

  a_loop:
    MOVE.b (A1)+,D2
    BEQ.w JL_0_5D0A
    BPL.w JL_0_5D0A
      BCLR #$7,D2
      MOVE.b D2,(A2)+
  BRA.b a_loop
  JL_0_5D0A:

  MOVE.b #$0,(A2)
  CMPA.l expandstore,A2
  BEQ.w exit_print_tokenized_text

  MOVE.w D0,-(A7)                   ; get x position
  MOVEA.l A1,A2
  SUBA.l A0,A2
  MOVE.b D2,D4
  MOVE.w A2,D2
  MOVE.w D2,D5
  SUBQ.w #1,D2
  MOVEA.l expandstore,A0

  !regs2stack
  MOVE.l A0,-(a7)   ; string
  MOVE.l D0,-(a7)   ; x-pos
  MOVE.l D1,-(a7)   ; y-pos
  MOVE.l D2,-(a7)   ; textlength
  !basic
  MOVE.l (a7)+,d0 : tlength.w = PutD0
  MOVE.l (a7)+,d0 : tposy.w = (PutD0 AND $FFFF)
  MOVE.l (a7)+,d0 : tposx.w = PutD0
  MOVE.l (a7)+,d0 : *textaddr.l = PutD0

  ;-- check for classic token and set color else set standard token color
  tcolor.w = AB3Pen(#AB3_ctoken)
  If AB3Pen(#AB3_cclassic) > 0
    !asm
    MOVEA.l expandstore,A0 : MOVE.l A0,D0
    JSR ascii_to_token
    !basic
     _token.l = PutD0
     If PED_CheckForClassicToken{_token} Then tcolor.w = AB3Pen(#AB3_cclassic)
  EndIf

  ;-- print the token
  SetBPen_ \win\RPort, AB3Pen(#AB3_ctokenbackground)
  If pedconfig\bold_tokens
    SetFont_ \win\RPort, \fontB
    SetSoftStyle_ \win\RPort,#FSF_BOLD,#FSF_BOLD
  EndIf
  PED_PrintText{*textaddr,tposx,tposy,tlength,tcolor}

  ;-- reset font and style
  SetBPen_ \win\RPort, AB3Pen(#AB3_cbackground)
  If pedconfig\bold_tokens
    SetFont_ \win\RPort, \font
    SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_BOLD
  EndIf
  !asm
  !stack2regs

  MOVE.w (A7)+,D0 : ADD.w D5,D0 : SUBQ.w #1,D0 ; update x-pos
  MOVE.b D4,D2
  TST.b D2
  BEQ.w exit_print_tokenized_text

  SUBQ.w #1,A1
  MOVEA.l A1,A0
  MOVEA.l expandstore,A2
  BRA.w JL_0_5C9C                ; start loop again

  exit_print_tokenized_text:
  MOVEM.l (A7)+,D4/A1
  MOVE.b comByte__AL_0_8662,$0(A1,D4.W)
RTS

.print_linenumber:
  USEPATH sourceWindow

  dl.l = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) + 1
  linenum$ = Str$(dl)

  lx.w = \BoxLeft - 3 - (FLen(linenum$) * \font\tf_XSize)
  ly.w = \BoxTop + Peek.l(?comLong_DisplayLine) * \font\tf_YSize

  SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)
  RectFill_ \win\RPort,0,ly,\BoxLeft,ly + \font\tf_YSize - 1

  SetAPen_ \win\RPort,AB3Pen(#AB3_screenfill)
  SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
  Move_ \win\RPort,lx,ly + \font\tf_Baseline
  Text_ \win\RPort,&linenum$,FLen(linenum$)

  ;Move_ \win\RPort,0,ly; + \font\tf_Baseline
  ;Draw_ \win\RPort,\BoxLeft,ly

  SetAPen_ \win\RPort,AB3Pen(#AB3_screentext)
  Move_ \win\RPort,\BoxLeft-2,ly
  Draw_ \win\RPort,\BoxLeft-2,ly + \font\tf_YSize
Return


.print_sourceline:                     ; a2: pointer to sourceline
  !basic
  PutReg A2, *sourceline.sourceLine

  If pedconfig\linenumbers Then Gosub print_linenumber

  If *sourceline = 0
    Pop If
    !asm
    RTS
  EndIf

  If Peek.b(*sourceline + 9) <> 0   ; first character of text
    Poke.w ?comWord_ColumnsOffsetTmp,Peek.w(?comWord_ColumnsOffset)
    ;log_Print{">>" + Peek.s(*sourceline+9)}
    GetReg D0,*sourceline + 9
    !asm
    MOVE.l D0,A0
    MOVEQ.l #0,D0
    MOVE.l comLong_DisplayLine,d1
    JSR print_complete_line         ; d0:x, d1:y, a0: text
    !basic
  Else
    USEPATH sourceWindow
    SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground) 
    ;SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    xMin = \BoxLeft
    yMin = \BoxTop + Peek.l(?comLong_DisplayLine) * \font\tf_YSize
    xMax = \BoxWidth
    yMax = yMin + \font\tf_YSize - 1
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ \win\RPort, xMin, yMin, xMax, yMax
   Else
      log_Print{"illegal area for JL_0_5E72!",#log_error}
      log_Print{Str$(xMin) + ", " + Str$(xMax)}
      log_Print{Str$(yMin) + ", " + Str$(yMax)}
    EndIf
    Move_ \win\RPort, 0, Peek.l(?comLong_DisplayLine) * \font\tf_YSize + \font\tf_YSize ; move cursor to next line

    Poke.l Peek.l(?textbufferPrint),0
  EndIf                                                                                                                                                                                                                                                ;


  ;-- copy current printed line to textbuffer
  tmpColumn.w = Peek.w(?comWord_Column)                           ; save Columnpos as it is changed for process_highlighting

  char.b = Peek.b(Peek.l(?textbufferPrint))
  If char <> 0
    tmpD2.w = 0
    tmpD3.w = 0
    textBufferPos.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
    If char <> Peek.b(?comByte_LabelIdentifier) Then Goto jump_in
    Gosub copy_to_textBuffer
    Repeat
      tmpD2 + 1
      char = Peek.b(Peek.l(?textbufferPrint) + tmpD2)
      If char <> 0
jump_in:
        Gosub copy_to_textBuffer
      End If
    Until char = 0
  EndIf

  ;-- do highlighting
  !asm
  BSR process_highlighting
  !basic

  ; -- handle blockmark - seems useless ?
  ;If Peek.l(?comLong_BlockEndY)<> $ffffFFFF
  ;  If Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) > Peek.l(?comLong_BlockStartY)
  ;    If Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) < Peek.l(?comLong_BlockEndY)
  ;      While tmpD3 <= \visibleColumns
  ;        ; fill with blanks
  ;        ;  MOVEQ.l #$20,D0 (displaylineoffset + displayline)
  ;        Poke.w ?comWord_Column,tmpD3
  ;        tmpD3 + 1
  ;      Wend
  ;    EndIf
  ;  EndIf
  ;EndIf

  Poke.w ?comWord_Column,tmpColumn                            ; restore Columnpos
  !asm
RTS

.copy_to_textBuffer:
  Poke.b textBufferPos + tmpD2, char
  If tmpD2 <= Peek.w(?comWord_ColumnsOffset)
    If tmpD3 <= Peek.w(?visiblecolumns)
      Poke.w ?comWord_Column,tmpD3
      tmpD3 + 1
    EndIf
  EndIf
Return


;
;.print_sourceline_old:
;  MOVE.l A2,-(a7)
;  !basic
;If pedconfig\linenumbers Then Gosub print_linenumber
;;VWait 15
;
;  !asm
;  MOVE.l (a7)+,A2
;
;
;  CMPA.l #$0,A2
;  BNE.w JL_0_5E32
;    RTS
;  JL_0_5E32:
;
;  LEA $9(A2),A2
;  TST.b (A2)
;  BEQ.w JL_0_5E72                      ; print textline
;;    MOVEM.l D1/A0-A3/A6,-(A7)
;    MOVEA.l A2,A0
;
;    MOVEQ.l #$00,D0
;    MOVEQ.l #$00,D1 : MOVE.l comLong_DisplayLine,D1
;
;    MOVE.w comWord_ColumnsOffset,comWord_ColumnsOffsetTmp
;    JSR print_complete_line            ; inputs: d0:x, d1:y, a0: text
;;    MOVEM.l (A7)+,D1/A0-A3/A6
;    MOVEA.l textbufferPrint,A2
;    BRA.w JL_0_5E78
;  JL_0_5E72:                           ; draw an empty line
;    !basic
;    USEPATH sourceWindow
;    SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)
;    xMin.w = \BoxLeft
;    yMin = \BoxTop + Peek.l(?comLong_DisplayLine) * \font\tf_YSize
;    xMax = \BoxWidth
;    yMax = yMin + \font\tf_YSize - 1
;    If (xMax => xMin) AND (yMax => yMin)
;      RectFill_ \win\RPort, xMin, yMin, xMax, yMax
;    Else
;      log_Print{"illegal area for JL_0_5E72!",#log_error}
;      log_Print{Str$(xMin) + ", " + Str$(xMax)}
;      log_Print{Str$(yMin) + ", " + Str$(yMax)}
;    EndIf
;
;    Move_ \win\RPort, 0, Peek.l(?comLong_DisplayLine) * \font\tf_YSize + \font\tf_YSize ; move cursor to next line
;    !asm
;    MOVEA.l textbufferPrint,A2
;    CLR.l (A2)
;  JL_0_5E78:
;
;  MOVE.w comWord_Column,-(A7)
;
;  MOVEA.l textbufferaddr,A3 : ADDA.w comWord_TextBufferOffset,A3
;  MOVEQ.l #$00,D3
;  MOVEQ.l #$00,D2
;  MOVE.b (A2)+,D0
;  BEQ.w JL_0_5EA0
;    CMP.b comByte_LabelIdentifier,D0
;    BNE.w JL_0_5E9A
;      JSR JL_0_5EE0
;      JL_0_5E92:
;        ADDQ.w #1,D2
;        MOVE.b (A2)+,D0                  ;copy to viewbuffer
;        BEQ.w JL_0_5EA0
;          JL_0_5E9A:
;          JSR JL_0_5EE0
;      BRA.b JL_0_5E92
;  JL_0_5EA0:
;
;  BSR process_highlighting
;
;  ;-- Handle blockmark
;  CMPI.l #$ffffFFFF,comLong_BlockEndY
;  BEQ.w aJL_0_5ED8
;    MOVE.l comLong_DisplayLineOffset,D0 : ADD.l comLong_DisplayLine,D0
;    CMP.l comLong_BlockStartY,D0
;    BCS.w aJL_0_5ED8
;      CMP.l comLong_BlockEndY,D0
;      BHI.w aJL_0_5ED8
;        aJL_0_5EC4:
;          CMP.w visiblecolumns,D3
;          BCC.w aJL_0_5ED8
;            MOVEQ.l #$20,D0
;            MOVE.w D3,comWord_Column
;            ADDQ.w #1,D3
;        BRA.b aJL_0_5EC4
;  aJL_0_5ED8:
;
;  MOVE.w (A7)+,comWord_Column
;RTS
;
;
;JL_0_5EE0:
;  MOVE.b D0,$0(A3,D2.W)
;  JL_0_5EE4:
;  CMP.w comWord_ColumnsOffset,D2
;  BCS.w JL_0_5EFC
;    CMP.w visiblecolumns,D3
;    BCC.w JL_0_5EFC
;      MOVE.w D3,comWord_Column
;      ADDQ.w #1,D3
;  JL_0_5EFC:
;RTS

;JL_0_5EFE:
;  TST.w comWord_DoTokenize
;  BEQ.b JL_0_5EE0
;    TST.b D0
;    BPL.b JL_0_5EE0
;      LSL.w #8,D0
;      MOVE.b (A2)+,D0
;      EXG.l A5,A3
;      JSR token_to_ascii
;      EXG.l A5,A3
;
;  JL_0_5F16:
;    MOVE.b (A5)+,D0
;    BEQ.w JL_0_5F2C
;    MOVE.b D0,$0(A3,D2.W)
;    BSET #$7,$0(A3,D2.W)
;    BSR.b JL_0_5EE4
;    ADDQ.w #1,D2
;  BRA.b JL_0_5F16
;
;  JL_0_5F2C:
;  SUBQ.w #1,D2
;RTS

.process_highlighting:
  MOVEM.l a2/d2,-(a7)
  !basic
  If NOT pedconfig\highlighting Then Goto skip_highlighting

  lineaddr = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
  ;log_Print{"process highlighting -  textbufferaddr:"}
  ;log_Print{Peeks$(lineaddr,20)}
  runner.w = 0 : exit_highlight.b = False
  Repeat
    curchar.s = Chr$(Peek.b(lineaddr + runner)) : textlen.w = 0
    Select curchar
    Case ";"
      ;skip parsing as we have a comment here
      ;log_Print{"comment found" + Peeks$(lineaddr + runner,40)}
      exit_highlight = True

    Case Chr$($22)
      If AB3Pen(#AB3_cstring) <> AB3Pen(#AB3_cother)
        ;log_Print { "search string [" + Peeks$(lineaddr + runner + 1,40)+ "]"}
        textlen = FindByte(Peek.s(lineaddr + runner + 1),$22) + 1   ; search for string mark
        If textlen
          ;log_Print { "string [" + Peeks$(lineaddr+runner+1 ,textlen) + "]" + Str$(textlen)}
          sourceWindow\ColumnsOffset = Peek.w(?comWord_ColumnsOffset)
          sourceWindow\DisplayLine = Peek.l(?comLong_DisplayLine)
          PED_PrintHighlight{lineaddr + runner, runner , textlen, AB3Pen(#AB3_cstring), 0}
        EndIf
      EndIf

    Case "{"
      ;log_Print{"statement found ??"}
      If AB3Pen(#AB3_cfunction) <> AB3Pen(#AB3_cother)
        ; skip all spaces backwards
        i = -1
        While (runner+i => 0) AND Peek.b(lineaddr + runner + i) = 32
          ;log_Print{Str$(runner+i) + " ["+Peeks$(lineaddr+runner+i,1)+"]"}
          i - 1
        Wend
        If runner+i => 0
          For i.l = runner + i To 0 Step -1
            checkchr.b = Peek.b(lineaddr + i)
            ;log_Print{"function checking [" + Chr$(checkchr) +  "] in "+ Peeks$(lineaddr + i,20)}
            If checkchr = @"!" OR (checkchr < 0) ; check if we have a token before "{"
              Pop For : Pop If : Pop If : Pop If
              Goto Exit_function
            EndIf

            If !PED_CheckUnAllowedChar{checkchr} OR (i = 0)
              textlen = runner - i
              sourceWindow\ColumnsOffset = Peek.w(?comWord_ColumnsOffset)
              sourceWindow\DisplayLine = Peek.l(?comLong_DisplayLine)
              PED_PrintHighlight{lineaddr + i, i , textlen, AB3Pen(#AB3_cfunction), 0}
              Pop For : Pop If : Pop If : Pop If
              Goto Exit_function
            EndIf
          Next i
        EndIf
        Exit_function:
        instring.b = False
        textlen = 0
      EndIf


    Case "!"
      ;log_Print{"macro found: " + Peeks$(lineaddr,20)}
      If AB3Pen(#AB3_cmacro) <> AB3Pen(#AB3_cother)
        For i.l = runner + 1 To #MAX_Columns - 1
          ;log_Print{"macro checking [" + Peeks$(lineaddr + i,1) +  "] in "+ Peeks$(lineaddr,20)}
          If !PED_CheckUnAllowedChar{Peek.b(lineaddr + i)}
            textlen = i - runner
            sourceWindow\ColumnsOffset = Peek.w(?comWord_ColumnsOffset)
            sourceWindow\DisplayLine = Peek.l(?comLong_DisplayLine)
            PED_PrintHighlight{lineaddr + runner, runner, textlen, AB3Pen(#AB3_cmacro), 0}
            Pop For : Pop If
            Goto Exit_macro
          EndIf
        Next i
        Exit_macro:
      EndIf

    Case "#"
      If AB3Pen(#AB3_cconstant) <> AB3Pen(#AB3_cother)
        For i.l = runner + 1 To #MAX_Columns - 1
          checkchr.b = Peek.b(lineaddr + i)

          If checkchr = $22 Then instring.b = NOT instring

          If instring = False
            ;log_Print{"macro checking [" + Chr$(checkchr) +  "] in "+ Peeks$(lineaddr,20)}
            If checkchr <> @"$" AND checkchr <> @"%"; OR checkchr = @"-"
              If !PED_CheckUnAllowedChar{Peek.b(lineaddr + i)}
                textlen = i - runner
                sourceWindow\ColumnsOffset = Peek.w(?comWord_ColumnsOffset)
                sourceWindow\DisplayLine = Peek.l(?comLong_DisplayLine)
                PED_PrintHighlight{lineaddr + runner, runner , textlen, AB3Pen(#AB3_cconstant), 0}
                Pop For : Pop If : Pop If : Pop If
                Goto Exit_constant
              EndIf
            EndIf
          EndIf
        Next i
        Exit_constant:
        instring.b = False
      EndIf

    Case "\"
      If AB3Pen(#AB3_cnewtype) <> AB3Pen(#AB3_cother)
        For i.l = runner + 1 To #MAX_Columns - 1
          checkchr.b = Peek.b(lineaddr + i)

          If checkchr = $22 Then instring.b = NOT instring

          If instring = False
            ;log_Print{"macro checking [" + Chr$(checkchr) +  "] in "+ Peeks$(lineaddr,20)}
            If checkchr <> @"\"
              If !PED_CheckUnAllowedChar{Peek.b(lineaddr + i)}
                textlen = i - runner
                sourceWindow\ColumnsOffset = Peek.w(?comWord_ColumnsOffset)
                sourceWindow\DisplayLine = Peek.l(?comLong_DisplayLine)
                PED_PrintHighlight{lineaddr + runner, runner , textlen, AB3Pen(#AB3_cnewtype), 0}
                Pop For : Pop If : Pop If : Pop If
                Goto Exit_newtype
              EndIf
            EndIf
          EndIf
        Next i
        Exit_newtype:
        instring.b = False
       EndIf

    End Select
    If textlen Then runner = runner + textlen - 1
    runner + 1
  Until exit_highlight OR runner >= #MAX_Columns - 1
  skip_highlighting:
  !asm
  ;!stack2regs
  MOVEM.l (a7)+,a2/d2
Return




.parse_line:                         ; input A2: textstring, results: comPtr_Temp_TokenString1 = parsed string, D5: length of string
  MOVEA.l comPtr_Temp_TokenString1,A1
  MOVE.l A1,-(A7)
  MOVE.w #MAX_Columns,D1 : SUBQ.w #1,D1

  MOVE.w comWord_DoTokenize,D0
  BNE.w JL_0_5F68

    MOVEA.l A1,A0                      ; ---- just copy the textstring to comPtr_temp_tokenstring
    JL_0_5F48:
      MOVE.b (A2)+,(A0)+
      CMPI.b #$20,-$1(A0)              ; space
      BEQ.w JL_0_5F56
        MOVEA.l A0,A1
      JL_0_5F56:
    DBF D1,JL_0_5F48

    JL_0_5F5A:                         ; return the copied string
      CLR.b (A1)+
      MOVE.l A1,D5
      SUB.l (A7)+,D5
      RTS

  tokenizeA1:                         ;A1 string to parse
    MOVE.l A1,-(A7)
  BRA.w JL_0_5F72
  
  JL_0_5F68:
  CMPI.b #$20,$0(A2,D1.W)              ; -------  check spaces from right to left
  BNE.w JL_0_5F7E
    JL_0_5F72:
    SUBQ.w #1,D1
    BPL.b JL_0_5F68
      ADDQ.w #4,A7
      CLR.b (A1)
      MOVEQ.l #$01,D5                  ; only spaces in string, so return length 1 as we dont store only 1 space
      RTS
  JL_0_5F7E:

  MOVE.l A4,-(A7)                      ; currentLine to Stack
  MOVEQ.l #$00,D0
  MOVE.w D0,comWord__AL_0_86B8
  CLR.b instring2

  JL_0_5F88:
    MOVE.b (A2)+,D2
    CMP.b #$22,d2                      ; check for string "
    BNE 'l10
      NOT.b instring2
   'l10
    TST.b instring2
    BNE 'l11
      BCLR #$7,D2                      ;morechar
   'l11
    CMP.b comByte__L_0_8BCD,D2
    BNE.w JL_0_5FA2

    JL_0_5F96:
    NOT.w comWord__AL_0_86B8

    JL_0_5F9C:
    JSR JL_0_60B2
    BRA.b JL_0_5F88

    JL_0_5FA2:
    MOVE.w comWord__AL_0_86B8,D4
    BNE.b JL_0_5F9C
    JSR checkForLetter
    BEQ.w JL_0_6030                  ; go to tokenfinder

    .temp1
    JL_0_5FB0:
    CMP.b #$30,d2                    ;number 0-9
    BLT 'l10
      CMP.b #$39,d2
      BGT 'l10
        BRA JL_0_6066
   'l10:
    CMP.b #"_",D2
    BEQ.w JL_0_6066
      CMP.b #$2E,D2                  ; "."
      BEQ.w JL_0_6066
        CMP.b #"\",D2
        BEQ.w JL_0_6066
          CMP.b comByte__L_0_8BCF,D2
          BNE.w JL_0_5FDC

    JL_0_5FD0:
      JSR JL_0_60B2
      MOVE.b (A2)+,D2
      BCLR #$7,D2
    BRA.b JL_0_5FD0

    JL_0_5FDC:
    CMP.b #"'",d2
     BEQ JL_0_5FE4
    CMP.b #"#",D2
     BEQ.w JL_0_5FE4                 ;jump notokenize
    CMP.b #"$",D2                    ;tokenize $ #
     BNE.w JL_0_6018

    JL_0_5FE4:
      JSR JL_0_60B2
      MOVE.b (A2)+,D2
      BCLR #$7,D2
      CMP.b #$22,d2                  ; "
      BNE 'l10
        BRA JL_0_5FE4
     'l10
      CMP.b #"_",d2
       BEQ JL_0_5FE4
      CMP.b #"0",D2
       BCS.w JL_0_6018
      CMP.b #"z",D2                  ;f
       BHI.w JL_0_6018
      CMP.b #"9",D2
       BLS.b JL_0_5FE4
      CMP.b #"A",D2
       BCS.w JL_0_6018
      CMP.b #"a",D2
       BCC.b JL_0_5FE4
      CMP.b #"Z",D2                  ;F
    BLS.b JL_0_5FE4

    JL_0_6018:
    JSR JL_0_60B2
    MOVE.b (A2)+,D2
    CMP.b #$22,d2
    BNE 'l10
      NOT.b instring2
   'l10
    TST.b instring2
    BNE 'l11
      BCLR #$7,D2                      ;morechar
   'l11
    CMP.b comByte__L_0_8BCD,D2
    BEQ.w JL_0_5F96

    JSR checkForLetter
    BNE.b JL_0_5FB0

    JL_0_6030:                         ; ------ start tokenizing
    SUBQ.w #1,A2
    MOVEA.l comPtr_TokenBase,A3

    JL_0_6036:
    MOVEA.l A2,A4
    MOVE.l A3,-(A7)
    ADDQ.w #6,A3

    JL_0_603C:
    MOVE.b (A3)+,D3
    BEQ.w JL_0_6082
      MOVE.b (A4)+,D2
      BCLR #$7,D2
      ORI.b #$20,D3
      ORI.b #$20,D2
      CMP.b D3,D2
      BEQ.b JL_0_603C

      JL_0_6054:
      MOVEA.l (A7)+,A3
      MOVE.l (A3),D3
      BEQ.w JL_0_6060
      MOVEA.l D3,A3
      BRA.b JL_0_6036

      JL_0_6060:
      MOVE.b (A2)+,D2
      BCLR #$7,D2

      JL_0_6066:
      JSR JL_0_60B2
      MOVE.b (A2)+,D2
      CMP.b #$22,d2
      BNE 'l10
      NOT.b instring2
    'l10
      TST.b instring2
      BNE 'l11
      BCLR #$7,D2            ;morechar
    'l11
      CMP.b comByte__L_0_8BCD,D2
      BEQ.w JL_0_5F96
      JSR checkForLetter
      BEQ.b JL_0_6066
      BRA.w JL_0_5FB0
    JL_0_6082:

    MOVE.b (A4),D2
    BCLR #$7,D2
    JSR checkForLetter            ;ascii to token
     BEQ.b JL_0_6054
    CMP.b #$30,d2            ;number 0-9
     BLT 'l10
    CMP.b #$39,d2
     BGT 'l10
    BRA JL_0_6054
   'l10:
    CMP.b #"_",D2
     BEQ.b JL_0_6054
    MOVEA.l (A7)+,A3
    ADDQ.w #4,A3
    MOVE.b (A3)+,(A1)
    BSET #$7,(A1)+
    MOVE.b (A3),(A1)+
    MOVE.l A4,D4
    SUB.l A2,D4
    ADD.w D4,D0
    CMP.w D1,D0
     BHI.w JL_0_60C0
    MOVEA.l A4,A2
  BRA.w JL_0_5F88

JL_0_60B2:
  MOVE.b D2,(A1)+
  ADDQ.w #1,D0
  CMP.w D1,D0
  BHI.w JL_0_60BE
    RTS
  JL_0_60BE:
  ADDQ.w #4,A7

  JL_0_60C0:
  MOVEA.l (A7)+,A4
BRA.w JL_0_5F5A


checkForLetter:
  CMP.b #"A",D2
   BCS.w JL_0_60E8
  CMP.b #"z",D2
   BHI.w JL_0_60E8
  CMP.b #"[",D2
   BCS.w JL_0_60E6
  CMP.b #"a",D2
   BCS.w JL_0_60E8

  JL_0_60E6:
  CMP.w D2,D2

  JL_0_60E8:
RTS


.increase_DisplayLine:
  ADDQ.l #1,comLong_DisplayLine
  MOVEQ.l #$00,D0 : MOVE.w #MAX_Columns,D0 : ADD.w D0,comWord_TextBufferOffset
RTS

.decrease_DisplayLine:
  SUBQ.l #1,comLong_DisplayLine
  MOVEQ.l #$00,D0 : MOVE.w #MAX_Columns,D0 : SUB.w D0,comWord_TextBufferOffset
RTS

.scroll_rest_of_line_left:
  xPos.w = Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)
  yPos.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
  ;log_Print{"scroll line to left xpos "+ Str$(xPos)+  ", ypos " + Str$(yPos) + " BlockEndY " +Str$(Peek.l(?comLong_BlockEndY))}

  ;-- scroll block
  If Peek.l(?comLong_BlockEndY) > -1
    If (yPos <= Peek.l(?comLong_BlockEndY)) AND (yPos >= Peek.l(?comLong_BlockStartY))
      If yPos = Peek.l(?comLong_BlockStartY)
        If xPos <= Peek.w(?comWord_BlockStartX) Then Poke.w ?comWord_BlockStartX, Peek.w(?comWord_BlockStartX) - 1
        If Peek.w(?comWord_BlockEndX) <> #MAX_Columns - 1
          If xPos <= Peek.w(?comWord_BlockEndX)
            Poke.w ?comWord_BlockEndX, Peek.w(?comWord_BlockEndX) - 1
            xPos = \visibleColumns + Peek.w(?comWord_ColumnsOffset)
            If xPos > Peek.w(?comWord_BlockEndX)
              sourceWindow\Column = Peek.w(?comWord_Column)
              sourceWindow\DisplayLine = Peek.l(?comLong_DisplayLine)
              PED_ScrollHorizontal{#SCROLL_LEFT,  #SCROLL_CURRENT_LINE}
            EndIf
          Else
            sourceWindow\Column = Peek.w(?comWord_Column)
            sourceWindow\DisplayLine = Peek.l(?comLong_DisplayLine)
            PED_ScrollHorizontal{#SCROLL_LEFT,  #SCROLL_CURRENT_LINE}
          EndIf
        EndIf
        USEPATH sourceWindow
        SetBPen_ \win\RPort,3
      EndIf
    EndIf
  EndIf

  sourceWindow\Column = Peek.w(?comWord_Column)
  sourceWindow\DisplayLine = Peek.l(?comLong_DisplayLine)
  PED_ScrollHorizontal{#SCROLL_LEFT,  #SCROLL_CURRENT_LINE}

Return


.update_blockmark_left:
  If Peek.l(?comLong_BlockEndY) > -1
    ;        log_Print{" blockendX: " + Str$(Peek.w(?comWord_BlockEndX))}
    ;        log_Print{" blockendy: " + Str$(Peek.w(?comLong_BlockEndY))}
    ;        log_Print{" blockstartX: " + Str$(Peek.w(?comWord_BlockStartX))}
    xMin = Peek.w(?comWord_ColumnsOffset)
    yMin = Peek.l(?comLong_DisplayLineOffset)
    yMax = yMin + Peek.l(?viewablelines)
    If (yMin <= Peek.l(?comLong_BlockEndY)) AND (yMax >= Peek.l(?comLong_BlockStartY))
      If Peek.l(?comLong_BlockStartY) = Peek.l(?comLong_BlockEndY)
        Gosub JL_0_66F2
        Pop If
        Return
      EndIf
      Gosub JL_0_6658   ; draw missing blockmark in first line while scrollin left

      yMin = Peek.l(?comLong_BlockStartY) - Peek.l(?comLong_DisplayLineOffset) + 1
      yMax = Peek.l(?comLong_BlockEndY) - Peek.l(?comLong_DisplayLineOffset)
      If yMax > Peek.l(?viewablelines) Then yMax = Peek.l(?viewablelines)

      If yMax <= yMin
        Gosub JL_0_669A ; update missing blockmark in last line
        Pop If
        Return
      EndIf
      Gosub JL_0_669A

      ;-- draw left blockparts while scrolling leftside except first and last line
      xMin = 0
      yMin = (Peek.l(?comLong_BlockStartY)-Peek.l(?comLong_DisplayLineOffset) + 1) * \font\tf_YSize

      yMax =  Peek.l(?comLong_BlockEndY) - Peek.l(?comLong_DisplayLineOffset)
      If yMax > Peek.l(?viewablelines) Then yMax = Peek.l(?viewablelines)
      xMax = xMin + \font\tf_YSize * 2 - 1  ; we scroll always 2 lines
      yMax = yMax * \font\tf_YSize - 1
      If (xMax => xMin) AND (yMax => yMin)
         RectFill_ *sourcerp,sourceWindow\BoxLeft + xMin,sourceWindow\BoxTop + yMin,sourceWindow\BoxLeft + xMax,sourceWindow\BoxTop + yMax
      Else
        log_Print{"illegal area for update blockmark left"}
      EndIf
      ;    SetAPen_ *sourcerp,5
      ;    SetDrMd_ *sourcerp,#JAM1
      ;    Move_ *sourcerp,sourceWindow\BoxLeft + xMin,yMin
      ;    Draw_ *sourcerp,sourceWindow\BoxLeft + xMax,yMax
      ;    SetDrMd_ *sourcerp,#COMPLEMENT
    EndIf
  EndIf
Return


JL_0_6658:      ; draw missing blockparts in first line when scrolling left
  If xMin >= Peek.w(?comWord_BlockStartX)
    yMaxold = yMax : xMaxold = xMax : yMinold = yMin : xMinold = xMin

    xMin = 0
    xMax = xMin + \font\tf_XSize * 2 - 1
    yMin = (Peek.l(?comLong_BlockStartY)-Peek.l(?comLong_DisplayLineOffset)) * \font\tf_YSize
    yMax = yMin + \font\tf_YSize - 1
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ *sourcerp,sourceWindow\BoxLeft + xMin,sourceWindow\BoxTop + yMin,sourceWindow\BoxLeft + xMax,sourceWindow\BoxTop + yMax
    Else
      log_Print{"illegal area for JL_0_6658"}
    EndIf

    yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return


JL_0_669A:  ; update missing blockmark in last line
  If xMin <= Peek.w(?comWord_BlockEndX)
    ;yMaxold = yMax : xMaxold = xMax : yMinold = yMin : xMinold = xMin
    xMin      = 0
    xmax_temp.w = (Peek.w(?comWord_BlockEndX)-Peek.w(?comWord_ColumnsOffset)+1) * \font\tf_XSize - 1
    If xmax_temp < 2 Then xmax_temp = 2
    xmax_temp = xmax_temp * \font\tf_XSize - 1
    xMax      = xMin + xmax_temp
    yMin      = (Peek.l(?comLong_BlockEndY)-Peek.l(?comLong_DisplayLineOffset)) * \font\tf_YSize
    yMax      = yMin + \font\tf_YSize - 1
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ *sourcerp,sourceWindow\BoxLeft + xMin,sourceWindow\BoxTop + yMin,sourceWindow\BoxLeft + xMax,sourceWindow\BoxTop + yMax
    Else
      log_Print{"illegal area for JL_0669A"}
    EndIf
    ;yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return

JL_0_66F2:
  If (xMin >= Peek.w(?comWord_BlockStartX)) AND (xMin <= Peek.w(?comWord_BlockEndX))
    ;yMaxold = yMax : xMaxold = xMax : yMinold = yMin : xMinold = xMin

    xMin      = 0
    xmax_temp.w = (Peek.w(?comWord_BlockEndX)-Peek.w(?comWord_ColumnsOffset)+1) * \font\tf_XSize - 1
    If xmax_temp < $2 Then xmax_temp = $2
    xmax_temp = xmax_temp * \font\tf_XSize - 1
    xMax      = xMin + xmax_temp
    yMin      = (Peek.l(?comLong_BlockStartY)-Peek.l(?comLong_DisplayLineOffset)) * \font\tf_YSize
    yMax      = yMin + \font\tf_YSize - 1
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ *sourcerp,sourceWindow\BoxLeft + xMin,sourceWindow\BoxTop + yMin,sourceWindow\BoxLeft + xMax,sourceWindow\BoxTop + yMax
    Else
      log_Print{"illegal area for JL_0_66F2"}
    EndIf
    ;yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return


.draw_new_columns_left:
  JSR save_cursorposition

  CLR.w comWord_ColumnsOffsetTmp
  CLR.w comWord_Column
  CLR.l comLong_DisplayLine
  CLR.w comWord_TextBufferOffset
  MOVEA.l textbufferaddr,A5 : ADDA.w comWord_ColumnsOffset,A5
  MOVE.l viewablelines,D2 : SUBQ.w #1,D2


  JL_0_67AA:
    MOVEA.l AL_0_5B9E,A0
    MOVE.b (A5),(A0)
    MOVE.b $1(A5),$1(A0)

    MOVEQ.l #$00,D0 : MOVE.w comWord_Column,D0 : MULU fontWidth,d0
    MOVE.l comLong_DisplayLine,D1 ;: MULU fontHeight,D1
    ST noDetokenizing                                                                                                                                                                                                                                    

    MOVEM.l D2/A5,-(A7)
    MOVEM.l d0-d2/a0,-(a7)
    MOVE.l textbufferaddr,a0 : ADD.w comWord_TextBufferOffset,a0
    CLR.b instring2
    MOVE.w #0,d2
    CMP.l #0,a0
    BEQ 'l2b
    MOVE.w comWord_ColumnsOffset,d1
   'l1
      CMP.w d1,d2
      BGE 'l2b
      MOVE.b (a0)+,d0
      CMP.b #$22,d0
      BNE 'l2
      NOT.b instring2
     'l2
      ADDQ.w #1,d2
    BRA 'l1
   'l2b
    MOVEM.l (a7)+,d0-d2/a0

    MOVE.b #$1,keepstring
    JSR print_complete_line          ; print the text ; d0:x, d1:y, a0: text
    CLR.b keepstring
    MOVEM.l (A7)+,D2/A5
    BSR process_highlighting        ; beim markieren nicht verwenden, da sonst
                                     ; unter umstaenden mit falscher Hintergrundfarbe ueber den
                                     ; Block gemalt wird.
    SF noDetokenizing
    MOVEQ.l #$00,D0
    MOVE.w #MAX_Columns,D0
    ADDA.w D0,A5
    ADD.w D0,comWord_TextBufferOffset
    ADDQ.l #1,comLong_DisplayLine
  DBF D2,JL_0_67AA
  JSR restore_cursorposition
RTS

.scroll_right:
  Gosub cursor_off
  USEPATH sourceWindow
  dx.w = -(\font\tf_XSize * \scrollSize)
  dy.w = 0
  xMin.w = \BoxLeft
  yMin.w = \BoxTop
  xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
  yMax.w = \BoxTop + Peek.l(?viewablelines) * \font\tf_YSize - 1
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax

  Gosub ScrollDelay
  !asm
  JSR draw_new_columns_left        ; draw text after scroll
  !basic
  Gosub update_blockmark_left          ; blockmark selected text after scrolling
  Gosub cursor_on
Return

.scroll_left:
  ;Gosub cursor_off
  USEPATH sourceWindow
  dx.w = \font\tf_XSize * \scrollSize
  dy.w = 0
  xMin.w = \BoxLeft
  xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
  yMin.w = \BoxTop
  yMax.w = \BoxTop + Peek.l(?viewablelines) * \font\tf_YSize - 1
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax

  Gosub ScrollDelay
  !asm
  JSR draw_new_columns_right
  !basic
  Gosub update_blockmark_right
  ;Gosub cursor_on
Return


.update_blockmark_right:
  If Peek.l(?comLong_BlockEndY) > -1            ; check if we have a Blockmark
    xMin = Peek.w(?comWord_ColumnsOffset) + \visibleColumns - 2 ;d0
    yMin = Peek.l(?comLong_DisplayLineOffset)       ;d1
    yMax = yMin + Peek.l(?viewablelines)            ;d2

    ;log_Print{"blockstartX: " + Str$(Peek.w(?comWord_BlockStartX))}
    ;log_Print{"blockstartY: " + Str$(Peek.l(?comLong_BlockStartY))}
    ;log_Print{"blockendX: " + Str$(Peek.w(?comWord_BlockEndX))}
    ;log_Print{"blockendY: " + Str$(Peek.l(?comLong_BlockEndY))}
    ;log_Print{"xmin:" + Str$(xMin)+" yMin:" + Str$(yMin)+ " yMax: " + Str$(yMax)}
    If (yMin <= Peek.l(?comLong_BlockEndY)) AND (yMax >= Peek.l(?comLong_BlockStartY))
      If Peek.l(?comLong_BlockStartY) = Peek.l(?comLong_BlockEndY)
        Gosub JL_0_695E
      Else
        Gosub JL_0_68C4
        yMin = Peek.l(?comLong_BlockStartY) - Peek.l(?comLong_DisplayLineOffset) + 1
        yMax = Peek.l(?comLong_BlockEndY) - Peek.l(?comLong_DisplayLineOffset)
        If yMax > Peek.l(?viewablelines) Then yMax = Peek.l(?viewablelines)

        If yMax < yMin      ; when does that happen???
          Gosub JL_0_6906   ; update missing block last line
          Pop If : Return
        EndIf
        Gosub JL_0_6906 ;update missing block last line

        ; add missing block on the right except first and last line
        ;xMin = Peek.w(?source_BoxLeft) + xMin * \font\tf_XSize
        xMin = (xMin - Peek.w(?comWord_ColumnsOffset)) * \font\tf_XSize
        xMax = xMin + \font\tf_XSize * 2 - 1
        yMin = yMin * \font\tf_YSize
        yMax = yMax * \font\tf_YSize - 1
        If (xMax => xMin) AND (yMax => yMin)
          RectFill_ *sourcerp, sourceWindow\BoxLeft + xMin, sourceWindow\BoxTop + yMin,sourceWindow\BoxLeft + xMax, sourceWindow\BoxTop + yMax
        Else
          log_Print{"illegal area for update_blockmark right"}
        EndIf
      EndIf
    EndIf
  EndIf
Return

.JL_0_68C4:
  If xMin >= Peek.w(?comWord_BlockStartX)
    yMaxold.l = yMax : xMaxold.l = xMax : yMinold.l = yMin : xMinold.l = xMin

    xMin = (xMin - Peek.w(?comWord_ColumnsOffset)) * \font\tf_XSize
    xMax = xMin + \font\tf_XSize * 2 - 1
    yMin = Peek.l(?comLong_BlockStartY) - Peek.l(?comLong_DisplayLineOffset)
    yMin = yMin * \font\tf_YSize
    yMax = yMin + \font\tf_YSize-1
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ *sourcerp, sourceWindow\BoxLeft + xMin, sourceWindow\BoxTop + yMin, sourceWindow\BoxLeft + xMax, sourceWindow\BoxTop + yMax
    Else
      log_Print{"illegal area for JL_0_68C4"}
    EndIf

    yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return

.JL_0_6906: ; update mission block last line
  If xMin <= Peek.w(?comWord_BlockEndX) + 1
    yMaxold.l = yMax : xMaxold.l = xMax : yMinold.l = yMin : xMinold.l = xMin

    d4.l = Peek.w(?comWord_BlockEndX) - xMin + 1 + 2
    If d4 > 2 Then d4 = 2     ; we scroll always 2 characters
    d4 = d4 * \font\tf_XSize

    xMin = xMin - Peek.w(?comWord_ColumnsOffset)
    xMin = xMin * \font\tf_XSize
    xMax = xMin + d4 - 1
    yMin = Peek.l(?comLong_BlockEndY) - Peek.l(?comLong_DisplayLineOffset)
    yMin = yMin * \font\tf_YSize
    yMax = yMin + \font\tf_YSize - 1
    ;log_Print{"d4: " +Str$(d4) + " blockendX: " + Str$(Peek.w(?comWord_BlockEndX))}
    ;log_Print{"d4: " +Str$(d4) + " blockendy: " + Str$(Peek.l(?comLong_BlockEndY))}
    ;log_Print{"d4: " +Str$(d4) + " blockstartX: " + Str$(Peek.w(?comWord_BlockStartX))}
    ;log_Print{">> xMin:"+Str$(xMin) + " ymin:"+Str$(yMin) + " xMax:"+Str$(xMax) + " ymax:"+Str$(yMax)}
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ *sourcerp, sourceWindow\BoxLeft + xMin, yMin, sourceWindow\BoxTop + sourceWindow\BoxLeft + xMax, sourceWindow\BoxTop + yMax
    Else
      log_Print{"illegal area for JL_0_6906"}
    EndIf


    yMax = yMaxold : xMax = xMaxold : yMin = yMinold : xMin = xMinold
  EndIf
Return

.JL_0_695E: ; all in the same line
  If (xMin >= Peek.w(?comWord_BlockStartX)) AND (xMin <= Peek.w(?comWord_BlockEndX))
    log_Print{"JL_0_695E"}
    d4.l = Peek.w(?comWord_BlockEndX) - xMin + 1
    If d4 > 2 Then d4 = 2
    d4 = d4 * \font\tf_XSize

    xMin = xMin - Peek.w(?comWord_ColumnsOffset)
    xMin = xMin * \font\tf_XSize
    xMax = xMin + d4
    yMin = Peek.l(?comLong_BlockStartY) - Peek.l(?comLong_DisplayLineOffset)
    yMax = yMin * \font\tf_YSize * 2 - 1
    yMin = yMin * \font\tf_YSize
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ *sourcerp, sourceWindow\BoxLeft + xMin, sourceWindow\BoxTop + yMin, sourceWindow\BoxLeft + xMax, sourceWindow\BoxTop + yMax
    Else
      log_Print{"illegal area for JL_0_695E"}
    EndIf

  EndIf
Return

.draw_new_columns_right:
  JSR save_cursorposition

  CLR.w comWord_ColumnsOffsetTmp
  CLR.w comWord_TextBufferOffset
  CLR.l comLong_DisplayLine
  MOVE.w visiblecolumns,D0 : SUBQ.w #2,D0 : MOVE.w D0,comWord_Column
  MOVEA.l textbufferaddr,A5 : ADDA.w comWord_ColumnsOffset,A5 : ADDA.w D0,A5
  MOVE.l viewablelines,D2 : SUBQ.w #1,D2

  JL_0_6AFA:
    MOVEA.l AL_0_5B9E,A0
    MOVE.b (A5),(A0)
    MOVE.b $1(A5),$1(A0)

    MOVEQ.l #$00,D0 : MOVE.w comWord_Column,D0 : MULU fontWidth,D0
    MOVE.l comLong_DisplayLine,D1 ;: MULU fontHeight,D1

    ; check if we are in a string
    MOVEM.l d0-d2/a0,-(a7)
    MOVE.l textbufferaddr,a0 : ADD.w comWord_TextBufferOffset,a0
    CLR.b instring2
    MOVE.w #0,d2
    CMP.l #0,a0
    BEQ 'l2b
      MOVE.w comWord_ColumnsOffset,d1 : ADD.w visiblecolumns,d1 : SUBQ.w #1,d1
     'l1
        CMP.w d1,d2
        BGE 'l2b
          MOVE.b (a0)+,d0
          CMP.b #$22,d0
          BNE 'l2
            NOT.b instring2
         'l2
          ADDQ.w #1,d2
      BRA 'l1
   'l2b
    MOVEM.l (a7)+,d0-d2/a0

    ST noDetokenizing                 ; handle as normal text, no detokenizing necessary                                                                                                                                                                 
    MOVE.b #1,keepstring
    JSR print_complete_line               ; inputs d0:x, d1:y, a0: text
    CLR.b keepstring
    BSR process_highlighting
    SF noDetokenizing

    MOVEQ.l #$00,D0  : MOVE.w #MAX_Columns,D0  :ADDA.w D0,A5 : ADD.w D0,comWord_TextBufferOffset
    ADDQ.l #1,comLong_DisplayLine
  DBF D2,JL_0_6AFA
  JSR restore_cursorposition
RTS

.clear_sourcebuffer:
  Gosub reset_Blockflag

  ped\ptrCurrentSourceData\Column = 0
  ped\ptrCurrentSourceData\DisplayLine = 0
  ped\ptrCurrentSourceData\TextBufferOffset = 0
  ped\ptrCurrentSourceData\DisplayLineOffset = 0
  ped\ptrCurrentSourceData\ColumnsOffset = 0 
  ped\ptrCurrentSourceData\SourceChanged = 0
  ped\ptrCurrentSourceData\LabelList = 0
  ped\ptrCurrentSourceData\LabelCounter = 0
  ped\ptrCurrentSourceData\SourceName[0] = 0
  ped\ptrCurrentSourceData\TotalLines = 1

  Gosub clear_sourcewindow

  ; create a first sourceline
  Gosub alloc_firstsourceline

  Gosub update_scrollers
Return

.free_actualsource:
  log_Print{"freeing current source..."}
  *tempLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
  While *tempLine <> 0
    *nextLine = *tempLine\nextLine
    PED_DeleteSourceLine{*tempLine}
    *tempLine = *nextLine
  Wend

  Gosub free_labellist
  log_Print{"...done"}
Return

.create_whole_gui:
  Gosub open_gui
  Gosub update_scrollers
  !asm
BRA.w _redraw

.SetGuiFontToWBScreenFont:                            ;Subroutine to get the used Screenfont of the WB an set it as guifont  tomsmart1
    WbToScreen 0                                      ; set WB to screen 0
    *scr.Screen = Peek.l(Addr Screen(0))              ; get pointer of this screen
    If *scr <> 0                                      ; check if we get a screenstructure
      *scrfont.TextAttr = *scr\Font                   ; try to get the font out of the screenstructur
      If *scrfont<>0                                  ; check if we get a TextAttrstructure

        ; In AmigaDOS we trust :
        guifont_size.w = (*scrfont.TextAttr\ta_YSize)    ; get size of the font
        guifont_name$ = Peek$(*scrfont.TextAttr\ta_Name)     ; get name of the font

       ; message{"WB fontname="+guifont$+"("+Str$(guifontsize)+")"}  ; for debug only to see if we get the right font ;)
      EndIf

    EndIf
Return


.open_gui:
  ped\errorCode = #PEDERROR_NOERROR

  log_Print{"opening gui...",#log_debug}
  If (pedconfig\use_wbfont = True)  OR  (pedconfig\use_wbscreen<>0)              ; check if we use workbench fonts or screen for Gui tomsmart1

    ;Gosub SetGuiFontToWBScreenFont                                   ; try to get the workbench screen font settinge out of the screen structure tomsmart1
    ;*guifont.TextFont = screen_SetDefaultFont{guifont_name$,guifont_size}  ; and try to use it for the Gui of oure own screen  tomsmart1
    screen_SetDefaultSysFont{#scr_sysfont_wb_prop}                    ; switch on sysfont overwrite for use Workbench screen font  tomsmart1

  Else

    screen_SetDefaultSysFont{#scr_sysfont_wb_off}                     ; switch off sysfont overwrite we want to use the selected font for the Gui  tomsmart1

    If guifont_name$ <> ""
      If guifont_size <= 0 Then guifont_size = 6
      *guifont.TextFont = screen_SetDefaultFont{guifont_name$,guifont_size} ; try to set selected font for the Gui  tomsmart1
    EndIf

    If *guifont = 0                                                   ; unable to open font => use system default
      log_Print{"Could not open selected font <" + guifont_name$ + ">, using Workbench Font instead.",#log_warning}
      Gosub SetGuiFontToWBScreenFont                                  ; try to get the workbench screen font settinge out of the screen structure tomsmart1
      *guifont = screen_SetDefaultFont{guifont_name$,guifont_size}          ; and try to use it for the Gui of oure own screen  tomsmart1
    EndIf
    If *guifont = 0
      log_Print{"We also failed to get the font of the Workbench, we now use the default font.",#log_warning}
      screen_SetDefaultSysFont{#scr_sysfont_wb_prop}                  ; switch on sysfont overwrite for use Workbench screen font  tomsmart1
    End If

  EndIf

  ped\defaultPubscreenName = "AmiBlitz3"
  ped\defaultScreenTitle = "AmiBlitz3 - PED V\\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH"
  If pedconfig\use_wbscreen <> 0                                    ; -- use workbench here
    If screen_Open{ped\defaultScreenTitle,#scr_mode_wb_use} = False
      ped\errorCode = #PEDERROR_OPENSCREEN
    Else
      ped\pubScreenNumber = "WB"
    EndIf
  Else
    If pedconfig\use_pubscreen                                 ; -- searching for already opened ab3-screens
      screen_ziffer.b = 1 : exit_screensearch.b = False
      ped\pubScreenNumber = ""
      Repeat
        GetPubScreen 2,ped\defaultPubscreenName + "_" + Str$(screen_ziffer)
        If Peek.l(Addr Screen(2))<>0
          ReleasePubScreen 2
          screen_ziffer + 1
        Else
          exit_screensearch = True
        EndIf
      Until exit_screensearch
      ped\pubScreenNumber = Str$(screen_ziffer)
      ped\defaultPubscreenName = ped\defaultPubscreenName + "_" + ped\pubScreenNumber
      screen_SetPubName{ped\defaultPubscreenName}        ; set name "str_defaultpubscreen+screen_number"
      WbToScreen 0 ; we need this, because GetPubScreen is steeling us the focus on screen 0
    EndIf

    If pedconfig\clone_wbscreen <> 0                                ; -- clone the workbench for one screen
      If screen_Open{ped\defaultScreenTitle,#scr_mode_wb_clone} = False
        ped\errorCode = #PEDERROR_OPENPUBSCREEN
      EndIf
    Else
      If screen_Open{ped\defaultScreenTitle,pedconfig\screen_modeID,pedconfig\screen_Width,pedconfig\screen_Height,pedconfig\screen_Depth} = False
        err_msg$ = "Could not open selected screen.\\nTrying to open default screen."
        log_Print{err_msg$,#log_warning}
        dummy.l = ask{!TRANS{err_msg$},!TRANS{"Ok"},!TRANS{"Error"}}

        pedconfig\clone_wbscreen = 1    ;try clone Wbscreen
        If screen_Open{ped\defaultScreenTitle,#scr_mode_wb_clone} = False
          err_msg$ = "Could not clone WB-screen, using WB itself."
          dummy.l = ask{!TRANS{err_msg$},!TRANS{"Ok"},!TRANS{"Error"}}
          pedconfig\clone_wbscreen = False  ; no clone Wbscreen
          pedconfig\use_wbscreen = True     ; try use Wbscreen
          If screen_Open{ped\defaultScreenTitle,#scr_mode_wb_use} = False
            ped\errorCode = #PEDERROR_OPENSCREEN
          EndIf
        EndIf

        ;-- get current Screen infos and store it for a update prefs/save
        pedconfig\screen_Width  = screen_GetWidth{}
        pedconfig\screen_Height = screen_GetHeight{}
        pedconfig\screen_Depth  = screen_GetDepth{}
        log_Print{"getting best screenmodeid..."}
        If NOT KickVersion(39)
          pedconfig\screen_modeID = screen_GetBestModeID{pedconfig\screen_Width,pedconfig\screen_Height,pedconfig\screen_Depth}
        Else
          err_msg$ = "Sorry, to obtain best matching screen mode, we need at least OS3.0!\\n"
          error{err_msg$,!TRANS{"Error"}}
          pedconfig\screen_modeID = 0
        EndIf
      EndIf
    EndIf
  EndIf
  If ped\errorCode
    Select ped\errorCode
    Case #PEDERROR_OPENSCREEN
      dummy.l = ask{!TRANS{"Unable to open screen"},!TRANS{"Ok"},!TRANS{"Error"}}
    Case #PEDERROR_OPENPUBSCREEN
      dummy.l = ask{!TRANS{"Unable to open pubscreen, it is already in use."},!TRANS{"Ok"},!TRANS{"Error"}}
    End Select
    Goto exit_PED_closeall
  EndIf

  If (screen_GetDepth{} < 4) ; AND (Peek.b(?newcolormode)<>0)
    log_Print{"screen colors: " + Str$(1 LSL screen_GetDepth{}),#log_debug}
    log_Print{"screen_GetDepth(): "+ Str$(screen_GetDepth{}),#log_debug}
    dummy.l = ask{!TRANS{"It is recommended to open a screen with at least 16 colors."},!TRANS{"Ok"},!TRANS{"Info"}}
  EndIf

  sourceWindow\pedScreen = Peek.l(Addr Screen(0))
  Poke.l ?comPtr_pedScreen,sourceWindow\pedScreen

  If screen_GetModeID{}<>#scr_mode_wb_use
    If pedconfig\use_default_pubscreen
      log_Print{"settings defaultpubscreen"}
      SetDefaultPubScreen_ &ped\defaultPubscreenName
    EndIf
  EndIf
  log_Print{"setting colors..."}
  Gosub set_storedcolors

  CNIF #USE_AREXX = 1
  ; -- inform via arexx that the Window is opened
  ArexxMyMessage$ = "OPENWINDOW" : Gosub arexx_sendmessage
  CEND

  log_Print{"init menues"}
  Gosub init_menus
  log_Print{"init windowlayouts"}
  Gosub load_windowlayouts
  If pedconfig\autolayout Then AutoLayout{&wtemp,ped\lastAutoLayout}
  log_Print{"do window layout"}
  Gosub do_windowlayout
  log_Print{"do window layout finished"}
Return

.open_sourcewindow:
  ; -- check arexx
  log_Print{"open sourcewindow."}

  CNIF #USE_AREXX = 1
    If arexx_GetMsg{True} Then Gosub arexx_event
  CEND

  If Used Screen < 0 Then WbToScreen 0
  *myscreen = Peek.l(Addr Screen(Used Screen))
  If *myscreen = 0
    Gosub close_gui
    ped\errorCode = #PEDERROR_OPENWINDOW
    Return
  EndIf

  If sourceWindow\win <> 0 Then Goto win_already_open

  If sourceWindow\WinWidth < 32 Then sourceWindow\WinWidth = *myscreen\Width - sourceWindow\WinLeft - 1
  If sourceWindow\WinHeight < 32 Then sourceWindow\WinHeight = *myscreen\Height - sourceWindow\WinTop - 1
  If sourceWindow\WinLeft + sourceWindow\WinWidth > *myscreen\Width  Then sourceWindow\WinWidth = *myscreen\Width - sourceWindow\WinLeft
  If sourceWindow\WinTop + sourceWindow\WinHeight > *myscreen\Height Then sourceWindow\WinHeight = *myscreen\Height - sourceWindow\WinTop

  DEFTYPE.Image       *img             ; An image which represents the size gadget
  DEFTYPE.Image       *sizeimage,*rarrowimage,*larrowimage,*darrowimage,*uarrowimage
  DEFTYPE.Gadget      *vertiprop,*horizprop,*rarrowbutton,*larrowbutton,*darrowbutton,*uarrowbutton
  DEFTYPE.l sizew,sizeh,w,h,barh,exit
  Dim GTags.TagItem(4) ; -- Tags for getting the size gadget image

  *drawinfo = GetScreenDrawInfo_(*myscreen)
  If *drawinfo
    If (*myscreen\Flags & #SCREENHIRES) Then sis.l=#SYSISIZE_HIRES Else sis=#SYSISIZE_MEDRES
    GTags(0)\ti_Tag = #SYSIA_DrawInfo,*drawinfo
    GTags(1)\ti_Tag = #SYSIA_Which,#SIZEIMAGE
    GTags(2)\ti_Tag = #SYSIA_Size,sis
    GTags(3)\ti_Tag = #TAG_DONE
    *img = NewObjectA_(0,"sysiclass",&GTags(0))
    If *img Then DisposeObject_ *img
    FreeScreenDrawInfo_ *myscreen,*drawinfo
  EndIf

  ; --
  ; -- Fenster erzeugen
  ; --
  !basic
  *drawinfo = GetScreenDrawInfo_(*myscreen)
  If (*myscreen\Flags & #SCREENHIRES)
    syssize.b = #SYSISIZE_MEDRES
  Else
    syssize = #SYSISIZE_LOWRES
  EndIf
  *sizeimage = NewObjectA_(0,"sysiclass",Tags(#SYSIA_Which,#SIZEIMAGE,@@
                                                #SYSIA_Size     ,syssize,@@
                                                #SYSIA_DrawInfo ,*drawinfo,@@
                                                #TAG_END        ,0))
  If (*sizeimage)
    GetAttr_ #IA_Width,*sizeimage ,&sizew
    GetAttr_ #IA_Height,*sizeimage,&sizeh
    DisposeObject_ *sizeimage
  Else
    sizew = 18
    sizeh = 10
  EndIf

  *darrowimage = NewObjectA_(0,"sysiclass",Tags(#SYSIA_Which,#DOWNIMAGE,@@
                                                   #SYSIA_Size     ,syssize,@@
                                                   #SYSIA_DrawInfo ,*drawinfo,@@
                                                   #TAG_END        ,0))
  If (*darrowimage)
    GetAttr_ #IA_Width ,*darrowimage,&w
    GetAttr_ #IA_Height,*darrowimage,&h
  EndIf

  *darrowbutton = NewObjectA_(0,"buttongclass",Tags(#GA_ID,#GID_DARROW,@@
    #GA_RelRight    ,-w+1,@@
    #GA_RelBottom   ,-sizeh-h+1,@@
    #GA_Width       ,w,@@
    #GA_Height      ,h,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,*drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #GA_Image       ,*darrowimage,@@
    #TAG_END        ,0))

  *uarrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#UPIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,*drawinfo,@@
    #TAG_END        ,0))

  If (*uarrowimage)
    GetAttr_ #IA_Width ,*uarrowimage,&w
    GetAttr_ #IA_Height,*uarrowimage,&h
  EndIf

  *uarrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous    ,*darrowbutton,@@
    #GA_ID          ,#GID_UARROW,@@
    #GA_RelRight    ,-w+1,@@
    #GA_RelBottom   ,-sizeh-h-h+1,@@
    #GA_Width       ,w,@@
    #GA_Height      ,h,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,*drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #GA_Image       ,*uarrowimage,@@
    #TAG_END        ,0))

  barh = *myscreen\WBorTop+*myscreen\RastPort\TxHeight+2

  *vertiprop = NewObjectA_(0,"propgclass",Tags(@@
    #GA_Previous    ,*uarrowbutton,@@
    #GA_ID          ,#GID_YPROP,@@
    #GA_RelRight    ,-sizew+4,@@
    #GA_Top         ,barh,@@
    #GA_Width       ,sizew-6,@@
    #GA_RelHeight   ,-sizeh-h-h-barh-1,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,*drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #PGA_Freedom    ,#FREEVERT,@@
    #PGA_Borderless ,True,@@
    #PGA_NewLook    ,True,@@
    #PGA_Total      ,1,@@
    #PGA_Visible    ,1,@@
    #TAG_END        ,0))

  *rarrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#RIGHTIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,*drawinfo,@@
    #TAG_END        ,0))

  If (*rarrowimage)
    GetAttr_ #IA_Width ,*rarrowimage,&w
    GetAttr_ #IA_Height,*rarrowimage,&h
  EndIf

  *rarrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous     ,*vertiprop,@@
    #GA_ID           ,#GID_RARROW,@@
    #GA_RelRight     ,-sizew-w+1,@@
    #GA_RelBottom    ,-h+1,@@
    #GA_Width        ,w,@@
    #GA_Height       ,h,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,*drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #GA_Image        ,*rarrowimage,@@
    #TAG_END         ,0))

  *larrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#LEFTIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,*drawinfo,@@
    #TAG_END        ,0))

  If (*larrowimage)
    GetAttr_ #IA_Width ,*larrowimage,&w
    GetAttr_ #IA_Height,*larrowimage,&h
  EndIf

  *larrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous     ,*rarrowbutton,@@
    #GA_ID           ,#GID_LARROW,@@
    #GA_RelRight     ,-sizew-w-w+1,@@
    #GA_RelBottom    ,-h+1,@@
    #GA_Width        ,w,@@
    #GA_Height       ,h,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,*drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #GA_Image        ,*larrowimage,@@
    #TAG_END         ,0))

  *horizprop = NewObjectA_(0,"propgclass",Tags(@@
    #GA_Previous     ,*larrowbutton,@@
    #GA_ID           ,#GID_XPROP,@@
    #GA_Left         ,*myscreen\WBorLeft,@@
    #GA_RelBottom    ,-sizeh+3,@@
    #GA_RelWidth     ,-sizew-w-w-*myscreen\WBorLeft-1,@@
    #GA_Height       ,sizeh-4,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,*drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #PGA_Freedom     ,#FREEHORIZ,@@
    #PGA_Borderless  ,True,@@
    #PGA_NewLook     ,True,@@
    #PGA_Total       ,#MAX_Columns,@@
    #PGA_Visible     ,20,@@
    #TAG_END         ,0))


  If (*vertiprop=0) OR( *horizprop=0)
    dummy.l = ask{Hex$(*vertiprop),Hex$(*horizprop),!TRANS{"Info"}}
    sourceWindow\win = 0
    Goto error_opensourcewindow                   ; bei Fehler ...
  EndIf

  ; only added OS4 only IDCMP Flags if we are running on OS4  tomsmart1
  SourceWindowIDCMPFlags.l = #IDCMP_INTUITICKS|#IDCMP_CLOSEWINDOW|#IDCMP_VANILLAKEY|#IDCMP_RAWKEY
  SourceWindowIDCMPFlags | #IDCMP_MENUPICK|#IDCMP_GADGETUP|#IDCMP_GADGETDOWN
  SourceWindowIDCMPFlags | #IDCMP_MOUSEMOVE|#IDCMP_MOUSEBUTTONS|#IDCMP_NEWSIZE|#IDCMP_CHANGEWINDOW|#IDCMP_REFRESHWINDOW
  SourceWindowIDCMPFlags | #IDCMP_ACTIVEWINDOW|#IDCMP_INACTIVEWINDOW   ; added to get info if the source win (in)active
  If OSVersion = #AmigaOS4
    SourceWindowIDCMPFlags|#IDCMP_EXTENDEDMOUSE  ;added #IDCMP_EXTENDEDMOUSE for OS4 Mousewheel support
  EndIf

  SourceWindowWFlags.l = #WFLG_NEWLOOKMENUS|#WFLG_WBENCHWINDOW|#WFLG_ACTIVATE|#WFLG_GIMMEZEROZERO
  SourceWindowWFlags   | #WFLG_SIZEBBOTTOM|#WFLG_SIZEBRIGHT|#WFLG_SIZEGADGET|#WFLG_CLOSEGADGET|#WFLG_DEPTHGADGET
  SourceWindowWFlags   | #WFLG_DRAGBAR|#WFLG_REPORTMOUSE
  log_Print{"opening source window"}


  ; --- OPEN the WINDOW
  Use Screen 0
  DefaultIDCMP SourceWindowIDCMPFlags    ; we have to add these IDCMP-Flags to the list that "event" is going to listen for
  WindowTags 0,SourceWindowWFlags,"AmiBlitz3",Tags(@@
                      #WA_Left       ,sourceWindow\WinLeft,@@
                      #WA_Top        ,sourceWindow\WinTop,@@
                      #WA_Height     ,sourceWindow\WinHeight,@@
                      #WA_Width      ,sourceWindow\WinWidth,@@
                      #WA_MinWidth   ,320,@@
                      #WA_MaxWidth   ,-1,@@
                      #WA_MinHeight  ,120,@@
                      #WA_MaxHeight  ,-1,@@
                      #WA_Gadgets    ,*darrowbutton,@@
                      #WA_PubScreen  ,*myscreen,@@
                      (#WA_Dummy + $60),-1)
  sourceWindow\win = Peek.l(Addr Window(0))

;  sourceWindow\win = OpenWindowTagList_(0,Tags(@@
;                      #WA_Title      ,"AmiBlitz3",@@
;                      #WA_Left       ,sourceWindow\WinLeft,@@
;                      #WA_Top        ,sourceWindow\WinTop,@@
;                      #WA_Height     ,sourceWindow\WinHeight,@@
;                      #WA_Width      ,sourceWindow\WinWidth,@@
;                      #WA_MinWidth   ,320,@@
;                      #WA_MaxWidth   ,-1,@@
;                      #WA_MinHeight  ,120,@@
;                      #WA_MaxHeight  ,-1,@@
;                      #WA_Flags      ,SourceWindowWFlags,@@
;                      #WA_IDCMP      ,SourceWindowIDCMPFlags,@@
;                      #WA_Gadgets    ,*darrowbutton,@@
;                      #WA_PubScreen  ,*myscreen,@@
;                      (#WA_Dummy + $60),-1  ))

  If sourceWindow\win = 0
    Goto error_opensourcewindow                   ; bei Fehler ...
  EndIf

  log_Print{"setting window pointers for asmcode"}
  Poke.l (Addr Window(0)),sourceWindow\win  ; to set the Window address in the BlitzBasic structure so we can use  "Use Window 0" this helps to shown the requesters of the error.include one the Amiblitz screen and not on the WB

  log_Print{"attaching menustrip to window"}
  If Peek.l(?addr_menustrip) Then SetMenuStrip_ sourceWindow\win,Peek.l(?addr_menustrip)

  log_Print{"setting sourcefont"}
  SetFont_ sourceWindow\win\RPort,\font

  ; attach sourcewindow to peds process
  log_Print{"find current task"}
  *this_process.Process = FindTask_(0)
  Poke.l ?ptr_windowPtrTemp, *this_process\pr_WindowPtr
  *this_process\pr_WindowPtr = sourceWindow\win
  ped\LabelListChanged = True  ; indicate that label window has to be updated too

  win_already_open:
  ; --
  ; -- Berechnung des Sourcelayouts, Groesse der Scroller etc.
  ; --
  Gosub calc_SourceWindowDimensions

  ;
  ; -- Speicher reservieren fuer sichtbaren Sourcebereich
  ;
  Gosub allocate_textbuffer

  ; -- allocate memory for temp rastport
  *sourcerp.RastPort = PED_AllocMem{$64}
  sourceWindow\rp = *sourcerp
  CopyMem_ \win\RPort,*sourcerp,$64
  SetDrMd_ *sourcerp, #COMPLEMENT

  ;*mask.l = AllocMem(4,0)
  ;If (*mask > 0)
  ;  Poke.w *mask,   %000100010001000100
  ;  Poke.w *mask +2,%100010001000100010
  ;  *sourcerp\AreaPtrn = *mask
  ;  *sourcerp\AreaPtSz = 1
  ;EndIf

  SetWindowTitles_ sourceWindow\win,&ped\defaultScreenTitle,-1
  Gosub clear_sourcewindow
  Gosub draw_statusarea
  Gosub set_pointer_normal_bas
  !asm
  JSR _redraw
  !basic
  Gosub update_scrollers
Return

.calc_SourceWindowDimensions:
  log_Print{"calculating sourcewindow dimensions..."}
  USEPATH sourceWindow
  \BoxHeight = \win\Height - \win\BorderTop - \win\BorderBottom
  \BoxWidth = \win\Width   - \win\BorderLeft - \win\BorderRight

  If pedconfig\linenumbers
    digits.b = 5
    If Peek.l(?comLong_TotalLines) < 10000 Then digits = 4
    If Peek.l(?comLong_TotalLines) < 1000 Then digits = 3
    If Peek.l(?comLong_TotalLines) < 100 Then digits = 2
    If Peek.l(?comLong_TotalLines) < 10 Then digits = 2
    linenumberWidth.w = digits * \font\tf_XSize
    \BoxLeft = linenumberWidth + 3
  Else
    \BoxLeft = 0
  EndIf

  \BoxTop = \font\tf_YSize + 2

  \visibleLines = (\BoxHeight - \BoxTop - 6) / \font\tf_YSize  ; 6 Pixel fehlen wg. Trennlinie etc.
  \visibleLines - 2                        ; subtract two lines for status area
  \statusAreaY = \BoxTop + \visibleLines * \font\tf_YSize + 1
  \visibleColumns = (\BoxWidth - \BoxLeft) / \font\tf_XSize
  ;\visibleColumns = \visibleColumns BitClr 0
  \boundLinesX = 2
  \boundLinesY = 2
  \scrollSize = 1

  Poke.l ?viewablelines,\visibleLines
  ;Poke.l ?viewablelines_m1, \visibleLines - 1
  Poke.w ?visiblecolumns,\visibleColumns

  !asm
  BCLR #0,comWord_BoundLinesX
  !basic
Return


.error_opensourcewindow:
  dummy.l = ask{!TRANS{"Unable to open window!"},!TRANS{"Ok"},!TRANS{"Error"}}
  Gosub free_textbuffer

  JL_0_7334:
  Gosub close_sourcewindow
  !coutclose
  CloseAllWZWindows{}

  screen_Close{} ;/* screen close knows if it is on wb! */
Goto exit_PED_closeall

ptr_windowPtrTemp:    Ds.l 1

.print_actualsourceline:
  sourceWindow\currentLine = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) + 1
  formatstr$ = "      " : len_fmtstr.b = FLen(formatstr$)
  formatstr$ = StrRight(Str$(sourceWindow\currentLine),len_fmtstr,48)  ; mit nullen auffuellen
  PED_PrintStatus{formatstr$,18}
Return

.print_actualsourcecolumn:
  sourceWindow\currentColumn = Peek.w(?comWord_ColumnsOffset) + Peek.w(?comWord_Column) + 1
  formatstr$ = "   " : len_fmtstr.b = FLen(formatstr$)
  formatstr$ = StrRight(Str$(sourceWindow\currentColumn),len_fmtstr,48)  ; mit nullen auffuellen
  PED_PrintStatus{formatstr$,3}
Return

.print_availmem:
  availchip.l = AvailMem_(#MEMF_CHIP) / 1024
  availfast.l = AvailMem_(#MEMF_FAST) / 1024
  Format "###0,000"
  availmem$ = "CHIP " + StrPack(Str$(availchip)) + "kb"
  availmem$ + " | FAST " + StrPack(Str$(availfast)) + "kb"
  Format ""

  PED_PrintStatus{availmem$,Len(availmem$),2}
RTS


.update_statusarea:
  Gosub print_availmem
  Gosub print_actualsourceline
  Gosub print_actualsourcecolumn

  If Peek.b(?comByte_DebugMode) Then info$ = "  Debug: On " Else info$ = "  Debug: Off"
  If ped\DoTokenize Then info$ + "  Tokenize: On " Else info$+ "  Tokenize: Off"
  If ped\ptrCurrentSourceData\SourceChanged Then info$ = "Modified: True  " + info$ Else info$= "Modified: False" + info$
  ;info$ = "Total: " + Str$(Peek.l(?comLong_TotalLines)) + info$
  PED_PrintStatus{info$,74,2}
Return

.draw_statusarea:
  log_Print{"draw statusarea"}
  USEPATH sourceWindow

  ;-- clear areas
  SetAPen_  \win\RPort, AB3Pen(#AB3_screenfill)
  If \statusAreaY <= \win\GZZHeight
    RectFill_ \win\RPort, 0,\statusAreaY,\win\GZZWidth,\win\GZZHeight
    RectFill_ \win\RPort, 0,0, \win\GZZWidth,\font\tf_YSize
  Else
    log_Print{"illegal area for draw statusara"}
  EndIf

  ;-- Draw separation lines
  SetAPen_ \win\RPort, AB3Pen(#AB3_screenshine)
  Move_ \win\RPort,0,\statusAreaY : Draw_ \win\RPort,\win\GZZWidth,\statusAreaY

  SetAPen_ \win\RPort, AB3Pen(#AB3_screentext)
  Move_ \win\RPort,0,\statusAreaY + 1 : Draw_ \win\RPort,\win\GZZWidth,\statusAreaY + 1
  Move_ \win\RPort,0,\BoxTop-1 : Draw_ \win\RPort,\win\GZZWidth,\BoxTop-1

  ; for updating the modifier flag "*"
  Gosub draw_tabs

  PED_PrintStatus{"Line:        ", 24}
  PED_PrintStatus{"Column:    ", 11}

  Gosub update_statusarea
  ;Gosub update_debuggertoggle
Return

.free_textbuffer:
  If Peek.l(?textbufferaddr)
    PED_FreeMem{Peek.l(?textbufferaddr)}
    Poke.l ?textbufferaddr, 0
  EndIf
  ;!asm
  ;TST.l textbufferaddr
  ;BEQ.w JL_0_74AE
  ;  MOVEM.l D0-D1/A0-A1/A6,-(A7)
  ;  MOVEA.l textbufferaddr,A1
  ;  !newfree
  ;  MOVEM.l (A7)+,D0-D1/A0-A1/A6
  ;  CLR.l textbufferaddr
  ;JL_0_74AE:
  ;!basic
Return

.allocate_textbuffer:
  Gosub free_textbuffer

  Poke.l ?textbufferaddr, PED_AllocMem{#MAX_Columns * Peek.l(?viewablelines) + 2}
  
  ;!asm
  ;MOVE.w #MAX_Columns,D0 : MULU viewablelines+2,D0
  ;!newalloc
  ;MOVE.l D0,textbufferaddr
  ;!basic

  If Peek.l(?textbufferaddr)=0 Then Goto JL_0_7334 ; quit ped
Return




.close_gui:
  log_Print{"closing gui..."}
  CloseAllWZWindows{}                                      ; replaced the close of all WZ Windows with a statement call  tomsmart1

  If Peek.l(?CLI_output_file) <> 0
    Close_ Peek.l(?CLI_output_file) : Poke.l ?CLI_output_file,0
  EndIf

  CNIF #USE_AREXX = 1
    ArexxMyMessage$ = "CLOSEWINDOW" : Gosub arexx_sendmessage
  CEND

  Gosub close_sourcewindow

  *this_process.Process = FindTask_(0)
  *this_process\pr_WindowPtr = ?ptr_windowPtrTemp

  Gosub free_textbuffer

  If pedconfig\use_pubscreen Then PubScreenStatus_ sourceWindow\pedScreen,#PSNF_PRIVATE
  vvblank_Free{}
  screen_Close{}   ; this release all pens for us  and close the used font
  log_Print{"closed gui"}
Return


.close_sourcewindow:
  If sourceWindow\win
    Gosub flush_intuimessages

    ;CloseWindow_ sourceWindow\win
    CloseWindow 0 : sourceWindow\win = 0
    ;Poke.l Addr Window(0),0  ; to clear the window structure of BlitzBasic to prevent a crash at exit.

    DisposeObject_ *larrowbutton
    DisposeObject_ *larrowimage
    DisposeObject_ *rarrowbutton
    DisposeObject_ *rarrowimage
    DisposeObject_ *horizprop
    DisposeObject_ *darrowbutton
    DisposeObject_ *darrowimage
    DisposeObject_ *uarrowbutton
    DisposeObject_ *uarrowimage
    DisposeObject_ *vertiprop
    FreeScreenDrawInfo_ *myscreen,*drawinfo

    ; -- clear rastport for source area
    If *sourcerp Then PED_FreeMem{*sourcerp}
  EndIf
Return


.set_storedcolors:
  screen_ReleaseAllPens{} ; release all pens that have been previously obtained by screen.include

  If (pedconfig\use_wbscreen = False) AND KickVersion(39)
    screen_SetPenRGB{0             ,AB3RGB(#AB3_screenback) }
    screen_SetPenRGB{1             ,AB3RGB(#AB3_screentext) }
    screen_SetPenRGB{2             ,AB3RGB(#AB3_screenshine)}
    screen_SetPenRGB{3             ,AB3RGB(#AB3_screenfill) }
    AB3Pen(#AB3_screenback)        = screen_GetPenRGB{AB3RGB(#AB3_screenback) }
    AB3Pen(#AB3_screentext)        = screen_GetPenRGB{AB3RGB(#AB3_screentext) }
    AB3Pen(#AB3_screenshine)       = screen_GetPenRGB{AB3RGB(#AB3_screenshine)}
    AB3Pen(#AB3_screenfill)        = screen_GetPenRGB{AB3RGB(#AB3_screenfill) }
  Else
    AB3Pen(#AB3_screenback)        = 0
    AB3Pen(#AB3_screentext)        = 1
    AB3Pen(#AB3_screenshine)       = 2
    AB3Pen(#AB3_screenfill)        = 3
  EndIf

  If KickVersion(39)
    AB3Pen(#AB3_cfunction)           = screen_GetPenRGB{AB3RGB(#AB3_cfunction)}
    AB3Pen(#AB3_cmacro)              = screen_GetPenRGB{AB3RGB(#AB3_cmacro)}
    AB3Pen(#AB3_cstring)             = screen_GetPenRGB{AB3RGB(#AB3_cstring)}
    AB3Pen(#AB3_cnewtype)            = screen_GetPenRGB{AB3RGB(#AB3_cnewtype)}
    AB3Pen(#AB3_cconstant)           = screen_GetPenRGB{AB3RGB(#AB3_cconstant)}
    AB3Pen(#AB3_cremarkforeground)   = screen_GetPenRGB{AB3RGB(#AB3_cremarkforeground)}
    AB3Pen(#AB3_cremarkbackground)   = screen_GetPenRGB{AB3RGB(#AB3_cremarkbackground)}
    AB3Pen(#AB3_ctoken)              = screen_GetPenRGB{AB3RGB(#AB3_ctoken)}
    AB3Pen(#AB3_ctokenbackground)    = screen_GetPenRGB{AB3RGB(#AB3_ctokenbackground)}
    AB3Pen(#AB3_cbackground)         = screen_GetPenRGB{AB3RGB(#AB3_cbackground)}
    AB3Pen(#AB3_cother)              = screen_GetPenRGB{AB3RGB(#AB3_cother)}
    AB3Pen(#AB3_cclassic)            = screen_GetPenRGB{AB3RGB(#AB3_cclassic)}
  Else
    AB3Pen(#AB3_cfunction)           = 1;screen_GetPenRGB{AB3RGB(#AB3_cfunction)}
    AB3Pen(#AB3_cmacro)              = 1;screen_GetPenRGB{AB3RGB(#AB3_cmacro)}
    AB3Pen(#AB3_cstring)             = 1;screen_GetPenRGB{AB3RGB(#AB3_cstring)}
    AB3Pen(#AB3_cnewtype)            = 1;screen_GetPenRGB{AB3RGB(#AB3_cnewtype)}
    AB3Pen(#AB3_cconstant)           = 1;screen_GetPenRGB{AB3RGB(#AB3_cconstant)}
    AB3Pen(#AB3_cremarkforeground)   = 1;screen_GetPenRGB{AB3RGB(#AB3_cremarkforeground)}
    AB3Pen(#AB3_cremarkbackground)   = 0;screen_GetPenRGB{AB3RGB(#AB3_cremarkbackground)}
    AB3Pen(#AB3_ctoken)              = 2;screen_GetPenRGB{AB3RGB(#AB3_ctoken)}
    AB3Pen(#AB3_ctokenbackground)    = 0;screen_GetPenRGB{AB3RGB(#AB3_ctokenbackground)}
    AB3Pen(#AB3_cbackground)         = 0;screen_GetPenRGB{AB3RGB(#AB3_cbackground)}
    AB3Pen(#AB3_cother)              = 1;screen_GetPenRGB{AB3RGB(#AB3_cother)}
    AB3Pen(#AB3_cclassic)            = 1;screen_GetPenRGB{AB3RGB(#AB3_cclassic)}
  EndIf

  ;remarkcolor.l              = AB3Pen(#AB3_cremarkforeground)
  ;remarkbgcolor.l            = AB3Pen(#AB3_cremarkbackground)
RTS



.save_cursorposition:
  MOVE.w comWord_Column,comWord_StoreColumn
  MOVE.l comLong_DisplayLine,comLong_StoreDisplayLine
  MOVE.w comWord_TextBufferOffset,comWord_StoreTextBufferOffset
RTS

.restore_cursorposition:
  MOVE.w comWord_StoreColumn,comWord_Column
  MOVE.l comLong_StoreDisplayLine,comLong_DisplayLine
  MOVE.w comWord_StoreTextBufferOffset, comWord_TextBufferOffset
RTS

.clear_sourcewindow:
  ; -- clear the codelines in window
  USEPATH sourceWindow
  SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)
  RectFill_ \win\RPort,\BoxLeft,\BoxTop,\BoxWidth,\statusAreaY

  ; draw vertical line to seperate numbers and source code
  If pedconfig\linenumbers
    lx.w = \BoxLeft - 1
    SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    RectFill_ \win\RPort,0,\BoxTop,lx,\statusAreaY

    lx - 1
    SetAPen_ \win\RPort,AB3Pen(#AB3_screentext)
    Move_ \win\RPort,lx, \BoxTop
    Draw_ \win\RPort,lx, \statusAreaY
  EndIf
  Gosub draw_statusarea
  Gosub update_statusarea

  !asm
  JSR clear_sourcetextbuffer
  !basic
Return

.clear_sourcetextbuffer:
  ; -- clear current text memoryarea
  MOVEA.l textbufferaddr,A0
  MOVE.w #MAX_Columns,D0 : LSR.w #1,D0
  MOVE.l viewablelines,D1 : MULS d0,d1 : SUBQ.w #1,D1

  JL_0_76A6:
    MOVE.w #$2020,(A0)+
  DBF D1,JL_0_76A6
RTS

.ScrollDelay:
  CNIF #slowdown <> 0
    If ped\no_scrollrate
      Delay_ 1
    Else
      vvblank_Wait{}
      vvblank_WaitSync{1}
      vvblank_ResetSync{}
    EndIf
  CEND
Return

.print_entered_char:      ; input: enteredChar
  currentColumn.w = Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)

  ; write character to textbuffer
  plineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
  plineaddr + currentColumn
  Poke.b plineaddr,enteredChar.b

  ; check if cursor in block
  If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
    currentLine.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
    !updateBlockMark{currentLine,currentColumn}
    If Peek.b(?comByte_StateBlockMark) Then ST comWord_CursorInMarkedBlock
  EndIf

  ; -- print entered character to source window
  CLR.w comWord_ColumnsOffsetTmp

  tposx.w = Peek.w(?comWord_Column); currentColumn
  tposy.w = Peek.l(?comLong_DisplayLine)
  textaddr.l = &enteredChar ;?comByte_EnteredCharacter

  If Peek.w(?comWord_CursorInMarkedBlock)
    log_Print{"cursor in block, routine called."}
     ; --- print actual character with blockbackgroundcolor
     SetBPen_ \win\RPort,3
     PED_PrintText{&enteredChar,tposx,tposy,1,AB3Pen(#AB3_cother)}
     SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
  Else
    If Peek.w(&enteredChar) > 0
     ; log_Print{"Print ["  + Chr$(enteredChar) + "] at " + Str$(tposx) + ", " + Str$(tposy) + "  " + Str$(Peek.w(?comWord_ColumnsOffset))}
      PED_PrintText{&enteredChar,tposx,tposy,1,AB3Pen(#AB3_cother)}
    Else
      textaddr.l = &enteredChar
      If Peek.w(?instru)
        log_Print{"instru handling missing.",#log_warning}
        textaddr = textaddr BitClr 7
      Else
;        error{"whats up?"}
      EndIf
      PED_PrintText{textaddr,tposx,tposy,1,AB3Pen(#AB3_cclassic)}
    EndIf
  EndIf
  SF comWord_CursorInMarkedBlock
Return



.update_TextBufferOffset:                                    ; calculate Textbufferoffset
  ;MOVE.l comLong_DisplayLine,D1 : MULU #MAX_Columns,D1 : MOVE.w D1,comWord_TextBufferOffset
  Poke.w ?comWord_TextBufferOffset, Peek.l(?comLong_DisplayLine) * #MAX_Columns
Return

.cursor_on:
  If sourceWindow\cursorState = False Then Gosub switch_cursordisplay
Return

.cursor_off:
  If sourceWindow\cursorState = True Then Gosub switch_cursordisplay
Return

.switch_cursordisplay:
  sourceWindow\cursorState = NOT sourceWindow\cursorState
  Gosub draw_cursor
Return


.draw_cursor:
  If Peek.l(?comLong_DisplayLine) > Peek.l(?viewablelines)-1
    Poke.l ?comLong_DisplayLine, Peek.l(?viewablelines)-1
  EndIf

  Select pedconfig\cursorStyle
  Case #AB3_cursorStyle_line
    xmin.w = \BoxLeft + Peek.w(?comWord_Column) * \font\tf_XSize
    ymin.w = \BoxTop + Peek.l(?comLong_DisplayLine) * \font\tf_YSize
    xmax.w = xmin + 1
    ymax.w = ymin + \font\tf_YSize - 1

  Case #AB3_cursorStyle_underline
    xmin.w = \BoxLeft + Peek.w(?comWord_Column) * \font\tf_XSize
    ymin.w = \BoxTop + Peek.l(?comLong_DisplayLine) * \font\tf_YSize + \font\tf_YSize - 1  - 1
    xmax.w = xmin + \font\tf_XSize - 1
    ymax.w = ymin + 1

  Default
    xmin.w = \BoxLeft + Peek.w(?comWord_Column) * \font\tf_XSize
    ymin.w = \BoxTop + Peek.l(?comLong_DisplayLine) * \font\tf_YSize
    xmax.w = xmin + \font\tf_XSize - 1
    ymax.w = ymin + \font\tf_YSize - 1
  End Select

  If (xMax => xMin) AND (yMax => yMin)
    ;SetAPen_ \win\RPort, AB3Pen(#AB3_screenfill)
    ;SetBPen_ \win\RPort, AB3Pen(#AB3_cbackground)
    ;SetAPen_ *sourcerp, AB3Pen(#AB3_screenfill)
    ;SetBPen_ *sourcerp, AB3Pen(#AB3_cbackground)
    ;SetDrMd_ *sourcerp,#COMPLEMENT
    *sourcerp\Mask = %11
    RectFill_ *sourcerp,xmin,ymin,xmax,ymax
    ;log_Print{"update cursor " + Str$(sourceWindow\cursorState)}
  Else
    log_Print{"illegal area for draw cursor",#log_error}
  EndIf
Return



.update_vertscroller:
  Gosub print_actualsourceline
  slider_top.l     = Peek.l(?comLong_DisplayLineOffset)
  slider_total.l   = Peek.l(?comLong_TotalLines)
  slider_visible.l = Peek.l(?viewablelines)

  ;log_Print{"update vertprop"}
  ;/ scale
  If slider_total > 0
    If slider_total >= #max_slider_res
      !mul48f{slider_visible,#max_slider_res,slider_total,slider_visible}  : If slider_visible<1 Then slider_visible=1
      !mul48f{slider_top    ,#max_slider_res,slider_total,slider_top}
      slider_total   = #max_slider_res
    EndIf
    SetGadgetAttrsA_ *vertiprop,sourceWindow\win,0,Tags(@@
                                            #PGA_Total  ,slider_total,@@
                                            #PGA_Top    ,slider_top,@@
                                            #PGA_Visible,slider_visible)
  End If
Return

.update_modifiermark:

  If ped\ptrCurrentSourceData\SourceChanged  <> oldSourceChanged.w
      Gosub draw_statusarea
      oldSourceChanged = ped\ptrCurrentSourceData\SourceChanged
  EndIf
Return

.update_horizscroller:
  xpot.l = Peek.w(?comWord_Column)
  xact.l = Peek.w(?comWord_ColumnsOffset) + Peek.w(?comWord_Column) + 1
  xvis.w = \visibleColumns / #MAX_Columns
  SetGadgetAttrsA_ *horizprop,sourceWindow\win,0,Tags(#PGA_VertPot,-1,@@
                                            #PGA_VertBody,1,@@
                                            #PGA_HorizPot,xpot,@@
                                            #PGA_HorizBody,xvis,@@
                                            #PGA_Top,xact,@@
                                            #PGA_Total,#MAX_Columns,@@
                                            #TAG_END,0)

  Gosub print_actualsourcecolumn
  Gosub update_modifiermark
Return

JL_0_7962_bas:
  JSR save_cursorposition
  !basic
  log_Print{"JL_0_7962_bas"}
  Poke.w ?comWord_TextBufferOffset,0
  Poke.l ?comLong_DisplayLine,0
  Poke.w ?comWord_Column,0
  Poke.w ?comWord_ColumnsOffsetTmp,0
  curline.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset) + Peek.w(?comWord_ColumnsOffset)
  cury.w = 0
  For v.l = Peek.l(?viewablelines) - 1 To 0 Step -1
    ST noDetokenizing                                                                                                                                                                                                                                    

    lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
    If Peek.b(lineaddr) <> 0
      tmpd2.l = 0
      While Peek.w(?comWord_ColumnsOffset) > tmpd2
        If Peek.b(lineaddr + tmpd2) = $22
          NOT.b instring2
        EndIf
        tmpd2 = tmpd2 + 1
      Wend
    EndIf

    Poke.b ?keepstring,1
    GetD0 curline : MOVE.l d0,-(a7)
    GetD0 cury : MOVE.l d0,-(a7)
    !asm
    MOVE.l (a7)+,D1
    MOVE.l (a7)+,A0
    MOVEQ.l #0,D0

    JSR print_complete_line                             ; d0:x, d1:y, a0: text
    !basic
    Poke.b ?keepstring,0
    !asm
    SF noDetokenizing                                                                                                                                                                                                                                    
    JSR process_highlighting
    ADD.l #1,comLong_DisplayLine
    ADD.w #MAX_Columns, comWord_TextBufferOffset
    !basic
    curline = curline + #MAX_Columns
    cury = cury + 1 ;\font\tf_YSize
  Next v
  !asm
  JSR restore_cursorposition
  JSR JL_0_590C
RTS


Macro checkBeforeBlockStartX
  `1 = False
  If Peek.l(?comLong_BlockStartY) = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine)
    If Peek.l(?comWord_BlockStartX) > Peek.l(?comWord_ColumnsOffset) + Peek.l(?comWord_Column)
      `1 = True
    EndIf
  EndIf
End Macro

Macro checkBeforeBlockEndX
  `1 = False
  If Peek.l(?comLong_BlockEndY) = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine)
    If Peek.l(?comWord_BlockEndX) > Peek.l(?comWord_ColumnsOffset) + Peek.l(?comWord_Column)
      `1 = True
    EndIf
  EndIf

End Macro


.checkBeforeBlockStartX:
  MOVE.l comLong_DisplayLineOffset,D2
  ADD.l comLong_DisplayLine,D2                           ; d2 = current Linenumber

  CMP.l comLong_BlockStartY,D2                           ; if blockstartY = d2
  BNE.w JL_0_79EE
    MOVE.w comWord_Column,D2                             ;   d2 = current Columnnumber
    ADD.w comWord_ColumnsOffset,D2
    CMP.w comWord_BlockStartX,D2                         ;   if d2 <= blockstartX
    BHI.w JL_0_79EE
      MOVEQ.l #$00,D3                                    ;     d3 = 0
                                                         ;   endif
  JL_0_79EE:                                             ; endif
RTS

checkBeforeBlockEndX:
  MOVE.l comLong_DisplayLineOffset,D2
  ADD.l comLong_DisplayLine,D2                           ; d2 = current Linenumber

  CMP.l comLong_BlockEndY,D2                             ; if blockstartY = d2
  BNE.w JL_0_7A12
    MOVE.w comWord_Column,D2                             ;   d2 = current Columnnumber
    ADD.w comWord_ColumnsOffset,D2
    CMP.w comWord_BlockEndX,D2                           ;   if d2 <= blockEndX
    BHI.w JL_0_7A12
      MOVEQ.l #$00,D3                                    ;     d3 = 0
  JL_0_7A12:                                             ;   endif
RTS                                                      ; endif



.adjustBlockPosition:
  If Peek.w(?comWord_BlockStartX) >= #MAX_Columns
    Poke.w ?comWord_BlockStartX,0
    Poke.l ?comLong_BlockStartY , Peek.l(?comLong_BlockStartY) + 1
    If Peek.w(?comLong_BlockStartY) > Peek.l(?comLong_BlockEndY)
      Gosub reset_Blockflag
      Return
    EndIf
  EndIf

  If Peek.w(?comWord_BlockEndX) > Peek.w(?comWord_BlockStartX)
    Poke.w ?comWord_BlockEndX,#MAX_Columns-1
    Poke.l ?comLong_BlockStartY , Peek.l(?comLong_BlockStartY) - 1
    If Peek.w(?comLong_BlockStartY) <= Peek.l(?comLong_BlockEndY)
      Return
    Else
      Gosub reset_Blockflag
      Return
    EndIf
  EndIf

  If Peek.w(?comLong_BlockStartY) = Peek.l(?comLong_BlockEndY)
    If Peek.w(?comWord_BlockEndX) <= Peek.l(?comWord_BlockStartX)
      Gosub reset_Blockflag
      Return
    EndIf
  EndIf

  If Peek.w(?comWord_BlockEndX) >= #MAX_Columns
    Poke.l ?comWord_BlockEndX, #MAX_Columns-1
  EndIf
Return

.JL_0_7A14: ;adjustBlockPosition_asm
  MOVE.w comWord_BlockStartX,D2
  CMP.w #MAX_Columns,D2
  BCS.w JL_0_7A3C                                                       ; if d2 < Maxcolumns   isLower
    CLR.w comWord_BlockStartX
    ADDQ.l #1,comLong_BlockStartY
    MOVE.l comLong_BlockStartY,D2
    CMP.l comLong_BlockEndY,D2
    BLS.w JL_0_7A3C                                                     ; if d2 <= BlockendY  isLowerOrSame
      JMP reset_Blockflag_asm
  JL_0_7A3C:

  MOVE.w comWord_BlockEndX,D2
  BPL.w JL_0_7A66                                                       ; if d2 >= BlockEndX  isGreater
    MOVE.w #MAX_Columns,D2
    SUBQ.w #1,D2
    MOVE.w D2,comWord_BlockEndX
    SUBQ.l #1,comLong_BlockEndY
    MOVE.l comLong_BlockEndY,D2
    CMP.l comLong_BlockStartY,D2
    BCC.w JL_0_7A90                                                     ; if d2 >= BlockStartY  isHigherOrSame

    JL_0_7A62:
    JMP reset_Blockflag_asm
  JL_0_7A66:

  MOVE.l comLong_BlockStartY,D2
  CMP.l comLong_BlockEndY,D2
  BNE.w JL_0_7A7C                                                      ; if d2 <> BlockEndY    isNotEqual
    MOVE.w comWord_BlockEndX,D2
    CMP.w comWord_BlockStartX,D2
    BLT.b JL_0_7A62                                                    ; if d2 <= BlockStartX   isLessOrEqual
  JL_0_7A7C:

  CMP.w #MAX_Columns,D2
  BCS.w JL_0_7A90                                                      ; if d2 < MaxColumns    isLower
    MOVE.w #MAX_Columns,D2
    SUBQ.w #1,D2
    MOVE.w D2,comWord_BlockEndX
  JL_0_7A90:
RTS


.handlePedEvents:
  CLR.w comWord_KeyBeforeReturn
  exit_eventloop.b = False

  While exit_eventloop = False
    Gosub handle_blockmark      ; if new editmode, delete a marked block if inserchar or deletechar happens                                                                                                                                                 
    ;CLR.b blockmark_removal
    Gosub update_horizscroller
;    Gosub print_actualsourceline

    ;-- handle Window events
    If sourceWindow\win <> 0
      Gosub eventHandler
    EndIf

    ; -- update functioncompletion and close any subwindows on key-press
;    If pedconfig\intellisense
; -- update intellisense after DELETE_KEY OR SPACE_KEY                        ; moved it too remove double switch asm-basic-asm and expand with Space-Key support  tomsmart1
;      If (last_vankey = $08) OR (last_vankey = $20)
;        Gosub intellisense
;      EndIf
; -- CURSOR_KEYs navigation
;      If WZ_CheckOpen{"WIN_POPUP"} AND (last_rawkey.l>(#RAWKEY_UP-1) AND last_rawkey<(#RAWKEY_LEFT+1) )
;        Select last_rawkey                                             ; test only rawkey code for cursor keys  tomsmart1
;          Case #RAWKEY_UP    : WZ_SetPopUpEntry{popupdata\selected_entry - 1}
;          Case #RAWKEY_DOWN  : WZ_SetPopUpEntry{popupdata\selected_entry + 1}
;          Case #RAWKEY_RIGHT : Gosub close_popupwindow
;          Case #RAWKEY_LEFT  : Gosub close_popupwindow
;        End Select
;      EndIf

    Gosub close_contexthelp

    If last_vankey > 0 Then Gosub immediate_syntaxhelp
  Wend
  log_Print{"exit pedevents"}
Return




.insertchar:
  Poke.w ?comWord_KeyBeforeReturn,last_vankey

  If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : Gosub handle_blockmark
  EndIf


  ;-- move everything right from cursor 1 to right
  lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
  currentColumn.w = Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)
  tempColumn.w = #MAX_Columns
  While tempColumn > currentColumn
    tempColumn - 1
    Poke.b lineaddr + tempColumn,Peek.b(lineaddr + tempColumn - 1)
  Wend

  Gosub cursor_off

  sourceWindow\Column = Peek.w(?comWord_Column)
  sourceWindow\DisplayLine = Peek.l(?comLong_DisplayLine)
  PED_ScrollHorizontal{#SCROLL_RIGHT, #SCROLL_CURRENT_LINE}

  ;-- update blockmarking
  If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
    currentColumn = Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)
    currentLine.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
    !updateBlockMark{currentLine,currentColumn}

    If Peek.l(?comLong_BlockStartY) <> currentLine AND Peek.l(?comLong_BlockEndY) <> currentLine
      If Peek.l(?comWord_BlockStartX) > currentColumn
        If Peek.b(?comByte_StateBlockMark) <> 0
          Poke.w ?comWord_BlockEndX, Peek.w(?comWord_BlockEndX) + 1
          If Peek.w(?comWord_BlockEndX) > #MAX_Columns-1
            Poke.w ?comWord_BlockEndX, #MAX_Columns-1
          EndIf
        EndIf
      EndIf
      If Peek.w(?comWord_BlockEndX) < currentColumn
        Poke.w ?comWord_BlockEndX, Peek.w(?comWord_BlockEndX) + 1
        If Peek.w(?comWord_BlockEndX) > #MAX_Columns-1
          Poke.w ?comWord_BlockEndX, #MAX_Columns-1
        EndIf
      EndIf

      Poke.w ?comWord_BlockStartX, (Peek.w(?comWord_BlockStartX) + 1) AND $7F
      Poke.w ?comWord_BlockEndX, (Peek.w(?comWord_BlockEndX) + 1) AND $7F

    EndIf
  EndIf
  ;--

  enteredChar.b = Peek.w(?comWord_KeyBeforeReturn) : Gosub print_entered_char
  Gosub moveCursorRight
Return



.moveCursorToBeginOfWord:
  ; get lineaddress in textbuffer (detokenized text!)
  lineaddr = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
  ; get length of source line
  textlen.w = getLineLength{lineaddr}

  ;clear highlight info but dont trash strings
  nostring.b = 0
  For i.l = lineaddr To lineaddr + textlen
    If nostring = 0
      Poke.b i,Peek.b(i) AND $7f
      If Peek.b(i) = $22 Then nostring = 1
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
  Next

  cursorpos.w = Peek.w(?comWord_Column)
  If cursorpos > 1
    cursorpos - 1
    skip_spaces.b = False
    If Peek.b(lineaddr+cursorpos) = 32 Then skip_spaces = True ; check if current char is a space

    exit_loop.b = False
    Repeat
      cursorpos - 1
      char.b = Peek.b(lineaddr+cursorpos)
      log_Print{Peeks$(lineaddr,textlen)}
      log_Print{Str$(char) + "  " + Chr$(char) + "  "+Str$(cursorpos)}
      If skip_spaces
        If char <> 32 Then skip_spaces = False
      Else
        If (char < 48) OR (char = Asc("{")) OR (char = Asc("}"))
          exit_loop = True
        EndIf
      EndIf
    Until exit_loop OR (cursorpos < 1)

  EndIf
  ;GetD0 cursorpos
RTS


.moveCursorToEndOfWord:
  ; get lineaddress in textbuffer (detokenized text!)
  lineaddr = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
  ; get length of source line
  textlen.w = getLineLength{lineaddr}

  ;clear highlight info but dont trash strings
  nostring.b = 0
  For i.l = lineaddr To lineaddr + textlen
    If nostring = 0
      Poke.b i,Peek.b(i) AND $7f
      If Peek.b(i) = $22 Then nostring = 1
    Else
      If Peek.b(i) = $22 Then nostring = 0
    End If
  Next

  cursorpos.w = Peek.w(?comWord_Column)
  If cursorpos < textlen
    cursorpos + 1
    skip_spaces.b = False
    If Peek.b(lineaddr+cursorpos) = 32 Then skip_spaces = True ; check if current char is a space

    exit_loop.b = False
    Repeat
      cursorpos + 1
      char.b = Peek.b(lineaddr+cursorpos)

      If skip_spaces
        If char <> 32 Then skip_spaces = False
      Else
        If (char < 48) OR (char = Asc("{")) OR (char = Asc("}"))
          exit_loop = True
        EndIf
      EndIf
    Until exit_loop OR (cursorpos => textlen)
    ;If cursorpos > 1 Then cursorpos - 1     ; internal counter starts at 0!
  EndIf
  GetD0 cursorpos
RTS


.startguide:
  !basic
  log_Print{"startguide"}
  strline$ = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
  actualword$ = PED_GetWordAtPos{strline$, Peek.w(?comWord_Column),True}
  If actualword$ <> ""
    Gosub instructionbrowser_startguide
  Else
    Gosub open_instructionbrowser
  EndIf

  PED_ShowMessage{""}
  !asm
RTS


.immediate_syntaxhelp:
  _key.b = last_vankey
  already_displayed.b = False
  ;log_Print{"immediate help ? : last_key " + Hex$(last_vankey)}
  If (_key=@" ") OR (_key = @"(") OR (_key = @"{") ;OR (*PreProcessor\tokenFlags[_key&$FF]&#TOKENF_IS); " " "(" "{"

    If Peek.w(?comWord_Column) > 0

      If WZ_CheckOpen{"WIN_POPUP"} Then Gosub close_popupwindow

      lineaddr = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
      strline$ = Peek.s(lineaddr) ;Peeks$(lineaddr,Peek.w(?comWord_Column))
      ;slen.w = FLen(strline$) : found.l = False
      ;Gosub getstring_new2
      ;tokname$ = actualword$
      ;error{"Line Pre:"+strline$}
      ;MaxLen linebuff$ = 256
      ;preproc_Detokenize{*PreProcessor,&strline$,&linebuff$,FLen(strline$)}
      ;strline$ = Peek.s(&linebuff$)
      ;error{"Line Post:"+strline$}

      bracketclose1.l = Instr(strline$,")")
      bracketclose2.l = Instr(strline$,"}")

      bracketopen1.l  = Instr(strline$,"(",bracketclose1)
      bracketopen2.l  = Instr(strline$,"{",bracketclose2)

      bracketopen.l   = 0

      If bracketopen1>bracketopen2 Then bracketopen=bracketopen1 : Else bracketopen=bracketopen2

      searchpos.l = Peek.w(?comWord_Column)
      If bracketopen>0 AND bracketopen<searchpos Then searchpos=bracketopen

      tokname$ = preproc_CropToken{*PreProcessor,strline$,searchpos}
      If tokname$ <> ""
        If *PreProcessor\tokenFlags[_key&$FF]&#TOKENF_IS
          tokname$ + Chr$(_key)
        End If
      End If
      If tokname$
        Gosub syntax_help
        If strhelp$ = ""
          Gosub intellisense
        End If
      End If
    EndIf
  Else
    Select _key
    Case $8b ; "HELP"
      ;If NOT already_displayed
      strline$ = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
      tokname$ = PED_GetWordAtPos{strline$, Peek.w(?comWord_Column),True}
      If tokname$ <> ""
        log_Print{"HELP on <" + tokname$ + ">"}

        If StrLower(tokname$) = "endif"
          Gosub help_checkforif
        Else
          !asm
          JSR help_checkfortype
          !basic
          type_found.b = PutD0
          If (type_found = False)
            Gosub syntax_help
          EndIf
        EndIf
;        Else
;          search_instruction$ = ""
;          ypos.l = Peek.l (?comLong_DisplayLine)*Peek.w (?fontHeight)+(Peek.w (?fontHeight)*3)
;          wtemp\ibrowser_x = Peek.w (?comWord_Column)*Peek.w (?fontWidth):wtemp\ibrowser_y = ypos
;          Gosub open_instructionbrowser
      EndIf
      ;EndIf

     Case $0D ; ENTER
       If pedconfig\intellisense AND pedconfig\onlinehelp_includes
         If WZ_CheckOpen{"WIN_POPUP"}
           a$ = WZ_GetPopUpEntry{WZ_GetPopUpMenu{}+1}

           ; include function
           a_new$ = dos_Trim{Left$(a$,Instr(a$,"{")-1)}
           If (a_new$ <> "") ;test if include function
             PED_ShowMessage{a_new$ + " " + PED_GetIncludeHelp{a_new$} }
             a$ = a_new$ + "{"
           Else          ; is command
             PED_ShowMessage{a$ + " " + PED_GetTokenHelp{*tokenbase,a$} }
           EndIf

           a$ = UnRight$(a$,FLen(poptok$)) ; cut string

           Gosub insertstring
           Gosub close_popupwindow
           Gosub activatesourcewindow
           Pop Select : Pop If :Pop If
           Return
           ;!asm
           ;MOVE.l #0,d7
           ;RTS
           ; replace text in textbuffer
;           MOVE.l textbufferaddr,d0
;           ADD.w comWord_TextBufferOffset,d0
;           ADD.w comWord_ColumnsOffset,d0
;           ADD.w comWord_Column,d0
;           faddr.l = PutD0 - 1
;           PokeS faddr-Len(poptok$), a$,FLen(a$)
;;           Poke.w ?comWord_ColumnsOffset,Peek.w(?comWord_Column)+FLen(a$)
;           Pop Select
;           !asm
;           MOVE.l #0,D7
;           RTS

         EndIf
       EndIf
    Default
      Gosub intellisense
    End Select
  EndIf
Return


Function.s FindTokenHelpStr{tokname$}
  SHARED *tokenbase.tokeninfo         ;add because it is global now  tomsmart1 2012 06 16

  If Left$(tokname$,1) = "!"
    MOVE.l comPtr_MacroBase,d0 : *macrobase.l = PutD0
    tokname$ = PED_GetMacroName{*macrobase,tokname$}
;    tokhelp$ = PED_GetMacroHelp{*macrobase,tokname$}
    tokexte$ = "Macro"
  Else
    tokid.l = PED_GetTokenID{*tokenbase,tokname$}
    If tokid>=0
      tokname$ = PED_GetTokenName{*tokenbase,tokid}
      libnum.l = PED_GetTokenLibnum{*tokenbase,tokname$}
      If libnum>=0
        tokhelp$ = PED_GetTokenHelp{*tokenbase,tokname$}
        tokexte$ = "BlitzLib: " + PED_GetLibname{libnum}
      End If
    Else
      tokname$ = PED_GetIncludeFunction{tokname$}
      If tokname$<>""
        tokhelp$ = PED_GetIncludeHelp{tokname$}
        tokexte$ = "Include: " + PED_GetIncludeName{tokname$}
      End If
    End If
  End If

  strhelp$ = tokname$
  If tokhelp$ <> "" Then strhelp$ + " " + tokhelp$
  If tokexte$ <> "" Then strhelp$ + " | " + tokexte$

  Function Return strhelp$
End Function


.syntax_help:
  log_Print{"syntax_help"}

  strhelp.s = ""
  If tokname$ <> ""
    strhelp =  FindTokenHelpStr{tokname$}
    If Len(strhelp) < 3
      ; keine Hilfe und kein Word unter Cursor
      PED_ShowMessage{""}
    Else
      PED_ShowMessage{strhelp}
    EndIf
  EndIf
RTS


.intellisense:
  ; -- bei delete-key wird ?comWord_Column nicht aktualisiert
  ;log_Print{"lastvankey " + Hex$(last_vankey)}
  If pedconfig\intellisense
    If last_vankey=#VANILLAKEY_BACKSPACE OR (last_vankey>=$20 AND last_vankey <= $7A)
      If Peek.w(?comWord_Column) > 1
        ; -- get everything left of cursor until " " or "=" , ":", "(", "{", ",", "+"    ; check expand to allow the following chars  : ( { , +  too tomsmart1
        If lineaddr.l

          strline$ = Peeks$(lineaddr,Peek.w(?comWord_Column)) : slen.w = FLen(strline$)
          ;log_Print{"intellisense for [" + strline$ +"]"}

          stokname$ = "" : strhelp$ = "" : sfound.l = False
          While (slen > 0) AND (sfound = False)
            schar$ = Mid$(strline$,slen,1)
            If (schar$ = " ") OR (schar$ = "=") OR (schar$ = ":") OR (schar$ = "(") OR (schar$ = "{") OR (schar$ = ",") OR (schar$ = "+")   ; expand check too allowed this chars : ( { , + too  tomsmart1
              sfound = True
            Else
              stokname$ = schar$ + stokname$
              slen - 1
            EndIf
          Wend
        End If

        Select last_vankey                            ; check for the last pressed key  tomsmart1
          Case $00                                    ; no key  added to support CTRL I update
                                                      ; nothing to do because stokname = stokname
          Case $08 ; DEL key
            stokname$ = UnLeft$(stokname$,1)          ; remove the most right chararter of the string too support the DELETE-KEY  tomsmart1
            Gosub close_popupwindow                   ; added to aviod hits  tomsmart1

         Default                                      ; all other keys
           ;stokname$ + Chr$(_key)                     ; normal added key to the string
        End Select

        ; -- search for any text that equals entered text
        If (FLen(stokname$) > 2)
          ;log_Print{"intellisense, searching for [" + stokname$+ "]"}
          poptok$ = Trim$(LCase$(stokname$)) : tokenliste$ = "" : popfound.w = 0

          ; in Helptext for Functionnames
          If (Instr(stokname$,"_") > 0)
            ; helptext
            ResetList HelpIndexCache()
            While NextItemFast(HelpIndexCache())
              If Instr(HelpIndexCache()\lname,poptok$) = 1
                ; %%1 = green, %%2 = rot, %%3= white, %%4= blue  fuer farben
                pophelp$ = HelpIndexCache()\name + HelpIndexCache()\help
                If FLen(pophelp$) > 32
                  pophelp$ = Left$(pophelp$,32) + " ... "
                EndIf
                tokenliste$ + "%%4" + pophelp$ + Chr$(10)
                popfound + 1
              End If
            Wend
          EndIf

          ; in Commands
          If pedconfig\use_commandsintellisens
            *tokenpointer.l = *tokenbase

            While *tokenpointer
              temptoken.s  = Peek$(*tokenpointer+6)
              ltemptoken.s = LCase$(temptoken)
              If Instr(ltemptoken,poptok$) = 1
                ; %%1 = green, %%2 = rot, %%3= white, %%4= blue  fuer farben
                pophelp$ = temptoken
                If FLen(pophelp$) > 32
                  pophelp$ = Left$(pophelp$,32) + " ... "
                EndIf
                tokenliste$ + "%%4" + pophelp$ + Chr$(10)
                popfound + 1
              End If

              *tokenpointer = Peek.l(*tokenpointer)  ; nexttoken
            Wend
          End If

          ; -- open list if something found
          If popfound > 0
            WZ_SetPopUpMenu{tokenliste$,1}
            sourceWindow\DisplayLine = Peek.l(?comLong_DisplayLine)
            USEPATH sourceWindow
            xpos.w = \WinLeft + \BoxLeft + Peek.w(?comWord_Column) * \font\tf_XSize
            ypos.w = \WinTop  + \BoxTop  + (\DisplayLine+1) * \font\tf_YSize + \font\tf_Baseline
            log_Print{"opening popup at " + Str$(xpos) + ", " + Str$(ypos)}
            WZ_PopUp_Nonmodal{xpos,ypos,-1,-1,*myscreen\RastPort}
          Else
            ;log_Print{"nothing found"}
            Gosub close_popupwindow
          EndIf
        Else
          Gosub close_popupwindow             ; added to support DELETE_KEY  tomsmart1
        EndIf
      Else
        Gosub close_popupwindow
      EndIf
      Gosub activatesourcewindow              ; if we change popupwin (open, close, change) so we need to activate sourcewin again  tomsmart1
    EndIf
  EndIf
Return

.scan_source_for_used_libs:
  log_Print{"scan source for used libs..."}
  Gosub set_pointer_busy_bas
  WZ_LockAllOpenWindows{}

  ; --
  ; -- scan for number of lines
  number_of_lines.l = Peek.l(?comLong_TotalLines)
  If number_of_lines = 0 Then Goto exit_scan_for_libs

;  libpointer.l = Peek.l(?comPtr_LibPointer)
;  Repeat
;    lib_size.l = Peek.l(libpointer)
;    lib_num.l = Peek.w(libpointer + 4 + 36)
;    libpointer = libpointer + lib_size + 4
;    log_Print{"libs size: " + Str$(lib_size) + " libnum: " + Str$(lib_num)}
;  Until lib_size = 0

  ; --
  ; -- reset tables and arrays
  For i.l = 0 To 65535
    tokentable(i) = 0
  Next i
  HIERARCHY_Clear{&lib_list}

  Use Window WZID("WIN_LABELS")
  WZPrint "LIBRARY_LIST",0,lib_list

  ; Zeilenstruktur:
  ; 0 - 3 bytes : Adresse naechste Zeile
  ; 4 - 7 bytes : Adresse prev Zeile
  ; 8 byte      : Laenge der Zeile
  ; 9.. bytes   : tokenized Text
  ; kill any spaces before Token

  ; --
  ; -- scanning each line for tokens
  WZ_ShowMessage{!TRANS{"Analyzing source..."},0}

  *sourceLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine : zeile.l = 0
  While *sourceLine <> 0
    bytecount.w = 0
    anzbytes.w = Peek.b(*sourceLine + 8)
    testaddr.l = *sourceLine + 9
    acttoken.w = Peek.w(testaddr) AND $FFFF
    acttoke2.l = Peek.w(testaddr) AND $FFFF
    skip_string.b = False

    While (bytecount<=anzbytes)
      If (acttoken<0) AND (NOT skip_string)
        If (acttoke2 AND $FF) > 0
          If (zeile MOD 10)=0 Then !WZ_Update_Gauge{zeile,number_of_lines}

          If acttoke2 > $8000 Then acttoke2 = acttoke2 - $8000
          tokentable(acttoke2) = tokentable(acttoke2) + 1
          bytecount + 1 : testaddr + 1

        EndIf
      EndIf
      testaddr + 1 : bytecount + 1
      acttoken = Peek.w(testaddr) AND $FFFF
      acttoke2.l = Peek.w(testaddr) AND $FFFF
      actbyte.w = acttoke2 LSR 8
      ; skip comments ...
      If actbyte = Asc(";")
        anzbytes = bytecount + 1
      Else
        ; skip strings ...
        If actbyte = 34
          If skip_string = False Then skip_string = True Else skip_string = False
        EndIf
      EndIf
    Wend
    *sourceLine = *sourceLine\nextLine : zeile = zeile + 1
  Wend

  ;
  ; build hierarchy table
  ;
  WZ_ShowMessage{!TRANS{"Building result tree..."},0}
  For i = 0 To 65535
    If tokentable(i) > 0
      acttoke2 = i
      tokname$ = PED_GetTokenName{*tokenbase,acttoke2}
      libnum.l = acttoke2 LSR 7 ;PED_GetTokenLibnumID{*tokenbase,tokname$})
      libname$ = lib_mapping$(libnum,0)

      If tokname$<>""
        entry$ = libname$ + ": " + tokname$ + " ("+Str$(tokentable(i))+")"
        hpos.w = Instr(entry$,":")
        If (hpos > 1)
          main$ = Left$(entry$,hpos - 1)
          child$= Right$(entry$,FLen(entry$) - hpos - 1)
          pid.l = HIERARCHY_GetParentID{main$}
          If pid > 0
            HIERARCHY_AddChild{pid,child$}
          Else
            dummy = HIERARCHY_AddParent{&lib_list,main$}
            If child$<>""
              pid.l = HIERARCHY_GetParentID{main$}
              If pid<>0 Then HIERARCHY_AddChild{pid,child$}
            EndIf
          EndIf
        Else
          dummy = HIERARCHY_AddParent{&lib_list,entry$}
        EndIf
      EndIf
    EndIf
    If (i MOD 1024) = 0 Then !WZ_Update_Gauge{i,65535}
  Next i
  ;
  WZ_HideMessage{}

  Use Window WZID("WIN_LABELS")
  WZPrint "LIBRARY_LIST",0,lib_list

  exit_scan_for_libs:
  WZ_UnlockAllOpenWindows{}
  Gosub set_pointer_normal_bas
Return

 
.deletechar:
  ped\blockmarkRemovalMode = 1
  lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
  Gosub scroll_rest_of_line_left

  currentColumn.w =  Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)
  For cupos.w = currentColumn + 1 To #MAX_Columns-1
    Poke.b lineaddr + cupos - 1, Peek.b(lineaddr + cupos)
  Next cupos
  Poke.b lineaddr + #MAX_Columns-1, $20 ; add space at the end (overwriting last character)

  ; check for "" in line and prevent parsing of instructions
  quotation.b = 0
  storcol.w = Peek.w(?comWord_Column)
  Poke.w ?comWord_Column, \visibleColumns - 1
  newcol.w = \visibleColumns + Peek.w(?comWord_ColumnsOffset) - 1
  For cupos.w = newcol To 0 Step -1
    If Peek.b(lineaddr + cupos) = $22 Then quotation + 1
  Next cupos
  Poke.b ?instru, 0
  If NOT (quotation AND 1) Then Poke.b ?instru,1

  ; show character that comes visible at the right if line is longer than visiblecolumns
  enteredChar.b = Peek.b(lineaddr + newcol) : Gosub print_entered_char
  Poke.b ?instru, 0
  Poke.w ?comWord_Column, storcol

  Gosub deletekey
Return

.updateSourceLine:        ; CursorXTarget: new Cursorposition
  log_Print{"update sourceline and moving cursor to x:" + Str$(CursorXTarget)}
  Gosub cursor_off

  lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
  storcol.w = Peek.w(?comWord_Column)
  Poke.w ?comWord_Column, 0
  For cupos.w = 0 To \visibleColumns - 1
    enteredChar.b = Peek.b(lineaddr + Peek.w(?comWord_ColumnsOffset) + cupos) : Gosub print_entered_char
    ADDQ.w #1,comWord_Column
  Next cupos
  Poke.w ?comWord_Column, storcol

  newColumn.w = CursorXTarget : Gosub moveCursorToX

  Gosub cursor_on
Return




.deletekey:
  ;log_Print{"deletekey, mode= " + Str$(sourceWindow\deleteMode)}
  ped\blockmarkRemovalMode = 2
  Poke.w ?comWord_KeyBeforeReturn,last_vankey

  ;If Peek.b(?nodelete) = 0
  If sourceWindow\deleteMode = False
    ; -- scroll to left by 1
    Gosub cursor_off
    Gosub scroll_rest_of_line_left

    ; -- move textbuffer left by 1 and append a space
    lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
    currentColumn.w = Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)

    For cupos.w = currentColumn + 1 To #MAX_Columns-1
      Poke.b lineaddr + cupos - 1, Peek.b(lineaddr + cupos)
    Next cupos
    Poke.b lineaddr + #MAX_Columns-1, $20 ; add space at the end (overwriting last character)

    ; check for "" in line and prevent parsing of instructions
    storcol.w = Peek.w(?comWord_Column)
    Poke.w ?comWord_Column, \visibleColumns - 1
    newcol.w = \visibleColumns - 1 + Peek.w(?comWord_ColumnsOffset)
    quotation.b = 0
    For cupos.w = newcol To 0 Step -1
      If Peek.b(lineaddr + cupos) = $22 Then quotation + 1
    Next cupos
    Poke.b ?instru, 0
    If NOT (quotation AND 1) Then Poke.b ?instru,1

    ; show character that comes visible at the right if line is longer than visiblecolumns
    enteredChar.b = Peek.b(lineaddr + newcol) : Gosub print_entered_char
    Poke.b ?instru, 0
    Poke.w ?comWord_Column, storcol

    ; check if Shift is pressed as well
    If Peek.w(?comWord_Column) > 0 OR Peek.w(?comWord_ColumnsOffset) > 0
      If (mqualifier.w AND #IEQUALIFIER_RSHIFT) OR (mqualifier AND #IEQUALIFIER_LSHIFT)
        ;log_Print{"shift"}
        If delete_mode.l = #VANILLAKEY_BACKSPACE
          If Peek.w(?comWord_Column) > 0
            Poke.w ?comWord_Column,Peek.w(?comWord_Column)-1
            Goto deletekey
          EndIf
          If Peek.w(?comWord_ColumnsOffset) > 0
            Poke.w ?comWord_ColumnsOffset,Peek.w(?comWord_ColumnsOffset)-1
            Goto deletekey
          EndIf
        EndIf
      Else
        Return
      EndIf
    EndIf
    !asm
    JSR JL_0_7962_bas ; horizontal scroll
    !basic
  EndIf
  delete_mode = 0
Return

.moveCursorToX:     ; newColumn: new X-Position
  Gosub cursor_off
  log_Print{"move cursor to column: "  + Str$(newColumn.w)}
  oldColumnsOffset.w = Peek.w(?comWord_ColumnsOffset)

  If newColumn <= Peek.w(?visiblecolumns) - Peek.w(?comWord_BoundLinesX)
    Poke.w ?comWord_ColumnsOffset, 0
    Poke.w ?comWord_Column,newColumn
  Else
    tmpvisColumns.w = Peek.w(?visiblecolumns) - 1
    newCursorPosX.w = newColumn - tmpvisColumns
    offColumns.w = #MAX_Columns - Peek.w(?visiblecolumns)
    If newCursorPosX < offColumns
      If newCursorPosX BitTst 0
        newCursorPosX + 1
        tmpvisColumns - 1
      EndIf
      Poke.w ?comWord_ColumnsOffset, newCursorPosX
      Poke.w ?comWord_Column, tmpvisColumns
    Else
      Poke.w ?comWord_ColumnsOffset, offColumns
      Poke.w ?comWord_Column, newColumn - offColumns
    EndIf
  EndIf

  If Peek.w(?comWord_ColumnsOffset) <> oldColumnsOffset
    !asm
    Gosub JL_0_7962_bas
    !basic
  EndIf

  Gosub cursor_on
Return

.moveCursorLeft:
  Gosub cursor_off
  If Peek.w(?comWord_Column) > \boundLinesX
    Poke.w ?comWord_Column,Peek.w(?comWord_Column) - 1
    Goto exit_cursorleft
  EndIf

  If Peek.w(?comWord_ColumnsOffset) > 1
    Poke.w ?comWord_ColumnsOffset,Peek.w(?comWord_ColumnsOffset) -  \scrollSize
    Gosub scroll_right
    ;Poke.w ?comWord_Column,Peek.w(?comWord_Column) + 1
  Else
    If Peek.w(?comWord_ColumnsOffset) = 1
      Poke.w ?comWord_ColumnsOffset,0
      Gosub scroll_right
      !basic
      JSR _redraw
      !asm
    Else
      If Peek.w(?comWord_Column) > 0
        Poke.w ?comWord_Column,Peek.w(?comWord_Column) - 1
      EndIf
    EndIf
  EndIf

  exit_cursorleft:
  Gosub cursor_on
Return

.moveCursorRight:
  Gosub cursor_off
  If Peek.w(?comWord_ColumnsOffset) + \visibleColumns => #MAX_Columns
    If Peek.w(?comWord_Column) < \visibleColumns-1
      Poke.w ?comWord_Column,Peek.w(?comWord_Column) + 1
    EndIf
  Else
    If \boundLinesX <= Peek.w(?comWord_Column)
      If Peek.w(?comWord_Column) > \visibleColumns - \boundLinesX
        Poke.w ?comWord_ColumnsOffset,Peek.w(?comWord_ColumnsOffset) + \scrollSize
        Gosub scroll_left
        ;Poke.w ?comWord_Column,Peek.w(?comWord_Column) - 1
        Goto exit_cursorright
      EndIf
    EndIf
    Poke.w ?comWord_Column,Peek.w(?comWord_Column) + 1
  EndIf

  exit_cursorright:
  Gosub cursor_on
Return

;.AJL_0_7FCC:
;  !basic
;  dummy.l = ask{"AJL_07FCC called",!TRANS{"Ok"},!TRANS{"Info"}}
;  !asm
;  TST.w comWord_LabelCounter
;   ;BEQ.w setpointer_to_normal
;  LEA L_0_808E,A3
;  CLR.l (A3)+
;  CLR.l (A3)+
;  CLR.l (A3)+
;  CLR.l (A3)+
;  CLR.l (A3)+
;  CLR.l (A3)+
;  CLR.l (A3)+
;  CLR.l (A3)+
;  LEA L_0_808E,A3
;  MOVEQ.l #$00,D6
;  MOVEA.l ptr_sourcewindow,A0
;  MOVEA.l $56(A0),A2                                 ; Window\UserPort
;
;  JL_0_7FF8:
;    MOVEA.l A2,A0 : JSR _WaitPort(A6)
;    MOVEA.l A2,A0 : JSR _ReplyMsg(A6)
;    MOVEA.l D0,A1
;    ;MOVE.l d0,messagestore
;    MOVE.l $14(A1),D1
;
;    CMP.l #IDCMP_VANILLAKEY,D1
;    BNE.w JL_0_8030
;
;      MOVE.w $18(A1),D2           ; keycode
;      CMP.w ##VANILLAKEY_RETURN,D2
;      BEQ.w JL_0_8036
;        CMP.w #$10,D6
;        BEQ.w JL_0_8036
;          MOVE.b D2,(A3)+
;          ;JSR JL_0_739E
;          ADDQ.w #1,D6
;
;    JL_0_8030:
;    ;MOVE.l messagestore,d0
;    BEQ 'l1
;      MOVE.l d0,a1
;      JSR _ReplyMsg(A6)
;   'l1
;  BRA.b JL_0_7FF8
;  JL_0_8036:
;
;  ;MOVE.l messagestore,d0
;  BEQ 'l1
;    MOVE.l d0,a1
;    JSR _ReplyMsg(A6)
; 'l1
;  MOVEQ.l #$00,D0
;  MOVEQ.l #$00,D7
;
;  LEA L_0_808E,A1
;  MOVEA.l comPtr_LabelList,A0
;  MOVEQ.l #$00,D4
;
;  JL_0_8048:
;  MOVEA.l $4(A0),A2
;  LEA $9(A2),A2
;  ADDQ.l #1,A2
;  LEA L_0_80B0,A3
;
;  JL_0_8056:
;  MOVE.b (A2)+,(A3)+
;  BNE.b JL_0_8056
;  LEA L_0_80B0,A3
;  JSR compare_strings
;  BNE.w JL_0_8076
;  ADDQ.l #1,D4
;  MOVEA.l (A0),A0
;  CMPA.l #$0,A0
;  BNE.b JL_0_8048
;  BRA.w JL_0_808C
;
;  JL_0_8076:
;  MOVEQ.l #$00,D2
;  MOVE.w visiblecolumns,D2
;  ADDQ.w #4,D2
;  MOVE.l D4,D3
;  ;JSR AJL_0_3A5E
;  ;JSR JL_0_73FA
;  JL_0_808C:
;RTS
;L_0_808E: Ds.w 17
;L_0_80B0: Ds.w 17


.handle_event_newsizewindow:
  log_Print{"handle newsizewindow"}
  sourceWindow\WinTop = sourceWindow\win\TopEdge
  sourceWindow\WinLeft = sourceWindow\win\LeftEdge

  If pedMessage\_Qualifier <> $FFFFC000   ; update only if mousebutton has been released
    sourceWindow\WinWidth = sourceWindow\win\Width
    sourceWindow\WinHeight = sourceWindow\win\Height
    Gosub resize_sourcewindow
    FlushEvents
  EndIf
Return

.resize_sourcewindow:
  Gosub cursor_off
  Gosub free_textbuffer
  Gosub calc_SourceWindowDimensions
  Gosub allocate_textbuffer
  Gosub clear_sourcewindow
  !asm
  JSR _redraw
  !basic
  Gosub cursor_on
Return


.eventHandler:
;  log_Print{"check message"}
  pedEventClass.l = PED_GetMessage{True}
;  log_Print{"check message end"}

;  While pedEventClass <> 0

    ;If pedMessage\_Class<>#IDCMP_INTUITICKS AND pedMessage\_Class<>#IDCMP_MOUSEMOVE
    ;  log_Print{"eventmessage: " + Hex$(pedMessage\_Class) + ", " + Hexw$(pedMessage\_Qualifier) + ", " + Hexw$(pedMessage\_Code)}
    ;  log_Print{"window: " + Str$(pedMessage\_Window) + "  MouseX:"  + Str$(pedMessage\_MouseX)}
    ;End If

    ; context onlinehelp for most windows
    If pedconfig\onlinehelp <> 0
      If (pedMessage\_Class<>#IDCMP_INTUITICKS) AND (pedMessage\_Class<>#IDCMP_ACTIVEWINDOW) AND (pedMessage\_Class<>#IDCMP_GADGETHELP)  AND (pedMessage\_Class<>#IDCMP_CHANGEWINDOW)
        WZ_HideHelp{}
      EndIf
      If pedMessage\_Class = #IDCMP_GADGETHELP Then WZ_ShowHelp{}
    EndIf


    If pedMessage\_Class = #IDCMP_MENUPICK
      ;addr_menuitem.l = ItemAddress_(Peek.l(?addr_menustrip),pedMessage\_Code)
      ;If addr_menuitem    ; added to protect agains MENUNULL  tomsmart1
      ;  _menuitem.l = Peek.l(addr_menuitem+$22)
      ;  Gosub event_menu
      ;EndIf
      Gosub handle_event_menupick
      exit_eventloop = True
    Else
      Use Window pedMessage\_Window
      Select pedMessage\_Window
        Case 0                              : Gosub event_sourcewindow
        Case WZID("WIN_SEARCH")             : Gosub event_find
        Case WZID("WIN_CONTEXTHELP")        : If pedMessage\_Class = #IDCMP_CLOSEWINDOW Then Gosub close_contexthelp
        Case WZID("WIN_NEWTYPE")            : Gosub event_newtype
        Case WZID("WIN_INSTRUCTIONBROWSER") : Gosub event_instructionbrowser
        Case WZID("WIN_LIBRARYBROWSER")     : Gosub event_librarybrowser
        Case WZID("WIN_LABELS")             : Gosub event_label
        Case WZID("WIN_POPUP")              : Gosub event_popup
        Case WZID("WIN_HELPDIAG")           : Gosub event_diag
        Case WZID("WIN_SHORTCUTS")          : Gosub event_shortcuts
      Default
        error{"received message from unknown window [" + Str$(pedMessage\_Window) + "]"}
      End Select
    EndIf

;    pedEventClass = PED_GetMessage{True}
;  Wend


  ;--  handle Arexx events
  CNIF #USE_AREXX = 1
    If arexx_GetMsg{True} Then Gosub arexx_event
  CEND

  If Peek.b(?comByte_RunningFlag) <> 0
    PED_ShowMessage{!TRANS{"!!!PROGRAM IS RUNNING: ONLY SAVE/NAVIGATION/HELP WILL WORK..."}}
    rf.l = 1
  Else
    If rf = 1 AND Peek.b(?comByte_RunningFlag) = 0
      PED_ShowMessage{""}
      rf = 0
    End If
  EndIf
Return




; ########################################################################################
.AREXX
CNIF #USE_AREXX = 1
  XINCLUDE "PED_arexx.ab3"
CEND
; ########################################################################################




.update_debuggertoggle:
  ped\debugmode = Peek.b(?comByte_DebugMode)
  GTSetMenuChecked 0,4,12,ped\debugmode
  ;log_Print{"updated Debugstatus: " + Str$(ped\debugmode)}
Return


.event_sourcewindow:
  exit_loop_class.b = 0
  exit_loop_code.l = 0
  last_vankey.b = 0
  last_rawkey.l = 0
  last_mqualifier.w = 0
  last_menuentry.l = 0
  last_event.l = pedMessage\_Class

  ;If pedMessage\_Class<>$400000 AND pedMessage\_Class<>$10
    ;log_Print{"source window event: " +Hex$(pedMessage\_Class) + ", " + Hex$(pedMessage\_Qualifier)+ ", " + Hex$(pedMessage\_Code)}
  ;EndIf

  ;If (pedMessage\_Class <> #IDCMP_INTUITICKS) AND (pedMessage\_Class <> #IDCMP_ACTIVEWINDOW) AND (pedMessage\_Class <> #IDCMP_GADGETHELP) AND (pedMessage\_Class <> #IDCMP_CHANGEWINDOW)
  ;  WZ_HideHelp{}
  ;EndIf

  Select pedMessage\_Class
  Case #IDCMP_INTUITICKS
    Gosub handle_event_intuiticks

  Case #IDCMP_REFRESHWINDOW
    Gosub handle_event_newsizewindow

  Case #IDCMP_NEWSIZE
    Gosub handle_event_newsizewindow

  Case #IDCMP_CHANGEWINDOW
    Gosub handle_event_newsizewindow

  Case #IDCMP_ACTIVEWINDOW
    Use Window 0
    Gosub cursor_on

  Case #IDCMP_INACTIVEWINDOW
    Gosub cursor_off

  Case #IDCMP_GADGETDOWN
    Gosub handle_event_gadget

  Case #IDCMP_GADGETUP
    *gadget.Gadget = pedMessage\_IAddress
    ;log_Print{"GADGETUP"}
    ;log_Print{"GadgetID " + Str$(*gadget\GadgetID) + ", Type " + Hex$(*gadget\GadgetType) + ", Activation " + Hex$(*gadget\Activation)}
    ;log_Print{"byte type " + Str$(*gadget\GadgetType AND $00FF)}

  Case #IDCMP_MENUVERIFY
    ; do nothing

  Case #IDCMP_CLOSEWINDOW
    ; exit_loop_code = #MENU_CLOSE
    ; exit_loop_class = -2

    log_Print{"CLOSEWINDOW"}
    _menuitem = #MENU_CLOSE
    Gosub event_menu

  Case #IDCMP_MOUSEBUTTONS
    Gosub handle_event_mousebuttons

  Case #IDCMP_RAWKEY
    Gosub handle_event_rawkey
    ; some events are converted to vanilla events, handle them now:
    If last_vankey <> 0 Then Gosub handle_event_vanillakey
    ;exit_eventloop = True

  Case #IDCMP_VANILLAKEY
    last_vankey = 0
    Gosub handle_event_vanillakey
    ;exit_eventloop = True

  Case #IDCMP_EXTENDEDMOUSE
    Gosub handle_event_extendedmouse

  Case #IDCMP_MOUSEMOVE
    Gosub handle_event_mousemove

  End Select
Return

.handle_event_intuiticks:
  ; ------------ cursor blinking
  blinkcount.b + 1
  If pedconfig\blinkrate > 0
    If blinkcount >= pedconfig\blinkrate
      blinkcount = 0
      ;log_Print{"blink " + Str$(Peek.b(?state_of_cursor))}
      Gosub switch_cursordisplay
    EndIf
  EndIf

  ; ---------------------------------
  If pedconfig\onlinehelp_extended AND pedMessage <> 0
    ; -- wait for at least 1 second before displaying the context
    help_ticks.b + 1 : If help_ticks < 10 Goto skip_this

    ; -- check sourcearea
    USEPATH sourceWindow
    If pedMessage\_MouseX - \win\BorderLeft<0 Then Goto skip_this
    If pedMessage\_MouseY - \win\BorderTop <0 Then Goto skip_this
    If pedMessage\_MouseY - \win\BorderTop - \statusAreaY > 0 Then Goto skip_this
    If pedMessage\_MouseX - \win\BorderRight - \win\Width > 0 Then Goto skip_this
    If (pedMessage\_MouseX = ocmousex.w) AND (pedMessage\_MouseY = ocmousey.w) Then Goto skip_this

    ;log_Print{"checking context help"}
    ; -- check mouseposition in source area
    textX.w = (pedMessage\_MouseX - \win\BorderLeft - \BoxLeft) / \font\tf_XSize + Peek.w(?comWord_ColumnsOffset) + 1
    textY.w = (pedMessage\_MouseY - \win\BorderTop - \BoxTop) / \font\tf_YSize + Peek.l(?comLong_DisplayLineOffset) + 1

    If textX = otextX.w AND textY = otextY.w Then Goto skip_this
    otextX = textX : otextY = textY
    ; -- get the currentsourceline and move to mouse cursor-line
    actualLine.l = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) + 1
    totalLines.l = Peek.l(?comLong_TotalLines)
    *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    delta.w = textY - actualLine
    If (delta <= totalLines) AND (actualLine + delta > 0)
      If delta > 0
        For si.w = 1 To delta
          If *tempLine\nextLine Then *tempLine = *tempLine\nextLine
        Next si
      Else
        If delta < 0
          For si.w = -1 To delta Step -1
            If *tempLine\previousLine Then *tempLine = *tempLine\previousLine
          Next si
        EndIf
      EndIf

      ; -- check out the help and display it
      If *tempLine
        strline$ = PED_Detoke{*tempLine}
        helptext$ = PED_GetWordAtPos{strline$,textX, True}
        If helptext$ <> ""
          helpvalue.l = 0 : msg$ = ""
          ;-- check for a constant
          If Left$(helptext$,1) = "#"
            helptext$ = UnRight$(helptext$,1)
            helpvalue = PED_GetConstantValue{Peek.l(?constantbase),helptext$}
          Else
            ;-- check for a newtype
          EndIf
          ;            $45464748
          ;PED_ShowMessage{helptext$}
          If helpvalue = 0 Then helpvalue = Vallong(helptext$)
          If helpvalue <> 0
            msg$ = helptext$
            ;log_Print{ Str$(helpvalue) }
            helpvaluestr.s = Str$(helpvalue)
            msg$ + Chr$(10) + Chr$(10) + "# " + helpvaluestr
            msg$ + Chr$(10) + "$ " + Hex$(helpvalue)
            msg$ + Chr$(10) + "% " + Bin$(helpvalue)

            msg$ + Chr$(10) + Mkl$(helpvalue)
          EndIf
          If msg$ <> ""
            log_Print{"showing context help: " + msg$}
            WZ_ShowHelp{msg$}
          Else
            WZ_HideHelp{}
          EndIf
          help_ticks = 0
          ocmousex.w = pedMessage\_MouseX : ocmousey.w = pedMessage\_MouseY
        EndIf
      EndIf
    EndIf
    skip_this:
  EndIf
Return

.handle_event_menupick:
  log_Print{"handle_event_menupick - selected menuitem: " + Hex$(_menuitem.l)}
  If pedMessage\_Code <> -1
    ;Gosub set_tedlibbase_bas                     ;why?
    _menuNumber.w = pedMessage\_Code
    _ItemAddress.l = ItemAddress_(Peek.l(?addr_menustrip),_menuNumber AND #MaxWord)
    _menuitem.l = Peek.l(_ItemAddress + $22)             ; Userdata of GadTools, longword right after MenuItem-struct
    exit_loop_class.b = -2
    exit_eventloop.b = True
  EndIf
Return

.handle_event_gadget:
   *gadget.Gadget = pedMessage\_IAddress

    exit_gadgetloop.b = False
    ;log_Print{"GADGETDOWN " + Hex$(pedMessage\_Class)}
    ;log_Print{"GadgetID " + Str$(*gadget\GadgetID) + ", Type " + Hex$(*gadget\GadgetType) + ", Activation " + Hex$(*gadget\Activation)}
    ;log_Print{"byte type " + Str$(*gadget\GadgetType AND $00FF)}

    Select *gadget\GadgetID
    Case #GID_UARROW: last_vankey = $1C : Gosub handle_event_vanillakey
    Case #GID_DARROW: last_vankey = $1D : Gosub handle_event_vanillakey
    Case #GID_RARROW: last_vankey = $1E : Gosub handle_event_vanillakey
    Case #GID_LARROW: last_vankey = $1F : Gosub handle_event_vanillakey
    Case #GID_XPROP
      DEFTYPE.l pos_hprop
      FlushEvents
      Repeat
        If pedMessage\_Class <> 0
          If pedMessage\_Class <> #IDCMP_GADGETUP
            GetAttr_ #PGA_Top,*horizprop, &pos_hprop
            ;GetD0 pos_hprop : MOVE.l d0,-(a7)
            ;!asm
            ;MOVE.l (a7)+,D1
            ;JSR moveCursorToX
            ;!basic
            newColumn.w = pos_hprop : Gosub moveCursorToX
            ;Gosub cursor_on
            Gosub update_statusarea
          Else
            *g.Gadget = pedMessage\_IAddress
            ;If pedMessage\_Class = #IDCMP_GADGETUP AND pedMessage\_Code <> 0 OR pedMessage\_Window<>0
            If *g\GadgetID = #GID_XPROP  Then exit_gadgetloop = True
          EndIf
        EndIf
        PED_GetMessage{False}
      Until exit_gadgetloop = True
      Gosub cursor_on

    Case #GID_YPROP
      If Peek.l(?comLong_DisplayLineOffset) < Peek.l(?comLong_TotalLines)
        Poke.l ?comWord_LinePosStartX, Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine)

        Repeat
          If pedMessage\_Class <> 0
            *g.Gadget = pedMessage\_IAddress

            If pedMessage\_Class <> #IDCMP_GADGETUP
              GetAttr_ #PGA_Top,*vertiprop,&slider_top.l
              totallines.l = Peek.l(?comLong_TotalLines)
              If totallines >= #max_slider_res
                !mul48f{slider_top,totallines,#max_slider_res,realline.l}
              Else
                realline = slider_top
              EndIf
              realline + Peek.l(?comLong_DisplayLine)

              If Peek.l(?comWord_LinePosStartX) <> realline
                Poke.l ?comWord_LinePosStartX, realline
                lineNum.l = realline : Gosub gotoline
                Gosub cursor_on
                Gosub update_statusarea
              EndIf

              ;If pedMessage\_Class = #IDCMP_RAWKEY Then exit_gadgetloop = True
              If pedMessage\_Class = #IDCMP_MOUSEBUTTONS Then exit_gadgetloop = True
            Else
              ; cannot check For GadgetID because of tools like FreeWheel, I do not get the correct GadgetID everytime !?
              If *g\GadgetID = #GID_YPROP AND pedMessage\_Class = #IDCMP_GADGETUP Then exit_gadgetloop = True
            EndIf
            ;log_Print{"YPROP " + Hex$(pedMessage\_Class) + " " + Hexw$(pedMessage\_Code) + " " + Str$(pedMessage\_Window) + "  GadID: " + Str$(*g\GadgetID)}
            ;log_Print{"IAddress: " +Str$(pedMessage\_IAddress) + "  type: " + Hex$(*g\GadgetType) + " x:" + Str$(*g\LeftEdge) + ", y:" + Str$(*g\TopEdge)}
          EndIf
          PED_GetMessage{False}
        Until exit_gadgetloop = True
        ;log_Print{"exit proploop"}
        Gosub cursor_on
      EndIf
    End Select
Return


.handle_event_mousebuttons:
;  log_Print{"handle event mousebuttons..."}
  If NOT Peek.b(?comByte_RunningFlag)            ; only available when no exe is running
    Gosub check_mouse_in_statusarea
  EndIf

; exit_Loop_classes:
;                     Dc.b $FF,$01                  ; VERTICAL SCROLLER      ; -1
;                     Dc.b $FE,$00                  ; SHORTCUT               ; -2
;                     Dc.b $FD,$01                  ; L-MOUSEBUTTON          ; -3
;                     Dc.b $FB,$01                  ; AJL_0_7FCC             ; -4
  Select pedMessage\_Code
  Case #SELECTUP
    If was_selectdown_before.b = True
;      log_Print{"Mouse-Event SELECTUP",#log_debug}
      was_selectdown_before = False
      ;exit_loop_class = -4 ; AJL_0_7FCC
      ;exit_eventloop = True
    EndIf

  Case #SELECTDOWN
    was_selectdown_before.b = True
;    log_Print{"Mouse-Event SELECTDOWN",#log_debug}
    exit_loop_class = -3
    ; left mb not pressed anymore, check doubleclick
    isDoubleClick.b = DoubleClick_(SSeconds.l,SMicros.l,pedMessage\_Seconds,pedMessage\_Micros)
    SSeconds = pedMessage\_Seconds
    SMicros = pedMessage\_Micros
    If pedMessage\_MouseX = Mmx.w AND pedMessage\_MouseY = Mmy.w Then isSameMousePosition.b = True Else isSameMousePosition = False
    Mmx = pedMessage\_MouseX
    Mmy = pedMessage\_MouseY
    If isDoubleClick AND isSameMousePosition
      strline$ = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
      actualword$ = PED_GetWordAtPos{strline$, Peek.w(?comWord_Column),True}
      log_Print{"doubleclick on ==>" + actualword$}
      If WZ_CheckOpen{"WIN_LABELS"}
        search_label$ = StripLead$(LCase$(actualword$),32)
        If StrLeft(search_label$,1)="." Then search_label$ = StrRight(search_label$,-1)
        Use Window WZID("WIN_LABELS")
        WZPrint "STRING_LABEL",search_label$
        Gosub update_labelstuff
      EndIf
    Else
      exit_eventloop = True
    EndIf

  Case #MIDDLEDOWN
    log_Print{"Mouse-Event MIDDLEDOWN",#log_debug}
    If NOT (pedMessage\_Qualifier AND (#IEQUALIFIER_LALT | #IEQUALIFIER_RALT))
      !asm
      JSR jump_historyup
      !basic
    EndIf
  End Select
Return

.handle_event_rawkey:
  mqualifier.w = pedMessage\_Qualifier
  mcode.w = pedMessage\_Code
  ;log_Print{"========= rawkey    code: "+ Hexw$(mcode) + " / quali: "+ Hex$(mqualifier)}
  last_rawkey = pedMessage\_Code       ; rename it to avoid clashes with vanillakey tomsmart1
  last_vankey = 0
  Poke.w ?comWord_QualifierStore, mqualifier

  ; check for Mousewheel Rawkey events from newmouse definition
  Select last_rawkey
  Case #NM_WHEEL_DOWN
    log_Print{"wheel down"}
    Gosub wheel_down

  Case #NM_WHEEL_UP
    log_Print{"wheel up"}
    Gosub wheel_up
  End Select

  ; check for F-Keys / HELP / RETURN / CURSOR
  If mcode = #RAWKEY_HELP Then last_vankey = #VANILLAKEY_HELP
  If mcode = #RAWKEY_TAB Then last_vankey = #VANILLAKEY_TAB
  If mcode = #RAWKEY_RETURN Then last_vankey = #VANILLAKEY_RETURN
  If (mcode => #RAWKEY_F1) AND (mcode <= #RAWKEY_F10) Then last_vankey = mcode + $31 ; convert F-KEYs to vanillakey
  If (mcode => #RAWKEY_UP) AND (mcode <= #RAWKEY_LEFT) Then last_vankey = mcode - $30
Return

.handle_event_vanillakey:
  If last_vankey = 0 Then last_vankey = pedMessage\_Code
  last_rawkey = 0
  mqualifier.w  = pedMessage\_Qualifier AND (NOT #IEQUALIFIER_RELATIVEMOUSE)
  last_mqualifier.w = mqualifier
  Poke.w ?comWord_QualifierStore, mqualifier
  ;log_Print{"event vanillakey: " + Hexw$(last_vankey) + " qualifier: " + Hexw$(mqualifier)}

  ; check key first
  Select last_vankey
  Case #VANILLAKEY_RETURN
    Gosub immediate_syntaxhelp
    ;Gosub do_VANILLAKEY_RETURN
    exit_eventloop.b = True
    Pop Select: Return

  Case #VANILLAKEY_HELP
    log_Print{"HELP"}
    Select mqualifier
    Case #IEQUALIFIER_CONTROL
      log_Print{" + CONTROL"}
      Gosub open_helpdiag

    Case #IEQUALIFIER_LSHIFT
      Gosub startguide

    Case #IEQUALIFIER_RSHIFT
      Gosub startguide

    Default
      log_Print{"default"}
      Gosub immediate_syntaxhelp
    End Select
    Pop Select: Return

  Case #VANILLAKEY_ESC
    Gosub close_contexthelp
    Gosub close_popupwindow
    Pop Select: Return

  Case #VANILLAKEY_DELETE
    Gosub do_VANILLAKEY_DELETE
    exit_eventloop = True
    Pop Select : Return

  Case #VANILLAKEY_BACKSPACE
    Gosub do_VANILLAKEY_BACKSPACE
    exit_eventloop.b = True
    Pop Select : Return

  Case #VANILLAKEY_TAB
    Gosub do_VANILLAKEY_TAB
    exit_eventloop.b = True
    Pop Select : Return

  Case #VANILLAKEY_UP       ; ---------------------------------------------------------------- Cursor Up
    exit_eventloop.b = True
    Pop Select : Return

  Case #VANILLAKEY_DOWN    ; ------------------------------------------------------------------------------------- Cursor Down
    exit_eventloop.b = True
    Pop Select: Return

  Case #VANILLAKEY_LEFT         ; -------------------------------------------------------------- Cursor Left
    If (mqualifier AND #IEQUALIFIER_RSHIFT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
    EndIf
    If (mqualifier AND #IEQUALIFIER_RALT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
    EndIf
    ;log_Print{"cursor left: " +Hex$(mqualifier)}

    Select mqualifier
    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL    ; $800A: select block right
      log_Print{"shift + alt"}
      !asm
      JSR selectblockleft
      !basic

    Case #IEQUALIFIER_LSHIFT          ; move cursor to beginning of line
      ;log_Print{"shift"}
      If Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset) > 0
        newColumn.w = 0 : Gosub moveCursorToX
      Else
        If Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) > 0
          runner.w = 0
          Repeat
            curbyte.b = Peek.b(ped\ptrCurrentSourceData\CurrentSourceLine + 9 + runner)
            runner + 1
          Until (curbyte <> $20) OR (curbyte = 0) OR (runner = #MAX_Columns)
          If (curbyte <> 0) AND (runner > 0)
            runner - 1
            newColumn.w = runner : Gosub moveCursorToX
          EndIf
        EndIf
      EndIf

    Case #IEQUALIFIER_LALT
      log_Print{"alt"}
      !asm
      JSR jump_historyup
      !basic

    Case #IEQUALIFIER_CONTROL                   ; ctrl
      log_Print{"control"}
      If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
        Gosub cursor_off                                                                                                                                                                                                                                    
        Gosub menu_blockuntab
      Else
        Gosub moveCursorToBeginOfWord
        newColumn.w = cursorpos : Gosub moveCursorToX
      EndIf

    Default
      ;log_Print{"no qualifier key"}
      ped\blockmarkRemovalMode = 1
      Gosub moveCursorLeft
    End Select

    Pop Select: Return

  Case #VANILLAKEY_RIGHT            ; ----------------------------------------------------------------------- Cursor Right
    ;log_Print{"cursor right"}
    If (mqualifier AND #IEQUALIFIER_RSHIFT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
    EndIf
    If (mqualifier AND #IEQUALIFIER_RALT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
    EndIf

    Select mqualifier
    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL    ; $800A: select block right
      log_Print{"shift + alt"}
      !asm
      JSR selectblockright
      !basic

    Case #IEQUALIFIER_LSHIFT         ; move to end of line
      log_Print{"shift"}
      lineaddr = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
      textlen.w = getLineLength{lineaddr}
      newColumn.w = textlen : Gosub moveCursorToX                                                                                                                                                                                                           

    Case #IEQUALIFIER_LALT           ; move in history
      log_Print{"alt"}
      !asm
      JSR jump_historydown
      !basic

    Case #IEQUALIFIER_CONTROL        ; $8 tab the marked block
      log_Print{"control"}
      If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
        Gosub cursor_off                                                                                                                                                                                                                                    
        Gosub menu_blocktab
      Else
        Gosub moveCursorToEndOfWord
        newcolumn.w = cursorpos : Gosub moveCursorToX                                                                                                                                                                                                       
      EndIf

    Default
      ped\blockmarkRemovalMode = 1
      Gosub moveCursorRight

    End Select

    Pop Select : Return

  End Select

  ;----------------------------------- check QUALIFIER first
  ; convert right qualifiers to left qualifiers to make selectblock smarter
  If (mqualifier AND #IEQUALIFIER_RSHIFT)
     mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
  EndIf

  Select mqualifier
  Case #IEQUALIFIER_CONTROL         ; CTRL   ---------------------------------------------------------------------------------------
    log_Print{"CONTROL ..."}
    Select last_vankey
    Case $15                        ; ctrl-u
      Gosub cursor_off
      ;MOVEM.l a0-a6/d0-d7,-(a7)
      !asm
      JSR _redraw
      !basic
      ;MOVEM.l (a7)+,a0-a6/d0-d7
      Gosub cursor_on


    Case $0e                        ; ctrl-n
      a$ = "newtype ."
      Gosub insertstring
      !asm
      JSR insertreturn
      JSR insertreturn
      !basic
      a$ = "end newtype "
      Gosub insertstring

    Case $06                        ; ctrl-f
      a$ = "function.l { }"
      Gosub insertstring
      !asm
      JSR insertreturn
      JSR insertreturn
      !basic
      a$ = "function return 0"
      Gosub insertstring
      !asm
      JSR insertreturn
      !basic
      a$ = "end function "
      Gosub insertstring

    Case $13                        ; ctrl-s
      a$ = "statement { }"
      Gosub insertstring
      !asm
      JSR insertreturn
      JSR insertreturn
      !basic
      a$ = "end statement "
      Gosub insertstring

    Case $05                        ; ctrl-e
      a$ = "end if "
      Gosub cursor_off
      Gosub insertstring

    Case $03                        ; ctrl-c
      ped\verticalCopyMode = True    ; set it for column copy
      Gosub menu_copy                         ; do normal copy
      ped\verticalCopyMode = False   ; set it to normal copy

    Case $16                        ; ctrl-v
      ped\verticalCopyMode = True   ; for vertical (Column) paste
      Gosub menu_paste                        ; do paste
      ped\verticalCopyMode = False  ; restore it for normal paste

    Case $18                        ; ctrl-x
      Gosub menu_cut

    Case $09                        ; ctrl-i
      log_Print{"toggle intellisense for commands "}
      If pedconfig\use_commandsintellisens
        pedconfig\use_commandsintellisens = False
      Else
        pedconfig\use_commandsintellisens = True
      EndIf
      last_vankey = 0               ; clear Key
      Gosub intellisense            ; update popupwin
    End Select
    exit_eventloop = True

    Pop Select : Return

  Case #IEQUALIFIER_LCOMMAND + #IEQUALIFIER_LSHIFT
    log_Print{"lcommand and lshift"}
    Select last_vankey
    Case $21                                ; check for "L-AMiGA_!", "LEFT AMIGA + SHIFT + 1"
      sourceWindow\bookmarkLine1 = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)

    Case $22                                ; check for "L-AMiGA_!", "LEFT AMIGA + SHIFT + 2"
      sourceWindow\bookmarkLine2 = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)

    Case $23                                ; check for "L-AMiGA_!", "LEFT AMIGA + SHIFT + 3"
      sourceWindow\bookmarkLine3 = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
    End Select

    Pop Select : Return

  Case #IEQUALIFIER_LCOMMAND        ; LAMIGA -----------------------------------------------------------------------------------------------
    goto_line.l = 0
    log_Print{"lamiga"}
    Select last_vankey
    Case #VANILLAKEY_F4             ; L-AMIGA-F4
       savewinpref{0} : Gosub write_newprefs

    Case #VANILLAKEY_F5             ; L-AMIGA-F5
       savewinpref{1} : Gosub write_newprefs

    Case #VANILLAKEY_F6             ; L-AMIGA-F6
       savewinpref{2} : Gosub write_newprefs

    Case $61                       ; L-AMIGA-A
      goto_line = sourceWindow\lastEditedLine

    Case $31                       ; L-AMIGA-1
      goto_line = sourceWindow\bookmarkLine1

    Case $32                       ; L-AMIGA-2
      goto_line = sourceWindow\bookmarkLine2

    Case $33                       ; L-AMIGA-3
      goto_line = sourceWindow\bookmarkLine3

    End Select

    If goto_line
      Gosub cursor_off
      lineNum.l = goto_line : Gosub gotoline
      Gosub cursor_on
    EndIf
    Pop Select : Return
  End Select

  Select last_vankey
  Case #VANILLAKEY_F1               ; F1
    JSR menu_helpgeneral

  Case #VANILLAKEY_F2               ; check for "F2"
    JSR menu_helpincludesguide

  Case #VANILLAKEY_F3               ; check for "F3"
    JSR menu_helpblitzlibs

  Case #VANILLAKEY_F4               ; check for "F4"
    ped\lastLayout = 0
    Gosub load_windowlayouts
    Gosub do_windowlayout

  Case #VANILLAKEY_F5               ; check for "F5"
    ped\lastLayout  = 1
    Gosub load_windowlayouts
    Gosub do_windowlayout

  Case #VANILLAKEY_F6               ; check for "F6"
    ped\lastLayout  = 2
    Gosub load_windowlayouts
    Gosub do_windowlayout

  Case #VANILLAKEY_F7               ; check for "F7"
    Gosub navigate_to_previous_label

  Case #VANILLAKEY_F8               ; check for "F8"
    Gosub navigate_to_next_label

  Case #VANILLAKEY_F9               ; check for "F9"
    Gosub menu_previousfile

  Case #VANILLAKEY_F10              ; check for "F10"
    Gosub menu_nextfile

  Default
    ;log_Print{"no special handling of vanillakey: " + Hexw$(last_vankey) + " *** INSERT CHAR*"}
    Gosub insertchar
    ;exit_loop_class = last_vankey
    ;exit_eventloop.b = True
  End Select
Return

.do_VANILLAKEY_RETURN:
  log_Print{"RETURN"}
  Gosub close_popupwindow
  !asm
  JSR insertreturn
  ;JSR immediate_syntaxhelp
  !basic
Return

.do_VANILLAKEY_DELETE
  log_Print{"DELETE"}
  If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : Gosub handle_blockmark
    Return
  EndIf

  If (mqualifier AND #IEQUALIFIER_RSHIFT)
    mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
  EndIf

  Select mqualifier
  Case #IEQUALIFIER_LSHIFT
    log_Print{"SHIFT"}
    Poke.w ?comWord_KeyBeforeReturn,last_vankey       ; save keycode
    CursorXTarget.w = Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)
    ; delete all until end of line (replace with spaces)
    lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
    For cupos.w = CursorXTarget To #MAX_Columns-1
      Poke.b lineaddr + cupos, $20
    Next cupos
    Gosub updateSourceLine

  Default
    Gosub deletekey

  End Select
Return

.do_VANILLAKEY_BACKSPACE
  log_Print{"BACKSPACE"}
  If Peek.w(?comWord_Column) > 0 OR Peek.w(?comWord_ColumnsOffset) > 0
    Gosub moveCursorLeft
    delete_mode.l = #VANILLAKEY_BACKSPACE
    Gosub deletekey
    delete_mode = 0
  Else
      If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
        ped\blockmarkRemovalMode = 2 : Gosub handle_blockmark
        ;Gosub deletekey
      Else
        actualLine.l = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine)
        If actualLine > 0
          log_Print{"join lines!"}
          Gosub storeline_bas
          Gosub movecursorlineup
          ; find last character in previous line
          lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
          tempOffset.w = #MAX_Columns - 1
          While Peek.b(lineaddr+tempOffset) = $20 AND tempOffset>-1
            tempOffset - 1
          Wend
          tempOffset + 1
          ;log_Print{"calculated column: " + Str$(tempOffset)}

          Poke.w ?comWord_Column, tempOffset
          Gosub menu_joinline
        EndIf
      EndIf
  EndIf
Return

.do_VANILLAKEY_TAB:
  log_Print{"TAB   " + Hexw$(last_vankey)}
  If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : Gosub handle_blockmark
  EndIf

  ;log_Print{Hex$(mqualifier)}
  Poke.w ?comWord_KeyBeforeReturn, last_vankey

  If pedconfig\tab_size = 0 Then pedconfig\tab_size = 1
  currentColumn.w = Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)

  If (mqualifier AND #IEQUALIFIER_RSHIFT) OR (mqualifier AND #IEQUALIFIER_LSHIFT)
    ;log_Print{"shift"}
    newColumn.w = currentColumn - pedconfig\tab_size
  Else
    newColumn.w = currentColumn + pedconfig\tab_size
  EndIf
  moveCount.b = newColumn - currentColumn

  ;log_Print{"move " + Str$(moveCount) + "  newColumn: " + Str$(newColumn)}

  If (newColumn < #MAX_Columns) AND (newColumn >= 0)
    ; check blockmark
    If Peek.l(?comLong_BlockEndY) <> $ffffFFFF
      result.b = 0
      !checkBeforeBlockStartX{result}
      If result Then Poke.w ?comWord_BlockStartX, Peek.l(?comWord_BlockStartX) + moveCount
      !checkBeforeBlockEndX{result}
      If result Then Poke.w ?comWord_BlockEndX, Peek.l(?comWord_BlockEndX) + moveCount
      Gosub adjustBlockPosition  ; JL_0_7A14
    EndIf

    ;-- move rest of line to right or left
    lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
    ;log_Print{"currentcolumn: " +Str$(currentColumn)}
    ;log_Print{Peeks$(lineaddr, 30)}
    If moveCount > 0
      For cupos.w = #MAX_Columns-1 To currentColumn Step -1
        Poke.b lineaddr + cupos, Peek.b(lineaddr + cupos - moveCount)
      Next cupos

      ;-- scroll tab_size to right and fill with new space characters
      Poke.w ?comWord_Column, Peek.w(?comWord_Column) + Peek.w(?comWord_ColumnsOffset)
      For cupos.w = 0 To moveCount - 1
        Poke.b lineaddr + currentColumn + cupos,$20 ; insert space character
        sourceWindow\Column = Peek.w(?comWord_Column)
        sourceWindow\DisplayLine = Peek.l(?comLong_DisplayLine)
        PED_ScrollHorizontal{#SCROLL_RIGHT, #SCROLL_CURRENT_LINE}
        enteredChar.b = $20 : Gosub print_entered_char
      Next cupos

      ;-- set new cursor position
      newColumn.w = Peek.w(?comWord_Column) + moveCount : Gosub moveCursorToX

    Else
      ; move characters to left an fill with empty spaces
      For aaa.b = 1 To Abs(moveCount)
        For cupos.w = newColumn To #MAX_Columns-1
          Poke.b lineaddr + cupos, Peek.b(lineaddr + cupos + 1)
        Next cupos
      Next aaa
      For cupos.w = #MAX_Columns-1 + moveCount To #MAX_Columns-1
        Poke.b lineaddr + cupos, $20 ; insert space character
      Next cupos

      Poke.w ?comWord_Column, Peek.w(?comWord_Column) + moveCount
      CursorXTarget.w = Peek.w(?comWord_Column)
      Gosub updateSourceLine

    EndIf
    ;log_Print{Peeks$(lineaddr, 30)}

  EndIf
Return



.do_VANILLAKEY_UP:
    Gosub close_popupwindow

    ; convert right qualifiers to left qualifiers to make selectblock smarter
    If (mqualifier AND #IEQUALIFIER_RSHIFT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
    EndIf
    If (mqualifier AND #IEQUALIFIER_RALT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
    EndIf

    ; remove REPEAT qualifier
    mqualifier = mqualifier & (NOT #IEQUALIFIER_REPEAT); remove "pressing" flag

    Select mqualifier
    Case 0  ;#IEQUALIFIER_RELATIVEMOUSE   ; $8000 (just the key)
      ped\blockmarkRemovalMode = 1
      Gosub movecursorlineup

    Case #IEQUALIFIER_LSHIFT   ; $8001
      log_Print{"shift"}
      tmpvalue.l = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine)
      log_Print{"current line: " + Str$(tmpvalue)}
      If tmpvalue < Peek.l(?viewablelines)
        tmpvalue = 0
      Else
        tmpvalue = tmpvalue - Peek.l(?viewablelines)
      EndIf
      log_Print{"going to line: " + Str$(tmpvalue)}
      lineNum.l = tmpvalue : Gosub gotoline

    Case #IEQUALIFIER_CONTROL  ; $8008
      log_Print{"control"}
      Gosub menu_top

    Case #IEQUALIFIER_LALT     ; $8010
      log_Print{"alt"}
      Gosub movelineup

    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL ; $8009
      log_Print{"shift + control"}
      !asm
      JSR selectblockup
      !basic

    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_LALT    ; $800A: select block upwarts
      log_Print{"shift + alt"}
      !asm
      JSR selectblockup
      !basic


    ;Case $0000                         ; cursor_up for freewheel

    Default
      log_Print{"default"}
      Gosub movecursorlineup
    End Select
Return

.do_VANILLAKEY_DOWN:
;  log_Print{"cursor down"}
    Gosub close_popupwindow

    ; convert right qualifiers to left qualifiers to make selectblock smarter
    If (mqualifier AND #IEQUALIFIER_RSHIFT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
    EndIf
    If (mqualifier AND #IEQUALIFIER_RALT)
      mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
    EndIf
    ; remove REPEAT qualifier
    mqualifier = mqualifier & (NOT #IEQUALIFIER_REPEAT); remove "pressing" flag

    Select mqualifier
    Case 0  ;#IEQUALIFIER_RELATIVEMOUSE                         ; $8000: one line down
      ped\blockmarkRemovalMode = 1
      Gosub movecursorlinedown

    Case #IEQUALIFIER_LSHIFT   ; $8001: page down
      log_Print{"shift"}
      lineNum.l = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine)
      log_Print{"current line: " + Str$(lineNum)}
      lineNum + Peek.l(?viewablelines)
      If lineNum > Peek.l(?comLong_TotalLines) Then lineNum = Peek.l(?comLong_TotalLines) - 1
      Gosub gotoline

    Case #IEQUALIFIER_CONTROL  ; $8008: jump to bottomline
      log_Print{"control"}
      Gosub menu_bottom

    Case #IEQUALIFIER_LALT     ; $8010: move current line down
      log_Print{"alt"}
      Gosub movelinedown

    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL  ; $8009: select block downwarts
      log_Print{"shift + control"}
      !asm
      JSR selectblockdown
      !basic

    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_LALT     ; $800A: select block downwarts
      log_Print{"shift + alt"}
      !asm
      JSR selectblockdown
      !basic

    ;Case $0000                         ; -- CURSOR DOWN FOR FREEWHEEL

    Default
      log_Print{"default"}
      Gosub movecursorlinedown
    End Select
Return


;Scroll Sourcetext at MouseWheelY events  tomsmart1
.wheel_down:
  Gosub storeline_bas
  Gosub cursor_off

  lineNum.l = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) + pedconfig\wheelStep
  Gosub gotoline

  Gosub update_vertscroller
  Gosub cursor_on
Return


.wheel_up:
  Gosub storeline_bas                                            ; added to save the changes of the corrent line
  Gosub cursor_off

  lineNum.l = Peek.l(?comLong_DisplayLineOffset) + Peek.l(?comLong_DisplayLine) - pedconfig\wheelStep
  Gosub gotoline

  Gosub update_vertscroller                                  ; update position of the vertical scroller
  Gosub cursor_on
Return

.handle_event_mousemove:
  If pedconfig\onlinehelp_extended
    help_ticks.b = 0 : WZ_HideHelp{}
  EndIf
Return

;OS4 MouseWheel events handling  tomsmart1
.handle_event_extendedmouse:
  mcode.w = pedMessage\_Code & $FFFF

  If (mcode = #IMSGCODE_INTUIWHEELDATA)
    log_Print{"extended mouse: wheelevent"}
    *wd.IntuiWheelData  = pedMessage\_IAddress
    ; vertical move
    If *wd\WheelY > 0
      pedconfig\wheelStep = (*wd\WheelY)                     ; get the stepdelta
      Gosub wheel_down                                       ; scroll the sourcetext
    End If
    If *wd\WheelY < 0
      pedconfig\wheelStep = (*wd\WheelY) * -1                ; get the stepdelta an make it to a postiv value
      Gosub wheel_up                                         ; scroll the sourcetext
    End If
  End If
Return



Even
;actualfile:             Dc.l 0  ; current node
;AL_0_84B2:              Dc.l 0  ; some other file, maybe last file

.fontdependent:
 viewablelines:         Dc.l 0
 visiblecolumns:        Dc.w 0
 ;fontHeight:            Dc.w 0
; viewablelines_m1:      Dc.l 0
 textbufferaddr:        Dc.l 0


.menu_helpshortcuts
  Gosub open_shortcuts
Return

.menu_helplibrarybrowser
  Gosub open_librarybrowser
Return

.menu_helpcompletion
  wtemp\ibrowser_x = -2
  wtemp\ibrowser_y = -2
  wtemp\ibrowser_w = -2
  wtemp\ibrowser_h = -2
  Gosub open_instructionbrowser
Return

.menu_helpnews:
  Show_Helpfile{"Changelog","main",""}
Return

.menu_helpblitzlibs:
  Show_Helpfile{"BlitzLibs","main",""}
Return

.menu_helpgeneral:
  Show_Helpfile{"AmiBlitz3","main",""}
Return

.menu_helpprogramming:
  Show_Helpfile{"BlitzProgrammers","main",""}
Return

.menu_helpincludesguide:
  Show_Helpfile{"Main","main",""}
Return


.menu_helpbuildindex
  Gosub set_pointer_busy_bas
  WZ_LockAllOpenWindows{}                                                                                                                                                                                                                                
  BuildHelpIndexWinTitle$ = "Rebuilding"                         ;added so the window title match the function  tomsmart1 ; remove !TRANS{} because it will translated with befor it will displayed  tomsmart1
  Gosub build_HelpIndexFile
  WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                              
  Gosub set_pointer_normal_bas
Return

.write_newprefs
  If WriteFile (0,pedconfig\winprefsFile)
    WriteType 0,wpref(0)
    WriteType 0,wpref(1)
    WriteType 0,wpref(2)
    CloseFile 0
  End If
RTS

Even                   ; make sure to have enough space reserved
.PREFSFORMAT
 ;use_wbcolors:
 ;                       Dc.b $00,$00        ; OBSOLETE
 ;clone_wb:
 ;                       Dc.b $00,$00        ; TOOLTYPE
 ;use_asldims:           Dc.b $FF,$FF
 ;aslreq_x:              Dc.l $18
 ;aslreq_y:              Dc.l $18
 ;aslreq_width:          Dc.l $17C
 ;aslreq_height:         Dc.l $17C
 ;flag_tokenization:     Dc.w $FF,$FF
 ;prefs_source_icon:     Ds.w 3
 ;ownscreen_modeid:      Dc.l 0              ; TOOLTYPE
 ;myscreen_Width:
 ;                       Ds.w 1
 ;ownscreen_width:       Dc.b $02,$80        ; TOOLTYPE
 ;myscreen_Height:
 ;                       Ds.w 1
 ;ownscreen_height:      Dc.b $01,$00        ; TOOLTYPE
 ;myscreen_Depth:
 ;                       Dc.b $00,$00
 ;                       Ds.w 1
 ;clickpos:              Dc.b $00,$0F        ; labelsize??
 ;othercolor:            Dc.b $00,$02        ; TOOLTYPE ex. backgroundcoler
 ;tokencolor:            Dc.b $00,$03        ; TOOLTYPE
 ;str_sourcefontname:   Dc.b 0              ; TOOLTYPE
 ;                       Ds.b #MAX_STRINGSIZE
 ;                       Even
 ;sourcefontstyle:       Dc.b $00            ; TOOLTYPE
 ;sourcefontflags:       Dc.b $03            ; TOOLTYPE
 ;sourcefontsize:        Dc.b $00,$08        ; TOOLTYPE
                        Dc.w 1              ; DUMMY
 ;auto_indent:           Dc.b $FF,$FF        ; TOOLTYPE
 ;use_filepattern:       Dc.b $FF,$FF        ; TOOLTYPE
 ;AL_0_B7E0:             Dc.b $FF,$FF        ; Save xtra-File ???
 tab_size:              Dc.b $00,$02        ; TOOLTYPE
 ;use_pubscreen:        Dc.b $FF,$FF        ; TOOLTYPE
 ;remember_saved:       Dc.b $FF,$FF        ; TOOLTYPE
 ;use_default_pubscreen:Ds.w 1              ; TOOLTYPE
 ;ownscreen_depth:       Dc.b $00,$04        ; TOOLTYPE
 ;startup_folder:        Dc.b $FF,$FF
 ;oldWindowPos:                             ; ??? irgendwas mit Fensterpos  OBSOLETE ??
 ;                       Ds.w 1
 ;oldWindowNumber:                          ; ??? irgendwas mit Fensterpos  OBSOLETE ??
 ;                       Ds.w 1
 ;AL_0_B7F2:                                ; OBSOLETE
 ;                       Ds.w 1
 ;comWord_BoundLinesX:                       ; moved to common.ab3
 ;                       Dc.b $00,$02
 ;comWord_BoundLinesY:
 ;                       Dc.b $00,$06
 ;AL_0_B7F8:
 ;                       Dc.b "%1ld ",0
 ;L_0_B7FE:
;                       Ds.l 4
 Even
.PREFSFORMAT_END


.update_rememberlist:
  tmpfile$ = Peek.s(?comStr_SourceName)
  tmppath$ = Peek.s(?comStr_CurrentDir)
  log_Print{"updating remember menu for " + tmppath$ + tmpfile$}
  h = 0 : exit_rlupdate.b = False
  Repeat
    If dos_FilePart{rememberfiles$(h)} = tmpfile$
      rememberfiles$(h) = dos_AddPart{tmppath$,tmpfile$}
      exit_rlupdate = True
    EndIf
    h + 1
  Until exit_rlupdate OR h = 4

  ; if no empty entry left, roll last out and replace with current one
  If NOT exit_rlupdate
    For h = 3 To 0 Step -1
      rememberfiles$(h+1) = rememberfiles$(h)
    Next h
    rememberfiles$(0) = dos_AddPart{tmppath$,tmpfile$}
  EndIf
  Gosub update_remembermenu
  Gosub write_pedrememberfiles
Return


.write_pedrememberfiles:
  tedfile.l = file_Open{pedconfig\rememberFile,#file_forcewrite}
  If tedfile <> -1
    For h = 0 To 4
      file_WriteString{tedfile,rememberfiles$(h)}
    Next h
    file_Close{tedfile}
  EndIf
Return

.load_pedrememberfile:
  ;-- reset list
  For h = 0 To 4
    rememberfiles$(h) = "<unnamed>"
  Next h

  ;-- load the files
  If dos_Exist{pedconfig\rememberFile}
    tedfile.l = file_Open{pedconfig\rememberFile,#file_read}
    If tedfile >= 0

      If file_GetLength{tedfile} = 1280 ; old format since ab2
        log_Print{"read old rememberfiles"}
        ;file_ReadMem{tedfile,Peek.l(?AL_0_BFE6),$500}
        tmpfile$ = SPACE$($40)
        tmppath$ = SPACE$($60)
        For h = 0 To 4
          file_Seek{tedfile,h * $100}
          file_ReadMem{tedfile,&tmpfile$,$40}
          file_ReadMem{tedfile,&tmppath$,$60}
          rememberfiles$(h) = dos_AddPart{Peek.s(&tmppath$), Peek.s(&tmpfile$)}
          ;log_Print{"["+rememberfiles$(h)+"]"}
        Next h
      Else
        log_Print{"loading new remember format."}
        For h = 0 To 4
          rememberfiles$(h) = file_ReadString{tedfile}
        Next h
      EndIf
      file_Close{tedfile}
    EndIf
  EndIf
  Gosub update_remembermenu
Return

.update_remembermenu:
  If sourceWindow\win Then Gosub init_menus
Return

.load_remembered:
  If pedconfig\remember_saved = False
    log_Print{"loading remembered source is deactivated."}
    Return
  EndIf

  _rememberitem.w = _menuitem - $78
  log_Print{"load remembered [" + Str$(_rememberitem) + "]"}
  log_Print{"selected lastsource: " + rememberfiles$(_rememberitem)}

  If rememberfiles$(_rememberitem) = "<unnamed>"
     Gosub menu_load
     ;TST.l D0
     ;BEQ.w JL_0_BD5A
     ;  !basic
     ;  Gosub analyze_loadedsource
     ;  Gosub set_remembered_filename
     ;  Gosub draw_statusarea
     ;  Gosub write_pedrememberfiles
     ;  !asm
     ;JL_0_BD5A:
     Return
  Else
    log_Print{"check if file already opened."}
    If ped\firstSourceEntry
      *fileEntry.sourceEntry = ped\firstSourceEntry
      Repeat
        If Peek.s(*fileEntry + 8 + $D4) = dos_FilePart{rememberfiles$(_rememberitem)}
          log_Print{"source already loaded, switching to that tab."}
          GetD0 *fileEntry : Gosub selectfile
          Pop If : Pop Repeat : Return
        EndIf
        *fileEntry = *fileEntry\nextEntry
      Until *fileEntry = 0
    EndIf
  EndIf
  ;
  ; -- check if actual source is unnamed to decide to open new or just open
  If ped\ptrCurrentSourceData
    If Peek$(ped\ptrCurrentSourceData + $DE) <> "" Then Gosub menu_opennew
  Else
    log_Print{"no actual file"}
  End If
  ;
  ; -- loading the selected source file
  ;
  log_Print{"loading selected sourcefile"}
  ; TODO: refacoring of following code, is used more than one time (see menu_load)
  If ped\ptrCurrentSourceData\SourceChanged
    dummy.l = ask{!TRANS{"You have unsaved changes!"},!TRANS{"Continue|Cancel"},!TRANS{"Load File"}}
    If dummy = 0 Then Return
  EndIf

  loadsourcefilename.s = rememberfiles$(_rememberitem)
  Gosub load_source
  Gosub analyze_loadedsource
  Gosub draw_statusarea
Return

.set_remembered_filename:
  tmpfile$ = Peek.s(?comStr_SourceName)
  tmppath$ = Peek.s(?comStr_CurrentDir)
  rememberfiles$(_rememberitem-1) = dos_AddPart{tmppath$,tmpfile$}
  log_Print{"set [" + rememberfiles$(_rememberitem) + "] to item [" +Str$(_rememberitem) + "]"}
Return
addr_menustrip:       Ds.l 1


.kill_menus
  If Peek.l(Addr GTMenuList(0))<>0
    If sourceWindow\win <> 0 Then ClearMenuStrip_ sourceWindow\win
    If WZ_CheckOpen{"WIN_NEWTYPE"}            Then Use Window WZID("WIN_NEWTYPE")            : ClearMenuStrip_ WZWindowAddr
    If WZ_CheckOpen{"WIN_LABELS"}             Then Use Window WZID("WIN_LABELS")             : ClearMenuStrip_ WZWindowAddr
    If WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"} Then Use Window WZID("WIN_INSTRUCTIONBROWSER") : ClearMenuStrip_ WZWindowAddr
    If WZ_CheckOpen{"WIN_LIBRARYBROWSER"}     Then Use Window WZID("WIN_LIBRARYBROWSER")     : ClearMenuStrip_ WZWindowAddr
    If WZ_CheckOpen{"WIN_SEARCH"}             Then Use Window WZID("WIN_SEARCH")             : ClearMenuStrip_ WZWindowAddr
    If WZ_CheckOpen{"WIN_SHORTCUTS"}          Then Use Window WZID("WIN_SHORTCUTS")          : ClearMenuStrip_ WZWindowAddr
    Free GTMenuList 0
    Poke.l ?addr_menustrip,0
  EndIf
Return


.init_menus
  Gosub kill_menus
  GTMenuTitle    0,0,   !TRANS{"Project"                     }
   GTMenuItem  0,0,0, 0,!TRANS{"Project Settings"            },"M"         ,0,#MENU_PROJECTSETTINGS
   GTMenuItem  0,0,0, 1,!TRANS{"IDE Preferences"             },""          ,0,#MENU_IDEPREFERENCES
   GTMenuItem  0,0,0, 2,!TRANS{"Autolayout   "               },""          ,0,#MENU_AUTOLAYOUT
   GTSubItem  0,0,0,2,0,!TRANS{"Set autolayout 1"            },""        ,0,#MENU_GETLAYOUT1
   GTSubItem  0,0,0,2,1,!TRANS{"Set autolayout 2"            },""        ,0,#MENU_GETLAYOUT2
   GTSubItem  0,0,0,2,2,!TRANS{"Set autolayout 3"            },""        ,0,#MENU_GETLAYOUT3
   GTMenuItem  0,0,0, 3,!TRANS{"Menu Edit..."                },""          ,0,#MENU_CUSTOMEDIT       ; entry moved to Project menu  tomsmart1
   GTMenuItem  0,0,0, 4
   GTMenuItem  0,0,0, 5,!TRANS{"Open WB"                     },""          ,0,#MENU_OPENWORKBENCH
   GTMenuItem  0,0,0, 6,!TRANS{"Close WB"                    },""          ,0,#MENU_CLOSEWORKBENCH
   GTMenuItem  0,0,0, 7,!TRANS{"Open Shell"                  },""          ,0,#MENU_OPENSHELL
   GTMenuItem  0,0,0, 8,!TRANS{"Calculator"                  },""          ,0,#MENU_CALCULATOR
   GTMenuItem  0,0,0, 9
   GTMenuItem  0,0,0,10,!TRANS{"About AmiBlitz3"             },""          ,0,#MENU_ABOUT
   GTMenuItem  0,0,0,11
   GTMenuItem  0,0,0,12,!TRANS{"Iconify"                     },""          ,0,#MENU_ICONIFY
   GTMenuItem  0,0,0,13,!TRANS{"Quit"                        },"Q"         ,0,#MENU_QUIT

  GTMenuTitle    0,1,   !TRANS{"Source File"                 }
   GTMenuItem  0,0,1, 0,!TRANS{"New..."                      },""          ,0,#MENU_NEW
   ; -- scan for any templates
   ClearList templates()
   templatepath.s = dos_AddPart{pedconfig\sourceDir , "Templates"}
   *root.ml_node  = ml_AddPathNode{0,templatepath.s,"#?.(bb2|ab2|ab3|asc)"}
   *node.ml_node  = *root
   templates.w    = 0
   While *node><0 AND templates < #MAX_MENUTEMPLATES
     fil.s = ml_GetUserString{*node}
     If dos_IsDir{fil} = False
        mtitle.s = Replace$(dos_RemExt{dos_FilePart{fil}},"_"," ")
        shortc.l = #MENU_TEMPLATE + templates
        GTSubItem  0,0,1, 0,templates,mtitle.s                    ,""          ,0,shortc
        If AddLast(templates()) Then templates()\filename = fil
        templates + 1
     End If
     *node = ml_GetNextNode{*node}
   Wend
   ml_RemoveAllNodes{*root}
   GTMenuItem  0,0,1, 1,!TRANS{"Open"                        },"O"         ,0,#MENU_OPEN
   GTMenuItem  0,0,1, 2,!TRANS{"Open New"                    },""          ,0,#MENU_OPENNEW
   GTMenuItem  0,0,1, 3,!TRANS{"Include File"                },"I"         ,0,#MENU_INCLUDEFILE
   GTMenuItem  0,0,1, 4
   GTMenuItem  0,0,1, 5,!TRANS{"Save"                        },"S"         ,0,#MENU_SAVE
   GTMenuItem  0,0,1, 6,!TRANS{"Save As..."                  },"A"         ,0,#MENU_SAVEAS
   GTMenuItem  0,0,1, 7
   GTMenuItem  0,0,1, 8,!TRANS{"Print..."                    },""          ,0,#MENU_PRINT
   GTMenuItem  0,0,1, 9
   GTMenuItem  0,0,1,10,!TRANS{"Close"                       },""          ,0,#MENU_CLOSE
   If pedconfig\remember_saved
     GTMenuItem  0,0,1,11
     For h = 0 To 4
       GTMenuItem  0,0,1,12+h,dos_FilePart{rememberfiles$(h)} ,Str$(h+1)    ,0,#MENU_LASTSOURCE1 + h
     Next h
   EndIf


  GTMenuTitle    0,2,   !TRANS{"Edit"                        }
   GTMenuItem  0,0,2, 0,!TRANS{"Cut"                         },"X"         ,0,#MENU_CUT
   GTMenuItem  0,0,2, 1,!TRANS{"Copy"                        },"C"         ,0,#MENU_COPY
   GTMenuItem  0,0,2, 2,!TRANS{"Paste"                       },"V"         ,0,#MENU_PASTE
   GTMenuItem  0,0,2, 3,!TRANS{"Duplicate"                   },"Z"         ,0,#MENU_DUPLICATE
   GTMenuItem  0,0,2, 4,!TRANS{"Forget"                      },"W"         ,0,#MENU_FORGET
   GTMenuItem  0,0,2, 5,!TRANS{"Kill"                        },"K"         ,0,#MENU_KILL
   GTMenuItem  0,0,2, 6,!TRANS{"Save Block As..."            },""          ,0,#MENU_SAVEBLOCKAS
   GTMenuItem  0,0,2, 7
   GTMenuItem  0,0,2, 8,!TRANS{"Insert Line"                 },""          ,0,#MENU_INSERTLINE
   GTMenuItem  0,0,2,09,!TRANS{"Delete Line"                 },"D"         ,0,#MENU_DELETELINE
   GTMenuItem  0,0,2,10,!TRANS{"Undelete Line"               },"U"         ,0,#MENU_UNDELETELINE
   GTMenuItem  0,0,2,11,!TRANS{"Join Lines"                  },"J"         ,0,#MENU_JOINLINES
   GTMenuItem  0,0,2,12,!TRANS{"Delete to EOL"               },"Y"         ,0,#MENU_DELETETOEOL
   GTMenuItem  0,0,2,13
   GTMenuItem  0,4,2,14,!TRANS{"Block Tab"                   },"CTRL+Right",0,#MENU_BLOCKTAB
   GTMenuItem  0,4,2,15,!TRANS{"Block Untab"                 },"CTRL+Left" ,0,#MENU_BLOCKUNTAB
   GTMenuItem  0,0,2,16,!TRANS{"Block Comment"               },"{"         ,0,#MENU_BLOCKCOMMENT
   GTMenuItem  0,0,2,17,!TRANS{"Block Uncomment"             },"}"         ,0,#MENU_BLOCKUNCOMMENT
   GTMenuItem  0,0,2,18,!TRANS{"Mark Indent"                 },""          ,0,#MENU_MARKINDENT
   GTMenuItem  0,0,2,19,!TRANS{"Insert Filename"             },""          ,0,#MENU_INSERTFILENAME
   GTMenuItem  0,0,2,20,!TRANS{"Open Filename Under Cursor"  },""          ,0,#MENU_OPENFILEUNDERCURSOR



  GTMenuTitle    0,3,   !TRANS{"Navigation"                  }
   GTMenuItem  0,0,3, 0,!TRANS{"Find..."                     },"F"         ,0,#MENU_OPENFIND
   GTMenuItem  0,0,3, 1,!TRANS{"Find Next"                   },"N"         ,0,#MENU_FIND
   GTMenuItem  0,0,3, 2,!TRANS{"Find Previous"               },"P"         ,0,#MENU_PREVIOUS
   GTMenuItem  0,0,3, 3,!TRANS{"Replace & Find"              },"R"         ,0,#MENU_REPLACE
   GTMenuItem  0,0,3, 4
   GTMenuItem  0,4,3, 5,!TRANS{"Top"                         },"CTRL+Up"   ,0,#MENU_TOP
   GTMenuItem  0,4,3, 6,!TRANS{"Bottom"                      },"CTRL+Down" ,0,#MENU_BOTTOM
   GTMenuItem  0,0,3, 7,!TRANS{"Goto Line..."                },"G"         ,0,#MENU_GOTOLINE
   GTMenuItem  0,0,3, 8
   GTMenuItem  0,4,3,09,!TRANS{"Previous Page"               },"F9"        ,0,#MENU_PREVPAGE
   GTMenuItem  0,4,3,10,!TRANS{"Next Page"                   },"F10"       ,0,#MENU_NEXTPAGE


  GTMenuTitle    0,4,   !TRANS{"Compiler"                    }
   GTMenuItem  0,0,4, 0,!TRANS{"Compile & Run"               },"#"         ,0,#MENU_COMPILERUN
   GTMenuItem  0,0,4, 1,!TRANS{"Save & Compile & Run"        },"B"         ,0,#MENU_SAVECOMPILERUN
   GTMenuItem  0,0,4, 2,!TRANS{"Run"                         },""          ,0,#MENU_RUN
   GTMenuItem  0,0,4, 3,!TRANS{"Create Executable..."        },"E"         ,0,#MENU_CREATEEXE
   GTMenuItem  0,0,4, 4,!TRANS{"Save & Create Executable"    },"T"         ,0,#MENU_SAVECREATEEXE
   GTMenuItem  0,0,4, 5,!TRANS{"Create minimized Executable" },""          ,0,#MENU_CREATERELEASEEXE
   GTMenuItem  0,0,4, 6,!TRANS{"Create Resident..."          },""          ,0,#MENU_CREATERESIDENT
   GTMenuItem  0,0,4, 7
   GTMenuItem  0,0,4, 8,!TRANS{"Set CLI Arguments"           },""          ,0,#MENU_SETCLIARGS
   GTMenuItem  0,0,4, 9,!TRANS{"Reload Userlibs"             },"\"         ,0,#MENU_RELOAD_USERLIBS
   GTMenuItem  0,0,4,10
   GTMenuItem  0,0,4,11,!TRANS{"Compiler Settings"           },""          ,0,#MENU_COMPILERSETTINGS
   GTMenuItem  0,1,4,12,!TRANS{"Create Debug Code"           },""          ,0,#MENU_CREATEDEBUGCODE


  GTMenuTitle    0,5,   !TRANS{"Help"                        }
   GTMenuItem  0,0,5, 0,!TRANS{"What's New?"                 },""          ,0,#MENU_WHATSNEW
   GTMenuItem  0,0,5, 1
   GTMenuItem  0,4,5, 2,!TRANS{"General AB3 Guide"           },"F1"        ,0,#MENU_GENERALGUIDE
   GTMenuItem  0,0,5, 3,!TRANS{"Programming in Blitz"        },""          ,0,#MENU_PROGRAMGUIDE
   GTMenuItem  0,4,5, 4,!TRANS{"Includes Guide"              },"F2"        ,0,#MENU_INCLUDEGUIDE
   GTMenuItem  0,4,5, 5,!TRANS{"Blitzlibs Guide"             },"F3"        ,0,#MENU_BLITZLIBSGUIDE
   GTMenuItem  0,0,5, 6,!TRANS{"Shortcuts Reference"         },""          ,0,#MENU_SHORTCUTREFERENCE
   GTMenuItem  0,0,5, 7
   GTMenuItem  0,0,5, 8,!TRANS{"Instruction Browser"         },""          ,0,#MENU_INSTRUCTIONBROWSER
   GTMenuItem  0,0,5, 9,!TRANS{"Source Browser"              },""          ,0,#MENU_SOURCEBROWSER
   GTMenuItem  0,0,5,10,!TRANS{"Definition Browser"          },""          ,0,#MENU_DEFINITIONBROWSER
   GTMenuItem  0,0,5,11,!TRANS{"Library Browser"             },""          ,0,#MENU_LIBRARYBROWSER
   GTMenuItem  0,0,5,12
   GTMenuItem  0,0,5,13,!TRANS{"Update Instruction Index"    },""          ,0,#MENU_UPDATEHELPINDEX

  Gosub load_custommenus
  If FirstItem(custommenu())                                                   ; changed code the CustomMenu only apear if there ar an entry  tomsmart1
    GTMenuTitle 0,6,    !TRANS{"Custom"                      }                 ; move MenuEdit entry to ProjectMenu  tomsmart1
      menuentry.b = 0                                                            ; change startentry  tomsmart1
      Repeat
        ;If custommenu()\itemname = "~"
        ;  GTMenuItem 0,0,6,menuentry
        ;Else
          shortc = #MENU_CUSTOMITEM1+menuentry                                 ; changed because CostomMenuEntry got its own ID  tomsmart1
          GTMenuItem 0,0,6,menuentry,custommenu()\itemname,"",0,shortc         ; changed because CostomMenuEntry got its own ID  tomsmart1
        ;EndIf
        menuentry + 1
      Until NOT NextItem(custommenu())
  EndIf

  CreateMenuStrip 0
  ;If templates = 0 Then GTMenuState 0,1,0,Off
  If Peek.l(Addr GTMenuList(0))<>0
    Poke.l ?addr_menustrip,Peek.l(Addr GTMenuList(0))

    If sourceWindow\win <> 0                  Then                                             SetMenuStrip_  sourceWindow\win,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_SHORTCUTS"}          Then Use Window WZID("WIN_SHORTCUTS")          : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_SEARCH"}             Then Use Window WZID("WIN_SEARCH")             : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_NEWTYPE"}            Then Use Window WZID("WIN_NEWTYPE")            : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_LABELS"}             Then Use Window WZID("WIN_LABELS")             : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"} Then Use Window WZID("WIN_INSTRUCTIONBROWSER") : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
    If WZ_CheckOpen{"WIN_LIBRARYBROWSER"}     Then Use Window WZID("WIN_LIBRARYBROWSER")     : SetMenuStrip_ WZWindowAddr,Peek.l(?addr_menustrip)
  EndIf
Return


.load_custommenus:
  If dos_Exist{pedconfig\menuFile}
    fid.l = file_Open{pedconfig\menuFile,#file_read}
    If fid >= 0
      ClearList custommenu()
      While file_EOF{fid} = False
        textline.s = file_ReadLine{fid}
        If textline <> "" AND AddLast(custommenu())
          InitArgParse textline
          custommenu()\itemname  = NextArgChar$(@",")
          custommenu()\shortcut  = NextArgChar$(@",")
          custommenu()\id        = Vallong(NextArgChar$(@","))
          custommenu()\path      = NextArgChar$(@",")
          custommenu()\runwbmode = Vallong(NextArgChar$(@","))
          custommenu()\stacksize = Vallong(NextArgChar$(@","))
          custommenu()\prio      = Vallong(NextArgChar$(@","))
        EndIf
      Wend
      file_Close{fid}
    End If
  EndIf
Return


Even
.menutable:
;   $5A: Leerzeile im Menu
;   $50: Compile & Run
;   $5b: Save & Create Exec
;   $5c: Save & Compile & Run
;   $5d: Debug / Runerrors On 10*slower Code
;   $5e: Create Executable absolut Smallest

;   $56: CLI arguments
;   $57: calculator
;   $58: reload all libs
;   $59: open sourcebrowser

  Dc.l #MENU_NEW                      ; menu/shortcut ID            ; replaced hardcode values with constants  tomsmart1
  Dc.l 0                              ; refresh after function call 0= No  1 Yes
  Dc.l menu_opennew                   ;new      (function call address)

  Dc.l #MENU_OPENNEW
  Dc.l 0
  Dc.l menu_openload                  ;open new and load

  Dc.l #MENU_OPEN
  Dc.l 1
  Dc.l menu_load                      ;load

  Dc.l #MENU_INCLUDEFILE
  Dc.l 1
  Dc.l menu_includeblock              ;include block

  Dc.l #MENU_SAVE
  Dc.l 0
  Dc.l menu_save                      ;save

  Dc.l #MENU_SAVEAS
  Dc.l 0
  Dc.l menu_saveas                    ;save as

  Dc.l #MENU_EXPORTASCII
  Dc.l 0
  Dc.l menu_saveascii                 ;save ascii

  Dc.l #MENU_CLOSE
  Dc.l 0
  Dc.l menu_quit                      ;quit

  Dc.l #MENU_QUIT
  Dc.l 0
  Dc.l menu_quitall                   ;quitall

  Dc.l #MENU_PRINT
  Dc.l 0
  Dc.l menu_print                     ;print

  Dc.l #MENU_OPENWORKBENCH
  Dc.l 0
  Dc.l menu_openwb                    ;openwb

  Dc.l #MENU_CLOSEWORKBENCH
  Dc.l 0
  Dc.l menu_closewb                   ;closewb

  Dc.l #MENU_ICONIFY
  Dc.l 0
  Dc.l menu_iconify                   ;iconify

  Dc.l #MENU_OPENSHELL
  Dc.l 0
  Dc.l menu_newshell                  ;newcli

  Dc.l #MENU_IDEPREFERENCES
  Dc.l 0
  Dc.l menu_settings                  ;prefs       ; changed to jump direct to the function  tomsmart1

  Dc.l #MENU_AUTOLAYOUT
  Dc.l 0
  Dc.l menu_autolayout

  Dc.l #MENU_GETLAYOUT1
  Dc.l 0
  Dc.l menu_autolayout

  Dc.l #MENU_GETLAYOUT2
  Dc.l 0
  Dc.l menu_autolayout

  Dc.l #MENU_GETLAYOUT3
  Dc.l 0
  Dc.l menu_autolayout


  Dc.l #MENU_ABOUT
  Dc.l 0
  Dc.l menu_about                     ; about
  ;
  Dc.l #MENU_LASTSOURCE1
  Dc.l 1
  Dc.l load_remembered                ; remembered sources

  Dc.l #MENU_LASTSOURCE2
  Dc.l 1
  Dc.l load_remembered

  Dc.l #MENU_LASTSOURCE3
  Dc.l 1
  Dc.l load_remembered

  Dc.l #MENU_LASTSOURCE4
  Dc.l 1
  Dc.l load_remembered

  Dc.l #MENU_LASTSOURCE5
  Dc.l 1
  Dc.l load_remembered

  ; -- MENU SOURCE
  Dc.l #MENU_CUT
  Dc.l 1
  Dc.l menu_cut

  Dc.l #MENU_COPY
  Dc.l 1
  Dc.l menu_copy

  Dc.l #MENU_PASTE
  Dc.l 1
  Dc.l menu_paste

  Dc.l #MENU_DUPLICATE
  Dc.l 1
  Dc.l menu_dublicate

  Dc.l #MENU_FORGET
  Dc.l 1
  Dc.l menu_forget

  Dc.l #MENU_KILL
  Dc.l 1
  Dc.l menu_kill

  Dc.l #MENU_SAVEBLOCKAS
  Dc.l 1
  Dc.l menu_saveblockas

  Dc.l #MENU_INSERTLINE
  Dc.l 0
  Dc.l menu_insertline

  Dc.l #MENU_DELETELINE
  Dc.l 0
  Dc.l menu_deleteline

  Dc.l #MENU_UNDELETELINE
  Dc.l 0
  Dc.l menu_undeleteline            ; undelete

  Dc.l #MENU_JOINLINES
  Dc.l 0
  Dc.l menu_joinline                ; join

  Dc.l #MENU_BLOCKTAB
  Dc.l 1
  Dc.l menu_blocktab                ; block Tab

  Dc.l #MENU_BLOCKUNTAB
  Dc.l 1
  Dc.l menu_blockuntab              ; block untab

  Dc.l #MENU_BLOCKCOMMENT
  Dc.l 1
  Dc.l menu_blockcomment            ; block comment

  Dc.l #MENU_BLOCKUNCOMMENT
  Dc.l 1
  Dc.l menu_blockuncomment

  Dc.l #MENU_MARKINDENT
  Dc.l 1
  Dc.l menu_markindent

  Dc.l #MENU_PROJECTSETTINGS
  Dc.l 0
  Dc.l menu_project

  Dc.l #MENU_TOP
  Dc.l 1
  Dc.l menu_top

  Dc.l #MENU_BOTTOM
  Dc.l 1
  Dc.l menu_bottom

  Dc.l #MENU_GOTOLINE
  Dc.l 1
  Dc.l menu_gotoline

  Dc.l #MENU_PREVPAGE
  Dc.l 0
  Dc.l menu_previousfile

  Dc.l #MENU_NEXTPAGE
  Dc.l 0
  Dc.l menu_nextfile

  Dc.l #MENU_OPENFIND
  Dc.l 1
  Dc.l menu_find

  Dc.l #MENU_FIND
  Dc.l 1
  Dc.l menu_findnext

  Dc.l #MENU_PREVIOUS
  Dc.l 1
  Dc.l menu_findprevious

  Dc.l #MENU_REPLACE
  Dc.l 1
  Dc.l menu_replace

  Dc.l #MENU_WHATSNEW
  Dc.l 0
  Dc.l menu_helpnews

  Dc.l #MENU_GENERALGUIDE
  Dc.l 0
  Dc.l menu_helpgeneral

  Dc.l #MENU_PROGRAMGUIDE
  Dc.l 0
  Dc.l menu_helpprogramming

  Dc.l #MENU_BLITZLIBSGUIDE
  Dc.l 0
  Dc.l menu_helpblitzlibs

  Dc.l #MENU_INCLUDEGUIDE
  Dc.l 0
  Dc.l menu_helpincludesguide           ;syntax

  Dc.l #MENU_INSTRUCTIONBROWSER
  Dc.l 0
  Dc.l menu_helpcompletion

  Dc.l #MENU_SHORTCUTREFERENCE
  Dc.l 0
  Dc.l menu_helpshortcuts

  Dc.l #MENU_LIBRARYBROWSER
  Dc.l 0
  Dc.l menu_helplibrarybrowser

  Dc.l #MENU_UPDATEHELPINDEX
  Dc.l 0
  Dc.l menu_helpbuildindex

  ; end of menutable
  Dc.l $FFFFFFFF                        ; end of menutable  tomsmart1
Even

.compare_strings:       ; compare string in A1/A3     (AJL_0_DD12)
  MOVEQ.l #$00,D0
  MOVEQ.l #$00,D1
  MOVEM.l A1/A3,-(A7)

  JL_0_DD1A:
    MOVE.b (A1)+,D2
    MOVE.b (A3)+,D3
    CMP.b #$20,D2
     BNE.w JL_0_DD2C
    TST.b D3
     BEQ.w JL_0_DD4C

    JL_0_DD2C:
    TST.b D2
     BNE.w JL_0_DD38
    TST.b D3
     BEQ.w JL_0_DD4C

    JL_0_DD38:
    BSET #$5,D2
    BSET #$5,D3
    CMP.b D2,D3
  BEQ.b JL_0_DD1A

  MOVEM.l (A7)+,A1/A3
  MOVEQ.l #$00,D0
  RTS

  JL_0_DD4C:
  MOVEM.l (A7)+,A1/A3
  MOVEQ.l #-$01,D0          ; string not equal
RTS


.menu_project:
  Gosub set_pointer_busy_bas

  Gosub storeCurrentSourceData

  WZ_LockAllOpenWindows{}
  If NOT WZ_CheckOpen{"WIN_PROJECT"}
    WZWindow WZID("WIN_PROJECT"),?wzgui,192,-2,-2,-2,-2,WZID("WIN_PROJECT")
    Use Window WZID("WIN_PROJECT")
    WZ_InitTable{"WIN_PROJECT","PROJECTTABLE",2}
    WZ_SetTableTitle{"PROJECTTABLE","File","Category"}
    WZ_SetTableColors{"PROJECTTABLE",1,0,1,0}
    WZ_SetPriority{"PROJECTTABLE",3,1}
    WZ_SetSortable{"PROJECTTABLE",Off}
    project_tab.b = WZInput("PROJECT_TABS")
    Gosub update_versiongadgets
  EndIf

  MaxLen lf$=64
  MaxLen pa$=64

  actual_file$ = Peek.s(ped\ptrCurrentSourceData + $DE)
  actual_drawer$ = Peek.s(?comStr_CurrentDir)

  If project_tab = 1
    WZ_DrawTable{"PROJECTTABLE"}
    Gosub project_updatesourcelist
  EndIf

  exit_project.b = False
  Repeat
    ev.l = WaitEvent
    Select ev
    Case #IDCMP_IDCMPUPDATE
      Select WZGadName
      Case "PROJECT_TABS"
        project_tab.b = WZInput("PROJECT_TABS")
        If project_tab = 1
          WZ_DrawTable{"PROJECTTABLE"}
          Gosub project_updatesourcelist
        EndIf

      Case "PROJECT_NAME"
        ab2_project\name = WZInputstr

      Case "PROJECT_DRAWER"
        ab2_project\drawer = WZInputstr

      Case "PROJECT_VERSION"
        ab2_project\version = WZInput

      Case "PROJECT_REVISION"
        ab2_project\revision = WZInput


      Case "PROJECT_CREATE"
        If ab2_project\name<>""
          If ask{!TRANS{"The current project and its files will be closed,\\nand all source files will be saved."},!TRANS{"Ok|Cancel"},!TRANS{"Create Project"}}
            WZ_ClearTable{"PROJECTTABLE"}
            WZ_UpdateTable{"PROJECTTABLE"}
            Gosub project_closeallfiles
            ClearType ab2_project
            Gosub project_updatesourcelist
            WZ_ActivateGadget{"PROJECT_NAME"}      ; replaced to use the statement  tomsmart1 2012 03 09                                                                                                                                                 
          EndIf
        Else
          dummy.l = ask{!TRANS{"Illegal Projectname"},!TRANS{"Ok"},!TRANS{"Create Project"}}
        EndIf

      Case "PROJECT_LOAD"
        aslfr_SetRequesterTitle {1,!TRANS{"Choose Project"},!TRANS{"Ok"},!TRANS{"Cancel"}}
        aslfr_SetPath  {1,"",lf$,"#?.a2p",False}
        If aslfr_Request {1,False,False,False,sourceWindow\pedScreen,True}
          lf$=aslfr_GetNextFile{}
        ;If Exists(lf$)>0
          Gosub project_load
          If ab2_project\sourcecounter > 0
            For pc.l = 1 To ab2_project\sourcecounter
              fext$ = dos_GetExt{ab2_project\sourcefile[pc]}
              If fext$="ab2" OR fext$="bb2" OR fext$="bb"
                sourcefile$ = ab2_project\sourcepath[pc]+ab2_project\sourcefile[pc]
                GetD0 &sourcefile$
                !asm
                JSR loadfile
                !basic
              EndIf
            Next pc
            Gosub activatesourcewindow
            Gosub project_updatesourcelist
            Use Window WZID("WIN_PROJECT")
            WindowToFront_ WZWindowAddr
          EndIf
        Else
          If lf$ <> "" Then dummy.l = ask{!TRANS{"This project does not exist."},!TRANS{"Ok"},!TRANS{"Info"}}
        EndIf

      Case "PROJECT_SAVE"
        ab2_project\name = WZGetString("PROJECT_NAME")
        ab2_project\drawer = WZGetString("PROJECT_DRAWER")
        If ab2_project\name <> ""
          Gosub project_save
        Else
          dummy.l = ask{!TRANS{"Illegal Projectname"},!TRANS{"Ok"},!TRANS{"Error"}}
        EndIf

      Case "PROJECT_ADDFILE"
        aslfr_SetRequesterTitle {1,!TRANS{"Add File"},!TRANS{"Ok"},!TRANS{"Cancel"}}
        aslfr_SetPath  {1,ab2_project\drawer,lf$,"",False}
        If aslfr_Request {1,False,False,False,sourceWindow\pedScreen,False}
          actual_file$=aslfr_GetNextFile{}
        ;If Exists(actual_file$) > 0
          ab2_project\sourcecounter + 1
          ab2_project\sourcefile[ab2_project\sourcecounter] = dos_FilePart{actual_file$}

          Gosub project_loadfile
          actual_file$ = dos_FilePart{actual_file$}
          Gosub project_updatesourcelist
          Use Window WZID("WIN_PROJECT")
          WindowToFront_ WZWindowAddr
        Else
          If lf$ <> "" Then dummy.l = ask{!TRANS{"This file does not exist"},!TRANS{"Ok"},!TRANS{"Error"}}
        EndIf

      Case "PROJECT_REMOVEFILE"
        actual_file$ = WZ_GetCell{"PROJECTTABLE",WZ_Row{"PROJECTTABLE"},1}
        For pc = 1 To ab2_project\sourcecounter
          If actual_file$ = ab2_project\sourcefile[pc]
            Gosub project_removefile
            ab2_project\sourcefile[pc] = ""
            ab2_project\sourcepath[pc] = ""
            Gosub project_sortsourcelist
            Gosub project_updatesourcelist
          EndIf
        Next pc
;        Gosub activatesourcewindow                              ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1
;        !asm
;        JSR menu_quit
;        !basic

; -- TAB Versionmanagement --

      Case "INTEGER_VER_MAJOR"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_MINOR"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_PATCH"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_BUILD"
        Gosub get_versiondata_from_gui

      ; -- TAB Changelog --

      Case "CHANGELOG_ADDENTRY"
        If Peek.l(?comPtr_VersionInformation) AND Peek.l(?comPtr_NumberOfBuilds)
          If (Peek.l(?comPtr_VersionInformation)<>0) AND (Peek.l(?comPtr_NumberOfBuilds )<>0)
            version_code.l = Peek.l(Peek.l(?comPtr_VersionInformation))
            anz_builds.l   = Peek.l(Peek.l(?comPtr_NumberOfBuilds))
            vercode$ = Str$(version_code LSR 24 )+"."
            vercode$ + Str$((version_code LSL 8) LSR 24 )+"."
            vercode$ + Str$((version_code LSL 16)LSR 24 )+" (build: "
            vercode$ + Str$(anz_builds)+")"
            project_changelog$ =  "V"+vercode$ + ":\\0a\\0a" + project_changelog$
            WZPrint "CHANGELOG_TEXTFIELD",&project_changelog$
          EndIf
        EndIf

      Case "CHANGELOG_TEXTFIELD"
        project_changelog$ = WZ_GetStringField{"CHANGELOG_TEXTFIELD"}

      End Select

   Case #IDCMP_VANILLAKEY
     Select EventCode
       Case #VANILLAKEY_ESC : exit_project = True
     End Select


    Case #IDCMP_CLOSEWINDOW
      exit_project = True
    End Select

    If project_tab = 1
      wev.l = WZ_CheckTableEvent{ev}
      If wev = #WZTABLEEVENT_DOUBLECLICK
        _sf$ = WZ_GetCell{"PROJECTTABLE",WZ_Row{"PROJECTTABLE"},1}
        If (_sf$<>actual_file$) AND (_sf$<>"<unnamed>")
          actual_file$ = _sf$
          Gosub project_loadfile
;        For pc = 1 To ab2_project\sourcecounter
;          t$ = ab2_project\sourcefile[pc]
;          If t$ = actual_source$ Then WZ_SetActiveRow{"PROJECTTABLE",pc}
;        Next pc
;        WZ_UpdateTable{"PROJECTTABLE"}
          Use Window WZID("WIN_PROJECT")
          WindowToFront_ WZWindowAddr
;        exit_project = True
        EndIf
      EndIf
    EndIf
  Until exit_project = True

  WZ_KillTable{"PROJECTTABLE"}
  WZCloseWindow WZID("WIN_PROJECT")
  FlushEvents
  Gosub activatesourcewindow
  WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                              
  Gosub set_pointer_normal_bas
Return

.project_sortsourcelist
  tempcounter.w = 0
  For i = 1 To #MAX_SOURCEFILES
    If ab2_project\sourcefile[i]<> ""
      tempcounter + 1
      tempproject$(tempcounter,0) = ab2_project\sourcefile[i]
      tempproject$(tempcounter,1) = ab2_project\sourcepath[i]
    EndIf
    ab2_project\sourcefile[i] = ""
    ab2_project\sourcepath[i] = ""
  Next i

  For i = 1 To tempcounter
    ab2_project\sourcefile[i] = tempproject$(i,0)
    ab2_project\sourcepath[i] = tempproject$(i,1)
  Next i
  ab2_project\sourcecounter = tempcounter
Return

.project_updatesourcelist:
  If project_tab = 1
    WZ_ClearTable{"PROJECTTABLE"}
    If ab2_project\sourcecounter > 0
      For pc = 1 To ab2_project\sourcecounter
        t$ = LCase$(ab2_project\sourcefile[pc])
        If Instr(t$,".include") Then u$ = "Include" Else
        If Instr(t$,".bb2")     Then u$ = "AB2-Source" Else
        If Instr(t$,".ab2")     Then u$ = "AB2-Source" Else
        If Instr(t$,".ab3")     Then u$ = "AB3-Source" Else
        If Instr(t$,".bb")      Then u$ = "BB2-Source" Else
        If Instr(t$,".wizard")  Then u$ = "Wizard-GUI-File" Else u$ = dos_GetExt{t$}+" File"
        WZ_AddRow{"PROJECTTABLE",t$,u$}
        If t$ = LCase$(actual_file$) Then WZ_SetActiveRow{"PROJECTTABLE",pc}
      Next pc
    EndIf
    WZ_UpdateTable{"PROJECTTABLE"}

    ab2p$ = ab2_project\name
    ab2d$ = ab2_project\drawer
    WZPrint "PROJECT_NAME",&ab2p$
    WZPrint "PROJECT_DRAWER",&ab2d$
;    WZPrint "PROJECT_VERSION",ab2_project\version
;    WZPrint "PROJECT_REVISION",ab2_project\revision
  EndIf
Return

.project_closeallfiles:
  Gosub activatesourcewindow

  While ped\firstSourceEntry
    !asm
    JSR dummy_compilercall
    !basic
    Gosub free_actualsource
    Gosub close_actualsource
  Wend

  Gosub activatesourcewindow
Return

.project_removefile:
  t$ = actual_file$
  If Instr(t$,".bb2")     OR Instr(t$,".ab2") OR Instr(t$,".ab3")     OR Instr(t$,".bb")
    Gosub project_loadfile
    Gosub menu_quit
    actual_file$ = Peek.s(ped\ptrCurrentSourceData + $DE)
  EndIf
Return

.project_loadfile:
  t$ = LCase$(actual_file$)
  If Instr(t$,".bb2")     OR Instr(t$,".ab2")  OR Instr(t$,".ab3")    OR Instr(t$,".bb")
    GetD0 &actual_file$
    !asm
    JSR loadfile
    !basic
  EndIf
Return

.project_load
  If OpenFile(1,lf$)
    ClearType ab2_project
    ReadType 1,ab2_project
    CloseFile 1
  Else
    dummy.l = ask{!TRANS{"This project could not be loaded"},!TRANS{"Ok"},"Error"}
  EndIf
Return

.project_save
  lf$ = ab2_project\name+".a2p"
  aslfr_SetRequesterTitle {1,!TRANS{"Save Projectfile"},!TRANS{"Ok"},!TRANS{"Cancel"}}
  aslfr_SetPath  {1,ab2_project\drawer,lf$,"(#?.a2p)",False}
  If aslfr_Request {1,True,False,False,sourceWindow\pedScreen,True}
    lf$=aslfr_GetNextFile{}
    If OpenFile(1,lf$)
      WriteType 1,ab2_project
      CloseFile 1
    Else
      dummy.l = ask{!TRANS{"The project could not be saved."},!TRANS{"Ok"},!TRANS{"Error"}}
    EndIf
  EndIf
Return

.get_versiondata_from_gui:
  If WZ_CheckOpen{"WIN_PROJECT"}
    If Peek.l(?comPtr_VersionInformation)
      version_code = WZInput("INTEGER_VER_MAJOR") LSL 24
      version_code + (WZInput("INTEGER_VER_MINOR") LSL 16)
      version_code + (WZInput("INTEGER_VER_PATCH") LSL 8)
      Poke.l Peek.l(?comPtr_VersionInformation),version_code

      Poke.l Peek.l(?comPtr_NumberOfBuilds), WZInput("INTEGER_VER_BUILD")
    EndIf
  EndIf
Return

.update_versiongadgets
  If Peek.l(?comPtr_VersionInformation) AND Peek.l(?comPtr_NumberOfBuilds)
    If (Peek.l(?comPtr_VersionInformation)<>0) AND (Peek.l(?comPtr_NumberOfBuilds)<>0)
      version_code.l = Peek.l(Peek.l(?comPtr_VersionInformation))
      anz_builds.l   = Peek.l(Peek.l(?comPtr_NumberOfBuilds))
      If WZ_CheckOpen{"WIN_PROJECT"}
        Use Window WZID("WIN_PROJECT")
        WZPrint "INTEGER_VER_MAJOR",version_code LSR 24
        WZPrint "INTEGER_VER_MINOR",(version_code LSL 8) LSR 24
        WZPrint "INTEGER_VER_PATCH",(version_code LSL 16)LSR 24
        WZPrint "INTEGER_VER_BUILD",anz_builds
        WZPrint "CHANGELOG_TEXTFIELD",&project_changelog$
      EndIf
    EndIf
  EndIf
Return


.menu_print:
  Gosub set_pointer_busy_bas
  WZ_LockAllOpenWindows{}                                                                                                                                                                                                                                
  If Peek.l(Addr Window(WZID("WIN_PRINT")))=0
    WZWindow WZID("WIN_PRINT"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_PRINT")
    Use Window WZID("WIN_PRINT")
    exit_print.b = False

    Repeat
      ev.l = WaitEvent
      Select ev

        Case #IDCMP_CLOSEWINDOW
          exit_print = True

        Case #IDCMP_IDCMPUPDATE
          Select WZGadName

            Case "PRINT_CANCEL"
              exit_print = True

            Case "PRINT_PRINT"
              printerdevice$ = WZGetString("PRINT_DEVICE")
              Gosub printout_source
              exit_print = True

          End Select

      End Select
    Until exit_print = True

    WZCloseWindow WZID("WIN_PRINT")
  EndIf
  WZ_UnlockAllOpenWindows{}
  Gosub set_pointer_normal_bas
  Gosub activatesourcewindow
Return

.printout_source:
  *prthandle.l = Open_ (&printerdevice$,#HUNK_RELOC_8__MODE_NEWFILE)
  If *prthandle = 0
    Pop If
    error{"Couldnot open Printer."}
    Return
  EndIf

  !asm
  CLR.b instring
  MOVE.l comLong_TotalLines,D6
  MOVEA.l comPtr_FirstSourceLine,A4

  JL_0_F58E:
    MOVEA.l comPtr_Temp_TokenString1,A0
    LEA $9(A4),A1
    MOVE.l A0,D2

    JL_0_F598:                        ;print code
      MOVE.b (A1)+,(A0)+
      BEQ.w JL_0_F5D8
      CMP.b #$22,-1(a0)
      BNE 'l1
        NOT.b instring
     'l1
      TST.b -1(a0)
      BPL.b JL_0_F598
      TST.b instring
      BNE JL_0_F598
     'l2
      MOVE.b -(A0),D0
      LSL.w #8,D0
      MOVE.b (A1)+,D0
      MOVE.b #$1B,(A0)+
      MOVE.b #"[",(A0)+
      MOVE.b #"1",(A0)+
      MOVE.b #"m",(A0)+
      JSR token_to_ascii

      JL_0_F5BC:
        MOVE.b (A3)+,(A0)+
      BNE.b JL_0_F5BC

      MOVE.b #$1B,-$1(A0)
      MOVE.b #"[",(A0)+
      MOVE.b #"2",(A0)+
      MOVE.b #"2",(A0)+
      MOVE.b #"m",(A0)+
    BRA.b JL_0_F598

    JL_0_F5D8:
    MOVE.b #$A,-$1(A0)
    MOVE.l A0,D3
    SUB.l D2,D3
    !regs2stack
    MOVE.l D3,-(a7)
    MOVE.l D2,-(a7)
    !basic
    MOVE.l (a7)+,d0 : *pbuffer.l = PutD0
    MOVE.l (a7)+,d0 : plength.l = PutD0
    Write_ *prthandle, *pbuffer, plength
    !asm
    !stack2regs
    ;JSR _Write(A6)
    ; write_ (d1:buffer, d2:buffer, d3:length)
    MOVEA.l (A4),A4
    SUBQ.l #1,D6
  BNE.b JL_0_F58E

  !basic
  Close_ *prthandle
Return


.call_pluginmenuentry:
  If _menuitem = #MENU_CUSTOMEDIT
    Gosub open_menueditor
    Gosub init_menus
  Else
    _menuitem - #MENU_CUSTOMITEM1                        ; to get the correct CostumMenu entry  tomsmart 1
    If _menuitem >= 0
      ResetList custommenu()
      menuentry = 0
      While _menuitem >= menuentry                       ; changed to get the correct entry  tomsmart1
        dummy = NextItem(custommenu())
        menuentry + 1
      Wend
      If custommenu()\path <> ""
        If custommenu()\runwbmode = False
          dos_RunCli{custommenu()\path,custommenu()\prio,custommenu()\stacksize,False}
        Else
          dos_RunWB{custommenu()\path}
        EndIf
      EndIf
    EndIf
  EndIf
Return


.update_menueditorgadgets                                  ; moved to subroutine to remove double code tomsmart1
    WZPrint "MENUED_ITEMNAME",custommenu()\itemname
    WZPrint "MENUED_STACK"   ,custommenu()\stacksize
    WZPrint "MENUED_PRIO"    ,custommenu()\prio
    If custommenu()\runwbmode = 1
      WZPrint "MENUED_RUNMODE",On
      WZDisable "MENUED_STACK" : WZDisable "MENUED_PRIO"
    Else
      WZPrint "MENUED_RUNMODE",Off
      WZEnable "MENUED_STACK" : WZEnable "MENUED_PRIO"
    EndIf
    WZEnable "MENUED_DEL" : WZEnable "MENUED_SORT"
    WZEnable "MENUED_RUNMODE"
    WZEnable "MENUED_PATH"
Return

.disable_menueditorgadgets                                 ; moved to subroutine to remove double code tomsmart1
    WZPrint "MENUED_ITEMNAME",""
    WZPrint "MENUED_STACK"   ,8192
    WZPrint "MENUED_PRIO"    ,-1
    WZPrint "MENUED_RUNMODE" ,Off
    WZDisable "MENUED_DEL"   : WZDisable "MENUED_SORT"
    WZDisable "MENUED_STACK" : WZDisable "MENUED_PRIO"
    WZDisable "MENUED_RUNMODE"
    WZDisable "MENUED_PATH"
Return

.open_menueditor
  Gosub set_pointer_busy_bas
  WZ_LockAllOpenWindows{}                                                                                                                                                                                                                                
  If NOT WZ_CheckOpen{"WIN_MENUED"}
    WZWindow WZID("WIN_MENUED"),?wzgui,255,-2,-2,-2,-2,WZID("WIN_MENUED")
  End If
  DEFTYPE.List menuedlist
  ; -- get all the defined menuentries
  If FirstItem(custommenu())                               ; test if we have a (first) entry in the list
    item_counter.b = 0
    Repeat
      WZListAdd menuedlist,custommenu()\itemname,-2
      item_counter+1
    Until NOT NextItem(custommenu())
    WZPrint "MENUED_LIST",0,menuedlist                     ; merged two IF-Thens to one and that fixed Hits if ther are no entrys in the list  tomsmart1
    item_counter = 0
    dummy = FirstItem(custommenu())                        ; back to entry 1 to set the status gadgets
    Gosub update_menueditorgadgets
  Else
    Gosub disable_menueditorgadgets
  EndIf
  menued_exit.b = False

  Repeat
    menued_ev.l = WaitEvent

    Select menued_ev
      Case #IDCMP_CLOSEWINDOW
        menued_exit = True

      Case #IDCMP_VANILLAKEY:
        If EventCode = #VANILLAKEY_ESC Then menued_exit = True

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName
          Case "MENUED_ADD"
            ResetList custommenu()
            If AddLast (custommenu())
                WZListAdd menuedlist,"",-2
                custommenu()\itemname = ""
                custommenu()\path     = ""
                custommenu()\runwbmode = False
                custommenu()\stacksize = 8192
                custommenu()\prio = -1
            EndIf
            item_counter = WZListItems (menuedlist)-1
            WZPrint "MENUED_LIST",item_counter,menuedlist,0 ; neue Position in der Liste anspringen und Liste erneuern ; changed that the selection get not lost  tomsmart1
            dummy.l = LastItem(custommenu())
            Gosub update_menueditorgadgets
            WZDisable "MENUED_SAVE"                         ; added to only allow 1 new entry to prevent empty entrys  tomsmart1
            WZDisable "MENUED_ADD"
            WZDisable "MENUED_SORT"
            WZDisable "MENUED_LIST"

          Case "MENUED_DEL"
            ResetList custommenu()
            item_counter = 0
            While (item_counter < WZListNum ("MENUED_LIST")) AND NextItem(custommenu())
              item_counter + 1
            Wend
            If item_counter = WZListNum ("MENUED_LIST")
              KillItem custommenu()
              WZListRemove menuedlist,WZListNum ("MENUED_LIST")
              WZPrint "MENUED_LIST",0,menuedlist,0
            EndIf
            If FirstItem(custommenu())
              Gosub update_menueditorgadgets
            Else
              Gosub disable_menueditorgadgets
            EndIf
            WZEnable "MENUED_SAVE"
            WZEnable "MENUED_ADD"                          ; added to only allow 1 new entry to prevent empty entrys  tomsmart1
            WZEnable "MENUED_LIST"

          Case "MENUED_SORT"
            If FirstItem(custommenu())                     ; merged If-Thens to one  tomsmart1

              StringSort custommenu(),SizeOf.custommenu    ; command changed to fix sorting  tomsmart1

              WZListRemove menuedlist
              dummy = FirstItem(custommenu())
              Repeat
                WZListAdd menuedlist,custommenu()\itemname,-2
              Until NOT NextItem (custommenu())

              WZPrint "MENUED_LIST",0,menuedlist,0
              dummy = FirstItem(custommenu())              ; back to entry 1 to set the status gadgets
              Gosub update_menueditorgadgets
              WZEnable "MENUED_SAVE"
            Else
              Gosub disable_menueditorgadgets
            EndIf


          Case "MENUED_LIST"
            item_counter = 0
            ResetList custommenu()
            While (item_counter < WZListNum ("MENUED_LIST")) AND NextItem(custommenu())
              item_counter + 1
            Wend
            If item_counter = WZListNum ("MENUED_LIST")
              Gosub update_menueditorgadgets
            Else
              Gosub disable_menueditorgadgets
            EndIf

          Case "MENUED_PATH"
            aslfr_SetRequesterTitle {0,!TRANS{"Select a Programm"},"Ok","Cancel"}
            ; replaced to set always a vaild path  tomsmart1
            If custommenu()\path <> ""
              aslfr_SetPath {0,dos_PathPart{custommenu()\path},dos_FilePart{custommenu()\path} }
            Else
              aslfr_SetPath {0,pedconfig\mainDir,""}
            EndIf
            If aslfr_Request {0,False,False,False,sourceWindow\pedScreen}
              custommenu()\path = aslfr_GetNextFile{}
              If custommenu()\path <>""
                custommenu()\itemname = dos_FilePart{custommenu()\path}
                WZPrint "MENUED_ITEMNAME",custommenu()\itemname

                WZListRemove menuedlist
                ResetList custommenu()
                While NextItem (custommenu())
                  WZListAdd menuedlist,custommenu()\itemname,-2
                Wend

                WZPrint "MENUED_LIST",item_counter,menuedlist,0  ; changed that the selection get not lost  tomsmart1
                WZEnable "MENUED_SAVE"
                WZEnable "MENUED_ADD"                            ; added to only allow 1 new entry to prevent empty entrys  tomsmart1
                WZEnable "MENUED_SORT"
                WZEnable "MENUED_LIST"
              EndIf
            EndIf

          Case "MENUED_STACK"
            stacksize.l = WZInput
            custommenu()\stacksize = stacksize
            If custommenu()\itemname<>"" Then WZEnable "MENUED_SAVE"  ; changed to prevent empty entrys  tomsmart1

          Case "MENUED_PRIO"
            prio.l = WZInput
            custommenu()\prio = prio
            If custommenu()\itemname<>"" Then WZEnable "MENUED_SAVE"  ; changed to prevent empty entrys  tomsmart1

          Case "MENUED_RUNMODE"
            checked.l = WZInput
            If checked = 1
              custommenu()\runwbmode = 1
              WZDisable "MENUED_STACK" : WZDisable "MENUED_PRIO"
            Else
              custommenu()\runwbmode = False
              WZEnable "MENUED_STACK" : WZEnable "MENUED_PRIO"
            EndIf
            If custommenu()\itemname<>"" Then WZEnable "MENUED_SAVE"  ; changed to prevent empty entrys  tomsmart1

          Case "MENUED_SAVE"
            ; removed code to fix Hits if entrys are deleted  tomsmart1
            fid.l = file_Open{pedconfig\menuFile,#file_forcewrite}
            If fid >= 0
              If FirstItem(custommenu())
                Repeat
                  file_WriteLine{fid,custommenu()\itemname+",~,0,"+custommenu()\path+","+Str$(custommenu()\runwbmode)+","+Str$(custommenu()\stacksize)+","+Str$(custommenu()\prio)}
                Until NOT NextItem(custommenu())
              EndIf
            EndIf
            file_Close{fid}
            WZDisable "MENUED_SAVE"

          Case "MENUED_EXIT" : menued_exit = True
        End Select
    End Select
  Until menued_exit = True

  FlushEvents
  WZListRemove menuedlist
  WZCloseWindow WZID("WIN_MENUED")
  WZ_UnlockAllOpenWindows{}                                                                                                                                                                                                                              
  Gosub set_pointer_normal_bas
Return


;init_sourceline:
;  MOVEA.l D0,A0
;  CLR.l (A0)
;  CLR.l $4(A0)
;  MOVE.b D5,$8(A0)
;RTS

;.reset_currentLine
;  MOVEQ #0,d0
;  TST.l 4(a4)             ; previousline available ?
;  BEQ 'l20
; 'l10:
;    MOVE.l 4(a4),a4
;    ADDQ.l #1,d0
;    TST.l 4(a4)
;  BNE 'l10
;
;  'l20:
;RTS
;
;.prev_currsourceline
;  TST.l 4(a4)
;  BEQ 'l20
;  MOVE.l 4(a4),a4
;  MOVE.l a4,d0
;  RTS
;
; 'l20
;  MOVEQ #0,d0
;RTS


.jump_addhistory         ;d0 linenum
  MOVEM.l a0/d0-d1,-(a7)
  LEA history,a0
  MOVEQ #0,d1
  MOVE.w historypointer,d1
  MOVE.l comLong_DisplayLineOffset,d0
  ADD.l comLong_DisplayLine,d0
  MOVE.l d0,0(a0,d1)
  ADDQ.w #4,d1
  CMP.w  #maxhistory,d1
  BLE 'nowrap
    MOVEQ #0,d1
 'nowrap:
  MOVE.w d1,historypointer
  MOVEM.l (a7)+,a0/d0-d1
RTS

.jump_historyup:
  !basic
  Gosub storeline_bas
  !asm
  MOVE.l a1,-(a7)
  ;JSR storeline
  LEA history,a0
  MOVE.w historypointer,d1
  SUBQ #4,d1
  BPL 'l10
  MOVEQ #maxhistory,d1
 'l10
  MOVE.w d1,historypointer
  MOVE.l 0(a0,d1.w),d0
  JSR jumpline
  MOVE.l (a7)+,a1
RTS

.jump_historydown
  !basic
  Gosub storeline_bas
  !asm
  MOVE.l a1,-(a7)
  ;JSR storeline
  LEA history,a0
  MOVE.w historypointer,d1
  ADDQ #4,d1
  CMP.w #maxhistory,d1
  BLE 'l10
  MOVEQ #0,d1
 'l10
  MOVE.w d1,historypointer
  MOVE.l 0(a0,d1.w),d0
  JSR jumpline
  MOVE.l (a7)+,a1
RTS

.jump_onclick:
  strline$ = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
  If Instr(strline$,"{") > 0 Then statement_in_line.b = True

  actualword$ = PED_GetWordAtPos{strline$, Peek.w(?comWord_Column),True}
  actualword_len.w = Len(actualword$)
  If actualword_len < 2
    Pop If : Return
  EndIf

  clickjump_fromfile.b = 0
  jump_search:
  log_Print{"search for <" + actualword$ + ">"}

  linecounter.l = 0 : found_definition.b = False : found_to_jump.b = False
  *tempLine = ped\ptrCurrentSourceData\FirstSourceLine
  Repeat
    ;log_Print{Hex$(ped\ptrCurrentSourceData\CurrentSourceLine) + " " + Hex$(*tempLine) + "  " + Str$(linecounter + 1)}

    If *tempLine = ped\ptrCurrentSourceData\CurrentSourceLine
      ;log_Print{"skipping actual line <" + Str$(linecounter+1)+">"}
    Else
      char_before$ = ""
      found_definition = False

      ; check if it is the definition of a Statement/Function/Macro, we skip it!
      strline$ = Trim$(Peek.s(*tempLine + 9))
      tokenID.l = Peek.w(&strline$) AND $FFFF
      Select tokenID
      Case #TOKEN_Statement : found_definition = True
      Case #TOKEN_Function : found_definition = True
      Case #TOKEN_Macro : found_definition = True
      End Select
      If found_definition Then strline$ = UnRight$(strline$,2)

      ; search for clicked word
      found_at.w = Instr(strline$, actualword$)
      If found_at > 0
        log_Print{"found_at: " + Str$(found_at) + " in line " + Str$(linecounter+1) + ":  " + strline$}
        If statement_in_line AND NOT found_definition Then Goto skip_jump
        If found_at > 1 Then char_before$ = Mid$(strline$,found_at-1,1)
        char_after$ = Mid$(strline$,found_at + actualword_len,1)
        log_Print{"before <" + char_before$ + "> after <" + char_after$ + ">" + Str$(linecounter+1) + "  "  +strline$}
        If CheckChr{char_after$, ":;{"} OR (char_before$=".")
          log_Print{"<"+actualword$ + "> in Zeile <" + Str$(linecounter + 1) + "> gefunden, jump!"}
          found_to_jump = True
        EndIf
        skip_jump:
      EndIf
    EndIf
    linecounter + 1
    *tempLine = *tempLine\nextLine
  Until found_to_jump OR (*tempLine = 0)

  If found_to_jump
    Pop If
    GetD0 linecounter-1
    !asm
    JSR jump_addhistory
    JSR jumpline
    !basic
    Return
  EndIf 


  ;-- nothing found in current source search in helpcache
  If clickjump_fromfile = 0
    clickjump_fromfile = 1
    Gosub set_pointer_busy_bas

    ;-- searching in HelpIndexFile for macro or function name
    found_in_cache.b = False
    If actualword$ <> ""
      log_Print{"definition not found in current source, searching in helpcache for <" + actualword$ + ">"}
      ResetList HelpIndexCache()
      While NextItemFast(HelpIndexCache()) AND found_in_cache = False
        If actualword$ = HelpIndexCache()\name OR actualword$ = HelpIndexCache()\includefile
          found_in_cache = True
        End If
      Wend

      If found_in_cache
        tmp_string = dos_AddPart{pedconfig\includeDir, HelpIndexCache()\includefile}
        log_Print{"found in HelpIndexCache(), will open it:" + tmp_string}
        GetD0 &tmp_string
        !asm
        JSR loadfile
        !basic
        Gosub update_vertscroller
        Gosub update_statusarea
        Gosub set_pointer_normal_bas
        *currLine = ped\ptrCurrentSourceData\CurrentSourceLine
        ;-- jump upwards and search again in file ...
        Goto jump_search
      Else
        log_Print{"not found in cache"}
      EndIf
    EndIf
    Gosub set_pointer_normal_bas

  EndIf
Return

.jumpline     ; D0: Zielzeile
  !basic
  lineNum.l = PutRegD0
  If lineNum < Peek.l(?comLong_TotalLines)
    Gosub cursor_off
    clearColumn.b = True: Gosub gotoline
    Gosub update_vertscroller
    Gosub cursor_on
  EndIf
  !asm
RTS


.open_helpdiag
  If diag.l = 0
    WZWindow WZID("WIN_HELPDIAG"),?wzgui,80,wtemp\diag_x,wtemp\diag_y,wtemp\diag_w,wtemp\diag_h,WZID("WIN_HELPDIAG")
    AddedMenu2WZWin{"WIN_HELPDIAG"}
    diag = 1
  End If
  Gosub diag_redraw
Return


.diag_redraw:
  If diag = 0 Then Return

  strline$ = PED_Detoke{ped\ptrCurrentSourceData\CurrentSourceLine}
  actualword$ = PED_GetWordAtPos{strline$, Peek.w(?comWord_Column),True}
  w$ = actualword$
  tokname$ = actualword$
  res$ = ""
  MOVE.l comPtr_TokenBase,token@(a5)
  While token.l
    b$ = Peek$(token+6)
    If b$ = w$
      res$ = Peek$(token+7+Len(b$))
      i = Instr(res$,";")
      If i Then res$ = Left$(res$,i)
    End If
    token = Peek.l(token)
  Wend
  If res$ = ""
    MOVE.l comPtr_MacroBase,a0:MOVE.l (a0),token@(a5)
    c.l = 0
    While token
      b$ = Peek$(token+13)
      If b$ = w$
        i = Peek.w(token+8)
        If i>100 Then i = 100
        res$ = Peeks$(Peek.l(token+4),i)
        res$ = Replace$(res$,";","")
        i = Instr(res$,"}")
        If i Then res$ = Left$(res$,i)
      End If
      token = Peek.l(token)
    Wend
  End If
  diag_addcodesize.l = 0:linesize.l = 0
  If res$<>""
       Use Window WZID("WIN_HELPDIAG")
       tokname$ + "   " + res$
       WZPrint "DIAG_TOKEN",&tokname$
       InitArgParse res$
       For i =  1 To 12
         diag_lab$(i) = NextArgChar$ (@",")
         If diag_lab$(i) = "[" Then i = i - 1 : diag_lab$(i) + "["
         WZPrint "lab" + UStr$(i),&diag_lab$(i)
         diag_val$(i) = ""
         WZPrint "val" + UStr$(i),&diag_val$(i)
       Next
       linesize.l = 0

       MOVEA.l textbufferaddr,A0
       ADDA.w comWord_TextBufferOffset,A0
       MOVE.l a0,a1
       ADD.w #MAX_Columns,a1
       SUBQ.l #1,a1
      's2
       CMP.b #" ",(a1)
       BNE 's1
         SUBQ.l #1,a1
         CMP.l a0,a1
         BNE 's2
      's1
       SUB.l a0,a1
       MOVE.l a1,d1
       MOVE.l d1,linesize@(a5)
       ;MOVE.l comPtr_CurrentSourceLine,a0
       ;LEA 9(a0),a0
       MOVE.w comWord_Column,d0
       BEQ 'l3
      'l1
         CMP.b #" ",0(a0,d0)
         BEQ 'l2
           CMP.b #"{",0(a0,d0)
           BEQ 'l2
           TST.b 0(a0,d0)
           BMI 'l3
             ADDQ.w #1,d0
             BNE 'l1
      'l3
       ADDQ.w #1,d0
       CMP.b #":",0(a0,d0)
       BEQ 'q
         CMP.b #";",0(a0,d0)
         BEQ 'q
           CMP.w d1,d0
           BEQ 'q
             CMP.b #" ",0(a0,d0)
             BEQ 'l2
               CMP.b #"(",0(a0,d0)
               BEQ 'l2
                 CMP.b #"{",0(a0,d0)
                 BEQ 'l2
       BRA 'l3
      'q
       RTS
      'l2
       ADD.l d0,a0
       MOVE.l #MAX_Columns,d0
       SUB.w comWord_Column,d0
       SUBQ.l #1,d0
'la1   CMP.b #$20,(a0)+
       BNE 'la2
       SUBQ.l #1,d0
       BNE 'la1
'la3   CMP.b #$20,-(a0)
       BEQ 'la3
       ADDQ.l #3,a0
'la2   MOVE.l a0,d0
       diag_addcodepos.l = PutD0-1
       MOVE.l diag_addcodepos@(a5),a0
       SUBQ #2,a0
       SUB.l textbufferaddr,A0
       SUB.w comWord_TextBufferOffset,A0
       MOVE.l a0,d0
       SUB.l d0,linesize@(a5)

       If linesize > 1 Then linesize - 1
       If linesize > 0 Then res$ = Peeks$(diag_addcodepos,linesize) : Else res$ = ""
       i.l = 0 : i2.l = 0
       Repeat
       w.l = PeekUB(&res$+i)
       If w = $22 Then i2 BitChg 0
       If i2 = 0
          If w>$80 Then Poke.b &res$+i,w BitClr 7
          If w = @";" OR w = @":" Then w = 0:
       End If
       i+1
       Until w = 0
       diag_addcodesize.l = i
       diag_addstr$ = ""
       If i Then res$ = Left$(res$,i-1)
       If Peek.b (&res$) = @"(" Then res$ = Right$(res$,Len(res$)-1) : diag_addstr$ = "("
       If Peek.b (&res$) = @"{" Then res$ = Right$(res$,Len(res$)-1) : diag_addstr$ = "{"
nopeek:  InitArgParse res$
       For i = 1 To 12
         diag_val$(i) = NextArgChar$(@",","{[(\\22",")]}\\22")
         If diag_lab$(i)<>"" Then WZPrint "val" + UStr$(i),&diag_val$(i)
       Next
 EndIf
RTS


.help_checkfortype:
;!basic
;  curcharptr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset) + Peek.w(?comWord_Column)
;  curchar.w = Peek.b(curcharptr)
;  lastchar.w = Peek.b(curcharptr-1)
;  log_Print{"check current char <" + Chr$(curchar) + "> for type help"}
;  If lastchar = Asc("\")
;    curcharptr - 1
;  Else If curchar <> Asc("\")
;    !asm
;    RTS
;  EndIf
;
;  While Peek.b(curchar-1) = $20
;    curchar - 1
;  Wend
;
;  If Peek.b(curchar) = Asc(")")
;    While Peek.b(curchar-1) <> Asc("(")
;      curchar - 1
;    Wend
;  EndIf
;
;!asm
;RTS
;
  MOVE.w comWord_Column,d1
  ;MOVE.w d1,columnstore
  SUBQ.w #2,d1
  BGT 'w1
    MOVEQ #1,d1
 'w1
  MOVE.l textbufferaddr,a0 : ADD.w comWord_TextBufferOffset,a0
  MOVE.l a0,a1 : SUBQ.l #1,a1
  ADD.w comWord_Column,a0
  ;!regs2stack
  ;!basic
  ;lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset) + Peek.w(?comWord_Column)
  ;log_Print{"check current char: <" + Peeks$(lineaddr,1) + ">"}
  ;!asm
  ;!stack2regs
  CMP.b #"\",-1(a0)
  BEQ typehelp1
    CMP.b #"\",(a0)
    BEQ typehelp2
      ;BRA notypehelp
      RTS
  typehelp1:
  SUBQ #1,a0

  typehelp2:
  CMP.b #$20,-(a0)
  BNE 't2b
    CMP.l a0,a1
    BNE typehelp2
 't2b

  CMP.b #")",(a0)
  BNE 't2
   'rb
      CMP.b #"(",-(a0)
      BEQ 't2c
    CMP.l a0,a1
    BNE 'rb
   't2c
    SUBQ.l #1,a0
 't2

  CMP.b #"_",(a0)
  BEQ 'ok
    CMP.b #$30,(a0)
    BLT 'path
      CMP.b #":",(a0)
      BLT 'p2
        CMP.b #"A",(a0)
        BLT 'path
     'p2
      CMP.b #"z",(a0)
      BGT 'path
 'ok
  MOVEQ #0,d0
  LEA chartab,a1
  ADDQ.l #1,a0
 'x1
    MOVE.b -(a0),d0
    TST.b 0(a1,d0)
    BNE 'x
      BRA 'x1
   'x
  CMP.b #"*",d0
  BEQ 'x1

  CMP.b #".",d0
  BNE 't1
    ;!regs2stack
    ;!basic
    ;log_Print{"typehelp"}
    ;!asm
    ;!stack2regs
    ;CNIF #USE_AREXX = 1
    ;  MOVE.w d1,comWord_Column
    ;  JSR arexxfunc_getword
    ;  MOVE.w columnstore,comWord_Column
      BRA typehelp
    ;CELSE
    ;  RTS
    ;CEND
 't1

  MOVE.l a2,-(a7)
  LEA typestr,a2
  ADDQ.l #1,a0
 'x111
    MOVE.b (a0)+,d0
    TST.b 0(a1,d0)
    BNE 'xc
   'x12
    MOVE.b d0,(a2)+
  BRA 'x111
 'xc
  CMP.b #"*",d0
  BEQ 'x12
  CLR.b (a2)
  MOVE.l comPtr_CurrentSourceLine,a0
  JSR gettype
  TST.l d0
  BNE 'found
  JSR findvar
 'found
  MOVE.l (a7)+,a2
  LEA typestr,a0
  BRA typehelp
 'path
  MOVE.l comPtr_CurrentSourceLine,a0
 'nl2
  MOVE.l 4(a0),d0
;  BEQ notypehelp
  RTS

  MOVE.l d0,a0
  LEA 9(a0),a1
 'l1
    MOVE.b (a1)+,d0
    BEQ 'nl
    CMP.b #$80,d0
    BNE 'l1
    MOVE.b (a1)+,d0
    CMP.b #$ca,d0            ;find usepath
  BNE 'l1
 'u1
    CMP.b #$20,(a1)+
  BEQ 'u1
  MOVE.l a2,-(a7)
  MOVE.l a0,-(a7)
  LEA typestr,a0
  LEA chartab,a2
  MOVEQ #0,d0
  SUBQ.l #1,a1
 'n2
    MOVE.b (a1)+,d0
    CMP.b #"*",d0
    BEQ 'do2
      TST.b 0(a2,d0)
      BNE 'n1
   'do2
    MOVE.b d0,(a0)+
  BRA 'n2
 'n1
  CLR.b (a0)+
  MOVE.l (a7)+,a0

  JSR gettype
  TST.l d0
  BNE 'found2
    JSR findvar
 'found2
  MOVE.l (a7)+,a2
  LEA typestr,a0
  BRA typehelp
 'nl
  BRA 'nl2
  ;  BRA notypehelp
  RTS

  gettype:
  MOVEM.l a0-a1,-(a7)
  LEA typestr,a2
 'nl2
  MOVE.l 4(a0),d0
  BEQ 'exit
  CLR.b deftypefound
  MOVE.l d0,a0
  LEA 9(a0),a1
 'l1
  MOVE.b (a1)+,d0
  BEQ 'nl
  CMP.b #$80,d0
  BNE 'notok
  MOVE.b (a1)+,d0
  CMP.b #$33,d0            ;find deftype
  BNE 'notok
  MOVE.b #1,deftypefound
 'notok
  CMP.b (a2),d0
  BNE 'l1
  MOVE.l a1,d1
  SUB.l #10,d1
  SUB.l a0,d1
  BEQ 'bg1
  CMP.b #",",-2(a1)
  BEQ 'bg1
  CMP.b #" ",-2(a1)
  BNE 'l1
 'bg1
  ADDQ.l #1,a2
 'l2
  MOVE.b (a2)+,d0
  BEQ 'f1
  CMP.b (a1)+,d0
  BEQ 'l2
  LEA typestr,a2
  BRA 'l1
 'f1
 'r1
  CMP.b #$20,(a1)+
  BEQ 'r1

  SUBQ.l #1,a1
  TST.b deftypefound
  BEQ 'nod
    LEA 9(a0),a1
   'lop
      MOVE.b (a1)+,d0
      BEQ 'nl
    CMP.b #".",d0
    BNE 'lop
    SUBQ.l #1,a1
 'nod
  CMP.b #".",(a1)+
  BEQ 'c1
    LEA typestr,a2
    BRA 'l1
 'c1
  LEA typestr,a2
  LEA chartab,a0
  MOVEQ #0,d0
 'loop
    MOVE.b (a1)+,d0
    TST.b 0(a0,d0)
    BNE 'e1
      MOVE.b d0,(a2)+
  BRA 'loop
 'e1
  CLR.b (a2)+
  MOVEM.l (a7)+,a0-a1
  MOVEQ #1,d0
  RTS

 'nl
  BRA 'nl2
 'exit
  MOVEM.l (a7)+,a0-a1
  MOVEQ #0,d0
RTS

;.notypehelp
.help_checkforif:
  *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  nestcount.b = 1
  Repeat
    iffound.b = 0
    *textline.l = *tempLine + 9

    ; kill any spaces before Token
    testaddr.l = Peek.l(*textline) : bytecount = 0
    While (testaddr LSR 16) <> $0000
      testaddr = Peek.l(*textline + bytecount)
      actword.w = testaddr LSR 16

      ; check the token for parts of an if-loop
      Select actword
      Case #TOKEN_EndIf    ; EndIf
        nestcount + 1

;      Case #TOKEN_End    ; End
;        nestcount + 1

      Case #TOKEN_If    ; If
        nestcount - 1
        iffound  = 1

      Case #TOKEN_Then    ; Then
        nestcount + 1
      End Select

;      !cout{nestcount, Hex$(testaddr),linestr$}
      bytecount + 1
    Wend
    If (nestcount = 1) Then Pop Repeat : Goto foundif

    ; get previous line pointer
    *tempLine = *tempLine\nextLine
  Until *tempLine = 0
  foundif:
  If (iffound = 1)
    strline$ = PED_Detoke{*tempLine}
    strline$ = Trim$(strline$)
    PED_ShowMessage{"Corresponding Header: " + strline$}
  EndIf
Return

.close_contexthelp
  If WZ_CheckOpen{"WIN_CONTEXTHELP"}
    WZListRemove helpme.List
    WZCloseWindow WZID("WIN_CONTEXTHELP")
  EndIf
RTS


.close_popupwindow
  If pedconfig\intellisense
    WZ_PopUpCloseNonmodal{}   ; move the code to the new include function  tomsmart1
    popup_selected.l = 0
  EndIf
RTS


.findvar
  !basic
  MOVE.l comPtr_VarBase,d0
  BEQ 'oldped
  MOVE.l d0,a0
  CMP.l #0,(a0)
  BEQ 'oldped
  *nt.l = PutD0:*nt = Peek.l(*nt):
  fvar$ = Peek$(?typestr)
  fvar$ = StripLead$(fvar$,@"*")
  While *nt
    a$ = Peek$(*nt+$13)
    If a$ = fvar$
      it.l = Peek.l(*nt+10)
      If it
        Poke$ ?typestr,Peek$(it+$b)
      End If
    End If
    *nt = Peek.l(*nt)
  Wend
 'oldped
  !asm
RTS

.typehelp
  ;MOVE.l a0,d0
  !basic
  ;i = PutD0 : str2$ = Peek$(i) : a$ = str2$
  str2$ = tokname$ : a$ = str2$
  log_Print{"typehelp [" + a$ + "]"}
  If NOT WZ_CheckOpen{"WIN_NEWTYPE"}
    USEPATH wtemp
    WZWindow WZID("WIN_NEWTYPE"),?wzgui,255,\type_x,\type_y,\type_w,\type_h,WZID("WIN_NEWTYPE")
    AddedMenu2WZWin{"WIN_NEWTYPE"}
    ;GTSetMenuChecked 0,5,9,On
    MOVE.l comPtr_VarBase,d0
    BEQ 'oldped
      MOVE.l d0,a0
      CMP.l #0,(a0)
      BNE 'nocompile
        WTitle "Compile the file to see all"
     'nocompile
    'oldped
     Gosub activatesourcewindow
  End If
  Use Window WZID("WIN_NEWTYPE")
  WZPrint "STRING2",&str2$
  WZPrint "newtype_const",0
  WZPrint "newtype_var",0
  WZPrint "newtype_struct",1
  ped\newtype_mode = 2
  lev.l = 0
  find.l = 0
  Gosub newtype_selecttype
  lev = 1

  MOVE.l newtypebase,d0
  *nt.l = PutD0
  If *nt
    *nt = Peek.l(*nt):
    While *nt
      b$ = Peek$(*nt+11)
      If b$ = a$:
        quicktype = 1 : Gosub newtype_listsubtype
        find = 1 : Pop If : Goto f1ab
      End If
      *nt = Peek.l(*nt)
    Wend
  EndIf
  quicktype = 0
  f1ab:
  !asm
RTS

.open_librarybrowser:
  If NOT WZ_CheckOpen{"WIN_LIBRARYBROWSER"}
    WZWindow WZID("WIN_LIBRARYBROWSER"),?wzgui,255,\lbrowser_x,\lbrowser_y,\lbrowser_w,\lbrowser_h,WZID("WIN_LIBRARYBROWSER")
    AddedMenu2WZWin{"WIN_LIBRARYBROWSER"}
  EndIf
    Use Window WZID("WIN_LIBRARYBROWSER")
    WZ_InitTable{"WIN_LIBRARYBROWSER","FUNCTIONSTABLE",2}
    WZ_SetTableTitle{"FUNCTIONSTABLE","Function","Syntax"};,"Library"}
    WZ_SetPriority{"FUNCTIONSTABLE",2,3}
    WZ_DrawTable{"FUNCTIONSTABLE"}
    Gosub update_librarylist
    Gosub update_functiontable
;  Else
;    Use Window WZID("WIN_LIBRARYBROWSER")
    Activate WZID("WIN_LIBRARYBROWSER")
    WZ_UpdateTable{"FUNCTIONSTABLE"}
;  End If
Return


event_librarybrowser:
  ; check for events occured with the functiontable
  wev.l = WZ_CheckTableEvent{pedMessage\_Class}
  Select wev

    Case #WZTABLEEVENT_CELLSELECTED
      pos.l = WZ_Row{"FUNCTIONSTABLE"}
      actualword$ = WZ_GetCell{"FUNCTIONSTABLE",WZ_Row{"FUNCTIONSTABLE"},1}
      If actualword$<>""
        libinfo$ = lib_mapping$(libnumber.l,0)+" (LibNr. "+Str$(libnumber)+" Token "+Hexw$(PED_GetTokenID{*tokenbase,actualword$}) +")"
        WZPrint "ARGS_LIBRARYNAME",&libinfo$
      EndIf

    Case #WZTABLEEVENT_DOUBLECLICK
      pos = WZ_Row{"FUNCTIONSTABLE"}
      actualword$ = WZ_GetCell{"FUNCTIONSTABLE",WZ_Row{"FUNCTIONSTABLE"},1}
      If actualword$<>""
        Gosub instructionbrowser_startguide
      EndIf
  End Select

  Select pedMessage\_Class
    Case #IDCMP_CLOSEWINDOW:
      Gosub close_librarybrowser

    Case #IDCMP_VANILLAKEY:
      ;error{"VAN: " + Hexw$(EventCode)}
      If pedMessage\_Code = #VANILLAKEY_ESC Then Gosub close_librarybrowser
      If pedMessage\_Code = #VANILLAKEY_TAB Then Gosub activatesourcewindow

    Case #IDCMP_IDCMPUPDATE
      Select WZGadName

        Case "LIST_LIBRARIES"
          Gosub update_functiontable

        Case "CYCLE_SORTORDER"
          Gosub update_librarylist
          Gosub update_functiontable

        Case "BUTTON_LIB_FREEIDS"
          message$ = !TRANS{"The following lib-IDs are not in use:"}+"\\n\\n"
          For i = 1 To (#Max_BlitzLibs-1)             ; replaced hardcoded 255 with (#Max_BlitzLibs-1) because we start with 0  tomsmart1
            If Instr(lib_mapping$(i,0),"unused")<>0
              message$ + Str$(i)+ "  "
            EndIf
          Next i
          WZ_LockWindow{"WIN_LIBRARYBROWSER"}
          dummy.l = ask{message$,!TRANS{"Ok"},!TRANS{"Info"}}
          WZ_UnlockWindow{"WIN_LIBRARYBROWSER"}

        Case "BUTTON_LIB_CHECK_CONSISTENCY"
          WZ_LockWindow{"WIN_LIBRARYBROWSER"}

          WZ_ShowMessage{!TRANS{"Checking BlitzLib consistency..."},1}

          tmp_string = ""
          libID.l = 0 : olibID.l = 0
          For i = 0 To (#Max_BlitzLibs-1) : lib_check(i) = False : Next i

          *tpointer.l = *tokenbase
          Repeat
            tokeninfo\next_token = Peek.l(*tpointer)
            tokeninfo\number     = Peek.w(*tpointer + 4)
            tokeninfo\name       = Peek.s(*tpointer + 6)
            tokeninfo\help       = Peek.s(*tpointer + 6 + FLen(tokeninfo\name) + 1)
            libID.l = (tokeninfo\number LSR 7)

            If (libID.l <> olibID.l) AND (libID>1) ; skip internal systemlib and dhandlerlib
              If lib_check(libID) = False
                lib_check(libID) = True
              Else
                For i = 0 To (#Max_BlitzLibs-1)
                  If lib_mapping$(i,1) = tokeninfo\name
                    old_libname.s = StripTrail$(UnRight$(lib_mapping$(i,0),Instr(lib_mapping$(libID,0),"with ")+4),Asc(")"))
                    Pop If : Pop For : Goto exit_for2
                  EndIf
                Next i
                log_Print{"nothing found for token [" + tokeninfo\name + "], libID #" + Str$(libID)}
                exit_for2:
                error_libname.s = Left$(lib_mapping$(libID,0),Instr(lib_mapping$(libID,0)," ")-1)
                tmp_string + "+ " + old_libname + " has been overwritten by\\n"
                tmp_string + "\\22" + error_libname + "\\22 with same LibID: "+Str$(libID)+"\\n\\n"
              EndIf
              olibID = libID
              !WZ_GaugeInfo{&lib_mapping$(libID,0)}
            EndIf
            *tpointer.l = tokeninfo\next_token
          Until (*tpointer = 0)

          WZ_HideMessage{}
          If tmp_string = ""
            tmp_string = !TRANS{"The internal library structure seems to be correct."}
          EndIf
          dummy.l = ask{tmp_string,!TRANS{"Ok"},!TRANS{"Info"}}

          WZ_UnlockWindow{"WIN_LIBRARYBROWSER"}
      End Select
  End Select
Return

.close_librarybrowser:
  WZ_KillTable{"FUNCTIONSTABLE"}
  CloseWZWinWithMenu{"WIN_LIBRARYBROWSER"}
  WZListRemove libslist.List
Return

.update_librarylist:
  sortorder.b = WZInput("CYCLE_SORTORDER")
  WZListRemove libslist.List
  Format "000"
  For i = 0 To (#Max_BlitzLibs-1)
    If Instr(lib_mapping$(i,0),"unused") = 0
      If sortorder = 0
        listvalue.s = lib_mapping$(i,0)
      Else
        listvalue.s = Str$(i)+ " | " + lib_mapping$(i,0)
      EndIf
      WZListAdd libslist.List,listvalue,-1,i
    EndIf
  Next i
  Format ""
  WZPrint "LIST_LIBRARIES",0,libslist
Return


.update_functiontable:
  selected.l = WZInput("LIST_LIBRARIES")
  libnumber = WZListData(libslist,selected)
  libinfo$ = lib_mapping$(libnumber,0)+" (LibNr. "+Str$(libnumber)+")"

  WZPrint "ARGS_LIBRARYNAME",&libinfo$

  WZ_ClearTable{"FUNCTIONSTABLE"}

  If *tokenbase<>0
    *tpointer.l = *tokenbase : tfound.b = False : tcounter.l = 0 : tname$ = ""
    Repeat
      tokeninfo\next_token = Peek.l(*tpointer)
      tokeninfo\number     = Peek.w(*tpointer+4)
      tokeninfo\name       = Peek$(*tpointer+6)
      tokeninfo\help       = Peek$(*tpointer+6+FLen(tokeninfo\name)+1)

      If (tokeninfo\number LSR 7) = libnumber
        WZ_AddRow{"FUNCTIONSTABLE",tokeninfo\name,tokeninfo\help}
      EndIf
      *tpointer.l = tokeninfo\next_token : tcounter + 1
    Until (*tpointer = 0)
  EndIf
  WZ_TableSort{"FUNCTIONSTABLE",1}
  WZ_UpdateTable{"FUNCTIONSTABLE"}
Return


.open_instructionbrowser
  Gosub close_popupwindow
  If NOT WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"} ; thilo: why this was commented out!?
    WZWindow WZID("WIN_INSTRUCTIONBROWSER"),?wzgui,255,wtemp\ibrowser_x,wtemp\ibrowser_y,wtemp\ibrowser_w,wtemp\ibrowser_h,WZID("WIN_INSTRUCTIONBROWSER")
    AddedMenu2WZWin{"WIN_INSTRUCTIONBROWSER"}
    If search_instruction$<>"" Then WZPrint "INSTRUCTION_STRING",search_instruction$
    WZPrint "macros",browse_macros
    WZPrint "instr",browse_instructions
    WZPrint "incdir",browse_includes
    WZ_InitTable{"WIN_INSTRUCTIONBROWSER","INSTRUCTIONTABLE",2}
    WZ_SetTableTitle{"INSTRUCTIONTABLE","Function","Syntax"};,"Library"}
    WZ_SetPriority{"INSTRUCTIONTABLE",2,3}
    WZ_DrawTable{"INSTRUCTIONTABLE"}
    previoussearch_instruction$="|"
    Gosub update_instructiontable
  Else
    Use Window WZID("WIN_INSTRUCTIONBROWSER")
    Activate WZID("WIN_INSTRUCTIONBROWSER")
    WZ_UpdateTable{"INSTRUCTIONTABLE"}
    WZPrint "INSTRUCTION_STRING",search_instruction$
  End If
  WZ_ActivateGadget{"INSTRUCTION_STRING"}                                                                                                                                                                                                                
RTS


.event_instructionbrowser:
  ; check for events occured with the instructiontable
  wev.l = WZ_CheckTableEvent{pedMessage\_Class}
  Select wev

    Case #WZTABLEEVENT_CELLSELECTED
      MOVE.l comPtr_TokenBase,token@(a5)

      b$ = WZ_GetCell{"INSTRUCTIONTABLE",WZ_Row{"INSTRUCTIONTABLE"},1}
      bstr$ = b$
      While token
        If b$ = Peek$(token+6) Then Pop While: Goto tfound
        token = Peek.l(token)
      Wend

     tfound:
      If token
        tok.l = Peek.w(token+4)
        iinfo$ = "Library: " + PED_GetLibname{tok LSR 7}
        iinfo$ + " - LibNr.: "+Str$(tok LSR 7)+" - TokenID: "+Str$((tok AND $7f)-1)+" - MemPointer $"+Hex$(tok)
      Else
        iinfo$ = "Include: " + PED_GetIncludeName{bstr$}
      EndIf
      WZTags #WARGSA_TextPen,2
      WZPrint "INSTRUCTION_INFO",&iinfo$

    Case #WZTABLEEVENT_DOUBLECLICK
      pos = WZ_Row{"INSTRUCTIONTABLE"}
      actualword$ = WZ_GetCell{"INSTRUCTIONTABLE",WZ_Row{"INSTRUCTIONTABLE"},1}
      Gosub instructionbrowser_startguide

  End Select

  Select pedMessage\_Class

    Case #IDCMP_INTUITICKS
      Gosub update_instructiontable

    Case #IDCMP_CLOSEWINDOW:
      Gosub close_instructionbrowser

    Case #IDCMP_RAWKEY:
      ;error{"RAW: " + Hexw$(EventCode)}

    Case #IDCMP_VANILLAKEY:
      ;error{"VAN: " + Hexw$(EventCode)}
      Select EventCode
      Case #VANILLAKEY_ESC : Gosub close_instructionbrowser
      Case #VANILLAKEY_TAB : Gosub activatesourcewindow
      End Select

    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "add" ;add to code
          a$ = Trim$(bstr$)
          If a$<>""
           log_Print{"adding to code: " + a$}
            lineaddr.l = Peek.l(?textbufferaddr) + Peek.w(?comWord_TextBufferOffset)
            lineaddr + Peek.w(?comWord_ColumnsOffset) + Peek.w(?comWord_Column)
            log_Print{"current source area: [" + Peek$(lineaddr) + "]"}
            tempph.w = 0
            If Peek.b(lineaddr-tempph) = $20
              While Peek.b(lineaddr-tempph) = $20
                tempph + 1
              Wend
              log_Print{Str$(tempph) + " spaces after last char"}
              Gosub cursor_off                                                                                                                                                                                                                              
              For i = 1 To tempph
                Gosub deletechar
              Next i
            EndIf
            Gosub insertstring
            Gosub activatesourcewindow
          EndIf

        Case "macros"
          browse_macros = WZInput
          previoussearch_instruction$ = "|"
          WZ_ActivateGadget{"INSTRUCTION_STRING"}                                                                                                                                                                                                        

        Case "instr"
          browse_instructions = WZInput
          previoussearch_instruction$ = "|"
          WZ_ActivateGadget{"INSTRUCTION_STRING"}                                                                                                                                                                                                        

        Case "incdir"
          browse_includes = WZInput
          previoussearch_instruction$ = "|"
          WZ_ActivateGadget{"INSTRUCTION_STRING"}                                                                                                                                                                                                        

      End Select

  End Select
Return

.close_instructionbrowser:
  wtemp\ibrowser_x = WindowX
  wtemp\ibrowser_y = WindowY
  wtemp\ibrowser_w = WindowWidth
  wtemp\ibrowser_h = WindowHeight
  WZ_KillTable{"INSTRUCTIONTABLE"}
  CloseWZWinWithMenu{"WIN_INSTRUCTIONBROWSER"}
Return

.update_instructiontable:
  search_instruction$ = WZGetString("INSTRUCTION_STRING")
  If (search_instruction$<>previoussearch_instruction$) AND (Len(search_instruction$) > 1)
    previoussearch_instruction$ = search_instruction$
    WZ_ClearTable{"INSTRUCTIONTABLE"}
    InitArgParse search_instruction$
    word1$ = NextArg$
    word2$ = NextArg$
    MOVE.l comPtr_TokenBase,token@(a5)
    numcount.l = 0
    If browse_instructions
      While token
        token_name$ = Peek$(token + 6)
        token_help$ = Peek$(token + 7 + Len(token_name$))
        ;token_libname$ = PED_GetLibname{Peek.w(token+4) LSR 7}
        If Instr(token_name$,word1$) AND numcount < #maxlabels
          If Instr(token_help$,word2$)
            numcount = numcount + 1
            WZ_AddRow{"INSTRUCTIONTABLE",token_name$,token_help$}

            If PED_CheckForClassicToken{Peek.w(token+4)} Then WZ_SetRowPen{"INSTRUCTIONTABLE",AB3Pen(#AB3_cclassic),0}
          End If
        End If
        token = Peek.l(token)
      Wend
    End If
    ;
    If browse_macros
      MOVE.l comPtr_MacroBase,a0:MOVE.l (a0),token@(a5)
      c.l = 0
      While token
        b$ = Peek$(token+13)
;        !cout{word1$,b$}
        If Instr(b$,word1$) AND numcount<#maxlabels
          If Instr(b$,word2$)
            numcount = numcount + 1
            i = Peek.w(token+8)
            If i > 90 Then i = 90
            b$ = "!" + b$
            c$ = Peeks$(Peek.l(token+4),i)
            ;                  WZTags #WENTRYA_TextPen,Peek.l(?macrocolor)
            ;                  WZListAdd lst,b$
            WZ_AddRow{"INSTRUCTIONTABLE",b$,c$}
          End If
        End If
        token = Peek.l(token)
      Wend
    End If

    If browse_includes
      ResetList HelpIndexCache()
      While NextItemFast(HelpIndexCache())
        If Instr(HelpIndexCache()\name,word1$) AND numcount<#maxlabels
          If Instr(HelpIndexCache()\name,word2$)
            numcount = numcount+1
            WZ_AddRow{"INSTRUCTIONTABLE",HelpIndexCache()\name,HelpIndexCache()\help}
          End If
        End If
      Wend
    End If
    pos = 0
    ;          WZPrint "list",pos,lst,0
    WZ_TableSort{"INSTRUCTIONTABLE",1}
    WZ_UpdateTable{"INSTRUCTIONTABLE"}
  Else
    If (search_instruction$<>previoussearch_instruction$) AND (Len(search_instruction$)<2)
      previoussearch_instruction$ = search_instruction$
      WZ_ClearTable{"INSTRUCTIONTABLE"}
     WZ_UpdateTable{"INSTRUCTIONTABLE"}
    EndIf
  End If
Return

.event_popup:
  log_Print{"processing poupevent " + Hex$(pedMessage\_Class)}
  popexit.l = False
                                                ; added to set the init value that fix the bug that after select a item with a doubleclick the next popup win are autoclosed  tomsmart1
  Select pedMessage\_Class
    Case #IDCMP_IDCMPUPDATE
      If Left$(WZGadName,9) = "POPUPMENU"
        popup_selected = WZInput + 1
        popexit = True
      EndIf

    Case #IDCMP_RAWKEY
      log_Print{"RAWKEY " + Hex$(pedMessage\_Code)}
    Case #IDCMP_MOUSEBUTTONS
;      mb.b = MButtons
;      If (mb = 1) OR (mb=2)
;         popexit = True
;      EndIf
  End Select

  If popexit = True
    a$ = WZ_GetPopUpEntry{popup_selected}
    ;log_Print{"selected: " + a$}
    brackpos.w = Instr(a$,"{")
    If brackpos > 0
      a$ = Trim$(Left$(a$,brackpos-1))
      a$ = UnRight$(a$,Len(poptok$)) + "{"
    Else
      a$ = UnRight$(a$,Len(poptok$)) 
    EndIf
    ;log_Print{"inserting: " + a$}
    Gosub insertstring
    PED_ShowMessage{a$ + " " + PED_GetIncludeHelp{a$} }    ; removed a$ test because it is not needed  tomsmart1
    Gosub close_popupwindow
  EndIf
  Gosub activatesourcewindow                                ; always active sourcewin if a popupwin event happend like mouse click or scroll  tomsmart1
Return


.insertstring:
  ; --
  ; -- check for a comment
  i = SearchBegin(a$,Asc(";"),1)
  If i Then a$ = Left$(a$,i-2) ;+" "

  If a$ <> ""
    For i = 1 To Len(a$)
      last_vankey = Asc(Mid$(a$,i,1) )
      If Peek.w(?comWord_Column) < $7d      ;#MAX_Columns - 1
        Gosub insertchar
      EndIf
    Next i
  EndIf
Return


.instructionbrowser_startguide   ;actualword$: zu suchende Funktion

  PED_ShowMessage{!TRANS{"Searching help for <" + actualword$ + ">"}}

  MOVE.l comPtr_TokenBase,token@(a5)
  b$ = actualword$
  While token
    If b$ = Peek$(token+6) Then Pop While:Goto found
    token = Peek.l(token)
  Wend

 found:
  If token
    tok.l = Peek.w(token+4)
    tokname$ = b$
    libnumber = tok LSR 7
  Else ;no token, but a function or macro
    tokname$ = b$
    libnumber = 0
  End If
  Gosub open_helptool
Return


.open_helptool:
  tokid.l = PED_GetTokenID{*tokenbase,tokname$}
  libnumber = PED_GetTokenLibnum{*tokenbase,tokname$}
  helpdir$ = pedconfig\helpDir

  ;If tokid <= 0
  ;  tokname$ = Left$(tokname$,FLen(tokname$)-1)
  ;  tokid = PED_GetTokenID{*tokenbase,tokname$}
  ;  libnumber = PED_GetTokenLibnum{*tokenbase,tokname$}
  ;EndIf

  If tokid > 0
    If Right$(tokname$,1)="_"
      tokname$ = Left$(tokname$,Len(tokname$)-1)
      helpdir$ = pedconfig\autodocDir + " -d " + helpdir$
    EndIf
    libname$ = lib_mapping$( libnumber,0)
    mostright$ = Right$(libname$,1)
    If mostright$ = "1" OR mostright$ = "2" Then libname$ = Left$(libname$,Len(libname$)-1)
  Else
    libname$ = PED_GetIncludeName{tokname$}
  EndIf

  If Instr(libname$,"unused")=0 AND (libname$<>"")
    Show_Helpfile{libname$,tokname$,helpdir$}
  Else
    search_instruction$ = tokname$
    Gosub open_instructionbrowser
    ;dummy.l = ask{"No help available",!TRANS{"Ok"},!TRANS{"Info"}}
  EndIf

  PED_ShowMessage{""}
Return


.open_shortcuts
  If NOT WZ_CheckOpen{"WIN_SHORTCUTS"}
    WZWindow WZID("WIN_SHORTCUTS"),?wzgui,255,wtemp\short_x,wtemp\short_y,wtemp\short_w,wtemp\short_h,WZID("WIN_SHORTCUTS")
    AddedMenu2WZWin{"WIN_SHORTCUTS"}

    WZ_InitTable{"WIN_SHORTCUTS","SHORTCUTS",2}
    WZ_SetPriority{"SHORTCUTS",1,2}
    WZ_SetTableReadOnly{"SHORTCUTS",True}        ; disabled row selection
    WZ_SetEditable{"SHORTCUTS",False,False}      ; disabled editing of the table  tomsmart1
    WZ_SetSortable{"SHORTCUTS",False}            ; disabled sorting for the table  tomsmart1
    ; update keys and changed order  tomsmart1
    WZ_SetTableTitle{"SHORTCUTS",!TRANS{"Key"}                       ,!TRANS{"Function"}}
           WZ_AddRow{"SHORTCUTS",       "Navigation"           ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+LeftArrow"}             ,!TRANS{"Go Back in history"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+RightArrow"}            ,!TRANS{"Go Forward in history"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+Left Mousebutton"}      ,!TRANS{"Jump to Label/Func-Definition"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+Middle Mousebutton"}    ,!TRANS{"Back from Label/func"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+UpArrow"}              ,!TRANS{"Jump to first line"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+DownArrow"}            ,!TRANS{"Jump to last line"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+LeftArrow"}            ,!TRANS{"Move cursor to start of word"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+RightArrow"}           ,!TRANS{"Move cursor to end of word"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+A"}                 ,!TRANS{"Jump to the last line in that something was added"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+SHIFT+1-3"}         ,!TRANS{"Set bookmark 1-3"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+1-3"}               ,!TRANS{"Jump to bookmark 1-3"} }

           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",       "Edit"               ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+X"}                    ,!TRANS{"CUT same as <AMIGA>+<X>"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+C"}                    ,!TRANS{"COPY vertical, all select lines only copyed at the select column"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+V"}                    ,!TRANS{"PASTE vertical, all lines pasted at the cursor column"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+U"}                    ,!TRANS{"undo delete current line"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+UpArrow"}               ,!TRANS{"Move Line Up"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+DownArrow"}             ,!TRANS{"Move Line Down"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+E"}                    ,!TRANS{"Insert 'End If'"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+F"}                    ,!TRANS{"Insert a 'Function' skeleton"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+N"}                    ,!TRANS{"Insert a 'Newtype' skeleton"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+S"}                    ,!TRANS{"Insert a 'Statement' skeleton"} }

           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+RightArrow on block"}  ,!TRANS{"TAB marked Block"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+LeftArrow on block"}   ,!TRANS{"Un-TAB marked Block"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+SHIFT+UpArrow"}        ,!TRANS{"Extend blockmark upwards"}   }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+SHIFT+DownArrow"}      ,!TRANS{"Extend blockmark downwards"} }

           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",       "Help"                 ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP+SHIFT"}                ,!TRANS{"Opens guide/autodoc of instruction under cursor"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP+CTRL"}                 ,!TRANS{"Opens parameter diagnostic for actual function"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP on any function"}      ,!TRANS{"Displays correct syntax in screens titlebar"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP on '\'"}               ,!TRANS{"Opens window 'type browser' and shows newtype information"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP on 'EndIf'"}           ,!TRANS{"Shows corresponding IF-Blockheader"} }

           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",       "Editor-Actions"       ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"TAB"}                       ,!TRANS{"Activates sourcewindow"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ESC"}                       ,!TRANS{"Closes any active helpwindow"} }
           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+Click on filename"}     ,!TRANS{"Save and compile and run"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+Click on filename"}    ,!TRANS{"Save and create exe (save both if you click on different)"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+I"}                    ,!TRANS{"Switch Intellisense for Commands 'on/off' if Intellisens is enabled"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+F4-F6"}             ,!TRANS{"save winconfig"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F4-F6"}                     ,!TRANS{"load winconfig (F4 also startconfig)"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F7"}                        ,!TRANS{"window autolayout variant #1"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F8"}                        ,!TRANS{"window autolayout variant #2"} }
           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",!TRANS{"F9"}                        ,!TRANS{"goto previous document"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F10"}                       ,!TRANS{"goto next document"} }
    WZ_DrawTable{"SHORTCUTS"}
    WZ_UpdateTable{"SHORTCUTS"}
  EndIf
Return


.event_shortcuts:
  wev.l = WZ_CheckTableEvent{pedMessage\_Class}
  Select pedMessage\_Class
    Case #IDCMP_VANILLAKEY:
      If EventCode = #VANILLAKEY_ESC Then Gosub close_shortcuts
      If EventCode = #VANILLAKEY_TAB Then Gosub activatesourcewindow

    Case #IDCMP_CLOSEWINDOW
      Gosub close_shortcuts
  End Select
Return

.close_shortcuts:
  WZ_KillTable{"SHORTCUTS"}
  CloseWZWinWithMenu{"WIN_SHORTCUTS"}
Return


.open_cliarguments
  *clistringptr.l = Peek.l(?comPtr_CLIArgumentsString)
  If *clistringptr >< 0
    clistr.s = Peek.s(*clistringptr)
  Else
    Return
  End If
  old_clistr.s = clistr
  ;FindScreen 0
  WZWindow WZID("WIN_CLIARGUMENTS"),?wzgui,64,-1,-1,-1,-1,WZID("WIN_CLIARGUMENTS")
  If clistr<>"" Then WZPrint "CLI_ARGUMENTS",&clistr
  WZ_ActivateGadget{"CLI_ARGUMENTS"}                                                                                                                                                                                                                     
  exit_cli.b = False : get_arguments.b = False

  Repeat
    ev.l = WaitEvent

    ; context onlinehelp for most windows
   ; If onlinehelp <> 0
   ;   If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) AND (ev<>#IDCMP_GADGETHELP)  AND (ev<>#IDCMP_CHANGEWINDOW)
   ;     WZ_HideHelp{}
   ;   EndIf
   ;   If ev = #IDCMP_GADGETHELP Then WZ_ShowHelp{}
   ; EndIf

    Select ev

      Case #IDCMP_CLOSEWINDOW
        exit_cli = True

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName

;          Case "CLI_ARGUMENTS"
;            get_arguments = True

          Case "CLI_OK"
            exit_cli = True
            get_arguments = True

          Case "CLI_CANCEL"
            get_arguments = False
            exit_cli = True

        End Select

      Default
        WZ_ActivateGadget{"CLI_ARGUMENTS"}                                                                                                                                                                                                               

    End Select

  Until exit_cli = True

  If get_arguments = True
    clistr = WZGetString("CLI_ARGUMENTS")
    Poke.s *clistringptr,Left$(clistr,127)
  Else
    clistr = old_clistr
  EndIf
  WZCloseWindow WZID("WIN_CLIARGUMENTS")
  FlushEvents
  Gosub activatesourcewindow
Return



.open_calculator:
  calc_expression.s = ""
  !ComData_GetL{comPtr_CalculatorExpressionString,D0} : CalculatorExpressionStringPointer.l = PutD0
  Poke.s CalculatorExpressionStringPointer,calc_expression
  If Peek.l(Addr Window(WZID("WIN_CALCULATOR")))=0
    WZWindow WZID("WIN_CALCULATOR"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_CALCULATOR")
    !ComData_SetW{comWord_CalculatorButtonBinFlag,#$00}
    !ComData_SetW{comWord_CalculatorButtonDecFlag,#$80}

    ;event_Calculator
    calc_exit.l = False
    calc_test.l = False
    Repeat
     WZ_ActivateGadget{"CALC_EXPRESSION"}                                                                                                                                                                                                                
     ev_calculator.l = WaitEvent

      Select ev_calculator
        Case #IDCMP_VANILLAKEY:
          If EventCode = #VANILLAKEY_ESC Then calc_exit = True

        Case #IDCMP_CLOSEWINDOW
          calc_exit = True

        Case #IDCMP_IDCMPUPDATE
          Select WZGadName

            Case "CALC_CLOSE"
              calc_exit = True

            Case "CALC_EXPRESSION"
              calc_expression = WZGetString("CALC_EXPRESSION")

            Case "BIN"
              !ComData_SetW{comWord_CalculatorButtonBinFlag,#$80}
              !ComData_SetW{comWord_CalculatorButtonDecFlag,#$00}
              calc_test = True

            Case "HEX"
              !ComData_SetW{comWord_CalculatorButtonBinFlag,#$00}
              !ComData_SetW{comWord_CalculatorButtonDecFlag,#$00}
              calc_test = True

            Case "DEC"
              !ComData_SetW{comWord_CalculatorButtonBinFlag,#$00}
              !ComData_SetW{comWord_CalculatorButtonDecFlag,#$80}
              calc_test = True

          End Select

          If FLen(calc_expression)<128                      ; test if the string is not longer than 128 byte because this is the limit that is set in the compiler source  tomsmart1 2012 05 30
            If (calc_expression<>"") AND (calc_exit = False)
              If (calc_expression<>Peek.s(CalculatorExpressionStringPointer) ) OR (calc_test = True)
                Poke.s CalculatorExpressionStringPointer,calc_expression
                !asm
                !ComData_JSR{comFunc_CalculatExpression} ;examine_expression
                !basic
                calc_expression = Peek.s(CalculatorExpressionStringPointer)
                WZPrint "CALC_EXPRESSION",&calc_expression
              EndIf
              calc_test = False
            EndIf
         Else
           error{!TRANS{"The expression is to long please reduce it to max 127 characters!"} }
         EndIf

      End Select

    Until calc_exit

    WZCloseWindow WZID("WIN_CALCULATOR")
    FlushEvents
    Gosub activatesourcewindow
  EndIf
Return




.open_newtype:
   WZWindow WZID("WIN_NEWTYPE"),?wzgui,255,wtemp\type_x,wtemp\type_y,wtemp\type_w,wtemp\type_h,WZID("WIN_NEWTYPE")
   AddedMenu2WZWin{"WIN_NEWTYPE"}

   ;GTSetMenuChecked 0,5,9,On
   Use Window WZID("WIN_NEWTYPE")
   WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
   WZ_SetTableTitle{"TYPETABLE","Type","Value"}
   WZ_SetTableColors{"TYPETABLE",1,0,1,0}
   WZ_SetPriority{"TYPETABLE",2,1}
   WZ_DrawTable{"TYPETABLE"}

   Select ped\newtype_mode

     Case 0
       WZPrint "STRING2",cstr$
       WZPrint "NEWTYPE_CONST",1
       WZPrint "NEWTYPE_VAR",0
       WZPrint "NEWTYPE_STRUCT",0
       Gosub newtype_listconsts

     Case 1
       WZPrint "STRING2",str2$
       WZPrint "NEWTYPE_CONST",0
       WZPrint "NEWTYPE_VAR",1
       WZPrint "NEWTYPE_STRUCT",0
       Gosub newtype_listvars

     Case 2
       WZPrint "STRING2",str2$
       WZPrint "NEWTYPE_CONST",0
       WZPrint "NEWTYPE_VAR",0
       WZPrint "NEWTYPE_STRUCT",1

       Gosub newtype_selecttype
       a$ = ""
       For i = 1 To lev:
         If i>1
            a$ = a$+"\"+pos$(i):
         Else
            a$ = a$+"."+pos$(i):
         End If
       Next
       typestr$ = a$
       WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
       WZPrint "NEWTYPE_ENTRY",&a$
   End Select

   WZ_ActivateGadget{"STRING2"}   ; replaced to use the statement  tomsmart1 2012 03 09                                                                                                                                                                  
Return


.event_newtype:
  tev.l = WZ_CheckTableEvent{pedMessage\_Class}
  If tev = #WZTABLEEVENT_DOUBLECLICK
    Select ped\newtype_mode

      Case 0 ; Constants
        temp$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},1} ;WZListString(lst2.List,WZInput)
        typestr$ = temp$
        WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
        WZPrint "NEWTYPE_ENTRY",&typestr$

      Default
        ;str2$ = "" : str2b$ = ""
        ;WZPrint "STRING2",&str2$
        temp$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},1} ;WZListString(lst2.List,WZInput)
        c2$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},2}
        If c2$<>"" Then c2$ = " ."+c2$
        c3$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},3}
        If c3$<>"" Then c3$ = " $"+c3$
        temp$ + c2$ + c3$

        If ped\newtype_mode = 1 AND lev  = 0
          i = SearchEnd (temp$,@".",1)
          If lev = 0 Then var$ = Left$(temp$,i-1)
          temp$ = Mid$(temp$,i + 1)
        End If

        If ped\newtype_mode <> 1 Then var$ = ""
        a$ = temp$
        lev = lev + 1 : If lev > 13 Then lev = 13
        pos2(lev) = 0
        find = 0
        pos2(lev-1) = WZ_Row{"TYPETABLE"} ;WZListPos("list2")
        t$ = Left$(a$,Instr(a$," ")-1)
        If lev > 1
          i = SearchEnd(a$,Asc("."),1)
          i2 = SearchEnd(a$,Asc("$"),1)
          a$ = Mid$(a$,i+1,i2-i-3)
        End If
        MOVE.l newtypebase,d0
        *nt.l = PutD0
        If *nt
          *nt = Peek.l(*nt):
          While *nt
            b$ = Peek$(*nt+11)
            If b$ = a$
              ;*nt2(lev) = Peek.l(*nt+4)
              Gosub newtype_listsubtype
              find = 1
              Pop If : Goto f1a
            End If
            *nt = Peek.l(*nt)

           f1a:
          Wend
        Else
          error{"newtypebase = NULL => GURU!!!"}
        End If
        If find = 0
          lev = lev - 1 ;:WZPrint "list2",-1:
          a$ = ""
          For i = 1 To lev:
            If i > 1
               a$ = a$ + "\" + pos$(i):
            Else
               a$ = a$ + "." + pos$(i):
            End If
          Next
          i = Instr(temp$," ")
          temp$ = Replace$ (temp$,"*","")
          typestr$ = var$ + a$ + "\" + Left$(temp$,i)
          WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
          WZPrint "NEWTYPE_ENTRY",&typestr$
        End If

    End Select

  EndIf

  Select pedMessage\_Class

    Case #IDCMP_INTUITICKS
      Select ped\newtype_mode

        Case 0
          cpos.l = 0
          cpos.l = WZ_Column{"TYPETABLE"} ;WZListPos ("list2")
          cstr$ = WZGetString("STRING2")
          If cstr$<>cstr2$
            cstr2$ = cstr$
            ;cpos = 0
            Gosub newtype_listconsts
          End If

        Case 1
          str2$ = WZGetString("STRING2")
          If str2$<>str2b$
            str2b$ = str2$
            pos2(lev) = 0
            Gosub newtype_listvars
          End If

        Case 2
          str2$ = WZGetString("STRING2")
          If str2$<>str2b$
            str2b$ = str2$
            find.l = 0
            pos2(lev) = 0
            p$ = str2$
            Gosub newtype_selecttype
          End If

      End Select

    Case #IDCMP_CLOSEWINDOW
      Gosub close_newtype

    Case #IDCMP_VANILLAKEY:
      If pedMessage\_Code = #VANILLAKEY_ESC Then Gosub close_newtype
      If pedMessage\_Code = #VANILLAKEY_TAB Then Gosub activatesourcewindow


    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "typeadd"
          a$ = typestr$
          If Instr(a$,"\",StrLen(a$)-1)<>0 Then a$ = Left$(a$,StrLen(a$)-1)
          If quicktype Then a$ = Mid$(typestr$,Instr (typestr$,"\")+1)
          If ped\newtype_mode <> 1 Then a$ = Replace$(a$,"*","")
          Gosub insertstring
          Gosub activatesourcewindow

        Case "string2"
         ;Gosub activatesourcewindow                             ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1

        Case "parent" :
          quicktype = 0
          If ped\newtype_mode = 0
          Else
            If lev Then lev = lev - 1
            If lev = 0
              If ped\newtype_mode = 1
                Gosub newtype_listvars
              Else
                If str2$<>"" Gosub newtype_selecttype Else Gosub newtype_listtype
              End If
            Else
              a$ = pos$(lev)
              JSR newtype_listsubtype
            End If
            a$ = "" : pos$(lev+1) = ""
            For i = 1 To lev:
              If i > 1
                a$ = a$+"\"+pos$(i):
              Else
                a$ = a$+"."+pos$(i):
              End If
            Next
            typestr$ = a$
            WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
            WZPrint "NEWTYPE_ENTRY",&a$
          End If

        Case "clear":
          If ped\newtype_mode = 0
            cstr$ = "":
            WZPrint "STRING2",&cstr$
          Else
            str2$ = "":
            Gosub newtype_selecttype
            WZPrint "STRING2",&str2$
          End If

        Case "newtype_const"
          ped\newtype_mode = 0 : Gosub newtype_updatelist

        Case "newtype_var"
          ped\newtype_mode = 1 : Gosub newtype_updatelist

        Case "newtype_struct"
          ped\newtype_mode = 2 : Gosub newtype_updatelist

      End Select
  End Select
Return

.close_newtype:
  wtemp\type_x = WindowX
  wtemp\type_y = WindowY
  wtemp\type_w = WindowWidth
  wtemp\type_h = WindowHeight
  WZ_KillTable{"TYPETABLE"}
  CloseWZWinWithMenu{"WIN_NEWTYPE"}
Return


.newtype_updatelist
  str2b$ = ""
  WZ_KillTable{"TYPETABLE"}

  Select ped\newtype_mode

    Case 0
      WZPrint "STRING2",cstr$
      WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
      WZ_SetTableTitle{"TYPETABLE","Identifier","Value"}
      WZ_SetTableColors{"TYPETABLE",1,0,1,0}
      WZ_SetPriority{"TYPETABLE",2,1}
      WZ_DrawTable{"TYPETABLE"}

      ptr.l = &str2b$
      If ptr>4096
        WZPrint "NEWTYPE_ENTRY",&str2b$
      Else
        error{"Pointer to str2b$ is not valid! \\22"+str2b$+"\\22"}
      End If

      Gosub newtype_listconsts

    Case 1
      WZPrint "STRING2",str2$
      WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
      WZ_SetTableTitle{"TYPETABLE","Identifier","Value"}
      WZ_SetTableColors{"TYPETABLE",1,0,1,0}
      WZ_SetPriority{"TYPETABLE",1,1}
      WZ_DrawTable{"TYPETABLE"}
      ptr.l = &str2$
      If ptr>4096
        WZPrint "NEWTYPE_ENTRY",&str2$
      Else
        error{"1: Pointer to str2$ is not valid! \\22"+str2$+"\\22"}
      End If

      Gosub newtype_listvars

    Case 2
      WZPrint "STRING2",str2$
      ptr.l = &str2$
      If ptr>4096
        WZPrint "NEWTYPE_ENTRY",&str2$
      Else
        error{"2: Pointer to str2$ is not valid! \\22"+str2$+"\\22"}
      End If

      Gosub newtype_selecttype
      a$ = ""
      For i = 1 To lev:
        If i>1
           a$ = a$+"\"+pos$(i):
        Else
           a$ = a$+"."+pos$(i):
        End If
      Next
      typestr$ = a$
      WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
      WZPrint "NEWTYPE_ENTRY",&a$

  End Select
Return


.newtype_listvars
  WZ_ClearTable{"TYPETABLE"}
  InitArgParse str2$
  word1$ = NextArg$
  word2$ = NextArg$
  MOVE.l comPtr_VarBase,d0
  *nt = PutD0
  If *nt
    *nt = Peek.l(*nt):
    While *nt
      a$ = Peek$(*nt + $13)
      If Peek.w(*nt + 6) AND 2 Then arr$ = "()" Else arr$ = ""
      If Peek.w(*nt + 6) AND 1 Then poin$ = "*" Else poin$ = ""
      If Instr (a$,word1$)
        If Instr(a$,word2$)
          it.l = Peek.l(*nt+10)
          WZ_AddRow{"TYPETABLE",poin$ + a$ + arr$,Peek$(it + $b)}
        EndIf
      End If
      *nt = Peek.l(*nt)
    Wend
  Else
    error{"comPtr_VarBase = NULL => GURU!!!"}
  End If
  WZ_TableSort{"TYPETABLE",1}
  WZ_UpdateTable{"TYPETABLE"}
Return


.newtype_listconsts
  WZ_ClearTable{"TYPETABLE"}
  If FLen(cstr$) => 2
    ;log_Print{"listconstants:" + cstr$}
    InitArgParse cstr$
    word1$ = NextArg$
    word2$ = NextArg$
    MOVE.l constantbase,d0
    *nt = PutD0
    If *nt
      *nt = Peek.l(*nt)
      While *nt
        a$ = Peek$(*nt+$13)
        If Instr (a$,word1$) Then If Instr(a$,word2$)
          WZ_AddRow{"TYPETABLE",a$,"$"+Hex$(Peek.l(*nt+8))}
        End If
        *nt = Peek.l(*nt)
      Wend
    Else
      error{"constantbase = NULL => GURU!!!"}
    End If

  End If

  WZ_TableSort{"TYPETABLE",1}
  WZ_UpdateTable{"TYPETABLE"}
Return


.newtype_listtype                   ;called when press parent
  lev = 0
  WZ_KillTable{"TYPETABLE"}
  WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",1}
  WZ_SetTableColors{"TYPETABLE",1,0,1,0}
  WZ_SetTableTitle{"TYPETABLE","Identifier"}
  WZ_DrawTable{"TYPETABLE"}

  MOVE.l newtypebase,d0
  *nt = PutD0

  If *nt
    *nt = Peek.l(*nt)
    While *nt
      a$ = Peek$(*nt+11)
      WZ_AddRow{"TYPETABLE",a$}
      *nt = Peek.l(*nt)
    Wend
  Else
    error{"newtypebase = NULL => GURU!!!"}
  End If

;  WZ_TableSort{"TYPETABLE",1}
  WZ_UpdateTable{"TYPETABLE"}
Return


.newtype_selecttype:

  WZ_KillTable{"TYPETABLE"}
  If lev = 0
    WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",1}
    WZ_SetTableTitle{"TYPETABLE","Identifier"}
    WZ_SetTableColors{"TYPETABLE",1,0,1,0}
    WZ_DrawTable{"TYPETABLE"}
  Else
    WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",3}
    WZ_SetTableTitle{"TYPETABLE","Identifier","Type","Offset"}
    WZ_SetTableColors{"TYPETABLE",1,0,1,0}
    WZ_SetPriority{"TYPETABLE",3,2,2}
    WZ_DrawTable{"TYPETABLE"}
  EndIf

  i = 0
  InitArgParse p$
  word1$ = NextArg$
  word2$ = NextArg$
  If lev
    MOVE.l newtypebase,d0
    *nt = PutD0
    If *nt
;       *nt = *nt2(lev)
;       While *nt
;       If Peek.w(*nt+6) = 1 Then b$ = "*" Else b$ = ""
;         b$ = b$ + Peek$(*nt+15)
;         c$ = Peek$(Peek.l(*nt+10)+11)
;         If Instr(b$,word1$) Then If Instr(b$,word2$)
;         WZ_AddRow{"TYPETABLE",b$,c$,"$"+Right$(Hex$(Peek.w(*nt+4)),4)}
;       End If
;      b$ + "  ."+c$
;      *nt = Peek.l(*nt)
     If *nt
          *nt = Peek.l(*nt)
        Else
          error{"newtypebase = NULL => GURU!!!"}
        End If
;      Wend
        While *nt
        b$ = Peek$(*nt+11)
        If postype$(lev) = b$
                  *nt3.l = Peek.l(*nt+4):
                  While *nt3
                  If Peek.w(*nt3+6) = 1 Then b$ = "*" Else b$ = ""
                    b$ = b$ + Peek$(*nt3+15)
                    c$ = Peek$(Peek.l(*nt3+10)+11)
                    ;If Instr(b$,word1$) Then If Instr(b$,word2$)
                    nt_value.w = Peek.w(*nt3+4)
                    nt_displayvalue.s = "$"+Right$(Hex$(nt_value),4) + "(" + Str$(nt_value) + ")"
                    ;nt_displayvalue.s = Str$(nt_value)
                    WZ_AddRow{"TYPETABLE",b$,c$,nt_displayvalue}
                    ;End If
                 b$ + "  ."+c$
                 *nt3 = Peek.l(*nt3)
                 Wend
                 *nt = 0:Goto out2
        EndIf
        *nt = Peek.l(*nt)
out2        Wend
        WZ_TableSort{"TYPETABLE",3}
        WZ_UpdateTable{"TYPETABLE"}
    End If
  Else
    MOVE.l newtypebase,d0
    *nt = PutD0
    If *nt
      *nt = Peek.l(*nt)
    Else
      error{"newtypebase = NULL => GURU!!!"}
    End If
   While *nt
     b$ = Peek$(*nt+11)
     If Instr(b$,word1$) Then If Instr(b$,word2$)
       WZ_AddRow{"TYPETABLE",b$,""}
       find = find + 1
       f$ = b$
     EndIf
     *nt = Peek.l(*nt)
   Wend
   WZ_TableSort{"TYPETABLE",1}
   WZ_UpdateTable{"TYPETABLE"}
  End If
Return


.newtype_listsubtype
  WZ_KillTable{"TYPETABLE"}
  If lev = 0
    WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",1}
    WZ_SetTableTitle{"TYPETABLE","Identifier"}
    WZ_SetTableColors{"TYPETABLE",1,0,1,0}
    WZ_DrawTable{"TYPETABLE"}
  Else
    WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",3}
    WZ_SetTableTitle{"TYPETABLE","Identifier","Type","Offset"}
    WZ_SetTableColors{"TYPETABLE",1,0,1,0}
    WZ_SetPriority{"TYPETABLE",3,2,2}
    WZ_DrawTable{"TYPETABLE"}
  EndIf
  postype$(lev)=a$
  If lev > 1
    pos$(lev) = t$
  Else
    pos$(lev) = a$
  End If
  a$ = ""
  For i = 1 To lev:
    If i > 1
      a$ = a$+"\"+pos$(i):
    Else
      a$ = a$+"."+pos$(i):
    End If
  Next
  typestr$ = a$
  WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
  WZPrint "NEWTYPE_ENTRY",&a$
  WZ_ClearTable{"TYPETABLE"}
  i = 0
;  *nt = *nt2(lev)
;  While *nt
;    If Peek.w(*nt+6) = 1 Then a$ = "*" Else a$ = ""
;    a$ = a$ + Peek$(*nt+15)
;    c$ = Peek$(Peek.l(*nt+10)+11)
;    WZ_AddRow{"TYPETABLE",a$,c$,"$" + Right$(Hex$(Peek.w(*nt+4)),4)}
;    a$ = a$ + " ."+c$
;    *nt = Peek.l(*nt)
;    i = i + 1
;  Wend
  MOVE.l newtypebase,d0
  *nt = PutD0
  If *nt
    *nt = Peek.l(*nt)
    Format ""
    While *nt
      b$ = Peek$(*nt+11)
      If postype$(lev) = b$
        *nt3.l = Peek.l(*nt+4)
        While *nt3
          If Peek.w(*nt3+6) = 1 Then b$ = "*" Else b$ = ""
          b$ = b$ + Peek$(*nt3+15)
          c$ = Peek$(Peek.l(*nt3+10)+11)
          ;If Instr(b$,word1$) Then If Instr(b$,word2$)
          nt_value.w = Peek.w(*nt3+4)
          nt_displayvalue.s = "$"+Right$(Hex$(nt_value),4) + "(" + Str$(nt_value) + ")"
          WZ_AddRow{"TYPETABLE",b$,c$,nt_displayvalue}
          ;End If
          b$ + "  ." + c$
          *nt3 = Peek.l(*nt3)
        Wend
      EndIf
      *nt = Peek.l(*nt)
    Wend
    WZ_TableSort{"TYPETABLE",3}
    WZ_UpdateTable{"TYPETABLE"}
  End If
Return


.event_diag:
  Select pedMessage\_Class
    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "addcode"
            a$ = diag_addstr$
            For i =  1 To 12
              diag_val$(i) = WZGetString("val" + UStr$(i))
            Next
            Gosub diag_close
            Gosub activatesourcewindow
            Gosub cursor_off                                                                                                                                                                                                                                

            For i = 1 To 12
              a$ = a$ + diag_val$(i)
              If diag_val$(i+1) <>"" Then a$ = a$ + ","
            Next


            tmpColumn.w = Peek.w(?comWord_Column)
            tmpColumnsOffset.w = Peek.w(?comWord_ColumnsOffset)

            MOVE.l diag_addcodepos@(a5),a0 : SUB.l textbufferaddr,a0 : SUB.w comWord_TextBufferOffset,a0
            MOVE.w a0,comWord_Column
            CLR.w comWord_ColumnsOffset

            ; remove code to be replaced by diag code
            If diag_addcodesize > 1 Then t$ = Peeks$(diag_addcodepos,diag_addcodesize) : Else t$ = ""
            t$ = StripLead$(t$,32) : i = FLen(t$)
            If i > 0
               MOVE.l diag_addcodepos@(a5),a0 : SUB.l textbufferaddr,a0 : SUB.w comWord_TextBufferOffset,a0
               MOVE.w a0,comWord_Column
               For i2 = 1 To i - 1
                 Gosub deletechar
               Next
            End If

            ; insert new code
            Gosub insertstring

            Poke.w ?comWord_ColumnsOffset,tmpColumnsOffset
            Poke.w ?comWord_Column,tmpColumn
            Gosub cursor_on

        Case "diagclear"
          For i = 1 To 12
            diag_val$(i) = ""
            WZPrint "val" + UStr$(i), diag_val$(i)
          Next
          WZ_ActivateGadget{"val1"}

      End Select

    Case #IDCMP_CLOSEWINDOW
      Gosub diag_close

    Case #IDCMP_VANILLAKEY
      If pedMessage\_Code = #VANILLAKEY_ESC Then Gosub diag_close

  End Select

Return


.diag_close
  wtemp\diag_x = WindowX
  wtemp\diag_y = WindowY
  wtemp\diag_w = WindowWidth
  wtemp\diag_h = WindowHeight
  CloseWZWinWithMenu{"WIN_HELPDIAG"}
  diag = 0
Return


.load_windowlayouts:
  USEPATH wtemp
  CopyMem_ &wpref(ped\lastLayout),&wtemp,SizeOf .winprefs

  If (\lbrowser_w<=0) OR (\lbrowser_h<=0)
    \lbrowser_x = -2
    \lbrowser_y = -2
    \lbrowser_w = -2
    \lbrowser_h = -2
  EndIf

  If (\source_h > 0) AND (\source_w > 0)
    sourceWindow\WinLeft = \source_x
    sourceWindow\WinTop = \source_y
    sourceWindow\WinWidth = \source_w
    sourceWindow\WinHeight = \source_h
  Else
    *myscreen.Screen = Peek.l(Addr Screen(0))
    sourceWindow\WinLeft = 0
    sourceWindow\WinTop  = *myscreen\WBorTop + *myscreen\Font\ta_YSize + 1
    sourceWindow\WinWidth= ScreenWidth
    sourceWindow\WinHeight = ScreenHeight - (*myscreen\WBorTop + *myscreen\Font\ta_YSize + 1)
  EndIf
Return


.do_windowlayout:
  If \lbrowser_on
    log_Print{"opening library browser"}
    Gosub open_librarybrowser
  Else
    If WZ_CheckOpen{"WIN_LIBRARYBROWSER"}
      WZ_KillTable{"FUNCTIONSTABLE"}
      CloseWZWinWithMenu{"WIN_LIBRARYBROWSER"}
    EndIf
  End If

  If \ibrowser_on
    log_Print{"opening instruction browser"}
    Gosub open_instructionbrowser
  Else
    If WZ_CheckOpen{"WIN_INSTRUCTIONBROWSER"}
      WZ_KillTable{"INSTRUCTIONTABLE"}
      CloseWZWinWithMenu{"WIN_INSTRUCTIONBROWSER"}
    EndIf
  End If

  If \diag_on
    Gosub open_helpdiag
  Else
    If WZ_CheckOpen{"WIN_HELPDIAG"}
      CloseWZWinWithMenu{"WIN_HELPDIAG"}
      diag = 0
    EndIf
  End If

  If \click_on
    log_Print{"opening label window"}
    Gosub open_labelwindow
  Else
    If WZ_CheckOpen{"WIN_LABELS"}
      CloseWZWinWithMenu{"WIN_LABELS"}
    EndIf
  End If

  If \short_on
    Gosub open_shortcuts
  Else
    If WZ_CheckOpen{"WIN_SHORTCUTS"}
      WZ_KillTable{"SHORTCUTS"}
      CloseWZWinWithMenu{"WIN_SHORTCUTS"}
    EndIf
  End If

  If \type_on
    log_Print{"opening newtype window"}
    Gosub open_newtype
  Else
    If WZ_CheckOpen{"WIN_NEWTYPE"}
      WZ_KillTable{"TYPETABLE"}
      CloseWZWinWithMenu{"WIN_NEWTYPE"}
    EndIf
  End If

  log_Print{"opening/updating source window"}
  If sourceWindow\win <> 0
    ChangeWindowBox_ sourceWindow\win,sourceWindow\WinLeft,sourceWindow\WinTop,sourceWindow\WinWidth,sourceWindow\WinHeight
    RefreshWindowFrame_ sourceWindow\win
    VWait 1
    Gosub resize_sourcewindow
  Else
    Gosub open_sourcewindow
    If ped\errorCode = #PEDERROR_OPENWINDOW
      dummy.l = ask{!TRANS{"Unable to open window"},!TRANS{"Ok"},!TRANS{"Error"}}
      Pop If
      Goto exit_PED_closeall
    EndIf
    Gosub cursor_on
  EndIf

  FlushEvents
  If \activewin > 0
    Activate \activewin
    Use Window \activewin
    If Peek.l(Addr Window(\activewin)) <> 0
      Select \activewin
        Case 3 : WZ_ActivateGadget{"STRING_LABEL"}
        Case 2 : WZ_ActivateGadget{"STRING2"}
        Case 1 : WZ_ActivateGadget{"STRING"}
        Case 4 : WZ_ActivateGadget{"VAL1"}
      End Select
    EndIf
  Else
    Gosub activatesourcewindow
  EndIf
Return



.open_labelwindow:
  WZWindow WZID("WIN_LABELS"),?wzgui,255,\click_x,\click_y,\click_w,\click_h,WZID("WIN_LABELS")
  AddedMenu2WZWin{"WIN_LABELS"}
  ;GTSetMenuChecked 0,5,8,On
  LabelList_PreSelectItemNumber = -1                             ;added because we don't know what was the preselectitem  tomsmart1
  WZPrint "rem",Peek.w(?comWord_LabelRemark)
  WZPrint "all",Peek.w(?comWord_LabelAll)
  WZPrint "STRING_LABEL",search_label$
  WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels,LabelList_FirstVisableItemNumber
  ;Gosub update_versiongadgets
Return


.event_label:
  Select pedMessage\_Class
    Case #IDCMP_INTUITICKS
      ;all activities of the window like mouse move

      ;only need this to auto update the listview by typ in the search string   tomsmart1
      search_label$ = LCase$( WZGetString("STRING_LABEL") )
      If search_label$<>old_search_label$
        LabelList_FirstVisableItemNumber = 0
        CLR.l comLong_Label1VisableItem
        LabelList_PreSelectItemNumber = -1                       ; added to clear all old list datas  tomsmart1
        LabelList_NewSelectItemNumber.l = 0
        old_search_label$ = search_label$
        Gosub free_labellist
        !asm
        JSR update_labellist
        !basic
        Gosub redraw_labellist
        Poke$ ?comStr_LabelSearchString ,search_label$
      End If

    Case #IDCMP_RAWKEY
       ;move_cursor{"LISTVIEW_LABELS",list_labels,LabelList_PreSelectItemNumber}

    Case #IDCMP_VANILLAKEY:
      If EventCode = #VANILLAKEY_ESC Then Gosub close_label
      If EventCode = #VANILLAKEY_TAB Then Gosub activatesourcewindow

    Case #IDCMP_CLOSEWINDOW
      Gosub close_label

    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "string_label"
          ; no needed becaus is handled in #IDCMP_INTUITICKS
          ;Gosub activatesourcewindow                            ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1

        Case "case"
          search_label$ = "Case"
          WZPrint "STRING_LABEL",search_label$
          Poke.w ?comWord_LabelRemark,1
          Poke.w ?comWord_LabelAll,0
          WZPrint "rem",1
          WZPrint "all",0
          LabelList_FirstVisableItemNumber = 0
          CLR.l comLong_Label1VisableItem                        ; added to clear all old list datas  tomsmart1
          LabelList_PreSelectItemNumber = -1
          Gosub free_labellist
          !asm
          JSR update_labellist
          !basic
          Gosub redraw_labellist
          WZ_ActivateGadget{"STRING_LABEL"}

        Case "listview_labels"
          ; removed code that checked if the last and the new select item
          ; was the same because wizard.lib do it and by overwritable by doublellick  tomsmart1
          LabelList_PreSelectItemNumber = WZListNum("LISTVIEW_LABELS")
          LabelList_FirstVisableItemNumber = WZListPos("LISTVIEW_LABELS")
          wzlistitem
          Poke.l ?comLong_Label1VisableItem,LabelList_FirstVisableItemNumber
          ;WZPrint "LISTVIEW_LABELS",-1,list_labels,LabelList_FirstVisableItemNumber
          Gosub activatesourcewindow
          Gosub storeline_bas
          lineaddress.l = WZListData (list_labels, WZInput)
          log_Print{"jump to corresponding source line, itemnumber:"+ Str$(WZInput)}
          GetD0 lineaddress
          !asm
          MOVE.l comPtr_CurrentSourceLine,a4
          MOVE.l d0,a0
          ;JSR storeline
          JSR jump_addhistory
          JSR jump_to_keyword
          !basic
          GetReg d1,jumpresult.b
          log_Print{"jump_to_keyword returned: " + Str$(jumpresult)}
          ;Gosub cursor_on

        Case "rem"
          Poke.w ?comWord_LabelRemark,WZInput
          Poke.w ?comWord_LabelAll,0
          WZPrint "all",0
          ;search_label$ = "":WZGadSet "STRING_LABEL",search_label$
          LabelList_FirstVisableItemNumber = 0
          CLR.l comLong_Label1VisableItem                        ; added to clear all old list datas  tomsmart1
          LabelList_PreSelectItemNumber = -1
          Gosub free_labellist
          !asm
          JSR update_labellist
          !basic
          Gosub redraw_labellist
          WZ_ActivateGadget{"STRING_LABEL"}

        Case "all"
          Poke.w ?comWord_LabelAll,WZInput
          Poke.w ?comWord_LabelRemark,0
          WZPrint "rem",0
          LabelList_FirstVisableItemNumber = 0
          CLR.l comLong_Label1VisableItem                        ; added to clear all old list datas  tomsmart1
          LabelList_PreSelectItemNumber = -1
          Gosub free_labellist
          !asm
          JSR update_labellist
          !basic
          Gosub redraw_labellist
          WZ_ActivateGadget{"STRING_LABEL"}

        Case "clr"
          search_label$ = ""
          WZPrint "STRING_LABEL",search_label$
          LabelList_FirstVisableItemNumber = 0
          CLR.l comLong_Label1VisableItem                        ; added to clear all old list datas  tomsmart1
          LabelList_PreSelectItemNumber = -1
          Gosub free_labellist
          !asm
          JSR update_labellist
          !basic
          Gosub redraw_labellist
          WZ_ActivateGadget{"STRING_LABEL"}

        Case "button_update_liblist"

          ; MOVE.l comdata,D0   : *cd.l = PutD0
          ; MOVE.l varbase,D0   : *vb.l = PutD0
          ; MOVE.l instrbase,D0 : *intructionbase.l = PutD0
          ; MOVE.l libpointer,D0: *librarybase.l = PutD0
          Gosub scan_source_for_used_libs

        Case "library_list"
          cmd_node.l = WZGetNode(lib_list.List)
          searchcmd.s = WZListString(cmd_node,0)
          klammer.b = Instr(searchcmd,"(")
          If klammer
            used_win.l = Used Window

            casesens_backup.w = ped\caseSensitive       ; store searchmode

            searchcmd.s = StrChg(Left$(searchcmd,klammer-1)," ","")
            ped\caseSensitive = True
            Poke.s ?str_searchstring   ,searchcmd
            If searchcmdStore.s <> searchcmd
              searchcmdStore.s = searchcmd
              !asm
              MOVEQ #0,d0 : JSR jumpline
              !basic
            EndIf
            Gosub storeline_bas
            Gosub cursor_off
            Gosub menu_findnext
            Gosub update_vertscroller
            Gosub cursor_on

            ped\caseSensitive = casesens_backup          ; restore searchmode

            If (used_win >< -1) Then Use Window used_win
            Gosub activatesourcewindow
          EndIf

      End Select

  End Select
  move_cursor{"LISTVIEW_LABELS",list_labels,LabelList_PreSelectItemNumber}
Return

.close_label:
  wtemp\click_x = WindowX
  wtemp\click_y = WindowY
  wtemp\click_w = WindowWidth
  wtemp\click_h = WindowHeight
  CloseWZWinWithMenu{"WIN_LABELS"}
Return



.navigate_to_previous_label:
  If WZ_CheckOpen{"WIN_LABELS"}
    LabelList_PreSelectItemNumber = LabelList_PreSelectItemNumber-1
    If LabelList_PreSelectItemNumber<0 Then LabelList_PreSelectItemNumber = 0
    LabelList_NewSelectItemNumber = LabelList_PreSelectItemNumber
    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels
    Gosub storeline_bas
    i = WZListData (list_labels,LabelList_NewSelectItemNumber)
    !asm
    MOVEM.l a0-a6/d1-d7,-(a7)
    MOVEA.l comPtr_CurrentSourceLine,A4
    MOVE.l d0,a0
    ;JSR storeline
    JSR jump_to_keyword
    MOVEM.l (a7)+,a0-a6/d1-d7
    !basic
    Gosub cursor_on
  End If
Return

.navigate_to_next_label:
  If WZ_CheckOpen{"WIN_LABELS"}
    LabelList_PreSelectItemNumber = LabelList_PreSelectItemNumber+1
    If LabelList_PreSelectItemNumber = >WZListItems (list_labels) Then LabelList_PreSelectItemNumber = WZListItems (list_labels)-1
    LabelList_NewSelectItemNumber = LabelList_PreSelectItemNumber
    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_labels
    Gosub storeline_bas
    i = WZListData (list_labels,LabelList_NewSelectItemNumber)
    !asm
    MOVEM.l a0-a6/d1-d7,-(a7)
    MOVEA.l comPtr_CurrentSourceLine,A4
    MOVE.l d0,a0
    ;JSR storeline
    JSR jump_to_keyword
    MOVEM.l (a7)+,a0-a6/d1-d7
    !basic
    Gosub cursor_on
  End If
Return


JL_0_46D6:
  MOVE.l d0,-(a7)
  MOVEM.l a0-a1,-(a7)
  MOVE.l a1,a0
  CMP.b #".",-1(a0)
  BEQ 'sk1
    CMP.b #";",-1(a0)
    BEQ 'sk1
      SUBQ.l #1,a0
 'sk1
  MOVE.l expandstore,a1
  JSR detokenize_line
  MOVEM.l (a7)+,a0-a1
  MOVE.l a0,d0
  MOVE.l a1,temp
  !basic
  s = PutD0
  MOVE.l expandstore,d0
  i = PutD0
  If i Then s$ = Peek$(i) : Else s$=""
  If Instr(s$,"Stop") OR Instr(s$,"Trap")
    MOVE.l temp,a0
   'l1
    MOVE.b (a0)+,d0
    BEQ no_breakpoint
      CMP.b #$80,d0
      BNE 'l1
        CMP.b #$ae,(a0)
        BEQ 'l2
          CMP.b #$2d,(a0)
          BNE 'l1
   'l2
    WZTags #WENTRYA_TextPen,2
    If pedconfig\sort_labels = -1
      WZListAdd list_labels," --Breakpoint---",0,s
    Else
      WZListAdd list_labels," --Breakpoint---",2000,s
    End If
    ADDQ.w #1,comWord_LabelCounter
    ADDQ.l #1,numcount
    Goto nostr
  End If

  no_breakpoint:
  Select Peek.b(?is_stat_func_macro)                                          ; replaced IF... with Select... to support Macros  tomsmart1
    Case 1 : s$ = Mid$(s$,2) : WZTags #WENTRYA_TextPen,AB3Pen(#AB3_cfunction)
    Case 2 : s$ = Mid$(s$,2) : WZTags #WENTRYA_TextPen,AB3Pen(#AB3_cmacro)
   Default :                   WZTags #WENTRYA_TextPen,1
  End Select

  If t
    If Instr(s$,word1$) OR skip = 1
      If Instr(s$,word2$) OR skip = 1
        WZListAdd list_labels,s$,pedconfig\sort_labels,s
        ADDQ.w #1,comWord_LabelCounter
        ADDQ.l #1,numcount
        skip = 0
      End If
    End If
  Else
    If Instr(s$,search_label$) OR skip = 1
      WZListAdd list_labels,s$,pedconfig\sort_labels,s
      ADDQ.w #1,comWord_LabelCounter
      ADDQ.l #1,numcount
      skip = 0
    End If
  End If

  nostr:
  !asm
  MOVE.l (a7)+,d0
  CLR.b is_stat_func_macro
RTS


.storeline_bas:
  log_Print{"storeline"}
  If Peek.w(?comWord_KeyBeforeReturn) = 0 Then Return
  ped\ptrCurrentSourceData\SourceChanged = $FFFF

  Gosub cursor_off

  ; -- draw selecting block if existing
  SF comByte_StateBlockMark
  If Peek.l(?comLong_BlockEndY) >= 0
    log_Print{"storeline, erasing block"}
    displayline.l = Peek.l(?comLong_DisplayLine) + Peek.l(?comLong_DisplayLineOffset)
    If Peek.l(?comLong_BlockStartY) =< displayline
      If Peek.l(?comLong_BlockEndY) => displayline
          bmark\xMin = Peek.l(?comWord_BlockStartX)
          bmark\yMin = Peek.l(?comLong_BlockStartY)
          bmark\xMax = Peek.l(?comWord_BlockEndX)
          bmark\yMax = Peek.l(?comLong_BlockEndY)
          If bmark\yMin = bmark\yMax
            If bmark\xMin = bmark\xMax
              bmark\xMax = Peek.w(?visiblecolumns)
            EndIf
          EndIf
          AbsDimensions{bmark}
          PED_DrawBlock{bmark, Peek.w(?comWord_ColumnsOffset)}
          ST comByte_StateBlockMark
      EndIf
    EndIf
  EndIf 

  !asm
  MOVE.l comPtr_CurrentSourceLine,a4
  MOVEA.l textbufferaddr,A2 :  ADDA.w comWord_TextBufferOffset,A2
  JSR parse_line
  JSR replaceCurrentLine
  MOVE.l a4,comPtr_CurrentSourceLine
  !basic

  If Peek.l(?comWord_DoTokenize)
    !asm
    MOVEA.l comPtr_CurrentSourceLine,A2 : JSR print_sourceline
    !basic

    If Peek.b(?comByte_StateBlockMark)
      log_Print{"storeline: redrawing blockmark"}
      AbsDimensions{bmark}
      PED_DrawBlock{bmark, Peek.w(?comWord_ColumnsOffset)}
    EndIf
  EndIf

  CLR.w comWord_KeyBeforeReturn
  MOVE.l comPtr_CurrentSourceLine,a4
Return

;.storeline:
;  MOVE.w comWord_KeyBeforeReturn,D0
;  BEQ.w exit_storeline
;
;  !regs2stack
;  !basic
;  Gosub cursor_off
;  !asm
;  MOVE.l comPtr_CurrentSourceLine,a4
;  MOVEA.l textbufferaddr,A2 :  ADDA.w comWord_TextBufferOffset,A2
;  MOVE.w D0,comWord_SourceChanged
;
;  JSR parse_line
;
;  ; -- draw selecting block if existing
;  SF comByte_StateBlockMark
;  TST.l comLong_BlockEndY
;  BMI.w exit_updateblocka
;    MOVEM.l D0-D3/A0-A2,-(A7)
;    MOVE.l comLong_DisplayLine,D1 : ADD.l comLong_DisplayLineOffset,D1
;    CMP.l comLong_BlockStartY,D1
;    BLT.w JL_0_C66a
;      CMP.l comLong_BlockEndY,D1
;      BGT.w JL_0_C66a
;        MOVE.w comWord_BlockStartX,D0
;        MOVE.l comLong_BlockStartY,D1
;        MOVE.w comWord_BlockEndX,D2
;        MOVE.l comLong_BlockEndY,D3
;        CMP.l D1,D3
;        BNE.w JL_0_C50a
;          CMP.w D0,D2
;          BNE.w JL_0_C50a
;            MOVE.w visiblecolumns,D2
;        JL_0_C50a:
;        SUB.l comLong_DisplayLineOffset,D3
;        SUB.l comLong_DisplayLineOffset,D1
;        JSR _redrawBlock                               ;redraw blockmark
;        ST comByte_StateBlockMark
;    JL_0_C66a:
;    MOVEM.l (A7)+,D0-D3/A0-A2
;  exit_updateblocka:
;
;  JSR replaceCurrentLine
;
;  MOVE.w comWord_DoTokenize,D0
;  BEQ.w JL_0_CC6b
;    MOVEA.l comPtr_CurrentSourceLine,A2
;    JSR print_sourceline
;
;    TST.b comByte_StateBlockMark
;    BEQ.w JL_0_CC6b
;      MOVEM.l D0-D3/D7/A0-A2,-(A7)
;      MOVE.w comWord_BlockStartX,D0
;      MOVE.l comLong_BlockStartY,D1
;      MOVE.w comWord_BlockEndX,D2
;      MOVE.l comLong_BlockEndY,D3
;      CMP.l D1,D3
;      BNE.w JL_0_CB2a
;        CMP.w D0,D2
;        BNE.w JL_0_CB2a
;          MOVE.w visiblecolumns,D2
;      JL_0_CB2a:
;      SUB.l comLong_DisplayLineOffset,D3
;      SUB.l comLong_DisplayLineOffset,D1
;      JSR _redrawBlock                            ;redraw blockmark
;      MOVEM.l (A7)+,D0-D3/D7/A0-A2
;  JL_0_CC6b:
;
;  MOVE.l a4,comPtr_CurrentSourceLine
;  !stack2regs
;
;  exit_storeline:
;  CLR.w comWord_KeyBeforeReturn
;  MOVE.l comPtr_CurrentSourceLine,a4
;RTS


.ascii_to_token: ;d0 = token
  MOVEM.l d1-d7/a0-a6,-(a7)
  MOVE.l d0,a2                    ; D0: expandstore
  MOVEA.l comPtr_TokenBase,A3

  JL_0_6036b:
    MOVEA.l A2,A4
    MOVE.l A3,-(A7)
    ADDQ.w #6,A3

    JL_0_603Cb:
      MOVE.b (A3)+,D3
      BEQ.w JL_0_6082b     ;found
        MOVE.b (A4)+,D2
        ;BCLR #$7,D2
        ;ORI.b #$20,D3
        ;ORI.b #$20,D2
    CMP.b D3,D2
    BEQ.b JL_0_603Cb

    JL_0_6054b:
    MOVEA.l (A7)+,A3
    MOVE.l (A3),D3
    BEQ.w JL_0_6060b
      MOVEA.l D3,A3
  BRA.b JL_0_6036b
  JL_0_6082b:

  MOVE.b (A4),D2
  BNE JL_0_6054b
  BCLR #$7,D2
  BNE.b JL_0_6054b       ;not found
  MOVEA.l (A7)+,A3
  ADDQ.w #4,A3
  MOVEQ #0,d0
  MOVE.b (A3)+,d0
  ASL.l #8,d0
  MOVE.b (a3),d0
  MOVEM.l (a7)+,d1-d7/a0-a6
RTS

 JL_0_6060b
  MOVEQ #0,d0
  MOVEM.l (a7)+,d1-d7/a0-a6
RTS

.activatesourcewindow                                                         ; changed name to better show it pourpos  tomsmart1
  If sourceWindow\win
     ActivateWindow_ sourceWindow\win                                         ; replaced ASM part with Basic commands  tomsmart1
     Use Window 0                                                             ; added sourcewinid  tomsmart1
  EndIf
Return                                                                        ; replaced RTS with Return  tomsmart1


.draw_tabs:
  USEPATH sourceWindow
  SetAPen_ \win\RPort, AB3Pen(#AB3_screenfill)

  xpos_text.l = #filenamepos * \font\tf_XSize
  ypos_sa.w = \statusAreaY + 1
  ypos_text.w = ypos_sa + 2 + \font\tf_Baseline

  RectFill_ \win\RPort,xpos_text - 4,ypos_sa + 2,\win\Width - \win\BorderRight,ypos_sa + 1 + \font\tf_YSize

  ; -- draw all sourcefilename tabs
  If ped\firstSourceEntry
    *fileEntry.sourceEntry = ped\firstSourceEntry
;    xpos_text.l= #filenamepos * \font\tf_XSize ;Peek.w(?fontWidth)

    Repeat
      modifiedFlag.b = False
      textlen.w = 10                        ; width of tab in characters

      Move_ \win\RPort, xpos_text, ypos_text

      If *fileEntry = ped\currentSourceEntry
        fcol.w = AB3Pen(#AB3_screentext)    ; selected
        bcol.w = AB3Pen(#AB3_cbackground)
        bevel_recessed.b = True
        stylestate.w = #FSF_BOLD
      Else
        fcol.w = AB3Pen(#AB3_screentext)    ; unselected
        bcol.w = AB3Pen(#AB3_screenback)
        bevel_recessed.b = False
        stylestate.w = #FS_NORMAL
      EndIf

      Gosub draw_bevel

      ;SetDrMd_ \win\RPort, #JAM2
      SetAPen_ \win\RPort, fcol
      SetBPen_ \win\RPort, bcol

      If stylestate = #FSF_BOLD
        SetFont_ \win\RPort,\fontB
      Else
        SetFont_ \win\RPort,\font
      EndIf
      SetSoftStyle_ \win\RPort,stylestate.w,#FSF_BOLD


      If *fileEntry = ped\currentSourceEntry
        modifiedFlag = ped\ptrCurrentSourceData\SourceChanged
      Else
        modifiedFlag = Peek.w(*fileEntry + 8 + $14B)  ; $143
      EndIf
      If modifiedFlag
        Text_ \win\RPort,"*", 1
        textlen - 1
      EndIf

      tmp_string = Peek.s(*fileEntry + 8 + $D4)
      If tmp_string = "" Then tmp_string = "unnamed"
      tmp_string = StrLeft(tmp_string,16)
      Text_ \win\RPort, &tmp_string, textlen

      If FLen(tmp_string) > textlen             ;indicator for more characters
        wpx.w = \win\RPort\cp_x + 1
        wpy.w = \win\RPort\cp_y - \win\RPort\TxBaseline + \win\RPort\TxHeight / 2 - 1
        For wp.b = -4 To 4 Step 2
          ;WritePixel_ \win\RPort,  wpx , wpy + wp
          Move_ \win\RPort, wpx, wpy + wp
          Draw_ \win\RPort, wpx + 2, wpy  + wp
        Next wp
      EndIf 

      ;SetDrMd_ \win\RPort, #JAM2
      xpos_text = xpos_text + #filenameoffs * \font\tf_XSize
      log_Print{">> " + Hex$(*fileEntry) }
      *fileEntry = *fileEntry\nextEntry
    Until *fileEntry = 0
  EndIf

  SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
  SetFont_ \win\RPort,\font
  SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_BOLD
Return

.draw_bevel:
  xsa.l = \font\tf_XSize / 2
  xsb.l = \font\tf_XSize - xsa
  bx1.l = xpos_text - xsa
  by1.l = ypos_sa +1;+ 3
  bx2.l = \font\tf_XSize * 10 + \font\tf_XSize + bx1
  by2.l = \font\tf_YSize + 1  + by1
  cp_x.l = \win\RPort\cp_x
  cp_y.l = \win\RPort\cp_y

  If bevel_recessed = False
    SetAPen_ \win\RPort,AB3Pen(#AB3_screenback)
    RectFill_ \win\RPort,bx1+1,by1+1,bx2-1+1,by2
    SetAPen_ \win\RPort,AB3Pen(#AB3_screentext)
    Move_ \win\RPort,bx1,by1
    Draw_ \win\RPort,bx1,by2
    Draw_ \win\RPort,bx2+1,by2
    Draw_ \win\RPort,bx2+1,by1
  Else
    SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    RectFill_ \win\RPort,bx1+1,by1-1,bx2-1+1,by2
    SetAPen_ \win\RPort,AB3Pen(#AB3_cother)
    Move_ \win\RPort,bx1,by1
    Draw_ \win\RPort,bx1,by2+1
    Draw_ \win\RPort,bx2+1,by2+1
    Draw_ \win\RPort,bx2+1,by1
    cp_y+1
  EndIf
  Move_ \win\RPort,cp_x,cp_y
Return


.check_mouse_in_statusarea:
  If pedMessage\_Code = #SELECTDOWN

    If ped\firstSourceEntry
      mx.w = pedMessage\_MouseX - \win\BorderLeft
      my.w = pedMessage\_MouseY - \win\BorderTop

      xsa.l = \font\tf_XSize / 2
      xpos_start.w = #filenamepos * \font\tf_XSize - xsa
      xpos_end.w = 0
      ypos_start.w = \statusAreaY + 1
      ypos_end.w = ypos_start + 2 + \font\tf_Baseline + \font\tf_YSize

      *fileEntry.sourceEntry = ped\firstSourceEntry
      Repeat
        xpos_end = xpos_start + #filenameoffs * \font\tf_XSize
        ;-- check click position
        If (mx > xpos_start) AND (mx < xpos_end) AND (my > ypos_start) AND (my < ypos_end)
          log_Print{"mouse clicked at: " + Peek.s(*fileEntry + 8 + $D4)}
          If *fileEntry = ped\currentSourceEntry
            log_Print{"tab is actual file"}
            If pedMessage\_Qualifier AND (#IEQUALIFIER_CONTROL|#IEQUALIFIER_LALT|#IEQUALIFIER_RALT)
              log_Print{"control or alt pressed with mouse"}
              If ped\ptrCurrentSourceData\SourceChanged
                Gosub storeline_bas
                Delay_ 2
              EndIf
              ;Gosub set_tedlibbase_bas
              If pedMessage\_Qualifier AND #IEQUALIFIER_CONTROL
                log_Print{"control: create exe"}
                Gosub cursor_off
                !asm
                MOVEM.l    D2-D7/A1-A6,-(A7)
                MOVEQ.l    ##MENU_SAVECREATEEXE,D6
                JSR        call_compilermenuitem
                MOVEM.l    (A7)+,D2-D7/A1-A6
                !basic
              EndIf
              If pedMessage\_Qualifier AND (#IEQUALIFIER_LALT|#IEQUALIFIER_RALT)
                log_Print{"alt: compile & run"}
                Gosub cursor_off
                !asm
                MOVEM.l    D2-D7/A1-A6,-(A7)
                MOVEQ.l    ##MENU_COMPILERUN,D6
                JSR        call_compilermenuitem
                MOVEM.l    (A7)+,D2-D7/A1-A6
                !basic
              EndIf
            EndIf
          Else
            log_Print{"tab is not actual file."}
            Gosub storeline_bas

            GetD0 *fileEntry : Gosub selectfile

            Gosub storeCurrentSourceData
          EndIf
          log_Print{"exiting mouse routine"}
          Return
        EndIf
        xpos_start = xpos_end
        *fileEntry = *fileEntry\nextEntry
      Until *fileEntry = 0

    EndIf
  EndIf
Return

.loadfile:
  !basic
  tmpD0.l = PutD0 : fileToLoad.s = Peek.s(tmpD0)
  log_Print{"load file: " + fileToLoad}
  If fileToLoad = "<unnamed>"
    log_Print{"nothing to load: " + fileToLoad}
    Pop If
    !asm
    RTS
  EndIf

  ; checking if File is already open:
  If ped\firstSourceEntry
    log_Print{"searching if already in open files: "}
    *fileEntry.sourceEntry = ped\firstSourceEntry
    Repeat
      lpath.s = Peek.s(*fileEntry + 8 + $14)
      lfile.s = Peek.s(*fileEntry + 8 + $D4)
      If dos_AddPart{lpath,lfile} = fileToLoad
        log_Print{"source already loaded, switching to that tab."}
        GetD0 *fileEntry : Gosub selectfile
        Pop If : Pop Repeat : Pop If
        Return
      EndIf
      *fileEntry = *fileEntry\nextEntry
    Until *fileEntry = 0
    log_Print{"not loaded yet, loading ..."}
  EndIf

  log_Print{"opening a new tab..."}
  Gosub menu_opennew

  log_Print{"new tab opened, now loading [" + fileToLoad + "]"}
  loadsourcefilename.s = fileToLoad
  Gosub load_source
  !asm
RTS




; Begin routines for function build_HelpIndexFile  ; moved the functions and statemend defination out of the build index rountine for a better overview  tomsmart1
Function.l ab3_IsTokenChar{char.w}
  If char>=@"a" AND char<=@"z" Then Function Return True
  If char>=@"A" AND char<=@"Z" Then Function Return True
  If char>=@"0" AND char<=@"9" Then Function Return True
  If char=@"_" OR char=@"@" OR char=@"`" Then Function Return True
  Function Return False
End Function


Statement writeentry{destfile.l, mode$,instruction$}
SHARED pedconfig

  ;#TOKEN_Function  = $8009
  ;#TOKEN_Statement = $8008
  ;#TOKEN_Object    = $80d7
  ;#TOKEN_Macro     = $800d
  ;#TOKEN_End       = $8002
  ;#TOKEN_Return    = $8007

  ; -- don't add it if it contains @H
  If Instr(instruction$,"@H") Then Statement Return

  ; -- token return found
  If Instr(instruction$,Mki$(#TOKEN_Return)) Then Statement Return

  ; -- token End found
  If Instr(instruction$,Mki$(#TOKEN_End)) Then Statement Return

  startpos.l = 0
  Select mode$
    Case "FUNC"
      startpos = Instr(instruction$,Mki$(#TOKEN_Function))  + 2
      i3.l = Instr (instruction$,".",startpos)
      If (i3 < startpos+5) AND (i3 <> 0)
        startpos = i3+1                              ; change it to 1 to make the test of spaces possible  tomsmart1

         While Mid$(instruction$,startpos,1)<>" "    ; test if we have no space  so it is still the function type (newtype)  tomsmart1
           startpos + 1
         Wend

      End If
      If Instr(instruction$,"FAST",startpos)
        startpos.l = Instr(instruction$,"FAST",startpos)    + 4
      End If

    Case "STAT"
      startpos = Instr(instruction$,Mki$(#TOKEN_Statement)) + 2
      If Instr(instruction$,"FAST",startpos)
        startpos.l = Instr(instruction$,"FAST",startpos)    + 4
      End If

    Case "MACR"
      startpos = Instr(instruction$,Mki$(#TOKEN_Macro))     + 2

  End Select

  ; -- get string positions --
  instruction$ = dos_Trim{Mid$(instruction$,startpos)}

  endpos.l  =1
  stopchar.l=False
  While endpos<=FLen(instruction$) AND stopchar=False
    If ab3_IsTokenChar{Peek.b(&instruction$+endpos-1)}=False Then stopchar=True:Else endpos+1
  Wend

  ; -- write infos to indexfile
  If endpos <> 0
    funcname$ = Mid$( instruction$ , 1 , endpos - 1)
    ;If Right$(funcname$,1)=";" Then funcname$ = UnLeft$(funcname$,1)
    ;funcname$ = StripLead$(StrLeft(funcname$,50,32),32)
    funcname$ = StripLead$(funcname$,32)

    If FLen(funcname$) >= 6                                   ; test if functionname leng <= 6  tomsmart1
      If Left$(funcname$,6) = "Return" Then Statement Return  ; yes then test if function or statement RETURN then we have nothing to print back again  tomsmart1
    EndIf

    If mode$ = "MACR" Then funcname$ = "!" + funcname$

    description$ = Mid$(instruction$,endpos)
    description$ = StripLead$(description$,32)
    If Left$(description$,1)=";" Then description$ = UnRight$(description$,1)
    description$ = StripLead$(description$,32)

    If (Left$(funcname$,1) = "_") OR (Left$(funcname$,2) = "!_")             ; test for privat routines  tomsmart
      If pedconfig\HelpForPrivateFunctions = True                                   ; test if we show help for it  tomsmart1
        file_WriteLine{destfile, mode$ + "\\09" + funcname$ + "\\09" + description$ + " ; private!"}     ; show help but indentify private routines tomsmart1
      End If
    Else
      ;NPrint LSet$(mode$,11) + LSet$(funcname$,50) + description$
      file_WriteLine{destfile, mode$ + "\\09" + funcname$ + "\\09" + description$}                      ; public routines
    End If

  End If
End Statement



Function.l ab3_InstrToken{code.s,token.s}
  pos.l = Instr(code,token)
  If pos
    If ab3_IsTokenChar{Peek.b(&code+pos-1+FLen(token))} Then pos=0
    If pos>1
      If ab3_IsTokenChar{Peek.b(&code+pos-1-1)} Then pos=0
    End If
  End If
  Function Return pos
End Function



Statement scanfile{rootpath$,filename$, destfile.l}
  functoken$      = Mki$(#TOKEN_Function)
  statementtoken$ = Mki$(#TOKEN_Statement)
  objecttoken$    = Mki$(#TOKEN_Object)
  macrotoken$     = Mki$(#TOKEN_Macro)
  endtoken$       = Mki$(#TOKEN_End)
  returntoken$    = Mki$(#TOKEN_Return)
  tok80.s         = Str$($80)
  fid.l = file_Open{dos_AddPart{rootpath$,filename$},#file_read}
  If dos_GetExt{filename$}="bb2" Then tokenized.l=True : Else tokenized=False

  If fid>=0 ; ReadFile(0,filename$)
    ;file_Cache{fid}
    ;FileInput 0
    ; -- get current path
    ;dir_name$ = SPACE$(512)
    ;GetCurrentDirName_ &dir_name$,FLen(dir_name$)
    ;dir_name$ = StripTrail$(dir_name$,0)
    ;dir_name$ = dos_Trim{dir_name$}
    ;dir_name$ = dos_FilePart{dir_name$}

    ; -- add parent path to filename, if not in includes-drawer
    ;If LCase$(dir_name$)<>"includes" Then filename$ = dos_AddPart{dir_name$,filename$}

    ; -- write filename into indexfile
    file_WriteLine{destfile,"FILE\\09"+filename$}

    Repeat
      ;code.s = ReadLine$
      If tokenized
        code.s = file_ReadBB2Line{fid}
      Else
        code.s = file_ReadLine{fid}
      End If

      maxpos.l = Instr(code,";")
      If maxpos = 0 Then maxpos = FLen(code)-1

      ; in case its ASCII...
      If tokenized=False
        pos.l = ab3_InstrToken{code,"Function"}
        If pos>0 AND pos<maxpos
          ;If Instr(code,"GetObjectBy") Then error{"Found Function in "+filename$+" line:\\n"+code}
          code.s = Left$(code,pos-1) + functoken$ + Right$(code,FLen(code)-pos-8+1)
          If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"Statement"}
        If pos>0 AND pos<maxpos
          code.s = Left$(code,pos-1) + statementtoken$ + Right$(code,FLen(code)-pos-9+1)
          If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"Macro"}
        If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + macrotoken$ + Right$(code,FLen(code)-pos-5+1)
            If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"End "}
        If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + endtoken$ + Right$(code,FLen(code)-pos-3+1)
            If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"Return"}
        If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + returntoken$ + Right$(code,FLen(code)-pos-6+1)
            If pos<maxpos Then maxpos=pos
        End If
      End If
;      If Left$(a$,2) = ";/"
;        NPrint a$
;      Else
        pos = Instr(code,functoken$)
        If pos>0 AND pos<=maxpos Then writeentry{destfile, "FUNC",code}

        pos = Instr(code,statementtoken$)
        If pos>0 AND pos<=maxpos Then writeentry{destfile, "STAT",code}

        pos = Instr(code,macrotoken$)
        If pos>0 AND pos<=maxpos Then writeentry{destfile, "MACR",code}

;       EndIf
    Until file_EOF{fid}
    file_Close{fid}
  Else
    dummy.l = ask{!TRANS{"Can't open file "}+filename$,!TRANS{"Ok"},!TRANS{"Error"}}
  End If
End Statement


.build_HelpIndexFile
  DosBuffLen 32000
  CaseSense On

  log_Print{"****** Building a new HelpIndexFile..."}

  If dos_Exist{pedconfig\includeDir}

    ;-- check if Indexfile is available and delete it
    If dos_Exist{pedconfig\HelpIndexFile} Then dos_Delete{pedconfig\HelpIndexFile}

    ;-- create a new indexfile
    log_Print{"opening help index file: " + pedconfig\HelpIndexFile}
    destfid.l = file_Open{pedconfig\HelpIndexFile, #file_forcewrite}
    If destfid >= 0
      WZ_ShowMessage{!TRANS{"Updating indexfile for onlinehelp..."},0}
      WZ_ChangeTitle{"WIN_PROGRESS",!TRANS{BuildHelpIndexWinTitle$} }  ; use Statement to remove double code tomsmart1 2012 03 09 ; use a variable so the title match the function tomsmart1                                                             


      ClearList HelpIndexCache()

      ; scan for subdirs
      ClearList dirs()
      If AddLast(dirs()) Then dirs()\name = pedconfig\includeDir
      log_Print{"*** scan includedir <" + pedconfig\includeDir + ">"}
      Repeat
        name$ = dos_ScanDir{pedconfig\includeDir,"",#dos_scan_dirs}
        If dos_IsDir{name$}
          If AddLast(dirs()) Then dirs()\name = dos_AddPart{pedconfig\includeDir,name$}
          log_Print{"found subdir <" + name$ + ">"}
        EndIf
      Until name$ = ""

      ; count number of files
      num_files.l = 0
      ResetList dirs()
      While NextItem(dirs())
        dirname$ = dirs()\name                    ; set first subdirectory
        Repeat
          name$ = dos_ScanDir{dirname$,"#?",#dos_scan_files}
          num_files + 1
        Until name$ = ""
      Wend
      log_Print{"counted files: " + Str$(num_files)}


      ; scan files for functions
      ; begin count include files
      subincludedirs.b = False
      exitscan.b       = True
      dirname$         = ""
      act_file.l = 0
      ResetList dirs()
      act_file.l = 0
      While NextItem(dirs())
        dirname$ = dirs()\name                    ; set first subdirectory
        log_Print{"*** scanning dir <" + dirname$ + ">",#log_debug}
        Repeat
          name$ = dos_ScanDir{dirname$,"#?",#dos_scan_files}
          If name$<>""
            log_Print{"scanning file <" + name$ + ">"}
            act_file + 1 : act_file = Min(act_file,num_files)
            ex.s = dos_GetExt{name$}
            If (ex="bb2" OR ex="ab2" OR ex="ab3")
               scanfile{pedconfig\includeDir,name$, destfid}
            EndIf
            !WZ_Update_Gauge{act_file,num_files}
          End If
        Until name$ = ""
      Wend
      ClearList dirs()
      file_Close{destfid}

      WZ_ShowMessage{!TRANS{"Updating Helpindex..."}} : PED_UpdateHelpIndexCache{pedconfig\HelpIndexFile}
      WZ_ShowMessage{!TRANS{"Saving Helpindex to Disc..."}} : PED_WriteHelpIndexCache{pedconfig\HelpIndexCacheFile}
      WZ_ShowMessage{!TRANS{"Creating Hashmaps..."}}
      preproc_QueryTokens{*PreProcessor}
      preproc_SaveTokens{*PreProcessor,TokenHashMapFile}
      WZ_HideMessage{}
    End If
  Else
    dummy.l = ask{!TRANS{"Could not determine Include directory"}+":\\n"+pedconfig\includeDir+"!",!TRANS{"Ok"},!TRANS{"Error"}}
  EndIf

  CaseSense Off
RTS

.event_find:
    ped\caseSensitive = True
    find_findStr.s = WZGetString("FIND_FINDSTRING")
    find_replaceStr.s = WZGetString("FIND_REPLACESTRING")
    find_findStrOld.s    = find_findStr
    find_replaceStrOld.s = find_replaceStr

    If WZInput("FIND_SENSITIVE") = 0
      find_findStr.s = StrUpper(find_findStr)
      ped\caseSensitive = False
    EndIf

    Poke.s ?str_searchstring   ,find_findStr
    Poke.s ?str_replacestring  ,find_replaceStr

    Select pedMessage\_Class
      Case #IDCMP_CLOSEWINDOW
        CloseWZWinWithMenu{"WIN_SEARCH"}
        Gosub activatesourcewindow
        FlushEvents

      Case #IDCMP_VANILLAKEY
        Select pedMessage\_Code

          Case #VANILLAKEY_RETURN
            ; not enabled anymore, jump to next now via shortcut amiga-N

          Case #VANILLAKEY_ESC
            CloseWZWinWithMenu{"WIN_SEARCH"}
            Gosub activatesourcewindow
            FlushEvents

        End Select

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName

          Case "FIND_FINDSTRING"
            If StrUpper(findStrStore.s) <> StrUpper(find_findStr)
              findStrStore = find_findStr
              Gosub storeline_bas
              Gosub cursor_off
              Gosub menu_findnext
              Gosub update_vertscroller
              Gosub cursor_on
              FlushEvents : Delay_ 1
            End If

          Case "FIND_NEXT"
            Gosub storeline_bas
            Gosub cursor_off
            Gosub menu_findnext
            Gosub update_vertscroller
            Gosub cursor_on
            Gosub activatesourcewindow                ; added to make source win active that edit is possible  tomsmart1

          Case "FIND_PREVIOUS"
            Gosub storeline_bas
            Gosub cursor_off
            Gosub menu_findprevious
            Gosub update_vertscroller
            Gosub cursor_on
            Gosub activatesourcewindow

          Case "FIND_REPLACE"
            Gosub storeline_bas
            Gosub cursor_off
            Gosub menu_replace
            Gosub cursor_on
            Gosub activatesourcewindow                ; added to make source win active that edit is possible  tomsmart1

          Case "FIND_REPLACE_ALL"
            If find_findStr <> "" AND find_replaceStr <> ""
              Gosub storeline_bas
              Gosub cursor_off
              Gosub set_pointer_busy_bas
              Gosub menu_replaceall
              Gosub update_currsourceline_bas
              !asm
              JSR _redraw
              !basic
              Gosub cursor_on
              Gosub set_pointer_normal_bas
            EndIf
            Gosub activatesourcewindow                ; added to make source win active that edit is possible  tomsmart1

          Case "FIND_EXIT"
            CloseWZWinWithMenu{"WIN_SEARCH"}
            Gosub activatesourcewindow

        End Select

    End Select
Return


.coutclose:
  !coutclose
Return

;####################################################################
; BEGIN  routines compiler settings window  tomsmart 2012 03 21     #
;####################################################################
.BackupCompilerSettings:
  !asm
  !ComData_JSR{comFunc_BackupXtraData}
  !basic

; get pointer to the settings from the compiler
  !ComData_GetL{comPtr_Residents_Table       ,D0} : Ptr_Residents_Table.l        = PutD0
  !ComData_GetL{comPtr_Number_of_Objects_Word,D0} : Ptr_Number_of_Objects_Word.l = PutD0
  !ComData_GetL{comPtr_StringBuffer_Long     ,D0} : Ptr_Stringbuffer_Long.l      = PutD0
  !ComData_GetL{comPtr_Stacksize_Long        ,D0} : Ptr_Stacksize_Long.l         = PutD0
  !ComData_GetL{comPtr_Create_IconFile_Byte  ,D0} : Ptr_Create_Iconfile_Byte.l   = PutD0
  !ComData_GetL{comPtr_Make_SmallestCode_Byte,D0} : Ptr_Make_Smallestcode_Byte.l = PutD0
  !ComData_GetL{comPtr_Link_DebugInfo_Byte   ,D0} : Ptr_Link_Debuginfo_Byte.l    = PutD0
  !ComData_GetL{comPtr_Use_Debugger_Byte     ,D0} : Ptr_Use_Debugger_Byte.l      = PutD0
  !ComData_GetL{comPtr_Autorun_Byte          ,D0} : Ptr_Autorun_Byte.l           = PutD0
  !ComData_GetL{comPtr_InterruptCheck_Byte   ,D0} : Ptr_Interruptcheck_Byte.l    = PutD0
  !ComData_GetL{comPtr_AssemblerCheck_Byte   ,D0} : Ptr_Assemblercheck_Byte.l    = PutD0
  !ComData_GetL{comPtr_OverflowCheck_Byte    ,D0} : Ptr_Overflowcheck_Byte.l     = PutD0
  !ComData_GetL{comPtr_MaxObjects_Value_Word ,D0} : Ptr_MaxObjects_Value_Word.l  = PutD0
  !ComData_GetL{comPtr_MaxObject_Pos_Word    ,D0} : Ptr_MaxObject_Pos_Word.l     = PutD0

  !ComData_GetW{comWord_CreateDebugFile      ,D0} : comWord_CreateDebugFile_Back.w = PutD0 ; get status of Create.dbg file  tomsmart1
  !ComData_GetB{comByte_FuncOptimize         ,D0} : comByte_FuncOptimize_Back.b    = PutD0 ; get status of Function Optimizer  tomsmart1
  StringbufferValue_Backup.l = Peek.l(Ptr_Stringbuffer_Long)              ;get sringbuffersize  tomsmart1
  StackSizeValue_Backup.l    = Peek.l(Ptr_Stacksize_Long)                 ;get stacksize  tomsmart1
Return

.RestoreCompilerSettings:
  GetD0 comWord_CreateDebugFile_Back : !ComData_SetW{comWord_CreateDebugFile,D0}   ;restore settings that not stored in the xtradata
  GetD0 comByte_FuncOptimize_Back    : !ComData_SetB{comByte_FuncOptimize   ,D0}   ;restore settings
  Poke.l Ptr_Stringbuffer_Long,StringbufferValue_Backup
  Poke.l Ptr_Stacksize_Long   ,StackSizeValue_Backup
  !asm
  !ComData_JSR{comFunc_RestoreXtraData}
  !basic
Return


.menu_compilersettings   ; was .newoptionsfunc

  Gosub BackupCompilerSettings    ; make a Backup of the active settings

  MaxLen a$ = 5000

  If ScreenHeight>400
    com_scr_y.w = ScreenHeight/6
    com_scr_h.w = ScreenHeight/1.5
  Else
    com_scr_y.w = -2
    com_scr_h.w = -2
  End If

  WZWindow WZID("WIN_CPREFS"),?wzgui,256,-2,com_scr_y,-2,com_scr_h,WZID("WIN_CPREFS")
  WZ_SetFont{"WIN_CPREFS"}
  WZ_InitTable{"WIN_CPREFS","OBJECTS",2,0}
  WZ_SetTableColors{"OBJECTS",1,0,2,3,3}

  ; Setzen der Spaltentitel fuer die erste Zeile
  WZ_SetTableTitle{"OBJECTS","Objects","Max"}

  ; Legt die Prioritaet der 6 Spalten fest
  WZ_SetPriority{"OBJECTS",3,1}

  ; Setzt die zweite Spalte der Tabelle "OBJECTS" auf nicht editierbar
  WZ_SetEditable{"OBJECTS",False,True}

  ; Sortieren verboten
  WZ_SetSortable{"OBJECTS",Off}

  ; Fuegt Zeilen an die Tabelle "OBJECTS" an
  For i.l = 0 To Peek.w(Ptr_Number_of_Objects_Word)-1
    a$ = ""
    GetD0 &a$,i
    !ComData_JSR{comFunc_GetObjectEntry}    ;stringaddress in d0 , indexnumber d1
    a.l = PutD0
    WZ_AddRow{"OBJECTS",Peek$(&a$),Str$(a)}
  Next
  WZ_DrawTable{"OBJECTS"}
  ; Fuellt die Tabelle mit den Werten, die mit WZAddRow{} erstellt wurden
  WZ_UpdateTable{"OBJECTS"}

  ;get Residents and convert it to a string
  var.l = Ptr_Residents_Table
  a$ = Peek$(var)              ; get first entry
  For i = 0 To 6               ; get up to 7 entry
    a$ = a$ + "\\0a"           ; added a newline
    var + #ResidentEntryStep   ; update pointer to the next entry
    a$ = a$ + Peek$(var)       ; added next entry
  Next
  WZPrint "RESIDENTS",&a$      ; print string in gadget

  WZPrint "STRINGBUFFER",StringbufferValue_Backup

  WZPrint "STACKSIZE",StackSizeValue_Backup                       ;print it  tomsmart1

; get and set status of the checkmarks
  If Peek.b(Ptr_Create_Iconfile_Byte)=-128
    WZPrint "ICON",1
  Else
    WZPrint "ICON",0
  EndIf

  If Peek.b(Ptr_Make_Smallestcode_Byte)=-128
    WZPrint "SMALLEST",1
    WZDisable "FUNCOPTIMIZE"                           ; added to prevent senceless settings  and possible endless compile runs tomsmart1
  Else
    WZPrint "SMALLEST",0
    WZEnable "FUNCOPTIMIZE"                            ; added  tomsmart1
  EndIf

  If Peek.b(Ptr_Link_Debuginfo_Byte)=-128
    WZPrint "DEBUGINFO",1
  Else
    WZPrint "DEBUGINFO",0
  EndIf

  WZPrint "FUNCOPTIMIZE",comByte_FuncOptimize_Back     ; show status in the GUI tomsmart1
  If comByte_FuncOptimize_Back = 0                     ; added to prevent endless compile runs  tomsmart1
    WZDisable "SMALLEST"
  Else
    WZEnable "SMALLEST"                                ; added  tomsmart1
  EndIf

  WZPrint "DBGFILE",comWord_CreateDebugFile_Back       ; show status in the GUI tomsmart1


  ;runtime Debugging
  If Peek.b(Ptr_Use_Debugger_Byte)=-128
    WZPrint "DEBUG",1
    WZEnable "AUTORUN"                                   ; enable all Debugger settings  tomsmart1
    WZEnable "CHECK_INTERRUPT"                           ;               "
    WZEnable "CHECK_ASSEMBLER"                           ;               "
    WZEnable "CHECK_OVERFLOW"                            ;               "
  Else
    WZPrint "DEBUG",0
    WZDisable "AUTORUN"                                  ; disable all Debugger settings  tomsmart1
    WZDisable "CHECK_INTERRUPT"                          ;                "
    WZDisable "CHECK_ASSEMBLER"                          ;                "
    WZDisable "CHECK_OVERFLOW"                           ;                "
  EndIf

  If Peek.b(Ptr_Autorun_Byte)=-128
    WZPrint "AUTORUN",1
  Else
    WZPrint "AUTORUN",0
  EndIf

  If Peek.b(Ptr_Interruptcheck_Byte)=-128
    WZPrint "CHECK_INTERRUPT",1
  Else
    WZPrint "CHECK_INTERRUPT",0
  EndIf

  If Peek.b(Ptr_Assemblercheck_Byte)=-128
    WZPrint "CHECK_ASSEMBLER",1
  Else
    WZPrint "CHECK_ASSEMBLER",0
  EndIf

  If Peek.b(Ptr_Overflowcheck_Byte)=-128
    WZPrint "CHECK_OVERFLOW",1
  Else
    WZPrint "CHECK_OVERFLOW",0
  EndIf


  ;Event handling of the compiler settings window
  CompilerSettingsWin_Exit.l  = False

  Repeat  ;new

    comsettings_ev.l = WaitEvent


    If pedconfig\onlinehelp <> 0
      If (comsettings_ev <> #IDCMP_INTUITICKS) AND (comsettings_ev <> #IDCMP_ACTIVEWINDOW) AND (comsettings_ev <> #IDCMP_GADGETHELP) AND (comsettings_ev <> #IDCMP_CHANGEWINDOW)
        WZ_HideHelp{}
      EndIf
      If comsettings_ev = #IDCMP_GADGETHELP Then WZ_ShowHelp{}
    EndIf


    WZ_CheckTableEvent{comsettings_ev} ; handel events of the objecttabel

    Select comsettings_ev  ; handel events of the rest of the window

       Case #IDCMP_CLOSEWINDOW
         CompilerSettingsWin_Exit = True
         Gosub RestoreCompilerSettings

       Case #IDCMP_VANILLAKEY
         If EventCode = #VANILLAKEY_ESC
           CompilerSettingsWin_Exit = True
           Gosub RestoreCompilerSettings
         EndIf

       Case #IDCMP_IDCMPUPDATE
         Select LCase$(WZGadName)

           Case "autorun"
             If WZInput
               Poke.b Ptr_Autorun_Byte,-128
             Else
               Poke.b Ptr_Autorun_Byte,0
             End If

           Case "check_interrupt"
             If WZInput
               Poke.b Ptr_Interruptcheck_Byte,-128
             Else
               Poke.b Ptr_Interruptcheck_Byte,0
             End If

           Case "check_assembler"
             If WZInput
               Poke.b Ptr_Assemblercheck_Byte,-128
             Else
               Poke.b Ptr_Assemblercheck_Byte,0
             End If

           Case "check_overflow"
             If WZInput
               Poke.b Ptr_Overflowcheck_Byte,-128
             Else
               Poke.b Ptr_Overflowcheck_Byte,0
             End If
 
           Case "residents"

           Case "stacksize"                                   ; stacksize changed  tomsmart1
             tempsize.l=WZInput                               ; save the valu to a temporay variable  tomsmart1
             If tempsize >= #MIN_STACKSIZE                    ; check size  tomsmart1
               Poke.l Ptr_Stacksize_Long,tempsize                     ; save it.  tomsmart1
             Else                                             ; its not big enough  tomsmart1
               tempsize = #MIN_STACKSIZE                      ; set it to the min size  tomsmart1
               Poke.l Ptr_Stacksize_Long,tempsize                     ; save it  tomsmart1
               WZPrint "STACKSIZE",tempsize                   ; print it  tomsmart1
             EndIf

           Case "stringbuffer"
             Poke.l Ptr_Stringbuffer_Long,WZInput

           Case "debug"
             If WZInput
               Poke.b Ptr_Use_Debugger_Byte,-128                           ; yes runtime Debugging
               WZEnable "AUTORUN"                             ; enable all Debugger settings  tomsmart1
               WZEnable "CHECK_INTERRUPT"                     ;               "
               WZEnable "CHECK_ASSEMBLER"                     ;               "
               WZEnable "CHECK_OVERFLOW"                      ;               "
             Else
               Poke.b Ptr_Use_Debugger_Byte,0                           ; no runtime Debugging
               WZDisable "AUTORUN"                            ; disable all Debugger settings  tomsmart1
               WZDisable "CHECK_INTERRUPT"                    ;                "
               WZDisable "CHECK_ASSEMBLER"                    ;                "
               WZDisable "CHECK_OVERFLOW"                     ;                "
             End If

           Case "icon"
             If WZInput
               Poke.b Ptr_Create_Iconfile_Byte,-128
             Else
               Poke.b Ptr_Create_Iconfile_Byte,0
             End If

           Case "smallest"
             If WZInput
               Poke.b Ptr_Make_Smallestcode_Byte,-128
               WZDisable "FUNCOPTIMIZE"
             Else
               Poke.b Ptr_Make_Smallestcode_Byte,0
               WZEnable "FUNCOPTIMIZE"
             End If

           Case "debuginfo"                                      ; check "Create Debug info" (Symbols)
             If WZInput
               Poke.b Ptr_Link_Debuginfo_Byte,-128
             Else
               Poke.b Ptr_Link_Debuginfo_Byte,0
             End If

           Case "funcoptimize"                                   ; check "Use Function Optimizer"   tomsmart1
             If WZInput
               !ComData_SetB{comByte_FuncOptimize,#1}            ; yes we use it  tomsmart1
               WZEnable "SMALLEST"
             Else
               !ComData_SetB{comByte_FuncOptimize,#0}            ; no we don't  tomsmart1
               WZDisable "SMALLEST"
             EndIf

           Case "dbgfile"                                        ; check "Create .dbg File"   tomsmart1
             If WZInput
               !ComData_SetW{comWord_CreateDebugFile,#1}         ; yes we create it  tomsmart1
             Else
               !ComData_SetW{comWord_CreateDebugFile,#0}         ; no we don't  tomsmart1
             EndIf

          ;check main window buttons
           Case "cancel"
            CompilerSettingsWin_Exit = True
            Gosub RestoreCompilerSettings


           Case "ok"
            CompilerSettingsWin_Exit = True
            Gosub UseMaxObjectsAndResidentsSettings

         End Select

    End Select

  Until CompilerSettingsWin_Exit

  WZ_KillTable{"OBJECTS"}
  WZCloseWindow WZID("WIN_CPREFS")
  FlushEvents
  Gosub activatesourcewindow
Return


.UseMaxObjectsAndResidentsSettings:
  ; update save max objects settings  tomsmart1 2012 03 21
  For i.l = 1 To Peek.w(Ptr_Number_of_Objects_Word)
    a$ = WZ_GetCell{"OBJECTS",i,2}
    i2.l = Vallong(a$) : If i2 = 0 Then i2 = 1
    Poke.w Ptr_MaxObjects_Value_Word,i2
    Poke.w Ptr_MaxObject_Pos_Word   ,i-1
    !ComData_JSR{comFunc_StoreMaxObjects}
  Next

  ; the compiler have to free all loaded residents and to clear the space for safty  tomsmart1 2012 06 09
  !asm
  !ComData_JSR{comFunc_FreeClearResidentsForPED}
  !basic

  ; convert strings to Residents entrys  tomsmart1 2012 03 21
  i.l = WZInput("RESIDENTS")
  a$ = Peek$(i)
  InitArgParse a$
  var.l = Ptr_Residents_Table
  For i = 0 To 7
    p$ = NextArgChar$ ($a)
    Poke$ var,p$
    var + #ResidentEntryStep
  Next

  ; the compiler have to reload the residents   tomsmart1 2012 03 21
  !asm
  !ComData_JSR{comFunc_ReloadResidentsForPED}
  !basic
Return
;####################################################################
; END routines compiler settings window  tomsmart 2012 03 21       #
;####################################################################


;######################################################################
;# BEGIN        routines for the compile status Window                #
;#                                                                    #
;#   moved form the compiler to Ped and modified by tomsmart 20120224 #
;######################################################################
.Open_CompileStatus_Window:                                             ; open the compile status window
  Select CompileMenuCallID

    Case #MENU_RUN              ; we don't need to open the window
    Case #MENU_CREATEDEBUGCODE  ;   "
    Case #MENU_RELOAD_USERLIBS  ;   "

    Default
     If CompileStatusWindow_Pointer.l = 0
       WZWindow WZID("WIN_COMPILESTATUS"),?wzgui,64,-2,-2,-2,-2,WZID("WIN_COMPILESTATUS") ; try to open the wizard window
       CompileStatusWindow_Pointer = Peek.l(Addr Window(WZID("WIN_COMPILESTATUS")))       ; get and store the pointer to window
       ;set init data for the update of the status gadgets
       CompileStatus_String_Pointer.l            = Peek.l(?comPtr_CompileStatusString)    ; get the pointer of status string set by the compiler
       CompileStatus_CalculatedProcent_Pointer.l = Peek.l(?comPtr_CompileCalcProLong)     ; get the pointer of calculated procent value set by the compiler
       CompileStatus_String_Old.s                = ""                            ; set to default
       CompileStatus_CalculatedProcent.l         = 0                             ; set to default
       CompileStatus_CalculatedProcent_Old.l     = 0                             ; set to default
       CompileStatus_GaugeString.s               = "0%%"                         ; set to default
       CompileStatusWindow_Event.l               = 0

       ;set init data for the abort handling
       Poke.b ?comByte_CompileStatusAbortByte,0                                ; set default
       CompileStatusWindow_Abort.l = False                                     ; abort status default for the event loop

       ;print initstring
       If CompileStatusWindow_Pointer <> 0                                     ; check if window is open
         CompileStatus_String_Old = !TRANS{"Initializing Compiler..."}         ; set the init string
         WZPrint "COMPILE_INFO",CompileStatus_String_Old                       ; show the init string
       EndIf

     EndIf

  End Select
Return


.Update_CompileStatus_Window:                                             ; update the compile status window
  !regs2stack
  !basic
  If CompileStatusWindow_Pointer <> 0                                     ; check if window is open
    CompileStatusWindow_Event = Event                                     ; get the event
    ;update gadgets if needed
    CompileStatus_String_Pointer = Peek.l(?comPtr_CompileStatusString)
    If CompileStatus_String_Pointer <> 0                                  ; check if pointer is set
      If (CompileStatus_String_Old <> Peek.s(CompileStatus_String_Pointer)) ; check is status sting changed => Print it
        CompileStatus_String_Old = Peek.s(CompileStatus_String_Pointer)
        WZPrint "COMPILE_INFO",CompileStatus_String_Pointer
      End If
    EndIf

    CompileStatus_CalculatedProcent_Pointer = Peek.l(?comPtr_CompileCalcProLong)  ; get the pointer of calculated procent value set by the compiler
    If (CompileStatus_CalculatedProcent_Pointer <> 0)                     ; check if pointer is set
       CompileStatus_CalculatedProcent = Peek.l(CompileStatus_CalculatedProcent_Pointer)  ; get the value
      If (CompileStatus_CalculatedProcent >< CompileStatus_CalculatedProcent_Old) ; check if procent value changed => update gauge
         CompileStatus_CalculatedProcent_Old = CompileStatus_CalculatedProcent
         If (((CompileStatus_CalculatedProcent & $3)=0) OR (CompileStatus_CalculatedProcent=100))
            CompileStatus_GaugeString = Str$(CompileStatus_CalculatedProcent)+"%%"
            WZPrint "COMPILE_GAUGE",CompileStatus_CalculatedProcent,100,&CompileStatus_GaugeString
         End If
      End If
    EndIf
   ;test abort button (instead of a separte routine)

    While (CompileStatusWindow_Event <> 0)
      If CompileStatusWindow_Event = #IDCMP_VANILLAKEY
        Poke.b ?comByte_CompileStatusAbortByte,1
      EndIf
      If ( (CompileStatusWindow_Event = #IDCMP_IDCMPUPDATE) AND (CompileStatusWindow_Abort = False) ) ; go if a event happend and the button are not allready pressed
        If WZGadName = "COMPILE_ABORT"                                  ; check if "Abort" gadget is pressed
           Poke.b ?comByte_CompileStatusAbortByte,1                     ; set abort condition
           CompileStatusWindow_Abort = True                             ; set abort condition so the event checking can skiped if a next window update is happend befor the abort is handeled by the compiler
        EndIf
      EndIf
      CompileStatusWindow_Event = Event                                 ; get next event
    Wend
    FlushEvents
  EndIf

  Gosub print_availmem

  !asm
  !stack2regs
RTS


.Close_CompileStatus_Window:                                            ; close the compile status window
  If CompileStatusWindow_Pointer <> 0
    WZCloseWindow WZID("WIN_COMPILESTATUS")                             ;turn off the requester
    CompileStatusWindow_Pointer             = 0                         ;set pointer to 0 because we close the window
    CompileStatus_String_Pointer            = 0
    CompileStatus_CalculatedProcent_Pointer = 0                         ;set pointer to 0 because we close the window
  EndIf
Return
;######################################################################
;# END          routines for the compile status Window                #
;######################################################################


; ---------------------------------------------------------------------
; Declarations of Variables
; ---------------------------------------------------------------------
.DECLARATIONS
wzgui:                IncBin "ped.wizard"

instring              Dc.b 0
instring2             Dc.b 0
instring3             Dc.b 0
historypointer:       Dc.l 0
ptr_deflibsfilename   Dc.l 0
ptr_incdirname        Dc.l 0

.classiccommands
                      ; memory reservations for libs that where introduced with old blitz2
                      ; here come whole libs
                      Dc.w 11    ; Ricopperfxlib.obj
                      Dc.w 45    ; Risoundlib.obj
                      Dc.w 56    ; Xbciatrackerlib.obj
                      Dc.w 60    ; EML (enhanced music library)
                      Dc.w 65    ; rigfxlib
                      Dc.w 82    ; medlib
                      Dc.w 96    ; trackerlib
                      Dc.w 98    ; blitzkeyslib
                      Dc.w 112   ; spriteslib
                      Dc.w 113   ; cd32lib
                      Dc.w 116   ; audiolib
                      Dc.w 117   ; blitzoslib
                      Dc.w 119   ; 2dlib
                      Dc.w 143   ; displaylib
                      Dc.w 144   ; blitzcoplib
                      Dc.w 146   ; bblitlib
                      Dc.w 148   ; qblitlib
                      Dc.w 150   ; blitlib
                      Dc.w 152   ; freqlib
                      Dc.w 156   ; palettelib
                      Dc.w 190   ; gameiolib
                      Dc.w 204   ; bfbplaymaster.library1
                      Dc.w 209   ; thxplay.library1

                      Dc.w 0     ;say end
                                 ;set breakpoint
                      Dc.w $3385 ;timer commands here come single commands
                      Dc.w $2588 ;timer
                      Dc.w $1784 ;timer
                      Dc.w $4d08 ;get a shape

                      Dc.w 0     ;say end

;classiccolor          Dc.l 1
;olddebugmode          Dc.w $0101
;cutmode               Dc.w 0
;dummystr              Dc.b ":",0,0 : Even

BSS
Even
comWord_BoundLinesX:  Dc.w 2
comWord_BoundLinesY:  Dc.w 2
comLong_Label1VisableItem: Dc.l 0
noDetokenizing:       Ds.w 1                                                         
loadAsNew             Ds.w 1
fontWidth             Ds.w 1
foldnum               Ds.l 1 
typestr               Ds.b 80
is_stat_func_macro    Ds.b 1                ; labellist identifier for statement, function or macro  tomsmart1 ; was isfunction
keepstring            Ds.b 1
;helpstring            Ds.b 260
searchmode            Ds.w 1 
slen2                 Ds.l 1
straddr2              Dc.l 0
straddr               Dc.l 0
numcount              Dc.l 0
constantbase          Dc.l 0
newtypebase           Dc.l 0
newsyntax             Dc.l 0
instrtab              Ds.l 32769
newted                Dc.l 0
history               Ds.l 10
tempbuf               Ds.b 260
convert               Dc.b 0
instru                Ds.w 1
chartab               Ds.b 260      ;last
lowerchartable        Ds.l 1
casemode              Ds.w 1
temp                  Ds.w 1
deftypefound          Ds.w 1
