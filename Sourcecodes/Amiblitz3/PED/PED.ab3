; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Development:AmiBlitz3/System"
; ExeFile         = "PED"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 64000
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 3.9.11
; NumberOfBuilds  = 3447
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8192
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 4646
; CursorColumn    = 1
; LabelSearch     = "ped_getfirstblockline"
; LabelRemark     = 0
; LabelAll        = 1
; LabelCase       = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 25
; Max GadgetList  = 5
; Max Shape       = 100
; Max Bank        = 5
; Max MenuList    = 5
; Max GTList      = 25
; Max Palette     = 4
; Max BitMap      = 1
; Max Screen      = 5
; Max IntuiFont   = 5
; Max BlitzFont   = 4
; Max Window      = 25
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max TagList     = 5
; Max Database    = 16
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/ Name: PED                                                                   /
;/                                                                             /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, AmigaOS4, MOS                         /
;/                                                                             /
;/ Date: 01.07.2022                                                            /
;/                                                                             /
;/ Authors: 1990...1996 Mark Silby                                             /
;/          1991...2003 Red When Excited                                       /
;/          2003...2009 Bernd Roesch, Sven Droege                              /
;/          2009...2016 The Opensource Team                                    /
;/          2019...     Sven Droege                                            /
;/                                                                             /
;/ Requirements: AmigaOS 2.05+                                                 /
;/                                                                             /
;/ Purpose:                                                                    /
;/ GUI for AmiBlitz3 programming language.                                     /
;/                                                                             /
;/ Abstract:                                                                   /
;/ This is not a stand alone program. It is launched by the AmiBlitz3 compiler./
;/ See AmiBlitz3 abstract.                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
DEBUG
; -------------------------------------------------------
; KONSTANTENDEFINITIONEN
; -------------------------------------------------------
.CONST

#USE_AREXX           = 1     ; include the arrexport?
#USE_WIZARD          = 1     ; use wizard library?
#WZ_USE_IMAGES       = 0     ; use pictures in tables
#WZ_singletable      = 1     ; only one table at the same time

#maxlabels           = 512
#maxhistory          = 8
#MAX_SOURCEFILES     = 16
#MAX_MENUTEMPLATES   = 16    ; max custom menuentries
#slowdown            = 0     ; reduce scrolling speed (for very fast machines)
#hardfold            = 0     ; not working
#leftoffset          = 1     ; startpos of filename tabs
#bevelsize           = 11    ; size of filename tabs


; -- OS version to enable/disable various features
#AmigaOS3 = 1
#AmigaOS4 = 2
#MorphOS  = 3
#AROS     = 4

; -- for gotoline
#LINE_START = 1
#LINE_END = 2
#LINE_NOCHANGE = 3

; -- for slider gadgets
#GID_XPROP  =900
#GID_YPROP  =901
#GID_RARROW =910
#GID_LARROW =911
#GID_UARROW =912
#GID_DARROW =913
#max_slider_res = $7FFF

; -- PED Errors
#PEDERROR_NOERROR        = $0000
#PEDERROR_OPENSCREEN     = $1001
#PEDERROR_OPENPUBSCREEN  = $1002
#PEDERROR_OPENWINDOW     = $1011

; -- Tokens IDs
#TOKEN_End       = $8002
#TOKEN_Return    = $8007
#TOKEN_Statement = $8008
#TOKEN_Function  = $8009
#TOKEN_If        = $800B
#TOKEN_While     = $800C
#TOKEN_Macro     = $800D
#TOKEN_Select    = $800E
#TOKEN_Case      = $800F
#TOKEN_For       = $8016
#TOKEN_Then      = $8021
#TOKEN_Stop      = $802D
#TOKEN_TRAP      = $80AE
#TOKEN_Repeat    = $80BB
#TOKEN_EndIf     = $80C0
#TOKEN_Object    = $80D7
#TOKEN_DEFTYPE   = $8033
#TOKEN_Pop       = $80BE ; dhandlerlib

; -- scrolling options for sourceWindow
#SCROLL_UP       = 1
#SCROLL_DOWN     = -1
#SCROLL_LEFT     = 1
#SCROLL_RIGHT    = -1
#SCROLL_CURRENT_LINE = 1
#FULL_REDRAW     = 2

; -- Keycodes
; Raw
#RAWKEY_TAB           = $42
#RAWKEY_RETURN        = $44
#RAWKEY_ESC           = $45
#RAWKEY_UP            = $4C
#RAWKEY_DOWN          = $4D
#RAWKEY_RIGHT         = $4E
#RAWKEY_LEFT          = $4F
#RAWKEY_F1            = $50
#RAWKEY_F10           = $59
#RAWKEY_HELP          = $5F

; Vanilla
#VANILLAKEY_BACKSPACE = $08
#VANILLAKEY_TAB       = $09
#VANILLAKEY_RETURN    = $0D
#VANILLAKEY_ESC       = $1B
#VANILLAKEY_UP        = $1C
#VANILLAKEY_DOWN      = $1D
#VANILLAKEY_RIGHT     = $1E
#VANILLAKEY_LEFT      = $1F
#VANILLAKEY_DELETE    = $7F
#VANILLAKEY_F1        = $81
#VANILLAKEY_F2        = $82
#VANILLAKEY_F3        = $83
#VANILLAKEY_F4        = $84
#VANILLAKEY_F5        = $85
#VANILLAKEY_F6        = $86
#VANILLAKEY_F7        = $87
#VANILLAKEY_F8        = $88
#VANILLAKEY_F9        = $89
#VANILLAKEY_F10       = $8A
#VANILLAKEY_HELP      = $8B
   

;/* Project */
#MENU_PROJECTSETTINGS     = $00000132
#MENU_IDEPREFERENCES      = $00000073
#MENU_AUTOLAYOUT          = $00000075
#MENU_GETLAYOUT1          = $00000171
#MENU_GETLAYOUT2          = $00000172
#MENU_GETLAYOUT3          = $00000173
#MENU_SETLAYOUT1          = $00000174
#MENU_SETLAYOUT2          = $00000175
#MENU_SETLAYOUT3          = $00000176
#MENU_CUSTOMEDIT          = $00000259
#MENU_OPENWORKBENCH       = $0000006F
#MENU_CLOSEWORKBENCH      = $00000070
#MENU_OPENSHELL           = $00000072
#MENU_CALCULATOR          = $00000057
#MENU_ABOUT               = $00000074
#MENU_ICONIFY             = $00000071
#MENU_QUIT                = $0000006D

;/* Source */
#MENU_NEW                 = $00000065
#MENU_OPEN                = $00000067
#MENU_OPENNEW             = $00000066
#MENU_INCLUDEFILE         = $00000068
#MENU_SAVE                = $00000069
#MENU_SAVEAS              = $0000006A
#MENU_EXPORTASCII         = $0000006B
#MENU_PRINT               = $0000006E
#MENU_CLOSE               = $0000006C

#MENU_LASTSOURCE1         = $00000078
#MENU_LASTSOURCE2         = $00000079
#MENU_LASTSOURCE3         = $0000007A
#MENU_LASTSOURCE4         = $0000007B
#MENU_LASTSOURCE5         = $0000007C
#MENU_TEMPLATE            = $00000200

;/* Edit */
#MENU_CUT                 = $000000C9
#MENU_COPY                = $000000CA
#MENU_PASTE               = $000000CB
#MENU_DUPLICATE           = $000000D8
#MENU_FORGET              = $000000CC
#MENU_KILL                = $000000D7
#MENU_SAVEBLOCKAS         = $000000CD
#MENU_INSERTLINE          = $000000CE
#MENU_DELETELINE          = $000000CF
#MENU_UNDELETELINE        = $000000D0
#MENU_JOINLINES           = $000000D1
#MENU_DELETETOEOL         = $000000D9
#MENU_BLOCKTAB            = $000000D2
#MENU_BLOCKUNTAB          = $000000D3
#MENU_BLOCKCOMMENT        = $000000D4
#MENU_BLOCKUNCOMMENT      = $000000D5
#MENU_MARKINDENT          = $000000D6
#MENU_INSERTFILENAME      = $00001000
#MENU_OPENFILEUNDERCURSOR = $00001001

;/* Navigation */
#MENU_OPENFIND            = $00000191
#MENU_FIND                = $00000192
#MENU_PREVIOUS            = $00000193
#MENU_REPLACE             = $00000194
#MENU_TOP                 = $0000012D
#MENU_BOTTOM              = $0000012E
#MENU_GOTOLINE            = $0000012F
#MENU_PREVPAGE            = $00000130
#MENU_NEXTPAGE            = $00000131

;/* Compiler */
#MENU_COMPILERUN          = $00000050 ;Compiler
#MENU_RUN                 = $00000051 ;Compiler
#MENU_CREATEEXE           = $00000052 ;Compiler
#MENU_COMPILERSETTINGS    = $00000053 ;PED
#MENU_CREATERESIDENT      = $00000054 ;Compiler
                                      ;PED
#MENU_SETCLIARGS          = $00000056 ;PED
                                      ;PED
#MENU_RELOAD_USERLIBS     = $00000058 ;Compiler
                                      ;PED
                                      ;PED
#MENU_SAVECREATEEXE       = $0000005B ;PED->MENU_CREATEEXE
#MENU_SAVECOMPILERUN      = $0000005C ;PED->MENU_COMPILERUN
#MENU_CREATEDEBUGCODE     = $0000005D ;Compiler
#MENU_CREATERELEASEEXE    = $0000005E ;Compiler

;/* Help */
#MENU_WHATSNEW            = $000001F0
#MENU_GENERALGUIDE        = $000001F1
#MENU_PROGRAMGUIDE        = $000001F2
#MENU_INCLUDEGUIDE        = $000001F4
#MENU_BLITZLIBSGUIDE      = $000001F3
#MENU_SHORTCUTREFERENCE   = $000001F6
#MENU_INSTRUCTIONBROWSER  = $000001F5
#MENU_SOURCEBROWSER       = $00000059
#MENU_DEFINITIONBROWSER   = $00000055
#MENU_LIBRARYBROWSER      = $000001F7
#MENU_UPDATEHELPINDEX     = $000001F8

;/* Custom */
#MENU_CUSTOMITEM1         = $00000260      ; must be greater than #MENU_CUSTOMEDIT because hat now its own ID  tomsmart1

;---------------







;@@1
!initasm
!basic
OPTIMIZE 5
SYNTAX 6
; ---------------------------------------------------- ADD INCLUDEFILES
; ------------------------------------------------------
#use_bbscreen      = 0     ; workaround for screen_close crash   (->screeen.include)
#USE_WBSTARTUPMSG  = 0
#CLIARGMODE        = 0     ; OS-Calls

XINCLUDE "/BlitzLibs/Residents/blitzbasic/libnums.ab3"
XINCLUDE "/Shared/library_offsets.ab3"      ; only for Macro newalloc
XINCLUDE "/Shared/common.ab3"
XINCLUDE "/Shared/preprocessor.include.ab3"
XINCLUDE "/Shared/ted.include.ab3"
DEFTYPE.preprocessor *preProcessor
DEFTYPE.tokendata *tokenbase
DEFTYPE.l *macrobase
DEFTYPE.l *newtypebase
DEFTYPE.l *constantbase
DEFTYPE.l *varbase


XINCLUDE "v43+.definitions.ab3"                       ; for MouseWheel support  tomsmart1
XINCLUDE "dos.include.ab3"
XINCLUDE "file.include.ab3"
XINCLUDE "asl.include.ab3"
XINCLUDE "clipboard2.include.ab3"
XINCLUDE "vvblank.include.ab3"
;XINCLUDE "eclock.include.ab3"

; ---------------------------------------------------
XINCLUDE "translation.include.ab3"


; --------------------------------------------------- LOGGING
.LOGGING
XINCLUDE "logging.include.ab3"

;log_Init{"CON:0/19/1200/200/AmiBlitz3 Log"}

log_SetLevel{#log_nothing}
log_SetDestination{#log_toconsole,"System/PED.log"}
!log_SetColumns{120}
log_Print{"===================================================================",#log_debug}
!log_AvailMem{"BEGIN"}

; --------------------------------------------------- Wizard-Extensions
XINCLUDE "wizard_Tools.include.ab3"
XINCLUDE "wizard_Table.include.ab3"
XINCLUDE "wizard_ColorWheel.include.ab3"
ColorWheelError.b = False

; --------------------------------------------------- AREXX
CNIF #USE_AREXX = 1
XINCLUDE "arexx.include.ab3"
Dim registeredArexxHosts.s(7) ; needed in PED_Arexx
CEND

; --------------------------------------------------- TYPE DEFINITIONS
.TYPES
DEFTYPE.l quicktype
DEFTYPE.l

Macro IsIllegalChar
  Peek.b(ped\illegalCharTable + `1)
End Macro

Macro removeTokenbits
  ;-- clear token bit info but dont trash strings
  ma_nostring.b = 0
  For i.l = `1 To `1 + `2
    If ma_nostring = 0
      Poke.b i,Peek.b(i) AND $7f
      If Peek.b(i) = $22 Then ma_nostring = 1
    Else
      If Peek.b(i) = $22 Then ma_nostring = 0
    End If
    ; workaround:
    ; sometimes there is a 0 in a linestring perhaps due to a wrong lineaddr
    ; the 0 is been replaced by a space
    If Peek.b(i) = 0 Then Poke.b i,32
  Next
End Macro

Macro mul48f
  _floattemp.f = (`1)
  _floattemp = _floattemp * (`2)
  _floattemp = _floattemp / (`3)
  `4 = Int(_floattemp + .5)
End Macro


NEWTYPE.readcache
  *fib.FileInfoBlock

  filehandle.l
  filelen.l

  bufferptr.l       ; pointer to memarea allocated for cache
  bufferoffset.l    ; current read byte in buffer

  cacheptr.l
  cachelen.l
  offset.l
  currentbyte.b

  readlen.l
  chunklen.l
  blocklen.l

  *cH.clipboardHandle
  cb_linecount.l
  cb_eol.b

  mode.b           ; PasteMode: File or Clipboard
  moreBytes.b
End NEWTYPE
DEFTYPE.readcache readcache



NEWTYPE.pedconfig
  no_welcome.b
  ask_before_quit.b
  load_last_source.b
  remember_saved.b
  create_backups.b

  no_display_beep.b
  use_pubscreen.b
  use_wbscreen.b
  use_default_pubscreen.b
  use_wbfont.b
  clone_wbscreen.b

  auto_indent.b
  auto_format.b
  auto_constructs.b
  correct_functions.b
  use_source_icon.b
  use_commandsintellisens.b
  intellisense.b
  localization.b
  onlinehelp.b
  onlinehelp_extended.b
  onlinehelp_includes.b
  HelpForPrivateFunctions.b

  smart_tokenization.b
  highlighting.b
  usePreProcessor.b

  linenumbers.b
  cursorStyle.b
  blinkrate.b
  bold_tokens.b
  tabSize.w

  autolayout.b
  al_leftspace.w
  al_topspace.w
  al_rightspace.w
  al_bottomspace.w

  scroll_rate.b
  wheelStep.l

  console_device.s
  console_title.s
  console_font.s
  console_wb.b
  console_wait.b

  screen_modeID.l
  screen_Height.l
  screen_Width.l
  screen_Depth.l

  use_filepattern.b
  asl_use_dims.b
  asl_x.w          ; asl-requester dims
  asl_y.w
  asl_w.w
  asl_h.w

  sort_labels.b

  rememberFile.s
  lastSourceFile.s
  menuFile.s
  winprefsFile.s

  HelpIndexTextFile.s
  HelpIndexBinFile.s
  TokenHashMapFile.s

  mainDir.s
  systemDir.s
  blitzlibDir.s
  includeDir.s
  autodocDir.s
  helpDir.s
  sourceDir.s

  useBaseLib.b
  useUtilLib.b
  useOsLib.b
  useCsLib.b

  baselibFile.s
  utillibFile.s
  oslibFile.s
  cslibFile.s

End NEWTYPE
DEFTYPE.pedconfig pedconfig

NEWTYPE.ped
  taskWinPtr.l                           ; save possibly set window to thisTask
  *screen.Screen
  *menuStrip.Menu
  *AbDiscObject.DiskObject_     ; used for tooltype access

  mempool.l
  illegalCharTable.l
  tokenCache.l
  errorCode.w

  currentDir.s
  currentFile.s
  filePattern.s
  sourceFileComplete.s
  amiblitzmode.b

  check_existsfile.b
  extention_info.s
  extention_xtra.s
  extention_bak.s

  *firstSourceEntry.sourceEntry
  *currentSourceEntry.sourceEntry
  *firstLoadedEntry.sourceEntry

  *ptrCurrentSourceData.sourceEntry       ; needed as long as comPtr_CurrentSourceLine ist converted

  currentDirLock.l
  oldDirLock.l
  sourceFileHandle.l
  inString.b
  noDetokenizing.b
  keepString.b
  convertAsm.b
  doTokenize.w
  debugMode.b

  caseSensitive.b
  searchString.s
  replaceString.s

  lastAutoLayout.b
  lastLayout.b
  pubScreenNumber.s
  pubscreenName.s
  defaultPubscreenName.s
  defaultScreenTitle.s

  ;-- Definitionbrowser
  definitionMode.b
  structLevel.b
  lastStructLevel.b
  currentConstantStr.s
  currentVariableStr.s
  currentNewtypeStr.s
  previousNewtypeStr.s
  lastConstantStr.s
  lastVariableStr.s
  lastNewtypeStr.s

  ;-- biglibs data
  baselibFileSize.l
  baselibFileDate.s
  utillibFileSize.l
  utillibFileDate.s
  oslibFileSize.l
  oslibFileDate.s
  cslibFileSize.l
  cslibFileDate.s

  labelIdentifier.b
  labelListChanged.b
  labelSearchMode.b
  labelEntryType.l

  verticalCopyMode.b
  blockmarkRemovalMode.b

  undeleteStrLen.w
  no_scrollrate.b
  foldNumber.l

  historyPointer.l
  historyTable.l[#maxhistory]

  ptrTextbuffer.l
  ptrTextbufferPrint.l
  ptrLineUndeleteStore.l
End NEWTYPE
DEFTYPE.ped ped

; -- set initial source metadata
ped\ptrCurrentSourceData = ?comLong_XtraBegin
ped\labelIdentifier = Peek.b(?comByte_LabelIdentifier)
ped\check_existsfile = False
ped\extention_info = ".info"
ped\extention_xtra = ".xtra"
ped\extention_bak = ".bak"
ped\filePattern = "(#?.bb2|#?.asm|#?.ab2|#?.ab3|#?.txt)"


NEWTYPE.runningExe
  *process.Process

  cliFileHandle.l
  storeInputStream.l
  storeOutputStream.l
End NEWTYPE
DEFTYPE.runningExe runExe

NEWTYPE.sourceWindow
  *pedScreen.Screen
  *drawinfo.DrawInfo
  *win.Window
  *rp.RastPort
  *vertiprop.Gadget
  *horizprop.Gadget

  *font.TextFont
  *fontB.TextFont

  redrawFlag.b
  
  statusAreaY.w
  visibleLines.l
  visibleColumns.w

  boundLinesX.w
  boundLinesY.w
  scrollSize.w

  WinLeft.w                      ; store window dimensions
  WinTop.w
  WinWidth.w
  WinHeight.w

  BoxLeft.w
  BoxTop.w
  BoxWidth.w
  BoxHeight.w

  cursorEnabled.b
  cursorState.b
  cursorX1.w
  cursorY1.w
  cursorX2.w
  cursorY2.w

  lastEditedLine.l
  bookmarkLine1.l
  bookmarkLine2.l
  bookmarkLine3.l

  Title.s
End NEWTYPE
DEFTYPE.sourceWindow sourceWindow
DEFTYPE.RastPort *sourcerp

NEWTYPE.bmark
  xMin.w
  yMin.l
  xMax.w
  yMax.l
End NEWTYPE
DEFTYPE.bmark bmark

NEWTYPE.mousePos
  X.w
  Y.w
  textX.w
  textY.w
End NEWTYPE
DEFTYPE.mousePos mousePos

NEWTYPE.project
  name.s
  drawer.s
  wizardfile.s
  sourcefile.s[#MAX_SOURCEFILES]
  sourcepath.s[#MAX_SOURCEFILES]
  sourcecounter.b
  pad.b         ; make it even
  ;
  version.w
  revision.w
  ;
  use_wbstartup.b
  use_nocli.b
  use_syntax.b
  use_optimize.b
  value_syntax.b
  value_optimize.b
End NEWTYPE
DEFTYPE.project ab3_project
Dim tempproject$(#MAX_SOURCEFILES,1)
MaxLen project_changelog.s = 1024
project_filename.s = ""

Dim rememberfiles$(5)

NEWTYPE .pedfilelist
 dummy.b[$DE]
 filename.s
End NEWTYPE

NEWTYPE .winprefs
  diag_x.w
  diag_y.w
  diag_w.w
  diag_h.w
  diag_on.b

  click_x.w
  click_y.w
  click_w.w
  click_h.w
  click_on.b

  ibrowser_x.w
  ibrowser_y.w
  ibrowser_w.w
  ibrowser_h.w
  ibrowser_on.b

  type_x.w
  type_y.w
  type_w.w
  type_h.w
  type_on.b
  activewin.b

  source_x.w
  source_y.w
  source_w.w
  source_h.w

  short_x.w
  short_y.w
  short_w.w
  short_h.w
  short_on.b

  lbrowser_x.w
  lbrowser_y.w
  lbrowser_w.w
  lbrowser_h.w
  lbrowser_on.b

  console_x.w
  console_y.w
  console_w.w
  console_h.w
  console_on.b
End NEWTYPE
Dim wpref.winprefs(3)
DEFTYPE.winprefs wtemp

NEWTYPE.custommenu
  itemname.s
  shortcut.s
  id.l
  path.s
  runwbmode.l
  stacksize.l
  prio.l
End NEWTYPE
Dim List custommenu.custommenu(0)

NEWTYPE.templates
  filename.s
  description.s
End NEWTYPE
Dim List templates.templates(0)

Dim diag_lab$(15)
Dim diag_val$(15)

; --------------------------- Color settings --------------------------
#AB3_cfunction         = 1
#AB3_cmacro            = 2
#AB3_cstring           = 3
#AB3_cnewtype          = 4
#AB3_cconstant         = 5
#AB3_cremarkforeground = 6
#AB3_cremarkbackground = 7
#AB3_ctoken            = 8
#AB3_ctokenbackground  = 9
#AB3_cbackground       = 10
#AB3_cother            = 11
#AB3_cclassic          = 12

#AB3_screenback        = 20
#AB3_screentext        = 21
#AB3_screenshine       = 22
#AB3_screenfill        = 23
#MAX_AB3Pens           = 24     ; added to replace Array dimension and maxindex for loops  tomsmart1
Dim AB3Pen.w(#MAX_AB3Pens)
Dim AB3RGB.l(#MAX_AB3Pens)
Dim AB3RGB_temp.l(#MAX_AB3Pens)
AB3RGB_copytemp.l = 0           ; added for temporary copy of the select color  tomsmart1


; --------------------------- Cursor modes -----------------------------
#AB3_cursorStyle_block      = 0
#AB3_cursorStyle_line       = 1
#AB3_cursorStyle_underline  = 2

Function.s cursorStyleGetString{value.w}
  Select value
  Case #AB3_cursorStyle_block
    Function Return "block"
  Case #AB3_cursorStyle_line
    Function Return "line"
  Case #AB3_cursorStyle_underline
    Function Return "underline"
  Default
    Function Return "block"
  End Select
End Function

Function.w cursorStyleGetValue{stylestring.s}
  Select LCase$(stylestring)
  Case "block"
    Function Return #AB3_cursorStyle_block
  Case "line"
    Function Return #AB3_cursorStyle_line
  Case "underline"
    Function Return #AB3_cursorStyle_underline
  Default
    Function Return #AB3_cursorStyle_block
  End Select
End Function
; -----------------------------------------------------------------------

SHARED num_operators.b  : num_operators = 0
Restore key_chars
Repeat
  Read key_char$
  If key_char$<>""
    Dim KEEP operators$(num_operators)                  ; array to store characters to structurize (auto_format-option)
    operators$(num_operators) = key_char$
    num_operators + 1
  EndIf
Until key_char$ = ""
key_chars:
Data.s "=",":","<",">","+","-","/","*","&","|",";",""


;-- for Macro PED_LoadSsource
loadsourcefilename.s = ""
loadnewtab.b = False
loadchecktab.b = False
loadcheckchanged.b = False
;--

;-- for listtype window
Dim pos2(15),pos$(15),postype$(15)

MaxLen tmpStringVar.s     = 1024          ; used for different temporary things
MaxLen tmpTokeStr.s       = #MAX_Columns  ; used in tokenize/detokenize functions
MaxLen linebuff$          = 256           ; used in tokenize/detokenize functions

WZListAdd list_Labels.List ," "
WZListRemove list_usedBlitzLibs.List

#MAX_Blitzlibs             = 256
Dim blitzlibMapping.s(#MAX_Blitzlibs,1)
; -------------------------------------- structs for source window
NEWTYPE.pedMessage
  _Class.l
  _Code.w
  _Qualifier.w
  _IAddress.l
  _MouseX.w
  _MouseY.w
  _Seconds.l
  _Micros.l
  _Window.l
End NEWTYPE
DEFTYPE.pedMessage pedMessage

; ------------------------------------------------------
; MACRODEFINITIONS
; ------------------------------------------------------
.MACROS
Macro versions
  "\\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH (\\__DATE_GER__) Build \\__VER_BUILD"
End Macro

Macro regs2stack
  MOVEM.l d0-d7/a0-a6,-(a7)
End Macro

Macro stack2regs
  MOVEM.l (a7)+,d0-d7/a0-a6
End Macro

Macro checkOption ; 1:variable, 2:optionValue
  (`1 AND `2)
End Macro

Macro PED_UpdateTextBufferOffset
  ped\ptrCurrentSourceData\TextBufferOffset = ped\ptrCurrentSourceData\DisplayLine * #MAX_Columns
End Macro


Macro PED_storeCursorPosition
  USEPATH ped\ptrCurrentSourceData
  \StoreColumn = \Column
  \StoreDisplayLine = \DisplayLine
  \StoreTextBufferOffset = \TextBufferOffset
End Macro

Macro PED_RestoreCursorPosition
  USEPATH ped\ptrCurrentSourceData
  \Column = \StoreColumn
  \DisplayLine = \StoreDisplayLine
  \TextBufferOffset = \StoreTextBufferOffset
End Macro

Function.b PED_IncreaseDisplayLine{}
; return 1 if the sourcewindow has to be scrolled because there is a new line to be displayed at the bottom
; returns -1 if the cursor has been moved without any change of the text view
  SHARED ped, sourceWindow
  USEPATH ped\ptrCurrentSourceData
   If sourceWindow\visibleLines >= (\DisplayLine + 1 + sourceWindow\boundLinesY)
    \DisplayLine + 1
    !PED_UpdateTextBufferOffset
    Function Return True    
  Else
    \DisplayLineOffset + 1
    !PED_UpdateTextBufferOffset    
    Function Return 1
  EndIf
End Function

Function.b PED_DecreaseDisplayLine{}
; return 1 if the sourcewindow has to be scrolled because there is a new line to be displayed at the top
; returns -1 if the cursor has been moved without any change of the text view
SHARED ped, sourceWindow
USEPATH ped\ptrCurrentSourceData
  If \DisplayLineOffset = 0 OR (\DisplayLine - 1 > sourceWindow\boundLinesY)
    \DisplayLine - 1
    !PED_UpdateTextBufferOffset
    Function Return True
  Else
    \DisplayLineOffset - 1
    !PED_UpdateTextBufferOffset
    Function Return 1
  EndIf
End Function


Function.b PED_CursorInBlockmark{actualLine.l, actualColumn.w}
SHARED ped
  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
    If (ped\ptrCurrentSourceData\BlockStartY < actualLine) OR (ped\ptrCurrentSourceData\BlockStartY = actualLine AND ped\ptrCurrentSourceData\BlockStartX <= actualColumn)
      If (ped\ptrCurrentSourceData\BlockEndY > actualLine) OR (ped\ptrCurrentSourceData\BlockEndY = actualLine AND ped\ptrCurrentSourceData\BlockEndX <= actualColumn)
        Function Return True
      EndIf
    EndIf
  EndIf
End Function


SHARED storeBlockStartX.w : storeBlockStartX = $FFFF
Macro PED_ResetBlockflag
  storeBlockStartX = $FFFF
  ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
End Macro

Macro PED_LoadSource ; filename, checkchanged, checktab, newtab
  loadsourcefilename.s = `1
  loadcheckchanged.b = `2
  loadchecktab.b = `3
  loadnewtab.b = `4
  Gosub load_source
End Macro

; ------------------------------------------------------
; FUNCTIONDEFINITIONS
; ------------------------------------------------------
.FUNCTIONS

Statement WZ_CloseAllWindows{}                    ; made a Statement to close all (used) Wizard Windows to remove double code  tomsmart1
  Gosub close_contexthelp
  Gosub close_popupwindow

  Gosub kill_menus

  Gosub close_instructionbrowser
  Gosub close_definitionbrowser
  Gosub close_sourcebrowser
  Gosub close_librarybrowser
  Gosub close_helpdiag
  Gosub close_shortcuts

  WZCloseWindow WZID("WIN_SEARCH")
  WZCloseWindow WZID("WIN_SETTINGS")
  WZ_HideBubble{}
End Statement


; Added the menu to the open WZ window
Statement WZ_AddMenuStrip{wzwinname.s, *menuStrip.Menu}
  If Addr Window(WZID(wzwinname))<>0
    winaddr.l = Peek.l(Addr Window(WZID(wzwinname)))
    If *menuStrip AND winaddr
      SetMenuStrip_ winaddr, *menuStrip
    EndIf
  EndIf
End Statement 

; Remove the menu and than close WZ window
Statement WZ_CloseWindowAndRemoveMenu{wzwinname.s}
  wzwinid.l = WZID(wzwinname)
  If Addr Window(wzwinid) <> 0
    *win.Window = Peek.l(Addr Window(wzwinid))
    If *win
      ClearMenuStrip_ *win
      WZCloseWindow wzwinid
    Else
      log_Print{"WZ_CloseWindowAndRemoveMenu: Window [" + wzwinname + "] ist not open.",#log_warning}
    EndIf
  EndIf
End Statement

Statement PED_SetPointerNormal{}
SHARED sourceWindow, SourceWindowIDCMPFlags.l

  If sourceWindow\win
    If (ExecVersion > 38)
      SetWindowPointerA_ sourceWindow\win, Tags(#WA_Pointer, Null, #TAG_END,Null)
    EndIf

    ;- reset to standard flags
    ModifyIDCMP_ sourceWindow\win, SourceWindowIDCMPFlags
  EndIf

  WZ_UnlockAllOpenWindows{}
End Statement

Statement PED_SetPointerBusy{}
SHARED sourceWindow, SourceWindowIDCMPFlags.l

  If sourceWindow\win
    If (ExecVersion > 38)
      ;-- I the heck dont know, why this does NOT work:
      ;SetWindowPointerA_ sourceWindow\win, Tags(#WA_BusyPointer,True, #TAG_END,Null)

      SetWindowPointerA_ sourceWindow\win, ?taglist_pointer_busy
    EndIf
    ;--  only allow following flags to lock the sourcewin
    ModifyIDCMP_ sourceWindow\win, #IDCMP_NEWSIZE|#IDCMP_REFRESHWINDOW|#WFLG_REPORTMOUSE
  EndIf

  WZ_LockAllOpenWindows{}
  Statement Return

  .taglist_pointer_busy:
  Dc.l $80000098               ; #WA_BusyPointer
  Dc.l $FFFFFFFF               ; TRUE
  Dc.l $00000000               ; 0
End Statement


Function.l PED_AllocMem{memsize.l}
SHARED ped
  memptr.l = AllocPooled_(ped\mempool, memsize + 4)
  If memptr <> 0
    Poke.l memptr, memsize + 4
    Function Return memptr + 4
  Else
    Function Return False
  EndIf
End Function

Statement PED_FreeMem{memptr.l}
SHARED ped
  FreePooled_ ped\mempool,memptr-4,Peek.l(memptr-4)
End Statement

Statement PED_ClearTokencache{}
SHARED ped
  GetReg A1, ped\tokenCache
  MOVE.l #32767,d0
  'l11:
    CLR.l (a1)+
  DBF d0,'l11
End Statement


Statement PED_ClearTextbuffer{}
SHARED sourceWindow,ped

  ;_from.l = ped\ptrTextbuffer
  ;_to.l = _from + (#MAX_Columns / 2) * sourceWindow\visibleLines - 1
  ;For tb.l = _from To _to Step 2
  ;  Poke.w tb, $2020
  ;Next tb

  GetReg D1,sourceWindow\visibleLines
  GetReg A0,ped\ptrTextbuffer
  MOVE.w #MAX_Columns,D0 : LSR.w #1,D0 : MULS d0,d1 : SUBQ.w #1,D1
  JL_0_76A6:
    MOVE.w #$2020,(A0)+
  DBF D1,JL_0_76A6
End Statement


Function PED_PrintStatus{txt$,xpos.w,@ypos.w}
  SHARED sourceWindow,AB3Pen()

  USEPATH sourceWindow
  If \win
    If FLen(txt$) > 0
      If Vallong(txt$) > 0                                   ; boldtext for numbers
        ;SetFont_ \win\RPort,\fontB
        SetSoftStyle_ \win\RPort,#FSF_BOLD,#FSF_BOLD
      EndIf

      xpos_text.l = \win\GZZWidth - (\font\tf_XSize) * xpos - 4
      If ypos <> -1
        ypos_text.w = \statusAreaY + (\font\tf_YSize) * ypos
      Else
        ypos_text.w = \statusAreaY + (\font\tf_YSize)
      EndIf

      SetAPen_ \win\RPort, AB3Pen(#AB3_screenshine)
      SetBPen_ \win\RPort, AB3Pen(#AB3_screenfill)
      Move_ \win\RPort, xpos_text, ypos_text

      Text_ \win\RPort,&txt$,FLen(txt$)

      SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)

      If Vallong(txt$) > 0
        ;SetFont_ \win\RPort,\font
        SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_BOLD
      EndIf
    EndIf
  Else
    log_Print{"PrintStatus(): window pointer empty!"}
  EndIf
End Function

Statement PED_DrawStatusArea{}
SHARED sourceWindow, ped, AB3Pen()
USEPATH sourceWindow

  ;log_Print{"draw statusarea"}

  ;-- clear areas
  SetAPen_  \win\RPort, AB3Pen(#AB3_screenfill)
  If \statusAreaY <= \win\GZZHeight
    RectFill_ \win\RPort, 0,\statusAreaY,\win\GZZWidth,\win\GZZHeight
    RectFill_ \win\RPort, 0,0, \win\GZZWidth,\font\tf_YSize
  Else
    log_Print{"illegal area for draw statusara"}
  EndIf

  ;-- Draw separation lines
  SetAPen_ \win\RPort, AB3Pen(#AB3_screenshine)
  Move_ \win\RPort,0,\statusAreaY : Draw_ \win\RPort,\win\GZZWidth,\statusAreaY

  SetAPen_ \win\RPort, AB3Pen(#AB3_screentext)
  Move_ \win\RPort,0,\statusAreaY + 1 : Draw_ \win\RPort,\win\GZZWidth,\statusAreaY + 1
  Move_ \win\RPort,0,\BoxTop-1 : Draw_ \win\RPort,\win\GZZWidth,\BoxTop-1

  ;-- Draw the tabs for each source file
  xpos_text.w = #leftoffset * \font\tf_XSize
  ypos_text.w = \statusAreaY + 4 + \font\tf_Baseline

  ;-- clear statusarea
  ;-- statusarea has to seperator lines, a white and a black one
  SetAPen_ \win\RPort, AB3Pen(#AB3_screenfill)
  RectFill_ \win\RPort, xpos_text - 4, \statusAreaY + 2, \win\Width - \win\BorderRight,\statusAreaY + 2 + \font\tf_YSize + 1

  ; -- draw all sourcefilename tabs
  If ped\firstSourceEntry
    *fileEntry.sourceEntry = ped\firstSourceEntry
    Repeat
      bevelsize.w = #bevelsize - 1

      If *fileEntry = ped\currentSourceEntry
        stylestate.w = #FSF_BOLD
        fcol.w = AB3Pen(#AB3_screenshine)    ; selected
        bcol.w = AB3Pen(#AB3_screenback)
        bevel_recessed.b = True
      Else
        stylestate.w = #FS_NORMAL
        fcol.w = AB3Pen(#AB3_screenshine)    ; unselected
        bcol.w = AB3Pen(#AB3_screenback)
        bevel_recessed.b = False
      EndIf

      xsa.l = \font\tf_XSize / 2

      bx1.l = xpos_text - xsa
      by1.l = \statusAreaY + 2
      bx2.l = bx1 + \font\tf_XSize * #bevelsize - 1
      by2.l = by1 + \font\tf_YSize + 2

      cp_x.l = \win\RPort\cp_x
      cp_y.l = \win\RPort\cp_y

      If bevel_recessed = False
        SetAPen_ \win\RPort,AB3Pen(#AB3_screenback)
        RectFill_ \win\RPort,bx1,by1, bx2, by2
        SetAPen_ \win\RPort,AB3Pen(#AB3_screentext)
        Move_ \win\RPort,bx1,by1
        Draw_ \win\RPort,bx1,by2
        Draw_ \win\RPort,bx2,by2
        Draw_ \win\RPort,bx2,by1
      Else
        SetAPen_ \win\RPort,AB3Pen(#AB3_screenback)
        RectFill_ \win\RPort,bx1,by1, bx2, by2
        SetAPen_ \win\RPort,AB3Pen(#AB3_screenshine)
        Move_ \win\RPort,bx1,by1
        Draw_ \win\RPort,bx1,by2 + 1
        Draw_ \win\RPort,bx2,by2 + 1
        Draw_ \win\RPort,bx2,by1
        cp_y + 1
      EndIf

      ;-- check the name
      modifiedFlag.b = False
      tmpStringVar.s = Peek.s(&*fileEntry\SourceName)
      If tmpStringVar = "" Then tmpStringVar = "unnamed"
      If *fileEntry = ped\currentSourceEntry
        modifiedFlag = ped\ptrCurrentSourceData\SourceChanged
      Else
        modifiedFlag = *fileEntry\SourceChanged
      EndIf
      If modifiedFlag Then tmpStringVar = "*" + tmpStringVar


      ;-- optionally draw indicator for more chars
      If FLen(tmpStringVar) > bevelsize
        Move_ \win\RPort,bx2,by1
        For wp.w = by1 To by2-1 Step 3
          Move_ \win\RPort, bx2 - 1, wp + 1
          Draw_ \win\RPort, bx2 - 3, wp + 1
        Next wp
      EndIf

      ;-- print the bevel caption
      If stylestate = #FSF_BOLD
        ;SetFont_ \win\RPort,\fontB
      Else
        SetFont_ \win\RPort,\font
      EndIf
      SetSoftStyle_ \win\RPort, stylestate, #FSF_BOLD

      SetAPen_ \win\RPort, fcol
      SetBPen_ \win\RPort, bcol
      tmpStringVar = Left$(tmpStringVar, bevelsize)
      Move_ \win\RPort, xpos_text-2, ypos_text
      Text_ \win\RPort, &tmpStringVar, FLen(tmpStringVar)


      xpos_text = xpos_text + #bevelsize * \font\tf_XSize

      *fileEntry = *fileEntry\nextEntry
    Until *fileEntry = 0
  EndIf

  SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
  SetFont_ \win\RPort,\font
 SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_BOLD

  ;----------------------------------------------------------------------------
  PED_PrintStatus{"Line:        ", 24}
  PED_PrintStatus{"Column:    ", 11}
End Statement


Statement PED_ShowStatusSymbol{icon.s, offset.b, state.b}
SHARED sourceWindow,AB3Pen()
  USEPATH sourceWindow
  xpos.w = \win\GZZWidth - 2 - (offset * (\font\tf_XSize+1))

  If state = On 
    SetSoftStyle_ \win\RPort, #FSF_BOLD, #FSF_BOLD
    SetAPen_ \win\RPort, AB3Pen(#AB3_screenshine)
    SetBPen_ \win\RPort, AB3Pen(#AB3_screenfill)
  Else
    SetAPen_ \win\RPort, AB3Pen(#AB3_screentext)
    SetBPen_ \win\RPort, AB3Pen(#AB3_screenfill)
  EndIf

  Move_ \win\RPort, xpos, \font\tf_Baseline
  Text_ \win\RPort, &icon, FLen(icon)

  If state = On
    SetSoftStyle_ \win\RPort, #FS_NORMAL, #FSF_BOLD
  EndIf
End Statement


#STATUS_REDRAW     = -1
#STATUS_SCROLLERS  = 1
#STATUS_MEMORY     = 2
#STATUS_CURSOR     = 4
#STATUS_ADDITIONAL = 8
#STATUS_MODIFIER   = 16

Statement PED_UpdateStatusArea{@statusmode.w}
SHARED sourceWindow, ped, AB3Pen()
SHARED oldSourceChanged.w

  ;log_Print{"UpdateStatusArea: " + Binw$(statusmode)}
  If ped\ptrCurrentSourceData = 0
    error{"no sourcecontext available!"}
  EndIf

  USEPATH ped\ptrCurrentSourceData

  If \SourceChanged  <> oldSourceChanged
    oldSourceChanged = \SourceChanged
    statusmode = #STATUS_REDRAW
  EndIf

  ;-- redraw everything
  If statusmode = #STATUS_REDRAW
    PED_DrawStatusArea{}
  EndIf

  ;-- update Scrollers
  If !checkOption{statusmode,#STATUS_CURSOR|#STATUS_SCROLLERS}
    ;log_Print{"updating scrollers"}
    slider_top.l     = \DisplayLineOffset
    slider_total.l   = \TotalLines
    slider_visible.l = sourceWindow\visibleLines
    ;/ scale
    If slider_total > 0
      If slider_total >= #max_slider_res
        !mul48f{slider_visible,#max_slider_res,slider_total,slider_visible}  : If slider_visible<1 Then slider_visible=1
        !mul48f{slider_top    ,#max_slider_res,slider_total,slider_top}
        slider_total   = #max_slider_res
      EndIf
      SetGadgetAttrsA_ sourceWindow\vertiprop,sourceWindow\win,0,Tags(@@
                                              #PGA_Total,   slider_total,@@
                                              #PGA_Top,     slider_top,@@
                                              #PGA_Visible, slider_visible,@@
                                              #TAG_END,0)
    EndIf

    SetGadgetAttrsA_ sourceWindow\horizprop,sourceWindow\win,0,Tags(@@
                                              #PGA_VertPot,   -1,@@
                                              #PGA_VertBody,  1,@@
                                              #PGA_HorizPot,  \Column,@@
                                              #PGA_HorizBody, sourceWindow\visibleColumns / #MAX_Columns,@@
                                              #PGA_Top,       \ColumnsOffset + \Column,@@
                                              #PGA_Total,     #MAX_Columns,@@
                                              #TAG_END,0)
  EndIf

  ;-- print current cursorposition
  If !checkOption{statusmode,#STATUS_CURSOR|#STATUS_SCROLLERS}
    actualLine.l = \DisplayLineOffset + \DisplayLine + 1
    actualColumn.w = \ColumnsOffset + \Column + 1

    Format "000000"
    formatstr.s = Right$(Str$(actualLine), 6) : PED_PrintStatus{formatstr,18}
    Format "000"
    formatstr = Right$(Str$(actualColumn), 3) : PED_PrintStatus{formatstr,3}
    Format ""
  EndIf

  ;-- print memory data
  If !checkOption{statusmode,#STATUS_MEMORY}
    ;log_Print{"printing memory data"}
    availchip.l = AvailMem_(#MEMF_CHIP) / 1024
    availfast.l = AvailMem_(#MEMF_FAST) / 1024
    Format "###0,000"
    availmem.s = "CHIP " + StripLead$(Str$(availchip),@" ") + "kb"
    availmem + " | FAST " + StripLead$(Str$(availfast),@" ") + "kb"
    Format ""
    PED_PrintStatus{availmem,FLen(availmem),2}
  EndIf

  ;-- print additional datas
  PED_ShowStatusSymbol{"D",2,ped\debugMode}
  PED_ShowStatusSymbol{"T",1,ped\doTokenize}
End Statement


Statement PED_SwitchCursor{}
SHARED sourceWindow, ped, pedconfig, AB3Pen()
USEPATH sourceWindow

  ;-- if cursor is disabled and the cursor state is on,
  ;-- we shall be able to remove the cursor but do not paint it anymore
  If \cursorEnabled OR (\cursorEnabled = False AND \cursorState = On)

    ;-- maybe obsolete?
    If ped\ptrCurrentSourceData\DisplayLine > sourceWindow\visibleLines-1
      ped\ptrCurrentSourceData\DisplayLine = sourceWindow\visibleLines-1
    EndIf

    ;-- set the style of the cursor
    Select pedconfig\cursorStyle
    Case #AB3_cursorStyle_line
      xmin.w = \BoxLeft + \font\tf_XSize * ped\ptrCurrentSourceData\Column
      ymin.w = \BoxTop  + \font\tf_YSize * ped\ptrCurrentSourceData\DisplayLine
      xmax.w = xmin + 1
      ymax.w = ymin + \font\tf_YSize - 1

    Case #AB3_cursorStyle_underline
      xmin.w = \BoxLeft + \font\tf_XSize * ped\ptrCurrentSourceData\Column
      ymin.w = \BoxTop  + \font\tf_YSize * ped\ptrCurrentSourceData\DisplayLine + \font\tf_YSize - 1  - 1
      xmax.w = xmin + \font\tf_XSize - 1
      ymax.w = ymin + 1

    Default
      xmin.w = \BoxLeft + \font\tf_XSize * ped\ptrCurrentSourceData\Column
      ymin.w = \BoxTop  + \font\tf_YSize * ped\ptrCurrentSourceData\DisplayLine
      xmax.w = xmin + \font\tf_XSize - 1
      ymax.w = ymin + \font\tf_YSize - 1
    End Select

    \cursorState = NOT \cursorState
    If \cursorState = On
      \cursorX1 = xmin
      \cursorY1 = ymin
      \cursorX2 = xmax
      \cursorY2 = ymax
    Else
      xmin = \cursorX1
      ymin = \cursorY1
      xmax = \cursorX2
      ymax = \cursorY2
    EndIf

    ;-- switch the cursorstate, if dimensions are valid
    If (xmax > xmin) AND (ymax > ymin)
      SetAPen_ \win\RPort, AB3Pen(#AB3_screenshine)
      \rp\Mask = %1
      RectFill_ \rp, xmin, ymin, xmax, ymax
      \rp\Mask = -1      
    Else
      log_Print{"illegal area for draw cursor",#log_error}
    EndIf
  EndIf
End Statement

Statement PED_CursorOn{}
SHARED sourceWindow
  If sourceWindow\cursorEnabled
    log_Print{"CURSOR: double ON!"}
  Else
    sourceWindow\cursorEnabled = True
    PED_SwitchCursor{}
  EndIf
End Statement

Statement PED_CursorOff{}
SHARED sourceWindow
  If NOT sourceWindow\cursorEnabled
    log_Print{"CURSOR: double OFF!"}
  EndIf
  sourceWindow\cursorEnabled = False
  PED_SwitchCursor{}
End Statement


Function.b PED_CheckLabelRelevance{testString.s}
SHARED ped

  tmppos.w = 1
  While Mid$(testString,tmppos,1) = " "
    tmppos + 1
  Wend
  Repeat
    tmpchar.b = Asc(Mid$(testString,tmppos,1))
    If tmpchar = ped\labelIdentifier Then Function Return True
    If tmpchar = @";" Then Function Return True    ; ";"
    If tmpchar = $80
      If Asc(Mid$(testString,tmppos+1,1))= $2d OR Asc(Mid$(testString,tmppos+1,1)) = $ae ; Token "Stop" or Token "TRAP"
        Function Return True
      EndIf
    EndIf
    tmppos + 1
  Until tmpchar <= 0
  Function Return False
End Function


Function.s PED_ConvertASM{textline.s}
;  log_Print{">>" + textline}

  txtlen.w = FLen(textline)
  If txtlen > 0
    incomment.b = False
    instring.b = False
    converted.s = ""
    txtpos.w = 0
    curchar.b = 0
    prevchar.b = 0
    If PeekUB(&textline) = @"."
      converted = "'l"
      txtpos + 1
      Goto ln1
    EndIf

    Repeat
      If Peeks$(&textline + txtpos,2) = "\@"
        converted + "'l"
        txtpos + 2
        asmexit.b = False
        Repeat
          curchar = PeekUB(&textline + txtpos)
          If curchar = @" " OR curchar = @":" OR curchar = 0
            asmexit = True
          Else
            converted + Chr$(curchar)
            txtpos + 1
          EndIf
        Until asmexit
        converted + "l`@ "
      EndIf
      ln1:

      prevchar = curchar
      curchar = PeekUB(&textline + txtpos)

      If curchar <> 0
        ; check for string or comment
        If curchar = @";" Then incomment = True
        If curchar = $22 Then instring = NOT instring

        If instring = False AND incomment = False
          If curchar = @"."
            If prevchar = @"," OR prevchar = @" "
              converted + "'"
              curchar = @"l"
            EndIf
          EndIf

          If curchar = @"\"
            curchar = @"`"
          EndIf

          If prevchar <> @"_"
            curlong.l = Peek.l(&textline + txtpos)
            If curlong = @"grap" Then converted + "_"
            If curlong = @"dosb" Then converted + "_"
            If curlong = @"intu" Then converted + "_"
            If curlong = @"Free" Then converted + "_"
            If curlong = @"Wait" Then converted + "_"
          EndIf

          ; "endm"
          tmpstr.s = Peeks$(&textline + txtpos,4)
          If tmpstr = "endm" OR tmpstr = "ENDM"
            tmpchar.b = Peek.b(&textline + txtpos + 4)
            If tmpchar = @" " OR tmpchar = @";" OR tmpchar = 0
              converted + "end macro"
              txtpos + 3
              Goto exitme
            EndIf
          EndIf

          ; " macro"
          tmpstr.s = Peeks$(&textline + txtpos,6)
          If tmpstr = " macro" OR tmpstr = " MACRO"
            tmpchar.b = Peek.b(&textline + txtpos + 6)
            If tmpchar = @" " OR tmpchar = @";" OR tmpchar = 0
              converted = "macro "
              ; append the macro name behind the macro-token
              converted + Peeks$(&textline, txtpos)
              txtpos + 5
              Goto exitme
            EndIf
          EndIf

          ; "movem"
          ;tmpstr.s = Peeks$(&textline + txtpos,5)
          ;If tmpstr = "movem" OR tmpstr = "MOVEM"
          ;  log_Print{"todo: convert movem..."}
          ;EndIf
        EndIf
        converted + Chr$(curchar)
exitme:
      EndIf
      txtpos + 1
    Until txtpos => txtlen OR curchar = 0

    ;log_Print{"<<" + converted}
    textline = converted
  EndIf
  Function Return textline
End Function

Function.b PED_ReadFileCache{}
SHARED ped, readcache

  log_Print{"read file to cache ..."}
  If ped\sourceFileHandle  = 0
    error{"No file handle set!!"}
    Function Return False
  EndIf

  readcache\mode = $00

  readcache\filehandle = ped\sourceFileHandle            ; file
  readcache\blocklen   = $2000                           ; length
  readcache\bufferoffset = 0

  If readcache\readlen <= 0                              ; no file yet!
    ExamineFH_ readcache\filehandle,readcache\fib
    readcache\filelen = readcache\fib\fib_Size
    If readcache\filelen > readcache\cachelen
      If readcache\cacheptr Then FreeVec_ readcache\cacheptr
      readcache\cacheptr = AllocVec_(readcache\filelen,#MEMF_ANY)
      readcache\cachelen = readcache\filelen
    End If

    readcache\readlen = Read_ (readcache\filehandle,readcache\cacheptr,readcache\filelen)
    readcache\offset = 0
  End If

  readcache\chunklen = readcache\blocklen
  If readcache\chunklen > readcache\readlen-readcache\offset Then readcache\chunklen = readcache\readlen-readcache\offset

  If readcache\chunklen > 0
    CopyMem_ readcache\cacheptr + readcache\offset,readcache\bufferptr,readcache\chunklen
    readcache\offset + readcache\chunklen
    Function Return True
  Else
    readcache\chunklen = 0
    readcache\readlen = 0
    Function Return False
  End If
End Function

Function.b PED_ReadClipboard{}
SHARED ped,readcache

  ;log_Print{"read from clipboard", #log_debug}
  readcache\mode = $FF : readcache\cb_eol = False
  readcache\chunklen = -1
  readcache\bufferoffset = 0
  If readcache\cH = Null Then readcache\cH = clipboard_Open{0} : readcache\cb_linecount = 0 ; open clipboard and reset line count

  If readcache\cH
    clipboard_text.s = ""
    If clipboard_HasMoreLines{readcache\cH}
      clipboard_text.s = clipboard_GetNextLine{readcache\cH}
      quoted.w = False
      comment.w = False
      For n.l = 0 To FLen(clipboard_text) - 1
        cchar.w = Peek.b(&clipboard_text+n) & $FF
        If cchar = $22 Then quoted = 1-quoted ; detect quotes
        If quoted=False AND cchar=@";" Then comment = True
        If cchar = $a0 Then cchar = @" "      ; non-breaking space => standard space
        If cchar > 127 AND quoted=False AND comment=False Then cchar = @"?"  ; replace non-ASCII characters with ?, if not in string
        Poke.b &clipboard_text+n,cchar
      Next
      ;log_Print{"cbline: " + clipboard_text}
      ;log_Print{"first char: " + Str$(Peek.b(&clipboard_text))}
      ;log_Print{"cblen: " + Str$(FLen(clipboard_text))}

      readcache\chunklen = FLen(clipboard_text) ; put this line to copy buffer
      If readcache\chunklen > 0 Then CopyMem_ &clipboard_text,readcache\bufferptr,readcache\chunklen
      readcache\cb_linecount + 1

    Else
      ;log_Print{"clipboard empty."}
      clipboard_Free{readcache\cH}
      readcache\cH = Null
      readcache\cb_linecount = 0
      readcache\cb_eol = True
      readcache\chunklen = -1
    End If
  End If

  If readcache\chunklen = -1
    Function Return False
  Else
    Function Return True
  EndIf
End Function

Function.b PED_ReadNextByte{}
SHARED ped,readcache

  morebytes.b = True
  readcache\currentbyte = 0

  Repeat
    readcache\chunklen - 1

    If readcache\chunklen >=0
      readcache\currentbyte = Peek.b(readcache\bufferptr + readcache\bufferoffset)
      readcache\bufferoffset + 1
      readcache\moreBytes = True
      Function Return True
    Else
      If readcache\mode = $00
        morebytes = PED_ReadFileCache{}
      Else
        morebytes = PED_ReadClipboard{}
      EndIf
    EndIf
  Until morebytes = False

  readcache\moreBytes = morebytes
  Function Return morebytes
End Function

Function.s PED_ReadNextLine{}
SHARED ped,readcache

  resultString.s = "NoCOntenTwasDelivered"

  If readcache\mode AND readcache\cb_eol Then Function Return resultString

  If PED_ReadNextByte{}
    resultString = ""
    Repeat
      ; this is the EOL of ClipBoard!
      If readcache\currentbyte = $0A Then Function Return resultString
      ; no further bytes left
      If readcache\currentbyte = $00 Then Function Return resultString

      If readcache\currentbyte = $9  Then readcache\currentbyte = $20 ; replace TAB by space

      If readcache\currentbyte <> $0D Then resultString + Chr$(readcache\currentbyte)
    Until NOT PED_ReadNextByte{}
  EndIf

  Function Return resultString
End Function

Function.b PED_StoreSourceLine{*storeLine.sourceLine}
SHARED ped

  If *storeLine = 0 Then Function Return False

  If *storeLine\strLength <> 0
    log_Print{"storing line [" + Str$(*storeLine\strLength) + "]: " + Peek.s(*storeLine + 9)}
    ped\undeleteStrLen = *storeLine\strLength
    CopyMem_ *storeLine + 9, ped\ptrLineUndeleteStore, *storeLine\strLength
  Else
    Function Return False
  EndIf
  Function Return True

End Function

Function.b PED_DeleteSourceLine{*delLine.sourceLine, @docheck.b}
SHARED ped

  If *delLine = 0 Then Function Return False

  If docheck
    tmpStr.s = Peek.s(*delLine + 9)
    If PED_CheckLabelRelevance{tmpStr} Then ped\labelListChanged = True
  EndIf

  PED_FreeMem{*delLine} : Poke.l *delLine, 0
  Function Return True
End Function


Function.l PED_CreateNewSourceLine{newline.s}
SHARED ped

  _strLen.w = FLen(newline)
  If _strLen > #MAX_Columns - 1
    error{"String length too long for a line!"}
    newline = Left$(newline,#MAX_Columns - 2)
    _strLen = #MAX_Columns - 1
  EndIf  

  ;-- add a null byte as string terminator
  newline + Chr$(0)
  _strLen + 1
  
  ;-- allocate memory for new sourceline
  lineaddr.l = PED_AllocMem{9 + _strLen}
  Poke.l lineaddr    ,0        ; clear pointer to prevline
  Poke.l lineaddr + 4,0        ; clear pointer to nextline
  Poke.b lineaddr + 8,_strLen  ; store length of string

  ;-- copy string to new sourceline
  CopyMem_  &newline, lineaddr + 9, _strLen

  ;-- check if there is a label in the new sourceline
  For i.w = 0 To _strLen - 1
    If Peek.b(&newline + i) = ped\labelIdentifier Then ped\labelListChanged = True
  Next i

  Function Return lineaddr
End Function


Function.l PED_ReplaceSourceLine{*oldLine.sourceLine, *newLine.sourceLine}
SHARED ped
  If *oldLine = 0
    log_Print{"ReplaceSourceLine: oldLine is NULL!", #log_error}
    Function Return 0
  EndIf

  *previousLine.sourceLine = *oldLine\previousLine
  If *previousLine
    *previousLine\nextLine = *newLine
    *newLine\previousLine = *previousLine
  EndIf
  *nextLine.sourceLine = *oldLine\nextLine
  If *nextLine
    *nextLine\previousLine = *newLine
  EndIf
  *newLine\nextLine = *nextLine

  If ped\ptrCurrentSourceData\FirstSourceLine = *oldLine Then ped\ptrCurrentSourceData\FirstSourceLine = *newLine
  If ped\ptrCurrentSourceData\LastSourceLine = *oldLine Then ped\ptrCurrentSourceData\LastSourceLine = *newLine
  PED_DeleteSourceLine{*oldLine}
  ped\ptrCurrentSourceData\SourceChanged = $FFFF
  Function Return *newLine
End Function

Function.b PED_ReplaceCurrentSourceLine{*newLine.sourceLine}
SHARED ped
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *currentLine = PED_ReplaceSourceLine{*currentLine, *newLine}
  If *currentLine
    ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine
    Function Return True
  Else
    Function Return False
  EndIf
End Function

Function PED_InsertSourceLine{*newLine.sourceLine}
SHARED ped

   *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
   If *currentLine
    *prevLine.sourceLine = *currentLine\previousLine
    If *prevLine = 0
      ;log_Print{"current line has no previousline, setting newline as new firstline."}
      ped\ptrCurrentSourceData\FirstSourceLine = *newLine
    Else
      *newLine\previousLine = *prevLine
      *prevLine\nextLine = *newLine
    EndIf

    *currentLine\previousLine = *newLine
    *newLine\nextLine = *currentLine
  Else
    log_Print{"as there is no sourceline left, this will be the first and last one."}
    ped\ptrCurrentSourceData\FirstSourceLine = *newLine
    ped\ptrCurrentSourceData\LastSourceLine = *newLine
  EndIf

  ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
  ped\ptrCurrentSourceData\TotalLines + 1
  ped\ptrCurrentSourceData\SourceChanged = $FFFF

  tmpStr.s = Peek.s(*newLine + 9)
  If PED_CheckLabelRelevance{tmpStr} Then ped\labelListChanged = True

  Function Return True

End Function

Function.b PED_CutSourceLine{*sl.sourceLine}                              ; remove the current line out of linked list
SHARED ped
    *prevLine.sourceLine = *sl\previousLine
    *nextLine.sourceLine = *sl\nextLine
    If (*prevLine = 0) AND (*nextLine = 0)
      log_Print{"The sourceline could not been cut!",#log_error}
      Function Return False
    End If

    ;-- clear old references to other lines
    *sl\previousLine = 0
    *sl\nextLine = 0

    ;-- connect previous and next line to cut current line off and update firstline if the firstline has been cut
    If *prevLine <> 0
      *prevLine\nextLine = *nextLine
    Else
      ped\ptrCurrentSourceData\FirstSourceLine = *nextLine
    EndIf
    If *nextLine <> 0 Then *nextLine\previousLine = *prevLine

    ped\ptrCurrentSourceData\TotalLines - 1
    ped\ptrCurrentSourceData\SourceChanged = $FFFF

    Function Return True
End Function

Function.b PED_AppendSourceLine{*workLine.sourceLine, *appendLine.sourceLine}
SHARED ped
  ;-- insert a new line into the linked list, previous/nextLine of *appendLine is null

  ;-- workLine : the line to append the appendLine to
  ;-- appendLine: the line to append after the workLine

  If *workLine = 0
    log_Print{"the given workline has no previousline, setting appendline as first sourceline", #log_warning}
  
    *firstLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
    *appendLine\previousLine = 0
    *appendLine\nextLine = *firstLine
    *firstLine\previousLine = *appendLine
    ped\ptrCurrentSourceData\FirstSourceLine = *appendLine
  Else 
    *oldnextLine.sourceLine = *workLine\nextLine        ; get the old nextline
    If *oldnextLine
      *oldnextLine\previousLine = *appendLine
      *appendLine\nextLine = *oldnextLine
    Else
      ped\ptrCurrentSourceData\LastSourceLine = *appendLine
    EndIf
    *appendLine\previousLine = *workLine
    *workLine\nextLine = *appendLine
  EndIf

  ped\ptrCurrentSourceData\TotalLines + 1
  ped\ptrCurrentSourceData\SourceChanged = $FFFF

  Function Return True
End Statement

Function.b PED_SetCurrentSourceLine{@actualLine.l}
SHARED ped

  If actualLine = -1 
    actualLine.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine
  EndIf

  *currentSourceLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
  While actualLine > 0
    *currentSourceLine = *currentSourceLine\nextLine
    actualLine - 1
  Wend

  ped\ptrCurrentSourceData\CurrentSourceLine = *currentSourceLine
End Function


Function.l PED_GetBlockStartSourceLine{}
SHARED ped

  USEPATH ped\ptrCurrentSourceData
  currentY.l = \DisplayLineOffset + \DisplayLine

  ;log_Print{"currentY: "  + Str$(currentY)}
  ;log_Print{"BlockStartY: "  + Str$(\BlockStartY)}
  If \BlockStartY = currentY Then Function Return \CurrentSourceLine

  *tempLine.sourceLine = \CurrentSourceLine
  If \BlockStartY < currentY
    Repeat
      *tempLine.sourceLine = *tempLine\previousLine
      currentY - 1
    Until currentY = \BlockStartY
  Else
    Repeat
      *tempLine.sourceLine = *tempLine\nextLine
      currentY + 1
    Until currentY = \BlockStartY
  EndIf
  Function Return *tempLine
End Function

Statement PED_CalculateColumnsOffset{}
SHARED ped, sourceWindow
USEPATH ped\ptrCurrentSourceData

  \ColumnsOffset = 0
  If \Column > sourceWindow\visibleColumns
    \Column - sourceWindow\visibleColumns
    \ColumnsOffset = sourceWindow\visibleColumns
    If \Column > sourceWindow\visibleColumns
      \Column - sourceWindow\visibleColumns
      \ColumnsOffset + sourceWindow\visibleColumns
    EndIf
  EndIf
  ;log_Print{"calculated new columnsoffset: " + Str$(\ColumnsOffset)}

End Statement



Function.b CheckChr{char$,table$}
  For i.b = 1 To FLen(table$)
    If char$ = Mid$(table$,i,1)
      Pop If : Pop For
      Function Return True
    End If
  Next i
  Function Return False
End Function

Function.s PED_GetWordAtPos{text$, textX.w, removechars.b, @preproc.b}
SHARED *preProcessor.preprocessor

  tlen.w = FLen(text$)
  If tlen < 2 Then Function Return ""

  If Mid$(text$,textX,1) = "" Then Function Return ""

  If preproc
    ;log_Print{"using preprocessor to find string in source: " + text$}
    result.s = preproc_CropToken{*preProcessor,text$,textX}                         ; works without loaded tokens to
  Else
    If removechars Then checklist.s = " .,+&!|(){}[]<>\\22" Else checklist = ""

    result.s = "" : char.s =""
    cursorpos.w = textX
    nextpos.w = cursorpos
    backpos.w = cursorpos - 1
    Repeat
      result.s = char + result
      char = Mid$(text$,backpos,1)
      backpos - 1
    Until CheckChr{char,checklist} OR (backpos<0)
    char = ""

    Repeat
      result = result + char
      char = Mid$(text$,nextpos,1)
      nextpos + 1
    Until CheckChr{char,checklist} OR (nextpos>(tlen+1))
  EndIf
  Function Return StripLead$(result,@" ")
End Function


Statement PED_ShowMessage{textMessage.s,@target.b,@style.b}
  SHARED pedmessage,sourceWindow,AB3Pen()            ; has to be shared, because on exit of function the variable will be discarded

  If sourceWindow\win

    If target = -1
      SetAPen_ sourceWindow\win\RPort,AB3Pen(#AB3_screenfill)
      RectFill_ sourceWindow\win\RPort, 0,0, sourceWindow\win\GZZWidth,sourceWindow\font\tf_YSize

      If style<>-1
        SetSoftStyle_ sourceWindow\win\RPort,style,style
      ;Else
        ;SetSoftStyle_ sourceWindow\win\RPort,#FSF_BOLD,#FSF_BOLD
      EndIf
      SetAPen_ sourceWindow\win\RPort,AB3Pen(#AB3_screenshine)
      SetBPen_ sourceWindow\win\RPort,AB3Pen(#AB3_screenfill)
      Move_ sourceWindow\win\RPort,0,sourceWindow\font\tf_Baseline
      Text_ sourceWindow\win\RPort,&textMessage,FLen(textMessage)
    Else
      SetWindowTitles_ sourceWindow\win,-1,&textMessage
    EndIf

  EndIf
End Statement


Statement Show_Helpfile{libname$, node$, helpdir$}
  SHARED pedconfig,ped

  If node$ = "" Then node$ = "main"
  commandlineStr.s = " -t " + node$

  If helpdir$ <> ""
    commandlineStr + " -d " + helpdir$
  Else
    commandlineStr + " -d " + pedconfig\helpDir
  EndIf

  If libname$ <> "" Then commandlineStr + " -l " + dos_FilePart{dos_RemExt{libname$}}

  If pedconfig\use_pubscreen
    commandlineStr + " -s " + ped\defaultPubscreenName
  Else
    If pedconfig\clone_wbscreen
      commandlineStr + " -s " + Chr$(34) + ped\defaultScreenTitle + Chr$(34)
    Else
      commandlineStr + " -s Workbench"
    EndIf
  EndIf

  ;-- adjusting the window size
  commandlineStr + " w " + Str$(screen_GetWidth{} / 2) + " h " + Str$(screen_GetHeight{} / 2)

  log_Print{"opening Helpviewer for ["+ libname$ + "/" + node$ + "] ..."}
  log_Print{"commandstring <" + commandlineStr + ">"}

  PED_ShowMessage{"Opening Helpviewer for "+ libname$ + "/" + node$ + " ..."}
  dos_RunCli{dos_AddPart{pedconfig\mainDir,"Tools/AB3HelpViewer"},0,8192,False,commandlineStr}
End Statement

Function.b CheckWindow{title$}
SHARED pedconfig
  found.b = False
  *thisscreen.Screen = Peek.l(Addr Screen(0))
  *conwin.Window = *thisscreen\FirstWindow
  While (*conwin <> 0)
    If Peek.s(*conwin\Title) = pedconfig\console_title
      found = True
    Else
      *conwin = Peek.l(*conwin)
    EndIf
  Wend
  Function Return found
End Function

Function.l PED_GetNewtypeByName{newtypename.s}
SHARED *newtypebase

  *nt.l = 0

  If *newtypebase = 0
    error{"No newtypebase-Pointer available!"}
  Else
    newtypename = Trim$(newtypename)
    log_Print{"GetNewtypeByName [" + newtypename + "]"}
    found.b = False
    *nt = Peek.l(*newtypebase)
    While *nt AND NOT found
      If Peek.s(*nt + 11) = newtypename
        found = True
      Else
        *nt = Peek.l(*nt)
      EndIf
    Wend
  EndIf
  Function Return *nt

End Function

Function.l PED_GetVariableByName{varname.s}
SHARED *varbase

  *vb.l = 0

  If *varbase = 0
    error{"No varbase-Pointer available!"}
  Else
    varname = Trim$(StripLead$(varname, @"*"))
    log_Print{"GetVariableByName [" + varname + "]"}
    found.b = False
    *vb.l = Peek.l(*varbase)
    While *vb AND NOT found
      If Peek.s(*vb + $13) = varname
        found = True
      Else
        *vb = Peek.l(*vb)
      EndIf
    Wend
  EndIf
  Function Return *vb

End Function


Function.s PED_GetNewtypeOf{varname.s}
  *var.l = PED_GetVariableByName{varname}
  If *var
    ntp.l = Peek.l(*var + 10)            ; get the newtype-pointer of that var
    If ntp
      Function Return Peek.s(ntp + $b)    ; get the newtype-name of that var
    End If
  EndIf
End Function



Function.l PED_GetConstantByName{constname.s}
SHARED *constantbase

  *cb.l = 0

  If *constantbase = 0
    error{"No contantbase-Pointer available!"}
  Else
    log_Print{"GetConstantByName [" + constname + "]"}
    found.b = False
    *cb.l = Peek.l(*constantbase)
    While *cb AND NOT found
      If Peek.s(*cb + $13) = constname
        found.b = True
      Else
        *cb = Peek.l(*cb)
      EndIf
    Wend
  EndIf
  Function Return *cb

End Function

Function.l PED_GetConstantValue{constname.s}
  *cb.l = PED_GetConstantByName{constname.s}
  If *cb
    Function Return Peek.l(*cb + 8)
  EndIf
End Function



Function.s PED_GetDefinitionOf{varname.s}
SHARED ped
  ; search all previous code if we can find a definition for the current varname
  ; a definition may be a DEFTYPE-command or an indirect type definition by using the type extention at the first time

  log_Print{"searching type for variable [" + varname + "]"}
  If Trim$(varname)="" Then Function Return ""

  typename.s = ""

  *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine\previousLine
  While *tempLine
    lineAddr.l = *tempLine + 9
    lineStr.s = Peek.s(lineAddr)

    runner.w = 0 : deftype_found.b = False
    While Peek.b(lineAddr + runner) <> 0
      actlong.l = Peek.l(lineAddr + runner)
      actword.l = actlong LSR 16
      ;log_Print{Hexw$(actword) + " " + Hexw$(#TOKEN_DEFTYPE)}
      If actword = #TOKEN_DEFTYPE
        log_Print{"DEFTYPE!"}
        deftype_found = True
        runner + 2
      Else
        runner + 1
      EndIf

      ; search for the first character of the varname in the current line
      If Peek.b(lineAddr + runner) = Peek.b(&varname)
        ;If runner - 10 > 0
          ; check if variable has an "," or " "
          If Peek.b(lineAddr + runner-1) = @"," OR Peek.b(lineAddr + runner-1) = @" "
            If Peeks$(lineAddr + runner, FLen(varname)) = varname ;AND !IsIllegalChar{Peek.b(lineAddr + runner + FLen(varname) + 1)}

              runner + FLen(varname)
              While Peek.b(lineAddr + runner) = @" "
                runner + 1
              Wend
              If deftype_found
                runner.w = Instr(lineStr,".") - 1
                If runner < 0
                  error{"DEFTYPE without . found!"}
                  Pop While : Goto move2nextline
                EndIf
              EndIf
              If Peek.b(lineAddr + runner) = @"."
                runner + 1
                While !IsIllegalChar{Peek.b(lineAddr + runner)} = 0
                  typename + Chr$(Peek.b(lineAddr + runner))
                  runner + 1
                Wend
                Pop While : Pop While : Function Return typename
              Else
                Pop While : Goto move2nextline
              EndIf
            EndIf
          EndIf
        ;EndIf
      EndIf
    Wend
    move2nextline:
    *tempLine = *tempLine\previousLine
  Wend
End Function


#DEFBROWSER_RESET = 0
#DEFBROWSER_RESETTYPELIST = 1
#DEFBROWSER_SELECTTYPE = 2
#DEFBROWSER_NEWTYPE = 10
#DEFBROWSER_VARIABLE = 20
#DEFBROWSER_CONSTANT = 30

Function.b PED_UpdateDefinitionBrowser{action.b, @defname.s,@openwin.b}
SHARED *newtypebase, *varbase, *constantbase
SHARED wtemp, ped, AB3Pen()
SHARED lev, newtype_found, quicktype, pos$(), postype$()

  log_Print{"UpdateDefinitionBrowser action [" + Str$(action) + "], string [" + Str$(defname) + "]"}

  ;-- optionally open window if requested
  If openwin = -1
    If NOT WZ_IsOpen{"WIN_NEWTYPE"}
      log_Print{"opening definitionbrowser."}
      USEPATH wtemp
      WZWindow WZID("WIN_NEWTYPE"),?wzgui,255,\type_x,\type_y,\type_w,\type_h,WZID("WIN_NEWTYPE")
      WZ_AddMenuStrip{"WIN_NEWTYPE", ped\menuStrip}
      If Peek.l(*varbase) = 0
          WTitle "Compile the source to see all data!"
      EndIf
      Gosub activatesourcewindow
    EndIf
  EndIf
  If NOT WZ_IsOpen{"WIN_NEWTYPE"} Then Function Return False
  Use Window WZID("WIN_NEWTYPE")

  ;-- switch to correct view
  defmode.b = ped\definitionMode
  If action = #DEFBROWSER_NEWTYPE OR action = #DEFBROWSER_SELECTTYPE OR action=#DEFBROWSER_RESETTYPELIST
    defmode = 2
  EndIf
  If action = #DEFBROWSER_NEWTYPE Then action = #DEFBROWSER_SELECTTYPE
  If action = #DEFBROWSER_NEWTYPE Then action = #DEFBROWSER_SELECTTYPE
  If action = #DEFBROWSER_RESET Then defmode = 0
  If action = #DEFBROWSER_CONSTANT Then defmode = 0
  If action = #DEFBROWSER_VARIABLE Then defmode = 1

  If (ped\definitionMode <> defmode) OR (ped\lastStructLevel <> lev)
    If (ped\definitionMode <> defmode)
      log_Print{"setting new definitionmode: " + Str$(defmode) + ", was " + Str$(ped\definitionMode)}
    EndIf
    If (ped\lastStructLevel <> lev)
      log_Print{"setting new structlevel: " + Str$(lev) + ", was " + Str$(ped\lastStructLevel)}
    EndIf
    ped\lastStructLevel = lev

    WZ_KillTable{"TYPETABLE"}
    Use Window WZID("WIN_NEWTYPE")

    Select defmode
    Case 0
      WZPrint "newtype_const",1
      WZPrint "newtype_var",0
      WZPrint "newtype_struct",0
      WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
      WZ_SetTableTitle{"TYPETABLE","Identifier","Value"}
      WZ_SetTableColors{"TYPETABLE",1,0,1,0}
      WZ_SetPriority{"TYPETABLE",2,1}
      WZ_DrawTable{"TYPETABLE"}

    Case 1
      WZPrint "newtype_const",0
      WZPrint "newtype_var",1
      WZPrint "newtype_struct",0
      WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",2}
      WZ_SetTableTitle{"TYPETABLE","Identifier","Value"}
      WZ_SetTableColors{"TYPETABLE",1,0,1,0}
      WZ_SetPriority{"TYPETABLE",2,1}
      WZ_DrawTable{"TYPETABLE"}

    Case 2
      WZPrint "newtype_const",0
      WZPrint "newtype_var",0
      WZPrint "newtype_struct",1
      If action  = #DEFBROWSER_RESETTYPELIST OR action = #DEFBROWSER_RESET Then lev = 0
      If lev = 0
        WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",1}
        WZ_SetTableTitle{"TYPETABLE","Identifier"}
        WZ_SetTableColors{"TYPETABLE",1,0,1,0}
        WZ_DrawTable{"TYPETABLE"}
      Else
        WZ_InitTable{"WIN_NEWTYPE","TYPETABLE",3}
        WZ_SetTableTitle{"TYPETABLE","Identifier","Type","Offset"}
        WZ_SetTableColors{"TYPETABLE",1,0,1,0}
        WZ_SetPriority{"TYPETABLE",3,2,2}
        WZ_DrawTable{"TYPETABLE"}
      EndIf
    End Select

    ;WZPrint "LABEL_PAGE",0
    ped\definitionMode = defmode
  EndIf

  ;WZPrint "NEWTYPE_ENTRY",&defname
  If action = #DEFBROWSER_RESET OR action = #DEFBROWSER_RESETTYPELIST Then defname = ""
  If defname <> WZGetString("STRING2")
    WZPrint "STRING2",&defname
    If defmode = 2 Then action = #DEFBROWSER_SELECTTYPE
  EndIf

  If FLen(defname) > 2
    InitArgParse defname
    word1$ = NextArg$
    word2$ = NextArg$
  EndIf

  Select defmode
  Case 0 ; constantlist
    If word1$ <> ""
      WZ_ClearTable{"TYPETABLE"}

      *cb.l = *constantbase
      If *cb
        *cb = Peek.l(*cb)
        While *cb
          constName.s = Peek.s(*cb + $13)
          ;-- for performance reasons, we should not list *all* constants
          ;-- as this maybe alot(!) of data
          If Instr(constName, word1$)
            If Instr(constName, word2$)
              WZ_AddRow{"TYPETABLE",constName,"$" + Hex$(Peek.l(*cb + 8))}
            EndIf
          EndIf
          *cb = Peek.l(*cb)
        Wend
      Else
        error{"constantbase = NULL => GURU!!!"}
      EndIf

      WZ_TableSort{"TYPETABLE",1}
      WZ_UpdateTable{"TYPETABLE"}
    EndIf

  Case 1 ; variableslist
    WZ_ClearTable{"TYPETABLE"}
    If *varbase
      *vb.l = Peek.l(*varbase)
      While *vb
        varName.s = Peek.s(*vb + $13)
        If Peek.w(*vb + 6) AND 2 Then arr$ = "()" Else arr$ = ""
        If Peek.w(*vb + 6) AND 1 Then poin$ = "*" Else poin$ = ""
        If word1$ <> ""
          If Instr(varName, word1$)
            If Instr(varName, word2$)
              it.l = Peek.l(*vb + 10)
              WZ_AddRow{"TYPETABLE",poin$ + varName + arr$, Peek.s(it + $b)}
            EndIf
          EndIf
        Else
          it.l = Peek.l(*vb + 10)
          WZ_AddRow{"TYPETABLE",poin$ + varName + arr$, Peek.s(it + $b)}
        EndIf
        *vb = Peek.l(*vb)
      Wend
    Else
      error{"*varbase = NULL => GURU!!!"}
    EndIf
    WZ_TableSort{"TYPETABLE",1}
    WZ_UpdateTable{"TYPETABLE"}

  Case 2
    log_Print{"action " + Str$(action)}
    Select action
    Case #DEFBROWSER_RESETTYPELIST
      WZ_ClearTable{"TYPETABLE"}
      *nt.l = *newtypebase
      If *nt
        *nt = Peek.l(*nt)
        While *nt
          WZ_AddRow{"TYPETABLE", Peek.s(*nt + 11)}
          *nt = Peek.l(*nt)
        Wend
      Else
        error{"newtypebase = NULL => GURU!!!"}
      EndIf
      WZ_UpdateTable{"TYPETABLE"}

    Case #DEFBROWSER_SELECTTYPE
      If *newtypebase = 0
        error{"newtypebase = NULL => GURU!!!"}
      Else
        log_Print{"action SELECTTYPE for [" + defname + "]"}

        ;-- updating type path
        postype$(lev) = defname
        If lev > 1
          pos$(lev) = ped\previousNewtypeStr
        Else
          pos$(lev) = defname
        EndIf
        typestr.s = ""
        For i.b = 1 To lev
          If i > 1
            typestr + "\" + pos$(i)
          Else
            typestr + "." + pos$(i)
          EndIf
        Next
        WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
        WZPrint "NEWTYPE_ENTRY",&typestr

        ;-- building types list
        WZ_ClearTable{"TYPETABLE"}
        *nt = *newtypebase
        If lev
          log_Print{"seaching for base type [" + postype$(lev) + "]"}
          *nt = Peek.l(*nt)
          While *nt
            If Peek.s(*nt + 11) = postype$(lev)
              log_Print{"type definition [" + postype$(lev) + "] found, building types list for it"}

              *nt3.l = Peek.l(*nt + 4)
              While *nt3
                If Peek.w(*nt3 + 6) = 1 Then b$ = "*" Else b$ = ""
                b$ = b$ + Peek.s(*nt3 + 15)
                c$ = Peek.s(Peek.l(*nt3 + 10) + 11)
                ;If Instr(b$,word1$) Then If Instr(b$,word2$)
                nt_value.w = Peek.w(*nt3 + 4)
                nt_displayvalue.s = "$" + Right$(Hex$(nt_value),4) + "(" + Str$(nt_value) + ")"
                ;nt_displayvalue.s = Str$(nt_value)
                WZ_AddRow{"TYPETABLE",b$,c$,nt_displayvalue}
                ;End If
                b$ + "  ." + c$
                *nt3 = Peek.l(*nt3)
              Wend
              *nt = 0 : Goto out2
            EndIf
            *nt = Peek.l(*nt)
            out2
          Wend
          WZ_TableSort{"TYPETABLE",3}
        Else
          log_Print{"searching for type with word1$[" + word1$ + "], word2$["+word2$ + "]"}
          *nt = Peek.l(*nt)
          While *nt
            b$ = Peek.s(*nt + 11)
            If Instr(b$,word1$)
              If Instr(b$,word2$)
                WZ_AddRow{"TYPETABLE",b$,""}
                newtype_found = newtype_found + 1
                f$ = b$
              EndIf
            EndIf
            *nt = Peek.l(*nt)
          Wend
          WZ_TableSort{"TYPETABLE",1}
        EndIf
        WZ_UpdateTable{"TYPETABLE"}
      EndIf

    Default
      log_Print{"no action for newtypes list called"}
    End Select

    ;lev.l = 0
    ;newtype_found.l = 0
    ;Gosub definitionbrowser_SelectType
    ;lev = 1

    ;*nt.l = *newtypebase
    ;If *nt
    ;  *nt = Peek.l(*nt)
    ;  While *nt
    ;    If Peek.s(*nt + 11) = defname
    ;      quicktype = 1 : Gosub definitionbrowser_ListSubType
    ;      newtype_found = 1 : Pop If : Pop While : Goto f1ab
    ;    EndIf
    ;    *nt = Peek.l(*nt)
    ;  Wend
    ;EndIf
    ;quicktype = 0
    ;f1ab:
  End Select
End Function

Function.s PED_GetLibname{libnum.w}
  SHARED blitzlibMapping()
  If libnum > 255 OR libnum < 0
    libname.s = ""
    Select libnum
    Case #varslib         : libname = "varslib"
    Case #wbstartuplib    : libname = "wbstartuplib"
    Case #memlib          : libname = "memlib"
    Case #intlib          : libname = "intlib"
    Case #switchlib       : libname = "switchlib"
    Case #runerrlib       : libname = "runerrlib"
    Case #arrayslib       : libname = "arrayslib"
    Case #staticslib      : libname = "staticslib"
    Case #strings1lib     : libname = "strings1lib"
    Case #strings2lib     : libname = "strings2lib"
    Case #exitslib        : libname = "exitslib"
    Case #ffplib          : libname = "ffplib1"
    Case #lmullib         : libname = "lmullib"
    Case #ldivlib         : libname = "ldivlib"
    Case #clrlib          : libname = "clrlib"
    Case #datalib         : libname = "datalib"
    Case #strcomplib      : libname = "strcomplib"
    Case #maxslib         : libname = "maxslib"
    Case #maxlenlib       : libname = "maxlenlib"
    Case #chipbaselib     : libname = "chipbaselib"
    Case #floatquicklib   : libname = "floatquicklib"
    Case #modlib          : libname = "modlib"
    Case #debuglib        : libname = "debuglib"
    Case #rundebuglib     : libname = "rundebuglib"
    Case #errtraplib      : libname = "errtraplib"
    Default
      libname = "unknown syslib #" + Str$(libname)
    End Select
    Function Return libname
  Else
    Function Return blitzlibMapping(libnum,0)
  EndIf
End Function

Function.s PED_GetFirstTokenname{libnum.w}
  SHARED blitzlibMapping()
  If libnum > 255
    error{"Couldnot get Token of a syslib!"}
  Else
    Function Return blitzlibMapping(libnum,1)
  EndIf
End Function


Function.w FAST PED_GetToken{toknameptr.l}
SHARED *tokenbase

  *token.tokendata = *tokenbase
  log_Print{"search for: " + Peek.s(toknameptr)}
  log_Print{".." + Peek.s(&*token\dat)}
  While *token

    If Peek.s(toknameptr) = Peek.s(&*token\dat)
      Pop If : Pop While : Function Return *token\number
    EndIf
    *token = *token\next_token
  Wend
End Function

Function.s PED_GetTokenName{tokenNumber.l}
SHARED *tokenbase, ped

  ;-- search in tokencache
  _tn.w = (tokenNumber BitClr $F) AND $FFFF
  _libnum.w = _tn LSR 7
  _entry.w = _tn - (_libnum LSL 7)
  ;log_Print{"searching for token " + Hexw$(_tn) + ": libnum " + Str$(_libnum) + ", entry " + Str$(_entry), #log_debug}

  *token.tokendata = Peek.l(ped\tokenCache + _tn * 4)
  If *token
    ;log_Print{"token " + Hexw$(tokenNumber) + ": " + Peek.s(&*token\dat) + " found in cache.", #log_debug}
    Function Return Peek.s(&*token\dat)
  Else
    *token = *tokenbase
    While *token
      If *token\number = _tn
        ;log_Print{"token " + Hexw$(tokenNumber) + " cached.", #log_debug}
        ;-- add token to tokencache
        Poke.l ped\tokenCache + _tn * 4, *token

        Pop If : Pop While
        Function Return Peek.s(&*token\dat)
      EndIf
      *token = *token\next_token
    Wend
  EndIf
  log_Print{"*** unknown tokennumber " + Hexw$(_tn) + ": libnum " + Str$(_libnum) + ", entry " + Str$(_entry) ,#log_warning}
  Function Return "????Lib "+ Str$(_libnum) + "/" + Str$(tokenNumber AND $7f)
End Function

Function.l PED_GetTokenPointer{tname.s}
SHARED *tokenbase

  tname.s = LCase$(tname.s)

  *token.tokendata = *tokenbase
  While *token
    If LCase$(Peek.s(&*token\dat)) = tname Then Function Return *token
    *token = *token\next_token
  Wend
End Function

Function.w PED_GetTokenLibnum{tname.s}
  *token.tokendata = PED_GetTokenPointer{tname}
  If *token Then Function Return (*token\number LSR 7)
  Function Return -1 ; token not found
End Function

Function.w PED_GetTokenID{tname.s}
  *token.tokendata = PED_GetTokenPointer{tname}
  If *token Then Function Return *token\number
  Function Return -1
End Function

Function.s PED_GetTokenHelp{tname.s}
  *token.tokendata = PED_GetTokenPointer{tname}
  If *token Then Function Return Peek.s(&*token\dat + FLen(tname.s) + 1)
  Function Return ""
End Function

Function.l PED_GetMacroPointer{macname.s}
SHARED *macrobase

  macname.s = StripLead$(LCase$(macname.s),@"!")
  log_Print{"searching for macro [" + macname + "], "+ Hex$(*macrobase)}

  *macroP.l = *macrobase
  While *macroP
    result.s = Peek.s(*macroP + 13)
    If LCase$(result) = macname Then Function Return *macroP
    *macroP = Peek.l(*macroP)
  Wend
  Function Return 0
End Function

Function.s PED_GetMacroName{macname.s}
  *macroP.l = PED_GetMacroPointer{macname}
  If *macroP
    result.s = Peek.s(*macroP + 13)
    Function Return result
  EndIf
  Function Return ""
End Function


Function.s PED_GetMacroHelp{macname.s}
  *macroP.l = PED_GetMacroPointer{macname}
  If *macroP
    maclen.w = Peek.w(*macroP + 8)
    If maclen > 32 Then maclen = 32
    macroP.l = Peek.l(*macroP + 4)
    If macroP Then help.s = StripLead$(Peeks$(macroP,maclen),32)
    help.s = StripLead$(help,@";")
    Function Return help.s
  End If
  Function Return ""
End Function


Function.b PED_CheckForClassicToken{_token.l}
    _libnum.l = _token ASR 7

    ; check for a classic lib
    ccounter.b = 0
    Repeat
      classicID.l = Peek.w(?classiccommands + ccounter)
      If (classicID > 0) AND (classicID = _libnum)
        Pop Repeat:Pop If
        Function Return True
      EndIf
      ccounter + 2
    Until classicID = 0

    ; check for a classic command
    exit_classicloop.b = False
    Repeat
      classicID.l = Peek.w(?classiccommands + ccounter)
      If (classicID > 0) AND (classicID = _token)
        Pop Repeat : Pop If
        Function Return True
      EndIf
      ccounter + 2
    Until classicID = 0 OR exit_classicloop
    Function Return False
End Function


Function.s PED_Tokenize_internal{strLine.s}
SHARED ped

  If FLen(strLine) > #MAX_Columns
    log_Print{"string to tokenize is too long: " + Str$(FLen(strLine)),#log_error}
  Else
    If FLen(strLine) < #MAX_Columns
      strLine = strLine + SPACE$(#MAX_Columns - FLen(strLine))
    EndIf
  EndIf

  GetRegD0 &strLine : MOVE.l D0,-(a7)
  !asm
  MOVE.l (a7)+,D2 : MOVE.l D2,A2      ; pointer to String to parse to be in A2
  JSR tokenize_line
  MOVE.l D5,D0                        ; returns length of string in D5
  !basic  
  outputSize.l = PutRegD0 - 1

  Function Return Peeks$(Peek.l(?comPtr_Temp_TokenString1), outputSize)
End Function

Function.s PED_TokenizeText{strLine.s, @disablePreProc.b}
; -- disablePreProc is used to disable preprocessor in some contexts as preproc
; -- is casesensitive, and so cannot process source that has been entered in PED with wrong cases.
; -- above that, preprocessor cannot process already tokenized source
SHARED ped, pedconfig, *preProcessor, linebuff$

  If FLen(strLine) = 0 Then Function Return ""

  If ped\doTokenize
    If pedconfig\usePreProcessor AND (NOT disablePreProc)
      log_Print{"PED_TokenizeText: using preprocessor [" + strLine + "]", #log_debug}
      byteLength.l = preproc_Tokenize{*preProcessor,&strLine.s, &linebuff$, FLen(strLine)}
      strLine = Peeks$(&linebuff$, byteLength)
    Else
      ;log_Print{"PED_TokenizeText: using internal tokenization [" + strLine + "]",#log_debug}
      strLine = PED_Tokenize_internal{strLine}
    EndIf
  Else
    log_Print{"PED_TokenizeText: tokenization turned off",#log_debug}
  EndIf

  ;log_Print{"tokenized output >" + strLine + "<"}

  Function Return strLine
End Function


Function.s PED_DetokenizeText{strLine.s}
SHARED ped, pedconfig, *preProcessor, linebuff$

  If ped\doTokenize AND ped\noDetokenizing = 0
    _strLen.w = FLen(strLine)
    If _strLen
      If pedconfig\usePreProcessor
        ;-- Function returns a string with a 0a-byte at the end in some conditions!
        byteLength.l = preproc_Detokenize{*preProcessor,&strLine, &linebuff$, FLen(strLine)}
        ;-- remove CR-character
        If Peek.b(&linebuff$ + byteLength-1) = $0A Then byteLength - 1
        strLine = Peeks$(&linebuff$, byteLength)
      Else
        linebuff$ = ""
        If _strLen > 0
          ped\inString = False
          For i.w = 0 To _strLen - 1
            curChar.b  = Peek.b(&strLine + i)
            ;-- check if we are in a string
            If curChar = $22 Then ped\inString = NOT ped\inString
            
            ;-- we found a token if the byte is negative?
            If ped\inString = 0
              If (curChar < 0)
                _token.l = Peek.w(&strLine + i) AND $FFFF
                _tokname.s = PED_GetTokenName{_token}
                linebuff$ + _tokname
                i + 1 ; skip next byte as it is part of the replaced token
              Else
                If curChar > 0 Then linebuff$ + Chr$(curChar) ; skip the 0 byte at the end
              EndIf
            Else
              linebuff$ + Chr$(curChar)
            EndIf
          Next i
        EndIf
        strLine = linebuff$
      EndIf
    EndIf
  Else
    ;log_Print{"PED_DetokenizeText(): Tokenizing is off"}
  EndIf
  Function Return strLine
End Function

Function.s PED_Detokenize{*sourceLine.sourceLine}
  If *sourceLine = 0 Then Function Return ""
  Function Return PED_DetokenizeText{Peek.s(*sourceLine + 9)}
End Function

Function.b PED_Detokenize2Printbuffer{ptrOrgString.l}
SHARED ped

  ;-- clear textBufferPrint
  ;FillMem ped\ptrTextbufferPrint, #MAX_Columns, 0
  MemCls ped\ptrTextbufferPrint, #MAX_Columns, 0

  _strLen.w = Len(Peek.s(ptrOrgString))
  If _strLen
    If ped\keepString = 0 Then ped\inString = False

    If ped\noDetokenizing
      ;-- just copy the current text line to the printBuffer
      CopyMem_ ptrOrgString, ped\ptrTextbufferPrint, _strLen
    Else
      ;-- detokenize but keep the tokenbit!
      runnerP.w = 0
      For i.w = 0 To _strLen - 1
        curChar.b  = Peek.b(ptrOrgString + i)
        If curChar = $22 Then ped\inString = NOT ped\inString
        If ped\inString = 0 AND (curChar < 0)
          _token.l = Peek.w(ptrOrgString + i)
          _tokname.s = PED_GetTokenName{_token}
          For j.b = 0 To FLen(_tokname)-1
            Poke.b ped\ptrTextbufferPrint + runnerP, Peek.b(&_tokname + j) BitSet 7
            runnerP + 1 ; skip next byte as it is part of the replaced token
          Next j
          i + 1
        Else
          Poke.b ped\ptrTextbufferPrint + runnerP, curChar
          runnerP + 1
        EndIf
      Next i
    EndIf
  EndIf

  Function Return True
End Function

Statement PED_CopyPrintbuffer2Textbuffer{}
SHARED ped, sourceWindow

  ;-- copy current printed line to textbuffer
  tmpColumn.w = ped\ptrCurrentSourceData\Column                           ; save Columnpos as it is changed for process_highlighting

  char.b = Peek.b(ped\ptrTextbufferPrint)
  If char <> 0
    tmpD2.w = 0
    tmpD3.w = 0
    textBufferPos.l = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset
    If char <> ped\labelIdentifier Then Goto jump_into_it
    ;Gosub copy_to_textBuffer
    Poke.b textBufferPos + tmpD2, char
    Repeat
      tmpD2 + 1
      char = Peek.b(ped\ptrTextbufferPrint + tmpD2)
      If char <> 0
jump_into_it:
        ;Gosub copy_to_textBuffer
        Poke.b textBufferPos + tmpD2, char
      End If
    Until char = 0
  EndIf

  ;-- restore Columnposition
  ped\ptrCurrentSourceData\Column = tmpColumn
  Statement Return

.copy_to_textBuffer:
  Poke.b textBufferPos + tmpD2, char
  ;If tmpD2 <= ped\ptrCurrentSourceData\ColumnsOffset
  ;  If tmpD3 <= sourceWindow\visibleColumns
  ;    ped\ptrCurrentSourceData\Column = tmpD3
  ;    tmpD3 + 1
  ;  EndIf
  ;EndIf
  Return
End Statement

;--WIP
NEWTYPE.helpIndexIncludeFileItem
  id.b
  includeFileName.s
End NEWTYPE

NEWTYPE.helpIndexItem
  name.s
  helpText.s
  includeFileName.s
End NEWTYPE
Dim List HelpIndexCache.helpIndexItem(0)

; Begin routines for function PED_BuildHelpIndex{}  ; moved the functions and statemend defination out of the build index rountine for a better overview  tomsmart1
Function.l ab3_IsTokenChar{char.w}
  If char>=@"a" AND char<=@"z" Then Function Return True
  If char>=@"A" AND char<=@"Z" Then Function Return True
  If char>=@"0" AND char<=@"9" Then Function Return True
  If char=@"_" OR char=@"@" OR char=@"`" Then Function Return True
  Function Return False
End Function

Statement writeentry{destfile.l, mode$,instruction$}
SHARED pedconfig

  ;#TOKEN_Function  = $8009
  ;#TOKEN_Statement = $8008
  ;#TOKEN_Object    = $80d7
  ;#TOKEN_Macro     = $800d
  ;#TOKEN_End       = $8002
  ;#TOKEN_Return    = $8007

  ; -- don't add it if it contains @H
  If Instr(instruction$,"@H") Then Statement Return

  ; -- token return found
  If Instr(instruction$,Mki$(#TOKEN_Return)) Then Statement Return

  ; -- token End found
  If Instr(instruction$,Mki$(#TOKEN_End)) Then Statement Return

  startpos.l = 0
  Select mode$
    Case "FUNC"
      startpos = Instr(instruction$,Mki$(#TOKEN_Function))  + 2
      i3.l = Instr (instruction$,".",startpos)
      If (i3 < startpos+5) AND (i3 <> 0)
        startpos = i3+1                              ; change it to 1 to make the test of spaces possible  tomsmart1

         While Mid$(instruction$,startpos,1)<>" "    ; test if we have no space  so it is still the function type (newtype)  tomsmart1
           startpos + 1
         Wend

      End If
      If Instr(instruction$,"FAST",startpos)
        startpos.l = Instr(instruction$,"FAST",startpos)    + 4
      End If

    Case "STAT"
      startpos = Instr(instruction$,Mki$(#TOKEN_Statement)) + 2
      If Instr(instruction$,"FAST",startpos)
        startpos.l = Instr(instruction$,"FAST",startpos)    + 4
      End If

    Case "MACR"
      startpos = Instr(instruction$,Mki$(#TOKEN_Macro))     + 2

  End Select

  ; -- get string positions --
  instruction$ = dos_Trim{Mid$(instruction$,startpos)}

  endpos.l  =1
  stopchar.l=False
  While endpos<=FLen(instruction$) AND stopchar=False
    If ab3_IsTokenChar{Peek.b(&instruction$+endpos-1)}=False Then stopchar=True:Else endpos+1
  Wend

  ; -- write infos to indexfile
  If endpos <> 0
    funcname$ = Mid$( instruction$ , 1 , endpos - 1)
    ;If Right$(funcname$,1)=";" Then funcname$ = UnLeft$(funcname$,1)
    ;funcname$ = StripLead$(Left$(funcname$,50,32),32)
    funcname$ = StripLead$(funcname$,32)

    If FLen(funcname$) >= 6                                   ; test if functionname leng <= 6  tomsmart1
      If Left$(funcname$,6) = "Return" Then Statement Return  ; yes then test if function or statement RETURN then we have nothing to print back again  tomsmart1
    EndIf

    If mode$ = "MACR" Then funcname$ = "!" + funcname$

    description$ = Mid$(instruction$,endpos)
    description$ = StripLead$(description$,32)
    If Left$(description$,1)=";" Then description$ = UnRight$(description$,1)
    description$ = StripLead$(description$,32)

    If (Left$(funcname$,1) = "_") OR (Left$(funcname$,2) = "!_")             ; test for privat routines  tomsmart
      If pedconfig\HelpForPrivateFunctions = True                                   ; test if we show help for it  tomsmart1
        file_WriteLine{destfile, mode$ + "\\09" + funcname$ + "\\09" + description$ + " ; private!"}     ; show help but indentify private routines tomsmart1
      End If
    Else
      ;NPrint LSet$(mode$,11) + LSet$(funcname$,50) + description$
      file_WriteLine{destfile, mode$ + "\\09" + funcname$ + "\\09" + description$}                      ; public routines
    End If

  End If
End Statement

 

Function.l ab3_InstrToken{code.s,token.s}
  pos.l = Instr(code,token)
  If pos
    If ab3_IsTokenChar{Peek.b(&code+pos-1+FLen(token))} Then pos=0
    If pos>1
      If ab3_IsTokenChar{Peek.b(&code+pos-1-1)} Then pos=0
    End If
  End If
  Function Return pos
End Function



Statement scanfile{rootpath$,filename$, destfile.l}
  functoken$      = Mki$(#TOKEN_Function)
  statementtoken$ = Mki$(#TOKEN_Statement)
  objecttoken$    = Mki$(#TOKEN_Object)
  macrotoken$     = Mki$(#TOKEN_Macro)
  endtoken$       = Mki$(#TOKEN_End)
  returntoken$    = Mki$(#TOKEN_Return)
  tok80.s         = Str$($80)
  fid.l = file_Open{dos_AddPart{rootpath$,filename$},#file_read}
  If dos_GetExt{filename$}="bb2" OR dos_GetExt{filename$}="bb"  Then tokenized.l=True : Else tokenized=False

  If fid>=0 ; ReadFile(0,filename$)
    ;file_Cache{fid}
    ;FileInput 0
    ; -- get current path
    ;dir_name$ = SPACE$(512)
    ;GetCurrentDirName_ &dir_name$,FLen(dir_name$)
    ;dir_name$ = StripTrail$(dir_name$,0)
    ;dir_name$ = dos_Trim{dir_name$}
    ;dir_name$ = dos_FilePart{dir_name$}

    ; -- add parent path to filename, if not in includes-drawer
    ;If LCase$(dir_name$)<>"includes" Then filename$ = dos_AddPart{dir_name$,filename$}

    ; -- write filename into indexfile
    file_WriteLine{destfile,"FILE\\09"+filename$}

    Repeat
      ;code.s = ReadLine$
      If tokenized
        code.s = file_ReadBB2Line{fid}
      Else
        code.s = file_ReadLine{fid}
      End If

      maxpos.l = Instr(code,";")
      If maxpos = 0 Then maxpos = FLen(code)-1

      ; in case its ASCII...
      If tokenized=False
        pos.l = ab3_InstrToken{code,"Function"}
        If pos>0 AND pos<maxpos
          ;If Instr(code,"GetObjectBy") Then error{"Found Function in "+filename$+" line:\\n"+code}
          code.s = Left$(code,pos-1) + functoken$ + Right$(code,FLen(code)-pos-8+1)
          If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"Statement"}
        If pos>0 AND pos<maxpos
          code.s = Left$(code,pos-1) + statementtoken$ + Right$(code,FLen(code)-pos-9+1)
          If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"Macro"}
        If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + macrotoken$ + Right$(code,FLen(code)-pos-5+1)
            If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"End "}
        If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + endtoken$ + Right$(code,FLen(code)-pos-3+1)
            If pos<maxpos Then maxpos=pos
        End If

        pos = ab3_InstrToken{code,"Return"}
        If pos>0 AND pos<maxpos
            code.s = Left$(code,pos-1) + returntoken$ + Right$(code,FLen(code)-pos-6+1)
            If pos<maxpos Then maxpos=pos
        End If
      End If

      pos = Instr(code,functoken$)
      If pos>0 AND pos<=maxpos Then writeentry{destfile, "FUNC",code}

      pos = Instr(code,statementtoken$)
      If pos>0 AND pos<=maxpos Then writeentry{destfile, "STAT",code}

      pos = Instr(code,macrotoken$)
      If pos>0 AND pos<=maxpos Then writeentry{destfile, "MACR",code}

    Until file_EOF{fid}
    file_Close{fid}
  Else
    dummy.l = ask{!TRANS{"Can't open file "}+filename$,!TRANS{"Ok"},!TRANS{"Error"}}
  End If
End Statement


Statement PED_CreateHelpIndexTextFile{}
SHARED pedconfig, HelpIndexCache()

  ;-- check if Indexfile is available and delete it
  If dos_Exist{pedconfig\HelpIndexTextFile} Then dos_Delete{pedconfig\HelpIndexTextFile}

  ;-- create a new index text file
  destfid.l = file_Open{pedconfig\HelpIndexTextFile, #file_forcewrite}
  If destfid >= 0
    WZ_ShowMessage{!TRANS{"Updating indexfile for includes onlinehelp..."},0}
  
    CaseSense On

    ClearList HelpIndexCache()

    ;-- scan for subdirs
    NEWTYPE.dirs
      name.s
    End NEWTYPE
    Dim List dirs.dirs(0)

    ClearList dirs()
    If AddLast(dirs()) Then dirs()\name = pedconfig\includeDir

    log_Print{"*** scan includedir <" + pedconfig\includeDir + ">"}
    Repeat
      name$ = dos_ScanDir{pedconfig\includeDir,"",#dos_scan_dirs}
      If dos_IsDir{name$}
        If AddLast(dirs()) Then dirs()\name = dos_AddPart{pedconfig\includeDir,name$}
        log_Print{"found subdir <" + name$ + ">"}
      EndIf
    Until name$ = ""

    ;-- count number of files
    num_files.l = 0
    ResetList dirs()
    While NextItem(dirs())
      dirname$ = dirs()\name                    ; set first subdirectory
      Repeat
        name$ = dos_ScanDir{dirname$,"#?",#dos_scan_files}
        num_files + 1
      Until name$ = ""
    Wend
    log_Print{"counted files: " + Str$(num_files)}

    ;-- scan files for functions
    ;-- begin count include files
    subincludedirs.b = False
    exitscan.b       = True
    dirname$         = ""
    act_file.l = 0
    ResetList dirs()
    act_file.l = 0
    While NextItem(dirs())
      ;--  set first subdirectory
      dirname$ = dirs()\name

      log_Print{"*** scanning dir <" + dirname$ + ">",#log_debug}
      Repeat
        name$ = dos_ScanDir{dirname$,"#?",#dos_scan_files}
        If name$ <> ""
          log_Print{"scanning file <" + name$ + ">"}
          act_file + 1 : act_file = Min(act_file,num_files)
          ex.s = LCase$(dos_GetExt{name$})
          If (ex = "bb" OR ex = "bb2" OR ex = "ab2" OR ex = "ab3")
              scanfile{pedconfig\includeDir,name$, destfid}
          EndIf
          !WZ_Update_Gauge{act_file,num_files}
        End If
      Until name$ = ""
    Wend
    CaseSense Off
    
    ClearList dirs()
    file_Close{destfid}
  EndIf
End Statement


Statement PED_ReadHelpIndexFromTextFile{}
SHARED pedconfig, HelpIndexCache()

  fid.l = file_Open{pedconfig\HelpIndexTextFile, #file_read}
  If fid<>-1
    file_Cache{fid}
    
    row.s = ""
    ClearList HelpIndexCache()
    While file_EOF{fid} = False
      row = file_ReadLine{fid}

      pos_name.l  = Instr(row,"\\09",1)
      If pos_name = 0 Then pos_name = FLen(row) + 1

      pos_desc.l  = Instr(row,"\\09",pos_name + 1)
      If pos_desc = 0 Then pos_desc = FLen(row) + 1

      typ$  = Mid$(row, 1, pos_name - 1)
      name$ = Mid$(row, pos_name + 1 , pos_desc - pos_name - 1)
      help$ = Mid$(row, pos_desc + 1)

      If typ$ <> ""
        If typ$ = "FILE"
          filename$ = name$

        Else

          lowerCase.s = LCase$(name$)
          If name$ <> ""
            If help$ = ""
              Select typ$
                Case "FUNC" : help$ = "{...} ; Function"
                Case "MACR" : help$ = "{...} ; Macro"
                Case "STAT" : help$ = "{...} ; Statement"
                Default     : help$ = typ$
              End Select
            End If
            If AddItem(HelpIndexCache())
              HelpIndexCache()\name  = name$
              HelpIndexCache()\helpText  = help$
              HelpIndexCache()\includeFileName = filename$
            End If
          End If
        End If
      End If
    Wend

    file_Close{fid}
  Else
    error{"Could not open " + pedconfig\HelpIndexTextFile + " for read."}
  End If
End Statement


Statement PED_WriteHelpIndexBinFile{}
SHARED pedconfig, HelpIndexCache()

  If dos_Exist{pedconfig\HelpIndexBinFile} Then dos_Delete{pedconfig\HelpIndexBinFile}

  If OpenFile(1,pedconfig\HelpIndexBinFile)
    ResetList HelpIndexCache()
    While NextItem(HelpIndexCache())
      WriteType 1,HelpIndexCache()
    Wend
    CloseFile 1
  End If
End Statement


Statement PED_LoadHelpIndexBinFile{}
SHARED pedconfig, HelpIndexCache()

  If OpenFile(1,pedconfig\HelpIndexBinFile)
    ClearList HelpIndexCache()
    _lof.l = Lof(1)
    While _lof > Loc(1)
      If AddLast(HelpIndexCache())
        ReadType 1,HelpIndexCache()
      Else
        log_Print{"Could not load HelpfileCache.", #log_error}
        Pop While: Goto exit_while1
      EndIf
    Wend
    exit_while1:
    CloseFile 1
  Else
    log_Print{pedconfig\HelpIndexBinFile + " " + !TRANS{"not found."}, #log_error}
  End If

;  If fidW><-1 Then file_Close{fidW}

End Statement



Statement PED_BuildHelpIndex{}
SHARED pedconfig
  log_Print{"****** Building a new helpIndex file for include functions..."}

  If dos_Exist{pedconfig\includeDir}
    log_Print{"creating help index text file: " + pedconfig\HelpIndexTextFile}

    WZ_ShowMessage{!TRANS{"Creating helpindex text file ..."}}  
    PED_CreateHelpIndexTextFile{}

    WZ_ShowMessage{!TRANS{"Read helpindex from text file ..."}} 
    PED_ReadHelpIndexFromTextFile{}
    
    WZ_ShowMessage{!TRANS{"Saving helpindex bin file ..."}} 
    PED_WriteHelpIndexBinFile{}

    WZ_HideMessage{}
  Else
    dummy.l = ask{!TRANS{"Could not determine Include directory"}+":\\n"+pedconfig\includeDir+"!",!TRANS{"Ok"},!TRANS{"Error"}}
  EndIf
End Statement


#INDEXHELP_NAME = 1
#INDEXHELP_HELP = 2
#INDEXHELP_FILE = 3

Function.s PED_GetIndexHelp{entry.s, entrytype.b}
SHARED HelpIndexCache()

  ResetList HelpIndexCache()
  If NextItemFast(HelpIndexCache()) = False Then Function Return ""

  result.s = ""
  lowerEntry.s = LCase$(entry)
  ResetList HelpIndexCache()
  While NextItemFast(HelpIndexCache()) OR result <> ""
    If LCase$(HelpIndexCache()\name) = lowerEntry
      Select entrytype
      Case #INDEXHELP_NAME : result = HelpIndexCache()\name
      Case #INDEXHELP_HELP : result = HelpIndexCache()\helpText
      Case #INDEXHELP_FILE : result = HelpIndexCache()\includeFileName
      End Select
    End If
  Wend

  Function Return "" 

End Function


Function.s PED_GetHelptextFor{tokname.s}
  If Left$(tokname.s,1) = "!"
    tokname.s = PED_GetMacroName{tokname.s}
    ;tokhelp$ = PED_GetMacroHelp{tokname.s}
    tokexte$ = "Macro"
  Else
    tokid.w = PED_GetTokenID{tokname.s}
    If tokid >= 0
      tokname.s = PED_GetTokenName{tokid}
      libnum.l = PED_GetTokenLibnum{tokname.s}
      If libnum >= 0
        tokhelp$ = PED_GetTokenHelp{tokname.s}
        tokexte$ = "BlitzLib: " + PED_GetLibname{libnum}
      End If
    Else
      tokname.s = PED_GetIndexHelp{tokname.s,#INDEXHELP_NAME}
      If tokname.s <> ""
        tokhelp$ = PED_GetIndexHelp{tokname.s,#INDEXHELP_HELP}
        tokexte$ = "Include: " + PED_GetIndexHelp{tokname.s, #INDEXHELP_FILE}
      End If
    End If
  End If

  strhelp$ = tokname.s
  If tokhelp$ <> "" Then strhelp$ + " " + tokhelp$
  If tokexte$ <> "" Then strhelp$ + " | " + tokexte$

  Function Return strhelp$
End Function


Function.b PED_ShowHelptextFor{tokname.s}
  log_Print{"ShowHelpTextFor{" + tokname + "}"}

  result.b = False
  If tokname <> ""
    strhelp.s =  PED_GetHelptextFor{tokname}
    If FLen(strhelp) < 3
      PED_ShowMessage{""}
    Else
      PED_ShowMessage{strhelp}
      result.b = True
    EndIf
  EndIf
  Function Return result
End Function


Function.l PED_SetCurrentDir{}
SHARED ped
  log_Print{"old current dir is [" + ped\currentDir + "]"}

  If ped\currentDir = "" Then ped\currentDir = dos_GetCurrentDir{}

  If ped\currentDirLock Then UnLock_ ped\currentDirLock

  ped\currentDirLock = Lock_(&ped\currentDir,#ACCESS_READ)
  If ped\currentDirLock
    log_Print{"new current dir is [" + ped\currentDir + "]"}
    ped\oldDirLock = CurrentDir_ (ped\currentDirLock)
    Function Return ped\oldDirLock
  Else
    log_Print{"could not lock the given dir, error #" + Str$(IoErr_), #log_warning}
  EndIf
End Function


Function.l PED_CheckSourceAlreadyOpen{fname.s}
SHARED ped

  log_Print{"check if file [" + fname + "] is already opened."}

  found.b = False
  *fileEntry.sourceEntry = ped\firstSourceEntry
  While *fileEntry AND (found = False)
    tempfname.s = dos_AddPart{Peek.s(&*fileEntry\SourceDir), Peek.s(&*fileEntry\SourceName)}
    log_Print{"... checking [" + tempfname + "]"}
    If tempfname = fname
      found = True
    Else
      *fileEntry = *fileEntry\nextEntry
    EndIf
  Wend
  Function Return *fileEntry
End Function

Statement PED_CloseFile{fh.l}
  SHARED ped,readcache
  If fh <> 0
    log_Print{"closing file handle: " + Hex$(fh)}
    Close_ fh : ped\sourceFileHandle = 0
    If readcache\cacheptr
      FreeVec_ readcache\cacheptr
      readcache\cacheptr = Null
      readcache\cachelen = 0
      readcache\readlen = 0
      readcache\chunklen = 0
      readcache\filelen = 0
      ;ClearType readcache
    EndIf
  Else
    log_Print{"file already closed at " + Hex$(fh)}
  EndIf
End Statement

Function.l PED_OpenFile{ofname.s, accessmode.l, menuload.b}
SHARED ped, pedconfig

  log_Print{"open_file <" + ofname + ">"}

  ; -- check extension
  fext.s = LCase$(dos_GetExt{ofname})
  log_Print{"checking file extention of file: " + ofname + " [" + fext + "]"}
  If pedconfig\smart_tokenization <> 0
    If fext = "bb" OR fext = "bb2" OR fext = "ab2" OR fext = "ab3"
      log_Print{"smart tokeniztation: activating tokenization"}
      ped\doTokenize = True
    Else
        log_Print{"deactivating tokenization"}
        ped\doTokenize = False
    EndIf
  EndIf

  If fext = "asm"
    log_Print{"it seems to be an asm file, tokenization and conversion mode is active."}
    If pedconfig\smart_tokenization Then ped\doTokenize = True
    ped\convertAsm = True
  Else
    ped\convertAsm = False
  EndIf

  fh.l = Open_(&ofname, accessmode)
  If fh
;    log_Print{"file opened successfully, handle: " + Hex$(fh)}
    Function Return fh
  Else
    fileerror.l = IoErr_
    log_Print{"could not open file <" + ofname + "> for reason: " + Str$(fileerror)}
    log_Print{"menuload: " + Str$(menuload)}

    If menuload = False
      error{"Couldn't open file, DOS-Error #" + Str$(fileerror)}
    Else
      error{"Couldn't open file, DOS-Error #" + Str$(fileerror)}
    EndIf
  EndIf
End Function



Function.s PED_RequestFile{tmpdir$, tmpfile$, tmptitle$, tmppattern$, @setAsCurrentFile.b}
SHARED ped, pedconfig, sourceWindow

 If pedconfig\use_filepattern <> 0
   If tmppattern$ = "" Then tmppattern$ = "(#?.info)"
 Else
   tmppattern$ = ""
 EndIf

 asl_SetRequesterDims{pedconfig\asl_x,pedconfig\asl_y,pedconfig\asl_w,pedconfig\asl_h}
 aslfr_SetRequesterTitle{1,!TRANS{tmptitle$},"",""}
 aslfr_SetPattern{1,tmppattern$}
 aslfr_SetPath{1,tmpdir$}
 aslfr_SetFile{1,tmpfile$}

 If aslfr_Request{1,False,False,False,sourceWindow\pedScreen}
   tempdir$      = aslfr_GetPath{1}
   tempfile$     = aslfr_GetFile{1}
   tempcomplete$ = dos_AddPart{tempdir$ , tempfile$}
 Else
   tempfile$ = ""
 EndIf

 If tempfile$ <> "" AND setAsCurrentFile
   ped\currentDir = tempdir$
   ped\currentFile = tempfile$
   ped\sourceFileComplete = tempcomplete$
 EndIf
 Function Return tempcomplete$
End Function


Statement FAST PED_PrintText{textaddr.l, xPos.w, yPos.w, textlen.w, @textcolor.w, @backcolor.w}
SHARED ped,sourceWindow,AB3Pen()

  ; -- clip text to visible columns
  If (xPos + textlen) > sourceWindow\visibleColumns
    textlen = sourceWindow\visibleColumns - xPos
  EndIf

  If textlen > 0
    If xPos < 0
      textlen + xPos
      textaddr - xPos
      xPos = 0
    EndIf
    If textlen > 0
      tposx.w = xPos * sourceWindow\font\tf_XSize + sourceWindow\BoxLeft
      tposy.w = yPos * sourceWindow\font\tf_YSize + sourceWindow\BoxTop + sourceWindow\font\tf_Baseline
    
      If textcolor <> -1 Then SetAPen_ sourceWindow\win\RPort, textcolor
      If backcolor <> -1 Then SetBPen_ sourceWindow\win\RPort, backcolor Else SetBPen_ sourceWindow\win\RPort, AB3Pen(#AB3_cbackground)
      Move_ sourceWindow\win\RPort, tposx, tposy  
      Text_ sourceWindow\win\RPort, textaddr, textlen
    EndIf
  EndIf
  
End Statement

Statement PED_PrintTokenizedText{*textaddr.l, startPos.w, size.w, tposx.w, tposy.w}
SHARED sourceWindow, ped, pedconfig, AB3Pen()
USEPATH sourceWindow

  ;-- work with printbuffer
  tmpString2.s = Peek.s(ped\ptrTextbufferPrint)

  ;-- check if source left of display start position has an opened string literal
  If ped\keepString = 0
    chkString.b = 0

    If tmpString2 <> ""
      runner.w = 0
      While runner < startPos
        If Peek.b( &tmpString2 + runner) = $22 Then chkString = NOT chkString
        runner + 1
      Wend
    EndIf
  EndIf
  ;log_Print{"we are in a string: " + Str$(chkString)}

  tposx = tposx / \font\tf_XSize  
  If size < 0 Then size = \visibleColumns - tposx
  If size > \visibleColumns - tposx Then size = \visibleColumns - tposx

  tmpPrint.s = UnRight$(tmpString2, startPos)
  tmpPrint = Left$(tmpPrint, size)

  runner.w = -1
  print_loop:
  tmpExpand.s = ""
  Repeat
    runner + 1
    curChar.b = Peek.b(&tmpPrint + runner)
    If curChar <> 0
      If curChar = $22 Then chkString.b = NOT chkString
      If chkString = 0
        If curChar < 0 Then Goto exit_printloop   ; Token found, goto routine to print token
      EndIf
      tmpExpand + Chr$(curChar)
    EndIf
  Until curChar = 0
  exit_printloop:

  ;-- print all normal characters we found so far...
  If FLen(tmpExpand)
    PED_PrintText{&tmpExpand, tposx, tposy, FLen(tmpExpand), AB3Pen(#AB3_cother)}
    tposx + FLen(tmpExpand)
  EndIf
  If curChar = 0 Then Goto exit_print
  If curChar > 0 Then Goto print_loop

  ;-- if we have a token, print it ...
  tmpExpand.s = ""
  While curChar < 0
    tmpExpand + Chr$(curChar BitClr 7)
    runner + 1
    curChar = Peek.b(&tmpPrint + runner)
  Wend
  runner - 1

  If FLen(tmpExpand)
    tcolor.w = AB3Pen(#AB3_ctoken)
    tcolorb.w = -1
    If AB3Pen(#AB3_ctokenbackground) <> AB3Pen(#AB3_cbackground) Then tcolorb = AB3Pen(#AB3_ctokenbackground)

    ;-- check for classic token and set color else set standard token color
    If AB3Pen(#AB3_cclassic) > 0
      _token.l = PED_GetTokenID{tmpExpand}
      If PED_CheckForClassicToken{_token} Then tcolor.w = AB3Pen(#AB3_cclassic)
    EndIf

    ;-- print the token
    If pedconfig\bold_tokens
      ;SetFont_ \win\RPort, \fontB
      SetSoftStyle_ \win\RPort,#FSF_BOLD,#FSF_BOLD
    EndIf

    PED_PrintText{&tmpExpand, tposx, tposy, FLen(tmpExpand), tcolor, tcolorb}

    ;-- reset font and style
    If pedconfig\bold_tokens
      ;SetFont_ \win\RPort, \font
      SetSoftStyle_ \win\RPort,#FS_NORMAL,#FSF_BOLD
    EndIf

    tposx + FLen(tmpExpand)

    If curChar <> 0 Then Goto print_loop
  EndIf

  exit_print:
End Statement

Function PED_PrintChar{enteredChar.b, @instru.b}
SHARED sourceWindow,ped,AB3Pen()
USEPATH ped\ptrCurrentSourceData

  actualColumn.w = \Column + \ColumnsOffset
  actualLine.l = \DisplayLine + \DisplayLineOffset

  ;-- write character to textbuffer
  plineaddr.l = ped\ptrTextbuffer + \TextBufferOffset + actualColumn
  Poke.b plineaddr, enteredChar

  ; -- print entered character to source window
  tcolor.w = AB3Pen(#AB3_cother)
  textaddr.l = &enteredChar

  If Peek.b(textaddr) < 0
    If instru <> -1 ; tokenbit in textbuffer is set!
      log_Print{"printing an instruction? removing token bit in testbuffer.", #log_warning}
      Poke.b textaddr, Peek.l(textaddr) BitClr 7
    EndIf
    tcolor.w = AB3Pen(#AB3_cclassic)
  EndIf

  If Peek.b(textaddr) > 0
    ;log_Print{"Print ["  + Chr$(enteredChar) + "] at " + Str$(tposx) + ", " + Str$(tposy) + " - offset " + Str$(\ColumnsOffset)}
    PED_PrintText{textaddr, \Column, \DisplayLine, 1, tcolor}
  EndIf
End Function


Statement PED_PrintSyntaxHighlighting{startPos.w, size.w, tposx.w, tposy.w}
SHARED pedconfig, ped, sourceWindow, AB3Pen()

  lineaddr.l = ped\ptrTextbufferPrint
  offset.w = 0 

  exit_highlight.b = False
  Repeat
    textlen.w = 0
    tlen.w    = 0
    tcolor.w  = -1
    tcolorb.w = -1

    curChar.b = Peek.b(lineaddr + offset)

    Select curChar
    Case @";" ;-------- comments
      If (AB3Pen(#AB3_cremarkforeground) <> AB3Pen(#AB3_cother)) OR (AB3Pen(#AB3_cremarkbackground) <> AB3Pen(#AB3_cbackground))
        If Peeks$(lineaddr + offset + 1,2) <> ":@"
          textlen = Len(Trim$(Peek.s(lineaddr + offset)))
          tcolor = AB3Pen(#AB3_cremarkforeground)
          tcolorb = AB3Pen(#AB3_cremarkbackground)
          exit_highlight = True
        EndIf         
      EndIf

    Case $22 ;-------- strings
      If AB3Pen(#AB3_cstring) <> AB3Pen(#AB3_cother)
        ;log_Print { "search string [" + Peeks$(lineaddr + offset + 1,40) + "]"}
        textlen = Instr(Peek.s(lineaddr + offset + 1), Chr$($22))   ; search for second string mark
        If textlen
          textlen + 1
          tcolor = AB3Pen(#AB3_cstring)
        EndIf
      EndIf

    Case @"#" ;-------- constants
      If AB3Pen(#AB3_cconstant) <> AB3Pen(#AB3_cother)
        For i.w = offset + 1 To #MAX_Columns - 1
          checkchr.b = Peek.b(lineaddr + i)
          ;log_Print{"macro checking [" + Chr$(checkchr) +  "] in "+ Peeks$(lineaddr,20)}
          If checkchr <> @"$" AND checkchr <> @"%"; OR checkchr = @"-"
            If !IsIllegalChar{Peek.b(lineaddr + i)}
              textlen = i - offset
              tcolor = AB3Pen(#AB3_cconstant)
              Pop For : Pop If : Pop If : Pop If
              Goto Exit_constant
            EndIf
          EndIf
        Next i
        Exit_constant:
      EndIf

    Case @"\" ;-------- newtypes
      If AB3Pen(#AB3_cnewtype) <> AB3Pen(#AB3_cother)
        For i.w = offset + 1 To #MAX_Columns - 1
          checkchr.b = Peek.b(lineaddr + i)
          ;log_Print{"macro checking [" + Chr$(checkchr) +  "] in "+ Peeks$(lineaddr,20)}
          If checkchr <> @"\"
            If !IsIllegalChar{Peek.b(lineaddr + i)}
              textlen = i - offset
              tcolor = AB3Pen(#AB3_cnewtype)
              Pop For : Pop If : Pop If : Pop If
              Goto Exit_newtype
            EndIf
          EndIf
        Next i
        Exit_newtype:
      EndIf

    Case @"!" ;-------- macros
      If AB3Pen(#AB3_cmacro) <> AB3Pen(#AB3_cother)
        For i.w = offset + 1 To #MAX_Columns - 1
          If !IsIllegalChar{Peek.b(lineaddr + i)}
            textlen = i - offset
            tcolor = AB3Pen(#AB3_cmacro)
            Pop For : Pop If
            Goto Exit_macro
          EndIf
        Next i
        Exit_macro:
      EndIf

    Case @"{" ;-------- basic functions/statements
      If AB3Pen(#AB3_cfunction) <> AB3Pen(#AB3_cother)
        For i.w = offset - 1 To 0 Step -1
          checkchr.b = Peek.b(lineaddr + i)

          ; check if we have a macro instead of an statement/function
          If checkchr = @"!"; OR (checkchr < 0) 
            Pop For : Pop If : Pop If : Pop If
            Goto Exit_function
          EndIf

          If !IsIllegalChar{checkchr} OR (i = 0)
            If i > 0 Then i + 1
            textlen = offset - i
            offset = offset - textlen
            tcolor = AB3Pen(#AB3_cfunction)
            Pop For : Pop If : Pop If : Pop If
            Goto Exit_function
          EndIf
        Next i
        Exit_function:
      EndIf       
    End Select

    ;-- print the highlighted text
    ;-- but only of it is in visible area
    If textlen 
      If (offset + textlen => startPos) AND (offset - startPos <= sourceWindow\visibleColumns-1)
        ; --
        ; startPos < ----- > size to check !!!!
        ; --

        textaddr.l = lineaddr + offset
        tlen = textlen
        tx.w = 0

        ;-- scrolling mode, so just update the scroll area left or right
        If (size > 0)  
          ;-- check if text is in visible area
          If (offset + textlen < startPos) OR (offset > startPos)
            ;log_Print{"IGNORING offset " + Str$(offset) + " tlen " + Str$(tlen) + "   " + Peeks$(textaddr,tlen)}
            tlen = 0
          Else
            ;--                             #ID_ | VALUE
            ;-- check if startPos is left or right of found text
            tx = offset - startPos

            If tx < 0        ; startPos is left of begin of text 
              textaddr - tx
            Else
              textaddr + tx  ; startPos is right of begin of text 
            EndIf

            If tposx = 0 Then tx = 0 Else tx = sourceWindow\visibleColumns - size
            If tlen > size Then tlen = size
            ;log_Print{"SCROLL offset " + Str$(offset) + " startpos " + Str$(startPos) + " tx " + Str$(tx) + " tlen " + Str$(tlen) + "  " + Peeks$(textaddr,tlen)}

          EndIf
        Else
          ;-- clipping of full text to visible area
          tx = offset - startPos          
          If tx < 0       
            textaddr - tx
            tlen + tx
            tx = 0
          EndIf
        EndIf

        If tlen > 0        
          ;log_Print{"SYNTAX tx " + Str$(tx) + " | " + Peeks$(textaddr,tlen)}
          PED_PrintText{textaddr, tx, tposy, tlen, tcolor, tcolorb}
        EndIf
      Else
        ;log_Print{"text is outside of view: offset " + Str$(offset) + " startPos " + Str$(startPos) + " tl " + Str$(textlen)  + " | " + Peeks$(lineaddr + offset, textlen)}
      EndIf

      offset = offset + textlen
    EndIf

    offset + 1
  Until (exit_highlight) OR (curChar = 0) OR (offset >= #MAX_Columns - 1)
End Statement


Statement PED_PrintSourceText{*textaddr.l, startPos.w, size.w, tposx.w, tposy.w, @clearEndOfLine.b}
SHARED sourceWindow, ped, pedconfig, AB3Pen()

  ;-- detokenize it but keep token indicator (bit7)
  tmpString1.s = Peeks$(*textaddr,#MAX_Columns - 1)    
  PED_Detokenize2Printbuffer{&tmpString1}  ; TODO: prepare for syntaxhighlighting

  ;-- print the sourcetext
  If ped\doTokenize
    PED_PrintTokenizedText{*textaddr, startPos, size, tposx, tposy}
  Else
    tmpString.s = UnRight$(Peek.s(*textaddr), startPos)
    textlen.w = FLen(tmpString.s)
    If textlen > size Then textlen = size
    PED_PrintText{*textaddr + startPos, tposx, tposy, textlen, AB3Pen(#AB3_cother), AB3Pen(#AB3_cbackground)}    
  EndIf

  ;-- clear end of line
  If clearEndOfLine = True
    USEPATH sourceWindow

    If \win\RPort\cp_x <= \BoxLeft
      rectx.w = \win\RPort\cp_x + 1
    Else
      rectx.w = \win\RPort\cp_x
    EndIf
    recty.w = \BoxTop + tposy * \font\tf_YSize
    rectw.w = \BoxWidth
    recth.w = recty + \font\tf_YSize-1
    If (rectw => rectx) AND (recth => recty)
      SetAPen_  \win\RPort, AB3Pen(#AB3_cbackground)
      RectFill_ \win\RPort, rectx, recty, rectw, recth
    Else
      log_Print{"illegal area for clear EOL:",#log_error}
      log_Print{Str$(rectx) + ", " + Str$(rectw)}
      log_Print{Str$(recty) + ", " + Str$(recth)}
    EndIf
  EndIf
  
  ;-- do syntax highlighting if activated
  If pedconfig\highlighting 
    PED_PrintSyntaxHighlighting{startPos, size, tposx, tposy}
  EndIf
End Statement

Statement PED_PrintLineNumber{}
SHARED sourceWindow, ped, AB3Pen()
USEPATH sourceWindow

  dl.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine + 1
  linenum$ = Str$(dl)

  lx.w = \BoxLeft - (FLen(linenum$) * \font\tf_XSize) - 2
  ly.w = \BoxTop + ped\ptrCurrentSourceData\DisplayLine * \font\tf_YSize

  SetAPen_ \win\RPort,AB3Pen(#AB3_screenfill)
  RectFill_ \win\RPort,0,ly,\BoxLeft-1,ly + \font\tf_YSize - 1

  SetAPen_ \win\RPort,AB3Pen(#AB3_screenshine)
  SetBPen_ \win\RPort,AB3Pen(#AB3_screenfill)
  Move_ \win\RPort,lx,ly + \font\tf_Baseline
  Text_ \win\RPort,&linenum$,FLen(linenum$)

  ;Move_ \win\RPort,0,ly; + \font\tf_Baseline
  ;Draw_ \win\RPort,\BoxLeft,ly

  SetAPen_ \win\RPort,AB3Pen(#AB3_screenshine)
  Move_ \win\RPort,\BoxLeft-1,ly
  Draw_ \win\RPort,\BoxLeft-1,ly + \font\tf_YSize - 1
End Statement


#FULL = 1
Statement PED_UpdateLinenumbers{@mode.b}
SHARED sourceWindow, pedconfig, AB3Pen(), ped

  ;log_Print{"update linenumbers, mode: " + Str$(mode)}
  If pedconfig\linenumbers = False Then Statement Return

  If mode = #FULL
    USEPATH sourceWindow
    SetAPen_ \win\RPort, AB3Pen(#AB3_screenfill)
    RectFill_ \win\RPort, 0, \BoxTop, \BoxLeft - 1, \statusAreaY - 1

    SetAPen_ \win\RPort,AB3Pen(#AB3_screenshine)
    Move_ \win\RPort, \BoxLeft - 2, \BoxTop
    Draw_ \win\RPort, \BoxLeft - 2, \statusAreaY - 1

    startWith.w = 0
  Else
    startWith.w = ped\ptrCurrentSourceData\DisplayLine
  EndIf

  actualLine.l = ped\ptrCurrentSourceData\DisplayLine

  maxLineNumber.l = Min(ped\ptrCurrentSourceData\TotalLines, sourceWindow\visibleLines)
  For y.w = startWith To maxLineNumber - 1
    ped\ptrCurrentSourceData\DisplayLine = y
    PED_PrintLineNumber{}
  Next y
    
  ped\ptrCurrentSourceData\DisplayLine = actualLine
End Statement


Statement PED_PrintCurrentSourceLine{@clearEndOfLine.b}
SHARED pedconfig, ped, sourceWindow, AB3Pen()

  If pedconfig\linenumbers Then PED_PrintLineNumber{}

  If ped\ptrCurrentSourceData\CurrentSourceLine = 0 Then Statement Return

  ;-- clear current line in textBuffer
  ;FillMem ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset, #MAX_Columns, @" "
  MemCls ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset, #MAX_Columns, @" "

  ;log_Print{"--- " + Str$(ped\ptrCurrentSourceData\CurrentSourceLine\strLength)}
  ;!log_HexDump{ped\ptrCurrentSourceData\CurrentSourceLine,ped\ptrCurrentSourceData\CurrentSourceLine\strLength+8}

  If Peek.b(ped\ptrCurrentSourceData\CurrentSourceLine + 9) <> 0   ; first character of text
    PED_PrintSourceText{ped\ptrCurrentSourceData\CurrentSourceLine + 9, ped\ptrCurrentSourceData\ColumnsOffset, -1,0,ped\ptrCurrentSourceData\DisplayLine, clearEndOfLine}
    PED_CopyPrintbuffer2Textbuffer{}
  Else
    USEPATH sourceWindow
    SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)
    xMin.w = \BoxLeft
    yMin.w = \BoxTop + ped\ptrCurrentSourceData\DisplayLine * \font\tf_YSize
    xMax.w = \BoxWidth
    yMax.w = yMin + \font\tf_YSize - 1
    If (xMax => xMin) AND (yMax => yMin)
      RectFill_ \win\RPort, xMin, yMin, xMax, yMax
    Else
      log_Print{"illegal clear area for PrintCurrentSourceLine!", #log_error}
      log_Print{Str$(xMin) + ", " + Str$(xMax)}
      log_Print{Str$(yMin) + ", " + Str$(yMax)}
    EndIf

    ;-- move cursor to next line
    Move_ \win\RPort, 0, ped\ptrCurrentSourceData\DisplayLine * \font\tf_YSize + \font\tf_YSize 
  EndIf
End Statement


Statement PED_UpdateBlockPosY{y.l}
SHARED ped
  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
    If y <= ped\ptrCurrentSourceData\BlockEndY
      ped\ptrCurrentSourceData\BlockEndY + 1
      If y <= ped\ptrCurrentSourceData\BlockStartY
        ped\ptrCurrentSourceData\BlockStartY + 1
      EndIf
    EndIf
  EndIf
End Statement

Statement AbsDimensions{*bm.bmark}

End Statement

Statement PED_NormalizeBlockmarkDimensions{@*bm.bmark}
SHARED ped
USEPATH ped\ptrCurrentSourceData

  If *bm <> - 1
    If *bm\yMin < *bm\yMax Then Statement Return
    
    If (*bm\yMin > *bm\yMax) OR ((*bm\yMin = *bm\yMax) AND (*bm\xMin > *bm\xMax))
      Exchange *bm\xMin,*bm\xMax
      Exchange *bm\yMin,*bm\yMax
    EndIf  
  Else
    If (\BlockStartY > \BlockEndY) OR (\BlockStartY = \BlockEndY AND \BlockStartX > \BlockEndX)
      Exchange \BlockStartX, \BlockEndX
      Exchange \BlockStartY, \BlockEndY
      log_Print{"corrected block dims: " + Str$(\BlockStartX) + "," + Str$(\BlockStartY) + "," +Str$(\BlockEndX) + "," +Str$(\BlockEndY)}
    EndIf
  EndIf

End Statement


Macro PED_RectFill ; (xMin, yMin, xMax, yMax, [Color, [Mask]])
CNIF `0 < 5
    CERR "Not enough parameters!"
CEND
CNIF `0 >= 5
    ;sourceWindow\rp\Mask = `5
    SetAPen_ sourceWindow\rp, AB3Pen(#AB3_screenshine)
CEND
CNIF `0 = 6
    SetAPen_ sourceWindow\rp,`6
CEND
    If (`3 >= `1) AND (`4 >= `2)
      RectFill_ sourceWindow\rp, sourceWindow\BoxLeft + `1,sourceWindow\BoxTop + `2, sourceWindow\BoxLeft + `3, sourceWindow\BoxTop + `4
    Else
      log_Print{"illegal area for Macro Rectfill"}
    EndIf
CNIF `0 >= 5
    ;sourceWindow\rp\Mask = -1    
    ;SetDrMd_ sourceWindow\rp, #COMPLEMENT
CEND
End Macro

Statement PED_DrawBlock{*bmark.bmark} ;xMin.w,yMin.w, xMax.w, yMax.w, absolute.b}
SHARED ped, sourceWindow, AB3Pen()
USEPATH sourceWindow
  CopyType *bmark, bm.bmark

  ;If bm\xMin < 0 Then bm\xMin = 0
  ;If bm\xMax < 0 Then bm\xMax = 0
  ;If bm\yMin < 0 Then bm\yMin = 0
  ;If bm\yMax < 0 Then bm\yMax = 0

  If bm\xMin > \visibleColumns - 1 Then bm\xMin = \visibleColumns - 1
  If bm\xMax > \visibleColumns - 1 Then bm\xMax = \visibleColumns - 1
  If bm\yMax > \visibleLines - 1 Then bm\yMax = \visibleLines - 1 
  If bm\yMin > \visibleLines - 1 Then bm\yMin = \visibleLines - 1

  If (bm\xMin > bm\xMax) AND (bm\yMin = bm\yMax) 
    log_Print{"PED_DrawBlock(): xMin > xMax!!", #log_warning}
    Exchange bm\xMin, bm\xMax
  EndIf
  If bm\yMin > bm\yMax 
    log_Print{"PED_DrawBlock(): yMin > yMax!!", #log_warning}
    Exchange bm\yMin, bm\yMax
  EndIf

  VWait 1
  If bm\yMin = bm\yMax
    Gosub rectfill2                       ; draw block in a single line
  Else
    DEFTYPE.bmark bmStore
    CopyType bm, bmStore

    bm\xMax = \visibleColumns - 1
    bm\yMax = bm\yMin
    Gosub rectfill2                       ; draw firstline of block

    CopyType bmStore, bm

    If bm\yMax - bm\yMin > 1
        bm\xMin = 0
        bm\yMin = bm\yMin + 1
        bm\xMax = \visibleColumns - 1
        bm\yMax = bm\yMax - 1
        Gosub rectfill2                   ; draw middle part of block
        CopyType bmStore,bm
    EndIf

    If bm\xMax => 0 
      bm\xMin = 0
      bm\yMin = bm\yMax
      Gosub rectfill2                       ; draw lastline of block
    EndIf
  EndIf

  Statement Return

  rectfill2:
    bm\xMin * \font\tf_XSize
    bm\yMin * \font\tf_YSize
    bm\xMax * \font\tf_XSize + \font\tf_XSize
    bm\yMax * \font\tf_YSize + \font\tf_YSize
    !PED_RectFill{bm\xMin, bm\yMin, bm\xMax - 1, bm\yMax - 1, %101}
  Return
End Statement

Statement PED_UpdateScrollBlockmark{direction.b}
SHARED ped,sourceWindow, AB3Pen()
USEPATH ped\ptrCurrentSourceData
  ; SCROLL_LEFT : add blockparts at the right side of the source window
  ; SCROLL_RIGHT: add blockparts at the left side of the source window  

  ;-- check if we have a Blockmark, if not, just leave
  If \BlockEndY = $ffffFFFF Then Statement Return

  DEFTYPE.bmark bm
  If direction = #SCROLL_LEFT
    bm\xMin = \ColumnsOffset + sourceWindow\visibleColumns - sourceWindow\scrollSize
  Else
    bm\xMin = \ColumnsOffset
  EndIf
  bm\yMin = \DisplayLineOffset
  bm\xMax = 0
  bm\yMax = bm\yMin + sourceWindow\visibleLines
 
  If (bm\yMin <= \BlockEndY) AND (bm\yMax >= \BlockStartY)
    If \BlockStartY = \BlockEndY
      If (bm\xMin >= \BlockStartX) AND (bm\xMin <= \BlockEndX)
        Gosub update_one_line         ; -- the block is just one line
      EndIf
    Else
      DEFTYPE.bmark bmStore
      If bm\xMin >= \BlockStartX
        CopyType bm, bmStore
        Gosub update_first_blockline  ; -- draw missing blockmark in first line while scrolling left
        CopyType bmStore, bm
      EndIf

      bm\yMin = \BlockStartY - \DisplayLineOffset + 1
      bm\yMax = \BlockEndY - \DisplayLineOffset - 1
      If bm\yMax > sourceWindow\visibleLines Then bm\yMax = sourceWindow\visibleLines

      If bm\xMin <= \BlockEndX
        CopyType bm, bmStore
        Gosub update_last_blockline
        CopyType bmStore, bm
      EndIf     

      If bm\yMax => bm\yMin
        Gosub update_middle_blocklines
      EndIf
    EndIf
  EndIf

  Statement Return

  update_one_line:
    If direction = #SCROLL_LEFT
      xMax_temp.w = \BlockEndX - bm\xMin + 1
      If xMax_temp > sourceWindow\scrollSize Then xMax_temp = sourceWindow\scrollSize

      bm\xMin = bm\xMin - \ColumnsOffset
      bm\xMax = bm\xMin + xMax_temp - 1
    Else
      xMax_temp.w = \BlockEndX - \ColumnsOffset + 1
      If xMax_temp < sourceWindow\scrollSize Then xMax_temp = sourceWindow\scrollSize

      bm\xMin = 0
      bm\xMax = bm\xMin + xMax_temp - 1
    EndIf
    bm\yMin = \BlockStartY - \DisplayLineOffset
    bm\yMax = bm\yMin

    Gosub rectfill3
  Return

  update_first_blockline:  
    If direction = #SCROLL_LEFT
      bm\xMin = bm\xMin - \ColumnsOffset
      bm\xMax = bm\xMin + sourceWindow\scrollSize - 1
    Else
      bm\xMin = 0
      bm\xMax = sourceWindow\scrollSize - 1
    EndIf
    bm\yMin = \BlockStartY - \DisplayLineOffset
    bm\yMax = bm\yMin    
    Gosub rectfill3
  Return

  update_last_blockline:
    If direction = #SCROLL_LEFT
      xMax_temp.w = \BlockEndX - bm\xMin + sourceWindow\scrollSize
      If xMax_temp > sourceWindow\scrollSize Then xMax_temp = sourceWindow\scrollSize

      bm\xMin = bm\xMin - \ColumnsOffset
      bm\xMax = bm\xMin + xMax_temp - 1
    Else
      xMax_temp.w = \BlockEndX - \ColumnsOffset - sourceWindow\scrollSize
      If xMax_temp < sourceWindow\scrollSize Then xMax_temp = sourceWindow\scrollSize
      
      bm\xMin = 0    
      bm\xMax = bm\xMin + xMax_temp - 1
    EndIf

    bm\yMin = \BlockEndY - \DisplayLineOffset
    bm\yMax = bm\yMin
    Gosub rectfill3
  Return

  update_middle_blocklines:
    If direction = #SCROLL_LEFT
      ;-- draw right blockparts while scrolling rightside except first and last line
      bm\xMin = bm\xMin - \ColumnsOffset
      bm\xMax = bm\xMin + sourceWindow\scrollSize - 1
      bm\yMin = bm\yMin
      bm\yMax = bm\yMax
    Else
      ;-- draw left blockparts while scrolling leftside except first and last line
      bm\xMin = 0
      bm\xMax = bm\xMin + sourceWindow\scrollSize - 1
      bm\yMin = \BlockStartY - \DisplayLineOffset + 1
      bm\yMax = \BlockEndY - \DisplayLineOffset
      If bm\yMax > sourceWindow\visibleLines Then bm\yMax = sourceWindow\visibleLines
      ;log_Print{Str$(bm\xMin) + ", " + Str$(bm\yMin) + ", " + Str$(bm\xMax) + ", " + Str$(bm\yMax)}      
    EndIf
    Gosub rectfill3
  Return

  rectfill3:
    bm\xMin * sourceWindow\font\tf_XSize
    bm\yMin * sourceWindow\font\tf_YSize
    bm\xMax * sourceWindow\font\tf_XSize + sourceWindow\font\tf_XSize
    bm\yMax * sourceWindow\font\tf_YSize + sourceWindow\font\tf_YSize
    !PED_RectFill{bm\xMin, bm\yMin, bm\xMax - 1, bm\yMax - 1, %101}
  Return
End Statement

Statement PED_DrawBlockmark{}
SHARED ped, sourceWindow
USEPATH ped\ptrCurrentSourceData

  If \BlockEndY = $ffffFFFF Then Statement Return

  ;-- draw the block, but only the parts in the visible area
  DEFTYPE.bmark bmark
  bmark\xMin = \BlockStartX, \BlockStartY, \BlockEndX, \BlockEndY      

  ;-- check if the block is visible  
  If (bmark\yMax < \DisplayLineOffset) Then Statement Return

  ;log_Print{"DrawBlockmark: " + Str$(bmark\xMin) + ", " + Str$(bmark\yMin) + " - " + Str$(bmark\xMax) + ", " + Str$(bmark\yMax)}

  bmark\xMin - \ColumnsOffset
  If bmark\xMin < 0 Then bmark\xMin = 0

  bmark\yMin - \DisplayLineOffset
  If bmark\yMin < 0
    bmark\xMin = 0
    bmark\yMin = 0
  EndIf

  If bmark\yMin < sourceWindow\visibleLines
    bmark\xMax - \ColumnsOffset
    ;If bmark\xMax < 0 Then bmark\xMax = 0

    bmark\yMax - \DisplayLineOffset
    ;If bmark\yMax < 0 Then bmark\yMax = 0

    If bmark\xMax > sourceWindow\visibleColumns - 1
      bmark\xMax = sourceWindow\visibleColumns - 1
    EndIf

    ;-- if the block is larger than the visible lines, then cut the block
    If bmark\yMax > sourceWindow\visibleLines - 1
      bmark\yMax = sourceWindow\visibleLines - 1
      bmark\xMax = sourceWindow\visibleColumns - 1
    EndIf

    PED_DrawBlock{bmark}
  EndIf
End Statement

Function.l PED_GetCountOfMarkedLines{}
SHARED ped
  Function Return ped\ptrCurrentSourceData\BlockEndY - ped\ptrCurrentSourceData\BlockStartY + 1
End Function

Function.l PED_GetFirstBlockLine{}
SHARED ped
  log_Print{"BlockStartX: " + Str$(ped\ptrCurrentSourceData\BlockStartX)}
  log_Print{"BlockStartY: " + Str$(ped\ptrCurrentSourceData\BlockStartY)}
  log_Print{"BlockEndX  : " + Str$(ped\ptrCurrentSourceData\BlockEndX)}
  log_Print{"BlockEndY  : " + Str$(ped\ptrCurrentSourceData\BlockEndY)}
  *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  currLine.l = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
  ;log_Print{"currline   : " + Str$(currLine) + "--> " + PED_Detokenize{*tempLine}}

  If currLine = ped\ptrCurrentSourceData\BlockStartY
    ; do nothing
  Else
    diff.l = 0
    If currLine < ped\ptrCurrentSourceData\BlockStartY
      diff = ped\ptrCurrentSourceData\BlockStartY - currLine
      For si.w = 1 To diff
        If *tempLine\nextLine Then *tempLine = *tempLine\nextLine Else error{"Error copying to clipboard!"}
      Next si
    Else
      If currLine > ped\ptrCurrentSourceData\BlockStartY
        diff = currLine - ped\ptrCurrentSourceData\BlockStartY
        For si.w = 1 To diff
          If *tempLine\previousLine Then *tempLine = *tempLine\previousLine Else error{"Error copying to clipboard!"}
        Next si
      EndIf
    EndIf
  EndIf

  Function Return *tempLine
End Function


Statement PED_HandleBlockmark{}
SHARED ped, sourceWindow, pedconfig

  ;log_Print{"handle blockmark"}

  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF Then Statement Return

  If ped\blockmarkRemovalMode <> 0
    If ped\blockmarkRemovalMode = 2
      Gosub menu_cut
      If pedconfig\no_display_beep = False Then DisplayBeep_ sourceWindow\pedScreen
    Else
      ; for blockmarkRemovalMode = 1 only remove blockmark
      PED_DrawBlockmark{}
      !PED_ResetBlockflag
    EndIf
    ped\blockmarkRemovalMode = 0
  EndIf
End Statement

Statement PED_RedrawTextbuffer{direction.b}
SHARED ped, sourceWindow

  !PED_storeCursorPosition

  ped\noDetokenizing = 1
  ped\keepString = 1

  Select direction
  Case #SCROLL_LEFT
    curX.w = sourceWindow\visibleColumns - sourceWindow\scrollSize
    startPos.w = ped\ptrCurrentSourceData\ColumnsOffset + sourceWindow\visibleColumns - 1
    tsize.w = sourceWindow\scrollSize
  Case #SCROLL_RIGHT
    curX.w = 0
    startPos.w = ped\ptrCurrentSourceData\ColumnsOffset
    tsize.w = sourceWindow\scrollSize
  Default
    curX.w = 0
    startPos.w = ped\ptrCurrentSourceData\ColumnsOffset
    tsize.w = -1
  End Select
  curX = curX * sourceWindow\font\tf_XSize
  
  lineaddr.l = ped\ptrTextbuffer

  ;log_Print{"redrawTextbuffer, startPos: " + Str$(startPos) + ", curX " + Str$(curX)}
  ;log_Print{"first line of textbufferoffset [" + Peeks$(lineaddr,30) + "]"}

  For curY.w = 0 To sourceWindow\visibleLines - 1    
    If Peek.b(lineaddr) <> 0
      PED_PrintSourceText{lineaddr, startPos, tsize, curX, curY, False}
    Else
      log_Print{"line starts with 0-byte, will be ignored"}
    EndIf

    ; -- increase text line pointer in textbufferoffset
    lineaddr + #MAX_Columns
  Next curY
  
  ;-- redraw or update the block
  If direction = #FULL_REDRAW
    PED_DrawBlockmark{}
  Else
    PED_UpdateScrollBlockmark{direction}
  EndIf

  ped\keepString = 0
  ped\noDetokenizing = 0

  !PED_RestoreCursorPosition
End Statement

Statement PED_RedrawSource{}
SHARED pedconfig, ped, sourceWindow, AB3Pen()
  log_Print{"RedrawSource, current displayline: " + Str$(ped\ptrCurrentSourceData\DisplayLine) + "  offset: " + Str$(ped\ptrCurrentSourceData\DisplayLineOffset)}
  *tmpcsl.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  If *tmpcsl = 0 Then Statement Return

  *storeCurrentSourceLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  !PED_storeCursorPosition

  ;-- clear textbuffer
  PED_ClearTextbuffer{} : ped\ptrCurrentSourceData\TextBufferOffset = 0
  
  CNIF #hardfold = 1
    ped\foldNumber = PED_CheckFoldingState{}
  CEND

  ; -- decrease linepointer to first sourceline to be displayed
  *tmpcsl.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  While (ped\ptrCurrentSourceData\DisplayLine > 0) AND (*tmpcsl <> 0)
    *tmpcsl = *tmpcsl\previousLine

    If *tmpcsl

      CNIF #hardfold = 1
      If Peek.w(*tmpcsl + 9) = @";@"
        PED_CheckFoldingReverse{*tmpcsl}
        If Peek.w(*tmpcsl + 11) = @"@0"
          If ped\foldNumber <> 0
            Pop If : Pop If : Pop If : Goto cont_redraw
          EndIf
        EndIf
      EndIf
      If ped\foldNumber <> 0
        ; jump to beginning of loop without reducing tmpdl
      EndIf
      cont_redraw:
      CEND

      ped\ptrCurrentSourceData\DisplayLine - 1
    Else
      log_Print{"RedrawSource: no previous line!", #log_error}
    EndIf
  Wend


  ;-- print all the lines into the empty textbuffer
  PED_CursorOff{}
  For cl.l = 1 To sourceWindow\visibleLines
    ped\ptrCurrentSourceData\CurrentSourceLine = *tmpcsl

;    CNIF #hardfold = 1
;   'nr
;      CMP.l #";@@1",9(a2)
;      BNE 'l1
;        MOVE.l #1,foldnum
;        BRA 'do
;     'l1
;      CMP.l #";@@0",9(a2)
;      BNE 'l2
;      MOVE.l #0,foldnum
;     'l2
;      MOVE.l comLong_DisplayLine,d0
;      CMP.l store_comLong_DisplayLine,d0
;      BNE 'l3b
;      ;MOVE.l a2,comPtr_CurrentSourceLine
;     'l3b
;      TST.l foldnum
;      BEQ 'do
;        MOVE.l (a2),d0
;        BEQ JL_0_5902
;          MOVE.l d0,a2
;    BRA 'nr
;   'do
;    CEND

    If ped\ptrCurrentSourceData\CurrentSourceLine
      ;log_Print{"redraw: next line at displayline " + Str$(ped\ptrCurrentSourceData\DisplayLine)}
      PED_PrintCurrentSourceLine{True}

      ped\ptrCurrentSourceData\DisplayLine + 1
      ped\ptrCurrentSourceData\TextBufferOffset + #MAX_Columns

      *tmpcsl = *tmpcsl\nextLine
    ;Else
      ;log_Print{"redraw: no next line at displayline " + Str$(cl),#log_information}
    EndIf
  Next cl

  ; -- better refresh: clear bottom
  USEPATH sourceWindow
  If ped\ptrCurrentSourceData\DisplayLine < sourceWindow\visibleLines
    ;log_Print{"redraw: clear rest of window at displayline: " + Str$(ped\ptrCurrentSourceData\DisplayLine+1)}
    SetAPen_  \win\RPort, AB3Pen(#AB3_cbackground)
    rectx.w = \BoxLeft
    recty.w = \BoxTop + (ped\ptrCurrentSourceData\DisplayLine) * \font\tf_YSize
    rectw.w = \BoxWidth
    recth.w = \statusAreaY-1
    If (rectw => rectx) AND (recth => recty)
      RectFill_ \win\RPort, rectx, recty, rectw, recth
      If pedconfig\linenumbers
        SetAPen_  \win\RPort, AB3Pen(#AB3_screenfill)
        RectFill_ \win\RPort, 0, recty, rectx-1,recth
        SetAPen_ \win\RPort,AB3Pen(#AB3_screenshine)
        Move_ \win\RPort,rectx - 1, recty
        Draw_ \win\RPort,rectx - 1, recth
      EndIf
    Else
      log_Print{"illegal area for clear bottom:",#log_error}
      log_Print{"displayline: " + Str$(ped\ptrCurrentSourceData\DisplayLine+1) + "   visibleLines: " + Str$(sourceWindow\visibleLines-1)}
      log_Print{Str$(rectx) + ", " + Str$(rectw),#log_error}
      log_Print{Str$(recty) + ", " + Str$(recth),#log_error}
    EndIf
  EndIf

  ; -- restore saved values
  ped\ptrCurrentSourceData\CurrentSourceLine = *storeCurrentSourceLine
  !PED_RestoreCursorPosition

  ;-- redraw the blockmark
  PED_DrawBlockmark{}
  
  PED_CursorOn{}
End Statement


Statement PED_CopyBlock{}
SHARED ped
  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF Then Statement Return

  ;-- move to first selected sourceline
  *tempLine.sourceLine = PED_GetFirstBlockLine{}

  ;-- get first copyline
  strline$ = PED_Detokenize{*tempLine.sourceLine}
  strlng.w = FLen(strline$)

  log_Print{"first marked line: <" + strline$ + ">," + Str$(strlng)}
  If PED_GetCountOfMarkedLines{} < 2
    If strlng > ped\ptrCurrentSourceData\BlockEndX + 1
      strlng = ped\ptrCurrentSourceData\BlockEndX - ped\ptrCurrentSourceData\BlockStartX + 1
    EndIf
    strline$ = Mid$(strline$, ped\ptrCurrentSourceData\BlockStartX + 1, strlng)
    clipboard_WriteText{&strline$}
    log_Print{"moved " + Str$(strlng) + " to clipboard [" + strline$ + "]"}
  Else
    *iff.IFFHandle = AllocIFF_()
    If *iff
      *iff\iff_Stream = OpenClipboard_ (0)
      If *iff\iff_Stream
        InitIFFasClip_ *iff
        If (OpenIFF_ (*iff, #IFFF_WRITE)=0)
          If (PushChunk_ (*iff, #ID_FTXT, #ID_FORM, #IFFSIZE_UNKNOWN)=0)
            If (PushChunk_ (*iff, 0, #ID_CHRS, #IFFSIZE_UNKNOWN)=0)
              ;-- copy first line
              If strlng < (ped\ptrCurrentSourceData\BlockStartX + 1)
                strline$ = ""
              Else
                strline$ = Mid$(strline$, ped\ptrCurrentSourceData\BlockStartX + 1)
              EndIf
              ;log_Print{"--> " + Str$(FLen(strline$)) + " <" + strline$ + ">"}
              strline$ + Chr$(10) : WriteChunkBytes_ *iff, &strline$, FLen(strline$)

              ; -- copy most lines
              ;log_Print{"copy other lines"}
              For si.w = 1 To PED_GetCountOfMarkedLines{} - 2
                If *tempLine\nextLine
                  *tempLine = *tempLine\nextLine
                  strline$ = PED_Detokenize{*tempLine}
                  strlng.w = FLen(strline$)
                  If ped\verticalCopyMode <> 0 AND (strlng > ped\ptrCurrentSourceData\BlockStartX + 1)
                    strline$ = Mid$(strline$, ped\ptrCurrentSourceData\BlockStartX + 1)
                  EndIf
                  ;log_Print{"--> " + Str$(FLen(strline$)) + " <" + strline$ + ">"}
                  strline$ + Chr$(10) : WriteChunkBytes_ *iff,&strline$,FLen(strline$)
                Else
                  error{"Error copying to clipboard: no next line!",#log_error}
                EndIf
              Next si

              ; copy last selected Line
              ;log_Print{"copy last line"}
              *tempLine = *tempLine\nextLine
              If *tempLine
                strline$ = PED_Detokenize{*tempLine}
                strline$ = Left$(strline$,ped\ptrCurrentSourceData\BlockEndX+1)
                strlng = FLen(strline$)
                If ped\verticalCopyMode <> 0 AND (strlng > ped\ptrCurrentSourceData\BlockStartX + 1)
                  strline$ = Mid$(strline$,1,ped\ptrCurrentSourceData\BlockEndX + 1)
                EndIf
                ;log_Print{"--> " + Str$(FLen(strline$)) + " <" + strline$ + ">"}
                strline$ + Chr$(10) : WriteChunkBytes_ *iff, &strline$, FLen(strline$)
              EndIf
              PopChunk_ *iff
            End If

            PopChunk_ *iff
          Else
            error{"Could not write chunks."}
          End If
          CloseIFF_ *iff
        Else
          error{"Could not open IFF."}
        End If
        CloseClipboard_ *iff\iff_Stream
      Else
        error{"Could not open Clipboard."}
      End If
      FreeIFF_ *iff
    Else
      error{"Could not AllocIFF."}
    End If
  EndIf

exit_copy:
  log_Print{"copy finished."}
End Statement


Statement PED_KillBlock{}
SHARED ped
USEPATH ped\ptrCurrentSourceData
  If \BlockEndY = $FFFFffff Then Statement Return

  killedRows.l = 0
  *tempLine.sourceLine = PED_GetFirstBlockLine{}
  ;log_Print{"number of marked Lines: " + Str$(PED_GetCountOfMarkedLines{})}
  strline$ = PED_Detokenize{*tempLine}
  log_Print{"source of first blockline: <" + Left$(strline$, 30) + ">"}

  If PED_GetCountOfMarkedLines{} = 1
    If (\BlockEndX - \BlockStartX) < #MAX_Columns
      strline$ = PED_Detokenize{*tempLine}
      strline$ = Left$(strline$,\BlockStartX) + UnRight$(strline$,\BlockEndX + 1)
      log_Print{"changing line to: <" + strline$ + ">"}
      newline$ = PED_TokenizeText{strline$}
      *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
      *tempLine = PED_ReplaceSourceLine{*tempLine, *newLine}
      If *tempLine = 0
        log_Print{"Could not cut selected block."}
      EndIf
    Else
      If PED_CutSourceLine{*tempLine} Then PED_DeleteSourceLine{*tempLine}
    EndIf
  Else
    
    *tmpfirstLine.sourceLine = 0
    For si.w = 1 To PED_GetCountOfMarkedLines{}
      *nextLine.sourceLine = *tempLine\nextLine

      ;-- check first line if not marked completely
      If si = 1 AND (\BlockStartX > 0)
        strline$ = PED_Detokenize{*tempLine}
        strline$ = Left$(strline$,\BlockStartX)
        log_Print{"changing first line to: <" + strline$ + ">"}
        newline$ = PED_TokenizeText{strline$}
        *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
        *tempLine = PED_ReplaceSourceLine{*tempLine, *newLine}

        ;-- store the line for joining with last fragment
        *tmpfirstLine = *tempLine
        firstline$ = strline$

        Goto skip_killofline
      EndIf    

      ;-- check last line
      If si = PED_GetCountOfMarkedLines{} 
        strline2$ = PED_Detokenize{*tempLine}
        ;log_Print{"last line: <" + strline2$ + ">"}
        If FLen(strline2$) > \BlockEndX + 1
          strline1$ = ""
          If *tmpfirstLine <> 0 Then strline1$ = firstline$
          strline$ = strline1$ + UnRight$(strline2$,\BlockEndX + 1)
          newline$ = PED_TokenizeText{strline$}
          *newLine.sourceLine = PED_CreateNewSourceLine{newline$}

          If *tmpfirstLine <> 0
            log_Print{"joining first and last line to: <" + strline$ + ">"}
            *tmpfirstLine = PED_ReplaceSourceLine{*tmpfirstLine, *newLine}
            If *tmpfirstLine = 0
              log_Print{"Could not cut selected block."}
            EndIf          
            killedRows - 1 ; we kill one line less in this case
          Else
            log_Print{"changing last line to: " + strline$}
            *tempLine = PED_ReplaceSourceLine{*tempLine, *newLine}
            If *tempLine = 0
              log_Print{"Could not cut selected block."}
            EndIf
            Goto skip_killofline
          EndIf
        EndIf
      EndIf

      ;-- remove the sourcelines
      If *tempLine
        strline$ = PED_Detokenize{*tempLine}
        log_Print{Str$(si) + " deleting " + Left$(strline$, 20)}
        If PED_CutSourceLine{*tempLine} Then PED_DeleteSourceLine{*tempLine}
        killedRows + 1 
        skip_killofline: 
      Else
        log_Print{"no linepointer to delete!", #log_error}
      EndIf
      *tempLine = *nextLine
    Next si
    \CurrentSourceLine = *tempLine
    \SourceChanged = $FFFF
  EndIf 

  ;-- remove block selection
  PED_DrawBlockmark{}
  !PED_ResetBlockflag

  ;-- adjust the display
  \Column = \BlockStartX
  ;-- check if we have to move the DisplayLineOffset
  If \DisplayLineOffset + \DisplayLine > \TotalLines
    \TotalLines - 1
    \DisplayLineOffset = \TotalLines
    \DisplayLine = 0
  Else
    If (\DisplayLineOffset + \DisplayLine) > \BlockStartY AND (\DisplayLineOffset + \DisplayLine) > \BlockEndY
      log_Print{"move cursor " + Str$(killedRows) + " lines up, current displayline: " + Str$(\DisplayLine)}
      If \DisplayLine - killedRows < 0
        \DisplayLineOffset - killedRows
        If \DisplayLineOffset < 0
          \DisplayLine + \DisplayLineOffset
          \DisplayLineOffset = 0
        EndIf
      Else  
        \DisplayLine - killedRows
      EndIf
    EndIf
  EndIf

  ;log_Print{"Kill finished, totallines left: " + Str$(\TotalLines + 1)}
  PED_SetCurrentSourceLine{}
  PED_RedrawSource{}    
End Statement

Statement PED_CutBlock{}
SHARED ped
  If ped\ptrCurrentSourceData\BlockEndY = $FFFFffff Then Statement Return

  PED_CopyBlock{}
  PED_KillBlock{}
End Statement

Statement PED_PasteBlock{blockfile.s}
SHARED ped, readcache

  If blockfile = ""
    ;-- clipboard mode
    log_Print{"reading from clipboard"}
    If NOT PED_ReadClipboard{}
      log_Print{"clipboard is empty"}
      Statement Return
    EndIf
  Else
    ;-- blockfile mode
    log_Print{"reading from file <" + blockfile + ">"}
    ped\sourceFileHandle = PED_OpenFile{blockfile,#HUNK_RELOC_16__MODE_OLDFILE,False}
    If NOT PED_ReadFileCache{}
      PED_CloseFile{ped\sourceFileHandle}
      Statement Return
    EndIf
  EndIf

  ped\labelListChanged = True

  lineaddr.l = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset
  actualColumn.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset

  ; -- get first part of current line
  ped\inString = 0
  beginString.s = ""
  For p.w = 0 To actualColumn - 1
    currentbyte.b = Peek.b(lineaddr + p)
    If currentbyte = $22 Then ped\inString = NOT ped\inString
    If NOT ped\inString Then currentbyte = currentbyte BitClr 7
    beginString + Chr$(currentbyte)
  Next p

  ;-- get rest of current line
  restString.s = ""
  For p.w = actualColumn To #MAX_Columns-1
    currentbyte.b = Peek.b(lineaddr + p)
    restString + Chr$(currentbyte)
  Next p
  restString = StripTrail$(restString,@" ")

  ;-- get first line and join it with currentline
  beginString = beginString + PED_ReadNextLine{}

  ;-- check labelIdentifier, update labellist ?
  If PED_CheckLabelRelevance{beginString} Then ped\labelListChanged = True

  ;-- replace line with current one
  newline$ = PED_TokenizeText{beginString}
  *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
  PED_ReplaceCurrentSourceLine{*newLine}

  storeCurrentSourceLine.l = ped\ptrCurrentSourceData\CurrentSourceLine

  ;-- import all further lines
  morelines.b = False
  pasteString.s = ""
  Repeat
    tmpLine.s = PED_ReadNextLine{}
    tmpLen.w = FLen(tmpLine)
    If tmpLine <> "NoCOntenTwasDelivered"
      morelines = True
      If ped\verticalCopyMode
        If actualColumn > #MAX_Columns-10 Then actualColumn = #MAX_Columns-10
        pasteString = SPACE$(actualColumn)
        pasteString = pasteString + tmpLine
      Else
        pasteString = tmpLine
      EndIf
      newline$ = PED_TokenizeText{pasteString}
      *newLine.sourceLine = PED_CreateNewSourceLine{newline$}

      PED_AppendSourceLine{ped\ptrCurrentSourceData\CurrentSourceLine, *newLine}
      ped\ptrCurrentSourceData\CurrentSourceLine = *newLine

      ;ped\ptrCurrentSourceData\DisplayLine + 1                           ;-> increase displayline if cursor should walk with inserted lines
    Else
      tmpLen = 0
    EndIf
  Until tmpLen = 0 AND (readcache\moreBytes = False)

  ;-- add the rest to an new line or append to pasted text
  If FLen(restString) > 0
    If morelines
      newline$ = PED_TokenizeText{restString}
      *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
      PED_AppendSourceLine{ped\ptrCurrentSourceData\CurrentSourceLine,*newLine}
    Else
      restString = beginString + pasteString + restString
      newline$ = PED_TokenizeText{restString}
      *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
      PED_ReplaceCurrentSourceLine{*newLine}
      storeCurrentSourceLine = *newLine
    EndIf
  ;Else
  ;  log_Print{"no restString: " + restString}
  EndIf
  ped\ptrCurrentSourceData\CurrentSourceLine = storeCurrentSourceLine

  If blockfile <> "" Then PED_CloseFile{ped\sourceFileHandle}

  ped\inString = False

  !PED_ResetBlockflag
  PED_RedrawSource{}
  PED_UpdateStatusArea{}
End Statement 


Statement PED_SetBlockStart{}
SHARED ped
USEPATH ped\ptrCurrentSourceData
  storeBlockStartX      = \ColumnsOffset + \Column
  \BlockStartDisplayLine = \DisplayLineOffset + \DisplayLine
  log_Print{"set blockstart to: " + Str$(storeBlockStartX) + "," + Str$(\BlockStartDisplayLine)}

End Statement

Statement PED_SetBlockEnd{}
SHARED ped
USEPATH ped\ptrCurrentSourceData
  If storeBlockStartX < 0
    log_Print{"setblockend: no blockstart set!"}
  Else
    log_Print{"setblockend"}

    ;-- remove old blockselection
    PED_DrawBlockmark{}

    endX.w = \ColumnsOffset + \Column
    endY.l = \DisplayLineOffset + \DisplayLine
    If (endX = storeBlockStartX) AND (endY = \BlockStartDisplayLine)
        log_Print{"blockstart is equal to blockend position, resetting block"}
        !PED_ResetBlockflag
        Statement Return
    EndIf
    
    ;-- cursor is most left, so select the whole line ?
    If (endX = 0) AND (endY > 0)
      If \BlockStartDisplayLine >= endY
        ;\BlockStartDisplayLine - 1
        endX = #MAX_Columns - 1
      Else
        endY - 1
        endX = #MAX_Columns - 1
      EndIf
    EndIf

    \BlockStartX = storeBlockStartX
    \BlockStartY = \BlockStartDisplayLine
    \BlockEndX = endX
    \BlockEndY = endY
    PED_NormalizeBlockmarkDimensions{}

    ;-- draw updated blockselection    
    PED_DrawBlockmark{}
  EndIf
End Statement



Function.w getLineLength{lineaddr.l}
  _length.w = #MAX_Columns - 1
  exit_loop.b = False

  Repeat
    char.b = Peek.b(lineaddr + _length)
    If char <> $20
      exit_loop = True
    Else
      _length - 1
    EndIf
  Until exit_loop OR _length < 1
  _length + 1
  Function Return _length
End Function

Statement PED_GotoLine{lineNum.l, @columnMode.b}
SHARED ped, sourceWindow
USEPATH ped\ptrCurrentSourceData

  If lineNum.l < 0 Then lineNum = 0
  If lineNum > \TotalLines - 1 Then lineNum = \TotalLines - 1

  ;-- same code as in routine mouseclick_in_source
  *tempLine.sourceLine = \CurrentSourceLine
  newLinenum.l = \DisplayLine + \DisplayLineOffset
  ;log_Print{"Gotoline: " + Str$(lineNum) + " current line:" + Str$(newLinenum)}

  While lineNum <> newLinenum
    If lineNum > newLinenum
      If *tempLine\nextLine
        *tempLine = *tempLine\nextLine
        newLinenum + 1
      Else
        log_Print{"GotoLine: no next line!",#log_error}
        error{"GotoLine: no next line!"}
        lineNum = \TotalLines - 1
        newLinenum = lineNum
      EndIf
    Else
      *tempLine = *tempLine\previousLine
      newLinenum - 1
    EndIf
  Wend
  \CurrentSourceLine = *tempLine

  ;-- adjust the display and offset to match the new current line
  tmpDisplayLineOffset.l = \DisplayLineOffset

  \DisplayLineOffset = 0
  \DisplayLine       = lineNum
  If (newLinenum > 0) AND (\TotalLines > sourceWindow\visibleLines)
    firstrow.l = \TotalLines - sourceWindow\visibleLines
    If lineNum > firstrow
      firstrow = firstrow
      \DisplayLineOffset = firstrow
      \DisplayLine       = newLinenum - firstrow
    Else
      \DisplayLineOffset = newLinenum
      \DisplayLine       = 0
    EndIf 
  EndIf

  Select columnMode
  Case #LINE_START
    \ColumnsOffset = 0
    \Column = 0
  Case #LINE_END
    strline.s = PED_Detokenize{\CurrentSourceLine}
    \Column = FLen(strline)
    PED_CalculateColumnsOffset{}
    ;log_Print{"set new cursor column to: " + Str$(\ColumnsOffset + \Column)}
  Case #LINE_NOCHANGE  
  End Select

  !PED_UpdateTextBufferOffset
  If tmpDisplayLineOffset <> \DisplayLineOffset
    PED_RedrawSource{}
  Else
    PED_CursorOff{}
    PED_CursorOn{}
  EndIf
  PED_UpdateStatusArea{#STATUS_SCROLLERS}
End Statement

Function.b PED_GotoLineAddress{ptrSourceLine.l}
SHARED ped, sourceWindow
  found.b = False
  If ped\ptrCurrentSourceData\TotalLines > 1
    *nextline.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
    lineNum.l = 0
    While *nextline AND (found = False)
      If ptrSourceLine = *nextline Then found = True
      If found = False
        *nextline = *nextline\nextLine
        lineNum + 1
      EndIf
    Wend
    If found
      PED_GotoLine{lineNum, #LINE_START}
      PED_UpdateStatusArea{#STATUS_SCROLLERS}
    EndIf
  EndIf
  Function Return found
End Function


Statement PED_ScrollDelay{}
SHARED ped
  CNIF #slowdown <> 0
    If ped\no_scrollrate
      Delay_ 1
    Else
      vvblank_Wait{}
      vvblank_WaitSync{1}
      vvblank_ResetSync{}
    EndIf
  CEND
End Statement


Statement PED_ScrollHorizontal{direction.b, @scrollMode.b}
SHARED sourceWindow, ped, AB3Pen()
USEPATH sourceWindow

  ;----------------------------- scroll screen  
  dx.w = direction * (\font\tf_XSize * \scrollSize)
  dy.w = 0

  If scrollMode = #SCROLL_CURRENT_LINE
    xMin.w = \BoxLeft + \font\tf_XSize * ped\ptrCurrentSourceData\Column
    yMin.w = \BoxTop  + \font\tf_YSize * ped\ptrCurrentSourceData\DisplayLine
    xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
    yMax.w = yMin + \font\tf_YSize - 1
  Else
    xMin.w = \BoxLeft
    yMin.w = \BoxTop
    xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
    yMax.w = \BoxTop  + sourceWindow\visibleLines * \font\tf_YSize - 1
  EndIf

  SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax
  PED_ScrollDelay{}

  If scrollMode = #SCROLL_CURRENT_LINE Then Statement Return

  ;--------------------------------------------
  ;-- draw the new lines after scrolling left or right
  PED_RedrawTextbuffer{direction}
End Statement

Statement PED_ScrollVertical{direction.b, @yStart.w}
SHARED sourceWindow, ped, AB3Pen()
USEPATH sourceWindow
  ;-- yStart optionally sets the line where to start to scroll up or down 
  ;-- e.g. yStart=6 means scrolling starts at line 6
  ;-- #MAX_Colums is 250 atm
  If yStart = -1 Then yStart = 0

  ;----------------------------- scroll screen  
  dx.w = 0
  dy.w = direction * \font\tf_YSize
  xMin.w = 0
  yMin.w = \BoxTop + yStart * \font\tf_YSize
  xMax.w = \BoxLeft + \visibleColumns * \font\tf_XSize - 1
  yMax.w = \BoxTop + sourceWindow\visibleLines * \font\tf_YSize - 1
  SetBPen_ \win\RPort,AB3Pen(#AB3_cbackground)  
  ScrollRaster_ \win\RPort,dx,dy,xMin,yMin,xMax,yMax
  PED_ScrollDelay{}

  ;----------------------------- "scroll" the textbuffer one line
  If direction = #SCROLL_DOWN 
    destAddr.l = ped\ptrTextbuffer + (#MAX_Columns * (sourceWindow\visibleLines-1))
  Else 
    destAddr.l = ped\ptrTextbuffer + (#MAX_Columns * yStart)
  EndIf
  startAddr.l = destAddr + (#MAX_Columns * direction)

  numberofRows2Copy.l = (sourceWindow\visibleLines - 1) - yStart
  For r.w = 1 To numberofRows2Copy
    CopyMem_ startAddr, destAddr, #MAX_Columns
    destAddr + (#MAX_Columns * direction)
    startAddr + (#MAX_Columns * direction)
  Next r

  ;-- prepare the new displayed line with spaces    
  ;FillMem destAddr, #MAX_Columns, @" "
  MemCls destAddr, #MAX_Columns, @" "

  ;--------------------------------------------
  ;-- draw the new lines after scrolling at top or bottom
  !PED_storeCursorPosition 
  storeCurrentSourceLine.l = \CurrentSourceLine

  If direction = #SCROLL_DOWN
    ;-- get the new sourceline that has to be displayed at the top
    Repeat 
      If \DisplayLine > 0
        \DisplayLine + direction
        \CurrentSourceLine = \CurrentSourceLine\previousLine

        If \CurrentSourceLine = 0
          log_Print{"PED_ScrollVertical(): there is no line to display!"}        
          Pop If : Pop Repeat : Goto no_line
        EndIf
      End If
    Until \DisplayLine = 0
    \TextBufferOffset = 0 ; we print at the first line into the textbuffer
  Else
    ;-- get the new sourceline that has to be displayed at the bottom
    Repeat
      If \DisplayLine < (sourceWindow\visibleLines-1)
        \DisplayLine + direction
        \CurrentSourceLine = \CurrentSourceLine\nextLine

        If \CurrentSourceLine = 0
          log_Print{"PED_ScrollVertical(): there is no line to display!"}        
          Pop If : Pop Repeat : Goto no_line
        EndIf
      EndIf
    Until \DisplayLine = (sourceWindow\visibleLines-1)
    \TextBufferOffset = #MAX_Columns * (sourceWindow\visibleLines-1) ; we print at the last line into the textbuffer
  EndIf

  ;-- display the calculated source line at the displayline
  PED_PrintCurrentSourceLine{False}

  no_line:
  If (direction = #SCROLL_UP) AND (ped\ptrCurrentSourceData\TotalLines < sourceWindow\visibleLines)
    PED_UpdateLinenumbers{#FULL}
  Else 
    PED_UpdateLinenumbers{}
  EndIf
  \CurrentSourceLine = storeCurrentSourceLine
  !PED_RestoreCursorPosition
End Statement


Function.b PED_CheckFoldingState{}
SHARED ped
  If ped\currentSourceEntry\FirstSourceLine <> 0
    foldstatus.b = 0
    *tmpcsl.sourceLine = ped\currentSourceEntry\FirstSourceLine
    While *tmpcsl <> ped\currentSourceEntry\CurrentSourceLine
      If Peek.w(*tmpcsl + 9) = @";@"
        foldstr.w = Peek.w(*tmpcsl + 11)
        Select foldstr
        Case @"@1" : foldstatus = 1
        Case @"@0" : foldstatus = 0
        End Select
      EndIf
      *tmpcsl = *tmpcsl\nextLine
    Wend
    Function Return foldstatus
  Else
    Function Return 0
  EndIf
End Function

Function.l PED_CheckFoldingReverse{*tmpLine.sourceLine}
SHARED ped
  ped\foldNumber = 0
  linePtr.l = 0

  log_Print{"check line:  [" + Peeks$(*tmpLine + 9,8) + "]"}
  marker.s = Peeks$(*tmpLine + 11,2)
  If marker = "@0"
    ped\foldNumber = 0
    *tmpPrev.sourceLine = *tmpLine\previousLine
    While *tmpPrev
      marker2.s = Peeks$(*tmpPrev + 9,4)
      If Left$(marker2,2) = ";@"
        log_Print{" found a marker upwarts: " + marker2}
        If Right$(marker2,2) = "@1"
          ped\foldNumber = 1
          linePtr = *tmpPrev
          Pop If: Pop If : Pop While
          Goto exit_while
        EndIf
        If Right$(marker2,2) = "@0"
          Goto exit_while
        EndIf
      EndIf
      *tmpPrev = *tmpPrev\previousLine
    Wend
    exit_while:
  EndIf

  If marker = "@1" Then ped\foldNumber = 0

  Function Return linePtr
End Function


Statement PED_MoveCursorUp{}
SHARED ped
  PED_HandleBlockmark{}

  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *prevLine.sourceLine = *currentLine\previousLine

  If *prevLine = 0
    log_Print{"there is no previous line."}
    Statement Return
  EndIf

  ;tmps.s = PED_Detokenize{\CurrentSourceLine}
  ;log_Print{"current: " + Str$(\DisplayLine+\DisplayLineOffset+1) + " | " +Str$(\DisplayLine)+"-" + Str$(\DisplayLineOffset) + " >> " + Left$(tmps,20)}
  If Peeks$(*currentLine + 9,4) = ";@@0"
    log_Print{"jump marker found, searching corresponding previous marker."}
    *_prev.sourceLine = *currentLine
    linePtr.l = PED_CheckFoldingReverse{*_prev}
    If linePtr <> 0
      log_Print{"previous marker for [" + Peeks$(*_prev + 9,4) + "] found, jumping to that line."}
      Repeat
        *_prev = *_prev\previousLine
        ped\ptrCurrentSourceData\DisplayLineOffset - 1
      Until *_prev = linePtr
      ped\ptrCurrentSourceData\CurrentSourceLine = *_prev
      PED_RedrawSource{}
      Statement Return
    EndIf
  EndIf

  PED_CursorOff{}
  ped\ptrCurrentSourceData\CurrentSourceLine = *prevLine    
  If PED_DecreaseDisplayLine{} = 1 ;-- check if we have to scroll the source window
    PED_ScrollVertical{#SCROLL_DOWN}
    PED_UpdateStatusArea{#STATUS_SCROLLERS}
  EndIf
  PED_CursorOn{}
End Statement


Statement PED_MoveCursorDown{}
SHARED ped

  PED_HandleBlockmark{}

  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *nextLine.sourceLine = *currentLine\nextLine

  If *nextLine = 0
    log_Print{"there is no next line."}
    Statement Return
  EndIf

  If Peeks$(*currentLine + 9, 4) = ";@@1"
    log_Print{"jump marker found, searching corresponding next marker."}
    tmpDLO.l = ped\ptrCurrentSourceData\DisplayLineOffset
    *_next.sourceLine = *nextLine
    While *_next
      ped\ptrCurrentSourceData\DisplayLineOffset + 1
      If Peeks$(*_next + 9,4) <> ";@@1"
        If Peeks$(*_next + 9,4) = ";@@0"
          ped\ptrCurrentSourceData\CurrentSourceLine = *_next
          PED_RedrawSource{}
          Statement Return
        EndIf
      EndIf
      *_next = *_next\nextLine
    Wend
    ped\ptrCurrentSourceData\DisplayLineOffset = tmpDLO
  EndIf

  PED_CursorOff{}
  ped\ptrCurrentSourceData\CurrentSourceLine = *nextLine
  If PED_IncreaseDisplayLine{} = 1
    PED_ScrollVertical{#SCROLL_UP}
    PED_UpdateStatusArea{#STATUS_SCROLLERS}        
  EndIf
  PED_CursorOn{}
End Statement


Statement PED_MoveCursorLeft{}
SHARED ped, sourceWindow

  PED_CursorOff{}
  If ped\ptrCurrentSourceData\Column > sourceWindow\boundLinesX
    ped\ptrCurrentSourceData\Column - 1
  Else
    If ped\ptrCurrentSourceData\ColumnsOffset > 1
      ped\ptrCurrentSourceData\ColumnsOffset - sourceWindow\scrollSize
      PED_ScrollHorizontal{#SCROLL_RIGHT}
      ;ped\ptrCurrentSourceData\Column + 1
    Else
      If ped\ptrCurrentSourceData\ColumnsOffset = 1
        ped\ptrCurrentSourceData\ColumnsOffset = 0
        PED_ScrollHorizontal{#SCROLL_RIGHT}
      Else
        If ped\ptrCurrentSourceData\Column > 0
          ped\ptrCurrentSourceData\Column - 1
        EndIf
      EndIf
    EndIf
  EndIf

  PED_UpdateStatusArea{#STATUS_SCROLLERS|#STATUS_CURSOR}
  PED_CursorOn{}
End Statement

Statement PED_MoveCursorRight{}
SHARED ped, sourceWindow

  PED_CursorOff{}
  If ped\ptrCurrentSourceData\ColumnsOffset + sourceWindow\visibleColumns => #MAX_Columns
    If ped\ptrCurrentSourceData\Column < sourceWindow\visibleColumns-1
      ped\ptrCurrentSourceData\Column + 1
    EndIf
  Else
    If sourceWindow\boundLinesX <= ped\ptrCurrentSourceData\Column
      If ped\ptrCurrentSourceData\Column > sourceWindow\visibleColumns - sourceWindow\boundLinesX
        ped\ptrCurrentSourceData\ColumnsOffset + sourceWindow\scrollSize
        PED_ScrollHorizontal{#SCROLL_LEFT}
        Goto exit_cursorright
      EndIf
    EndIf
    ped\ptrCurrentSourceData\Column + 1
  EndIf
  exit_cursorright:
  PED_UpdateStatusArea{#STATUS_SCROLLERS|#STATUS_CURSOR}
  PED_CursorOn{}
End Statement

Statement PED_MoveCursorToX{newColumn.w}
SHARED ped, sourceWindow
  ;log_Print{"move cursor to column: "  + Str$(newColumn)}

  PED_CursorOff{}
  oldColumnsOffset.w = ped\ptrCurrentSourceData\ColumnsOffset

  If newColumn <= sourceWindow\visibleColumns - sourceWindow\boundLinesX
    ped\ptrCurrentSourceData\ColumnsOffset = 0
    ped\ptrCurrentSourceData\Column = newColumn
  Else
    ped\ptrCurrentSourceData\ColumnsOffset = newColumn - (sourceWindow\visibleColumns - 1)
    ped\ptrCurrentSourceData\Column = newColumn - ped\ptrCurrentSourceData\ColumnsOffset
    ;log_Print{"cursor out of visible area, calculating offset to " + Str$(ped\ptrCurrentSourceData\ColumnsOffset)}
  EndIf

  If ped\ptrCurrentSourceData\ColumnsOffset <> oldColumnsOffset
    PED_RedrawTextbuffer{#FULL_REDRAW}
  EndIf

  PED_UpdateStatusArea{#STATUS_CURSOR|#STATUS_SCROLLERS}
  PED_CursorOn{}
End Statement


Statement PED_GetMousePos{*mp.mousePos}
  SHARED sourceWindow
  USEPATH sourceWindow

  *mp\X = \win\MouseX - \win\BorderLeft + 1
  *mp\Y = \win\MouseY - \win\BorderTop + 1
  If *mp\X < 0 Then *mp\X = 0
  If *mp\Y < 0 Then *mp\Y = 0

  If (*mp\X > \BoxLeft)
    *mp\textX = *mp\X - \BoxLeft
    If *mp\textX < 0 Then *mp\textX = 0
    *mp\textX = *mp\textX / \font\tf_XSize
  Else
    *mp\textX = -1
  EndIf

  If (*mp\Y > \BoxTop)
    *mp\textY = *mp\Y - \BoxTop
    If *mp\textY < 0 Then *mp\textY = 0
    *mp\textY = *mp\textY / \font\tf_YSize
  Else
    *mp\textY = -1
  EndIf

  ;msg$ = Str$(*mp\X) +  ", " + Str$(*mp\Y) + " - "
  ;msg$ + Str$(*mp\textX) + ", " + Str$(*mp\textY)
  ;msg$ + " / storeXY: " + Str$(storeX.w) + ", " + Str$(storeY.l)
  ;PED_ShowMessage{msg$}
End Statement

Statement PED_HistoryAddEntry{}
SHARED ped
  ped\historyTable[ped\historyPointer] = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
  ped\historyPointer + 1
  If ped\historyPointer >= #maxhistory Then ped\historyPointer = 0
  log_Print{"adding historypointer " + Str$(ped\historyPointer) + ", line " + Str$(ped\historyTable[ped\historyPointer])}
End Statement

Statement HistoryUp{}
End Statement


Function.w PED_SearchString{searchStr.s, casesensitive.b, startpos.w, *currentLine.sourceLine}
SHARED ped
 
  strline.s = Peek.s(*currentLine + 9)
  If FLen(strline) = 0 Then Function Return 0
  strline = PED_DetokenizeText{strline}
  ;log_Print{"searching for [" + searchStr +"] in >> " + strline}

  If casesensitive Then CaseSense True Else CaseSense False
  Function Return Instr(strline, searchStr, startpos)
End Function

Function.b PED_ReplaceString{search.s, replacement.s, *currentLine.sourceLine}
SHARED ped,sourceWindow

  success.b = False

  tmpX.w = PED_SearchString{search, 0, 1, *currentLine}
  If tmpX > 0
    ;log_Print{"[" + search + "] found in line, replacing with [" + replacement + "]"}
    strline.s = Peek.s(*currentLine + 9)
    strline = PED_DetokenizeText{strline}
    replacedline.s = Replace$(strline, search, replacement)
    replacedline.s = PED_TokenizeText{replacedline}
    If FLen(replacedline) > #MAX_Columns Then replacedline = Left$(replacedline,#MAX_Columns)

    *previousLine.sourceLine = *currentLine\previousLine
    If PED_CutSourceLine{*currentLine}
      *newLine.sourceLine = PED_CreateNewSourceLine{replacedline}
      PED_AppendSourceLine{*previousLine,*newLine}
      ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
      PED_DeleteSourceLine{*currentLine}
      success = True
    Else
      error{"Could not replace the current source line"}
    EndIf
  EndIf
  Function Return success
End Function

Statement PED_InsertReturn{@count.w}
SHARED ped, sourceWindow, pedconfig
USEPATH ped\ptrCurrentSourceData

  If \BlockEndY <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : PED_HandleBlockmark{}
  EndIf

  sourceWindow\redrawFlag = True

  If count = -1 Then count = 1

  For i.b = 1 To count
    ;-- SHIFT pressed as well ? 
    If (\QualifierStore AND 3) <> 0
      ;-- if pressed, do not split current line at cursor pos but insert a new line before the current line!
      Gosub appendline
    Else
      ;log_Print{"split current line at column position, BlockEndY = " + Hex$(\BlockEndY)}
      Gosub splitlines
    EndIf
  Next i

  Statement Return

 .splitlines:
  ;log_Print{"splitlines"}

  ;-- split the current line at the column position
  USEPATH ped\ptrCurrentSourceData

  tmpColumn.w = \ColumnsOffset + \Column
  tmpColumnsOffset.w = \ColumnsOffset

  lineaddr.l = ped\ptrTextbuffer + \TextBufferOffset

  ;-- check the spaces at the beginning to auto indent the next line
  \Column = 0
  If pedconfig\auto_indent
    While Peek.b(lineaddr + \Column) = $20 AND (\Column < #MAX_Columns)
      \Column + 1
    Wend
    If \Column = #MAX_Columns Then \Column = 0
  EndIf 

  ;-- calculate ColumnsOffset
  PED_CalculateColumnsOffset{}  

  ;-- get the string until cursorposition
  restString.s = ""
  ; add spaces for auto indentation: align to beginning of current line
  If pedconfig\auto_indent AND \Column <> 0 Then restString.s = SPACE$(\Column)

  ;-- save rest of line and remove from current line / update the text buffer
  For tcol.w = tmpColumn To #MAX_Columns - 1
    restString + Chr$(Peek.b(lineaddr + tcol))    ; copy rest of line to parsebuffer
    Poke.b lineaddr + tcol, $20                   ; remove rest of Line from textbuffer
  Next tcol
  restString = StripTrail$(restString, @" ")

  ;-- update current line, that means break the line at cursor position
  ;-- and move the text right of the cursor into a new line right behinde the current one
  strline$ = StripTrail$(Peeks$(lineaddr,#MAX_Columns),@" ")
  strline$ = PED_TokenizeText{strline$}
  *newLine.sourceLine = PED_CreateNewSourceLine{strline$}
  PED_ReplaceCurrentSourceLine{*newLine}

  ;-- append rest of line as new line
  newline$ = PED_TokenizeText{restString}
  *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
  If *newLine
    PED_UpdateBlockPosY{\DisplayLineOffset + \DisplayLine}

    If PED_AppendSourceLine{\CurrentSourceLine,*newLine}
      If tmpColumnsOffset <> \ColumnsOffset
        log_Print{"reset columnsoffset, redraw with offset"}
        PED_RedrawSource{}
      Else
        PED_CursorOff{}
        PED_ScrollVertical{#SCROLL_DOWN, \DisplayLine}
        PED_PrintCurrentSourceLine{True} ; update the old line
      EndIf
      PED_MoveCursorDown{}
      PED_CursorOff{}
      PED_PrintCurrentSourceLine{True} ; draw the new line
      PED_CursorOn{}      
      PED_UpdateStatusArea{#STATUS_SCROLLERS}  
    Else
      error{"Couldn't append sourceline!"}      
    EndIf
  EndIf
  Return

.appendline:
  ;-- don't split the current line but insert a new line after it!
  USEPATH ped\ptrCurrentSourceData  
  log_Print{"appendline"}


  tmpColumnsOffset.w = \ColumnsOffset

  ;-- check the spaces at the beginning to auto indent the next line
  \Column = 0
  If pedconfig\auto_indent
    \Column = -1
    Repeat
      \Column + 1
    Until Peek.b(\CurrentSourceLine + 9 + \Column) <> $20
    log_Print{"indent after return: " + Str$(\Column)}
  EndIf

  ;-- calculate ColumnsOffset
  If \ColumnsOffset > 0
    \ColumnsOffset = 0
    If \Column > sourceWindow\visibleColumns
      \Column - sourceWindow\visibleColumns
      \ColumnsOffset = sourceWindow\visibleColumns
      If \Column > sourceWindow\visibleColumns
        \Column - sourceWindow\visibleColumns
        \ColumnsOffset + sourceWindow\visibleColumns
      EndIf
    EndIf
    log_Print{"calculated new columnsoffset: " + Str$(\ColumnsOffset)}
  EndIf

  *newLine.sourceLine = PED_CreateNewSourceLine{""}
  If *newLine 
     PED_UpdateBlockPosY{\DisplayLineOffset + \DisplayLine}

    If PED_AppendSourceLine{\CurrentSourceLine, *newLine}
      ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
      If PED_IncreaseDisplayLine{}
       PED_CursorOff{}
       If tmpColumnsOffset <> \ColumnsOffset
          log_Print{"reset columnsoffset, redraw source"}
          PED_RedrawSource{}
        Else
          PED_ScrollVertical{#SCROLL_DOWN,\DisplayLine}
          PED_PrintCurrentSourceLine{False}
        EndIf
        PED_CursorOn{}
        PED_UpdateStatusArea{#STATUS_SCROLLERS}
      EndIf
    Else
      error{"Couldn't append sourceline!"}
    EndIf
  Else
    Pop If
    Goto memAlert_CloseSource
  EndIf
  Return 
End Statement

Statement PED_InsertCharToTextBuffer{char.b}
SHARED ped
USEPATH ped\ptrCurrentSourceData
 
  If \BlockEndY <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : PED_HandleBlockmark{}
  EndIf

  ;-- move everything right from cursor 1 to right
  lineaddr.l = ped\ptrTextbuffer + \TextBufferOffset
  actualColumn.w = \Column + \ColumnsOffset
  tmpColumn.w = #MAX_Columns - 1
  While tmpColumn > actualColumn
    tmpColumn - 1
    Poke.b lineaddr + tmpColumn, Peek.b(lineaddr + tmpColumn - 1)
  Wend

  PED_CursorOff{}
  PED_ScrollHorizontal{#SCROLL_RIGHT, #SCROLL_CURRENT_LINE}
  PED_PrintChar{char} : \KeyBeforeReturn = char
  PED_CursorOn{}

  PED_MoveCursorRight{}
End Statement


Statement PED_InsertStringToTextBuffer{str.s}
SHARED ped
  If str = "" Then Statement Return

  ; --
  ; -- check for a comment
  i.w = SearchBegin(str, @";", 1)
  If i Then str = Left$(str,i - 2)

  If str <> ""
    For i = 1 To FLen(str)
      If ped\ptrCurrentSourceData\Column < $7d      ;#MAX_Columns - 1
        PED_InsertCharToTextBuffer{ Asc(Mid$(str,i,1)) }
      EndIf
    Next i
  EndIf
End Statement


Function.s autoCompleteContructs{*currentline.sourceLine}

  If *currentline = 0 Then Function Return ""

  construct.s = ""

  *prevLine.sourceLine = *currentline\previousLine

  If *prevLine <> Null
    *textline.l = *prevLine + 9     ; get pointer of previus sourceline text
    If *textline <> Null
      lasttoken.w = 0
      acttoken.w = 0
      bytecount.w = 0

      Repeat
        acttoken = Peek.w(*textline + bytecount) AND $FFFF

        ;-- check the token to select the end token(s)
        If acttoken < 0 
          log_Print{"found token " + Hexw$(acttoken)+ ",last token " + Hexw$(lasttoken)}
          Select acttoken
            Case #TOKEN_Then      : construct = "" ; remove completion for If
            Case #TOKEN_Return    : construct = "" ; remove completion for Function/Statement
            Case #TOKEN_Statement : construct = "End Statement"
            Case #TOKEN_Function  : construct = "End Function"
            Case #TOKEN_Macro     : construct = "End Macro"            
            Case #TOKEN_If        : If Hexw$(lasttoken) <> Hexw$(#TOKEN_End) AND Hexw$(lasttoken) <> Hexw$(#TOKEN_Pop) Then construct = "EndIf"
            Case #TOKEN_While     : If Hexw$(lasttoken) <> Hexw$(#TOKEN_Pop) Then construct = "Wend"
            Case #TOKEN_Select    : If Hexw$(lasttoken) <> Hexw$(#TOKEN_Pop) Then construct = "End Select"
            Case #TOKEN_Repeat    : If Hexw$(lasttoken) <> Hexw$(#TOKEN_Pop) Then construct = "Until"
            Case #TOKEN_For       : If Hexw$(lasttoken) <> Hexw$(#TOKEN_Pop) Then construct = "Next"            
          End Select
          lasttoken = acttoken
          bytecount + 1
        EndIf
        
        bytecount + 1

      Until (acttoken = 0) OR (bytecount = #MAX_Columns - 1)
    EndIf
  EndIf

  Function Return construct
End Function


Function.w PED_PreparseTextLine{lineaddr.l}
  SHARED ped, pedconfig, operators$(),num_operators

  ;--  clear token flags but dont trash strings
  !removeTokenbits{lineaddr, #MAX_Columns}

  strg$ = Peeks$(lineaddr,#MAX_Columns)
  absColumnPos.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset

  ; --
  ; -- checking if editing a comment
  kommata.w  = Instr(strg$,";")
  If kommata AND (kommata < absColumnPos)
    ped\ptrCurrentSourceData\Column = absColumnPos - ped\ptrCurrentSourceData\ColumnsOffset
    Function Return absColumnPos
  EndIf

  ; --
  ; -- continue to preparse & optimize entered string
  ; --
  line_changed.b = False

  strg$ = StripTrail$(strg$,@" ")
  len_strg.w = FLen(strg$)

  ; --
  ; -- replace lower written functionames with correct cases
  If pedconfig\correct_functions
    newstrg$ = strg$
    startAt.w = 0                                               ; added to make a test of the complete line and begin at position 0  tomsmart1
    Repeat                                                         ; added loop to test the complete line  tomsmart1
      bracketPos.w = Instr(strg$,"{",startAt)

      If bracketPos > 1
        startOfName.l = bracketPos

        again:
        log_Print{"searching begin of function name:"}
        Repeat
          startOfName - 1
        Until !IsIllegalChar{Peek.b(&strg$ + startOfName - 1)} OR startOfName = 0
        If Peek.b(&strg$ + startOfName - 1) = @" " AND startOfName = bracketPos-1 Then Goto again
        startOfName + 1

        funcname$ = Mid$(strg$,startOfName, bracketPos - startOfName)
        log_Print{"found function name to correct [" + funcname$ + "] at pos " + Str$(startOfName)}

        funcname$ = Trim$(funcname$)
        newfuncname$ = PED_GetIndexHelp{funcname$, #INDEXHELP_NAME}
        If newfuncname$ <> ""
          If newfuncname$ <> funcname$
            log_Print{"correct function name: " + newfuncname$}

            ;If startOfName > 1
            ;  strg$ = Left$(strg$,startOfName) + newfuncname$ + UnRight$(strg$,bracketPos)
            ;Else
            ;  strg$ = newfuncname$ + UnRight$(strg$,bracketPos)
            ;EndIf

            newstrg$ = Replace$(newstrg$, funcname$, newfuncname$)
            line_changed = True
          EndIf
        Else
          ;log_Print{"no better name found for function name ..."}
        EndIf
        startAt = bracketPos + 1
        If startAt >= FLen(strg$) Then bracketPos = 0
      EndIf
    Until bracketPos = 0
    If line_changed
      log_Print{"replacing function names finished:"}
      log_Print{"o [" + strg$ + "]"}
      log_Print{"n [" + newstrg$ + "]"}
      absColumnPos + (FLen(newstrg$) - FLen(strg$))
      strg$ = newstrg$
    EndIf
  EndIf

  ; -- structurization of source
  If pedconfig\auto_format
    len_strg.w = FLen(strg$)
    neustrg$ = ""
    make_struct.b = On
    For j.w = 1 To len_strg
      double_operator.b = False
      temp_disabled.b = Off
      no_pre_pad.b = Off
      no_post_pad.b = Off
      comment_mode.b = Off

      char$ = Mid$(strg$,j,1)
      If char$<>" "
        For k.w = 0 To num_operators-1
          If char$ = operators$(k)
            For l.w = 0 To num_operators - 1
              If last_op$ = operators$(l) Then double_operator = True
            Next
            If NOT double_operator
              op_found.b = True
              Pop For
              Goto exit_for
            EndIf
          Else
            op_found = False
          EndIf
        Next k
        exit_for:
        If char$ = Chr$(34) Then make_struct = -1 + Abs(make_struct)

        If (op_found = True) AND (last_op$ <> "=")
          last_op$ = char$

          Select char$
            Case ";"      
              comment_mode = On   ; ignore comments

            Case "&"
              temp_disabled = On  ; TODO : check if it is a pointer            
            Case "*"
              temp_disabled = On  ; TODO : check if it is a pointer

            Case "-"      ; eine Zuweisung mit neg. Wert nicht formatieren
              If Mid$(strg$,j - 2,2) = "= " OR Mid$(strg$,j - 1,1) = "="
                temp_disabled = On
              EndIf

            Case "<"
              If Mid$(strg$,j-2,2) = "> " OR Mid$(strg$,j-1,1)=">"
                no_pre_pad = On
              EndIf
              If Mid$(strg$,j+2,2) = "> " OR Mid$(strg$,j+1,1)=">"
                no_post_pad = On
              EndIf

            Case ">"
              If Mid$(strg$,j-2,2) = "< " OR Mid$(strg$,j-1,1)="<"
                no_pre_pad = On
              EndIf
              If Mid$(strg$,j+2,2) = "< " OR Mid$(strg$,j+1,1)="<"
                no_post_pad = On
              EndIf

          End Select

          If make_struct AND (j > 1) AND (NOT temp_disabled) AND (NOT comment_mode = On)
            pad_pre$ = "" : pad_post$ =""
            If Mid$(strg$,j - 1,1) <>" " Then pad_pre$  = " " : absColumnPos + 1
            If Mid$(strg$,j + 1,1) <>" " Then pad_post$ = " " : absColumnPos + 1
            If no_pre_pad                Then pad_pre$  = ""  : absColumnPos - 1
            If no_post_pad               Then pad_post$ = ""  : absColumnPos - 1
            char$ = pad_pre$ + char$ + pad_post$
            line_changed = True
          EndIf
        Else
          last_op$ = ""
        EndIf
      EndIf
      neustrg$ + char$
    Next j
    strg$ = neustrg$
  EndIf

  ; --- write formated textline into textbuffer
  If line_changed
    strg$ = Left$(strg$,#MAX_Columns)
    strg$ + SPACE$(#MAX_Columns - FLen(strg$))
    ;log_Print{"pushing to textbuffer after preparsing: [" + strg$ + "]"}
    log_Print{Peeks$(lineaddr,16)}
    For i.l = 0 To #MAX_Columns-1
      Poke.b lineaddr + i, Peek.b(&strg$ + i)
    Next
    log_Print{Peeks$(lineaddr,16)}
  EndIf

  ;log_Print{"2preparsing: [" + Left$(strg$, 16) + "]"}

  ; --- return new cursorposition if something as changed
  ped\ptrCurrentSourceData\Column = absColumnPos - ped\ptrCurrentSourceData\ColumnsOffset
  Function Return absColumnPos
End Function


Statement savewinpref{layoutNum.l}
  SHARED wpref(),wtemp,pedconfig,sourceWindow

  used_win.l = Used Window
  ret.l = ask{!TRANS{"The window settings have been saved.\\nPress appropriate FN-Key (F4-F6) to set window configuration."},!TRANS{"Ok"},!TRANS{"Info"}}
  USEPATH wtemp

  \lbrowser_on = 0
  \ibrowser_on = 0
  \type_on = 0
  \diag_on = 0
  \click_on = 0
  \short_on = 0
  \activewin = 0

  If WZ_IsOpen{"WIN_LIBRARYBROWSER"}
     Use Window WZID("WIN_LIBRARYBROWSER")
     \lbrowser_x  = WindowX
     \lbrowser_y  = WindowY
     \lbrowser_w  = WindowWidth
     \lbrowser_h  = WindowHeight
     \lbrowser_on = 1
  End If
  If WZ_IsOpen{"WIN_INSTRUCTIONBROWSER"}
     Use Window WZID("WIN_INSTRUCTIONBROWSER")
     \ibrowser_x  = WindowX
     \ibrowser_y  = WindowY
     \ibrowser_w  = WindowWidth
     \ibrowser_h  = WindowHeight
     \ibrowser_on = 1
  End If
  If WZ_IsOpen{"WIN_NEWTYPE"}
     Use Window WZID("WIN_NEWTYPE")
     \type_x  = WindowX
     \type_y  = WindowY
     \type_w  = WindowWidth
     \type_h  = WindowHeight
     \type_on = 1
  End If
  If WZ_IsOpen{"WIN_HELPDIAG"}
     Use Window WZID("WIN_HELPDIAG")
     \diag_x  = WindowX
     \diag_y  = WindowY
     \diag_w  = WindowWidth
     \diag_h  = WindowHeight
     \diag_on = 1
  End If
  If WZ_IsOpen{"WIN_LABELS"}
     Use Window WZID("WIN_LABELS")
     \click_x  = WindowX
     \click_y  = WindowY
     \click_w  = WindowWidth
     \click_h  = WindowHeight
     \click_on = 1
  End If
  If WZ_IsOpen{"WIN_SHORTCUTS"}
     Use Window WZID("WIN_SHORTCUTS")
     \short_x  = WindowX
     \short_y  = WindowY
     \short_w  = WindowWidth
     \short_h  = WindowHeight
     \short_on = 1
  EndIf

  If sourceWindow\win
    \source_x = sourceWindow\win\LeftEdge
    \source_y = sourceWindow\win\TopEdge
    \source_w = sourceWindow\win\Width
    \source_h = sourceWindow\win\Height
  EndIf

  ; -- check if console is open and store its position
  *thisscreen.Screen = Peek.l(Addr Screen(0))
  *conwin.Window = *thisscreen\FirstWindow
;  message{"error"}
  security.l = 0
  If *conwin
    While *conwin <> 0
      If Peek.s(*conwin\Title) <> pedconfig\console_title
        If Peek.l(*conwin) Then *conwin = Peek.l(*conwin) Else *conwin = 0
      Else
        Pop While
        Goto exit_consearch
      EndIf
      ; notbremse fuer while-loop
      security + 1
      If security > 30 Then *conwin = 0
    Wend
  EndIf
  exit_consearch:
  If *conwin
    \console_x = *conwin\LeftEdge
    \console_y = *conwin\TopEdge
    \console_w = *conwin\Width
    \console_h = *conwin\Height
  EndIf
  Use Window used_win
  CopyMem_ &wtemp,&wpref(layoutNum),SizeOf .winprefs
End Statement


Statement write_libmapping{_tokenMappingFile.s}
  SHARED blitzlibMapping()

  If dos_Exist{_tokenMappingFile} Then dos_Delete{_tokenMappingFile}

  fid.l = file_Open{_tokenMappingFile,#file_write}
  If fid <> -1
    log_Print{"writing libslist..."}
    For i.w = 0 To #MAX_Blitzlibs-1
      textline.s = LSet$(blitzlibMapping(i,0),31) + ";" + blitzlibMapping(i,1)
      file_WriteLine{fid,textline}
    Next i
    file_Close{fid}
  EndIf

End Statement


Statement map_tokens_to_libs{_tokenMappingFile.s, _updatefile.b}
  SHARED *tokenbase
  SHARED blitzlibMapping()

  fid.l = file_Open{_tokenMappingFile,#file_read}
  If fid <> -1
    ;-- check content of file, if there is only little garbage, then ignore it
    If file_GetLength{fid} < 5
      file_Close{fid}
      Statement Return
    EndIf
    file_Cache{fid}

    ;-- build the hashmap for faster parsing
    ;-- mapping file must have an empty line at the end!
    log_Print{"building hashmap for tokens with mappingfile [" + _tokenMappingFile + "] ..."}
    *hm_firstTokens.hashmap = hashmap_Create{8}
    lineCounter.w = 0
    Repeat
      row.s = file_ReadLine{fid}
      ;-- ignore comments
      If Left$(row,1) <> "#"
        qpos.w = Instr(row,";")
        If qpos
          ;-- extract library name from current row
          ;-- extract token name of first token in lib
          libName.s = Trim$( Left$(row,qpos - 1) )
          tokenName.s = LCase$(Trim$( Right$(row, FLen(row) - qpos) ))
          ;log_Print{"hasing " + tokenName + " to " + libName}
          If tokenName <> ""          
            hashmap_AddItem{*hm_firstTokens, tokenName, libName}
          Else
            ;-- set the libname directly, as there is no token to map
            blitzlibMapping(lineCounter,0) = libName
          EndIf
        EndIf
      EndIf
      lineCounter + 1
    Until file_EOF{fid}
    file_Close{fid}
    log_Print{"building hashmap done."}

    ;-- run through the tokenindex and map tokens to library names
    log_Print{"scanning tokens ..."}
    *token.tokendata = *tokenbase
    If *token
      libCounter.w = 0
      tokenCounter.l = 0
      oldlibNum.w = -1
      Repeat
        libName.s = ""
        libNum.w    = *token\number LSR 7

        tokenName.s = Peek.s(&*token\dat)
        If tokenName = ""
          log_Print{ "Lib #" + Str$(libNum) + ": nulltoken found , number: " + Str$(*token\number) + ")"}
          !log_HexDump{*token,32}
        EndIf

        If (libNum <> oldlibNum) AND tokenName <> ""
          libCounter + 1
          oldlibNum = libNum

          ;-- check if token is first token of a blitzlib
          libName = hashmap_GetItem{*hm_firstTokens, LCase$(tokenName)}

          ;log_Print{"#" + Str$(libNum) + " [" + libName + "] -  first token [" + tokenName + "]"}

          ;-- check if token is part of library, that is already used
          ;-- if libNum is unused, map libname to libNum
          ;-- if a libNum appears, here a libname has been mapped, we have a libclash!
          If libName = ""
            log_Print{"could not identify libNum #" + Str$(libNum) + " with first token [" + tokenName + "]", #log_warning}
          Else
            ;log_Print{"first token of library #" + Str$(libNum) + " [" + libName + "]: [" + tokenName + "]"}

            If Instr(blitzlibMapping(libNum,0),"unused") = 0
              log_Print{"lib #" + Str$(libNum) + " has already been mapped!",#log_warning}
              message$ = !TRANS{"Library clash!\\n" }
              message$ + !TRANS{"The dynamic added blitzlib"} + " \\22" + libName + "\\22 " + !TRANS{"overwrites the already loaded blitzlib "} + " \\22" + blitzlibMapping(libNum,0)+"\\22\\n\\n"

              message$ + !TRANS{"Both libs have the same Lib-ID"} + " #"+ Str$(libNum) + ".\\n\\n"

              message$ + !TRANS{"Sourcecode that uses that blitzlib might not work, because these functions are now mapped to"} + " \\22" + libName + "\\22.\\n"

              message$ + !TRANS{"You should remove the appropriate library from userlibs-directory,\\nor change the Lib-ID to a free one."}
              dummy.l = ask{message$,!TRANS{"Ok"},!TRANS{"Error"}}
              blitzlibMapping(libNum,0) = libName + " ("+!TRANS{ "clashing with"}+" "+blitzlibMapping(libNum,0)+")"
            Else
              blitzlibMapping(libNum,0) = libName
            EndIf
            blitzlibMapping(libNum,1) = tokenName
          End If
        EndIf
        *token = *token\next_token
        tokenCounter + 1
      Until (*token = 0)
      log_Print{"scanning tokenlist done, processed " + Str$(libCounter) +" libs, " + Str$(tokenCounter) + " tokens."}

      ;-- update the token_mapping file
      If _updatefile Then write_libmapping{_tokenMappingFile}
    EndIf

    ;-- free the hashmap
    hashmap_Free{*hm_firstTokens}
  EndIf
End Statement


Function.l AutoLayout{*wprefs.winprefs,mode.l}
  SHARED sourceWindow, pedconfig
  USEPATH *wprefs
  *scr.Screen = Peek.l(Addr Screen(0))
  If *scr = 0 Then Function Return False

  top.l    = *scr\BarHeight +1 + pedconfig\al_topspace
  bottom.l = *scr\Height-1     - pedconfig\al_bottomspace
  left.l   = 0                 + pedconfig\al_leftspace
  right.l  = *scr\Width-1      - pedconfig\al_rightspace

  lock.l = LockIBase_ (0)
    *myWindow.Window = *scr\FirstWindow

    While *myWindow
      rx.l = *myWindow\Width/*myWindow\Height
      ry.l = *myWindow\Height/*myWindow\Width
      ;If *myWindow\Title Then rx=1 : ry=1
      If *myWindow\Flags&#WFLG_BORDERLESS = 0 Then rx=1 : ry=1
      If rx>2
        If *myWindow\TopEdge+*myWindow\Height-1 >= bottom
          bottom = Min(bottom,*myWindow\TopEdge-1)
        End If
        If *myWindow\TopEdge<*scr\BarHeight
          top    = Max(top,*myWindow\TopEdge+*myWindow\Height)
        End If
      End If

      If ry>2
        If *myWindow\LeftEdge+*myWindow\Width-1 >= right
          right = Min(right,*myWindow\LeftEdge-1)
        End If
        If *myWindow\LeftEdge<=0
          left  = Max(left,*myWindow\LeftEdge+*myWindow\Width)
        End If
      End If
      *myWindow = *myWindow\NextWindow
    Wend

  UnlockIBase_ lock

  width.l  = right-left+1
  height.l = bottom-top+1


  Select mode
    Case 0    ; Layout A
      splitpointY.l  = (bottom-top) * 3/4
      splitpointX.l  = (right-left) * 3/4

      If splitpointY<700              Then splitpointY=height
      If (right-left)-splitpointX<250 Then splitpointX=right-left-250

      \source_x    = left,top,splitpointX,splitpointY
      sourceWindow\WinLeft  = left,top,splitpointX,splitpointY

      If (splitpointY<bottom-top+1)
        If (splitpointX>1024)
          \ibrowser_on = True        ; Instruction Browser
          \ibrowser_x  = left,(top+splitpointY),(splitpointX/2),bottom-(top+splitpointY)+1
          \lbrowser_on = True
          \lbrowser_x  = left+splitpointX/2,(top+splitpointY),splitpointX-(splitpointX/2),bottom-(top+splitpointY)+1
        Else
          \ibrowser_on = True        ; Instruction Browser
          \ibrowser_x  = left,(top+splitpointY),(splitpointX),bottom-(top+splitpointY)+1
          \lbrowser_on = False
        End If
      Else
        \lbrowser_on = False
        \ibrowser_on = False
      End If
      \click_on    = True            ; Source Browser
      \click_x     = (left+splitpointX),top,width-splitpointX,height*3/5
      \type_on     = True            ; Definition Browser
      \type_x      = (left+splitpointX),(top+height*3/5),width-splitpointX,bottom-((height)*3/5)+1-top

      If splitpointY<height
        \console_x   = left,(top+splitpointY),splitpointX,height-splitpointY
      Else
        \console_x   = left,(top),splitpointX,height
      End If

    Case 1    ; Layout B
      splitpointX1.l  = (width)  * 1/4 : If splitpointX1<400       Then splitpointX1=400
      splitpointX2.l  = (width)  * 3/4 : If width-splitpointX2<250 Then splitpointX2=width-250
      splitpointY.l   = (height) * 3/5

      If splitpointX2-splitpointX1<320 Then splitpointX1=0 ;: splitpointX2.l  = (right-left) * 1/3
      If splitpointY <400              Then splitpointY=0

      ;\source_on   = True ; source code window
      \source_x    = left+splitpointX1,top,splitpointX2-splitpointX1,height
      sourceWindow\WinLeft = left+splitpointX1,top,splitpointX2-splitpointX1,height

      If (splitpointX1>0)
        If (splitpointY>0)
          \ibrowser_on = True ; Instruction Browser
          \ibrowser_x  = left,top,splitpointX1,splitpointY
          \lbrowser_on = True
          \lbrowser_x  = left,top+splitpointY,splitpointX1,height-splitpointY
        Else
          \ibrowser_on = True ; Instruction Browser
          \ibrowser_x  = left,top,splitpointX1,height
          \lbrowser_on = False
        End If
      Else
        \lbrowser_on = False
        \ibrowser_on = False
      End If
      If (splitpointY>0)
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX2 ,top,width-splitpointX2,splitpointY
        \type_on     = True ; Definition Browser
        \type_x      = left+splitpointX2 ,top+splitpointY,width-splitpointX2,height-splitpointY
      Else
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX2,top,width-splitpointX2,height
        \type_on     = False ; Definition Browser
      End If
      \console_x    = left,(top+splitpointY),width,height-splitpointY

    Case 2    ; Layout C
      splitpointX.l  = (width) * 3/4 : If width-splitpointX<250 Then splitpointX=width-250
      splitpointY.l  = (height) * 3/5
      If splitpointY <400 Then splitpointY=0

      ;\source_on   = True ; source code window
      \source_x    = left,top,splitpointX,height
      sourceWindow\WinLeft  = left,top,splitpointX,height

      \lbrowser_on = False
      \ibrowser_on = False

      If (splitpointY>0)
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX ,top,width-splitpointX,splitpointY
        \type_on     = True ; Definition Browser
        \type_x      = left+splitpointX ,top+splitpointY,width-splitpointX,height-splitpointY
      Else
        \click_on    = True ; Source Browser
        \click_x     = left+splitpointX,top,width-splitpointX,height
        \type_on     = False ; Definition Browser
      End If
      \console_x   = left,(top+splitpointY),width,height-splitpointY


  End Select
  USELASTPATH
  Function Return True
End Function

Function.b PED_PanicKill{*exeTask.Task}
  log_Print{"running exe task [" + Hex$(*exeTask) + "], removing all windows, screen and kill task..."}

  ;-- stop multitasking
  log_Print{"... disabling multitasking"}
  Forbid_

  ;-- close all windows and the screen of the task
  *iBase.IntuitionBase = IntuitionBase
  log_Print{"Intuitionbase: " + Hex$(*iBase) + ", version " + Str$(*iBase\LibNode\lib_Version)}
  *exeScreen.Screen = 0
  *tmpScreen.Screen = *iBase\FirstScreen
  While *tmpScreen
    log_Print{"... checking Screen: " + Hex$(*tmpScreen) + " >> " + Peek.s(*tmpScreen\Title)}
    *tmpWindow.Window = *tmpScreen\FirstWindow
    While *tmpWindow
      *nextWindow.Window = *tmpWindow\NextWindow
      log_Print{"... checking Window " + Hex$(*tmpWindow) + " >> " + Peek.s(*tmpWindow\Title) + " Sigtask: " +  Hex$(*tmpWindow\UserPort\mp_SigTask)}
      If *tmpWindow\UserPort\mp_SigTask = *exeTask
        log_Print{"... window belongs to task, closing it!"}
        *exeScreen = *tmpScreen
        *tmpWindow\UserPort = 0
        CloseWindow_ *tmpWindow
      EndIf
      *tmpWindow = *nextWindow
    Wend
    *tmpScreen = *tmpScreen\NextScreen
  Wend
  If *exeScreen <> 0
    log_Print{"... screen belongs to task window, closing it ..."}
    CloseScreen_ *exeScreen
  EndIf

  ;-- kill the exe task
  log_Print{"... removing task"}
  RemTask_ *exeTask

  ;-- emable multitasking
  log_Print{"... enabling multitasking"}
  Permit_
End Function

Function PED_PanicCheck{}
SHARED ped
  *exeTask.Task = FindTask_("AmiBlitz3 Program Process")
  If *exeTask <> 0
    dummy.l = ask{!TRANS{"This action is not allowed while executing a program\\nShould PED do a PANIC program kill?"},!TRANS{"Ok|Cancel"},!TRANS{"Error"}}
    If dummy <> 0
      PED_PanicKill{*exeTask}
      ped\ptrCurrentSourceData\RunningFlag = 0
    Else
      Function Return True
    EndIf
  EndIf
  Function Return False
End Function



Function.l PED_GetIntuiMessage{_wait.b}
SHARED pedMessage,sourceWindow

  pedMessage\_Class = 0
  pedMessage\_Code  = 0
  pedMessage\_Qualifier = 0
  pedMessage\_IAddress  = 0
  pedMessage\_MouseX    = 0
  pedMessage\_MouseY    = 0
  pedMessage\_Window    = 0
  pedMessage\_Seconds   = 0
  pedMessage\_Micros    = 0

  If _wait = True
    pedMessage\_Class     = WaitEvent
  Else
    pedMessage\_Class     = Event
  ;*msg.IntuiMessage = GetMsg_(sourceWindow\win\UserPort)
  EndIf

  ;If *msg Then ReplyMsg_ *msg
  pedMessage\_Code      = EventCode
  pedMessage\_Qualifier = EventQualifier
  pedMessage\_IAddress  = EventiAddress
  pedMessage\_MouseX    = EMouseX
  pedMessage\_MouseY    = EMouseY
  pedMessage\_Window    = EventWindow
  pedMessage\_Seconds   = EventSeconds
  pedMessage\_Micros    = EventMicros

  Function Return pedMessage\_Class
End Function


;@@0
.STARTUP_PED
; -------------------------------------------------------------------------------------
; START OF CODE
; -------------------------------------------------------------------------------------

; -- check for TEDY as input of D1, if NOT, program was not run from IDE
; -- we have to switch to asm-context, as the registers have been stored there
!asm
MOVE.l A1,comLong_AB3IsAvailable   ; only used as indicator if started by compiler
MOVEM.l D1/A1,-(A7)
!basic
MOVEM.l (A7)+,D1/A1
PutReg D1, tedy.l                  ; should be "TEDY
PutReg A1, teddata.l               ; should contain pointer to compilers "teddata"-structure
If tedy <> @"TEDY"
  error{"PED is not a standalone editor anymore.\\nPlease start the AmiBlitz3-IDE via Compiler."}
  Goto immediate_exit
EndIf

; -- copy received teddata of compiler in A1 to local data structures
Poke.l ?comPtr_TokenBase        , Peek.l(teddata)
Poke.l ?comFunc_ReadXtraFile    , Peek.l(teddata+4)
Poke.l ?comFunc_WriteXtraFile   , Peek.l(teddata+8)
Poke.l ?comFunc_CallMenuEntry   , Peek.l(teddata+12)
Poke.l ?comByte_ColonIdentifier , Peek.l(teddata+16)
*tokenbase = Peek.l(?comPtr_TokenBase)
*newtypebase = Peek.l(teddata+20)
*constantbase = Peek.l(teddata+24)
*macrobase = Peek.l(teddata+28)

; skip simple newtypes b,w,l,q,f,d,s to prevent them to be listed in newtype browser
For _nt.b = 1 To 7
  *newtypebase = Peek.l(*newtypebase)
Next _nt

; --
; -- check/set tokenisation mode, If no tokens available, Disable tokenization
If *tokenbase = 0
  ped\doTokenize = False
Else
  ped\doTokenize = True
EndIf

; -- setting comdatas
!ComData_LEA{comFunc_ErrorRequest           ,A0}        : MOVE.l #com_showErrorRequest        ,(A0) ;$0C
!ComData_LEA{comFunc_DebugTrap              ,A0}        : MOVE.l #com_debugTrap               ,(A0) ;$38
!ComData_LEA{comFunc_OpenConsole            ,A0}        : MOVE.l #com_consoleOpen             ,(A0) ;$3C
!ComData_LEA{comFunc_CloseConsole           ,A0}        : MOVE.l #com_consoleClose            ,(A0) ;$40
!ComData_LEA{comFunc_LogPrint               ,A0}        : MOVE.l #com_logPrint                ,(A0) ;$44
!ComData_LEA{comFunc_DetokenizeLine         ,A0}        : MOVE.l #com_detokenizeLine          ,(A0) ;$64
!ComData_LEA{comPtr_SourceDir               ,A0}        : MOVE.l #comStr_SourceDir            ,(A0) ;$68
!ComData_LEA{comPtr_SourceName              ,A0}        : MOVE.l #comStr_SourceName           ,(A0) ;$6C
!ComData_SetL{comFunc_CloseGUI              ,#close_gui}
!ComData_SetL{comFunc_CreateGUI             ,#create_whole_gui}
!ComData_SetL{comData_Magic                 ,##MagicIdentifier_Long}
!ComData_SetL{comFunc_UpdateCompileStatusWin,#com_updateCompileWindow}


; ########################################################################################
; # Check  if  all  needed  Librarys  are  available  with  the  needed  min  Version
; ########################################################################################
missingLibExit.b = False   ; abort indicater
missingLibMsg.s  = ""      ; for the error text

;****************** ted.library is only needed for sharing comdata with the Debugger!
If ted_OpenLib{0} = 0
  missingLibMsg + "Unable to open ted.library\\n\\n"
  missingLibExit = True
Else
  Gosub set_tedlibbase
EndIf

If dos_CheckLib{"wizard.library",42} = False        ; needed for PED and REDDebugger
  missingLibMsg + "Missing 'wizard.library':\\nVersion 42 of this library is required by the IDE.\\n\\n"
  missingLibExit = True
EndIf
If dos_CheckLib{"disassembler.library",40} = False  ; only needed for REDDebugger
  missingLibMsg + "Missing 'disassembler.library':\\nVersion 40 of this library is required by REDDebugger.\\nASM debugging won't work.\\n\\n"
End If

If missingLibMsg <> ""
   missingLibMsg = "Please reinstall AmiBlitz3 or copy the following librarys to LIBS:\\n\\n" + missingLibMsg
   If missingLibExit
     missingLibMsg + "... that the PED can start!" ; for abort
   Else
     missingLibMsg + "... for a full working IDE!" ; for limited start
   End If
   error{!TRANS{missingLibMsg}}
End If
If missingLibExit Then Goto immediate_exit
; -----------------------------------------------------------------------------------

; ########################################################################################
; # memory allocations
; ########################################################################################
ped\mempool = CreatePool_(#MEMF_CLEAR,40000,40000)
If ped\mempool = 0
  log_Print{"Could not allocate enough memory. PED closes down now.",#log_error}
  Pop If
  Goto exit_PED_nomem
EndIf
Poke.l ?comPtr_MemPool,ped\mempool

; --
; -- alloc 128 bytes for illegal character table
; -- & initiation of the disallowed characters table
ped\illegalCharTable = PED_AllocMem{128}
If ped\illegalCharTable = 0 Then Goto exit_PED_closelibraries
Poke.b ped\illegalCharTable +    0, 1
Poke.b ped\illegalCharTable +    1, 1
Poke.b ped\illegalCharTable +    2, 1
Poke.b ped\illegalCharTable + @",", 1
Poke.b ped\illegalCharTable + @";", 1
Poke.b ped\illegalCharTable + @":", 1
Poke.b ped\illegalCharTable + @"(", 1
Poke.b ped\illegalCharTable + @")", 1
Poke.b ped\illegalCharTable + @"=", 1
Poke.b ped\illegalCharTable + @"+", 1
Poke.b ped\illegalCharTable + @"-", 1
Poke.b ped\illegalCharTable + @"*", 1
Poke.b ped\illegalCharTable + @"/", 1
Poke.b ped\illegalCharTable + @"$", 1
Poke.b ped\illegalCharTable + @"%", 1
Poke.b ped\illegalCharTable + @".", 1
Poke.b ped\illegalCharTable + @"[", 1
Poke.b ped\illegalCharTable + @"]", 1
Poke.b ped\illegalCharTable + @"{", 1
Poke.b ped\illegalCharTable + @"}", 1
Poke.b ped\illegalCharTable + @"\", 1
Poke.b ped\illegalCharTable + @">", 1
Poke.b ped\illegalCharTable + @"<", 1
Poke.b ped\illegalCharTable + @"&", 1
Poke.b ped\illegalCharTable + @"|", 1
Poke.b ped\illegalCharTable + @"^", 1
Poke.b ped\illegalCharTable + @" ", 1

; --
; -- alloc some memory for filereading
readcache\bufferptr = PED_AllocMem{8192}
If readcache\bufferptr = 0 Then Goto exit_PED_closelibraries
readcache\fib = AllocDosObject_ (#DOS_FIB,0)
*rc_fib.FileInfoBlock = readcache\fib

; --
; -- alloc memory for textbuffer of source editor
tempMemPtr.l = PED_AllocMem{(#MAX_Columns + 4) * 2}
If tempMemPtr = 0 Then Goto exit_PED_closelibraries
ped\ptrTextbufferPrint   = tempMemPtr + (#MAX_Columns + 4) * 0
ped\ptrLineUndeleteStore = tempMemPtr + (#MAX_Columns + 4) * 1

; --
; -- alloc memory for tokencache
ped\tokenCache = PED_AllocMem{32768 * 4}
If ped\tokenCache = 0 Then Goto exit_PED_closelibraries

*pedProcess.Process = FindTask_(0)
FindScreen 0

tt.s = dos_GetProgIcon{dos_AddPart{default_assign,"AmiBlitz3"} }
log_Print{"opening tooltypes for <" + tt.s + ">"}
ped\AbDiscObject = dos_OpenToolTypes{tt.s}
If ped\AbDiscObject
  ; ---- LOGGING --------------------------------------------------
  tmpStringVar = UCase$(dos_GetToolString{"LOG_LEVEL","NOTHING"})
  logging_level.b = #log_nothing
  If tmpStringVar = "NOTHING" Then logging_level = #log_nothing
  If tmpStringVar = "DEBUG" Then logging_level = #log_debug
  If tmpStringVar = "INFO" Then logging_level = #log_information
  If tmpStringVar = "WARN" Then logging_level = #log_warning
  If tmpStringVar = "ERROR" Then logging_level = #log_error

  log_SetLevel{logging_level}
  If logging_level < #log_nothing
    If log_Init{"CON:0/19/1200/200/AmiBlitz3 Log"} = 0 
      log_Init{"CON:0/19/640/200/AmiBlitz3 Log"}
    EndIf
  EndIf

  log_mode.b = #log_toconsole
  tmpStringVar = UCase$(dos_GetToolString{"LOG_MODE","CONSOLE"})
  If tmpStringVar = "FILE" Then log_mode = #log_tofile
  If tmpStringVar = "CONSOLE" Then log_mode = #log_toconsole
  If tmpStringVar = "BOTH" Then log_mode = #log_toboth
  log_SetDestination{log_mode,"System/PED.log"}
EndIf

; ########################################################################################
; # return to compiler and continue after being recalled by compiler
; ########################################################################################
!log_AvailMem{"after memory allocation and init stuff, back to compiler now"}

; --
; -- return to compiler after initiation
!asm
MOVE.l comLong_AB3IsAvailable,D0                          ; <-- compiler checks value in D0 at first return of PED
BEQ.w start_up_without_compiler
  LEA MAINPROGRAM,A0                                      ; <-- give compiler jump entry for return
  MOVEA.l comdata,A1                                      ; <-- five comdata to compiler
  MOVE.w ##ComDataVersionID,comWord_PEDIsAvailable
  RTS                                                     ; <-- return to compiler
start_up_without_compiler:




; ########################################################################################
.MAINPROGRAM: ; --> compiler offers sourcefile in A0 here
; ########################################################################################
MOVE.l A0,-(a7) ; store a0 as it will be destroyed while context switching to !basic
!basic
MOVE.l (a7)+,A0 : PutReg A0,ptr_compilersource.l

!log_AvailMem{"after compiler has given control back"}

*varbase = Peek.l(?comPtr_VarBase)

;log_Print{"Tokenbase   = " + Hex$(*tokenbase)}
;log_Print{"NewTypebase = " + Hex$(*newtypebase)}
;log_Print{"Constantbase= " + Hex$(*constantbase)}
;log_Print{"Macrobase   = " + Hex$(*macrobase)}
;log_Print{"Varbase     = " + Hex$(*varbase)}

; ------------------------------------------------------------------------------------
; AUSWERTEN DER TOOLTYPES
; ------------------------------------------------------------------------------------
.TOOLTYPES
  If ped\AbDiscObject
    ; ----- OTHER TOOLTYPES
    log_Print{"processing tooltypes..."}

    If dos_GetToolState{"DISABLE_WELCOME"}     = -1 Then pedconfig\no_welcome      = True  : Else pedconfig\no_welcome = 0
    If dos_GetToolState{"ASKBEFOREQUIT"}       = -1 Then pedconfig\ask_before_quit = True  : Else pedconfig\ask_before_quit = 0
    If dos_GetToolState{"CREATE_BACKUPS"}       = -1 Then pedconfig\create_backups = True  : Else pedconfig\create_backups = 0
    If dos_GetToolState{"SMART_TOKENIZATION"}  = -1 Then pedconfig\smart_tokenization = True  : Else pedconfig\smart_tokenization = 0
    If dos_GetToolState{"DISABLE_DISPLAYBEEP"} = -1 Then pedconfig\no_display_beep = True  : Else pedconfig\no_display_beep =   0
    If dos_GetToolState{"AUTO_FORMAT"}         = -1 Then pedconfig\auto_format     = True  : Else pedconfig\auto_format = 0
    If dos_GetToolState{"AUTO_INDENT"}         = -1 Then pedconfig\auto_indent     = True  : Else pedconfig\auto_indent = 0  ; added because was not loaded befor tomsmart1
    If dos_GetToolState{"AUTO_CONSTRUCTS"}     = -1 Then pedconfig\auto_constructs = True  : Else pedconfig\auto_constructs = 0
    If dos_GetToolState{"CORRECT_FUNCTIONS"}   = -1 Then pedconfig\correct_functions = True  : Else pedconfig\correct_functions = 0
    If dos_GetToolState{"BOLD_TOKENS"}         = -1 Then pedconfig\bold_tokens       = True  : Else pedconfig\bold_tokens = 0
    If dos_GetToolState{"LINENUMBERS"}         = -1 Then pedconfig\linenumbers     = True  : Else pedconfig\linenumbers = 0
    If dos_GetToolState{"DISABLE_HIGHLIGHTING"}= -1 Then pedconfig\highlighting  = False  : Else pedconfig\highlighting = True
    If dos_GetToolState{"DISABLE_LOCALIZATION"}  = -1 Then pedconfig\localization = False : Else pedconfig\localization = True
    If dos_GetToolState{"HELPFORPRIVATFUNCTIONS"}  = -1 Then pedconfig\HelpForPrivateFunctions = True : Else pedconfig\HelpForPrivateFunctions = 0
    If dos_GetToolState{"USE_INTELLISENSE"}        = -1 Then pedconfig\intellisense = True  : Else pedconfig\intellisense = 0
    If dos_GetToolState{"USE_INTELLISENSE_COMMANDS"}= -1 Then pedconfig\use_commandsintellisens = True  :Else pedconfig\use_commandsintellisens = False
    If dos_GetToolState{"ONLINEHELP"}          = -1 Then pedconfig\onlinehelp      = True  : Else pedconfig\onlinehelp = 0
    If dos_GetToolState{"ONLINEHELP_EXTENDED"} = -1 Then pedconfig\onlinehelp_extended = True : Else pedconfig\onlinehelp_extended = 0
    If dos_GetToolState{"DISABLE_INCLUDEHELP"} = -1 Then pedconfig\onlinehelp_includes   = False  : Else pedconfig\onlinehelp_includes = True
    If dos_GetToolState{"USE_PREPROCESSOR"} = -1 Then pedconfig\usePreProcessor   = True  : Else pedconfig\usePreProcessor = False

    If AvailMem_(#MEMF_FAST) < 4000000 AND (pedconfig\onlinehelp_includes OR pedconfig\intellisense OR pedconfig\usePreProcessor OR pedconfig\localization)
      errormessage$ = "The available memory is low.\\n"
      errormessage$ + "Online-Help and intellisense for Include-functions will be disabled.\\n"
      errormessage$ + "You should check following tooltypes:\\n\\n"
      If pedconfig\onlinehelp_includes Then errormessage$ + "- DISABLE_INCLUDEHELP\\n"
      If pedconfig\localization Then errormessage$ + "- DISABLE_LOCALIZATION\\n"
      If pedconfig\intellisense Then errormessage$ + "- USE_INTELLISENSE\\n"
      If pedconfig\usePreProcessor Then errormessage$ + "- PREPROCESSOR"
      pedconfig\onlinehelp_includes = False
      pedconfig\localization = False
      pedconfig\intellisense = False
      pedconfig\usePreProcessor = False
      error{errormessage$}
    End If

    If dos_GetToolState{"SOURCE_HISTORY"}          = -1 Then pedconfig\remember_saved    = True : Else pedconfig\remember_saved = 0
    If dos_GetToolState{"LOAD_LAST_SOURCE"}        = -1 Then pedconfig\load_last_source  = 1 : Else pedconfig\load_last_source = 0
    If dos_GetToolState{"USE_FILEPATTERN"}         = -1 Then pedconfig\use_filepattern=1 : Else pedconfig\use_filepattern=0
    If dos_GetToolState{"SORT_LABELS"}             = -1 Then pedconfig\sort_labels       = True  : Else pedconfig\sort_labels = 0
    If dos_GetToolState{"CON_ONWB"}                = -1 Then pedconfig\console_wb        = True  : Else pedconfig\console_wb  = 0
    If dos_GetToolState{"CON_WAIT"}                = -1 Then pedconfig\console_wait      = True  : Else pedconfig\console_wait = 0

    If dos_GetToolState{"CLONE_WBSCREEN"}   = True
      pedconfig\clone_wbscreen = True : pedconfig\use_wbscreen = False
    Else
      If dos_GetToolState{"USE_WBSCREEN"}   = True
        pedconfig\use_wbscreen = True : pedconfig\clone_wbscreen = False
      EndIf
    EndIf
    If dos_GetToolState{"PUBSCREEN"}          = -1 Then pedconfig\use_pubscreen         = True : Else pedconfig\use_pubscreen = 0
    If dos_GetToolState{"DEFAULTPUBSCREEN"}   = -1 Then pedconfig\use_default_pubscreen = True : Else pedconfig\use_default_pubscreen = 0
    If dos_GetToolState{"USE_WBFONT"}         = -1 Then pedconfig\use_wbfont            = True : Else pedconfig\use_wbfont = 0
  Else
    log_Print{"Could not open tooltypes",#log_warning}
    pedconfig\create_backups      = True
    pedconfig\bold_tokens         = True
    pedconfig\onlinehelp          = True
    pedconfig\onlinehelp_extended = False
    pedconfig\clone_wbscreen      = False
    pedconfig\use_wbscreen        = True
    pedconfig\use_pubscreen       = False
    pedconfig\use_default_pubscreen = False
    pedconfig\use_wbfont          = True
    pedconfig\use_filepattern     = True
  End If

  If dos_GetToolState{"CREATE_ICONS"}=-1 Then pedconfig\use_source_icon = True Else pedconfig\use_source_icon = False
  If dos_GetToolState{"AUTOLAYOUT"}=-1 Then pedconfig\autolayout     = True Else pedconfig\autolayout = False

  pedconfig\al_leftspace   = dos_GetToolValue{"autolayout_left"  ,0}
  pedconfig\al_topspace    = dos_GetToolValue{"autolayout_top"   ,0}
  pedconfig\al_rightspace  = dos_GetToolValue{"autolayout_right" ,0}
  pedconfig\al_bottomspace = dos_GetToolValue{"autolayout_bottom",0}

  pedconfig\console_device = dos_GetToolString{"CON_DEVICE","CON:"}
  pedconfig\console_font   = dos_GetToolString{"CON_FONT",""}


  pedconfig\cursorStyle = cursorStyleGetValue{dos_GetToolString{"cursorstyle","block"}}
  pedconfig\scroll_rate = dos_GetToolValue{"scrollrate",0}
  If pedconfig\scroll_rate <> 0
    If vvblank_SetFreq{pedconfig\scroll_rate} = False Then ped\no_scrollrate = True
  Else
    ped\no_scrollrate = True
  EndIf

  pedconfig\tabSize =  dos_GetToolValue{"tabsize",2}
  pedconfig\blinkrate = dos_GetToolValue{"cursorblinkrate",5}
  pedconfig\wheelStep = dos_GetToolValue{"MOUSEWHEELSTEP",6}     ; added to make Mousewheelsteprate changeable  tomsmart1

  ; --- ASL-Requestersettings ------------------------------
  pedconfig\asl_x = dos_GetToolValue{"ASLREQ_X" ,20}
  pedconfig\asl_y = dos_GetToolValue{"ASLREQ_Y" ,20}
  pedconfig\asl_w = dos_GetToolValue{"ASLREQ_W",320}
  pedconfig\asl_h = dos_GetToolValue{"ASLREQ_H",200}
  asl_SetRequesterDims{pedconfig\asl_x,pedconfig\asl_y,pedconfig\asl_w,pedconfig\asl_h}

  ; --- COLORS ---------------------------------------------
  AB3RGB(#AB3_ctoken)            = dos_GetToolValue{"tokencolor"      ,$646bd7}
  AB3RGB(#AB3_cfunction)         = dos_GetToolValue{"functioncolor"   ,$396635}
  AB3RGB(#AB3_cconstant)         = dos_GetToolValue{"constantcolor"   ,$8C338A}
  AB3RGB(#AB3_cnewtype)          = dos_GetToolValue{"newtypecolor"    ,$153492}
  AB3RGB(#AB3_cstring)           = dos_GetToolValue{"stringcolor"     ,$7D8A83}
  AB3RGB(#AB3_cmacro)            = dos_GetToolValue{"macrocolor"      ,$CB3817}
  AB3RGB(#AB3_cother)            = dos_GetToolValue{"othercolor"      ,$000000}
  AB3RGB(#AB3_cremarkforeground) = dos_GetToolValue{"remarkforg"      ,$6a9a66}
  AB3RGB(#AB3_cremarkbackground) = dos_GetToolValue{"remarkbackg"     ,$f9f9f9}
  AB3RGB(#AB3_ctokenbackground)  = dos_GetToolValue{"tokenbackpen"    ,$ffffff}
  AB3RGB(#AB3_cbackground)       = dos_GetToolValue{"backgroundcolor" ,$ffffff}
  AB3RGB(#AB3_cclassic)          = dos_GetToolValue{"classiccolor"    ,$ff0500}
  AB3RGB(#AB3_screenback)        = dos_GetToolValue{"screenbackcolor" ,$c8c8c8}
  AB3RGB(#AB3_screentext)        = dos_GetToolValue{"screentextcolor" ,$000000}
  AB3RGB(#AB3_screenshine)       = dos_GetToolValue{"screenshinecolor",$FFFFFF}
  AB3RGB(#AB3_screenfill)        = dos_GetToolValue{"screenfillcolor" ,$6e94e2}

  ; --- SCREEN ---------------------------------------------
  pedconfig\screen_modeID  = dos_GetToolValue{"SCREEN_ID"     ,0}
  pedconfig\screen_Width   = dos_GetToolValue{"SCREEN_WIDTH"  ,0}
  pedconfig\screen_Height  = dos_GetToolValue{"SCREEN_HEIGHT" ,0}
  pedconfig\screen_Depth   = dos_GetToolValue{"SCREEN_DEPTH"  ,0}

  ; check if any Screentooltype set
  If (pedconfig\clone_wbscreen = 0) AND (pedconfig\use_wbscreen = 0) AND (pedconfig\screen_modeID = 0)
     pedconfig\use_wbscreen = True  ; we use WBScreen if no Screen Tooltype is set
  EndIf

  project_changelog$ = ""

  ; --- FONTS ----------------------------------------------
  If pedconfig\use_wbfont = False
    ;no Tooltype use_wbfont so check for GUI and Source font tooltypes
    str_guifont$    = dos_GetToolString{"guifont",""}       ; no predefine Font use WB fonts instead
    str_sourcefont$ = dos_GetToolString{"sourcefont",""}

    If str_guifont$<>"" OR str_sourcefont$<>""
      ;-- check and set GUIfont
      If str_guifont$<>""
        InitArgParse str_guifont$
        guifont_name$ = NextArgChar$(@",")
        guifont_size.w = Vallong(NextArg$)
      EndIf
      ;-- check and set Sourcefont
      If str_sourcefont$<>""
        InitArgParse str_sourcefont$
        sourcefont_name$ = NextArgChar$(@",")
        sourcefont_size.w = Val(NextArg$)
      EndIf
    Else
      ;-- no guifont and sourcefont set so use WBfonts
      pedconfig\use_wbfont = True
    EndIf
  EndIf

  ; --- DIRECTORIES ---------------------------------------
  pedconfig\mainDir      = dos_GetToolString{"ASSIGN",default_assign}
  If pedconfig\mainDir = "" Then pedconfig\mainDir = default_assign ; in case someone sets assign to ""
  pedconfig\systemDir    = dos_AddPart{pedconfig\mainDir,"System"}
  pedconfig\blitzlibDir  = dos_AddPart{pedconfig\mainDir,"Blitzlibs"}
  pedconfig\lastSourceFile     = dos_GetToolString{"last_source",""}

  pedconfig\includeDir   = dos_GetToolString{"INCLUDEDIR" ,dos_AddPart{pedconfig\mainDir,"Sourcecodes/Includes"}}
  pedconfig\helpDir      = dos_GetToolString{"HELPDIR"    ,dos_AddPart{pedconfig\mainDir,"Docs"}}
  pedconfig\autodocDir   = dos_GetToolString{"AUTODOCDIR" ,dos_AddPart{pedconfig\mainDir,"Docs"}}
  pedconfig\sourceDir    = dos_GetToolString{"SOURCEDIR"  ,dos_AddPart{pedconfig\mainDir,"Sourcecodes"}}
  pedconfig\winprefsFile = dos_GetToolString{"WINDOWPREFS",dos_AddPart{pedconfig\mainDir,"System/ped_addon.prefs"}}
  pedconfig\rememberFile = dos_AddPart{pedconfig\systemDir,"PED.history"}
  pedconfig\menuFile = dos_AddPart{pedconfig\systemDir,"PED.menus"}

  ; -- lib collections
  If dos_GetToolState{"BASELIBS"} <> 0
    If dos_GetToolState{"BASELIBS"} =-1 Then pedconfig\useBaseLib = True
    pedconfig\baselibFile = dos_GetToolString{"BASELIBS",dos_AddPart{pedconfig\blitzlibDir,"AcidLibs"}}
    ;log_Print{"BASELIBS = " + pedconfig\baselibFile}
  EndIf
  If pedconfig\baselibFile <> ""
    If dos_Exist{pedconfig\baselibFile}
      ped\baselibFileDate = Replace$(dos_GetFileDate{pedconfig\baselibFile},"/",".")
      ped\baselibFileSize = dos_GetFileSize{pedconfig\baselibFile}
    EndIf
  EndIf

  If dos_GetToolState{"UTILLIBS"} <> 0
    If dos_GetToolState{"UTILLIBS"} =-1 Then pedconfig\useUtilLib = True
    pedconfig\utillibFile = dos_GetToolString{"UTILLIBS",dos_AddPart{pedconfig\blitzlibDir,"DefLibs"}} 
    ;log_Print{"UTILLIBS = " + pedconfig\utillibFile}
  EndIf
  If pedconfig\utillibFile <> ""
    If dos_Exist{pedconfig\utillibFile}
      ped\utillibFileDate = Replace$(dos_GetFileDate{pedconfig\utillibFile},"/",".")
      ped\utillibFileSize = dos_GetFileSize{pedconfig\utillibFile}
    EndIf
  EndIf

  If dos_GetToolState{"OSLIBS"} <> 0
    If dos_GetToolState{"OSLIBS"} =-1 Then pedconfig\useOsLib = True
    pedconfig\oslibFile = dos_GetToolString{"OSLIBS",dos_AddPart{pedconfig\blitzlibDir,"OsLibs"}}
    ;log_Print{"OSLIBS = " + pedconfig\oslibFile}
  EndIf
  If pedconfig\oslibFile <> ""
    If dos_Exist{pedconfig\oslibFile}
      ped\oslibFileDate  = Replace$(dos_GetFileDate{pedconfig\oslibFile},"/",".")
      ped\oslibFileSize  = dos_GetFileSize{pedconfig\oslibFile}
    EndIf
  EndIf

  If dos_GetToolState{"CSLIBS"} <> 0
    If dos_GetToolState{"CSLIBS"} =-1 Then pedconfig\useCsLib = True
    pedconfig\cslibFile = dos_GetToolString{"CSLIBS",dos_AddPart{pedconfig\blitzlibDir,"CsLibs"}}
    ;log_Print{"CSLIBS = " + pedconfig\cslibFile}
  EndIf
  If pedconfig\cslibFile <> ""
    If dos_Exist{pedconfig\cslibFile}
      ped\cslibFileDate  = Replace$(dos_GetFileDate{pedconfig\cslibFile},"/",".")
      ped\cslibFileSize  = dos_GetFileSize{pedconfig\cslibFile}
    EndIf
  EndIf

  ; settings for type browser
  ped\definitionMode = -1


  log_Print{"processing tooltypes done."}

  ; -------------------------------------- localization
  If pedconfig\localization
    !log_AvailMem{"init localization..."}
    !TRANS_INIT{"AmiBlitz3"}

    *MyCatalog.Catalog = OpenCatalogA_(0,"PED.catalog",0)
    If *MyCatalog
      ;set tags so Wizardlibrary Use catalog File
      log_Print{"language: " + Peek.s(*MyCatalog\cat_Language)}
      WZTags #SFH_Catalog,*MyCatalog,#TAG_DONE,0,#TAG_END,0
    Else
      log_Print{"could not open catalog file",#log_warning}
    EndIf
    !log_AvailMem{"init localization done."}
  EndIf

  pedconfig\console_title  = !TRANS{"AmiBlitz3 Console Output"}

  ; --
  ; -- setup wizard GUI
  ; --
  !log_AvailMem{"processing StormWizard gui..."}
  WZLoadGUI ?wzgui
  !log_AvailMem{"processing StormWizard gui done."}

  WZ_ShowMessage{!TRANS{"Initiating AmiBlitz3 Environment..."} }
  WZ_ChangeTitle{"WIN_PROGRESS","Amiblitz3 V" + !versions}


  ;--- Check to identify on with OS we are running
  ;--- added to disable the Mousewheel settings in the IDE prefs for OS4 because we use the System values with OS4
  SHARED OSVersion.l
  OSVersion = #AmigaOS3
  If ( dos_CheckLib{"exec.library",50} ) Then OSVersion = #AmigaOS4
  If ( FindResident_("MorphOS") )        Then OSVersion = #MorphOS
  ;-----

; ------------------------------------------------------
; EINBINDEN DER KONFIGURATIONSDATEIEN
; ------------------------------------------------------
.CONFIGFILES
pedconfig\HelpIndexTextFile = dos_AddPart{pedconfig\systemDir,"HelpIndex.txt"}
pedconfig\HelpIndexBinFile  = dos_AddPart{pedconfig\systemDir,"HelpIndexCache.bin"}
pedconfig\TokenHashMapFile  = dos_AddPart{pedconfig\systemDir,"TokenList.hashmap"}

pedconfig\usePreProcessor = True  ; it is necessary for Compiler ATM !!!

;--
;-- Preprocessor
WZ_ShowMessage{!TRANS{"Preparing preprocessor ..."}}
!log_AvailMem{"before initiating preprocessor"}
*preProcessor = preproc_Create{}
Poke.l ?comPtr_PreProcessor,*preProcessor

If pedconfig\usePreProcessor
  preproc_LoadTokens{*preProcessor,pedconfig\TokenHashMapFile}
  If *preProcessor\tokens = Null
    WZ_ShowMessage{!TRANS{"Creating token hashmap for preprocessor ..."}}
    Gosub update_preprocessor
  End If
Else
  log_Print{"no preprocessor for token processing used."}
EndIf
!log_AvailMem{"after initiating preprocessor"}

;--
;-- HelpIndex
If pedconfig\onlinehelp_includes
  WZ_ShowMessage{!TRANS{"Loading helpindex for include-functions ..."}}
  If dos_Exist{pedconfig\HelpIndexBinFile} AND dos_GetFileSize{pedconfig\HelpIndexBinFile} > 0
    log_Print{"loading help index cache file: " + pedconfig\HelpIndexBinFile + ", " + Str$(dos_GetFileSize{pedconfig\HelpIndexBinFile}) + "bytes"}
    PED_LoadHelpIndexBinFile{}
  Else
    log_Print{"building help index cache file: " + pedconfig\HelpIndexBinFile}
    PED_BuildHelpIndex{}
  EndIf
  !log_AvailMem{"after loading includehelpindex"}
Else
  log_Print{"index for includefiles skipped."}
EndIf

;--
;-- prefs file for window positions
If ReadFile (0,pedconfig\winprefsFile)
  WZ_ShowMessage{!TRANS{"Loading window layouts ..."}}
  ReadType 0,wpref(0)
  ReadType 0,wpref(1)
  ReadType 0,wpref(2)
  CloseFile 0
End If

WZ_ShowMessage{!TRANS{"Starting IDE ..."} }


; ########################################################################################
; # create ports
; ########################################################################################
; --
; -- create a msgport for Iconification
*WBMsgPort.MsgPort = CreateMsgPort_


; --
; -- defaultsettings for instructions browser
CaseSense Off
browse_macros.l           = Off
browse_instructions.l     = On
browse_includes.l         = Off


; --
; -- init arexx port
CNIF #USE_AREXX = 1
  log_Print{"init arexx-port..."}
  Gosub arexx_init
  AddWaitEvent PortSigBit(*ArexxMsgPort.MsgPort),$8000000
CEND

; --
; -- load sourcefont
Gosub open_sourcefonts

; --
; -- add the source history to the menu
If pedconfig\remember_saved
  Gosub load_pedrememberfile
Else
  Gosub update_remembermenu
EndIf

; --
; -- fill mapping array with libnames from mapping-file
; -- and check consistency based on the mapping files and the internal libnums
WZ_ShowMessage{!TRANS{"Building libmapping..."}}
!log_AvailMem{"before doing libmapping"}

;-- reset libmapping
For i.l = 0 To (#MAX_Blitzlibs-1)
  blitzlibMapping(i,0) = "* unused ID" + Str$(i) + " *"
  blitzlibMapping(i,1) = ""
Next i
map_tokens_to_libs{dos_AddPart{pedconfig\systemDir,"token_mapping_libs.txt"}, False}
map_tokens_to_libs{dos_AddPart{pedconfig\systemDir,"token_mapping_userlibs.txt"}, False}
!log_AvailMem{"after doing libmapping"}

WZ_HideMessage{}

PED_SetCurrentDir{}

.START_GUI
Gosub open_gui
Gosub menu_new
Gosub update_debuggertoggle


log_Print{"checking lastsource option"}
If pedconfig\load_last_source <> 0 OR Peek.s(ptr_compilersource) <> ""

  If Peek.s(ptr_compilersource) <> ""
      log_Print{"source file given by compiler: [" + Peek.s(ptr_compilersource) + "]"}
      pedconfig\lastSourceFile = Peek.s(ptr_compilersource)
  EndIf

  If pedconfig\lastSourceFile <> ""
    tmp_sourceDir.s = dos_PathPart{pedconfig\lastSourceFile}
    If Right$(tmp_sourceDir,1)<>":" Then tmp_sourceDir + "/" ; dirty hack, but better than editing ASM
    ped\currentFile = dos_FilePart{pedconfig\lastSourceFile}
    ped\currentDir = tmp_sourceDir
    ped\sourceFileComplete =  pedconfig\lastSourceFile
    Poke.s ?comStr_SourceDir,tmp_sourceDir
    Poke.s ?comStr_SourceName,dos_FilePart{pedconfig\lastSourceFile}
    ;ped\ptrCurrentSourceData\SourceDir = tmp_sourceDir
    ;ped\ptrCurrentSourceData\SourceName = dos_FilePart{pedconfig\lastSourceFile}

  EndIf
EndIf

  ; --
  ; -- jump to mainloop if no sourcename given, else
  ; -- load last Source
.AUTOLOAD_SOURCE
If ped\currentFile <> ""
  !PED_LoadSource{ped\sourceFileComplete,False,False,False}
Else
  log_Print{"no file to autoload."}
  PED_RedrawSource{}
  PED_UpdateStatusArea{#STATUS_REDRAW}
EndIf

; -- init empty strings
ped\searchString = ""       
ped\replaceString = ""

; -- show welcome requester if option selected
If NOT pedconfig\no_welcome Then Gosub menu_about

; ============================================================================
; -- jump to main loop
; --
Gosub main_loop
; --
; -- shutdown PED after return of the mainloop
; ============================================================================

exit_PED_closeall:
  Gosub close_gui
  Gosub free_textbuffer
  Gosub close_sourcefonts

exit_PED_closelibraries:
  log_Print{"closing ted.library ..."}
  ted_CloseLib{}

  log_Print{"closing catalog an libs..."}
  If *MyCatalog Then CloseCatalog_ *MyCatalog

  log_Print{"closing ports..."}
  If *WBMsgPort Then DeleteMsgPort_ *WBMsgPort
  CNIF #USE_AREXX = 1
    log_Print{"sending AREXX-message QUITPLEASE"}
    ArexxMyMessage.s = "QUITPLEASE" : Gosub arexx_sendmessage

    log_Print{"closing arexxport.."}
    Gosub arexx_free
  CEND

  log_Print{"freeing caches ..."}
  If *preProcessor
    preproc_Free{*preProcessor}
    *preProcessor = Null
  EndIf
  If readcache\fib Then FreeDosObject_ #DOS_FIB,readcache\fib  : readcache\fib = Null
  If readcache\cacheptr
    FreeVec_ readcache\cacheptr
    readcache\cacheptr = Null
    readcache\readlen = 0
  End If

.exit_PED_nomem:
  log_Print{"deleting mempool..."}
  DeletePool_ ped\mempool

.immediate_exit:
  log_Print{"unlocking directory..."}
  If ped\currentDirLock Then UnLock_ ped\currentDirLock
  If ped\oldDirLock Then CurrentDir_ (ped\oldDirLock)

  !ComData_LEA{comFunc_LogPrint,A0} : MOVE.l #0,(A0) ; "de-register" logprint function: make it unavailable for other processes
  !asm
  CLR.w comWord_PEDIsAvailable
  MOVEA.l comdata,A1            ; not needed as ped is gone in a few moments
  !exitasm                      ; exitasm jumps into basic mode
End
; ----------------------------------- END OF MAINPROGRAM ------------------------------------------



.handlePedEvents:
  ped\ptrCurrentSourceData\KeyBeforeReturn = 0
  exit_eventloop.b = False

  While exit_eventloop = False
    ;PED_HandleBlockmark{}      ; if new editmode, delete a marked block if insertchar or deleteCharFromTextbuffer happens

    ;-- handle Window events
    If sourceWindow\win <> 0
      Gosub eventHandler 
    EndIf

    ; -- update functioncompletion and close any subwindows on key-press
    ;If pedconfig\intellisense
    ; -- update intellisense after DELETE_KEY OR SPACE_KEY                        ; moved it too remove double switch asm-basic-asm and expand with Space-Key support  tomsmart1
    ;      If (last_vankey = $08) OR (last_vankey = $20)
    ;        Gosub intellisense
    ;      EndIf
    ; -- CURSOR_KEYs navigation
    ;      If WZ_IsOpen{"WIN_POPUP"} AND (pedMessage\_Code >(#RAWKEY_UP-1) AND pedMessage\_Code <(#RAWKEY_LEFT+1) )
    ;        Select pedMessage\_Code  ; test only rawkey code for cursor keys  tomsmart1
    ;          Case #RAWKEY_UP    : WZ_SetPopUpEntry{popupdata\selected_entry - 1}
    ;          Case #RAWKEY_DOWN  : WZ_SetPopUpEntry{popupdata\selected_entry + 1}
    ;          Case #RAWKEY_RIGHT : Gosub close_popupwindow
    ;          Case #RAWKEY_LEFT  : Gosub close_popupwindow
    ;        End Select
    ;      EndIf

    Gosub close_contexthelp

    If last_vankey.b > 0 Then Gosub immediate_syntaxhelp
  Wend
  ;log_Print{"exit pedevents =================================="}
Return

; ---------------------------------- THIS IS THE MAINLOOP -----------------------------------------
.main_loop:
  exit_mainloop.b = False

  While NOT exit_mainloop
    ped\labelListChanged = False
    sourceWindow\redrawFlag = False

    ;log_Print{"### handlePedevents"}
    Gosub handlePedEvents
    ;log_Print{"### handlpepedevents end"}

    ;-- check if an executable is running and prevent IDE from doing things
    If ped\ptrCurrentSourceData\RunningFlag
      If exit_loop_class.b = -3 OR last_vankey.b = #VANILLAKEY_UP OR last_vankey= #VANILLAKEY_DOWN OR last_vankey = #VANILLAKEY_HELP
        If PED_PanicCheck{} 
          If ped\ptrCurrentSourceData\KeyBeforeReturn
            log_Print{"as an exe is running, revert the entered key"}
            PED_RedrawSource{}
            ped\ptrCurrentSourceData\KeyBeforeReturn = 0
          EndIf

          Goto bottom_of_mainloop
        EndIf
      EndIf
    EndIf

    If ped\ptrCurrentSourceData\KeyBeforeReturn
      ;log_Print{"** parse the line after event, lastkey = " + Hexw$(ped\ptrCurrentSourceData\KeyBeforeReturn)}

      ; --- get number of actual source line
      sourceWindow\lastEditedLine = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset

      ; -- parse the current line
      lineaddr.l = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset
      PED_PreparseTextLine{lineaddr}

      newline$ = Peeks$(lineaddr,#MAX_Columns)
      newline$ = StripTrail$(newline$,@" ")
      newline$ = PED_TokenizeText{newline$}
      *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
      ;log_Print{"result for new line:"}
      ;!log_HexDump{*newLine, *newLine\strLength + 8}
      PED_ReplaceCurrentSourceLine{*newLine}
   
      ; -- print the tokenized source line if tokenizing
      If ped\doTokenize
        PED_CursorOff{}
        PED_PrintCurrentSourceLine{False}
        PED_CursorOn{}
      EndIf
    EndIf

    sourceWindow\redrawFlag = False
    If exit_loop_class.b = -3 Then sourceWindow\redrawFlag = True

    ; -- call function selected in comArray_KeyTable
    ;log_Print{"***** Last_vankey = " + Hex$(last_vankey.b)}
    ;log_Print{"***** exit class:" + Str$(exit_loop_class.b)}

    If exit_eventloop.b <> 0
      Gosub close_popupwindow
      
      ;log_Print{"***** executing actions hold back ... " + Hex$(last_vankey)}
      Select last_vankey
      Case #VANILLAKEY_RETURN: PED_InsertReturn{}
      Case #VANILLAKEY_UP:     mqualifier.w = ped\ptrCurrentSourceData\QualifierStore : Gosub do_VANILLAKEY_UP
      Case #VANILLAKEY_DOWN:   mqualifier = ped\ptrCurrentSourceData\QualifierStore : Gosub do_VANILLAKEY_DOWN
      End Select

      If exit_loop_class = -3 OR exit_loop_class= -4 Then Gosub event_leftmousebutton
      If exit_loop_class = -2 Then Gosub event_menu
    EndIf

    ;--
    ;-- check for some tokens and automatically add the closing token
    If pedconfig\auto_constructs AND NOT exit_mainloop
      If last_vankey.b = #VANILLAKEY_RETURN
        tmpStringVar = autoCompleteContructs{ped\ptrCurrentSourceData\CurrentSourceLine}
        If tmpStringVar <> ""
          PED_InsertStringToTextBuffer{tmpStringVar}
          PED_InsertReturn{}
          PED_MoveCursorDown{}
        EndIf
      EndIf
    EndIf

    ;--
    bottom_of_mainloop:
    If NOT exit_mainloop
      If ped\labelListChanged Then Gosub reset_labellist
      Gosub update_helpdiag
      PED_UpdateStatusArea{#STATUS_SCROLLERS}
    EndIf
  Wend

Return
; ----------------------------------------- END OF MAINLOOP -------------------------------------

.menu_autolayout:
  Select _menuitem.l
  Case $171 : ped\lastAutoLayout = 0
  Case $172 : ped\lastAutoLayout = 1
  Case $173 : ped\lastAutoLayout = 2
  End Select
  log_Print{"doing autolayout " + Str$(ped\lastAutoLayout)}
  AutoLayout{&wtemp,ped\lastAutoLayout}
  Gosub do_windowlayout
;  pedconfig\autolayout + 1
;  If pedconfig\autolayout > 2 Then pedconfig\autolayout = 0
Return

.menu_settings:
 PED_SetPointerBusy{}

 WZWindow WZID("WIN_SETTINGS"),?wzgui,255,-2,-2,-2,-2,WZID("WIN_SETTINGS")
 Use Window WZID("WIN_SETTINGS")

 ; make tab 0 active
 WZPrint "SET_PAGES",0

  ; init tempcolors
 For i.l = 0 To (#MAX_AB3Pens-1) ; relaced wrong 24 by #Max_AB3Pens -1, -1 because 0 to 23  tomsmart1
  AB3RGB_temp(i) = AB3RGB(i)
 Next i

 ;-- init gadgets
 If pedconfig\auto_format       Then WZPrint "SET_AUTO_FORMAT"        ,On
 If pedconfig\auto_constructs   Then WZPrint "SET_COMPLETE_CONSTRUCTS",On
 If pedconfig\intellisense      Then WZPrint "SET_INTELLISENSE"       ,On
 If pedconfig\correct_functions Then WZPrint "SET_CORRECT_FUNCTIONS"  ,On
 If pedconfig\smart_tokenization Then WZPrint "SET_SMART_TOKENIZATION" ,On

 If pedconfig\no_welcome        Then WZPrint "SET_WELCOME"            ,On
 If pedconfig\ask_before_quit   Then WZPrint "SET_ASKBEFOREQUIT"      ,On
 If NOT pedconfig\localization  Then WZPrint "SET_LOCALIZATION",On

 If pedconfig\onlinehelp        Then WZPrint "SET_ONLINEHELP"         ,On
 If pedconfig\highlighting      Then WZPrint "SET_HIGHLIGHTING"       ,On
 If pedconfig\bold_tokens       Then WZPrint "SET_BOLDTOKENS"         ,On
 If pedconfig\linenumbers       Then WZPrint "SET_LINENUMBERS"        ,On : oldlinenumbers.b = pedconfig\linenumbers
 If pedconfig\remember_saved    Then WZPrint "SET_REMEMBER_SAVED"     ,On
 If pedconfig\load_last_source  Then WZPrint "SET_LAST_SOURCE"        ,On

 If pedconfig\use_pubscreen     Then WZPrint "SET_PUBSCREEN"          ,On
 If pedconfig\use_default_pubscreen Then WZPrint "SET_DEFAULTPUBSCREEN",On
 If pedconfig\use_filepattern   Then WZPrint "SET_FILEPATTERN"        ,On
 If pedconfig\auto_indent       Then WZPrint "SET_AUTO_INDENT"        ,On
 If pedconfig\autolayout        Then WZPrint "SET_AUTOLAYOUT"         ,On
 If pedconfig\no_display_beep   Then WZPrint "SET_NO_DISPLAYBEEP"     ,On

 If pedconfig\console_device <> ""    Then WZPrint "SET_CONSOLE_DEVICE"     ,&pedconfig\console_device
 If pedconfig\console_wb      =  True  Then WZPrint "SET_CONSOLE_ON_WB"      ,True
 If pedconfig\console_wait    =  True  Then WZPrint "SET_CONSOLE_WAIT"       ,True
 ;if console_dontclose = true       Then wzprint "SET_CONSOLE_

 WZPrint "SET_SORTLABELS"     ,pedconfig\sort_labels
 WZPrint "SET_CURSORSTYLE"    ,pedconfig\cursorStyle

 WZDisable "SET_ITALICREMARKS"  ; field obsolete will be removed later TODO

; If NOT ped\no_scrollrate
;   WZDisable "SET_SCROLLRATE"
; Else
   WZPrint "SET_SCROLLRATE"   , pedconfig\scroll_rate
; EndIf

 WZPrint "SET_TAB_SIZE"       , pedconfig\tabSize
 WZPrint "SET_CURSORBLINKRATE", pedconfig\blinkrate

 If OSVersion = #AmigaOS4                           ; check if OS4
   WZDisable "SET_MOUSEWHEELSTEP"                   ; yes disable it becau we use the System value
 Else                                               ; no print used value.
   WZPrint "SET_MOUSEWHEELSTEP",pedconfig\wheelStep  ; add to make Mousewheelsteprate configuratable and saveable tomsmart1
 EndIf

 tmpSourceDir.s  = pedconfig\sourceDir
 tmpIncludeDir.s = pedconfig\includeDir
 tmpAutoDocDir.s = pedconfig\autodocDir
 tmpHelpDir.s    = pedconfig\helpDir
 tmpUtillibFile.s= pedconfig\utillibFile
 tmpOslibFile.s  = pedconfig\oslibFile
 tmpCslibFile.s  = pedconfig\cslibFile

 WZPrint "SET_SOURCEDIR"  ,&tmpSourceDir
 WZPrint "SET_INCDIR"     ,&tmpIncludeDir
 WZPrint "SET_AUTODOCDIR" ,&tmpAutoDocDir
 WZPrint "SET_HELPDIR"    ,&tmpHelpDir

 WZPrint "SET_UTILLIBS",pedconfig\useUtilLib
 WZPrint "SET_OSLIBS",pedconfig\useOsLib
 WZPrint "SET_CSLIBS",pedconfig\useCsLib

 WZPrint "SET_UTILLIBS_PATH",&tutillibfile$
 WZPrint "SET_OSLIBS_PATH"  ,&tmpOslibFile
 WZPrint "SET_CSLIBS_PATH"  ,&tmpCslibFile

 ;-- get screen infos
 temp_id.l     = pedconfig\screen_modeID
 temp_width.w  = pedconfig\screen_Width
 temp_height.w = pedconfig\screen_Height
 temp_depth.w  = pedconfig\screen_Depth

 ;-- get screenname
 log_Print{"getting screenmodename for id: " + Str$(temp_id)}
 temp_scr$ = screen_GetModeName{temp_id}
 log_Print{"modename = " + Str$(temp_scr$)}

 ;--  check if the ID unknown then get best match
 If temp_scr$ = "unknown"
   log_Print{"screenmode unknown, searching for best match available mode..."}
   If ExecVersion < 39
     temp_id.l = 0
     log_Print{"we need OS3+ to do this!"}
   Else
     temp_id.l = screen_GetBestModeID{temp_width,temp_height,temp_depth}
     log_Print{"most matching id: " + Str$(temp_id)}
   EndIf
   temp_scr$ = screen_GetModeName{temp_id}
   log_Print{"modename = " + temp_scr$}
 EndIf

 ;-- set screenrequester initials
 screen_SetASLInitialDims{temp_id,temp_width,temp_height,temp_depth}
 WZPrint "SET_SCREENNAME",&temp_scr$

 ;-- get font infos
 newsourcefont_name$  = sourcefont_name$
 newsourcefont_size.l = sourcefont_size
 newguifont_name$     = guifont_name$
 newguifont_size.l    = guifont_size
 tempstr$             = newsourcefont_name$ + " ("+Str$(newsourcefont_size)+")"
 WZPrint "SET_SOURCEFONTNAME",&tempstr$
 tempstr2$            = guifont_name$+" ("+Str$(guifont_size)+")"
 WZPrint "SET_GUIFONTNAME",&tempstr2$
 olduse_wbfont.b      = pedconfig\use_wbfont               ; temp variables to check former stat
 olduse_wbscreen.b    = pedconfig\use_wbscreen

 If pedconfig\use_wbscreen <> 0
   WZPrint "SET_USEWB"  ,On
   WZPrint "SET_CLONEWB",Off
   WZDisable "SET_SCREENNAME"
   WZDisable "SET_SCREEN"
   For i = 0 To 3
    WZDisable "SET_SCREENCOL" + Str$(i)   ; disable Screencolors
   Next i
   usewbscreen_tmp.b = True             ; temporay variable for prefs window
 Else
   For i = 0 To 3
    WZEnable "SET_SCREENCOL" + Str$(i)    ; enable Screencolors
   Next i
   usewbscreen_tmp.b = False
 EndIf

 If pedconfig\clone_wbscreen <> 0
   WZPrint "SET_USEWB"  ,Off
   WZPrint "SET_CLONEWB",On
   WZDisable "SET_SCREENNAME"
   WZDisable "SET_SCREEN"
   usewbscreen_tmp.b = False
 EndIf

 If pedconfig\use_wbfont = True                   ;<>0
   WZPrint "SET_USEWBFONT", On
   WZDisable "SET_SOURCEFONT"
   WZDisable "SET_SOURCEFONTNAME"
   WZDisable "SET_GUIFONT"
   WZDisable "SET_GUIFONTNAME"
   usewbfont_tmp.b = True               ; temporay variable for prefs window
 Else
   WZPrint "SET_USEWBFONT", Off
   WZEnable "SET_SOURCEFONT"
   WZEnable "SET_SOURCEFONTNAME"
   usewbfont_tmp.b = False
   If usewbscreen_tmp.b = True          ; only active GuiFontsettings if we don't use WBscreen
     WZDisable "SET_GUIFONT"
     WZDisable "SET_GUIFONTNAME"
   Else
     WZEnable "SET_GUIFONTNAME"
     WZEnable "SET_GUIFONT"
   EndIf
 EndIf

 ;-- color wheel
 *cw_gad.Gadget = WZGadAddr("SET_COLORWHEEL")
 cw_open.b          = False                             ; type was .l changed to .b because function return is only .b  tomsmart
 colnum.w           = -1
 rebuild_gui.b      = False
 rebuild_sourcewindow.b = False
 rebuild_menu.b     = False

 settings_loop:
 exit_settings.b    = False
 save_settings.b    = False
 use_settings.b     = False
 reopen_settings.b  = False
 update_colors.b    = False
 SliderUsed.b       = False

 Repeat
   ev.l = WaitEvent

   If pedconfig\onlinehelp <> 0
      If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) AND (ev<>#IDCMP_GADGETHELP)  AND (ev<>#IDCMP_CHANGEWINDOW)
        WZ_HideBubble{}
      Else
        If (ev = #IDCMP_GADGETHELP) Then WZ_ShowBubble{}
      End If
   EndIf

   Select ev
     Case #IDCMP_MOUSEMOVE
       If SliderUsed = True       ; check if colorslider used before
         SliderUsed = False       ; set it back
       Else
         If (WZInput("SET_PAGES") = 3) AND (cw_open = True)
          
           ;-- get current RGB-Value in relation to the Gradient-slider
           _RGB.l = WZ_GetColorWheelRGB{}
          
           ;-- update sliders and colorboxes
           If _RGB <> old_RGB.l
             WZ_SetColorGradientSlider{_RGB}
             Gosub update_colorsliders             
             old_RGB = _RGB
             update_colors.b = True
             If colnum <> -1
               AB3RGB_temp(colnum)= _RGB
               Gosub update_colorboxes
             EndIf
           EndIf
         EndIf
       EndIf

     Case #IDCMP_VANILLAKEY
       Select EventCode
         Case #VANILLAKEY_ESC : exit_settings = True
       End Select

     Case #IDCMP_REFRESHWINDOW
       Gosub update_colorwheel
       Gosub update_colorboxes

     Case #IDCMP_CLOSEWINDOW
       exit_settings = True

     Case #IDCMP_IDCMPUPDATE
       ;-- check the colorgadgets
       If Left$(WZGadName,9) = "SET_COLOR"
         colnum = Vallong(Replace$(WZGadName,"SET_COLOR",""))
         Gosub update_colorboxes
         
         _RGB = AB3RGB_temp(colnum) : old_RGB = _RGB
         Gosub update_colorsliders

         If (ColorWheelError = False) Then WZ_SetColorWheelRGB{AB3RGB_temp(colnum)}

         update_colors = True
       Else
         If Left$(WZGadName,13) = "SET_SCREENCOL"
           colnum.w = Vallong(Replace$(WZGadName,"SET_SCREENCOL","")) + 20
           Gosub update_colorboxes
           
           _RGB = AB3RGB_temp(colnum) : old_RGB = _RGB
           Gosub update_colorsliders

           If (ColorWheelError = False) Then WZ_SetColorWheelRGB{AB3RGB_temp(colnum)}

           update_colors = True           
           rebuild_gui   = True
         EndIf
       EndIf

       ;-- check all other gadgets
       Select WZGadName

         Case "SET_PAGES"
           If WZInput("SET_PAGES") = 3
             If (ExecVersion > 38)
               Gosub update_colorwheel
               Gosub update_colorboxes
             Else
              error{"Color settings are not available with Workbench <V3.0."}
              WZPrint "SET_PAGES",0
             EndIf
           EndIf
         ; begin check new Gadgets of color page, tempstorage, sliders and integers  tomsmart1
         Case "COPYTOTEMP"        ; copy used color to tempstorage
           AB3RGB_copytemp = _RGB
           Gosub update_colorboxes

         Case "COPYTEMPTO"        ; used color of tempstorage
           _RGB = AB3RGB_copytemp
           Gosub set_color_slider_wheel_boxes

         Case "REDSLIDER"
           RedSlider.l = WZInput
           _RGB = (_RGB & $FF00FFFF) + (RedSlider LSL 16)
           Gosub set_color_slider_wheel_boxes
           SliderUsed = True

         Case "GREENSLIDER"
           GreenSlider.l = WZInput
           _RGB = (_RGB & $FFFF00FF) + (GreenSlider LSL 8)
           Gosub set_color_slider_wheel_boxes
           SliderUsed = True

         Case "BLUESLIDER"
           BlueSlider.l = WZInput
           _RGB = (_RGB & $FFFFFF00) + BlueSlider
           Gosub set_color_slider_wheel_boxes
           SliderUsed = True

         Case "REDIN"
           RedSlider = WZInput
           _RGB = (_RGB & $FF00FFFF) + (RedSlider LSL 16)
           Gosub set_color_slider_wheel_boxes

         Case "GREENIN"
           GreenSlider = WZInput
           _RGB = (_RGB & $FFFF00FF) + (GreenSlider LSL 8)
           Gosub set_color_slider_wheel_boxes

         Case "BLUEIN"
           BlueSlider = WZInput
           _RGB = (_RGB & $FFFFFF00) + BlueSlider
           Gosub set_color_slider_wheel_boxes
         ; end new gadgets of colors page

         Case "SET_SOURCEDIR"
           tmpSourceDir = WZInputstr
           WZPrint "SET_SOURCEDIR",&tmpSourceDir

         Case "BUTTON_SOURCEDIR"
           aslfr_SetRequesterTitle {0,!TRANS{ "Please select source directory:"},"",""}
           aslfr_SetPath{0,tmpSourceDir,"",""}
           If aslfr_Request{0,False,False,True,sourceWindow\pedScreen}
             tmpSourceDir = aslfr_GetNextFile{}
             WZPrint "SET_SOURCEDIR",&tmpSourceDir
           EndIf

         Case "SET_INCDIR"
           tmpIncludeDir = WZInputstr
           WZPrint "SET_INCDIR",&tmpIncludeDir

         Case "BUTTON_INCDIR"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select includes directory:"},"",""}
           aslfr_SetPath{0,tmpIncludeDir,"",""}
           If aslfr_Request{0,False,False,True,sourceWindow\pedScreen}
             tmpIncludeDir = aslfr_GetNextFile{}
             WZPrint "SET_INCDIR",&tmpIncludeDir
           EndIf

         Case "SET_HELPDIR"
           tmpHelpDir = WZInputstr
           WZPrint "SET_HELPDIR",&tmpHelpDir

         Case "BUTTON_HELPDIR"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select help directory:"},"",""}
           aslfr_SetPath{0,tmpHelpDir,"",""}
           If aslfr_Request{0,False,False,True,sourceWindow\pedScreen}
             tmpHelpDir = aslfr_GetNextFile{}
             WZPrint "SET_HELPDIR",&tmpHelpDir
           EndIf

         Case "SET_AUTODOCDIR"
           tmpAutoDocDir = WZInputstr
           WZPrint "SET_AUTODOCDIR",&tmpAutoDocDir

         Case "BUTTON_AUTODOCDIR"
           aslfr_SetRequesterTitle {0,!TRANS{ "Please select AutoDocs directory:"},"",""}
           aslfr_SetPath{0,tmpAutoDocDir,"",""}
           If aslfr_Request{0,False,False,True,sourceWindow\pedScreen}
             tmpAutoDocDir = aslfr_GetNextFile{}
             WZPrint "SET_AUTODOCDIR",&tmpAutoDocDir
           EndIf

         Case "BUTTON_UTILLIBS"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select UtilLibs file:"},"",""}
           aslfr_SetPath{0,dos_PathPart{tutillibfile$},dos_FilePart{tutillibfile$},"#?"}
           If aslfr_Request{0,False,False,False,sourceWindow\pedScreen}
            tmpUtillibFile = aslfr_GetNextFile{}
             WZPrint "SET_UTILLIBS_PATH",&tutillibfile$
           EndIf

         Case "BUTTON_OSLIBS"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select OsLibs file:"},"",""}
           aslfr_SetPath{0,dos_PathPart{tmpOslibFile},dos_FilePart{tmpOslibFile},"#?"}
           If aslfr_Request{0,False,False,False,sourceWindow\pedScreen}
             tmpOslibFile = aslfr_GetNextFile{}
             WZPrint "SET_OSLIBS_PATH",&tmpOslibFile
           EndIf

         Case "BUTTON_CSLIBS"
           aslfr_SetRequesterTitle {0,!TRANS{"Please select CsLibs file:"},"",""}
           aslfr_SetPath{0,dos_PathPart{tmpCslibFile},dos_FilePart{tmpOslibFile},"#?"}
           If aslfr_Request{0,False,False,False,sourceWindow\pedScreen}
             tmpOslibFile = aslfr_GetNextFile{}
             WZPrint "SET_CSLIBS_PATH",&tmpCslibFile
           EndIf

         Case "SET_PUBSCREEN"
           If WZInput = 0
             WZPrint "SET_DEFAULTPUBSCREEN",Off : WZDisable "SET_DEFAULTPUBSCREEN"
           Else
             WZEnable "SET_DEFAULTPUBSCREEN"
           EndIf
           rebuild_gui = True

         Case "SET_DEFAULTPUBSCREEN"
           rebuild_gui = True

         Case "SET_REMEMBER_SAVED"
           rebuild_menu = True

         Case "SET_CLONEWB"
           If WZInput
             WZDisable "SET_SCREENNAME"
             WZDisable "SET_SCREEN"
             WZPrint   "SET_USEWB",Off
             usewbscreen_tmp.b = False
             If usewbfont_tmp.b = False     ;only actived GUIfontsetting if we don't use WBFonts
               WZEnable "SET_GUIFONTNAME"
               WZEnable "SET_GUIFONT"
             EndIf
           Else
             WZEnable "SET_SCREENNAME"
             WZEnable "SET_SCREEN"
           EndIf
           rebuild_gui = True

         Case "SET_USEWB"
           If WZInput
             For i = 0 To 3
              WZDisable "SET_SCREENCOL"+Str$(i)
             Next i
             WZDisable "SET_SCREENNAME"
             WZDisable "SET_SCREEN"
             WZPrint   "SET_CLONEWB",Off
             usewbscreen_tmp.b = True       ; deactived GUIFontsettings we use WBScreen
             WZDisable "SET_GUIFONT"
             WZDisable "SET_GUIFONTNAME"
           Else
             For i = 0 To 3
              WZEnable "SET_SCREENCOL"+Str$(i)
             Next i
             WZEnable "SET_SCREENNAME"
             WZEnable "SET_SCREEN"
             usewbscreen_tmp.b = False
               If usewbfont_tmp.b = False    ;only actived GUIfontsetting if we don't use WBFonts
                 WZEnable "SET_GUIFONTNAME"
                 WZEnable "SET_GUIFONT"
             EndIf
           EndIf
           rebuild_gui = True

         Case "SET_SCREEN"
           aslsm_SetRequesterTitle {!TRANS{"Please select screenmode:"},"",""} ;!TRANS{"Ok"},!TRANS{"Cancel"}}  ; use system default  tomsmart1
           aslsm_SetMinDims{640,480,2}
           If aslsm_Request{}
              temp_id.l     = screen_GetASLModeID{}
              temp_width.w  = screen_GetASLWidth{}
              temp_height.w = screen_GetASLHeight{}
              temp_depth.w  = screen_GetASLDepth{}
              temp_scr$     = screen_GetASLModeName{}
              log_Print{"selected screen depth: " + Str$(temp_depth),#log_debug}
              WZPrint "SET_SCREENNAME",&temp_scr$
              log_Print{"written screenname... " + temp_scr$}
              rebuild_gui   = True
           EndIf

         Case "SET_GUIFONT"
           aslfo_SetRequesterTitle {!TRANS{"Please select GUI-Font:"},"",""} ;!TRANS{"Ok"},!TRANS{"Cancel"}}  ; use system default  tomsmart1
           aslfo_SetInitialFont{newguifont_name$,newguifont_size}
           If aslfo_Request{True}
             newguifont_name$      = aslfo_GetFontName{}
             newguifont_size   = aslfo_GetFontSize{}
             ;newguifontstyle = *finfo2\ta_Style
             tempstr2$= newguifont_name$ + " ("+Str$(newguifont_size)+")"
             WZPrint "SET_GUIFONTNAME",&tempstr2$
           EndIf

         Case "SET_USEWBFONT"
           If WZInput
             usewbfont_tmp.b = True
             WZDisable "SET_GUIFONT"
             WZDisable "SET_GUIFONTNAME"
             WZDisable "SET_SOURCEFONT"
             WZDisable "SET_SOURCEFONTNAME"
           Else
             usewbfont_tmp.b = False
             WZEnable "SET_SOURCEFONTNAME"
             WZEnable "SET_SOURCEFONT"
             If usewbscreen_tmp.b = False     ; make GUIfont selectable only if we don't use wbscreen
               WZEnable "SET_GUIFONT"
               WZEnable "SET_GUIFONTNAME"
             EndIf
           EndIf
           rebuild_gui = True

         Case "SET_SOURCEFONT"
           aslfo_SetRequesterTitle {!TRANS{"Please select Source-Font:"},"",""} ;!TRANS{"Ok"},!TRANS{"Cancel"}}  ; use system default tomsmart1
           aslfo_SetInitialFont{newsourcefont_name$,newsourcefont_size}
           If aslfo_Request{False}
             newsourcefont_name$     = aslfo_GetFontName{}
             newsourcefont_size  = aslfo_GetFontSize{}
             ;newsourcefontstyle = *finfo2\ta_Style
             tempstr$= newsourcefont_name$ + " ("+Str$(newsourcefont_size)+")"
             WZPrint "SET_SOURCEFONTNAME",&tempstr$
           EndIf


         Case "SET_F4"
           savewinpref{0} : Gosub write_newprefs

         Case "SET_F5"
           savewinpref{1} : Gosub write_newprefs

         Case "SET_F6"
           savewinpref{2} : Gosub write_newprefs


         ; UNTERSTE BUTTON-ZEILE
         Case "SET_SAVE"
           save_settings   = True
           use_settings    = True
           exit_settings   = True

         Case "SET_USEEXIT"
           use_settings    = True
           exit_settings   = True

         Case "SET_USE"
           use_settings    = True
           exit_settings   = True
           reopen_settings = True

         Case "SET_CANCEL"
           use_settings    = False
           reopen_settings = False
           exit_settings   = True

       End Select

      ;log_Print{"end_of_event"}
   End Select
 Until exit_settings = True

 ;log_Print{"settings loop finished."}
 If use_settings = True
   log_Print{"storing all settings"}
   WZ_LockWindow{"WIN_SETTINGS"}

   pedconfig\auto_indent =       -WZInput("SET_AUTO_INDENT")
   pedconfig\auto_format =       -WZInput("SET_AUTO_FORMAT")
   pedconfig\auto_constructs =   -WZInput("SET_COMPLETE_CONSTRUCTS")
   pedconfig\intellisense =      -WZInput("SET_INTELLISENSE")
   pedconfig\correct_functions=  -WZInput("SET_CORRECT_FUNCTIONS")
   pedconfig\smart_tokenization= -WZInput("SET_SMART_TOKENIZATION")
   pedconfig\no_welcome =        -WZInput("SET_WELCOME")
   pedconfig\ask_before_quit =   -WZInput("SET_ASKBEFOREQUIT")
   pedconfig\localization =      NOT(-WZInput("SET_LOCALIZATION"))
   pedconfig\onlinehelp =        -WZInput("SET_ONLINEHELP")
   pedconfig\bold_tokens =       -WZInput("SET_BOLDTOKENS")
   pedconfig\highlighting =      -WZInput("SET_HIGHLIGHTING")
   pedconfig\linenumbers =       -WZInput("SET_LINENUMBERS")
   pedconfig\remember_saved =    -WZInput("SET_REMEMBER_SAVED")
   pedconfig\load_last_source =  -WZInput("SET_LAST_SOURCE")
   pedconfig\use_pubscreen    =  -WZInput("SET_PUBSCREEN")
   pedconfig\use_default_pubscreen = -WZInput("SET_DEFAULTPUBSCREEN")
   pedconfig\use_filepattern  =  -WZInput("SET_FILEPATTERN")
   pedconfig\use_wbscreen =      -WZInput("SET_USEWB")
   pedconfig\clone_wbscreen =    -WZInput("SET_CLONEWB")
   pedconfig\use_wbfont =        -WZInput("SET_USEWBFONT")
   pedconfig\no_display_beep =   -WZInput("SET_NO_DISPLAYBEEP")
   pedconfig\console_device  =    WZGetString("SET_CONSOLE_DEVICE")
   ;console_keepopen = WZInput("SET_CONSOLE_KEEPOPEN")
   pedconfig\console_wb       =  -WZInput("SET_CONSOLE_ON_WB")
   pedconfig\console_wait     =  -WZInput("SET_CONSOLE_WAIT")
   pedconfig\sort_labels =       -WZInput("SET_SORTLABELS")
   pedconfig\scroll_rate =        WZInput("SET_SCROLLRATE")
   pedconfig\cursorStyle =        WZInput("SET_CURSORSTYLE")
   If pedconfig\scroll_rate = 0 Then ped\no_scrollrate = True Else vvblank_SetFreq{pedconfig\scroll_rate}

   pedconfig\tabSize =  WZInput("SET_TAB_SIZE")
   pedconfig\blinkrate =  WZInput("SET_CURSORBLINKRATE")
   pedconfig\wheelStep =  WZInput("SET_MOUSEWHEELSTEP")     ; added to make Mousewheelsteprate changeable, no special OS4 handling nessacary because the System settings are used by any event  tomsmart1
   pedconfig\autolayout= -WZInput("SET_AUTOLAYOUT")

   ; store directories
   pedconfig\sourceDir  = tmpSourceDir
   pedconfig\includeDir = tmpIncludeDir
   pedconfig\autodocDir = tmpAutoDocDir
   pedconfig\helpDir    = tmpHelpDir
   pedconfig\utillibFile =tmpUtillibFile
   pedconfig\oslibFile  = tmpOslibFile
   pedconfig\cslibFile  = tmpCslibFile

   pedconfig\useUtilLib  = -WZInput("SET_UTILLIBS")
   pedconfig\useOsLib  = -WZInput("SET_OSLIBS")
   pedconfig\useCsLib  = -WZInput("SET_CSLIBS")


   If temp_id <> pedconfig\screen_modeID
     pedconfig\screen_modeID = temp_id
     pedconfig\screen_Width = temp_width
     pedconfig\screen_Height = temp_height
     pedconfig\screen_Depth = temp_depth
     rebuild_gui    = True
   EndIf

   If ( (newguifont_name$<>guifont_name$) OR (newguifont_size<>guifont_size) ) AND ( (NOT pedconfig\use_wbfont) AND (pedconfig\use_wbscreen=0) )
     guifont_name$   = newguifont_name$
     guifont_size    = newguifont_size
     guifont_style.l = newguifont_style.l
     rebuild_gui    = True
   Else
     If ( (pedconfig\use_wbfont AND (NOT olduse_wbfont) ) AND olduse_wbscreen=0 ) OR ( ( (pedconfig\use_wbscreen<>0) AND (olduse_wbscreen=0) ) AND (NOT olduse_wbfont) )
      log_Print{"setguifonttowbscreenfont"}
      Gosub SetGuiFontToWBScreenFont
      rebuild_gui = True
     EndIf
   EndIf


   ; update colors
   If update_colors = True
     For i = 0 To (#MAX_AB3Pens-1) ; relaced wrong 24 by #Max_AB3Pens -1, -1 because 0 to 23  tomsmart1
       AB3RGB(i) = AB3RGB_temp(i)
     Next i
     If rebuild_gui = False          ; update screencolors only if GUI not rebuild else we trash maybe the Wbscreencolors
       Gosub set_storedcolors
       update_colors.b = False
     EndIf
   EndIf

   If ( (newsourcefont_name$ <> sourcefont_name$) OR (newsourcefont_size <> sourcefont_size) ) AND (NOT pedconfig\use_wbfont)
     sourcefont_name$ = newsourcefont_name$
     sourcefont_size  = newsourcefont_size
     sourcefont_style.b = newsourcefont_style.b
     Gosub open_sourcefonts
     rebuild_sourcewindow = True
   EndIf

   If pedconfig\use_wbfont AND (NOT olduse_wbfont)
     ; get WBfont for Sourcefont
     sourcefont_name$ = ""     ;that open_sourcefonts get the WBfont
     Gosub open_sourcefonts
     rebuild_sourcewindow = True
   EndIf

   If oldlinenumbers <> pedconfig\linenumbers Then rebuild_sourcewindow = True

   If (rebuild_sourcewindow = True) AND (rebuild_gui = False)
     log_Print{"rebuilding the source window..."}

     PED_SetPointerBusy{}
     Gosub close_sourcewindow
     Gosub open_sourcewindow
     If ped\errorCode = #PEDERROR_OPENWINDOW
       dummy.l = ask{!TRANS{"Unable to open window"},!TRANS{"Ok"},!TRANS{"Error"}}
       Pop If
       Goto exit_PED_closeall
     EndIf

     WindowToFront_ Peek.l(Addr Window(WZID("WIN_SETTINGS")))
     PED_SetPointerNormal{}     
   Else
     log_Print{"just redraw source"}
     PED_RedrawSource{}
   EndIf

   WZ_UnlockWindow{"WIN_SETTINGS"}
 EndIf

 If reopen_settings Then Goto settings_loop

 If save_settings
   log_Print{"saving settings..."}
   WZ_LockWindow{"WIN_SETTINGS"}
   Gosub write_newprefs
   Gosub set_tooltypes
   WZ_UnlockWindow{"WIN_SETTINGS"}
   log_Print{"saving settings done"}
 EndIf

 If cw_open Then WZ_KillColorWheel{} : cw_open = False
 WZCloseWindow WZID("WIN_SETTINGS")
 FlushEvents
 PED_SetPointerNormal{}

 If rebuild_gui
   log_Print{"rebuilding the gui..."}
   Gosub close_gui
   Gosub open_sourcefonts
   Gosub open_gui
 EndIf
 If rebuild_menu
   Gosub init_menus
 EndIf

 Gosub activatesourcewindow
Return

Statement UpdateColorBox{*rp.RastPort, *gad.Gadget, width.w, boxcolor.w, boxpen.w}
  boxx.w = *gad\LeftEdge + *gad\Width + 2
  boxw.w = boxx + width
  boxy.w = *gad\TopEdge
  If width = 20
    boxh.w = boxy + *gad\Height - 1
  Else
    boxh.w = boxy + *gad\Height
  EndIf

  SetAPen_ *rp, boxcolor
  RectFill_ *rp, boxx + 1,boxy + 1,boxw - 1,boxh - 1
  
  SetAPen_ *rp, boxpen
  Move_ *rp, boxx, boxy
  Draw_ *rp, boxw, boxy
  Draw_ *rp, boxw, boxh
  Draw_ *rp, boxx, boxh
  Draw_ *rp, boxx, boxy
End Statement

.update_colorboxes:
  If WZInput("SET_PAGES") = 3
    WZ_LockWindow{"WIN_SETTINGS"}    ; added to prevent page switch during drawing  tomsmart1
    *winSettings.Window = Peek.l(Addr Window(WZID("WIN_SETTINGS")))
    *winRP.RastPort = *winSettings\RPort
    boxpen.w = 1 : boxcolor.w = 0

    ;-- sourcetext colors
    For ii.w = 1 To 12
      *gad.Gadget = WZGadAddr("SET_COLOR" + Str$(ii))
      If *gad
        boxcolor = screen_GetPenRGB{AB3RGB_temp(ii)}
        If ii = colnum Then boxpen = 2 Else boxpen = 1
        UpdateColorBox{*winRP, *gad, 20, boxcolor, boxpen}
      EndIf
    Next ii

    ;-- GUI colors
    For ii.w = 0 To 3
      *gad.Gadget = WZGadAddr("SET_SCREENCOL" + Str$(ii))
      If *gad
        boxcolor = screen_GetPenRGB{AB3RGB_temp(20 + ii)}
        If 20 + ii = colnum Then boxpen = 2 Else boxpen = 1
        UpdateColorBox{*winRP, *gad, 20, boxcolor, boxpen}
      EndIf
    Next ii

    ;-- temporarycopy color box
    *gad.Gadget = WZGadAddr("COPYTOTEMP")
    If *gad
      boxcolor = screen_GetPenRGB{AB3RGB_copytemp}
      UpdateColorBox{*winRP, *gad, 16, boxcolor, boxpen}
    EndIf
     
    WZ_UnlockWindow{"WIN_SETTINGS"}
  EndIf
Return


.update_colorwheel:
  If (WZInput("SET_PAGES") = 3) AND (ColorWheelError = False)
    If cw_open
      WZ_KillColorWheel{}
      RefreshWindowFrame_ Peek.l(Addr Window(WZID("WIN_SETTINGS")))
      cw_open = False
    EndIf

    WZ_LockWindow{"WIN_SETTINGS"}  ; added to prevent page switch during drawing  tomsmart1
    cw_open = WZ_DrawColorWheel{*cw_gad\LeftEdge,*cw_gad\TopEdge,*cw_gad\Width,*cw_gad\Height,False}; added flag to not show the error message of the include  tomsmart1
    If cw_open
      If colnum <> -1
        WZ_SetColorWheelRGB{AB3RGB_temp(colnum)} : _RGB = AB3RGB_temp(colnum) : old_RGB = _RGB    ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
      Else
        WZ_SetColorWheelRGB{$FFFFFF}             : _RGB = $FFFFFF : old_RGB = _RGB                ; added set of _RGB and old_RGB because else it is undefind  tomsmart1
        Gosub update_colorsliders  ; added to set the silder to the default settings  tomsmart1
      EndIf
    Else
      ColorWheelError = True
      error{!TRANS{"error creating colorwheel"} }   ; convert to a normal error message  tomsmart1
    EndIf
    WZ_UnlockWindow{"WIN_SETTINGS"}  ; added to prevent page switch during drawing  tomsmart1
  Else     ; not page 2
    If cw_open
      WZ_KillColorWheel{}
      cw_open = False
    EndIf
  EndIf
Return


.update_colorsliders:     ; added to set the colorsliders position and value of the colorintger gadgets  tomsmart1
  RedSlider   = ( (_RGB & $00FF0000) LSR 16)
  GreenSlider = ( (_RGB & $0000FF00) LSR 8)
  BlueSlider  =   (_RGB & $000000FF)
  ;log_Print{Hex$(_RGB) + "  " + Hex$(RedSlider) + "  " + Hex$(GreenSlider) + "  " + Hex$(BlueSlider)}
  WZPrint "REDSLIDER"  , RedSlider
  WZPrint "GREENSLIDER", GreenSlider
  WZPrint "BLUESLIDER" , BlueSlider
  WZPrint "REDIN"      , RedSlider
  WZPrint "GREENIN"    , GreenSlider
  WZPrint "BLUEIN"     , BlueSlider
Return


.set_color_slider_wheel_boxes:  ;added to set the color -wheel, -boxes, -slider and -intger gadgets for a colorslider or intger gadget change  tomsmart1
  old_RGB = _RGB
  
  If (ColorWheelError = False)
    WZ_SetColorWheelRGB{_RGB}   ; update the ColorWheel and GradientSlider
  EndIf

  Gosub update_colorsliders     ; update the sliders and the integer gadgets
  
  If colnum <> -1               ; check if a AB3color is set to change
    update_colors = True
    AB3RGB_temp(colnum) = _RGB  ; set it to the color we set by the slider or get intger gadget
    Gosub update_colorboxes     ; redraw the boxes
  EndIf
Return


.set_tooltypes:
   If ped\AbDiscObject
      log_Print{"saving tooltypes to disk object"}

       ; -- save colors 
       dos_SetToolString{"FUNCTIONCOLOR"   ,"$" + Hex$(AB3RGB(#AB3_cfunction))}
       dos_SetToolString{"MACROCOLOR"      ,"$" + Hex$(AB3RGB(#AB3_cmacro))}
       dos_SetToolString{"STRINGCOLOR"     ,"$" + Hex$(AB3RGB(#AB3_cstring))}
       dos_SetToolString{"NEWTYPECOLOR"    ,"$" + Hex$(AB3RGB(#AB3_cnewtype))}
       dos_SetToolString{"CONSTANTCOLOR"   ,"$" + Hex$(AB3RGB(#AB3_cconstant))}
       dos_SetToolString{"REMARKFORG"      ,"$" + Hex$(AB3RGB(#AB3_cremarkforeground))}
       dos_SetToolString{"REMARKBACKG"     ,"$" + Hex$(AB3RGB(#AB3_cremarkbackground))}
       dos_SetToolString{"TOKENCOLOR"      ,"$" + Hex$(AB3RGB(#AB3_ctoken))}
       dos_SetToolString{"TOKENBACKPEN"    ,"$" + Hex$(AB3RGB(#AB3_ctokenbackground))}
       dos_SetToolString{"BACKGROUNDCOLOR" ,"$" + Hex$(AB3RGB(#AB3_cbackground))}
       dos_SetToolString{"OTHERCOLOR"      ,"$" + Hex$(AB3RGB(#AB3_cother))}
       dos_SetToolString{"CLASSICCOLOR"    ,"$" + Hex$(AB3RGB(#AB3_cclassic))}
       dos_SetToolString{"screenbackcolor" ,"$" + Hex$(AB3RGB(#AB3_screenback))}
       dos_SetToolString{"screentextcolor" ,"$" + Hex$(AB3RGB(#AB3_screentext))}
       dos_SetToolString{"screenshinecolor","$" + Hex$(AB3RGB(#AB3_screenshine))}
       dos_SetToolString{"screenfillcolor" ,"$" + Hex$(AB3RGB(#AB3_screenfill))}

       ; save Screen settings
       dos_SetToolSwitch{"USE_WBSCREEN"    ,pedconfig\use_wbscreen}  ;-WZInput("SET_USEWB")}
       dos_SetToolSwitch{"CLONE_WBSCREEN"  ,pedconfig\clone_wbscreen};-WZInput("SET_CLONEWB")}
       dos_SetToolSwitch{"DEFAULTPUBSCREEN",pedconfig\use_default_pubscreen};-WZInput("SET_DEFAULTPUBSCREEN")}
       dos_SetToolSwitch{"PUBSCREEN"       ,pedconfig\use_pubscreen} ;-WZInput("SET_PUBSCREEN")}

       ;save ownscreen parameters
       dos_SetToolValue{"SCREEN_ID"        ,pedconfig\screen_modeID}
       dos_SetToolValue{"SCREEN_WIDTH"     ,pedconfig\screen_Width}
       dos_SetToolValue{"SCREEN_HEIGHT"    ,pedconfig\screen_Height}
       dos_SetToolValue{"SCREEN_DEPTH"     ,pedconfig\screen_Depth}

       ; save Font settings
       dos_SetToolSwitch{"USE_WBFONT"      ,pedconfig\use_wbfont} ;-WZInput("SET_USEWBFONT")}
       If pedconfig\use_wbfont = False
         If newsourcefont_name$ <>""
           dos_SetToolSwitch{"SOURCEFONT"  ,True}       ; actived tooltype maybe it was deactived
           dos_SetToolString{"SOURCEFONT"  ,newsourcefont_name$ + "," + Str$(newsourcefont_size)}
         Else
           dos_SetToolSwitch{"SOURCEFONT"  ,False}      ; deactived Sourcefont Tooltypes no font is set
         EndIf
         If newguifont_name$ <>"" AND pedconfig\use_wbscreen = False ;WZInput("SET_USEWB")=False   ;
           dos_SetToolSwitch{"GUIFONT"     ,True}       ; actived tooltype maybe it was deactived
           dos_SetToolString{"GUIFONT"     ,newguifont_name$ + "," + Str$(newguifont_size)}
         Else
           dos_SetToolSwitch{"GUIFONT"     ,False}      ; deactived GUIfont Tooltypes no font is set or we use the WBscreen
         EndIf
       Else
         dos_SetToolSwitch{"GUIFONT"       ,False}      ; deactived GUIfont Tooltypes we use WBfonts
         dos_SetToolSwitch{"SOURCEFONT"    ,False}      ; deactived Sourcefont Tooltypes we use WBfonts
       EndIf

       ; save other settings
       dos_SetToolSwitch{"ASKBEFOREQUIT"        , pedconfig\ask_before_quit};-WZInput("SET_ASKBEFOREQUIT")}
       dos_SetToolSwitch{"DISABLE_WELCOME"      , pedconfig\no_welcome}     ;-WZInput("SET_WELCOME")}
       dos_SetToolSwitch{"DISABLE_DISPLAYBEEP"  , pedconfig\no_display_beep};-WZInput("SET_NO_DISPLAYBEEP")}
       dos_SetToolSwitch{"DISABLE_LOCALIZATION" , NOT pedconfig\localization}
       dos_SetToolSwitch{"AUTO_FORMAT"          , pedconfig\auto_format}    ;-WZInput("SET_AUTO_FORMAT")}
       dos_SetToolSwitch{"AUTO_INDENT"          , pedconfig\auto_indent}    ;-WZInput("SET_AUTO_INDENT")}     ; add because was not saved before  tomsmart1
       dos_SetToolSwitch{"AUTO_CONSTRUCTS"      , pedconfig\auto_constructs};-WZInput("SET_COMPLETE_CONSTRUCTS")}
       dos_SetToolSwitch{"USE_INTELLISENSE"     , pedconfig\intellisense}   ;-WZInput("SET_INTELLISENSE")}
       dos_SetToolSwitch{"CORRECT_FUNCTIONS"    , pedconfig\correct_functions};-WZInput("SET_CORRECT_FUNCTIONS")}
       dos_SetToolSwitch{"SMART_TOKENIZATION"   , pedconfig\smart_tokenization} ;-WZInput("SET_SMART_TOKENIZATION")}
       dos_SetToolSwitch{"DISABLE_HIGHLIGHTING" , NOT pedconfig\highlighting}
       dos_SetToolSwitch{"BOLD_TOKENS"          , pedconfig\bold_tokens}
       dos_SetToolSwitch{"LINENUMBERS"          , pedconfig\linenumbers}
       dos_SetToolSwitch{"ONLINEHELP"           , pedconfig\onlinehelp}    ;-WZInput("SET_ONLINEHELP")}

       dos_SetToolSwitch{"AUTOLAYOUT"           , pedconfig\autolayout}
       dos_SetToolSwitch{"USE_FILEPATTERN"      , pedconfig\use_filepattern}
       dos_SetToolSwitch{"SOURCE_HISTORY"       , pedconfig\remember_saved};-WZInput("SET_REMEMBER_SAVED")}
       dos_SetToolSwitch{"LOAD_LAST_SOURCE"     , pedconfig\load_last_source};-WZInput("SET_LAST_SOURCE")}
       dos_SetToolSwitch{"SORT_LABELS"          , pedconfig\sort_labels}
       dos_SetToolString{"CURSORSTYLE"          , cursorStyleGetString{pedconfig\cursorStyle}}
       dos_SetToolValue{"SCROLLRATE"            , pedconfig\scroll_rate}
       If OSVersion <> #AmigaOS4                                        ; check if not OS4 than save the value, because on OS4 the System value is used  tomsmart1
         dos_SetToolValue{"MOUSEWHEELSTEP"      , pedconfig\wheelStep}   ; added to make Mousewheelsteprate configuatable and saveable  tomsmart1
       EndIf

       ; save console settings
       dos_SetToolString{"CON_DEVICE" ,pedconfig\console_device}
       dos_SetToolSwitch{"CON_ONWB"   ,pedconfig\console_wb}
       dos_SetToolSwitch{"CON_WAIT"   ,pedconfig\console_wait}

       dos_SetToolValue{"CURSORBLINKRATE",pedconfig\blinkrate}
       dos_SetToolValue{"TABSIZE",pedconfig\tabSize}

       ; save pathes
       dos_SetToolString{"HELPDIR"    ,pedconfig\helpDir}
       dos_SetToolString{"AUTODOCDIR" ,pedconfig\autodocDir}
       dos_SetToolString{"SOURCEDIR"  ,pedconfig\sourceDir}
       dos_SetToolString{"INCLUDEDIR" ,pedconfig\includeDir}

       dos_SetToolString{"UTILLIBS"   ,pedconfig\utillibFile} : dos_SetToolState{"UTILLIBS",pedconfig\useUtilLib}
       dos_SetToolString{"OSLIBS"     ,pedconfig\oslibFile} : dos_SetToolState{"OSLIBS",pedconfig\useOsLib}
       dos_SetToolString{"CSLIBS"     ,pedconfig\cslibFile} : dos_SetToolState{"CSLIBS",pedconfig\useCsLib}

       ;update AND write Icon
       dos_FlushToolTypes{}
   Else
     log_Print{"could not write tooltypes, no disk object.", #log_warning}
   EndIf
Return

.menu_iconify:
  If ExecVersion >= 36
    Gosub close_gui
    *appMenuItem.l = AddAppMenuItemA_(0,0,&ped\defaultPubscreenName,*WBMsgPort,Tags(#TAG_DONE,#TAG_END))
    log_Print{"generated appmenuitem, waiting for uniconify command..."}
    WaitPort_ *WBMsgPort
    *msg.Message = GetMsg_(*WBMsgPort)
    ReplyMsg_ *msg
    log_Print{"... got message, reopening."}
    RemoveAppMenuItem_ *appMenuItem
    MOVEA.l comPtr_CurrentSourceLine,A2
    Gosub open_gui
  EndIf
Return

.write_infofile:
  If dos_Exist{ped\sourceFileComplete + ped\extention_info}
    dos_Delete{ped\sourceFileComplete + ped\extention_info}
  EndIf

  *ni.DiskObject = GetDiskObject_(Null)
  If *ni
    log_Print{"writing info-file for [" + ped\sourceFileComplete + "]"}

    ;-- set the icon type as a projectfile
    *ni\do_Type = #WBPROJECT

    ;-- set the default tooltype for the icon
    idefToolTtype.s = "Blitz3:AmiBlitz3"
    *ni\do_DefaultTool = &idefToolTtype

    ;-- create the Image structure with embedded gfx data and assing the Image to the icongadget structure
    iImg.Image\LeftEdge = 0,0,46,23,2,?iconImageData,3,0,0
    *ni\do_Gadget\NextGadget = 0,0,0,46,24,5,3,1,iImg,0,0,0,0,0,0
    *ni\do_CurrentX = #NO_ICON_POSITION ; 92
    *ni\do_CurrentY = #NO_ICON_POSITION ; 14

    If NOT PutDiskObject_(&ped\sourceFileComplete, *ni)
      log_Print{"Could not write DiskObject, error " + Str$(IoErr_),#log_error}
    EndIf
  Else
    log_Print{"Could not init Diskobject structure",#log_error}
  EndIf

Return

iconImageData:
  Dc.b $FF,$FF
  Dc.b $FF,$FF,$FF,$FC
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $80,$FF,$FF,$FF
  Dc.b $7C,$00,$81,$80
  Dc.b $00,$00,$06,$00
  Dc.b $81,$80,$00,$00
  Dc.b $06,$00,$81,$9A
  Dc.b $DE,$D5,$86,$00
  Dc.b $81,$97,$5B,$7D
  Dc.b $86,$00,$81,$82
  Dc.b $56,$E9,$86,$00
  Dc.b $81,$81,$AD,$5D
  Dc.b $86,$00,$81,$9F
  Dc.b $FF,$FF,$86,$00
  Dc.b $81,$80,$00,$00
  Dc.b $06,$00,$81,$FF
  Dc.b $FF,$FF,$FE,$00
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$7F
  Dc.b $FF,$FF,$F8,$00
  Dc.b $80,$80,$00,$00
  Dc.b $04,$00,$81,$3A
  Dc.b $AA,$AB,$52,$00
  Dc.b $81,$55,$55,$54
  Dc.b $2A,$00,$82,$00
  Dc.b $00,$00,$01,$00
  Dc.b $83,$FF,$FF,$FF
  Dc.b $FF,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$1F
  Dc.b $FF,$FF,$E0,$04
  Dc.b $00,$1A,$DE,$D4
  Dc.b $00,$04,$00,$17
  Dc.b $5B,$7C,$00,$04
  Dc.b $00,$02,$56,$E8
  Dc.b $00,$04,$00,$01
  Dc.b $AD,$5C,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$1F
  Dc.b $FF,$FF,$E0,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$7F
  Dc.b $FF,$FF,$F8,$04
  Dc.b $00,$C5,$55,$54
  Dc.b $AC,$04,$00,$AA
  Dc.b $AA,$AB,$D4,$04
  Dc.b $01,$FF,$FF,$FF
  Dc.b $FE,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$00,$00,$00
  Dc.b $00,$04,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $7F,$FF,$FF,$FF
  Dc.b $FF,$FC
Even

.load_source:
  log_Print{"load_source called"}

  ; -- security requester
  If loadcheckchanged = True
    If ped\ptrCurrentSourceData
      If ped\ptrCurrentSourceData\SourceChanged
        dummy.l = ask{!TRANS{"You have unsaved changes!"},!TRANS{"Continue|Cancel"},!TRANS{"Load File"}}
        If dummy = 0 Then Return
      EndIf
    EndIf
  EndIf

  ; -- select tab, if source is already opened
  *fileEntry.sourceEntry = 0
  If loadchecktab = True
    *fileEntry = PED_CheckSourceAlreadyOpen{ loadsourcefilename }
    If *fileEntry
      GetD0 *fileEntry : Gosub selectTab
      dummy.l = ask{!TRANS{"The file is already open. Do you want to reload it?"},!TRANS{"Yes|Cancel"},!TRANS{"Load File"}}
      If dummy = 0
        Pop If : Pop If : Pop If : Return
      EndIf
      loadnewtab = False
    EndIf
  EndIf

  ; -- check if actual source is unnamed to decide to open new or just open
  If loadnewtab = True
    If ped\ptrCurrentSourceData
      log_Print{"Current sourcename [" + Peek.s(&ped\ptrCurrentSourceData\SourceName) + "]"}
      If Peek.s(&ped\ptrCurrentSourceData\SourceName) <> ""
        log_Print{"opening a new tab"}
        Gosub menu_new
      EndIf
    Else
      log_Print{"no actual file"}
    EndIf
  EndIf

  ; -- load the source file
  PED_SetPointerBusy{}

  PED_ShowMessage{!TRANS{"Loading file"} + " " + loadsourcefilename + "..."}
  If loadsourcefilename.s <> ""
    log_Print{"getting extension for ["+loadsourcefilename.s + "]"}
    ex.s = LCase$(dos_GetExt{loadsourcefilename.s})
    log_Print{"loading source <" + loadsourcefilename.s + ">, <" + ex + ">"}
  Else
    ex.s = "???"
  End If

  If ex.s = "ab3" OR ex.s = "ab2"; OR ex.s = "bb2"
    log_Print{"loading source via compiler ..."}
    GetD0 &loadsourcefilename.s
    !asm
    MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
    !ComData_JSR{comFunc_LoadSource}
    !basic
    log_Print{"loaded " + Str$(ped\ptrCurrentSourceData\TotalLines) + " lines of text"}

    Gosub storeCurrentSourceData

    ;-- restore windows
    Gosub RestoreLabelAndNewtypeWin
    project_changelog$ = ""
 
    Gosub update_versiongadgets
    Gosub analyze_loadedsource
    Gosub calc_SourceWindowDimensions
 
    If ped\ptrCurrentSourceData\CursorPosStore
      log_Print{"goto stored cursor line: " + Str$(ped\ptrCurrentSourceData\CursorPosStore)}
      PED_GotoLine{ped\ptrCurrentSourceData\CursorPosStore-1, #LINE_START}
    EndIf

    log_Print{"deleting and restoring prefs..."}
    Gosub delete_tempprefs
    Gosub save_tempprefs
  Else
    Gosub other_loading_routine
    Gosub storeCurrentSourceData

    Gosub analyze_loadedsource
    Gosub calc_SourceWindowDimensions
  EndIf

  log_Print{"updating sourcewindow..."}
  PED_UpdateStatusArea{#STATUS_REDRAW}
  Gosub reset_labellist
  PED_RedrawSource{}

  PED_SetPointerNormal{}

  PED_ShowMessage{""}
Return

.other_loading_routine:
  log_Print{"other loading routine called..."}
  ped\sourceFileHandle = PED_OpenFile{loadsourcefilename.s,#HUNK_RELOC_16__MODE_OLDFILE,True}
  ped\sourceFileComplete = loadsourcefilename

  log_Print{"... file " + loadsourcefilename + " opened with handle " + Hex$(ped\sourceFileHandle)}

  log_Print{"loading file to cache"}
  If NOT PED_ReadFileCache{}
    log_Print{"could not read file...",#log_error}
    PED_CloseFile{ped\sourceFileHandle}
    Pop If : Return
  EndIf

  If ped\convertAsm = True
    ped\sourceFileComplete = UnLeft$(ped\sourceFileComplete,4) + ".ab3"
  EndIf

  ped\currentDir = dos_PathPart{ped\sourceFileComplete}
  ped\currentFile = dos_FilePart{ped\sourceFileComplete}
  Poke.s ?comStr_SourceName,dos_FilePart{ped\sourceFileComplete}
  Poke.s ?comStr_SourceDir,dos_PathPart{ped\sourceFileComplete}
  ;ped\ptrCurrentSourceData\SourceName = dos_FilePart{ped\sourceFileComplete}
  ;ped\ptrCurrentSourceData\SourceDir = dos_PathPart{ped\sourceFileComplete}
  
  PED_SetCurrentDir{}

  PED_SetPointerBusy{}
  !PED_ResetBlockflag
  Gosub free_actualsource

  tmpLine.s = PED_ReadNextLine{}
  If ped\convertAsm Then tmpLine = PED_ConvertASM{tmpLine}

  *newLine.sourceLine = PED_CreateNewSourceLine{tmpLine}
  ped\ptrCurrentSourceData\FirstSourceLine = *newLine
  ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
  ped\ptrCurrentSourceData\LastSourceLine = *newLine

  Repeat
    *currLine.sourceLine = *newLine

    tmpLine = PED_ReadNextLine{}
    If ped\convertAsm Then tmpLine = PED_ConvertASM{tmpLine}

    tmpLen.w = FLen(tmpLine)
    ;log_Print{Str$(tmpLen) + " [" + tmpLine + "]"}

    If tmpLine <> "NoCOntenTwasDelivered"
      If ped\doTokenize AND (ex <> "bb2" AND ex <> "bb")
        tmpLine = PED_TokenizeText{tmpLine}
      Else
        ;-- replace TAB with space
        tmpLine = Replace$(tmpLine,Chr$(9)," ")
      EndIf
      *newLine = PED_CreateNewSourceLine{tmpLine}

;      log_Print{"[" + Str$(*newLine\strLength)+ "] >> " + Peek.s(*newLine+9)}

      ped\ptrCurrentSourceData\LastSourceLine = *newLine
      *currLine\nextLine = *newLine
      *newLine\previousLine = *currLine
      ped\ptrCurrentSourceData\TotalLines + 1
    Else
      tmpLen = 0
    EndIf
  Until tmpLen = 0 AND (readcache\moreBytes = False)

  PED_CloseFile{ped\sourceFileHandle}
  ped\convertAsm = 0
  ped\ptrCurrentSourceData\TextBufferOffset = 0
  ped\ptrCurrentSourceData\SourceChanged = 0
  ped\ptrCurrentSourceData\Column = 0
  ped\ptrCurrentSourceData\ColumnsOffset = 0
  ped\ptrCurrentSourceData\DisplayLineOffset = 0
  ped\ptrCurrentSourceData\DisplayLine = 0

  ;--
  ;-- read optional xtrafile
  ;--

  Goto skip_loadingxtrafile

  If Peek.l(?comFunc_ReadXtraFile) = 0 Then Goto skip_loadingxtrafile
  tmpStringVar.s = ped\sourceFileComplete + ped\extention_xtra
  *xtra_fh.l = Open_(&tmpStringVar, #HUNK_RELOC_16__MODE_OLDFILE)
  If *xtra_fh = 0 Then Goto skip_loadingxtrafile

  PutReg D0,*xtra_fh : MOVE.l d0,-(a7)
  !asm
  MOVE.l (a7)+,D7
  MOVE.l comFunc_ReadXtraFile,D0 : MOVEA.l D0,A5
  JSR (A5)
  !basic
  log_Print{"opening xtrafile done."}
  Read_ *xtra_fh, ?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin ; xtrabuf,36

;  stackSize.l = Peek.l(?comLong_StackSizeStore)
;  If stackSize<4096 Then stackSize=4096
;  Poke.l ?stacksize,stackSize
;
  ; -- get the data for creating executables
  exefilename$ = ""
  exepathname$ = ""
  tempexename$ = SPACE$(96)

  Seek_ *xtra_fh,$256,#OFFSET_BEGINNING
  Read_ *xtra_fh,&tempexename$,96
  i = 1
  Repeat
    char$ = Mid$(tempexename$,i,1)
    If Asc(char$) <> 0 Then exepathname$ + char$
    i + 1
  Until (i = FLen(tempexename$)) OR (Asc(char$) = 0)

  tempexename$ = SPACE$(96)
  Seek_ *xtra_fh,$316,#OFFSET_BEGINNING
  Read_ *xtra_fh,&tempexename$,96
  i = 1
  Repeat
    char$ = Mid$(tempexename$,i,1)
    If Asc(char$)<>0 Then exefilename$ + char$
    i + 1
  Until (i = FLen(tempexename$)) OR (Asc(char$) = 0)

;  exepathname$ = dos_Trim{exepathname$}
;  exefilename$ = dos_Trim{exefilename$}
;  !cout{exepathname$+"/"+exefilename$} ;$ , dos_GetFileSize2{exepathname$+"/"+exefilename$}}


  ; -- restore windows
  Gosub RestoreLabelAndNewtypeWin
  project_changelog$ = ""
  Gosub update_versiongadgets

  Close_ *xtra_fh

  ; update Sourcewindow
  PED_GotoLine{ped\ptrCurrentSourceData\CursorPosStore+1, #LINE_START}

  ; set default as these options are not stored in old xtra-file
  ped\ptrCurrentSourceData\FuncOptimize = 1
  ped\ptrCurrentSourceData\CreateDebugFile = 0

  Gosub delete_tempprefs
  Gosub save_tempprefs

  skip_loadingxtrafile:
Return


;subroutine to restore Source_Browser(Label) and Definition_Browser(Newtype) window status after load and switch of Sourecode  tomsmart1
.RestoreLabelAndNewtypeWin
  log_Print{"RestoreLabelAndNewtypeWin"}
  LabelListSearchString.s = Peek.s(?comStr_LabelSearchString)        ; set the searchlabel_string
  old_LabelListSearchString.s = LabelListSearchString                ; set also old searchlabel_string to prevent a unessacary reset and jump of the labellist tomsmart1
  LabelList_1VisableItem.l = Peek.l(?comLong_Label1VisableItemStore) ; set/restore the first visable entry of the labellist  tomsmart1
  LabelList_PreSelectItemNumber.l    = -1                            ; set the preselected labellist entry to -1 because we don't save/store it. ; change from 0 to -1 so not the first entry was preselect  tomsmart1

  If WZ_IsOpen{"WIN_LABELS"}
    Use Window WZID("WIN_LABELS")
    WZPrint "STRING_LABEL",LabelListSearchString
    WZPrint "case"        ,Peek.w(?comWord_LabelCase)
    WZPrint "rem"         ,Peek.w(?comWord_LabelRemark)
    WZPrint "all"         ,Peek.w(?comWord_LabelAll)
    WZListRemove list_usedBlitzLibs
    WZPrint "LIBRARY_LIST",0,list_usedBlitzLibs
  EndIf
  If WZ_IsOpen{"WIN_NEWTYPE"}
    PED_UpdateDefinitionBrowser{#DEFBROWSER_RESET}
  End If
Return


.analyze_loadedsource:
  log_Print{"analyze_loadedsource"}

  sourceWindow\Title = "unnamed"
  If pedconfig\smart_tokenization Then ped\doTokenize = True

  ped\currentDir = Peek.s(&ped\ptrCurrentSourceData\SourceDir)
  ped\currentFile = Peek.s(&ped\ptrCurrentSourceData\SourceName)
  ped\sourceFileComplete = dos_AddPart{ped\currentDir,ped\currentFile}

  If ped\currentFile <> ""
    sourceWindow\Title = ped\currentFile + " (" + ped\currentDir + ")"

    ; -- check extension
    fext$ = LCase$(dos_GetExt{ped\currentFile})
    log_Print{"checking file extention of loaded file: " + fext$}
    If fext$ = "bb2" OR fext$ = "ab2" OR fext$ = "ab3" OR fext$ = "bb"
      log_Print{"activating tokenization"}
      ped\doTokenize = True
    Else
      log_Print{"deactivating tokenization"}
      ped\doTokenize = False
    EndIf
  EndIf

  SetWindowTitles_ sourceWindow\win, &sourceWindow\Title, -1

  Gosub update_debuggertoggle
Return


.delete_tempprefs:
  If Peek.l(?comFunc_ReadXtraFile) <> 0
    tmpStringVar = "T:PED_" + Hex$(ped\currentSourceEntry) + ".xtra"
    log_Print{"deleting <" + tmpStringVar + ">"}
    DeleteFile_ &tmpStringVar
  EndIf
Return

.read_tempprefs:
  If Peek.l(?comFunc_ReadXtraFile) <> 0
    tmpStringVar = "T:PED_" + Hex$(ped\currentSourceEntry) + ".xtra"
    tpfhandle.l = Open_(&tmpStringVar, #HUNK_RELOC_16__MODE_OLDFILE)
    If tpfhandle <> 0
      log_Print{"reading xtrafile <" + tmpStringVar + ">"}
      GetD0 Peek.l(?comFunc_ReadXtraFile) : MOVE.l d0,-(a7)
      GetD0 tpfhandle : MOVE.l d0,-(a7)
      !asm
      MOVE.l (a7)+,D7
      MOVEA.l (a7)+,A5
      JSR (A5)
      !basic
      Close_ tpfhandle
    EndIf
  EndIf
Return

.save_tempprefs:
  If Peek.l(?comFunc_WriteXtraFile) <> 0
    tmpStringVar.s = "T:PED_" + Hex$(ped\currentSourceEntry) + ".xtra"
    tpfhandle.l = Open_(&tmpStringVar, #HUNK_RELOC_8__MODE_NEWFILE)
    If tpfhandle <> 0
      log_Print{"writing xtrafile for " + Peek.s(&ped\ptrCurrentSourceData\SourceName) + " <" + tmpStringVar + ">"}
      GetD0 Peek.l(?comFunc_WriteXtraFile) : MOVE.l d0,-(a7)
      GetD0 tpfhandle : MOVE.l d0,-(a7)
      !asm
      MOVE.l (a7)+,D7
      MOVEA.l (a7)+,A5
      JSR (A5)
      !basic
      Close_ tpfhandle
    EndIf
  EndIf
Return

.menu_saveas:
  log_Print{"menu_saveas called."}
  Gosub storeCurrentSourceData

  tmpStringVar.s = PED_RequestFile{Peek.s(&ped\ptrCurrentSourceData\SourceDir),Peek.s(&ped\ptrCurrentSourceData\SourceName),"Name of file to save", "(#?.ab3)"}
  If tmpStringVar <> ""
    ped\check_existsfile = True
    Gosub menu_save
    ped\check_existsfile = False

    PED_UpdateStatusArea{#STATUS_REDRAW}
 EndIf
Return

.menu_save:
  log_Print{"menu_save called on sourcefile: " + ped\currentFile}
  If ped\currentFile = ""
    PED_RequestFile{ped\currentDir,ped\currentFile,"Name to save file as",ped\filePattern}
    Poke.s ?comStr_SourceName,ped\currentFile   ; info for compiler
    Poke.s ?comStr_SourceDir,ped\currentDir
    ;ped\ptrCurrentSourceData\SourceName = ped\currentFile
    ;ped\ptrCurrentSourceData\SourceDir = ped\currentDir
  EndIf
  If ped\currentFile = "" Then Return

  ;--
  ;-- check if file exist and if file should be stored in templates drawer
  If ped\check_existsfile = True
    log_Print{"check if file <" + ped\sourceFileComplete + "> already exists, requester if so  ..."}

    If dos_Exist{ped\sourceFileComplete} ; Lock_(&ped\sourceFileComplete, #ACCESS_WRITE)
      If ask{!TRANS{"File already exists!"},!TRANS{"Overwrite|Cancel"},!TRANS{"Save File As..."}}
        log_Print{"overwrite is ok"}
      Else
        log_Print{"operation cancelled"}
        Return
      EndIf

      directory.s = dos_FilePart{dos_PathPart{ped\sourceFileComplete}}
      If LCase$(directory) = "templates"
        If NOT ask{!TRANS{"Do you really want to save this file into the templates drawer?"},!TRANS{"Ok|Cancel"},!TRANS{"Question"}}
          Return
        EndIf
      EndIf
    Else
      ; file does not exist, that is ok!
    EndIf
  EndIf 

  ;--
  ;-- check file length
  If FLen(ped\currentFile) > 27
    dummy.l = ask{!TRANS{"Warning: Filename is longer than 27 characters.\\n" + ped\currentFile + "\\n\\nThis may cause problems with some filesystems."},!TRANS{"Continue"},!TRANS{"Info"}}
  EndIf
  log_Print{"ped\sourceFileComplete : " + ped\sourceFileComplete + ", check exists: " + Str$(ped\check_existsfile)}

  ;--
  ;-- creating a backup of current source file
  If pedconfig\create_backups
    tmpStringVar.s = ped\sourceFileComplete + ped\extention_bak
    log_Print{"creating a backup of source file " + tmpStringVar}
    dos_Delete{tmpStringVar}
    dos_Rename{ped\sourceFileComplete, tmpStringVar}
  EndIf


  Poke.l ?comPtr_SourceName, &ped\currentFile
  Poke.l ?comPtr_SourceDir, &ped\currentDir
  Poke.s ?comStr_SourceName, ped\currentFile
  Poke.s ?comStr_SourceDir, ped\currentDir
  ;ped\ptrCurrentSourceData\SourceName = ped\currentFile      ; doesnt work with NEWTYPE
  ;ped\ptrCurrentSourceData\SourceDir = ped\currentDir
  
  Gosub storeCurrentSourceData

  log_Print{"updated current source name: " + Peek.s(&ped\ptrCurrentSourceData\SourceName)}

  PED_SetPointerBusy{}
  PED_ShowMessage{!TRANS{"Saving file"} + "..."}

  ped\amiblitzmode = 0
  ex.s = LCase$(dos_GetExt{ped\sourceFileComplete})
  If ex = "bb"  Then ped\amiblitzmode = 1
  If ex = "bb2" Then ped\amiblitzmode = 1
  If ex = "ab2" Then ped\amiblitzmode = 2
  If ex = "ab3" Then ped\amiblitzmode = 3

  log_Print{"writing mode: " + Str$(ped\amiblitzmode)}
  Select ped\amiblitzmode
  Case 1 : Gosub save_source_as_tokenized           
  Case 2 : Gosub save_source_as_text
  Case 3 : Gosub save_source_as_ab3
  Default: Gosub save_source_as_text
  End Select

  If pedconfig\use_source_icon Then Gosub write_infofile


  Gosub analyze_loadedsource

  If pedconfig\remember_saved Then Gosub update_rememberlist
  If pedconfig\load_last_source Then Gosub update_loadsourcefile

  ped\ptrCurrentSourceData\SourceChanged = 0

  PED_ShowMessage{""}
  PED_SetPointerNormal{}
Return


.save_source_as_ab3:
  log_Print{"ped\sourceFileComplete = " + ped\sourceFileComplete + ">"}
  GetD0 &ped\sourceFileComplete : MOVE.l D0,-(a7)
  !asm
  MOVE.l (a7)+,D0
  !ComData_JSR{comFunc_SaveSource}
  !basic
Return


.save_source_as_text:
  log_Print{"ped\sourceFileComplete = " + ped\sourceFileComplete + ">"}
  GetD0 &ped\sourceFileComplete : MOVE.l D0,-(a7)
  !asm
  MOVE.l (a7)+,D0
  !ComData_JSR{comFunc_SaveSource}
  !basic
Return

.save_source_as_tokenized:
  log_Print{"ped\sourceFileComplete = " + ped\sourceFileComplete + ">"}
  GetD0 &ped\sourceFileComplete : MOVE.l D0,-(a7)
  !asm
  MOVE.l (a7)+,D0
  !ComData_JSR{comFunc_SaveSource}
  !basic

  Gosub write_xtrafile
Return

.write_xtrafile:
  tmpStringVar.s = ped\sourceFileComplete + ped\extention_xtra
  *xtra_fh.l = Open_(&tmpStringVar, #HUNK_RELOC_8__MODE_NEWFILE)
  If *xtra_fh
    PutReg D7,*xtra_fh
    !asm
    MOVEA.l comFunc_WriteXtraFile,A5
    JSR (A5)
    !basic
    log_Print{"writing additional stuff..."}
    ped\ptrCurrentSourceData\CursorPosStore = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine
    Poke.s ?comStr_LabelSearchString,LabelListSearchString
    Poke.l ?comLong_Label1VisableItemStore, LabelList_1VisableItem
    ; moved the write of the 4 extra fill/pad/termination bytes to the Compiler xtra save routine because the Compiler xtra load routine needs it!  tomsmart1
    Write_ *xtra_fh,?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin
    log_Print{"close xtrafile"}
    Close_ *xtra_fh
  EndIf
Return

.menu_about:
  PED_SetPointerBusy{}

  txt0.s = !versions + "#" + Peek.s(Peek.l(?comPtr_CompilerVersion))
  txt1.s = ArexxPortName.s
  txt2.s = ped\defaultPubscreenName
  txt3.s = "n/a"
  txt4.s = "n/a"
  txt5.s = "n/a"
  txt6.s = "n/a"
  If pedconfig\useBaseLib Then txt3 = ped\baselibFileDate + " - " + Str$(ped\baselibFileSize) + " bytes"
  If pedconfig\useUtilLib Then txt4 = ped\utillibFileDate + " - " + Str$(ped\utillibFileSize) + " bytes"
  If pedconfig\useOsLib   Then txt5 = ped\oslibFileDate + " - " + Str$(ped\oslibFileSize) + " bytes"
  If pedconfig\useCsLib   Then txt6 = ped\cslibFileDate + " - " + Str$(ped\cslibFileSize) + " bytes"

  ; -- es kommt zu einem Enforcerhit beim beenden von Amiblitz3, wenn dieses Fenster geoeffnet wurde !??
  WZWindow WZID("WIN_WELCOME"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_WELCOME")

  If (txt0 <> "")
    sharp.b = Instr(txt0,"#")
    vlen.b = FLen(txt0)
    pv.s = Left$(txt0,sharp - 1)
    cv.s = Right$(txt0,vlen - sharp)
    WZPrint "PED",&pv
    WZPrint "COMPILER",&cv
  EndIf

  If (txt1 <> "") AND (txt2<>"")
    WZPrint "TEXT1",&txt1
    WZPrint "TEXT2",&txt2
  EndIf

  ltxt1.s = "BaseLibs:" : WZPrint "LACIDLIBS_TEXT",&ltxt1
  WZPrint "ACIDLIBS_TEXT",&txt3
  ltxt2.s = "UtilLibs:" : WZPrint "LDEFLIBS_TEXT",&ltxt2
  WZPrint "DEFLIBS_TEXT",&txt4
  ltxt3.s = "OsLibs:" : WZPrint "LOSLIBS_TEXT",&ltxt3
  WZPrint "OSLIBS_TEXT",&txt5
  ltxt4.s = "CsLibs:" : WZPrint "LCSLIBS_TEXT",&ltxt4
  WZPrint "CSLIBS_TEXT",&txt6


  welcome_Exit.b = False
  Repeat
    welcome_ev.l = WaitEvent

    Select welcome_ev
    Case #IDCMP_VANILLAKEY:
      ;error{"VAN: " + Hexw$(EventCode)}
      If EventCode = #VANILLAKEY_ESC Then welcome_Exit = True

    Case #IDCMP_IDCMPUPDATE
      If WZGadName = "WELCOME_OK" Then welcome_Exit = True

    Case #IDCMP_CLOSEWINDOW
      welcome_Exit = True

    End Select
  Until welcome_Exit

  WZCloseWindow WZID("WIN_WELCOME")
  FlushEvents

  PED_SetPointerNormal{}
  Gosub activatesourcewindow
Return

.menu_find:

  ts.s = PED_Detokenize{ped\ptrCurrentSourceData\CurrentSourceLine}
  actualword$ = PED_GetWordAtPos{ts, ped\ptrCurrentSourceData\Column,False}
  If actualword$ <> ""
    ped\searchString = actualword$
  EndIf
  If WZ_IsOpen{"WIN_SEARCH"} = False
    WZWindow WZID("WIN_SEARCH"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_SEARCH")
    WZ_AddMenuStrip{"WIN_SEARCH",ped\menuStrip}
    Delay_ 2
    WZPrint "FIND_FINDSTRING"   ,&ped\searchString
    WZPrint "FIND_REPLACESTRING",&ped\replaceString
    ;WZPrint "FIND_FINDMODE",-1
    WZ_ActivateGadget{"FIND_FINDSTRING"}

  Else
    Use Window WZID("WIN_SEARCH")
    WindowToFront_ WZWindowAddr
    WZ_ActivateGadget{"FIND_FINDSTRING"}
  EndIf
Return


.menu_findnext:
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *currentLine = *currentLine\nextLine
  direction.b = 1

nextOccurence:
  If *currentLine <> 0
    If direction = 1
      log_Print{"find next for [" + ped\searchString + "]"}
    Else
      log_Print{"find previous for [" + ped\searchString + "]"}
    EndIf

    PED_SetPointerBusy{}

    curLine.l = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset + direction
    Repeat
      tmpX.w = PED_SearchString{ped\searchString, ped\caseSensitive, 1, *currentLine}
      If tmpX = 0
        If direction = 1
          *currentLine = *currentLine\nextLine
        Else
          *currentLine = *currentLine\previousLine
       EndIf
        curLine + direction
      EndIf
    Until (tmpX > 0) OR (curLine > ped\ptrCurrentSourceData\TotalLines) OR (curLine < 0) OR (*currentLine = 0)

    If tmpX > 0
      log_Print{"found [" + ped\searchString + "] in Line " + Str$(curLine) + ", Column " + Str$(tmpX)}
      PED_GotoLine{curLine}
      PED_MoveCursorToX{tmpX - 1}
    EndIf

    PED_SetPointerNormal{}
  EndIf
Return


.menu_findprevious:
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *currentLine = *currentLine\previousLine
  direction.b = -1
Goto nextOccurence

.menu_replace:
  If ped\searchString <> ""
    log_Print{"menu replace called: " + ped\searchString + " >> " + ped\replaceString}
    *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    If PED_ReplaceString{ped\searchString, ped\replaceString, *currentLine}
      log_Print{"replace done."}
      Gosub menu_findnext
      PED_RedrawSource{}
    EndIf
  Else
    log_Print{"no searchstring set."}
  EndIf
Return

.menu_replaceall:
  If ped\searchString <> ""
    log_Print{"menu replaceall called: " + ped\searchString + " >> " + ped\replaceString}
    findmode.b = WZInput("FIND_FINDMODE")
    If findmode
      *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    Else
      *currentLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
    EndIf

    Repeat
      If PED_ReplaceString{ped\searchString, ped\replaceString, *currentLine}
        *currentLine = ped\ptrCurrentSourceData\CurrentSourceLine
      EndIf
      *currentLine = *currentLine\nextLine
    Until *currentLine = 0
  Else
    log_Print{"no searchstring set."}
  EndIf
Return


.menu_quitall:
  log_Print{"close all sources."}

  While ped\firstSourceEntry
    If ped\ptrCurrentSourceData\SourceChanged 
      dummy.l = ask{!TRANS{"You have unsaved changes!"},!TRANS{"Continue|Cancel"},!TRANS{"Quit"}}
      If dummy = 0 Then Pop If: Return
    EndIf

    Gosub free_actualsource
    Gosub close_actualsource
    PED_UpdateStatusArea{#STATUS_REDRAW}
  Wend

  exit_eventloop = True : exit_mainloop = True
Return


.menu_quit:
  If pedMessage\_Code = 1
    log_Print{"new Iconify message was send by intuition"}
    Gosub menu_iconify
    Return
  EndIf

  If ped\ptrCurrentSourceData\SourceChanged
    dummy.l = ask{!TRANS{"You have unsaved changes!"},!TRANS{"Continue|Cancel"},!TRANS{"Quit"}}
    If dummy = 0 Then Pop If : Return
  EndIf

  log_Print{"close current source."}
  PED_ShowMessage{"Closing current source..."}

  Gosub free_actualsource
  Gosub close_actualsource

  If ped\firstSourceEntry = 0
    dummy.l = 1
    If pedconfig\ask_before_quit
      dummy.l = ask{!TRANS{"Closing last source, do you really want to quit?"},!TRANS{"Ok|Cancel"},!TRANS{"Question"}}
    EndIf
    If dummy = 0
      Gosub menu_new
    Else
      log_Print{"telling mainloop to stop, no open file left"}
      exit_eventloop = True : exit_mainloop = True
    EndIf
  EndIf

  PED_UpdateStatusArea{#STATUS_REDRAW}
Return


.menu_blockcomment:
  USEPATH ped\ptrCurrentSourceData

  log_Print{"menu blockcomment called."}

  If \BlockEndY = $ffffFFFF
    log_Print{"no block selected."}
    PED_SetPointerNormal{}
    Pop If: Return
  EndIf

  PED_SetCurrentSourceLine{}
  \CurrentSourceLine = PED_GetBlockStartSourceLine{}
  startY.l = \BlockStartY
  log_Print{"startY: " + Str$(\BlockStartY)}
  log_Print{"endY: "  + Str$(\BlockEndY)}

  Repeat
    If ped\doTokenize
      strline$ = PED_Detokenize{\CurrentSourceLine}
    Else
      strline$ = Peek.s(\CurrentSourceLine + 9)
    EndIf

    strline$ = ";" + strline$
    newline$ = PED_TokenizeText{strline$}
    *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
    PED_ReplaceCurrentSourceLine{*newLine}

    \CurrentSourceLine = \CurrentSourceLine\nextLine
    startY + 1
  Until startY = \BlockEndY + 1
  
  PED_SetCurrentSourceLine{}
  PED_RedrawSource{}
Return


.menu_blockuncomment:
  log_Print{"menu blockuncomment called."}
  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
    log_Print{"no block selected."}
    PED_SetPointerNormal{}
    Pop If: Return
  EndIf

  PED_SetCurrentSourceLine{}
  \CurrentSourceLine = PED_GetBlockStartSourceLine{}
  startY.l = \BlockStartY
  log_Print{"startY: " + Str$(\BlockStartY)}
  log_Print{"endY: "  + Str$(\BlockEndY)}

  Repeat
    If ped\doTokenize
      strline$ = PED_Detokenize{\CurrentSourceLine}
    Else
      strline$ = Peek.s(\CurrentSourceLine + 9)
    EndIf
 
    If FLen(strline$) > 0
      If Left$(strline$,1) = ";"
        strline$ = UnRight$(strline$,1)
        newline$ = PED_TokenizeText{strline$}
        *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
        PED_ReplaceCurrentSourceLine{*newLine}
      EndIf
    EndIf

    \CurrentSourceLine = \CurrentSourceLine\nextLine
    startY + 1
  Until startY = \BlockEndY + 1
  
  PED_SetCurrentSourceLine{}

  PED_RedrawSource{}
Return

.menu_blocktab:
  log_Print{"menu blocktab called."}

  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
    log_Print{"no block selected."}
    PED_SetPointerNormal{}
    Pop If: Return
  EndIf

  PED_SetCurrentSourceLine{}
  \CurrentSourceLine = PED_GetBlockStartSourceLine{}
  log_Print{"startY: " + Str$(\BlockStartY)}
  log_Print{"endY: "  + Str$(\BlockEndY)}

  startY.l = \BlockStartY
  Repeat
    If ped\doTokenize
      strline$ = PED_Detokenize{\CurrentSourceLine}
    Else
      strline$ = Peek.s(\CurrentSourceLine + 9)
    EndIf

    strline$ = SPACE$(pedconfig\tabSize) + strline$
    newline$ = PED_TokenizeText{strline$}
    *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
    PED_ReplaceCurrentSourceLine{*newLine}

    \CurrentSourceLine = \CurrentSourceLine\nextLine
    startY + 1
  Until startY = \BlockEndY + 1

  PED_SetCurrentSourceLine{}
  PED_RedrawSource{}
  log_Print{"menu blocktab done."}
Return


.menu_blockuntab:
  log_Print{"menu blockuntab called."}
  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
    log_Print{"no block selected."}
    PED_SetPointerNormal{}
    Pop If: Return
  EndIf

  PED_SetCurrentSourceLine{}
  \CurrentSourceLine = PED_GetBlockStartSourceLine{}
  log_Print{"startY: " + Str$(\BlockStartY)}
  log_Print{"endY: "  + Str$(\BlockEndY)}

  startY.l = \BlockStartY
  Repeat
    If ped\doTokenize
      strline$ = PED_Detokenize{\CurrentSourceLine}
    Else
      strline$ = Peek.s(\CurrentSourceLine + 9)
    EndIf
 
    If FLen(strline$) > 0
      For runner.w = 1 To pedconfig\tabSize
        If Left$(strline$,1) = " " Then strline$ = UnRight$(strline$,1)
      Next runner
      newline$ = PED_TokenizeText{strline$}
      *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
      PED_ReplaceCurrentSourceLine{*newLine}
    EndIf

    \CurrentSourceLine = \CurrentSourceLine\nextLine
    startY + 1
  Until startY = \BlockEndY + 1

  PED_SetCurrentSourceLine{}

  PED_RedrawSource{}
  log_Print{"menu blockuntab done."}
Return

.close_actualsource:
  Gosub delete_tempprefs

  *sourceEntry.sourceEntry = ped\currentSourceEntry
  *nextEntry.sourceEntry = *sourceEntry\nextEntry
  *prevEntry.sourceEntry = *sourceEntry\previousEntry

  If *prevEntry <> 0
    If *nextEntry <> 0
      ped\currentSourceEntry = *nextEntry
      *prevEntry\nextEntry = *nextEntry
      *nextEntry\previousEntry = *prevEntry
    Else
      ped\currentSourceEntry = *prevEntry
      ped\firstLoadedEntry = *prevEntry
      *prevEntry\nextEntry = 0
    EndIf
  Else
    If *nextEntry <> 0
      ped\firstSourceEntry = *nextEntry
      ped\currentSourceEntry = *nextEntry
      *nextEntry\previousEntry = 0
    Else
      ped\firstSourceEntry = 0
      ped\firstLoadedEntry = 0
      ped\currentSourceEntry = 0
    EndIf
  EndIf
  PED_FreeMem{*sourceEntry}

  If ped\currentSourceEntry
    Gosub getCurrentSourceData
    Gosub read_tempprefs
    Gosub reset_sourcewindow
  EndIf
Return


.selectblockdown:
  If ped\ptrCurrentSourceData\BlockEndY = $FFFFffff Then PED_SetBlockStart{}
  PED_MoveCursorDown{}
  PED_SetBlockEnd{}
Return

.selectblockup:
  If ped\ptrCurrentSourceData\BlockEndY = $FFFFffff Then PED_SetBlockStart{}
  PED_MoveCursorUp{}
  PED_SetBlockEnd{}
Return

.selectblockright:
  If ped\ptrCurrentSourceData\BlockEndY = $FFFFffff Then PED_SetBlockStart{}
  PED_MoveCursorRight{}
  PED_SetBlockEnd{}
Return

.selectblockleft:
  If ped\ptrCurrentSourceData\BlockEndY = $FFFFffff Then PED_SetBlockStart{}
  PED_MoveCursorLeft{}
  PED_SetBlockEnd{}
Return

.movelinedown: ; move the current source line down, not just the cursor
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *nextLine.sourceLine = *currentLine\nextLine
  
  actualLine.l = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
  If (actualLine < ped\ptrCurrentSourceData\TotalLines) AND (*nextLine <> 0) ; if no nextline, we cannot move down
    If PED_CutSourceLine{*currentLine}
      If PED_AppendSourceLine{*nextLine, *currentLine}
        f1.s = PED_Detokenize{ped\ptrCurrentSourceData\FirstSourceLine}
        log_Print{"f1: " + Left$(f1,20)}

        PED_CursorOff{}
        ;-- print the line that has to be moved up
        ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine\previousLine
        PED_PrintCurrentSourceLine{True}

        ;-- print the current line one line down
        ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine
        If PED_IncreaseDisplayLine{} = 1 ;-- check if text is has to be scrolled      
          PED_ScrollVertical{#SCROLL_UP}
        EndIf
        PED_PrintCurrentSourceLine{True}
        PED_CursorOn{}
        PED_UpdateStatusArea{#STATUS_SCROLLERS}
      Else
        log_Print{"*** append not successfull ***"}      
      EndIf
    Else
      log_Print{"*** cut not successfull ***"}
    EndIf
  Else
    log_Print{"no alt-cursor down available."}
  EndIf
Return

.movelineup: ; move the current source line up, not just the cursor
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *prevLine.sourceLine = *currentLine\previousLine

  actualLine.l = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
  If (actualLine > 0) AND (*prevLine <> 0) ; if no previousline, we cannot move up
    If PED_CutSourceLine{*currentLine}
      If PED_AppendSourceLine{*prevLine\previousLine, *currentLine}
        PED_CursorOff{}
        ;-- print the line that has to be moved down
        ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine\nextLine
        PED_PrintCurrentSourceLine{True}

        ;-- print the current line one line up
        ped\ptrCurrentSourceData\CurrentSourceLine = *currentLine
        If PED_DecreaseDisplayLine{} = 1 ;-- check if text is has to be scrolled      
          PED_ScrollVertical{#SCROLL_DOWN}
        EndIf
        PED_PrintCurrentSourceLine{True}
        PED_CursorOn{}
        PED_UpdateStatusArea{#STATUS_SCROLLERS}  
      Else
        log_Print{"*** append not successfull ***"}
      EndIf
    Else
      log_Print{"*** cut not successfull ***"}
    EndIf
  Else
    log_Print{"no alt-cursor up available."}
  EndIf
Return

.menu_markindent:
  log_Print{"menu markindent called."}
  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  If Peek.b(*currentLine + 9) <> 0
    actualLine.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine

    ; -- get current indent position
    currentXPos.w = 0
    While Peek.b(*currentLine + 9 + currentXPos) = $20
      currentXPos + 1
    Wend

    ; -- search for block start
    indentBegin.l = actualLine
    While indentBegin > 0
      upperXPos.w = 0
      *currentLine = *currentLine\previousLine
      While Peek.b(*currentLine + 9 + upperXPos) = $20
        upperXPos + 1
      Wend
      If Peek.b(*currentLine + 9 + upperXPos) <> 0
        If upperXPos < currentXPos Then Goto exit_upperindent
      EndIf
      indentBegin - 1
    Wend
    exit_upperindent:

    ; -- search for end of block
    *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    indentEnd.l = actualLine
    *currentLine = *currentLine\nextLine
    While *currentLine <> 0
      lowerXPos.w = 0
      While Peek.b(*currentLine + 9 + lowerXPos) = $20
        lowerXPos + 1
      Wend
      If Peek.b(*currentLine + 9 + lowerXPos) <> 0
        If lowerXPos < currentXPos Then Goto exit_lowerindent
      EndIf
      indentEnd + 1

      *currentLine = *currentLine\nextLine
    Wend
    exit_lowerindent:

    ;-- draw the blockmark
    ped\ptrCurrentSourceData\BlockStartY = indentBegin
    ped\ptrCurrentSourceData\BlockStartX = 0
    ped\ptrCurrentSourceData\BlockEndY   = indentEnd
    ped\ptrCurrentSourceData\BlockEndX   = #MAX_Columns - 1
    PED_RedrawSource{}
  EndIf
  PED_SetPointerNormal{}
Return


.menu_insertline:  ; insertStr may come from menu_undeleteline...
  ;If insertStr.s = "" Then insertStr = "leere Zeile"
  *newLine.sourceLine = PED_CreateNewSourceLine{insertStr.s}
  If *newLine <> 0
    ;-- if autoindent, align cursor for line
    If NOT pedconfig\auto_indent
      log_Print{"auto-indent is OFF"}
      \Column = 0
    Else
      \Column = -1
      Repeat
        \Column + 1
      Until Peek.b(\CurrentSourceLine + 9 + \Column) <> $20
      log_Print{"indent after return: " + Str$(\Column)}
    EndIf

    PED_UpdateBlockPosY{ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine}
    
    If PED_InsertSourceLine{*newLine}
      PED_CursorOff{}        
      PED_ScrollVertical{#SCROLL_DOWN, ped\ptrCurrentSourceData\DisplayLine}
      PED_PrintCurrentSourceLine{False}
      ;PED_UpdateLinenumbers{}
      PED_UpdateStatusArea{#STATUS_SCROLLERS}
      PED_CursorOn{}
    Else
      error{"Couldn't insert sourceline!"}
    EndIf
    insertStr = ""
  Else
    Pop If
    Goto memAlert_CloseSource
  EndIf
Return


.menu_undeleteline:
  log_Print{"menu undeleteline called"}
  insertStr.s = Peek.s(ped\ptrLineUndeleteStore)
  If FLen(insertStr) > 0
    log_Print{"undeleting line: " + insertStr}
    Gosub menu_insertline
  Else
    log_Print{"no data to undelete."}
  EndIf
Return


.menu_deleteline:
  log_Print{"menu deleteline called"}

  ;-- update the blockmark if set
  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
    If ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine > ped\ptrCurrentSourceData\BlockStartY
      If ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine < ped\ptrCurrentSourceData\BlockEndY
        ped\ptrCurrentSourceData\BlockEndY - 1
        If ped\ptrCurrentSourceData\BlockEndY < ped\ptrCurrentSourceData\BlockStartY
          ped\ptrCurrentSourceData\BlockEndY = 0
        EndIf
      EndIf
    Else
      ped\ptrCurrentSourceData\BlockStartY - 1
      ped\ptrCurrentSourceData\BlockEndY - 1
    EndIf
  EndIf

  *currentLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  *nextLine.sourceLine = *currentLine\nextLine
  *prevLine.sourceLine = *currentLine\previousLine
  If *nextLine <> 0
    If PED_CutSourceLine{*currentLine}
      PED_StoreSourceLine{*currentLine}
      PED_DeleteSourceLine{*currentLine}
      ped\ptrCurrentSourceData\CurrentSourceLine = *nextLine
      PED_ScrollVertical{#SCROLL_UP, ped\ptrCurrentSourceData\DisplayLine}
      PED_UpdateStatusArea{#STATUS_SCROLLERS}
      ;PED_UpdateLinenumbers{#FULL}
    EndIf
  Else
    If *prevLine <> 0
      If PED_CutSourceLine{*currentLine}
        PED_StoreSourceLine{*currentLine}
        PED_DeleteSourceLine{*currentLine}
        ped\ptrCurrentSourceData\CurrentSourceLine = *prevLine
        ped\ptrCurrentSourceData\LastSourceLine = *prevLine
        PED_ScrollVertical{#SCROLL_UP, ped\ptrCurrentSourceData\DisplayLine}
        PED_UpdateStatusArea{#STATUS_SCROLLERS}
        ;PED_UpdateLinenumbers{#FULL}
      EndIf
    Else
      PED_StoreSourceLine{*currentLine}
      PED_DeleteSourceLine{*currentLine}
      *newLine.sourceLine = PED_CreateNewSourceLine{""}
      ped\ptrCurrentSourceData\FirstSourceLine = *newLine
      ped\ptrCurrentSourceData\LastSourceLine = *newLine
      ped\ptrCurrentSourceData\CurrentSourceLine = *newLine
      Gosub clear_sourcewindow
    EndIf
  EndIf
  log_Print{"menu deleteline finished"}
Return

.menu_joinlines:
USEPATH ped\ptrCurrentSourceData
  log_Print{"menu joinlines called."}

  *currLine.sourceLine = \CurrentSourceLine
  If *currLine\nextLine = 0
    log_Print{"no next line to join."}

    PED_SetPointerNormal{}
    Pop If: Return
  Else
    *nextLine.sourceLine = *currLine\nextLine
  EndIf

  ; -- adjust blockmark
  ; TODO: currently not necessary, as the blockmark is resetted after each key event

  ; -- get both lines and tokenize the joined one
  strline1$ = StripTrail$(PED_Detokenize{*currLine},@" ")
  strline2$ = StripTrail$(PED_Detokenize{*nextLine},@" ")
  strline$ = PED_TokenizeText{strline1$ + strline2$}
  *newLine.sourceLine = PED_CreateNewSourceLine{strline$}
  PED_ReplaceCurrentSourceLine{*newLine}
  If PED_CutSourceLine{*nextLine}
    PED_DeleteSourceLine{*nextLine}
  Else
    log_Print{"could not cut the current line."}
  EndIf

  ;-- update the source
  PED_CursorOff{}
  PED_ScrollVertical{#SCROLL_UP, \DisplayLine}  
  PED_PrintCurrentSourceLine{True}
  PED_UpdateStatusArea{#STATUS_SCROLLERS}
  PED_CursorOn{}
  log_Print{"menu joinlines finished."}
Return

.menu_top:
  PED_HistoryAddEntry{}
  PED_GotoLine{0, #LINE_START}
Return

.menu_bottom:
  PED_HistoryAddEntry{}
  PED_GotoLine{ped\ptrCurrentSourceData\TotalLines, #LINE_START}
Return


; -- handle compilermenu
; menuids
; $5A: Leerzeile im Menu
; $50: Compile & Run
; $5b: Save & Create Exec
; $5c: Save & Compile & Run
; $5d: Debug / Runerrors On 10*slower Code
; $5e: Create Executable absolut Smallest

; $57: calculator
; $58: reload all libs
; $59: open sourcebrowser

.call_compilermenuitem:              ; (Menuitem in D6)
  compile_state.l = 0
  log_Print{"we call the compiler with menu " + Hex$(_menuitem.l)}

  Select _menuitem.l
  Case $5A                             ; empty menuitem number
    log_Print{"*** unknown compilermenu entry called.",#log_warning}
    Return

  Case #MENU_CALCULATOR
    PED_SetPointerBusy{}
 
    Gosub save_tempprefs                 ; save data to prevent crashes if the calculation routine is called an it coms back to Ped
    Gosub open_calculator
    Gosub read_tempprefs                 ; restore data to prevent crashes if the calculation routine is called an it comes back to Ped

    PED_SetPointerNormal{}

    Pop Select : Return

  Case #MENU_DEFINITIONBROWSER
    Gosub open_definitionbrowser

  Case #MENU_SETCLIARGS
    PED_SetPointerBusy{}
    Gosub open_cliarguments
    PED_SetPointerNormal{}

  Case #MENU_SOURCEBROWSER
    Gosub open_sourcebrowser

  Case #MENU_COMPILERSETTINGS
    PED_SetPointerBusy{}
    Gosub menu_compilersettings
    If WZ_IsOpen{"WIN_NEWTYPE"}
       Use Window WZID("WIN_NEWTYPE")
       PED_UpdateDefinitionBrowser{#DEFBROWSER_RESET}
    End If
    Gosub update_debuggertoggle
    Gosub save_tempprefs
    PED_SetPointerNormal{}

  Case #MENU_COMPILERUN
    ;TEDSetLabelList {?comPtr_LabelList}
    ;TEDSetLabelCount{ped\ptrCurrentSourceData\LabelCounter}
    Gosub call_compiler

  Case #MENU_RUN
    Gosub call_compiler

  Case #MENU_SAVECREATEEXE
    log_Print{"savecreateexe"}
    Gosub menu_save
    Gosub call_compiler

  Case #MENU_SAVECOMPILERUN
    Gosub menu_save
    _menuitem = #MENU_COMPILERUN
    Gosub call_compiler

  Case #MENU_RELOAD_USERLIBS
    log_Print{"reload libs"}

    ; clear intructioncache as the tokennumbers may change
    PED_ClearTokencache{}

    Gosub call_compiler

    Gosub read_tempprefs

  Default
    Gosub call_compiler
  End Select

  log_Print{"doing stuff after compiler has finished."}

  PED_UpdateStatusArea{}

  ;-- handle compile error??
  log_Print{"checking compiler return state " + Str$(compile_state) }  
  Select compile_state.l
  Case -1
    ; everything went ok, nothing to do
  Case -2
    ; what is this for a state ??
    PED_RedrawSource{}
  Default ; we have got an error line, jump to that pos
    log_Print{"Found an error in line #" + Str$(compile_state)}
    PED_GotoLine{compile_state, #LINE_END}
  End Select

  log_Print{"all done with compiler, returning to IDE..."}
Return

.call_compiler:
  If Peek.l(?comFunc_CallMenuEntry) = 0
    error{"Compiler not available!"}
    Return
  EndIf

  ;-- check if we need a file requester for exefile & exepath
  If (_menuitem = #MENU_CREATEEXE) OR (_menuitem = #MENU_SAVECREATEEXE)
    If (_menuitem = #MENU_SAVECREATEEXE) AND Peek.s(?comStr_ExePath) <> "" AND Peek.s(?comStr_ExeFile) <> ""
      Goto skip_aslrequest
    EndIf

    aslfr_SetRequesterTitle{2,"Name of Executable to Create:","Create","Cancel"}
    aslfr_SetPath {2,Peek.s(?comStr_ExePath),Peek.s(?comStr_ExeFile),""}
    If NOT aslfr_Request{2,False,True,False, sourceWindow\pedScreen}
      Return
    EndIf
    Poke.s ?comStr_ExePath, aslfr_GetPath{2}
    Poke.s ?comStr_ExeFile, aslfr_GetFile{2}
    skip_aslrequest:
  EndIf

  If dos_Exist{Peek.s(?comStr_ExePath)} = False 
    error{"The path " + Peek.s(?comStr_ExePath) + " does not exist."}
    Return
  EndIf

  PED_SetCurrentDir{}

  WZ_LockAllOpenWindows{}

  CompileMenuCallID.l = _menuitem - #MENU_COMPILERUN
  log_Print{"*** calling compiler with function id [" + Hex$(CompileMenuCallID) + "]"}
  PED_ShowMessage{"Compiling..."}

  Gosub Open_CompileStatus_Window                         ; open Compile status window if we need it

  ;-- set infos for Compiler to run functions
  GetD0 CompileMenuCallID : MOVE.l D0,-(a7)
  !asm
  MOVE.l (a7)+,D6
  MOVEA.l comPtr_FirstSourceLine,A5
  MOVE.l comLong_TotalLines,D7
  MOVE.l comFunc_CallMenuEntry,a0 : JSR (A0)               ; call compilerfunction for the menuentry
  MOVE.l D0,-(a7)
  !basic
  MOVE.l (a7)+,D0
  compile_state.l = PutD0                                  ; get the return code of compiler

  Delay_ 10                                                ; without waiting we get s serious crash, dont know why!!

  Gosub update_debuggertoggle                              ; update the state to the commenu "Create Debug Code"
  Gosub update_versiongadgets

  Gosub Close_CompileStatus_Window                         ; close compile status window if it is open
  previoussearch_instruction$ = "|"

  PED_ShowMessage{""}
  WZ_UnlockAllOpenWindows{}

  log_Print{"*** compiler finished with return code [" + Hex$(compile_state) + "]"}
Return

.event_menu:
  log_Print{"selected menuitem: " + Hex$(_menuitem.l)}

  ;-- handle compiler menues
  If (_menuitem >= #MENU_COMPILERUN) AND (_menuitem < #MENU_NEW)    ;$64 - $50
    Gosub call_compilermenuitem
    Return
  EndIf

  ;-- handle custom menues
  If (_menuitem >= #MENU_CUSTOMEDIT-1) AND (_menuitem < $F00)       ; 259 -$f00
    Gosub call_pluginmenuentry             ;plugin menuitem
    Return
  EndIf

  ;-- handle dynamic menuentries, ( last filenames )
  If _menuitem >= #MENU_TEMPLATE AND _menuitem<#MENU_TEMPLATE+#MAX_MENUTEMPLATES
    Gosub load_template
    PED_UpdateStatusArea{#STATUS_SCROLLERS}
    Return
  EndIf


  ;-- handle other menues
  Select _menuitem
  Case #MENU_INSERTFILENAME
    aslfr_SetRequesterTitle{0,!TRANS{"Select a filename to insert in source"},"",""}
    aslfr_SetPath{0,pedconfig\mainDir,"",""}
    If aslfr_Request{0,False,False,False,sourceWindow\pedScreen}
      tmpStringVar = aslfr_GetNextFile{} : PED_InsertStringToTextBuffer{tmpStringVar}
    EndIf

  Case #MENU_OPENFILEUNDERCURSOR
    strline$ = PED_Detokenize{ped\ptrCurrentSourceData\CurrentSourceLine}
    _file$ = PED_GetWordAtPos{strline$, ped\ptrCurrentSourceData\Column,False,False}
    log_Print{"open file under cursor [" + _file$+ "]"}
    If _file$ <> ""
      tmpStringVar = _file$
      If NOT dos_Exist{tmpStringVar}
        tmpStringVar = dos_AddPart{pedconfig\includeDir,_file$}
        log_Print{"not found, trying " + tmpStringVar}
      EndIf
      If NOT dos_Exist{tmpStringVar}
        tmpStringVar = dos_AddPart{Peek.s(&ped\ptrCurrentSourceData\SourceDir),_file$}
        log_Print{"not found, trying " + tmpStringVar}
      EndIf
      If dos_Exist{tmpStringVar}
        log_Print{"open file under cursor: " + tmpStringVar}
        !PED_LoadSource{tmpStringVar,False,True,True}  
      Else
        log_Print{"could not find file: " + tmpStringVar}
      EndIf
    EndIf

  Case #MENU_DELETETOEOL
    log_Print{"menuentry DELETE TO EOL"}
    ped\ptrCurrentSourceData\KeyBeforeReturn = last_vankey       ; save keycode
    CursorXTarget.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset
    ; delete all until end of line (replace with spaces)
    lineaddr.l = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset
    For cupos.w = CursorXTarget To #MAX_Columns-1
      Poke.b lineaddr + cupos, $20
    Next cupos
    Gosub updateSourceLine

  Default
      _menutable.l = ?menutable
      menu_found.b = False : menu_ptr.l = 0 : menu_number.w = 0
      menu_refresh.l = 0
      While (NOT menu_found) AND Peek.l(_menutable) <> 0
        menu_number = Peek.l(_menutable)
        If menu_number = _menuitem
          menu_found = True
          menu_refresh = Peek.l(_menutable + 4)
          menu_ptr = Peek.l(_menutable + 8)
        Else
          _menutable + 12
        EndIf
      Wend
      If menu_ptr
        log_Print{"menu call execute at " + Hex$(menu_ptr) + "..."}
        GetD0 _menuitem : MOVE.l d0,D6 : Call menu_ptr
        log_Print{"menu call ended."}
        If menu_refresh
          PED_UpdateStatusArea{#STATUS_SCROLLERS}
        EndIf
      EndIf
  End Select
Return


.reset_sourcewindow:
  log_Print{"*** reset_sourcewindow called."}

  Gosub calc_SourceWindowDimensions
  Gosub clear_sourcewindow
  Gosub reset_labellist

  Gosub analyze_loadedsource
  PED_SetCurrentDir{}

  log_Print{"redraw of sourcewindow"}
  PED_RedrawSource{}
  PED_UpdateStatusArea{#STATUS_REDRAW}
Return

.load_template:
  mcounter.l = _menuitem-#MENU_TEMPLATE
  log_Print{"called menu new template with subitem: " + Str$(mcounter)}

  ResetList templates()
  For n.l = 0 To mcounter - 1
    NextItem templates()
  Next
  If NextItem(templates())
    log_Print{"opening new source tab."}

    loadsourcefilename.s = templates()\filename
    log_Print{"selected template: " + loadsourcefilename}
    !PED_LoadSource{templates()\filename,False,False,True}

  Else
    log_Print{"unknown template, opening a new file instead."}
    tmpStringVar = !TRANS{"unnamed"}
    Gosub menu_loadAsNew
  EndIf
Return



.menu_new:
  log_Print{"*** menu new called."}
  ;log_Print{"value of ped\firstLoadedEntry: " + Hex$(ped\firstLoadedEntry)}

  ; -- alloc memory for a new fileentry
  MOVE.l #comDef_XtraEnd-comLong_XtraBegin,d0 : tmpMemSize.l = PutD0
  *newEntry.sourceEntry = PED_AllocMem{tmpMemSize}
  If *newEntry = 0
    Gosub display_memoryalert
    Return
  EndIf
  log_Print{"new fileentry allocated at: " + Hex$(*newEntry) }

  ; -- adding the new source into the source list
  If ped\firstLoadedEntry = 0
    log_Print{"no current fileentry available, creating first one ..."}
    ped\firstLoadedEntry = *newEntry
    ped\firstSourceEntry = *newEntry
    ped\currentSourceEntry = *newEntry
    *newEntry\previousEntry = 0
    *newEntry\nextEntry = 0
    ;log_Print{"currentEntry at " + Hex$(ped\currentSourceEntry)}
    Gosub getCurrentSourceData
    Gosub clear_sourcebuffer
  Else
    log_Print{"we already have an opened source file, so adding a new tab..."}
    ; -- save changes to current source line
    Gosub storeline
    Gosub storeCurrentSourceData

    log_Print{"currentEntry at " + Hex$(ped\currentSourceEntry)}
    *sourceEntry.sourceEntry = ped\currentSourceEntry
    *nextEntry.sourceEntry = *sourceEntry\nextEntry
    If *nextEntry <> 0                         ; insert new source between current source an next source entry ?
      *sourceEntry\nextEntry = *newEntry       ; nextfile -> newentry
      *newEntry\previousEntry = *sourceEntry   ; newentry\prev -> currentEntry
      *newEntry\nextEntry = *nextEntry         ; newentry\next -> nextfile
      *nextEntry\previousEntry = *newEntry     ; nextfile\prev -> newentry
    Else
      ped\firstLoadedEntry = *newEntry
      *sourceEntry\nextEntry = *newEntry       ; nextfile -> newentry
      *newEntry\previousEntry = *sourceEntry
      *newEntry\nextEntry = 0
    EndIf
    ped\currentSourceEntry = *newEntry
    Gosub clear_sourcebuffer
    Gosub reset_sourcewindow
  EndIf
Return

.menu_loadAsNew:
  log_Print{"*** menu opennew called."}
  Gosub menu_new
  Gosub menu_load
  Gosub storeCurrentSourceData
  PED_UpdateStatusArea{#STATUS_SCROLLERS}
Return

.menu_load:
  log_Print{"*** menu load called."}

  ;-- we want to check an unsaved state *before* opening the file requester, so the code for checking is here aswell as in load_source
  If ped\ptrCurrentSourceData\SourceChanged
    dummy.l = ask{!TRANS{"You have unsaved changes!"},!TRANS{"Continue|Cancel"},!TRANS{"Load File"}}
    If dummy = 0 Then Pop If : Pop If : Return
  EndIf

  aslfr_SetRequesterTitle {1,!TRANS{"Load source file"},!TRANS{"Load"},!TRANS{"Cancel"}}
  If pedconfig\use_filepattern
    aslfr_SetPath  {1,ped\currentDir,ped\currentFile,ped\filePattern,False}
  Else
    aslfr_SetPath  {1,ped\currentDir,ped\currentFile,"",False}
  EndIf
  ASL_x = 14
  ASL_y = 36
  If aslfr_Request {1,False,False,False,-1,False}
    loadsourcefilename.s = aslfr_GetNextFile{}
    If loadsourcefilename.s <> ""
      !PED_LoadSource{loadsourcefilename,False,True,True}
    EndIf
  EndIf
  log_Print{"menu load finished."}
Return

.storeCurrentSourceData:                      ;copy view data
  ; this function is called after a succesfull load of a sourcecode and before and after a switch of the sourcecode
  Poke.l ?comLong_Label1VisableItemStore, LabelList_1VisableItem    ; to update both for a unified LabelList restore routine that work by load and switch of a Sourcecode  tomsmart1

  GetReg A0, ped\currentSourceEntry : ADDQ.l #8,A0    ; skip listentries (next/previous sourceentry)
  LEA comLong_XtraBegin + 8,A1                    ; skip "tedsdoc!"
  MOVE.l #comDef_XtraEnd-comLong_XtraBegin - 8, D0 : SUBQ.w #1,D0
 'copyloop
    MOVE.b (A1)+,(A0)+
  DBF D0,'copyloop
Return


.getCurrentSourceData:
  ; zurueckholen der xtra-settings nach sourcewechsel
  GetReg A0,ped\currentSourceEntry : ADDQ.l #8,A0    ; skip listentries (next/previous sourceentry)
  LEA comLong_XtraBegin + 8,A1                   ; skip "tedsdoc!"
  MOVE.l #comDef_XtraEnd-comLong_XtraBegin - 8, D0 : SUBQ.w #1,D0
 'copyloop:
    MOVE.b (A0)+,(A1)+
  DBF D0,'copyloop

  ped\ptrCurrentSourceData = ?comLong_XtraBegin
  ;-- restore some windows
  Gosub RestoreLabelAndNewtypeWin
Return

.selectTab:  ; D0: current entry in opened file table
  selectedEntry.l = PutD0

  If ped\currentSourceEntry <> selectedEntry
    log_Print{"switching to requested tab."}

    Gosub storeCurrentSourceData
    Gosub save_tempprefs
    ped\currentSourceEntry = selectedEntry : Gosub getCurrentSourceData
    Gosub read_tempprefs

    Gosub reset_sourcewindow
    PED_UpdateStatusArea{#STATUS_REDRAW}
  Else
    log_Print{"source is already at current tab."}
  EndIf
Return


.menu_previousfile:
  Gosub storeCurrentSourceData
  Gosub save_tempprefs

  If ped\currentSourceEntry\previousEntry
    ped\currentSourceEntry = ped\currentSourceEntry\previousEntry
  Else
    If ped\firstLoadedEntry = ped\currentSourceEntry
      Pop If : Pop If : Return
    Else
      ped\currentSourceEntry = ped\firstLoadedEntry
    EndIf
  EndIf
  Gosub getCurrentSourceData
  Gosub reset_sourcewindow
  Gosub read_tempprefs

  PED_UpdateStatusArea{#STATUS_REDRAW}
Return


.menu_nextfile:
  Gosub storeCurrentSourceData
  Gosub save_tempprefs

  If ped\currentSourceEntry\nextEntry
    ped\currentSourceEntry = ped\currentSourceEntry\nextEntry
  Else
    If ped\firstSourceEntry = ped\currentSourceEntry
      Pop If : Pop If : Returnsdf
    Else
        ped\currentSourceEntry = ped\firstSourceEntry
    EndIf
  EndIf
  Gosub getCurrentSourceData
  Gosub reset_sourcewindow
  Gosub read_tempprefs

  PED_UpdateStatusArea{#STATUS_REDRAW}
Return

.menu_copy:
  log_Print{"menu copy called."}
  PED_CopyBlock{}

  ; -- remove block selection
  PED_DrawBlockmark{}
  ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
Return


.menu_cut:
  log_Print{"menu cut called."}
  PED_CutBlock{}
Return

.menu_paste:
  log_Print{"menu paste called."}
  PED_KillBlock{}
  PED_PasteBlock{""}
Return

.menu_kill:
  log_Print{"menu kill called."}
  PED_KillBlock{}
Return

.menu_saveblockas:
  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
    log_Print{"no block marked."}
  EndIf  

  blockfn$ = PED_RequestFile{"","","Name to save block as","(#?.info)", False}
  If blockfn$ <> ""
    *write_fh.l = Open_(&blockfn$, #HUNK_RELOC_8__MODE_NEWFILE)
    If *write_fh <> 0
      PED_SetPointerBusy{}
      *tempLine.sourceLine = PED_GetFirstBlockLine{}
      strline$ = PED_Detokenize{*tempLine}
      strlng.w = FLen(strline$)

      If PED_GetCountOfMarkedLines{} < 2
        If strlng >= ped\ptrCurrentSourceData\BlockEndX
          strlng = ped\ptrCurrentSourceData\BlockEndX - ped\ptrCurrentSourceData\BlockStartX + 2
        EndIf
        strlng = strlng - 1
        strline$ = Mid$(strline$, ped\ptrCurrentSourceData\BlockStartX, strlng) ;+ Chr$(10)
        ;log_Print{">>" + strline$}
        Write_ *write_fh,&strline$,FLen(strline$)
      Else
        If strlng <= ped\ptrCurrentSourceData\BlockStartX
          ;-- end of String...
          strline$ = Chr$(10)
          WriteChunkBytes_ *write_fh, &strline$,1
        EndIf

          ;-- copy first line
          strlng = strlng - ped\ptrCurrentSourceData\BlockStartX
          strline$ = Mid$(strline$, ped\ptrCurrentSourceData\BlockStartX, strlng) + Chr$(10)
          Write_ *write_fh, &strline$, Len(strline$)

          ;-- copy most lines
          For si.w = 1 To PED_GetCountOfMarkedLines{} - 2
            If *tempLine\nextLine
              *tempLine = *tempLine\nextLine
              strline$ = PED_Detokenize{*tempLine}
              strlng.w = FLen(strline$)
              If ped\verticalCopyMode <> 0 AND (strlng > ped\ptrCurrentSourceData\BlockStartX)
                strline$ = Mid$(strline$, ped\ptrCurrentSourceData\BlockStartX, strlng - ped\ptrCurrentSourceData\BlockStartX) + Chr$(10)
              Else
                strline$ = Left$(strline$, strlng) + Chr$(10)
              EndIf
              Write_ *write_fh,&strline$,FLen(strline$)
            Else
              error{"Error copying to clipboard: no next line!",#log_error}
            EndIf
          Next si

          ;-- copy last selected Line
          *tempLine = *tempLine\nextLine
          If *tempLine
            strline$ = PED_Detokenize{*tempLine}
            strline$ = Left$(strline$,ped\ptrCurrentSourceData\BlockEndX)
            strlng = Len(strline$)
            If ped\verticalCopyMode <> 0 AND (strlng > ped\ptrCurrentSourceData\BlockStartX)
              strline$ = UnRight$(strline$,ped\ptrCurrentSourceData\BlockStartX-1) + Chr$(10)
            Else
              strline$ = strline$ + Chr$(10)
            EndIf
            Write_ *write_fh, &strline$, Len(strline$)
          EndIf
      EndIf
      Close_ *write_fh
      PED_SetPointerNormal{}
    Else
      dummy.l = ask{!TRANS{"Error writing file!"},!TRANS{"OK"},"Error!"}
    End If
  End If
Return


.menu_includeblock:
  log_Print{"includeblock"}

  includeblockfile.s = PED_RequestFile{"","","Name of block to load","(#?.info)", False}
  If includeblockfile <> ""
    PED_PasteBlock{includeblockfile}
  EndIf
Return


.menu_dublicate:
  log_Print{"menu dublicate called."}
  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
    log_Print{"no block selected."}
    PED_SetPointerNormal{}
    Pop If: Return
  EndIf

  error{"Function disabled, WIP."}

  PED_RedrawSource{}
  log_Print{"menu dublicate finished."}
Return


.menu_forget:
  log_Print{"menu forget called."}
  If ped\ptrCurrentSourceData\BlockEndY = $ffffFFFF
    log_Print{"no block selected."}
    PED_SetPointerNormal{}
    Pop If : Return
  EndIf

  error{"Function disabled, WIP."}
  !PED_ResetBlockflag
  PED_RedrawSource{}
Return

.event_leftmousebutton:
USEPATH ped\ptrCurrentSourceData
  ;log_Print{"event left mousebutton, qualifier: " + Hexw$(pedMessage\_Qualifier AND NOT (#IEQUALIFIER_RELATIVEMOUSE|#IEQUALIFIER_LSHIFT))}

  ;-- check if mouse is in source area and there is an existing sourceline
  PED_GetMousePos{mousePos}
  If (mousePos\textY < 0) OR (mousePos\textY + \DisplayLineOffset > \TotalLines - 1) OR (mousePos\textX < 0) OR (mousePos\textX + \ColumnsOffset > #MAX_Columns - 1)
    log_Print{"mouse is outside of source area"}
    Return
  EndIf

  PED_CursorOff{}

  ;-- if a blockmark is set, clear the block
  If \BlockEndY <> $FFFFffff
    ;log_Print{"remove block from source area."}
    PED_DrawBlockmark{}
    !PED_ResetBlockflag
  EndIf

  ;-- set initial blockdimensions
  storeX.w = mousePos\textX + \ColumnsOffset
  storeY.l = mousePos\textY + \DisplayLineOffset

  If storeX > #MAX_Columns- 1 Then storeY = #MAX_Columns - 1
  If storeY > \TotalLines - 1 Then storeY = \TotalLines - 1

  If pedMessage\_Qualifier AND (#IEQUALIFIER_LSHIFT|#IEQUALIFIER_RSHIFT)
    log_Print{"shift: reuse of last click in source! "}
    \LinePosStartX = ostoreX.w
    \LinePosStartY = ostoreY.l
    \LinePosEndX = storeX
    \LinePosEndY = storeY
    bmark\xMin = ostoreX - \ColumnsOffset, ostoreY - \DisplayLineOffset, storeX - \ColumnsOffset, storeY - \DisplayLineOffset
  Else
    \LinePosStartX = storeX
    \LinePosStartY = storeY
    \LinePosEndX = \LinePosStartX
    \LinePosEndY = \LinePosStartY
    bmark\xMin = storeX - \ColumnsOffset, storeY - \DisplayLineOffset, storeX - \ColumnsOffset, storeY - \DisplayLineOffset    
  EndIf

  ; -- draw initial blockmark
  DEFTYPE.bmark storebmark
  CopyType bmark, storebmark
  PED_DrawBlock{bmark}
  ;log_Print{"initial block draw at " + Str$(storeX) + ", " + Str$(storeY)}

  ;-- loop while mousebutton is pressed and block marking is in progress
  exit_mouse_loop.b = False
  Repeat
    PED_GetIntuiMessage{True}

    If pedMessage\_Class <> 0
      If pedMessage\_Code = #SELECTUP
        mqualifier.w = pedMessage\_Qualifier 
        If (mqualifier AND #IEQUALIFIER_CONTROL) Then mqualifier = mqualifier AND (NOT #IEQUALIFIER_CONTROL)
        If (mqualifier AND #IEQUALIFIER_CAPSLOCK) Then mqualifier = mqualifier AND (NOT #IEQUALIFIER_CAPSLOCK)
        If (mqualifier AND #IEQUALIFIER_RSHIFT) Then mqualifier = (mqualifier AND (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
        If (mqualifier AND #IEQUALIFIER_RALT) Then mqualifier = (mqualifier AND (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT
        exit_mouse_loop = True
      Else
        PED_GetMousePos{mousePos}

        tmpX.w = mousePos\textX + \ColumnsOffset
        tmpY.l = mousePos\textY + \DisplayLineOffset 

        If (storeX <> tmpX) OR (storeY <> tmpY)

          If (mousePos\textX) < 0 AND (\ColumnsOffset > 0)
            Gosub mouse_scrollright
          Else
            If mousePos\textX > sourceWindow\visibleColumns
              Gosub mouse_scrollleft
            Else
              If (mousePos\textY < 0) AND (\DisplayLineOffset > 0)
                Gosub mouse_scrolldown
              Else
                If mousePos\textY > sourceWindow\visibleLines - 1
                  Gosub mouse_scrollup
                EndIf
              EndIf
            EndIf
          EndIf
          Gosub mouse_updateblock          
          PED_UpdateStatusArea{#STATUS_SCROLLERS|#STATUS_CURSOR}          
          storeX = tmpX
          storeY = tmpY
        EndIf
      EndIf
    EndIf
  Until exit_mouse_loop

  Gosub mouseclick_in_source

  PED_CursorOn{}
Return

.mouse_scrollup:
USEPATH ped\ptrCurrentSourceData
  tmpY.l = \DisplayLineOffset + sourceWindow\visibleLines - 1
  If tmpY < \TotalLines - 1
    ;-- update the block
    \LinePosEndX = tmpX
    \LinePosEndY = tmpY

    \BlockStartX = \LinePosStartX
    \BlockStartY = \LinePosStartY
    \BlockEndX   = \LinePosEndX
    \BlockEndY   = \LinePosEndY
    PED_NormalizeBlockmarkDimensions{}

    Repeat
      If \CurrentSourceLine\nextLine Then \CurrentSourceLine = \CurrentSourceLine\nextLine
    Until PED_IncreaseDisplayLine{} = 1 OR (\CurrentSourceLine\nextLine = 0)
    PED_ScrollVertical{#SCROLL_UP}
  Else
    tmpY = \TotalLines - 1
  EndIf
Return

.mouse_scrolldown:
USEPATH ped\ptrCurrentSourceData
  tmpY.l = \DisplayLineOffset - 1
  If tmpY => 0
    ;-- update the block
    \LinePosEndX = tmpX
    \LinePosEndY = tmpY

    \BlockStartX = \LinePosStartX
    \BlockStartY = \LinePosStartY
    \BlockEndX   = \LinePosEndX
    \BlockEndY   = \LinePosEndY
    PED_NormalizeBlockmarkDimensions{}
    
    Repeat
      If \CurrentSourceLine\previousLine Then \CurrentSourceLine = \CurrentSourceLine\previousLine
    Until PED_DecreaseDisplayLine{} = 1 OR \CurrentSourceLine\previousLine = 0
    PED_ScrollVertical{#SCROLL_DOWN}

  Else 
    tmpY = 0
  EndIf
Return

.mouse_scrollleft:
USEPATH ped\ptrCurrentSourceData
  tmpX = \ColumnsOffset + sourceWindow\visibleColumns + sourceWindow\scrollSize
  If tmpX < #MAX_Columns
    \LinePosEndX = tmpX
    \LinePosEndY = tmpY

    \BlockStartX = \LinePosStartX
    \BlockStartY = \LinePosStartY
    \BlockEndX   = \LinePosEndX
    \BlockEndY   = \LinePosEndY
    PED_NormalizeBlockmarkDimensions{}

    \ColumnsOffset + sourceWindow\scrollSize

    PED_ScrollHorizontal{#SCROLL_LEFT}
  EndIf
Return

.mouse_scrollright:
USEPATH ped\ptrCurrentSourceData
  tmpX = \ColumnsOffset - sourceWindow\scrollSize
  If tmpX > 0
    \LinePosEndX = tmpX
    \LinePosEndY = tmpY

    \BlockStartX = \LinePosStartX
    \BlockStartY = \LinePosStartY
    \BlockEndX   = \LinePosEndX
    \BlockEndY   = \LinePosEndY
    PED_NormalizeBlockmarkDimensions{}

    \ColumnsOffset - sourceWindow\scrollSize    
    PED_ScrollHorizontal{#SCROLL_RIGHT}
  EndIf
Return

.mouse_updateblock:
  USEPATH ped\ptrCurrentSourceData

  \LinePosEndX = tmpX
  \LinePosEndY = tmpY

  ;-- draw the selection **changes**
  bmark\xMin = storeX - \ColumnsOffset
  bmark\yMin = storeY - \DisplayLineOffset
  bmark\xMax = tmpX - \ColumnsOffset
  bmark\yMax = tmpY - \DisplayLineOffset
  If bmark\xMin > sourceWindow\visibleColumns-1 Then bmark\xMin = sourceWindow\visibleColumns-1
  If bmark\xMax > sourceWindow\visibleColumns-1 Then bmark\xMax = sourceWindow\visibleColumns-1
  If bmark\yMin > \TotalLines-1 Then bmark\yMin = \TotalLines-1
  If bmark\yMax > \TotalLines-1 Then bmark\yMax = \TotalLines-1
  
  If bmark\xMin < 0 Then bmark\xMin = 0
  If bmark\xMax < 0 Then bmark\xMax = 0
  If bmark\yMin < 0 Then bmark\yMin = 0
  If bmark\yMax < 0 Then bmark\yMax = 0

  ;-- adjust blockpart if necessary (e.g. change of direction)
  If bmark\yMax > bmark\yMin
    ; mouse moved into next line, so we have to fill the rest of the current line with a block
    bmark\xMin + 1
  Else
    If bmark\yMax = bmark\yMin
      ; we are in a oneliner
      If (bmark\xMax > bmark\xMin) 
        If bmark\xMin < sourceWindow\visibleColumns-1 Then bmark\xMin + 1
      Else
        If (bmark\xMax < bmark\xMin)
          If bmark\xMax < sourceWindow\visibleColumns-1 Then bmark\xMax + 1
        EndIf
      EndIf
    Else
      ; we select in a negative way
      bmark\xMax + 1
    EndIf
  EndIf

  PED_NormalizeBlockmarkDimensions{bmark} 
;  If (bmark\xMin <> storebmark\xMin) OR (bmark\xMax <> storebmark\xMax) OR (bmark\yMin <> storebmark\yMin) OR (bmark\yMax <> storebmark\yMax)
    log_Print{"updating bmark   " + Str$(bmark\xMin) + ", " + Str$(bmark\yMin)  + ", " + Str$(bmark\xMax) + ", " + Str$(bmark\yMax)}
    PED_DrawBlock{bmark}
;  EndIf
;  CopyType bmark, storebmark
Return


.mouseclick_in_source:
USEPATH ped\ptrCurrentSourceData
  ;log_Print{"mousebutton released in source, qualifier: " + Hex$(mqualifier) }
  ;log_Print{"EndX: " + Str$(\LinePosEndX)+ " EndY: " + Str$(\LinePosEndY)}

  ;-- correct positions, if mousepointer was outside of source area!
  If \LinePosEndY < 0 Then \LinePosEndY = 0
  If \LinePosEndY > \TotalLines-1 Then \LinePosEndY = \TotalLines-1

  ;-- todo: add hardfold support (compare with old asm code at this place!
  ped\foldNumber = 0

  ;-- set y-position: sourceline to last selected line
  lineNum.l = \LinePosEndY - \DisplayLineOffset
  *tempLine.sourceLine = \CurrentSourceLine
  While lineNum <> \DisplayLine
    If lineNum > \DisplayLine
      *tempLine = *tempLine\nextLine
      \DisplayLine + 1
    Else
      *tempLine = *tempLine\previousLine
      \DisplayLine - 1
    EndIf
  Wend
  \CurrentSourceLine = *tempLine
  !PED_UpdateTextBufferOffset

  ;-- set x-position of blockend
  If \LinePosEndX < 1
    ;-- if the mousepointer is mostleft, then set the end of block to the end of the previous line
    If \LinePosEndY > \LinePosStartY
      \LinePosEndY - 1
      \LinePosEndX = #MAX_Columns - 1
    Else
      \LinePosEndX = 0
    EndIf
  EndIf
  If \LinePosEndX > #MAX_Columns - 1
    \LinePosEndX = #MAX_Columns - 1
  EndIf

  ;-- set cursor position to beginning of block mark
  \Column = \LinePosEndX - \ColumnsOffset

  ;-- store last click position for next event
  ostoreX = \LinePosEndX
  ostoreY = \LinePosEndY


  ;-- if a block is marked, then quit routine
  If (\LinePosStartX <> \LinePosEndX) OR (\LinePosStartY <> \LinePosEndY)
      log_Print{"End of block selection, redraw the source, new column: " + Str$(\Column)}
      \BlockStartX = \LinePosStartX
      \BlockStartY = \LinePosStartY
      \BlockEndX = \LinePosEndX
      \BlockEndY = \LinePosEndY
      PED_NormalizeBlockmarkDimensions{}
      log_Print{Str$(\BlockStartX) + ", " + Str$(\BlockStartY)  + " - " + Str$(\BlockEndX) + ", " + Str$(\BlockEndY)}      
      PED_RedrawSource{}
      PED_UpdateStatusArea{#STATUS_SCROLLERS}
  Else
    ;-- it was just a click, so remove the start blockmark and restore 
    log_Print{"just a click, remove initial blockmark!"}
    PED_DrawBlock{bmark}
    !PED_ResetBlockflag

    If mqualifier AND #IEQUALIFIER_LALT ;$30
      Gosub jump_onclick
    EndIf
  EndIf
Return

.menu_gotoline:
  PED_SetPointerBusy{}

  WZWindow WZID("WIN_GOTO"),?wzgui,32,-2,-2,-2,-2,WZID("WIN_GOTO")
  Use Window WZID("WIN_GOTO")

  ;*gad.Gadget = WZGadAddr("GOTO_LINE")
  ;If *gad
  ;  log_Print{Str$(*gad\GadgetType)}
  ;  log_Print{Hex$(*gad\SpecialInfo)}
  ;  !log_HexDump{*gad,48}
  ;  *gadStringInfo.StringInfo = Peek.l(*gad\SpecialInfo)
  ;  ;log_Print{"numchars " + Str$(*gadStringInfo\NumChars)}
  ;  ;RefreshGadgets_ *gad, WZWindowAddr,0
  ;EndIf

  actualLine.l = \DisplayLine + \DisplayLineOffset + 1
  SetGadgetAttrsA_ WZGadAddr("GOTO_LINE"),WZWindowAddr,0,Tags(#WINTEGERA_Long,actualLine)
  WZ_ActivateGadget{"GOTO_LINE"}

  exit_goto.b = False

  Repeat
    ev.l = WaitEvent
    Select ev

      Case #IDCMP_IDCMPUPDATE
        If WZGadName = "GOTO_LINE"
          _line.l = Abs(WZInput("GOTO_LINE")) - 1
           If _line >= 0                                   ; fixed so we can jump to line 1  tomsmart1
             PED_GotoLine{_line, #LINE_START}
           EndIf
          exit_goto = True
        EndIf

      Case #IDCMP_CLOSEWINDOW
        _line = -1
        exit_goto = True

    End Select

  Until exit_goto

  WZCloseWindow WZID("WIN_GOTO")

  PED_SetPointerNormal{}
  Gosub activatesourcewindow
Return

.menu_closewb:
  If NOT CloseWorkBench_
    log_Print{"Could not close the Workbench due to open windows...",#log_warning}
  Else
    log_Print{"Workbench successfully closed."}
  EndIf
Return

.menu_openwb:
  If NOT OpenWorkBench_
    log_Print{"Could not open the Workbench...",#log_error}
  EndIf
  ScreenToFront_ sourceWindow\pedScreen
  ActivateWindow_ sourceWindow\win
Return

.menu_newshell:
  If pedconfig\use_wbscreen <> 0
    WBenchToFront_
    exescr$ = "Workbench"
  Else
    exescr$ = ped\defaultPubscreenName
  EndIf
  exe.s = "NEWCLI WINDOW = \\22"+pedconfig\console_device + "///196/AmiBlitz Shell/CLOSE/SCREEN "+exescr$+"\\22"   ; use select Consoledevice for Shell
  Execute_ &exe,0,0
Return

;================================================================================================================================
;=                                                                                                                              =
;=                   functions to be called by compiler or other programs                                                       =
;=                                                                                                                              =
;================================================================================================================================
.com_consoleOpen:
  !regs2stack
  !basic
  log_Print{"opening console ..."}

  ;-- storing standard cli-I/O-Stream
  runExe\process = FindTask_(0)
  runExe\storeInputStream = runExe\process\pr_CIS
  runExe\storeOutputStream = runExe\process\pr_COS

  ; -- if the console_settings are n/a, set them to something usefull
  USEPATH wtemp
  If \console_h = 0
    \console_x = 0
    \console_y = ped\screen\BarHeight * 2
    \console_w = ped\screen\Width / 3
    \console_h = ped\screen\Height / 3
  EndIf

  ; -- build the window path for opening the con:-device
  Format ""
  con_windowpath.s = Trim$(dos_PathPart{pedconfig\console_device})
  If con_windowpath = "" Then con_windowpath = "CON:"
  con_windowpath + Str$(\console_x)
  con_windowpath + "/" + Str$(\console_y)
  con_windowpath + "/" + Str$(\console_w)
  con_windowpath + "/" + Str$(\console_h)
  con_windowpath + "/" + pedconfig\console_title
  con_windowpath + "/ZOOM" ;"/CLOSE"
  If pedconfig\console_wb = True OR (screen_GetModeID{}=#scr_mode_wb_use)
    con_windowpath + "/SCREEN Workbench"
  Else
    con_windowpath + "/SCREEN " + screen_GetTitle{}
  EndIf
  If pedconfig\console_device = "VNC:"
    con_windowpath + "/DRAG/QUIET/NOCLOSE/NOBUTTONS"
    If pedconfig\console_font <> "" Then con_windowpath + "/FONT" + pedconfig\console_font
  EndIf
  con_windowpath + Chr$(0)

  ;-- check if a console is already open and open it if necessary
  If runExe\cliFileHandle = 0
    ; -- WIP: optionally set the log window as console window
    ;If __ptr_consolelog
    ;  runExe\cliFileHandle = __ptr_consolelog
    ;Else
      log_Print{"opening console with configuration: " + con_windowpath}
      runExe\cliFileHandle = Open_(&con_windowpath,#HUNK_RELOC_8__MODE_NEWFILE)
    ;EndIf
  Else
    log_Print{"console is already open"}
  EndIf

  ;-- set console as input/outputstream for executable task
  If runExe\cliFileHandle <> 0
    log_Print{"setting process input/output stream to console " + Hex$(runExe\cliFileHandle)}
    runExe\process\pr_CIS = runExe\cliFileHandle
    runExe\process\pr_COS = runExe\cliFileHandle
  Else 
    error{"Could not open console!"}
  EndIf

  ;-- put wbscreen to front if option is set
  If pedconfig\console_wb = True Then WBenchToFront_
  !asm
  !stack2regs
RTS

.com_consoleClose:
  !regs2stack
  !basic
  log_Print{"closing console ..."}

  ;-- restoring the Input/Outputstreams of the process
  runExe\process = FindTask_(0)
  runExe\process\pr_CIS = runExe\storeInputStream
  runExe\process\pr_COS = runExe\storeOutputStream

  If pedconfig\console_wait = True
    log_Print{"console close: waiting for input..."}

    If pedconfig\console_wb   = True Then WBenchToFront_

    clitxt.s = "\\1B[1m\\1B[32m"              ; bold text and textcolor (30..37)
    clitxt + !TRANS{"Program terminated."} + "\\0a"
    clitxt + !TRANS{"Press <ENTER> to return to the IDE ..."} + "\\0a"
    Write_ runExe\cliFileHandle, &clitxt, FLen(clitxt)
    Flush_ runExe\cliFileHandle

    PED_SetPointerBusy{}

    console_dummy.b = 0
    While Read_(runExe\cliFileHandle, &console_dummy, 1) = 0
      Delay_ 2
    Wend

    PED_SetPointerNormal{}

    If pedconfig\console_wb = True Then ScreenToFront_ sourceWindow\pedScreen
  EndIf

  If runExe\cliFileHandle <> __ptr_consolelog Then Close_ runExe\cliFileHandle
  runExe\cliFileHandle = 0

  log_Print{"console closed"}
  !asm
  !stack2regs
RTS

.com_logPrint: ;A1: pointer to string, D0: optional value, d3: sourceline
  MOVEM.l a1/d0-d5,-(a7)
  !basic
  MOVEM.l (a7)+,a1/d0-d5
  PutReg D0, log_libnum.l
  PutReg D1, log_sourcefile.l
  PutReg D2, log_linenumber.l
  PutReg D3, ptr_sourceline.l
  PutReg D4, ptr_sourcetext.l
  PutReg D5, log_libsize.l
  PutReg A1, log_text.l

  log_libnum = log_libnum AND $FFFF
  ;log_linenumber = log_linenumber AND $FFFF
  logmess.s = ""

  If log_libnum <> 0
    If log_libnum > 255
      logmess = "syslib  : "
    Else
      logmess = "blitzlib: "
    EndIf
    Format "###00"
    logmess + Str$(log_libnum) + ", " + Str$(log_libsize) + ": " + LSet$(PED_GetLibname{log_libnum},12) + ", "
    Format ""
  EndIf

  If log_sourcefile <> 0
      incfile.s = Peek.s(log_sourcefile)
      If incfile <> ""
        logmess + "I: " + LSet$(incfile,12) + " "
      EndIf
  EndIf

  If log_linenumber <> 0
    If log_linenumber <> -1
      logmess + " L: " + LSet$(Str$(log_linenumber),5) + " "
    EndIf
  EndIf

  If ptr_sourcetext <> 0
    strline.s = Peek.s(ptr_sourcetext)
    If strline <> ""
      If FLen(strline) > #MAX_Columns Then strline = Left$(strline,#MAX_Columns)
      strline = PED_DetokenizeText{strline}
      strline.s = StripTrail$(strline,@" ")
      If logmess <> "" Then strline = Left$(strline,50)
      logmess + strline
    EndIf
  EndIf

  If log_text <> 0
    logmess + Peek.s(log_text)
  EndIf

  log_Print{logmess}

  !asm
RTS


.com_debugTrap:     ; A0: tokenized String in A0, returns detokenized string in A1
  MOVEA.l A0,A2

  MOVEQ.l #$00,D1   ; check length of string in A0
  JL_0_44E6:
    ADDQ.w #1,D1
    TST.b (A0)+
  BNE.b JL_0_44E6

  MOVEA.l A2,A1
  SUBQ.w #1,D1
  BPL.w tokenizeToA1
RTS

.com_detokenizeLine:
  !regs2stack
  !basic
  MOVE.l (a7)+,D0 : *strptr.l = PutD0
  MOVE.l (a7)+,D0 : *destptr.l = PutD0
  If *strptr = 0 OR *destptr = 0
    error{"null-pointer in com_detokenizeLine !"}
  Else
    tmpStringVar.s = PED_DetokenizeText{Peek.s(*strptr)}
    For i = 0 To FLen(tmpStringVar) - 1
      Poke.b *destptr + i, Peek.b(&tmpStringVar + i)
    Next i
  EndIf
  !asm
  !stack2regs
RTS


.com_showErrorRequest: ; A0: ptr to Errortext,            only to be called by compiler
                       ; A5: ptr current sourceline
                       ; A6: "INLN" if in INCLUDE
                       ; D7: includeline
  !regs2stack
  !basic
  fid.l = file_Open{dos_AddPart{pedconfig\systemDir,"ab_compileerror.txt"},#file_read}
  If fid <> -1
    error_type.s    = Mid$(file_ReadLine{fid},9)
    error_code.s    = Mid$(file_ReadLine{fid},9)
    error_line.s    = Mid$(file_ReadLine{fid},9)
    error_lineptr.s = Mid$(file_ReadLine{fid},9)
    error_cause1.s  = Mid$(file_ReadLine{fid},9)
    error_cause2.s  = Mid$(file_ReadLine{fid},9)
    error_source.s  = Mid$(file_ReadLine{fid},9)
    error_libnum.s  = Mid$(file_ReadLine{fid},9)
    error_incname.s = Mid$(file_ReadLine{fid},9)
    error_incline.s = Mid$(file_ReadLine{fid},9)
    compilestatus.s = Mid$(file_ReadLine{fid},9)
    file_Close{fid}

    ;-- open source file with error    
    If error_incname <> "none"
      If Exists (error_incname)
        log_Print{"Error in include ["+ error_incname + "], opening it and jumping to errorline ["+ error_incline + "]..."}
        ;-- check if source is already open
        *fileEntry = PED_CheckSourceAlreadyOpen{ error_incname }
        If *fileEntry
          GetD0 *fileEntry : Gosub selectTab
        Else
          !PED_LoadSource{error_incname, False, True, True}
        EndIf
        PED_GotoLine{Val(error_incline)-1,#LINE_END}
        PED_UpdateStatusArea{#STATUS_REDRAW}
      EndIf
    EndIf
  Else
    error_line = ""
    log_Print{"no error file from compiler",#log_warning}
  EndIf

  ;--
  ;--  building the inforequester:
  If error_line <> ""
    msg$ = !TRANS{Replace$(error_type,"\n","\\n")} + "\\n"
    msg$ + !TRANS{"Line "} + error_line + ": "

    If error_lineptr <> ""
      *errorline.sourceLine = Vallong(error_lineptr)
      error_sourceline.s = Trim$(PED_Detokenize{*errorline})
      msg$ + "--> " + error_sourceline + "\\n"

      log_Print{"Sourceline pointer provided by compiler: $" + Hex$(*errorline)}
      log_Print{"affected sourceline: [" + error_sourceline + "]"}
    Else
      msg$ + "\\n"
    EndIf

    ;-- add infos to include
    If error_incname <> "none"
      msg$ + "\\nThe error occured in included file"
      msg$ + "\\n" + error_incname + "\\n"
      msg$ + "Line " + error_incline + ": "
      msg$ + "--> " + error_source + "\\n"
    EndIf


    ;-- Details
    If error_cause1 <> "" OR error_cause2 <> ""
      msg$ + "\\n------ " + !TRANS{"Problem before:"} + " ------\\n"
      If error_cause1 <> ""
        msg$ + PED_DetokenizeText{error_cause1} + "\\n"
      EndIf
      If error_cause2 <> "" 
        msg$ + PED_DetokenizeText{error_cause2}
      EndIf
    EndIf    
  Else
    msg$ = "Compiler did not provide any data about the problem."
  EndIf

  dummy.l = ask{msg$,!TRANS{"OK"},!TRANS{"Compile Error"}}

  !asm
  !stack2regs
;  MOVE.l (A7)+,D7
RTS

Function.b FAST IsLetter{c.b}
  If (c > 64 AND c < 92) OR (c > 96 AND c < 123 )
    Function Return True
  EndIf
End Function

Function.s PED_TokenizeText2{strLine.s}
SHARED ped, tmpTokeStr

  If ped\doTokenize = False
    tmpTokeStr = strLine
  Else
    If Trim$(strLine) = ""
      tmpTokeStr = ""
    Else
      strLen.w = FLen(strLine)
      runner.w = 0
      ped\inString = False
      CLR.w comWord__QuoteFlag

      Repeat
        curChar.b = Peek.b(&strLine + runner)
        If curChar = $22 Then ped\inString = NOT ped\inString
        If ped\inString = False Then curChar = curChar BitClr 7

        If curChar = $22 ;Peek.b(?comByte_QuotationIdentifier)
          NOT.w comWord__QuoteFlag
          tmpTokeStr + Chr$(curChar)
        EndIf

;        If Peek.w(?comWord__QuoteFlag)
          tmpTokeStr + Chr$(curChar)
 ;       EndIf

        If NOT IsLetter{curChar}
          If (curChar > $29 AND curChar < $58) OR curChar = @"_" OR curChar = @"." OR curChar = @"\"  ; check if char is a number or special char
          EndIf
        EndIf

        ;-- we found a comment, so just copy the rest of the string
        If curChar.b = $22 ;Peek.b(?comByte_QuotationIdentifier)
          For i.w = runner To strLen
            curChar = Peek.b(&strLine + runner) BitClr 7
            tmpTokeStr + Chr$(curChar)
          Next i
          Pop If : Pop Repeat : Pop If : Pop If
          Goto exitsub
        EndIf

        If curChar = @"'" OR curChar = @"#" OR curChar = @"$"
        EndIf

        runner + 1
      Until runner = #MAX_Columns - 1
    EndIf
  EndIf
  exitsub:
  Function Return tmpTokeStr
End Function

.tokenize_line:                        ; input A2: textstring to parse, string has to have the length MAX_Columns!
                                       ; results: comPtr_Temp_TokenString1 = parsed string, D5: length of string
  MOVEA.l comPtr_Temp_TokenString1,A1
  MOVE.l A1,-(A7)                      ; put address pointer A1 on stack to calc processed characters at LeaveParsing
  MOVE.w #MAX_Columns,D1 : SUBQ.w #1,D1
  BRA.w JL_0_5F68

.tokenizeToA1:                         ; input A1: string to parse, D1: length of string to parse
  MOVE.l A1,-(A7)                      ; put address pointer A1 on stack to calc processed characters at LeaveParsing                          
  BRA.w JL_0_5F72

  JL_0_5F68:                           ; tokenize string with pointer in A2 to string buffer in A1
  CMPI.b #$20,$0(A2,D1.W)              ; -------  check spaces from right to left
  BNE.w JL_0_5F7E
    JL_0_5F72:
    SUBQ.w #1,D1
    BPL.b JL_0_5F68
      ADDQ.w #4,A7                     ; adjust stack as we put A1 into it
      CLR.b (A1)
      MOVEQ.l #$01,D5                  ; only spaces in string, so return length 1 as we dont store only 1 space
      RTS
  JL_0_5F7E:

  MOVE.l A4,-(A7)                      ; save A4
  MOVEQ.l #$00,D0
  MOVE.w D0,comWord__QuoteFlag
  CLR.b instring2

  JL_0_5F88:
    MOVE.b (A2)+,D2

    CMP.b #$22,d2 : BNE 'l10           ; ------------------ check for string "
      NOT.b instring2
   'l10
    TST.b instring2 : BNE 'l11
      BCLR #$7,D2                      ; remove tokenflag in string
   'l11

    CMP.b comByte_QuotationIdentifier,D2
    BNE.w JL_0_5FA2
      JL_0_5F96:
      NOT.w comWord__QuoteFlag

      JL_0_5F9C:
      JSR copyD2toA1
      BRA.b JL_0_5F88
    JL_0_5FA2:

    MOVE.w comWord__QuoteFlag,D4
    BNE.b JL_0_5F9C                    ; ----------------------------------------------------

    JSR checkD2ForLetter
    BEQ.w findToken                    ; go to tokenfinder

    JL_0_5FB0:
    CMP.b #$30,d2                      ; number 0-9
    BLT 'l10
      CMP.b #$39,d2
      BGT 'l10
        BRA JL_0_6066
   'l10:

    CMP.b #"_",D2 :    BEQ.w JL_0_6066 ; "_"

    CMP.b #$2E,D2 :    BEQ.w JL_0_6066 ; "."

    CMP.b #"\",D2 :    BEQ.w JL_0_6066 ; "\"

    CMP.b comByte_CommentIdentifier,D2 ; comment found
    BNE.w JL_0_5FDC
      JL_0_5FD0:
        JSR copyD2toA1
        MOVE.b (A2)+,D2
        BCLR #$7,D2
      BRA.b JL_0_5FD0
    JL_0_5FDC:

    CMP.b #"'",d2                       ; do not tokenize ' $ #
    BEQ JL_0_5FE4
      CMP.b #"#",D2
      BEQ.w JL_0_5FE4
        CMP.b #"$",D2
        BNE.w JL_0_6018

      JL_0_5FE4:
        JSR copyD2toA1
        MOVE.b (A2)+,D2
        BCLR #$7,D2
        CMP.b #$22,d2                  ; "
        BNE 'l10
          BRA JL_0_5FE4
       'l10
        CMP.b #"_",d2 : BEQ JL_0_5FE4
        CMP.b #"0",D2 : BCS.w JL_0_6018
        CMP.b #"z",D2 : BHI.w JL_0_6018
        CMP.b #"9",D2 : BLS.b JL_0_5FE4
        CMP.b #"A",D2 : BCS.w JL_0_6018
        CMP.b #"a",D2 : BCC.b JL_0_5FE4
        CMP.b #"Z",D2 : BLS.b JL_0_5FE4
    JL_0_6018:

    JSR copyD2toA1
    MOVE.b (A2)+,D2
    CMP.b #$22,d2 : BNE 'l10
      NOT.b instring2
   'l10
    TST.b instring2 : BNE 'l11
      BCLR #$7,D2                      ;morechar
   'l11
    CMP.b comByte_QuotationIdentifier,D2
    BEQ.w JL_0_5F96

    JSR checkD2ForLetter
    BNE.b JL_0_5FB0

    findToken:                         ; ------ start tokenizing
    SUBQ.w #1,A2
    MOVEA.l comPtr_TokenBase,A3

    JL_0_6036:
    MOVEA.l A2,A4
    MOVE.l A3,-(A7)
    ADDQ.w #6,A3

    JL_0_603C:
    MOVE.b (A3)+,D3                    ; char of Tokenname -> D3
    BEQ.w JL_0_6082
      MOVE.b (A4)+,D2                  ; char of string    -> D2
      BCLR #$7,D2
      ORI.b #$20,D3                    ; or space ?
      ORI.b #$20,D2
      CMP.b D3,D2
      BEQ.b JL_0_603C

      JL_0_6054:
      MOVEA.l (A7)+,A3
      MOVE.l (A3),D3                   ; move to next token
      BEQ.w JL_0_6060                  ; no token left
      MOVEA.l D3,A3
      BRA.b JL_0_6036

      JL_0_6060:                       ; no token found, so write the char
      MOVE.b (A2)+,D2
      BCLR #$7,D2

      JL_0_6066:
      JSR copyD2toA1
      MOVE.b (A2)+,D2
      CMP.b #$22,d2
      BNE 'l10
        NOT.b instring2
     'l10
      TST.b instring2
      BNE 'l11
        BCLR #$7,D2
     'l11
      CMP.b comByte_QuotationIdentifier,D2
      BEQ.w JL_0_5F96

      JSR checkD2ForLetter
      BEQ.b JL_0_6066

      BRA.w JL_0_5FB0
    JL_0_6082:

    MOVE.b (A4),D2
    BCLR #$7,D2
    JSR checkD2ForLetter
    BEQ.b JL_0_6054

    CMP.b #$30,d2                     ; number  0-9
    BLT 'l10
      CMP.b #$39,d2
      BGT 'l10
        BRA JL_0_6054
   'l10:
    CMP.b #"_",D2
    BEQ.b JL_0_6054

    MOVEA.l (A7)+,A3                  ; copy token word to destination string
    ADDQ.w #4,A3
    MOVE.b (A3)+,(A1)
    BSET #$7,(A1)+
    MOVE.b (A3),(A1)+
    MOVE.l A4,D4
    SUB.l A2,D4
    ADD.w D4,D0
    CMP.w D1,D0                       ; d1: maxcolumns - 1
    BHI.w leaveParsing
    MOVEA.l A4,A2
  BRA.w JL_0_5F88

.copyD2toA1:
  MOVE.b D2,(A1)+
  ADDQ.w #1,D0
  CMP.w D1,D0
  BHI.w JL_0_60BE
    RTS
  JL_0_60BE:
  ADDQ.w #4,A7

leaveParsing:
  MOVEA.l (A7)+,A4                    ; restore pointer to tokenstring to A4
  CLR.b (A1)+
  MOVE.l A1,D5
  SUB.l (A7)+,D5                   ; return the length of the string in D5
RTS


.checkD2ForLetter:
  CMP.b #"A",D2 : BCS.w JL_0_60E8
  CMP.b #"z",D2 : BHI.w JL_0_60E8
  CMP.b #"[",D2 : BCS.w JL_0_60E6
  CMP.b #"a",D2 : BCS.w JL_0_60E8
  JL_0_60E6:
  CMP.w D2,D2

  JL_0_60E8:
RTS

Even
comPtr_Temp_TokenString1: Dc.l ptr_tokenstring
ptr_tokenstring:          Ds.l #MAX_Columns + 2
Even

;
;.ascii_to_token: ;d0 = token
;  MOVEM.l d1-d7/a0-a6,-(a7)
;  MOVE.l d0,a2                    ; D0: expandstore
;  MOVEA.l comPtr_TokenBase,A3
;
;  JL_0_6036b:
;    MOVEA.l A2,A4
;    MOVE.l A3,-(A7)
;    ADDQ.w #6,A3
;
;    JL_0_603Cb:
;      MOVE.b (A3)+,D3
;      BEQ.w JL_0_6082b     ;found
;        MOVE.b (A4)+,D2
;        ;BCLR #$7,D2
;        ;ORI.b #$20,D3
;        ;ORI.b #$20,D2
;    CMP.b D3,D2
;    BEQ.b JL_0_603Cb
;
;    JL_0_6054b:
;    MOVEA.l (A7)+,A3
;    MOVE.l (A3),D3
;    BEQ.w JL_0_6060b
;      MOVEA.l D3,A3
;  BRA.b JL_0_6036b
;  JL_0_6082b:
;
;  MOVE.b (A4),D2
;  BNE JL_0_6054b
;  BCLR #$7,D2
;  BNE.b JL_0_6054b       ;not found
;  MOVEA.l (A7)+,A3
;  ADDQ.w #4,A3
;  MOVEQ #0,d0
;  MOVE.b (A3)+,d0
;  ASL.l #8,d0
;  MOVE.b (a3),d0
;  MOVEM.l (a7)+,d1-d7/a0-a6
;RTS
;
; JL_0_6060b
;  MOVEQ #0,d0
;  MOVEM.l (a7)+,d1-d7/a0-a6
;RTS
;



.free_labellist:
  WZListRemove list_Labels
  ped\ptrCurrentSourceData\LabelCounter = 0
Return


.reset_labellist:
  If WZ_IsOpen{"WIN_LABELS"}
    PED_ShowMessage{"Updating Source Browser ..."}  

    Gosub free_labellist
    Gosub update_labellist

    ;-- if labellistchanged is true, the source has changed, so we want to preserve the current selected item
    If ped\labelListChanged = False
      LabelList_1VisableItem = 0
      LabelList_PreSelectItemNumber = -1
    Else
      ped\labelListChanged = False
    EndIf
    If ped\ptrCurrentSourceData\LabelCounter <= LabelList_1VisableItem
      LabelList_1VisableItem = 0
    EndIf

    Use Window WZID("WIN_LABELS")
    ;-- update the labellist
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_Labels,LabelList_1VisableItem

    ;-- update the librarylist
    WZListRemove list_usedBlitzLibs
    WZPrint "LIBRARY_LIST",0,list_usedBlitzLibs

    PED_ShowMessage{""}
  EndIf
Return

.update_labellist:
  ped\ptrCurrentSourceData\LabelCounter = 0

  *nextline.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
  If *nextline = 0 Then Return

  ;eclock_Open{1000}
  ;eclock_Start{1000}

  log_Print{"updating labellist, search string [" + LabelListSearchString + "]"}

  ped\labelSearchMode = 0
  If LabelListSearchString <> ""
    InitArgParse LabelListSearchString
    labelWord1.s = NextArg$
    labelWord2.s = NextArg$
    If labelWord2 <> ""
      ped\labelSearchMode = 2
    Else
      If labelWord1 <> "" Then ped\labelSearchMode = 1
    EndIf
  EndIf

  Gosub listLabels

  ;log_Print{"updating labellist done"}
  ;ttt.l = eclock_Stop{}
  ;log_Print{"time elapsed " + Str$(ttt/1000.0)}
  ;eclock_Close{}
Return

.listLabels:
  labelListMode.b = 0
  If Peek.w(?comWord_LabelAll) Then labelListMode = 1
  If Peek.w(?comWord_LabelCase) Then labelListMode = 2
  If Peek.w(?comWord_LabelRemark) Then labelListMode = 3

  ;log_Print{"listLabels: " + Str$(labelListMode) + ", search: " + labelWord1}

  labelBreak.b = False
  While *nextline AND (labelBreak = False)
    tmpStr.s = StripLead$(Peek.s(*nextline + 9),@" ")
    found.b = False

    If tmpStr <> ""

      Select labelListMode
      Case 2   ; -- labelmode = all "Case"-branches
        If Peek.w(?comWord_LabelCase)
          checkWord.l = Peek.w(&tmpStr) AND $FFFF
          If checkWord = #TOKEN_Case Then found = True
        EndIf

      Case 3    ; -- labelmode = all remarks
        If Peek.w(?comWord_LabelRemark)
          ped\inString = 0
          ped\labelEntryType = $FFFE : found.b = False
          Repeat
            checkByte.b = Peek.b(&tmpStr) AND $FF
            If checkByte = $22 Then ped\inString = NOT ped\inString
            If checkByte = @";" AND (ped\inString = 0) Then found = True
            tmpStr = UnRight$(tmpStr,1)
          Until found OR tmpStr = ""
        EndIf

      Default  ; -- labelmode = all or standard: list functions,statements,breakpoint and labels

        If Peek.w(?comWord_LabelAll)                ; add all codelines
          found = True
        EndIf

        If Instr(tmpStr,"????L") > 0                ; add unknown tokens
          ped\labelEntryType = $FFFD : found.b = True
          ;  log_Print{"unknown token in source: " + labelCaption}
          ;  !log_HexDump{&tmpStr,32}
        EndIf
                                                    ; standard way: only functions, statements, labels, breakpoints
        ;-- check for some tokens
        Select Cvi(tmpStr) AND $FFFF
        Case #TOKEN_Stop
          ped\labelEntryType = #TOKEN_Stop : found.b = True
        Case #TOKEN_TRAP
          ped\labelEntryType = #TOKEN_Stop : found.b = True
        Case #TOKEN_Macro
          ped\labelEntryType = #TOKEN_Macro: found.b = True
          tmpStr = UnRight$(tmpStr,2)
        Case #TOKEN_Statement
          tmpStr = UnRight$(tmpStr,2)
          tmpStr = Trim$(tmpStr)
          If Left$(tmpStr,5) = "FAST "            ; skip token "FAST"
            tmpStr = UnRight$(tmpStr,5)
            tmpStr = Trim$(tmpStr)
          EndIf
          If (Cvi(tmpStr) AND $FFFF) <> #TOKEN_Return         ; check if end of statement
            ped\labelEntryType = #TOKEN_Function : found.b = True
          EndIf
        Case #TOKEN_Function
          tmpStr = UnRight$(tmpStr,2)
          tmpStr = Trim$(tmpStr)
          If Left$(tmpStr,5) = "FAST "            ; skip token "FAST"
            tmpStr = UnRight$(tmpStr,5)
            tmpStr = Trim$(tmpStr)
          EndIf
          If (Cvi(tmpStr) AND $FFFF) <> #TOKEN_Return
            ped\labelEntryType = #TOKEN_Function : found.b = True
          EndIf

        ;-- handle normal labels
        Default
          If Peek.b(&tmpStr) = Peek.b(?comByte_LabelIdentifier)
            ped\labelEntryType = $FFFF           : found = True
          EndIf
        End Select
      End Select

      If found
        If ped\ptrCurrentSourceData\LabelCounter >= #maxlabels
          log_Print{"maximum labels reached: " + Str$(#maxlabels),#log_warning}
          labelBreak = True
        Else
          If Left$(tmpStr,1) = "."                  ; check if label or function-return type
            If ped\labelEntryType = #TOKEN_Function ; skip datatypes if function
              While Left$(tmpStr,1) <> " "
                tmpStr = UnRight$(tmpStr,1)
              Wend
            Else
              tmpStr = UnRight$(tmpStr,1)
            EndIf
            tmpStr = Trim$(tmpStr)
          Else
            tmpStr = Trim$(tmpStr)
          EndIf
          Gosub label_add
        EndIf
      EndIf
    EndIf

    *nextline = *nextline\nextLine
  Wend
Return

.label_add:
  addok.b = False
  labelCaption.s = PED_DetokenizeText{tmpStr}

  ; -- search in entry for an optional search string
  Select ped\labelSearchMode
  Case 0
    addok = True

  Case 1
      If Instr(labelCaption, LabelListSearchString) Then addok = True
  Case 2
    If Instr(labelCaption, labelWord1)
      If Instr(labelCaption, labelWord2) Then  addok = True
    EndIf
  End Select

  ;-- add breakpoint in every case
  If ped\labelEntryType = #TOKEN_Stop Then addok = True

  If addok
    ;If ped\labelEntryType
    ; log_Print{"entry to add... [" + tmpStr + "] $" + Hex$(ped\labelEntryType)}
    ; log_Print{"adding <" + tmpStr + "> <" + labelCaption + "> data " + Hex$(*nextline)}
    ;EndIf

    If labelCaption = ""
      log_Print{"sourcebrowser: label to add is empty!",#log_error}
    EndIf

    If pedconfig\sort_labels = 0
      labelSorting.b = -2
    Else
      labelSorting = -1
    EndIf

    Select ped\labelEntryType
    Case #TOKEN_Stop
      labelCaption.s = "---Breakpoint---" ; space at the beginning to see it as the first entry
      WZTags #WENTRYA_TextPen,2 : labelSorting = 0
    Case #TOKEN_Function
      WZTags #WENTRYA_TextPen,AB3Pen(#AB3_cfunction)
    Case #TOKEN_Statement
      WZTags #WENTRYA_TextPen,AB3Pen(#AB3_cfunction)
    Case #TOKEN_Macro
      WZTags #WENTRYA_TextPen,AB3Pen(#AB3_cmacro)
    Case $FFFE
      WZTags #WENTRYA_TextPen,AB3Pen(#AB3_cremarkforeground)
    Case $FFFD
      WZTags #WENTRYA_TextPen,AB3Pen(#AB3_cclassic)
    Default
      WZTags #WENTRYA_TextPen,1
    End Select
    ped\labelEntryType = 0

    WZListAdd list_Labels,labelCaption,labelSorting,*nextline

    ped\ptrCurrentSourceData\LabelCounter + 1
    ;ped\labelListChanged = True
  EndIf
Return


.memAlert_CloseSource:
  Gosub display_memoryalert
  PED_CloseFile{ped\sourceFileHandle}

  ped\ptrCurrentSourceData\DisplayLineOffset = 0
  ped\ptrCurrentSourceData\DisplayLine = 0
  ped\ptrCurrentSourceData\CurrentSourceLine = ped\ptrCurrentSourceData\FirstSourceLine
  PED_RedrawSource{}
Goto bottom_of_mainloop


.display_memoryalert:
  alert$ = Chr$($00)  ; alert code
  alert$ + Chr$($38)  ; x-position
  alert$ + Chr$($16)  ; y-position
  alert$ + "Not enough memory for that operation! - Click Mousebutton to continue.\00\00"
  DisplayAlert_ $00,&alert$,$28
Return

.close_sourcefonts:
  ;log_Print{"closing fonts..."}
  USEPATH sourceWindow
  If \fontB AND (\fontB <> \font) Then CloseFont_ \fontB : \fontB = 0
  If \font Then CloseFont_ \font : \font = 0
Return

.open_sourcefonts:
  Gosub close_sourcefonts

  ;-- open source font
  DEFTYPE.TextAttr fontsettings
  fontsettings\ta_Name = &sourcefont_name$
  fontsettings\ta_YSize = sourcefont_size
  fontsettings\ta_Style = sourcefont_style

  \font = OpenDiskFont_ (fontsettings)
  If \font = 0                                                  ; open standard font if config not font
    InitRastPort_ defaultrp.RastPort
    AskFont_ defaultrp,ta.TextAttr                                     ; might be better
    log_Print{"sourcefont [" + sourcefont_name$ + "] not found, using default [" + Peek.s(ta\ta_Name) + "]"}
    sourcefont_name$ = Peek.s(ta\ta_Name)
    sourcefont_size = ta\ta_YSize
    sourcefont_style = ta\ta_Style
    fontsettings\ta_Name =  &sourcefont_name$
    fontsettings\ta_YSize = sourcefont_size
    fontsettings\ta_Style = sourcefont_style
    \font = OpenDiskFont_(ta)
  EndIf

  ;-- open bold font
  fontsettings\ta_Style = #FSF_BOLD
  \fontB = OpenDiskFont_ (fontsettings)
  If \fontB = 0
    InitRastPort_ defaultrp.RastPort
    AskFont_ defaultrp,ta.TextAttr
    \fontB = OpenDiskFont_(ta)
    If \fontB
      If \fontB\tf_XSize>< \font\tf_XSize
        CloseFont_ \fontB
        \fontB = \font
      EndIf
    EndIf
  EndIf
Return

.update_loadsourcefile:
  pedconfig\lastSourceFile = ped\sourceFileComplete
  If pedconfig\lastSourceFile <> ""
    log_Print{"updating tooltype LAST_SOURCE to " + ped\sourceFileComplete}
    dos_SetToolString{"LAST_SOURCE",pedconfig\lastSourceFile}
  EndIf
Return

.clear_sourcebuffer:
  !PED_ResetBlockflag

  ped\ptrCurrentSourceData\Column = 0
  ped\ptrCurrentSourceData\DisplayLine = 0
  ped\ptrCurrentSourceData\TextBufferOffset = 0
  ped\ptrCurrentSourceData\DisplayLineOffset = 0
  ped\ptrCurrentSourceData\ColumnsOffset = 0
  ped\ptrCurrentSourceData\SourceChanged = 0
  ped\ptrCurrentSourceData\LabelList = 0
  ped\ptrCurrentSourceData\LabelCounter = 0
  ped\ptrCurrentSourceData\SourceName[0] = 0
  ped\ptrCurrentSourceData\TotalLines = 1

  Gosub clear_sourcewindow

  *tempLine.sourceLine = PED_CreateNewSourceLine{""}
  If *tempLine
    ped\ptrCurrentSourceData\FirstSourceLine = *tempLine
    ped\ptrCurrentSourceData\CurrentSourceLine = *tempLine
    ped\ptrCurrentSourceData\LastSourceLine = *tempLine
  Else
    error{"Could not allocate a new sourceline!"}
  EndIf

  PED_UpdateStatusArea{#STATUS_SCROLLERS}
Return

.free_actualsource:
  log_Print{"freeing current source..."}
  ;!asm
  ;!ComData_JSR{comFunc_ClearSource}
  ;!basic
  *tempLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
  While *tempLine <> 0
    *nextLine = *tempLine\nextLine
    PED_DeleteSourceLine{*tempLine, False}
    *tempLine = *nextLine
  Wend
  ped\ptrCurrentSourceData\TotalLines = 1
  Gosub free_labellist
  log_Print{"...done"}
Return

.create_whole_gui:
  Gosub open_gui
  PED_RedrawSource{}
  PED_UpdateStatusArea{#STATUS_SCROLLERS}
Return

.SetGuiFontToWBScreenFont:                            ;Subroutine to get the used Screenfont of the WB an set it as guifont  tomsmart1
    WbToScreen 0                                      ; set WB to screen 0
    *scr.Screen = Peek.l(Addr Screen(0))              ; get pointer of this screen
    If *scr <> 0                                      ; check if we get a screenstructure
      *scrfont.TextAttr = *scr\Font                   ; try to get the font out of the screenstructur
      If *scrfont<>0                                  ; check if we get a TextAttrstructure

        ; In AmigaDOS we trust :
        guifont_size.w = (*scrfont.TextAttr\ta_YSize)    ; get size of the font
        guifont_name$ = Peek.s(*scrfont.TextAttr\ta_Name)     ; get name of the font

       ; message{"WB fontname="+guifont$+"("+Str$(guifontsize)+")"}  ; for debug only to see if we get the right font ;)
      EndIf

    EndIf
Return


.open_gui:
  ped\errorCode = #PEDERROR_NOERROR

  log_Print{"opening gui...",#log_debug}
  If (pedconfig\use_wbfont = True)  OR  (pedconfig\use_wbscreen<>0)              ; check if we use workbench fonts or screen for Gui tomsmart1

    ;Gosub SetGuiFontToWBScreenFont                                   ; try to get the workbench screen font settinge out of the screen structure tomsmart1
    ;*guifont.TextFont = screen_SetDefaultFont{guifont_name$,guifont_size}  ; and try to use it for the Gui of oure own screen  tomsmart1
    screen_SetDefaultSysFont{#scr_sysfont_wb_prop}                    ; switch on sysfont overwrite for use Workbench screen font  tomsmart1

  Else

    screen_SetDefaultSysFont{#scr_sysfont_wb_off}                     ; switch off sysfont overwrite we want to use the selected font for the Gui  tomsmart1

    If guifont_name$ <> ""
      If guifont_size <= 0 Then guifont_size = 6
      *guifont.TextFont = screen_SetDefaultFont{guifont_name$,guifont_size} ; try to set selected font for the Gui  tomsmart1
    EndIf

    If *guifont = 0                                                   ; unable to open font => use system default
      log_Print{"Could not open selected font <" + guifont_name$ + ">, using Workbench Font instead.",#log_warning}
      Gosub SetGuiFontToWBScreenFont                                  ; try to get the workbench screen font settinge out of the screen structure tomsmart1
      *guifont = screen_SetDefaultFont{guifont_name$,guifont_size}          ; and try to use it for the Gui of oure own screen  tomsmart1
    EndIf
    If *guifont = 0
      log_Print{"We also failed to get the font of the Workbench, we now use the default font.",#log_warning}
      screen_SetDefaultSysFont{#scr_sysfont_wb_prop}                  ; switch on sysfont overwrite for use Workbench screen font  tomsmart1
    End If

  EndIf

  ped\defaultPubscreenName = "AmiBlitz3"
  ped\defaultScreenTitle = "AmiBlitz3 - PED V\\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH"
  If pedconfig\use_wbscreen <> 0                                    ; -- use workbench here
    If screen_Open{ped\defaultScreenTitle,#scr_mode_wb_use} = False
      ped\errorCode = #PEDERROR_OPENSCREEN
    Else
      ped\pubScreenNumber = "WB"
    EndIf
  Else
    If pedconfig\use_pubscreen                                 ; -- searching for already opened ab3-screens
      screen_ziffer.b = 1 : exit_screensearch.b = False
      ped\pubScreenNumber = ""
      Repeat
        GetPubScreen 2,ped\defaultPubscreenName + "_" + Str$(screen_ziffer)
        If Peek.l(Addr Screen(2))<>0
          ReleasePubScreen 2
          screen_ziffer + 1
        Else
          exit_screensearch = True
        EndIf
      Until exit_screensearch
      ped\pubScreenNumber = Str$(screen_ziffer)
      ped\defaultPubscreenName = ped\defaultPubscreenName + "_" + ped\pubScreenNumber
      screen_SetPubName{ped\defaultPubscreenName}        ; set name "str_defaultpubscreen+screen_number"
      WbToScreen 0 ; we need this, because GetPubScreen is steeling us the focus on screen 0
    EndIf

    If pedconfig\clone_wbscreen <> 0                                ; -- clone the workbench for one screen
      If screen_Open{ped\defaultScreenTitle,#scr_mode_wb_clone} = False
        ped\errorCode = #PEDERROR_OPENPUBSCREEN
      EndIf
    Else
      If screen_Open{ped\defaultScreenTitle,pedconfig\screen_modeID,pedconfig\screen_Width,pedconfig\screen_Height,pedconfig\screen_Depth} = False
        err_msg$ = "Could not open selected screen.\\nTrying to open default screen."
        log_Print{err_msg$,#log_warning}
        dummy.l = ask{!TRANS{err_msg$},!TRANS{"Ok"},!TRANS{"Error"}}

        pedconfig\clone_wbscreen = 1    ;try clone Wbscreen
        If screen_Open{ped\defaultScreenTitle,#scr_mode_wb_clone} = False
          err_msg$ = "Could not clone WB-screen, using WB itself."
          dummy.l = ask{!TRANS{err_msg$},!TRANS{"Ok"},!TRANS{"Error"}}
          pedconfig\clone_wbscreen = False  ; no clone Wbscreen
          pedconfig\use_wbscreen = True     ; try use Wbscreen
          If screen_Open{ped\defaultScreenTitle,#scr_mode_wb_use} = False
            ped\errorCode = #PEDERROR_OPENSCREEN
          EndIf
        EndIf

        ;-- get current Screen infos and store it for a update prefs/save
        pedconfig\screen_Width  = screen_GetWidth{}
        pedconfig\screen_Height = screen_GetHeight{}
        pedconfig\screen_Depth  = screen_GetDepth{}
        log_Print{"getting best screenmodeid..."}
        If ExecVersion < 39
          err_msg$ = "Sorry, to obtain best matching screen mode, we need at least OS3.0!\\n"
          error{err_msg$,!TRANS{"Error"}}
          pedconfig\screen_modeID = 0
        Else
          pedconfig\screen_modeID = screen_GetBestModeID{pedconfig\screen_Width,pedconfig\screen_Height,pedconfig\screen_Depth}
        EndIf
      EndIf
    EndIf
  EndIf
  If ped\errorCode
    Select ped\errorCode
    Case #PEDERROR_OPENSCREEN
      dummy.l = ask{!TRANS{"Unable to open screen"},!TRANS{"Ok"},!TRANS{"Error"}}
    Case #PEDERROR_OPENPUBSCREEN
      dummy.l = ask{!TRANS{"Unable to open pubscreen, it is already in use."},!TRANS{"Ok"},!TRANS{"Error"}}
    End Select
    Goto exit_PED_closeall
  EndIf

  If (screen_GetDepth{} < 4) ; AND (Peek.b(?newcolormode)<>0)
    log_Print{"screen colors: " + Str$(1 LSL screen_GetDepth{}),#log_debug}
    log_Print{"screen_GetDepth(): "+ Str$(screen_GetDepth{}),#log_debug}
    dummy.l = ask{!TRANS{"It is recommended to open a screen with at least 16 colors."},!TRANS{"Ok"},!TRANS{"Info"}}
  EndIf

  sourceWindow\pedScreen = Peek.l(Addr Screen(0))
  Poke.l ?comPtr_pedScreen,sourceWindow\pedScreen     ; is used to info compiler on with screen to open requesters

  If screen_GetModeID{}<>#scr_mode_wb_use
    If pedconfig\use_default_pubscreen
      log_Print{"settings defaultpubscreen"}
      SetDefaultPubScreen_ &ped\defaultPubscreenName
    EndIf
  EndIf

  Gosub set_storedcolors

  CNIF #USE_AREXX = 1
  ; -- inform via arexx that the Window is opened
  ArexxMyMessage = "OPENWINDOW" : Gosub arexx_sendmessage
  CEND

  ;log_Print{"init menues"}
  Gosub init_menus

  ;log_Print{"init windowlayouts"}
  Gosub load_windowlayouts

  If pedconfig\autolayout Then AutoLayout{&wtemp,ped\lastAutoLayout}

  ;log_Print{"do window layout"}
  Gosub do_windowlayout
  ;log_Print{"do window layout finished"}
Return


.create_sourcewindow:
  If sourceWindow\WinWidth < 32 Then sourceWindow\WinWidth = ped\screen\Width - sourceWindow\WinLeft - 1
  If sourceWindow\WinHeight < 32 Then sourceWindow\WinHeight = ped\screen\Height - sourceWindow\WinTop - 1
  If sourceWindow\WinLeft + sourceWindow\WinWidth > ped\screen\Width  Then sourceWindow\WinWidth = ped\screen\Width - sourceWindow\WinLeft
  If sourceWindow\WinTop + sourceWindow\WinHeight > ped\screen\Height Then sourceWindow\WinHeight = ped\screen\Height - sourceWindow\WinTop

  DEFTYPE.Image  *img             ; An image which represents the size gadget
  DEFTYPE.Image  *sizeimage,*rarrowimage,*larrowimage,*darrowimage,*uarrowimage
  DEFTYPE.Gadget *rarrowbutton,*larrowbutton,*darrowbutton,*uarrowbutton
  DEFTYPE.l sizew,sizeh,w,h,barh,exit
  Dim GTags.TagItem(4) ; -- Tags for getting the size gadget image

  sourceWindow\drawinfo = GetScreenDrawInfo_(ped\screen)
  If sourceWindow\drawinfo
    If (ped\screen\Flags & #SCREENHIRES) Then sis.l=#SYSISIZE_HIRES Else sis=#SYSISIZE_MEDRES
    GTags(0)\ti_Tag = #SYSIA_DrawInfo,sourceWindow\drawinfo
    GTags(1)\ti_Tag = #SYSIA_Which,#SIZEIMAGE
    GTags(2)\ti_Tag = #SYSIA_Size,sis
    GTags(3)\ti_Tag = #TAG_DONE
    *img = NewObjectA_(0,"sysiclass",&GTags(0))
    If *img Then DisposeObject_ *img
    FreeScreenDrawInfo_ ped\screen,sourceWindow\drawinfo
  EndIf

  ; --
  ; -- Fenster erzeugen
  ; --
  sourceWindow\drawinfo = GetScreenDrawInfo_(ped\screen)
  If (ped\screen\Flags & #SCREENHIRES)
    syssize.b = #SYSISIZE_MEDRES
  Else
    syssize = #SYSISIZE_LOWRES
  EndIf
  *sizeimage = NewObjectA_(0,"sysiclass",Tags(#SYSIA_Which,#SIZEIMAGE,@@
                                                #SYSIA_Size     ,syssize,@@
                                                #SYSIA_DrawInfo ,sourceWindow\drawinfo,@@
                                                #TAG_END        ,0))
  If (*sizeimage)
    GetAttr_ #IA_Width,*sizeimage ,&sizew
    GetAttr_ #IA_Height,*sizeimage,&sizeh
    DisposeObject_ *sizeimage
  Else
    sizew = 18
    sizeh = 10
  EndIf

  *darrowimage = NewObjectA_(0,"sysiclass",Tags(#SYSIA_Which,#DOWNIMAGE,@@
                                                   #SYSIA_Size     ,syssize,@@
                                                   #SYSIA_DrawInfo ,sourceWindow\drawinfo,@@
                                                   #TAG_END        ,0))
  If (*darrowimage)
    GetAttr_ #IA_Width ,*darrowimage,&w
    GetAttr_ #IA_Height,*darrowimage,&h
  EndIf

  *darrowbutton = NewObjectA_(0,"buttongclass",Tags(#GA_ID,#GID_DARROW,@@
    #GA_RelRight    ,-w+1,@@
    #GA_RelBottom   ,-sizeh-h+1,@@
    #GA_Width       ,w,@@
    #GA_Height      ,h,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,sourceWindow\drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #GA_Image       ,*darrowimage,@@
    #TAG_END        ,0))

  *uarrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#UPIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,sourceWindow\drawinfo,@@
    #TAG_END        ,0))

  If (*uarrowimage)
    GetAttr_ #IA_Width ,*uarrowimage,&w
    GetAttr_ #IA_Height,*uarrowimage,&h
  EndIf

  *uarrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous    ,*darrowbutton,@@
    #GA_ID          ,#GID_UARROW,@@
    #GA_RelRight    ,-w+1,@@
    #GA_RelBottom   ,-sizeh-h-h+1,@@
    #GA_Width       ,w,@@
    #GA_Height      ,h,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,sourceWindow\drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #GA_Image       ,*uarrowimage,@@
    #TAG_END        ,0))

  barh = ped\screen\WBorTop+ped\screen\RastPort\TxHeight+2

  sourceWindow\vertiprop = NewObjectA_(0,"propgclass",Tags(@@
    #GA_Previous    ,*uarrowbutton,@@
    #GA_ID          ,#GID_YPROP,@@
    #GA_RelRight    ,-sizew+4,@@
    #GA_Top         ,barh,@@
    #GA_Width       ,sizew-6,@@
    #GA_RelHeight   ,-sizeh-h-h-barh-1,@@
    #GA_Immediate   ,True,@@
    #GA_RelVerify   ,True,@@
    #GA_DrawInfo    ,sourceWindow\drawinfo,@@
    #GA_GZZGadget   ,True,@@
    #GA_RightBorder ,True,@@
    #PGA_Freedom    ,#FREEVERT,@@
    #PGA_Borderless ,True,@@
    #PGA_NewLook    ,True,@@
    #PGA_Total      ,1,@@
    #PGA_Visible    ,1,@@
    #TAG_END        ,0))

  *rarrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#RIGHTIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,sourceWindow\drawinfo,@@
    #TAG_END        ,0))

  If (*rarrowimage)
    GetAttr_ #IA_Width ,*rarrowimage,&w
    GetAttr_ #IA_Height,*rarrowimage,&h
  EndIf

  *rarrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous     ,sourceWindow\vertiprop,@@
    #GA_ID           ,#GID_RARROW,@@
    #GA_RelRight     ,-sizew-w+1,@@
    #GA_RelBottom    ,-h+1,@@
    #GA_Width        ,w,@@
    #GA_Height       ,h,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,sourceWindow\drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #GA_Image        ,*rarrowimage,@@
    #TAG_END         ,0))

  *larrowimage = NewObjectA_(0,"sysiclass",Tags(@@
    #SYSIA_Which    ,#LEFTIMAGE,@@
    #SYSIA_Size     ,syssize,@@
    #SYSIA_DrawInfo ,sourceWindow\drawinfo,@@
    #TAG_END        ,0))

  If (*larrowimage)
    GetAttr_ #IA_Width ,*larrowimage,&w
    GetAttr_ #IA_Height,*larrowimage,&h
  EndIf

  *larrowbutton = NewObjectA_(0,"buttongclass",Tags(@@
    #GA_Previous     ,*rarrowbutton,@@
    #GA_ID           ,#GID_LARROW,@@
    #GA_RelRight     ,-sizew-w-w+1,@@
    #GA_RelBottom    ,-h+1,@@
    #GA_Width        ,w,@@
    #GA_Height       ,h,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,sourceWindow\drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #GA_Image        ,*larrowimage,@@
    #TAG_END         ,0))

  sourceWindow\horizprop = NewObjectA_(0,"propgclass",Tags(@@
    #GA_Previous     ,*larrowbutton,@@
    #GA_ID           ,#GID_XPROP,@@
    #GA_Left         ,ped\screen\WBorLeft,@@
    #GA_RelBottom    ,-sizeh+3,@@
    #GA_RelWidth     ,-sizew-w-w-ped\screen\WBorLeft-1,@@
    #GA_Height       ,sizeh-4,@@
    #GA_Immediate    ,True,@@
    #GA_RelVerify    ,True,@@
    #GA_DrawInfo     ,sourceWindow\drawinfo,@@
    #GA_GZZGadget    ,True,@@
    #GA_BottomBorder ,True,@@
    #PGA_Freedom     ,#FREEHORIZ,@@
    #PGA_Borderless  ,True,@@
    #PGA_NewLook     ,True,@@
    #PGA_Total       ,#MAX_Columns,@@
    #PGA_Visible     ,20,@@
    #TAG_END         ,0))


  If (sourceWindow\vertiprop=0) OR (sourceWindow\horizprop=0)
    sourceWindow\win = 0
    dummy.l = ask{!TRANS{"Unable to open window!"},!TRANS{"Ok"},!TRANS{"Error"}}
    Goto exit_PED_closeall
  EndIf

  SourceWindowIDCMPFlags.l = #IDCMP_INTUITICKS|#IDCMP_CLOSEWINDOW|#IDCMP_VANILLAKEY|#IDCMP_RAWKEY
  SourceWindowIDCMPFlags | #IDCMP_MENUPICK|#IDCMP_GADGETUP|#IDCMP_GADGETDOWN
  SourceWindowIDCMPFlags | #IDCMP_MOUSEMOVE|#IDCMP_MOUSEBUTTONS|#IDCMP_NEWSIZE|#IDCMP_CHANGEWINDOW|#IDCMP_REFRESHWINDOW
  SourceWindowIDCMPFlags | #IDCMP_ACTIVEWINDOW|#IDCMP_INACTIVEWINDOW   ; added to get info if the source win (in)active
  ; only added OS4 only IDCMP Flags if we are running on OS4  tomsmart1  
  If OSVersion = #AmigaOS4
    SourceWindowIDCMPFlags | #IDCMP_EXTENDEDMOUSE  ;added #IDCMP_EXTENDEDMOUSE for OS4 Mousewheel support
  EndIf

  SourceWindowWFlags.l = #WFLG_NEWLOOKMENUS|#WFLG_WBENCHWINDOW|#WFLG_ACTIVATE|#WFLG_GIMMEZEROZERO
  SourceWindowWFlags   | #WFLG_SIZEBBOTTOM|#WFLG_SIZEBRIGHT|#WFLG_SIZEGADGET|#WFLG_CLOSEGADGET|#WFLG_DEPTHGADGET
  SourceWindowWFlags   | #WFLG_DRAGBAR|#WFLG_REPORTMOUSE

  ; --- OPEN the WINDOW
  Use Screen 0
  DefaultIDCMP SourceWindowIDCMPFlags    ; we have to add these IDCMP-Flags to the list that "event" is going to listen for
  WindowTags 0,SourceWindowWFlags,"AmiBlitz3",Tags(@@
                      #WA_Left       ,sourceWindow\WinLeft,@@
                      #WA_Top        ,sourceWindow\WinTop,@@
                      #WA_Height     ,sourceWindow\WinHeight,@@
                      #WA_Width      ,sourceWindow\WinWidth,@@
                      #WA_MinWidth   ,320,@@
                      #WA_MaxWidth   ,-1,@@
                      #WA_MinHeight  ,120,@@
                      #WA_MaxHeight  ,-1,@@
                      #WA_Gadgets    ,*darrowbutton,@@
                      #WA_PubScreen  ,ped\screen,@@
                      (#WA_Dummy + $60),-1)
  sourceWindow\win = Peek.l(Addr Window(0))

  If sourceWindow\win = 0
    dummy.l = ask{!TRANS{"Unable to open window!"},!TRANS{"Ok"},!TRANS{"Error"}}
    Goto exit_PED_closeall
  EndIf

  If ped\menuStrip Then SetMenuStrip_ sourceWindow\win,ped\menuStrip

  SetFont_ sourceWindow\win\RPort,sourceWindow\font

  ;-- attach sourcewindow to peds process
  ;log_Print{"attach sourcewindow as main window of ped-task"}
  ped\taskWinPtr = *pedProcess\pr_WindowPtr
  *pedProcess\pr_WindowPtr = sourceWindow\win
Return


.open_sourcewindow:
  log_Print{"open sourcewindow."}

  ; -- check arexx
  CNIF #USE_AREXX = 1
    If arexx_GetMsg{True} Then Gosub arexx_event
  CEND

  If Used Screen < 0 Then WbToScreen 0
  ped\screen = Peek.l(Addr Screen(Used Screen))
  If ped\screen = 0
    Gosub close_gui
    ped\errorCode = #PEDERROR_OPENWINDOW
    Return
  EndIf

  If sourceWindow\win = 0
    Gosub create_sourcewindow
  EndIf

  ped\labelListChanged = True  ; indicate that label window has to be updated too

  ; --
  ; -- Berechnung des Sourcelayouts, Groesse der Scroller etc.
  ; --
  Gosub calc_SourceWindowDimensions

  ;
  ; -- Speicher reservieren fuer sichtbaren Sourcebereich
  ;
  Gosub allocate_textbuffer

  ; -- allocate memory for temp rastport
  *sourcerp.RastPort = PED_AllocMem{$64}
  sourceWindow\rp = *sourcerp
  CopyMem_ sourceWindow\win\RPort,*sourcerp,$64
  SetDrMd_ *sourcerp, #COMPLEMENT

  ;*mask.l = AllocMem(4,0)
  ;If (*mask > 0)
  ;  Poke.w *mask,   %000100010001000100
  ;  Poke.w *mask +2,%100010001000100010
  ;  *sourcerp\AreaPtrn = *mask
  ;  *sourcerp\AreaPtSz = 1
  ;EndIf

  SetWindowTitles_ sourceWindow\win,&ped\defaultScreenTitle,-1
  Gosub clear_sourcewindow
  PED_SetPointerNormal{}
  PED_RedrawSource{}
Return

.calc_SourceWindowDimensions:
  ;log_Print{"calculating sourcewindow dimensions..."}
  USEPATH sourceWindow
  \BoxHeight = \win\Height - \win\BorderTop - \win\BorderBottom
  \BoxWidth = \win\Width   - \win\BorderLeft - \win\BorderRight

  If pedconfig\linenumbers
    If ped\ptrCurrentSourceData ; maybe there is no source loaded at begin
      ;log_Print{"TotalLines: " + Str$(ped\ptrCurrentSourceData\TotalLines)}
      digits.b = 5
      If ped\ptrCurrentSourceData\TotalLines < 10000 Then digits = 4
      If ped\ptrCurrentSourceData\TotalLines < 1000 Then digits = 3
      If ped\ptrCurrentSourceData\TotalLines < 100 Then digits = 2
      If ped\ptrCurrentSourceData\TotalLines < 10 Then digits = 2
    Else
      digits = 2
    EndIf
    linenumberWidth.w = digits * \font\tf_XSize
    \BoxLeft = linenumberWidth + 5
  Else
    \BoxLeft = 0
  EndIf
 
  \BoxTop = \font\tf_YSize + 2

  \visibleLines = (\BoxHeight - \BoxTop - 6) / \font\tf_YSize  ; 6 Pixel fehlen wg. Trennlinie etc.
  \visibleLines - 2                        ; subtract two lines for status area
  \statusAreaY = \BoxTop + \visibleLines * \font\tf_YSize + 1
  \visibleColumns = (\BoxWidth - \BoxLeft) / \font\tf_XSize

  ;-- move cursor if invisible after resizing
  If ped\ptrCurrentSourceData
    actualColumn.w = (ped\ptrCurrentSourceData\ColumnsOffset + ped\ptrCurrentSourceData\Column) - (\visibleColumns - 1)
    If (actualColumn > 0)
      log_Print{"Cursor is now outside of window (" + Str$(actualColumn) + "), move cursor into visible area."}  
      If ped\ptrCurrentSourceData\ColumnsOffset > 0
        ped\ptrCurrentSourceData\ColumnsOffset - actualColumn
        If ped\ptrCurrentSourceData\ColumnsOffset < 0
          ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset
          ped\ptrCurrentSourceData\ColumnsOffset = 0
        EndIf
      Else
        ped\ptrCurrentSourceData\Column = \visibleColumns - 1
      EndIf
    EndIf
  EndIf

  ;-- set default values for sourcewindow scrolling
  \boundLinesX = 2
  \boundLinesY = 2
  \scrollSize = 1
Return

.allocate_textbuffer:
  ;log_Print{"allocate textbuffer"}

  Gosub free_textbuffer

  ped\ptrTextbuffer = PED_AllocMem{#MAX_Columns * sourceWindow\visibleLines}
  If ped\ptrTextbuffer = 0
    dummy.l = ask{!TRANS{"Unable to allocate memory for text buffer!"},!TRANS{"Ok"},!TRANS{"Error"}}
    Pop If : Goto exit_PED_closeall
  EndIf

  log_Print{"textbuffer at " + Hex$(ped\ptrTextbuffer)}
Return

.free_textbuffer:
  If ped\ptrTextbuffer
    log_Print{"freeing textbuffer..."}  
    PED_FreeMem{ped\ptrTextbuffer}
    ped\ptrTextbuffer = 0
  EndIf
Return



.close_gui:
  log_Print{"closing gui..."}

  ;-- we want to close the pub screen, therfore we inform all apps on the screen that it is not public anymore
  If pedconfig\use_pubscreen Then PubScreenStatus_ sourceWindow\pedScreen,#PSNF_PRIVATE

  ;-- inform arexxport that the source window is going to be closed
  CNIF #USE_AREXX = 1
    ArexxMyMessage = "CLOSEWINDOW" : Gosub arexx_sendmessage
  CEND

  Gosub close_sourcewindow

  WZ_CloseAllWindows{}

  ;-- optionally close console window if open
  If runExe\cliFileHandle <> 0
    If runExe\cliFileHandle <> __ptr_consolelog
      Close_ runExe\cliFileHandle : runExe\cliFileHandle = 0
    EndIf
  EndIf

  vvblank_Free{}
  screen_Close{}   ; this release all pens for us and close the used fonts

  log_Print{"closed gui"}
Return


.close_sourcewindow:
  If sourceWindow\win
    FlushEvents
    ;If sourceWindow\win
    ;  *intuimessage.IntuiMessage = GetMsg_(sourceWindow\win\UserPort)
    ;  While *intuimessage
    ;    ReplyMsg_ *intuimessage : *intuimessage = 0
    ;    *intuimessage.IntuiMessage = GetMsg_(sourceWindow\win\UserPort)
    ;  Wend
    ;EndIf

    Gosub free_textbuffer

    CloseWindow 0 : sourceWindow\win = 0
    ;Poke.l Addr Window(0),0  ; to clear the window structure of BlitzBasic to prevent a crash at exit.

    DisposeObject_ *larrowbutton
    DisposeObject_ *larrowimage
    DisposeObject_ *rarrowbutton
    DisposeObject_ *rarrowimage
    DisposeObject_ sourceWindow\horizprop
    DisposeObject_ *darrowbutton
    DisposeObject_ *darrowimage
    DisposeObject_ *uarrowbutton
    DisposeObject_ *uarrowimage
    DisposeObject_ sourceWindow\vertiprop
    FreeScreenDrawInfo_ ped\screen,sourceWindow\drawinfo

    ; -- clear rastport for source area
    If *sourcerp Then PED_FreeMem{*sourcerp}

    ; -- restore previous attached window to this task: not needed but save
    *pedProcess\pr_WindowPtr = ped\taskWinPtr
  EndIf
Return


.set_storedcolors:
  screen_ReleaseAllPens{} ; release all pens that have been previously obtained by screen.include

  If (pedconfig\use_wbscreen = False) AND (ExecVersion > 38)
    screen_SetPenRGB{0             ,AB3RGB(#AB3_screenback) }
    screen_SetPenRGB{1             ,AB3RGB(#AB3_screentext) }
    screen_SetPenRGB{2             ,AB3RGB(#AB3_screenshine)}
    screen_SetPenRGB{3             ,AB3RGB(#AB3_screenfill) }
    AB3Pen(#AB3_screenback)        = screen_GetPenRGB{AB3RGB(#AB3_screenback) }
    AB3Pen(#AB3_screentext)        = screen_GetPenRGB{AB3RGB(#AB3_screentext) }
    AB3Pen(#AB3_screenshine)       = screen_GetPenRGB{AB3RGB(#AB3_screenshine)}
    AB3Pen(#AB3_screenfill)        = screen_GetPenRGB{AB3RGB(#AB3_screenfill) }
  Else
    AB3Pen(#AB3_screenback)        = 0
    AB3Pen(#AB3_screentext)        = 1
    AB3Pen(#AB3_screenshine)       = 2
    AB3Pen(#AB3_screenfill)        = 3
  EndIf

  If (ExecVersion > 38)
    AB3Pen(#AB3_cfunction)           = screen_GetPenRGB{AB3RGB(#AB3_cfunction)}
    AB3Pen(#AB3_cmacro)              = screen_GetPenRGB{AB3RGB(#AB3_cmacro)}
    AB3Pen(#AB3_cstring)             = screen_GetPenRGB{AB3RGB(#AB3_cstring)}
    AB3Pen(#AB3_cnewtype)            = screen_GetPenRGB{AB3RGB(#AB3_cnewtype)}
    AB3Pen(#AB3_cconstant)           = screen_GetPenRGB{AB3RGB(#AB3_cconstant)}
    AB3Pen(#AB3_cremarkforeground)   = screen_GetPenRGB{AB3RGB(#AB3_cremarkforeground)}
    AB3Pen(#AB3_cremarkbackground)   = screen_GetPenRGB{AB3RGB(#AB3_cremarkbackground)}
    AB3Pen(#AB3_ctoken)              = screen_GetPenRGB{AB3RGB(#AB3_ctoken)}
    AB3Pen(#AB3_ctokenbackground)    = screen_GetPenRGB{AB3RGB(#AB3_ctokenbackground)}
    AB3Pen(#AB3_cbackground)         = screen_GetPenRGB{AB3RGB(#AB3_cbackground)}
    AB3Pen(#AB3_cother)              = screen_GetPenRGB{AB3RGB(#AB3_cother)}
    AB3Pen(#AB3_cclassic)            = screen_GetPenRGB{AB3RGB(#AB3_cclassic)}
  Else
    AB3Pen(#AB3_cfunction)           = 1;screen_GetPenRGB{AB3RGB(#AB3_cfunction)}
    AB3Pen(#AB3_cmacro)              = 1;screen_GetPenRGB{AB3RGB(#AB3_cmacro)}
    AB3Pen(#AB3_cstring)             = 1;screen_GetPenRGB{AB3RGB(#AB3_cstring)}
    AB3Pen(#AB3_cnewtype)            = 1;screen_GetPenRGB{AB3RGB(#AB3_cnewtype)}
    AB3Pen(#AB3_cconstant)           = 1;screen_GetPenRGB{AB3RGB(#AB3_cconstant)}
    AB3Pen(#AB3_cremarkforeground)   = 1;screen_GetPenRGB{AB3RGB(#AB3_cremarkforeground)}
    AB3Pen(#AB3_cremarkbackground)   = 0;screen_GetPenRGB{AB3RGB(#AB3_cremarkbackground)}
    AB3Pen(#AB3_ctoken)              = 2;screen_GetPenRGB{AB3RGB(#AB3_ctoken)}
    AB3Pen(#AB3_ctokenbackground)    = 0;screen_GetPenRGB{AB3RGB(#AB3_ctokenbackground)}
    AB3Pen(#AB3_cbackground)         = 0;screen_GetPenRGB{AB3RGB(#AB3_cbackground)}
    AB3Pen(#AB3_cother)              = 1;screen_GetPenRGB{AB3RGB(#AB3_cother)}
    AB3Pen(#AB3_cclassic)            = 1;screen_GetPenRGB{AB3RGB(#AB3_cclassic)}
  EndIf
Return



.clear_sourcewindow:
  ;log_Print{"clear source window"}

  ; -- clear the codelines in window
  USEPATH sourceWindow
  SetAPen_ \win\RPort,AB3Pen(#AB3_cbackground)
  RectFill_ \win\RPort,\BoxLeft,\BoxTop,\BoxWidth,\statusAreaY-1

  ; draw vertical line to seperate numbers and source code
  If pedconfig\linenumbers
    lx.w = \BoxLeft - 1
    SetAPen_ \win\RPort,AB3Pen(#AB3_screenfill)
    RectFill_ \win\RPort,0,\BoxTop,lx,\statusAreaY-1

    lx - 1
    SetAPen_ \win\RPort,AB3Pen(#AB3_screenshine)
    Move_ \win\RPort,lx, \BoxTop
    Draw_ \win\RPort,lx, \statusAreaY-1
  EndIf

  PED_UpdateStatusArea{#STATUS_REDRAW}
  PED_ShowMessage{""}
  PED_ClearTextbuffer{}
  ;log_Print{"clear source window done."}
Return


.moveCursorToEndOfLine:
  lineaddr = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset
  PED_MoveCursorToX{ getLineLength{lineaddr} }
Return

.moveCursorToBeginOfLine:
  If ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset > 0
    PED_MoveCursorToX{0}
  Else
    If ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine > 0
      runner.w = 0
      Repeat
        curbyte.b = Peek.b(ped\ptrCurrentSourceData\CurrentSourceLine + 9 + runner)
        runner + 1
      Until (curbyte <> $20) OR (curbyte = 0) OR (runner = #MAX_Columns)
      If (curbyte <> 0) AND (runner > 0)
        runner - 1
        PED_MoveCursorToX{runner}
      EndIf
    EndIf
  EndIf
Return

.moveCursorToBeginOfWord:
  lineaddr = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset
  textlen.w = getLineLength{lineaddr}

  cursorpos.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset
  If cursorpos > 1
    cursorpos - 1
    skip_spaces.b = False
    If Peek.b(lineaddr + cursorpos) = 32 Then skip_spaces = True ; check if current char is a space

    exit_loop.b = False
    Repeat
      cursorpos - 1
      char.b = Peek.b(lineaddr + cursorpos)
      If skip_spaces
        If char <> 32 Then skip_spaces = False
      Else
        If (char < 48) OR (char = Asc("{")) OR (char = Asc("}"))
          cursorpos + 1 ; cursor should be *at* the first character
          exit_loop = True
        EndIf
      EndIf
    Until exit_loop OR (cursorpos < 1)
  EndIf
  PED_MoveCursorToX{cursorpos}
Return

.moveCursorToEndOfWord:
  lineaddr = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset
  textlen.w = getLineLength{lineaddr}
  
  cursorpos.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset
  If cursorpos < textlen
    cursorpos + 1
    skip_spaces.b = False
    ;-- check if current char is a space
    If Peek.b(lineaddr + cursorpos) = $20 Then skip_spaces = True 

    exit_loop.b = False
    Repeat
      cursorpos + 1
      char.b = Peek.b(lineaddr + cursorpos)
      If skip_spaces
        If char <> 32 Then skip_spaces = False
      Else
        If (char < 48) OR (char = Asc("{")) OR (char = Asc("}"))
          exit_loop = True
        EndIf
      EndIf
    Until exit_loop OR (cursorpos => textlen)
  EndIf
  PED_MoveCursorToX{cursorpos}
Return


.helpOnToken:
  log_Print{"helpOnToken"}
  strline$ = PED_Detokenize{ped\ptrCurrentSourceData\CurrentSourceLine}
  ;log_Print{"current sourceline: " + strline$}
  actualword$ = PED_GetWordAtPos{strline$, ped\ptrCurrentSourceData\Column,True}
  If actualword$ <> ""
    Gosub startGuide
  Else
    Gosub open_instructionbrowser
  EndIf

  PED_ShowMessage{""}
Return


.immediate_syntaxhelp:
  _key.b = last_vankey
  already_displayed.b = False
  ;log_Print{"immediate help ? : last_key " + Hex$(last_vankey)}
  If (_key=@" ") OR (_key = @"(") OR (_key = @"{")

    If ped\ptrCurrentSourceData\Column > 0

      Gosub close_popupwindow

      lineaddr = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset
      strline$ = Peek.s(lineaddr)

      bracketclose1.l = Instr(strline$,")")
      bracketclose2.l = Instr(strline$,"}")

      bracketopen1.l  = Instr(strline$,"(",bracketclose1)
      bracketopen2.l  = Instr(strline$,"{",bracketclose2)

      bracketopen.l   = 0

      If bracketopen1>bracketopen2 Then bracketopen=bracketopen1 : Else bracketopen=bracketopen2

      searchpos.l = ped\ptrCurrentSourceData\Column
      If bracketopen>0 AND bracketopen<searchpos Then searchpos=bracketopen

      _tokname.s = PED_GetWordAtPos{strline$, searchpos, True}
      If _tokname.s <> ""
        If *preProcessor\tokenFlags[_key&$FF]&#TOKENF_IS
          _tokname.s + Chr$(_key)
        End If
      End If
      If _tokname.s
        If PED_ShowHelptextFor{_tokname.s} = False
          Gosub intellisense
        End If
      End If
    EndIf
  Else
    Select _key
    Case $8b ; "HELP"
      strline$ = PED_Detokenize{ped\ptrCurrentSourceData\CurrentSourceLine}
      _tokname.s = PED_GetWordAtPos{strline$, ped\ptrCurrentSourceData\Column,True}
      If _tokname <> ""
        log_Print{"HELP on <" + _tokname + ">"}
        If LCase$(_tokname) = "endif"
          Gosub help_checkforif
        Else
          Gosub help_checkfortype
          If typestr$ = ""
            log_Print{"as there is no typehelp available, trying to get a token help text..."}
            PED_ShowHelptextFor{_tokname}
          EndIf
        EndIf
      EndIf

     Case $0D ; ENTER
       If pedconfig\intellisense AND pedconfig\onlinehelp_includes
         If WZ_IsOpen{"WIN_POPUP"}
           tmpStringVar = WZ_GetPopUpEntry{WZ_GetPopUpMenu{}+1}

           ; include function
           a_new$ = dos_Trim{Left$(tmpStringVar,Instr(tmpStringVar,"{")-1)}
           If (a_new$ <> "") ;test if include function
             PED_ShowMessage{a_new$ + " " + PED_GetIndexHelp{a_new$, #INDEXHELP_HELP} }
             tmpStringVar = a_new$ + "{"
           Else          ; is command
             PED_ShowMessage{tmpStringVar + " " + PED_GetTokenHelp{tmpStringVar} }
           EndIf

           tmpStringVar = UnRight$(tmpStringVar,FLen(poptok$)) : PED_InsertStringToTextBuffer{tmpStringVar}

           Gosub close_popupwindow
           Gosub activatesourcewindow
           Pop Select : Pop If :Pop If
           Return
         EndIf
       EndIf
    Default
      Gosub intellisense
    End Select
  EndIf
Return

.intellisense:
  ; -- bei delete-key wird ?comWord_Column nicht aktualisiert
  ;log_Print{"lastvankey " + Hex$(last_vankey)}
  If pedconfig\intellisense
    If last_vankey=#VANILLAKEY_BACKSPACE OR (last_vankey>=$20 AND last_vankey <= $7A)
      If ped\ptrCurrentSourceData\Column > 1
        ; -- get everything left of cursor until " " or "=" , ":", "(", "{", ",", "+"    ; check expand to allow the following chars  : ( { , +  too tomsmart1
        If lineaddr.l

          strline$ = Peeks$(lineaddr,ped\ptrCurrentSourceData\Column) : slen.w = FLen(strline$)
          ;log_Print{"intellisense for [" + strline$ +"]"}

          _tokname.s = "" : strhelp$ = "" : sfound.l = False
          While (slen > 0) AND (sfound = False)
            schar$ = Mid$(strline$,slen,1)
            If (schar$ = " ") OR (schar$ = "=") OR (schar$ = ":") OR (schar$ = "(") OR (schar$ = "{") OR (schar$ = ",") OR (schar$ = "+")   ; expand check too allowed this chars : ( { , + too  tomsmart1
              sfound = True
            Else
              _tokname.s = schar$ + _tokname.s
              slen - 1
            EndIf
          Wend
        End If

        Select last_vankey                            ; check for the last pressed key  tomsmart1
          Case $00                                    ; no key  added to support CTRL I update
                                                      ; nothing to do because stokname = stokname
          Case $08 ; DEL key
            _tokname.s = UnLeft$(_tokname.s,1)          ; remove the most right chararter of the string too support the DELETE-KEY  tomsmart1
            Gosub close_popupwindow                   ; added to aviod hits  tomsmart1

         Default                                      ; all other keys
           ;_tokname.s + Chr$(_key)                     ; normal added key to the string
        End Select

        ; -- search for any text that equals entered text
        If (FLen(_tokname.s) > 2)
          CaseSense Off
          ;log_Print{"intellisense, searching for [" + _tokname.s+ "]"}
          poptok$ = Trim$(_tokname.s) : tokenliste$ = "" : popfound.w = 0

          ;-- in Helptext for Functionnames
          If Instr(_tokname.s,"_") > 0
            ResetList HelpIndexCache()
            While NextItemFast(HelpIndexCache())
              If Instr(HelpIndexCache()\name, poptok$) = 1
                pophelp$ = HelpIndexCache()\name + HelpIndexCache()\helpText
                If FLen(pophelp$) > 32
                  pophelp$ = Left$(pophelp$,32) + " ... "
                EndIf
                ; %%1 = green, %%2 = rot, %%3= white, %%4= blue  fuer farben
                tokenliste$ + "%%4" + pophelp$ + Chr$(10)
                popfound + 1
              End If
            Wend
          EndIf

          ; in Commands
          If pedconfig\use_commandsintellisens
            *tokenpointer.l = *tokenbase

            While *tokenpointer
              temptoken.s  = Peek.s(*tokenpointer+6)
              If Instr(temptoken, poptok$) = 1
                pophelp$ = temptoken
                If FLen(pophelp$) > 32
                  pophelp$ = Left$(pophelp$,32) + " ... "
                EndIf
                ; %%1 = green, %%2 = rot, %%3= white, %%4= blue  fuer farben
                tokenliste$ + "%%4" + pophelp$ + Chr$(10)
                popfound + 1
              End If

              *tokenpointer = Peek.l(*tokenpointer)  ; nexttoken
            Wend
          End If
          CaseSense On

          ; -- open list if something found
          If popfound > 0
            WZ_SetPopUpMenu{tokenliste$,1}
            USEPATH sourceWindow
            xpos.w = \WinLeft + \BoxLeft + ped\ptrCurrentSourceData\Column * \font\tf_XSize
            ypos.w = \WinTop  + \BoxTop  + (ped\ptrCurrentSourceData\DisplayLine+1) * \font\tf_YSize + \font\tf_Baseline
            log_Print{"opening popup at " + Str$(xpos) + ", " + Str$(ypos)}
            WZ_PopUp_Nonmodal{xpos,ypos,-1,-1,ped\screen\RastPort}
          Else
            ;log_Print{"nothing found"}
            Gosub close_popupwindow
          EndIf
        Else
          Gosub close_popupwindow             ; added to support DELETE_KEY  tomsmart1
        EndIf
      Else
        Gosub close_popupwindow
      EndIf
      Gosub activatesourcewindow              ; if we change popupwin (open, close, change) so we need to activate sourcewin again  tomsmart1
    EndIf
  EndIf
Return

.scan_source_for_used_libs:
  log_Print{"scan source for used libs..."}
  If ped\ptrCurrentSourceData\TotalLines = 0 Then Return

  PED_SetPointerBusy{}

  Use Window WZID("WIN_LABELS")

  ; --
  ; -- reset tables and arrays
  Dim usedTokensTable.b(65535)
  For i.l = 0 To 65535
    usedTokensTable(i) = 0
  Next i
  HIERARCHY_Clear{&list_usedBlitzLibs}
  WZPrint "LIBRARY_LIST",0,list_usedBlitzLibs

  ; --
  ; -- scanning each line for tokens
  WZ_ShowMessage{!TRANS{"Analyzing source..."},0}

  scanned_lines.l = 0
  *sourceLine.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
  _token.l = 0 
  While *sourceLine
    ptrString.l = *sourceLine + 9
    ped\inString = 0
    skip_rest_of_line.b = False
    Repeat
      curchar.b = Peek.b(ptrString)

      If curchar = $22 Then ped\inString = NOT ped\inString
      If curchar = @";" AND NOT ped\inString Then skip_rest_of_line = True
      If curchar < 0 AND NOT ped\inString
        _token.l = Peek.w(ptrString) AND $FFFF
        If _token > $8000 Then _token - $8000
        usedTokensTable(_token) = usedTokensTable(_token) + 1
        ptrString + 1
      EndIf

      ptrString + 1
    Until skip_rest_of_line OR curchar = 0

    If (scanned_lines MOD 10) = 0 Then !WZ_Update_Gauge{scanned_lines, ped\ptrCurrentSourceData\TotalLines}
    
    scanned_lines = scanned_lines + 1
    
    *sourceLine = *sourceLine\nextLine
  Wend

  ;-- build hierarchy tree
  log_Print{Str$(scanned_lines) + " lines scanned, building result tree..."}
  WZ_ShowMessage{!TRANS{"Building result tree..."}, 0}

  For _token = 0 To 65535
    If usedTokensTable(_token)
      tokenName.s = PED_GetTokenName{_token}
      If tokenName <> ""
        libNum.l = _token LSR 7
        libName.s = blitzlibMapping(libNum, 0)
        entry.s = tokenName + " (" + Str$(usedTokensTable(_token) AND $FF) + ")"

        If libName <> ""
          main.s = libName
          child.s= entry
          pid.l = HIERARCHY_GetParentID{main}
          If pid > 0
            HIERARCHY_AddChild{pid,child}
          Else
            HIERARCHY_AddParent{&list_usedBlitzLibs, main}
            If child <> ""
              pid.l = HIERARCHY_GetParentID{main}
              If pid <> 0 Then HIERARCHY_AddChild{pid, child}
            EndIf
          EndIf
        Else
          HIERARCHY_AddParent{&list_usedBlitzLibs, entry}
        EndIf
      EndIf
    EndIf
    If (_token MOD 1024) = 0 Then !WZ_Update_Gauge{_token,65535}
  Next _token
  ;
  WZ_HideMessage{}

  Use Window WZID("WIN_LABELS")
  WZPrint "LIBRARY_LIST",0,list_usedBlitzLibs

  PED_SetPointerNormal{}
Return

.deleteCharFromTextbuffer:
  ped\ptrCurrentSourceData\StoreColumn = ped\ptrCurrentSourceData\Column

  lineaddr.l = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset
  actualColumn.w =  ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset
  For cupos.w = actualColumn + 1 To #MAX_Columns-1
    Poke.b lineaddr + cupos - 1, Peek.b(lineaddr + cupos)
  Next cupos
  Poke.b lineaddr + #MAX_Columns-1, $20 ; add space at the end (overwriting last character)

  ;-- check for "" in line and prevent parsing of instructions
  ped\ptrCurrentSourceData\Column = \visibleColumns - 1
  newcol.w = \visibleColumns + ped\ptrCurrentSourceData\ColumnsOffset - 1
  quotation.b = 0
  For cupos.w = newcol To 0 Step -1
    If Peek.b(lineaddr + cupos) = $22 Then quotation + 1
  Next cupos

  ;-- show character that comes visible at the right if line is longer than visiblecolumns
  If NOT (quotation AND 1) 
    PED_PrintChar{Peek.b(lineaddr + newcol),1}
  Else
    PED_PrintChar{Peek.b(lineaddr + newcol)}  
  EndIf

  ped\ptrCurrentSourceData\Column = ped\ptrCurrentSourceData\StoreColumn
Return

.updateSourceLine:        ; CursorXTarget: new Cursorposition
  log_Print{"update sourceline and moving cursor to x:" + Str$(CursorXTarget)}
  PED_CursorOff{}

  ped\ptrCurrentSourceData\StoreColumn = ped\ptrCurrentSourceData\Column
  lineaddr.l = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset 
  lineaddr   + ped\ptrCurrentSourceData\ColumnsOffset
  For ped\ptrCurrentSourceData\Column = 0 To \visibleColumns - 1
    enteredChar.b = Peek.b(lineaddr + ped\ptrCurrentSourceData\Column)
    PED_PrintChar{enteredChar}
  Next
  ped\ptrCurrentSourceData\Column = ped\ptrCurrentSourceData\StoreColumn

  PED_MoveCursorToX{CursorXTarget}

  PED_CursorOn{}
Return


.deletekey:
  log_Print{"deletekey"}

  ped\blockmarkRemovalMode = 2
  ped\ptrCurrentSourceData\KeyBeforeReturn = last_vankey

  ; -- scroll to left by 1
  PED_CursorOff{}
  PED_ScrollHorizontal{#SCROLL_LEFT,  #SCROLL_CURRENT_LINE}
  PED_UpdateStatusArea{#STATUS_SCROLLERS|#STATUS_CURSOR}
  Gosub deleteCharFromTextbuffer
  PED_CursorOn{}

  ; -- check if shift is pressed as well
  If ped\ptrCurrentSourceData\Column > 0 OR ped\ptrCurrentSourceData\ColumnsOffset > 0
    If mqualifier AND #IEQUALIFIER_LSHIFT
      ;log_Print{"shift"}
      If delete_mode.l = #VANILLAKEY_BACKSPACE
        If ped\ptrCurrentSourceData\Column > 0
          ped\ptrCurrentSourceData\Column - 1
          Goto deletekey
        EndIf
        If ped\ptrCurrentSourceData\ColumnsOffset > 0
          ped\ptrCurrentSourceData\ColumnsOffset - 1
          Goto deletekey
        EndIf
      EndIf
    Else
      Return
    EndIf
  EndIf
Return


.handle_event_newsizewindow:
  log_Print{"handle newsizewindow"}
  sourceWindow\WinTop = sourceWindow\win\TopEdge
  sourceWindow\WinLeft = sourceWindow\win\LeftEdge

  ;-- update only if mousebutton has been released
  If pedMessage\_Qualifier <> #IEQUALIFIER_RELATIVEMOUSE|#IEQUALIFIER_LEFTBUTTON
    sourceWindow\WinWidth = sourceWindow\win\Width
    sourceWindow\WinHeight = sourceWindow\win\Height
    Gosub resize_sourcewindow
  EndIf
Return

.resize_sourcewindow:
  Gosub calc_SourceWindowDimensions
  Gosub allocate_textbuffer
  Gosub clear_sourcewindow
  PED_RedrawSource{}
Return


.eventHandler:
  pedEventClass.l = PED_GetIntuiMessage{True}

  ;If (pedMessage\_Class <> #IDCMP_INTUITICKS) AND (pedMessage\_Class <> #IDCMP_MOUSEMOVE)
  ;  If pedMessage\_Class = #IDCMP_RAWKEY Then log_Print{"RAWKEY"}
  ;  If pedMessage\_Class = #IDCMP_VANILLAKEY Then log_Print{"VANILLAKEY"}
  ;  log_Print{"eventmessage: " + Hex$(pedMessage\_Class) + ", quali " + Hexw$(pedMessage\_Qualifier) + ", code " + Hexw$(pedMessage\_Code)}
  ;  log_Print{"window: " + Str$(pedMessage\_Window) + "  MouseX:"  + Str$(pedMessage\_MouseX)}
  ;End If

  ;-- context onlinehelp for most windows
  If pedconfig\onlinehelp <> 0
    If (pedMessage\_Class <> #IDCMP_INTUITICKS) AND (pedMessage\_Class <> #IDCMP_ACTIVEWINDOW) AND (pedMessage\_Class <> #IDCMP_GADGETHELP)  AND (pedMessage\_Class <> #IDCMP_CHANGEWINDOW)
      WZ_HideBubble{}
    EndIf
    If pedMessage\_Class = #IDCMP_GADGETHELP Then WZ_ShowBubble{}
  EndIf

  ;-- Menu handling is for all windows
  If pedMessage\_Class = #IDCMP_MENUPICK
    Gosub handle_event_menupick
    exit_eventloop = True
  Else
    Use Window pedMessage\_Window
    Select pedMessage\_Window
      Case 0                              : Gosub event_sourcewindow
      Case WZID("WIN_SEARCH")             : Gosub event_find
      Case WZID("WIN_CONTEXTHELP")        : If pedMessage\_Class = #IDCMP_CLOSEWINDOW Then Gosub close_contexthelp
      Case WZID("WIN_NEWTYPE")            : Gosub event_definitionbrowser
      Case WZID("WIN_INSTRUCTIONBROWSER") : Gosub event_instructionbrowser
      Case WZID("WIN_LIBRARYBROWSER")     : Gosub event_librarybrowser
      Case WZID("WIN_LABELS")             : Gosub event_sourcebrowser
      Case WZID("WIN_POPUP")              : Gosub event_popup
      Case WZID("WIN_HELPDIAG")           : Gosub event_helpdiag
      Case WZID("WIN_SHORTCUTS")          : Gosub event_shortcuts
    Default
      error{"received message from unknown window [" + Str$(pedMessage\_Window) + "]"}
    End Select
  EndIf

  ;-- handle Arexx events
  CNIF #USE_AREXX = 1
    If arexx_GetMsg{True} Then Gosub arexx_event
  CEND

  ;-- check if a compiled program is running
  If ped\ptrCurrentSourceData\RunningFlag <> 0
    PED_ShowMessage{!TRANS{"!!!PROGRAM IS RUNNING: ONLY SAVE/NAVIGATION/HELP WILL WORK..."}}
    rf.l = 1
  Else
    If rf = 1 AND ped\ptrCurrentSourceData\RunningFlag = 0
      PED_ShowMessage{""}
      rf = 0
    End If
  EndIf
Return


.set_tedlibbase:
  TEDSetJumpTable  {?COMDATABASE}
  TEDSetFirstLine  {?comPtr_FirstSourceLine}
  TEDSetCurrentLine{?comPtr_CurrentSourceLine}
  TEDSetLabelList  {?comPtr_LabelList}
  TEDSetLabelCount {?comWord_LabelCounter}
Return


.update_debuggertoggle:
  ped\debugMode = Peek.b(?comByte_DebugMode)
  GTSetMenuChecked 0,4,12,ped\debugMode
  ;log_Print{"updated Debugstatus: " + Str$(ped\debugMode)}
Return


.event_sourcewindow:
  exit_loop_class.b = 0

  last_vankey.b = 0
  ped\ptrCurrentSourceData\QualifierStore = 0

  Select pedMessage\_Class
  Case #IDCMP_INTUITICKS
    Gosub handle_event_intuiticks

  Case #IDCMP_REFRESHWINDOW
    Gosub handle_event_newsizewindow

  Case #IDCMP_NEWSIZE
    Gosub handle_event_newsizewindow

  Case #IDCMP_CHANGEWINDOW
    Gosub handle_event_newsizewindow

  Case #IDCMP_ACTIVEWINDOW
    Use Window 0
    PED_CursorOn{}

  Case #IDCMP_INACTIVEWINDOW
    PED_CursorOff{}

  Case #IDCMP_GADGETDOWN
    Gosub handle_event_gadget

  Case #IDCMP_GADGETUP
    ;*gadget.Gadget = pedMessage\_IAddress
    ;log_Print{"GADGETUP"}
    ;log_Print{"GadgetID " + Str$(*gadget\GadgetID) + ", Type " + Hex$(*gadget\GadgetType) + ", Activation " + Hex$(*gadget\Activation)}
    ;log_Print{"byte type " + Str$(*gadget\GadgetType AND $00FF)}

  Case #IDCMP_MENUVERIFY
    ;-- do nothing atm

  Case #IDCMP_CLOSEWINDOW
    _menuitem = #MENU_CLOSE : Gosub event_menu

  Case #IDCMP_MOUSEBUTTONS
    Gosub handle_event_mousebuttons

  Case #IDCMP_RAWKEY
    Gosub convert_to_vanillakeys

  Case #IDCMP_VANILLAKEY
    Gosub handle_event_vanillakey

  Case #IDCMP_EXTENDEDMOUSE
    Gosub handle_event_extendedmouse

  Case #IDCMP_MOUSEMOVE
    Gosub handle_event_mousemove

  End Select
Return

.handle_event_intuiticks:
  ; ------------ cursor blinking
  blinkcount.b + 1
  If pedconfig\blinkrate > 0 AND sourceWindow\cursorEnabled
    If blinkcount >= pedconfig\blinkrate
      blinkcount = 0
      PED_SwitchCursor{}
    EndIf
  EndIf
 
  ; ---------------------------------
  If pedconfig\onlinehelp_extended AND pedMessage <> 0
    ; -- wait for at least 1 second before displaying the context
    help_ticks.b + 1 : If help_ticks < 10 Goto skip_this

    USEPATH sourceWindow

    mx.w = pedMessage\_MouseX - \win\BorderLeft
    my.w = pedMessage\_MouseY - \win\BorderTop

    If mx < 0 Then Goto skip_this
    If my < 0 Then Goto skip_this

    ; -- check statusArea
    If my - \statusAreaY > 0
      If mx = omx.w AND my = omy.w Then Goto skip_this
      omx = mx : omy = my
      xsa.l = \font\tf_XSize / 2
      xpos_start.w = #leftoffset * \font\tf_XSize - xsa
      xpos_end.w = 0
      ypos_start.w = \statusAreaY + 1
      ypos_end.w = ypos_start + 2 + \font\tf_Baseline + \font\tf_YSize

      *fileEntry.sourceEntry = ped\firstSourceEntry
      Repeat
        xpos_end = xpos_start + (#bevelsize * \font\tf_XSize)
        ;-- check click position
        If (mx > xpos_start) AND (mx < xpos_end) AND (my > ypos_start) AND (my < ypos_end)
          msg$ = dos_AddPart{Peek.s(&*fileEntry\SourceDir), Peek.s(&*fileEntry\SourceName)}
          ;log_Print{"mouse hovered tab: " + msg$}
          WZ_ShowBubble{msg$}
          Pop If : Pop Repeat : Goto skip_this
        EndIf
        xpos_start = xpos_end
        *fileEntry = *fileEntry\nextEntry
      Until *fileEntry = 0      
    EndIf

    ; -- check sourcearea
    If pedMessage\_MouseX - \win\BorderRight - \win\Width > 0 Then Goto skip_this
    If (pedMessage\_MouseX = ocmousex.w) AND (pedMessage\_MouseY = ocmousey.w) Then Goto skip_this

    ;log_Print{"checking context help"}
    ; -- check mouseposition in source area
    textX.w = (mx - \BoxLeft) / \font\tf_XSize + ped\ptrCurrentSourceData\ColumnsOffset + 1
    textY.w = (my - \BoxTop) / \font\tf_YSize + ped\ptrCurrentSourceData\DisplayLineOffset + 1

    If textX = otextX.w AND textY = otextY.w Then Goto skip_this
    otextX = textX : otextY = textY

    ; -- get the currentsourceline and move to mouse cursor-line
    actualLine.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine + 1
    *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
    delta.w = textY - actualLine
    If (delta <= ped\ptrCurrentSourceData\TotalLines) AND (actualLine + delta > 0)
      If delta > 0
        For si.w = 1 To delta
          If *tempLine\nextLine Then *tempLine = *tempLine\nextLine
        Next si
      Else
        If delta < 0
          For si.w = -1 To delta Step -1
            If *tempLine\previousLine Then *tempLine = *tempLine\previousLine
          Next si
        EndIf
      EndIf

      ; -- check out the help and display it
      If *tempLine
        strline$ = PED_Detokenize{*tempLine}
        helptext$ = PED_GetWordAtPos{strline$,textX, True}
        If helptext$ <> ""
          helpvalue.l = 0 : msg$ = ""
          ;-- check for a constant
          If Left$(helptext$,1) = "#"
            helptext$ = UnRight$(helptext$,1)
            helpvalue = PED_GetConstantValue{helptext$}
          Else
            ;-- check for a newtype
            *var.l = PED_GetVariableByName{helptext$}
          EndIf
          ;            $45464748
          ;PED_ShowMessage{helptext$}
          If helpvalue = 0 Then helpvalue = Vallong(helptext$)
          If helpvalue <> 0
            msg$ = helptext$
            ;log_Print{ Str$(helpvalue) }
            helpvaluestr.s = Str$(helpvalue)
            msg$ + Chr$(10) + Chr$(10) + "# " + helpvaluestr
            msg$ + Chr$(10) + "$ " + Hex$(helpvalue)
            msg$ + Chr$(10) + "% " + Bin$(helpvalue)
            msg$ + Chr$(10) + Mkl$(helpvalue)
          Else
            If *var
              msg$ = helptext$
              msg$ + Chr$(10) + Chr$(10) + "(variable) " + PED_GetNewtypeOf{helptext$}
            EndIf
          EndIf
          If msg$ <> ""
            log_Print{"showing context help: " + msg$}
            WZ_ShowBubble{msg$}
          Else
            WZ_HideBubble{}
          EndIf
          help_ticks = 0
          ocmousex.w = pedMessage\_MouseX : ocmousey.w = pedMessage\_MouseY
        EndIf
      EndIf
    EndIf
    skip_this:
    ;log_Print{"check context end"}
  EndIf
Return

.handle_event_menupick:
  log_Print{"handle_event_menupick - selected menuitem: " + Hex$(_menuitem.l)}
  If pedMessage\_Code <> -1
    _menuNumber.w = pedMessage\_Code
    _ItemAddress.l = ItemAddress_(ped\menuStrip,_menuNumber AND #MaxWord)
    _menuitem.l = Peek.l(_ItemAddress + $22)             ; Userdata of GadTools, longword right after MenuItem-struct
    exit_loop_class.b = -2
    exit_eventloop.b = True
  EndIf
Return

.handle_event_gadget:
   *gadget.Gadget = pedMessage\_IAddress

    exit_gadgetloop.b = False
    ;log_Print{"GADGETDOWN " + Hex$(pedMessage\_Class)}
    ;log_Print{"GadgetID " + Str$(*gadget\GadgetID) + ", Type " + Hex$(*gadget\GadgetType) + ", Activation " + Hex$(*gadget\Activation)}
    ;log_Print{"byte type " + Str$(*gadget\GadgetType AND $00FF)}

    Select *gadget\GadgetID
    Case #GID_UARROW: last_vankey = $1C : Gosub handle_event_vanillakey
    Case #GID_DARROW: last_vankey = $1D : Gosub handle_event_vanillakey
    Case #GID_RARROW: last_vankey = $1E : Gosub handle_event_vanillakey
    Case #GID_LARROW: last_vankey = $1F : Gosub handle_event_vanillakey
    Case #GID_XPROP
      DEFTYPE.l pos_hprop
      FlushEvents
      Repeat
        If pedMessage\_Class <> 0
          If pedMessage\_Class <> #IDCMP_GADGETUP
            GetAttr_ #PGA_Top, sourceWindow\horizprop, &pos_hprop                                                                                                                                                                                        
            PED_MoveCursorToX{pos_hprop}                                                                                                                                                                                                  
          Else
            *g.Gadget = pedMessage\_IAddress
            ;If pedMessage\_Class = #IDCMP_GADGETUP AND pedMessage\_Code <> 0 OR pedMessage\_Window<>0
            If *g\GadgetID = #GID_XPROP  Then exit_gadgetloop = True
          EndIf
        EndIf
        PED_GetIntuiMessage{False}
      Until exit_gadgetloop = True

    Case #GID_YPROP
      ;-- maybe triggered by a wheel up/down event of WinUAE
      If ped\ptrCurrentSourceData\DisplayLineOffset < ped\ptrCurrentSourceData\TotalLines
        
        tmpCurrentline.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine

        Repeat
          If pedMessage\_Class <> 0
            *g.Gadget = pedMessage\_IAddress

            If pedMessage\_Class <> #IDCMP_GADGETUP
              GetAttr_ #PGA_Top,sourceWindow\vertiprop, &slider_top.l
              totallines.l = ped\ptrCurrentSourceData\TotalLines
              If totallines >= #max_slider_res
                !mul48f{slider_top,totallines,#max_slider_res,realline.l}
              Else
                realline = slider_top
              EndIf
              realline + ped\ptrCurrentSourceData\DisplayLine

              If realline <> tmpCurrentline
                ped\ptrCurrentSourceData\LinePosStartX = realline
                PED_GotoLine{realline}
                PED_UpdateStatusArea{#STATUS_CURSOR|#STATUS_SCROLLERS}
              EndIf

              ;If pedMessage\_Class = #IDCMP_RAWKEY Then exit_gadgetloop = True
              If pedMessage\_Class = #IDCMP_MOUSEBUTTONS Then exit_gadgetloop = True
            Else
              ; cannot check For GadgetID because of tools like FreeWheel, I do not get the correct GadgetID everytime !?
              If *g\GadgetID = #GID_YPROP AND pedMessage\_Class = #IDCMP_GADGETUP Then exit_gadgetloop = True
            EndIf
            ;log_Print{"YPROP " + Hex$(pedMessage\_Class) + " " + Hexw$(pedMessage\_Code) + " " + Str$(pedMessage\_Window) + "  GadID: " + Str$(*g\GadgetID)}
            ;log_Print{"IAddress: " +Str$(pedMessage\_IAddress) + "  type: " + Hex$(*g\GadgetType) + " x:" + Str$(*g\LeftEdge) + ", y:" + Str$(*g\TopEdge)}
          EndIf
          PED_GetIntuiMessage{False}
        Until exit_gadgetloop = True
        
        ;log_Print{"exit proploop"}
      EndIf
    End Select
Return


.handle_event_mousebuttons:
  ;log_Print{"handle event mousebuttons..."}

  ;-- handle mouse actions in source
  Select pedMessage\_Code
  Case #SELECTUP
    ;log_Print{"Mouse-Event SELECTUP",#log_debug}
    If was_selectdown_before.b = True
      was_selectdown_before = False
    EndIf

  Case #SELECTDOWN
    ;log_Print{"Mouse-Event SELECTDOWN",#log_debug}

    ;-- handle mouse actions in status area
    If NOT ped\ptrCurrentSourceData\RunningFlag            
      ; only available when no exe is running  
      If pedMessage\_MouseY - \win\BorderTop > \statusAreaY + 1
        Gosub check_mouse_in_statusarea
        Pop Select
        Return
      EndIf
    EndIf

    was_selectdown_before.b = True
    exit_loop_class = -3

    ;-- left mb not pressed anymore, check doubleclick
    isDoubleClick.b = DoubleClick_(SSeconds.l,SMicros.l,pedMessage\_Seconds,pedMessage\_Micros)
    SSeconds = pedMessage\_Seconds
    SMicros = pedMessage\_Micros
    If pedMessage\_MouseX = Mmx.w AND pedMessage\_MouseY = Mmy.w Then isSameMousePosition.b = True Else isSameMousePosition = False
    Mmx = pedMessage\_MouseX
    Mmy = pedMessage\_MouseY
    If isDoubleClick AND isSameMousePosition
      strline$ = PED_Detokenize{ped\ptrCurrentSourceData\CurrentSourceLine}
      actualword$ = PED_GetWordAtPos{strline$, ped\ptrCurrentSourceData\Column,True}
      log_Print{"doubleclick on ==>" + actualword$}
      If WZ_IsOpen{"WIN_LABELS"}
        LabelListSearchString = StripLead$(LCase$(actualword$),32)
        If Left$(LabelListSearchString,1)="." Then LabelListSearchString = UnRight$(LabelListSearchString,1)
        Use Window WZID("WIN_LABELS")
        WZPrint "STRING_LABEL",LabelListSearchString
        Gosub reset_labellist
      EndIf
    Else
      exit_eventloop = True
    EndIf

  Case #MIDDLEDOWN
    log_Print{"Mouse-Event MIDDLEDOWN",#log_debug}
    If NOT pedMessage\_Qualifier AND #IEQUALIFIER_LALT
      Gosub jump_historyup
    EndIf
  End Select
Return


.check_mouse_in_statusarea:
  USEPATH sourceWindow
  If ped\firstSourceEntry
    mx.w = pedMessage\_MouseX - \win\BorderLeft
    my.w = pedMessage\_MouseY - \win\BorderTop

    xsa.l = \font\tf_XSize / 2
    xpos_start.w = #leftoffset * \font\tf_XSize - xsa
    xpos_end.w = 0
    ypos_start.w = \statusAreaY + 1
    ypos_end.w = ypos_start + 2 + \font\tf_Baseline + \font\tf_YSize

    ;-- check if a tab is clicked on
    *fileEntry.sourceEntry = ped\firstSourceEntry
    Repeat
      xpos_end = xpos_start + (#bevelsize * \font\tf_XSize)
      If (mx > xpos_start) AND (mx < xpos_end) AND (my > ypos_start) AND (my < ypos_end)
        Gosub handle_statusareaactions
        Pop Repeat
      EndIf
      xpos_start = xpos_end

      *fileEntry = *fileEntry\nextEntry
    Until *fileEntry = 0
  EndIf
Return


.handle_statusareaactions:
  log_Print{"mouse clicked at tab: " + dos_AddPart{Peek.s(&*fileEntry\SourceDir), Peek.s(&*fileEntry\SourceName)}}
  If *fileEntry = ped\currentSourceEntry
    log_Print{"tab is actual file"}
    _menuitem = 0
    If pedMessage\_Qualifier AND #IEQUALIFIER_CONTROL
      log_Print{"control: create exe"}
      _menuitem = #MENU_SAVECREATEEXE
    EndIf
    If pedMessage\_Qualifier AND #IEQUALIFIER_LALT
      log_Print{"alt: compile & run"}
      _menuitem = #MENU_COMPILERUN
    EndIf
    If _menuitem
      If ped\ptrCurrentSourceData\SourceChanged
        Gosub storeline
        Delay_ 2
      EndIf               
      Gosub call_compilermenuitem
    EndIf
  Else
    log_Print{"tab is not actual file."}
    Gosub storeline

    GetD0 *fileEntry : Gosub selectTab

;    Gosub storeCurrentSourceData
    log_Print{"switch tab done"}
  EndIf
Return



.convert_to_vanillakeys:
  ;log_Print{"========= rawkey    code: "+ Hexw$(pedMessage\_Code) + " / quali: " + Hex$(mqualifier)}
  
  Select pedMessage\_Code
  ;-- check for Mousewheel Rawkey events from newmouse definition
  Case #NM_WHEEL_DOWN
    log_Print{"wheel down"}
    Gosub wheel_down

  Case #NM_WHEEL_UP
    log_Print{"wheel up"}
    Gosub wheel_up

  ;-- HELP / TAB / RETURN 
  Case #RAWKEY_HELP
    last_vankey = #VANILLAKEY_HELP
  
  Case #RAWKEY_TAB
    last_vankey = #VANILLAKEY_TAB
  
  Case #RAWKEY_RETURN
    last_vankey = #VANILLAKEY_RETURN

  ;-- check for F-Keys / CURSOR / or RAWKEY events provided by FreeWheel to map mouse wheel events to keys
  Default
    If (pedMessage\_Code => #RAWKEY_F1) AND (pedMessage\_Code <= #RAWKEY_F10)
      last_vankey = pedMessage\_Code + $31 ; convert F-KEYs to vanillakey
    Else If (pedMessage\_Code => #RAWKEY_UP) AND (pedMessage\_Code <= #RAWKEY_LEFT)
        last_vankey = pedMessage\_Code - $30
      EndIf
    EndIf
  End Select

  If last_vankey <> 0 Then Gosub handle_event_vanillakey
Return

.handle_event_vanillakey:
  mqualifier.w  = pedMessage\_Qualifier 
  ;-- remove some unnecessary qualifiers
  If (mqualifier AND #IEQUALIFIER_RELATIVEMOUSE) Then mqualifier = mqualifier AND (NOT #IEQUALIFIER_RELATIVEMOUSE)
  If (mqualifier AND #IEQUALIFIER_CAPSLOCK) Then mqualifier = mqualifier & (NOT #IEQUALIFIER_CAPSLOCK)
  ;-- convert right qualifiers to left qualifiers
  If (mqualifier AND #IEQUALIFIER_RSHIFT) Then mqualifier = (mqualifier & (NOT #IEQUALIFIER_RSHIFT)) | #IEQUALIFIER_LSHIFT
  If (mqualifier AND #IEQUALIFIER_RALT) Then mqualifier = (mqualifier & (NOT #IEQUALIFIER_RALT)) | #IEQUALIFIER_LALT  
  ped\ptrCurrentSourceData\QualifierStore = mqualifier

  If last_vankey = 0 Then last_vankey = pedMessage\_Code
  ;log_Print{"event vanillakey: " + Hexw$(last_vankey) + " qualifier: " + Hexw$(mqualifier)}

  ;-- check key first
  Select last_vankey

  Case #VANILLAKEY_RETURN
    ;Gosub immediate_syntaxhelp
    exit_eventloop.b = True
    Pop Select: Return

  Case #VANILLAKEY_UP       ; ---------------------------------------------------------------- Cursor Up
    exit_eventloop.b = True
    Pop Select : Return

  Case #VANILLAKEY_DOWN    ; ------------------------------------------------------------------------------------- Cursor Down
    exit_eventloop.b = True
    Pop Select: Return

  Case #VANILLAKEY_HELP
    Select mqualifier
    Case #IEQUALIFIER_CONTROL
      Gosub open_helpdiag

    Case #IEQUALIFIER_LSHIFT
      Gosub helpOnToken

    Default
      Gosub immediate_syntaxhelp
    End Select
    Pop Select: Return

  Case #VANILLAKEY_ESC
    Gosub close_contexthelp
    Gosub close_popupwindow
    Pop Select: Return

  Case #VANILLAKEY_DELETE
    Gosub do_VANILLAKEY_DELETE
    Pop Select : Return

  Case #VANILLAKEY_BACKSPACE
    Gosub do_VANILLAKEY_BACKSPACE
    Pop Select : Return

  Case #VANILLAKEY_TAB
    Gosub do_VANILLAKEY_TAB
    Pop Select : Return

  Case #VANILLAKEY_LEFT         ; -------------------------------------------------------------- Cursor Left
    Select mqualifier
    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL    ; $800A: select block right
      log_Print{"shift + control"}
      Gosub selectblockleft

    Case #IEQUALIFIER_LSHIFT          ; move cursor to beginning of line
      ;log_Print{"shift"}
      Gosub moveCursorToBeginOfLine

    Case #IEQUALIFIER_LALT
      log_Print{"alt"}
      Gosub jump_historyup

    Case #IEQUALIFIER_CONTROL                   ; ctrl
      log_Print{"control"}
      If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
        PED_CursorOff{}
        Gosub menu_blockuntab
      Else
        Gosub moveCursorToBeginOfWord        
      EndIf

    Default
      ;log_Print{"no qualifier key"}
      ped\blockmarkRemovalMode = 1
      PED_MoveCursorLeft{}
    End Select
    PED_UpdateStatusArea{#STATUS_SCROLLERS}

    Pop Select: Return

  Case #VANILLAKEY_RIGHT            ; ----------------------------------------------------------------------- Cursor Right

    Select mqualifier
    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL    ; $800A: select block right
      log_Print{"shift + control "}
      Gosub selectblockright

    Case #IEQUALIFIER_LSHIFT         ; move to end of line
      ;log_Print{"shift"}
      Gosub moveCursorToEndOfLine

    Case #IEQUALIFIER_LALT           ; move in history
      log_Print{"alt"}
      Gosub jump_historydown

    Case #IEQUALIFIER_CONTROL        ; tab the marked block
      log_Print{"control"}
      If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
        PED_CursorOff{}
        Gosub menu_blocktab
      Else
        Gosub moveCursorToEndOfWord
      EndIf

    Default
      ped\blockmarkRemovalMode = 1
      PED_MoveCursorRight{}

    End Select

    PED_UpdateStatusArea{#STATUS_SCROLLERS}
    Pop Select : Return

  End Select

  ;----------------------------------- check QUALIFIER first

  Select mqualifier
  Case #IEQUALIFIER_CONTROL         ; CTRL   ---------------------------------------------------------------------------------------
    log_Print{"CONTROL + $" + Hexb$(last_vankey)}
    Select last_vankey
    Case $15                        ; ctrl-u
      PED_RedrawSource{}

    Case $0e                        ; ctrl-n
      PED_InsertStringToTextBuffer{"newtype ."}
      PED_InsertReturn{2}
      PED_InsertStringToTextBuffer{"end newtype "}
      PED_InsertReturn{}

    Case $06                        ; ctrl-f
      PED_InsertStringToTextBuffer{"function.l { }"}
      PED_InsertReturn{2}
      PED_InsertStringToTextBuffer{"function return 0"}
      PED_InsertReturn{}
      PED_InsertStringToTextBuffer{"end function "}
      PED_InsertReturn{}
    
    Case $13                        ; ctrl-s
      PED_InsertStringToTextBuffer{"statement { }"}
      PED_InsertReturn{2}
      PED_InsertStringToTextBuffer{"end statement "}
      PED_InsertReturn{}

    Case $05                        ; ctrl-e
      PED_InsertStringToTextBuffer{"end if "}
      PED_InsertReturn{}
    
    Case $03                        ; ctrl-c
      ped\verticalCopyMode = True    ; set it for column copy
      Gosub menu_copy                         ; do normal copy
      ped\verticalCopyMode = False   ; set it to normal copy

    Case $16                        ; ctrl-v
      ped\verticalCopyMode = True   ; for vertical (Column) paste
      Gosub menu_paste                        ; do paste
      ped\verticalCopyMode = False  ; restore it for normal paste

    Case $18                        ; ctrl-x
      Gosub menu_cut

    Case $09                        ; ctrl-i
      log_Print{"toggle intellisense for commands "}
      If pedconfig\use_commandsintellisens
        pedconfig\use_commandsintellisens = False
      Else
        pedconfig\use_commandsintellisens = True
      EndIf
      last_vankey = 0               ; clear Key
      Gosub intellisense            ; update popupwin
    End Select
    exit_eventloop = True

    Pop Select : Return

  Case #IEQUALIFIER_LCOMMAND + #IEQUALIFIER_LSHIFT
    log_Print{"lcommand and lshift"}
    Select last_vankey
    Case $21                                ; check for "L-AMiGA_!", "LEFT AMIGA + SHIFT + 1"
      sourceWindow\bookmarkLine1 = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset

    Case $22                                ; check for "L-AMiGA_!", "LEFT AMIGA + SHIFT + 2"
      sourceWindow\bookmarkLine2 = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset

    Case $23                                ; check for "L-AMiGA_!", "LEFT AMIGA + SHIFT + 3"
      sourceWindow\bookmarkLine3 = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
    End Select

    Pop Select : Return

  Case #IEQUALIFIER_LCOMMAND        ; LAMIGA -----------------------------------------------------------------------------------------------
    log_Print{"LAMIGA"}

    goto_line.l = 0
    Select last_vankey
    Case #VANILLAKEY_F4             ; L-AMIGA-F4
      savewinpref{0} : Gosub write_newprefs
    Case #VANILLAKEY_F5             ; L-AMIGA-F5
      savewinpref{1} : Gosub write_newprefs
    Case #VANILLAKEY_F6             ; L-AMIGA-F6
      savewinpref{2} : Gosub write_newprefs
    Case $61                       ; L-AMIGA-A
      goto_line = sourceWindow\lastEditedLine
    Case $31                       ; L-AMIGA-1
      goto_line = sourceWindow\bookmarkLine1
    Case $32                       ; L-AMIGA-2
      goto_line = sourceWindow\bookmarkLine2
    Case $33                       ; L-AMIGA-3
      goto_line = sourceWindow\bookmarkLine3
    End Select

    If goto_line Then PED_GotoLine{goto_line}
    
    Pop Select : Return
  End Select

  Select last_vankey
  Case #VANILLAKEY_F1               ; F1
    Gosub menu_helpgeneral

  Case #VANILLAKEY_F2               ; check for "F2"
    Gosub menu_helpincludesguide

  Case #VANILLAKEY_F3               ; check for "F3"
    Gosub menu_helpblitzlibs

  Case #VANILLAKEY_F4               ; check for "F4"
    ped\lastLayout = 0
    Gosub load_windowlayouts
    Gosub do_windowlayout

  Case #VANILLAKEY_F5               ; check for "F5"
    ped\lastLayout  = 1
    Gosub load_windowlayouts
    Gosub do_windowlayout

  Case #VANILLAKEY_F6               ; check for "F6"
    ped\lastLayout  = 2
    Gosub load_windowlayouts
    Gosub do_windowlayout

  Case #VANILLAKEY_F7               ; check for "F7"
    Gosub navigate_to_previous_label

  Case #VANILLAKEY_F8               ; check for "F8"
    Gosub navigate_to_next_label

  Case #VANILLAKEY_F9               ; check for "F9"
    Gosub menu_previousfile

  Case #VANILLAKEY_F10              ; check for "F10"
    Gosub menu_nextfile

  Default
    ;log_Print{"no special handling of vanillakey: " + Hexw$(last_vankey) + " *** INSERT CHAR*"}
    PED_InsertCharToTextBuffer{last_vankey}
  End Select
Return


.do_VANILLAKEY_DELETE
  log_Print{"DELETE"}
  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : PED_HandleBlockmark{}
    Return
  EndIf

  Select mqualifier
  Case #IEQUALIFIER_LSHIFT
    log_Print{"SHIFT"}
    ped\ptrCurrentSourceData\KeyBeforeReturn = last_vankey       ; save keycode
    CursorXTarget.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset
    ;-- delete all charecters until end of line (replace with spaces)
    lineaddr.l = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset
    For cupos.w = CursorXTarget To #MAX_Columns-1
      Poke.b lineaddr + cupos, $20
    Next cupos
    Gosub updateSourceLine

  Default
    Gosub deletekey

  End Select
Return

.do_VANILLAKEY_BACKSPACE:
  log_Print{"BACKSPACE"}
  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : PED_HandleBlockmark{}
    Return
  EndIf
  
  If ped\ptrCurrentSourceData\Column > 0 OR ped\ptrCurrentSourceData\ColumnsOffset > 0
    PED_MoveCursorLeft{}
    delete_mode.l = #VANILLAKEY_BACKSPACE
    Gosub deletekey
    delete_mode = 0
  Else
    If ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine > 0
      log_Print{"backspace at line start, so join lines!"}

      Gosub storeline
      PED_MoveCursorUp{}

      ;-- find last character in previous line to set new cursor column
      lineaddr.l = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset
      tempOffset.w = #MAX_Columns - 1
      While Peek.b(lineaddr + tempOffset) = $20 AND tempOffset > -1
        tempOffset - 1
      Wend
      ped\ptrCurrentSourceData\Column = tempOffset + 1

      Gosub menu_joinlines
    EndIf
  EndIf
Return

.do_VANILLAKEY_TAB:
  log_Print{"TAB " + Hexw$(last_vankey)}

  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
    ped\blockmarkRemovalMode = 2 : PED_HandleBlockmark{}
  EndIf

  ped\ptrCurrentSourceData\KeyBeforeReturn = last_vankey

  If pedconfig\tabSize = 0 Then pedconfig\tabSize = 1
  actualColumn.w = ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset

  ;-- TODO: at the moment, "shift+tab" does not generate an event!!
  If mqualifier AND #IEQUALIFIER_LSHIFT
    log_Print{"shift"}
    newColumn.w = actualColumn - pedconfig\tabSize
  Else
    newColumn.w = actualColumn + pedconfig\tabSize
  EndIf
  moveCount.b = newColumn - actualColumn

  ;log_Print{"move " + Str$(moveCount) + "  newColumn: " + Str$(newColumn)}

  If (newColumn < #MAX_Columns) AND (newColumn >= 0)
    ;-- check blockmark
    If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
      ;-- check if cursor is in first blockline and we have to increase the BlockStartX
      actualLine.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine
      If ped\ptrCurrentSourceData\BlockStartY = actualLine
        If ped\ptrCurrentSourceData\BlockStartX > ped\ptrCurrentSourceData\ColumnsOffset + ped\ptrCurrentSourceData\Column
          ped\ptrCurrentSourceData\BlockStartX + moveCount
        EndIf
      EndIf
      ;-- check if cursor is in last blockline and we have to increase the BlockEndX
      If ped\ptrCurrentSourceData\BlockEndY = actualLine
        If ped\ptrCurrentSourceData\BlockEndX > ped\ptrCurrentSourceData\ColumnsOffset + ped\ptrCurrentSourceData\Column
          ped\ptrCurrentSourceData\BlockEndX + moveCount
        EndIf
      EndIf

      ;-- adjust BlockPosition
      If ped\ptrCurrentSourceData\BlockStartX > #MAX_Columns - 1
        ped\ptrCurrentSourceData\BlockStartX = 0
        ped\ptrCurrentSourceData\BlockStartY + 1
        If ped\ptrCurrentSourceData\BlockStartY > ped\ptrCurrentSourceData\BlockEndY
          !PED_ResetBlockflag
          Goto skip_adjustblock
        EndIf
      EndIf

      If ped\ptrCurrentSourceData\BlockEndX > ped\ptrCurrentSourceData\BlockStartX
        ped\ptrCurrentSourceData\BlockEndX = #MAX_Columns-1
        ped\ptrCurrentSourceData\BlockStartY - 1
        If ped\ptrCurrentSourceData\BlockStartY <= ped\ptrCurrentSourceData\BlockEndY
          Goto skip_adjustblock
        Else
          !PED_ResetBlockflag
          Goto skip_adjustblock
        EndIf
      EndIf

      If ped\ptrCurrentSourceData\BlockStartY = ped\ptrCurrentSourceData\BlockEndY
        If ped\ptrCurrentSourceData\BlockEndX <= ped\ptrCurrentSourceData\BlockStartX
          !PED_ResetBlockflag
          Goto skip_adjustblock
        EndIf
      EndIf

      If ped\ptrCurrentSourceData\BlockEndX >= #MAX_Columns
        ped\ptrCurrentSourceData\BlockEndX = #MAX_Columns-1
      EndIf
      skip_adjustblock:
    EndIf

    ;-- move rest of line to right or left
    lineaddr.l = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset
    If moveCount > 0
      For cupos.w = #MAX_Columns-1 To actualColumn Step -1
        Poke.b lineaddr + cupos, Peek.b(lineaddr + cupos - moveCount)
      Next cupos

      ;-- scroll tabSize to right and fill with new space characters
      PED_CursorOff{}
      ped\ptrCurrentSourceData\Column + ped\ptrCurrentSourceData\ColumnsOffset
      For cupos.w = 0 To moveCount - 1
        Poke.b lineaddr + actualColumn + cupos,$20 ; insert space character
        PED_ScrollHorizontal{#SCROLL_RIGHT, #SCROLL_CURRENT_LINE}
        PED_PrintChar{$20}
      Next cupos

      ;-- set new cursor position
      PED_MoveCursorToX{ped\ptrCurrentSourceData\Column + moveCount}
      PED_CursorOn{}
    Else
      ; move characters to left an fill with empty spaces
      For aaa.b = 1 To Abs(moveCount)
        For cupos.w = newColumn To #MAX_Columns-1
          Poke.b lineaddr + cupos, Peek.b(lineaddr + cupos + 1)
        Next cupos
      Next aaa
      For cupos.w = #MAX_Columns-1 + moveCount To #MAX_Columns-1
        Poke.b lineaddr + cupos, $20 ; insert space character
      Next cupos

      ped\ptrCurrentSourceData\Column + moveCount
      CursorXTarget.w = ped\ptrCurrentSourceData\Column : Gosub updateSourceLine

    EndIf
    ;log_Print{Peeks$(lineaddr, 30)}
  EndIf
Return



.do_VANILLAKEY_UP:
    ; remove REPEAT qualifier
    mqualifier = mqualifier & (NOT #IEQUALIFIER_REPEAT)

    Select mqualifier
    Case 0                     ; $8000 (cursor up)
      ped\blockmarkRemovalMode = 1
      PED_MoveCursorUp{}

    Case #IEQUALIFIER_LSHIFT   ; $8001
      log_Print{"shift"}
      actualLine.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine
      actualLine - sourceWindow\visibleLines
      If actualLine < 0 Then actualLine = 0
      PED_GotoLine{actualLine}

    Case #IEQUALIFIER_CONTROL  ; $8008
      log_Print{"control"}
      Gosub menu_top

    Case #IEQUALIFIER_LALT     ; $8010
      log_Print{"alt"}
      Gosub movelineup

    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL ; $8009
      log_Print{"shift + control"}
      Gosub selectblockup

    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_LALT    ; $800A: select block upwarts
      log_Print{"shift + alt"}
      Gosub selectblockup

    Default
      log_Print{"unknown shortcut at vanilla down"}
    End Select
Return

.do_VANILLAKEY_DOWN:
    ;-- remove REPEAT qualifier
    mqualifier = mqualifier & (NOT #IEQUALIFIER_REPEAT); remove "pressing" flag

    Select mqualifier
    Case 0                     ; $8000: cursor down
      ped\blockmarkRemovalMode = 1
      PED_MoveCursorDown{}
      
    Case #IEQUALIFIER_LSHIFT   ; $8001: page down
      log_Print{"shift"}
      actualLine.l = ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine
      actualLine + sourceWindow\visibleLines
      If actualLine > ped\ptrCurrentSourceData\TotalLines Then actualLine = ped\ptrCurrentSourceData\TotalLines
      PED_GotoLine{actualLine}

    Case #IEQUALIFIER_CONTROL  ; $8008: jump to bottomline
      log_Print{"control"}
      Gosub menu_bottom

    Case #IEQUALIFIER_LALT     ; $8010: move current line down
      log_Print{"alt"}
      Gosub movelinedown

    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_CONTROL  ; $8009: select block downwarts
      log_Print{"shift + control: selectblockdown"}
      Gosub selectblockdown

    Case #IEQUALIFIER_LSHIFT + #IEQUALIFIER_LALT     ; $800A: select block downwarts
      log_Print{"shift + alt: selectblockdown"}
      Gosub selectblockdown

    Default
      log_Print{"unknown shortcut at vanilla up"}
    End Select
Return


.wheel_down:
  Gosub storeline
  log_Print{"wheel down"}
  If ped\ptrCurrentSourceData\DisplayLineOffset > 0 
    PED_GotoLine{ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine + pedconfig\wheelStep}
  Else
    If ped\ptrCurrentSourceData\DisplayLine + pedconfig\wheelStep < ped\ptrCurrentSourceData\TotalLines
      PED_CursorOff{}
      ped\ptrCurrentSourceData\DisplayLine + pedconfig\wheelStep
      PED_CursorOn{}
    EndIf
  EndIf

  PED_UpdateStatusArea{#STATUS_SCROLLERS}
Return


.wheel_up:
  Gosub storeline
  log_Print{"wheel up"}
  If ped\ptrCurrentSourceData\DisplayLineOffset > 0 
    PED_GotoLine{ped\ptrCurrentSourceData\DisplayLineOffset + ped\ptrCurrentSourceData\DisplayLine - pedconfig\wheelStep}
  Else
    If ped\ptrCurrentSourceData\DisplayLine > pedconfig\wheelStep
      PED_CursorOff{}
      ped\ptrCurrentSourceData\DisplayLine - pedconfig\wheelStep
      PED_CursorOn{}
    EndIf
  EndIf

  PED_UpdateStatusArea{#STATUS_SCROLLERS}
Return

.handle_event_mousemove:
  If pedconfig\onlinehelp_extended
    help_ticks.b = 0 : WZ_HideBubble{}
  EndIf
Return

.handle_event_extendedmouse:
  If (pedMessage\_Code & $FFFF) = #IMSGCODE_INTUIWHEELDATA  
    log_Print{"extended mouse: wheelevent"}
    *wd.IntuiWheelData  = pedMessage\_IAddress
    ; vertical move
    If *wd\WheelY > 0
      pedconfig\wheelStep = (*wd\WheelY)                     ; get the stepdelta
      Gosub wheel_down                                       ; scroll the sourcetext
    End If
    If *wd\WheelY < 0
      pedconfig\wheelStep = (*wd\WheelY) * -1                ; get the stepdelta an make it to a postiv value
      Gosub wheel_up                                         ; scroll the sourcetext
    End If
  End If
Return

.menu_helpshortcuts
  Gosub open_shortcuts
Return

.menu_helplibrarybrowser
  Gosub open_librarybrowser
Return

.menu_helpcompletion
  wtemp\ibrowser_x = -2
  wtemp\ibrowser_y = -2
  wtemp\ibrowser_w = -2
  wtemp\ibrowser_h = -2
  Gosub open_instructionbrowser
Return

.menu_helpnews:
  Show_Helpfile{"Changelog","main",""}
Return

.menu_helpblitzlibs:
  Show_Helpfile{"BlitzLibs","main",""}
Return

.menu_helpgeneral:
  Show_Helpfile{"AmiBlitz3","main",""}
Return

.menu_helpprogramming:
  Show_Helpfile{"BlitzProgrammers","main",""}
Return

.menu_helpincludesguide:
  Show_Helpfile{"Main","main",""}
Return

.menu_helpbuildindex:
  PED_SetPointerBusy{}

  PED_BuildHelpIndex{}

  If pedconfig\usePreProcessor
    WZ_ShowMessage{!TRANS{"updating token hashmap for preprocessor ..."}}
    Gosub update_preprocessor
    WZ_HideMessage{}
  End If

  PED_SetPointerNormal{}
Return

.write_newprefs
  If WriteFile (0,pedconfig\winprefsFile)
    WriteType 0,wpref(0)
    WriteType 0,wpref(1)
    WriteType 0,wpref(2)
    CloseFile 0
  EndIf
Return


.update_rememberlist:
  tmpfile$ = Peek.s(&ped\ptrCurrentSourceData\SourceName)
  tmppath$ = Peek.s(&ped\ptrCurrentSourceData\SourceDir)
  log_Print{"updating remember menu for " + tmppath$ + "/" + tmpfile$}
  h = 0 : exit_rlupdate.b = False
  Repeat
    If dos_FilePart{rememberfiles$(h)} = tmpfile$
      rememberfiles$(h) = dos_AddPart{tmppath$,tmpfile$}
      exit_rlupdate = True
    EndIf
    h + 1
  Until exit_rlupdate OR h = 4

  ; if no empty entry left, roll last out and replace with current one
  If NOT exit_rlupdate
    For h = 3 To 0 Step -1
      rememberfiles$(h+1) = rememberfiles$(h)
    Next h
    rememberfiles$(0) = dos_AddPart{tmppath$,tmpfile$}
  EndIf
  Gosub update_remembermenu
  Gosub write_pedrememberfiles
Return


.write_pedrememberfiles:
  tedfile.l = file_Open{pedconfig\rememberFile,#file_forcewrite}
  If tedfile <> -1
    For h = 0 To 4
      file_WriteString{tedfile,rememberfiles$(h)}
    Next h
    file_Close{tedfile}
  EndIf
Return

.load_pedrememberfile:
  ;-- reset list
  For h = 0 To 4
    rememberfiles$(h) = "<unnamed>"
  Next h

  ;-- load the files
  If dos_Exist{pedconfig\rememberFile}
    tedfile.l = file_Open{pedconfig\rememberFile,#file_read}
    If tedfile >= 0

      If file_GetLength{tedfile} = 1280 ; old format since ab2
        log_Print{"reading old rememberfiles format and converting it."}
        tmpfile$ = SPACE$($40)
        tmppath$ = SPACE$($60)
        For h = 0 To 4
          file_Seek{tedfile,h * $100}
          file_ReadMem{tedfile,&tmpfile$,$40}
          file_ReadMem{tedfile,&tmppath$,$60}
          rememberfiles$(h) = dos_AddPart{Peek.s(&tmppath$), Peek.s(&tmpfile$)}
          ;log_Print{"["+rememberfiles$(h)+"]"}
        Next h
      Else
        For h = 0 To 4
          rememberfiles$(h) = file_ReadString{tedfile}
        Next h
      EndIf
      file_Close{tedfile}
    EndIf
  EndIf
  Gosub update_remembermenu
Return

.update_remembermenu:
  If sourceWindow\win Then Gosub init_menus
Return

.load_remembered:
  If pedconfig\remember_saved = False
    log_Print{"loading remembered source is deactivated."}
    Return
  EndIf

  _rememberitem.w = _menuitem - $78
  log_Print{"load remembered item [" + Str$(_rememberitem) + "]: " + rememberfiles$(_rememberitem)}
  If rememberfiles$(_rememberitem) = "<unnamed>"
     Gosub menu_load
     Return
  EndIf

  log_Print{"loading remembered sourcefile"}
  !PED_LoadSource{rememberfiles$(_rememberitem),True,True,True}
  Gosub analyze_loadedsource
  PED_UpdateStatusArea{#STATUS_REDRAW}
Return

.set_remembered_filename:
  tmpfile$ = Peek.s(&ped\ptrCurrentSourceData\SourceName)
  tmppath$ = Peek.s(&ped\ptrCurrentSourceData\SourceDir)
  rememberfiles$(_rememberitem-1) = dos_AddPart{tmppath$,tmpfile$}
  log_Print{"set [" + rememberfiles$(_rememberitem) + "] to item [" +Str$(_rememberitem) + "]"}
Return

.kill_menus
  If Peek.l(Addr GTMenuList(0))<>0
    If sourceWindow\win <> 0 Then ClearMenuStrip_ sourceWindow\win
    If WZ_IsOpen{"WIN_NEWTYPE"}            Then Use Window WZID("WIN_NEWTYPE")            : ClearMenuStrip_ WZWindowAddr
    If WZ_IsOpen{"WIN_LABELS"}             Then Use Window WZID("WIN_LABELS")             : ClearMenuStrip_ WZWindowAddr
    If WZ_IsOpen{"WIN_INSTRUCTIONBROWSER"} Then Use Window WZID("WIN_INSTRUCTIONBROWSER") : ClearMenuStrip_ WZWindowAddr
    If WZ_IsOpen{"WIN_LIBRARYBROWSER"}     Then Use Window WZID("WIN_LIBRARYBROWSER")     : ClearMenuStrip_ WZWindowAddr
    If WZ_IsOpen{"WIN_SEARCH"}             Then Use Window WZID("WIN_SEARCH")             : ClearMenuStrip_ WZWindowAddr
    If WZ_IsOpen{"WIN_SHORTCUTS"}          Then Use Window WZID("WIN_SHORTCUTS")          : ClearMenuStrip_ WZWindowAddr
    Free GTMenuList 0 : ped\menuStrip = 0
  EndIf
Return


.init_menus
  Gosub kill_menus
  GTMenuTitle    0,0,   !TRANS{"Project"                     }
   GTMenuItem  0,0,0, 0,!TRANS{"Project Settings"            },"M"         ,0,#MENU_PROJECTSETTINGS
   GTMenuItem  0,0,0, 1,!TRANS{"IDE Preferences"             },""          ,0,#MENU_IDEPREFERENCES
   GTMenuItem  0,0,0, 2,!TRANS{"Autolayout   "               },""          ,0,#MENU_AUTOLAYOUT
   GTSubItem  0,0,0,2,0,!TRANS{"Set autolayout 1"            },""        ,0,#MENU_GETLAYOUT1
   GTSubItem  0,0,0,2,1,!TRANS{"Set autolayout 2"            },""        ,0,#MENU_GETLAYOUT2
   GTSubItem  0,0,0,2,2,!TRANS{"Set autolayout 3"            },""        ,0,#MENU_GETLAYOUT3
   GTMenuItem  0,0,0, 3,!TRANS{"Menu Edit..."                },""          ,0,#MENU_CUSTOMEDIT       ; entry moved to Project menu  tomsmart1
   GTMenuItem  0,0,0, 4
   GTMenuItem  0,0,0, 5,!TRANS{"Open WB"                     },""          ,0,#MENU_OPENWORKBENCH
   GTMenuItem  0,0,0, 6,!TRANS{"Close WB"                    },""          ,0,#MENU_CLOSEWORKBENCH
   GTMenuItem  0,0,0, 7,!TRANS{"Open Shell"                  },""          ,0,#MENU_OPENSHELL
   GTMenuItem  0,0,0, 8,!TRANS{"Calculator"                  },""          ,0,#MENU_CALCULATOR
   GTMenuItem  0,0,0, 9
   GTMenuItem  0,0,0,10,!TRANS{"About AmiBlitz3"             },""          ,0,#MENU_ABOUT
   GTMenuItem  0,0,0,11
   GTMenuItem  0,0,0,12,!TRANS{"Iconify"                     },""          ,0,#MENU_ICONIFY
   GTMenuItem  0,0,0,13,!TRANS{"Quit"                        },"Q"         ,0,#MENU_QUIT

  GTMenuTitle    0,1,   !TRANS{"Source File"                 }
   GTMenuItem  0,0,1, 0,!TRANS{"New..."                      },""          ,0,#MENU_NEW
   ; -- scan for any templates
   ClearList templates()
   templatepath.s = dos_AddPart{pedconfig\sourceDir , "Templates"}
   *root.ml_node  = ml_AddPathNode{0,templatepath.s,"#?.(bb2|ab2|ab3|asc)"}
   *node.ml_node  = *root
   templates.w    = 0
   While *node><0 AND templates < #MAX_MENUTEMPLATES
     fil.s = ml_GetUserString{*node}
     If dos_IsDir{fil} = False
        mtitle.s = Replace$(dos_RemExt{dos_FilePart{fil}},"_"," ")
        shortc.l = #MENU_TEMPLATE + templates
        GTSubItem  0,0,1, 0,templates,mtitle.s                    ,""          ,0,shortc
        If AddLast(templates()) Then templates()\filename = fil
        templates + 1
     End If
     *node = ml_GetNextNode{*node}
   Wend
   ml_RemoveAllNodes{*root}
   GTMenuItem  0,0,1, 1,!TRANS{"Open"                        },"O"         ,0,#MENU_OPEN
   GTMenuItem  0,0,1, 2,!TRANS{"Open New"                    },""          ,0,#MENU_OPENNEW
   GTMenuItem  0,0,1, 3,!TRANS{"Include File"                },"I"         ,0,#MENU_INCLUDEFILE
   GTMenuItem  0,0,1, 4
   GTMenuItem  0,0,1, 5,!TRANS{"Save"                        },"S"         ,0,#MENU_SAVE
   GTMenuItem  0,0,1, 6,!TRANS{"Save As..."                  },"A"         ,0,#MENU_SAVEAS
   GTMenuItem  0,0,1, 7
   GTMenuItem  0,0,1, 8,!TRANS{"Print..."                    },""          ,0,#MENU_PRINT
   GTMenuItem  0,0,1, 9
   GTMenuItem  0,0,1,10,!TRANS{"Close"                       },""          ,0,#MENU_CLOSE
   If pedconfig\remember_saved
     GTMenuItem  0,0,1,11
     For h = 0 To 4
       GTMenuItem  0,0,1,12+h,dos_FilePart{rememberfiles$(h)} ,Str$(h+1)    ,0,#MENU_LASTSOURCE1 + h
     Next h
   EndIf


  GTMenuTitle    0,2,   !TRANS{"Edit"                        }
   GTMenuItem  0,0,2, 0,!TRANS{"Cut"                         },"X"         ,0,#MENU_CUT
   GTMenuItem  0,0,2, 1,!TRANS{"Copy"                        },"C"         ,0,#MENU_COPY
   GTMenuItem  0,0,2, 2,!TRANS{"Paste"                       },"V"         ,0,#MENU_PASTE
   GTMenuItem  0,0,2, 3,!TRANS{"Duplicate"                   },"Z"         ,0,#MENU_DUPLICATE
   GTMenuItem  0,0,2, 4,!TRANS{"Forget"                      },"W"         ,0,#MENU_FORGET
   GTMenuItem  0,0,2, 5,!TRANS{"Kill"                        },"K"         ,0,#MENU_KILL
   GTMenuItem  0,0,2, 6,!TRANS{"Save Block As..."            },""          ,0,#MENU_SAVEBLOCKAS
   GTMenuItem  0,0,2, 7
   GTMenuItem  0,0,2, 8,!TRANS{"Insert Line"                 },""          ,0,#MENU_INSERTLINE
   GTMenuItem  0,0,2,09,!TRANS{"Delete Line"                 },"D"         ,0,#MENU_DELETELINE
   GTMenuItem  0,0,2,10,!TRANS{"Undelete Line"               },"U"         ,0,#MENU_UNDELETELINE
   GTMenuItem  0,0,2,11,!TRANS{"Join Lines"                  },"J"         ,0,#MENU_JOINLINES
   GTMenuItem  0,0,2,12,!TRANS{"Delete to EOL"               },"Y"         ,0,#MENU_DELETETOEOL
   GTMenuItem  0,0,2,13
   GTMenuItem  0,4,2,14,!TRANS{"Block Tab"                   },"CTRL+Right",0,#MENU_BLOCKTAB
   GTMenuItem  0,4,2,15,!TRANS{"Block Untab"                 },"CTRL+Left" ,0,#MENU_BLOCKUNTAB
   GTMenuItem  0,0,2,16,!TRANS{"Block Comment"               },"{"         ,0,#MENU_BLOCKCOMMENT
   GTMenuItem  0,0,2,17,!TRANS{"Block Uncomment"             },"}"         ,0,#MENU_BLOCKUNCOMMENT
   GTMenuItem  0,0,2,18,!TRANS{"Mark Indent"                 },""          ,0,#MENU_MARKINDENT
   GTMenuItem  0,0,2,19,!TRANS{"Insert Filename"             },""          ,0,#MENU_INSERTFILENAME
   GTMenuItem  0,0,2,20,!TRANS{"Open Filename Under Cursor"  },""          ,0,#MENU_OPENFILEUNDERCURSOR



  GTMenuTitle    0,3,   !TRANS{"Navigation"                  }
   GTMenuItem  0,0,3, 0,!TRANS{"Find..."                     },"F"         ,0,#MENU_OPENFIND
   GTMenuItem  0,0,3, 1,!TRANS{"Find Next"                   },"N"         ,0,#MENU_FIND
   GTMenuItem  0,0,3, 2,!TRANS{"Find Previous"               },"P"         ,0,#MENU_PREVIOUS
   GTMenuItem  0,0,3, 3,!TRANS{"Replace & Find"              },"R"         ,0,#MENU_REPLACE
   GTMenuItem  0,0,3, 4
   GTMenuItem  0,4,3, 5,!TRANS{"Top"                         },"CTRL+Up"   ,0,#MENU_TOP
   GTMenuItem  0,4,3, 6,!TRANS{"Bottom"                      },"CTRL+Down" ,0,#MENU_BOTTOM
   GTMenuItem  0,0,3, 7,!TRANS{"Goto Line..."                },"G"         ,0,#MENU_GOTOLINE
   GTMenuItem  0,0,3, 8
   GTMenuItem  0,4,3,09,!TRANS{"Previous Page"               },"F9"        ,0,#MENU_PREVPAGE
   GTMenuItem  0,4,3,10,!TRANS{"Next Page"                   },"F10"       ,0,#MENU_NEXTPAGE


  GTMenuTitle    0,4,   !TRANS{"Compiler"                    }
   GTMenuItem  0,0,4, 0,!TRANS{"Compile & Run"               },"#"         ,0,#MENU_COMPILERUN
   GTMenuItem  0,0,4, 1,!TRANS{"Save & Compile & Run"        },"B"         ,0,#MENU_SAVECOMPILERUN
   GTMenuItem  0,0,4, 2,!TRANS{"Run"                         },""          ,0,#MENU_RUN
   GTMenuItem  0,0,4, 3,!TRANS{"Create Executable..."        },"E"         ,0,#MENU_CREATEEXE
   GTMenuItem  0,0,4, 4,!TRANS{"Save & Create Executable"    },"T"         ,0,#MENU_SAVECREATEEXE
   GTMenuItem  0,0,4, 5,!TRANS{"Create minimized Executable" },""          ,0,#MENU_CREATERELEASEEXE
   GTMenuItem  0,0,4, 6,!TRANS{"Create Resident..."          },""          ,0,#MENU_CREATERESIDENT
   GTMenuItem  0,0,4, 7
   GTMenuItem  0,0,4, 8,!TRANS{"Set CLI Arguments"           },""          ,0,#MENU_SETCLIARGS
   GTMenuItem  0,0,4, 9,!TRANS{"Reload Userlibs"             },"\"         ,0,#MENU_RELOAD_USERLIBS
   GTMenuItem  0,0,4,10
   GTMenuItem  0,0,4,11,!TRANS{"Compiler Settings"           },""          ,0,#MENU_COMPILERSETTINGS
   GTMenuItem  0,1,4,12,!TRANS{"Create Debug Code"           },""          ,0,#MENU_CREATEDEBUGCODE


  GTMenuTitle    0,5,   !TRANS{"Help"                        }
   GTMenuItem  0,0,5, 0,!TRANS{"What's New?"                 },""          ,0,#MENU_WHATSNEW
   GTMenuItem  0,0,5, 1
   GTMenuItem  0,4,5, 2,!TRANS{"General AB3 Guide"           },"F1"        ,0,#MENU_GENERALGUIDE
   GTMenuItem  0,0,5, 3,!TRANS{"Programming in Blitz"        },""          ,0,#MENU_PROGRAMGUIDE
   GTMenuItem  0,4,5, 4,!TRANS{"Includes Guide"              },"F2"        ,0,#MENU_INCLUDEGUIDE
   GTMenuItem  0,4,5, 5,!TRANS{"Blitzlibs Guide"             },"F3"        ,0,#MENU_BLITZLIBSGUIDE
   GTMenuItem  0,0,5, 6,!TRANS{"Shortcuts Reference"         },""          ,0,#MENU_SHORTCUTREFERENCE
   GTMenuItem  0,0,5, 7
   GTMenuItem  0,0,5, 8,!TRANS{"Instruction Browser"         },""          ,0,#MENU_INSTRUCTIONBROWSER
   GTMenuItem  0,0,5, 9,!TRANS{"Source Browser"              },""          ,0,#MENU_SOURCEBROWSER
   GTMenuItem  0,0,5,10,!TRANS{"Definition Browser"          },""          ,0,#MENU_DEFINITIONBROWSER
   GTMenuItem  0,0,5,11,!TRANS{"Library Browser"             },""          ,0,#MENU_LIBRARYBROWSER
   GTMenuItem  0,0,5,12
   GTMenuItem  0,0,5,13,!TRANS{"Update Instruction Index"    },""          ,0,#MENU_UPDATEHELPINDEX

  Gosub load_custommenus
  If FirstItem(custommenu())                                                   ; changed code the CustomMenu only apear if there ar an entry  tomsmart1
    GTMenuTitle 0,6,    !TRANS{"Custom"                      }                 ; move MenuEdit entry to ProjectMenu  tomsmart1
      menuentry.b = 0                                                            ; change startentry  tomsmart1
      Repeat
        ;If custommenu()\itemname = "~"
        ;  GTMenuItem 0,0,6,menuentry
        ;Else
          shortc = #MENU_CUSTOMITEM1+menuentry                                 ; changed because CostomMenuEntry got its own ID  tomsmart1
          GTMenuItem 0,0,6,menuentry,custommenu()\itemname,"",0,shortc         ; changed because CostomMenuEntry got its own ID  tomsmart1
        ;EndIf
        menuentry + 1
      Until NOT NextItem(custommenu())
  EndIf

  CreateMenuStrip 0
  ped\menuStrip = Peek.l(Addr GTMenuList(0))
  If ped\menuStrip
    If sourceWindow\win <> 0                  Then                                             SetMenuStrip_ sourceWindow\win,ped\menuStrip
    If WZ_IsOpen{"WIN_SHORTCUTS"}          Then Use Window WZID("WIN_SHORTCUTS")          : SetMenuStrip_ WZWindowAddr,ped\menuStrip
    If WZ_IsOpen{"WIN_SEARCH"}             Then Use Window WZID("WIN_SEARCH")             : SetMenuStrip_ WZWindowAddr,ped\menuStrip
    If WZ_IsOpen{"WIN_NEWTYPE"}            Then Use Window WZID("WIN_NEWTYPE")            : SetMenuStrip_ WZWindowAddr,ped\menuStrip
    If WZ_IsOpen{"WIN_LABELS"}             Then Use Window WZID("WIN_LABELS")             : SetMenuStrip_ WZWindowAddr,ped\menuStrip
    If WZ_IsOpen{"WIN_INSTRUCTIONBROWSER"} Then Use Window WZID("WIN_INSTRUCTIONBROWSER") : SetMenuStrip_ WZWindowAddr,ped\menuStrip
    If WZ_IsOpen{"WIN_LIBRARYBROWSER"}     Then Use Window WZID("WIN_LIBRARYBROWSER")     : SetMenuStrip_ WZWindowAddr,ped\menuStrip
  EndIf
Return


.load_custommenus:
  If dos_Exist{pedconfig\menuFile}
    fid.l = file_Open{pedconfig\menuFile,#file_read}
    If fid >= 0
      ClearList custommenu()
      While file_EOF{fid} = False
        textline.s = file_ReadLine{fid}
        If textline <> "" AND AddLast(custommenu())
          InitArgParse textline
          custommenu()\itemname  = NextArgChar$(@",")
          custommenu()\shortcut  = NextArgChar$(@",")
          custommenu()\id        = Vallong(NextArgChar$(@","))
          custommenu()\path      = NextArgChar$(@",")
          custommenu()\runwbmode = Vallong(NextArgChar$(@","))
          custommenu()\stacksize = Vallong(NextArgChar$(@","))
          custommenu()\prio      = Vallong(NextArgChar$(@","))
        EndIf
      Wend
      file_Close{fid}
    End If
  EndIf
Return


Even
.menutable:
  ;    menu/ShortcutID   refresh   pointer to menuaction code

  ; -- MENU PROJECT
  Dc.l #MENU_OPENWORKBENCH,   0, menu_openwb
  Dc.l #MENU_CLOSEWORKBENCH,  0, menu_closewb
  Dc.l #MENU_ICONIFY,         0, menu_iconify
  Dc.l #MENU_OPENSHELL,       0, menu_newshell
  Dc.l #MENU_IDEPREFERENCES,  0, menu_settings
  Dc.l #MENU_PROJECTSETTINGS, 0, menu_project
  Dc.l #MENU_AUTOLAYOUT,      0, menu_autolayout
  Dc.l #MENU_GETLAYOUT1,      0, menu_autolayout
  Dc.l #MENU_GETLAYOUT2,      0, menu_autolayout
  Dc.l #MENU_GETLAYOUT3,      0, menu_autolayout
  Dc.l #MENU_ABOUT,           0, menu_about
  Dc.l #MENU_QUIT,            0, menu_quitall

  ; -- MENU SOURCE
  Dc.l #MENU_NEW,             0, menu_new
  Dc.l #MENU_OPENNEW,         0, menu_loadAsNew
  Dc.l #MENU_OPEN,            1, menu_load
  Dc.l #MENU_INCLUDEFILE,     1, menu_includeblock
  Dc.l #MENU_SAVE,            0, menu_save
  Dc.l #MENU_SAVEAS,          0, menu_saveas
  Dc.l #MENU_EXPORTASCII,     0, menu_saveas
  Dc.l #MENU_PRINT,           0, menu_print
  Dc.l #MENU_CLOSE,           0, menu_quit
  Dc.l #MENU_LASTSOURCE1,     1, load_remembered
  Dc.l #MENU_LASTSOURCE2,     1, load_remembered
  Dc.l #MENU_LASTSOURCE3,     1, load_remembered
  Dc.l #MENU_LASTSOURCE4,     1, load_remembered
  Dc.l #MENU_LASTSOURCE5,     1, load_remembered

  ; -- MENU EDIT
  Dc.l #MENU_CUT,             1, menu_cut
  Dc.l #MENU_COPY,            1, menu_copy
  Dc.l #MENU_PASTE,           1, menu_paste
  Dc.l #MENU_DUPLICATE,       1, menu_dublicate
  Dc.l #MENU_FORGET,          1, menu_forget
  Dc.l #MENU_KILL,            1, menu_kill
  Dc.l #MENU_SAVEBLOCKAS,     1, menu_saveblockas
  Dc.l #MENU_INSERTLINE,      0, menu_insertline
  Dc.l #MENU_DELETELINE,      0, menu_deleteline
  Dc.l #MENU_UNDELETELINE,    0, menu_undeleteline
  Dc.l #MENU_JOINLINES,       0, menu_joinlines
  Dc.l #MENU_BLOCKTAB,        1, menu_blocktab
  Dc.l #MENU_BLOCKUNTAB,      1, menu_blockuntab
  Dc.l #MENU_BLOCKCOMMENT,    1, menu_blockcomment
  Dc.l #MENU_BLOCKUNCOMMENT,  1, menu_blockuncomment
  Dc.l #MENU_MARKINDENT,      1, menu_markindent

  ;-- MENU NAVIGATION
  Dc.l #MENU_OPENFIND,        1, menu_find
  Dc.l #MENU_FIND,            1, menu_findnext
  Dc.l #MENU_PREVIOUS,        1, menu_findprevious
  Dc.l #MENU_REPLACE,         1, menu_replace
  Dc.l #MENU_TOP,             1, menu_top
  Dc.l #MENU_BOTTOM,          1, menu_bottom
  Dc.l #MENU_GOTOLINE,        1, menu_gotoline
  Dc.l #MENU_PREVPAGE,        0, menu_previousfile
  Dc.l #MENU_NEXTPAGE,        0, menu_nextfile

  ; -- MENU COMPILER

  ; -- MENU HELP
  Dc.l #MENU_WHATSNEW,0,menu_helpnews
  Dc.l #MENU_GENERALGUIDE,0, menu_helpgeneral
  Dc.l #MENU_PROGRAMGUIDE,0,menu_helpprogramming
  Dc.l #MENU_BLITZLIBSGUIDE,0,menu_helpblitzlibs
  Dc.l #MENU_INCLUDEGUIDE,0,menu_helpincludesguide
  Dc.l #MENU_INSTRUCTIONBROWSER,0, menu_helpcompletion
  Dc.l #MENU_SHORTCUTREFERENCE,0, menu_helpshortcuts
  Dc.l #MENU_LIBRARYBROWSER,0,  menu_helplibrarybrowser
  Dc.l #MENU_UPDATEHELPINDEX,0,menu_helpbuildindex
  ; end of menutable
  Dc.l $FFFFFFFF
Even


.menu_project:
  PED_SetPointerBusy{}

  Gosub storeCurrentSourceData

  If NOT WZ_IsOpen{"WIN_PROJECT"}
    WZWindow WZID("WIN_PROJECT"),?wzgui,192,-2,-2,-2,-2,WZID("WIN_PROJECT")
    Use Window WZID("WIN_PROJECT")
    WZ_InitTable{"WIN_PROJECT","PROJECTTABLE",2}
    WZ_SetTableTitle{"PROJECTTABLE","File","Category"}
    WZ_SetTableColors{"PROJECTTABLE",1,0,1,0}
    WZ_SetPriority{"PROJECTTABLE",3,1}
    WZ_SetSortable{"PROJECTTABLE",Off}
    project_tab.b = WZInput("PROJECT_TABS")
    Gosub update_versiongadgets
  EndIf

  actual_file$ = Peek.s(&ped\ptrCurrentSourceData\SourceName)
  actual_drawer$ = Peek.s(&ped\ptrCurrentSourceData\SourceDir)

  If project_tab = 1
    WZ_DrawTable{"PROJECTTABLE"}
    Gosub project_updatesourcelist
  EndIf

  exit_project.b = False
  Repeat
    ev.l = WaitEvent
    Select ev
    Case #IDCMP_IDCMPUPDATE
      Select WZGadName
      Case "PROJECT_TABS"
        project_tab.b = WZInput("PROJECT_TABS")
        If project_tab = 1
          WZ_DrawTable{"PROJECTTABLE"}
          Gosub project_updatesourcelist
        EndIf

      Case "PROJECT_NAME"
        ab3_project\name = WZInputstr

      Case "PROJECT_DRAWER"
        ab3_project\drawer = WZInputstr

      Case "PROJECT_VERSION"
        ab3_project\version = WZInput

      Case "PROJECT_REVISION"
        ab3_project\revision = WZInput


      Case "PROJECT_CREATE"
        If ab3_project\name<>""
          If ask{!TRANS{"The current project and its files will be closed,\\nand all source files will be saved."},!TRANS{"Ok|Cancel"},!TRANS{"Create Project"}}
            WZ_ClearTable{"PROJECTTABLE"}
            WZ_UpdateTable{"PROJECTTABLE"}
            Gosub project_closeallfiles
            ClearType ab3_project
            Gosub project_updatesourcelist
            WZ_ActivateGadget{"PROJECT_NAME"}
          EndIf
        Else
          dummy.l = ask{!TRANS{"Illegal Projectname"},!TRANS{"Ok"},!TRANS{"Create Project"}}
        EndIf

      Case "PROJECT_LOAD"
        aslfr_SetRequesterTitle {1,!TRANS{"Choose Project"},!TRANS{"Ok"},!TRANS{"Cancel"}}
        aslfr_SetPath  {1,"",project_filename,"#?.a2p",False}
        If aslfr_Request {1,False,False,False,sourceWindow\pedScreen,True}
          project_filename = aslfr_GetNextFile{}
        ;If Exists(project_filename)>0
          Gosub project_load
          If ab3_project\sourcecounter > 0
            For pc.l = 1 To ab3_project\sourcecounter
              fext$ = dos_GetExt{ab3_project\sourcefile[pc]}
              If fext$="ab2" OR fext$="bb2" OR fext$="bb"
                sourcefile$ = ab3_project\sourcepath[pc]+ab3_project\sourcefile[pc]
                !PED_LoadSource{sourcefile$,False,True,True}
              EndIf
            Next pc
            Gosub activatesourcewindow
            Gosub project_updatesourcelist
            Use Window WZID("WIN_PROJECT")
            WindowToFront_ WZWindowAddr
          EndIf
        Else
          If project_filename <> "" Then dummy.l = ask{!TRANS{"This project does not exist."},!TRANS{"Ok"},!TRANS{"Info"}}
        EndIf

      Case "PROJECT_SAVE"
        ab3_project\name = WZGetString("PROJECT_NAME")
        ab3_project\drawer = WZGetString("PROJECT_DRAWER")
        If ab3_project\name <> ""
          Gosub project_save
        Else
          dummy.l = ask{!TRANS{"Illegal Projectname"},!TRANS{"Ok"},!TRANS{"Error"}}
        EndIf

      Case "PROJECT_ADDFILE"
        aslfr_SetRequesterTitle {1,!TRANS{"Add File"},!TRANS{"Ok"},!TRANS{"Cancel"}}
        aslfr_SetPath  {1,ab3_project\drawer,project_filename,"",False}
        If aslfr_Request {1,False,False,False,sourceWindow\pedScreen,False}
          actual_file$=aslfr_GetNextFile{}
        ;If Exists(actual_file$) > 0
          ab3_project\sourcecounter + 1
          ab3_project\sourcefile[ab3_project\sourcecounter] = dos_FilePart{actual_file$}

          Gosub project_filename
          actual_file$ = dos_FilePart{actual_file$}
          Gosub project_updatesourcelist
          Use Window WZID("WIN_PROJECT")
          WindowToFront_ WZWindowAddr
        Else
          If project_filename <> "" Then dummy.l = ask{!TRANS{"This file does not exist"},!TRANS{"Ok"},!TRANS{"Error"}}
        EndIf

      Case "PROJECT_REMOVEFILE"
        actual_file$ = WZ_GetCell{"PROJECTTABLE",WZ_Row{"PROJECTTABLE"},1}
        For pc = 1 To ab3_project\sourcecounter
          If actual_file$ = ab3_project\sourcefile[pc]
            Gosub project_removefile
            ab3_project\sourcefile[pc] = ""
            ab3_project\sourcepath[pc] = ""
            Gosub project_sortsourcelist
            Gosub project_updatesourcelist
          EndIf
        Next pc
;        Gosub activatesourcewindow                              ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1
;        Gosub menu_quit


; -- TAB Versionmanagement --

      Case "INTEGER_VER_MAJOR"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_MINOR"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_PATCH"
        Gosub get_versiondata_from_gui

      Case "INTEGER_VER_BUILD"
        Gosub get_versiondata_from_gui

      ; -- TAB Changelog --

      Case "CHANGELOG_ADDENTRY"
        If Peek.l(?comPtr_VersionInformation) AND Peek.l(?comPtr_NumberOfBuilds)
          If (Peek.l(?comPtr_VersionInformation)<>0) AND (Peek.l(?comPtr_NumberOfBuilds )<>0)
            version_code.l = Peek.l(Peek.l(?comPtr_VersionInformation))
            anz_builds.l   = Peek.l(Peek.l(?comPtr_NumberOfBuilds))
            vercode$ = Str$(version_code LSR 24 )+"."
            vercode$ + Str$((version_code LSL 8) LSR 24 )+"."
            vercode$ + Str$((version_code LSL 16)LSR 24 )+" (build: "
            vercode$ + Str$(anz_builds)+")"
            project_changelog$ =  "V" + vercode$ + ":\\0a\\0a" + project_changelog$
            WZPrint "CHANGELOG_TEXTFIELD",&project_changelog$
          EndIf
        EndIf

      Case "CHANGELOG_TEXTFIELD"
        project_changelog$ = WZ_GetStringField{"CHANGELOG_TEXTFIELD"}

      End Select

   Case #IDCMP_VANILLAKEY
     Select EventCode
       Case #VANILLAKEY_ESC : exit_project = True
     End Select


    Case #IDCMP_CLOSEWINDOW
      exit_project = True
    End Select

    If project_tab = 1
      wev.l = WZ_CheckTableEvent{ev}
      If wev = #WZTABLEEVENT_DOUBLECLICK
        _sf$ = WZ_GetCell{"PROJECTTABLE",WZ_Row{"PROJECTTABLE"},1}
        If (_sf$<>actual_file$) AND (_sf$<>"<unnamed>")
          actual_file$ = _sf$
          Gosub project_filename
;        For pc = 1 To ab3_project\sourcecounter
;          t$ = ab3_project\sourcefile[pc]
;          If t$ = actual_source$ Then WZ_SetActiveRow{"PROJECTTABLE",pc}
;        Next pc
;        WZ_UpdateTable{"PROJECTTABLE"}
          Use Window WZID("WIN_PROJECT")
          WindowToFront_ WZWindowAddr
;        exit_project = True
        EndIf
      EndIf
    EndIf
  Until exit_project = True

  WZ_KillTable{"PROJECTTABLE"}
  WZCloseWindow WZID("WIN_PROJECT")
  FlushEvents
  Gosub activatesourcewindow
  PED_SetPointerNormal{}
Return

.project_sortsourcelist
  tempcounter.w = 0
  For i = 1 To #MAX_SOURCEFILES
    If ab3_project\sourcefile[i]<> ""
      tempcounter + 1
      tempproject$(tempcounter,0) = ab3_project\sourcefile[i]
      tempproject$(tempcounter,1) = ab3_project\sourcepath[i]
    EndIf
    ab3_project\sourcefile[i] = ""
    ab3_project\sourcepath[i] = ""
  Next i

  For i = 1 To tempcounter
    ab3_project\sourcefile[i] = tempproject$(i,0)
    ab3_project\sourcepath[i] = tempproject$(i,1)
  Next i
  ab3_project\sourcecounter = tempcounter
Return

.project_updatesourcelist:
  If project_tab = 1
    WZ_ClearTable{"PROJECTTABLE"}
    If ab3_project\sourcecounter > 0
      For pc = 1 To ab3_project\sourcecounter
        t$ = LCase$(ab3_project\sourcefile[pc])
        If Instr(t$,".include") Then u$ = "Include" Else
        If Instr(t$,".bb2")     Then u$ = "AB2-Source" Else
        If Instr(t$,".ab2")     Then u$ = "AB2-Source" Else
        If Instr(t$,".ab3")     Then u$ = "AB3-Source" Else
        If Instr(t$,".bb")      Then u$ = "BB2-Source" Else
        If Instr(t$,".wizard")  Then u$ = "Wizard-GUI-File" Else u$ = dos_GetExt{t$}+" File"
        WZ_AddRow{"PROJECTTABLE",t$,u$}
        If t$ = LCase$(actual_file$) Then WZ_SetActiveRow{"PROJECTTABLE",pc}
      Next pc
    EndIf
    WZ_UpdateTable{"PROJECTTABLE"}

    ab2p$ = ab3_project\name
    ab2d$ = ab3_project\drawer
    WZPrint "PROJECT_NAME",&ab2p$
    WZPrint "PROJECT_DRAWER",&ab2d$
;    WZPrint "PROJECT_VERSION",ab3_project\version
;    WZPrint "PROJECT_REVISION",ab3_project\revision
  EndIf
Return

.project_closeallfiles:
  Gosub activatesourcewindow

  While ped\firstSourceEntry
    Gosub free_actualsource
    Gosub close_actualsource
  Wend

  Gosub activatesourcewindow
Return

.project_removefile:
  t$ = LCase$(actual_file$)
  If Instr(t$,".bb2") OR Instr(t$,".ab2") OR Instr(t$,".ab3") OR Instr(t$,".bb")
    Gosub project_filename
    Gosub menu_quit
    actual_file$ = Peek.s(ped\ptrCurrentSourceData + $DE)
  EndIf
Return

.project_filename:
  t$ = LCase$(actual_file$)
  If Instr(t$,".bb2") OR Instr(t$,".ab2") OR Instr(t$,".ab3") OR Instr(t$,".bb")
    !PED_LoadSource{actual_file$,False,True,True}
  EndIf
Return

.project_load
  If OpenFile(1,project_filename)
    ClearType ab3_project
    ReadType 1,ab3_project
    CloseFile 1
  Else
    dummy.l = ask{!TRANS{"This project could not be loaded"},!TRANS{"Ok"},"Error"}
  EndIf
Return

.project_save
  project_filename = ab3_project\name+".a2p"
  aslfr_SetRequesterTitle {1,!TRANS{"Save Projectfile"},!TRANS{"Ok"},!TRANS{"Cancel"}}
  aslfr_SetPath  {1,ab3_project\drawer,project_filename,"(#?.a2p)",False}
  If aslfr_Request {1,True,False,False,sourceWindow\pedScreen,True}
    project_filename = aslfr_GetNextFile{}
    If OpenFile(1,project_filename)
      WriteType 1,ab3_project
      CloseFile 1
    Else
      dummy.l = ask{!TRANS{"The project could not be saved."},!TRANS{"Ok"},!TRANS{"Error"}}
    EndIf
  EndIf
Return

.get_versiondata_from_gui:
  If WZ_IsOpen{"WIN_PROJECT"}
    If Peek.l(?comPtr_VersionInformation)
      version_code = WZInput("INTEGER_VER_MAJOR") LSL 24
      version_code + (WZInput("INTEGER_VER_MINOR") LSL 16)
      version_code + (WZInput("INTEGER_VER_PATCH") LSL 8)
      Poke.l Peek.l(?comPtr_VersionInformation),version_code

      Poke.l Peek.l(?comPtr_NumberOfBuilds), WZInput("INTEGER_VER_BUILD")
    EndIf
  EndIf
Return

.update_versiongadgets
  If Peek.l(?comPtr_VersionInformation) AND Peek.l(?comPtr_NumberOfBuilds)
    If (Peek.l(?comPtr_VersionInformation)<>0) AND (Peek.l(?comPtr_NumberOfBuilds)<>0)
      version_code.l = Peek.l(Peek.l(?comPtr_VersionInformation))
      anz_builds.l   = Peek.l(Peek.l(?comPtr_NumberOfBuilds))
      If WZ_IsOpen{"WIN_PROJECT"}
        Use Window WZID("WIN_PROJECT")
        WZPrint "INTEGER_VER_MAJOR",version_code LSR 24
        WZPrint "INTEGER_VER_MINOR",(version_code LSL 8) LSR 24
        WZPrint "INTEGER_VER_PATCH",(version_code LSL 16)LSR 24
        WZPrint "INTEGER_VER_BUILD",anz_builds
        WZPrint "CHANGELOG_TEXTFIELD",&project_changelog$
      EndIf
    EndIf
  EndIf
Return


.menu_print:
  PED_SetPointerBusy{}

  If Peek.l(Addr Window(WZID("WIN_PRINT")))=0
    WZWindow WZID("WIN_PRINT"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_PRINT")
  EndIf
  Use Window WZID("WIN_PRINT")

  exit_print.b = False
  Repeat
    ev.l = WaitEvent
    log_Print{"event " + Hex$(ev)}
    Select ev

    Case #IDCMP_CLOSEWINDOW
      exit_print = True

    Case #IDCMP_IDCMPUPDATE
      log_Print{"Button: " + WZGadName}
      Select WZGadName
        Case "PRINT_CANCEL"
          exit_print = True
        Case "PRINT_PRINT"
          printerDevice.s = WZGetString("PRINT_DEVICE")
          Gosub printout_source
          exit_print = True
      End Select

    End Select
  Until exit_print = True

  WZCloseWindow WZID("WIN_PRINT")
  PED_SetPointerNormal{}
  Gosub activatesourcewindow
Return

.printout_source:
  *prthandle.l = Open_ (&printerDevice,#HUNK_RELOC_8__MODE_NEWFILE)
  If *prthandle
    *currentline.sourceLine = ped\ptrCurrentSourceData\FirstSourceLine
    ped\inString = 0
    While *currentline
      newstr.s = ""
      ptrString.l = *currentline + 9
      Repeat
        curchar.b = Peek.b(ptrString)
        If curchar
          If curchar = $22 Then ped\inString = NOT ped\inString
          ;-- here comes a token
          If (curchar < 0) AND (ped\inString = 0)
            toknum.w = Peek.w(ptrString)
            newstr + "\\1B[1m"
            newstr + PED_GetTokenName{toknum}
            newstr + "\\1B[22m"
            ptrString + 2
          Else
            newstr + Chr$(curchar)
            ptrString + 1
          EndIf
        EndIf
      Until curchar = 0
      newstr = Trim$(newstr) + "\\0A"

      ;log_Print{">>" + Hex$(Cvl(newstr)) + " : " + newstr}
      Write_ *prthandle, &newstr, FLen(newstr)

      *currentline = *currentline\nextLine
    Wend
    Close_ *prthandle
  Else
    error{"Couldnot open printer [" + printerDevice + "]"}
  EndIf
Return


.call_pluginmenuentry:
  If _menuitem = #MENU_CUSTOMEDIT
    Gosub open_menueditor
    Gosub init_menus
  Else
    _menuitem - #MENU_CUSTOMITEM1                        ; to get the correct CostumMenu entry  tomsmart 1
    If _menuitem >= 0
      ResetList custommenu()
      menuentry = 0
      While _menuitem >= menuentry                       ; changed to get the correct entry  tomsmart1
        dummy = NextItem(custommenu())
        menuentry + 1
      Wend
      If custommenu()\path <> ""
        If custommenu()\runwbmode = False
          dos_RunCli{custommenu()\path,custommenu()\prio,custommenu()\stacksize,False}
        Else
          dos_RunWB{custommenu()\path}
        EndIf
      EndIf
    EndIf
  EndIf
Return


.update_menueditorgadgets                                  ; moved to subroutine to remove double code tomsmart1
    WZPrint "MENUED_ITEMNAME",custommenu()\itemname
    WZPrint "MENUED_STACK"   ,custommenu()\stacksize
    WZPrint "MENUED_PRIO"    ,custommenu()\prio
    If custommenu()\runwbmode = 1
      WZPrint "MENUED_RUNMODE",On
      WZDisable "MENUED_STACK" : WZDisable "MENUED_PRIO"
    Else
      WZPrint "MENUED_RUNMODE",Off
      WZEnable "MENUED_STACK" : WZEnable "MENUED_PRIO"
    EndIf
    WZEnable "MENUED_DEL" : WZEnable "MENUED_SORT"
    WZEnable "MENUED_RUNMODE"
    WZEnable "MENUED_PATH"
Return

.disable_menueditorgadgets                                 ; moved to subroutine to remove double code tomsmart1
    WZPrint "MENUED_ITEMNAME",""
    WZPrint "MENUED_STACK"   ,8192
    WZPrint "MENUED_PRIO"    ,-1
    WZPrint "MENUED_RUNMODE" ,Off
    WZDisable "MENUED_DEL"   : WZDisable "MENUED_SORT"
    WZDisable "MENUED_STACK" : WZDisable "MENUED_PRIO"
    WZDisable "MENUED_RUNMODE"
    WZDisable "MENUED_PATH"
Return

.open_menueditor:
  PED_SetPointerBusy{}
  If NOT WZ_IsOpen{"WIN_MENUED"}
    WZWindow WZID("WIN_MENUED"),?wzgui,255,-2,-2,-2,-2,WZID("WIN_MENUED")
  End If
  DEFTYPE.List menuedlist
  ; -- get all the defined menuentries
  If FirstItem(custommenu())                               ; test if we have a (first) entry in the list
    item_counter.b = 0
    Repeat
      WZListAdd menuedlist,custommenu()\itemname,-2
      item_counter+1
    Until NOT NextItem(custommenu())
    WZPrint "MENUED_LIST",0,menuedlist                     ; merged two IF-Thens to one and that fixed Hits if ther are no entrys in the list  tomsmart1
    item_counter = 0
    dummy = FirstItem(custommenu())                        ; back to entry 1 to set the status gadgets
    Gosub update_menueditorgadgets
  Else
    Gosub disable_menueditorgadgets
  EndIf
  menued_exit.b = False

  Repeat
    menued_ev.l = WaitEvent

    Select menued_ev
      Case #IDCMP_CLOSEWINDOW
        menued_exit = True

      Case #IDCMP_VANILLAKEY:
        If EventCode = #VANILLAKEY_ESC Then menued_exit = True

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName
          Case "MENUED_ADD"
            ResetList custommenu()
            If AddLast (custommenu())
                WZListAdd menuedlist,"",-2
                custommenu()\itemname = ""
                custommenu()\path     = ""
                custommenu()\runwbmode = False
                custommenu()\stacksize = 8192
                custommenu()\prio = -1
            EndIf
            item_counter = WZListItems (menuedlist)-1
            WZPrint "MENUED_LIST",item_counter,menuedlist,0 ; neue Position in der Liste anspringen und Liste erneuern ; changed that the selection get not lost  tomsmart1
            dummy.l = LastItem(custommenu())
            Gosub update_menueditorgadgets
            WZDisable "MENUED_SAVE"                         ; added to only allow 1 new entry to prevent empty entrys  tomsmart1
            WZDisable "MENUED_ADD"
            WZDisable "MENUED_SORT"
            WZDisable "MENUED_LIST"

          Case "MENUED_DEL"
            ResetList custommenu()
            item_counter = 0
            While (item_counter < WZListNum ("MENUED_LIST")) AND NextItem(custommenu())
              item_counter + 1
            Wend
            If item_counter = WZListNum ("MENUED_LIST")
              KillItem custommenu()
              WZListRemove menuedlist,WZListNum ("MENUED_LIST")
              WZPrint "MENUED_LIST",0,menuedlist,0
            EndIf
            If FirstItem(custommenu())
              Gosub update_menueditorgadgets
            Else
              Gosub disable_menueditorgadgets
            EndIf
            WZEnable "MENUED_SAVE"
            WZEnable "MENUED_ADD"                          ; added to only allow 1 new entry to prevent empty entrys  tomsmart1
            WZEnable "MENUED_LIST"

          Case "MENUED_SORT"
            If FirstItem(custommenu())                     ; merged If-Thens to one  tomsmart1

              StringSort custommenu(),SizeOf.custommenu    ; command changed to fix sorting  tomsmart1

              WZListRemove menuedlist
              dummy = FirstItem(custommenu())
              Repeat
                WZListAdd menuedlist,custommenu()\itemname,-2
              Until NOT NextItem (custommenu())

              WZPrint "MENUED_LIST",0,menuedlist,0
              dummy = FirstItem(custommenu())              ; back to entry 1 to set the status gadgets
              Gosub update_menueditorgadgets
              WZEnable "MENUED_SAVE"
            Else
              Gosub disable_menueditorgadgets
            EndIf


          Case "MENUED_LIST"
            item_counter = 0
            ResetList custommenu()
            While (item_counter < WZListNum ("MENUED_LIST")) AND NextItem(custommenu())
              item_counter + 1
            Wend
            If item_counter = WZListNum ("MENUED_LIST")
              Gosub update_menueditorgadgets
            Else
              Gosub disable_menueditorgadgets
            EndIf

          Case "MENUED_PATH"
            aslfr_SetRequesterTitle {0,!TRANS{"Select a Programm"},"Ok","Cancel"}
            ; replaced to set always a vaild path  tomsmart1
            If custommenu()\path <> ""
              aslfr_SetPath {0,dos_PathPart{custommenu()\path},dos_FilePart{custommenu()\path} }
            Else
              aslfr_SetPath {0,pedconfig\mainDir,""}
            EndIf
            If aslfr_Request {0,False,False,False,sourceWindow\pedScreen}
              custommenu()\path = aslfr_GetNextFile{}
              If custommenu()\path <>""
                custommenu()\itemname = dos_FilePart{custommenu()\path}
                WZPrint "MENUED_ITEMNAME",custommenu()\itemname

                WZListRemove menuedlist
                ResetList custommenu()
                While NextItem (custommenu())
                  WZListAdd menuedlist,custommenu()\itemname,-2
                Wend

                WZPrint "MENUED_LIST",item_counter,menuedlist,0  ; changed that the selection get not lost  tomsmart1
                WZEnable "MENUED_SAVE"
                WZEnable "MENUED_ADD"                            ; added to only allow 1 new entry to prevent empty entrys  tomsmart1
                WZEnable "MENUED_SORT"
                WZEnable "MENUED_LIST"
              EndIf
            EndIf

          Case "MENUED_STACK"
            stacksize.l = WZInput
            custommenu()\stacksize = stacksize
            If custommenu()\itemname<>"" Then WZEnable "MENUED_SAVE"  ; changed to prevent empty entrys  tomsmart1

          Case "MENUED_PRIO"
            prio.l = WZInput
            custommenu()\prio = prio
            If custommenu()\itemname<>"" Then WZEnable "MENUED_SAVE"  ; changed to prevent empty entrys  tomsmart1

          Case "MENUED_RUNMODE"
            checked.l = WZInput
            If checked = 1
              custommenu()\runwbmode = 1
              WZDisable "MENUED_STACK" : WZDisable "MENUED_PRIO"
            Else
              custommenu()\runwbmode = False
              WZEnable "MENUED_STACK" : WZEnable "MENUED_PRIO"
            EndIf
            If custommenu()\itemname<>"" Then WZEnable "MENUED_SAVE"  ; changed to prevent empty entrys  tomsmart1

          Case "MENUED_SAVE"
            ; removed code to fix Hits if entrys are deleted  tomsmart1
            fid.l = file_Open{pedconfig\menuFile,#file_forcewrite}
            If fid >= 0
              If FirstItem(custommenu())
                Repeat
                  file_WriteLine{fid,custommenu()\itemname+",~,0,"+custommenu()\path+","+Str$(custommenu()\runwbmode)+","+Str$(custommenu()\stacksize)+","+Str$(custommenu()\prio)}
                Until NOT NextItem(custommenu())
              EndIf
            EndIf
            file_Close{fid}
            WZDisable "MENUED_SAVE"

          Case "MENUED_EXIT" : menued_exit = True
        End Select
    End Select
  Until menued_exit = True

  FlushEvents
  WZListRemove menuedlist
  WZCloseWindow WZID("WIN_MENUED")
  PED_SetPointerNormal{}
Return

.jump_historyup:
  Gosub storeline
  ped\historyPointer - 1
  If ped\historyPointer < 0 Then ped\historyPointer = #maxhistory
  PED_GotoLine{ped\historyTable[ped\historyPointer], #LINE_START}
Return

.jump_historydown:
  Gosub storeline
  ped\historyPointer + 1
  If ped\historyPointer > #maxhistory Then ped\historyPointer = 0
  PED_GotoLine{ped\historyTable[ped\historyPointer], #LINE_START}
Return

.jump_onclick:
  strline$ = PED_Detokenize{ped\ptrCurrentSourceData\CurrentSourceLine}
  If Instr(strline$,"{") > 0 Then statement_in_line.b = True

  actualword$ = PED_GetWordAtPos{strline$, ped\ptrCurrentSourceData\Column,True}
  actualword_len.w = Len(actualword$)
  If actualword_len < 2
    Pop If : Return
  EndIf

  clickjump_fromfile.b = 0
  jump_search:
  log_Print{"search for <" + actualword$ + ">"}

  linecounter.l = 0 : found_definition.b = False : found_to_jump.b = False
  *tempLine = ped\ptrCurrentSourceData\FirstSourceLine
  Repeat
    ;log_Print{Hex$(ped\ptrCurrentSourceData\CurrentSourceLine) + " " + Hex$(*tempLine) + "  " + Str$(linecounter + 1)}

    If *tempLine = ped\ptrCurrentSourceData\CurrentSourceLine
      ;log_Print{"skipping actual line <" + Str$(linecounter+1)+">"}
    Else
      char_before$ = ""
      found_definition = False

      ;-- check if it is the definition of a Statement/Function/Macro, we skip it!
      strline$ = StripLead$(Peek.s(*tempLine + 9),@" ")
      tokenID.l = Peek.w(&strline$) AND $FFFF
      Select tokenID
      Case #TOKEN_Statement : found_definition = True
      Case #TOKEN_Function : found_definition = True
      Case #TOKEN_Macro : found_definition = True
      End Select
      If found_definition Then strline$ = UnRight$(strline$,2)

      ;-- search for clicked word
      found_at.w = Instr(strline$, actualword$)
      If found_at > 0
        ;log_Print{"found_at: " + Str$(found_at) + " in line " + Str$(linecounter+1) + ":  " + strline$}
        If statement_in_line AND NOT found_definition Then Goto skip_jump
        If found_at > 1 Then char_before$ = Mid$(strline$,found_at-1,1)
        char_after$ = Mid$(strline$,found_at + actualword_len,1)
        ;log_Print{"before <" + char_before$ + "> after <" + char_after$ + ">" + Str$(linecounter+1) + "  "  +strline$}
        If CheckChr{char_after$, ":;{"} OR (char_before$=".")
          log_Print{"<" + actualword$ + "> found in line <" + Str$(linecounter + 1) + ">, jump!"}
          found_to_jump = True
        EndIf
        skip_jump:
      EndIf
    EndIf
    linecounter + 1
    *tempLine = *tempLine\nextLine
  Until found_to_jump OR (*tempLine = 0)

  If found_to_jump
    Pop If
    PED_HistoryAddEntry{}
    PED_GotoLine{linecounter-1,#LINE_START}
    Return
  EndIf

  ;-- nothing found in current source search in helpcache
  If clickjump_fromfile = 0
    clickjump_fromfile = 1
    PED_SetPointerBusy{}

    ;-- searching in help index for macro or function name
    found_in_cache.b = False
    If actualword$ <> ""
      log_Print{"definition not found in current source, searching in helpcache for <" + actualword$ + ">"}
      ResetList HelpIndexCache()
      While NextItemFast(HelpIndexCache()) AND found_in_cache = False
        If actualword$ = HelpIndexCache()\name OR actualword$ = HelpIndexCache()\includeFileName
          found_in_cache = True
        End If
      Wend

      If found_in_cache
        tmpStringVar = dos_AddPart{pedconfig\includeDir, HelpIndexCache()\includeFileName}
        log_Print{"found in HelpIndexCache(), will open it:" + tmpStringVar}
        !PED_LoadSource{tmpStringVar,False,True,True}
        PED_UpdateStatusArea{}
        PED_SetPointerNormal{}
        *currLine = ped\ptrCurrentSourceData\CurrentSourceLine
        ;-- jump upwards and search again in file ...
        Goto jump_search
      Else
        log_Print{"not found in cache"}
      EndIf
    EndIf
    PED_SetPointerNormal{}

  EndIf
Return

.open_helpdiag:
  If NOT WZ_IsOpen{"WIN_HELPDIAG"}
    WZWindow WZID("WIN_HELPDIAG"),?wzgui,80,wtemp\diag_x,wtemp\diag_y,wtemp\diag_w,wtemp\diag_h,WZID("WIN_HELPDIAG")
    WZ_AddMenuStrip{"WIN_HELPDIAG", ped\menuStrip}
  End If
  Gosub update_helpdiag
Return

.close_helpdiag:
  If WZ_IsOpen{"WIN_HELPDIAG"}
    Use Window WZID("WIN_HELPDIAG")
    wtemp\diag_x = WindowX
    wtemp\diag_y = WindowY
    wtemp\diag_w = WindowWidth
    wtemp\diag_h = WindowHeight
    WZ_CloseWindowAndRemoveMenu{"WIN_HELPDIAG"}
  EndIf
Return

.event_helpdiag:
  Select pedMessage\_Class
    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)
      Case "addcode"
        For i = 1 To 12
          diag_val$(i) = WZGetString("val" + UStr$(i))
        Next
        Gosub close_helpdiag

        tmpStringVar = diag_addstr$
        For i = 1 To 12
          tmpStringVar = tmpStringVar + diag_val$(i)
          If diag_val$(i + 1) <> "" Then tmpStringVar = tmpStringVar + ","
        Next

        Gosub activatesourcewindow
        PED_CursorOff{}
        tmpColumn.w = ped\ptrCurrentSourceData\Column
        tmpColumnsOffset.w = ped\ptrCurrentSourceData\ColumnsOffset

        PED_InsertStringToTextBuffer{tmpStringVar}

        ped\ptrCurrentSourceData\ColumnsOffset = tmpColumnsOffset
        ped\ptrCurrentSourceData\Column = tmpColumn
        PED_CursorOn{}

      Case "diagclear"
        For i = 1 To 12
          diag_val$(i) = ""
          WZPrint "val" + UStr$(i), diag_val$(i)
        Next
        WZ_ActivateGadget{"val1"}

      End Select

    Case #IDCMP_CLOSEWINDOW
      Gosub close_helpdiag

    Case #IDCMP_VANILLAKEY
      If pedMessage\_Code = #VANILLAKEY_ESC Then Gosub close_helpdiag

  End Select
Return

.update_helpdiag:
  If NOT WZ_IsOpen{"WIN_HELPDIAG"} Then Return

  strline$ = PED_Detokenize{ped\ptrCurrentSourceData\CurrentSourceLine}
  actualword$ = PED_GetWordAtPos{strline$, ped\ptrCurrentSourceData\Column,True}
  w$ = actualword$
  tokname$ = actualword$

  log_Print{"update_helpdiag, searching for [" + w$ + "]"}

  parlist.s = ""

  ;-- search in tokenlist
  parlist = PED_GetTokenHelp{w$}
  If parlist <> ""
    ;-- remove comments in helptext
    i = Instr(parlist, ";")
    If i Then parlist = Left$(parlist, i-1)
  End If

  diag_addcodesize.l = 0 : lineSize.l = 0
  If parlist <> ""
    log_Print{"found: " + parlist}
    Use Window WZID("WIN_HELPDIAG")

    tokname$ + " " + parlist
    WZPrint "DIAG_TOKEN",&tokname$

    ; build parameter table
    InitArgParse parlist
    For i =  1 To 12
      diag_lab$(i) = NextArgChar$ (@",")

      If  Left$(diag_lab$(i),1) = "(" Then diag_lab$(i) = UnRight$(diag_lab$(i),1)
      If Right$(diag_lab$(i),1) = ")" Then diag_lab$(i) =  UnLeft$(diag_lab$(i),1)
      If Right$(diag_lab$(i),1) = "[" Then diag_lab$(i) =  UnLeft$(diag_lab$(i),1)
      If Right$(diag_lab$(i),1) = "]" Then diag_lab$(i) =  UnLeft$(diag_lab$(i),1)
      If Right$(diag_lab$(i),2) = "][" Then diag_lab$(i)=  UnLeft$(diag_lab$(i),2)

      If diag_lab$(i) = "[" Then i = i - 1 : diag_lab$(i) + "["
      WZPrint "lab" + UStr$(i), &diag_lab$(i)
      diag_val$(i) = ""
      WZPrint "val" + UStr$(i), &diag_val$(i)
    Next

    lineStr.s = StripTrail$(Peeks$(ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset,#MAX_Columns),@" ")
    lineSize.l = FLen(lineStr)
    linePos.w = ped\ptrCurrentSourceData\Column
    If linePos > 0
      dFound.b = False
      Repeat
        lineChar.b = Peek.b(&lineStr+linePos)
        linePos + 1
        If lineChar = @" " OR lineChar = @"{" Then dFound = True
      Until lineChar < 0 OR linePos = lineSize OR dFound
      If NOT dFound
        dExit.b = False
        Repeat
          lineChar.b = Peek.b(&lineStr + linePos)
          linePos + 1
          If lineChar = @":" OR lineChar = @";" OR linePos = lineSize Then dExit = True
          If lineChar = @" " OR lineChar = @"{" OR lineChar = @"(" Then dFound = True
        Until dExit OR dFound
      EndIf
      If NOT dExit
        log_Print{"used pars: [" + Mid$(lineStr,linePos,lineSize-linePos) + "]"}
        parlist = Mid$(lineStr,linePos,lineSize-linePos)
        i.l = 0 : i2.l = 0
        Repeat
          w.l = PeekUB(&parlist + i)
          If w = $22 Then i2 BitChg 0
          If i2 = 0
            If w > $80 Then Poke.b &parlist + i, w BitClr 7
            If w = @";" OR w = @":" Then w = 0
          End If
          i + 1
        Until w = 0
        diag_addcodepos.l = linePos
        diag_addcodesize.l = i
        diag_addstr$ = ""
        If i Then parlist = Left$(parlist,i-1)
        If Peek.b(&parlist) = @"(" Then parlist = Right$(parlist,FLen(parlist)-1) : diag_addstr$ = "("
        If Peek.b(&parlist) = @"{" Then parlist = Right$(parlist,FLen(parlist)-1) : diag_addstr$ = "{"
        InitArgParse parlist
        For i = 1 To 12
          diag_val$(i) = NextArgChar$(@",","{[(\\22",")]}\\22")
          If diag_lab$(i) <> "" Then WZPrint "val" + UStr$(i), &diag_val$(i)
        Next
      EndIf
    EndIf
  EndIf
Return



.help_checkfortype:
  typestr$ = ""
  tmpColumn.w = ped\ptrCurrentSourceData\Column - 2
  If tmpColumn < 0 Then tmpColumn = 1

  lineAddr.l = ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset + ped\ptrCurrentSourceData\Column
  lineAddrStore.l = lineAddr
  log_Print{"check current char <" + Chr$(Peek.b(lineAddr)) + "> for type help"}

  If Peek.b(lineAddr-1) = @"\"
    lineAddr - 1
  Else
    If Peek.b(lineAddr) <> @"\"
      log_Print{"no \ found nearby."}
      Return
    EndIf
  EndIf

  ; -- skip spaces
  Repeat
    lineAddr - 1
  Until Peek.b(lineAddr) <> @" " OR (lineAddr = lineAddrStore)

  ; -- skip brackets if we have an array
  If Peek.b(lineAddr) = @")"
    log_Print{"skipping array brackets"}
    Repeat
      lineAddr - 1
    Until Peek.b(lineAddr) = @"(" OR (lineAddr = lineAddrStore)
  EndIf

  ; -- skip characters not allowed for typedefs
  actbyte.b = Peek.b(lineAddr)
  If actbyte <> @"_" AND actbyte < @"0" AND (actbyte < @":" OR actbyte < @"A") OR actbyte > @"z"
    log_Print{"no printable character found, exiting help routine for type"}
    Goto exit_checkfortype
  EndIf

  ; -- skip illegal characters
  type_again:
  Repeat
    lineAddr - 1
  Until !IsIllegalChar{Peek.b(lineAddr)} OR (lineAddr = lineAddrStore)
  If Peek.b(lineAddr) = @"*" Then Goto type_again

  ; -- we have dot, that means the typename is right here!
  If Peek.b(lineAddr) = @"."
    log_Print{"we have a dot, so the typename is right here:" + Peeks$(lineAddr,10)+ "..."}
    PED_UpdateDefinitionBrowser{#DEFBROWSER_SELECTTYPE,Peek.s(lineAddr),True}
    Return
  EndIf

  ;----------------------------------------------------------------------------------
  ; -- no dot we have to determine the type by searching for type definitions in previous code
  log_Print{"no dot, searching for type defintions in previous code"}
  typestr$ = ""
  ; -- skip illegal characters again
  lineAddr + 1
  While !IsIllegalChar{Peek.b(lineAddr)} = False OR Peek.b(lineAddr) = @"*"
    typestr$ + Chr$(Peek.b(lineAddr))
    lineAddr + 1
  Wend

  log_Print{"this is what we have so far as the variable name: [" + typestr$ + "]"}
  ;-- try to get the type
  typestr$ = PED_GetDefinitionOf{typestr$}
  If typestr$ <> ""
    log_Print{"type [" + typestr$ + "] found, showing in Browser..."}
    PED_UpdateDefinitionBrowser{#DEFBROWSER_SELECTTYPE, typestr$, True}
  Else
    If PED_GetVariableByName{typestr$}
      log_Print{"variable found, showing in Browser..."}
      PED_UpdateDefinitionBrowser{#DEFBROWSER_VARIABLE, typestr$, True}
    EndIf
  EndIf
  If typestr$ = ""
    log_Print{"no type or var information found."}
  EndIf

  exit_checkfortype:
Return

.help_checkforif:
  *tempLine.sourceLine = ped\ptrCurrentSourceData\CurrentSourceLine
  nestcount.b = 1
  bytecount.w = 0
  Repeat
    iffound.b = 0
    *textline.l = *tempLine + 9

    ; kill any spaces before Token
    testaddr.l = Peek.l(*textline) : bytecount = 0
    While (testaddr LSR 16) <> $0000
      testaddr = Peek.l(*textline + bytecount)
      actword.w = testaddr LSR 16

      ;-- check the token for parts of an if-loop
      Select actword
      Case #TOKEN_EndIf : nestcount + 1
      Case #TOKEN_If    : nestcount - 1
        iffound  = 1
      Case #TOKEN_Then  : nestcount + 1
      End Select

      bytecount + 1
    Wend
    If (nestcount = 1) Then Pop Repeat : Goto foundif

    ; get previous line pointer
    *tempLine = *tempLine\nextLine
  Until *tempLine = 0
  foundif:
  If (iffound = 1)
    strline$ = PED_Detokenize{*tempLine}
    strline$ = Trim$(strline$)
    PED_ShowMessage{"Corresponding Header: " + strline$}
  EndIf
Return

.close_contexthelp:
  If WZ_IsOpen{"WIN_CONTEXTHELP"}
    WZListRemove helpme.List
    WZCloseWindow WZID("WIN_CONTEXTHELP")
  EndIf
Return

.close_popupwindow:
  If pedconfig\intellisense
    If WZ_IsOpen{"WIN_POPUP"}
      WZ_PopUpCloseNonmodal{}   ; move the code to the new include function  tomsmart1
      popup_selected.l = 0
    EndIf
  EndIf
Return

.open_librarybrowser:
  If NOT WZ_IsOpen{"WIN_LIBRARYBROWSER"}
    USEPATH wtemp
    WZWindow WZID("WIN_LIBRARYBROWSER"),?wzgui,255,\lbrowser_x,\lbrowser_y,\lbrowser_w,\lbrowser_h,WZID("WIN_LIBRARYBROWSER")
    WZ_AddMenuStrip{"WIN_LIBRARYBROWSER", ped\menuStrip}
    Use Window WZID("WIN_LIBRARYBROWSER")
    WZ_InitTable{"WIN_LIBRARYBROWSER","FUNCTIONSTABLE",2}
    WZ_SetTableTitle{"FUNCTIONSTABLE","Function","Syntax"};,"Library"}
    WZ_SetPriority{"FUNCTIONSTABLE",2,3}
    WZ_DrawTable{"FUNCTIONSTABLE"}
  EndIf

  Gosub update_librarylist
  Gosub update_functiontable
  Activate WZID("WIN_LIBRARYBROWSER")
  WZ_UpdateTable{"FUNCTIONSTABLE"}
Return


.event_librarybrowser:
  ;-- check for events occured with the functiontable
  wev.l = WZ_CheckTableEvent{pedMessage\_Class}
  Select wev

    Case #WZTABLEEVENT_CELLSELECTED
      pos.l = WZ_Row{"FUNCTIONSTABLE"}
      actualword$ = WZ_GetCell{"FUNCTIONSTABLE",WZ_Row{"FUNCTIONSTABLE"},1}
      If actualword$ <> ""
        libinfo$ = blitzlibMapping(libnumber.l,0) 
        libinfo$ + " (LibNr. " + Str$(libnumber)
        libinfo$ + " Token " + Hexw$(PED_GetTokenID{actualword$}) + ")"
        WZPrint "ARGS_LIBRARYNAME",&libinfo$
      EndIf

    Case #WZTABLEEVENT_DOUBLECLICK
      pos = WZ_Row{"FUNCTIONSTABLE"}
      actualword$ = WZ_GetCell{"FUNCTIONSTABLE",WZ_Row{"FUNCTIONSTABLE"},1}
      If actualword$<>""
        Gosub startGuide
      EndIf
  End Select

  Select pedMessage\_Class
    Case #IDCMP_CLOSEWINDOW:
      Gosub close_librarybrowser

    Case #IDCMP_VANILLAKEY:
      Select pedMessage\_Code
      Case #VANILLAKEY_ESC : Gosub close_librarybrowser
      Case #VANILLAKEY_TAB : Gosub activatesourcewindow
      Default
        ;log_Print{Chr$(pedMessage\_Code) + " - " + Str$(pedMessage\_Code)}
        libslistStartChar.s = Chr$(pedMessage\_Code)
        Gosub update_librarylist
        Gosub update_functiontable
      End Select

    Case #IDCMP_IDCMPUPDATE
      Select WZGadName

        Case "LIST_LIBRARIES"
          Gosub update_functiontable

        Case "CYCLE_SORTORDER"
          Gosub update_librarylist
          Gosub update_functiontable

        Case "BUTTON_LIB_FREEIDS"
          message$ = !TRANS{"The following lib-IDs are not in use:"}+"\\n\\n"
          For i = 1 To (#MAX_Blitzlibs-1)             ; replaced hardcoded 255 with (#MAX_Blitzlibs-1) because we start with 0  tomsmart1
            If Instr(blitzlibMapping(i,0),"unused")<>0
              message$ + Str$(i)+ "  "
            EndIf
          Next i
          WZ_LockWindow{"WIN_LIBRARYBROWSER"}
          dummy.l = ask{message$,!TRANS{"Ok"},!TRANS{"Info"}}
          WZ_UnlockWindow{"WIN_LIBRARYBROWSER"}

        Case "BUTTON_LIB_CHECK_CONSISTENCY"
          WZ_LockWindow{"WIN_LIBRARYBROWSER"}

          WZ_ShowMessage{!TRANS{"Checking BlitzLib consistency..."},1}

          tmpStringVar = ""
          libID.l = 0 : olibID.l = 0

          *token.tokendata = *tokenbase
          Repeat
            libID.l = (*token\number LSR 7)
            
            ;-- skip internal systemlib and dhandlerlib (Ids 0 and 1)
            If (libID.l <> olibID.l) AND (libID > 1) 
              For i = 0 To (#MAX_Blitzlibs-1)
                If blitzlibMapping(i,1) = Peek.s(&*token\dat)
                  old_libname.s = StripTrail$(UnRight$(blitzlibMapping(i,0),Instr(blitzlibMapping(libID,0),"with ")+4),@")")
                  Pop If : Pop For : Goto exit_for2
                EndIf
              Next i
              log_Print{"nothing found for token [" + Peek.s(&*token\dat) + "], libID #" + Str$(libID)}
              exit_for2:
              error_libname.s = Left$(blitzlibMapping(libID,0),Instr(blitzlibMapping(libID,0)," ")-1)
              tmpStringVar + "+ " + old_libname + " has been overwritten by\\n"
              tmpStringVar + "\\22" + error_libname + "\\22 with same LibID: "+Str$(libID)+"\\n\\n"

              olibID = libID
              !WZ_GaugeInfo{&blitzlibMapping(libID,0)}
            EndIf
            *token = *token\next_token
          Until (*token = 0)

          WZ_HideMessage{}
          If tmpStringVar = ""
            tmpStringVar = !TRANS{"The internal library structure seems to be correct."}
          EndIf
          dummy.l = ask{tmpStringVar,!TRANS{"Ok"},!TRANS{"Info"}}

          WZ_UnlockWindow{"WIN_LIBRARYBROWSER"}
      End Select
  End Select
Return

.close_librarybrowser:
  If WZ_IsOpen{"WIN_LIBRARYBROWSER"}
    WZ_KillTable{"FUNCTIONSTABLE"}
    WZ_CloseWindowAndRemoveMenu{"WIN_LIBRARYBROWSER"}
  EndIf
  WZListRemove libslist.List
Return

.update_librarylist:
  sortorder.b = WZInput("CYCLE_SORTORDER")
  WZListRemove libslist.List
  Format "000"
  For i = 0 To (#MAX_Blitzlibs-1)
    If Instr(blitzlibMapping(i,0),"unused") = 0
      If sortorder = 0
        listvalue.s = LCase$(blitzlibMapping(i,0))
      Else
        listvalue.s = Str$(i) +  " | " + LCase$(blitzlibMapping(i,0))
      EndIf
      WZListAdd libslist,listvalue,-1,i
    EndIf
  Next i
  Format ""

  ;-- jump to first library beginning with selected character
  If libslistStartChar <> "" AND sortorder = 0
    For i = 0 To WZListItems(libslist)
      If libslistStartAt.w = 0 AND libslistStartChar = Left$(WZListString(libslist,i,1),1)
        libslistStartAt = i
      EndIf
    Next i
  Else
    libslistStartAt = 0
  EndIf

  WZPrint "LIST_LIBRARIES",libslistStartAt,libslist,libslistStartAt
  libslistStartAt = 0
Return


.update_functiontable:
  selected.l = WZInput("LIST_LIBRARIES")
  libnumber = WZListData(libslist,selected)
  libinfo$ = blitzlibMapping(libnumber,0) + " (LibNr. " + Str$(libnumber) + ")"
  WZPrint "ARGS_LIBRARYNAME",&libinfo$

  WZ_ClearTable{"FUNCTIONSTABLE"}

  If *tokenbase
    *token.tokendata = *tokenbase
    Repeat
      If (*token\number LSR 7) = libnumber
        token_name.s = Peek.s(&*token\dat)
        token_help.s = Peek.s(&*token\dat + FLen(token_name) + 1)
        WZ_AddRow{"FUNCTIONSTABLE", token_name, token_help}
        ;log_Print{token_name +  "   " + token_help}
      EndIf
      *token = *token\next_token
    Until *token = 0
  EndIf

  WZ_TableSort{"FUNCTIONSTABLE",1}
  WZ_UpdateTable{"FUNCTIONSTABLE"}
Return


.open_instructionbrowser
  Gosub close_popupwindow
  If NOT WZ_IsOpen{"WIN_INSTRUCTIONBROWSER"} ; thilo: why this was commented out!?
    WZWindow WZID("WIN_INSTRUCTIONBROWSER"),?wzgui,255,wtemp\ibrowser_x,wtemp\ibrowser_y,wtemp\ibrowser_w,wtemp\ibrowser_h,WZID("WIN_INSTRUCTIONBROWSER")
    WZ_AddMenuStrip{"WIN_INSTRUCTIONBROWSER", ped\menuStrip}
    If search_instruction$<>"" Then WZPrint "INSTRUCTION_STRING",search_instruction$
    WZPrint "macros",browse_macros
    WZPrint "instr",browse_instructions
    WZPrint "incdir",browse_includes
    WZ_InitTable{"WIN_INSTRUCTIONBROWSER","INSTRUCTIONTABLE",2}
    WZ_SetTableTitle{"INSTRUCTIONTABLE","Function","Syntax"};,"Library"}
    WZ_SetPriority{"INSTRUCTIONTABLE",2,3}
    WZ_DrawTable{"INSTRUCTIONTABLE"}
    previoussearch_instruction$="|"
    Gosub update_instructiontable
  Else
    Use Window WZID("WIN_INSTRUCTIONBROWSER")
    Activate WZID("WIN_INSTRUCTIONBROWSER")
    WZ_UpdateTable{"INSTRUCTIONTABLE"}
    WZPrint "INSTRUCTION_STRING",search_instruction$
  End If
  WZ_ActivateGadget{"INSTRUCTION_STRING"}
Return


.event_instructionbrowser:
  ; check for events occured with the instructiontable
  wev.l = WZ_CheckTableEvent{pedMessage\_Class}
  Select wev

    Case #WZTABLEEVENT_CELLSELECTED
      b$ = WZ_GetCell{"INSTRUCTIONTABLE",WZ_Row{"INSTRUCTIONTABLE"},1}
      bstr$ = b$
      *token.tokendata = *tokenbase
      While *token
        If b$ = Peek.s(&*token\dat) Then Pop While: Goto tfound
        *token = *token\next_token
      Wend

     tfound:
      If *token
        tokenNumber.w = *token\number
        iinfo$ = "Library: " + PED_GetLibname{tokenNumber LSR 7}
        iinfo$ + " - LibNr.: " + Str$(tokenNumber LSR 7) + " - TokenNr: " + Str$((tokenNumber AND $7f)-1) + " - TokenId: $" + Hexw$(tokenNumber)
      Else
        iinfo$ = "Include: " + PED_GetIndexHelp{bstr$, #INDEXHELP_FILE}
      EndIf
      WZTags #WARGSA_TextPen,2
      WZPrint "INSTRUCTION_INFO",&iinfo$

    Case #WZTABLEEVENT_DOUBLECLICK
      pos = WZ_Row{"INSTRUCTIONTABLE"}
      actualword$ = WZ_GetCell{"INSTRUCTIONTABLE",WZ_Row{"INSTRUCTIONTABLE"},1}
      Gosub startGuide

  End Select

  Select pedMessage\_Class

    Case #IDCMP_INTUITICKS
      Gosub update_instructiontable

    Case #IDCMP_CLOSEWINDOW:
      Gosub close_instructionbrowser

    Case #IDCMP_RAWKEY:
      ;error{"RAW: " + Hexw$(pedMessage\_Code)}

    Case #IDCMP_VANILLAKEY:
      ;error{"VAN: " + Hexw$(pedMessage\_Code)}
      Select pedMessage\_Code
      Case #VANILLAKEY_ESC : Gosub close_instructionbrowser
      Case #VANILLAKEY_TAB : Gosub activatesourcewindow
      End Select

    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "add" ;add to code
          tmpStringVar = Trim$(bstr$)
          If tmpStringVar <> ""
            log_Print{"adding to code: " + tmpStringVar}
            PED_InsertStringToTextBuffer{tmpStringVar}
            Gosub activatesourcewindow
          EndIf

        Case "macros"
          browse_macros = WZInput
          previoussearch_instruction$ = "|"
          WZ_ActivateGadget{"INSTRUCTION_STRING"}

        Case "instr"
          browse_instructions = WZInput
          previoussearch_instruction$ = "|"
          WZ_ActivateGadget{"INSTRUCTION_STRING"}

        Case "incdir"
          browse_includes = WZInput
          previoussearch_instruction$ = "|"
          WZ_ActivateGadget{"INSTRUCTION_STRING"}
      End Select

  End Select
Return

.close_instructionbrowser:
  If WZ_IsOpen{"WIN_INSTRUCTIONBROWSER"}
    wtemp\ibrowser_x = WindowX
    wtemp\ibrowser_y = WindowY
    wtemp\ibrowser_w = WindowWidth
    wtemp\ibrowser_h = WindowHeight
    WZ_KillTable{"INSTRUCTIONTABLE"}
    WZ_CloseWindowAndRemoveMenu{"WIN_INSTRUCTIONBROWSER"}
  EndIf
Return

.update_instructiontable:
  search_instruction$ = WZGetString("INSTRUCTION_STRING")
  If (search_instruction$ <> previoussearch_instruction$) AND (Len(search_instruction$) > 1)
    previoussearch_instruction$ = search_instruction$
    WZ_ClearTable{"INSTRUCTIONTABLE"}
    InitArgParse search_instruction$
    word1$ = NextArg$
    word2$ = NextArg$
    instruction_counter.l = 0
    CaseSense Off
    If browse_instructions
      log_Print{"instruction browser: searching for token <" + word1$ + "/" + word2$+ ">"}
      *token.tokendata = *tokenbase
      While *token
        token_name.s = Peek.s(&*token\dat)
        If Instr(token_name, word1$) AND instruction_counter < #maxlabels
          token_help.s = Peek.s(&*token\dat + FLen(token_name) + 1)
          If Instr(token_help, word2$)
            instruction_counter = instruction_counter + 1
            WZ_AddRow{"INSTRUCTIONTABLE",token_name, token_help}
            If PED_CheckForClassicToken{*token\number} Then WZ_SetRowPen{"INSTRUCTIONTABLE",AB3Pen(#AB3_cclassic),0}
          EndIf
        EndIf
        *token = *token\next_token
      Wend
    EndIf

    If browse_macros
      log_Print{"instruction browser: searching for macro <" + word1$ + ">"}
      *macroP.l = *macrobase
      c.l = 0
      While *macroP
        macro_name.s = Peek.s(*macroP + 13)
        If Instr(macro_name, word1$) AND instruction_counter < #maxlabels
          If Instr(macro_name, word2$)
            instruction_counter = instruction_counter + 1
            i = Peek.w(*macroP + 8)
            If i > 90 Then i = 90
            macro_name = "!" + macro_name
            macro_help.s = Peeks$(Peek.l(*macroP + 4),i)
            WZ_AddRow{"INSTRUCTIONTABLE", macro_name, macro_help}
          End If
        End If
        *macroP = Peek.l(*macroP)
      Wend
    End If

    If browse_includes
      ResetList HelpIndexCache()
      While NextItemFast(HelpIndexCache())
        If Instr(HelpIndexCache()\name, word1$) AND instruction_counter < #maxlabels
          If Instr(HelpIndexCache()\name, word2$)
            instruction_counter = instruction_counter + 1
            WZ_AddRow{"INSTRUCTIONTABLE",HelpIndexCache()\name,HelpIndexCache()\helpText}
          End If
        End If
      Wend
    End If
    CaseSense On
    pos = 0
    WZ_TableSort{"INSTRUCTIONTABLE",1}
    WZ_UpdateTable{"INSTRUCTIONTABLE"}
  Else
    If (search_instruction$<>previoussearch_instruction$) AND (Len(search_instruction$)<2)
      previoussearch_instruction$ = search_instruction$
      WZ_ClearTable{"INSTRUCTIONTABLE"}
     WZ_UpdateTable{"INSTRUCTIONTABLE"}
    EndIf
  End If
Return

.event_popup:
  log_Print{"processing popup event " + Hex$(pedMessage\_Class)}
  popexit.l = False
                                                ; added to set the init value that fix the bug that after select a item with a doubleclick the next popup win are autoclosed  tomsmart1
  Select pedMessage\_Class
    Case #IDCMP_IDCMPUPDATE
      If Left$(WZGadName,9) = "POPUPMENU"
        popup_selected = WZInput + 1
        popexit = True
      EndIf

    Case #IDCMP_RAWKEY
      log_Print{"RAWKEY " + Hex$(pedMessage\_Code)}
    Case #IDCMP_MOUSEBUTTONS
;      mb.b = MButtons
;      If (mb = 1) OR (mb=2)
;         popexit = True
;      EndIf
  End Select

  If popexit = True
    tmpStringVar = WZ_GetPopUpEntry{popup_selected}
    ;log_Print{"selected: " + tmpStringVar}
    brackpos.w = Instr(tmpStringVar,"{")
    If brackpos > 0
      tmpStringVar = Trim$(Left$(tmpStringVar,brackpos-1))
      tmpStringVar = UnRight$(tmpStringVar,Len(poptok$)) + "{"
    Else
      tmpStringVar = UnRight$(tmpStringVar,Len(poptok$))
    EndIf
    ;log_Print{"inserting: " + tmpStringVar}
    PED_InsertStringToTextBuffer{tmpStringVar}
    PED_ShowMessage{tmpStringVar + " " + PED_GetIndexHelp{tmpStringVar, #INDEXHELP_HELP} }    ; removed tmpStringVar test because it is not needed  tomsmart1
    Gosub close_popupwindow
  EndIf
  Gosub activatesourcewindow                                ; always active sourcewin if a popupwin event happend like mouse click or scroll  tomsmart1
Return


.startGuide   ;actualword$: zu suchende Funktion

  PED_ShowMessage{!TRANS{"Searching help for <" + actualword$ + ">"}}

  *token.tokendata = PED_GetTokenPointer{actualword$}
  If *token
    libnumber = *token\number LSR 7
    If Right$(actualword$,1) = "_"
      actualword$ = Left$(actualword$,FLen(actualword$) - 1)
      helpdir$ = pedconfig\autodocDir
    EndIf
    libname$ = blitzlibMapping(libnumber,0)

    ;-- check if library has an number extention (e.g. for libraries that have more than 128 tokens)
    mostright$ = Right$(libname$,1)
    If mostright$ = "1" OR mostright$ = "2" Then libname$ = Left$(libname$,FLen(libname$)-1)
  Else
    libname$ = PED_GetIndexHelp{actualword$, #INDEXHELP_FILE}
  EndIf

  If (libname$ <> "") AND Instr(libname$,"unused") = 0
    Show_Helpfile{libname$, actualword$, helpdir$}
  Else
    search_instruction$ = actualword$
    Gosub open_instructionbrowser
    ;dummy.l = ask{"No help available",!TRANS{"Ok"},!TRANS{"Info"}}
  EndIf

  PED_ShowMessage{""}
Return


.open_shortcuts
  If NOT WZ_IsOpen{"WIN_SHORTCUTS"}
    WZWindow WZID("WIN_SHORTCUTS"),?wzgui,255,wtemp\short_x,wtemp\short_y,wtemp\short_w,wtemp\short_h,WZID("WIN_SHORTCUTS")
    WZ_AddMenuStrip{"WIN_SHORTCUTS", ped\menuStrip}

    WZ_InitTable{"WIN_SHORTCUTS","SHORTCUTS",2}
    WZ_SetPriority{"SHORTCUTS",1,2}
    WZ_SetTableReadOnly{"SHORTCUTS",True}        ; disabled row selection
    WZ_SetEditable{"SHORTCUTS",False,False}      ; disabled editing of the table  tomsmart1
    WZ_SetSortable{"SHORTCUTS",False}            ; disabled sorting for the table  tomsmart1
    ; update keys and changed order  tomsmart1
    WZ_SetTableTitle{"SHORTCUTS",!TRANS{"Key"}                       ,!TRANS{"Function"}}
           WZ_AddRow{"SHORTCUTS",       "Navigation"           ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+LeftArrow"}             ,!TRANS{"Go Back in history"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+RightArrow"}            ,!TRANS{"Go Forward in history"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+Left Mousebutton"}      ,!TRANS{"Jump to Label/Func-Definition"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+Middle Mousebutton"}    ,!TRANS{"Back from Label/func"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+UpArrow"}              ,!TRANS{"Jump to first line"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+DownArrow"}            ,!TRANS{"Jump to last line"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+LeftArrow"}            ,!TRANS{"Move cursor to start of word"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+RightArrow"}           ,!TRANS{"Move cursor to end of word"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+A"}                 ,!TRANS{"Jump to the last line in that something was added"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+SHIFT+1-3"}         ,!TRANS{"Set bookmark 1-3"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+1-3"}               ,!TRANS{"Jump to bookmark 1-3"} }

           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",       "Edit"               ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+X"}                    ,!TRANS{"CUT same as <AMIGA>+<X>"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+C"}                    ,!TRANS{"COPY vertical, all select lines only copyed at the select column"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+V"}                    ,!TRANS{"PASTE vertical, all lines pasted at the cursor column"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+U"}                    ,!TRANS{"undo delete current line"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+UpArrow"}               ,!TRANS{"Move Line Up"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+DownArrow"}             ,!TRANS{"Move Line Down"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+E"}                    ,!TRANS{"Insert 'End If'"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+F"}                    ,!TRANS{"Insert a 'Function' skeleton"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+N"}                    ,!TRANS{"Insert a 'Newtype' skeleton"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+S"}                    ,!TRANS{"Insert a 'Statement' skeleton"} }

           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+RightArrow on block"}  ,!TRANS{"TAB marked Block"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+LeftArrow on block"}   ,!TRANS{"Un-TAB marked Block"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+SHIFT+UpArrow"}        ,!TRANS{"Extend blockmark upwards"}   }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+SHIFT+DownArrow"}      ,!TRANS{"Extend blockmark downwards"} }

           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",       "Help"                 ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP+SHIFT"}                ,!TRANS{"Opens guide/autodoc of instruction under cursor"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP+CTRL"}                 ,!TRANS{"Opens parameter diagnostic for actual function"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP on any function"}      ,!TRANS{"Displays correct syntax in screens titlebar"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP on '\'"}               ,!TRANS{"Opens window 'type browser' and shows newtype information"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"HELP on 'EndIf'"}           ,!TRANS{"Shows corresponding IF-Blockheader"} }

           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",       "Editor-Actions"       ,       ""}
           WZ_SetRowPen{"SHORTCUTS",-1,-1,#FSF_BOLD}
           WZ_AddRow{"SHORTCUTS",!TRANS{"TAB"}                       ,!TRANS{"Activates sourcewindow"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"ESC"}                       ,!TRANS{"Closes any active helpwindow"} }
           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",!TRANS{"ALT+Click on filename"}     ,!TRANS{"Save and compile and run"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+Click on filename"}    ,!TRANS{"Save and create exe (save both if you click on different)"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"CTRL+I"}                    ,!TRANS{"Switch Intellisense for Commands 'on/off' if Intellisens is enabled"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"L-Amiga+F4-F6"}             ,!TRANS{"save winconfig"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F4-F6"}                     ,!TRANS{"load winconfig (F4 also startconfig)"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F7"}                        ,!TRANS{"window autolayout variant #1"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F8"}                        ,!TRANS{"window autolayout variant #2"} }
           WZ_AddRow{"SHORTCUTS",       "####"                       ,       "####"}
           WZ_AddRow{"SHORTCUTS",!TRANS{"F9"}                        ,!TRANS{"goto previous document"} }
           WZ_AddRow{"SHORTCUTS",!TRANS{"F10"}                       ,!TRANS{"goto next document"} }
    WZ_DrawTable{"SHORTCUTS"}
    WZ_UpdateTable{"SHORTCUTS"}
  EndIf
Return


.event_shortcuts:
  wev.l = WZ_CheckTableEvent{pedMessage\_Class}
  Select pedMessage\_Class
    Case #IDCMP_VANILLAKEY:
      If pedMessage\_Code = #VANILLAKEY_ESC Then Gosub close_shortcuts
      If pedMessage\_Code = #VANILLAKEY_TAB Then Gosub activatesourcewindow

    Case #IDCMP_CLOSEWINDOW
      Gosub close_shortcuts
  End Select
Return

.close_shortcuts:
  If WZ_IsOpen{"WIN_SHORTCUTS"}
    WZ_KillTable{"SHORTCUTS"}
    WZ_CloseWindowAndRemoveMenu{"WIN_SHORTCUTS"}
  EndIf
Return


.open_cliarguments
  *clistringptr.l = Peek.l(?comPtr_CLIArgumentsString)
  If *clistringptr >< 0
    clistr.s = Peek.s(*clistringptr)
  Else
    Return
  End If
  old_clistr.s = clistr
  ;FindScreen 0
  WZWindow WZID("WIN_CLIARGUMENTS"),?wzgui,64,-1,-1,-1,-1,WZID("WIN_CLIARGUMENTS")
  If clistr<>"" Then WZPrint "CLI_ARGUMENTS",&clistr
  WZ_ActivateGadget{"CLI_ARGUMENTS"}
  exit_cli.b = False : get_arguments.b = False

  Repeat
    ev.l = WaitEvent

    ; context onlinehelp for most windows
   ; If onlinehelp <> 0
   ;   If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) AND (ev<>#IDCMP_GADGETHELP)  AND (ev<>#IDCMP_CHANGEWINDOW)
   ;     WZ_HideBubble{}
   ;   EndIf
   ;   If ev = #IDCMP_GADGETHELP Then WZ_ShowBubble{}
   ; EndIf

    Select ev

      Case #IDCMP_CLOSEWINDOW
        exit_cli = True

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName

;          Case "CLI_ARGUMENTS"
;            get_arguments = True

          Case "CLI_OK"
            exit_cli = True
            get_arguments = True

          Case "CLI_CANCEL"
            get_arguments = False
            exit_cli = True

        End Select

      Default
        WZ_ActivateGadget{"CLI_ARGUMENTS"}

    End Select

  Until exit_cli = True

  If get_arguments = True
    clistr = WZGetString("CLI_ARGUMENTS")
    Poke.s *clistringptr,Left$(clistr,127)
  Else
    clistr = old_clistr
  EndIf
  WZCloseWindow WZID("WIN_CLIARGUMENTS")
  FlushEvents
  Gosub activatesourcewindow
Return



.open_calculator:
  calc_expression.s = ""
  !ComData_GetL{comPtr_CalculatorExpressionString,D0} : CalculatorExpressionStringPointer.l = PutD0
  Poke.s CalculatorExpressionStringPointer,calc_expression
  If Peek.l(Addr Window(WZID("WIN_CALCULATOR")))=0
    WZWindow WZID("WIN_CALCULATOR"),?wzgui,128,-2,-2,-2,-2,WZID("WIN_CALCULATOR")
    !ComData_SetW{comWord_CalculatorButtonBinFlag,#$00}
    !ComData_SetW{comWord_CalculatorButtonDecFlag,#$80}

    ;event_Calculator
    calc_exit.l = False
    calc_test.l = False
    Repeat
     WZ_ActivateGadget{"CALC_EXPRESSION"}
     ev_calculator.l = WaitEvent

      Select ev_calculator
        Case #IDCMP_VANILLAKEY:
          If pedMessage\_Code = #VANILLAKEY_ESC Then calc_exit = True

        Case #IDCMP_CLOSEWINDOW
          calc_exit = True

        Case #IDCMP_IDCMPUPDATE
          Select WZGadName

            Case "CALC_CLOSE"
              calc_exit = True

            Case "CALC_EXPRESSION"
              calc_expression = WZGetString("CALC_EXPRESSION")

            Case "BIN"
              !ComData_SetW{comWord_CalculatorButtonBinFlag,#$80}
              !ComData_SetW{comWord_CalculatorButtonDecFlag,#$00}
              calc_test = True

            Case "HEX"
              !ComData_SetW{comWord_CalculatorButtonBinFlag,#$00}
              !ComData_SetW{comWord_CalculatorButtonDecFlag,#$00}
              calc_test = True

            Case "DEC"
              !ComData_SetW{comWord_CalculatorButtonBinFlag,#$00}
              !ComData_SetW{comWord_CalculatorButtonDecFlag,#$80}
              calc_test = True

          End Select

          ;-- test if the string is not longer than 128 byte because this is the limit that is set in the compiler source
          If FLen(calc_expression) < 128
            If (calc_expression<>"") AND (calc_exit = False)
              If (calc_expression<>Peek.s(CalculatorExpressionStringPointer) ) OR (calc_test = True)
                Poke.s CalculatorExpressionStringPointer,calc_expression
                !asm
                !ComData_JSR{comFunc_CalculatExpression} ;examine_expression
                !basic
                calc_expression = Peek.s(CalculatorExpressionStringPointer)
                WZPrint "CALC_EXPRESSION",&calc_expression
              EndIf
              calc_test = False
            EndIf
          Else
            error{!TRANS{"The expression is too long, max 127 characters allowed!"} }
         EndIf

      End Select

    Until calc_exit

    WZCloseWindow WZID("WIN_CALCULATOR")
    FlushEvents
    Gosub activatesourcewindow
  EndIf
Return


.open_definitionbrowser:
  PED_UpdateDefinitionBrowser{#DEFBROWSER_RESET,"",True}
  WZ_ActivateGadget{"STRING2"}
Return


.event_definitionbrowser:

  tev.l = WZ_CheckTableEvent{pedMessage\_Class}
  If tev = #WZTABLEEVENT_DOUBLECLICK
    Select ped\definitionMode
      Case 0 ; Constants
        selectedDefEntry.s = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},1}
        typestr$ = selectedDefEntry
        WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
        WZPrint "NEWTYPE_ENTRY",&typestr$

      Default
        selectedDefEntry = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},1}

        c2$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},2}
        If c2$ <> "" Then c2$ = " ." + c2$

        c3$ = WZ_GetCell{"TYPETABLE",WZ_Row{"TYPETABLE"},3}
        If c3$ <> "" Then c3$ = " $" + c3$

        selectedDefEntry + c2$ + c3$

        log_Print{"selected type: " + selectedDefEntry}

        If ped\definitionMode = 1 AND lev  = 0
          i = SearchEnd (selectedDefEntry,@".",1)
          If lev = 0 Then selectedVarName.s = Left$(selectedDefEntry,i - 1)
          selectedDefEntry = Mid$(selectedDefEntry,i + 1)
        EndIf

        If ped\definitionMode <> 1 Then selectedVarName = ""

        tmpStringVar = selectedDefEntry

        lev = lev + 1 : If lev > 13 Then lev = 13

        pos2(lev) = 0
        pos2(lev-1) = WZ_Row{"TYPETABLE"}

        ped\previousNewtypeStr = Left$(tmpStringVar,Instr(tmpStringVar," ")-1)

        If lev > 1
          i = SearchEnd(tmpStringVar, @".", 1)
          i2 = SearchEnd(tmpStringVar, @"$", 1)
          tmpStringVar = Mid$(tmpStringVar, i+1, i2-i-3)
        EndIf

        log_Print{"search for type: " + tmpStringVar + " - " + ped\previousNewtypeStr}
        newtype_found = 0
        *nt.l = *newtypebase
        If *nt = 0
          error{"newtypebase = NULL => GURU!!!"}
        Else
          *nt = Peek.l(*nt)
          While *nt AND newtype_found = False
            If Peek.s(*nt + 11) = tmpStringVar
              log_Print{"Found the type in newtypes-list [" + tmpStringVar + "]"}
              PED_UpdateDefinitionBrowser{#DEFBROWSER_SELECTTYPE, tmpStringVar}
              newtype_found = 1
            EndIf
            *nt = Peek.l(*nt)
          Wend
        EndIf

        If newtype_found = 0
          lev = lev - 1
          tmpStringVar = ""
          For i = 1 To lev
            If i > 1
               tmpStringVar = tmpStringVar + "\" + pos$(i)
            Else
               tmpStringVar = tmpStringVar + "." + pos$(i)
            EndIf
          Next
          i = Instr(selectedDefEntry," ")
          selectedDefEntry = Replace$ (selectedDefEntry,"*","")
          typestr$ = selectedVarName + tmpStringVar + "\" + Left$(selectedDefEntry,i)
          WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
          WZPrint "NEWTYPE_ENTRY",&typestr$
        EndIf

    End Select

  EndIf

  Select pedMessage\_Class

    Case #IDCMP_INTUITICKS
      Select ped\definitionMode

        Case 0
          ped\currentConstantStr = WZGetString("STRING2")
          If ped\currentConstantStr <> ped\lastConstantStr
            ped\lastConstantStr = ped\currentConstantStr
            PED_UpdateDefinitionBrowser{#DEFBROWSER_CONSTANT, ped\currentConstantStr,False}
          EndIf

        Case 1
          ped\currentVariableStr = WZGetString("STRING2")
          If ped\currentVariableStr <> ped\lastVariableStr
            ped\lastVariableStr = ped\currentVariableStr
            pos2(lev) = 0
            PED_UpdateDefinitionBrowser{#DEFBROWSER_VARIABLE, ped\currentVariableStr,False}
          EndIf

        Case 2
          ped\currentNewtypeStr = WZGetString("STRING2")
          If ped\currentNewtypeStr <> ped\lastNewtypeStr
            ped\lastNewtypeStr = ped\currentNewtypeStr
            newtype_found.l = 0
            pos2(lev) = 0
            PED_UpdateDefinitionBrowser{#DEFBROWSER_SELECTTYPE, ped\currentNewtypeStr,False}
          EndIf
      End Select

    Case #IDCMP_CLOSEWINDOW
      Gosub close_definitionbrowser

    Case #IDCMP_VANILLAKEY:
      If pedMessage\_Code = #VANILLAKEY_ESC Then Gosub close_definitionbrowser
      If pedMessage\_Code = #VANILLAKEY_TAB Then Gosub activatesourcewindow


    Case #IDCMP_IDCMPUPDATE
      Select LCase$(WZGadName)

        Case "typeadd"
          tmpStringVar = typestr$
          If Instr(tmpStringVar,"\",FLen(tmpStringVar)-1)<>0 Then tmpStringVar = Left$(tmpStringVar,FLen(tmpStringVar)-1)
          If quicktype Then tmpStringVar = Mid$(typestr$,Instr (typestr$,"\")+1)
          If ped\definitionMode <> 1 Then tmpStringVar = Replace$(tmpStringVar,"*","")
          PED_InsertStringToTextBuffer{tmpStringVar}
          Gosub activatesourcewindow

        Case "string2"
         ;Gosub activatesourcewindow                             ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1

        Case "parent" :
          quicktype = 0
          If ped\definitionMode = 0
          Else
            If lev Then lev = lev - 1
            If lev = 0
              If ped\definitionMode = 1
                PED_UpdateDefinitionBrowser{#DEFBROWSER_VARIABLE,"",False}
              Else
                PED_UpdateDefinitionBrowser{#DEFBROWSER_RESETTYPELIST}
              EndIf
            Else
              PED_UpdateDefinitionBrowser{#DEFBROWSER_SELECTTYPE, pos$(lev)}
            EndIf

            typePath.s = "" : pos$(lev + 1) = ""
            For i = 1 To lev:
              If i > 1
                typePath + "\" + pos$(i)
              Else
                typePath + "." + pos$(i)
              EndIf
            Next
            typestr$ = typePath
            WZTags #WZRD_TEXTPEN,AB3Pen(#AB3_cnewtype)
            WZPrint "NEWTYPE_ENTRY",&typePath
          End If

        Case "clear": ; button "reset"
          Select ped\definitionMode
          Case 0
            ped\currentConstantStr = ""
            WZPrint "STRING2",&ped\currentConstantStr
          Case 1
            ped\currentVariableStr = ""
            WZPrint "STRING2",&ped\currentVariableStr
          Case 2
            ped\currentNewtypeStr = ""
            WZPrint "STRING2",&ped\currentNewtypeStr
          End Select
          PED_UpdateDefinitionBrowser{#DEFBROWSER_RESET}

        Case "newtype_const"
          PED_UpdateDefinitionBrowser{#DEFBROWSER_CONSTANT,"",False}

        Case "newtype_var"
          PED_UpdateDefinitionBrowser{#DEFBROWSER_VARIABLE,"",False}

        Case "newtype_struct"
          PED_UpdateDefinitionBrowser{#DEFBROWSER_NEWTYPE,"",False}

      End Select
  End Select
Return

.close_definitionbrowser:
  If WZ_IsOpen{"WIN_NEWTYPE"}
    Use Window WZID("WIN_NEWTYPE")
    wtemp\type_x = WindowX
    wtemp\type_y = WindowY
    wtemp\type_w = WindowWidth
    wtemp\type_h = WindowHeight
    WZ_KillTable{"TYPETABLE"}
    WZ_CloseWindowAndRemoveMenu{"WIN_NEWTYPE"}
  EndIf
Return


.load_windowlayouts:
  USEPATH wtemp
  CopyMem_ &wpref(ped\lastLayout),&wtemp,SizeOf .winprefs

  If (\lbrowser_w<=0) OR (\lbrowser_h<=0)
    \lbrowser_x = -2
    \lbrowser_y = -2
    \lbrowser_w = -2
    \lbrowser_h = -2
  EndIf

  If (\source_h > 0) AND (\source_w > 0)
    sourceWindow\WinLeft = \source_x
    sourceWindow\WinTop = \source_y
    sourceWindow\WinWidth = \source_w
    sourceWindow\WinHeight = \source_h
  Else
    ped\screen = Peek.l(Addr Screen(0))
    sourceWindow\WinLeft = 0
    sourceWindow\WinTop  = ped\screen\WBorTop + ped\screen\Font\ta_YSize + 1
    sourceWindow\WinWidth= ScreenWidth
    sourceWindow\WinHeight = ScreenHeight - (ped\screen\WBorTop + ped\screen\Font\ta_YSize + 1)
  EndIf
Return


.do_windowlayout:
  If \lbrowser_on
    ;log_Print{"opening library browser"}
    Gosub open_librarybrowser
  Else
    Gosub close_librarybrowser
  End If

  If \ibrowser_on
    ;log_Print{"opening instruction browser"}
    Gosub open_instructionbrowser
  Else
    Gosub close_instructionbrowser
  End If

  If \diag_on
    ;log_Print{"opening diag window"}
    Gosub open_helpdiag
  Else
    Gosub close_helpdiag
  End If

  If \click_on
    ;log_Print{"opening source browser"}
    Gosub open_sourcebrowser
  Else
    Gosub close_sourcebrowser
  End If

  If \short_on
    Gosub open_shortcuts
  Else
    Gosub close_shortcuts
  End If

  If \type_on
    ;log_Print{"opening definition browser"}
    Gosub open_definitionbrowser
  Else
    Gosub close_definitionbrowser
  End If

  ;log_Print{"opening/updating source window"}
  If sourceWindow\win <> 0
    ChangeWindowBox_ sourceWindow\win,sourceWindow\WinLeft,sourceWindow\WinTop,sourceWindow\WinWidth,sourceWindow\WinHeight
    RefreshWindowFrame_ sourceWindow\win
    VWait 1
    Gosub resize_sourcewindow
  Else
    Gosub open_sourcewindow
    If ped\errorCode = #PEDERROR_OPENWINDOW
      dummy.l = ask{!TRANS{"Unable to open window"},!TRANS{"Ok"},!TRANS{"Error"}}
      Pop If
      Goto exit_PED_closeall
    EndIf
    PED_CursorOn{}
  EndIf

  FlushEvents
  If \activewin > 0
    Activate \activewin
    Use Window \activewin
    If Peek.l(Addr Window(\activewin)) <> 0
      Select \activewin
        Case 3 : WZ_ActivateGadget{"STRING_LABEL"}
        Case 2 : WZ_ActivateGadget{"STRING2"}
        Case 1 : WZ_ActivateGadget{"STRING"}
        Case 4 : WZ_ActivateGadget{"VAL1"}
      End Select
    EndIf
  Else
    Gosub activatesourcewindow
  EndIf
Return


.open_sourcebrowser:
  WZWindow WZID("WIN_LABELS"),?wzgui,255,\click_x,\click_y,\click_w,\click_h,WZID("WIN_LABELS")
  WZ_AddMenuStrip{"WIN_LABELS", ped\menuStrip}

  Use Window WZID("WIN_LABELS")
  LabelList_PreSelectItemNumber = -1                             ;added because we don't know what was the preselectitem  tomsmart1
  WZPrint "rem",Peek.w(?comWord_LabelRemark)
  WZPrint "all",Peek.w(?comWord_LabelAll)
  WZPrint "STRING_LABEL",LabelListSearchString
  WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_Labels,LabelList_1VisableItem

Return


.event_sourcebrowser:
  Select pedMessage\_Class
    Case #IDCMP_INTUITICKS
      ;all activities of the window like mouse move
      ;only need this to auto update the listview by typ in the search string   tomsmart1

      LabelListSearchString = LCase$( WZGetString("STRING_LABEL") )
      If LabelListSearchString <> old_LabelListSearchString
        old_LabelListSearchString = LabelListSearchString
        LabelList_NewSelectItemNumber.l = 0
        Gosub reset_labellist
        Poke.s ?comStr_LabelSearchString ,LabelListSearchString
      End If

    Case #IDCMP_RAWKEY:
      ;log_Print{"event: "+ Hex$(pedMessage\_Code)}
      Select pedMessage\_Code
      Case #NM_WHEEL_UP
        Gosub navigate_to_previous_label
      Case #NM_WHEEL_DOWN
        Gosub navigate_to_next_label
      Case #RAWKEY_UP
        Gosub navigate_to_previous_label
      Case #RAWKEY_DOWN
        Gosub navigate_to_next_label
      End Select

    Case #IDCMP_VANILLAKEY:
      ;log_Print{Hex$(pedMessage\_Code)}
      If pedMessage\_Code = #VANILLAKEY_ESC Then Gosub close_sourcebrowser
      If pedMessage\_Code = #VANILLAKEY_TAB Then Gosub activatesourcewindow

    Case #IDCMP_CLOSEWINDOW
      Gosub close_sourcebrowser

    Case #IDCMP_IDCMPUPDATE
      ;log_Print{"event sourcebrowser: IDCMPUPDATE - " + WZGadName}
      Select LCase$(WZGadName)

        Case "string_label"
          ; no need because event is handled in #IDCMP_INTUITICKS
          ;Gosub activatesourcewindow                            ; replaced jsr by gosub to show that this is a BASIC subroutine  tomsmart1

        Case "listview_labels"
          ; removed code that checked if the last and the new select item
          ; was the same because wizard.lib do it and by overwritable by doublellick  tomsmart1
          LabelList_PreSelectItemNumber = WZListNum("LISTVIEW_LABELS")
          LabelList_1VisableItem = WZListPos("LISTVIEW_LABELS")
          ;WZPrint "LISTVIEW_LABELS",-1,list_Labels,LabelList_1VisableItem
          Gosub activatesourcewindow
          Gosub storeline
          lineAddress.l = WZListData (list_Labels, WZInput)
          log_Print{"jump to corresponding source line, (address: " + Hex$(lineAddress)+ ") itemnumber:"+ Str$(WZInput)}
          PED_HistoryAddEntry{}
          PED_GotoLineAddress{lineAddress}

        Case "case"
          Poke.w ?comWord_LabelCase,WZInput
          Poke.w ?comWord_LabelRemark,0
          Poke.w ?comWord_LabelAll,0
          WZPrint "rem",0
          WZPrint "all",0
          Gosub reset_labellist
          WZ_ActivateGadget{"STRING_LABEL"}

        Case "rem"
          Poke.w ?comWord_LabelCase,0
          Poke.w ?comWord_LabelRemark,WZInput
          Poke.w ?comWord_LabelAll,0
          WZPrint "case",0
          WZPrint "all",0
          Gosub reset_labellist
          WZ_ActivateGadget{"STRING_LABEL"}

        Case "all"
          Poke.w ?comWord_LabelCase,0
          Poke.w ?comWord_LabelRemark,0
          Poke.w ?comWord_LabelAll,WZInput
          WZPrint "case",0
          WZPrint "rem",0
          Gosub reset_labellist
          WZ_ActivateGadget{"STRING_LABEL"}

        Case "clr"
          LabelListSearchString = ""
          WZPrint "STRING_LABEL",LabelListSearchString
          Gosub reset_labellist
          WZ_ActivateGadget{"STRING_LABEL"}

        Case "button_update_liblist"
          Gosub scan_source_for_used_libs

        Case "library_list"
          cmd_node.l = WZGetNode(list_usedBlitzLibs)
          searchcmd.s = WZListString(cmd_node,0)
          klammer.b = Instr(searchcmd,"(")
          If klammer
            used_win.l = Used Window

            casesens_backup.w = ped\caseSensitive       ; store searchmode

            searchcmd.s = Replace$(Left$(searchcmd,klammer-1)," ","")
            ped\caseSensitive = True
            ped\searchString = searchcmd
            If searchcmdStore.s <> searchcmd
              searchcmdStore.s = searchcmd
              PED_GotoLine{0,#LINE_START}
            EndIf
            Gosub storeline
            PED_CursorOff{}
            Gosub menu_findnext
            PED_UpdateStatusArea{#STATUS_SCROLLERS}
            PED_CursorOn{}

            ped\caseSensitive = casesens_backup          ; restore searchmode

            If (used_win >< -1) Then Use Window used_win
            Gosub activatesourcewindow
          EndIf

      End Select
  End Select
Return

.close_sourcebrowser:
  If WZ_IsOpen{"WIN_LABELS"}
     Use Window WZID("WIN_LABELS")
     wtemp\click_x  = WindowX
     wtemp\click_y  = WindowY
     wtemp\click_w  = WindowWidth
     wtemp\click_h  = WindowHeight
     WZ_CloseWindowAndRemoveMenu{"WIN_LABELS"}     
  End If
Return


.navigate_to_previous_label:
  If WZ_IsOpen{"WIN_LABELS"}
    LabelList_PreSelectItemNumber = LabelList_PreSelectItemNumber - 1
    If LabelList_PreSelectItemNumber < 0 Then LabelList_PreSelectItemNumber = 0
    LabelList_NewSelectItemNumber = LabelList_PreSelectItemNumber

    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_Labels

    Gosub storeline    

    lineAddress.l = WZListData (list_Labels,LabelList_NewSelectItemNumber)
    PED_GotoLineAddress{lineAddress}
  End If
Return

.navigate_to_next_label:
  If WZ_IsOpen{"WIN_LABELS"}
    LabelList_PreSelectItemNumber = LabelList_PreSelectItemNumber + 1
    If LabelList_PreSelectItemNumber = >WZListItems (list_Labels) Then LabelList_PreSelectItemNumber = WZListItems (list_Labels) - 1
    LabelList_NewSelectItemNumber = LabelList_PreSelectItemNumber

    Use Window WZID("WIN_LABELS")
    WZPrint "LISTVIEW_LABELS",LabelList_PreSelectItemNumber,list_Labels

    Gosub storeline

    lineAddress.l = WZListData (list_Labels,LabelList_NewSelectItemNumber)
    PED_GotoLineAddress{lineAddress}
  End If
Return

.storeline:
  If ped\ptrCurrentSourceData\KeyBeforeReturn = 0 Then Return

  PED_CursorOff{}

  ; -- remove part of the selected block if existing and the currentline is inside of the block
  ped\ptrCurrentSourceData\StateBlockmark = False
  If ped\ptrCurrentSourceData\BlockEndY <> $ffffFFFF
    log_Print{"storeline, erasing block"}
    displayline.l = ped\ptrCurrentSourceData\DisplayLine + ped\ptrCurrentSourceData\DisplayLineOffset
    If ped\ptrCurrentSourceData\BlockStartY =< displayline
      If ped\ptrCurrentSourceData\BlockEndY => displayline
          bmark\xMin = ped\ptrCurrentSourceData\BlockStartX
          bmark\yMin = ped\ptrCurrentSourceData\BlockStartY
          bmark\xMax = ped\ptrCurrentSourceData\BlockEndX
          bmark\yMax = ped\ptrCurrentSourceData\BlockEndY
          If bmark\yMin = bmark\yMax
            If bmark\xMin = bmark\xMax
              bmark\xMax = sourceWindow\visibleColumns
            EndIf
          EndIf
          PED_DrawBlock{bmark}
          ped\ptrCurrentSourceData\StateBlockmark = True
      EndIf
    EndIf
  EndIf

  pasteString.s = Peeks$(ped\ptrTextbuffer + ped\ptrCurrentSourceData\TextBufferOffset,#MAX_Columns)
  newline$ = PED_TokenizeText{pasteString}
  *newLine.sourceLine = PED_CreateNewSourceLine{newline$}
  PED_ReplaceCurrentSourceLine{*newLine}
  PED_PrintCurrentSourceLine{False}

  ;-- redraw only  block part of that line after updating the line
  If ped\ptrCurrentSourceData\StateBlockmark
    log_Print{"storeline: redrawing blockmark"}
    PED_DrawBlock{bmark}
  EndIf

  PED_CursorOn{}

  ped\ptrCurrentSourceData\KeyBeforeReturn = 0
Return


.activatesourcewindow                                                         ; changed name to better show it pourpos  tomsmart1
  If sourceWindow\win
     ActivateWindow_ sourceWindow\win                                         ; replaced ASM part with Basic commands  tomsmart1
     Use Window 0                                                             ; added sourcewinid  tomsmart1
  EndIf
Return                                                                        ; replaced RTS with Return  tomsmart1


.update_preprocessor:
  If *preProcessor
    log_Print{"recreating token hashmap..."}
    preproc_QueryTokens{*preProcessor}
    log_Print{"updating hashmapfile [" + pedconfig\TokenHashMapFile + "]..."}
    preproc_SaveTokens{*preProcessor, pedconfig\TokenHashMapFile}
  Else
    log_Print{"update_preprocessor: preprocessor not initiated!", #log_warning}
  EndIf
Return


.event_find:
    ped\caseSensitive = True
    ped\searchString = WZGetString("FIND_FINDSTRING")
    ped\replaceString = WZGetString("FIND_REPLACESTRING")

    If WZInput("FIND_SENSITIVE") = 0
      ped\searchString = UCase$(ped\searchString)
      ped\caseSensitive = False
    EndIf

    Select pedMessage\_Class
      Case #IDCMP_CLOSEWINDOW
        WZ_CloseWindowAndRemoveMenu{"WIN_SEARCH"}
        Gosub activatesourcewindow
        FlushEvents

      Case #IDCMP_VANILLAKEY
        Select pedMessage\_Code

          Case #VANILLAKEY_RETURN
            ; not enabled anymore, jump to next now via shortcut amiga-N

          Case #VANILLAKEY_ESC
            WZ_CloseWindowAndRemoveMenu{"WIN_SEARCH"}
            Gosub activatesourcewindow
            FlushEvents

        End Select

      Case #IDCMP_IDCMPUPDATE
        Select WZGadName

          Case "FIND_FINDSTRING"
            If UCase$(findStrStore.s) <> UCase$(ped\searchString)
              findStrStore = ped\searchString
              Gosub storeline
              PED_CursorOff{}
              Gosub menu_findnext
              PED_UpdateStatusArea{#STATUS_SCROLLERS}
              PED_CursorOn{}
              FlushEvents : Delay_ 1
            End If

          Case "FIND_NEXT"
            Gosub storeline
            PED_CursorOff{}
            Gosub menu_findnext
            PED_UpdateStatusArea{#STATUS_SCROLLERS}
            PED_CursorOn{}
            Gosub activatesourcewindow                ; added to make source win active that edit is possible  tomsmart1

          Case "FIND_PREVIOUS"
            Gosub storeline
            PED_CursorOff{}
            Gosub menu_findprevious
            PED_UpdateStatusArea{#STATUS_SCROLLERS}
            PED_CursorOn{}
            Gosub activatesourcewindow

          Case "FIND_REPLACE"
            Gosub storeline
            PED_CursorOff{}
            Gosub menu_replace
            PED_CursorOn{}
            Gosub activatesourcewindow                ; added to make source win active that edit is possible  tomsmart1

          Case "FIND_REPLACE_ALL"
            If ped\searchString <> "" AND ped\replaceString <> ""
              Gosub storeline
              PED_CursorOff{}
              PED_SetPointerBusy{}
              Gosub menu_replaceall
              PED_SetCurrentSourceLine{}
              PED_RedrawSource{}
              PED_CursorOn{}
              PED_SetPointerNormal{}
            EndIf
            Gosub activatesourcewindow                ; added to make source win active that edit is possible  tomsmart1

          Case "FIND_EXIT"
            WZ_CloseWindowAndRemoveMenu{"WIN_SEARCH"}
            Gosub activatesourcewindow

        End Select

    End Select
Return


;####################################################################
; BEGIN  routines compiler settings window  tomsmart 2012 03 21     #
;####################################################################
.BackupCompilerSettings:
  !asm
  !ComData_JSR{comFunc_BackupXtraData}
  !basic

; get pointer to the settings from the compiler
  !ComData_GetL{comPtr_Residents_Table       ,D0} : Ptr_Residents_Table.l        = PutD0
  !ComData_GetL{comPtr_Number_of_Objects_Word,D0} : Ptr_Number_of_Objects_Word.l = PutD0
  !ComData_GetL{comPtr_StringBuffer_Long     ,D0} : Ptr_Stringbuffer_Long.l      = PutD0
  !ComData_GetL{comPtr_Stacksize_Long        ,D0} : Ptr_Stacksize_Long.l         = PutD0
  !ComData_GetL{comPtr_Create_IconFile_Byte  ,D0} : Ptr_Create_Iconfile_Byte.l   = PutD0
  !ComData_GetL{comPtr_Make_SmallestCode_Byte,D0} : Ptr_Make_Smallestcode_Byte.l = PutD0
  !ComData_GetL{comPtr_Link_DebugInfo_Byte   ,D0} : Ptr_Link_Debuginfo_Byte.l    = PutD0
  !ComData_GetL{comPtr_Use_Debugger_Byte     ,D0} : Ptr_Use_Debugger_Byte.l      = PutD0
  !ComData_GetL{comPtr_Autorun_Byte          ,D0} : Ptr_Autorun_Byte.l           = PutD0
  !ComData_GetL{comPtr_InterruptCheck_Byte   ,D0} : Ptr_Interruptcheck_Byte.l    = PutD0
  !ComData_GetL{comPtr_AssemblerCheck_Byte   ,D0} : Ptr_Assemblercheck_Byte.l    = PutD0
  !ComData_GetL{comPtr_OverflowCheck_Byte    ,D0} : Ptr_Overflowcheck_Byte.l     = PutD0
  !ComData_GetL{comPtr_MaxObjects_Value_Word ,D0} : Ptr_MaxObjects_Value_Word.l  = PutD0
  !ComData_GetL{comPtr_MaxObject_Pos_Word    ,D0} : Ptr_MaxObject_Pos_Word.l     = PutD0

  !ComData_GetW{comWord_CreateDebugFile      ,D0} : comWord_CreateDebugFile_Back.w = PutD0 ; get status of Create.dbg file  tomsmart1
  !ComData_GetB{comByte_FuncOptimize         ,D0} : comByte_FuncOptimize_Back.b    = PutD0 ; get status of Function Optimizer  tomsmart1
  StringbufferValue_Backup.l = Peek.l(Ptr_Stringbuffer_Long)              ;get sringbuffersize  tomsmart1
  StackSizeValue_Backup.l    = Peek.l(Ptr_Stacksize_Long)                 ;get stacksize  tomsmart1
Return

.RestoreCompilerSettings:
  GetD0 comWord_CreateDebugFile_Back : !ComData_SetW{comWord_CreateDebugFile,D0}   ;restore settings that not stored in the xtradata
  GetD0 comByte_FuncOptimize_Back    : !ComData_SetB{comByte_FuncOptimize   ,D0}   ;restore settings
  Poke.l Ptr_Stringbuffer_Long,StringbufferValue_Backup
  Poke.l Ptr_Stacksize_Long   ,StackSizeValue_Backup
  !asm
  !ComData_JSR{comFunc_RestoreXtraData}
  !basic
Return


.menu_compilersettings   ; was .newoptionsfunc

  Gosub BackupCompilerSettings    ; make a Backup of the active settings

  If ScreenHeight > 400
    com_scr_y.w = ScreenHeight / 6
    com_scr_h.w = ScreenHeight / 1.5
  Else
    com_scr_y.w = -2
    com_scr_h.w = -2
  End If
  WZWindow WZID("WIN_CPREFS"),?wzgui,256,-2,com_scr_y,-2,com_scr_h,WZID("WIN_CPREFS")

  WZ_SetFont{"WIN_CPREFS"}
  WZ_InitTable{"WIN_CPREFS","OBJECTS",2,0}
  WZ_SetTableColors{"OBJECTS",1,0,2,3,3}

  ; Setzen der Spaltentitel fuer die erste Zeile
  WZ_SetTableTitle{"OBJECTS","Objects","Max"}

  ; Legt die Prioritaet der 6 Spalten fest
  WZ_SetPriority{"OBJECTS",3,1}

  ; Setzt die zweite Spalte der Tabelle "OBJECTS" auf nicht editierbar
  WZ_SetEditable{"OBJECTS",False,True}

  ; Sortieren verboten
  WZ_SetSortable{"OBJECTS",Off}

  ;-- fill objectdata from compiler into table OBJECTS
  For i.l = 0 To Peek.w(Ptr_Number_of_Objects_Word) - 1
    tmpStringVar = ""
    GetD0 &tmpStringVar, i
    !ComData_JSR{comFunc_GetObjectEntry}    ;stringaddress in d0 , indexnumber d1
    tmpL.l = PutD0
    WZ_AddRow{"OBJECTS",Peek.s(&tmpStringVar),Str$(tmpL)}
  Next
  WZ_DrawTable{"OBJECTS"}
  WZ_UpdateTable{"OBJECTS"}

  ;-- get Residents and convert it to a string
  var.l = Ptr_Residents_Table
  tmpStringVar = Peek.s(var)     ; get first entry
  For i = 0 To 6               ; get up to 7 entry
    tmpStringVar + "\\0a"        ; added a newline
    var + #ResidentEntryStep   ; update pointer to the next entry
    tmpStringVar + Peek.s(var)   ; added next entry
  Next
  WZPrint "RESIDENTS",&tmpStringVar

  WZPrint "STRINGBUFFER",StringbufferValue_Backup
  WZPrint "STACKSIZE",StackSizeValue_Backup

  ;-- get and set status of the checkmarks
  If Peek.b(Ptr_Create_Iconfile_Byte)=-128
    WZPrint "ICON",1
  Else
    WZPrint "ICON",0
  EndIf

  If Peek.b(Ptr_Make_Smallestcode_Byte)=-128
    WZPrint "SMALLEST",1
    WZDisable "FUNCOPTIMIZE"                           ; added to prevent senceless settings  and possible endless compile runs tomsmart1
  Else
    WZPrint "SMALLEST",0
    WZEnable "FUNCOPTIMIZE"                            ; added  tomsmart1
  EndIf

  If Peek.b(Ptr_Link_Debuginfo_Byte)=-128
    WZPrint "DEBUGINFO",1
  Else
    WZPrint "DEBUGINFO",0
  EndIf

  WZPrint "FUNCOPTIMIZE",comByte_FuncOptimize_Back     ; show status in the GUI tomsmart1
  If comByte_FuncOptimize_Back = 0                     ; added to prevent endless compile runs  tomsmart1
    WZDisable "SMALLEST"
  Else
    WZEnable "SMALLEST"                                ; added  tomsmart1
  EndIf

  WZPrint "DBGFILE",comWord_CreateDebugFile_Back       ; show status in the GUI tomsmart1


  ;runtime Debugging
  If Peek.b(Ptr_Use_Debugger_Byte)=-128
    WZPrint "DEBUG",1
    WZEnable "AUTORUN"                                   ; enable all Debugger settings  tomsmart1
    WZEnable "CHECK_INTERRUPT"                           ;               "
    WZEnable "CHECK_ASSEMBLER"                           ;               "
    WZEnable "CHECK_OVERFLOW"                            ;               "
  Else
    WZPrint "DEBUG",0
    WZDisable "AUTORUN"                                  ; disable all Debugger settings  tomsmart1
    WZDisable "CHECK_INTERRUPT"                          ;                "
    WZDisable "CHECK_ASSEMBLER"                          ;                "
    WZDisable "CHECK_OVERFLOW"                           ;                "
  EndIf

  If Peek.b(Ptr_Autorun_Byte)=-128
    WZPrint "AUTORUN",1
  Else
    WZPrint "AUTORUN",0
  EndIf

  If Peek.b(Ptr_Interruptcheck_Byte)=-128
    WZPrint "CHECK_INTERRUPT",1
  Else
    WZPrint "CHECK_INTERRUPT",0
  EndIf

  If Peek.b(Ptr_Assemblercheck_Byte)=-128
    WZPrint "CHECK_ASSEMBLER",1
  Else
    WZPrint "CHECK_ASSEMBLER",0
  EndIf

  If Peek.b(Ptr_Overflowcheck_Byte)=-128
    WZPrint "CHECK_OVERFLOW",1
  Else
    WZPrint "CHECK_OVERFLOW",0
  EndIf


  ;Event handling of the compiler settings window
  CompilerSettingsWin_Exit.l  = False

  Repeat  ;new

    comsettings_ev.l = WaitEvent


    If pedconfig\onlinehelp <> 0
      If (comsettings_ev <> #IDCMP_INTUITICKS) AND (comsettings_ev <> #IDCMP_ACTIVEWINDOW) AND (comsettings_ev <> #IDCMP_GADGETHELP) AND (comsettings_ev <> #IDCMP_CHANGEWINDOW)
        WZ_HideBubble{}
      EndIf
      If comsettings_ev = #IDCMP_GADGETHELP Then WZ_ShowBubble{}
    EndIf


    WZ_CheckTableEvent{comsettings_ev} ; handle events of the objecttable

    Select comsettings_ev  ; handle events of the rest of the window

       Case #IDCMP_CLOSEWINDOW
         CompilerSettingsWin_Exit = True
         Gosub RestoreCompilerSettings

       Case #IDCMP_VANILLAKEY
         If EventCode = #VANILLAKEY_ESC
           CompilerSettingsWin_Exit = True
           Gosub RestoreCompilerSettings
         EndIf

       Case #IDCMP_IDCMPUPDATE
         Select LCase$(WZGadName)

           Case "autorun"
             If WZInput
               Poke.b Ptr_Autorun_Byte,-128
             Else
               Poke.b Ptr_Autorun_Byte,0
             End If

           Case "check_interrupt"
             If WZInput
               Poke.b Ptr_Interruptcheck_Byte,-128
             Else
               Poke.b Ptr_Interruptcheck_Byte,0
             End If

           Case "check_assembler"
             If WZInput
               Poke.b Ptr_Assemblercheck_Byte,-128
             Else
               Poke.b Ptr_Assemblercheck_Byte,0
             End If

           Case "check_overflow"
             If WZInput
               Poke.b Ptr_Overflowcheck_Byte,-128
             Else
               Poke.b Ptr_Overflowcheck_Byte,0
             End If

           Case "residents"

           Case "stacksize"                                   ; stacksize changed  tomsmart1
             tempsize.l=WZInput                               ; save the valu to a temporay variable  tomsmart1
             If tempsize >= #MIN_STACKSIZE                    ; check size  tomsmart1
               Poke.l Ptr_Stacksize_Long,tempsize                     ; save it.  tomsmart1
             Else                                             ; its not big enough  tomsmart1
               tempsize = #MIN_STACKSIZE                      ; set it to the min size  tomsmart1
               Poke.l Ptr_Stacksize_Long,tempsize                     ; save it  tomsmart1
               WZPrint "STACKSIZE",tempsize                   ; print it  tomsmart1
             EndIf

           Case "stringbuffer"
             Poke.l Ptr_Stringbuffer_Long,WZInput

           Case "debug"
             If WZInput
               Poke.b Ptr_Use_Debugger_Byte,-128                           ; yes runtime Debugging
               WZEnable "AUTORUN"                             ; enable all Debugger settings  tomsmart1
               WZEnable "CHECK_INTERRUPT"                     ;               "
               WZEnable "CHECK_ASSEMBLER"                     ;               "
               WZEnable "CHECK_OVERFLOW"                      ;               "
             Else
               Poke.b Ptr_Use_Debugger_Byte,0                           ; no runtime Debugging
               WZDisable "AUTORUN"                            ; disable all Debugger settings  tomsmart1
               WZDisable "CHECK_INTERRUPT"                    ;                "
               WZDisable "CHECK_ASSEMBLER"                    ;                "
               WZDisable "CHECK_OVERFLOW"                     ;                "
             End If

           Case "icon"
             If WZInput
               Poke.b Ptr_Create_Iconfile_Byte,-128
             Else
               Poke.b Ptr_Create_Iconfile_Byte,0
             End If

           Case "smallest"
             If WZInput
               Poke.b Ptr_Make_Smallestcode_Byte,-128
               WZDisable "FUNCOPTIMIZE"
             Else
               Poke.b Ptr_Make_Smallestcode_Byte,0
               WZEnable "FUNCOPTIMIZE"
             End If

           Case "debuginfo"                                      ; check "Create Debug info" (Symbols)
             If WZInput
               Poke.b Ptr_Link_Debuginfo_Byte,-128
             Else
               Poke.b Ptr_Link_Debuginfo_Byte,0
             End If

           Case "funcoptimize"                                   ; check "Use Function Optimizer"   tomsmart1
             If WZInput
               !ComData_SetB{comByte_FuncOptimize,#1}            ; yes we use it  tomsmart1
               WZEnable "SMALLEST"
             Else
               !ComData_SetB{comByte_FuncOptimize,#0}            ; no we don't  tomsmart1
               WZDisable "SMALLEST"
             EndIf

           Case "dbgfile"                                        ; check "Create .dbg File"   tomsmart1
             If WZInput
               !ComData_SetW{comWord_CreateDebugFile,#1}         ; yes we create it  tomsmart1
             Else
               !ComData_SetW{comWord_CreateDebugFile,#0}         ; no we don't  tomsmart1
             EndIf

          ;check main window buttons
           Case "cancel"
            CompilerSettingsWin_Exit = True
            Gosub RestoreCompilerSettings


           Case "ok"
            CompilerSettingsWin_Exit = True
            Gosub UseMaxObjectsAndResidentsSettings

         End Select

    End Select

  Until CompilerSettingsWin_Exit

  WZ_KillTable{"OBJECTS"}
  WZCloseWindow WZID("WIN_CPREFS")
  FlushEvents
  Gosub activatesourcewindow
Return


.UseMaxObjectsAndResidentsSettings:
  ;-- update save max objects settings
  For i.l = 1 To Peek.w(Ptr_Number_of_Objects_Word)
    i2.l = Vallong( WZ_GetCell{"OBJECTS",i,2} ) 
    If i2 = 0 Then i2 = 1
    Poke.w Ptr_MaxObjects_Value_Word,i2
    Poke.w Ptr_MaxObject_Pos_Word   ,i-1
    !ComData_JSR{comFunc_StoreMaxObjects}
  Next

  ;-- the compiler have to free all loaded residents and to clear the space for safty
  !asm
  !ComData_JSR{comFunc_FreeClearResidentsForPED}
  !basic

  ;-- convert strings to Resident entrys
  i.l = WZInput("RESIDENTS")
  tmpStringVar = Peek.s(i)
  InitArgParse tmpStringVar
  var.l = Ptr_Residents_Table
  For i = 0 To 7
    p$ = NextArgChar$ ($a)
    Poke.s var,p$
    var + #ResidentEntryStep
  Next

  ;-- the compiler has to reload the Residents
  !asm
  !ComData_JSR{comFunc_ReloadResidentsForPED}
  !basic
Return
;####################################################################
; END routines compiler settings window  tomsmart 2012 03 21       #
;####################################################################


;######################################################################
;# BEGIN        routines for the compile status Window                #
;#                                                                    #
;#   moved form the compiler to Ped and modified by tomsmart 20120224 #
;######################################################################
.Open_CompileStatus_Window:                                             ; open the compile status window
  Select CompileMenuCallID

    Case #MENU_RUN              ; we don't need to open the window
    Case #MENU_CREATEDEBUGCODE  ;   "
    Case #MENU_RELOAD_USERLIBS  ;   "

    Default
     If CompileStatusWindow_Pointer.l = 0
       WZWindow WZID("WIN_COMPILESTATUS"),?wzgui,64,-2,-2,-2,-2,WZID("WIN_COMPILESTATUS") ; try to open the wizard window
       CompileStatusWindow_Pointer = Peek.l(Addr Window(WZID("WIN_COMPILESTATUS")))       ; get and store the pointer to window
       ;-- set init data for the update of the status gadgets
       CompileStatus_String_Pointer.l            = Peek.l(?comPtr_CompileStatusString)    ; get the pointer of status string set by the compiler
       CompileStatus_CalculatedProcent_Pointer.l = Peek.l(?comPtr_CompileCalcProLong)     ; get the pointer of calculated procent value set by the compiler
       CompileStatus_String_Old.s                = ""                            ; set to default
       CompileStatus_CalculatedProcent.l         = 0                             ; set to default
       CompileStatus_CalculatedProcent_Old.l     = 0                             ; set to default
       CompileStatus_GaugeString.s               = "0%%"                         ; set to default
       CompileStatusWindow_Event.l               = 0

       ;-- set init data for the abort handling
       Poke.b ?comByte_CompileStatusAbortByte,0                                ; set default
       CompileStatusWindow_Abort.l = False                                     ; abort status default for the event loop

       ;-- print initstring
       If CompileStatusWindow_Pointer <> 0                                     ; check if window is open
         CompileStatus_String_Old = !TRANS{"Initializing Compiler..."}         ; set the init string
         WZPrint "COMPILE_INFO",CompileStatus_String_Old                       ; show the init string
       EndIf

     EndIf

  End Select
Return



;######################################################################
;# END          routines for the compile status Window                #
;######################################################################
.com_updateCompileWindow:                                             ; update the compile status window
  !regs2stack
  !basic
  If CompileStatusWindow_Pointer <> 0                                     ; check if window is open
    CompileStatusWindow_Event = Event                                     ; get the event
    ;update gadgets if needed
    CompileStatus_String_Pointer = Peek.l(?comPtr_CompileStatusString)
    If CompileStatus_String_Pointer <> 0                                  ; check if pointer is set
      If (CompileStatus_String_Old <> Peek.s(CompileStatus_String_Pointer)) ; check is status sting changed => Print it
        CompileStatus_String_Old = Peek.s(CompileStatus_String_Pointer)
        WZPrint "COMPILE_INFO",CompileStatus_String_Pointer
      End If
    EndIf

    CompileStatus_CalculatedProcent_Pointer = Peek.l(?comPtr_CompileCalcProLong)  ; get the pointer of calculated procent value set by the compiler
    If (CompileStatus_CalculatedProcent_Pointer <> 0)                     ; check if pointer is set
       CompileStatus_CalculatedProcent = Peek.l(CompileStatus_CalculatedProcent_Pointer)  ; get the value
      If (CompileStatus_CalculatedProcent >< CompileStatus_CalculatedProcent_Old) ; check if procent value changed => update gauge
         CompileStatus_CalculatedProcent_Old = CompileStatus_CalculatedProcent
         If (((CompileStatus_CalculatedProcent & $3)=0) OR (CompileStatus_CalculatedProcent=100))
            CompileStatus_GaugeString = Str$(CompileStatus_CalculatedProcent)+"%%"
            WZPrint "COMPILE_GAUGE",CompileStatus_CalculatedProcent,100,&CompileStatus_GaugeString
         End If
      End If
    EndIf
   ;test abort button (instead of a separte routine)

    While (CompileStatusWindow_Event <> 0)
      If CompileStatusWindow_Event = #IDCMP_VANILLAKEY
        Poke.b ?comByte_CompileStatusAbortByte,1
      EndIf
      If ( (CompileStatusWindow_Event = #IDCMP_IDCMPUPDATE) AND (CompileStatusWindow_Abort = False) ) ; go if a event happend and the button are not allready pressed
        If WZGadName = "COMPILE_ABORT"                                  ; check if "Abort" gadget is pressed
           Poke.b ?comByte_CompileStatusAbortByte,1                     ; set abort condition
           CompileStatusWindow_Abort = True                             ; set abort condition so the event checking can skiped if a next window update is happend befor the abort is handeled by the compiler
        EndIf
      EndIf
      CompileStatusWindow_Event = Event                                 ; get next event
    Wend
    FlushEvents
  EndIf

  PED_UpdateStatusArea{#STATUS_MEMORY}

  !asm
  !stack2regs
RTS


.Close_CompileStatus_Window:                                            ; close the compile status window
  If CompileStatusWindow_Pointer <> 0
    WZCloseWindow WZID("WIN_COMPILESTATUS")                             ;turn off the requester
    CompileStatusWindow_Pointer             = 0                         ;set pointer to 0 because we close the window
    CompileStatus_String_Pointer            = 0
    CompileStatus_CalculatedProcent_Pointer = 0                         ;set pointer to 0 because we close the window
  EndIf
Return


; -----------------------------------------------------------------------------------------------
CNIF #USE_AREXX = 1
Goto skip_arexxinit
XINCLUDE "PED_arexx.ab3"
skip_arexxinit:
CEND
; -----------------------------------------------------------------------------------------------


; ---------------------------------------------------------------------
; Declarations of Variables
; ---------------------------------------------------------------------
.DECLARATIONS
wzgui:                IncBin "ped.wizard"

.classiccommands
                      ; memory reservations for libs that where introduced with old blitz2
                      ; here come whole libs
                      Dc.w 11    ; Ricopperfxlib
                      Dc.w 45    ; Risoundlib
                      Dc.w 56    ; Xbciatrackerlib
                      Dc.w 60    ; EML (enhanced music library)
                      Dc.w 65    ; rigfxlib
                      Dc.w 82    ; medlib
                      Dc.w 96    ; trackerlib
                      Dc.w 98    ; blitzkeyslib
                      Dc.w 112   ; spriteslib
                      Dc.w 113   ; cd32lib
                      Dc.w 116   ; audiolib
                      Dc.w 117   ; blitzoslib
                      Dc.w 119   ; 2dlib
                      Dc.w 143   ; displaylib
                      Dc.w 144   ; blitzcoplib
                      Dc.w 146   ; bblitlib
                      Dc.w 148   ; qblitlib
                      Dc.w 150   ; blitlib
                      Dc.w 152   ; freqlib
                      Dc.w 156   ; palettelib
                      Dc.w 190   ; gameiolib
                      Dc.w 204   ; bfbplaymaster.library1
                      Dc.w 209   ; thxplay.library1

                      Dc.w 0     ;say end
                                 ;set breakpoint
                      Dc.w $3385 ;timer commands here come single commands
                      Dc.w $2588 ;timer
                      Dc.w $1784 ;timer
                      Dc.w $4d08 ;get a shape

                      Dc.w 0     ;say end

BSS
Even
instring2             Dc.b 0                ; > tokenize_line
