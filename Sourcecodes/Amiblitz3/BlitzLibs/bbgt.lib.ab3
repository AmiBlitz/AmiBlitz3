; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "blitz2:userlibs/Acidlibs"
; ExeFile         = "mygadtoolslib.obj"
; CreateIcon      = 0
; Residents       = "blitzlibs:all.res,blitzlibs:libmacs.res,blitzlibs:bb2objtypes.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 0
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 621
; CursorColumn    = 1
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 5
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 5
; /XTRA
; V2 of the BBGTLib
; Loads of internal re-structuring

; 17/10/93
;  fixed immediate/relverify constants (they were bloody wrong!)
;  added gtsetsting getsetinteger gtgetsting getgetinteger
;   so no more attatching a dummy Blitz gadget list for users
; 18/10/93
;  added optional values for scroll,slider,cycle,mx,string&palette
;  added optional listview parameters and flag$1000 for readonly
;  fixed setattr to find correct gadget
; 13/11/93
;  fixed id bug where d1 parameter was getting trashed in stdsetup
; 19/11/93
;  fixed attachgtlist to not corrupt a4
; 24/11/93
;  added gtshape for gtbutton using an shape image,
;  it seems that it isn' t possible to add text anymore...
;  error checking (gtshape) added
; March 1994 (BUM6)
;  GTGetAttrs (GTList#,id,Tag)
;  GTEnable   GTList#,Id
;  GTDisable  GTList#,Id
;  GTToggle   GTList#,Id [,On|Off]
; August 1994
; sorted out os2/3 problems
; fuck attachgtlist presumed a6 had gtlib????
; removed #GTLV_ShowSelected tag for in gtlists
; removed the free imagepointers routine in freecontext (mem drain!) NOT!
;
; 2nd April 2000 (David McMinn)
;   * Started a much needed update
;   * Commenting some routines
;   * Fixed free gtlist bug for visual prefs
;   * fixed gtshapes having wrong PlanePick values
;   * fixed gtshapes having wrong highlight images
; 3rd April 2000 (David McMinn)
;   * added detachgtlist
;   * added gtgzzposition
;   * added gtsethighlight
;   * added gtfreegadget but it needs to be rewritten
;   * added gtactivategadget
;   * fixed possible enforcer death from hell in internal routine "findgadorig"
;   * hopefully the free gtlist will now also free the Image structures allocated for GTShapes and still work with VP
;   * and the same with the GTFreeGadget routine
; 19th April 2000 (David McMinn)
;   * GTGetStatus renamed to GTStatus
;   * highlight shape now displayed correctly, was testing the wrong memory location
;     when checking for the highlight image flag being set
; 15th August 2000 (David McMinn)
;   * Fixed problems with GTGadPtr and GTSetAttrs for GTListviews (and possibly palettes?)
;     [GTGadPtr now searches for the last item in the GTList with the
;     ID we are looking for]
;   * Latest build date added to the help text of the GTList dumtoke
;   * Really need to go through and make all routines use a standard findgad routine
;     to get the gadget pointer and check the return result from some things

; 25th November 2000 (David McMinn)
;   * OK, due to complaints of not-workingness, and actually have a
;     bit of a think about how to best do this, I've changed the operation
;     of GTGadPtr again. The problem before was that with the Acid library
;     using GTGadPtr would return the pointer to the first (part of a) gadget
;     with the correct ID. While this was OK for some gadgets, using the
;     returned pointer with some OS routines (like to remove GTListviews
;     from a window, or using the OS GT_SetGadgetAttrsA_) did not work.
;     This was because the real gadget to use is the last one in the list,
;     which is what the update from 15/8/00 did. However, since the
;     behaviour of GTGadPtr is now different, I have decided to change
;     it back to finding the first gadget. HOWEVER, there is now an optional
;     option for the GTGadPtr command to return the last gadget with the
;     required ID, thus allowing you the best of both worlds.
;   * Added GTNewLookProp
;   * Bumped date in GTList help string
;   * Would like to make all the gadget creation routines commands
;     which return a pointer to the gadget created

; 26th November 2000 (David McMinn)
;   * Added option for GTBevelBox to specify the frame type (OS3+!)
;   * Fixed the above option :(

; 28th November 2000 (David McMinn)
;   * Fixed GTBevelBox when using debugger, was checking for errors from the wrong address register

; 19th February 2001 (David McMinn)
;   * Added GTListAddress command (gets address of head of List array)

; 7th December 2001 (David McMinn)
;   * Added GTUserData command

; 22nd December 2001 (David McMinn)
;   * Gadget pointers stored in internal list for correct GTGadPtr, and related commands
;   * All gadget creation commands return pointer to created gadget
;   * Third parameter of GTGadPtr ignored (but left in for compatibility)

; 29th December 2001 (David McMinn)
;   * Memory for GTMX and GTCycle commands stored in same internal list and freed on Free GTList/GTFreeGadget
;   * GTText gadgets do not allocate new string
;   * All gadgets lose memory until program exit for their Text - need to fix that

; 29th January 2002 (David McMinn)
;   * GTUnderscore command added
;   * GTChangeCycle command added
;   * All gadget memory freed (including text) when not required any more
;   * GTGZZPosition now has an affect on GTBevelBoxes
;   * GTBevelBox will not crash if GTList not attached to a window and debugger is off

; 30th January 2002 (David McMinn)
;   * GTGetString rewritten to use GT_GetGadgetAttrsA_ on OS3+ machines.
;   * GTGetInteger rewritten as above (assumes *Gadget\SpecialInfo=0 for GTNumbers)
;     and now has the bonus of working for GTNumber gadgets. Still uses the old
;     code for pre-V39 machines, so that won't work with GTNumbers.
;   * Fixed enforcer hit in GTGetInteger
;   * GTBevelBox checks for GTList not being attached to window and exits
;     (no more crashing when debugger is turned off)
;   * GTGetAttrs quits without crashing on pre-v39 machines

; 1st February 2002 (David McMinn)
;   * GTDisable and GTEnable now use GT_SetGadgetAttrs() to change the state of the
;     gadget. Means the code is cleaner and you do not need to manually redraw the
;     gadget after calling those commands
;   * GTToggle will now automatically redraw the gadget for you
;   * GTEventSeconds and GTEventMicros commands added (also changes to the prehandler routine)
;   * freecontext updated to clear the shape gadgets properly and not free them (which is done later)


#mygadtoolslib = 141
#intuitionlib = 255
#windowslib = 138

#globalalloc = $c002  ; token for allocating memory (d0 = size, d1 = memtype :: d0 = pointer to mem)
#globalfree  = $c003  ; token for freeing memory (a1 = pointer to mem, d0 = size)
#stringalloc = $cf01  ; token for allocating + copying a new string (d0 = pointer to string to copy, d1 = length of string
                      ; :: d0 = new Pointer)
#stringfree  = $cf02  ; token for freeing a string (d0 = pointer to string)


#_CreateGadget=-30     ;(kind,gad,ng,taglist)(d0/a0/a1/a2)
#_FreeGadgets=-36      ;(gad)(a0)
#_SetGadgetAttrs=-42   ;(gad,win,req,taglist)(a0/a1/a2/a3)
#_GetIMsg=-72          ;(iport)(a0)
#_ReplyIMsg=-78        ;(imsg)(a1)
#_RefreshWindow=-84    ;(win,req)(a0/a1)
#_BeginRefresh=-90     ;(win)(a0)
#_EndRefresh=-96       ;(win,complete)(a0,d0)
#_FilterIMsg=-102      ;(imsg)(a1)
#_PostFilterIMsg=-108  ;(imsg)(a1)
#_CreateContext=-114   ;(glistptr)(a0)
#_DrawBevelBox=-120    ;(rport,left,top,width,height,taglist)(a0,d0/d1/d2/d3/a1)
#_GetVisualInfo=-126   ;(screen,taglist)(a0/a1)
#_FreeVisualInfo=-132  ;(vi)(a0)
#_GetGadgetAttrs=-174   ;(gad,win,req,taglist)(a0/a1/a2/a3)


; intuition.library
#_LVOAddGadget      = -42
#_LVORemoveGadget   = -228
#_LVORefreshGList   = -432
#_LVOAddGList       = -438
#_LVORemoveGList    = -444
#_LVOActivateGadget = -462


; exec.library
#_LVOCloseLibrary   = -414
#_LVORawPutChar     = -516      ; Send one character in d0:7-0 to the serial port
#_LVORawDoFmt       = -522      ; formats and completes string like printf
#_LVOOpenLibrary    = -552
#_LVOCopyMem        = -624


#DEBUG  = 0         ; Turns on (1) or off (0) debugging output to the serial port
                    ; Should be set to 0 for releasing the lib!

#OLDFLAGS = 1       ; Set to 1 to use the old Blitz2 style of flags (combined bbgtlib and OS in one parameter)
                    ; or 0 to make the flags parameter solely for the use of the OS flags)


!libheader{#mygadtoolslib,init,0,finit,errors}

!dumtoke{"GTList","A GadTools GadgetList (05.01.2002)",_toke}

!acommand{#long}
!args{#word,#word,#word,#word,#word,#word,#string,#long}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtbuttonnoud,0,0}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#long}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtbutton,0,0}
!name{"GTButton","GTList#,id.w,x.w,y.w,w.w,h.w,Text$,flags.l[,UserData.l]"}


!acommand{#long}
!args{#word,#word,#word,#word,#word,#word,#string,#long}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtcheckbox,0,0}
!name{"GTCheckBox","GTList#,id,x,y,w,h,Text$,flags"}


!acommand{#long}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#string}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtcycle2,0,0}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#string,#word|#push}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtcycle,0,0}
!name{"GTCycle","GTList#,id,x,y,w,h,Text$,flags,Options$[,active]"}


!acommand{#long}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#long}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtinteger,0,0}
!name{"GTInteger","GTList#,id,x,y,w,h,Text$,flags,default"}


!acommand{#long}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#array|#push,#word|push}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtlistview1,0,0}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#array|#push,#word|push,#word|push}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtlistview2,0,0}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#array|#push}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtlistview,0,0}
!name{"GTListView","GTList#,id,x,y,w,h,Text$,flags,list()[,selected[,top]]"}


!acommand{#long}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#string}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtmx,0,0}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#string,#word|#push}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtmx2,0,0}
!name{"GTMX","GTList#,id,x,y,w,h,Text$,flags,Options$[,active]"}


!acommand{#long}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#long}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtnumber,0,0}
!name{"GTNumber","GTList#,id,x,y,w,h,Text$,flags,value"}


!acommand{#long}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#long}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtpalette,0,0}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#long,#word|#push}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtpalette2,0,0}
!name{"GTPalette","GTList#,id,x,y,w,h,Text$,flags,depth[,Color]"}


!acommand{#long}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#word,#word}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtscroller,0,0}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#word,#word,#word|#push}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtscroller2,0,0}
!name{"GTScroller","GTList#,id,x,y,w,h,Text$,flags,Visible,Total[,Top]"}


!acommand{#long}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#word,#word}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtslider,0,0}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#word,#word,#word|#push}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtslider2,0,0}
!name{"GTSlider","GTList#,id,x,y,w,h,Text$,flags,Min,Max[,Level]"}


!acommand{#long}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#word}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtstring,0,0}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#word,#string|#push}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gtstring2,0,0}
!name{"GTString","GTList#,id,x,y,w,h,Text$,flags,MaxChars [,default$]"}


!acommand{#long}
!args{#word,#word,#word,#word,#word,#word,#string,#long,#string}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1}
!subs{_gttext,0,0}
!name{"GTText","GTList#,id,x,y,w,h,Text$,flags,Display$"}


!astatement
!args{#word,#word}
!libs{#mygadtoolslib,#ia1|pd0,#windowslib,$1081,#intuitionlib,#la6}
!subs{_attachgtlist,checkattach,0}
!name{"AttachGTList","GTList#,Window#"}


!astatement
!repargs {0,2,#long|#push,#long|#push}
!libs
!subs {_gttags,0,0}
!name {"GTTags","Tag,Value [,Tag,Value...]"}


!afunction {#long}
!args {#word,#word}
!libs {#mygadtoolslib,#ia1|pd0}
!subs {_gtptr,0,0}
;!args {#word,#word,#word}
;!libs {#mygadtoolslib,#ia1|pd0}
;!subs {_gtptr,0,0}
!name {"GTGadPtr","(GTList#,id)"}


!astatement
!args{#word,#long,#long,#long,#long,#long}
!libs{#mygadtoolslib,#ia0|pd0}
!subs{_gtbevel2,checkbevel,0}
!args{#word,#long,#long,#long,#long,#long,#long}
!libs{#mygadtoolslib,#ia0|pd0}
!subs{_gtbevel,checkbevel,0}
!name{"GTBevelBox","GTList#,x.l,y.l,w.l,h.l,flags.l[,type.l]"}


!astatement
!args {#word,#word,#array|#push}
!libs {#mygadtoolslib,#ia1|pd0}
!subs {_gtchnglist2,0,0}
!args {#word,#word}
!libs {#mygadtoolslib,#ia1|pd0}
!subs {_gtchnglist,0,0}
!name {"GTChangeList","GTList#,id [ ,List() ]"}


!acommand{#long}
!repargs {2,2,#word,#word,#long|#push,#long|#push}
!libs {#mygadtoolslib,#ia1|pd0}
!subs {_gtsetattrs,0,0}
!name {"GTSetAttrs","GTList#,id [,Tag,Value...]"}


!astatement
!args {#word,#word,#string}
!libs {#mygadtoolslib,#ia1|pd0}
!subs {_gtsetstring,0,0}
!name {"GTSetString","GTList#,id,string$"}


!astatement
!args {#word,#word,#long}
!libs {#mygadtoolslib,#ia1|pd0}
!subs {_gtsetint,0,0}
!name {"GTSetInteger","GTList#,id,value"}


!afunction {#string}
!args {#word,#word}
!libs {#mygadtoolslib,#ia1|pd0}
!subs {_gtgetstring,0,0}
!name {"GTGetString","GTList#,id"}


!afunction {#long}
!args {#word,#word}
!libs {#mygadtoolslib,#ia1|pd0}
!subs {_gtgetint,0,0}
!name {"GTGetInteger","GTList#,id"}


!acommand{#long}
!args{#word,#word,#word,#word,#long,#word}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1,#shapeslib,#ia6|#pd5}
!subs{_gtshape,sgchk,0}
!args{#word,#word,#word,#word,#long,#word,#word}
!libs{#mygadtoolslib,#ia3|pd0,#intuifontlib,#la0,#screenslib,#ua1,#shapeslib,#ia6|#pd5,#shapeslib,#ia2|#pd6}
!subs{_gtshape2,sgchk2,0}
!name{"GTShape","GTList#,id,x,y,flags,Shape#[,Shape#]"} ; Andre was here :)


!afunction {#long}
!args {#word,#word,#long}
!libs {#mygadtoolslib,#ia1|pd0}
!subs {_gtgetattrs,0,0}
!name {"GTGetAttrs","(GTList#,id,Tag)"}


!astatement ; need a Redraw...
!args{#word,#word}
!libs{#mygadtoolslib,#ia1|pd0}
!subs{doenable,0,0}
!name{"GTEnable","GTList#,Id"}


!astatement ; need a Redraw...
!args{#word,#word}
!libs{#mygadtoolslib,#ia1|pd0}
!subs{dodisable,0,0}
!name{"GTDisable","GTList#,Id"}


!astatement ; need a Redraw...
!args{#word,#word,word}
!libs{#mygadtoolslib,#ia1|pd0,#intuitionlib,#la6}
!subs{doselect,0,0}
!args{#word,#word}              ;simon was here
!libs{#mygadtoolslib,#ia1|pd0,#intuitionlib,#la6}  ;andre too...
!subs{doselect2,0,0}
!name{"GTToggle","GTList#,Id [,On|Off]"}


;Stephen McNamara updates, August 1994
;Function definitions


!afunction {#byte}                   ; Steve Mc was here!
!args{#word,#word}
!libs{#mygadtoolslib,#ia1|pd0}
!subs{_gtgetstatus,0,0}
!name{"GTStatus","GTList#,Id"}


!astatement                          ; Steve Mc was here!
!args {#long}
!libs
!subs{_gtarrowsize,0,0}
!name{"GTArrowSize","size"}


; David McMinn was here, trying to copy the BSS updated bbgtlib
; (without the source, doh)
!astatement
!args{#word}
!libs{#mygadtoolslib,#ia1|pd0,#intuitionlib,#la6}
!subs{_detachgtlist,checkdetach,0}
!name{"DetachGTList","GTList# - Removes a GTList from a window"}


!astatement
!args{#word}
!libs
!subs{_gtgzzposition,0,0}
!name{"GTGZZPosition","On/Off - Turn on/off adding of window borders to gadget positions"}


!astatement
!args{#word,#word,#long}
!libs{#mygadtoolslib,#ia1|pd0}
!subs{_gtsethighlight,0,0}
!name{"GTSetHighlight","GTList#,id,value - Set highlighted item in GTListview"}


!acommand{#word}
!args{#word,#word}
!libs{#mygadtoolslib,#ia1|pd0,#intuitionlib,#la6}
!subs{_gtfreegadget,0,0}
!name{"GTFreeGadget","[(]GTList#,id[)]"}


!astatement
!args{#word,#word}
!libs{#mygadtoolslib,#ia1|pd0,#intuitionlib,#la6}
!subs{_gtactivategadget,0,0}
!name{"GTActivateGadget","GTList#,id - Activates a string/custom gadget"}


; New additions (past the RI lib)
!astatement
!args{#word}
!libs
!subs{_gtnewlookpropmode,0,0}
!args{#word,#word,#word}
!libs{#mygadtoolslib,#ia1|pd0}
!subs{_gtnewlookprop,0,0}
!name{"GTNewLookProp","[Mode=On/Off] or [GTList,ID,On/Off]"}


!acommand{#long}
!args{#array}
!libs
!subs{_gtlistaddress,0,0}
!name{"GTListAddress","(List())  Returns address of List header structure"}


!astatement
!args{#long}
!libs
!subs{_gtuserdata,0,0}
!name{"GTUserData","UserData.l - Set userdata for next gadget created"}


!acommand{#long}
!args{#word,#word,#string}
!libs{#mygadtoolslib,#ia0|pd0,#intuitionlib,#la6}
!subs{_gtchangecycle,0,0}
!name{"GTChangeCycle","[(]GTList.w,ID.w,Option$[)] - Change contents of GTCycle gadget"}


!afunction{#long}
!args
!libs
!subs{_gtgetinternal,0,0}
!name{"GTGetInternal","Returns pointer to internal list of memory allocations"}


!astatement
!args{#word}
!libs
!subs{_gtunderscore,0,0}
!name{"GTUnderscore", "char.w - Sets the ASCII code of the character to use as the underscore indicator"}


!afunction{#long}
!args
!libs
!subs{_gteventseconds,0,0}
!name{"GTEventSeconds","- Tells you the seconds at which the last event occurred"}


!afunction{#long}
!args
!libs
!subs{_gteventmicros,0,0}
!name{"GTEventMicros","- Tells you the microseconds at which the last event occurred"}


init:!nullsub{_codeinit,0,0}
finit:!nullsub{_codefinit,0,0}
_load:!nullsub{0,0,0}
_save:!nullsub{0,0,0}
_use:!nullsub{0,0,0}
_free:!nullsub{_freecontext,0,0}
!libfin{_toke,_load,_save,_use,_free,5,4} ;don't change!!!(cludged)

;----------------------------------------------------------------

NEWTYPE .gtcontext
  mycontext.l        ;0 points to context
  visualinfo.l       ;4 our visual info from current screen
  current.l          ;8 current gadget
  gtwindow.l         ;12 window gadgetlist is attached to
End NEWTYPE


; Internal gadget list
NEWTYPE.gtinlist
  *Succ.gtinlist    ; Pointer to next gadget
  *Gad.Gadget       ; Pointer to gadget returned by CreateGadget
  *Text.b           ; Gadget text (if required)
  Special.l         ; The special stuff (size.l stored at (-4,Special))
  id.w              ; gadget ID
  pad.w
End NEWTYPE

NEWTYPE.gtil
  *Succ.gtil
  *First.gtinlist
  *gtlst.gtcontext ; GTList pointer
  pad.w
End NEWTYPE


Macro s SizeOf.Screen\`1 End Macro
Macro n SizeOf.NewGadget\`1 End Macro
Macro g SizeOf.Gadget\`1 End Macro


; Push arguments onto stack, last first
; !PUTSTR{id,"rawdofmt string"}
; Remove args from stack
; e.g.:
;.someroutine:
;CNIF    #DEBUG=1
;    PEA.l   $DEADBEEF
;    !PUTSTR{001,"Fiiiiiiist: $%lX"}
;    LEA.l   4(a7),a7
;CEND


Macro PUTSTR
    MOVEM.l d0-d1/a0-a1,-(a7)
    LEA.l   'msg_`1(pc),a0
    LEA.l   4*4(a7),a1
    JSR     dboutput
    MOVEM.l (a7)+,d0-d1/a0-a1
    BRA     'skip_`1
    'msg_`1: Dc.b `2,10,0 : Even
    'skip_`1:
End Macro

.Internals
; Debugging code
; a0 = pointer to format string
; a1 = pointer to arguments
dboutput:
    MOVEM.l d0-d1/a0-a3/a6,-(a7)
    MOVE.l  4,a6                            ; Pointer to execbase
    LEA     'KPutChar(pc),a2                ; Pointer to the routine for dumping chars called by RawDoFmt
    SUB.l   a3,a3                           ; Clear a3
    JSR     _LVORawDoFmt(a6)                ; Call exec.library/RawDoFmt()
    MOVEM.l (a7)+,d0-d1/a0-a3/a6
    RTS

    'KPutChar:
    MOVE.l  a6,-(a7)
    MOVE.l  4,a6                            ; execbase
    JSR     _LVORawPutChar(a6)              ; print character in d0:7-0 to ser:
    MOVE.l  (a7)+,a6
    RTS


._codeinit:
    LEA     gtname(pc),a1
    MOVEQ   #0,d0
    MOVE.l  4,a6
    JSR     _LVOOpenLibrary(a6)
    MOVE.l  d0,gtbase
    BEQ     'failinit
    MOVE.l  #_prehandler,d0
    MOVE.l  #_posthandler,d1
    ALibJsr SetEventFilter  ; Thilo
    'failinit:
    CLR.w   gzzpos                          ; set gzz flag to off initially
    CLR.w   propmode                        ; set propmode to off initially
    CLR.l   internalglist                   ; NULL pointer to head of internal malloc list
    MOVEQ.l #16,d0
    MOVE.w  d0,arrowsize                    ; Store default size of arrows in scroller, sliders, etc
    MOVEQ.l #95,d0
    MOVE.w  d0,underscore                   ; Store ASCII code for default underscore indicator
    CLR.l   evseconds
    CLR.l   evmicros
    RTS


; I hope the free routine gets called for all objects before the codefinit routine :)
._codefinit:
    MOVE.l  gtbase(pc),d0
    BEQ     'noclose
    MOVE.l  d0,a1
    MOVE.l  4,a6
    JSR     _LVOCloseLibrary(a6)
    CLR.l   gtbase
    'noclose:

    ; free the memory in the internal list of stuff
    JSR     reminternallist
    RTS


._prehandler:
    MOVE.l  d0,a1
    MOVE.l  {SizeOf.IntuiMessage\Seconds}(a1),evseconds
    MOVE.l  {SizeOf.IntuiMessage\Micros}(a1),evmicros
    MOVE.l  gtbase(pc),a6
    JSR     _FilterIMsg(a6)
    MOVE.l  4,a6
    RTS

._posthandler:
    MOVE.l  d0,a1
    MOVE.l  gtbase(pc),a6
    JSR     _PostFilterIMsg(a6)
    MOVE.l  4,a6
    RTS


; Adds pointer to the gadget to the internal gadget list
; d0.l = gadget ID
; d1.l = pointer to gtlist
; Returns pointer to new gtlistinternal item thingy
.addgadptr:
    MOVEM.l d1-d3/a0-a1,-(a7)
    MOVE.l  d0,d2
    MOVE.l  internalglist,a0                ; Pointer to first item

    'findgtlist:
    CNIF #DEBUG=1
    MOVE.l  a0,-(a7)
    !PUTSTR{001,"addgadptr: current item in gtlist = $%lx"}
    LEA.l   4(a7),a7
    CEND

    MOVE.l  a0,d0                           ; pointer to item in d0
    BEQ     'newgtitem                      ; if NULL, branch to code for creating new item

    CMP.l   {SizeOf.gtil\gtlst}(a0),d1      ; else compare gtlist ID in list to the one we're looking for
    BEQ     'gtfound                        ; if they are the same, branch to code for searching through gadget IDs

    MOVE.l  (a0),a0                         ; Else, get pointer to next item in gtlist list into a0
    BRA     'findgtlist                     ; and repeat loop

    'newgtitem:                             ; We reached the end of the loop, never found an item so we must create one
    CNIF #DEBUG=1
    !PUTSTR{002,"addgadptr: Creating new item in list of gtlists"}
    CEND
    MOVE.l  d1,d3                           ; Preserve GTList pointer
    MOVE.l  #SizeOf.gtil,d0                 ; size of list item
    MOVE.l  #MEMF_ANY|MEMF_CLEAR,d1         ; mem type
    ALibJsr #globalalloc                    ; Blitz's alloc mem
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{003,"addgadptr: allocated gtlist item = $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; check pointer
    BEQ     'noitem                         ; oh dear

    MOVE.l  d0,a0
    MOVE.l  internalglist,(a0)              ; current head of list pointer into next item pointer
    MOVE.l  a0,internalglist                ; new item becomes head boy
    MOVE.l  d3,{SizeOf.gtil\gtlst}(a0)      ; Store ID of GTList

    ; Add new gadget to this monkey boy
    'gtfound:
    CNIF #DEBUG=1
    !PUTSTR{004,"addgadptr: Creating new item in list of gadgets"}
    CEND
    MOVE.l  #SizeOf.gtinlist,d0             ; size of list item
    MOVE.l  #MEMF_ANY|MEMF_CLEAR,d1         ; mem type
    ALibJsr #globalalloc
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{005,"addgadptr: allocated gadget item = $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0
    BEQ     'noitem

    MOVE.l  d0,a1
    MOVE.l  {SizeOf.gtil\First}(a0),(a1)
    MOVE.l  a1,{SizeOf.gtil\First}(a0)
    MOVE.w  d2,{SizeOf.gtinlist\id}(a1)

    'noitem:
    MOVEM.l (a7)+,d1-d3/a0-a1
    RTS


; Frees one gadget from an internal gtinlist
; d0 = pointer to gtlist
; d1 = gadget ID
; returns nothing, preserves all registers
.remgadptr:
    MOVEM.l d0-d2/a0-a1,-(a7)

    LEA.l   internalglist,a1                ; Pointer to pointer to head of list into a1

    'gtloop:
    MOVE.l  (a1),d2
    BEQ     'nolist

    MOVE.l  d2,a0
    CMP.l   {SizeOf.gtil\gtlst}(a0),d0
    BEQ     'gotlist

    MOVE.l  a0,a1
    BRA     'gtloop

    ; Found start of gtlist - search for gadget and previous gadget
    'gotlist:
    LEA.l   {SizeOf.gtil\First}(a0),a1      ; Pointer to pointer to head of list

    'gadloop:
    MOVE.l  (a1),d2                         ; Pointer to next item in list -> d2
    BEQ     'nolist                         ; if NULL, we can't find the gadget, exit

    MOVE.l  d2,a0
    CMP.w   {SizeOf.gtinlist\id}(a0),d1     ; Compare ID to the one we are looking for
    BEQ     'gotgad

    MOVE.l  a0,a1
    BRA     'gadloop

    ; Found gadget (previous=a1, item to free=a0)
    'gotgad:
    MOVE.l  a0,-(a7)                        ; preserve a0
    MOVE.l  (a0),(a1)                       ; Pointer to next gadget in next field of previous gadget
    MOVE.l  {SizeOf.gtinlist\Special}(a0),d0; pointer to special memory into d0
    BEQ     'nospec

    MOVE.l  d0,a1                           ; pointerto special mem into a1
    SUBQ.w  #4,a1                           ; pointer to start of allocated memory for special
    MOVE.l  (a1),d0                         ; size of allocated memory
    ALibJsr #globalfree                     ; freemem
    MOVE.l  (a7),a0                         ; restore a0

    'nospec:
    MOVE.l  {SizeOf.gtinlist\Text}(a0),d0   ; Pointer to gadget text
    BEQ     'notext
    MOVE.l  a0,-(a7)                        ; preserve a0
    ALibJsr #stringfree                     ; freemem

    'notext:
    MOVE.l  (a7)+,a1                        ; restore a1
    MOVEQ.l #SizeOf.gtinlist,d0             ; size of list item
    ALibJsr #globalfree                     ; freemem

    'nolist:
    MOVEM.l (a7)+,d0-d2/a0-a1
    RTS


; Frees a single gadget list
; d0 = gtlist pointer
; returns nothing and preserves all registers
.remgadlist:
    MOVEM.l d0-d2/a0-a1,-(a7)

    CNIF #DEBUG=1
    !PUTSTR{001,"remgadlist: Entered"}
    CEND

    LEA.l   internalglist,a1                ; pointer to head pointer -> a1 (need to store pointer to previous item)

    'gtloop:
    MOVE.l  (a1),d2                         ; Pointer to next item in list into d2 (and test)
    BEQ     'nolist                         ; if NULL, we reached the end of the list

    CNIF #DEBUG=1
    MOVE.l  d2,-(a7)
    MOVE.l  a1,-(a7)
    !PUTSTR{002,"remgadlist: Previous/current gtlist pointers = $%lx/$%lx"}
    LEA.l   2*4(a7),a7
    CEND

    MOVE.l  d2,a0                           ; Else, get pointer to next item in a0
    CMP.l   {SizeOf.gtil\gtlst}(a0),d0      ; compare ID of gadget list to the one we want to remove
    BEQ     'gotlist                        ; if the same, branch to gotlist

    MOVE.l  a0,a1                           ; Pointer to previous item in list = current item pointer
    BRA     'gtloop                         ; repeat loop for next item

    ; Found GTList item to free
    'gotlist:
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{003,"remgadlist: Found item to free at $%lx"}
    LEA.l   4(a7),a7
    CEND
    MOVE.l  (a0),(a1)                       ; Copy pointer to next item in list to next field of previous item

    ; Go through all the gadgets in this gtlist and free the special info and then the gadget info structure
    'freeloop:

    MOVE.l  {SizeOf.gtil\First}(a0),d0      ; Pointer to head of gadgets into d0
    BEQ     'donefree
    MOVE.l  a0,-(a7)
    MOVE.l  d0,a1                           ; pointer to gadget info item into a0
    MOVE.l  (a1),{SizeOf.gtil\First}(a0)    ; put pointer to next item in the head of list pointer
    MOVE.l  a1,-(a7)
    MOVE.l  {SizeOf.gtinlist\Special}(a1),d0; Pointer to special info
    BEQ     'nospec
    MOVE.l  d0,a1
    SUBQ.w  #4,a1
    MOVE.l  (a1),d0                         ; size of allocated memory into d1

    CNIF #DEBUG=1
    MOVE.l  a1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{004,"remgadlist: Special - freeing %ld bytes at $%lx"}
    LEA.l   2*4(a7),a7
    CEND

    ALibJsr #globalfree
    MOVE.l  (a7),a1                         ; pointer to gadget item
    'nospec:

    MOVE.l  {SizeOf.gtinlist\Text}(a1),d0   ; Pointer to text
    BEQ     'notext
    MOVE.l  d0,a1

    CNIF #DEBUG=1
    MOVE.l  a1,-(a7)
    !PUTSTR{005,"remgadlist: Text - freeing at $%lx"}
    LEA.l   4(a7),a7
    CEND

    ALibJsr #stringfree

    'notext:
    MOVE.l  (a7)+,a1                        ; pointer to gadget item

    ; Free memory for gadget item from internal list
    MOVEQ.l #SizeOf.gtinlist,d0
    CNIF #DEBUG=1
    MOVE.l  a1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{006,"remgadlist: GTInList - freeing %ld bytes at $%lx"}
    LEA.l   2*4(a7),a7
    CEND
    ALibJsr #globalfree

    MOVE.l  (a7)+,a0                        ; pointer to gtlist item
    BRA     'freeloop

    'donefree:
    MOVE.l  a0,a1                           ; Pointer to memory to free (current item in list)
    MOVEQ.l #SizeOf.gtil,d0                 ; Size of memory to free

    CNIF #DEBUG=1
    MOVE.l  a1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{007,"remgadlist: GTIL - freeing %ld bytes at $%lx"}
    LEA.l   2*4(a7),a7
    CEND
    ALibJsr #globalfree                     ; Free memory

    'nolist:
    MOVEM.l (a7)+,d0-d2/a0-a1
    RTS


; frees entire internal list
; no parameters and returns nothing
.reminternallist:
    MOVEM.l d0/a0-a1,-(a7)

    'filloop:
    LEA.l   internalglist,a1                ; pointer to head pointer -> a1 (need to store pointer to previous item)
    TST.l   (a1)
    BEQ     'nolist

    MOVE.l  (a1),a0                         ; Pointer to first item into a0
    MOVE.l  (a0),(a1)                       ; Copy pointer to next item in list to next field of previous item

    ; Go through all the gadgets in this gtlist and free the special info and then the gadget info structure
    'freeloop:

    MOVE.l  {SizeOf.gtil\First}(a0),d0      ; Pointer to head of gadgets into d0
    BEQ     'donefree
    MOVE.l  a0,-(a7)
    MOVE.l  d0,a1                           ; pointer to gadget info item into a0
    MOVE.l  (a1),{SizeOf.gtil\First}(a0)    ; put pointer to next item in the head of list pointer
    MOVE.l  a1,-(a7)
    MOVE.l  {SizeOf.gtinlist\Special}(a1),d0; Pointer to special info
    BEQ     'nospec
    MOVE.l  d0,a1
    SUBQ.w  #4,a1
    MOVE.l  (a1),d0                         ; size of allocated memory into d1

    CNIF #DEBUG=1
    MOVE.l  a1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"reminternallist: Special - freeing %ld bytes at $%lx"}
    LEA.l   2*4(a7),a7
    CEND
    ALibJsr #globalfree
    MOVE.l  (a7),a1
    'nospec:

    MOVE.l  {SizeOf.gtinlist\Text}(a1),d0   ; Pointer to text info
    BEQ     'notext
    MOVE.l  d0,a1

    CNIF #DEBUG=1
    MOVE.l  a1,-(a7)
    !PUTSTR{005,"reminternallist: Text - freeing at $%lx"}
    LEA.l   4(a7),a7
    CEND

    ALibJsr #stringfree

    'notext:
    MOVE.l  (a7)+,a1                        ; pointer to gadget item

    ; Free memory for gadget item from internal list
    MOVEQ.l #SizeOf.gtinlist,d0

    CNIF #DEBUG=1
    MOVE.l  a1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{002,"reminternallist: GTInList - freeing %ld bytes at $%lx"}
    LEA.l   2*4(a7),a7
    CEND
    ALibJsr #globalfree

    MOVE.l  (a7)+,a0                        ; pointer to gtlist item
    BRA     'freeloop

    'donefree:
    MOVE.l  a0,a1                           ; Pointer to memory to free (current item in list)
    MOVEQ.l #SizeOf.gtil,d0                 ; Size of memory to free
    CNIF #DEBUG=1
    MOVE.l  a1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{003,"reminternallist: GTIL - freeing %ld bytes at $%lx"}
    LEA.l   2*4(a7),a7
    CEND
    ALibJsr #globalfree                     ; Free memory

    BRA     'filloop

    'nolist:
    MOVEM.l (a7)+,d0/a0-a1
    RTS


; Search internal lists for a gadget
; d0.w=pointer to gtlist
; d1.w=gadget ID
; Returns pointer to gadget (internal info structure) in d0
; Preserves all registers
.findgadget:
    MOVEM.l d1-d2/a0,-(a7)
    MOVE.l  d0,d2
    MOVE.l  internalglist(pc),a0            ; Pointer to head of list into a0

    'gtloop:
    MOVE.l  a0,d0
    BEQ     'nolist

    CMP.l   {SizeOf.gtil\gtlst}(a0),d2
    BEQ     'gotlist

    MOVE.l  (a0),a0
    BRA     'gtloop

    ; Found start of gtlist - search for gadget
    'gotlist:
    MOVE.l  {SizeOf.gtil\First}(a0),a0

    'gadloop:
    MOVE.l  a0,d0
    BEQ     'nolist
    CMP.w   {SizeOf.gtinlist\id}(a0),d1
    BEQ     'nolist
    MOVE.l  (a0),a0
    BRA     'gadloop

    'nolist:
    MOVEM.l (a7)+,d1-d2/a0
    RTS


; Added 04/01/02 - deals with the new memory allocations required by the lib
; Returns pointer to newly allocated internal memory
._handlestd:
    MOVE.l  gtbase(pc),a6                   ; gadtools.library into a6
    MOVE.l  (a0),a0                         ; Pointer to currently used IntuiFont object (TextAttr) into a0
    CNIF #DEBUG=1
    MOVE.l  a0,-(a7)
    !PUTSTR{001,"handlestd: Currently used intuifont object $%lx"}
    LEA.l   4(a7),a7
    CEND

    MOVE.l  (a1),a1                         ; Pointer to OS screen structure from currently used screen object
    CNIF #DEBUG=1
    MOVE.l  a1,-(a7)
    !PUTSTR{002,"handlestd: OS screen structure $%lx"}
    LEA.l   4(a7),a7
    CEND

    TST.w   gzzpos                          ; Test whether window border sizes should be added to gadget positions
    BNE     'gzzskip                        ; if not 0, branch past the adding code
    MOVEQ.l #0,d0                           ; clear upper bytes of d0
    MOVE.b  !s{WBorLeft}(a1),d0             ; Get window top border size
    ADD.w   d0,d2                           ; add left border to gadget left position
    MOVE.b  !s{WBorTop}(a1),d0              ; Window top border height into d0
    ADD.w   d0,d3                           ; Add top border to gadget top position
    ;ADD.w   !s{RastPort\TxHeight}(a1),d3    ; Add font height to gadget top position
    ADD.w   142(a1),d3                      ; Same as above, but works
    ADDQ.w  #1,d3                           ; The final piece of the puzzle :)

    'gzzskip:
    MOVE.l  a1,d0                           ; Preserve screen pointer
    LEA.l   wrkgadget(pc),a1                ; Pointer to working NewGadget structure into a1
    MOVE.w  d1,!n{ng_GadgetID}(a1)          ; Store gadget ID
    MOVEM.w d2-d5,!n{ng_LeftEdge}(a1)       ; store left, top, width and height in NewGadget
    MOVE.l  a0,!n{ng_TextAttr}(a1)          ; pointer to currently used intuifont object in newgadget
    MOVE.l  d0,d2                           ; More shuffling of the screen pointer

    MOVE.l  -(a2),d1                        ; get length of Text$ string into d1
    MOVE.l  -(a2),d0                        ; get pointer to string into d0 (??? is it??? didn't think that got put on the stack
    ALibJsr #stringalloc                    ; allocate and copy the string for this gadget
    MOVE.l  d0,!n{ng_GadgetText}(a1)        ; store pointer to text in ng_GadgetText
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{003,"handlestd: Allocated string for Text$ at $%lx"}
    LEA.l   4(a7),a7
    CEND

    BSR     _getcontext                     ; Make sure there is a context in the GTList
    LEA.l   wrkgadget(pc),a1                ; Pointer to working NewGadget structure into a1

    MOVEQ.l #0,d0                           ; Clear upper word of d0
    MOVE.w  !n{ng_GadgetID}(a1),d0          ; Get gadget ID
    MOVE.l  a3,d1                           ; Pointer to GTList
    BSR     addgadptr                       ; Create internal storage
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{004,"handlestd: Allocated internal memory at $%lx"}
    LEA.l   4(a7),a7
    CEND

    TST.l   d0                              ; Check pointer to memory
    BEQ     'noalloc

    MOVE.l  d0,a0                           ; Pointer to newly allocated memory into a0
    MOVE.l  !n{ng_GadgetText}(a1),{SizeOf.gtinlist\Text}(a0)

    'noalloc:
    MOVEQ.l #0,d2                           ; Clear upper word of d2
    MOVE.l  -(a2),d1                        ; Get flags parameter from stack
    MOVE.w  underscore,d2                   ; Get ASCII code of underscore character
    RTS
    ; d0 = pointer to allocated memory
    ; d1 = Flags parameter
    ; d2 = ASCII code for underscore character
    ; a0 = same as d0
    ; a1 = pointer to wrkgadget
    ; a2 = pointer to remaining parameters
    ; a3 = pointer to GTList object
    ; a6 = gadtools.library


; Parameters: d0=kind of gadget, a1=pointer to wrkgadget, a2=pointer to tags, a3=gtlist obj, a6=gadtools.library
; Returns: d0=pointer to gadget or NULL for failure (+mem freed). If not null, current gadget in gtcontext also points to new ga
._createstd:
    MOVEM.l d1/a0-a1,-(a7)
    MOVE.l  {SizeOf.gtcontext\current}(a3),a0
    MOVE.l  {SizeOf.gtcontext\visualinfo}(a3),!n{ng_VisualInfo}(a1)

    CNIF #DEBUG=1
    MOVE.l  a2,-(a7)
    MOVE.l  a1,-(a7)
    MOVE.l  a0,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"createstd: CreateGadget parameters %ld,$%lx,$%lx,$%lx"}
    LEA.l   4*4(a7),a7
    CEND

    ; a1 already has pointer to wrkgadget
    ; a2 already has pointer to taglist
    JSR     _CreateGadget(a6)
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{002,"createstd: Created gadget $%lx"}
    LEA.l   4(a7),a7
    CEND

    MOVEM.l (a7)+,d1/a0-a1                  ; Restore registers

    TST.l   d0                              ; Test pointer to created gadget
    BEQ     'nogad                          ; if NULL, exit routine

    MOVE.l  d0,{SizeOf.gtinlist\Gad}(a0)    ; Else, store pointer to gadget in internal memory (see, thats why we restore early)
    MOVE.l  d0,{SizeOf.gtcontext\current}(a3) ; And store in the current gadget pointer of GTList
    RTS

    'nogad:
    MOVE.l  a3,d0                           ; Pointer to gtlist object
    MOVEQ.l #0,d1                           ; Clear upper word of d1
    MOVE.l  {SizeOf.gtinlist\id}(a0),d1     ; Set lower word to gadget ID
    CNIF #DEBUG=1
    MOVE.l  d1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{003,"createstd: Removing gadget with GTList,ID: $%lx,%ld"}
    LEA.l   2*4(a7),a7
    CEND
    BSR     remgadptr
    MOVEQ.l #0,d0                           ; Clear d0 for the return value
    RTS

;    MOVEQ.l #BUTTON_KIND,d0                 ; Type of gadget to create
;    MOVE.l  {SizeOf.gtcontext\current}(a3),a0
;    JSR     _CreateGadget(a6)
;    MOVE.l  (a7)+,d3                        ; Get flags parameter off stack
;
;    CNIF    #DEBUG=1
;    MOVE.l  d0,-(a7)
;    !PUTSTR{003,"_gtbutton: Created gadget = $%lx"}
;    LEA.l   4(a7),a7
;    CEND
;
;    TST.l   d0
;    BNE     'gadok
;
;    ; Gadget creation failed!
;    ; Free the internal memory we allocated
;    MOVE.l  a3,d0                           ; Pointer to GTList object
;    MOVE.l  intmem(pc),a3                   ; Get pointer to internal memory allocated
;    MOVEQ.l #0,d1
;    MOVE.w  {SizeOf.gtinlist\id}(a3),d1
;
;    CNIF #DEBUG=1
;    MOVE.l  d1,-(a7)
;    MOVE.l  d0,-(a7)
;    !PUTSTR{004,"_gtbutton: Removing gadget with GTList,ID: $%lx,%ld"}
;    LEA.l   2*4(a7),a7


; makes sure we have a valid gadgetlist context
; Parameters: d2=pointer to screen, a3=pointer to gtlist object, a6=gadtools.library
; Returns nothing
; Trashes: a0, d0, a1
._getcontext:
    CNIF #DEBUG=1
    MOVE.l  (a3),-(a7)
    !PUTSTR{001,"getcontext: Context= $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   (a3)                            ; check pointer to gadgetlist in gtlist
    BNE     'gotcontext                     ; if not NULL then we already have a context, skip to end of routine

    MOVE.l  a3,a0                           ; put pointer to gadgetlist context pointer in a0 (**gad)
    JSR     _CreateContext(a6)              ; call gadtools.library/CreateContext
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{002,"getcontext: Created context $%lx"}
    LEA.l   4(a7),a7
    CEND
    MOVE.l  d0,(a3)                         ; store new context pointer in the gadgetlist pointer in gtlist ob
    MOVE.l  d0,{SizeOf.gtcontext\current}(a3); store same pointer as the current gadget pointer

    MOVE.l  d2,a0                           ; get pointer to OS screen in a0
    LEA     nulltags(pc),a1                 ; get pointer to a taglist with nothing in it
    JSR     _GetVisualInfo(a6)              ; call gadtools.library/GetVisualInfo
    MOVE.l  d0,{SizeOf.gtcontext\visualinfo}(a3); store visualinfo pointer in visualinfo for gtlist object
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{003,"getcontext: Got visual info $%lx"}
    LEA.l   4(a7),a7
    CEND

    'gotcontext:
    RTS


; a3 = pointer to gtlist
._freecontext:
    MOVEM.l d0-d1/a0-a1,-(a7)
    CNIF #DEBUG=1
    MOVE.l  a3,-(a7)
    !PUTSTR{001,"_freecontext: Pointer to GTList object to free = $%lx"}
    LEA.l   4(a7),a7
    CEND

    TST.l   (a3)                            ; test pointer to gadgetlist in gtlist object
    BEQ     'donefree                       ; if pointer is NULL, we don't need to free anything, skip to end of routine

    ; Go through the internal list to find this gtlist
    MOVE.l  internalglist(pc),a0            ; Pointer to head of list into a0

    'gtloop:
    MOVE.l  a0,d0
    BEQ     'nolist
    CMP.l   {SizeOf.gtil\gtlst}(a0),a3
    BEQ     'gotlist
    MOVE.l  (a0),a0
    BRA     'gtloop

    ; Found start of gtlist - search through gadgets and clear the GadgetRender and SelectRender fields of the GTShapes
    'gotlist:
    MOVE.l  {SizeOf.gtil\First}(a0),a0
    'gadloop:
    MOVE.l  a0,d0
    BEQ     'nolist
    ; Check gadget flags here and clear render fields if required
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a1
    BTST    #2,13(a1)                       ; Test #GFLG_GADGIMAGE in lower byte of Gadget\Flags field
    BEQ     'noshp
    CNIF #DEBUG=1
    MOVE.l  a1,-(a7)
    !PUTSTR{002,"_freecontext: Clearing GadgetRender from gadget $%lx"}
    LEA.l   4(a7),a7
    CEND
    CLR.l   !g{GadgetRender}(a1)            ; Clear Image pointer
    MOVEQ.l #GFLG_GADGHIGHBITS,d0
    AND.w   !g{Flags}(a1),d0
    CMPI.w  #GFLG_GADGHIMAGE,d0
    BNE     'noshp
    CNIF #DEBUG=1
    MOVE.l  a1,-(a7)
    !PUTSTR{003,"_freecontext: Clearing SelectRender from gadget $%lx"}
    LEA.l   4(a7),a7
    CEND
    CLR.l   !g{SelectRender}(a1)
    'noshp:
    MOVE.l  (a0),a0
    BRA     'gadloop

    ; Remove this GTList object from the internal list
    'nolist:
    MOVE.l  a3,d0
    JSR     remgadlist
    MOVE.l  gtbase(pc),a6                   ; get pointer to gadtools.library in a6
    MOVE.l  (a3),a0                         ; put pointer to gadget list into a0
    JSR     _FreeGadgets(a6)                ; call gadtools.library/FreeGadgets
    MOVE.l  4(a3),a0                        ; move visualinfo field of gtlist object into a0
    JSR     _FreeVisualInfo(a6)             ; call gadtools.library/FreeVisualInfo
    CLR.l   (a3)                            ; clear pointer to gadgetlist in gtlist object
    'donefree:
    MOVEM.l (a7)+,d0-d1/a0-a1
    RTS


; d0 = pointer to options string
; d1 = length of said string
; Returns pointer to allocated memory (with size stored at -4(pointer)
.getoptions:
    MOVEM.l d1-d4/a0-a2,-(a7)

    ; Count how many options need to be displayed in the cycle gadget
    ; (the number of "|" characters in the string + 1 + 1 more for NULL to terminate array)
    ; + 1 more for storing length of allocated memory)
    MOVEQ.l #3,d2                           ; Initial count value
    MOVE.l  d0,a0                           ; Pointer to access it
    'countloop:
    MOVE.b  (a0)+,d3                        ; get next char from string into d3
    BEQ     'endcount                       ; if NULL, end of string, exit loop
    CMP.b   #"|",d3                         ; compare character from string to option separator
    BNE     'countloop                      ; if not same, repeat loop
    ADDQ.l  #1,d2                           ; increase number of longs to allocate
    BRA     'countloop                      ; repeat loop
    'endcount:

    ; by the time we get here, we have the number of longs to allocate in d2 and are 1 char past the end of the string in a0
    ; and d3:7-0 is 0.

    CNIF #DEBUG=1
    MOVE.l  d1,-(a7)
    MOVE.l  d2,-(a7)
    !PUTSTR{001,"getoptions: number of longs, length of string = %ld, %ld"}
    LEA.l   2*4(a7),a7
    CEND

    LSL.l   #2,d2                           ; Number of bytes to allocate for the longs
    MOVE.l  d2,d4                           ; Copy length of longs to d4
    ADD.l   d1,d2                           ; add length of string to get total memory size to allocate
    ADDQ.l  #1,d2                           ; and one for the final NULL

    EXG.l   d0,d2                           ; swap string pointer and size of mem to allocate
    MOVE.l  d0,d3                           ; Copy size of allocated memory into d3
    MOVE.l  #MEMF_PUBLIC|MEMF_CLEAR,d1      ; type of memory to allocate
    ALibJsr #globalalloc

    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{002,"getoptions: Allocated memory at $%lx"}
    LEA.l   4(a7),a7
    CEND

    TST.l   d0
    BEQ     'noalloc

    MOVE.l  d0,a0                           ; Pointer to allocated memory into a0
    MOVE.l  d3,(a0)+                        ; store length of memory allocated into allocated memory and correct pointer
    MOVE.l  a0,d0
    SUBQ.l  #4,d4                           ; Subtract the size of the long used for memsize
    LEA     0(a0,d4),a1                     ; move to start of text (past array of pointers) in a1

    LSR.l   #2,d4                           ; number of pointers in the array
    SUBQ.l  #2,d4                           ; and subtract 2 to keep counter happy (1 for counter, 1 for NULL)

    MOVE.l  d2,a2                           ; Pointer to start of string into a2
    'arrayloop:
    MOVE.l  a1,(a0)+                        ; Copy pointer to start of string into array

    CNIF #DEBUG=1
    MOVE.l  a2,-(a7)
    !PUTSTR{003,"getoptions: pointer to start of option string = $%lx"}
    LEA.l   4(a7),a7
    CEND

    'copyoptloop:
    MOVE.b  (a2)+,d3                        ; get character from string and move onto next
    CMP.b   #"|",d3                         ; check if we reached the end of this option
    BNE     'dochar                         ; if not | character, branch past next line
    MOVEQ.l #0,d3                           ; set character to store as NULL character
    'dochar:
    MOVE.b  d3,(a1)+                        ; store char in target memory
    BNE     'copyoptloop                    ; if not NULL char, repeat for next character in this target string

    DBRA    d4,'arrayloop                   ; decrease count of options in the string and repeat

    'noalloc:
    MOVEM.l (a7)+,d1-d4/a0-a2
    RTS


.
.GadgetCommands
._attachgtlist
    MOVEM.l a3-a4,-(a7)
    MOVE.l  (a0),a0
    MOVE.l  a0,12(a1)
    MOVE.l  (a1),a1
    MOVE.l  a0,a3
    MOVE.l  a1,a4
    MOVEQ   #-1,d0
    MOVE.l  d0,d1
    SUB.l   a2,a2
    JSR     _LVOAddGList(a6)
    MOVE.l  a4,a0
    MOVE.l  a3,a1
    SUB.l   a2,a2
    MOVEQ   #-1,d0
    JSR     _LVORefreshGList(a6)
    MOVE.l  a3,a0
    SUB.l   a1,a1
    MOVE.l  gtbase(pc),a6
    JSR     _RefreshWindow(a6)
    MOVEM.l (a7)+,a3-a4
    RTS


._detachgtlist
    TST.l 12(a1)
    BEQ 'ok
    MOVE.l  12(a1),a0                       ; get pointer to window that this gtlist is attached to
    MOVE.l  #0,12(a1)                       ; clear pointer to window (seeing as we are detaching :)
    MOVE.l  (a1),a1                         ; get pointer to head of gadget list
    MOVEQ.l #-1,d0                          ; set number of gadgets to remove as all of them
    JSR     _LVORemoveGList(a6)             ; call intuition.library/RemoveGList
'ok: RTS


;._gt<whatever>
;    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers
;
;    BSR     _handlestd                      ; Do standard processing for all gadgets
;    CNIF #DEBUG=1
;    MOVE.l  d0,-(a7)
;    !PUTSTR{001,"gt<whatever>: Return from handlestd $%lx"}
;    LEA.l   4(a7),a7
;    CEND
;    TST.l   d0                              ; Check if we could allocate internal memory
;    BEQ     'nogad                          ; if NULL, we have none, exit
;
;    ; Do flags and extra parameter processing
;    CNIF #OLDFLAGS=1
;    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
;    CEND
;    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
;    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
;    BEQ     'noutags
;
;    MOVEQ.l #TAG_MORE,d0                    ;
;    'noutags:
;    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not
;
;    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
;    MOVEQ.l #<whatever>_KIND,d0             ; Gadget type
;    BSR     _createstd                      ; Create gadget
;
;    ; test/branch then post process
;    TST.l   d0
;    BEQ     'nogad
;
;    ; Post processing here
;
;    'nogad:
;    CLR.l   usertags                        ; Clear first tag in usertags
;    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
;    MOVEM.l (a7)+,a3-a5
;    RTS
;'defaulttags:
;    Dc.l GT_Underscore,95
;'ut:Dc.l 0,usertags


._gtbutton
    MOVE.l  -16(a2),wrkgadget+26            ; Store user specified USerData field in the userdata field of the NewGadget structu
_gtbuttonnoud:                              ; No userdata parameter
    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers

    BSR     _handlestd                      ; Do standard processing for all gadgets
    MOVE.l  d2,'defaulttags+20              ; Store ASCII code as data for GT_Underscore tag
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gtbutton: Return from handlestd $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; Check if we could allocate internal memory
    BEQ     'nogad                          ; if NULL, we have none, exit

    ; Do flags and extra parameter processing
    CNIF #OLDFLAGS=1
    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
    MOVE.l  d1,d3                           ; Copy of the flags parameter for later
    BTST    #6,d1                           ; Check bit 6 of flags
    SNE     d2 : EXT d2 : EXT.l d2          ; Set d2 to 0 or -1 depending on state of flag
    MOVE.l  d2,4(a4)                        ; Store boolean as ti_Data for GA_Disabled tag
    BTST    #7,d1                           ; check bit 7 of flags
    SNE     d2 : EXT d2 : EXT.l d2          ; Set d2 to 0 or -1 depending on state of flag
    MOVE.l  d2,12(a4)                       ; Store boolean as ti_Data for GA_Immediate tag
    AND.l   #$3F,d1                         ; Clear all bbgtlib flags
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags

    MOVEQ.l #TAG_MORE,d0                    ;
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVEQ.l #BUTTON_KIND,d0                 ; Gadget type
    BSR     _createstd                      ; Create gadget

    ; test/branch then post process
    TST.l   d0
    BEQ     'nogad

    ; Post processing here
    CNIF #OLDFLAGS=1
    MOVE.l  d0,a0                           ; Pointer to gadget into a0
    BTST    #13,d3                          ; Check bit 13 in the flags parameter
    BEQ     'notoggle                       ; if not set, branch past setting the toggle activation
    BSET    #0,14(a0)                       ; set bit 9 in the Gadget\Activation field
    'notoggle:
    CEND

    'nogad:
    CLR.l   usertags                        ; Clear first tag in usertags
    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
    Dc.l GA_Disabled,0
    Dc.l GA_Immediate,0
    Dc.l GT_Underscore,95
'ut:Dc.l 0,usertags


._gtcheckbox:
    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers

    BSR     _handlestd                      ; Do standard processing for all gadgets
    MOVE.l  d2,'defaulttags+28              ; Store ASCII code as data for GT_Underscore tag
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gtcheckbox: Return from handlestd $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; Check if we could allocate internal memory
    BEQ     'nogad                          ; if NULL, we have none, exit

    ; Do flags and extra parameter processing
    CNIF #OLDFLAGS=1
    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
    BTST    #6,d1                           ; Test bit 6 in flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean to mirror state of bit 6
    MOVE.l  d2,4(a4)                        ; Store boolean as the ti_Data for the GA_Disabled tag
    BTST    #8,d1                           ; Test bit 8 in flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean to mirror state of bit 6
    MOVE.l  d2,12(a4)                       ; Store boolean as the ti_Data for the GTCB_Checked tag
    BTST    #9,d1                           ; Test bit 9 in flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean to mirror state of bit 6
    MOVE.l  d2,20(a4)                       ; Store boolean as the ti_Data for the GTCB_Scaled tag
    AND.l   #$3f,d1                         ; Mask out all Blitz2 flags
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags

    MOVEQ.l #TAG_MORE,d0                    ;
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVEQ.l #CHECKBOX_KIND,d0               ; Gadget type
    BSR     _createstd                      ; Create gadget

    ; No post-processing

    'nogad:
    CLR.l   usertags                        ; Clear first tag in usertags
    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
    Dc.l GA_Disabled,0
    Dc.l GTCB_Checked,0
    Dc.l GTCB_Scaled,0
    Dc.l GT_Underscore,95
'ut:Dc.l 0,usertags


._gtcycle:
    MOVE.w  -22(a2),d0                      ; Store active parameter in d0
    BRA     _gtcyclenoactive
_gtcycle2:
    MOVEQ.l #0,d0

_gtcyclenoactive:                           ; Start of routine now all that crap is outta the way
    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers
    MOVE.w  d0,'defaulttags+22              ; Store active parameter as ti_Data for GTCY_Active tag

    BSR     _handlestd                      ; Do standard processing for all gadgets
    MOVE.l  d2,'defaulttags+28              ; Store ASCII code as data for GT_Underscore tag
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gtcycle: Return from handlestd $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; Check if we could allocate internal memory
    BEQ     'nogad                          ; if NULL, we have none, exit

    ; Do flags and extra parameter processing
    CNIF #OLDFLAGS=1
    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
    BTST    #6,d1                           ; Check bit 6 of flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean based on state of bit
    MOVE.l  d2,4(a4)                        ; store as ti_Data for GA_Disabled tag
    AND.l   #$3f,d1                         ; Remove all Blitz2 flag bits
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags

    MOVEQ.l #TAG_MORE,d0                    ;
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    MOVE.l  -(a2),d1                        ; Pointer to length of options string from stack
    MOVE.l  -(a2),d0                        ; Pointer to options string from stack
    BSR     getoptions                      ; Create the array of GTCycle options
    TST.l   d0                              ; Check if we could allocate it OK
    BEQ     'failedopts                     ; if NULL, exit routine

    MOVE.l  d0,'defaulttags+12              ; Store pointer to array as labels
    MOVE.l  d0,{SizeOf.gtinlist\Special}(a0); Store in internal memory so it gets freed later

    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVEQ.l #CYCLE_KIND,d0                  ; Gadget type
    BSR     _createstd                      ; Create gadget
    BRA     'nogad                          ; whether it works or not, we have no post-processing

    'failedopts:
    MOVEQ.l #0,d1
    MOVE.w  {SizeOf.gtinlist\id}(a0),d1     ; Get gadget ID to free
    MOVE.l  a3,d0                           ; Pointer to GTList object in which the gadget is

    CNIF #DEBUG=1
    MOVE.l  d1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{002,"gtcycle: Removing gadget with GTList,ID: $%lx,%ld"}
    LEA.l   2*4(a7),a7
    CEND
    BSR     remgadptr                       ; Free this gadget (due to option failure)
    MOVEQ.l #0,d0                           ; return value of 0 to indicate failure

    'nogad:
    CLR.l   usertags                        ; Clear first tag in usertags
    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
    Dc.l GA_Disabled,0
    Dc.l GTCY_Labels,0
    Dc.l GTCY_Active,0
    Dc.l GT_Underscore,95
'ut:Dc.l 0,usertags


._gtinteger:
    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers

    BSR     _handlestd                      ; Do standard processing for all gadgets
    MOVE.l  d2,'defaulttags+28              ; Store ASCII code as data for GT_Underscore tag
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gtinteger: Return from handlestd $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; Check if we could allocate internal memory
    BEQ     'nogad                          ; if NULL, we have none, exit

    ; Do flags and extra parameter processing
    CNIF #OLDFLAGS=1
    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
    BTST    #6,d1                           ; Test bit 6 of flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean LONG depending on state of bit
    MOVE.l  d2,4(a4)                        ; Store as data for GA_Disabled tag
    BTST    #7,d1                           ; Test bit 7 from flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean LONG based on bit state
    MOVE.l  d2,12(a4)                       ; store as data for GA_Immediate tag
    AND.l   #$3f,d1
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags

    MOVEQ.l #TAG_MORE,d0                    ;
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    MOVE.l  -(a2),'defaulttags+20           ; Store default value parameter in taglist

    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVEQ.l #INTEGER_KIND,d0                ; Gadget type
    BSR     _createstd                      ; Create gadget

    'nogad:
    CLR.l   usertags                        ; Clear first tag in usertags
    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
    Dc.l GA_Disabled,0
    Dc.l GA_Immediate,0
    Dc.l GTIN_Number,0
    Dc.l GT_Underscore,95
'ut:Dc.l 0,usertags


_gtlistview1:
    MOVE    -18(a2),d0                      ; Set selected value into d0 (for the selected)
    MOVE    -18(a2),d6                      ; Set selected value into d6 (for the top value)
    BRA     _gtlistviewstart                ; Branch to start of real code
_gtlistview2
    MOVE    -18(a2),d0                      ; Set selected value into d0 (for the selected)
    MOVE    -22(a2),d6                      ; Set selected value into d6 (for the top value)
    BRA     _gtlistviewstart                ; Branch to start of real code
._gtlistview:
    MOVEQ.l #0,d6                           ; Default value for top=0
    MOVEQ.l #-1,d0                          ; Default value for selected=~0 (none selected)
_gtlistviewstart:
    EXT.l   d0 : EXT.l  d6                  ; Create longwords out of the word parameters
    MOVE.l  d6,'defaulttags+20              ; Store d6 as the data for the GTLV_Top tag
    MOVE.l  d0,'defaulttags+28              ; Store d0 as the data for the GTLV_Selected tag

    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers

    BSR     _handlestd                      ; Do standard processing for all gadgets
    MOVE.l  d2,'defaulttags+44              ; Store ASCII code as data for GT_Underscore tag
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gtlistview: Return from handlestd $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; Check if we could allocate internal memory
    BEQ     'nogad                          ; if NULL, we have none, exit

    ; Do flags and extra parameter processing
    CNIF #OLDFLAGS=1
    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
    BTST    #6,d1                           ; Test bit 6 of the flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean based on status of bit
    MOVE.l  d2,4(a4)                        ; store as data for GA_Disabled tag
    BTST    #12,d1                          ; Test bit 12 of the flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean based on status of bit
    MOVE.l  d2,36(a4)                       ; store as data for GA_ReadOnly tag
    AND     #$3f,d1                         ; Clear all Blitz2 flags
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags

    MOVEQ.l #TAG_MORE,d0                    ;
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    MOVE.l  -(a2),a2                        ; Get list() parameter from stack
    LEA     -28(a2),a2                      ; list()-28 is the address of the list header?
    MOVE.l  a2,'defaulttags+12              ; store pointer as the data from GTLV_Labels

    MOVE.l  8(a3),-(a7)                     ; Preserve pointer to gadget before the listview for later prop style chicanery

    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVEQ.l #LISTVIEW_KIND,d0               ; Gadget type
    BSR     _createstd                      ; Create gadget

    ; test/branch then post process
    MOVE.l  (a7)+,a0                        ; Restore pointer to previous gadget from stack
    TST.l   d0
    BEQ     'nogad

    ; Post processing here
    ; DM 20001125 - If propmode set, set the flag for new look

    TST.w   propmode                        ; check value of propmode flag
    BEQ     'nogad                          ; if 0 skip setting the prop flags
    MOVE.l  (a0),a0                         ; and move onto the first part of the listview gadget
    MOVE.w  38(a0),d1                       ; put gadget ID into d1

    'lastloop:                              ; goes through the list of gadgets with the same ID
    MOVE.w  16(a0),d2                       ; get gadget type into d2
    AND.w   #GTYP_GTYPEMASK,d2              ; clear out all bits except the gadget types
    CMP.w   #GTYP_PROPGADGET,d2             ; check if this is a prop gadget
    BNE     'notprop

    MOVEA.l !g{SpecialInfo}(a0),a1          ; Gadget SpecialInfo -> a1 (PropInfo)
    OR.w    #PROPNEWLOOK,(a1)               ; set bit for PROPNEWLOOK

    'notprop:
    MOVE.l  (a0),d2                         ; move onto next gadget
    BEQ     'nogad                          ; if NULL, end of list, exit routine
    MOVEA.l d2,a0                           ; else pointer to gadget -> a0
    CMP.w   38(a0),d1                       ; compare gadget IDs
    BEQ     'lastloop                       ; If same, still some gadgets To process, Repeat loop

    'nogad:
    CLR.l   usertags                        ; Clear first tag in usertags
    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
    Dc.l GA_Disabled,0                      ; 0,4
    Dc.l GTLV_Labels,0                      ; 8,12
    Dc.l GTLV_Top,0                         ; 16,20
    Dc.l GTLV_Selected,-1                   ; 24,28
    Dc.l GTLV_ReadOnly,0                    ; 32,36
    Dc.l GT_Underscore,95                   ;
'ut:Dc.l 0,usertags


_gtmx2:
    MOVEQ.l #0,d0
    MOVE.w  -22(a2),d0                      ; Get active parameter from stack
    BRA     gtmx_start
._gtmx:
    MOVEQ.l #0,d0
gtmx_start:
    MOVE.l  d0,'defaulttags+28              ; Store active parameter as data for GTMX_Active tag
    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers

    BSR     _handlestd                      ; Do standard processing for all gadgets
    MOVE.l  d2,'defaulttags+36              ; Store ASCII code as data for GT_Underscore tag
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gtmx: Return from handlestd $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; Check if we could allocate internal memory
    BEQ     'nogad                          ; if NULL, we have none, exit

    ; Do flags and extra parameter processing
    CNIF #OLDFLAGS=1
    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
    BTST    #6,d1                           ; Test bit 6 in flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean long from state of bit 6
    MOVE.l  d2,4(a4)                        ; store boolean as data for GA_Disabled tag
    BTST    #9,d1                           ; test bit 9 in flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean long from state of bit 6
    MOVE.l  d2,20(a4)                       ; store boolean as data for GTMX_Scaled tag
    AND.l   #$3f,d1                         ; Mask out all Blitz2 flags
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags

    MOVEQ.l #TAG_MORE,d0                    ;
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    MOVE.l  -(a2),d1                        ; Pointer to length of options string from stack
    MOVE.l  -(a2),d0                        ; Pointer to options string from stack
    BSR     getoptions                      ; Create the array of GTCycle options
    TST.l   d0                              ; Check if we could allocate it OK
    BEQ     'failedopts                     ; if NULL, exit routine

    MOVE.l  d0,'defaulttags+12              ; Store pointer to array as labels
    MOVE.l  d0,{SizeOf.gtinlist\Special}(a0); Store in internal memory so it gets freed later

    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVEQ.l #MX_KIND,d0                     ; Gadget type
    BSR     _createstd                      ; Create gadget
    BRA     'nogad                          ; whether it works or not, we have no post-processing

    'failedopts:
    MOVEQ.l #0,d1
    MOVE.w  {SizeOf.gtinlist\id}(a0),d1     ; Get gadget ID to free
    MOVE.l  a3,d0                           ; Pointer to GTList object in which the gadget is

    CNIF #DEBUG=1
    MOVE.l  d1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{002,"gtmx: Removing gadget with GTList,ID: $%lx,%ld"}
    LEA.l   2*4(a7),a7
    CEND
    BSR     remgadptr                       ; Free this gadget (due to option failure)
    MOVEQ.l #0,d0                           ; return value of 0 to indicate failure

    'nogad:
    CLR.l   usertags                        ; Clear first tag in usertags
    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
    Dc.l GA_Disabled,0
    Dc.l GTMX_Labels,0
    Dc.l GTMX_Scaled,0
    Dc.l GTMX_Active,0
    Dc.l GT_Underscore,95
'ut:Dc.l 0,usertags


._gtnumber:
    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers

    BSR     _handlestd                      ; Do standard processing for all gadgets
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gtnumber: Return from handlestd $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; Check if we could allocate internal memory
    BEQ     'nogad                          ; if NULL, we have none, exit

    ; Do flags and extra parameter processing
    CNIF #OLDFLAGS=1
    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
    BTST    #15,d1                          ; Test bit 14 of the flags parameter
    SEQ     d2 : EXT d2 : EXT.l d2          ; Create long boolean based on inverted state of bit
    MOVE.l  d2,'defaulttags+12              ; Store as data for GTNM_Border tag
    AND.l   #$3F,d1                         ; Mask out all Blitz2 flags
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags

    MOVEQ.l #TAG_MORE,d0                    ;
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    MOVE.l  -(a2),d0                        ; Get value parameter from stack
    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVE.l  d0,4(a2)                        ; store value as data for GTNM_Number tag
    MOVEQ.l #NUMBER_KIND,d0                 ; Gadget type
    BSR     _createstd                      ; Create gadget

    'nogad:
    CLR.l   usertags                        ; Clear first tag in usertags
    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
    Dc.l GTNM_Number,0
    Dc.l GTNM_Border,-1
'ut:Dc.l 0,usertags


_gtpalette2:
    MOVEQ.l #0,d0                           ; Clear upper word of d0
    MOVE.w  -18(a2),d0                      ; Get colour parameter from stack
    BRA     gtp_start                       ; start routine proper
._gtpalette:
    MOVEQ.l #0,d0                           ; Default colour value for no parameter
gtp_start:
    MOVE.l  d0,'defaulttags+20              ; Store colour in taglist
    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers

    BSR     _handlestd                      ; Do standard processing for all gadgets
    MOVE.l  d2,'defaulttags+28              ; Store ASCII code as data for GT_Underscore tag
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gtpalette: Return from handlestd $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; Check if we could allocate internal memory
    BEQ     'nogad                          ; if NULL, we have none, exit

    ; Do flags and extra parameter processing
    CNIF #OLDFLAGS=1
    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
    BTST    #6,d1                           ; Test bit 6 in flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create LONG boolean based on status of flags
    MOVE.l  d2,4(a4)                        ; store as data for GA_Disabled tag
    AND.l   #$3f,d1                         ; Remove all Blitz2 flags
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags

    MOVEQ.l #TAG_MORE,d0                    ;
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    MOVE.l  -(a2),d0                        ; Get depth parameter from stack
    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVE.l  d0,12(a2)                       ; Store depth in taglist
    MOVEQ.l #PALETTE_KIND,d0                ; Gadget type
    BSR     _createstd                      ; Create gadget

    'nogad:
    CLR.l   usertags                        ; Clear first tag in usertags
    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
    Dc.l GA_Disabled,0      ;0,4
    Dc.l GTPA_Depth,0       ;8,12
    Dc.l GTPA_Color,0       ;16,20
    Dc.l GT_Underscore,95   ;
'ut:Dc.l 0,usertags         ;


_gtscroller2:
    MOVEQ.l #0,d0                           ; Clear upper word of d0
    MOVE.w  -18(a2),d0                      ; Get Top parameter from stack
    BRA     gtsc_start                       ; branch to start of routine proper
._gtscroller:
    MOVEQ.l #0,d0                           ; No Top parameter specified, defaults to 0
gtsc_start:
    MOVE.l  d0,'defaulttags+52              ; Store the value for the Top parameter in the taglist
    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers

    BSR     _handlestd                      ; Do standard processing for all gadgets
    MOVE.l  d2,'defaulttags+68              ; Store ASCII code as data for GT_Underscore tag
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gtscroller: Return from handlestd $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; Check if we could allocate internal memory
    BEQ     'nogad                          ; if NULL, we have none, exit

    ; Do flags and extra parameter processing
    MOVE.w  -(a2),d2                        ; Get Visible parameter from stack
    EXT.l   d2                              ; is this needed?
    MOVE.l  d2,'defaulttags+28              ; Store in taglist
    MOVE.w  -(a2),d2                        ; Get Total parameter from stack
    EXT.l   d2                              ; Is this needed?
    MOVE.l  d2,'defaulttags+36              ; Stoer in taglist

    CNIF #OLDFLAGS=1
    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
    BTST    #6,d1                           ; Test bit 6 of the flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean long from state of bit
    MOVE.l  d2,4(a4)                       ; Store boolean as the data for the GA_Immediate tag
    BTST    #7,d1                           ; Test bit 7 of the flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create long boolean based on state of bit
    MOVE.l  d2,12(a4)                       ; store boolean as data for GA_Immediate tag
    MOVEQ.l #LORIENT_HORIZ,d2               ; Default freedom is horizontal
    BTST    #10,d1                          ; test bit 10 of the flags parameter
    BEQ     'not_vert                       ; If not set, we want to keep the freedom as horizontal
    MOVEQ.l #LORIENT_VERT,d2                ; Else set freedom to vertical
    'not_vert:
    MOVE.l  d2,20(a4)                       ; Store freedom as the data for the PGA_Freedom tag
    MOVEQ.l #0,d2                           ; Set default arrow size to 0
    BTST    #11,d1                          ; Test bit 11 in the flags parameter
    BEQ     'no_arrows                      ; If not set, we want to keep the arrows size at 0
    MOVE.w  arrowsize(pc),d2                ; else get arrow size from storage
    'no_arrows:
    MOVE.l  d2,44(a4)                       ; store size of arrows in the data for GTSC_Arrows tag
    BTST    #14,d1                          ; Test bit 13 in the flags parameter
    SEQ     d2 : EXT d2 : EXT.l d2          ; create boolean based on the inverted state of the bit (bit=1, boolean=0)
    MOVE.l  d2,60(a4)                       ; Store as the data for the GA_Relverify tag
    AND     #$3f,d1                         ; Remove all Blitz2 flags
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags

    MOVEQ.l #TAG_MORE,d0                    ;
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    MOVE.l  8(a3),-(a7)                     ; Store pointer to current gadget on stack

    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVEQ.l #SCROLLER_KIND,d0               ; Gadget type
    BSR     _createstd                      ; Create gadget

    ; test/branch then post process
    MOVE.l  (a7)+,a0                        ; Restore gadget pointer (before new current) from stack
    TST.l   d0
    BEQ     'nogad

    ; Post processing here
    TST.w   propmode                        ; check value of propmode flag
    BEQ     'nogad                          ; if 0 skip setting the prop flags

    MOVE.l  (a0),a0                         ; and move onto the first part of the scroller gadget
    MOVE.w  38(a0),d1                       ; put gadget ID into d1

    'lastloop:                              ; goes through the list of gadgets with the same ID
    MOVE.w  !g{GadgetType}(a0),d2           ; get gadget type into d0
    AND.w   #GTYP_GTYPEMASK,d2              ; clear out all bits except the gadget types
    CMP.w   #GTYP_PROPGADGET,d2             ; check if this is a prop gadget
    BNE     'notprop

    MOVEA.l !g{SpecialInfo}(a0),a1          ; Gadget SpecialInfo -> a1 (PropInfo)
    OR.w    #PROPNEWLOOK,(a1)               ; set bit for PROPNEWLOOK

    'notprop:
    MOVE.l  (a0),d2                         ; move onto next gadget
    BEQ     'nogad                          ; if NULL, end of list, exit routine
    MOVEA.l d2,a0                           ; else pointer to gadget -> a0
    CMP.w   !g{GadgetID}(a0),d1             ; compare gadget IDs
    BEQ     'lastloop                       ; If same, still some gadgets To process, Repeat loop

    'nogad:
    CLR.l   usertags                        ; Clear first tag in usertags
    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
    Dc.l GA_Disabled,0                      ; 0,4
    Dc.l GA_Immediate,0                     ; 8,12
    Dc.l PGA_Freedom,0                      ; 16,20
    Dc.l GTSC_Visible,0                     ; 24,28
    Dc.l GTSC_Total,0                       ; 32,36
    Dc.l GTSC_Arrows,16                     ; 40,44
    Dc.l GTSC_Top,0                         ; 48,52
    Dc.l GA_RelVerify,-1                    ; 56,60
    Dc.l GT_Underscore,95                   ; 64,68
'ut:Dc.l 0,usertags                         ;


; dx = gtlist.w,id.w,x.w,y.w,flags.l,shape.w[,shape.w]
; ax = intuifontlib, currentscreen, shape2ptr, gtlistptr, xxx, xxx, shape1ptr
._gtshape:
    MOVEQ.l #0,d0
    MOVE.l  d0,a2                           ; Make sure pointer to second gadget is clear when using only 1 shape
_gtshape2:
    MOVEM.l a3-a5,-(a7)
    MOVE.l  (a1),a1

    TST.w   gzzpos                          ; Check if we should add border sizes to x,y position of gadget
    BNE     'gzzskip                        ; if non-zero, don't add the window border sizes to the gadget position
    MOVEQ.l #0,d0                           ; clear upper bytes of d0
    MOVE.b  !s{WBorLeft}(a1),d0             ; Get window top border size
    ADD.w   d0,d2                           ; add left border to gadget left position
    MOVE.b  !s{WBorTop}(a1),d0              ; Window top border height into d0
    ADD.w   d0,d3                           ; Add top border to gadget top position
    ;ADD.w   !s{RastPort\TxHeight}(a1),d3    ; Add font height to gadget top position
    ADD.w   142(a1),d3                      ; Same as above, but works
    ADDQ.w  #1,d3                           ; The final piece of the puzzle :)

    'gzzskip:
    MOVE.l  a1,d0                           ; Preserve screen pointer
    LEA.l   wrkgadget(pc),a1                ; Pointer to working NewGadget structure into a1
    MOVE.w  d1,!n{ng_GadgetID}(a1)          ; Store gadget ID
    MOVE.w  d2,!n{ng_LeftEdge}(a1)          ; store left and top in NewGadget
    MOVE.w  d3,!n{ng_TopEdge}(a1)
    MOVE.l  (a6),!n{ng_Width}(a1)           ; Store pixel width and height from 1st shape into NewGadget structure

    CNIF #DEBUG=1
    MOVE.w  !n{ng_Height}(a1),-(a7)
    MOVE.w  !n{ng_Width}(a1),-(a7)
    MOVE.w  !n{ng_TopEdge}(a1),-(a7)
    MOVE.w  !n{ng_LeftEdge}(a1),-(a7)
    !PUTSTR{001,"gtshape: NewGadget  Left=%d  Top=%d  Width=%d  Height=%d"}
    LEA.l   8(a7),a7
    CEND

    ;MOVE.l  a0,!n{ng_TextAttr}(a1)          ; pointer to currently used intuifont object in newgadget
    MOVE.l  d0,d2                           ; More shuffling of the screen pointer

    MOVE.l  a6,-(a7)                        ; Preserve pointer to first shape
    MOVE.l  gtbase(pc),a6
    BSR     _getcontext                     ; Make sure we have gadget context
    MOVE.l  (a7)+,a6                        ; Restore pointer to first shape

    LEA.l   wrkgadget(pc),a1                ; Pointer to working NewGadget structure into a1
    MOVEQ.l #0,d0                           ; Clear upper word of d0
    MOVE.w  !n{ng_GadgetID}(a1),d0          ; Get gadget ID
    MOVE.l  a3,d1                           ; Pointer to GTList
    BSR     addgadptr                       ; Create internal storage
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{002,"gtshape: Allocated internal memory at $%lx"}
    LEA.l   4(a7),a7
    CEND

    TST.l   d0                              ; Check pointer to allocated memory for internal list
    BEQ     'nogad                          ; if NULL, exit routine

    MOVE.l  d0,a0                           ; Pointer to internal memory into a0
    ; Allocate memory for the special info (.Image structures)
    MOVEQ.l #SizeOf.Image,d0                ; Size of 1 image structure
    MOVEQ.l #0,d1                           ; For comparing against second shape pointer
    CMP.l   d1,a2                           ; Compare 0 to second shape pointer
    BEQ     'oneshp                         ; if equal (second shape pointer = NULL) skip the next bit
    LSL.l   #1,d0                           ; Multiply size of allocated special memory by 2
    'oneshp:
    ADDQ.l  #4,d0                           ; Increase size of memory to allocate by 4 (for size of allocated memory)
    MOVE.l  d0,d5                           ; Copy size of memory allocation into d2
    MOVE.l  #MEMF_CLEAR|MEMF_PUBLIC,d1      ; Type of memory to allocate
    ALibJsr #globalalloc

    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{003,"gtshape: Allocated special memory at $%lx"}
    LEA.l   4(a7),a7
    CEND

    TST.l   d0                              ; Check pointer to special allocated memory
    BEQ     'specfail                       ; If NULL, branch to exit of routine

    MOVE.l  d0,a1                           ; otherwise, move pointer to special memory into a0
    MOVE.l  d5,(a1)+                        ; Copy size of memory allocation into memory and move onto usable memory
    MOVE.l  a1,{SizeOf.gtinlist\Special}(a0); Copy special memory pointer into internal memory

    ; a0 = internal memory
    ; a1 = special
    ; a2 = second shape pointer
    ; a3 = GTContext
    ; a6 = first shape pointer
    ; d4 = flags parameter

    ; Do first shape
    MOVE.w  #GFLG_GADGIMAGE,gflags          ; Set default flags for after we have created the gadget
    MOVE.l  (a6),{SizeOf.Image\Width}(a1)   ; Copy shape width and height to the image structure
    MOVE.w  {SizeOf.shape\_depth}(a6),{SizeOf.Image\Depth}(a1)
    MOVE.l  {SizeOf.shape\_data}(a6),{SizeOf.Image\ImageData}(a1)
    MOVEQ.l #0,d1
    MOVE.w  {SizeOf.shape\_depth}(a6),d1
    MOVEQ.l #1,d0
    LSL.l   d1,d0
    SUBQ.w  #1,d0
    MOVE.b  d0,{SizeOf.Image\PlanePick}(a1)

    ; Do second shape if it is used
    MOVEQ.l #0,d0                           ; Clear d0
    CMP.l   d0,a2                           ; Compare second shape pointer to NULL
    BEQ     'nosecond                       ; if second shape pointer is NULL, skip this next bit
    OR.w    #GFLG_GADGHIMAGE,gflags         ; Add in extra flag for highlight image
    MOVEQ.l #SizeOf.Image,d0
    ADD.l   d0,a1                           ; Move onto second Image structure in special memory
    MOVE.l  (a2),{SizeOf.Image\Width}(a1)   ; Copy shape width and height to the image structure
    MOVE.w  {SizeOf.shape\_depth}(a2),{SizeOf.Image\Depth}(a1)
    MOVE.l  {SizeOf.shape\_data}(a2),{SizeOf.Image\ImageData}(a1)
    MOVEQ.l #0,d1
    MOVE.w  {SizeOf.shape\_depth}(a2),d1

    MOVEQ.l #1,d0
    LSL.l   d1,d0
    SUBQ.w  #1,d0
    MOVE.b  d0,{SizeOf.Image\PlanePick}(a1)

    'nosecond:
    MOVE.l  d4,d1                           ; Copy flags parameter into d1
    LEA.l   wrkgadget(pc),a1
    CNIF #OLDFLAGS=1
;    LEA.l   'defaulttags,a4
;    BTST    #6,d1                           ; Test bit 6 of the flags parameter
;    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean long from state of bit
;    MOVE.l  d2,4(a4)                        ; Store boolean as the data for the GA_Immediate tag
;    BTST    #7,d1                           ; Test bit 7 of the flags parameter
;    SNE     d2 : EXT d2 : EXT.l d2          ; Create long boolean based on state of bit
;    MOVE.l  d2,12(a4)                       ; store boolean as data for GA_Immediate tag
;    BTST    #14,d1
;    SEQ     d2 : EXT d2 : EXT.l d2
;    MOVE.l  d2,20(a4)
    AND.l   #$3F,d1
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags

    MOVEQ.l #TAG_MORE,d0                    ;
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    MOVEQ.l #0,d0
    MOVE.l  d0,!n{ng_GadgetText}(a1)
    MOVE.l  d0,!n{ng_TextAttr}(a1)

    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVEQ.l #GENERIC_KIND,d0                ; Gadget type
    MOVE.l  gtbase(pc),a6
    BSR     _createstd                      ; Create gadget

    ; test/branch then post process
    TST.l   d0
    BEQ     'specfail

    MOVE.l  {SizeOf.gtinlist\Special}(a0),a1
    MOVE.l  d0,a0

    MOVE.l  a1,!g{GadgetRender}(a0)
    MOVE.w  gflags,d0
    AND.w   #GFLG_GADGHIGHBITS,d0
    CMP.w   #GFLG_GADGHIMAGE,d0
    BNE     'nohimage
    MOVEQ.l #SizeOf.Image,d0
    ADD.l   d0,a1
    MOVE.l  a1,!g{SelectRender}(a0)
    'nohimage:

    MOVE.w  gflags,d0
    OR.w    d0,!g{Flags}(a0)                ; Store flags in flags for gadget

    BTST    #15,12(a0)                      ; check if #GFLG_EXTENDED flag is set
    BEQ     'noextgad                       ; if not, the gadget is not extended so don't set the GMORE flag
    OR.w    #GMORE_GADGETHELP,44(a0)        ; set gadgethelp flag if the gadget is extended->gives gadgethelp IDCMPs
    'noextgad:

    BSET    #0,15(a0)                       ; Set relverify activation for the gadget

    CNIF #OLDFLAGS=1
    BTST    #6,d4
    BEQ     'enabled
    BSET    #0,12(a0)
    'enabled:

    BTST    #7,d4                           ; Immediate
    BEQ     'noimmediate
    BSET    #1,15(a0)
    'noimmediate:

    BTST    #13,d4
    BEQ     'notoggle                       ; if not set, branch past setting the toggle activation
    BSET    #0,14(a0)                       ; set bit 9 in the Gadget\Activation field
    'notoggle:

    BTST    #14,d4
    BEQ     'relverify
    BCLR    #0,15(a0)
    'relverify:
    CEND
    OR.w    #GTYP_BOOLGADGET,16(a0) ; set gadget to be boolean type

    MOVE.l  a0,d0
    BRA     'nogad:                         ; branch past the freeing of internal memory

    'specfail:
    MOVEQ.l #0,d1
    MOVE.w  {SizeOf.gtinlist\id}(a0),d1     ; Get gadget ID to free
    MOVE.l  a3,d0                           ; Pointer to GTList object in which the gadget is

    CNIF #DEBUG=1
    MOVE.l  d1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{004,"gtshape: Removing gadget with GTList,ID: $%lx,%ld"}
    LEA.l   2*4(a7),a7
    CEND
    BSR     remgadptr                       ; Free this gadget (due to option failure)
    MOVEQ.l #0,d0                           ; return value of 0 to indicate failure

    'nogad:
    CLR.l   wrkgadget+!n{ng_UserData}
    CLR.l   usertags
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
;    Dc.l GA_Disabled,0                      ; 0,4
;    Dc.l GA_Immediate,0                     ; 8,12
;    Dc.l GA_RelVerify,-1                    ; 16,20
;    Dc.l GT_Underscore,95                   ;
'ut:Dc.l 0,usertags


_gtslider2:
    MOVEQ.l #0,d0                           ; Clear upper word of d0
    MOVE.w  -18(a2),d0                      ; Get value of Level parameter from stack
    BRA     gtsl_start                      ; Branch to real start of routine
._gtslider:
    MOVEQ.l #0,d0                           ; Clear level parameter
gtsl_start:
    MOVE.l  d0,'defaulttags+44              ; Store level value as the data for the GTSL_Level tag
    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers

    BSR     _handlestd                      ; Do standard processing for all gadgets
    MOVE.l  d2,'defaulttags+60              ; Store ASCII code as data for GT_Underscore tag
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gtslider: Return from handlestd $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; Check if we could allocate internal memory
    BEQ     'nogad                          ; if NULL, we have none, exit

    ; Do flags and extra parameter processing
    MOVE.w  -(a2),d2                        ; Get Min parameter from stack
    EXT.l   d2                              ; is this needed?
    MOVE.l  d2,'defaulttags+28              ; Store in taglist as data for GTSL_Min tag
    MOVE.w  -(a2),d2                        ; Get Max parameter from stack
    EXT.l   d2                              ; Is this needed?
    MOVE.l  d2,'defaulttags+36              ; Store in taglist as data for GTSL_Max tag

    CNIF #OLDFLAGS=1
    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
    BTST    #6,d1                           ; Test bit 6 of the flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create boolean long from state of bit
    MOVE.l  d2,4(a4)                        ; Store boolean as the data for the GA_Immediate tag
    BTST    #7,d1                           ; Test bit 7 of the flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create long boolean based on state of bit
    MOVE.l  d2,12(a4)                       ; store boolean as data for GA_Immediate tag
    MOVEQ.l #LORIENT_HORIZ,d2               ; Default freedom is horizontal
    BTST    #10,d1                          ; test bit 10 of the flags parameter
    BEQ     'not_vert                       ; If not set, we want to keep the freedom as horizontal
    MOVEQ.l #LORIENT_VERT,d2                ; Else set freedom to vertical
    'not_vert:
    MOVE.l  d2,20(a4)                       ; Store freedom as the data for the PGA_Freedom tag
    BTST    #14,d1                          ; Test bit 13 in the flags parameter
    SEQ     d2 : EXT d2 : EXT.l d2          ; create boolean based on the inverted state of the bit (bit=1, boolean=0)
    MOVE.l  d2,52(a4)                       ; Store as the data for the GA_Relverify tag
    AND.l   #$3F,d1                         ; Remove all Blitz2 specific flags
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags

    MOVEQ.l #TAG_MORE,d0                    ;
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    MOVE.l  8(a3),-(a7)                     ; Store pointer to current gadget on stack

    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVEQ.l #SLIDER_KIND,d0                 ; Gadget type
    BSR     _createstd                      ; Create gadget

    ; test/branch then post process
    MOVE.l  (a7)+,a0                        ; Restore gadget pointer (before new current) from stack
    TST.l   d0
    BEQ     'nogad

    ; Post processing here
    TST.w   propmode                        ; check value of propmode flag
    BEQ     'nogad                          ; if 0 skip setting the prop flags

    MOVE.l  (a0),a0                         ; and move onto the first part of the slider gadget
    MOVE.w  38(a0),d1                       ; put gadget ID into d1

    'lastloop:                              ; goes through the list of gadgets with the same ID
    MOVE.w  !g{GadgetType}(a0),d2           ; get gadget type into d0
    AND.w   #GTYP_GTYPEMASK,d2              ; clear out all bits except the gadget types
    CMP.w   #GTYP_PROPGADGET,d2             ; check if this is a prop gadget
    BNE     'notprop

    MOVEA.l !g{SpecialInfo}(a0),a1          ; Gadget SpecialInfo -> a1 (PropInfo)
    OR.w    #PROPNEWLOOK,(a1)               ; set bit for PROPNEWLOOK

    'notprop:
    MOVE.l  (a0),d2                         ; move onto next gadget
    BEQ     'nogad                          ; if NULL, end of list, exit routine
    MOVEA.l d2,a0                           ; else pointer to gadget -> a0
    CMP.w   !g{GadgetID}(a0),d1             ; compare gadget IDs
    BEQ     'lastloop                       ; If same, still some gadgets To process, Repeat loop

    'nogad:
    CLR.l   usertags                        ; Clear first tag in usertags
    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
    Dc.l GA_Disabled,0                      ; 0,4
    Dc.l GA_Immediate,1                     ; 8,12
    Dc.l PGA_Freedom,0                      ; 16,20
    Dc.l GTSL_Min,0                         ; 24,28
    Dc.l GTSL_Max,0                         ; 32,36
    Dc.l GTSL_Level,0                       ; 40,44
    Dc.l GA_RelVerify,-1                    ; 48,52
    Dc.l GT_Underscore,95                   ; 56,60
'ut:Dc.l 0,usertags                         ;


_gtstring2:
    MOVE.l  -22(a2),d0                      ; Get pointer to string from stack
    BRA     gtst_start                      ; And branch to start of routine proper
._gtstring:
    MOVEQ.l #0,d0                           ; Defaults to no string
gtst_start:
    MOVE.l  d0,'defaulttags+28              ; Store string pointer as data for GTST_String tag
    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers

    BSR     _handlestd                      ; Do standard processing for all gadgets
    MOVE.l  d2,'defaulttags+36              ; Store ASCII code as data for GT_Underscore tag
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gtstring: Return from handlestd $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; Check if we could allocate internal memory
    BEQ     'nogad                          ; if NULL, we have none, exit

    ; Do flags and extra parameter processing
    MOVEQ.l #0,d2                           ; Clear upper word of d2
    MOVE.w  -(a2),d2                        ; Get MaxChars parameter off stack
    MOVE.l  d2,'defaulttags+20              ; Store maxchars as data for GTST_MaxChars tag
    CNIF #OLDFLAGS=1
    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
    BTST    #6,d1                           ; Test bit 6 of flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create long boolean based on state of bit
    MOVE.l  d2,4(a4)                        ; store boolean as data for GA_Disabled flag
    BTST    #7,d1                           ; Test bit 7 of flags parameter
    SNE     d2 : EXT d2 : EXT.l d2          ; Create long boolean based on state of bit
    MOVE.l  d2,12(a4)                       ; Store boolean as data for GA_Immediate flag
    AND.l   #$3F,d1                         ; Clear all Blitz2 specific flags
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags

    MOVEQ.l #TAG_MORE,d0                    ;
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVEQ.l #STRING_KIND,d0                 ; Gadget type
    BSR     _createstd                      ; Create gadget

    'nogad:
    CLR.l   usertags                        ; Clear first tag in usertags
    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
    Dc.l GA_Disabled,0                      ; 0,4
    Dc.l GA_Immediate,0                     ; 8,12
    Dc.l GTST_MaxChars,0                    ; 16,20
    Dc.l GTST_String,0                      ; 24,28
    Dc.l GT_Underscore,95                   ;
'ut:Dc.l 0,usertags


._gttext:
    MOVEM.l a3-a5,-(a7)                     ; Preserve important registers

    BSR     _handlestd                      ; Do standard processing for all gadgets
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gttext: Return from handlestd $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; Check if we could allocate internal memory
    BEQ     'nogad                          ; if NULL, we have none, exit

    ; Do flags and extra parameter processing
    CNIF #OLDFLAGS=1
    LEA.l   'defaulttags(pc),a4             ; Pointer to start of default tags used in creation of gadget
    BTST    #15,d1                          ; Test bit 14 of the flags parameter
    SEQ     d2 : EXT d2 : EXT.l d2          ; Create long boolean based on inverted state of bit
    MOVE.l  d2,'defaulttags+12              ; Store as data for GTTX_Border tag
    AND.l   #$3F,d1                         ; Mask out all Blitz2 specific flags
    CEND
    MOVE.l  d1,!n{ng_Flags}(a1)             ; Store flags in flags field of working NewGadget structure
    MOVE.l  usertags(pc),d0                 ; get first tag value from the user specified tags
    BEQ     'noutags                        ; If 0, then we do not want to set the tag to TAG_MORE

    MOVEQ.l #TAG_MORE,d0                    ; Else set the tag to TAG_MORE
    'noutags:
    MOVE.l  d0,'ut                          ; Set the Tag value to either move onto next taglist or not

    ; Allocate specialinfo memory to hold string
    MOVEQ.l #5,d1                           ; Extra space required in allocation (4 for size.l + 1 for NULL terminator)
    MOVE.l  -(a2),d0                        ; Get length of string from stack
    ADD.l   d1,d0                           ; Add extra size onto total size of allocation
    MOVE.l  #MEMF_ANY|MEMF_CLEAR,d1         ; Memory type into d1
    MOVE.l  d0,d2                           ; Take a copy of the allocated size
    ALibJsr #globalalloc                    ; Allocate specialinfo memory
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{002,"gttext: Allocated string memory at $%lx"}
    LEA.l   4(a7),a7
    CEND

    TST.l   d0                              ; Check allocated memory for string
    BEQ     'failedstr                      ; if NULL, skip to exit routine

    MOVEM.l a0/a1/a6,-(a7)                  ; Preserve pointers used in CopyMem call
    MOVE.l  d0,a1                           ; Pointer to newly allocated memory into address reg
    MOVE.l  d2,(a1)+                        ; Store length of memory allocation into memory and increase position to strng start
    MOVE.l  a1,'defaulttags+4               ; Store pointer to text as data for GTTX_Text tag
    MOVE.l  a1,{SizeOf.gtinlist\Special}(a0); Store pointer to string memory in internal list item
    MOVEQ.l #-5,d0                          ; The extra amount of memory allocated onto the string length
    ADD.l   d2,d0                           ; Get back to original length of string
    MOVE.l  -(a2),a0                        ; Pointer to string passed as Display$
    MOVE.l  4,a6                            ; Pointer to exec.library
    JSR     _LVOCopyMem(a6)                 ; Copy memory from source string to new memory
    MOVEM.l (a7)+,a0/a1/a6                  ; Restore registers

    LEA.l   'defaulttags(pc),a2             ; Pointer to start of default tags used in creation of gadget
    MOVEQ.l #TEXT_KIND,d0                   ; Gadget type
    BSR     _createstd                      ; Create gadget
    BRA     'nogad

    'failedstr:
    MOVEQ.l #0,d1
    MOVE.w  {SizeOf.gtinlist\id}(a0),d1     ; Get gadget ID to free
    MOVE.l  a3,d0                           ; Pointer to GTList object in which the gadget is

    CNIF #DEBUG=1
    MOVE.l  d1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{003,"gttext: Removing gadget with GTList,ID: $%lx,%ld"}
    LEA.l   2*4(a7),a7
    CEND
    BSR     remgadptr                       ; Free this gadget (due to option failure)
    MOVEQ.l #0,d0                           ; return value of 0 to indicate failure

    'nogad:
    CLR.l   usertags                        ; Clear first tag in usertags
    CLR.l   wrkgadget+26                    ; Clear UserData field of NewGadget
    MOVEM.l (a7)+,a3-a5
    RTS
'defaulttags:
    Dc.l GTTX_Text,0                        ; 0,4
    Dc.l GTTX_Border,-1                     ; 8,12
'ut:Dc.l 0,usertags
    RTS

.
.SupportCommands
.dodisable:
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; Try to find internally allocated memory for this gadget
    TST.l   d0                              ; Check pointer returned
    BEQ     'nogad                          ; exit if NULL

    MOVE.l  d0,a0                           ; Pointer to internal memory into a0
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget into a0
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a1
    SUB.l   a2,a2
    CLR.l   -(a7)                           ; TAG_DONE
    PEA.l   -1                              ; TRUE
    PEA.l   GA_Disabled
    MOVE.l  a7,a3
    MOVE.l  gtbase(pc),a6
    JSR     _SetGadgetAttrs(a6)
    LEA.l   3*4(a7),a7
    'nogad:
    RTS


.doenable:
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; Try to find internally allocated memory for this gadget
    TST.l   d0                              ; Check pointer returned
    BEQ     'nogad                          ; exit if NULL

    MOVE.l  d0,a0                           ; Pointer to internal memory into a0
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget into a0
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a1
    SUB.l   a2,a2
    CLR.l   -(a7)                           ; TAG_DONE
    CLR.l   -(a7)                           ; FALSE
    PEA.l   GA_Disabled
    MOVE.l  a7,a3
    MOVE.l  gtbase(pc),a6
    JSR     _SetGadgetAttrs(a6)
    LEA.l   3*4(a7),a7
    'nogad:
    RTS


.doselect:
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; Try to find internally allocated memory for this gadget
    TST.l   d0                              ; Check pointer returned
    BEQ     dsnogad                         ; exit if NULL

    MOVE.l  d0,a0                           ; Pointer to internal memory into a0
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget into a0
    TST.l   d2                              ; Check the on/off parameter
    BEQ     'stateoff
    BSET    #7,13(a0)                       ; Set the #GFLG_SELECTED bit in the Gadget\Flags field
    BRA     doselrefresh

    'stateoff:
    BCLR    #7,13(a0)                       ; Set the #GFLG_SELECTED bit in the Gadget\Flags field
    BRA     doselrefresh

doselect2:
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; Try to find internally allocated memory for this gadget
    TST.l   d0                              ; Check pointer returned
    BEQ     dsnogad                         ; exit if NULL

    MOVE.l  d0,a0                           ; Pointer to internal memory into a0
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget into a0
    BCHG    #7,13(a0)                       ; Toggle the #GFLG_SELECTED bit in the Gadget\Flags field

doselrefresh:
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a1
    SUB.l   a2,a2
    MOVEQ.l #1,d0
    JSR     _LVORefreshGList(a6)

dsnogad:
    RTS


._gtactivategadget:
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; Try to find internally allocated memory for this gadget
    TST.l   d0                              ; Check pointer returned
    BEQ     'nogad                          ; exit if NULL

    MOVE.l  d0,a0                           ; Pointer to internal memory into a0
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget into a0
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a1
    SUB.l   a2,a2
    JSR     _LVOActivateGadget(a6)

    'nogad:
    RTS


._gtarrowsize:
   MOVE.l    d0,arrowsize                   ; Store specified size of arrow gadgets
   RTS


_gtbevel2:
    MOVEQ.l #BBFT_BUTTON,d6                 ; default frame type is button style (raised)
._gtbevel:
    LEA     'defaulttags(pc),a1
    MOVE.l  4(a0),d0                        ; get VisualInfo from GTContext
    BEQ     'nodraw                         ; if NULL, exit routine (cannot draw)
    MOVE.l  d0,4(a1)                        ; store visualinfo into taglist

    MOVE.l  12(a0),d0                       ; get pointer to currently attached window
    BEQ     'nodraw                         ; if NULL, not attached to a window so nothing to draw onto
    MOVE.l  d0,a0                           ; else pointer to window into a0

    TST.w   gzzpos                          ; Check if we should add border sizes to x,y position of gadget
    BNE     'gzzskip                        ; if non-zero, don't add the window border sizes to the gadget position
    MOVEQ.l #0,d0                          ; clear upper bytes of d0
    MOVE.b  {SizeOf._Window\BorderLeft}(a0),d0 ; Get window top border size
    ADD.w   d0,d1                           ; add left border to bevelbox left position
    MOVE.b  {SizeOf._Window\BorderTop}(a0),d0  ; Window top border height into d0
    ADD.w   d0,d2                           ; Add top border to bevelbox top position

    'gzzskip:
    MOVE.l  50(a0),a0                       ; get window rastport
    MOVE.l  d1,d0                           ; sort out x,
    MOVE.l  d2,d1                           ; y,
    MOVE.l  d3,d2                           ; w,
    MOVE.l  d4,d3                           ; h parameters into correct registers

    TST.l   d5                              ; check flags
    BEQ     'norecess                       ; if 0, we don't want a recessed box
    MOVE.l  #GTBB_Recessed,d5               ; otherwise, set the recessed flags
    'norecess::                             ;
    MOVE.l  d5,16(a1)                       ; store the recessed/raised tag
    MOVE.l  d6,12(a1)                       ; store the frame type in the ti_Data
    MOVE.l  gtbase(pc),a6                   ; gadtools.library base
    JSR     _DrawBevelBox(a6)               ; call DrawBevelBoxA

    'nodraw:
    RTS

'defaulttags:
    Dc.l GT_VisualInfo,0
    Dc.l GTBB_FrameType,BBFT_BUTTON
    Dc.l GTBB_Recessed,0
    Dc.l 0


._gtchangecycle:
    MOVEM.l d3-d7/a3-a4,-(a7)
    MOVEQ.l #0,d7
    MOVE.l  a0,d0                           ; Poinbter to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; Try to find specified gadget in internal memory
    TST.l   d0                              ; Check if we could find internal memory
    BEQ     'exit                           ; if NULL, exit routine

    MOVE.l  {SizeOf.gtcontext\gtwindow}(a0),a1  ; Pointer to attached window
    MOVE.l  d0,a0
    MOVE.l  {SizeOf.gtinlist\Special}(a0),d0
    BEQ     'exit

    MOVEQ.l #-1,d6                          ; Set initial position of gadget removed from to -1
    ;MOVE.l  (a1),a1                         ; Pointer to intuition window structure into a1
    MOVEM.l d0/a0-a1,-(a7)
    MOVEQ.l #0,d0
    CMP.l   d0,a1
    BEQ     'nowindow1
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0
    EXG.l   a0,a1
    JSR     _LVORemoveGadget(a6)
    MOVE.l  d0,d6
    'nowindow1:
    MOVEM.l (a7)+,d0/a0-a1

    MOVE.l  d0,a3                           ; Pointer to special memory into a3

    MOVE.l  d2,a4                           ; Pointer to new string into a4
    MOVEQ.l #3,d1
    'countloop:
    MOVE.b  (a4)+,d0                        ; get next char from string into d0
    BEQ     'endcount                       ; if NULL, end of string, exit loop
    CMP.b   #"|",d0                         ; compare character from string to option separator
    BNE     'countloop                      ; if not same, repeat loop
    ADDQ.l  #1,d1                           ; increase number of longs to allocate
    BRA     'countloop                      ; repeat loop
    'endcount:
    MOVE.l  d2,a4                           ; Pointer to string again for later

    LSL.l   #2,d1                           ; Multiply longwords by 4
    MOVE.l  d1,d4                           ; Copy of longword size into d4
    ADDQ.l  #1,d1                           ; Add 1 for the trailing NULL
    MOVE.l  -(a2),d0                        ; Get length of string to allocate
    ADD.l   d0,d1                           ; Finally - total length of required memory for new string

    MOVE.l  -4(a3),d0                       ; Get length of previously allocated memory

    CNIF #DEBUG=1
    MOVE.l  d1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{001,"gtchangecycle: Previous size=%ld  New size=%ld"}
    LEA.l   2*4(a7),a7
    CEND

    CMP.l   d0,d1                           ; Compare string length with length of previous string
    BLE     'noalloc                        ; if length of new string will fit into previous memory, skip new allocation

    ; Sort out sizes and things
    MOVE.l  d1,d2                           ; Preserve length of new memory
    MOVE.l  d1,d0                           ; Size of memory to allocate into d0
    MOVEQ.l #MEMF_PUBLIC,d1                 ; Memory flag
    BSET    #16,d1                          ; Set other memory flag (2 bytes shorter than move.l ;)
    ALibJsr #globalalloc

    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{002,"New memory allocated at %lx"}
    LEA.l   4(a7),a7
    CEND

    TST.l   d0                              ; Check pointer to new memory
    BEQ     'nogad                          ; If NULL, everything is screwed, can't do new strings, so just exit and use old

    ; Swap new and old pointers
    MOVE.l  d0,a2
    MOVE.l  d2,(a2)+
    MOVE.l  a2,{SizeOf.gtinlist\Special}(a0)

    ; Free old memory
    MOVE.l  -(a3),d0                        ; Get length of old memory into d0
    EXG.l   a3,a1                           ; exchange window pointer and old memory pointer
    ALibJsr #globalfree                     ; Free it

    MOVE.l  a3,a1                           ; Pointer to window object into a1
    MOVE.l  a2,a3                           ; Pointer to base of new memory into a3

    'noalloc:
    ; By here we have
    ; a0 = pointer to internal gadget memory
    ; a1 = pointer to window
    ; a3 = pointer to start of memory to use for longword array
    ; a4 = pointer to new string
    ; d4 = length of longwords + 4
    CNIF #DEBUG=1
    MOVE.l  a0,-(a7)
    MOVE.l  a1,-(a7)
    MOVE.l  a3,-(a7)
    MOVE.l  a4,-(a7)
    MOVE.l  d4,-(a7)
    !PUTSTR{003,"gtchangecycle: LenLongs+4=%ld  Str=%lx  Memory=%lx  Window=%lx  GTInList=%lx"}
    LEA.l   5*4(a7),a7
    CEND

    SUBQ.l  #4,d4                           ; Remove size of long for size from d4
    ;MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget into a0
    LEA.l   0(a3,d4.l),a2                   ; Pointer to start of string memory into a2

    LSR.l   #2,d4                           ; number of pointers in the array
    SUBQ.l  #2,d4                           ; and subtract 2 to keep counter happy (1 for counter, 1 for NULL)

    MOVE.l  a3,-(a7)

    'arrayloop:
    MOVE.l  a2,(a3)+                        ; Copy pointer to start of string into array

    CNIF #DEBUG=1
    MOVE.l  a4,-(a7)
    !PUTSTR{004,"gtchangecycle: pointer to start of option string = $%lx"}
    LEA.l   4(a7),a7
    CEND

    'copyoptloop:
    MOVE.b  (a4)+,d3                        ; get character from string and move onto next
    CMP.b   #"|",d3                         ; check if we reached the end of this option
    BNE     'dochar                         ; if not | character, branch past next line
    MOVEQ.l #0,d3                           ; set character to store as NULL character
    'dochar:
    MOVE.b  d3,(a2)+                        ; store char in target memory
    BNE     'copyoptloop                    ; if not NULL char, repeat for next character in this target string

    DBRA    d4,'arrayloop                   ; decrease count of options in the string and repeat
    CLR.l   (a3)                            ; Terminate array with NULL pointer

    MOVE.l  (a7)+,a3

    ; Update gadget
    MOVEM.l d0-d1/a0-a3/a6,-(a7)
    MOVEQ.l #0,d0
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0
    LEA.l   'defaulttags(pc),a2
    MOVE.l  a3,4(a2)
    SUB.l   a3,a3
    EXG.l   a2,a3
    MOVE.l  gtbase(pc),a6
    JSR     _SetGadgetAttrs(a6)
    MOVEM.l (a7)+,d0-d1/a0-a3/a6

    MOVEQ.l #-1,d7

    'nogad:
    MOVEQ.l #-1,d4                          ; Set d4 to -1
    CMP.l   d4,d6                           ; Check position in list gadget removed from
    BEQ     'exit                           ; if -1, gadget not removed from list, we don't need to add it

    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0
    EXG.l   a0,a1
    MOVE.l  d6,d0

    MOVEM.l a0-a1,-(a7)
    JSR     _LVOAddGadget(a6)
    MOVEM.l (a7)+,a0-a1

    EXG.l   a0,a1
    SUB.l   a2,a2
    MOVEQ.l #1,d0
    JSR     _LVORefreshGList(a6)

    'exit:
    MOVE.l  d7,d0
    MOVEM.l (a7)+,d3-d7/a3-a4
    RTS
'defaulttags:
    Dc.l    GTCY_Labels,0
    Dc.l    0


._gtchnglist:
    MOVEM.l d2/a0/a3/a6,-(a7)
    MOVEQ.l #-1,d2                          ; When no list parameter is used, we want to detach the list with ~0
    BRA     gtcl_start                      ; And go to start of code where we have the list address to use
_gtchnglist2:
    MOVEM.l d2/a0/a3/a6,-(a7)
    MOVE.l  -(a2),a2                        ; Pointer to head of list structure into a2
    LEA.l   -28(a2),a2                      ; Get OS List structure from Blitz list
    MOVE.l  a2,d2
gtcl_start:
    MOVE.l  a1,d0                           ; Pointer to GTList object (d1 already has ID)
    BSR     findgadget                      ; Try to find gadget in internal lists
    TST.l   d0                              ; Check pointer to internal memory returned by search
    BEQ     'nogad                          ; if NULL, exit

    MOVE.l  d0,a0
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Get pointer to gadget to set attrs for
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a1  ; Pointer to window GTList is attached to
    LEA     'defaulttags(pc),a3             ; Address of taglist
    MOVEQ.l #0,d0                           ; Clear d0
    MOVE.l  d2,4(a3)                        ; Store address of list header in taglist
    MOVE.l  d0,a2                           ; Requester pointer = 0
    MOVE.l  gtbase(pc),a6                   ; Get gadtools.library
    JSR     _SetGadgetAttrs(a6)

    'nogad:
    MOVEM.l (a7)+,d2/a0/a3/a6
    RTS
'defaulttags:
    Dc.l    GTLV_Labels,0
    Dc.l    0


._gteventmicros:
    MOVE.l  evmicros(pc),d0
    RTS


._gteventseconds:
    MOVE.l  evseconds(pc),d0
    RTS


._gtfreegadget:
    MOVEM.l d1-d3/a0-a4/a6,-(a7)
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0
    BSR     findgadget                      ; Try to find gadget in internal memory
    TST.l   d0                              ; Check pointer to internal memory
    BEQ     'nogad                          ; if NULL, exit routine

    MOVE.l  d0,a3                           ; Copy of infernal memory pointer into a3
    MOVE.l  d1,d2
    MOVEQ.l #0,d3

    ; Scan through gadgets (starting from Context)
    MOVE.l  a1,a0                           ; Pointer to GTList object into a0

    'findgad:
    MOVE.l  a0,a2                           ; Pointer to current item into a2 (will be the previous)
    MOVE.l  (a0),d0                         ; Get pointer to next gadget into d0
    BEQ     'eol                            ; If NULL, we reached the end of the list
    MOVE.l  d0,a0                           ; Current gadget pointer into address reg
    CMP.w   !g{GadgetID}(a0),d1             ; check ifthis is the gadget we are looking for
    BNE     'findgad                        ; repeat loop if this isn't the gadget we want

    ; Found first gadget in list with the desired ID
    ; Pointer to gadget in a0, previous gadget in a2
    MOVEQ.l #0,d3                           ; Number of gadgets to remove
    'findend:
    ADDQ.l  #1,d3                           ; Increase number of gadgets
    MOVE.l  a0,a4                           ; Current gadget (soon to be previous) into a4
    MOVE.l  (a0),d0                         ; Pointer to next gadget into d0
    BEQ     'endfindend                     ; if NULL, branch to end of loop
    MOVE.l  d0,a0                           ; Pointer back into a0
    CMP.w   !g{Flags}(a0),d1                ; Check if this is still the gadget we're looking for
    BEQ     'findend                        ; if it is, keep going through the loop until the end
    BRA     'gotgad

    ; a2 = pointer to gadget before one to remove, a4 = pointer to last gadget to remove
    'endfindend:
    MOVE.l  a2,{SizeOf.gtcontext\current}(a1); Since we're removing the last gadget, we need to change the context

    'gotgad:
    MOVE.l  a1,-(a7)
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a0
    MOVE.l  d3,d0                           ; Number of gadgets to remove
    MOVE.l  (a2),a1                         ; Pointer to gadget to remove
    JSR     _LVORemoveGList(a6)             ; Remove gadget from window
    MOVE.l  (a7)+,a1

    MOVE.l  (a4),(a2)                       ; Pointer to gadget after the one we are removing into the NextGadget field of the
                                            ; gadget before the first one we are removing

    MOVE.l  a2,a0
    'gadrenloop:
    MOVE.l  (a0),a0
    BTST    #2,13(a0)                       ; Test #GFLG_GADGIMAGE in Gadget\Flags
    BEQ     'nogr
    CLR.l   !g{GadgetRender}(a0)            ; Clear image pointer
    MOVEQ.l #GFLG_GADGHIGHBITS,d0           ; Mask for highlight bits
    AND.w   !g{Flags}(a0),d0                ; Get highlight setting for gadget
    CMP.w   #GFLG_GADGHIMAGE,d0
    BNE     'nogr
    CLR.l   !g{SelectRender}(a0)
    'nogr:
    CMP.l   a0,a4
    BNE     'gadrenloop

    MOVE.l  gtbase(pc),a6
    MOVE.l  (a2),a0
    JSR     _FreeGadgets(a6)

    'eol:
    MOVE.l  a3,d0
    MOVE.l  d2,d1
    BSR     remgadptr

    MOVE.l  d3,d0

    'nogad:
    MOVEM.l (a7)+,d1-d3/a0-a4/a6
    RTS


._gtgetattrs:
    MOVEM.l d1/a0-a3/a6,-(a7)
    MOVE.l  a1,d0                           ; Pointer to GTList object (ID already in d1)
    BSR     findgadget                      ; Find gadget in internal memory lists
    TST.l   d0
    BEQ     'oldgadtools

    MOVE.l  d0,a0
    MOVEQ.l #0,d0                           ; Default return value is nowt
    MOVEQ.l #39,d1                          ; Library version we are checking for
    MOVE.l  gtbase(pc),a6                   ; gadtools.library
    CMP.w   {SizeOf.Library\lib_Version}(a6),d1 ; Compare library version number
    BGE     'oldgadtools

    CLR.l   -(a7)                           ; Space to store result
    MOVE.l  a7,a2                           ; Pointer to result space
    CLR.l   -(a7)                           ; TAG_DONE
    MOVE.l  a2,-(a7)                        ; result pointer
    MOVE.l  d2,-(a7)                        ; Tag
    MOVE.l  a7,a3                           ; taglist
    SUB.l   a2,a2
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a1
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0
    JSR     _GetGadgetAttrs(a6)
    LEA.l   3*4(a7),a7
    MOVE.l  (a7)+,d0

    'oldgadtools:
    MOVEM.l (a7)+,d1/a0-a3/a6
    RTS


._gtgetint:
    MOVEM.l a0/a2/a3/a6,-(a7)
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; try to find pointer to internal memory for gadget
    TST.l   d0                              ; Check the returned pointer
    BEQ     'nogad                          ; if NULL, exit routine

    MOVE.l  d0,a0
    MOVEQ.l #39,d0                          ; Library version we are checking for
    MOVE.l  gtbase(pc),a6                   ; gadtools.library
    CMP.w   {SizeOf.Library\lib_Version}(a6),d0 ; Compare library version number
    BGE     'oldstyle

    ; OS3+ uses GT_GetGadgetAttrsA for full future compatibility
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a1  ; Window
    SUB.l   a2,a2
    MOVE.l  #GTIN_Number,d0
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget
    MOVE.w  !g{GadgetType}(a0),d1           ; Gadget type
    ANDI.w  #GTYP_GTYPEMASK,d1              ; Mask out all bits except user specifiable type bits
    CMPI.w  #GTYP_STRGADGET,d1              ; Check if this is a string gadget (if it is, it is a GTInteger)
    BEQ     'nogtnumber
    MOVE.l  #GTNM_Number,d0
    'nogtnumber:
    CLR.l   -(a7)                           ; Storage for returned value
    CLR.l   -(a7)                           ; TAG_DONE
    PEA.l   4(a7)                           ; Store that address in taglist
    MOVE.l  d0,-(a7)                        ; Tag to use depending on gadget type
    MOVE.l  a7,a3                           ; taglist address into a3
    JSR     _GetGadgetAttrs(a6)
    LEA.l   3*4(a7),a7
    MOVE.l  (a7)+,d0                        ; Pointer to gadget string buffer into d0
    BRA     'nogad

    ; For pre-V39 machines - does not work for GTNumber gadgets because they do not use the SpecialInfo
    ; pointer and StringInfo to store the data. Feck.
    'oldstyle:
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget
    MOVE.l  !g{SpecialInfo}(a0),d0          ; Get address of StringInfo structure for string gadget
    BEQ     'nogad
    MOVE.l  d0,a0
    MOVE.l  {SizeOf.StringInfo\LongInt}(a0),d0

    'nogad:
    MOVEM.l (a7)+,a0/a2/a3/a6
    RTS


._gtgetinternal:
    MOVE.l  internalglist(pc),d0            ; Get address of first item in internal gadget list
    RTS


._gtgetstring:
    MOVEM.l a0/a2/a6,-(a7)
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; try to find pointer to internal memory for gadget
    TST.l   d0                              ; Check the returned pointer
    BEQ     'nogad                          ; if NULL, exit routine

    MOVE.l  d0,a0
    MOVEQ.l #39,d0                          ; Library version we are checking for
    MOVE.l  gtbase(pc),a6                   ; gadtools.library
    CMP.w   {SizeOf.Library\lib_Version}(a6),d0 ; Compare library version number
    BGE     'oldstyle

    ; OS3+ uses GT_GetGadgetAttrsA for full future compatibility
    MOVE.l  a3,-(a7)
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a1  ; Window
    SUB.l   a2,a2
    MOVE.l  #GTST_String,d0
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget
    MOVE.w  !g{GadgetType}(a0),d1           ; Gadget type
    ANDI.w  #GTYP_GTYPEMASK,d1              ; Mask out all bits except user specifiable type bits
    CMPI.w  #GTYP_STRGADGET,d1              ; Check if this is a string gadget (if it is, it is a GTInteger)
    BEQ     'nogttext
    MOVE.l  #GTTX_Text,d0
    'nogttext:
    CLR.l   -(a7)                           ; Clear some memory for storing the return result
    CLR.l   -(a7)                           ; TAG_DONE
    PEA.l   4(a7)                           ; Store that address in taglist
    MOVE.l  d0,-(a7)                        ; Store tag to use depending on gadget type
    MOVE.l  a7,a3                           ; Pointer to taglist into a3
    JSR     _GetGadgetAttrs(a6)
    LEA.l   3*4(a7),a7                      ; Remove taglist from stack
    MOVE.l  (a7)+,d0                        ; Pointer to gadget string buffer into d0
    MOVE.l  (a7)+,a3                        ; Restore a3
    BRA     'copystr

    ; For pre-V39 machines
    'oldstyle:
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget
    MOVE.l  !g{SpecialInfo}(a0),d0          ; Get address of StringInfo structure for string gadget
    BEQ     'nogad
    MOVE.l  d0,a0
    MOVE.l  {SizeOf.StringInfo\Buffer}(a0),d0

    ; a3 = pointer to Blitz2 string space
    ; d0 = pointer to gadget's string
    'copystr:
    TST.l   d0
    BEQ     'nogad

    MOVE.l  d0,a0
    MOVEQ.l #-1,d0
    'copyloop:
    ADDQ.l  #1,d0
    MOVE.b  (a0)+,(a3)+
    BNE     'copyloop
    LEA.l   -1(a3),a3

    'nogad:
    MOVEM.l (a7)+,a0/a2/a6
    RTS


._gtgetstatus:
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; Try to find internally allocated memory for this gadget
    TST.l   d0                              ; Check pointer returned
    BEQ     'nogad                          ; exit if NULL

    MOVE.l  d0,a0                           ; Pointer to internal memory into a0
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget into a0
    MOVEQ.l #GFLG_SELECTED-1,d0             ; The flag we want to examine (mask)
    ADDQ.l  #1,d0
    AND.w   !g{Flags}(a0),d0                ; and in the value of the flags
    LSR.w   #7,d0                           ; and produce a 0 or 1 result

    'nogad:                                 ; result=0 if gadget cannot be found
    RTS


._gtgzzposition:
    TST.w   d0                              ; Check what the user passed in
    SNE     d0                              ; If not zero, set lower 8 bits to 1
    EXT     d0                              ; Extend it to a word
    MOVE.w  d0,gzzpos                       ; Store as GZZPos flag
    RTS


._gtlistaddress:
    MOVE.l  a0,-(a7)                        ; preserve a0
    TST.l   d0                              ; Test pointer to first item in list
    BEQ     'head                           ; if NULL, skip to end of routine

    'loop:
    MOVE.l  d0,a0                           ; pointer to item into a0
    MOVE.l  4(a0),d0                        ; pointer to previous item in d0
    BNE     'loop                           ; if pointer to previous is NULL, exit loop
    MOVE.l  a0,d0                           ; pointer to list header into d0

    'head:
    MOVE.l  (a7)+,a0                        ; restore a0
    RTS
    RTS


._gtnewlookprop:
    MOVE.l  (a1),d0                         ; get pointer to gadget list context
    BEQ     'nocontext                      ; if NULL, skip to end of routine

    MOVEA.l d0,a0                           ; pointer to context -> a0
    'firstloop:                             ; loop to find first gadget with correct ID
    MOVE.l  (a0),d0                         ; get next gadget in list
    BEQ     'nocontext:                     ; we have reached the end of the list, exit routine
    MOVEA.l d0,a0                           ; else put pointer to gadget -> a0
    CMP.w   38(a0),d1                       ; compare gadget id's
    BNE     'firstloop                      ; if we ain't found the ID yet, repeat loop

    'lastloop:                              ; goes through the list of gadgets with the same ID
    MOVE.w  16(a0),d0                       ; get gadget type into d0
    AND.w   #GTYP_GTYPEMASK,d0              ; clear out all bits except the gadget types
    CMP.w   #GTYP_PROPGADGET,d0             ; check if this is a prop gadget
    BNE     'notprop

    MOVEA.l 34(a0),a1                       ; Gadget SpecialInfo -> a1 (PropInfo)
    MOVEQ.l #PROPNEWLOOK,d0                 ; Prop new look flag -> d0
    TST.w   d2                              ; check flag of on/offness
    BEQ     'pnl_off                        ; if 0, branch to code to turn flag off

    OR.w    d0,(a1)                         ; set bit for PROPNEWLOOK
    BRA     'pnl_end                        ; branch to end of setting flag
    'pnl_off:                               ; turn propnewlook flag off
    NOT.w   d0                              ; invert flag
    AND.w   d0,(a1)                         ; clear bit for PROPNEWLOOK
    'pnl_end:                               ; end of setting flag

    'notprop:
    MOVE.l  (a0),d0                         ; move onto next gadget
    BEQ     'nocontext                      ; if NULL, end of list, exit routine
    MOVEA.l d0,a0                           ; else pointer to gadget -> a0
    CMP.w   38(a0),d1                       ; compare gadget IDs
    BEQ     'lastloop                       ; If same, still some gadgets To process, Repeat loop

    'nocontext:
    RTS
; Set the prop mode for newly created gadgets
_gtnewlookpropmode:
    MOVE.w  d0,propmode                     ; set the default prop mode for when creating new gadgets
    RTS


._gtptr:
    MOVE.l  a3,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; Try to find gadget in internal memory
    TST.l   d0                              ; Check pointer returned by function
    BEQ     'nogad                          ; if NULL, exit routine

    MOVE.l  a0,-(a7)                        ; Else, preserve a0
    MOVE.l  d0,a0                           ; Pointer -> address reg
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),d0    ; Get gadget pointer from internal memory
    MOVE.l  (a7)+,a0                        ; restore a0

    'nogad:
    RTS


._gtsetattrs:
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; Try to find internally allocated memory for this gadget
    TST.l   d0                              ; Check pointer returned
    BEQ     'nogad                          ; exit if NULL

    MOVE.l  d0,a0                           ; Pointer to internal memory into a0
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget into a0
    BSR     _gttags                         ; Call GTTags, to copy the tags into usertags array
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a1
    SUB.l   a2,a2
    LEA.l   usertags(pc),a3
    MOVE.l  gtbase(pc),a6
    JSR     _SetGadgetAttrs(a6)

    'nogad:
    RTS


._gtsethighlight:
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; Try to find gadget in internal memory lists
    TST.l   d0                              ; Check returned pointer
    BEQ     'nogad                          ; if NULL, exit routine

    MOVEM.l a0-a3/a6,-(a7)
    LEA.l   'defaulttags(pc),a3             ; Pointer to taglist into a3
    MOVE.l  d0,a0                           ; Pointer to internal memory
    MOVE.l  d2,4(a3)                        ; Store the item to highlist as data for both tags
    SUB.l   a2,a2
    MOVE.l  d2,12(a3)                       ; So that it is selected and visible
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a1
    MOVE.l  gtbase(pc),a6
    JSR     _SetGadgetAttrs(a6)
    MOVEM.l (a7)+,a0-a3/a6

    'nogad:
    RTS
'defaulttags:
    Dc.l    GTLV_Selected,0
    Dc.l    GTLV_MakeVisible,0
    Dc.l    0


._gtsetint:
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; Try to find gadget in internal memory lists
    TST.l   d0                              ; Check pointer to internal memory
    BEQ     'nogad                          ; if NULL, exit routine

    MOVEM.l a0-a3/a6,-(a7)

    MOVE.l  d0,a0                           ; Pointer to internal memory into a0
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget into a0
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a1  ; Attached window into a1
    SUB.l   a2,a2

    MOVE.l  #GTIN_Number,d0                 ; Deafult tag - set number for integer gadget
    MOVE.w  !g{GadgetType}(a0),d1           ; Type of gadget into
    ANDI.w  #GTYP_GTYPEMASK,d1              ; Mask out all but the gadget type bits
    CMPI.w  #GTYP_STRGADGET,d1              ; Check if the type is a string gadget (indicating integer gadget)
    BEQ     'nogtnumber                     ; If the same, we don't need to change the tag we already have
    MOVE.l  #GTNM_Number,d0                 ; else set the tag to set the value for a number gadget
    'nogtnumber:

    CLR.l   -(a7)                           ; TAG_DONE
    MOVE.l  d2,-(a7)                        ; Value to set
    MOVE.l  d0,-(a7)                        ; Tag depending on type of gadget
    MOVE.l  a7,a3                           ; taglist into a3
    MOVE.l  gtbase(pc),a6                   ; gadtools.library
    JSR     _SetGadgetAttrs(a6)
    LEA.l   3*4(a7),a7                      ; Remove taglist from stack

    MOVEM.l (a7)+,a0-a3/a6

    'nogad:
    RTS


._gtsetstring:
    MOVE.l  a1,d0                           ; Pointer to GTList object into d0 (ID already in d1)
    BSR     findgadget                      ; Try to find gadget in internal memory lists
    TST.l   d0                              ; Check pointer to internal memory
    BEQ     'nogad                          ; if NULL, exit routine

    MOVEM.l a0-a3/a6,-(a7)

    MOVE.l  d0,a0                           ; Pointer to internal memory into a0
    MOVE.l  d0,a3                           ; And a copy into a3
    MOVE.l  {SizeOf.gtinlist\Gad}(a0),a0    ; Pointer to gadget into a0

    MOVE.l  #GTST_String,d0                 ; Deafult tag - set string for string gadget
    MOVE.w  !g{GadgetType}(a0),d1           ; Type of gadget into
    ANDI.w  #GTYP_GTYPEMASK,d1              ; Mask out all but the gadget type bits
    CMPI.w  #GTYP_STRGADGET,d1              ; Check if the type is a string gadget (indicating string gadget)
    BEQ     'nogttext                       ; If the same, we don't need to change the tag we already have

    CNIF #DEBUG=1
    !PUTSTR{001,"gtsetstring: Doing code for GTText"}
    CEND

    MOVE.l  #GTTX_Text,d0                   ; else set the tag to set the text for a text gadget
    ; We now also need to change the special info (just because)
    MOVEM.l d0-d1/d3/a0-a3/a6,-(a7)
    MOVE.l  {SizeOf.gtinlist\Special}(a3),d1; Pointer to special memory
    CNIF #DEBUG=1
    MOVE.l  d1,-(a7)
    !PUTSTR{002,"gtsetstring: Special=$%lx"}
    MOVE.l  (a7)+,d1
    CEND
    BEQ     'doalloc                        ; if NULL, branch to code to allocate new memory

    MOVE.l  d1,d3                           ; target = special
    MOVE.l  d1,a0
    MOVE.l  -(a0),d1                        ; Size of allocated memory for old special
    MOVE.l  -4(a2),d0                       ; Length of new string (hopefully ;)
    ADDQ.l  #5,d0                           ; Add space for size and terminating NULL
    CNIF #DEBUG=1
    MOVE.l  d1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{003,"gtsetstring: New memory required=%ld  Old space allocated=%ld"}
    LEA.l   2*4(a7),a7
    CEND
    CMP.l   d0,d1                           ; Compare new string mem requirements to old allocated memory size
    BGE     'noalloc                        ; If old size >= new size, branch to noalloc

    'doalloc:
    MOVE.l  -4(a2),d0                       ; Size of string (in case special was 0)
    MOVEQ.l #MEMF_ANY,d1                    ; mem requirements
    BSET    #16,d1                          ; MEMF_CLEAR
    ADDQ.l  #5,d0                           ; add 5 for the size and NULL
    ALibJsr #globalalloc
    CNIF #DEBUG=1
    MOVE.l  d0,-(a7)
    !PUTSTR{004,"gtsetstring: New memory allocated at $%lx"}
    LEA.l   4(a7),a7
    CEND
    TST.l   d0                              ; target = new memory
    BNE     'skipexit

    'earlyexit:
    MOVEM.l (a7)+,d0-d1/d3/a0-a3/a6
    MOVEM.l (a7)+,a0-a3/a6
    RTS

    'skipexit:
    MOVE.l  d0,a1                           ; Pointer to new memory into a1
    MOVE.l  -4(a2),d0                       ; string length
    ADDQ.l  #5,d0                           ; + 5 is the size we allocated
    MOVE.l  d0,(a1)+                        ; store in memory
    MOVE.l  a1,d3                           ; target = new memory

    MOVE.l  {SizeOf.gtinlist\Special}(a3),d0
    BEQ     'noalloc
    MOVE.l  d0,a1
    MOVE.l  -(a1),d0
    CNIF #DEBUG=1
    MOVE.l  a1,-(a7)
    MOVE.l  d0,-(a7)
    !PUTSTR{005,"gtsetstring: Freeing %ld bytes at $%lx"}
    LEA.l   2*4(a7),a7
    CEND
    ALibJsr #globalfree

    ; d2 = new string
    ; d3 = target mem
    'noalloc:
    TST.l   d3                              ; check pointer to target memory
    BEQ     'earlyexit                      ; exit if NULL

    MOVE.l  d2,a0                           ; else, stick source and target memory pointers
    MOVE.l  d3,a1                           ; into address registers
    'copyloop:
    MOVE.b  (a0)+,(a1)+                     ; and copy string
    BNE     'copyloop

    MOVE.l  d3,d2                           ; Set target memory as the memory to be used in the SetGadgetAttrs call
    MOVE.l  d3,{SizeOf.gtinlist\Special}(a3); and put a copy in as the Special info memory

    MOVEM.l (a7)+,d0-d1/d3/a0-a3/a6

    ; d2 contains pointer to the string to use in the SetAttrs call
    'nogttext:
    CLR.l   -(a7)                           ; TAG_DONE
    MOVE.l  d2,-(a7)                        ; Value to set
    MOVE.l  d0,-(a7)                        ; Tag depending on type of gadget
    MOVE.l  a7,a3                           ; taglist into a3
    MOVE.l  gtbase(pc),a6                   ; gadtools.library
    MOVE.l  {SizeOf.gtcontext\gtwindow}(a1),a1  ; Attached window into a1
    SUB.l   a2,a2
    JSR     _SetGadgetAttrs(a6)
    LEA.l   3*4(a7),a7                      ; Remove taglist from stack

    MOVEM.l (a7)+,a0-a3/a6

    'nogad:
    RTS


._gttags:
    MOVE.l  a0,-(a7)                        ; Preserve a0 on stack
    LEA     usertags(pc),a0                 ; Get pointer to start of user specified tag storage
    BRA     'gettags                        ; And branch to end of loop (keeps loop counter happy)

    'tagloop:
    MOVE.l  -(a2),d0                        ; Get tag from stack
    MOVE.l  -(a2),d1                        ; Get data from stack
    MOVEM.l d0-d1,(a0)                      ; Store tag/data in user taglist
    ADDQ    #8,a0                           ; Move onto next tag/data pair in the user taglist

    'gettags:
    DBRA    d7,'tagloop                     ; d7 pre-loaded with number of varargs?!?!?!

    MOVEQ.l #TAG_DONE,d0
    MOVE.l  d0,(a0)                         ; Finally, store the end of taglist in user tags
    MOVE.l  (a7)+,a0
    RTS

._gtunderscore:
    MOVE.w  d0,underscore                   ; Store specified ASCII character code as the underscore character
    RTS


._gtuserdata:
    MOVE.l  d0,wrkgadget+!n{ng_UserData}    ; Store userdata value in the userdata field of the working gadget
    RTS


.
.Globals:
gtname:     Dc.b "gadtools.library",0 : Even
gtbase:     Dc.l    0
gflags:     Dc.w    0                       ; temporarily used for gadget flags on GTShapes
propmode:   Dc.w    0                       ; Shows whether prop gadgets should have the "new look" when created
wrkgadget:  Dcb.b   SizeOf.NewGadget,0      ; space for creating a working gadget
nulltags:   Dc.l    0,0                     ; empty taglist
usertags:   Ds.l    32                      ; User specified tags (16 tag/data pairs max!)
gzzpos:     Ds.w    1                       ; flag to show whether to automatically add window border sizes to gadget left/top
arrowsize:  Dc.w    16                      ; Default size of arrow gadgets for scrollers, sliders etc
underscore: Dc.w    95                      ; ASCII code of character to indicate shortcut key in gadget text
evseconds:  Ds.l    1                       ; Seconds and
evmicros:   Ds.l    1                       ; microseconds at which the last evet occured

; Pointer to head of internal gadget list for gadget pointers
; and other interesting things
internalglist:  Dc.l    0


.
.errors:
err4:MOVE.l #mess4,d0:TRAP #0
err5:MOVE.l #mess5,d0:TRAP #0
err6:MOVE.l #mess6,d0:TRAP #0

mess4:Dc.b "Uninitialized Shape",0
mess5:Dc.b "GTList not attached to a window",0
mess6:Dc.b "GTList already attached to a window",0
Even

.checkattach:
    TST.l   12(a1)                          ; check pointer to window in gtlist object
    BNE     err6                            ; if not NULL, we are aleady attached to a window
    RTS


.checkdetach:
    TST.l   12(a1)                          ; check pointer to window in gtlist object
    BEQ     err5                            ; if NULL, we are not attached to a window
    RTS


.checkbevel:
    TST.l   12(a0)                          ; check pointer to window in gtlist object
    BEQ     err5                            ; if NULL, we are not attached to a window
    RTS


.sgchk2:
    TST     (a2)                            ; check if shape pointed to by a2 has a pixelwidth
    BEQ     err4                            ; if not, shape unititialised, crank up the debugger
.sgchk:
    TST     (a6)                            ; check if shape pointed to by a6 has a pixelwidth
    BEQ     err4                            ; if not, shape unitialised, crank up the error monkey
    RTS

