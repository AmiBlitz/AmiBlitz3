; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Ram Disk:"
; ExeFile         = "riFXLib.obj"
; CreateIcon      = 0
; Residents       = "libnums.res,libmacs.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 0
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 0
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 1
; CursorColumn    = 1
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 5
; Max GadgetList  = 5
; Max Shape       = 100
; Max Bank        = 5
; Max MenuList    = 5
; Max GTList      = 20
; Max Palette     = 4
; Max BitMap      = 10
; Max Screen      = 5
; Max IntuiFont   = 5
; Max Window      = 20
; Max BlitzFont   = 4
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
;rifxlib=66

;FX-library
;By Stephen McNamara
;(C)1994 Reflective Images

;17/7/1994
; As from this date, only the following only work on lorez
;  bitmaps: ZoomX8, ZoomXY, Derez
; Derez has been optimised for all derez values under 18 - it is
;  much faster doing these derezs now
; ClearBitmap and FadeInBitmap have had comments add at last!
;  These commands also have been adjusted to work on any size
;  bitmap.  At the moment, though, they operate on the whole
;  width of the bitmap.
;10/7/1994
; ZoomX2 and ZoomX4 now work on any size bitmap.
;  Depth of zoom is taken from source bitmap but bitmaps can be
;  different heights and widths
; ZOOMX4 command is changed to include separate X and Y zooming,
;  this feature may be added to X2 and X8

Macro bmap
CNIF `0<>2
  CERR "Not enough parameters"
CEND
!libs {#bitmaplib,#ia`1|#pd`2}
End Macro

!libheader {#rifxlib,init,0,finit,0}

!astatement
!args {#long,#long}
!bmap {0,0}
!subs {_clearbitmap2,0,0}
!args {#long,#long,#word,#word}
!bmap {0,0}
!subs {_clearbitmap,0,0}
!name {"ClearBitmap","bitmap#,delay[,height,offset]"}

!astatement
!args {#long,#long,#long}
!libs {#bitmaplib,#ia0|#pd0,#bitmaplib,#ia1|#pd1}
!subs {_fadeinbitmap2,0,0}
!args {#long,#long,#long,#word,#word,#word}
!libs {#bitmaplib,#ia0|#pd0,#bitmaplib,#ia1|#pd1}
!subs {_fadeinbitmap,0,0}
!name {"FadeInBitmap","bitmapsource#,bitmapdest#,delay[,height,offset1,offset2]"}

!astatement
!args {#byte,#byte,#long,#long,#word,#word}
!libs {#bitmaplib,#ia0|#pd0,#bitmaplib,#ia1|#pd1}
!subs {_zoomxy_no_xy,0,0}
!args {#byte,#byte,#long,#long,#word,#word,#byte}
!libs {#bitmaplib,#ia0|#pd0,#bitmaplib,#ia1|#pd1}
!subs {_zoomx4_xy,0,0}
!name {"ZoomX4","source#,dest#,sourceadd,destadd,width,height[,xy_select]"}

!acommand {#long}
!args {#long,#long,#long,#long,#word,#word}
!libs {#bitmaplib,#ia0|#pd0,#bitmaplib,#ia1|#pd1}
!subs {_asmderez,0,0}
!name {"Derez","source#,dest#,sourceadd,destadd,derez_value,height"}

!astatement
!args {#word,#word,#word}
!libs
!subs {_AsmZoom,0,0}
!name {"ZoomXY","xzoom,yzoom,height"}

!astatement
!args {#long,#long,#long,#long}
!libs {#bitmaplib,#ia0|#pd0,#bitmaplib,#ia1|#pd1}
!subs {_InitZoomxy,0,0}
!name {"InitZoomXY","source#,dest#,sourceadd,destadd"}

!astatement
!args {#long,#long,#long,#long,#word,#word}
!libs {#bitmaplib,#ia0|#pd0,#bitmaplib,#ia1|#pd1}
!subs {_zoomx2,0,0}
!name {"ZoomX2","source#,dest#,sourceadd,destadd,width,height"}

!astatement
!args {#long,#long,#word,#word,#word}
!libs
!subs {_planetochunky,0,0}
!name {"PlanarToChunky","bitmap_addr,dest_addr,width,height,depth"}

!astatement
!args {#long,#long,#word,#word,#word}
!libs
!subs {_chunkytoplane,0,0}
!name {"ChunkyToPlanar","source_addr,bitmap_addr,width,height,depth"}

!astatement
!args {#byte,#byte,#long,#long,#word,#word}
!libs {#bitmaplib,#ia0|#pd0,#bitmaplib,#ia1|#pd1}
!subs {_zoomx8,0,0}
!name {"ZoomX8","source#,dest#,sourceadd,destadd,width,height"}

!afunction {#long}
!args {#byte,#word,#word}
!bmap {0,0}
!subs {_ADDValue,0,0}
!name {"ADDValue","(bitmap#,x,y)"}

!astatement
!args {#byte,#byte,#long,#long,#word,#word}
!libs {#bitmaplib,#ia0|#pd0,#bitmaplib,#ia1|#pd1}
!subs {_ReduceX2,0,0}
!name {"ReduceX2","source#,dest#,sourceadd,destadd,width,height"}

finit:!nullsub{_libfinit,0,0}
init: !nullsub{_libinit,0,0}

!libfin

_libfinit:
  TST.l   tableaddress
  BNE     'yup
  RTS
'yup
  MOVE.l  #1856,d0
  MOVE.l  tableaddress,a1
  ALibJsr $c003
  RTS

_libinit:
  MOVE.l  #1856,d0                  ; amount of memoru for LUTs
  MOVEQ.l #%1,d1                    ; any memory please
  MOVEQ.l #0,d2
  ALibJsr $c002                     ; call Blitz allocmem

  TST.l   d0
  BNE     'gotmem
  RTS

'gotmem:
  MOVE.l  d0,tableaddress
  MOVE.l  d0,a0
CreateReduceX2:
  MOVE.l  a0,reducex2table
  MOVEQ.l #0,d0
'loop:
  MOVEQ.l #0,d1
'bit7:
  BTST    #7,d0
  BEQ     'bit5
  BSET    #3,d1
'bit5:
  BTST    #5,d0
  BEQ     'bit3
  BSET    #2,d1
'bit3:
  BTST    #3,d0
  BEQ     'bit1
  BSET    #1,d1
'bit1:
  BTST    #1,d0
  BEQ     'endloop
  BSET    #0,d1
'endloop:
  MOVE.b  d1,(a0)+
  ADDQ.w  #1,d0
  CMPI.w  #256,d0
  BNE     'loop

CreateZoomX2:
  MOVE.l  a0,zoomx2table
  MOVEQ.l #0,d0
'loop:
  MOVEQ.l #0,d1
'bit7:
  BTST    #7,d0
  BEQ     'bit6
  ADD.w   #%1100000000000000,d1
'bit6:
  BTST    #6,d0
  BEQ     'bit5
  ADD.w   #%11000000000000,d1
'bit5:
  BTST    #5,d0
  BEQ     'bit4
  ADD.w   #%110000000000,d1
'bit4:
  BTST    #4,d0
  BEQ     'bit3
  ADD.w   #%1100000000,d1
'bit3:
  BTST    #3,d0
  BEQ     'bit2
  ADD.b   #%11000000,d1
'bit2:
  BTST    #2,d0
  BEQ     'bit1
  ADD.b   #%110000,d1
'bit1:
  BTST    #1,d0
  BEQ     'bit0
  ADD.b   #%1100,d1
'bit0:
  BTST    #0,d0
  BEQ     'endloop
  ADD.b   #%11,d1
'endloop:
  MOVE.w  d1,(a0)+
  ADDQ.w  #1,d0
  CMPI.w  #256,d0
  BNE     'loop

CreateZoomX4:
  MOVE.l  a0,zoomx4table
  MOVEQ.l #0,d0
'loop:
  MOVEQ.l #0,d1
'bit7:
  BTST    #7,d0
  BEQ     'bit6
  ADD.l   #$f0000000,d1
'bit6:
  BTST    #6,d0
  BEQ     'bit5
  ADD.l   #$f000000,d1
'bit5:
  BTST    #5,d0
  BEQ     'bit4
  ADD.l   #$f00000,d1
'bit4:
  BTST    #4,d0
  BEQ     'bit3
  ADD.l   #$f0000,d1
'bit3:
  BTST    #3,d0
  BEQ     'bit2
  ADD.w   #$f000,d1
'bit2:
  BTST    #2,d0
  BEQ     'bit1
  ADD.w   #$f00,d1
'bit1:
  BTST    #1,d0
  BEQ     'bit0
  ADD.b   #$f0,d1
'bit0:
  BTST    #0,d0
  BEQ     'endloop
  ADD.b   #$f,d1
'endloop:
  MOVE.l  d1,(a0)+
  ADDQ.w  #1,d0
  CMPI.w  #256,d0
  BNE     'loop

CreateZoomX8:
  MOVE.l  a0,zoomx8table
  MOVEQ.l #0,d0
'loop:
  MOVEQ.l #0,d1
'bit3:
  BTST    #3,d0
  BEQ     'bit2
  ADD.l   #$ff000000,d1
'bit2:
  BTST    #2,d0
  BEQ     'bit1
  ADD.l   #$ff0000,d1
'bit1:
  BTST    #1,d0
  BEQ     'bit0
  ADD.w   #$ff00,d1
'bit0:
  BTST    #0,d0
  BEQ     'endloop
  ADD.b   #$ff,d1
'endloop:
  MOVE.l  d1,(a0)+
  ADDQ.b  #1,d0
  CMPI.b  #16,d0
  BNE     'loop

  RTS


._planetochunky
  MOVEM.l d0-d7/a0-a6,-(a7)
  MOVE.l  d0,a0

  MOVE.l  d1,a1
  MOVE.l  #"CKPL",(a1)+                     ; store header in plane
  MOVE.w  d2,(a1)+                          ; store width in plane
  MOVE.w  d3,(a1)+                          ; store height in plane
  MOVE.w  d4,(a1)+                          ; store depth in plane

  MOVE.b  d4,bitdepth                       ; store depth

  ASR.w   #3,d2                             ; get width in bytes
  ANDI.l  #$ff,d2
  SUBQ.w  #1,d2                             ; adjust for dbra
  MOVE.w  d2,bitwidth                       ; and store

  SUBQ.w  #1,d3                             ; adjust height for dbra
  MOVE.w  d3,bitheight                      ; and store

  MOVE.w  (a0),bitmapwidth                  ; store bitmap width

  MOVEQ.l #0,d4
  MOVE.b  5(a0),d4
  SUBQ.w  #1,d4
  ADDQ.l  #8,a0
  MOVE.l  (a0)+,TBPL0
  MOVE.l  (a0)+,TBPL1
  MOVE.l  (a0)+,TBPL2
  MOVE.l  (a0)+,TBPL3
  MOVE.l  (a0)+,TBPL4
  MOVE.l  (a0)+,TBPL5
  MOVE.l  (a0)+,TBPL6
  MOVE.l  (a0)+,TBPL7

  MOVE.w  bitheight,d7                      ; d7=line counter
  MOVE.l  a1,a6

  MOVEM.l d0-d7/a0-a6,-(a7)
  MOVE.l  4,a6
  JSR     -$27c(a6)
  MOVEM.l (a7)+,d0-d7/a0-a6
'yloop:
  MOVE.w  bitwidth,d6                       ; d6=width in bytes
  MOVEQ.l #7,d5                             ; pointer to bit
  MOVEQ.l #0,d3                             ; amount to add to bitplane pointer
'xloop
  MOVEQ.l #0,d0
; construct a byte from upto 8 bitplanes
'TSTBPL0:
  MOVE.l  TBPL0,a1
  ADD.l   d3,a1
  BTST    d5,(a1)
  BEQ     'TSTBPL1
  BSET    #0,d0
'TSTBPL1:
  CMP.b   #1,bitdepth
  BEQ     'end_test
  MOVE.l  TBPL1,a1
  ADD.l   d3,a1
  BTST    d5,(a1)
  BEQ     'TSTBPL2
  BSET    #1,d0
'TSTBPL2:
  CMP.b   #2,bitdepth
  BEQ     'end_test
  MOVE.l  TBPL2,a1
  ADD.l   d3,a1
  BTST    d5,(a1)
  BEQ     'TSTBPL3
  BSET    #2,d0
'TSTBPL3:
  CMP.b   #3,bitdepth
  BEQ     'end_test
  MOVE.l  TBPL3,a1
  ADD.l   d3,a1
  BTST    d5,(a1)
  BEQ     'TSTBPL4
  BSET    #3,d0
'TSTBPL4:
  CMP.b   #4,bitdepth
  BEQ     'end_test
  MOVE.l  TBPL4,a1
  ADD.l   d3,a1
  BTST    d5,(a1)
  BEQ     'TSTBPL5
  BSET    #4,d0
'TSTBPL5:
  CMP.b   #5,bitdepth
  BEQ     'end_test
  MOVE.l  TBPL5,a1
  ADD.l   d3,a1
  BTST    d5,(a1)
  BEQ     'TSTBPL6
  BSET    #5,d0
'TSTBPL6:
  CMP.b   #6,bitdepth
  BEQ     'end_test
  MOVE.l  TBPL6,a1
  ADD.l   d3,a1
  BTST    d5,(a1)
  BEQ     'TSTBPL7
  BSET    #6,d0
'TSTBPL7:
  CMP.b   #7,bitdepth
  BEQ     'end_test
  MOVE.l  TBPL7,a1
  ADD.l   d3,a1
  BTST    d5,(a1)
  BEQ     'end_test
  BSET    #7,d0

'end_test:
  MOVE.b  d0,(a6)+                            ; store byte
  SUBQ.b  #1,d5
  BPL     'xloop

  ADDQ.b  #1,d3
  MOVEQ.l #7,d5
  DBRA    d6,'xloop

  MOVEQ.l #0,d5
  MOVE.w  bitmapwidth,d5

  ADD.l   d5,TBPL0
  ADD.l   d5,TBPL1
  ADD.l   d5,TBPL2
  ADD.l   d5,TBPL3
  ADD.l   d5,TBPL4
  ADD.l   d5,TBPL5
  ADD.l   d5,TBPL6
  ADD.l   d5,TBPL7

  DBRA    d7,'yloop
  MOVEM.l (a7)+,d0-d7/a0-a6
  RTS

._chunkytoplane:
  MOVEM.l d0-d7/a0-a6,-(a7)

  MOVE.l  d0,a0
  MOVE.l  d1,a1

  MOVE.b  d4,bitdepth                       ; store depth

  SUBQ.w  #1,d2                             ; adjust for dbra
  MOVE.w  d2,bitwidth                       ; and store

  SUBQ.w  #1,d3                             ; adjust height for dbra
  MOVE.w  d3,bitheight                      ; and store

  MOVE.w  (a1),bitmapwidth                  ; store bitmap width

  MOVEQ.l #0,d4
  MOVE.b  5(a1),d4
  SUBQ.w  #1,d4
  ADDQ.l  #8,a1
  MOVE.l  a1,a5

  MOVEM.l d0-d7/a0-a6,-(a7)
  MOVE.l  4,a6
  JSR     -$27c(a6)
  MOVEM.l (a7)+,d0-d7/a0-a6
  MOVE.l  a0,a6

  MOVEQ.l #0,d4
;a6=Addr Chunky   a5=Bitplane PTRS
'bitplane_loop:
  MOVE.l  a6,a0
  MOVE.l  (a5)+,a2
  MOVE.l  a2,a1
  MOVE.w  bitheight,d7                      ; d7=line counter
'yloop:
  MOVE.w  bitwidth,d6                       ; d6=width in bytes
  MOVEQ.l #31,d5                            ; d5=pointer to bit
  MOVEQ.l #0,d1                             ; d4=bitplane pointer
'xloop:                                     ; d0=chunky byte
  MOVE.b  (a0)+,d0                          ; d1=bitplane data
  BTST    d4,d0
  BEQ     'not_set
  BSET    d5,d1

'not_set:
  SUBQ.w  #1,d6
  BMI     'end_of_line
  SUBQ.b  #1,d5
  BPL     'xloop

  MOVE.l  d1,(a1)+
  MOVEQ.l #0,d1
  MOVEQ.l #31,d5
  BRA     'xloop

'end_of_line
  MOVE.l  d1,(a1)+
  MOVEQ.l #0,d0
  MOVE.w bitmapwidth,d0
  ADD.l   d0,a2
  MOVE.l  a2,a1
  DBRA    d7,'yloop

  ADDQ.b  #1,d4
  CMP.b   bitdepth,d4
  BNE     'bitplane_loop
  MOVEM.l (a7)+,d0-d7/a0-a6
  RTS


bitdepth:     Dc.b  1
  Even
bitwidth:     Dc.w  1
bitheight:    Dc.w  1
bitmapwidth:  Dc.w  1
TBPL0:        Dc.l  1
TBPL1:        Dc.l  1
TBPL2:        Dc.l  1
TBPL3:        Dc.l  1
TBPL4:        Dc.l  1
TBPL5:        Dc.l  1
TBPL6:        Dc.l  1
TBPL7:        Dc.l  1

;Clear a bitmap backwards
_clearbitmap2:
  MOVE.w  2(a0),d2
  MOVEQ.l #0,d3
._clearbitmap:
  MOVEM.l a4-a6,-(a7)                  ;save registers
  MOVE.l  d1,delay_timer               ;store delay value
  MOVE.w  (a0),d1                      ;get EBWidth
  ASR.w   #1,d1                        ;divide by 2
  SUBQ.w  #1,d1                        ;adjust for dbra
  MOVE.w  d1,EWWidth                   ;even word width of clear
  MOVE.w  4(a0),BDepth                 ;get depth
  SUBQ.w  #1,BDepth                    ;subtract 1

  ANDI.l  #$ffff,d2
  MOVE.w  d2,BHeight
  SUBQ.w  #1,BHeight
  ADD.w   d3,d2
  MULU.w  (a0),d2                      ;multiple by EBWidth
  SUBQ.l  #4,d2                        ;subtract 2 for loop

  ADDQ.l  #8,a0
  MOVE.w  BDepth,d0
  LEA     bit_add(pc),a1
  LEA     dest_add(pc),a2
Store_loop
  MOVE.l  (a0)+,d1
  ADD.l   d2,d1
  MOVE.l  d1,(a1)+
  MOVE.l  d1,(a2)+
  DBRA    d0,Store_loop

;yer actual routine
  MOVEQ.l #0,d5
  MOVE.w  BHeight,d5                   ;get height
  MOVE.w  #-19,d4                      ;stop value
  MOVE.l  #%1010101010101010,d3        ;source mask
Main_loop
  TST.w   d5                           ;over 0?
  BMI     Clear_a_line                 ; no - branch
Mask_a_line
  LEA     bit_add(pc),a1               ;get first dest pointers
  MOVE.w  EWWidth,d6                   ;get width
Xloop
  MOVE.w  BDepth,d7                    ;get width
  MOVE.l  a1,a0                        ;get dest pointer array
bit_loop
  MOVE.l  (a0),a2                      ;get bitplane
  AND.w   d3,(a2)                      ;mask word
  SUBQ.l  #2,(a0)+                     ;subtract 4 from source
  DBRA    d7,bit_loop                  ;loop for all bitplanes
  DBRA    d6,Xloop                     ;loop for all of line
  NOT.w   d3                           ;not mask for next line

Clear_a_line
  TST.w   d4                           ;Clear this line?
  BMI     End_loop                     ;no - branch
  LEA     dest_add(pc),a1              ;get second dest pointers
  MOVE.w  EWWidth,d6                   ;get width
Xloop2
  MOVE.w  BDepth,d7                    ;get depth
  MOVE.l  a1,a0                        ;get array
bit_loop2
  MOVE.l  (a0),a2                      ;get bitplane pointer
  MOVE.w  #0,(a2)                      ;clear word
  SUBQ.l  #2,(a0)+                     ;decrement pointer and adjust array
  DBRA    d7,bit_loop2                 ;loop for all planes
  DBRA    d6,Xloop2                    ;loop for all of width

End_loop
  MOVE.l  delay_timer,d7               ;get delay value
Slow_down_loop
  SUBQ.l  #1,d7                        ;simple instruction
  BNE     Slow_down_loop               ;loop until 0

  ADDQ.w  #1,d4                        ;1 more line done
  SUBQ.w  #1,d5                        ;decrement counter
  CMPI.w  #-20,d5                      ;is it the end?
  BNE     Main_loop                    ;nop - branch

  MOVEM.l (a7)+,a4-a6                  ;restore registers
  RTS                                  ;and exit

;Copy a bitplane nicely!
_fadeinbitmap2:
  MOVE.w  2(a0),d3
  MOVEQ.l #0,d4
  MOVEQ.l #0,d5
._fadeinbitmap:
  MOVEM.l a4-a6,-(a7)                  ;save resgisters
  MOVE.l  d2,delay_timer               ;store delay value
  MOVE.w  (a0),d2                      ;get EBWidth
  ASR.w   #1,d2                        ;divide by 2
  SUBQ.w  #1,d2                        ;adjust for dbra
  MOVE.w  d2,EWWidth                   ;even word width of clear
  MOVE.w  4(a0),BDepth                 ;get depth to do
  SUBQ.w  #1,BDepth                    ;adjust for dbra

  ANDI.l  #$ffff,d3                    ;just in case
  MOVE.w  d3,BHeight                   ;store height to do
  SUBQ.w  #1,BHeight                   ;adjust for dbra

  MULU.w  (a0),d4                      ;make pixel offsets
  MULU.w  (a0),d5                      ; into byte offsets

  ADDQ.l  #8,a0                        ;get source bitplane pointers
  ADDQ.l  #8,a1                        ;get dest bitplane poi\nters
  MOVE.w  BDepth,d0                    ;get depth
  LEA     bit_add(pc),a2               ;storage area source
  LEA     dest_add(pc),a3              ;storage area dest
'Store_loop
  MOVE.l  (a0)+,d1                     ;source bitplane
  ADD.l   d4,d1                        ;add offset
  MOVE.l  d1,(a2)+                     ;store pointer
  MOVE.l  d1,(a3)+                     ;store pointer

  MOVE.l  (a1)+,d1                     ; destination bitmap
  ADD.l   d5,d1                        ;add offset
  MOVE.l  d1,(a2)+                     ;store pointer
  MOVE.l  d1,(a3)+                     ;store pointer
  DBRA    d0,'Store_loop               ;loop for all bitplanes

;yer actual routine
  MOVEQ.l #0,d5
  MOVE.w  BHeight,d5                   ;get height
  MOVE.w  #-19,d4                      ;stop value
  MOVE.l  #%1010101010101010,d3        ;data mask

'Main_loop
  TST.w   d5                           ;under 0?
  BMI     'Clear_a_line                ;yup - branch
'Mask_a_line
  LEA     bit_add(pc),a1               ;get pointers
  MOVE.w  EWWidth,d6                   ;get width
'Xloop
  MOVE.w  BDepth,d7                    ;get depth to do
  MOVE.l  a1,a0                        ;get pointers
'bit_loop
  MOVE.l  (a0),a2                      ;get source bitplane
  MOVE.l  4(a0),a3                     ;get dest bitplane
  MOVE.w  (a2),d0                      ;get a word of data
  AND.w   d3,d0                        ;and mask it
  MOVE.w  d0,(a3)                      ;store in dest
  ADDQ.l  #2,(a0)+                     ;adjust pointer and store
  ADDQ.l  #2,(a0)+                     ;adjust pointer and store
  DBRA    d7,'bit_loop                 ;loop for all bitplanes
  DBRA    d6,'Xloop                    ;loop for all of width
  NOT.w   d3                           ;NOT mask for next line

'Clear_a_line
  TST.w   d4                           ;do this line?
  BMI     'End_loop                    ;no - branch
  LEA     dest_add(pc),a1              ;get pointer array
  MOVE.w  EWWidth,d6                   ;get width
'Xloop2
  MOVE.w  BDepth,d7                    ;get depth
  MOVE.l  a1,a0                        ;get array
'bit_loop2
  MOVE.l  (a0),a2                      ;get source bitplane
  MOVE.l  4(a0),a3                     ;get dest bitplane
  MOVE.w  (a2),(a3)                    ;copy data over
  ADDQ.l  #2,(a0)+                     ;adjust pointer
  ADDQ.l  #2,(a0)+                     ;adjust pointer
  DBRA    d7,'bit_loop2                ;loop for all bitplanes

  DBRA    d6,'Xloop2                   ;loop for all of width

'End_loop
  MOVE.l  delay_timer,d7               ;get delay value
'Slow_down_loop
  SUBQ.l  #1,d7                        ;simple instruction
  BNE     'Slow_down_loop              ;loop until 0

  ADDQ.w  #1,d4                        ;adjust counter
  SUBQ.w  #1,d5                        ;adjust counter
  CMPI.w  #-20,d5                      ;is it all done?
  BNE     'Main_loop                   ;loop until it is

  MOVEM.l (a7)+,a4-a6                  ;restore registers
  RTS                                  ;and exit

  Even
EWWidth:    Dc.w  0
BHeight:    Dc.w  0
BDepth:     Dc.w  0
delay_timer:Dc.l  0

;================================

_zoomx4_xy:
  MOVE.b  -1(a2),d7
  BRA     _zoomx4
_zoomxy_no_xy:
  CLR.b   d7
._zoomx4:
  TST.l   zoomx4table
  BNE     'yup
  RTS
'yup:
  MOVE.b  d7,d0
  MOVEM.l d0-d7/a0-a6,-(a7)
  MOVE.l  d2,d6
  MOVE.l  d3,d7

  MOVEQ.l #0,d2
  MOVE.b  5(a0),d2
  SUBQ.b  #1,d2       ; adjust for dbra

  LEA     8(a0),a5
  LEA     8(a1),a6

  MOVE.l  zoomx4table,a4

  ASR.w   #3,d4
  MOVE.w  d4,d3
  SUBQ.w  #1,d4       ; adjust for dbra
  BMI     the_end
  SUBQ.w  #1,d5       ; adjust for dbra
  BMI     the_end
  MOVE.w  d4,xzoom
  MOVE.w  d5,yzoom

  CMPI.b  #1,d0
  BEQ     X4_x
  CMPI.b  #2,d0
  BEQ     X4_y

;Calculate source mod
  MOVEQ.l #0,d5
  MOVE.w  -8(a5),d5
  SUB.w   d3,d5

;Calculate dest mod
  MOVEQ.l #0,d4
  MOVE.w  -8(a6),d4
  MOVE.w  d4,bytesperline+2
  ASL.w   #2,d4
  ASL.w   #2,d3
  SUB.w   d3,d4
  MOVE.l  d4,d3

  MOVE.l  a5,sourcebitplanes

;X4 - x and y
'x4do_bitplanes
  MOVE.l  sourcebitplanes,a5
  ADD.l   #4,sourcebitplanes
  MOVE.l  (a5)+,a0
  ADD.l   d6,a0
  MOVE.l  (a6)+,a1
  ADD.l   d7,a1

  MOVE.l  a1,a2
  ADD.l   bytesperline,a2
  MOVE.l  a2,a3
  ADD.l   bytesperline,a3
  MOVE.l  a3,a5
  ADD.l   bytesperline,a5

  MOVE.w  yzoom,d1
'x4next_line
  MOVE.w  xzoom,d0
'x4do_line
  MOVEQ.l #0,d4
  MOVE.b  (a0)+,d4
  ASL.w   #2,d4
  MOVE.l  0(a4,d4.w),d4

  MOVE.l  d4,(a1)+
  MOVE.l  d4,(a2)+
  MOVE.l  d4,(a3)+
  MOVE.l  d4,(a5)+

  DBRA    d0,'x4do_line

  ADD.l   d5,a0
  ADD.l   d3,a1
  ADD.l   d3,a2
  ADD.l   d3,a3
  ADD.l   d3,a5

  DBRA    d1,'x4next_line

  DBRA    d2,'x4do_bitplanes
  MOVEM.l (a7)+,d0-d7/a0-a6
  RTS

  sourcebitplanes: Dc.l 0

X4_x:
;Calculate source mod
  MOVEQ.l #0,d5
  MOVE.w  -8(a5),d5
  SUB.w   d3,d5

;Calculate dest mod
  MOVEQ.l #0,d4
  MOVE.w  -8(a6),d4
  ASL.w   #2,d3
  SUB.w   d3,d4
  MOVE.l  d4,d3

'x4do_bitplanes
  MOVE.l  (a5)+,a0
  ADD.l   d6,a0
  MOVE.l  (a6)+,a1
  ADD.l   d7,a1
  MOVE.w  yzoom,d1
'x4next_line
  MOVE.w  xzoom,d0
;  MOVE.l  a0,a2
;  MOVE.l  a1,a3
'x4do_line
  MOVEQ.l #0,d4
  MOVE.b  (a0)+,d4
  ROL.w   #2,d4
  MOVE.l  0(a4,d4.w),(a1)+

  DBRA    d0,'x4do_line

  ADD.l   d5,a0
  ADD.l   d3,a1

  DBRA    d1,'x4next_line

  DBRA    d2,'x4do_bitplanes
  MOVEM.l (a7)+,d0-d7/a0-a6
  RTS

X4_y:
;Calculate source mod
  MOVEQ.l #0,d5
  MOVE.w  -8(a5),d5
  SUB.w   d3,d5

;Calculate dest mod
  MOVEQ.l #0,d4
  MOVE.w  -8(a6),d4
  MOVE.w  d4,bytesperline+2
  ASL.w   #2,d4
  SUB.w   d3,d4
  MOVE.l  d4,d3

  MOVE.l  a5,sourcebitplanes

'x4do_bitplanes
  MOVE.l  sourcebitplanes,a5
  ADD.l   #4,sourcebitplanes
  MOVE.l  (a5)+,a0
  ADD.l   d6,a0
  MOVE.l  (a6)+,a1
  ADD.l   d7,a1

  MOVE.l  a1,a2
  ADD.l   bytesperline,a2
  MOVE.l  a2,a3
  ADD.l   bytesperline,a3
  MOVE.l  a3,a5
  ADD.l   bytesperline,a5

  MOVE.w  yzoom,d1
'x4next_line
  MOVE.w  xzoom,d0
'x4do_line
  MOVE.b  (a0)+,d4

  MOVE.b  d4,(a1)+
  MOVE.b  d4,(a2)+
  MOVE.b  d4,(a3)+
  MOVE.b  d4,(a5)+

  DBRA    d0,'x4do_line

  ADD.l   d5,a0
  ADD.l   d3,a1
  ADD.l   d3,a2
  ADD.l   d3,a3
  ADD.l   d3,a5

  DBRA    d1,'x4next_line

  DBRA    d2,'x4do_bitplanes
the_end:
  MOVEM.l (a7)+,d0-d7/a0-a6
  RTS

._zoomx2:
  TST.l   zoomx2table
  BNE     'yup
  RTS
'yup:
  MOVEM.l d0-d7/a0-a6,-(a7)

  MOVE.l  d2,d6
  MOVE.l  d3,d7

  MOVEQ.l #0,d2
  MOVE.b  5(a0),d2
  SUBQ.b  #1,d2       ; adjust for dbra

  LEA     8(a0),a5
  LEA     8(a1),a6

  MOVE.l  zoomx2table,a4

  ASR.w   #3,d4
  MOVE.w  d4,d3
  SUBQ.w  #1,d4       ; adjust for dbra
  BMI     'the_end
  SUBQ.w  #1,d5       ; adjust for dbra
  BMI     'the_end
  MOVE.w  d4,xzoom
  MOVE.w  d5,yzoom

;Calculate source mod
  MOVEQ.l #0,d5
  MOVE.w  -8(a5),d5
  SUB.w   d3,d5

;Calculate dest mod
  MOVEQ.l #0,d4
  MOVE.w  -8(a6),d4
  MOVE.w  d4,bytesperline+2
  SUB.w   d3,d4
  SUB.w   d3,d4
  MOVE.l  d4,d3
  ADD.w   -8(a6),d3

'x2do_bitplanes
  MOVE.l  (a5)+,a0
  ADD.l   d6,a0
  MOVE.l  (a6)+,a1
  ADD.l   d7,a1

  MOVE.l  a1,a2
  ADD.l   bytesperline,a2
  MOVE.w  yzoom,d1
'x2next_line
  MOVE.w  xzoom,d0
'x2do_line
  MOVEQ.l #0,d4
  MOVE.b  (a0)+,d4
  ASL.w   #1,d4
  MOVE.w  0(a4,d4.w),d4

'x2drawbits
  MOVE.w  d4,(a1)+
  MOVE.w  d4,(a2)+

  DBRA    d0,'x2do_line

  ADD.l   d5,a0
  ADD.l   d3,a1
  ADD.l   d3,a2

  DBRA    d1,'x2next_line

  DBRA    d2,'x2do_bitplanes
'the_end:
  MOVEM.l (a7)+,d0-d7/a0-a6
  RTS

._zoomx8
  TST.l   zoomx8table
  BNE     'yup
  RTS
'yup:
  MOVEM.l d0-d7/a0-a6,-(a7)

  MOVE.l  d2,d6
  MOVE.l  d3,d7

  MOVEQ.l #0,d2
  MOVE.b  5(a0),d2
  SUBQ.b  #1,d2       ; adjust for dbra

  LEA     8(a0),a5
  LEA     8(a1),a6

  MOVE.l  zoomx8table,a4

  ASR.w   #3,d4
  SUBQ.w  #1,d4       ; adjust for dbra
  BMI     'the_end
  SUBQ.w  #1,d5       ; adjust for dbra
  BMI     'the_end
  MOVE.w  d4,xzoom
  MOVE.w  d5,yzoom

'do_bitplanes
  MOVE.l  (a5)+,a0
  ADD.l d6,a0
  MOVE.l  (a6)+,a1
  ADD.l d7,a1

  MOVE.w  yzoom,d1
'next_line
  MOVE.w  xzoom,d0
  MOVE.l  a0,a2
  MOVE.l  a1,a3
'do_line
  MOVE.b  (a2)+,d4
  MOVE.b  d4,d5
  ANDI.b  #$f,d5
  ANDI.l  #$f0,d4
  LSR.b   #2,d4
  MOVE.l  0(a4,d4.w),d3

'drawbits
  MOVE.l  d3,(a3)
  MOVE.l  d3,40(a3)
  MOVE.l  d3,80(a3)
  MOVE.l  d3,120(a3)
  MOVE.l  d3,160(a3)
  MOVE.l  d3,200(a3)
  MOVE.l  d3,240(a3)
  MOVE.l  d3,280(a3)

  LSL.b   #2,d5
  MOVE.l  0(a4,d5.w),d3
  ADDQ.l  #4,a3
  MOVE.l  d3,(a3)
  MOVE.l  d3,40(a3)
  MOVE.l  d3,80(a3)
  MOVE.l  d3,120(a3)
  MOVE.l  d3,160(a3)
  MOVE.l  d3,200(a3)
  MOVE.l  d3,240(a3)
  MOVE.l  d3,280(a3)

   ADDQ.l  #4,a3
  DBRA    d0,'do_line

  LEA     40(a0),a0
  LEA     320(a1),a1

  DBRA    d1,'next_line

  DBRA    d2,'do_bitplanes
'the_end
  MOVEM.l (a7)+,d0-d7/a0-a6
  RTS

._ReduceX2:
  TST.l   reducex2table
  BNE     'yup
  RTS
'yup:
  MOVEM.l d0-d7/a0-a6,-(a7)

  MOVE.l  d2,d6
  MOVE.l  d3,d7

  MOVEQ.l #0,d2
  MOVE.b  5(a0),d2
  SUBQ.b  #1,d2       ; adjust for dbra

  MOVE.w  (a0),d0
  ASL.w   #1,d0
  MOVE.w  d0,bytesperline+2
  MOVE.w  (a1),bytesperline2+2
  LEA     8(a0),a5
  LEA     8(a1),a6

  MOVE.l  reducex2table,a4

  ASR.w   #3,d4
  SUB.w   d4,bytesperline+2
  ASR.w   #1,d4
  SUB.w   d4,bytesperline2+2
  SUBQ.w  #1,d4       ; adjust for dbra
  BMI     'the_end
  ASR.w   #1,d5
  SUBQ.w  #1,d5       ; adjust for dbra
  BMI     'the_end
  MOVE.w  d4,xzoom
  MOVE.w  d5,yzoom

  MOVEQ.l #0,d4
'x2do_bitplanes
  MOVE.l  (a5)+,a0
  ADD.l   d6,a0
  MOVE.l  (a6)+,a1
  ADD.l   d7,a1
  MOVE.w  yzoom,d1
'x2next_line
  MOVE.w  xzoom,d0
'x2do_line
  MOVE.b  (a0)+,d4
  MOVE.b  0(a4,d4.w),d3

  ASL.b   #4,d3

  MOVE.b  (a0)+,d4
  OR.b    0(a4,d4.w),d3

  MOVE.b  d3,(a1)+

  DBRA    d0,'x2do_line

  ADD.l   bytesperline,a0
  ADD.l   bytesperline2,a1

  DBRA    d1,'x2next_line

  DBRA    d2,'x2do_bitplanes
'the_end:
  MOVEM.l (a7)+,d0-d7/a0-a6
  RTS

  Even
bytesperline: Dc.l  0
bytesperline2:Dc.l  0
xzoom:        Dc.w  1
yzoom:        Dc.w  1

tableaddress: Dc.l  0
reducex2table:Dc.l  0
zoomx2table:  Dc.l  0
zoomx4table:  Dc.l  0
zoomx8table:  Dc.l  0

._asmderez
  TST.w   d4
  BNE     'ok
  RTS
'ok
  MOVEM.l d1-d7/a0-a6,-(a7)     ; save BLITZ registers
  MOVE.w  d4,res_value          ; store res_value
  MOVE.w  d4,res_value2         ; store again BUT
  SUBQ.w  #1,res_value2         ;  subtract 1 this time
  MOVE.w  d5,height             ; store height AND
  SUBQ.w  #1,height             ;  subtract 1 for dbra
  MOVE.b  5(a0),sbitdepth+1     ; get source bitplane depth
  SUBQ.w  #1,sbitdepth          ;  subtract 1 for dbra
  LEA     8(a0),a0              ; get source's bitplane pointers
  LEA     8(a1),a1              ; get dest's bitplane pointers

  MOVE.w  sbitdepth,d0          ; get bitdepth in d0
  LEA     bit_add(pc),a2        ; source bitplane storage
  LEA     dest_add(pc),a3       ; dest bitplane storage
'store_bitplanes
  MOVE.l  (a0)+,(a2)            ; copy source bitplane address
  ADD.l   d2,(a2)+              ;  AND add offset value
  MOVE.l  (a1)+,(a3)            ; copy dest bitplane address
  ADD.l   d3,(a3)+              ;  AND add offset value
  DBRA    d0,'store_bitplanes   ; loop for all bitplanes

  TST.w   res_value2            ; Is res_value2=0?
  BEQ     ScreenCopy            ; if so - SCREENCOPY

  CMPI.w  #2,res_value          ; Is res_value=2?
  BEQ     UnrezX2               ; yes - do FAST X2 unrez

  MOVEQ.l #40,d7                ; 40 byte wide screen
  MULU.w  res_value,d7          ; X number of lines
  MOVE.l  d7,add_value          ; gives us step value

  MOVE.w  height,yvalue         ; store height in yvalue for use
                                ;  in loop
  LEA     myline(pc),a5
  MOVEQ.l #19,d0
  MOVEQ.l #15,d1
  MOVE.w  res_value,d3

  MOVEQ.l #0,d2
'widthloop:
  BSET    d1,d2
  SUB.w   d3,d1
  BPL     'widthloop
;  NOT.w   d2
  MOVE.w  d2,(a5)+
  MOVEQ.l #0,d2

  ADD.w   #16,d1
  BMI     'moretodo
  DBRA    d0,'widthloop
  BRA     'yloop

'moretodo:
  MOVE.w  #0,(a5)+
  SUBQ.w  #1,d0
  BMI     'yloop
  ADD.w   #16,d1
  BMI     'moretodo
  DBRA    d0,'widthloop

'yloop:                         ; d6=bitplane loop
  LEA     bit_add(pc),a0        ; d5=xloop
  LEA     dest_add(pc),a6
  MOVE.w  sbitdepth,d6
'bitplane_loop:
  MOVE.w  yvalue,d7
  MOVE.l  (a0),a1               ; a1=source
  MOVE.l  a1,a2                 ; a2=source (corruptable)
  MOVE.l  (a6),a3               ; a3=destination
  MOVEQ.l #19,d5                ; x count for pixels
  MOVEQ.l #0,d0
  MOVEQ.l #0,d1

  CMPI.w  #16,res_value2
  BHI     'bitbitplane_loop

  LEA     myline(pc),a5
  MOVE.w  #0,mytemp
'xloop:
  MOVEQ.l #0,d0
  MOVEQ.l #0,d2

  MOVE.w  (a2)+,d0
  MOVE.w  (a5)+,d2
  AND.w   d2,d0

  MOVE.w  d0,d2

  MOVE.w  res_value2,d4
  SUBQ.w  #1,d4
'myrollloop:
  ROR.l   #1,d2
  OR.l    d2,d0
  DBRA    d4,'myrollloop
  BRA     'dotherest

'dotherest:
  OR.w    d1,d0

  MOVE.w  d0,(a3)+
  SWAP    d0
  MOVE.w  d0,d1

  DBRA    d5,'xloop                ; loop for whole line
  BRA     'done_line

;Bitmode:
'bitbitplane_loop:
;  MOVE.w  yvalue,d7
;  MOVE.l  (a0),a1               ; a1=source
;  MOVE.l  a1,a2                 ; a2=source (corruptable)
;  MOVE.l  (a6),a3               ; a3=destination
;  MOVEQ.l #19,d5                ; x count for pixels
  MOVEQ.l #15,d3                ; first bit to test on line
'bitxloop:
  MOVE.w  res_value2,d4         ; get number of bits to set
  MOVE.w  (a2),d0               ; get source word
  BTST    d3,d0                 ; test bit of word
  BEQ     'clearbits            ; if not set - branch
'setbits:                       ; SETS bits in dest line
  MOVE.w  (a3),d2               ; get destination word
'setbits_loop:
  BSET    d3,d2                 ; set the bit!
  SUBQ.b  #1,d3                 ; decrease bit pointer
  BMI     'setbits_word         ; if negative the get new word
  DBRA    d4,'setbits_loop      ; loop for all bits
  BRA     'next_bit             ; branch to main line loop
'setbits_word:                  ; GETS a new destination word
  ADDQ.l  #2,a2                 ; add 2 to source - IMPORTANT
  MOVE.w  d2,(a3)+              ; move current word into dest
  MOVE.w  (a3),d2               ; get new word
  MOVEQ.l #15,d3                ; reset bit pointer
  SUBQ.b  #1,d5                 ; subtract 1 from # of words
  BMI     'done_line            ; exit if we've overflowed the line
  DBRA    d4,'setbits_loop      ; loop for all bits to set
  BRA     'next_bit             ; branch to main line loop

'clearbits                      ; CLEARS bits in dest line
  MOVE.w  (a3),d2
'clearbits_loop:
  BCLR    d3,d2
  SUBQ.b  #1,d3
  BMI     'clearbits_word
  DBRA    d4,'clearbits_loop
  BRA     'next_bit
'clearbits_word:
  ADDQ.w  #2,a2
  MOVE.w  d2,(a3)+
  MOVE.w  (a3),d2
  MOVEQ.l #15,d3
  SUBQ.b  #1,d5
  BMI     'done_line
  DBRA    d4,'clearbits_loop

'next_bit:
  MOVE.w  d2,(a3)               ; store dest word
  BRA     'bitxloop                ; loop for whole line



'done_line                      ; COPIES line vertically
  MOVE.w  res_value,d4          ; get res_value
  SUBQ.w  #2,d4                 ; subtract 2 (dbra & current line)
  MOVE.l  (a6),a1               ; get dest bitplane address
  LEA     40(a1),a2             ; add 40 ti skip current line
'copy_line:
  SUBQ.w  #1,d7                 ; subtract 1 from height
  BMI     'out_of_screen        ; Height negative? - OVERFLOW
  MOVE.l  (a1)+,(a2)+           ; Copy 40 bytes
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  DBRA    d4,'copy_line         ; loop around for all lines

  MOVE.l  add_value,d4          ; move source bitplane pointer down
  ADD.l   d4,(a0)               ;  by the current amount & store

'out_of_screen                  ; ALL Y SCREEN FILLED FOR 1 bitplane
  ADDQ.l  #4,a0                 ; increment source bitplane pointer
  MOVE.l  a2,(a6)+              ; store dest bitplane pointer
  DBRA    d6,'bitplane_loop     ; loop for all bitplanes

  MOVE.w  res_value,d6
  SUB.w   d6,yvalue             ; decrease yvalue

  TST.w   yvalue                ; test yvalue for OVERFLOW
  BMI     get_out_of_it         ; yvalue NEGATIVE? - RTS
  BRA     'yloop                ; loop for all lines
get_out_of_it
  MOVEM.l (a7)+,d1-d7/a0-a6     ; restore BLITZ registers
  RTS                           ; EXIT

UnrezX2
  MOVEQ.l #0,d7                 ; clear d7
  MOVE.w  height,d7             ; get height-1
  ADDQ.w  #1,d7                 ; add 1 to height
  ASR.w   #1,d7                 ; divide by 2 for FASTX2
  SUBQ.w  #1,d7                 ; subtract 1 for dbra

  LEA     bit_add(pc),a0        ; get source pointers
  LEA     dest_add(pc),a1       ; get dest pointers
  MOVE.w  sbitdepth,d6          ; get bitplane depth
'X2bitloop
  MOVE.l  (a0)+,a2              ; get source bitplane address
  MOVE.l  (a1)+,a3              ; get dest bitplane address
  MOVE.w  d7,d5                 ; copy height into temp
'X2yloop
  MOVE.w  #9,d4                 ; do 10 longwords please
'X2xloop
  MOVE.l  (a2)+,d0              ; get data
  ANDI.l  #%10101010101010101010101010101010,d0 ; MASK data
  MOVE.l  d0,d1                 ; copy into d1
  ASR.l   #1,d1                 ; roll 1 place to the right
  OR.l    d1,d0                 ; OR with original data
  MOVE.l  d0,(a3)+              ; store data
  MOVE.l  d0,36(a3)             ; copy to line below as well
  DBRA    d4,'X2xloop            ; do whole line
  LEA     40(a2),a2             ; adjust bitplane pointers
  LEA     40(a3),a3             ;  to skip a whole line
  DBRA    d5,'X2yloop            ; loop for all lines
  DBRA    d6,'X2bitloop          ; loop for all bitplanes

  MOVEM.l (a7)+,d1-d7/a0-a6     ; restore BLITZ registers
  RTS                           ; EXIT!

  Even
add_value:  Dc.l  1             ; step value for source bitplanes
res_value:  Dc.w  1             ; store for unrez value
res_value2: Dc.w  1             ; fast res_value for dbra use
mytemp:     Dc.w  0

myline: Dc.w %0110110110110110,%1101101101101101,%1011011011011011
        Dc.w %0110110110110110,%1101101101101101,%1011011011011011
        Dc.w %0110110110110110,%1101101101101101,%1011011011011011
        Dc.w %0110110110110110,%1101101101101101,%1011011011011011
        Dc.w %0110110110110110,%1101101101101101,%1011011011011011
        Dc.w %0110110110110110,%1101101101101101,%1011011011011011

myflag: Dc.b 0
Even

;.exit

._AsmZoom
  TST.w   d0
  BEQ     exithere
  TST.w   d1
  BEQ     exithere

  MOVEM.l d1-d7/a0-a6,-(a7)     ; save BLITZ registers

  MOVE.l  source_address,a0
  MOVE.l  dest_address,a1
  MOVE.l  add_source,d4
  MOVE.l  add_dest,d5

  MOVE.w  d0,xzoom_value        ; store zoom_value
  SUBQ.w  #1,xzoom_value
  MOVE.w  d1,yzoom_value2       ; store yzoom
  MOVE.w  d1,yzoom_value        ; store again BUT
  SUBQ.w  #1,yzoom_value        ;  subtract 1 this time
  MOVE.w  d2,height             ; store height AND
  SUBQ.w  #1,height             ;  subtract 1 for dbra
  MOVE.b  5(a0),sbitdepth+1     ; get source bitplane depth
  SUBQ.w  #1,sbitdepth          ;  subtract 1 for dbra
  LEA     8(a0),a0              ; get source's bitplane pointers
  LEA     8(a1),a1              ; get dest's bitplane pointers

  MOVE.w  sbitdepth,d0          ; get bitdepth in d0
  LEA     bit_add(pc),a2        ; source bitplane storage
  LEA     dest_add(pc),a3       ; dest bitplane storage

'store_bitplanes
  MOVE.l  (a0)+,(a2)            ; copy source bitplane address
  ADD.l   d4,(a2)+              ;  AND add offset value
  MOVE.l  (a1)+,(a3)            ; copy dest bitplane address
  ADD.l   d5,(a3)+              ;  AND add offset value
  DBRA    d0,'store_bitplanes   ; loop for all bitplanes

  TST.w   xzoom_value           ; Is xzoom_value=0?
  BNE     'x_over_1             ; if so then check y

  TST.w   yzoom_value           ; only screen copy if
  BEQ     ScreenCopy            ; xzoom & yzoom equal 1
'x_over_1
  MOVE.w  height,yvalue         ; store height in yvalue for use
                                ;  in loop
'yloop:                         ; d6=bitplane loop
  LEA     bit_add(pc),a0        ; d5=xloop
  LEA     dest_add(pc),a6
  MOVE.w  sbitdepth,d6
'bitplane_loop:
  MOVE.w  yvalue,d7
  MOVE.l  (a0),a1               ; a1=source
  MOVE.l  a1,a2                 ; a2=source (corruptable)
  MOVE.l  (a6),a3               ; a3=destination
  MOVE.l  #9,d5                 ; x count for longwords wide
  MOVEQ.l #31,d3                ; first bit to test on line
  MOVEQ.l #31,d1
'xloop:
  MOVE.w  xzoom_value,d4        ; get number of bits to set
  MOVE.l  (a3),d2               ; get destination word
  MOVE.l  (a2),d0
  BTST    d1,d0                 ; test bit of word
  BEQ     'clearbits_loop       ; if not set - branch
'setbits_loop:                  ; SETS bits in dest line
  BSET    d3,d2                 ; set the bit!
  SUBQ.b  #1,d3                 ; decrease bit pointer
  BMI     'setbits_word         ; if negative the get new word
  DBRA    d4,'setbits_loop      ; loop for all bits
  BRA     'next_bit             ; branch to main line loop
'setbits_word:                  ; GETS a new destination word
  MOVE.l  d2,(a3)+              ; move current word into dest
  MOVE.l  (a3),d2               ; get new word
  MOVEQ.l #31,d3                ; reset bit pointer
  SUBQ.b  #1,d5                 ; subtract 1 from # of longwords
  BMI     'done_line            ; exit if we've overflowed the line
  DBRA    d4,'setbits_loop      ; loop for all bits to set
  BRA     'next_bit             ; branch to main line loop

'clearbits_loop:                ; CLEARS bits in dest line
  BCLR    d3,d2
  SUBQ.b  #1,d3
  BMI     'clearbits_word
  DBRA    d4,'clearbits_loop
  BRA     'next_bit
'clearbits_word:
  MOVE.l  d2,(a3)+
  MOVE.l  (a3),d2
  MOVEQ.l #31,d3
  SUBQ.b  #1,d5
  BMI     'done_line
  DBRA    d4,'clearbits_loop

'next_bit:
  MOVE.l  d2,(a3)               ; store dest word
  SUBQ.b  #1,d1                 ; adjust source bit pointer
  BPL     'xloop                ; if positive then skip next
  MOVEQ.l #31,d1                ; else reset pointer &
  ADDQ.l  #4,a2                 ; increase address
  BRA     'xloop                ; loop for whole line
'done_line                      ; COPIES line vertically
  MOVE.w  yzoom_value,d4        ; get zoom_value
  BEQ     'yzoom1
  SUBQ.w  #1,d4                 ; subtract 2 (dbra & current line)
  MOVE.l  (a6),a1               ; get dest bitplane address
  LEA     40(a1),a2             ; add 40 to skip current line
'copy_line:
  SUBQ.w  #1,d7                 ; subtract 1 from height
  BMI     'out_of_screen        ; Height negative? - OVERFLOW
  MOVE.l  (a1)+,(a2)+           ; Copy 40 bytes
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  MOVE.l  (a1)+,(a2)+
  DBRA    d4,'copy_line         ; loop around for all lines
  BRA     'out_of_screen

'yzoom1
  MOVE.l  (a6),a2
  ADD.l   #40,a2
'out_of_screen                  ; ALL Y SCREEN FILLED FOR 1 bitplane
  ADD.l   #40,(a0)+             ; increment source bitplane pointer
  MOVE.l  a2,(a6)+              ; store dest bitplane pointer
  DBRA    d6,'bitplane_loop     ; loop for all bitplanes

  MOVE.w  yzoom_value2,d6       ; get zoom_value
  SUB.w   d6,yvalue             ; decrease yvalue
  BMI     get_out_of_it2         ; yvalue NEGATIVE? - RTS
  BRA     'yloop                ; loop for all lines
get_out_of_it2:
  MOVEM.l (a7)+,d1-d7/a0-a6     ; restore BLITZ registers
exithere:
  RTS                           ; EXIT

;General subroutine to copy one LOREZ bitmap to another
ScreenCopy                      ; copy 1 bitmap to another
  MOVEQ.l #0,d7                 ; clear d7
  MOVE.w  height,d7             ; get height-1

  LEA     bit_add(pc),a0        ; get source pointers
  LEA     dest_add(pc),a1       ; get dest pointers
  MOVE.w  sbitdepth,d6          ; get bitplane depth
'bitloop
  MOVE.l  (a0)+,a2              ; get source bitplane address
  MOVE.l  (a1)+,a3              ; get dest bitplane address
  MOVE.w  d7,d5                 ; copy height into temp
'yloop
  MOVE.l  (a2)+,(a3)+           ; copy data 1
  MOVE.l  (a2)+,(a3)+           ; copy data 2
  MOVE.l  (a2)+,(a3)+           ; copy data 3
  MOVE.l  (a2)+,(a3)+           ; copy data 4
  MOVE.l  (a2)+,(a3)+           ; copy data 5
  MOVE.l  (a2)+,(a3)+           ; copy data 6
  MOVE.l  (a2)+,(a3)+           ; copy data 7
  MOVE.l  (a2)+,(a3)+           ; copy data 8
  MOVE.l  (a2)+,(a3)+           ; copy data 9
  MOVE.l  (a2)+,(a3)+           ; copy data A
  DBRA    d5,'yloop             ; loop for all lines
  DBRA    d6,'bitloop           ; loop for all bitplanes

  MOVEM.l (a7)+,d1-d7/a0-a6     ; save BLITZ registers
  RTS                           ; EXIT!

yzoom_value: Dc.w  1
yzoom_value2:Dc.w  1
xzoom_value: Dc.w  1
;=================================================================
sbitdepth:      Dc.w  0            ; bitplane depth of source
yvalue:         Dc.w  0            ; y counter for loops
height:         Dc.w  0            ; height of bitmap-1
bit_add:        Ds.l  16            ; source bitplane pointers(16)
dest_add:       Ds.l  16            ; dest bitplane pointers(16)
source_address: Dc.l 0
dest_address:   Dc.l 0
add_source:     Dc.l 0
add_dest:       Dc.l 0
;=================================================================

_InitZoomxy:
  MOVE.l    a0,source_address
  MOVE.l    a1,dest_address
  MOVE.l    d2,add_source
  MOVE.l    d3,add_dest
  RTS

_ADDValue:
  MOVE.w    (a0),d0
  MULU.w    d2,d0
  ANDI.l    #$ffff,d1
  ASR.w     #3,d1
  ADD.l     d1,d0
  RTS

version: Dc.b "$VER: FX-Library v1.0 (17.7.1994)",0

