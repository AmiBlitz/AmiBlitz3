optimize 7 ; = 1|2|4
Syntax 2

vers.s = Peek.s(?shortversion)

XINCLUDE "dos.include.bb2"  ; we will use functions from the dos.include
XINCLUDE "useful.include.bb2"

err.l      = False ; indicate that an error has occured
showhelp.l = False ; show the CLI tool's help

; Get the required CLI arguments ...
filename.s = dos_GetNextArg{} ; first read the filename
If filename.s = ""
  NPrint "*** ERROR: No filename specified!"
  err=True
End If

Repeat
  arg.s = dos_GetNextArg{} ; get the next CLI argument
  larg.s = LCase$(arg) ; lower case the option string
  Select larg
    Case "-mystr"  ; the user can specify a string here, spaces must be in quotes
      ;myString = dos_GetNextArg{}
    Case "-h"
      showhelp = True  ; show the help and quit
    Default
      If arg><""
        NPrint "*** ERROR: Unknown option \\22",arg,"\\22 specified!"
        err = True
      End If
  End Select
Until arg = "" ; until we processed all arguments

; Show the help if something went wrong or help was requested
If err><False OR showhelp = True
  NPrint vers
  NPrint "VRun <vbinfile> [options]"
  NPrint "\\n description:"
  NPrint "    Run a V virtual binary file."
  NPrint "\\n    required:"
  NPrint "    <vbinfile>      : V virtual binary file"
  NPrint "\\n    optional:"
  NPrint "    -debug <0|1>    : debug or no debug"
  NPrint "    -h              : show this help"
  End
End If


NEWTYPE.FDFuncInfo68K
numParams.l
lvo.l
reg.b[16]
End NEWTYPE

NEWTYPE.FDLibInfo68K
*libbase.Library
numFuncs.l
End NEWTYPE

NEWTYPE.FDLibData68K
libInfo.FDLibInfo68K
funcInfo.FDFuncInfo68K[1024]
End NEWTYPE

XINCLUDE "file.include.bb2"

#_A0 = 8
#_A1 = 9
#_A2 = 10
#_A3 = 11
#_A4 = 12
#_A5 = 13
#_A6 = 14
#_A7 = 15

#_D0 = 0
#_D1 = 1
#_D2 = 2
#_D3 = 3
#_D4 = 4
#_D5 = 5
#_D6 = 6
#_D7 = 7


Statement CloseLib{libnum.l}
libTable.l    = Peek.l(?_libtable)
libDataP.l    = libTable + libnum*4
libSize.l     = Peek.l(?_libsize)
If libnum<0 OR libnum>=libSize Then Statement Return

*libData.FDLibData68K = Peek.l(libDataP)
If (*libData)
  If (*libData\libInfo\libbase)
    CloseLibrary_ *libData\libInfo\libbase
    *libData\libInfo\libbase = !_NULL
  End If
  FreeVec_ *libData
  Poke.l(libDataP),!_NULL
End If
End Statement

Function.l OpenLib{libnum.l,libname.s,libversion.l}
libTable.l    = Peek.l(?_libtable)
libDataP.l    = libTable + libnum*4
libSize.l     = Peek.l(?_libsize)
If libnum<0 OR libnum>=libSize Then Function Return !_NULL

*libData.FDLibData68K = Peek.l(libDataP)
If *libData
  If *libData\libInfo\libbase Then Function Return *libData\libInfo\libbase
End If

fdname.s         = dos_AddPart{"Blitz3:Sourcecodes/Amiblitz3/AIDE/FD",dos_RemExt{ dos_FilePart{libname}}+"_lib.fd"}
fd_public.l      = True
fd_basename.s    = dos_RemExt{dos_FilePart{libname}}
fd_bias.l        = 30
fd_funccount.l   = 0
*library.Library = !_NULL
fid.l = file_Open{fdname,#file_read}
Dim List func.FDFuncInfo68K(0)

errorcode.l = 0
errorline.l = 0
currentline.l = 0
If fid>=0
  quitme.l = False
  While quitme = False AND file_EOF{fid}=False AND errorcode=0
    lin.s = file_ReadLine{fid} : If lin.s = "" Then quitme = True
    currentline+1
    compos.l = Instr(lin,"*")
    If compos>0 Then lin = Left$(lin,compos-1)
    If Left$(lin.s,2)="##"
      Select LCase$(Mid$(lin.s,3,3))
        Case "bas" : fd_basename = Right$(lin.s,FLen(lin.s)-7)
        Case "bia" : fd_bias     = Vallong(Right$(lin.s,FLen(lin.s)-7))
        Case "pub" : fd_public   = True
        Case "pri" : fd_public   = False
        Case "end" : quitme      = True
        Default
          errorcode = 2
      End Select
    Else
      lin=Replace$(lin," ","")
      pos1.l = Instr(lin,"(")
      pos2.l = Instr(lin,")")
      If pos1>0 AND pos2>0
        name.s  = Left$(lin,pos1-1)
        param.s = Mid$(lin,pos1+1,pos2-pos1-1)
        reg.s   = Right$(lin,FLen(lin)-pos2);: NPrint reg
        pos1.l  = Instr(reg,"(")
        pos2.l  = Instr(reg,")")
        reg     = Right$(reg,FLen(reg)-pos1)
        reg     = Left$(reg,FLen(reg)-1)
        ;NPrint "; Library function "+name+"("+param+")/("+reg+")"
        If AddItem(func())
          While param><""
            pos.l = Instr(param,",")
            If pos<=0 Then thisparam.s = param:param="":Else thisparam=Left$(param,pos-1):param = Right$(param,Len(param)-pos)
            thisparam = Replace$(thisparam," ","")
            If thisparam><""
              ;func()\param[func()\paramcount] = thisparam
              func()\numParams+1
            Else
              param = ""
            End If
          Wend
          For n.l=0 To func()\numParams-1
            pos.l = Instr(reg,",")
            pos2.l = Instr(reg,"/")
            If pos2>0 Then If pos=0 Then pos = pos2: Else pos = Min(pos,pos2)
            If pos<=0
              thisreg.s = reg:reg=""
            Else
              thisreg=Left$(reg,pos-1):reg = Right$(reg,FLen(reg)-pos)
            End If
            ;NPrint "thisreg: ",thisreg," ... ",reg
            Select LCase$(thisreg)
              Case "a0" : func()\reg[n] = #_A0
              Case "a1" : func()\reg[n] = #_A1
              Case "a2" : func()\reg[n] = #_A2
              Case "a3" : func()\reg[n] = #_A3
              Case "a4" : func()\reg[n] = #_A4
              Case "a5" : func()\reg[n] = #_A5
              Case "a6" : func()\reg[n] = #_A6
              Case "a7" : func()\reg[n] = #_A7
              Case "d0" : func()\reg[n] = #_D0
              Case "d1" : func()\reg[n] = #_D1
              Case "d2" : func()\reg[n] = #_D2
              Case "d3" : func()\reg[n] = #_D3
              Case "d4" : func()\reg[n] = #_D4
              Case "d5" : func()\reg[n] = #_D5
              Case "d6" : func()\reg[n] = #_D6
              Case "d7" : func()\reg[n] = #_D7
              Default
                errorcode.l = 3
                n = func()\numParams-1
                errorline = currentline
            End Select
          Next
          func()\lvo = -(fd_bias + fd_funccount*6) : fd_funccount+1
        End If
      End If
    End If
  Wend
  file_Close{fid}
Else
  errorcode = 1
End If
If errorcode = 0
  *libbase.Library = OpenLibrary_ (&libname,libversion)
  If *libbase
    libTable.l    = Peek.l(?_libtable)
    libDataP.l    = libTable + libnum*4
    *libData.FDLibData68K     = AllocVec_(SizeOf.FDLibInfo68K + (SizeOf.FDFuncInfo68K *fd_funccount),#MEMF_CLEAR)
    Poke.l libDataP,*libData
    *libData\libInfo\libbase  = !_NULL
    *libData\libInfo\numFuncs = fd_funccount
    n.l=0
    ResetList func()
    While NextItem(func())
      CopyType func(),*libData\funcInfo[n] : n+1
    Wend
    fidW.l = file_Open{dos_SetExt{fdname,"68k.inc"},#file_forcewrite}
    If fidW>=0
      file_WriteMem{fidW,*libData,SizeOf.FDLibInfo68K + (SizeOf.FDFuncInfo68K*fd_funccount)}
      file_Close{fidW}
    End If
    *libData\libInfo\libbase  = *libbase
    Poke.l libDataP,*libData
  End If
Else
  Select errorcode
    Case 1 : NPrint "ERROR: Unable to open FD file! ",fdname
    Case 2 : NPrint "ERROR: Illegal parameter in FD file!"
    Case 3 : NPrint "ERROR: (line ",errorline,") Illegal register definition in FD file: \\22",thisreg,"\\22"
    Default
      NPrint "ERROR: Unknown error!"
  End Select
End If

Function Return *libbase
End Function

#MAX_INSTR = 256
Dim JMPTable.l(#MAX_INSTR-1)

#_autoconstantnum = 0
JMPTable(#@ID_INVALID)  = ?BREAK
JMPTable(#@ID_END_A)    = ?END_A
JMPTable(#@ID_INIT_A)   = ?INIT_A
JMPTable(#@ID_OPEN)     = ?OPEN
JMPTable(#@ID_CLSE)     = ?CLSE
JMPTable(#@ID_CALL_p)   = ?CALL_p
JMPTable(#@ID_CALL_l)   = ?CALL_l

JMPTable(#@ID_CMP_l)    = ?CMP_l
JMPTable(#@ID_CMP_f)    = ?CMP_f
JMPTable(#@ID_CMP_p)    = ?CMP_p
JMPTable(#@ID_CMP_w)    = ?CMP_w
JMPTable(#@ID_CMP_b)    = ?CMP_b
JMPTable(#@ID_CMP_s)    = ?CMP_s

JMPTable(#@ID_GT_p)     = ?GT_p
JMPTable(#@ID_GT_s)     = ?GT_s
JMPTable(#@ID_GT_f)     = ?GT_f
JMPTable(#@ID_GT_l)     = ?GT_l
JMPTable(#@ID_GT_w)     = ?GT_w
JMPTable(#@ID_GT_b)     = ?GT_b

JMPTable(#@ID_GE_p)     = ?GE_p
JMPTable(#@ID_GE_s)     = ?GE_s
JMPTable(#@ID_GE_f)     = ?GE_f
JMPTable(#@ID_GE_l)     = ?GE_l
JMPTable(#@ID_GE_w)     = ?GE_w
JMPTable(#@ID_GE_b)     = ?GE_b

JMPTable(#@ID_ST_p)     = ?ST_p
JMPTable(#@ID_ST_s)     = ?ST_s
JMPTable(#@ID_ST_f)     = ?ST_f
JMPTable(#@ID_ST_l)     = ?ST_l
JMPTable(#@ID_ST_w)     = ?ST_w
JMPTable(#@ID_ST_b)     = ?ST_b

JMPTable(#@ID_SE_p)     = ?SE_p
JMPTable(#@ID_SE_s)     = ?SE_s
JMPTable(#@ID_SE_f)     = ?SE_f
JMPTable(#@ID_SE_l)     = ?SE_l
JMPTable(#@ID_SE_w)     = ?SE_w
JMPTable(#@ID_SE_b)     = ?SE_b

JMPTable(#@ID_NE_p)     = ?NE_p
JMPTable(#@ID_NE_s)     = ?NE_s
JMPTable(#@ID_NE_f)     = ?NE_f
JMPTable(#@ID_NE_l)     = ?NE_l
JMPTable(#@ID_NE_w)     = ?NE_w
JMPTable(#@ID_NE_b)     = ?NE_b

JMPTable(#@ID_NOT_l)    = ?NOT_l
JMPTable(#@ID_NOT_w)    = ?NOT_w
JMPTable(#@ID_NOT_b)    = ?NOT_b

JMPTable(#@ID_AND_l)    = ?AND_l
JMPTable(#@ID_AND_w)    = ?AND_w
JMPTable(#@ID_AND_b)    = ?AND_b

JMPTable(#@ID_OR_l )    = ?OR_l
JMPTable(#@ID_OR_w )    = ?OR_w
JMPTable(#@ID_OR_b )    = ?OR_b

JMPTable(#@ID_XOR_l)    = ?XOR_l
JMPTable(#@ID_XOR_w)    = ?XOR_w
JMPTable(#@ID_XOR_b)    = ?XOR_b

JMPTable(#@ID_LSR_l)    = ?LSR_l
JMPTable(#@ID_ASR_l)    = ?ASR_l
JMPTable(#@ID_LSL_l)    = ?LSL_l
JMPTable(#@ID_LSR_w)    = ?LSR_w
JMPTable(#@ID_ASR_w)    = ?ASR_w
JMPTable(#@ID_LSL_w)    = ?LSL_w
JMPTable(#@ID_LSR_b)    = ?LSR_b
JMPTable(#@ID_ASR_b)    = ?ASR_b
JMPTable(#@ID_LSL_b)    = ?LSL_b

JMPTable(#@ID_NEG_f)    = ?NEG_f
JMPTable(#@ID_NEG_l)    = ?NEG_l
JMPTable(#@ID_NEG_w)    = ?NEG_w
JMPTable(#@ID_NEG_b)    = ?NEG_b

JMPTable(#@ID_ADD_p)    = ?ADD_p
JMPTable(#@ID_ADD_s)    = ?ADD_s
JMPTable(#@ID_ADD_f)    = ?ADD_f
JMPTable(#@ID_ADD_l)    = ?ADD_l
JMPTable(#@ID_ADD_w)    = ?ADD_w
JMPTable(#@ID_ADD_b)    = ?ADD_b

JMPTable(#@ID_SUB_p)    = ?SUB_p
JMPTable(#@ID_SUB_f)    = ?SUB_f
JMPTable(#@ID_SUB_l)    = ?SUB_l
JMPTable(#@ID_SUB_w)    = ?SUB_w
JMPTable(#@ID_SUB_b)    = ?SUB_b

JMPTable(#@ID_MUL_f)    = ?MUL_f
JMPTable(#@ID_MUL_l)    = ?MUL_l
JMPTable(#@ID_MUL_w)    = ?MUL_w
JMPTable(#@ID_MUL_b)    = ?MUL_b

JMPTable(#@ID_DIV_f)    = ?DIV_f
JMPTable(#@ID_DIV_l)    = ?DIV_l
JMPTable(#@ID_DIV_w)    = ?DIV_w
JMPTable(#@ID_DIV_b)    = ?DIV_b

JMPTable(#@ID_MOD_f)    = ?MOD_f
JMPTable(#@ID_MOD_l)    = ?MOD_l
JMPTable(#@ID_MOD_w)    = ?MOD_w
JMPTable(#@ID_MOD_b)    = ?MOD_b

JMPTable(#@ID_POW_f)    = ?POW_f
JMPTable(#@ID_POW_l)    = ?POW_l
JMPTable(#@ID_POW_w)    = ?POW_w
JMPTable(#@ID_POW_b)    = ?POW_b

JMPTable(#@ID_LOG_f)    = ?LOG_f
JMPTable(#@ID_SIN_f)    = ?SIN_f
JMPTable(#@ID_COS_f)    = ?COS_f
JMPTable(#@ID_TAN_f)    = ?TAN_f
JMPTable(#@ID_ASIN_f)   = ?ASIN_f
JMPTable(#@ID_ACOS_f)   = ?ACOS_f
JMPTable(#@ID_ATAN_f)   = ?ATAN_f

JMPTable(#@ID_LEA_p)    = ?LEA_p

JMPTable(#@ID_PUSH_p)   = ?PUSH_p
JMPTable(#@ID_PUSH_s)   = ?PUSH_s
JMPTable(#@ID_PUSH_f)   = ?PUSH_f
JMPTable(#@ID_PUSH_l)   = ?PUSH_l
JMPTable(#@ID_PUSH_w)   = ?PUSH_l
JMPTable(#@ID_PUSH_b)   = ?PUSH_b

JMPTable(#@ID_PUSH_VAR_p) = ?PUSH_VAR_p
JMPTable(#@ID_PUSH_VAR_s) = ?PUSH_VAR_s
JMPTable(#@ID_PUSH_VAR_f) = ?PUSH_VAR_f
JMPTable(#@ID_PUSH_VAR_l) = ?PUSH_VAR_l
JMPTable(#@ID_PUSH_VAR_w) = ?PUSH_VAR_w
JMPTable(#@ID_PUSH_VAR_b) = ?PUSH_VAR_b

JMPTable(#@ID_POP_VAR_p)    = ?POP_VAR_p
;JMPTable(#@ID_POP_s)    = ?POP_VAR_s
JMPTable(#@ID_POP_VAR_f)    = ?POP_VAR_f
JMPTable(#@ID_POP_VAR_l)    = ?POP_VAR_l
JMPTable(#@ID_POP_VAR_w)    = ?POP_VAR_w
JMPTable(#@ID_POP_VAR_b)    = ?POP_VAR_b

JMPTable(#@ID_POP_p)    = ?POP_p
;JMPTable(#@ID_POP_s)    = ?POP_s
JMPTable(#@ID_POP_f)    = ?POP_f
JMPTable(#@ID_POP_l)    = ?POP_l
JMPTable(#@ID_POP_w)    = ?POP_w
JMPTable(#@ID_POP_b)    = ?POP_b

JMPTable(#@ID_READ_p)   = ?READ_p
;JMPTable(#@ID_READ_s)   = ?READ_s
JMPTable(#@ID_READ_f)   = ?READ_f
JMPTable(#@ID_READ_l)   = ?READ_l
JMPTable(#@ID_READ_w)   = ?READ_w
JMPTable(#@ID_READ_b)   = ?READ_b

JMPTable(#@ID_BOOL_p)   = ?BOOL_p
;JMPTable(#@ID_BOOL_s)   = ?BOOL_s
JMPTable(#@ID_BOOL_f)   = ?BOOL_f
JMPTable(#@ID_BOOL_l)   = ?BOOL_l
JMPTable(#@ID_BOOL_w)   = ?BOOL_w
JMPTable(#@ID_BOOL_b)   = ?BOOL_b

JMPTable(#@ID_BYTE_p)   = ?BYTE_p
;JMPTable(#@ID_BYTE_s)   = ?BYTE_s
JMPTable(#@ID_BYTE_f)   = ?BYTE_f
JMPTable(#@ID_BYTE_l)   = ?BYTE_l
JMPTable(#@ID_BYTE_w)   = ?BYTE_w

JMPTable(#@ID_LONG_p)   = ?LONG_p
;JMPTable(#@ID_LONG_s)   = ?LONG_s
JMPTable(#@ID_LONG_f)   = ?LONG_f
JMPTable(#@ID_LONG_w)   = ?LONG_w
JMPTable(#@ID_LONG_b)   = ?LONG_b

;JMPTable(#@ID_PTR_s)    = ?PTR_s
JMPTable(#@ID_PTR_f)    = ?PTR_f
JMPTable(#@ID_PTR_l)    = ?PTR_l
JMPTable(#@ID_PTR_w)    = ?PTR_w
JMPTable(#@ID_PTR_b)    = ?PTR_b

JMPTable(#@ID_FLT_p)    = ?FLT_p
;JMPTable(#@ID_FLT_s)    = ?FLT_s
JMPTable(#@ID_FLT_l)    = ?FLT_l
JMPTable(#@ID_FLT_w)    = ?FLT_w
JMPTable(#@ID_FLT_b)    = ?FLT_b

;JMPTable(#@ID_STR_p)    = ?STR_p
;JMPTable(#@ID_STR_f)    = ?STR_f
;JMPTable(#@ID_STR_l)    = ?STR_l
;JMPTable(#@ID_STR_w)    = ?STR_w
;JMPTable(#@ID_STR_b)    = ?STR_b

JMPTable(#@ID_WORD_p)   = ?WORD_p
;JMPTable(#@ID_WORD_s)   = ?WORD_s
JMPTable(#@ID_WORD_f)   = ?WORD_f
JMPTable(#@ID_WORD_l)   = ?WORD_l
JMPTable(#@ID_WORD_b)   = ?WORD_b

JMPTable(#@ID_COUT_l)   = ?COUT_l
JMPTable(#@ID_COUT_f)   = ?COUT_f
JMPTable(#@ID_COUT_s)   = ?COUT_s
JMPTable(#@ID_COUT_B)   = ?COUT_B



vcodebase.l  = AllocVec_(4096,#MEMF_CLEAR)
vstacksize.l = 16000
vstackbase.l = AllocVec_(vstacksize,#MEMF_ANY)
vexit.l      = 0
vretcode.l   = 0
vprog.l      = vcodebase

Poke.l ?_vjt,&JMPTable(0)
Poke.l ?_vvbtable,!_NULL
Poke.l ?_vsp,vstackbase + vstacksize
Poke.l ?_vpc,vcodebase
MOVE.l a5,_basic_varbase

Macro CODE
Poke.w vprog,#ID_`1 LSL 2 : vprog+2
End Macro

Macro DATA_l
Poke.l vprog,`1 : vprog+4
End Macro

Macro DATA_f
Poke.f vprog,`1 : vprog+4
End Macro
 
Macro DATA_w
Poke.w vprog,`1 : vprog+2
End Macro
 
Macro DATA_b
Poke.b vprog,`1 : vprog+1
End Macro

Macro DATA_s
Poke.l vprog,Len(`1)  : vprog + 4
Poke.s vprog,`1       : vprog +Len(`1) +1
End Macro

Macro VSP ; virtual stack pointer
A3
End Macro

Macro VPC ; virtual program counter
A2
End Macro

Macro VJT ; virtual jump table
A4
End Macro

Macro VVB ; virtual var base
A6
End Macro

Macro BASICVB ; virtual var base
A5
End Macro

Macro deinitV
MOVE.l !VSP,_vsp
MOVE.l !VPC,_vpc
MOVE.l _basic_varbase,!BASICVB
End Macro

Macro initV
MOVE.l _vsp,!VSP
MOVE.l _vpc,!VPC
MOVE.l _vjt,!VJT
MOVE.l _vvbtable,!VVB
End Macro

Macro B
b
End Macro

;/* small test program ... */
!CODE{INIT_A}
!DATA_l{4096} ; global variable base
!DATA_l{10} ; libbase table

!CODE{PUSH_s} : !DATA_s{"dos.library"}
!CODE{PUSH_l} : !DATA_l{31}
!CODE{OPEN}   : !DATA_l{0}
!CODE{COUT_B}

!CODE{PUSH_s} : !DATA_s{"intuition.library"}
!CODE{PUSH_l} : !DATA_l{31}
!CODE{OPEN}   : !DATA_l{1}
!CODE{COUT_B}

!CODE{PUSH_s} : !DATA_s{"graphics.library"}
!CODE{PUSH_l} : !DATA_l{31}
!CODE{OPEN}   : !DATA_l{2}
!CODE{COUT_B}

!CODE{PUSH_s} : !DATA_s{"exec.library"}
!CODE{PUSH_l} : !DATA_l{31}
!CODE{OPEN}   : !DATA_l{3}
!CODE{COUT_B}

!CODE{PUSH_s}     : !DATA_s{"Ram:test4"}
!CODE{PUSH_l}     : !DATA_l{#MODE_NEWFILE}
!CODE{CALL_p}     : !DATA_l{0} : !DATA_l{0}
!CODE{POP_VAR_l}  : !DATA_l{12}

!CODE{PUSH_VAR_l} : !DATA_l{12}
!CODE{COUT_l}

!CODE{PUSH_VAR_l} : !DATA_l{12}
!CODE{CALL_p} : !DATA_l{0} : !DATA_l{1}
!CODE{POP_p}

!CODE{PUSH_l} : !DATA_l{12345}
!CODE{END_A}

!initV
ProgramLoop:
  !deinitV
  NPrint "Stack: ",vstacksize-(Peek.l(?_vsp)-vstackbase )
  !initV
  MOVE.w (!VPC)+,D0      ; get instruction ID => D0
  MOVE.l 0(!VJT,D0),A0
  ;JMP 0(!VJT,D0)
  JMP (A0)               ; ...and jump!

ProgramError:
  !deinitV
  vretcode=-2

ProgramDone:
  !deinitV

If vcodebase  Then FreeVec_ vcodebase  : vcodebase  = !_NULL
If vstackbase Then FreeVec_ vstackbase : vstackbase = !_NULL
NPrint "Program ended with code ",vretcode
End

;/* helper variables for basic fallback routines */
DEFTYPE.l _basic_x_p,_basic_y_p,_basic_r_p
DEFTYPE.l _basic_x_l,_basic_y_l,_basic_r_l
DEFTYPE.f _basic_x_f,_basic_y_f,_basic_r_f
DEFTYPE.w _basic_x_w,_basic_y_w,_basic_r_w
DEFTYPE.b _basic_x_b,_basic_y_b,_basic_r_b
DEFTYPE.s _basic_x_s,_basic_y_s,_basic_r_s
DEFTYPE.b _basic_x_B,_basic_y_B,_basic_r_B

DEFTYPE.l libnum,funcnum

._basic_varbase: Dc.l 0
._vvbtable:  Dc.l 0
._vvbsize:   Dc.l 0
._vsp:       Dc.l 0
._vpc:       Dc.l 0
._vjt:       Dc.l 0
._strbuff:   Dc.l 0
._strsize:   Dc.l 0
._execbase:  Dc.l 0
._libtable:  Dc.l 0
._libsize:   Dc.l 0

._registers
._reg_D0:    Dc.l 0
._reg_D1:    Dc.l 0
._reg_D2:    Dc.l 0
._reg_D3:    Dc.l 0
._reg_D4:    Dc.l 0
._reg_D5:    Dc.l 0
._reg_D6:    Dc.l 0
._reg_D7:    Dc.l 0

._reg_A0:    Dc.l 0
._reg_A1:    Dc.l 0
._reg_A2:    Dc.l 0
._reg_A3:    Dc.l 0
._reg_A4:    Dc.l 0
._reg_A5:    Dc.l 0
._reg_A6:    Dc.l 0
._reg_A7:    Dc.l 0


.BREAK : MOVE.l #-1,vretcode@(a5) : JMP ProgramDone

.INIT_A ;   Init_A    (heapsize.l)                | init the program
      ; /* get the exec base */
      MOVE.l 4,_execbase

      ; /* fetch the global base size */
      MOVE.l (!VPC)+,_vvbsize
      MOVE.l (!VPC)+,_libsize
      ; /* allocate the global variable base */
      !deinitV
      vvbsize.l = Peek.l(?_vvbsize)
      If vvbsize>0
        vvbtable.l = AllocVec_(vvbsize,#MEMF_CLEAR)
        Poke.l ?_vvbtable,vvbtable
      End If

      libsize.l = Peek.l(?_libsize)
      If libsize>0
        libtable.l = AllocVec_(libsize*4,#MEMF_CLEAR)
        Poke.l ?_libtable,libtable
      End If

      !initV
      JMP ProgramLoop

.END_A  ;   End    (c.l)                | End the program
      MOVE.l (!VSP)+,vretcode@(a5)
      !deinitV
      vvbtable.l = Peek.l(?_vvbtable)
      vvbsize.l  = Peek.l(?_vvbsize)
      libtable.l = Peek.l(?_libtable)
      libsize.l  = Peek.l(?_libsize)

      If vvbtable Then FreeVec_ vvbtable : Poke.l ?_vvbtable,!_NULL

      If libtable  ; close all libraries and free memory
        For libnum.l = 0 To libsize-1
          CloseLib{libnum}
        Next
        FreeVec_ libtable : Poke.l ?_libtable,!_NULL
      End If

      !initV
      JMP ProgramDone

.OPEN
      MOVE.l (!VPC)+,libnum@(a5)
      MOVE.l (!VSP)+,_basic_x_l@(a5) ; version
      MOVE.l (!VSP)+,_basic_x_p@(a5) ; name
      !deinitV
      libname.s = Peeks$(_basic_x_p,Peek.l(_basic_x_p-4))
      libversion.l = _basic_x_l
      *libbase.Library = OpenLib{libnum,libname,libversion} ; OpenLibrary_ (&libname,libversion)
      If *libbase Then _basic_r_B = True:Else _basic_r_B = False
      !initV
      MOVE.!B _basic_r_B@(a5),-(!VSP)
      JMP ProgramLoop

.CLSE
      MOVE.l (!VSP)+,libnum@(a5)
      !deinitV
      CloseLib{libnum}
      !initV
      JMP ProgramLoop

.CALL_p ;   FUNC.p lib\func => r.p      | Call an external library Function with Return Type Pointer
.CALL_l ;   FUNC.l lib\func => r.l      | Call an external library Function with Return Type long
  ; get lib and func
  MOVE.l (!VPC)+,libnum@(a5)
  MOVE.l (!VPC)+,funcnum@(a5)
  !deinitV
  libTable.l    = Peek.l(?_libtable)
  libDataP.l    = libTable + libnum*4
  libSize.l     = Peek.l(?_libsize)
;  If libnum<0 OR libnum>=libSize
;  If funcum<0 OR funcnum>=*libData\libInfo\numFuncs

  *libData.FDLibData68K = Peek.l(libDataP)
  *func.FDFuncInfo68K = *libData\funcInfo[funcnum]
  offset.l  = *func\lvo
  param.l = 0
  NPrint "Call ",libnum,"/",funcnum,": ",*func\numParams," params..."
  For n.l = 0 To *func\numParams-1
    pos.l = *func\numParams-n-1
    reg.l = *func\reg[pos]
    !initV
    MOVE.l (!VSP)+,param@(a5)
    !deinitV
    Poke.l ?_registers+reg*4,param
  Next
  jmpaddr.l = offset + *libData\libInfo\libbase
  MOVE.l libbase@(a5),_reg_A6
  MOVE.l jmpaddr@(a5),_reg_A5

  MOVE.l _reg_D0,d0
  MOVE.l _reg_D1,d1
  MOVE.l _reg_D2,d2
  MOVE.l _reg_D3,d3
  MOVE.l _reg_D4,d4
  MOVE.l _reg_D5,d5
  MOVE.l _reg_D6,d6
  MOVE.l _reg_D7,d7

  MOVE.l _reg_A0,A0
  MOVE.l _reg_A1,A1
  MOVE.l _reg_A2,A2
  MOVE.l _reg_A3,A3
  MOVE.l _reg_A4,A4
  MOVE.l _reg_A5,A5
  MOVE.l _reg_A6,A6
;  MOVE.l _reg_A7,A7 ; stack pointer !
  JSR 0(a5)

  !initV
  MOVE.l D0,-(!VSP)
  JMP ProgramLoop
;   FUNC.w lib\func => r.w      | Call an external library Function with Return Type Word
;   FUNC.b lib\func => r.b      | Call an external library Function with Return Type byte
;   FUNC.f lib\func => r.f      | Call an external library Function with Return Type float
;   FUNC.s lib\func => r.s      | Call an external library Function with Return Type string
;   FUNC.v lib\func             | Call an external library Statement


.CMP_f ;  CMP.f  (x.f, y.f) => r.B    | True If x is equal To y, False otherwise
.CMP_p ;  CMP.p  (x.p, y.p) => r.B    | True If x is equal To y, False otherwise
.CMP_l ;  CMP.l  (x.l, y.l) => r.B    | True If x is equal To y, False otherwise
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1
      CMP.l D0,D1  : BEQ 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.CMP_w ;  CMP.w  (x.w, y.w) => r.B    | True If x is equal To y, False otherwise
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      CMP.w D0,D1  : BEQ 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.CMP_b ;  CMP.b  (x.b, y.b) => r.B    | True If x is equal To y, False otherwise
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1
      CMP.b D0,D1  : BEQ 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.CMP_s ;  CMP.s  (x.s, y.s) => r.B    | True If x is equal To y, False otherwise
      MOVE.l (!VSP)+,_basic_x_p@(A5) : MOVE.l (!VSP)+,_basic_y_p@(A5)
      !deinitV
      _basic_x_s = Peek.s(_basic_x_p)
      _basic_y_s = Peek.s(_basic_y_p)
      _basic_r_B = _basic_x_s=_basic_y_s
      !initV
      MOVE.!B _basic_r_B@(a5),-(!VSP)
      JMP ProgramLoop

.GT_p ;  GT.p   (x.p, y.p) => r.B    | True If x is greater than y, False otherwise
.GT_l ;  GT.l   (x.l, y.l) => r.B    | True If x is greater than y, False otherwise
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1
      CMP.l D0,D1 : BGT 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.GT_w ;  GT.w   (x.w, y.w) => r.B    | True If x is greater than y, False otherwise
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      CMP.w D0,D1 : BGT 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.GT_b ;  GT.b   (x.b, y.b) => r.B    | True If x is greater than y, False otherwise
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1
      CMP.b D0,D1 : BGT 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.GT_f ;  GT.f   (x.f, y.f) => r.B    | True If x is greater than y, False otherwise
      MOVE.l (!VSP)+,_basic_x_f@(A5) : MOVE.l (!VSP)+,_basic_y_f@(A5)
      !deinitV : _basic_r_B = _basic_x_f>_basic_y_f : !initV
      MOVE.!B _basic_r_B@(a5),-(!VSP) : JMP ProgramLoop
.GT_s ;  GT.s   (x.s, y.s) => r.B    | True If x is greater than y, False otherwise
      MOVE.l (!VSP)+,_basic_x_p@(A5) : MOVE.l (!VSP)+,_basic_y_p@(A5)
      !deinitV
      _basic_x_s = Peek.s(_basic_x_p)
      _basic_y_s = Peek.s(_basic_y_p)
      _basic_r_b = _basic_x_s>_basic_y_s
      !initV
      MOVE.!B _basic_r_b@(a5),-(!VSP) : JMP ProgramLoop

.GE_p ;  GE.p   (x.p, y.p) => r.B    | True If x is greater than OR equal y, False otherwise
.GE_l ;  GE.l   (x.l, y.l) => r.B    | True If x is greater than OR equal y, False otherwise
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1
      CMP.l D0,D1 : BGE 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.GE_w;  GE.w   (x.w, y.w) => r.B    | True If x is greater than OR equal y, False otherwise
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      CMP.w D0,D1 : BGE 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.GE_b ;  GE.b   (x.b, y.b) => r.B    | True If x is greater than OR equal y, False otherwise
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1
      CMP.b D0,D1 : BGE 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.GE_f ;  GE.f   (x.f, y.f) => r.B    | True If x is greater than OR equal y, False otherwise
      MOVE.l (!VSP)+,_basic_x_f@(A5) : MOVE.l (!VSP)+,_basic_y_f@(A5)
      !deinitV : _basic_r_B = _basic_x_f>=_basic_y_f : !initV
      MOVE.!B _basic_r_B@(a5),-(!VSP) : JMP ProgramLoop
.GE_s ;  GE.s   (x.s, y.s) => r.B    | True If x is greater than OR equal y, False otherwise
      MOVE.l (!VSP)+,_basic_x_p@(A5) : MOVE.l (!VSP)+,_basic_y_p@(A5)
      !deinitV
      _basic_x_s = Peek.s(_basic_x_p)
      _basic_y_s = Peek.s(_basic_y_p)
      _basic_r_B = _basic_x_s>=_basic_y_s
      !initV
      MOVE.!B _basic_r_B@(a5),-(!VSP) : JMP ProgramLoop

.ST_p ;  ST.p   (x.p, y.p) => r.B    | True If x is smaller than y, False otherwise
.ST_l ;  ST.l   (x.l, y.l) => r.B    | True If x is smaller than y, False otherwise
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1
      CMP.l D0,D1 : BLT 'ok
      MOVE.b #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.b #1,-(!VSP) : JMP ProgramLoop
.ST_w ;  ST.w   (x.w, y.w) => r.B    | True If x is smaller than y, False otherwise
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      CMP.w D0,D1 : BLT 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.ST_b ;ST_b;  ST.b   (x.b, y.b) => r.B    | True If x is smaller than y, False otherwise
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1
      CMP.b D0,D1 : BLT 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.ST_f ;  ST.f   (x.f, y.f) => r.B    | True If x is smaller than y, False otherwise
      MOVE.l (!VSP)+,_basic_x_f@(A5) : MOVE.l (!VSP)+,_basic_y_f@(A5)
      !deinitV : _basic_r_B = _basic_x_f<_basic_y_f : !initV
      MOVE.!B _basic_r_B@(a5),-(!VSP) : JMP ProgramLoop
.ST_s ;  ST.s   (x.s, y.s) => r.B    | True If x is smaller than y, False otherwise
      MOVE.l (!VSP)+,_basic_x_p@(A5) : MOVE.l (!VSP)+,_basic_y_p@(A5)
      !deinitV
      _basic_x_s = Peek.s(_basic_x_p)
      _basic_y_s = Peek.s(_basic_y_p)
      _basic_r_B = _basic_x_s<_basic_y_s
      !initV
      MOVE.!B _basic_r_B@(a5),-(!VSP) : JMP ProgramLoop

.SE_p ;  SE.p   (x.p, y.p) => r.B    | True If x is smaller than OR equal y, False otherwise
.SE_l ;  SE.l   (x.l, y.l) => r.B    | True If x is smaller than OR equal y, False otherwise
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1
      CMP.l D0,D1 : BLE 'ok
      MOVE.b #0,-(!VSP) : JMP ProgramLoop
'ok : MOVE.b #1,-(!VSP) : JMP ProgramLoop
.SE_w ;  SE.w   (x.w, y.w) => r.B    | True If x is smaller than OR equal y, False otherwise
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      CMP.w D0,D1 : BLE 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.SE_b ;  SE.b   (x.b, y.b) => r.B    | True If x is smaller than OR equal y, False otherwise
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1
      CMP.b D0,D1 : BLE 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.SE_f ;  SE.f   (x.f, y.f) => r.B    | True If x is smaller than OR equal y, False otherwise
      MOVE.l (!VSP)+,_basic_x_f@(A5) : MOVE.l (!VSP)+,_basic_y_f@(A5)
      !deinitV : _basic_r_B = _basic_x_f<=_basic_y_f : !initV
      MOVE.!B _basic_r_B@(a5),-(!VSP) : JMP ProgramLoop
.SE_s ;  SE.s   (x.s, y.s) => r.B    | True If x is smaller than OR equal y, False otherwise
      MOVE.l (!VSP)+,_basic_x_p@(A5) : MOVE.l (!VSP)+,_basic_y_p@(A5)
      !deinitV
      _basic_x_s = Peek.s(_basic_x_p)
      _basic_y_s = Peek.s(_basic_y_p)
      _basic_r_B = _basic_x_s<=_basic_y_s
      !initV
      MOVE.!B _basic_r_B@(a5),-(!VSP) : JMP ProgramLoop

.NE_f ;  NE.f   (x.f, y.f) => r.B    | True If x is NOT equal To y, False otherwise
.NE_p ;  NE.p   (x.p, y.p) => r.B    | True If x is NOT equal To y, False otherwise
.NE_l ;  NE.l   (x.l, y.l) => r.B    | True If x is NOT equal To y, False otherwise
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1
      CMP.l D0,D1 : BNE 'ok
      MOVE.b #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.b #1,-(!VSP) : JMP ProgramLoop
.NE_w ;  NE.w   (x.w, y.w) => r.B    | True If x is NOT equal To y, False otherwise
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      CMP.w D0,D1 : BNE 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.NE_b ;  NE.b   (x.b, y.b) => r.B    | True If x is NOT equal To y, False otherwise
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1
      CMP.b D0,D1 : BNE 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.NE_s ;  NE.s   (x.s, y.s) => r.B    | True If x is NOT equal To y, False otherwise
      MOVE.l (!VSP)+,_basic_x_p@(A5) : MOVE.l (!VSP)+,_basic_y_p@(A5)
      !deinitV
      _basic_x_s = Peek.s(_basic_x_p)
      _basic_y_s = Peek.s(_basic_y_p)
      _basic_r_B = _basic_x_s><_basic_y_s
      !initV
      MOVE.!B _basic_r_B@(a5),-(!VSP) : JMP ProgramLoop

.NOT_l ;  NOT.l  (x.l) => r.l         | bitwise NOT
      MOVE.l (!VSP)+,D0 : NOT.l D0
      MOVE.l D0,-(!VSP) : JMP ProgramLoop
.NOT_w ;  NOT.w  (x.w) => r.w         | bitwise NOT
      MOVE.w (!VSP)+,D0 : NOT.w D0
      MOVE.w D0,-(!VSP) : JMP ProgramLoop
.NOT_b ;  NOT.b  (x.b) => r.b         | bitwise NOT
      MOVE.b (!VSP)+,D0 : NOT.b D0
      MOVE.b D0,-(!VSP) : JMP ProgramLoop

.AND_l ;  AND.l  (x.l, y.l) => r.l    | bitwise AND
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1
      AND.l D0,D1 : MOVE.l D1,-(!VSP) : JMP ProgramLoop
.AND_w ;  AND.w  (x.w, y.w) => r.w    | bitwise AND
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      AND.w D0,D1 : MOVE.w D1,-(!VSP) : JMP ProgramLoop
.AND_b ;  AND.b  (x.b, y.b) => r.b    | bitwise AND
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1
      AND.b D0,D1 : MOVE.b D1,-(!VSP) : JMP ProgramLoop

.OR_l ;  OR.l   (x.l, y.l) => r.l    | bitwise OR
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1
      OR.l D0,D1 : MOVE.l D1,-(!VSP) : JMP ProgramLoop
.OR_w ;  OR.w   (x.w, y.w) => r.w    | bitwise OR
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      OR.w D0,D1 : MOVE.w D1,-(!VSP) : JMP ProgramLoop
.OR_b ;  OR.b   (x.b, y.b) => r.b    | bitwise OR
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1
      OR.b D0,D1 : MOVE.b D1,-(!VSP) : JMP ProgramLoop

.XOR_l ;  Xor.l  (x.l, y.l) => r.l    | bitwise Xor ;  (x && !y) || (!x && y)
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1
      MOVE.l D0,D2 : NOT.l D2
      MOVE.l D1,D3 : NOT.l D1
      AND.l D0,D1
      AND.l D2,D3
      OR.l D1,D3
      MOVE.l D3,-(!VSP)
      JMP ProgramLoop
.XOR_w ;  Xor.w  (x.w, y.w) => r.w    | bitwise Xor
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      MOVE.w D0,D2 : NOT.w D2
      MOVE.w D1,D3 : NOT.w D1
      AND.w D0,D1
      AND.w D2,D3
      OR.w D1,D3
      MOVE.w D3,-(!VSP)
      JMP ProgramLoop
.XOR_b ;  Xor.b  (x.b, y.b) => r.b    | bitwise Xor
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1
      MOVE.b D0,D2 : NOT.b D2
      MOVE.b D1,D3 : NOT.b D1
      AND.b D0,D1
      AND.b D2,D3
      OR.b D1,D3
      MOVE.b D3,-(!VSP)
      JMP ProgramLoop

.LSR_l ;  LSR.l  (x.l,n.w) => r.l     | shift down x about y bits (sign respected)
      MOVE.l (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      LSR.l D1,D0 : MOVE.l D0,-(!VSP) : JMP ProgramLoop
.LSR_w ;  LSR.w  (x.w,n.w) => r.w     | shift down x about y bits (sign respected)
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      LSR.w D1,D0 : MOVE.w D0,-(!VSP) : JMP ProgramLoop
.LSR_b ;  LSR.b  (x.b,n.w) => r.b     | shift down x about y bits (sign respected)
      MOVE.b (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      LSR.b D1,D0 : MOVE.b D0,-(!VSP) : JMP ProgramLoop

.ASR_l ;  ASR.l  (x.l, n.w) => r.l    | forced unsigned shift down
      MOVE.l (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      ASR.l D1,D0 : MOVE.l D0,-(!VSP) : JMP ProgramLoop
.ASR_w ;  ASR.w  (x.w, n.w) => r.w    | forced unsigned shift down
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      ASR.w D1,D0 : MOVE.w D0,-(!VSP) : JMP ProgramLoop
.ASR_b ;  ASR.b  (x.b, n.w) => r.b    | forced unsigned shift down
      MOVE.b (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      ASR.b D1,D0 : MOVE.b D0,-(!VSP) : JMP ProgramLoop

.LSL_l ;  LSL.l  (x.l, n.w) => r.l    | shift up x about y bits
      MOVE.l (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      LSL.l D1,D0 : MOVE.l D0,-(!VSP) : JMP ProgramLoop
.LSL_w ;  LSL.w  (x.w, n.w) => r.w    | shift up x about y bits
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      LSL.w D1,D0 : MOVE.w D0,-(!VSP) : JMP ProgramLoop
.LSL_b ;  LSL.b  (x.b, n.w) => r.b    | shift up x about y bits
      MOVE.b (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      LSL.b D1,D0 : MOVE.b D0,-(!VSP) : JMP ProgramLoop

.NEG_l ;  NEG.l  (x.l) => r.l         | negation of x
      MOVE.l (!VSP)+,D0 : NEG.l D0 : MOVE.l D0,-(!VSP) : JMP ProgramLoop
.NEG_w;  NEG.w  (x.w) => r.w         | negation of x
      MOVE.s (!VSP)+,D0 : NEG.w D0 : MOVE.w D0,-(!VSP) : JMP ProgramLoop
.NEG_b;  NEG.b  (x.b) => r.b         | negation of x
      MOVE.b (!VSP)+,D0 : NEG.b D0 : MOVE.b D0,-(!VSP) : JMP ProgramLoop
.NEG_f;  NEG.f  (x.f) => r.f         | negation of x
      MOVE.l (!VSP)+,_basic_x_f@(a5)
      !deinitV : _basic_r_f = - _basic_x_f : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

.ADD_p ;   ADD.p  (x.p, y.l) => r.p    | ADD x AND y
.ADD_l ;   ADD.l  (x.l, y.l) => r.l    | ADD x AND y
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1 : ADD.l D1,D0 : MOVE.l D0,-(!VSP) : JMP ProgramLoop
.ADD_w ;   ADD.w  (x.w, y.w) => r.w    | ADD x AND y
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1 : ADD.w D1,D0 : MOVE.w D0,-(!VSP) : JMP ProgramLoop
.ADD_b ;   ADD.b  (x.b, y.b) => r.b    | ADD x AND y
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1 : ADD.b D1,D0 : MOVE.b D0,-(!VSP) : JMP ProgramLoop
.ADD_f ;   ADD.f  (x.f, y.f) => r.f    | ADD x AND y
      MOVE.l (!VSP)+,_basic_x_f@(a5) : MOVE.l (!VSP)+,_basic_y_f@(a5)
      !deinitV : _basic_r_f = _basic_x_f + _basic_y_f : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop
.ADD_s ;   ADD.s  (x.s, y.s) => r.s    | ADD x AND y
      MOVE.l (!VSP)+,_basic_x_p@(a5) : MOVE.l (!VSP)+,_basic_y_p@(a5)
      !deinitV
      _basic_x_s = Peek.s(_basic_x_p)
      _basic_y_s = Peek.s(_basic_y_p)
      _basic_r_s = _basic_x_s + _basic_y_s
      _basic_r_p = &_basic_r_s
      !initV
      MOVE.l _basic_r_p@(a5),-(!VSP) : JMP ProgramLoop

.SUB_p ;   SUB.p  (x.p, y.l) => r.p    | subtract y from x
.SUB_l ;   SUB.l  (x.l, y.l) => r.l    | subtract y from x
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1 : SUB.l D1,D0 : MOVE.l D0,-(!VSP) : JMP ProgramLoop
.SUB_w ;   SUB.w  (x.w, y.w) => r.w    | subtract y from x
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1 : SUB.w D1,D0 : MOVE.w D0,-(!VSP) : JMP ProgramLoop
.SUB_b  ;   SUB.b  (x.b, y.b) => r.b    | subtract y from x
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1 : SUB.b D1,D0 : MOVE.b D0,-(!VSP) : JMP ProgramLoop
.SUB_f  ;   SUB.f  (x.f, y.f) => r.f    | subtract y from x
      MOVE.l (!VSP)+,_basic_x_f@(a5) : MOVE.l (!VSP)+,_basic_y_f@(a5)
      !deinitV : _basic_r_f = _basic_x_f - _basic_y_f : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

.MUL_l ;   MUL.l  (x.l, y.l) => r.l    | multiply x by y
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1
      MULS.l d1,d0
      MOVE.l D0,-(!VSP) : JMP ProgramLoop
.MUL_w ;   MUL.w  (x.w, y.w) => r.w    | multiply x by y
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      MULS.w d1,d0
      MOVE.w D0,-(!VSP) : JMP ProgramLoop
.MUL_b ;   MUL.b  (x.b, y.b) => r.b    | multiply x by y
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1
      EXT.w d0 : EXT.w d1 : MULS.w d1,d0
      MOVE.b D0,-(!VSP) : JMP ProgramLoop
.MUL_f ;   MUL.f  (x.f, y.f) => r.f    | multiply x by y
      MOVE.l (!VSP)+,_basic_x_f@(a5) : MOVE.l (!VSP)+,_basic_y_f@(a5)
      !deinitV : _basic_r_f = _basic_x_f * _basic_y_f : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

.DIV_l ;   DIV.l  (x.l, y.l) => r.l    | divide x through y
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1
      DIVS.l d0,d1
      MOVE.l D1,-(!VSP) : JMP ProgramLoop
.DIV_w ;   DIV.w  (x.w, y.w) => r.w    | divide x through y
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      EXT.l D0 : EXT.l D1 : DIVS.w d0,d1
      MOVE.w D1,-(!VSP) : JMP ProgramLoop
.DIV_b ;   DIV.b  (x.b, y.b) => r.b    | divide x through y
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1
      EXT.w D0 : EXT.w D1 : EXT.l D0 : EXT.l D1
      DIVS.w d0,d1
      MOVE.b D1,-(!VSP) : JMP ProgramLoop
.DIV_f ;   DIV.f  (x.f, y.f) => r.f    | divide x through y
      MOVE.l (!VSP)+,_basic_y_f@(a5) : MOVE.l (!VSP)+,_basic_x_f@(a5)
      !deinitV : _basic_r_f = _basic_x_f / _basic_y_f : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

.MOD_l ;   MOD.l  (x.l, y.l) => r.l    | x modulo y
      MOVE.l (!VSP)+,D0 : MOVE.l (!VSP)+,D1
      MOVE.l D0,D2
      DIVS.l d1,d2
      MULS.l d1,d2
      SUB.l  D2,D0
      MOVE.l D0,-(!VSP)
      JMP ProgramLoop
.MOD_w  ;   MOD.w  (x.w, y.w) => r.w    | x modulo y
      MOVE.w (!VSP)+,D0 : MOVE.w (!VSP)+,D1
      EXT.l d0 : EXT.l d1
      MOVE.l D0,D2
      DIVS.l d1,d2
      MULS.l d1,d2
      SUB.l  D2,D0
      MOVE.w D0,-(!VSP)
      JMP ProgramLoop
.MOD_b  ;   MOD.b  (x.b, y.b) => r.b    | x modulo y
      MOVE.b (!VSP)+,D0 : MOVE.b (!VSP)+,D1
      EXT.w d0 : EXT.w d1
      EXT.l d0 : EXT.l d1
      MOVE.l D0,D2
      DIVS.l d1,d2
      MULS.l d1,d2
      SUB.l  D2,D0
      MOVE.b D0,-(!VSP)
      JMP ProgramLoop
.MOD_f  ;   MOD.f  (x.f, y.f) => r.f    | x modulo y
      MOVE.l (!VSP)+,_basic_y_f@(a5) : MOVE.l (!VSP)+,_basic_x_f@(a5)
      !deinitV
      _basic_r_f = Int(_basic_x_f / _basic_y_f)
      _basic_r_f = (_basic_x_f * _basic_y_f) - _basic_r_f
      !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

.POW_l ;   POW.l  (x.l, y.l) => r.l    | x power y
      MOVE.l (!VSP)+,_basic_x_l@(A5) : MOVE.l (!VSP)+,_basic_y_l@(A5)
      !deinitV : _basic_r_l = _basic_x_l^_basic_y_l : !initV
      MOVE.l _basic_r_l@(a5),-(!VSP) : JMP ProgramLoop
.POW_w ;   POW.w  (x.w, y.w) => r.w    | x power y
      MOVE.w (!VSP)+,_basic_x_w@(A5) : MOVE.w (!VSP)+,_basic_y_w@(A5)
      !deinitV : _basic_r_w = _basic_x_w^_basic_y_w : !initV
      MOVE.w _basic_r_w@(a5),-(!VSP) : JMP ProgramLoop
.POW_b ;   POW.b  (x.b, y.b) => r.b    | x power y
      MOVE.b (!VSP)+,_basic_x_b@(A5) : MOVE.l (!VSP)+,_basic_y_b@(A5)
      !deinitV : _basic_r_b = _basic_x_b^_basic_y_b : !initV
      MOVE.b _basic_r_b@(a5),-(!VSP) : JMP ProgramLoop
.POW_f ;   POW.f  (x.f, y.f) => r.f    | x power y
      MOVE.l (!VSP)+,_basic_x_f@(A5) : MOVE.l (!VSP)+,_basic_y_f@(A5)
      !deinitV : _basic_r_f = _basic_x_f^_basic_y_f : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

.LOG_f;   Log.f  (x.f, y.f) => r.f    | logarithm of x To base y
      MOVE.l (!VSP)+,_basic_x_f@(A5) : MOVE.l (!VSP)+,_basic_y_f@(A5)
      !deinitV : _basic_r_f = Log(_basic_x_f) * Log(_basic_y_f) / Log(10) : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

.SIN_f ;   Sin.f  (x.f) => r.f         | Sinus of x
      MOVE.l (!VSP)+,_basic_x_f@(A5)
      !deinitV : _basic_r_f = Sin(_basic_x_f) : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

.COS_f ;   Cos.f  (x.f) => r.f         | Cosinus of x
      MOVE.l (!VSP)+,_basic_x_f@(A5)
      !deinitV : _basic_r_f = Cos(_basic_x_f) : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

.TAN_f ;   Tan.f  (x.f) => r.f         | Tangents of x
      MOVE.l (!VSP)+,_basic_x_f@(A5)
      !deinitV : _basic_r_f = Tan(_basic_x_f) : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

.ASIN_f ;   ASin.f (x.f) => r.f         | inverse Sinus of x
      MOVE.l (!VSP)+,_basic_x_f@(A5)
      !deinitV : _basic_r_f = ASin(_basic_x_f) : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

.ACOS_f ;   ACos.f (x.f) => r.f         | inverse Cosinus of x
      MOVE.l (!VSP)+,_basic_x_f@(A5)
      !deinitV : _basic_r_f = ACos(_basic_x_f) : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

.ATAN_f ;   ATan.f (x.f) => r.f         | inverse Tangents of x
      MOVE.l (!VSP)+,_basic_x_f@(A5)
      !deinitV : _basic_r_f = ATan(_basic_x_f) : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop

;   MID.s  (s.s,p.p,n.p) => r.s | middle n characters starting from p of s
;   Len.p  (s.s) => r.p         | string Length of str
;   RPL.s  (s.s,a.s,b.s) => r.s | replace all a with b in str
;   INST.p (s.s,a.s,p.p) => r.p | position of a in s starting from p, OR 0
;   ALOC.p (n.p) => r.p         | allocate memory of n bytes
;   CLR    (m.p,n.p)            | clear memory at m of n bytes
;   Free   (m.p,n.p)            | Free memory at m of n bytes
;   COPY   (x.p,y.p,n.p)        | copy n bytes from x To y

;   PUSH.* (m.p, n.p) => r.b[n] | push n bytes from m To stack
.LEA_p ;   LEA.p  label => r.p         | push label address To stack
      MOVE.l (!VPC)+,-(!VSP) : JMP ProgramLoop

.PUSH_VAR_s ;   PUSH.s label => r.s         | push string  found at label To stack
.PUSH_VAR_f ;   PUSH.f label => r.f         | push float   found at label To stack
.PUSH_VAR_p ;   PUSH.p label => r.p         | push Pointer found at label To stack
.PUSH_VAR_l ;   PUSH.l label => r.l         | push long    found at label To stack
      MOVE.l (!VPC)+,D0 : MOVE.l 0(!VVB,D0),-(!VSP) : JMP ProgramLoop
.PUSH_VAR_w ;   PUSH.w label => r.w         | push Word    found at label To stack
      MOVE.l (!VPC)+,D0 : MOVE.w 0(!VVB,D0),-(!VSP) : JMP ProgramLoop
.PUSH_VAR_b ;   PUSH.b label => r.b         | push byte    found at label To stack
      MOVE.l (!VPC)+,D0 : MOVE.b 0(!VVB,D0),-(!VSP) : JMP ProgramLoop

.PUSH_f ;   PUSH.f #.f => r.f           | push constant float   To stack
.PUSH_p ;   PUSH.p #.p => r.p           | push constant Pointer To stack
.PUSH_l ;   PUSH.l #.l => r.l           | push constant long    To stack
      MOVE.l (!VPC)+,-(!VSP) : JMP ProgramLoop
.PUSH_w ;   PUSH.w #.w => r.w           | push constant Word    To stack
      MOVE.w (!VPC)+,-(!VSP) : JMP ProgramLoop
.PUSH_b ;   PUSH.b #.b => r.b           | push constant byte    To stack
      MOVE.b (!VPC)+,-(!VSP) : JMP ProgramLoop
.PUSH_s ;   PUSH.s #.s => r.s           | push constant string  To stack
      MOVE.l (!VPC)+,D0 ; strlen
      MOVE.l !VPC,-(!VSP) ; strptr => stack
      ADD.l #1,D0      ; add 0 byte
      ADDA.l D0,!VPC   ; add length
      JMP ProgramLoop
;   Pop.*  label (m.p, n.p)     | Pop n bytes from stack To label

.POP_VAR_f ;   Pop.f  label (x.f)          | Pop float   from stack To label
.POP_VAR_p ;   Pop.p  label (x.p)          | Pop Pointer from stack To label
.POP_VAR_l ;   Pop.l  label (x.l)          | Pop long    from stack To label
      MOVE.l (!VPC)+,D0 : MOVE.l (!VSP)+,0(!VVB,D0) : JMP ProgramLoop
.POP_VAR_w  ;   Pop.w  label (x.w)          | Pop Word    from stack To label
      MOVE.l (!VPC)+,D0 : MOVE.w (!VSP)+,0(!VVB,D0) : JMP ProgramLoop
.POP_VAR_b  ;   Pop.b  label (x.b)          | Pop byte    from stack To label
      MOVE.l (!VPC)+,D0 : MOVE.b (!VSP)+,0(!VVB,D0) : JMP ProgramLoop
;   Pop.s  label (x.s)          | Pop string  from stack To label

.POP_f ;   Pop.f  (x.f)          | Pop float   from stack
.POP_p ;   Pop.p  (x.p)          | Pop Pointer from stack
.POP_l ;   Pop.l  (x.l)          | Pop long    from stack
      MOVE.l (!VSP)+,D0 : JMP ProgramLoop
.POP_w  ;   Pop.w  (x.w)          | Pop Word    from stack
      MOVE.b (!VSP)+,D0 : JMP ProgramLoop
.POP_b  ;   Pop.b  (x.b)          | Pop byte    from stack
      MOVE.b (!VSP)+,D0 : JMP ProgramLoop
;   Pop.s  label (x.s)          | Pop string  from stack

.READ_f ;   Read.f (x.p) => r.f         | push float   found in address To stack
.READ_p ;   Read.p (x.p) => r.p         | push Pointer found in address To stack
.READ_l ;   Read.l (x.p) => r.l         | push long    found in address To stack
      MOVE.l (!VSP)+,A0 : MOVE.l (A0),-(!VSP) : JMP ProgramLoop
.READ_w ;   Read.w (x.p) => r.w         | push Word    found in address To stack
      MOVE.l (!VSP)+,A0 : MOVE.w (A0),-(!VSP) : JMP ProgramLoop
.READ_b ;   Read.b (x.p) => r.b         | push byte    found in address To stack
      MOVE.l (!VSP)+,A0 : MOVE.b (A0),-(!VSP) : JMP ProgramLoop
;   Read.s (x.p) => r.s         | push string  found in address To stack
;   Read.* (m.p,n.p) => r.b[n]  | push memory  found in address To stack

.JMP_v ;   JMP    label                | Goto label
   MOVE.l (!VPC)+,D1
   ADDA.l D1,!VPC
   JMP ProgramLoop
.JMPF_v ;   JMPF   label, (c.B)         | Goto label If cond is False
   MOVE.l (!VPC)+,D1
   MOVE.!B (!VSP)+,D0
   BNE ProgramLoop
   ADD.l D1,!VPC
   JMP ProgramLoop
.JMPT_v ;   JMPT   label, (c.B)         | Goto label If cond is True
   MOVE.l (!VPC)+,D1
   MOVE.!B (!VSP)+,D0
   BEQ ProgramLoop
   ADD.l D1,!VPC
   JMP ProgramLoop
.JSR_p ;   JSR    label => r.p         | Goto label AND store current PC
   MOVE.l (!VPC)+,D1
   MOVE.l !VPC,-(!VSP)
   ADDA.l D1,!VPC
   JMP ProgramLoop
.RTS_v ;   RTS    (r.p)                | Goto PC On stack (Return from subroutine)
   MOVE.l (!VSP)+,!VPC
   JMP ProgramLoop

.BOOL_f ;   BOOL.f (x.f) => r.B         | convert x To bool     (True/False)
.BOOL_p ;   BOOL.p (x.p) => r.B         | convert x To bool     (True/False)
.BOOL_l ;   BOOL.l (x.l) => r.B         | convert x To bool     (True/False)
      MOVE.l (!VSP)+,D0
      BNE 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.BOOL_w ;   BOOL.w (x.w) => r.B         | convert x To bool     (True/False)
      MOVE.w (!VSP)+,D0
      BNE 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
.BOOL_b ;   BOOL.b (x.b) => r.B         | convert x To bool     (True/False)
      MOVE.b (!VSP)+,D0
      BNE 'ok
      MOVE.!B #0,-(!VSP) : JMP ProgramLoop
'ok:  MOVE.!B #1,-(!VSP) : JMP ProgramLoop
;   BOOL.s (x.s) => r.B         | convert x To bool     (True/False)

.BYTE_p ;   BYTE.p (x.p) => r.b         | convert x To byte     (-128...+127)
.BYTE_l ;   BYTE.l (x.l) => r.b         | convert x To byte     (-128...+127)
      MOVE.l (!VSP)+,A0 : MOVE.b (A0),-(!VSP) : JMP ProgramLoop
.BYTE_w ;   BYTE.w (x.w) => r.b         | convert x To byte     (-128...+127)
      MOVE.w (!VSP)+,A0 : MOVE.b (A0),-(!VSP) : JMP ProgramLoop
.BYTE_f ;   BYTE.f (x.f) => r.b         | convert x To byte     (-128...+127)
      MOVE.l (!VSP)+,_basic_x_f@(A5)
      !deinitV
      _basic_r_l = _basic_x_f
      !initV
      MOVE.l _basic_r_l@(a5),D0 : MOVE.b D0,-(!VSP)
      JMP ProgramLoop
;   BYTE.s (x.s) => r.b         | convert x To byte     (-128...+127)

.WORD_p ;   Word.p (x.p) => r.w         | convert x To Word     (-32768...+32767)
.WORD_l ;   Word.l (x.l) => r.w         | convert x To Word     (-32768...+32767)
      MOVE.l (!VSP)+,D0 : MOVE.w D0,-(!VSP) : JMP ProgramLoop
.WORD_b ;   Word.b (x.b) => r.w         | convert x To Word     (-32768...+32767)
      MOVE.b (!VSP)+,D0 : EXT.w D0 : MOVE.w D0,-(!VSP) : JMP ProgramLoop
.WORD_f ;   Word.f (x.f) => r.w         | convert x To Word     (-32768...+32767)
      MOVE.l (!VSP)+,_basic_x_f@(A5)
      !deinitV : _basic_r_b = _basic_x_f : !initV
      MOVE.b _basic_r_b@(a5),-(!VSP) : JMP ProgramLoop
;   Word.s (x.s) => r.w         | convert x To Word     (-32768...+32767)

.PTR_w
.LONG_w;   LONG.w (x.w) => r.l         | convert x To Long     (-2^31...+2^31-1)
       MOVE.w (!VSP)+,D0 : EXT.l D0 : MOVE.l D0,-(!VSP) : JMP ProgramLoop
.PTR_b
.LONG_b ;   LONG.b (x.b) => r.l         | convert x To Long     (-2^31...+2^31-1)
       MOVE.b (!VSP)+,D0 : EXT.w D0 : EXT.l D0 : MOVE.l D0,-(!VSP) : JMP ProgramLoop
.PTR_f
.LONG_f ;   LONG.f (x.f) => r.l         | convert x To Long     (-2^31...+2^31-1)
  MOVE.l (!VSP)+,_basic_x_f@(A5)
  !deinitV
  _basic_r_l = _basic_x_f
  !initV
  MOVE.l _basic_r_l@(a5),-(!VSP)
  JMP ProgramLoop
;   LONG.s (x.s) => r.l         | convert x To Long     (-2^31...+2^31-1)
.PTR_l
.LONG_p ;   LONG.p (x.p) => r.l         | convert x To Long     (-2^31...+2^31-1)
  JMP ProgramLoop

.FLT_p ;   FLT.p  (x.p) => r.f         | convert x To float    (...)
.FLT_l ;   FLT.l  (x.l) => r.f         | convert x To float    (...)
      MOVE.l (!VSP)+,_basic_x_l@(A5)
      !deinitV : _basic_r_f = _basic_x_l : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop
.FLT_w ;   FLT.w  (x.w) => r.f         | convert x To float    (...)
      MOVE.w (!VSP)+,_basic_x_w@(A5)
      !deinitV : _basic_r_f = _basic_x_w : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop
.FLT_b ;   FLT.b  (x.b) => r.f         | convert x To float    (...)
      MOVE.b (!VSP)+,_basic_x_b@(A5)
      !deinitV : _basic_r_f = _basic_x_b : !initV
      MOVE.l _basic_r_f@(a5),-(!VSP) : JMP ProgramLoop
;   FLT.s  (x.s) => r.f         | convert x To float    (...)

;   STR.l  (x.l) => r.s         | convert x To string   (0-2^31-1 Length)
;   STR.w  (x.w) => r.s         | convert x To string   (0-2^31-1 Length)
;   STR.b  (x.b) => r.s         | convert x To string   (0-2^31-1 Length)
;   STR.s  (x.s) => r.s         | convert x To string   (0-2^31-1 Length)
;   STR.p  (x.p) => r.s         | convert x To string   (0-2^31-1 Length)

.COUT_l ;   COUT (x.l)
  MOVE.l (!VSP)+,_basic_x_l@(A5)
  !deinitV
  NPrint _basic_x_l
  !initV
  JMP ProgramLoop

.COUT_f ;   COUT (x.f)
  MOVE.l (!VSP)+,_basic_x_f@(A5)
  !deinitV
  NPrint _basic_x_f
  !initV
  JMP ProgramLoop
 
.COUT_s ;   COUT (x.l)
  MOVE.l (!VSP)+,_basic_x_p@(A5)
  !deinitV
  NPrint Peeks$(_basic_x_p,Peek.l(_basic_x_p-4))
  !initV
  JMP ProgramLoop

.COUT_B ;   COUT (x.l)
  MOVE.!B (!VSP)+,_basic_x_B@(A5)
  !deinitV
  If _basic_x_B
    NPrint "TRUE"
  Else
    NPrint "FALSE"
  End If
  !initV
  JMP ProgramLoop
 


Dc.b "$VER: "
version:
Dc.b "VRun \\_VER_MAJOR.\\_VER_MINOR (\\_DATE_GER_) Build \\_VER_PATCH.\\_VER_BUILD",0
shortversion:
Dc.b "VRun \\_VER_MAJOR.\\_VER_MINOR",0



