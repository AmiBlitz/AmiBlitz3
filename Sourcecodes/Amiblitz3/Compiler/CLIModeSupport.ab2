
; load bb, bb2, ab2 and ab3
Function.l LoadSource{filename.s }
!ComData_GetL{comPtr_FirstSourceLine,D0}
*sourceBase.sourceline = PutD0
!ComData_GetL{comPtr_PreProcessor,D0}
*PreProcessor.preprocessor = PutD0

fid.l = file_Open{filename,#file_read}
If fid>=0
  bytelength.l = file_GetLength{fid}
  tempbuffer.l = AllocVec_(bytelength,#MEMF_ANY)
  If tempbuffer
    If file_ReadMem{fid,tempbuffer,bytelength}
      ex.s = dos_GetExt{filename}
      If ex="ab2" OR ex="ab3" OR ex="asc"
        preproc_Tokenize{*PreProcessor,tempbuffer,tempbuffer,bytelength}
      End If
      offset.l = 0
      *sourceline.sourceline = !_NULL
      *prevline.sourceline   = !_NULL
      *firstline.sourceline  = !_NULL
      While offset<bytelength
        text.s = Peek.s(tempbuffer+offset)
        offset+FLen(text)+1
        *sourceline = AllocMem_(SizeOf.sourceline+FLen(text)+1,#MEMF_ANY)
        *sourceline\PrevLine   = *prevline
        *sourceline\NextLine   = !_NULL
        *sourceline\linelength = FLen(text)+1
        Poke.s &*sourceline\text,text
        *prevline.sourceline = *sourceline
        If *firstline=!_NULL Then *firstline = *sourceline
      Wend
      FreeVec_ tempbuffer
      GetD0 *firstline
      !ComData_SetL{comPtr_FirstSourceLine,D0}
    End If
  End If
End If
Function Return *firstline
End Function

Function.l SaveXtra{filename.s}
succ.l = False
fid.l = file_Open{filename,#file_forcewrite}
If fid>=0
  GetD0 file_GetFH{fid}
  MOVE.l D0,D7
;  JSR write_xtrafile:
;  Read_ xtrafilehandle,?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin ; xtrabuf,36
  file_Close{fid}
End If
Function Return succ
End Function


Function.l LoadXtra{filename.s}
succ.l = False
fid.l = file_Open{filename,#file_read}
If fid>=0
  GetD0 file_GetFH{fid}
  MOVE.l D0,D7
 ; JSR read_xtrafile:
 ; Read_ xtrafilehandle,?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin ; xtrabuf,36
 file_Close{fid}
End If
Function Return succ
End Function
 


; this function can save .bb2, .ab2 and .ab3
Function.l SaveSource{filename.s}
SHARED exepathname$,exefilename$
Format ""
!ComData_GetL{comPtr_FirstSourceLine,D0}
*sourceBase.sourceline = PutD0
!ComData_GetL{comPtr_PreProcessor,D0}
*PreProcessor.preprocessor = PutD0
succ.l = False
fid.l = file_Open{filename,#file_write}
If fid>=0

  totalLength.l = 0
  *sourceLine.sourceline = *sourceBase

  While *sourceLine
    baseptr.l = &*sourceLine\text[0]
    sptr.l = baseptr
    While Peek.b(sptr) : sptr+1 : Wend
    totalLength + sptr-baseptr+1
    *sourceLine = *sourceLine\NextLine
  Wend

  tmp.l      = AllocVec_(totalLength,#MEMF_CLEAR)
  If tmp
    *sourceLine.sourceline = *sourceBase
    dptr.l     = tmp
    While *sourceLine
      baseptr.l = &*sourceLine\text[0]
      sptr.l = baseptr
      Repeat
        char.b = Peek.b(sptr)
        Poke.b dptr,char : sptr +1 : dptr+1
      Until char=0
      *sourceLine = *sourceLine\NextLine
    Wend

    ex.s = dos_GetExt{filename}

    If ex="bb2" OR ex="bb" ; write tokenized
      succ = file_WriteMem{fid,tmp,totalLength}
    Else
      If ex="ab3" ; write Xtra as text...

        cliargs.s = Peeks$(?str_cliarguments,120)
        cliargs   = Peek.s(&cliargs)

        resptr.l = ?residents_table
        residents.s = Peek.s(resptr)
        For i.l = 0 To 6
          If Right$(residents,1)><"," Then residents + ","
          resptr + $44
          residents  + Peek.s(resptr)
        Next
        If Right$(residents,1)="," Then residents=Left$(residents,FLen(residents)-1)

        If (Peek.b(?use_debugger      )&$80) Then RuntimeDebug.l   = 1:Else RuntimeDebug   = 0
        If (Peek.b(?create_iconfile   )&$80) Then CreateIcon.l     = 1:Else CreateIcon     = 0
        If (Peek.b(?make_smallestcode )&$80) Then MakeSmallest.l   = 1:Else MakeSmallest   = 0
        If (Peek.b(?link_debuginfo    )&$80) Then DebugInfo.l      = 1:Else DebugInfo      = 0
        If (Peek.b(?autorun           )&$80) Then AutoRun.l        = 1:Else AutoRun        = 0
        If (Peek.b(?assemblercheck    )&$80) Then AssemblerCheck.l = 1:Else AssemblerCheck = 0
        If (Peek.b(?interruptcheck    )&$80) Then InterruptCheck.l = 1:Else InterruptCheck = 0
        If (Peek.b(?overflowcheck     )&$80) Then OverflowCheck.l  = 1:Else OverflowCheck  = 0

        !ComData_GetL{startdisplayline,d0}
        !ComData_GetL{displayoffset   ,d1}
        ADD.l d1,d0
        ADD.l #1,d0
        CursorLine.l = PutD0
        ;CursorLine.l   = Peek.l(?startdisplayline)      + Peek.l(?displayoffset)  +1

        CLR.l d0
        !ComData_GetW{comWord_ColumnsOffset,d0}
        !ComData_GetW{comWord_Column       ,d1}
        EXT.l d0
        EXT.l d1
        ADD.l d1,d0
        ADD.l #1,d0
        CursorColumn.l = PutD0
        ;CursorColumn.l = Peek.w(?comWord_ColumnsOffset) + Peek.w(?comWord_Column) +1

        VersionInfo.l = Peek.l(?versioninformation)
        MajorVersion.l = (VersionInfo & $FF000000) LSR 24
        MinorVersion.l = (VersionInfo & $00FF0000) LSR 16
        PatchVersion.l = (VersionInfo & $0000FF00) LSR 8




        ExeFile.s = "";Peek.s(?actualfile)
        !ComData_GetL{comPtr_CurrentDir,d0}
        ExePathP.l = PutD0
        If ExePathP
          ExePath.s = Peek.s(ExePathP)
        Else
          ExePath.s = ""
        End If

        ExePath.s = Peek.s(?exepath)
        ExeFile.s = Peek.s(?exefilename)


        file_WriteLine{fid,"; XTRA"}
        file_WriteLine{fid,"; Embedded .xtra Header"}
        file_WriteLine{fid,"; "}
        file_WriteLine{fid,"; General Info"}
        file_WriteLine{fid,"; -------------------------------------------------------"}
        file_WriteLine{fid,"; SourceName      = \\22"+dos_FilePart{filename}+"\\22"}
        file_WriteLine{fid,"; ExePath         = \\22"+ExePath+"\\22"}
        file_WriteLine{fid,"; ExeFile         = \\22"+ExeFile+"\\22"}
        file_WriteLine{fid,"; Residents       = \\22"+residents+"\\22"}
        file_WriteLine{fid,"; "}
        file_WriteLine{fid,"; Compiler"}
        file_WriteLine{fid,"; -------------------------------------------------------"}
        file_WriteLine{fid,"; StringBuffer    = "+Str$(Peek.l(?stringbuffer))}
        file_WriteLine{fid,"; MakeSmallest    = "+Str$(MakeSmallest)}
        file_WriteLine{fid,"; Version         = "+Str$(MajorVersion)+"."+Str$(MinorVersion)+"."+Str$(PatchVersion)}
        file_WriteLine{fid,"; NumberOfBuilds  = "+Str$(Peek.l(?number_of_builds))}
        file_WriteLine{fid,"; "}
        file_WriteLine{fid,"; Debugger"}
        file_WriteLine{fid,"; -------------------------------------------------------"}
        file_WriteLine{fid,"; CliArgs         = \\22"+cliargs+"\\22"}
        file_WriteLine{fid,"; RuntimeDebug    = "+Str$(RuntimeDebug)}
        file_WriteLine{fid,"; DebugInfo       = "+Str$(DebugInfo)}
        file_WriteLine{fid,"; OverflowCheck   = "+Str$(OverflowCheck)}
        file_WriteLine{fid,"; AssemblerCheck  = "+Str$(AssemblerCheck)}
        file_WriteLine{fid,"; InterruptCheck  = "+Str$(InterruptCheck)}
        file_WriteLine{fid,"; AutoRun         = "+Str$(AutoRun)}
        file_WriteLine{fid,"; "}
        file_WriteLine{fid,"; Editor"}
        file_WriteLine{fid,"; -------------------------------------------------------"}
        file_WriteLine{fid,"; CursorLine      = "+Str$(CursorLine)}
        file_WriteLine{fid,"; CursorColumn    = "+Str$(CursorColumn)}
        file_WriteLine{fid,"; "}
        file_WriteLine{fid,"; Max Blitz Objects"}
        file_WriteLine{fid,"; -------------------------------------------------------"}
        For i.l = 0 To Peek.w(?number_of_objects)-1
          name.s = "                                "
          GetD0 &name,i:JSR getobjectentry : a.l = PutD0
          maxname.s = "; Max"+Peek.s(&name)
          If FLen(maxname)<18 Then maxname + LSet$(" ",18-FLen(maxname))
          file_WriteLine{fid,maxname+"= "+Str$(a)}
        Next

        file_WriteLine{fid,"; /XTRA"}
      EndIf
      file_Flush{fid}
      plainLength.l = preproc_DetokenizeFP{*PreProcessor,tmp,totalLength,file_GetFH{fid}}
      If ex="ab3"
        file_WriteLine{fid,"</source>"}
      End If
      succ.l = True
    End If
    FreeVec_ tmp

    If ex="bb2" OR ex="bb" OR ex="ab2"    ; write xtra file
      SaveXtra{dos_SetExt{filename,"xtra"}}
    End If
  Else
    error{!TRANS{"Not enough memory for temp buffer!"}}
  End If
  file_Close{fid}
End If
Function Return succ
End Function
 
 
Statement EmulatePED{}
*tedlibbase.Library = OpenLibrary_ ("ted.library",0)
If *tedlibbase
  LEA COMDATABASE,A0
;  TEDSetJumpTable_
;  TEDSetFirstLine_ ?comPtr_FirstSourceLine
;  TEDSetCurrentLine_ ?comPtr_CurrentSourceLine
;  If Peek.l(?comPtr_CurrentSourceLine) > 0
;    TEDSetCurrentLine_ ?comPtr_CurrentSourceLine
;  EndIf
;  TEDSetLabelList_ ?comPtr_LabelList
;  TEDSetLabelCount_ ?ptr_labelcounter
  CloseLibrary_ *tedlibbase
EndIf
End Statement


Statement ClearSource{}
 !ComData_GetL{comPtr_FirstSourceLine,D0}
 *sourceline.sourceline = PutD0
 MOVE.l maxlines,D0
 SUBQ.l #1,D0
 maxlines.l = PutD0
 While *sourceline
   FreePooled_ Peek.l(?mempool),*sourceline,*sourceline\linelength
   *sourceline = *sourceline\NextLine
 Wend
 JSR clearlabels ; was clear labellist
End Statement


Macro xnewalloc
  ADDQ.l #4,d0
  MOVE.l _execbase,a6
  MOVE.l mempool,a0
  MOVE.l d0,-(a7)
  JSR _AllocPooled(a6)
  MOVE.l (a7)+,d1
  TST.l d0
  BEQ 'lab1`@
  MOVE.l d0,a0
  MOVE.l d1,(a0)+
  MOVE.l a0,d0
 'lab1`@
End Macro

Macro xnewfree
  MOVE.l _execbase,a6
  MOVE.l mempool,a0
  MOVE.l -(a1),d0
  JSR _FreePooled(a6)        ; a0: poo lHeader, a1: memory, d0: memsize
End Macro

