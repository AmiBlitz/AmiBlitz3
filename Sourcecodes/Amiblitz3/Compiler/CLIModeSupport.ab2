
; load bb, bb2, ab2 and ab3
Function.l LoadSource{filename.s }
!ComData_GetL{comPtr_FirstSourceLine,D0}
*sourceBase.sourceline = PutD0
!ComData_GetL{comPtr_PreProcessor,D0}
*PreProcessor.preprocessor = PutD0

fid.l = file_Open{filename,#file_read}
If fid>=0
  bytelength.l = file_GetLength{fid}
  tempbuffer.l = AllocVec_(bytelength,#MEMF_ANY)
  If tempbuffer
    If file_ReadMem{fid,tempbuffer,bytelength}
      ex.s = dos_GetExt{filename}
      If ex="ab2" OR ex="ab3" OR ex="asc"
        preproc_Tokenize{*PreProcessor,tempbuffer,tempbuffer,bytelength}
      End If
      offset.l = 0
      *sourceline.sourceline = !_NULL
      *prevline.sourceline   = !_NULL
      *firstline.sourceline  = !_NULL
      While offset<bytelength
        text.s = Peek.s(tempbuffer+offset)
        offset+FLen(text)+1
        *sourceline = AllocMem_(SizeOf.sourceline+FLen(text)+1,#MEMF_ANY)
        *sourceline\PrevLine   = *prevline
        *sourceline\NextLine   = !_NULL
        *sourceline\linelength = FLen(text)+1
        Poke.s &*sourceline\text,text
        *prevline.sourceline = *sourceline
        If *firstline=!_NULL Then *firstline = *sourceline
      Wend
      FreeVec_ tempbuffer
      GetD0 *firstline
      !ComData_SetL{comPtr_FirstSourceLine,D0}
    End If
  End If
End If
Function Return *firstline
End Function

Function.l SaveXtra{filename.s}
succ.l = False
fid.l = file_Open{filename,#file_forcewrite}
If fid>=0
  GetD0 file_GetFH{fid}
  MOVE.l D0,D7
;  JSR write_xtrafile:
;  Read_ xtrafilehandle,?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin ; xtrabuf,36
  file_Close{fid}
End If
Function Return succ
End Function


Function.l LoadXtra{filename.s}
succ.l = False
fid.l = file_Open{filename,#file_read}
If fid>=0
  GetD0 file_GetFH{fid}
  MOVE.l D0,D7
 ; JSR read_xtrafile:
 ; Read_ xtrafilehandle,?comDef_XtraExtendBegin,?comDef_XtraExtendEnd-?comDef_XtraExtendBegin ; xtrabuf,36
 file_Close{fid}
End If
Function Return succ
End Function
 


; this function can save .bb2, .ab2 and .ab3
Function.l SaveSource{filename.s}
!ComData_GetL{comPtr_FirstSourceLine,D0}
*sourceBase.sourceline = PutD0
!ComData_GetL{comPtr_PreProcessor,D0}
*PreProcessor.preprocessor = PutD0
succ.l = False
fid.l = file_Open{filename,#file_write}
If fid>=0

  totalLength.l = 0
  *sourceLine.sourceline = *sourceBase

  While *sourceLine
    baseptr.l = &*sourceLine\text[0]
    sptr.l = baseptr
    While Peek.b(sptr) : sptr+1 : Wend
    totalLength + sptr-baseptr+1
    *sourceLine = *sourceLine\NextLine
  Wend

  tmp.l      = AllocVec_(totalLength,#MEMF_CLEAR)
  If tmp
    *sourceLine.sourceline = *sourceBase
    dptr.l     = tmp
    While *sourceLine
      baseptr.l = &*sourceLine\text[0]
      sptr.l = baseptr
      Repeat
        char.b = Peek.b(sptr)
        Poke.b dptr,char : sptr +1 : dptr+1
      Until char=0
      *sourceLine = *sourceLine\NextLine
    Wend

    ex.s = dos_GetExt{filename}

    If ex="bb2" OR ex="bb" ; write tokenized
      succ = file_WriteMem{fid,tmp,totalLength}
    Else
      If ex="ab3" ; write Xtra as text...
        cliargs.s = Peeks$(?str_cliarguments,120)
        cliargs   = Peek.s(&cliargs)

        resptr.l = ?residents_table
        residents.s = Peek.s(resptr)
        For i.l = 0 To 6
          If Right$(residents,1)><"," Then residents + ","
          resptr + $44
          residents  + Peek.s(resptr)
        Next
        If Right$(residents,1)="," Then residents=Left$(residents,FLen(residents)-1)

        file_WriteLine{fid,"<xtra>"}
        file_WriteLine{fid,"; General"}
        file_WriteLine{fid,"; -------------------------------------------------------"}
        file_WriteLine{fid,"  SourceName      = "+dos_FilePart{filename}}
        file_WriteLine{fid,"  ExePath         = "}
        file_WriteLine{fid,"  ExeFile         = "}
        file_WriteLine{fid,"  Residents       = \\22"+residents+"\\22"}
        file_WriteLine{fid,""}
        file_WriteLine{fid,"; Compiler"}
        file_WriteLine{fid,"; -------------------------------------------------------"}
        file_WriteLine{fid,"  StringBuffer    = "+Str$(Peek.l(?stringbuffer))}
        file_WriteLine{fid,"  MakeSmallest    = "}
        file_WriteLine{fid,"  VersionInfo     = "+Str$(Peek.l(?versioninformation))}
        file_WriteLine{fid,"  NumberOfBuilds  = "+Str$(Peek.l(?number_of_builds))}
        file_WriteLine{fid,""}
        file_WriteLine{fid,"; Debugger"}
        file_WriteLine{fid,"; -------------------------------------------------------"}
        file_WriteLine{fid,"  CliArgs         = \\22"+cliargs+"\\22"}
        file_WriteLine{fid,"  Debugger        = "}
        file_WriteLine{fid,"  DebugInfo       = "}
        file_WriteLine{fid,"  OverflowCheck   = "}
        file_WriteLine{fid,"  AssemblerCheck  = "}
        file_WriteLine{fid,"  Interruptcheck  = "}
        file_WriteLine{fid,"  AutoRun         = "}
        file_WriteLine{fid,""}
        file_WriteLine{fid,"; Editor"}
        file_WriteLine{fid,"; -------------------------------------------------------"}
        file_WriteLine{fid,"  CursorColumn    = "}
        file_WriteLine{fid,"  CursorLine      = "}
        file_WriteLine{fid,""}
        file_WriteLine{fid,"; Max Blitz Objects"}
        file_WriteLine{fid,"; -------------------------------------------------------"}
        For i.l = 0 To Peek.w(?number_of_objects)-1
          name.s = "                                "
          GetD0 &name,i:JSR getobjectentry : a.l = PutD0
          maxname.s = "  Max"+Peek.s(&name)
          If FLen(maxname)<18 Then maxname + LSet$(" ",18-FLen(maxname))
          file_WriteLine{fid,maxname+"= "+Str$(a)}
        Next

        file_WriteLine{fid,"</xtra>"}
        file_WriteLine{fid,"<source>"}
      EndIf
      file_Flush{fid}
      plainLength.l = preproc_DetokenizeFP{*PreProcessor,tmp,totalLength,file_GetFH{fid}}
      If ex="ab3"
        file_WriteLine{fid,"</source>"}
      End If
      succ.l = True
    End If
    FreeVec_ tmp

    If ex="bb2" OR ex="bb" OR ex="ab2"    ; write xtra file
      SaveXtra{dos_SetExt{filename,"xtra"}}
    End If
  Else
    error{!TRANS{"Not enough memory for temp buffer!"}}
  End If
  file_Close{fid}
End If
Function Return succ
End Function
 
 
Statement EmulatePED{}
*tedlibbase.Library = OpenLibrary_ ("ted.library",0)
If *tedlibbase
  LEA COMDATABASE,A0
;  TEDSetJumpTable_
;  TEDSetFirstLine_ ?comPtr_FirstSourceLine
;  TEDSetCurrentLine_ ?comPtr_CurrentSourceLine
;  If Peek.l(?comPtr_CurrentSourceLine) > 0
;    TEDSetCurrentLine_ ?comPtr_CurrentSourceLine
;  EndIf
;  TEDSetLabelList_ ?comPtr_LabelList
;  TEDSetLabelCount_ ?ptr_labelcounter
  CloseLibrary_ *tedlibbase
EndIf
End Statement


Statement ClearSource{}
 !ComData_GetL{comPtr_FirstSourceLine,D0}
 *sourceline.sourceline = PutD0
 MOVE.l maxlines,D0
 SUBQ.l #1,D0
 maxlines.l = PutD0
 While *sourceline
   FreePooled_ Peek.l(?mempool),*sourceline,*sourceline\linelength
   *sourceline = *sourceline\NextLine
 Wend
 JSR clearlabels ; was clear labellist
End Statement


Macro xnewalloc
  ADDQ.l #4,d0
  MOVE.l _execbase,a6
  MOVE.l mempool,a0
  MOVE.l d0,-(a7)
  JSR _AllocPooled(a6)
  MOVE.l (a7)+,d1
  TST.l d0
  BEQ 'lab1`@
  MOVE.l d0,a0
  MOVE.l d1,(a0)+
  MOVE.l a0,d0
 'lab1`@
End Macro

Macro xnewfree
  MOVE.l _execbase,a6
  MOVE.l mempool,a0
  MOVE.l -(a1),d0
  JSR _FreePooled(a6)        ; a0: poo lHeader, a1: memory, d0: memsize
End Macro

