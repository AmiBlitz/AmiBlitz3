;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: AmiBlitz3                                                             /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, AmigaOS4, MOS                         /
;/                                                                             /
;/ Date: 01.09.2009                                                            /
;/                                                                             /
;/ Authors: 1990...1996 Mark Silby                                             /
;/          1991...2003 Red When Excited                                       /
;/          2003...2009 Bernd Roesch, Sven Droege                              /
;/          2009...     Thilo Koehler, Thomas Klein                            /
;/                                                                             /
;/ Requirements: AmigaOS3.1+                                                   /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Compiler and framework for AmiBlitz3 programming language.                  /
;/                                                                             /
;/ Abstract:  (sorry, German only)                                             /
;/ AmiBlitz3 ist eine freie Entwicklungsumgebung fuer AmigaOS3.x und           /
;/ Kompatible. Um zu erlaeutern, was es mit AmiBlitz3 auf sich hat,            /
;/ muss man bei BlitzBasic beginnen.                                           /
;/                                                                             /
;/ BlitzBasic, spaeter BlitzBasic2, ist ein urspruenglich von Acidsoft und     /
;/ Red When Excited (RWE) fuer den Amiga entwickelter, umfangreicher           /
;/ und ein wenig eigenwilliger Basic-Dialekt.                                  /
;/ Trotz der Popularitaet, die dieser in den 90er Jahren erreichte, sah man    /
;/ sich bei Acidsoft nach der Commodore-Pleite und dem nachfolgenden           /
;/ Niedergang des Amiga Marktes dazu gezwungen,                                /
;/ die Entwicklung von BlitzBasic2 auf dem Amiga einzustellen und sich         /
;/ ausschliesslich einer Version fuer Windows-PCs zu widmen.                   /
;/                                                                             /
;/ Auf Bestreben von Bernd Roesch durfte die Amiga-Version disassembliert      /
;/ und weiterenwickelt werden. Um eine Verwechslung mit der PC-Version zu      /
;/ vermeiden, firmiert diese mittlerweile ueberarbeitete Amiga-Version seitdem /
;/ unter dem Namen AmiBlitz2.                                                  /
;/                                                                             /
;/ Mit der Umgestaltung und Modernisierung der Entwicklungsumgebung            /
;/ sowie der gesamten Dateistruktur erfolgte die konsequente Fortfuehrung      /
;/ der Namensgebung zu AmiBlitz3.                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////

optimize 5                               ; don't use FPU (opt. 4)
Syntax 2                                 ; syntax strictness

#MAX_STRINGSIZE = 512                    ; general string buffer size
#MIN_STACKSIZE = 8191                    ; minimum stack size for AB3 programs

Macro regs2stack                         ; helper macro
  MOVEM.l d0-d7/a0-a6,-(a7)
End Macro

Macro stack2regs                         ; helper macro
  MOVEM.l (a7)+,d0-d7/a0-a6
End Macro

Macro DPrint
  MOVE.l d0,-(a7)
  !basic
  NPrint `1
  ;MouseWait
  !asm
  MOVE.l (a7)+,d0
End Macro

!initasm                                 ; some initial mumbo jumbo
!basic
WBStartup

SHARED cli_verbose.l
SHARED CLIMode.l
cli_verbose = -1
CLIMode     = False
MaxLen cli_tempstr.s = 1024
GetCurrentDirName_ &cli_tempstr,1024  ; get the current dir to restore it on exit
cli_path.s = Peek.s(&cli_tempstr)

#USE_WBSTARTUPMSG = 0

XINCLUDE "/Shared/library_offsets.ab3"   ; needed includes
XINCLUDE "dos.include.bb2"

If dos_FromCLI{}
  CLIMode.l=True
  error_SetFlags{#error_stdout}
End If

XINCLUDE "/Shared/common.ab3"
XINCLUDE "/Shared/preprocessor.include.ab3"
XINCLUDE "PE/wizard_Table.include.bb2"
optimize 5                               ; added because the include change the optimize and or syntax level  tomsmart1
Syntax 2

XINCLUDE "PE/logging.include.bb2"
optimize 5                               ; added because the include change the optimize and or syntax level  tomsmart1
Syntax 2

XINCLUDE "translation.include.bb2"
XINCLUDE "/Shared/ted.include.ab3"
XINCLUDE "CLIModeSupport.ab3"

.TOOLTYPES
; --
; -- check, if an assign-value was set via Tooltype
dynassign.s = dos_GetToolString{"ASSIGN","Blitz3:"}
If dynassign <> ""
    *AssignSema.SignalSemaphore = FindSemaphore_(&dynassign)    ; does it already exist?
    If *AssignSema
      ObtainSemaphoreShared_ *AssignSema
    Else                                                        ; no, create one...
      *AssignSema = AllocVec_ (SizeOf.SignalSemaphore,#MEMF_PUBLIC|#MEMF_CLEAR)
      If *AssignSema
        InitSemaphore_ *AssignSema

        *AssignSema\ss_Link\ln_Name = AllocVec_(FLen(dynassign)+1,#MEMF_PUBLIC|#MEMF_CLEAR)
        If *AssignSema\ss_Link\ln_Name
          Poke.s  *AssignSema\ss_Link\ln_Name,dynassign
        End If
        *AssignSema\ss_Link\ln_Pri  = 1
        *AssignSema\ss_Link\ln_Type = #NT_SIGNALSEM

        AddSemaphore_ *AssignSema
        ObtainSemaphoreShared_ *AssignSema

      End If
    End If

  ; -- create our assign & config the directory variables
  mydir.s = dos_GetProgDir{"Sys:"}
  If dos_SetAssign{dynassign,mydir,False}
    dos_AddAssign{"LIBS:",dos_AddPart{dynassign,"Libs"}}
  EndIf

  Poke$ ?str_blitz3assign,dynassign
  Poke$ ?str_defaultdbug,dos_AddPart{dynassign,"Debug/DefaultDBug"}
  ;Poke$ ?str_defaultdbug,dos_AddPart{dynassign,"Debug/REDDebugger"}

  Poke$ ?str_path_acidlibs,dos_AddPart{dynassign, "BlitzLibs/AcidLibs"}
  Poke$ ?str_path_deflibs ,dos_AddPart{dynassign, "BlitzLibs/DefLibs" }
  Poke$ ?str_path_userlibs,dos_AddPart{dynassign, "BlitzLibs/UserLibs"}
  Poke$ ?str_path_includes,dos_AddPart{dynassign, "Sourcecodes/Includes"}
  my_systemdir$    = dos_AddPart{dynassign, "System"}
  my_residentsdir$ = dos_AddPart{dynassign, "BlitzLibs/Residents"}
  my_blitzlibsdir$ = dos_AddPart{dynassign, "BlitzLibs"}
  dos_CreateDir{my_blitzlibsdir$}
  dos_CreateDir{Peek$(?str_path_userlibs)}
  dos_CreateDir{my_residentsdir$}
  dos_CreateDir{my_systemdir$}

EndIf

; --
; -- check, if there is an alternative PED-executable set via Tooltype
pedfile$ = dos_GetToolString{"EDITOR",dos_AddPart{my_systemdir$,"PED"}}
Poke.s ?str_pedfile,pedfile$

If dos_GetToolState{"START_WITHOUT_LIBS"} = -1
  Poke.b ?start_without_libs,1
Else
  Poke.b ?start_without_libs,0
EndIf

!TRANS_INIT{"AmiBlitz3"}     ; init localization via translation.include

;---  Check  if  all  needed  Librarys  are  available  with  the  needed  min  Version
errorout.s = ""                                            ; for the error text
ende.b     =  False                                        ; abort indicater

If dos_CheckLib{"wizard.library",42} = False               ; needed for Compiler, PED and REDDebugger
  errorout + "Missing wizard.library:\\nThis library is required in version 42 by this IDE.\\n\\n"
  ende = True
EndIf

If dos_CheckLib{"reqtools.library",38} = False             ; needed for PED and REDDebugger
  errorout + "Missing reqtools.library:\\nThis library is required in version 38 by the IDE.\\n\\n"
  ende = True
End If

If dos_CheckLib{"ted.library",1} = False                   ; needed for PED and REDDebugger
  errorout + "Missing ted.library:\\nThis library is required in version 1 by the IDE.\\n\\n"
  ende = True
End If

If dos_CheckLib{"disassembler.library",40} = False         ; only needed for REDDebugger
  errorout + "Missing disassembler.library:\\nThis library is required in version 40 for REDDebugger\\nASM debugging won't work.\\n\\n"
End If

If errorout <> ""                                          ; check if something to show
   errorout = "Please reinstall AmiBlitz3 or install the librarys in LIBS:\\n\\n"+errorout
   If ende
     errorout + "...that the IDE can Start!"               ; for abort
   Else
     errorout + "...for a full working IDE!"               ; for limited start
   End If
   error{!TRANS{errorout}}
End If

dbg_fid.l = -1 ; no debug file id yet!


;--- End if needed library or Version is not available
If ende Then Goto abnormal_exit                            ; remove Assigns
;------

If CLIMode

  ; We assume no error happened so far ...
  err.l      = False                                       ; indicate that an error has occured
  showhelp.l = False                                       ; show the CLI tool's help

  ; Set the default values of your CLI arguments.
  cli_progpath.s     = dos_GetProgDir{"Blitz3:"}
  cli_sourcefile.s   = ""
  cli_exefile.s      = ""
  cli_savefile.s     = ""
  cli_dumpfile.s     = ""
  cli_includepath.s  = ""
  cli_blitzlibpath.s = ""
  cli_debuginfo.l    = False
  cli_run.l          = False
  cli_dumpflags.l    = $FFFFFFFF
  cli_info.s         = ""
  cli_release.l      = False
  cli_numargs.l      = dos_GetNumArgs{}
  cli_gui.l          = False
  cli_dumpform.l     = 1 ; 0 = bin, 1 = ASCII
  cli_verbose.l      = 1
  If cli_numargs=0 Then showhelp=True

  ; Get the CLI arguments
  Repeat
    arg.s = dos_GetNextArg{}                               ; get the next CLI argument
    larg.s = LCase$(arg)                                   ; lower case the option string
    If Left$(larg,1)="-" Then larg = Right$(larg,FLen(larg)-1)
    Select larg
      Case "s" : larg="source"
      Case "e" : larg="exe"
      Case "d" : larg="debug"
      Case "r" : larg="release"
      Case "h" : larg="help"
      Case "v" : larg="verbose"
    End Select

    Select larg
      Case "exe"      : cli_exefile     = dos_GetNextArg{}
      Case "source"   : cli_sourcefile  = dos_GetNextArg{}
      Case "save"     : cli_savefile    = dos_GetNextArg{}
      Case "debug"    : cli_debuginfo   = True
      Case "run"      : cli_run         = True
      Case "release"  : cli_release     = True
      Case "ped"      : cli_gui         = True
      Case "dform"    : cli_dumpform.l  = Vallong(dos_GetNextArg{})
      Case "dump"     : cli_info        = LCase$(dos_GetNextArg{})
                        cli_dumpfile    = dos_GetNextArg{}
                        cli_dumpflags   = $0
                        If Instr(cli_info,"all"  ) Then cli_dumpflags | $FFFFFFFF
                        If Instr(cli_info,"token") Then cli_dumpflags | #DUMPFLG_TOKENS
                        If Instr(cli_info,"label") Then cli_dumpflags | #DUMPFLG_LABELS
                        If Instr(cli_info,"var"  ) Then cli_dumpflags | #DUMPFLG_VARS
                        If Instr(cli_info,"const") Then cli_dumpflags | #DUMPFLG_CONSTANTS
                        If Instr(cli_info,"func" ) Then cli_dumpflags | #DUMPFLG_FUNCTIONS
                        If Instr(cli_info,"macro") Then cli_dumpflags | #DUMPFLG_MACROS
                        If Instr(cli_info,"type" ) Then cli_dumpflags | #DUMPFLG_NEWTYPES
                        If Instr(cli_info,"lib"  ) Then cli_dumpflags | #DUMPFLG_LIBS
                        If cli_dumpflags = $0
                         err=True
                         NPrint "\\1b[1m*** ERROR: Invalid flags for dumpfile \\22",cli_info,"\\22 specified!\\1b[0m"
                        End If
      Case "verbose"  : cli_verbose     = Vallong(dos_GetNextArg{})
      Case "h"        : showhelp        = True             ; show the help and quit
      Default
        If arg><""
          NPrint "\\1b[1m*** ERROR: Unknown option \\22",arg,"\\22 specified!\\1b[0m"
          err = True
        End If
    End Select
  Until arg = "" OR err=True          ; until we processed all arguments

  ; Show the help if something went wrong or help was requested
  If err><False OR showhelp = True
    If showhelp
    NPrint "AmiBlitz ",Peek.s(?myversion)
    NPrint "\\nSyntax: AmiBlitz3 [options]"
    NPrint "\\nOptions:"
    NPrint "  -(s)ource <file>    : input source code filename (bb2, ab2 or ab3)"
    NPrint "  -(e)xe <file>       : output executable filename"
    NPrint "  -(d)ebug            : compile with debug info"
    NPrint "  -(r)elease          : create release executable (size optimized)"
    NPrint "  -run                : run compiled program"
    NPrint "  -dump <info> <file> : dump compiler internals to file"
    NPrint "                        (info=all|token|label|var|func|const|macro|type|lib)"
    NPrint "  -dform <n>          : format of compiler internals dump (0=bin, 1=ASCII; default=1)"
    NPrint "  -PED                : start AmiBlitz3 IDE (PED)"
    NPrint "  -save <file>        : re-save source code (convert format, if needed)"
    NPrint "  -(v)erbose <n>      : set verbose level (0, 1 or 2; default=1)"
    NPrint "  -(h)elp             : show this help"
    NPrint "\\nExample:"
    NPrint "  AmiBlitz3 -s \\22DH0:Sourcecodes/MyProgram.ab3\\22 -e RAM:MyProgram.exe"
    NPrint "\\nNote: To start the AmiBlitz3 IDE, run from Workbench or with -PED option."
    End If
    Pop If:Pop If
    Goto abnormal_exit
  End If

  If cli_gui        Then CLIMode = False : error_SetFlags{#error_requester}
  If cli_sourcefile Then Poke.s ?str_tempfilename,cli_sourcefile
End If

Poke.l ?CLIMode,CLIMode

; --
; -- Konstanten- und Variableninitialisierung
.DEFINITIONS
  #function_typecheck         = 1
  #function_support_returntype= 1
  #continue_on_error          = 1
  #maxincludes                = 128
  #64bitconstant              = 0
  #funcscan                   = 0                                    ; if 1 functions are add at beginning
  #WZ_singletable             = 1
;  #newoptions                 = 1                                    ; the new compiler option requester
  #debugmacro                 = 1                                    ; macros can debug
  #more6string                = 1                                    ; more than 6 strings can use
  #errorconstant              = 0                                    ; constants can not declare twice
  #types64                    = 1                                    ; types can use 64kb
  #longbranch                 = 1                                    ; if thens have no 32kb limit
  #stopignore                 = 1                                    ; ignore stop on release build
  #debugtrap                  = 0                                    ; only use if you want debug the trap#15 compile feature
  #fpudebug                   = 1                                    ; allow fpu code for debugger
  #optibreak                  = 0                                    ; set breakpoint on all optimzer positions
  #moremem                    = 40
  #isfunc                     = $21                                  ; increase if morepars than 14
  #funcentry_extend           = 16+48                                ;+16 need for 10 pars +44 need for 10 par long of type addr and return type +4 gap for maybe later 4 par enhance
  #funcstruct_returntype      = $2a
  #funcstruct_parametertype   = $2e
  #doublecheck                = $00080d64

  Dim incdim.s (#maxincludes)
  Dim incline.l(#maxincludes)


  MinByteSgnd                 EQU $80
  MaxByte                     EQU $FF
  MaxWordSgnd                 EQU $7FFF
  MinWordSgnd                 EQU $8000
  MaxWord                     EQU $FFFF
  MemfPublic_MemfClear        EQU $10001
  _custom                     EQU $DFF000
  COLOR00                     EQU $180
  MaxIntSgnd                  EQU $7FFFFFFF
  HUNK_RELOC_16__MODE_OLDFILE EQU $3ED
  HUNK_RELOC_8__MODE_NEWFILE  EQU $3EE
  hashsize                    EQU $3ff                     ;$ff=256,$1ff=512,$3ff=1024,$7ff=2048,$fff=4096

; --
; -- Macro definitions
.MACROS

Macro hashalgo                                             ;d1 currentchar d0 hashvalue
  MULS.w #5,d0                                             ;important for fast hash speed
  ADD.l d1,d0
End Macro


Macro newcalc
   MOVE.l destpointer,a1
   MOVE.l #$4e754e75,(a1)+
   MOVEQ #0,d1
   MOVE.w (a0)+,d1
   CMP.l #$303c,d1                                         ;move.w    ;d0
   BNE 'nw1
   MOVE.w (a0)+,d0
   CMP.w #$48c0,(a0)                                       ;ext.l
   BNE 'nw2
   EXT.l d0
   ADDQ.l #2,a0
BRA 'nw2

 'nw1
   CMP.l #$323c,d1                                         ;move.w     ;d1
   BNE 'nw1_w
   MOVE.w (a0)+,d1
   CMP.w #$48c1,(a0)                                       ;ext.l
   BNE 'nw2
   EXT.l d1
   ADDQ.l #2,a0
BRA 'nw2

 'nw1_w
   CMP.l #$203c,d1                                         ;move.l #,d0
   BNE.s 'nw2_w                                            ;fault
   MOVE.l (a0)+,d0
BRA 'nw2

  'nw2_w
;   CMP.l #$243c,d1                                         ;move.l #,d2
;   BNE 'nw2_d2
;   MOVE.l (a0)+,d2
;BRA 'nw2

 'nw2_d2
   CMP.l #$223c,d1                                         ;move.l #,d1
   BNE.s 'Fals`@                                           ;fault
   MOVE.l (a0)+,d1

 'nw2
;   CMP.w #$243c,(a0)
;   BNE.s 'nod2`@                                           ;no d2 load
;   MOVE.l 2(a0),d2
;   ADDQ.l #6,a0

 'nod2`@
   CMP.w #$223c,(a0)
   BNE.s 'nod1`@                                           ;no d1 load
   MOVE.l 2(a0),d1
   ADDQ.l #6,a0

 'nod1`@
;   CMP.w #$d081,(a0)
;   BNE.s 'noadd_l_d1                                       ;no add l d1,d0
;   ADD.l d1,d0
;   ADDQ.l #2,a0

; 'noadd_l_d1
   CMP.w #$d0bc,(a0)
   BNE.s 'noadd_i_d0                                       ;no add.l #,d0
   ADDQ.l #2,a0
   ADD.l (a0)+,d0
BRA 'nosub_w_d2

  'noadd_i_d0
   CMP.w #$90bc,(a0)
   BNE.s 'nosub_i_d0                                        ;no sub.l #,d0
   ADDQ.l #2,a0
   SUB.l (a0)+,d0
BRA 'nosub_w_d2

 'nosub_i_d0
   CMP.w #$8081,(a0)
   BNE.s 'noor_d1_d0                                       ;no or.l d1,d0
   ADDQ.l #2,a0
   OR.l d1,d0
BRA 'nosub_w_d2

 'noor_d1_d0
   CMP.w #$d07c,(a0)
   BNE.s 'noadd_w_d1                                       ;no add w #,d0
   ADDQ.l #2,a0
   ADD.w (a0)+,d0

 'noadd_w_d1
   CMP.l #$4c3c0800,(a0)
   BNE.s 'nomul_l_d1                                       ; no mul.l #,d0
   MOVE.l d1,-(a7)
   ADDQ.l #4,a0
   MOVE.l (a0)+,d1
   MULS.l d1,d0
   MOVE.l (a7)+,d1

 'nomul_l_d1
   CMP.w #$94bc,(a0)
   BNE.s 'nosub_i_d2                                       ;no sub l #,d2
   ADDQ.l #2,a0
   SUB.l (a0)+,d2

 'nosub_i_d2
   CMP.w #$9081,(a0)
   BNE 'nosub_l_d1
   SUB.l d1,d0                                             ;no sub l d1,d0
   ADDQ.l #2,a0

 'nosub_l_d1
;   CMP.w #$9041,(a0)
;   bne 'nosub_w_d2
;   SUB.w d1,d0                                             ;no sub w d1,d0
;   ADDQ.l #2,a0

; 'nosub_w_d1
;   CMP.w #$9282,(a0)
;   BNE 'nosub_l_d2
;   SUB.l d2,d1                                             ;no sub l d2,d0
;   ADDQ.l #2,a0

; 'nosub_l_d2
;   CMP.w #$9242,(a0)
;   BNE'nosub_w_d2
;   SUB.w d2,d1                                             ;no sub w d2,d1
;   ADDQ.l #2,a0

 'nosub_w_d2
   CMP.w #$4480,(a0)
   BNE.s 'noneg`@                                          ;no neg
   NEG.l d0
   ADDQ.l #2,a0

 'noneg`@
   CMP.w #$48c0,(a0)
   BNE 'noext
   EXT.l d0
   ADDQ.l #2,a0

 'noext
   CMP.w #$b081,(a0)                                       ;nocmp
   BNE 'nocmp
   ADDQ.l #2,a0
   CMP.w #$57c0,(a0)
   BNE 'se1
   CMP.l d1,d0
   SEQ d0
BRA 'sw1

 'se1
   CMP.w #$56c0,(a0)
   BNE 'Fals`@
   CMP.l d1,d0
   SNE d0

 'sw1
   EXT.w d0
   ADDQ.l #6,a0

 'nocmp
   CMP.w #$4e75,(a0)                                       ;is last instruction
   BNE 'Fals`@
   TST.w regnum
   BNE 'Fals`@
   MOVEQ #1,d1
BRA.s 'ok`@

 'Fals`@
   MOVEA.l forthsp(PC),A0
   MOVEQ #0,d1

 'ok`@
End Macro


Macro compare3
   TST.w D0
   BEQ.w 'lab1`@
   CMP.w #$3A,D0
   BEQ.w 'lab1`@
   CMP.w #$2C,D0

 'lab1`@
End Macro


Macro compare1
  CMP.w #$7A,D0
   BHI 'lab2`@
  CMP.w #$41,D0
   BCS 'lab2`@
  CMP.w #$61,D0
   BCC 'lab1`@
  CMP.w #$5A,D0
   BHI 'lab1`@

 'lab1`@
  CMP.w D0,D0

 'lab2`@
End Macro


Macro fget
  MOVEQ #0,d0

 'lab1`@
  MOVE.l a5,lastsourcepos
  MOVE.b (a5)+,d0
  TST.w instringon
  BNE 'lab2`@
  CMP.b #$20,d0
  BEQ 'lab1`@
  CMP.b #";",d0
  BNE 'lab2`@
  MOVEQ #0,d0

 'lab2`@
  MOVE.w d0,lastchar
End Macro


Macro fget2
  MOVEQ #0,d0

 'lab1`@
  MOVE.l a5,lastsourcepos
  MOVE.b (a5)+,d0
  TST.w instringon
  BNE 'lab2`@
  CMP.b #$20,d0
  BEQ 'lab1`@
  CMP.b #";",d0
  BNE 'lab2`@
  MOVEQ #0,d0

 'lab2@`
  MOVE.w d0,lastchar
End Macro


Macro compare2
  CMP.w #$30,D0
   BCS.w 'lab1`@
  CMP.w #$39,D0
   BHI.w 'lab1`@
  CMP.w D0,D0

 'lab1`@
End Macro




Statement activategadget{ag$}                              ;ag$ = gadget
  ActivateGadget_ WZGadAddr (ag$),WZWindowAddr,0
End Statement

Function.s Get_Libinfo{addr_libnum.l}
  ; diese Funktion holt aus der nativen lib im Speicher den ersten Tokennamen
  lib_ab2.b = False : lib_os.b = False
  addr_counter.l = addr_libnum
  skip.l = 0
  If addr_counter=0
    error{"INTERNAL: \\__THIS_FUNCTION: Invalid pointer!"}
    Function Return ""
  End If
;  runner.l = 0
;  !cout{Hex$(addr_counter)}
  Repeat
    mem.l = Peek.l(addr_counter)
;    If (runner MOD 8 = 0) AND (runner < $80)
;        !cout{Hex$(addr_counter)+": "+Hex$(mem) + " " + Hex$(Peek.l(addr_counter + 4))+"   "+Hex$(mem LSR 16)}
;    EndIf
;    runner + 2
    addr_counter + 2
    If (mem = $0000ffff) Then lib_ab2= True : skip = 8
    If (mem LSR 16) = $ffe2
;      !cout{"found."}
      lib_os = True
      skip = 10
      If Peek$(addr_counter+skip) = "" Then skip + 4
    EndIf
  Until (lib_ab2=True OR lib_os = True) OR (addr_counter>addr_libnum + $400)
  ;!cout{Hex$(addr_libnum),Peek$(addr_counter + skip),Peek$(addr_counter + skip+1),Peek$(addr_counter + skip+2)   }
  If (addr_counter>addr_libnum + $400)
;    !cout{"error"}
    Function Return ""
  Else
    Function Return Peek$(addr_counter + skip)
  EndIf
End Function



;d2 mode  1=byte 2 =word 3=long 4=quick 5=float  bit 15 newtype
;a3=current instruction struct
;34(a3)=Instruction Token

;SECTION "Segment0",CODE
;cnop 0,4
       ;labelbase   $0
                    ; $4 mode 0 = label 1 = constant
                    ; $8 addr/label value/constant
                    ; $c nexthash
                    ; $12 Bytecount
                    ; $13 name

       ;templabel   ; $0 next
                    ; $4 addr in code
                    ; $8 = resultmode 5 = word
                    ; $a
                    ; $e templabelsize
                    ; $10 addr in source or short string
       ;variable    ; $0
                    ; $4 offset of a5
                    ; $8 size
                    ; $a type addr add+4 for findvariable2 to find offset for Newtype
      ;typestruct
      ;             ; $4 Adress to typeitemlist or 1-7 if no structure
                    ; $8 size of newtype
      ;typeitemlist
                    ; $0 * nexttypeentry
                    ; $4.w Offset
                    ; $6
                    ; $8
                    ; $a addr to variable
                    ; $e name

; ------------------------------------------ BEGIN OF MAINPROGRAM -------------------------------
.MAINPROGRAM
  !asm
  MOVEA.l _execbase,A6
  MOVEM.l d0/a0,-(a7)

  MOVEQ #127,d0
  LEA chartab,a0

 'l12
    MOVE.b #1,128(a0)
    CLR.b (a0)+
  DBF d0,'l12

  LEA chartab,a0
  MOVE.b #1,(a0)
  MOVE.b #1,","(a0)
  MOVE.b #1,";"(a0)
  MOVE.b #1,":"(a0)
  MOVE.b #1,"("(a0)
  MOVE.b #1,")"(a0)
  MOVE.b #1,"="(a0)
  MOVE.b #1,"+"(a0)
  MOVE.b #1,"-"(a0)
  MOVE.b #1,"*"(a0)
  MOVE.b #1,"/"(a0)
  MOVE.b #1,"$"(a0)
  MOVE.b #1,"%"(a0)
  MOVE.b #1,"."(a0)
  MOVE.b #1,"["(a0)
  MOVE.b #1,"]"(a0)
  MOVE.b #1,"{"(a0)
  MOVE.b #1,"}"(a0)
  MOVE.b #1,"\"(a0)
  MOVE.b #1,">"(a0)
  MOVE.b #1,"<"(a0)
  MOVE.b #1,"&"(a0)
  MOVE.b #1,"|"(a0)
  MOVE.b #1,"^"(a0)
  MOVE.b #1,$7e(a0)
  MOVE.w #$0101,1(a0)

  LEA instrtab,a0
  MOVE.l #labelhash-instrtab,d0
  ASR.l #2,d0
  SUBQ.l #1,d0

 'l10
   CLR.l (a0)+
   SUBQ.l #1,d0
  BNE 'l10

  LEA allowtab,a0
  MOVE.l #255,d0

 'la1
    CLR.b (a0)+
  DBF d0,'la1

  LEA allowtab,a0
  MOVE.b #1,$7d(a0)
  MOVE.b #1,$7c(a0)
  MOVE.b #1,$44(a0)
  MOVE.b #1,$45(a0)
  MOVE.b #1,$b9(a0)
  MOVE.b #1,$89(a0)
  MOVE.b #1,$ce(a0)
  MOVE.b #1,$cf(a0)
  MOVE.b #1,$d0(a0)
  MOVE.b #1,$cd(a0)
  MOVEQ #0,d0

  MOVEA.l _execbase,a6
  ;LEA _intuiname,a1
  ;JSR _OpenLibrary(a6)                                    ; open intuition.library
  ;MOVE.l d0,_intuibase

  MOVE.l #$10000,d0
  MOVE.l #80000,d1
  MOVE.l d1,d2
  JSR _CreatePool(a6)                                      ; alloc memory for own stuff
  MOVE.l d0,mempool
  MOVEM.l (a7)+,d0/a0
  TST.l mempool
  BEQ shutdown_compiler

  MOVEA.l $114(A6),A4                                      ; get adress of this.Task-Structure
  MOVE.l A4,ptr_ThisTask

  BSR.w open_doslibrary
  BEQ.w shutdown_compiler

  MOVE.l D2,stacksize

  ; --
  ; -- get the last token
  MOVEQ.l #$00,D0
  LEA tokens,A0

 JL_0_2D0E:
    ADDQ.w #1,D0
    MOVE.l (A0),D1
    BEQ.w JL_0_2D1C
    MOVEA.l D1,A0
BRA.w JL_0_2D0E

 JL_0_2D1C:
  MOVE.l A0,end_of_tokenlist

  BSR.w makeasmtable
  MOVE.w #$FFFF,returncode_org                             ;#-1,returncode

  BSR.w open_mathlibrary
  BEQ.w freemem_and_quit4

  MOVE.l constmaxpc,D0
  MOVEQ.l #$02,D1                                          ;chipmem            ;01 org source
  MOVEA.l _execbase,A6
  JSR _AllocMem(A6)                                        ;mem for branch routine
  MOVE.l D0,constpcat
  BEQ.w freemem_and_quit3
  ADD.l constmaxpc,D0
  MOVE.l D0,constlibat

  MOVE.l macrobuffer_size,D0
  CMP.l #40000,d0
  BGE 'ok
    MOVE.l #40000,d0
    MOVE.l d0,macrobuffer_size

 'ok
  ADDQ.l #4,d0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  JSR _AllocMem(A6)                                        ;macro mem
  MOVE.l d0,a0
  MOVE.l macrobuffer_size,(a0)+
  MOVE.l a0,d0
  MOVE.l D0,ptr_macrobuffer_begin
  BEQ.w freemem_and_quit2
  ADD.l macrobuffer_size,D0
  MOVE.l D0,ptr_macrobuffer_end

  TST.l CLIMode
  BEQ load_ped

  ;/* Emulate PED Environment */
  !basic
  succ.l = InitEmulatedPED{}
  GetD0 succ
  !asm
  TST.l d0
  BEQ freemem_and_quit
JMP skip_ped

.load_ped
  ; --
  ; -- load_PED
  MOVE.l #str_pedfile,D1                                   ; Load PED
  MOVEA.l _dosbase,A6
  JSR _LoadSeg(A6)
  MOVE.l D0,ptr_seg_ped
  BEQ.w freemem_and_quit

  ; --
  ; -- calulate entryaddress for starting segment
  MOVEA.l D0,A2
  ADDA.l A2,A2
  ADDA.l A2,A2
  ; -- start_PED
  LEA teddata,a1                                           ;lea edstruct,A1
  MOVE.l #"TEDY",d1
  JSR 4(A2)                                                ; Run PED

  MOVE.l A0,ped_startup_addr                               ; PED returns address of routine "startup_code"
  MOVE.l A1,comdata                                        ; PED returns address of comdata-area in A1
;  MOVE.w $7b2(a1),d0                                       
  !ComData_GetW{comWord_PEDIsAvailable,D0}                 ; if PED_IsAvailable=0, quit AmiBlitz
  BEQ.w unload_ped


.skip_ped
  !ComData_GetL{comData_Magic,D0}
  CMP.l #$7E3A3A7E,D0                                      ;"~::~",D0
  BNE unload_ped

  ; -- extent_comdatas:
  !ComData_SetL{comPtr_Trap15            ,#directTrap15 }
  !ComData_SetL{comPtr_DirectBuffer      ,#directbuffer}
  !ComData_SetL{comPtr_MacroBase         ,#macrobase}
  !ComData_SetL{comPtr_VarBase           ,#varbase }
  !ComData_SetL{comPtr_InstrBase         ,#instrtab}
  !ComData_SetL{comPtr_LibPointer        ,#libpointer}
  !ComData_SetL{comPtr_CompilerVersion   ,#myversion }
  !ComData_SetL{comPtr_VersionInformation,#versioninformation}
  !ComData_SetL{comPtr_NumberOfBuilds    ,#number_of_builds}
  !ComData_SetL{comFunc_SaveSource       ,#ab3_SaveSource}
  !ComData_SetL{comFunc_LoadSource       ,#ab3_LoadSource}
  !ComData_SetL{comFunc_ClearSource      ,#ab3_ClearSource}

  CLR.w returncode_org
;  MOVE.l $2C(A1),_intuibase                                ; intuibase of PED
  !basic
  If CLIMode
    If cli_verbose>=2 Then NPrint !TRANS{"Loading BlitzLibs."}
  End If
  !asm

  ; --
  ; -- load all acidlibs, deflibs and userlibs
  TST.b start_without_libs
  BNE skip_loading_libs
    BSR.w call_setpointerbusy
    MOVE.l #$FFFFffff,linenumat
    BSR.w get_libraries
    JSR init_libraries
    BSR.w init_buffers
    BSR.w call_setpointernormal

 skip_loading_libs:
  ; --
  ; --
  MOVEQ.l #-$01,D0
  MOVEA.l _execbase,A6
  JSR _AllocSignal(A6)
  MOVE.l D0,signalNum
  MOVEQ.l #$00,D1
  BSET D0,D1
  MOVE.l D1,signals

  ; --
  ; -- load_debugger:
  MOVE.l #str_defaultdbug,D1
  MOVEA.l _dosbase(PC),A6
  JSR _LoadSeg(A6)
  MOVE.l D0,ptr_seg_debugger
  TST.l d0
  BNE ok_12
    !basic
    error{!TRANS{"The Debugexecutor `Defaultdbug` was not found.\\nDebugging is not possible."}}
    !asm

 ok_12:
  TST.l CLIMode
  BEQ run_ped
  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ AmiBlitz3 Command Line Interface                                           /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  !basic
  err.l = False

  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ Resolve pathes                                                             /
  ;/ Get the full qualified path for source code and executable file            /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  If cli_sourcefile
    lock.l = Lock_(&cli_sourcefile,#ACCESS_READ)
    If lock
      NameFromLock_ lock,&cli_tempstr,1024
      cli_sourcefile.s = Peek.s(&cli_tempstr)
      UnLock_ lock
    End If

    If cli_exefile
      SetCurrentDir{dos_PathPart{cli_sourcefile}}
      path.s = dos_PathPart{cli_exefile}
      lock.l = Lock_(&path,#ACCESS_READ)
      If lock
        NameFromLock_ lock,&cli_tempstr,1024
        path.s = Peek.s(&cli_tempstr)
        cli_exefile = dos_AddPart{path,dos_FilePart{cli_exefile}}
        UnLock_ lock
      End If
    End If
  End If

  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ Initialize Token Hashmap                                                   /
  ;/ Get the token hashmap to tokenize/detokenize source code files             /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  If cli_verbose>=2 Then NPrint "Initializing token hashmap."
  TokenHashMapFile.s = "Blitz3:System/TokenList.hashmap"
  *PreProcessor.preprocessor = preproc_Create{}
  Poke.l ?comPtr_PreProcessor,*PreProcessor
  preproc_LoadTokens{*PreProcessor,TokenHashMapFile}
  If *PreProcessor\tokens=#NULL
    If cli_verbose>=1 Then NPrint "No hashmap found (\\22"+TokenHashMapFile+"\\22), will be created..."
    preproc_QueryTokens{*PreProcessor}
    preproc_SaveTokens{*PreProcessor,TokenHashMapFile}
  End If

  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ Load and Compile Sourcecode                                                /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  If cli_sourcefile><"" AND err=False
    If cli_verbose>=2 Then NPrint "Loading sourcecode \\22",cli_sourcefile,"\\22."
    succ=LoadSource{cli_sourcefile}
    If succ
      If cli_savefile=""                                                        ; added check if -save is used then we skip compiling and only save the source  tomsmart1
        If cli_verbose>=1 Then NPrint "Compiling "+cli_sourcefile+"..."
        comerr.l = CompileSource{cli_exefile,cli_debuginfo,cli_release}

        If comerr
        ; NPrint "*** ERROR: Error compiling source!"
        Else
        ; success!!!
        End If
      EndIf
    Else
      If cli_verbose>=0 NPrint "\\1b[1m*** ERROR: Unable to read source file!\\1b[0m" : err=True
    End If
  EndIf

  If cli_savefile><"" AND err=False
    If cli_verbose>=2 Then NPrint "Saving Sourcefiles as "+cli_savefile
    SaveSource{cli_savefile}
  End If

  If cli_dumpfile><"" AND err=False
    If cli_verbose>=2 Then NPrint "Saving dumpfile."
    DumpFile{cli_dumpfile,cli_dumpflags,cli_dumpform}
  End If

  If cli_run
    If comerr=False
      If cli_exefile
        If cli_verbose>=1 Then NPrint "Compiling "+cli_sourcefile+"..."
        comerr.l = CompileSource{"",cli_debuginfo,cli_release} ; re-compile for launch!
      End If
      If cli_verbose>=1 Then NPrint "Running program..."
      RunSource{}
      Repeat
        CLR.l d0
        !ComData_GetB{comByte_RunningFlag,D0}
        running.l = PutD0
        If running Then Delay_ 50
        ;NPrint "Runnign flag: ",running
      Until running=False
      If Peek.l(?_runerror)
        If cli_verbose>=0 NPrint "\\1b[1m*** ERROR: Unable to run compiled program!\\1b[0m" : err=True
      End If
    End If
  End If


  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ Cleanup and prepare for exit                                               /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  preproc_Free{*PreProcessor} : *PreProcessor=#NULL
  If cli_verbose>=2 Then NPrint "Exit AmiBlitz3."
  DeinitEmulatedPED{}

  !asm
JMP terminate_ab3


.run_ped
  ; Try to open the catalog and used it for the WizardGUI
  !basic
    *MyCatalog.l=OpenCatalogA_(0,"Compiler.catalog",0)
    ;Set Tags so Wizardlibrary use the catalog File
    If *MyCatalog
       WZTags #SFH_Catalog,*MyCatalog,#TAG_DONE,0,#TAG_END,0
    EndIf
    ;init Wizard GUI
    WZLoadGUI ?wzgui
  !asm

  ; -- jump to the address ped returned before and pass a sourcename in A0
  MOVEA.l ped_startup_addr,A1
  LEA str_tempfilename,A0
  JSR (A1)
  ; --
  ; -- PED has been quit now ...
  ; --

  ; If we used a catalog so close it
  !basic
    If *MyCatalog Then CloseCatalog_ *MyCatalog
  !asm
                                                                                                                                                                                                                                                        
.terminate_ab3
  MOVE.l signalNum,D0
  MOVEA.l _execbase,A6
  JSR _FreeSignal(A6)

  MOVE.l ptr_seg_debugger,D1
  BEQ.b skip_unload_debugger
    MOVEA.l _dosbase(PC),A6
    JSR _UnLoadSeg(A6)

 skip_unload_debugger:
  BSR.w Aclearallvars
  BSR.w free_residents
  JSR free_blitzlibs

 unload_ped:
  MOVE.l ptr_seg_ped,D1
  BEQ freemem_and_quit
  MOVEA.l _dosbase(PC),A6
  JSR _UnLoadSeg(A6)

 freemem_and_quit:
  BSR.w freeallox
  MOVEA.l ptr_macrobuffer_begin,A1
  MOVE.l -(a1),D0
  ADDQ.l #4,d0
  MOVEA.l _execbase,A6
  JSR _FreeMem(A6)

 freemem_and_quit2:
  MOVEA.l _dosbase,A1
  MOVEA.l _execbase,A6
  JSR _CloseLibrary(A6)

  MOVEA.l constpcat,A1
  MOVE.l constmaxpc,D0
  MOVEA.l _execbase,A6
  JSR _FreeMem(A6)

 freemem_and_quit3:
  MOVEA.l _mathffpbase,A1
  MOVEA.l _execbase,A6
  JSR _CloseLibrary(A6)

 freemem_and_quit4:
  ;MOVE.w returncode_org,D0
  ;EXT.l D0
;BRA shutdown_compiler

 shutdown_compiler:
;  MOVE.l ptr_wbmessage,D0          ; deactivate old asm code to replay the Workbenchmessage because we use the Basiccommand WBStartup to handle it  tomsmart1
;  BEQ.w JL_0_12A                   ;       "
    MOVEA.l _execbase,A6
    MOVE.l mempool,a0
    JSR _DeletePool(a6)
    CLR.l pushat
;    JSR _Forbid(A6)                ;        "
;    MOVEA.l ptr_wbmessage,A1       ;        "
;    JSR _ReplyMsg(A6)              ;        "
;    JSR _Permit(A6)                ; seems this got lost over the years to actived the Multitasking  tomsmart1

 JL_0_12A:
  JSR free_unusedfunctions
  MOVEQ #0,d0

 abnormal_exit
  !exitasm
  If dynassign<>""
    If *AssignSema
      ReleaseSemaphore_ *AssignSema
      If (AttemptSemaphore_ (*AssignSema))                 ; we are the exclusive owner of the sema now!
        dos_RemAssign{"LIBS:",dos_AddPart{dynassign,"Libs"}}
        dos_RemAssign{dynassign}
        RemSemaphore_ *AssignSema
        ReleaseSemaphore_ *AssignSema
        If *AssignSema\ss_Link\ln_Name Then FreeVec_ *AssignSema\ss_Link\ln_Name : *AssignSema\ss_Link\ln_Name = #NULL
        FreeVec_ *AssignSema
        *AssignSema = #NULL
      End If
    End If
  EndIf
  SetCurrentDir{cli_path}
  !coutclose
End
; ------------------------------------------ END OF MAINPORGRAM --------------------------------


;ptr_wbmessage:      Ds.l 1                   ; deactivate old asm code to replay the Workbenchmessage because we use the Basiccommand WBStartUp to handle it  tomsmart1
str_doslibrary:     Dc.b "dos.library",0 : Even
_dosbase:           Ds.l 1


.open_doslibrary:
  MOVEA.l _execbase,A6
  LEA str_doslibrary,A1
  JSR _OldOpenLibrary(A6)
  MOVE.l D0,_dosbase
RTS


.open_mathlibrary:
  MOVEA.l #str_mathffpname,A1
  MOVEA.l _execbase,A6
  JSR _OldOpenLibrary(A6)
  MOVE.l D0,_mathffpbase
RTS


.call_setpointernormal:
 ; MOVEA.l comdata,A0
 ; MOVEA.l $48(A0),A0
  !ComData_JMP{comFunc_SetNormalPointer}
 ;L_0_2EFE:
;JMP (A0)


.call_setpointerbusy:
 ; MOVEA.l comdata,A0
 ; MOVEA.l $4C(A0),A0
  !ComData_JMP{comFunc_SetBusyPointer}
 ;L_0_2F0A:
;JMP (A0)

ab3_SaveSource:
  !basic
  ab3save_filenameP.l = PutD0
  If ab3save_filenameP
    ab3save_filename.s = Peek.s(ab3save_filenameP)
;    error{"...as "+ab3save_filename}
    SaveSource{ab3save_filename}
  Else
    error{"INTERNAL ERROR: no filename passed in D0 to SaveSource{}!"}
  End If
  !asm
  RTS

ab3_LoadSource:
  !basic
  ab3save_filenameP.l = PutD0
  If ab3save_filenameP
    ab3save_filename.s = Peek.s(ab3save_filenameP)
    LoadSource{ab3save_filename}
  Else
    error{"INTERNAL ERROR: no filename passed in D0 to LoadSource{}!"}
  End If
  !asm
  RTS

ab3_ClearSource:
  !basic
  ClearSource{}
  !asm
  RTS

ab3_OpenConsole:
  !basic
  OpenConsoleFake{}
  !asm
  RTS


ab3_CloseConsole:
  !basic
  CloseConsoleFake{}
  !asm
  RTS


.call_menuentry:
  MOVE.w d6,menuitemdebug
  !basic
  menuitemx.l = Peek.w(?menuitemdebug)
  If menuitemx>16 OR  menuitemx<0
    error{"Called invalid AB3 Menuitem #"+Str$(menuitemx)+"!"}
    menuitemx=0
  End If
  Poke.w ?menuitemdebug,menuitemx
  !asm
  MOVE.w menuitemdebug,d6

  ; D6: menuitem
  MOVE.l A5,firstitem_
  MOVE.w D7,numlines_org
  MOVE.l d7,numlines
  LSL.w #2,D6
  LEA menu_items,A0
  MOVEA.l $0(A0,D6.W),A0
  MOVE.l #$FFFFffff,linenumat
  MOVE.l #$FFFFffff,compilelinecounter


 L_0_2F34:
  JSR (A0)
  MOVE.l compilelinecounter,D0
RTS

menuitemdebug: Dc.l 0

mempool                Dc.l 0
str_loaddebugmessage:  Dc.b "Debug module to load",0 : Even
dloaderr:             JSR handle_compileerror
                       Dc.b "Can't LoadSeg debug module!",0 : Even


.menu_loaddebugmodule:                                      ;menu_d org source
    ;select debug module
    ;
;  MOVEA.l comdata,A3
;  MOVEA.l $18(A3),A3                                       ; asl filerequest
  !ComData_GetL{comFunc_ASLFileRequest,A3}
  LEA str_loaddebugmessage,A2
  LEA str_blitz3assign,A0
  LEA str_temp_debugmodulename,A1

 L_0_30FC:                                                  ;??looks like not used anymore??
  JSR (A3)

  BEQ.w menu_loaddebugmodule_noload
  MOVE.l D0,ptr_temp_debugmodule
  BSR.w call_setpointerbusy
  MOVE.l A7,errstack
  MOVE.l #menu_loaddebugmodule_noload,errcont
  MOVE.l ptr_temp_debugmodule,D1

  MOVEA.l _dosbase(PC),A6
  JSR _LoadSeg(A6)
  MOVE.l D0,D7
  BEQ.w dloaderr
  MOVE.l ptr_seg_debugger,D1
  BEQ.b menu_loaddebugmodule_ndseg
  MOVEA.l _dosbase(PC),A6
  JSR _UnLoadSeg(A6)
  BSR.w call_setpointernormal

 menu_loaddebugmodule_ndseg:
  MOVE.l D7,ptr_seg_debugger

 menu_loaddebugmodule_noload:
RTS


str_request_exename:   Dc.b "Name of Executable to Create:",0 : Even                        ;xtext org source
exepath:               Ds.l 48                             ;Ds.b #MAX_STRINGSIZE ; Ds.l 48  ;xpath  dcb.b 192,0 org source
exefilename:           Ds.l 48                             ;Ds.b #MAX_STRINGSIZE ; Ds.l 48  ;xname  dcb.b 192,0 org source
ptr_newexefilename:    Dc.l 0                                                               ;execname org


.menu_newcreate
  !basic
  exepath.s = Peek.s(?exepath)
  exefile.s = Peek.s(?exefilename)
  exefile.s = dos_AddPart{exepath,exefile}
  Poke.s ?tempspace,exefile
  !asm
;  LEA exepath,a0
;  LEA exefilename,a1
;  TST.b (a1)
;  BEQ menu_createexecutable
;
;  LEA tempspace,a1
; 'l10
;  MOVE.b (a0)+,(a1)+
;  BNE 'l10
;  SUBQ.l #1,a1
;  CMP.b #":",-1(a1)
;  BEQ 'lw1
;  MOVE.b #"/",(a1)+

; 'lw1
;  LEA exefilename,a0

; 'l20
;  MOVE.b (a0)+,(a1)+
;  BNE 'l20
  LEA tempspace,a0
  MOVE.l a0,d0
BRA newcreate2


.menu_createexecutable:
    ;compile/save
    ;
  !basic
  request_exename.s = Peek.s(?str_request_exename )
  request_exename   = !TRANS{request_exename}
  GetD0 &request_exename
  !asm
  MOVE.l D0,A2
  ;MOVEA.l comdata,A3
  ;MOVEA.l $18(A3),A3
  !ComData_GetL{comFunc_ASLFileRequest,A3}
  ;LEA str_request_exename,A2
  LEA exepath,A0
  LEA exefilename,A1

 L_0_332A:                                                ;??looks like not used anymore??
  JSR (A3)                                                 ;open ped filerequest
  BEQ.w cancel_createexe

 newcreate2:
  ADD.l #1,number_of_builds
    ;
    ;O.K.... Now to create it
  MOVE.l D0,ptr_newexefilename
  MOVE.w #-1,debugversion
  MOVE.w set_make_smallestcode,-(A7)
  ;bset #$7,make_smallestcode                              ;set optimize for create file    ;make small!

 'l1
    MOVE.w #1,makeexec
    JSR ab3_OpenDebugFile
    BSR.w startcompile
    JSR ab3_CloseDebugFile
    CMP.l #"NORE",reqmode
  BEQ 'l1

  TST.w anyerrs
  BNE.b menu_createexecutable__skip
  BSR.w savefile

 menu_createexecutable__skip:
  MOVE.w (A7)+,set_make_smallestcode

 cancel_createexe:
RTS


.do_CloseEd:
  MOVE.w #-1,flag_noPED
RTS


.do_NoCli:
  MOVE.w #-1,flag_noCLI
RTS

ab3_CloseDebugFile:
  !basic
    If dbg_fid>=0 Then file_Close{dbg_fid} : dbg_fid = -1
    Poke.w ?word_WriteDebugFileNow,0
  !asm
RTS

ab3_OpenDebugFile:
  !basic
  Poke.w ?word_WriteDebugFileNow,0
  If dbg_fid>=0
    file_Close{dbg_fid} : dbg_fid = -1
  End If
  If dbg_fid.l<0
    CLR.l d0
    !ComData_GetW{comWord_CreateDebugFile,D0}
    dbg_Create.l = PutD0
    If (dbg_Create) ; only when set!
      exefileP.l = Peek.l (?ptr_newexefilename)
      exefile.s = ""
      If exefileP Then exefile.s = Peek.s(exefileP)
      If exefile><""
        dbg_fid = file_Open{exefile+".dbg",#file_forcewrite}
        If dbg_fid>=0
          Poke.w ?word_WriteDebugFileNow,-1
        End If
      End If
      oldhunkoffset.l = -1
      oldfile.s       = ""
    End If
  End If
  !asm
RTS

ab3_WriteDebugFile:
TST.w word_WriteDebugFileNow
BEQ 'skipdebugfile
!basic
  If dbg_fid>=0
    pass.l          = Peek.w(?pass)
    makesmallest.b  = Peek.b(?make_smallestcode)               ; get the status of make_smallestcode  tomsmart1
    If pass><0 OR makesmallest=0                               ; check expand for makesmallestcode so if it not set that then the dbgfile will fill because we don't reach Pass>0  tomsmart1
      oldhunkoffset.l = hunkoffset.l
      oldfile.s       = codefile.s
      If Peek.w (?ininclude)>0
        codeline.l = Peek.l(?includeline);-1
        codefile.s = dos_FilePart{incdim(Peek.w(?ininclude)-1)}
      Else
        !ComData_LEA{comStr_SourceName,A0}
        MOVE.l A0,D0
        sourceP.l = PutD0
        codefile.s = Peek.s(sourceP)
        codeline.l = Peek.l(?linenumat)
      End If
      hunkoffset.l = Peek.l(?destpointer)-Peek.l(?destbufferstart)
      If oldhunkoffset><hunkoffset OR oldfile><codefile

        ;Format ""
;        *sourceLine.SourceLine_t = Peek.l(?sourceline)
;        If *sourceLine Then sourceLineText.s = Peek.s(&*sourceLine\Text) : Else sourceLineText = "NULL"
        ;file_WriteLine{dbg_fid,Hex$(hunkoffset)+" "+Str$(codeline)+" \\22"+codefile+"\\22"};::"+sourceLineText}

        *sourceLine.SourceLine_t = Peek.l(?sourceline)
        If *sourceLine
          MaxLen detokenline.s = 4096
         !ComData_GetL{comPtr_PreProcessor,include_preprocessor}
         *tn.preprocessor = Peek.l(?include_preprocessor)
          written.l = preproc_Detokenize{*tn,&*sourceLine\Text,&detokenline,*sourceLine\CharLength}
          If written>0 Then Poke.b &detokenline+written-1,0
          sourceLineText.s = Peek.s(&detokenline)
        Else
          sourceLineText = "NULL"
        End If

        file_WriteLine{dbg_fid,Hex$(hunkoffset)+" <"+codefile+"@"+Str$(codeline)+"> "+sourceLineText}

        ;Format ""
      End If
    End If
  End If
!asm
'skipdebugfile
RTS

word_WriteDebugFileNow: Dc.w 0

flag_noPED:  Ds.w 1                                        ;closeed org source
flag_noCLI:  Ds.w 1                                        ;nocli org source


Aclearcache:
  MOVEM.l D0-D1/A0-A1/A6,-(A7)
  MOVEA.l _execbase,A6
  JSR _CacheClearU(A6)
  MOVEM.l (A7)+,D0-D1/A0-A1/A6
RTS

getfunctionreturntype:
  MOVEM.l A2-A3,-(A7)
  CLR.b doublepeek
  MOVE.l A5,lastsourcepos
   JSR getchar
  CMP.w #$2E,D0
   BEQ.w JL_0_49B4b
  MOVEA.l defaulttype,A2
  CMP.w #$24,D0
   BNE.w JL_0_49CAb
  MOVEQ.l #$07,D1
BRA.w JL_0_49DEb

JL_0_49B4b:
  JSR getparameter2
  BEQ.w syntaxerrb
  LEA newtypebase,A2
  JSR findtype
  BNE.w notypeerrb

 JL_0_49CAb:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
CNIF #function_support_returntype
  MOVE.l a2,functionreturntype
  CMPI.l #$100,$4(A2)
  BLE.w 'isvar
  MOVEQ #3,d1
  BRA JL_0_49DEb
'isvar

CELSE
  CMPI.l #$100,$4(A2)                        ;check for normal var or type
  BLS.w illtypeerrb
CEND
  MOVE.w $6(A2),D1
  CMP.w #8,8(a2)
  BNE 'l1
  MOVE.b #1,doublepeek
'l1
JL_0_49DEb:
  MOVE.w D1,convsize
  MOVEM.l (A7)+,A2-A3
RTS

notypeerrb JMP notypeerr
illtypeerrb JMP illtypeerr
syntaxerrb JMP syntaxerr



;Aclearcache2:
;  MOVEM.l D0-D1/A0-A1/A6,-(A7)
;  movea.l _execbase,A6
;  MOVE    $128(A6),D0
;  BTST    #3,D0
;BRA.S   'l10
;;  MOVE.l a0,-(a7)
;;  JSR     -$96(A6)
;;  JSR     -$78(A6)
;;  MOVEA.L (A7)+,A1
;;  CPUSHL  Dc,(A1)
;;  cinvl   ic,(a1)
;;  ADDA #16,a1
;;  CPUSHL  Dc,(A1)
;;  cinvl   ic,(a1)
;;  ADDA #16,a1
;;  CPUSHL  Dc,(A1)
;;  cinvl   ic,(a1)
;;  ADDA #16,a1
;;  CPUSHL  Dc,(A1)
;;  cinvl   ic,(a1)
;;  ADDA #16,a1
;;  CPUSHL  Dc,(A1)
;;  cinvl   ic,(a1)
;;  ADDA #16,a1
;;  CPUSHL  Dc,(A1)
;;  cinvl   ic,(a1)
;;  JSR     -$7E(A6)
;;  JSR     -$9C(A6)
;;BRA 'l20

; 'l10
;   movea.l _execbase,A6
;   JSR CacheClearU(A6)

; 'l20
;   MOVEM.l (A7)+,D0-D1/A0-A1/A6
; RTS


.menu_compile_run:
  ADD.l #1,number_of_builds

  CLR.w debugversion
  CLR.w flag_noPED
  CLR.w flag_noCLI

 'l1
    MOVE.w #0,makeexec                                     ;MOVE.w #$FFFF,debugversion
    BSR.w startcompile
    CMP.l #"NORE",reqmode
  BEQ 'l1

 .menu_run:
  TST.w anyerrs
   BNE.w JL_0_3482

  MOVE.w flag_noPED(PC),D1
   BEQ.w skip_closingGUI
  ;MOVEA.l comdata,A0
  ;MOVEA.l -$8(A0),A0
  ;L_0_33C8:
  ;JSR (A0)
  !ComData_JSR{comFunc_CloseGUI}
BRA.b runprogram

 skip_closingGUI:
  ;LEA str_executing(PC),A0
  BSR.w compilerequester

runprogram:
  MOVEA.l _dosbase,A6
  LEA exepath,a0
  MOVE.l a0,d1
  MOVEQ #-2,d2
  JSR _Lock(a6)                                            ;lock
  MOVE.l d0,exelock
  MOVE.l #0,d1
  JSR _CurrentDir(A6)
  MOVE.l D0,lock_currentdir
  MOVE.l D0,D1
  JSR _CurrentDir(A6)
  CLR.l ptr_exetask

  ;;!basic
  ;processname.s = Peek.s(?str_process_name)
  ;processname   = !TRANS{processname}
  ;GetD0 &processname
  ;!asm
  ;MOVE.l d0,d1

  MOVE.l #str_process_name,D1
  MOVEQ.l #$00,D2
  MOVE.l #proc_seglist,D3
  LSR.l #2,D3
  MOVE.l stacksize,D4
  MOVEA.l _dosbase,A6
  JSR _CreateProc(A6)                                      ;runtask
  TST.l D0
   BEQ ErrorRunningProg

  !ComData_SetB{comByte_RunningFlag,#1}   ; this should be done here, straigt after it is clear that
                                          ; the program task is running
  TST.w flag_noPED
   BNE.b JL_0_344E
  BSR.w close_compilewin

 JL_0_344E:
  CLR.l firstlocal
  CLR.l firstglob
  MOVE.w flag_noPED(PC),D1
  BEQ.w skip_openGUI
  ;MOVEA.l comdata,A0
  ;MOVEA.l -$4(A0),A0                                       ; create_whole_gui in PED
  ;JSR (A0)
  !ComData_JSR{comFunc_CreateGUI}

 skip_openGUI:
;  MOVEA.l comdata,A0
;  MOVEA.l $50(A0),A0
;  MOVEA.l _intuibase,A6
;JMP _ActivateWindow(A6)

 JL_0_3482:
RTS

ErrorRunningProg:
MOVE.l #1,_runerror
BRA JL_0_344E

_runerror: Dc.l 0
lock_currentdir:    Ds.l 1                                          ;tasklock org source
ptr_exetask:        Ds.l 1                                          ;panictask org source
signalNum:          Ds.l 1                                          ;panicbit org source
signals:            Ds.l 1                                          ;panicmask org source
;str_process_name:   Dc.b "AB3 Program Process",0 : Even
str_process_name:   Dc.b "Blitz ][ Program Proc",0 : Even           ;procname org source
                    Ds.b 5                                          ;cnop 0,4 :dc.l 0   ;length org source
Even4

ptr_ThisTask:       Ds.l 1                                          ;length
.proc_seglist:      Ds.l 1                                          ;procstart org source ;next

   ;
;runtheprog:                                                        ;??looks like label not used??
  MOVEA.l $4,A0
  MOVE.l  $114(A0),ptr_exetask
   ;
  MOVEA.l _dosbase,A6
  MOVE.l exelock,D1
  JSR _CurrentDir(A6)

  ; -- set the running flag for IDE
;  MOVEA.l comdata,A0
;  MOVE.b #1,$1ea(a0)
  !ComData_SetB{comByte_RunningFlag,#1}
 ; !basic
 ; error{"I am the new thread!"}
 ; !asm

  ; -- optionally open the console
  MOVE.w flag_noCLI(PC),D1
   BNE.b skip_openconsole
 ; MOVEA.l comdata,A0
 ; MOVEA.l $3C(A0),A0                                       ; WBtoFront  etc.
;  JSR (A0)                                                 ;open hendrix
  !ComData_JSR{comFunc_OpenConsole}

 skip_openconsole:                                          ;.nocli org source
  BSR.w calcvbr
  MOVEA.l vbr,A0
  ;MOVE.l $84(a0),lasttrap1                                 ;activate for 68k low level trap
  ;MOVE.l #tokens,$84(A0)                                   ;set trap vectors  1
  ;MOVE.l newtype_string,$88(A0)                            ;2 activate for 68k low level trap
  ;MOVE.l #directTrap15,$BC(A0)                             ;15 for expression calculation
  CLR.w dirmode
  CLR.l firstglob
  CLR.l firstlocal
  ;MOVE.l destpointer,directbuffer                          ;direct buffer
  MOVE.l stacksize,D2
  MOVE.l #$624C745A,D7                                      ;#'bLtZ',d7 org source ;force cli-type run
  LEA str_cliarguments,A0                                   ;cli arguement
  MOVEA.l destbufferstart,A1
  BSR.w Aclearcache

 runthing:                                                 ;??Looks like not used??
  JSR (A1)                                                 ; execute compiled code  ;Run the thing!
  ;
  MOVEA.l vbr,A0
  ;MOVE.l lasttrap1,$84(a0)
  CLR.l firstglob
  CLR.l firstlocal
  MOVEA.l _dosbase,A6
  MOVE.l exelock,d1
  BEQ 'nolock
  JSR _UnLock(a6)

 'nolock
;  MOVEA.l comdata,A0
;  MOVE.b #0,$1ea(a0)                                       ; clear running flag
  !ComData_SetB{comByte_RunningFlag,#0}

  ; -- optionally close the console and bring ide to front
  MOVE.w flag_noCLI(PC),D1
   BNE.b skip_closeconsole
;  MOVEA.l comdata,A0
;  MOVEA.l $40(A0),A0                                       ; close the console window and bring IDE to front
;  JSR (A0)                                                 ;close the Hendrix IO Window
  !ComData_JSR{comFunc_CloseConsole}

 skip_closeconsole:                                        ;ended OK!
  MOVE.w #$0001,stopit
  MOVE.l signals(PC),D0
  MOVEA.l ptr_ThisTask,A1
  MOVEA.l _execbase,A6
  JSR _Signal(A6)
RTS


.calcvbr:
  MOVEA.l _execbase,A6
  MOVE.w $128(A6),D0
  MOVEQ.l #$00,D1
  ANDI.w #$F,D0

 calcvbr_loop:
    BEQ.b calcvbr__skip
    ADDQ.w #1,D1
    LSR.w #1,D0
BRA.b calcvbr_loop

 calcvbr__skip:
  MOVEQ.l #$00,D2
  CMP.w #$2,D1
   BCS.b calcvbr__skip2
  MOVEA.l _execbase,A6
  JSR _SuperState(A6)
  Dc.l $4E7A2801                                           ;movec vbr,D2
  JSR _UserState(A6)

 calcvbr__skip2:
  MOVE.l D2,vbr
RTS


.menu_reloadlibs:
  LEA instrtab,a0
  MOVE.l #labelhash-instrtab,d0
  ASR.l #2,d0
  SUBQ.l #1,d0

 'l10
  CLR.l (a0)+
  SUBQ.l #1,d0
  BNE 'l10
  BSR.w call_setpointerbusy
  BSR.w free_userlibs
  BSR.w scan_for_userlibs
  BSR.w JL_0_7082
BRA.w call_setpointernormal


.get_libraries:
  ; --
  ; -- get size of acidlibs/deflibs
  !basic
  Poke.l ?size_acidlibs, dos_GetFileSize{Peek$(?str_path_acidlibs)}

  deflibNameP.l = Peek.l(?deflib)
  If deflibNameP
    If Peek.s(deflibNameP)<>""
      Poke.l ?size_deflibs, dos_GetFileSize{Peek.s(Peek.l(?deflib))}
    Else
      Poke.l ?size_deflibs, dos_GetFileSize{Peek.s(?str_path_deflibs)}
    End If
  Else
    Poke.l ?size_deflibs, dos_GetFileSize{Peek.s(?str_path_deflibs)}
    error{"INTERNAL: Invalid deflib name pointer!"}
  EndIf
  !asm

 scan_for_userlibs:
  ; --
  ; -- search for the userlibs-path
  MOVE.l #str_path_userlibs,D1
  MOVEQ.l #-$02,D2
  MOVEA.l _dosbase,A6
  JSR _Lock(A6)
  MOVE.l D0,D7
   BEQ.w exit_get_libraries
  MOVE.l D7,D1
  MOVE.l #ptr_parameterstore,D2
  JSR _Examine(A6)
  TST.l D0
  BEQ.w unlock_and_exit_get_libraries
  MOVE.l fib_DirEntryType,D0
  BMI.w unlock_and_exit_get_libraries

  ; --
  ; -- hier wird rekursiv in str_path_userlibs nach libs gesucht ...
 scan_libsdrawer:
    MOVE.l D7,D1
    MOVE.l #ptr_parameterstore,D2
    MOVEA.l _dosbase,A6
    JSR _ExNext(A6)
    TST.l D0
     BEQ.w exit_scan_libsdrawer                            ; kein weiteres File

    MOVE.l fib_DirEntryType,D0                             ; positive for directoies, negative for files
    BPL.w scan_libsdrawer                                  ; skip directories

    LEA fib_FileName,A0                                    ; pruefen ob infofile
    BSR.w check_for_infoextention
    BEQ.w scan_libsdrawer

    MOVEA.l _execbase,A6                                   ; allocate $26 = 38 bytes fuer listeneintrag
    MOVEQ.l #$26,D0
    MOVEQ.l #$01,D1
    MOVE.l mempool,a0
    JSR _AllocPooled(a6)
    ;jsr AJL_0_4B6C
    MOVEA.l _dosbase,A6
    MOVE.l D0,D6                                           ; sichere speicheradresse in D6


    LEA ptr_userlibs_list,A0                               ; pruefe liste

 JL_0_36D6:
    MOVE.l (A0),D5
     BEQ.w JL_0_3722                                       ; kein pointer da? kann springe weiter
    MOVEA.l D5,A2
    ADDQ.w #6,A2                                           ; 6 bytes weiter gehen, um dateinamen zu speichern


    LEA fib_FileName,A1                                    ; vergleich, ob Dateiname schon in der liste ist

 JL_0_36E6:
      MOVEQ.l #$00,D0
      MOVE.b (A1)+,D0
       BEQ.w JL_0_3722                                     ; dateiname komplett, dann weiter
      MOVEQ.l #$00,D1
      MOVE.b (A2)+,D1
       BEQ.w JL_0_371C
      !compare1                                            ;bsr.w tstalpha
      BNE.w JL_0_3702
      ANDI.w #$DF,D0

 JL_0_3702:
      EXG.l D0,D1
      !compare1                                            ;bsr.w tstalpha
      BNE.w JL_0_3710
      ANDI.w #$DF,D0

 JL_0_3710:
      EXG.l D0,D1
      CMP.b D1,D0
    BEQ.w JL_0_36E6
    BCS.w JL_0_3722

 JL_0_371C:
    MOVEA.l D5,A0
BRA.w JL_0_36D6

 JL_0_3722:
    MOVEA.l D6,A1                                          ; hier war die adresse des allokierten Speicers drin
    MOVE.l (A0),(A1)
    MOVE.l A1,(A0)
    ADDQ.w #4,A1                                           ; pointer zum naechsten namen ueberspringen
    MOVE.w #$FFFF,(A1)+                                    ; $FFFF schreiben
    MOVEA.l #fib_FileName,A0                               ; dateinamen in die liste kopieren

 JL_0_3734:
      MOVE.b (A0)+,(A1)+
    BNE.w JL_0_3734
BRA.w scan_libsdrawer

 exit_scan_libsdrawer:
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  JSR _UnLock(A6)
  MOVEQ.l #-$01,D0

 exit_get_libraries:
RTS

 unlock_and_exit_get_libraries:
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  JSR _UnLock(A6)
  MOVEQ.l #$00,D0
RTS


.free_userlib:
  MOVEA.l _execbase,A6
  MOVEA.l ptr_userlibs_list,A2
  CLR.l ptr_userlibs_list

 loop_free_userlib:
    CMPA.w #$0,A2
    BEQ.w exit_free_userlib
      MOVEA.l A2,A1
      MOVEQ.l #$26,D0
      MOVEA.l (A2),A2
      MOVE.l mempool,a0
      MOVEA.l _execbase,A6
      JSR _FreePooled(A6)
BRA.w loop_free_userlib

 exit_free_userlib:
RTS


pass:  Dc.w 0                                             ; smallpass org source
compiler_job: Dc.w 0                                      ; added by thilo: what the compiler is doing at the moment
                                                          ; 0 = compiling, 1 = code generation

.startcompile
  MOVE.l A7,errstack                                      ;startcompile
        ;tst.l mempool2
        ;beq 'l10
        ;move.l $4,a6
        ;move.l mempool2,a0
        ;clr.l mempool2
  ;jsr -$2be(a6)

; .10
  CLR.l reqmode

  MOVE.l #Aclearallvars,errcont
  MOVE.l #concomstack,concomsp
    ;
    ;racing stripe stuff...
    ;
;  MOVEA.l comdata,A0
;  MOVEA.l $50(A0),A0
;  MOVE.w $8(A0),D0                                         ;width for progress
  MOVE.w #1450,D0
  LSR.w #3,D0
  SUBQ.w #7,D0                                             ; 173
  MOVE.w D0,progressbar_width
  SWAP D0
  CLR.w D0
  MOVE.l numlines,d1
  DIVU.l d1,d0                                             ; progressbar_width / numlines

  TST.w D0
  BNE.w JL_0_37C0
  MOVEQ.l #-$01,D0

 JL_0_37C0:
  MOVE.w D0,progress_per_line
;  MOVEA.l comdata,A0
;  MOVE.w $5C(A0),D0                                        ; screenwidth * 2
;  MOVE.w D0,bmapmul
;  MULU #$9,D0
;  MOVE.w D0,botline                                        ;offset to bottom of racing stripe

  ; check if debugger is on
  BTST #$7,use_debugger
;  SNE debugmode
  BNE 'debugon
  CLR.w debugmode
BRA.b 'debugoff

 'debugon
  SNE debugmode

 'debugoff
;  !basic
;  logging_peekw{?debugmode}
;  !asm
;  MOVEA.l comdata,A0
;  MOVE.b debugmode,$7ee(a0)
  !ComData_SetB{comByte_DebugMode,debugmode}


  CLR.w dirmode                                            ;direct mode flag
  CLR.w ezerr                                              ;quiet error
  CLR.l currentfunction
  CLR.w connest
  CLR.w varmode
  CLR.w proceduremode
  CLR.w ininclude
  CLR.w intstring
  CLR.w pass
  MOVE.w #0,compiler_job
  CLR.l funcscanon

 JL_0_3824:
  CNIF #funcscan                                           ; scan, welche funktionen verwendet werden
    MOVE.l #1,funcscanon
    BSR compileall
  CEND

  CLR.l funcscanon
  BSR.w compileall

  MOVE.w dontwrite,d0
  CMP.w #1,d0
  BNE 'l3
  CLR.w dontwrite
  BSR compileall                                           ;if a function is not found

 'l3                                                       ;??looks like double label??
 JL_0_3832:
  TST.b funcoptimize
   ;BEQ 'out
  LEA firstproc,a0
  CLR.l savefuncspace
  MOVE.l (a0),d0

 .'funcskiplist                                            ;??looks like double label??
 'lr1
    MOVE.l d0,a0
    BEQ 'out
    TST.b isfunc(a0)
    BNE 'nex
    MOVEM.l d2/a6/a0,-(a7)
    ;MOVE.l $4,a6
    MOVEQ #0,d0
    MOVE.b $21+#funcentry_extend-1(a0),d0
    SUB.w #$21+#funcentry_extend,d0
    ADD.w #16,d0
    MOVE.l #$10000,d1
    MOVE.l d0,d2
    MOVEA.l _execbase,A6
    JSR _AllocMem(a6)         ; thilo: not 100% sure about this!
    MOVE.l d0,a1
    MOVE.l d2,4(a1)
    MOVE.l unusedfunc,(a1)
    MOVE.l d0,unusedfunc
    MOVEM.l (a7)+,a6/a0/d2
    MOVE.l isfunc+1(a0),d0
    ADDQ.l #6,d0
    ADD.l d0,savefuncspace

 'l1f
    MOVE.l d0,8(a1)
    LEA 12(a1),a1
    MOVE.l a0,-(a7)
    LEA $21+#funcentry_extend(a0),a0

 'l1
      MOVE.b (a0)+,(a1)+
    BNE 'l1
    MOVE.l (a7)+,a0

 'nex
    MOVE.l (a0),d0
BRA 'lr1

 'out
  BTST #$7,make_smallestcode
  BEQ.b JL_0_3844                                           ;optimize for executable
  CLR.l morememadd
  again
  BSR.w alloxadj
  BEQ.w JL_0_388A
  ADDQ.w #1,pass
  BSR.w compileall

 JL_0_3844:
  MOVE.w dontwrite,D1
  BEQ.w JL_0_38A2
  ;MOVEA.l #comreq_datas,A0
  ;MOVEA.l comdata,A1
  ;MOVEA.l (A1),A1

 L_0_385C:
  ;JSR (A1)

 JL_0_385E:
  ;MOVEA.l comdata,A1
  ;MOVEA.l $8(A1),A1

 L_0_3868:
  ;JSR (A1)                                                 ;compile requester more mem
  ;CMP.w #-$1,D7
   ;BNE.w JL_0_385E
  ;CMP.w #$1,D6
   ;ADD.l #20000,morememadd
   ;ADD.l #500000,libsbuffer
BRA.w JL_0_3896

;BRA.w JL_0_3824
  ;CMP.w #$2,D6
   ;MOVE.l #30000,morememadd
   ;ADD.l #5000,libsbuffer
;BRA.w again
  ;CMP.w #$3,D6
   ;BNE.w JL_0_385E

 JL_0_388A:
  MOVE.w #$FFFF,anyerrs
BRA.w JL_0_38A2

 JL_0_3896:
  BSR.w alloxinc                                          ;increase all by 50%
  BEQ.w Aclearallvars
BRA.w JL_0_3824


JL_0_38A2:
  ;move.l $4,a6
  ;move.l mempool2,d0
  ;beq 'l10
  ;move.l d0,a0
  ;jsr -$2be(a6)
  ;clr.l mempool2

; 'l10:
BRA.w JL_0_38A6                                            ;???????


.JL_0_38A6:
  JSR freereps
  JSR freesels
  JSR AJL_0_6DF2
  JSR freepends
  JSR freeifs
  JSR AJL_0_C188
  JSR AJL_0_C15C
  JSR AJL_0_D9BC

;'l10:
JMP cleartemplabel


mempool2:  Dc.l 0


.Aclearallvars:                                            ;called from ped every filechange
  JSR Aclearcache

  BTST #$7,use_debugger
;  SNE debugmode
  BNE 'debugon
  CLR.w debugmode
BRA.b 'debugoff

 'debugon
  SNE debugmode

 'debugoff
;  MOVE.l comdata,a0
;  MOVE.b debugmode,$7ee(a0)
  !ComData_SetB{comByte_DebugMode,debugmode}

  LEA regtable,a0
  MOVEQ #10,d0

 'l1
    CLR.l (a0)+
  DBF d0,'l1

  LEA includetemp2,a0
  CLR.b (a0)
  MOVE.l #7,maxregs
  CLR.w debugnest
  CLR.b funcparloop
  CLR.b nostringopt
  CLR.b firsttime
  CLR.l lastdestpointer
  CLR.l lastwritedat
  CLR.l prevwritedat
  CLR.l includeline
  CLR.b incnif
  CLR.b formode
  CLR.b funccall
  CLR.w objectcount
  CLR.b resdisable
  CLR.b developobject
  CLR.b optistring
  CLR.b optistring2
  CLR.b optiarray
  CLR.b quickadd
  CLR.w newmode
  CLR.w mode
  CLR.w string1
  CLR.b fastfunc
  CLR.w load_var_size
  CLR.w load_var_reg
  CLR.l load_var_addr
  CLR.w imm_size
  CLR.w imm_reg
  CLR.l imm_addr
  CLR.b _dcb
  CLR.l nohunkoffset
  CLR.b peekaddrsize
  CLR.b typecheck
  CLR.b declare2
  CLR.b declare
  CLR.l myoline                                          ;check
  CLR.l myline                                          ;check
  CLR.b newvariable
  CLR.b saved0
  CLR.l bsssize
  CLR.l chipsize
  CLR.b infunctioncode
  MOVE.l #-1,bssstart
  MOVE.l #-1,bssend
  MOVE.l #-1,chipstart
  MOVE.l #-1,chipend
  MOVE.w #0,bssmode
  CLR.w a2offset
  CLR.w fast
  CLR.w fpu
  CLR.b iee
  CLR.w newsyntax
  BSR.w JL_0_38A6
  JSR AJL_0_7962
  JSR frallvars
  JSR fralltypes
  JSR freemacs
  JSR clearfunctionlist
  TST.w pass
  ;bne freeprocvs
  JSR clearlabels
  JSR clearhash

 'l2a
  LEA devo,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA ptr_parameterstore,a1

 'l1b
    MOVE.b (a0)+,(a1)+
  BNE 'l1b
  MOVEQ #13,d2
  JSR findlabel2
  BNE 'd
  CLR.l 8(a2)

 'd
  MOVEM.l (a7)+,a0-a6/d0-d7
  !basic
  dos_Delete{dos_AddPart{my_systemdir$,"ab_compileerror.txt"}}
  !asm
  CLR.b returncode
JMP freeprocvs


.clearhash
  MOVE.l #bssstore-labelhash,d0
  ASR.l #2,d0
  LEA labelhash,a0

 'l10
    CLR.l (a0)+
    SUBQ.l #1,d0
  BNE.s 'l10

  LEA labelbase,a1
  MOVE.l (a1),d0
  BEQ 'l11

 'l21
    MOVE.l d0,a1
    TST.l 4(a1)
    BEQ 'l29
    LEA $13(a1),a0
    MOVEQ #0,d0
    MOVEQ #0,d1

 'l13
      MOVE.b (a0)+,d1
      BEQ 'l12
      !hashalgo
BRA 'l13

 'l12
    LEA labelhash,a0
    AND.l #hashsize,d0
     ASL.l #2,d0
    MOVE.l 0(a0,d0),d1                                     ;*4
    MOVE.l d1,$c(a1)
    MOVE.l a1,0(a0,d0)

 'l29
    MOVE.l (a1),d0
  BNE 'l21

 'l11
RTS


fralltypes:
  MOVEA.l lastrestype,A0
  MOVEA.l (A0),A2
  CLR.l (A0)
JMP freetypes


frallvars:
  MOVEA.l varbase,A3
  CLR.l varbase

 'l10
  CMPA.w #$0,A3
  BEQ.w 'l20
  MOVEA.l A3,A1
  MOVEA.l (A3),A3
  MOVEQ.l #$00,D0
  MOVE.b $E+4(A1),D0
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _FreePooled(A6)
BRA.w 'l10

 'l20
RTS
;JMP freevars                                              ;??Looks like dead code??


freeifs:
  LEA firstiff,A2
  MOVEQ.l #$0E,D2
JMP freeslist


;bmapmul:            Dc.w 0
;botline:            Dc.w 0                                ;offset to bottom of stripe

progressbar_width:   Dc.w 100                              ;riteend org source ;right end of include strip
inmacro:             Ds.w 1                                ;macmask org source ;macro found


.nextline:
  CLR.w inmacro
  ADDQ.l #1,globallinecount
  CLR.b nostringopt
  BSR.w JL_0_3CA4
  CLR.w instringon

 mergeline:
  TST.w ininclude
  BEQ.w JL_0_39B0
  ADDQ.l #1,includeline
    JSR ab3_WriteDebugFile
  JSR AJL_0_C09E
  BEQ.w JL_0_39B0
  MOVE.w ininclude,D0
  CMP.w #$4,D0
  BCC.w JL_0_39AC
  ADD.w D0,D0
  LEA progress_per_line,A0
  MOVE.w $0(A0,D0.W),D2
  CMP.w progressbar_width(PC),D2
  BCC.w JL_0_39AC
  ADDQ.w #1,$0(A0,D0.W)
  LSR.w #1,D0
  MOVE.l d0,d1
  EXT.l d1
  MOVE.l d2,d0
  EXT.l d0                                                 ;d0=x,d1=y

  JSR update_progressbar

 JL_0_39AC:
  MOVEQ.l #-$01,D0
RTS


JL_0_39B0:
  MOVE.l titleat,D0
  MOVEQ.l #$00,D1
  MOVE.w progress_per_line,D1
  ADD.l D1,D0
  MOVE.l D0,D1
  SWAP D0
  CMP.w titleat,D0
   BEQ.w JL_0_39E4
;  MOVEA.l comdata,A0                                       ; fr|her wird direkt in die Planes geschrieben
;  MOVEA.l $24(A0),A0
  EXT.l d0
  MOVE.l d1,-(a7)
;  MOVEQ #9,d1                                              ; y-pos runtersetzen

  MOVE.w #1,compiler_job                                    ; set to compiler job 1 (=build executable)
  JSR update_progressbar
  MOVE.w #0,compiler_job                                    ; set to compiler job 0 (=compile source)
  ;NOT.b -$1(A0,D0.W)
  ;ADDA.w botline(PC),A0                                     ;progress
  ;NOT.b -$1(A0,D0.W)
  MOVE.l (a7)+,d1

 JL_0_39E4:
  MOVE.l D1,titleat
  ADDQ.l #1,linenumat
  CLR.w linedone
  JSR ab3_WriteDebugFile  ; write to DebugFile every main source line
  ;SUBQ.w #1,linesleft
  SUBQ.l #1,numlines2
   BEQ.w JL_0_3A12
  MOVEA.l sourceline,A0
  MOVEA.l (A0),A0
  MOVE.l A0,sourceline
  LEA $9(A0),A5

 JL_0_3A12:
RTS


hexascii:                                                  ;convert d1.w to ascii at a0
  MOVE.w D0,-(A7)
  MOVEQ.l #$03,D0

  JL_0_3A18:
    MOVE.w D1,D2
    ANDI.w #$F,D2
    ADDI.w #$30,D2
    CMP.w #$3A,D2
     BCS.w JL_0_3A2C
    ADDQ.w #7,D2

 JL_0_3A2C:
    MOVE.b D2,$0(A0,D0.W)
    LSR.w #4,D1
  DBF D0,JL_0_3A18

  MOVE.w (A7)+,D0
RTS


findmacro:                                                 ;expandmax org source
    ;
    ;go through statement and expand macros
    ;
    ;line at a5.....
    ;check it for !'s
    ;
  MOVE.w skipcode,D1
  BNE.w JL_0_3A46
RTS

JL_0_3A46:
  MOVE.l A5,-(A7)
  MOVEQ.l #$3A,D1                                          ;':'
  MOVEQ.l #$21,D2                                          ;'!'
  MOVEQ.l #$3B,D3                                          ;';'
  MOVEQ.l #$22,D4                                          ;'"'

 JL_0_3A50:
  MOVE.b (A5)+,D0
   BEQ.w JL_0_3CA0
   BPL.w JL_0_3A60
  MOVE.b (A5)+,D0
BRA.w JL_0_3A50

 JL_0_3A60:
  CMP.b D4,D0
   BNE.w JL_0_3A82

 JL_0_3A66:
  MOVE.b (A5)+,D0
   BEQ.w notqerr
   ;BPL.w JL_0_3A76                                        ;morechar
  ;MOVE.b (A5)+,D0
;BRA.w JL_0_3A66

 JL_0_3A76:
  CMP.b #$22,D0
   BNE.w JL_0_3A66
BRA.w JL_0_3A50

 JL_0_3A82:
  CMP.b D1,D0
   BEQ.w JL_0_3CA0
  CMP.b D3,D0
   BEQ.w JL_0_3CA0

 'l10
  CMP.b D2,D0
   BNE.w JL_0_3A50
  MOVE.w #$FFFF,inmacro                                    ; no runtimecheck in macros
  MOVEA.l A5,A3
   JSR getparameter2
   BNE.w JL_0_3AAC
JMP syntaxerr


 JL_0_3AAC:
  ;bsr.w bakup
   MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
   JSR findmac                                             ;find macro
   BEQ.w JL_0_3ABE
JMP nomacerr

 JL_0_3ABE:
  TST.b debugmode
  BEQ 'sk1
  MOVE.w #$4e71,d1
  JSR writeword
  MOVE.l a5,-(a7)
  MOVE.l a3,a5
  SUBQ.l #1,a5
  MOVE.w #$0,inmacro
  BSR debugstuffa
  MOVE.w #$FFFF,inmacro
  MOVE.l (a7)+,a5
  MOVE.w #$4e71,d1
  JSR writeword

 'sk1
  MOVEA.l A5,A4

 'l5a
   CMP.b #" ",(a4)+
    BEQ 'l5a
     SUBQ.l#1,a4
     CMP.b #",",(a4)
    BEQ JL_0_3AEA

 'l5b
  MOVEQ.l #$00,D4
  TST.b newsyntax
  BEQ 'l10b
  MOVEM.l a0/d0,-(a7)
  MOVE.l 4(a2),a0
  MOVE.w 8(a2),d0

 'x2
  CMP.b #"`",(a0)+
  BEQ 'x1
  SUBQ.w #1,d0
  BNE 'x2
BRA 'x3

 'x1
  MOVEM.l (a7)+,a0/d0
BRA 'l10

 'x3
  MOVEM.l (a7)+,a0/d0
BRA JL_0_3AEA

 'l10b
  CMPI.b #"{",(A4)
   BNE.w JL_0_3AEA
  ;BNE 'l10

 'l5
  ADDQ.l #1,a4

 'l10
    CMP.b #" ",(a4)
    BEQ 'l5
    MOVEM.l a0/d0,-(a7)
    CLR.b exmac
    LEA chartab,a0
    MOVEQ #0,d0
    MOVE.b (a4),d0
    BMI 'm1
    TST.b 0(a0,d0)
    BEQ 'm1
    TST.b newsyntax
    BEQ 'ns1
    CMP.b #"#",d0
    BEQ 'm1
    CMP.b #"$",d0
    BEQ 'm1
    CMP.b #"-",d0
    BEQ 'm1

 'ns1
  CMP.b #",",d0
    BEQ 'm1
    CMP.b #"{",d0
    BNE 'm1b
    ADDQ.l #1,a4
BRA 'm1

 'm1b
  TST.b newsyntax
    BEQ 'm1
    MOVE.b #1,exmac

 'm1
  MOVEM.l (a7)+,a0/d0
    TST.b exmac
    BNE JL_0_3AEA
    ;CMP.b #"|",(a4)
    ;BEQ JL_0_3AEA
    ;CMP.b #":",(a4)
    ;BEQ JL_0_3AEA
    ;CMP.b #";",(a4)
    ;BEQ JL_0_3AEA
  TST.b (a4)
  BEQ JL_0_3AEA

 oldlab
  MOVEA.l ptr_macrobuffer_begin,A0

 JL_0_3AD0:
  ADDQ.w #1,D4
  MOVE.l A4,(A0)
  CLR.w 4(a0)
   BSR.w JL_0_3CC6
  ;move.l A4,D1
  ADDQ.l #4,a0
  ;sub.l (A0)+,D1
  ;subq.w #1,D1
  ;move.w D1,(A0)+
  SUBQ.w #1,(a0)+
  CMP.b #$7D,D0
  BEQ 'l10
  TST.b d0
  BEQ 'l10
BRA JL_0_3AD0
   ;bne.w JL_0_3AD0

 'l10
  CLR.l sourceline3
  MOVEA.l A4,A5

 JL_0_3AEA:
  MOVE.w D4,numarg
  ;tst.l myoline
  ;beq 'l1
  ;move.l myline,d0
;bra 'l10

 'l1
  MOVE.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
  MOVE.l macrobuffer_size,D0
  CMP.l #40000,d0
  BGE 'l1m
  MOVE.l #40000,d0
  MOVE.l d0,macrobuffer_size

 'l1m
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C
  MOVE.l myline,myoline

 'l10
  ADDQ.l #1,d0
  MOVE.l D0,myline
  MOVEA.l D0,A1
  MOVE.b #":",-1(a1)
  MOVEA.l A1,A6
  ADDA.l macrobuffer_size,A6
  MOVEA.l (A7)+,A0

 JL_0_3B1E:
  CMPA.l A6,A1
   BCC.w mbovererr
  MOVE.b (A0)+,(a1)+
  CMPA.l A3,A0
   BCS.w JL_0_3B1E
  SUBQ.w #1,A1
  MOVE.w $8(A2),D1
   BEQ.w JL_0_3C70
  MOVE.w $A(A2),macnum
  ADDQ.w #1,$A(A2)
  MOVEA.l $4(A2),A2
  SUBQ.w #1,D1
  CLR.b firstmline

 JL_0_3B48:
    MOVEQ.l #$00,D0
    MOVE.b (A2)+,D0
    TST.b firstmline
    BNE 'c1
    CMP.b #$22,d0
    BNE 's1
    MOVE.b #1,firstmline

   's1
    CMP.b #":",d0
    BNE 'm1
    MOVE.b #1,firstmline

   'm1
    CMP.b #";",d0
    BNE 'c1

   'l1
    SUBQ.w #1,d1                                           ;filter out comment
    MOVE.b (a2)+,d0
    CMP.w #":@",-1(a2)
    BEQ 'c2
    TST.w d1
    BNE 'l1
  BRA JL_0_3C6C

   'c2
    CMP.b #":",1(a2)
      BNE 'l1
      ADDQ #2,a2
      SUBQ #3,d1
      MOVE.b (a2)+,d0
      MOVE.b #1,firstmline

   'c1
    CMP.b #"`",D0
     BNE.w JL_0_3C56
    SUBQ.w #1,D1
    MOVE.b (A2)+,D0
    CMP.w #$7B,D0
     BEQ.w JL_0_3BB6
    CMP.w #$40,D0
     BNE.w JL_0_3B82
    MOVEQ.l #$00,D2
    MOVE.w macnum,D2
    MOVEA.l A1,A0
    MOVE.w D1,-(A7)
     JSR makelong
    MOVEA.l A0,A1
    MOVE.w (A7)+,D1
  BRA.w JL_0_3C6C

   JL_0_3B82:
    ORI.w #$20,D0
    CMP.w #$7A,D0
     BCS.w JL_0_3B94
  JMP ilconsterr

   JL_0_3B94:
    SUBI.w #$30,D0
    CMP.w #$A,D0
     BCS.w JL_0_3BF2
    SUBI.w #$27,D0
    CMP.w #$A,D0
     BCC.w JL_0_3BB2
  JMP ilconsterr

   JL_0_3BB2:
  BRA.w JL_0_3BF2

   JL_0_3BB6:
    MOVE.l A5,-(A7)
    MOVEM.l D1/A1-A2/A6,-(A7)
    MOVEA.l A2,A5
     JSR AJL_0_BF6E
    CMP.w #$7D,D0
     BEQ.w JL_0_3BD2
  JMP syntaxerr

   JL_0_3BD2:
    MOVEM.l (A7)+,D1/A1-A2/A6
    MOVE.l A5,D2
    SUB.l A2,D2
    SUB.w D2,D1
    MOVEA.l A5,A2
    CLR.w instringon
    MOVEA.l (A7)+,A5
    MOVE.l D3,D0
    BPL.w JL_0_3BF2
  JMP ilconsterr

   JL_0_3BF2:
    SUBQ.w #1,D0
     BPL.w JL_0_3C20
    ;
    ;here, we do a numarg text replace
    ;
    MOVE.w numarg,D0
    DIVU #$A,D0
    ADDI.w #$30,D0
    CMPA.l A6,A1
     BCC.w mbovererr
    MOVE.b D0,(A1)+
    SWAP D0
    ADDI.w #$30,D0
    CMPA.l A6,A1
     BCC.w mbovererr
    MOVE.b D0,(A1)+
  BRA.w JL_0_3C6C
    ;
    ;ok to do parameter replacement
    ;d0= number for parameter replacement!
    ;
   JL_0_3C20:
    CMP.w numarg,D0
     BCC.w JL_0_3C6C
    LSL.w #1,D0
    MOVE.w D0,D4
    LSL.w #1,D0
    ADD.w D4,D0
    MOVEA.l ptr_macrobuffer_begin,A0
    ADDA.w D0,A0
    MOVE.w $4(A0),D4
     BEQ.w JL_0_3C6C
    MOVEA.l (A0),A0
    SUBQ.w #1,D4

   JL_0_3C46:
      CMPA.l A6,A1
       BCC.w mbovererr
      CMP.w #"@@",(a0)
       BNE 'l10
      TST.w ininclude
       BNE errorjoin

    'l111
      MOVE.l sourceline,a0
      MOVE.l (a0),a0
      CMP.l #0,a0
      BNE 'l11
      MOVEQ #0,d0
      JSR error

    'l11
      MOVE.l a0,sourceline
      ADDQ.l #1,linenumat
      LEA 9(a0),a0
      MOVE.l a0,-(a7)

    'l110
      CMP.b #" ",(a0)+
       BEQ 'l110
      CMP.b #";",-1(a0)
      MOVE.l (a7)+,a0
       BEQ 'l111
      SUBQ.l #1,d4

    'l10
      MOVE.b (A0)+,(A1)+
    DBF D4,JL_0_3C46

  BRA.w JL_0_3C6C

   JL_0_3C56:
    CMPA.l A6,A1
     BCC.w mbovererr
    MOVE.b D0,(A1)+
     BPL.w JL_0_3C6C
    CMPA.l A6,A1
     BCC.w mbovererr
    MOVE.b (A2)+,(A1)+
    SUBQ.w #1,D1

   JL_0_3C6C:
  DBF D1,JL_0_3B48

  ;tst.l numarg
  ;beq 'l10
  ;cmp.b #"}",-1(a5)
  ;beq 'l10
  ;subq.l #1,a5

 'l10                                                      ;??Looks like double label??
 JL_0_3C70:
  CMPA.l A6,A1
   BCC.w mbovererr
  MOVE.b (A5)+,(A1)+
   BNE.w JL_0_3C70
  MOVEA.l myline,A5
  MOVE.l myoline,D0
   BEQ.w JL_0_3C9C
  SUBQ.l #1,d0
  MOVEA.l D0,A1
  MOVE.l macrobuffer_size,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
  JSR _FreePooled(A6)

 JL_0_3C9C:
BRA.w JL_0_3A46

 JL_0_3CA0:
  MOVEA.l (A7)+,A5
RTS


JL_0_3CA4:
  MOVE.l myline,D0
  BEQ.w JL_0_3CC4
  SUBQ.l #1,d0
  CLR.l myline
  MOVEA.l D0,A1
  MOVE.l macrobuffer_size,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
JMP _FreePooled(A6)

 JL_0_3CC4:
RTS


JL_0_3CC6:
  MOVEQ.l #$00,D2

 JL_0_3CC8:
  ADDQ.w #1,4(a0)
   MOVE.b (A4)+,D0
   ;beq.w syntaxerr
   BEQ exit1
   BPL.w JL_0_3CD8
  ADDQ.w #1,4(a0)
  ADDQ.w #1,A4
BRA.w JL_0_3CC8

 JL_0_3CD8:
   TST.w instringon
   BNE 'lnom
   CMP.b #";",d0
   BEQ exit2
   CMP.b #":",d0
   BEQ exit2

 'lnom
  CMP.b #$22,D0
   BNE.w JL_0_3CEA
  NOT.w instringon
BRA.w JL_0_3CC8


JL_0_3CEA:
  TST.w instringon
   BNE.w JL_0_3CC8
   CMP.b #"@",d0
   BNE 'l10
   CMP.b #"@",(a4)
   BNE 'l10
   TST.w ininclude
   BNE errorjoin
   MOVE.l sourceline3,a4
   CMP.l #0,a4
   BNE 'l11
   MOVE.l sourceline,a4

 'l11
  MOVE.l (a4),a4
      CMP.l #0,a4
      BNE 'l12
      MOVEQ #0,d0
      JSR error

 'l12
   MOVE.l a4,sourceline3
   LEA 9(a4),a4
   MOVEQ #",",d0

 'l10
  CMP.b #$2C,D0
   BNE.w JL_0_3D06
  TST.w D2
   BEQ.w JL_0_3D30
BRA.w JL_0_3CC8

 JL_0_3D06:
  ;bsr.w isitopen
   CMP.b #$7B,D0                                           ;"{"
   BEQ.w 'l10
  CMP.b #$28,D0                                            ;"("

 'l10
   BNE.w JL_0_3D14
  ADDQ.w #1,D2
BRA.w JL_0_3CC8

 JL_0_3D14:
  CMP.b #$7D,D0                                           ;"}"
   BNE.w JL_0_3D22
 TST.w D2
   BEQ.w JL_0_3D30

 JL_0_3D22:
  ;bsr.w isitclose
   CMP.b #$7D,D0                                           ;"}"
   BEQ.w 'l10
  CMP.b #$29,D0                                            ;")"

 'l10
   BNE.w JL_0_3CC8
  SUBQ.w #1,D2
BRA.w JL_0_3CC8

 JL_0_3D30:
RTS


exit1
      SUBQ.l #1,a4
      CLR.l sourceline3
RTS


exit2
      MOVEQ #0,d0
      SUBQ.l #1,a4
      CLR.l sourceline3
RTS


isitopen:
  CMP.b #$7B,D0                                            ;"{"
  BEQ.w JL_0_3D3E
  CMP.b #$28,D0                                            ;"("

 JL_0_3D3E:
RTS


isitclose:
  CMP.b #$7D,D0                                            ;"}"
  BEQ.w JL_0_3D4C
  CMP.b #$29,D0                                            ;")"

 JL_0_3D4C:
RTS


;stopbit:   Ds.w 1
stopit:     Ds.w 1
clrreq:     Ds.w 1

;stopcode:
;  MOVE.w stopit(PC),D1
;  BNE.b stopcode__skip
;  MOVE.w stopbit(PC),D1
;  BTST D1,D0
;  BEQ.b stopcode__skip
;  ;MOVE.w #-1,stopit
;  MOVEM.l D0/A6,-(A7)
;  MOVE.l signals(PC),D0
;  MOVEA.l ptr_ThisTask,A1
;  MOVEA.l _execbase,A6
;  JSR _Signal(A6)
;  MOVEM.l (A7)+,D0/A6

; stopcode__skip:
;RTS


.close_compilewin:
  MOVE.w clrreq(PC),D0
   BEQ.w close_compilewin__skip

  !basic
  If Peek.l(Addr Window(4))<>0 Then WZCloseWindow 4        ;turn off the requester
  !asm
  LEA clrreq,a0
  NOT.w (a0)                                               ;reass
  MOVEA.l ptr_ThisTask,A0
  CLR.l $1E(A0)
  CLR.l $2A(A0)

 close_compilewin__skip:
RTS


intsused:  Ds.w 1


setcvars:
  MOVE.w #-1,blitzoff
  CLR.w intsused
  CLR.w anyerrs
  CLR.w blitzmode
  CLR.w dontwrite                                              ;nomemleft
  CLR.w constmode
  CLR.w cmake
  CLR.w cfetchmode
  CLR.l intdata1
  CLR.w fuckpos
  CLR.w procnum
  CLR.w procnum2
  CLR.w dfetch
  CLR.l titleat
  CLR.b usedpath
  CLR.b path2
  CLR.w inerr
  CLR.w intlevel
  CLR.l cont_pc
  CLR.l cont_pc2
  CLR.l lastcontlink
  MOVE.l destbufferstart,destpointer
  MOVE.l destbufferstart,bigpc
  MOVE.l destbufferend,libend
  MOVE.l data1start,data1
  MOVE.l data2at,data2
  MOVE.w #-1,skipcode                                      ;#-1,comflag org source
  MOVE.w #-1,linemode                                      ;#-1,linemode org soruce
  CLR.w oldvcodelen
  CLR.b lastgloballabel                                    ;lastbiglab org source
RTS


debugmode:  Ds.w 1                                         ;debugga org source ;debugger enabled?


.compilerequester:
  LEA  clrreq,a1
  MOVE.w #2000,(a1)
  !basic
  If CLIMode=False
    FindScreen 0
    WZWindow 4,?wzgui,64,-2,-2,-2,-2,4
    ;  comstatus$ = "Pass "+Str$(Peek.w(?pass))
    ;  WZPrint "COMPILE_INFO",&comstatus$
  End If
  calcpro_old.l = 0
  typ_old.l     = -1
  pass_old.l    = -1
  !asm
  CLR.w stopit
RTS


.compileall:
  CLR.w storedebugmode
  CLR.b iserror
  BSR.w compilerequester

  MOVE.l #0,globallinecount
  JSR check_of_same_source
  BSR.w call_setpointerbusy
  BSR.w setcvars
  MOVE.w #$8000,globalvarpointer
  MOVE.l #newtype_quick,defaulttype
  MOVE.l A7,passstack
  MOVE.l #firstitem_,sourceline
  MOVE.w numlines_org,linesleft
  MOVE.l numlines,numlines2
  ADDQ.w #1,linesleft
  ADDQ.l #1,numlines2
  MOVE.l #-1,linenumat
  BSR.w resetlibs
  BSR.w Aclearallvars
  LEA progress_per_line+2,A0
  MOVEQ.l #$03,D0

 JL_0_40EC:
    CLR.w (A0)+
  DBF D0,JL_0_40EC

 'l2a
  LEA _include,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA ptr_parameterstore,a1

 'l1b
    MOVE.b (a0)+,(a1)+
  BNE 'l1b

  MOVEQ #9,d2
  JSR findlabel2
  BNE 'd
  MOVE.l #0,8(a2)
  MOVEM.l (a7)+,a0-a6/d0-d7
BRA 'd2

 'd
  JSR addlabelhash
  MOVE.l #$1,$4(A2)
  MOVE.l #0,8(a2)
  MOVEM.l (a7)+,a0-a6/d0-d7

 'd2
  LEA _debug,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA ptr_parameterstore,a1

 'l9b
    MOVE.b (a0)+,(a1)+
  BNE 'l9b

  MOVEQ #7,d2
  JSR findlabel2
  BNE 'd9
  MOVE.b debugmode(PC),D0
  EXT.w d0
  EXT.l d0
  MOVE.l d0,8(a2)
  MOVEM.l (a7)+,a0-a6/d0-d7
BRA 'd9b

 'd9
  JSR addlabelhash
  MOVE.l #$1,$4(A2)
  MOVE.b debugmode(PC),D0
  EXT.w d0
  EXT.l d0
  MOVE.l d0,8(a2)
  MOVEM.l (a7)+,a0-a6/d0-d7

 'd9b
  MOVE.l #firstitem_,a0
  MOVE.l (a0),a0
  LEA 9(a0),a0
  MOVE.w #0,exdebug
  TST.b debugmode
   BEQ 'l10

 'l2
  MOVE.b (a0)+,d0
   BEQ 'l10
  CMP.b #$20,d0
   BEQ 'l2
  SUBQ.l #1,a0
  CMP.l #"DEBU",(a0)
   BNE 'l10
  CMP.b #"G",4(a0)
   BNE 'l10
  MOVE.w #$0,debugversion
  MOVE.b #1,exdebug

 'l10
  LEA nops4,A0
  LEA dataget,A1
  JSR pokecode2                                            ;write intro nops
  MOVE.l #$01010101,d1
  JSR writedatalong                                        ;for the 4 tempregs
  JSR writedatalong
  JSR writedatalong
  JSR writedatalong
  TST.b saved0
   BEQ 'l1
  MOVE.l #$4e714e71,d1
  JSR writelong                                            ;add 2 nops
  MOVE.l #$4e714e71,d1
  JSR writelong                                            ;add 2 nops
  MOVE.l #$4e714e71,d1
  JSR writelong                                            ;add 2 nops
   MOVE.l #$4e714e71,d1
  JSR writelong                                            ;add 2 nops

 'l1
  MOVE.b debugmode(PC),D1
   BEQ.b JL_0_4132
  MOVE.b debugmode,storedebugmode
  MOVE.w #$FFDC,D1
   BSR.w uselib
  TST.w debugversion                                       ;make a version for debugger
   BNE.b JL_0_412A
    ;
    ;not executable!
    ;
  MOVE.w #$FA3C,D1
   BSR.w uselib
  MOVE.w #$0001,D1
   BSR.w uselib
BRA.b JL_0_4132

 JL_0_412A:
  MOVE.w #$FA32,D1
  BSR.w uselib

 JL_0_4132:
  BSR.w nextline
  CLR.l linenum
  CLR.l stacktrack

 JL_0_4136:
  ADDQ.l #1,linenum
  MOVE.l destpointer,destpointer2
  MOVE.l a5,sourceline2
  BSR.w compile_line                                        ;compile pass

 AJL_0_413A:
  BSR.w nextline
   BNE.w JL_0_4136
  BSR.w JUMP_do_runerrson
  BSR.w pointchk
  TST.b objectcount
   BNE macenderr
  CLR.l linenumat
  BSR.w errchx2
  CMP.l #-1,bssend
   BNE 'l30
  MOVE.l destpointer,bssend                                ;compile end

 'l30
  MOVE.l destpointer,d0
  CMP.l #-1,bssstart
  BNE 'lnf6
  CMP.l #-1,chipstart
  BNE 'lnf6
BRA 'leven4

 'lnf6
  MOVE.l destpointer,d1
  ADDQ.l #3,d1
  AND.l #$fffffffc,d1                                      ;bug ?
  MOVE.l d1,destpointer

 'leven4
  MOVE.l destpointer,codeend
  CMP.l #-1,chipend
  BNE 'l31
  MOVE.l destpointer,chipend

 'l31                                                     ;write exitcode
  MOVE.l destpointer,d1
  ADDQ.l #1,d1
  AND.l #$fffffffe,d1                                     ;new evenexit
  MOVE.l d1,destpointer
  MOVE.b debugmode(PC),D1
   BEQ.b JL_0_4180
   BSR.w debugstuff
  MOVE.w #$C300,D1
   JSR Atokejsr
   BSR.w debugstuff
  MOVE.l eopcode(PC),D1
   JSR writelong
  MOVE.l lastcontlink(PC),D1
   BEQ.b JL_0_4180
  MOVEA.l D1,A0
  CLR.w $6(A0)

 JL_0_4180:
    ;
    ;end of whole program!
    ;
  MOVE.l destpointer,endop                                ;where end goes...
    ;
  TST.w blitzmode
  BEQ.w JL_0_4198
  BSR.w do_AMIGA                                          ;back to amiga if in blitz!

 JL_0_4198:
  TST.w intsused
  BEQ.b JL_0_41AA
  MOVE.w #$C105,D1                                        ;interupts off!
  JSR tokejsr2

 JL_0_41AA:
  BSR.w calcstatic
  MOVE.w D4,numstatic
  MOVE.l D3,staticdata
   BSR.w calcmaxs

  TST.l tokeslist
   BEQ.b JL_0_41F8
  MOVE.w gotocode,D1                                       ;jmp!
   JSR writeword
  MOVE.l destpointer,endjmpat
   BSR.w addoff
   JSR writelong                                           
    ;
   BSR.w JL_0_6C76                                         ;has to be done before finits!
    ;
    ;misc finish-ups
    ;
  TST.w dontwrite
   BNE.b JL_0_41F8
  MOVEA.l endjmpat(PC),A4
  MOVE.l destpointer,(A4)

 JL_0_41F8:
  TST.b returncode
  BEQ 'l2
  MOVE.w #$2e80,d1
  JSR writeword

 'l2
  JSR JL_0_B98A
  TST.b returncode
  BEQ 'l3
  MOVE.w #$4e75,d1
  JSR writeword
BRA 'l1

 'l3
  MOVE.l #$70004E75,D1
  JSR writelong                                            ;write moveq #0,d0:rts

 'l1
  JSR JL_0_B73E
  BSR.w asmfixer
  BSR.w close_compilewin
BRA.w call_setpointernormal


.JUMP_do_runerrson:
JMP do_runerrson


;------                                                  ;disassembled code begin
eopcode:    Dc.b $70,$03                                   ;MOVEQ #$03,D0
            Dc.b $4E,$40                                   ;TRAP  #00
;------                                                  ;disassembled code end
endjmpat:   Ds.l 1

Even
pointchk:
  MOVEA.l newtype_string,A2
  MOVE.l #MaxByte,D0                                       ;move.l #$ff,d0 org source

 pointchk_loop:
    CMPA.w #$0,A2
     BEQ.w pointchk_done
    CMP.l $4(A2),D0
     BNE.w pointchk_next
    MOVE.w $8(A2),linenumat+2                              ;type not found  ;move 8(a2),linenumat org source
BRA.w notypeerr

 pointchk_next:
    MOVEA.l (A2),A2
BRA.w pointchk_loop

 pointchk_done:
RTS


errchx2:
  LEA labelbase,A2
  ;Make sure all the labels have been resolved

 errchx2_loop:
  MOVE.l (A2),D0                                           ;testlabels
   BEQ.w errchx2_done
  MOVEA.l D0,A2
  MOVE.l $4(A2),D0
  BTST #$0,D0
   BNE.w errchx2_loop
  MOVE.l $8(A2),D0
   BNE.w errchx2_loop
  MOVE.w $10(A2),linenumat+2
  MOVEQ #0,d0
  MOVE.b $12(a2),d0
  MOVE.w 0(a2,d0),linenumat
JMP nolaberr                                               ;label not found

 errchx2_done:
  MOVE.l concomsp,D0
  CMP.l #concomstack,D0
   BNE.w chxerr4
  MOVE.w connest,D1
   BNE.w chxerr4

 errchx:
  MOVE.l D1,-(A7)
  MOVE.l firstsel,D1
   BNE.w errchx_err1
  MOVE.l firstrep,D1
   BNE.w errchx_err2
  MOVE.w intstring,D1
   BNE.w errchx_err3
  MOVE.l 4(a7),d1
  MOVE.w proceduremode,D1
   BNE.w errchx_err6
  MOVE.l firstiff,d1
   BNE errchx_err5
  MOVE.l firstfor,D1
   BNE.w errchx_err7
  MOVE.l (A7)+,D1
RTS


 errchx_err1:
  MOVE.l sellineat,linenumat
JMP selerrz

 errchx_err2:
  MOVE.l replineat,linenumat
JMP unterr3

 errchx_err3:
  MOVE.l intlineat,linenumat
JMP interr2

 errchx_err5:
  MOVE.l iflineat,linenumat
JMP noenderr

 errchx_err6:
  MOVE.l prolineat,linenumat
JMP nopenderr

 errchx_err7:
  MOVE.l forlineat,linenumat
JMP nonexterr

 chxerr4:
  MOVE.l ciflineat,linenumat
JMP nocenderr


calcmaxs:                                                  ;How many max's used in prog?
  MOVE.l data1,maxsat
  MOVEQ.l #$00,D4
  MOVEA.l libpointer,A2

 calcmaxs_loop:
    CMPA.w #$0,A2
     BEQ.w calcmaxs_done
    TST.w $C(A2)
     BPL.w calcmaxs_next
    MOVE.l $12(A2),D0
    TST.w -$2(A2,D0.L)
     BEQ.w calcmaxs_next
    ADDQ.w #1,D4
    MOVE.w -$6(A2,D0.L),D1
    BSR.w pokedata1
    MOVEQ.l #$01,D1
    MOVE.w -$2(A2,D0.L),D2
    LSL.w D2,D1
    MULU -$4(A2,D0.L),D1                                   ;write objectspacesize
    BSR.w writedatalong

 calcmaxs_next:
    MOVEA.l (A2),A2
BRA.w calcmaxs_loop

 calcmaxs_done:
  MOVE.w D4,maxsused
   BEQ.w calcmaxs_done2
  MOVE.w #$FFFA,D1                                         ;;use memlib
BRA.w uselib

 calcmaxs_done2:
RTS

;was compilepass
.compile_line:                                              ;doline org source
   MOVE.l a7,stackaddr
   BSR.w compile_term
   BSR.w reget
   BNE.w illeolerr
   TST.w dontwrite
   BNE 'l1
   TST.l stacktrack
   BNE errormsg_stack

  'l1
   CMP.w #-$7FDE,D0
   BNE.w compile_line_notelse
   JSR do_else2
BRA.w compile_line

 compile_line_notelse:
  TST.w D0
  BNE.w compile_line
    ;
    ;here we do any 'un-thens'
    ;
 compile_line_unthen:
  MOVE.l firstiff,D0
   BEQ.w compile_line_done
  MOVEA.l D0,A0
  MOVE.w $C(A0),D1
   BPL.w compile_line_done
    ;
    ;an If...Then... found!
    ;
  BCLR #$F,D1
   JSR AJL_0_D7B8
   JSR AJL_0_D81C
BRA.w compile_line_unthen

 compile_line_done:
RTS


createlab:                                                 ;loclabch fetched, make a big label!
  LEA lastgloballabel,A0
  TST.b (A0)
   BEQ.w nolocerr
  LEA ptr_parameterstore,A1
  MOVEQ.l #$00,D2

 createlab_loop:
  ADDQ.w #1,D2
  MOVE.b (A0)+,(A1)+
   BNE.w createlab_loop
  MOVE.b #$27,-$1(A1)
  MOVE.w D2,-(A7)
   BSR.w makename4
  CMP.w (A7)+,D2
   BEQ.w syntaxerr
   TST.w d0
   BPL createlab_done
   MOVE.w #$3a,lastchar
   SUBQ.l #2,a5

 createlab_done:
RTS


prepstack:
  MOVE.l #forthstack,forthsp
  MOVE.l #precstack,precsp
RTS


chkrealstop:
    ;
    ;return ne if really a stop!
    ;
  MOVEQ.l #$00,D4

 chkrealstop__loop:                                        ;??looks like label not used??
  !basic
  If Peek.l(Addr Window(4))
    Use Window 4
    ev.l = Event : c_abort.b = False
    While ev
      If ev = #IDCMP_IDCMPUPDATE
        If WZGadName = "COMPILE_ABORT" Then c_abort = True
      EndIf
      If (c_abort = True)
        Pop If : Pop While
        MOVEQ.l #-$01,d4
        MOVE.w D4,stopit
        !asm
    BRA chkrealstop__skip
      EndIf
      ev = Event
    Wend
  End If
  !asm
  MOVEQ.l #$00,D6
  MOVEQ.l #$00,D7                                          ; clr Z-Flag for beq.b in chkstop_chk

 chkrealstop__skip:
  ;MOVE.w D4,stopit
RTS


chkstop:
  MOVE.w stopit(PC),D0
  BEQ chkstop__chk
  SUBQ.w #1,stopit
  ;BNE.b chkstop__chk

 chkstop__rts:
RTS

 chkstop__chk:
  MOVE.w #2000,stopit
  BSR.w chkrealstop
  BEQ.b chkstop__rts

  BSR.w close_compilewin
  BSR.w call_setpointernormal

  MOVEA.l errstack,A7
  MOVEA.l errcont,A0
  MOVE.w #-1,anyerrs
JMP (A0)


d_pc:           Ds.l 1
d_bigpc:        Ds.l 1
d_nomemleft:    Ds.w 1
cont_pc:        Ds.l 1
cont_pc2:       Ds.l 1
lastcontlink:   Ds.l 1


writetrap:                                                 ;maketrap org source
  ORI.w #$4E40,D1
BRA.w JUMP_writeword


debugstuff:
  TST.b debugmode
  BEQ.w debugstuff__rts

 debugstuffa:
  CNIF #debugmacro=0
    TST.w inmacro
    BNE debugstuff__rts                                     ;disable to show macros in debugger
  CEND                                                     ;no debugging of Macros!
  TST.w dirmode                                            ;or while in direct mode...
   BNE debugstuff__rts
  MOVE.l destpointer,d_pc
  MOVE.l bigpc,d_bigpc
  MOVE.w dontwrite,d_nomemleft
  MOVEM.l D0-D1,-(A7)
  MOVEQ.l #$01,D1
   BSR.w writetrap                                         ;write the adress to sourceline
    ;
    ;hook up cont address...
    ;
   MOVE.l destpointer,D0
  MOVE.l cont_pc,D1
  MOVE.l D0,cont_pc
  MOVE.l D1,cont_pc2
   BEQ.b debugstuff__skip
  TST.w dontwrite
   BNE.b debugstuff__skip
  MOVEA.l D1,A4
  SUB.l A4,D0
  MOVE.w D0,$6(A4)
  MOVE.l A4,lastcontlink

 debugstuff__skip:
  TST.w ininclude
  ;BEQ 'noinc
  TST.w makeexec
  BEQ 'l1
  TST.w exdebug
  BEQ 'noinc

 'l1
  MOVEM.l a0-a1/d2/d3,-(a7)                                ;write source for includes
  MOVE.l data1,d1
  TST.b firsttime
  BNE 'nofirst
  MOVE.b #1,firsttime
  MOVE.l #"DuCk",d1                                        ; to found from debugger the code start
  JSR writedatalong
  MOVE.l #"AmiB",d1
  JSR writedatalong
  MOVE.l destbufferstart,d1
  JSR writedatalong
  TST.w dontwrite
  BNE 'nohunk
  MOVE.l data1,d1
  SUBQ.l #4,d1
  SUB.l destbufferstart,d1
  MOVE.l d1,d2
  JSR addhunkoffset

 'nohunk
  MOVE.l destpointer,d2
  MOVE.l data1,d1

 'nofirst
  MOVE.l destpointer,d2
  MOVE.l d1,d3
  SUB.l destbufferstart,d1
  OR.l #$80000000,d1
  JSR writelong
  TST.w inmacro
  BEQ 'sc1
  MOVE.l myline,a0
  ;SUBQ.l #1,a0
BRA 'inc2

 'sc1  TST.w ininclude
  BEQ 'inc
  MOVE.l includesourceline,a0
BRA 'inc2

 'inc
  MOVE.l sourceline,a0
  LEA 9(a0),a0

 'inc2
  MOVE.l d1,d2
  MOVE.l A5,D1
  SUB.l a0,D1
  ADD.l #9,d1
  BSR.w JUMP_writeword
  CMP.l #9,d1
  BEQ 'pos1
  TST.w dontwrite
  BNE 'nopad
  MOVE.l lastsourceline,d1
  MOVE.l d1,-6(a4)
BRA 'nopad

 'pos1
  MOVE.l d2,lastsourceline
   MOVE.l destpointer,lastdestpointer
   MOVEQ #0,d1
  MOVE.l data1,d2
  SUB.l destbufferstart,d2
  JSR writedatalong
  TST.w dontwrite
  BNE 'no2
  JSR addhunkoffset

 'no2
  MOVE.l data1,d2
  SUB.l destbufferstart,d2
  JSR writedatalong
  TST.w dontwrite
  BNE 'no
  JSR addhunkoffset
  MOVE.l lastwritedat,a1
  CMP.l #0,a1
  BEQ 'no
  MOVE.l d3,(a1)
  MOVE.l prevwritedat,4(a1)
  MOVE.l lastwritedat,prevwritedat

 'no
  MOVE.l d3,lastwritedat
  MOVEQ #4,d1
  BSR pokedata1b

 'loop
  MOVE.b (a0)+,d1
  BEQ 'done
  BSR pokedata1b
BRA 'loop

 'done
  MOVEQ #0,d1
  BSR pokedata1b
  MOVE.l data1,d1
  BTST #0,d1
  BEQ 'nopad
  MOVEQ #0,d1
  BSR pokedata1b

 'nopad
  MOVEM.l (a7)+,a0-a1/d2/d3
BRA 'noinc2

 'noinc
  MOVE.l sourceline,D1
;  BSR.w writelong
  JSR writelong
  MOVE.l A5,D1
  SUB.l sourceline,D1
;  BSR.w writeword
  JSR writeword

 'noinc2
  MOVEQ.l #$00,D1
  JSR writeword                                            ; was: BSR.w writeword
  MOVEM.l (A7)+,D0-D1

 debugstuff__rts:
RTS


undodebug:
  TST.b debugmode                                          ;extern debug
   BEQ.b undodebug__rts
  TST.b dirmode
  BNE undodebug__rts
  CNIF #debugmacro=0
    TST.w inmacro
    BNE.b undodebug__rts
  CEND
  MOVE.w d_nomemleft,dontwrite
  MOVE.l d_bigpc,bigpc
  MOVE.l d_pc,destpointer
  MOVE.l cont_pc2,cont_pc

 undodebug__rts:
RTS

setsvars:                                                  ;set statement vars...
  ;bsr.w prepstack
  MOVE.l #forthstack,forthsp
  MOVE.l #precstack,precsp
  CLR.w regnum
  CLR.w nonew
  CLR.w sbasegot
  MOVE.w varcodelen,oldvcodelen
  CLR.w varcodelen
  MOVE.w #-1,lasta6
RTS


smode:                                                     ;special mode...d1...
  TST.w linemode
  BMI.b smode__skip
  BSR.w undodebug
  MOVE.w linemode,D1
  ADDQ.w #4,A7
  LSL.w #2,D1
  LEA modetable,A0
  MOVEA.l $0(A0,D1.W),A0
  BSR.w reget

 L_0_45CE:                                                 ;?? looks like label not used??
JMP (A0)                                                   ;jumptokenroutine

 smode__skip:
RTS


; was compileloop
.compile_term:                                              ;a0 sourceline  a5 sourcepos compile a term to next ":" or until end of line
  MOVE.w #0,leaa0a0+2
  CLR.b nowdeclare
  CLR.b notypecheck
  CLR.l lasttoken
  CLR.b doimmediate
  CLR.w vartype
  CLR.w regnumfunc
  CLR.b optistring
  CLR.b iniffcommand
  CLR.w instringon  ; new
  CLR.b funccall
  CLR.l currentfunccall
  TST.b debugmode
   BEQ 'fpu
  CNIF #fpudebug=0
    CLR.b fpu                                              ;fpu off when debug
  CEND

 'fpu
  MOVE.b fpu,iee
  MOVE.w stopit(PC),D0
  BNE chkstop_chkb
  BSR.w chkstop                                          ; message here

 chkstop_chkb
  SUBQ.w #1,stopit

 'l20
  BSR.w findmacro                                          ;macro

  CNIF #funcscan
    TST.l funcscan
    BEQ funcscanskip

   .funcscan_
    CLR.b instringf
    BSR.w get1bytemain
    CMP.w #"#",d0
    BNE 'lf9b
    JSR JL_0_4718
  BRA 'lf9b

   'lf9
    BSR.w get1bytemain

   'lf9b
    CMP.w #$22,d0
    BNE 'nos
    NOT.b instringf

   'nos
    TST.b instringf
    BNE 'sk3
    CMP.w #$8008,d0
    ;BEQ 'lf4
    CMP.w #$8009,d0
    ;BEQ 'lf4

   'sk1
    CMP.w #$8012,d0                                        ;xinclude
    BNE 'sk2
    ADDQ.l #2,lastsourcepos
    JSR do_xinclude

   'sk2
    CMP.w #$8013,d0                                        ;include
    BNE 'sk3
    ADDQ.l #2,lastsourcepos
    JSR do_INCLUDE

   'sk3
    TST.w lastchar
    BNE 'lf9
  RTS

   'lf4
  RTS
  CEND

 funcscanskip:
  CMP.b #$2b,(a5)
  BNE 'lb2
  BSR.w get1bytemain                                       ;gettokenmain
  MOVE.b #1,notypecheck

 'lb2
  TST.b debugmode
   BEQ.s 'l10
  TST.b exdebug
  BEQ 'l10a
  MOVE.w (a5),d0
  CMP.w #$8025,d0
   BEQ 'l10

 'l10a
  BSR.w debugstuffa                                         ;insert runtimecode debugcode

 'l10
 moredata                                                  ;??Looks like double labels??
 'l1
  BSR.w get1bytemain                                       ;gettokenmain
  BEQ.w undodebug                                          ;JL_0_462C
   ;  CMP.l #2698,globallinecount
   ;BNE 'lb1
   ; trap #0

 'lb1
  MOVE.l #forthstack,forthsp
  MOVE.l #precstack,precsp
  CLR.w regnum
  CLR.w nonew
  CLR.w sbasegot
  MOVE.w varcodelen,oldvcodelen

  CLR.w varcodelen
  MOVE.w #$FFFF,lasta6
  ;bsr.w setsvars
  BSR.w smode
  TST.w D0
  BMI.w get_tokencode
  CMP.w #$2E,D0
   BEQ.w JL_0_4644                                         ;shortlist
  CMP.w #"#",D0
   BEQ.w JL_0_4718                                         ;constant found
  CMP.w #$27,D0
   BEQ.w JL_0_4638                                         ;local label
  MOVE.l A5,letstart
  JSR getparameter
  BSR.w reget
   BEQ.w JL_0_4658                                         ;label found
  CMP.w #$7B,D0
   BEQ.w JL_0_475C
  TST.w d0
   BPL 'll1
  TST.b newsyntax
   BEQ 'll1
  LEA allowtab,a0
  MOVEQ #0,d1
  MOVE.b d0,d1
  TST.b 0(a0,d1.w)
   BNE 'll1
  SUBQ.l #2,a5
  MOVE.w #":",lastchar                                     ;no doublepoint
BRA JL_0_4658

 'll1
  CMP.l #"equ ",-1(a5)
   BEQ 'll4
  CMP.l #"EQU ",-1(a5)
   BNE 'll2

 'll4
  ADDQ.l #2,a5
  BSR.w findlabel2
  BEQ.w 'lf1
  BSR.w addlabelhash
  MOVE.l #$1,$4(A2)

 'lf1
  CMPI.l #$1,$4(A2)
   BNE.w illconerr
  BSR get1bytemain
  MOVE.l A2,-(A7)
     ;cmp.b #$30,d0
     ;blt 'lnonum
     ;cmp.b #$39,d0
     ;bgt 'lnonum
     ;bra 'lnum

 'lnonum
     ;cmp.b #"#",d0
     ;beq 'lnum
     ;move.b #"#",-2(a5)
  SUBQ.l #1,a5

 'lnum
  SUBQ.l #1,a5
  JSR AJL_0_BF6E
  MOVEA.l (A7)+,A2
  MOVE.l D3,$8(A2)
  RTS
  BSR get1bytemain

 'll2
  CMP.l #"SET ",-1(a5)
  BNE 'll3
BRA 'll4

 'll3
JMP AJL_0_DEA6

 JL_0_462C:
  CMP.w #-$7FDE,D0
  BEQ.w get_tokencode
BRA.w undodebug

 JL_0_4638:
  BSR.w undodebug
  BSR.w createlab
BRA.w JL_0_466E

 JL_0_4644:
  BSR.w get1bytemain
   BEQ.w JL_0_462C
  CMP.w #"'",D0
   BEQ.w JL_0_4638
   BSR.w makename2
   TST.w d0
   BPL 'll1
   SUBQ.l #2,a5
   MOVE.w #":",lastchar
BRA JL_0_4658                                              ;????

 'll1                                                      ;??looks like double labels??
 JL_0_4658:
  BSR.w undodebug
  LEA ptr_parameterstore,A0
  LEA lastgloballabel,A1

 JL_0_4668:
  MOVE.b (A0)+,(A1)+
   BNE.w JL_0_4668

 JL_0_466E:
  BSR.w findlabel2
   BEQ.w JL_0_4698
   BSR.w addlabelhash

 JL_0_467A:
  CLR.l $4(A2)
  MOVE.l destpointer,$8(A2)
  ;clr.l $c(a2)
  ;move.l data2,$C(A2)
  MOVE.w procnum,$10(A2)
RTS


JL_0_4698:
  MOVE.l $4(A2),D0
  BTST #$0,D0
   BNE.w illlaberr
  TST.w pass
  ;bne JL_0_467A
  MOVE.l $8(A2),D0
   BNE.w duplaberr
  MOVE.w procnum,$10(A2)
  MOVEA.l $4(A2),A3
  MOVEA.l _execbase,A6

 JL_0_46BC:
  CMPA.w #$0,A3
   BEQ.w JL_0_467A
    MOVE.l $4(A2),D1
    BTST #$0,D1
    BNE.w illlaberr
  MOVE.w $8(A3),D1
  CMP.w $10(A2),D1
   BEQ.w JL_0_46DC
   TST.b newsyntax
   BEQ 'l1
BRA.w JL_0_46DC                                            ;label context out of range fix
    ;
    ;Bad Reference
    ;
 'l1
  MOVE.w $A(A3),linenumat+2                                ;move 10(a3),linenumat org source
BRA.w referr

 JL_0_46DC:
  MOVE.w dontwrite,D1
   BNE.w JL_0_4706
  MOVEA.l $4(A3),A1
  BTST #$0,$7(A3)
   BEQ.w JL_0_4700
  SUBQ.w #1,A1
  MOVE.l data2,(A1)
BRA.w JL_0_4706

 JL_0_4700:
  MOVE.l destpointer,(A1)

 JL_0_4706:
  MOVEA.l A3,A1
  MOVEA.l (A3),A3
  MOVE.l A3,$4(A2)
  MOVEQ.l #$0C+2,D0
  MOVE.l mempool,a0
  MOVEA.l _execbase,A6
  JSR _FreePooled(A6)
BRA.w JL_0_46BC


JL_0_4718:
  ;bsr.w prepstack
   MOVE.l #forthstack,forthsp
  MOVE.l #precstack,precsp
   BSR.w getparameter2

 constant2:
  BSR.w findlabel2
   BEQ.w JL_0_4738
   BSR.w addlabelhash
  MOVE.l #$1,$4(A2)
BRA.w JL_0_4744

 JL_0_4738:
  CMPI.l #$1,$4(A2)
   BNE.w illconerr
  CNIF #errorconstant=1
    TST.b declare2
    BNE errormsg_declaredtwice
    TST.b declare
    BNE errormsg_declaredtwice
  CEND

 JL_0_4744:
  CMP.w #$3D,D0
  BEQ.w JL_0_474E
RTS


JL_0_474E:
  MOVE.l A2,-(A7)
  JSR AJL_0_BF6E
  MOVEA.l (A7)+,A2
  MOVE.l D3,$8(A2)                                         ;store constant
  CMP.w #$0a,lastchar
  BNE 'l1
  MOVE.w #":",lastchar                                     ;hack to read wizard include files

 'l1
RTS

JL_0_475C:
  BSR.w findproc                                           ;write statement call
  BEQ _state
  TST.l unusedfunc
  BEQ noprocerr
;BRA noprocerr
  JSR gotoendsource

 ._state
  TST.b $5(A2)
   ;BPL.w illprocerr                                         ;error function is called without returnpar
  MOVE.l a2,currentfunccall
  MOVE.b #1,funccall
  MOVE.b #1,isfunc(a2)
  MOVE.l $E(A2),-(A7)
  MOVEQ.l #$00,D0
  MOVE.b $4(A2),D0
  MOVE.l d0,parnumtemp
  BEQ.w JL_0_4786
  TST.b $20(a2)                                            ;increase if morepar
  BNE 'no0par
  MOVE.l a5,a4

 'l1
  CMP.b #$20,(a4)+
  BEQ 'l1
  CMP.b #"}",-1(a4)
  BNE  'no0par                                             ;statementcall pars
  MOVEQ #0,d0

  ;-- functioncall no pars
  LEA $16(A2),A1

 'again
  MOVE.l d1,-(a7)
  MOVE.b (a1),d2
  MOVE.l d0,d1
  CMP.w #4,d2
  BNE 'l1b
  ADD.l #$203c,d1
;  BSR writeword
  JSR writeword
  MOVE.l #$ffff0000,d1
;  BSR writelong
  JSR writelong
BRA 'l2b

 'l1b
  TST.b fpu
  BNE 'l1c
  CMP.w #5,d2
  BNE 'l1c
  ADD.l #$203c,d1
;  BSR writeword
  JSR writeword
  MOVE.l #$800000c1,d1
;  BSR writelong
  JSR writelong
BRA 'l2b

 'l1c
  ADD.l #$70ff,d1
;  BSR writeword
  JSR writeword
  MOVE.l #$f23c5000,d1
  MOVE.l d0,d2
  ASR.l #2,d2
  ADD.l d2,d1
;  BSR writelong
  JSR writelong
  MOVE.w #$ffff,d1
;  BSR writeword
  JSR writeword

 'l2b
  MOVE.l (a7)+,d1
  ADDQ.l #1,a1
  ADD.l #$0200,d0
  CMP.l #$0e00,d0
   BEQ syntaxerr
  TST.b (a1)
   BNE 'again
BRA JL_0_4786

 'no0par
  MOVE.w a2offset,a2offset2
  LEA $16(A2),A2
  MOVE.b funcparloop,-(a7)
  MOVE.b #1,funcparloop
  BSR.w fetchpees2
  MOVE.b (a7)+,funcparloop
BRA.w JL_0_478A

 JL_0_4786:
  BSR.w get1bytemain

 JL_0_478A:
  CMP.w #$7D,D0
   BNE.w morepar_                                          ;syntax error morepar
   JSR chkstak
  MOVE.l (A7)+,D1
;  CMP.l #6,parnumtemp
;  BLE 'l1
;  CMP.l #11,parnumtemp
;  BGE 'l1
;   TST.w a2offset
;   BEQ 'l1
;   MOVE.l d1,-(a7)
;   MOVE.w #$47ef,d1                                        ;lea x(a7),a3 nat
;   BSR writeword
;   MOVE.w a2offset,d1
;   SUB.w a2offset2,d1
;   BSR writeword
;   MOVE.l (a7)+,d1

 'l1
   JSR JL_0_AFCA
;   CMP.l #6,parnumtemp
;  BLE JL_0_493Ab
;  CMP.l #11,parnumtemp
;  BGE JL_0_493Ab
;   TST.w a2offset
;   BEQ.w JL_0_493Ab                                        ; changed
;   MOVE.l d1,-(a7)
;   MOVE.l #$4fef0000,d1                                    ; lea $x(a7),a7   nat
;   MOVE.w a2offset,d1
;   SUB.w a2offset2,d1
;   BSR.w writelong                                         ; correct stack with more parameters
;  MOVE.w numreps,movenumrep+2
;   BEQ.w JL_0_493Ac
;  MOVE.l movenumrep,D1
;   BSR.w writelong

; JL_0_493Ac
;  MOVE.w a2offset2,a2offset
;  MOVE.l (a7)+,d1

JL_0_493Ab:
  CLR.b funccall
BRA.w get1bytemain


get_tokencode:
  CMP.w #$c09f,d0                                          ;hack to use getregd0 instead of getd0
  BNE 'l2
   MOVE.w #$dd05,d0

 'l2
  CMP.w #$c0a0,d0                                          ;hack to use getregd0 instead of getd0
  BNE 'l3
   MOVE.w #$dd06,d0

 'l3
  CMP.w #-$7FC4,D0
  BCS.w JL_0_47C4
    CMP.w #-$7F4D,D0
    BCC.w JL_0_47C4
      BTST #$7,assemblercheck                              ;inline Assembler checking
      BNE.b JL_0_47C0
        TST.b debugmode
        BEQ.b 'l10
          CNIF #debugmacro=0
            TST.w inmacro
            BNE.b 'l10
          CEND
          MOVE.w d_nomemleft,dontwrite
          MOVE.l d_bigpc,bigpc
          MOVE.l d_pc,destpointer
          MOVE.l cont_pc2,cont_pc

 'l10
   ;bsr.w undodebug

 JL_0_47C0:
BRA.w JL_0_612C

 JL_0_47C4:
  BCLR #$F,D0
  MOVE.w D0,D1
  ANDI.w #$7F00,D1
  BNE.w JL_0_4856
    CMP.w #$B3,D0                                          ;intern Instructions
    BCS.w JL_0_47F2
      SUBI.w #$77,D0
      CMP.w #$4B,D0
      BEQ.w JL_0_4830
        CMP.w #$46,D0
        BEQ.w JL_0_4830
BRA.w JL_0_4834                                            ; change tokennum

 JL_0_47F2:
    CMP.w #$38,D0
     BEQ.w JL_0_4830
    CMP.w #$39,D0
     BEQ.w JL_0_4830
    CMP.w #$D,D0
     BEQ.w JL_0_4830
    CMP.w #$12,D0
     BEQ.w JL_0_4830
    CMP.w #$13,D0
     BEQ.w JL_0_4830
    CMP.w #$1A,D0
     BEQ.w JL_0_4830
    CMP.w #$2A,D0
     BHI.w JL_0_4834
    CMP.w #$23,D0
     BCS.b JL_0_4834

 JL_0_4830:
  BSR.w undodebug

 JL_0_4834:                                                ; change tokennum
  SUBQ.w #1,D0
  LSL.w #2,D0
  ;CMP.w #$170,D0
   ;BCS.w JL_0_4846
   ;BSR.w JL_0_359C
;RTS

 JL_0_4846:
  LEA instructionbase,A0
  MOVEA.l $0(A0,D0.W),A0
  MOVE.l A0,-(A7)
BRA.w get1bytemain


JL_0_4856:
    ;a token from a library!
    ;
  MOVE.w D0,D1
   BSR.w searchinstr
   TST.b newmode
   BNE compile_term
  BTST #$2,$1(A3)                                          ;a3 = pointer to instr ;toke stuff in a3
   BNE.w stamigalib
  BTST #$0,$1(A3)
   BEQ.w needreturn_                                       ;syntax err need return   ;check it's a statement
   BSR.w JL_0_49EA                                         ;does it need a size specifier?
   BSR.w JL_0_66F6

 JL_0_4878:
    ;number of parameters in d1....
    ;a2=lib base, a3=sub for this toke
    ;
  MOVE.w numreps,-(A7)
  MOVE.w userp,-(A7)
  MOVE.w a2offset,-(A7)
  MOVE.l A2,-(A7)                                          ;recurs.
  MOVE.w convsize,userp
  LEA $6(A3),A1
    ;
    ;now to find a form with d1 parameters in it.....
 JL_0_489A:
   MOVE.w (A1),D2
   BMI.w SERR                                              ;statement syntax error
  ANDI.w #$FF,D2
  CMP.w D2,D1
   BEQ.w JL_0_48E0
   BCS.w JL_0_48CC
  MOVE.b (A1),D3
  ANDI.w #$7,D3
   BEQ.w JL_0_48CC
  MOVE.w D2,D4
  SUB.w D3,D4
  MOVEQ.l #$00,D5
  MOVE.w D1,D5
  SUB.w D4,D5
  DIVU D3,D5
  SWAP D5
  TST.w D5
   BEQ.w JL_0_48E0

 JL_0_48CC:
  ADDQ.w #2,A1
  ADDA.w D2,A1
   BSR.w aligna1
   BSR.w skiplibreg
  LEA $C(A1),A1
BRA.w JL_0_489A

 SERR
  MOVE.w (a3),d2
  BTST #1,d2
  BEQ statement_
  CMP.w #1,d1
  BEQ statement_

 'l2:
  CMP.b #$20,(a5)+
  BEQ 'l2
  CMP.b #"(",-2(a5)
  BNE 'l1
BRA parameter_

 'l1
BRA inbrackets_

 JL_0_48E0:                                                ;Got it!
  MOVE.b (A1),D2
  LSL.w #8,D2
  OR.w D2,D1
  MOVE.l A1,-(A7)
  CLR.w a2offset
  TST.w D1
   BEQ.w JL_0_4900
  LEA $2(A1),A2
   BSR.w fetchlibps
BRA.w JL_0_4904

 JL_0_4900:
  BSR.w get1bytemain

 JL_0_4904:
  MOVEA.l (A7)+,A1
  MOVEA.l (A7)+,A2
  MOVE.w a2offset,D1
   BEQ.w JL_0_493A
  MOVE.w D1,preplibst+2
  MOVE.l preplibst,D1
   JSR writelong                                           ;write array offset stack correct
  MOVE.w numreps,movenumrep+2
   BEQ.w JL_0_493A
  MOVE.l movenumrep,D1
   JSR writelong
                                                           ;??looks like double label??
 JL_0_493A:
 'l10
  JSR userjsr

 'l20
  MOVE.w a2offset,D1
   BEQ.w JL_0_4974
  CMP.w #$8,D1
   BHI.w JL_0_4964
  ANDI.w #$7,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$504F,D1
;  BSR.w writeword
  JSR writeword
BRA.w JL_0_4974

 JL_0_4964:
  MOVE.w D1,fixlibst+2
  MOVE.l fixlibst,D1
  JSR writelong

 JL_0_4974:
  MOVE.w (A7)+,a2offset
  MOVE.w (A7)+,userp
  MOVE.w (A7)+,numreps
BRA.w reget


AJL_0_498A:
  MOVEM.l A2-A3,-(A7)
  CLR.b doublepeek
  MOVE.l A5,lastsourcepos
   BSR.w getchar
  CMP.w #$2E,D0
   BEQ.w JL_0_49B4
  MOVEA.l defaulttype,A2
  CMP.w #$24,D0
   BNE.w JL_0_49CA
  MOVEQ.l #$07,D1
BRA.w JL_0_49DE

 JL_0_49B4:
  BSR.w getparameter2
  BEQ.w syntaxerr
  LEA newtypebase,A2
  BSR.w findtype
  BNE.w notypeerr

 JL_0_49CA:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
CNIF #function_support_returntype=0
  CMPI.l #$100,$4(A2)
   BCC.w illtypeerr
CEND
  MOVE.w $6(A2),D1
  CMP.w #8,8(a2)
  BNE 'l1
  MOVE.b #1,doublepeek

 'l1                                                       ;??looks like double label??
 JL_0_49DE:
  MOVE.w D1,convsize
  MOVEM.l (A7)+,A2-A3
RTS



JL_0_49EA:
  BTST #$3,$1(A3)
  BEQ.w JL_0_4A06
  BSR.w AJL_0_498A                                         ;read peek/poke size

  ORI.w #$7000,D1
  JSR writeword
  ADDQ.w #1,regnum

 JL_0_4A06:
RTS



;------                                                  ;disassembled code begin
swapb:
            Dc.b $10,$12                                   ;MOVE.B  (A2),D0
            Dc.b $14,$91                                   ;MOVE.B  (A1),(A2)
            Dc.b $12,$80                                   ;MOVE.B  D0,(A1)
swapbf:


swapw:      Dc.b $30,$12                                   ;MOVE.W  (A2),D0
            Dc.b $34,$91                                   ;MOVE.W  (A1),(A2)
            Dc.b $32,$80                                   ;MOVE.W  D0,(A1)
swapwf:


swapl:      Dc.b $20,$12                                   ;MOVE.L  (A2),D0
            Dc.b $24,$91                                   ;MOVE.L  (A1),(A2)
            Dc.b $22,$80                                   ;MOVE.L  D0,(A1)
swaplf:


pulla1:     Dc.b $22,$5F                                   ;MOVEA.L (A7)+,A1
;------                                                  ;disassembled code end

srctype:    Ds.w 1


Even
.do_Exchange:                                              ;'swap' 2 variables.
  BSR.w excget
  CMP.w #$2C,D0
   BNE.w syntaxerr
  MOVE.b D2,srctype
  MOVE.w pusha2,D1
  JSR writeword
  BSR.w get1bytemain
  BSR.w excget
  CMP.b srctype,D2
   BNE.w excerr2
  MOVE.w pulla1,D1
   JSR writeword
  CMP.b #$2,D2
   BCS.w JL_0_4B2A
   BEQ.w JL_0_4B1E
  LEA swapl(PC),A0
  LEA swaplf(PC),A1
JMP pokecode

 JL_0_4B1E:
  LEA swapw(PC),A0
  LEA swapwf(PC),A1
JMP pokecode

 JL_0_4B2A:
  LEA swapb(PC),A0
  LEA swapbf(PC),A1
JMP pokecode

 excget:
  ;BSR.w getparameter
  JSR getparameter
  BSR.w JL_0_8E3C
  BSR.w calcvar
  BTST #$E,D2
   BEQ.w JL_0_4B4E
  MOVE.b #$4,D2

 JL_0_4B4E:
  TST.b D2
   BEQ.w excerr
  BTST #$F,D2
   BNE.w JL_0_4B6A
  MOVE.w leaamp,D1
   JSR pokewda5s
  MOVE.w D3,D1
JMP writeword

 JL_0_4B6A:
RTS


AJL_0_4B6C:
  ;movea.l comdata,A0
  ;movea.l $58(A0),A0
  MOVE.l mempool,a0
  MOVEA.l _execbase,A6
JMP _AllocPooled(a6)

;L_0_4B76:                                                  ;??looks like not used anymore??
;JMP (A0)                                                   ;allocmemfromted


.do_WBStartup:
  MOVE.w #$BF00,D1
JMP Atokejsr


.do_Pop:
  CMP.w #-$7FFA,D0
   BEQ.w popreturn
  CMP.w #-$7FEA,D0
   BEQ.w popnext2
  CMP.w #-$7FF2,D0
   BEQ.w popselect2
  CMP.w #-$7FF5,D0
   BEQ.w get1bytemain
  CMP.w #-$7FF4,D0
   BEQ.w get1bytemain
  CMP.w #-$7FEC,D0
   BEQ.w get1bytemain
  CMP.w #-$7F45,D0
   BEQ.w get1bytemain
BRA.w syntaxerr

 popreturn:
  TST.b debugmode
   BEQ.w popreturn__norerr
  LEA popreturn__rfix(PC),A0
  LEA popreturn__rfixf(PC),A1
   JSR pokecode
  MOVE.w #$C305,D1
   JSR Atokejsr
  MOVE.w popreturn__rfix2(PC),D1
   ;BSR.w writeword
   JSR writeword
BRA.w get1bytemain


 popreturn__rfix:
  CMPI.w #$6753,$4(A7)                                     ;#"gS",4(A7)
  BEQ.w popreturn__rfix2

 popreturn__rfixf:
  JSR $20000                                               ;reass
                                                           ;jsr 0 org source
 popreturn__rfix2:
  ADDQ.w #6,A7


 popreturn__norerr:
  MOVE.w popreturn__sfix(PC),D1
  JSR writeword
BRA.w get1bytemain


;------                                                  ;disassembled code begin
popreturn__sfix:
  Dc.b $58,$4F                                             ;ADDQ.W  #4,A7
;------                                                  ;disassembled code end

Even
popnext2:
  MOVE.l firstfor,D0
   BEQ.w noforerr
  MOVEA.l D0,A2
   BSR.w get1bytemain
  BSR.w popnext

 popnext3:
  TST.b debugmode
   BEQ.w popnext3__ner
  MOVE.l nextfixw2,D1
  CMPI.w #$3,$C(A2)
   BCS.w writelong2
  MOVE.l nextfixl2,D1
writelong2 JMP  writelong

 popnext3__ner:
  CMPI.w #$3,$C(A2)
   BCS.w popnext3__skip2
  MOVE.l nextfixl,D1
  JMP writelong

 popnext3__skip2:
  MOVE.w nextfixw,D1
JMP writeword


popnext:
  MOVE.w $C(A2),D0
  TST.b debugmode
   BEQ.w popnext__norunerr
  MOVE.w #$C306,D1
  CMP.w #$3,D0
   BCS.w popnext__oktc
  ADDQ.w #1,D1

 popnext__oktc:
  MOVE.l A2,-(A7)
  JSR Atokejsr
  MOVEA.l (A7)+,A2

 popnext__norunerr:
RTS


popselect2:
  MOVE.l firstsel,D0
   BEQ.w eselerr
  MOVEA.l D0,A2
   BSR.w get1bytemain

 popselect:
  MOVE.w $C(A2),D2
  TST.b debugmode
   BEQ.w popselect__norerr
  MOVE.w #$C313,D1
  CMP.w #$3,D2
   BCS.w popselect__chkit
  ADDQ.w #1,D1

 popselect__chkit:
  JSR Atokejsr                                             ;make sure next thing on stack
            ;is a select

 popselect__norerr:
  MOVEQ.l #$02,D1
  CMP.w #$3,D2
   BCS.w popselect__doit
  MOVEQ.l #$04,D1
  CMP.w #$7,D2
   BCS.w popselect__doit
  LEA endselstr,A0
  LEA endselstrf,A1
  TST.b debugmode
   BEQ.w popselect__norerr3
  LEA endselstrf2,A1

 popselect__norerr3:
  JSR pokecode
  MOVE.w #$C003,D1                                         ;global freemem
JMP Atokejsr

 popselect__doit:
  TST.b debugmode
   BEQ.w popselect__norerr2
  ADDQ.w #2,D1                                             ;for the "sE"

 popselect__norerr2:
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w endsel,D1
JMP writeword


firstrep:    Ds.l 1
replineat:   Ds.l 1


.do_Repeat:
    ;Repeat...
    ;.
    ;.
    ;.
    ;Until a=10
  CLR.l fp0addr
  MOVE.l linenumat,replineat
  MOVEQ.l #$08,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C                                           ;allocmem8
  MOVEA.l D0,A0
  MOVE.l firstrep(PC),(A0)
  MOVE.l A0,firstrep
  MOVE.l destpointer,$4(A0)
RTS


str_temp:  Ds.w 3                                            ;infochk  ds.b 6 org source
   ;
check_for_infoextention:                                     ;does a0 end in .info?
  LEA str_temp(PC),A1
  CLR.w (A1)
  CLR.l $2(A1)

 check_for_infoextention__loop2:
  MOVEQ.l #$04,D0

 check_for_infoextention__loop:
    MOVE.b $1(A1),(A1)+
  DBF D0,check_for_infoextention__loop

;  !basic
;   logging{Peek$(?str_temp)+" "}
;  !asm
  LEA str_temp(PC),A1
  MOVE.b (A0),D0
  ORI.b #$20,D0
  MOVE.b D0,$5(A1)
  TST.b (A0)+
   BNE.w check_for_infoextention__loop2
  CMPI.w #$2E69,(A1)+                                      ;".i"
   BNE.w check_for_infoextention__no
  CMPI.l #$6E666F20,(A1)                                   ;"nfo "

 check_for_infoextention__no:
RTS


gettokeps:                                                 ;toke jsr
  BPL.w gettokeps__evaltoke
  MOVE.w D0,D1
  ANDI.w #$7F80,D1
   BEQ.w tokeerr
  BCLR #$F,D0
  MOVE.w D0,D4                                             ;got toke number
  BSR.w get1bytemain
BRA.w gettokeps__gotnum

 gettokeps__evaltoke:
  JSR JL_0_BF6A
  CMP.l #MaxWord,D3
   BHI.w tokeerr
  TST.w D6
   BNE.w tokeerr
  MOVE.w D3,D4

 gettokeps__gotnum:
  MOVEQ.l #$00,D5
  CMP.w #$2C,D0
   BNE.w gettokeps__gotfrom
  MOVE.w D4,-(A7)
   JSR AJL_0_BF6E
  CMP.l #MaxWord,D3
   BHI.w tokeerr
  TST.w D6
   BNE.w tokeerr
  MOVE.w D3,D5
  MOVE.w (A7)+,D4

 gettokeps__gotfrom:
RTS                                                        ;d4=toke, d5=form


.do_LibJsr:
  TST.w D0
   BSR.w gettokeps
  MOVE.w #$4EB9,D1
  BSR.w writeword
  BSR.w addoff
  MOVE.w D5,D1
  ORI.w #$8000,D1                                          ;Toke of Amiga type.
  SWAP D1
  MOVE.w D4,D1
BRA.w writelong


.do_BLibJsr:
  TST.w D0
   BSR.w gettokeps
  MOVE.w #$4EB9,D1
  BSR.w writeword
  BSR.w addoff
  MOVE.w D5,D1
  ORI.w #$C000,D1                                          ;Toke of Blitz type.
  SWAP D1
  MOVE.w D4,D1
BRA.w writelong


.do_SysJsr:
  JSR JL_0_BF6A
  CMP.l #$10000,D3
   BCC.w tokeerr
  MOVE.w D3,D1
JMP Atokejsr


.do_TokeJsr:
  BSR.w gettokeps
  MOVE.w #$4EB9,D1
  BSR.w writeword
  MOVE.l destpointer,D3
  BTST #$7,blitzmode
   BEQ.w do_TokeJsr__inamiga
  BSET #$E,D5

 do_TokeJsr__inamiga:
  BSR.w JL_0_6E86
  BSR.w addoff
BRA.w writelong


.do_VWait:
  BEQ.w do_VWait__zero
  MOVEQ.l #$02,D2                                          ;get a word
  ;BSR.w bakeval
  JSR bakeval
  MOVE.w fvwait(PC),D1
BRA.w do_VWait__vcont

 do_VWait__zero:
  MOVE.w #$7000,D1                                         ;moveq #0,d0

 do_VWait__vcont:
  BSR.w writeword
  MOVE.w #$C104,D1
JMP Atokejsr


fvwait:
  SUBQ.w #1,D0

cgoblitz:
  Dc.w $3b7c,$ffff,0                                       ;move.w #$FFFF,$0(A5) ;noopt

cgoamiga:
  Dc.l $426d0001                                           ;clr.w $0(A5)


debugmode_codelabel:                                       ;debugmode org source
  MOVE.b debugmode(PC),D1
  BEQ.b debugmode_codelabel__skip
  MOVE.w #$D500,D1
JMP Atokejsr

 debugmode_codelabel__skip:
RTS


.do_BLITZ:                                                 ;go into Blitz mode!
  BSET #$0,blitzmode
  BSET #$7,blitzmode
  MOVE.w #$C200,D1
  JSR Atokejsr
  TST.b debugmode
   BEQ.w do_BLITZ__done
  MOVE.w cgoblitz(PC),D1
  BSR.w writeword
  MOVEQ.l #-$01,D1
  BSR.w writeword
  JSR getbbase
  BSR.w writeword

 do_BLITZ__done:
BRA.w debugmode_codelabel


.do_AMIGA:                                                 ;go into Amiga mode
  MOVE.w #$C201,D1
BRA.w do_AMIGA__toamode


.do_QAMIGA:                                                ;go into quick amiga mode
  MOVE.W  #$C202,D1

 do_AMIGA__toamode:
  BSET #$0,blitzmode
  BCLR #$7,blitzmode
  JSR Atokejsr
  TST.b debugmode
   BEQ.w do_AMIGA__done
  MOVE.w cgoamiga(PC),D1
  BSR.w writeword
  JSR getbbase
  BSR.w writeword

 do_AMIGA__done:
BRA.w debugmode_codelabel


intstart0:
  MOVEM.l D2-D7/A2-A4,-(A7)

intfin:
  MOVEM.l (A7)+,D2-D7/A2-A4


.do_ClrInt:
  JSR JL_0_BF6A
  CMP.l #$E,D3
   BCC.w interr4
  MOVE.w #$7000,D1
  OR.w D3,D1
  BSR.w writeword
  MOVE.w #$C101,D1
JMP Atokejsr                                               ;clear the interupt


inerr:       Ds.w 1                                        ;flag - in error trap mode
errjmp:      Ds.l 1                                        ;where err jump is
errcode:     Ds.l 1


.do_ClrErr:
  MOVE.W  #$D202,D1
JMP Atokejsr                                               ;BRA.W Atokejsr


doendseterr:
  MOVE.w inerr(PC),D1
   BEQ.w errerr3
  CLR.w inerr
  MOVE.w dontwrite,D1
   BNE.w doendseterr__skip
  MOVEA.l errjmp(PC),A0
  MOVE.l destpointer,(A0)

 doendseterr__skip:
BRA.w get1bytemain


.do_ErrFail:
  MOVE.w #$D205,D1
JMP Atokejsr


.do_SetErr:
  MOVE.w proceduremode,D1
   BNE.w errerr1
  MOVE.w inerr(PC),D1
   BNE.w errerr2
  LEA inerr,a0
  NOT.w (a0)                                               ;reass
  MOVE.w #$203C,D1                                         ;move.l #x,d0
  BSR.w writeword
  MOVE.l destpointer,errcode
  BSR.w addoff
  BSR.w writelong
  MOVE.w #$D201,D1
  JSR Atokejsr
  MOVE.w #$4EF9,D1                                         ;JMP
  BSR.w writeword
  MOVE.l destpointer,errjmp
  BSR.w addoff
  BSR.w writelong
  MOVE.w dontwrite,D1
   BNE.w do_SetErr__skip
  MOVEA.l errcode(PC),A0
  MOVE.l destpointer,(A0)

 do_SetErr__skip:
RTS


intlineat:  Ds.l 1


.do_SetInt:
  MOVEQ.l #-$01,D1                                        ;type - need new string space
  BSR.w errchx
  MOVE.w D1,intstring
  MOVE.l linenumat,intlineat
  JSR JL_0_BF6A                                           ;get constant - int level
  CMP.l #$E,D3
   BCC.w interr4
  ST intsused
  MOVE.w D3,intlevel
  MOVE.w #$7000,D1
  OR.w D3,D1                                              
  BSR.w writeword                                         ;moveq #x,d0
  MOVE.w #$223C,D1                                        ;move.l #x,d1
  BSR.w writeword
  BSR.w addoff
  MOVE.l destpointer,-(A7)
  BSR.w writelong
  MOVE.w #$C100,D1
  JSR Atokejsr
  MOVE.w #$4EF9,D1                                        ;jmp
  BSR.w writeword
  BSR.w addoff
  MOVE.l destpointer,intjmpat
  BSR.w writelong
  MOVEA.l (A7)+,A0
  MOVE.w dontwrite,D1
  BNE.w do_SetInt__dontpoke
  MOVE.l destpointer,(A0)

 do_SetInt__dontpoke:
  MOVE.l intstart0(PC),D1
  BSR.w writelong
  TST.b debugmode
   BEQ.w do_SetInt__norerr
    ;
    ;debugga stuff..
    ;
  MOVEQ.l #$02,D1
  BSR.w writetrap
  BSR.w addoff
  MOVE.l destpointer,intcleanat
  BSR.w writelong
  MOVE.w intlevel,D1
  BSR.w writeword
  MOVE.w #$C30B,D1                                         ;disable stack checks
  JSR Atokejsr

 do_SetInt__norerr:
  MOVE.w #$FED3,D1
  BSR.w uselib
  MOVE.w #$C102,D1
  JSR Atokejsr
  MOVE.w #-1,lasta6
  MOVE.l linenumat,intline
RTS


;intallox:                                                 ;mask for allocates for interrupts
            Ds.w 1                                         ;??looks like obsolved data??

intdata1:   Ds.l 1                                         ;where in data1 a5 is being kept

intjmpat:   Ds.l 1
intline:    Ds.l 1
intstring:  Ds.w 1                                         ;flag 0 = no setint
                                                           ;>0=setint, no st space
                                                           ;<0=set, st space
intlevel:   Ds.w 1
intcleanat: Ds.l 1
ret15add:   Ds.l 1
ret15cc:    Ds.w 1


directTrap15:                                              ;directrap trap #15
  ADDI.l #$12,$2(A7)
  MOVE.l $2(A7),ret15add
  MOVE.w (A7),ret15cc
  MOVE.l #directdo,$2(A7)
RTE
  ;.l : input - code to compile
  ;.l : firstlocal
  ;.l : firstglobal
  ;.l : returned - 0 if no compile error, else pointer to err text
  ;.w : blitz mode status

.trap15                                                    ;??looks like double label??
directdo:                                                
  MOVE.l ret15add(PC),-(A7)
  MOVE.w ret15cc(PC),-(A7)                                 ;15*4
  MOVEM.l D0-D7/A0-A6,-(A7)
  MOVE.l destbufferend,trap15temp                          ;store high buff addr
  MOVE.l destbufferstart,trap15temp2
  MOVE.l libend,templibend
  MOVE.l data1start,tempdata1start
  CLR.l hunkoffsetcounter

  MOVE.l directbuffer,a0
  CNIF #debugtrap
    MOVE.l #$40000,a0
  CEND
  MOVE.l a0,destbufferstart
  ADD.l #3900,a0
  MOVE.l a0,destbufferend
  TST.b exdebug
  BEQ 'l1
  MOVE.l a0,libend
  ADD.l #4000,a0
  MOVE.l a0,data1start

 'l1
  MOVE.l #dircont,errcont
  MOVE.l A7,errstack
  MOVE.w #$FFFF,dirmode
  CNIF #debugtrap=0
    MOVEA.l ret15add(PC),A1
    MOVE.w -(A1),blitzmode
    CLR.l -(A1)
    MOVE.l -(A1),firstglob
    MOVE.l -(A1),firstlocal
  CEND
  CLR.w proceduremode
  MOVE.l firstglob,D0
  OR.l firstlocal,D0
  BEQ.b directdo__skip
  NOT.w proceduremode

 directdo__skip:
  MOVEA.l -(A1),A0                                         ;address of string
  CNIF #debugtrap
    LEA testcode,a0
  CEND
  MOVE.l A0,-(A7)
;  MOVEA.l comdata,A1
;  MOVEA.l $38(A1),A1
  !ComData_GetL{comFunc_DebugTrap,A1}

 L_0_5164:                                                 ;??looks like label not used??
  JSR (A1)                                                 ;tokenise line.....
  MOVEA.l (A7)+,A5
  MOVE.l directbuffer,destpointer
  TST.b exdebug
  BEQ 'noexdebug
  MOVE.l a5,a0
  MOVE.l #200,d0

 'l1
    MOVE.b 0(a0,d0.l),8(a0,d0.l)
  DBF d0,'l1

  CNIF #debugtrap
    MOVE.l destbufferstart,destpointer
  CEND
  MOVE.l destpointer,a0
  MOVE.w #$207c,(a0)+
  MOVE.l a5,d0
  ADD.l #$206,d0                                           ;constant from debuglib
  MOVE.l d0,(a0)+
  MOVE.l a0,destpointer
  MOVE.l a5,a0
  MOVE.w #$8039,(a0)+                                      ;TokeJsr 164 (inputoutputlib) LSL 7+4
  MOVE.l #"$520",(a0)+
  MOVE.w #"4:",(a0)+

 'noexdebug
  CLR.w dontwrite
  MOVE.w #$FFFF,lasta6
  BSR.w compile_line                                        ;.....compile it
  TST.b exdebug
  BEQ 'noexdebug2
  JSR JL_0_6C76

 'noexdebug2
  CLR.w proceduremode
  BSR.w errchx
  MOVE.w #$4EF9,D1
  BSR.w writeword                                          ;JMP
  MOVE.l ret15add(PC),D1
  BSR.w writelong                                          ;jmp to done
  MOVE.w dontwrite,D0
   BNE.w nodirmem
  MOVE.l directbuffer,$3E(A7)                              ;install code address

 direxit:
  CLR.w dirmode
  MOVE.w ret15cc(PC),$3C(A7)
  MOVE.l trap15temp,destbufferend
  MOVE.l trap15temp2,destbufferstart
  MOVE.l tempdata1start,data1start
  MOVE.l templibend,libend
  MOVEM.l (A7)+,D0-D7/A0-A6
  BSR.w Aclearcache                                        ;selden used
RTR

dircont:                                                   ;direct mode error! - d0=error text
  MOVEA.l ret15add(PC),A0
  SUBQ.w #2,A0
  MOVE.l D0,-(A0)
BRA.w direxit


stamigalib:                                                ;an amigalib called through a statement!
  MOVE.w $6(A3),D1
  BSR.w uselib                                             ;get lib for base address
  MOVE.w $A(A1),-(A7)                                      ;libbase reg
  ADDQ.w #8,A3
  MOVE.w (A3)+,-(A7)                                       ;get offset for lib
  MOVE.l A3,-(A7)
    ;
    ;collect longs for lib
    ;
  MOVEQ.l #$00,D3

 stamigalib__loop:
  MOVE.b (A3)+,D1
   BMI.w stamigalib__done
  MOVEQ.l #$03,D2
  ADDQ.w #1,D3
  MOVEM.l D3/A3,-(A7)
   JSR peval
  MOVEM.l (A7)+,D3/A3
  CMP.w #$2C,D0
   BEQ.w stamigalib__loop
  TST.b (A3)
   BPL.w syntaxerr

 stamigalib__done:
  MOVEA.l (A7)+,A3
  SUBQ.w #1,D3
   BPL.w stamigalib__toend
   BSR.w get1bytemain                                      ;no pars - get :
BRA.w stamigalib__nopars

 stamigalib__toend:
  TST.b (A3)+                                              ;go to end of params
   BPL.w stamigalib__toend
  SUBQ.w #1,A3

 stamigalib__loop2:
   MOVEQ.l #$00,D1
   MOVE.b -(A3),D1
   BTST #$4,D1
    BNE.w stamigalib__addreg
   LSL.w #8,D1
   LSL.w #1,D1
   ORI.w #$201F,D1
 BRA.w stamigalib__gotit

  stamigalib__addreg:
   ANDI.w #$7,D1
   LSL.w #8,D1
   LSL.w #1,D1
   ORI.w #$205F,D1

  stamigalib__gotit:
    BSR.w writeword
  DBF D3,stamigalib__loop2

 stamigalib__nopars:
  MOVE.w (A7)+,libjsr+2
  MOVE.w (A7)+,libbase+2
  MOVE.l libbase,D1
   BSR.w writelong
  MOVE.l libjsr,D1
BRA.w writelong


alloxinc:                                                  
  MOVE.l data1,D4
  SUB.l data1start,D4
  ADD.l #10000,d4
  MOVE.l libend,D3
  SUB.l destbufferend,D3
  ADD.l #40000,d3
  MOVE.l bigpc,D2
  SUB.l destbufferstart,D2
  ADD.l #20000,d2
  MOVE.l databuffer,D5
  ADD.l #10000,D5
BRA newallox

;alloxinc:                                                  ;increment allocs by 150%
                                                           ;??Looks like unused code??
  MOVE.l objectbuffer,D2
  LSR.l #1,D2
  ADD.l objectbuffer,D2
  MOVE.l libsbuffer,D3
  LSR.l #1,D3
  ADD.l libsbuffer,D3
  MOVE.l systembuffer,D4
  LSR.l #1,D4
  ADD.l systembuffer,D4
  MOVE.l databuffer,D5
  LSR.l #1,D5
  ADD.l databuffer,D5
BRA.w newallox


alloxadj:                                                     ;ne if enough mem for allox
  MOVE.l bigpc,D2
  SUB.l destbufferstart,D2                                     ;size of object buffer
  SUB.l savefuncspace,d2
  ;ADD.l morememadd,d2
  TST.w debugversion
   BNE.b alloxadj__skip
  ADDI.l #$800,D2

 alloxadj__skip:
  MOVE.l libend,D3
  SUB.l destbufferend,D3
  ;ADD.l morememadd,d3
  MOVE.l data1,D4
  SUB.l data1start,D4
  ;ADD.l morememadd,d4
  MOVE.l data2,D5
  SUB.l data2at,D5
  ;ADD.l morememadd,d5
  CLR.l morememadd

 newallox:
  BSR.w makeallox
  BNE.w newallox__done
BRA.w init_buffers

 newallox__done:
RTS


freeallox:
  MOVEA.l _execbase,A6
  MOVE.l objlen,D0
  BEQ.w freeallox__skip
  CLR.l objlen
  MOVEA.l destbufferstart,A1
  MOVE.l mempool,a0
JMP _FreeVec(A6)

 freeallox__skip:
RTS


.init_buffers:                                             ;makeiallox org source ;initial allox
  MOVE.l objectbuffer,D2
  MOVE.l libsbuffer,D3
  MOVE.l systembuffer,D4
  MOVE.l databuffer,D5

 makeallox:                                                ;d2=pc size,d3=lib size,d4=data1,d5=data2
  MOVE.w #$FFFF,anyerrs
  BSR.w freeallox
    ;
    ;word align blocks
    ;
  ADDQ.l #1,D2
  BCLR #$0,D2
  ADDQ.l #1,D3
  BCLR #$0,D3
  ADDQ.l #1,D4
  BCLR #$0,D4
  TST.l d5
  BNE 'l1

 'l1
  ADDQ.l #1,D5
  BCLR #$0,D5
  MOVE.l D2,D0
  ADD.l D3,D0
  ADD.l D4,D0
  ADD.l D5,D0
  ADD.l #moremem,d0
  MOVE.l D0,D6
  MOVE.l #MemfPublic_MemfClear,D1
  MOVE.l mempool,a0
  MOVEA.l _execbase,A6
  JSR _AllocVec(a6)                                        ;alloc mem for objectbuffer
   ;jsr AJL_0_4B6C
  TST.l D0
  BEQ.w exit_initbuffers
  MOVE.l D6,objlen
  MOVE.l D2,objectbuffer
  MOVE.l D3,libsbuffer
  MOVE.l D4,systembuffer
  MOVE.l D5,databuffer
  MOVE.l D0,destbufferstart
;  MOVE.l comdata,a0
;  MOVE.l d0,$1f0(a0)
  !ComData_SetL{comPtr_DestBufferStart,D0}
  ADD.l D2,D0
  MOVE.l D0,destbufferend
  ADD.l D3,D0
  MOVE.l D0,data1start
  ADD.l D4,D0
  MOVE.l D0,data2at
  ADD.l D5,D0
  MOVE.l D0,allat

 exit_initbuffers:
RTS


divisors:
  Dc.b $00,$00,$00,$01                                     ;         1
  Dc.b $00,$00,$00,$0A                                     ;        10
  Dc.b $00,$00,$00,$64                                     ;       100
  Dc.b $00,$00,$03,$E8                                     ;      1000
  Dc.b $00,$00,$27,$10                                     ;     10000
  Dc.b $00,$01,$86,$A0                                     ;    100000
  Dc.b $00,$0F,$42,$40                                     ;   1000000
  Dc.b $00,$98,$96,$80                                     ;  10000000
  Dc.b $05,$F5,$E1,$00                                     ; 100000000
  Dc.b $3B,$9A,$CA,$00                                     ;1000000000

Even
makelong:                                                  ;put long in d2 into (a0)+; D2
  MOVEQ.l #$00,D1                                          ;no zero printed
  MOVEQ.l #$24,D3                                          ; "$"

 makelong__loop:
  MOVEQ.l #$30,D4                                          ; "0"

 makelong__loop2:
    CMP.l divisors(PC,D3.W),D2
    BCS.w makelong__skip
    SUB.l divisors(PC,D3.W),D2
    ADDQ.w #1,D4
BRA.w makelong__loop2

 makelong__skip:
  CMP.b #"0",D4
  BNE.w makelong__doit
  TST.w D1
  BEQ.w makelong__skip2

 makelong__doit:
  MOVE.b D4,(A0)+
  MOVEQ.l #$01,D1

 makelong__skip2:
  SUBQ.w #4,D3
  BPL.w makelong__loop
  TST.w D1
  BNE.w makelong__skip3
  MOVE.b #"0",(A0)+

 makelong__skip3:
  CLR.b (A0)
RTS


str_residentrequester:  Dc.b "Name of Resident File to Create",0 : Even        ;restext org source
str_residentpath:       Ds.l 48                                                ;respath org source
str_residentname:       Ds.l 48                                                ;resname org source


.menu_createresidentfile:
  MOVE.l macrobase,D0
   BNE.w create_residentfile
  MOVE.l newtype_string,D0
   BNE.w create_residentfile
  MOVEA.l labelbase,A2

 menu_createresidentfile__loop:
    CMPA.w #$0,A2
     BEQ.w menu_createresidentfile__err
    CMPI.l #$1,$4(A2)
     BEQ.w create_residentfile
    MOVEA.l (A2),A2
BRA.w menu_createresidentfile__loop

 menu_createresidentfile__err:
  !basic
    error{!TRANS{"There is no data to be stored in a resident file.\\nTry again to create the resident after one compile pass."}}
  !asm
RTS


 .create_residentfile:                                     ;.skip orgk source
  ;MOVEA.l comdata,A3
  ;MOVEA.l $18(A3),A3
  !ComData_GetL{comFunc_ASLFileRequest,A3}
  LEA str_residentrequester,A2
  LEA str_residentpath,A0
  LEA str_residentname,A1
  !basic
    Poke$ ?str_residentpath,my_residentsdir$
    Poke$ ?str_residentname,".res"
  !asm

 L_0_560C:
  JSR (A3)

  BEQ.w menu_createresidentfile__err

  ;O.K.... Now to create it
  MOVE.l D0,D1
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVEA.l _dosbase(PC),A6
  JSR _Open(A6)
  MOVE.l D0,D7                                             ;handle
  BEQ.w menu_createresidentfile__err
  MOVEM.l d2-d7/a0-a6,-(a7)
  LEA devo,a0
  LEA ptr_parameterstore,a1

 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1
  MOVEQ #13,d2
  JSR findlabel2
  BNE 'd
  TST.l 8(a2)
  BEQ 'd2
  !basic
    error{!TRANS{"Cannot create Resident with develope debug 1"}}
  !asm
  MOVEM.l (a7)+,d2-d7/a0-a6
  MOVEA.l _dosbase(PC),A6
  MOVE.l d7,d1
  JSR _Close(a6)
BRA menu_createresidentfile__err
                                                           ;??looks like double label??
 'd2
 'd
  MOVEM.l (a7)+,d2-d7/a0-a6
  BSR.w call_setpointerbusy

  BSR.w AJL_0_7962
  MOVE.l D7,D1
  MOVE.l #tsthead,D2                                       ;header
  MOVEQ.l #$20,D3
  MOVEA.l _dosbase(PC),A6
  JSR _Write(A6)
  MOVEQ.l #$00,D6                                          ;offset from start of file!
  BSR.w restypes
  BSR.w resmacs
  BSR.w resconsts
  MOVE.l D6,D3
  ADDQ.l #3,D3
  ANDI.l #$FFFFFFFC,D3                                    ;long word align
  MOVE.l D3,-(A7)
  SUB.l D6,D3
  BEQ.w menu_createresidentfile__noalign
  MOVE.l #writelist,D2
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  JSR _Write(A6)

 menu_createresidentfile__noalign:
   MOVE.l hunkoffsetcounter,tstsize3
   BEQ.w menu_createresidentfile__skip2a
  MOVE.l D7,D1
  MOVE.l #tstend,D2
  MOVEQ.l #$0C,D3
  MOVEA.l _dosbase,A6
   JSR _Write(A6)
    ;
    ;and offsets.....
    ;
  MOVEA.l hunkoffsetbase,A2

 menu_createresidentfile__oloop:
  CMPA.w #$0,A2
   BEQ.w menu_createresidentfile__skip2
  LEA $4(A2),A1
  MOVE.l D7,D1
  MOVE.l A1,D2
  MOVEQ.l #$04,D3
  MOVEA.l _dosbase,A6
   JSR _Write(A6)
  MOVEA.l (A2),A2
BRA.w menu_createresidentfile__oloop

 menu_createresidentfile__skip2:
  MOVE.l D7,D1
  MOVE.l #zero,D2
  MOVEQ.l #$04,D3
  MOVEA.l _dosbase,A6
  JSR _Write(A6)

 menu_createresidentfile__skip2a:
  MOVE.l D7,D1
  MOVE.l #tstdone,D2
  MOVEQ.l #$04,D3
  MOVEA.l _dosbase,A6
   JSR _Write(A6)
  MOVE.l (A7)+,D0
  LSR.l #2,D0
  MOVE.l D0,temp1
  MOVE.l D7,D1
  MOVEQ.l #$14,D2
  MOVEQ.l #-$01,D3
  JSR _Seek(A6)
  MOVE.l D7,D1
  MOVE.l #temp1,D2
  MOVEQ.l #$04,D3
   JSR _Write(A6)
  MOVE.l D7,D1
  MOVEQ.l #$1C,D2
  MOVEQ.l #-$01,D3
   JSR _Seek(A6)
  MOVE.l D7,D1
  MOVE.l #temp1,D2
  MOVEQ.l #$04,D3
   JSR _Write(A6)
  MOVE.l D7,D1
   JSR _Close(A6)
BRA.w call_setpointernormal


writelist:                                                 ;hello   dc.b    'ZAP',0 org source
  ADDQ.w #5,D1
  ADDQ.b #8,D0
                                                           ;writelist org source  ;a2=first, d5=.b len offset
 writelist__loop:
    CMPA.w #$0,A2
    BEQ.w writelist__done
     BSR.w writeitem
    MOVEA.l (A2),A2
BRA.w writelist__loop

 writelist__done:
RTS

 writeitem:
  MOVEQ.l #$00,D3
  MOVE.b $0(A2,D5.W),D3
  ADDQ.w #1,D3
  BCLR #$0,D3                                              ;word align
  MOVE.l (A2),-(A7)
   BEQ.w writeitem__skip
   BSR.w resoff
  ADD.l D3,D6
  MOVE.l D6,(A2)
  SUB.l D3,D6

 writeitem__skip:
   ADD.l D3,D6
  MOVE.l A2,D2
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
   JSR _Write(A6)
  MOVE.l (A7)+,(A2)
RTS

 resoff:
  MOVE.l D6,D2
BRA.w addhunkoffset


writeoffs:                                                 ;write the offsets
    CMPA.w #$0,A2
     BEQ.w writeoffs__done
    MOVEA.l newtypebase,A1
    MOVEQ.l #$00,D1

 writeoffs__loop2:
      CMPA.w #$0,A1
      BEQ.w writeoffs__found
      CMPA.l $A(A2),A1
       BEQ.w writeoffs__found
      ADDQ.w #1,D1
      MOVEA.l (A1),A1
BRA.w writeoffs__loop2

 writeoffs__found:
    MOVE.w $A(A2),-(A7)
    MOVE.w D1,$A(A2)
     BSR.w writeitem
    MOVE.w (A7)+,$A(A2)
    MOVEA.l (A2),A2
BRA.w writeoffs

 writeoffs__done:
RTS


countem:
  MOVEQ.l #$00,D0

 countem__loop:
  CMPA.w #$0,A2
   BEQ.w countem__done
  ADDQ.w #1,D0
  MOVEA.l (A2),A2
BRA.w countem__loop

 countem__done:
  MOVE.w D0,temp1
  MOVE.l D7,D1
  MOVE.l #temp1,D2
  MOVEQ.l #$02,D3
  ADDQ.l #2,D6
  MOVEA.l _dosbase,A6
JMP _Write(A6)


resmacs:                                                   ;put out! macros
   TST.b resdisable
   BEQ resmacs__l1
   MOVE.l currentmacroaddr,a3
   CMP.l #0,a3
   BEQ resmacs__l1
   MOVE.l (a3),a3
BRA resmacs__l2

 resmacs__l1:
  MOVEA.l macrobase,A3                                     ;??begin org code??

 resmacs__l2:
  MOVEA.l A3,A2
  BSR.w countem

 resmacs__loop:
   CMPA.w #$0,A3
   BEQ.w resmacs__done
  MOVE.l D6,D5
  MOVE.l (A3),-(A7)
  MOVE.l $4(A3),-(A7)
  MOVEQ.l #$00,D3
  MOVE.b $C(A3),D3
  ADDQ.w #1,D3
  BCLR #$0,D3
  ADD.l D3,D6                                              ;add len of struct
  TST.w $8(A3)
   BEQ.w resmacs__notext
  MOVE.l D6,$4(A3)
  MOVE.l D5,D2
  ADDQ.l #4,D2
   BSR.w addhunkoffset

 resmacs__notext:
  MOVEQ.l #$00,D4
  MOVE.w $8(A3),D4
  ADDQ.w #1,D4
  BCLR #$0,D4
  ADD.l D4,D6
  TST.l (A3)
   BEQ.w resmacs__nomore
  MOVE.l D6,(A3)
  MOVE.l D5,D2
   BSR.w addhunkoffset

 resmacs__nomore:
  MOVE.l A3,D2
  MOVE.l D7,D1
   ;JSR -$30(A6)           ; thilo: ??? should be resolved
   MOVEA.l _dosbase,A6
   JSR _Write(a6)
  TST.l D4
   BEQ.w resmacs__skip
  MOVE.l (A7),D2
  MOVE.l D4,D3
  MOVE.l D7,D1
   ;JSR -$30(A6)           ; thilo: ??? should be resolved
    MOVEA.l _dosbase,A6
   JSR _Write(A6)

 resmacs__skip:
  MOVE.l (A7)+,$4(A3)
  MOVE.l (A7)+,(A3)
  MOVEA.l (A3),A3
BRA.w resmacs__loop

 resmacs__done:
RTS


restypes:
  TST.b resdisable
  BEQ restypes__l1
  MOVE.l lastrestype,a3
  CMP.l #0,a3
  BEQ restypes__l1
  MOVE.l (a3),a3
BRA restypes__l2

 restypes__l1:                                              ;??begin org source??
  MOVEA.l newtype_string,A3

 restypes__l2:
  MOVEA.l A3,A2
   BSR.w countem

 restypes__loop:
   CMPA.w #$0,A3
   BEQ.w restypes__done
  MOVE.l D6,-(A7)
  MOVEA.l $4(A3),A2
  MOVEQ.l #$0E,D5
   BSR.w writeoffs
  MOVE.l (A7)+,D0
  MOVE.l $4(A3),-(A7)
  MOVE.l D0,$4(A3)
  MOVE.l D6,D2
  ADDQ.l #4,D2
   BSR.w addhunkoffset
  MOVEQ.l #$00,D3
  MOVE.b $A(A3),D3
  ADDQ.w #1,D3
  BCLR #$0,D3
  ADD.l D3,D6
  MOVE.l A3,D2
  MOVE.l D7,D1
   ;JSR -$30(A6)             ; thilo: ??? should be resolved
    MOVEA.l _dosbase,A6
    JSR _Write(A6)
  MOVE.l (A7)+,$4(A3)
  MOVEA.l (A3),A3
BRA.w restypes__loop

 restypes__done:
RTS


resconsts:
   TST.b resdisable
   BEQ resconsts__l1
   MOVE.l currentlabeladdr,a2
   CMP.l #0,a2
   BEQ resconsts__l1
   MOVE.l (a2),a2
BRA resconsts__l2

 resconsts__l1:                                             ;??begin org source??
   MOVEA.l labelbase,A2

 resconsts__l2:
   MOVEQ.l #$00,D0

 resconsts__loop:
   CMPA.w #$0,A2
   BEQ.w resconsts__done
  CMPI.l #$1,$4(A2)
   BNE.w resconsts__next
  ADDQ.w #1,D0

 resconsts__next:
  MOVEA.l (A2),A2
BRA.w resconsts__loop

 resconsts__done:
  MOVE.w D0,temp1
  MOVE.l D7,D1
  MOVE.l #temp1,D2
  MOVEQ.l #$02,D3
  ADDQ.l #2,D6
   ;JSR -$30(A6)                                            ;jsr write(a6) org source
    MOVEA.l _dosbase,A6
    JSR _Write(A6)
   TST.b resdisable
   BEQ resconsts__done_l1
   MOVE.l currentlabeladdr,a2
   CMP.l #0,a2
   BEQ resconsts__done_l1
   MOVE.l (a2),a2
BRA resconsts__loop2

 resconsts__done_l1
   MOVEA.l labelbase,A2                                    ;write resident labels

 resconsts__loop2:
   CMPA.w #$0,A2
   BEQ.w resconsts__done2
  CMPI.l #$1,$4(A2)
   BNE.w resconsts__next2
   MOVEQ.l #$00,D3
  MOVE.b $12(A2),D3                                        ;length
  ADDQ.w #1,D3
  BCLR #$0,D3
  MOVE.l D6,D2
  ADD.l D3,D6

 skipf                                                     ;??Looks like label not used??
  MOVE.l (A2),-(A7)
  TST.l (A2)
   BEQ.w resconsts__nonext
  MOVE.l D6,(A2)
   BSR.w addhunkoffset

 resconsts__nonext:
  MOVE.l A2,D2
  MOVE.l D7,D1
   ;JSR -$30(A6)
    MOVEA.l _dosbase,A6
    JSR _Write(A6)
  MOVE.l (A7)+,(A2)

 resconsts__next2:
  MOVEA.l (A2),A2
BRA.w resconsts__loop2

 resconsts__done2:
RTS


.check_residentpath
   !basic
    MOVE.l ptr_resfile,d0
    resfileP.l = Peek.l(?ptr_resfile)
    If resfileP
      resfile$ = Peek.s(resfileP)
      tests.b = Instr(resfile$,"/")
      testc.b = Instr(resfile$,":")
      If tests=0 AND testc=0
        resfile$ = dos_AddPart{my_residentsdir$,resfile$}
        Poke.l ?ptr_resfile,&resfile$
      EndIf
    Else
      error{"INTERNAL: Invalid pointer in ptr_resfile!"}
    End If
   !asm
RTS


.reloadresident:                                           ;loadres org source  ;load in resident structs.....
  MOVE.l A7,errstack
  ;JSR free_unusedfunctions
  MOVE.l #next_resentry,errcont
  MOVE.w #$FFFF,ezerr
  BSR.w Aclearallvars
  BSR.w free_residents

  LEA residents_table,A5
  MOVEQ.l #$07,D6

 reloadresident__loop:
    TST.b (A5)
    BEQ.w next_resentry
    MOVE.l A5,ptr_resfile
    BSR check_residentpath
    MOVE.l ptr_resfile,d1
    MOVEA.l _dosbase,A6
    JSR _LoadSeg(A6)
    MOVE.l D0,$40(A5)
    BNE.w reloadresident__yeah
    BSR.w reserr

  reloadresident__yeah:                                     ;res loaded O.K.
    MOVEA.l D0,A3
    ADDA.l A3,A3
    ADDA.l A3,A3
    ADDQ.w #4,A3                                           ;start of res
    BSR.w JL_0_5A9E
    BSR.w JL_0_5A62                                        ;add macros to list
    BSR.w JL_0_5A32                                        ;read labels

  next_resentry:
    LEA $44(A5),A5
  DBF D6,reloadresident__loop

    ;
    ;check resident clashes!
    ;
  MOVE.l #free_residents,errcont

  MOVEA.l newtype_string,A3
  MOVEQ.l #$0B,D7
  BSR.w checkclash

  MOVEA.l macrobase,A3
  MOVEQ.l #$d,D7
  BSR.w checkclash

  MOVEA.l firstconst,A3
  MOVEQ.l #$19,D7
  BSR.w checkclash

 skipresload:                                              ;??looks like label not used??
RTS


checkclash:
  MOVEA.l A3,A4

 checkclash__loop:
    CMPA.w #$0,A4
    BEQ.w checkclash__done

    LEA ptr_parameterstore,A0
    LEA $0(A4,D7.W),A1
    MOVEQ.l #-$01,D2

 checkclash__loop2:
      ADDQ.w #1,D2
      MOVE.b (A1)+,(A0)+
    BNE.w checkclash__loop2
    MOVEA.l A3,A2

 checkclash__more:
    BSR.w findlab
    BNE.w checkclash__next                                  ;not found
    CMPA.l A2,A4
    BEQ.w checkclash__l1
    MOVE.l a1,a5
BRA clasherr

 checkclash__l1:
BRA.w checkclash__more

 checkclash__next:
    MOVEA.l (A4),A4
BRA.w checkclash__loop

 checkclash__done:
RTS


.free_residents:
  MOVEA.l _dosbase,A6

  LEA newtype_string,A0
  MOVE.l A0,lastrestype
  CLR.l (A0)

  LEA macrobase,A0
  MOVE.l A0,currentmacroaddr
  CLR.l (A0)

  LEA labelbase,A0
  MOVE.l A0,currentlabeladdr
  CLR.l (A0)
  CLR.w rescnt

;  MOVEA.l comdata,A2
;  MOVE.b debugmode,$7ee(a2)
  !ComData_SetB{comByte_DebugMode,debugmode}

;freeres2:
  LEA residents_table,A2
  MOVEQ.l #$07,D2

 free_residents__loop:
     MOVE.l $40(A2),D1
     BEQ.w free_residents__next
      CLR.l $40(A2)
      MOVEA.l _dosbase,A6
      JSR _UnLoadSeg(A6)

  free_residents__next:
     LEA $44(A2),A2
   DBF D2,free_residents__loop

RTS


JL_0_5A32:
  MOVE.w (A3)+,D1
  BEQ.w JL_0_5A60
  MOVEA.l currentlabeladdr,A2
  MOVE.l A3,(A2)
  SUBQ.w #1,D1

 JL_0_5A42:
    MOVEA.l A3,A2
    MOVEA.l (A3),A3
  DBF D1,JL_0_5A42

  CLR.l (a2)                                               ;bugfix for object
  MOVE.l A2,currentlabeladdr
  MOVEA.l A2,A3
  MOVEQ.l #$00,D0
  MOVE.b $12(A3),D0
  ADDQ.w #1,D0
  BCLR #$0,D0
  ADDA.w D0,A3

 JL_0_5A60:
RTS


JL_0_5A62:
  MOVE.w (A3)+,D1
  BEQ.w JL_0_5A9C

  MOVEA.l currentmacroaddr,A2
  MOVE.l A3,(A2)
  SUBQ.w #1,D1

 JL_0_5A72:
    MOVEA.l A3,A2
    MOVEA.l (A3),A3
  DBF D1,JL_0_5A72

  MOVE.l A2,currentmacroaddr
  MOVEA.l A2,A3
  MOVEQ.l #$00,D0
  MOVE.b $C(A3),D0
  ADDQ.w #1,D0
  BCLR #$0,D0
  MOVE.w $8(A3),D1
  ADDQ.w #1,D1
  BCLR #$0,D1
  ADDA.w D0,A3
  ADDA.w D1,A3

 JL_0_5A9C:
RTS


JL_0_5A9E:
  MOVE.w (A3)+,D1
  BEQ.w JL_0_5B38
  MOVE.w D1,-(A7)
  SUBQ.w #1,D1
  MOVEA.l lastrestype,A2
  MOVE.l A2,-(A7)

 JL_0_5AB0:
      MOVE.l (A3),D0
      BEQ.w JL_0_5ABC
      MOVEA.l D0,A3
BRA.w JL_0_5AB0

   JL_0_5ABC:
      MOVE.b $E(A3),D0
      ADDQ.w #1,D0
      BCLR #$0,D0
      ADDA.w D0,A3
      MOVE.l A3,(A2)
      MOVEA.l A3,A2
      MOVEQ.l #$00,D0
      MOVE.b $A(A3),D0
      ADDQ.w #1,D0
      BCLR #$0,D0
      ADDA.w D0,A3
  DBF D1,JL_0_5AB0

  MOVEA.l (A7)+,A0
  MOVEA.l (A0),A0

 JL_0_5AE2:
    CMPA.w #$0,A0
    BEQ.w JL_0_5B2A
    MOVEA.l $4(A0),A1

 JL_0_5AEE:
    CMPA.w #$0,A1
    BEQ.w JL_0_5B24
    MOVE.w $A(A1),D0
    MOVEA.l newtypebase,A4
    CMP.w #$7,D0
    BCS.w JL_0_5B0E
    SUB.w rescnt,D0

 JL_0_5B0E:
    SUBQ.w #1,D0
    BMI.w JL_0_5B1A

 JL_0_5B14:
       MOVEA.l (A4),A4
  DBF D0,JL_0_5B14

 JL_0_5B1A:
    MOVE.l A4,$A(A1)
    MOVEA.l (A1),A1
BRA.w JL_0_5AEE

 JL_0_5B24:
    MOVEA.l (A0),A0
BRA.w JL_0_5AE2

 JL_0_5B2A:
  MOVE.w (A7)+,D0
  ADD.w D0,rescnt
  MOVE.l A2,lastrestype

 JL_0_5B38:
RTS


.makeasmtable:                                             ;make a table of pointers to ASM data
  LEA tokens,A0
  MOVE.w #$003A,D0                                         ; $003A : 58 dec

 JL_0_5BD0:                                                ; diese Tokens ueberspringen
    MOVEA.l (A0),A0
  DBF D0,JL_0_5BD0

  MOVEA.l #asmpnts,A1                                      ;create tokentab
  MOVE.w #$0076,D0                                         ; $0076 : 118 dec

 JL_0_5BE0:
      LEA $6(A0),A2

   JL_0_5BE4:
        TST.b (A2)+
      BNE.w JL_0_5BE4

   JL_0_5BEA:
        TST.b (A2)+
      BNE.w JL_0_5BEA

      ADDQ.w #1,A2
      EXG.l D1,A2
      BCLR #$0,D1
      EXG.l D1,A2
      MOVE.l A2,(A1)+
      MOVEA.l (A0),A0
  DBF D0,JL_0_5BE0
RTS


getimm:                                                    ;get an immediate value
  BSR.w asmconst
  MOVEQ.l #$0B,D5
RTS


unmove:  Ds.w 1


regmovems:                                                 ;d4=reg#
  MOVE.w #$48E7,D1
  BSR.w writeword                                          ;movem.l -(a7)
  MOVE.w #$000F,D2
  SUB.w D4,D2
  MOVEQ.l #-$01,D1
  BCLR D2,D1
  BSR.w writeword
  MOVEQ.l #-$01,D1
  BCLR D4,D1
  MOVE.w D1,unmove
RTS


dounmove:
  MOVE.w #$4CDF,D1
  BSR.w writeword
  MOVE.w unmove(PC),D1
BRA.w writeword

    ;if bit 15 of d2 then code has been generated for
    ;address of thing in a2. else d3=offset from a5
    ;for simple variable.
    ;
    ;d2 & ff=type. 0=struct address
    ;
    ;bit 14 of d2=1 if result is a pointer
    ;


.do_PutReg:
  BSR.w JL_0_5D22
  CMP.w #$2C,D0                                            ;#','
   BNE.w syntaxerr
  MOVE.l #$48E7FFFE,D1                                     ;movem to stack
   BSR.w writelong
  MOVE.w D4,D1
  ORI.w #$2F00,D1
   BSR.w writeword
   BSR.w get1bytemain
   BSR.w getparameter
   BSR.w JL_0_8E3C
   BSR.w calcvar
   BTST #$E,D2
   BEQ.w JL_0_5C80

 JL_0_5C78:
   MOVE.b #$3,D2
BRA.w JL_0_5C8E

 JL_0_5C80:
  TST.b D2
   BEQ.w JL_0_5C78
  CMP.b #$7,D2
   BEQ.w JL_0_5C78

 JL_0_5C8E:
  BTST #$F,D2
   BNE.w JL_0_5CA4
  MOVE.w #$45ED,D1                                         ;lea x(a5),a2
   BSR.w writeword
  MOVE.w D3,D1
   BSR.w writeword

 JL_0_5CA4:
  MOVE.w #$201F,D1                                         ;move.l (a7)+,d0
   BSR.w writeword
  MOVE.w #$1480,D1
  CMP.b #$1,D2
   BEQ.w JL_0_5CC8
  EORI.w #$3000,D1
  CMP.b #$2,D2
   BNE.w JL_0_5CC8
  ORI.w #$1000,D1

 JL_0_5CC8:
  BSR.w writeword
  MOVE.l #$4CDF7FFF,D1
BRA.w writelong


.do_setreg:
  BSR.w JL_0_5D22
  CMP.w #$2C,D0
   BNE.w syntaxerr
   BSR.w regmovems
  MOVE.w D4,-(A7)
  MOVEQ.l #$03,D2
   BSR.w eval
  MOVE.w (A7)+,D1
   BEQ.w JL_0_5D1A
  CMP.w #$8,D1
   BCC.w JL_0_5D0C
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2000,D1
   BSR.w writeword
BRA.w JL_0_5D1A

 JL_0_5D0C:
  SUBQ.w #8,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2040,D1
  BSR.w writeword

 JL_0_5D1A:
BRA.w dounmove


 JL_0_5D1E:
  BSR.w get1bytemain

 JL_0_5D22:
  ORI.w #$20,D0
  CMP.w #$64,D0
   BEQ.w JL_0_5D4E
  CMP.w #$61,D0
   BNE.w syntaxerr
   BSR.w JL_0_5D4E
  ADDQ.w #8,D4
RTS


JL_0_5D3E:
  !fget                                                   ;bsr.w get1bytemain

  ORI.w #$20,D0

 JL_0_5D46:
  CMP.w #$61,D0
  BNE.w syntaxerr

 JL_0_5D4E:
  !fget                                                    ;bsr.w get1bytemain
  SUBI.w #$30,D0
   BMI.w syntaxerr
  CMP.w #$7,D0
   BHI.w syntaxerr
  MOVE.w D0,D4
  !fget
RTS                                                        ;bra.w get1bytemain


JL_0_5D68:
  ADDQ.w #8,D4

 JL_0_5D6A:
  MOVEQ.l #$00,D5
  SUBI.w #$30,D4

 JL_0_5D70:
  CMP.w #$2D,D0
   BEQ.w JL_0_5D9E
  CMP.w #$2F,D0
   BEQ.w JL_0_5D8C
BRA.w syntaxerr

 JL_0_5D84:
  BSET D4,D5

 JL_0_5D86:
  MOVE.w D5,D4
  MOVEQ.l #$0F,D5
RTS

 JL_0_5D8C:
  BSET D4,D5
  BSR.w JL_0_5D1E
  !compare3                                                ;bsr.w JL_0_5FC0
  BNE.w JL_0_5D70
BRA.w JL_0_5D84

 JL_0_5D9E:
  MOVE.w D4,D1
   BSR.w JL_0_5D1E
  CMP.w D4,D1
   BLS.w JL_0_5DAC
  EXG.l D4,D1

 JL_0_5DAC:
  BSET D1,D5
  ADDQ.w #1,D1
  CMP.w D4,D1
   BLS.w JL_0_5DAC
  !compare3                                                ;bsr.w JL_0_5FC0
  BNE.w JL_0_5D70
BRA.w JL_0_5D86

 JL_0_5DC2:
  MOVEA.l A5,A4                                            ;bsr.w get1bytemain
   !fget
  CMP.w #$23,D0
   BEQ.w getimm
  CMP.w #$28,D0
   BEQ.w JL_0_5DFE
  CMP.w #$2D,D0
   BNE.w JL_0_5E20
   !fget                                                   ;bsr.w get1bytemain       -(
  CMP.w #$28,D0
   BNE.w JL_0_5F4E
   BSR.w JL_0_5D3E
  CMP.w #$29,D0
   BNE.w syntaxerr
  MOVEQ.l #$04,D5
  !fget                                                    ;bsr.w get1bytemain
RTS


 JL_0_5DFE:
  BSR.w JL_0_5D3E
  CMP.w #$29,D0
   BNE.w syntaxerr
  !fget                                                    ;bsr.w get1bytemain
  CMP.w #$2B,D0
   BEQ.w JL_0_5E1A
  MOVEQ.l #$02,D5
RTS


 JL_0_5E1A:
  MOVEQ.l #$03,D5
  !fget                                                    ;bra.w get1bytemain
RTS


 JL_0_5E20:
  ORI.w #$20,D0
  MOVE.w D0,D1                                            
   !fget                                                   ;bsr.w get1bytemain
  CMP.w #$64,D1
   BNE.w JL_0_5E6C
  CMP.w #$30,D0
   BCS.w JL_0_5EAE
  CMP.w #$37,D0
   BHI.w JL_0_5EAE
  MOVE.w D0,D4
   !fget                                                   ;bsr.w get1bytemain
   !compare3                                               ;bsr.w JL_0_5FC0
   BEQ.w JL_0_5E64
  CMP.w #$2D,D0
   BEQ.w JL_0_5D6A
  CMP.w #$2F,D0
   BEQ.w JL_0_5D6A
BRA.w JL_0_5EB8

 JL_0_5E64:
  MOVEQ.l #$00,D5
  SUBI.w #$30,D4
RTS

 JL_0_5E6C:
   CMP.w #$61,D1
   BNE.w JL_0_5EAE
  CMP.w #$30,D0
   BCS.w JL_0_5EAE
  CMP.w #$37,D0
   BHI.w JL_0_5EAE
  MOVE.w D0,D4
   !fget                                                   ;bsr.w get1bytemain
   !compare3                                               ;bsr.w JL_0_5FC0
   BEQ.w JL_0_5EA6
  CMP.w #$2D,D0
   BEQ.w JL_0_5D68                                         ;movem
  CMP.w #$2F,D0
   BEQ.w JL_0_5D68
BRA.w JL_0_5EB8

 JL_0_5EA6:
  MOVEQ.l #1,d5
  SUBI.w #$30,D4

BRA 'l10
  ADDQ.w #8,d4
  MOVEQ #0,d5
  BSET d4,d5
  MOVE.w d5,d4
  MOVEQ.l #$0f,D5                                          ;01

 'l10
RTS


 JL_0_5EAE:
  ORI.w #$20,D0
  MOVE.w D0,D4
   !fget                                                   ;bsr.w get1bytemain

 JL_0_5EB8:
  !compare3                                                ;bsr.w JL_0_5FC0
   BNE.w JL_0_5EF2
  CMP.w #$73,D1
   BNE.w JL_0_5EF2
  CMP.w #$70,D4
   BNE.w JL_0_5EDE
   !compare3                                               ;bsr.w JL_0_5FC0
   BNE.w JL_0_5F4E
  MOVEQ.l #$07,D4
  MOVEQ.l #$01,D5
RTS


 JL_0_5EDE:
  CMP.w #$72,D4
   BNE.w JL_0_5F4E
   !compare3                                               ;bsr.w JL_0_5FC0
   BNE.w JL_0_5F4E
  MOVEQ.l #$0D,D5
RTS


 JL_0_5EF2:
  ORI.w #$20,D0
  CMP.w #$63,D1
   BNE.w JL_0_5F22
  CMP.w #$63,D4
   BNE.w JL_0_5F4E
  CMP.w #$72,D0
   BNE.w JL_0_5F4E
   BSR.w get1bytemain                                      ;??wy not !fget
   BEQ.w JL_0_5F1E
  CMP.w #$2C,D0
   BNE.w JL_0_5F4E

 JL_0_5F1E:
  MOVEQ.l #$0C,D5
RTS


 JL_0_5F22:
  CMP.w #$75,D1
   BNE.w JL_0_5F4E
  CMP.w #$73,D4
   BNE.w JL_0_5F4E
  CMP.w #$70,D0
   BNE.w JL_0_5F4E
   BSR.w get1bytemain                                      ;??wy not !fget
   BEQ.w JL_0_5F4A
  CMP.w #$2C,D0
   BNE.w JL_0_5F4E

 JL_0_5F4A:
  MOVEQ.l #$0E,D5
RTS


 JL_0_5F4E:
  MOVEA.l A4,A5
   BSR.w asmconst
   !compare3                                               ;bsr.w JL_0_5FC0
   BEQ.w JL_0_5FB8
  CMP.w #$2E,D0
   BEQ.w JL_0_5FA0
  CMP.w #$28,D0
   BNE.w syntaxerr
   BSR.w get1bytemain                                      ;??wy not !fget
  ORI.w #$20,D0
  CMP.w #$70,D0
   BNE.w JL_0_5F98
   BSR.w get1bytemain                                      ;??wy not !fget
  ORI.w #$20,D0
  CMP.w #$63,D0
   BNE.w syntaxerr
   BSR.w get1bytemain                                      ;??wy not !fget
   BSR.w JL_0_5FD4
  ADDQ.w #4,D5
RTS


 JL_0_5F98:
  BSR.w JL_0_5D46
BRA.w JL_0_5FD4


 JL_0_5FA0:
   BSR.w get1bytemain                                     ;??wy not !fget
  ORI.w #$20,D0
  CMP.w #$77,D0
   BEQ.w JL_0_5FBC
  CMP.w #$6C,D0
   BNE.w syntaxerr

 JL_0_5FB8:
  MOVEQ.l #$08,D5
RTS


 JL_0_5FBC:
  MOVEQ.l #$07,D5
RTS


 JL_0_5FC0:
  TST.w D0
   BEQ.w JL_0_5FD2
  CMP.w #$3A,D0
   BEQ.w JL_0_5FD2
  CMP.w #$2C,D0

 JL_0_5FD2:
RTS


 JL_0_5FD4:
  CMP.w #$2C,D0
   BNE.w JL_0_6054
   BSR.w get1bytemain                                      ;??wy not !fget
  ORI.w #$20,D0
  MOVEQ.l #$00,D1
  CMP.w #$64,D0
   BEQ.w JL_0_5FFA
  CMP.w #$61,D0
   BNE.w syntaxerr
  BSET #$F,D1

 JL_0_5FFA:
   BSR.w get1bytemain                                      ;??wy not !fget
  SUBI.w #$30,D0
   BMI.w syntaxerr
  CMP.w #$7,D0
   BHI.w syntaxerr
  LSL.w #8,D0
  LSL.w #4,D0
  OR.w D0,D1
   BSR.w get1bytemain                                      ;??wy not !fget
  CMP.w #$2E,D0
   BNE.w JL_0_6040
   BSR.w get1bytemain                                      ;??wy not !fget
  ORI.w #$20,D0
  CMP.w #$77,D0
   BEQ.w JL_0_603C
  CMP.w #$6C,D0
   BNE.w syntaxerr
  BSET #$B,D1

 JL_0_603C:
   BSR.w get1bytemain                                      ;??wy not !fget

 JL_0_6040:
   CMP.b #"*",d0                                           ;020 * Mode
            BNE 'l1
            BSR.w get1bytemain                             ;??wy not !fget
            CMP.b #"2",d0
            BNE 'l2
            OR.w #$200,d1
BRA 'l1b

 'l2
            CMP.b #"4",d0
            BNE 'l3
            OR.w #$400,d1
BRA 'l1b

 'l3
            CMP.b #"8",d0
            BNE syntaxerr
            OR.w #$600,d1

 'l1b
        BSR.w get1bytemain                                 ;??wy not !fget

 'l1
  CMP.w #$29,D0
   BNE.w syntaxerr
  MOVE.w D1,extraword
  MOVEQ.l #$06,D5
BRA.w get1bytemain                                         ;??wy not !fget


 JL_0_6054:
  CMP.w #$29,D0                                            ;")"
   BNE.w syntaxerr
  MOVEQ.l #$05,D5
BRA.w get1bytemain                                         ;??wy not !fget


asmconst:                                                  ;store the text of the eval into asmfirst...
    ;
    ;text till '(','.'
    ;
  MOVEA.l asmbuff,A0
  MOVE.w ininclude,D1
  OR.w inmacro,D1
  MOVE.w D1,(A0)+                                          ;flag!
   BNE.w copyconst
  MOVE.l A5,-(A7)
   BSR.w copyconst
  MOVEA.l asmbuff,A0
  CMP.w #$4,D1
   BLS.w asmconst__leave
  TST.w lc
   BNE.w asmconst__leave
  ADDQ.w #2,A0
  MOVE.l (A7)+,(A0)+
  CLR.b (A0)
  MOVE.w #$0004,asmlen2                                    ;pointer + 0
RTS


 asmconst__leave:
  NOT.w (A0)
  ADDQ.w #4,A7
RTS


lc:  Ds.w 1


copyconst:
  CLR.w lc
  MOVEQ.l #$00,D1

 copyconst__loop:
   ADDQ.w #1,D1                                            ;label name
   !fget                                                   ;bsr.w get1bytemain
   BEQ.w copyconst__done
   CMP.w #$22,d0
   BNE.s copyconst__loop_l10
   NOT.w instringon

 copyconst__loop_l10:
   CMP.w #":",d0
   BNE.s copyconst__loop_l11
   TST.w instringon
   BEQ copyconst__done

 copyconst__loop_l11:
  TST.w D0
  BPL.w copyconst__notmi
  MOVE.w D0,-(A7)
  LSR.w #8,D0
  MOVE.b D0,(A0)+
  MOVE.w (A7)+,D0
  MOVE.b D0,(A0)+
  ADDQ.w #1,D1
BRA.s copyconst__loop

 copyconst__notmi:
   TST.w instringon
   BNE.w copyconst__putbyte
   TST.b _dcb
   BNE copyconst__notmi_l10
   CMP.w #$28,D0
   BEQ.w copyconst__done

 copyconst__notmi_l10
   CMP.w #$2C,D0
   BEQ.w copyconst__done
   CMP.b #"'",D0
   BNE.w copyconst__putbyte
   MOVE.w D0,lc                                     ;locallabels
   MOVE.l A1,-(A7)
   LEA lastgloballabel,A1
   TST.b (A1)
   BEQ.w nolocerr

 copyconst__cloop:
  ADDQ.w #1,D1
  MOVE.b (A1)+,(A0)+
   BNE.w copyconst__cloop
  SUBQ.w #1,D1
  SUBQ.w #1,A0
  MOVEA.l (A7)+,A1

 copyconst__putbyte:
  MOVE.b D0,(A0)+
BRA.w copyconst__loop

 copyconst__done:
  CLR.b (A0)
  MOVE.w D1,asmlen2
RTS


JL_0_612C:
  ;jsr do_even
  CMP.l #$80ad,d0
  BNE.s 'l12
JMP bssseg

 'l12
  CMP.l #$807f,d0
    BNE.s 'l13
JMP chipseg

 'l13
  ADDQ.l #1,destpointer                                    ;even
  BCLR #$0,destpointer+3
  SUBI.w #$803C,D0
  LSL.w #2,D0
  MOVEA.l #asmpnts,A0
  MOVEA.l $0(A0,D0.W),A0                                   ;begin inline assembler
  MOVE.w D0,temp1
  MOVE.l A0,-(A7)
  MOVEQ.l #$01,D1
   !fget                                                   ;bsr.w get1bytemain
  CMP.w #$2E,D0
   BNE.w JL_0_6184
  !fget                                                    ;bsr.w get1bytemain
  ORI.w #$20,D0
  CMP.w #$77,D0                                            ;long
   BEQ.w JL_0_618A
  CMP.w #$62,D0                                            ;byte
   BEQ.w JL_0_617A
  CMP.w #$6C,D0                                            ;word
   BEQ.w JL_0_6196
  CMP.w #"s",d0
  BNE syntaxerr
BRA.w JL_0_617A

 JL_0_617A:
  MOVEQ.l #$00,D1
  MOVE.w $8(A0),D0
BRA.w JL_0_619E

 JL_0_6184:
  MOVEQ.l #$04,D1
BRA.w JL_0_61AE

 JL_0_618A:
  MOVEQ.l #$04,D1
  MOVE.w $8(A0),D0
  LSR.w #4,D0
BRA.w JL_0_619E

 JL_0_6196:
  MOVEQ.l #$08,D1
  MOVE.w $8(A0),D0
  LSR.w #8,D0

 JL_0_619E:
   ANDI.w #$F,D0
  CMP.w #$F,D0
   BNE.w 'cl60

 'c10
   CMP.l #"MULS",-6(a0)
   BNE 'c20
   MOVE.l #$4c000800,d1
JMP do32

 'c20
   CMP.l #"MULU",-6(a0)
   BNE 'c30
   MOVE.l #$4c000000,d1
JMP do32

 'c30
   CMP.l #"DIVS",-6(a0)
   BNE 'c40
   MOVE.l #$4c400800,d1
JMP do32

 'c40
   CMP.l #"DIVU",-6(a0)
   BNE 'c50
   MOVE.l #$4c400000,d1
JMP do32

 'c50
BRA illsizeerr

 'cl60
  !fget                                                    ;bsr.w get1bytemain

 JL_0_61AE:
  MOVE.w D1,asmsize
  MOVEQ.l #-$01,D3
   BSR.w reget
   BEQ.w JL_0_6200
  MOVE.l #ptr_parameterstore,asmbuff
   ;bsr.w bakup
   MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
   BSR.w JL_0_5DC2
  MOVE.l D4,D2                                             ;to src
  MOVE.l D5,D3
  MOVE.w asmlen2,asmlen
  MOVEQ.l #-$01,D5
  MOVE.w extraword,extraword2
  CMP.w #$2C,D0                                            ;','
   BNE.w JL_0_6200
  MOVE.l #namebuff2,asmbuff
   BSR.w JL_0_5DC2                                         ;dest

 JL_0_6200:
  MOVEA.l (A7)+,A0
  MOVEA.l destpointer,A1
  MOVEA.l A1,A4
  ADDQ.w #2,A1
  MOVE.w (A0),D1
  TST.w D3
   BMI.w JL_0_639E
  MOVE.w $E(A0),D0
   BPL.w JL_0_6264
  BTST #$0,D0
   BEQ.w JL_0_6240
  CMP.w #$1,D5
   BNE.w JL_0_6240
  CMP.w #$E,D3
   BEQ.w JL_0_6264
  MOVE.w temp1,D0
  ADDQ.w #4,D0
BRA.w JL_0_6256

 JL_0_6240:
  BTST #$1,D0
   BEQ.w JL_0_6264
  CMP.w #$B,D3
   BNE.w JL_0_6264
  MOVE.w temp1,D0

 JL_0_6256:
  ADDQ.w #4,D0
  MOVEA.l #asmpnts,A0
  MOVEA.l $0(A0,D0.W),A0
  MOVE.w (A0),D1

 JL_0_6264:
  MOVE.l #ptr_parameterstore,buff1
  MOVE.l #namebuff2,buff2
  MOVE.l $A(A0),D0
   BEQ.w JL_0_62DC
  MOVEA.l D0,A3
  MOVE.w asmsize,D6

 L_0_6288:
   JSR (A3)
   BPL.w JL_0_629A
  CMP.w #-$2,D0
   BEQ.w illsizeerr
BRA.w illeaerr

 JL_0_629A:
  BEQ.w JL_0_62DC
  EXG.l D2,D4
  EXG.l D3,D5
  MOVE.l extraword,D6
  SWAP D6
  MOVE.l D6,extraword
  MOVE.l #namebuff2,buff1
  MOVE.l #ptr_parameterstore,buff2
  MOVE.w asmlen,D6
  MOVE.w asmlen2,D7
  MOVE.w D6,asmlen2
  MOVE.w D7,asmlen

 JL_0_62DC:
  MOVE.l buff1,asmbuff
  MOVE.w $E(A0),D0
   BEQ.w JL_0_6348
   BMI.w JL_0_6348
   CMP.w #$7000,d1
   BNE 'skip
   CMP.w #$b,d3
   BNE illeaerr

 'skip
   CMP.w #$1,D0
   BNE.w JL_0_630E
   CMP.w #$B,D3
   BNE.w JL_0_6348

 JL_0_6302:
   BSR.w insasm
  MOVE.w D4,D2
  MOVE.w D5,D3
BRA.w JL_0_6364

 JL_0_630E:
   CMP.w #$2,D0
   BNE.w JL_0_6324
  CMP.w #$8,D3
   BNE.w illeaerr
  MOVEQ.l #$09,D3
BRA.w JL_0_6348

 JL_0_6324:
   CMP.w #$3,D0
   BEQ.w JL_0_6302
  CMP.w #$4,D0
   BEQ.w JL_0_6302
  CMP.w #$5,D0
   BNE.w JL_0_6348
  CMP.w #$8,D5
   BNE.w illeaerr
  OR.w D2,D1
  MOVEQ.l #$09,D5

 JL_0_6348:
  MOVE.w $2(A0),D6
  MOVE.b $6(A0),D7
  MOVEM.l D4-D5,-(A7)
  MOVE.w extraword2,D4
   BSR.w doea
  MOVEM.l (A7)+,D2-D3
  TST.w D3

 JL_0_6364:
    BMI.w JL_0_6392
  MOVE.w extraword,D4
  MOVE.w $4(A0),D6
  MOVE.b $7(A0),D7
  MOVE.l buff2,asmbuff
  MOVE.w asmlen2,asmlen
   BSR.w doea
BRA.w JL_0_63AA

 JL_0_6392:
  MOVE.w $4(A0),D0
   BNE.w illeaerr
BRA.w JL_0_63AA


JL_0_639E:
  MOVE.w $2(A0),D0
  OR.w $4(A0),D0
   BNE.w illeaerr

 JL_0_63AA:
  MOVE.w $8(A0),D0
  ANDI.w #$F000,D0
  CMP.w #-$1000,D0
   BEQ.w JL_0_63D2
  LSR.w #8,D0
  LSR.w #4,D0
  MOVE.w $8(A0),D2
  MOVE.w asmsize,D3
  LSR.w D3,D2
  ANDI.w #$F,D2
  LSL.w D0,D2
  OR.w D2,D1

 JL_0_63D2:
  CMPA.l destbufferend,A4
   BCS.w JL_0_63E8

  MOVE.w #$FFFF,dontwrite
BRA.w JL_0_63EA

 JL_0_63E8:
  MOVE.w D1,(A4)

 JL_0_63EA:
  MOVE.l A1,destpointer
RTS


asmoff:                                                 ;add an offset
  MOVE.l destpointer,-(A7)
  MOVE.l A1,destpointer
   BSR.w addoff
  MOVEA.l destpointer,A1
  MOVE.l (A7)+,destpointer
RTS


.do32
  MOVEM.l d2-d6,-(a7)
  JSR stripspaces
  CMP.b #"d",(a5)+
  BNE noreg
  MOVE.b (a5)+,d0
  CMP.b #$30,d0
  BLT noreg
  CMP.b #$37,d0
  BGT noreg
  SUB.b #$30,d0
  MOVEQ #0,d3
  MOVE.b d0,d3                                             ;reg1
  ASL.l #8,d3
  ASL.l #8,d3
  JSR stripspaces
  CMP.b #",",(a5)+
  BNE noreg
  JSR stripspaces
  CMP.b #"d",(a5)+
  BNE noreg
  MOVE.b (a5)+,d0
  CMP.b #$30,d0
  BLT noreg
  CMP.b #$37,d0
  BGT noreg
  SUB.b #$30,d0
  MOVEQ #0,d4
  MOVE.b d0,d4                                             ;reg2
  ASL.l #8,d4
  ASL.l #4,d4
  OR.b d0,d1
  OR.l d3,d1
  OR.l d4,d1
  JSR writelong
  MOVEM.l (a7)+,d2-d6
  MOVEM.l d1/a1-a3,-(a7)
BRA exit


noreg
  MOVEM.l (a7)+,d2-d6
  LEA errtext,a0
  MOVE.l a0,-(a7)
JMP handle_compileerror


;BRA syntaxerr                                              ;??looks like dead code??

;RTS                                                        ;??looks like dead code??


asmfixer:                                                  ;end of pass asm filler-inner
  MOVE.w dontwrite,D1
   BNE.w asmfixer__done
  BTST #$7,make_smallestcode
   BEQ.w asmfixer__go
  MOVE.w pass(PC),D1
   BEQ.w asmfixer__done

 asmfixer__go:
  MOVEA.l templabel,A2                                     ;insert labels in Code
  MOVE.b #1,curtemplabel
  MOVE.w #$FFFF,constmode
  CLR.w regnum
          MOVE.l #forthstack,forthsp
          MOVE.l #precstack,precsp
   BSR.w prepstack

 asmfixer__loop:
  MOVE.l A2,-(A7)
   BSR.w chkstop
  MOVEA.l (A7)+,A2
  CMPA.w #$0,A2
   BEQ.w asmfixer__done2
   CLR.b iee
  MOVE.l A2,asmbuff
  LEA $10(A2),A5
  TST.b $F(A2)
   BNE.w asmfixer__skipo
  MOVEA.l (A5),A5                                          ;pointer to real text

 asmfixer__skipo:
   CLR.w asmtype
   CMP.b #".",(a5)
   BNE.s asmfixer__skipo_l10
   MOVE.l a2,-(a7)
   ADDQ.l #1,a5
   LEA newtypebase,a2
   BSR getparameter2
   BEQ.w syntaxerr
   BSR findtype
   BNE.w notypeerr
   LEA $4(a2),a2
   BSR getparameter2
   BEQ.w syntaxerr
   BSR.w findvariable2
   BNE.w notypeerr
   MOVE.w $4(a2),d3
   EXT.l d3
BRA asmfixer__skipo_l30b

 asmfixer__skipo_l10:
  CMP.b #"\",(a5)
    BNE asmfixer__skipo_l20
    ADDQ.l #1,a5
   MOVE.l a2,-(a7)
   MOVE.l a5,a4
   LEA usedpath,a5
   CMP.b #"*",(a5)
   BNE asmfixer__skipo_lm1
   ADDQ.l #1,a5

 asmfixer__skipo_lm1:
   BSR.w getparameter2
   BEQ.w syntaxerr
   LEA varbase,A2
   MOVE.b #1,newvariable
   BSR.w findvariable
   CLR.b newvariable
   CMP.l #-1,d0
   BEQ.w notypeerr
   MOVE.l a4,a5
   MOVE.l $a(a2),a2
   LEA $4(a2),a2
   BSR getparameter2
   BEQ.w syntaxerr
   BSR.w findvariable2
   BNE.w notypeerr
  MOVE.w $4(A2),D3
  EXT.l D3

 asmfixer__skipo_l30b:
   CMP.b #"[",-1(a5)
   BNE asmfixer__skipo_l30c
   MOVEQ #0,d0
   MOVE.b (a5)+,d0
   MOVE.l d3,-(a7)
   MOVEQ #0,d3
   JSR atoi
   MOVE.l (a7)+,d1
   MOVE.l $a(a2),a2
   MOVE.w 8(a2),d0
   MULS d0,d3
   ADD.l d1,d3

 asmfixer__skipo_l30c:
  MOVE.l (a7)+,a2
BRA asmfixer__oko

 asmfixer__skipo_l20:
  CMP.w #$c,$8(a2)
     BEQ asmfixer__skipo_lf1
     CMP.w #$d,$8(a2)
     BEQ asmfixer__skipo_lf1

 asmfixer__skipo_lf2:
  JSR AJL_0_BF6E

 asmfixer__skipo_l30:
  MOVEA.l asmbuff,A2
   BEQ.w asmfixer__oko
  CMP.w #$28,D0
   BEQ.w asmfixer__oko
  CMP.w #$2C,D0
   BEQ.w asmfixer__oko
BRA.w syntaxerr

 asmfixer__skipo_lf1:
  MOVE.b #1,iee
BRA asmfixer__skipo_lf2

asmfixer__oko:
  MOVEA.l $4(A2),A1

  MOVE.w $8(A2),D1                                         ;labelmode
  CMP.w #$5,D1
   BNE.w asmfixer__notdan

 asmfixer__word:
   BSR.w chkword                                         ;word

 asmfixer__word2:
  MOVE.w D3,(A1)
BRA.w asmfixer__next

 asmfixer__notdan:
  CMP.w #$6,D1
   BNE.w asmfixer__notdanxi

 asmfixer__isbyte:
   BSR.w chkbyte                                         ;byte

 asmfixer__isbyte2:
  MOVE.b D3,$1(A1)
BRA.w asmfixer__next

 asmfixer__notdanxi:
   CMP.w #$11,D1                                           ;byte
   BEQ.w asmfixer__isbyte2
   CMP.w #$c,d1
   BEQ asmfixer__single1
   CMP.w #$d,d1
   BEQ asmfixer__double1
  CMP.w #$7,D1
   BEQ.w asmfixer__word                                    ;word
  CMP.w #$8,D1
   BNE.w asmfixer__notabsl

 asmfixer__isabsl:
  MOVE.w asmtype,D1                                        ;long
   BEQ.w asmfixer__notpcrel
     BSR.w asmoff

 asmfixer__notpcrel:
  MOVE.l D3,(A1)
BRA.w asmfixer__next


 asmfixer__single1
  fmove.s fp0,0(a1)
BRA.w asmfixer__next


 asmfixer__double1
  fmove.d fp0,0(a1)
BRA.w asmfixer__next


 asmfixer__notabsl:
  CMP.w #$9,D1
   BNE.w asmfixer__notdpc
  SUB.l A1,D3                                              ;branchword
   BSR.w chkword
  MOVE.w D3,(A1)
BRA.w asmfixer__next


 asmfixer__notdpc:
  CMP.w #$A,D1
   BNE.w asmfixer__imm
  SUB.l A1,D3                                              ;branchbyte
BRA.w asmfixer__isbyte


 asmfixer__imm:
  CMP.w #$11,d1
  BLE asmfixer__imm_org
  MOVE.l a3,-(a7)
  LEA pluginbase,a3
  MOVE.l 8(a2),a0
  JSR (a0)                                                 ;hook
  MOVE.l (a7)+,a3
BRA asmfixer__next

 asmfixer__imm_org:
  MOVE.w $A(A2),D0
   BEQ.w asmfixer__noflag
  CMP.w #$1,D0
   BEQ.w asmfixer__tocount
  CMP.w #$3,D0
   BEQ.w asmfixer__tomoveq
  CMP.w #$4,D0
   BEQ.w asmfixer__totrap

 asmfixer__noflag:
  CMP.w #$B,D1                                             ;long
   BEQ.w asmfixer__isabsl
BRA asmfixer__word2                                              ;word

 asmfixer__totrap:
  CMP.l #$F,D3
   BHI.w illtraperr
  OR.b D3,-(A1)
BRA.w asmfixer__next

 asmfixer__tocount:
  CMP.l #$8,D3
   BHI.w illimmerr
  TST.l D3
   BEQ.w illimmerr
  ANDI.w #$7,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,-(A1)
BRA.w asmfixer__next

 asmfixer__tomoveq:
   BSR.w chkbyte
  MOVE.b D3,-(A1)

 asmfixer__next:
  MOVEA.l (A2),A2
BRA.w asmfixer__loop

 asmfixer__done2:
  CLR.w constmode

 asmfixer__done:
  CLR.b curtemplabel
RTS


doea:
    ;d2=reg, d3=ea, d4=extraword, d5=asm type
    ;d6=allowable mask, d7=shift data
    ;
    ;or in bits for opcode in d1
    ;
  BTST D3,D6
   BEQ.w illeaerr
   BSR.w makemode
  CMP.w #$7,D3
   BCS.w doea__skip
  MOVE.w D3,D2
  SUBQ.w #7,D2
  CMP.w #$5,D2
   BCS.w doea__skip0
  MOVEQ.l #$04,D2

 doea__skip0:
  MOVEQ.l #$07,D3

 doea__skip:
  MOVE.b D7,D0
  ANDI.w #$F,D0
  CMP.w #$F,D0
   BEQ.w doea__skip2
  LSL.w D0,D3
  OR.w D3,D1

 doea__skip2:
  LSR.w #4,D7
  ANDI.w #$F,D7
  CMP.w #$F,D7
   BEQ.w doea__skip3
  LSL.w D7,D2
  OR.w D2,D1

 doea__skip3:
RTS


chkbyte:
  CMP.l #$7F,D3
   BGT.w illdiserr
  CMP.l #$FFFFFF80,D3                                      ;#-128,d3 org source
   BLT.w illdiserr
RTS


chkword:
  CMP.l #$7fff,D3
   BGT.w illdiserr
  CMP.l #$FFFF8000,D3                                      ;#-32768,d3 org source
   BLT.w illdiserr
RTS


findchar                                                   ;??Looks like double label??
 'll20:
  MOVE.b (a5)+,d0
  CMP.b d1,d0
  BEQ 'll10
  TST.b d0
  BNE 'll20

 'll10:
  SUBQ #1,a5
RTS


findnext                                                   ;??looks like double label??
 'll20:
  MOVE.b (a5)+,d0
  CMP.b #",",d0
  BEQ 'll10
  CMP.b #";",d0
  BEQ 'll10
 CMP.b #":",d0
  BEQ 'll10
  ;cmp.b #"(",d0
  ;beq 'll10
  TST.b d0
  BNE 'll20

 'll10:
  SUBQ #1,a5
RTS


macroexecute
  ADD.l a2,d1
  LEA tempspace,a1
  MOVE.l d1,a0

 'l10
  MOVE.b (a0)+,(a1)+
  BNE.s 'l10
  SUBQ.l #1,a0
  SUBQ.l #1,a1

 'l20
  MOVE.b (a5)+,(a1)+
  BNE.s 'l20
  CLR.b (a1)
  LEA tempspace,a5
RTS


calc
  MOVEM.l D1-D2/A0,-(A7)
  MOVE.l d0,d2
  MOVEQ #0,d1
  MOVE.l a5,a4

 'll20:
  ADDQ.l #1,d1
  MOVE.b (a5)+,d0
  CMP.b #",",d0
  BEQ 'll10
  CMP.b #";",d0
  BEQ 'll10
  CMP.b #":",d0
  BEQ 'll10
  CMP.b #"(",d0
  BEQ 'll10
  TST.b d0
  BNE 'll20

 'll10:
  SUBQ #1,a5
  CMP.b #"'",(a4)
  BEQ 'llocal
  TST.w inmacro
  BNE 'lmacro
  MOVEQ.l #$14+4,D0
  ADD.l d1,d0
  MOVE.l d1,-(a7)
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C                                          ;allocmemforcompile
  MOVE.l (a7)+,d1
  TST.l d0
  BEQ nomemory
  MOVEA.l D0,A0
  ;MOVE.w linenumat+2,$C(A0)
  MOVE.w linenumat+2,$A(A0)
  ;MOVE.w linenumat,$c(a0)
  MOVE.l templabel,(A0)
  MOVE.l A0,templabel
  MOVE.l destpointer,$4(A0)
  MOVE.l d2,$8(A0)
  LEA $E(A0),A0
  MOVE.b #$14,(A0)+
  CLR.b (a0)+
  ;MOVE.l A4,(A0)+
  MOVE.l a0,d2
  ADDQ.l #4,d2
  MOVE.l d2,(a0)+

 'lc1
  MOVE.b (a4)+,(a0)+
  SUBQ.l #1,d1
  BNE 'lc1
  CLR.b (a0)+
  MOVE.w linenumat,(a0)
  MOVEM.l (A7)+,D1-D2/A0
RTS

 'lmacro
  MOVEQ.l #$10+2,D0
  ADD.l d1,d0
  MOVEM.l a4/d3,-(a7)
  MOVE.l d1,d3
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C                                          ;allocmemforcompile
  TST.l d0
  BEQ nomemory
  MOVEA.l D0,A0

 'o2
  MOVE.w linenumat+2,$C(A0)
  MOVE.l templabel,(A0)
  MOVE.l A0,templabel
  MOVE.l destpointer,$4(A0)
  MOVE.l d2,$8(A0)
  LEA $E(A0),A0
  MOVE.b d3,(A0)+
  ADD.b #$10,-1(a0)
  MOVE.b #$1,(a0)+
  SUBQ.w #1,d3

 'lm2
  MOVE.b (a4)+,(a0)+
  SUBQ.l #1,d3
  BNE.s 'lm2
  CLR.b (a0)+
  MOVE.w linenumat,(a0)
  MOVEM.l (a7)+,d3/a4
  MOVEM.l (A7)+,D1-D2/A0
RTS

 'llocal
  LEA lastgloballabel,a1

 'll11
  ADDQ.l #1,d1
  TST.b (a1)+
  BNE.s 'll11
  MOVEQ.l #$10+2,D0
  ADD.l d1,d0
  MOVEM.l a4/d3,-(a7)
  MOVE.l d1,d3
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C                                          ;allocmemforcompile
  TST.l d0
  BEQ nomemory
  MOVEA.l D0,A0

 'o3
  MOVE.w linenumat+2,$C(A0)
  MOVE.l templabel,(A0)
  MOVE.l A0,templabel
  MOVE.l destpointer,$4(A0)
  MOVE.l d2,$8(A0)
  LEA $E(A0),A0
  MOVE.b d3,(A0)+
  ADD.b #$10,-1(a0)
  MOVE.b #$1,(a0)+
  SUBQ.w #1,d3
  LEA lastgloballabel,a1

 'lm3
  SUBQ.l #1,d3
  MOVE.b (a1)+,(a0)+
  BNE.s 'lm3
  SUBQ.l #1,a0

 'lm1
  MOVE.b (a4)+,(a0)+
  SUBQ.l #1,d3
  BNE.s 'lm1
  CLR.b (a0)+
  MOVE.w linenumat,(a0)
  MOVEM.l (a7)+,d3/a4
  MOVEM.l (A7)+,D1-D2/A0
RTS


.nomemory
  !basic
  error{!TRANS{"No memory available!!!\\nAB3 will terminate due to low memory!"}}
  loop Delay_ 1
Goto loop


insasm:                                                    ;ass asmbuff, asmlen, pc, ea to list
  MOVEM.l D0-D2/A0,-(A7)
  MOVE.w $E(A0),-(A7)
   BPL.w insasm__ok
  CLR.w (A7)

 insasm__ok:
  MOVE.l A1,-(A7)
  MOVEQ.l #$10+2,D0
  ADD.w asmlen,D0
  MOVE.w D0,D2
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C                                          ;allocmemforcompile
  MOVEA.l D0,A0

 'o                                                         ;??Looks like label not used??
  MOVE.w linenumat+2,$C(A0)
  MOVE.l templabel,(A0)
  MOVE.l A0,templabel
  MOVE.l (A7),$4(A0)
  MOVE.w d3,$8(A0)
  MOVE.w $4(A7),$A(A0)
  LEA $E(A0),A0
  MOVE.b D2,(A0)+                                           ;length
  MOVEA.l asmbuff,A1
  ADDQ.w #1,A1
  MOVE.b (A1)+,(A0)+                                        ;type - 0 = indirect,else direct
   BNE.w insasm__loop
  MOVE.l (A1)+,(A0)+
  MOVE.w linenumat,(a0)
BRA.w insasm__loopdone

 insasm__loop:
   MOVE.b (A1)+,(A0)+
   BNE.w insasm__loop
   MOVE.w linenumat,(a0)

 insasm__loopdone:
  MOVEA.l (A7)+,A1
  ADDQ.w #2,A7
  MOVEM.l (A7)+,D0-D2/A0
RTS


makemode:
  CMP.w #$5,D3
   BCS.w makemode__done
  CMP.w #$B,D3
   BHI.w makemode__done2
   BEQ.w makemode__imm
   BSR.w insasm
  CMP.w #$5,D3
   BEQ.w makemode__word
  CMP.w #$6,D3
   BEQ.w makemode__dxi
  CMP.w #$7,D3
   BEQ.w makemode__word
  CMP.w #$8,D3
   BEQ.w makemode__long
  CMP.w #$9,D3
   BEQ.w makemode__word
   ;d(pc,xi)

 makemode__dxi:
  CMPA.l destbufferend,A1
   BCS.w makemode__ok7
  ADDQ.w #2,A1
RTS

 makemode__ok7:
  MOVE.w D4,(A1)+
RTS

 makemode__imm:
  CMPI.w #$8,asmsize
   BCC.w makemode__immlong
  MOVEQ.l #$10,D3
   BSR.w insasm
  MOVEQ.l #$0B,D3
BRA.w makemode__word

 makemode__immlong:
  BSR.w insasm

 makemode__long:
  ADDQ.w #2,A1

 makemode__word:
  ADDQ.w #2,A1
RTS

 makemode__done2:
  CMP.w #$F,D3
   BNE.w makemode__done
  CMPA.l destbufferend,A1
   BCS.w makemode__ok3
  ADDQ.w #2,A1
  ADDQ.w #4,A7
RTS

 makemode__ok3:
  MOVE.w D2,(A1)+
  ADDQ.w #4,A7

 makemode__done:
RTS


JL_0_66F6:
  BSR.w storeloc
  MOVE.l linenumat,oldline
  MOVEQ.l #$00,D1
   BSR.w get1bytemain
   BEQ.w JL_0_676E
  MOVEQ.l #$00,D3
BRA.w JL_0_6726

 JL_0_670A:
   BSR.w get1bytemain
   BNE.w JL_0_671C

 ready
  TST.w D3
   BNE.w brackets_                                         ;syntax error brackets
BRA.w JL_0_676C

 JL_0_671C:
   MOVE.w instringon,D4
   ;BNE.w JL_0_670A
     BEQ JL_0_6726

 'l1
    MOVEQ #0,d0
     MOVE.b (a5)+,d0                                       ;fix "ue"
     MOVE.w d0,lastchar
     BEQ ready
     CMP.b #$22,d0
     BNE 'l1
     NOT.w instringon
BRA JL_0_670A

 JL_0_6726:
           CMP.b #"@",d0                                   ;expand line @@ 1. for parameter
           BNE 'l10
           CMP.b #"@",(a5)
           BNE 'l10

 'l111
           TST.w ininclude
           BNE 'inc
           MOVE.l sourceline3,a5
           CMP.l #0,a5
           BNE 'l11t
           MOVEA.l sourceline,A5

 'l11t
           MOVEA.l (A5),A5
           CMP.l #0,a5
           BEQ JL_0_676C
           MOVE.l a5,sourceline3
           LEA $9(A5),A5
BRA 'l11

 'inc
           ADDQ.l #1,a5
           TST.b (a5)
           BNE 'inc
           ;BEQ illeolerr

 'l11
           ADDQ.l #1,a5
           TST.b (a5)
           BEQ illeolerr
           MOVE.l a5,-(a7)

 'l110
      CMP.b #" ",(a5)+
      BEQ 'l110
       CMP.b #";",-1(a5)
       MOVE.l (a7)+,a5
       BEQ 'l111
BRA JL_0_670A

 'l10
   CMP.w #$29,D0
   BNE.w JL_0_673A
  TST.w D3
   BEQ.w JL_0_676C

 JL_0_6734:
  SUBQ.w #1,D3
BRA.w JL_0_670A

 JL_0_673A:
   CMP.w #$7D,D0
   BEQ.w JL_0_6734
  CMP.w #$28,D0
   BNE.w JL_0_6750

 JL_0_674A:
   ADDQ.w #1,D3
BRA.w JL_0_670A

 JL_0_6750:
  CMP.w #$7B,D0
   BEQ.w JL_0_674A
  CMP.w #$2C,D0
   BNE.w JL_0_670A
  TST.w D3
   BNE.w JL_0_670A
  ADDQ.w #1,D1
BRA.w JL_0_670A

 JL_0_676C:
  ADDQ.w #1,D1

 JL_0_676E:
  CLR.l sourceline3
  MOVE.l oldline,linenumat
BRA.w resloc


fetchlibps:
   CLR.w numreps
  MOVE.w D1,D0
  ANDI.w #$FF00,D0
   BEQ.w fetchlibps__noreps
  LSR.w #8,D0
  LSR.w #4,D0
   BEQ.w fetchlibps__skip
  SUB.b D0,D1
   MOVE.w regnum,regnumfunc
   MOVE.b funcparloop,-(a7)
   MOVE.b #0,funcparloop
   BSR.w fetchpees2
   MOVE.b (a7)+,funcparloop
  CMP.w #$2C,D0
   BNE.w syntaxerr

 fetchlibps__skip:
  MOVE.w D1,D2
  LSR.w #8,D2
  ANDI.w #$7,D2

 fetchlibps__rloop:
   CMP.b D2,D1
   BCS.w fetchlibps__repsdone
  SUB.b D2,D1
  MOVEM.l D2/A2,-(A7)
  MOVE.w D2,D0
  MOVE.b funcparloop,-(a7)
  MOVE.b #0,funcparloop
  BSR.w fetchpees4
  MOVE.b (a7)+,funcparloop
  MOVEM.l (A7)+,D2/A2
  ADDQ.w #1,numreps
BRA.w fetchlibps__rloop

 fetchlibps__repsdone:
   MOVE.w numreps,D3
   BEQ.w syntaxerr
  ADDA.w D2,A2
  ANDI.w #$FF,D1
   BEQ.w fetchlibps__done
  CMP.w #$2C,D0
   BNE.w syntaxerr

 fetchlibps__noreps:
   MOVE.w D1,D0
   BNE.w fetchpees2b

 fetchlibps__done:
RTS

 fetchpees2b
  MOVE.b funcparloop,-(a7)
  MOVE.b #0,funcparloop
  BSR.w fetchpees2
  MOVE.b (a7)+,funcparloop
RTS


;------                                                  ;disassembled code begin
ptype:    Dc.b $3F,$3C,$00,$00                             ;MOVE.W  #$0000,-(A7)
;------                                                  ;disassembled code end

partostack:  Ds.w 1                                        ;pmode org source

Even
fetchpees4:                                                ;always push
  MOVEQ.l #$01,D2
BRA.w fetchpees3

 fetchpees2:                                               ;dont push unless told.
  MOVEQ.l #$00,D2

 fetchpees3:
  ANDI.w #$F,D0
    ;
;fetchpees:                                                ;??looks like label not used??
    ;fetch a list of parameters.
    ;
    ;d0=number to fetch, a2=pointer to type buffer
    ;d1=push mode
    ;
  CLR.w parnum
  MOVE.w D1,-(A7)
  MOVE.w partostack(PC),-(A7)                              ;in case of recursion
  MOVE.w D2,partostack
  MOVE.w D0,-(A7)
  CMP.w #"@@",(a5)                                         ;was l15
  BNE fetchpees__loop
  TST.w ininclude                                          ;merge macrolines
  BNE errorjoin
       MOVEA.l sourceline,A5

 'l111                                                     ;??Looks like label not used??
           MOVEA.l (A5),A5
           MOVE.l a5,sourceline
           LEA $9(A5),A5
           ADDQ.l #1,linenumat

 ;'l15                                                      ;??looks liks double label??
 fetchpees__loop:
  MOVE.b (A2)+,D2                                          ;parameterloop   d2=vartype
   BNE.w fetchpees__skip0
  MOVE.w userp,D2                                          ;user selected type

 fetchpees__skip0:
   MOVE.l A2,-(A7)
   ADDQ.w #1,parnum
   TST.b funccall
   BEQ fetchpees__skip0_l1
   CMP.w #6,parnum
   BLE fetchpees__skip0_l1
   CMP.w #7,d2
   CNIF #more6string=0
     BEQ more6par
   CEND

 fetchpees__skip0_l1:
   TST.b fpu
   BEQ fetchpees__skip0_old
   TST.w regnumfunc
   BEQ fetchpees__skip0_old
   CMP.w #$48e7,-4(a4)
   BNE fetchpees__skip0_old
   MOVEQ #0,d1
   MOVE.w regnum,d1
   CMP regnumfunc,d1                                       ;fpu reg function save
   BGE fetchpees__skip0_old
   ASL.w #7,d1
   MOVE.l d0,-(a7)
   MOVE.w regnumfunc,d0
   CLR.w regmask

 fetchpees__skip0_loop:
   BSET d0,regmask
   SUBQ #1,d0
   BNE fetchpees__skip0_loop
    MOVEQ #0,d0

 fetchpees__skip0_loop2:
      BTST d0,regmask
      BEQ fetchpees__skip0_noa7
      MOVEQ #0,d1
      MOVE.w d0,d1
      SUBQ.w #1,d1
      ASL #7,d1
      OR.l #$f2277400,d1                                   ;fmove.d
      ;OR.l #$f2276400,d1                                   ;fmove.s
      BSR writelong

      ADDQ.l #2,stacktrack
      MOVE.l stacktrack,d1
      CMP.l #180,d1
      BGT conmemerr                                        ;formel too complex
      MOVE.l a0,-(a7)
      LEA fpustackbase,a0
      MOVE.w regmask,0(a0,d1)
      MOVE.l (a7)+,a0

 fetchpees__skip0_noa7:
      ADDQ.w #1,d0
      CMP.w regnumfunc,d0
      BLE fetchpees__skip0_loop2

 fetchpees__skip0_ready:
      MOVE.l (a7)+,d0

 fetchpees__skip0_old:
     MOVE.l currentfunccall,-(a7)
     MOVE.w parnum,-(a7)
     BSR.w JL_0_6836
     MOVE.w (a7)+,parnum
;  CLR.b funcparloop
   MOVE.l (a7)+,currentfunccall
CNIF #function_typecheck
   TST.b typecheck
   BEQ 'notypecheck
   CMP.l #0,currentfunccall
   BEQ 'isblitzlibcall
   MOVEM.l a0/a1,-(a7)
   MOVE.l currentfunccall,a0
   MOVE.w parnum,d1
   TST.b isconstantvalue
   BEQ 'noconstant
   CMP.l #0,lastconstantvalue
   BEQ 'isnull
'noconstant   MOVE.l funcstruct_parametertype-4(a0,d1*4),a0
   CMP.l #0,a0
   BEQ 'notype
   CMP.l #$100,4(a0)
   BLE 'notype
   MOVE.l lastinstruction,d1
   CMP.w #$b581,d1                   ; ok, when token for null
   BEQ 'isnull
   CMP.l a0,a2
   BEQ 'ok
                    ; check if type is parent
   CMP.l #$100,4(a2)                 ; is a type here
   BLE 'error
   MOVE.l 4(a2),a1                   ; load the address of type.
   CMP.l $a(a1),a0                   ; check if the bigger type contain in first place same type as the function need
   BEQ 'ok
'error: JMP   error_convert_types
'ok
'notype
'isnull
   MOVEM.l (a7)+,a0/a1
'isblitzlibcall
'notypecheck
CEND
   CLR.l lastfunction
   TST.b fpu
   BEQ fetchpees__skip0_noprint
  MOVE.l (a7),a2
  ADDQ.l #1,a2
   CMP.b #5,d2
  BNE fetchpees__skip0_noprint
  CMP.b #$5d,24(a2)
  BNE fetchpees__skip0_noprint
  CMP.b #$81,25(a2)
  BLT fetchpees__skip0_noprint
  CMP.b #$86,25(a2)
  BEQ fetchpees__skip0_ok
  CMP.b #$87,25(a2)
  BEQ fetchpees__skip0_ok
  CMP.b #$88,25(a2)
  BEQ fetchpees__skip0_ok
  CMP.b #$83,25(a2)
  BGT fetchpees__skip0_noprint

 fetchpees__skip0_ok:
  MOVE.l destpointer,a4
  CMP.w #$2f00,-2(a4)
  BNE fetchpees__skip0_noprint
  SUBQ.l #2,destpointer
;  MOVE.w (a2),-(a7)                                        ;fpu print,nprint,str$
  MOVE.l #$f2277400,d1
  BSR writelong                                            ;fmove.d fp0,-(a7)
  ADDQ #4,a2offset
;  MOVE.w #$c0,(a2)
;  MOVE.l a2,-(a7)
;  JSR fetchregs
;  MOVE.l #$f2006400,d1                                     ;fmove.s fp0,d0
;  BSR writelong
;  MOVE.l #$4EAEFF94,d1                                     ;SPfieee
;  BSR writelong
;  MOVE.l (a7)+,a2
;   MOVE.w (a7)+,(a2)
  ;CMP.b #$83,25(a2)
  ;BEQ fetchpees__skip0_nomovea7
  ;MOVE.w #$2e80,d1
  ;BSR writeword
; fetchpees__skip0_nomovea7:


 fetchpees__skip0_noprint:
  CLR.b optistring
  MOVEA.l (A7)+,A2
   CMP.w #"@",d0
  BNE fetchpees__skip0_l10
   CMP.b #"@",(a5)
  BNE fetchpees__skip0_l10
  TST.w ininclude
  BNE errorjoin
  MOVEA.l sourceline,A5
           MOVEA.l (A5),A5
           MOVE.l a5,sourceline
           ADDQ.l #1,linenumat
           LEA $9(A5),A5
           MOVEQ #0,d0
           BSR get1bytemain

 fetchpees__skip0_l10:
   CMP.b #32,(a5)+ ;for space after a ,
   BEQ fetchpees__skip0_l10:
   SUBQ.l #1,a5

   CMP.w #"@@",(a5)                                        ;if merge
   BNE fetchpees__skip0_l15
   MOVEM.l d0-d7/a0-a4/a6,-(a7)
   JSR mergeline
   MOVEM.l (a7)+,d0-d7/a0-a4/a6

; fetchpees__skip0_l111:
;           MOVEA.l sourceline,A5
;           MOVEA.l (A5),A5
;           MOVE.l a5,sourceline
;  ADDQ.l #1,linenumat
;           LEA $9(A5),A5
;           TST.b (a5)
;           BEQ fetchpees__skip0_l111
;           MOVE.l a5,-(a7)

; fetchpees__skip0_l110:
;   CMP.b #" ",(a5)+
;   BEQ fetchpees__skip0_l110
;   CMP.b #";",-1(a5)
;   MOVE.l (a7)+,a5
;   BEQ fetchpees__skip0_l111

 fetchpees__skip0_l15:
      SUBQ.w #1,(A7)
   BEQ.w fetchpees__done

    CMP.w #$2C,D0
   ;BNE.w notparerr                                         ;not enough parameter
   BNE overloadfunc
BRA.w fetchpees__loop

 fetchpees__done:
  ADDQ.w #2,A7
  MOVE.w (A7)+,partostack
  MOVE.w (A7)+,D1
  CLR.b isconstantvalue
  MOVE.l currentfunccall,lastfunction
  CLR.b funccall
  CLR.l currentfunccall
RTS


overloadfunc:
  CLR.b funccall
  MOVE.w regnum,d1
  MOVE.l currentfunccall,a4
  CMP.b $20(a4),d1                                         ;increase if more pars
  BLT notparerr

 'ol2
  MOVE.b (a2)+,d2
  ADD.w #1,parnum
  TST.b fpu
  BEQ 'nofpu
  CMP.b #5,d2
  BNE 'nofpu
  MOVEQ #0,d1
  MOVE.w regnum,d1
  CMP.w #6,regnum
  BLT 'nostack2
  CNIF #more6string=0
    CMP.l #$b,parnumtemp
    BGE more6par
  CEND
  MOVE.w #$2c3c,d1
  BSR writeword
  MOVE.l #$bf800000,d1
  BSR writelong
  MOVE.w #$c4ff,d1                                         ;savetemp+regnum
  ADD.w parnum,d1
  JSR Atokejsr
  TST.w dontwrite
  BNE 'l1
  MOVE.l data1start,d1
  MOVE.l destpointer,a4
  ADD.l d1,-4(a4)
  MOVE.l destpointer,d1
  SUBQ.l #4,d1
  SUB.l destbufferstart,d1
  MOVE.l d2,-(a7)
  MOVE.l d1,d2
  JSR addhunkoffset
  MOVE.l (a7)+,d2
BRA 'l1

 'nostack2
  ASL.l #7,d1
  OR.l #$F23C5000,d1                                       ;fmove.w #-1,fpx
  BSR writelong
  MOVEQ #-1,d1                                             ;-1
  BSR writeword
BRA 'l1

 'nofpu
  MOVE.w regnum,d1
  CMP.w #6,regnum
  BLT 'nostack
  CNIF #more6string=0
    CMP.l #$b,parnumtemp
    BGE more6par
  CEND
  CMP.b #2,d2
  BGT 'nw
BRA 'nos

 ; ADDQ #2,a2offset
 ; MOVE.l #$3f3cffff,d1
 ; BSR writelong
;BRA 'l1

 'nw
  ;ADDQ #4,a2offset
  CMP.w #7,d2
  BNE 'nos
  ADDQ #4,a2offset
  CNIF #more6string
    MOVE.l #$48780000,d1
    BSR writelong
    ADDQ.w #4,a2offset
    MOVE.w #$2f3c,d1
    BSR writeword
    MOVE.l #-1,d1
    BSR writelong
  BRA 'l1
  CEND

 'nos
  CMP.b #4,d2
      BNE 'noq
      MOVE.w #$2c3c,d1
      BSR writeword
      MOVE.l #$ffff0000,d1
      BSR writelong
BRA 'noq2

 'noq
     CMP.b #5,d2
     BNE 'nof
      MOVE.w #$2c3c,d1
      BSR writeword
      MOVE.l #$800000c1,d1
      BSR writelong
BRA 'noq2

 'nof
  MOVE.w #$7cff,d1
  BSR writeword

 'noq2
  MOVE.w #$c4ff,d1                                         ;savetemp+regnum
  ADD.w parnum,d1
  JSR Atokejsr
   TST.w dontwrite
   BNE 'l1
   MOVE.l data1start,d1
   MOVE.l destpointer,a4
   ADD.l d1,-4(a4)
   MOVE.l destpointer,d1
   SUBQ.l #4,d1
   SUB.l destbufferstart,d1
   MOVE.l d2,-(a7)
   MOVE.l d1,d2
   JSR addhunkoffset
   MOVE.l (a7)+,d2
BRA 'l1

 'nostack
  ASL.l #8,d1
  ASL.l #1,d1
  OR.l #$203c,d1                                           ;-1
  BSR writeword
  MOVE.l #-1,d1
  CMP.b #4,d2
  BNE 'nq1
  MOVE.l #$ffff0000,d1

 'nq1
  CMP.b #5,d2
  BNE 'nof2
  TST.b fpu
  BNE 'nof2
  MOVE.l #$800000c1,d1

 'nof2
   BSR writelong
   CMP.b #7,d2
   BNE 'l1
   CNIF #more6string
     MOVE.l #$48780000,d1
     BSR writelong
   CEND
   ADDQ.w #4,a2offset                                      ; bug fix for string parameters
   MOVE.l #$594f,d1                                        ; subq #4,a7
   BSR writeword

  'l1
   SUBQ.w #1,(A7)
   BEQ.w fetchpees__done
   ADDQ.w #1,regnum
BRA 'ol2

 JL_0_6836:
   MOVE.w D2,D1
   ANDI.w #$40,D1
   MOVE.b D1,partostack
   TST.b D2
    BMI.w handlevara
   BTST #$5,D2
    BNE.w handlearr
    MOVE.w regnumstore,-(a7)
    MOVE.w tempregnum,-(a7)
    MOVE.w parnum,-(a7)
    BSR.w getap                                        ;recursive entry
    MOVE.w (a7)+,parnum
    MOVE.w (a7)+,tempregnum
    MOVE.w (a7)+,regnumstore

 JL_0_6854:
    MOVE.w partostack(PC),D1
    BEQ.w JL_0_6886

 JL_0_685C:
   ADDQ.w #4,a2offset

 'l10
   MOVE.w pushdn,D1
   OR.w regnum,D1
   CMP.w #$3,D2
    BCC.w JL_0_6880
   SUBQ.w #2,a2offset
   ORI.w #$1000,D1
   BSR.w writeword
RTS

 JL_0_6880:
  CMP.b #7,d2
   BNE 'l10
   CMP.b #2,optistring
   ;BEQ 'l20                                                ;muicycle fix

 'l10
  TST.b iee
  BEQ 'old
  CMP.b #5,d2
  BNE 'old

 'old
  BSR.w writeword                                          ;write val to stack
RTS

 'l20
  SUBQ.w #4,a2offset
RTS

 JL_0_6886:
  ADDQ.w #1,regnum
RTS


 putalp:
  MOVEQ.l #$03,D2
BRA.w JL_0_6854


 handlevara:                                               ;Here, we want the address of a var type d2
  ANDI.w #$7,D2
  MOVE.w D2,-(A7)
   BSR.w JL_0_A916
  CMP.b #$7,D2                                             ;ignore pnt to $
   BEQ.w JL_0_68C0
  BTST #$E,D2
   BEQ.w JL_0_68B6
  MOVE.b #$3,D2                                            ;pointer to long
BRA.w JL_0_68C0

 JL_0_68B6:
   TST.b D2
   BNE.w JL_0_68C0
  MOVE.b #$3,D2

 JL_0_68C0:
  MOVE.w (A7)+,D3
  TST.b D3
   BEQ.w JL_0_68D2
  CMP.b D2,D3
   BEQ.w putalp
BRA.w mismatcherr

 JL_0_68D2:
  ADDQ.w #2,a2offset
  MOVE.w ptype(PC),D1
   BSR.w writeword
  MOVEQ.l #$00,D1
  MOVE.b D2,D1
   BSR.w writeword
BRA.w putalp

 handlearr:
   MOVE.w D2,-(A7)
   BSR.w JL_0_694E
  BTST #$4,$1(A7)
   BEQ.w JL_0_6900
   BSR.w JL_0_699A

 JL_0_6900:
   BTST #$3,$1(A7)
   BEQ.w JL_0_690E
   BSR.w sendtype

 JL_0_690E:
   MOVE.w (A7)+,D2
BRA.w get1bytemain

 sendtype:                                                 ;OK, type of array is gonna be put on stack
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$7000,D1
  BTST #$0,$7(A3)
   BNE.w JL_0_6946                                         ;A Pointer
  CMPI.l #$100,$4(A2)
   BCC.w arrerr1                                           ;illegal type to send
  MOVE.b $7(A2),D1

 JL_0_693C:
  BSR.w writeword                                          ;moveq #type,d regat
  MOVEQ.l #$02,D2                                          ;just a word.
BRA.w JL_0_685C

 JL_0_6946:
  MOVE.b #$3,D1
BRA.w JL_0_693C


 JL_0_694E:                                                ;send base on stack or in reg
   BSR.w get1bytemain                                      ;write array paramter code
   BSR.w getparameter
  BTST #$1,flagmask+1
   BEQ.w syntaxerr
   BSR.w JL_0_8E3C
   BSR.w get1bytemain
  CMP.w #$29,D0                                            ;we just want a() or whatever
   BNE.w syntaxerr
  MOVE.w notshared,D1
   BNE.w noarrayerr
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w fbase(PC),D1
   TST.b varmode
   BEQ 'l1
   BCLR #0,d1

 'l1
   BSR.w writeword
  MOVE.w $4(A3),D1
   BSR.w writeword
BRA.w putalp


JL_0_699A:
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w fbase(PC),D1
   TST.b varmode
   BEQ 'l1
   BCLR #0,d1

'l1
   BSR.w writeword
  MOVE.w $8(A3),D1
  LSL.w #2,D1
  MOVE.w varmode,D2
   BEQ.w JL_0_69BE
  NEG.w D1

 JL_0_69BE:
   ADD.w $4(A3),D1
   BSR.w writeword
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  MOVE.w partostack(PC),D2
   BNE.w JL_0_69F4
  CMPI.w #$7,regnum
   BCC.w JL_0_69F4
  OR.w pushlast(PC),D1
  MOVE.w regnum,D2
  SUBQ.w #1,D2
  OR.w D2,D1
BRA.w JL_0_69F8

 JL_0_69F4:
  OR.w pushadd(PC),D1

 JL_0_69F8:
  BSR.w writeword
  MOVE.b #$1,partostack
BRA.w putalp


;------                                                  ;disassembled code begin
fbase:       Dc.b $20,$2D,$00,$00                           ;MOVE.L  $0000(A5),D0
pushadd:     Dc.b $D0,$97                                   ;ADD.L (A7),D0
pushlast:    Dc.b $D0,$80                                   ;ADD.L D0,D0
;------                                                  ;disassembled code end

Even
getap:
  ANDI.w #$7,D2                                            ;0-7 (unknown to string)
   BEQ.w evalu2
BRA.w eval


resetlibs:
  MOVEA.l libpointer,A1

 resetlibs__loop:
   CMPA.w #$0,A1
   BEQ.w resetlibs__done
  MOVE.w #-1,$A(A1)
  BCLR #$7,$C(A1)
  MOVEA.l (A1),A1
BRA.w resetlibs__loop

 resetlibs__done:
RTS


uselib2:                                                   ;usevars org source
  MOVE.w #$FFFE,D1

 uselib:                                                   ;lib number in d1 - turn it on baby!
   BSR.w JL_0_6F38

 uselib3:
  TST.w cfetchmode
   BEQ.w uselib3__noconst
  BTST #$6,$C(A1)
   BNE.w uselib3__constok
BRA.w badconerr                                            ;Can't use this Library!

 uselib3__constok:
RTS

 uselib3__noconst:
   BSET #$7,$C(A1)
   BNE.w JL_0_6C74                                         ;already done....
   CMPI.w #-1,$A(A1)
   BNE.w JL_0_6C74                                         ;something already here
    ;
    ;o.k. - move in the lib!
    ;
   TST.w dirmode
   BEQ.b JL_0_6A86
   TST.b exdebug
   BEQ 'l1
BRA.b JL_0_6A86

 'l1
  BCLR #$7,$C(A1)
BRA.w dirliberr

 JL_0_6A86:                                                ;addlibrary
  MOVE.b debugmode,-(a7)
  MOVEM.l D1/A0/A2,-(A7)

;  BTST #$7,use_debugger
;  SNE d1
;  MOVE.b d1,debugmode

  BTST #$7,use_debugger
  BNE 'debugon
  CLR.w D1
BRA.b 'debugoff

 'debugon
  SNE D1

 'debugoff
  MOVE.b d1,debugmode
; !basic
;  logging{"debugmode in d1, state:" +Str$(Peek.w(?debugmode))}
; !asm
  MOVEA.l A1,A0
  ADDA.l $12(A1),A0
  TST.w -$2(A0)
   BEQ.w JL_0_6AD2
  MOVEM.l A0-A1,-(A7)
  MOVE.w #$FB4F,D1
   BSR.w uselib
  MOVEM.l (A7)+,A0-A1
  ADDQ.w #1,globalvarpointer
  BCLR #$0,globalvarpointer+1
  MOVE.w globalvarpointer,-$6(A0)
  ADDQ.w #4,globalvarpointer
  TST.l -$E(A0)
   BEQ.w JL_0_6AD2
  ADDQ.w #4,globalvarpointer

 JL_0_6AD2:
  MOVE.l libend,$28(A1)
  MOVEA.l A1,A0
  ADDA.l $12(A1),A0
  MOVE.l A1,D1
  ADD.l $6(A1),D1
  TST.l $2C(A1)
   BEQ.w JL_0_6AFE

  TST.b debugmode
   BNE.w JL_0_6AFE
  MOVE.l A1,D1
  ADD.l $2C(A1),D1

 JL_0_6AFE:
  MOVEA.l libend,A2

 JL_0_6B04:
  CMPA.l data1start,A2
   BCS.w JL_0_6B24
  MOVE.w #$FFFF,dontwrite

 JL_0_6B16:
  ADDQ.w #2,A0
  ADDQ.w #2,A2
  CMPA.l D1,A0
   BCS.w JL_0_6B16
BRA.w JL_0_6B2C

 JL_0_6B24:
  MOVE.w (A0)+,(A2)+                                       ;copylibcode
  CMPA.l D1,A0
   BCS.w JL_0_6B04

 JL_0_6B2C:
  MOVE.l A2,libend
  MOVE.l $20(A1),D1
   BEQ.w JL_0_6BB8
  MOVEM.l D0/D2-D3,-(A7)
  MOVEA.l $24(A1),A0
  MOVEQ.l #$00,D3

 JL_0_6B44:
  MOVE.l (A0)+,D2
  TST.l $2C(A1)
   BEQ.w JL_0_6B60
  TST.b debugmode
   BNE.w JL_0_6B60
  CMP.l $2C(A1),D2
   BCC.w JL_0_6BA0

 JL_0_6B60:
  TST.w $0(A1,D2.L)
   BPL.w JL_0_6B72
  TST.l D3
   BNE.w JL_0_6B72
  MOVE.l A0,D0
  MOVE.l D1,D3

 JL_0_6B72:
  SUB.l $12(A1),D2
   BMI.w JL_0_6BA0
  ADD.l $28(A1),D2
  MOVE.l D2,-(A7)
  SUB.l destbufferstart,D2
   BSR.w addhunkoffset
  MOVEA.l (A7)+,A2
  TST.w dontwrite
   BNE.w JL_0_6BA0
  MOVE.l $28(A1),D2
  SUB.l $12(A1),D2
  ADD.l D2,(A2)

 JL_0_6BA0:
   SUBQ.l #1,D1
   BNE.w JL_0_6B44
  MOVE.l D3,D2
   BEQ.w JL_0_6BB4
  MOVEA.l D0,A2
  SUBQ.w #4,A2
   BSR.w JL_0_6E34

 JL_0_6BB4:
   MOVEM.l (A7)+,D0/D2-D3

 JL_0_6BB8:
   MOVEM.l (A7)+,D1/A0/A2
  MOVEM.l D1-D2,-(A7)
  TST.w $1A(A1)
   BNE.w JL_0_6BD0
  CLR.w $A(A1)
BRA.w JL_0_6C5E

 JL_0_6BD0:
  ADDQ.w #1,globalvarpointer
  BCLR #$0,globalvarpointer+1
  MOVE.w globalvarpointer,$A(A1)
  CMP.w #-$12D,D1
   BNE.w JL_0_6C16
  MOVE.w $A(A1),movestdn+2
  MOVE.w $A(A1),pusha3+2
  MOVE.w $A(A1),pusha32+2
  MOVE.w $A(A1),pulla3+2
  MOVE.w $A(A1),geta3+2

 JL_0_6C16:
   CMP.w #-$3E9,D1
   BNE.w JL_0_6C3E
  MOVE.w $A(A1),dataget+2
  MOVE.w $A(A1),dataput+2
  MOVE.w $A(A1),rescode+6
  MOVE.w $A(A1),rescode2+2

 JL_0_6C3E:
  ADDQ.w #2,globalvarpointer
  TST.w $1A(A1)
   BMI.w JL_0_6C52
  ADDQ.w #2,globalvarpointer

 JL_0_6C52:
  MOVEM.l D1/A1,-(A7)
  BSR.w uselib2
  MOVEM.l (A7)+,D1/A1

 JL_0_6C5E:
  MOVE.w D1,D2
  MOVE.l $16(A1),D1
   BSR.w uselib2_org
  MOVE.l $1C(A1),D1
   BSR.w uselib2_org
  MOVEM.l (A7)+,D1-D2
  ;JSR Aclearcache
  MOVE.b (a7)+,debugmode

 JL_0_6C74:
RTS


JL_0_6C76:
  MOVEQ.l #$00,D2

 JL_0_6C78:
  MOVEA.l tokeslist,A2
  CMPA.l D2,A2
   BEQ.w JL_0_6CE0
  MOVE.l A2,-(A7)

 JL_0_6C86:
  MOVEQ.l #$00,D3

 JL_0_6C88:
  MOVEA.l $8(A2),A3
  CMPA.l D3,A3
   BEQ.w JL_0_6CD2
  MOVE.l A3,-(A7)
  MOVEM.l D2-D3/A2-A3,-(A7)
  MOVE.w $4(A2),D1
  MOVE.w $6(A2),D2
   BSR.w JL_0_6CE2
  MOVEM.l (A7)+,D2-D3/A2-A3
  MOVE.w dontwrite,D0
   BEQ.w JL_0_6CBE

 JL_0_6CB2:
  MOVEA.l (A3),A3
  CMPA.l D3,A3
   BNE.w JL_0_6CB2
BRA.w JL_0_6CCC

 JL_0_6CBE:
  MOVEA.l $4(A3),A0
  MOVE.l D7,(A0)
  MOVEA.l (A3),A3
  CMPA.l D3,A3
   BNE.w JL_0_6CBE

 JL_0_6CCC:
  MOVE.l (A7)+,D3
BRA.w JL_0_6C88

 JL_0_6CD2:
   MOVEA.l (A2),A2
  CMPA.l D2,A2
   BNE.w JL_0_6C86
  MOVE.l (A7)+,D2
BRA.w JL_0_6C78

 JL_0_6CE0:
RTS


JL_0_6CE2:
  MOVE.w D2,-(A7)
   BSR.w searchinstr
  MOVE.w (A7)+,D2
  BCLR #$7,blitzmode
  BCLR #$E,D2
   BEQ.w JL_0_6D02
  BSET #$7,blitzmode

 JL_0_6D02:
  TST.w (A3)
   BEQ.w JL_0_6DAC
  BTST #$2,$1(A3)
   BNE.w tokeerr
  BTST #$3,$1(A3)
   BNE.w tokeerr
  LEA $6(A3),A3

 JL_0_6D20:
  MOVE.w (A3)+,D0
   BMI.w tokeerr
  ANDI.w #$FF,D0
  ADDA.w D0,A3
  ADDQ.w #1,A3
  EXG.l D0,A3
  BCLR #$0,D0
  EXG.l D0,A3
  SUBQ.w #1,D2
   BPL.w JL_0_6D98
  TST.w (A3)
   BNE.w JL_0_6D76
  MOVE.l $2(A3),D0
  OR.l $A(A3),D0
   BNE.w JL_0_6D76
  BTST #$0,$9(A3)
   BNE.w JL_0_6D76
  MOVE.l $6(A3),D7
  MOVE.w $0(A2,D7.L),D0
  ANDI.w #$F000,D0
  CMP.w #-$6000,D0
   BEQ.w JL_0_6D76

 JL_0_6D6C:
  SUB.l $12(A2),D7
  ADD.l $28(A2),D7
RTS


JL_0_6D76:
  LEA cutejsr,A0

 JL_0_6D7C:
  MOVE.l destpointer,-(A7)
  MOVE.w #$FFFF,lasta6

 L_0_6D8A:
   JSR (A0)
  MOVE.w #$4E75,D1
   BSR.w writeword
  MOVE.l (A7)+,D7
RTS


JL_0_6D98:
  TST.w (A3)+
   BEQ.w JL_0_6DA4
  ADDQ.w #2,A3
BRA.w JL_0_6D98

 JL_0_6DA4:
  LEA $C(A3),A3
BRA.w JL_0_6D20


JL_0_6DAC:
  TST.w D2
   BNE.w tokeerr
  TST.w $6(A3)
   BNE.w JL_0_6DE4
  MOVE.l $8(A3),D0
  OR.l $10(A3),D0
   BNE.w JL_0_6DE4
  BTST #$0,$F(A3)
   BNE.w JL_0_6DE4
  MOVE.l $C(A3),D7
  MOVE.w $0(A2,D7.L),D0
  ANDI.w #$F000,D0
  CMP.w #-$6000,D0
   BNE.w JL_0_6D6C

 JL_0_6DE4:
  MOVE.l A3,D1
  SUB.l A2,D1
  LEA Amakelibsub,A0
BRA.w JL_0_6D7C


AJL_0_6DF2:
  MOVEA.l _execbase,A6
  MOVEA.l tokeslist,A2
  CLR.l tokeslist

 JL_0_6E02:
    CMPA.w #$0,A2
     BEQ.w JL_0_6E32
    MOVEA.l $8(A2),A3

 JL_0_6E0E:
      CMPA.w #$0,A3
       BEQ.w JL_0_6E24
      MOVEA.l A3,A1
      MOVEA.l (A3),A3
      MOVEQ.l #$08,D0
      MOVE.l mempool,a0
      MOVEA.l _execbase,A6
      JSR _FreePooled(A6)
BRA.w JL_0_6E0E

 JL_0_6E24:
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$0C,D0
    MOVE.l mempool,a0
    MOVEA.l _execbase,A6
    JSR _FreePooled(A6)
BRA.w JL_0_6E02

 JL_0_6E32:
RTS


JL_0_6E34:
  MOVEM.l D3-D5/A1-A6,-(A7)
  MOVEA.l A1,A4

 JL_0_6E3A:
  MOVE.l (A2)+,D3
  MOVE.w $0(A4,D3.L),D5
   BPL.w JL_0_6E7A
  TST.l $2C(A4)
   BEQ.w JL_0_6E5E
  TST.b debugmode
   BNE.w JL_0_6E5E
  CMP.l $2C(A4),D3
   BCC.w JL_0_6E7A

 JL_0_6E5E:
  BCLR #$F,D5
  MOVE.w $2(A4,D3.L),D4
  SUB.l $12(A4),D3
  ADD.l $28(A4),D3
  MOVEM.l D2/A2/A4,-(A7)
   BSR.w JL_0_6E86
  MOVEM.l (A7)+,D2/A2/A4

 JL_0_6E7A:
  SUBQ.l #1,D2
   BNE.w JL_0_6E3A
  MOVEM.l (A7)+,D3-D5/A1-A6
RTS


JL_0_6E86:
  LEA tokeslist,A3
  MOVEA.l _execbase,A6

 JL_0_6E90:
  MOVE.l (A3),D0
   BEQ.w JL_0_6EAC
  MOVEA.l D0,A3
  CMP.w $4(A3),D4
   BNE.w JL_0_6E90
  CMP.w $6(A3),D5
   BNE.w JL_0_6E90
BRA.w JL_0_6ED0

 JL_0_6EAC:
  MOVEQ.l #$0C,D0
  MOVEQ.l #$01,D1
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C
  MOVEA.l D0,A3
  MOVE.l tokeslist,(A3)
  MOVE.l A3,tokeslist
  MOVE.w D4,$4(A3)
  MOVE.w D5,$6(A3)
  CLR.l $8(A3)

 JL_0_6ED0:
  MOVEQ.l #$08,D0
  MOVEQ.l #$01,D1
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C
  MOVEA.l D0,A0
  MOVE.l D3,$4(A0)
  MOVE.l $8(A3),(A0)
  MOVE.l A0,$8(A3)
  MOVE.w D4,D1
BRA.w searchinstr


tokeslist: Ds.l 1

;   00.l : Next
;   04.w : token number
;   06.w : form number  ;bit 14=1 if Blitz
;   08.l : list of offsets
        ;
        ;00.l : Next
        ;04.l : Offset



uselib2_org:
  BEQ.w uselib2_org__skip
  MOVE.l A1,-(A7)
  ADDA.l D1,A1
  ADDQ.w #6,A1

 uselib2_org__loop:
    MOVE.w (A1)+,D1
    BEQ.w uselib2_org__done
    CMP.w D2,D1
    BEQ.w uselib2_org__skip2
    MOVE.l A1,-(A7)
    BSR.w uselib
    MOVEA.l (A7)+,A1

 uselib2_org__skip2:
    ADDQ.w #2,A1
BRA.w uselib2_org__loop

 uselib2_org__done:
  MOVEA.l (A7)+,A1

 uselib2_org__skip:
RTS


AJL_0_6F1A:
  MOVEA.l libpointer,A1

 JL_0_6F20:
  CMPA.w #$0,A1
   BEQ.b JL_0_6F36
  CMP.w $4(A1),D1
   BEQ.w JL_0_6F34
  MOVEA.l (A1),A1
BRA.w JL_0_6F20

 JL_0_6F34:
  MOVEQ.l #-$01,D1

 JL_0_6F36:
RTS


JL_0_6F38:
  MOVEM.l d0/a2,-(a7)
  MOVEQ #0,d0
  LEA instrtab+4,a2
  MOVE.w d1,d0
  ASL.l #3,d0
  MOVE.l 0(a2,d0.l),a1                                     ;*8
  CMP.l #0,a1
  BNE JL_0_6F54b

  MOVEA.l libpointer,A1

 JL_0_6F3E:
    CMPA.w #$0,A1
    BEQ.w noliberr
    CMP.w $4(A1),D1
    BEQ.w JL_0_6F54
   MOVEA.l (A1),A1
BRA.w JL_0_6F3E

 JL_0_6F54:
  MOVE.l a1,0(a2,d0.l)

 JL_0_6F54b:
  MOVEM.l (a7)+,d0/a2
RTS

searchinstr:
  MOVEM.l d0-d1/a1,-(a7)
  MOVEQ #0,d0
  LEA instrtab,a1
  MOVE.w d1,d0
  ASL.l #3,d0
  MOVE.l 0(a1,d0.l),a3
  MOVE.l 4(a1,d0.l),a2
  CMP.l #0,a3
  BNE JL_0_6F92b

  MOVEA.l libpointer,A2

 JL_0_6F5C:
  CMPA.w #$0,A2
  BEQ.w notokerr
  CMP.w $E(A2),D1
  BCS.w JL_0_6FB8
  CMP.w $10(A2),D1
  BCC.w JL_0_6FB8
  LEA $30(A2),A3
  TST.w $4(A2)
  BPL.w JL_0_6FA6

 JL_0_6F80:
    CMP.w $E(A2),D1
    BEQ.w JL_0_6F92
    SUBQ.w #1,D1
    MOVEA.l $2(A3),A3
BRA.w JL_0_6F80

 JL_0_6F92:
  MOVE.l a3,0(a1,d0.l)
  MOVE.l a2,4(a1,d0.l)

 JL_0_6F92b
  MOVEM.l (a7)+,d0-d1/a1
  MOVEM.l D1/A1-a3,-(A7)
  CMP.w #1,(a3)
  BNE.s ex10
  CMP.l #$12345678,$e(a3)
  BNE.s ex10
  CMP.w #$ffff,$16(a3)
  BNE.s ex10
  MOVE.l $12(a3),d1
  BEQ.s ex10
  LEA pluginbase,a3
  ;move.b #1,newmode
JMP 0(a2,d1.l)                                             ;plugin

 exit:
  MOVEM.l (A7)+,D1/A1-a3
  JSR stripspaces
  MOVEQ #0,d0
  MOVE.b (a5)+,d0
  MOVE.w d0,lastchar
  ADDQ.l #4,a7
RTS


 ex10:
  MOVEA.l A2,A1
  CLR.b newmode
  MOVE.w $4(A1),D1
  ;CMP.w #$fed3,d1
  ;BEQ 'l1
  BSR.w uselib3
  MOVEM.l (A7)+,D1/A1-a3
RTS

 'l1
  MOVE.w globalvarpointer,-(a7)
  MOVE.w #$8004,globalvarpointer
  BSR.w uselib3
  MOVE.w (a7)+,globalvarpointer
  MOVEM.l (A7)+,D1/A1-a3
RTS

 JL_0_6FA6:
    CMP.w $E(A2),D1
    BEQ.w JL_0_6F92
    SUBQ.w #1,D1
    MOVEA.l $2(A3),A3
BRA.w JL_0_6FA6

 JL_0_6FB8:
  MOVEA.l (A2),A2
BRA.w JL_0_6F5C

 JUMP_writeword:
JMP writeword


ptr_acidlibs:   Ds.l 1                                     ;deflibsat org source
ptr_deflibs:    Ds.l 1                                     ;acidlibsat org source
ptr_userlibs:   Ds.l 1                                     ;blitzlibsat org source  ;;start of blitzlibs list!


; input  : D0: size,D1: ptr_strname
; returns: D0: buffer addr
.load_libsfile:                                            ;loadlibgroup org source  ;load a group of libraries!
  TST.l D0
  BEQ.w exit_loadlibsfile
    MOVE.l D0,D6                                           ;d6=len
    MOVEA.l _dosbase,A6
    MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
    JSR _Open(A6)
    MOVE.l D0,D7
    BEQ.w exit_loadlibsfile
      MOVE.l D6,D0
      MOVEQ.l #$01,D1
      MOVEA.l _execbase,A6
      MOVE.l mempool,a0
      JSR _AllocPooled(a6)
      MOVE.l D0,D5                                         ;start address

      MOVE.l D7,D1                                         ; handle
      MOVE.l D5,D2                                         ; buffer addr
      MOVE.l D6,D3                                         ; size
      MOVEA.l _dosbase,A6
      JSR _Read(A6)
      MOVE.l D7,D1
      JSR _Close(A6)

      MOVEA.l D5,A0                                        ; buffer addr

      ; --
      ; -- process loaded acid/deflibs
      ; -- (libpointer steht ja in A3)
 JL_0_7010:
        MOVE.l (A0)+,D0                                    ; naechster Longwert nach DO
        BEQ.b JL_0_7044                                    ; wenn <> 0, dann
          LEA $20(A0),A1                                   ;   lade inhalt von D0+40bytes nach A1
          MOVE.l A1,(A3)                                   ;   kopiere Adresse in A1 zum libpointer
          MOVEA.l A1,A3                                    ;   kopiere A1 nach A3
          ADDA.l D0,A0                                     ;   addiere inhalt von D0 zu A0 hinzu
          MOVE.l -$4(A1),D0                                ;   hole die 4bytes vor nach D0
          ADD.l D0,D0                                      ;   verdoppele D0
          ADD.l D0,D0                                      ;   verdoppele D0 nochmal
          MOVE.l D0,$6(A1)                                 ;   schreibe D0 6bytes nach A1
          CLR.l $20(A1)                                    ;   loesche D0+40bytes
          LEA $C(A1,D0.L),A2                               ;   lade inhalt von (A1)+D0+$C nach A2
          CMPA.l A0,A2
          BCC.b JL_0_7010                                  ; wenn A0=>A2
            MOVE.l -$8(A2),$20(A1)                         ;
            MOVE.l A2,$24(A1)                              ;
BRA.w JL_0_7010

 JL_0_7044:
      MOVE.l D5,D0

 exit_loadlibsfile:
RTS


.init_libraries:
  !basic
   tempmapping$ = dos_AddPart{my_systemdir$,"token_mapping_userlibs.txt"}
   dos_Delete{tempmapping$}
   fid.l = file_Open{tempmapping$,#file_forcewrite}
  !asm

  LEA libpointer,A3

  ; --
  ; -- load the deflibs
  MOVE.l size_deflibs,D0
  MOVE.l deflib,d1
  BEQ 'l1
BRA 'l2

 'l1
  MOVE.l #str_path_deflibs,D1

 'l2
  BSR.w load_libsfile
  MOVE.l D0,ptr_deflibs
  ; --
  ; -- load the acidlibs
  MOVE.l size_acidlibs,D0
  MOVE.l #str_path_acidlibs,D1
  BSR.w load_libsfile
  MOVE.l D0,ptr_acidlibs

  ; --
  ; -- load the userlibs
  CLR.l (A3)
  MOVE.l A3,ptr_userlibs


  ; -- copy current path to str_libfilename
 JL_0_7082:
  LEA str_libfilename,A0
  LEA str_path_userlibs,A1

 JL_0_708E:
    MOVE.b (A1)+,(A0)+
  BNE.b JL_0_708E
  ; -- append "/" = $2F
  SUBQ.w #1,A0
  MOVE.b #$2F,(A0)+

 JL_0_70A6:
  MOVE.l A0,-(A7)                                          ; -- store str_path_userlibs in A7

  LEA ptr_userlibs_list,A2
  MOVEA.l ptr_userlibs,A3
  MOVEA.l _dosbase,A6

  ; --
  ; -- loop for loading libs out of "userlibs"
 JL_0_70BA:
      MOVE.l (A2),D0                                       ; addresse aus liste nach D0
      BNE.b JL_0_70C6                                      ; wenn nix drin, processing ueberspringen

      CLR.l (A3)
      ADDQ.w #4,A7
      !basic
      If fid<>-1
        file_Close{fid}
        fid = -1
      EndIf
      !asm
BRA.w process_libraries

 JL_0_70C6:
      MOVEA.l D0,A2                                        ; addresse zureuck nach A2
      TST.w $4(A2)                                         ; naechste addresse pruefen
    BEQ.b JL_0_70BA

    LEA $6(A2),A1
    MOVEA.l (A7),A0

 JL_0_70D4:
      MOVE.b (A1)+,(A0)+
    BNE.w JL_0_70D4

    ; --
    ; -- lock the userlibs directory, e.g. "private"
    MOVE.l A0,-(A7)
    MOVE.l #str_libfilename,D1
    MOVEQ.l #-$02,D2
    MOVEA.l _dosbase,A6
     JSR _Lock(A6)
    MOVE.l D0,D1
     BEQ.w JL_0_7156
    MOVEA.l (A7),A0
    MOVE.b #$2F,-$1(A0)

    ; -- examine the files
    MOVE.l D1,-(A7)
    MOVE.l #ptr_parameterstore,D2
    MOVEA.l _dosbase,A6
    JSR _Examine(A6)
    TST.l D0
     BEQ.w JL_0_7150

    ; pruefen, ob infofile
    LEA fib_FileName,A0
    BSR.w check_for_infoextention
    BEQ.w JL_0_7150
    ; --
    ; -- open that file ...
    !basic
      Poke$ ?str_libfilename,dos_AddPart{Peek$(?str_path_userlibs),Peek$(?fib_FileName)}
    !asm
    MOVE.l #str_libfilename,D1
    BSR.w open_userlibfile

 JL_0_7150:
    MOVE.l (A7)+,D1
    MOVEA.l _dosbase,A6
    JSR _UnLock(A6)

 JL_0_7156:
    ADDQ.w #4,A7
BRA.w JL_0_70BA

 open_userlibfile:
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
  MOVEA.l _dosbase,A6
   JSR _Open(A6)
  MOVE.l D0,D7
   BEQ.w exit_userlibfile

  ; -- read 32 bytes of library
  MOVE.l D7,D1                                             ; filehandle
  MOVE.l #optstuff,D2                                     ; buffer
  MOVEA.l _dosbase,A6
  MOVEQ.l #$20,D3                                          ; size
  JSR _Read(A6)

  ; -- calculate size of datachunk and allocate memory
  MOVE.l optstuff+28,D6
  LSL.l #2,D6
  MOVE.l D6,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  MOVEA.l D0,A5

  ; -- read that datachunk from library
  MOVEA.l _dosbase,A6
  MOVE.l D7,D1                                             ; filehandle
  MOVE.l A5,D2                                             ; buffer
  MOVE.l D6,D3                                             ; size
   JSR _Read(A6)
  MOVE.l A5,(A3)
  ; -- get the address for basic code
  MOVE.l A5,d0
  ; --
  MOVEA.l A5,A3
  MOVE.l D6,$6(A5)
  CLR.l $20(A5)

  !basic
  ; -- get the first token of the lib
  addr_libnum.l = PutD0 + 4
  If fid<>-1
    currentlib$ = LSet$(Peek.s(?fib_FileName),30)+";"+LSet$(Get_Libinfo{addr_libnum},30) ;+";"+Str$(Peek.w(addr_libnum))
    file_WriteLine{fid,currentlib$}
  EndIf
  !asm

  ; -- read 12 bytes from library
  MOVE.l D7,D1                                             ; filehandle
  MOVE.l #optstuff,D2                                     ; buffer
  MOVEQ.l #$0C,D3                                          ; size
  MOVEA.l _dosbase,A6
   JSR _Read(A6)
  ; -- close file if these 12 bytes could not be read
  CMP.l #$C,D0
   BCS.w close_and_exit_userlibfile

  ; -- else read on
  MOVE.l optstuff+4,D0
  MOVE.l D0,$20(A5)
  LSL.l #2,D0
  MOVE.l D0,D5
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C
  MOVEA.l _dosbase,A6
  MOVE.l D0,$24(A5)
  MOVE.l D7,D1
  MOVE.l D0,D2
  MOVE.l D5,D3
  JSR _Read(A6)

 close_and_exit_userlibfile:
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
JMP _Close(A6)

 exit_userlibfile:
RTS


  ; --
  ; -- prepare userlibs and adding to librarylist
.process_libraries:
  CLR.w number_of_objects
  MOVEA.l end_of_tokenlist,A3
  MOVEA.l libpointer,A2

 JL_0_720E:
    CMPA.w #$0,A2
    BEQ.w JL_0_72D8                                        ; <-- abbruch mit RTS

    MOVE.w $4(A2),D7                                       ; <-- get tokennumber
    BMI.w JL_0_7226
      LSL.w #7,D7
      ADDQ.w #1,D7
      MOVE.w D7,$E(A2)

 JL_0_7226:
    LEA $30(A2),A1
    LEA temp1,A4

 JL_0_7230:
      MOVE.w (A1),D0
      BMI.w JL_0_72AE
      MOVE.l A1,(A4)
      MOVEA.l A1,A4
      ADDQ.w #2,A4
      ADDQ.w #6,A1
      CMP.w #$8,D0
      BEQ.w JL_0_7290
        ANDI.w #$F,D0
        BNE.w JL_0_725C
          BSR.w skiplibreg
          LEA $C(A1),A1
          ADDQ.w #1,D7
BRA.w JL_0_7230

 JL_0_725C:
    BTST #$2,D0
    BEQ.w JL_0_7274
      ADDQ.w #4,A1

 JL_0_7266:
        TST.b (A1)+
      BPL.w JL_0_7266
      BSR.w aligna1
BRA.w JL_0_7290

 JL_0_7274:
      MOVE.w (A1)+,D0
      BMI.w JL_0_7290
      ANDI.w #$FF,D0
      ADDA.w D0,A1
      BSR.w aligna1
      BSR.w skiplibreg
      LEA $C(A1),A1
BRA.w JL_0_7274

 JL_0_7290:
    MOVE.l A1,(A3)
    MOVEA.l A1,A3
    ADDQ.w #4,A1
    MOVE.w D7,(A1)+

 JL_0_7298:
      TST.b (A1)+
    BNE.w JL_0_7298

 JL_0_729E:
      TST.b (A1)+
    BNE.w JL_0_729E

    BSR.w aligna1
    ADDQ.w #1,D7
BRA.w JL_0_7230

 JL_0_72AE:
    TST.w $4(A2)
     BMI.w JL_0_72BA
    MOVE.w D7,$10(A2)

 JL_0_72BA:
    ADDQ.w #2,A1
    TST.l (A1)+
     BEQ.w JL_0_72CC
    ADDQ.w #1,number_of_objects
    LEA $16(A1),A1

 JL_0_72CC:
    SUBA.l A2,A1
    MOVE.l A1,$12(A2)
    MOVEA.l (A2),A2
BRA.w JL_0_720E

 JL_0_72D8:
  CLR.l (A3)
  MOVE.l A7,errstack
  MOVE.l #AL_0_730E,errcont
  MOVE.w #$FFFF,ezerr
  MOVE.w #$FFFA,D1
   BSR.w JL_0_6F38
  MOVE.l A1,tempvm
  MOVE.w #$FDA7,D1
   BSR.w JL_0_6F38
  MOVE.l A1,ffplib

 AL_0_730E:
RTS


ffplib:  Ds.l 1


skiplibreg:
    TST.w (A1)+
    BEQ.w JL_0_7320
    ADDQ.w #2,A1
BRA.w skiplibreg

 JL_0_7320:
RTS


aligna0:
  EXG.l A1,A0
  BSR.w aligna1
  EXG.l A1,A0
RTS

 aligna1:
  EXG.l D0,A1
  ADDQ.l #1,D0
  BCLR #$0,D0
  EXG.l D0,A1
RTS


.free_userlibs:                                            ;freeblitzlibs
  MOVEA.l _execbase,A6
  MOVEA.l ptr_userlibs,A2
  MOVE.l (A2),D0
  CLR.l (A2)
  MOVEA.l D0,A2

 JL_0_7348:
    CMPA.w #$0,A2
    BEQ.w free_userlib

    MOVE.l $20(A2),D0
    BEQ.b JL_0_7360
      LSL.l #2,D0
      MOVE.l mempool,a0
      MOVEA.l $24(A2),A1
      JSR _FreePooled(A6)

 JL_0_7360:
    MOVEA.l A2,A1
    MOVE.l $6(A1),D0
    MOVE.l mempool,a0
    MOVEA.l (A2),A2
    MOVEA.l _execbase,A6
    JSR _FreePooled(A6)
BRA.w JL_0_7348


.free_blitzlibs:                                           ;freelibs org source    ;free up all memory used by libs
  BSR.w free_userlibs
  MOVEA.l _execbase,A6
  CLR.l libpointer
  MOVEA.l end_of_tokenlist,A0
  CLR.l (A0)

  MOVE.l size_acidlibs,D0
  BEQ.b JL_0_73A2
    MOVE.l ptr_acidlibs,D1
    BEQ.b JL_0_73A2
      CLR.l ptr_acidlibs
      MOVEA.l D1,A1
      MOVE.l mempool,a0
      MOVEA.l _execbase,A6
      JSR _FreePooled(A6)                                 ; free acidlibs

 JL_0_73A2:
  MOVE.l size_deflibs,D0
  BEQ.b JL_0_73BE
    MOVE.l ptr_deflibs,D1
    BEQ.b JL_0_73BE
      CLR.l ptr_deflibs                                    ; d0: memorySize
      MOVEA.l D1,A1                                        ; a1: memory
      MOVE.l mempool,a0                                    ; a0: poolHeader
      MOVEA.l _execbase,A6
      JSR _FreePooled(A6)                                  ; free deflibs

 JL_0_73BE:
RTS


freemacs:
  MOVEA.l currentmacroaddr,A0
  MOVEA.l (A0),A2
  CLR.l (A0)
  MOVEA.l _execbase,A6

 JL_0_73CE:
    CMPA.w #$0,A2
    BEQ.w JL_0_73FA
    MOVEQ.l #$00,D0
    MOVE.w $8(A2),D0
    BEQ.w JL_0_73E8
    MOVEA.l $4(A2),A1
    MOVE.l mempool,a0
    JSR _FreePooled(A6)

 JL_0_73E8:
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$00,D0
    MOVE.b $C(A1),D0
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
BRA.w JL_0_73CE

 JL_0_73FA:
RTS


cleartemplabel:                                            ;freeasms org code
  MOVEA.l templabel,A2
  CLR.l templabel
RTS


  MOVEA.l _execbase,A6                                     ;??looks like dead code?

JL_0_740C:
    CMPA.w #$0,A2
    BEQ.w JL_0_7426
    MOVEQ.l #$00,D0
    MOVE.b $E(A2),D0                                       ;labeltemp
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVE.l mempool2,a0
    ;jsr _FreePooled(A6)
BRA.w JL_0_740C

 JL_0_7426:
RTS


pokedata1b:                                               ;byte into data1
  MOVEA.l data1,A4
  CMPA.l data2at,A4
  BCC.w JL_0_7442
    MOVE.b D1,(A4)+
    MOVE.l A4,data1
RTS

 JL_0_7442:
  MOVE.w #$FFFF,dontwrite                                  ;move #-1, org source
  ADDQ.l #1,data1
RTS


writedatalong:                                             ;pokedata1l org source
  SWAP D1
  BSR.w pokedata1
  SWAP D1

 pokedata1:                                                ;poke word in d1 into data block
  MOVEA.l data1,A4
  CMPA.l data2at,A4
   BCC.w JL_0_7474
  MOVE.w D1,(A4)+
  MOVE.l A4,data1
RTS

 JL_0_7474:
  MOVE.w #$FFFF,dontwrite
  ADDQ.l #2,data1
RTS


calcstatic2b:
  MOVE.l data1,D3                                      ;write local string/type allocs
  MOVEQ.l #$00,D4

 JL_0_7492c:
  CMPA.w #$0,A2
   BEQ.w JL_0_74CAc
  TST.w $6(A2)
   BNE.w JL_0_74C4c
  MOVEA.l $A(A2),A3
  CMPI.l #$100,$4(A3)
   BCS.w JL_0_74C4c
  MOVE.w $4(A2),D1
   BSR.w pokedata1
  MOVE.w $8(A3),D1
   BSR.w pokedata1
  ADDQ.w #1,D4

 JL_0_74C4c:
   MOVEA.l (A2),A2
BRA.w JL_0_7492c

 JL_0_74CAc:
   TST.w D4
   BEQ.w JL_0_74E0
  MOVE.w #$FF37,D1
   BSR.w uselib
  MOVE.w #$FFFA,D1
BRA.w uselib

 calcstatic:
    ;calculate static structures stuff - put num of structs d4.w
    ;address of data1 table in d3.l
    ;
    ;data1: .w=structsize,.w=offset
    ;
  MOVEA.l varbase,A2                                       ;add alloc mem for types/strings global

 calcstatic2:
  MOVE.l data1,D3
  MOVEQ.l #$00,D4
  TST.b iserror
  BEQ JL_0_7492
  RTS
 JL_0_7492:
   CMPA.w #$0,A2
   BEQ.w JL_0_74CA
  TST.w $6(A2)
   BNE.w JL_0_74C4
  MOVEA.l $A(A2),A3
  CMPI.l #$100,$4(A3)
   BCS.w JL_0_74C4
  MOVE.w $4(A2),D1
   BSR.w pokedata1
  MOVE.w $8(A3),D1
   BSR.w pokedata1
  ADDQ.w #1,D4

 JL_0_74C4:
  MOVEA.l (A2),A2
BRA.w JL_0_7492

 JL_0_74CA:                                                 ;??looks like double label ?
 calcstaticb:
  MOVEA.l sharebase,A2

 JL_0_7492b:
  CMPA.w #$0,A2
   BEQ.w JL_0_74CAb

  TST.w $6(A2)
   BNE.w JL_0_74C4b
  MOVEA.l $A(A2),A3
  CMPI.l #$100,$4(A3)
   BCS.w JL_0_74C4b
  MOVE.w $4(A2),D1
   BSR.w pokedata1
  MOVE.w $8(A3),D1
   BSR.w pokedata1
  ADDQ.w #1,D4

 JL_0_74C4b:
  MOVEA.l (A2),A2
BRA.w JL_0_7492b

 JL_0_74CAb
   TST.w D4
   BEQ.w JL_0_74E0
  MOVE.w #$FF37,D1
   BSR.w uselib                                            ;use statics lib
  MOVE.w #$FFFA,D1                                         ;use memlib
BRA.w uselib

 JL_0_74E0:
RTS


datastart:                                                 ;set up a2 (d3.l) and d4 (d4.w)
  MOVE.w numtoa2,D1
   BSR.w writeword
   BSR.w addoff
  MOVE.l D3,D1
   BSR.w writelong
  SUBQ.w #1,D4
  MOVE.w D4,endarray+2
  MOVE.l endarray,D1
BRA.w writelong


mywrite:
  MOVE.l D3,-(A7)

  ; JSR _Reschedule(A6)  ;<= this is probably wrong, it's Write() from dos.lib
  MOVEA.l _dosbase,A6
  JSR _Write(a6)

  CMP.l (A7)+,D0
   BNE.w JL_0_7516
RTS

 JL_0_7516:
  MOVE.l D7,D1
  ;JSR _ExitIntr(A6)   ; <= this is probably wrong, it's Close() from dos.lib
  MOVEA.l _dosbase,A6
  JSR _Close(a6)

 execerr:
JMP error_create_exe

;RTS                                                       ;??looks like dead code??


.savefile:
    ;
    ;make all abs refs pcat relative
    ;
  MOVE.l A7,errstack
  MOVEM.l d2-d7/a2-a6,-(a7)
  MOVE.l #AL_0_7790,errcont
   JSR call_setpointerbusy
  MOVE.w #$FFFF,anyerrs
  CMP.l #-1,chipstart
  BEQ 'l01
  MOVE.l chipend,d1
  ADDQ.l #3,d1
  AND.l #$fffffffc,d1                                      ;bug
  MOVE.l d1,chipend
  MOVE.l d1,a1
  MOVE.l chipstart,a0
  MOVE.l a1,d1
  SUB.l a0,d1
  MOVE.l d1,chipsize

 'l01
  CMP.l #-1,bssstart
  BEQ 'l11
  MOVE.l realbssend,a1
  MOVE.l bssstart,a0
  MOVE.l a1,d1
  SUB.l a0,d1
  MOVE.l d1,bsssize
  BEQ 'l11

 'l32
  TST.b (a0)+
  BEQ 'l31
  TST.b debugmode
  BEQ 'l1
  TST.b exdebug
  BNE 'l31

 'l1
  MOVE.l #nodata,-(a7)
JMP handle_compileerror

 'l31
  CMP.l a0,a1
  BGT 'l32
  MOVE.l bssend,d1
  ADDQ.l #3,d1
  AND.l #$fffffffc,d1                                      ;bug
  MOVE.l d1,bssend
  MOVE.l d1,a1
  MOVE.l bssstart,a0
  MOVE.l a1,d1
  SUB.l a0,d1
  MOVE.l d1,bsssize

 'l11
  MOVEM.l d5-d7/d3,-(a7)
  MOVE.w dontwrite,D1
  BNE.w JL_0_757C
  MOVE.l chipsize,d5
  MOVE.l bsssize,d3
  MOVE.l chipstart,d7
  MOVE.l bssstart,d6
  MOVEA.l hunkoffsetbase,A2
  MOVEA.l destbufferstart,A1
  MOVE.l A1,D2
  ADD.l noinits,D2
  CLR.l hunkoffsetnum

 JL_0_755E:
  CMPA.w #$0,A2
   BEQ.w JL_0_757C
  MOVE.l $4(A2),D0
   LEA $0(a1,d0.l),a0
   MOVE.l (a0),d1
  TST.l d1
   BMI.w 'lm1
  MOVE.b #0,newhunk
  CMP.l #-1,chipstart
  BEQ 'l10
  CMP.l chipstart,d1
  BLT 'l10
  MOVE.b #1,newhunk
  CMP.l chipend,d1
  BGE 'l110
  SUB.l d7,(a0)
  ADD.l #$80000000,4(a2)
BRA JL_0_7576

 'l110
  SUB.l d5,0(a0)

 'l10
  CMP.l #-1,bssstart
    BEQ 'l11
  CMP.l bssstart,d1
  BLT 'l11
  CMP.l bssend,d1
  BGE 'l111
  TST.b newhunk
  BEQ 'ln1
  ADD.l d5,(a0)

 'ln1
  SUB.l d6,(a0)
  ADD.l #$40000000,4(a2)
BRA JL_0_7576

 'l111
  SUB.l d3,0(a0)

 'l11
  SUB.l D2,(A0)

 'lm1
  ADDQ.l #1,hunkoffsetnum

 JL_0_7576:
   MOVEA.l (A2),A2
BRA.w JL_0_755E


JL_0_757C:
  MOVEM.l (a7)+,d5-d7/d3
  MOVE.l ptr_newexefilename,D1
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVEA.l _dosbase,A6
   JSR _Open(A6)
  MOVE.l D0,D7
   BEQ.w execerr
  MOVE.l objlen,D0
  SUB.l #moremem,d0
  SUB.l noinits,D0
  CMP.l #-1,bssstart
  BEQ 'l60
  SUB.l bsssize,d0
  SUB.l chipsize,d0
BRA.s 'l61

 'l60
  CMP.l #-1,chipstart
  BEQ 'l61
  SUB.l bsssize,d0
  SUB.l chipsize,d0

 'l61
  ADDQ.l #3,D0
  LSR.l #2,D0
  MOVE.l D0,tstsize1
  MOVE.l D0,tstsize2
  MOVE.l D7,D1
  MOVE.l #tsthead,D2                                      ;hunkbegin
  MOVEQ.l #$20,D3
  CMP.l #-1,bssstart
  BEQ 'lb1
  CMP.l #-1,chipstart
  BEQ 'lb1
  MOVE.l #1,bssnum
  MOVE.l #2,chipnum
  MOVEQ.l #$28,D3
  MOVE.l bsssize,d2
  ADDQ.l #3,d2
  ASR.l #2,d2
  MOVE.l d2,hunkend+8
  MOVE.l d2,bsssize3
  MOVE.l chipsize,d2
  ADDQ.l #3,d2
  ASR.l #2,d2
  MOVE.l d2,chipsize2
  ADD.l #$40000000,chipsize2
  MOVE.l d2,hunkend2+8
  MOVE.l D0,tstsize1c
  MOVE.l D0,tstsize2c
  MOVE.l #hunkbegin2,d2
BRA 'l100

 'lb1
  CMP.l #-1,bssstart
  BEQ 'l10
  MOVE.l #1,bssnum
  MOVEQ.l #$24,D3
  MOVE.l bsssize,d2
  ADDQ.l #3,d2
  ASR.l #2,d2
  MOVE.l d2,hunkend+8
  MOVE.l d2,bsssize2
  MOVE.l D0,tstsize1b
  MOVE.l D0,tstsize2b
  MOVE.l #hunkbegin,d2

 'l10
  CMP.l #-1,chipstart
  BEQ 'l100
  MOVE.l #1,chipnum
  MOVEQ.l #$24,D3
  MOVE.l chipsize,d2
  ADDQ.l #3,d2
  ASR.l #2,d2
  MOVE.l d2,hunkend2+8
  MOVE.l d2,bsssize2
  ADD.l #$40000000,bsssize2
  MOVE.l D0,tstsize1b
  MOVE.l D0,tstsize2b
  MOVE.l #hunkbegin,d2

 'l100
   BSR.w mywrite
  MOVE.l destbufferstart,D2
  ADD.l noinits,D2
  MOVE.l objlen,D3
  SUB.l #moremem,d3
  SUB.l noinits,D3
  CMP.l #-1,bssstart
  BNE 'l40
  CMP.l #-1,chipstart
  BNE 'l40
BRA 'l41

 'l40
  MOVE.l codeend,d1
    SUB.l d2,d1
    MOVE.l d1,d3
  SUB.l bsssize,d3
  SUB.l chipsize,d3
  MOVE.l D7,D1
  BSR.w mywrite
  MOVE.l objlen,D3
  SUB.l #moremem,d3
  SUB.l noinits,D3
  MOVE.l d3,d1
  MOVE.l destbufferstart,D2
  ADD.l noinits,D2
  ADD.l d2,d1
  SUB.l codeend,d1
  MOVE.l d1,d3
  MOVE.l codeend,d2

 'l41
  MOVE.l d2,d1
  ADD.l d3,d1
  ADDQ.l #3,D1
  ANDI.l #$FFFFFFFC,D1
  SUB.l d2,d1
  MOVE.l d1,d3
  MOVE.l D7,D1
   BSR.w mywrite
  MOVE.l hunkoffsetcounter,tstsize3
   BEQ.w JL_0_7646
  MOVE.l D7,D1
  MOVE.l #tstend,D2
  MOVEQ.l #$04,D3
   BSR.w mywrite
   MOVEA.l _execbase,A6
   MOVE.l hunkoffsetcounter,d0
   ASL.l #2,d0
   ADD.l #12,d0
   MOVEQ #0,d1
   JSR _AllocMem(a6)
   TST.l d0
   BEQ nomem
   MOVE.l noinits,D4
   MOVE.l d5,-(a7)
   MOVE.l d0,d5
   MOVE.l d0,a1
   MOVEA.l hunkoffsetbase,A2
   MOVE.b #0,newhunk

 menu_createresidentfile__oloopb:
  CMPA.w #$0,A2
   BEQ.w savehunk
  MOVE.l destbufferstart,D2
  ADD.l noinits,D2
  MOVE.l  $4(A2),d1
  BTST #31,d1
  BEQ 'lh1
  MOVE.b #1,newhunk
BRA 'lh3

 'lh1
  BTST #30,d1
  BEQ 'lh2
  MOVE.b #1,newhunk
BRA 'lh3

 'lh2
  ADD.l d1,d2
  CMP.l chipend,d2
  BLT 'l100
  SUB.l chipsize,d1

 'l100
  CMP.l bssend,d2
  BLT 'l101
  SUB.l bsssize,d1

 'l101
  MOVE.l d1,(a1)
  SUB.l D4,(A1)+

 'lh3
  MOVEA.l (A2),A2
BRA.w menu_createresidentfile__oloopb


savehunk
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  MOVE.l hunkoffsetnum,tstsize3
  BEQ 'ln1
  MOVE.l #tstend+4,d2
    MOVEQ #8,d3
   JSR _Write(A6)
  MOVE.l d7,d1
  MOVE.l hunkoffsetnum,d3
  ASL.l #2,d3
  MOVE.l d5,D2
  JSR _Write(a6)

 'ln1
  TST.b newhunk
  BEQ 'l10
  MOVEA.l hunkoffsetbase,A2
  MOVE.l d5,a0
  ADDQ #8,a0
  MOVE.l bssnum,-4(a0)
  MOVEQ #0,d6

 'lh2
  CMPA.w #$0,A2
   BEQ.w 'lh3
  MOVE.l destbufferstart,D2
  ADD.l noinits,D2
  MOVE.l  $4(A2),d1
  BTST #30,d1
  BEQ 'lh1
  BCLR #30,d1
  MOVE.l d1,(a0)
  SUB.l D4,(A0)+
  ADDQ.l #1,d6

 'lh1
  MOVE.l (a2),a2
BRA 'lh2

 'lh3
  TST.l d6
    BEQ 'lh10
    MOVE.l d5,a0
    MOVE.l d6,(a0)
    MOVE.l d7,d1
    MOVE.l d5,d2
    MOVE.l d6,d3
    ASL.l #2,d3
    ADDQ.l #8,d3
    BSR.w mywrite

 'lh10
  MOVEA.l hunkoffsetbase,A2
  MOVE.l d5,a0
  ADDQ #8,a0
  MOVE.l chipnum,-4(a0)
  MOVEQ #0,d6

 'lh20
  CMPA.w #$0,A2
   BEQ.w 'lh30
  MOVE.l destbufferstart,D2
  ADD.l noinits,D2
  MOVE.l  $4(A2),d1
  BTST #31,d1
  BEQ 'lh11
  BCLR #31,d1
  MOVE.l d1,(a0)
  SUB.l D4,(A0)+
  ADDQ.l #1,d6

 'lh11
  MOVE.l (a2),a2
BRA 'lh20

 'lh30
  TST.l d6
    BEQ 'l10
    MOVE.l d5,a0
    MOVE.l d6,(a0)
    MOVE.l d7,d1
    MOVE.l d5,d2
    MOVE.l d6,d3
    ASL.l #2,d3
    ADDQ.l #8,d3
    BSR.w mywrite

 'l10
   ;MOVE.l $4,a6
   MOVEA.l _execbase,A6
   MOVE.l hunkoffsetcounter,d0
   ASL.l #2,d0
   ADD.l #12,d0
   MOVE.l d5,a1
   JSR _FreeMem(a6)
   MOVEA.l _dosbase,A6
   MOVE.l (a7)+,d5
BRA JL_0_7632


nomem
  MOVEA.l hunkoffsetbase,A2
  MOVE.l noinits,D4

 JL_0_7610:
  CMPA.w #$0,A2                                            ;write hunkoffsets
  BEQ.w JL_0_7632
  LEA $4(A2),A1
  SUB.l D4,(A1)
  MOVE.l D7,D1
  MOVE.l A1,D2
  MOVEQ.l #$04,D3
  BSR.w mywrite
  ADD.l D4,$4(A2)
  MOVEA.l (A2),A2
BRA.w JL_0_7610

 JL_0_7632:
  CLR.l tstsize3
  MOVE.l D7,D1
  MOVE.l #tstsize3,D2
  MOVEQ.l #$04,D3
   BSR.w mywrite

 JL_0_7646:
  BTST #$7,link_debuginfo
   BEQ.w JL_0_7706
  MOVE.l #sysdebug,D2                                      ;debughunks
  MOVEQ.l #$04,D3
  MOVE.l D7,D1
   BSR.w mywrite
  MOVEA.l labelbase,A2

JL_0_7664:
  CMPA.w #$0,A2
   BEQ.w JL_0_76F8
  BTST #$0,$7(A2)
   BEQ.w JL_0_7682
  CMPI.l #$1,$4(A2)
   ;BNE.w JL_0_76F2
  BRA.w JL_0_76F2                                            ;only addr labels
 JL_0_7682:
  MOVEQ.l #$00,D4
  MOVE.b $12(A2),D4
  SUBI.w #$13,D4
  ADDQ.w #2,D4
  ANDI.w #$FFFC,D4
  MOVE.l D4,D5
  LSR.w #2,D5
  MOVE.l D5,temp1
  LSL.w #2,D5
  MOVE.l #temp1,a1
  ;move.l #temp1,D2
  LEA debugstore,a0
  MOVE.l (a1),(a0)+
  MOVEQ.l #$04,D3
  ;move.l D7,D1
  ;bsr.w mywrite
  LEA $13(A2),A1
  MOVE.l d4,d1
  SUBQ.l #1,d1

 'l10
    MOVE.b (a1)+,d0
    BEQ 'l21
    CMP.b #"'",d0                                            ; ' does reassembler/assembler not like, so replace
    BNE 'ok
    MOVE.b #"_",d0
'ok    MOVE.b d0,(a0)+                                      ; copy labeltext to debuginfo
  DBF d1,'l10

BRA 'l22

 'l21
      CLR.b (a0)+
  DBF d1,'l21

 'l22
  ADD.l d4,d3
  ;move.l A1,D2
  ;move.l D4,D3
  ;move.l D7,D1
   ;bsr.w mywrite
  SUB.l D4,D5
   BEQ.w JL_0_76CE
  MOVE.l #zero,a1
  ;move.l #zero,D2
  MOVE.l (a1),(a0)+
  ;move.l D5,D3
  ADD.l d5,d3
  ;move.l D7,D1
   ;bsr.w mywrite

 JL_0_76CE:
  MOVE.l $8(A2),D2
  SUB.l destbufferstart,D2
  SUB.l noinits,D2
  MOVE.l D2,temp1
  MOVE.l #temp1,a1
  ;move.l #temp1,D2
  MOVE.l (a1),(a0)+
  ADD.l #4,d3
  LEA debugstore,a0
  MOVE.l a0,d2
  ;moveq.l #$04,D3
  MOVE.l D7,D1
  BSR.w mywrite

 JL_0_76F2:
  MOVEA.l (A2),A2
BRA.w JL_0_7664


JL_0_76F8:
  MOVE.l #zero,D2
  MOVEQ.l #$04,D3
  MOVE.l D7,D1
  BSR.w mywrite

 JL_0_7706:
  MOVE.l D7,D1
  MOVE.l #tstdone,D2                                      ;hunkend
  MOVEQ.l #$04,D3
  CMPI.l #-1,bssstart
  BEQ 'l10
  MOVEQ #16,d3
  MOVE.l #hunkend,d2
  CMPI.l #-1,chipstart
  BEQ 'l10
  MOVE.l d7,d1
  MOVEQ #12,d3
  BSR.w mywrite

 'l10
  CMPI.l #-1,chipstart
  BEQ 'l11
  MOVEQ #12,d3
  MOVE.l #hunkend2,d2
  MOVE.l d7,d1
  BSR.w mywrite
  MOVE.l d7,d1
  MOVE.l chipstart,d2
  MOVE.l chipsize,d3
  BSR.w mywrite
  MOVEQ #4,d3
  MOVE.l #hunkend,d2
  MOVE.l d7,d1

 'l11
  BSR.w mywrite
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  JSR _Close(A6)

  ; --
  ; -- create the optional icon for the executable
  .create_icon
  BTST #$7,create_iconfile
   BEQ.w skip_createicon

  MOVEA.l ptr_newexefilename,A0

 JL_0_772C:
    TST.b (A0)+
  BNE.w JL_0_772C
  SUBQ.w #1,A0
  MOVE.l A0,-(A7)
  LEA str_infoextention2,A1

 JL_0_773A:
    MOVE.b (A1)+,(A0)+
  BNE.w JL_0_773A

  MOVE.l ptr_newexefilename,D1
  MOVEQ.l #-$02,D2
  MOVEA.l _dosbase,A6
  JSR _Lock(A6)
  MOVE.l D0,D1
  BEQ.w JL_0_775A                                          ;no icon exit so jump to create one  tomsmart1
  JSR _UnLock(A6)                                          ;OH!! there is a Icon so we must Unlock it  tomsmart1
BRA.w JL_0_7788                                            ;and skip writing a Icon  tomsmart1

 JL_0_775A:
  MOVE.l ptr_newexefilename,D1
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVEA.l _dosbase,A6
   JSR _Open(A6)
  MOVE.l D0,D7
   BEQ.w JL_0_7788
  MOVE.l #icongfx_data,D2                                  ; icon graphics
  MOVE.l #icongfx_data_end-icongfx_data,D3                 ; length of gfx-data
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  JSR _Write(A6)
  MOVE.l D7,D1
  JSR _Close(A6)

 JL_0_7788:
  MOVEA.l (A7)+,A0
  CLR.b (A0)

 skip_createicon:
  ; --
  ; -- restore offsets for extern debug
  TST.b exdebug
   BEQ JL_0_757Cb
  MOVE.w dontwrite,D1
  BNE.w JL_0_757Cb
  MOVE.l chipsize,d5
  MOVE.l bsssize,d3
  MOVE.l chipstart,d7
  MOVE.l bssstart,d6
  MOVEA.l hunkoffsetbase,A2
  MOVEA.l destbufferstart,A1
  MOVE.l A1,D2
  ADD.l noinits,D2
  CLR.l hunkoffsetnum

 JL_0_755Eb:
  CMPA.w #$0,A2
   BEQ.w JL_0_757Cb
  MOVE.l $4(A2),D0
   LEA $0(a1,d0.l),a0
   MOVE.l (a0),d1
  TST.l d1
   BMI.w 'lm1
  MOVE.b #0,newhunk
  CMP.l #-1,chipstart
  BEQ 'l10
  CMP.l chipstart,d1
  BLT 'l10
  MOVE.b #1,newhunk
  CMP.l chipend,d1
  BGE 'l110
  ADD.l d7,(a0)
  ADD.l #$80000000,4(a2)
BRA JL_0_7576b

 'l110
  ADD.l d5,0(a0)

 'l10
  CMP.l #-1,bssstart
    BEQ 'l11
  CMP.l bssstart,d1
  BLT 'l11
  CMP.l bssend,d1
  BGE 'l111
  TST.b newhunk
  BEQ 'ln1
  ADD.l d5,(a0)

 'ln1
  ADD.l d6,(a0)
  ADD.l #$40000000,4(a2)
BRA JL_0_7576b

 'l111
  ADD.l d3,0(a0)

 'l11
  ADD.l D2,(A0)                                            ;only normal code offsets restore

 'lm1
  ADDQ.l #1,hunkoffsetnum

 JL_0_7576b:
  MOVEA.l (A2),A2
BRA.w JL_0_755Eb

 JL_0_757Cb
  JSR call_setpointernormal
  MOVEM.l (a7)+,d2-d7/a2-a6
  AL_0_7790:
RTS


addoff:
  MOVE.l D2,-(A7)
  MOVE.l destpointer,D2
  SUB.l destbufferstart,D2
  BSR.w addhunkoffset
  MOVE.l (A7)+,D2
RTS


.addhunkoffset:
  MOVEM.l D0-D1/A0-A1/A6,-(A7)
  TST.b nohunkoffset
  BNE 'l10
  MOVEQ.l #$8,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C
  ADDQ.l #1,hunkoffsetcounter
  MOVEA.l D0,A0
  MOVE.l hunkoffsetbase,(A0)
  MOVE.l A0,hunkoffsetbase
  MOVE.l D2,$4(A0)

 'l10
  MOVEM.l (A7)+,D0-D1/A0-A1/A6
RTS


AJL_0_7962:
  CLR.l hunkoffsetbase
  MOVEA.l _execbase,A6
  MOVEA.l hunkoffsetbase,A2

 JL_0_7972:
    CMPA.w #$0,A2
     BEQ.w JL_0_7988
    MOVEA.l A2,A1
    MOVEQ.l #$08,D0
    MOVEA.l (A2),A2
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
BRA.w JL_0_7972

 JL_0_7988:
  CLR.l hunkoffsetcounter
RTS


cmakebuff:  Ds.l 6                                          ;dc.w 12 org source
cmakea5:    Ds.l 1
cmake:      Ds.w 1
cmakebak:   Ds.l 32                                         ;ds.b 128 org source


getchar:
  MOVE.l A5,lastsourcepos
  MOVE.w instringon,oldqflag
   ;bsr.w getcharb                                          ;gettokennum

 JL_0_7BA0a:                                                ;??Looks like label not used??
  MOVEQ.l #$00,D0
  MOVE.b (A5)+,D0
   BEQ getcharb__donea
  BPL getcharb__stuffa
  LSL.l #8,D0
  MOVE.b (A5)+,D0
  MOVE.l a1,-(a7)
  LEA replacedat,a1
  Dc.w $4a71,$0a00                                         ;TST.w 0(a1,d0.l*2)
  BEQ getchar__l10
  Dc.w $3031,$0a00                                         ;MOVE.w 0(a1,d0.l*2),d0

 getchar__l10:
  MOVE.l d0,lasttoken
  MOVE.l (a7)+,a1
BRA getchar__weiter

 getcharb__stuffa:
  CMP.w #$22,D0
   BEQ.b swapquotea
  CMP.w #$3B,D0
   BNE.b getcharb__donea
  TST.w instringon
   BNE.b getcharb__donea

 getcharb__loopa:
  MOVE.b (A5)+,D0
             BEQ getchar__l1
             CMP.b #":",d0
             BNE getcharb__loopa                                ;:@
             CMP.b #"@",(a5)
             BNE getcharb__loopa
             ADDQ #1,a5

 getchar__l1:
  MOVE.w D0,lastchar

 getcharb__donea:
BRA.s getchar__weiter

 swapquotea:
  NOT.w instringon

 getchar__weiter:
   MOVE.w D0,lastchar
   BEQ.w getchar__done
   BPL.w getchar__done2
  CMP.w #-$7FE4,D0                                         ;cnif
   BEQ.w getchar__cnif
  CMP.w #-$7FE3,D0                                         ;csif
   BEQ.w getchar__csif
  CMP.w #-$7FE2,D0                                         ;celse
   BEQ.w getchar__celse
  CMP.w #-$7FE1,D0                                         ;cend
   BEQ.w getchar__cend

 getchar__done2:
  TST.w skipcode
   BEQ.w getchar
  CMP.w #$7E,D0
   BEQ.w getchar__cmake                                         ;tilde
  CMP.w #$2,D0
   BNE.w getchar__notunpath
  MOVEA.l usedfrom,A5
  CLR.l usedfrom
BRA.w getchar

 getchar__notunpath:
  CMP.w #$1,D0
   BNE.w getchar__done
    ;
    ;End of Cmake chars got
    ;
  MOVEA.l cmakea5(PC),A5
BRA.w getchar

 getchar__cmake:
  TST.w cmake
   BNE.w getchar__done

  MOVEM.l D0-D7/A0-A6,-(A7)
  LEA cmake,a0                                         ;reass
  NOT.w (a0)
  LEA cmakebak(PC),A0
  LEA ptr_parameterstore,A1
  MOVEQ.l #$1F,D0

 getchar__cmloop:
    MOVE.l (A1)+,(A0)+
  DBF D0,getchar__cmloop

 ;  BSR.w AJL_0_BF6E                                      ;get constant into d3
   JSR AJL_0_BF6E
  CMP.w #$7E,D0
   BNE.w syntaxerr
  MOVE.l A5,cmakea5                                      ;tilde
  LEA cmakebuff(PC),A0
  MOVE.l D3,D2
  BSR.w makelong
  ADDQ.b #1,(A0)
  LEA cmake,a0
  NOT.w (a0)                                               ;reass
  LEA cmakebak(PC),A0
  LEA ptr_parameterstore,A1
  MOVEQ.l #$1F,D0

 getchar__cmloop2:
    MOVE.l (A0)+,(A1)+
  DBF D0,getchar__cmloop2

  MOVEM.l (A7)+,D0-D7/A0-A6
  LEA cmakebuff(PC),A5
BRA.w getchar

 getchar__done:
RTS


 getchar__csif:
  MOVE.l linenumat,ciflineat                               ;csif
  TST.w skipcode
   BEQ.w getchar__incnest
   BSR.w get1bytemain
   MOVE.l a1,-(a7)
   JSR JL_0_C492
   MOVE.l (a7)+,a1
BRA.w getchar

 getchar__cnif:
  MOVE.l linenumat,ciflineat                               ;cnif
  TST.w skipcode
   BEQ.w getchar__incnest
   BSR.w get1bytemain
   CMP.b #"@",d0
   BNE getchar__cnif_ok2
   BSR.w get1bytemain
   MOVE.b #1,incnif
   JSR findconstant2
   BEQ getchar__cnif_ok2

 getchar__cnif_ok2:
   MOVE.w fast,-(a7)
   CLR.b fast
   MOVE.l a1,-(a7)
   JSR JL_0_C47E
   CLR.b incnif
   MOVE.l (a7)+,a1
   MOVE.w (a7)+,fast
BRA.w getchar

 getchar__incnest:
  ADDQ.w #1,connest
BRA.w getchar

 getchar__celse:
  MOVE.w connest,D0                                      ;celse
   BNE.w getchar
  NOT.w skipcode
BRA.w getchar

 getchar__cend:
  SUBQ.w #1,connest                                      ;cend
   BPL.w getchar
  ADDQ.w #1,connest
  MOVEA.l concomsp,A0
  CMPA.l #concomstack,A0
   BEQ.w nociferr
  SUBQ.w #2,A0
  MOVE.l A0,concomsp
  MOVE.w (A0),skipcode
BRA.w getchar


ciflineat:   Ds.l 1


getcharb:
    ;
    ;get next character into d0... a5=charpointer
    ;set hi bit if token, and lo 15 bits to token number (0-32767)
    ;
  MOVEQ.l #$00,D0
  MOVE.b (A5)+,D0
   BEQ.b getcharb__done
   BPL.b getcharb__stuff
  LSL.w #8,D0
  MOVE.b (A5)+,D0
RTS

 getcharb__stuff:
  CMP.w #$22,D0
   BEQ.b swapquote
  CMP.w #$3B,D0
   BNE.b getcharb__done
  TST.w instringon
   BNE.b getcharb__done

 getcharb__loop:
  MOVE.b (A5)+,D0
            BEQ getcharb__loop_l1
            CMP.b #":",d0
            BNE getcharb__loop
            CMP.b #"@",(a5)
            BNE getcharb__loop

 getcharb__loop_l1:
  MOVE.w D0,lastchar

 getcharb__done:
RTS

 swapquote:
  NOT.w instringon
RTS


get1byte_:                                                 ;getchar2 org source  ;as above and skip spaces
  BSR.w getchar
  TST.w instringon
   BNE.w get1byte__skip
  CMP.w #$20,D0
   BEQ.w get1byte_

 get1byte__skip:
RTS


gs:        Ds.w 13                                         ;ds.b 26  org source
           Dc.b $F6,$E4,$FC,$D6                            ;dc.b 228,246,252,196,214,220 org source
           Dc.b $C4,$DC

Even

.get1bytemain:                                             ;getchar3 org source    ;as above. return z=1 if 0 or ':'
  ;bsr.w get1byte_
  BSR.w getchar
  TST.w instringon
   BNE.w gchar2
  CMP.w #$20,D0
   BEQ.w get1bytemain

  TST.w D0

 gchar2:
  BEQ.b get1bytemain__zero
  TST.w instringon
   BEQ.b get1bytemain__noqoute
  CMP.b #$20,D0
   BCC.b get1bytemain__skip
  MOVE.b gs(PC,D0.W),D0
RTS

 get1bytemain__noqoute:
  CMP.w #-$7FDE,D0                                         ;cmp #$8000+34,d0 org source  ;else
   BEQ.b get1bytemain__zero
  CMP.w #$3A,D0
   BEQ.b get1bytemain__zero

 get1bytemain__skip:
  TST.w D0

 get1bytemain__zero:
RTS


reget:
  MOVE.w lastchar,D0
BRA.w gchar2


bakup:
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
RTS


storeloc:                                                  ;remember character pointer
  MOVE.w D0,locchar
  MOVE.l A5,locloc
RTS


resloc:                                                    ;recall char pointer....
  MOVEA.l locloc,A5
  MOVE.w locchar,D0
  MOVE.w D0,lastchar
RTS


.error_messages:
XINCLUDE "internal_errormsg.ab2"



ezerr:   Ds.w 1                                            ;for simple errors
            ;(ie not during compile)

.comperror   ;compile time error...

.handle_compileerror:                                      ;err org source
   MOVE.l myline,d0
  BNE handle_compileerror__l2
CNIF #continue_on_error
    MOVE.l a5,lastsourcepos
CEND
    SUBA.l a5,a5
 handle_compileerror__l2:
  TST.l usedfrom
  BEQ handle_compileerror__org
    MOVEA.l usedfrom,a5

 handle_compileerror__org:
  TST.w dirmode
  BNE.b handle_compileerror__quiet
    JSR call_setpointernormal
    MOVE.w ezerr(PC),D0
    BNE.w handle_compileerror__skip
      MOVE.w cfetchmode,D0
      BEQ.w handle_compileerror__skip2
        MOVE.l oldlibat,destbufferend                      ;fix up lib thing.

 handle_compileerror__skip2:
  MOVE.w constmode,D0
  BEQ.b handle_compileerror__skip3
    BSR.w asmerr2

 handle_compileerror__skip3:
  MOVE.l firstlocal,D1
  OR.l firstglob,D1
  BEQ.b handle_compileerror__notproc                       ;?!?!?!
    JSR JL_0_DB5C

 handle_compileerror__notproc:
  MOVE.w #$FFFF,anyerrs                                    ;#-1,anyerrs org source
  CMP.l #"NORE",reqmode                                    ;for used functions
  BEQ handle_compileerror__notproc_l1
    MOVE.l linenumat,compilelinecounter

 handle_compileerror__notproc_l1:
  JSR close_compilewin

 handle_compileerror__skip:
  MOVEA.l (A7)+,A0
  CMP.l #"NORE",reqmode                                    ;for used functions
  BEQ handle_compileerror__skip_Lxx2
  TST.l CLIMode
  BNE 'climode_output
'guimode_output:
    JSR save_errorfile
    BRA 'end_output
'climode_output:
    JSR stdout_error
CNIF #continue_on_error
    MOVE.l lastsourcepos,a5
'loop TST.b (a5)
      BEQ 'ok2
    MOVE.b (a5)+,d0                                  ; position to usefull source position to avoid following errors
    BEQ 'ok
    CMP.b #":",d0
    BEQ 'ok
    BRA 'loop
'ok SUBQ.l #1,a5
'ok2 MOVE.w #0,lastchar
    MOVE.b #1,iserror
    MOVE.l stackaddr,a7
    RTS
CEND
  'end_output

;  MOVEA.l comdata,A1
;  MOVEA.l $C(A1),A1                                        ; show errorrequester
  MOVE.l A0,-(a7)
  !ComData_GetL{comFunc_ErrorRequest,A1}
  MOVE.l (a7)+,A0

  MOVEM.l d6/D7/A6,-(A7)
  MOVE.l includeline,d7
  MOVE.l #"INLN",a6
  MOVE.l errstack,tempa7
  JSR (A1)
  !basic
   If Peek.l(Addr Window(3))<>0 Then WZCloseWindow 3
  !asm
  MOVEM.l (A7)+,D7/d6/A6

 ;MOVEA.l errstack,A7
  MOVE.l tempa7,a7
  MOVEA.l errcont,A0
 ;JMP (A0)                                                  ;clear all vars
RTS

 handle_compileerror__skip_Lxx2:
  MOVEA.l errstack,A7
  MOVEA.l errcont,A0
 ;JMP (A0)                                                  ;clear all vars
RTS

 handle_compileerror__quiet:
  MOVE.l (A7),D0
  MOVEA.l errstack,A7
  MOVEA.l errcont,A0
JMP (A0)


tstalpha:
    ;tst if d0 is alphabetic
    ;return z=1 if yes
  CMP.w #$7A,D0                                            ;'z'
   BHI.w tstalpha__no
  CMP.w #$41,D0                                            ;'A'
   BCS.w tstalpha__no
  CMP.w #$61,D0                                            ;'a'
   BCC.w tstalpha__yes
  CMP.w #$5A,D0                                            ;'Z'
   BHI.w tstalpha__no

 tstalpha__yes:
  CMP.w D0,D0

 tstalpha__no:
RTS


tstnum:
    ;tst if d0 is numeric, eq=1 if yes
    ;cmp    #'-',d0
    ;beq    .skip
tstnum2:
  CMP.w #$30,D0                                            ;'0'
   BCS.w tstnum__skip
  CMP.w #$39,D0                                            ;'9'
   BHI.w tstnum__skip                                     
  CMP.w D0,D0

 tstnum__skip:
RTS


tstlab:
    ;tst if d0 is a lable character
    ;eq=1 if yes
  !compare1                                                ;bsr.w tstalpha
   BEQ.w tstlab__skip
  !compare2                                                ;bsr.w tstnum2
   BEQ.w tstlab__skip
  CMP.w #$5F,D0                                            ;'_'
   BEQ.w tstlab__skip
  CMP.w #$27,D0                                            ;#loclabch,d0 org source

 tstlab__skip:
RTS


makename2:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

 getparameter2:                                            ;makename org source
  LEA ptr_parameterstore,A1

 makename3:
  MOVEQ.l #$00,D2

 makename4:
  LEA chartab,a0
  MOVEQ #0,d0
  MOVE.l A5,lastsourcepos
  MOVE.w instringon,oldqflag

 makename4__retry:
    MOVE.b (a5)+,d0
  CMP.b #$20,d0                                            ;space deftype
  BEQ makename4__retry

  MOVE.w d0,lastchar
  TST.b 0(a0,d0.w)
  BNE makename__done

  ;move.l a0,-(a7)
  ;cmp.w #$5F,D0                                            ;'_'
   ;beq.w makename__loop
   ;compare1                                                ;bsr.w tstalpha
   ;bne.w makename__done

 makename__loop:
  MOVE.b D0,(A1)+
  ADDQ.l #1,D2
  MOVE.l A5,lastsourcepos

 makename__loop_ln1:
  MOVE.b (a5)+,d0
  MOVE.b d0,lastchar+1
  CMP.b #$20,d0
  BEQ makename__loop_l20

  TST.b 0(a0,d0)
  BEQ makename__loop
  CMP.b #2,d0
  BNE makename__loop_lf1
  MOVEA.l usedfrom,A5
  CLR.l usedfrom
BRA makename__loop_ln1

 makename__loop_lf1:
  CMP.b #1,d0
  BNE makename__loop_l20
  MOVEA.l cmakea5(PC),A5
BRA makename__loop_ln1

 makename__loop_l20:
  CMP.b #$7e,d0
            BNE makename__loop_lt
            TST.w cmake
            BNE.w makename__loop_a1
            SUBQ.l #1,a5
            BSR.w get1bytemain
BRA makename__loop

 makename__loop_a1                                         ;??looks like double label??
 makename__loop_lt
BRA makename__loop_gpex


 makename__loop_old:                                       ;tstlab org source ;??looks like a copy??
  BSR.w getchar
   !compare1                                               ;bsr.w tstalpha
   BEQ.w makename__loop_getp1
   !compare2                                               ;bsr.w tstnum
   BEQ.w makename__loop_getp1
  CMP.w #$5F,D0                                            ;'_'
   BEQ.w makename__loop_getp1
  CMP.w #$27,D0                                            ;#loclabch,d0 org source

 ;tstlab__skip:                                                ;??Looklike dead label??
 makename__loop_getp1:
      BNE makename__loop_gpex
      CMP.b #$20,d0
      BNE.w makename__loop

 makename__loop_gpex:
     TST.b d0
     BPL makename__loop_l10
     SUBQ.l #1,a5
     BSR get1byte_

 makename__loop_l10:
   CMP.w #$20,D0
   BNE.w makename__done
   MOVEQ #0,d0
  MOVE.l a5,lastsourcepos

 makename__loop_l103:
  MOVE.b (a5)+,d0                                          ;neuneu
  BPL makename__loop_l101:
  ASL.w #8,d0
  MOVE.b (a5)+,d0

 makename__loop_l101:
  TST.w instringon
  BNE makename__loop_l102
  CMP.b #$20,d0
  BEQ makename__loop_l103
  CMP.b #";",d0
  BNE makename__loop_l102

 makename__loop_lr:
  MOVE.b (A5)+,D0
             BEQ makename__loop_l1
             CMP.b #":",d0
             BNE makename__loop_lr                         ;:@
             CMP.b #"@",(a5)
             BNE makename__loop_lr
             ADDQ #1,a5

 makename__loop_l1:                                        ;??looks like double label?
 makename__loop_l102:
  MOVE.w d0,lastchar
   ;BSR.w get1bytemain

 makename__done:
  CMP.b #";",d0
  BEQ makename__done_l11
  CLR.b (A1)
  ;move.l (a7)+,a0
  TST.w D2
RTS

 makename__done_l11:
  CLR.b (a1)
  MOVEQ #0,d0
  MOVE.w d0,lastchar
  ;move.l (a7)+,a0
  TST.w D2
RTS


findlast:                                                  ;??looks like not used??
    ;look for last entry in list from a2
    ;
  MOVE.l (A2),D0

 findlast__loop:
  BEQ.w findlast__here
  MOVEA.l D0,A2
BRA.w findlast__loop

 findlast__here:
BRA.w reget


addhere2:
    ;insert at beginning
    ;
  MOVE.l (A2),-(A7)
  BSR.w addlabel
  MOVE.l (A7)+,(A2)
RTS



addlabelhash:                                              
  CLR.l fp0addr
  TST.w dirmode
   BNE.w illdirerr
  MOVEQ.l #$00,D0
  MOVE.w D7,D0
  ADD.w D2,D0
  ADDQ.w #1,D0
  MOVE.w D0,D2
  ADDQ.l #2,d0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C
  MOVE.l lastlabel,a2
  MOVE.l D0,(A2)
  MOVE.l d0,a0
  CLR.l (a0)
  MOVE.l a0,lastlabel
  MOVE.l d0,A2
  LEA -$1(A0,D7.W),A0
  MOVE.b D2,(A0)+
  LEA ptr_parameterstore,A1
  MOVEQ #0,d0
  MOVEQ #0,d1

 addlabel_loop2a:
  MOVE.b (A1)+,d1
   BEQ 'l1
   !hashalgo
   MOVE.b d1,(A0)+
BRA addlabel_loop2a

 'l1
   CLR.b (a0)+
   LEA labelhash,a0
   AND.l #hashsize,d0
   ASL.l #2,d0
   MOVE.l 0(a0,d0),d1
   MOVE.l d1,$c(a2)
   MOVE.l a2,0(a0,d0)
   MOVEQ #0,d0
BRA.w reget


addvariable:
   TST.b newvariable
   BNE addlabel

 'l1
  TST.w dirmode
   BNE.w illdirerr
  MOVEQ.l #$00,D0
  MOVE.w D7,D0
  ADD.w D2,D0
  ADDQ.w #1,D0
  MOVE.w D0,D2
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
  MOVEA.l D0,A0
   ;jsr AJL_0_4B6C
  LEA varbase,a2
  MOVE.l (a2),(a0)
  MOVE.l A0,(A2)
  MOVEA.l A0,A2
  LEA -$1(A0,D7.W),A0
  MOVE.b D2,(A0)+
  LEA ptr_parameterstore,A1
  MOVEQ #0,d0
  MOVEQ #0,d1

 'l11
  MOVE.b (A1)+,d1
   BEQ 'l12
   !hashalgo
   MOVE.b d1,(A0)+
BRA 'l11

 'l12
  CLR.b (a0)+
  LEA variablehash,a0
   AND.l #hashsize,d0
   ASL.l #2,d0
   MOVE.l 0(a0,d0),d1
   MOVE.l d1,$e(a2)
   MOVE.l a2,0(a0,d0)
   MOVEQ #0,d0
BRA.w reget


.addlabel                                                  ;addhere org source
  TST.w dirmode
   BNE.w illdirerr
    ;
    ;add namebuff after a2,d7
    ;
    ;d2=len of name, name in namebuff
    ;set a2 to address of struct
    ;
  MOVEQ.l #$00,D0
  MOVE.w D7,D0
  ADD.w D2,D0
  ADDQ.w #1,D0
  MOVE.w D0,D2
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C
  MOVEA.l D0,A0
  MOVE.l A0,(A2)
  CLR.l (a0)
  CLR.l 8(a0)                                              ;clear next
  MOVEA.l A0,A2
  LEA -$1(A0,D7.W),A0
  MOVE.b D2,(A0)+                                          ;put in struct length
  LEA ptr_parameterstore,A1
  MOVEQ #0,d0
  MOVEQ #0,d1

 addlabel_loop2:
  MOVE.b (A1)+,d1

 'l1                                                       ;??looks like label not used anymore??
  MOVE.b d1,(A0)+
  BNE.w addlabel_loop2
BRA.w reget


.findconstant:                                             ;findinc org source
  MOVEQ.l #$13,D7
  LEA constantbase,A2
BRA.w findlab


findxinc:
  MOVEQ.l #$05+8,D7                                        ;#5,d7 org source
  LEA xinclude_base,A2
BRA.w findlab


findconst_org:
  MOVEQ.l #$09,D7
  LEA firstconst,A2
BRA.w findlab


findmac:
  MOVEQ.l #$0d,D7                                          ;find macro
  LEA macrobase,A2
BRA.w findlab


findlabel2:                                                ;findadd  org source
  LEA labelhash,A2
  MOVEQ.l #$13,D7
  EXT.l d2
  LEA ptr_parameterstore,A0
  MOVEQ #0,d0
  MOVEQ #0,d1

 'l20
    MOVE.b (a0)+,d1
    BEQ 'l15
    !hashalgo
BRA 'l20

 'l15
  AND.l #hashsize,d0
  ASL.l #2,d0
  MOVE.l 0(a2,d0),d0
BRA 'l11

 'l10
  MOVE.l $c(A2),D0                                         ;find label

 'l11
  BEQ findlab__no
  MOVEA.l D0,A2
  MOVEQ.l #$00,D0
  MOVE.b -$1(A2,D7.l),D0
  LEA ptr_parameterstore,A0
  SUB.l D7,D0
  SUBQ.l #1,D0
  CMP.l D0,D2
   BNE.b 'l10
  LEA $0(A2,D7.W),A1
  SUBQ.l #1,D0

 'l201:
    MOVE.b (a1)+,d1
    CMP.b (a0)+,d1
    ;CMPM.b (A1)+,(A0)+
    BNE.b 'l10
  DBF D0,'l201

  BSR.w reget
  CMP.w D0,D0
RTS


findtype:
  MOVEQ.l #$0B,D7
BRA.w findlab


findproc:
  LEA firstproc,A2
  MOVE.l #$21+#funcentry_extend,D7
BRA findlab


findfor:
  LEA firstfor,A2
  MOVEQ.l #$11,D7
BRA.w findlab


findvariable2                                              ;findvar org source
  MOVEQ.l #$0F,D7
BRA.w findlab


findvariable:
  MOVEQ.l #$0F+4,D7
  TST.b newvariable
   BNE.w findlab
  LEA variablehash,A2
  LEA ptr_parameterstore,A0
  MOVEQ #0,d0
  MOVEQ #0,d1

 'l20
    MOVE.b (a0)+,d1
    BEQ 'l15
    !hashalgo
BRA 'l20

 'l15
  AND.l #hashsize,d0
  ASL.l #2,d0
  MOVE.l 0(a2,d0),d0
BRA 'l11

 'l10
  MOVE.l $e(A2),D0                                         ;find label

 'l11
  BEQ findlab__no
  MOVEA.l D0,A2
  MOVEQ.l #$00,D0
  MOVE.b -$1(A2,D7.W),D0
  LEA ptr_parameterstore,A0
  SUB.w D7,D0
  SUBQ.l #1,D0
  CMP.w D0,D2
   BNE.b 'l10
  LEA $0(A2,D7.W),A1
  SUBQ.l #1,D0

 'l201:
    MOVE.b (a1)+,d1
    CMP.b (a0)+,d1
    ;CMPM.b (A1)+,(A0)+
    BNE.b 'l10
  DBF D0,'l201

  BSR.w reget
  CMP.w D0,D0
RTS



 findlab:
    ;see if namebuff is in list at a2, char offset in d7
    ;
    ;z=1 if yes, a2=item loc
    ;
    ;if no, a2=last for link
    ;
 labelold                                                  ;??looks like double label??
 findlab__loop:
    MOVE.l (A2),D0                                         ;find label
     BEQ.b findlab__no
    MOVEA.l D0,A2
    MOVEQ.l #$00,D0
    MOVE.b -$1(A2,D7.W),D0
    SUB.l D7,D0
    SUBQ.l #1,D0
  CMP.w D0,D2
  BNE.b findlab__loop

  LEA $0(A2,D7.W),A1
  LEA ptr_parameterstore,A0
  SUBQ.l #1,D0

 findlab__loop2:
    MOVE.b (a1)+,d1
    CMP.b (a0)+,d1
    ;CMPM.b (A1)+,(A0)+
    BNE.b findlab__loop
  DBF D0,findlab__loop2

  BSR.w reget
  CMP.w D0,D0
RTS

 findlab__no:
  BSR.w reget
  MOVEQ.l #-$01,D1
RTS


freeprocvs:
  MOVEA.l alllocals,A4
  CLR.l alllocals
;BRA freeprocvs__done

 freeprocvs__loop:
    CMPA.w #$0,A4
     BEQ.b freeprocvs__done
    MOVEA.l $4(A4),A3
    ;BSR.w freevarsb
    MOVEA.l $8(A4),A3
    ;BSR.w freevars
    MOVEA.l A4,A1
    MOVEA.l (A4),A4
    MOVEQ.l #$0C,D0
    MOVEA.l _execbase,A6
    MOVE.l mempool,a0
    JSR _FreePooled(A6)
BRA.b freeprocvs__loop

 freeprocvs__done:
  CLR.l firstglob                                          ;fix 2*aclearallvar called
  CLR.l firstlocal
  CLR.l sharebase
  TST.l mempool2
  BEQ freeprocvs__done_l10
  ;MOVE.l $4,a6
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  CLR.l mempool2
  JSR _DeletePool(a6)

 freeprocvs__done_l10:
  MOVE.l _execbase,a6
  MOVE.l #$10000,d0
  MOVE.l #80000,d1
  MOVE.l d1,d2
  JSR _CreatePool(a6)
  MOVE.l d0,mempool2
RTS


freevars:                                                  ;free up var structs from a3 on
  CMPA.w #$0,A3
   BEQ.w freevars__done
  MOVEA.l A3,A1
  MOVEA.l (A3),A3
  MOVEQ.l #$00,D0
  MOVE.b $E(A1),D0
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _FreePooled(A6)
BRA.w freevars

 freevarsb:
    CMPA.w #$0,A3
     BEQ.w freevars__done
    MOVEA.l A3,A1
    MOVEA.l (A3),A3
    MOVEQ.l #$00,D0
    MOVE.b $E+4(A1),D0
    MOVEA.l _execbase,A6
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
BRA.w freevarsb

 freevars__done:
RTS


clearlabels:                                               ;freelabels org source  ;free up label structs from firstlabel on...
  MOVEA.l currentlabeladdr,A0
  MOVE.l a0,lastlabel
  MOVEA.l (A0),A2
  CLR.l (A0)
  MOVEA.l _execbase,A6

 clearlabels__loop:
  CMPA.w #$0,A2
   BEQ.w clearlabels__done
  MOVE.l $4(A2),D0
  BTST #$0,D0
   BNE.w clearlabels__skip
  MOVEA.l D0,A3

 clearlabels__loop2:
    CMPA.w #$0,A3
     BEQ.w clearlabels__skip
    MOVEA.l A3,A1
    MOVEA.l (A3),A3
    MOVEQ.l #$0C+2,D0                                      ;cancel fix
    MOVE.l mempool,a0
    JSR _FreePooled(A6)
BRA.w clearlabels__loop2

 clearlabels__skip:
  MOVEQ.l #$00,D0
  MOVE.b $12(A2),D0
  MOVEA.l A2,A1
  MOVEA.l (A2),A2
  MOVE.l mempool2,a0
   ;JSR _FreePooled(A6)                                     ;nofreemem
BRA.w clearlabels__loop

 clearlabels__done:
RTS


freepends:
  MOVEA.l firstpend,A3
  CLR.l firstpend
  MOVEA.l _execbase,A6

 fpnd2:
    CMPA.w #$0,A3
     BEQ.w freepends__done
    MOVEA.l A3,A1
    MOVEQ.l #$08,D0
    MOVEA.l (A3),A3
    MOVE.l mempool,a0
    JSR _FreePooled(A6)
BRA.w fpnd2

 freepends__done:
RTS


clearfunctionlist:                                         ;freeprocs org source  ;free up all proc structs
  MOVEA.l firstproc,A2
  CLR.l firstproc
  MOVEA.l _execbase,A6

 clearfunctionlist__loop:
    CMPA.w #$0,A2
     BEQ.w clearfunctionlist__done
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$00,D0
    MOVE.b $20+#funcentry_extend(A1),D0
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
BRA.w clearfunctionlist__loop

 clearfunctionlist__done:
RTS


freetypes:                                                 ;free up type structs from a2 on
  CMPA.w #$0,A2
   BEQ.w freetypes__done
  MOVEA.l $4(A2),A3
  CMPA.w #$FF,A3
   BEQ.w freetypes__noway
    ;
    ;free offsets too
    ;
   BSR.w freevars

 freetypes__noway:
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$00,D0
    MOVE.b $A(A1),D0
    MOVEA.l _execbase,A6
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
BRA.w freetypes

 freetypes__done:
RTS


JL_0_8E3C:
  JSR uselib2

  CLR.w notshared
  CLR.w varmode
  MOVE.w proceduremode,D1
   BNE.w JL_0_8F4E
  LEA varbase,A2
  LEA ptr_parameterstore,a0
  CMP.b #$22,(a0)
  BNE JL_0_8E5E
  MOVEQ #0,d0
JMP error

 JL_0_8E5E:
  BSR.w findvariable

 JL_0_8E62:
  BNE.w JL_0_8E7E

 JL_0_8E62b
  MOVE.b flagmask+1,D1
  MOVE.b $7(A2),D3
  EOR.b D3,D1
  BNE 'l2
  CMP.b #2,nowdeclare
  BEQ errormsg_declaredtwice
BRA.w JL_0_8FA8

 'l2
  BSR.w findlab
  BNE 'l1
  CMP.b #2,nowdeclare
  BEQ errormsg_declaredtwice
  CMP.w d0,d0

 'l1
BRA.w JL_0_8E62

 JL_0_8E7E:
   MOVE.l a2,-(a7)
   LEA sharebase,a2
   MOVEQ #$f+4,d7
   BSR.w findlab
   BEQ 'l2x
   MOVE.l (a7)+,a2
BRA 'cont

 'l2x
  ADDQ.l #4,a7
  CLR.w varmode
  MOVE.b flagmask+1,D1
  MOVE.b $7(A2),D3
  EOR.b D3,D1
  BNE vardeclareerr
BRA JL_0_8FA8

 'cont
   MOVE.w nonew,D1
   BNE.w nonewerr
   TST.b nowdeclare
   BNE 'l2
   TST.b declare2
   BEQ 'l1
   CMP.b #$2e,d0
   BEQ 'l2
   CMP.b #"$",d0
   BEQ 'l2
BRA vardeclareerr

 'l1
  TST.b declare
   BNE vardeclareerr

 'l2
  BSR.w addvariable
  NOT.w notshared
  MOVEA.l A2,A3
  MOVEA.l defaulttype,A2
  CMP.w #$2E,D0
   BEQ.w JL_0_8EB8
  CMP.w #$24,D0
   BNE.w JL_0_8ECA
  LEA newtype_string,A2
   BSR.w get1bytemain
BRA.w JL_0_8ECA

 JL_0_8EB8b:
   BSR.w getparameter2
  LEA newtypebase,A2
   BSR.w findtype
   BNE.w JUMP_notypeerr

 JL_0_8ECAb:
  CMPA.l #newtype_byte,A2
   BEQ.w JL_0_8EECb
  MOVE.w varmode,D1
   BNE.w JL_0_8EE4b
  ADDQ.w #1,globalvarpointer

 JL_0_8EE4b:
  BCLR #$0,globalvarpointer+1

 JL_0_8EECb:
  MOVE.l A2,$A(A3)
  MOVE.w flagmask,$6(A3)                                  ;??????????
  ;MOVE.w #0,$6(A3)                                         ;??????????
  MOVEQ.l #$04,D1
  BTST #$0,flagmask+1
   BNE.w JL_0_8F22b
  BTST #$1,flagmask+1
   BNE.w JL_0_8F22b
  CMPI.l #$100,$4(A2)
   BCC.w JL_0_8F22b
  MOVE.w $8(A2),D1

 JL_0_8F22b:
  TST.w varmode
BRA.w JL_0_8F3E

;  NEG.w D1                                                 ;??looks like dead code??
;  ADD.w D1,globalvarpointer
;  MOVE.w globalvarpointer,$4(A3)
;RTS


JL_0_8EB8:
  BSR.w getparameter2
  LEA newtypebase,A2
   BSR.w findtype
   BNE.w notypeerr

 JL_0_8ECA:
  CMPA.l #newtype_byte,A2
   BEQ.w JL_0_8EEC
  MOVE.w varmode,D1
   BNE.w JL_0_8EE4
  ADDQ.w #1,globalvarpointer

 JL_0_8EE4:
  BCLR #$0,globalvarpointer+1

 JL_0_8EEC:
  MOVE.l A2,$A(A3)
  MOVE.w flagmask,$6(A3)                                  ;??????????
  MOVEQ.l #$04,D1
  BTST #$0,flagmask+1
   BNE.w JL_0_8F22
  BTST #$1,flagmask+1
   BNE.w JL_0_8F22
  CMPI.l #$100,$4(A2)
   BCC.w JL_0_8F22
  MOVE.w $8(A2),D1

 JL_0_8F22:
  TST.w varmode
   BEQ.w JL_0_8F3E
  NEG.w D1
  ADD.w D1,globalvarpointer
  MOVE.w globalvarpointer,$4(A3)
RTS

 JL_0_8F3E:
  MOVE.w globalvarpointer,$4(A3)
  ADD.w D1,globalvarpointer
RTS


JL_0_8F4E:
  LEA firstglob,A2
   BSR.w findvariable2

 JL_0_8F58:
  BNE.w JL_0_8F74
  MOVE.b flagmask+1,D1
  MOVE.b $7(A2),D3
  EOR.b D3,D1
   BEQ.w JL_0_8FA8
   BSR.w findlab
BRA.w JL_0_8F58

 JL_0_8F74:
  MOVE.w #$FFFF,varmode
  MOVE.w globalvarpointer,-(A7)
  MOVE.w locvaroff,globalvarpointer
  LEA firstlocal,A2
  MOVE.b #1,newvariable
   BSR.w JL_0_8E5E
  CLR.b newvariable
  MOVE.w globalvarpointer,locvaroff
  MOVE.w (A7)+,globalvarpointer
RTS

 JL_0_8FA8:
  MOVEA.l A2,A3
  CMP.w #$2E,D0
   BEQ.w JL_0_8FCE
  CMP.w #$24,D0
   BNE.w JL_0_8FE8
  CMPI.l #newtype_string,$A(A3)
   BNE.w rongtypeerr
   BSR.w get1bytemain
BRA.w JL_0_8FE8

 JL_0_8FCE:
   BSR.w getparameter2
  LEA newtypebase,A2
   BSR.w findtype
   BNE.w notypeerr
  CMPA.l $A(A3),A2
   BNE.w rongtypeerr
 JL_0_8FE8:
  BTST #$0,flagmask+1
   BEQ.w JL_0_8FFE
  BTST #$0,$7(A3)
   BEQ.w pointerr

 JL_0_8FFE:
  MOVEA.l $A(A3),A2
RTS


JL_0_9004:
   TST.l D3                                                ;newtype >32kb  .w to .l
   BEQ.w JL_0_9042
   MOVE.l destpointer,loada
   ;TST.b fast
   ;BNE JL_0_9032
BRA JL_0_9032
                                                           ;??looks like dead code now??
  CMP.w #$9,D3                                             ;_addq_arrays
   BCC.w JL_0_9032
  MOVE.w d3,arrayoffset
  ANDI.w #$7,D3
  LSL.w #8,D3
  LSL.w #1,D3
  ANDI.w #$F1FF,addqa0
  OR.w D3,addqa0
  MOVE.w addqa0,D1
BRA.w writeword

 JL_0_9032:
  CMP.l #$7fff,d3                                          ;>32kb newtypes
  BGT longoffset
  MOVE.w D3,leaa0a0+2
  MOVE.w d3,arrayoffset
  MOVE.l leaa0a0,D1
  BSR.w writelong

 JL_0_9042:
RTS

 longoffset
   MOVE.w #$d5fc,d1
   BSR writeword
   MOVE.l d3,d1
   BSR.w writelong
RTS


zarrchk:
  Dc.w $b0ad,0000                                          ;cmp.l $0(A5),D0    ;nooptimize

arrchk2:
   BCS.w arrchk3                                           
   JSR $20000                                              ;jsr 0
arrchk3



 JL_0_9052:
  TST.b fast
  BEQ 'l1
   MOVEQ #0,d1                                             ;faster arrays
   MOVE.w regnum,d2
   MOVE.w d2,d1
   LSL.w #8,d1
   LSL.w #4,d1
   ADD.w d2,d1
   OR.l #$4c2d0000,d1
   TST.w varmode
   BEQ 'l1a
   BCLR #16,d1

 'l1a
   BSR writelong
   MOVE.w $4(A7),D1
   BSR.w writeword
   MOVE.w regnum,D1
  SUBQ.w #1,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$D080,D1
  OR.w regnum,D1
   BSR.w writeword
RTS

 'l1
  MOVE.w regnum,D2
  MOVE.w arrmul1(PC),D1
  OR.w D2,D1
  SUBQ.w #1,D1
   BSR.w writeword
  MOVE.w arrmul2(PC),D1
  OR.w D2,D1
  MOVE.w D2,D3
  SUBQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w writeword
  MOVE.w arrmul3(PC),D1
  MOVE.w D2,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w pokewda5s
  MOVE.w $4(A7),D1
  ADDQ.w #2,D1
   BSR.w writeword
  MOVE.w arrmul4(PC),D1
  MOVE.w D2,D3
  SUBQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w pokewda5s
  MOVE.w $4(A7),D1
   BSR.w writeword
  MOVE.w arrmul5(PC),D1
  OR.w D2,D1
  SUBQ.w #1,D1
   BSR.w writeword
  MOVE.w arrmul6(PC),D1
  OR.w D2,D1
  SUBQ.w #1,D1
   BSR.w writeword
  MOVE.w arrmul7(PC),D1
  OR.w D2,D1
  SUBQ.w #1,D1
  MOVE.w D2,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w writeword
  MOVE.w arrmul8(PC),D1
  MOVE.w D2,D3
  SUBQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w writeword
  MOVE.w regnum,D1
  SUBQ.w #1,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$D080,D1
  OR.w regnum,D1
BRA.w writeword


    ;code for doing long array calculations.
    ;d1.w=this subscript, d0.l=array offset
    ;
    ;do a x(a5).l * d1 + d0.l
    ;
arrmul1:   MOVE.l d0,-(a7)                                ;write array access
arrmul2:   MOVE  d0,d0
arrmul3:   MULU 0(a5),d0                                  ;mulu   x+2(a5),d1  ;lo*lo
arrmul4:   MULU 0(a5),d0                                  ;mulu   x(a5),d0    ;hi*lo
;
arrmul5:   SWAP d0
arrmul6:   CLR d0
arrmul7:   ADD.l d0,d0
arrmul8:   MOVE.l (a7)+,d0

;arraynew   Dc.l $4c150000                                  ; MULU.l 0(a5),d0  ;new arrayaccess

;------                                                  ;disassembled code begin
listcode1:  Dc.b $24,$6D :              Dc.b $00,$00       ;MOVEA.L $0000(A5),A2      ;pointer to start of array data
listcode2:  Dc.b $24,$6A,$FF,$E0                           ;MOVEA.L -$0020(A2),A2     ;pointer to current
listarfix:  Dc.b $50,$4A                                   ;ADDQ.W  #8,A2
;------                                                  ;disassembled code end

Even
calcvar:
    ;used to optimize this...no more!
    ;
;calcvar2:                                                 ;??looks like label not used??
    ;use a3 = var, a2 = type, flagmask = flags.
    ;
    ;if bit 15 of d2 then code has been generated for
    ;address of thing in a2. else d3=offset from a5
    ;for simple variable.
    ;
    ;d2 & ff=type. 0=struct address
    ;
    ;bit 14 of d2=1 if result is a pointer
    ;
  CLR.l lastoffset_org
  BTST #$1,$7(A3)
   BEQ.w calcvar__notarr
  MOVE.w notshared,D1
   BNE.w noarrerr
   BSR.w get1bytemain
  CMP.w #$29,D0
   BNE.w calcvar__notalist
  BTST #$0,$6(A3)
   BEQ.w nolisterr
  MOVE.w $4(A3),listcode1+2
  MOVE.l listcode1(PC),D1
   BSR.w pokela5s
  MOVE.l listcode2(PC),D1
   BSR.w writelong
  TST.b debugmode
   BEQ.w calcvar__nolrerr
    ;
    ;a2=0 error check
    ;
  MOVE.l A2,-(A7)
  MOVE.w #$C315,D1
   BSR.w Atokejsr
  MOVEA.l (A7)+,A2

 calcvar__nolrerr:
   MOVE.w listarfix(PC),D1                                 ;addq #8,a2
                ;skip node.
   BSR.w writeword
BRA.w calcvar__normalar


calcvar__listoff:   Ds.w 1


calcvar__notalist:
  CLR.w calcvar__listoff
  BTST #$0,$6(A3)
   BEQ.w calcvar__knop
  MOVE.w #$0008,calcvar__listoff                            ;adjust size of one element if list.

 calcvar__knop:
  MOVEM.l A2-A3,-(A7)
  MOVE.w varmode,-(A7)
  MOVE.w $8(A3),-(A7)                                       ;number of dims
  MOVE.w $4(A3),-(A7)                                       ;varoff
  MOVE.l A2,-(A7)
  MOVE.w flagmask,-(A7)
   ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
   BSR.w arreval
  MOVE.w (A7)+,flagmask
  MOVE.w $8(A7),varmode
  TST.b debugmode
   BEQ.w calcvar__noszchk
   ;BSR.w arrszchk                                        ;skip for dim >65536

 calcvar__noszchk:
  MOVEA.l (A7)+,A2
  MOVEQ.l #$04,D1
  BTST #$0,flagmask+1                                      ;pointer?
   BNE.b calcvar__domul                                          ;yes, then use 4 byte mul...
  MOVE.w $8(A2),D1

 calcvar__domul:
  ADD.w calcvar__listoff(PC),D1
  BSR.w JL_0_B6DE
  ADDQ.w #1,regnum

 calcvar__arloop:
  ADDQ.w #4,(A7)
  TST.w $4(A7)
   BEQ.w calcvar__isglob
  SUBQ.w #8,(A7)                                           ;range check local array

 calcvar__isglob:
  TST.b debugmode
   BEQ.w calcvar__noer1
  MOVE.w regnum,D1
  SUBQ.w #1,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w zarrchk(PC),D1
   BSR.w pokewda5s                                         ;cmp.l x(a5),D regat
  MOVE.w (A7),D1
   BSR.w writeword
  MOVE.l arrchk2(PC),D1
   BSR.w writelong
  MOVE.w #$C309,D1
   BSR.w Atokejsr

 calcvar__noer1:
  SUBQ.w #1,$2(A7)
   BEQ.w calcvar__ardone
  CMP.w #$2C,D0
   BNE.w syntaxerr
   TST.b fast
   BNE 'l1
   BSR.w arrevalchk
BRA 'l2

 'l1
  BSR arreval

 'l2
  MOVE.w $4(A7),varmode
  BSR.w JL_0_9052
BRA.w calcvar__arloop


calcvar__ardone:
  CMP.w #$29,D0
   BNE.w syntaxerr
  SUBQ.w #1,regnum
  ADDQ.w #6,A7
  MOVEM.l (A7)+,A2-A3
  MOVE.w $4(A3),movea5a0+2
  MOVE.l movea5a0,D1
   BSR.w pokela5s
  MOVE.w regnum,D1
  ORI.w #$D5C0,D1                                          ;add.l Dr,a2
   BSR.w writeword
  BTST #$0,$6(A3)
   BEQ.w calcvar__normalar
    ;
    ;addq #8,a2 to skip node.
    ;
  MOVE.w listarfix(PC),D1
   BSR.w writeword

 calcvar__normalar:
  BSR.w get1bytemain
    ;
    ;this shit added lately - after the major fucking crash!
    ;
  BTST #$0,$7(A3)
   BEQ.w calcvar__noppnt
  CMP.w #$5C,D0
   BNE.w calcvar__pmskip
  MOVE.w calcvar__pfix(PC),D1
   BSR.w writeword

 calcvar__noppnt:
  MOVE.w #$8000,D2
BRA.w calcvar__loopml

 calcvar__pmskip:
  MOVE.w #$C000,D2
BRA.w calcvar__loopml


;------                                                  ;disassembled code begin
calcvar__pfix:   Dc.b $24,$52                                   ;MOVEA.L (A2),A2
;------                                                  ;disassembled code end

Even
 calcvar__notarr:
  CMP.w #$28,D0
   BEQ.w noarrerr
  CMPI.l #$100,$4(A2)
   BCS.w calcvar__simpvar
  BTST #$0,$7(A3)
   BEQ.w calcvar__notap
    ;
    ;it's a pointer - is it a simple one?
    ;
  CMP.w #$5C,D0
   BEQ.w calcvar__notap
  MOVEQ.l #$00,D2
BRA.w calcvar__simpvar2

 calcvar__notap:
  MOVE.w #$8000,D2
  MOVE.w $4(A3),movea5a0+2
  MOVE.l movea5a0,D1
   BSR.w pokela5s                                         ;move.l x(a5),a2
                                                           ;check read pointer <=0
   TST.b debugmode
   BEQ.w 'skip
   MOVE.w #$c320,D1
   JSR Atokejsr

 'skip                                                     ;??looks liks double label??
 calcvar__loopml:
  MOVEQ.l #$00,D3

 calcvar__loop0:
  CMP.w #$5C,D0
   BNE.w calcvar__done
  CMPI.l #$100,$4(A2)
   BCS.w rongtypeerr
  MOVE.w D2,-(A7)
   BSR.w getparameter2
   BEQ.w syntaxerr
  ADDQ.w #4,A2
   BSR.w findvariable2
   BNE.w noofferr
  MOVE.w (A7)+,D2
  MOVEA.l A2,A3                                             ;pointer to offset
  MOVEA.l $A(A3),A2                                         ;pointer to type
  MOVEQ #0,d1
  MOVE.w 4(a3),d1
  ADD.l d1,d3
  ;ADD.w $4(A3),D3                                          ;offset for newtype
  MOVE.l A3,lastoffset_org
  CMP.w #$5B,D0
   BNE.w calcvar__realdone
  BTST #$1,$7(A3)
   BEQ.w rongtypeerr
   BSR.w JL_0_9004
  MOVEM.l A2-A3,-(A7)
  MOVE.w varmode,-(A7)
  MOVE.l lastoffset_org,-(A7)
  MOVE.w pusha2,D1
   BSR.w writeword
  MOVEQ.l #$03,D2                                          ;was 2 >32kb types
  MOVE.l destpointer,deststore
   BSR.w eval
  CMP.w #$5D,D0
   BNE.w syntaxerr
  TST.b fast                                               ;a2,-(a7) array
  BEQ calcvar__loop0_l10
  CNIF #optibreak
    ILLEGAL
  CEND
  MOVE.l destpointer,d1
  SUB.l deststore,d1
  CMP.l #4,d1
  BNE calcvar__loop0_l10
  MOVE.l destpointer,a4
  MOVE.l -4(a4),-6(a4)
  SUBQ.l #2,destpointer
  CLR.l imm_addr
  CLR.l load_var_addr
BRA calcvar__loop0_l20

 calcvar__loop0_l10:
  MOVE.w pulla2,D1
   BSR.w writeword

 calcvar__loop0_l20:
  MOVE.l (A7)+,lastoffset_org
  MOVE.w (A7)+,varmode
  MOVEM.l (A7)+,A2-A3
    ;
    ;[] ***** error checking here! *****
    ;
    ;8(a3) = how many we can handle. special case for 0!
    ;
  TST.w debugmode
   BEQ.b calcvar__nobchk
  MOVE.w $8(A3),D1
   BEQ.b calcvar__nobchk                                   ;no [0] checks!
    ;
    ;ok, check regat<8(a3)
    ;
  MOVE.w D1,brchkcode+2
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w brchkcode0(PC),D1
  MOVE.w D1,brchkcode
  MOVE.l brchkcode(PC),D1
   BSR.w writelong
  MOVE.l brchkcode+4(PC),D1
   BSR.w writelong
  MOVE.w brchkcode+8(PC),D1
   BSR.w writeword

 calcvar__nobchk:
  MOVEQ.l #$04,D1
  BTST #$0,$7(A3)
   BNE.w calcvar__dothemul
  MOVE.w $8(A2),D1

 calcvar__dothemul:
  BSR.w JL_0_B6DE
  MOVE.w addrega2,D1
  OR.w regnum,D1
   OR.w #$100,d1                                           ;>32kb types
   BSR.w writeword
   BSR.w get1bytemain
  MOVEQ.l #$00,D3
  MOVE.w #$8000,D2

 calcvar__realdone:
  BTST #$0,$7(A3)
   BNE.w calcvar__pointer
BRA.w calcvar__loop0


 calcvar__pointer:
 CMP.w #$5C,D0
   BNE.w calcvar__done3
  TST.w D3
   BNE.w calcvar__pskip
  MOVE.w movea0,D1
   BSR.w writeword
BRA.w calcvar__pmore

 calcvar__pskip:
  MOVE.w D3,movea0a0+2
  MOVE.l movea0a0,D1
   BSR.w writelong

 calcvar__pmore:
  BTST #$2,$7(A3)
   BEQ.w calcvar__loopml
  MOVE.l adda0a0,D1
   BSR.w writelong
BRA.w calcvar__loopml

 calcvar__done3:
  BSET #$E,D2
  BTST #$2,$7(A3)
   BNE.w calcvar__done
  BSET #$D,D2

 calcvar__done:
  CMPI.l #$100,$4(A2)
   BCC.w calcvar__done2
  MOVE.b $7(A2),D2

 calcvar__done2:
BRA.w JL_0_9004

 calcvar__simpvar:
  MOVE.w $6(A2),D2

 calcvar__simpvar2:
  MOVE.w $4(A3),D3
  BTST #$0,$7(A3)
   BEQ.w calcvar__nopoint
  BSET #$E,D2

 calcvar__nopoint:
RTS


;------                                                  ;disassembled code begin
brchkcode0:  Dc.b $B0,$7C,$00,$00                          ;CMP.W   #$0000,D0
brchkcode:   Dc.b $B0,$7C :             Dc.b $00,$00       ;CMP.W   #$0000,D0
             Dc.b $65,$04                                  ;BCS.B   brchkcode__ok
             Dc.b $70,$02                                  ;MOVEQ   #$02,D0
             Dc.b $4E,$40                                  ;TRAP    #00
brchkcode__ok:
;------                                                  ;disassembled code end


;-----------Poking to Object code stuff-------------------;

pokewda5s:
  TST.w varmode
   BEQ.w writeword
  BCLR #$0,D1
BRA.w writeword

pokewda5d:                                                 ;??looks like not used??
  TST.w varmode
   BEQ.w writeword
  BCLR #$9,D1
BRA.w writeword

pokela5d:
  TST.w proceduremode
   BEQ.w writelong
  BCLR #$19,D1
BRA.w writelong

pokela5s:
  TST.w varmode
  BEQ.w writelong
  BCLR #$10,D1

 writelong:                                                ;pokel org source
  ADDQ.l #1,destpointer
  BCLR #$0,destpointer+3
  MOVEA.l destpointer,A4
  CMPA.l destbufferend,A4
   BCC.w writeword__overa
  MOVE.l D1,(A4)+

 writeword__msa:
  MOVE.l A4,destpointer
  CMPA.l bigpc(PC),A4
   BHI.w writeword__nbp
RTS

writeword__overa:
  MOVE.w #$FFFF,dontwrite                                  ;#-1 org source
  CLR.b fast
  CLR.b fpu
  CLR.b iee
  ADDQ.w #4,A4
BRA.w writeword__msa

;RTS                                                        ;??Looks like unneeded code??


.writeword:                                                ;pokewd org source  ;poke d1.w into pc - not an opcode
  ADDQ.l #1,destpointer
  BCLR #$0,destpointer+3
  MOVEA.l destpointer,A4
  CMPA.l destbufferend,A4
   BCC.w writeword__over
  MOVE.w D1,(A4)+

 writeword__ms:
  MOVE.l A4,destpointer
  CMPA.l bigpc(PC),A4
   BHI.w writeword__nbp
RTS

.writeinstruction:
  ADDQ.l #1,destpointer
  BCLR #$0,destpointer+3
  MOVEA.l destpointer,A4
  CMPA.l destbufferend,A4
   BCC.w writeword__over
  MOVE.w D1,(A4)+
  MOVE.l A4,destpointer
  CMPA.l bigpc(PC),A4
   BHI.w writeword__nbp
RTS

 writeword__nbp:
  TST.w cfetchmode
  BNE.w writeword__nbp2
  MOVE.l A4,bigpc

 writeword__nbp2:
RTS

 writeword__over:
  MOVE.w #$FFFF,dontwrite                                  ;#-1 org source
  ADDQ.w #2,A4
  CLR.b fast
  CLR.b fpu
  CLR.b iee
BRA.w writeword__ms


writebyte:                                                 ;pokebyte org source
  MOVEA.l destpointer,A4
  CMPA.l destbufferend,A4
   BCC.w writebyte__over
  MOVE.b D1,(A4)+

 writebyte__ms:
  MOVE.l A4,destpointer
  CMPA.l bigpc(PC),A4
   BHI.w writebyte__nbp
RTS

 writebyte__nbp:
  TST.w cfetchmode
   BNE.w writebyte__nbp2
  MOVE.l A4,bigpc

 writebyte__nbp2:
RTS

writebyte__over:
  MOVE.w #-1,dontwrite
  ADDQ.w #1,A4
  CLR.b fast
  CLR.b fpu
  CLR.b iee
BRA.w writebyte__ms


bigpc:   Ds.l 1


pokecode:                                                  ;a0=start of code to poke, a1=end
  MOVE.w (A0)+,D1
  BSR.w writeword

 pokecode__loop:
    CMPA.l A1,A0
    BCC.w pokecode__done
      MOVE.w (A0)+,D1
      BSR.w writeword
BRA.w pokecode__loop

 pokecode__done:
RTS

pokecode2:
  MOVE.w (A0)+,D1
  BSR.w writeword
  CMPA.l A1,A0
  BCS.w pokecode2
RTS

;-----------End of poking to Object code------------------;


convert_byte_to_word:                                                ;byte to word
  TST.b iniffcommand
  BEQ 'l1
    MOVE.w #$4880,D1
    OR.w regnum,D1
    BSR writeword

 'l1
RTS

 convert_byte_to_long:
  BSR.w convert_byte_to_word

 convert_word_to_long:                                               ;word to long word_to_fpu
  TST.b iee
  BEQ 'old
  CMP.b #5,d2
  BEQ wtof

 'old
  MOVE.w #$48C0,D1
  OR.w regnum,D1
BRA.w writeword

 wtof
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2005000,d1
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
BRA writelong


convert_byte_to_quick:
  BSR.w convert_byte_to_word

 convert_word_to_quick:
  MOVE.w #$4840,D1
  OR.w regnum,D1
   BSR.w writeword
  MOVE.w #$4240,D1
  OR.w regnum,D1
BRA.w writeword


 ltof                                                      ;long to fpu
  CMP.w #$ffdc,d1
  BNE 'negfpu
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2004000,d1
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
BRA writelong


 'negfpu
  MOVEQ #0,d1
  MOVE.w regnum,d1                                         ;fpu neg
  ASL.l #7,d1
  OR.l #$f200001a,d1
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #8,d0
  ASL.l #2,d0
  OR.l d0,d1
  MOVE.l (a7)+,d0
BRA writelong

convert_byte_to_float:
   TST.b iee
   BNE wtof
   BSR.w convert_byte_to_long

 JL_0_9600:
   MOVE.w #$FFDC,D1

 JL_0_9604:
   TST.b iee
   BNE ltof
   MOVE.w D1,libjsr+2
   BSR.w JL_0_AD40
  MOVE.l D4,D1
   BSR.w JL_0_AD38
  MOVE.w #$C900,D1
   BSR.w Atokejsr
   BSR.w JL_0_A352
  MOVE.l libjsr,D1
   BSR.w writelong
   BSR.w JL_0_A36E
  MOVE.l D5,D1
BRA.w JL_0_AD38

JL_0_9634:
RTS

convert_word_to_byte:
  MOVE.w #$C317,D1
  TST.b typecheck
  BEQ 'l1
   TST.b notypecheck
   BNE 'l1
   TST.l lasttoken
   BEQ typeerror

 'l1                                                       ;??looks like double label??
 JL_0_963A:
  TST.b debugmode
   BEQ.w JL_0_9696
  BTST #$7,overflowcheck
   BEQ.w JL_0_9696
  TST.w cfetchmode
   BNE.w JL_0_9696
  TST.w regnum
   BEQ.w JL_0_968A
  MOVE.w D1,-(A7)
  MOVE.w JL_0_9698(PC),D1
   BSR.w writeword
  MOVE.w regnum,D1
  OR.w L_0_969C(PC),D1
   BSR.w writeword
  MOVE.w (A7)+,D1
   BSR.w JL_0_968A
  MOVE.w L_0_969A(PC),D1
BRA.w writeword


JL_0_968A:
  MOVEM.l D0-D7/A0-A6,-(A7)
   BSR.w Atokejsr
  MOVEM.l (A7)+,D0-D7/A0-A6

 JL_0_9696:
RTS

JL_0_9698:
  MOVE.l D0,-(A7)

 L_0_969A:
  MOVE.l (A7)+,D0

 L_0_969C:
  MOVE.l D0,D0

 convert_word_to_float:
  BSR.w convert_word_to_long
  TST.b iee
  BEQ 'old
  CMP.b #5,d2
  BNE 'old
RTS

 'old
BRA.w JL_0_9600


convert_long_to_byte:
  MOVE.w #$C316,D1
  TST.b typecheck
  BEQ 'l1
  TST.b peekaddrsize
  BNE 'l1
  TST.b notypecheck
  BNE 'l1
  TST.l lasttoken
  BEQ typeerror

 'l1
BRA.w JL_0_963A


convert_long_to_word:
  MOVE.w #$C318,D1
;  TST.b typecheck
;  BEQ 'l1
;  TST.b peekaddrsize
;  BNE 'l1
;  TST.b notypecheck
;  BNE 'l1
;  TST.l lasttoken
;  BEQ typeerror
;
; 'l1
BRA.w JL_0_963A


convert_long_to_quick:
  MOVE.w #$C318,D1
  TST.b typecheck
  BEQ 'l1
  TST.b notypecheck
  BNE 'l1
  TST.l lasttoken
  BEQ typeerror

 'l1
  BSR.w JL_0_963A
BRA.w convert_word_to_quick


convert_long_to_float:
BRA.w JL_0_9600


JL_0_96C6:
RTS


convert_quick_to_byte:
  MOVE.w #$C319,D1
  TST.b typecheck
  BEQ 'l1
  TST.b notypecheck
  BNE 'l1
  TST.l lasttoken
  BEQ typeerror

 'l1
  BSR.w JL_0_963A

 JL_0_96D0:
  MOVE.w #$4240,D1
  OR.w regnum,D1
  BSR.w writeword
  MOVE.w #$4840,D1
  OR.w regnum,D1
BRA.w writeword


 convert_quick_to_word:
BRA.w JL_0_96D0


 convert_quick_to_long:
  BSR.w JL_0_96D0
BRA.w convert_word_to_long


 qtof                                                      ;quick to fpu
 'l2                                                       ;??Looks like double label??
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2004000,d1
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
  BSR writelong
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f23c4423,d1                                     ;fmul.s #1/65536,fpreg
  OR.w d0,d1
  BSR writelong
  MOVE.l #$37800000,d1
  BSR writelong
RTS


 convert_quick_to_float:
  TST.b iee
  BNE qtof
  MOVE.w #$D300,D1

 JL_0_96FC:
  MOVE.w D1,-(A7)
   BSR.w JL_0_AD40
  MOVE.l D4,D1
   BSR.w JL_0_AD38
   BSR.w JL_0_A352
  MOVE.w (A7)+,D1
   BSR.w Atokejsr
   BSR.w JL_0_A36E
  MOVE.l D5,D1
BRA.w JL_0_AD38


JL_0_971C:
RTS

convert_float_to_byte:
  TST.b typecheck
  BEQ 'l1
  TST.b notypecheck
  BNE 'l1
  TST.l lasttoken
  BEQ typeerror

'l1
  TST.b iee
  BNE ftol
  MOVE.w #$C31A,D1
  BSR.w JL_0_963A
  BSR.w JL_0_974A
BRA.w convert_long_to_byte


JL_0_972E:
RTS

convert_float_to_word:
  TST.b typecheck
  BEQ 'l1
  TST.b notypecheck
  BNE 'l1
  TST.l lasttoken
  BEQ typeerror

 'l1
  TST.b iee
  BNE ftol
  MOVE.w #$C31B,D1
  BSR.w JL_0_963A
  BSR.w JL_0_974A
BRA.w convert_long_to_word


 JL_0_9740:
RTS

convert_float_to_long:
  TST.b iee
  BNE ftol
  MOVE.w #$C31C,D1
  BSR.w JL_0_963A

 JL_0_974A:
  MOVE.w #$FFE2,D1
BRA.w JL_0_9604

 ftol                                                      ;fpu to long
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2006000,d1
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
  MOVE.l (a7)+,d0
BRA writelong


ftoq                                                       ;fpu to quick
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
  MOVE.l #$f23c4023,d1
  MOVE.w regnum,d0
  ASL.l #7,d0
  OR.l d0,d1
  BSR writelong
  MOVE.l #$00010000,d1
  BSR writelong
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2006000,d1
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
  BSR writelong
  MOVE.l (a7)+,d0
RTS


JL_0_9752:
RTS


convert_float_to_quick:
  TST.b iee
  BNE ftoq
  MOVE.w #$C31B,D1
  BSR.w JL_0_963A
  MOVE.w #$D301,D1
BRA.w JL_0_96FC



string_to_long:                                                ;stringtolong
   TST.l lasttoken
   BNE 'l1
BRA error_convert_types

 'l1
  CMP.b #2,optistring
  BEQ JLrts
  MOVE.w stol,D1
  BSR.w writeword
  CMPI.w #$2,sbgot
  BCS.w sbtolong
  MOVE.w ceos(PC),D1
  BSR.w writeword

 'l10
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  CMPI.w #$2,sbgot
  BCS.w JL_0_98E8
  MOVE.w a2offset,D3
  SUB.w thisstuse,D3
  CMP.w #$6,D3
  BNE.w JL_0_98D4b
  OR.w movestst2,D1
  BSR.w writeword
  LEA movestst2+2,A0
  LEA movestst2f,A1
BRA.w pokecode2


JL_0_98D4b:                                                ;OS call 2 strings fix
  OR.w movea7dn,D1
  BSR.w writeword
  MOVE.l #0,D1
BRA.w writeword


JL_0_9770:
  ADDQ.w #1,fuckpos
  BSR.w writeconvertcode
  SUBQ.w #1,fuckpos
 JLrts
RTS


writeconvertcode:                                          ;convtype org source   ;convert type d3 to d2
  MOVE.w D3,D1
  SUBQ.w #1,D1
  MULU #$7,D1
  ADD.w D2,D1
  SUBQ.w #1,D1
  LSL.w #2,D1
  LEA convtable,A0
  MOVE.l $0(A0,D1.W),D1
  BEQ.w JL_0_97A2
    MOVEA.l D1,A0
    CMP.b #$ff,d3
    BEQ JL_0_97A2
JMP (A0)

 JL_0_97A2:
RTS


usedfrom:  Ds.l 1


getparameter:                                              ;getvname org source
    ;transfer chars to namebuff. set flagmask according
    ;to array/pointer etc status
    ;
  CMP.w #"\",D0
  BNE.w JL_0_97C2
    CMP.b #"\",(a5)
    BNE 'first
      MOVE.l A5,usedfrom
      LEA path2,A5
BRA 'g1

 'first
    SUBQ.w #1,A5
  MOVE.l A5,usedfrom
  LEA usedpath,A5                                          ;read path

 'g1
  BSR.w get1bytemain

 JL_0_97C2:
  CLR.w flagmask
  CMP.w #$2A,D0
   BNE.w JL_0_983A
  MOVE.w #$0001,flagmask
 JL_0_97D8:
   BSR.w getparameter2

 JL_0_97DC:
   BEQ.w syntaxerr
  CMP.w #$28,D0
   BEQ.w JL_0_9830
  CMP.w #$2E,D0
   BEQ.w JL_0_980C
  CMP.w #$24,D0
   BNE.w JL_0_9838
  ORI.w #$8,flagmask
   BSR.w storeloc
   BSR.w get1bytemain
BRA.w JL_0_9822


JL_0_980C:
  BSR.w storeloc
  MOVE.w D2,-(A7)
  LEA namebuff2,A1
   BSR.w makename3
   BEQ.w syntaxerr
  MOVE.w (A7)+,D2

 JL_0_9822:
   MOVE.w D0,D1
   BSR.w resloc
   CMP.w #$28,D1
   BNE.w JL_0_9838

JL_0_9830:
  ORI.w #$2,flagmask

JL_0_9838:
RTS


JL_0_983A:
  CMP.w #$40,D0
   BNE.w JL_0_984E
  MOVE.w #$0005,flagmask
BRA.w JL_0_97D8


JL_0_984E:
  BSR.w makename2
BRA.w JL_0_97DC


dopusha3:
  MOVE.w #$FED3,D1
   BSR.w uselib
  LEA pusha3,A0
  LEA pusha3f,A1
BRA.w pokecode


dopulla3:
  MOVE.w #$FED3,D1
   BSR.w uselib
  LEA pulla3,A0
  LEA pulla3f,A1
BRA.w pokecode


;------                                                  ;disassembled code begin
ceos:   Dc.b $42,$1B                                       ;CLR.B   (A3)+             ;*!
;------                                                  ;disassembled code end

Even
sbtolong:                                                 ;make sbase into a long
    CMP.b #2,optistring
   BEQ 'l10
   MOVE.w ceos(PC),D1
   BSR.w writeword                                         ;clr.b (a3)

 'l10
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  CMPI.w #$2,sbgot
   BCS.w JL_0_98E8
  MOVE.w a2offset,D3                                       ;stackuse,d3 org source
  SUB.w thisstuse,D3
  CMP.w #$6,D3
   BNE.w JL_0_98D4
  OR.w movestst2,D1
   BSR.w writeword
  LEA movestst2+2,A0
  LEA movestst2f,A1
BRA.w pokecode2


JL_0_98D4:
   OR.w movea7dn,D1
   BSR.w writeword
  MOVE.l movea7dn+2,D1
;  CNIF #more6string
;    MOVE.w #$0008,d1
;    BSR writeword
;    MOVE.w #$2f6f,d1                                       ;native move.l 4(a7),8(a7)
;    BSR writeinstruction
;    MOVE.l #$00040008,d1
;    BSR writelong
;    MOVE.w #$588f,d1                                       ;native addq.l #4,a7
;    BSR writeword
;  RTS
;  CEND
  BSR writelong

 CNIF #more6string
   CMP.w #6,regnum
   BEQ 'l1
   TST.w stackpar
   BNE 'l1
   TST.b funcparloop
   BEQ 'l1
   MOVE.l #$48780000,d1
   BSR writelong

 'l1
 CEND
RTS


JL_0_98E8:
  CNIF #more6string
     MOVE.l d1,-(a7)
     CMP.w #6,regnum
     BEQ 'l1
     TST.w stackpar
     BNE 'l1
     TST.b funcparloop
     BEQ 'l1
     MOVE.l #$48780000,d1
     BSR writelong

    'l1
     MOVE.l (a7)+,d1
  CEND
   OR.w movestdn,D1
   BSR.w writeword
  MOVE.w #$FED3,D1
   BSR.w uselib
  MOVE.w $A(A1),D1
BRA.w writeword


unknown:    Ds.w 1

;------                                                  ;disassembled code begin
somecode:   Dc.b $0C,$80,$00,$01,$00,$00                   ;CMPI.L  #$00010000,D0
somecode2:  Dc.b $65,$00,$00,$08                           ;BCS.W   codeisok
            Dc.b $4E,$B9,$00,$00,$00,$00                   ;JSR $00000000
codeisok:
;------                                                  ;disassembled code end


arrevalchk:
  TST.b debugmode
  BEQ.w sharreval
 BSR.w arreval

 arrszchk:
  MOVE.w somecode(PC),D1
  OR.w regnum,D1
   BSR.w writeword
  MOVEQ.l #$01,D1
  SWAP D1
   BSR.w writelong
  MOVE.l somecode2(PC),D1
   BSR.w writelong
  MOVE.w #$C309,D1
BRA.w Atokejsr


sharreval:
  MOVEQ.l #$02,D2
  MOVEQ.l #$00,D1
  MOVEQ.l #$00,D3
BRA.w maineval2


arreval:
  MOVEQ.l #$03,D2
  MOVEQ.l #$00,D1
  MOVEQ.l #$00,D3
BRA.w maineval2


bakpevalu:                                                 ;??looks like labe not used??
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  MOVEQ.l #-$01,D1
  MOVEQ.l #-$01,D3
BRA.w peval


bakpeval:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

 peval:
  MOVEQ.l #-$01,D1
  MOVEQ.l #$00,D3
BRA.w maineval


bakevalu:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  MOVEQ.l #$00,D1
  MOVEQ.l #-$01,D3
BRA.w maineval


evalu2:
  MOVEQ.l #$01,D1
  MOVEQ.l #-$01,D3
BRA.w maineval


bakeval:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

 eval:
  MOVEQ.l #$00,D1                                        ;no push
  MOVEQ.l #$00,D3

 maineval:
    ;CLR.b isconstantvalue
    ;CLR.l lastconstantvalue
                                                                                                                                                                                                                                                        
    ;Big Evaluation routine.....
    ;
    ;d2 = type to collect - 0 if unknown
    ;
    ;d3 = 0 if conv to original type
    ;
    ;d1 = push result flag, 0 = no push, < 0 = push result
    ;     > 0 = push type when known
    ;
    ;result will be pushed anyway if using reg d6+
    ;
    ;if getting a string, then strings len is on stack
    ;(a long), and a3 points at arse end of string
    ;while D(regat) points to start of string
    ;
   CMPI.w #$6,regnum
   BCS.w maineval2
   MOVEQ #0,d1
   MOVE.l destpointer,a4

   CMPA.l destbufferend,A4
   BCC.w maineval__l2

   CMP.w #$2f0a,-2(a4)                                    ;bug is a move.l a2,-(a7) before (show temp calc)?
                                                          ;then put not to stack
   BNE maineval__l2
;   JSR linemessage
;   TST.l result
;   BEQ maineval__l2
BRA maineval__l1

 maineval__l2
  MOVEQ.l #-$01,D1

 maineval__l1
  MOVE.w #$0006,regnum                                     ;write a func par To stack

 maineval2:
  MOVE.w thisstuse,-(A7)
  MOVE.w a2offset,thisstuse
  MOVE.w stackpar,-(A7)
  MOVE.w D1,stackpar
  MOVE.w sbgot,-(A7)
  CLR.w sbgot
  MOVE.w unknown(PC),-(A7)
  MOVE.w D3,unknown
  MOVE.w D2,-(a7)
  MOVE.w d2,mode
   BSR.w eval3
  MOVE.w (a7)+,d3
   BEQ.w maineval__noconv
  MOVE.w unknown(PC),D1
   BNE.w maineval__noconv
  EXG.l D2,D3
   MOVE.l a2,-(a7)
   TST.b curtemplabel
   BEQ maineval2__l10
   MOVE.l asmbuff,a2
   CMP.w #$c,$8(a2)
   BEQ maineval2__l20
   CMP.w #$d,$8(a2)
   BEQ maineval2__l20

 maineval2__l10:
  CMP.w d2,d3
  BEQ maineval2__l20
  BSR.w writeconvertcode
  CLR.b doimmediate

 maineval2__l20:
  MOVE.l (a7)+,a2

 maineval__noconv:
  MOVE.w (A7)+,unknown
  MOVE.w stackpar,D1
   BEQ.w maineval__skipme
   BMI.w maineval__skipme
    ;
    ;push the type got.
    ;
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  CMP.w #$7,D2
   BNE.w maineval__hi1
   CMP.b #2,optistring
   BEQ maineval__hi1a
  MOVE.w D1,-(A7)
  OR.w getstlen,D1
   BSR.w writeword
  MOVE.w (A7)+,D1

 maineval__hi1:
  ADDQ.w #2,a2offset                                        ;lib mode to stack
  ;ORI.w #$7000,D1
  ;ADDI.w #$200,D1                                          ;moveq #x,dREGAT+1
  ;OR.w D2,D1
  MOVE.w #$3f3c,d1
   BSR.w writeword
  ;move.w pushut(PC),D1
  ;or.w regnum,D1
  ;addq.w #1,D1
  MOVE.w d2,d1
  MOVE.w d1,libmode
   BSR.w writeword
  CMP.w #$7,D2
   BNE.w maineval__skipme
  MOVE.w putstlen,D1
  OR.w regnum,D1
   BSR.w writeword

 maineval__skipme:
   CMP.w #$7,D2
   BNE.w maineval__notst
; CNIF #more6string
;   CMP.w #6,regnum
;   BEQ maineval__skipme_l1
;   TST.b funcparloop
;   BEQ maineval__skipme_l1
;   MOVE.l #$48780000,d1
;   BSR writelong
;
; maineval__skipme_l1:
; CEND
   CMP.b #2,optistring
   BEQ maineval__skipme_l10
   ADDQ.w #4,a2offset                                      ;a length on da stack.....
   BSR.w sbtolong
BRA.w maineval__notst2

 maineval__skipme_l10:
 CNIF #more6string
    CMP.w #6,regnum
    BEQ maineval__skipme_l10_l1
    TST.b funcparloop
    BEQ maineval__skipme_l10_l1
    MOVE.l #$48780000,d1
    BSR writelong
   maineval__skipme_l10_l1:
 CEND
BRA.w maineval__notst2

 maineval__hi1a
  ADDQ.w #2,a2offset
BRA maineval__skipme

 maineval__notst:
  CMPI.w #$2,sbgot
   BCS.w maineval__notst2                                         ;correct stack
  MOVE.w ststfix(PC),D1
   BSR.w writeword

 maineval__notst2:
  MOVE.w (A7)+,sbgot
  MOVE.w stackpar,D1
   BPL.w maineval__skip
   CMP.b #7,d2
   BEQ maineval__notst2_l1
  TST.b funcparloop
  BEQ maineval__notst2_l1
  CMP.b #5,d2
  BNE maineval__notst2_skip
  TST.b fpu
  BEQ maineval__notst2_skip
  MOVE.l #$f2066700,d1                                     ;fmove.s fp6,d6
  JSR writelong

 maineval__notst2_skip:
  MOVE.w #$c4ff,d1                                         ;savetemp+regnum
  ADD.w parnum,d1
  JSR Atokejsr
   TST.w dontwrite
   BNE maineval__notst2_l1
   MOVE.l data1start,d1
   MOVE.l destpointer,a4
   ADD.l d1,-4(a4)
   MOVE.l destpointer,d1
   SUBQ.l #4,d1
   SUB.l destbufferstart,d1
   MOVE.l d2,-(a7)
   MOVE.l d1,d2
   JSR addhunkoffset
   MOVE.l (a7)+,d2
BRA maineval__skip

 maineval__notst2_l1:
  ADDQ.w #2,a2offset
  MOVE.w pushd0wd,D1
  CMP.w #$3,D2                                             ;write parameter to stack
   BCS.w maineval__ok
  ADDQ.w #2,a2offset
  TST.b fpu
  BEQ maineval__notst2_nofpu
  CMP.w #5,d2
  BNE maineval__notst2_nofpu
  MOVEQ #0,d1
  MOVE.w regnum,d1
  ASL.l #7,d1
  OR.l #$f2276400,d1
  BSR writelong
BRA maineval__skip

 maineval__notst2_nofpu:
  MOVE.w pushd0l,D1

 maineval__ok:
   OR.w regnum,D1
   BSR.w writeword                                         ;nat

 maineval__skip:
  MOVE.w (A7)+,stackpar
  MOVE.w (A7)+,thisstuse
RTS


thisstuse: Ds.w 1

;------                                                  ;disassembled code begin
ststfix:   Dc.b $58,$4F                                    ;ADDQ.W  #4,A7
pushut:    Dc.b $3F,$00                                    ;MOVE.W  D0,-(A7)
;------                                                  ;disassembled code end
Even

eval3:
  BSR.w eval4
  SUBI.l #$12,forthsp
RTS


eval4:
  MOVEQ.l #$01,D1
   ;BSR.w pushprec
      MOVEA.l precsp(PC),A1
      MOVE.l A0,(A1)+
      MOVE.w D1,(A1)+
      MOVE.l A1,precsp
   BSR.w calcloop
  TST.w D1
   BNE.w syntaxerr
  SUBQ.l #6,precsp                                      ;pop the prec set up
RTS


calcloop:                                                  ;eval5 org source

  BSR.w JL_0_9C24

 JL_0_9AFE:
  MOVEA.l precsp(PC),A1
  CMP.w -(A1),D1
   BHI.w JL_0_9B0A
RTS


JL_0_9B0A:
  ;BSR.w pushprec
  MOVEA.l precsp(PC),A1
  MOVE.l A0,(A1)+
  MOVE.w D1,(A1)+
  MOVE.l A1,precsp
  MOVE.w D2,-(A7)
  ADDQ.w #1,regnum
   BSR.w calcloop               ;constant optimizer
  SUBQ.w #1,regnum
  MOVE.w (A7)+,D3
  MOVEM.l D1/A0,-(A7)
   BEQ.w JL_0_9B2E
   BSR.w JL_0_9770

 JL_0_9B2E:
  BSR.w popprec
  BSR.w writecode
  MOVEA.l forthsp(PC),A0
  MOVE.w -$2(A0),D1
  OR.w -$14(A0),D1
  MOVE.w D1,-$14(A0)
   BNE.w JL_0_9C0E
  MOVE.w dontwrite,D1
   BNE.w JL_0_9C0E
   MOVEA.l -$24(A0),A0

 !newcalc
   BEQ 'l10
   MOVEA.l forthsp(PC),A0
   MOVE.w -$18(A0),lasta6
   MOVE.l -$1C(A0),lasta6
   MOVEA.l -$24(A0),A0
   MOVE.l A0,destpointer
   MOVEA.l _mathffpbase,A6
   MOVEA.l ffplib,A1
BRA cont1

'l10
  MOVE.w #$2000,D1
  OR.w regnum,D1
   BSR.w writeword
    MOVEQ #0,d1
    MOVE.w regnum,D1
    ASL.l #8,d1
    ASL.l #2,d1
    OR.l #$f2000000,d1
    BSR writelong
  MOVE.w #$4E75,D1
   BSR.w writeword
  MOVE.w -$18(A0),lasta6
  MOVE.l -$1C(A0),lasta6
  MOVEA.l -$24(A0),A0
  MOVE.l A0,destpointer
  MOVEM.l D2/A5,-(A7)
  MOVEA.l _mathffpbase,A6
  MOVEA.l ffplib,A1
  MOVE.w $A(A1),D0
  LEA _mathffpbase,A5
  SUBA.w D0,A5
  JSR Aclearcache                                          ;neg +
  CLR.l load_var_addr
  CLR.l imm_addr
  TST.w dontwrite
  BNE '1
  JSR (A0)                                                 ;calc constant inline expression

 '1
  MOVEM.l (A7)+,D2/A5

 cont1:
  MOVE.b d2,isconstantvalue
  MOVE.l d0,lastconstantvalue
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1
  CMP.w #$3,D2
   BCC.w JL_0_9BCE
  ORI.w #$1000,D1
   BSR.w writeword
  MOVE.w D0,D1
   BSR.w writeword
BRA.w JL_0_9BD8


JL_0_9BCE:
  TST.b iee                                                ;fpu constant
  BEQ 'l10
  CMP.b #5,d2
  BNE 'l10
  MOVEQ #0,d1
  MOVE.w regnum,D1
  ASL.l #7,d1
  OR.l #$f23c5400,d1
  BSR writelong
  SUBQ.l #8,a7
  fmove.d fp0,0(a7)
  MOVE.l (a7)+,d1
  BSR writelong
  MOVE.l (a7)+,d1
  BSR writelong
BRA JL_0_9BD8

 'l10
  BSR.w writeword
  MOVE.l D0,D1
  BSR.w writelong

 JL_0_9BD8:
  MOVEA.l forthsp(PC),A0
  MOVEA.l -$20(A0),A3
  MOVEA.l hunkoffsetbase,A2
  MOVE.l A3,hunkoffsetbase
  MOVEA.l _execbase,A6

 JL_0_9BF0:
  CMPA.l A3,A2
  BEQ.w JL_0_9C0A
  SUBQ.l #1,hunkoffsetcounter
  MOVEA.l A2,A1
  MOVEA.l (A2),A2
  MOVEQ.l #$8,D0
  MOVE.l mempool2,a0
   JSR _FreePooled(A6)
BRA.w JL_0_9BF0


JL_0_9C0A:
  MOVEA.l forthsp(PC),A0

 JL_0_9C0E:
  LEA -$12(A0),A0
  MOVE.l A0,forthsp
  MOVEM.l (A7)+,D1/A0
  BSR.w reget
BRA.w JL_0_9AFE


JL_0_9C24:
  BSR.w JL_0_A386
  TST.w d0
  BEQ JL_0_9C42
  CMP.b #",",d0
  BEQ JL_0_9C42
  CMP.b #"@",d0                                            ;expandline @@
  BEQ JL_0_9C42
  LEA operators,A0

 JL_0_9C2E:
   TST.w (A0)
   BEQ.w JL_0_9C42
  CMP.w (A0),D0
   BEQ.w JL_0_9C46a
  LEA $20(A0),A0
BRA.w JL_0_9C2E


JL_0_9C42:
  MOVEQ.l #$00,D1
RTS

JL_0_9C46a                                                 ;??Looks like double label??
JL_0_9C46:
  CMP.w #$3C,D0
   BNE.w JL_0_9C70
   BSR.w get1bytemain
  CMP.w #$3D,D0
   BNE.w JL_0_9C64
  LEA ople,A0
BRA.w JL_0_9CCA


JL_0_9C64:
  CMP.w #$3E,D0
   BNE.w JL_0_9C96
BRA.w JL_0_9CC4


JL_0_9C70:
  CMP.w #$3E,D0
   BNE.w JL_0_9C9E
   BSR.w get1bytemain
  CMP.w #$3D,D0
   BNE.w JL_0_9C8E
  LEA opge,A0
BRA.w JL_0_9CCA


JL_0_9C8E:
  CMP.w #$3C,D0
   BEQ.w JL_0_9CC4

 JL_0_9C96:
    ;bsr.w bakup
    MOVE.w oldqflag,instringon
    MOVEA.l lastsourcepos,A5
BRA.w JL_0_9CCA


JL_0_9C9E:
  CMP.w #$3D,D0
   BNE.w JL_0_9CCA
   BSR.w get1bytemain
  CMP.w #$3E,D0
   BNE.w JL_0_9CBC
  LEA opge,A0
BRA.w JL_0_9CCA


JL_0_9CBC:
  CMP.w #$3C,D0
  BNE.w JL_0_9C96

 JL_0_9CC4:
  LEA opne,A0

 JL_0_9CCA:
  MOVE.w $1E(A0),D1
RTS


writecode:                                                 ;doop org source
    ;a0=operator,d2=type
    ;
 ;CLR.b iniffcommand
  MOVE.w d2,d1
  SUBQ.w #1,D1
   BMI.w illoperr
  LSL.w #2,D1
  MOVE.l $2(A0,D1.W),D1
   BEQ.w illoperr
  MOVEA.l D1,A0

 L_0_9CE4:                                                 ;??looks like label not used anymore??
JMP (A0)


;pushprec:
    ;push operator on stack
    ;
  ;MOVEA.l precsp(PC),A1
  ;MOVE.l A0,(A1)+
  ;MOVE.w D1,(A1)+
  ;MOVE.l A1,precsp
;RTS


popprec:
    ;pull precedence into d1 from stack
    ;
  MOVEA.l precsp(PC),A1
  CMPA.l #precstackf,A1
   BCC.w pserr
  MOVE.w -(A1),D1
  MOVEA.l -(A1),A0
  MOVE.l A1,precsp
RTS


precsp:      Dc.l precstack
precstack:   Ds.l 63                                       ;ds 6*32 org source   ;Lotsa Room?
             Ds.l 33
precstackf:  ;


;-----------PLUS------------;

mseq:  SEQ D0
msne:    SNE D0
mslt:    SLT D0
msle:    SLE D0
msgt:    SGT D0
msge:    SGE D0

cmp0:    CMP.b D0,D0
cmp1:    CMP.w D0,D0
cmp2:    CMP.l D0,D0


do_equal_byte:
  MOVE.w cmp0(PC),D1
BRA.w doeqcmp2                                            ;writecompare


do_not_equal_byte:
  MOVE.w cmp0(PC),D1
BRA.w donecmp2


do_littler_byte:
  MOVE.w cmp0(PC),D1
BRA.w doltcmp2


do_littler_equal_byte:
  MOVE.w cmp0(PC),D1
BRA.w dolecmp2


do_greater_byte:
  MOVE.w cmp0(PC),D1
BRA.w dogtcmp2


do_greater_equal_byte:                                                ;??Looks like double label??
dogeb
  MOVE.w cmp0(PC),D1
BRA.w dogecmp2


do_equal_word:
  MOVE.w cmp1(PC),D1
BRA.w doeqcmp2


do_not_equal_word:
  MOVE.w cmp1(PC),D1
BRA.w donecmp2


do_littler_word:
  MOVE.w cmp1(PC),D1
BRA.w doltcmp2


do_littler_equal_word:
  MOVE.w cmp1(PC),D1
BRA.w dolecmp2


do_greater_word:
  MOVE.w cmp1(PC),D1
BRA.w dogtcmp2


do_greater_equal_word:
dogew                                                      ;??looks like double label??
  MOVE.w cmp1(PC),D1
BRA.w dogecmp2


do_equal_long:
  MOVE.w cmp2(PC),D1                                   ;writecomparelong
BRA doeqcmp2

do_not_equal_long:
  MOVE.w cmp2(PC),D1
BRA donecmp2


do_littler_long:
  MOVE.w cmp2(PC),D1
BRA.w doltcmp2


do_littler_equal_long:
  MOVE.w cmp2(PC),D1
BRA.w dolecmp2


do_greater_long:
  MOVE.w cmp2(PC),D1
BRA.w dogtcmp2


do_greater_equal_long:
  MOVE.w cmp2(PC),D1
BRA.w dogecmp2


cfregat:  Ds.w 1


docflib:
  MOVE.w D1,libjsr+2
   BSR.w JL_0_AD40
  MOVE.l D4,D1
   BSR.w JL_0_AD38
  MOVE.w #$C900,D1
   BSR.w Atokejsr
   BSR.w JL_0_A352
  MOVE.l libjsr,D1
   BSR.w writelong
  MOVE.w regnum,cfregat
  CLR.w regnum
RTS


docflib2:                                                  
  MOVE.w cfregat,regnum
   BSR.w JL_0_A36E
  MOVE.l D5,D1
BRA.w JL_0_AD38


do_equal_float:                                            ;doeqf org source
   MOVEQ.l #-$2A,D1
   TST.b fpu
   BEQ do_equal_float__nofpu
   MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVEQ.l #1,d2
   MOVE.w #1,d1                                            ;fpu comp fseq
   BSR writeword
RTS

 do_equal_float__nofpu:
   BSR.w docflib
   BSR.w doeqcmp
BRA.w docflib2


do_not_equal_float:                                        ;donef org source
  MOVEQ.l #-$2A,D1
  TST.b fpu
   BEQ do_not_equal_float__nofpu
   MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #1,d2
   MOVE.w #$e,d1                                           ;fpu comp fsne
   BSR writeword
RTS

 do_not_equal_float__nofpu:
   BSR.w docflib
   BSR.w donecmp
BRA.w docflib2


do_littler_float:                                          ;doltf org source
  MOVEQ.l #-$2A,D1
    TST.b fpu
   BEQ do_littler_float__nofpu
   MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #$1,d2
   MOVE.w #$14,d1                                          ;fpu comp fslt
   BSR writeword
RTS

 do_littler_float__nofpu:
   BSR.w docflib
   BSR.w doltcmp
BRA.w docflib2


do_littler_equal_float:                                    ;dolef org source
  MOVEQ.l #-$2A,D1
  TST.b fpu
   BEQ do_littler_equal_float__nofpu
   MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #1,d2
   MOVE.w #$15,d1                                          ;fpu comp fsle
   BSR writeword
RTS

 do_littler_equal_float__nofpu:
   BSR.w docflib
   BSR.w dolecmp
BRA.w docflib2


do_greater_float:                                          ;dogtf org source
  MOVEQ.l #-$2A,D1
   TST.b fpu
   BEQ do_greater_float__nofpu
    MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #1,d2
   MOVE.w #$12,d1                                          ;fpu comp fsgt
   BSR writeword
RTS

 do_greater_float__nofpu:
   BSR.w docflib
   BSR.w dogtcmp
BRA.w docflib2


do_greater_equal_float:                                   ;dogef org source
  MOVEQ.l #-$2A,D1
 TST.b fpu
   BEQ do_greater_equal_float__nofpu
   MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #1,d2
   MOVE.w #$13,d1                                          ;fpu comp fsge
   BSR writeword
RTS

 do_greater_equal_float__nofpu:
   BSR.w docflib
   BSR.w dogecmp
BRA.w docflib2



do_equal_string:                                           ;doeqs org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w doeqcmp


do_not_equal_string:                                       ;dones org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w donecmp


do_littler_string:                                         ;dolts org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w doltcmp


do_littler_equal_string:                                   ;doles org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w dolecmp


do_greater_string:                                         ;dogts org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w dogtcmp


do_greater_equal_string:                                   ;doges org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w dogecmp



cmpit:
  TST.b fast                                               ;compare
  BEQ cmpit__org
  CNIF #optibreak
    ILLEGAL
  CEND
  MOVE.l destpointer,a0
  SUB.l imm_addr,a0
  CMP.l #6,a0
  BNE cmpit__l11
  MOVE.l imm_addr,a0
  CMP.w #$223c,imm_addr
  BNE cmpit__org
  ADD.w #$8e80,-6(a4)

 cmpit__l2b:
  CLR.l imm_addr
RTS

 cmpit__l11:
  CMP.l #4,a0
  BNE cmpit__l10
  CMP.b #2,d3
  BNE cmpit__l11b
  ADD.w #$7e40,-4(a4)
RTS

 cmpit__l11b:
 ADD.w #$7e00,-4(a4)
RTS

 cmpit__l10:
   MOVE.l destpointer,a0
   SUB.l load_var_addr,a0
   CMP.w #4,a0
   BNE cmpit__org
   CMP.b #3,d3
   BCS cmpit__lv1
   CLR.l load_var_addr
   ADD.w #$9080-$200,-4(a4)
RTS

 cmpit__lv1:
  CMP.b #2,d3
   BNE cmpit__org
   CLR.l load_var_addr
   ADD.w #$8040-$200,-4(a4)
RTS

 cmpit__org:                                               ;begin org source
  MOVE.w regnum,D3
  OR.w D3,D1
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
  ADDQ.w #1,D1
BRA.w writeword


doeqcmp2:
   BSR.w cmpit

 doeqcmp:
   MOVE.w mseq(PC),D1
BRA.w cpoke


donecmp2:
  BSR.w cmpit

 donecmp:
  MOVE.w msne(PC),D1
BRA.w cpoke


doltcmp2:
  BSR.w cmpit

 doltcmp:
   MOVE.w mslt(PC),D1
BRA.w cpoke


dolecmp2:
   BSR.w cmpit

 dolecmp:
   MOVE.w msle(PC),D1
BRA.w cpoke


dogtcmp2:
   BSR.w cmpit

 dogtcmp:
   MOVE.w msgt(PC),D1
BRA.w cpoke


dogecmp2:
  BSR.w cmpit

 dogecmp:
   MOVE.w msge(PC),D1

 cpoke:
   OR.w regnum,D1
   CMP.w #5,d2
   BNE cpoke__nod0
   CMP.w #5,d3
   BNE cpoke__nod0
   MOVE.l d1,-(a7)
   MOVE.l #$44004a00,d1                                    ;68k neg.b:tst.b
   BSR writelong
   MOVE.l (a7)+,d1

 cpoke__nod0:
   BSR.w writeword                                         ;writeseq
   MOVEQ.l #1,d2
   MOVE.l lasttoken,d1
    TST.b fast
    BEQ.s cpoke__l11
   CMP.l #$800b,d1
   BEQ cpoke__l10

 cpoke__l11:
  MOVE.w #$4880,D1                                         ;ext.w D regat
  OR.w regnum,D1
   BSR.w writeword                                         ;writeext.w
  MOVEQ.l #$02,D2                                          ;type now WORD!

 cpoke__l10:
RTS



do_plus_byte:                                              ;doplusb org source
  MOVE.w #$D040,D1
  MOVEQ.l #$02,D2                                          ;writeaddword   ;now a word
BRA.w doplus2


do_plus_word:                                              ;doplusw org source
  MOVE.w #$D040,D1
  MOVEQ.l #$03,D2                                          ;now a long
   BSR.w doplus2
BRA.w convert_word_to_long


do_plus_long:                                              ;doplusl org source  ;add regat+1 to regat
  MOVE.w #$D080,D1                                         ;writeaddlong

 doplus2:
  MOVE.w d1,a1
  TST.b fast
  BEQ doplus2__l10
  CNIF #optibreak
    ILLEGAL
  CEND
  ASR.w #8,d1
  CMP.b #$90,d1
  BEQ doplus2__sub1
  CMP.b #$d0,d1
  BNE doplus2__l10
  CMP.b #3,d3
  BCS doplus2__lq10
  TST.b quickadd
  ;BNE doplus2__lq1                                        ;????????????activate

 doplus2__lq10:
   MOVE.l destpointer,a0
   CLR.b quickadd
   CLR.l load_var_addr
   SUB.l imm_addr,a0
   CMP.w #6,a0
   BEQ doplus2__li10
   CMP.w #4,a0
   BNE.s doplus2__li1
   CLR.l imm_addr
   ADD.w #$a040-$200,-4(a4)
RTS

 doplus2__lq1:
   MOVE.l a4,a0
   SUB.l load_var_addr,a0
   CMP.l #$a,a0
   BNE doplus2__l10e
   CLR.l load_var_addr
   MOVE.w -$8(a4),d1
   MOVE.l -$4(a4),-$8(a4)
   MOVE.w d1,-$4(a4)
   SUB.w #$1980,-$a(a4)
   SUBQ.l #2,destpointer
RTS

 doplus2__l10e:
  CLR.b quickadd
BRA doplus2__l10

 doplus2__li10:
   CLR.l imm_addr
   TST.l -4(a4)                                            ;skip If ADD.l #0,dx
   BNE doplus2__doit
   SUBQ.l #6,destpointer
RTS

 doplus2__doit:
   ADD.w #$b080-$200,-6(a4)
RTS

 doplus2__li1:
   MOVE.l destpointer,a0
   SUB.l load_var_addr,a0
   CMP.w #4,a0
   BNE doplus2__l10
   CMP.b #3,d3
   BNE doplus2__lv1
   CLR.l load_var_addr
   ADD.w #$b080-$200,-4(a4)
RTS

 doplus2__lv1:
  CMP.b #2,d3
  BNE doplus2__l10
  CLR.l load_var_addr
  ADD.w #$a040-$200,-4(a4)
RTS

 doplus2__l10:
  MOVE.w regnum,D3
  MOVE.w a1,d1
  OR.w D3,D1
  ADDQ.w #1,D1
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
BRA.w writeword

 doplus2__sub1:
   CMP.b #3,d3
   BCS doplus2__sub1_lq10
   TST.b quickadd
   ;BNE doplus2__sub1_lqs1

 doplus2__sub1_lq10:                                       ;??lookslike same code as doplus2__lq10:
   MOVE.l destpointer,a0
   CLR.b quickadd
   CLR.l load_var_addr
   SUB.l imm_addr,a0
   CMP.w #6,a0
   BEQ doplus2__sub1_li10
   CMP.w #4,a0
   BNE.s doplus2__sub1_li1
   CLR.l imm_addr
   ADD.w #$6040-$200,-4(a4)
RTS

 doplus2__sub1_lqs1:
   MOVE.l a4,a0
    SUB.l load_var_addr,a0
    CMP.l #$a,a0
    BNE doplus2__sub1_l10e
   CLR.l load_var_addr
   MOVE.w -$8(a4),d1
   MOVE.l -$4(a4),-$8(a4)
   MOVE.w d1,-$4(a4)
   SUB.w #$1b80,-$a(a4)
   SUBQ.l #2,destpointer
RTS

 doplus2__sub1_l10e:                                       ;??looks like same code as doplus2__l10e:
  CLR.b quickadd
BRA doplus2__sub1_l10

 doplus2__sub1_li10:
   CLR.l imm_addr
   ADD.w #$7080-$200,-6(a4)
RTS

 doplus2__sub1_li1:                                        ;??looks like same code as doplus2__li1:
   MOVE.l destpointer,a0
   SUB.l load_var_addr,a0
   CMP.w #4,a0
   BNE doplus2__sub1_l10
   CMP.b #3,d3
   BNE doplus2__sub1_lv1
   CLR.l load_var_addr
   ADD.w #$7080-$200,-4(a4)
RTS

 doplus2__sub1_lv1:                                       ;??looks like same code as doplus2__lv1:
   CMP.b #2,d3
   BNE doplus2__sub1_l10
   CLR.l load_var_addr
   ADD.w #$6040-$200,-4(a4)
RTS

 doplus2__sub1_l10:                                       ;??looks like same code as doplus2__l10:
  MOVE.w regnum,D3
  MOVE.w a1,d1
  OR.w D3,D1
  ADDQ.w #1,D1
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
BRA.w writeword


do_plus_float__fadd1:
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ADDQ #1,d0
  ASL.w #8,d0
  ASL.w #2,d0
  MOVE.l #$f2000022,d1                                     ;fpu add
  OR.l d0,d1
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.l d0,d1
BRA.w writelong

 do_plus_float:                                            ;doplusf org source
    ;
    ;ffp add
    ;
  TST.b iee
  BNE do_plus_float__fadd1
  MOVE.w #$FFBE,D1                                         ;#-66,d1 org soruce ;floatadd

 doflib:
   MOVE.w D1,libjsr+2
   BSR.w JL_0_AD40
  MOVE.l D4,D1
   BSR.w JL_0_AD38
  MOVE.w #$C900,D1
   BSR.w Atokejsr
   BSR.w JL_0_A352
  MOVE.l libjsr,D1
   BSR.w writelong
   BSR.w JL_0_A36E
  MOVE.l D5,D1
BRA.w JL_0_AD38


add_strings:                                               ;addstrings org source
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  MOVE.w D1,-(A7)
  CMP.w #3072,d1
  BEQ 'l1
  OR.w addcode,D1                                          ;move.l (a7)+,d0
BRA 'l2

 'l1
   MOVE.w #$588f,d1                                        ;addq.l #4,a7

 'l2
   BSR.w writeword
  MOVE.w (A7)+,D1
  OR.w addcode+2,D1                                        ;native string add.l d0,(a7)
BRA.w writeword


;-----------end of PLUS, start of MINUS---------;

do_minus_byte:
  MOVE.w #$9040,D1
BRA.w doplus2


do_minus_word:
  MOVE.w #$9040,D1
BRA.w doplus2


do_minus_long:
  MOVE.w #$9080,D1
BRA.w doplus2


do_minus_float:
   TST.b iee
    BNE do_minus_float__fs1
  MOVE.w #$FFB8,D1                                         ;floatsub
BRA.w doflib

 do_minus_float__fs1:                                      ;fpu sub
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ADDQ #1,d0
  ASL.w #8,d0
  ASL.w #2,d0
  MOVE.l #$f2000028,d1
  OR.l d0,d1
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.l d0,d1
BRA.w writelong


;-----------end of MINUS, start of TIMES---------;

do_times_byte:
  MOVE.w #$C1C0,D1
  MOVEQ.l #$02,D2                                          ;now a word
BRA.w doplus2


do_times_word:
  MOVE.w #$C1C0,D1
  MOVEQ.l #$03,D2                                          ;now a long.
BRA.w doplus2


do_times_quick:
  MOVE.w #$CA00,D1                                         ;quickmul
BRA.w domylib


do_times_long:
  TST.b fast
  BNE.s 'l10
  MOVE.w #$CA01,D1                                         ;writelongmul
BRA.w domylib

 'l10
  ;bsr.w JL_0_AD40

 mull
  ;move.l D4,D1
  ;bsr.w JL_0_AD38
  ;bsr.w JL_0_A352
   MOVE.l destpointer,a0
   SUB.l imm_addr,a0
   CMP.w #6,a0
   BNE 'li1
   MOVEQ.l #2,d1
   MOVEQ #1,d3

 'ag
  CMP.l -4(a4),d1
   BEQ 'oklsl
    LSL.l #1,d1
    ADD.l #1,d3
    CMP.l #9,d3
    BNE 'ag
   MOVE.w -2(a4),d1
   BSR writeword
   MOVE.w -6(a4),-4(a4)
   MOVE.l #$4c3c0800,-8(a4)
   MOVE.w regnum,D3
   MULS #$1000,D3
   OR.w D3,-6(a4)
   CLR.l load_var_addr
   CLR.l imm_addr
BRA 'li3

 'oklsl
   CMP.w #8,d3
   BEQ 'ok
   ASL.l #1,d3
   ASL.l #8,d3
   MOVE.w #$e188,d1
   OR.w d3,d1
   MOVE.w d1,-6(a4)
BRA 'okls

 'ok
  MOVE.w #$e188,-6(a4)                                     ;lsl.l #,dx

 'okls
  MOVE.w regnum,d3
   OR.b d3,-5(a4)
   SUBQ.l #4,destpointer
   CLR.l load_var_addr
   CLR.l imm_addr
BRA 'li3

 'li1
   MOVE.l destpointer,a0
   SUB.l load_var_addr,a0
   CMP.w #4,a0
   BNE 'li2
   MOVE.w -2(a4),d1
   BSR writeword
   MOVE.b #$4c,-6(a4)
   MOVE.w #$0800,-4(a4)
   MOVE.w regnum,D3
   MULS #$1000,d3
   OR.w D3,-4(a4)
BRA 'li3

 'li2
   MOVE.l #$4c010800,d1
   MOVE.w regnum,D3
   EXT.l d3
   MULS #$1000,d3
   OR.w D3,d1
   MULS #$10,d3
   ADD.l d3,d1
   BSR writelong

'li3
  ;bsr.w JL_0_A36E
  ;move.l D5,D1
RTS


domylib:
  MOVE.w D1,-(A7)
   BSR.w JL_0_AD40
  MOVE.l D4,D1
   BSR.w JL_0_AD38
   BSR.w JL_0_A352
  MOVEQ #0,d1
  MOVE.w (A7)+,D1
  MOVE.l d1,lastinstruction
   BSR.w Atokejsr
   BSR.w JL_0_A36E
  MOVE.l D5,D1
BRA.w JL_0_AD38


do_times_float:
   TST.b iee
    BNE fm1
 MOVE.w #$FFB2,D1                                          ;floatmul
BRA.w doflib

 fm1                                                       ;fpu mul
  MOVEQ #0,d0
 MOVE.w regnum,d0
 ADDQ #1,d0
 ASL.w #8,d0
 ASL.w #2,d0
 MOVE.l #$f2000023,d1
 OR.l d0,d1
 MOVE.w regnum,d0
 ASL.w #7,d0
 OR.l d0,d1
BRA.w writelong


do_pow:
  MOVE.w D2,-(A7)                                          ;dopow
  MOVE.w D2,D3
  MOVEQ.l #$05,D2
   BSR.w JL_0_9770
  ADDQ.w #1,regnum
  MOVE.w (A7)+,D3
  MOVEQ.l #$05,D2
   BSR.w writeconvertcode
  SUBQ.w #1,regnum
   BSR.w nocando
   TST.b fpu
   BEQ 'old
   MOVEQ #0,d1
   MOVE.w regnum,d1
  MOVE.l d1,d0
  ASL.w #7,d1
  ASL.w #8,d0
  ASL.w #2,d0
  OR.w d0,d1
  MOVE.l d1,-(a7)
   ;OR.l #$f2000014,d1                                      ;flogn.x fp0      ;fpu ^ pow
   OR.l #$f2000016,d1                                       ;flog2.x fp0      ;fpu ^ pow
   BSR writelong
   MOVE.w regnum,d0
 ADDQ #1,d0
 ASL.w #8,d0
 ASL.w #2,d0
 MOVE.l #$f2000023,d1
 OR.l d0,d1
 MOVE.w regnum,d0
 ASL.w #7,d0
 OR.l d0,d1
   OR.l #$f2000023,d1                                      ;fmulx.x fp1,fp0
   BSR writelong
   MOVE.l (a7)+,d1
   ;OR.l #$f2000010,d1                                      ;fetox.x fp0
   OR.l #$f2000011,d1                                      ;ftwotox.x fp0
   BSR writelong
RTS

'old
  MOVE.w #$6001,D1
BRA.w domylib


nocando:
    ;can't eval this as a const!
    ;
  MOVEA.l forthsp(PC),A0
  MOVE.w #$FFFF,-(A0)                                      ;#-1,-(a0) org source
RTS


;-----------end of times, start of mod-------;

do_mod_byte:
  MOVE.w #$D400,D1
BRA.w domylib


do_mod_word:
  MOVE.w #$D401,D1
BRA.w domylib


do_mod_long:
   BSR.w nocando                                           ;modlib uses an alibjsr here!
  MOVE.w #$D402,D1
BRA.w domylib


do_mod_quick:
  MOVE.w #$D403,D1
  MOVEQ.l #$02,D2                                          ;now a word.
BRA.w domylib


do_mod_float:
   BSR.w nocando                                           ;modlib lib uses an alibjsr!  ;domod float
  TST.b fpu
  BEQ 'old
  MOVEQ #0,d1
  MOVE.w regnum,d1                                         ;fpu mod
  MOVE.l d1,d0
  ADDQ.l #1,d1
  ASL.l #7,d0
  ASL.l #8,d1
  ASL.l #2,d1
  OR.l d0,d1
  MOVE.l d0,-(a7)
  OR.l #$f2000021,d1
  BSR writelong
  MOVE.l (a7)+,d0
 RTS

'old
  MOVE.w #$D404,D1
  MOVEQ.l #$03,D2                                          ;now a long
BRA.w domylib


;-----------end of mod, start of POWER OF----;

;-----------end of mod, start of DIVIDE------;

do_Div_byte:
  MOVE.w #$48C0,D1
  OR.w regnum,D1
   BSR.w writeword
  ADDQ.w #1,D1
   BSR.w writeword

 do_Div_word:
   MOVE.w #$48C0,D1
  OR.w regnum,D1
   BSR.w writeword
  MOVE.w #$81C0,D1
BRA.w doplus2


do_Div_long:                                                ;longdiv
  TST.b fast
  BNE.s 'l10
  MOVE.w #$CB01,D1
BRA.w domylib

 'l10
  CNIF #optibreak
    ILLEGAL
  CEND
  BSR.w JL_0_AD40
  MOVE.l D4,D1
   BSR.w JL_0_AD38
   BSR.w JL_0_A352
;   MOVE.l destpointer,a4
;   MOVEQ.l #2,d1                                           ;have problem on negative float
;   MOVE.l d3,-(a7)                                         ;-18/8 =-3 should be -2
;   MOVEQ #1,d3
;
; 'ag
;       CMP.l -4(a4),d1
;       BEQ 'oklsr
;       LSL.l #1,d1
;       ADD.l #1,d3
;       CMP.l #9,d3
;       BNE 'ag
;   MOVE.l (a7)+,d3
   MOVE.l #$4c410800,d1
   BSR writelong

 'weit
  MOVE.w #$4e71,d1
   ;bsr writeword
   BSR.w JL_0_A36E
  MOVE.l D5,D1
BRA.w JL_0_AD38

 'oklsr
    CMP.w #8,d3
    BEQ 'ok
    ASL.l #1,d3
    ASL.l #8,d3
    MOVE.w #$e080,d1
    OR.w d3,d1
BRA 'oklsr2

 'ok
  MOVE.w #$e080,d1                                         ;lsr.l #,dx

 'oklsr2
     SUBQ.l #6,destpointer
     BSR writeword
     MOVE.l (a7)+,d3
     MOVEQ #0,d1
     CLR.l load_var_addr
     CLR.l imm_addr
BRA JL_0_AD38


do_Div_quick:
  MOVE.w #$CB00,D1                                         ;quickdiv
BRA.w domylib


do_Div_float:
   TST.b iee
   BNE fdiv1
   MOVE.w #$FFAC,D1                                        ;floatdiv
BRA.w doflib


fdiv1
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ADDQ #1,d0
  ASL.w #8,d0
  ASL.w #2,d0
  MOVE.l #$f2000020,d1                                     ;fpu div
  OR.l d0,d1
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.l d0,d1
BRA.w writelong


do_AND_byte:
  MOVE.w #$C000,D1
BRA.w doplus2


do_AND_word:
  MOVE.w #$C040,D1
BRA.w doplus2


do_AND_long:
  MOVE.w #$C080,D1
BRA.w doplus2


do_OR_byte:
  MOVE.w #$8000,D1
BRA.w doplus2


do_OR_word:
  MOVE.w #$8040,D1
BRA.w doplus2


do_OR_long:
  MOVE.w #$8080,D1
BRA.w doplus2


do_EOR_byte:
  MOVE.w #$B100,D1

 JL_0_A25C:
   MOVE.w regnum,D3
  OR.w D3,D1
  ADDQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
BRA.w writeword


do_EOR_word:
  MOVE.w #$B140,D1
BRA.w JL_0_A25C


do_EOR_long:
  MOVE.w #$B180,D1
BRA.w JL_0_A25C


do_LSL:
  MOVE.w #$E1A8,D1
BRA.w JL_0_A298


do_LSR:
  MOVE.w #$E0A8,D1
BRA.w JL_0_A298


do_ASR:
  MOVE.w #$E0A0,D1
BRA.w JL_0_A298


JL_0_A298:
  MOVE.w D1,-(A7)
  ADDQ.w #1,regnum
  MOVE.w D2,-(A7)
  MOVE.w D2,D3
  MOVEQ.l #$02,D2

 'l1
   MOVE.b #1,notypecheck
   BSR.w writeconvertcode
   CLR.b notypecheck
  MOVE.w (A7)+,D2
  SUBQ.w #1,regnum
  CMP.w #$4,D2
   BEQ.w JL_0_A2C2
  MOVE.w D2,D3
  MOVEQ.l #$03,D2
   BSR.w JL_0_9770

 JL_0_A2C2:
   MOVE.w (A7)+,D1
  MOVE.w regnum,D3
  OR.w D3,D1
  ADDQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
BRA.w writeword


_BitTst:
  MOVE.w #$0100,D1
   BSR.w JL_0_A31C
  MOVE.w regnum,D1
  ORI.w #$56C0,D1
   BSR.w writeword
  MOVE.w regnum,D1
  ORI.w #$4880,D1
   BSR.w writeword
  MOVEQ.l #$02,D2
RTS


_BitSet:
  MOVE.w #$01C0,D1

 JL_0_A304:
   BSR.w JL_0_A31C
  MOVEQ.l #$03,D2
RTS


_BitClr:
  MOVE.w #$0180,D1
BRA.w JL_0_A304


_BitChg:
  MOVE.w #$0140,D1
BRA.w JL_0_A304


JL_0_A31C:
  MOVE.w D1,-(A7)
  MOVE.w D2,-(A7)
  MOVE.w D2,D3
  MOVEQ.l #$03,D2
   BSR.w JL_0_9770
  MOVE.w (A7)+,D3
  MOVEQ.l #$01,D2
  ADDQ.w #1,regnum
   BSR.w writeconvertcode
  SUBQ.w #1,regnum
  MOVE.w regnum,D1
  MOVE.w D1,D2
  ADDQ.w #1,D2
  LSL.w #8,D2
  LSL.w #1,D2
  OR.w (A7)+,D1
  OR.w D2,D1
BRA.w writeword


JL_0_A352:
  MOVE.w regnum,D1
   BEQ.w JL_0_A36C
  ORI.w #$2000,D1
   BSR.w writeword
  ADDI.w #$201,D1
   BSR.w writeword

 JL_0_A36C:
RTS


JL_0_A36E:
  MOVE.w regnum,D1
   BEQ.w JL_0_A384
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2000,D1
   BSR.w writeword

 JL_0_A384:
RTS


JL_0_A386:
   CLR.b isconstantvalue
   CLR.l lastconstantvalue
   CMPI.w #$7,regnum
   BCS.w JL_0_A6B4
  MOVE.l #$f2277700,d1                                     ;fmove.d fp6,-(a7)
  BSR writelong
  MOVE.w #$2F06,D1                                         ;d6 to stack
  ;MOVE.w #$3F06,D1                                         ;d6 to stack
  CMP.w #$3,D2
   BCS.w JL_0_A3A2
  MOVE.w #$2F06,D1

 JL_0_A3A2:
  BSR.w writeword
  MOVE.w D1,-(A7)
  SUBQ.w #1,regnum
   BSR.w JL_0_A6B4
  ADDQ.w #1,regnum
  MOVE.l #$f2001b80,d1
  BSR writelong
  MOVE.w #$3E06,D1
  CMP.w #$3,D2
   BCS.w JL_0_A3C8
  MOVE.w #$2E06,D1

 JL_0_A3C8:
  BSR.w writeword
  MOVE.w (A7)+,D1
  ANDI.w #$F000,D1
  ORI.w #$C1F,D1
  JSR writeword
  MOVE.l #$f21f5700,d1                                     ;fmove.d (a7)+,fp6
BRA writelong


JL_0_A3DA:
  BSR.w JL_0_A6B4
  MOVE.w #$4440,D1
  CMP.w #$3,D2
   BCS.w JL_0_A406
  MOVE.w #$4480,D1
  CMP.w #$5,D2
   BCS.w JL_0_A406
  CMP.w #$6,D2
   BCC.w illoperr
  MOVE.w #$FFC4,D1
BRA.w JL_0_9604

 JL_0_A406:
  OR.w regnum,D1                                           ;negate
  CLR.l imm_addr
BRA.w writeword


JL_0_A410:
   BSR.w eval4
  CMP.w #$29,D0
   BEQ.w JL_0_A424
  CMP.w #$7D,D0
   BNE.w brackets_                                         ;syntax error brackets

 JL_0_A424:
BRA.w get1bytemain


JL_0_A428:
   BSR.w eval4
  CMP.w #$5,D2
   BCC.w illoperr
  MOVE.w regnum,D1
  ORI.w #$4640,D1
  CMP.w #$3,D2
   BCS.w writeword
  EORI.w #$C0,D1
BRA.w writeword


JL_0_A44E:
  MOVEQ.l #$05,D2                                          ;fpu pi
   TST.b fpu
  BEQ 'old
JMP fpupi

 'old
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1
   BSR.w writeword
  MOVE.l #$C90FDA42,D1
   BSR.w writelong
BRA.w get1bytemain


    ;stack contains.....
    ;pc.l,firstoff.l,optat.l,lasta6.w,0,constgot.w!
    ;
    ;18 bytes!

forthstack:  Ds.l 63                                       ;ds.b  18*32 org source
             Ds.l 63
             Ds.l 18
forthsp:     Dc.l forthstack


JL_0_A6B4:
   ;bsr.w get1bytemain
   !fget
   CMP.b #$7e,d0
   BNE 'noc
   SUBQ.l #1,a5
   BSR get1bytemain

 'noc
   CMP.b #"#",d0
   BNE 'ld1
   CMP.b #$22,(a5)
   BNE 'ld1
   JSR addimmi

 'ld1
   CMP.b #$22,d0
   BNE 'l11
   ;BTST #$d,vartype
   ;BNE 'ls1
   ;CMP.b #7,d2                                             ;long pointer string error
   ;BEQ 'ls1
   ;TST.b vartype+1
   ;BEQ 'ls1
;BRA error_convert_types

 'ls1
   NOT.w instringon

 'l11
   TST.b d0
   BPL 'l10
   LSL.w #8,d0
   MOVE.b (a5)+,d0
   MOVE.l d0,lasttoken
   MOVE.w d0,lastchar

 'l10
  CMP.w #$28,D0
   BEQ.w JL_0_A410
  CMP.w #$7B,D0
   BEQ.w JL_0_A410
  CMP.w #$2D,D0
   BEQ.w JL_0_A3DA
  CMP.w #-$7F77,D0
   BEQ.w JL_0_A428
  MOVEA.l forthsp(PC),A1
  CMPA.l #forthsp,A1
   BCC.w conmemerr
  MOVE.l destpointer,(A1)+
  MOVE.l hunkoffsetbase,(A1)+
  MOVE.l lasta6,(A1)+
  MOVE.w lasta6,(A1)+
  CLR.w (A1)+
  CLR.w (A1)+
  MOVE.l A1,forthsp
   ;bsr.w tstnum
   !compare2
   BEQ.w JL_0_B224
  CMP.w #".",D0
   BEQ.w JL_0_B21E
  CMP.w #"#",D0
   BEQ.w get_constant
  CMP.w #"$",D0
   BEQ.w get_hexconstant
  CMP.w #"%",D0
   BEQ.w JL_0_A8C0
  CMP.w #-$7FD1,D0
   BEQ.w _SizeOf
  CMP.w #-$7F46,D0
   BEQ.w JL_0_A44E
  CMP.w #-$7F3B,D0
   BEQ.w JL_0_A83C
  CMP.w #-$7F3A,D0
   BEQ.w JL_0_A846
  MOVE.w constmode,D1
   BEQ.w JL_0_A776
   !compare1                                               ;bsr.w tstalpha
   BEQ.w JL_0_AF22
  CMP.w #$5F,D0
   BEQ.w JL_0_AF22
  CMP.w #$22,D0
   BEQ.w JL_0_AF00
BRA.w syntaxerr


JL_0_A776:
  MOVE.w cfetchmode,D1
  BEQ.w JL_0_A784
BRA.w badconerr

 JUMP_syntaxerropt4
JMP syntaxerropt4


JL_0_A784:
  NOT.w -(A1)
  !compare1                                                ;bsr.w tstalpha
   BEQ.w JL_0_AF4C
  CMP.w #$2A,D0
   BEQ.w JL_0_AF4C
  CMP.w #$5C,D0
   BEQ.w JL_0_AF4C
  CMP.w #$22,D0
   BEQ.w JL_0_ADC0
  BTST #$F,D0
   BNE.w JL_0_AAF2
  CMP.w #$26,D0
   BEQ.w JL_0_A90E
  CMP.w #$3F,D0
   BEQ.w JL_0_AED4

 .atmode_iff
  CMP.b #"@",d0
   BNE syntaxerr
  TST.b newsyntax
   BEQ JUMP_syntaxerropt4
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1
  BSR.w writeword
  CMP.b #$22,(a5)
   BNE syntaxerr
  ADDQ #1,a5
  MOVEQ #0,d0
  CMP.b #1,d2
   BEQ 'l3b
  CMP.b #2,d2
   BEQ 'l2b
  CMP.b #4,d2
   BEQ error_convert_types
  MOVE.b (a5)+,d0
  BEQ syntaxerr
  CMP.b #$22,d0
  BNE 'l1
    MOVE.b #0,d0
BRA 'do

 'l1
  ASL.l #8,d0
  MOVE.b (a5)+,d0
  BEQ syntaxerr
  CMP.b #$22,d0
  BNE 'l2
    MOVE.b #0,d0
    ASR.l #8,d0
BRA 'do

 'l2
  ASL.l #8,d0

 'l2b
  MOVE.b (a5)+,d0
   BEQ syntaxerr
   CMP.b #$22,d0
   BNE 'l3
   MOVE.b #0,d0
   ASR.l #8,d0
BRA 'do

 'l3
  ASL.l #8,d0

 'l3b
  MOVE.b (a5)+,d0
   BEQ syntaxerr
   CMP.b #$22,d0
   BNE 'l4
   MOVE.b #0,d0
   ASR.l #8,d0
BRA 'do

 'l4
   CMP.b #$22,(a5)+
   BNE JUMP_error4char

 'do
  MOVE.l d0,d1
    BSR writelong
    BSR get1bytemain
RTS


_SizeOf:
  BSR.w get1bytemain
  CMP.w #$2E,D0
   BEQ.b JL_0_A7F4
   ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  MOVE.w D2,-(A7)
   BSR.w getparameter2
   BEQ.w syntaxerr
  LEA varbase,A2
   BSR.w findvariable
   BNE.w notypeerr
  MOVE.w $4(A2),D3
  EXT.l D3
  MOVE.w (A7)+,D2
BRA.w JL_0_B46E


JL_0_A7F4:
  MOVE.w D2,-(A7)
   BSR.w getparameter2
   BEQ.w syntaxerr
  LEA newtypebase,A2
   BSR.w findtype
   BNE.w notypeerr
  MOVEQ.l #$00,D3
  CMP.w #$5C,D0
   BNE.w JL_0_A832
   BSR.w getparameter2
   BEQ.w syntaxerr
  LEA $4(A2),A2
   BSR.w findvariable2
   BNE.w noofferr
  MOVE.w $4(A2),D3
BRA.w JL_0_A836


JL_0_A832:
  MOVE.w $8(A2),D3

 JL_0_A836:
  MOVE.w (A7)+,D2
BRA.w JL_0_B46E


JL_0_A83C:
  MOVEQ.l #-$01,D3
   BSR.w get1bytemain
BRA.w JL_0_B46E


JL_0_A846:
  MOVEQ.l #$00,D3
   BSR.w get1bytemain
BRA.w JL_0_B46E


ishex:
  CMP.w #$30,D0
   BCS.w JL_0_A876
  CMP.w #$39,D0
   BLS.w JL_0_A874
  ANDI.w #$FFDF,D0
  CMP.w #$46,D0
   BHI.w JL_0_A876
  CMP.w #$41,D0
   BCS.w JL_0_A876

 JL_0_A874:
   CMP.w D0,D0

 JL_0_A876:
RTS


JL_0_A878:
  CMP.w #$31,D0
   BEQ.w JL_0_A884
  CMP.w #$30,D0

 JL_0_A884:
RTS


get_hexbyte
   MOVEQ #0,d0
   MOVE.b (a5)+,d0
   MOVE.b (a5)+,d0
   BSR ishex
   BNE syntaxerr
   SUBI.w #$30,D0
   CMP.w #$9,D0
   BLS.w 'l1
   SUBQ.w #7,D0

 'l1
   MOVE.l d0,d1
   MOVE.b (a5)+,d0
     BSR ishex
    BNE syntaxerr
    LSL.l #4,d1
    SUBI.w #$30,D0
   CMP.w #$9,D0
   BLS.w 'l2
   SUBQ.w #7,D0

 'l2
  ADD.l d1,d0
RTS


get_hexconstant:
   BSR.w get1bytemain
   BSR.w ishex
   BNE.w syntaxerr
  MOVEQ.l #$00,D3
  CMP.w #5,d2
  BNE JL_0_A894
  CMP.l #newtype_double,a2
  BEQ 'doit
  CMP.l #newtype_float,a2
  BNE JL_0_A894

 'doit
   fmove.s #0,fp0
 JL_0_A894a:
  TST.b fpu
  BEQ JL_0_A894
  fmove.w #16,fp1
  fmul.x fp1,fp0
  SUBI.w #$30,D0
  CMP.w #$9,D0
   BLS.w JL_0_A8AEa
  SUBQ.w #7,D0

 JL_0_A8AEa:
   fmove.w d0,fp1
   fadd.x fp1,fp0
   BSR.w get1bytemain
   BSR.w ishex
   BEQ.w JL_0_A894a
BRA.w nofpregload


JL_0_A894:
  CMP.l #$10000000,D3
   BCC.w overerr
  LSL.l #4,D3
  SUBI.w #$30,D0
  CMP.w #$9,D0
   BLS.w JL_0_A8AE
  SUBQ.w #7,D0

JL_0_A8AE:
  OR.w D0,D3
   BSR.w get1bytemain
   BSR.w ishex
   BEQ.w JL_0_A894
BRA.w JL_0_B46E


JL_0_A8C0:
   BSR.w get1bytemain
   BSR.w JL_0_A878
   BNE.w syntaxerr
   MOVEQ.l #$00,D3

 JL_0_A8CE:
   LSL.l #1,D3
   BCS.w overerr
  SUBI.w #$30,D0
  OR.w D0,D3
   BSR.w get1bytemain
   BSR.w JL_0_A878
   BEQ.w JL_0_A8CE
BRA.w JL_0_B46E


get_constant:
   MOVE.w d2,-(A7)
   MOVE.b #0,automode
   CMP.b #"@",(a5)
   BNE 'l1
   ADDQ.l #1,a5
   MOVE.b #1,automode
   BSR getparameter2
   BSR findlabel2
   BNE 'addit
BRA errormsg_autocount

 'addit
  BSR.w addlabelhash
  MOVE.l #$1,$4(A2)
  MOVEM.l a2/a5,-(a7)
  MOVE.w lastchar,-(a7)
  LEA autostorename,a5
  BSR getparameter2
  BSR findlabel2
  BEQ 'found
  BSR.w addlabelhash
  MOVE.l #$1,$4(A2)
  MOVE.l #0,8(a2)

 'found
   MOVE.w (a7)+,d0
   MOVE.w d0,lastchar
  MOVE.l 8(a2),d3
  ADD.l #1,8(a2)
  MOVEM.l (a7)+,a2/a5
  MOVE.l d3,8(a2)
  MOVE.l $8(A2),D3
BRA.l 'l3

 'l1
  BSR.w getparameter2
    TST.b incnif
    BEQ 'lc1
    BSR.w findlabel2
    BNE 'l5
    MOVEQ #1,d3
    MOVE.w (A7)+,D2
BRA JL_0_B46E

 'l5
  MOVEQ #0,d3
    MOVE.w (A7)+,D2
BRA JL_0_B46E

 'lc1
   BSR.w findlabel2
   BNE.w cnferr

 'l2
   CMPI.l #$1,$4(A2)
   BNE.w cnferr
 'l3
   MOVE.l $8(A2),D3
   MOVE.w (A7)+,D2
BRA.w JL_0_B46E


JL_0_A90E:
  CLR.w vartype
  BSR.w JL_0_A916
  MOVEQ.l #$03,D2
RTS


JL_0_A916:
   BSR.w get1bytemain
   !compare2
   BEQ andop2
   BSR.w getparameter
   BSR.w JL_0_8E3C
   BSR.w calcvar
  CMP.b #$7,D2
   BNE.w JL_0_A960
  BTST #$F,D2
   BNE.w JL_0_A94A
  MOVE.w D3,stamp2+2
  MOVE.l stamp2,D1
   BSR.w pokela5s
BRA.w JL_0_A978


JL_0_A94A:
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w stamp,D1
   BSR.w writeword
RTS


JL_0_A960:
  BTST #$F,D2
   BNE.w JL_0_A978
  MOVE.w D3,leaamp+2
  MOVE.l leaamp,D1
   BSR.w pokela5s

 JL_0_A978:
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w leaamp2,D1
BRA.w writeword


JL_0_A98C:
  MOVE.w #$D200,D1
   BSR.w Atokejsr
  MOVEQ.l #$03,D2
RTS


;------                                                  ;disassembled code begin
addrcode:  Dc.b $20,$6D,$00,$00                            ;MOVEA.L $0000(A5),A0
           Dc.b $D0,$C0                                    ;ADDA.W  D0,A0
           Dc.b $20,$08                                    ;MOVE.L  A0,D0
addrcodef:
;------                                                  ;disassembled code end


JL_0_A9A0:
   BSR.w get1bytemain
  MOVE.w D0,D1
   BPL.w syntaxerr
  MOVE.w D2,-(A7)
  BCLR #$F,D1
   BSR.w searchinstr
  MOVE.l $12(A2),D0
  TST.w -$2(A2,D0.L)
   BEQ.w freeerr
  MOVE.w (A7)+,D2
RTS


usedcode:
  MOVE.l $0(A5),D0
   BNE.b ucodeskip
  MOVEQ.l #-$01,D0
BRA.b usedcodef

 ucodeskip:
  SUB.l $0(A5),D0

 ucodediv:
  LSR.w #8,D0
usedcodef:   ;


usedcode2:
   MOVE.l $0(A5),D0
   BNE.b ucodeskip2
  MOVEQ.l #-$01,D0
BRA.b usedcode2f

 ucodeskip2:
  SUB.l $0(A5),D0                                          ;usedcode2
  LSR.w #8,D0

 ucodediv2:
  LSR.w #8,D0
usedcode2f:  ;


usedprep:
  MOVE.l D0,-(A7)

useddone:
  MOVE.l (A7)+,D0

usedfix:
  MOVE.l D0,D0


doused:
    ;return 'used' object.
    ;
  BSR.w JL_0_A9A0
    ;
  MOVE.w -$2(A2,D0.L),D3
  CMP.w #$9,D3
   BCC.w doused__skip
    ;
    ;shift 1-8
    ;
  LEA usedcode(PC),A0
  LEA usedcodef(PC),A1
    ;
  ANDI.w #$F1FF,$E+4(A0)                                   ;and #$f1ff,ucodediv-usedcode(a0) org source
  ANDI.w #$7,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,$E+4(A0)                                         ;or  d3,ucodediv-usedcode(a0) org source
BRA.w doused__skip2

 doused__skip:
    ;shift 9+
    ;
  LEA usedcode2(PC),A0
  LEA usedcode2f(PC),A1
    ;
  ANDI.w #$F1FF,$10+4(A0)                                  ;and #$f1ff,ucodediv2-usedcode2(a0) org source
  SUBQ.w #8,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,$10+4(A0)                                        ;or  d3,ucodediv2-usedcode2(a0) org source

 doused__skip2:
  MOVE.w -$6(A2,D0.L),D3
  MOVE.w D3,$C+4(A0)                                       ;move d3,ucodeskip-usedcode+2(a0) org source
  ADDQ.w #4,D3
  MOVE.w D3,$2(A0)
  MOVE.w regnum,D1
   BEQ.w doused__skip3
  MOVE.w usedprep(PC),D1
   BSR.w writeword

 doused__skip3:
  BSR.w pokecode
  MOVE.w regnum,D1
   BEQ.w doused__skip4
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w usedfix(PC),D1
   BSR.w writeword
  MOVE.w useddone(PC),D1
   BSR.w writeword

 doused__skip4:
   MOVEQ.l #$02,D2
BRA.w get1bytemain


domaximum:
    ;number of maximums
    ;
    ;eg a=Maximum Shape
    ;
   BSR.w JL_0_A9A0
    ;
  MOVEQ.l #$00,D3
  MOVE.w -$4(A2,D0.L),D3
   BSR.w get1bytemain
BRA.w JL_0_B46E


doaddr:
    ;address of something
    ;eg a.l=Addr Window(0)
    ;
   BSR.w get1bytemain
  MOVE.w D0,-(A7)
   BSR.w get1bytemain
  CMP.w #$28,D0
   BNE.w syntaxerr
  MOVE.w (A7)+,D0
   BSR.w JL_0_C340
   BSR.w reget
  CMP.w #$29,D0
   BNE.w syntaxerr
    ;
    ;OK, now a2=lib it's from
    ;
  LEA addrcode(PC),A0
  LEA addrcodef(PC),A1
  MOVE.w -$6(A2),$2(A0)
  MOVE.w $4(A0),D1
  ANDI.w #$FFF8,D1
  OR.w regnum,D1
  MOVE.w D1,$4(A0)
  MOVE.w $6(A0),D1
  ANDI.w #$F1FF,D1
  MOVE.w regnum,D0
  LSL.w #8,D0
  LSL.w #1,D0
  OR.w D0,D1
  MOVE.w D1,$6(A0)
   BSR.w pokecode
  MOVEQ.l #$03,D2
BRA.w get1bytemain


 JL_0_AAF2:
  CMP.w #-$7F4D,D0
   BHI.w JL_0_AAFE
BRA.w syntaxerr


 JL_0_AAFE:                                               ;varassign lib commands. $b581 Null from lotanlib
   CMP.w #$b581,d0
   BNE nonull
   MOVE.l d0,lastinstruction
   MOVE.w #$7000,d1                                            ;asm instr moveq #0,dx
   MOVE.w regnum,d0
   ASL.l #7,d0
   ASL.l #2,d0
   OR.l d0,d1
   BSR writeword
   JSR get1bytemain
   RTS

nonull  CMP.w #-$7F4A,D0
   BEQ.w JL_0_A98C
  CMP.w #-$7F48,D0
   BEQ.w doaddr
  CMP.w #-$7F3C,D0
   BEQ.w domaximum
  CMP.w #-$7F2F,D0
   BEQ.w doused
  MOVE.w D2,-(A7)
  MOVE.w D0,D1
  BCLR #$F,D1
  ;CLR.b quickpeek
   BSR.w searchinstr
  MOVE.w (A3),D1
  BTST #$1,D1
   BEQ.w noreturn_                                         ;syntax error noreturn
  BTST #$2,D1
   BNE.w JL_0_AC1A
  LSR.w #8,D1
  BTST #$3,$1(A3)
   BEQ.w JL_0_AB4C
   JSR AJL_0_498A

 JL_0_AB4C:
   MOVE.w D1,-(A7)                                         ;is library instruction
  CMP.w #$7,D1
   BNE.w JL_0_AB5E
  MOVE.l A2,-(A7)
   BSR.w makesbase
  MOVEA.l (A7)+,A2

 JL_0_AB5E:
    BSR.w JL_0_AFA2
  MOVE.w D3,-(A7)
   BSR.w get1bytemain
  MOVEQ.l #$00,D1
  CMP.w #$28,D0
   BNE.w JL_0_AB80
   BSR.w JL_0_66F6
  TST.w D1
   BEQ.w syntaxerr
BRA.w JL_0_AB84


 JL_0_AB80:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

 JL_0_AB84:
   MOVE.w regnum,-(A7)
   MOVE.w regnum,regnumstore
   TST.b fpu
            BEQ 'nofloat
            CMP.w #$ffff,28(a3)
            BNE 'nofloat
            CMP.w #$3c01,34(a3)                            ;val do nofpu stuff
            BEQ 'nofloat
            CMP.w #$3c02,34(a3)                            ;int skip
            BEQ 'quick
            CMP.b #5,(a3)
            BNE 'nofloat

 'quick
            CLR.l load_var_addr
BRA 'isfpu

 'nofloat
   CLR.w regnum

 'isfpu
   MOVE.w D1,-(A7)
  BTST #$3,$1(A3)
   BEQ.w JL_0_ABB0
;   TST.b fast
;   BEQ 'l2
;   CMP.w #$ffff,24(a3)
;   BNE 'l2
;   CMP.w #$5a02,30(a3)                                     ;peek
;   BNE 'l2
;  MOVE.w $6(A7),D1
;  MOVE.w d1,peeksize
;  TST.b fpu
;  BEQ 'l2
;  CMP.w #5,d1                                              ;is float on fpu
;  BNE 'l1
;  ;MOVE.b #1,quickpeek
;
; 'l1
;BRA 'l11

'l2
  MOVE.w $6(A7),D1
  MOVE.w d1,peeksize
;  CMP.w #$5a02,30(a3)                                      ;peek
;  BNE 'l10
;  CMP.b #7,d1                                              ;optimize dont work in peek.w(peek.w))
;  BEQ 'l10
;  TST.b fast
;  BEQ 'l10
;BRA 'l11

'l10
  ORI.w #$7000,D1
  BSR.w writeword                                          ;write peekmode

'l11
  ADDQ.w #1,regnum
  MOVE.w (A7),D1

 JL_0_ABB0:
  MOVE.w 2(a7),tempregnum
  JSR JL_0_4878
  TST.w (A7)+
   BEQ.w JL_0_ABC6
  CMP.w #$29,D0
   BNE.w syntaxerr
   BSR.w get1bytemain

 JL_0_ABC6:
   MOVE.w (A7)+,D1
  MOVE.w D1,regnum
   BEQ.w JL_0_ABDE
   CMP.w #$3c01,24(a2)                                     ;val skipped
   BNE 'noval
   TST.b fpu
   BEQ 'noval
   CLR.l load_var_addr
   MOVEQ #0,d1
   MOVE.w regnum,d1
   LSL.l #7,d1
   OR.l #$f2000000,d1
   BSR writelong
BRA JL_0_ABDE


 'noval
   CMP.w #$3c02,24(a2)                                     ;int skipped
   BEQ 'quick
   CMP.b #5,d2
   BNE 'nofpu
   TST.b fpu
   BEQ 'nofpu
   ;CLR.l load_var_addr
;BRA 'nofpu

 'quick
   CLR.l load_var_addr
BRA JL_0_ABDE

 'nofpu
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2000,D1
  BSR.w writeword                                          ;write move.l d0,dx
  TST.b fpu
  BEQ JL_0_ABDE
  MOVEQ #0,d1
  MOVE.w regnum,d1
  LSL.l #7,d1
  OR.l #$f2000000,d1
  ;BSR writelong

 JL_0_ABDE:
       MOVE.w (A7)+,D3
       BEQ.w JL_0_ABFC
       TST.b fpu
       BEQ 'nofpu
      MOVE.l d0,-(a7)
       MOVE.l a0,-(a7)
       MOVE.l stacktrack,d1
       LEA fpustackbase,a0
       MOVE.w 0(a0,d1),regmask
       MOVE.l (a7)+,a0
      MOVE.w #8,d0

 'loop
      BEQ 'ready
      BTST d0,regmask
      BEQ 'noa7
      MOVEQ #0,d1
      MOVE.w d0,d1
      SUBQ.w #1,d1
      ASL #7,d1
      ;OR.l #$f21f4400,d1                                   ;fmove.s (a7)+
      OR.l #$f21f5400,d1                                   ;fmove.d (a7)+
      BSR writelong
      SUBQ.l #2,stacktrack

 'noa7
      SUBQ.w #1,d0
      BNE 'loop

 'ready
      MOVE.l (a7)+,d0
      SUBQ.l #2,stacktrack                                 ;int track

 'nofpu
   MOVE.w #$4CDF,D1
   BSR.w writeword                                         ;write movem.l (a7)+,
  MOVEQ.l #$00,D1
  MOVEQ.l #$0F,D4

 JL_0_ABF0:
    LSL.w #1,D3
    ROXR.w #1,D1
  DBF D4,JL_0_ABF0

   BSR.w writeword
   TST.b fast
   BEQ JL_0_ABFC
   TST.w regnum
   BEQ JL_0_ABFC
   CMP.w #$3c0e,$1c(a3)                                    ;true
   BNE 'l1
   MOVE.w regnum,d1
   ASL.l #8,d1
   ASL.l #1,d1
   OR.w #$70ff,d1
   SUB.l #12,destpointer
   BSR writeword

 'l1
  CMP.w #$3c0f,$1c(a3)                                     ;false
   BNE 'l2
    MOVE.w regnum,d1
    ASL.l #8,d1
    ASL.l #1,d1
    OR.w #$7000,d1
    SUB.l #12,destpointer
    BSR writeword

 'l2                                                       ;??looks like double label??
 JL_0_ABFC:
   MOVE.w (A7)+,D2
  CMP.w #$7,D2                                             ;destination var type
   BNE.w JL_0_AC16
  MOVE.w putstlen,D1
  OR.w regnum,D1
   BSR.w writeword

 JL_0_AC16:
BRA.w JL_0_AF66


JL_0_AC1A:
  MOVE.w $6(A3),D1
   BSR.w uselib
   BSR.w JL_0_AD40
  MOVE.l D4,D1
  MOVE.l D5,-(A7)
   BSR.w JL_0_AD38
  MOVE.w $A(A1),-(A7)
  ADDQ.w #8,A3
  MOVE.w (A3)+,-(A7)
  MOVE.l A3,-(A7)
   BSR.w get1bytemain
  MOVE.w D0,-(A7)
  MOVEQ.l #$00,D3

 JL_0_AC40:
  MOVE.b (A3)+,D1
   BMI.w JL_0_AC6A
  MOVEQ.l #$03,D2
  ADDQ.w #1,D3
  MOVEM.l D3/A3,-(A7)
   BSR.w peval
  SUBQ.w #4,a2offset
  MOVEM.l (A7)+,D3/A3
  CMP.w #$2C,D0
   BEQ.w JL_0_AC40
  TST.b (A3)
   BPL.w syntaxerr

 JL_0_AC6A:
  MOVE.w (A7)+,D1
   BSR.w JL_0_AD04
  MOVEA.l (A7)+,A3
  SUBQ.w #1,D3
   BMI.w JL_0_ACBE

 JL_0_AC78:
  TST.b (A3)+
   BPL.w JL_0_AC78
  SUBQ.w #1,A3

 JL_0_AC80:
    MOVEQ.l #$00,D1
    MOVE.b -(A3),D1
    BTST #$4,D1
     BNE.w JL_0_ACAA
    CMP.w regnum,D1
     BCC.w JL_0_AC9E
    BSET D1,D5
    MOVEQ.l #$0F,D0
    SUB.w D1,D0
    BSET D0,D4

   JL_0_AC9E:
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$201F,D1
  BRA.w JL_0_ACB6

   JL_0_ACAA:
    ANDI.w #$7,D1
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$205F,D1

   JL_0_ACB6:
     BSR.w writeword
  DBF D3,JL_0_AC80

 JL_0_ACBE:
  MOVE.w (A7)+,libjsr+2
  MOVE.w (A7)+,libbase+2
  MOVE.l libbase,D1
   BSR.w writelong
  MOVE.l libjsr,D1
   BSR.w writelong
  MOVE.w regnum,D1
   BEQ.w JL_0_ACF4
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2000,D1
   BSR.w writeword

 JL_0_ACF4:
  MOVE.l (A7)+,D1
   BSR.w JL_0_AD38
  MOVEQ.l #$03,D2
   BSR.w reget
BRA.w JL_0_AF66

 JL_0_AD04:
  TST.w D3
   BEQ.w JL_0_AD1E
  CMP.w #$28,D1
   BNE.w syntaxerr
  CMP.w #$29,D0
   BNE.w syntaxerr
BRA.w get1bytemain

 JL_0_AD1E:
  CMP.w #$28,D1
   BNE.w JL_0_AD36
   BSR.w get1bytemain
  CMP.w #$29,D0
   BNE.w syntaxerr
BRA.w get1bytemain

 JL_0_AD36:
RTS

 JL_0_AD38:
  TST.w D1
   BNE.w writelong
RTS


JL_0_AD40:
  MOVE.w #$48E7,D4
  SWAP D4
  CLR.w D4
  MOVE.w #$4CDF,D5
  SWAP D5
  CLR.w D5
  MOVE.w regnum,D1
   BEQ.w JL_0_AD74
  BSET #$F,D4
  BSET #$0,D5
  CMP.w #$2,D1
   BCS.w JL_0_AD72

 JL_0_AD6A:
  BSET #$E,D4
  BSET #$1,D5

 JL_0_AD72:
RTS

 JL_0_AD74:
  TST.w fuckpos
  BNE.w JL_0_AD6A
RTS


fuckpos:  Ds.w 1


makesbase:
  MOVE.w sbasegot,D1
   BEQ.w makesbase__skip
    ;
    ;S base has been got, was it for this Eval?
    ;
  MOVE.w sbgot(PC),D1
   BNE.w makesbase__skip2
    ;
    ;No, push it on da stack!
    ;
  MOVE.w #$0002,sbgot
  MOVE.w movea3a7,D1
BRA.w writeword

 makesbase__skip2:
RTS

 makesbase__skip:                                          ;add tempstring
   ;no sbase got at all!                                              
   ;
  MOVE.w #$0001,sbgot                                      ;voodoo magic! - Will it work?

 'l1                                                       ;??looks like unused label??
  MOVE.l #$C601,D1
  MOVE.w #-1,sbasegot
  MOVE.l d1,lastinstruction
  BSR.w Atokejsr
RTS



JL_0_ADC0:
  MOVE.l data1,litdata1
  TST.b fast
  BEQ 'l50                                                 ;optistring  seem impossible to get work
                                                           ;100% compatible see string$ for problems
                                                           ;only assign constant and case constant is activate
                                                           ;when on print "test",fi$  fail
BRA 'l50                                                   ;to deactivate

  CNIF #optibreak                                          ;??looks like dead code??
    ILLEGAL
  CEND

  TST.b optistring
  BNE.s 'l21
  CLR.b string1
  MOVE.b #1,optistring
  TST.b nostringopt
  BNE 'l21
  MOVE.l a5,a4
  SUBQ.l #1,a4

 'l10
    TST.b (a4)
    BMI 'l19a
    BEQ.s 'l20
    CMP.b #$22,(a4)
    BEQ.s 'l19

 'l18
    TST.w string1
    BNE 'l11
    CMP.b #":",(a4)
    BEQ.s 'l20
    CMP.b #";",(a4)
    BEQ.s 'l20
    CMP.b #"+",(a4)
    BEQ.s 'l21
    CMP.b #",",(a4)
    BEQ.s 'l20                                             ;was l21
    CMP.b #")",(a4)
    BEQ.s 'l20                                             ;was l21

 'l11
    ADDQ.l #1,a4
BRA.s 'l10

 'l19
  BCHG #0,string1
BRA 'l18

 'l19a
  ADDQ.l #1,a4
  TST.b (a4)
  BEQ 'l21
BRA 'l11

 'l20
  MOVE.l a5,a4
  SUBQ.l #1,a4

 'll1
  CMP.b #$20,-(a4)
  BEQ 'll1
  CMP.b #"+",(a4)
  BEQ 'l21
  ;CMP.b #",",(a4)
  ;BEQ 'l22
  ;CMP.b #"(",(a4)
  ;BEQ 'l22
;BRA 'l21

;; CMP.b #"=",(a4)
;; BEQ 'l21
  ;CMP.b #">",(a4)
  ;BEQ 'l21
  ;CMP.b #"<",(a4)
  ;BEQ 'l21

 'l22
  MOVE.b #2,optistring

 'l21
  CMP.b #2,optistring
  BEQ.s 'l100

 'l50
  BSR.w makesbase
  BSR.w pokedata1                                          ;writestringsizespace
  BSR.w pokedata1

 'l100
  MOVEQ.l #$00,D2

  writestring:
    MOVE.l a5,lastsourcepos
    MOVEQ #0,d0
    MOVE.b (a5)+,d0
    TST.w D0
     BEQ.w notqerr
    CMP.w #$22,D0                                          ; --- " ---
     BEQ.w JL_0_ADF6
    CMP.b #"\",d0
     BNE 'l1
    CMP.b #"\",(a5)
     BNE 'l1
    TST.b newsyntax
     BEQ 'l1
    CMP.w #"\\",1(a5)                                      ; new compiler constants
    BNE 'l2
    ADDQ #2,a5

 'l1
    ADDQ.w #1,D2
    MOVE.w D0,D1
    BSR.w pokedata1b                                        ;writestring
BRA.w writestring

 'l2                                                       ;\\char//
    JSR check_newconstants
BRA writestring

 JL_0_ADF6:
  NOT instringon
  MOVE.w dontwrite,D1
  BNE.w JL_0_AE0A
  CMP.b #2,optistring
  BEQ 'l10
    MOVEA.l litdata1,A0
    CLR.w (A0)+                                            ;writesize
    MOVE.w D2,(A0)

 'l10                                                      ;??Looks like double label?
 JL_0_AE0A:
  BSR.w JL_0_AEA4                                          ;writestringconstantcode
  ADDQ.l #1,data1
  BCLR #$0,data1+3
  MOVEQ.l #$07,D2
BRA.w get1bytemain


JL_0_AE22:
  BSR.w makename2
  BSR.w findlabel2
  BEQ.w JL_0_AE4A
  BSR.w addlabelhash
  CLR.l $4(A2)
  CLR.l $8(A2)
  ;clr.l $C(A2)
  MOVE.w linenumat+2,$10(A2)
  MOVE.w linenumat,d0
  MOVEQ #0,d1
  MOVE.b -1(a2,d7),d1
  MOVE.w d0,0(a2,d1)
BRA.w JL_0_AE52

JL_0_AE4A:
  TST.l $8(A2)
  BNE.w JL_0_AE88

 JL_0_AE52:
  MOVEA.l _execbase,A6
  MOVEQ.l #$0C+2,D0
  MOVEQ.l #$01,D1
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C
  MOVEA.l D0,A0
  MOVE.l $4(A2),(A0)
  MOVE.l A0,$4(A2)
  MOVE.l destpointer,$4(A0)
  ADDQ.l #2,$4(A0)
  MOVE.w procnum,$8(A0)
  MOVE.w linenumat+2,$A(A0)
  MOVE.w linenumat,$c(a0)
RTS

 JL_0_AE88:
  MOVE.l $4(A2),D1
  BTST #$0,D1
   BNE.w illlaberr
  MOVE.w procnum,D1
  CMP.w $10(A2),D1
   BNE.w referr
RTS


JL_0_AEA4:
  MOVE.w D0,-(A7)
  CMP.b #2,optistring
  BEQ 'l10

 'l35
  MOVE.w numtoa0,D1
   BSR.w writeword
   BSR.w addoff
  MOVE.l litdata1,D1
   BSR.w writelong
  MOVE.w pushlen,D1
   BSR.w writeword
  MOVE.w #$C600,D1
   BSR.w Atokejsr
  MOVE.w (A7)+,D0
RTS

 'l10
  MOVEQ #0,d1
  BSR.w pokedata1b
  MOVE.l destpointer,a4
  MOVE.w #$203c,d1
  TST.w mode
  BNE 'lm10
   ADDQ.w #4,a2offset
  MOVE.w #$2f3c,d1

 'lm10
  TST.w mode
  BEQ 'lm3
  MOVE.w regnum,D0
  LSL.w #8,D0
  LSL.w #1,D0
  OR.w d0,d1
  BSR writeword
  BSR.w addoff
  MOVE.l litdata1,D1
  BSR.w writelong
  CMP.w #3,mode
  BEQ 'l30
   ADDQ.w #4,a2offset
  MOVE.w #$4878,D1
  BSR.w writeword
  MOVE.l d2,d1
  BSR writeword

 'l30
  MOVE.w (A7)+,D0
RTS

 'lm3
  MOVE.l #$3f3c0007,d1
  BSR writelong
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2f3c,d1
  BSR writeword
   ADDQ.w #4,a2offset
  MOVE.l d2,d1
  BSR writelong
  MOVE.w #$2f3c,d1
  BSR writeword
  BSR.w addoff
  MOVE.l litdata1,D1
  BSR.w writelong
  MOVE.w (A7)+,D0
RTS


JL_0_AED4:
  BSR.w get1bytemain
   BSR.w JL_0_AE22
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1
   BSR.w writeword
   BSR.w addoff
  MOVE.l $8(A2),D1
   BSR.w writelong
  MOVEQ.l #$03,D2
BRA.w reget

 JL_0_AF00:
  MOVEQ.l #$00,D3

 JL_0_AF02:
  BSR.w get1bytemain
   BEQ.w syntaxerr
  CMP.w #$22,D0
   BEQ.w JL_0_AF1A
  LSL.l #8,D3
  MOVE.b D0,D3
BRA.w JL_0_AF02

 JL_0_AF1A:
  BSR.w get1bytemain
BRA.w JL_0_B46E

 JL_0_AF22:
  MOVE.w D2,-(A7)                                          ;basicvarsforasm
   BSR.w makename2
   BSR.w findlabel2
   BEQ.w 'l10
   LEA ptr_parameterstore,a0
   CMP.b #"@",-1(a0,d2.w)
   BNE cnferr
   CLR.b -1(a0,d2.w)
   SUBQ.l #1,d2
   LEA varbase,a2
   BSR findvariable
   BNE cnferr
   CMP.b #"\",d0
   BNE 'l6
   ADDQ #1,lastsourcepos
   MOVE.l $a(a2),a2
   ADDQ.l #4,a2
   BSR.w makename2
   BSR findvariable2
   BNE cnferr
BRA.s 'l6                                                  ;???

 'l6
   MOVE.w $4(a2),d3
   EXT.l d3
BRA JL_0_AF46

 'l10
  MOVE.l $8(A2),D3
  CMPI.l #$1,$4(A2)
   BEQ.w JL_0_AF46
  NOT.w asmtype

 JL_0_AF46:
  MOVE.w (A7)+,D2
BRA.w JL_0_B46E


JL_0_AF4C:
  MOVE.w D2,-(A7)
   BSR.w getparameter
  CMP.w #$7B,D0
   BEQ.w JL_0_AFDE
   BSR.w JL_0_8E3C

   BSR.w calcvar                                         ;getvaroffset+type
   BSR.w JL_0_B150
   ;BTST #$d,vartype
   ;BNE 'ls1
   ;CMP.b #7,vartype+1                                      ;long pointer string error
   ;BEQ 'ls1
   ;TST.b vartype+1
   ;BEQ 'ls1
   ;CMP.b #7,d2
   ;BNE 'ls1
;BRA error_convert_types

 'ls1
   TST.b typecheck
   BEQ JL_0_AF66


   CMP.l #$da01,lasttoken                                  ;poke
   BEQ 'l1
   CMP.l #$da02,lasttoken                                  ;peek
   BNE 'l2

'l1
   CMP.w #1,parnum
   BNE JL_0_AF66
   MOVE.b d2,peekaddrsize
BRA JL_0_AF66

 'l2
  CLR.b peekaddrsize

 JL_0_AF66:
  CMP.w #$1,D2
   BNE.w JL_0_AF7C
  MOVE.w regnum,D1
  ORI.w #$4880,D1
   BSR.w writeword

 JL_0_AF7C:
  MOVE.w (A7)+,D3
   BEQ.w JL_0_AF9E
   MOVE.l lastinstructionaddr,a0
  CMP.w #$3,D3
   BNE.w JL_0_AF92
  CMP.w #$4,D2
   BEQ.w JL_0_AF98

 JL_0_AF92:
  CMP.w D2,D3
   BLS.w JL_0_AF9E

 JL_0_AF98:
  EXG.l D2,D3

  BSR.w writeconvertcode

 JL_0_AF9E:
BRA.w reget

JL_0_AFA2func:
  MOVEQ.l #$00,D3
  MOVE.w regnum,D1
   BEQ.w JL_0_AFC8
  SUBQ.w #1,D1

 JL_0_AFB0b:
     LSR.l #1,D3
     BSET #$F,D3
  DBF D1,JL_0_AFB0b

   TST.b fpu
   BEQ 'l1
   ADDQ.l #2,stacktrack                                    ;intern command
    MOVE.l a0,-(a7)
    MOVE.l stacktrack,d1
    LEA fpustackbase,a0
    CLR.w 0(a0,d1)
    CLR.w regmask
    MOVE.l (a7)+,a0

 'l1
  MOVE.w #$48E7,D1
   BSR.w writeword                                         ;write movem.l d0/d1,-(a7)
  MOVE.w D3,D1
BRA.w writeword



JL_0_AFA2:
  MOVEQ.l #$00,D3
  MOVE.w regnum,D1
   BEQ.w JL_0_AFC8
  SUBQ.w #1,D1

 JL_0_AFB0:
    LSR.l #1,D3
    BSET #$F,D3
  DBF D1,JL_0_AFB0

   TST.b fpu
   BEQ 'l1
   ADDQ.l #2,stacktrack                                    ;intern command
    MOVE.l a0,-(a7)
    MOVE.l stacktrack,d1
    LEA fpustackbase,a0
    CLR.w 0(a0,d1)
   CMP.b #5,(a3)                                           ;result float ?
    BNE 'nofpu
;    MOVE.w #1,0(a0,d1.w)
    MOVE.w regnum,regnumfunc

 'nofpu
  CLR.w regmask
    MOVE.l (a7)+,a0

 'l1
  MOVE.w #$48E7,D1
   BSR.w writeword                                         ;write movem.l d0/d1,-(a7)
  MOVE.w D3,D1
BRA.w writeword

 JL_0_AFC8:
RTS


JL_0_AFCA:
  MOVE.l D1,-(A7)
  MOVE.w #$4EB9,D1
   BSR.w writeword
   BSR.w addoff
  MOVE.l (A7)+,D1
BRA.w writelong


JL_0_AFDE:
   BSR.w findproc                                          ;write function call
   BEQ 'l1
   TST.l unusedfunc
   BEQ noprocerr
;BRA noprocerr
   JSR gotoendsource

 'l1
  MOVEQ.l #$00,D1
  MOVE.b $5(A2),D1
  MOVE.b d1,retmode
   BMI.w illprocerr
   MOVE.b #1,isfunc(a2)
  MOVE.w D1,-(A7)
  MOVEQ.l #$00,D1
  MOVE.b $4(A2),D1
  LSR.w #4,D1
   BEQ.w JL_0_B006
  LSL.w #2,D1
  SUB.w D1,a2offset

 JL_0_B006:
  CMPI.w #$7,(A7)
   BNE.b JL_0_B014
  MOVE.l A2,-(A7)
   BSR.w makesbase
  MOVEA.l (A7)+,A2

 JL_0_B014:
  MOVE.w sbasegot,-(A7)
   BEQ.b JL_0_B020
   BSR.w dopusha3

 JL_0_B020:
  BSR.w JL_0_AFA2func
  MOVE.w D3,-(A7)
  MOVE.l $E(A2),D1
  TST.b $20(a2)                                            ;increase if morepar
  BNE 'no0par
  MOVE.l a5,a4

 'l1
  CMP.b #$20,(a4)+
  BEQ 'l1
  CMP.b #"}",-1(a4)
  BNE  'no0par
  MOVEQ #0,d0

                                                           ;functioncall no pars
  LEA $16(A2),A1

 'again
  MOVE.l d1,-(a7)
  MOVE.b (a1),d2
  MOVE.l d0,d1
  CMP.w #4,d2
  BNE 'l1b
  ADD.l #$203c,d1
  BSR writeword
  MOVE.l #$ffff0000,d1
  BSR writelong
BRA 'l2b

 'l1b
   TST.b fpu
   BNE 'l1c
   CMP.w #5,d2
   BNE 'l1c
   ADD.l #$203c,d1
   BSR writeword
   MOVE.l #$800000c1,d1
   BSR writelong
BRA 'l2b

 'l1c
  ADD.l #$70ff,d1
  BSR writeword
  CMP.w #7,d2
  BNE 'l1d
  MOVE.l #$2f3c0000,d1      ; write code move.l #0,-(a7)
  BSR writelong
  MOVEQ #0,d1
  BSR writeword
  MOVE.l #$2f3c0000,d1      ; write code move.l #0,-(a7)
  BSR writelong
  MOVEQ #0,d1
  BSR writeword
                                                                                                                                                                                                                                                        
'l1d  MOVE.l #$f23c5000,d1
  MOVE.l d0,d2
  ASR.l #2,d2
  ADD.l d2,d1
  BSR writelong
  MOVE.w #$ffff,d1
  BSR writeword


 'l2b
  MOVE.l (a7)+,d1
     ADDQ.l #1,a1
     ADD.l #$0200,d0
     CMP.l #$0e00,d0
     BEQ syntaxerr
     TST.b (a1)
     BNE 'again
BRA 'p1

 'no0par
  TST.b $4(A2)
   BNE.w JL_0_B03E

 'p1
  BSR.w JL_0_AFCA
   BSR.w get1bytemain
BRA.w JL_0_B06C


JL_0_B03E:
  MOVE.w regnum,-(A7)
  MOVE.w regnum,regnumfunc

 ._func
  MOVE.l D1,-(A7)                                          ;write functioncall with pars
  MOVE.b #1,funccall
  MOVEQ.l #$00,D0
  MOVE.b $4(A2),D0
  MOVE.w a2offset,a2offset2
  MOVE.b 5(a2),retmode
  MOVE.l a2,currentfunccall
  LEA $16(A2),A2
  CLR.w regnum
  CLR.w regmask
  MOVE.b isconstantvalue,-(a7)
  MOVE.b funcparloop,-(a7)
  MOVE.b #1,funcparloop
  ;BSR.w fetchpees2

  JSR fetchpees2
  MOVE.b (a7)+,funcparloop
  MOVE.b (a7)+,isconstantvalue

  JSR chkstak
  MOVE.l (A7)+,D1
;  CMP.l #6,parnumtemp
;  BLE 'l1
;  CMP.l #11,parnumtemp
;  BGE 'l1
;   TST.w a2offset
;   BEQ 'l1
;   MOVE.l d1,-(a7)
;   MOVE.w #$47ef,d1                                        ;lea x(a7),a3 nat
;   BSR writeword
;   MOVE.w a2offset,d1
;   SUB.w a2offset2,d1
;   BSR writeword
;   MOVE.l (a7)+,d1

; 'l1
   BTST #0,d1
   BNE intern1
   BSR.w JL_0_AFCA
;   CMP.l #6,parnumtemp
;  BLE 'le
;  CMP.l #11,parnumtemp
;  BGE 'le
;   TST.w a2offset
;   BEQ 'le                                                 ;changed
;   MOVE.l d1,-(a7)
;   MOVE.l #$4fef0000,d1                                    ;lea $x(a7),a7   nat
;   MOVE.w a2offset,d1
;   SUB.w a2offset2,d1
;   BSR.w writelong                                         ;correct stack with more parameters
;  MOVE.w numreps,movenumrep+2
;   BEQ.w 'le2
;  MOVE.l movenumrep,D1
;   BSR.w writelong

; 'le2
;  MOVE.w a2offset2,a2offset
;  MOVE.l (a7)+,d1

 'le
  MOVE.w (A7)+,regnum

 JL_0_B06C:
  CMP.w #$7D,D0
   BNE.w syntaxerr
   MOVEQ #0,d1                                            ; end of function call pars
  MOVE.w regnum,D1
   BEQ.w JL_0_B08A
   TST.b fpu
   BEQ 'old
   CMP.b #5,retmode
   BNE 'old
   ASL.l #7,d1
   OR.l #$f2000000,d1
   BSR writelong
BRA JL_0_B08A

 'old  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2000,D1
   BSR.w writeword

 JL_0_B08A:
   MOVE.w (A7)+,D3
   BEQ.w JL_0_B0A8
   TST.b fpu
   BEQ 'old
   MOVE.l d0,-(a7)
   MOVE.w #8,d0
   MOVE.l a0,-(a7)
   MOVE.l stacktrack,d1
   LEA fpustackbase,a0
   MOVE.w 0(a0,d1),regmask
   MOVE.l (a7)+,a0

 'loop
  BEQ 'ready
   BTST d0,regmask
   BEQ 'noa7
   MOVEQ #0,d1
   MOVE.w d0,d1
   SUBQ.w #1,d1
   ASL #7,d1
   ;OR.l #$f21f4400,d1
   OR.l #$f21f5400,d1                                      ;fmove.d (a7)+
   BSR writelong
   SUBQ.l #2,stacktrack

 'noa7
   SUBQ.w #1,d0
   BNE 'loop

 'ready
  SUBQ.l #2,stacktrack                                     ;integer sub
  MOVE.l (a7)+,d0

 'old
  MOVE.w #$4CDF,D1
   BSR.w writeword
  MOVEQ.l #$00,D1
  MOVEQ.l #$0F,D4

 JL_0_B09C:
    LSL.w #1,D3
    ROXR.w #1,D1
  DBF D4,JL_0_B09C                                         ;movem.l (a7)+,dx

    BSR.w writeword
   CLR.w regnumfunc

 JL_0_B0A8:
  MOVE.w (A7)+,D1
   BEQ.b JL_0_B0D2
  CMPI.w #$7,(A7)
   BEQ.b JL_0_B0C4
  LEA geta3,A0
  LEA numtoa0,A1
   BSR.w pokecode
BRA.b JL_0_B0CE

 JL_0_B0C4:                                                ;is a string, wack off last '0'
  MOVE.w deca3,D1
   BSR.w writeword

 JL_0_B0CE:                                                
  BSR.w dopulla3                                           ;fix up string base

 JL_0_B0D2:
  MOVE.w (A7)+,D2                                          ;what it returns!
  CMP.w #$7,D2
   BNE.w JL_0_B0EC
  MOVE.w putstlen,D1
  OR.w regnum,D1
   BSR.w writeword

 JL_0_B0EC:
  BSR.w get1bytemain
BRA.w JL_0_AF66


;------                                                  ;disassembled code begin
deca3:   Dc.b $53,$4B                                      ;SUBQ.W  #1,A3
;------                                                  ;disassembled code end

Even
JL_0_B0F6:
  CMP.b #2,optistring
  BEQ fs2
  BSR.w makesbase                                          ;writestringvariable
  BTST #$F,D2
   BNE.w JL_0_B112
  MOVE.w D3,leaa5d3a2+2
  MOVE.l leaa5d3a2,D1
   BSR.w pokela5s

 JL_0_B112:
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$7000,D1
  LEA stvarget2,A0
  MOVE.w D1,(A0)
  MOVE.w regnum,D1
  ANDI.w #$FFF8,$2(A0)
  OR.w D1,$2(A0)
  LEA stvarget2f,A1
   BSR.w pokecode
  MOVE.w #$C600,D1
   BSR.w Atokejsr
  MOVEQ.l #$07,D2
BRA.w reget

 fs2:
     TST.w stackpar
     BMI 'l10
     MOVE.l #$3f3c0007,d1
     ADDQ.w #2,a2offset
     BSR writelong

 'l10
  MOVE.w #$4878,d1
     CLR.w stackpar
     BSR writeword
     MOVE.w #$0,d1
     BSR writeword
     MOVE.w #$246d,d1
     BSR writeword
     MOVE.w d3,d1
     BSR writeword
     MOVE.l #$4a926704,d1
     BSR writelong
     MOVE.l #$2eaafffc,d1
     BSR writelong
     MOVE.w #$2f0a,d1
     ADDQ.w #8,a2offset
     BSR writeword
BRA.w reget

JL_0_B150:
  CMP.b #$7,D2                                             ;load basic var
   BEQ.w JL_0_B0F6

   TST.b iee
   BEQ 'noiee
   CMP.b #5,d2
   BNE 'noiee
   MOVE.l d0,-(a7)                                         ;fpu load var
   BTST #15,d2
   BEQ 'var
   CMP.l #$7fff,d3
   BGT 'longoffset
   MOVE.l #$f22a4400,d1                                    ;newtype     >32kb
   TST.w d3                                                ;offset =0
   BNE 'offset

 'longoffset
  MOVE.l #$f2124400,d1
   MOVEQ #0,d3
BRA 'glob

 'offset
  SUBQ.l #4,destpointer
BRA 'glob

 'var
  TST.b fast
   BEQ 'nofastload
   TST.w regnum
   BNE 'nofastload
   CMP.l fp0addr,a4
   BNE 'nofastload
   MOVE.l fp0iff,d1
   CMP.l firstiff,d1
   BNE 'nofastload
   MOVE.w varmode,d1
   CMP.w fp0mode,d1
   BNE 'nofastload
   CMP.w fp0var,d3
   BNE 'nofastload
   BCLR #16,d2
   MOVE.l (a7)+,d0
RTS

 'nofastload
   MOVEQ #0,d0
   MOVE.w regnum,d0
   CMP.l maxregs,d0
   BLE 'ok
   LEA cmplxerr,a0
  MOVE.l a0,-(a7)
JMP handle_compileerror

 'ok
   LEA regtable,a4
   TST.l (a4)
   BEQ 'noreg
   CMP.w 0+4(a4),d3
   BNE 'doreg1
   MOVE.l #$f2001c00,d1
   MOVE.w regnum,d0
   ASL.w #7,d0
   OR.w d0,d1
   BSR writelong
   MOVE.l (a7)+,d0
RTS

 'doreg1
  CMP.w 8+4(a4),d3
   BNE 'doreg2
   MOVE.l #$f2001800,d1
   MOVE.w regnum,d0
   ASL.w #7,d0
   OR.w d0,d1
   BSR writelong
   MOVE.l (a7)+,d0
RTS

 'doreg2
  CMP.w 16+4(a4),d3
   BNE 'doreg3
   MOVE.l #$f2001400,d1
   MOVE.w regnum,d0
   ASL.w #7,d0
   OR.w d0,d1
   BSR  writelong
   MOVE.l (a7)+,d0
RTS

 'doreg3
  CMP.w 24+4(a4),d3
   BNE 'doreg4
   MOVE.l #$f2001000,d1
   MOVE.w regnum,d0
   ASL.w #7,d0
   OR.w d0,d1
   BSR writelong
   MOVE.l (a7)+,d0
RTS

 'doreg4
   CMP.w 32+4(a4),d3
   BNE 'noreg
   MOVE.l #$f2000c00,d1
   MOVE.w regnum,d0
   ASL.w #7,d0
   OR.w d0,d1
   BSR writelong
   MOVE.l (a7)+,d0
RTS

 'noreg
   MOVE.l #$f22d4400,d1                                    ;var
   TST.w varmode
  BEQ 'glob
  BCLR #16,d1                                              ;local

 'glob
   MOVEQ #0,d0
   MOVE.w regnum,d0
   CMP.w #7,d0
   BLE 'ok2
   LEA cmplxerr,a0
  MOVE.l a0,-(a7)
JMP handle_compileerror

 'ok2
     ASL.w #7,d0
   OR.l d0,d1
   CMP.l #doublecheck,8(a2)
   BNE 'dbl
   OR.l #$00001000,d1

 'dbl
  BSR writelong
   MOVE.l (a7)+,d0
   AND.w #$ff,d2
   MOVE.w d3,d1
   BEQ 'nooffs
BRA writeword

 'nooffs
   ;CMP.l #$f2124400,-4(a4)
   ;BNE writeword
RTS

 'noiee
  MOVE.w regnum,D1
  MOVE.w d1,load_var_reg
  LSL.w #8,D1
  MOVE.l destpointer,load_var_addr
  MOVE.w d2,load_var_size
  LSL.w #1,D1
  BTST #$E,D2
   BNE.w JL_0_B17A
  TST.b D2
   BNE.w JL_0_B17E
  MOVEQ.l #$03,D2
  ORI.w #$200A,D1
BRA.w writeword

 JL_0_B17A:
  MOVE.b #$3,D2

 JL_0_B17E:
  BTST #$F,D2
   BEQ.w JL_0_B19A                                         ;loadarray
   TST.b fast                                              ;lea->move xx(a2)
   BEQ 'la10
   CNIF #optibreak
     ILLEGAL
   CEND

   CLR.l load_var_addr
BRA 'la10

   CMP.w #$2012,movea2dn                                  ;??Looks like dead code??
   BNE 'la10
   TST.b optiarray
   BNE 'la10
   MOVE.l destpointer,a4
   SUB.l loada,a4
   CMP.w #4,a4
   BEQ 'la100
   CMP.w #2,a4
   BNE 'la10
   MOVE.l destpointer,a4
   CMP.b #3,d2
   BCS 'la110
   MOVE.w #$202a,-2(a4)
   OR.w d1,-2(a4)
   MOVE.w arrayoffset,d1
   BSR writeword
BRA JL_0_B194

 'la110
   CMP.b #2,d2
   BNE 'la120
    MOVE.w #$302a,-2(a4)
   OR.w d1,-2(a4)

   MOVE.w arrayoffset,d1
   BSR writeword
BRA JL_0_B194

 'la120
  CMP.b #1,d2
   BNE.s 'la10
    MOVE.w #$102a,-2(a4)
   OR.w d1,-2(a4)
   MOVE.w arrayoffset,d1
   BSR writeword
BRA JL_0_B194

 'la100
  MOVE.l destpointer,a4
   CMP.w #$45ea,-2(a4)
   BNE 'la10
   CMP.b #3,d2
   BCS 'la11
   MOVE.w #$202a,-4(a4)
   OR.w d1,-4(a4)
BRA JL_0_B194

 'la11
   CMP.b #2,d2
   BNE 'la12
    MOVE.w #$302a,-4(a4)
   OR.w d1,-4(a4)
BRA JL_0_B194

 'la12
  CMP.b #1,d2
   BNE.s 'la10
    MOVE.w #$102a,-4(a4)
   OR.w d1,-4(a4)
BRA JL_0_B194

 'la10
   OR.w movea2dn,D1
   BSR.w JL_0_B1B2
   BSR.w writeword

 JL_0_B194:
  ANDI.w #$FF,D2
RTS


farr2
   MOVE.l destpointer,a4
   MOVE.l #$f22a4400,-4(a4)
   MOVE.w arrayoffset,d1
BRA writeword


JL_0_B19A:
  OR.w moved3a5dn,D1                                        ;write move.l 0(a5),reg
   BSR.w JL_0_B1B2
   BSR.w pokewda5s
  MOVE.w D3,D1
   BSR.w writeword
BRA.w JL_0_B194

 JL_0_B1B2:
  BTST #$E,D2
   BNE.w JL_0_B1CA
  CMP.b #$1,D2
   BEQ.w JL_0_B1CC
  CMP.b #$2,D2
   BEQ.w JL_0_B1D2

 JL_0_B1CA:
RTS

 JL_0_B1CC:
  EORI.w #$3000,D1
RTS

 JL_0_B1D2:
  ORI.w #$1000,D1
RTS


JL_0_B1D8:
  MOVE.w #$FFFF,dfetch
  BSR.w get1bytemain
  CMP.w #$2D,D0
   BNE.w JL_0_B206
  BSR.w get1bytemain
  BSR.w JL_0_B206
  CMP.w #$5,D2
   BCC.w JL_0_B200
  NEG.l D0
RTS

 JL_0_B200:
  TST.b fpu
  BEQ 'noneg
  fneg.x fp0
RTS

 'noneg
  BCHG #$7,D0
RTS

 JL_0_B206:
  CMP.w #$24,D0
   BEQ.w get_hexconstant
  CMP.w #$25,D0
   BEQ.w JL_0_A8C0
  CMP.w #$2E,D0
   BNE.w JL_0_B224

 JL_0_B21E:
  MOVEQ.l #$00,D3
BRA.w JL_0_B272

 JL_0_B224:
  MOVEQ.l #$00,D3                                          ;number
   BSR.w atoi
  CMP.w #$2E,D0
   BEQ.w JL_0_B268
  ORI.w #$20,D0
  CMP.w #$65,D0
   BNE.w JL_0_B46E
  CMP.l #$800000,D3
   BCC.w overerr
  MOVEQ.l #-$01,D6
  fmove.l d3,fp0
  MOVE.l D3,D0
  MOVEA.l _mathffpbase,A6
   JSR -$24(A6)
  MOVE.l D0,D3
   BSR.w JL_0_B2E6
   BSR.w reget
   BSR.w JL_0_B480
BRA.w JL_0_B3DC

 JL_0_B268:
  CMP.b #4,d2
  BEQ 'l4
  MOVE.b #5,d2                                             ;nprint 2/0.5 bugfix

 'l4
   TST.b fpu
   BNE 'l1
   CMP.l #$800000,D3
   BCC.w overerr
BRA JL_0_B272

 'l1
  CMP.l #$7fffffff,d3
    BCC.w overerr

 JL_0_B272:
  MOVEQ.l #-$01,D6
  MOVE.l D3,D0
  fmove.l d3,fp0
  MOVEA.l _mathffpbase,A6
   JSR -$24(A6)                                            ;integer to ffp
  MOVE.l D0,-(A7)
   BSR.w get1bytemain
   BSR.w tstnum
   BNE.w syntaxerr
  MOVEQ.l #$00,D3
   BSR.w atoi
  TST.l D3
   BEQ.w JL_0_B2E0
  TST.b fpu
  BNE 'l1
  CMP.l #$800000,D3
   BCC.w overerr
BRA 'l2

 'l1
  CMP.l #$7fffffff,d3
  BCC overerr

 'l2
  fmove.l d5,fp1
  MOVE.l D5,D0
   JSR -$24(A6)
  MOVE.l D0,D5
  fmove.l d3,fp2
  MOVE.l D3,D0
   JSR -$24(A6)
  fdiv.x fp1,fp2
  MOVE.l D5,D1
   JSR -$54(A6)
  fadd.x fp2,fp0
  MOVE.l (A7)+,D1
   JSR -$42(A6)
  MOVE.l D0,D3
   BSR.w reget
  ORI.w #$20,D0
  CMP.w #$65,D0
   BNE.w JL_0_B2D4
   BSR.w JL_0_B2E6

 JL_0_B2D4:
   BSR.w reget
   BSR.w JL_0_B480
BRA.w JL_0_B3DC

 JL_0_B2E0:
  MOVE.l (A7)+,D3
BRA.w JL_0_B2D4

 JL_0_B2E6:
  BSR.w get1bytemain
  CMP.w #$2B,D0
   BEQ.w JL_0_B30E
  CMP.w #$2D,D0
   BNE.w JL_0_B312
   BSR.w get1bytemain
   BSR.w getsign
  MOVE.l D3,D0
  fdiv.x fp1,fp0
  MOVE.l D4,D1
   JSR -$54(A6)
  MOVE.l D0,D3
RTS

 JL_0_B30E:
  BSR.w get1bytemain

 JL_0_B312:
  BSR.w getsign
  fmul.x fp1,fp0
  MOVE.l D3,D0
  MOVE.l D4,D1
   JSR -$4E(A6)
  MOVE.l D0,D3
RTS

getsign:
  BSR.w tstnum
   BNE.w syntaxerr
  MOVE.w D0,D4
  SUBI.w #$30,D4
   BSR.w get1bytemain
   BSR.w tstnum
   BNE.w getsign__skip
  MULU #$A,D4
  SUBI.w #$30,D0
  ADD.w D0,D4
   BSR.w get1bytemain

 getsign__skip:
  CMP.w #$12,D4
   BHI.w overerr
  LSL.w #3,D4
  LEA fputab,a0
  ADD.l d4,a0
  fmove.d 0(a0),fp1
  LSR.w #1,d4
  MOVE.l facts(PC,D4.W),D4
RTS


fputab
  Dc.d 1,10,100,1000,10000,100000,1000000,10000000,100000000  ;,1000000000,10000000000
  ;Dc.d 100000000000,1000000000000,10000000000000,100000000000000


facts:
  Dc.l $80000041
  Dc.l $A0000044
  Dc.l $C8000047
  Dc.l $FA00004A
  Dc.l $9C40004E
  Dc.l $C3500051
  Dc.l $F4240054
  Dc.l $98968058
  Dc.l $BEBC205B
  Dc.l $EE6B285E
  Dc.l $9502F962
  Dc.l $BA43B765
  Dc.l $E8D4A568
  Dc.l $9184E76C
  Dc.l $B5E6A96F
  Dc.l $E35F2972
  Dc.l $8E1BCA76
  Dc.l $B1A2BD79
  Dc.l $DE0B6C7C


atoi:                                                      ;fetchdec org source
  MOVEQ.l #$01,D5

 atoi__loop:
  LSL.l #1,D5
  MOVE.l D5,D1
  LSL.l #2,D5
  ADD.l D1,D5                                              ;divisor for frac convert!
  LSL.l #1,D3
   BCS.w overerr
  MOVE.l D3,D1
  LSL.l #1,D3
   BCS.w overerr
  LSL.l #1,D3
   BCS.w overerr
  ADD.l D1,D3
  SUBI.w #$30,D0
  ADD.l D0,D3
   !fget                                                   ;bsr.w get1bytemain
   CMP.b #1,d0
   BNE 'cm1
   SUBQ.l #1,a5
   BSR get1bytemain                                        ;??wy not !fget

 'cm1
  CMP.b #$7e,d0
   BNE 'cm2
   SUBQ.l #1,a5
   BSR get1bytemain

 'cm2
  TST.b d0
   BPL 'l10
   LSL.w #8,d0
   MOVE.b (a5)+,d0
   MOVE.w d0,lastchar

 'l10
  !compare2                                                ;bsr.w tstnum ;cmake bug
   BEQ.w atoi__loop
RTS


dfetch:  Ds.w 1                                            ;fetching data?


JL_0_B3DC:
  MOVE.w dfetch(PC),D1
   BEQ.w JL_0_B3EC
  CLR.w dfetch
RTS
                                                         ;1 number value write
JL_0_B3EC:
  MOVE.b d2,isconstantvalue
  MOVE.l d0,lastconstantvalue
  MOVE.w d2,imm_size
  MOVE.w regnum,imm_reg
  MOVE.l destpointer,imm_addr                           ; long
  CMP.w #$3,D2
  BEQ.w JL_0_B434
  CMP.w #$5,D2                                          ;float
  BEQ.w JL_0_B434
  CMP.w #$1,D2
  BEQ.w JL_0_B418
  CMP.w #$2,D2
  BEQ.w JL_0_B418
  CMP.w #$4,D2
  BEQ.w JL_0_B434

BRA.w mismatcherr

 JL_0_B418:
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$303C,D1
   BSR.w writeword
  MOVE.w D0,D1
   BSR.w writeword
BRA.w reget

 JL_0_B434:
  MOVEQ #0,d1
  MOVE.w regnum,D1
  TST.b fpu
  BEQ 'f1
  CMP.w #5,d2
  BEQ 'l10
BRA 'f2

 'f1
  TST.b iee
  BNE 'l10

 'f2
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1
   BSR.w writeword
  MOVE.l D0,D1
   BSR.w writelong
BRA.w reget

 'l10                                                      ;fpu constant
  MOVEQ #5,d2
  ASL.l #7,d1
  SUBQ.l #8,a7
  CNIF #64bitconstant
      OR.l #$f23c5400,d1                                   ;fmove.d
      fmove.d fp0,0(a7)
  CELSE
      OR.l #$f23c4400,d1                                   ;fmove.s
       fmove.s fp0,0(a7)
  CEND
  BSR writelong
  MOVE.l (a7)+,d1
  BSR writelong
  MOVE.l (a7)+,d1
  CNIF #64bitconstant
      BSR writelong
  CEND
BRA.w reget


;-----------end of number fetch-------------;

JL_0_B450:
 MOVE.l D3,D0
  TST.w D6
   BEQ.w JL_0_B46C
  MOVEA.l _mathffpbase,A6
   JSR -$1E(A6)
   BVC.w JL_0_B46C
  ADDQ.w #4,A7
BRA.w JL_0_B5A0

 JL_0_B46C:
RTS


JL_0_B46E:
  MOVEQ.l #$00,D6
   fmove.l d3,fp0

 nofpregload
  BSR.w JL_0_B480
BRA.w JL_0_B3DC

 JL_0_B478:
  MOVE.w D2,-(A7)
   BSR.w JL_0_BF6A
  MOVE.w (A7)+,D2

 JL_0_B480:
  TST.w D2
   BNE.w JL_0_B498
  TST.w D6
   BEQ.w JL_0_B492
  MOVEQ.l #$04,D2
BRA.w JL_0_B510

 JL_0_B492:
  MOVEQ.l #$02,D2
BRA.w JL_0_B4C4

 JL_0_B498:
  CMP.w #$1,D2
   BEQ.w JL_0_B4C4
  CMP.w #$2,D2
   BEQ.w JL_0_B4F8
  CMP.w #$3,D2
   BEQ.w JL_0_B57A
  CMP.w #$4,D2
   BEQ.w JL_0_B506
  CMP.w #$5,D2
   BEQ.w JL_0_B586
BRA.w mismatcherr

 JL_0_B4C4:
  BSR.w JL_0_B450                                          ;bugfix if a.b=$90 bug fix
  CMP.l #$7f,D0
   BGT.w JL_0_B4DC
  CMP.l #$FFFFFF80,D0
   BGE.w JL_0_B59E

 JL_0_B4DC:
  MOVEQ.l #$02,D2                                          ;was 2 before
  CMP.l #$7fff,D0
   BGT.w JL_0_B4F2
  CMP.l #$FFFF8000,D0
   BGE.w JL_0_B59E

 JL_0_B4F2:
  MOVEQ.l #$03,D2
BRA.w JL_0_B59E

; errorbytes2                                                ;??looks like not used anymore
;JMP errorbytes


; JL_0_B4C4:                                                ;??looks like old doubled code??
;  BSR.w JL_0_B450                                          ;if a.b=$90 bug
;  CMP.l #$7F,D0
;   BGT.w JL_0_B4DC
;  CMP.l #$FFFFFF80,D0
;   BGE.w JL_0_B59E

; JL_0_B4DC:
;   MOVEQ.l #$02,D2
;  CMP.l #MaxWordSgnd,D0
;   BGT.w JL_0_B4F2
;  CMP.l #$FFFF8000,D0
;   BGE.w JL_0_B59E

; JL_0_B4F2:
;  MOVEQ.l #$03,D2
;BRA.w JL_0_B59E


 JL_0_B4F8:
  TST.w D6
   BNE.w JL_0_B510
   BSR.w JL_0_B450
BRA.w JL_0_B4DC

 JL_0_B506:
  BSR.w JL_0_B450
  TST.w D6
  BEQ.w JL_0_B560

 JL_0_B510:
  CMP.l #MaxWordSgnd,D0
   BGT.w JL_0_B5A0
  CMP.l #$FFFF8000,D0
   BLT.w JL_0_B5A0
  MOVE.w D0,-(A7)
   JSR -$24(A6)
  MOVE.l D0,D1
  MOVE.l D3,D0
   JSR -$48(A6)
  MOVE.l #$80000051,D1
   JSR -$4E(A6)
   JSR -$1E(A6)
   BEQ.w JL_0_B55A
  CMP.l #$10000,D0
   BCC.w JL_0_B55A
  MOVE.w D0,D1
  MOVE.w (A7)+,D0
  SWAP D0
  MOVE.w D1,D0
BRA.w JL_0_B59E

 JL_0_B55A:
  ADDQ.w #2,A7
BRA.w JL_0_B5A0

 JL_0_B560:
  CMP.l #MaxWordSgnd,D0
   BGT.w JL_0_B4F2
  CMP.l #$FFFF8000,D0
   BLT.w JL_0_B4F2
  SWAP D0
BRA.w JL_0_B59E

 JL_0_B57A:
  TST.w D6
  BNE.w JL_0_B5A0
  MOVE.l D3,D0
BRA.w JL_0_B59E

 JL_0_B586:
  TST.w D6
  BNE.w JL_0_B5A0
  MOVE.l D3,D0
  MOVEA.l _mathffpbase,A6
  JSR -$24(A6)
  MOVE.l D0,D3
BRA.w JL_0_B5A0

 JL_0_B59E:
RTS

 JL_0_B5A0:
  MOVEQ.l #$05,D2
  MOVE.l D3,D0
RTS


;pushfrom:                                                 :??Looks like not used??
            Ds.l 1                                         ;??Looks like unused data??
pushpc:     Ds.l 1
pushoff:    Ds.l 1
pushdooff:  Ds.l 1
pushclen:   Ds.w 1
pushat:     Ds.l 1


pushstart:
  MOVE.l destpointer,pushpc
  MOVE.l hunkoffsetbase,pushoff
RTS


JL_0_B5D2:
  MOVEM.l D0-D1/A0-A1,-(A7)
  MOVE.l destpointer,D0
  MOVE.l pushpc(PC),D1
  MOVE.l D1,destpointer
  SUB.l D1,D0
  MOVE.w D0,pushclen
   BEQ.w JL_0_B636
  MOVE.w dontwrite,D1
   BNE.w JL_0_B636
   CMP.w #1000,pushclen
   BGE conmemerr
   MOVE.l pushat,d0
   BNE 'nomem
   MOVE.l #1024,d0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C
  MOVE.l D0,pushat

 'nomem
  MOVEA.l D0,A0
  MOVEA.l pushpc,A1
  MOVE.l A1,destpointer
  MOVE.w pushclen,D0
  LSR.w #1,D0
  SUBQ.w #1,D0

 JL_0_B626:
    MOVE.w (A1)+,(A0)+
  DBF D0,JL_0_B626

   MOVE.l hunkoffsetbase,pushdooff

 JL_0_B636:
  MOVEM.l (A7)+,D0-D1/A0-A1
RTS


JL_0_B63C:
  MOVEM.l D0-D1/A0-A1,-(A7)
  MOVEQ.l #$00,D0
  MOVE.w pushclen,D0
   BEQ.w JL_0_B6D8
  MOVE.l destpointer,D1
  ADD.l D0,destpointer
  TST.w dontwrite
   BNE.w JL_0_B6D8
  LSR.w #1,D0
  SUBQ.w #1,D0
  MOVEA.l D1,A1
  MOVEA.l pushat,A0

 JL_0_B66E:
    CMPA.l destbufferend,A1
    BCS.w JL_0_B684

    MOVE.w #$FFFF,dontwrite
  BRA.w JL_0_B6D8

   JL_0_B684:
     MOVE.w (A0)+,(A1)+                                    ;copylibcode
  DBF D0,JL_0_B66E

  SUB.l pushpc,D1
  BEQ.w JL_0_B6C2
  MOVEA.l pushdooff,A0

 JL_0_B69A:
  CMPA.l pushoff,A0
  BEQ.w JL_0_B6C2
  MOVEA.l $4(A0),A1
  ADDA.l destbufferstart,A1
  CMPA.l destbufferend,A1
  BCC.w JL_0_B6BC
  ADD.l D1,$4(A0)

 JL_0_B6BC:
  MOVEA.l (A0),A0
BRA.w JL_0_B69A

 JL_0_B6C2:
  MOVEA.l pushat,A1
  MOVEQ.l #$00,D0
  MOVE.w pushclen,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
   ;JSR _FreePooled(A6)

 JL_0_B6D8:
  MOVEM.l (A7)+,D0-D1/A0-A1
RTS

JL_0_B6DE:
  MOVE.l D1,-(A7)                                          ;array mul
  MOVEQ.l #$00,D2
  MOVEQ.l #$0F,D3

 JL_0_B6E4:
    LSL.w #1,D1
    BCC.w JL_0_B6EE
    ADDQ.w #1,D2
    MOVE.w D3,D4

   JL_0_B6EE:
  DBF D3,JL_0_B6E4

  SUBQ.w #1,D2
   BNE.w JL_0_B726
  ADDQ.w #4,A7
  MOVE.w D4,D1
   BEQ.w JL_0_B724
  CMP.w #$8,D1
   BCS.w JL_0_B712
  SUBI.w #$8,D1
   BSR.w JL_0_B712
  MOVEQ.l #$00,D1

 JL_0_B712:
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$E188,D1
  OR.w regnum,D1
BRA.w writeword

 JL_0_B724:
RTS

 JL_0_B726:
  MOVEQ #0,d1
  MOVE.w regnum,D1
  LSL.l #8,D1
  ;LSL.l #1,D1
  LSL.l #4,d1
  ;ORI.w #$C0FC,D1
  OR.l #$4c3c0000,d1
  OR.w regnum,d1
  BSR.w writelong
  MOVE.l (A7)+,D1
 ;BRA.w writeword
BRA writelong

 JL_0_B73E:
  MOVE.l destpointer,-(A7)
  MOVEQ.l #-$01,D7

 JL_0_B746:
    BSR.w findhilib
     BEQ.w JL_0_B8A4
    TST.w $C(A2)
     BPL.w JL_0_B746

    MOVE.l $16(A2),D1
    BEQ.w JL_0_B746

    MOVE.w $4(A2),D1                                       ; check state in D1 and do some things
    CMP.w #-$2,D1
     BNE.w JL_0_B772
    BSR.w makevsize
BRA.w JL_0_B7FE

 JL_0_B772:
    CMP.w #-$5C4,D1
     BNE.w JL_0_B790
    MOVE.w #$7000,D1
    BTST #$7,autorun
    SNE D1
    BSR.w writeword
BRA.w JL_0_B7FE

 JL_0_B790:
    CMP.w #-$12D,D1
     BNE.w JL_0_B7A0
    BSR.w makessize
BRA.w JL_0_B7FE

 JL_0_B7A0:
    CMP.w #-$1F5,D1
     BNE.w JL_0_B7C2
    MOVE.w #$203C,D1
    BSR.w writeword
    BSR.w addoff
    MOVE.l endop,D1
    BSR.w writelong
BRA.w JL_0_B7FE

 JL_0_B7C2:
    CMP.w #-$3E9,D1
     BNE.w JL_0_B7E4
    MOVE.w #$203C,D1
    BSR.w writeword
    BSR.w addoff
    MOVE.l data2at,D1
    BSR.w writelong
BRA.w JL_0_B7FE

 JL_0_B7E4:
    CMP.w #$1,D1
     BNE.w JL_0_B7FE
    MOVE.w #$203C,D1
    BSR.w writeword
    MOVE.l ptr_seg_debugger,D1
    BSR.w writelong

 JL_0_B7FE:
    MOVE.l $16(A2),D1
    MOVE.w #$FFFF,lasta6
    BSR.w Amakelibsub
    CMPI.w #$FFFE,$4(A2)
     BNE.w JL_0_B83A
    MOVE.l intdata1,D1
     BEQ.w JL_0_B83A
    MOVE.w putidata1,D1
    BSR.w writeword
    BSR.w addoff
    MOVE.l intdata1,D1
    BSR.w writelong

 JL_0_B83A:
    MOVE.w #$2B40,D1
    TST.w $1A(A2)
     BEQ.w JL_0_B746
     BPL.w JL_0_B84E
    MOVE.w #$3B40,D1

 JL_0_B84E:
    BSR.w writeword
    MOVE.w $A(A2),D1
     BSR.w writeword
    CMPI.w #$FFFA,$4(A2)
     BNE.w JL_0_B746
    MOVE.w D7,-(A7)
    MOVE.w numstatic,D4
     BEQ.w JL_0_B882
    MOVE.l staticdata,D3
     BSR.w datastart
    MOVE.w #$C500,D1
     BSR.w tokejsr2

 JL_0_B882:
    MOVE.w maxsused,D4
     BEQ.w JL_0_B89E
    MOVE.l maxsat,D3
     BSR.w datastart
    MOVE.w #$CF00,D1
     BSR.w tokejsr2

 JL_0_B89E:
    MOVE.w (A7)+,D7
BRA.w JL_0_B746

 JL_0_B8A4:
  MOVE.l destpointer,D1
  CMP.l (A7),D1
   BNE.w JL_0_B8BC
  MOVE.w #$0008,noinits+2
BRA.w JL_0_B8E6

 JL_0_B8BC:
  CLR.w noinits+2
  MOVE.w dontwrite,D1
   BNE.w JL_0_B8DE
  TST.l newinitaddr
   BEQ 'l10
  MOVE.l newinitaddr,D2
  SUB.l destbufferstart,D2
  ADDQ.l #2,d2
  MOVEA.l newinitaddr,A0                                   ;write newinitcode
  ;MOVE.w #$2f00,(a0)+
  MOVE.w #$4EB9,(A0)+
  MOVE.l (A7),(A0)+
  ;MOVE.l #$202f0048,(a0)
BRA 'l20

 'l10
  MOVEA.l destbufferstart,A0                               ;write initcode
  TST.b saved0
  BEQ 'l1
  MOVE.w #$23c0,(a0)+
  MOVE.l a0,a1
  ADDQ.l #6,a1
  MOVE.l a1,(a0)+
  MOVEQ.l #$02,D2
  BSR.w addhunkoffset
  MOVE.w #$6004,(a0)+
  MOVE.l #$4e714e71,(a0)+

 'l1
  MOVE.w #$4EB9,(A0)+
  MOVE.l (A7),(A0)+
  MOVEQ #2,d2
  TST.b saved0
  BEQ 'l20
  MOVEQ.l #14,D2

 'l2
  BSR.w addhunkoffset
  MOVE.w #$2039,(a0)+
  MOVE.l a1,(a0)+
  MOVEQ.l #20,d2

 'l20
  BSR.w addhunkoffset

 JL_0_B8DE:
  MOVE.w #$4E75,D1
  BSR.w writeword

 JL_0_B8E6:
  ADDQ.w #4,A7
RTS


;------                                                  ;disassembled code begin
;prepd1:                                                   ;??looks like label not used??
  Dc.b $22,$2D,$00,$00                                     ;MOVE.L  $0000(A5),D1
putidata1:
  Dc.b $23,$CD,$00,$00,$00,$00                             ;MOVE.L  A5,$00000000
;prepint:                                                  ;??looks like label not used??
  Dc.b $24,$7C,$00,$00,$00,$00                             ;MOVEA.L #$00000000,A2
;------                                                  ;disassembled code end
Even

makessize:
  MOVE.l stringbuffer,D1
BRA.w makesize

 makevsize:
  MOVEQ.l #$00,D1
  MOVE.w globalvarpointer,D1
  SUBI.w #$8000,D1
  BNE.w makesize
    MOVEQ.l #$08,D1

 makesize:
  MOVE.l D1,-(A7)
  MOVE.w #$203C,D1
  BSR.w writeword
  MOVE.l (A7)+,D1
BRA.w writelong


findhilib:
    ;find highest lib# under d7. set d7 to this lib number
    ;
    ;ne if found, eq if not
    ;
  MOVEQ.l #$00,D1
  MOVEA.l libpointer,A1

 findhilib__loop:
    CMPA.w #$0,A1
    BEQ.w findhilib__done
      CMP.w $4(A1),D7
      BLS.w findhilib__next
        CMP.w $4(A1),D1
        BCC.w findhilib__next
          MOVE.w $4(A1),D1
          MOVEA.l A1,A2

 findhilib__next:
    MOVEA.l (A1),A1
BRA.w findhilib__loop

 findhilib__done:
  MOVE.w D1,D7
RTS


findlolib:
    ;find lowest lib# above d7. set d7 to this lib number
    ;
    ;ne if found, eq if not
    ;
  MOVEQ.l #-$01,D1
  MOVEA.l libpointer,A1

 findlolib__loop:
    CMPA.w #$0,A1
     BEQ.w findlolib__done
    CMP.w $4(A1),D7
     BCC.w findlolib__next
    CMP.w $4(A1),D1
     BLS.w findlolib__next
    MOVE.w $4(A1),D1
    MOVEA.l A1,A2

 findlolib__next:
    MOVEA.l (A1),A1
BRA.w findlolib__loop

 findlolib__done:
  MOVE.w D1,D7
  CMP.w #-$1,D1
RTS


JL_0_B98A:
  ADDQ.w #1,globalvarpointer
  BCLR #$0,globalvarpointer+1
  MOVEQ.l #$00,D7

 JL_0_B99A:
    BSR.w findlolib
    BEQ.w JL_0_BA74
    TST.w $C(A2)
    BPL.w JL_0_B99A
    MOVEA.l A2,A1
    ADDA.l $12(A1),A1
    TST.w -$2(A1)
    BEQ.w JL_0_BA34
    MOVE.l -$A(A1),D1
    LEA $6(A2,D1.L),A3

 JL_0_B9C0:
      TST.w (A3)+
      BEQ.w JL_0_B9CC
        ADDQ.w #2,A3
BRA.w JL_0_B9C0

 JL_0_B9CC:
    TST.l $4(A3)
    BEQ.w JL_0_BA34
      MOVE.w freemax(PC),D1
      BSR.w writeword
      MOVE.w -$4(A1),D1
      BSR.w writeword
      MOVE.l free,D1
      MOVE.w -$6(A1),D1
      BSR.w writelong
      MOVE.l destpointer,-(A7)
      MOVEQ.l #$01,D1
      MOVE.w -$2(A1),D2
      LSL.w D2,D1
      MOVE.w D1,-(A7)
      MOVE.l -$A(A1),D1
      BSR.w Amakelibsub
      MOVE.w freemax3(PC),D1
      BSR.w writeword
      MOVE.w (A7)+,D1
      BSR.w writeword
      MOVE.l freemax2(PC),D1
      BSR.w writelong
      MOVE.l (A7)+,D1
      SUB.l destpointer,D1
      BSR.w writeword
      MOVE.w freemax4(PC),D1
      BSR.w writeword

 JL_0_BA34:
    MOVE.l $1C(A2),D1
    BEQ.w JL_0_B99A

    MOVE.w $4(A2),D1
    CMP.w #-$2,D1
    BNE.w JL_0_BA50
      BSR.w makevsize
BRA.w JL_0_BA60

 JL_0_BA50:
    CMP.w #-$12D,D1
    BNE.w JL_0_BA60
      BSR.w makessize
BRA.w JL_0_BA60

 JL_0_BA60:
    MOVE.l $1C(A2),D1
    MOVE.w #$FFFF,lasta6
    BSR.w Amakelibsub
BRA.w JL_0_B99A

 JL_0_BA74:
RTS


;------                                                  ;disassembled code begin
freemax:   Dc.b $3F,$3C,$00,$00                            ;MOVE.W  #$0000,-(A7)

freemax2:  Dc.b $53,$57                                    ;SUBQ.W  #1,(A7)
           Dc.b $66,$00,$FF,$FC                            ;BNE.W freemax2
freemax4:  Dc.b $54,$4F                                    ;ADDQ.W  #2,A7
freemax3:  Dc.b $47,$EB,$00,$00                            ;LEA $0000(A3),A3
;------                                                  ;disassembled code end

Even
chkstak:
  TST.b debugmode
   BEQ.b chkstak__skip
  TST.w debugversion
   BNE.b chkstak__skip
  MOVE.w #$C308,D1
BRA.w Atokejsr

 chkstak__skip:
RTS


tokejsr2:
  MOVE.w #$FFFF,lasta6

 Atokejsr:                                                 ;tokejsr org source
    ;make a jsr (or simple reg get) from d1
    ;
  MOVEM.l D0-d7/A0-a6,-(A7)
  MOVE.b #1,nostringopt
  JSR searchinstr
  MOVE.l A3,D1
  SUB.l A2,D1
  BSR.w Amakelibsub
  MOVEM.l (A7)+,d0-d7/a0-a6
RTS


userjsr:
    ;a2 = lib base
    ;a1 = start of #parameters
    ;
  MOVE.l libisat,-(A7)                                   ;library write
  MOVE.l A2,libisat

  MOVEA.l A1,A2
  MOVE.w (A2)+,D1
  MOVE.l a2,lastinstructionaddr
  ANDI.w #$FF,D1
  ADDA.w D1,A2
  EXG.l D0,A2
  ADDQ.l #1,D0
  BCLR #$0,D0
  EXG.l D0,A2
BRA.w JL_0_BB08


cutejsr:
  MOVE.l libisat,-(A7)
  MOVE.l A2,libisat
  MOVEA.l A3,A2
BRA.w JL_0_BB08


scantype
  MOVE.l a1,-(a7)

 'more
  MOVE.l d0,a0
  MOVE.l $a(a0),d0
  MOVE.l d0,a1
  CMP.l #8,4(a1)
  BLE 'norec
  MOVE.l a0,-(a7)
  MOVE.l typebase,-(a7)
  MOVEQ #0,d0
  MOVE.w 4(a0),d0
  ADD.l d0,typebase
  MOVE.l $4(a1),d0
  BSR scantype
  MOVE.l (a7)+,typebase
  MOVE.l (a7)+,a0

 'norec
  CMP.l #newtype_string,d0
  BNE 'nostring
  ADDQ #2,a2offset
  MOVE.l #$3f3c0000,d1
  MOVEQ #0,d0
  MOVE.w 4(a0),d0
  ADD.l typebase,d0
  MOVE.w d0,d1
  BSR writelong
  TST.b debugmode
  BEQ 'l1a
  MOVE.l d1,-(a7)
  MOVE.l #$c308,d1
  JSR Atokejsr
  MOVE.l (a7)+,d1

 'l1a
  TST.w 8(a0)
  BEQ 'nostring
  MOVEM.l d2/d3,-(a7)
  MOVE.l d1,d2
  MOVEQ #0,d3
  MOVE.w 8(a0),d3
  SUBQ.l #1,d3
  BEQ 'nostring2

 'loop
  ADDQ.l #4,d2
  MOVE.l d2,d1
  BSR writelong
  TST.b debugmode
  BEQ 'l1
  MOVE.l #$c308,d1
  JSR Atokejsr

 'l1
  ADDQ #2,a2offset
  SUBQ.l #1,d3
  BNE 'loop

 'nostring2
  MOVEM.l (a7)+,d2/d3

 'nostring
  MOVE.l (a0),d0
  BNE 'more
  MOVE.l (a7)+,a1
RTS


libisat:   Ds.l 1


Amakelibsub:                                               ;makelibsub org source
    ;lib in a2, sub offset in d1
    ;
  MOVE.l libisat,-(A7)                                   
  MOVE.l A2,libisat
  LEA $6(A2,D1.L),A2

 JL_0_BB08:                                                ;??Look like double label??
 .writetype
  CMP.l #$3e19436c,$1c-8(a2)                               ;clear type
  BEQ 'dowritevar
  CMP.l #$3e18436f,$1c-8(a2)                               ;copy type
  BEQ 'dowritevar
  CMP.l #$3e175265,$1c(a2)
  BEQ 'dowritevar
  CMP.l #$3e165772,$1c(a2)
  BNE 'nowritef

 'dowritevar
  MOVEM.l a0-a2/d2,-(a7)
  MOVEQ #0,d1
  MOVE.l #0,typebase
  MOVE.l $a(a3),a0
  MOVE.l $4(a0),d0
  CMP.l #8,d0
  BLE 'notype
  BSR scantype

 'notype:
  MOVE.l #$3f3c0000,d1
  MOVE.w a2offset,d1
  BSR writelong
  MOVE.l #$3f3c0000,d1
  MOVE.l $a(a3),a0
  MOVE.w 8(a0),d1
  BSR writelong
  MOVE.l #$3f3cab12,d1
  BSR writelong
  ADDQ.w #6,a2offset
  MOVEM.l (a7)+,a0-a2/d2

 'nowritef
  TST.b fpu
  BEQ 'nofpu2
  CMP.l #$496e7400,$1a(a2)
  BNE 'noint
  MOVEQ #0,d1
  SUBQ.l #8,destpointer                                    ;fpu int
  CLR.w a2offset
  CMP.b #2,d2
  BGT 'noword
  MOVE.w #$48c0,d1
  OR.w regnumstore,d1
  BSR writeword
BRA 'exit2

 'noword
   CMP.b #3,d2
        BNE 'nolong
BRA 'exit2

 'nolong
   CMP.b #4,d2
        BNE 'noquick
        MOVE.w #$e080,d1
        OR.w regnumstore,d1
        BSR writeword
        MOVE.w #$e080,d1
        OR.w regnumstore,d1
        BSR writeword
BRA 'exit2

 'noquick
        MOVEQ #0,d0
        MOVEQ #0,d1
        MOVE.w regnumstore,d0
        ASL.l #7,d0
        OR.l #$f23c4428,d1                                 ;fsub.s 0.5,fpx
        OR.l d0,d1
        ;BSR writelong
        MOVE.l #$3f000000,d1
        ;BSR writelong
        MOVEQ #0,d0
        MOVEQ #0,d1
        MOVE.w regnumstore,d0
        ASL.l #7,d0
        MOVE.l d0,d1
        OR.l #$f2000003,d1                                 ;fintrz fpx
        ASL.l #3,d0
        OR.l d0,d1
        BSR writelong
        MOVEQ #0,d0
        MOVE.w regnumstore,d0
        ASL.l #7,d0
        MOVE.l #$f2006000,d1                               ;fmove.l fp0,d0
        OR.l d0,d1
        ASL.l #1,d0
        ASL.l #8,d0
        OR.l d0,d1
BRA 'exit

 'noint
  CMP.w #$3c01,24(a2)
  BNE 'noval
  MOVE.l a2,-(a7)
  BSR.w JL_0_BB14
  MOVE.l (a7)+,a2
BRA 'exit2

;  MOVE.l (a7),a2
;  MOVE.w (a2),-(a7)                                        ;fpu val
;  MOVE.w #$c0,(a2)
;  BSR.w fetchregs
;  MOVE.l #$4eaeff9a,d1                                     ;SPtieee
;  BSR writelong
;  MOVE.l 2(a7),a2
;  MOVE.w (a7)+,(a2)
;  MOVE.l (a7)+,a2
;  MOVE.l #$4a876604,d1
;  BSR writelong
;  MOVE.l #$f2004400,d1                                     ;fmove.s d0,fp0
;BRA 'exit

 'noval
  CMP.l #$41627300,$1a(a2)
  BNE 'noabs
  MOVEQ #0,d1
  MOVE.w regnumstore,d1
  MOVE.w d1,d0
  ASL.w #7,d1
  ASL.w #8,d0
  ASL.w #2,d0
  OR.w d0,d1
  SUBQ.l #8,destpointer                                    ;fpu abs
  MOVEM.l d3/d1,-(a7)
  MOVE.w #5,d3
  EXG d2,d3
  MOVE.w regnum,-(a7)
  MOVE.w regnumstore,regnum
  BSR writeconvertcode
  MOVE.w (a7)+,regnum
  EXG d2,d3
  MOVEM.l (a7)+,d3/d1
  OR.l #$f2000018,d1
  CLR.w a2offset
BRA 'exit

 'noabs
  CMP.b #5,d2
  BNE 'nofpu2
  MOVE.b 24(a2),d0
  CMP.b #$60,d0                                            ;nolib $edxx
  BNE 'nofpu
  MOVEQ #0,d1
  MOVE.w regnumstore,d1
  MOVE.w d1,d0
  ASL.w #7,d1
  ASL.w #8,d0
  ASL.w #2,d0
  OR.w d0,d1
  MOVE.b 25(a2),d0
  CMP.b #5,d0
  BNE 'nocos
  OR.l #$f200001d,d1                                       ;fpu cos
BRA 'exit

 'nocos
  CMP.b #$c,d0
  BNE 'nosqr
  OR.l #$f2000004,d1                                       ;fpu sqr
BRA 'exit

 'nosqr
  CMP.b #$d,d0
  BNE 'notan
  OR.l #$f200000f,d1                                       ;fpu tan
BRA 'exit

 'notan
  CMP.b #$a,d0
  BNE 'nosin
  OR.l #$f200000e,d1                                       ;fpu sin
BRA 'exit

 'nosin
  CMP.b #$3,d0
  BNE 'noasin
  OR.l #$f200000c,d1                                       ;fpu asin
BRA 'exit

 'noasin
  CMP.b #$2,d0
  BNE 'noacos
  OR.l #$f200001c,d1                                       ;fpu acos
BRA 'exit

 'noacos
  CMP.b #$4,d0
  BNE 'noatan
  OR.l #$f200000a,d1                                       ;fpu atan
BRA 'exit

 'noatan
  CMP.b #$e,d0
  BNE 'nohtan
  OR.l #$f2000009,d1                                       ;fpu htan
BRA 'exit

 'nohtan
  CMP.b #$6,d0
  BNE 'nohcos
  OR.l #$f2000019,d1                                       ;fpu hcos
BRA 'exit

 'nohcos
  CMP.b #$b,d0
  BNE 'nohsin
  OR.l #$f2000002,d1                                       ;fpu hsin
BRA 'exit

 'nohsin
  CMP.b #$9,d0
  BNE 'nolog
  OR.l #$f2000014,d1                                       ;fpu log
BRA 'exit

 'nolog
  CMP.b #$8,d0
  BNE 'nolog10
  OR.l #$f2000015,d1                                       ;fpu log10
BRA 'exit

 'nolog10
  CMP.b #$7,d0
  BNE 'noexp
  OR.l #$f2000010,d1                                       ;fpu exp
BRA 'exit

 'noexp
  LEA fpuerr,a0
  MOVE.l a0,-(a7)
JMP handle_compileerror
;BRA 'exit                                                  ;??Looks like unneeded code??

 'nofpu
  CMP.b #$3c,d0
  BNE 'nofpu2
  MOVEQ #0,d1
      MOVE.w regnumstore,d1
      MOVE.w d1,d0
      ASL.w #7,d1
      ASL.w #8,d0
      ASL.w #2,d0
      OR.w d0,d1
      CMP.b #$03,25(a2)
      BNE 'nosgn
;BRA 'noexp

      SUBQ.l #8,destpointer                                ;fpu sgn
        OR.l #$f200003a,d1
        BSR writelong
        CLR.w a2offset
         MOVE.l #$F28E0006,d1
         BSR writelong
  MOVE.l #$7000600a,d1
  BSR writelong
  MOVE.l #$70014840,d1
  BSR writelong
  MOVE.l #$F292,d1
  BSR writeword
  MOVE.l #$000470FF,d1
BRA 'exit

 'nosgn
  CMP.l #"Frac",$1a(a2)
  BNE 'nofrac
JMP notwork

;        MOVE.l d0,-(a7)
;        MOVEQ #0,d1
;        MOVE.w regnumstore,d1
;        ASL.w #7,d1
;        OR.l #$f23c4428,d1
;        ;OR.l #$f2000380,d1
;        BSR writelong                                      ;fsub.s #-0.5,fp0
;        MOVE.l #$3f000000,d1
;        BSR writelong
;        MOVE.w regnumstore,d1
;        ASL.l #8,d1
;        ASL.l #8,d1
;        OR.l #$f2006000,d1                                 ;fmove.l fp0,d0
;        MOVE.w regnumstore,d0
;        ASL.w #7,d0
;        OR.w d0,d1
;        ;OR.l #$f2000380,d1                                 ;fmove.x fpx,fp7
;        BSR writelong
;        ;MOVE.l #$f2001f83,d1                              ;fintrz,fp7
;        ;BSR writelong
;        MOVEQ #0,d1
;        MOVE.w regnumstore,d1
;        ASL.w #7,d1
;        OR.l #$f23c4422,d1
;
;        BSR writelong                                      ;fadd.s #-0.5,fp0
;        MOVE.l #$3f000000,d1
;        BSR writelong
;        MOVEQ #0,d1
;        MOVE.w regnumstore,d1
;        ASL.l #8,d1
;        ASL.l #8,d1                                        ;fsub.l d0,fp0
;        OR.l #$f2004028,d1
;        MOVE.w regnumstore,d0
;        ASL.w #7,d0
;        OR.w d0,d1
;        ;SUBQ.l #8,destpointer                              ;fpu frac
;        CLR.w a2offset
;        MOVE.l (a7)+,d0
BRA 'exit

 'nofrac                                                   ;??Looks like double label??
 'nofpu2
  BSR.w JL_0_BB14                                          ;write lib code
  MOVE.l (A7)+,libisat
RTS

 'exit
  BSR writelong

 'exit2
  MOVE.l (A7)+,libisat
RTS


JL_0_BB14:
  BSR.w fetchregs
  TST.b debugmode
   BEQ.w JL_0_BB76
  MOVE.l (A2),D1
  OR.l $8(A2),D1
  BCLR #$0,D1
  TST.l D1
   BEQ.w JL_0_BB76
  MOVE.l (A2)+,D1
  BTST #$0,D1
   BEQ.w JL_0_BB60
  TST.w blitzmode
   BPL.w blitzerr
  TST.b debugmode
   BEQ.w JL_0_BB5C
  MOVE.l D1,-(A7)
  MOVE.w #$C311,D1
   BSR.w makebtst
  MOVE.l (A7)+,D1

 JL_0_BB5C:
  BCLR #$0,D1

 JL_0_BB60:
  TST.l D1
   BSR.w JL_0_BBC6
  MOVE.l (A2)+,D1
   BSR.w JL_0_BB98
  MOVE.l (A2)+,D1
   BSR.w JL_0_BBC6
BRA.w JL_0_BB90

 JL_0_BB76:
  BTST #$0,$3(A2)
   BEQ.w JL_0_BB88
  MOVE.w blitzmode(PC),D1
   BPL.w blitzerr

 JL_0_BB88:
  MOVE.l $4(A2),D1
   BSR.w JL_0_BB98

 JL_0_BB90:
  MOVEA.l libisat,A2
RTS

 JL_0_BB98:
  BTST #$0,D1
   BEQ.w JL_0_BBC4
  TST.w blitzmode
   BMI.w amigaerr
  TST.b debugmode
   BEQ.w JL_0_BBC0
  MOVE.l D1,-(A7)
  MOVE.w #$C312,D1
   BSR.w makebtst
  MOVE.l (A7)+,D1

 JL_0_BBC0:
  BCLR #$0,D1

 JL_0_BBC4:
  TST.l D1

 JL_0_BBC6:
   BEQ.w JL_0_BBD2
  MOVE.l A1,-(A7)
   BSR.w JL_0_BBD4
  MOVEA.l (A7)+,A1

 JL_0_BBD2:
RTS

 JL_0_BBD4:
  MOVEA.l libisat,A0
  TST.w cfetchmode
   BEQ.w JL_0_BBF6
  ADD.l A0,D1
  MOVE.l D1,-(A7)
  MOVE.w #$4EB9,D1
   BSR.w writeword
  MOVE.l (A7)+,D1
BRA.w writelong

 JL_0_BBF6:
  LEA $0(A0,D1.L),A1
  CLR.w inline

 JL_0_BC00:
  CMPI.b #$A0,(A1)+
   BNE.w JL_0_BC68
  TST.b (A1)+
   BEQ.w JL_0_BC18
  CMPI.b #$1,-$1(A1)
   BEQ.w JL_0_BC24

 JL_0_BC18:
  MOVE.w (A1)+,inline
  ADDQ.l #4,D1
BRA.w JL_0_BC00

 JL_0_BC24:
  TST.w blitzmode
   BPL.w JL_0_BC4A
  TST.b debugmode
   BEQ.w JL_0_BC40
  MOVE.w #$C311,D1
   BSR.w makebtst

 JL_0_BC40:
  MOVE.l (A1)+,D1
  LEA $0(A0,D1.L),A1
BRA.w JL_0_BC00

 JL_0_BC4A:
  TST.b debugmode
   BEQ.w JL_0_BC60
  MOVE.l D1,-(A7)
  MOVE.w #$C312,D1
   BSR.w makebtst
  MOVE.l (A7)+,D1

 JL_0_BC60:
  ADDQ.w #4,A1
  ADDQ.l #6,D1
BRA.w JL_0_BC00

 JL_0_BC68:
  TST.w inline
   BEQ.w JL_0_BC7E
  SUBQ.w #1,A1
  MOVEA.l A1,A0
  ADDA.w inline(PC),A1
BRA.w pokecode2

 JL_0_BC7E:
  MOVEM.l a0/D1,-(A7)
  TST.w debugversion
  BEQ 'l11
  BTST #$7,link_debuginfo
  BEQ.w 'l11
  MOVE.l lastinstruction,d1
  BEQ 'l11
  CLR.l lastinstruction
  CMP.l #$e000,d1
  BGE 'ln99
  LEA notf,a0
  CMP.l #$c601,d1
  BNE 'ln1
  LEA strcpy,a0
BRA 'ln3

 'ln1
  CMP.l #$c700,d1
  BNE 'ln2
  LEA strvar,a0
BRA 'ln3

 'ln2
  CMP.l #$ce00,d1
  BNE 'ln4
  LEA strcmp,a0
BRA 'ln3

 'ln4
  CMP.l #$ca00,d1
  BNE 'ln5
  LEA qmul,a0
BRA 'ln3

 'ln5
  CMP.l #$d000,d1
     BNE 'ln6
     LEA _MaxLen,a0
BRA 'ln3

 'ln6
  CMP.l #$cb00,d1
  BNE 'ln3
  LEA qdiv,a0
BRA 'ln3

 'ln99
  MOVE.l d1,a0
  LEA $8(a0),a0

 'l1
  CMP.w #$ffff,(a0)+
  BNE 'l1
  LEA 6(a0),a0

 'ln3
  MOVEM.l a1/a2/d7/d2,-(a7)
  MOVEQ #0,d2
  LEA ptr_parameterstore,a1

 'l2
  ADDQ.l #1,d2
  MOVE.b (a0)+,d0
  CMP.b #"$",d0                                         ;A label contain $ does not work for reassembler and assembler.it is replace with S
  BNE 'nodollar
  MOVE.b #"S",d0
'nodollar
  CMP.b #"?",d0
  BEQ 'nolabelwrite
  MOVE.b d0,(a1)+
  BNE 'l2
  MOVE.w #"__",-1(a1)
  ADDQ.l #2,d2
  CLR.b 1(a1)
  JSR findlabel2
  BEQ 'l3
  JSR addlabelhash

 'l3
  CLR.l 4(a2)
  MOVE.l $14(a7),a0
  MOVE.l $10(a7),d1
  SUB.l $12(a0),d1
  ADD.l $28(a0),d1
  MOVE.l d1,8(a2)
'nolabelwrite MOVEM.l (a7)+,a1/a2/d7/d2

 'l11                                                      ;peek/poke
  TST.b typecheck
  BEQ 'p1
  ;MOVE.l lasttoken,d1
  ;CMP.l #$da01,d1                                          ;poke
  ;BEQ 'lp1
  ;CMP.l #$da02,d1                                          ;peek
  ;BNE 'p1

 'lp1
  TST.b peekaddrsize
  BEQ 'p1
  CMP.b #3,peekaddrsize
  BNE errormsg_onlylong
  CLR.b peekaddrsize
;  BEQ 'p1

;'p2
;  CMP.w #3,lasttoken
;  BNE errormsg_onlylong

 'p1
   TST.b fpu
  BNE 'optf
  TST.b fast
  BEQ JL11a2


 'optf
  CNIF #optibreak
    ILLEGAL
  CEND
  CMP.l #"Poke",20(a2)                                     ;poke
  BNE peekopt
  TST.b 24(a2)
  BNE peekopt
  CMP.b #3,d2
  BNE 'lw1

 'll1
  MOVE.l #$21821990,d1
BRA.s 'lpx

 'lw1
  CMP.b #2,d2
  BNE 'lb1
  MOVE.l #$31821990,d1
BRA.s 'lpx

 'lb1
  CMP.b #1,d2
  BNE 'lp3
  MOVE.l #$11821990,d1
BRA.s 'lpx

 'lp3
  CMP.b #5,d2
    BNE JL11a2
    TST.b fpu
    BEQ 'll1
     MOVE.l destpointer,a4
    CMP.l #$f22d4500,-6(a4)
    BNE 'noglob
    TST.b doublepeek
    BNE 'noglob
    MOVE.w -2(a4),-4(a4)
    MOVE.w #$21ad,-6(a4)
    MOVE.w #$1990,-2(a4)
    MOVE.w #9,peeksize
    ADDQ #8,a7
RTS

 'noglob
    CMP.l #$f22c4500,-6(a4)
    BNE 'nolocal
    MOVE.w -2(a4),-4(a4)
    TST.b doublepeek                                       ;dont move longfix on double floats
    BNE 'nolocal
    MOVE.w #$21ac,-6(a4)
    MOVE.w #$1990,-2(a4)
    MOVE.w #9,peeksize
    ADDQ #8,a7
RTS

 'nolocal
    MOVE.w #$f230,d1
    BSR writeword
  MOVE.l #$65001990,d1
  TST.b doublepeek
  BEQ 'lpx
  OR.l   #$10000000,d1

 'lpx                                                      ;??Looks like double label??
 exitjsr
  ADDQ #8,a7
  MOVE.w #9,peeksize
BRA writelong

 peekopt
  CMP.l #"Peek",20(a2)
  BNE 'l10
  TST.b 24(a2)
  BNE 'l10
  CMP.w #7,peeksize
  BEQ 'l10
   CMP.w #3,peeksize
   BNE.s 'lw1

 'll1
  MOVE.l #$20301990,d1
BRA exitjsr

 'lw1
  CMP.w #2,peeksize
   BNE.s 'lb1
   MOVE.l #$30301990,d1
BRA exitjsr

 'lb1
  CMP.w #1,peeksize
   BNE.s 'lf1
   MOVE.l #$10301990,d1
BRA exitjsr

 'lf1
  CMP.w #5,peeksize
   BNE 'l10
   TST.b fpu
   BEQ 'll1
   MOVE.w #$f230,d1
   BSR writeword
   MOVEQ #0,d1
   MOVE.w tempregnum,d1
   ASL.l #7,d1
   ASL.l #8,d1
   ASL.l #8,d1
   ADD.l #$44001990,d1
    TST.b doublepeek
    BEQ 'lpx2
    OR.l   #$10000000,d1
 'lpx2
BRA exitjsr

 'l10                                                      ;??Looks like double label??
 JL11a2
  MOVE.w #$4EB9,D1
   BSR.w writeword                                         ;writesysjsr
  MOVEM.l (A7)+,a0/D1
   JSR addoff
  SUB.l $12(A0),D1
  ADD.l $28(A0),D1
BRA.w writelong
;RTS                                                        ;??Looks like unneeded code??


makebtst:
  MOVE.w D1,-(A7)
  MOVE.w tstmode(PC),D1
   BSR.w writeword
   BSR.w getbbase
   BSR.w writeword
  MOVE.w (A7)+,D1
  MOVEM.l D0/D3-D7/A0-A2/A4,-(A7)
   BSR.w Atokejsr
  MOVEM.l (A7)+,D0/D3-D7/A0-A2/A4
RTS


getbbase:
    ;this return returns varoff for blitzmode flag
    ;in d1
    ;it will create blitzoff if necessary
    ;
  MOVE.w blitzoff(PC),D1
  CMP.w #-$1,D1
   BNE.w getbbase__done
  ADDQ.w #1,globalvarpointer
  BCLR #$0,globalvarpointer+1
  MOVE.w globalvarpointer,D1
  MOVE.w D1,blitzoff
  ADDQ.w #2,globalvarpointer

 getbbase__done:
RTS


;------                                                  ;disassembled code begin
tstmode:    Dc.b $4A,$6D,$00,$00                           ;TST.W $0000(A5)
;------                                                  ;disassembled code end

inline:     Ds.w 1
blitzoff:   Dc.w $FFFF                                   ;-1 org source
blitzmode:  Ds.w 1                                       ;+=amiga, -=blitz

Even
fetchregs:
  MOVE.w (A2)+,D1
   BEQ.w fetchregs__done
  MOVE.w (A2)+,D2
   BSR.w toreg
BRA.w fetchregs

 fetchregs__done:
RTS

toreg:
    ;d1=lib num, d2.b=reg num
    ;
  CMP.w #-$100,D2
   BCC.w toreg__yeah
    ;
  BCLR #$F,D2
   BEQ.w toreg__nobm
    ;OK, blitz mode must be ON for us to bother doing this one
  TST.w blitzmode
   BMI.w toreg__yeah
RTS

 toreg__nobm:
  BCLR #$E,D2
   BEQ.w toreg__yeah
    ;OK, must be in amiga mode
  TST.w blitzmode
   BPL.w toreg__yeah
RTS

 toreg__yeah:
  JSR uselib
  TST.b D2
   BEQ.w toreg__norm
  CMP.b #$4,D2
   BNE.w toreg__suv
  MOVE.w #$0004,-(A7)
  MOVE.l #$FFFFFFFA,-(A7)                                  ;#-6,-(a7) org source
BRA.w toreg__sendmd

 toreg__suv:
  CMP.b #$3,D2
   BNE.w toreg__notnmax
  CLR.w -(A7)
  MOVE.l #$FFFFFFFC,-(A7)                                  ;#-4,-(a7) org source

    ;
    ;O.K., we are going to send the current maximum settings.
    ;
 toreg__sendmd:
  LSR.w #8,D2
  MOVE.w #$303C,D1                                         ;move.w #x,dn
  BTST #$7,D2
   BEQ.w toreg__skipad
  MOVE.w #$307C,D1                                         ;move.w #x,an
  CMP.w #$16,D2
   BNE.w toreg__skipad
  MOVE.w #$FFFF,lasta6                                     ;-1 org source

 toreg__skipad:
  ANDI.w #$7,D2
  LSL.w #8,D2
  LSL.w #1,D2
  OR.w D2,D1
   BSR.w writeword
  MOVE.l $12(A1),D1
  ADD.l (A7)+,D1
  MOVE.w $0(A1,D1.L),D1
  ADD.w (A7)+,D1
BRA.w writeword

 toreg__notnmax:
  MOVE.w D2,-(A7)
  LSR.w #8,D2
  CMP.w #$16,D2
   BNE.w toreg__isnta6
  MOVE.w #$FFFF,lasta6                                     ;-1 org source

 toreg__isnta6:
  MOVE.l $12(A1),D1                                        ;objectspace
  MOVE.w -$6(A1,D1.L),-(A7)
   BSR.w makeregop
   BSR.w writeword
  MOVE.w (A7)+,D1
  MOVE.w (A7)+,D2
  TST.b D2
   BPL.w toreg__skippy1
    ;
    ;<0 - the rest is a register spec.
    ;this reg is used to calc a max item (must be dn)
    ;
   BSR.w writeword                                         ;move.l x(a5),dn
  MOVE.w D2,-(A7)                                          ;store reg used
    ;
  ADDA.l $12(A1),A1
  MOVE.b D2,D1
  ANDI.w #$7,D1
    ;
  TST.b debugmode
   BEQ.w toreg__norerr
    ;
  MOVE.w D1,-(A7)
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$B07C,D1                                          ;cmp #x,dn
   BSR.w writeword
  MOVE.w -$4(A1),D1
   BSR.w writeword
  MOVE.l maxchk(PC),D1                                  ;bcs
   BSR.w writelong
  MOVE.l A2,-(A7)
  MOVE.w #$C30A,D1
   BSR.w Atokejsr
  MOVEA.l (A7)+,A2
  MOVE.w (A7)+,D1

 toreg__norerr:
  MOVE.w -$2(A1),D2                                        ;shift amount

 toreg__shloop:
  CMP.w #$9,D2
   BCS.w toreg__simp
  MOVEM.w D1-D2,-(A7)
    ;
  MOVEQ.l #$00,D2                                          ;!!!!!
    ;
  LSL.w #8,D2
  LSL.w #1,D2
  OR.w D2,D1
  OR.w lsldn(PC),D1
   BSR.w writeword
  MOVEM.w (A7)+,D1-D2
  SUBQ.w #8,D2
BRA.w toreg__shloop

 toreg__simp:
  MOVE.w D1,-(A7)
  OR.w #$48c0,d1
  BSR writeword
  MOVE.w (a7),d1
  TST.w D2
  BEQ.w toreg__simp2
    ;
  ANDI.w #$7,D2                                            ;?????
    ;
  LSL.w #8,D2
  LSL.w #1,D2
  OR.w D2,D1
  OR.w lsldn(PC),D1
   BSR.w writeword

 toreg__simp2:
    ;
    ;Shifts are done, add'em to the opcode
    ;
  MOVE.w (A7)+,D1
  ANDI.w #$7,D1
  OR.w maxdo(PC),D1
  MOVE.w (A7)+,D2
  LSL.w #1,D2
  ANDI.w #$E00,D2
  OR.w D2,D1
BRA.w writeword

 toreg__skippy1:
  CMP.b #$1,D2
   BEQ.w toreg__skippy
    ;
    ;select used of a max block
    ;
  ADDQ.w #4,D1
    ;
  TST.b debugmode
   BEQ.w toreg__skippy
    ;
   BSR.w writeword
  SWAP D1
  MOVE.w toreg__theretest(PC),D1
  SWAP D1
   BSR.w writelong
  MOVE.l toreg__theretest+4(PC),D1
   BSR.w writelong
  MOVE.l toreg__theretest+8(PC),D1
BRA.w writelong

 toreg__skippy:                                            ;select base of a max block
BRA.w writeword


;------                                                  ;disassembled code begin
 toreg__theretest:
            Dc.b $4A,$AD,$00,$00                           ;TST.L  $0000(A5)
            Dc.b $66,$00,$00,$06                           ;BNE.W  toreg__ttskip
            Dc.b $70,$01                                   ;MOVEQ  #$01,D0
            Dc.b $4E,$40                                   ;TRAP   #00
 toreg__ttskip:
;------                                                  ;disassembled code end

 toreg__norm:
  LSR.w #8,D2
  CMP.b #$16,D2
   BNE.w toreg__nota6
  MOVE.w $A(A1),D1
  CMP.w lasta6,D1
   BEQ.w toreg__sk
  MOVE.w D1,lasta6

 toreg__nota6:
   BSR.w makeregop
  TST.w $1A(A1)
   BPL.w toreg__long
  CMP.w stackop(PC),D1
   BNE.w toreg__notst
  SUBQ.w #2,a2offset

 toreg__notst:
   ORI.w #$1000,D1

 toreg__long:
   BSR.w writeword
  MOVE.w $A(A1),D1
   BSR.w writeword

 toreg__sk:
RTS


;------                                                                 ;disassembled code begin
lsldn:      Dc.b $E1,$88                 ;Dc.b $48 ;object long acsess    ;LSL.L   #8,D0
maxchk:     Dc.b $65,$00,$00,$08                                          ;BCS.W   maxchk__ok
            Dc.b $4E,$B9,$00,$00,$00,$00                                  ;JSR     $00000000
maxchk__ok:

maxdo:      Dc.b $D1,$C0                                                  ;ADDA.L  D0,A0        ;old Dc.b $d0 $C0,00   ;ADDA.W  D0,A0

;stackopuse:                                                              ;??looks like not used??
            Dc.b $00,$00
stackop:    Dc.b $2F,$2D,$00,$00                                          ;MOVE.L  $0000(A5),-(A7)
;------                                                  ;disassembled code end


makeregop:
    ;make move x(a5),dn/an based on d2
    ;
  CMP.b #$FF,D2
   BNE.w makeregop__notst
  MOVE.w stackop(PC),D1
  ADDQ.w #4,a2offset
RTS

 makeregop__notst:
  MOVE.l A3,-(A7)
  LEA regtransd,A3
  BTST #$4,D2
   BEQ.w makeregop__skip
  LEA regtransa,A3

 makeregop__skip:
  ANDI.w #$7,D2
  MOVE.w D2,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w (A3),D1
  MOVEA.l (A7)+,A3
RTS


ifchar:
    ;return eq=1 if <,=,>
    ;
  CMP.w #$3C,D0
   BCS.w ifchar__no
  CMP.w #$3E,D0
   BHI.w ifchar__no
  SUBI.w #$3C,D0
  CMP.w D0,D0

 ifchar__no:
RTS


JL_0_BF6A:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

 AJL_0_BF6E:
  ;MOVE.b isconstantvalue,-(a7)                 ;new
  ;MOVE.l lastconstantvalue,-(a7)
  MOVE.w regnum,-(A7)
  CLR.w regnum
  MOVE.l destpointer,-(A7)
  MOVE.l destbufferend,-(A7)
  MOVE.w dontwrite,-(A7)
  MOVE.w lasta6,-(A7)
  MOVE.w cfetchmode,-(A7)
   BNE.w JL_0_BFB6
  MOVE.l destbufferend,oldlibat
  MOVEA.l constpcat,A0
  MOVE.l A0,destpointer
BRA.w JL_0_BFBC

 JL_0_BFB6:
  MOVEA.l destpointer,A0

 JL_0_BFBC:
  MOVE.l A0,-(A7)
  MOVE.l constlibat,destbufferend
  CLR.w dontwrite

  MOVE.w #$FFFF,lasta6
  MOVE.w #$FFFF,cfetchmode
  ;clr.b _neg
    BSR.w arreval
   MOVE.l (a7),a0

 !newcalc
   BEQ 'l10
   MOVE.l d0,d3
   MOVEA.l (A7)+,A0
BRA bc1

 'l10
   MOVE.w #$2600,D1
  OR.w regnum,D1
   BSR.w writeword
  MOVE.w #$4E75,D1
   BSR.w writeword
  MOVE.w dontwrite,D1
   BNE.w conmemerr
  MOVEA.l (A7)+,A0
  NOP
   JSR Aclearcache                                         ;simple expression

 L_0_C00A:
   JSR (A0)                                                ;writeresult

 bc1
  MOVE.w (A7)+,cfetchmode
  MOVE.w (A7)+,lasta6
  MOVE.w (A7)+,dontwrite
  MOVE.l (A7)+,destbufferend
  MOVE.l (A7)+,destpointer
  MOVE.w (A7)+,regnum
  ;MOVE.l (a7)+,lastconstantvalue
  ;MOVE.b (a7)+,isconstantvalue
JMP reget


oldlibat:   Ds.l 1


.do_INCDIR:
  LEA incdir,A0

 JL_0_C03E:
  CMP.w #$22,D0
   BEQ.w JL_0_C052
  MOVE.b D0,(A0)+
  TST.w D0
   BEQ.w JL_0_C05A
   BMI.w syntaxerr

 JL_0_C052:
  JSR get1bytemain                                         ;_long
BRA.w JL_0_C03E

 JL_0_C05A:
RTS


JL_0_C05C:
  LEA ptr_parameterstore,A1                                ;getparameter
  LEA incdir,A0
  MOVEQ.l #-$01,D2

 JL_0_C06A:
    ADDQ.w #1,D2
    MOVE.b (A0)+,(A1)+
  BNE.w JL_0_C06A
  SUBQ.w #1,A1
   ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

 JL_0_C078:
;  BSR.w get1bytemain
  JSR get1bytemain
  TST.w D0
   BMI.w syntaxerr
  CMP.b #$22,D0
   BEQ.w JL_0_C078
  MOVE.b D0,(A1)+
   BEQ.w JL_0_C096
  ADDQ.w #1,D2
BRA.w JL_0_C078

 JL_0_C096:
  TST.w D2
   BEQ.w syntaxerr
RTS


AJL_0_C09E:
  MOVEA.l constantbase,A2
  MOVEA.l $E(A2),A5
  MOVE.l a5,includesourceline
  LEA inctab,a0
  MOVE.w ininclude,d0
  MOVE.l $0(a0,d0*4),d0
  MOVEA.l $4(A2),A0
  ;MOVE.w $C(A2),D0
  LEA $0(A0,D0.l),A0
  MOVEA.l A5,A1

 JL_0_C0B6:
    CMPA.l A0,A1
     BCC.w JL_0_C0C6
  TST.b (A1)+
  BNE.w JL_0_C0B6
BRA.w JL_0_C112

 JL_0_C0C6:
  MOVEA.l $4(A2),A1

 JL_0_C0CA:
  CMPA.l A0,A5
  BCC.w JL_0_C0D6
  MOVE.b (A5)+,(A1)+
BRA.w JL_0_C0CA

 JL_0_C0D6:
  MOVE.l A1,D0
  SUB.l $4(A2),D0
  LEA inctab,a0
  MOVEQ #0,d1
  MOVE.w ininclude,d1
  MOVE.l d0,0(a0,d1*4)
  ;MOVE.w D0,$C(A2)
  MOVEA.l _dosbase,A6
  MOVE.l $8(A2),D1
  MOVE.l A1,D2
  MOVE.l D2,include_base
  ;MOVE.l #$3FF*8,D3
  MOVE.l #$10000000,d3                                     ;load whole file
  SUB.l D0,D3
   JSR _Read(A6)
  TST.l D0
   BMI.w error_reading_file
   BEQ.w JL_0_C120
   MOVE.l D0,include_length
   !ComData_GetL{comPtr_PreProcessor,include_preprocessor}
   !basic
   ilen.l  = Peek.l(?include_length)
   ibase.l = Peek.l(?include_base)
   ido.l   = Peek.l(?include_process)
   *tn.preprocessor = Peek.l(?include_preprocessor)
   If ido
     ioffset.l = SkipXtraHeader{ibase,ilen}
     nilen.l = preproc_Tokenize{*tn,ibase+ioffset,ibase,ilen-ioffset}
     If nilen>0
       ;For n.l=nilen To ilen-1
       ;  Poke.b ibase+n,0
       ;Next
       Poke.l ?include_length,nilen
     End If
   End If
   !asm
   MOVE.l #0,include_process
   MOVE.l include_length,D0
   LEA inctab,a0
   MOVEQ #0,d1
   MOVE.w ininclude,d1
   ADD.l d0,0(a0,d1*4)
  ;ADD.w D0,$C(A2)
  MOVEA.l $4(A2),A5
  ;MOVE.w $C(A2),D0
   MOVE.l 0(a0,d1*4),d0
  CLR.b $0(A5,D0.l)

 JL_0_C112:
  MOVEA.l A5,A0

 JL_0_C114:
    TST.b (A0)+
  BNE.w JL_0_C114
  MOVE.l A0,$E(A2)
RTS


include_length:        Dc.l 0                              ; for tokenizer!
include_base:          Dc.l 0
include_process:       Dc.l 0
include_preprocessor:  Dc.l 0


JL_0_C120:
  MOVE.l $8(A2),D1
  ;JSR -$24(A6)
  MOVEA.l _dosbase,A6
  JSR _Close(a6)
  MOVEA.l _execbase,A6
  MOVEA.l $4(A2),A1
  MOVE.l #$400*8,D0                                        ;exit include
  ;MOVE.l mempool,a0
  JSR _FreeVec(a6)
  ;JSR _FreePooled(a6)
   ;jsr _FreeMem(A6)
  MOVE.l (A2),constantbase
  MOVEA.l A2,A1
  MOVEQ.l #$00,D0
  MOVE.b $12(A2),D0
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _FreePooled(A6)
  JSR zero_includename
  SUBQ.w #1,ininclude
  BNE.w AJL_0_C09E

 'l2a
  LEA _include,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA ptr_parameterstore,a1

 'l1b
    MOVE.b (a0)+,(a1)+
  BNE 'l1b
  MOVEQ #9,d2
  JSR findlabel2
  BNE 'd
  CLR.l 8(a2)

 'd
  MOVEM.l (a7)+,a0-a6/d0-d7
RTS


.free_unusedfunctions:
  MOVE.l unusedfunc,d0
  BEQ 'noclear
  MOVEM.l d0-d2/a0-a1/a6,-(a7)

 'f1
    MOVE.l d0,a1
    MOVE.l 4(a1),d0
    MOVE.l (a1),d2
    MOVE.l _execbase,a6
    JSR _FreeMem(a6)
    MOVE.l d2,d0
  BNE 'f1
  CLR.l unusedfunc
  MOVEM.l (a7)+,a0-a1/a6/d0-d2

 'noclear
RTS


AJL_0_C15C:
  MOVEA.l xinclude_base,A2
  CLR.l xinclude_base

 JL_0_C168:
    CMPA.w #$0,A2
     BEQ.w JL_0_C186
    MOVEQ.l #$00,D0
    MOVE.b 4+8(A2),D0
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEA.l _execbase,A6
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
BRA.w JL_0_C168

 JL_0_C186:
RTS


AJL_0_C188:
  MOVEA.l constantbase,A2
  CLR.l constantbase

 JL_0_C194:
    CMPA.w #$0,A2
     BEQ.w JL_0_C1DC
    MOVE.l $8(A2),D1
     BEQ.w JL_0_C1AE
    MOVEA.l _dosbase,A6
     JSR _Close(A6)

 JL_0_C1AE:
    MOVE.l $4(A2),D0
     BEQ.w JL_0_C1C6
    MOVEA.l D0,A1
    MOVE.l #$400*8,D0
    MOVEA.l _execbase,A6
    MOVE.l mempool,a0
    JSR _FreeVec(a6)

 JL_0_C1C6:
    MOVEQ.l #$00,D0
    MOVE.b $12(A2),D0
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEA.l _execbase,A6
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
BRA.w JL_0_C194

 JL_0_C1DC:
RTS


JL_0_C1DE:
  SWAP D0
   BSR.w JL_0_C1E6
  SWAP D0

 JL_0_C1E6:
  MOVEA.l data2,A4
  CMPA.l allat,A4
   BCC.w JL_0_C200
  MOVE.w D0,(A4)+
  MOVE.l A4,data2
RTS

 JL_0_C200:
  MOVE.w #$FFFF,dontwrite
  ADDQ.l #2,data2
RTS


JL_0_C210:
  MOVEA.l data2,A4
  CMPA.l allat,A4
   BCC.w JL_0_C22A
  MOVE.b D0,(A4)+
  MOVE.l A4,data2
RTS

 JL_0_C22A:
  MOVE.w #$FFFF,dontwrite
  ADDQ.l #1,data2
RTS


JL_0_C23A:
  CMP.w #$22,D0
   BNE.w syntaxerr

 JL_0_C242:
;  BSR.w get1bytemain
  JSR get1bytemain
  CMP.b #$22,D0
   BEQ.w JL_0_C25A
  TST.w D0
   BEQ.w syntaxerr
  MOVE.b D0,(A0)+
BRA.w JL_0_C242

 JL_0_C25A:
  CLR.b (A0)
RTS

AJL_0_C25E:
  TST.l D3
RTS

AJL_0_C262:
  LEA ptr_parameterstore,A0
  LEA namebuff2,A1

 JL_0_C26E:
    MOVE.b (A0)+,D0
    BEQ.w JL_0_C27C
  CMP.b (A1)+,D0
  BEQ.w JL_0_C26E
RTS

 JL_0_C27C:
  TST.b (A1)
  BNE.w JL_0_C284
RTS

 JL_0_C284:
  CMP.w #$1,D0
RTS


.do_DEFTYPE:
  CMP.w #$2E,D0                                            ;dodeftype
   BNE.w syntaxerr
  BSR.w getparameter2
  LEA newtypebase,A2
  BSR.w findtype
   BNE.w notypeerr
  TST.b declare
   BNE 'l1
  TST.b declare2
   BEQ 'l2

 'l1
  MOVE.b #2,nowdeclare

 'l2
  ;BSR.w reget
  JSR reget
   BNE.w JL_0_C2B4
  MOVE.l A2,defaulttype
RTS

 JL_0_C2B4:
  MOVE.l defaulttype,-(A7)
  MOVE.l A2,defaulttype

 JL_0_C2C0:
  BSR.w getparameter
   BSR.w JL_0_8E3C
  CMP.w #$2C,D0
   BNE.w JL_0_C2D8
   JSR get1bytemain                                        ; was BSR.w
BRA.w JL_0_C2C0

 JL_0_C2D8:
  MOVE.l (A7)+,defaulttype
RTS


JL_0_C2E0:
  LEA $4(A5),A2                                            ;fehler function

 L_0_C2E4:
  MOVE.l A2,D0

 .do_MaxLen:
  BSR.w getparameter
  BSR.w JL_0_8E3C
  BSR.w calcvar
  CMP.b #$7,D2
   BNE.w mismatcherr
  MOVE.w varmode(PC),-(A7)
  CMP.w #$3D,D0
   BNE.w syntaxerr
  BTST #$F,D2
   BNE.w JL_0_C31C
  MOVE.w JL_0_C2E0(PC),D1
  BSR.w pokewda5s
  MOVE.w D3,D1
  BSR.w writeword

 JL_0_C31C:
  MOVE.w L_0_C2E4(PC),D1
  BSR.w writeword
  ADDQ.w #1,regnum
  MOVEQ.l #$03,D2
  BSR.w eval
  MOVE.l #$D000,D1
  MOVE.l d1,lastinstruction
  TST.w (A7)+
   BEQ.w Atokejsr
  ADDQ.w #1,D1
BRA.w Atokejsr


JL_0_C340:
  MOVE.w D0,D1
   BPL.w syntaxerr
  BCLR #$F,D1
   JSR searchinstr
  MOVE.l $12(A2),D0
  TST.w -$2(A2,D0.L)
   BEQ.w freeerr
  MOVEQ.l #$02,D2
  MOVE.l A2,-(A7)
   BSR.w eval
  MOVEA.l (A7)+,A2
  MOVE.l A2,mymaxlib
  ADDA.l $12(A2),A2
  TST.b debugmode
   BEQ.w JL_0_C3A8
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$B07C,D1
   BSR.w writeword
  MOVE.w -$4(A2),D1
   BSR.w writeword
  MOVE.l maxchk,D1
   BSR.w writelong
  MOVE.l A2,-(A7)
  MOVE.w #$C30A,D1
   BSR.w Atokejsr
  MOVEA.l (A7)+,A2

 JL_0_C3A8:
  MOVE.w -$2(A2),D2

 JL_0_C3AC:
  MOVE.w regnum,D1
  OR.w lslimm,D1
  CMP.w #$8,D2
   BCS.w JL_0_C3CE
   BSR.w writeword
  SUBQ.w #8,D2
   BNE.w JL_0_C3AC
BRA.w JL_0_C3DA

 JL_0_C3CE:
  MOVE.w D2,D0
  LSL.w #8,D0
  LSL.w #1,D0
  OR.w D0,D1
  BSR.w writeword

 JL_0_C3DA:
RTS


;------                                                  ;disassembled code begin
free:
  Dc.b $26,$6D,$00,$00                                     ;MOVEA.L $0000(A5),A3
  Dc.b $D6,$C0                                             ;ADDA.W  D0,A3
freef:  ;
;------                                                  ;disassembled code end

mymaxlib:  Ds.l 1


.do_free:
  BSR.w JL_0_C340
  LEA free(PC),A0
  LEA freef(PC),A1
  MOVE.w -$6(A2),$2(A0)
  BSR.w pokecode
  MOVE.l -$A(A2),D1

 maxjsr:
  BEQ.w nosuperr
  MOVEA.l mymaxlib(PC),A2
BRA.w Amakelibsub



.do_use:
  BSR.w JL_0_C340
  LEA use,A0
  LEA usef,A1
  MOVE.w -$6(A2),$2(A0)
  MOVE.w -$6(A2),-$2(A1)
  ADDQ.w #4,-$2(A1)
  BSR.w pokecode
  MOVE.l -$E(A2),D1
BRA.w maxjsr

.do_else2:
  ;BSR.w get1bytemain
  JSR get1bytemain


 .do_else:
  MOVE.l firstiff,D0
   BEQ.w noiferr
  MOVEA.l D0,A0
  CMPI.b #$1,$D(A0)
   BEQ.w illelseerr
  MOVE.w #$6000,D1
  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    OR.l #$ff,d1
    BSR writeword
  CEND

 'l1
  SWAP D1
  BSR.w writelong
  MOVEQ.l #$00,D1
  BSR.w AJL_0_D7B8
  MOVE.l destpointer,$8(A0)
BRA.w do_then


.do_cerr:
  LEA ptr_parameterstore,A0
  MOVE.l A0,-(A7)
  BSR.w JL_0_C23A
BRA.w handle_compileerror


JL_0_C47E:
  BSR.w JL_0_BF6A
  MOVEQ.l #$05,D1
   ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  LEA AJL_0_C25E,A0
BRA.w JL_0_C4B4


JL_0_C492:
  LEA ptr_parameterstore,A0
  BSR.w JL_0_C23A
  JSR get1bytemain
  BSR.w JL_0_CCA8
  LEA namebuff2,A0
  BSR.w JL_0_C23A
  LEA AJL_0_C262,A0

 JL_0_C4B4:
  LSL.w #2,D1
  LEA CIF_branches,A1
  MOVE.l $0(A1,D1.W),-(A7)
  MOVEQ.l #-$01,D1

 L_0_C4C2:
  JSR (A0)
  MOVEA.l (A7)+,A1

 L_0_C4C6:
JMP (A1)


cif_eq:
  BEQ.w JL_0_C4F6
BRA.w JL_0_C4F4


cif_ne:
  BNE.w JL_0_C4F6
BRA.w JL_0_C4F4


cif_lt:
  BLT.w JL_0_C4F6
BRA.w JL_0_C4F4


cif_le:
  BLE.w JL_0_C4F6
BRA.w JL_0_C4F4


cif_gt:
  BGT.w JL_0_C4F6
BRA.w JL_0_C4F4


cif_ge:
  BGE.w JL_0_C4F6

 JL_0_C4F4:
  MOVEQ.l #$00,D1

 JL_0_C4F6:
  MOVEA.l concomsp,A0
  MOVE.w skipcode,(A0)+
  MOVE.l A0,concomsp
  MOVE.w D1,skipcode
  JSR get1bytemain
   BNE.w syntaxerr
JMP bakup


;------                                                  ;disassembled code begin
rescode:   Dc.b $2B,$7c,$00,$00,$00,$00 :   Ds.w 1         ;MOVE.L  #$00000000,$0000(A5)
rescode2:  Dc.b $2B,$40                 :   Ds.w 1         ;MOVE.L  D0,$0000(A5)
;------                                                  ;disassembled code end


.do_Restore:
    ;Restore 'label'
    ;
  MOVE.w #$FC17,D1
  JSR uselib
    ;
  JSR reget
   BEQ.w do_Restore__resbeg
  BSR.w JL_0_AE22                                          ;get label name!
  MOVE.w rescode(PC),D1
  BSR.w writeword
  JSR addoff                                               ;add offset
  MOVE.l $C(A2),D1
  BSR.w writelong
  MOVE.w rescode+6(PC),D1
  BSR.w writeword
  MOVE.l $4(A2),D1                                         ;is it outstanding?
  BEQ.w do_Restore__no
    ;yes - tell it that reference is a DATA statement one
  MOVEA.l D1,A1
  ADDQ.l #1,$4(A1)                                         ;make odd - flag for data reference.
RTS

 do_Restore__no:
    ;data label not outstanding...this not working!?!?
    ;
RTS

 do_Restore__resbeg:                                       ;restore to beginning...
  MOVE.w #$CD00,D1
  JSR Atokejsr
  MOVE.l rescode2(PC),D1
JMP writelong


.do_read:
  MOVE.w #$FC17,D1
  JSR uselib

 JL_0_C584:
  MOVE.l dataget,D1
  BSR.w writelong
  BSR.w getparameter
  BSR.w JL_0_8E3C
  BSR.w calcvar
  BTST #$E,D2
   BEQ.w JL_0_C5A6
  MOVE.b #$6,D2

 JL_0_C5A6:
  TST.b D2
   BEQ.w noleterr
  TST.b debugmode
   BEQ.w JL_0_C5D0
  MOVE.w #$7000,D1
  MOVE.b D2,D1
  ANDI.b #$F,D1
  BSR.w writeword
  MOVE.w #$C310,D1
  MOVE.w D2,-(A7)
  BSR.w Atokejsr
  MOVE.w (A7)+,D2

 JL_0_C5D0:
  CMP.b #$7,D2
   BEQ.w JL_0_C684
  CMP.b #$1,D2
   BNE.w JL_0_C62A
  LEA dataletb2,A0
  LEA dataletb2f,A1
  BTST #$F,D2
   BEQ.w JL_0_C5FC
  BSR.w pokecode
BRA.w JL_0_C668

 JL_0_C5FC:
  LEA dataletb,A0
  LEA dataletbf,A1
  TST.w varmode
   BEQ.w JL_0_C61E
  LEA dataletbl,A0
  LEA dataletblf,A1

 JL_0_C61E:
  MOVE.w D3,$4(A0)
  BSR.w pokecode
BRA.w JL_0_C668

 JL_0_C62A:
  LEA dataletw,A0
  CMP.b #$3,D2
   BCS.w JL_0_C63E
  LEA dataletl,A0

 JL_0_C63E:
  BTST #$F,D2
   BEQ.w JL_0_C652
  MOVE.w $4(A0),D1
   BSR.w writeword
BRA.w JL_0_C668

 JL_0_C652:
  TST.w varmode
   BEQ.w JL_0_C65E
  ADDQ.w #6,A0

 JL_0_C65E:
  MOVE.w D3,$2(A0)
  MOVE.l (A0),D1
  BSR.w writelong

 JL_0_C668:
  MOVE.l dataput,D1
   BSR.w writelong
  CMP.w #$2C,D0
   BEQ.w JL_0_C67C
RTS

 JL_0_C67C:
  JSR get1bytemain
BRA.w JL_0_C584


JL_0_C684:
  MOVE.w stlenget,D1
   BSR.w writeword
  BTST #$F,D2
   BNE.w JL_0_C6C0
  TST.w varmode
   BEQ.w JL_0_C6B0
  MOVE.w D3,leaampl+2
  MOVE.l leaampl,D1
BRA.w JL_0_C6BC

 JL_0_C6B0:
  MOVE.w D3,leaamp+2
  MOVE.l leaamp,D1

 JL_0_C6BC:
  BSR.w writelong

 JL_0_C6C0:
  MOVE.w #$C701,D1
  MOVE.w varmode,D2
   BEQ.w JL_0_C6D0
  SUBQ.w #1,D1

 JL_0_C6D0:
  BSR.w Atokejsr
  MOVE.w #$FFFF,lasta6
  LEA stalign,A0
  LEA stalignf,A1
  BSR.w pokecode
BRA.w JL_0_C668


JL_0_C6F0:
  CMP.w #$2E,D0                                            ;definecode 'lb 'lw 'll
   BNE.w JL_0_C720
  JSR get1bytemain
  CMP.w #$77,D0
   BEQ.w JL_0_C71C
  CMP.w #$62,D0
   BEQ.w JL_0_C718
  CMP.w #"s",d0
  BEQ single3
  CMP.w #"d",d0
  BEQ double3
  CMP.w #$6C,D0
   BNE.w syntaxerr
  MOVEQ.l #$02,D1
RTS


single3
  MOVE.b #1,iee
  MOVEQ.l #$3,d1
RTS


double3
  MOVE.b #1,iee
  MOVEQ.l #$4,d1
RTS


JL_0_C718:
  MOVEQ.l #$00,D1
RTS


JL_0_C71C:
  MOVEQ.l #$01,D1
RTS


JL_0_C720:
  MOVEQ.l #$01,D1
JMP bakup


.do_dcb:
  BSR.w JL_0_C6F0

  MOVE.w D1,-(A7)
   BSR.w AJL_0_BF6E
  CMP.w #$2C,D0
   BNE.w syntaxerr
  MOVE.l D3,-(A7)
   BSR.w AJL_0_BF6E
  MOVE.l D3,D1
  MOVE.l (A7)+,D3
  MOVE.w (A7)+,D2
   BEQ.w JL_0_C774
   ;bsr.w do_even
   ;addq.l #1,destpointer                                   ;even
   ;bclr #$0,destpointer+3
  CMP.w #$1,D2
   BEQ.w JL_0_C768

 JL_0_C754:
  SWAP D1
   BSR.w writeword
  SWAP D1
   BSR.w writeword
  SUBQ.l #1,D3
   BNE.w JL_0_C754
RTS

 JL_0_C768:
   BSR.w writeword
  SUBQ.l #1,D3
   BNE.w JL_0_C768
RTS

 JL_0_C774:
   BSR.w writebyte
  SUBQ.l #1,D3
   BNE.w JL_0_C774
RTS


.do_ds:
  BSR.w JL_0_C6F0                                          ;definestorage
  MOVE.w D1,-(A7)
  BSR.w AJL_0_BF6E
  MOVE.w (A7)+,D1
  LSL.l D1,D3
  MOVE.l d3,d0
  BEQ 'll5
  MOVEQ #0,d1

 'll10:
    JSR writebyte
    SUBQ.l #1,d3
  BNE.s 'll10

 'll5:
RTS


JL_0_C796:
  MOVE.w D0,-(A7)
  LEA dummyasm,A0
  MOVEA.l destpointer,A1
  MOVE.w asmlen2,asmlen
  JSR insasm
  MOVE.w (A7)+,D0
RTS


.do_dc:
  BSR.w JL_0_C6F0

  MOVE.l #ptr_parameterstore,asmbuff
  TST.w D1
   BEQ.w JL_0_C7EE
  CMP.w #$1,D1
   BEQ.w JL_0_C844
  CMP.w #$2,d1
   BEQ long
  CMP.w #$3,d1
   BEQ single
   MOVEQ.l #$0d,D3
   ;bsr.w do_even
   ;addq.l #1,destpointer                                   ;even
  ;bclr #$0,destpointer+3

 JL_0_C7D8b:
   JSR asmconst
   BSR.w JL_0_C796
   BSR.w writelong
   BSR   writelong
  CMP.w #$2C,D0
   BEQ.w JL_0_C7D8b
RTS


long
  MOVEQ.l #$0B,D3
   ;bsr.w do_even
   ;addq.l #1,destpointer                                   ;even
  ;bclr #$0,destpointer+3
  MOVE.b #1,_dcb

 JL_0_C7D8:
  JSR asmconst
  CLR.b _dcb
  BSR.w JL_0_C796
  BSR writebyte
  BSR writebyte
  BSR writebyte                                            ;long
  BSR writebyte
  CMP.w #$2C,D0
   BEQ.w JL_0_C7D8
RTS


single
  MOVEQ.l #$0c,D3
  ;bsr.w do_even
  ;addq.l #1,destpointer                                    ;even
  ;bclr #$0,destpointer+3
  MOVE.b #1,_dcb

 JL_0_C7D8a:
  JSR asmconst
  CLR.b _dcb
  BSR.w JL_0_C796
  BSR.w writebyte
  BSR.w writebyte
  BSR.w writebyte
  BSR.w writebyte
  CMP.w #$2C,D0
   BEQ.w JL_0_C7D8a
RTS
;RTS                                                        ;??Looks like unneeded code??


JL_0_C7EE:
  MOVEQ.l #$11,D3

 JL_0_C7F0:
  JSR get1bytemain
  CMP.w #$22,D0
   BNE.w JL_0_C81E

 JL_0_C7FC:
  MOVE.b (a5)+,d0                                          ;bsr.w get1bytemain ascii dc.b
   BEQ.w syntaxerr
  CMP.w #$22,D0
   BEQ.w JL_0_C816
  CMP.b #"\",d0
   BNE 'n1
  CMP.b #"\",(a5)
   BEQ 'do1

 'n1
  MOVE.w D0,D1
  BSR.w writebyte
BRA.w JL_0_C7FC

 'do1
  CMP.l #"__DA",1(a5)
   BNE 'nodate1
  CMP.l #"TE__",5(a5)
   BEQ 'c1
  CMP.l #"TE_G",5(a5)
   BNE 'nodate1
  CMP.l #"ER__",9(a5)
   BNE 'nodate1
  JSR compiledatedc_ger
BRA 'n1

 'c1
  JSR compiledatedc
BRA 'n1

 'nodate1
  CMP.l #"__VE",1(a5)
   BNE 'n1
  CMP.w #"R_",5(a5)
   BNE 'n1
  JSR version_string_dc
BRA.w JL_0_C7FC


JL_0_C816:
  CLR.w instringon
  JSR get1bytemain
BRA.w JL_0_C83A


 JL_0_C81E:
  ;bsr.w bakup
   MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
   JSR asmconst
  SUBQ.l #1,destpointer
   BSR.w JL_0_C796
  ADDQ.l #1,destpointer
   BSR.w writebyte

 JL_0_C83A:
  CMP.w #$2C,D0
   BEQ.w JL_0_C7F0
RTS


JL_0_C844:
  MOVEQ.l #$10,D3
   ;bsr.w do_even
   ;addq.l #1,destpointer                                   ;even
  ;bclr #$0,destpointer+3

 JL_0_C84A:
  MOVE.b #1,_dcb
  JSR asmconst
  CLR.b _dcb
  BSR.w JL_0_C796
  BSR.w writebyte
  BSR.w writebyte
  CMP.w #$2C,D0
   BEQ.w JL_0_C84A
RTS


.do_even4:                                                 ;long align
  ADDQ.l #3,destpointer
  ANDI.w #$FFFC,destpointer+2
RTS


.do_even8:                                                 ;phrase align
  ADDQ.l #7,destpointer
  ANDI.w #$FFF8,destpointer+2
RTS


.do_even:                                                  ;word align
  ADDQ.l #1,destpointer                                    ;even
  BCLR #$0,destpointer+3
RTS


datasize: Ds.w 1



pdt:
    ;insert type of data item into code
    ;if runtime error checking is on.....
    ;
    ;codes for data..... Dn
    ;
  TST.b debugmode
  BEQ.w pdt__skip
  MOVE.w #$4420,D0                                         ;'D '
  MOVE.b datasize+1(PC),D0
BRA.w JL_0_C1E6

 pdt__skip:
RTS


.do_data:
  MOVE.w #$FC17,D1
   JSR uselib
   ;bsr.w bakup
   MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
   JSR AJL_0_498A
  MOVE.w D1,datasize
  CMP.w #$7,D1
   BEQ.w JL_0_C944
  MOVE.w D1,-(A7)

 JL_0_C8CC:
  BSR.w pdt
  MOVE.w (A7),D2
   BSR.w JL_0_B1D8
  CMP.w (A7),D2                                            ;datamode
   BEQ.w JL_0_C920
  MOVE.w D2,D1
  MOVE.w (A7),D2
  CMP.w #$2,D2
   BNE.w JL_0_C8FE
  CMP.w #$3,D1
   BNE.w baddaterr
  CMP.l #$10000,D3
   BCC.w baddaterr
BRA.w JL_0_C920

 JL_0_C8FE:
  CMP.w #$1,D2
   BNE.w JL_0_C91C
  CMP.w #$2,D1
   BNE.w baddaterr
  CMP.l #$100,D3
   BCC.w baddaterr
BRA.w JL_0_C920

 JL_0_C91C:
BRA.w baddaterr

 JL_0_C920:
  CMP.w #$3,D2
  BCC.w JL_0_C930
  BSR.w JL_0_C1E6
BRA.w JL_0_C934

 JL_0_C930:
  TST.b iee
  BEQ 'old
  CMP.b #5,d2
  BNE 'old
  Dc.l $f2006400                                           ;  fpu data write fmove.s fp0,d0
  ;BSR writelong

 'old
  BSR.w JL_0_C1DE                                          ;write data >3

 JL_0_C934:
  JSR reget
  CMP.w #$2C,D0
   BEQ.w JL_0_C8CC
  ADDQ.w #2,A7
RTS

 JL_0_C944:
   BSR.w pdt
  MOVE.l data2,-(A7)
   BSR.w JL_0_C1DE
  MOVEQ.l #$00,D1
   JSR get1bytemain
   BEQ.w JL_0_C9A6
  CMP.w #$22,D0
   BEQ.w JL_0_C988
  CMP.w #$2C,D0
   BEQ.w JL_0_C9A6

 JL_0_C96C:
   BSR.w JL_0_C210
  ADDQ.w #1,D1
   JSR getchar
  TST.w D0
   BEQ.w JL_0_C9A6
  CMP.w #$2C,D0
   BEQ.w JL_0_C9A6
BRA.w JL_0_C96C

 JL_0_C988:
   ;BSR.w get1bytemain                                      ;data writestring
   MOVEQ #0,d0
   MOVE.b (a5)+,d0
   BEQ.w notqerr2
  CMP.w #$22,D0
   BEQ.w JL_0_C9A2
   BSR.w JL_0_C210
  ADDQ.w #1,D1
BRA.w JL_0_C988
notqerr2 JMP notqerr
 JL_0_C9A2:
  CLR.w instringon
  JSR get1bytemain

 JL_0_C9A6:
  MOVEA.l (A7)+,A0
  MOVE.w dontwrite,D2
   BNE.w JL_0_C9B4
  MOVE.l D1,(A0)

 JL_0_C9B4:
  ADDQ.l #1,data2
  BCLR #$0,data2+3
  CMP.w #$2C,D0
   BEQ.w JL_0_C944
RTS


 JUMP_vardeclareerr
JMP vardeclareerr

.do_shared:
  MOVE.w proceduremode,D1                                  ;doshared
  ;BEQ.w sharederr
  BNE.w 'l1
  MOVE.w D1,-(A7)
  CLR.w proceduremode

 'again2
  LEA varbase,a2
  BSR.w getparameter
  MOVE.w d2,-(a7)
   JSR findvariable
   BEQ 'checkdim
   LEA sharebase,a2
   MOVEQ #$f+4,d7
   BSR.w findlab                                         ;find var
   BEQ.b dupsherr
   BSR addlabel
   CMP.b #".",d0
   BNE JUMP_vardeclareerr
   MOVE.l a2,a3
   JSR JL_0_8EB8b
;      BSR.w getparameter2
;   LEA newtypebase,A2
;   BSR.w findtype
;   BNE.w notypeerr
;   MOVE.l a2,$A(A3)
;   MOVE.w flagmask,$6(A3)
;   MOVE.w globalvarpointer,$4(A3)
;   MOVEQ.l #4,d1
;   CMPI.l #$100,$4(A2)
;    BCC.w 'l1d
;   MOVE.w 8(a2),d1

;'l1d
;   ADD.w d1,globalvarpointer
;   CMP.b #$2e,d0
;   BNE vardeclareerr
;   JSR get1bytemain
;   CMP.b #"l",d0
;   BNE 'lo
;BRA 'ok

;'lo
;  CMP.l #"f",d0
;   BNE onlyfloatint

;'ok
;   MOVE.w globalvarpointer,$4(A3)
;   ADD.w #4,globalvarpointer

 'domore
  MOVE.w (a7)+,d2
   CMP.b #",",d0
   BNE 'ret
   JSR get1bytemain
BRA 'again2

 'ret
  MOVE.w (A7)+,proceduremode
RTS

;'errormsg_declaredtwice_                                  ;deactived because of the change from BRA to JMP
;JMP errormsg_declaredtwice


'checkdim
   CMP.w #2,6(a2)
   BEQ 'do
   CMP.w #$102,6(a2)
   BEQ 'do
JMP errormsg_declaredtwice                                 ;was BRA 'errormsg_declaredtwice_

 'do
  LEA varbase,a0

 'm1
  MOVE.l (A0),D0                                           ;find label
   BEQ.b 'z1
   CMP.l d0,a2
   BEQ 'z1
   MOVE.l d0,a0
BRA 'm1

 'z1
  MOVE.l (a2),d1
    MOVE.l d1,(a0)
    CLR.l (a2)
    LEA sharebase,a0
    MOVE.l (a0),(a2)
    MOVE.l a2,(a0)
    JSR get1bytemain
    JSR get1bytemain
BRA 'domore

 'l1
  MOVE.b #1,nowdeclare
  MOVE.w D1,-(A7)
  CLR.w proceduremode

 JL_0_C9DE:
   BSR.w getparameter
  MOVE.w D2,-(A7)
  LEA firstglob,A2
   BSR.w findvariable2
   BNE.b JL_0_CA06

 JL_0_C9F0:
  MOVE.b flagmask+1,D1
  MOVE.b $7(A2),D3
  EOR.b D3,D1
   BEQ.w dupsherr
   BSR.w findlab
   BEQ.b JL_0_C9F0

 JL_0_CA06:
   BSR.w addlabel
  MOVE.w (A7)+,D2
  MOVE.l A2,-(A7)
   BSR.w JL_0_8E3C
  MOVEA.l (A7)+,A2
  MOVEQ.l #$04,D1
  ADDQ.w #4,A2
  ADDQ.w #4,A3

 JL_0_CA1A:
    MOVE.w (A3)+,(A2)+
  DBF D1,JL_0_CA1A

  BTST #$1,flagmask+1
   BEQ.w JL_0_CA3C
   JSR get1bytemain
  CMP.w #$29,D0
   BNE.w syntaxerr
   JSR get1bytemain

 JL_0_CA3C:
   CMP.w #$2C,D0
   BNE.w JL_0_CA4C
   JSR get1bytemain
BRA.w JL_0_C9DE

 JL_0_CA4C:
  MOVE.w (A7)+,proceduremode
RTS


.do_xinclude:
   BSR.w JL_0_C05C
   JSR check_incdir                                        ; ergebnis in d2

   LEA ptr_parameterstore,a1
   MOVE.l d2,-(a7)
   LEA includetemp,a0                                      ; filename in includetemp packen

 'l4
     MOVE.b (a1)+,(a0)+
   BNE 'l4

   LEA ptr_parameterstore,a1
   MOVE.l a1,a0

 'l1
    TST.b (a0)+
   BNE 'l1

 'l2
     MOVE.b -(a0),d0
     CMP.b #":",d0
      BEQ 'out
     CMP.b #"/",d0
      BEQ 'out
     CMP.l a1,a0
      BEQ 'out2
BRA 'l2

 'out
   ADDQ.l #1,a0                                            ; dateinamen vom pfad extrahiert

 'out2
   MOVEQ.l #-$01,D2

 'l3
     ADDQ.w #1,D2
     MOVE.b (a0)+,(a1)+
   BNE 'l3
   CLR.b (a1)+

   LEA ptr_parameterstore,a1
   BSR.w findxinc                                         ;find include
    BEQ.w 'outb

   MOVE.w D2,-(A7)
   BSR.w addlabel
   MOVE.w (A7)+,D2

   LEA ptr_parameterstore,a1
   LEA includetemp,a0                                      ; namen in includetemp schreiben

 'l4b
    MOVE.b (a0)+,(a1)+
   BNE 'l4b

   MOVE.l (a7)+,d2
   LEA ptr_parameterstore,a1
BRA.w JL_0_CB18

 'outb
   LEA ptr_parameterstore,a1
   LEA includetemp,a0

 'l4b2
    MOVE.b (a0)+,(a1)+
   BNE 'l4b2

   MOVE.l (a7)+,d2
   LEA ptr_parameterstore,a1

 ;JL_0_CA6C:
RTS


.do_IncBin:
  BSR.w JL_0_C05C                                              ; test and get the parameter (includestring)

  JSR check_IncBinDir                                          ; to fix the path problem in CLIMode  tomsmart1

  MOVEA.l _dosbase,A6
  MOVE.l D0,D7                                                 ; store Lockpointer
   BEQ.w error_cant_open_include                               ; no pointer => errormessage
  MOVE.l D7,D1                                                 ; begin get the size of the file to include
  MOVE.l ptr_macrobuffer_begin,D2
   JSR _Examine(A6)
  MOVEA.l ptr_macrobuffer_begin,A0
  MOVE.l $4(A0),D0
   BPL.w error_cant_open_include                               ; something went wrong => errormessage
  MOVE.l $7C(A0),D3                                            ; store the size of the file to include
  MOVE.l D7,D1                                                 ; begin unlock the file
   JSR _UnLock(A6)

  MOVE.l #ptr_parameterstore,D1                                ; begin Open and Load the file
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2                       
   JSR _Open(A6)
  MOVE.l D0,D7
   BEQ.w error_cant_open_include
  MOVE.l destpointer,D0
  ADD.l D3,D0
  CMP.l destbufferend,D0
   BHI.w JL_0_CAF6
  MOVE.l destpointer,D2
  MOVE.l D7,D1
   JSR _Read(A6)
  CMP.l #$FFFFFFFF,D0
   BEQ.w error_reading_file
  ADD.l D0,destpointer
BRA.w JL_0_CB04

 JL_0_CAF6:
  MOVE.w #$FFFF,dontwrite
  MOVE.l D0,destpointer

 JL_0_CB04:
  MOVE.l D7,D1
JMP _Close(A6)


JUMP_illdirerr:
JMP illdirerr

.do_INCLUDE:
  TST.w dirmode                                            ;include  open
   BNE.w JUMP_illdirerr
  BSR.w JL_0_C05C
  JSR check_incdir

 JL_0_CB18:
  BSR.w findconstant
   BEQ.w alincerr

  LEA constantbase,A2
  BSR.w addhere2
  CLR.w $C(A2)
  CLR.l $4(A2)

  MOVE.l #ptr_parameterstore,D1
  MOVE.l d1,a0
  LEA includetemp2,a1

 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1
  JSR save_includename
  MOVE.l #0,include_process

  CMP.l #$62623200,-4(a0)                                  ;.bb2
  BEQ 'ok
  CMP.l #$61623300,-4(a0)                                  ;.ab3
  BEQ 'ok_tokenize
  CMP.l #$61623200,-4(a0)                                  ;.ab2
  BEQ 'ok_tokenize
  CMP.l #$2e626200,-4(a0)                                  ;.bb files
  BEQ 'ok
JMP errortoken                                             ;can only include

 'ok_tokenize
   MOVE.l #-1,include_process                              ; must tokenize the include

 'ok
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
  MOVEA.l _dosbase,A6
  JSR _Open(A6)
  MOVE.l D0,$8(A2)
  BEQ.w error_cant_open_include
  CLR.l includeline
  MOVE.l 8(a2),d1
  MOVE.l d3,-(a7)
  MOVEQ #0,d2
  MOVEQ #1,d3
  JSR _Seek(a6)                                            ; -66
  MOVE.l 8(a2),d1
  MOVEQ #0,d2
  MOVEQ #-1,d3
  JSR _Seek(a6)                                            ; -66
  MOVE.l (a7)+,d3
  ADDQ.l #4,d0
  ;MOVE.l #$400*8,D0
  MOVE.l #$10000,D1
  MOVEA.l _execbase,A6
  ;MOVE.l mempool,a0
  ;JSR _AllocPooled(a6)
  JSR _AllocVec(a6)
   ;jsr AJL_0_4B6C
  MOVE.l D0,$4(A2)
  MOVE.l D0,$E(A2)
  MOVEA.l D0,A5
;  MOVE.l #ptr_parameterstore,D1
;  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
;  MOVEA.l _dosbase,A6
;   jsr _Open(A6)
;  MOVE.l D0,$8(A2)
  ; BEQ.w error_cant_open_include
  ADDQ.w #1,ininclude                                      ;enter include

 'l2a
  LEA _include,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA ptr_parameterstore,a1

 'l1b
    MOVE.b (a0)+,(a1)+
  BNE 'l1b

  MOVEQ #9,d2
  JSR findlabel2
  BNE 'd
  MOVE.l #1,8(a2)
  MOVEM.l (a7)+,a0-a6/d0-d7
BRA 'd2

 'd
  JSR addlabelhash
  MOVE.l #$1,$4(A2)
  MOVE.l #1,8(a2)
  MOVEM.l (a7)+,a0-a6/d0-d7

 'd2
  LEA inctab,a0
  MOVEQ #0,d1
  MOVE.w ininclude,d1
  CLR.l $0(a0,d1*4)
  MOVEA.l passstack,A7
JMP AJL_0_413A


coolnest:   Ds.w 1
macline:    Ds.l 1


.do_Macro:
  MOVE.l linenumat,macline
   BSR.w makename2
   BEQ.w JUMP_syntaxerr

   CLR.b thenmode
   ;bsr.w bakup
   MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
   BSR.w findmac
   BEQ.w dupmacerr
   BSR.w addlabel
  CLR.w $A(A2)
  MOVEA.l ptr_macrobuffer_begin,A0
  MOVEQ.l #$00,D2
  CLR.w coolnest

 'l1
  MOVE.b (a5),d0
     BEQ 'l3
     CMP.b #" ",d0
      BNE 'l2                                              ;space macro
      ADDQ.l #1,a5
BRA 'l1

 'l2
   CMP.b #";",d0
      BNE 'l3

 'l4
   MOVE.b (a5),d0
      BEQ 'l5
      BSR.w JL_0_CC98                                      ;add comment
      ADDQ.l #1,a5
BRA 'l4

 'l5
   MOVE.b #":",d0
      BSR.w JL_0_CC98
      MOVE.b #"@",d0
      BSR.w JL_0_CC98

 'l3
   MOVE.b #0,temp
      MOVE.b #0,thenmode

 JL_0_CBB6:
  JSR getcharb
  TST.w D0
   BNE.w JL_0_CBDE
  MOVEM.l D2/A0/A2,-(A7)
  CMP.w #"@@",-3(a5)
  BNE 'l2a
  JSR nextline
  BEQ.w macenderr
  MOVEM.l (A7)+,D2/A0/A2
BRA.w JL_0_CBB6

 'l2a
   JSR nextline
   BEQ.w macenderr
  MOVEM.l (A7)+,D2/A0/A2
  TST.w D2
   BEQ.w JL_0_CBB6

 'l2
  MOVE.b (a5),d0
      CMP.b #" ",d0
      BNE 'l1
      ADDQ.w #1,a5
BRA 'l2

 'l1
  TST.b thenmode
     BEQ 'l3
     MOVEQ #":",d0
     BSR.w JL_0_CC98
     MOVE.w #-$7FFE,D0                                     ;write end if
     BSR macputw
     MOVE.w #$800b,d0
     BSR.w macputw
     CLR.b thenmode

 'l3
   MOVEQ.l #$3A,D0
     MOVE.b #1,temp

BRA.w JL_0_CC2A


 JL_0_CBDE:
  BPL.w JL_0_CC2A
  CMP.w #-$7FF3,D0                                         ;macro ?
   BNE.w JL_0_CBF4
  ADDQ.w #1,coolnest
BRA.w JL_0_CC22

 JL_0_CBF4:
  CMP.w #$80d7,d0                                          ;object ?
    BNE 'l1x
    TST.b objectcount
    BNE macnesterr

 'l1x
  CMP.w #$8021,d0
    BNE 'nothen
    MOVE.b #1,thenmode

 'nothen
  TST.b thenmode
        BEQ 'l1
   CMP.w #$8002,d0                                         ;end if
   BNE 'l1
   MOVEM.l d0/a5,-(a7)
   JSR get1bytemain
   MOVE.w d0,d1
   MOVEM.l (a7)+,a5/d0
   CMP.w #$800b,d1
   BNE 'l1
   CLR.b thenmode

 'l1
   CMP.w #-$7FFE,D0                                        ;end ?
   BNE.w JL_0_CC22
   MOVE.l a5,-(a7)
   JSR get1bytemain
   MOVE.l (a7)+,a5
   TST.w d0
   BEQ 'doend
   CMP.w #":",d0
   BEQ 'doend
   CMP.w #";",d0
   BEQ 'doend
   MOVE.l a5,-(a7)
   JSR get1bytemain
   MOVE.l -1(a5),d0
   MOVE.l (a7)+,a5
   CMP.l #"noa7",d0
   BEQ 'doend
BRA 'morechar

 'doend:
  MOVE.w #$8002,D0
   BSR.w macputw
BRA JL_0_CBB6

 'morechar
  JSR get1bytemain
   CMP.w #-$7FF3,D0                                        ;end macro
   BEQ.w 'lo1
  CMP.w #$80d7,d0                                          ;end object
  BNE JL_0_CC12
  SUBQ.b #1,objectcount
  TST.b developobject
  BEQ 'lo1
  BSR skiprest
RTS

 'lo1
  SUBQ.w #1,coolnest
   BMI.w JL_0_CC32

 JL_0_CC12:
  MOVE.w D0,-(A7)
  MOVE.w #$8002,D0
   BSR.w macputw
  MOVE.w (A7)+,D0
BRA.w JL_0_CC22

 JL_0_CC22:
  BSR.w macputw
BRA.w JL_0_CBB6

 JL_0_CC2A:
    CMP.w #"@@",-1(a5)                                     ;merge lines
    BNE 'no
     MOVEM.l D2/A0/A2,-(A7)
   JSR nextline
   BEQ.w macenderr
  MOVEM.l (A7)+,D2/A0/A2
    TST.w D2
   BEQ.w JL_0_CBB6
BRA JL_0_CBB6

 'no
  BSR.w JL_0_CC98
BRA.w JL_0_CBB6

 JL_0_CC32:
  ADDQ.w #4,A7
  MOVE.l A0,D0
  SUB.l ptr_macrobuffer_begin,D0

 JL_0_CC3C:
   BEQ.w JL_0_CC5E
  CMPI.b #":",-(A0)
   BNE.w JL_0_CC5E
  CMP.w #$1,D0
   BEQ.w JL_0_CC58
  TST.b -$1(A0)
   BMI.w JL_0_CC5E

 JL_0_CC58:
  SUBQ.w #1,D0
BRA.w JL_0_CC3C

 JL_0_CC5E:
  MOVE.w D0,$8(A2)
   BEQ.w JL_0_CC8E
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C
  MOVEA.l D0,A0
  MOVE.l A0,$4(A2)
  MOVE.w $8(A2),D1
   BEQ.w JL_0_CC8E
  SUBQ.w #1,D1
  MOVEA.l ptr_macrobuffer_begin,A1

 JL_0_CC88:
    MOVE.b (A1)+,(A0)+
  DBF D1,JL_0_CC88

 JL_0_CC8E:
JMP get1bytemain


macputw:
  MOVE.w D0,D1
  LSR.w #8,D1
  MOVE.b D1,(A0)+

 JL_0_CC98:
  MOVEQ.l #-$01,D2
  MOVE.b D0,(A0)+
  CMPA.l ptr_macrobuffer_end,A0
   BCC.w macbigerr
RTS


skiprest:
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
  CLR.b skiptoggle

 'loop
    MOVE.b (a5),d0
    BEQ 'l3
    CMP.b #";",d0
    BNE 'l2
    MOVE.b #1,skiptoggle

 'l2
    TST.b skiptoggle
    BNE 'l4
    CMP.b #":",d0
    BEQ 'l3

 'l4
    ADDQ #1,a5
BRA 'loop

 'l3
  MOVE.w d0,lastchar
  MOVE.l (a7)+,d0
RTS


JL_0_CCA8:
  BSR.w ifchar
   BNE.w JUMP_syntaxerr
  MOVE.w D0,D1
  JSR get1bytemain
  BSR.w ifchar
   BNE.w JL_0_CCDA
  ADDQ.w #1,D0
  MOVE.w D0,D2
  ADD.w D0,D0
  ADD.w D2,D0
  ADD.w D0,D1
  MOVE.w D1,D0
  ANDI.w #$3,D0
  CMP.w #$3,D0
   BEQ.w JUMP_syntaxerr

  JSR get1bytemain

 JL_0_CCDA:
RTS

; JUMP_syntaxerr_1:                                        ;?? deactived because doubled??
;JMP syntaxerr


thetst1:  TST.b D0
thetst2:  TST.w D0
thetst3:  TST.l D0
thetst4:  TST.l (A7)+                                      ;Any Length?
thetst5:  JSR _Reschedule(A6)

posbr:    BEQ.w posbr
negbr:    BNE.w negbr


;dounless:                                                 ;??looks like not used??
  MOVEQ.l #-$01,D2
BRA.w JL_0_D04C


.do_while:
  CLR.l fp0addr
  MOVEQ.l #$01,D1                                          ;while flag
  MOVEQ.l #$00,D2                                          ;negate flag
BRA.w JL_0_D04E


freereps:
  LEA firstrep,A2
  MOVEQ.l #$08,D2
BRA.w freeslist


freesels:
  LEA firstsel(PC),A2
  MOVEQ.l #$0E,D2

 freeslist:
    ;free a simple list. a2=lea of list, d2=size
    ;
  MOVEQ.l #$00,D3
    ;
;freelist:                                                 ;??looks like not used??
    ;a2=lea of list, d2=size of item
    ;d3=offset to sub list, d4=size of sublist item
    ;
    ;if d3=0 then single list free only.
    ;
  MOVE.l (A2),D0
  CLR.l (A2)
  MOVEA.l D0,A2
  MOVEA.l _execbase,A6

 freelist__loop:
    CMPA.w #$0,A2
     BEQ.w freelist__done
    TST.w D3
     BEQ.w freelist__skip
    MOVEM.l D2-D3/A2,-(A7)
    ADDA.w D3,A2
    MOVE.l D4,D2
    BSR.w freeslist
    MOVEM.l (A7)+,D2-D3/A2

 freelist__skip:
    MOVEA.l A2,A1
    MOVE.l D2,D0
    MOVEA.l (A2),A2
    MOVE.l mempool,a0
    JSR _FreePooled(A6)
BRA.w freelist__loop

 freelist__done:
RTS

 JUMP_eselerr
JMP eselerr


firstsel:  Ds.l 1

;------                                                  ;disassembled code begin
selpushb:   Dc.b $02,$40,$00,$FF                           ;ANDI.W  #$00FF,D0
;------                                                  ;disassembled code end

selpushw:   MOVE.w D0,-(A7)
selpushbf:   ;
selpushl:   MOVE.l D0,-(A7)
selpushlf:   ;
selpushs:   LEA $4(A7),A2                                  ;(a7)=len of string!
selpushsf:   ;

selcomb:    ANDI.w #$FF,D0
selcomw:    CMP.w (A7),D0
selcombf:    ;
selcoml:    CMP.l (A7),D0
selcomlf:    ;
selbne:     BNE.w selbne

endsel:     ADDQ.w #8,A7


doendsel:                                                  ;doendselect
    ;END SELECT
    ;
  MOVE.l firstsel(PC),D0                                  
   BEQ.w JUMP_eselerr
  MOVEA.l D0,A2
   BSR.w JL_0_CDFC
    ;
    ;fill in all bras at end of cases!
  MOVEA.l _execbase,A6

 doendsel__loop:
  MOVE.l $4(A2),D0
   BEQ.w doendsel__done
  MOVEA.l D0,A3
  MOVEA.l $4(A3),A0
  MOVE.l destpointer,D1
  SUB.l A0,D1
  CNIF #longbranch
    TST.b fast
    BEQ doendsel__loop_l1
    MOVE.w dontwrite,D0
    BNE.w doendsel__skip
    ADDQ.l #2,d1
    MOVE.l d1,-2(a0)
  BRA doendsel__skip
  CEND

 doendsel__loop_l1:
  TST.w dontwrite
     BNE.w doendsel__skip
  CMP.l #MaxWordSgnd,D1
   BHI.w JUMP_cbraerr
  MOVE.w D1,(A0)

 doendsel__skip:                                           ;free it up!
  MOVE.l (A3),$4(A2)                                       ;next of me is new first
  MOVEA.l A3,A1
  MOVEQ.l #$08,D0
  MOVE.l mempool,a0
   JSR _FreePooled(A6)
BRA.w doendsel__loop

 doendsel__done:
  JSR popselect                                            ;fix stack on select
  MOVEA.l firstsel(PC),A1
  MOVE.l (A1),firstsel
  MOVEQ.l #$0E,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
  JSR _FreePooled(A6)
JMP get1bytemain


endselstr:
  MOVEA.l (A7)+,A1
  SUBQ.w #8,A1
  MOVEQ.l #$09,D0
  ADD.l (A1),D0

 endselstrf:
  ADDQ.w #2,A7                                             ;for runtime errs!
endselstrf2:   ;


.do_default:
  MOVE.l firstsel(PC),D0
   BEQ.w JUMP_defaerr
  MOVEA.l D0,A2
  BSR.w JL_0_CE26
  BSR.w JL_0_CDFC
  CLR.l $8(A2)
  MOVE.w $C(A2),D2
BRA.w JL_0_CE5E

 JUMP_defaerr
JMP defaerr

 JL_0_CDFC:
  MOVE.l $8(A2),D0
   BEQ.w JL_0_CE24
  MOVEA.l D0,A0
  MOVE.l destpointer,D1
  SUB.l A0,D1
  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    TST.w dontwrite
    BNE.w JL_0_CE24
    ADDQ.l #2,d1
    MOVE.l D1,-2(A0)
  BRA JL_0_CE24
  CEND

 'l1
  TST.w dontwrite
     BNE.w JL_0_CE24
   CMP.l #MaxWordSgnd,D1
   BHI.w JUMP_cbraerr
  MOVE.w D1,(A0)

 JL_0_CE24:
RTS

 JUMP_cbraerr
JMP cbraerr


JL_0_CE26:
  MOVE.l $8(A2),D0
   BEQ.w JL_0_CE5C
  MOVEA.l D0,A3
  MOVE.w #$6000,D1
 CNIF #longbranch
   TST.b fast
   BEQ 'l1
   OR.l #$ff,d1
   BSR writeword
 CEND

 'l1
  BSR.w writeword
  MOVEQ.l #$08,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
   ;jsr AJL_0_4B6C
  MOVEA.l D0,A0
  MOVE.l $4(A2),(A0)
  MOVE.l A0,$4(A2)
  MOVE.l destpointer,$4(A0)
BRA.w writeword

 JL_0_CE5C:
RTS


JL_0_CE5E:
  TST.b debugmode
   BEQ.w JL_0_CE7A
  MOVE.w #$C313,D1
  CMP.w #$3,D2
   BCS.w JL_0_CE76
  ADDQ.w #1,D1

 JL_0_CE76:
BRA.w Atokejsr

 JL_0_CE7A:
RTS


 JUMP_caseerr
JMP caseerr

.do_case:
  MOVE.l firstsel(PC),D0
   BEQ.w JUMP_caseerr
  MOVEA.l D0,A2
   BSR.w JL_0_CE26
   BSR.w JL_0_CDFC
  MOVE.w $C(A2),D2
  MOVE.w D2,-(A7)
   BSR.w JL_0_CE5E
  MOVE.w (A7),D2
   BSR.w bakeval
  MOVE.w (A7)+,D2
  LEA selcomb(PC),A0
  LEA selcombf(PC),A1
  CMP.w #$1,D2
   BEQ.w JL_0_CED8
  LEA selcomw(PC),A0
  CMP.w #$2,D2
   BEQ.w JL_0_CED8
  LEA selcoml(PC),A0
  LEA selcomlf(PC),A1
  CMP.w #$7,D2
   BCS.w JL_0_CED8
    ;Strings....
  MOVE.w #$CE01,D1
   BSR.w Atokejsr
BRA.w JL_0_CEDC

 JL_0_CED8:
  BSR.w pokecode

 JL_0_CEDC:
  MOVE.w selbne(PC),D1
  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    ORI.l #$ff,d1
    BSR writeword
  CEND
 'l1
  BSR.w writeword
  MOVEA.l firstsel(PC),A0
  MOVE.l destpointer,$8(A0)
BRA.w writeword


;------                                                  ;disassembled code begin
pcchk:      Dc.b $3F,$3C,$73,$45                           ;MOVE.W  #$7345,-(A7)   ;#"sE",-(a7) org source
clrst:      Dc.b $42,$A7                                   ;CLR.L   -(A7)
;------                                                  ;disassembled code end

sellineat:  Ds.l 1


.do_select:
    ;OK, as in : SELECT opt
    ;
  TST.b debugmode
   BEQ.w JL_0_CF0E
  MOVE.l pcchk(PC),D1                                      ;move #"sE",-(a7)
   BSR.w writelong

 JL_0_CF0E:
  MOVE.l linenumat,sellineat
   ;bsr.w pushstart                                        ;we may have to CLR -(a7)!
   MOVE.l destpointer,pushpc
  MOVE.l hunkoffsetbase,pushoff
  MOVEQ.l #$00,D2
   BSR.w bakevalu                                          ;Evaluate
   BSR.w JL_0_B5D2
  CMP.w #$7,D2
   BNE.w JL_0_CF36
  MOVE.w clrst(PC),D1
   BSR.w writeword

 JL_0_CF36:
   BSR.w JL_0_B63C
  LEA selpushb(PC),A0
  LEA selpushbf(PC),A1
  CMP.w #$1,D2
   BEQ.w JL_0_CF88
  LEA selpushw(PC),A0
  CMP.w #$2,D2
   BEQ.w JL_0_CF88
  LEA selpushl(PC),A0
  LEA selpushlf(PC),A1
  CMP.w #$7,D2
   BCS.w JL_0_CF88
    ;
  MOVE.w moved0a3,D1                                       ;d0 to a3!
   BSR.w writeword
  LEA selpushs(PC),A0
  LEA selpushsf(PC),A1
   BSR.w pokecode
  MOVE.w #$C701,D1
   BSR.w Atokejsr
BRA.w JL_0_CF8C

 JL_0_CF88:
  BSR.w pokecode

 JL_0_CF8C:
  MOVEQ.l #$0E,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
   ;jsr AJL_0_4B6C
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  MOVEA.l D0,A0
  MOVE.l firstsel(PC),(A0)
  MOVE.l A0,firstsel
  CLR.l $4(A0)
  CLR.l $8(A0)
  MOVE.w D2,$C(A0)
RTS


.do_Forever:
  MOVE.l firstrep,D0
   BEQ.w JUMP_unterr1
  MOVE.w #$6000,D1
  BSR.w writeword
  MOVEA.l D0,A0
  MOVE.l $4(A0),D1
  SUB.l destpointer,D1
  TST.w D1
   BPL.w JUMP_unterr2
  BSR.w writeword
  MOVEA.l _execbase,A6
BRA.w JL_0_D036

 JUMP_unterr2
JMP unterr2

 JUMP_unterr1
JMP unterr1


.do_Until:
  MOVE.l firstrep,D0
   BEQ.w JUMP_unterr1
  BSR.w do_if
  JSR reget
   BNE.w JUMP_syntaxerr
  MOVE.w dontwrite,D1
   BNE.w JL_0_D020
  MOVEA.l firstrep,A0
  MOVEA.l destpointer,A1
  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    SUBQ.w #4,a1
    MOVE.l $4(A0),D2
    SUB.l A1,D2
    MOVE.l d2,(a1)
  BRA JL_0_D020
  CEND

 'l1
  SUBQ.w #2,A1
  MOVE.l $4(A0),D2
  SUB.l A1,D2
  TST.w D2
   BPL.w JUMP_unterr2
  MOVE.w D2,(A1)

 JL_0_D020:
  MOVEA.l firstiff,A1
  MOVE.l (A1),firstiff
  MOVEQ.l #$0E,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
  JSR _FreePooled(A6)

 JL_0_D036:
  MOVEA.l firstrep,A1
  MOVE.l (A1),firstrep
  MOVEQ.l #$08,D0
  MOVE.l mempool,a0
JMP _FreePooled(A6)


iflineat:   Ds.l 1


.do_if:
  MOVEQ.l #$00,D2
  TST.b fast
  BEQ 'l1
  MOVE.b #1,nostringopt
  MOVE.b #1,iniffcommand

 'l1
 JL_0_D04C:                                                ;??looks like double label??
  MOVEQ.l #$00,D1

 JL_0_D04E:
  MOVE.w D1,-(A7)
  MOVE.l destpointer,-(A7)
  MOVE.w D2,-(A7)
  MOVE.l linenumat,iflineat
  MOVEQ.l #$00,D2
  MOVE.b optistring,optistring2
  MOVE.b #1,optistring
  BSR.w bakevalu
  MOVE.b optistring2,optistring
  CMP.w #$5,D2
   BEQ.w JL_0_D09C
  MOVE.w thetst1(PC),D1
  CMP.w #$1,D2
   BEQ.w writebranchcode
  MOVE.w thetst2(PC),D1
  CMP.w #$2,D2
   BEQ.w writebranchcode
  MOVE.w thetst4(PC),D1
  CMP.w #$7,D2
   BEQ.w writebranchcode
  MOVE.w thetst3(PC),D1
BRA.w writebranchcode

 JL_0_D09C:
  TST.b fpu
  BEQ 'dofpu
  MOVE.l #$f200003a,d1
  BSR writelong
  MOVE.w #$f2c1,d1
  BSR writeword
  BSR writelong
  ADDQ.l #2,a7
BRA.w br2

 'dofpu
   MOVE.w #$C900,D1
   BSR.w Atokejsr
  MOVE.l thetst5(PC),D1
   BSR.w writelong
BRA.w JL_0_D0B4


.writebranchcode:
         CLR.b iniffcommand
         TST.b fast                                        ;branchcode
         BEQ b6
         TST.b fpu
         BEQ 'nofpu
         CNIF #optibreak
           ILLEGAL
         CEND
          MOVE.l destpointer,a0
         SUB.l load_var_addr,a0
         CMP.l #4,a0
         BEQ 'nofpu
         CMP.l #$f2400014,-4(a4)                           ;<
         BNE 'nolt
         SUBQ.l #2,destpointer
         MOVE.w #$f293,-4(a4)                              ;
BRA 'brf

 'nolt
  CMP.l #$f2400015,-4(a4)                                  ;<=
         BNE 'nole
         SUBQ.l #2,destpointer
         MOVE.w #$f292,-4(a4)
BRA 'brf

 'nole
  CMP.l #$f2400013,-4(a4)                                  ;=>
         BNE 'noge
         SUBQ.l #2,destpointer
         MOVE.w #$f294,-4(a4)
BRA 'brf

 'noge
  CMP.l #$f2400012,-4(a4)                                  ;>
         BNE 'nogt
         SUBQ.l #2,destpointer
         MOVE.w #$f295,-4(a4)
BRA 'brf

 'nogt
  CMP.l #$f2400001,-4(a4)                                  ;=
         BNE 'noeq
         SUBQ.l #2,destpointer
         MOVE.w #$f28e,-4(a4)
BRA 'brf

 'noeq
  CMP.l #$f240000e,-4(a4)                                  ;<>
         BNE 'none
         SUBQ.l #2,destpointer
         MOVE.w #$f281,-4(a4)

 'brf
  ADDQ.l #2,a7
  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    OR.b #$40,-3(a4)
    BSR writeword
  CEND

'l1
 BSR writeword
BRA.s br2

 'none                                                     ;??Looks like double label??
 'nofpu
  MOVE.l destpointer,a0
         SUB.l load_var_addr,a0
         CMP.l #4,a0
         BEQ JL_0_D0B4
         CMP.w #$4eb9,-6(a4)
         BEQ b6
         CMP.w #$5ec0,-2(a4)                               ;>
     BNE.s 'lb1
         MOVE.w #$6f00,-2(a4)                              ;ble
BRA.s br

 'lb1
 CMP.w #$5dc0,-2(a4)                                       ;<
  BNE.s 'lb2
         MOVE.w #$6c00,-2(a4)                              ;bge
BRA.s br

 'lb2
  CMP.w #$57c0,-2(a4)                                      ;=
  BNE.s 'lb3
         MOVE.w #$6600,-2(a4)                              ;bne
BRA.s br

 'lb3
  CMP.w #$56c0,-2(a4)                                      ;<>
  BNE.s 'lb4
         MOVE.w #$6700,-2(a4)                              ;beq
BRA.s br

 'lb4
  CMP.w #$5cc0,-2(a4)                                      ;>=
  BNE.s 'lb5
         MOVE.w #$6d00,-2(a4)                              ;blt
BRA.s br

 'lb5
  CMP.w #$5fc0,-2(a4)                                      ;<=
        BNE.s b6
         MOVE.w #$6e00,-2(a4)                              ;bgt

 br
  TST.w (a7)+
  CNIF #longbranch
        TST.b fast
        BEQ 'l1
        OR.b #$ff,-1(a4)                                   ;long branches
        BSR writeword
  CEND

'l1
        BSR writeword
BRA.s br2

 b6
  BSR.w writeword

JL_0_D0B4:
  MOVE.l posbr(PC),D1
  TST.w (A7)+
   BEQ.w JL_0_D0C2
  MOVE.l negbr(PC),D1

 JL_0_D0C2:
  TST.b fast
           BEQ 'l1
           OR.l #$00ff0000,d1
           BSR writelong
           BSR writeword
BRA br2

 'l1
  BSR.w writelong

 br2
 MOVEQ.l #$0E,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
   ;jsr AJL_0_4B6C
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  MOVEA.l D0,A0
  MOVE.l firstiff,(A0)
  MOVE.l A0,firstiff
  MOVE.l (A7)+,$4(A0)
  MOVE.l destpointer,$8(A0)
  MOVE.w (A7)+,$C(A0)
   JSR reget
   BEQ.w JL_0_D10C
  BSET #$7,$C(A0)

 .do_then:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  MOVE.w #$003A,lastchar

 JL_0_D10C:
RTS


 JL_0_D10E:
  CMP.w #$1,D0
   BLT.w JL_0_D128
  CMP.w #$0,D0
   BGT.w JL_0_D128
  ADD.w D0,D0
  ADD.w D0,D0
  MOVEA.l JL_0_D128(PC,D0.W),A0

 L_0_D126:
JMP (A0)

 JL_0_D128:                                                ;??
BRA.w JL_0_D128


JL_0_D12C:
  CMP.w #$1,D0
   BLT.w JL_0_D146
  CMP.w #$0,D0
   BGT.w JL_0_D146
  ADD.w D0,D0
  ADD.w D0,D0
  MOVEA.l JL_0_D146(PC,D0.W),A0

 L_0_D144:
  JSR (A0)

 JL_0_D146:                                                ;??
BRA.w JL_0_D146


JL_0_D14A:
  CMP.w #$1,D0
   BLT.w JL_0_D168
  CMP.w #$0,D0
   BGT.w JL_0_D168
  ADD.w D0,D0
  ADD.w D0,D0
  MOVEA.l JL_0_D168(PC,D0.W),A0

 AL_0_D162:
  MOVE.w #$6753,-(A7)                                      ;#'gS' ;for runtime error checking!

 L_0_D166:
   JSR (A0)

 JL_0_D168:                                                ;??
BRA.w JL_0_D168


labcnt:   Ds.w 1


.do_Ongo:                                                  ;On expression Goto/Gosub Label[Label...]
    ;
    ;Get expression as a word.
    ;
  MOVEQ.l #$02,D2
   BSR.w bakeval
  LEA JL_0_D10E(PC),A0
  LEA JL_0_D12C(PC),A1
  MOVE.w #$001A,D1
  CMP.w #-$7FFB,D0
   BEQ.w JL_0_D1B6
  CMP.w #-$7FFA,D0
   BNE.w JUMP_syntaxerr
  LEA JL_0_D12C(PC),A0
  LEA JL_0_D14A(PC),A1
  MOVE.w #$001A,D1
  TST.b debugmode
   BEQ.b JL_0_D1B6
   JSR chkstak
  LEA JL_0_D14A(PC),A0
  LEA labcnt(PC),A1
  MOVE.w #$001E,D1

 JL_0_D1B6:
  MOVE.w D1,-(A7)
  MOVE.l destpointer,-(A7)                                 ;for when we know number of labels!
   BSR.w pokecode
  CLR.w labcnt
    ;
    ;now, make a labels list!
    ;
 JL_0_D1C8:
   JSR get1bytemain
  SUBQ.l #2,destpointer                                    ;for makealab!
   BSR.w JL_0_AE22
  ADDQ.l #2,destpointer
   JSR addoff
  MOVE.l $8(A2),D1
   BSR.w writelong
  ADDQ.w #1,labcnt
   JSR reget
  CMP.w #$2C,D0
   BEQ.w JL_0_D1C8
  MOVEA.l (A7)+,A0
  MOVE.w (A7)+,D2
  MOVE.w dontwrite,D1
   BNE.w JL_0_D21A
  MOVE.w labcnt(PC),D1
  MOVE.w D1,$A(A0)
  ADD.w D1,D1
  ADD.w D1,D1
  ADDQ.w #2,D1
  MOVE.w D1,$2(A0,D2.W)

 JL_0_D21A:
RTS


.do_gosub:
  TST.b debugmode
   BEQ.w JL_0_D236
   JSR chkstak
  MOVE.l AL_0_D162,D1
   BSR.w writelong
 JL_0_D236:
  MOVE.w gosubcode,D1
BRA.w JL_0_D246


 .do_goto:
  MOVE.w gotocode,D1

 JL_0_D246:
  MOVE.w D1,-(A7)
   BSR.w JL_0_AE22
  MOVE.w (A7)+,D1
   BSR.w writeword
   JSR addoff
  MOVE.l $8(A2),D1
BRA.w writelong


.do_AsmExit:
  MOVE.w proceduremode,D1
   BEQ.w JUMP_badpenderr
  MOVE.w #$4EF9,D1
   BSR.w writeword
   JSR addoff
  MOVEA.l _execbase,A6
  MOVEQ.l #$08,D0
  MOVEQ.l #$01,D1
   ;jsr AJL_0_4B6C
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  MOVEA.l D0,A0
  MOVE.l firstpend,(A0)
  MOVE.l A0,firstpend
  MOVE.l destpointer,$4(A0)
BRA.w writelong


JL_0_D29C:
  BSR.w do_AsmExit
JMP get1bytemain


do_function_return:
  MOVE.b #1,nostringopt
  MOVE.l a0,-(a7)
  MOVEA.l currentfunction,A0
    CMP.l #0,a0
    BNE 'l1
    JMP errorasmexit
'l1 MOVEQ.l #$00,D2
  MOVE.b $5(A0),D2
  BSR.w eval
CNIF #function_support_returntype
  MOVEA.l currentfunction,A0
  MOVE.l funcstruct_returntype(a0),a0
  CMP.l #0,a0
  BEQ 'isstatement
  CMP.l #$100,4(a0)
  BLT.w 'isvar
  CMP.l a0,a2
  BNE error_convert_types2
'isvar
'isstatement
CEND
  MOVE.l (a7)+,a0
BRA.w do_AsmExit

error_convert_types2 JMP error_convert_types

.do_return:
;  TST.w proceduremode                                      ; return work in functions
;  BEQ 'no                                                  ; must forbid gosub in functions
;  TST.l currentfunction                                    ; if that work
;  BEQ 'no
;  SUBQ.l #1,a5
;  BGT JL_0_D2A4
;  CMP.w #$ffff,proceduremode
;  BEQ JL_0_D29C
;
;'no
  TST.b debugmode
   BEQ.w JL_0_D2CA
  MOVE.w #$C305,D1
BRA.w Atokejsr

 JL_0_D2CA:
  MOVE.w #$4E75,D1
BRA.w writeword


localslist:  Ds.l 1                                        ;all locals for procs.;??Looks like obsovled data??
proclocals:  Ds.l 1                                        ;for debugga!
procnum:     Ds.w 1
procnum2:    Ds.w 1
prolineat:   Ds.l 1


.do_statement:
   TST.w proceduremode
   BGT JUMP_sreterr
   CMP.w #-$7FF9,D0
   BEQ.w JL_0_D29C
   MOVEQ.l #-$01,D1
BRA.w do_function2

 JUMP_sreterr
JMP sreterr


checkused
  CLR.b skipfunc
  TST.l unusedfunc
  BEQ 'ex
  MOVEM.l d0-d7/a0-a6,-(a7)
  MOVE.l unusedfunc,d1
  LEA ptr_parameterstore,a5

 'ag
  MOVE.l d1,a0
  LEA 12(a0),a2
  MOVE.l a5,a1
 'ch
  CMPM.b (a1)+,(a2)+
  BNE 'neq
  TST.b (a2)
  BNE 'ch
  TST.b (a1)
  BNE 'neq
  MOVE.b #1,skipfunc
BRA 'out

 'neq
  MOVE.l (a0),d1
  BNE 'ag

 'out
  MOVEM.l (a7)+,d0-d7/a0-a6

 'ex
RTS


 JUMP_dupprocerr
JMP dupprocerr

 JUMP_illprocperr
JMP illprocperr


; JUMP_sreterr_2                                           ;deaktived because double
;JMP sreterr

.do_function:
  CMP.w #-1,proceduremode                                  ;was JUMP_sreterr_2
   BEQ JUMP_sreterr
  CMP.w #-$7FF9,D0
   BEQ.w do_function_return

  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  JSR getfunctionreturntype
  JSR get1bytemain

do_function2:                                             ;do_statement jump to here
  TST.b declare
  BEQ 'l1
  MOVE.b #1,nowdeclare

 'l1
  JSR errchx                                           ;writejumpoverfunction

 returnaddr
  CLR.b fastfunc
  MOVE.l firstiff,firstiffstore
  CMP.l #"FAST",-1(a5)
  BNE 'nofast
  CMP.b #" ",3(a5)
  BNE 'nofast
  ADDQ.l #3,a5

 'x2
    CMP.b #" ",(a5)
     BNE 'x1
    ADDQ #1,a5
BRA 'x2

 'x1
  MOVE.l a5,lastsourcepos
  MOVE.b #1,fastfunc

 'nofast
  CMP.l #"NOOP",-1(a5)                                     ;compile 3* so its deactivate
BRA 'noopt

  CMP.w #"T ",3(a5)                                        ;??Looks like dead code??
  BNE 'noopt
  ADDQ.l #4,a5

 'x2b
    CMP.b #" ",(a5)
     BNE 'x1b
    ADDQ #1,a5
BRA 'x2b

 'x1b
  MOVE.l a5,lastsourcepos
;  BSR makename2
  JSR makename2
BRA 'l1

 'noopt
;  BSR.w makename2
  JSR makename2
  JSR checkused
  TST.b skipfunc
   BEQ 'l1
  JSR skipme
  CLR.b fastfunc
RTS

 'l1
  MOVE.l linenumat,prolineat
  ADDQ.w #1,procnum2
  MOVE.w procnum2(PC),procnum
  MOVE.w D1,proceduremode
  CLR.w locvaroff
  CMP.w #$7B,D0
   BNE.w JUMP_syntaxerr
   MOVE.b #1,infunctioncode
  MOVEA.l tempvm,A0
  MOVE.w $C(A0),memlibstat
  BCLR #$7,$C(A0)                                          ;Bit out of range
  MOVE.w #$4EF9,D1
   BSR.w writeword
   JSR addoff
   BSR.w writelong
   BSR.w findproc                                          ;findproc function
   BEQ.w JUMP_dupprocerr
   BSR.w addlabel
   MOVE.b #31,$20(a2)                                      ;increase if more pars
   MOVE.b #0,isfunc(a2)
   MOVE.l functionreturntype,funcstruct_returntype(a2)
  MOVE.l destpointer,$E(A2)
  MOVE.l A2,currentfunction
  LEA nops8,A0
  LEA dataget,A1
   BSR.w pokecode2
  TST.b debugmode
   BEQ.b JL_0_D3AA
  MOVEQ.l #$04,D1
   JSR writetrap
  MOVE.l destpointer,proclocals
   BSR.w writelong
   BSR.w writelong

 JL_0_D3AA:
   LEA $16(A2),A4
  MOVE.b proceduremode+1,$5(A2)
  MOVEQ.l #$00,D6
  MOVEQ.l #$00,D5
   JSR get1bytemain
  CMP.w #$7D,D0
   BEQ.w JL_0_D466

 JL_0_D3C6:
   CMP.b #"@",d0
   BNE 'l2
   MOVE.l a0,-(a7)
   MOVE.l currentfunction,a0
   CMP.b #31,$20(a0)                                       ;increase if morepars
   BNE 'l1
   MOVE.b d6,$20(a0)                                       ;increase if morepar

 'l1
   JSR get1bytemain
   MOVE.l (a7)+,a0

 'l2
   BSR.w getparameter
   BSR.w JL_0_8E3C
  CMPI.l #$7,$4(A2)
   BNE.w JL_0_D3F6
  LEA stbuff,A0
  MOVE.w D5,D1
  LSL.w #2,D1
  MOVE.w D6,$0(A0,D1.W)
  MOVE.w $4(A3),$2(A0,D1.W)
  ADDQ.w #1,D5
  MOVEQ.l #$07,D2
BRA.w JL_0_D442

 JUMP_toovarerr
JMP toovarerr

 JL_0_D3F6:
  MOVE.w #$2940,D1
  MOVEQ.l #$03,D2
  BTST #$0,flagmask+1
   BNE.w JL_0_D430
  CMPI.l #$100,$4(A2)
   BCC.w JUMP_illprocperr
  MOVE.w $6(A2),D2
  CMP.w #$2,D2
   BHI.w JL_0_D430
   BEQ.w JL_0_D42C
  EORI.w #$3000,D1
BRA.w JL_0_D430

 JUMP_more6pard
JMP more6pard

 JL_0_D42C:
  ORI.w #$1000,D1

 JL_0_D430:
  OR.w D6,D1
  TST.b fpu
  BEQ 'nofpu
  CMP.b #5,d2
  BNE 'nofpu
  CMP.w #6,d6
  BLT 'l10a
  CMP.l #newtype_double,a2
  BEQ JUMP_more6pard
BRA 'nofpu

 'l10a
  MOVE.l #$f22c6400,d1
  MOVEM.l d0/a4,-(a7)
  MOVE.l d6,d0
  ASL.l #7,d0
  OR.w d0,d1
  CMP.l #newtype_double,a2
  BNE 'l1
  OR.l #$1000,d1

 'l1
  BSR writelong
  MOVE.w 4(a3),d1
  BSR writeword
  MOVEM.l (a7)+,a4/d0
BRA JL_0_D442

 'nofpu
  MOVE.l A4,-(A7)
   CMP.w #6,d6
   BLT 'l10
   MOVE.w #$c500-4,d1                                      ;savetemp+regnum
   ADD.w d6,d1
   JSR Atokejsr
   TST.w dontwrite
   BNE 'l10
   MOVE.l data1start,d1
   MOVE.l destpointer,a4
   ADD.l d1,-6(a4)
   MOVE.l destpointer,d1
   SUBQ.l #6,d1
   SUB.l destbufferstart,d1

   MOVE.l d2,-(a7)
   MOVE.l d1,d2
   JSR addhunkoffset                                       ;move.l $0,-x(a4)
   MOVE.l (a7)+,d2
   MOVE.l destpointer,a4
   CMP.w #2,d2
   BNE 'nw1

   MOVE.w #$3979,-8(a4)                                    ;move.w $0,-x(a4)
   ADD.l #2,-6(a4)

 'nw1
   CMP.w #1,d2
   BNE 'nb
   MOVE.w #$1979,-8(a4)                                    ;move.b $0,-x(a4)
   ADD.l #3,-6(a4)

 'nb
   MOVE.w $4(a3),-2(a4)
BRA 'ne1

 'l10
  BSR.w writeword                                          ;write storeparameter

 'l20
  MOVE.w $4(A3),D1
   BSR.w writeword

 'ne1
  MOVEA.l (A7)+,A4

JL_0_D442:
  CLR.l functionreturntype
  ADDQ.w #1,D6
  CMP.w #11,D6                                             ;max function parameters
   BCC.w JUMP_toovarerr
  MOVE.l currentfunction,a0
  MOVE.l a2,funcstruct_parametertype-4(a0,d6*4)                                    ;-4 because d6 is increment before
  MOVE.b D2,(A4)+
  CMP.w #$2C,D0
   BNE.w JL_0_D45E
   JSR get1bytemain

;   CMP.b #"@",d0
;   BNE JL_0_D3C6
;   MOVE.l a0,-(a7)
;   MOVE.l currentfunction,a0
;   CMP.b #31,$20(a0)                                       ;increase if morepars
;   BNE 'l1
;   MOVE.b d6,$20(a0)

;'l1 JSR get1bytemain
;   MOVE.l (a7)+,a0
BRA.w JL_0_D3C6

 JL_0_D45E:
  CMP.w #$7D,D0
   BNE.w JUMP_syntaxerr

 JL_0_D466:
  MOVEA.l currentfunction,A2
  LSL.w #4,D5
  OR.w D5,D6
  MOVE.b D6,$4(A2)
  LSR.w #4,D6
   BEQ.w JL_0_D4C4
  LEA stbuff,A0
  SUBQ.w #1,D6

 JL_0_D482:
    MOVE.w D6,D1                                           ;function stringpars
    LSL.w #2,D1                                            ;stringsize was 2
    CNIF #more6string
      LSL.w #1,d1
      ADDQ.w #4,d1
    CEND
    ADDQ.w #8,D1
    MOVE.w D1,funcst+2
    MOVE.l funcst,D1
    BSR.w writelong
    MOVE.w (A0)+,D1
    CMP.b #5,d1
    BLE 's1
    MOVE.w #$266c,d1                                       ;native move.l 4(a4),a3
    BSR writeinstruction
    MOVE.w D6,D1                                           ;function stringpars
    LSL.w #2,D1                                            ;stringsize was 2
    CNIF #more6string
      LSL.w #1,d1
    CEND
    ADDQ.w #8,D1
    BSR writeword
  BRA 's2

   's1
    OR.w movedna3,D1
     BSR.w writeword

   's2
    MOVE.w (A0)+,least+2
    MOVE.l least,D1
     BSR.w writelong
    MOVE.l A0,-(A7)
    MOVE.w #$C700,D1
     BSR.w Atokejsr
    MOVEA.l (A7)+,A0
  DBF D6,JL_0_D482

 JL_0_D4C4:
JMP get1bytemain


JL_0_D4C8:
  MOVE.w dontwrite,D1
   BNE.w JL_0_D4F6
  MOVE.l destpointer,-(A7)
  MOVE.l A0,destpointer
  MOVE.l linksize,D1
   BSR.w writelong                                         ;writefunctions jumppos
   TST.b fastfunc
   BNE 'skip
  MOVE.w #$CC00,D1
   BSR.w tokejsr2                                          ;write clearvars

 'skip
  MOVE.l (A7)+,destpointer

 JL_0_D4F6:
RTS


JL_0_D4F8:
  MOVEA.l currentfunction,A2
  MOVEA.l $E(A2),A0
  MOVE.w $6(A2),D1
   BEQ.w JL_0_D538
  MOVE.w D1,linksize+2
  MOVE.w $8(A2),D1                                         ;check if function memalloc need
   BNE.w JL_0_D522
  ADDQ.w #6,A0
  MOVE.l A0,$E(A2)
BRA.w JL_0_D4C8

 JL_0_D522:
  MOVE.l A0,-(A7)
   BSR.w JL_0_D4C8
  MOVEA.l (A7)+,A0
  LEA $A(A0),A0
  MOVEA.l currentfunction,A2
BRA.w JL_0_D54A

 JL_0_D538:
  MOVE.w $8(A2),D1
   BNE.w JL_0_D54A
  LEA $10(A0),A0
  MOVE.l A0,$E(A2)
RTS


 JUMP_errormsg_nofast:
JMP errormsg_nofast

JL_0_D54A:
   MOVE.w dontwrite,D1                                     ;writeallocmem for functions (after releasemem called)
   BNE.w JL_0_D580
   TST.b fastfunc
   BNE JUMP_errormsg_nofast
  MOVE.l destpointer,-(A7)
  MOVE.l A0,destpointer
  MOVE.w #$4EB9,D1
   BSR.w writeword
   JSR addoff
   BSR.w writelong
  MOVEA.l (A7)+,A0
  MOVEA.l destpointer,A1
  MOVE.l A0,-(A1)
  MOVE.l A0,destpointer

 JL_0_D580:
  MOVE.w $8(A2),D4
   BPL.w JL_0_D59E
  MOVE.w #$C004,D1
   BSR.w tokejsr2
  MOVEA.l currentfunction,A2
  MOVE.w $8(A2),D4
  ANDI.w #$7FFF,D4

 JL_0_D59E:
   BEQ.w JL_0_D5E0
  MOVE.b $4(A2),D1
  ANDI.w #$F,D1
  MOVE.w D1,-(A7)
  CMP.w #$5,D1
   BCS.w JL_0_D5BC
  MOVE.w #$2F04,D1
   BSR.w writeword

 JL_0_D5BC:
  MOVE.l locdatast,D3
   JSR datastart
  MOVE.w #$C501,D1
   BSR.w tokejsr2
  MOVE.w (A7)+,D1
  CMP.w #$5,D1
   BCS.w JL_0_D5E0
  MOVE.w #$281F,D1
   BSR.w writeword
 JL_0_D5E0:
  MOVE.w #$4E75,D1
BRA.w writeword


.do_mousewait:
  LEA mwait,A0
  LEA mwaitf,A1
BRA.w pokecode


 JUMP_laberr
JMP laberr

.do_newtype:
  CMP.w #$2E,D0
  BNE.w JUMP_syntaxerr
  JSR getparameter2
  BEQ.w JUMP_laberr
  LEA newtypebase,A2
  JSR findtype
  BNE.w JL_0_D626
  CMPI.l #MaxByte,$4(A2)
  BNE.w JUMP_typeerr
BRA.w JL_0_D62A

 JUMP_typeerr
JMP typeerr

 JL_0_D626:
  JSR addlabel

 JL_0_D62A:
  CLR.l $4(A2)
  MOVE.l A2,thistype
  CLR.l prevtype
  CLR.w typelen
  CLR.w linemode
  JSR reget
  BNE.w typemode
RTS

 typemode:
  CMP.w #-$7FFE,D0
  BEQ.w JL_0_D82E
   ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  MOVEQ.l #$00,D6
  CMP.w #$2A,D0
  BNE.w JL_0_D670
  MOVEQ.l #$01,D6
  JSR get1bytemain
BRA.w JL_0_D67E

 JL_0_D670:
  CMP.w #$40,D0
  BNE.w JL_0_D67E
  MOVEQ.l #$05,D6
  JSR get1bytemain

 JL_0_D67E:
  MOVE.w D6,flagmask
  JSR getparameter2
  BEQ.w JUMP_syntaxerr
  MOVEA.l thistype,A2
  ADDQ.w #4,A2
  JSR findvariable2
  BEQ.w JUMP_dupofferr
  JSR addlabel
  MOVE.l A2,-(A7)
  CMP.w #$2E,D0
   BEQ.w JL_0_D6CE
  CMP.w #$24,D0
   BNE.w JL_0_D6C0
  MOVE.l #newtype_string,D2
   JSR get1bytemain
BRA.w JL_0_D710

 JUMP_dupofferr
JMP dupofferr

 JL_0_D6C0:
  MOVE.l prevtype,D2
  BEQ.w JUMP_notypeerr
BRA.w JL_0_D706

 JUMP_notypeerr
JMP notypeerr

 JL_0_D6CE:
  JSR getparameter2
   BEQ.w JUMP_syntaxerr
  LEA newtypebase,A2
   JSR findtype
   BEQ.w JL_0_D704
  BTST #$0,flagmask+1
   BEQ.w JUMP_notypeerr
  JSR addlabel

 'n
  MOVE.w linenumat+2,$8(A2)
  MOVE.l #MaxByte,$4(A2)

 JL_0_D704:
  MOVE.l A2,D2

 JL_0_D706:
  CMP.l #newtype_byte,D2
   BEQ.w JL_0_D71E

 JL_0_D710:
  ADDQ.w #1,typelen
  BCLR #$0,typelen+1

 JL_0_D71E:
  MOVEQ.l #$00,D3
  MOVEA.l D2,A2
  MOVE.l A2,prevtype
  MOVE.w $8(A2),D3
  MOVEA.l (A7)+,A2
  MOVE.l D2,$A(A2)
  MOVEQ.l #$00,D4
  MOVE.w typelen,D4
  MOVE.w D4,$4(A2)
  BTST #$0,flagmask+1
   BEQ.w JL_0_D74C
  MOVEQ.l #$04,D3

 JL_0_D74C:
  CMP.w #$5B,D0
   BNE.w JL_0_D782
  MOVEM.l D3-D4/A2,-(A7)
   BSR.w AJL_0_BF6E
  CMP.w #$5D,D0
   BNE.w JUMP_syntaxerr
  TST.w D6
   BNE.w JUMP_fpconerr
  MOVE.l D3,D1
  MOVEM.l (A7)+,D3-D4/A2
   JSR get1bytemain
  MOVE.w D1,$8(A2)
  MULU.l d1,d3                                             ;>32k fix was mulu.w
  ORI.w #$2,flagmask

 JL_0_D782:
  ADD.l D3,D4

  CNIF #types64
    CMP.l #65532,d4
  CELSE
    CMP.l #32764,d4
  CEND

  BCC JUMP_toolongerr
  MOVE.w flagmask,$6(A2)
  MOVE.w D4,typelen
RTS

 JUMP_badenderr
JMP badenderr

 JUMP_noiferr
JMP noiferr

 JUMP_toolongerr
JMP toolongerr

 JUMP_fpconerr
JMP fpconerr

JL_0_D79E:
  MOVE.l firstiff,D0
   BEQ.w JUMP_noiferr
  MOVEA.l D0,A0
  MOVE.w $C(A0),D0
  ANDI.w #$FF,D0
  CMP.w D0,D1
   BNE.w JUMP_badenderr

 AJL_0_D7B8:
  CMP.w #$1,D1
  BNE.w JL_0_D7D8
  MOVE.w #$6000,D1

  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    OR.l #$ff,d1
  CEND

 'l1
  BSR.w writeword
  MOVEA.l destpointer,A1
  MOVE.l $4(A0),D1
  SUB.l A1,D1

  CNIF #longbranch
    TST.b fast
    BEQ 'l2
    BSR writelong
  BRA JL_0_D7D8
  CEND

 'l2
  BSR.w writeword

 JL_0_D7D8:
  MOVEA.l $8(A0),A1                                        ;write if branch destination
  MOVE.l destpointer,D1
  SUB.l A1,D1

  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    ADDQ.l #4,D1
    MOVE.w dontwrite,D0
    BNE.w JL_0_D7FE
    MOVE.l d1,-$4(a1)
  BRA JL_0_D7FE
  CEND

 'l1
  ADDQ.l #2,d1
  TST.w dontwrite
  BNE JL_0_D7FE
  CMP.l #MinWordSgnd,D1
  BCC.w JUMP_bigiferr
  MOVE.w D1,-$2(A1)

 JL_0_D7FE:
RTS

 JUMP_bigiferr
JMP bigiferr


.do_Wend:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

 JL_0_D804:
  MOVEQ.l #$01,D1
BRA.w JL_0_D810

 .mydo_Endif2:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

 JL_0_D80E:
  MOVEQ.l #$00,D1

 JL_0_D810:
  BSR.w JL_0_D79E
  BSR.w AJL_0_D81C
JMP get1bytemain

 AJL_0_D81C:
  MOVE.l (A0),firstiff
  MOVEA.l A0,A1
  MOVEQ.l #$0E,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
JMP _FreePooled(A6)


JL_0_D82E:
  JSR get1bytemain

 .do_end:
  BEQ.w JL_0_D980
  CMP.l #"noa7",-1(a5)
  BNE 'l1
  JSR get1bytemain
  JSR get1bytemain
  JSR get1bytemain
  MOVE.w #$3a,lastchar
BRA JL_0_D980

 'l1
  CMP.w #"d0",-1(a5)
  BNE 'l2
  MOVE.b #1,returncode
  CLR.w lastchar
BRA JL_0_D980

 'l2
  CMP.w #$80d7,d0
  BNE JL_0_D836
  JSR skiprest
RTS

 JL_0_D836:
  BSR.w JL_0_D844
  JSR reget
  BNE.w JL_0_D836
RTS

 JL_0_D844:
  CMP.w #-$7FFF,D0
   BNE.w JL_0_D87E
  MOVE.w linemode,D1
   BNE.w JUMP_modeerr
  ADDQ.w #1,typelen
  BCLR #$0,typelen+1
  MOVEA.l thistype,A0
  MOVE.w typelen,$8(A0)
  MOVE.w #$FFFF,linemode
JMP get1bytemain

 JUMP_modeerr
JMP modeerr

 JL_0_D87E:
  CMP.w #-$7FF5,D0
   BEQ.w JL_0_D80E
  CMP.w #-$7FF4,D0
   BEQ.w JL_0_D804
  CMP.w #-$7FF8,D0
   BNE.w JL_0_D89A

 JL_0_D896:
BRA.w JL_0_D9E8

 JUMP_interr3
JMP interr3

 JL_0_D89A:
  CMP.w #-$7FF7,D0
   BNE.w JL_0_D8C8
   TST.b fpu
   BEQ 'nof
   MOVEA.l currentfunction,A0
   CMP.l #0,a0
   BEQ 'nof
   CMP.b #5,$5(a0)
    BNE 'nof
   MOVE.l #$f23c5000,d1
   BSR writelong
   MOVE.w #0,d1
   BSR writeword

 'nof
  MOVE.w #$7000,D1                                         ;end function moveq #0,d0
   BSR.w writeword
  MOVEA.l currentfunction,A0
  CMP.l #0,a0
  BEQ JL_0_D896
  MOVE.l destpointer,d1
  SUB.l $e(a0),d1
  MOVE.l d1,isfunc+1(a0)
  CMPI.b #$7,$5(A0)
   BNE.w JL_0_D896
  MOVE.w putstlen,D1
   BSR.w writeword
BRA.w JL_0_D896

 JUMP_interr
JMP interr

JL_0_D8C8:
 CMP.w #-$7FD0,D0
   BNE.w JL_0_D966
  MOVE.w proceduremode,D1
   BNE.w JUMP_interr3
  TST.b debugmode
   BEQ.w JL_0_D90A
  MOVEQ.l #$03,D1
   JSR writetrap
  MOVE.w dontwrite,D1
   BNE.w JL_0_D90A
  MOVEA.l intcleanat,A0
  MOVE.l destpointer,(A0)
  MOVE.w #$C30C,D1
   BSR.w Atokejsr

 JL_0_D90A:
  MOVE.w intstring,D1
   BEQ.w JUMP_interr
   BPL.w JL_0_D934
  MOVE.w intlevel,D1
  ORI.w #$7200,D1
   BSR.w writeword
  MOVE.w #$C103,D1
   BSR.w Atokejsr
  CLR.w intlevel

 JL_0_D934:
 CLR.w intstring
  MOVE.l intfin,D1
   BSR.w writelong
  MOVE.l #$70004E75,D1
   BSR.w writelong
  MOVE.w dontwrite,D1
   BNE.w JL_0_D962
  MOVEA.l intjmpat,A0
  MOVE.l destpointer(PC),(A0)

 JL_0_D962:
JMP get1bytemain


JL_0_D966:
  CMP.w #-$7FF2,D0
   BEQ.w doendsel
  CMP.w #-$7F4C,D0
   BNE.w JL_0_D97C
JMP doendseterr


JL_0_D97C:
JMP syntaxerr


JL_0_D980:
  TST.w dirmode
  BNE.w JUMP_baddirerr
  MOVE.w #$C800,D1
  JSR Atokejsr                                            ;end
  CMP.l #"noa7",-4(a5)
  BNE 'l10
  TST.w dontwrite
  BNE 'l10
  MOVE.l destpointer,d1
  SUBQ.l #4,d1
  MOVE.l a0,-(a7)
  MOVE.l d1,a0
  MOVE.l (a0),a0
  MOVE.l #$60000002,(a0)+
  MOVE.w #$588f,(a0)
  MOVE.l (a7)+,a0

 'l10
RTS


.do_Stop:
  TST.w dirmode                                            ;stop
  BNE.w JUMP_baddirerr
  MOVE.w d0,d1
  BEQ 'l10
  CMP.b #$3a,d0
  BEQ 'l10
  JSR get1bytemain

 'l10
  TST.b debugmode
  BEQ.w newstop
  MOVE.w #$D501,D1
BRA.w Atokejsr

 newstop
  CNIF #stopignore
    RTS
  CEND
  MOVE.w d1,d0
  BEQ 'l10
  CMP.b #$3a,d0
  BEQ 'l10
  SUB.b #$30,d0
  MOVE.w #$4e40,d1
BRA 'l11

 'l10
  MOVE.w #$4e4a,d1
BRA writeword

 'l11
  ADD.b d0,d1
BRA writeword


.do_Cont:
JMP badconterr

JL_0_D9B4:
  MOVE.w #$4E71,D1
BRA.w writeword

AJL_0_D9BC:
  MOVEA.l firstfor,A2
  CLR.l firstfor
  MOVEA.l _execbase,A6

 JL_0_D9CC:
  CMPA.w #$0,A2
  BEQ.w JL_0_D9E6
  MOVEA.l A2,A1
  MOVEA.l (A1),A2
  MOVEQ.l #$00,D0
  MOVE.l mempool2,a0
  MOVE.b $10(A1),D0
  JSR _FreePooled(A6)                                      ;freememfor_error
BRA.w JL_0_D9CC

 JL_0_D9E6:
RTS


 JUMP_badpenderr
JMP badpenderr

JL_0_D9E8:                                                 ;End Statement
    ;
    ;first, fill in any FUNCTION RETURN type shit.....
    ;
  MOVE.w proceduremode,D1
   BEQ.w JUMP_badpenderr
  ;
  MOVE.w dontwrite,D1
   BNE.w JL_0_DA1A
  MOVEA.l firstpend,A2

 JL_0_DA02:
  CMPA.w #$0,A2
   BEQ.w JL_0_DA1A
  MOVEA.l $4(A2),A0
  MOVE.l destpointer,(A0)
  MOVEA.l (A2),A2
BRA.w JL_0_DA02

 JL_0_DA1A:
  TST.b debugmode
   BEQ.b JL_0_DA2A
  MOVEQ.l #$05,D1
  JSR writetrap

 JL_0_DA2A:
  MOVEA.l firstlocal,A2                                    ;firstlocal
  JSR calcstatic2b                                           ;calcstatic
  MOVEA.l currentfunction,A0
  MOVE.l destpointer,d1
  SUB.l $e(a0),d1
  MOVE.l d1,isfunc+1(a0)                                   ;store function size
  MOVE.w D4,$8(A0)                                         ;set if memalloc need
  MOVE.l D3,locdatast
  MOVEA.l tempvm,A1
 CLR.b infunctioncode
  MOVE.l firstiffstore,d1
  CMP.l firstiff,d1
  BNE JUMP_noenderr
  TST.w $C(A1)                                             ;dim
   BPL.w JL_0_DA64
 BSET #$7,$8(A0)
  MOVE.w #$C005,D1
   BSR.w tokejsr2                                          ;writefreememstatement
BRA.w JL_0_DA6C

 JUMP_noenderr
JMP noenderr

 JL_0_DA64:
  MOVE.w memlibstat,$C(A1)

 JL_0_DA6C:
  MOVEA.l currentfunction,A0
  MOVE.l $E(A0),-(A7)
  MOVE.w locvaroff,$6(A0)
  BCLR #$1,$7(A0)
  BCLR #$0,$7(A0)
  CMPI.b #$7,$5(A0)
   BNE.w JL_0_DA9E
  MOVE.w getstlen,D1
   BSR.w writeword

 JL_0_DA9E:
  TST.w $6(A0)
   BEQ.w JL_0_DAB8
  MOVE.w #$FC7B,D1
   JSR uselib
  MOVE.w unlinka4,D1
   BSR.w writeword

 JL_0_DAB8:
  MOVEA.l currentfunction,A0
  MOVEQ.l #$00,D1
  MOVE.b $4(A0),D1
  LSR.w #4,D1
   BEQ.w JL_0_DB24
  CNIF #more6string
     LSL.w #1,d1
  CEND
  CMP.w #$1,D1
   BNE.w JL_0_DAE0
  MOVE.w fix1,D1
   BSR.w writeword
BRA.w JL_0_DB24

 JL_0_DAE0:
  LSL.w #2,D1
  MOVE.w D1,-(A7)
  MOVE.w D1,moverts+2
  MOVE.l moverts,D1
   BSR.w writelong
  MOVE.w (A7)+,D1
  CMP.w #$8,D1
   BHI.w JL_0_DB14
  ANDI.w #$7,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w fixq,D1
   BSR.w writeword
BRA.w JL_0_DB24


 JL_0_DB14:
   MOVE.w D1,fixstack+2
  MOVE.l fixstack,D1
   BSR.w writelong

 JL_0_DB24:
   BSR.w JL_0_D2CA
   BSR.w JL_0_D4F8
  MOVEA.l (A7)+,A0
  MOVE.w dontwrite,D1
   BNE.w JL_0_DB3E
  MOVE.l destpointer,-(A0)

 JL_0_DB3E:
  CLR.w proceduremode
  CLR.l currentfunction
  CLR.w procnum
   BSR.w JL_0_DB5C
   JSR freepends
JMP get1bytemain

 JL_0_DB5C:
  MOVEQ.l #$0C,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
   ;jsr AJL_0_4B6C
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  MOVEA.l D0,A0
  MOVE.l alllocals,(A0)
  MOVE.l A0,alllocals
  MOVE.l firstlocal,D0
  CLR.l firstlocal
  MOVE.l D0,$4(A0)
  MOVE.l firstglob,D1
  CLR.l firstglob
  MOVE.l D1,$8(A0)
  TST.b debugmode
   BEQ.b JL_0_DBB0
  TST.w dontwrite
   BNE.b JL_0_DBB0
  MOVEA.l proclocals(PC),A0
  MOVE.l D0,(A0)+
  MOVE.l D1,(A0)

 JL_0_DBB0:
RTS

 JUMP_baddirerr
JMP baddirerr


.do_next:
  TST.w dirmode
   BNE.w JUMP_baddirerr
  MOVE.l firstfor,D1
   BEQ.w JUMP_noforerr
  JSR reget
   BEQ.w JL_0_DC18

 JL_0_DBCE:
  BSR.w getparameter
  MOVEA.l firstfor(PC),A2
  MOVEQ.l #$00,D1
  MOVE.b $10(A2),D1
  SUBI.w #$12,D1
  CMP.w D1,D2
   BNE.w JUMP_noforerr
  LEA ptr_parameterstore(PC),A0
  LEA $11(A2),A1
  SUBQ.w #1,D2

 JL_0_DBF0:
    CMPM.b (A0)+,(A1)+
    BNE.w JUMP_noforerr
  DBF D2,JL_0_DBF0

   BSR.w JL_0_DC1A
   JSR reget
   BEQ.w JL_0_DC16
  CMP.w #$2C,D0
   BNE.w JUMP_syntaxerr
   JSR get1bytemain
BRA.w JL_0_DBCE

 JUMP_noforerr:
JMP noforerr

 JL_0_DC16:
RTS


fpu2dats
  MOVE.l 8(a7),a2
  Dc.l  $f2124400                                          ;fmove.s (a2),fp0
  Dc.l  $F2174422                                          ;fadd.s (a7),fp0
  Dc.l  $F2126400                                          ;fmove.s fp0,(a2)

 fpu2date                                                  ;??Looks like double label??
 JL_0_DC18:
  MOVEA.l D1,A2

 JL_0_DC1A:
  JSR popnext                                           ;error checking for next.
  MOVE.w $C(A2),D0
  LEA nextb,A0
  LEA nextbf,A1
  CMP.w #$1,D0
   BEQ.w JL_0_DC74
  LEA nextw,A0
  LEA nextwf,A1
  CMP.w #$2,D0
   BEQ.w JL_0_DC74
  LEA nextl,A0
  LEA nextlf,A1
  CMP.w #$5,D0
   BNE.w JL_0_DC74
   TST.b fpu
   BEQ 'old
   LEA fpu2dats,a0                                         ;fpu next code
   LEA fpu2date,a1
BRA JL_0_DC74

 'old
  MOVE.w #$C900,D1
   BSR.w Atokejsr
  LEA nextf,A0
  LEA nextff,A1

 JL_0_DC74:
  BSR.w pokecode
    TST.b fast                                             ;fast for next deactivate
BRA 'l1
                                                           ;??Looks like dead code??
    TST.b onestep
    BEQ 'l1
    CLR.b onestep
    SUBQ.l #4,destpointer
    MOVE.w #$5292,d1
    BSR writeword

 'l1
  MOVE.l JL_0_DCF4(PC),D1
   BSR.w writelong
  MOVEA.l firstfor,A2
  MOVE.l (A2),firstfor
  MOVEA.l $8(A2),A0
  MOVEA.l destpointer,A1
  MOVE.l A1,D1
  SUB.l A0,D1
  ADDQ.l #2,D1
  CMP.l #MinWordSgnd,D1
   BCC.w JUMP_bigforerr
  TST.w dontwrite
   BNE.w JL_0_DCB4
  MOVE.w D1,-$2(A0)

 JL_0_DCB4:
  MOVE.l A1,D1
  SUB.l $4(A2),D1
  SUBQ.l #6,D1
  CMP.l #MinWordSgnd,D1
   BCC.w JUMP_bigforerr
  TST.w dontwrite
   BNE.w JL_0_DCD6
  NEG.w D1
  MOVE.w D1,-$2(A1)

 JL_0_DCD6:
  JSR popnext3
  MOVEA.l _execbase,A6
  MOVEA.l A2,A1
  MOVEQ.l #$00,D0
  MOVE.b $10(A1),D0
  MOVE.l mempool2,a0
  JSR _FreePooled(A6)
JMP reget

 JUMP_notallowd:
JMP notallowd

 JUMP_bigforerr:
JMP bigforerr

; JUMP_baddirerr_2:                                        ;deactivead because double
;JMP baddirerr


AJL_0_DCF0:
  MOVE.w #$664F,-(A7)

 JL_0_DCF4:                                                      ;??
BRA.w JL_0_DCF4

 JUMP_error_dublicate_for:
JMP error_dublicate_for


forlineat:   Ds.l 1
fortemp:     Ds.w 1


.do_for:
    ;
    ;For var = START To FINISH [Step INCREMENT]
    ;
  CLR.l fp0addr
  TST.w dirmode
   BNE.w JUMP_baddirerr
  MOVE.l linenumat,forlineat
    ;
    ;new stuff!
    ;
  MOVE.l A5,letstart
  BSR.w getparameter
  MOVE.w D2,fortemp
  JSR findfor
   BEQ.w JUMP_error_dublicate_for
  LEA firstfor,A2
  JSR addhere2
  MOVE.l A2,-(A7)
  TST.b debugmode
   BEQ.b JL_0_DD4C
  JSR chkstak
  MOVE.l AJL_0_DCF0,D1
  JSR  writelong

 JL_0_DD4C:
  MOVE.w fortemp(PC),D2
  MOVE.b #1,formode
  BSR.w AJL_0_DEA6                                         ;for get 1. value
  CLR.b formode
  CMP.w #-$7FE8,D0
   BNE.w JUMP_syntaxerr
  MOVE.w commode,D1
   BNE.w JUMP_syntaxerr
  CMP.b #$6,D2
   BCC.w JUMP_badforerr
  BTST #$F,D2
   BNE.w JL_0_DD86
  MOVE.w leaamp,D1
  JSR pokewda5s
  MOVE.w D3,D1
  JSR  writeword

 JL_0_DD86:
  MOVE.w pushindex,D1
  JSR  writeword
  ANDI.w #$FF,D2

  MOVEA.l (A7),A1
  MOVE.w D2,$C(A1)
  MOVE.w D2,-(A7)
   BSR.w eval
   CLR.b onestep
   CMP.w #$8019,d0
   BEQ 'l1
   MOVE.b #1,onestep

 'l1
  MOVE.w (A7),D2
  MOVE.w pushd0l,D1
  CMP.w #$3,D2
   BCC.w JL_0_DDB6
  MOVE.w pushd0wd,D1

 JL_0_DDB6:
   MOVE.w D1,-(A7)
   TST.b fpu
   BEQ 'old
   CMP.b #5,d2
   BNE 'old
   MOVE.l #$f2276400,d1
   ;MOVE.l #$f2277400,d1
   JSR writelong
BRA 'weit

 'old
   JSR  writeword                                          ;fpu for end value

 'weit
  CMP.w #-$7FE7,D0
   BNE.w JL_0_DDCC
   BSR.w eval
   TST.b fpu
   BEQ JL_0_DE0C
   CMP.b #5,d2
   BNE JL_0_DE0C
   MOVE.l #$f2276400,d1                                    ;write step <> 1
   ;MOVE.l #$f2277400,d1                                    ;write step <> 1
  JSR writelong
;BRA.w JL_0_DE0C

   MOVE.w (a7)+,d1
BRA fpur

 JL_0_DDCC:
  CMP.w #$4,D2
   BCC.w JL_0_DDE0
  MOVE.w #$7001,D1
  JSR writeword
BRA.w JL_0_DE0C

 JUMP_badforerr
JMP badforerr

 JL_0_DDE0:
  BNE.w JL_0_DDFA
  MOVE.w #$7001,D1
  JSR writeword
  MOVE.w swapd0,D1
  JSR writeword
BRA.w JL_0_DE0C

 JL_0_DDFA:
  TST.b fpu
   BEQ 'old
  CMP.b #5,d2
   BNE 'old
  MOVE.l #$f23c5000,d1
  JSR writelong
  MOVE.w #$1,d1
  JSR writeword
  MOVE.l #$f2276400,d1
  JSR writelong
  MOVE.w (a7)+,d1
BRA fpur

 'old
  MOVE.w #$203C,D1                                         ;write step 1
  JSR writeword
  MOVE.l #SA_BackFill,D1                                   ;#$80000041,d1 org source  ;ffp '1'
  JSR writelong

 JL_0_DE0C:
  MOVE.w (A7)+,D1
  JSR writeword                                            ;push step on stack

 fpur
  MOVE.w (A7)+,D2
  MOVEA.l (A7),A1
  MOVE.l destpointer,$4(A1)
  LEA forcompb,A0
  LEA forcompbf,A1
  CMP.w #$1,D2
   BEQ.w JL_0_DE7E
  LEA forcompw,A0
  LEA forcompwf,A1
  CMP.w #$2,D2
   BEQ.w JL_0_DE7E
  LEA forcompl,A0
  LEA forcomplf,A1
  CMP.w #$5,D2
   BNE.w JL_0_DE7E
  TST.b fpu
   BEQ 'old
  LEA fpu_start,a0
  LEA fpu_end,a1
  JSR pokecode
BRA fpu3

 'old
  LEA forcompf,A0                                         ;
  LEA forcompff,A1
  JSR pokecode
  MOVE.w #$C900,D1
  BSR.w Atokejsr
  LEA forcompf2,A0
  LEA forcompf2f,A1

 JL_0_DE7E:
  JSR pokecode
  TST.b fast                                               ;fast for next
   BEQ 's1
  CMP.w #3,d2
   BNE 's1
  TST.b onestep
   BEQ 's1
  SUB.l #10,destpointer
  MOVE.w #$b081,d1
  JSR writeword

 's1                                                       ;??Looks like double label??
 fpu2
  MOVE.l thebgt(PC),D1
  JSR writelong

 fpu3
  MOVEA.l (A7)+,A1
  MOVE.l destpointer,$8(A1)
JMP reget

 fpu_start
  MOVEA.l 8(a7),a2
  Dc.l $f2124400                                           ;fmove.s (a2),fp0
  fmove.s 4(a7),fp1
  BTST.b #7,(a7)
  BNE 'negi
  fcmp.x fp1,fp0
BRA 'negi2

 'negi
  fcmp.x fp0,fp1

 'negi2
  Dc.l $f2920000                                           ;fbgt.w

 fpu_end                                                   ;??Looks like double label??
 thebgt:
  BGT.w thebgt

 .do_let:
  MOVE.l A5,letstart
  BSR.w getparameter

 AJL_0_DEA6:
  ;bsr.w pushstart

 .varassign
  MOVE.l destpointer,pushpc
  MOVE.l hunkoffsetbase,pushoff
  MOVE.w #$0001,regnum
  JSR JL_0_8E3C
  JSR calcvar
  TST.b formode
  BEQ 'lf1
  CMP.l #newtype_double,A2
  BEQ JUMP_notallowd
  MOVE.l a2,currtype

 'lf1
  CLR.w startoffsetmore
  CMP.w #$3d,d0
  BNE 'l1a
  BTST #15,d2
  BEQ 'l1a
  CMP.b #1,d2
  BNE 'l1a
  MOVE.w leaa0a0+2,startoffsetmore

 'l1a
  CLR.w regnum
  BSR.w JL_0_B5D2
  CLR.w commode
  CLR.w stackcorrect
  CLR.w pcodd
  MOVE.w startoffsetmore,d1
  BTST #0,d1
  BEQ 'l2a
  MOVE.w #1,pcodd

 'l2a
  CMP.w #$3D,D0                                            ;=
  BEQ.w JL_0_DEE0

 'l1
  MOVE.b (a5)+,d1
  BEQ 'l10
  CMP.b #":",d1
  BEQ 'l10
  CMP.b #";",d1
  BEQ 'l10
  CMP.b #"0",d1
  BLT 'l11
  CMP.b #"9",d1
  BGT 'l11
BRA.s 'l1

 'l10
  MOVE.b #1,quickadd

 'l11
  MOVEA.l letstart,A5
  SUBQ.w #1,A5

 JL_0_DEE0:
  CMP.b #$7,D2
   BNE.w JL_0_DF8A
;   TST.b infunctioncode
;   BEQ 'l10
;   MOVE.b #1,addmemcode

 'l10
  MOVEM.w D2-D3,-(A7)
  MOVE.l lastoffset_org,-(A7)
  MOVE.w varmode,-(A7)
  ; JSR setsvars
   MOVE.l #forthstack,forthsp
   MOVE.l #precstack,precsp
   CLR.w regnum
   CLR.w nonew
   CLR.w sbasegot
   MOVE.w varcodelen,oldvcodelen
   CLR.w varcodelen
   MOVE.w #$FFFF,lasta6

 ;end 457a
  MOVEQ.l #$07,D2
   BSR.w eval
  MOVE.w (A7)+,varmode
  MOVE.l (A7)+,lastoffset_org
  MOVE.w moved0a3,D1
   JSR writeword
  MOVE.w commode,D1
   BEQ.w JL_0_DF38
  LEA pulla2st,A0
  LEA pulla2stf,A1
   JSR pokecode
BRA.w JL_0_DF3C

 JL_0_DF38:
  BSR.w JL_0_B63C

 JL_0_DF3C:
  MOVEM.w (A7)+,D2-D3
  BTST #$F,D2
  BNE.w JL_0_DF58
    MOVE.w D3,leaa5d3a2+2
    MOVE.l leaa5d3a2,D1
    JSR pokela5s

 JL_0_DF58:
  MOVE.w #$FE6F,D1
  JSR uselib
  MOVE.l #$C700,D1
  MOVE.l d1,lastinstruction
  MOVE.w varmode,D2
  BNE.w JL_0_DF70
    ADDQ.w #1,D1

 JL_0_DF70:
  BSR.w Atokejsr
  CMP.w #$2C,D0
  BNE.w JL_0_E0C6

  MOVE.w addq4a2,D1
  JSR writeword
BRA.w JL_0_E018

 JUMP_error4char:
JMP error4char

 JUMP_error_convert_types:
JMP error_convert_types


JL_0_DF8A:
   BTST #$E,D2
   BNE.w JL_0_DF9C
  TST.b D2
   BEQ.w JUMP_noleterr
   TST.b newsyntax
   BEQ JL_0_DFA0

 .atmode
   CMP.w #$4022,(a5)
   BNE JL_0_DFA0
   CMP.l #3,d2
   BNE  JUMP_error_convert_types
   ADDQ #2,a5
   MOVEQ #0,d0
   MOVE.b (a5)+,d0
   BEQ JL_0_DFA0
   CMP.b #$22,d0
   BNE 'l1
   MOVE.b #0,d0
BRA 'do

 'l1
  ASL.l #8,d0
   MOVE.b (a5)+,d0
   BEQ JL_0_DFA0
   CMP.b #$22,d0
   BNE 'l2
   MOVE.b #0,d0
   ASR.l #8,d0
BRA 'do

 'l2
  ASL.l #8,d0
    MOVE.b (a5)+,d0
   BEQ JL_0_DFA0
   CMP.b #$22,d0
   BNE 'l3
   MOVE.b #0,d0
   ASR.l #8,d0
BRA 'do

 'l3
  ASL.l #8,d0
    MOVE.b (a5)+,d0
   BEQ JL_0_DFA0
   CMP.b #$22,d0
   BNE 'l4
   MOVE.b #0,d0
   ASR.l #8,d0
BRA 'do

 'l4
   CMP.b #$22,(a5)+
   BNE JUMP_error4char

 'do
  MOVE.w #$2b7c,d1
   TST.w varmode
   BEQ 'g3
   BCLR #9,d1

 'g3
    JSR writeword
    MOVE.l d0,d1
    JSR writelong
    MOVE.w d3,d1
    JSR writeword
    JSR get1bytemain
RTS

;BRA.w JL_0_DFA0                                            ;??Looks like dead code??


 JUMP_noleterr
JMP noleterr


JL_0_DF9C:
  MOVE.w d2,vartype
  MOVE.b #$3,D2

 JL_0_DFA0:
  CMP.b #5,d2
  BNE 'l1
  MOVE.l a2,currtype

 'l1
  ;MOVE.l currtype,-(a7)
  MOVEM.w D2-D3,-(A7)
  MOVE.w varmode,-(A7)
  ANDI.w #$FF,D2
  MOVE.l lastoffset_org,-(A7)
  MOVE.l a2,leftsidetype
  BSR.w eval                                ; calc right side of var assign
  TST.b typecheck
  BEQ 'notypecheck
  MOVEM.l a0/a1,-(a7)
  MOVE.l leftsidetype,a0
  CMP.l #$100,4(a0)
  BLE 'nocheck
  MOVE.l a2,a1
  CMP.l #$0003fffc,4(a2)
  BNE 'nocheck
  TST.l 8(a2)
  BNE 'nocheck
  MOVE.l funcstruct_returntype(a2),a1        ; a2 point to a function structure
'nofuncreturnassign  CMP.l #$100,4(a1)
  BLE 'nocheck

  CMP.l a0,a1
  BEQ 'ok
'error  JMP   error_convert_types
'ok
'nocheck
   MOVEM.l (a7)+, a0/a1
'notypecheck
  MOVE.l (A7)+,lastoffset_org
  MOVE.w commode,D1
   BNE.w JL_0_DFCC
   BSR.w JL_0_B63C

 JL_0_DFCC:
  MOVE.w (A7)+,varmode
  MOVEM.w (A7)+,D2-D3
  ;MOVE.l (a7)+,currtype
  MOVE.w #$2B40,D1
  MOVE.w varmode,D4
   BEQ.w JL_0_DFE8
  BCLR #$9,D1

 JL_0_DFE8:
  BTST #$F,D2
   BEQ.w JL_0_E090
   TST.b stackcorrect
   BNE 'st1
  MOVE.w commode,D1
   BEQ.w JL_0_E004

 'st1
  MOVE.w pulla2,D1
   JSR writeword

 JL_0_E004:
  MOVE.w #$2480,D1
   MOVEM.l a0/d0,-(a7)
   MOVEA.l lastoffset_org,A0
   MOVE.l A0,D0
   BEQ.w 'skip
   MOVEA.l D0,A0
   MOVE.l $A(A0),currtype

 'skip
  MOVEM.l (a7)+,a0/d0
  CMP.w #$2C,D0
   BNE.w JL_0_E090
    MOVE.w #$24C0,D1
   BSR.w JL_0_E090                                         ;write store

 JL_0_E018:
   MOVE.l lastoffset_org,D0
   ;BEQ.w JUMP_nocomerr

 'dim1
  MOVE.w #$FFFF,commode
  CLR.w varcodelen
  MOVE.b #1,optiarray
  MOVE.w pusha2,D1
   JSR writeword
  TST.l lastoffset_org
  BEQ dimmore
  MOVEA.l lastoffset_org,A0
  MOVE.l (A0),D0
   BEQ.w JUMP_comerr
  MOVEA.l D0,A0
  MOVE.l A0,lastoffset_org
  BTST #$1,$7(A0)
   BNE.w JUMP_nocomerr
  MOVEA.l $A(A0),A1
  MOVE.l $4(A1),D2

 dimlet
  BTST #$0,$7(A0)
   BNE.w JL_0_E078
  CMP.l #$100,D2
   BCC.l JUMP_nocomerr
BRA.w JL_0_E088

 dimmore
        CLR.b optiarray
        CMP.w #"@@",(a5)
        BEQ 'n1
BRA 'd1

 'n1
  JSR nextline
        MOVE.l a5,-(a7)

 'l2
  MOVE.b (a5)+,d0
        CMP.b #$20,d0
        BEQ 'l2
        MOVE.l (a7)+,a5
        CMP.b #";",d0
        BEQ 'n1

 'd1
        TST.w debugmode
        BEQ JL_0_DEE0
        MOVE.l a0,-(a7)
        MOVE.l pushat,a0
        CMP.l #0,a0
        BNE 'o1
BRA 'skip

 'o1
        ADD.l #1,2(a0)

 'skip
  CLR.w commode
        MOVE.b #1,stackcorrect
        MOVE.l (a7)+,a0
JMP JL_0_DEE0

 JUMP_nocomerr
JMP nocomerr

 JL_0_E078:
  CMP.l #$100,D2
   BCS.w JL_0_E084
  MOVEQ.l #$00,D2

 JL_0_E084:
  BSET #$E,D2

 JL_0_E088:
  BSET #$F,D2
BRA.w JL_0_DEE0

 farr
   MOVE.l destpointer,a4
   MOVE.l #$f22a6400,-4(a4)
   MOVE.w arrayoffset,d1
JMP writeword

 JUMP_comerr
JMP comerr

 JL_0_E090:
   TST.b fpu
   BEQ 'nofloat
   CMP.b #5,d2
   BNE 'nofloat
   CLR.w fp0var
   LEA regtable,a4
   TST.l (a4)
   BEQ 'noreg
   BTST #15,d2                                             ;regvars
   BNE 'noreg
   CMP.w 0+4(a4),d3
   BNE 'doreg1
   MOVE.l #$f2000380,d1
   MOVE.w regnum,d0
   BNE 'noopt
                                                           ;fmove.x fp0,fp7 should add

                                                           ;optimize if code before is
                                                           ;fmove.x fp7,fp1
                                                           ;fadd.x fp1,fp0
   MOVE.l destpointer,a4
   CMP.l #$f2001c80,-8(a4)
   BNE 'noopt
   CMP.l #$f2000422,-4(a4)
   BNE 'noopt
   MOVE.l #$f20003a2,d1
   SUB.l #8,destpointer

 'noopt
   ASL.w #7,d0
   OR.w d0,d1
   JSR writelong
RTS

 'doreg1
  CMP.w 8+4(a4),d3
   BNE 'doreg2
   MOVE.l #$f2000300,d1
   MOVE.w regnum,d0
   ASL.w #7,d0
   OR.w d0,d1
   JSR writelong
RTS

 'doreg2
  CMP.w 16+4(a4),d3
   BNE 'doreg3
   MOVE.l #$f2000280,d1
   MOVE.w regnum,d0
   ASL.w #7,d0
   OR.w d0,d1
   JSR  writelong
 RTS

 'doreg3
  CMP.w 24+4(a4),d3
   BNE 'doreg4
   MOVE.l #$f2000200,d1
   MOVE.w regnum,d0
   ASL.w #7,d0
   OR.w d0,d1
   JSR writelong
RTS

 'doreg4
  CMP.w 32+4(a4),d3
   BNE 'noreg
   MOVE.l #$f2000180,d1
   MOVE.w regnum,d0
   ASL.w #7,d0
   OR.w d0,d1
   JSR writelong
RTS

 'noreg
   TST.w regnum
   BNE 'nofp0
   MOVE.l destpointer ,a4
   CMP.l #$f2304400,-6(a4)
   BNE 'do
   CMP.w #$1990,-2(a4)
   BNE 'do
   BTST #15,d2                                             ;types ?
   BNE 'do
  MOVE.l #$2b701990,d1                                     ;var
  TST.w varmode
  BEQ 'glob1
  BCLR #25,d1

 'glob1
  MOVE.l d1,-6(a4)
  MOVE.w d3,-2(a4)
  CLR.w fp0var
  MOVE.w #$ffff,fp0mode
RTS

 'do:
   CMP.l #$f22d4400,-6(a4)                                 ;fmove.s (a5),fp0
   BNE 'do3
   CMP.l #newtype_double,currtype
   BEQ 'do4

 'nd1
  MOVE.w #$2b6d,d1
   TST.w varmode
   BEQ 'g2
    BCLR #9,d1

 'g2
    CMP.w #$2b6d,d1
    BNE 'd1
    CMP.w -2(a4),d3
    BNE 'd1
    SUBQ.l #6,destpointer
BRA 'd12

 'd1
    MOVE.w d1,-6(a4)                                       ;fmove.s to move.l mem,mem
    MOVE.w -2(a4),-4(a4)
    MOVE.w d3,-2(a4)

 'd12
  CLR.w fp0var
    MOVE.w #$ffff,fp0mode
RTS

 'do3
  CMP.l #$f22c4400,-6(a4)                                  ;fmove.s (a4)
   BNE 'do4
   MOVE.w #$2b6c,d1
      TST.w varmode
   BEQ 'g3
   BCLR #9,d1

 'g3
  MOVE.w d1,-6(a4)
    MOVE.w -2(a4),-4(a4)
    MOVE.w d3,-2(a4)
    CLR.w fp0var
    MOVE.w #$ffff,fp0mode
RTS

 'do4
  MOVE.w d3,fp0var
   MOVE.w varmode,fp0mode
   ADDQ.l #6,a4
   MOVE.l a4,fp0addr
   MOVE.l firstiff,fp0iff

 'nofp0
  MOVEM.l d0/d4,-(a7)
   MOVEQ #0,d0
    MOVE.w regnum,d0
   ASL.w #7,d0                                             ;fpu store var
  BTST #15,d2
   BEQ 'var
   MOVE.w d1,d4
   CMP.w #$24c0,d4
   BNE 'nopl
   MOVE.l #$f21a6400,d1
   MOVEQ #0,d3
BRA 'glob

 'nopl
  ;MOVE.l #$f22a6400,d1                                    ;for newtype
  MOVE.l #$f2126400,d1
   TST.w d3                                                ;offset =0
   BNE 'offset
   MOVE.l #$f2126400,d1
;   CMP.w #$24c0,d4
;   BNE 'glob
;   MOVE.l #$f21a6400,d1                                    ;fmove.s fp0,(a2)+
;BRA 'glob

'offset
 ;SUBQ.l #4,destpointer
   MOVEQ #0,d3
BRA 'glob

 'var
  MOVE.l #$f22d6400,d1                                     ;var
  TST.w varmode
  BEQ 'glob
  BCLR #16,d1
 'glob OR.l d0,d1

 'weit
  CMP.l #newtype_double,currtype
  BNE 'dbl1
  OR.l #$00001000,d1

 'dbl1
  JSR writelong
  CLR.l currtype
  MOVEM.l (a7)+,d0/d4
  MOVE.l d3,d1
  BEQ 'nooffs
JMP writeword

 'nooffs
RTS

;  CMP.l #$f2126400,-4(a4)
;  BEQ 'exit
;  CMP.l #$f21a6400,-4(a4)
;  BEQ 'exit
;BRA writeword

; 'exit
;RTS

;JMP writeword                                              ;??looks like dead code?

 'nofloat
    TST.b fast                                             ;write lea->xx(a2)
   BEQ 'la10
   CNIF #optibreak
     ILLEGAL
   CEND
   TST.b quickadd
   ;BNE 'lq1                                               ;to avoid bug
     CLR.b quickadd
   CMP.w #$2480,d1
   BNE 'la10
   TST.b optiarray
   BNE 'la10
   MOVE.l destpointer,a4
   CMP.w #$45ea,-4(a4)
   BNE 'la10
   CMP.w #8,pushclen
   BEQ 'la100
   CMP.w #6,pushclen
   BNE 'la10
   CMP.b #3,d2
   BCS 'la110
                                                           ;store value
   MOVE.w #$2540,-2(a4)
   MOVE.w arrayoffset,d1
JMP writeword

 'lq1
   CLR.b quickadd
RTS

 'la110
   CMP.b #2,d2
   BNE 'la120
    MOVE.w #$3540,-2(a4)
   MOVE.w arrayoffset,d1
JMP writeword

 'la120
  CMP.b #1,d2
   BNE.s 'la10
    MOVE.w #$1540,-2(a4)
   MOVE.w arrayoffset,d1
JMP writeword

 'la100
   CMP.b #3,d2
   BCS 'la11
   MOVE.w #$2540,-4(a4)
RTS

 'la11
   CMP.b #2,d2
   BNE 'la12
    MOVE.w #$3540,-4(a4)
RTS

 'la12 CMP.b #1,d2
   BNE.s 'la10
    MOVE.w #$1540,-4(a4)
RTS

 'la10
  CLR.b optiarray
   CMP.b #$1,D2
   BEQ.w JL_0_E0AC
   BSR.w varalign
   CMP.b #$3,D2
   BCC.w writevarlong
   TST.b fast                                              ;optiimmi
   BEQ 'l10b
   CNIF #optibreak
     ILLEGAL
   CEND

   MOVE.l destpointer,a0
   SUB.l imm_addr,a0
   CMP.l #4,a0
   BNE 'l10
   CLR.l imm_addr
   MOVE.l destpointer,a4
   OR.w #$107c,d1
   MOVE.w d1,-4(a4)
    MOVE.w D3,D1
JMP writeword

 'l10
  MOVE.l destpointer,a0
  SUB.l load_var_addr,a0
  CMP.l #4,a0
  BNE 'l10b
  CMP.w #$302d,-4(a4)                                      ;check 68k opcode
  BNE 'l10b

  CLR.l load_var_addr
  MOVE.l destpointer,a4
  OR.w #$102d,d1
  MOVE.w d1,-4(a4)
  MOVE.w d3,d1
JMP writeword

 'l10b
  ORI.w #$1000,D1                                          ;word
BRA.w writestorevar


JL_0_E0AC:
   TST.b fast                                              ;optiimmi
   BEQ 'l10b
   CNIF #optibreak
     ILLEGAL
   CEND

   MOVE.l destpointer,a0
   SUB.l imm_addr,a0
   CMP.l #4,a0
   BNE 'l10
   CLR.l imm_addr
   MOVE.l destpointer,a4
   OR.w #$7c,d1
   EORI #$3000,d1
   MOVE.w d1,-4(a4)
      MOVE.w D3,D1
JMP writeword

 'l10
  MOVE.l destpointer,a0
  SUB.l load_var_addr,a0
  CMP.l #4,a0
  BNE 'l10b
  CLR.l load_var_addr
  MOVE.l destpointer,a4
   CMP.w #$1b6d,-4(a4)
   BNE 'l10b
   OR.w #$2d,d1
   EORI #$3000,d1
   MOVE.w d1,-4(a4)
  MOVE.w d3,d1
JMP writeword

 'l10b
  ADDQ.w #1,pcodd                                          ;byte
  EORI.w #$3000,D1

 writestorevar:
  JSR writeword
  BTST #$7,D1
   BNE JL_0_E0C6
  MOVE.w D3,D1
JMP writeword

 .writevarlong:
   TST.b fast                                              ;optiimmi
   BEQ 'l10b
   CNIF #optibreak
     ILLEGAL
   CEND
   MOVE.l destpointer,a0
   SUB.l imm_addr,a0
   CMP.l #6,a0
   BNE 'l10
   CLR.l imm_addr
   MOVE.l destpointer,a4
   OR.w #$7c,d1
   MOVE.w d1,-6(a4)
    MOVE.w D3,D1
JMP writeword

 'l10
  MOVE.l destpointer,a0
  SUB.l load_var_addr,a0
  CMP.l #4,a0
  BNE 'l10b
  CLR.l load_var_addr
  MOVE.l destpointer,a4
  CMP.w #$245f,-2(a4)
  BEQ 'l10b
  OR.w #$28,d1
  OR.w d1,-4(a4)
  CMP.w #$2b6d,-4(a4)
  BNE 'd1
  CMP.w -2(a4),d3
  BNE 'd1
  SUBQ.l #4,destpointer
RTS

 'd1
  MOVE.w d3,d1
JMP writeword

 'l10b
  JSR writeword
  BTST #$7,D1
   BNE.b JL_0_E0C6
  MOVE.w D3,D1
JMP writeword

 JL_0_E0C6:
RTS


varalign:
  MOVE.w D1,-(A7)
  MOVE.w pcodd(PC),D1
  LSR.w #1,D1
   BCC.b JL_0_E0E2
  CLR.w pcodd
  MOVE.w add1a2,D1
   JSR writeword

 JL_0_E0E2:
  MOVE.w (A7)+,D1
RTS


;------                                                  ;disassembled code begin
add1a2:     Dc.b $52,$4A                                   ;ADDQ.W  #1,A2
;------                                                  ;disassembled code end

pcodd:     Ds.w 1                                          ;add 1 to this for bytes
listadd:   Ds.w 1                                          ;set to 8 if it's a list
listsize:  Ds.w 1


.do_dim:
  ADDQ.w #1,regnum
  MOVE.b #1,nowdeclare
  CLR.b dimkeep
   CMP.l #"KEEP",-1(a5)
  BNE 'nokeep
  CMP.b #" ",3(a5)
  BNE 'nokeep
  ADDQ.l #3,a5

 '2
    CMP.b #" ",(a5)
    BNE '1
   ADDQ #1,a5
BRA '2

 '1
  MOVE.l a5,lastsourcepos
  MOVE.b #1,dimkeep

 'nokeep
;  TST.b infunctioncode
;  BEQ 'l10
;  MOVE.b #1,addmemcode

;'l10
  MOVE.w #$FF9A,D1
  JSR uselib

 JL_0_E0FC:
  CLR.w listadd
  CMP.w #-$7F4D,D0
   BNE.w JL_0_E11E
  MOVE.w #$0008,listadd
  MOVE.w #$FFFA,D1
   JSR uselib
   JSR get1bytemain

 JL_0_E11E:
  CLR.w nonew
   JSR getparameter
  BTST #$1,flagmask+1
   BEQ.w JUMP_syntaxerr
   JSR JL_0_8E3C
  MOVE.w notshared,D1
   BNE.w JL_0_E198
  MOVE.w $8(A3),temp1
  MOVE.w proceduremode,D2
   BNE.w JL_0_E176
  MOVE.w globalvarpointer,-(A7)
  MOVE.w $4(A3),globalvarpointer
  ADDQ.w #4,globalvarpointer
   BSR.w write_dim_code
  MOVE.w (A7)+,globalvarpointer
BRA.w JL_0_E1BA

; JL_0_E176:                                                ;??
;  MOVE.w globalvarpointer,-(A7)
;  MOVE.w $4(A3),locvaroff
;  subq.w #4,locvaroff
;   BSR.w write_dim_code
;  MOVE.w (A7)+,locvaroff
;BRA.w JL_0_E1BA

 JL_0_E176:
  MOVE.w globalvarpointer,-(A7)
            MOVE.w proceduremode,-(a7)
            CLR.w proceduremode
  MOVE.w $4(A3),globalvarpointer
  ADDQ.w #4,globalvarpointer
   BSR.w write_dim_code
   MOVE.w (a7)+,proceduremode
  MOVE.w (A7)+,globalvarpointer
BRA.w JL_0_E1BA

 JL_0_E198:
  MOVE.w #$FFFF,temp1
  MOVE.w listadd(PC),D1
   BEQ.w JL_0_E1B6
  MOVE.w #$4000,temp1
  BSET #$0,$6(A3)

 JL_0_E1B6:
        TST.w proceduremode
       BNE 'l1
       MOVE.w locvaroff,-(a7)

 'l1
  BSR.w write_dim_code
        TST.w proceduremode
        BNE JL_0_E1BA
       MOVE.w (A7)+,locvaroff

 JL_0_E1BA:
  JSR get1bytemain
  CMP.w #$2C,D0
   BNE.w JL_0_E1CE
   JSR get1bytemain
BRA.w JL_0_E0FC

 JL_0_E1CE:
RTS

write_dim_code:                                            ;dimwit org source
  MOVE.w #$FFFF,nonew                                      ;#-1,nonew org source
  MOVE.w beginarr,D1
   JSR writeword
  MOVEQ.l #$00,D1
   JSR writeword
  MOVEQ.l #$04,D1
  BTST #$0,flagmask+1
   BNE.w write_dim_code__pointer
  MOVE.w $8(A2),D1

 write_dim_code__pointer:
  ADD.w listadd(PC),D1                                     ;size of one element.
  MOVE.w D1,listsize
   JSR writeword
  CLR.w temp2                                              ;# dim's got
  MOVE.l A3,-(A7)

 write_dim_code__loop:
  ADDQ.w #1,temp2
  MOVEQ.l #$03,D2                                          ;get word
  MOVE.w notshared,-(a7)
   JSR eval
  MOVE.w (a7)+,notshared
  TST.b debugmode
   BEQ.w write_dim_code__norerr0
  MOVE.w #$C30F,D1
   ;BSR.w Atokejsr

 write_dim_code__norerr0:
  ;MOVE.w #$C402,D1
   ;BSR.w Atokejsr
      MOVE.w #$5281,d1
      JSR writeword
      MOVE.l #$4c010800,d1                                 ;dim >65536 fix
      JSR writelong
  MOVE.w proceduremode,D2
   BEQ.w write_dim_code__global
  SUBQ.w #4,locvaroff
  MOVE.w locvaroff,putarr+2
BRA.w write_dim_code__doit

 JUMP_syntaxerr:                                           ;??deactivaed because doubled??
JMP syntaxerr

 write_dim_code__global:
  MOVE.w globalvarpointer,putarr+2
  ADDQ.w #4,globalvarpointer

 write_dim_code__doit:
  TST.b dimkeep
           BEQ write_dim_code__doit_l1
      MOVEQ #0,d1
      MOVE.w putarr+2,d1
      OR.l  #$222d0000,d1
      MOVE.w proceduremode,D2
      BEQ write_dim_code__doit_l2
      TST.w notshared
      BEQ write_dim_code__doit_l2
      SUB.l #$00010000,d1

 write_dim_code__doit_l2:
  JSR writelong

 write_dim_code__doit_l1:
  MOVE.l putarr,D1
      TST.w notshared
      BNE write_dim_code__doit_l1a
      JSR writelong
BRA write_dim_code__doit_l4

 write_dim_code__doit_l1a:
  JSR pokela5d

 write_dim_code__doit_l4:
  CMP.w #$2C,D0
   BEQ.w write_dim_code__loop
  CMP.w #$29,D0
   BNE.w JUMP_syntaxerr
  MOVEA.l (A7)+,A3
  MOVE.w temp1,D1
   BMI.w write_dim_code__nocare
    ;
    ;is it a list?
    ;
  BTST #$E,D1
   BEQ.w write_dim_code__notl
  CMPI.w #$1,temp2
   BNE.w JUMP_redimerr
BRA.w write_dim_code__nocare

 JUMP_redimerr:
JMP redimerr

 write_dim_code__notl:
  CMP.w temp2,D1
   BNE.w JUMP_redimerr                                      ;range too long

 'ok                                                        ;??looks like not used anymore??
  LEA globalvarpointer,A0
  MOVE.w proceduremode,D1
  BEQ.w write_dim_code__gskip
  LEA locvaroff,A0

 write_dim_code__gskip:
  MOVE.W  extraword,(A0)
  BRA.W   write_dim_code__care

 write_dim_code__nocare:
  MOVE.w temp2,$8(A3)                                      ;set # dim's

 write_dim_code__care:
  LEA doarr,A0
  MOVE.w $4(A3),$2(A0)
  MOVE.w putarr+2,$6(A0)
  MOVE.l (A0)+,D1
   JSR writelong
  MOVE.l (A0),D1
   JSR writelong
   TST.b dimkeep
  BNE write_dim_code__care_l3

 write_dim_code__care_l1:                                  ;??Looks like not used any more??
  MOVE.w #$C400,D1
BRA write_dim_code__care_l2

 write_dim_code__care_l3:
  MOVE.w #$C405,d1

 write_dim_code__care_l2:
  MOVE.w proceduremode,D2
   BEQ.w write_dim_code__isg
   TST.w notshared
   BEQ write_dim_code__isg
  ADDQ.w #1,D1

 write_dim_code__isg:
  MOVE.w listadd(PC),D2
   BEQ.w write_dim_code__isrg
  MOVE.w D1,-(A7)
  MOVE.w setles(PC),D1
   JSR writeword
  MOVE.w listsize(PC),D1
   JSR writeword
  MOVE.w (A7)+,D1
  ADDQ.w #3,D1

 write_dim_code__isrg:
BRA.w Atokejsr


fpupi:
  CNIF #64bitconstant
    MOVE.l #$f23c5400,d1
  CELSE
    MOVE.l #$f23c4400,d1
  CEND
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.w d0,d1
  JSR writelong
  CNIF #64bitconstant
    MOVE.l #$400921fb,d1
    JSR writelong
    MOVE.l #$54442D18,d1
  CELSE
    MOVE.l #$40490fd9,d1
  CEND
  JSR writelong
JMP get1bytemain


;------                                                  ;disassembled code begin
setles:   Dc.b $38,$3C,$00,$00                             ;MOVE.W  #$0000,D4
;------                                                  ;disassembled code end

;-----------data-----------------------;

.mydata

vbr:                Ds.l 1
cfetchmode:         Ds.w 1                               ;1=fetching a constant
                    ;intercept uselib!
constlibs           Dc.w $FDA7,$FCDF,$FD43               ;64935,64735,64835  org source

    ;below is a PC for the constant evaluation routine
    ;
constpcat:          Ds.l 1
constlibat:         Ds.l 1
constmaxpc:         Dc.l $400
   ;
stacksize:          Dc.l 32768                           ;stackfuck org source
currentlabeladdr:   Dc.l labelbase                       ;lastrescon org source
currentmacroaddr:   Dc.l macrobase                       ;lastresmac org source
lastrestype:        Dc.l newtype_string
rescnt:             Ds.w 1                               ;# resident
state_of_residents: Ds.w 1                               ;reschg org source ;flag for if res's have changed
resat:              Dc.l residents_table                 ;??looks like not used anymore??
linedone:           Ds.w 1
directbuffer:       Ds.w 11                              ;dirpcat  dc.w 0 org source
                                                         ;dira4    dc.l 0           ;Label not used in org source
                                                         ;dira5    dc.l 0           ;Label not used in org source
                                                         ;dira6    dc.l 0           ;Label not used in org source
                                                         ;dirstack dc.l 0           ;Label not used in org source

.handle_datatypes                                        
convtable:
;byte
  Dc.l 0                                        ; bytetobyte
  Dc.l convert_byte_to_word                     ; bytetoword
  Dc.l convert_byte_to_long                     ; bytetolong
  Dc.l convert_byte_to_quick                    ; bytetoquick
  Dc.l convert_byte_to_float                    ; bytetofloat
  Dc.l convert_byte_to_long                     ; bytetolong
  Dc.l error_convert_types                      ; noconerr

;word
  Dc.l convert_word_to_byte                     ; wordtobyte
  Dc.l 0                                        ; wordtoword
  Dc.l convert_word_to_long                     ; wordtolong
  Dc.l convert_word_to_quick                    ; wordtoquick
  Dc.l convert_word_to_float                    ; wordtofloat
  Dc.l convert_word_to_long                     ; wordtolong
  Dc.l error_convert_types                      ; noconerr

;long
  Dc.l convert_long_to_byte                     ; longtobyte
  Dc.l convert_long_to_word                     ; longtoword
  Dc.l 0                                        ; longtolong
  Dc.l convert_long_to_quick                    ; longtoquick
  Dc.l convert_long_to_float                    ; longtofloat
  Dc.l 0                                        ; longtolong
  Dc.l error_convert_types                      ; noconerr

;quick
  Dc.l convert_quick_to_byte                    ; quicktobyte
  Dc.l convert_quick_to_word                    ; quicktoword
  Dc.l convert_quick_to_long                    ; quicktolong
  Dc.l 0                                        ; quicktoquick
  Dc.l convert_quick_to_float                   ; quicktofloat
  Dc.l convert_quick_to_long                    ; quicktolong
  Dc.l error_convert_types                      ; noconerr

;float
  Dc.l convert_float_to_byte                    ; floattobyte
  Dc.l convert_float_to_word                    ; floattoword
  Dc.l convert_float_to_long                    ; floattolong
  Dc.l convert_float_to_quick                   ; floattoquick
  Dc.l 0                                        ; floattofloat
  Dc.l convert_float_to_long                    ; floattolong
  Dc.l error_convert_types                      ; noconerr

;address
  Dc.l convert_long_to_byte                     ; longtobyte
  Dc.l convert_long_to_word                     ; longtoword
  Dc.l 0                                        ; longtolong
  Dc.l convert_long_to_quick                    ; longtoquick
  Dc.l convert_long_to_float                    ; longtofloat
  Dc.l 0                                        ; longtolong
  Dc.l error_convert_types                      ; noconerr

;string
  Dc.l error_convert_types                      ; noconerr
  Dc.l error_convert_types                      ; noconerr
  Dc.l string_to_long                           ; stringtolong
  Dc.l error_convert_types                      ; noconerr
  Dc.l error_convert_types                      ; noconerr
  Dc.l string_to_long                           ; stringtolong
  Ds.l 1

    ;dc operator ascii
    ;dc.l   ..b,.w,.l,.q,.f,.a,.s                          ;dc.l   ..b,.w,.l,.q,.f,.s,.a org source seem wrong

operators:
  Dc.b $00,$2B                                  ;+ ; add
  Dc.l do_plus_byte                             ;doplusb
  Dc.l do_plus_word                             ;doplusw
  Dc.l do_plus_long                             ;doplusl
  Dc.l do_plus_long                             ;doplusl
  Dc.l do_plus_float                            ;doplusf
  Ds.l 1
  Dc.l add_strings                              ;addstrings
  Dc.b $0B,$B8
  ;
  Dc.b $00,$2D                                  ;- ; sub
  Dc.l do_minus_byte                            ;dominusb
  Dc.l do_minus_word                            ;dominusw
  Dc.l do_minus_long                            ;dominusl
  Dc.l do_minus_long                            ;dominusl
  Dc.l do_minus_float                           ;dominusf
  Ds.l 2
  Dc.b $0B,$B8
  ;
  Dc.b $00,$2A                                  ;* ; mul
  Dc.l do_times_byte                            ;dotimesb
  Dc.l do_times_word                            ;dotimesw
  Dc.l do_times_long                            ;dotimesl
  Dc.l do_times_quick                           ;dotimesq
  Dc.l do_times_float                           ;dotimesf
  Ds.l 2
  Dc.b $0F,$A0
  ;
  Dc.b $00,$2F                                  ;/ ; div
  Dc.l do_Div_byte                              ;dodivb
  Dc.l do_Div_word                              ;dodivb
  Dc.l do_Div_long                              ;dodivl
  Dc.l do_Div_quick                             ;dodivq
  Dc.l do_Div_float                             ;dodivf
  Ds.l 2
  Dc.b $0F,$A0
  ;
  Dc.b $00,$26                                  ;& ; & int
  Dc.l do_AND_byte                              ;doandb
  Dc.l do_AND_word                              ;doandw
  Dc.l do_AND_long                              ;doandl
  Dc.l do_AND_long                              ;doandl
  Ds.l 3
  Dc.b $13,$88
  ;
  Dc.b $00,$7C                                  ;| ;or int ;
  Dc.l do_OR_byte                               ;doorb
  Dc.l do_OR_word                               ;doorw
  Dc.l do_OR_long                               ;doorl
  Dc.l do_OR_long                               ;doorl
  Ds.l 3
  Dc.b $13,$88
  ;
  Dc.b $80,$42                                  ; AND int  ;(opand-opabcd)/$1c+$8000+fnum
  Dc.l do_AND_byte                              ;doandb
  Dc.l do_AND_word                              ;doandw
  Dc.l do_AND_long                              ;doandl
  Dc.l do_AND_long                              ;doandl
  Ds.l 3
  Dc.b $03,$E8
  ;
  Dc.b $80,$8A                                  ; OR int   ;(opor-opabcd)/$1c+$8000+fnum
  Dc.l do_OR_byte                               ;doorb
  Dc.l do_OR_word                               ;doorw
  Dc.l do_OR_long                               ;doorl
  Dc.l do_OR_long                               ;doorl
  Ds.l 3
  Dc.b $03,$E8
  ;
  Dc.b $80,$73                                  ; EOR int  ;(opeor-opabcd)/$1c+$8000+fnum
  Dc.l do_EOR_byte                              ;doeorb
  Dc.l do_EOR_word                              ;doeorw
  Dc.l do_EOR_long                              ;doeorl
  Dc.l do_EOR_long                              ;doeorl
  Ds.l 3
  Dc.b $03,$E8
  ;
  Dc.b $80,$7C                                  ; LSL int  ;(oplsl-opabcd)/$1c+$8000+fnum
  Dc.l do_LSL                                   ;dolslb
  Dc.l do_LSL                                   ;dolslw
  Dc.l do_LSL                                   ;dolsll
  Dc.l do_LSL                                   ;dolsll
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$44                                  ; ASL int  ;(opasl-opabcd)/$1c+$8000+fnum
  Dc.l do_LSL                                   ;dolslb
  Dc.l do_LSL                                   ;dolslw
  Dc.l do_LSL                                   ;dolsll
  Dc.l do_LSL                                   ;dolsll
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$7D                                  ; LSR int  ;(oplsr-opabcd)/$1c+$8000+fnum
  Dc.l do_LSR                                   ;dolsrb
  Dc.l do_LSR                                   ;dolsrw
  Dc.l do_LSR                                   ;dolsrl
  Dc.l do_LSR                                   ;dolsrl
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$45                                  ; ASR int  ;(opasr-opabcd)/$1c+$8000+fnum
  Dc.l do_ASR                                   ;doasrb
  Dc.l do_ASR                                   ;doasrw
  Dc.l do_ASR                                   ;doasrl
  Dc.l do_ASR                                   ;doasrl
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$B9                                  ;mod       ;$8006+tnum
  Dc.l do_mod_byte                              ;domodb
  Dc.l do_mod_word                              ;domodw
  Dc.l do_mod_long                              ;domodl
  Dc.l do_mod_quick                             ;domodq
  Dc.l do_mod_float                             ;domodf
  Ds.l 2
  Dc.b $13,$88
  ;
oppow:
  Dc.b $00,$5E                                  ;^
  Dc.l do_pow                                   ;dopow
  Dc.l do_pow                                   ;dopow
  Dc.l do_pow                                   ;dopow
  Dc.l do_pow                                   ;dopow
  Dc.l do_pow                                   ;dopow
  Ds.l 2
  Dc.b $1B,$58                                  ;7000
  ;
opeq:
  Dc.b $00,$3D                                  ;=
  Dc.l do_equal_byte                            ;doeqb
  Dc.l do_equal_word                            ;doeqw
  Dc.l do_equal_long                            ;doeql
  Dc.l do_equal_long                            ;doeql
  Dc.l do_equal_float                           ;doeqf
  Dc.l do_equal_long                            ;doeql
  Dc.l do_equal_string                          ;doeqs
  Dc.b $07,$D0                                  ;2000
  ;
opne:
  Dc.b $3C,$3E                                  ;<>
  Dc.l do_not_equal_byte                        ;doneb
  Dc.l do_not_equal_word                        ;donew
  Dc.l do_not_equal_long                        ;donel
  Dc.l do_not_equal_long                        ;donel
  Dc.l do_not_equal_float                       ;donef
  Dc.l do_not_equal_long                        ;donel
  Dc.l do_not_equal_string                      ;dones
  Dc.b $07,$D0                                  ;2000
  ;
oplt:
  Dc.b $00,$3C                                  ;<
  Dc.l do_littler_byte                          ;doltb
  Dc.l do_littler_word                          ;doltw
  Dc.l do_littler_long                          ;doltl
  Dc.l do_littler_long                          ;doltl
  Dc.l do_littler_float                         ;doltf
  Dc.l do_littler_long                          ;doltl
  Dc.l do_littler_string                        ;dolts
  Dc.b $07,$D0                                  ;2000
  ;
ople:
  Dc.b $3C,$3D                                  ;<=
  Dc.l do_littler_equal_byte                    ;doleb
  Dc.l do_littler_equal_word                    ;doleb
  Dc.l do_littler_equal_long                    ;dolel
  Dc.l do_littler_equal_long                    ;dolel
  Dc.l do_littler_equal_float                   ;dolef
  Dc.l do_littler_equal_long                    ;dolel
  Dc.l do_littler_equal_string                  ;doles
  Dc.b $07,$D0                                  ;2000
  ;
opgt:
  Dc.b $00,$3E                                  ;>
  Dc.l do_greater_byte                          ;dogtb
  Dc.l do_greater_word                          ;dogtw
  Dc.l do_greater_long                          ;dogtl
  Dc.l do_greater_long                          ;dogtl
  Dc.l do_greater_float                         ;dogtf
  Dc.l do_greater_long                          ;dogtl
  Dc.l do_greater_string                        ;dogts
  Dc.b $07,$D0                                  ;2000
  ;
opge:
  Dc.b $3E,$3D                                  ;>=
  Dc.l do_greater_equal_byte                    ;dogeb
  Dc.l do_greater_equal_word                    ;dogew
  Dc.l do_greater_equal_long                    ;dogel
  Dc.l do_greater_equal_long                    ;dogel
  Dc.l do_greater_equal_float                   ;dogef
  Dc.l do_greater_equal_long                    ;dogel
  Dc.l do_greater_equal_string                  ;doges
  Dc.b $07,$D0                                  ;2000
  ;
  Dc.b $80,$CD                                  ;$8000+26+tnum
  Dc.l _BitTst
  Dc.l _BitTst
  Dc.l _BitTst
  Dc.l _BitTst
  Ds.l 3
  Dc.b $1F,$40                                  ;8000
  ;
  Dc.b $80,$CE                                  ;$8000+27+tnum
  Dc.l _BitSet
  Dc.l _BitSet
  Dc.l _BitSet
  Dc.l _BitSet
  Ds.l 3
  Dc.b $1F,$40                                  ;8000
  ;
  Dc.b $80,$CF                                  ;$8000+28+tnum
  Dc.l _BitClr
  Dc.l _BitClr
  Dc.l _BitClr
  Dc.l _BitClr
  Ds.l 3
  Dc.b $1F,$40                                  ;8000
  ;
  Dc.b $80,$D0                                  ;$8000+29+tnum
  Dc.l _BitChg
  Dc.l _BitChg
  Dc.l _BitChg
  Dc.l _BitChg
  Ds.l 3
  Dc.b $1F,$40                                  ;8000
  ;
  Dc.b $00,$00




modetable:   Dc.l typemode


newtypebase: Dc.l newtype_byte

newtype_byte:                                              ;bytetype
  Dc.l newtype_word,$01                                    
  Dc.w $0001
  Dc.b 13,"b",0,0

newtype_word:                                              ;wordtype
  Dc.l newtype_long,$02
  Dc.w $0002
  Dc.b 13,"w",0,0

newtype_long:                                              ;longtype
  Dc.l newtype_quick,$03                                   
  Dc.w $0004
  Dc.b 13,"l",0,0

newtype_quick:                                             ;quicktype
  Dc.l newtype_float,$04                                   
  Dc.w $0004
  Dc.b 13,"q",0,0

newtype_float:                                             ;floattype
  ;Dc.l addresstype,$05                                     
  Dc.l newtype_double,$05                                  ;make problems on old residents
  Dc.w $0004
  Dc.b 13,"f",0,0

addresstype:                                               ;addresstype
  Dc.l newtype_double,$06
  Dc.w $0004
  Dc.b 13,"a",0,0

newtype_double:
  Dc.l newtype_string,$05                                  ;?? has to by $06 becous is number 6 not 5
  Dc.w $0008
  Dc.b 13,"d",0,0

firsttype: ;
newtype_string:
  Dc.l $0000000,$07                                        ;stringtype
  Dc.w $0004
  Dc.b 13,"s",0,0

dummytype:
  Dc.l $00,$00
  Dc.w $0000
  Dc.b $01,$00,$00,$00


incdir:               Ds.l 24                              ;dcb.b   96,0    org source
                                                           ;Even            org source


dirmode:              Ds.w 1                               ;shows if directmode is on
;_intuibase:                                               ;direct mode flag
                      Ds.l 1                               ;int org source ;intuition!
maxobject_pos:        Ds.w 1                               ;maxat org source ;max at
maxsat:               Ds.l 1                               ;data1 info pos
number_of_objects:    Ds.w 1                               ;nummaxs org source ;number of maximums
                                                           ;in libs
maxsused:             Ds.w 1                               ;maximums used in prog
    ;
    ;below are defaults to be saved with source
    ;
dark:                 Ds.w 1                               ;dark compile?
qlab:                 Ds.w 1                               ;quick lab allocate
defaulttype:          Dc.l newtype_quick                   ;dc.l quicktype org source
    ;
    ;end of defaults
    ;

anyerrs:              Dc.w -1                              ;Any Errors in compile ?
debugversion:         Ds.w 1                               ;makeexec org source ;make an executable file!
noinits:              Ds.l 1                               ;flag for if we have any init routines!
                                                           ;6.l=no!
letstart:             Ds.l 1
dontwrite:            Ds.w 1                               ;nomemleft org source
lastgloballabel:      Ds.l 32                              ;lastbiglab ds.b 128 org source
    ;
locdatast:            Ds.l 1
firstpend:            Ds.l 1
    ;
    ;one pass compiler stuff!
    ;
data2at:              Ds.l 1
data2:                Ds.l 1
data1start:           Ds.l 1                               ;data1at org source
data1:                Ds.l 1                               ;pc for initialized data!
destbufferstart:      Ds.l 1                               ;pcat org source
;destpointer:          Ds.l 1                               ;pc org source          ;ds.w 1  ;   moved to .pluginbase
                                                            ;pc+2; destpointer+2:    Ds.b 1
                                                            ;pc+3; destpointer+3:    Ds.b 1
destbufferend:        Ds.l 1                               ;libat org source
libend:               Ds.l 1                               ;lib org source
allat:                Ds.l 1                               ;highest allocmemd location for code
dummyasm:             Dc.w 0,0,0,0,0
                      Dc.l 0
                      Dc.w 0
    ;
    ;data for assembler
    ;
buff1:                Ds.l 1                               ;buffer for text get
buff2:                Ds.l 1                               ;ditto for dest
constmode:            Ds.w 1                               ;0 for norm, <>0 for assembler
asmtype:              Ds.w 1                               ;0=contains no prog reference
extraword:            Ds.w 1                               ;the extension word for assembler
extraword2:           Ds.w 1                               ;ditto
asmsize:              Ds.w 1
asmbuff:              Ds.l 1
asmlen:               Ds.w 1                               ;first (src) text len
asmlen2:              Ds.w 1                               ;second (dest)
templabel:            Ds.l 1                               ;linked list of expressions to resolve
            ;for one pass assembly.
    ;
macnum:               Ds.w 1
;nextinc0:                                                 ;??Looks like not used??
                      Dc.l 0                               ;address of next 0 in include fil
titleat:              Ds.l 1                               ;5 longs for compile streaks
progress_per_line:    Ds.w 5                               ;titleadd ds 5 org source ;5 adds for compile streaks
connest:              Ds.w 1                               ;conditional nest level
firstconst:           Ds.l 1                               ;first constant (#a)
numarg:               Ds.w 1                               ;number of macro arguements
myoline:              Ds.l 1                               ;macro done yet?
myline:               Ds.l 1                               ;pointer to some memory to create
                      ;line in.....
;mylinef:                                                  ;??looks like not used??
                      Ds.l 1
concomstack:          Ds.l 16                              ;32 deep conditional compilation
concomsp:             Dc.l concomstack                     ;stack pointer
oldqflag:             Ds.w 1
;datalib:              Dc.l 0                               ;pointer to datalib.obj (64535)  ;org source
;lastconloc:                                               ;??looks like not used??
                      Ds.l 1
;lastconop:                                                ;??looks like not used??
                      Ds.w 1
firstfor:             Ds.l 1                               ;first for
stackpar:             Ds.w 1                               ;pushflag org source ;1 par to stack 0 normal
sbgot:                Ds.w 1                               ;flag for string got 2
convsize:             Ds.w 1                               ;usertype org source
userp:                Ds.w 1

;libspos               Dc.w  0   ;pos in libs dir                      ;org source
;numlibs               Dc.w  0   ;number of libraries in libslist      ;org source

ptr_userlibs_list:    Ds.l 1                               ;libslist org source
a2offset:             Ds.w 1                               ;stackuse org source ;stack used when gathering lib parameters
numreps:              Ds.w 1                               ;number of repeats in a repeatable
                      ;parameter list.....
locloc:               Ds.l 1
locchar:              Ds.w 1
stbuff:               Ds.l 32                              ;was 8    ;six string varoffs
commode:              Ds.w 1                               ;in comma mode...
lastoffset_org:       Ds.l 1                               ;lastoffset org source ;last offset in calcvar!
linenumat:            Dc.l $FFFFFFFF                       ;linecounter ;dc -1 org source ;line being processed
compilelinecounter:   Dc.l $FFFFFFFF                       ;menuret dc -1 org source ;menu return code
;optresoff:                                                ;??looks like not used??
                      Ds.w 1                               ;opt reset offset
;varcode:                                                  ;??looks like not used??
                      Ds.l 64                              ;Ds.b vcodelen org source ;code used to generate
;varcode2:                                                 ;??looks like not used??
                      Ds.l 64                              ;Ds.b vcodelen org source ;above for let.....
varcodelen:           Ds.w 1                               ;and length
;varcodelen2:                                              ;??looks like not used??
                      Ds.w 1
oldvcodelen:          Ds.w 3                               ;old varcodelen
;stringslib1:          Dc.l 0                               ;address of stringslib1  ; org source
;procjmppc:            Dc.l 0                               ;pc of jmp of proc ;?? in org source presend  but not used??
Even4
tempvm:               Ds.l 1                               ;memlib org source ;address of memory library
memlibstat:           Ds.w 1                               ;status of memory library during
                      ;procs
;tempvmode:                                                ;??looks like not used??
                      Dc.w 0
;tempvmode2:                                               ;??looks like not used??
                      Dc.w 0

varmode:              Ds.w 1                               ;0 a5 pointer to global
                      ;else pointer to locals
currentfunction:      Ds.l 1                               ;thisproc org source
firstproc:            Ds.l 1                               ;firstproc org source ;this procedure being 'done'
proceduremode:        Ds.w 1                               ;-1=statement/ function return type ;procmode org source  ;1 if statement, 2 if function
                      ;0 if norm!
skipcode:             Ds.w 1                               ;nocompile ;comflag org source ;0 if no compile
passstack:            Ds.l 1
zero:                 Ds.l 1                               ;ZERO!
ininclude:            Ds.w 1                               ;numincs org source ;number of include files
                      ;0=main RAM code
xinclude_base:        Ds.l 1                               ;firstxinc org source ;first exclusive include.
constantbase:         Ds.l 1                               ;firstinc org source ;first include
lasta6:               Dc.w $FFFF                           ;-1 org source
instringon:           Ds.w 1                               ;quoteflag org source
ptr_macrobuffer_begin:Ds.l 1                               ;macrobuff org source ;pointer to macro collection buffer ;begin
ptr_macrobuffer_end:  Ds.l 1                               ;macrobufff org source ;end of above ;end of
macrobase:            Ds.l 1                               ;firstmacro org source ;linked list of macro's ;macrolist
endop:                Ds.l 1                               ;end of program pc - before finishups!
labelbase:            Ds.l 1                               ;firstlabel org source ;first lib struct
end_of_tokenlist:     Ds.l 1                               ;lasttoken org source
numstatic:            Ds.w 1                               ;number of static structs
staticdata:           Ds.l 1                               ;data1 val for statics
libpointer:           Ds.l 1                               ;firstlib org source ;first lib struct
sbasegot:             Ds.w 1                               ;string base got?
litdata1:             Ds.l 1
    ;
    ;Optimization stuff
    ;
objlen:               Ds.l 1
hunkoffsetcounter:    Ds.l 1                               ;numoffs org source
hunkoffsetbase:       Ds.l 1                               ;firstoff org source ;pointer to linked list
                      ;of amigados type reloc offsets
flagmask:             Ds.w 1                               ;mask for flag of variable when
                      ;searching for it!
notshared:            Ds.w 1                               ;added org source ;flag for seeing if variable was added!
nonew:                Ds.w 1                               ;1 to inhibit new variable creation
temp1:                Ds.l 1
temp2:                Ds.l 1
;    cnop    0,4 org source
ptr_parameterstore:   Ds.l 1                               ;namebuff ds.b 128 org source
fib_DirEntryType:     Ds.l 1                               ;namebuff+4 org source
fib_FileName:         Ds.l 29                              ;namebuff+8 org source
fib_Size:             Ds.l 1                               ;namebuff+124 org source

namebuff2:            Ds.b 128
                      Ds.b 8                               ;for fileinfoblock

; buffer fuer uselibs
optstuff:             Ds.b 64                              ;temp opt make buffer


Even

.menu_viewnewtypes:
;  MOVEA.l comdata,A1
;  MOVEA.l $802(A1),A1                                      ; compiler says to PED: openwindow
  !ComData_GetL{comFunc_OpenCompilerWindow,A1}
  MOVE.l #1000,D0
  JSR (A1)
RTS


.ptr_xtradata:                                             ;optspnts org source ;pointers to options involved in source dependant
    ;stuff
    ;
  Dc.b $00,$01                                             ; 1 byte schreiben ;one byte stuff...
  Dc.l xtra_versionnumber                                  ; vers org source
  Dc.l create_iconfile                                     ; create icon for executable
  Ds.l 1

  Dc.b $00,$02                                             ; 2 bytes schreiben  ;two byte stuff...
    ;
;jimi0 org source
  Dc.l set_use_debugger
  Dc.l AL_0_11010                                          ;+obsolet: debugger
  Dc.l AL_0_1103C                                          ;+obsolet: long arrays
  Dc.l AL_0_11068                                          ;+obsolet: expand macros
  Dc.l AL_0_11094                                          ;+obsolet: quoted macros
  Dc.l set_make_smallestcode
  Dc.l set_link_debuginfo
  Dc.l set_autorun
  Dc.l set_interruptcheck
  Dc.l set_assemblercheck
    ;
  Dc.l set_overflowcheck
  Dc.l default_obsolete                                    ;+obsolet: ohne inhalt
  Dc.l default_interruptcheck                              ;+obsolet: interruptcheck vorgabe
  Dc.l default_overflowcheck                               ;+obsolet: overflow vorgabe
    ;
;jimi1  ;org source
  Ds.l 1
    ;
  Dc.b $00,$04                                             ; 4 bytes schreiben..  ;four byte stuff...

;jimi2:  ;org source
bufferlist:
    ;
    ;Maximums Int String Gadgets...
    ;
  Dc.l objectbuffer
  Dc.l libsbuffer
  Dc.l systembuffer
  Dc.l databuffer
  Dc.l macrobuffer_size
  Dc.l stringbuffer

;jimi3   ;org source
  Ds.l 1
    ;
    ;Resident Buffer...
    ;
  Dc.b $02,$20                                             ;dc 68*8; 544 bytes schreiben.
  Dc.l residents_table,0
    ;
    ;Executable name!
    ;
  Dc.b $01,$80                                             ;dc 192*2; 384 bytes schreiben
  Dc.l exepath,0                                           ; exepath und exefilename jeweils 192 bytes
  Ds.w 1
;optspntsf   ;                                             ;??looks like not used??

optssave: ;ds.b ((jimi1-jimi0)/4*2)+(jimi3-jimi2)+(68*8)+(192*2)+2 org source ; 982 bytes
  Ds.l 63
  Ds.l 63
  Ds.l 63
  Ds.w 113
.ptr_endxtradata

comsettings_message:  Ds.w 1                               ;allchg org source
xtra_versionnumber:   Ds.w 1                               ;vers org source


.read_xtrafile:                                            ;load xtrafile, filehandle via PED in D7
  CLR.b exefilename
  TST.l d0
  BNE read_xtrafile__l10
RTS

 read_xtrafile__l10                                         ;??begin org source??
  JSR free_residents                                       ;jsr freeres2 org source
  LEA ptr_xtradata,A2
  MOVEQ.l #$00,D4

 read_xtrafile__loop:
    MOVE.w (A2)+,D4                                        ; anzahl bytes zum lesen
    BEQ.b read_xtrafile__done

 read_xtrafile__loop2:
    MOVE.l (A2)+,D2
  BEQ.b read_xtrafile__loop

  MOVE.l D4,D3
  MOVE.l D7,D1
  JSR _Read(A6)                                            ; d1: file, d2: buffer, d3:length
  TST.l D0
  BNE.b read_xtrafile__loop2
BRA.w read_xtrafile__done2

 read_xtrafile__done:                                                ; set defaults
  TST.b xtra_versionnumber
   BNE.b read_xtrafile__nover0
  MOVE.w #$0080,set_autorun                                ;auto run on
  MOVE.w default_interruptcheck,set_interruptcheck         ;interupt checking on
  CLR.w set_assemblercheck                                 ;assembler checking off
  MOVE.w default_overflowcheck,set_overflowcheck           ;overflow chex
BRA.b read_xtrafile__ver0

 read_xtrafile__nover0:
  MOVE.l D7,D1                                             ;load cli arg!
  MOVE.l #str_cliarguments,D2
  MOVE.l #116,D3                                           ; vorher 128 , jetzt 8 weniger fuer die Versionsdaten
  JSR _Read(A6)                                            ; d1: file, d2: buffer, d3:length
  MOVE.l #str_cliarguments,A0
  ADDA.l #115,A0
  MOVE.l #0,(a0) ; terminate it!

  MOVE.l D7,D1                                             ; I know, I know. Honitos started this horrible thing, see below...
  MOVE.l #stacksize,D2
  MOVE.l #4,D3
  JSR _Read(A6)
  CMP.l ##MIN_STACKSIZE,stacksize
  BGE 'stackok
  MOVE.l ##MIN_STACKSIZE,stacksize
  'stackok:

  MOVE.l D7,D1
  MOVE.l #versioninformation,D2
  MOVE.l #4,D3
  JSR _Read(A6)

  MOVE.l D7,D1
  MOVE.l #number_of_builds,D2
  MOVE.l #4,D3
  JSR _Read(A6)

 read_xtrafile__ver0:
    ;here, we load in current max settings. done last coz of
    ;unknown number of max's
    ;
  MOVE.l A7,errstack
  MOVE.l #read_xtrafile__done2,errcont
  MOVE.w #$FFFF,ezerr

 read_xtrafile__dloop:
    MOVE.l #temp1,D2                                   ;LOAD maxobjectsvalues
    MOVEQ.l #$04,D3
    MOVE.l D7,D1
    JSR _Read(A6)
    TST.l D0
    BEQ.b read_xtrafile__done2
    MOVE.w temp1,D1
    TST.w d1                                               ;new
    BEQ read_xtrafile__done2                                         ;new
     JSR AJL_0_6F1A
     ;BEQ.b read_xtrafile__done2
    CMP.l #0,a1
    BEQ read_xtrafile__dloop
    MOVE.l $12(A1),D0
    MOVE.w temp1+2,-$4(A1,D0.L)
BRA.b read_xtrafile__dloop

 read_xtrafile__done2:
    ;
    ;load in residents
    ;
  LEA residents_table(PC),A0
  MOVEQ.l #$07,D0

 read_xtrafile__loop3:
    CLR.l $40(A0)
    LEA $44(A0),A0
  DBF D0,read_xtrafile__loop3

  MOVEM.l D7/A6,-(A7)
  JSR init_buffers
  JSR reloadresident
  MOVEM.l (A7)+,D7/A6
RTS


.write_xtrafile:                                           ;savextra org source ; D7 = filepointer A6 = dosbase
  MOVE.b #$1,xtra_versionnumber                            ;.xtra version number...

;  LEA ptr_xtradata,A2
;  MOVE.l A2,D0
;  !basic
;  testD0.l= PutD0
;  !cout{"xtradata at: ",Hex$(testD0)}
;  !asm

  LEA ptr_xtradata,A2
  MOVEQ.l #$00,D4

  ; -- boolean options speichern
 write_xtrafile__loop:
  MOVE.w (A2)+,D4                                          ; anzahl bytes zu schreiben
  BEQ.b write_xtrafile__done

 write_xtrafile__loop2:
   MOVE.l (A2)+,D2
   BEQ.b write_xtrafile__loop

   MOVE.l D4,D3
   MOVE.l D7,D1                                            ; schreiben der daten in ptr_xtradata
   JSR _Write(A6)                                          ; d1: file, d2: buffer, d3:length
BRA.b write_xtrafile__loop2

 write_xtrafile__done:                                                ;write out cli arguement...
  MOVE.l D7,D1
  MOVE.l #str_cliarguments,D2
  MOVE.l #116,D3
  JSR _Write(A6)                                           ; hier werden 116 bytes an cli_arguments geschrieben !!

  MOVE.l D7,D1
  MOVE.l #stacksize,D2
  MOVE.l #4,D3
  JSR _Write(A6)

  MOVE.l D7,D1
  MOVE.l #versioninformation,D2
  MOVE.l #4,D3
  JSR _Write(A6)

  MOVE.l D7,D1
  MOVE.l #number_of_builds,D2
  MOVE.l #4,D3
  JSR _Write(A6)
    ;
    ;OK, now to write out max's
    ;
    ;lib#.w,
    ;max.w.
  LEA libpointer,A2

 write_xtrafile__loop3:
    MOVE.l (A2),D0
    BEQ.w write_xtrafile__done2
    MOVEA.l D0,A2
    MOVE.l $12(A2),D4
    TST.w -$2(A2,D4.L)
    BEQ.w write_xtrafile__loop3

    LEA $4(A2),A0
    MOVE.l A0,D2
    MOVEQ.l #$02,D3
    MOVE.l D7,D1                                           ; schreiben der Libnum mit 2 bytes
    JSR _Write(A6)                                         ; d1: file, d2: buffer, d3:length

    LEA -$4(A2,D4.L),A0
    MOVE.l A0,D2
    MOVEQ.l #$02,D3
    MOVE.l D7,D1                                           ; schreiben der Max Objects mit 2 bytes
    JSR _Write(A6)                                         ; d1: file, d2: buffer, d3:length
BRA.w write_xtrafile__loop3

 write_xtrafile__done2:

  ; write 4 fill/pad/termination bytes because the .read_xtrafile routine read min 4 bytes more as saved, this was moved form PED extend xtra Data save routine  tomsmart1
  LEA XTRAEndPadBytes,A2 ; get the start address off the 4 fill/pad/termination bytes
  MOVE.l A2,D2           ; move the address to d2
  MOVE.l #4,D3           ; we only need 4 bytes to save
  MOVE.l D7,D1           ; we set the file handle
  JSR _Write(A6)         ; and we write it.

RTS


.menu_compileroptions:                                     ;menu4 org source  ;options requester
  LEA optssave,A0
  LEA ptr_xtradata,A1

 menu_compileroptions__loop:
  MOVE.w (A1)+,D0                                          ;length of data move
  BEQ.b menu_compileroptions__done
  SUBQ.w #1,D0

 menu_compileroptions__loop2:
    MOVE.l (A1)+,D1
    BEQ.b menu_compileroptions__loop
    MOVEA.l D1,A2
    MOVE.w D0,D1

 menu_compileroptions__loop3:
      MOVE.b (A2)+,(A0)+
  DBF D1,menu_compileroptions__loop3

BRA.w menu_compileroptions__loop2

 menu_compileroptions__done:
  ;MAKE INT GADS!
  LEA bufferlist,A1

 menu_compileroptions__loop4:
    MOVE.l (A1)+,D2
    BEQ.b menu4c

    MOVEA.l D2,A0
    MOVE.l (A0),D2
    ADDQ.w #8,A0
    JSR makelong
BRA.b menu_compileroptions__loop4

 menu4c:
  CLR.w state_of_residents                                 ;resident change
  CLR.w comsettings_message                                ;alloc change
  CLR.w maxobject_pos

 settings_events:                                          
    Gosub newoptionsfunc
    ;$6 stringbuffer
    ;$9 icons
    ;$a runtime error
    ;$f smallest
    ;$10 debuginfo
    ;$11 =ok
    ;$14 =cancel
    ;$1b =resident  line 1
    ;$1c =resident  line 2

 menu4c__igot:
    CMP.w #-$1,D7
     BNE.w settings_events
    CMP.w #$5,D6                                           ; vorher $6
     BHI.w menu4c__notmax2                                      ; 6, 9, F, 10, 11, 14
    MOVE.w D6,comsettings_message
BRA.w settings_events

 menu4c__notmax2:
  CMP.w #$A,D6
  BNE.w JL_0_10084                                         ; JL_0_1003C

  BTST #$7,use_debugger                                    ;runtime ERROR
  BNE 'debugon
  CLR.w debugmode
BRA.b 'debugoff

 'debugon
  SNE debugmode

 'debugoff
  MOVE.l a0,-(a7)
;  MOVE.l comdata,a0
;  MOVE.b debugmode,$7ee(a0)
  !ComData_SetB{comByte_DebugMode,debugmode}
  MOVE.l (a7)+,a0

BRA.w settings_events


 JL_0_10084:
  CMP.w #$11,D6
   BCS.w settings_events
  CMP.w #$14,D6
   BHI.w settings_events
  BEQ.w menu4canc
  ; -- settings closed with "ok"

  MOVE.w D6,-(A7)
  MOVE.w comsettings_message,D0
   BEQ.w menu4c__skip
  JSR init_buffers

 menu4c__skip:
  MOVE.w state_of_residents,D0
   BEQ.w menu4c__zdone
  JSR reloadresident

 menu4c__zdone:
  MOVE.w (A7)+,D6

  CMP.w #$12,D6
   BEQ.w JUMP_menu_compile_run
  CMP.w #$13,D6
   BEQ.w JUMP_menu_createexecutable
RTS

 JUMP_menu_compile_run:
JMP menu_compile_run

 JUMP_menu_createexecutable:
JMP menu_createexecutable


menu4canc:                                                ;cancel compilersettings
  LEA optssave,A0
  LEA ptr_xtradata,A1

 menu4canc__loop:
  MOVE.w (A1)+,D0
  BEQ.b menu4canc__done
  SUBQ.w #1,D0

 menu4canc__loop2:
    MOVE.l (A1)+,D1
    BEQ.b menu4canc__loop
    MOVEA.l D1,A2
    MOVE.w D0,D1

 menu4canc__loop3:
      MOVE.b (A0)+,(A2)+
  DBF D1,menu4canc__loop3

BRA.b menu4canc__loop2

 menu4canc__done:
RTS


.getobjectentry:
  MOVE.l d0,a1
  MOVEA.l libpointer,A2

 JL_0_1027Ca:
    MOVE.l $12(A2),D0
    TST.w -$2(A2,D0.L)
     BEQ.w JL_0_102AAa
    SUBQ.w #1,D1
     BPL.w JL_0_102AAa
    MOVEA.l -$1A(A2,D0.L),A3
    ADDA.l A2,A3

 JL_0_10294a:
      MOVE.b (A3)+,(A1)+
    BNE.w JL_0_10294a

    CLR.b -(A1)
    MOVE.w -$4(A2,D0.L),D0
    AND.l #$ffff,d0
RTS

 JL_0_102AAa:
    MOVEA.l (A2),A2
BRA.w JL_0_1027Ca


; --
; -- compilersetting_datas
str_maxobjects_name:   Dc.b "              ",0 : Even
str_maxobjects_name2:  Dc.b "              ",0 : Even
objectbuffer:          Ds.w 1
                       Dc.b "@",0,0
                       Ds.b 3
str_objectbuffer:      Dc.b "16384",0,0
                       Ds.b 5
libsbuffer:            Ds.w 1
                       Dc.b $80,$00,$00,$00
                       Ds.w 1
str_libsbuffer:        Dc.b "16384",0,0
                       Ds.b 5
systembuffer:          Ds.w 1                              ; systen buffer
                       Dc.b $10,$00,$00,$00
                       Ds.w 1
str_systembuffer:      Dc.b "4096",0,0
                       Ds.w 3
databuffer:            Ds.w 1                              ; data buffer
                       Dc.b $10,$00,$00,$00
                       Ds.w 1
str_databuffer:        Dc.b "4096",0,0
                       Ds.w 3
macrobuffer_size:      Ds.w 1                              ; macro buffer
                       Dc.b " ",0,0
                       Ds.b 3
str_macrobuffer:       Dc.b "8192",0,0
                       Ds.w 3
stringbuffer:          Ds.w 1                              ; string buffer
                       Dc.b "(",0,0
                       Ds.b 3
str_stringbuffer:      Dc.b "10240",0,0                    ; stringbuff
                       Ds.b 5
maxobjects_value:      Dc.b $00,$64,$00,$00
                       Ds.w 1
str_maxobjects_value:  Dc.b "100",0,0
                       Ds.b 7
maxobjects_value2:     Dc.b $00,$14,$00,$00
;   Ds.w 1
str_maxobjects_value2: Dc.b "20",0,0
                       Ds.l 2

set_create_iconfile:   Dc.b $00
create_iconfile:       Dc.b $80,$01,$01                    ;create icon
                       Dc.b $00,$01

set_use_debugger:      Dc.b $00                            ; Flags.w
use_debugger:          Dc.b $80,$01,$01                    ; Activation.w
                       Dc.b $00,$01                        ; GadgetType.w
AL_0_11010:            Dc.b $00,$80,$01,$01                ; flags, activation
AL_0_1103C:            Dc.b $00,$80,$01,$01                ; flags, activation
AL_0_11068:            Dc.b $00,$80,$01,$01                ; flags, activation
AL_0_11094:            Ds.w 1

set_make_smallestcode: Ds.b 1
make_smallestcode:     Dc.b $00,$01,$01                    ;make smallest
                       Dc.b $00,$01
set_link_debuginfo:    Ds.b 1
link_debuginfo:        Dc.b $00,$01,$01                    ;create debuginfo
                       Dc.b $00,$01


; -------------------------------------------------
residents_table:   ; 544 bytes, 68 bytes je eintrag
  Ds.l 17          ;resident files STEP $44 piece 8
AL_0_113A8:
  Ds.l 63
  Ds.l 39
AL_0_11540:
  Ds.l 17
; -------------------------------------------------

str_calcexpression:    Ds.l 32
AL_0_11A20:            Ds.l 1
Even


.menu_calculator:
  MOVE.l destbufferend,AL_0_11A20
  MOVE.l A7,errstack
  MOVE.l #AJL_0_11C00,errcont
  CLR.b str_calcexpression
  !basic
  If Peek.l(Addr Window(3))=0
    FindScreen 0
    WZWindow 3,?wzgui,128,-2,-2,-2,-2,3
    Poke.w ?button_bin_flags, $00
    Poke.w ?button_dec_flags, $80

    activategadget{"CALC_EXPRESSION"}
    calc_exit.l = False
    Repeat
      ev.l = WaitEvent
      Select ev

        Case #IDCMP_IDCMPUPDATE
          Select WZGadName

            Case "CALC_EXPRESSION"
              calc_expression$ = WZGetString("CALC_EXPRESSION")
              Poke$ ?str_calcexpression,calc_expression$

            Case "BIN"
              Poke.w ?button_bin_flags, $80
              Poke.w ?button_dec_flags, $00

            Case "HEX"
              Poke.w ?button_bin_flags, $00
              Poke.w ?button_dec_flags, $00

            Case "DEC"
              Poke.w ?button_bin_flags, $00
              Poke.w ?button_dec_flags, $80

            Case "CALC_CLOSE"
              calc_exit = True

          End Select
          If calc_expression$<>""
            !asm
            BSR examine_expression
            !basic
            calc_expression$ = Peek$(?str_calcexpression)
            WZPrint "CALC_EXPRESSION",&calc_expression$
          EndIf

        Case #IDCMP_CLOSEWINDOW
          calc_exit = True

      End Select
      activategadget{"CALC_EXPRESSION"}
    Until calc_exit
    WZCloseWindow 3
    !asm
  RTS
  EndIf
  !asm

  ; examine entered expression
.examine_expression:
  LEA str_calcexpression,A0

  ;MOVEA.l comdata,A1
  ;MOVEA.l $38(A1),A1                                       ; print update in stringgadget
;L_0_11AB8:
  ;JSR (A1)

  ; auswerten der expression
  JSR setcvars
  JSR setsvars
  CLR.w connest
  LEA str_calcexpression,A5
  JSR AJL_0_BF6E
  LEA str_calcexpression,A0
  TST.l D3
   BPL.w JL_0_11AE8
  MOVE.b #$2D,(A0)+
  NEG.l D3

 JL_0_11AE8:
  CMPI.w #$80,button_dec_flags
   BEQ.w JL_0_11B74
  MOVEQ.l #$00,D1
  CMPI.w #$80,button_bin_flags
   BNE.w JL_0_11B36
  MOVEQ.l #$1F,D0
  MOVE.b #$25,(A0)+

 JL_0_11B08:
      LSL.l #1,D3
       BCC.w JL_0_11B18
      MOVE.b #"1",(A0)+
      MOVEQ.l #-$01,D1
  BRA.w JL_0_11B22

   JL_0_11B18:
      TST.w D1
      BEQ.w JL_0_11B22
      MOVE.b #"0",(A0)+

   JL_0_11B22:
 DBF D0,JL_0_11B08

 JL_0_11B26:
  TST.w D1
  BNE.w JL_0_11B30
  MOVE.b #"0",(A0)+

 JL_0_11B30:
  CLR.b (A0)
BRA.w JL_0_11B7C

 JL_0_11B36:
  MOVEQ.l #$07,D0
  MOVE.b #$24,(A0)+

 JL_0_11B3C:
    MOVE.l D3,D2
    SWAP D2
    LSR.w #8,D2
    LSR.w #4,D2
    ADDI.w #$30,D2
    CMP.w #$3A,D2
     BCS.w JL_0_11B52
    ADDQ.w #7,D2

   JL_0_11B52:
    CMP.w #$30,D2
    BEQ.w JL_0_11B62
    MOVE.b D2,(A0)+
    MOVEQ.l #-$01,D1
  BRA.w JL_0_11B6A

   JL_0_11B62:
    TST.w D1
     BEQ.w JL_0_11B6A
    MOVE.b D2,(A0)+

   JL_0_11B6A:
    LSL.l #4,D3
 DBF D0,JL_0_11B3C

BRA.w JL_0_11B26

 JL_0_11B74:
  MOVE.l D3,D2
  JSR makelong

 JL_0_11B7C:
RTS


AJL_0_11C00:
  MOVE.l AL_0_11A20,destbufferend
  CLR.b str_calcexpression
BRA.w JL_0_11B7C


Even
str_cliarguments: Ds.b 255   ; a command line can acutally be 255 characters long

Even

.menu_simcliarguments:
;  MOVEA.l comdata,A1
;  MOVEA.l $802(A1),A1                                     ; compiler says to PED: openwindow
  !ComData_GetL{comFunc_OpenCompilerWindow,A1}
  MOVE.l #1001,D0
  MOVE.l #str_cliarguments,D1
  JSR (A1)
RTS


.skipme:                                                   ;??Looks like double label??
 'l1
    MOVE.b (a5)+,d0
    BEQ 'l2
    CMP.b #$80,d0
    BNE 'l1
    MOVE.b (a5)+,d0
    BEQ 'l2
    CMP.b #$02,d0
  BNE 'l1

 'l3
    CMP.b #$20,(a5)+
  BEQ 'l3
  SUBQ.l #1,a5
  TST.b (a5)
  BEQ 'l2
  CMP.w #$8008,(a5)
  BEQ 'l4
  CMP.w #$8009,(a5)
  BEQ 'l4
BRA 'l1

 'l4
  ADDQ.l #2,a5
  JSR skiprest
RTS

 'l2
  JSR nextline
  BNE 'l1
RTS


.compiledate
  !basic
  DateFormat 1
  i.l=SystemDate
  a$=Date$ (i)
  a$=Replace$(a$,"/",".")
  GetD0 &a$
  MOVEQ #8,d2
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b (a0)+,d0
  !asm
  ADD.l #9,d2
  ADD.l #9,a5
RTS


.compiledate_ger
  !basic
  DateFormat 0
  i.l=SystemDate
  a$=Date$ (i)
  a$=Replace$(a$,"/",".")
  GetD0 &a$
  MOVEQ #8,d2
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b (a0)+,d0
  !asm
  ADD.l #9,d2
  ADD.l #13,a5
RTS


.compiledatedc
  !basic
  DateFormat 1
  i.l = SystemDate
  a$ = Date$ (i)
  a$ = Replace$(a$,"/",".")
  GetD0 &a$
  MOVEQ #8,d2
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR writebyte
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b (a0)+,d0
  !asm
  ADD.l #9,a5
RTS


.compiledatedc_ger
  !basic
  DateFormat 0
  i.l=SystemDate
  a$=Date$ (i)
  a$=Replace$(a$,"/",".")
  GetD0 &a$
  MOVEQ #8,d2
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR writebyte
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b (a0)+,d0
  !asm
  ADD.l #13,a5
RTS


.version_string:
  MOVE.l d2,-(a7)                                          ; D2 -> stack
  MOVE.l a5,d0
  !basic
  _myD0.l = PutD0
  If _myD0
    verstring$ = Left$(Peek.s(_myD0),9+3)
    verstring$ = UnRight$(verstring$,3)                      ; Compilerkonstantenbeginn \__ entfernen
  Else
    error{"INTERNAL: Invalid pointer in version_string!"}
  End If

  ; Version coded as : Majorversion Minorversion Patchlevel
  ;                    00           00           00
  actual_version.l = Peek.l(?versioninformation)
  actual_build.l   = Peek.l(?number_of_builds)

  Format "00"
  Select verstring$

    Case "VER_MAJOR"
     put_versionstr$ = Str$(actual_version LSR 24)

    Case "VER_MINOR"
     put_versionstr$ = Str$((actual_version LSL 8) LSR 24)

    Case "VER_PATCH"
     put_versionstr$ = Str$((actual_version LSL 16) LSR 24 )

    Case "VER_BUILD"
     Format ""
     put_versionstr$ = Str$(actual_build)

    Default
     put_versionstr$ = "{unknown compilerconstant}"
;    a5add.l = 4

  End Select
  Format ""

  GetD0 FLen(put_versionstr$)                              ; laenge zielstring -> Stack
  MOVE.l d0,d2
  MOVE.l d2,-(a7)
  SUB #1,d2

  GetD0 &put_versionstr$                                   ; kopieren des neuen Strings in den Zielstring
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
 DBF d2,'l1

  MOVEQ #0,d0
  !asm
  MOVE.l (a7)+,d0                                          ; laenge Zielstring <- Stack
  MOVE.l (a7)+,d2                                          ; d2 <-Stack
  ADD.l d0,d2
  ADD.l #12,a5                                             ; string_ptr um konstante weitersetzen
  MOVEQ #0,d0
RTS


.version_string_dc:
  MOVE.l a5,d0
  !basic
  _myD0.l = PutD0
  If _myD0
    verstring$ = Left$(Peek.s(_myD0),9+3)
    verstring$ = UnRight$(verstring$,3)                      ; Compilerkonstantenbeginn \__ entfernen
  Else
    error{"INTERNAL: Invalid pointer in version_string_dc!"}
  End If

  ; Version coded as : Majorversion Minorversion Patchlevel
  ;                    00           00           00
  actual_version.l = Peek.l(?versioninformation)
  actual_build.l   = Peek.l(?number_of_builds)

  Format ""
  Select verstring$

    Case "VER_MAJOR"
     put_versionstr$ = Str$(actual_version LSR 24)

    Case "VER_MINOR"
     put_versionstr$ = Str$((actual_version LSL 8) LSR 24)

    Case "VER_PATCH"
     put_versionstr$ = Str$((actual_version LSL 16) LSR 24 )

    Case "VER_BUILD"
     Format ""
     put_versionstr$ = Str$(actual_build)

    Default
     put_versionstr$ = "{unknown compilerconstant}"

  End Select
  Format ""

  GetD0 FLen(put_versionstr$)-1
  MOVE.l d0,d2

  GetD0 &put_versionstr$                                   ; kopieren des neuen Strings in den Zielstring
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR writebyte
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b -(a0),d0                                          ; letztes Zeichen in D0
  !asm
  ADD.l #12,a5                                             ; string_ptr um konstante weitersetzen
RTS


.insert_functionname:
; "\\__THIS_FUNCTION
  MOVE.l d2,-(a7)                                          ; D2 -> stack
  MOVE.l a5,d0
  !basic
  _myD0.l = PutD0
  If _myD0
    constring$ = Left$(Peek.s(_myD0),13 + 3)
    constring$ = UnRight$(constring$,3)                      ; Compilerkonstantenbeginn \__ entfernen
  Else
    error{"INTERNAL: Invalid pointer in insert_functionname!"}
  End If
  Select LCase$(constring$)

   Case "this_function"
    If Peek.l(?currentfunction)<>0
      currentfuncP.l = Peek.l(?currentfunction)
      If currentfuncP
        condata$ = Peek.s(currentfuncP + 48 + 1)
      Else
        condata$ = "???"
        error{"INTERNAL: Invalid pointer in currentfunction!"}
      End If
    Else
      condata$ = "GLOBAL"
    EndIf

   Default
    condata$ = constring$

  End Select
  GetD0 Len(condata$)                                      ; laenge zielstring -> Stack
  MOVE.l d0,d2
  MOVE.l d2,-(a7)

  GetD0 &condata$                                          ; kopieren des neuen Strings in den Zielstring
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
 DBF d2,'l1

  !asm
  MOVE.l (a7)+,d0                                          ; laenge Zielstring <- Stack
  MOVE.l (a7)+,d2                                          ; d2 <-Stack
  ADD.l d0,d2                                              ; eingefuegte chars zu D2 dazu
  ADD.l #16,a5                                             ; string_ptr um konstante weitersetzen
RTS


.insert_codeline:
; "\\__codeline
  MOVE.l d2,-(a7)                                          ; D2 -> stack
  MOVE.l a5,d0
  !basic
  _myD0.l = PutD0
  If _myD0
    constring$ = Left$(Peek.s(_myD0),8 + 3)
    constring$ = UnRight$(constring$,3)                      ; Compilerkonstantenbeginn \__ entfernen
  Else
    error{"INTERNAL: Invalid pointer in insert_codeline!"}
    constring$ = "???"
  End If
  Select LCase$(constring$)

   Case "codeline"
    condata$ = Str$(Peek.l(?globallinecount))

   Default
    condata$ = constring$

  End Select

  GetD0 Len(condata$)                                      ; laenge zielstring -> Stack
  MOVE.l d0,d2
  MOVE.l d2,-(a7)
  SUB #1,d2

  GetD0 &condata$                                          ; kopieren des neuen Strings in den Zielstring
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
 DBF d2,'l1

  MOVEQ #0,d0
  !asm
  MOVE.l (a7)+,d0                                          ; laenge Zielstring <- Stack
  MOVE.l (a7)+,d2                                          ; d2 <-Stack
  ADD.l d0,d2
  ADD.l #11,a5                                             ; string_ptr um konstante weitersetzen
  MOVEQ #0,d0
RTS


Function.l ab3_GetIncludeLock{filename.s}
  incLock.l  = Lock_ (&filename,#ACCESS_READ)   ; try bla.blub
  ex.s       = dos_GetExt{filename}

  If incLock = False
    filename = dos_SetExt{filename,"ab3"}
    incLock  = Lock_ (&filename,#ACCESS_READ)   ; try bla.ab3
  End If

  If incLock = False
    filename = dos_SetExt{filename,"ab2"}
    incLock  = Lock_ (&filename,#ACCESS_READ)   ; try bla.ab2
  End If

  If incLock = False
    filename = dos_SetExt{filename,"bb2"}
    incLock  = Lock_ (&filename,#ACCESS_READ)   ; try bla.bb2
  End If

  If incLock = False
    filename = dos_SetExt{filename,ex+".ab3"}
    incLock  = Lock_ (&filename,#ACCESS_READ)   ; try bla.blub.ab3
  End If

  If incLock = False
    filename = dos_SetExt{filename,"ab2"}
    incLock  = Lock_ (&filename,#ACCESS_READ)   ; try bla.blub.ab2
  End If

  If incLock = False
    filename = dos_SetExt{filename,"bb2"}
    incLock  = Lock_ (&filename,#ACCESS_READ)   ; try bla.blub.bb2
  End If

 Function Return incLock
End Function


.check_incdir:
  !basic
  incString.s = Peek$(?ptr_parameterstore)
                                                            ; to fix includepathes in CLIMode   tomsmart1
  !ComData_LEA{comStr_CurrentDir,D0}                        ; get pointer to current Sourcefiledir
  incDirP.l   = PutD0                                       ;    "
  incDir_.s   = Peek.s(incDirP)                             ; get current Sourcefiledir
  incFile.s   = dos_AddPart{incDir_,incString}              ; adding Sourcefiledir and Includestring
  incLock.l   = ab3_GetIncludeLock{incFile}                 ; check if file exist

  If incLock = False ; not found => check default Include Directory
    incDirP.l = Peek.l(?incd)
    If incDirP
      incDir_.s = Peek.s(incDirP)
    Else
      incDir_.s = dos_AddPart{Peek.s(?str_blitz3assign),"Sourcecodes/Includes"}
    End If
    incFile.s = dos_AddPart{incDir_,incString}
    incLock.l = ab3_GetIncludeLock{incFile}
  End If

  If incLock = False ; not found => check relative to current source
    incDepth.l = Peek.w(?ininclude)-1
    If incDepth >= 0 AND incDepth < #maxincludes
      incDir_.s = dos_PathPart{incdim (incDepth)} ;= Peek.s(?includetemp2)
      incFile.s = dos_AddPart{incDir_,incString}
      incLock.l = ab3_GetIncludeLock{incFile}
    End If
  End If

  If incLock = False ; still not found => check default Include Directory and name only
    incDirP.l = Peek.l(?incd)
    If incDirP
      incDir_.s = Peek.s(incDirP)
    Else
      incDir_.s = dos_AddPart{Peek.s(?str_blitz3assign),"Sourcecodes/Includes"}
    End If
    incFile.s = dos_AddPart{incDir_,dos_FilePart{incString}}
    incLock.l = ab3_GetIncludeLock{incFile}
  End If

  If incLock
    MaxLen incFile = 1024
    NameFromLock_ incLock,&incFile,1024
    incFile = Peek.s(&incFile)
    Poke$ ?ptr_parameterstore,incFile
    i = FLen(incFile)
    GetReg d0,i
    MOVE.l d0,tempstore
    UnLock_ incLock
  End If

  !asm
  TST.l tempstore
   BEQ 'l1
  MOVE.l tempstore,d2

 'l1
RTS


.check_IncBinDir:                                           ; to fix includepathes in CLIMode   tomsmart1
  !basic
  incString.s = Peek$(?ptr_parameterstore)                  ; get the string
  !ComData_LEA{comStr_CurrentDir,D0}                        ; get pointer to current Sourcefiledir
  incDirP.l   = PutD0                                       ;    "
  incDir_.s   = Peek.s(incDirP)                             ; get current Sourcefiledir
  incFile.s   = dos_AddPart{incDir_,incString}              ; adding Sourcefiledir and Includestring
  incLock.l   = Lock_(&incFile,#ACCESS_READ)                ; check if file exist

  If incLock = False                                        ; not found => try orignal string only to find
    incLock.l = Lock_(&incString,#ACCESS_READ)
  End If

  If incLock                                                ; found => store full path
    MaxLen incFile = 1024
    NameFromLock_ incLock,&incFile,1024
    incFile = Peek.s(&incFile)
    Poke$ ?ptr_parameterstore,incFile
  End If

  GetReg d0,incLock                                         ; store Lockpointer in D0 for a futher use in the orginal routine (errormsg, Examine, UnLock)
  !asm
RTS


.gotoendsource
  ; MOVE.w #1,dontwrite

;'l1
  ; JSR naloextline
  ; BNE 'l1
  ; ADDQ.l #1,numlines2
  ; ;JSR skiprest
  JSR Aclearallvars
  JSR free_unusedfunctions
  ;
;'l2
  ; MOVE.l firstiff,d0
  ; BEQ 'done
  ; MOVE.l d0,a1
  ; MOVE.l (A1),firstiff
  ; MOVEQ.l #$0E,D0
  ; movea.l _execbase,A6
  ; MOVE.l mempool,a0
  ; JSR _FreePooled(A6)
;BRA 'l2

 'done
  ; MOVE.l stackaddr,a7
  MOVE.l #"NORE",reqmode
JSR handle_compileerror

 .linemessage
  MOVE.l d0,-(a7)
  MOVE.l a5,d0
  !basica7
  i.l = PutD0
  If i
    a$ = Peek$(i)
    b$ = Peeks$(i-7,7)
    i = Request(!TRANS{"Do workaround ?"},b$ + a$,!TRANS{"Yes|No"})
    MOVE.l d0,result
  End If
  !asma7
  MOVE.l (a7)+,d0
RTS


.check_of_same_source:
  !basic
  !ComData_LEA{comStr_CurrentDir,D0}
  currentDirP.l = PutD0

  !ComData_LEA{comStr_SourceName,D0}
  fileNameP.l = PutD0

  check_dirname$  = Peek$(currentDirP)
  check_filename$ = Peek$(fileNameP)
  If (olddirname$<>check_dirname$) OR (oldfilename$<>check_filename$)
    JSR free_unusedfunctions
  End If
  olddirname$ = Peek$(check_dirname$)
  oldfilename$ = Peek$(check_filename$)
  For i = 0 To #maxincludes-1
    incline(i) = 0
  Next
  !asm
RTS


.addimmi
  MOVEQ #0,d1

 'l1
  MOVE.b (a5)+,d0
  BEQ 'er1
  CMP.b #$20,d0
  BEQ 'l1
  ADDQ #1,d1
  CMP.b #$22,d0
  BNE 'l1
RTS

 'er1
JMP syntaxerr

;  Dc.l $3A3A                                               ; deactivate unused code  tomsmart1

; checkfor_wbmessage:                                       ; deactivte unused and unneeded code to get the WBStartup message  tomsmart1
;  JSR _WaitPort(A6)
;  LEA $5C(A4),A0
;  JSR _GetMsg(A6)
;RTS


erro1t   Dc.b "Only one BSS / Chip Segment allowed",0 : Even
nodata   Dc.b "BSS Segment contains Data!!!!",0       : Even
Even


.bssseg
  TST.b exdebug
  BNE 'l10
  MOVE.l #$4e71,d1
  JSR writeword
  MOVE.l destpointer,d0
  MOVE.l d0,d1
  ADDQ.l #3,d1
  AND.l #$fffffffc,d1
  MOVE.l d1,destpointer
  SUB.l destpointer,d0
  BEQ 'lnf1
  CMP.l #-1,bssstart
  BNE 'lnf1
  CMP.l #-1,chipstart
  BNE 'lnf1
  MOVE.l destpointer,a4
  TST.w dontwrite
  BNE 'lnf1
  MOVE.w #$4e71,-2(a4)

 'lnf1
  CMP.l #-1,bssstart
  BEQ 'l11
  MOVE.l #erro1t,-(a7)
JMP handle_compileerror

 'l11
  MOVE.l destpointer,bssstart
  MOVE.b #1,bssmode

 'x2
  TST.b chipmode
  BEQ 'l10
  MOVE.l destpointer,chipend
  CLR.b chipmode

 'l10
  JSR get1bytemain
RTS


.chipseg
   TST.b exdebug
  BNE 'x1
  MOVE.l destpointer,d0
  MOVE.l d0,realbssend
  MOVE.l #$4e71,d1
  JSR writeword
  MOVE.l destpointer,d0
  MOVE.l d0,d1
  ADDQ.l #3,d1
  AND.l #$fffffffc,d1
  MOVE.l d1,destpointer
  SUB.l destpointer,d0
  BEQ 'lnf1
  MOVE.l destpointer,a4
  CMP.l #-1,bssstart
  BNE 'lnf1
  CMP.l #-1,chipstart
  BNE 'lnf1
  TST.w dontwrite
  BNE 'lnf1
  MOVE.w #$4e71,-2(a4)

 'lnf1
  TST.b bssmode
  BEQ 'l10
  MOVE.l destpointer,bssend
  CLR.b bssmode

 'l10
  ;addq.l #3,destpointer
  ;and.l #$fffffffc,destpointer
  CMP.l #-1,chipstart
  BEQ 'l11
  MOVE.l #erro1t,-(a7)
JMP handle_compileerror

 'l11
  MOVE.l destpointer,chipstart
  MOVE.b #1,chipmode

 'x1
  JSR get1bytemain
RTS


.save_includename:
  !basic
;  For i = 0 To  #maxincludes-1
;    If dos_FilePart{incdim(i)} = dos_FilePart{Peek$(?includetemp2)}
;      !cout{"schon drin: " + Peek$(?includetemp2)}
;      Pop For
;      !asm
;      RTS
;    EndIf
;  Next i
;  !cout{"storing: ",Peek$(?includetemp2),Peek.l(?includeline)}
  i.l = Peek.w(?ininclude)
  If i>=0 AND i<#maxincludes
    incdim (i) = Peek.s(?includetemp2)
    incline(i) = Peek.l(?includeline)

    If CLIMode
      If cli_verbose>=2 Then NPrint "  -> Compiling ",incdim(i),"..."
    End If
  End If

  !asm
RTS


.zero_includename:
  !basic
  i.l = Peek.w(?ininclude)
  If i>=0 AND i<#maxincludes
    incdim (i) = ""
    incline(i) = 0
    If i>0 Then Poke.l (?includeline),incline(i-1)+1
  End If
  !asm
RTS


.replacelib:
  LEA replacedat,a0
  Dc.w $3181,$0A00                                         ;MOVE.w d1,0(a0,d0.l*2)
RTS


.writeinit:
  TST.b fpu
  BEQ 'l1

 'l1
  MOVE.l destpointer,newinitaddr
  JSR writeword
  JSR writelong
RTS


.stripspaces:                                              ;??Looks like double label??
 'll21
  TST.b (a5)
   BEQ.s 'll20
  CMP.b #$20,(a5)
   BNE.s 'll10
  ADDQ.l #1,a5
BRA.s 'll21

 'll10
  CMP.b #";",(a5)
  BNE.s 'll20

 'll25
  TST.b (a5)+
  BEQ.s 'll23
BRA.s 'll25

 'll23
  SUBQ.l #1,a5

 'll20
RTS


.findconstant2:
  MOVEM.l a2/d2,-(a7)
  MOVEQ #0,d2
  LEA ptr_parameterstore,a0
  LEA chartab,a2

 fc2
  MOVE.b (a5),d0
  TST.b 0(a2,d0)
  BNE 'l10
  ADDQ.l #1,a5
  MOVE.b d0,(a0)+
  ADDQ.l #1,d2
BRA fc2

 'l10
  CLR.b (a0)+
  JSR findlabel2
  MOVE.l a2,a0
  MOVEM.l (a7)+,a2/d2
RTS


.error:
  TST.l d0
  BNE 'l10
    MOVE.l #syntax_,-(a7)
JMP handle_compileerror

 'l10
  CMP.l #1,d0
  BNE 'l20
    MOVE.l #overflow,-(a7)
JMP handle_compileerror

 'l20
  ADD.l a2,d0
  MOVE.l d0,-(a7)
JMP handle_compileerror


;************************** don't scatter end
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP Atokejsr
  JMP writeinit
  JMP macroexecute
  JMP findnext
  JMP replacelib
  JMP findconstant2
  JMP findchar                                             ;char in d1
  JMP stripspaces
  JMP calc                                                 ;d0 varmode
  JMP error
  JMP writelong                                            ;d1 value
  JMP writeword                                            ;d1 value
  JMP writebyte                                            ;d1 value
JMP exit


.pluginbase
  destpointer:    Ds.l 1                                ;pc org source      ;Ds.w 1
                                                        ;destpointer+2:      Ds.b 1
                                                        ;destpointer+3:      Ds.b 1
  fast            Dc.w 0
  fpu             Dc.w 0
  newsyntax       Dc.w 0
  ;******************** don't scatter end
  optistring      Dc.b 0
  optistring2     Dc.b 0
  optiarray       Dc.b 0
  quickadd        Dc.b 0
  newmode         Dc.w 0
  mode            Dc.w 0
  string1         Dc.w 0
  load_var_size   Dc.w 0
  load_var_reg    Dc.w 0
  load_var_addr   Dc.l 0
  imm_size        Dc.w 0
  imm_reg         Dc.w 0
  imm_addr        Dc.l 0
  iee             Dc.b 0
  _dcb            Dc.b 0
  nohunkoffset    Dc.l 0

;-- data for ted
teddata:        Dc.l tokens
                Dc.l 0 ;compilermenu_entries               ; NOT used anymore
                Dc.l read_xtrafile
                Dc.l write_xtrafile
                Dc.l call_menuentry                        ; compile AND RUN ?
                Dc.l 0
                Dc.b ":",34,".;"
                Dc.l "NEW1"
                Dc.l newtypebase
realconstbase:  Dc.l labelbase
deflib          Dc.l 0
incd            Dc.l 0
                Dc.l 0
                Dc.l 0
                Dc.l 0
_return         RTS
                Dc.b 0
chartab2        Ds.l 256
codeend         Dc.l 0
hunkoffsetnum   Dc.l 0
chipsize        Dc.l 0
bsssize         Dc.l 0
bssstart        Dc.l -1
bssend          Dc.l -1
chipstart       Dc.l -1
chipend         Dc.l -1
bssmode         Dc.b 0
chipmode        Dc.b 0
newhunk         Dc.b 0
bssnum          Dc.l 0
chipnum         Dc.l 0
lastinstruction Dc.l 0
lastinstructionaddr Dc.l 0
hunkbegin       Dc.l $03F3,$00,$02,$00,$01
tstsize1b:      Ds.l 1
bsssize2        Dc.l 1
                Dc.l $03E9
tstsize2b:      Dc.l $100
hunkbegin2      Dc.l $03F3,$00,$03,$00,$02
tstsize1c:      Ds.l 1
bsssize3        Dc.l 1
chipsize2       Dc.l 1
                Dc.l $3e9
tstsize2c       Dc.l 0
hunkend         Dc.l $3f2,$3eb,0,$3f2
hunkend2        Dc.l $3f2,$3ea,0,$3f2
strcpy          Dc.b "strcpy",0
strcmp          Dc.b "strcmp",0
strvar          Dc.b "strvar",0
qmul            Dc.b "qmul",0
qdiv            Dc.b "qdiv",0
_MaxLen         Dc.b "maxlen",0
notf            Dc.b "????",0
;_intuiname      Dc.b "intuition.library",0
errtext         Dc.b "only reg addressing Mode supported",0
fpuerr          Dc.b "Instruction not yet supported by 68K FPU ",0
cmplxerr        Dc.b "Formula too complex for 68K FPU or too much regload register used",0 : Even
peeksize        Dc.w 0

mainstart       Dc.l 0
;addmemcode      Dc.b 0
infunctioncode  Dc.b 0
regnumstore     Dc.w 0
                Dc.b "$VER: AmiBlitz3 \\__VER_MAJOR.\\__VER_MINOR (\\__DATE_GER__) Build \\__VER_PATCH.\\__VER_BUILD",0 : Even
testcode        Dc.b "print i",0
                Ds.b 100
devo            Dc.b "developobject",0 : Even
autostorename   Dc.b "__autoconstantnum",0
_include        Dc.b "__include",0
_debug          Dc.b "__debug",0
unusedfunc      Dc.l 0
Even

.stdout_error
  MOVE.l a0,-(a7)
  MOVE.l a0,d0
  MOVE.l a5,a0                                             ;macro title
  !basic
  i = PutD0
  MOVEQ #20,d0

 'l2:
    MOVE.b -(a0),d1
    BEQ 'l1
    CMP.b #":",d1
    BEQ 'l1
    SUBQ.l #1,d0
    BNE 'l2

 'l1
  ADDQ #1,a0
  MOVE.l a0,d0
  i2.l = PutD0
  If Peek.w (?ininclude)>0
    Poke.s (?includetemp2),incdim(Peek.w(?ininclude)-1)
    errorline.l = Peek.l(?includeline);-1
    Poke.l ?compilelinecounter,Peek.l(?includeline) - 1
    errorfile.s = Peek.s(?includetemp2)
  Else
    Poke.s (?includetemp2),Peek.s(?ptr_parameterstore)
    errorline.l = Peek.l(?compilelinecounter) + 1
    errorfile.s = cli_sourcefile
  End If

  If i
    errortext.s = !TRANS{Replace$(Peek.s(i),"\\0a","\n")}
  Else
    errortext.s = "???"
  End If

  NPrint "\\1b[1m",!TRANS{"Compiler Error"}," <",errorfile,"@",errorline,">\\1b[0m ",errortext
;    NPrint peek.s(i2)
;  NPrint Peek.l(?globallinecount)," ",!TRANS{"line(s) compiled."}
;  NPrint Hex$(Peek.w(?globalvarpointer))+" global var base"
  !asm
  MOVE.l (a7)+,a0
RTS


.save_errorfile
  MOVE.l a0,-(a7)
  MOVE.l a0,d0
  MOVE.l a5,a0                                             ;macro title
  !basic
  i = PutD0
  MOVEQ #20,d0

 'l2:
    MOVE.b -(a0),d1
    BEQ 'l1
    CMP.b #":",d1
    BEQ 'l1
    SUBQ.l #1,d0
    BNE 'l2

 'l1
  ADDQ #1,a0
  MOVE.l a0,d0
  i2.l = PutD0
  fid.l = file_Open{dos_AddPart{my_systemdir$,"ab_compileerror.txt"},#file_forcewrite}
  If fid <> -1
    If Peek.w (?ininclude)>0
      Poke$(?includetemp2),incdim(Peek.w(?ininclude)-1)
    Else
      Poke$(?includetemp2),""
    End If
    a$ = Peek$(?includetemp2)
    x$ = Replace$(Peek$(i),"\\0a","\n")
    file_WriteLine{fid,x$}
    file_WriteLine{fid,Str$(Peek.l(?compilelinecounter) + 1)}
    If a$
      file_WriteLine{fid,a$}
      file_WriteLine{fid,Str$(Peek.l(?includeline)-1)}
      Poke.l ?compilelinecounter,Peek.l(?includeline) - 1
    Else
      file_WriteLine{fid,"none"}
    End If
    file_WriteLine{fid,Peek$(i2)}
    file_WriteLine{fid,Str$(Peek.l(?globallinecount))+" line(s) compiled"}
    file_WriteLine{fid,Hex$(Peek.w(?globalvarpointer))+" global var base"}
    file_Close{fid}
  End If
  !asm
  MOVE.l (a7)+,a0
RTS


.update_progressbar
  !basic
  progress.l     = PutD0
  total.l        = Peek.w(?progressbar_width)
  calcpro.l      = (progress * 100) / total +1
  pass.l         = Peek.w(?pass)
  typ.l          = Peek.w(?compiler_job)

  If pass><pass_old.l OR typ><typ_old.l
    pass_old = pass
    typ_old  = typ
    comstatus$ = "Initializing Compiler..."
    If typ=0
      comstatus$ = !TRANS{"Pass"}+" "+Str$(pass)+": "+!TRANS{"Compiling Sources..."}
    End If
    If typ=1
      comstatus$ = !TRANS{"Pass"}+" "+Str$(pass)+": "+!TRANS{"Building Executable..."}
    End If

    If Peek.l(Addr Window(4))<>0
      Use Window 4
      WZPrint "COMPILE_INFO",&comstatus$
    Else
      If cli_verbose>=2 Then NPrint comstatus$
    End If
  End If

  If (calcpro >< calcpro_old)
    If Peek.l(Addr Window(4))<>0
      If (((calcpro & $7)=0) OR (calcpro=100))
        testpr$ = Str$(calcpro)+"%%"
        WZPrint "COMPILE_GAUGE",calcpro,100,&testpr$
      End If
    Else
      ;If ((calcpro & $7)=0)
        ;Print "."
      ;End If
      If cli_verbose>=3 Then NPrint calcpro,"% compiled..."
    EndIf
    calcpro_old = calcpro
  EndIf
  !asm
RTS
 

.newoptionsfunc
  !basic
  MaxLen a$ = 5000
  var.l = ?residents_table
  If winon.l = 0
    FindScreen 0
    WZWindow 1,?wzgui,256,-2,ScreenHeight/6,-2,ScreenHeight/1.5,1
    WZ_SetFont{"WIN_CPREFS"}
    WZ_InitTable{"WIN_CPREFS","OBJECTS",2,0}
    WZ_SetTableColors{"OBJECTS",1,0,2,3,3}

    ; Setzen der Spaltentitel fuer die erste Zeile
    WZ_SetTableTitle{"OBJECTS","Objects","Max"}

    ; Legt die Prioritaet der 6 Spalten fest
    WZ_SetPriority{"OBJECTS",3,1}

    ; Setzt die zweite Spalte der Tabelle "OBJECTS" auf nicht editierbar
    WZ_SetEditable{"OBJECTS",False,True}

    ; Sortieren verboten
    WZ_SetSortable{"OBJECTS",Off}

    ; Fuegt Zeilen an die Tabelle "OBJECTS" an
    For i = 0 To Peek.w(?number_of_objects)-1
      a$ = ""
      GetD0 &a$,i:JSR getobjectentry : a.l = PutD0
      WZ_AddRow{"OBJECTS",Peek$(&a$),Str$(a)}
    Next
    WZ_DrawTable{"OBJECTS"}
    ; Fuellt die Tabelle mit den Werten, die mit WZAddRow{} erstellt wurden
    WZ_UpdateTable{"OBJECTS"}
    winon = 1
    var.l = ?residents_table
    a$ = Peek$(var)
    For i = 0 To 6
      a$ = a$ + "\\0a"
      var + $44
      a$ = a$ + Peek$(var)
    Next
    WZPrint "RESIDENTS",&a$

    i = Peek.l(?stringbuffer)
    WZPrint "STRINGBUFFER",i

    i = Peek.l(?stacksize)                            ;get stacksize  tomsmart1
    WZPrint "STACKSIZE",i                             ;print it  tomsmart1
                                                                                                                                                                                                                                                      
    var.l = 0
    BTST #7,create_iconfile
    BEQ 'noi
    var = 1

  'noi
    WZPrint "ICON",var
    var = 0
    BTST #7,make_smallestcode
    BEQ 'nos
    var = 1

  'nos
    WZPrint "SMALLEST",var
    var = 0
    BTST #7,link_debuginfo
    BEQ 'nodi
    var = 1

  'nodi
    WZPrint "DEBUGINFO",var
    ; Setzen der Schaltflaechen fuer die Debuggersettings
    var = 0

    !ComData_GetW{comWord_CreateDebugFile,D0}            ; get status of Create.dbg file  tomsmart1
    var = PutD0                                          ; save status to var  tomsmart1
    WZPrint "DBGFILE",var                                ; show status in the GUI tomsmart1

    var = 0                                              ; no runtime Debugging
    WZDisable "AUTORUN"                                  ; disable all Debugger settings  tomsmart1
    WZDisable "CHECK_INTERRUPT"                          ;                "
    WZDisable "CHECK_ASSEMBLER"                          ;                "
    WZDisable "CHECK_OVERFLOW"                           ;                "
    BTST #7,use_debugger                                 ; check status
    BEQ 'nod
    var = 1                                              ; yes runtime Debugging
    WZEnable "AUTORUN"                                   ; enable all Debugger settings  tomsmart1
    WZEnable "CHECK_INTERRUPT"                           ;               "
    WZEnable "CHECK_ASSEMBLER"                           ;               "
    WZEnable "CHECK_OVERFLOW"                            ;               "

  'nod
    WZPrint "DEBUG",var
    var = 0
    BTST #7,autorun
    BEQ 'nod4
    var = 1

  'nod4
    WZPrint "AUTORUN",var
    var.l = 0
    BTST #7,interruptcheck
    BEQ 'nod1
    var = 1

  'nod1
    WZPrint "CHECK_INTERRUPT",var
    var.l = 0
    BTST #7,assemblercheck
    BEQ 'nod2
    var = 1

  'nod2
    WZPrint "CHECK_ASSEMBLER",var
    var.l = 0
    BTST #7,overflowcheck
    BEQ 'nod3
    var = 1

  'nod3
    WZPrint "CHECK_OVERFLOW",var
  End If

  exit.l = 0
  mess.l = 0
  ev.l = WaitEvent
  WZ_CheckTableEvent{ev}
  Select ev

   Case #IDCMP_IDCMPUPDATE
    Select LCase$(WZGadName)

     Case "autorun"
       If WZInput
         BSET #7,autorun
       Else
         BCLR #7,autorun
       End If

     Case "check_interrupt"
       If WZInput
         BSET #7,interruptcheck
       Else
         BCLR #7,interruptcheck
       End If

     Case "check_assembler"
       If WZInput
         BSET #7,assemblercheck
       Else
         BCLR #7,assemblercheck
       End If

     Case "check_overflow"
       If WZInput
         BSET #7,overflowcheck
       Else
         BCLR #7,overflowcheck
       End If

     Case "residents"

     Case "stacksize"                                   ; stacksize changed  tomsmart1
       tempsize.l=WZInput                               ; save the valu to a temporay variable  tomsmart1
       If tempsize >= #MIN_STACKSIZE                    ; check size  tomsmart1
         Poke.l ?stacksize,tempsize                     ; save it.  tomsmart1
       Else                                             ; its not big enough  tomsmart1
         tempsize = #MIN_STACKSIZE                      ; set it to the min size  tomsmart1
         Poke.l ?stacksize,tempsize                     ; save it  tomsmart1
         WZPrint "STACKSIZE",tempsize                   ; print it  tomsmart1
       EndIf

     Case "stringbuffer"
       ;Poke$ ?str_stringbuffer,Str$(WZInput)
       Poke.l ?stringbuffer,WZInput
       mess = $6

     Case "debug"
       If WZInput
         BSET #7,use_debugger                           ; yes runtime Debugging
         WZEnable "AUTORUN"                             ; enable all Debugger settings  tomsmart1
         WZEnable "CHECK_INTERRUPT"                     ;               "
         WZEnable "CHECK_ASSEMBLER"                     ;               "
         WZEnable "CHECK_OVERFLOW"                      ;               "
       Else
         BCLR #7,use_debugger                           ; no runtime Debugging
         WZDisable "AUTORUN"                            ; disable all Debugger settings  tomsmart1
         WZDisable "CHECK_INTERRUPT"                    ;                "
         WZDisable "CHECK_ASSEMBLER"                    ;                "
         WZDisable "CHECK_OVERFLOW"                     ;                "
       End If
       mess = $a

     Case "icon"
       If WZInput
         BSET #7,create_iconfile
       Else
         BCLR #7,create_iconfile
       End If
       mess = $9

     Case "smallest"
       If WZInput
         BSET #7,make_smallestcode
       Else
         BCLR #7,make_smallestcode
       End If
       mess = $f

     Case "debuginfo"                                      ; check "Create Debug info" (Symbols)
       If WZInput
         BSET #7,link_debuginfo
       Else
         BCLR #7,link_debuginfo
       End If
       mess = $10

     Case "dbgfile"                                        ; check "Create .dbg File"   tomsmart1
       If WZInput
         !ComData_SetW{comWord_CreateDebugFile,#1}         ; yes we create it  tomsmart1
       Else
         !ComData_SetW{comWord_CreateDebugFile,#0}         ; no we don't  tomsmart1
       EndIf

     Case "cr"                                             ; compile and run in compiler prefs
      mess = $12 : exit = 1

     Case "ce"                                             ; compile und create exe in compile prefs
      mess = $13 : exit = 1
;      Poke$ (?exefilename),""                             ; remove clear of the executablename  tomsmart1
;      !asm
;      JSR menu_newcreate
;      !basic

     Case "cancel"
      mess.l = $14 : exit = 1

     Case "ok"
      mess = $11 : exit = 1

    End Select

  End Select

  If ev = $200 Then mess = $11:exit = 1
  If mess = $11
    For i = 1 To Peek.w(?number_of_objects)
      a$ = WZ_GetCell{"OBJECTS",i,2}
      i2 = Val(a$):If i2 = 0 Then i2 = 1
      Poke.w ?maxobjects_value,i2
      Poke.w ?maxobject_pos,i-1
      Gosub storemaxobjects
    Next
    Gosub stringtores
  End If

  If exit = 1
    MOVE.w #$FFFF,state_of_residents                       ;load resident
    WZ_KillTable{"OBJECTS"}
    WZCloseWindow 1
    winon = 0
  End If

  GetD0 mess
  !asm
  MOVEQ #-1,d7
  MOVE.l d0,d6
Return


.stringtores
  i.l = WZInput("RESIDENTS")
  a$ = Peek$(i)
  InitArgParse a$
  var.l = ?residents_table
  For i = 0 To 7
    p$ = NextArgChar$ ($a)
    Poke$ var,p$
    var + $44
  Next
Return


.storemaxobjects
  MOVE.w maxobject_pos,D5                                  ;max objects 1. visible
  LEA maxobjects_value,A3                                  ;current value
  MOVEA.l libpointer,A2

 JL_0_FFDAb:
  CMPA.w #$0,A2
  BEQ.w menu4c__igotb
  MOVEA.l A2,A1
  ADDA.l $12(A1),A1
  TST.w -$2(A1)
  BEQ.w JL_0_FFF6b
  SUBQ.w #1,D5
  BMI.w JL_0_FFFCb

 JL_0_FFF6b:
  MOVEA.l (A2),A2
BRA.w JL_0_FFDAb

 JL_0_FFFCb:
  MOVE.w (A3),-$4(A1)

 menu4c__igotb
RTS


.do_LastRunErrsMode:
  MOVE.w debugnest,d0
  LEA storedebugmode, a0
  MOVE.b 0(a0,d0.w),debugmode
  TST.w debugnest
  BEQ JUMP_unpairrunerrs
  SUBQ.w #1,debugnest
RTS

 JUMP_runerrsoverflow
JMP runerrsoverflow

 JUMP_unpairrunerrs
JMP unpairrunerrs


.toggledebug:
  BCHG #$7,use_debugger

  BTST #$7,use_debugger
  BNE 'debugon
  CLR.w debugmode
BRA.b 'debugoff

 'debugon
  SNE debugmode

 'debugoff
  MOVE.l a0,-(a7)
;  MOVE.l comdata,a0
;  MOVE.b debugmode,$7ee(a0)
  !ComData_SetB{comByte_DebugMode,debugmode}

;  !basic
;  !cout{Peek.b(?debugmode)}
;  !asm
  MOVE.l (a7)+,a0
RTS



.do_runerrson:
  BTST #$7,use_debugger
  BNE 'debugon
  CLR.w debugmode
BRA.b 'debugoff

 'debugon
  SNE debugmode

 'debugoff
RTS


.do_runerrsoff:
  ADDQ.w #1,debugnest
  MOVE.w debugnest,d0
  CMP.w #18,d0
   BGE JUMP_runerrsoverflow
  LEA storedebugmode, a0
  MOVE.b debugmode,0( a0,d0.w)

 'l1
  SF debugmode
RTS


usedpath:  Ds.l 32


.do_USEPATH:
  BEQ.w JUMP_syntaxerr
  LEA lastpath,A0
  MOVEM.l a0-a1/d0,-(a7)
  LEA lastpath2,a1

 'l2
    MOVE.b (a0)+,(a1)+
  BNE 'l2
  MOVEM.l (a7)+,a0-a1/d0
  LEA usedpath(PC),A0
  MOVEM.l a0-a1/d0,-(a7)
  LEA lastpath,a1

 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1
  MOVEM.l (a7)+,a0-a1/d0

 JL_0_4AA8:
  TST.w D0
   BMI.w JUMP_syntaxerr
  MOVE.b D0,(A0)+
  BSR.w JUMP_get1bytemain
   BNE.w JL_0_4AA8
  MOVE.b #$2,(A0)
RTS


.do_usepath2:
  BEQ.w JUMP_syntaxerr
  LEA path2,A0
;  MOVEM.l a0-a1/d0,-(a7)
;  LEA lastpath,a1

; 'l1
;  MOVE.b (a0)+,(a1)+
;  BNE 'l1
;  MOVEM.l (a7)+,a0-a1/d0

 JL_0_4AA8b:
  TST.w D0
   BMI.w JUMP_syntaxerr
  MOVE.b D0,(A0)+
  BSR.w JUMP_get1bytemain
   BNE.w JL_0_4AA8b
  MOVE.b #$2,(A0)
RTS

; JUMP_runerrsoverflow_2:                                  ;deactivaed because double
;JMP runerrsoverflow

; JUMP_syntaxerr_3:                                          ;deactivaed because double
;JMP syntaxerr

 JUMP_errormsg_reg:
JMP errormsg_reg


.do_regsave:
  MOVE.l #$f22d6780,fpucodeglobal
  MOVE.l #$f22c6780,fpucodelocal
  LEA regtable,a0
  MOVE.l #7,maxregs

 'again
  MOVE.l (a0),d0
  BEQ 'e1
  CLR.l (a0)
  MOVE.w 4(a0),d0
  MOVE.l fpucodeglobal,fpucode
  TST.w 6(a0)
  BEQ 'glob
  MOVE.l fpucodelocal,fpucode

 'glob
  MOVE.l fpucode,d1
  JSR writelong
  SUB.l #$80,fpucodelocal
  SUB.l #$80,fpucodeglobal
  MOVE.w d0,d1
  JSR writeword
  ADDQ #8,a0
BRA 'again

 'e1
RTS


; JUMP_syntaxerr_4                                          ;??deactived because doubled??
;JMP syntaxerr

 JUMP_notypeerr2                                          ;??deactivaed becaus doubled??
JMP notypeerr

 JUMP_illtypeerr
JMP illtypeerr

.do_regload:
  MOVE.l #$f22d4780,fpucodeglobal
  MOVE.l #$f22c4780,fpucodelocal
  LEA regtable,a0
  TST.l (a0)
   BNE JUMP_errormsg_reg
  MOVE.l d7,-(a7)
  SUBQ.l #1,a5

 'l2
  JSR getparameter2
  BEQ.w 'nopar
  MOVE.w d0,lastchar
  JSR findvariable
  BNE 'islocal
  MOVE.l fpucodeglobal,fpucode
  MOVE.l #3,maxregs
  MOVEQ #0,d7

 'go
  CMP.l #newtype_float,$a(a2)                              ;is float type
   BEQ 'doit
  CMP.l #newtype_double,$a(a2)
   BNE JUMP_illtypeerr

 'doit
  LEA regtable,a0
  MOVEQ #0,d0

 'loop
  TST.l (a0)
   BEQ 'store
  ADDQ.l #4,d0
  ADDQ.l #8,a0
  CMP.l #16,d0
   BCS 'loop
  MOVE.l #2,maxregs
  CMP.l #20,d0
   BCS 'loop
  MOVE.l #1,maxregs
  CMP.l #24,d0
   BCS 'loop
JMP toovarerr

 'store
  TST.b fpu
   BEQ 'nofpu
  MOVE.l a2,(a0)
  MOVE.w 4(a2),4(a0)
  MOVE.w d7,6(a0)
  MOVE.l fpucode,d1
  SUB.l #$80,fpucodeglobal
  SUB.l #$80,fpucodelocal
  JSR writelong
  MOVE.w 4(a2),d1
  JSR writeword

 'nofpu
  MOVE.w lastchar,d0
  CMP.w #":",d0
   BEQ 'nopar
  TST.w d0
   BEQ 'nopar
  CMP.w #",",d0
  BNE JUMP_syntaxerr
BRA 'l2

 'nopar
   MOVE.l (a7)+,d7
RTS

 'islocal
  MOVEQ #1,d7
  MOVE.b #1,newvariable
  LEA firstlocal,a2
  JSR findvariable
  CLR.b newvariable
  CMP.l #-1,d0
  BEQ.w JUMP_notypeerr2
  MOVE.l fpucodelocal,fpucode
BRA 'go

 _extb                                                     ;020 instr extb
  CMP.b #".",d0
   BNE 'l1
  BSR JUMP_get1bytemain
  BSR JUMP_get1bytemain

 'l1
  ORI .b #$20,d0
  CMP.b #"d",d0
   BNE JUMP_illeaerr
  BSR JUMP_get1bytemain
  SUB.b #$30,d0
  CMP.b #$7,d0
   BGT JUMP_syntaxerr
  MOVE.w #$49c0,d1
  ADD.b d0,d1
  JSR writeword
  BSR JUMP_get1bytemain
RTS


.do_uselastpath
  LEA lastpath,a0
  LEA usedpath(PC),A1

 'l1:
    MOVE.b (a0)+,(a1)+
  BNE 'l1

  LEA lastpath2,a0
  LEA lastpath,A1

 'l2:
    MOVE.b (a0)+,(a1)+
  BNE 'l2
RTS


.do_Object:
  TST.b objectcount
  BEQ 'l2a
JMP macnesterr

 'l2a
  LEA devo,a0
  ADDQ.b #1,objectcount
  MOVEM.l a1/d2,-(a7)
  LEA ptr_parameterstore,a1

 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1

  MOVEQ #13,d2
  JSR findlabel2
  BNE 'd
  TST.l 8(a2)
  BEQ 'd
  SUBQ.b #1,objectcount
  MOVEM.l (a7)+,a1/d2
  JSR skiprest
  MOVE.b #1,developobject
RTS

 'd
  MOVEM.l (a7)+,a1/d2
  MOVE.b #1,resdisable

 'l2
  CLR.b developobject
JMP do_Macro
;RTS                                                        ;??looks like unneeded code??

 JUMP_illeaerr:
JMP illeaerr


.do_syntax
  CLR.b typecheck
  CLR.b declare
  CLR.b declare2
  SUB.b #$30,d0
  BTST #0,d0
  BEQ 'l1
  MOVE.b #1,declare

 'l1
  BTST #1,d0
  BEQ 'l2
  MOVE.b #1,declare2

 'l2
  BTST #2,d0
  BEQ 'l3
  MOVE.b #1,typecheck
'l3
  BSR.w JUMP_get1bytemain
RTS

 JUMP_get1bytemain:
JMP get1bytemain


.check_newconstants:
;  !regs2stack
  MOVE.l d2,-(a7)                                          ; D2 -> stack
  ADDQ #1,a5
  MOVE.l a5,-(a7)
  !basic
  MOVE.l (a7)+,d0 : _myD0.l = PutD0
  If _myD0
    newconst$ = UCase$(Peek.s(_myD0))
  Else
    error{"INTERNAL: invalid pointer in check_newconstants!"}
    nwconst$="xxx"
  End If
  condata$ =""
  Poke.b ?skip_bytes,0
  If Left$(newconst$,2) = "__"
    Select Mid$(newconst$,3,4)

     Case "DATE"
      Select Mid$(newconst$,3,6)
      Case "DATE__" : DateFormat 1 : Poke.b ?skip_bytes,8
      Case "DATE_G" : DateFormat 0 : Poke.b ?skip_bytes,12
      End Select
      i.l=SystemDate
      condata$ = Date$ (i)
      condata$ = Replace$(condata$,"/",".")

     Case "VER_"
      ; Version coded as : Majorversion Minorversion Patchlevel
      ;                    00           00           00
      actual_version.l = Peek.l(?versioninformation)
      actual_build.l   = Peek.l(?number_of_builds)

      Format ""
      Select Mid$(newconst$,3,9)

       Case "VER_MAJOR"
        condata$ = Str$(actual_version LSR 24)

       Case "VER_MINOR"
        condata$ = Str$((actual_version LSL 8) LSR 24)

       Case "VER_PATCH"
        condata$ = Str$((actual_version LSL 16) LSR 24 )

       Case "VER_BUILD"
        Format ""
        condata$ = Str$(actual_build)

       Default
        condata$ = "{unknown compiler constant}"

      End Select
      Format ""
      Poke.b ?skip_bytes,11

     Case "THIS"
      Select Mid$(newconst$,3,9)

       Case "THIS_FUNC"
        Poke.b ?skip_bytes,15
        If Peek.l(?currentfunction)<>0
          condata$ = Peek.s(Peek.l(?currentfunction) + 32 + #funcentry_extend + 1)
        Else
          condata$ = "GLOBAL"
        EndIf

       Case "THIS_INCL"
        Poke.b ?skip_bytes,14
        If Peek.l(?includetemp2)<>0
          condata$ = dos_FilePart{Peek$(?includetemp2)}
        EndIf

       Case "THIS_POIN"
        Poke.b ?skip_bytes,14
        If Peek.l(?currentfunction)<>0
          condata$ = Hex$(Peek.l(?currentfunction))
        EndIf

      End Select

     Case "CODE"
      Poke.b ?skip_bytes,10
      If Mid$(newconst$,3,8) = "CODELINE"
        condata$ = Str$(Peek.l(?globallinecount))
      EndIf

    End Select

  Else
    Select Left$(newconst$,1)

     Case "R"
      Poke.b ?skip_bytes,3
      For i = 1 To Vallong(Mid$(newconst$,2,2))
        condata$ = condata$ + Mid$(newconst$,4,1)
      Next

     Case "N"
      Poke.b ?skip_bytes,1
      condata$ = Chr$(10)

     Default
      char1.b = Peek.b(&newconst$)
      char2.b = Peek.b(&newconst$+1)
      nibble1.l = -1
      nibble2.l = -1

      If (char1>=@"0" AND char1<=@"9") Then nibble1 = char1-@"0"
      If (char2>=@"0" AND char2<=@"9") Then nibble2 = char2-@"0"

      If (char1>=@"a" AND char1<=@"f") Then nibble1 = char1-@"a" + 10
      If (char2>=@"a" AND char2<=@"f") Then nibble2 = char2-@"a" + 10

      If (char1>=@"A" AND char1<=@"F") Then nibble1 = char1-@"A" + 10
      If (char2>=@"A" AND char2<=@"F") Then nibble2 = char2-@"A" + 10

      If nibble1>=0 AND nibble2>=0
        newchar.l = (nibble1 LSL 4) + (nibble2)
        condata$ = Chr$(newchar)
        Poke.b ?skip_bytes,2
      EndIf

    End Select
  EndIf
  If condata$ = "" AND Peek.b(?skip_bytes)=0
    !cout{"detected unknown const: " + newconst$}
    condata$ = newconst$
  EndIf

  GetD0 FLen(condata$)-1                                    ; laenge zielstring -> Stack
  MOVE.l d0,d2
  MOVE.l d2,-(a7)

  GetD0 &condata$                                          ; kopieren des neuen Strings in den Zielstring
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
 DBF d2,'l1

  !asm
  MOVE.l (a7)+,d0                                          ; laenge Zielstring <- Stack
  MOVE.l (a7)+,d2                                          ; d2 <-Stack
  ADD.l d0,d2                                              ; eingefuegte chars zu D2 dazu
  ADD.l #1,d2

  MOVE.l #0,d0                                             ; a5 um konstantennamen weiterschieben
  MOVE.b skip_bytes,D0
  ADD.l D0,a5
RTS

;  CMP.l #"__DA",1(a5)
;   BEQ 'date
;
;  CMP.l #"__VE",1(a5)
;   BEQ 'versionstring
;
;  CMP.l #"__TH",1(a5)
;   BEQ 'functionname
;
;  CMP.l #"__CO",1(a5)
;   BEQ 'codeline
;
;  CMP.b #"R",1(a5)
;   BNE 'l21
;
;  ADDQ #1,a5
;  JSR get_hexbyte
;  SUBQ #1,d0
;  MOVE.b (a5),d1
;
; 'lr1
;    ADDQ #1,d2
;    BSR.w pokedata1b
;  DBF d0,'lr1
;
;  ADDQ.l #1,a5
;BRA writestring
;
; 'l21
;  CMP.b #"n",1(a5)
;   BNE 'l22
;  MOVEQ #$a,d0
;  ADDQ.l #2,a5
;BRA 'l1
;
;'l22
;  JSR get_hexbyte
;BRA 'l1
;
;'date
;  CMP.l #"TE__",5(a5)
;   BNE 'l1b
;  JSR compiledate
;BRA 'l1
;
; 'l1b
;  CMP.l #"TE_G",5(a5)
;   BNE 'l1
;  CMP.l #"ER__",9(a5)
;   BNE 'l1
;  JSR compiledate_ger
;BRA 'l1
;
; 'functionname
;  CMP.w #"IS",5(a5)
;   BNE 'l1
;  JSR insert_functionname
;BRA writestring
;
; 'codeline
;  CMP.w #"DE",5(a5)
;   BNE 'l1
;  JSR insert_codeline
;BRA 'l1
;
; 'versionstring
;  CMP.w #"R_",5(a5)
;   BNE 'l1
;  JSR version_string
;
;RTS



.internal_commands:
.tokens:
INCLUDE "internal_commands.ab2"
Even


.CIF_branches:                                             ;cifbras
           Dc.l cif_lt                                     ;ciflt
           Dc.l cif_eq                                     ;cifeq
           Dc.l cif_gt                                     ;cifgt
           Ds.l 1                                          ;0
           Dc.l cif_le                                     ;cifle
           Dc.l cif_ne                                     ;cifne
           Dc.l cif_le                                     ;cifge
           Ds.l 1                                          ;0
           Dc.l cif_ge                                     ;cifge
           Dc.l cif_ne                                     ;cifne
           Dc.l cif_ge                                     ;cifge
           Ds.l 1                                          ;0

instructionbase:                                                     ;atokens org sourcs
           Dc.l do_newtype                                 ;donewtype
           Dc.l do_end                                     ;doend
           Dc.l do_let                                     ;dolet
           Dc.l do_dim                                     ;dodim
           Dc.l do_goto                                    ;dogoto
           Dc.l do_gosub                                   ;dogosub
           Dc.l do_return                                  ;doreturn
           Dc.l do_statement                               ;dostatement
           Dc.l do_function                                ;dofunc
           Dc.l do_mousewait                               ;domwait
           Dc.l do_if                                      ;doif
           Dc.l do_while                                   ;dowhile
           Dc.l do_Macro                                   ;domacro
           Dc.l do_select                                  ;doselect
           Dc.l do_case                                    ;docase
           Dc.l do_default                                 ;dodefault
           Dc.l do_AsmExit                                 ;doasmexit
           Dc.l do_xinclude                                ;doxinclude
           Dc.l do_INCLUDE                                 ;doinclude
           Dc.l do_syntax                                  ;syntaxerr
           Dc.l do_shared                                  ;doshared
           Dc.l do_for                                     ;dofor
           Dc.l do_next                                    ;donext
           Dc.l syntaxerr                                  ; To
           Dc.l syntaxerr                                  ; Step
           Dc.l do_data                                    ;dodata
           Dc.l do_read                                    ;doread

; --
; -- the following should all be intercepted by getchar
           Dc.l syntaxerr                                  ; CNIF
           Dc.l syntaxerr                                  ; CSIF
           Dc.l syntaxerr                                  ; CELSE
           Dc.l syntaxerr                                  ; CEND
           Dc.l do_cerr                                    ;docerr
           Dc.l do_then                                    ;dothen
           Dc.l do_else                                    ;doelse
           Dc.l do_even4                                   ;doeven4
           Dc.l do_even8                                   ;doeven8
;
           Dc.l do_dc                                      ;dodc
           Dc.l do_ds                                      ;dods
           Dc.l do_even                                    ;doeven
           Dc.l do_dcb                                     ;dodcb
           Dc.l do_setreg                                  ;dosetreg
           Dc.l do_IncBin                                  ;doincbin
           Dc.l do_free                                    ;dofree
           Dc.l do_use                                     ;douse
           Dc.l do_Stop                                    ;dostop
           Dc.l do_Cont                                    ;docont
           Dc.l syntaxerr                                  ;syntaxeer
           Dc.l do_SetInt                                  ;dosetint
           Dc.l do_ClrInt                                  ;doclrint
           Dc.l do_MaxLen                                  ;domaxlen
           Dc.l do_DEFTYPE                                 ;dodeftype
           Dc.l do_BLITZ                                   ;doblitz
           Dc.l do_AMIGA                                   ;doamiga
           Dc.l do_QAMIGA                                  ;doqamiga
           Dc.l do_VWait                                   ;dovwait
           Dc.l do_LibJsr                                  ;dolibjsr
           Dc.l do_TokeJsr                                 ;dotokejsr
           Dc.l do_BLibJsr                                 ;doblibjsr
           Dc.l _extb                                      ;syntaxerr
    ;
    ;A break goes in here for the assembler stuff!
    ;
           Dc.l syntaxerr                                  ;syntaxerr      ;flash2 ; for list
           Dc.l do_SetErr                                  ;doseterr
           Dc.l do_ClrErr                                  ;doclrerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l do_ErrFail                                 ;doerrfail
           Dc.l syntaxerr
           Dc.l syntaxerr                                  ;mod
           Dc.l syntaxerr                                  ;Pi
           Dc.l do_Repeat                                  ;dorepeat
           Dc.l do_Until                                   ;dountil
           Dc.l do_PutReg                                  ;doputreg
           Dc.l do_Pop                                     ;dopop
           Dc.l do_INCDIR                                  ;doincdir
           Dc.l mydo_Endif2                                ;mydoendif2
           Dc.l do_Wend                                    ;dowend
           Dc.l do_SysJsr                                  ;dosysjsr
           Dc.l do_WBStartup                               ;dowbstartup
           Dc.l syntaxerr
           Dc.l do_Ongo                                    ;doongo
           Dc.l syntaxerr
           Dc.l do_Forever                                 ;doforever
           Dc.l do_Restore                                 ;dorestore
           Dc.l do_Exchange                                ;doexchange
           Dc.l do_USEPATH                                 ;dousepath
           Dc.l do_CloseEd                                 ;doclosed
           Dc.l do_NoCli                                   ;donocli
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l do_runerrson                               ;dorunerrson
           Dc.l do_runerrsoff                              ;dorunerrsoff
           Dc.l do_uselastpath
           Dc.l do_regload
           Dc.l do_regsave
           Dc.l do_Object
           Dc.l do_usepath2
           Dc.l do_LastRunErrsMode
atokensend:

;.compilermenu_entries:
;   Dc.b "COMPILER",0
;   Dc.b "COMPILE AND RUN        ",0,"X"
;   Dc.b "RUN                    ",0,"M"
;   Dc.b "CREATE EXECUTABLE      ",0,"E"
;   Dc.b "COMPILER OPTIONS       ",0,"O"
;   Dc.b "CREATE RESIDENT        ",0,";"
;   Dc.b "VIEW NEWTYPES          ",0,"-"
;   Dc.b "CLI ARGUMENT           ",0,"="
;   Dc.b "CALCULATOR             ",0,"H"
;   Dc.b "RELOAD ALL LIBS        ",0,"\"
;   Dc.b "LOAD DEBUG MODULE      ",0,"."
;   ifeq    final
;    Dc.b "PRINT TOKENS"          ",0,0
;   endc
;   Dc.b    0
;   Even



menu_items:Dc.l menu_compile_run                                ;menuadds oreg source
           Dc.l menu_run
           Dc.l menu_createexecutable
           Dc.l menu_compileroptions
           Dc.l menu_createresidentfile
           Dc.l menu_viewnewtypes
           Dc.l menu_simcliarguments
           Dc.l menu_calculator
           Dc.l menu_reloadlibs
           Dc.l menu_loaddebugmodule
           Dc.l menu_dummyfunc
           Dc.l menu_newcreate
           Dc.l menu_dummyfunc
           Dc.l toggledebug
           Dc.l menu_dummyfunc
           Dc.l menu_dummyfunc
Even4


menu_dummyfunc:
!basic
error{"Inavlid amiblitz3 menu item called!"}
!asm
RTS



; --
; -- configuration data for debugger
set_autorun:               Dc.b $00
autorun:                   Dc.b $80,$01,$01,$00,$01

set_interruptcheck:        Dc.b $00
interruptcheck             Dc.b $80,$01,$01,$00,$01

set_assemblercheck:        Ds.b 1
assemblercheck:            Dc.b $00,$01,$01,$00,$01

set_overflowcheck:         Ds.b 1
overflowcheck:             Dc.b $00,$01,$01,$00,$01

default_obsolete:          Dc.b $00,$80,$01,$01,$00,$01
default_interruptcheck:    Dc.b $00,$80,$01,$01,$00,$01
default_overflowcheck:     Dc.b $00,$80,$01,$01,$00,$01
Even4


tsthead:                   Dc.l $000003F3,$00000000,$00000001
                           Dc.l $00000000,$00000000
tstsize1:                  Dc.l $00000100,$000003E9
tstsize2:                  Dc.l $00000100
tstend:                    Dc.l $000003EC
tstsize3:                  Ds.l 2
tstdone:                   Dc.l $000003F2


edstruct:                  Dc.l tokens                     ;data for ted


;                          Dc.l compilermenu_entries
                           Dc.l 0

                           Dc.l read_xtrafile              ;load .xtra routine
                           Dc.l write_xtrafile             ;save .xtra routine
                           Dc.l call_menuentry             ;Menu Routine
                           Ds.l 1                          ;cleanup (?)
                           Dc.b ":",34,".;"
Even4

asmpnts:                   Ds.l 63                                                  ;Ds.l tnum-fnum org source  hat was mit tok zu tun
                           Ds.l 56

;------                                                                             ;disassembled code begin
.objects ;some object codes for compile

lslimm:                    Dc.b $E1,$48                                             ;LSL.W   #8,D0


use:                       Dc.b $26,$6D,$00,$00                                     ;MOVEA.L $0000(A5),A3
                           Dc.b $D6,$C0                                             ;ADDA.W  D0,A3
                           Dc.b $2B,$4B,$00,$00                                     ;MOVE.L  A3,$0000(A5)
usef:                      ;


beginarr:                  Dc.b $20,$3C,$00,$00,$00,$00                             ;MOVE.L  #$00000000,D0


;mularr:                   ;??looks like not used??
                           Dc.b $C0,$C1                                             ;MULU.W  D1,D0


putarr:                    Dc.b $2B,$40 :                            Dc.b $00,$00   ;MOVE.L  D0,$0000(A5)


doarr:                     Dc.b $34,$3C,$00,$00                                     ;MOVE.W  #$0000,D2
                           Dc.b $36,$3C,$00,$00                                     ;MOVE.W  #$0000,D3

;doarrf:                   ;??looks like not used??


;tstword:                  ;??looks like not used??
                           Dc.b $4A,$40                                             ;TST.W   D0


;tstlong:                  ;??looks like not used??
                           Dc.b $4A,$80                                             ;TST.L   D0


nops8:                     Dc.b $4E,$71                                             ;NOP
                           Dc.b $4E,$71                                             ;NOP
                           Dc.b $4E,$71                                             ;NOP
                           Dc.b $4E,$71                                             ;NOP
nops4:                     Dc.b $4E,$71                                             ;NOP
;nops3:                    ;??looks like not used??
                           Dc.b $4E,$71                                             ;NOP
                           Dc.b $4E,$71                                             ;NOP
                           Dc.b $4E,$71                                             ;NOP
nopsf:


dataget:                   Dc.b $26,$6D :                            Dc.b $00,$00   ;MOVEA.L $0000(A5),A3


dataput:                   Dc.b $2B,$4B :                            Dc.b $00,$00   ;MOVE.L  A3,$0000(A5)


stlenget:                  Dc.b $2F,$1B                                             ;MOVE.L  (A3)+,-(A7)


stalign:                   Dc.b $52,$4B                                             ;ADDQ.W  #1,A3
                           Dc.b $C1,$8B                                             ;EXG D0,A3
                           Dc.b $08,$80,$00,$00                                     ;BCLR    #0,D0
                           Dc.b $C1,$8B                                             ;EXG D0,A3
stalignf:


    ;byte...
    ;
dataletb:                  Dc.b $52,$4B                                             ;ADDQ.W  #1,A3
                           Dc.b $1B,$5B,$00,$00                                     ;MOVE.B  (A3)+,$0000(A5)
dataletbf:



dataletbl:                 Dc.b $52,$4B                                             ;ADDQ.W  #1,A3
                           Dc.b $19,$5B,$00,$00                                     ;MOVE.B  (A3)+,$0000(A4)
dataletblf:


dataletb2:                 Dc.b $52,$4B                                             ;ADDQ.W  #1,A3
                           Dc.b $14,$9B                                             ;MOVE.B  (A3)+,(A2)
dataletb2f:


    ;word...
    ;
dataletw:                  Dc.b $3B,$5B,$00,$00                                     ;MOVE.W  (A3)+,$0000(A5)
                           Dc.b $34,$9B                                             ;MOVE.W  (A3)+,(A2)
                           Dc.b $39,$5B,$00,$00                                     ;MOVE.W  (A3)+,$0000(A4)


    ;long...
dataletl:                  Dc.b $2B,$5B,$00,$00                                     ;MOVE.L  (A3)+,$0000(A5)
                           Dc.b $24,$9B                                             ;MOVE.L  (A3)+,(A2)
                           Dc.b $29,$5B,$00,$00                                     ;MOVE.L  (A3)+,$0000(A4)


nextfixw:                  Dc.b $50,$4F                                             ;ADDQ.W  #8,A7


nextfixw2:                 Dc.b $4F,$EF,$00,$0A                                     ;LEA $000A(A7),A7


nextfixl:                  Dc.b $4F,$EF,$00,$0C                                     ;LEA $000C(A7),A7


nextfixl2:                 Dc.b $4F,$EF,$00,$0E                                     ;LEA $000E(A7),A7


nextb:                     ;
                           Dc.b $24,$6F,$00,$04                                     ;MOVEA.L $0004(A7),A2
                           Dc.b $30,$17                                             ;MOVE.W  (A7),D0
                           Dc.b $D1,$12                                             ;ADD.B   D0,(A2)
nextbf:


nextw:                     ;a word type next
                           Dc.b $24,$6F,$00,$04                                     ;MOVEA.L $0004(A7),A2
                           Dc.b $30,$17                                             ;MOVE.W  (A7),D0
                           Dc.b $D1,$52                                             ;ADD.W   D0,(A2)
nextwf:                    ;


nextl:                     ;
                           Dc.b $24,$6F,$00,$08                                     ;MOVEA.L $0008(A7),A2
                           Dc.b $20,$17                                             ;MOVE.L  (A7),D0
                           Dc.b $D1,$92                                             ;ADD.L   D0,(A2)
nextlf:


nextf:                     ;
                           Dc.b $24,$6F,$00,$08                                     ;MOVEA.L $0008(A7),A2
                           Dc.b $20,$12                                             ;MOVE.L  (A2),D0
                           Dc.b $22,$17                                             ;MOVE.L  (A7),D1
                           Dc.b $4E,$AE,$FF,$BE                                     ;JSR -$0042(A6)
                           Dc.b $24,$80                                             ;MOVE.L  D0,(A2)
nextff                     ;


forcompb:                  ;
                           Dc.b $24,$6F,$00,$04                                     ;MOVEA.L $0004(A7),A2
                           Dc.b $10,$12                                             ;MOVE.B  (A2),D0
                           Dc.b $32,$2F,$00,$02                                     ;MOVE.W  $0002(A7),D1
                           Dc.b $4A,$57                                             ;TST.W   (A7)
                           Dc.b $6A,$00,$00,$04                                     ;BPL.W   L000001         ;.skip org source
                           Dc.b $C1,$41                                             ;EXG D0,D1

                                                                                  ;L000001:                  ;.skip org source
                           Dc.b $B0,$01                                             ;CMP.B   D1,D0
forcompbf:                 ;


forcompw:                  ;the For...Next Compare..... for words
                           Dc.b $24,$6F,$00,$04                                     ;MOVEA.L $0004(A7),A2
                           Dc.b $30,$12                                             ;MOVE.W  (A2),D0
                           Dc.b $32,$2F,$00,$02                                     ;MOVE.W  $0002(A7),D1
                           Dc.b $4A,$57                                             ;TST.W   (A7)
                           Dc.b $6A,$00,$00,$04                                     ;BPL.W   L000002         ;.skip org source
                           Dc.b $C1,$41                                             ;EXG D0,D1

                                                                                  ;L000002:                  ;.skip org source
                           Dc.b $B0,$41                                             ;CMP.W   D1,D0
forcompwf:                 ;


forcompl:                  ;
                           Dc.b $24,$6F,$00,$08                                     ;MOVEA.L $0008(A7),A2
                           Dc.b $20,$12                                             ;MOVE.L  (A2),D0
                           Dc.b $22,$2F,$00,$04                                     ;MOVE.L  $0004(A7),D1
                           Dc.b $4A,$57                                             ;TST.W   (A7)
                           Dc.b $6A,$00,$00,$04                                     ;BPL.W   L000003         ;.skip org source
                           Dc.b $C1,$41                                             ;EXG D0,D1

                                                                                  ;L000003:                  ;.skip org source
                           Dc.b $B0,$81                                             ;CMP.L   D1,D0
forcomplf:


forcompf:                  ;floating point for/next compare.....
                           Dc.b $24,$6F,$00,$08                                     ;MOVEA.L $0008(A7),A2
                           Dc.b $20,$12                                             ;MOVE.L  (A2),D0
                           Dc.b $22,$2F,$00,$04                                     ;MOVE.L  $0004(A7),D1
                           Dc.b $08,$2F,$00,$07,$00,$03                             ;BTST    #7,$0003(A7)
                           Dc.b $67,$00,$00,$04                                     ;BEQ.W   L000004
                           Dc.b $C1,$41                                             ;EXG D0,D1

                                                                                  ;L000004:
forcompff:                 ;


forcompf2:                 ;continuation
                           Dc.b $4E,$AE,$FF,$D6                                     ;JSR -$002A(A6)
forcompf2f:                ;


swapd0:                    Dc.b $48,$40                                             ;SWAP    D0


pushindex:                 Dc.b $2F,$0A                                             ;MOVE.L  A2,-(A7)


leaamp:                    Dc.b $45,$ED :                            Dc.b $00,$00   ;LEA $0000(A5),A2
leaamp2:                   Dc.b $20,$0A                                             ;MOVE.L  A2,D0


leaampl:                   Dc.b $45,$EC :                            Dc.b $00,$00   ;LEA $0000(A4),A2


stamp:                     Dc.b $20,$12                                             ;MOVE.L  (A2),D0


stamp2:                    Dc.b $24,$6D :                            Dc.b $00,$00   ;MOVEA.L $0000(A5),A2


stol:                      ;lose string len!
                           Dc.b $58,$4F                                             ;ADDQ.W  #4,A7


pushd0wd:                  Dc.b $3F,$00                                             ;MOVE.W  D0,-(A7)


pushd0l:                   Dc.b $2F,$00                                             ;MOVE.L  D0,-(A7)


movenumrep:                Dc.b $3E,$3C :                            Dc.b $00,$00   ;MOVE.W  #$0000,D7


preplibst:                 Dc.b $45,$EF :                            Dc.b $00,$00   ;LEA $0000(A7),A2


fixlibst:                  Dc.b $4F,$EF :                            Dc.b $00,$00   ;LEA $0000(A7),A7


pushdn:                    Dc.b $2F,$00                                             ;MOVE.L  D0,-(A7)


movea3a7:                  Dc.b $2F,$0B                                             ;MOVE.L  A3,-(A7)


movestst2:                 Dc.b $20,$2F :                            Dc.b $00,$06   ;MOVE.L  $0006(A7),D0
                           Dc.b $3F,$6F,$00,$04,$00,$08                             ;MOVE.W  $0004(A7),$0008(A7)
                           Dc.b $2E,$9F                                             ;MOVE.L  (A7)+,(A7)
movestst2f:


movea7dn:                  Dc.b $20,$2F :                            Dc.b $00,$04   ;MOVE.L  $0004(A7),D0
                           Dc.b $2E,$9F                                             ;MOVE.L  (A7)+,(A7)
;movea7dnf:                ;??looks like not used??


moved0a3:                  Dc.b $26,$40                                             ;MOVEA.L D0,A3


movestdn:                  Dc.b $20,$2D :                            Dc.b $00,$00   ;MOVE.L  $0000(A5),D0


;movea3dn:                 ;??looks like not used??
                           Dc.b $20,$0B                                             ;MOVE.L  A3,D0


putstlen:                  ;push string length
                           Dc.b $2F,$00                                             ;MOVE.L  D0,-(A7)


getstlen:                  ;pop string length
                           Dc.b $20,$1F                                             ;MOVE.L  (A7)+,D0


moverts:                   Dc.b $2F,$57 :                            Dc.b $00,$00   ;MOVE.L  (A7),$0000(A7)


fixstack:                  Dc.b $4F,$EF :                            Dc.b $00,$00   ;LEA $0000(A7),A7


fixq:                      Dc.b $50,$4F                                             ;ADDQ.W  #8,A7


fix1:                      Dc.b $2E,$9F                                             ;MOVE.L  (A7)+,(A7)


movedna3:                  Dc.b $26,$40                                             ;MOVEA.L D0,A3


least:                     Dc.b $45,$EC :                            Dc.b $00,$00   ;LEA $0000(A4),A2


funcst:                    Dc.b $2F,$2C :                            Dc.b $00,$00   ;MOVE.L  $0000(A4),-(A7)


addq4a2:                   Dc.b $58,$4A                                             ;ADDQ.W  #4,A2


;savesbase:                ;??looks like not used??
                           Dc.b $2F,$0B                                             ;MOVE.L  A3,-(A7)

;savesbase2:               ;??looks like not used??
                           Dc.b $2B,$4B,$00,$00                                     ;MOVE.L  A3,$0000(A5)

;savesbasef:               ;??looks like not used??


;ressbase                  ;??looks like not used??
                           Dc.b $26,$5F                                             ;MOVEA.L (A7)+,A3

;ressbase2                 ;??looks like not used??
                           Dc.b $2B,$4B,$00,$00                                     ;MOVE.L  A3,$0000(A5)

;ressbasef                 ;??looks like not used??


;exga4a5                   ;??looks like not used??
                           Dc.b $CB,$4C                                             ;EXG A5,A4


;linka4 ;org source
linksize:                  Dc.b $4E,$54 :                            Dc.b $00,$00   ;LINK    A4,#-$0000


unlinka4:                  Dc.b $4E,$5C                                             ;UNLK    A4


;a2toa7                    ;??looks like not used??
                           Dc.b $2F,$0A                                             ;MOVE.L  A2,-(A7)


;a7toa2                    ;??looks like not used??
                           Dc.b $24,$5F                                             ;MOVEA.L (A7)+,A2


gotocode:                  Dc.b $4E,$F9,$00,$00,$00,$00                             ;JMP $00000000


gosubcode:                 Dc.b $4E,$B9,$00,$00,$00,$00                             ;JSR $00000000

                                                                                  ;L000005:                ;mwait: org source

mwait:                     Dc.b $08,$39,$00,$06,$00,$BF,$E0,$01                     ;BTST    #6,$00BFE001
                           Dc.b $66,$00,$FF,$F6                                     ;BNE.W   L000005       ;mwait: org source
mwaitf:


libreg:                    Dc.b $20,$00                                             ;MOVE.L  D0,D0


libbase:                   Dc.b $2C,$6D :                            Dc.b $00,$00   ;MOVEA.L $0000(A5),A6


libjsr:                    Dc.b $4E,$AE :                            Dc.b $00,$00   ;JSR $0000(A6)


regtransd:                 Dc.b $20,$2D,$00,$00                                     ;MOVE.L  $0000(A5),D0
regtransa:                 Dc.b $20,$6D,$00,$00                                     ;MOVEA.L $0000(A5),A0


;litget                    ;??looks like not used??
                           Dc.b $26,$7C,$00,$00                                     ;MOVEA.L #$00000000,A3
;litget2                   ;??looks like not used??
                           Dc.l $3F1B                                               ;MOVE.W  (A3)+,-(A7)


movea2dn:                  Dc.b $20,$12                                             ;MOVE.L  (A2),D0


moved3a5dn:                Dc.b $20,$2D,$00,$00                                     ;MOVE.L  $0000(A5),D0


stvarget2:                 Dc.b $70,$00                                             ;MOVEQ   #$00,D0
                           Dc.b $2F,$00                                             ;MOVE.L  D0,-(A7)
                           Dc.b $4A,$92                                             ;TST.L   (A2)
                           Dc.b $67,$00,$00,$0E                                     ;BEQ.W   L000006        ;varget2skip org source
                           Dc.b $20,$52                                             ;MOVEA.L (A2),A0
                           Dc.b $59,$48                                             ;SUBQ.W  #4,A0
                           Dc.b $2E,$98                                             ;MOVE.L  (A0)+,(A7)
stvarget2f:                ;
                           Dc.b $4E,$B9,$00,$00,$00,$00                             ;JSR $00000000
                           ;
varget2skip:               ;                                                      ;L000006:                 ;varget2skip org source


addcode:                   Dc.b $20,$1F                                             ;MOVE.L  (A7)+,D0
                           Dc.b $D1,$97                                             ;ADD.L   D0,(A7)
;addcodef                  ;??looks like not used??


pushlen:                   Dc.b $2F,$18                                             ;MOVE.L  (A0)+,-(A7)


leaa5d3a2:                 Dc.b $45,$ED :                            Dc.b $00,$00   ;LEA $0000(A5),A2


pusha2:                    Dc.b $2F,$0A                                             ;MOVE.L  A2,-(A7)


;geta2                     ;??looks like not used??
                           Dc.b $24,$57                                             ;MOVEA.L (A7),A2


pulla2:                    Dc.b $24,$5F                                             ;MOVEA.L (A7)+,A2


pulla2st:                  Dc.b $24,$6F,$00,$04                                     ;MOVEA.L $0004(A7),A2
                           Dc.b $2E,$9F                                             ;MOVE.L  (A7)+,(A7)
pulla2stf:                 ;


pusha3:                    Dc.b $2F,$2D :                            Dc.b $00,$00   ;MOVE.L  $0000(A5),-(A7)
pusha32:                   Dc.b $2B,$4B :                            Dc.b $00,$00   ;MOVE.L  A3,$0000(A5)
pusha3f:


pulla3:                    Dc.b $2B,$5F :                            Dc.b $00,$00   ;MOVE.L  (A7)+,$0000(A5)
pulla3f:


geta3:                     Dc.b $26,$6D :                            Dc.b $00,$00   ;MOVEA.L $0000(A5),A3
geta3f:


numtoa0:                   Dc.b $20,$7C,$00,$00,$00,$00                             ;MOVEA.L #$00000000,A0


numtoa2:                   Dc.b $24,$7C,$00,$00,$00,$00                             ;MOVEA.L #$00000000,A2


                           ;free up all arrays code
endarray:                  Dc.b $38,$3C :                            Dc.b $00,$00   ;MOVE.W  #$0000,D4


;preparray                 ;??looks like not used??
                           Dc.b $34,$3C,$00,$00                                     ;MOVE.W  #$0000,D2
                           Dc.b $36,$3C,$00,$00                                     ;MOVE.W  #$0000,D3
;preparrayf                ;??looks like not used??


;dimbegin:                 ;??looks like not used??
                           Dc.b $20,$3C,$00,$00,$00,$04                             ;MOVE.L  #$00000004,D0
;dimbeginf:                ;??looks like not used??


;dimb4:                    ;??looks like not used??
                           Dc.b $2B,$40,$00,$00                                     ;MOVE.L  D0,$0000(A5)
;dimb4f:                   ;??looks like not used??


;dimaf:                    ;??looks like not used??
                           Dc.b $C0,$C1                                             ;MULU.W  D1,D0
;dimaff:                   ;??looks like not used??

;dimfin:                   ;??looks like not used??
                           Dc.b $2B,$40,$00,$00                                     ;MOVE.L  D0,$0000(A5)
;dimfinf:                  ;??looks like not used??


movea0:                    Dc.b $24,$52                                             ;MOVEA.L (A2),A2


adda0a0:                   Dc.b $D5,$CA                                             ;ADDA.L  A2,A2
                           Dc.b $D5,$CA                                             ;ADDA.L  A2,A2


;getebase:                 ;??looks like not used??
                           Dc.b $2C,$78,$00,$04                                     ;MOVEA.L $0004,A6
;getebasef:                ;??looks like not used??


movea5a0:                  Dc.b $24,$6D :                            Dc.b $00,$00   ;MOVEA.L $0000(A5),A2


movea0a0:                  Dc.b $24,$6A :                            Dc.b $00,$00   ;MOVEA.L $0000(A2),A2


addqa0:                    Dc.b $52,$4A                                             ;ADDQ.W  #1,A2


leaa0a0:                   Dc.b $45,$EA :                            Dc.b $00,$00   ;LEA $0000(A2),A2


addrega2:                  Dc.b $D4,$C0                                             ;ADDA.W  D0,A2

;------                                                                           ;disassembled code end
;tstname:                  ;??looks like not used??
                           Dc.b "ram:test",0
Even

;-----------end of object codes!--------------;
;memat:                    ;??looks like not used??
                           Dc.l  0                          ;was  Ds.w 3 org source
;memlen:                   ;??looks like not used??
                           Dc.w  0

.memstackf:   ;
_mathffpbase:              Ds.l 1                           ;maths org source
regnum:                    Ds.w 1                           ;regat org source       ;register being used!
typelen:                   Ds.w 1
prevtype:                  Ds.l 1
lastsourcepos:             Ds.l 1                           ;prevloc org source
lastchar:                  Ds.w 1
thistype:                  Ds.l 1
errstack:                  Ds.l 1
errcont:                   Ds.l 1
linemode:                  Ds.w 1                          ;0 if norm, 1 if newtype
linesleft:                 Ds.w 1
sourceline:                Ds.l 1                          ;thisitem org source
varbase:                   Ds.l 1                          ;firstvar org source
alllocals:                 Ds.l 1
firstlocal:                Ds.l 1
firstglob:                 Ds.l 1
globalvarpointer:          Ds.w 1                          ;varoff org source
locvaroff:                 Ds.w 1
firstitem_:                 Ds.l 1
numlines_org:              Ds.w 1                          ;numlines org source
returncode_org:            Ds.w 1                          ;returncode org source
firstiff:                  Ds.l 1                          ;firstif org source
ptr_seg_ped:               Ds.l 1                          ;segadd org source
str_pedfile:               Ds.b #MAX_STRINGSIZE            ;segname org source
str_mathffpname:           Dc.b "mathffp.library",0 : Even ;mathsname org source
str_libfilename:           Ds.b #MAX_STRINGSIZE
str_path_userlibs:         Ds.b #MAX_STRINGSIZE
str_defaultdbug:           Ds.b #MAX_STRINGSIZE            ;debugname org source

ptr_seg_debugger:          Ds.l 1                          ;dseg org source
str_blitz3assign:          Ds.b #MAX_STRINGSIZE            ;dpath org source

str_path_acidlibs:         Ds.b #MAX_STRINGSIZE            ;acidname org source
size_acidlibs:             Ds.l 1                          ;acidlibs org source
str_path_deflibs:          Ds.b #MAX_STRINGSIZE            ;defname org source
size_deflibs:              Ds.l 1                          ;deflibs org source
str_tempfilename:          Ds.b #MAX_STRINGSIZE

str_temp_debugmodulename:  Ds.b #MAX_STRINGSIZE            ;dname org source
ptr_temp_debugmodule:      Ds.l 1                          ;dname2 org source

str_path_includes:         Ds.b #MAX_STRINGSIZE            ;acidname org source

Even


.icongfx_data:                                             ;objicon org sourcename
  Dc.b $E3,$10,$00,$01                                     ;icondata  
  Dc.b $00,$00,$00,$00
  Dc.b $00,$19,$00,$11
  Dc.b $00,$2E,$00,$18
  Dc.b $00,$04,$00,$03
  Dc.b $00,$01,$00,$22
  Dc.b $73,$68,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $03,$22,$00,$21
  Dc.b $3C,$28,$00,$22
  Dc.b $6E,$C0,$00,$00
  Dc.b $00,$12,$00,$00
  Dc.b $00,$0E,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$2E
  Dc.b $00,$17,$00,$02
  Dc.b $00,$01,$8E,$80
  Dc.b $03,$00,$00,$00
  Dc.b $00,$00,$FF,$FF
  Dc.b $FF,$FF,$FF,$FC
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$3F,$BB,$40
  Dc.b $80,$1F,$C0,$00
  Dc.b $00,$00,$80,$3F
  Dc.b $C0,$0F,$BB,$40
  Dc.b $80,$1F,$C0,$00
  Dc.b $00,$00,$8E,$00
  Dc.b $F8,$00,$00,$00
  Dc.b $8F,$01,$FF,$00
  Dc.b $3B,$40,$81,$E3
  Dc.b $F7,$C0,$00,$00
  Dc.b $80,$7F,$F8,$70
  Dc.b $3B,$40,$80,$0F
  Dc.b $7C,$E0,$00,$00
  Dc.b $80,$00,$FD,$80
  Dc.b $00,$00,$80,$01
  Dc.b $F6,$00,$FB,$40
  Dc.b $80,$03,$EF,$00
  Dc.b $00,$00,$80,$07
  Dc.b $87,$80,$3B,$40
  Dc.b $80,$0F,$01,$C0
  Dc.b $00,$00,$80,$03
  Dc.b $F0,$70,$1D,$40
  Dc.b $80,$00,$18,$1C
  Dc.b $00,$00,$80,$00
  Dc.b $10,$06,$03,$40
  Dc.b $80,$00,$20,$1F
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$01,$40
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$3F,$FC,$01
  Dc.b $BB,$44,$00,$60
  Dc.b $FE,$00,$00,$04
  Dc.b $00,$CF,$FF,$01
  Dc.b $BB,$44,$1F,$EF
  Dc.b $FF,$00,$00,$04
  Dc.b $33,$FF,$FF,$E0
  Dc.b $00,$04,$37,$FE
  Dc.b $7F,$FC,$1B,$44
  Dc.b $0F,$9C,$FF,$FF
  Dc.b $00,$04,$03,$E3
  Dc.b $FF,$FF,$DB,$44
  Dc.b $00,$7F,$BF,$FF
  Dc.b $80,$04,$00,$0F
  Dc.b $3F,$FE,$00,$04
  Dc.b $00,$06,$7F,$F8
  Dc.b $1B,$44,$00,$0C
  Dc.b $F7,$FC,$00,$04
  Dc.b $00,$19,$F9,$FE
  Dc.b $1B,$44,$00,$33
  Dc.b $FE,$7F,$00,$04
  Dc.b $00,$0F,$FF,$BF
  Dc.b $CD,$44,$00,$03
  Dc.b $EF,$EF,$F0,$04
  Dc.b $00,$00,$7F,$DF
  Dc.b $FB,$44,$00,$00
  Dc.b $FF,$A7,$FC,$04
  Dc.b $00,$00,$7E,$3F
  Dc.b $FD,$44,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $7F,$FF,$FF,$FF
  Dc.b $FF,$FC,$00,$00
  Dc.b $00,$01,$00,$00
  Dc.b $00,$00,$04
.icongfx_data_end:                                            ;objiconf org source

str_infoextention2:  Dc.b ".info",0                           ;infoname org source
Even

sysdebug:            Dc.l $3F0
Even


exelock              Ds.l 1

wzgui                IncBin "compiler.wizard"

includesourceline    Dc.l 0
linenum              Ds.l 1
globallinecount      Ds.l 1
myversion            Dc.b "\\__VER_MAJOR.\\__VER_MINOR (\\__DATE_GER__) Build \\__VER_PATCH.\\__VER_BUILD",0 : Even
calc_option          Dc.l 1
versioninformation   Dc.l $00
number_of_builds     Dc.l $00


BSS
debugnest            Ds.w 1
instringf            Ds.l 1
funcscanon           Ds.l 1
storedebugmode       Ds.b 20
firsttimepref        Ds.l 1
funcparloop          Ds.w 1
nostringopt          Ds.w 1
path2:               Ds.l 32
typebase             Dc.l 0
doublepeek           Dc.w 0
lastoffset           Dc.l 0
firsttime            Dc.w 0
lastdestpointer      Dc.l 0
prevwritedat         Dc.l 0
lastsourceline       Dc.l 0
lastwritedat         Dc.l 0
makeexec             Dc.w 0
makeexec_remember    Dc.w 0
sharebase            Ds.l 1
tempa7               Ds.l 1
incnif               Ds.w 1
tempstore            Ds.l 1
result               Ds.l 1
automode             Ds.w 1
stackcorrect         Ds.w 1
formode              Ds.w 1
limitregs            Ds.l 1
onestep              Ds.w 1
reqmode              Ds.l 1
inctab               Ds.l 40
funcoptimize         Ds.w 1
includeline          Ds.l 1
morememadd           Ds.l 1
objectcount          Ds.w 1
savefuncspace        Ds.l 1
lasttrap1            Ds.l 1
currentfunccall      Ds.l 1
skipfunc             Ds.b 1
resdisable           Ds.b 1
skiptoggle           Ds.b 1
developobject        Ds.b 1
iniffcommand         Ds.w 1
startoffsetmore      Ds.w 1
olddebugmode         Ds.w 1
fpucodeglobal        Ds.l 1
fpucodelocal         Ds.l 1
maxregs              Ds.l 1
fpucode              Ds.l 1
firstmline           Ds.w 1
regtable             Ds.l 16
exdebug              Ds.w 1
a2offset2            Ds.w 1
parnumtemp           Ds.l 1
doimmediate          Ds.b 1
notypecheck          Ds.b 1
vartype              Ds.w 1
peekaddrsize         Ds.b 1
declare2             Ds.b 1
parameternum         Ds.w 1
lasttoken            Ds.l 1
newvariable          Ds.w 1
declare              Ds.b 1
typecheck            Ds.b 1
nowdeclare           Ds.b 1
dimkeep              Ds.b 1

firstiffstore        Ds.l 1
destpointer2         Ds.l 1
stackaddr            Ds.l 1
allowtab             Ds.b 260
templine             Ds.b 256
thenmode             Ds.w 1
temp                 Ds.w 1
tempregnum           Ds.w 1
;quickpeek            Ds.w 1
numlines2            Ds.l 1
numlines             Ds.l 1
exmac                Ds.w 1
returncode           Ds.w 1
fp0iff               Ds.l 1
fp0addr              Ds.l 1
fp0mode              Ds.w 1
fp0var               Ds.w 1
fastfunc             Ds.w 1
retmode              Ds.w 1
parnum               Ds.w 1
regmask              Ds.w 1
regnumfunc           Ds.w 1
libmode              Ds.w 1
oldline              Ds.l 1
sourceline3          Ds.l 1
debugstore           Ds.b 200
deststore            Ds.l 1
;_Screen              Ds.l 1
loada                Ds.l 1
;_intuibase           Ds.l 1
currtype             Ds.l 1
arrayoffset          Ds.l 1
lastlabel            Ds.l 1
curtemplabel         Ds.l 1
sourceline2          Ds.l 1
chartab              Ds.b 256
tempspace            Ds.b 120
instrtab             Ds.l 65538*2
; by every compile pass the content beginning from label labelhash to bssstore are cleared!
labelhash            Ds.l 8192                             ;-bssstore clear every compile pass
replacedat           Ds.w 65538
variablehash         Ds.l 8192
newinitaddr          Ds.l 1
realbssend           Ds.l 1
saved0               Ds.b 1
lastpath             Ds.b 128
lastpath2            Ds.b 128
fpustackbase         Ds.w 100
lastconstantvalue    Ds.l 1  ; the value of the constant expression used in Function Parameter.check isconstantvalue <> 0 if its valid
isconstantvalue      Ds.w 1  ; contain a type (1-7) if a constant expression is used as a Parameter or on right side of =
lastfunction         Ds.l 1  ; the address of the function in the Parameter or rght side of =
leftsidetype         Ds.l 1  ;this contain the address of the type from the left side of the variable assign
bssstore

trap15temp           Ds.l 1
trap15temp2          Ds.l 1
templibend           Ds.l 1
tempdata1start       Ds.l 1
pad2                 Ds.b 1
stacktrack           Ds.l 1
pad                  Ds.l 1
includetemp          Ds.b 256
includetemp2         Ds.b 256*10
funccall             Ds.w 1
;progressrp           Ds.l 1
;_gfxbase             Ds.l 1
ptr_resfile          Ds.l 1
button_bin_flags:    Ds.w 1
button_dec_flags:    Ds.w 1
ped_startup_addr:    Ds.l 1
start_without_libs:  Ds.b 1
skip_bytes:          Ds.b 1
functionreturntype   Ds.l 1  ; a temp store of it.do not read this value

iserror              Ds.b 1
Even

CLIMode:             Dc.l 0
XTRAEndPadBytes:     Dc.l 0                             ; 4 fill/pad/termination bytes for the xtra write function  tomsmart1
