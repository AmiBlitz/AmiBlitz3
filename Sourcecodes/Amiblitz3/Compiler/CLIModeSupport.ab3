; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "///"
; ExeFile         = "Amiblitz3_Beta"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 4096
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 3.6.6
; NumberOfBuilds  = 1
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 1
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 1173
; CursorColumn    = 81
; LabelSearch     = "loads"
; LabelRemark     = 0
; LabelAll        = 1
; LabelCase       = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 25
; Max GadgetList  = 5
; Max Shape       = 100
; Max Bank        = 5
; Max MenuList    = 5
; Max GTList      = 25
; Max Palette     = 4
; Max BitMap      = 10
; Max Screen      = 5
; Max IntuiFont   = 5
; Max BlitzFont   = 4
; Max Window      = 25
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 25
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max TagList     = 5
; Max Database    = 16
; Max Sound       = 1
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 1
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 1
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
SHARED global_exefilename.s

Statement OpenConsoleFake{}
  SHARED pr_CIS.l,pr_COS.l,*ab3proc.Process

  *myproc.Process   = FindTask_(0)
  pr_CIS.l = *myproc\pr_CIS
  pr_COS.l = *myproc\pr_COS

  If *ab3proc
    *myproc\pr_CIS = *ab3proc\pr_CIS
    *myproc\pr_COS = *ab3proc\pr_COS
  Else
    error{"AB3 Process is not initialized!"}
  End If

End Statement


Statement CloseConsoleFake{}
  SHARED pr_CIS.l,pr_COS.l
  *myproc.Process = FindTask_(0)
  *myproc\pr_CIS = pr_CIS
  *myproc\pr_COS=  pr_COS
  pr_COS = #NULL
  pr_CIS = #NULL
End Statement


Statement SetCurrentDir{path.s}
  If path
    SetCurrentDirName_ &path
  EndIf
End Statement


;/* this function emulates a minimalistic PED environment */
Function.l InitEmulatedPED{}
  SHARED *ab3proc.Process
  succ.l = True

  !ComData_SetL{comData_Magic         ,##MagicIdentifier_Long}             ; "~::~"
  !ComData_SetW{comWord_PEDIsAvailable,##ComDataVersionID}      ;added to indentivie ComData Version for Debugger  tomsmart1 2016 02 _8
  !ComData_SetL{comPtr_SourceDir      ,#comStr_SourceDir }
  !ComData_SetL{comPtr_SourceName     ,#comStr_SourceName }
  !ComData_SetL{comPtr_TokenBase      ,#tokens }
  !ComData_SetL{comFunc_ReadXtraFile  ,#read_xtrafile }
  !ComData_SetL{comFunc_OpenConsole   ,#ab3_OpenConsole}
  !ComData_SetL{comFunc_CloseConsole  ,#ab3_CloseConsole}
  !ComData_SetL{comFunc_CallMenuEntry ,#call_menuentry}
  !ComData_SetL{comLong_AB3IsAvailable,#teddata}
  !ComData_LEA{comFunc_DebugTrap      ,A0}                : MOVE.l #com_debugtrap ,(A0) ;$38

  ; removed Ted.library use because is not needed  tomsmart1 2012 06 11

  mempoolP.l = CreatePool_(#MEMF_CLEAR,40000,40000)
  If mempoolP = 0
    error{"Could not allocate enough memory. Emulated PED closes down now."}
    succ = False
  Else
    GetRegD0 mempoolP : !ComData_SetL{comPtr_MemPool,d0}
  End If

  *ab3proc.Process = FindTask_(0)

  Function Return succ
End Function

JMP skip_PEDEmu
.PEDEmu_vars
instring              Dc.b 0
instring2             Dc.b 0
instring3             Dc.b 0
Even

.com_debugtrap:       ; was tokone: org source SuperTED
  ;tokenise one line - line in a0
  ;
  MOVEA.l A0,A2
  MOVEQ.l #$00,D1

 'loop
    ADDQ.w #1,D1
    TST.b (A0)+
  BNE.b 'loop

  MOVEA.l A2,A1
  SUBQ.w #1,D1
  BPL.w tokit2
RTS

enddo:                         ; tokenise line
  CLR.b (A1)+
  MOVE.l A1,D5
  SUB.l (A7)+,D5
RTS


tokit2:                        ; debugger entry point
  MOVE.l A1,-(A7)
  BRA.w tokit3

tokit:                         ; tokenise the line!
 ;
 ;first, find last character in line!
 ;
tokit4
  CMPI.b #$20,$0(A2,D1.W)
  BNE.w tokskip

tokit3:
  SUBQ.w #1,D1
   BPL.b tokit
  ADDQ.w #4,A7
  CLR.b (A1)
  MOVEQ.l #$01,D5
RTS

tokskip:
  MOVE.l A4,-(A7)
  ;O.K. d1=last char on line
  MOVEQ.l #$00,D0
  MOVE.w D0,comWord__QuoteFlag   ; was , invflag
  ;
  ;the main tokenise loop...
  ;
  ; new >
  CLR.b instring2
  ; < new

   'loop2
    MOVE.b (A2)+,D2
    ;new >
    CMP.b #$22,d2
    BNE 'l10
    NOT.b instring2

   'l10
    TST.b instring2
    BNE 'l11
    ; < new
    BCLR #$7,D2                      ;morechar

   'l11
    CMP.b comByte_QuotationIdentifier,D2       ; was quote(pc),
    BNE.w 'hendrix

   'quoteon
    NOT.w comWord__QuoteFlag

   'pch
    JSR putchar
    BRA.b 'loop2

   'hendrix
    MOVE.w comWord__QuoteFlag,D4
    BNE.b 'pch
    JSR alpha
    BEQ.w 'tsttoke

   ;.dbt_temp1
   'ppp2
    ; new >
    CMP.b #$30,d2                    ;number 0-9
     BLT 'l10a
    CMP.b #$39,d2
     BGT 'l10a
    BRA 'unto2

   'l10a
    ; < new
    CMP.b #"_",D2
     BEQ.w 'unto2
    CMP.b #$2E,D2   ;'.'
     BEQ.w 'unto2
    CMP.b #"\",D2
     BEQ.w 'unto2
    CMP.b comByte_CommentIdentifier,D2   ; was remark(pc),
     BNE.w 'notrem

   'remloop
      JSR putchar
      MOVE.b (A2)+,D2
      BCLR #$7,D2
    BRA.b 'remloop

   'notrem
    ; new >
    CMP.b #"'",d2
     BEQ 'hexloop
    CMP.b #"#",D2
     BEQ.w 'hexloop                 ;jump notokenize
    ; < new
    CMP.b #"$",D2                    ;tokenize $ #
     BNE.w 'nothex

   'hexloop
      JSR putchar
      MOVE.b (A2)+,D2
      BCLR #$7,D2
      ;
      ; new >
      CMP.b #$22,d2
      BNE 'l10b
      BRA 'hexloop

     'l10b
      CMP.b #"_",d2
       BEQ 'hexloop
      ; < new
      CMP.b #"0",D2
       BCS.w 'nothex
      CMP.b #"z",D2                  ;f
       BHI.w 'nothex
      CMP.b #"9",D2
       BLS.b 'hexloop
      CMP.b #"A",D2
       BCS.w 'nothex
      CMP.b #"a",D2
       BCC.b 'hexloop
      CMP.b #"Z",D2                  ;F
    BLS.b 'hexloop

   'nothex
    JSR putchar
    MOVE.b (A2)+,D2
    ; new >
    CMP.b #$22,d2
     BNE 'l10c
    NOT.b instring2

   'l10c
    TST.b instring2
     BNE 'l11c
    ; < new
    BCLR #$7,D2                      ;morechar

   'l11c
    CMP.b comByte_QuotationIdentifier,D2    ; was  quote(pc)
     BEQ.w 'quoteon
    JSR alpha
    BNE.b 'ppp2
    ;

   'tsttoke
    SUBQ.w #1,A2
    MOVEA.l comPtr_TokenBase,A3    ; was tokens(pc)

   'loop3
    MOVEA.l A2,A4
    MOVE.l A3,-(A7)
    ADDQ.w #6,A3

   'loop4
    MOVE.b (A3)+,D3
     BEQ.w 'found
    MOVE.b (A4)+,D2
    BCLR #$7,D2
    ORI.b #$20,D3
    ORI.b #$20,D2
    CMP.b D3,D2
    BEQ.b 'loop4
    ;

   'next
    MOVEA.l (A7)+,A3
    MOVE.l (A3),D3
     BEQ.w 'notoke
    MOVEA.l D3,A3
   BRA.b 'loop3
    ;

   'notoke
    MOVE.b (A2)+,D2
    BCLR #$7,D2

   'unto2
     JSR putchar
    MOVE.b (A2)+,D2
    ; new >
    CMP.b #$22,d2
    BNE 'l10d
    NOT.b instring2

   'l10d
    TST.b instring2
     BNE 'l11d
    ; < new
    BCLR #$7,D2            ;morechar

   'l11d
    CMP.b comByte_QuotationIdentifier,D2    ; was quote(pc)
     BEQ.w 'quoteon
    JSR alpha
    BEQ.b 'unto2
   BRA.w 'ppp2

   'found
    MOVE.b (A4),D2
    BCLR #$7,D2
    JSR alpha            ;ascii to token
     BEQ.b 'next
    ; new >
    CMP.b #$30,d2            ;number 0-9
     BLT 'l10e
    CMP.b #$39,d2
     BGT 'l10e
    BRA 'next

   'l10e
    ; < new
    CMP.b #"_",D2
     BEQ.b 'next
    MOVEA.l (A7)+,A3
    ADDQ.w #4,A3

   'putina3
    MOVE.b (A3)+,(A1)
    BSET #$7,(A1)+
    MOVE.b (A3),(A1)+
    MOVE.l A4,D4
    SUB.l A2,D4
    ADD.w D4,D0
    CMP.w D1,D0
     BHI.w pchover2
    MOVEA.l A4,A2
BRA.w 'loop2


putchar:
  MOVE.b D2,(A1)+
  ADDQ.w #1,D0
  CMP.w D1,D0
  BHI.w pchover
RTS


pchover:
  ADDQ.w #4,A7

pchover2:
  MOVEA.l (A7)+,A4
BRA.w enddo


alpha:
  ;return eq if d2 is alphabetic
  CMP.b #"A",D2
   BCS.w 'done
  CMP.b #"z",D2
   BHI.w 'done
  CMP.b #"[",D2
   BCS.w 'yes
  CMP.b #"a",D2
   BCS.w 'done

  'yes
  CMP.w D2,D2

 'done
RTS


alphad0:                          ; This part is not used and can be removed  tomsmart1
  EXG.l D0,D2                     ;
  BSR.b alpha                     ;
  EXG.l D0,D2                     ;
RTS

.skip_PEDEmu

;/* deinit what has been inited before */
Function.l DeinitEmulatedPED{}
  succ.l = True

  !ComData_GetL{comPtr_MemPool,d0} : mempoolP.l = PutRegD0
  If mempoolP
    CLR.l d0
    !ComData_SetL{comPtr_MemPool,d0}
    DeletePool_ mempoolP
  End If

  ;CLR.l d0
  ;!ComData_SetL{comPtr_Temp_TokenString1,#0}
  ;!ComData_SetL{comPtr_Temp_TokenString2,#0}
  ;!ComData_SetL{comPtr_Temp_TokenString3,#0}

  Function Return succ
End Function


;/* clear the source buffer */
Statement ClearSource{}
  !ComData_GetL{comPtr_FirstSourceLine,D0}
  *SourceLine.SourceLine_t = PutRegD0
  *NextLine.SourceLine_t = #NULL
  !ComData_GetL{comLong_TotalLines,D0}
  SUBQ.l #1,D0
  maxlines.l = PutRegD0

  !ComData_GetL{comPtr_MemPool,D0}      : mempoolP.l = PutRegD0
  !ComData_GetL{comLong_TotalLines,D0}  : totalLines.l = PutRegD0
  While *SourceLine><#NULL AND totalLines>0
    *NextLine =  *SourceLine\NextLine
    memsize.l = Peek.l(*SourceLine-4)
    FreePooled_ mempoolP,*SourceLine-4,memsize
    *SourceLine = *NextLine
    totalLines-1
  Wend

  !ComData_SetL{comLong_TotalLines,#$0001}
End Statement


Function.l LoadXtra{filename.s}
  succ.l = False
  fp.l = Open_ (&filename,#MODE_OLDFILE)
  If fp
    GetRegD0 fp
    MOVE.l A4,-(A7)
    !asm
    MOVE.l D0,D7
    MOVEA.l _dosbase,A6
    JSR read_xtrafile
  ;  !ComData_JSR{comFunc_ReadXtraFile}
    !basic
    MOVE.l (A7)+,A4
    !ComData_LEA{comDef_XtraExtendBegin,D0}
    aptr.l = PutRegD0
    !ComData_LEA{comDef_XtraExtendEnd,D0}
    eptr.l = PutRegD0

    Read_ fp,aptr,eptr-aptr
    Close_ fp
    succ.l = True
  Else
    log2PED{"warning: unable to open .xtra file [" + filename + "]!"}
  End If
 Function Return succ
End Function


Macro SetBoolXtra
  If (`2)
    Poke.b ?`1, (Peek.b(?`1)|$80)
  Else
    Poke.b ?`1, (Peek.b(?`1)|$80) - $80
  End If
End Macro


Function.l SkipXtraHeader{textP.l,blength.l}
  pos.l = 0
  found.l = False
  gotcomment.l = False
  While found=False AND pos<blength

    Select Peek.b(textP+pos)
      Case @";" : gotcomment.l = True  : pos+1
      Case 10   : If gotcomment=False
                    found = True       : pos=0
                  Else
                    gotcomment = False : pos+1
                  End If
      Case @"/"
        pos+1
        xtra.l = Peek.l(textP+pos)
        If xtra = @"xtra" OR xtra = @"XTRA" OR xtra = @"Xtra"
          pos + 4
          While Peek.b(textP+pos)><10 AND pos<blength
            pos+1
          Wend
          pos+1
          found = True
        End If
      Default
        pos+1
    End Select

  Wend
  ;error{"Found inc pos: "+Str$(pos)+" of "+Str$(blength)}
  If pos>=blength Then pos=0
 Function Return pos
End Function


; load bb, bb2, ab2 and ab3
Function.l LoadSource{sourcefile.s}
 SHARED OnePassCompiling.l

  !ComData_GetL{comPtr_FirstSourceLine,D0} : *sourceBase.SourceLine_t = PutRegD0
  !ComData_GetL{comPtr_PreProcessor,D0}    : *PreProcessor.preprocessor = PutRegD0
  !ComData_GetL{comPtr_MemPool,D0}         :  mempoolP.l = PutRegD0

  *firstLine.SourceLine_t  = #NULL
  *lastLine.SourceLine_t   = #NULL

  fid.l = file_Open{sourcefile,#file_read}
  If fid>=0
    ex.s = LCase$(dos_GetExt{sourcefile})
    byteLength.l = file_GetLength{fid}
    sourcefile.s = file_GetDosName{fid}

    offset.l = 0
    tempBuffer.l = AllocVec_(byteLength+8,#MEMF_ANY)
    If tempBuffer
      If file_ReadMem{fid,tempBuffer,byteLength}
        Poke.b tempBuffer + byteLength,0

        If ex = "bb" OR ex = "bb2" OR ex = "ab2" ; read xtra file
          LoadXtra{sourcefile + ".xtra"}
          !ComData_SetB{comByte_FuncOptimize   ,#1}                ; added for compatiblity because it is not stored in the xtra file  tomsmart1
          !ComData_SetW{comWord_CreateDebugFile,#0}                ; to match the old default settings  tomsmart1
        Else
          Gosub ParseAB3Header

          ;-- tokenize text without header (start at offset)
          ;-- the fileformats above are already tokenized
          byteLength = preproc_Tokenize{*PreProcessor,tempBuffer+offset,tempBuffer,byteLength-offset}
        End If

        offset.l = 0
        count.l = 0

        ;-- convert to source nodes
        *sourceNode.SourceNode_t = #NULL
        *prevLine.SourceLine_t   = #NULL
        While offset < byteLength
          text.s = Peek.s(tempBuffer + offset)
          charLength.l = FLen(text) + 1

          ; -- check if last line has no 0-byte at the end,
          ; -- in this case, the last line will be read until the next 0-byte and be corrupted
          If charLength > byteLength-offset
            charLength = byteLength-offset
            text.s = Peeks$(tempBuffer + offset,charLength)
          EndIf

          offset + charLength

          If charLength > #MAX_Columns Then charLength = #MAX_Columns : text = Left$(text,#MAX_Columns)
          allocsize.l = SizeOf.SourceNode_t + FLen(text)   ; the SizeOf contains already the terminating 0-Byte
          *sourceNode = AllocPooled_(mempoolP, allocsize)
          If *sourceNode
            *sourceNode\AllocSize             = allocsize
            *sourceNode\SourceLine\PrevLine   = *prevLine
            *sourceNode\SourceLine\NextLine   = #NULL
            *sourceNode\SourceLine\CharLength = charLength
            Poke.s &*sourceNode\SourceLine\Text,text

            If *prevLine Then *prevLine\NextLine = &*sourceNode\SourceLine
            *prevLine = &*sourceNode\SourceLine
            If *firstLine=#NULL Then *firstLine = &*sourceNode\SourceLine
            *lastLine = &*sourceNode\SourceLine
            count + 1

          Else
            log2PED{"LoadSource() - could not allocate memory for sourceline. allocsize: " + Str$(allocsize)}
            log2PED{">" +Str$(mempoolP)}
          End If
        Wend
        FreeVec_ tempBuffer

        GetRegD0 *firstLine
        !ComData_SetL{comPtr_FirstSourceLine   ,D0}
        !ComData_SetL{comPtr_CurrentSourceLine ,D0}

        GetRegD0 *lastLine
        !ComData_SetL{comPtr_LastSourceLine    ,D0}

        GetRegD0 count
        !ComData_SetL{comLong_TotalLines       ,D0}

        MOVE.l D0,numlines

        !ComData_SetW{comWord_TextBufferOffset ,#0}
        !ComData_SetW{comWord_Column           ,#0}
        !ComData_SetW{comWord_ColumnsOffset    ,#0}
        !ComData_SetL{comLong_DisplayLineOffset,#0}
        !ComData_SetL{comLong_DisplayLine      ,#0}

        If ex = "ab3"        ; apply xtra data
          !asm
          MOVEM.l D7/A6,-(A7)
          JSR clear_lastcompileerrordatas   ; added to fix problems if a residents load error happend  tomsmart1 2016 02 02
          JSR init_buffers
          JSR reloadresident
          MOVEM.l (A7)+,D7/A6
          !basic
        End If

        ;-- save the cursor line position for the CLIModus  tomsmart1
        If CLIMode = True                            ; check if we run in CLI mode 
          !ComData_GetL{comLong_CursorPosStore,d0}   ; yes than get the line of the cursor position
          !ComData_SetL{comLong_DisplayLine   ,d0}   ; and store it so it gets not lost by a save of the sourcecode
        EndIf

        ;-- update AB3 context
        !ComData_SetW{comWord_SourceChanged,#0}

        currdir.s = dos_PathPart{sourcefile}
        !ComData_LEA{comStr_SourceDir,D0} : currentDirP.l = PutRegD0
        Poke.s currentDirP,currdir
        SetCurrentDir{currdir}

        !ComData_LEA{comStr_SourceName,D0} : snP.l = PutRegD0
        Poke.s snP,dos_FilePart{sourcefile}

      End If
    Else
      error{"Not enough memory to load file!"}
    End If

    file_Close{fid}
  End If
  Function Return *firstLine

ParseAB3Header:
            headerDone.l = False
            file_Seek{fid,0}

            ; set defaults: /////////////////////////////////////
            ExePath.s        = "RAM:"
            ExeFile.s        = "Prog.exe"
            StringBuffer.l   = #DEFAULT_STRINGBUFFERSIZE    ; replaced with a constant  tomsmart1
            MakeSmallest.l   = False
            FuncOptimize.l   = 1                ; was False ; added for compatily with old sourcecode  tomsmart1
            StackSize.l      = #DEFAULT_STACKSIZE           ; replaced with a constant  tomsmart1
            CliArgs.s        = ""
            NumberOfBuilds.l = 0
            VersionInfo.l    = 0
            CreateIcon.l     = False
            UseDebugger.l    = False
            DebugInfo.l      = False
            CreateDbgFile.l  = False
            OverflowCheck.l  = False
            AssemblerCheck.l = True
            InterruptCheck.l = True
            AutoRun.l        = True
            CursorLine.l     = 0
            CursorCol.l      = 0
            LabelSearch.s    = ""
            LabelRemark.w    = False
            LabelAll.w       = False
            LabelCase.w      = False
            LabelPosition.l  = 0
            ; end defaults ///////////////////////////////////////

            ; erase xtra Buffer
            FillMem ?optssave,?ptr_endxtradata-?optssave,0

            Poke.b ?xtra_versionnumber,0                                ; vers org source
            Poke.b ?create_iconfile,0                                   ; create icon for executable

            Poke.w ?set_use_debugger,0
            Poke.w ?AL_0_11010,0                                          ;+obsolet: debugger
            Poke.w ?AL_0_1103C,0                                          ;+obsolet: long arrays
            Poke.w ?AL_0_11068,0                                          ;+obsolet: expand macros
            Poke.w ?AL_0_11094,0                                          ;+obsolet: quoted macros
            Poke.w ?set_make_smallestcode,0
            Poke.w ?set_link_debuginfo,0
            Poke.w ?set_autorun,0
            Poke.w ?set_interruptcheck,0
            Poke.w ?set_assemblercheck,0
            Poke.w ?set_overflowcheck,0
            Poke.w ?default_obsolete,0                                    ;+obsolet: ohne inhalt
            Poke.w ?default_interruptcheck,0                              ;+obsolet: interruptcheck vorgabe
            Poke.w ?default_overflowcheck,0                               ;+obsolet: overflow vorgabe

            If OnePassCompiling = False                                   ; check if try OnePassCompiling ; no use old buffer size   ; yes use small to load and big to compile  tomsmart1
              Poke.l ?objectbuffer     ,#DEFAULT_OBJECTBUFFERSIZE         ; replaced with there default value  tomsmart1
              Poke.l ?libsbuffer       ,#DEFAULT_LIBSBUFFERSIZE           ;                    "
              Poke.l ?systembuffer     ,#DEFAULT_SYSTEMBUFFERSIZE         ;                    "
              Poke.l ?databuffer       ,#DEFAULT_DATABUFFERSIZE           ;                    "
            Else
              Poke.l ?objectbuffer     ,#DEFAULT_MINIMALBUFFERSIZE        ; added to use minmal mem for loading  tomsmart1                                                                         q
              Poke.l ?libsbuffer       ,#DEFAULT_MINIMALBUFFERSIZE
              Poke.l ?systembuffer     ,#DEFAULT_MINIMALBUFFERSIZE
              Poke.l ?databuffer       ,#DEFAULT_MINIMALBUFFERSIZE
            EndIf
            Poke.l ?macrobuffer_size ,#DEFAULT_MACROBUFFERSIZE            ; replaced with there default value  tomsmart1
            Poke.l ?stringbuffer     ,#DEFAULT_STRINGBUFFERSIZE           ;                    "

            !asm
            JSR free_residents   ; frist free all residents if allready loaded  tomsmart1 2012 06 09
            ; make a full clear of the Residents table (max 7 entrys)  tomsmart1 2012 06 08
            JSR Clear_Residents_table      ; replace Poke.l ?residents_table,0 because it clears only the first table entry if one of the other entry is was used the stay active with the new source
            !basic
            ; exepath und exefilename jeweils 192 bytes
            !ComData_LEA{comStr_ExePath,d0} : exeP.l = PutRegD0 : Poke.l exeP,0
            !ComData_LEA{comStr_ExeFile,d0} : exeP.l = PutRegD0 : Poke.l exeP,0
            Repeat
              lin.s = file_ReadLine{fid}
              If file_EOF{fid} Then headerDone = True

              eqpos.l = Instr(lin,"=")
              If eqpos > 0
                rawtoken.s = Left$(lin,eqpos-1)
                value.s    = Right$(lin,FLen(lin)-eqpos-1)
              Else
                rawtoken.s = lin
                value.s    =  ""
              End If

              token.s    = ""
              For n.l = 0 To FLen(rawtoken)-1    ; trim token
                c.b = Peek.b(&rawtoken+n)
                If (c>=@"a" AND c<=@"z") OR (c>=@"A" AND c<=@"Z") OR c=@"_" OR c=@"/" OR c=@"-"
                  If (c=@"-") Then c=32 ; - to SPACE
                  token + Chr$(c)
                End If
              Next

              ; Trim: remove spaces at begin and end of each line
              ltrim.l = 0
              lmax.l  = FLen(value)
              While Peek.b(&value+ltrim) < 33 AND ltrim < lmax: ltrim+1 : Wend
              rtrim.l = lmax
              While Peek.b(&value+rtrim) < 33 AND rtrim >= 0 : rtrim-1 : Wend
              If Peek.b(&value+rtrim) = $22 AND Peek.b(&value+ltrim) = $22 Then rtrim-1:ltrim+1
              value = Mid$(value,ltrim+1,rtrim-ltrim+1)
              lvalue.l = Vallong(value)

                If token
                  Select LCase$(token)
                    Case "/xtra"
                      headerDone = True
                      ; remove embedded XTRA Header
                      offset = file_GetSeekPos{fid}

                    Case "exepath"        : ExePath = value
                    Case "exefile"        : ExeFile = value
                    Case "residents"
                      resptr.l = ?residents_table
                      resN.l   = 0
                      While value><""
                        cpos.l = Instr(value,",")
                        If cpos>0
                          resident.s = Left$(value,cpos-1)
                          value = Right$(value,FLen(value)-cpos-1+1)
                        Else
                          resident = value
                          value = ""
                        End If
                        ;NPrint "Set resident: <",resident,">"
                        Poke.s resptr,resident
                        resptr + #ResidentEntryStep    ; $44
                        resN + 1
                        If resN=7 Then value="" : error{"Warning: could not load all residents"}
                      Wend
                    Case "stringbuffer"   : StringBuffer = lvalue : If StringBuffer<#MIN_STRINGBUFFERSIZE Then StringBuffer=#MIN_STRINGBUFFERSIZE
                    Case "stacksize"      : StackSize    = lvalue : If StackSize<#MIN_STACKSIZE Then StackSize=#MIN_STACKSIZE
                    Case "makesmallest"   : MakeSmallest = lvalue
                    Case "funcoptimize"   : FuncOptimize = lvalue
                    Case "version"
                      mpos.l = Instr(value,".",1)
                      ppos.l = Instr(value,".",mpos+1)                          ; fixed search of the second "." because we must start +1 behind the first founded one
                      MajorVersion.l = Vallong(Left$(value,mpos))
                      MinorVersion.l = Vallong(Mid$(value,mpos+1,ppos-mpos+1))
                      PatchVersion.l = Vallong(Right$(value,FLen(value)-ppos))  ; fixed leng calculation
                      VersionInfo.l  = (MajorVersion LSL 24) | (MinorVersion LSL 16) | (PatchVersion LSL 8)
                    Case "numberofbuilds" : NumberOfBuilds = lvalue
                    Case "cliargs"        : CliArgs.s      = Left$(value,254)
                    Case "createicon"     : CreateIcon     = lvalue
                    Case "runtimedebug"   : UseDebugger    = lvalue
                    Case "debuginfo"      : DebugInfo      = lvalue
                    Case "createdbgfile"  : CreateDbgFile  = lvalue
                    Case "overflowcheck"  : OverflowCheck  = lvalue
                    Case "assemblercheck" : AssemblerCheck = lvalue
                    Case "interruptcheck" : InterruptCheck = lvalue
                    Case "autorun"        : AutoRun        = lvalue
                    Case "cursorline"     : CursorLine     = lvalue
                    Case "cursorcolumn"   : CursorCol      = lvalue
                    Case "labelsearch"    : LabelSearch    = Left$(value,29)
                    Case "labelremark"    : LabelRemark    = lvalue
                    Case "labelall"       : LabelAll       = lvalue
                    Case "labelcase"      : LabelCase      = lvalue
                    Case "labelposition"  : LabelPosition  = lvalue            ; added the read of inner position of the labellist tomsmart1
                    Default
                      If LCase$(Left$(token,3))="max"
                        bobjName.s = Right$(token,FLen(token)-3)
                        bobjMax.l  = Peek.w(?number_of_objects)
                        For i.l = 0 To bobjMax-1 ; find the obj's name...
                         name.s = "                                "
                         GetRegD0 &name,i:JSR getobjectentry : a.l = PutRegD0
                         name = Peek.s(&name)
                         If (name=bobjName) ; this is the one...
                           Poke.w ?maxobjects_value,lvalue
                           Poke.w ?maxobject_pos,i
                           Gosub storemaxobjects
                         End If
                        Next

                      End If

                  End Select
                End If

            Until headerDone

            ; set data
            !ComData_LEA{comStr_ExePath,d0} : exeP.l = PutRegD0 : Poke.s exeP, ExePath
            !ComData_LEA{comStr_ExeFile,d0} : exeP.l = PutRegD0 : Poke.s exeP, ExeFile
            GetRegD0 CursorLine : !ComData_SetL{comLong_CursorPosStore,d0}
            Poke.l ?versioninformation,VersionInfo
            !ComData_LEA{comStr_LabelSearchString,d0} : labelP.l = PutRegD0 : Poke.s labelP,LabelSearch
            Poke.s ?str_cliarguments,CliArgs
            Poke.l ?stringbuffer,StringBuffer
            Poke.l ?number_of_builds,NumberOfBuilds
            !SetBoolXtra{make_smallestcode,MakeSmallest}
            !SetBoolXtra{create_iconfile  ,CreateIcon}
            !SetBoolXtra{use_debugger     ,UseDebugger}
            !SetBoolXtra{link_debuginfo   ,DebugInfo}
            !SetBoolXtra{overflowcheck    ,OverflowCheck}
            !SetBoolXtra{assemblercheck   ,AssemblerCheck}
            !SetBoolXtra{interruptcheck   ,InterruptCheck}
            !SetBoolXtra{autorun          ,AutoRun}
            Poke.l ?stacksize,StackSize
            ; cursorcol is missing
            GetRegD0 CreateDbgFile : !ComData_SetW{comWord_CreateDebugFile,d0}
            GetRegD0 LabelRemark   : !ComData_SetW{comWord_LabelRemark,d0}
            GetRegD0 LabelAll      : !ComData_SetW{comWord_LabelAll,d0}
            GetRegD0 LabelCase     : !ComData_SetW{comWord_LabelCase,d0}
            GetRegD0 LabelPosition : !ComData_SetL{comLong_Label1VisableItemStore,d0}    ; added the load of the inner postion of the labellist  tomsmart1
            If (MakeSmallest <> False) Then FuncOptimize = 1                          ; added for compatblity with older source  tomsmart1
            GetRegD0 FuncOptimize  : !ComData_SetB{comByte_FuncOptimize,d0}
  Return
End Function

Statement RunSource{debug.l,clistacksize.l}         ; added argument to indicate if ted.library use is needed  tomsmart1 2012 06 11
  !ComData_LEA{comStr_ExePath,D0} : exeP.l = PutRegD0 : workpath.s = Peek.s(exeP)
  SetCurrentDir{workpath}
  If cli_verbose>=2 Then NPrint "Set working directory to \\22",workpath+"\\22..."

  If debug                           ; check if debug is used  tomsmart1 2012 06 11
    If ted_OpenLib{0}                ; ted.library is only necessary for the Debugger  tomsmart1 2012 06 11
      !ComData_LEA{COMDATABASE,d0}              : comdataP.l           = PutRegD0 : TEDSetJumpTable  {comdataP}
      !ComData_LEA{comPtr_FirstSourceLine,d0}   : FirstSourceLineP.l   = PutRegD0 : TEDSetFirstLine  {FirstSourceLineP}
      !ComData_LEA{comPtr_CurrentSourceLine,d0} : CurrentSourceLineP.l = PutRegD0 : TEDSetCurrentLine{CurrentSourceLineP}
      !ComData_LEA{comPtr_LabelList,d0}         : LabelListP.l         = PutRegD0 : TEDSetLabelList  {LabelListP}
      !ComData_LEA{comWord_LabelCounter,d0}     : LabelCounterP.l      = PutRegD0 : TEDSetLabelCount {LabelCounterP}
    Else
      error{"ERROR: Unable to open ted.library, REDDebugger will not work!"}
    End If
  End If


  If clistacksize > #MIN_STACKSIZE    ; added to set Stacksize by CLI MODE args  tomsmart1
    Poke.l ?stacksize,clistacksize
  EndIf

  fh.l = Output_()     ; flush the stdout before we do something else
  If fh Then Flush_ fh

  MOVE.l A4,-(A7)
  !asm
  JSR menu_run
  !basic
  MOVE.l (A7)+,A4

  If debug
    ted_CloseLib{}           ; moved form DeinitEmulatedPED  tomsmart1 2012 06 11
  End If

End Statement

; define constants for CLI compiler and debugger settings  tomsmart1
#CLI_COMSETICONFLAG  = $00010000
#CLI_COMSETSMALLFLAG = $00020000
#CLI_COMSETFUNCFLAG  = $00040000
#CLI_COMSETLDBGFLAG  = $00080000
#CLI_COMSETDBGFFLAG  = $00100000
#CLI_COMSETALLFLAGS  = #CLI_COMSETICONFLAG|#CLI_COMSETSMALLFLAG|#CLI_COMSETFUNCFLAG|#CLI_COMSETFUNCFLAG|#CLI_COMSETLDBGFLAG|#CLI_COMSETDBGFFLAG

#CLI_DEBUGAUTOFLAG   = $00000001
#CLI_DEBUGIRQFLAG    = $00000002
#CLI_DEBUGASMFLAG    = $00000004
#CLI_DEBUGOFLFLAG    = $00000008
#CLI_DEBUGALLFLAGS   = #CLI_DEBUGAUTOFLAG|#CLI_DEBUGIRQFLAG|#CLI_DEBUGASMFLAG|#CLI_DEBUGOFLFLAG


Function.l CompileSource{exefile.s,debug.l,release.l,comdbgflags.l,stringbuffersize.l} ; expand to support CLI Compiler and Debugger settings tomsmart1
 SHARED releaseexe.l , releasedbg_save.w      ; added for the new create of release exe  tomsmart1

  ;check if there are cli args for compiler and debugger settings
  ;else use settings of the xtra data  tomsmart1
  If (comdbgflags & #CLI_COMSETALLFLAGS) <> 0
    ;set compiler settings from cli args
    If comdbgflags & #CLI_COMSETICONFLAG
      !SetBoolXtra {create_iconfile  ,1}
    Else
      !SetBoolXtra {create_iconfile  ,0}
    EndIf

    If comdbgflags & #CLI_COMSETSMALLFLAG
      !SetBoolXtra {make_smallestcode,1}
      !ComData_SetB{comByte_FuncOptimize,#1}
    Else
      !SetBoolXtra {make_smallestcode,0}
      If comdbgflags & #CLI_COMSETFUNCFLAG
        !ComData_SetB{comByte_FuncOptimize,#1}
      Else
        !ComData_SetB{comByte_FuncOptimize,#0}
      EndIf
    EndIf

    If comdbgflags & #CLI_COMSETLDBGFLAG
      !SetBoolXtra {link_debuginfo   ,1}
    Else
      !SetBoolXtra {link_debuginfo   ,0}
    EndIf

    If comdbgflags & #CLI_COMSETDBGFFLAG
      !ComData_SetW{comWord_CreateDebugFile,#1}
    Else
      !ComData_SetW{comWord_CreateDebugFile,#0}
    EndIf
  ;end compiler settings from cli args
  EndIf

  If (comdbgflags & #CLI_DEBUGALLFLAGS) <> 0
    ;set debugger settings from cli args
    If (comdbgflags & #CLI_DEBUGAUTOFLAG)
      !SetBoolXtra{autorun          ,1}
    Else
      !SetBoolXtra{autorun          ,0}
    EndIf

    If (comdbgflags & #CLI_DEBUGIRQFLAG)
      !SetBoolXtra{interruptcheck   ,1}
    Else
      !SetBoolXtra{interruptcheck   ,0}
    EndIf

    If (comdbgflags & #CLI_DEBUGASMFLAG)
      !SetBoolXtra{assemblercheck   ,1}
    Else
      !SetBoolXtra{assemblercheck   ,0}
    EndIf

    If (comdbgflags & #CLI_DEBUGOFLFLAG)
      !SetBoolXtra{overflowcheck    ,1}
    Else
      !SetBoolXtra{overflowcheck    ,0}
    EndIf
  ;End debugger settings form cli args
  EndIf

  If stringbuffersize > #MIN_STRINGBUFFERSIZE    ; added to set stringbuffer size by CLI MODE arg  tomsmart1
    Poke.l ?stringbuffer,stringbuffersize
  EndIf

  If debug ; set debugger
    !SetBoolXtra{use_debugger     ,1}
    CLR.w debugversion                 ; moved because it adds $800 buffers extra an added debug libs  tomsmart1
  Else
    !SetBoolXtra{use_debugger     ,0}
    MOVE.w #-1,debugversion            ; added so no extra debug stuff is add to exe and the result exe match now the exes that a create with PEd  tomsmart1
  End If

  If release   ; set make smallest (for release); only for release we overwrite the settings of the sourcefile  tomsmart1
    !SetBoolXtra{make_smallestcode,1}
    !ComData_SetB{comByte_FuncOptimize,#1}     ; set it to the old default for smallest size  tomsmart1
    !ComData_GetW{comWord_CreateDebugFile,D0}  ; get status
    releasedbg_save = PutRegD0                    ; save status
    !ComData_SetW{comWord_CreateDebugFile,#0}  ; switch it off that the dbg file is not created for every compile
    releaseexe = True                          ; set it on
  Else                                         ; NO, it is debug, we dont care about size, but want 1-pass compiling
                                               ; deactivate else because we use the settings of the sourcefile  tomsmart1
    !SetBoolXtra{make_smallestcode,0}          ; If someone doesnt want to release, he gives a damn about the size (usually)
    !ComData_SetB{comByte_FuncOptimize,#0}     ; if we dont make smallest, we dont need to prune functions
                                               ; Wanderer 2013 05 15
    releaseexe = False                         ; set it off
  End If


  !ComData_LEA{comStr_SourceDir,D0}
  currentDirP.l = PutRegD0
  sourcepath.s = Peek.s(currentDirP)

  ; do some cleanup before invoking compiler */
  CLR.w anyerrs
  ;CLR.w flag_noPED
  ;CLR.w flag_noCLI
  environment\_noCLI = False
  environment\_noPED = False
  MOVE.l #$FFFFffff,linenumat
  MOVE.l #$FFFFffff,compilelinecounter

  SetCurrentDir{sourcepath}

  If exefile
    MOVE.w #1,makeexec_remember

    ; changed to support relative paths for the exe file  tomsmart1
    If "" <> dos_DevicePart{exefile}                       ; check if the exefile have a devicename like "RAM:"
      global_exefilename = exefile                         ; yes, use only this path
    Else
      global_exefilename = dos_AddPart{sourcepath,exefile} ; no, use the source file path as start path plus the exepath
    EndIf
    Poke.l ?ptr_newexefilename,&global_exefilename
    !ComData_LEA{comStr_ExePath,d0} : exeP.l = PutRegD0 : Poke.s exeP,dos_PathPart{sourcepath}
    !ComData_LEA{comStr_ExeFile,d0} : exeP.l = PutRegD0 : Poke.s exeP,dos_FilePart{exefile}
  Else
    MOVE.w #0,makeexec_remember
    ; use exe settings from xtra information
  End If

  MOVE.l A4,-(a7)
  !asm
  !ComData_GetL{comPtr_FirstSourceLine,A5}
  !ComData_GetL{comLong_TotalLines,D7}

  MOVE.l A5,firstitem_
  MOVE.w D7,numlines_org
  MOVE.l d7,numlines

 _ab3_compileloop:
    MOVE.w makeexec_remember,makeexec                                     ;MOVE.w #$FFFF,debugversion
    JSR ab3_OpenDebugFile
    JSR startcompile
    JSR ab3_CloseDebugFile
    TST.l errorcounter                                                    ; if a error happen do not the second pass
    BNE 'notagain
    CMP.l #"NORE",reqmode
   BEQ _ab3_compileloop

 'notagain
  !basic
  MOVE.l (a7)+,A4

  MOVE.l globallinecount,D0
  counter.l = PutRegD0

  MOVE.w anyerrs,d0         ; fixed to the right size  tomsmart1
  err.w = PutRegD0             ;   "

  errcount.l = Peek.l(?errorcounter)
  If cli_verbose>=1 Then Print counter-1," line(s) compiled, "

  If errcount>0
    NPrint "\\1B[1m",errcount," error(s)!"
  Else
    If cli_verbose>=1 Then NPrint "0 errors."
  End If

  If err=0
    If exefile
      If cli_verbose>=1 Then NPrint "Saving executable as \\22",exefile,"\\22."
      !asm
      JSR savefile
      !basic
    End If
  Else
    NPrint "A unknow error happend!"  ; added tomsmart1
  End If

  fh.l = Output_()     ; flush the stdout before we do something else
  If fh Then Flush_ fh

  Function Return err

End Function


; this function can save .bb2, .ab2 and .ab3
Function.l SaveSource{filename.s}
  Format ""
  !ComData_GetL{comPtr_FirstSourceLine,D0} : *sourceBase.SourceLine_t = PutRegD0
  !ComData_GetL{comPtr_PreProcessor,D0}    : *PreProcessor.preprocessor = PutRegD0

  ;calculate to get the cursor line postion
  !ComData_GetL{comLong_DisplayLineOffset,D0}
  !ComData_GetL{comLong_DisplayLine,D1}
  ADD.l d1,d0
  !ComData_SetL{comLong_CursorPosStore,d0}

  succ.l = False
  fid.l = file_Open{filename,#file_write}
  If fid>=0

    totalLength.l = 0
    *sourceLine.SourceLine_t = *sourceBase

    While *sourceLine ; estimate the size of the temp buffer
      baseptr.l = &*sourceLine\Text
      sptr.l = baseptr
      While Peek.b(sptr) : sptr+1 : Wend
      totalLength + sptr - baseptr + 1
      *sourceLine = *sourceLine\NextLine
    Wend

    tmp.l = AllocVec_(totalLength,#MEMF_CLEAR)
    If tmp
      *sourceLine = *sourceBase
      dptr.l     = tmp
      While *sourceLine
        baseptr.l = &*sourceLine\Text
        sptr.l = baseptr
        Repeat
          char.b = Peek.b(sptr)
          Poke.b dptr,char : sptr+1 : dptr+1
        Until char=0
        *sourceLine = *sourceLine\NextLine
      Wend

      ex.s = LCase$(dos_GetExt{filename})

      If ex = "bb2" OR ex = "bb" ; write tokenized
        succ = file_WriteMem{fid,tmp,totalLength}
      Else
        If ex = "ab3" ; write Xtra as text...
          Gosub write_AB3Header
        EndIf
        file_Flush{fid}
        plainLength.l = preproc_DetokenizeFP{*PreProcessor,tmp,totalLength,file_GetFH{fid}}
        succ.l = True
      End If
      FreeVec_ tmp

    Else
      error{!TRANS{"Not enough memory for temp buffer!"}}
    End If
    file_Close{fid}
  End If
  Function Return succ

write_AB3Header:
  cliargs.s = Peeks$(?str_cliarguments,255)
  cliargs   = Peek.s(&cliargs)

  resptr.l = ?residents_table
  residents.s = Peek.s(resptr)
  For i.l = 0 To 6
    If Right$(residents,1)><"," Then residents + ","
    resptr + #ResidentEntryStep    ; $44
    residents  + Peek.s(resptr)
  Next
  If Right$(residents,1)="," Then residents=Left$(residents,FLen(residents)-1)

  If (Peek.b(?use_debugger      )&$80) Then RuntimeDebug.l   = 1:Else RuntimeDebug   = 0
  If (Peek.b(?create_iconfile   )&$80) Then CreateIcon.l     = 1:Else CreateIcon     = 0
  If (Peek.b(?make_smallestcode )&$80) Then MakeSmallest.l   = 1:Else MakeSmallest   = 0
  If (Peek.b(?link_debuginfo    )&$80) Then DebugInfo.l      = 1:Else DebugInfo      = 0
  If (Peek.b(?autorun           )&$80) Then AutoRun.l        = 1:Else AutoRun        = 0
  If (Peek.b(?assemblercheck    )&$80) Then AssemblerCheck.l = 1:Else AssemblerCheck = 0
  If (Peek.b(?interruptcheck    )&$80) Then InterruptCheck.l = 1:Else InterruptCheck = 0
  If (Peek.b(?overflowcheck     )&$80) Then OverflowCheck.l  = 1:Else OverflowCheck  = 0

  CLR.l d0
  !ComData_GetW{comWord_CreateDebugFile,D0} : CreateDbgFile.l = PutRegD0

  ;calculate to get the cursor line postion
  !ComData_GetL{comLong_DisplayLineOffset,d0}
  !ComData_GetL{comLong_DisplayLine      ,d1}
  ADD.l d1,d0
  ADD.l #1,d0
  CursorLine.l = PutRegD0

  CLR.l d0
  !ComData_GetW{comWord_ColumnsOffset,d0}
  !ComData_GetW{comWord_Column       ,d1}
  EXT.l d0
  EXT.l d1
  ADD.l d1,d0
  ADD.l #1,d0
  CursorColumn.l = PutRegD0

  VersionInfo.l  = Peek.l(?versioninformation)
  MajorVersion.l = (VersionInfo & $FF000000) LSR 24
  MinorVersion.l = (VersionInfo & $00FF0000) LSR 16
  PatchVersion.l = (VersionInfo & $0000FF00) LSR 8

  !ComData_LEA{comStr_ExePath,d0} : exeP.l = PutRegD0 : ExePath.s = Peek.s(exeP)
  !ComData_LEA{comStr_ExeFile,d0} : exeP.l = PutRegD0 : ExeFile.s = Peek.s(exeP)
  !ComData_LEA{comStr_LabelSearchString,d0} : labelP.l = PutRegD0 : LabelSearch.s = Peek.s(labelP)
  
  CLR.l d0
  !ComData_GetW{comWord_LabelRemark,d0}     : LabelRemark.w = PutRegD0
  !ComData_GetW{comWord_LabelAll,d0}        : LabelAll.w = PutRegD0
  !ComData_GetW{comWord_LabelCase,d0}       : LabelCase.w = PutRegD0
  !ComData_GetL{comLong_Label1VisableItemStore,d0}  : LabelPosition.l= PutRegD0
  !ComData_GetB{comByte_FuncOptimize,d0}    : FuncOptimize.l= PutRegD0

  file_WriteLine{fid,"; XTRA"}
  file_WriteLine{fid,"; Embedded .xtra Header"}
  file_WriteLine{fid,"; "}
  file_WriteLine{fid,"; General Info"}
  file_WriteLine{fid,"; -------------------------------------------------------"}
  file_WriteLine{fid,"; ExePath         = \\22"+ExePath+"\\22"}
  file_WriteLine{fid,"; ExeFile         = \\22"+ExeFile+"\\22"}
  file_WriteLine{fid,"; CreateIcon      = "+Str$(CreateIcon)}
  file_WriteLine{fid,"; Residents       = \\22"+residents+"\\22"}
  file_WriteLine{fid,"; "}
  file_WriteLine{fid,"; Compiler"}
  file_WriteLine{fid,"; -------------------------------------------------------"}
  file_WriteLine{fid,"; StringBuffer    = "+Str$(Peek.l(?stringbuffer))}
  file_WriteLine{fid,"; MakeSmallest    = "+Str$(MakeSmallest)}
  file_WriteLine{fid,"; FuncOptimize    = "+Str$(FuncOptimize)}
  file_WriteLine{fid,"; Version         = "+Str$(MajorVersion)+"."+Str$(MinorVersion)+"."+Str$(PatchVersion)}
  file_WriteLine{fid,"; NumberOfBuilds  = "+Str$(Peek.l(?number_of_builds))}
  file_WriteLine{fid,"; "}
  file_WriteLine{fid,"; Debugger"}
  file_WriteLine{fid,"; -------------------------------------------------------"}
  file_WriteLine{fid,"; CliArgs         = \\22"+cliargs+"\\22"}
  file_WriteLine{fid,"; StackSize       = "+Str$(Peek.l(?stacksize))}
  file_WriteLine{fid,"; RuntimeDebug    = "+Str$(RuntimeDebug)}
  file_WriteLine{fid,"; DebugInfo       = "+Str$(DebugInfo)}
  file_WriteLine{fid,"; CreateDbgFile   = "+Str$(CreateDbgFile)}
  file_WriteLine{fid,"; OverflowCheck   = "+Str$(OverflowCheck)}
  file_WriteLine{fid,"; AssemblerCheck  = "+Str$(AssemblerCheck)}
  file_WriteLine{fid,"; InterruptCheck  = "+Str$(InterruptCheck)}
  file_WriteLine{fid,"; AutoRun         = "+Str$(AutoRun)}
  file_WriteLine{fid,"; "}
  file_WriteLine{fid,"; Editor"}
  file_WriteLine{fid,"; -------------------------------------------------------"}
  file_WriteLine{fid,"; CursorLine      = "+Str$(CursorLine)}
  file_WriteLine{fid,"; CursorColumn    = "+Str$(CursorColumn)}
  file_WriteLine{fid,"; LabelSearch     = \\22"+LabelSearch+"\\22"}
  file_WriteLine{fid,"; LabelRemark     = "+Str$(LabelRemark)}
  file_WriteLine{fid,"; LabelAll        = "+Str$(LabelAll)}
  file_WriteLine{fid,"; LabelCase       = "+Str$(LabelCase)}
  file_WriteLine{fid,"; LabelPosition   = "+Str$(LabelPosition)}
  file_WriteLine{fid,"; "}
  file_WriteLine{fid,"; Blitz Objects"}
  file_WriteLine{fid,"; -------------------------------------------------------"}
  For i.l = 0 To Peek.w(?number_of_objects)-1
    name.s = "                                "
    GetRegD0 &name,i:JSR getobjectentry : a.l = PutRegD0
    name.s = Replace$(Peek.s(&name)," ","-")
    maxname.s = "; Max "+name
    If FLen(maxname)<18 Then maxname + LSet$(" ",18-FLen(maxname))
    file_WriteLine{fid,maxname+"= "+Str$(a)}
  Next

  file_WriteLine{fid,"; /XTRA"}
  Return
End Function

#DUMPFLG_CONSTANTS = $01
#DUMPFLG_VARS      = $02
#DUMPFLG_NEWTYPES  = $04
#DUMPFLG_MACROS    = $08
#DUMPFLG_FUNCTIONS = $10
#DUMPFLG_LABELS    = $20
#DUMPFLG_TOKENS    = $40
#DUMPFLG_LIBS      = $80


Function.l WriteDump{fid.l,dumpFlags.l,mode.l}
  MOVE.l realconstbase,d0            : constantbaseP.l  = PutRegD0 : If constantbaseP Then *constant.Constant_t = Peek.l(constantbaseP)
  !ComData_GetL{comPtr_VarBase,d0}   : varbaseP.l       = PutRegD0 : If varbaseP      Then *var.Var_t           = Peek.l(varbaseP)
  MOVE.l newtypebase,d0              : newtypebaseP.l   = PutRegD0 : If newtypebaseP  Then *typ.NewType_t       = Peek.l(newtypebaseP)
  MOVE.l labelbase,d0                : labelbaseP.l     = PutRegD0 : If labelbaseP    Then *label.Label_t       = Peek.l(labelbaseP)     ; was labelP fixed thats compile again  tomsmart1
  !ComData_GetL{comPtr_MacroBase,d0} : macrobaseP.l     = PutRegD0 : If macrobaseP    Then *mac.Macro_t         = Peek.l(macrobaseP)
  !ComData_GetL{comPtr_TokenBase,D0} : *token.tokendata = PutRegD0

  Select mode
    Case 0 ; binary hashmaps

    Default ; ASCII
      If dumpFlags&#DUMPFLG_CONSTANTS
        While *constant
          file_WriteLine{fid,"CONSTANT "+Peek.s(&*constant\nameA)+" $"+Hex$(*constant\value)}
          *constant = *constant\next_
        Wend
      End If

      If dumpFlags&#DUMPFLG_VARS
        While *var
          file_WriteLine{fid,"VAR "+Peek.s(&*var\nameA)+"."+Peek.s(&*var\typ\nameA)}
          *var = *var\next_
        Wend
      End If

      If dumpFlags&#DUMPFLG_NEWTYPES
        While *typ
          file_WriteLine{fid,"NEWTYPE "+Peek.s(&*typ\nameA)}
          *field.Field_t = *typ\fieldA
          If *field>4096 OR *field<0
            While *field
              If *field\indirection=1 Then prefix.s = "*" : Else prefix=""
              file_WriteLine{fid,"FIELD "+prefix+Peek.s(&*field\nameA)+"." + Peek.s(&*field\typ\nameA)+" "+Hex$(*field\offset)}
              *field = *field\next_
            Wend
          End If
          *typ = *typ\next_
        Wend
      End If

      If dumpFlags&#DUMPFLG_MACROS
        While *mac
          file_WriteLine{fid,"MACRO "+Peek.s(&*mac\nameA)}
          *mac = *mac\next_
        Wend
      End If

      If dumpFlags&#DUMPFLG_FUNCTIONS
        file_WriteLine{fid,"FUNCTION Function dump not supported yet!"}
      End If

      If dumpFlags&#DUMPFLG_LABELS ; <= same like constants!?
        file_WriteLine{fid,"LABEL Label dump not supported yet!"}
      End If

      If dumpFlags&#DUMPFLG_LIBS
        file_WriteLine{fid,"LIB Blitz Library dump not supported yet!"}
      End If

      If dumpFlags&#DUMPFLG_TOKENS ; <= all available tokens
        While *token
          name.s    = Peek.s(&*token\dat)
          help.s    = Peek.s(&*token\dat+FLen(name)+1)
          libid.l   = (*token\number LSR 7) &$FF
          tokenid.l = *token\number & $7F
          file_WriteLine{fid,"TOKEN "+Str$(libid)+"/"+Str$(tokenid)+" "+name+" "+help}
          *token = *token\next_token
        Wend
      End If
  End Select
End Function


Function.l DumpFile{filename.s,dumpFlags.l,mode.l}
  succ.l = False
  fid.l = file_Open{filename,#file_forcewrite}
  If fid>=0
    WriteDump{fid,dumpFlags,mode}
    file_Close{fid}
    succ.l = True
  End If
 Function Return succ
End Function




