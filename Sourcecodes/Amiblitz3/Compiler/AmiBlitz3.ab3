; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Blitz3:"
; ExeFile         = "Amiblitz3"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 20000
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 3.11.1
; NumberOfBuilds  = 602
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 64000
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 0
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 5256
; CursorColumn    = 21
; LabelSearch     = "make smallest"
; LabelRemark     = 0
; LabelAll        = 1
; LabelCase       = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 25
; Max GadgetList  = 5
; Max Shape       = 100
; Max Bank        = 5
; Max MenuList    = 5
; Max GTList      = 25
; Max BitMap      = 10
; Max Screen      = 5
; Max IntuiFont   = 5
; Max Window      = 25
; Max Palette     = 4
; Max BlitzFont   = 4
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max TagList     = 5
; Max Database    = 16
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: AmiBlitz3                                                             /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, AmigaOS4, MOS                         /
;/                                                                             /
;/ Date: 01.05.2022                                                            /
;/                                                                             /
;/ Authors: 1990...1996 Mark Silby                                             /
;/          1991...2003 Red When Excited                                       /
;/          2003...2009 Bernd Roesch, Sven Droege                              /
;/          2009...2016 The Opensource Team                                    /
;/          2019...     Sven Droege                                            /
;/                                                                             /
;/ Requirements: AmigaOS3.1+                                                   /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Compiler and framework for AmiBlitz3 programming language.                  /
;/                                                                             /
;/ Abstract:  (sorry, German only)                                             /
;/ AmiBlitz3 ist eine freie Entwicklungsumgebung fuer AmigaOS3.x und           /
;/ Kompatible. Um zu erlaeutern, was es mit AmiBlitz3 auf sich hat,            /
;/ muss man bei BlitzBasic beginnen.                                           /
;/                                                                             /
;/ BlitzBasic, spaeter BlitzBasic2, ist ein urspruenglich von Acidsoft und     /
;/ Red When Excited (RWE) fuer den Amiga entwickelter, umfangreicher           /
;/ und ein wenig eigenwilliger Basic-Dialekt.                                  /
;/ Trotz der Popularitaet, die dieser in den 90er Jahren erreichte, sah man    /
;/ sich bei Acidsoft nach der Commodore-Pleite und dem nachfolgenden           /
;/ Niedergang des Amiga Marktes dazu gezwungen,                                /
;/ die Entwicklung von BlitzBasic2 auf dem Amiga einzustellen und sich         /
;/ ausschliesslich einer Version fuer Windows-PCs zu widmen.                   /
;/                                                                             /
;/ Auf Bestreben von Bernd Roesch durfte die Amiga-Version disassembliert      /
;/ und weiterenwickelt werden. Um eine Verwechslung mit der PC-Version zu      /
;/ vermeiden, firmiert diese mittlerweile ueberarbeitete Amiga-Version seitdem /
;/ unter dem Namen AmiBlitz2.                                                  /
;/                                                                             /
;/ Mit der Umgestaltung und Modernisierung der Entwicklungsumgebung            /
;/ sowie der gesamten Dateistruktur erfolgte die konsequente Fortfuehrung      /
;/ der Namensgebung zu AmiBlitz3.                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////

OPTIMIZE 5                               ; don't use FPU (opt. 4)
SYNTAX 6                                 ; syntax strictness

Macro regs2stack                         ; helper macro
  MOVEM.l d0-d7/a0-a6,-(a7)
End Macro

Macro stack2regs                         ; helper macro
  MOVEM.l (a7)+,d0-d7/a0-a6
End Macro

NEWTYPE.environment
  lock_CurrentDir.l
  lock_ExePath.l
  signalPanicBitNum.l     ;panicbit
  signalPanicMask.l       ;panicmask
  signalStopBitNum.l     
  signalStopMask.l       
  ;
  *exeTask.Task
  *PEDTask.Task
  *msgportPED.MsgPort
  ;
  progdir.s
  ;
  _noCLI.b
  _noPED.b
  ;
  _runerror.b
End NEWTYPE
SHARED environment.environment

NEWTYPE.configuration
  localization.b
  OnePassCompiling.b

  clone_wbscreen.b
  use_wbscreen.b
  con_on_wb.b

  blitz3assign.s
  path_system.s
  path_blitzlibs.s
  path_residents.s
  path_baselibs.s
  path_utillibs.s
  path_oslibs.s
  path_cslibs.s
  path_userlibs.s
  path_includes.s
  pedfile.s
  ptr_seg_ped.l
  default_debugger.s
  ptr_seg_debugger.l
End NEWTYPE
SHARED config.configuration

NEWTYPE.libdata
  size_baselibs.l
  ptr_baselibs.l

  size_utillibs.l
  ptr_utillibs.l

  size_oslibs.l
  ptr_oslibs.l

  size_cslibs.l
  ptr_cslibs.l

  ptr_userlibs.l
End NEWTYPE
SHARED libdata.libdata




!initasm                                 ; some initial mumbo jumbo
!basic
WBStartup

;--- MorphOS Check to use the CacheClearE function because it is faster under MorphOS as CacheClearU
If FindResident_("MorphOS")
  PokeB ?MorphOS,1      ; set it to use CacheClear_E
Else
  PokeB ?MorphOS,0      ; set it to use CacheClear_U
EndIf

SHARED cli_verbose.l
SHARED CLIMode.l
cli_verbose          = 4
CLIMode              = False
MaxLen cli_tempstr.s = 1024
GetCurrentDirName_ &cli_tempstr,1024  ; get the current dir to restore it on exit
environment\progdir = Peek.s(&cli_tempstr)

XINCLUDE "/BlitzLibs/residents/LVO/LVO.ab3"   ; needed for remaining asm-parts
XINCLUDE "/Shared/common.ab3"
XINCLUDE "/Shared/preprocessor.include.ab3"
XINCLUDE "/Shared/ted.include.ab3"

XINCLUDE "dos.include.ab3"
XINCLUDE "file.include.ab3"
XINCLUDE "logging.include.ab3"


; -- Statement to log text into PEDs log
Statement log2PED{message.s, @level.b}
SHARED CLIMode, cli_verbose

  If cli_verbose>=level
    If CLIMode
      NPrint message
    Else
      !ComData_LEA{comFunc_LogPrint,D0} : tmpD0.l = PutRegD0

      If PeekL(tmpD0) <> 0
        tmpL.l = 0 : tmpW.w = 0
        message = "\\1B[42mAB3 " + message + "\\1B[40m"
        GetReg A1,&message  ; logtext
        GetReg D0,tmpW      ; logvalue0: libnumber
        GetReg D1,tmpL      ; include file name
        GetReg D2,tmpL      ; logvalue1: code line num
        GetReg D3,tmpL      ; pointer source line
        GetReg D4,tmpL      ; pointer tokenized source code
        !ComData_JSR{comFunc_LogPrint}
      Else
        ;error{"Log-function of PED not available for output: \\n" + message}
      EndIf
    End If
  End If
End Statement

Statement log2PED_HexDump{maddr.l, size.w}
  For imh.l = 0 To size Step 8
    memaddr.l = maddr + imh
    memdata.l = PeekL(memaddr)
    memdata2.l= PeekL(memaddr + 4)

    logtxt$ = Hex$(memaddr-maddr) + " (" + LSet$(Str$(imh),4) + ") # "
    logtxt$ + Hex$(memaddr) + ": " + Hex$(memdata)+" "+Hex$(memdata2)+"  "+CharStream{Peeks$(memaddr,8)}+" "
    logtxt$ + Str$(memdata) + "  " + Str$(memdata2)
    log2PED{logtxt$}
  Next
End Statement




.TOOLTYPES
; --
; -- check, if an assign-value was set via Tooltype
config\blitz3assign = dos_GetToolString{"ASSIGN",default_assign}
If config\blitz3assign <> ""
    *AssignSema.SignalSemaphore = FindSemaphore_(&config\blitz3assign)    ; does it already exist?
    If *AssignSema
      ObtainSemaphoreShared_ *AssignSema
    Else
      ; no, create one...
      *AssignSema = AllocVec_ (SizeOf.SignalSemaphore,#MEMF_PUBLIC|#MEMF_CLEAR)
      If *AssignSema
        InitSemaphore_ *AssignSema

        *AssignSema\ss_Link\ln_Name = AllocVec_(FLen(config\blitz3assign)+1,#MEMF_PUBLIC|#MEMF_CLEAR)
        If *AssignSema\ss_Link\ln_Name
          Poke.s  *AssignSema\ss_Link\ln_Name,config\blitz3assign
        End If
        *AssignSema\ss_Link\ln_Pri  = 1
        *AssignSema\ss_Link\ln_Type = #NT_SIGNALSEM

        AddSemaphore_ *AssignSema
        ObtainSemaphoreShared_ *AssignSema

      End If
    End If

  ; -- create our assign & config the directory variables
  mydir.s = dos_GetProgDir{"Sys:"}
  If NOT dos_CheckAssign{config\blitz3assign}
    dos_SetAssign{config\blitz3assign,mydir,False}
  EndIf
  If dos_CheckAssign{config\blitz3assign}
    If NOT dos_AddAssign{"LIBS:",dos_AddPart{config\blitz3assign,"Libs"}}
      error{"could not add LIBS:-assign: "+ config\blitz3assign + "/Libs"}
    EndIf
  EndIf

  config\default_debugger = dos_AddPart{config\blitz3assign,"Debug/DefaultDBug"}     ; /REDDebugger"}

  If dos_GetToolState{"INCLUDEDIR"} =-1 Then config\path_includes = dos_GetToolString{"INCLUDEDIR",dos_AddPart{config\blitz3assign , "Sourcecodes/Includes"}}

  config\path_includes  = dos_AddPart{config\blitz3assign, "Sourcecodes/Includes"}
  config\path_system    = dos_AddPart{config\blitz3assign, "System"}
  config\path_residents = dos_AddPart{config\blitz3assign, "BlitzLibs/Residents"}
  config\path_blitzlibs = dos_AddPart{config\blitz3assign, "BlitzLibs"}
  dos_CreateDir{config\path_blitzlibs}
  dos_CreateDir{config\path_userlibs}
  dos_CreateDir{config\path_residents}
  dos_CreateDir{config\path_system}
EndIf

; -- check, if there is an alternative PED-executable set via Tooltype
config\pedfile = dos_GetToolString{"EDITOR",dos_AddPart{config\path_system,"PED"}}

; -- check the default biglib files
If dos_GetToolState{"BASELIBS"} =-1 Then config\path_baselibs = dos_GetToolString{"BASELIBS",dos_AddPart{config\blitz3assign , "BlitzLibs/baseLibs"}}
If dos_GetToolState{"BASELIBS"} = 0
  dos_SetToolState{"BASELIBS",True}
  config\path_baselibs = dos_AddPart{config\blitz3assign , "BlitzLibs/baseLibs"}
EndIf
If dos_GetToolState{"UTILLIBS"} =-1 Then config\path_utillibs  = dos_GetToolString{"UTILLIBS",dos_AddPart{config\blitz3assign , "BlitzLibs/utilLibs"}}
If dos_GetToolState{"UTILLIBS"} = 0
  dos_SetToolState{"UTILLIBS",True}
  config\path_utillibs  = dos_AddPart{config\blitz3assign , "BlitzLibs/utilLibs"}
EndIf
If dos_GetToolState{"OSLIBS"}   =-1 Then config\path_oslibs   = dos_GetToolString{"OSLIBS"  ,dos_AddPart{config\blitz3assign , "BlitzLibs/OsLibs"}}
If dos_GetToolState{"OSLIBS"}   = 0
  dos_SetToolState{"OSLIBS",True}
  config\path_oslibs   = dos_AddPart{config\blitz3assign , "BlitzLibs/OsLibs"}
EndIf
If dos_GetToolState{"CSLIBS"}   =-1 Then config\path_cslibs   = dos_GetToolString{"CSLIBS"  ,dos_AddPart{config\blitz3assign , "BlitzLibs/CsLibs"}}
If dos_GetToolState{"CSLIBS"}   = 0
  dos_SetToolState{"CSLIBS",True}
  config\path_cslibs   = dos_AddPart{config\blitz3assign , "BlitzLibs/CsLibs"}
EndIf

config\path_userlibs = dos_AddPart{config\blitz3assign , "BlitzLibs/UserLibs"}

; -- check if One pass compiling is set as Tooltype to use big buffers for compiling  tomsmart1
config\OnePassCompiling = dos_GetToolState{"ONEPASSCOMPILING"}

; -- check screen settings for bringing PED-screen to back and to front after executing 
If dos_GetToolState{"CON_ONWB"} = True Then config\con_on_wb = True

If dos_GetToolState{"CLONE_WBSCREEN"}   = True
  config\clone_wbscreen = True : config\use_wbscreen = False
Else
  If dos_GetToolState{"USE_WBSCREEN"}   = True
    config\use_wbscreen = True : config\clone_wbscreen = False
  EndIf
EndIf

; -- LOCALIZATION
; -- used by CLIModeSupport, added here as it needs propriatary libraries. 
; -- LIBS:-assign is added right before
XINCLUDE "translation.include.ab3"      
If dos_GetToolState{"DISABLE_LOCALIZATION"}  = -1
  config\localization = False
Else
  config\localization = True
  !TRANS_INIT{"AmiBlitz3"}     ; init localization via translation.include
EndIf

If dos_GetToolState{"LOG_USED_BLITZLIBS"} = -1
  PokeB ?log_blitzlibs,1
EndIf



XINCLUDE "CLIModeSupport.ab3"
If dos_FromCLI{}
  CLIMode.l = True
  error_SetFlags{#error_stdout}
End If

; added here so the init is also available for the climode
; for create release exe (minimized exe)
 releaseexe.w               = False
 releasedbg_save.w          = 0
 releasemakesmall_save.w    = 0
 releasefuncoptimize_save.w = 0
 releasedebugger_save.w     = 0

; for compiler status info
 MaxLen comBaseStatus.s = 100
 MaxLen comstatusstr.s = 100 ; set the max leng of the comstatusstring because if it not set the string get partly trashed do the first compile from init to pass 1
 comBaseStatus  = !TRANS{"Initializing Compiler..."} ;default settings
 calcpro.l      = 0
 calcpro_old.l  = 0
 typ_old.l      = -1
 pass_old.l     = -1
 update_comstatus_gui.b = False ; for the first

; for .dbg file creation
#MAX_dbg_detokenlinesBufferSize = 131072                   ;was 65536  changed because we reduce detokenline size to MAX_Columns for the error info  tomsmart1
MaxLen dbg_detokenlinesBuffer.s = #MAX_dbg_detokenlinesBufferSize
dbg_fid.l = -1 ; no debug file id yet!

#defaultmaxerrorcount              = 99                    ; moved it to support the change of maxerrorcount in CLIMode  tomsmart1
PokeL ?maxerrorcount,#defaultmaxerrorcount                ; set the default value  tomsmart1
cli_sourcefile.s    = ""
If CLIMode
  ; We assume no error happened so far ...
  err.l      = False                                       ; indicate that an error has occured
  showhelp.l = False                                       ; show the CLI tool's help

  ; Set the default values of your CLI arguments.
  cli_progpath.s      = dos_GetProgDir{default_assign}    ; replaced hardcoded path  tomsmart1 2012 03 09
  cli_exefile.s       = ""
  cli_savefile.s      = ""
  cli_dumpfile.s      = ""
  cli_includepath.s   = ""
  cli_blitzlibpath.s  = ""
  cli_debuginfo.l     = False
  cli_run.l           = False
  cli_dumpflags.l     = $FFFFFFFF
  cli_info.s          = ""
  cli_release.l       = False
  cli_numargs.l       = dos_GetNumArgs{}
  cli_gui.l           = False
  cli_dumpform.l      = 1                     ; 0 = bin, 1 = ASCII
  cli_verbose.l       = 1
  cli_comdbgflags.l   = $00000000             ; added to support compiler and debugger settings via CLI  tomsmart1
  cli_comstrbufsize.l = 0
  cli_exestacksize.l  = 0
  cli_maxerrors.l     = 0                     ; added to make maxerrorcount changable in CLIMode  tomsmart1
  config\OnePassCompiling    = False
  If cli_numargs = 0 Then showhelp = True

  ; Get the CLI arguments
  Repeat
    arg.s = dos_GetNextArg{}                               ; get the next CLI argument
    larg.s = LCase$(arg)                                   ; lower case the option string
    If Left$(larg,1)="-" Then larg = Right$(larg,FLen(larg)-1)
    Select larg
      Case "s" : larg="source"
      Case "e" : larg="exe"
      Case "d" : larg="debug"
      Case "r" : larg="release"
      Case "h" : larg="help"
      Case "v" : larg="verbose"
      Case "1" : larg="1pass"
    End Select

    Select larg
      Case "exe"      : cli_exefile     = dos_GetNextArg{}
      Case "source"   : cli_sourcefile  = dos_GetNextArg{}
      Case "save"     : cli_savefile    = dos_GetNextArg{}
      Case "debug"    : cli_debuginfo   = True
      Case "run"      : cli_run         = True
      Case "release"  : cli_release     = True
      Case "ped"      : cli_gui         = True
      Case "dform"    : cli_dumpform.l  = Vallong(dos_GetNextArg{})
      Case "dump"     : cli_info        = LCase$(dos_GetNextArg{})
                        cli_dumpfile    = dos_GetNextArg{}
                        cli_dumpflags   = $0
                        If Instr(cli_info,"all"  ) Then cli_dumpflags | $FFFFFFFF
                        If Instr(cli_info,"token") Then cli_dumpflags | #DUMPFLG_TOKENS
                        If Instr(cli_info,"label") Then cli_dumpflags | #DUMPFLG_LABELS
                        If Instr(cli_info,"var"  ) Then cli_dumpflags | #DUMPFLG_VARS
                        If Instr(cli_info,"const") Then cli_dumpflags | #DUMPFLG_CONSTANTS
                        If Instr(cli_info,"func" ) Then cli_dumpflags | #DUMPFLG_FUNCTIONS
                        If Instr(cli_info,"macro") Then cli_dumpflags | #DUMPFLG_MACROS
                        If Instr(cli_info,"type" ) Then cli_dumpflags | #DUMPFLG_NEWTYPES
                        If Instr(cli_info,"lib"  ) Then cli_dumpflags | #DUMPFLG_LIBS
                        If cli_dumpflags = $0
                         err=True
                         NPrint "\\1b[1m*** ERROR: Invalid flags for dumpfile \\22",cli_info,"\\22 specified!\\1b[0m"
                        End If
      ;check cli compiler settings args  tomsmart1
      Case "setcom"   : cli_setcom.s    = LCase$(dos_GetNextArg{})
                        cli_comflags.l  = $0
                        If Instr(cli_setcom,"icon"  ) Then cli_comflags | #CLI_COMSETICONFLAG     ; create Icon
                        If Instr(cli_setcom,"small" ) Then cli_comflags | #CLI_COMSETSMALLFLAG    ; make smallest code
                        If Instr(cli_setcom,"func"  ) Then cli_comflags | #CLI_COMSETFUNCFLAG     ; use Functionoptimizer
                        If Instr(cli_setcom,"ldbg"  ) Then cli_comflags | #CLI_COMSETLDBGFLAG     ; link debug info (Symbols) to the exe
                        If Instr(cli_setcom,"dbgf"  ) Then cli_comflags | #CLI_COMSETDBGFFLAG     ; create a .dbf file
                        If (cli_comflags & #CLI_COMSETALLFLAGS) = 0                               ; test if args are correct
                          err=True                                                                ; no
                          NPrint "\\1b[1m*** ERROR: Invalid flags for setcom \\22",cli_setcom,"\\22 specified!\\1b[0m"
                        Else
                          cli_comdbgflags | cli_comflags                                          ; yes then add it
                        EndIf
      ;check cli debugger settings args  tomsmart1
      Case "setdbg"   : cli_setdbg.s    = LCase$(dos_GetNextArg{})
                        cli_dbgflags.l  = $0
                        If Instr(cli_setdbg,"auto" ) Then cli_dbgflags | #CLI_DEBUGAUTOFLAG       ; autorun
                        If Instr(cli_setdbg,"irq"  ) Then cli_dbgflags | #CLI_DEBUGIRQFLAG        ; interrupt check
                        If Instr(cli_setdbg,"asm"  ) Then cli_dbgflags | #CLI_DEBUGASMFLAG        ; assembler check
                        If Instr(cli_setdbg,"ofl"  ) Then cli_dbgflags | #CLI_DEBUGOFLFLAG        ; overflow check
                        If (cli_dbgflags & #CLI_DEBUGALLFLAGS) = 0                                ; yes then add it
                          err=True                                                                ; no
                          NPrint "\\1b[1m*** ERROR: Invalid flags for setdbg \\22",cli_setdbg,"\\22 specified!\\1b[0m"
                        Else
                          cli_comdbgflags | cli_dbgflags                                          ; yes then add it
                        EndIf
      Case "strbufsize": cli_comstrbufsize = Vallong(dos_GetNextArg{})
      Case "stacksize" : cli_exestacksize  = Vallong(dos_GetNextArg{})
      Case "maxerrors" : cli_maxerrors     = Vallong(dos_GetNextArg{})                              ; added to make the maxerrorcount changeable in CLI MODE  tomsmart1
                         If ((cli_maxerrors > 0) AND (cli_maxerrors <4097))                        ; check
                           PokeL ?maxerrorcount,cli_maxerrors
                         EndIf
      Case "1pass"     : config\OnePassCompiling = True   ; added to use big buffers for compile so only 1 pass is needed  tomsmart1
      Case "verbose"   : cli_verbose      = Vallong(dos_GetNextArg{})
      Case "help"      : showhelp         = True             ; show the help and quit
      Default
        If arg><""
          NPrint "\\1b[1m*** ERROR: Unknown option \\22",arg,"\\22 specified!\\1b[0m"
          err = True
        End If
    End Select
  Until arg = "" OR err=True          ; until we processed all arguments

  ; Show the help if something went wrong or help was requested
  If err><False OR showhelp = True
    If showhelp
      NPrint "AmiBlitz ",Peek.s(?myversion)
      NPrint "\\nSyntax: AmiBlitz3 [options]"
      NPrint "\\nOptions:"
      NPrint "  -(s)ource <file>    : input source code filename (bb2, ab2 or ab3)"
      NPrint "  -(e)xe <file>       : output executable filename"
      NPrint "  -(d)ebug            : compile and start runtime debugger"
      NPrint "  -(r)elease          : create release executable (size optimized)"
      NPrint "  -run                : run compiled program"
      NPrint "  -dump <info> <file> : dump compiler internals to file"
      NPrint "                        (info=all|token|label|var|func|const|macro|type|lib)"
      NPrint "  -setcom <options>   : set compiler settings (options=icon|small|func|ldbg|dbgf)"       ; added  tomsmart1
      NPrint "  -setdbg <check>     : set debugger settings (check=auto|irq|asm|ofl)"                  ; added  tomsmart1
      NPrint "  -strbufsize <n>     : set the string buffer size of the compiler"                      ; added  tomsmart1
      NPrint "  -stacksize <n>      : set the stacksize for the exe if it run/debug"                   ; added  tomsmart1
      NPrint "  -maxerrors <n>      : set maxerrorcounter of the compiler (1-4096; default=99)"        ; added  tomsmart1
      NPrint "  -(1)pass            : use large buffers for compile"
      NPrint "  -dform <n>          : format of compiler internals dump (0=bin, 1=ASCII; default=1)"
      NPrint "  -PED                : start AmiBlitz3 IDE (PED)"
      NPrint "  -save <file>        : re-save source code (convert format, if needed)"
      NPrint "  -(v)erbose <n>      : set verbose level (0, 1 or 2; default=1)"
      NPrint "  -(h)elp             : show this help"
      NPrint "\\nExample:"
      NPrint "  AmiBlitz3 -s \\22DH0:Sourcecodes/MyProgram.ab3\\22 -e RAM:MyProgram.exe"
      NPrint "\\nNote: To start the AmiBlitz3 IDE, run from Workbench or with -PED option."
    End If
    Pop If : Pop If
    Goto abnormal_exit
  End If

  If cli_gui        Then CLIMode = False : error_SetFlags{#error_requester}
Else
  _wbArgs.b = dos_GetWBNumArgs{}
  If _wbArgs
    ; parameter 0 is the name of the executable
    ; all furher parameters are the command line options
    sdir.s = dos_GetStartDir{""}
    sfil.s = dos_GetWBArg{1}
    If sfil <> ""
      cli_sourcefile = dos_AddPart{sdir,sfil}
    EndIf
  EndIf
End If

PokeL ?CLIMode,CLIMode

; --
; -- Konstanten- und Variableninitialisierung
.DEFINITIONS
  #assign_fulltypecheck       = 0                            ; if 1 report long to word or other size reduction as error.
  #function_typecheck         = 1
  #function_support_returntype= 1
  #continue_on_error          = 1
  #maxincludes                = 128
  #64bitconstant              = 0
  #funcscan                   = 0                          ; if set to "1" functions are added at beginning
  #debugmacro                 = 1                          ; macros can be debugged
  #more6string                = 1                          ; more than 6 strings can be used in function calls
  #errorconstant              = 0                          ; constants declared twice check
  #types64                    = 1                          ; types can use 64kb
  #longbranch                 = 1                          ; if 1 then we have no 32kb limit
  #stopignore                 = 1                          ; ignore "STOP" on release build
  #debugtrap                  = 0                          ; only use if you want debug the trap#15 compile feature
  #fpudebug                   = 1                          ; allow fpu code for debugger
  #optibreak                  = 0                          ; set breakpoints on all optimzed positions
  #moremem                    = 40
  #isfunc                     = $21                        ; increase if morepars than 14
  #funcentry_extend           = 16+48                      ;+16 need for 10 pars +44 need for 10 par long of type addr and return type +4 gap for maybe later 4 par enhance
  #funcstruct_returntype      = $2a
  #funcstruct_parametertype   = $2e
  #doublecheck                = $00080d64

  #USENEWCACHECLEAR_U         = 0                          ; switch to use the new and faster CachClear, but it is not save only for testing !
  ; removed #USECACHECLEAR_E because we now use a detection for MorphOS to set the use of CacheClearE else we use CacheClearU (because on AOS4 it crashs with CacheClearE)!


  #opcode_TRAP0      = $4E40
  #opcode_NOP        = $4E71
  #opcode_NOP2       = $4E714E71
  #opcode_RTS        = $4E75
  #opcode_JSR        = $4EB9
  #opcode_JMP        = $4EF9
  #opcode_BRA        = $6000
  #opcode_BSR        = $6100
  #opcode_MOVEQ0D0   = $7000

  #TokenID_NEWTYPE   = $8001 ;-$7FFF
  #TokenID_End       = $8002 ;-$7FFE
  #TokenID_Goto      = $8005 ;-$7FFB
  #TokenID_Gosub     = $8006 ;-$7FFA
  #TokenID_Return    = $8007 ;-$7FF9
  #TokenID_Statement = $8008 ;-$7FF8
  #TokenID_Function  = $8009 ;-$7FF7
  #TokenID_If        = $800b ;-$7FF5
  #TokenID_While     = $800c ;-$7FF4
  #TokenID_Macro     = $800d ;-$7FF3
  #TokenID_Select    = $800e ;-$7FF2
  #TokenID_INCLUDE   = $8012 ;-$7FEE
  #TokenID_XINCLUDE  = $8013 ;-$7FED
  #TokenID_SYNTAX    = $8014 ;-$7FEC
  #TokenID_For       = $8016 ;-$7FEA
  #TokenID_To        = $8018 ;-$7FE8
  #TokenID_Step      = $8019 ;-$7FE7
  #TokenID_CNIF      = $801C ;-$7FE4
  #TokenID_CSIF      = $801D ;-$7FE3
  #TokenID_CELSE     = $801E ;-$7FE2
  #TokenID_CEND      = $801F ;-$7FE1
  #TokenID_Then      = $8021 ;-$7FDF
  #TokenID_Else      = $8022 ;-$7FDE
  #TokenID_Dc        = $8025 ;-$7FDB
  #TokenID_SizeOf    = $802F ;-$7FD1
  #TokenID_SetInt    = $8030 ;-$7FD0
  #TokenID_ABCD      = $803C ;-$7FC4
  #TokenID_Chip      = $807F ;-$7F81
  #TokenID_Not       = $8089 ;-$7F77
  #TokenID_BSS       = $80AD ;-$7F53
  #TokenID_List      = $80B3 ;-$7F4D
  #TokenID_SetErr    = $80B4 ;-$7F4C
  #TokenID_Ern       = $80B6 ;-$7F4A
  #TokenID_Addr      = $80B8 ;-$7F48
  #TokenID_Pi        = $80BA ;-$7F46
  #TokenID_Repeat    = $80BB ;-$7F45
  #TokenID_Maximum   = $80C4 ;-$7F3C
  #TokenID_On        = $80C5 ;-$7F3B
  #TokenID_Off       = $80C6 ;-$7F3A
  #TokenID_Used      = $80D1 ;-$7F2F
  #TokenID_Object    = $80D7 ;-$7F29

  #TokenID_KEEP      = $80DA ;


  #TokenID_Null      = $B594                      ; TokenID of NULL from Lib 107 token 20  (was token 1  = $B581) to overwrite by the compiler!
  #TokenID_New       = $C982                      ; TokenID of New from Lib 147 token "New" ($4982; LotanSystem)

  Dim incdim.s (#maxincludes)
  Dim incline.l(#maxincludes)

  hashsize                    EQU $3ff                     ;$ff=256,$1ff=512,$3ff=1024,$7ff=2048,$fff=4096


; --
; -- Macro definitions
.MACROS

Macro clear_instructionTable
  LEA instructionTable,a0
  MOVE.l #labelhash-instructionTable,d0 : ASR.l #2,d0 : SUBQ.l #1,d0
 'l10
    CLR.l (a0)+
    SUBQ.l #1,d0
  BNE 'l10
End Macro

Macro hashalgo                                             ;d1 currentchar d0 hashvalue
  MULS.w #5,d0                                             ;important for fast hash speed
  ADD.l d1,d0
End Macro


Macro newcalc
  MOVE.l destpointer,a1
  MOVE.w ##opcode_RTS,(a1)+                               ; write 2x RTS
  MOVE.w ##opcode_RTS,(a1)+

  MOVEQ #0,d1
  MOVE.w (a0)+,d1

  CMP.l #$303c,d1 : BNE 'nw1                              ;move.w    ;d0
    MOVE.w (a0)+,d0
    CMP.w #$48c0,(a0) : BNE 'nw2                          ;ext.l
      EXT.l d0
      ADDQ.l #2,a0
      BRA 'nw2
 'nw1
    CMP.l #$323c,d1 : BNE 'nw1_w                          ;move.w     ;d1
      MOVE.w (a0)+,d1
      CMP.w #$48c1,(a0) : BNE 'nw2                        ;ext.l
        EXT.l d1
        ADDQ.l #2,a0
        BRA 'nw2
   'nw1_w
      CMP.l #$203c,d1 : BNE.s 'nw2_w                      ;move.l #,d0
        MOVE.l (a0)+,d0
        BRA 'nw2
     'nw2_w
      ;   CMP.l #$243c,d1                                 ;move.l #,d2
      ;   BNE 'nw2_d2
      ;   MOVE.l (a0)+,d2
      ;BRA 'nw2
     'nw2_d2
      CMP.l #$223c,d1 : BNE.s 'Fals`@                     ;move.l #,d1
        MOVE.l (a0)+,d1
 'nw2
;   CMP.w #$243c,(a0) : BNE.s 'nod2`@                     ;no d2 load
;   MOVE.l 2(a0),d2
;   ADDQ.l #6,a0
 'nod2`@
  CMP.w #$223c,(a0) : BNE.s 'nod1`@                       ;no d1 load
    MOVE.l 2(a0),d1
    ADDQ.l #6,a0
 'nod1`@
;   CMP.w #$d081,(a0) : BNE.s 'noadd_l_d1                 ;no add l d1,d0
;   ADD.l d1,d0
;   ADDQ.l #2,a0

; 'noadd_l_d1
  CMP.w #$d0bc,(a0) : BNE.s 'noadd_i_d0                   ;no ADD.l #,d0
    ADDQ.l #2,a0
    ADD.l (a0)+,d0
    BRA 'nosub_w_d2
 'noadd_i_d0

  CMP.w #$90bc,(a0) : BNE.s 'nosub_i_d0                   ;no SUB.l #,d0
    ADDQ.l #2,a0
    SUB.l (a0)+,d0
    BRA 'nosub_w_d2
 'nosub_i_d0

  CMP.w #$8081,(a0) : BNE.s 'noor_d1_d0                   ;no or.l d1,d0
    ADDQ.l #2,a0
    OR.l d1,d0
    BRA 'nosub_w_d2
 'noor_d1_d0

  CMP.w #$d07c,(a0) : BNE.s 'noadd_w_d1                   ;no add w #,d0
    ADDQ.l #2,a0
    ADD.w (a0)+,d0
 'noadd_w_d1

  CMP.l #$4c3c0800,(a0) : BNE.s 'nomul_l_d1               ; no mul.l #,d0
    MOVE.l d1,-(a7)
    ADDQ.l #4,a0
    MOVE.l (a0)+,d1
    MULS.l d1,d0
    MOVE.l (a7)+,d1
 'nomul_l_d1

  CMP.w #$94bc,(a0) : BNE.s 'nosub_i_d2                   ;no sub l #,d2
    ADDQ.l #2,a0
    SUB.l (a0)+,d2
 'nosub_i_d2

  CMP.w #$9081,(a0) : BNE 'nosub_l_d1
    SUB.l d1,d0                                             ;no sub l d1,d0
    ADDQ.l #2,a0
 'nosub_l_d1
;   CMP.w #$9041,(a0)
;   bne 'nosub_w_d2
;   SUB.w d1,d0                                             ;no sub w d1,d0
;   ADDQ.l #2,a0

; 'nosub_w_d1
;   CMP.w #$9282,(a0)
;   BNE 'nosub_l_d2
;   SUB.l d2,d1                                             ;no sub l d2,d0
;   ADDQ.l #2,a0

; 'nosub_l_d2
;   CMP.w #$9242,(a0)
;   BNE'nosub_w_d2
;   SUB.w d2,d1                                             ;no sub w d2,d1
;   ADDQ.l #2,a0
 'nosub_w_d2

  CMP.w #$4480,(a0) : BNE.s 'noneg`@                        ;no neg
    NEG.l d0
    ADDQ.l #2,a0
 'noneg`@

  CMP.w #$48c0,(a0) : BNE 'noext                            ; noext
    EXT.l d0
    ADDQ.l #2,a0
 'noext

  CMP.w #$b081,(a0) : BNE 'nocmp                            ; nocmp
    ADDQ.l #2,a0
    CMP.w #$57c0,(a0) : BNE 'se1
      CMP.l d1,d0
        SEQ d0
      BRA 'sw1
   'se1
    CMP.w #$56c0,(a0) : BNE 'Fals`@
      CMP.l d1,d0
        SNE d0
   'sw1
    EXT.w d0
    ADDQ.l #6,a0
 'nocmp

  CMP.w ##opcode_RTS,(a0) : BNE 'Fals`@                    ; is last instruction
    TST.w regnum : BNE 'Fals`@
      MOVEQ #1,d1
      BRA.s 'ok`@
 'Fals`@
  MOVEA.l forthsp(PC),A0
  MOVEQ #0,d1
 'ok`@
End Macro


Macro test_for_letter
  ;-- old tstalpha func
  ;-- tst if d0 is alphabetic
  ;-- return z-flag set if yes
  CMP.w #"z",D0 : BHI 'lab2a`@
  CMP.w #"A",D0 : BCS 'lab2a`@
  CMP.w #"a",D0 : BCC 'lab1a`@
  CMP.w #"Z",D0 : BHI 'lab1a`@
 'lab1a`@
  CMP.w D0,D0
 'lab2a`@
End Macro

Macro test_for_literal
  ;-- tst if d0 is numeric
  ;-- return z-flag set if yes
  CMP.w #"0",D0 : BCS.w 'lab1`@
  CMP.w #"9",D0 : BHI.w 'lab1`@
  CMP.w D0,D0
 'lab1`@
End Macro

Macro test_for_commacolon
  ;-- tst id d0 is ':' or ','
  ;-- return z-flag set if yes
  TST.w D0      : BEQ.w 'lab1`@
  CMP.w #":",D0 : BEQ.w 'lab1`@
  CMP.w #",",D0
 'lab1`@
End Macro




Macro fget
  MOVEQ #0,d0

 'laba1`@
    MOVE.l a5,lastsourcepos
    MOVE.b (a5)+,d0
    TST.w instringon : BNE 'laba2`@
    CMP.b #" ",d0 : BEQ 'laba1`@   ; 32 " "
    CMP.b #";",d0 : BNE 'laba2`@
        MOVEQ #0,d0
 'laba2`@
  MOVE.w d0,lastchar
End Macro

Function.s Get_Libinfo{addr_libdata.l}
  ;-- diese Funktion holt aus der nativen lib im Speicher den ersten Tokennamen
  If addr_libdata = 0
    error{"INTERNAL: \\__THIS_FUNCTION: Invalid pointer!"}
    Function Return ""
  End If

  lib_ab2.b = False : lib_os.b = False
  skip.l = 0
  addr_counter.l = addr_libdata + 4 ;start after libnum, maybe better start at $80
  Repeat
    mem.l = PeekL(addr_counter)
    addr_counter + 2
    If (mem = $0000ffff) Then lib_ab2 = True : skip = 8
    If (mem LSR 16) = $ffe2
      lib_os = True
      skip = 10
      If Peek$(addr_counter + skip) = "" Then skip + 4
    EndIf
  Until (lib_ab2 = True OR lib_os = True) OR (addr_counter > addr_libdata + $400)

  If (addr_counter > addr_libdata + $400)
    Function Return ""
  Else
    Function Return Peek$(addr_counter + skip)
  EndIf
End Function



;d2 mode  1=byte 2 =word 3=long 4=quick 5=float  bit 15 newtype
;a3=current instruction struct
;34(a3)=Instruction Token

;SECTION "Segment0",CODE
;cnop 0,4
       ;labelbase   $0
                    ; $4 mode 0 = label 1 = constant
                    ; $8 addr/label value/constant
                    ; $c nexthash
                    ; $12 Bytecount
                    ; $13 name

       ;templabel   ; $0 next
                    ; $4 addr in code
                    ; $8 = resultmode 5 = word
                    ; $a
                    ; $e templabelsize
                    ; $10 addr in source or short string
       ;variable    ; $0
                    ; $4 offset of a5
                    ; $8 size
                    ; $a type addr add+4 for findvariable2 to find offset for Newtype
      ;typestruct
      ;             ; $4 Adress to typeitemlist or 1-7 if no structure
                    ; $8 size of newtype
      ;typeitemlist
                    ; $0 * nexttypeentry
                    ; $4.w Offset
                    ; $6
                    ; $8
                    ; $a addr to variable
                    ; $e name

; ------------------------------------------ BEGIN OF MAINPROGRAM -------------------------------
.MAINPROGRAM     ; was actual begin org source
  ;
  ;OKAY, Here it is - The actual compiler!
  ;
  ;
  ; new >
  !asm
  MOVEA.l _execbase,A6

  MOVEM.l d0/a0,-(a7)

  ;-- init chartab
  MOVEQ #127,d0
  LEA chartab,a0
 'l12
    MOVE.b #1,128(a0)
    CLR.b (a0)+
  DBF d0,'l12
  LEA chartab,a0
  MOVE.b #1,(a0)
  MOVE.b #1,","(a0)
  MOVE.b #1,";"(a0)
  MOVE.b #1,":"(a0)
  MOVE.b #1,"("(a0)
  MOVE.b #1,")"(a0)
  MOVE.b #1,"="(a0)
  MOVE.b #1,"+"(a0)
  MOVE.b #1,"-"(a0)
  MOVE.b #1,"*"(a0)
  MOVE.b #1,"/"(a0)
  MOVE.b #1,"$"(a0)
  MOVE.b #1,"%"(a0)
  MOVE.b #1,"."(a0)
  MOVE.b #1,"["(a0)
  MOVE.b #1,"]"(a0)
  MOVE.b #1,"{"(a0)
  MOVE.b #1,"}"(a0)
  MOVE.b #1,"\"(a0)
  MOVE.b #1,">"(a0)
  MOVE.b #1,"<"(a0)
  MOVE.b #1,"&"(a0)
  MOVE.b #1,"|"(a0)
  MOVE.b #1,"^"(a0)
  MOVE.b #1,127(a0)   ;tilde
  MOVE.w #$0101,1(a0)

  ;-- init instructionTable
  !clear_instructionTable

  ;-- init allowtab
  LEA allowtab,a0
  MOVE.l #255,d0
 'la1
    CLR.b (a0)+
  DBF d0,'la1
  LEA allowtab,a0
  MOVE.b #1,$7d(a0)   ; }
  MOVE.b #1,$7c(a0)   ; pipe
  MOVE.b #1,$44(a0)   ; D
  MOVE.b #1,$45(a0)   ; E
  MOVE.b #1,$b9(a0)   ;
  MOVE.b #1,$89(a0)
  MOVE.b #1,$ce(a0)
  MOVE.b #1,$cf(a0)
  MOVE.b #1,$d0(a0)
  MOVE.b #1,$cd(a0)
  MOVEQ #0,d0

  MOVEM.l (a7)+,d0/a0

  !basic
  *eb.ExecBase = execbase
  *compilerTask.Task = *eb\ThisTask

  PokeL ?mempool, CreatePool_(#MEMF_CLEAR,80000,80000)
  If PeekL(?mempool) = 0 Then Goto shutdown_compiler

  PokeL ?_dosbase, OldOpenLibrary_("dos.library")
  If PeekL(?_dosbase) = 0 Then Goto shutdown_compiler

  PokeL ?_mathffpbase, OldOpenLibrary_("mathffp.library")
  If PeekL(?_mathffpbase) = 0 Then Goto shutdown_compiler

  !asm

  MOVE.l #MIN_STACKSIZE,stacksize

  ; --
  ; -- get the last token of systemlib
  MOVEQ.l #$00,D0
  LEA tokens,A0
 'loop
    ADDQ.w #1,D0
    MOVE.l (A0),D1
    BEQ.w 'gotlast
      MOVEA.l D1,A0
  BRA.w 'loop
 'gotlast
  MOVE.l A0,end_of_tokenlist

  JSR make_AssemblerTable

  !basic
  PokeL ?constpcat, AllocMem_(PeekL(?constmaxpc),#MEMF_CHIP)
  If PeekL(?constpcat) = 0 Then Goto shutdown_compiler
  PokeL ?constlibat, PeekL(?constpcat) + PeekL(?constmaxpc)

  ;-- init macrobuffer
  ;-- macrobuffersize is 4 bytes more to store the size in the first 4 bytes :-)
  If PeekL(?macrobuffer_size) < #DEFAULT_MACROBUFFERSIZE Then PokeL ?macrobuffer_size, #DEFAULT_MACROBUFFERSIZE
  tmpL.l = AllocMem_(PeekL(?macrobuffer_size) + 4, #MEMF_PUBLIC)
  If tmpL = 0 Then Goto shutdown_compiler
  PokeL tmpL, PeekL(?macrobuffer_size) + 4
  PokeL ?ptr_macrobuffer_begin, tmpL + 4
  PokeL ?ptr_macrobuffer_end  , tmpL + 4 + PeekL(?macrobuffer_size)

  If CLIMode
    succ.l = InitEmulatedPED{}
    If succ = False Then Goto shutdown_compiler
  Else
    config\ptr_seg_ped = LoadSeg_(config\pedfile)
    If config\ptr_seg_ped = 0
      error{!TRANS{"Can't load the Editor:\\n"} + config\pedfile + !TRANS{"\\nProgram will quit now."} }
      Goto shutdown_compiler
    EndIf

    ; --
    ; -- calculate entryaddress for starting segment (BPTR)
    ; --
    GetRegD0 config\ptr_seg_ped
    !asm
    MOVEA.l D0,A2 : ADDA.l A2,A2 : ADDA.l A2,A2
    LEA teddata,A1
    MOVE.l #"TEDY",D1 : JSR 4(A2)                            ; Run PED, TODO: use Basic "Call"
    MOVE.l A0,ped_startup_addr                               ; PED returns address of routine "startup_code"
    MOVE.l A1,comdata                                        ; PED returns address of comdata-area in A1
    !basic

    !ComData_GetW{comWord_PEDIsAvailable,D0} : tmpL.l = PutRegD0
    If tmpL = 0 Then Goto shutdown_compiler

    If tmpL <> #ComDataVersionID
      error{!TRANS{"Old version of the Editor found at:\\n"} + config\pedfile + !TRANS{"\\nProgram will quit now."} }
      Goto shutdown_compiler
    EndIf
  EndIf
  !ComData_GetL{comData_Magic,D0} : tmpL.l = PutRegD0        ;"~::~",D0    ; replace with a constant  tomsmart1 2012 03 09
  If tmpL <> #MagicIdentifier_Long
    Goto shutdown_compiler
  EndIf

  ; --
  ; -- extent_comdatas:
  ; --
  !asm
  !ComData_SetL{comPtr_Trap15                    ,#directTrap15}
  !ComData_SetL{comPtr_DirectBuffer              ,#directbuffer}
  !ComData_SetL{comPtr_MacroBase                 ,#macrobase}
  !ComData_SetL{comPtr_VarBase                   ,#varbase}
  !ComData_SetL{comPtr_InstrBase                 ,#instructionTable}
  !ComData_SetL{comPtr_LibPointer                ,#libpointer}
  !ComData_SetL{comPtr_CompilerVersion           ,#myversion}
  !ComData_SetL{comPtr_VersionInformation        ,#versioninformation}
  !ComData_SetL{comPtr_NumberOfBuilds            ,#number_of_builds}
  !ComData_SetL{comFunc_SaveSource               ,#ab3_SaveSource}
  !ComData_SetL{comFunc_LoadSource               ,#ab3_LoadSource}
  !ComData_SetL{comFunc_ClearSource              ,#ab3_ClearSource}
  !ComData_SetL{comFunc_CalculatExpression       ,#menu_calculator}
  !ComData_SetL{comPtr_CalculatorExpressionString,#str_calcexpression}
  !ComData_SetL{comFunc_BackupXtraData           ,#BackupXtraData}
  !ComData_SetL{comFunc_RestoreXtraData          ,#RestoreXtraData}
  !ComData_SetL{comFunc_GetObjectEntry           ,#getobjectentry}
  !ComData_SetL{comFunc_StoreMaxObjects          ,#storemaxobjects}
  !ComData_SetL{comFunc_ReloadResidentsForPED    ,#ReloadResidentsForPED}
  !ComData_SetL{comFunc_FreeClearResidentsForPED ,#FreeClearResidentsForPED}
  !ComData_SetL{comPtr_Residents_Table           ,#residents_table}
  !ComData_SetL{comPtr_StringBuffer_Long         ,#stringbuffer}
  !ComData_SetL{comPtr_Stacksize_Long            ,#stacksize}
  !ComData_SetL{comPtr_Create_IconFile_Word      ,#set_create_iconfile}
  !ComData_SetL{comPtr_Create_DebugFile_Word     ,#set_create_dbgfile}
  !ComData_SetL{comPtr_Link_DebugInfo_Word       ,#set_link_debuginfo}
  !ComData_SetL{comPtr_Make_SmallestCode_Word    ,#set_make_smallestcode}
  !ComData_SetL{comPtr_FuncOptimize_Word         ,#set_FuncOptimize}
  !ComData_SetL{comPtr_Use_Debugger_Word         ,#set_use_debugger}
  !ComData_SetL{comPtr_Autorun_Word              ,#set_autorun}
  !ComData_SetL{comPtr_InterruptCheck_Word       ,#set_interruptcheck}
  !ComData_SetL{comPtr_AssemblerCheck_Word       ,#set_assemblercheck}
  !ComData_SetL{comPtr_OverflowCheck_Word        ,#set_overflowcheck}
  !ComData_SetL{comPtr_Number_of_Objects_Word    ,#number_of_objects}
  !ComData_SetL{comPtr_MaxObjects_Value_Word     ,#maxobjects_value}
  !ComData_SetL{comPtr_MaxObject_Pos_Word        ,#maxobject_pos}
  !ComData_SetL{comPtr_CLIArgumentsString        ,#str_cliarguments}
  !basic

  ; --
  ; -- load all baselibs, utillibs, cslibs, oslibs and userlibs
  ; --
  log2PED{"Loading Blitzlibs...",3}
  Gosub scan_for_userlibs
  Gosub load_all_libraries

  !asm
  MOVE.l #$FFFFffff,linenumat   ; was -1
  BSR.w init_buffers
  !basic

  ; --
  ; -- grab a panic bit for a signal mask with -1 no preference for a special signal bit
  ; -- 
  environment\signalPanicBitNum = AllocSignal_(-1)
  environment\signalPanicMask = 1 LSL environment\signalPanicBitNum
  environment\signalStopBitNum = AllocSignal_(-1)
  environment\signalStopMask = 1 LSL environment\signalStopBitNum

  ; --
  ; -- loadseg default debugger (blitz2:dhandler)
  ; --
  log2PED{"loading debugger start module."}
  config\ptr_seg_debugger = LoadSeg_(config\default_debugger)
  If config\ptr_seg_debugger = 0
    error{!TRANS{"The Debugexecutor `Defaultdbug` was not found.\\nDebugging is not possible."}}
  EndIf

  ; --
  ; -- Pass control to PED or parse cli parameters
  ; --
  ; --
  If CLIMode = False
    log2PED{"running PED..."}
    ; -- jump to the address ped returned before and pass a sourcename in A0
    !asm
    MOVE.l cli_sourcefile@(A5),A0
    MOVEA.l ped_startup_addr,A1 : JSR (A1)
    !basic

    ; --
    ; --
    ; == wait until PED has been quit !!
    ; --
    ; --
    ; --

  Else
    Gosub handle_cli_parameters
  EndIf

  ; --
  ; -- tidy up everything and quit
  ; --
  ; --
  !asm
  BSR.w Aclearallvars
  BSR.w free_Residents
  BSR.w free_allox
  JSR free_unusedfunctions  
  CLR.l pushat
  !basic
  Gosub free_blitzlibs
  
.shutdown_compiler:
  If config\ptr_seg_debugger Then UnLoadSeg_ config\ptr_seg_debugger
  If config\ptr_seg_ped      Then UnLoadSeg_ config\ptr_seg_ped

  ;-- ptr_macrobuffer_begin: byte 0..3: size of macrobuffer
  ;--                        byte 4..7: address begin of buffer
  If PeekL(?ptr_macrobuffer_begin)-4 Then FreeMem_ PeekL(?ptr_macrobuffer_begin)-4, PeekL(?macrobuffer_size) + 4

  If PeekL(?constpcat) Then FreeMem_ PeekL(?constpcat), PeekL(?constmaxpc) : PokeL ?constpcat,0

  If PeekL(?mempool2) Then DeletePool_ PeekL(?mempool2) : PokeL ?mempool2,0
  If PeekL(?mempool) Then DeletePool_ PeekL(?mempool) : PokeL ?mempool,0

  If PeekL(?_dosbase) Then CloseLibrary_ PeekL(?_dosbase) : PokeL ?_dosbase,0
  If PeekL(?_mathffpbase) Then CloseLibrary_ PeekL(?_mathffpbase) : PokeL ?_mathffpbase,0
  If environment\signalStopBitNum Then FreeSignal_ environment\signalStopBitNum
  If environment\signalPanicBitNum Then FreeSignal_ environment\signalPanicBitNum

.abnormal_exit:
  If config\blitz3assign  <> ""
    If *AssignSema
      ReleaseSemaphore_ *AssignSema
      If (AttemptSemaphore_ (*AssignSema))                 ; we are the exclusive owner of the sema now!
        If dos_RemAssign{"LIBS:",dos_AddPart{config\blitz3assign, "Libs"}}
          ;If KickVersion < 47                              ; AssignLock_ freezes with OS 3.2.0 !
            If NOT dos_RemAssign{config\blitz3assign}
              error{"Could not remove assign: " + config\blitz3assign}
            EndIf
          ;EndIf
        Else
          error{"Could not remove assign: " + dos_AddPart{config\blitz3assign, "Libs"}}
        EndIf

        RemSemaphore_ *AssignSema
        ReleaseSemaphore_ *AssignSema

        If *AssignSema\ss_Link\ln_Name Then FreeVec_ *AssignSema\ss_Link\ln_Name : *AssignSema\ss_Link\ln_Name = Null
        FreeVec_ *AssignSema
        *AssignSema = Null
      End If
    End If
  EndIf

  ;-- resetting the current path in cli structure
  SetCurrentDir{environment\progdir}

  !coutclose
  MOVEQ #0,D0
  !exitasm
End
; ----------------------------------------------------------------------------------------------
; ------------------------------------------ END OF MAINPROGRAM --------------------------------
; ----------------------------------------------------------------------------------------------

.handle_cli_parameters:
  err.l = False

  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ Resolve pathes                                                             /
  ;/ Get the full qualified path for source code and executable file            /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  If cli_sourcefile
    lock.l = Lock_(&cli_sourcefile,#ACCESS_READ)
    If lock
      NameFromLock_ lock,&cli_tempstr,1024
      cli_sourcefile.s = Peek.s(&cli_tempstr)
      UnLock_ lock
    End If

    If cli_exefile
      SetCurrentDir{dos_PathPart{cli_sourcefile}}
      path.s = dos_PathPart{cli_exefile}
      lock.l = Lock_(&path,#ACCESS_READ)
      If lock
        NameFromLock_ lock,&cli_tempstr,1024
        path.s = Peek.s(&cli_tempstr)
        cli_exefile = dos_AddPart{path,dos_FilePart{cli_exefile}}
        UnLock_ lock
      End If
    End If
  End If

  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ Initialize Token Hashmap                                                   /
  ;/ Get the token hashmap to tokenize/detokenize source code files             /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  log2PED{"Initializing token hashmap...",3}
  TokenHashMapFile.s = dos_AddPart{config\path_system,"TokenList.hashmap"}
  *PreProcessor.preprocessor = preproc_Create{}
  PokeL ?comPtr_PreProcessor,*PreProcessor
  preproc_LoadTokens{*PreProcessor,TokenHashMapFile}
  If *PreProcessor\tokens=Null
    log2PED{"No hashmap found (\\22"+TokenHashMapFile+"\\22), will be created...",1}
    preproc_QueryTokens{*PreProcessor}
    preproc_SaveTokens{*PreProcessor,TokenHashMapFile}
  End If

  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ Load and Compile Sourcecode                                                /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  If cli_sourcefile><"" AND err=False
    log2PED{"Loading sourcecode \\22" + cli_sourcefile + "\\22...",1}
    succ = LoadSource{cli_sourcefile}
    If succ
      If cli_savefile = ""                                                        ; added check if -save is used then we skip compiling and only save the source  tomsmart1
        log2PED{"Compiling \\22" + cli_sourcefile + "\\22...",1}
        comerr.l = CompileSource{cli_exefile,cli_debuginfo,cli_release,cli_comdbgflags,cli_comstrbufsize} ; expand to support CLI compiler and debugger settings  tomsmart1

        If comerr
        ; NPrint "*** ERROR: Error compiling source!"
        Else
        ; success!!!
        End If
      EndIf
    Else
      log2PED{"\\1b[1m*** ERROR: Unable to read source file!\\1b[0m"}
      err = True
    End If
  EndIf

  If cli_savefile><"" AND err=False
    log2PED{"Saving sourcefiles as " + cli_savefile + "...",2}
    SaveSource{cli_savefile}
  End If

  If cli_dumpfile><"" AND err=False
    log2PED{"Saving dumpfile...",2}
    DumpFile{cli_dumpfile,cli_dumpflags,cli_dumpform}
  End If

  If cli_run
    If comerr=False
      If cli_exefile
        log2PED{"Recompiling " + cli_sourcefile + " for debug...",1}
        comerr.l = CompileSource{"",cli_debuginfo,cli_release,cli_comdbgflags,cli_comstrbufsize} ; re-compile for launch! ; expand to support CLI compiler and debugger settings  tomsmart1
      End If
      log2PED{"Running program...",1}
      RunSource{cli_debuginfo,cli_exestacksize}         ; added debug info to indicate ted.lib use becaus is only needed for Debugging  tomsmart1 2011 06 11
      Repeat
        CLR.l d0
        !ComData_GetB{comByte_RunningFlag,D0}
        PutReg D0,running.l
        If running Then Delay_ 50
        ;NPrint "Runnign flag: ",running
      Until running=False
      If environment\_runerror
        log2PED{"\\1b[1m*** ERROR: Unable to run compiled program!\\1b[0m"}
        err = True
      End If
    End If
  End If


  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ Cleanup and prepare for exit                                               /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  preproc_Free{*PreProcessor} : *PreProcessor=Null
  log2PED{"Exit AmiBlitz3.",3}
  DeinitEmulatedPED{}
Return

.ab3_SaveSource:
  !basic
  PutReg D0,ab3save_filenameP.l
  If ab3save_filenameP
    ab3save_filename.s = Peek.s(ab3save_filenameP)
    SaveSource{ab3save_filename}
  Else
    error{"INTERNAL ERROR: no filename passed in D0 to SaveSource{}!"}
  End If
  !asm
RTS

.ab3_LoadSource:
  !basic
  PutReg d0,ab3save_filenameP.l
  If ab3save_filenameP
    ab3save_filename.s = Peek.s(ab3save_filenameP)
    LoadSource{ab3save_filename}
  Else
    error{"INTERNAL ERROR: no filename passed in D0 to LoadSource{}!"}
  End If
  !asm
RTS

.ab3_ClearSource:
  !basic
  ClearSource{}
  !asm
RTS

.ab3_OpenConsole:
  !basic
  OpenConsoleFake{}
  !asm
RTS


.ab3_CloseConsole:
  !basic
  CloseConsoleFake{}
  !asm
RTS


.call_menuentry:  ; d6: CompileMenuCallID, d7: totallines, A5: ptr firstsourceline
  MOVE.w D6,CompileMenuCallID
  !regs2stack
  !basic
  menuitemx.w = PeekW(?CompileMenuCallID)
  If menuitemx > 16 OR menuitemx < 0
    error{"Called invalid AB3 Menuitem #" + Hexw$(menuitemx) + "!"}
    menuitemx = 0
;  Else
;    error{"calling compilermenu: " + Hex$(menuitemx)}
  End If
  PokeW ?CompileMenuCallID,menuitemx
  !asm
  !stack2regs

  MOVE.l #$FFFFffff,linenumat             ; was -1
  MOVE.l #$FFFFffff,compilelinecounter    ; was -1

  MOVE.l A5,firstitem_
  MOVE.w D7,numlines_org
  MOVE.l D7,numlines

  MOVE.w CompileMenuCallID,d6
  LSL.w #2,D6
  LEA menu_items,A0
  MOVEA.l $0(A0,D6.W),A0
  JSR (A0)                              ; jsr to the function for the menuitem

  MOVE.l compilelinecounter,D0
RTS
CompileMenuCallID: Dc.l 0



mempool:               Dc.l 0
mempool2:              Dc.l 0
ptr_newexefilename:    Dc.l 0                                                               ;execname org

.menu_createexecutable:    ;was menu1 org source          ;compile/save
  !basic 
  !ComData_LEA{comStr_ExePath,D0} : PutReg d0,exeDirP.l
  !ComData_LEA{comStr_ExeFile,D0} : PutReg d0,exeFileP.l
  newexefilename.s = dos_AddPart{Peek.s(exeDirP),Peek.s(exeFileP)}
  Poke.l ?ptr_newexefilename,&newexefilename
  ;GetReg D0,&newexefilename
  !asm
  ;MOVE.l D0,ptr_newexefilename

  ADD.l #1,number_of_builds
  MOVE.w #-1,debugversion

 'l1
    MOVE.w #1,makeexec
    JSR ab3_OpenDebugFile
    BSR.w startcompile
    JSR ab3_CloseDebugFile
  CMP.l #"NORE",reqmode : BEQ 'l1

  TST.w anyerrs : BNE.b 'skip
    JSR save_binaryfile
 'skip
RTS


.do_CloseEd:
  !basic
  environment\_noPED = True
  !asm
RTS


.do_NoCli:
  !basic
  environment\_noCLI = True
  !asm
RTS

; new >
.ab3_CloseDebugFile:
  !basic
  If dbg_fid>=0
    If fillcount.l > 0                                         ; added to check if we still have data so save in the buffer  tomsmart1
      file_WriteMem{dbg_fid,&dbg_detokenlinesBuffer,fillcount} ; yes save it
      fillcount = 0                                            ; set it back to zero bytes
    EndIf
    file_Close{dbg_fid}
    dbg_fid = -1
  EndIf
  PokeW ?word_WriteDebugFileNow,0
  !asm
RTS


.ab3_OpenDebugFile:
  BSR ab3_CloseDebugFile
  !basic
  If dbg_fid.l < 0
    If PeekW(?set_create_dbgfile)
      exefileP.l = PeekL (?ptr_newexefilename)
      exefile.s = ""
      If exefileP Then exefile.s = Peek.s(exefileP)
      If exefile <> ""
        dbg_fid = file_Open{exefile + ".dbg",#file_forcewrite}
        If dbg_fid >= 0
          PokeW ?word_WriteDebugFileNow,-1
        End If
      End If
      oldhunkoffset.l = -1
      oldfile.s       = ""
      fillcount       = 0       ; set it to zero bytes in the buffer
    End If
  End If
  !asm
RTS


.ab3_WriteDebugFile:
  TST.w word_WriteDebugFileNow : BEQ 'skipdebugfile
    !basic
    If dbg_fid>=0
      pass.l          = PeekW(?pass)
      makesmallest.w  = PeekW(?set_make_smallestcode)               ; get the status of make_smallestcode  tomsmart1
      If pass><0 OR makesmallest=0                               ; check expand for makesmallestcode so if it not set that then the dbgfile will fill because we don't reach Pass>0  tomsmart1
        oldhunkoffset.l = hunkoffset.l
        oldfile.s       = codefile.s
        If PeekW (?ininclude)>0
          codeline.l = PeekL(?includeline);-1
          codefile.s = dos_FilePart{incdim(PeekW(?ininclude)-1)}
        Else
          !ComData_LEA{comStr_SourceName,A0}
          MOVE.l A0,D0
          PutReg d0,sourceP.l
          codefile.s = Peek.s(sourceP)
          codeline.l = PeekL(?linenumat)
        End If
        hunkoffset.l = PeekL(?destpointer)-PeekL(?destbufferstart)
        If oldhunkoffset><hunkoffset OR oldfile><codefile
          linebegintext.s = Hex$(hunkoffset)+" <"+codefile+"@"+Str$(codeline)+"> "
          linebeginlen.l  = FLen(linebegintext)
          Poke.s &dbg_detokenlinesBuffer+fillcount,linebegintext           ; copy the begin of the line text to the buffer
          fillcount + linebeginlen

          *sourceLine.SourceLine_t = PeekL(?sourceline)
          If *sourceLine
            !ComData_GetL{comPtr_PreProcessor,include_preprocessor}
            *tn.preprocessor = PeekL(?include_preprocessor)
            written.l = preproc_Detokenize{*tn,&*sourceLine\Text,&dbg_detokenlinesBuffer+fillcount,*sourceLine\CharLength}
            If written > 0
              written - 1
            EndIf
            fillcount + written                                            ; added the dekotenline size to the count
          Else
            Poke.s &dbg_detokenlinesBuffer+fillcount,"NULL"                ; copy it to the buffer
            fillcount + 4                                                  ; added the size to the count
          End If

          PokeB &dbg_detokenlinesBuffer+fillcount,10                      ; copy line end (return) in to the buffer
          fillcount +1                                                     ; count +1

          If fillcount >= (#MAX_dbg_detokenlinesBufferSize - #MAX_Columns) ; check if we have no room for a nother line
            file_WriteMem{dbg_fid,&dbg_detokenlinesBuffer,fillcount}       ; no room write the buffer it do disk
            fillcount = 0                                                  ; set it back to zero bytes
          EndIf

        End If
      End If
    End If
    !asm
 'skipdebugfile
RTS

word_WriteDebugFileNow: Dc.w 0
; < new


check_FunctionReturnType:           ; copy of sizespec2
  MOVEM.l A2-A3,-(A7)
  CLR.b doublepeek
  MOVE.l A5,lastsourcepos
  JSR getchar

  CMP.w #".",D0 : BEQ.w 'ok
    MOVEA.l defaulttype,A2
    CMP.w #"$",D0 : BNE.w 'none
    MOVEQ.l #$07,D1
    BRA.w 'skip
 'ok
  JSR getparameter2 : BEQ.w JUMP_syntaxerr1

  LEA newtypebase,A2
  JSR findtype : BNE.w JUMP_notypeerr1

 'none
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

CNIF #function_support_returntype
  MOVE.l a2,functionreturntype
  CMPI.l #$100,4(A2) : BLE.w 'isvar
    ;CMP.w #"*",d0 : BNE JUMP_syntaxerr1
    ;!fget
    MOVEQ #3,d1
  BRA 'skip
 'isvar
CELSE
  CMPI.l #$100,4(A2) : BLS.w JUMP_illtypeerr1     ;check for normal var or type
CEND

  MOVE.w $6(A2),D1
  CMP.w #8,8(a2) : BNE 'l1
    MOVE.b #1,doublepeek
 'l1

 'skip
  MOVE.w D1,convsize
  MOVEM.l (A7)+,A2-A3
RTS

JUMP_notypeerr1  JMP notypeerr
JUMP_illtypeerr1 JMP illtypeerr
JUMP_syntaxerr1  JMP syntaxerr
 
.clear_Cache:                       ; was flushc in orginal BB2 source
  MOVEM.l D0-D1/A0-A1/A6,-(A7)
  MOVEA.l _execbase,A6
  TST.b MorphOS : BEQ 'useclearU    ; test if we have MorphOS ( 0 no, 1 yes)
                                    ; if we have 0 = No MorpOS then jump
    MOVEQ.l #8,d1
    MOVE.l #200,d0
    JSR _CacheClearE(A6)
    BRA 'exit
 'useclearU
  ;  CMP.w #$27C,16(a6)               ; from orginal BB2 source
  ;  BCS 'exit                        ; from orginal BB2 source
CNIF #USENEWCACHECLEAR_U              ; it is bugy on MorphOS only for testing
  MOVE $128(A6),D0                    ; get CPU ID
  BTST #3,D0 : BEQ 'l10               ; test if its CPU
                                      ; if yes skip ; was BRA.S   'l10
    MOVE.l a0,-(a7)
    JSR _SuperState(A6)
    JSR _Disable(A6)
    MOVEA.L (A7)+,A1

    Dc.w $f469 ;CPUSHL Dc,(A1)
    Dc.w $f489 ;CINVL Ic,(A1)
    ADDA #16,a1
    Dc.w $f469 ;CPUSHL Dc,(A1)
    Dc.w $f489 ;CINVL Ic,(A1)
    ADDA #16,a1
    Dc.w $f469 ;CPUSHL Dc,(A1)
    Dc.w $f489 ;CINVL Ic,(A1)
    ADDA #16,a1
    Dc.w $f469 ;CPUSHL Dc,(A1)
    Dc.w $f489 ;CINVL Ic,(A1)
    ADDA #16,a1
    Dc.w $f469 ;CPUSHL Dc,(A1)
    Dc.w $f489 ;CINVL Ic,(A1)
    ADDA #16,a1
    Dc.w $f469 ;CPUSHL Dc,(A1)
    Dc.w $f489 ;CINVL Ic,(A1)

    JSR _Enable(A6)
    JSR _UserState(A6)
    BRA 'exit
 'l10
CEND                              ; end for USENEWCACHECLEAR_U
  JSR _CacheClearU(A6)

 'exit
  MOVEM.l (A7)+,D0-D1/A0-A1/A6
RTS


.menu_compile_run:                ;compile/run
  ADD.l #1,number_of_builds
  CLR.w debugversion
  !basic
  environment\_noPED = False
  environment\_noCLI = False
  !asm

 'l1
    MOVE.w #0,makeexec                                     ;MOVE.w #$FFFF,debugversion
    BSR.w startcompile
  CMP.l #"NORE",reqmode : BEQ 'l1


.menu_run:                                                   ; run the last compiled source
  !basic
  If PeekW(?anyerrs) <> 0
    log2PED{"cannot run the code as the compiler failed. returning..."}
    Pop If
    !asm
    RTS
  EndIf

  check_fpu_mode.b = PeekB(?optimize_fpu) AND $2
  If check_fpu_mode
    If ProcessorFPU = 0
      error{"The generated code has been optimized to use FPU-features,\\nbut no FPU is present on this system.\\n\\nExecution is not possible."}
      Pop If : Pop If
      !asm
      MOVEQ #1,d0
      RTS
    End If
  End If

  If environment\_noPED
    !asm
    !ComData_JSR{comFunc_CloseGUI}
    !basic
  Else
    
    !asm
    BSR init_compilerequester
    !basic

    comstatusstr  = !TRANS{"Running executable..."}
    calcpro = 100
    GetReg D0,&comstatusstr : !ComData_SetL{comPtr_CompileStatusString,d0}
    GetReg D0,&calcpro      : !ComData_SetL{comPtr_CompileCalcProLong ,d0}
    !asm
    !ComData_JSR{comFunc_UpdateCompileStatusWin}          
    !basic
  EndIf

  ;-- lock the current path or the set executable
  !ComData_LEA{comStr_ExePath,D0} : PutReg d0,exeDirP.l
  !ComData_LEA{comStr_SourceDir,D0} : PutReg d0,sourceDirP.l
  Poke.s exeDirP, Peek.s(sourceDirP)

  log2PED{"locking directory for executable or running exe: " + Peek.s(exeDirP)}
  environment\lock_ExePath = Lock_(Peek.s(exeDirP), #ACCESS_READ)
  If environment\lock_ExePath = 0
    log2PED{"Could not lock the given Exepath ["+ Peek.s(exeDirP) + "], using currentdir ..."}
    environment\lock_CurrentDir = CurrentDir_(0)
    CurrentDir_ environment\lock_CurrentDir
  EndIf

  processName.s = "AmiBlitz3 Program Process"
  log2PED{"creating the exe process [" + processName + "] with stack " + Str$(PeekL(?stacksize)),3}

  *processMsgPort.l = CreateNewProc_(Tags(#NP_Entry,?processStart,@@
                                          #NP_Name,&processName,@@
                                          #NP_StackSize,PeekL(?stacksize),@@
                                          #TAG_END,0))
  If *processMsgPort
    *exeTask.Task = Null                    ; will be set within process in a few moments
    !asm
    !ComData_SetB{comByte_RunningFlag,#1}   ; this should be done here, straigt after it is clear that the program task is running
    !basic

    If environment\_noPED = False
      !asm
      BSR.w close_compilewin
      !basic
    EndIf

    log2PED{"program is running, waiting to stop..."}

    ; TODO: implment a complete signalling between exe, compiler and PED
    ;;-- OK, task should be running here! see if we get a panic or stop!
    ;signalSet.l = environment\signalPanicMask|environment\signalStopMask
    ;receivedSignal.l = Wait_(signalSet)
    ;If receivedSignal AND environment\signalPanicMask
    ;  log2PED{"received Panic signal..."}
    ;Else
    ;  If receivedSignal AND environment\signalStopMask
    ;    log2PED{"received Stop signal..."}
    ;  EndIf
    ;EndIf

    ;Repeat
    ;    CLR.l d0 : !ComData_GetB{comByte_RunningFlag,D0} : PutReg D0,running.l
    ;    If running Then Delay_ 10
    ;Until running = False

    environment\_runerror = 0
  Else
    environment\_runerror = 1
  EndIf

  CLR.l firstlocal
  CLR.l firstglob

  If environment\_noPED
    !asm
    !ComData_JSR{comFunc_CreateGUI}
    !basic
  EndIf
  !asm
RTS

stopit:     Ds.w 1
.processStart: 
  !basic
  *exeTask.Task = *eb\ThisTask                                     ; getting this task via execbase
  *exeProcess.Process = FindTask_(0)
  log2PED{"I am exetask is at address "  + Hex$(*exeTask) + ", tasknum: " + Str$(*exeProcess\pr_TaskNum) + ", name: " + Peek.s(*exeTask\tc_Node\ln_Name)}

  If environment\lock_ExePath
    log2PED{"setting currentdir for exetask..."}
    CurrentDir_ environment\lock_ExePath
  EndIf

  If PeekL(?stacksize) < #MIN_STACKSIZE
    error{"The stacksize is too low: " + Str$(PeekL(?stacksize))}
  EndIf

  ; -- set the running flag for IDE
  !asm
  !ComData_SetB{comByte_RunningFlag,#1}
  !basic

  ; -- optionally open the console
  If environment\_noCLI = False
    log2PED{"opening console window"}
    !asm
    !ComData_JSR{comFunc_OpenConsole}
    !basic
  EndIf

  If (NOT config\use_wbscreen) AND config\con_on_wb Then WBenchToFront_
  !asm

  ;BSR.w calculate_VBR
  ;MOVEA.l vbr,A0
  ;MOVE.l $84(a0),lasttrap1                                 ;activate for 68k low level trap
  ;MOVE.l #tokens,$84(A0)                                   ;set trap vectors  1
  ;MOVE.l newtype_string,$88(A0)                            ;2 activate for 68k low level trap
  ;MOVE.l #directTrap15,$BC(A0)                             ;15 for expression calculation
  CLR.w direct_mode
  CLR.l firstglob
  CLR.l firstlocal
  ;MOVE.l destpointer,directbuffer                          ;direct buffer

  MOVE.l stacksize,D2
  MOVE.l #$624C745A,D7                                      ;#'bLtZ',d7 org source ;force cli-type run
  LEA str_cliarguments,A0                                   ;cli arguement
  MOVEA.l destbufferstart,A1

  BSR.w clear_Cache

  JSR (A1)                                                 ; execute compiled code  ;Run the thing!

  ;MOVEA.l vbr,A0
  ;MOVE.l lasttrap1,$84(a0)
  CLR.l firstglob
  CLR.l firstlocal

  !ComData_SetB{comByte_RunningFlag,#0}

  !basic
  
  log2PED{"We are back from the executable!"}  

  If environment\lock_ExePath Then UnLock_ environment\lock_ExePath

  ; -- optionally close the console and bring ide to front
  If environment\_noCLI = False
    !asm
    !ComData_JSR{comFunc_CloseConsole}
    !basic
  EndIf

  ;-- send compilertask the signal that the task has stopped OK!
  PokeW ?stopit, 1
  Signal_ *compilerTask, environment\signalStopMask

  If (NOT config\use_wbscreen) AND config\con_on_wb 
    log2PED{"bringing PED-screen to front again..."}  
    WBenchToBack_
  EndIf
  !asm
RTS


.menu_reload_userlibs:      ; was menu8 org source
  !clear_instructionTable
  !basic
  Gosub free_userlibs
  Gosub scan_for_userlibs
  Gosub load_userlibs
  !asm
RTS

.scan_for_userlibs:      ; was makeblitzlibs org source
  NEWTYPE.userlibentry
    ;*next_entry.libentry  ; pointer to next entry in list
    is_used.w             ; used flag: is entry used ?
    libname.s             ; name of the libfile
  End NEWTYPE
  Dim List userlibslist.userlibentry(0)

  log2PED{"scanning for userlibs in path " + config\path_userlibs}

  result.b = False
  tmp_lock.l = Lock_(&config\path_userlibs,#ACCESS_READ)
  If tmp_lock
    DEFTYPE.FileInfoBlock fib
    If Examine_(tmp_lock,fib)         ; fileInfoBlock
      If fib\fib_DirEntryType >= 0    ; /* Type of Directory. If < 0, Then a plain File.
                                      ;  * If > 0 a directory */
        While ExNext_(tmp_lock,fib)
          If fib\fib_DirEntryType < 0
            libname.s = Peek.s(&fib\fib_FileName)
            If LCase$(dos_GetExt{libname}) <> "info"
              libfound.b = False
              ResetList userlibslist()
              While NextItem(userlibslist()) OR (libfound = True)
                If userlibslist()\libname = libname Then libfound = True
              Wend
              If AddLast(userlibslist())
                userlibslist()\is_used = $FFFF
                userlibslist()\libname = libname
              EndIf
            EndIf
          EndIf
        Wend
        result = True
      Else
        error{"Given path for userlibs is not a directory: " + config\path_userlibs + "!"}
      EndIf
    EndIf
    UnLock_ tmp_lock
  EndIf
Return



;-----------main compiler functions!------------;
pass:         Dc.w 0                                      ; smallpass org source
compiler_job: Dc.w 0                                      ; added by thilo: what the compiler is doing at the moment
                                                          ; 0 = compiling, 1 = code generation

.startcompile:                                            ; O.K. Here we go.....
  !basic
  log2PED{"=================== begin compiling ======================="}
  log2PED{"runtime debugging : " + Hex$(PeekW(?set_use_debugger))}
  log2PED{"function optimizer: " + Hex$(PeekW(?set_FuncOptimize))}
  log2PED{"make smallest code: " + Hex$(PeekW(?set_make_smallestcode))}

  ;-- calc size of libcode for executable
  alllibssize.l = 0
  !asm

  MOVE.l #0,compileErrorCode
  MOVE.l A7,errstack

  !regs2stack
  TST.w set_make_smallestcode : BNE 'nobigallox
    JSR bigallox                   ; no try to make big buffers for 1 pass compile
 'nobigallox
  !stack2regs

  CLR.l reqmode
  ; < new
  MOVE.l #Aclearallvars,errcont
  MOVE.l #concomstack,concomsp

  ;--
  ;-- racing stripe stuff...
  ;--
  MOVE.w #100,d0                                           ; 100%
  SWAP D0
  CLR.w D0
  MOVE.l numlines,d1                                       ; was divu numlines,d0
  DIVU.l d1,d0                                             ; 100 / numlines; progress per line
  TST.w D0 : BNE.w 'ok
    MOVEQ.l #-$01,D0
 'ok
  MOVE.w D0,progress_per_line

  ;--
  ;-- check if debugger should be turned on
  ;--
  JSR do_runerrson

  CLR.w direct_mode                                        ;direct mode flag
  CLR.w ezerr                                              ;quiet error
  CLR.l currentfunction
  CLR.w connest
  CLR.w varmode
  CLR.w proceduremode
  CLR.w ininclude
  CLR.w intstring
  CLR.w pass

  MOVE.w #0,compiler_job
  CLR.l errorcounter
  CLR.l beforeparameterfetch     ; add to prevent fals detokening by showing a the (compile)error requester  tomsmart1 2016 02 02
  ; < new

 'retry
  ; new >
  CNIF #funcscan                                           ; DEFFUNC ?
    MOVE.l #1,funcscanon
    BSR compileall
    ADDQ.w #1,pass
    JSR ab3_OpenDebugFile                                  ; repoen the .dbg file to only contain the data from the next compile pass
  CEND
  CLR.l funcscanon

  BSR.w compileall
  ADDQ.w #1,pass

  TST.l errorcounter : BEQ 'skiperrorstop
    RTS
 'skiperrorstop

  ;-- get the needed size for the exe from the first compile 
  ;-- for creation of the release exe
  !regs2stack           
  !basic
  samesize.l = 0
  needsize0.l = PeekL(?bigpc) - PeekL(?destbufferstart)
  !asm
  !stack2regs

  TST.w dontwrite_nomemleft : BNE 'l3
    TST.l errorcounter : BNE 'l3
      CLR.w dontwrite_nomemleft
      JSR ab3_OpenDebugFile                                    ; reopen .dbg file to only contain the data from one the next compile pass
      BSR compileall                                           ;if a function is not found
      ADDQ.w #1,pass
 'l3
 

  TST.w set_FuncOptimize : BEQ 'out
    LEA firstproc,a0
    CLR.l savefuncspace
    MOVE.l (a0),d0

   'lr1
      MOVE.l d0,a0 : BEQ 'out
        TST.b isfunc(a0) : BNE 'nex
          MOVEM.l d2/a6/a0,-(a7)

          MOVEA.l _execbase,A6

          MOVEQ #0,d0
          MOVE.b $21 + #funcentry_extend-1(a0),d0
          SUB.w #$21 + #funcentry_extend,d0
          ADD.w #16,d0

          MOVE.l ##MEMF_CLEAR,d1
          MOVE.l d0,d2
          JSR _AllocMem(a6)         ; thilo: not 100% sure about this!
          MOVE.l d0,a1

          MOVE.l d2,4(a1)
          MOVE.l unusedfunc,(a1)
          MOVE.l d0,unusedfunc
          MOVEM.l (a7)+,a6/a0/d2

          MOVE.l isfunc+1(a0),d0
          ADDQ.l #6,d0
          ADD.l d0,savefuncspace

          MOVE.l d0,8(a1)
          LEA 12(a1),a1
          MOVE.l a0,-(a7)
          LEA $21+#funcentry_extend(a0),a0
         'l1
            MOVE.b (a0)+,(a1)+
          BNE 'l1
          MOVE.l (a7)+,a0
      'nex
        MOVE.l (a0),d0
    BRA 'lr1
 'out

  ;-- optimize for executable
  TST.w set_make_smallestcode : BEQ.b 'nosmall
    !basic
    log2PED{"optimizing for smallest code ..."}
    !asm

    BSR.w alloxadj : BEQ.w 'anerr

    JSR ab3_OpenDebugFile                                      ; added that the .dbg file only contains the data of the next compile pass

    BSR.w compileall
    ADDQ.w #1,pass

    !regs2stack             ; added to get the needed size for the exe from the last (second) compile for the create the release exe  tomsmart1
    !basic
    If releaseexe = True                                       ; test if we create a release exe
      needsize1.l = PeekL(?bigpc) - PeekL(?destbufferstart)  ; get the size from the last compile
      If (needsize1 = needsize0) AND (releasedbg_save = 1)     ; test if we we can not reduce the size anymore and need to cread a dbg file
        PokeW ?set_create_dbgfile,$80                          ; set create .dbg file to one
        !asm
        JSR ab3_OpenDebugFile                                  ; open the .dbg flie
        !stack2regs
        BSR compileall                                         ; compile for the last time to create the dbg file
        !regs2stack
        !basic
      EndIf

      If needsize1 < needsize0   ; test if the needed size is smaller then the compile befor
        needsize0 = needsize1    ; yes the new size is that the old size
        Pop If : Pop If
        !asm
        !stack2regs
        BRA 'l3                  ; back to the funcscan and compile again
      EndIf
    EndIf
    !asm
    !stack2regs
 'nosmall

  MOVE.w dontwrite_nomemleft,D1 : BEQ.w 'dosave
   
; 'loop
    BRA.w 'inc     ; was beq

 'anerr
    MOVE.w #$FFFF,anyerrs        ; was -1
    BRA.w 'dosave

 'inc
    BSR.w alloxinc : BEQ.w Aclearallvars                    ;increase all by 50%
    JSR ab3_OpenDebugFile                                   ; added to fix that the .dbg file only holds the data from the second (last) compile if no make_smallest is set and the buffer was to small  tomsmart1
    BRA.w 'retry

 'dosave
  ;-- log out size of libcode for executable
  !basic
  log2PED{"used size for attached code of blitzlibs " + Str$(alllibssize) + " bytes."}
  !asm


.qfree:
  ;--
  ;-- free up stuff after compile has finished
  !basic
  log2PED{"freeing up memory ..."}
  !asm
  JSR free_Repeats
  JSR free_Selects
  JSR free_tokeslist
  JSR free_pEnds
  JSR free_Ifs
  JSR free_includes
  JSR free_xincludes
  JSR free_Fors
  JSR cleartemplabel
  ;!basic
  ;log2PED{"done  ..."}
  ;!asm  
RTS

.Aclearallvars:      ; was freeemup  org source                                    ;called from ped every filechange
  ; new >
  JSR clear_Cache

  JSR do_runerrson

  LEA regtable,a0
  MOVEQ #10,d0
 'l1
    CLR.l (a0)+
  DBF d0,'l1

  LEA includetemp2,a0
  CLR.b (a0)
  MOVE.l #7,maxregs
  CLR.w debugnest
  CLR.b funcparloop
  CLR.b nostringopt
  CLR.b firsttime
  CLR.l lastdestpointer
  CLR.l lastwritedat
  CLR.l prevwritedat
  CLR.l includeline
  CLR.b incnif
  CLR.b formode
  CLR.b funccall
  CLR.w objectcount
  CLR.b resdisable
  CLR.b developobject
  CLR.b optistring
  CLR.b optistring2
  CLR.b optiarray
  CLR.b quickadd
  CLR.w newmode
  CLR.w mode
  CLR.w string1
  CLR.b fastfunc
  CLR.w load_var_size
  CLR.w load_var_reg
  CLR.l load_var_addr
  CLR.w imm_size
  CLR.w imm_reg
  CLR.l imm_addr
  CLR.b _dcb
  CLR.l nohunkoffset
  CLR.b peekaddrsize
  CLR.b typecheck
  CLR.b declare2
  CLR.b declare
  CLR.l macrolineold                                          ;check
  CLR.l macroline                                          ;check
  CLR.b newvariable
  CLR.b saved0
  CLR.l bsssize
  CLR.l chipsize
  CLR.b infunctioncode
  CLR.l errorcounter
  MOVE.l #-1,bssstart
  MOVE.l #-1,bssend
  MOVE.l #-1,chipstart
  MOVE.l #-1,chipend
  MOVE.w #0,bssmode
  CLR.w a2offset
  CLR.w optimize_integer
  CLR.w optimize_fpu
  CLR.b iee
  CLR.w optimize_newsyntax
  CLR.w optimize_jumps
  ; < new

  BSR.w qfree
  JSR free_allHunkOffsets     ;free up DOS offset table
  JSR free_allVariables       ;free up Global vars
  JSR free_allTypes           ;free up all types
  JSR free_Macros             ;free up actual macro defines.
  JSR free_proceduresList     ;free up states/funcs
  ;TST.w pass : BNE free_procedureVS ; is done later
  JSR free_Labels             ;free up labels
  JSR clearhash

 'l2a
  LEA devo,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA namebuffer,a1
 'l1b
    MOVE.b (a0)+,(a1)+
  BNE 'l1b
  MOVEQ #13,d2
  JSR findlabel2 : BNE 'd
    CLR.l 8(a2)
 'd
  MOVEM.l (a7)+,a0-a6/d0-d7

  !basic
  dos_Delete{dos_AddPart{config\path_system,"ab_compileerror.txt"}}
  !asm

  CLR.b returncode
  ; < new

  JSR free_procedureVS                     ;free up outstanding proc stuff
RTS


.clearhash:
  MOVE.l #bssstore-labelhash,d0
  ASR.l #2,d0
  LEA labelhash,a0
 'l10
    CLR.l (a0)+
    SUBQ.l #1,d0
  BNE.s 'l10

  LEA labelbase,a1
  MOVE.l (a1),d0 : BEQ 'l11

 'l21
    MOVE.l d0,a1
    TST.l 4(a1) : BEQ 'l29
      LEA $13(a1),a0
      MOVEQ #0,d0
      MOVEQ #0,d1

     'l13
        MOVE.b (a0)+,d1 : BEQ 'l12

        !hashalgo
      BRA 'l13
     'l12
      LEA labelhash,a0
      AND.l #hashsize,d0
      ASL.l #2,d0
      MOVE.l 0(a0,d0),d1                                     ;*4
      MOVE.l d1,$c(a1)
      MOVE.l a1,0(a0,d0)
   'l29
    MOVE.l (a1),d0
  BNE 'l21
 'l11
RTS


.free_allTypes:
  MOVEA.l lastrestype,A0
  MOVEA.l (A0),A2
  CLR.l (A0)
JMP free_Types


.free_allVariables:
  MOVEA.l _execbase,A6

  MOVEA.l varbase,A3
  CLR.l varbase
 'l10
    CMPA.w #$0,A3 : BEQ.w 'l20

    MOVEA.l A3,A1
    MOVEA.l (A3),A3
    MOVEQ.l #$00,D0
    MOVE.b $E+4(A1),D0
    MOVE.l mempool2,a0 : JSR _FreePooled(A6)
  BRA.w 'l10
 'l20
RTS

.free_Ifs:
  LEA firstiff,A2
  MOVEQ.l #$0E,D2
JMP freeslist


inmacro:             Ds.w 1                                ;macmask org source ;macro found

.nextline:
  ;
  ;go on to the next line of the program.....
  ;
  CLR.w inmacro
  ADDQ.l #1,globallinecount
  CLR.b nostringopt
  BSR.w free_macroBuffer
  CLR.w instringon

.mergeline:

  TST.w ininclude : BEQ.w 'skip3
    ADDQ.l #1,includeline

    JSR ab3_WriteDebugFile

    JSR read_includeline : BEQ.w 'skip3
      ;--
      ;-- do include stripe
      ;--
      MOVE.w ininclude,D0               ; calc only for the first 4 includes progress
      CMP.w #$4,D0 : BCC.w 'stskip
        ADD.w D0,D0
        LEA progress_per_line,A0
        MOVE.w $0(A0,D0.W),D2           ;offset in line (stored for each include!)
        CMP.w #100,D2 : BCC.w 'stskip
          ADDQ.w #1,$0(A0,D0.W)
          ;
          LSR.w #1,D0
          MOVE.l d0,d1 : EXT.l d1
          MOVE.l d2,d0 : EXT.l d0
          JSR update_progressbar        ; d0=x, d1=y
          ; < new
      'stskip
       MOVEQ.l #-$01,D0
       RTS
 'skip3                                                         

  ;-- do main stripe
  MOVE.l titleat,D0
  MOVEQ.l #$00,D1 : MOVE.w progress_per_line,D1 : ADD.l D1,D0
  MOVE.l D0,D1
  SWAP D0
  CMP.w titleat,D0 : BEQ.w 'skip3a
    EXT.l d0
    MOVE.l d1,-(a7)
    MOVE.w #1,compiler_job                                    ; set to compiler job 1 (=build executable)
    JSR update_progressbar
    MOVE.w #0,compiler_job                                    ; set to compiler job 0 (=compile source)
    MOVE.l (a7)+,d1
 'skip3a
  MOVE.l D1,titleat

 'skip2
  ADDQ.l #1,linenumat
  CLR.w linedone

  JSR ab3_WriteDebugFile                                      ; write to DebugFile every main source line

 'norunerr
  SUBQ.l #1,numlines2 : BEQ.w 'skip
    MOVEA.l sourceline,A0
    MOVEA.l (A0),A0
    MOVE.l A0,sourceline
    LEA $9(A0),A5
 'skip
RTS

JMP_notqerr: JMP notqerr

findmacro:   ;expandmax org source
  ;--
  ;-- go through statement and expand macros
  ;--
  ;-- line at a5.....
  ;-- check it for !'s
  ;--
  MOVE.w skipcode,D1 : BNE.w 'loop0
    RTS
 'loop0

  MOVE.l A5,-(A7)
  MOVEQ.l #$3A,D1      ;':'
  MOVEQ.l #$21,D2      ;'!'
  MOVEQ.l #$3B,D3      ;';'
  MOVEQ.l #$22,D4      ;'"'

 'loop
    MOVE.b (A5)+,D0 : BEQ.w 'done
      BPL.w 'test
         MOVE.b (A5)+,D0
  BRA.w 'loop
 'test
  CMP.b D4,D0 : BNE.w 'notq

 'qloop
  MOVE.b (A5)+,D0 : BEQ.w JMP_notqerr
  ;BPL.w 'qskip                                        ;morechar
  ;MOVE.b (A5)+,D0
  ;BRA.w 'qloop

 'qskip
  CMP.b #$22,D0 : BNE.w 'qloop        ;'"'
   
  BRA.w 'loop

 'notq
  CMP.b D1,D0 : BEQ.w 'done
  CMP.b D3,D0 : BEQ.w 'done       ;macro character!
  CMP.b D2,D0 : BNE.w 'loop
  ;
  ;expand the macro!
  ;
  MOVE.w #$FFFF,inmacro    ; was -1                                ; no runtimecheck in macros
  MOVEA.l A5,A3
  ;
  JSR getparameter2 : BNE.w 'fkitme
    JMP syntaxerr
 'fkitme
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  ;
  JSR findmac : BEQ.w 'kl1                                       ;find macro
    JMP nomacerr
 'kl1
  ; new >
  TST.b debugmode : BEQ 'sk1
    MOVE.w ##opcode_NOP,d1 : JSR writeword
    MOVE.l a5,-(a7)
    MOVE.l a3,a5
    SUBQ.l #1,a5
    MOVE.w #$0,inmacro
    BSR insertDebugTrapa
    MOVE.w #$FFFF,inmacro
    MOVE.l (a7)+,a5
    MOVE.w ##opcode_NOP,d1 : JSR writeword
 'sk1
  ; < new
  MOVEA.l A5,A4            ;start of parameters!

  ; new >
 'l5a
    CMP.b #" ",(a4)+ : BEQ 'l5a

    SUBQ.l#1,a4
    CMP.b #",",(a4) : BEQ 'nops
 'l5b
  ; < new
  MOVEQ.l #$00,D4          ;narg=0
  ; new >
  TST.b optimize_newsyntax : BEQ 'l10b
  MOVEM.l a0/d0,-(a7)
  MOVE.l 4(a2),a0
  MOVE.w 8(a2),d0

 'x2
    CMP.b #"`",(a0)+ : BEQ 'x1
    SUBQ.w #1,d0
    BNE 'x2
    BRA 'x3
 'x1
    MOVEM.l (a7)+,a0/d0
    BRA 'l10
 'x3
    MOVEM.l (a7)+,a0/d0
    BRA 'nops

 'l10b
  ; < new
  CMPI.b #"{",(A4) : BNE.w 'nops
  ; new >
  ;BNE 'l10

 'l5
  ADDQ.l #1,a4

 'l10
  CMP.b #" ",(a4) :  BEQ 'l5
  MOVEM.l a0/d0,-(a7)
  CLR.b exmac
  LEA chartab,a0
  MOVEQ #0,d0
  MOVE.b (a4),d0 : BMI 'm1
  TST.b 0(a0,d0) : BEQ 'm1
  TST.b optimize_newsyntax: BEQ 'ns1
  CMP.b #"#",d0  : BEQ 'm1
  CMP.b #"$",d0  : BEQ 'm1
  CMP.b #"-",d0  : BEQ 'm1

 'ns1
  CMP.b #",",d0 : BEQ 'm1
    CMP.b #"{",d0 : BNE 'm1b
    ADDQ.l #1,a4
 BRA 'm1

 'm1b
  TST.b optimize_newsyntax : BEQ 'm1
    MOVE.b #1,exmac
 'm1
  MOVEM.l (a7)+,a0/d0
  TST.b exmac : BNE 'nops
    ;CMP.b #"|",(a4)
    ;BEQ 'nops
    ;CMP.b #":",(a4)
    ;BEQ 'nops
    ;CMP.b #";",(a4)
    ;BEQ 'nops
  TST.b (a4) : BEQ 'nops

 'oldlab
  ; < new
  MOVEA.l ptr_macrobuffer_begin,A0    ;start of parameter collect

 'ppl
  ADDQ.w #1,D4                        ;another p
  MOVE.l A4,(A0)
  ; new >
  CLR.w 4(a0)
  ; < new
   BSR.w findit
  ;move.l A4,D1
  ; new >
  ADDQ.l #4,a0
  ; < new
  ;SUB.l (A0)+,D1
  ;subq.w #1,D1
  ;move.w D1,(A0)+
  ; new >
  SUBQ.w #1,(a0)+
  ; < new
  CMP.b #"}",D0 : BEQ 'l10b1
    TST.b d0 : BEQ 'l10b1
      BRA 'ppl
 'l10b1
  CLR.l sourceline3
  ; <new
  MOVEA.l A4,A5

 'nops
  MOVE.w D4,numarg

  ;tst.l macrolineold : beq 'l1c
  ;  move.l macroline,d0
  ; bra 'l10c
  ;'l1c

  MOVEA.l _execbase,A6

  MOVE.l macrobuffer_size,D0
  CMP.l #DEFAULT_MACROBUFFERSIZE,d0 : BGE 'l1mc
    MOVE.l #DEFAULT_MACROBUFFERSIZE,d0               
    MOVE.l d0,macrobuffer_size
 'l1mc
  MOVE.l mempool,a0 : JSR _AllocPooled(a6)
  
  MOVE.l macroline,macrolineold

  ; new >
 'l10c
  ADDQ.l #1,d0
  ; < new
  MOVE.l D0,macroline
  MOVEA.l D0,A1
  ; new <
  MOVE.b #":",-1(a1)
  ; < new
  MOVEA.l A1,A6
  ADDA.l macrobuffer_size,A6   ;end of macro buffer
  ;
  MOVEA.l (A7)+,A0             ;start of the line

 'loop2
    CMPA.l A6,A1 : BCC.w JMP_mbovererr

    MOVE.b (A0)+,(a1)+
  CMPA.l A3,A0 : BCS.w 'loop2

  SUBQ.w #1,A1                 ;back over '#'
  ;
  MOVE.w 8(A2),D1             ;mac len
   BEQ.w 'loop4
  MOVE.w $A(A2),macnum
  ADDQ.w #1,$A(A2)
  MOVEA.l 4(A2),A2
  SUBQ.w #1,D1
  ; new >
  CLR.b firstmline
  ; < new

 'loop3
    MOVEQ.l #$00,D0
    MOVE.b (A2)+,D0
  ; new >
    TST.b firstmline : BNE 'c1

      CMP.b #$22,d0 : BNE 's1            ;'"'
        MOVE.b #1,firstmline
     's1

      CMP.b #":",d0 : BNE 'm1a
        MOVE.b #1,firstmline
     'm1a

      CMP.b #";",d0 : BNE 'c1
       'l1d
          SUBQ.w #1,d1                                           ;filter out comment
          MOVE.b (a2)+,d0
          CMP.w #":@",-1(a2) : BEQ 'c2
            TST.w d1 : BNE 'l1d
              BRA 'oky2
         'c2
        CMP.b #":",1(a2) : BNE 'l1d

        ADDQ #2,a2
        SUBQ #3,d1
        MOVE.b (a2)+,d0
        MOVE.b #1,firstmline
   'c1
  ; < new
    CMP.b #"`",D0 : BNE.w 'oky

    SUBQ.w #1,D1
    MOVE.b (A2)+,D0
    CMP.w #"{",D0 : BEQ.w 'evalit     ;'{'
    CMP.w #$40,D0 : BNE.w 'notnum     ;'@'
  
    ;--
    ;-- macro num parameter
    ;--
    MOVEQ.l #$00,D2
    MOVE.w macnum,D2
    MOVEA.l A1,A0
    MOVE.w D1,-(A7)
    JSR makelong
    MOVEA.l A0,A1
    MOVE.w (A7)+,D1
    ;
    BRA.w 'oky2

   'notnum
    ORI.w #" ",D0
    CMP.w #$7A,D0 : BCS.w 'fkit       ;'z'
      JMP ilconsterr
   'fkit
    SUBI.w #$30,D0
    CMP.w #$A,D0 : BCS.w 'itsgot
    ;
    SUBI.w #$27,D0
    CMP.w #$A,D0 : BCC.w 'fkit2
      JMP ilconsterr
   'fkit2
    BRA.w 'itsgot

   'evalit
    MOVE.l A5,-(A7)
    MOVEM.l D1/A1-A2/A6,-(A7)
    MOVEA.l A2,A5
    JSR evalconst2
    CMP.w #"}",D0 : BEQ.w 'allisok
      JMP syntaxerr
   'allisok

    MOVEM.l (A7)+,D1/A1-A2/A6
    MOVE.l A5,D2
    SUB.l A2,D2
    SUB.w D2,D1
    MOVEA.l A5,A2
    ;
    CLR.w instringon
    MOVEA.l (A7)+,A5
    ;
    MOVE.l D3,D0 : BPL.w 'itsgot
      JMP ilconsterr
   'itsgot

    SUBQ.w #1,D0 : BPL.w 'ok
      ;
      ;here, we do a numarg text replace
      ;
      MOVE.w numarg,D0
      DIVU #$A,D0
      ADDI.w #$30,D0
      CMPA.l A6,A1 : BCC.w JMP_mbovererr

      MOVE.b D0,(A1)+
      SWAP D0
      ADDI.w #$30,D0
      CMPA.l A6,A1 : BCC.w JMP_mbovererr

      MOVE.b D0,(A1)+
      BRA.w 'oky2
   'ok

    ;ok to do parameter replacement
    ;d0= number for parameter replacement!
    ;
    CMP.w numarg,D0 : BCC.w 'oky2
    LSL.w #1,D0
    MOVE.w D0,D4
    LSL.w #1,D0
    ADD.w D4,D0          ;*6
    MOVEA.l ptr_macrobuffer_begin,A0
    ADDA.w D0,A0
    MOVE.w $4(A0),D4     ;len of replacetext
    BEQ.w 'oky2
    MOVEA.l (A0),A0
    SUBQ.w #1,D4

   'plp
      CMPA.l A6,A1 : BCC.w JMP_mbovererr

      ;-- preparse "@@" syntax
      CMP.w #"@@",(a0) : BNE 'l10e

        TST.w ininclude : BNE JMP_errorjoin

       'l111e
          MOVE.l sourceline,a0
          MOVE.l (a0),a0
          CMP.l #0,a0 : BNE 'l11e
            MOVEQ #0,d0 : JSR error
         'l11e
          MOVE.l a0,sourceline
          ADDQ.l #1,linenumat
          LEA 9(a0),a0
          MOVE.l a0,-(a7)
         'l110e
            CMP.b #" ",(a0)+
          BEQ 'l110e
        CMP.b #";",-1(a0)
        MOVE.l (a7)+,a0
        BEQ 'l111e
        SUBQ.l #1,d4
     'l10e
      MOVE.b (A0)+,(A1)+
    DBF D4,'plp

    BRA.w 'oky2

   'oky
    CMPA.l A6,A1    : BCC.w JMP_mbovererr
    MOVE.b D0,(A1)+ : BPL.w 'oky2
    CMPA.l A6,A1    : BCC.w JMP_mbovererr
    MOVE.b (A2)+,(A1)+
    SUBQ.w #1,D1

   'oky2
   DBF D1,'loop3
   ; new >
   ;tst.l numarg : beq 'loop4
   ;CMP.b #"}",-1(a5) : beq 'loop4
   ;  subq.l #1,a5
   ; < new

 'loop4
    CMPA.l A6,A1 : BCC.w JMP_mbovererr
  MOVE.b (A5)+,(A1)+ : BNE.w 'loop4

  MOVEA.l macroline,A5
  ;
  MOVE.l macrolineold,D0 : BEQ.w 'skip3
    BSR free_macroBufferb
 'skip3
 BRA.w 'loop0

 'done
  MOVEA.l (A7)+,A5
RTS

JMP_mbovererr: JMP mbovererr
JMP_errorjoin: JMP errorjoin

.free_macroBuffer:
  MOVE.l macroline,D0 : BEQ.w nomacro
    CLR.l macroline
    free_macroBufferb:
    MOVEA.l _execbase,A6
    SUBQ.l #1,d0
    MOVEA.l D0,A1
    MOVE.l macrobuffer_size,D0
    MOVE.l mempool,a0 : JMP _FreePooled(A6)
 nomacro:
RTS


findit:
  ;--
  ;-- find the end of a parameter
  
  MOVEQ.l #$00,D2    ;no nesting

 'loop
      ; new >
      ADDQ.w #1,4(a0)
      ; < new
      MOVE.b (A4)+,D0
      ;beq.w syntaxerr
      ; new >
      BEQ exit1
      ; < new
      BPL.w 'tst
      ; new >
      ADDQ.w #1,4(a0)
      ; < new
      ADDQ.w #1,A4
    BRA.w 'loop
   'tst
    ; new >
    TST.w instringon : BNE 'lnom
      CMP.b #";",d0 :  BEQ exit2
      CMP.b #":",d0 :  BEQ exit2
   'lnom
    ; < new
    CMP.b #$22,D0 : BNE.w 'notq           ;'"'
      NOT.w instringon
  BRA.w 'loop

 'notq
  TST.w instringon : BNE.w 'loop

  ; new >
  CMP.b #"@",d0 :   BNE 'l10
  CMP.b #"@",(a4) : BNE 'l10
  TST.w ininclude : BNE JMP_errorjoin

  MOVE.l sourceline3,a4
  CMP.l #0,a4 : BNE 'l11
   MOVE.l sourceline,a4
 'l11
  MOVE.l (a4),a4
  CMP.l #0,a4 : BNE 'l12
     MOVEQ #0,d0
     JSR error
 'l12
  MOVE.l a4,sourceline3
  LEA 9(a4),a4
  MOVEQ #",",d0
 'l10

  ; < new
  CMP.b #",",D0 : BNE.w 'notc
    TST.w D2 : BEQ.w 'done
    BRA.w 'loop
 'notc

  ;bsr.w isitopen
  ; new >
  CMP.b #"{",D0 : BEQ.w 'l10b
  CMP.b #"(",D0
 'l10b
  BNE.w 'noto
  ADDQ.w #1,D2
  BRA.w 'loop

 'noto
  CMP.b #"}",D0 : BNE.w 'notcb
    TST.w D2 : BEQ.w 'done
 'notcb
  ;bsr.w isitclose
  ; new >
  CMP.b #"}",D0 : BEQ.w 'l10a          ;same as isitclose                                       
  CMP.b #")",D0
 'l10a
  ; <  new
    BNE.w 'loop
    SUBQ.w #1,D2
  BRA.w 'loop

 'done
RTS

; new >
exit1
      SUBQ.l #1,a4
      CLR.l sourceline3
RTS


exit2
      MOVEQ #0,d0
      SUBQ.l #1,a4
      CLR.l sourceline3
RTS
; < new


isitopen:
  CMP.b #"{",D0 : BEQ.w 'yes
  CMP.b #"(",D0
 'yes
RTS


isitclose:
  CMP.b #"}",D0 : BEQ.w 'yes
  CMP.b #")",D0
 'yes
RTS


.close_compilewin:         ; was endstop  org source
  !basic
  *compilerTask\tc_SigExcept = 0
  *compilerTask\tc_ExceptCode = 0
  !asm
RTS


intsused:  Ds.w 1


setcvars:
  MOVE.w #-1,blitzoff
  CLR.w intsused
  CLR.w anyerrs
  CLR.w blitzmode
  CLR.w dontwrite_nomemleft                                              ;nomemleft
  CLR.w constmode
  CLR.w cmake
  CLR.w cfetchmode
  CLR.l intdata1
  CLR.w fuckpos
  CLR.w procnum
  CLR.w procnum2
  CLR.w dfetch
  CLR.l titleat
  CLR.b usedpath
  CLR.b path2
  CLR.w inerr
  CLR.w intlevel
  CLR.l cont_pc
  CLR.l cont_pc2
  CLR.l lastcontlink
  ;
  MOVE.l destbufferstart,destpointer
  MOVE.l destbufferstart,bigpc
  MOVE.l destbufferend,libend
  MOVE.l data1start,data1
  MOVE.l data2at,data2
  ;
  MOVE.w #-1,skipcode                                      ;#-1,comflag org source
  MOVE.w #-1,linemode                                      ;#-1,linemode org soruce
  ;CLR.w oldvcodelen
  CLR.b lastgloballabel                                    ;lastbiglab org source
  ;
RTS


debugmode:  Ds.w 1                                         ;debugga org source ;debugger enabled?


.init_compilerequester:           ; was openstopreq org source
  !basic  
  comstatusstr  = !TRANS{"Initializing Compiler..."} ;default settings
  calcpro       = 0
  calcpro_old   = 0
  typ_old       = -1
  pass_old      = -1
  update_comstatus_gui = True ; for the first

  GetReg D0,&comstatusstr : !ComData_SetL{comPtr_CompileStatusString,d0}
  GetReg D0,&calcpro      : !ComData_SetL{comPtr_CompileCalcProLong ,d0}
  !asm

  CLR.w stopit
RTS


.compileall:   ; was dopass
  ;--
  ;-- compile entire program based on 'pass'
  ; new >
  CLR.w storedebugmode
  CLR.b iserror
  
  BSR.w init_compilerequester
  
  MOVE.l #0,globallinecount
  JSR check_of_same_source
  ; < new
  BSR.w setcvars
  ;
  MOVE.w #$8000,globalvarpointer
  MOVE.l #newtype_quick,defaulttype
  ;
  MOVE.l A7,passstack
  MOVE.l #firstitem_,sourceline
  MOVE.w numlines_org,linesleft
  ; new >
  MOVE.l numlines,numlines2
  ; < new
  ADDQ.w #1,linesleft
  ADDQ.l #1,numlines2
  MOVE.l #-1,linenumat
  ;
  BSR.w resetlibs
  BSR.w Aclearallvars
  ;
  LEA progress_per_line+2,A0
  MOVEQ.l #$03,D0
 'okloop
    CLR.w (A0)+
  DBF D0,'okloop

  ; new >
 'l2a
  LEA _include,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA namebuffer,a1
 'l1b
    MOVE.b (a0)+,(a1)+
  BNE 'l1b
  MOVEQ #9,d2 :  JSR findlabel2 : BNE 'd
    MOVE.l #0,8(a2)
    MOVEM.l (a7)+,a0-a6/d0-d7
    BRA 'd2
 'd
    JSR add_LabelHash
    MOVE.l #$1,4(A2)
    MOVE.l #0,8(a2)
    MOVEM.l (a7)+,a0-a6/d0-d7
 'd2

  LEA _debug,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA namebuffer,a1
 'l9b
    MOVE.b (a0)+,(a1)+
  BNE 'l9b
  MOVEQ #7,d2 : JSR findlabel2 : BNE 'd9
    MOVE.b debugmode(PC),D0
    EXT.w d0
    EXT.l d0
    MOVE.l d0,8(a2)
    MOVEM.l (a7)+,a0-a6/d0-d7
    BRA 'd9b
 'd9
    JSR add_LabelHash
    MOVE.l #$1,4(A2)
    MOVE.b debugmode(PC),D0
    EXT.w d0
    EXT.l d0
    MOVE.l d0,8(a2)
    MOVEM.l (a7)+,a0-a6/d0-d7
 'd9b

  ;-- check for DEBUG-String (no TOKEN!!)
  MOVE.l #firstitem_,a0
  MOVE.l (a0),a0
  LEA 9(a0),a0
  MOVE.w #0,exdebug
  TST.b debugmode : BEQ 'l10
   'l2
    MOVE.b (a0)+,d0 : BEQ 'l10
    CMP.b #" ",d0 : BEQ 'l2
      SUBQ.l #1,a0
      CMP.l #"DEBU",(a0) : BNE 'l10
        CMP.b #"G",4(a0) : BNE 'l10
          MOVE.w #$0,debugversion
          MOVE.b #1,exdebug
 'l10

  ; < new
  ;--
  ;-- put in 4 nops for dummy JSR to init routines! (was 3)
  ;--
  LEA nops4,A0
  LEA nopsf,A1
  JSR pokecode2                                            ;write intro nops
  ; new >
  MOVE.l #$01010101,d1
  JSR writedatalong                                        ;for the 4 tempregs
  JSR writedatalong
  JSR writedatalong
  JSR writedatalong
  TST.b saved0 : BEQ 'l1
    MOVE.l ##opcode_NOP2,d1 : JSR writelong                ;add 2 nops
    MOVE.l ##opcode_NOP2,d1 : JSR writelong                ;add 2 nops
    MOVE.l ##opcode_NOP2,d1 : JSR writelong                ;add 2 nops
    MOVE.l ##opcode_NOP2,d1 : JSR writelong                ;add 2 nops
 'l1

  ; new >
  MOVE.b debugmode(PC),D1 : BEQ.b 'dskip
    MOVE.b debugmode,storedebugmode
    ;
    MOVE.w #$FFDC,D1 : BSR.w uselib                        ;#runerrlib,
    ;
    TST.w debugversion : BNE.b 'exec                       ;make a version for debugger
      ;--
      ;-- is one is not executable as standalone program!
      ;--
      MOVE.w #$FA3C,D1 : BSR.w uselib                      ;#debuglib,
      MOVE.w #$0001,D1 : BSR.w uselib                      ;#dhandlerlib,
      BRA.b 'dskip
   'exec
      ;--
      ;-- thes one is executable!
      ;--
      MOVE.w #$FA32,D1 : BSR.w uselib                      ;#rundebuglib,      
 'dskip

  BSR.w nextline

  ; new >
  CLR.l linenum
  CLR.l stacktrack
  ; < new

  ; ===========================================================================================
  passloop:
    ADDQ.l #1,linenum
    MOVE.l destpointer,destpointer2
    MOVE.l a5,sourceline2

    BSR.w compile_line                                        ;compile pass

    passnxt:
    BSR.w nextline
  BNE.w passloop
  ; ===========================================================================================

  !basic
  log2PED{"compiling done"}
  !asm

  ;-- turn debugger on if enabled
  JSR do_runerrson

  ;-- do typecheck
  !basic
  log2PED{"doing type checks ..."}
  !asm
  BSR.w pointchk
  
  ;-- check if any object is not closed
  TST.b objectcount : BEQ 'allgood
    JMP macenderr
 'allgood

  CLR.l linenumat

  ; -- do label checks
  !basic
  log2PED{"checking labels ..."}
  !asm  
  BSR.w errchx2


  ; --------------------------------
  CMP.l #-1,bssend : BNE 'l30
    MOVE.l destpointer,bssend                                ;compile end
 'l30
  MOVE.l destpointer,d0

  CMP.l #-1,bssstart : BNE 'lnf6
    CMP.l #-1,chipstart : BNE 'lnf6
      BRA 'leven4
 'lnf6
    MOVE.l destpointer,d1
    ADDQ.l #3,d1
    AND.l #$fffffffc,d1                                      ;bug ?
    MOVE.l d1,destpointer
 'leven4

  MOVE.l destpointer,codeend
  CMP.l #-1,chipend : BNE 'l31
    MOVE.l destpointer,chipend
 'l31                                                     ;write exitcode
  MOVE.l destpointer,d1
  ADDQ.l #1,d1
  AND.l #$fffffffe,d1                                     ;new evenexit
  MOVE.l d1,destpointer
  
  MOVE.b debugmode(PC),D1 : BEQ.b 'nodb
    BSR.w insertDebugTrap
    MOVE.w #$C300,D1 : JSR Atokejsr                      ; (runerrslib/finalscheck)
    BSR.w insertDebugTrap
    MOVE.l eopcode(PC),D1 : JSR writelong                ; write end of code info for debugger
    MOVE.l lastcontlink(PC),D1 : BEQ.b 'nocl
      MOVEA.l D1,A0
      CLR.w $6(A0)
   'nocl
 'nodb

  ;--
  ;-- end of whole program!
  ;--
  MOVE.l destpointer,endop                               ;where end goes...

  TST.w blitzmode : BEQ.w 'nobl
    BSR.w do_AMIGA                                       ;back to amiga if in blitz!
 'nobl

  TST.w intsused : BEQ.b 'noints
    MOVE.w #$C105,D1 : JSR tokejsr2                      ;#intlib: clear and free all Interrupts
 'noints

  BSR.w calcstatic
  MOVE.w D4,numstatic
  MOVE.l D3,staticdata
  BSR.w calcmaxs

  TST.l tokeslist : BEQ.b 'skipjsrs
    !regs2stack
    !basic
    log2PED{"starting to fix JSRs..."}
    !asm
    !stack2regs

    MOVE.w gotocode,D1 : JSR writeword
    MOVE.l destpointer,endjmpat
    BSR.w addoff : JSR writelong
    BSR.w fixjsrs                                         ;has to be done before finits!
    ;--
    ;-- misc finish-ups
    ;--
    TST.w dontwrite_nomemleft : BNE.b 'skipjsrs
    
    MOVEA.l endjmpat(PC),A4
    MOVE.l destpointer,(A4)
    ;!regs2stack
    ;!basic
    ;log2PED{"done..."}
    ;!asm
    ;!stack2regs
 'skipjsrs

  ; new >
  TST.b returncode : BEQ 'l2
    MOVE.w #$2e80,d1 : JSR writeword                        ; move.l d0,(a7)
 'l2

  !basic
  log2PED{"adding blitzlib init/fint code ..."}
  !asm
  JSR makeLibFInits

  TST.b returncode : BEQ 'l3
    MOVE.w ##opcode_RTS,d1 : JSR writeword
    BRA 'l1
 'l3
    MOVE.l #$70004E75,D1 : JSR writelong                   ; moveq #0,d0:rts
 'l1

  JSR makeLibInits

  BSR.w asmfixer
  
  BSR.w close_compilewin
RTS

; end of program message
;------                                                  ;disassembled code begin
eopcode:    Dc.w $7003                                   ;MOVEQ #$03,D0
            Dc.w #opcode_TRAP0                           ;TRAP  #00
;------                                                  ;disassembled code end
endjmpat:   Ds.l 1

Even
pointchk:
  MOVE.l #MaxByte,D0                                     ;move.l #$ff,d0 org source

  MOVEA.l newtype_string,A2
 'loop
    CMPA.w #$0,A2 : BEQ.w 'done

    CMP.l 4(A2),D0 : BNE.w 'next
      MOVE.w 8(A2),linenumat+2                           ;type not found  ;move 8(a2),linenumat org source
      BRA.w JUMP_notypeerr1
   'next
    MOVEA.l (A2),A2
  BRA.w 'loop
 'done
RTS


errchx2:
  ;--
  ;-- Make sure all the labels have been resolved
  
  LEA labelbase,A2
 'loop
    MOVE.l (A2),D0 : BEQ.w 'done                           ;testlabels

    MOVEA.l D0,A2
    MOVE.l 4(A2),D0
    BTST #$0,D0 : BNE.w 'loop
      MOVE.l 8(A2),D0 : BNE.w 'loop
        MOVE.w $10(A2),linenumat+2
        MOVEQ #0,d0
        MOVE.b 18(A2),d0
        MOVE.w 0(a2,d0),linenumat
        JMP nolaberr                                        ;label not found
 'done
  MOVE.l concomsp,D0
  CMP.l #concomstack,D0 : BNE.w chxerr4
  MOVE.w connest,D1 : BNE.w chxerr4

errchx:
  MOVE.l D1,-(A7)
  MOVE.l firstsel,D1   :   BNE.w 'err1
  MOVE.l firstrep,D1   :   BNE.w 'err2   ;Repeat-block too large
  MOVE.w intstring,D1  :   BNE.w 'err3   ;SetInt without End SetInt
  MOVE.l 4(a7),d1
  MOVE.w proceduremode,D1: BNE.w 'err6
  MOVE.l firstiff,d1     : BNE.w 'err5
  MOVE.l firstfor,D1     : BNE.w 'err7
  MOVE.l (A7)+,D1
RTS
'err1: MOVE.l sellineat,linenumat : JMP selerrz
'err2: MOVE.l replineat,linenumat : JMP unterr3
'err3: MOVE.l intlineat,linenumat : JMP interr2
'err5: MOVE.l iflineat, linenumat : JMP noenderr
'err6: MOVE.l prolineat,linenumat : JMP nopenderr
'err7: MOVE.l forlineat,linenumat : JMP nonexterr

chxerr4:
  MOVE.l ciflineat,linenumat
JMP nocenderr


.calcmaxs:                                                  ;How many max's used in prog?
  MOVE.l data1,maxsat
  MOVEQ.l #$00,D4
  MOVEA.l libpointer,A2

 'loop
    CMPA.w #$0,A2 : BEQ.w 'done

    TST.w 12(A2) : BPL.w 'next
      MOVE.l 18(A2),D0
      TST.w -$2(A2,D0.L) : BEQ.w 'next
        ADDQ.w #1,D4
        MOVE.w -$6(A2,D0.L),D1
        BSR.w pokedata1
        MOVEQ.l #$01,D1
        MOVE.w -$2(A2,D0.L),D2
        LSL.w D2,D1
        MULU -$4(A2,D0.L),D1                                   ;write objectspacesize
        BSR.w writedatalong
   'next
    MOVEA.l (A2),A2
  BRA.w 'loop
 'done
  MOVE.w D4,maxsused : BEQ.w 'done2
    MOVE.w #$FFFA,D1 : BRA.w uselib      ;was #65530    ;use memlib     ;;use memlib 
 'done2
RTS


;was compilepass
.compile_line:                                              ;doline org source
  ; new >
  MOVE.l a7,stackaddr
  ; < new

  BSR.w compile_term

  BSR.w reget : BNE.w JMP_illeolerr

  ; new >
  TST.w dontwrite_nomemleft : BNE 'l1
    TST.l stacktrack :BNE errormsg_stack
 'l1
  ; < new
  CMP.w ##TokenID_Else,D0 : BNE.w 'notelse           ; was #$8000+34
    JSR do_else2
    BRA.w compile_line
 'notelse

  TST.w D0 : BNE.w compile_line

  ;--
  ;-- here we do any 'un-thens'
 'unthen
    MOVE.l firstiff,D0 : BEQ.w 'done
      MOVEA.l D0,A0
      MOVE.w $C(A0),D1 : BPL.w 'done
        ;
        ;an If...Then... found!
        ;
        BCLR #$F,D1 : JSR doendif2
        JSR freetheifz
  BRA.w 'unthen
 'done
RTS

JMP_illeolerr:  JMP illeolerr
JMP_nolocerr:   JMP nolocerr

createlab:                                                 ;loclabch fetched, make a big label!
  LEA lastgloballabel,A0
  TST.b (A0) :  BEQ.w JMP_nolocerr

  LEA namebuffer,A1
  MOVEQ.l #$00,D2
 'loop
    ADDQ.w #1,D2
    MOVE.b (A0)+,(A1)+
  BNE.w 'loop

  MOVE.b #$27,-$1(A1)
  MOVE.w D2,-(A7)
  JSR makename4
  CMP.w (A7)+,D2 : BEQ.w JUMP_syntaxerr1

  TST.w d0 : BPL 'done
    MOVE.w #$3a,lastchar
   SUBQ.l #2,a5
 'done
RTS


prepstack:
  MOVE.l #forthstack,forthsp
  MOVE.l #precstack,precsp
RTS


chkrealstop:
  ;
  ;return ne if really a stop!
  ;
  MOVEQ.l #$00,D4

  !basic
  ; -- get status of abort 0=no 1=yes
  !ComData_GetB{comByte_CompileStatusAbortByte,d0} : PutReg d0,c_abort.b
  If (c_abort = 1)
    MOVEQ.l #-$01,d4
    MOVE.w D4,stopit
    !asm
    BRA 'skip
  EndIf
  !asm
  MOVEQ.l #$00,D6
  MOVEQ.l #$00,D7                                          ; clr Z-Flag for beq.b in chkstop_chk

 'skip
RTS


.chkstop:
  MOVE.w stopit(PC),D0 : BEQ 'chk
    SUBQ.w #1,stopit
   'rts
    RTS
 'chk
    MOVE.w #2000,stopit
    BSR.w chkrealstop
  BEQ.b 'rts

  ;--
  ;-- gostop
  BSR.w close_compilewin
  ;
  MOVEA.l errstack,A7
  MOVEA.l errcont,A0
  MOVE.w #-1,anyerrs
JMP (A0)


d_pc:           Ds.l 1
d_bigpc:        Ds.l 1
d_nomemleft:    Ds.w 1
cont_pc:        Ds.l 1
cont_pc2:       Ds.l 1
lastcontlink:   Ds.l 1


writetrap:                                                 ;maketrap org source
  ORI.w #opcode_TRAP0,D1
BRA.w JUMP_writeword


insertDebugTrap:
  TST.b debugmode : BEQ.w debugstuffa_rts

  ; new <
insertDebugTrapa:
  CNIF #debugmacro=0
    TST.w inmacro : BNE debugstuffa_rts                     ;disable to show macros in debugger
  CEND
  ; < new                                                   ;no debugging of Macros!
  TST.w direct_mode : BNE debugstuffa_rts                   ;or while in direct mode...

  MOVE.l destpointer,d_pc
  MOVE.l bigpc,d_bigpc
  MOVE.w dontwrite_nomemleft,d_nomemleft
  ;
  MOVEM.l D0-D1,-(A7)
  ;
  MOVEQ.l #$01,D1 : BSR.w writetrap                         ;write a TRAP #1 instruction before each basic sourceline
  ;                                                         ; after that write the current sourceline pointer as long word
  ;hook up cont address...                                  ; then write 
  ;
  MOVE.l destpointer,D0
  MOVE.l cont_pc,D1
  MOVE.l D0,cont_pc
  MOVE.l D1,cont_pc2 : BEQ.b 'skip
    TST.w dontwrite_nomemleft : BNE.b 'skip
      MOVEA.l D1,A4
      SUB.l A4,D0
      MOVE.w D0,$6(A4)
      MOVE.l A4,lastcontlink
    ; new >
 'skip

  TST.w ininclude  ;BEQ 'noinc
  TST.w makeexec : BEQ 'l1
    TST.w exdebug :  BEQ 'noinc
 'l1

  MOVEM.l a0-a1/d2/d3,-(a7)                                ;write source for includes
  MOVE.l data1,d1
  TST.b firsttime :  BNE 'nofirst
    MOVE.b #1,firsttime
    ;-- to be found by debugger the code start
    MOVE.l #"DuCk",d1 : JSR writedatalong
    MOVE.l #"AmiB",d1 : JSR writedatalong
    MOVE.l destbufferstart,d1 : JSR writedatalong
    TST.w dontwrite_nomemleft : BNE 'nohunk
      MOVE.l data1,d1
      SUBQ.l #4,d1
      SUB.l destbufferstart,d1
      MOVE.l d1,d2
      JSR addhunkoffset
   'nohunk
    MOVE.l destpointer,d2
    MOVE.l data1,d1
 'nofirst

  MOVE.l destpointer,d2
  MOVE.l d1,d3
  SUB.l destbufferstart,d1 : OR.l #$80000000,d1 : JSR writelong

  TST.w inmacro : BEQ 'sc1
    MOVE.l macroline,a0
    ;SUBQ.l #1,a0
    BRA 'inc2
 'sc1
    TST.w ininclude : BEQ 'inc
      MOVE.l includesourceline,a0
      BRA 'inc2
   'inc
      MOVE.l sourceline,a0
      LEA 9(a0),a0
 'inc2

  MOVE.l d1,d2
  MOVE.l A5,D1
  SUB.l a0,D1 : ADD.l #9,d1 : BSR.w JUMP_writeword
  
  CMP.l #9,d1 : BEQ 'pos1
    TST.w dontwrite_nomemleft : BNE 'nopad
    
    MOVE.l lastsourceline,d1
    MOVE.l d1,-6(a4)
    BRA 'nopad
 'pos1
    MOVE.l d2,lastsourceline
    MOVE.l destpointer,lastdestpointer
    MOVEQ #0,d1
    MOVE.l data1,d2
    SUB.l destbufferstart,d2
    JSR writedatalong
    TST.w dontwrite_nomemleft : BNE 'no2
      JSR addhunkoffset
   'no2
    MOVE.l data1,d2
    SUB.l destbufferstart,d2
    JSR writedatalong
    TST.w dontwrite_nomemleft : BNE 'no
      JSR addhunkoffset
      MOVE.l lastwritedat,a1
      CMP.l #0,a1 : BEQ 'no
        MOVE.l d3,(a1)
        MOVE.l prevwritedat,4(a1)
        MOVE.l lastwritedat,prevwritedat
   'no
    MOVE.l d3,lastwritedat
    MOVEQ #4,d1
    BSR pokedata1b
   'loop
      MOVE.b (a0)+,d1 : BEQ 'done
      BSR pokedata1b
    BRA 'loop
   'done
  
    MOVEQ #0,d1 : BSR pokedata1b
    MOVE.l data1,d1
    BTST #0,d1 : BEQ 'nopad
      MOVEQ #0,d1
      BSR pokedata1b
 'nopad
  MOVEM.l (a7)+,a0-a1/d2/d3
  BRA 'noinc2
 'noinc

  ; < new
  MOVE.l sourceline,D1    : JSR writelong                   ;write address of sourceline for debugger
  MOVE.l A5,D1
  SUB.l sourceline,D1     : JSR writeword                   ;write position of current command in current sourceline

 'noinc2
  MOVEQ.l #$00,D1 : JSR writeword                           ;next cont goes here! 
  ;
  MOVEM.l (A7)+,D0-D1

 debugstuffa_rts:
RTS


undodebug:
  TST.b debugmode : BEQ.b 'rts                             ;extern debug
    TST.b direct_mode : BNE 'rts
      CNIF #debugmacro = 0
        TST.w inmacro : BNE.b 'rts
      CEND
      MOVE.w d_nomemleft,dontwrite_nomemleft
      MOVE.l d_bigpc,bigpc
      MOVE.l d_pc,destpointer
      MOVE.l cont_pc2,cont_pc
 'rts
RTS


setsvars:                                                  ;set statement vars...
  BSR.w prepstack

  CLR.w regnum
  CLR.w nonew
  CLR.w sbasegot
  ;MOVE.w varcodelen,oldvcodelen
  ;CLR.w varcodelen
  MOVE.w #$FFFF,lasta6
RTS


smode:                                                     ;special mode...d1...
  TST.w linemode : BMI.b 'skip
    BSR.w undodebug
    MOVE.w linemode,D1
    ADDQ.w #4,A7
    LSL.w #2,D1
    LEA modetable,A0
    MOVEA.l $0(A0,D1.W),A0
    BSR.w reget
    JMP (A0)                                                   ;jumptokenroutine
 'skip
RTS


; was compileloop
.compile_term:        ; was  dostatement  org source      ;a0 sourceline  a5 sourcepos compile a term to next ":" or until end of line
  ;process individual statement
  ;                                      
  ; new >
  MOVE.w #0,leaa0a0+2
  CLR.b nowdeclare
  CLR.b notypecheck
  CLR.l lasttoken
  CLR.b doimmediate
  CLR.w vartype
  CLR.w regnumfunc
  CLR.b optistring
  CLR.b iniffcommand
  CLR.w instringon  ; new
  CLR.b funccall
  CLR.l currentfunccall
  CLR.l leftsidetype
  CLR.l rightsidetype
  CLR.w leftsideflagmask
  CLR.w rightsideflagmask
  CLR.b peekaddrsize
  CLR.b blitzparloop
  CLR.b funcparloop
  CLR.w parnum           ;7.2014

  TST.b debugmode : BEQ 'fpu
    CNIF #fpudebug=0
      CLR.b optimize_fpu                                              ;fpu off when debug
    CEND
 'fpu
  MOVE.b optimize_fpu,iee

  MOVE.w stopit(PC),D0 : BNE 'chkstop_chkb
    ; < new
    BSR.w chkstop                                          ; message here
    ; new >
 'chkstop_chkb
  SUBQ.w #1,stopit

 'l20
  ; < new
  BSR.w findmacro                                          ;macro
  ; new >

  CNIF #funcscan
    TST.l funcscan : BEQ funcscanskip

   ;.funcscan_
    CLR.b instringf
    BSR.w get1bytemain
    CMP.w #"#",d0 : BNE 'lf9b
      JSR handleconst
      BRA 'lf9b

   'lf9
      BSR.w get1bytemain
  
     'lf9b
      CMP.w #$22,d0 : BNE 'nos                            ;'"'
        NOT.b instringf
     'nos

      TST.b instringf : BNE 'sk3
        CMP.w ##TokenID_Statement,d0 : ;BEQ 'lf4
        CMP.w ##TokenID_Function,d0 : ;BEQ 'lf4
        CMP.w ##TokenID_XINCLUDE,d0 : BNE 'sk2
          ADDQ.l #2,lastsourcepos
          JSR do_xinclude
       'sk2
        CMP.w ##TokenID_INCLUDE,d0 : BNE 'sk3             
          ADDQ.l #2,lastsourcepos
          JSR do_INCLUDE
     'sk3
    TST.w lastchar : BNE 'lf9
    RTS

   'lf4
    RTS
  CEND

.funcscanskip:    ; was  handlechar   org source

  ;-- Handle the first character in statement
  TST.b debugmode :  BEQ.s 'l10
    TST.b exdebug :  BEQ 'l10a
      MOVE.w (a5),d0
      CMP.w ##TokenID_Dc,d0 : BEQ 'l10      
   'l10a
    BSR.w insertDebugTrapa                                       ;insert runtimecode debugcode
 'l10

 'l1
  BSR.w get1bytemain : BEQ.w undodebug                      ;gettokenmain
  
  CMP.w #$002b,d0 : BNE 'lb2                                ;check for "+" cast sign
    BSR.w get1bytemain
    MOVE.b #1,notypecheck
 'lb2

  ; < new
  ;beq handleeol
  ; new >
  ;  CMP.l #2698,globallinecount : BNE 'lb1
  ;    TRAP #0
  ;  'lb1

  BSR.w setsvars      ; could speed up by coping unroll the code here

  BSR.w smode

  ;
  ; new <
  TST.w D0 : BMI.w get_tokencode               ; was behind cmp ... and befor handleascii in org source
  ; < new
  CMP.w #".",D0 : BEQ.w handlemouse            ; shortlist
  CMP.w #"#",D0 : BEQ.w handleconst            ; constant found
  CMP.w #"'",D0 : BEQ.w handlelocal            ; was #loclabch, local label

  ;-- handleascii
  MOVE.l A5,letstart
  JSR getparameter
  BSR.w reget   : BEQ.w handle_label           ; label found
  CMP.w #"{",D0 : BEQ.w handle_statement       ; statement found

  ; new >
  TST.w d0 : BPL 'll1
    TST.b optimize_newsyntax : BEQ 'll1
      LEA allowtab,a0
      MOVEQ #0,d1
      MOVE.b d0,d1
      TST.b 0(a0,d1.w) : BNE 'll1
        SUBQ.l #2,a5
        MOVE.w #":",lastchar                   ; no doublepoint
        BRA handle_label
 'll1

  CMP.l #"equ ",-1(a5) : BEQ 'll4              ; handle "EQU"
    CMP.l #"EQU ",-1(a5) : BNE 'll2
 'll4
    ADDQ.l #2,a5
    JSR findlabel2 : BEQ.w 'lf1
      JSR add_LabelHash
      MOVE.l #$1,4(A2)
   'lf1
    CMPI.l #$1,4(A2) : BNE.w illconerr

    BSR get1bytemain

    MOVE.l A2,-(A7)
    ;CMP.b #$30,d0 : BLT 'lnonum
    ;CMP.b #$39,d0 : BGT 'lnonum
      ;bra 'lnum
   'lnonum
      ;CMP.b #"#",d0 : BEQ 'lnum
        ;move.b #"#",-2(a5)
        SUBQ.l #1,a5
   'lnum
    SUBQ.l #1,a5
    JSR evalconst2
    MOVEA.l (A7)+,A2

    MOVE.l D3,8(A2)
    RTS
    BSR get1bytemain
 'll2

  CMP.l #"SET ",-1(a5) : BNE 'll3             ; handle "SET"  
    BRA 'll4
 'll3
 ; < new
JMP dolet2


.handleeol:
  CMP.w ##TokenID_Else,D0 : BEQ.w get_tokencode
BRA.w undodebug                              ;!*!*!


.handlelocal:
  BSR.w undodebug                            ;!***!
  BSR.w createlab
BRA.w handlelab2


.handlemouse:
  BSR.w get1bytemain : BEQ.w handleeol     ;syntaxerr
  CMP.w #"'",D0      : BEQ.w handlelocal  ; was #loclabch
  JSR makename2
  ; new >
  TST.w d0           : BPL handle_label
  SUBQ.l #2,a5
  MOVE.w #":",lastchar
BRA handle_label                                              ;????
  ; < new


.handle_label:
  ;an ordinary label
  ;
  BSR.w undodebug      ;!***!
  ;
  LEA namebuffer,A0
  LEA lastgloballabel,A1

 'coplab:
    MOVE.b (A0)+,(A1)+
  BNE.w 'coplab


handlelab2:
  JSR findlabel2 : BEQ.w 'found
    JSR add_LabelHash
  
   'done
    CLR.l 4(A2)                ;no refs
    MOVE.l destpointer,8(A2)   ;pc of label.
    ; new >
    ;clr.l 12(A2)
    ; < new
    ;move.l data2,12(A2)        ;pc for data statements
    MOVE.w procnum,$10(A2)
    RTS
 'found

  MOVE.l 4(A2),D0
  BTST #$0,D0 : BNE.w illlaberr

  ; new >
  TST.w pass ;BNE 'done
  ; new >
  MOVE.l 8(A2),D0 : BNE.w JMP_duplaberr
  MOVE.w procnum,$10(A2)
  ;
  ;now, we have to fill in blanks in the Bloody past code....
  ;
  MOVEA.l 4(A2),A3      ;start of refs list
  MOVEA.l _execbase,A6

 'floop:
    CMPA.w #$0,A3 : BEQ.w 'done
    ; new >
    MOVE.l 4(A2),D1
    BTST #$0,D1 : BNE.w illlaberr
    ; < new
    MOVE.w $8(A3),D1
    CMP.w $10(A2),D1 : BEQ.w 'isok
      ; new >
      TST.b optimize_newsyntax :  BEQ 'l1
        BRA.w 'isok                                     ;label context out of range fix
        ; < new
        ;
        ;Bad Reference
     'l1
        MOVE.w $A(A3),linenumat+2                       ;move 10(a3),linenumat org source
        BRA.w referr
   'isok

    MOVE.w dontwrite_nomemleft,D1 : BNE.w 'isaskip
      MOVEA.l $4(A3),A1
      BTST #$0,$7(A3) : BEQ.w 'pcref
        ;
        ;OK it's a 'Restore' references
        ;
        SUBQ.w #1,A1
        MOVE.l data2,(A1)
        BRA.w 'isaskip
     'pcref
        MOVE.l destpointer,(A1)
   'isaskip

    MOVEA.l _execbase,A6
    MOVEA.l A3,A1
    MOVEA.l (A3),A3
    MOVE.l A3,4(A2)     ;new first.
    MOVEQ.l #$0C+2,D0    ; was #12
    MOVE.l mempool,a0 : JSR _FreePooled(A6)
  BRA.w 'floop

JMP_duplaberr: JMP duplaberr


.handleconst:
  BSR.w prepstack                                      ;forth stax

  JSR getparameter2           ; BSR.w
  ; new >
;.constant2
 ; < new
  JSR findlabel2 : BEQ.w 'cfound
    JSR add_LabelHash
    MOVE.l #$1,4(A2)
    BRA.w 'cn
 'cfound
    CMPI.l #$1,4(A2) :  BNE.w illconerr
  ; new >
CNIF #errorconstant=1
    TST.b declare2 :  BNE errormsg_declaredtwice
    TST.b declare :  BNE errormsg_declaredtwice
CEND
  ; < new
 'cn
  CMP.w #"=",D0 : BEQ.w 'asscon
    RTS
 'asscon
  MOVE.l A2,-(A7)
  JSR evalconst2
  MOVEA.l (A7)+,A2
  MOVE.l D3,8(A2)                                         ;store constant
  ; new >
  CMP.w #$0a,lastchar : BNE 'l1
    MOVE.w #":",lastchar                                   ; hack to read wizard include files
 'l1
  ; < new
RTS


JMP_free_unusedfunctions: JMP free_unusedfunctions

handle_statement:                                          ;a procedure! - eg gameover{score.l,player}
  JSR find_procedure : BEQ '_statement                      ; A2 contains address of function data
    TST.l unusedfunc : BEQ JMP_free_unusedfunctions

    JSR gotoendsource
 '_statement

  TST.b $5(A2)                                              ; this value seems to be always $FFFFFFF now
  ;BPL.w illprocerr                                         ; error function was formly called without returnpar

  MOVE.l a2,currentfunccall

  MOVE.b #1,funccall
  MOVE.b #1,isfunc(a2)

  MOVE.l 14(A2),-(A7)                                       ; pc of proc.
  MOVEQ.l #$00,D0
  MOVE.b 4(A2),D0                                          ; defined parameter count
  MOVE.l d0,parnumtemp
  BEQ.w 'no_defined_parameters                              ; if no parameters defined, we dont have to analyse anything

  TST.b $20(a2)                                             ; startposition on first optional parameter (+1)
  BNE 'no0par                                               ; $1F if all Parameters are mandatory
                                                            ; $00 if only optional parameters defined

  ;-- the procedure has only optional parameters defined
  ;-- lets check if there are any given with the call and init them with default values
  ;-- this is new stuff from Bernd Roesch
  MOVE.l a5,a4                                              ; a5 seems to contain the current sourcestring
 'l1
    CMP.b #" ",(a4)+                                        ; 32 " " --> skip space-characters
  BEQ 'l1
  CMP.b #"}",-1(a4)                                         ; if no parameters are given at all
  BNE 'no0par                                               ; jump to n0par

  MOVEQ #0,d0

  LEA $16(A2),A1                                            ; pointer to variable type list:
                                                            ; 01 ... byte, 02 ... word, 03 ... long,
                                                            ; 04 ... quick, 05 ... float, 06 ... string
 'again
  MOVE.l d1,-(a7)
  MOVE.b (a1),d2                                            ; in D2 we have the parameter datatype
  MOVE.l d0,d1                                              ; seems to be the register number

  CMP.w #4,d2                                               ; is it Type 4 "quick"?
  BNE 'l1b                                                  ; if no, branch ahead
    ADD.l #$203c,d1                                         ; move.l x,y, $0x00 codes the D-Register:
    JSR writeword                                           ; $203c: D0, $223c, D1, $243c: D2, ...
    MOVE.l #$ffff0000,d1
    JSR writelong                                           ; concrete: move.l #-$10000,dx
    BRA 'l2b
 'l1b
    TST.b optimize_fpu                                                ; test against 0
    BNE 'l1c                                                 ; if Zero-Flag is NOT set, then branch
      CMP.w #5,d2                                            ; is the variable Type 5 "float"?
      BNE 'l1c
        ADD.l #$203c,d1                                     ; write code move.l x,y
        JSR writeword
        MOVE.l #$800000c1,d1 : JSR writelong                ; concrete: move.l #-$7FFFFF3F,d2
        BRA 'l2b
   'l1c
      ADD.l #$70ff,d1 : JSR writeword                       ; moveq.l #-$1,dx -> dx register in d1 will be ADD-ed with opcode

      CMP.w #7,d2
      BNE 'l1d
        MOVE.l #$2f3c0000,d1 : JSR writelong                ; write code move.l #0,-(a7)
        MOVEQ #0,d1 : JSR writeword
        
        MOVE.l #$2f3c0000,d1 : JSR writelong                ; write code move.l #0,-(a7)
        MOVEQ #0,d1 : JSR writeword
   'l1d
      TST.b optimize_fpu : BEQ 'l3b                                  ;remove fpustuff, if no fpu mode; honitos 20191113
        MOVE.l #$f23c5000,d1                                ; write code fmove.w #-1,fpx
        MOVE.l d0,d2
        ASR.l #2,d2
        ADD.l d2,d1
        JSR writelong
        MOVE.w #$ffff,d1 : JSR writeword                    ; concrete fmove.w #$-$1,fpx, fpx is masked in the 2. word $5xxxx
     'l3b
 'l2b

  MOVE.l (a7)+,d1
  ADDQ.l #1,a1
  ADD.l #$0200,d0
  CMP.l #$0e00,d0
    BEQ syntaxerr
  TST.b (a1)
  BNE 'again

  BRA 'no_defined_parameters

 'no0par
  MOVE.w a2offset,a2offset2
  LEA $16(A2),A2
  MOVE.b funcparloop,-(a7)
  MOVE.b #1,funcparloop
  MOVE.b blitzparloop,-(a7)
  CLR.b blitzparloop
  ; < new
  BSR.w fetchpees2
  ; new >
  MOVE.b (a7)+,blitzparloop
  MOVE.b (a7)+,funcparloop
  ; < new
  BRA.w 'nopars3


 'no_defined_parameters
  BSR.w get1bytemain

 'nopars3
  CMP.w #"}",D0 : BNE.w morepar_                            ;syntax error morepar

  JSR insert_stackchk
  MOVE.l (A7)+,D1
  ; new >
;  CMP.l #6,parnumtemp : BLE 'l1d
;    CMP.l #11,parnumtemp : BGE 'l1d
;      TST.w a2offset : BEQ 'l1d
;        MOVE.l d1,-(a7)
;        MOVE.w #$47ef,d1                                        ;lea x(a7),a3 nat
;        BSR writeword
;        MOVE.w a2offset,d1
;        SUB.w a2offset2,d1
;        BSR writeword
;        MOVE.l (a7)+,d1
; 'l1d
  ; < new
   JSR makefjsr
  ; new >
;  CMP.l #6,parnumtemp : BLE 'skip2b
;    CMP.l #11,parnumtemp : BGE 'skip2b
;      TST.w a2offset : BEQ.w 'skip2b                          ; changed
;        MOVE.l d1,-(a7)
;        MOVE.l #$4fef0000,d1                                    ; lea $x(a7),a7   nat
;        MOVE.w a2offset,d1
;        SUB.w a2offset2,d1
;        BSR.w writelong                                         ; correct stack with more parameters
;        MOVE.w numreps,movenumrep+2 : BEQ.w 'skip2c
;          MOVE.l movenumrep,D1
;          BSR.w writelong
;       'skip2c
;        MOVE.w a2offset2,a2offset
;        MOVE.l (a7)+,d1
; 'skip2b
  CLR.b funccall
  ; < new
BRA.w get1bytemain


.get_tokencode:                   ; blitz instruction found without return value
  ; process a token in d0
  ;
  ; new >
  MOVE.l d0,lasttoken

  ; preplace some Tokens with other ones
  ; CMP.w #$40a0,d0                 ; hack to replace PutD0 ($40a0-$8000=$C0A0) with GetRegD0
  ; BNE 'l3                         ; $608d-$8000 = E08D
  ;   MOVE.w #$dd06,d0
  ;'l3

  ;--
  ;-- check for inline assembly tokens
  CMP.w ##TokenID_ABCD,D0 : BCS.w 'nono      ; check if token is an asm-token
  CMP.w ##TokenID_List,D0 : BCC.w 'nono      ; we have 76 asm tokens defined
    TST.w set_assemblercheck : BNE.b 'asmok   ; was optreq2ga3+13                            ;inline Assembler checking
      TST.b debugmode : BEQ.b 'l10
        CNIF #debugmacro=0
          TST.w inmacro : BNE.b 'l10
        CEND
        MOVE.w d_nomemleft,dontwrite_nomemleft
        MOVE.l d_bigpc,bigpc
        MOVE.l d_pc,destpointer
        MOVE.l cont_pc2,cont_pc
     'l10
   'asmok

    BRA.w assemble_it                         ;assemble the bastard
 'nono

  ;--
  ;-- handle standard blitzlib token
  BCLR #$F,D0                                 ; found a token of a blitzlib
  MOVE.w D0,D1
  ANDI.w #$7F00,D1 : BNE.w handlelib
  ;

  ;-- check if asm type things....
  ;-- If so, no line remembering etc!
  CMP.w #$B3,D0 : BCS.w 'isokat               ; internal Instruction
    SUBI.w #$77,D0                            ; was #tnum-fnum,
    CMP.w #$4B,D0 : BEQ.w 'noerr              ; was #fnum+15
      CMP.w #$46,D0 : BEQ.w 'noerr            ; was #fnum+10,      
        BRA.w 'doerr                          ; change tokennum
 'isokat
  ;-- check for things which don't want error checking...
  CMP.w #$38,D0 : BEQ.w 'noerr    ; do_ALibJsr
  CMP.w #$39,D0 : BEQ.w 'noerr    ; TokeJsr
  CMP.w #$D,D0  : BEQ.w 'noerr    ; Macro
  CMP.w #$12,D0 : BEQ.w 'noerr    ; XINCLUDE
  CMP.w #$13,D0 : BEQ.w 'noerr    ; Include
  CMP.w #$1A,D0 : BEQ.w 'noerr    ; Data
  CMP.w #$2A,D0 : BHI.w 'doerr    ; INCBIN
  CMP.w #$23,D0 : BCS.b 'doerr    ; EvenX
  
 'noerr
  BSR.w undodebug
 'doerr

  ;-- change tokennum
  SUBQ.w #1,D0
  LSL.w #2,D0
  ;CMP.w #$170,D0       ; was #atokensend-atokens,
  ;BCS.w 'ok
  ;
  ;Freaked out Token!
  ;BSR.w flash         ; was a routine that change the color of screen,background or pointer
  ;
  ;RTS
  ;'ok
  LEA instructionbase,A0
  MOVEA.l $0(A0,D0.W),A0
  MOVE.l A0,-(A7)
BRA.w get1bytemain
 

.handlelib:            ; token in D0
  ; a token from a library!
  ;
  MOVE.w D0,D1
  BSR.w searchinstr    ; input: d1=token, return: a2.l=lib, a3.l=sub (code for token)

  TST.b newmode : BNE compile_term
  BTST #$2,$1(A3) : BNE.w stamigalib        ; a3 = pointer to instr ;toke stuff in a3
  BTST #$0,$1(A3) : BEQ.w needreturn_       ; syntax err need return   ;check it's a statement
  BSR.w sizespec                            ; does it need a size specifier?
  BSR.w countpees

.dolibtoke:
  ; number of parameters in d1....
  ; a2=lib base, a3=sub for this toke
  ;
  MOVE.w numreps,-(A7)
  MOVE.w userp,-(A7)
  MOVE.w a2offset,-(A7)
  MOVE.l A2,-(A7)                           ;recurs.
  MOVE.w convsize,userp
  LEA $6(A3),A1                             ; jump to the calling definitions of the token, e.g. one, two or three parameters ("overload")
  
  ;--
  ;-- now to find a form with d1 parameters in it..... D1 is the number of used parameters in source
 'loop
    MOVE.w (A1),D2 : BMI.w 'SERR            ;statement syntax error

    ANDI.w #$FF,D2
    CMP.w D2,D1    : BEQ.w 'found
      BCS.w 'next
        MOVE.b (A1),D3
        ANDI.w #$7,D3 : BEQ.w 'next
          MOVE.w D2,D4
          SUB.w D3,D4
          MOVEQ.l #$00,D5
          MOVE.w D1,D5
          SUB.w D4,D5
          DIVU D3,D5
          SWAP D5
          TST.w D5 : BEQ.w 'found
     'next
      ADDQ.w #2,A1
      ADDA.w D2,A1
      BSR.w aligna1
      BSR.w skiplibreg
  LEA $C(A1),A1
  BRA.w 'loop
 'SERR
    MOVE.w (a3),d2
    BTST #1,d2  : BEQ statement_
    CMP.w #1,d1 : BEQ statement_
   'l2                           ; skip spaces
      CMP.b #" ",(a5)+
    BEQ 'l2
    CMP.b #"(",-2(a5) : BNE 'l1  ; check for opening brackets, for parameters
      BRA parameter_
   'l1
    BRA inbrackets_
 'found                     ;Got it!

  MOVE.b (A1),D2
  LSL.w #8,D2
  OR.w D2,D1
  MOVE.l A1,-(A7)
  CLR.w a2offset
  TST.w D1 :  BEQ.w 'nopees
    LEA $2(A1),A2             ; datatype of parameter
    MOVE.l lasttoken,-(a7)
    CLR.l lasttoken
    BSR.w fetchlibps
    MOVE.l (a7)+,lasttoken
    BRA.w 'skip
 'nopees
    BSR.w get1bytemain
 'skip
  MOVEA.l (A7)+,A1
  MOVEA.l (A7)+,A2
  MOVE.w a2offset,D1 : BEQ.w 'skip2
    MOVE.w D1,preplibst+2
    MOVE.l preplibst,D1
    JSR writelong                                           ;write array offset stack correct
    MOVE.w numreps,movenumrep+2
    BEQ.w 'skip2
      MOVE.l movenumrep,D1
      JSR writelong;??looks like double label??
     'l10
 'skip2                
  ;-- make the JSR
  JSR userjsr

  ; new >
 'l20
  ; < new
  MOVE.w a2offset,D1 : BEQ.w 'skip3
    CMP.w #$8,D1 : BHI.w 'skip4
      ANDI.w #$7,D1
      LSL.w #8,D1
      LSL.w #1,D1
      ORI.w #$504F,D1       ;addq #x,a7
      JSR writeword
      BRA.w 'skip3
   'skip4
    MOVE.w D1,fixlibst+2
    MOVE.l fixlibst,D1
    JSR writelong
 'skip3
  MOVE.w (A7)+,a2offset
  MOVE.w (A7)+,userp
  MOVE.w (A7)+,numreps
BRA.w reget 


.sizespec2:
  MOVEM.l A2-A3,-(A7)
  ; new >
  CLR.b doublepeek
  ; < new
  MOVE.l A5,lastsourcepos

  BSR.w getchar
  CMP.w #".",D0 : BEQ.w 'ok1
    MOVEA.l defaulttype,A2
    CMP.w #"$",D0 : BNE.w 'none
      MOVEQ.l #$07,D1
      BRA.w 'skip
 'ok1
  JSR getparameter2 : BEQ.w syntaxerr           ;bsr.w
  
  LEA newtypebase,A2 :  JSR findtype            ; BSR.w
  BNE.w notypeerr

 'none
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
CNIF #function_support_returntype = 0
  ; < new
  CMPI.l #$100,4(A2) : BCC.w illtypeerr
  ; new >
CEND
  ; < new
  MOVE.w $6(A2),D1
  ; new >
  CMP.w #8,8(a2) : BNE 'l1
    MOVE.b #1,doublepeek
 'l1
  ; < new                                                       ;??looks like double label??
 'skip
  MOVE.w D1,convsize
  MOVEM.l (A7)+,A2-A3
RTS



sizespec
  BTST #$3,$1(A3) : BEQ.w 'skip
    BSR.w sizespec2                                         ;read peek/poke size

    ORI.w #$7000,D1
    JSR writeword
    ADDQ.w #1,regnum
 'skip
RTS

;-----------subs-------------------------------;


;------                                                  ;disassembled code begin
swapb:
            Dc.w $1012                                   ;MOVE.B  (A2),D0
            Dc.w $1491                                   ;MOVE.B  (A1),(A2)
            Dc.w $1280                                   ;MOVE.B  D0,(A1)
swapbf:


swapw:      Dc.w $3012                                   ;MOVE.W  (A2),D0
            Dc.w $3491                                   ;MOVE.W  (A1),(A2)
            Dc.w $3280                                   ;MOVE.W  D0,(A1)
swapwf:


swapl:      Dc.w $2012                                   ;MOVE.L  (A2),D0
            Dc.w $2491                                   ;MOVE.L  (A1),(A2)
            Dc.w $2280                                   ;MOVE.L  D0,(A1)
swaplf:


pulla1:     Dc.w $225F                                   ;MOVEA.L (A7)+,A1
;------                                                  ;disassembled code end

srctype:    Ds.w 1


Even
.do_Exchange:                                            ;'swap' 2 variables.
  BSR.w excget
  CMP.w #",",D0 : BNE.w syntaxerr

  MOVE.b D2,srctype
  MOVE.w pusha2,D1
  JSR writeword
  BSR.w get1bytemain
  BSR.w excget
  CMP.b srctype,D2 : BNE.w excerr2

  MOVE.w pulla1,D1
  JSR writeword
  ;
  CMP.b #$2,D2
   BCS.w 'byte
   BEQ.w 'word
  LEA swapl(PC),A0
  LEA swaplf(PC),A1
 JMP pokecode

 'word
  LEA swapw(PC),A0
  LEA swapwf(PC),A1
 JMP pokecode

 'byte
  LEA swapb(PC),A0
  LEA swapbf(PC),A1
JMP pokecode


excget:
  JSR getparameter
  JSR fetchvars
  JSR calcvar
  BTST #$E,D2
   BEQ.w 'skip
  MOVE.b #$4,D2

 'skip
  TST.b D2
   BEQ.w excerr
  BTST #$F,D2
   BNE.w 'done
  MOVE.w leaamp,D1
   JSR pokewda5s
  MOVE.w D3,D1
 JMP writeword

 'done
RTS

.do_WBStartup:
  MOVE.w #$BF00,D1       ; was #wbstart
JMP Atokejsr

.do_Pop:
  CMP.w ##TokenID_Gosub,D0  : BEQ.w popreturn
  CMP.w ##TokenID_For,D0    : BEQ.w popnext2
  CMP.w ##TokenID_Select,D0 : BEQ.w popselect2

  CMP.w ##TokenID_If,D0     : BEQ.w get1bytemain
  CMP.w ##TokenID_While,D0  : BEQ.w get1bytemain

  CMP.w ##TokenID_SYNTAX,D0 : BEQ.w get1bytemain
  CMP.w ##TokenID_Repeat,D0 : BEQ.w get1bytemain
BRA.w syntaxerr


.popreturn:
  TST.b debugmode : BEQ.w 'norerr

  LEA 'rfix(PC),A0
  LEA 'rfixf(PC),A1    :  JSR pokecode
  MOVE.w #$C305,D1     :  JSR Atokejsr                    ; (runerrslib, #chkret)
  MOVE.w 'rfix2(PC),D1 :  JSR writeword
  BRA.w get1bytemain

 'rfix
  CMPI.w #$6753,$4(A7)                                     ;#"gS",4(A7)
  BEQ.w 'rfix2

 'rfixf
  JSR $20000                                               ;reass
                                                           ;jsr 0 org source
 'rfix2
  ADDQ.w #6,A7

 'norerr
  MOVE.w 'sfix(PC),D1 : JSR writeword
BRA.w get1bytemain


;------                                                  ;disassembled code begin
'sfix
  Dc.b $58,$4F                                             ;ADDQ.W  #4,A7
;------                                                  ;disassembled code end

Even
popnext2:
  MOVE.l firstfor,D0 : BEQ.w noforerr

  MOVEA.l D0,A2
  BSR.w get1bytemain
  BSR.w popnext

 popnext3:
  TST.b debugmode : BEQ.w 'ner
    MOVE.l nextfixw2,D1
    CMPI.w #$3,12(A2) : BCS.w 'writelong2
      MOVE.l nextfixl2,D1
   'writelong2
    JMP writelong
 'ner
    CMPI.w #$3,12(A2) : BCS.w 'skip2
      MOVE.l nextfixl,D1
      JMP writelong
   'skip2
    MOVE.w nextfixw,D1
JMP writeword



popnext:
  MOVE.w 12(A2),D0
  TST.b debugmode : BEQ.w 'norunerr
    MOVE.w #$C306,D1        ; (runerrslib/nextchkw)
    CMP.w #$3,D0 : BCS.w 'oktc
      ADDQ.w #1,D1          ; (runerrslib/nextchkl)
   'oktc
    MOVE.l A2,-(A7)
    JSR Atokejsr
    MOVEA.l (A7)+,A2
 'norunerr
RTS


popselect2:
  MOVE.l firstsel,D0 : BEQ.w eselerr
  MOVEA.l D0,A2
  BSR.w get1bytemain

popselect:
  MOVE.w 12(A2),D2
  TST.b debugmode : BEQ.w 'norerr
    MOVE.w #$C313,D1
    CMP.w #$3,D2 : BCS.w 'chkit
      ADDQ.w #1,D1
   'chkit
    JSR Atokejsr                                             ;make sure next thing on stack
    ;is a select
 'norerr
  MOVEQ.l #$02,D1
  CMP.w #$3,D2 : BCS.w 'doit

  MOVEQ.l #$04,D1
  CMP.w #$7,D2 : BCS.w 'doit

  LEA endselstr,A0
  LEA endselstrf,A1
  TST.b debugmode : BEQ.w 'norerr3
    LEA endselstrf2,A1
 'norerr3
  JSR pokecode
  MOVE.w #$C003,D1                                         ;global freemem
  JMP Atokejsr

 'doit
  TST.b debugmode : BEQ.w 'norerr2
    ADDQ.w #2,D1                                           ;for the "sE"
 'norerr2
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w endsel,D1
JMP writeword


firstrep:    Ds.l 1
replineat:   Ds.l 1


.do_Repeat:
  ;Repeat...
  ;.
  ;.
  ;.
  ;Until a=10
  CLR.l fp0addr
  MOVE.l linenumat,replineat
  MOVEA.l _execbase,A6
  MOVEQ.l #$08,D0
  MOVE.l mempool,a0 : JSR _AllocPooled(a6)
  MOVEA.l D0,A0

  MOVE.l firstrep(PC),(A0)
  MOVE.l A0,firstrep
  MOVE.l destpointer,$4(A0)
RTS


str_temp:  Ds.w 3                                            ;infochk  ds.b 6 org source

check_for_infoextention:                                     ;does a0 end in .info?
  LEA str_temp(PC),A1
  CLR.w (A1)
  CLR.l $2(A1)

 'loop2
  MOVEQ.l #$04,D0

 'loop
    MOVE.b $1(A1),(A1)+
  DBF D0,'loop

;  !basic
;   logging{Peek$(?str_temp)+" "}
;  !asm
  LEA str_temp(PC),A1
  MOVE.b (A0),D0
  ORI.b #" ",D0
  MOVE.b D0,$5(A1)
  TST.b (A0)+ : BNE.w 'loop2
  CMPI.w #$2E69,(A1)+ : BNE.w 'no                          ;".i"
  CMPI.l #$6E666F20,(A1)                                   ;"nfo "
 'no
RTS


.getTokenPS:                                                ;toke jsr
  BPL.w 'evaltoke
    MOVE.w D0,D1
    ANDI.w #$7F80,D1 :  BEQ.w tokeerr

    BCLR #$F,D0
    MOVE.w D0,D4                                           ;got toke number
    BSR.w get1bytemain
    BRA.w 'gotnum
 'evaltoke
    JSR evalconst
    CMP.l #MaxWord,D3 : BHI.w tokeerr
    TST.w D6 : BNE.w tokeerr

    MOVE.w D3,D4
 'gotnum

  MOVEQ.l #$00,D5
  CMP.w #",",D0 : BNE.w 'gotfrom
    MOVE.w D4,-(A7)
    JSR evalconst2

    CMP.l #MaxWord,D3 : BHI.w tokeerr
    TST.w D6 : BNE.w tokeerr

    MOVE.w D3,D5
    MOVE.w (A7)+,D4
 'gotfrom
RTS                                                        ;d4=toke, d5=form


.do_ALibJsr:
  TST.w D0 : BSR.w getTokenPS

  MOVE.w ##opcode_JSR,D1 : JSR writeword
  BSR.w addoff
  MOVE.w D5,D1
  ORI.w #$8000,D1                                          ;Toke of Amiga type.
  SWAP D1
  MOVE.w D4,D1
JMP writelong


.do_BLibJsr:
  TST.w D0 : BSR.w getTokenPS

  MOVE.w ##opcode_JSR,D1 : JSR writeword
  BSR.w addoff
  MOVE.w D5,D1
  ORI.w #$C000,D1                                          ;Toke of Blitz type.
  SWAP D1
  MOVE.w D4,D1
JMP writelong


.do_SysJsr:
  JSR evalconst
  CMP.l #$10000,D3 : BCC.w tokeerr

  MOVE.w D3,D1
JMP Atokejsr


.do_TokeJsr:
  BSR.w getTokenPS
  MOVE.w ##opcode_JSR,D1 : JSR writeword
  MOVE.l destpointer,D3
  BTST #$7,blitzmode : BEQ.w 'inamiga
    BSET #$E,D5
 'inamiga
  BSR.w maketjsr
  BSR.w addoff
JMP writelong


.do_VWait:
  BEQ.w 'zero
    MOVEQ.l #$02,D2                                          ;get a word
    ;BSR.w bakeval
    JSR bakeval
    MOVE.w fvwait(PC),D1
    BRA.w 'vcont
 'zero
    MOVE.w #$7000,D1                                         ;moveq #0,d0
 'vcont
  JSR writeword
  MOVE.w #$C104,D1                                         ; intlib, vwaitint
JMP Atokejsr

fvwait:    SUBQ.w #1,D0
cgoblitz:  Dc.w $3b7c,$ffff,0                                       ;move.w #$FFFF,$0(A5) ;noopt
cgoamiga:  Dc.l $426d0001                                           ;clr.w $0(A5)


debugmode_codelabel:                                       ;debugmode org source
  MOVE.b debugmode(PC),D1 : BEQ.b 'skip
    MOVE.w #$D500,D1 : JMP Atokejsr
 'skip
RTS


.do_BLITZ:                                                 ;go into Blitz mode!
  BSET #$0,blitzmode
  BSET #$7,blitzmode
  MOVE.w #$C200,D1 : JSR Atokejsr                          ; switchlib, goblitz
  TST.b debugmode : BEQ.w 'done
    MOVE.w cgoblitz(PC),D1 : JSR writeword
    MOVEQ.l #-$01,D1 : JSR writeword
    JSR getbbase
    JSR writeword
 'done
BRA.w debugmode_codelabel


.do_AMIGA:                                                 ;go into Amiga mode
  MOVE.w #$C201,D1                                         ; switchlib, goamiga
BRA.w do_AMIGA_toamode

.do_QAMIGA:                                                ;go into quick amiga mode
  MOVE.W  #$C202,D1                                        ; switchlib, goqamiga

do_AMIGA_toamode:
  BSET #$0,blitzmode
  BCLR #$7,blitzmode
  JSR Atokejsr

  TST.b debugmode : BEQ.w 'done
    MOVE.w cgoamiga(PC),D1 : JSR writeword
    JSR getbbase
    JSR writeword
 'done
BRA.w debugmode_codelabel


intstart0: MOVEM.l D2-D7/A2-A4,-(A7)
intfin:    MOVEM.l (A7)+,D2-D7/A2-A4


.do_ClrInt:
  JSR evalconst
  CMP.l #$E,D3 : BCC.w interr4

  MOVE.w #$7000,D1                                         ; MOVEQ#0,D0
  OR.w D3,D1
  JSR writeword
  MOVE.w #$C101,D1                                         ; intlib, ClrAnInt,  libnum 65520
JMP Atokejsr                                               


inerr:       Ds.w 1                                        ;flag - in error trap mode
errjmp:      Ds.l 1                                        ;where err jump is
errcode:     Ds.l 1


.do_ClrErr:
  MOVE.W  #$D202,D1                                        ;
JMP Atokejsr                                               ;BRA.W Atokejsr


.do_ErrFail:
  MOVE.w #$D205,D1
JMP Atokejsr


.do_SetErr:
  MOVE.w proceduremode,D1 : BNE.w errerr1
  MOVE.w inerr(PC),D1 : BNE.w errerr2

  LEA inerr,a0                                             ; set inerr to indicate we are in a error routine definitions
  NOT.w (a0)                                               ;reass
  
  ;-- pass current "pc" to errhandler routine
  MOVE.w #$203C,D1                                         ;move.l <current pc>,d0
  JSR writeword
  MOVE.l destpointer,errcode
  BSR.w addoff
  JSR writelong                                             ; write dummy long, will be filled with real adress later


  ;-- register code in trap handler
  MOVE.w #$D201,D1 : JSR Atokejsr                           ; call errroutinecaller

  ;-- insert a jump to skip the error code  
  MOVE.w ##opcode_JMP,D1 : JSR writeword
  MOVE.l destpointer,errjmp
  BSR.w addoff
  JSR writelong                                             ; write dummy long, will be filled with real adress later

  MOVE.w dontwrite_nomemleft,D1 : BNE.w 'skip
    MOVEA.l errcode(PC),A0
    MOVE.l destpointer,(A0)                                 ; patch address of errorcode begin into generated code
 'skip
RTS


doendseterr:
  MOVE.w inerr(PC),D1 : BEQ.w errerr3                       ; end seterr without set err

  CLR.w inerr

  MOVE.w dontwrite_nomemleft,D1 : BNE.w 'skip
    MOVEA.l errjmp(PC),A0                                   ; patch address of reentry code into generated code
    MOVE.l destpointer,(A0)
 'skip
BRA.w get1bytemain




intlineat:  Ds.l 1        ; storing the current line for routine errchx


.do_SetInt:
  MOVEQ.l #-$01,D1                                        ;type - need new string space
  BSR.w errchx
  MOVE.w D1,intstring                                     ;indicate that an setint is there
  MOVE.l linenumat,intlineat

  JSR evalconst                                           ;get constant - int level
  CMP.l #$E,D3 :  BCC.w interr4

  ST intsused
  MOVE.w D3,intlevel

  MOVE.w #$7000,D1                                        
  OR.w D3,D1                                            ;MOVEQ #<d3>,d0 ... intlevel to pass to addanInt 
  JSR writeword                                         

  MOVE.w #$223C,D1 : JSR writeword                      ;move.l #x,d1   ... 
  BSR.w addoff
  MOVE.l destpointer,-(A7)
  JSR writelong                                         ;write dummy long, real address will be patched later

  MOVE.w #$C100,D1 : JSR Atokejsr                       ;intlib: addAnInt

  MOVE.w ##opcode_JMP,D1 : JSR writeword  
  BSR.w addoff
  MOVE.l destpointer,intjmpat
  JSR writelong                                         ;write dummy long, readl adress will be patched in End SetInt
  MOVEA.l (A7)+,A0

  MOVE.w dontwrite_nomemleft,D1 : BNE.w 'dontpoke      
    MOVE.l destpointer,(A0)                             ; patch address for begin of interrupt code (see above)
 'dontpoke

  MOVE.l intstart0(PC),D1 : JSR writelong               ; code to store registers on stack

  TST.b debugmode : BEQ.w 'norerr
    ;
    ;debugga stuff..
    ;
    MOVEQ.l #$02,D1 : BSR.w writetrap
    BSR.w addoff
    MOVE.l destpointer,intcleanat : JSR writelong
    MOVE.w intlevel,D1 : JSR writeword
    MOVE.w #$C30B,D1 : JSR Atokejsr                         ; (runerrslib, stackchk): disable stack checks
 'norerr

  MOVE.w #$FED3,D1 : BSR.w uselib                           ; 65235, strings1lib
  MOVE.w #$C102,D1 : JSR Atokejsr                           ; (intlib, restoreA5): set A5 to value at startup
  MOVE.w #$FFFF,lasta6
  MOVE.l linenumat,intline
RTS


;intallox:  Ds.w 1                                         ;mask for allocates for interrupts
            
intdata1:   Ds.l 1                                         ;where in data1 a5 is being kept

intjmpat:   Ds.l 1
intline:    Ds.l 1
intstring:  Ds.w 1                                         ;flag 0 = no setint
                                                           ;>0=setint, no string space
                                                           ;<0=set, string space
intlevel:   Ds.w 1
intcleanat: Ds.l 1
ret15add:   Ds.l 1
ret15cc:    Ds.w 1


directTrap15:                                              ;directrap trap #15
  ADDI.l #$12,$2(A7)
  MOVE.l $2(A7),ret15add
  MOVE.w (A7),ret15cc
  MOVE.l #directdo,$2(A7)
RTE
  ;.l : input - code to compile
  ;.l : firstlocal
  ;.l : firstglobal
  ;.l : returned - 0 if no compile error, else pointer to err text
  ;.w : blitz mode status

.trap15                                                    ;??looks like double label??
directdo:
  MOVE.l ret15add(PC),-(A7)
  MOVE.w ret15cc(PC),-(A7)                                 ;15*4
  MOVEM.l D0-D7/A0-A6,-(A7)
  MOVE.l destbufferend,trap15temp                          ;store high buff addr
  MOVE.l destbufferstart,trap15temp2
  MOVE.l libend,templibend
  MOVE.l data1start,tempdata1start
  CLR.l hunkoffsetcounter

  MOVE.l directbuffer,a0
  CNIF #debugtrap
    MOVE.l #$40000,a0
  CEND
  MOVE.l a0,destbufferstart
  ADD.l #3900,a0
  MOVE.l a0,destbufferend
  TST.b exdebug : BEQ 'l1
    MOVE.l a0,libend
    ADD.l #4000,a0
    MOVE.l a0,data1start
 'l1
  MOVE.l #'dircont,errcont
  MOVE.l a7,stackaddr                                      ; added to prevent a possible crash in CLIMode if #continue_on_error is set  tomsmart1
  MOVE.l A7,errstack
  MOVE.w #$FFFF,direct_mode
  CNIF #debugtrap=0
    MOVEA.l ret15add(PC),A1
    MOVE.w -(A1),blitzmode
    CLR.l -(A1)
    MOVE.l -(A1),firstglob
    MOVE.l -(A1),firstlocal
  CEND
  CLR.w proceduremode
  MOVE.l firstglob,D0
  OR.l firstlocal,D0
  BEQ.b 'skip
    NOT.w proceduremode
 'skip
  MOVEA.l -(A1),A0                                         ;address of string
  CNIF #debugtrap
    LEA testcode,a0
  CEND
  MOVE.l A0,-(A7)
;  MOVEA.l comdata,A1
;  MOVEA.l $38(A1),A1
  !ComData_GetL{comFunc_DebugTrap,A1} : JSR (A1)           ;returns tokenised line in A1

  MOVEA.l (A7)+,A5
  MOVE.l directbuffer,destpointer

  TST.b exdebug : BEQ 'noexdebug
    MOVE.l a5,a0
    MOVE.l #200,d0
   'l2
      MOVE.b 0(a0,d0.l),8(a0,d0.l)
    DBF d0,'l2

    CNIF #debugtrap
      MOVE.l destbufferstart,destpointer
    CEND

    MOVE.l destpointer,a0
    MOVE.w #$207c,(a0)+
    MOVE.l a5,d0
    ADD.l #$206,d0                                           ;constant from debuglib
    MOVE.l d0,(a0)+
    MOVE.l a0,destpointer
    MOVE.l a5,a0
    MOVE.w #$8039,(a0)+                                      ;TokeJsr 164 (inputoutputlib) LSL 7+4
    MOVE.l #"$520",(a0)+
    MOVE.w #"4:",(a0)+
 'noexdebug

  CLR.w dontwrite_nomemleft
  MOVE.w #$FFFF,lasta6
 
  BSR.w compile_line                                        ;.....compile it

  TST.b exdebug : BEQ 'noexdebug2
    JSR fixjsrs
 'noexdebug2

  CLR.w proceduremode
  BSR.w errchx
  MOVE.w ##opcode_JMP,D1 :  JSR writeword
  MOVE.l ret15add(PC),D1 :  JSR writelong                   ;jmp to done
  MOVE.w dontwrite_nomemleft,D0 : BNE.w nodirmemerr

  MOVE.l directbuffer,$3E(A7)                              ;install code address

 'direxit
  CLR.w direct_mode
  MOVE.w ret15cc(PC),$3C(A7)
  MOVE.l trap15temp,destbufferend
  MOVE.l trap15temp2,destbufferstart
  MOVE.l tempdata1start,data1start
  MOVE.l templibend,libend
  MOVEM.l (A7)+,D0-D7/A0-A6
  BSR.w clear_Cache                                        ;selden used
RTR

 'dircont                                                  ;direct mode error! - d0=error text
  MOVEA.l ret15add(PC),A0
  SUBQ.w #2,A0
  MOVE.l D0,-(A0)
BRA.w 'direxit


stamigalib:                                                ;an amigalib called through a statement!
  MOVE.w $6(A3),D1 : BSR.w uselib                          ;get lib for base address
  MOVE.w $A(A1),-(A7)                                      ;libbase reg
  ADDQ.w #8,A3
  MOVE.w (A3)+,-(A7)                                       ;get offset for lib
  MOVE.l A3,-(A7)
  ;
  ;collect longs for lib
  ;
  MOVEQ.l #$00,D3
  ; new >
  JSR checka4a5
  ; < new

 'loop                                                   ;no return value amigalib call parameter compile (can use recursive)
  MOVE.b (A3)+,D1
   BMI.w 'done
  MOVEQ.l #$03,D2
  ADDQ.w #1,D3
  MOVEM.l D3/A3,-(A7)
  ; new >
  MOVE.b funcparloop,-(a7)
  MOVE.b #0,funcparloop
  MOVE.l leftsidetype,-(a7)
  MOVE.l rightsidetype,-(a7)
  MOVE.w leftsideflagmask,-(a7)
  MOVE.w rightsideflagmask,-(a7)
  CLR.l leftsidetype
  CLR.l rightsidetype
  CLR.w leftsideflagmask
  CLR.w rightsideflagmask
  MOVE.b blitzparloop,-(a7)
  MOVE.b #1,blitzparloop                                 ;write the parameter to stack
  ; < new
  JSR peval
  ; new >
  MOVE.b (a7)+,blitzparloop
  MOVE.w (a7)+,rightsideflagmask
  MOVE.w (a7)+,leftsideflagmask
  MOVE.l (a7)+,rightsidetype
  MOVE.l (a7)+,leftsidetype
  MOVE.b (a7)+,funcparloop
  MOVEM.l (A7)+,D3/A3
  ; < new
  CMP.w #",",D0 : BEQ.w 'loop
  TST.b (A3) : BPL.w syntaxerr

 'done
  MOVEA.l (A7)+,A3
  SUBQ.w #1,D3
   BPL.w 'toend
   BSR.w get1bytemain                                      ;no pars - get :
 BRA.w 'nopars

 'toend
  TST.b (A3)+                                              ;go to end of params
   BPL.w 'toend
  SUBQ.w #1,A3

 'loop2                                                    ;fetch the parameter from stack and put to correct register
   MOVEQ.l #$00,D1
   MOVE.b -(A3),D1
   BTST #$4,D1
    BNE.w 'addreg
   LSL.w #8,D1
   LSL.w #1,D1
   ORI.w #$201F,D1
 BRA.w 'gotit

  'addreg
   ANDI.w #$7,D1
   LSL.w #8,D1
   LSL.w #1,D1
   ORI.w #$205F,D1

  'gotit
    JSR writeword
  DBF D3,'loop2

 'nopars
  MOVE.w (A7)+,libjsr+2
  MOVE.w (A7)+,libbase+2
  MOVE.l libbase,D1
  JSR writelong
  MOVE.l libjsr,D1
  JSR writelong
  ; new >
  JSR restorea4a5
  ; < new
RTS


alloxinc:                                                  
  ;increment allocs by 150%
  ;
  ; new >
  !basic
  log2PED{"increasing buffers"}
  !asm

  MOVE.l data1,D4  : SUB.l data1start,D4      : ADD.l #10000,d4
  MOVE.l libend,D3 : SUB.l destbufferend,D3   : ADD.l #40000,d3
  MOVE.l bigpc,D2  : SUB.l destbufferstart,D2 : ADD.l #20000,d2
  MOVE.l databuffer,D5                        : ADD.l #10000,D5
  BRA newallox
  ; < new                                                        

  MOVE.l objectbuffer,D2 :  LSR.l #1,D2 : ADD.l objectbuffer,D2
  MOVE.l libsbuffer,D3   :  LSR.l #1,D3 : ADD.l libsbuffer,D3
  MOVE.l systembuffer,D4 :  LSR.l #1,D4 : ADD.l systembuffer,D4
  MOVE.l databuffer,D5   :  LSR.l #1,D5 : ADD.l databuffer,D5
BRA.w newallox


alloxadj:                                                      ;ne if enough mem for allox
  MOVE.l bigpc,D2
  SUB.l destbufferstart,D2                                     ;size of object buffer
  SUB.l savefuncspace,d2

  TST.w debugversion : BNE.b 'skip
    ADDI.l #$800,D2
 'skip

  MOVE.l libend,D3 : SUB.l destbufferend,D3
  MOVE.l data1,D4  :  SUB.l data1start,D4
  MOVE.l data2,D5  :  SUB.l data2at,D5

newallox:
  BSR.w make_allox : BNE.w 'done
    BRA.w init_buffers
 'done
RTS


.free_allox:
  MOVE.l objlen,D0 : BEQ.w 'skip
    MOVEA.l _execbase,A6    
    CLR.l objlen
    MOVEA.l destbufferstart,A1 : JMP _FreeVec(A6)
 'skip
RTS


.init_buffers:                                             ;makeiallox org source ;initial allox
  MOVE.l objectbuffer,D2
  MOVE.l libsbuffer,D3
  MOVE.l systembuffer,D4
  MOVE.l databuffer,D5

.make_allox:
  ;-- d2 = pc size
  ;-- d3 = lib size
  ;-- d4 = data1
  ;-- d5 = data2
  ;--
  MOVE.w #$FFFF,anyerrs      ; was -1
  BSR.w free_allox
  ;--
  ;-- word align blocks
  ;--
  ADDQ.l #1,D2 :  BCLR #$0,D2
  ADDQ.l #1,D3 :  BCLR #$0,D3
  ADDQ.l #1,D4 :  BCLR #$0,D4
  ; new >
  TST.l d5 : BNE 'l1 ; ??? make no sence ??
 'l1
  ; < new
  ADDQ.l #1,D5 :  BCLR #$0,D5
  ;
  MOVE.l D2,D0
  ADD.l D3,D0
  ADD.l D4,D0
  ADD.l D5,D0 : ADD.l #moremem,d0
  MOVE.l D0,D6
  MOVE.l #MemfPublic_MemfClear,D1
  MOVEA.l _execbase,A6 : JSR _AllocVec(a6)                         ; alloc mem for objectbuffer
  TST.l D0 : BEQ.w 'done
    MOVE.l D6,objlen
    MOVE.l D2,objectbuffer
    MOVE.l D3,libsbuffer
    MOVE.l D4,systembuffer
    MOVE.l D5,databuffer
    MOVE.l D0,destbufferstart
    ; new >
    ;  MOVE.l comdata,a0
    ;  MOVE.l d0,$1f0(a0)
    !ComData_SetL{comPtr_DestBufferStart,D0}
    !ComData_SetL{comLong_DestBufferSize,D6} ; add that the Debugger have the right size of the buffer  tomsmart1 2016 02 06
    ; < new
    ADD.l D2,D0 : MOVE.l D0,destbufferend
    ADD.l D3,D0 : MOVE.l D0,data1start
    ADD.l D4,D0 : MOVE.l D0,data2at
    ADD.l D5,D0 : MOVE.l D0,allat
 'done
RTS


divisors:
  Dc.b $00,$00,$00,$01                                     ;         1
  Dc.b $00,$00,$00,$0A                                     ;        10
  Dc.b $00,$00,$00,$64                                     ;       100
  Dc.b $00,$00,$03,$E8                                     ;      1000
  Dc.b $00,$00,$27,$10                                     ;     10000
  Dc.b $00,$01,$86,$A0                                     ;    100000
  Dc.b $00,$0F,$42,$40                                     ;   1000000
  Dc.b $00,$98,$96,$80                                     ;  10000000
  Dc.b $05,$F5,$E1,$00                                     ; 100000000
  Dc.b $3B,$9A,$CA,$00                                     ;1000000000
Even

makelong:                                                  ;put long in d2 into (a0)+
  MOVEQ.l #$00,D1                                          ;no zero printed
  MOVEQ.l #"$",D3                                          ; 36

 'loop
    MOVEQ.l #"0",D4                                          ; 48

   'loop2
      CMP.l divisors(PC,D3.W),D2 : BCS.w 'skip
      SUB.l divisors(PC,D3.W),D2
      ADDQ.w #1,D4
    BRA.w 'loop2
   'skip
    CMP.b #"0",D4 :  BNE.w 'doit
    TST.w D1      :  BEQ.w 'skip2

   'doit
    MOVE.b D4,(A0)+
    MOVEQ.l #$01,D1

   'skip2
  SUBQ.w #4,D3 :  BPL.w 'loop
  TST.w D1 :  BNE.w 'skip3
  MOVE.b #"0",(A0)+

 'skip3
  CLR.b (A0)
RTS


.menu_createresidentfile:      ; was menu5, make a resident!, A1 points to the resident file name
  MOVE.l macrobase,D0 :  BNE.w 'skip
    MOVE.l newtype_string,D0 : BNE.w 'skip

      ;-- check if there is at least one constant in the labelbase
      MOVEA.l labelbase,A2
     'loop
        CMPA.w #$0,A2 : BEQ.w 'err

        CMPI.l #$1,4(A2) : BEQ.w 'skip   
        MOVEA.l (A2),A2
      BRA.w 'loop
     'err
      MOVE.l #-3,compilelinecounter
      RTS
 'skip

  MOVE.l A1,D0 ; get filename from a0 to d0

; -- start of rewrite in basic
;  fh.l = Open_(residentfile,#MODE_NEWFILE)
;  If fh
;    !asm
;    ;MOVEM.l d2-d7/a0-a6,-(a7)
;    LEA devo,a0
;    LEA namebuffer,a1
;
;   'l1
;      MOVE.b (a0)+,(a1)+
;    BNE 'l1
;    MOVEQ #13,d2
;    JSR findlabel2
;    MOVE.l 8(a2),-(a7)
;    MOVE.l d0,-(a7)
;    !basic
;    MOVE (a7)+,d0 : putreg d0, tempd0.l
;    MOVE (a7)+,d0 : putreg d0, tempd1.l
;    If tempd0 <> 0 AND tempd1 = 0
;      !asm
;      BSR.w free_allHunkOffsets
;      !basic
;      Write_ fh,?tsthead,$20          ; write header
;
;      ; ...
;    Else
;      error{!TRANS{"Cannot create Resident with develope debug 1"}}
;    EndIf
;    Close_ fh 
;
;
;  Else
;    error{"Could not open file " + residentfile}
;  EndIf
;  !asm
;RTS

  ;--
  ;-- O.K.... Now to create the resident file 
  MOVEA.l _dosbase,A6

  MOVE.l D0,D1
  MOVE.l #MODE_NEWFILE,D2
  JSR _Open(A6)
  MOVE.l D0,D7 : BEQ.w 'err 
  
  ; new >
  MOVEM.l d2-d7/a0-a6,-(a7)
  LEA devo,a0
  LEA namebuffer,a1
 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1
  MOVEQ #13,d2 : JSR findlabel2 :  BNE 'd
    TST.l 8(a2) : BEQ 'd2
      !basic
      error{!TRANS{"Cannot create Resident with develope debug 1"}}
      !asm
      MOVEM.l (a7)+,d2-d7/a0-a6
      MOVEA.l _dosbase,A6
      MOVE.l d7,d1
      JSR _Close(a6)
      BRA 'err
  'd2
 'd
  MOVEM.l (a7)+,d2-d7/a0-a6
  ; < new
  ;
  BSR.w free_allHunkOffsets
  ;
  MOVE.l D7,D1             ;write hunk header
  MOVE.l #tsthead,D2        
  MOVEQ.l #32,D3
  MOVEA.l _dosbase,A6
  JSR _Write(A6)
  ;
  MOVEQ.l #$00,D6           ;offset from start of file!                               ;offset from start of file!
  BSR.w resident_Types
  BSR.w resident_Macros
  BSR.w resident_Constants
  ;
  MOVE.l D6,D3
  ADDQ.l #3,D3
  ANDI.l #$FFFFFFFC,D3      ;long word align                               ;long word align
  MOVE.l D3,-(A7)
  SUB.l D6,D3 : BEQ.w 'noalign
    MOVE.l #writelist,D2      ; was #hello,
    MOVE.l D7,D1
    MOVEA.l _dosbase,A6
    JSR _Write(A6)
 'noalign

  ;.. write RELOC32 data hunk
  MOVE.l hunkoffsetcounter,tstsize3 : BEQ.w 'skip2a
    MOVE.l D7,D1
    MOVE.l #tstend,D2
    MOVEQ.l #$0C,D3
    MOVEA.l _dosbase,A6
    JSR _Write(A6)
    ;
    ;and offsets.....
    ;
    MOVEA.l hunkoffsetbase,A2
   'oloop
    CMPA.w #$0,A2 : BEQ.w 'skip2
      LEA 4(A2),A1
      MOVE.l D7,D1
      MOVE.l A1,D2
      MOVEQ.l #$04,D3
      MOVEA.l _dosbase,A6
      JSR _Write(A6)
      MOVEA.l (A2),A2
    BRA.w 'oloop
   'skip2

    MOVE.l D7,D1
    MOVE.l #zero,D2
    MOVEQ.l #$04,D3
    MOVEA.l _dosbase,A6
    JSR _Write(A6)
 'skip2a

  MOVE.l D7,D1
  MOVE.l #tstdone,D2      ; HUNK_END
  MOVEQ.l #$04,D3
  MOVEA.l _dosbase,A6
  JSR _Write(A6)

  MOVE.l (A7)+,D0
  LSR.l #2,D0
  MOVE.l D0,temp1         ; calc hunk size in longwords
  
  MOVE.l D7,D1
  MOVEQ.l #20,D2
  MOVEQ.l #-$01,D3
  JSR _Seek(A6)           ; seek position for hunk size

  MOVE.l D7,D1
  MOVE.l #temp1,D2
  MOVEQ.l #$04,D3
  JSR _Write(A6)          ; write size of first hunk

  MOVE.l D7,D1
  MOVEQ.l #28,D2
  MOVEQ.l #-$01,D3
  JSR _Seek(A6)

  MOVE.l D7,D1
  MOVE.l #temp1,D2        ; write size of reloc hunk (the same as above)
  MOVEQ.l #$04,D3
  JSR _Write(A6)
  ;
  MOVE.l D7,D1
  JSR _Close(A6)
RTS


writelist:                                                 ;hello   dc.b    'ZAP',0 org source
  ;a2=first, d5=.b len offset
  ; new >
  ADDQ.w #5,D1
  ADDQ.b #8,D0
  ; < new

 'loop
    CMPA.w #$0,A2
    BEQ.w 'done
     BSR.w writeitem
    MOVEA.l (A2),A2
 BRA.w 'loop

 'done
RTS


.writeitem:
  MOVEQ.l #$00,D3
  MOVE.b $0(A2,D5.W),D3
  ADDQ.w #1,D3
  BCLR #$0,D3                                              ;word align
  MOVE.l (A2),-(A7) : BEQ.w 'skip
    BSR.w 'resoff
    ADD.l D3,D6
    MOVE.l D6,(A2)
    SUB.l D3,D6
 'skip
  ADD.l D3,D6
  MOVE.l A2,D2
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  JSR _Write(A6)
  MOVE.l (A7)+,(A2)
RTS

'resoff
  MOVE.l D6,D2
BRA.w addhunkoffset


.writeoffs:
  ;-- write the offsets
  ;--
 'loop
    CMPA.w #$0,A2 : BEQ.w 'done

    MOVEA.l newtypebase,A1
    MOVEQ.l #$00,D1
   'loop2
      CMPA.w #$0,A1 : BEQ.w 'found
      CMPA.l $A(A2),A1 : BEQ.w 'found

      ADDQ.w #1,D1
      MOVEA.l (A1),A1
    BRA.w 'loop2
   'found

    MOVE.w $A(A2),-(A7)
    MOVE.w D1,$A(A2)
    BSR.w writeitem
    MOVE.w (A7)+,$A(A2)
    MOVEA.l (A2),A2
  BRA.w 'loop
 'done
RTS


countem:
  MOVEQ.l #$00,D0

 'loop
    CMPA.w #$0,A2 : BEQ.w 'done

    ADDQ.w #1,D0
    MOVEA.l (A2),A2
  BRA.w 'loop
 'done

  MOVE.w D0,temp1
  MOVE.l D7,D1
  MOVE.l #temp1,D2
  MOVEQ.l #$02,D3
  ADDQ.l #2,D6
  MOVEA.l _dosbase,A6
JMP _Write(A6)


resident_Macros:
  ;-- put out! macros
  ;
  ; new >
  TST.b resdisable : BEQ 'l1
    MOVE.l currentmacroaddr,a3
    CMP.l #0,a3 : BEQ 'l1
      MOVE.l (a3),a3
      BRA 'l2
 'l1
    ; < new
    MOVEA.l macrobase,A3                                     ;??begin org code??
 'l2
  MOVEA.l A3,A2
  BSR.w countem

 'loop
    CMPA.w #$0,A3 : BEQ.w 'done

    MOVE.l D6,D5
    MOVE.l (A3),-(A7)
    MOVE.l $4(A3),-(A7)
    MOVEQ.l #$00,D3
    MOVE.b $C(A3),D3
    ADDQ.w #1,D3
    BCLR #$0,D3
    ADD.l D3,D6                                              ;add len of struct
    TST.w $8(A3) : BEQ.w 'notext
      MOVE.l D6,$4(A3)
      MOVE.l D5,D2
      ADDQ.l #4,D2
      BSR.w addhunkoffset
   'notext
    MOVEQ.l #$00,D4
    MOVE.w $8(A3),D4
    ADDQ.w #1,D4
    BCLR #$0,D4
    ADD.l D4,D6
    TST.l (A3) : BEQ.w 'nomore
      MOVE.l D6,(A3)
      MOVE.l D5,D2
      BSR.w addhunkoffset
   'nomore
    MOVE.l A3,D2
    MOVE.l D7,D1
    MOVEA.l _dosbase,A6
    JSR _Write(a6)
    TST.l D4 : BEQ.w 'skip
      MOVE.l (A7),D2
      MOVE.l D4,D3
      MOVE.l D7,D1
      MOVEA.l _dosbase,A6
      JSR _Write(A6)
   'skip
    MOVE.l (A7)+,$4(A3)
    MOVE.l (A7)+,(A3)
    MOVEA.l (A3),A3
  BRA.w 'loop
 'done
RTS


resident_Types:
  ; new >
  TST.b resdisable : BEQ 'l1
    MOVE.l lastrestype,a3
    CMP.l #0,a3 : BEQ 'l1
      MOVE.l (a3),a3
      BRA 'l2
   'l1
      ; < new
      MOVEA.l newtype_string,A3
 'l2
  MOVEA.l A3,A2
  BSR.w countem
 'loop
    CMPA.w #$0,A3 : BEQ.w 'done
    MOVE.l D6,-(A7)
    MOVEA.l $4(A3),A2
    MOVEQ.l #$0E,D5
    BSR.w writeoffs

    MOVE.l (A7)+,D0
    MOVE.l $4(A3),-(A7)
    MOVE.l D0,$4(A3)
    MOVE.l D6,D2
    ADDQ.l #4,D2
    BSR.w addhunkoffset
    MOVEQ.l #$00,D3
    MOVE.b $A(A3),D3
    ADDQ.w #1,D3
    BCLR #$0,D3
    ADD.l D3,D6
    MOVE.l A3,D2
    MOVE.l D7,D1
    MOVEA.l _dosbase,A6
    JSR _Write(A6)
    MOVE.l (A7)+,$4(A3)
    MOVEA.l (A3),A3
  BRA.w 'loop
 'done
RTS


resident_Constants:
  ; new >
  TST.b resdisable : BEQ 'l1
    MOVE.l currentlabeladdr,a2
    CMP.l #0,a2 : BEQ 'l1
      MOVE.l (a2),a2
      BRA 'l2
 'l1
    ; < new
    MOVEA.l labelbase,A2
 'l2
  MOVEQ.l #$00,D0

 'loop
    CMPA.w #$0,A2 : BEQ.w 'done
 
    CMPI.l #$1,4(A2) : BNE.w 'next
      ADDQ.w #1,D0
   'next
    MOVEA.l (A2),A2
  BRA.w 'loop
 'done

  MOVE.w D0,temp1
  MOVE.l D7,D1
  MOVE.l #temp1,D2
  MOVEQ.l #$02,D3
  ADDQ.l #2,D6
  MOVEA.l _dosbase,A6
  JSR _Write(A6)
  ; new>
  TST.b resdisable : BEQ 'done_l1
    MOVE.l currentlabeladdr,a2
    CMP.l #0,a2 : BEQ 'done_l1
      MOVE.l (a2),a2
      BRA 'loop2
 'done_l1
    ; < new
     MOVEA.l labelbase,A2                                    ;write resident labels
 'loop2
    CMPA.w #$0,A2 : BEQ.w 'done2

    CMPI.l #$1,4(A2) : BNE.w 'next2
    MOVEQ.l #$00,D3
    MOVE.b 18(A2),D3                                        ;length
    ADDQ.w #1,D3
    BCLR #$0,D3
    MOVE.l D6,D2
    ADD.l D3,D6
    MOVE.l (A2),-(A7)
    TST.l (A2) : BEQ.w 'nonext
      MOVE.l D6,(A2)
      BSR.w addhunkoffset
   'nonext
    MOVE.l A2,D2
    MOVE.l D7,D1
    MOVEA.l _dosbase,A6
    JSR _Write(A6)
    MOVE.l (A7)+,(A2)
   'next2
    MOVEA.l (A2),A2
  BRA.w 'loop2
 'done2
RTS

; new >
.check_residentpath:
  MOVE.l a5,-(a7)

  !basic
  resfileP.l = PeekL(?ptr_resfile)
  If resfileP
    resfile$ = Peek.s(resfileP)
    tests.b = Instr(resfile$,"/")
    testc.b = Instr(resfile$,":")
    If tests = 0 AND testc = 0
      resfile$ = dos_AddPart{config\path_residents, resfile$}
      PokeL ?ptr_resfile,&resfile$
    EndIf
    log2PED{"loading resident file: " + resfile$}
  Else
    error{"INTERNAL: Invalid pointer in ptr_resfile!"}
  End If
  !asm
  MOVE.l (a7)+,a5
RTS
; < new


.reloadresident:  ;loadres org source
  !basic
  log2PED{"reload residents ..."}
  !asm  

  ;--
  ;-- load in resident structs.....
  MOVE.l a7,stackaddr                                      ; added to prevent a crash in CLIMode if #continue_on_error is set and residents can't load  tomsmart1
  MOVE.l A7,errstack

  ; new >
  ;JSR free_unusedfunctions
  ; < new

  MOVE.l #'next,errcont
  MOVE.w #$FFFF,ezerr         ; was -1
  ;
  BSR.w Aclearallvars

  BSR.w free_Residents

  LEA residents_table,A5                                   ; this is a fixed memory area with a meta data size for 8 residents
  MOVEQ.l #$07,D6
 'loop
    TST.b (A5) : BEQ.w 'next

    MOVE.l A5,ptr_resfile

    BSR check_residentpath
    
    MOVE.l ptr_resfile,d1
    MOVEA.l _dosbase,A6
    JSR _LoadSeg(A6)
    MOVE.l D0,$40(A5) : BNE.w 'yeah
      !basic
      log2PED{"Error loading resident."}
      !asm
      BSR.w reserr
      BRA 'next
   'yeah

    ;-- res loaded O.K.
    MOVEA.l D0,A3
    ADDA.l A3,A3
    ADDA.l A3,A3
    ADDQ.w #4,A3                                           ;start of res
    ;
    BSR.w fixtypes
    BSR.w fixmacs                                        ;add macros to list
    BSR.w fixconsts                                        ;read labels
   'next
    LEA ResidentEntryStep(A5),A5
  DBF D6,'loop

  ;--
  ;-- check resident clashes!
  ;--
  MOVE.l #free_Residents,errcont

  MOVEA.l newtype_string,A3
  MOVEQ.l #$0B,D7
  BSR.w checkclash

  MOVEA.l macrobase,A3
  MOVEQ.l #$d,D7
  BSR.w checkclash

  MOVEA.l firstconst,A3
  MOVEQ.l #$19,D7
  BSR.w checkclash

  !basic
  log2PED{"done ..."}
  !asm  

 ;'skipresload                                             ;??looks like label not used??
RTS


.checkclash:
  MOVEA.l A3,A4

 'loop
    CMPA.w #$0,A4 : BEQ.w 'done

    LEA namebuffer,A0
    LEA $0(A4,D7.W),A1
    MOVEQ.l #-$01,D2

   'loop2
      ADDQ.w #1,D2
      MOVE.b (A1)+,(A0)+
    BNE.w 'loop2
  
    MOVEA.l A3,A2
   'more
      BSR.w findlab : BNE.w 'next                                  ;not found

      CMPA.l A2,A4 : BEQ.w 'l1
        MOVE.l a1,a5
        BRA clasherr      ; was bne
     'l1
    BRA.w 'more
   'next
    MOVEA.l (A4),A4
  BRA.w 'loop
 'done
RTS


.free_Residents:
  LEA newtype_string,A0           ; remove all newtypes from list except build in ones
  MOVE.l A0,lastrestype
  CLR.l (A0)

  LEA macrobase,A0
  MOVE.l A0,currentmacroaddr
  CLR.l (A0)

  LEA labelbase,A0
  MOVE.l A0,currentlabeladdr
  CLR.l (A0)
  CLR.w rescnt

  MOVEA.l _dosbase,A6
  LEA residents_table,A2
  MOVEQ.l #$07,D2
 'loop
    MOVE.l $40(A2),D1 : BEQ.w 'next
      CLR.l $40(A2)
      JSR _UnLoadSeg(A6)
   'next
    LEA ResidentEntryStep(A2),A2
  DBF D2,'loop
RTS


fixconsts
  MOVE.w (A3)+,D1 : BEQ.w 'done

  MOVEA.l currentlabeladdr,A2
  MOVE.l A3,(A2)
  SUBQ.w #1,D1

 'loop
    MOVEA.l A3,A2
    MOVEA.l (A3),A3
  DBF D1,'loop

  ; new >
  CLR.l (a2)                                               ;bugfix for object
  ; < new
  MOVE.l A2,currentlabeladdr
  MOVEA.l A2,A3
  MOVEQ.l #$00,D0
  MOVE.b $12(A3),D0
  ADDQ.w #1,D0
  BCLR #$0,D0
  ADDA.w D0,A3

 'done
RTS


fixmacs
  MOVE.w (A3)+,D1 : BEQ.w 'done
  
  MOVEA.l currentmacroaddr,A2
  MOVE.l A3,(A2)
  SUBQ.w #1,D1

 'loop
    MOVEA.l A3,A2
    MOVEA.l (A3),A3
  DBF D1,'loop

  MOVE.l A2,currentmacroaddr
  MOVEA.l A2,A3
  MOVEQ.l #$00,D0
  MOVE.b $C(A3),D0
  ADDQ.w #1,D0
  BCLR #$0,D0
  MOVE.w $8(A3),D1
  ADDQ.w #1,D1
  BCLR #$0,D1
  ADDA.w D0,A3
  ADDA.w D1,A3

 'done
RTS


fixtypes
  ;-- fix up all load types
  MOVE.w (A3)+,D1 : BEQ.w 'done        ;number of types to do
  
  MOVE.w D1,-(A7)
  SUBQ.w #1,D1
  MOVEA.l lastrestype,A2
  MOVE.l A2,-(A7)
 'loop
    MOVE.l (A3),D0 : BEQ.w 'loopme     ;skip through offsets
      MOVEA.l D0,A3
      BRA.w 'loop
   'loopme
      MOVE.b $E(A3),D0
      ADDQ.w #1,D0
      BCLR #$0,D0
      ADDA.w D0,A3            ;a3=type
      MOVE.l A3,(A2)          ;link
      MOVEA.l A3,A2
      MOVEQ.l #$00,D0
      MOVE.b $A(A3),D0
      ADDQ.w #1,D0
      BCLR #$0,D0
      ADDA.w D0,A3            ;next offset
  DBF D1,'loop
  ;-- 
  ;-- Now, Fix up pointers to Stuff!
  ;--
  MOVEA.l (A7)+,A0
  MOVEA.l (A0),A0

 'floop
    CMPA.w #$0,A0 : BEQ.w 'fdone

    MOVEA.l $4(A0),A1          ;first offset!

   'floop2
      CMPA.w #$0,A1 : BEQ.w 'fofd

      MOVE.w $A(A1),D0           ;number of type
      MOVEA.l newtypebase,A4
      CMP.w #$7,D0 : BCS.w 'fsys
        SUB.w rescnt,D0
     'fsys
      SUBQ.w #1,D0 : BMI.w 'fdone2
       'floop3
          MOVEA.l (A4),A4
        DBF D0,'floop3
     'fdone2

      MOVE.l A4,$A(A1)
      MOVEA.l (A1),A1
    BRA.w 'floop2
   'fofd

    MOVEA.l (A0),A0
  BRA.w 'floop
 'fdone
  MOVE.w (A7)+,D0
  ADD.w D0,rescnt
  MOVE.l A2,lastrestype

 'done
RTS


; was runerropts at this point in org source
.make_AssemblerTable:                                 ; make a table of pointers to ASM data
                                                      ; d1: last token number of all loaded tokens
  LEA tokens,A0
  MOVE.w #$003A,D0                                    ; $003A : 58 dec
 'loop                                                ; skip 58 tokens, beginning of ASM instructions
    MOVEA.l (A0),A0
  DBF D0,'loop

  MOVEA.l #asmpnts,A1                                 ; create tokentab
  MOVE.w #$0076,D0        ; was #tnum-fnum-1,         ; $0076 : 118 dec

 'loop2
    LEA $6(A0),A2                                     ;get beginning of tokenname

   'loop3                                             ;skip tokenname
     TST.b (A2)+
    BNE.w 'loop3

   'loop4                                             ;skip token helptext
      TST.b (A2)+
    BNE.w 'loop4

    ADDQ.w #1,A2                                      ;
    EXG.l D1,A2                                       ;make sure the address is even
    BCLR #$0,D1                                       ;
    EXG.l D1,A2                                       ;

    MOVE.l A2,(A1)+                                   ;
    MOVEA.l (A0),A0
  DBF D0,'loop2
RTS


getimm:                                                    ;get an immediate value
  BSR.w asmconst
  MOVEQ.l #$0B,D5
RTS


unmove:  Ds.w 1


regmovems:                                                 ;d4=reg#
  MOVE.w #$48E7,D1
  BSR.w writeword                                          ;movem.l -(a7)
  MOVE.w #$000F,D2
  SUB.w D4,D2
  MOVEQ.l #-$01,D1
  BCLR D2,D1
  BSR.w writeword
  MOVEQ.l #-$01,D1
  BCLR D4,D1
  MOVE.w D1,unmove
RTS


dounmove:
  MOVE.w #$4CDF,D1
  BSR.w writeword
  MOVE.w unmove(PC),D1
BRA.w writeword

;-- if bit 15 of d2 then code has been generated for
;--address of thing in a2. else d3=offset from a5
;-- for simple variable.
;--
;-- d2 & ff=type. 0=struct address
;--
;-- bit 14 of d2=1 if result is a pointer
;--

.do_PutReg:
  BSR.w get_reg2
  CMP.w #",",D0 : BNE.w syntaxerr

  MOVE.l #$48E7FFFE,D1                                     ;movem.l d0-a6,-(a7)
  BSR.w writelong
  MOVE.w D4,D1
  ORI.w #$2F00,D1
  BSR.w writeword
  ;
  BSR.w get1bytemain
  JSR getparameter           ; bsr.w
  BSR.w fetchvars
  BSR.w calcvar
  BTST #$E,D2
  BEQ.w 'notp

 'issa
    MOVE.b #$3,D2
    BRA.w 'pd

 'notp
    TST.b D2
   BEQ.w 'issa
  CMP.b #$7,D2
   BEQ.w 'issa

 'pd
  BTST #$F,D2
   BNE.w 'nsimp
  MOVE.w #$45ED,D1                                         ;lea x(a5),a2
   BSR.w writeword
  MOVE.w D3,D1
   BSR.w writeword

 'nsimp
  MOVE.w #$201F,D1                                         ;move.l (a7)+,d0
   BSR.w writeword
  MOVE.w #$1480,D1
  CMP.b #$1,D2
   BEQ.w 'pg
  EORI.w #$3000,D1
  CMP.b #$2,D2
   BNE.w 'pg
  ORI.w #$1000,D1

 'pg
  BSR.w writeword
  MOVE.l #$4CDF7FFF,D1
BRA.w writelong


.do_GetReg:
  BSR.w get_reg2
  CMP.w #",",D0 : BNE.w syntaxerr

  BSR.w regmovems
  MOVE.w D4,-(A7)
  MOVEQ.l #$03,D2                ;get a long
  JSR eval                       ; BSR.w
  MOVE.w (A7)+,D1
   BEQ.w 'done
  CMP.w #$8,D1
   BCC.w 'addreg
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2000,D1
   BSR.w writeword
 BRA.w 'done

 'addreg
  SUBQ.w #8,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2040,D1
  BSR.w writeword

 'done
BRA.w dounmove


get_reg:                ; was getreg
  BSR.w get1bytemain

get_reg2:
  ORI.w #" ",D0
  CMP.w #$64,D0 : BEQ.w checkValidRegisterNum          ;'d'      Dataregister
  CMP.w #$61,D0 : BNE.w syntaxerr                      ;'a'      Addressregister
  
  BSR.w checkValidRegisterNum
  ADDQ.w #8,D4
RTS


getan:
  !fget                                                ;bsr.w get1bytemain
  ORI.w #" ",D0

getan2:
  CMP.w #$61,D0  : BNE.w syntaxerr                     ;'a'

checkValidRegisterNum:
  !fget                                                ;bsr.w get1bytemain
  SUBI.w #$30,D0 : BMI.w syntaxerr                     ; check if register number is within [0..7]
  CMP.w #$7,D0   : BHI.w syntaxerr
  MOVE.w D0,D4
  !fget                                                    ;bra.w get1bytemain
RTS


getmovem2:
  ADDQ.w #8,D4

getmovem:
  MOVEQ.l #$00,D5    ;bits for reg
  SUBI.w #$30,D4

 'loop
  CMP.w #"-",D0 : BEQ.w 'range
  CMP.w #$2F,D0 : BEQ.w 'one      ;'/'
   
 BRA.w syntaxerr

 'done2
  BSET D4,D5

 'done
  MOVE.w D5,D4
  MOVEQ.l #$0F,D5
 RTS

 'one
  BSET D4,D5
  BSR.w get_reg
  !test_for_commacolon : BNE.w 'loop
 BRA.w 'done2

 'range
  MOVE.w D4,D1    ;from
  BSR.w get_reg
  CMP.w D4,D1 : BLS.w 'loop2
  EXG.l D4,D1
 'loop2
  BSET D1,D5
  ADDQ.w #1,D1
  CMP.w D4,D1 : BLS.w 'loop2

  !test_for_commacolon : BNE.w 'loop
BRA.w 'done


.getea:
  ;--
  ;-- evaluate the ea of an asm bit
  ;--
  MOVEA.l A5,A4                                            
  !fget                                                   ;bsr.w get1bytemain
  CMP.w #"#",D0 : BEQ.w getimm
  CMP.w #"(",D0 : BEQ.w 'ind
  CMP.w #"-",D0 : BNE.w 'more

  !fget                                                   ;bsr.w get1bytemain       -(
  CMP.w #"(",D0 : BNE.w 'notccr
  BSR.w getan
  CMP.w #")",D0 : BNE.w syntaxerr
  MOVEQ.l #$04,D5
  !fget                                                    ;bsr.w get1bytemain  
RTS

 'ind
  BSR.w getan
  CMP.w #")",D0 : BNE.w syntaxerr

  !fget
  CMP.w #"+",D0 : BEQ.w 'postinc
    MOVEQ.l #$02,D5
    RTS
 'postinc

  MOVEQ.l #$03,D5
  !fget
RTS


 'more
  ORI.w #" ",D0
  MOVE.w D0,D1      ;first
  !fget
  CMP.w #"d",D1 : BNE.w 'notdn
  CMP.w #"0",D0 : BCS.w 'notan
  CMP.w #"7",D0 : BHI.w 'notan
   
  MOVE.w D0,D4
  !fget
  !test_for_commacolon : BEQ.w 'dn
  CMP.w #"-",D0 : BEQ.w getmovem
  CMP.w #"/",D0 : BEQ.w getmovem
   
  BRA.w 'notan2

 'dn
  MOVEQ.l #$00,D5
  SUBI.w #$30,D4
RTS

 'notdn
  CMP.w #"a",D1 : BNE.w 'notan
  CMP.w #"0",D0 : BCS.w 'notan
  CMP.w #"7",D0 : BHI.w 'notan
  MOVE.w D0,D4
  !fget
  !test_for_commacolon : BEQ.w 'an
  CMP.w #"-",D0 : BEQ.w getmovem2                          ;movem
  CMP.w #"/",D0 : BEQ.w getmovem2
  BRA.w 'notan2

 'an
  ;--
  ;-- An
  ;--
  MOVEQ.l #1,d5
  SUBI.w #$30,D4
  ; new >
  BRA 'l10
  ADDQ.w #8,d4                             ; ??? looks like dead code ???
  MOVEQ #0,d5                              ;   "
  BSET d4,d5                               ;   "
  MOVE.w d5,d4                             ;   "
  MOVEQ.l #$0f,D5                          ;   "             ;01

 'l10
  ; > new
RTS

 'notan
  ORI.w #" ",D0
  MOVE.w D0,D4
  !fget                                                   ;bsr.w get1bytemain ;get third

 'notan2
  ;-- d1,d4,d0=chars
  !test_for_commacolon : BNE.w 'notsx

  CMP.w #$73,D1 : BNE.w 'notsx       ;'s'
  CMP.w #$70,D4 : BNE.w 'notsp       ;'p'
   
  !test_for_commacolon : BNE.w 'notccr
  ;--
  ;-- Sp
  ;--
  MOVEQ.l #$07,D4
  MOVEQ.l #$01,D5
RTS

 'notsp
  CMP.w #$72,D4 : BNE.w 'notccr      ;'r'
   
  !test_for_commacolon : BNE.w 'notccr
  MOVEQ.l #$0D,D5
RTS

 'notsx
  ORI.w #" ",D0
  CMP.w #$63,D1 : BNE.w 'notccr0     ;'c'
  CMP.w #$63,D4 : BNE.w 'notccr      ;'c'
  CMP.w #$72,D0 : BNE.w 'notccr      ;'r'
   
  BSR.w get1bytemain : BEQ.w 'ccr    ;??wy not !fget
   
  CMP.w #",",D0 : BNE.w 'notccr

 'ccr
  ;--
  ;-- ccr
  ;--
  MOVEQ.l #$0C,D5
RTS

 'notccr0
  CMP.w #$75,D1 : BNE.w 'notccr      ;'u'
  CMP.w #$73,D4 : BNE.w 'notccr      ;'s'
  CMP.w #$70,D0 : BNE.w 'notccr      ;'p'
   
  BSR.w get1bytemain : BEQ.w 'usp    ;??wy not !fget
  
  CMP.w #",",D0 : BNE.w 'notccr

 'usp
  MOVEQ.l #$0E,D5
RTS

 'notccr
  ;
  ;not anything - must be a label or abs address of some kind
  ;
  MOVEA.l A4,A5
  BSR.w asmconst
  
  !test_for_commacolon : BEQ.w 'abs1
  CMP.w #".",D0 : BEQ.w 'absx
  CMP.w #"(",D0 : BNE.w syntaxerr

  BSR.w get1bytemain                                      ;??wy not !fget

  ORI.w #" ",D0
  CMP.w #$70,D0 : BNE.w 'notpcrel      ;'p'
  
  BSR.w get1bytemain                                      ;??wy not !fget
  ORI.w #" ",D0
  CMP.w #$63,D0 : BNE.w syntaxerr      ;'c'
  
  BSR.w get1bytemain                                      ;??wy not !fget
  BSR.w getrest
  ADDQ.w #4,D5
RTS

 'notpcrel
  BSR.w getan2
  BRA.w getrest

 'absx
  BSR.w get1bytemain                                     ;??wy not !fget
  ORI.w #" ",D0
  CMP.w #$77,D0 : BEQ.w 'absw          ;'w'
  
  CMP.w #$6C,D0 : BNE.w syntaxerr      ;'l'

 'abs1
  MOVEQ.l #$08,D5
RTS

 'absw
  MOVEQ.l #$07,D5
RTS


getrest:
  CMP.w #",",D0 : BNE.w 'dis

  BSR.w get1bytemain                                      ;??wy not !fget
  ORI.w #" ",D0
  MOVEQ.l #$00,D1
  CMP.w #$64,D0 : BEQ.w 'ianxi          ;'d'
  CMP.w #$61,D0 : BNE.w syntaxerr       ;'a'
   
  BSET #$F,D1

 'ianxi
  BSR.w get1bytemain                                      ;??wy not !fget
  SUBI.w #$30,D0 : BMI.w syntaxerr
  CMP.w #$7,D0   : BHI.w syntaxerr
  LSL.w #8,D0
  LSL.w #4,D0
  OR.w D0,D1
  BSR.w get1bytemain                                      ;??wy not !fget
  CMP.w #".",D0  : BNE.w 'ok2
   
  BSR.w get1bytemain                                      ;??wy not !fget
  ORI.w #" ",D0
  CMP.w #$77,D0  : BEQ.w 'ok           ;'w'
  CMP.w #$6C,D0  : BNE.w syntaxerr     ;'l'   
  BSET #$B,D1

 'ok
   BSR.w get1bytemain                                      ;??wy not !fget

 'ok2
  ; new >
  CMP.b #"*",d0 : BNE 'l1                                 ;020 * Mode
    BSR.w get1bytemain                                    ;??wy not !fget
    CMP.b #"2",d0 : BNE 'l2
      OR.w #$200,d1
      BRA 'l1b
   'l2
    CMP.b #"4",d0 : BNE 'l3
      OR.w #$400,d1
      BRA 'l1b
   'l3
    CMP.b #"8",d0 : BNE syntaxerr
    OR.w #$600,d1
   'l1b
    BSR.w get1bytemain                                 ;??wy not !fget
 'l1
  ; < new
  CMP.w #")",D0 : BNE.w syntaxerr

  MOVE.w D1,extraword
  MOVEQ.l #$06,D5
BRA.w get1bytemain                                         ;??wy not !fget

 'dis
  CMP.w #")",D0 : BNE.w errorbracketmiss                   ; was syntax error
  MOVEQ.l #$05,D5
BRA.w get1bytemain                                         ;??wy not !fget


asmconst:                                                  ;store the text of the eval into asmfirst...
    ;
    ;text till '(','.'
    ;
  MOVEA.l asmbuff,A0
  MOVE.w ininclude,D1
  OR.w inmacro,D1
  MOVE.w D1,(A0)+                                          ;flag!
  BNE.w copyconst
  MOVE.l A5,-(A7)
  BSR.w copyconst
  MOVEA.l asmbuff,A0
  CMP.w #$4,D1 : BLS.w 'leave
  TST.w lc : BNE.w 'leave

  ADDQ.w #2,A0
  MOVE.l (A7)+,(A0)+
  CLR.b (A0)
  MOVE.w #$0004,asmlen2                                    ;pointer + 0
 RTS

 'leave
  NOT.w (A0)
  ADDQ.w #4,A7
RTS


lc:  Ds.w 1


copyconst:
  CLR.w lc
  MOVEQ.l #$00,D1

 'loop
  ADDQ.w #1,D1                                            ;label name

  !fget : BEQ.w 'done
  CMP.w #$22,d0 : BNE.s 'loop_l10                         ;'"'
    NOT.w instringon
 'loop_l10

  CMP.w #":",d0 : BNE.s 'loop_l11
    TST.w instringon : BEQ 'done
 'loop_l11

  TST.w D0 : BPL.w 'notmi
  MOVE.w D0,-(A7)
  LSR.w #8,D0
  MOVE.b D0,(A0)+
  MOVE.w (A7)+,D0
  MOVE.b D0,(A0)+
  ADDQ.w #1,D1
  BRA.s 'loop

 'notmi
  TST.w instringon : BNE.w 'putbyte
  ; new >
  TST.b _dcb       : BNE 'notmi_l10
  ; < new
  CMP.w #"(",D0    : BEQ.w 'done

 'notmi_l10
  ; < new
  CMP.w #",",D0 : BEQ.w 'done
  CMP.b #"'",D0 : BNE.w 'putbyte          ; was #loclabch
   
  MOVE.w D0,lc                            ;locallabels
  MOVE.l A1,-(A7)
  LEA lastgloballabel,A1
  TST.b (A1) : BEQ.w nolocerr

 'cloop
    ADDQ.w #1,D1
    MOVE.b (A1)+,(A0)+ 
  BNE.w 'cloop

  SUBQ.w #1,D1
  SUBQ.w #1,A0
  MOVEA.l (A7)+,A1

 'putbyte
  MOVE.b D0,(A0)+
 BRA.w 'loop

 'done
  CLR.b (A0)
  MOVE.w D1,asmlen2
RTS


.assemble_it:
  ;-------------------------------------------------
  ;-- Patch some instructions to be used by own code
  CMP.l ##TokenID_BSS,d0 : BNE.s 'l12                      ; token was asm instruction TAS  
    JMP bssseg
 'l12

  CMP.l ##TokenID_Chip,d0 : BNE.s 'l13                     ; token was asm instruction MOVEP  
    JMP chipseg
 'l13
  ;-------------------------------------------------

  ADDQ.l #1,destpointer                                    ;even
  BCLR #$0,destpointer+3

  SUBI.w #$803C,D0                                         ; substract offset in tokennumber, now d0 is the number of instruction as ...
                                                           ; 0.. ABCD
                                                           ; 1.. ADD ...
  LSL.w #2,D0                                              ; tokennumber * 4

  MOVEA.l #asmpnts,A0
  MOVEA.l $0(A0,D0.W),A0                                   ; begin inline assembler: get the asm instruction from token number
  MOVE.w D0,temp1
  MOVE.l A0,-(A7)
  ;
  MOVEQ.l #$01,D1         ; 1:no size, 0:byte, 4:word/defaultsize 8:longword
  !fget                                                    ;bsr.w get1bytemain
  CMP.w #".",D0   : BNE.w 'dsize                           ; check a size extention of the asm instruction
    !fget                                                    ;bsr.w get1bytemain
    ORI.w #" ",D0
  
    CMP.w #"w",D0 : BEQ.w 'wsize    ;word
    CMP.w #"W",D0 : BEQ.w 'wsize
    CMP.w #"b",D0 : BEQ.w 'bsize    ;byte
    CMP.w #"B",D0 : BEQ.w 'bsize
    CMP.w #"l",D0 : BEQ.w 'lsize    ;long
    CMP.w #"L",D0 : BEQ.w 'lsize
    CMP.w #"s",d0 : BNE syntaxerr   ;s equals b
    BRA.w 'bsize                    ; was 'lsize org source
  
 'bsize
  MOVEQ.l #$00,D1
  MOVE.w $8(A0),D0      ; some opcode mask and allowed operand size from instruction table in D0
  BRA.w 'tstsize

 'dsize                   ; defaultsize
  MOVEQ.l #$04,D1
  BRA.w 'putsize

 'wsize
  MOVEQ.l #$04,D1
  MOVE.w $8(A0),D0
  LSR.w #4,D0
  BRA.w 'tstsize

 'lsize
  MOVEQ.l #$08,D1
  MOVE.w $8(A0),D0
  LSR.w #8,D0

 'tstsize
  ;-- check allowed operand size
  ;-- allowed sizes are coded this way: byte: $ff0, word: $f1f, long: $2ff, nosize: $fff, all sizes: $210
  ANDI.w #$F,D0                
  CMP.w #$F,D0 : BNE.w 'cl60
    ;-- patch some instruction handling to support 32bit operands
    ;-- works only if no helptext is available in the token definition !!
    CMP.l #"MULS",-6(a0) : BNE 'c20    
      MOVE.l #$4c000800,d1
      JMP do32
   'c20
    CMP.l #"MULU",-6(a0) :  BNE 'c30
      MOVE.l #$4c000000,d1
      JMP do32
   'c30
    CMP.l #"DIVS",-6(a0) :  BNE 'c40
      MOVE.l #$4c400800,d1
      JMP do32
   'c40
    CMP.l #"DIVU",-6(a0) :  BNE 'c50
      MOVE.l #$4c400000,d1
      JMP do32
   'c50
    ; < new
    BRA illsizeerr             ; in org source this was after 'c160
 'cl60
  !fget                                                    ;bsr.w get1bytemain

 'putsize
  MOVE.w D1,asmsize                                          ; asmsize = operandsize
  MOVEQ.l #-$01,D3                                           ; set all bits of D3

  BSR.w reget : BEQ.w 'done0                                 ; check further parameters of asm instruction
    MOVE.l #namebuffer,asmbuff
    ;bsr.w bakup
    ; new >
    MOVE.w oldqflag,instringon
    MOVEA.l lastsourcepos,A5
    ;< new
    
    BSR.w getea                                               ; get source ea
    MOVE.l D4,D2                                              ;to src
    MOVE.l D5,D3                                              ; size ??

    MOVE.w asmlen2,asmlen
    MOVEQ.l #-$01,D5
    MOVE.w extraword,extraword2

    CMP.w #",",D0 : BNE.w 'done0
      MOVE.l #namebuffer2,asmbuff
      BSR.w getea                                             ;dest
 'done0
  ;
  ;-- all stuff fetched!
  ;-- now to assemble it.....
  ;
  MOVEA.l (A7)+,A0              ; pointer to asm token
  ;
  ;-- O.K. - Let's assemble it!
  ;
  ;-- d1=opcode, d2=srcreg, d3=srcea, d4=destreg, d5=destea
  ;
  MOVEA.l destpointer,A1    ; pc
  ;
  MOVEA.l A1,A4
  ADDQ.w #2,A1
  MOVE.w (A0),D1            ;opcode
  TST.w D3 : BMI.w 'none              ;no src/dest ea!

  ;
  ;-- make into movea, addi etc. if possible
  ;
  MOVE.w $E(A0),D0 :  BPL.w 'noia
    BTST #$0,D0  :  BEQ.w 'noa
      CMP.w #$1,D5 :  BNE.w 'noa
        CMP.w #$E,D3 :  BEQ.w 'noia
          MOVE.w temp1,D0
          ADDQ.w #4,D0
          BRA.w 'moveon
  'noa
      BTST #$1,D0  :  BEQ.w 'noia
      CMP.w #$B,D3 :  BNE.w 'noia
      MOVE.w temp1,D0
  'moveon
      ADDQ.w #4,D0
      MOVEA.l #asmpnts,A0
      MOVEA.l $0(A0,D0.W),A0
      MOVE.w (A0),D1
 'noia

  MOVE.l #namebuffer,buff1
  MOVE.l #namebuffer2,buff2

  ;--
  ;-- check if a error checking routine is defined in the token
  ;--
  MOVE.l $A(A0),D0 : BEQ.w 'nojsr           
    MOVEA.l D0,A3
    MOVE.w asmsize,D6
    JSR (A3)                                ; call errorchecking routine
    BPL.w 'noerr
      CMP.w #-$2,D0 : BEQ.w illsizeerr
      BRA.w illeaerr
   'noerr
    BEQ.w 'nojsr
    ;
    EXG.l D2,D4
    EXG.l D3,D5
    ;
    MOVE.l extraword,D6
    SWAP D6
    MOVE.l D6,extraword
    ;
    MOVE.l #namebuffer2,buff1
    MOVE.l #namebuffer,buff2
    ;
    MOVE.w asmlen,D6
    MOVE.w asmlen2,D7
    MOVE.w D6,asmlen2
    MOVE.w D7,asmlen
 'nojsr

  MOVE.l buff1,asmbuff

  MOVE.w $E(A0),D0 : BEQ.w 'nothing
                     BMI.w 'nothing
    ; new >
    CMP.w #$7000,d1 : BNE 'skip                     ; MOVEQ#0,D0
      CMP.w #$b,d3  : BNE illeaerr
   'skip
    ; < new
    CMP.w #$1,D0  :   BNE.w 'n1to8
    CMP.w #$B,D3  :   BNE.w 'nothing

   'skipsrc
    BSR.w insasm
    MOVE.w D4,D2
    MOVE.w D5,D3
    BRA.w 'skipsrc2

   'n1to8
    CMP.w #$2,D0 :  BNE.w 'notbcc
      CMP.w #$8,D3 :  BNE.w illeaerr
      MOVEQ.l #$09,D3
      BRA.w 'nothing
   'notbcc

    CMP.w #$3,D0 :   BEQ.w 'skipsrc
    ;
   ;'notmq
    CMP.w #$4,D0 :   BEQ.w 'skipsrc
    ;
   ;'nottrap
    CMP.w #$5,D0 :   BNE.w 'notdbf
      CMP.w #$8,D5 :   BNE.w illeaerr
      OR.w D2,D1
      MOVEQ.l #$09,D5
   'notdbf

 'nothing
  MOVE.w $2(A0),D6              ; allowed source ea of instruction
  MOVE.b $6(A0),D7              ; allowed  dest reg of instruction
  MOVEM.l D4-D5,-(A7)
  MOVE.w extraword2,D4
  BSR.w doea                    ;do src
  ;
  MOVEM.l (A7)+,D2-D3
 ;'skipsrc3

  TST.w D3
 'skipsrc2
  BMI.w 'one
    MOVE.w extraword,D4
    MOVE.w $4(A0),D6
    MOVE.b $7(A0),D7
    MOVE.l buff2,asmbuff
    MOVE.w asmlen2,asmlen
    BSR.w doea
    BRA.w 'putit
 'one
    MOVE.w $4(A0),D0 : BNE.w illeaerr
    BRA.w 'putit
 'none
    MOVE.w $2(A0),D0
    OR.w $4(A0),D0 : BNE.w illeaerr
 'putit
  ;-- put in the opcode
  ;
  MOVE.w $8(A0),D0
  ANDI.w #$F000,D0
  CMP.w #-$1000,D0 : BEQ.w 'nosizep   ;was #$f000
    LSR.w #8,D0
    LSR.w #4,D0         ;shift for size
    ;
    MOVE.w $8(A0),D2
    MOVE.w asmsize,D3
    LSR.w D3,D2
    ANDI.w #$F,D2
    LSL.w D0,D2
    OR.w D2,D1          ;size into opcode
 'nosizep

  CMPA.l destbufferend,A4 : BCS.w 'oky
    MOVE.w #$FFFF,dontwrite_nomemleft     ; was -1
    BRA.w 'done
 'oky
    MOVE.w D1,(A4)
 'done
  MOVE.l A1,destpointer
RTS


asmoff:                                                 ;add an offset
  MOVE.l destpointer,-(A7)
  MOVE.l A1,destpointer
   BSR.w addoff
  MOVEA.l destpointer,A1
  MOVE.l (A7)+,destpointer
RTS

; new >
.do32
  MOVEM.l d2-d6,-(a7)
  ;-- handle source register
  JSR stripspaces
  CMP.b #"d",(a5)+ : BNE noreg      ; only dataregisters allowed
  

  MOVE.b (a5)+,d0
  CMP.b #$30,d0 : BLT noreg         ; check if in range d0-d7
  CMP.b #$37,d0 : BGT noreg

  SUB.b #$30,d0
  MOVEQ #0,d3
  MOVE.b d0,d3                                             ;reg1
  ASL.l #8,d3
  ASL.l #8,d3

  ; handle dest register
  JSR stripspaces
  CMP.b #",",(a5)+ : BNE noreg

  JSR stripspaces
  CMP.b #"d",(a5)+ : BNE noreg

  MOVE.b (a5)+,d0
  CMP.b #$30,d0 : BLT noreg

  CMP.b #$37,d0 : BGT noreg

  SUB.b #$30,d0
  MOVEQ #0,d4
  MOVE.b d0,d4                                             ;reg2
  ASL.l #8,d4
  ASL.l #4,d4
  OR.b d0,d1
  OR.l d3,d1
  OR.l d4,d1
  JSR writelong
  MOVEM.l (a7)+,d2-d6
  MOVEM.l d1/a1-a3,-(a7)
BRA exit


noreg
  MOVEM.l (a7)+,d2-d6
  LEA errtextnoreg,a0
  MOVE.l a0,-(a7)
JMP handle_compileerror
; < new


.asmfixer:                                               ;end of pass asm filler-inner
  MOVE.w dontwrite_nomemleft,D1 : BNE.w 'done

  TST.w set_make_smallestcode : BEQ.w 'go
    MOVE.w pass(PC),D1
    BEQ.w 'done
 'go

  MOVEA.l templabel,A2                                     ;insert labels in Code
  MOVE.b #1,curtemplabel
  MOVE.w #$FFFF,constmode
  CLR.w regnum

  BSR.w prepstack

 'loop
  MOVE.l A2,-(A7)
  BSR.w chkstop
  MOVEA.l (A7)+,A2
  CMPA.w #$0,A2 : BEQ.w 'done2

  CLR.b iee
  MOVE.l A2,asmbuff
  LEA $10(A2),A5
  TST.b $F(A2) :  BNE.w 'skipo
    MOVEA.l (A5),A5                                          ;pointer to real text
 'skipo

  CLR.w asmtype
  CMP.b #".",(a5) : BNE.s 'skipo_l10
    MOVE.l a2,-(a7)
    ADDQ.l #1,a5                                  ; type character in A5
    LEA newtypebase,a2
    BSR getparameter2 : BEQ.w syntaxerr
    BSR findtype : BNE.w notypeerr

    LEA 4(A2),a2
    BSR getparameter2 : BEQ.w syntaxerr
    BSR.w findvariable2 : BNE.w notypeerr

    MOVE.w 4(A2),d3                               ; datatype in d3
    EXT.l d3
    BRA 'skipo_l30b
 'skipo_l10
    CMP.b #"\",(a5) : BNE 'skipo_l20
    ADDQ.l #1,a5
    MOVE.l a2,-(a7)
    MOVE.l a5,a4
    LEA usedpath,a5
    CMP.b #"*",(a5) : BNE 'skipo_lm1
      ADDQ.l #1,a5
   'skipo_lm1
    BSR.w getparameter2 : BEQ.w syntaxerr

    LEA varbase,A2
    MOVE.b #1,newvariable
    BSR.w findvariable
    CLR.b newvariable
    CMP.l #-1,d0 : BEQ.w notypeerr

    MOVE.l a4,a5
    MOVE.l $a(a2),a2
    LEA 4(A2),a2
    BSR getparameter2 : BEQ.w syntaxerr

    BSR.w findvariable2 : BNE.w notypeerr

    MOVE.w 4(A2),D3
    EXT.l D3
 'skipo_l30b

  CMP.b #"[",-1(a5) : BNE 'skipo_l30c
    MOVEQ #0,d0
    MOVE.b (a5)+,d0
    MOVE.l d3,-(a7)
    MOVEQ #0,d3
    JSR atoi           ; get current character in d0, returns number in d3, frac10 in d5
    MOVE.l (a7)+,d1
    MOVE.l $a(a2),a2
    MOVE.w 8(a2),d0
    MULS d0,d3
    ADD.l d1,d3
 'skipo_l30c
 
  MOVE.l (a7)+,a2
  BRA 'oko

 'skipo_l20
  CMP.w #$c,8(A2)
  BEQ 'skipo_lf1

    CMP.w #$d,8(A2)
    BEQ 'skipo_lf1

 'skipo_lf2
  JSR evalconst3

 'skipo_l30
  MOVEA.l asmbuff,A2 : BEQ.w 'oko
  CMP.w #"(",D0 : BEQ.w 'oko
  CMP.w #",",D0 : BEQ.w 'oko
  BRA.w syntaxerr

 'skipo_lf1
  MOVE.b #1,iee
  BRA 'skipo_lf2

 'oko
  MOVEA.l 4(A2),A1

  MOVE.w 8(A2),D1                                         ;labelmode
  CMP.w #$5,D1 : BNE.w 'notdan

 'word
  BSR.w chkword                                           ;word

 'word2
  MOVE.w D3,(A1)
  BRA.w 'next

 'notdan
  CMP.w #$6,D1 : BNE.w 'notdanxi

 'isbyte
  BSR.w chkbyte                                           ;byte

 'isbyte2
  MOVE.b D3,$1(A1)
  BRA.w 'next

 'notdanxi
  CMP.w #$11,D1 : BEQ.w 'isbyte2                          ;byte
  CMP.w #$c,d1 :  BEQ 'single1
  CMP.w #$d,d1 :  BEQ 'double1
  CMP.w #$7,D1 :  BEQ.w 'word                             ;word
  CMP.w #$8,D1 :  BNE.w 'notabsl

 'isabsl
  MOVE.w asmtype,D1 : BEQ.w 'notpcrel                      ;long
  BSR.w asmoff

 'notpcrel
  MOVE.l D3,(A1)
  BRA.w 'next

 'single1
  fmove.s fp0,0(a1)
  BRA.w 'next

 'double1
  fmove.d fp0,0(a1)
  BRA.w 'next

 'notabsl

  CMP.w #$9,D1 : BNE.w 'notdpc
    SUB.l A1,D3                                              ;branchword
    BSR.w chkword
    MOVE.w D3,(A1)
    BRA.w 'next
 'notdpc

  CMP.w #$A,D1 : BNE.w 'imm
    SUB.l A1,D3                                              ;branchbyte
    BRA.w 'isbyte
 'imm

  CMP.w #$11,d1 : BLE 'imm_org
    MOVE.l a3,-(a7)
    LEA pluginbase,a3
    MOVE.l 8(a2),a0
    JSR (a0)                                                 ;hook
    MOVE.l (a7)+,a3
    BRA 'next
 'imm_org

  MOVE.w $A(A2),D0 : BEQ.w 'noflag
  CMP.w #$1,D0     : BEQ.w 'tocount
  CMP.w #$3,D0     : BEQ.w 'tomoveq
  CMP.w #$4,D0     : BEQ.w 'totrap

 'noflag
  CMP.w #$B,D1     : BEQ.w 'isabsl                          ;long
   
  BRA 'word2                                                ;word

 'totrap
  CMP.l #$F,D3     : BHI.w illtraperr
  OR.b D3,-(A1)
  BRA.w 'next

 'tocount
  CMP.l #$8,D3     : BHI.w illimmerr
  TST.l D3         : BEQ.w illimmerr
  ANDI.w #$7,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,-(A1)
  BRA.w 'next

 'tomoveq
  BSR.w chkbyte
  MOVE.b D3,-(A1)

 'next
  MOVEA.l (A2),A2
  BRA.w 'loop

 'done2
  CLR.w constmode

 'done
  CLR.b curtemplabel
RTS


.doea:
  ;-- d2=reg, d3=ea, d4=extraword, d5=asm type
  ;-- d6=allowable mask, d7=shift data
  ;--
  ;-- or in bits for opcode in d1
  ;--
  BTST D3,D6 : BEQ.w illeaerr

  BSR.w makemode

  CMP.w #$7,D3 : BCS.w 'skip
    MOVE.w D3,D2
    SUBQ.w #7,D2
    CMP.w #$5,D2 : BCS.w 'skip0
      MOVEQ.l #$04,D2
   'skip0
    MOVEQ.l #$07,D3
 'skip

  MOVE.b D7,D0
  ANDI.w #$F,D0
  CMP.w #$F,D0 : BEQ.w 'skip2
    LSL.w D0,D3
    OR.w D3,D1
 'skip2

  LSR.w #4,D7
  ANDI.w #$F,D7
  CMP.w #$F,D7 : BEQ.w 'skip3
    LSL.w D7,D2
    OR.w D2,D1
 'skip3
RTS


chkbyte:
  CMP.l #$7F,D3 : BGT.w illdiserr
  CMP.l #$FFFFFF80,D3 : BLT.w illdiserr                    ;#-128,d3 org source
   
RTS


chkword:
  CMP.l #$7fff,D3 : BGT.w illdiserr
  CMP.l #$FFFF8000,D3 : BLT.w illdiserr                    ;#-32768,d3 org source
RTS


findchar                                                   ;??Looks like double label??
 'll20
    MOVE.b (a5)+,d0
    CMP.b d1,d0 : BEQ 'll10
      TST.b d0
  BNE 'll20
 'll10
  SUBQ #1,a5
RTS


findnext                                                   ;??looks like double label??
 'll20
    MOVE.b (a5)+,d0
    CMP.b #",",d0 : BEQ 'll10
    CMP.b #";",d0 :  BEQ 'll10
    CMP.b #":",d0 :  BEQ 'll10
    ;CMP.b #"(",d0 : BEQ 'll10
  TST.b d0 : BNE 'll20
 'll10

  SUBQ #1,a5
RTS


macroexecute
  ADD.l a2,d1
  LEA tempspace,a1
  MOVE.l d1,a0

 'l10
    MOVE.b (a0)+,(a1)+
  BNE.s 'l10
  SUBQ.l #1,a0
  SUBQ.l #1,a1

 'l20
    MOVE.b (a5)+,(a1)+
  BNE.s 'l20
  CLR.b (a1)
  LEA tempspace,a5
RTS


.calc:
  MOVEM.l D1-D2/A0,-(A7)
  MOVE.l d0,d2
  MOVEQ #0,d1
  MOVE.l a5,a4

 'll20
  ADDQ.l #1,d1
  MOVE.b (a5)+,d0
  CMP.b #",",d0 :  BEQ 'll10
  CMP.b #";",d0 :  BEQ 'll10
  CMP.b #":",d0 :  BEQ 'll10
  CMP.b #"(",d0 :  BEQ 'll10
  TST.b d0      :  BNE 'll20

 'll10
  SUBQ #1,a5
  CMP.b #"'",(a4) : BEQ 'llocal

  TST.w inmacro   : BNE 'lmacro

  MOVEQ.l #$14+4,D0
  ADD.l d1,d0

  MOVE.l d1,-(a7)
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0 :  JSR _AllocPooled(a6)
  MOVE.l (a7)+,d1
  TST.l d0 : BEQ out_of_memory
  MOVEA.l D0,A0

  ;MOVE.w linenumat+2,$C(A0)
  MOVE.w linenumat+2,$A(A0)
  ;MOVE.w linenumat,$c(a0)
  MOVE.l templabel,(A0)
  MOVE.l A0,templabel
  MOVE.l destpointer,$4(A0)
  MOVE.l d2,$8(A0)
  LEA $E(A0),A0
  MOVE.b #$14,(A0)+
  CLR.b (a0)+
  ;MOVE.l A4,(A0)+
  MOVE.l a0,d2
  ADDQ.l #4,d2
  MOVE.l d2,(a0)+

 'lc1
  MOVE.b (a4)+,(a0)+
  SUBQ.l #1,d1
  BNE 'lc1
  CLR.b (a0)+
  MOVE.w linenumat,(a0)
  MOVEM.l (A7)+,D1-D2/A0
 RTS

 'lmacro
  MOVEQ.l #$10+2,D0
  ADD.l d1,d0
  MOVEM.l a4/d3,-(a7)
  MOVE.l d1,d3
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0 : JSR _AllocPooled(a6)
  TST.l d0 : BEQ out_of_memory
  MOVEA.l D0,A0

 'o2
  MOVE.w linenumat+2,$C(A0)
  MOVE.l templabel,(A0)
  MOVE.l A0,templabel
  MOVE.l destpointer,$4(A0)
  MOVE.l d2,$8(A0)
  LEA $E(A0),A0
  MOVE.b d3,(A0)+
  ADD.b #$10,-1(a0)
  MOVE.b #$1,(a0)+
  SUBQ.w #1,d3

 'lm2
  MOVE.b (a4)+,(a0)+
  SUBQ.l #1,d3
  BNE.s 'lm2
  CLR.b (a0)+
  MOVE.w linenumat,(a0)
  MOVEM.l (a7)+,d3/a4
  MOVEM.l (A7)+,D1-D2/A0
 RTS

 'llocal
  LEA lastgloballabel,a1

 'll11
    ADDQ.l #1,d1
  TST.b (a1)+ : BNE.s 'll11
  MOVEQ.l #$10+2,D0
  ADD.l d1,d0
  MOVEM.l a4/d3,-(a7)
  MOVE.l d1,d3

  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0 : JSR _AllocPooled(a6)
  TST.l d0 : BEQ out_of_memory
  MOVEA.l D0,A0

 'o3
  MOVE.w linenumat+2,$C(A0)
  MOVE.l templabel,(A0)
  MOVE.l A0,templabel
  MOVE.l destpointer,$4(A0)
  MOVE.l d2,$8(A0)
  LEA $E(A0),A0
  MOVE.b d3,(A0)+
  ADD.b #$10,-1(a0)
  MOVE.b #$1,(a0)+
  SUBQ.w #1,d3
  LEA lastgloballabel,a1

 'lm3
  SUBQ.l #1,d3
  MOVE.b (a1)+,(a0)+
  BNE.s 'lm3
  SUBQ.l #1,a0

 'lm1
  MOVE.b (a4)+,(a0)+
  SUBQ.l #1,d3
  BNE.s 'lm1
  CLR.b (a0)+
  MOVE.w linenumat,(a0)
  MOVEM.l (a7)+,d3/a4
  MOVEM.l (A7)+,D1-D2/A0
RTS


.out_of_memory
  !basic
  error{!TRANS{"No memory available!!!\\nAB3 will terminate due to low memory!"}}
  loop Delay_ 1
Goto loop


insasm:                                                    ;ass asmbuff, asmlen, pc, ea to list
  MOVEM.l D0-D2/A0,-(A7)
  MOVE.w $E(A0),-(A7) : BPL.w 'ok
    CLR.w (A7)
 'ok
  MOVE.l A1,-(A7)
  MOVEQ.l #$10+2,D0
  ADD.w asmlen,D0
  MOVE.w D0,D2
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0 : JSR _AllocPooled(a6)
  MOVEA.l D0,A0

  MOVE.w linenumat+2,$C(A0)
  MOVE.l templabel,(A0)
  MOVE.l A0,templabel
  MOVE.l (A7),$4(A0)
  MOVE.w d3,$8(A0)
  MOVE.w $4(A7),$A(A0)
  LEA $E(A0),A0
  MOVE.b D2,(A0)+                                           ;length
  MOVEA.l asmbuff,A1
  ADDQ.w #1,A1
  MOVE.b (A1)+,(A0)+ : BNE.w 'loop                          ;type - 0 = indirect,else direct
    MOVE.l (A1)+,(A0)+
    MOVE.w linenumat,(a0)
    BRA.w 'loopdone
 'loop
    MOVE.b (A1)+,(A0)+
    BNE.w 'loop
    MOVE.w linenumat,(a0)
 'loopdone
  MOVEA.l (A7)+,A1
  ADDQ.w #2,A7
  MOVEM.l (A7)+,D0-D2/A0
RTS


.makemode:   ;d3: ea
  CMP.w #$5,D3:   BCS.w 'done
  CMP.w #$B,D3:   BHI.w 'done2
                  BEQ.w 'imm
  BSR.w insasm
  CMP.w #$5,D3:   BEQ.w 'word
  CMP.w #$6,D3:   BEQ.w 'dxi
  CMP.w #$7,D3:   BEQ.w 'word
  CMP.w #$8,D3:   BEQ.w 'long
  CMP.w #$9,D3:   BEQ.w 'word

 'dxi ;   d(pc,xi)
  CMPA.l destbufferend,A1 : BCS.w 'ok7
    ADDQ.w #2,A1
    RTS
 'ok7
    MOVE.w D4,(A1)+
    RTS

 'imm
  CMPI.w #$8,asmsize : BCC.w 'immlong
    MOVEQ.l #$10,D3
    BSR.w insasm
    MOVEQ.l #$0B,D3
    BRA.w 'word
 'immlong
  BSR.w insasm

 'long
  ADDQ.w #2,A1

 'word
  ADDQ.w #2,A1
  RTS

 'done2
  CMP.w #$F,D3 : BNE.w 'done
    CMPA.l destbufferend,A1 : BCS.w 'ok3
      ADDQ.w #2,A1
      ADDQ.w #4,A7
      RTS
   'ok3
      MOVE.w D2,(A1)+
      ADDQ.w #4,A7
 'done
RTS


countpees:
  ;-- count up how many parameters are following
  ;-- nest a-la {,(,},)
  ;--
  ;-- return how many parameters in d1
  ;--
  BSR.w storeloc
  ; new >
  MOVE.l linenumat,oldline
  ; < new
  MOVEQ.l #$00,D1
  BSR.w get1bytemain : BEQ.w 'done                        ;eol

  MOVEQ.l #$00,D3
  BRA.w 'skiphelp

 'loop
   BSR.w get1bytemain : BNE.w 'skip
  ; new >
 'ready
  ; < new
  TST.w D3 : BNE.w brackets_                              ;syntax error brackets
  BRA.w 'done2

 'skip
   MOVE.w instringon,D4
   ;BNE.w 'loop
  ; new >
    BEQ 'skiphelp

 'l1
    MOVEQ #0,d0
    MOVE.b (a5)+,d0                                       ;fix "ue"
    MOVE.w d0,lastchar : BEQ 'ready
 
  CMP.b #$22,d0 : BNE 'l1                                 ;'"'
  NOT.w instringon
  BRA 'loop
  ; < new

 'skiphelp
  ; new >
           CMP.b #"@",d0   : BNE 'l10                     ;expand line @@ 1. for parameter
           CMP.b #"@",(a5) : BNE 'l10

 'l111
           TST.w ininclude : BNE 'inc
           MOVE.l sourceline3,a5
           CMP.l #0,a5     : BNE 'l11t
             MOVEA.l sourceline,A5
          'l11t
           MOVEA.l (A5),A5
           CMP.l #0,a5     : BEQ 'done2
           MOVE.l a5,sourceline3
           LEA $9(A5),A5
           BRA 'l11
 'inc
           ADDQ.l #1,a5
           TST.b (a5)      : BNE 'inc
           ;BEQ illeolerr

 'l11
           ADDQ.l #1,a5
           TST.b (a5)      : BEQ illeolerr
           MOVE.l a5,-(a7)
 'l110
      CMP.b #" ",(a5)+ : BEQ 'l110
      CMP.b #";",-1(a5)
      MOVE.l (a7)+,a5
      BEQ 'l111
  BRA 'loop

 'l10
  ; < new
  CMP.w #")",D0 : BNE.w 'skip2
  TST.w D3 : BEQ.w 'done2

 'skip3
  SUBQ.w #1,D3
 BRA.w 'loop

 'skip2
   CMP.w #"}",D0 : BEQ.w 'skip3
   CMP.w #"(",D0 : BNE.w 'skip4a
 'skip4
   ADDQ.w #1,D3
 BRA.w 'loop

 'skip4a
   CMP.w #"{",D0 : BEQ.w 'skip4
   CMP.w #",",D0 : BNE.w 'loop
   TST.w D3 : BNE.w 'loop
   ADDQ.w #1,D1
 BRA.w 'loop

 'done2
  ADDQ.w #1,D1

 'done
  ; new >
  CLR.l sourceline3
  MOVE.l oldline,linenumat
  ; < new
BRA.w resloc


fetchlibps:                                 ;blitzlib parameter compile get parameter here (can recursive call )
  ;-- fetch library parameters....
  ;--
  ;-- d1 = number. lo byte = # parameters
  ;-- hi byte and 7= number of repeatables
  ;-- (eg:- Line 0,0,319,0,319,199,0,199,0,0 ,3)
  ;-- hi byte and $78 lsr 3 = pos of first repeat
  ;--
  ;-- a2 = start of types table.....
  ;--
  CLR.w numreps
  MOVE.w D1,D0
  ANDI.w #$FF00,D0 : BEQ.w 'noreps
  LSR.w #8,D0
  LSR.w #4,D0           ;d0= start of reps
  BEQ.w 'skip
  SUB.b D0,D1           ;new number to fetch
  ; new >
   MOVE.w regnum,regnumfunc
   MOVE.b funcparloop,-(a7)
   MOVE.b #0,funcparloop
   MOVE.l leftsidetype,-(a7)
   MOVE.l rightsidetype,-(a7)
   MOVE.w leftsideflagmask,-(a7)
   MOVE.w rightsideflagmask,-(a7)
   CLR.l leftsidetype
   CLR.l rightsidetype
   CLR.w leftsideflagmask
   CLR.w rightsideflagmask
   MOVE.b blitzparloop,-(a7)
   MOVE.b #1,blitzparloop
  ; < new
   BSR.w fetchpees2      ;fetch first parms
  ; new >
   MOVE.b (a7)+,blitzparloop
   MOVE.w (a7)+,rightsideflagmask
   MOVE.w (a7)+,leftsideflagmask
   MOVE.l (a7)+,rightsidetype
   MOVE.l (a7)+,leftsidetype
   MOVE.b (a7)+,funcparloop
  ; < new
  CMP.w #",",D0 : BNE.w syntaxerr
   

 'skip
  ;O.K., now to fetch repeats.....
  ;
  MOVE.w D1,D2
  LSR.w #8,D2
  ANDI.w #$7,D2         ;# repeatable....

 'rloop                                               ;blitzlib parameter compile loop (can call recursive)
   CMP.b D2,D1
   BCS.w 'repsdone      ;all reps done....
  SUB.b D2,D1
  MOVEM.l D2/A2,-(A7)
  MOVE.w D2,D0
  ; new >
  MOVE.b funcparloop,-(a7)
  MOVE.b #0,funcparloop
  MOVE.l leftsidetype,-(a7)
  MOVE.l rightsidetype,-(a7)
  MOVE.w leftsideflagmask,-(a7)
  MOVE.w rightsideflagmask,-(a7)
  CLR.l leftsidetype
  CLR.l rightsidetype
  CLR.w leftsideflagmask
  CLR.w rightsideflagmask
  MOVE.b blitzparloop,-(a7)
  MOVE.b #1,blitzparloop
  ; < new
  BSR.w fetchpees4
  ; new >
  MOVE.b (a7)+,blitzparloop
  MOVE.w (a7)+,rightsideflagmask
  MOVE.w (a7)+,leftsideflagmask
  MOVE.l (a7)+,rightsidetype
  MOVE.l (a7)+,leftsidetype
  MOVE.b (a7)+,funcparloop
  ; < new
  MOVEM.l (A7)+,D2/A2
  ADDQ.w #1,numreps
 BRA.w 'rloop

 'repsdone
   MOVE.w numreps,D3
   BEQ.w syntaxerr
  ADDA.w D2,A2
  ANDI.w #$FF,D1
   BEQ.w 'done
;  ;
;  ;handle 'else' for repeating parameters...
;  ;
;  cmp #$8000+34,d0
;  beq 'done
;  ;
  CMP.w #",",D0 : BNE.w syntaxerr

 'noreps
   MOVE.w D1,D0
   BNE.w 'fetchpees2b

 'done
 RTS

  ; new >
 'fetchpees2b                           ;blitzlib parameter compile  ( var = blitzfunc) call this to get Parameter (can call recursive)
  MOVE.b funcparloop,-(a7)
  MOVE.l leftsidetype,-(a7)
  MOVE.l rightsidetype,-(a7)
  MOVE.w leftsideflagmask,-(a7)
  MOVE.w rightsideflagmask,-(a7)

  CLR.l leftsidetype
  CLR.l rightsidetype
  CLR.w leftsideflagmask
  CLR.w rightsideflagmask
  MOVE.b #0,funcparloop
  MOVE.b blitzparloop,-(a7)
  MOVE.b #1,blitzparloop
  BSR.w fetchpees2

  MOVE.b (a7)+,blitzparloop
  MOVE.w (a7)+,rightsideflagmask
  MOVE.w (a7)+,leftsideflagmask
  MOVE.l (a7)+,rightsidetype
  MOVE.l (a7)+,leftsidetype
  MOVE.b (a7)+,funcparloop
RTS
  ; < new

;------                                                  ;disassembled code begin
ptype:    Dc.b $3F,$3C,$00,$00                             ;MOVE.W  #$0000,-(A7)
;------                                                  ;disassembled code end

partostack:  Ds.w 1                                        ;pmode org source

Even
fetchpees4:                                                ;always push
  MOVEQ.l #$01,D2
BRA.w fetchpees3

fetchpees2:                                               ;dont push unless told.
  MOVEQ.l #$00,D2

fetchpees3:
  ANDI.w #$F,D0

;fetchpees:
  ;-- fetch a list of parameters.
  ;
  ;-- D0 = number to fetch,
  ;-- A2 = Pointer To Type Buffer
  ;-- D1 = push mode
  ;
  CLR.w parnum
  MOVE.w D1,-(A7)
  MOVE.w partostack(PC),-(A7)                              ;in case of recursion
  MOVE.w D2,partostack
  MOVE.w D0,-(A7)
  CMP.w #"@@",(a5) : BNE 'loop
    
    TST.w ininclude : BNE errorjoin                        ;merge macrolines
    
    MOVEA.l sourceline,A5
    MOVEA.l (A5),A5
    MOVE.l a5,sourceline
    LEA $9(A5),A5
    ADDQ.l #1,linenumat
 'loop

  MOVE.b (A2)+,D2 : BNE.w 'skip0                           ;parameterloop   d2=vartype
    MOVE.w userp,D2                                        ;user selected type
 'skip0

  MOVE.l A2,-(A7)
  ADDQ.w #1,parnum
  TST.b funccall :  BEQ 'skip0_l1
  CMP.w #6,parnum : BLE 'skip0_l1
  CMP.w #7,d2

  CNIF #more6string=0
    BEQ more6par
  CEND

 'skip0_l1
  TST.b optimize_fpu :  BEQ 'skip0_old
  TST.w regnumfunc : BEQ 'skip0_old
  CMP.w #$48e7,-4(a4) : BNE 'skip0_old
  MOVEQ #0,d1
  MOVE.w regnum,d1
  CMP regnumfunc,d1 :   BGE 'skip0_old                   ;fpu reg function save

    ASL.w #7,d1
    MOVE.l d0,-(a7)
    MOVE.w regnumfunc,d0
    CLR.w regmask

   'skip0_loop
      BSET d0,regmask : SUBQ #1,d0 
    BNE 'skip0_loop

    MOVEQ #0,d0
   'skip0_loop2
      BTST d0,regmask :  BEQ 'skip0_noa7
        MOVEQ #0,d1
        MOVE.w d0,d1
        SUBQ.w #1,d1
        ASL #7,d1
        OR.l #$f2277400,d1                                   ;fmove.d
       ;OR.l #$f2276400,d1                                   ;fmove.s
        BSR writelong
        ADDQ.l #2,stacktrack
        MOVE.l stacktrack,d1
        CMP.l #180,d1 :  BGT conmemerr                       ;formula too complex

        MOVE.l a0,-(a7)
        LEA fpustackbase,a0
        MOVE.w regmask,0(a0,d1)
        MOVE.l (a7)+,a0
   'skip0_noa7

    ADDQ.w #1,d0
    CMP.w regnumfunc,d0 : BLE 'skip0_loop2

  'skip0_ready
    MOVE.l (a7)+,d0

 'skip0_old
  MOVE.l currentfunccall,-(a7)
  MOVE.w parnum,-(a7)
  TST.l rightsidetype
  BSR.w handlep
  MOVE.w (a7)+,parnum

;  CLR.b funcparloop
  MOVE.l (a7)+,currentfunccall

  CNIF #function_typecheck
    TST.b typecheck   :  BEQ 'notypecheck                 ;typecheck for function call
    TST.b notypecheck :  BNE 'notypecheck
    TST.b blitzparloop : BNE 'isblitzlibcall              ;no typecheck for blitzlibs currently

    CMP.l #0,currentfunccall :  BEQ 'isblitzlibcall

    MOVEM.l a0/a1,-(a7)
    MOVE.l currentfunccall,a0
    MOVE.w parnum,d1

    TST.b isconstantvalue : BEQ 'noconstant
      CMP.l #0,lastconstantvalue : BEQ 'isnull
  'noconstant

    MOVE.l funcstruct_parametertype-4(a0,d1*4),a0
    CMP.l #0,a0             :  BEQ 'notype
    CMP.l #$100,4(a0)       :  BLE 'notype
    MOVE.l lasttoken,d1
    CMP.w ##TokenID_Null,d1 : BEQ 'isnull                   ;$b581 ok, when token for null
    
    TST.l typetocast :  BEQ 'nocast
      MOVE.l typetocast,a1
      BRA 'typecheck
  'nocast
      MOVE.l rightsidetype,a1
      CMP.l #0,a1 :  BEQ 'notype

  'typecheck
    CMP.l #$100,4(a1)  ;BLE 'ok                          ; deactivate if long for Parameter is not allowed
    CMP.l a0,a1 : BEQ 'ok
                                            ; check if type is parent for function call
    CMP.l #$100,4(a1) : BLE 'error          ; is a type here
    
    MOVE.l 4(a1),a1                         ; load the address of type.
    CMP.l $a(a1),a0 : BEQ 'ok               ; check if the bigger type contain in first place same type as the function need
    
  'error
    JMP error_convert_types                 ; for syntax 4

  'ok
  'notype
  'isnull
    CLR.l typetocast
    MOVEM.l (a7)+,a0/a1

  'isblitzlibcall
  'notypecheck
  CEND

  CLR.l lastfunction

  TST.b optimize_fpu
  BEQ 'skip0_noprint

  MOVE.l (a7),a2
  ADDQ.l #1,a2
  CMP.b #5,d2         :  BNE 'skip0_noprint
  CMP.b #$5d,24(a2)   :  BNE 'skip0_noprint
  CMP.b #$81,25(a2)   :  BLT 'skip0_noprint
  CMP.b #$86,25(a2)   :  BEQ 'skip0_ok
  CMP.b #$87,25(a2)   :  BEQ 'skip0_ok
  CMP.b #$88,25(a2)   :  BEQ 'skip0_ok
  CMP.b #$83,25(a2)   :  BGT 'skip0_noprint

 'skip0_ok
  MOVE.l destpointer,a4
  CMP.w #$2f00,-2(a4) :  BNE 'skip0_noprint

  SUBQ.l #2,destpointer
;  MOVE.w (a2),-(a7)                                        ;fpu print,nprint,str$
  MOVE.l #$f2277400,d1 :  BSR writelong                     ;fmove.d fp0,-(a7)
  ADDQ #4,a2offset
;  MOVE.w #$c0,(a2)
;  MOVE.l a2,-(a7)
;  JSR fetchregs
;  MOVE.l #$f2006400,d1                                     ;fmove.s fp0,d0
;  BSR writelong
;  MOVE.l #$4EAEFF94,d1                                     ;SPfieee
;  BSR writelong
;  MOVE.l (a7)+,a2
;   MOVE.w (a7)+,(a2)
  ;CMP.b #$83,25(a2)
  ;BEQ 'skip0_nomovea7
  ;MOVE.w #$2e80,d1
  ;BSR writeword
; 'skip0_nomovea7
 'skip0_noprint

  CLR.b optistring
  MOVEA.l (A7)+,A2
  CMP.w #"@",d0   : BNE 'skip0_l10
  CMP.b #"@",(a5) : BNE 'skip0_l10

  TST.w ininclude : BNE errorjoin

  MOVEA.l sourceline,A5
  MOVEA.l (A5),A5
  MOVE.l a5,sourceline
  ADDQ.l #1,linenumat
  LEA $9(A5),A5
  MOVEQ #0,d0
  BSR get1bytemain

 'skip0_l10
  CMP.b #32,(a5)+ : BEQ 'skip0_l10                        ;for space after a ,
  
  SUBQ.l #1,a5
  CMP.w #"@@",(a5) : BNE 'skip0_l15                       ;if merge
    MOVEM.l d0-d7/a0-a4/a6,-(a7)
    JSR mergeline
    MOVEM.l (a7)+,d0-d7/a0-a4/a6

    ; 'skip0_l111
    ;           MOVEA.l sourceline,A5
    ;           MOVEA.l (A5),A5
    ;           MOVE.l a5,sourceline
    ;  ADDQ.l #1,linenumat
    ;           LEA $9(A5),A5
    ;           TST.b (a5)
    ;           BEQ 'skip0_l111
    ;           MOVE.l a5,-(a7)

    ; 'skip0_l110
    ;   CMP.b #" ",(a5)+
    ;   BEQ 'skip0_l110
    ;   CMP.b #";",-1(a5)
    ;   MOVE.l (a7)+,a5
    ;   BEQ 'skip0_l111
 'skip0_l15

  SUBQ.w #1,(A7) : BEQ.w 'done
  CMP.w #",",D0                                           ; "," 
  ;BNE.w notparerr                                        ;not enough parameter
  BNE 'overloadfunc
  BRA.w 'loop

 'done
  ADDQ.w #2,A7
  MOVE.w (A7)+,partostack
  MOVE.w (A7)+,D1
  CLR.b isconstantvalue
  MOVE.l currentfunccall,lastfunction
  CLR.b funccall
  CLR.l currentfunccall
  RTS

 'overloadfunc
  CLR.b funccall
  MOVE.w regnum,d1
  MOVE.l currentfunccall,a4
  CMP.b $20(a4),d1 : BLT notparerr                      ;increase if more pars

 'ol2
  MOVE.b (a2)+,d2
  ADD.w #1,parnum

  TST.b optimize_fpu : BEQ 'nofpu
    CMP.b #5,d2 : BNE 'nofpu

      MOVEQ #0,d1 : MOVE.w regnum,d1
      CMP.w #6,regnum : BLT 'nostack2

        CNIF #more6string=0
          CMP.l #$b,parnumtemp : BGE more6par
        CEND

        MOVE.w #$2c3c,d1 :  BSR writeword

        MOVE.l #$bf800000,d1 : BSR writelong

        MOVE.w #$c4ff,d1                                      ;savetemp+regnum
        ADD.w parnum,d1
        JSR Atokejsr

        TST.w dontwrite_nomemleft : BNE 'l1

        MOVE.l data1start,d1
        MOVE.l destpointer,a4
        ADD.l d1,-4(a4)
        MOVE.l destpointer,d1
        SUBQ.l #4,d1
        SUB.l destbufferstart,d1
        MOVE.l d2,-(a7)
        MOVE.l d1,d2
        JSR addhunkoffset
        MOVE.l (a7)+,d2
        BRA 'l1
     'nostack2
        ASL.l #7,d1
        OR.l #$F23C5000,d1 : BSR writelong                    ;fmove.w #-1,fpx
        MOVEQ #-1,d1 : BSR writeword                          ;-1        
        BRA 'l1
 'nofpu
  MOVE.w regnum,d1
  CMP.w #6,regnum : BLT 'nostack

  CNIF #more6string=0
    CMP.l #$b,parnumtemp : BGE more6par
  CEND
  CMP.b #2,d2 : BGT 'nw
  BRA 'nos

 ; ADDQ #2,a2offset
 ; MOVE.l #$3f3cffff,d1
 ; BSR writelong
 ;BRA 'l1

 'nw
  ;ADDQ #4,a2offset
  CMP.w #7,d2 : BNE 'nos
  ADDQ #4,a2offset
    CNIF #more6string
      MOVE.l #$48780000,d1 : BSR writelong
      ADDQ.w #4,a2offset
      MOVE.w #$2f3c,d1 : BSR writeword
      MOVE.l #-1,d1 : BSR writelong
      BRA 'l1
    CEND
 'nos

  CMP.b #4,d2 : BNE 'noq
    MOVE.w #$2c3c,d1 : BSR writeword
    MOVE.l #$ffff0000,d1 : BSR writelong
    BRA 'noq2
 'noq

  CMP.b #5,d2 : BNE 'nof
    MOVE.w #$2c3c,d1 : BSR writeword
    MOVE.l #$800000c1,d1 : BSR writelong
    BRA 'noq2
 'nof

  MOVE.w #$7cff,d1 : BSR writeword

 'noq2
  MOVE.w #$c4ff,d1                                         ;savetemp+regnum
  ADD.w parnum,d1
  JSR Atokejsr

  TST.w dontwrite_nomemleft : BNE 'l1
  MOVE.l data1start,d1
  MOVE.l destpointer,a4
  ADD.l d1,-4(a4)
  MOVE.l destpointer,d1
  SUBQ.l #4,d1
  SUB.l destbufferstart,d1
  MOVE.l d2,-(a7)
  MOVE.l d1,d2
  JSR addhunkoffset
  MOVE.l (a7)+,d2
  BRA 'l1

 'nostack
  ASL.l #8,d1
  ASL.l #1,d1
  OR.l #$203c,d1                                           ;move.l #,d0
  BSR writeword

  MOVE.l #-1,d1
  CMP.b #4,d2 : BNE 'nq1
    MOVE.l #$ffff0000,d1
 'nq1

  CMP.b #5,d2 : BNE 'nof2
    TST.b optimize_fpu : BNE 'nof2
      MOVE.l #$800000c1,d1
 'nof2
  BSR writelong

  CMP.b #7,d2 : BNE 'l1
    CNIF #more6string
      MOVE.l #$48780000,d1
      BSR writelong
    CEND
    ADDQ.w #4,a2offset                                    ; bug fix for string parameters
    MOVE.l #$594f,d1 : BSR writeword                      ; subq #4,a7
    
 'l1
  SUBQ.w #1,(A7) : BEQ.w 'done
  ADDQ.w #1,regnum
  BRA 'ol2


handlep:
  ;d2=what to get. various flags are as follows:
  ;
  ;BIT 7 : The Address of a var - d2.b = type of var
  ;BIT 6 : We want to push any results that
  ;   would normally go into D(regat).
  ;   this should apply to all others too.
  ;
  ;BIT 5 : We want array info.
  ;
   MOVE.w D2,D1
   ANDI.w #$40,D1          ;push bit
   MOVE.b D1,partostack
   TST.b D2
    BMI.w handlevara
   BTST #$5,D2
    BNE.w handlearr
  ;
  ;normal p get
  ;
  ; new >
    MOVE.w regnumstore,-(a7)
    MOVE.w tempregnum,-(a7)
    MOVE.w parnum,-(a7)
  ; < new
    BSR.w getap                                        ;recursive entry
  ; new >
    MOVE.w (a7)+,parnum
    MOVE.w (a7)+,tempregnum
    MOVE.w (a7)+,regnumstore
  ; < new

putap:
  ;push D(regat), type in d2.
  ;
    MOVE.w partostack(PC),D1
    BEQ.w putapincreg

pushap:
   ;push D(regat), type in d2.
   ADDQ.w #4,a2offset

   MOVE.w pushdn,D1
   OR.w regnum,D1      ;push long
   CMP.w #$3,D2
    BCC.w 'skip
   SUBQ.w #2,a2offset
   ORI.w #$1000,D1    ;push word only
   BSR.w writeword
 RTS

 'skip
  ; new >
  CMP.b #7,d2 : BNE 'l10a
    CMP.b #2,optistring
    ;BEQ 'l20a                                                ;muicycle fix
 'l10a

  TST.b iee : BEQ 'olda
    CMP.b #5,d2 : BNE 'olda
 'olda
  ; < new
  BSR.w writeword                                          ;write val to stack
  RTS

  ; new >
 'l20a
  SUBQ.w #4,a2offset
RTS
  ; < new


putapincreg:
  ADDQ.w #1,regnum
RTS


putalp:
  MOVEQ.l #$03,D2
BRA.w putap


handlevara:
  ;Here, we want the address of a var type d2
  ;
  ANDI.w #$7,D2
  MOVE.w D2,-(A7)
  ;
   JSR ampersand2  ;ignore pnt to $         ;bsr.w
  ;
  CMP.b #$7,D2                                             ;ignore pnt to $
   BEQ.w 'nop2
  ;
  BTST #$E,D2
   BEQ.w 'nop
  MOVE.b #$3,D2      ;pointer to long                                      ;pointer to long
 BRA.w 'nop2

 'nop
   TST.b D2
   BNE.w 'nop2
  MOVE.b #$3,D2

 'nop2:
  MOVE.w (A7)+,D3
  TST.b D3
   BEQ.w 'unp
  CMP.b D2,D3
   BEQ.w putalp
 BRA.w mismatcherr

 'unp
  ADDQ.w #2,a2offset
  MOVE.w ptype(PC),D1
   BSR.w writeword
  MOVEQ.l #$00,D1
  MOVE.b D2,D1
   BSR.w writeword
BRA.w putalp


handlearr:
  MOVE.w D2,-(A7)
  BSR.w baseadd
  BTST #$4,$1(A7) : BEQ.w 'nohigh
    BSR.w highadd
 'nohigh

  BTST #$3,$1(A7) : BEQ.w 'notype
    BSR.w sendtype
 'notype

  MOVE.w (A7)+,D2
BRA.w get1bytemain


sendtype:
  ;--
  ;-- OK, type of array is gonna be put on stack
  ;--
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$7000,D1                           ; MOVEQ#0,D0
  
  BTST #$0,$7(A3) : BNE.w 'isap            ;A Pointer
    CMPI.l #$100,4(A2) : BCC.w arrerr1     ;illegal type to send
    
    MOVE.b $7(A2),D1
   'putit
    BSR.w writeword      ;moveq #type,d regat
    MOVEQ.l #$02,D2      ;just a word.
    BRA.w pushap

 'isap
  MOVE.b #$3,D1
BRA.w 'putit


baseadd:
  ;-- send base on stack or in reg
  ;--
  BSR.w get1bytemain                                      ;write array paramter code
  BSR.w getparameter
  BTST #$1,flagmask+1 : BEQ.w syntaxerr

  BSR.w fetchvars
  ;
  BSR.w get1bytemain
  CMP.w #")",D0 : BNE.w syntaxerr                         ;we just want a() or whatever
   
  MOVE.w notshared,D1 : BNE.w noarrayerr

  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w fbase(PC),D1
  ; new >
  TST.b varmode : BEQ 'l1
    BCLR #0,d1
 'l1
  ; < new
   BSR.w writeword
  MOVE.w $4(A3),D1
   BSR.w writeword
BRA.w putalp      ;OK, we've got da base reg.


highadd:
  ;send high end of array on stack
  ;
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w fbase(PC),D1
  ; new >
   TST.b varmode
   BEQ 'l1
   BCLR #0,d1

 'l1
  ; < new
   BSR.w writeword
  ;
  MOVE.w $8(A3),D1
  LSL.w #2,D1
  MOVE.w varmode,D2 : BEQ.w 'isglob
    NEG.w D1
 'isglob

  ADD.w $4(A3),D1
  BSR.w writeword
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ;
  MOVE.w partostack(PC),D2 : BNE.w 'dopadd           ;we just pushed last parameter!
  CMPI.w #$7,regnum : BCC.w 'dopadd                  ;last was d6, it must have been pushed too.
    OR.w pushlast(PC),D1
    MOVE.w regnum,D2
    SUBQ.w #1,D2
    OR.w D2,D1
    BRA.w 'pp
 'dopadd
    ;last one was pushed. we have to add to stack!
    ;
    OR.w pushadd(PC),D1
 'pp
  BSR.w writeword
  MOVE.b #$1,partostack
BRA.w putalp


;------                                                  ;disassembled code begin
fbase:       Dc.b $20,$2D,$00,$00                           ;MOVE.L  $0000(A5),D0
pushadd:     Dc.b $D0,$97                                   ;ADD.L (A7),D0
pushlast:    Dc.b $D0,$80                                   ;ADD.L D0,D0
;------                                                  ;disassembled code end

Even
getap:
  ANDI.w #$7,D2                                            ;0-7 (unknown to string)
   BEQ.w evalu2
BRA.w eval


resetlibs:
  MOVEA.l libpointer,A1

 'loop
    CMPA.w #$0,A1
    BEQ.w 'done
      MOVE.w #-1,$A(A1)
      BCLR #$7,$C(A1)
      MOVEA.l (A1),A1
   BRA.w 'loop
 'done
RTS


usevars:                                                  ; was uselib2 in new source renamed to org name
                                                          ; because of the org source routine label uselib2
  MOVE.w #$FFFE,D1                                        ; #varslib (was #allocvars)

.uselib:                                                  ; lib number in d1 - turn it on baby!
  BSR.w findlib


uselib3:                                                  ; a1: pointer to lib
  TST.w cfetchmode : BEQ.w 'noconst
    BTST #$6,$C(A1) : BNE.w 'constok
      BRA.w badconerr                                     ; Can't use this Library!
   'constok
    RTS
 'noconst
  
  BSET #$7,$C(A1) : BNE.w 'skip                           ; already done....
    CMPI.w #-1,$A(A1) : BNE.w 'skip                       ; something already here
      ;--
      ;-- o.k. - move in the lib!
      ;--
      TST.w direct_mode : BEQ.b 'oktouse
      ; new >
        TST.b exdebug : BEQ 'l1
          BRA.b 'oktouse
       'l1
          ; < new
          BCLR #$7,$C(A1)
          BRA.w dirliberr                                 ; not available in direct mode
     'oktouse                                             ; addlibrary

      TST.b log_blitzlibs : BEQ.b 'skiplog
        TST.w pass : BNE.b 'skiplog
          TST.l funcscanon : BNE.b 'skiplog
            !regs2stack
            MOVE.l A1,D2 ; get libpointer
            !basic
            PutReg D1,libnum2.l
            PutReg D2,libptr2.l

            If PeekW(?ininclude) > 0
              codefile.s = dos_FilePart{incdim(PeekW(?ininclude)-1)}
              codeline.l = PeekL(?includeline)
            Else
              codefile.s = ""
              codeline.l = PeekL(?linenumat)
            EndIf

            libaddr.l = PeekL(libptr2)
            libsize.l = PeekL(libaddr + $6) - PeekL(libaddr + $12)
            If PeekB(?debugmode) Then libsize + PeekL(libaddr + $2C)
            
            alllibssize + libsize
            
            GetReg D0,libnum2
            GetReg D1,&codefile
            GetReg D2,codeline
            GetReg D3,PeekL(?sourceline)
            GetReg D4,PeekL(?lastsourcepos)
            GetReg D5,libsize
            GetReg A1,0
            !ComData_JSR{comFunc_LogPrint}
            !asm
            !stack2regs
     'skiplog:

      MOVE.b debugmode,-(a7)
      MOVEM.l D1/A0/A2,-(A7)

      ; -- check debugmode
      JSR do_runerrson

      ;-- 
      ;-- is it a maximum type lib....
      ;-- if so, create a varoff for it's structs.....
      ;--
      MOVEA.l A1,A0 : ADDA.l $12(A1),A0
      TST.w -$2(A0) : BEQ.w 'notmax
        MOVEM.l A0-A1,-(A7)
        MOVE.w #$FB4F,D1 : BSR.w uselib        ; #maxslib #64335
        MOVEM.l (A7)+,A0-A1

        ADDQ.w #1,globalvarpointer
        BCLR #$0,globalvarpointer+1
        MOVE.w globalvarpointer,-$6(A0)
        ADDQ.w #4,globalvarpointer
        TST.l -$E(A0) : BEQ.w 'notmax
          ADDQ.w #4,globalvarpointer
      'notmax

      ;-- calculate start and end of code to be copied
      MOVE.l libend,$28(A1)                    ; pc of lib
      MOVEA.l A1,A0 : ADDA.l $12(A1),A0        ; start of lib
      MOVE.l A1,D1 : ADD.l $6(A1),D1           ; end of lib without error check routines

      TST.l $2C(A1) : BEQ.w 'nor               ; check if lib contains error checking code
        TST.b debugmode : BNE.w 'nor
          MOVE.l A1,D1 : ADD.l $2C(A1),D1      ; copy errchks as well!
      'nor


      ;-- copy the lib code to destination buffer
      MOVEA.l libend,A2
     'loop
        CMPA.l data1start,A2 : BCS.w 'okp
          MOVE.w #$FFFF,dontwrite_nomemleft
         'bad
            ADDQ.w #2,A0
            ADDQ.w #2,A2
          CMPA.l D1,A0 : BCS.w 'bad
          BRA.w 'toreloc
       'okp
          MOVE.w (A0)+,(A2)+ 
      CMPA.l D1,A0 : BCS.w 'loop
     'toreloc
     
      MOVE.l A2,libend

      MOVE.l $20(A1),D1 : BEQ.w 'noreloc
        MOVEM.l D0/D2-D3,-(A7)
        MOVEA.l $24(A1),A0                              ;start of reloc table
        MOVEQ.l #$00,D3                                 ;no tokejsrs (yet!)

        'reloop
          ;-- relocate library code!
          MOVE.l (A0)+,D2
          TST.l $2C(A1) : BEQ.w 'skipr                  ; error checks ?
            TST.b debugmode : BNE.w 'skipr
              CMP.l $2C(A1),D2
              BCC.w 'next
          'skipr

          TST.w $0(A1,D2.l) : BPL.w 'notajsr
            TST.l D3 : BNE.w 'notajsr                   ; already done...
              MOVE.l A0,D0
              MOVE.l D1,D3                              ; number left to do!
          'notajsr

          SUB.l $12(A1),D2 : BMI.w 'next
            ADD.l $28(A1),D2
            MOVE.l D2,-(A7)
            SUB.l destbufferstart,D2
            BSR.w addhunkoffset
            MOVEA.l (A7)+,A2

            TST.w dontwrite_nomemleft : BNE.w 'next
              MOVE.l $28(A1),D2
              SUB.l $12(A1),D2
              ADD.l D2,(A2)
          'next
          SUBQ.l #1,D1
        BNE.w 'reloop

        MOVE.l D3,D2 : BEQ.w 'nohand
          MOVEA.l D0,A2
          SUBQ.w #4,A2
          BSR.w handlejsrs
       'nohand
        MOVEM.l (A7)+,D0/D2-D3
      'noreloc

      MOVEM.l (A7)+,D1/A0/A2
      ;
      MOVEM.l D1-D2,-(A7)
      TST.w $1A(A1) : BNE.w 'skip2a
        CLR.w $A(A1)
        BRA.w 'skip2
      'skip2a
        ADDQ.w #1,globalvarpointer
        BCLR #$0,globalvarpointer+1
        MOVE.w globalvarpointer,$A(A1)
        ;
        CMP.w #-$12D,D1 : BNE.w 'nots1            ; was  #65235, strings1lib
          MOVE.w $A(A1),movestdn+2
          MOVE.w $A(A1),pusha3+2
          MOVE.w $A(A1),pusha32+2
          MOVE.w $A(A1),pulla3+2
          MOVE.w $A(A1),geta3+2
       'nots1

        CMP.w #-$3E9,D1 : BNE.w 'notd            ; was #64535, datalib
          MOVE.w $A(A1),dataget+2
          MOVE.w $A(A1),dataput+2
          MOVE.w $A(A1),rescode+6
          MOVE.w $A(A1),rescode2+2
        'notd

        ADDQ.w #2,globalvarpointer
        TST.w $1A(A1) : BMI.w 'jword
          ADDQ.w #2,globalvarpointer
       'jword

        MOVEM.l D1/A1,-(A7)
        BSR.w usevars
        MOVEM.l (A7)+,D1/A1
     'skip2
      MOVE.w D1,D2
      MOVE.l $16(A1),D1 : BSR.w uselib2  ;init?
      MOVE.l $1C(A1),D1 : BSR.w uselib2

      MOVEM.l (A7)+,D1-D2
      ;JSR clear_Cache
      MOVE.b (a7)+,debugmode
 'skip
RTS


.fixjsrs:
  ;--
  ;-- OK, we have to create code and fill in offsets
  ;-- for all tokejsrs done through the program
  MOVEQ.l #$00,D2       ;do list till this...
 'loop
    MOVEA.l tokeslist,A2
    CMPA.l D2,A2 : BEQ.w 'done

    MOVE.l A2,-(A7)       ;next till...
    'loop2                ;do this list...
      MOVEQ.l #$00,D3
      'loop3
        MOVEA.l 8(A2),A3
        CMPA.l D3,A3 : BEQ.w 'done4

        MOVE.l A3,-(A7)
        MOVEM.l D2-D3/A2-A3,-(A7)
        MOVE.w 4(A2),D1
        MOVE.w $6(A2),D2
        BSR.w tokecode
        MOVEM.l (A7)+,D2-D3/A2-A3
        ;'loop4
        MOVE.w dontwrite_nomemleft,D0 : BEQ.w 'ok
         'loop5
            MOVEA.l (A3),A3
          CMPA.l D3,A3 : BNE.w 'loop5
          BRA.w 'skipz
       'ok
          MOVEA.l $4(A3),A0
          MOVE.l D7,(A0)
          MOVEA.l (A3),A3
        CMPA.l D3,A3 : BNE.w 'ok
       'skipz
        MOVE.l (A7)+,D3
      BRA.w 'loop3
     'done4
      MOVEA.l (A2),A2
    CMPA.l D2,A2 : BNE.w 'loop2
    MOVE.l (A7)+,D2
  BRA.w 'loop
 'done
RTS


tokecode:                       ; d1=token number, d2=form number!
  ;
  ;return d7, address to jsr!
  ;
  MOVE.w D2,-(A7)
  BSR.w searchinstr             ; Return: a2.l=lib, a3.l=SUB
  MOVE.w (A7)+,D2

  ;!regs2stack
  ;!basic
  ;PutReg D1,tempwd1.w
  ;PutReg D2,tempwd2.w
  ;PutReg A2,tempwa2.l
  ;PutReg A3,tempwa3.l
  ;tokenum.w = tempwd1 - ((tempwd1 LSR 7) LSL 7)
  ;libnum.w = (tempwd1 LSR 7) AND $FFFF
  ;log2PED{"checking " + Str$(libnum) + ":" + Str$(tokenum) + " - " + Hex$(tempwd1) + "," + Str$(tempwd2) + " ... " + Hex$(PeekL(PeekL(tempwa2))) + " / " + Hex$(PeekL(PeekL(tempwa3)))}
  ;!asm
  ;!stack2regs

  BCLR #$7,blitzmode
  BCLR #$E,D2
  BEQ.w 'isamiga
    BSET #$7,blitzmode
 'isamiga

  TST.w (A3)
  BEQ.w 'simple
    BTST #$2,$1(A3) : BNE.w tokeerr
    BTST #$3,$1(A3) : BNE.w tokeerr

    ;--
    ;-- OK, it's a complex sorta token...
    ;--
    LEA $6(A3),A3     ;skip node
   'loop
      MOVE.w (A3)+,D0 : BMI.w tokeerr

      ANDI.w #$FF,D0
      ADDA.w D0,A3
      ADDQ.w #1,A3
      EXG.l D0,A3
      BCLR #$0,D0
      EXG.l D0,A3
      SUBQ.w #1,D2
      BPL.w 'loop2
        TST.w (A3)
        BNE.w 'go4it                  ; no libs to fetch....
          MOVE.l $2(A3),D0
          OR.l $A(A3),D0
          BNE.w 'go4it                ; no error chx...
            BTST #$0,$9(A3)
            BNE.w 'go4it              ; ditto...
              MOVE.l $6(A3),D7        ; sub offset
              MOVE.w $0(A2,D7.L),D0
              ANDI.w #$F000,D0
              CMP.w #-$6000,D0
              BEQ.w 'go4it
               'penis
                SUB.l 18(A2),D7
                ADD.l $28(A2),D7
                RTS
       'go4it
        LEA cutejsr,A0

       'putcode
        ;a0=route in
        MOVE.l destpointer,-(A7)
        MOVE.w #$FFFF,lasta6     ; was -1
        ;
        JSR (A0)
        MOVE.w ##opcode_RTS,D1 : BSR.w writeword
        ;
        MOVE.l (A7)+,D7
        RTS
     'loop2
       TST.w (A3)+
       BEQ.w 'skip
         ADDQ.w #2,A3
      BRA.w 'loop2
     'skip
      LEA $C(A3),A3
    BRA.w 'loop

 'simple
  TST.w D2 : BNE.w tokeerr2        ; a form is not allowed in a simple call

  TST.w $6(A3)
  BNE.w 'be4it
    MOVE.l $8(A3),D0
    OR.l $10(A3),D0
    BNE.w 'be4it
      BTST #$0,$F(A3)
      BNE.w 'be4it
        MOVE.l $C(A3),D7
        MOVE.w $0(A2,D7.L),D0
        ANDI.w #$F000,D0
        CMP.w #-$6000,D0        ; was #$a000
        BNE.w 'penis
 'be4it
  MOVE.l A3,D1
  SUB.l A2,D1
  LEA Amakelibsub,A0
BRA.w 'putcode


.free_tokeslist:
  MOVEA.l _execbase,A6
  
  MOVEA.l tokeslist,A2
  CLR.l tokeslist
 'floop
    CMPA.w #$0,A2 :  BEQ.w 'done2
    
    MOVEA.l 8(A2),A3

    'floop2
      CMPA.w #$0,A3 : BEQ.w 'done3
        MOVEA.l A3,A1
        MOVEA.l (A3),A3
        MOVEQ.l #$08,D0
        MOVE.l mempool,a0 : JSR _FreePooled(A6)
        BRA.w 'floop2
     'done3
        MOVEA.l A2,A1
        MOVEA.l (A2),A2
        MOVEQ.l #$0C,D0
        MOVE.l mempool,a0 : JSR _FreePooled(A6)
  BRA.w 'floop
 'done2
RTS


.handlejsrs:
  ;--
  ;-- a2 = first,
  ;-- d2 = how many to do.
  MOVEM.l D3-D5/A1-A6,-(A7)
  MOVEA.l A1,A4

 'loop
    MOVE.l (A2)+,D3
    MOVE.w $0(A4,D3.L),D5 : BPL.w 'next
      TST.l $2C(A4) : BEQ.w 'skipr
        TST.b debugmode : BNE.w 'skipr
          CMP.l $2C(A4),D3 : BCC.w 'next
     'skipr
        BCLR #$F,D5             ;to offset number
        MOVE.w $2(A4,D3.L),D4
        SUB.l $12(A4),D3
        ADD.l $28(A4),D3

        MOVEM.l D2/A2/A4,-(A7)
        BSR.w maketjsr
        MOVEM.l (A7)+,D2/A2/A4
   'next
    SUBQ.l #1,D2
  BNE.w 'loop
  ;
  MOVEM.l (A7)+,D3-D5/A1-A6
RTS


.maketjsr:
  ;-- add token to tokeslist in order to create correct jsr-offsets for them

  ;-- d3 = address to poke jsr into,
  ;-- d4 = token number,
  ;-- d5 = offset number
  ;-- bit 14 of d5=1 if BLITZ type.
  ;

  ;!regs2stack
  ;!basic
  ;PutReg D4,tempd4.l
  ;PutReg D5,tempd5.l
  ;If tempd5 > 0
  ;  log2PED{"... adding " + Hex$(tempd4)}
  ;EndIf
  ;!asm
  ;!stack2regs

  MOVEA.l _execbase,A6

  LEA tokeslist,A3
 'loop2
    MOVE.l (A3),D0    :  BEQ.w 'notfound
      MOVEA.l D0,A3
      CMP.w $4(A3),D4   : BNE.w 'loop2
        CMP.w $6(A3),D5 : BNE.w 'loop2
          BRA.w 'found
 'notfound
    ;-- None done yet...make one up!
    ;--
    MOVEQ.l #$0C,D0       ; 12 bytes
    MOVE.l mempool,a0 : JSR _AllocPooled(a6)
    MOVEA.l D0,A3

    MOVE.l tokeslist,(A3)
    MOVE.l A3,tokeslist
    MOVE.w D4,$4(A3)            ; tokenumber
    MOVE.w D5,$6(A3)            ; form number
    CLR.l $8(A3)                ; clear offsets
 'found


  MOVEQ.l #$08,D0               ; add offset to list
  MOVE.l mempool,a0 : JSR _AllocPooled(a6)
  MOVEA.l D0,A0

  MOVE.l D3,$4(A0)
  MOVE.l $8(A3),(A0)
  MOVE.l A0,$8(A3)
  ;
  MOVE.w D4,D1
BRA.w searchinstr               ; use this library - NOW!  return: a2.l=lib, a3.l=sub


tokeslist: Ds.l 1

;   00.l : Next
;   04.w : token number
;   06.w : form number  ;bit 14=1 if Blitz
;   08.l : list of offsets
        ;
        ;00.l : Next
        ;04.l : Offset



uselib2:
  BEQ.w 'skip
    MOVE.l A1,-(A7)
    ADDA.l D1,A1
    ADDQ.w #6,A1

   'loop
      MOVE.w (A1)+,D1 : BEQ.w 'done
      
      CMP.w D2,D1 : BEQ.w 'skip2
        MOVE.l A1,-(A7)
        BSR.w uselib
        MOVEA.l (A7)+,A1
     'skip2

      ADDQ.w #2,A1
    BRA.w 'loop
   'done
    MOVEA.l (A7)+,A1
 'skip
RTS


findlibnoerr: ;d1: libnumber, returns D1: True if found, A1: address of blitzlib
  MOVEA.l libpointer,A1

 'loop
    CMPA.w #$0,A1 : BEQ.b 'rts
    CMP.w $4(A1),D1 : BEQ.w 'found
    MOVEA.l (A1),A1
  BRA.w 'loop
 'found
  MOVEQ.l #-$01,D1
 'rts
RTS


.findlib:   ;d1: libnumber, return libpointer in a1
  MOVEM.l d0/a2,-(a7)
  
  ;-- search first in instructionTable (cache)
  MOVEQ #0,d0
  LEA instructionTable+4,a2
  MOVE.w d1,d0 : ASL.l #3,d0                 ;*8
  MOVE.l 0(a2,d0.l),a1                       
  
  CMP.l #0,a1 : BNE 'foundb
    ;-- libnum not found, so search the complete library list  
    MOVEA.l libpointer,A1
   'loop
      CMPA.w #$0,A1 :  BEQ.w noliberr

      CMP.w $4(A1),D1 : BEQ.w 'found

      MOVEA.l (A1),A1
    BRA.w 'loop
   'found 

    MOVE.l a1,0(a2,d0.l)
 'foundb

  MOVEM.l (a7)+,d0/a2
RTS


searchinstr:                  ; was  findtoke org source input: d1=token, return: a2.l=lib, a3.l=sub
  ; new >
  MOVEM.l d0-d1/a1,-(a7)
  MOVEQ #0,d0
  LEA instructionTable,a1     ; search in cache first
  MOVE.w d1,d0
  ASL.l #3,d0
  MOVE.l 0(a1,d0.l),a3
  MOVE.l 4(a1,d0.l),a2
  CMP.l #0,a3 : BNE 'foundb

  MOVEA.l libpointer,A2

 'loop
    CMPA.w #$0,A2   :  BEQ.w notokerr

    CMP.w 14(A2),D1 :  BCS.w 'next
    CMP.w $10(A2),D1:  BCC.w 'next
    ;
    ;-- lib found!
    ;
    LEA $30(A2),A3
    TST.w 4(A2) : BPL.w 'userlib
  
   'loop2
      CMP.w 14(A2),D1 : BEQ.w 'found

      SUBQ.w #1,D1
      MOVEA.l $2(A3),A3
    BRA.w 'loop2
   'found
    MOVE.l a3,0(a1,d0.l)
    MOVE.l a2,4(a1,d0.l)

   'foundb
    MOVEM.l (a7)+,d0-d1/a1
  
    ; < new
    MOVEM.l D1/A1-a3,-(A7)      ; was  movem.l d1/a1,-(a7)
    ; new >
    CMP.w #1,(a3)           : BNE.s 'ex10
    CMP.l #$12345678,$e(a3) : BNE.s 'ex10   ;call functions in fpulib !
    CMP.w #$ffff,$16(a3)    : BNE.s 'ex10
    MOVE.l $12(a3),d1       : BEQ.s 'ex10   ;third parameter in !subs is set!
      LEA pluginbase,a3
      ;move.b #1,newmode
      JMP 0(a2,d1.l)                        ;plugin
   'ex10

    MOVEA.l A2,A1
    CLR.b newmode
    MOVE.w $4(A1),D1 : BSR.w uselib3
    MOVEM.l (A7)+,D1/A1-a3
    RTS
  
    ; new >                               ;??? looks like not used ???
   'l1                                    ; "
    MOVE.w globalvarpointer,-(a7)         ; "
    MOVE.w #$8004,globalvarpointer        ; "
    BSR.w uselib3                         ; "
    MOVE.w (a7)+,globalvarpointer         ; "
    MOVEM.l (A7)+,D1/A1-a3
    RTS
    ; < new
  
   'userlib
    CMP.w 14(A2),D1
    BEQ.w 'found
      SUBQ.w #1,D1
      MOVEA.l $2(A3),A3
    BRA.w 'userlib
  
   'next
    MOVEA.l (A2),A2
  BRA.w 'loop

; new >             
exit:                ; used from do32
  MOVEM.l (A7)+,D1/A1-a3
  JSR stripspaces
  MOVEQ #0,d0
  MOVE.b (a5)+,d0
  MOVE.w d0,lastchar
  ADDQ.l #4,a7
RTS
; < new

JUMP_writeword JMP writeword

ptr_EndOfLibs.l = 0

Function.l load_biglibsfile{libfilename.s, libpointer.l, mempool.l}
SHARED ptr_EndOfLibs.l

  If libfilename <> ""
    libfilesize.l = dos_GetFileSize{libfilename}
    libfilehandle.l = Open_(&libfilename,#MODE_OLDFILE)
    If libfilehandle AND (libfilesize > 0)
      tmp_buffer.l = AllocPooled_(mempool, libfilesize)
      tmp_size.l = Read_(libfilehandle, tmp_buffer, libfilesize)
      If tmp_size > 0
;        !cout{"read ok "  + Str$(tmp_size)}
;        !cout{"libpointer: " + Hex$(libpointer)}
        ;If append_to_list
        ;  While PeekL(libpointer) <> 0
        ;    !cout{Hex$(PeekL(libpointer)) + "  "}
        ;    libpointer = PeekL(libpointer)
        ;  Wend
        ;EndIf
        ;-- process loaded libsfile
        GetReg D0,libpointer : MOVE.l d0,-(a7)
        GetReg D0,tmp_buffer : MOVE.l d0,-(a7)
        !asm
        MOVE.l (a7)+,A0     ; memory address of loaded libsfile
        MOVE.l (a7)+,A3     ; libpointer
        linkloop:
          MOVE.l (A0)+,D0                                  ; get next lib of loaded biglibs
          BEQ.w linkdone                                   ; exit if there is no next lib to parse
          ;          
          LEA $20(A0),A1  ;link in.                        ; get begin of libdata in A1
          MOVE.l A1,(A3)                                   ; set libptr as nextlib in linked list
          MOVEA.l A1,A3                                    ; set currentlib as current entry of linked list
          ADDA.l D0,A0                                     ; move to nextlib in loaded biglibs
          ;
          ;fix stuff - done by loadalib
          ;
          MOVE.l -$4(A1),D0    ;number of longwords.       ; get size of blitzlib
          ADD.l D0,D0          ;to bytes...                ;   
          ADD.l D0,D0                                      ;   
          MOVE.l D0,$6(A1)     ;fix 1                      ; write (size * 4) to 6(A1)
          CLR.l $20(A1)        ;no relocs                  ; clear.l 32(A1)
          LEA $C(A1,D0.L),A2   ;reloc info.                ; lade inhalt von (A1)+D0+$C nach A2
          CMPA.l A0,A2         ;is it over?
          BCC.w linkloop                                   ; lib needs relocation
            MOVE.l -8(A2),$20(A1)  ;number of relocs.     ;
            MOVE.l A2,$24(A1)       ;pointer to relocs.    ;
        BRA.w linkloop
        linkdone:
        MOVE.l A3,D0
        !basic
        PutReg d0,ptr_EndOfLibs
 ;       !cout{"read done at " + Hex$(ptr_EndOfLibs)}
      Else
        error{"could not read libfile " + libfilename}
      EndIf
      Close_ libfilehandle
    Else
      error{"The libsfile " + libfilename + " could not be opened."}
    EndIf
    Function Return tmp_buffer
  EndIf
End Function

.load_all_libraries:
  tempmapping$ = dos_AddPart{config\path_system,"token_mapping_userlibs.txt"}
  dos_Delete{tempmapping$}
  tokmapfid.l = file_Open{tempmapping$,#file_forcewrite}

  ;-- load baseLibs
  ;!cout{"baseLibs"}
  If config\path_baselibs <> ""
    libdata\size_baselibs = dos_GetFileSize{config\path_baselibs}
    If libdata\size_baselibs < 0
      error{"BASELIBS [" + config\path_baselibs + "] not found, none of the stored functions will be available."}
    Else
      libdata\ptr_baselibs = load_biglibsfile{config\path_baselibs,?libpointer,PeekL(?mempool)}
    EndIf
  Else
    ptr_EndOfLibs = ?libpointer
  EndIf

  ;-- load utilLibs
  ;!cout{"utilLibs"}
  If config\path_utillibs <> ""
    libdata\size_utillibs = dos_GetFileSize{config\path_utillibs}
    If libdata\size_utillibs < 0
      error{"UTILLIBS [" + config\path_utillibs + "] not found, none of the stored functions will be available."}
    Else
      tmp_mem.l = load_biglibsfile{config\path_utillibs,ptr_EndOfLibs,PeekL(?mempool)}
      libdata\ptr_utillibs = tmp_mem
    End If
  EndIf

  ;-- load oslibs
  ;!cout{"osLibs"}
  If config\path_oslibs <> ""
    libdata\size_oslibs = dos_GetFileSize{config\path_oslibs}
    If libdata\size_oslibs < 0
      error{"OSLIBS [" + config\path_oslibs + "] not found, none of the stored functions will be available."}
    Else
      tmp_mem.l = load_biglibsfile{config\path_oslibs,ptr_EndOfLibs,PeekL(?mempool)}
      libdata\ptr_oslibs = tmp_mem
    End If
  EndIf

  ;-- load cslibs
  ;!cout{"csLibs"}
  If config\path_cslibs <> ""
    libdata\size_cslibs = dos_GetFileSize{config\path_cslibs}
    If libdata\size_cslibs < 0
      error{"CSLIBS [" + config\path_cslibs + "] not found, none of the stored functions will be available."}
    Else
      tmp_mem.l = load_biglibsfile{config\path_cslibs,ptr_EndOfLibs,PeekL(?mempool)}
      libdata\ptr_cslibs = tmp_mem
    End If
  EndIf

  libdata\ptr_userlibs = ptr_EndOfLibs
  PokeL ptr_EndOfLibs,0  ; setting pointer to next lib to 0
 
.load_userlibs:
  log2PED{"scanning userlibs ..."}
  ResetList userlibslist()
  While NextItem(userlibslist())
    userlib_filename$ = dos_AddPart{config\path_userlibs,userlibslist()\libname}
    tmp_lock.l = Lock_(&userlib_filename$,#ACCESS_READ)
    If tmp_lock
      ;  DEFTYPE.FileInfoBlock fib
      If Examine_(tmp_lock,fib)
        log2PED{"loading userlib [" + userlib_filename$ + "]"}
        If dos_GetExt{Peek.s(&fib\fib_FileName)} <> "info"
          userlib_filename$ = dos_AddPart{config\path_userlibs,Peek.s(&fib\fib_FileName)}
          Gosub read_userlibsfile
        EndIf 
      EndIf
      UnLock_ tmp_lock
    EndIf
  Wend
  If tmp_userlibspointer.l <> 0 Then PokeL tmp_userlibspointer,0    ; setting pointer to next lib to 0

  ;-- close temp_mapping file opened above
  If tokmapfid <> -1
    file_Close{tokmapfid}
    tokmapfid = -1
  EndIf
  !asm
BRA.w process_libraries




; --
; -- prepare userlibs and adding to librarylist
.process_libraries:   ;was fixlibs org source
  ;-- fill in blanks in lib list
  ;--
  ;-- tokens, links etc
  ;--
  CLR.w number_of_objects
  MOVEA.l end_of_tokenlist,A3
  MOVEA.l libpointer,A2

  tokenloop:
    CMPA.w #$0,A2
    BEQ.w tokendone

      MOVE.w 4(A2),D7                                   ; <-- get tokennumber
      BMI.w 'syslib
        LSL.w #7,D7
        ADDQ.w #1,D7
        MOVE.w D7,14(A2)
     'syslib
      LEA $30(A2),A1
      LEA temp1,A4

     'loop2
        MOVE.w (A1),D0 : BMI.w 'next
        MOVE.l A1,(A4)
        MOVEA.l A1,A4      ;last link for subs
        ADDQ.w #2,A4
        ADDQ.w #6,A1
        CMP.w #$8,D0 : BEQ.w 'addtoke
          ANDI.w #$F,D0
          BNE.w 'something
            ;
            ;skip sys sub
            ;
            BSR.w skiplibreg
            LEA $C(A1),A1
            ADDQ.w #1,D7   ;in case it's a user lib
            BRA.w 'loop2
     'something

      BTST #$2,D0 : BEQ.w 'notalib
        ADDQ.w #4,A1
       'alibloop
          TST.b (A1)+
        BPL.w 'alibloop
        BSR.w aligna1
        BRA.w 'addtoke
     'notalib
       ;--process standard function or statement
       'stloop
          MOVE.w (A1)+,D0
          BMI.w 'addtoke
            ANDI.w #$FF,D0
            ADDA.w D0,A1
            BSR.w aligna1
            BSR.w skiplibreg
            LEA $C(A1),A1
        BRA.w 'stloop
     'addtoke

        MOVE.l A1,(A3)
        MOVEA.l A1,A3
        ADDQ.w #4,A1
        ;
        MOVE.w D7,(A1)+
       'tokeloop
          TST.b (A1)+
        BNE.w 'tokeloop
       'tokeloop2
          TST.b (A1)+
        BNE.w 'tokeloop2
        BSR.w aligna1
        ADDQ.w #1,D7
      BRA.w 'loop2
   'next

    TST.w 4(A2) : BMI.w 'notulib
      MOVE.w D7,$10(A2)
   'notulib
    ADDQ.w #2,A1
    TST.l (A1)+ : BEQ.w 'nomax
      ADDQ.w #1,number_of_objects
      LEA $16(A1),A1
   'nomax
    SUBA.l A2,A1
    MOVE.l A1,18(A2)
    MOVEA.l (A2),A2
  BRA.w tokenloop
  tokendone:

  CLR.l (A3)


  ; new >
  ;-- added to prevent a possible crash in CLIMode if #continue_on_error is set
  MOVE.l a7,stackaddr       
  ; < new
  MOVE.l A7,errstack
  MOVE.l #'cont,errcont
  MOVE.w #$FFFF,ezerr       ; was -1

  MOVE.w #$FFFA,D1 : BSR.w findlib          ;#65530, #memlib
  MOVE.l A1,tempvm

  MOVE.w #$FDA7,D1 : BSR.w findlib          ;#64935, #ffplib
  MOVE.l A1,ffplib

 'cont
RTS
ffplib:  Ds.l 1


.skiplibreg:
  TST.w (A1)+ : BEQ.w 'done
    ADDQ.w #2,A1
  BRA.w skiplibreg
 'done
RTS


aligna0:
  EXG.l A1,A0
  BSR.w aligna1
  EXG.l A1,A0
RTS


aligna1:
  EXG.l D0,A1
  ADDQ.l #1,D0
  BCLR #$0,D0
  EXG.l D0,A1
RTS

.free_userlibs:       ; was freeblitzlibs org source
  ; -- free all userlibs loaded
  If libdata\ptr_userlibs <> 0
    tmp_current.l = PeekL(libdata\ptr_userlibs) ; this is the begin of the first userlib
    While tmp_current <> 0
      tmp_next.l = PeekL(tmp_current)
      datachunk_size.l = PeekL(tmp_current + $20)
      If datachunk_size <> 0 Then FreePooled_ PeekL(?mempool),PeekL(tmp_current+$24),datachunk_size LSL 2
      FreePooled_ PeekL(?mempool), tmp_current, PeekL(tmp_current+$6)

      tmp_current = tmp_next
    Wend
    ClearList userlibslist()
  EndIf
Return

.free_blitzlibs:                                           ;freelibs org source    ;free up all memory used by libs
  Gosub free_userlibs
  If libdata\size_cslibs Then   FreePooled_ PeekL(?mempool),libdata\ptr_cslibs,libdata\size_cslibs
  If libdata\size_oslibs Then   FreePooled_ PeekL(?mempool),libdata\ptr_oslibs,libdata\size_oslibs
  If libdata\size_utillibs Then FreePooled_ PeekL(?mempool),libdata\ptr_utillibs,libdata\size_utillibs
  If libdata\size_baselibs Then FreePooled_ PeekL(?mempool),libdata\ptr_baselibs,libdata\size_baselibs

  PokeL ?libpointer, 0
  PokeL PeekL(?end_of_tokenlist),0
Return

.free_Macros:
  MOVEA.l _execbase,A6

  MOVEA.l currentmacroaddr,A0
  MOVEA.l (A0),A2
  CLR.l (A0)
 'loop
    CMPA.w #$0,A2 : BEQ.w 'done

    MOVEQ.l #$00,D0
    MOVE.w 8(A2),D0 : BEQ.w 'skip
      MOVEA.l 4(A2),A1
      MOVE.l mempool,a0 : JSR _FreePooled(A6)
   'skip
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$00,D0
    MOVE.b $C(A1),D0
    MOVE.l mempool2,a0 : JSR _FreePooled(A6)
  BRA.w 'loop
 'done
RTS


.cleartemplabel:                                            ;freeasms org code
  MOVEA.l templabel,A2
  CLR.l templabel
RTS

  ;--
  ;-- code not used atm, donot know why
  MOVEA.l _execbase,A6                                     ;??looks like dead code?

 'loop
    CMPA.w #$0,A2 : BEQ.w 'done

    MOVEQ.l #$00,D0
    MOVE.b 14(A2),D0                                       ;labeltemp
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    ;MOVE.l mempool2,a0 : JSR _FreePooled(A6)
  BRA.w 'loop
 'done
RTS


pokedata1b:                                               ;byte into data1
  MOVEA.l data1,A4
  CMPA.l data2at,A4 : BCC.w 'over
    MOVE.b D1,(A4)+
    MOVE.l A4,data1
    RTS
 'over
  MOVE.w #$FFFF,dontwrite_nomemleft     ; was -1                             ;move #-1, org source
  ADDQ.l #1,data1
RTS


writedatalong:                                             ;pokedata1l org source
  SWAP D1
  BSR.w pokedata1
  SWAP D1

pokedata1:                                                ;poke word in d1 into data block
  MOVEA.l data1,A4
  CMPA.l data2at,A4
   BCC.w 'over
  MOVE.w D1,(A4)+
  MOVE.l A4,data1
 RTS

 'over
  MOVE.w #$FFFF,dontwrite_nomemleft    ; was -1
  ADDQ.l #2,data1
RTS


calcstatic2b:               ;copy of calcstatic2, this is the original code
  MOVE.l data1,D3                                      ;write local string/type allocs
  MOVEQ.l #$00,D4

 'loop
    CMPA.w #$0,A2 : BEQ.w 'done
    TST.w $6(A2) : BNE.w 'next
      MOVEA.l $A(A2),A3 
      CMPI.l #$100,$4(A3) : BCS.w 'next
        MOVE.w 4(A2),D1 : BSR.w pokedata1
        MOVE.w $8(A3),D1 : BSR.w pokedata1
        ADDQ.w #1,D4
   'next
    MOVEA.l (A2),A2
  BRA.w 'loop
 'done

  TST.w D4 : BEQ.w calcstatic2b_skip
    MOVE.w #$FF37,D1 : BSR.w uselib     ;#65335, use statics lib
    MOVE.w #$FFFA,D1 : BSR.w uselib     ;#65530, use memlib
  calcstatic2b_skip:
RTS 


calcstatic:
    ;calculate static structures stuff - put num of structs d4.w
    ;address of data1 table in d3.l
    ;
    ;data1: .w=structsize,.w=offset
    ;
  MOVEA.l varbase,A2                                       ;add alloc mem for types/strings global

calcstatic2:
  MOVE.l data1,D3
  MOVEQ.l #$00,D4
  TST.b iserror : BEQ 'loop
    RTS
 'loop
    CMPA.w #$0,A2 : BEQ.w 'done
    TST.w $6(A2) : BNE.w 'next
      MOVEA.l $A(A2),A3
      CMPI.l #$100,$4(A3) : BCS.w 'next
        MOVE.w 4(A2),D1 : BSR.w pokedata1
        MOVE.w $8(A3),D1 : BSR.w pokedata1
        ADDQ.w #1,D4
   'next
    MOVEA.l (A2),A2
  BRA.w 'loop
 'done       
 ;calcstaticb:          ; copy of calcstatic
  MOVEA.l sharebase,A2  ; org  varbase

 'loopb                 ; copy of calcstatic2
    CMPA.w #$0,A2 : BEQ.w 'doneb
    TST.w $6(A2) : BNE.w 'nextb
      MOVEA.l $A(A2),A3
      CMPI.l #$100,$4(A3) : BCS.w 'nextb
      MOVE.w 4(A2),D1 : BSR.w pokedata1
      MOVE.w $8(A3),D1 : BSR.w pokedata1
      ADDQ.w #1,D4
  'nextb
    MOVEA.l (A2),A2
  BRA.w 'loopb
 'doneb

  TST.w D4 : BEQ.w calcstatic2_skip
    MOVE.w #$FF37,D1 : BSR.w uselib     ;#65335, use statics lib
    MOVE.w #$FFFA,D1 : BRA.w uselib     ;# ,use memlib
  calcstatic2_skip:
RTS


datastart:                                                 ;set up a2 (d3.l) and d4 (d4.w)
  MOVE.w numtoa2,D1
   BSR.w writeword
   BSR.w addoff
  MOVE.l D3,D1
   BSR.w writelong
  SUBQ.w #1,D4
  MOVE.w D4,endarray+2
  MOVE.l endarray,D1
BRA.w writelong


.mywrite:                 ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes
  MOVEA.l _dosbase,A6     ; if the data could not been written, an error routine will be called

  MOVE.l D3,-(A7)         ; to check if all bytes could be written
  JSR _Write(a6)          
  CMP.l (A7)+,D0 : BNE.w 'skip
    RTS
 'skip

  MOVE.l D7,D1 : JSR _Close(a6)
  execerr: 
JMP error_create_exe

.save_binaryfile:
  !regs2stack
  !basic
  log2PED{"creating executable file " + Peek.s(PeekL(?ptr_newexefilename))}
  !asm
  !stack2regs
  ;--
  ;-- make all abs refs pcat relative
  ;-- 
  ; new >
  MOVE.l a7,stackaddr                                      ; added to prevent a possible crash in CLIMode if #continue_on_error is set and the file can't create  tomsmart1
  ; < new
  MOVE.l A7,errstack
  ; new <
  MOVEM.l d2-d7/a2-a6,-(a7)
  ; < new
  MOVE.l #'rts,errcont
  ;
  MOVE.w #$FFFF,anyerrs   ; was -1
  ; new >
  CMP.l #-1,chipstart : BEQ 'l01
    MOVE.l chipend,d1
    ADDQ.l #3,d1
    AND.l #$fffffffc,d1                                      ;bug
    MOVE.l d1,chipend
    MOVE.l d1,a1
    MOVE.l chipstart,a0
    MOVE.l a1,d1
    SUB.l a0,d1
    MOVE.l d1,chipsize
 'l01

  CMP.l #-1,bssstart : BEQ 'l11
    MOVE.l realbssend,a1
    MOVE.l bssstart,a0
    MOVE.l a1,d1
    SUB.l a0,d1
    MOVE.l d1,bsssize : BEQ 'l11
     'l32
        TST.b (a0)+     : BEQ 'l31
        TST.b debugmode : BEQ 'l1
        TST.b exdebug   : BNE 'l31
       'l1
        MOVE.l #nodata,-(a7)
        JMP handle_compileerror
       'l31
      CMP.l a0,a1 : BGT 'l32

      MOVE.l bssend,d1
      ADDQ.l #3,d1
      AND.l #$fffffffc,d1                                      ;bug
      MOVE.l d1,bssend
      MOVE.l d1,a1
      MOVE.l bssstart,a0
      MOVE.l a1,d1
      SUB.l a0,d1
      MOVE.l d1,bsssize
 'l11

  MOVEM.l d5-d7/d3,-(a7)
  ; < new
  MOVE.w dontwrite_nomemleft,D1 : BNE.w 'fixdone
    ; new >
    MOVE.l chipsize,d5
    MOVE.l bsssize,d3
    MOVE.l chipstart,d7
    MOVE.l bssstart,d6
    ; < new
    MOVEA.l hunkoffsetbase,A2
    MOVEA.l destbufferstart,A1
    MOVE.l A1,D2
    ADD.l noinits,D2
    ; new >
    CLR.l hunkoffsetnum
    ; < new

   'loop0
      CMPA.w #$0,A2 : BEQ.w 'fixdone

      MOVE.l 4(A2),D0
      ; new >
      LEA $0(a1,d0.l),a0
      MOVE.l (a0),d1
      TST.l d1 : BMI.w 'lm1a
        MOVE.b #0,newhunk
        CMP.l #-1,chipstart : BEQ 'l10a
        CMP.l chipstart,d1  : BLT 'l10a
        MOVE.b #1,newhunk
        CMP.l chipend,d1    : BGE 'l110a
          SUB.l d7,(a0)
          ADD.l #$80000000,4(a2)
          BRA 'noway
      'l110a
        SUB.l d5,0(a0)

      'l10a
        CMP.l #-1,bssstart : BEQ 'l11a
        CMP.l bssstart,d1  : BLT 'l11a
        CMP.l bssend,d1    : BGE 'l111a
        TST.b newhunk      : BEQ 'ln1a
          ADD.l d5,(a0)
      'ln1a
        SUB.l d6,(a0)
        ADD.l #$40000000,4(a2)
        BRA 'noway

      'l111a
        SUB.l d3,0(a0)

      'l11a
        SUB.l D2,(A0)
     'lm1a

      ADDQ.l #1,hunkoffsetnum
      ; < new

     'noway
      MOVEA.l (A2),A2
    BRA.w 'loop0
 'fixdone

  ; new >
  MOVEM.l (a7)+,d5-d7/d3
  ; < new

  ; --
  ; -- open new file and write binary data to it
  ; --
  MOVEA.l _dosbase,A6 

  MOVE.l ptr_newexefilename,D1
  MOVE.l #MODE_NEWFILE,D2
  JSR _Open(A6)
  MOVE.l D0,D7 : BEQ.w execerr

  ;-- calc size of code hunk
  MOVE.l objlen,D0 : SUB.l #moremem,d0 : SUB.l noinits,D0
  CMP.l #-1,bssstart :  BEQ 'l60
    SUB.l bsssize,d0
    SUB.l chipsize,d0
    BRA.s 'l61
 'l60
    CMP.l #-1,chipstart : BEQ 'l61
      SUB.l bsssize,d0
      SUB.l chipsize,d0
 'l61
  ADDQ.l #3,D0
  LSR.l #2,D0
  MOVE.l D0,tstsize1 ; size of hunk0
  MOVE.l D0,tstsize2 ; size of code hunk, that is hunk0

  MOVE.l D7,D1
  MOVE.l #tsthead,D2                                      ;hunkbegin
  MOVEQ.l #32,D3
  
  ;-- calc hunk sizes for bss and chip hunks
  CMP.l #-1,bssstart  : BEQ 'lb1
  CMP.l #-1,chipstart : BEQ 'lb1          ; we have bss AND chip data
    MOVE.l #1,bssnum
    MOVE.l #2,chipnum
    MOVEQ.l #40,D3
    MOVE.l bsssize,d2 : ADDQ.l #3,d2 : ASR.l #2,d2
    MOVE.l d2,hunkend+8
    MOVE.l d2,bsssize3
    
    MOVE.l chipsize,d2 : ADDQ.l #3,d2 : ASR.l #2,d2
    MOVE.l d2,hunkend2+8
    MOVE.l d2,chipsize2 : ADD.l #$40000000,chipsize2    

    MOVE.l D0,tstsize1c
    MOVE.l D0,tstsize2c
    MOVE.l #hunkbegin2,d2
    BRA 'l100b
 'lb1
  CMP.l #-1,bssstart : BEQ 'l10b         ; we have only bss
    MOVE.l #1,bssnum
    MOVEQ.l #36,D3
    MOVE.l bsssize,d2 : ADDQ.l #3,d2 : ASR.l #2,d2
    MOVE.l d2,hunkend+8
    MOVE.l d2,bsssize2

    MOVE.l D0,tstsize1b
    MOVE.l D0,tstsize2b
    MOVE.l #hunkbegin,d2
 'l10b
  CMP.l #-1,chipstart : BEQ 'l100b       ; we have only chip
    MOVE.l #1,chipnum
    MOVEQ.l #$24,D3
    MOVE.l chipsize,d2 : ADDQ.l #3,d2 : ASR.l #2,d2
    MOVE.l d2,hunkend2+8
    MOVE.l d2,bsssize2 : ADD.l #$40000000,bsssize2

    MOVE.l D0,tstsize1b
    MOVE.l D0,tstsize2b
    MOVE.l #hunkbegin,d2
 'l100b

  ;-- write the hunkheader
  BSR.w mywrite ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes

  MOVE.l destbufferstart,D2 : ADD.l noinits,D2
  MOVE.l objlen,D3 : SUB.l #moremem,d3 : SUB.l noinits,D3
  ; new >
  CMP.l #-1,bssstart  : BNE 'l40
  CMP.l #-1,chipstart : BNE 'l40
    BRA 'l41
 'l40
    ; substract bsssize and chipsize from code hunk and write it
    MOVE.l codeend,d1 : SUB.l d2,d1
    MOVE.l d1,d3 : SUB.l bsssize,d3 : SUB.l chipsize,d3

    MOVE.l D7,D1
    BSR.w mywrite     ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes

    MOVE.l objlen,D3 : SUB.l #moremem,d3 : SUB.l noinits,D3
    MOVE.l d3,d1
    MOVE.l destbufferstart,D2 : ADD.l noinits,D2
    ADD.l d2,d1 : SUB.l codeend,d1
    MOVE.l d1,d3
    MOVE.l codeend,d2
 'l41
  MOVE.l d2,d1
  ADD.l d3,d1
  ; < new
  ADDQ.l #3,D1
  ANDI.l #$FFFFFFFC,D1
  ; new >
  SUB.l d2,d1
  MOVE.l d1,d3
  MOVE.l D7,D1
  BSR.w mywrite      ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes

  ;-- do we have other hunks to write ?
  MOVE.l hunkoffsetcounter,tstsize3 : BEQ.w 'skip

  MOVE.l D7,D1       ; write HUNK_END
  MOVE.l #tstend,D2
  MOVEQ.l #$04,D3    ; was #12
  BSR.w mywrite      ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes

  ; new >
  MOVEA.l _execbase,A6
  MOVE.l hunkoffsetcounter,d0 : ASL.l #2,d0 : ADD.l #12,d0
  JSR _AllocMem(a6)
  TST.l d0 : BEQ 'nomem

  MOVE.l noinits,D4
  MOVE.l d5,-(a7)
  MOVE.l d0,d5
  MOVE.l d0,a1

  MOVEA.l hunkoffsetbase,A2
  MOVE.b #0,newhunk
 'oloopb                      ; copy of 'oloop
    CMPA.w #$0,A2 : BEQ.w 'savehunk

    MOVE.l destbufferstart,D2
    ADD.l noinits,D2
    MOVE.l  4(A2),d1
    BTST #31,d1 : BEQ 'lh1
      MOVE.b #1,newhunk
      BRA 'lh3
   'lh1
    BTST #30,d1 : BEQ 'lh2
      MOVE.b #1,newhunk
      BRA 'lh3
   'lh2
      ADD.l d1,d2
      CMP.l chipend,d2 : BLT 'l102c
        SUB.l chipsize,d1
   'l102c
      CMP.l bssend,d2 :  BLT 'l101c
        SUB.l bsssize,d1
     'l101c
      MOVE.l d1,(a1)
      SUB.l D4,(A1)+
   'lh3
      MOVEA.l (A2),A2
  BRA.w 'oloopb
 'savehunk

  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  MOVE.l hunkoffsetnum,tstsize3 : BEQ 'ln1c
    MOVE.l #tstend+4,d2
    MOVEQ #8,d3
    JSR _Write(A6)
    MOVE.l d7,d1
    MOVE.l hunkoffsetnum,d3
    ASL.l #2,d3
    MOVE.l d5,D2
    JSR _Write(a6)
 'ln1c
  TST.b newhunk :  BEQ 'l10c
  MOVEA.l hunkoffsetbase,A2
  MOVE.l d5,a0
  ADDQ #8,a0
  MOVE.l bssnum,-4(a0)
  MOVEQ #0,d6

 'lh2c
    CMPA.w #$0,A2 : BEQ.w 'lh3c
    
    MOVE.l destbufferstart,D2
    ADD.l noinits,D2
    MOVE.l  4(A2),d1
    BTST #30,d1 :  BEQ 'lh1c
      BCLR #30,d1
      MOVE.l d1,(a0)
      SUB.l D4,(A0)+
      ADDQ.l #1,d6
   'lh1c
    MOVE.l (a2),a2
  BRA 'lh2c
 'lh3c
  TST.l d6 :  BEQ 'lh10c
    MOVE.l d5,a0
    MOVE.l d6,(a0)
    MOVE.l d7,d1
    MOVE.l d5,d2
    MOVE.l d6,d3
    ASL.l #2,d3
    ADDQ.l #8,d3
    BSR.w mywrite   ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes
 'lh10c

  MOVEA.l hunkoffsetbase,A2
  MOVE.l d5,a0
  ADDQ #8,a0
  MOVE.l chipnum,-4(a0)
  MOVEQ #0,d6
 'lh20c
  CMPA.w #$0,A2 : BEQ.w 'lh30c

    MOVE.l destbufferstart,D2
    ADD.l noinits,D2
    MOVE.l  4(A2),d1
    BTST #31,d1 : BEQ 'lh11c
      BCLR #31,d1
      MOVE.l d1,(a0)
      SUB.l D4,(A0)+
      ADDQ.l #1,d6
  'lh11c
    MOVE.l (a2),a2
  BRA 'lh20c
 'lh30c
  TST.l d6 : BEQ 'l10c
    MOVE.l d5,a0
    MOVE.l d6,(a0)
    MOVE.l d7,d1
    MOVE.l d5,d2
    MOVE.l d6,d3
    ASL.l #2,d3
    ADDQ.l #8,d3
    BSR.w mywrite    ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes
 'l10c

  MOVEA.l _execbase,A6
  MOVE.l hunkoffsetcounter,d0
  ASL.l #2,d0
  ADD.l #12,d0
  MOVE.l d5,a1
  JSR _FreeMem(a6)
  MOVEA.l _dosbase,A6
  MOVE.l (a7)+,d5
  BRA 'skip2

 'nomem
  ; < new
  MOVEA.l hunkoffsetbase,A2
  MOVE.l noinits,D4

 'loop
    CMPA.w #$0,A2 : BEQ.w 'skip2          ;write hunkoffsets
    
    LEA 4(A2),A1
    SUB.l D4,(A1)
    MOVE.l D7,D1
    MOVE.l A1,D2
    MOVEQ.l #$04,D3
    BSR.w mywrite    ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes
    ;
    ADD.l D4,4(A2)
    MOVEA.l (A2),A2
  BRA.w 'loop
 'skip2

  CLR.l tstsize3
  MOVE.l D7,D1
  MOVE.l #tstsize3,D2
  MOVEQ.l #$04,D3
  BSR.w mywrite     ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes

 'skip
  TST.w set_link_debuginfo : BEQ.w 'nodebug
    ;
    MOVE.l #sysdebug,D2                                      ;debughunks
    MOVEQ.l #$04,D3
    MOVE.l D7,D1
    BSR.w mywrite   ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes
    ;
    MOVEA.l labelbase,A2

   'deloop
      CMPA.w #$0,A2    : BEQ.w 'dedone

      BTST #$0,$7(A2)  : BEQ.w 'dedeb
        CMPI.l #$1,4(A2)
        ;BNE.w 'denext
        ; new >
        BRA.w 'denext                                            ;only addr labels
        ; < new
     'dedeb
    
      MOVEQ.l #$00,D4
      MOVE.b 18(A2),D4
      SUBI.w #$13,D4
      ADDQ.w #2,D4
      ANDI.w #$FFFC,D4     ;long align
      MOVE.l D4,D5
      LSR.w #2,D5
      MOVE.l D5,temp1
      LSL.w #2,D5          ;#bytes
      ; new >
      MOVE.l #temp1,a1
      ; < new
      ;move.l #temp1,D2
      ; new >
      LEA debugstore,a0
      MOVE.l (a1),(a0)+
      ; < new
      MOVEQ.l #$04,D3
      ;move.l D7,D1
      ;bsr.w mywrite    ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes
      ;
      LEA $13(A2),A1
      ; new >
      MOVE.l d4,d1
      SUBQ.l #1,d1

     'l10d
        MOVE.b (a1)+,d0 :  BEQ 'l21d
        CMP.b #"'",d0 : BNE 'ok                             ; ' does reassembler/assembler not like, so replace
          MOVE.b #"_",d0
       'ok
        MOVE.b d0,(a0)+                                      ; copy labeltext to debuginfo
      DBF d1,'l10d
      BRA 'l22d
       'l21d
          CLR.b (a0)+
        DBF d1,'l21d
     'l22d

      ADD.l d4,d3
      ; < new
      ;move.l A1,D2
      ;move.l D4,D3
      ;move.l D7,D1
      ;bsr.w mywrite    ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes
      ;
      SUB.l D4,D5 : BEQ.w 'deoff
        ; new >
        MOVE.l #zero,a1
        ; < new
        ;move.l #zero,D2
        ; new >
        MOVE.l (a1),(a0)+
        ; < new
        ;move.l D5,D3
        ; new >
        ADD.l d5,d3
        ; < new
        ;move.l D7,D1
        ;bsr.w mywrite
    'deoff

      MOVE.l 8(A2),D2
      SUB.l destbufferstart,D2
      SUB.l noinits,D2
      MOVE.l D2,temp1
      ; new >
      MOVE.l #temp1,a1
      ; < new
      ;move.l #temp1,D2
      ; new >
      MOVE.l (a1),(a0)+
      ADD.l #4,d3
      LEA debugstore,a0
      MOVE.l a0,d2
      ; < new
      ;moveq.l #$04,D3
      MOVE.l D7,D1
      BSR.w mywrite     ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes

    'denext
      MOVEA.l (A2),A2
      BRA.w 'deloop
  'dedone
  
    MOVE.l #zero,D2
    MOVEQ.l #$04,D3
    MOVE.l D7,D1
    BSR.w mywrite      ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes

 'nodebug
  MOVE.l D7,D1
  MOVE.l #tstdone,D2                                      ;hunkend
  MOVEQ.l #$04,D3

  ;-- optionally write bss-hunk
  CMPI.l #-1,bssstart : BEQ 'l10e
    MOVEQ #16,d3
    MOVE.l #hunkend,d2
    CMPI.l #-1,chipstart : BEQ 'l10e
      MOVE.l d7,d1
      MOVEQ #12,d3
      BSR.w mywrite    ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes
 'l10e

  ;-- optionally write chipdata-hunk
  CMPI.l #-1,chipstart : BEQ 'l11e
    MOVEQ #12,d3
    MOVE.l #hunkend2,d2
    MOVE.l d7,d1
    BSR.w mywrite      ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes

    MOVE.l d7,d1
    MOVE.l chipstart,d2
    MOVE.l chipsize,d3
    BSR.w mywrite      ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes

    MOVEQ #4,d3
    MOVE.l #hunkend,d2
    MOVE.l d7,d1
 'l11e

  BSR.w mywrite        ; input: D1: file, D2: buffer, D3: length, output: D0: written bytes

  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  JSR _Close(A6)

  
  ;
  ; --
  ; -- create the optional icon for the executable
  ;create_icon:
  TST.w set_create_iconfile : BEQ.w 'done
    ;
    ;OK, create an icon for the object code!
    ;
    !basic
    iconfilename.s = Peek.s(PeekL(?ptr_newexefilename))
    If dos_Exist{iconfilename + ".info"}
      dos_Delete{iconfilename + ".info"}
    EndIf

    *ni.DiskObject = GetDiskObject_(Null)
    If *ni
      log2PED{"writing info-file for [" + iconfilename + "]"}

      ;-- create the Image structure with embedded gfx data
      iImg.Image\LeftEdge = 0,0, 46,23,2, ?iconImageData,3,0,Null

    ;-- fill the diskobject-structure
      *ni\do_Magic       =  #WB_DISKMAGIC
      *ni\do_Version     =  #WB_DISKVERSION
      *ni\do_Gadget\NextGadget = Null, 25,17,46,24,#GFLG_GADGHBOX|#GFLG_GADGIMAGE, #GACT_IMMEDIATE|#GACT_RELVERIFY, #GTYP_BOOLGADGET,iImg,0,0,0,0,0,0
      
      *ni\do_Type        = #WBTOOL
      *ni\do_CurrentX    = #NO_ICON_POSITION ; 18
      *ni\do_CurrentY    = #NO_ICON_POSITION ; 14

      If PutDiskObject_(iconfilename, *ni) = False
        log2PED{"Could not write DiskObject, error " + Str$(IoErr_)}
      EndIf
      FreeDiskObject_(*ni)
    Else
      log2PED{"Could not init Diskobject structure"}
    EndIf
    !asm

    MOVEA.l ptr_newexefilename,A0
    CLR.b (A0)
 'done

  ; new >
  ; --
  ; -- restore offsets for external debug
  TST.b exdebug : BEQ 'fixdoneb

  MOVE.w dontwrite_nomemleft,D1 : BNE.w 'fixdoneb
  
  MOVE.l chipsize,d5
  MOVE.l bsssize,d3
  MOVE.l chipstart,d7
  MOVE.l bssstart,d6
  MOVEA.l hunkoffsetbase,A2
  MOVEA.l destbufferstart,A1
  MOVE.l A1,D2
  ADD.l noinits,D2
  CLR.l hunkoffsetnum

 'loop0b                ; copy save_binaryfile 'loop0
  CMPA.w #$0,A2 : BEQ.w 'fixdoneb
  MOVE.l 4(A2),D0
  LEA $0(a1,d0.l),a0
  MOVE.l (a0),d1
  TST.l d1            :  BMI.w 'lm1f
  MOVE.b #0,newhunk
  CMP.l #-1,chipstart :  BEQ 'l10f
  CMP.l chipstart,d1  :  BLT 'l10f
  MOVE.b #1,newhunk
  CMP.l chipend,d1    :  BGE 'l110f
  ADD.l d7,(a0)
  ADD.l #$80000000,4(a2)
  BRA 'nowayb

 'l110f
  ADD.l d5,0(a0)

 'l10f
  CMP.l #-1,bssstart :  BEQ 'l11f
  CMP.l bssstart,d1  :  BLT 'l11f
  CMP.l bssend,d1    :  BGE 'l111f
  TST.b newhunk      :  BEQ 'ln1f
  ADD.l d5,(a0)

 'ln1f
  ADD.l d6,(a0)
  ADD.l #$40000000,4(a2)
  BRA 'nowayb

 'l111f
  ADD.l d3,0(a0)

 'l11f
  ADD.l D2,(A0)                                            ;only normal code offsets restore

 'lm1f
  ADDQ.l #1,hunkoffsetnum

 'nowayb
  MOVEA.l (A2),A2
  BRA.w 'loop0b

 'fixdoneb                        ; end of copy
  ; < new
  MOVEM.l (a7)+,d2-d7/a2-a6

 'rts
RTS


.addoff:
  ;--
  ;-- add pc to list of offsets
  MOVE.l D2,-(A7)
  MOVE.l destpointer,D2 : SUB.l destbufferstart,D2
  BSR.w addhunkoffset
  MOVE.l (A7)+,D2
RTS


.addhunkoffset:  ; was addoff2 org source
  ;--
  ;-- add d2 to linked list of all offsets
  MOVEM.l D0-D1/A0-A1/A6,-(A7)

  TST.b nohunkoffset :  BNE 'l10
    MOVEA.l _execbase,A6
    MOVEQ.l #$8,D0
    MOVE.l mempool2,a0 : JSR _AllocPooled(a6)

    ADDQ.l #1,hunkoffsetcounter
    MOVEA.l D0,A0
    MOVE.l hunkoffsetbase,(A0)
    MOVE.l A0,hunkoffsetbase
    MOVE.l D2,$4(A0)
 'l10
  MOVEM.l (A7)+,D0-D1/A0-A1/A6
RTS


.free_allHunkOffsets:
  ;--
  ;-- kill all offsets
  MOVEA.l _execbase,A6

  CLR.l hunkoffsetbase
  MOVEA.l hunkoffsetbase,A2
 'loop
    CMPA.w #$0,A2 : BEQ.w 'skip

    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$08,D0
    MOVE.l mempool2,a0 : JSR _FreePooled(A6)
  BRA.w 'loop
 'skip
  CLR.l hunkoffsetcounter
RTS


cmakebuff:  Ds.l 6                                          ;dc.w 12 org source
cmakea5:    Ds.l 1
cmake:      Ds.w 1
cmakebak:   Ds.l 32                                         ;ds.b 128 org source


getchar: ; A5=sourcepos, return D0 = next char
  MOVE.l A5,lastsourcepos
  MOVE.w instringon,oldqflag
   ;bsr.w getcharb                                          ;gettokennum

  MOVEQ.l #$00,D0
  MOVE.b (A5)+,D0 : BEQ 'donea
  BPL 'stuffa                                               ; token?
    LSL.l #8,D0
    MOVE.b (A5)+,D0
    MOVE.l a1,-(a7)
    LEA replacedat,a1
    Dc.w $4a71,$0a00 : BEQ 'l10                             ;TST.w 0(a1,d0.l*2)
      Dc.w $3031,$0a00                                      ;MOVE.w 0(a1,d0.l*2),d0
   'l10
    ;MOVE.l d0,lasttoken
    MOVE.l (a7)+,a1
    BRA 'weiter
 'stuffa
  CMP.w #$22,D0 : BEQ.b 'swapquotea                           ;'"'
  CMP.w #$3B,D0 : BNE.b 'donea
  TST.w instringon : BNE.b 'donea

 'loopa
    MOVE.b (A5)+,D0 : BEQ 'l1
    
    CMP.b #":",d0 : BNE 'loopa                               ;skip ":@"
    CMP.b #"@",(a5) : BNE 'loopa
      ADDQ #1,a5
 'l1
  MOVE.w D0,lastchar

 'donea
  BRA.s 'weiter

 'swapquotea
  NOT.w instringon

 'weiter
  MOVE.w D0,lastchar : BEQ.w 'done
  BPL.w 'done2
    CMP.w ##TokenID_CNIF,D0 :   BEQ.w 'cnif
    CMP.w ##TokenID_CSIF,D0 :   BEQ.w 'csif
    CMP.w ##TokenID_CELSE,D0:   BEQ.w 'celse
    CMP.w ##TokenID_CEND,D0 :   BEQ.w 'cend
 'done2
  TST.w skipcode :   BEQ.w getchar
  CMP.w #127,D0  :   BEQ.w 'cmake                            ;tilde
  CMP.w #$2,D0   :   BNE.w 'notunpath
    MOVEA.l usedfrom,A5
    CLR.l usedfrom
    BRA.w getchar
 'notunpath
  CMP.w #$1,D0 : BNE.w 'done
  
  ;-- 
  ;-- End of Cmake chars got
  ;--
  MOVEA.l cmakea5(PC),A5
  BRA.w getchar

 'cmake
  TST.w cmake :  BNE.w 'done

  MOVEM.l D0-D7/A0-A6,-(A7)
  LEA cmake,a0                                            ;reass
  NOT.w (a0)
  LEA cmakebak(PC),A0
  LEA namebuffer,A1
  MOVEQ.l #$1F,D0

 'cmloop
    MOVE.l (A1)+,(A0)+
  DBF D0,'cmloop

  JSR evalconst3                                      ;get constant into d3
  CMP.w #127,D0 : BNE.w syntaxerr                        ; tilde

  MOVE.l A5,cmakea5
  LEA cmakebuff(PC),A0
  MOVE.l D3,D2
  BSR.w makelong
  ADDQ.b #1,(A0)
  LEA cmake,a0
  NOT.w (a0)                                               ;reass
  LEA cmakebak(PC),A0
  LEA namebuffer,A1
  MOVEQ.l #$1F,D0

 'cmloop2
    MOVE.l (A0)+,(A1)+
  DBF D0,'cmloop2

  MOVEM.l (A7)+,D0-D7/A0-A6
  LEA cmakebuff(PC),A5
  BRA.w getchar

 'done
 RTS

 'csif
  MOVE.l linenumat,ciflineat                               ;csif
  TST.w skipcode : BEQ.w 'incnest
    BSR.w get1bytemain
    MOVE.l a1,-(a7)
    JSR do_csif
    MOVE.l (a7)+,a1
    BRA.w getchar

 'cnif
  MOVE.l linenumat,ciflineat                               ;cnif
  TST.w skipcode : BEQ.w 'incnest
    BSR.w get1bytemain
    CMP.b #"@",d0 : BNE 'cnif_ok2
      BSR.w get1bytemain
      MOVE.b #1,incnif
      JSR findconstant2 : BEQ 'cnif_ok2
   'cnif_ok2
    MOVE.w optimize_integer,-(a7)
    CLR.b optimize_integer
    MOVE.l a1,-(a7)
    JSR do_cnif
    CLR.b incnif
    MOVE.l (a7)+,a1
    MOVE.w (a7)+,optimize_integer
    BRA.w getchar
 'incnest
  ADDQ.w #1,connest
  BRA.w getchar

 'celse
  MOVE.w connest,D0                                      ;celse
  BNE.w getchar
  NOT.w skipcode
  BRA.w getchar

 'cend
  SUBQ.w #1,connest                                      ;cend
  BPL.w getchar
  ADDQ.w #1,connest
  MOVEA.l concomsp,A0
  CMPA.l #concomstack,A0 : BEQ.w nociferr
  SUBQ.w #2,A0
  MOVE.l A0,concomsp
  MOVE.w (A0),skipcode
BRA.w getchar


ciflineat:   Ds.l 1


.getcharb:
  ;-- 
  ;-- get next character into d0... a5=charpointer
  ;-- set hi bit if token, and lo 15 bits to token number (0-32767)
  MOVEQ.l #$00,D0
  MOVE.b (A5)+,D0 : BEQ.b 'done
  BPL.b 'stuff
  LSL.w #8,D0
  MOVE.b (A5)+,D0
  RTS

 'stuff
  CMP.w #$22,D0    : BEQ.b 'swapquote     ;'"'
  CMP.w #$3B,D0    : BNE.b 'done
  TST.w instringon : BNE.b 'done

 'loop
  MOVE.b (A5)+,D0 : BEQ 'loop_l1
  CMP.b #":",d0   : BNE 'loop             ; skip ":@"
  CMP.b #"@",(a5) : BNE 'loop
 'loop_l1
  MOVE.w D0,lastchar
 'done
RTS

 'swapquote
  NOT.w instringon
RTS


get1byte_:                                                 ;getchar2 org source  ;as above and skip spaces
  BSR.w getchar
  TST.w instringon : BNE.w 'skip
    CMP.w #" ",D0 : BEQ.w get1byte_     ;' '
   
 'skip
RTS


gs:        Ds.w 13                                         ;ds.b 26  org source
           Dc.b $F6,$E4,$FC,$D6                            ;dc.b 228,246,252,196,214,220 org source
           Dc.b $C4,$DC

Even

.get1bytemain:                                             ;getchar3 org source    ;as above. return z=1 if 0 or ':'
  ;bsr.w get1byte_
  ; new >
  BSR.w getchar

  TST.w instringon : BNE.w gchar2
    CMP.w #" ",D0 : BEQ.w get1bytemain               ; 32 " "
      ; < new
      TST.w D0
  gchar2:
  BEQ.b 'zero
    TST.w instringon : BEQ.b 'noqoute
      CMP.b #" ",D0 : BCC.b 'skip                    ; 32 " "
        MOVE.b gs(PC,D0.W),D0
        RTS
   'noqoute
    CMP.w ##TokenID_Else,D0 : BEQ.b 'zero            ;cmp #$8000+34,d0 org source  ;else
      CMP.w #$3A,D0 : BEQ.b 'zero                    ;':'
   'skip
      TST.w D0
   'zero
RTS


reget:
  MOVE.w lastchar,D0
BRA.w gchar2


bakup:
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
RTS


storeloc:                                                  ;remember character pointer
  MOVE.w D0,locchar
  MOVE.l A5,locloc
RTS


resloc:                                                    ;recall char pointer....
  MOVEA.l locloc,A5
  MOVE.w locchar,D0
  MOVE.w D0,lastchar
RTS


.hexascii:                                                    ;convert d1.w to ascii at a0
  MOVE.w D0,-(A7)
  MOVEQ.l #$03,D0

 'loop
    MOVE.w D1,D2
    ANDI.w #$F,D2
    ADDI.w #$30,D2
    CMP.w #$3A,D2 : BCS.w 'skip   ;":"
      ADDQ.w #7,D2
   'skip
    MOVE.b D2,$0(A0,D0.W)
    LSR.w #4,D1
  DBF D0,'loop

  MOVE.w (A7)+,D0
RTS


ezerr:   Ds.w 1                                            ;for simple errors
                                                           ;(ie not during compile)

errorlimit_text:     
         Dc.b "There are too much errors, compiling will stop now. Please fix errors first and try again",0
Even
.error_messages:
XINCLUDE "internal_errormsg.ab3"
Even



.handle_compileerror:                                      ;compile time error...
  ;-- (a7) holds the error cause, must be removed from stack !
  MOVE.l macroline,d0 : BNE 'l2
    CNIF #continue_on_error
      MOVE.l a5,lastsourcepos
    CEND
    SUBA.l a5,a5
 'l2

  TST.l usedfrom : BEQ 'org
    MOVEA.l usedfrom,a5
 'org

  TST.w direct_mode : BNE.b 'quiet

    MOVE.w ezerr(PC),D0 : BNE.w 'skip
      MOVE.w cfetchmode,D0 : BEQ.w 'skip2
        MOVE.l oldlibat,destbufferend                      ;fix up lib thing.
     'skip2

      MOVE.w constmode,D0 : BEQ.b 'skip3
        BSR.w asmerr2
     'skip3

      MOVE.l firstlocal,D1 : OR.l firstglob,D1 : BEQ.b 'notproc
        TST.l CLIMode : BNE 'notproc                       ; test for climode, added to prevend the freeing of some datas this prevend false errors in climode with continue_on_error active  tomsmart1
          JSR droplocals                                   ; no free some data ????
     'notproc
      MOVE.w #$FFFF,anyerrs                                ;#-1,anyerrs org source

      CMP.l #"NORE",reqmode : BEQ 'notproc_l1              ;for used functions
        MOVE.l linenumat,compilelinecounter
     'notproc_l1

      JSR close_compilewin
   'skip

    MOVEA.l (A7)+,A0                                       ; get the error cause from stack

    MOVE.l errorcounter,d0                                 ; added to make maxerrorcount changable in CLIMode  tomsmart1
    CMP.l maxerrorcount,d0 : BLT 'lesserror                ; changed to make maxerrorcount changable in CLIMode  tomsmart1
      LEA errorlimit_text,a0
   'lesserror
    ADDQ.l #1,errorcounter

    JSR errorstringparse

    CMP.l #"NORE",reqmode : BEQ 'skip_Lxx2                 ;for used functions
      TST.l CLIMode : BNE 'climode_output
       'guimode_output
        JSR save_errorfile
        BRA 'end_output
     'climode_output
      JSR stdout_error

      CNIF #continue_on_error
        MOVE.l errorcounter,d0                          ; added to make maxerrorcount changable in CLIMode  tomsmart1
        CMP.l maxerrorcount,d0 : BGT 'end_output        ; changed to make maxerrorcount changable in CLIMode  tomsmart1
          MOVE.l lastsourcepos,a5
          'loop
            TST.b (a5) : BEQ 'ok2
              MOVE.b (a5)+,d0 : BEQ 'ok                 ; position to usefull source position to avoid following errors
                CMP.b #":",d0 : BEQ 'ok
          BRA 'loop
          'ok
            SUBQ.l #1,a5
          'ok2
            MOVE.w #0,lastchar
            MOVE.b #1,iserror
            MOVE.l stackaddr,a7
          RTS
      CEND
     'end_output
 
   'skip_Lxx2
    MOVEA.l errstack,A7
    MOVEA.l errcont,A0
    ;JMP (A0)                                                  ;clear all vars
    RTS
 'quiet
  MOVE.l (A7),D0

  MOVEA.l errstack,A7
  MOVEA.l errcont,A0
JMP (A0)


tstlab:                                                   ; tst if d0 is a valid label character
                                                          ; eq=1 if yes
  !test_for_letter : BEQ.w 'skip
  !test_for_literal : BEQ.w 'skip
  CMP.w #"_",D0 : BEQ.w 'skip
  CMP.w #"'",D0                                           ;#loclabch,d0 org source
 'skip
RTS


makename2:
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new

getparameter2:                                            ;makename org source
  ;-- pick up label name from a5...
  ;-- 
  ;-- put into namebuffer, return len in d2 (eq if zero)
  ;--
  ; new >
  MOVE.l a5,beforeparameterfetch
  ; < new
  LEA namebuffer,A1

makename3:
  MOVEQ.l #$00,D2

makename4:
  ; new >
  MOVE.l A5,lastsourcepos
  MOVE.w instringon,oldqflag

  MOVEQ #0,d0
 'retry
    MOVE.b (a5)+,d0
  CMP.b #" ",d0 : BEQ 'retry                               ; skip spaces
  

  MOVE.w d0,lastchar
  LEA chartab,a0  
  TST.b 0(a0,d0.w) : BNE 'done                             ; check illegal character

 'loop
  MOVE.b D0,(A1)+
  ADDQ.l #1,D2
  ;
  ; new >
  MOVE.l A5,lastsourcepos

 'loop_ln1
    MOVE.b (a5)+,d0
    MOVE.b d0,lastchar+1
    CMP.b #" ",d0 : BEQ 'loop_l20

      TST.b 0(a0,d0) : BEQ 'loop
      CMP.b #2,d0 : BNE 'loop_lf1
        MOVEA.l usedfrom,A5
        CLR.l usedfrom
        BRA 'loop_ln1
     'loop_lf1

      CMP.b #1,d0 : BNE 'loop_l20
        MOVEA.l cmakea5(PC),A5
        BRA 'loop_ln1
   'loop_l20
    CMP.b #127,d0 : BNE 'loop_lt                  ; tilde
      TST.w cmake : BNE.w 'loop_a1
        SUBQ.l #1,a5
        BSR.w get1bytemain
        BRA 'loop
     'loop_a1                                         ;??looks like double label??
   'loop_lt
    BRA 'loop_gpex

 'loop_old                                        ;tstlab org source ;??looks like a copy??
  ; < new
  BSR.w getchar
  ; new >
  !test_for_letter  : BEQ.w 'loop_getp1
  !test_for_literal : BEQ.w 'loop_getp1
  CMP.w #"_",D0 : BEQ.w 'loop_getp1
  CMP.w #"'",D0                                           ;#loclabch,d0 org source

 ;'skip                                                   ;??Looklike dead label??
 'loop_getp1
  BNE 'loop_gpex
  CMP.b #" ",d0
  ; < new
  BNE.w 'loop
  ; new >
 'loop_gpex
  TST.b d0 : BPL 'loop_l10
    SUBQ.l #1,a5
    BSR get1byte_
 'loop_l10
  ; < new
  ;
  ;not    quoteflag   ;back to norm...
  ;not    oldqflag
  ;
  CMP.w #" ",D0 : BNE.w 'done
   ; new >
  MOVEQ #0,d0
  MOVE.l a5,lastsourcepos

 'loop_l103
  MOVE.b (a5)+,d0 : BPL 'loop_l101                                          ;neuneu
    ASL.w #8,d0
    MOVE.b (a5)+,d0
 'loop_l101

  TST.w instringon :  BNE 'loop_l102
  CMP.b #" ",d0    :  BEQ 'loop_l103
  CMP.b #";",d0    :  BNE 'loop_l102

 'loop_lr
    MOVE.b (A5)+,D0  :  BEQ 'loop_l1
    CMP.b #":",d0    :  BNE 'loop_lr                         ;:@
    CMP.b #"@",(a5)  :  BNE 'loop_lr
      ADDQ #1,a5
 'loop_l1
 'loop_l102
  MOVE.w d0,lastchar
  ; < new
   ;BSR.w get1bytemain

 'done
  ; new >
  CMP.b #";",d0 : BEQ 'done_l11
    ; < new
    CLR.b (A1)
    ; new >
    ;move.l (a7)+,a0
    ; < new
    TST.w D2
    RTS
    ; new >
 'done_l11
  CLR.b (a1)
  MOVEQ #0,d0
  MOVE.w d0,lastchar
  ;move.l (a7)+,a0
  ; < new
  TST.w D2
RTS
  ;< new


findlast: 
  ;look for last entry in list from a2
  ;
  MOVE.l (A2),D0

 'loop
  BEQ.w 'here
  MOVEA.l D0,A2
 BRA.w 'loop

 'here
BRA.w reget


.addhere2:
  ;--
  ;-- insert at beginning of list
  MOVE.l (A2),-(A7)
  BSR.w add_Label
  MOVE.l (A7)+,(A2)
RTS

; new >
.add_LabelHash:
  CLR.l fp0addr
  TST.w direct_mode : BNE.w illdirerr

  MOVEA.l _execbase,A6

  MOVEQ.l #$00,D0
  MOVE.w D7,D0
  ADD.w D2,D0
  ADDQ.w #1,D0
  MOVE.w D0,D2
  ADDQ.l #2,d0
  MOVE.l mempool2,a0 :  JSR _AllocPooled(a6)

  MOVE.l lastlabel,a2
  MOVE.l D0,(A2)
  MOVE.l d0,a0
  CLR.l (a0)
  MOVE.l a0,lastlabel
  MOVE.l d0,A2
  LEA -$1(A0,D7.W),A0
  MOVE.b D2,(A0)+
  LEA namebuffer,A1
  MOVEQ #0,d0
  MOVEQ #0,d1

 'loop2a
    MOVE.b (A1)+,d1 : BEQ 'l1
    
    !hashalgo
    MOVE.b d1,(A0)+
  BRA 'loop2a
 'l1
  CLR.b (a0)+
  LEA labelhash,a0
  AND.l #hashsize,d0
  ASL.l #2,d0
  MOVE.l 0(a0,d0),d1
  MOVE.l d1,12(A2)
  MOVE.l a2,0(a0,d0)
  MOVEQ #0,d0
BRA.w reget


.add_Variable:
  TST.b newvariable : BNE add_Label

 'l1
  TST.w direct_mode : BNE.w illdirerr

  MOVEA.l _execbase,A6
  
  MOVEQ.l #$00,D0
  MOVE.w D7,D0 : ADD.w D2,D0 : ADDQ.w #1,D0
  MOVE.w D0,D2
  MOVE.l mempool2,a0 : JSR _AllocPooled(a6)
  MOVEA.l D0,A0

  LEA varbase,a2
  MOVE.l (a2),(a0)
  MOVE.l A0,(A2)
  MOVEA.l A0,A2
  LEA -$1(A0,D7.W),A0
  MOVE.b D2,(A0)+
  LEA namebuffer,A1
  MOVEQ #0,d0
  MOVEQ #0,d1

 'l11
   MOVE.b (A1)+,d1 : BEQ 'l12
   
   !hashalgo
   MOVE.b d1,(A0)+
  BRA 'l11
 'l12
  CLR.b (a0)+
  LEA variablehash,a0
  AND.l #hashsize,d0
  ASL.l #2,d0
  MOVE.l 0(a0,d0),d1
  MOVE.l d1,14(A2)
  MOVE.l a2,0(a0,d0)
  MOVEQ #0,d0
BRA.w reget
; < new


;labelbase
; $0 next entry
; $4 mode 0 = label 1 = constant
; $8 addr/label value/constant
; $c nexthash
; $12 Bytecount
; $13 name

.add_Label:        ; was addhere org source
  ;--
  ;-- add namebuffer after a2,d7
  ;--
  ;-- d2=len of name, name in namebuffer
  ;-- set a2 to address of struct
  ;
  TST.w direct_mode : BNE.w illdirerr

  MOVEA.l _execbase,A6

  MOVEQ.l #$00,D0          ; alloc memory for new entry
  MOVE.w D7,D0
  ADD.w D2,D0
  ADDQ.w #1,D0             ; d7 + d2 + 1, for zero byte ?
  MOVE.w D0,D2
  MOVE.l mempool2,a0 : JSR _AllocPooled(a6)
  MOVEA.l D0,A0

  MOVE.l A0,(A2)
  CLR.l (a0)               ; clear pointer to next entry
  CLR.l 8(a0)              ; clear special data, e.g. filehandle
  MOVEA.l A0,A2
  ; < new
  LEA -$1(A0,D7.W),A0
  MOVE.b D2,(A0)+          ; put in struct length

  LEA namebuffer,A1        ; put in name
  ; new >
  MOVEQ #0,d0
  MOVEQ #0,d1
  ; < new

 'loop2
    MOVE.b (A1)+,d1       ; was move.b  (a1)+,(a0)+                                              ;??looks like label not used anymore??
    MOVE.b d1,(A0)+       ; "
  BNE.w 'loop2
BRA.w reget


.findinclude:           ; was findinc org source
  MOVEQ.l #$13,D7       ; begin of string in list entry
  LEA includebase,A2
BRA.w findlab


.findxinclude:
  MOVEQ.l #$05+8,D7     ; was #5                                ;#5,d7 org source
  LEA xincludebase,A2
BRA.w findlab


findconst_org:
  MOVEQ.l #$09,D7
  LEA firstconst,A2
BRA.w findlab


findmac:
  MOVEQ.l #$0d,D7                                          ;find macro
  LEA macrobase,A2
BRA.w findlab


.findlabel2:                 ; was findadd  org source
  LEA labelhash,A2

  MOVEQ.l #$13,D7
  ; new >
  EXT.l d2
  LEA namebuffer,A0
  MOVEQ #0,d0
  MOVEQ #0,d1

 'l20
    MOVE.b (a0)+,d1 : BEQ 'l15
    
    !hashalgo
  BRA 'l20
 'l15

  AND.l #hashsize,d0
  ASL.l #2,d0
  MOVE.l 0(a2,d0),d0
  BRA 'l11

 'loop
    MOVE.l 12(A2),D0          ;  begin copy of findlabel

   'l11
    BEQ findlab_no
    MOVEA.l D0,A2
    MOVEQ.l #$00,D0
    MOVE.b -$1(A2,D7.l),D0
    LEA namebuffer,A0
    SUB.l D7,D0
    SUBQ.l #1,D0
  CMP.l D0,D2 : BNE.b 'loop

  LEA $0(A2,D7.W),A1
  SUBQ.l #1,D0

 'loop2
    MOVE.b (a1)+,d1
    CMP.b (a0)+,d1
    ;CMPM.b (A1)+,(A0)+
    BNE.b 'loop
  DBF D0,'loop2

  BSR.w reget
  CMP.w D0,D0
RTS                     ; end copy of findlab
  ; < new

findtype:
  MOVEQ.l #$0B,D7
BRA.w findlab


find_procedure:
  LEA firstproc,A2
  MOVE.l #$21+#funcentry_extend,D7    ; was #33,
BRA findlab


findfor:
  LEA firstfor,A2
  MOVEQ.l #$11,D7
BRA.w findlab


findvariable2       ; was findvar org source
  MOVEQ.l #$0F,D7
  ; new >
BRA.w findlab


findvariable:
  MOVEQ.l #$0F+4,D7
  TST.b newvariable : BNE.w findlab

  LEA variablehash,A2
  LEA namebuffer,A0
  MOVEQ #0,d0
  MOVEQ #0,d1

 'l20
    MOVE.b (a0)+,d1 : BEQ 'l15
    !hashalgo
  BRA 'l20
 'l15

  AND.l #hashsize,d0
  ASL.l #2,d0
  MOVE.l 0(a2,d0),d0
  BRA 'l11

 'l10
    MOVE.l 14(A2),D0                                         ;find label

   'l11
    BEQ findlab_no
  
    MOVEA.l D0,A2
    MOVEQ.l #$00,D0
    MOVE.b -$1(A2,D7.W),D0
    LEA namebuffer,A0
    SUB.w D7,D0
    SUBQ.l #1,D0
    CMP.w D0,D2 :  BNE.b 'l10
  
    LEA $0(A2,D7.W),A1
    SUBQ.l #1,D0

  'l201
      MOVE.b (a1)+,d1
      CMP.b (a0)+,d1
      ;CMPM.b (A1)+,(A0)+
      BNE.b 'l10
    DBF D0,'l201

  BSR.w reget
  CMP.w D0,D0
RTS
  ; < new


.findlab:
  ;-- see if namebuff is in list at a2, char offset in d7
  ;-- z=1 if yes, a2=item loc
  ;-- if no, a2=last for link

 'loop
    MOVE.l (A2),D0 : BEQ.b findlab_no                       ;find label 

    MOVEA.l D0,A2

    MOVEQ.l #$00,D0
    MOVE.b -$1(A2,D7.W),D0
    SUB.l D7,D0
    SUBQ.l #1,D0
    CMP.w D0,D2 : BNE.b 'loop

    LEA $0(A2,D7.W),A1
    LEA namebuffer,A0
    SUBQ.l #1,D0

   'loop2
      MOVE.b (a1)+,d1
      CMP.b (a0)+,d1 : BNE.b 'loop
    DBF D0,'loop2

    BSR.w reget
    CMP.w D0,D0
    RTS
  findlab_no:

  BSR.w reget
  MOVEQ.l #-$01,D1
RTS


.free_procedureVS:
  MOVEA.l alllocals,A4
  CLR.l alllocals
  ; new >
; BRA 'done
  ; < new

 'loop
    CMPA.w #$0,A4 : BEQ.b 'done

    MOVEA.l $4(A4),A3
    ;BSR.w 'freevarsb       ; was freevars
    MOVEA.l $8(A4),A3
    ;BSR.w freevars
    MOVEA.l A4,A1
    MOVEA.l (A4),A4
    MOVEA.l _execbase,A6
    MOVEQ.l #$0C,D0
    MOVE.l mempool,a0 : JSR _FreePooled(A6)
  BRA.b 'loop
 'done

  ; new >
  CLR.l firstglob                                          ;fix 2*aclearallvar called
  CLR.l firstlocal
  CLR.l sharebase
  MOVEA.l _execbase,A6
  TST.l mempool2 : BEQ 'done_l10
    MOVE.l mempool2,a0
    CLR.l mempool2
    JSR _DeletePool(a6)

 'done_l10
  MOVE.l ##MEMF_CLEAR,d0
  MOVE.l #80000,d1
  MOVE.l d1,d2
  JSR _CreatePool(a6)
  MOVE.l d0,mempool2
RTS


freevars:
  ;free up var structs from a3 on
  CMPA.w #$0,A3
   BEQ.w 'done
  MOVEA.l A3,A1
  MOVEA.l (A3),A3
  MOVEQ.l #$00,D0
  MOVE.b $E(A1),D0
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0 : JSR _FreePooled(A6)
  BRA.w freevars

  ; new >
 'freevarsb
    CMPA.w #$0,A3
     BEQ.w 'done
    MOVEA.l A3,A1
    MOVEA.l (A3),A3
    MOVEQ.l #$00,D0
    MOVE.b $E+4(A1),D0
    MOVEA.l _execbase,A6
    MOVE.l mempool2,a0 : JSR _FreePooled(A6)
  BRA.w 'freevarsb
  ; < new

 'done
RTS


.free_Labels: ; was freelabels org source
  ;--
  ;-- free up label structs from firstlabel on...
  MOVEA.l _execbase,A6
 
  MOVEA.l currentlabeladdr,A0
  MOVE.l a0,lastlabel
  MOVEA.l (A0),A2
  CLR.l (A0)
  MOVEA.l _execbase,A6

 'loop
    CMPA.w #$0,A2 : BEQ.w 'done
  
    MOVE.l 4(A2),D0
    BTST #$0,D0 : BNE.w 'skip
      MOVEA.l D0,A3  
     'loop2
        CMPA.w #$0,A3 : BEQ.w 'skip
        
        MOVEA.l A3,A1
        MOVEA.l (A3),A3
        MOVEQ.l #$0C+2,D0     ; was #12                                 ;cancel fix
        MOVE.l mempool,a0 : JSR _FreePooled(A6)
      BRA.w 'loop2
   'skip
   
    MOVEQ.l #$00,D0
    MOVE.b 18(A2),D0
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVE.l mempool2,a0  ;JSR _FreePooled(A6)                          ;nofreemem
  BRA.w 'loop
 'done
RTS


.free_pEnds:
  MOVEA.l _execbase,A6

  MOVEA.l firstpend,A3
  CLR.l firstpend
 'fpnd2
    CMPA.w #$0,A3 : BEQ.w 'done
 
    MOVEA.l A3,A1
    MOVEQ.l #$08,D0
    MOVEA.l (A3),A3
    MOVE.l mempool,a0 : JSR _FreePooled(A6)
  BRA.w 'fpnd2
 'done
RTS


.free_proceduresList:  ; was freeprocs org source
  ;--
  ;-- free up all proc structs
  MOVEA.l _execbase,A6

  MOVEA.l firstproc,A2
  CLR.l firstproc
 'loop
    CMPA.w #$0,A2 : BEQ.w 'done

    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$00,D0
    MOVE.b $20+#funcentry_extend(A1),D0    ; was 32(a1),
    MOVE.l mempool2,a0 : JSR _FreePooled(A6)
  BRA.w 'loop
 'done
RTS


.free_Types:
  ;--
  ;-- free up type structs from a2 on
    CMPA.w #$0,A2 : BEQ.w 'done

    MOVEA.l 4(A2),A3
    CMPA.w #$FF,A3 : BEQ.w 'noway
      ;--
      ;-- free offsets too
      ;--
      BSR.w freevars
   'noway
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$00,D0
    MOVE.b $A(A1),D0
    MOVEA.l _execbase,A6
    MOVE.l mempool2,a0 : JSR _FreePooled(A6)
  BRA.w free_Types
 'done
RTS


.fetchvars:
  ;-- find/create variable/struct from namebuff
  ;-- flagmask.0=1 if pointer
  ;--
  ;-- get pointer to variable in a3, pointer to type in a2
  ;--
  JSR usevars

  CLR.w notshared
  CLR.w varmode           ;local mode
  MOVE.w proceduremode,D1 : BNE.w fvarlocal
  ;
  LEA varbase,A2
  
  LEA namebuffer,a0
  CMP.b #$22,(a0) : BNE fvarback          ; "
    MOVEQ #0,d0 :JMP error
  fvarback:
  
  BSR.w findvariable
 'more
    BNE.w fvaradd

    ; new >
  'moreb
    ; < new
    MOVE.b flagmask+1,D1
    MOVE.b $7(A2),D3
    EOR.b D3,D1 : BNE 'l2
      CMP.b #2,nowdeclare : BEQ errormsg_declaredtwice
      BRA.w fvarfound
   'l2
    ; < new
    BSR.w findlab : BNE 'l1
      CMP.b #2,nowdeclare : BEQ errormsg_declaredtwice
      CMP.w d0,d0
   'l1
    ; < new
  BRA.w 'more


.fvaradd:
  MOVE.l a2,-(a7)
  LEA sharebase,a2
  MOVEQ #$f+4,d7
  BSR.w findlab : BEQ 'l2x
    MOVE.l (a7)+,a2
    BRA 'cont
 'l2x
    ADDQ.l #4,a7
    CLR.w varmode
    MOVE.b flagmask+1,D1
    MOVE.b $7(A2),D3
    EOR.b D3,D1 : BNE vardeclareerr
    BRA fvarfound
 'cont
  ; < new
  MOVE.w nonew,D1 :  BNE.w nonewerr
  ; new >
  TST.b nowdeclare : BNE 'l2b
  TST.b declare2   : BEQ 'l1b
  CMP.b #".",d0    : BEQ 'l2b
  CMP.b #"$",d0    : BEQ 'l2b
    BRA vardeclareerr
 'l1b
  TST.b declare : BNE vardeclareerr

 'l2b
  ; < new
  BSR.w add_Variable                ; create var
  NOT.w notshared                  ; set added flag
  MOVEA.l A2,A3
  MOVEA.l defaulttype,A2
  CMP.w #".",D0 : BEQ.w 'clapton
  CMP.w #"$",D0 : BNE.w 'usedef
    LEA newtype_string,A2
    BSR.w get1bytemain
    BRA.w 'usedef
 'clapton
    BSR.w getparameter2
    LEA newtypebase,A2
    BSR.w findtype : BNE.w notypeerr
 'usedef

  CMPA.l #newtype_byte,A2 :  BEQ.w 'byte
    MOVE.w varmode,D1       :  BNE.w 'pit
      ADDQ.w #1,globalvarpointer
   'pit
    BCLR #$0,globalvarpointer+1
 'byte
  MOVE.l A2,$A(A3)           ;set type
  MOVE.w flagmask,$6(A3)                                  ;??????????
  MOVEQ.l #$04,D1
  BTST #$0,flagmask+1 :  BNE.w 'skip3
  BTST #$1,flagmask+1 :  BNE.w 'skip3
  CMPI.l #$100,4(A2)  :  BCC.w 'skip3
    MOVE.w 8(A2),D1
 'skip3

  TST.w varmode : BEQ.w fvaradd_pit2
    NEG.w D1
    ADD.w D1,globalvarpointer
    MOVE.w globalvarpointer,$4(A3)
    RTS
  fvaradd_pit2:
  MOVE.w globalvarpointer,$4(A3)
  ADD.w D1,globalvarpointer
RTS


; new >
claptonb:                     ; is a copy of fvaradd 'clapton
   BSR.w getparameter2
   LEA newtypebase,A2
   BSR.w findtype :  BNE.w notypeerr

 'usedef
  CMPA.l #newtype_byte,A2 :   BEQ.w 'byte
    MOVE.w varmode,D1       :   BNE.w 'pit
      ADDQ.w #1,globalvarpointer
   'pit
    BCLR #$0,globalvarpointer+1
 'byte
  MOVE.l A2,$A(A3)              ;set type
  MOVE.w flagmask,$6(A3)                                  ;??????????
  ;MOVE.w #0,$6(A3)                                         ;??????????
  MOVEQ.l #$04,D1
  BTST #$0,flagmask+1 :  BNE.w 'skip3
  BTST #$1,flagmask+1 :  BNE.w 'skip3
  CMPI.l #$100,4(A2)  :  BCC.w 'skip3
    MOVE.w 8(A2),D1
 'skip3
  TST.w varmode
BRA.w fvaradd_pit2

;  NEG.w D1                                                 ;??looks like dead code??
;  ADD.w D1,globalvarpointer
;  MOVE.w globalvarpointer,$4(A3)
;RTS
; < new


fvarlocal:
  LEA firstglob,A2
  BSR.w findvariable2

 'more
    BNE.w 'hendrix
    
    MOVE.b flagmask+1,D1
    MOVE.b $7(A2),D3
    EOR.b D3,D1 : BEQ.w fvarfound
    BSR.w findlab
  BRA.w 'more
 'hendrix

  MOVE.w #$FFFF,varmode           ; was -1
  MOVE.w globalvarpointer,-(A7)
  MOVE.w locvaroff,globalvarpointer
  LEA firstlocal,A2
  ; new >
  MOVE.b #1,newvariable
  ; < new
   BSR.w fvarback
  ; new >
  CLR.b newvariable
  ; < new
  MOVE.w globalvarpointer,locvaroff
  MOVE.w (A7)+,globalvarpointer
RTS


fvarfound:
  MOVEA.l A2,A3
  ;--
  ;-- var found, establish if type is correct!
  ;--
  CMP.w #".",D0 : BEQ.w 'skipsh
    CMP.w #"$",D0 : BNE.w 'skip4
      
      CMPI.l #newtype_string,$A(A3) : BNE.w rongtypeerr
      BSR.w get1bytemain
      BRA.w 'skip4

 'skipsh
    
    BSR.w getparameter2
    LEA newtypebase,A2
    BSR.w findtype : BNE.w notypeerr
    CMPA.l $A(A3),A2 : BNE.w rongtypeerr

 'skip4
    BTST #$0,flagmask+1 : BEQ.w 'skipz
      BTST #$0,$7(A3) : BEQ.w pointerr
 'skipz
  MOVEA.l $A(A3),A2
RTS


addd0a0:
  TST.l D3 : BEQ.w 'done2a                                ;newtype >32kb  .w to .l
  ; new >
  MOVE.l destpointer,loada
  ;TST.b optimize_integer
  ;BNE 'done3a
  BRA 'done3a
                                                           ;??looks like dead code now??
  ; < new
  CMP.w #$9,D3 : BCC.w 'done3a                             ;_addq_arrays
  ; new >
  MOVE.w d3,arrayoffset
  ; < new
  ANDI.w #$7,D3
  LSL.w #8,D3
  LSL.w #1,D3
  ANDI.w #$F1FF,addqa0
  OR.w D3,addqa0
  MOVE.w addqa0,D1
  BRA.w writeword

 'done3a
  ; new >
  CMP.l #$7fff,d3 : BGT longoffset                         ;>32kb newtypes

    ; < new
    MOVE.w D3,leaa0a0+2
    ; new >
    MOVE.w d3,arrayoffset
    ; < new
    MOVE.l leaa0a0,D1                                       ; LEA $0000(A2),A2
    BSR.w writelong

    'done2a
    RTS

  ; new >
  longoffset
    MOVE.w #$d5fc,d1                                       ; add ??
    BSR writeword
    MOVE.l d3,d1
    BSR.w writelong
RTS
; < new

zarrchk:  Dc.w $b0ad,0000                                          ;CMP.l $0(A5),D0    ;nooptimize

arrchk2:  BCS.w arrchk3
          JSR $20000                                               ;jsr 0
arrchk3:



makeamul:
  ;
makelmul:                                                   ;make long multiply for array calc
  ;
  ; new >
  TST.b optimize_integer : BEQ 'l1
    MOVEQ #0,d1                                             ;faster arrays
    MOVE.w regnum,d2
    MOVE.w d2,d1
    LSL.w #8,d1
    LSL.w #4,d1
    ADD.w d2,d1
    OR.l #$4c2d0000,d1
    TST.w varmode : BEQ 'l1a
      BCLR #16,d1
   'l1a
    BSR writelong
    MOVE.w $4(A7),D1
    BSR.w writeword
    MOVE.w regnum,D1
    SUBQ.w #1,D1
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$D080,D1
    OR.w regnum,D1
    BSR.w writeword
    RTS
 'l1
  ; < new
  MOVE.w regnum,D2
  MOVE.w arrmul1(PC),D1
  OR.w D2,D1
  SUBQ.w #1,D1
  BSR.w writeword
  MOVE.w arrmul2(PC),D1
  OR.w D2,D1
  MOVE.w D2,D3
  SUBQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
  BSR.w writeword
  MOVE.w arrmul3(PC),D1
  MOVE.w D2,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
  BSR.w pokewda5s
  MOVE.w $4(A7),D1         ; was 4+0
  ADDQ.w #2,D1
  BSR.w writeword
  ;
  MOVE.w arrmul4(PC),D1
  MOVE.w D2,D3
  SUBQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w pokewda5s
  MOVE.w $4(A7),D1       ; was 4+0
   BSR.w writeword
  ;
  MOVE.w arrmul5(PC),D1
  OR.w D2,D1
  SUBQ.w #1,D1
   BSR.w writeword
  MOVE.w arrmul6(PC),D1
  OR.w D2,D1
  SUBQ.w #1,D1
   BSR.w writeword
  MOVE.w arrmul7(PC),D1
  OR.w D2,D1
  SUBQ.w #1,D1
  MOVE.w D2,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w writeword
  MOVE.w arrmul8(PC),D1
  MOVE.w D2,D3
  SUBQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w writeword
  ;
  MOVE.w regnum,D1
  SUBQ.w #1,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$D080,D1
  OR.w regnum,D1
BRA.w writeword


    ;code for doing long array calculations.
    ;d1.w=this subscript, d0.l=array offset
    ;
    ;do a x(a5).l * d1 + d0.l
    ;
arrmul1:   MOVE.l d0,-(a7)                                ;write array access
arrmul2:   MOVE  d0,d0
arrmul3:   MULU 0(a5),d0                                  ;mulu   x+2(a5),d1  ;lo*lo
arrmul4:   MULU 0(a5),d0                                  ;mulu   x(a5),d0    ;hi*lo
;
arrmul5:   SWAP d0
arrmul6:   CLR d0
arrmul7:   ADD.l d0,d0
arrmul8:   MOVE.l (a7)+,d0

;arraynew   Dc.l $4c150000                                  ; MULU.l 0(a5),d0  ;new arrayaccess

;------                                                  ;disassembled code begin
listcode1:  Dc.w $246D,$0000                             ;MOVEA.L $0000(A5),A2      ;pointer to start of array data
listcode2:  Dc.w $246A,$FFE0                             ;MOVEA.L -$0020(A2),A2     ;pointer to current
listarfix:  Dc.w $504A                                   ;ADDQ.W  #8,A2
;------                                                  ;disassembled code end

Even
calcvar:
    ;used to optimize this...no more!
    ;
;calcvar2:                                                 ;??looks like label not used??
    ;use a3 = var, a2 = type, flagmask = flags.
    ;
    ;if bit 15 of d2 then code has been generated for
    ;address of thing in a2. else d3=offset from a5
    ;for simple variable.
    ;
    ;d2 & ff=type. 0=struct address
    ;
    ;bit 14 of d2=1 if result is a pointer
    ;
  CLR.l lastoffset_org
  BTST #$1,$7(A3) : BEQ.w 'notarr

  MOVE.w notshared,D1 : BNE.w noarrerr

  BSR.w get1bytemain
  CMP.w #")",D0 : BNE.w 'notalist
    BTST #$0,$6(A3) : BEQ.w nolisterr

    MOVE.w $4(A3),listcode1+2
    MOVE.l listcode1(PC),D1
    BSR.w pokela5s
    MOVE.l listcode2(PC),D1 : BSR.w writelong

    TST.b debugmode : BEQ.w 'nolrerr
      ;
      ;a2=0 error check
      ;
      MOVE.l A2,-(A7)
      MOVE.w #$C315,D1 : BSR.w Atokejsr           ;runerrls: currentchk
      MOVEA.l (A7)+,A2
   'nolrerr

    MOVE.w listarfix(PC),D1                                 ;addq #8,a2
    ;skip node.
    BSR.w writeword
    BRA.w 'normalar
 
 'listoff: Ds.w 1

 'notalist
  CLR.w 'listoff
  BTST #$0,$6(A3) : BEQ.w 'knop
    MOVE.w #$0008,'listoff                            ;adjust size of one element if list.
 'knop
  MOVEM.l A2-A3,-(A7)
  MOVE.w varmode,-(A7)
  MOVE.w $8(A3),-(A7)                                       ;number of dims
  MOVE.w $4(A3),-(A7)                                       ;varoff
  MOVE.l A2,-(A7)
  MOVE.w flagmask,-(A7)
   ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  BSR.w arreval
  MOVE.w (A7)+,flagmask
  MOVE.w $8(A7),varmode

  TST.b debugmode : BEQ.w 'noszchk
   ;BSR.w arrszchk                                        ;skip for dim >65536
 'noszchk

  MOVEA.l (A7)+,A2
  MOVEQ.l #$04,D1
  BTST #$0,flagmask+1                                      ;pointer?
  BNE.b 'domul                                             ;yes, then use 4 byte mul...
    MOVE.w 8(A2),D1
 'domul
  ADD.w 'listoff(PC),D1
  BSR.w muld1
  ADDQ.w #1,regnum

 'arloop
    ADDQ.w #4,(A7)
    TST.w $4(A7) : BEQ.w 'isglob
      SUBQ.w #8,(A7)                                         ;range check local array
   'isglob

    TST.b debugmode : BEQ.w 'noer1
      MOVE.w regnum,D1
      SUBQ.w #1,D1
      LSL.w #8,D1
      LSL.w #1,D1
      OR.w zarrchk(PC),D1
      BSR.w pokewda5s                                        ; "CMP.l x(a5),D regat"

      MOVE.w (A7),D1 : BSR.w writeword                       

      MOVE.l arrchk2(PC),D1 : BSR.w writelong                ; "BCS.w <skip next JSR>"

      MOVE.w #$C309,D1 : BSR.w Atokejsr                      ; (runerrslib, arrerr)
   'noer1

    SUBQ.w #1,$2(A7) : BEQ.w 'ardone

    CMP.w #",",D0 : BNE.w syntaxerr
    
    TST.b optimize_integer : BNE 'l1
        BSR.w arrevalchk
        BRA 'l2
    'l1
        BSR arreval
    'l2
    MOVE.w $4(A7),varmode
    BSR.w makeamul
  BRA.w 'arloop
 'ardone

  CMP.w #")",D0 : BNE.w syntaxerr
  SUBQ.w #1,regnum
  ADDQ.w #6,A7
  MOVEM.l (A7)+,A2-A3
  MOVE.w $4(A3),movea5a0+2
  MOVE.l movea5a0,D1
  BSR.w pokela5s

  MOVE.w regnum,D1
  ORI.w #$D5C0,D1                                          ;ADD.l Dr,a2
  BSR.w writeword

  BTST #$0,$6(A3) : BEQ.w 'normalar
    ;
    ;addq #8,a2 to skip node.
    ;
    MOVE.w listarfix(PC),D1
    BSR.w writeword
 'normalar

  BSR.w get1bytemain
  ;
  ;this shit added lately - after the major fucking crash!
  ;
  BTST #$0,$7(A3) : BEQ.w 'noppnt
    CMP.w #"\",D0 :  BNE.w 'pmskip
      MOVE.w 'pfix(PC),D1
      BSR.w writeword
 'noppnt
    MOVE.w #$8000,D2
    BRA.w 'loopml
 'pmskip
  MOVE.w #$C000,D2
  BRA.w 'loopml

;------                                                  ;disassembled code begin
 'pfix:   Dc.w $2452                                     ;MOVEA.L (A2),A2
;------                                                  ;disassembled code end

 Even
 'notarr
  CMP.w #"(",D0      : BEQ.w noarrerr

  CMPI.l #$100,4(A2) : BCS.w 'simpvar
  BTST #$0,$7(A3) : BEQ.w 'notap
    ;
    ;it's a pointer - is it a simple one?
    ;
  CMP.w #"\",D0       : BEQ.w 'notap
    MOVEQ.l #$00,D2
    BRA.w 'simpvar2
 'notap
  MOVE.w #$8000,D2
  MOVE.w $4(A3),movea5a0+2
  MOVE.l movea5a0,D1
  BSR.w pokela5s                                         ;move.l x(a5),a2

  TST.b debugmode : BEQ.w 'skip                          ;check read pointer <=0
    MOVE.w #$c320,D1 : JSR Atokejsr                      ;runerrlib, checkpointer
 'skip       
 'loopml
  MOVEQ.l #$00,D3

 'loop0
  CMP.w #"\",D0 : BNE.w 'done
  CMPI.l #$100,4(A2) : BCS.w rongtypeerr

  MOVE.w D2,-(A7)
   BSR.w getparameter2
   BEQ.w syntaxerr
  ADDQ.w #4,A2
   BSR.w findvariable2
   BNE.w noofferr
  MOVE.w (A7)+,D2
  MOVEA.l A2,A3                                             ;pointer to offset
  MOVEA.l $A(A3),A2                                         ;pointer to type
  MOVEQ #0,d1
  MOVE.w 4(a3),d1
  ADD.l d1,d3
  ;ADD.w $4(A3),D3                                          ;offset for newtype
  MOVE.l A3,lastoffset_org
  
  CMP.w #"[",D0 : BNE.w 'realdone
   
  BTST #$1,$7(A3) : BEQ.w rongtypeerr                  ;a array [] in newtype is found

  BSR.w addd0a0
  MOVEM.l A2-A3,-(A7)
  MOVE.w varmode,-(A7)
  MOVE.l lastoffset_org,-(A7)
  MOVE.w pusha2,D1
  BSR.w writeword
  MOVEQ.l #$03,D2                                          ;was 2 >32kb types
  MOVE.l destpointer,deststore
  MOVE.l leftsidetype,-(a7)
  MOVE.l rightsidetype,-(a7)

  MOVE.w leftsideflagmask,-(a7)
  MOVE.w rightsideflagmask,-(a7)
  CLR.l rightsidetype
  CLR.l leftsidetype
  CLR.w leftsideflagmask
  CLR.w rightsideflagmask
  BSR.w eval
  MOVE.w (a7)+,rightsideflagmask
  MOVE.w (a7)+,leftsideflagmask
  MOVE.l (a7)+,rightsidetype
  MOVE.l (a7)+,leftsidetype

  CMP.w #"]",D0 :  BNE.w syntaxerr

  TST.b optimize_integer :   BEQ 'loop0_l10                ;a2,-(a7) array
    CNIF #optibreak
      ILLEGAL
    CEND
    MOVE.l destpointer,d1
    SUB.l deststore,d1
    CMP.l #4,d1
    BNE 'loop0_l10
    MOVE.l destpointer,a4
    MOVE.l -4(a4),-6(a4)
    SUBQ.l #2,destpointer
    CLR.l imm_addr
    CLR.l load_var_addr
    BRA 'loop0_l20
 'loop0_l10
    MOVE.w pulla2,D1
    BSR.w writeword
 'loop0_l20

  MOVE.l (A7)+,lastoffset_org
  MOVE.w (A7)+,varmode
  MOVEM.l (A7)+,A2-A3
  ;
  ;[] ***** error checking here! *****
  ;
  ;8(a3) = how many we can handle. special case for 0!
  ;
  TST.w debugmode : BEQ.b 'nobchk
    MOVE.w $8(A3),D1 : BEQ.b 'nobchk                 ;no [0] checks!
      ;
      ;ok, check regat<8(a3)
      ;
      MOVE.w D1,brchkcode+2
      MOVE.w regnum,D1
      LSL.w #8,D1
      LSL.w #1,D1
      OR.w brchkcode0(PC),D1
      MOVE.w D1,brchkcode
      MOVE.l brchkcode(PC),D1    : BSR.w writelong
      MOVE.l brchkcode+4(PC),D1  : BSR.w writelong
      MOVE.w brchkcode+8(PC),D1  : BSR.w writeword
 'nobchk
 
  MOVEQ.l #$04,D1

  BTST #$0,$7(A3) : BNE.w 'dothemul
    MOVE.w 8(A2),D1
 'dothemul
  BSR.w muld1

  MOVE.w addrega2,D1                                      ; ADDA.W  D0,A2
  OR.w regnum,D1
  OR.w #$100,d1                                           ; >32kb types
  BSR.w writeword

  BSR.w get1bytemain
  MOVEQ.l #$00,D3
  MOVE.w #$8000,D2
 'realdone
  BTST #$0,$7(A3) : BNE.w 'pointer
    BRA.w 'loop0
 'pointer
  CMP.w #"\",D0 : BNE.w 'done3
  TST.w D3 : BNE.w 'pskip
    MOVE.w movea0,D1
    BSR.w writeword
    BRA.w 'pmore
 'pskip
    MOVE.w D3,movea0a0+2
    MOVE.l movea0a0,D1
    BSR.w writelong
 'pmore

  BTST #$2,$7(A3) :  BEQ.w 'loopml
  MOVE.l adda0a0,D1
  BSR.w writelong
  BRA.w 'loopml

 'done3
  BSET #$E,D2
  BTST #$2,$7(A3) : BNE.w 'done
    BSET #$D,D2
 'done

  CMPI.l #$100,4(A2) : BCC.w 'done2
    MOVE.b $7(A2),D2
 'done2
  BRA.w addd0a0

 'simpvar
  MOVE.w $6(A2),D2

 'simpvar2
  MOVE.w $4(A3),D3
  BTST #$0,$7(A3) : BEQ.w 'nopoint
    BSET #$E,D2
 'nopoint
RTS

;offset out of range error
;------                             ; disassembled code begin
brchkcode0:  Dc.w $B07C,$0000       ; CMP.W   #$0000,D0
brchkcode:   Dc.w $B07C,$0000       ; CMP.W   #$0000,D0
             Dc.w $6504             ; BCS.B   brchkcode_ok
             Dc.w $7002             ; MOVEQ   #$02,D0
             Dc.w #opcode_TRAP0     ; TRAP    #00
brchkcode_ok:
;------                             ;disassembled code end


;-----------Poking to Object code stuff-------------------;

pokewda5s:
  TST.w varmode : BEQ.w writeword
  
  BCLR #$0,D1
BRA.w writeword

pokewda5d:                                                 ;??looks like not used??
  TST.w varmode : BEQ.w writeword
  
  BCLR #$9,D1
BRA.w writeword

pokela5d:
  TST.w proceduremode : BEQ.w writelong
  
  BCLR #$19,D1
BRA.w writelong

pokela5s:
  TST.w varmode : BEQ.w writelong
    BCLR #$10,D1

.writelong:                                                ;pokel org source
;-- write 4 bytes in D1 to destpointer and increase

;  SWAP d1                                                ;code org source
;  BSR writeword
;poke1c:
;  SWAP d1
  ; new >
  ADDQ.l #1,destpointer                                   ; this is a copy of the writewordcode
  BCLR #$0,destpointer+3
  MOVEA.l destpointer,A4

  CMPA.l destbufferend,A4 : BCC.w 'overa
 
  MOVE.l D1,(A4)+
 'msa
    MOVE.l A4,destpointer
    CMPA.l bigpc(PC),A4 : BHI.w 'nbpa
      RTS
   'nbpa                                                     ; copied from writeword code  tomsmart1

    TST.w cfetchmode : BNE.w 'nbp2a                          ; to complete the subroutine
      MOVE.l A4,bigpc                                        ;
   'nbp2a
    RTS
 'overa

  MOVE.w #$FFFF,dontwrite_nomemleft                                  ;#-1 org source
  CLR.b optimize_integer
  CLR.b optimize_fpu
  CLR.b iee                                                ; in writeword this is #2
  ADDQ.w #4,A4
BRA.w 'msa
  ; < new


.writeinstruction:                                         ; used in old code same as writeword
.writeword:                                              ;pokewd org source  ;poke d1.w into pc - not an opcode
  ADDQ.l #1,destpointer
  BCLR #$0,destpointer+3
  MOVEA.l destpointer,A4
  CMPA.l destbufferend,A4 :  BCC.w 'over

  MOVE.w D1,(A4)+

 'ms
  MOVE.l A4,destpointer
  
  CMPA.l bigpc(PC),A4 : BHI.w 'nbp
    RTS
 'nbp
  
  TST.w cfetchmode : BNE.w 'nbp2
    MOVE.l A4,bigpc
 'nbp2
  RTS

 'over
  MOVE.w #$FFFF,dontwrite_nomemleft                                  ;#-1 org source
  ADDQ.w #2,A4
  CLR.b optimize_integer
  CLR.b optimize_fpu
  CLR.b iee
BRA.w 'ms


writebyte:                                                 ;pokebyte org source
  MOVEA.l destpointer,A4
  CMPA.l destbufferend,A4 : BCC.w 'over

  MOVE.b D1,(A4)+

 'ms
  MOVE.l A4,destpointer
  CMPA.l bigpc(PC),A4 : BHI.w 'nbp
    RTS
 'nbp

  TST.w cfetchmode : BNE.w 'nbp2
    MOVE.l A4,bigpc
 'nbp2
 RTS

 'over
  MOVE.w #-1,dontwrite_nomemleft
  ADDQ.w #1,A4
  CLR.b optimize_integer
  CLR.b optimize_fpu
  CLR.b iee
BRA.w 'ms


bigpc:   Ds.l 1


.pokecode:
  ;-- a0 = startaddress of code to poke,
  ;-- a1 = endaddress
  MOVE.w (A0)+,D1
  BSR.w writeword
 'loop
    CMPA.l A1,A0 : BCC.w 'done

    MOVE.w (A0)+,D1
    BSR.w writeword
  BRA.w 'loop
 'done
RTS


.pokecode2:
  ;-- a0 = startaddress of code to poke,
  ;-- a1 = endaddress
  MOVE.w (A0)+,D1
  BSR.w writeword
  CMPA.l A1,A0 : BCS.w pokecode2  
RTS

;-----------End of poking to Object code------------------;


convert_byte_to_word:  ; was bytetoword                                              ;byte to word
  ; new
  TST.b iniffcommand :  BEQ 'l1
    MOVE.w #$4880,D1                            ; EXT.W
    OR.w regnum,D1
    BSR writeword
 'l1
 ;  < new
RTS

  ;
  ;Below should ALWAYS be done when something is fetched
  ;

convert_byte_to_long:   ; was bytetolong
  BSR.w convert_byte_to_word

convert_word_to_long:   ; was wordtolong                                             ;word to long word_to_fpu
  ; new >
  TST.b iee : BEQ 'old
    CMP.b #5,d2 : BEQ wtof
 'old
  ;< new
  MOVE.w #$48C0,D1                              ; EXT.L
  OR.w regnum,D1
BRA.w writeword

; new >
wtof
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2005000,d1
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
BRA writelong
; < new

convert_byte_to_quick:
  BSR.w convert_byte_to_word

convert_word_to_quick:
  MOVE.w #$4840,D1
  OR.w regnum,D1
  BSR.w writeword
  MOVE.w #$4240,D1
  OR.w regnum,D1
BRA.w writeword

; new >
convert_long2float                                                      ;long to fpu
  CMP.w #$ffdc,d1 : BNE 'negfpu  
    MOVEQ #0,d0
    MOVE.w regnum,d0
    ASL.l #7,d0
    MOVE.l #$f2004000,d1                                     ; F203 4000 fmove.l d3, fp0
    OR.l d0,d1
    ASL.l #1,d0
    ASL.l #8,d0
    OR.l d0,d1
    BRA writelong
 'negfpu
  MOVEQ #0,d1
  MOVE.w regnum,d1                                         ;fpu neg
  ASL.l #7,d1
  OR.l #$f200001a,d1
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #8,d0
  ASL.l #2,d0
  OR.l d0,d1
  MOVE.l (a7)+,d0
BRA writelong
; < new


convert_byte_to_float:  ; was bytetofloat
   ; new >
   TST.b iee : BNE wtof

   ; < new
   BSR.w convert_byte_to_long

bytetof2:
   MOVE.w #$FFDC,D1                                       ; floatfloor ?

fdo2:
   ; new >
   TST.b iee : BNE convert_long2float
   ; < new

   MOVE.w D1,libjsr+2
   BSR.w savereg
  MOVE.l D4,D1
   BSR.w pokemovem
  MOVE.w #$C900,D1 : BSR.w Atokejsr      ; #getffpbase
   BSR.w PutRegXToD0
  MOVE.l libjsr,D1 : BSR.w writelong
   BSR.w PutD0ToRegX
  MOVE.l D5,D1
BRA.w pokemovem

RTS ; dead old code

convert_word_to_byte:  ; was wordtobyte
  MOVE.w #$C317,D1     ;#wtobover
  ; new >
  CNIF #assign_fulltypecheck
    TST.b typecheck : BEQ 'l1
      TST.b notypecheck : BNE 'l1
        TST.l lasttoken : BEQ typeerror
   'l1
  CEND
  ; < new

overchk:
  ;d1=overflow check routine.
  TST.b debugmode : BEQ.w 'skip
    TST.w set_overflowcheck : BEQ.w 'skip                   ;;*** was 7! overflow checking?
    ;
    TST.w cfetchmode : BNE.w 'skip
    ;
    TST.w regnum :  BEQ.w 'isok
      MOVE.w D1,-(A7)
      MOVE.w 'code1(PC),D1
      BSR.w writeword
      MOVE.w regnum,D1
      OR.w 'code3(PC),D1
      BSR.w writeword
      MOVE.w (A7)+,D1
      BSR.w 'isok
      MOVE.w 'code2(PC),D1
      BRA.w writeword
   'isok

   MOVEM.l D0-D7/A0-A6,-(A7)
   BSR.w Atokejsr
   MOVEM.l (A7)+,D0-D7/A0-A6
 'skip
 RTS

 'code1
  MOVE.l D0,-(A7)

 'code2
  MOVE.l (A7)+,D0

 'code3
  MOVE.l D0,D0



convert_word_to_float:  ; was wordtofloat
  BSR.w convert_word_to_long

  TST.b iee : BEQ 'old
    CMP.b #5,d2 : BNE 'old
      RTS
 'old
BRA.w bytetof2


convert_long_to_byte:   ; was longtobyte
  MOVE.w #$C316,D1      ; #ltobover

  CNIF #assign_fulltypecheck
    TST.b typecheck : BEQ 'l1
      TST.b peekaddrsize : BNE 'l1
        TST.b notypecheck : BNE 'l1
          TST.l lasttoken : BEQ typeerror
   'l1
  CEND
BRA.w overchk


convert_long_to_word:   ; was longtoword
  MOVE.w #$C318,D1      ; #ltowover,

  CNIF #assign_fulltypecheck
    TST.b typecheck : BEQ 'l1
      TST.b peekaddrsize : BNE 'l1
        TST.b notypecheck :  BNE 'l1
          TST.l lasttoken : BEQ typeerror
   'l1
  CEND
BRA.w overchk


convert_long_to_quick:  ; was longtoquick
  MOVE.w #$C318,D1      ;#ltowover,

  CNIF #assign_fulltypecheck
    TST.b typecheck : BEQ 'l1
      TST.b notypecheck : BNE 'l1
        TST.l lasttoken : BEQ typeerror
   'l1
  CEND
  BSR.w overchk
BRA.w convert_word_to_quick


convert_long_to_float:   ; was longtofloat
BRA.w bytetof2


convert_quick_to_byte:     ; was quicktobyte
  MOVE.w #$C319,D1         ; #qtobover,

  CNIF #assign_fulltypecheck
    TST.b typecheck : BEQ 'l1
      TST.b notypecheck : BNE 'l1
      TST.l lasttoken : BEQ typeerror
   'l1
  CEND

  BSR.w overchk

quicktob2:
  MOVE.w #$4240,D1
  OR.w regnum,D1
  BSR.w writeword
  MOVE.w #$4840,D1
  OR.w regnum,D1
BRA.w writeword


convert_quick_to_word:     ;was quicktoword
BRA.w quicktob2


convert_quick_to_long:     ; was quicktolong
  BSR.w quicktob2
BRA.w convert_word_to_long


convert_quick_to_float:     ; was quicktofloat;
  TST.b iee : BNE qtof

  MOVE.w #$D300,D1       ; #qutofl,

qtof2:
  MOVE.w D1,-(A7)
   BSR.w savereg
  MOVE.l D4,D1
   BSR.w pokemovem
  ;
   BSR.w PutRegXToD0
  MOVE.w (A7)+,D1
   BSR.w Atokejsr
  ;
   BSR.w PutD0ToRegX
  MOVE.l D5,D1
BRA.w pokemovem

qtof:                                                      ;quick to fpu
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2004000,d1                                     ; F203 4000 fmove.l d3, fp0
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
  BSR writelong
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f23c4423,d1                                     ;fmul.s #1/65536,fpreg
  OR.w d0,d1
  BSR writelong
  MOVE.l #$37800000,d1
  BSR writelong
RTS


convert_float_to_byte:      ; was floattobyte
  CNIF #assign_fulltypecheck
    TST.b typecheck : BEQ 'l1
      TST.b notypecheck : BNE 'l1
        TST.l lasttoken : BEQ typeerror
    'l1
  CEND
  TST.b iee : BNE ftol

  MOVE.w #$C31A,D1       ; #ftobover
  BSR.w overchk
  ;
  BSR.w floattolong2
BRA.w convert_long_to_byte


convert_float_to_word:    ; was floattoword
  CNIF #assign_fulltypecheck
    TST.b typecheck : BEQ 'l1
      TST.b notypecheck : BNE 'l1
      TST.l lasttoken : BEQ typeerror
    'l1
  CEND
  TST.b iee : BNE ftol

  MOVE.w #$C31B,D1         ; #ftowover
  BSR.w overchk
  ;
  BSR.w floattolong2
BRA.w convert_long_to_word


convert_float_to_long:       ; was floattolong ;
  TST.b iee : BNE ftol

  MOVE.w #$C31C,D1     ; #ftolover,
  BSR.w overchk

floattolong2:
  MOVE.w #$FFE2,D1     ; #-30,
BRA.w fdo2


ftol:                                                      ;fpu to long
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2006000,d1
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
  MOVE.l (a7)+,d0
BRA writelong


ftoq:                                                       ;fpu to quick
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
  MOVE.l #$f23c4023,d1
  MOVE.w regnum,d0
  ASL.l #7,d0
  OR.l d0,d1
  BSR writelong
  MOVE.l #$00010000,d1
  BSR writelong
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2006000,d1
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
  BSR writelong
  MOVE.l (a7)+,d0
RTS



convert_float_to_quick:   ; was floattoquick;
  ;do my own routine here for float to quick conversion
  ;
  ; new >
  TST.b iee : BNE ftoq

  MOVE.w #$C31B,D1    ; #ftowover,
  BSR.w overchk
  ;
  MOVE.w #$D301,D1    ; #fltoqu,
BRA.w qtof2


string_to_long:
  ; allowed as calling parameter for blitzlibs and functions
  TST.b blitzparloop : BNE 'l1
    TST.b funcparloop : BNE 'l1
      BRA error_convert_types
 'l1

  CMP.b #2,optistring : BEQ JLrts
  ; < new
  MOVE.w stol,D1
  BSR.w writeword
  ; new >
  CMPI.w #$2,sbgot : BCS.w sbtolong                     ; was BRA

  MOVE.w ceos(PC),D1                 ; begin copy of sbtolong
  BSR.w writeword
  ;
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  CMPI.w #$2,sbgot : BCS.w sbtolong_skip2

  MOVE.w a2offset,D3
  SUB.w thisstuse,D3
  CMP.w #$6,D3 : BNE.w 'lenonly
    OR.w movestst2,D1
    BSR.w writeword
    LEA movestst2+2,A0
    LEA movestst2f,A1
    BRA.w pokecode2
 'lenonly                                                ;OS call 2 strings fix
  OR.w movea7dn,D1
  BSR.w writeword
  MOVE.l #0,D1
BRA.w writeword                      ; end of copy
  ; < new


convtypef:
  ;as below, but regat+1 should be saved!
  ;
  ADDQ.w #1,fuckpos
  BSR.w writeconvertcode
  SUBQ.w #1,fuckpos
  ; new >
JLrts
  ;> new
RTS


.writeconvertcode:                                          ;convtype org source   ;convert type d3 to d2
  MOVE.w D3,D1
  ; new >
  CMP.w #7,d1 : BLE 'ok
    JMP errorinternalconvert
 'ok
  ; < new
  SUBQ.w #1,D1
  MULU #$7,D1
  ADD.w D2,D1
  SUBQ.w #1,D1
  LSL.w #2,D1
  LEA convtable,A0
  MOVE.l $0(A0,D1.W),D1 : BEQ.w 'skip
    MOVEA.l D1,A0
    ; new >
    CMP.b #$ff,d3 : BEQ 'skip
    ; < new
      JMP (A0)
 'skip
RTS


usedfrom:  Ds.l 1


.getparameter:                                             ; get vname org source
                                                          ; transfer chars to namebuff. set flagmask according
                                                          ; to array/pointer etc status
  CMP.w #"\",D0 : BNE.w 'skip0
    ; new >
    CMP.b #"\",(a5) : BNE 'first
      MOVE.l A5,usedfrom
      LEA path2,A5
      BRA 'g1
   'first
      ; < new
      SUBQ.w #1,A5
      MOVE.l A5,usedfrom
      LEA usedpath,A5                                          ;read path
      ; new >
   'g1
    ; < new
    BSR.w get1bytemain
 'skip0
  CLR.w flagmask

  CMP.w #"*",D0 : BNE.w 'skip
  
  MOVE.w #$0001,flagmask
 'more2
   BSR.w getparameter2

 'more
  BEQ.w syntaxerr
  CMP.w #"(",D0 : BEQ.w 'setmask
  CMP.w #".",D0 : BEQ.w 'morem
  CMP.w #"$",D0 : BNE.w 'done
   
    ORI.w #$8,flagmask
    BSR.w storeloc
    BSR.w get1bytemain
    BRA.w 'morez


  'morem
    BSR.w storeloc
    MOVE.w D2,-(A7)
    LEA namebuffer2,A1
    BSR.w makename3 : BEQ.w syntaxerr
    MOVE.w (A7)+,D2

  'morez
    MOVE.w D0,D1
    BSR.w resloc
    CMP.w #"(",D1 : BNE.w 'done
    
 'setmask
  ORI.w #$2,flagmask

 'done
  RTS

 'skip
  CMP.w #$40,D0 :  BNE.w 'skip2          ;'@'
 
    MOVE.w #$0005,flagmask
    BRA.w 'more2
 'skip2
  BSR.w makename2
BRA.w 'more


dopusha3:
  MOVE.w #$FED3,D1          ; #65235 (#strings1lib)
   BSR.w uselib
  LEA pusha3,A0
  LEA pusha3f,A1
BRA.w pokecode


dopulla3:
  MOVE.w #$FED3,D1          ; #65235 (#strings1lib)
   BSR.w uselib
  LEA pulla3,A0
  LEA pulla3f,A1
BRA.w pokecode


;------                                                  ;disassembled code begin
ceos:   Dc.b $42,$1B                                       ;CLR.B   (A3)+             ;*!
;------                                                  ;disassembled code end

Even
sbtolong:                                                 ;make sbase into a long
  ; new >
  CMP.b #2,optistring : BEQ 'l10
    ; < new
    MOVE.w ceos(PC),D1 : BSR.w writeword                   ;clr.b (a3)
    ; new >
 'l10
  ; new <
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  CMPI.w #$2,sbgot : BCS.w sbtolong_skip2

  MOVE.w a2offset,D3                                       ;stackuse,d3 org source
  SUB.w thisstuse,D3
  CMP.w #$6,D3 : BNE.w 'lenonly
    OR.w movestst2,D1
    BSR.w writeword
    LEA movestst2+2,A0
    LEA movestst2f,A1
    BRA.w pokecode2
 'lenonly
  OR.w movea7dn,D1
  BSR.w writeword
  MOVE.l movea7dn+2,D1
  ; new >
;  CNIF #more6string
;    MOVE.w #$0008,d1
;    BSR writeword
;    MOVE.w #$2f6f,d1                                       ;native move.l 4(a7),8(a7)
;    BSR writeword    ; was writeinstruction  tomsmart1
;    MOVE.l #$00040008,d1
;    BSR writelong
;    MOVE.w #$588f,d1                                       ;native addq.l #4,a7
;    BSR writeword
;  RTS
;  CEND
  BSR writelong
  ; new >
 CNIF #more6string
   CMP.w #6,regnum : BEQ 'l1
   TST.w stackpar : BNE 'l1
   TST.b funcparloop : BEQ 'l1
     MOVE.l #$48780000,d1
     BSR writelong
  'l1
 CEND
 RTS
  ; < new

sbtolong_skip2:        ;was 'skip
  ; new >
  CNIF #more6string
     MOVE.l d1,-(a7)
     CMP.w #6,regnum : BEQ 'l1
     TST.w stackpar : BNE 'l1
     TST.b funcparloop : BEQ 'l1
       MOVE.l #$48780000,d1
       BSR writelong
    'l1
     MOVE.l (a7)+,d1
  CEND
  ; < new
   OR.w movestdn,D1
  BSR.w writeword
  MOVE.w #$FED3,D1        ;#65235 (#strings1lib)
  BSR.w uselib
  MOVE.w $A(A1),D1
BRA.w writeword


unknown:    Ds.w 1

;------                                              ;-- disassembled code begin
somecode:   Dc.w $0C80,$0001,$0000                   ; CMPI.L  #$00010000,D0
somecode2:  Dc.w $6500,$0008                         ; BCS.W   codeisok
            Dc.w $4EB9,$0000,$0000                   ; JSR $00000000
codeisok:                                            ; codeisok:
;------                                              ;-- disassembled code end


arrevalchk:
  TST.b debugmode : BEQ.w sharreval
    BSR.w arreval

    arrszchk:
      MOVE.w somecode(PC),D1      ; CMPI.l ####, <regnum>
      OR.w regnum,D1
      BSR.w writeword

      MOVEQ.l #$01,D1             ; $00010000  / 65536
      SWAP D1
      BSR.w writelong

      MOVE.l somecode2(PC),D1     ; BCS.l <skip next instruction>
      BSR.w writelong

      MOVE.w #$C309,D1            ; (runerrslib, arrerr)
    BRA.w Atokejsr

  sharreval:
    MOVEQ.l #$02,D2
    MOVEQ.l #$00,D1
    MOVEQ.l #$00,D3
BRA.w maineval2


.arreval:
  MOVEQ.l #$03,D2           ;getlong
  MOVEQ.l #$00,D1           ;no push
  MOVEQ.l #$00,D3           ;and convert
  MOVE.b notypecheck,-(a7)
  MOVE.b #1,notypecheck                                    ;typecheck need switch off for array offset calculation code
  JSR maineval2             ;2!* ;was bra
  ; new >
  MOVE.b (a7)+,notypecheck                                 ;now its switch to old state
RTS
  ; < new

bakpevalu:                                                 ;??looks like labe not used??
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  MOVEQ.l #-$01,D1
  MOVEQ.l #-$01,D3
BRA.w peval


bakpeval:
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
peval:                                                 ; write blitzlib function calls
  MOVEQ.l #-$01,D1
  MOVEQ.l #$00,D3
  ; new >
  MOVE.l leftsidetype,-(a7)
  MOVE.l rightsidetype,-(a7)
  MOVE.w leftsideflagmask,-(a7)
  MOVE.w rightsideflagmask,-(a7)
  CLR.l leftsidetype
  CLR.l rightsidetype
  CLR.w leftsideflagmask
  CLR.w rightsideflagmask
  ; < new
  JSR maineval                    ; was bra
  ; new >
  MOVE.w (a7)+,rightsideflagmask
  MOVE.w (a7)+,leftsideflagmask
  MOVE.l (a7)+,rightsidetype
  MOVE.l (a7)+,leftsidetype
RTS
  ; < new

bakevalu:
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
evalu
  MOVEQ.l #$00,D1
  MOVEQ.l #-$01,D3
BRA.w maineval


evalu2:
  MOVEQ.l #$01,D1
  MOVEQ.l #-$01,D3
BRA.w maineval


bakeval:
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new

eval:
  MOVEQ.l #$00,D1      ;no push
  MOVEQ.l #$00,D3

maineval:
  ;CLR.b isconstantvalue
  ;CLR.l lastconstantvalue
  ;--                                                                                                                                                                                                                                                    
  ;-- Big Evaluation routine.....
  ;-- 
  ;-- d2 = type to collect - 0 if unknown
  ;-- 
  ;-- d3 = 0 if conv to original type
  ;-- 
  ;-- d1 = push result flag, 0 = no push, < 0 = push result
  ;--      > 0 = push type when known
  ;-- 
  ;-- result will be pushed anyway if using reg d6+
  ;-- 
  ;-- if getting a string, then strings len is on stack
  ;-- (a long), and a3 points at arse end of string
  ;-- while D(regat) points to start of string
  ;-- 
  CMPI.w #$6,regnum : BCS.w maineval2
    ; new >
    MOVEQ #0,d1
    MOVE.l destpointer,a4
    CMPA.l destbufferend,A4 : BCC.w 'l2
      CMP.w #$2f0a,-2(a4) : BNE 'l2           ;bug is a move.l a2,-(a7) before (show temp calc)?
                                              ;then put not to stack
        ;   JSR linemessage
        ;   TST.l result
        ;   BEQ 'l2
        BRA 'l1
  'l2
      ; < new
      MOVEQ.l #-$01,D1                                         ;do stackpar write
  'l1
    MOVE.w #$0006,regnum                                     ;write a func par To stack

maineval2:
  ;-- 
  ;-- d2=type to get, d1=push flag (should I push result?)
  ;--
  MOVE.w thisstuse,-(A7)
  MOVE.w a2offset,thisstuse
  ;
  MOVE.w stackpar,-(A7)
  MOVE.w D1,stackpar
  MOVE.w sbgot,-(A7)
  CLR.w sbgot                                    ;not pushed yet
  MOVE.w unknown(PC),-(A7)
  MOVE.w D3,unknown
  ;
  MOVE.w D2,-(a7)
  ; new >
  MOVE.w d2,mode
  ; < new

  BSR.w eval3

  MOVE.w (a7)+,d3 : BEQ.w 'noconv               ;type asked for
    MOVE.w unknown(PC),D1 : BNE.w 'noconv
    EXG.l D2,D3
    ; new >
    MOVE.l a2,-(a7)
    TST.b curtemplabel : BEQ 'l10
      MOVE.l asmbuff,a2
      CMP.w #$c,8(A2) : BEQ 'l20
      CMP.w #$d,8(A2) : BEQ 'l20
   'l10
      CMP.w d2,d3 : BEQ 'l20
        BSR.w writeconvertcode
        CLR.b doimmediate
   'l20
    MOVE.l (a7)+,a2
 'noconv
  ; < new
  MOVE.w (A7)+,unknown
  MOVE.w stackpar,D1 : BEQ.w 'skipme
                       BMI.w 'skipme
  ;--
  ;-- push the type got.
  ;--
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  CMP.w #$7,D2 : BNE.w 'hi1
    ; new >
    CMP.b #2,optistring : BEQ 'hi1a
    ; < new
    MOVE.w D1,-(A7)
    OR.w getstlen,D1
    BSR.w writeword
    MOVE.w (A7)+,D1
  'hi1
  ADDQ.w #2,a2offset                                        ;lib mode to stack
  ;ORI.w #$7000,D1      ; MOVEQ#0,D0
  ;ADDI.w #$200,D1      ;moveq #x,dREGAT+1
  ;OR.w D2,D1
  ; new >
  MOVE.w #$3f3c,d1
  ; < new
  BSR.w writeword
  ;move.w pushut(PC),D1
  ;or.w regnum,D1
  ;addq.w #1,D1
  ; new >
  MOVE.w d2,d1
  MOVE.w d1,libmode
  ; < new
  BSR.w writeword
  ;
  CMP.w #$7,D2 : BNE.w 'skipme        ; value is as string
    MOVE.w putstlen,D1
    OR.w regnum,D1
    BSR.w writeword
 'skipme

  CMP.w #$7,D2 : BNE.w 'notst
    ;
    ; new >
    ; CNIF #more6string
    ;   CMP.w #6,regnum
    ;   BEQ 'skipme_l1
    ;   TST.b funcparloop
    ;   BEQ 'skipme_l1
    ;   MOVE.l #$48780000,d1
    ;   BSR writelong
    ;
    ; 'skipme_l1
    ; CEND
    CMP.b #2,optistring : BEQ 'skipme_l10
      ; < new
      ADDQ.w #4,a2offset     ;a length on da stack.....
      BSR.w sbtolong
      BRA.w 'notst2
      ; new >
  'skipme_l10

    CNIF #more6string
      CMP.w #6,regnum : BEQ 'skipme_l10_l1
      TST.b funcparloop : BEQ 'skipme_l10_l1
        MOVE.l #$48780000,d1
        BSR writelong
    'skipme_l10_l1
    CEND
    BRA.w 'notst2

  'hi1a
    ADDQ.w #2,a2offset
    BRA 'skipme
    ; < new
 'notst

  CMPI.w #$2,sbgot : BCS.w 'notst2           ;correct stack
    MOVE.w ststfix(PC),D1
    BSR.w writeword
 'notst2
  MOVE.w (A7)+,sbgot
  ;
  MOVE.w stackpar,D1 : BPL.w 'skip
  ; new >
  CMP.b #7,d2         : BEQ 'notst2_l1
  TST.b funcparloop   : BEQ 'notst2_l1

  CMP.b #5,d2         : BNE 'notst2_skip
    TST.b optimize_fpu         : BEQ 'notst2_skip
      MOVE.l #$f2066700,d1 : JSR writelong               ;fmove.s fp6,d6  
 'notst2_skip

  MOVE.w #$c4ff,d1                                         ;savetemp+regnum
  ADD.w parnum,d1
  JSR Atokejsr

  TST.w dontwrite_nomemleft : BNE 'notst2_l1
    MOVE.l data1start,d1
    MOVE.l destpointer,a4
    ADD.l d1,-4(a4)
    MOVE.l destpointer,d1
    SUBQ.l #4,d1
    SUB.l destbufferstart,d1
    MOVE.l d2,-(a7)
    MOVE.l d1,d2
    JSR addhunkoffset
    MOVE.l (a7)+,d2
    BRA 'skip
 'notst2_l1
  ; < new
  ADDQ.w #2,a2offset
  MOVE.w pushd0wd,D1
  CMP.w #$3,D2 : BCS.w 'ok                             ;write parameter to stack
  
  ADDQ.w #2,a2offset
  ; new >
  TST.b optimize_fpu : BEQ 'notst2_nofpu
    CMP.w #5,d2 : BNE 'notst2_nofpu
      MOVEQ #0,d1
      MOVE.w regnum,d1
      ASL.l #7,d1
      OR.l #$f2276400,d1
      BSR writelong
      BRA 'skip
 'notst2_nofpu
  ; < new
  MOVE.w pushd0l,D1

 'ok
   OR.w regnum,D1
   BSR.w writeword                                         ;nat

 'skip
  MOVE.w (A7)+,stackpar
  MOVE.w (A7)+,thisstuse
RTS


thisstuse: Ds.w 1

;------                                                  ;disassembled code begin
ststfix:   Dc.b $58,$4F                                    ;ADDQ.W  #4,A7
pushut:    Dc.b $3F,$00                                    ;MOVE.W  D0,-(A7)
;------                                                  ;disassembled code end
Even

eval3:
  BSR.w eval4
  SUBI.l #$12,forthsp
RTS


eval4:
  MOVEQ.l #$01,D1
   ;BSR.w pushprec
  ; new >
  MOVEA.l precsp(PC),A1
  MOVE.l A0,(A1)+
  MOVE.w D1,(A1)+
  MOVE.l A1,precsp
  ; < new
  BSR.w calcloop

  TST.w D1 : BNE.w syntaxerr
  ;
  SUBQ.l #6,precsp           ;pop the prec set up
RTS


.calcloop:  ; was eval5 org source
  BSR.w eval2

 'more
  MOVEA.l precsp(PC),A1
  CMP.w -(A1),D1 : BHI.w 'higher
    RTS
 'higher
  ;BSR.w pushprec
  ;
  ; new >
  MOVEA.l precsp(PC),A1
  MOVE.l A0,(A1)+
  MOVE.w D1,(A1)+
  MOVE.l A1,precsp
  ; < new
  MOVE.w D2,-(A7)
  ADDQ.w #1,regnum
  BSR.w calcloop               ;constant optimizer
  SUBQ.w #1,regnum
  MOVE.w (A7)+,D3
  MOVEM.l D1/A0,-(A7)
  BEQ.w 'skip
    BSR.w convtypef            ;could possibly fuck regat+1 !
 'skip
  BSR.w popprec
  BSR.w writecode
  ;-- 
  ;-- O.K., lets check the forth stack to see if last two operators are constants!
  ;--       if so, we can JSR the routine to optimize into a constant!
  ;--
  MOVEA.l forthsp(PC),A0
  MOVE.w -$2(A0),D1
  OR.w -$14(A0),D1
  MOVE.w D1,-$14(A0) : BNE.w 'no

  MOVE.w dontwrite_nomemleft,D1 : BNE.w 'no
  ;--
  ;-- YES! We can do it!
  ;--
  ;-- Set up MOVE.l regat,d0
  ;--
  ; new >
  MOVEA.l -$24(A0),A0

  !newcalc
  BEQ 'l10
    MOVEA.l forthsp(PC),A0
    MOVE.w -$18(A0),lasta6
    MOVE.l -$1C(A0),lasta6
    MOVEA.l -$24(A0),A0
    MOVE.l A0,destpointer
    MOVEA.l _mathffpbase,A6
    MOVEA.l ffplib,A1
    BRA 'cont1
 'l10
    ; < new
    MOVE.w #$2000,D1                              ; opcode: move.l d0,d0
    OR.w regnum,D1                                ; was regat(pc),
    BSR.w writeword
    ; new >
    TST.b optimize_fpu : BEQ 'nofpu1
      MOVEQ #0,d1
      MOVE.w regnum,D1
      ASL.l #8,d1
      ASL.l #2,d1
      OR.l #$f2000000,d1                            ; opcode: fmove.x fp0       FPU-check: ok
      BSR writelong
   'nofpu1
    ; < new
    MOVE.w ##opcode_RTS,D1 : BSR.w writeword        ; opcode: rts
  
    MOVE.w -$18(A0),lasta6
    MOVE.l -$1C(A0),lasta6
    MOVEA.l -$24(A0),A0
    MOVE.l A0,destpointer
    ;
    MOVEM.l D2/A5,-(A7)
    ;
    MOVEA.l _mathffpbase,A6
    MOVEA.l ffplib,A1
    MOVE.w $A(A1),D0
    LEA _mathffpbase,A5
    SUBA.w D0,A5
    ;
    JSR clear_Cache                                          ;neg +
    ; new >
    CLR.l load_var_addr
    CLR.l imm_addr
    TST.w dontwrite_nomemleft : BNE '1
      ; < new
      ;TRAP #5
      JSR (A0)                                                 ;calc constant inline expression
   '1
    MOVEM.l (A7)+,D2/A5
    ;
    ;d0 has got constant!
    ;
    ; new >
 'cont1

  MOVE.b d2,isconstantvalue
  MOVE.l d0,lastconstantvalue
  ; < new
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1                                            ; opcode: move.l #x,dn
  CMP.w #$3,D2 : BCC.w 'ok
    ORI.w #$1000,D1
    BSR.w writeword
    MOVE.w D0,D1
    BSR.w writeword
    BRA.w 'mode
 'ok
    ; new >
    TST.b iee : BEQ 'l10b                                    ; fpu constant
      CMP.b #5,d2 : BNE 'l10b
        TST.b optimize_fpu : BEQ 'nofpu2
          MOVEQ #0,d1
          MOVE.w regnum,D1
          ASL.l #7,d1
          OR.l #$f23c5400,d1                                   ; opcode: fmove.d
          BSR writelong
          SUBQ.l #8,a7
          fmove.d fp0,0(a7)
          MOVE.l (a7)+,d1
          BSR writelong
       'nofpu2

        MOVE.l (a7)+,d1
        BSR writelong
        BRA 'mode
   'l10b
      ; < new
      BSR.w writeword
      MOVE.l D0,D1
      BSR.w writelong
 'mode
  ;Move #x,Dn

  ;--
  ;-- clean up offset stack
  ;
  MOVEA.l _execbase,A6
  
  MOVEA.l forthsp(PC),A0
  MOVEA.l -$20(A0),A3
  MOVEA.l hunkoffsetbase,A2
  MOVE.l A3,hunkoffsetbase
 'loop
    CMPA.l A3,A2 : BEQ.w 'done
  
    SUBQ.l #1,hunkoffsetcounter
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$8,D0
    MOVE.l mempool2,a0 : JSR _FreePooled(A6)
  BRA.w 'loop
 'done

  MOVEA.l forthsp(PC),A0

 'no
  LEA -$12(A0),A0
  MOVE.l A0,forthsp
  ;
  MOVEM.l (A7)+,D1/A0
  BSR.w reget
BRA.w 'more


eval2:
  ;--
  ;-- get 1 element and operator
  ;-- d1 = op prec, or 0 if .done
  ;-- a0 = operator address
  ;--
  BSR.w getelement
  ; new >
  TST.w d0 :  BEQ 'done
  CMP.b #",",d0 : BEQ 'done
  CMP.b #"@",d0 : BEQ 'done                                           ;expandline @@

  LEA operators,A0
 'loop
    TST.w (A0) : BEQ.w 'done
    CMP.w (A0),D0 : BEQ.w 'found
      LEA $20(A0),A0
      BRA.w 'loop
 'done
  MOVEQ.l #$00,D1
  RTS

 'found
  CMP.w #$3C,D0 : BNE.w 'notlt            ;<
    BSR.w get1bytemain
    CMP.w #"=",D0 : BNE.w 'notlteq
      LEA ople,A0
      BRA.w 'found2
   'notlteq
    CMP.W #$3C,D0 : BNE.W 'nolshift       ;<
      LEA opls,A0
      BRA.w 'found2
   'nolshift
    CMP.w #$3E,D0 : BNE.w 'found3         ;'>'
      BRA.w 'isne
 'notlt

  CMP.w #$3E,D0 : BNE.w 'notqt            ;'>'
    BSR.w get1bytemain
    CMP.w #"=",D0 : BNE.w 'notgteq
      LEA opge,A0
      BRA.w 'found2
   'notgteq
    CMP.W #$3E,D0 : BNE.W 'norshift       ;>
      LEA oprs,A0
      BRA.w 'found2
   'norshift
    CMP.w #$3C,D0 : BEQ.w 'isne           ;'<'
    
 'found3
    ;bsr.w bakup
    ; new >
    MOVE.w oldqflag,instringon
    MOVEA.l lastsourcepos,A5
    ; < new
    BRA.w 'found2

 'notqt
  CMP.w #"=",D0 : BNE.w 'found2
    BSR.w get1bytemain
    CMP.w #$3E,D0 : BNE.w 'noteqgt       ;'>'
      LEA opge,A0
      BRA.w 'found2
   'noteqgt
    CMP.w #$3C,D0 : BNE.w 'found3        ;'<'
   'isne
    LEA opne,A0
 'found2
  ;
  ;We've found the operator.
  ;
  MOVE.w $1E(A0),D1
RTS


.writecode:                                                 ;doop org source
 ;-- a0 = operator, d2 = type
 ;--
  ; new >
  ;CLR.b iniffcommand
  ; < new
  MOVE.w d2,d1
  SUBQ.w #1,D1
  BMI.w illoperr

  LSL.w #2,D1
  MOVE.l $2(A0,D1.W),D1
  BEQ.w illoperr

  MOVEA.l D1,A0
JMP (A0)


;pushprec:
  ;-- push operator on stack
  ;
  ;MOVEA.l precsp(PC),A1
  ;MOVE.l A0,(A1)+
  ;MOVE.w D1,(A1)+
  ;MOVE.l A1,precsp
;RTS


popprec:
  ;-- pull precedence into d1 from stack
  ;--
  MOVEA.l precsp(PC),A1
  CMPA.l #precstackf,A1 : BCC.w pserr

  MOVE.w -(A1),D1
  MOVEA.l -(A1),A0
  MOVE.l A1,precsp
RTS


precsp:      Dc.l precstack
precstack:   Ds.l 63                                       ;ds 6*32 org source   ;Lotsa Room?
             Ds.l 33
precstackf:  ;


;-----------PLUS------------;

mseq:  SEQ D0
msne:  SNE D0
mslt:  SLT D0
msle:  SLE D0
msgt:  SGT D0
msge:  SGE D0

cmp0:  CMP.b D0,D0
cmp1:  CMP.w D0,D0
cmp2:  CMP.l D0,D0


do_equal_byte:
  MOVE.w cmp0(PC),D1
BRA.w doeqcmp2                                            ;writecompare


do_not_equal_byte:
  MOVE.w cmp0(PC),D1
BRA.w donecmp2


do_littler_byte:
  MOVE.w cmp0(PC),D1
BRA.w doltcmp2


do_littler_equal_byte:
  MOVE.w cmp0(PC),D1
BRA.w dolecmp2


do_greater_byte:
  MOVE.w cmp0(PC),D1
BRA.w dogtcmp2


do_greater_equal_byte:                                                ;??Looks like double label??
dogeb
  MOVE.w cmp0(PC),D1
BRA.w dogecmp2


do_equal_word:
  MOVE.w cmp1(PC),D1
BRA.w doeqcmp2


do_not_equal_word:
  MOVE.w cmp1(PC),D1
BRA.w donecmp2


do_littler_word:
  MOVE.w cmp1(PC),D1
BRA.w doltcmp2


do_littler_equal_word:
  MOVE.w cmp1(PC),D1
BRA.w dolecmp2


do_greater_word:
  MOVE.w cmp1(PC),D1
BRA.w dogtcmp2


do_greater_equal_word:
dogew                                                      ;??looks like double label??
  MOVE.w cmp1(PC),D1
BRA.w dogecmp2


do_equal_long:
  MOVE.w cmp2(PC),D1                                   ;writecomparelong
BRA doeqcmp2

do_not_equal_long:
  MOVE.w cmp2(PC),D1
BRA donecmp2


do_littler_long:
  MOVE.w cmp2(PC),D1
BRA.w doltcmp2


do_littler_equal_long:
  MOVE.w cmp2(PC),D1
BRA.w dolecmp2


do_greater_long:
  MOVE.w cmp2(PC),D1
BRA.w dogtcmp2


do_greater_equal_long:
  MOVE.w cmp2(PC),D1
BRA.w dogecmp2


cfregat:  Ds.w 1


docflib:
  MOVE.w D1,libjsr+2
   BSR.w savereg
  MOVE.l D4,D1
   BSR.w pokemovem
  MOVE.w #$C900,D1 :  BSR.w Atokejsr                        ;#getffpbase
   BSR.w PutRegXToD0
  MOVE.l libjsr,D1
   BSR.w writelong
  MOVE.w regnum,cfregat
  CLR.w regnum
RTS


docflib2:
  MOVE.w cfregat,regnum
   BSR.w PutD0ToRegX
  MOVE.l D5,D1
BRA.w pokemovem


do_equal_float:                                            ;doeqf org source
   MOVEQ.l #-$2A,D1
   TST.b optimize_fpu : BEQ 'nofpu
    MOVEQ #0,d1
    MOVE.w regnum,d1
    MOVE.l d1,d2
    ASL.l #7,d1
    ADDQ  #1,d2
    ASL.l #8,d2
    ASL.l #2,d2
    OR.l d2,d1
    OR.l #$f2000038,d1
    JSR writelong
    MOVE.w #$f240,d1
    OR.w regnum,d1
    BSR writeword
    MOVEQ.l #1,d2
    MOVE.w #1,d1                                            ;fpu comp fseq
    BSR writeword
    RTS
 'nofpu
  BSR.w docflib
  BSR.w doeqcmp
BRA.w docflib2


do_not_equal_float:                                        ;donef org source
  MOVEQ.l #-$2A,D1
  TST.b optimize_fpu
   BEQ 'nofpu
   MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #1,d2
   MOVE.w #$e,d1                                           ;fpu comp fsne
   BSR writeword
 RTS

 'nofpu
   BSR.w docflib
   BSR.w donecmp
BRA.w docflib2


do_littler_float:                                          ;doltf org source
  MOVEQ.l #-$2A,D1
    TST.b optimize_fpu
   BEQ 'nofpu
   MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #$1,d2
   MOVE.w #$14,d1                                          ;fpu comp fslt
   BSR writeword
 RTS

 'nofpu
   BSR.w docflib
   BSR.w doltcmp
BRA.w docflib2


do_littler_equal_float:                                    ;dolef org source
  MOVEQ.l #-$2A,D1
  TST.b optimize_fpu
  BEQ 'nofpu
    MOVEQ #0,d1
    MOVE.w regnum,d1
    MOVE.l d1,d2
    ASL.l #7,d1
    ADDQ  #1,d2
    ASL.l #8,d2
    ASL.l #2,d2
    OR.l d2,d1
    OR.l #$f2000038,d1
    JSR writelong
    MOVE.w #$f240,d1
    OR.w regnum,d1
    BSR writeword
    MOVE.l #1,d2
    MOVE.w #$15,d1                                          ;fpu comp fsle
    BSR writeword
    RTS
 'nofpu
  BSR.w docflib
  BSR.w dolecmp
BRA.w docflib2


do_greater_float:                                          ;dogtf org source
  MOVEQ.l #-$2A,D1
   TST.b optimize_fpu
   BEQ 'nofpu
    MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #1,d2
   MOVE.w #$12,d1                                          ;fpu comp fsgt
   BSR writeword
 RTS

 'nofpu
   BSR.w docflib
   BSR.w dogtcmp
BRA.w docflib2


do_greater_equal_float:                                   ;dogef org source
  MOVEQ.l #-$2A,D1
 TST.b optimize_fpu
   BEQ 'nofpu
   MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #1,d2
   MOVE.w #$13,d1                                          ;fpu comp fsge
   BSR writeword
 RTS

 'nofpu
   BSR.w docflib
   BSR.w dogecmp
BRA.w docflib2



do_equal_string:                                           ;doeqs org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w doeqcmp


do_not_equal_string:                                       ;dones org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w donecmp


do_littler_string:                                         ;dolts org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w doltcmp


do_littler_equal_string:                                   ;doles org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w dolecmp


do_greater_string:                                         ;dogts org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w dogtcmp


do_greater_equal_string:                                   ;doges org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w dogecmp



cmpit:
  TST.b optimize_integer : BEQ 'org                        ;compare

  CNIF #optibreak
    ILLEGAL
  CEND

  MOVE.l destpointer,a0
  SUB.l imm_addr,a0
  CMP.l #6,a0 : BNE 'l11
  MOVE.l imm_addr,a0
  CMP.w #$223c,imm_addr : BNE 'org
    ADD.w #$8e80,-6(a4)
    CLR.l imm_addr
    RTS
 'l11
  CMP.l #4,a0 : BNE 'l10
    CMP.b #2,d3 : BNE 'l11b
      ADD.w #$7e40,-4(a4)
      RTS
   'l11b
    ADD.w #$7e00,-4(a4)
    RTS
 'l10

  MOVE.l destpointer,a0
  SUB.l load_var_addr,a0
  CMP.w #4,a0 : BNE 'org
    CMP.b #3,d3 : BCS 'lv1
      CLR.l load_var_addr
      ADD.w #$9080-$200,-4(a4)
      RTS
   'lv1
  CMP.b #2,d3 : BNE 'org
    CLR.l load_var_addr
    ADD.w #$8040-$200,-4(a4)
    RTS

 'org                                               ;begin org source
  MOVE.w regnum,D3
  OR.w D3,D1
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
  ADDQ.w #1,D1
BRA.w writeword


doeqcmp2:
   BSR.w cmpit

 doeqcmp:
   MOVE.w mseq(PC),D1
BRA.w cpoke


donecmp2:
  BSR.w cmpit

 donecmp:
  MOVE.w msne(PC),D1
BRA.w cpoke


doltcmp2:
  BSR.w cmpit

 doltcmp:
   MOVE.w mslt(PC),D1
BRA.w cpoke


dolecmp2:
   BSR.w cmpit

 dolecmp:
   MOVE.w msle(PC),D1
BRA.w cpoke


dogtcmp2:
   BSR.w cmpit

 dogtcmp:
   MOVE.w msgt(PC),D1
BRA.w cpoke


dogecmp2:
  BSR.w cmpit

 dogecmp:
   MOVE.w msge(PC),D1

cpoke:
   OR.w regnum,D1
   CMP.w #5,d2 : BNE 'nod0
   CMP.w #5,d3 : BNE 'nod0

   MOVE.l d1,-(a7)
   MOVE.l #$44004a00,d1                                    ;68k neg.b:tst.b
   BSR writelong
   MOVE.l (a7)+,d1

  'nod0
   BSR.w writeword                                         ;writeseq
   MOVEQ.l #1,d2
   MOVE.l lasttoken,d1
    TST.b optimize_integer : BEQ.s 'l11
      CMP.l ##TokenID_If,d1 : BEQ 'l10                       ; $800b
   'l11
  MOVE.w #$4880,D1                                         ;ext.w D regat
  OR.w regnum,D1
  BSR.w writeword                                          ;writeext.w
  MOVEQ.l #$02,D2                                          ;type now WORD!

 'l10
RTS



do_plus_byte:                                              ;doplusb org source
  MOVE.w #$D040,D1
  MOVEQ.l #$02,D2                                          ;writeaddword   ;now a word
BRA.w doplus2


do_plus_word:                                              ;doplusw org source
  MOVE.w #$D040,D1
  MOVEQ.l #$03,D2                                          ;now a long
   BSR.w doplus2
BRA.w convert_word_to_long


do_plus_long:                                              ;doplusl org source  ;add regat+1 to regat
  MOVE.w #$D080,D1                                         ;writeaddlong

doplus2:
  MOVE.w d1,a1
  TST.b optimize_integer : BEQ 'l10
  
  CNIF #optibreak
    ILLEGAL
  CEND
  
  ASR.w #8,d1
  CMP.b #$90,d1 :  BEQ 'sub1
  CMP.b #$d0,d1 :  BNE 'l10
  CMP.b #3,d3   :  BCS 'lq10
  TST.b quickadd
  ;BNE 'lq1                                        ;????????????activate

 'lq10
   MOVE.l destpointer,a0
   CLR.b quickadd
   CLR.l load_var_addr
   SUB.l imm_addr,a0
   CMP.w #6,a0 : BEQ 'li10
   CMP.w #4,a0 : BNE.s 'li1
   CLR.l imm_addr
   ADD.w #$a040-$200,-4(a4)
 RTS

 'lq1
   MOVE.l a4,a0
   SUB.l load_var_addr,a0
   CMP.l #$a,a0 : BNE 'l10e
   CLR.l load_var_addr
   MOVE.w -$8(a4),d1
   MOVE.l -$4(a4),-$8(a4)
   MOVE.w d1,-$4(a4)
   SUB.w #$1980,-$a(a4)
   SUBQ.l #2,destpointer
 RTS

 'l10e
  CLR.b quickadd
 BRA 'l10

 'li10
   CLR.l imm_addr
   TST.l -4(a4) : BNE 'doit                             ;skip If ADD.l #0,dx
     SUBQ.l #6,destpointer
     RTS
  'doit
   ADD.w #$b080-$200,-6(a4)
 RTS

 'li1
   MOVE.l destpointer,a0
   SUB.l load_var_addr,a0
   CMP.w #4,a0 : BNE 'l10
   CMP.b #3,d3 : BNE 'lv1
   CLR.l load_var_addr
   ADD.w #$b080-$200,-4(a4)
 RTS

 'lv1
  CMP.b #2,d3 : BNE 'l10
    CLR.l load_var_addr
    ADD.w #$a040-$200,-4(a4)
    RTS
 'l10:
  MOVE.w regnum,D3
  MOVE.w a1,d1
  OR.w D3,D1
  ADDQ.w #1,D1
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
  BRA.w writeword

 'sub1
   CMP.b #3,d3 : BCS 'sub1_lq10
   TST.b quickadd
   ;BNE 'sub1_lqs1

 'sub1_lq10                                       ;??lookslike same code as 'lq10:
   MOVE.l destpointer,a0
   CLR.b quickadd
   CLR.l load_var_addr
   SUB.l imm_addr,a0
   CMP.w #6,a0 : BEQ 'sub1_li10
   CMP.w #4,a0 : BNE.s 'sub1_li1
   CLR.l imm_addr
   ADD.w #$6040-$200,-4(a4)
 RTS

 'sub1_lqs1
   MOVE.l a4,a0
   SUB.l load_var_addr,a0
   CMP.l #$a,a0 : BNE 'sub1_l10e
   CLR.l load_var_addr
   MOVE.w -$8(a4),d1
   MOVE.l -$4(a4),-$8(a4)
   MOVE.w d1,-$4(a4)
   SUB.w #$1b80,-$a(a4)
   SUBQ.l #2,destpointer
 RTS

 'sub1_l10e:                                       ;??looks like same code as 'l10e:
  CLR.b quickadd
 BRA 'sub1_l10

 'sub1_li10
   CLR.l imm_addr
   ADD.w #$7080-$200,-6(a4)
 RTS

 'sub1_li1                                        ;??looks like same code as 'li1:
   MOVE.l destpointer,a0
   SUB.l load_var_addr,a0
   CMP.w #4,a0 : BNE 'sub1_l10
   CMP.b #3,d3 : BNE 'sub1_lv1
   CLR.l load_var_addr
   ADD.w #$7080-$200,-4(a4)
 RTS

 'sub1_lv1                                       ;??looks like same code as 'lv1:
   CMP.b #2,d3 : BNE 'sub1_l10
   CLR.l load_var_addr
   ADD.w #$6040-$200,-4(a4)
 RTS

 'sub1_l10                                       ;??looks like same code as 'l10:
  MOVE.w regnum,D3
  MOVE.w a1,d1
  OR.w D3,D1
  ADDQ.w #1,D1
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
BRA.w writeword


do_plus_float_fadd1:
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ADDQ #1,d0
  ASL.w #8,d0
  ASL.w #2,d0
  MOVE.l #$f2000022,d1                                     ;fpu add
  OR.l d0,d1
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.l d0,d1
BRA.w writelong


do_plus_float:                                            ;doplusf org source
  ;
  ;ffp add
  ;
  TST.b iee : BNE do_plus_float_fadd1

  MOVE.w #$FFBE,D1                                         ;#-66,d1 org source ;floatadd
  doflib:
  MOVE.w D1,libjsr+2
  BSR.w savereg
  MOVE.l D4,D1
  BSR.w pokemovem
  MOVE.w #$C900,D1 :   BSR.w Atokejsr                      ;#getffpbase
  BSR.w PutRegXToD0
  MOVE.l libjsr,D1
  BSR.w writelong
  BSR.w PutD0ToRegX
  MOVE.l D5,D1
BRA.w pokemovem


add_strings:                                               ;addstrings org source
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  MOVE.w D1,-(A7)
  CMP.w #3072,d1 : BEQ 'l1
    OR.w addcode,D1                                        ;move.l (a7)+,d0
    BRA 'l2
 'l1
    MOVE.w #$588f,d1                                       ;addq.l #4,a7
 'l2
  BSR.w writeword
  MOVE.w (A7)+,D1
  OR.w addcode+2,D1                                        ;native string ADD.l d0,(a7)
BRA.w writeword


;-----------end of PLUS, start of MINUS---------;

do_minus_byte:
  MOVE.w #$9040,D1                                        ; SUB.w d0,d0
BRA.w doplus2


do_minus_word:
  MOVE.w #$9040,D1                                        ; SUB.w d0,d0
BRA.w doplus2


do_minus_long:
  MOVE.w #$9080,D1                                        ; SUB.L d0,d0
BRA.w doplus2


do_minus_float:
  TST.b iee : BNE 'fs1
    MOVE.w #$FFB8,D1                                      ;floatsub
    BRA.w doflib
 'fs1                                                     ;fpu sub

  MOVEQ #0,d0
  MOVE.w regnum,d0
  ADDQ #1,d0
  ASL.w #8,d0
  ASL.w #2,d0
  MOVE.l #$f2000028,d1
  OR.l d0,d1
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.l d0,d1
BRA.w writelong


;-----------end of MINUS, start of TIMES---------;

do_times_byte:
  MOVE.w #$C1C0,D1                                         ;MULS D0,D0 
  MOVEQ.l #$02,D2                                          ;now a word
BRA.w doplus2


do_times_word:
  MOVE.w #$C1C0,D1                                         ;MULS D0,D0
  MOVEQ.l #$03,D2                                          ;now a long.
BRA.w doplus2


do_times_quick:
  MOVE.w #$CA00,D1                                         ;#quickmult / LMULLIB
BRA.w domylib


do_times_long:
  TST.b optimize_integer : BNE.s 'l10
    MOVE.w #$CA01,D1                                       ;#longmult / LMULLIB
    BRA.w domylib
 'l10
  ;bsr.w savereg

  mull
  ;move.l D4,D1
  ;bsr.w pokemovem
  ;bsr.w PutRegXToD0
  MOVE.l destpointer,a0
  SUB.l imm_addr,a0
  CMP.w #6,a0 : BNE 'li1
  MOVEQ.l #2,d1
  MOVEQ #1,d3

 'ag
    CMP.l -4(a4),d1 : BEQ 'oklsl
      LSL.l #1,d1
      ADD.l #1,d3
      CMP.l #9,d3
  BNE 'ag
  MOVE.w -2(a4),d1
  BSR writeword
  MOVE.w -6(a4),-4(a4)
  MOVE.l #$4c3c0800,-8(a4)                                ; MULU.L
  MOVE.w regnum,D3
  MULS #$1000,D3
  OR.w D3,-6(a4)
  CLR.l load_var_addr
  CLR.l imm_addr
  BRA 'li3

 'oklsl
  CMP.w #8,d3 : BEQ 'ok
    ASL.l #1,d3
    ASL.l #8,d3
    MOVE.w #$e188,d1                                        ;lsl.l #,dx
    OR.w d3,d1
    MOVE.w d1,-6(a4)
    BRA 'okls
 'ok
  MOVE.w #$e188,-6(a4)                                     ;lsl.l #,dx

 'okls
  MOVE.w regnum,d3
  OR.b d3,-5(a4)
  SUBQ.l #4,destpointer
  CLR.l load_var_addr
  CLR.l imm_addr
  BRA 'li3

 'li1
  MOVE.l destpointer,a0
  SUB.l load_var_addr,a0
  CMP.w #4,a0 : BNE 'li2
    MOVE.w -2(a4),d1
    BSR writeword
    MOVE.b #$4c,-6(a4)
    MOVE.w #$0800,-4(a4)
    MOVE.w regnum,D3
    MULS #$1000,d3
    OR.w D3,-4(a4)
    BRA 'li3
 'li2
    MOVE.l #$4c010800,d1                                   ; muls.l d1,d0: 68020+ only
    MOVE.w regnum,D3
    EXT.l d3
    MULS #$1000,d3
    OR.w D3,d1
    MULS #$10,d3
    ADD.l d3,d1
    BSR writelong
 'li3
  ;bsr.w PutD0ToRegX
  ;move.l D5,D1
RTS


.domylib:
  MOVE.w D1,-(A7)
  BSR.w savereg
  MOVE.l D4,D1
  BSR.w pokemovem
  BSR.w PutRegXToD0
  MOVEQ #0,d1
  MOVE.w (A7)+,D1
  MOVE.l d1,lastinstruction
  BSR.w Atokejsr
  BSR.w PutD0ToRegX
  MOVE.l D5,D1
BRA.w pokemovem


do_times_float:
  TST.b iee : BNE fm1
    MOVE.w #$FFB2,D1                                       ;floatmul
    BRA.w doflib
  fm1                                                       ;fpu mul

  MOVEQ #0,d0
  MOVE.w regnum,d0
  ADDQ #1,d0
  ASL.w #8,d0
  ASL.w #2,d0
  MOVE.l #$f2000023,d1
  OR.l d0,d1
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.l d0,d1
BRA.w writelong


do_pow:
  MOVE.w D2,-(A7)                                          ;dopow
  MOVE.w D2,D3
  MOVEQ.l #$05,D2
  BSR.w convtypef
  ADDQ.w #1,regnum
  MOVE.w (A7)+,D3
  MOVEQ.l #$05,D2
  BSR.w writeconvertcode
  SUBQ.w #1,regnum
  BSR.w nocando

  TST.b optimize_fpu : BEQ 'old
    MOVEQ #0,d1
    MOVE.w regnum,d1
    MOVE.l d1,d0
    ASL.w #7,d1
    ASL.w #8,d0
    ASL.w #2,d0
    OR.w d0,d1
    MOVE.l d1,-(a7)
    ;OR.l #$f2000014,d1                                      ;flogn.x fp0      ;fpu ^ pow
    OR.l #$f2000016,d1                                       ;flog2.x fp0      ;fpu ^ pow
    BSR writelong
    MOVE.w regnum,d0
    ADDQ #1,d0
    ASL.w #8,d0
    ASL.w #2,d0
    MOVE.l #$f2000023,d1
    OR.l d0,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.l d0,d1
    OR.l #$f2000023,d1                                      ;fmulx.x fp1,fp0
    BSR writelong
    MOVE.l (a7)+,d1
    ;OR.l #$f2000010,d1                                      ;fetox.x fp0
    OR.l #$f2000011,d1                                      ;ftwotox.x fp0
    BSR writelong
    RTS
'old
  MOVE.w #$6001,D1                                          ;mathtranslib, SPPow() ??
BRA.w domylib


nocando:
    ;can't eval this as a const!
    ;
  MOVEA.l forthsp(PC),A0
  MOVE.w #$FFFF,-(A0)                                      ;#-1,-(a0) org source
RTS


;-----------end of times, start of mod-------;

do_mod_byte:
  MOVE.w #$D400,D1                                         ; do_ModB / modlib
BRA.w domylib


do_mod_word:
  MOVE.w #$D401,D1                                         ; do_ModW / modlib
BRA.w domylib


do_mod_long:
  BSR.w nocando                                            ;modlib uses an alibjsr here!
  MOVE.w #$D402,D1                                         ; do_ModL / modlib
BRA.w domylib


do_mod_quick:
  MOVE.w #$D403,D1                                         ; do_ModQ / modlib
  MOVEQ.l #$02,D2                                          ; returntype is a word
BRA.w domylib


do_mod_float:
  BSR.w nocando                                            ;modlib lib uses an alibjsr!
  TST.b optimize_fpu
  BEQ 'old
    MOVEQ #0,d1
    MOVE.w regnum,d1                                       ; fpu mod
    MOVE.l d1,d0
    ADDQ.l #1,d1
    ASL.l #7,d0
    ASL.l #8,d1
    ASL.l #2,d1
    OR.l d0,d1
    MOVE.l d0,-(a7)
    OR.l #$f2000021,d1
    BSR writelong
    MOVE.l (a7)+,d0
    RTS
'old
 MOVE.w #$D404,D1                                          ; do_ModF / modlib
 MOVEQ.l #$03,D2                                           ; returntype is a long
BRA.w domylib


;-----------end of mod, start of POWER OF----;

;-----------end of mod, start of DIVIDE------;

do_Div_byte:
  MOVE.w #$48C0,D1                                        ; optcode EXT.l d0
  OR.w regnum,D1
  BSR.w writeword
  ADDQ.w #1,D1
  BSR.w writeword

 do_Div_word:
  MOVE.w #$48C0,D1                                         ; opcode EXT.L d0
  OR.w regnum,D1
  BSR.w writeword
  MOVE.w #$81C0,D1
BRA.w doplus2


do_Div_long:                                                ;longdiv
  TST.b optimize_integer : BNE.s 'l10
    MOVE.w #$CB01,D1
    BRA.w domylib
 'l10

  CNIF #optibreak
    ILLEGAL
  CEND

  BSR.w savereg
  MOVE.l D4,D1
  BSR.w pokemovem
  BSR.w PutRegXToD0
;   MOVE.l destpointer,a4
;   MOVEQ.l #2,d1                                           ;have problem on negative float
;   MOVE.l d3,-(a7)                                         ;-18/8 =-3 should be -2
;   MOVEQ #1,d3
;
; 'ag
;       CMP.l -4(a4),d1
;       BEQ 'oklsr
;       LSL.l #1,d1
;       ADD.l #1,d3
;       CMP.l #9,d3
;       BNE 'ag
;   MOVE.l (a7)+,d3
   MOVE.l #$4c410800,d1
   BSR writelong

 'weit
  MOVE.w ##opcode_NOP,d1
  ;bsr writeword
  BSR.w PutD0ToRegX
  MOVE.l D5,D1
  BRA.w pokemovem

 'oklsr
  CMP.w #8,d3
  BEQ 'ok
    ASL.l #1,d3
    ASL.l #8,d3
    MOVE.w #$e080,d1
    OR.w d3,d1
    BRA 'oklsr2
 'ok
    MOVE.w #$e080,d1                                         ;lsr.l #,dx
 'oklsr2
  SUBQ.l #6,destpointer
  BSR writeword
  MOVE.l (a7)+,d3
  MOVEQ #0,d1
  CLR.l load_var_addr
  CLR.l imm_addr
BRA pokemovem


do_Div_quick:
  MOVE.w #$CB00,D1                                         ;quickdiv
BRA.w domylib


do_Div_float:
  TST.b iee : BNE 'fdiv1
    MOVE.w #$FFAC,D1                                       ;floatdiv
    BRA.w doflib
 'fdiv1
 
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ADDQ #1,d0
  ASL.w #8,d0
  ASL.w #2,d0
  MOVE.l #$f2000020,d1                                     ;fpu div
  OR.l d0,d1
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.l d0,d1
BRA.w writelong

;-----------end of DIVIDE, start of AND-----------;
do_AND_byte:
  MOVE.w #$C000,D1
BRA.w doplus2

do_AND_word:
  MOVE.w #$C040,D1
BRA.w doplus2

do_AND_long:
  MOVE.w #$C080,D1
BRA.w doplus2

;-----------end if AND, start of OR---------------;
do_OR_byte:
  MOVE.w #$8000,D1
BRA.w doplus2


do_OR_word:
  MOVE.w #$8040,D1
BRA.w doplus2


do_OR_long:
  MOVE.w #$8080,D1
BRA.w doplus2

;-----------end if OR, start of EOR---------------;
do_EOR_byte:
  MOVE.w #$B100,D1

doeor2:
   MOVE.w regnum,D3
  OR.w D3,D1
  ADDQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
BRA.w writeword


do_EOR_word:
  MOVE.w #$B140,D1
BRA.w doeor2


do_EOR_long:
  MOVE.w #$B180,D1
BRA.w doeor2

;-----------end of OR, start of LSL---------------;
do_LSL:
  MOVE.w #$E1A8,D1
BRA.w shpoke

;-----------end of LSL, start of LSR--------------;
do_LSR:
  MOVE.w #$E0A8,D1
BRA.w shpoke

;-----------end of LSR, start of ASR--------------;
do_ASR:
  MOVE.w #$E0A0,D1
BRA.w shpoke
;-----------------end of ASR----------------------;
do_ROL_b:
  MOVE.w #$E138,D1
BRA.w shpoke

do_ROL_w:
  MOVE.w #$E178,D1
BRA.w shpoke

do_ROL_l:
  MOVE.w #$E1B8,D1
BRA.w shpoke

do_ROR_b:
  MOVE.w #$E038,D1
BRA.w shpoke

do_ROR_w:
  MOVE.w #$E078,D1
BRA.w shpoke

do_ROR_l:
  MOVE.w #$E0B8,D1
BRA.w shpoke



shpoke:
  MOVE.w D1,-(A7)
  ADDQ.w #1,regnum   ;make second a word!
  MOVE.w D2,-(A7)
  MOVE.w D2,D3
  MOVEQ.l #$02,D2

  ; new >
 'l1
   ;MOVE.b notypecheck,-(a7)
   ;MOVE.b #1,notypecheck
  ; < new
   BSR.w writeconvertcode
  ; new >
   ;MOVE.b (a7)+,notypecheck
  ; < new
  MOVE.w (A7)+,D2     ;type
  SUBQ.w #1,regnum
  CMP.w #$4,D2        ;don't fuck with quix
   BEQ.w 'skip
  MOVE.w D2,D3
  MOVEQ.l #$03,D2
   BSR.w convtypef    ;make first (and current) a long

 'skip
   MOVE.w (A7)+,D1
  ;
  MOVE.w regnum,D3
  OR.w D3,D1
  ADDQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
BRA.w writeword

;-----------start of bittst-----------------;
_BitTst:
  MOVE.w #$0100,D1
   BSR.w dothebit
  ;
  MOVE.w regnum,D1
  ORI.w #$56C0,D1    ;sne regat
   BSR.w writeword
  ;
  MOVE.w regnum,D1
  ORI.w #$4880,D1    ;ext.w D regat
   BSR.w writeword
  ;
  MOVEQ.l #$02,D2    ;type now WORD!
RTS


_BitSet:
  MOVE.w #$01C0,D1

dothemip:
   BSR.w dothebit
  ;
  MOVEQ.l #$03,D2    ;type now LONG!
RTS


_BitClr:
  MOVE.w #$0180,D1
BRA.w dothemip


_BitChg:
  MOVE.w #$0140,D1
BRA.w dothemip


dothebit:
  MOVE.w D1,-(A7)
  ;
  ;make first a long
  ;
  MOVE.w D2,-(A7)
  MOVE.w D2,D3
  MOVEQ.l #$03,D2         ;first to long!
   BSR.w convtypef
  ;
  MOVE.w (A7)+,D3
  MOVEQ.l #$01,D2         ;second to byte!
  ADDQ.w #1,regnum
   BSR.w writeconvertcode
  SUBQ.w #1,regnum
  ;
  MOVE.w regnum,D1
  MOVE.w D1,D2
  ADDQ.w #1,D2
  LSL.w #8,D2
  LSL.w #1,D2
  OR.w (A7)+,D1
  OR.w D2,D1
BRA.w writeword        ;btst regat+1,regat


PutRegXToD0:               ;put regat to d0
  MOVE.w regnum,D1
  BEQ.w 'skip
    ORI.w #$2000,D1
    BSR.w writeword
    ADDI.w #$201,D1
    BSR.w writeword
 'skip
RTS


PutD0ToRegX:                 ;get regat from d0
  MOVE.w regnum,D1
  BEQ.w 'skip
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$2000,D1
    BSR.w writeword
 'skip
RTS


getelement:                                               ; code only when debuggercode is enabled
  ;TRAP #1
  ; new >
  CLR.b isconstantvalue
  CLR.l lastconstantvalue
  ; < new
  CMPI.w #$7,regnum : BCS.w getelement2

  ; new >
  TST.b optimize_fpu : BEQ.b 'nofpu
    MOVE.l #$f2277700,d1                                    ; fmove.d fp6,-(a7)
    BSR writelong
 'nofpu

  MOVE.w #$2F06,D1                                        ; d6 to stack
  ; < new
  ;MOVE.w #$3F06,D1                                       ; d6 to stack
  CMP.w #$3,D2 : BCS.w 'skip
    MOVE.w #$2F06,D1
 'skip
  BSR.w writeword
  MOVE.w D1,-(A7)
  ;
  SUBQ.w #1,regnum
  BSR.w getelement2

  ADDQ.w #1,regnum
  ;
  ; new >
  TST.b optimize_fpu : BEQ.b 'nofpu1
    MOVE.l #$f2001b80,d1
    BSR writelong
 'nofpu1
  ; < new
  MOVE.w #$3E06,D1
  CMP.w #$3,D2 : BCS.w 'skip2
    MOVE.w #$2E06,D1
 'skip2
  BSR.w writeword
  ;
  MOVE.w (A7)+,D1
  ANDI.w #$F000,D1
  ORI.w #$C1F,D1
  JSR writeword
  ; new <

  TST.b optimize_fpu : BEQ.b 'nofpu3
    MOVE.l #$f21f5700,d1                                     ;fmove.d (a7)+,fp6
    BRA writelong
 'nofpu3
  RTS
  ; < new


negate:
  BSR.w getelement2
  MOVE.w #$4440,D1
  CMP.w #$3,D2 : BCS.w 'doneg
  MOVE.w #$4480,D1
  CMP.w #$5,D2 : BCS.w 'doneg
  CMP.w #$6,D2 : BCC.w illoperr
  MOVE.w #$FFC4,D1   ; was -60
BRA.w fdo2

 'doneg
  OR.w regnum,D1                                           ;negate
  ; new >
  CLR.l imm_addr
  ; < new
BRA.w writeword


bracket:                                                 ;eval between brackets
  BSR.w eval4
  CMP.w #")",D0 : BEQ.w 'done
  CMP.w #"}",D0 : BNE.w brackets_                        ;syntax error brackets

 'done
BRA.w get1bytemain


notit:
  BSR.w eval4
  CMP.w #$5,D2 : BCC.w illoperr                          ; datatype string
  
  MOVE.w regnum,D1
  ORI.w #$4640,D1                                       ; opcode "not.w"
  CMP.w #$3,D2 : BCS.w writeword
  EORI.w #$C0,D1
BRA.w writeword


fetch_Pi:
  MOVEQ.l #$05,D2                                       ; return Pi.;move.l #x,dnf

  TST.b optimize_fpu : BEQ 'old
    JMP fpu_pi
 'old
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1 : BSR.w writeword                        ;move.l #x,dn
  MOVE.l #$C90FDA42,D1
  BSR.w writelong
BRA.w get1bytemain


;forth stack contains.....
;-- 00 pc.l,
;-- 04 firstoff.l
;-- 08 optat.l
;-- 12 lasta6.w
;-- 14 0
;-- 16 constgot.w!
;--
;-- 18 bytes!

forthstack:  Ds.b 32 * 18
forthsp:     Dc.l forthstack


JUMP_checkcast     JMP checkcast
JUMP_syntaxerropt4 JMP syntaxerropt4

getelement2:
  ;--
  ;-- recursive stuff first.....
  ;--
  ;bsr.w get1bytemain
  ; new >
  !fget
  CMP.b #127,d0 :  BNE 'noc             ; ~
    SUBQ.l #1,a5
    BSR get1bytemain
 'noc

  CMP.b #"#",d0 :  BNE 'ld1
    CMP.b #$22,(a5) :  BNE 'ld1         ; " 
      JSR addimmi
 'ld1

  CMP.b #$22,d0 : BNE 'l11              ; "
   ;BTST #$d,vartype : BNE 'ls1
   ;CMP.b #7,d2 : BEQ 'ls1               ;long pointer string error
   ;TST.b vartype+1 : BEQ 'ls1
   ; BRA error_convert_types
   ;'ls1
    NOT.w instringon
 'l11
  TST.b d0 : BPL 'l10
    LSL.w #8,d0
    MOVE.b (a5)+,d0                      ; get blitzlib instruction with returnvalue(called in functions/statement)
    MOVE.l d0,lasttoken
    MOVE.w d0,lastchar
    CLR.l rightsidetype                  ; blitzlibs do currently no type check
    CLR.w rightsideflagmask
 'l10
  CMP.w #"(",D0 : BEQ.w JUMP_checkcast
  nocast:                                   ; used from .checkcast
  CMP.w #"{",D0          : BEQ.w bracket
  CMP.w #"-",D0          : BEQ.w negate
  CMP.w ##TokenID_Not,D0 : BEQ.w notit      ; was #(opnot-opabcd)/$1c+$8000+fnum,
  
  ;
  MOVEA.l forthsp(PC),A1
  CMPA.l #forthsp,A1 : BCC.w conmemerr
  ;
  MOVE.l destpointer,(A1)+
  MOVE.l hunkoffsetbase,(A1)+
  MOVE.l lasta6,(A1)+
  MOVE.w lasta6,(A1)+
  CLR.w (A1)+
  ;
  CLR.w (A1)+
  MOVE.l A1,forthsp

  ;--
  ;-- First, we have stuff which won't fuck constgot
  ;--
  !test_for_literal         : BEQ.w fetch_DecValue
  CMP.w #".",D0             : BEQ.w fetch_FracValue
  CMP.w #"$",D0             : BEQ.w fetch_HexValue
  CMP.w #"%",D0             : BEQ.w fetch_BinValue
  CMP.w #"#",D0             : BEQ.w fetch_Constant

  CMP.w ##TokenID_SizeOf,D0 : BEQ.w fetch_SizeOf
  CMP.w ##TokenID_Pi,D0     : BEQ.w fetch_Pi
  CMP.w ##TokenID_On,D0     : BEQ.w fetch_On
  CMP.w ##TokenID_Off,D0    : BEQ.w fetch_Off

  MOVE.w constmode,D1 : BEQ.w 'noasm            ; assembler constant mode
    !test_for_letter : BEQ.w fetchasm
    CMP.w #"_",D0 : BEQ.w fetchasm
    CMP.w #$22,D0 : BEQ.w fetchqasm   ;'"'   
    BRA.w syntaxerr
 'noasm

  MOVE.w cfetchmode,D1 : BEQ.w 'asmok
     BRA.w badconerr                                             ;we're trying to get a const here!
 'asmok

  NOT.w -(A1)              ;set forth stack type to non-const

  ;--
  ;-- Here, we have stuff which will fuck it!
  ;--
  !test_for_letter: BEQ.w variable
  CMP.w #"*",D0   : BEQ.w variable
  CMP.w #"\",D0   : BEQ.w variable
  CMP.w #$22,D0   : BEQ.w litstring  ; '"'
  BTST #$F,D0     : BNE.w f_unction
  CMP.w #"&",D0   : BEQ.w getvaraddr ; jump to & address of var code
  CMP.w #"?",D0   : BEQ.w qmark
  ;
  ; new >
 ;.atmode_iff
  CMP.b #"@",d0   : BNE syntaxerr
  TST.b optimize_newsyntax : BEQ JUMP_syntaxerropt4

  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1                         ;move.l #,d0
  BSR.w writeword
  CMP.b #$22,(a5) : BNE syntaxerr   ;'"'

  ADDQ #1,a5
  MOVEQ #0,d0
  CMP.b #1,d2 : BEQ 'l3b
  CMP.b #2,d2 : BEQ 'l2b
  CMP.b #4,d2 : BEQ error_convert_types

  MOVE.b (a5)+,d0 : BEQ syntaxerr
  CMP.b #$22,d0 : BNE 'l1                     ;'"'
    MOVE.b #0,d0
    BRA 'do
 'l1
  ASL.l #8,d0
  
  MOVE.b (a5)+,d0 : BEQ syntaxerr
  CMP.b #$22,d0 : BNE 'l2                     ;'"'
    MOVE.b #0,d0
    ASR.l #8,d0
    BRA 'do
 'l2
  ASL.l #8,d0

 'l2b
  MOVE.b (a5)+,d0 : BEQ syntaxerr
  CMP.b #$22,d0 : BNE 'l3                     ;'"'
   MOVE.b #0,d0
    ASR.l #8,d0
    BRA 'do
 'l3
  ASL.l #8,d0

 'l3b
  MOVE.b (a5)+,d0 : BEQ syntaxerr
  CMP.b #$22,d0 : BNE 'l4                    ;'"'
    MOVE.b #0,d0
    ASR.l #8,d0
    BRA 'do
 'l4
  CMP.b #$22,(a5)+ : BNE error4char          ;'"'

 'do
  MOVE.l d0,d1
  BSR writelong
  BSR get1bytemain
RTS
  ; < new


fetch_SizeOf:   ;was _SizeOf
  BSR.w get1bytemain
  
  CMP.w #".",D0 : BEQ.b sizeobj
    ;--
    ;-- find size of a var!
    ;--
    BSR.w bakup

    MOVE.w D2,-(A7)

    BSR.w getparameter2 : BEQ.w syntaxerr

    LEA varbase,A2
    BSR.w findvariable : BNE.w notypeerr

    MOVE.w 4(A2),D3
    EXT.l D3
    BRA.w jty2
  sizeobj:

    MOVE.w D2,-(A7)

    BSR.w getparameter2 : BEQ.w syntaxerr
    
    LEA newtypebase,A2
    BSR.w findtype : BNE.w notypeerr

    MOVEQ.l #$00,D3
    CMP.w #"\",D0 : BNE.w 'jty
      BSR.w getparameter2 : BEQ.w syntaxerr

      LEA 4(A2),A2
      BSR.w findvariable2 : BNE.w noofferr

      MOVE.w 4(A2),D3
      BRA.w jty2
   'jty
      MOVE.w 8(A2),D3
   jty2:
      MOVE.w (A7)+,D2
BRA.w fetchnum2


fetch_On:
  MOVEQ.l #-$01,D3
  BSR.w get1bytemain
BRA.w fetchnum2


fetch_Off:
  MOVEQ.l #$00,D3
   BSR.w get1bytemain
BRA.w fetchnum2


is_Hex:       ; was chkhex org source
  ;is d0 a hex number?
  ;
  CMP.w #$30,D0 : BCS.w 'no     ;'0'
  CMP.w #$39,D0 : BLS.w 'yes    ;'9'
   
  ANDI.w #$FFDF,D0
  CMP.w #$46,D0 : BHI.w 'no     ;'F'
  CMP.w #$41,D0 : BCS.w 'no     ;'A'

 'yes
  CMP.w D0,D0

 'no
RTS


is_Bin:
  CMP.w #$31,D0 : BEQ.w 'ok    ;'1'
    CMP.w #$30,D0              ;'0'
 'ok
RTS


; new >
get_hexbyte
   MOVEQ #0,d0
   MOVE.b (a5)+,d0
   MOVE.b (a5)+,d0
   BSR is_Hex
   BNE syntaxerr
   SUBI.w #$30,D0
   CMP.w #$9,D0
   BLS.w 'l1
   SUBQ.w #7,D0

 'l1
   MOVE.l d0,d1
   MOVE.b (a5)+,d0
     BSR is_Hex
    BNE syntaxerr
    LSL.l #4,d1
    SUBI.w #$30,D0
   CMP.w #$9,D0
   BLS.w 'l2
   SUBQ.w #7,D0

 'l2
  ADD.l d1,d0
RTS
; < new

fetch_HexValue:     ;was fetchhex org source
  BSR.w get1bytemain
  BSR.w is_Hex : BNE.w syntaxerr

  MOVEQ.l #$00,D3
  ; new >
  CMP.w #5,d2 : BNE 'loop                     ; is it a float ?
  
  CMP.l #newtype_float,a2 : BNE 'loop
  
  ;CMP.l #newtype_double,a2 : BNE 'loopa

  TST.b optimize_fpu :  BEQ.b 'nofpu
    fmove.s #0,fp0
 'nofpu

 'loopa
  TST.b optimize_fpu : BEQ 'loop
    fmove.w #16,fp1
    fmul.x fp1,fp0
    SUBI.w #$30,D0
    CMP.w #$9,D0 : BLS.w 'skipa
      SUBQ.w #7,D0
   'skipa
    fmove.w d0,fp1
    fadd.x fp1,fp0
    BSR.w get1bytemain
    BSR.w is_Hex
    BEQ.w 'loopa
    BRA.w nofpregload
    ; < new
 'loop
    CMP.l #$10000000,D3 : BCC.w overerr

    LSL.l #4,D3
    SUBI.w #$30,D0
    CMP.w #$9,D0 : BLS.w 'skip
      SUBQ.w #7,D0
   'skip
    OR.w D0,D3
    BSR.w get1bytemain
    BSR.w is_Hex
  BEQ.w 'loop
BRA.w fetchnum2


fetch_BinValue:
  BSR.w get1bytemain
  BSR.w is_Bin :  BNE.w syntaxerr

  MOVEQ.l #$00,D3
 'loop
    LSL.l #1,D3 : BCS.w overerr

    SUBI.w #$30,D0
    OR.w D0,D3
    BSR.w get1bytemain
    BSR.w is_Bin
  BEQ.w 'loop
BRA.w fetchnum2


fetch_Constant:     ; was fetchconst org source
  MOVE.w d2,-(A7)
  ; new >
  MOVE.b #0,automode

  CMP.b #"@",(a5) : BNE 'l1
    ADDQ.l #1,a5
    MOVE.b #1,automode
    BSR getparameter2
    BSR findlabel2 : BNE 'addit
      BRA errormsg_autocount
   'addit
    BSR.w add_LabelHash
    MOVE.l #$1,4(A2)
    MOVEM.l a2/a5,-(a7)
    MOVE.w lastchar,-(a7)
    LEA autostorename,a5
    BSR getparameter2
    BSR findlabel2 : BEQ 'found
      BSR.w add_LabelHash
      MOVE.l #$1,4(A2)
      MOVE.l #0,8(a2)
   'found
    MOVE.w (a7)+,d0
    MOVE.w d0,lastchar
    MOVE.l 8(a2),d3
    ADD.l #1,8(a2)
    MOVEM.l (a7)+,a2/a5
    MOVE.l d3,8(a2)
    MOVE.l 8(A2),D3
    BRA.l 'l3
 'l1
    ; < new
    BSR.w getparameter2
    ; new >
    TST.b incnif : BEQ 'lc1
      BSR.w findlabel2 : BNE 'l5
        MOVEQ #1,d3
        MOVE.w (A7)+,D2
        BRA fetchnum2
     'l5
      MOVEQ #0,d3
      MOVE.w (A7)+,D2
      BRA fetchnum2
   'lc1
    ; < new
    BSR.w findlabel2
    BNE.w cnferr

   'l2
    CMPI.l #$1,4(A2) : BNE.w cnferr

 'l3
  MOVE.l 8(A2),D3
  MOVE.w (A7)+,D2
BRA.w fetchnum2     ;to right type.


getvaraddr:    ; was ampersand
  ; new >
  CLR.w vartype
  MOVE.b #3,peekaddrsize
  ; < new
  BSR.w ampersand2
  ; new <
  MOVE.l a2,rightsidetype
  MOVE.w flagmask,rightsideflagmask
  ; < new
  MOVEQ.l #$03,D2
RTS


ampersand2:                             ; "@"-Symbol
  BSR.w get1bytemain
  ; new <
  !test_for_literal : BEQ andop2
  ; < new
  BSR.w getparameter
  BSR.w fetchvars
  BSR.w calcvar
  ;
  CMP.b #$7,D2 : BNE.w 'notst
    BTST #$F,D2 : BNE.w 'algot2
      MOVE.w D3,stamp2+2
      MOVE.l stamp2,D1
      BSR.w pokela5s
      BRA.w 'algot
   'algot2
    MOVE.w regnum,D1
    LSL.w #8,D1
    LSL.w #1,D1
    OR.w stamp,D1
    BSR.w writeword
    RTS
 'notst
  BTST #$F,D2 : BNE.w 'algot
    MOVE.w D3,leaamp+2
    MOVE.l leaamp,D1
    BSR.w pokela5s
 'algot
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w leaamp2,D1
BRA.w writeword


doern:
  ;-- read err number
  MOVE.w #$D200,D1 : BSR.w Atokejsr                      ; was #ern,  getErrorNum
  MOVEQ.l #$03,D2
RTS


;------                                                  ;disassembled code begin
addrcode:  Dc.w $206D,$0000                              ;MOVEA.L $0000(A5),A0
           Dc.w $D0C0                                    ;ADDA.W  D0,A0
           Dc.w $2008                                    ;MOVE.L  A0,D0
addrcodef:
;------                                                  ;disassembled code end


fetchit:
  BSR.w get1bytemain
  MOVE.w D0,D1 : BPL.w syntaxerr
  
  MOVE.w D2,-(A7)
  BCLR #$F,D1 : BSR.w JMP_searchinstr
  
  MOVE.l 18(A2),D0
  TST.w -$2(A2,D0.L) : BEQ.w freeerr

  MOVE.w (A7)+,D2
RTS

JMP_searchinstr: JMP searchinstr

usedcode:
  MOVE.l $0(A5),D0 : BNE.b ucodeskip
  MOVEQ.l #-$01,D0
    BRA.b usedcodef

ucodeskip:
  SUB.l $0(A5),D0

ucodediv:
  LSR.w #8,D0
usedcodef:   ;


usedcode2:
   MOVE.l $0(A5),D0
   BNE.b ucodeskip2
  MOVEQ.l #-$01,D0
BRA.b usedcode2f

ucodeskip2:
  SUB.l $0(A5),D0                                          ;usedcode2
  LSR.w #8,D0

ucodediv2:
  LSR.w #8,D0
usedcode2f:  ;


usedprep:
  MOVE.l D0,-(A7)

useddone:
  MOVE.l (A7)+,D0

usedfix:
  MOVE.l D0,D0


doused:
    ;return 'used' object.
    ;
  BSR.w fetchit
    ;
  MOVE.w -$2(A2,D0.L),D3
  CMP.w #$9,D3
   BCC.w 'skip
    ;
    ;shift 1-8
    ;
  LEA usedcode(PC),A0
  LEA usedcodef(PC),A1
    ;
  ANDI.w #$F1FF,$E+4(A0)                                   ;and #$f1ff,ucodediv-usedcode(a0) org source
  ANDI.w #$7,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,$E+4(A0)                                         ;or  d3,ucodediv-usedcode(a0) org source
 BRA.w 'skip2

 'skip
    ;shift 9+
    ;
  LEA usedcode2(PC),A0
  LEA usedcode2f(PC),A1
    ;
  ANDI.w #$F1FF,$10+4(A0)                                  ;and #$f1ff,ucodediv2-usedcode2(a0) org source
  SUBQ.w #8,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,$10+4(A0)                                        ;or  d3,ucodediv2-usedcode2(a0) org source

 'skip2
  MOVE.w -$6(A2,D0.L),D3
  MOVE.w D3,$C+4(A0)                                       ;move d3,ucodeskip-usedcode+2(a0) org source
  ADDQ.w #4,D3
  MOVE.w D3,$2(A0)
  MOVE.w regnum,D1
   BEQ.w 'skip3
  MOVE.w usedprep(PC),D1
   BSR.w writeword

 'skip3
  BSR.w pokecode
  MOVE.w regnum,D1
   BEQ.w 'skip4
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w usedfix(PC),D1
   BSR.w writeword
  MOVE.w useddone(PC),D1
   BSR.w writeword

 'skip4
   MOVEQ.l #$02,D2
BRA.w get1bytemain


domaximum:
  ;number of maximums
  ;
  ;eg a=Maximum Shape
  ;
   BSR.w fetchit
  ;
  MOVEQ.l #$00,D3
  MOVE.w -$4(A2,D0.L),D3
   BSR.w get1bytemain
BRA.w fetchnum2


doaddr:
  ;address of something
  ;eg a.l=Addr Window(0)
  ;
  BSR.w get1bytemain    ;get the token
  MOVE.w D0,-(A7)
  BSR.w get1bytemain    ;and the bracket?
  CMP.w #"(",D0 : BNE.w syntaxerr

  MOVE.w (A7)+,D0
  BSR.w getmaxel
  BSR.w reget
  CMP.w #")",D0 : BNE.w syntaxerr
  ;
  ;OK, now a2=lib it's from
  ;
  LEA addrcode(PC),A0
  LEA addrcodef(PC),A1
  MOVE.w -$6(A2),$2(A0) ;x(a5)
  MOVE.w $4(A0),D1
  ANDI.w #$FFF8,D1
  OR.w regnum,D1
  MOVE.w D1,$4(A0)      ;add Dregat,a0
  MOVE.w $6(A0),D1
  ANDI.w #$F1FF,D1
  MOVE.w regnum,D0
  LSL.w #8,D0
  LSL.w #1,D0
  OR.w D0,D1
  MOVE.w D1,$6(A0)      ;move.l a0,Dregat
   BSR.w pokecode
  MOVEQ.l #$03,D2       ;now a long
BRA.w get1bytemain



f_unction:       ; was function
  ;do a function
  CMP.w ##TokenID_List,D0 : BHI.w 'overasm             ;first Token after asm-tokens
    BRA.w syntaxerr
 'overasm                                              ; varassign lib commands. $b581 Null from lotanlib

 ; new >
.do_null: ;(blitzlib Elmoresyslib)
  CMP.w ##TokenID_Null,d0 : BNE 'nonull                ; #$b594-$8000 check for lib 107 token "NULL" form elomorsyslib
    MOVE.l d0,lastinstruction
    MOVE.w #$7000,d1                                   ; ; MOVEQ#0,D0
    MOVE.w regnum,d0
    ASL.l #7,d0
    ASL.l #2,d0
    OR.l d0,d1
    BSR writeword
    JSR get1bytemain
    RTS
 'nonull
  CMP.w ##TokenID_New,d0 : BNE nonew_                  ; $c982-$8000=$4982 check for lib 147 token $4982 "New" from LotanSystem


.do_new: ;(blitzlib LotanSystem)
  MOVE.l a5,-(a7)
  MOVE.w lastchar,-(a7)
  JSR get1bytemain

  CMP.w #"(",d0 :   BNE 'newcode                             ; use oldcode
    JSR get1bytemain
    CMP.w #")",d0 : BEQ 'newcode
        MOVE.w (a7)+,lastchar
        MOVE.l (a7)+,a5
        MOVE.w lastchar,d0
        BRA nonew_
 'newcode

  MOVE.l a0,-(a7)
  TST.b blitzparloop : BNE 'err
    TST.b funcparloop :  BNE 'err
      BRA 'ok
 'err
    JMP errornewnotincalls
 'ok
  MOVE.l #$203c0000,d1 :  BSR writelong                 ; 68k asm move.l #$xx,d0
  MOVEQ #0,d1
  MOVE.w 8(a0),d1
  BSR writeword
  MOVE.w #$7200,d1     :  BSR writeword                 ; 68k asm "moveq #0,d1" 

  MOVE.w #$C002,D1     :  BSR.w tokejsr2                ;call function to alloc global mem

  MOVE.l (a7)+,a0
  ADDQ.l #6,a7                      ; a5 need not restore
  CMP.w #")",d0 : BNE 'nobracket
    JSR get1bytemain
 'nobracket
RTS

nonew_
  ; < new
  CMP.w ##TokenID_Ern,D0     : BEQ.w doern      ; was #$8003+tnum,
  CMP.w ##TokenID_Addr,D0    : BEQ.w doaddr     ; was #$8005+tnum,
  CMP.w ##TokenID_Maximum,D0 : BEQ.w domaximum  ; was #$8011+tnum,
  CMP.w ##TokenID_Used,D0    : BEQ.w doused     ; was #$801e+tnum,
  ;
  MOVE.w D2,-(A7)       ;remember old type!
  MOVE.w D0,D1
  BCLR #$F,D1
  ; new >
  ;CLR.b quickpeek
  ; < new
  JSR searchinstr       ; BSR.w
  MOVE.w (A3),D1
  BTST #$1,D1 : BEQ.w noreturn_                                         ;syntax error noreturn
  BTST #$2,D1 : BNE.w amigalib
  ;
libfunction:
  ;do a user library function -
  ;eg a=pixel{x,y}
  ;
  LSR.w #8,D1
  BTST #$3,$1(A3) :  BEQ.w 'no0
    JSR sizespec2
 'no0
  ; new >
  CLR.l rightsidetype
  CLR.w rightsideflagmask
  ; < new
  MOVE.w D1,-(A7)                                         ;is library instruction
  CMP.w #$7,D1 :  BNE.w 'notst0
    MOVE.l A2,-(A7)
    BSR.w makesbase
    MOVEA.l (A7)+,A2
 'notst0
  BSR.w savem
  MOVE.w D3,-(A7)        ;the movem regs
  ;
  BSR.w get1bytemain
  MOVEQ.l #$00,D1
  CMP.w #"(",D0 : BNE.w 'nopars
    JSR countpees
    TST.w D1 : BEQ.w syntaxerr    
      BRA.w 'skip0
 'nopars
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new

 'skip0                               ; IMPORTANT: Dont add more values to stack until 'no2
  MOVE.w regnum,-(A7)
  ; new >
  MOVE.w regnum,regnumstore
  TST.b optimize_fpu : BEQ 'nofloat
    CMP.w #$ffff,28(a3) : BNE 'nofloat
    CMP.w #$3c01,34(a3) : BEQ 'nofloat        ;val do nofpu stuff
    CMP.w #$3c02,34(a3) : BEQ 'quick1         ;int skip
      CMP.b #5,(a3) : BNE 'nofloat
   'quick1
    CLR.l load_var_addr
    BRA 'isfpu
 'nofloat                                                 ; regnum clear, when a function is call  in a function
  ; new >
  CLR.w regnum

 'isfpu
  MOVE.w D1,-(A7)
  BTST #$3,$1(A3) : BEQ.w 'no2
  ; new >
;   TST.b optimize_integer
;   BEQ 'l2a
;   CMP.w #$ffff,24(a3)
;   BNE 'l2a
;   CMP.w #$5a02,30(a3)                                     ;peek
;   BNE 'l2a
;  MOVE.w $6(A7),D1
;  MOVE.w d1,peeksize
;  TST.b optimize_fpu
;  BEQ 'l2a
;  CMP.w #5,d1                                              ;is float on fpu
;  BNE 'l1a
;  ;MOVE.b #1,quickpeek
;
; 'l1a
; BRA 'l11

 'l2a
  ; < new
  MOVE.w $6(A7),D1
  ; new >
  MOVE.w d1,peeksize
;  CMP.w #$5a02,30(a3)                                      ;peek
;  BNE 'l10
;  CMP.b #7,d1                                              ;optimize dont work in PeekW(PeekW))
;  BEQ 'l10
;  TST.b optimize_integer
;  BEQ 'l10
; BRA 'l11

; 'l10
  ; < new
  ORI.w #$7000,D1                                           ; MOVEQ#0,D0
  BSR.w writeword                                          ;write peekmode

; 'l11
  ADDQ.w #1,regnum
  MOVE.w (A7),D1

 'no2
  ; new >
  MOVE.w 2(a7),tempregnum
  MOVE.w parnum,-(a7)                                       ;7.2014 parnum need store to allow functioncall in parameter >6
  CLR.w parnum                                              ;7.2014
  ; < new
  JSR dolibtoke                                             ;write code of blitzfunc
  ; new >
  MOVE.w (a7)+,parnum                                       ;7.2014 new restore parnum
  ; < new
  TST.w (A7)+
  BEQ.w 'skip
  CMP.w #")",D0                                             ; check if ) here for correct end of blitzlib function call
  BNE.w errorbracketmiss                                    ; was syntax error
  ; new >
  CLR.l lasttoken
  ; < new
  BSR.w get1bytemain

 'skip
  MOVE.w (A7)+,D1
  MOVE.w D1,regnum
  BEQ.w 'skip2
  ; new >
  CMP.w #$3c01,24(a2)                                     ;val skipped
  BNE 'noval
    TST.b optimize_fpu
    BEQ 'noval
      CLR.l load_var_addr
      MOVEQ #0,d1
      MOVE.w regnum,d1
      LSL.l #7,d1
      OR.l #$f2000000,d1                                     ; opcode: fmove.x fp0       FPU-check: ok
      BSR writelong
      BRA 'skip2
 'noval
  CMP.w #$3c02,24(a2)                                     ;int skipped
  BEQ 'quick
    CMP.b #5,d2
    BNE 'nofpu2
    TST.b optimize_fpu
    BEQ 'nofpu2
    ;CLR.l load_var_addr
    ;BRA 'nofpu2
 'quick
    CLR.l load_var_addr
    BRA 'skip2
 'nofpu2
  ; < new
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2000,D1
  BSR.w writeword      ;move.l d0,regat                                    ;write move.l d0,dx

  ; new >
  TST.b optimize_fpu
  BEQ 'skip2
    MOVEQ #0,d1
    MOVE.w regnum,d1
    LSL.l #7,d1
    OR.l #$f2000000,d1                                      ; opcode: fmove.x fp0       FPU-check ok
    ;BSR writelong
    ; < new
 'skip2
  MOVE.w (A7)+,D3
  BEQ.w 'nomovem
  ; new >
  TST.b optimize_fpu
  BEQ 'nofpu3
    MOVE.l d0,-(a7)
    MOVE.l a0,-(a7)
    MOVE.l stacktrack,d1
    LEA fpustackbase,a0
    MOVE.w 0(a0,d1),regmask
    MOVE.l (a7)+,a0
    MOVE.w #8,d0
 'loop
    BEQ 'ready
    BTST d0,regmask
    BEQ 'noa7
      MOVEQ #0,d1
      MOVE.w d0,d1
      SUBQ.w #1,d1
      ASL #7,d1
      ;OR.l #$f21f4400,d1                                   ;fmove.s (a7)+
      OR.l #$f21f5400,d1                                   ;fmove.d (a7)+
      BSR writelong
      SUBQ.l #2,stacktrack
   'noa7
    SUBQ.w #1,d0
  BNE 'loop

 'ready
  MOVE.l (a7)+,d0
  SUBQ.l #2,stacktrack                                 ;int track

 'nofpu3
  ; < new
  MOVE.w #$4CDF,D1 : BSR.w writeword                    ;write movem.l (a7)+,
  MOVEQ.l #$00,D1
  MOVEQ.l #$0F,D4

 'loopsw
  LSL.w #1,D3
  ROXR.w #1,D1
  DBF D4,'loopsw
  BSR.w writeword      ;poke movem (a7)+...
  ; new >
  TST.b optimize_integer : BEQ 'nomovem
    TST.w regnum : BEQ 'nomovem
    CMP.w #$3c0e,$1c(a3) : BNE 'l1b                         ;true
      MOVE.w regnum,d1
      ASL.l #8,d1
      ASL.l #1,d1
      OR.w #$70ff,d1
      SUB.l #12,destpointer
      BSR writeword
   'l1b
    CMP.w #$3c0f,$1c(a3) : BNE 'l2b                     ;false

      MOVE.w regnum,d1
      ASL.l #8,d1
      ASL.l #1,d1
      OR.w #$7000,d1                                          ; MOVEQ#0,D0
      SUB.l #12,destpointer
      BSR writeword
   'l2b                                                       ;??looks like double label??
  ; < new
 'nomovem

  MOVE.w (A7)+,D2
  CMP.w #$7,D2                                             ;destination var type
  BNE.w 'notst
    MOVE.w putstlen,D1
    OR.w regnum,D1
    BSR.w writeword
 'notst
BRA.w varcont



amigalib:
  MOVE.w $6(A3),D1
   JSR uselib           ;get lib for base address       BSR.w
   BSR.w savereg
  MOVE.l D4,D1
  MOVE.l D5,-(A7)
   BSR.w pokemovem
  MOVE.w $A(A1),-(A7)     ;libbase reg
  ADDQ.w #8,A3
  MOVE.w (A3)+,-(A7)      ;get offset for lib
  MOVE.l A3,-(A7)
   BSR.w get1bytemain
  MOVE.w D0,-(A7)         ;remember first bracket....
  ;
  ;collect longs for lib
  ;
  MOVEQ.l #$00,D3
  ; new >
  JSR checka4a5
  ; < new

 'loop
  MOVE.b (A3)+,D1
   BMI.w 'done
  MOVEQ.l #$03,D2
  ADDQ.w #1,D3
  MOVEM.l D3/A3,-(A7)
  ; new >
  MOVE.b funcparloop,-(a7)
  CLR.b funcparloop
  MOVE.b blitzparloop,-(a7)
  MOVE.b #1,blitzparloop
  MOVE.l lasttoken,-(a7)
  MOVE.l leftsidetype,-(a7)
  MOVE.l rightsidetype,-(a7)
  ; < new
  BSR.w peval
  ; new >
  MOVE.l (a7)+,rightsidetype
  MOVE.l (a7)+,leftsidetype
  MOVE.l (a7)+,lasttoken
  MOVE.b (a7)+,blitzparloop
  MOVE.b (a7)+,funcparloop
  ; < new
  SUBQ.w #4,a2offset              ;readjust stack! it's coming off later!
  MOVEM.l (A7)+,D3/A3
  CMP.w #",",D0 : BEQ.w 'loop
  TST.b (A3)    : BPL.w syntaxerr

 'done
  MOVE.w (A7)+,D1
   BSR.w tstbras
  MOVEA.l (A7)+,A3
  SUBQ.w #1,D3
   BMI.w 'nopars

 'toend               
  TST.b (A3)+                     ;go to end of params
   BPL.w 'toend
  SUBQ.w #1,A3

 'loop2
    MOVEQ.l #$00,D1
    MOVE.b -(A3),D1
    BTST #$4,D1
     BNE.w 'addreg
    CMP.w regnum,D1
     BCC.w 'nomovem
    BSET D1,D5
    MOVEQ.l #$0F,D0
    SUB.w D1,D0
    BSET D0,D4

   'nomovem
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$201F,D1
   BRA.w 'gotit

   'addreg
    ANDI.w #$7,D1
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$205F,D1

   'gotit
     BSR.w writeword
  DBF D3,'loop2

 'nopars
  MOVE.w (A7)+,libjsr+2
  MOVE.w (A7)+,libbase+2
  MOVE.l libbase,D1
   BSR.w writelong
  MOVE.l libjsr,D1
   BSR.w writelong
  MOVE.w regnum,D1
   BEQ.w 'nofin
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2000,D1
   BSR.w writeword

 'nofin
  MOVE.l (A7)+,D1
   BSR.w pokemovem
   ; new >
   JSR restorea4a5
   ; < new
  MOVEQ.l #$03,D2
   BSR.w reget
BRA.w varcont



tstbras:
  ;chk that d1 (first bra char) and d0 (last)
  ;are consistent with d3 (number of parameters)
  ;also, skip last if nec.
  ;
  TST.w D3 : BEQ.w 'nopars
    CMP.w #"(",D1 : BNE.w syntaxerr
    CMP.w #")",D0 : BNE.w syntaxerr
    
    BRA.w get1bytemain

 'nopars
    CMP.w #"(",D1 : BNE.w 'skip
      BSR.w get1bytemain
      CMP.w #")",D0 : BNE.w syntaxerr
        BRA.w get1bytemain
   'skip
RTS


pokemovem:
  TST.w D1 : BNE.w writelong
RTS


savereg:
  ;set up d4 for movem -(a7) and d5 for movem (a7)+
  MOVE.w #$48E7,D4
  SWAP D4
  CLR.w D4
  MOVE.w #$4CDF,D5
  SWAP D5
  CLR.w D5
  MOVE.w regnum,D1
   BEQ.w 'skip
  BSET #$F,D4
  BSET #$0,D5
  CMP.w #$2,D1
   BCS.w 'skip2

 'skip3
  BSET #$E,D4
  BSET #$1,D5

 'skip2
 RTS

 'skip
  TST.w fuckpos
  BNE.w 'skip3
RTS


fuckpos:  Ds.w 1


makesbase:
  MOVE.w sbasegot,D1
   BEQ.w 'skip
    ;
    ;S base has been got, was it for this Eval?
    ;
  MOVE.w sbgot(PC),D1
   BNE.w 'skip2
    ;
    ;No, push it on da stack!
    ;
  MOVE.w #$0002,sbgot
  MOVE.w movea3a7,D1
 BRA.w writeword

 'skip2
 RTS

 'skip                                         ;add tempstring
   ;no sbase got at all!                                              
   ;
  MOVE.w #$0001,sbgot                                      ;voodoo magic! - Will it work?

  MOVE.l #$C601,D1                  ; was #workstart,
  MOVE.w #-1,sbasegot               
  ; new >
  MOVE.l d1,lastinstruction
  ; < new
  BSR.w Atokejsr
RTS



litstring:
  MOVE.l data1,litdata1
  ; new >
  TST.b optimize_integer :BEQ 'l50                         ;optistring  seem impossible to get work
                                                           ;100% compatible see string$ for problems
                                                           ;only assign constant and case constant is activate
                                                           ;when on print "test",fi$  fail
  BRA 'l50                                                 ;to deactivate

  CNIF #optibreak
    ILLEGAL
  CEND

  TST.b optistring : BNE.s 'l21
  CLR.b string1
  MOVE.b #1,optistring
  TST.b nostringopt : BNE 'l21
  MOVE.l a5,a4
  SUBQ.l #1,a4

 'l10
    TST.b (a4) :  BMI 'l19a : BEQ.s 'l20
    CMP.b #$22,(a4) : BEQ.s 'l19                           ;'"'
    
 'l18
    TST.w string1  : BNE 'l11
    CMP.b #":",(a4): BEQ.s 'l20
    CMP.b #";",(a4): BEQ.s 'l20
    CMP.b #"+",(a4): BEQ.s 'l21
    CMP.b #",",(a4): BEQ.s 'l20                          ;was l21
    CMP.b #")",(a4): BEQ.s 'l20                          ;was l21

 'l11
  ADDQ.l #1,a4
  BRA.s 'l10

 'l19
  BCHG #0,string1
  BRA 'l18

 'l19a
  ADDQ.l #1,a4
  TST.b (a4) : BEQ 'l21
  BRA 'l11

 'l20
  MOVE.l a5,a4
  SUBQ.l #1,a4

 'll1
  CMP.b #" ",-(a4) : BEQ 'll1
  CMP.b #"+",(a4)  : BEQ 'l21
  ;CMP.b #",",(a4) : BEQ 'l22
  ;CMP.b #"(",(a4) : BEQ 'l22
  ; BRA 'l21
  ;CMP.b #"=",(a4) : BEQ 'l21
  ;CMP.b #">",(a4) : BEQ 'l21
  ;CMP.b #"<",(a4) : BEQ 'l21

 'l22
  MOVE.b #2,optistring

 'l21
  CMP.b #2,optistring : BEQ.s 'l100

 'l50
  BSR.w makesbase
  ; < new
  BSR.w pokedata1                                          ;writestringsizespace
  BSR.w pokedata1

 'l100
  MOVEQ.l #$00,D2

  ; new >
  'writestring:
    MOVE.l a5,lastsourcepos
    MOVEQ #0,d0
    MOVE.b (a5)+,d0
   ; < new
    TST.w D0 : BEQ.w notqerr

    CMP.w #$22,D0 : BEQ.w 'done                           ; --- " ---
     
   ; new >
    CMP.b #"\",d0 :     BNE 'l1
    CMP.b #"\",(a5) :     BNE 'l1
    TST.b optimize_newsyntax : BEQ 'l1
      CMP.w #"\\",1(a5) : BNE 'l2                          ; new compiler constants
        ADDQ #2,a5
   'l1
      ADDQ.w #1,D2
      MOVE.w D0,D1
      BSR.w pokedata1b                                        ;writestring
      BRA.w 'writestring
   'l2                                                       ;\\char//
    JSR check_newconstants
    BRA 'writestring

  ; < new
 'done
  ; new >
  NOT instringon
  ; < new
  MOVE.w dontwrite_nomemleft,D1 :  BNE.w 'skip
  ; new >
  CMP.b #2,optistring : BEQ 'skip
    ; < new
     MOVEA.l litdata1,A0
     CLR.w (A0)+                                            ;writesize
     MOVE.w D2,(A0)
 'skip

  BSR.w makelit                                          ;writestringconstantcode
  ADDQ.l #1,data1
  BCLR #$0,data1+3
  MOVEQ.l #$07,D2
BRA.w get1bytemain


makealab2:
  ; new >
  BSR.w makename2
  ; < new
  BSR.w findlabel2
  BEQ.w 'found
  ;
  BSR.w add_LabelHash
  CLR.l 4(A2)           ;no refs
  CLR.l 8(A2)           ;not created yet (no PC)
  ;clr.l 12(A2)          ;no data label
  MOVE.w linenumat+2,$10(A2)  ; was linenumat,    ;context
  ; new >
  MOVE.w linenumat,d0
  MOVEQ #0,d1
  MOVE.b -1(a2,d7),d1
  MOVE.w d0,0(a2,d1)
  ; < new
 BRA.w 'makeit

 'found
  TST.l 8(A2) : BNE.w 'gotit    ;already made
  ;
  ;create an oustanding reference to this label!
  ;

 'makeit
  MOVEA.l _execbase,A6
  MOVEQ.l #$0C+2,D0      ; was 12
  MOVE.l mempool,a0 : JSR _AllocPooled(a6)
  MOVEA.l D0,A0
  
  MOVE.l 4(A2),(A0)
  MOVE.l A0,4(A2)
  MOVE.l destpointer,$4(A0)
  ADDQ.l #2,$4(A0)
  MOVE.w procnum,$8(A0)
  MOVE.w linenumat+2,$A(A0)   ; was linenumat,
  ; new >
  MOVE.w linenumat,$c(a0)
  ; < new
 RTS

 'gotit
  MOVE.l 4(A2),D1
  BTST #$0,D1
   BNE.w illlaberr
  MOVE.w procnum,D1
  CMP.w $10(A2),D1
   BNE.w referr

 'skip
RTS


makelit:
  ;put lit string from d3 (data1) into stringbuff
  ;
  MOVE.w D0,-(A7)
  ; new >
  CMP.b #2,optistring : BEQ 'l10
    ; < new
    MOVE.w numtoa0,D1 : BSR.w writeword
    BSR.w addoff
    MOVE.l litdata1,D1: BSR.w writelong
    MOVE.w pushlen,D1 : BSR.w writeword
    MOVE.w #$C600,D1  : BSR.w Atokejsr        ; was #copstring   
    MOVE.w (A7)+,D0
    RTS
    ; new >
 'l10
  MOVEQ #0,d1
  BSR.w pokedata1b
  MOVE.l destpointer,a4
  MOVE.w #$203c,d1                          ;move.l #,d0
  TST.w mode : BNE 'lm10
    ADDQ.w #4,a2offset
    MOVE.w #$2f3c,d1
 'lm10

  TST.w mode : BEQ 'lm3
    MOVE.w regnum,D0
    LSL.w #8,D0
    LSL.w #1,D0
    OR.w d0,d1
    BSR writeword
    BSR.w addoff
    MOVE.l litdata1,D1
    BSR.w writelong
    CMP.w #3,mode : BEQ 'l30
      ADDQ.w #4,a2offset
      MOVE.w #$4878,D1
      BSR.w writeword
      MOVE.l d2,d1
      BSR writeword
   'l30
    MOVE.w (A7)+,D0
    RTS
 'lm3
  MOVE.l #$3f3c0007,d1
  BSR writelong
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2f3c,d1
  BSR writeword
   ADDQ.w #4,a2offset
  MOVE.l d2,d1
  BSR writelong
  MOVE.w #$2f3c,d1
  BSR writeword
  BSR.w addoff
  MOVE.l litdata1,D1
  BSR.w writelong
  MOVE.w (A7)+,D0
RTS
  ; < new


qmark:
  BSR.w get1bytemain
  BSR.w makealab2
  ;
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1
  BSR.w writeword        ;create move.l #loc,dn
  BSR.w addoff
  MOVE.l 8(A2),D1
  BSR.w writelong
  MOVEQ.l #$03,D2
  ; new >
  CLR.b peekaddrsize
  ; < new
BRA.w reget


fetchqasm:
  MOVEQ.l #$00,D3

 'loop
    BSR.w get1bytemain
    BEQ.w syntaxerr
    CMP.w #$22,D0         ;'"'
    BEQ.w 'done
      LSL.l #8,D3
      MOVE.b D0,D3
  BRA.w 'loop

 'done
  BSR.w get1bytemain
BRA.w fetchnum2


fetchasm:
  MOVE.w D2,-(A7)              ; basic vars for asm
  BSR.w makename2              ; get the things name

  BSR.w findlabel2 : BEQ.w 'l10
    LEA namebuffer,a0
    CMP.b #"@",-1(a0,d2.w) : BNE cnferr
    CLR.b -1(a0,d2.w)
    SUBQ.l #1,d2
    LEA varbase,a2
    BSR findvariable : BNE cnferr

    CMP.b #"\",d0 :  BNE 'l6
      ADDQ #1,lastsourcepos
      MOVE.l $a(a2),a2
      ADDQ.l #4,a2
      BSR.w makename2
      BSR findvariable2 : BNE cnferr
      BRA.s 'l6                                                  ;???
   'l6
    MOVE.w 4(A2),d3
    EXT.l d3
    BRA 'npc
 'l10
  ; < new
  MOVE.l 8(A2),D3          ;val.
  CMPI.l #$1,4(A2) : BEQ.w 'npc
    NOT.w asmtype
 'npc
  MOVE.w (A7)+,D2
BRA.w fetchnum2


variable:
  MOVE.w D2,-(A7)                                        ;remember old type
  BSR.w getparameter

  CMP.w #"{",D0 : BEQ.w handle_function                  ;test if var = function{}

  BSR.w fetchvars
                                                         ;called when do var = var
  BSR.w calcvar                                          ;getvaroffset+type
  BSR.w variable2
   ; new >
  MOVE.l a2,rightsidetype
  MOVE.w flagmask, rightsideflagmask
   ;BTST #$d,vartype : BNE 'ls1
   ;CMP.b #7,vartype+1 : BEQ 'ls1                        ;long pointer string error
   ;TST.b vartype+1 : BEQ 'ls1
   ;CMP.b #7,d2 : BNE 'ls1
   ;BRA error_convert_types

 'ls1
  TST.b typecheck : BEQ varcont
  CMP.l #$da01,lasttoken : BEQ 'l1                         ; poke
    CMP.l #$da02,lasttoken : BNE 'l2                       ; peek
 'l1
  CMP.w #1,parnum : BNE varcont                           ; is not call when & is used in parameter
  MOVE.b d2,peekaddrsize
  BRA varcont
 'l2
  CLR.b peekaddrsize
  ; < new

  varcont:
  CMP.w #$1,D2 : BNE.w 'notabyte
    ;
    ;ALWAYS CONVERT BYTE TO WORD.
    ;
    MOVE.w regnum,D1
    ORI.w #$4880,D1      ;ext.w Dn
    BSR.w writeword
 'notabyte

  MOVE.w (A7)+,D3                           ; old type
  BEQ.w 'done                               ; type not set yet...
                                            ; it is now!
  ; new >
  MOVE.l lastinstructionaddr,a0
  ; < new
  CMP.w #$3,D3 : BNE.w 'nob
    CMP.w #$4,D2 : BEQ.w 'conv2
 'nob
    CMP.w D2,D3 : BLS.w 'done
 'conv2

  EXG.l D2,D3
  ; new >
  MOVE.l a0,-(a7)
  TST.b typecheck  :  BEQ 'ok
  TST.b notypecheck : BNE 'ok
  MOVE.l leftsidetype,a0
  CMP.l #0,leftsidetype : BEQ 'ok
  CMP.w #1,leftsideflagmask : BEQ 'isptr
  CMP.l #$100,4(a0) : BLE 'ok

 'isptr
  CMP.b #3,d3 : BEQ 'ok
  CMP.b #7,d3 : BEQ 'ok
    JMP error_convert_types      ;for all syntax only long and string allowed to assign to a type
 'ok
  MOVE.l (a7)+,a0
  ; < new
  BSR.w writeconvertcode         ;called from var assign      ;bump up new type to old...

 'done
BRA.w reget


savemfunc:                       ; it is a copy of the savem routine
  MOVEQ.l #$00,D3
  MOVE.w regnum,D1 : BEQ.w savem_skip
  
  SUBQ.w #1,D1
 'loop
     LSR.l #1,D3
     BSET #$F,D3
  DBF D1,'loop
  ; new >
  TST.b optimize_fpu : BEQ 'l1
    ADDQ.l #2,stacktrack                                    ;intern command
    MOVE.l a0,-(a7)
    MOVE.l stacktrack,d1
    LEA fpustackbase,a0
    CLR.w 0(a0,d1)
    CLR.w regmask
    MOVE.l (a7)+,a0
 'l1
  ; < new
  MOVE.w #$48E7,D1 : BSR.w writeword                         ;write movem.l d0/d1,-(a7)
  MOVE.w D3,D1
  BRA.w writeword
  ; < new


savem:
  MOVEQ.l #$00,D3
  MOVE.w regnum,D1 : BEQ.w savem_skip

  SUBQ.w #1,D1
 'loop
    LSR.l #1,D3
    BSET #$F,D3
  DBF D1,'loop
  ; new >
  TST.b optimize_fpu : BEQ 'l1
    ADDQ.l #2,stacktrack                                    ;intern command
    MOVE.l a0,-(a7)
    MOVE.l stacktrack,d1
    LEA fpustackbase,a0
    CLR.w 0(a0,d1)
    CMP.b #5,(a3) : BNE 'nofpu                              ;result float ?
      ;MOVE.w #1,0(a0,d1.w)
      MOVE.w regnum,regnumfunc
   'nofpu
    CLR.w regmask
    MOVE.l (a7)+,a0
 'l1
  ; < new
  MOVE.w #$48E7,D1 : BSR.w writeword                       ; write movem.l d0/d1,-(a7)   
  MOVE.w D3,D1
  BRA.w writeword

  savem_skip:
RTS


.makefjsr:
  MOVE.l D1,-(A7)                                           ;Push the TARGET PC on to the stack

  TST.b optimize_jumps : BEQ 'fullJsr

  ;JSR log_optimize

  ;-- To start with, we'll get the current PC of the compiled program
  MOVE.l destpointer,d1
  ; SUB.l destbufferstart,d1                                ;I don't know if this is necessary, or why
  ADD.l  #2,d1                                              ;Add two to our "offset" value
 
  ;-- Then we need to subtract the destination offset to get the total distance 
  SUB.l  (a7),d1
  NEG.L  d1
 
  ;-- do we need full jsr ? 
  CMP.l  #32767,D1  : BGT 'fullJsr
  CMP.l   #-32768,D1 : BLT 'fullJsr
  ;-- do we need a bsr.w ?
  CMP.L  #127,d1 : BGT 'bsrWord
  CMP.L   #-128,D1  : BLT 'bsrWord
  
 'bsrByte: ;-- If we get here, we should be able to do a BSR.S (byte sized) jump 
  MOVE.l d2,-(a7)                                         ;Temp store D2
  MOVE.l  d1,d2
  MOVE.W  ##opcode_BSR,D1                                  ;Poke the branch opcode 
  OR.B D2,d1                                               ;Apply the byte sized jump offset
  BSR writeword                                            ;Add our byte sized jump
  MOVE.l (a7)+,d2                                         ;Restore D2
  MOVE.l (a7)+,d1                                         ;Remove the target PC from the stack
  RTS
  
 'bsrWord: ;-- If we get here, we should be able to do a BSR.W jump
  MOVE.L d1,-(a7)                                         ;Store the 16 bit offset
  MOVE.W ##opcode_BSR,D1 : BSR writeword
  MOVE.l  (a7)+,d1                                         ;Restore the 16 bit offset
  BSR writeword 
  MOVE.l (a7)+,d1                                         ;Remove the target PC from the stack
  RTS 

 'fullJsr:
  MOVE.w ##opcode_JSR,D1 : BSR.w writeword                 ;Poke the jump opcode from D1 on to the program
  BSR.w addoff                                             ;Add the current address to the offset hunk? 
  MOVE.l (A7)+,D1                                          ;Pop the TARGET PC from the stack
BRA.w writelong                                            ;Poke the jump address to the program. This is BRA rather than BSR to save an RTS call


handle_function:                                           ;do var = function {}
                                                           ;do a local function -
                                                           ;eg a=pixel{x,y}
  BSR.w find_procedure : BEQ 'l1a
    TST.l unusedfunc : BEQ free_unusedfunctions
    JSR gotoendsource
 'l1a

  MOVE.l funcstruct_returntype(a2),rightsidetype

  TST.l typetocast : BEQ 'nocast
    MOVE.l typetocast,rightsidetype
    CLR.l typetocast
    MOVE.l a1,-(a7)
    MOVE.l rightsidetype,a1
    CMP.l leftsidetype,a1 : BEQ 'ok
      JMP errorconvertreturntype2
   'ok
    MOVE.l (a7)+,a1
 'nocast

  MOVE.l a2,currentfunccall
  MOVEQ.l #$00,D1
  MOVE.b $5(A2),D1
  MOVE.b d1,retmode : BMI.w illprocerr

  MOVE.b #1,isfunc(a2)
  MOVE.w D1,-(A7)
  MOVEQ.l #$00,D1
  MOVE.b 4(A2),D1
  LSR.w #4,D1
  BEQ.w 'skip
    LSL.w #2,D1
    SUB.w D1,a2offset                                   ; a2offset : stackuse
 'skip

  CMPI.w #7,(A7) : BNE.b 'sss                          ; if function return type is "string"
    MOVE.l A2,-(A7)
    BSR.w makesbase
    MOVEA.l (A7)+,A2
 'sss

  MOVE.w sbasegot,-(A7) : BEQ.b 'sssz
    BSR.w dopusha3
 'sssz

  BSR.w savemfunc

  MOVE.w D3,-(A7)                                        ;the movem regs
  ;
  MOVE.l 14(A2),D1                                       ; pc of function call

  TST.b $20(a2) : BNE 'no0par                            ; counter of parameters
  
  MOVE.l a5,a4                                           ; skip spaces and search for "}"
 'l1
    CMP.b #" ",(a4)+
  BEQ 'l1
  CMP.b #"}",-1(a4) : BNE  'no0par                       ; if "}" found, there are not parameters given

  ;--
  ;--  analyse the given parameters
  ;--
  MOVEQ #0,d0
  LEA $16(A2),A1                                         ; parameter description list (1..byte, 2..word, etc.)

 'again
  MOVE.l d1,-(a7)
  MOVE.b (a1),d2
  MOVE.l d0,d1

  CMP.w #4,d2 : BNE 'l1b                                 ; is parameter of type "quick"?  
    ADD.l #$203c,d1
    BSR writeword
    MOVE.l #$ffff0000,d1
    BSR writelong
    BRA 'l2b
 'l1b
    TST.b optimize_fpu : BNE 'l1c                        ; test for fpu-optimization mode
      CMP.w #5,d2 : BNE 'l1c                             ; is parameter of type "float"?
        ADD.l #$203c,d1
        BSR writeword
        MOVE.l #$800000c1,d1
        BSR writelong
        BRA 'l2b
   'l1c
      ADD.l #$70ff,d1
      BSR writeword

      CMP.w #7,d2 : BNE 'l1d                             ; is parameter of type "string"?
        MOVE.l #$2f3c0000,d1                                 ; write code move.l #0,-(a7)
        BSR writelong
        MOVEQ #0,d1
        BSR writeword

        MOVE.l #$2f3c0000,d1                                ; write code move.l #0,-(a7)
        BSR writelong
        MOVEQ #0,d1
        BSR writeword
    'l1d
        TST.b optimize_fpu : BEQ 'l3b                       ;remove fpustuff, if no fpu mode; honitos 20191113
          MOVE.l #$f23c5000,d1                              ; write code fmove.w #-1,fpx
          MOVE.l d0,d2
          ASR.l #2,d2
          ADD.l d2,d1
          BSR writelong
          MOVE.w #$ffff,d1
          BSR writeword
       'l3b
 'l2b
  MOVE.l (a7)+,d1
  ADDQ.l #1,a1
  ADD.l #$0200,d0
  CMP.l #$0e00,d0 : BEQ syntaxerr

  TST.b (a1) : BNE 'again
  BRA 'p1

 'no0par
  ; < new
  TST.b 4(A2) : BNE.w 'somepars

  ; new >
 'p1
  ; < new
  BSR.w makefjsr
  BSR.w get1bytemain
  BRA.w 'nopars


 'somepars
  ; new >
  MOVE.w parnum,-(a7)                                      ;7.2014 need store so function calls in parameter >6 can work
  ; < new
  MOVE.w regnum,-(A7)         ;old regat
  ; new >
  MOVE.w regnum,regnumfunc

 '_func
  ; < new
  MOVE.l D1,-(A7)                                          ;write functioncall with pars
  ; new >
  MOVE.b #1,funccall
  ; < new
  MOVEQ.l #$00,D0
  MOVE.b 4(A2),D0
  ; new >
  MOVE.w a2offset,a2offset2
  MOVE.b 5(a2),retmode
  MOVE.l a2,currentfunccall
  ; < new
  LEA $16(A2),A2              ;pointer to var desc
  CLR.w regnum
  ; new >
  CLR.w regmask
  MOVE.b isconstantvalue,-(a7)
  MOVE.b funcparloop,-(a7)
  MOVE.b #1,funcparloop
  MOVE.l rightsidetype,-(a7)
  MOVE.l leftsidetype,-(a7)                               ;store values To stack so it can work recursive
  MOVE.b blitzparloop,-(a7)
  CLR.b blitzparloop
  ; < new
  JSR fetchpees2
  ;
  ; new >
  MOVE.b (a7)+,blitzparloop
  MOVE.l (a7)+,leftsidetype
  MOVE.l (a7)+,rightsidetype
  MOVE.b (a7)+,funcparloop
  MOVE.b (a7)+,isconstantvalue
  ; < new
  JSR insert_stackchk
  MOVE.l (A7)+,D1
  ; new >
;  CMP.l #6,parnumtemp : BLE 'l1f
;  CMP.l #11,parnumtemp : BGE 'l1f
;  TST.w a2offset : BEQ 'l1f
;    MOVE.l d1,-(a7)
;    MOVE.w #$47ef,d1                                        ;lea x(a7),a3 nat
;    BSR writeword
;    MOVE.w a2offset,d1
;    SUB.w a2offset2,d1
;    BSR writeword
;    MOVE.l (a7)+,d1
; 'l1f

   BTST #0,d1 : BNE intern1
   ; < new
   BSR.w makefjsr
   ; new >

;  CMP.l #6,parnumtemp : BLE 'le
;  CMP.l #11,parnumtemp : BGE 'le
;  TST.w a2offset: BEQ 'le                                  ;changed
;    MOVE.l d1,-(a7)
;    MOVE.l #$4fef0000,d1                                    ;lea $x(a7),a7   nat
;    MOVE.w a2offset,d1
;    SUB.w a2offset2,d1
;    BSR.w writelong                                         ;correct stack with more parameters
;    MOVE.w numreps,movenumrep+2 : BEQ.w 'le2
;      MOVE.l movenumrep,D1
;      BSR.w writelong
;   'le2
;    MOVE.w a2offset2,a2offset
;    MOVE.l (a7)+,d1
; 'le
; < new

  MOVE.w (A7)+,regnum
  ; new >
  MOVE.w (a7)+,parnum                                     ;07.2014
  ; < new

 'nopars
  CMP.w #"}",D0 : BNE.w errorbracketmiss2

  ;
  ; new >
  MOVEQ #0,d1                                            ; end of function call pars
  ; < new
  MOVE.w regnum,D1 : BEQ.w 'nopars3
  ; new >
  TST.b optimize_fpu :  BEQ 'old
    CMP.b #5,retmode :  BNE 'old
      ASL.l #7,d1
      OR.l #$f2000000,d1                             ; opcode: fmove.x fp0       FPU-check: ok
      BSR writelong
      BRA 'nopars3
 'old
    ; < new
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$2000,D1
    BSR.w writeword         ;move.l d0,regat
 'nopars3

  MOVE.w (A7)+,D3 : BEQ.w 'nomovem

  ; new >
  TST.b optimize_fpu : BEQ 'old2
    MOVE.l d0,-(a7)
    MOVE.w #8,d0
    MOVE.l a0,-(a7)
    MOVE.l stacktrack,d1
    LEA fpustackbase,a0
    MOVE.w 0(a0,d1),regmask
    MOVE.l (a7)+,a0

   'loop
      BEQ 'ready

      BTST d0,regmask : BEQ 'noa7
        MOVEQ #0,d1
        MOVE.w d0,d1
        SUBQ.w #1,d1
        ASL #7,d1
        ;OR.l #$f21f4400,d1
        OR.l #$f21f5400,d1                                      ;fmove.d (a7)+
        BSR writelong
        SUBQ.l #2,stacktrack
     'noa7
      SUBQ.w #1,d0
    BNE 'loop
   'ready

    SUBQ.l #2,stacktrack                                     ;integer sub
    MOVE.l (a7)+,d0
 'old2

  ; < new
  MOVE.w #$4CDF,D1 : BSR.w writeword                      ;write movem.l (a7)+,

  MOVEQ.l #$00,D1
  MOVEQ.l #$0F,D4
 'loopsw
    LSL.w #1,D3
    ROXR.w #1,D1
  DBF D4,'loopsw                                         ;movem.l (a7)+,dx
  BSR.w writeword                                        ;poke movem (a7)+...
  ; new >
  CLR.w regnumfunc
  ; < new

 'nomovem
  MOVE.w (A7)+,D1 : BEQ.b 'nores
    CMPI.w #$7,(A7) : BEQ.b 'issb
      ;-- not a string...set a3 back to start of any strings...
      LEA geta3,A0
      LEA geta3f,A1
      BSR.w pokecode
      BRA.b 'nosb
   'issb
      ;-- is a string, wack off last '0'
      MOVE.w deca3,D1
      BSR.w writeword
   'nosb
    BSR.w dopulla3          ;fix up string base
 'nores
  
  MOVE.w (A7)+,D2         ;what it returns!

  CMP.w #$7,D2 : BNE.w 'notst
    MOVE.w putstlen,D1
    OR.w regnum,D1
    BSR.w writeword
 'notst
  BSR.w get1bytemain
BRA.w varcont


;------                                                  ;disassembled code begin
deca3:   Dc.w $534B                                      ;SUBQ.W  #1,A3
;------                                                  ;disassembled code end

Even
stvar:
  ;-- handle string variable get!
  ;--
  
  ; new >
  CMP.b #2,optistring : BEQ 'fs2
    ; < new
    BSR.w makesbase                                          ;writestringvariable
    BTST #$F,D2 : BNE.w 'already
      MOVE.w D3,leaa5d3a2+2
      MOVE.l leaa5d3a2,D1
      BSR.w pokela5s
   'already
    MOVE.w regnum,D1
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$7000,D1                                       ; MOVEQ#0,D0
    LEA stvarget2,A0
    MOVE.w D1,(A0)
    MOVE.w regnum,D1
    ANDI.w #$FFF8,$2(A0)
    OR.w D1,$2(A0)
    LEA stvarget2f,A1
    BSR.w pokecode
    MOVE.w #$C600,D1 : BSR.w Atokejsr                     ; was #copstring,   
    MOVEQ.l #$07,D2
    BRA.w reget
    ; new >
 'fs2
    TST.w stackpar : BMI 'l10
      MOVE.l #$3f3c0007,d1
      ADDQ.w #2,a2offset : BSR writelong
   'l10
    MOVE.w #$4878,d1
    CLR.w stackpar       : BSR writeword
    MOVE.w #$0,d1        : BSR writeword
    MOVE.w #$246d,d1     : BSR writeword
    MOVE.w d3,d1         : BSR writeword
    MOVE.l #$4a926704,d1 : BSR writelong
    MOVE.l #$2eaafffc,d1 : BSR writelong
    MOVE.w #$2f0a,d1
    ADDQ.w #8,a2offset   : BSR writeword
  BRA.w reget
  ; < new


variable2: ; d2: dataype
  CMP.b #$7,D2 : BEQ.w stvar                    ;load basic var

  TST.b iee : BEQ 'noiee
    CMP.b #5,d2 : BNE 'noiee
      MOVE.l d0,-(a7)                                         ;fpu load var
      BTST #15,d2
      BEQ 'var
    CMP.l #$7fff,d3 : BGT 'longoffset
      MOVE.l #$f22a4400,d1                                    ;newtype     >32kb
      TST.w d3 : BNE 'offset                                  ;offset =0
      
   'longoffset
    MOVE.l #$f2124400,d1
    MOVEQ #0,d3
    BRA 'glob

 'offset
  SUBQ.l #4,destpointer
  BRA 'glob

 'var
  TST.b optimize_integer : BEQ 'nofastload
  TST.w regnum : BNE 'nofastload
  CMP.l fp0addr,a4 : BNE 'nofastload
  MOVE.l fp0iff,d1
  CMP.l firstiff,d1 : BNE 'nofastload
  MOVE.w varmode,d1
  CMP.w fp0mode,d1 : BNE 'nofastload
  CMP.w fp0var,d3 : BNE 'nofastload
     BCLR #16,d2
     MOVE.l (a7)+,d0
     RTS
 'nofastload
  
  MOVEQ #0,d0
  MOVE.w regnum,d0
  CMP.l maxregs,d0 : BLE 'ok
    LEA cmplxerr,a0
    MOVE.l a0,-(a7)
    JMP handle_compileerror
 'ok
    LEA regtable,a4
    TST.l (a4) : BEQ 'noreg
    CMP.w 0+4(a4),d3
    BNE 'doreg1
    MOVE.l #$f2001c00,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    BSR writelong
    MOVE.l (a7)+,d0
    RTS
 'doreg1
  CMP.w 8+4(a4),d3 : BNE 'doreg2
    MOVE.l #$f2001800,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    BSR writelong
    MOVE.l (a7)+,d0
    RTS
 'doreg2
  CMP.w 16+4(a4),d3 : BNE 'doreg3
    MOVE.l #$f2001400,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    BSR  writelong
    MOVE.l (a7)+,d0
    RTS
 'doreg3
  CMP.w 24+4(a4),d3 : BNE 'doreg4
    MOVE.l #$f2001000,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    BSR writelong
    MOVE.l (a7)+,d0
    RTS
 'doreg4
  CMP.w 32+4(a4),d3 : BNE 'noreg
    MOVE.l #$f2000c00,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    BSR writelong
    MOVE.l (a7)+,d0
    RTS
 'noreg
  MOVE.l #$f22d4400,d1                                    ;var
  TST.w varmode : BEQ 'glob
    BCLR #16,d1                                              ;local
 'glob
  MOVEQ #0,d0
  MOVE.w regnum,d0
  CMP.w #7,d0 : BLE 'ok2
    LEA cmplxerr,a0
    MOVE.l a0,-(a7)
    JMP handle_compileerror
 'ok2
  ASL.w #7,d0
  OR.l d0,d1
  CMP.l #doublecheck,8(a2) : BNE 'dbl
    OR.l #$00001000,d1
 'dbl
  BSR writelong
  MOVE.l (a7)+,d0
  AND.w #$ff,d2
  MOVE.w d3,d1 : BEQ 'nooffs
    BRA writeword
 'nooffs
  ;CMP.l #$f2124400,-4(a4)
  ;BNE writeword
  RTS

 'noiee
  MOVE.w regnum,D1
  ; new >
  MOVE.w d1,load_var_reg
  ; < new
  LSL.w #8,D1
  ; new >
  MOVE.l destpointer,load_var_addr
  MOVE.w d2,load_var_size
  ; < new
  LSL.w #1,D1
  BTST #$E,D2 : BNE.w 'pointer
    TST.b D2
    BNE.w 'skip2
      MOVEQ.l #$03,D2
      ORI.w #$200A,D1
      BRA.w writeword
 'pointer
    MOVE.b #$3,D2
 'skip2

  BTST #$F,D2 : BEQ.w 'simpvar                             ;loadarray
  ; new >
   TST.b optimize_integer                                              ;lea->move xx(a2)
   BEQ 'la10
   CNIF #optibreak
     ILLEGAL
   CEND

   CLR.l load_var_addr
   BRA 'la10

   CMP.w #$2012,movea2dn                                  ;??Looks like dead code??
   BNE 'la10
   TST.b optiarray
   BNE 'la10
   MOVE.l destpointer,a4
   SUB.l loada,a4
   CMP.w #4,a4
   BEQ 'la100
   CMP.w #2,a4
   BNE 'la10
   MOVE.l destpointer,a4
   CMP.b #3,d2
   BCS 'la110
   MOVE.w #$202a,-2(a4)
   OR.w d1,-2(a4)
   MOVE.w arrayoffset,d1
   BSR writeword
 BRA 'more

 'la110
   CMP.b #2,d2
   BNE 'la120
    MOVE.w #$302a,-2(a4)
   OR.w d1,-2(a4)

   MOVE.w arrayoffset,d1
   BSR writeword
 BRA 'more

 'la120
  CMP.b #1,d2
   BNE.s 'la10
    MOVE.w #$102a,-2(a4)
   OR.w d1,-2(a4)
   MOVE.w arrayoffset,d1
   BSR writeword
 BRA 'more

 'la100
  MOVE.l destpointer,a4
   CMP.w #$45ea,-2(a4)
   BNE 'la10
   CMP.b #3,d2
   BCS 'la11
   MOVE.w #$202a,-4(a4)
   OR.w d1,-4(a4)
 BRA 'more

 'la11
   CMP.b #2,d2
   BNE 'la12
    MOVE.w #$302a,-4(a4)
   OR.w d1,-4(a4)
 BRA 'more

 'la12
  CMP.b #1,d2
   BNE.s 'la10
    MOVE.w #$102a,-4(a4)
   OR.w d1,-4(a4)
 BRA 'more

 'la10
  ; < new
   OR.w movea2dn,D1
   BSR.w 'size
   BSR.w writeword

 'more
  ANDI.w #$FF,D2
 RTS

  ; new >
 'farr2                               ;??? looks like not used ???
   MOVE.l destpointer,a4              ; "
   MOVE.l #$f22a4400,-4(a4)           ; "
   MOVE.w arrayoffset,d1              ; "
 BRA writeword
  ; < new

 'simpvar
  OR.w moved3a5dn,D1                                        ;write move.l 0(a5),reg
   BSR.w 'size
   BSR.w pokewda5s
  MOVE.w D3,D1
   BSR.w writeword
 BRA.w 'more

 'size
  ;correct for size
  ;
  BTST #$E,D2
   BNE.w 'long
  CMP.b #$1,D2
   BEQ.w 'byte
  CMP.b #$2,D2
   BEQ.w 'word

 'long
 RTS

 'byte
  EORI.w #$3000,D1
 RTS

 'word
  ORI.w #$1000,D1
RTS


;----------- fetch number and update type if necessary!----------;

.fetchdata:
  MOVE.w #$FFFF,dfetch    ; was -1

  BSR.w get1bytemain
  CMP.w #"-",D0 : BNE.w 'datado
  
  BSR.w get1bytemain
  BSR.w 'datado

  CMP.w #$5,D2  : BCC.w 'nfp            ; float ?
    NEG.l D0
    RTS
 'nfp

  TST.b optimize_fpu :  BEQ 'noneg
    fneg.x fp0
    RTS
 'noneg

  ;-- negate floating point data!
  BCHG #$7,D0
RTS

'datado
  CMP.w #"#",D0 : BEQ.w fetch_Constant
  CMP.w #"$",D0 : BEQ.w fetch_HexValue
  CMP.w #"%",D0 : BEQ.w fetch_BinValue
  CMP.w #".",D0 : BNE.w fetch_DecValue
  

fetch_FracValue:
  MOVEQ.l #$00,D3
BRA.w fetchpoint2


fetch_DecValue:
  MOVEQ.l #$00,D3                                          ; number
  BSR.w atoi                                               ; get current character in d0, returns number in d3
  ;
  CMP.w #".",D0 : BEQ.w fetchpoint
  
  ORI.w #" ",D0
  CMP.w #$65,D0 : BNE.w fetchnum2                          ; 'e'
  
  CMP.l #$800000,D3 : BCC.w overerr

  MOVEQ.l #-$01,D6

  TST.b optimize_fpu : BEQ 'nofpu1
    fmove.l d3,fp0
 'nofpu1

  MOVE.l D3,D0
  MOVEA.l _mathffpbase,A6
  JSR _SPFlt(A6)                                           ;int to ffp
  MOVE.l D0,D3

  BSR.w do_the_E

  BSR.w reget
  BSR.w consttype2
BRA.w fetchnum3


fetchpoint:
  ; new >
  CMP.b #4,d2 : BEQ 'l4
    MOVE.b #5,d2                                             ;nprint 2/0.5 bugfix
 'l4

  TST.b optimize_fpu : BNE 'l1
  ; < new
    CMP.l #$800000,D3 : BCC.w overerr
  ; new >
    BRA fetchpoint2
 'l1
  CMP.l #$7fffffff,d3 : BCC.w overerr
   ; < new


fetchpoint2:
  MOVEQ.l #-$01,D6         ;now a float.

  ; new >
  TST.b optimize_fpu : BEQ 'nofpu2
    fmove.l d3,fp0
 'nofpu2
  MOVE.l D3,D0
  MOVEA.l _mathffpbase,A6 : JSR _SPFlt(A6)                   ;convert integer to ffp
  MOVE.l D0,-(A7)                                            ;save whole number

  BSR.w get1bytemain
  !test_for_literal : BNE.w syntaxerr

  MOVEQ.l #$00,D3

  BSR.w atoi                                                 ; get int frac, returns 10th in d5, int number in d3

  TST.l D3 : BEQ.w 'pskip

  TST.b optimize_fpu : BNE 'l1
    CMP.l #$800000,D3 : BCC.w overerr
    BRA 'l2
 'l1
    CMP.l #$7fffffff,d3 : BCC overerr
 'l2

  TST.b optimize_fpu : BEQ 'nofpu4
    fmove.l d5,fp1
    fmove.l d3,fp2
    fdiv.x fp1,fp2
    fadd.x fp2,fp0
 'nofpu4

  MOVE.l D5,D0   :  JSR _SPFlt(A6)        ; divisor to FFP
  MOVE.l D0,D5
  MOVE.l D3,D0   :  JSR _SPFlt(A6)        ; to FFP
  MOVE.l D5,D1   :  JSR _SPDiv(A6)        ; num/divisor (eg .25=25/100)
  MOVE.l (A7)+,D1 : JSR _SPAdd(A6)        ; add 'em
  MOVE.l D0,D3

  BSR.w reget                             ; get previous char to D0
  ORI.w #" ",D0
  CMP.w #$65,D0 : BNE.w 'pskip2           ; 'e'
    BSR.w do_the_E
 'pskip2

  BSR.w reget
  BSR.w consttype2

  BRA.w fetchnum3

 'pskip
  MOVE.l (A7)+,D3
BRA.w 'pskip2


do_the_E:                                                     ; Suss stuff after the E
  ; input: d3/fp0 = number
  ; input: d0 = current source
  ; returns division in d3/fp0
  BSR.w get1bytemain
  CMP.w #"+",D0 : BEQ.w 'pos
    CMP.w #"-",D0 : BNE.w 'pos2
      BSR.w get1bytemain
      BSR.w get_Sign                      ;d3/fp0=number, d4/fp1=divisor

      TST.b optimize_fpu : BEQ 'nofpu10
        fdiv.x fp1,fp0
     'nofpu10
      MOVE.l D3,D0
      MOVE.l D4,D1
      JSR _SPDiv(A6)
      MOVE.l D0,D3
      RTS
 'pos
    BSR.w get1bytemain
 'pos2

  BSR.w get_Sign                          ;d3/fp0=number, d4/fp1=multiplier

  TST.b optimize_fpu : BEQ 'nofpu8
    fmul.x fp1,fp0
 'nofpu8

  MOVE.l D3,D0
  MOVE.l D4,D1
  JSR _SPMul(A6)
  MOVE.l D0,D3
RTS


get_Sign:
  !test_for_literal : BNE.w syntaxerr

  MOVE.w D0,D4
  SUBI.w #$30,D4
  BSR.w get1bytemain

  !test_for_literal : BNE.w 'skip
    MULU #$A,D4
    SUBI.w #$30,D0
    ADD.w D0,D4
    BSR.w get1bytemain
 'skip
  ;d4=number E+10
  CMP.w #$12,D4 : BHI.w overerr

  ; new >
  LSL.w #3,D4
  LEA fputab,a0
  ADD.l d4,a0

  TST optimize_fpu : BEQ 'skipfpu
    fmove.d 0(a0),fp1
 'skipfpu
  ; < new

  LSR.w #1,d4               ; was #2
  MOVE.l facts(PC,D4.W),D4
RTS


fputab:
  Dc.d 1,10,100,1000,10000,100000,1000000,10000000,100000000  ;,1000000000,10000000000
  ;Dc.d 100000000000,1000000000000,10000000000000,100000000000000


facts:
  Dc.l $80000041
  Dc.l $A0000044
  Dc.l $C8000047
  Dc.l $FA00004A
  Dc.l $9C40004E
  Dc.l $C3500051
  Dc.l $F4240054
  Dc.l $98968058
  Dc.l $BEBC205B
  Dc.l $EE6B285E
  Dc.l $9502F962
  Dc.l $BA43B765
  Dc.l $E8D4A568
  Dc.l $9184E76C
  Dc.l $B5E6A96F
  Dc.l $E35F2972
  Dc.l $8E1BCA76
  Dc.l $B1A2BD79
  Dc.l $DE0B6C7C


.atoi:                                                    ; fetchdec org source, converts string to integer
                                                          ; returns number in D3, divisor for frac in D5

  MOVEQ.l #$01,D5                                         ; divisor for frac convert will be in D5
 'loop
  LSL.l #1,D5                                             ; calculate 10 powerof(loopruns) like:
  MOVE.l D5,D1                                            ; 10 ...
  LSL.l #2,D5                                             ; 100 ...
  ADD.l D1,D5                                             ; 1000 ...

  LSL.l #1,D3 : BCS.w overerr                             ; d3 * 2
                                                          ;
  MOVE.l D3,D1                                            ; d1 = d3
  LSL.l #1,D3 : BCS.w overerr                             ; d3 * 2
                                                          ;
  LSL.l #1,D3 : BCS.w overerr                             ; d3 * 2
                                                          ;
  ADD.l D1,D3                                             ; d3 = d3 + d1
  SUBI.w #$30,D0                                          ; d0 = d0 - 48 (48: asc("0"))
  ADD.l D0,D3                                             ; d3 = d3 + d0
  ; new >
  !fget                                                   ;
  CMP.b #1,d0 : BNE 'cm1                                  ; if 
    SUBQ.l #1,a5
    BSR get1bytemain
 'cm1

  CMP.b #127,d0 : BNE 'cm2                                ; 127
    SUBQ.l #1,a5
    BSR get1bytemain
 'cm2

  TST.b d0 : BPL 'l10
    LSL.w #8,d0
    MOVE.b (a5)+,d0
    MOVE.w d0,lastchar
 'l10

  !test_for_literal                                                ;bsr.w tstnum ;cmake bug
  ; < new
  BEQ.w 'loop
RTS


dfetch:  Ds.w 1                                            ;fetching data?


fetchnum3:
  MOVE.w dfetch(PC),D1 : BEQ.w 'doit
    CLR.w dfetch
     RTS                ;1 number value write
 'doit

  ; new >
  MOVE.b d2,isconstantvalue
  MOVE.l d0,lastconstantvalue
  MOVE.w d2,imm_size
  MOVE.w regnum,imm_reg
  MOVE.l destpointer,imm_addr                           ; long
  ;< new

  ;datatypes...
  ;#byte=1
  ;#word=2
  ;#long=3
  ;#quick=4
  ;#float=5
  ;#string=7
  ;#double=8

  CMP.w #$3,D2 : BEQ.w 'long          ; order of cmp/beq in org soure is different
  CMP.w #$5,D2 : BEQ.w 'long          ;float
  CMP.w #$1,D2 : BEQ.w 'word
  CMP.w #$2,D2 : BEQ.w 'word
  CMP.w #$4,D2 : BEQ.w 'long
  BRA.w mismatcherr

 'word
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$303C,D1
  BSR.w writeword      ; old label "pokewd"
  MOVE.w D0,D1
  BSR.w writeword
  BRA.w reget

 'long
  MOVEQ #0,d1
  MOVE.w regnum,D1

  TST.b optimize_fpu : BEQ 'f1                               ; fpu-optimization on ??
    CMP.w #5,d2 : BEQ 'l10                                     ; float ?
      BRA 'f2
 'f1
    TST.b iee : BNE 'l10
 'f2

    LSL.w #8,D1                                       ; move register number to the left opcode byte
    LSL.w #1,D1
    ;  CMP.l #127,D0                                     ; check if value is in byte range and optimize opcode to "moveq"
    ;  BGT 'nomoveq
    ;    CMP.l #-128,D0
    ;    BLT 'nomoveq
    ;      BRA 'writemoveq
    ; 'nomoveq:
    ORI.w #$203C,D1                                   ; write opcode "move.l"
    BSR.w writeword
    MOVE.l D0,D1
    BSR.w writelong
    BRA.w reget
 'l10                                               ;fpu constant
 ; --- FPU optimization: use fpu-calls instead 68k ones
  MOVEQ #5,d2
  ASL.l #7,d1
  SUBQ.l #8,a7
CNIF #64bitconstant
  OR.l #$f23c5400,d1                                   ;fmove.d
  fmove.d fp0,0(a7)
CELSE
  OR.l #$f23c4400,d1                                   ;fmove.s
  fmove.s fp0,0(a7)
CEND
  JSR writelong
  MOVE.l (a7)+,d1
  JSR writelong
  MOVE.l (a7)+,d1

CNIF #64bitconstant
  BSR writelong
CEND
  BRA.w reget
  ; < new

'writemoveq:
  ;AND.w #$0F00,D1                                   ;Fix the opcode from "move.l" to "moveq"
  OR.w #$7000,D1                                      ; MOVEQ#0,D0
  OR.b D0,D1
  BSR.w writeword
BRA.w reget



;-----------end of number fetch-------------;

makeint:
  MOVE.l D3,D0
  TST.w D6 : BEQ.w 'skip                   ;already integer
    MOVEA.l _mathffpbase,A6
    JSR _SPFix(A6)
  BVC.w 'skip
    ADDQ.w #4,A7
    BRA.w numdofloat
 'skip
RTS


fetchnum2:
  MOVEQ.l #$00,D6          ;no frac

  TST.b optimize_fpu : BEQ 'nofpu3
    fmove.l d3,fp0
 'nofpu3

 nofpregload:
  ;< new
  BSR.w consttype2
BRA.w fetchnum3


constotype:                             ; ??? looks like not used ???
  ;fetch a constant of type d2          ;
  ;                                     ;
  ;return new type in d2!               ;
  ;                                     ;
  MOVE.w D2,-(A7)                       ;
  BSR.w evalconst                      ;  "
  MOVE.w (A7)+,D2

consttype2:
  TST.w D2 : BNE.w 'something
    ;-- 
    ;-- Let's set type
    ;--
    TST.w D6 : BEQ.w 'nofrac
      MOVEQ.l #$04,D2
      BRA.w 'quick2
   'nofrac
    MOVEQ.l #$02,D2
    BRA.w 'byte
 'something

  CMP.w #$1,D2 : BEQ.w 'byte
  CMP.w #$2,D2 : BEQ.w 'word
  CMP.w #$3,D2 : BEQ.w 'long
  CMP.w #$4,D2 : BEQ.w 'quick
  CMP.w #$5,D2 : BEQ.w 'float
  BRA.w mismatcherr

 'byte
    BSR.w makeint                                          ;bugfix if a.b=$90 bug fix
    CMP.l #$7f,D0 : BGT.w 'over1                           ;127
      CMP.l #$FFFFFF80,D0 : BGE.w 'dobword                 ;-128
   'over1
    MOVEQ.l #$02,D2                                        ;was 2 before
    CMP.l #$7fff,D0 : BGT.w 'byte2                         ;32767
        CMP.l #$FFFF8000,D0 : BGE.w 'dobword               ;32768
   'byte2
    MOVEQ.l #$03,D2
    BRA.w 'dobword

 'word
    TST.w D6 : BNE.w 'quick2
      BSR.w makeint
      BRA.w 'over1

'quick
  BSR.w makeint
  TST.w D6 : BEQ.w 'qint

'quick2
  CMP.l #MaxWordSgnd,D0 : BGT.w numdofloat                ; 32767
  CMP.l #$FFFF8000,D0 : BLT.w numdofloat                  ; -32768

  MOVE.w D0,-(A7)         ; save whole part
  JSR _SPFlt(A6)          ; back to ffp
  MOVE.l D0,D1
  MOVE.l D3,D0
  JSR _SPSub(A6)          ; subtract - d0=fraction!
  MOVE.l #$80000051,D1    ; 65536
  JSR _SPMul(A6)          ; *65536
  JSR _SPFix(A6)          ; back to int
  ;
  BEQ.w 'knob             ; numdofloat
    CMP.l #$10000,D0      ; 65536
    BCC.w 'knob           ; numdofloat
      MOVE.w D0,D1
      MOVE.w (A7)+,D0
      SWAP D0
      MOVE.w D1,D0
      BRA.w 'dolong
 'knob
  ADDQ.w #2,A7
  BRA.w numdofloat

 'qint
  CMP.l #MaxWordSgnd,D0 :   BGT.w 'byte2                 ;#32767
  CMP.l #$FFFF8000,D0 : BLT.w 'byte2                     ;#32768
  SWAP D0
  BRA.w 'dolong

 'long
  TST.w D6 : BNE.w numdofloat
  MOVE.l D3,D0
  BRA.w 'dolong

 'float
  TST.w D6 : BNE.w numdofloat
  MOVE.l D3,D0
  MOVEA.l _mathffpbase,A6
  JSR _SPFlt(A6)           ;int to float
  MOVE.l D0,D3
  BRA.w numdofloat

 'dobword
 'dolong
RTS


numdofloat:
  MOVEQ.l #$05,D2
  MOVE.l D3,D0
RTS


;pushfrom:                                                 :??Looks like not used??
            Ds.l 1                                         ;??Looks like unused data??
pushpc:     Ds.l 1
pushoff:    Ds.l 1
pushdooff:  Ds.l 1
pushclen:   Ds.w 1
pushat:     Ds.l 1


pushstart:
  ;Here, we prepare to collect code to be saved and added
  ;later
  MOVE.l destpointer,pushpc
  MOVE.l hunkoffsetbase,pushoff
 RTS


pushdo:
  ;OK, push code since push start
  ;
  MOVEM.l D0-D1/A0-A1,-(A7)
  ;
  MOVE.l destpointer,D0
  MOVE.l pushpc(PC),D1
  MOVE.l D1,destpointer    ;New PC
  SUB.l D1,D0              ;len
  MOVE.w D0,pushclen : BEQ.w 'skip
    MOVE.w dontwrite_nomemleft,D1 : BNE.w 'skip
      CMP.w #1000,pushclen : BGE conmemerr
      
      MOVE.l pushat,d0 : BNE 'nomem
        MOVE.l #1024,d0
        MOVEA.l _execbase,A6
        MOVE.l mempool,a0 : JSR _AllocPooled(a6)
        MOVE.l D0,pushat
     'nomem
      MOVEA.l D0,A0          ;destination
      MOVEA.l pushpc,A1      ;source
      MOVE.l A1,destpointer
      MOVE.w pushclen,D0
      LSR.w #1,D0
      SUBQ.w #1,D0           ;to word dbf
     'loop
        MOVE.w (A1)+,(A0)+
      DBF D0,'loop
      MOVE.l hunkoffsetbase,pushdooff
 'skip
  MOVEM.l (A7)+,D0-D1/A0-A1
RTS


pushput:
  ;replace pulled out code!
  ;
  MOVEM.l D0-D1/A0-A1,-(A7)
  MOVEQ.l #$00,D0
  MOVE.w pushclen,D0
   BEQ.w 'skip
  MOVE.l destpointer,D1     ;pc before put
  ADD.l D0,destpointer
  TST.w dontwrite_nomemleft
   BNE.w 'skip
  ;
  LSR.w #1,D0
  SUBQ.w #1,D0
  ;
  MOVEA.l D1,A1
  MOVEA.l pushat,A0

 'loop
    CMPA.l destbufferend,A1
    BCS.w 'ok

    MOVE.w #$FFFF,dontwrite_nomemleft    ; was -1
  BRA.w 'skip

   'ok
     MOVE.w (A0)+,(A1)+                                    ;copylibcode
  DBF D0,'loop
  ;
  ;OK, now all offsets between pushdooff and pushoff must
  ;be adjusted by d1-pushpc
  ;
  SUB.l pushpc,D1 : BEQ.w 'skip2
    MOVEA.l pushdooff,A0

   'loop2
      CMPA.l pushoff,A0 : BEQ.w 'done
    
      MOVEA.l $4(A0),A1          ;address in prog.
      ADDA.l destbufferstart,A1
      CMPA.l destbufferend,A1 : BCC.w 'next                ;leave offs >= lib
        ADD.l D1,$4(A0)
     'next
      MOVEA.l (A0),A0
    BRA.w 'loop2
   'done   ;Whew!

 'skip2

  MOVEA.l pushat,A1
  MOVEQ.l #$00,D0
  MOVE.w pushclen,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0  ;JSR _FreePooled(A6)

 'skip
  MOVEM.l (A7)+,D0-D1/A0-A1
RTS


muld1:                            ;generate code for #d1.w * regat
  MOVE.l D1,-(A7)                 ;array mul
  MOVEQ.l #$00,D2
  MOVEQ.l #$0F,D3

 'shloop
    LSL.w #1,D1
    BCC.w 'shskip
      ADDQ.w #1,D2
      MOVE.w D3,D4
   'shskip
  DBF D3,'shloop

  SUBQ.w #1,D2
  BNE.w 'domul
    ADDQ.w #4,A7           ; was 2
    MOVE.w D4,D1
    BEQ.w 'done
      CMP.w #$8,D1
      BCS.w 'once
        SUBI.w #$8,D1
        BSR.w 'once
          MOVEQ.l #$00,D1
     'once
      LSL.w #8,D1
      LSL.w #1,D1
      ORI.w #$E188,D1                               ;lsl.l #,dx
      OR.w regnum,D1
      BRA.w writeword
   'done
    RTS
 'domul

  ; new >
  MOVEQ #0,d1
  MOVE.w regnum,D1
  ; < new


  BRA 'nooptimize
  ;TST #0;##optimize_68020
  ;BEQ 'nooptimize
    LSL.l #8,D1
    LSL.l #4,D1
    OR.l #$4c3c0000,d1    ; MULU.L #x,d0
    OR.w regnum,d1
    BSR.w writelong
    MOVE.l (A7)+,D1
    BRA writelong
    ;BRA 'optimize_end
  'nooptimize
    LSL #8,d1
    LSL #1,d1
    ORI #$C0FC,D1       ; MULU.w #x,d0
    BSR writeword
    MOVE.l (a7)+,d1
    BRA writeword
  'optimize_end


.makeLibInits:  
  ;--
  ;-- make any initialing jsr's to INIT routines from libs
  MOVE.l destpointer,-(A7)
  
  MOVEQ.l #-$01,D7
 'loop
    BSR.w findhilib : BEQ.w 'done

    TST.w 12(A2) : BPL.w 'loop

    MOVE.l $16(A2),D1 : BEQ.w 'loop

    MOVE.w 4(A2),D1                              ; check libnum in D1 and do some things related to that lib
    CMP.w #-$2,D1 : BNE.w 'notvar                 ; was #varslib
      BSR.w makevsize
      BRA.w 'more
   'notvar

    CMP.w #-$5C4,D1 : BNE.w 'notdebuglib          ; was #debuglib
      ;
      ;pass flag in d0 : non zero=auto run
      ;
      MOVE.w #$7000,D1      ;moveq #0,d0
      TST.w set_autorun : SNE D1
      BSR.w writeword
      BRA.w 'more
   'notdebuglib

    CMP.w #-$12D,D1 : BNE.w 'notstring1              ; was #strings1lib
      BSR.w makessize
      BRA.w 'more
   'notstring1

    CMP.w #-$1F5,D1 : BNE.w 'notexit                 ; was #exitslib
      MOVE.w #$203C,D1 : BSR.w writeword
      BSR.w addoff
      MOVE.l endop,D1
      BSR.w writelong
      BRA.w 'more
   'notexit

    CMP.w #-$3E9,D1 : BNE.w 'notdatalib              ; was #datalib
      MOVE.w #$203C,D1 : BSR.w writeword
      BSR.w addoff
      MOVE.l data2at,D1
      BSR.w writelong
      BRA.w 'more
   'notdatalib

    CMP.w #$1,D1 : BNE.w 'notdhandler                ; was #dhandlerlib
      MOVE.w #$203C,D1 : BSR.w writeword
      MOVE.l d0,-(a7)      ; store d0
      !basic
      GetReg D0,config\ptr_seg_debugger
      !asm
      ;MOVE.l ptr_seg_debugger,D1
      MOVE.l D0,D1
      MOVE.l (a7)+,D0      ; restore d0
      BSR.w writelong
   'notdhandler
   'more

    MOVE.l $16(A2),D1
    MOVE.w #$FFFF,lasta6     ; was -1
    BSR.w Amakelibsub
    CMPI.w #$FFFE,4(A2) : BNE.w 'notvar2           ; was #varslib
      MOVE.l intdata1,D1 : BEQ.w 'notvar2
        MOVE.w putidata1,D1 : BSR.w writeword
        BSR.w addoff
        MOVE.l intdata1,D1 : BSR.w writelong
   'notvar2

    MOVE.w #$2B40,D1                                ;MOVE.L  D0,$0000(A5)
    TST.w $1A(A2) : BEQ.w 'loop
      BPL.w 'long
        MOVE.w #$3B40,D1
   'long
    BSR.w writeword

    MOVE.w $A(A2),D1
    BSR.w writeword

    CMPI.w #$FFFA,4(A2) : BNE.w 'loop              ; was #memlib
      MOVE.w D7,-(A7)
      MOVE.w numstatic,D4 : BEQ.w 'nostats
        MOVE.l staticdata,D3
        JSR datastart
        MOVE.w #$C500,D1 : BSR.w tokejsr2       ; was #alstat
     'nostats
      MOVE.w maxsused,D4 : BEQ.w 'nomaxs
        MOVE.l maxsat,D3
        JSR datastart
        MOVE.w #$CF00,D1 : BSR.w tokejsr2      ; was #setmaxs
     'nomaxs
      MOVE.w (A7)+,D7
  BRA.w 'loop
 'done

  ;--
  ;-- misc inits
  ;--
  MOVE.l destpointer,D1
  CMP.l (A7),D1 : BNE.w 'yi
    MOVE.w #$0008,noinits+2
    BRA.w 'yi3
 'yi
    CLR.w noinits+2
    MOVE.w dontwrite_nomemleft,D1 : BNE.w 'yi2
      ; new >
      TST.l newinitaddr : BEQ 'l10
        MOVE.l newinitaddr,D2
        SUB.l destbufferstart,D2
        ADDQ.l #2,d2
        ; < new
        MOVEA.l newinitaddr,A0                                   ;write newinitcode
        ; new >
        ;MOVE.w #$2f00,(a0)+
        ; < new
        MOVE.w ##opcode_JSR,(A0)+
        MOVE.l (A7),(A0)+
        ; new >
        ;MOVE.l #$202f0048,(a0)
        BRA 'l20  
     'l10
        MOVEA.l destbufferstart,A0                               ;write initcode
        TST.b saved0 : BEQ 'l1
          MOVE.w #$23c0,(a0)+
          MOVE.l a0,a1
          ADDQ.l #6,a1
          MOVE.l a1,(a0)+
          ; < new
          MOVEQ.l #$02,D2
          BSR.w addhunkoffset
          ; new >
          MOVE.w #$6004,(a0)+
          MOVE.l ##opcode_NOP2,(a0)+
       'l1
        MOVE.w ##opcode_JSR,(A0)+
        MOVE.l (A7),(A0)+
        MOVEQ #2,d2
        TST.b saved0 : BEQ 'l20
          MOVEQ.l #14,D2    
       'l2
        BSR.w addhunkoffset
        MOVE.w #$2039,(a0)+
        MOVE.l a1,(a0)+
        MOVEQ.l #20,d2
     'l20
      BSR.w addhunkoffset
      ; < new
    
   'yi2
    MOVE.w ##opcode_RTS,D1
    BSR.w writeword
  
 'yi3
  ADDQ.w #4,A7
RTS


;------                                                  ;disassembled code begin
;prepd1:    Dc.w $222D,$0000                             ;MOVE.L  $0000(A5),D1
putidata1:  Dc.w $23CD,$0000,$0000                       ;MOVE.L  A5,$00000000
;prepint:   Dc.w $247C,$0000,$0000                       ;MOVEA.L #$00000000,A2
;------                                                  ;disassembled code end
Even

makessize:
  MOVE.l stringbuffer,D1
BRA.w makesize

makevsize:
  ;create code for amount of variables in d0
  ;
  MOVEQ.l #$00,D1
  MOVE.w globalvarpointer,D1
  SUBI.w #$8000,D1
  BNE.w makesize
    MOVEQ.l #$08,D1

makesize:
  ;create code for #d1 into d0
  ;
  MOVE.l D1,-(A7)
  MOVE.w #$203C,D1                       ;move.l #x,d0
  BSR.w writeword
  MOVE.l (A7)+,D1
BRA.w writelong


findhilib:
  ;-- find highest lib# under d7. set d7 to this lib number
  ;-- 
  ;-- ne if found, eq if not
  ;-- 
  MOVEQ.l #$00,D1
  MOVEA.l libpointer,A1

 'loop
    CMPA.w #$0,A1 : BEQ.w 'done
      CMP.w $4(A1),D7 : BLS.w 'next
        CMP.w $4(A1),D1 : BCC.w 'next
          MOVE.w $4(A1),D1
          MOVEA.l A1,A2
   'next

    MOVEA.l (A1),A1
  BRA.w 'loop
 'done

  MOVE.w D1,D7
RTS


findlolib:
  ;-- find lowest lib# above d7. set d7 to this lib number
  ;--
  ;-- ne if found, eq if not
  ;-- 
  MOVEQ.l #-$01,D1
  MOVEA.l libpointer,A1

 'loop
    CMPA.w #$0,A1 : BEQ.w 'done
      CMP.w $4(A1),D7 : BCC.w 'next
        CMP.w $4(A1),D1 : BLS.w 'next
          MOVE.w $4(A1),D1
          MOVEA.l A1,A2
   'next
   
    MOVEA.l (A1),A1
  BRA.w 'loop
 'done

  MOVE.w D1,D7
  CMP.w #-$1,D1
RTS


.makeLibFInits:    ;create jsr's to FINIT routines from libs
  ;--
  ;-- also calculate the REGAT variables for inits!
  ;--
  ADDQ.w #1,globalvarpointer
  BCLR #$0,globalvarpointer+1
  MOVEQ.l #$00,D7

 'loop
    BSR.w findlolib : BEQ.w 'azdone
    TST.w 12(A2) : BPL.w 'loop

    MOVEA.l A2,A1
    ADDA.l $12(A1),A1
    TST.w -$2(A1) : BEQ.w 'nomax
      ;
      ;A max lib, possible multiple frees!
      ;
      MOVE.l -$A(A1),D1
      LEA $6(A2,D1.L),A3
     'plop
        TST.w (A3)+ : BEQ.w 'plopf
          ADDQ.w #2,A3
          BRA.w 'plop
     'plopf
      TST.l $4(A3) : BEQ.w 'nomax
      ;
      ;Something to Do!
      ;
      MOVE.w freemax(PC),D1    ;move.w #x,-(a7)
      BSR.w writeword
      MOVE.w -$4(A1),D1
      BSR.w writeword          ;x (max)
      MOVE.l free,D1
      MOVE.w -$6(A1),D1
      BSR.w writelong          ;move.l x(a5),a3
      ;
      MOVE.l destpointer,-(A7)
      MOVEQ.l #$01,D1
      MOVE.w -$2(A1),D2
      LSL.w D2,D1
      MOVE.w D1,-(A7)
      MOVE.l -$A(A1),D1
      BSR.w Amakelibsub
      MOVE.w freemax3(PC),D1
      BSR.w writeword          ;lea x(a3),a3
      MOVE.w (A7)+,D1
      BSR.w writeword
      MOVE.l freemax2(PC),D1
      BSR.w writelong
      MOVE.l (A7)+,D1
      SUB.l destpointer,D1
      BSR.w writeword
      MOVE.w freemax4(PC),D1
      BSR.w writeword
   'nomax

    MOVE.l $1C(A2),D1 :  BEQ.w 'loop
    ;
    ; check special cases!
    ;
    MOVE.w 4(A2),D1

    CMP.w #-$2,D1 : BNE.w 'notvfin              ; was #varslib
      BSR.w makevsize
      BRA.w 'more
   'notvfin

    CMP.w #-$12D,D1 : BNE.w 'more               ; was #strings1lib
      BSR.w makessize
      BRA.w 'more
   'more

    MOVE.l $1C(A2),D1
    MOVE.w #$FFFF,lasta6       ; was -1
    BSR.w Amakelibsub
  BRA.w 'loop
 'azdone
RTS


;------                                                  ;disassembled code begin
freemax:   Dc.w $3F3C,$0000                              ;MOVE.W  #$0000,-(A7)

freemax2:  Dc.w $5357                                    ;SUBQ.W  #1,(A7)
           Dc.w $6600,$FFFC                              ;BNE.W freemax2
freemax4:  Dc.w $544F                                    ;ADDQ.W  #2,A7
freemax3:  Dc.w $47EB,$0000                              ;LEA $0000(A3),A3
;------                                                  ;disassembled code end

Even
insert_stackchk:
  TST.b debugmode : BEQ.b 'skip
    TST.w debugversion : BNE.b 'skip
      MOVE.w #$C308,D1 : BRA.w Atokejsr                  ; (runerrslib, stackchk)
 'skip
RTS


tokejsr2:
  MOVE.w #$FFFF,lasta6

Atokejsr:                                                 ;tokejsr org source
  ;-- make a jsr (or simple reg get) from d1
  ;-- 
  MOVEM.l D0-d7/A0-a6,-(A7)
  MOVE.b #1,nostringopt
  JSR searchinstr
  MOVE.l A3,D1
  SUB.l A2,D1
  BSR.w Amakelibsub
  MOVEM.l (A7)+,d0-d7/a0-a6
RTS


.userjsr:
    ;a2 = lib base of the current command
    ;a1 = start of #parameters
    ;
  MOVE.l libisat,-(A7)                                   ;library write
  MOVE.l A2,libisat

  MOVEA.l A1,A2
  MOVE.w (A2)+,D1
  MOVE.l a2,lastinstructionaddr
  ANDI.w #$FF,D1
  ADDA.w D1,A2
  EXG.l D0,A2
  ADDQ.l #1,D0
  BCLR #$0,D0
  EXG.l D0,A2
BRA.w makelsub2


cutejsr:
  MOVE.l libisat,-(A7)
  MOVE.l A2,libisat
  MOVEA.l A3,A2
BRA.w makelsub2


.scantype:
  MOVE.l a1,-(a7)

 'more
  MOVE.l d0,a0
  MOVE.l $a(a0),d0
  MOVE.l d0,a1
  CMP.l #8,4(a1) : BLE 'norec
    MOVE.l a0,-(a7)
    MOVE.l typebase,-(a7)
    MOVEQ #0,d0
    MOVE.w 4(a0),d0
    ADD.l d0,typebase
    MOVE.l $4(a1),d0
    BSR scantype
    MOVE.l (a7)+,typebase
    MOVE.l (a7)+,a0
 'norec

  CMP.l #newtype_string,d0 : BNE 'nostring
  ADDQ #2,a2offset
  MOVE.l #$3f3c0000,d1
  MOVEQ #0,d0
  MOVE.w 4(a0),d0
  ADD.l typebase,d0
  MOVE.w d0,d1
  BSR writelong
  TST.b debugmode : BEQ 'l1a
    MOVE.l d1,-(a7)
    MOVE.l #$c308,d1 : JSR Atokejsr             ; (runerrlib, stackchk)
    MOVE.l (a7)+,d1
 'l1a

  TST.w 8(a0) : BEQ 'nostring

  MOVEM.l d2/d3,-(a7)
  MOVE.l d1,d2
  MOVEQ #0,d3
  MOVE.w 8(a0),d3
  SUBQ.l #1,d3
  BEQ 'nostring2

 'loop
  ADDQ.l #4,d2
  MOVE.l d2,d1
  BSR writelong

  TST.b debugmode :  BEQ 'l1
    MOVE.l #$c308,d1 : JSR Atokejsr             ; (runerrlib, stackchk)
 'l1
  ADDQ #2,a2offset
  SUBQ.l #1,d3
  BNE 'loop

 'nostring2
  MOVEM.l (a7)+,d2/d3

 'nostring
  MOVE.l (a0),d0
  BNE 'more
  MOVE.l (a7)+,a1
RTS


libisat:   Ds.l 1


Amakelibsub:                                               ;makelibsub org source
  ;lib in a2, sub offset in d1
  ;
  MOVE.l libisat,-(A7)
  MOVE.l A2,libisat
  LEA $6(A2,D1.L),A2

makelsub2:
  ; new >
 .writetype
  CMP.l #$3e19436c,$1c-8(a2) : BEQ 'dowritevar            ;clear type
  CMP.l #$3e18436f,$1c-8(a2) : BEQ 'dowritevar            ;copy type
  CMP.l #$3e175265,$1c(a2)   : BEQ 'dowritevar
  CMP.l #$3e165772,$1c(a2)   : BNE 'nowritef

 'dowritevar
    MOVEM.l a0-a2/d2,-(a7)
    MOVEQ #0,d1
    MOVE.l #0,typebase
    MOVE.l $a(a3),a0
    MOVE.l $4(a0),d0
    CMP.l #8,d0 : BLE 'notype
      BSR scantype
 'notype

    MOVE.l #$3f3c0000,d1
    MOVE.w a2offset,d1 : BSR writelong

    MOVE.l #$3f3c0000,d1
    MOVE.l $a(a3),a0
    MOVE.w 8(a0),d1 : BSR writelong
    
    MOVE.l #$3f3cab12,d1 : BSR writelong
    ADDQ.w #6,a2offset
    MOVEM.l (a7)+,a0-a2/d2
 'nowritef

  TST.b optimize_fpu : BEQ 'nofpu2

  CMP.l #$496e7400,$1a(a2) : BNE 'noint                    ; "Int"
  MOVEQ #0,d1
  SUBQ.l #8,destpointer                                    ; fpu int

  CLR.w a2offset
  CMP.b #2,d2 : BGT 'noword                                ; word ?
    MOVE.w #$48c0,d1                                       ; opcode EXT.l d0+
    OR.w regnumstore,d1
    BSR writeword
    BRA 'exit2
 'noword

  CMP.b #3,d2 : BNE 'nolong                                ; long ?
    BRA 'exit2
 'nolong

  CMP.b #4,d2 : BNE 'noquick                               ; quick ?
    MOVE.w #$e080,d1
    OR.w regnumstore,d1 : BSR writeword
    MOVE.w #$e080,d1
    OR.w regnumstore,d1 : BSR writeword
    BRA 'exit2
 'noquick

  MOVEQ #0,d0
  MOVEQ #0,d1
  MOVE.w regnumstore,d0
  ASL.l #7,d0
  OR.l #$f23c4428,d1                                 ;fsub.s 0.5,fpx
  OR.l d0,d1
  ;BSR writelong

  MOVE.l #$3f000000,d1
  ;BSR writelong

  MOVEQ #0,d0
  MOVEQ #0,d1
  MOVE.w regnumstore,d0
  ASL.l #7,d0
  MOVE.l d0,d1
  OR.l #$f2000003,d1                                 ;fintrz fpx
  ASL.l #3,d0
  OR.l d0,d1
  BSR writelong

  MOVEQ #0,d0
  MOVE.w regnumstore,d0
  ASL.l #7,d0
  MOVE.l #$f2006000,d1                               ;fmove.l fp0,d0
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
  BRA 'exit

 'noint
  CMP.w #$3c01,24(a2) : BNE 'noval
    MOVE.l a2,-(a7)
    BSR.w makelsub3
    MOVE.l (a7)+,a2
    BRA 'exit2

;  MOVE.l (a7),a2
;  MOVE.w (a2),-(a7)                                        ;fpu val
;  MOVE.w #$c0,(a2)
;  BSR.w fetchregs
;  MOVE.l #$4eaeff9a,d1                                     ;SPtieee
;  BSR writelong
;  MOVE.l 2(a7),a2
;  MOVE.w (a7)+,(a2)
;  MOVE.l (a7)+,a2
;  MOVE.l #$4a876604,d1
;  BSR writelong
;  MOVE.l #$f2004400,d1                                     ;fmove.s d0,fp0
;BRA 'exit

 'noval
  CMP.l #$41627300,$1a(a2) : BNE 'noabs                     ; "Abs"
    MOVEQ #0,d1
    MOVE.w regnumstore,d1
    MOVE.w d1,d0
    ASL.w #7,d1
    ASL.w #8,d0
    ASL.w #2,d0
    OR.w d0,d1
    SUBQ.l #8,destpointer                                    ;fpu abs
    MOVEM.l d3/d1,-(a7)
    MOVE.w #5,d3
    EXG d2,d3
    MOVE.w regnum,-(a7)
    MOVE.w regnumstore,regnum
    BSR writeconvertcode

    MOVE.w (a7)+,regnum
    EXG d2,d3
    MOVEM.l (a7)+,d3/d1
    OR.l #$f2000018,d1
    CLR.w a2offset
    BRA 'exit
 'noabs

  CMP.b #5,d2 : BNE 'nofpu2                                ; do we have a float?

  MOVE.b 24(a2),d0
  CMP.b #$60,d0 : BNE 'nofpu                               ;nolib $edxx

  MOVEQ #0,d1
  MOVE.w regnumstore,d1
  MOVE.w d1,d0
  ASL.w #7,d1
  ASL.w #8,d0
  ASL.w #2,d0
  OR.w d0,d1

  MOVE.b 25(a2),d0
  CMP.b #5,d0 : BNE 'nocos
    OR.l #$f200001d,d1                                       ;fpu cos
    BRA 'exit
 'nocos
  CMP.b #$c,d0 : BNE 'nosqr
    OR.l #$f2000004,d1                                       ;fpu sqr
    BRA 'exit
 'nosqr
  CMP.b #$d,d0 : BNE 'notan
    OR.l #$f200000f,d1                                       ;fpu tan
    BRA 'exit
 'notan
  CMP.b #$a,d0 : BNE 'nosin
    OR.l #$f200000e,d1                                       ;fpu sin
    BRA 'exit
 'nosin
  CMP.b #$3,d0 : BNE 'noasin
    OR.l #$f200000c,d1                                       ;fpu asin
    BRA 'exit
 'noasin
  CMP.b #$2,d0 : BNE 'noacos
    OR.l #$f200001c,d1                                       ;fpu acos
    BRA 'exit
 'noacos
  CMP.b #$4,d0 : BNE 'noatan
    OR.l #$f200000a,d1                                       ;fpu atan
    BRA 'exit
 'noatan
  CMP.b #$e,d0 : BNE 'nohtan
    OR.l #$f2000009,d1                                       ;fpu htan
    BRA 'exit
 'nohtan
  CMP.b #$6,d0 : BNE 'nohcos
    OR.l #$f2000019,d1                                       ;fpu hcos
    BRA 'exit
 'nohcos
  CMP.b #$b,d0 : BNE 'nohsin
    OR.l #$f2000002,d1                                       ;fpu hsin
    BRA 'exit
 'nohsin
  CMP.b #$9,d0 : BNE 'nolog
    OR.l #$f2000014,d1                                       ;fpu log
    BRA 'exit
 'nolog
  CMP.b #$8,d0 : BNE 'nolog10
    OR.l #$f2000015,d1                                       ;fpu log10
    BRA 'exit
 'nolog10
  CMP.b #$7,d0 : BNE 'noexp
    OR.l #$f2000010,d1                                       ;fpu exp
    BRA 'exit
 'noexp
  LEA fpuerr,a0
  MOVE.l a0,-(a7)
  JMP handle_compileerror
 ;BRA 'exit                                                  ;??Looks like unneeded code??

 'nofpu
  CMP.b #$3c,d0 : BNE 'nofpu2

  MOVEQ #0,d1
  MOVE.w regnumstore,d1
  MOVE.w d1,d0
  ASL.w #7,d1
  ASL.w #8,d0
  ASL.w #2,d0
  OR.w d0,d1

  CMP.b #$03,25(a2) : BNE 'nosgn
    ;BRA 'noexp
    SUBQ.l #8,destpointer                                ;fpu sgn
    OR.l #$f200003a,d1
    BSR writelong
    CLR.w a2offset
    MOVE.l #$F28E0006,d1 : BSR writelong
    MOVE.l #$7000600a,d1 : BSR writelong                  ; MOVEQ#0,D0
    MOVE.l #$70014840,d1 : BSR writelong
    MOVE.l #$F292,d1     : BSR writeword
    MOVE.l #$000470FF,d1
    BRA 'exit
 'nosgn
  CMP.l #"Frac",$1a(a2) : BNE 'nofrac
    JMP notwork

;        MOVE.l d0,-(a7)
;        MOVEQ #0,d1
;        MOVE.w regnumstore,d1
;        ASL.w #7,d1
;        OR.l #$f23c4428,d1
;        ;OR.l #$f2000380,d1
;        BSR writelong                                      ;fsub.s #-0.5,fp0
;        MOVE.l #$3f000000,d1
;        BSR writelong
;        MOVE.w regnumstore,d1
;        ASL.l #8,d1
;        ASL.l #8,d1
;        OR.l #$f2006000,d1                                 ;fmove.l fp0,d0
;        MOVE.w regnumstore,d0
;        ASL.w #7,d0
;        OR.w d0,d1
;        ;OR.l #$f2000380,d1                                 ;fmove.x fpx,fp7
;        BSR writelong
;        ;MOVE.l #$f2001f83,d1                              ;fintrz,fp7
;        ;BSR writelong
;        MOVEQ #0,d1
;        MOVE.w regnumstore,d1
;        ASL.w #7,d1
;        OR.l #$f23c4422,d1
;
;        BSR writelong                                      ;fadd.s #-0.5,fp0
;        MOVE.l #$3f000000,d1
;        BSR writelong
;        MOVEQ #0,d1
;        MOVE.w regnumstore,d1
;        ASL.l #8,d1
;        ASL.l #8,d1                                        ;fsub.l d0,fp0
;        OR.l #$f2004028,d1
;        MOVE.w regnumstore,d0
;        ASL.w #7,d0
;        OR.w d0,d1
;        ;SUBQ.l #8,destpointer                              ;fpu frac
;        CLR.w a2offset
;        MOVE.l (a7)+,d0
    BRA 'exit

 'nofrac                                                   ;??Looks like double label??
 'nofpu2
  ; < new
  BSR.w makelsub3                                          ;write lib code
  MOVE.l (A7)+,libisat
  RTS

  ; new >
 'exit
  BSR writelong

 'exit2
  MOVE.l (A7)+,libisat
RTS
  ; < new

makelsub3:
  BSR.w fetchregs         ; get register values, f.e. move.l <basicvar>,d0
  ;
  TST.b debugmode : BEQ.w 'norerr
  ;
  MOVE.l (A2),D1
  OR.l 8(A2),D1
  BCLR #$0,D1
  TST.l D1 : BEQ.w 'norerr
  ;
  MOVE.l (A2)+,D1
  BTST #$0,D1 : BEQ.w 'skiptt
    TST.w blitzmode : BPL.w blitzerr

    TST.b debugmode : BEQ.w 'skiptt2
      MOVE.l D1,-(A7)
      MOVE.w #$C311,D1   ; (runerrlib, bmodechk)
      BSR.w makebtst
      MOVE.l (A7)+,D1
   'skiptt2
    BCLR #$0,D1
 'skiptt
  TST.l D1
  BSR.w doajsr

  MOVE.l (A2)+,D1
  BSR.w doajsrrout
  MOVE.l (A2)+,D1
  BSR.w doajsr
  BRA.w 'more

 'norerr
  BTST #$0,$3(A2) : BEQ.w 'penis
    ;
    ;Here, the routine can only run in Blitz Mode
    ;
    MOVE.w blitzmode(PC),D1 : BPL.w blitzerr
 'penis

  MOVE.l 4(A2),D1
  BSR.w doajsrrout

 'more
  MOVEA.l libisat,A2
RTS


doajsrrout:
  ;Here, we suss out bit 0 to see if this
  ;can only happen in Amiga mode.
  ;
  BTST #$0,D1 : BEQ.w 'doajsr
    TST.w blitzmode : BMI.w amigaerr
      TST.b debugmode : BEQ.w 'doajsr2
        MOVE.l D1,-(A7)
        MOVE.w #$C312,D1     ; (runerrlib, amodechk)
        BSR.w makebtst
        MOVE.l (A7)+,D1
     'doajsr2
        BCLR #$0,D1
 'doajsr
  TST.l D1

.doajsr:
  BEQ.w 'skip
    MOVE.l A1,-(A7)
    BSR.w doajsr2
    MOVEA.l (A7)+,A1
 'skip
RTS


.doajsr2:
  MOVEA.l libisat,A0
  TST.w cfetchmode : BEQ.w 'nfetch
    ADD.l A0,D1
    MOVE.l D1,-(A7)
    MOVE.w ##opcode_JSR,D1 : BSR.w writeword
    MOVE.l (A7)+,D1
    BRA.w writelong
 'nfetch
  ;
  ;d1 is an offset from start of lib.
  ;a0 is start of lib.
  ;
  LEA $0(A0,D1.L),A1
  CLR.w inline

 'cute
  CMPI.b #$A0,(A1)+ : BNE.w 'ugly
  TST.b (A1)+ : BEQ.w 'iszero
    CMPI.b #$1,-$1(A1) : BEQ.w 'isone
 'iszero
  ;here, code can be made inline.
  MOVE.w (A1)+,inline
  ADDQ.l #4,D1
  BRA.w 'cute
 'isone

  ;-- here, a blitzmode variation is available
  ;
  TST.w blitzmode : BPL.w 'inamiga
    TST.b debugmode : BEQ.w 'nobrerr
      MOVE.w #$C311,D1 : BSR.w makebtst        ; (runerrlib, bmodechk)
   'nobrerr
    MOVE.l (A1)+,D1
    LEA $0(A0,D1.L),A1
    BRA.w 'cute
 'inamiga

  TST.b debugmode : BEQ.w 'noarerr
    MOVE.l D1,-(A7)
    MOVE.w #$C312,D1 : BSR.w makebtst          ; (runerrlib, amodechk)    
    MOVE.l (A7)+,D1
 'noarerr

  ADDQ.w #4,A1
  ADDQ.l #6,D1
  BRA.w 'cute

 'ugly
  TST.w inline : BEQ.w 'notin
    ;--here, we copy the inline code.
    SUBQ.w #1,A1
    MOVEA.l A1,A0
    ADDA.w inline(PC),A1
    BRA.w pokecode2
 'notin

  MOVEM.l a0/D1,-(A7)          ; was  d1,-(a7)
  ; new >
  TST.w debugversion        : BEQ 'l11
  TST.w set_link_debuginfo   : BEQ.w 'l11
  MOVE.l lastinstruction,d1 : BEQ 'l11
  CLR.l lastinstruction
  CMP.l #$e000,d1 :  BGE 'ln99
  LEA notf,a0
  CMP.l #$c601,d1 :  BNE 'ln1
  LEA strcpy,a0
  BRA 'ln3

 'ln1
  CMP.l #$c700,d1 : BNE 'ln2
    LEA strvar,a0
    BRA 'ln3
 'ln2

  CMP.l #$ce00,d1 : BNE 'ln4
    LEA strcmp,a0
    BRA 'ln3
 'ln4

  CMP.l #$ca00,d1 : BNE 'ln5
    LEA qmul,a0
    BRA 'ln3
 'ln5

  CMP.l #$d000,d1 : BNE 'ln6
    LEA _MaxLen,a0
    BRA 'ln3
 'ln6

  CMP.l #$cb00,d1 : BNE 'ln3
    LEA qdiv,a0
  BRA 'ln3

 'ln99
  MOVE.l d1,a0
  LEA $8(a0),a0

 'l1
  CMP.w #$ffff,(a0)+ : BNE 'l1
  LEA 6(a0),a0

 'ln3
  MOVEM.l a1/a2/d7/d2,-(a7)
  MOVEQ #0,d2
  LEA namebuffer,a1

 'l2
    ADDQ.l #1,d2
    MOVE.b (a0)+,d0
    CMP.b #"$",d0 : BNE 'nodollar          ;A label contain $ does not work for reassembler and assembler.it is replace with S
      MOVE.b #"S",d0
   'nodollar
    CMP.b #"?",d0 : BEQ 'nolabelwrite
  MOVE.b d0,(a1)+ : BNE 'l2

  MOVE.w #"__",-1(a1)
  ADDQ.l #2,d2
  CLR.b 1(a1)
  JSR findlabel2 : BEQ 'l3
    JSR add_LabelHash
 'l3
  CLR.l 4(a2)
  MOVE.l $14(a7),a0
  MOVE.l $10(a7),d1
  SUB.l $12(a0),d1
  ADD.l $28(a0),d1
  MOVE.l d1,8(a2)

 'nolabelwrite
  MOVEM.l (a7)+,a1/a2/d7/d2

 'l11                                                      ;peek/poke
  TST.b typecheck : BEQ 'p1
  MOVE.l lasttoken,d1
  CMP.l #$da01,d1 : BEQ 'lp1                               ;poke
  CMP.l #$da02,d1 : BNE 'p1                                ;peek

 'lp1
  TST.b peekaddrsize : BEQ 'p1
  CMP.b #3,peekaddrsize : BNE errormsg_onlylong
  CLR.b peekaddrsize
;  BEQ 'p1

; 'p2
;  CMP.w #3,lasttoken
;  BNE errormsg_onlylong

 'p1
  TST.b optimize_fpu : BNE 'optf
  TST.b optimize_integer : BEQ 'l10

 'optf
  CNIF #optibreak
    ILLEGAL
  CEND
  CMP.l #"Poke",20(a2) : BNE 'peekopt                     ;poke
  TST.b 24(a2) : BNE 'peekopt

  CMP.b #3,d2  : BNE 'lw1
   'll1
    MOVE.l #$21821990,d1
    BRA.s 'exitjsr

 'lw1
  CMP.b #2,d2 : BNE 'lb1
    MOVE.l #$31821990,d1
    BRA.s 'exitjsr
 'lb1

  CMP.b #1,d2 : BNE 'lp3
    MOVE.l #$11821990,d1
    BRA.s 'exitjsr
 'lp3

  CMP.b #5,d2 : BNE 'l10

  TST.b optimize_fpu : BEQ 'll1

  MOVE.l destpointer,a4
  CMP.l #$f22d4500,-6(a4) : BNE 'noglob
    TST.b doublepeek : BNE 'noglob
      MOVE.w -2(a4),-4(a4)
      MOVE.w #$21ad,-6(a4)
      MOVE.w #$1990,-2(a4)
      MOVE.w #9,peeksize
      ADDQ #8,a7
      RTS
 'noglob

  CMP.l #$f22c4500,-6(a4) : BNE 'nolocal
    MOVE.w -2(a4),-4(a4)
    TST.b doublepeek : BNE 'nolocal                    ;dont move longfix on double floats
      MOVE.w #$21ac,-6(a4)
      MOVE.w #$1990,-2(a4)
      MOVE.w #9,peeksize
      ADDQ #8,a7
      RTS
 'nolocal

  MOVE.w #$f230,d1
  BSR writeword
  MOVE.l #$65001990,d1
  TST.b doublepeek : BEQ 'exitjsr
    OR.l   #$10000000,d1
 'exitjsr
  ADDQ #8,a7
  MOVE.w #9,peeksize
  BRA writelong

 'peekopt
  CMP.l #"Peek",20(a2) : BNE 'l10
  TST.b 24(a2) : BNE 'l10
  CMP.w #7,peeksize : BEQ 'l10

  CMP.w #3,peeksize : BNE.s 'lw1a
   'll1a
    MOVE.l #$20301990,d1
    BRA 'exitjsr
 'lw1a

  CMP.w #2,peeksize : BNE.s 'lb1a
    MOVE.l #$30301990,d1
    BRA 'exitjsr
 'lb1a

  CMP.w #1,peeksize : BNE.s 'lf1
   MOVE.l #$10301990,d1
   BRA 'exitjsr
 'lf1

  CMP.w #5,peeksize : BNE 'l10
    TST.b optimize_fpu : BEQ 'll1a
    MOVE.w #$f230,d1
    BSR writeword
    MOVEQ #0,d1
    MOVE.w tempregnum,d1
    ASL.l #7,d1
    ASL.l #8,d1
    ASL.l #8,d1
    ADD.l #$44001990,d1
    TST.b doublepeek : BEQ 'exitjsr2
      OR.l   #$10000000,d1
   'exitjsr2
    BRA 'exitjsr
 'l10
  ; < new
  MOVE.w ##opcode_JSR,D1 :  BSR.w writeword
  MOVEM.l (A7)+,a0/D1        ; was  (a7)+,d1
  JSR addoff
  SUB.l $12(A0),D1
  ADD.l $28(A0),D1
BRA.w writelong
                                                       ;??Looks like unneeded code??


makebtst:
  MOVE.w D1,-(A7)
  MOVE.w tstmode(PC),D1
   BSR.w writeword
   BSR.w getbbase
   BSR.w writeword
  MOVE.w (A7)+,D1
  MOVEM.l D0/D3-D7/A0-A2/A4,-(A7)
   BSR.w Atokejsr
  MOVEM.l (A7)+,D0/D3-D7/A0-A2/A4
RTS


.getbbase:
  ;this return returns varoff for blitzmode flag
  ;in d1
  ;it will create blitzoff if necessary
  ;
  MOVE.w blitzoff(PC),D1
  CMP.w #-$1,D1 : BNE.w 'done
    ADDQ.w #1,globalvarpointer
    BCLR #$0,globalvarpointer+1
    MOVE.w globalvarpointer,D1
    MOVE.w D1,blitzoff
    ADDQ.w #2,globalvarpointer
 'done
RTS


;------                                                  ;disassembled code begin
tstmode:    Dc.w $4A6D,$0000                             ;TST.W $0000(A5)
;------                                                  ;disassembled code end

inline:     Ds.w 1
blitzoff:   Dc.w $FFFF                                   ;-1 org source
blitzmode:  Ds.w 1                                       ;+=amiga, -=blitz

Even
fetchregs:
  MOVE.w (A2)+,D1
  BEQ.w 'done
    MOVE.w (A2)+,D2
    BSR.w toreg
    BRA.w fetchregs
 'done
RTS


toreg:
  ;-- d1=lib num, d2.b=reg num
  ;--
  CMP.w #-$100,D2 : BCC.w 'yeah
    BCLR #$F,D2 : BEQ.w 'nobm
      ;-- OK, blitz mode must be ON for us to bother doing this one
      TST.w blitzmode : BMI.w 'yeah
        RTS
   'nobm
    BCLR #$E,D2 : BEQ.w 'yeah
    ;-- OK, must be in amiga mode
      TST.w blitzmode : BPL.w 'yeah
        RTS
 'yeah

  JSR uselib
  TST.b D2 : BEQ.w 'norm

  CMP.b #$4,D2 : BNE.w 'suv
    MOVE.w #$0004,-(A7)
    MOVE.l #$FFFFFFFA,-(A7)                                  ;#-6,-(a7) org source
    BRA.w 'sendmd
 'suv
    CMP.b #$3,D2 : BNE.w 'notnmax

    CLR.w -(A7)
    MOVE.l #$FFFFFFFC,-(A7)                                  ;#-4,-(a7) org source
    ;
    ; O.K., we are going to send the current maximum settings.
    ;
 'sendmd
  LSR.w #8,D2
  MOVE.w #$303C,D1                                         ;move.w #x,dn
  BTST #$7,D2 : BEQ.w 'skipad
    MOVE.w #$307C,D1                                       ;move.w #x,an
    CMP.w #$16,D2 : BNE.w 'skipad
      MOVE.w #$FFFF,lasta6                                 ;-1 org source
 'skipad
  ANDI.w #$7,D2
  LSL.w #8,D2
  LSL.w #1,D2
  OR.w D2,D1
  BSR.w writeword

  MOVE.l $12(A1),D1
  ADD.l (A7)+,D1
  MOVE.w $0(A1,D1.L),D1
  ADD.w (A7)+,D1
  BRA.w writeword

 'notnmax
  MOVE.w D2,-(A7)
  LSR.w #8,D2
  CMP.w #$16,D2 : BNE.w 'isnta6
    MOVE.w #$FFFF,lasta6                                     ;-1 org source
 'isnta6
  MOVE.l $12(A1),D1                                        ;objectspace
  MOVE.w -$6(A1,D1.L),-(A7)
  BSR.w makeregop
  BSR.w writeword
  MOVE.w (A7)+,D1
  MOVE.w (A7)+,D2
  TST.b D2 : BPL.w 'skippy1
    ;
    ;<0 - the rest is a register spec.
    ;this reg is used to calc a max item (must be dn)
    ;
   BSR.w writeword                                         ;move.l x(a5),dn
  MOVE.w D2,-(A7)                                          ;store reg used
    ;
  ADDA.l $12(A1),A1
  MOVE.b D2,D1
  ANDI.w #$7,D1
    ;
  TST.b debugmode : BEQ.w 'norerr
    MOVE.w D1,-(A7)
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$B07C,D1                                          ;cmp #x,dn
    BSR.w writeword
    MOVE.w -$4(A1),D1
    BSR.w writeword
    MOVE.l maxchk(PC),D1                                  ;bcs
    BSR.w writelong
    MOVE.l A2,-(A7)
    MOVE.w #$C30A,D1 : BSR.w Atokejsr                       ; (runerrlib, maxerr)
    MOVEA.l (A7)+,A2
    MOVE.w (A7)+,D1
 'norerr
  MOVE.w -$2(A1),D2                                        ;shift amount

 'shloop
    CMP.w #$9,D2 : BCS.w 'simp
      MOVEM.w D1-D2,-(A7)
        ;
      MOVEQ.l #$00,D2                                          ;!!!!!
        ;
      LSL.w #8,D2
      LSL.w #1,D2
      OR.w D2,D1
      OR.w lsldn(PC),D1
      BSR.w writeword
      MOVEM.w (A7)+,D1-D2
      SUBQ.w #8,D2
  BRA.w 'shloop
 'simp

  MOVE.w D1,-(A7)
  OR.w #$48c0,d1                                          ; EXT.l d0
  BSR writeword
  MOVE.w (a7),d1
  TST.w D2 : BEQ.w 'simp2
    ;
    ANDI.w #$7,D2                                            ;?????
    ;
    LSL.w #8,D2
    LSL.w #1,D2
    OR.w D2,D1
    OR.w lsldn(PC),D1
    BSR.w writeword
 'simp2
  ;--
  ;-- Shifts are done, add'em to the opcode
  ;--
  MOVE.w (A7)+,D1
  ANDI.w #$7,D1
  OR.w maxdo(PC),D1
  MOVE.w (A7)+,D2
  LSL.w #1,D2
  ANDI.w #$E00,D2
  OR.w D2,D1
  BRA.w writeword

 'skippy1
    CMP.b #$1,D2 :BEQ.w 'skippy
      ;--
      ;-- select used of a max block
      ;--
      ADDQ.w #4,D1
      ;
      TST.b debugmode : BEQ.w 'skippy
        BSR.w writeword
        SWAP D1
        MOVE.w 'theretest(PC),D1
        SWAP D1
        BSR.w writelong
        MOVE.l 'theretest+4(PC),D1
        BSR.w writelong
        MOVE.l 'theretest+8(PC),D1
        BRA.w writelong
 'skippy                                            ;select base of a max block
BRA.w writeword


; "no currently used object" error
;------                                                ;disassembled code begin
 'theretest
            Dc.w $4AAD,$0000                           ;TST.L  $0000(A5)
            Dc.w $6600,$0006                           ;BNE.W  'ttskip
            Dc.w $7001                                 ;MOVEQ  #$01,D0
            Dc.w #opcode_TRAP0                         ;TRAP   #00
 'ttskip
;------                                                ;disassembled code end

 'norm
  LSR.w #8,D2
  CMP.b #$16,D2 : BNE.w 'nota6
    MOVE.w $A(A1),D1
    CMP.w lasta6,D1 : BEQ.w 'sk
      MOVE.w D1,lasta6
 'nota6

  BSR.w makeregop
  TST.w $1A(A1) : BPL.w 'long
    CMP.w stackop(PC),D1 : BNE.w 'notst
      SUBQ.w #2,a2offset
   'notst
    ORI.w #$1000,D1
 'long
  BSR.w writeword
  MOVE.w $A(A1),D1
  BSR.w writeword
 'sk
RTS


;------                                                                 ;disassembled code begin
lsldn:      Dc.b $E1,$88                 ;Dc.b $48 ;object long acsess    ;LSL.L   #8,D0
maxchk:     Dc.b $65,$00,$00,$08                                          ;BCS.W   maxchk_ok
            Dc.b $4E,$B9,$00,$00,$00,$00                                  ;JSR     $00000000
maxchk_ok:

maxdo:      Dc.b $D1,$C0                                                  ;ADDA.L  D0,A0        ;old Dc.b $d0 $C0,00   ;ADDA.W  D0,A0

;stackopuse:                                                              ;??looks like not used??
            Dc.b $00,$00
stackop:    Dc.b $2F,$2D,$00,$00                                          ;MOVE.L  $0000(A5),-(A7)
;------                                                  ;disassembled code end


makeregop:
    ;make move x(a5),dn/an based on d2
    ;
  CMP.b #$FF,D2
   BNE.w 'notst
  MOVE.w stackop(PC),D1
  ADDQ.w #4,a2offset
 RTS

 'notst
  MOVE.l A3,-(A7)
  LEA regtransd,A3
  BTST #$4,D2
   BEQ.w 'skip
  LEA regtransa,A3

 'skip
  ANDI.w #$7,D2
  MOVE.w D2,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w (A3),D1
  MOVEA.l (A7)+,A3
RTS


ifchar:
    ;return eq=1 if <,=,>
    ;
  CMP.w #$3C,D0
   BCS.w 'no
  CMP.w #$3E,D0
   BHI.w 'no
  SUBI.w #$3C,D0
  CMP.w D0,D0

 'no
RTS


evalconst:
  ;bsr.w bakup
  ;
  ;evaluate a constant at a5...
  ;first char in d0...
  ;
  ;get long into d3 (d6=0)
  ;or ffp into d3 (d6<>0)
  ;
  ; new <
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new

evalconst2  ;
evalconst3:
  ;move.l maths,a6
  ;
  ;MOVE.b isconstantvalue,-(a7)                 ;new
  ;MOVE.l lastconstantvalue,-(a7)
  MOVE.w regnum,-(A7)
  CLR.w regnum
  MOVE.l destpointer,-(A7)
  MOVE.l destbufferend,-(A7)
  MOVE.w dontwrite_nomemleft,-(A7)
  MOVE.w lasta6,-(A7)
  MOVE.w cfetchmode,-(A7) : BNE.w 'something
    MOVE.l destbufferend,oldlibat
    MOVEA.l constpcat,A0
    MOVE.l A0,destpointer
    BRA.w 'some2
 'something
    ;already cfetching!
    ;
    MOVEA.l destpointer,A0     ;continue in cmode buff
 'some2

  MOVE.l A0,-(A7)
  MOVE.l constlibat,destbufferend      ;for overflow
  CLR.w dontwrite_nomemleft

  MOVE.w #$FFFF,lasta6                 ; was -1
  MOVE.w #$FFFF,cfetchmode             ; was -1
  ; new >
  ;clr.b _neg
  ; < new
  BSR.w arreval                      ;!
  ; new >
  MOVE.l (a7),a0

  !newcalc
  BEQ 'l10
    MOVE.l d0,d3
    MOVEA.l (A7)+,A0
    BRA 'bc1
 'l10
    ; <new
    MOVE.w #$2600,D1              ;move.l d0,d3
    OR.w regnum,D1         : BSR.w writeword
    MOVE.w ##opcode_RTS,D1 : BSR.w writeword
    ;
    MOVE.w dontwrite_nomemleft,D1 : BNE.w conmemerr
    ;
    MOVEA.l (A7)+,A0
    ; new >
    NOP
    ; < new
    JSR clear_Cache                                         ;simple expression
    JSR (A0)                                                ;writeresult
 'bc1
  MOVE.w (A7)+,cfetchmode
  MOVE.w (A7)+,lasta6
  MOVE.w (A7)+,dontwrite_nomemleft
  MOVE.l (A7)+,destbufferend
  MOVE.l (A7)+,destpointer
  MOVE.w (A7)+,regnum
  ; new >
  ;MOVE.l (a7)+,lastconstantvalue
  ;MOVE.b (a7)+,isconstantvalue
  ; < new
JMP reget


oldlibat:   Ds.l 1


.do_INCDIR:
  LEA incdir,A0

 'loop
    CMP.w #$22,D0 : BEQ.w 'skip     ;'"'   
      MOVE.b D0,(A0)+
      TST.w D0 : BEQ.w 'done
        BMI.w syntaxerr
   'skip
    JSR get1bytemain
  BRA.w 'loop
 'done
RTS


makeiname:
  ;--
  ;-- create include name
  LEA namebuffer,A1
  LEA incdir,A0

  MOVEQ.l #-$01,D2
 'loop0
    ADDQ.w #1,D2
    MOVE.b (A0)+,(A1)+
  BNE.w 'loop0
  SUBQ.w #1,A1

  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

 'loop:
    JSR get1bytemain

    TST.w D0 : BMI.w syntaxerr

    CMP.b #$22,D0 : BEQ.w 'loop       ;'"'    
      MOVE.b D0,(A1)+
      BEQ.w 'done
        ADDQ.w #1,D2
  BRA.w 'loop

 'done
  TST.w D2 : BEQ.w syntaxerr
RTS


;NEWTYPE.includeentry  ; same structure as labellist
;  ptr_next_entry.l    ;0
;  ptr_sourcebuffer.l  ;4
;  filehandle.l        ;8
;  <noteused>          ;12
;  current includeline ;14
;  entrysize in bytes  ;18
;  string...           ;19
;End NEWTYPE

.read_includeline: ;-- do include next line, a5 = position in buffer

  MOVEA.l includebase,A2

  MOVEA.l 14(A2),A5               ; get current include line

  MOVE.l a5,includesourceline
  
  LEA inctab,a0  
  MOVE.w ininclude,d0
  MOVE.l $0(a0,d0 * 4),d0         ; current include source position
  MOVEA.l 4(A2),A0                ; get sourcebuffer
  LEA 0(A0,D0.l),A0               ; move to position in source buffer

  MOVEA.l A5,A1
 'loop
    CMPA.l A0,A1 : BCC.w readpend
    TST.b (A1)+
  BNE.w 'loop
BRA.w imakeend

.readpend:
  ;--
  ;-- o.k., no 0's past where we're at!
  MOVEA.l 4(A2),A1                              ; get sourcebuffer of include
 'loop
    CMPA.l A0,A5 : BCC.w 'skip
    
    MOVE.b (A5)+,(A1)+
  BRA.w 'loop
 'skip

  MOVE.l A1,D0
  SUB.l 4(A2),D0

  LEA inctab,a0
  MOVEQ #0,d1 : MOVE.w ininclude,d1
  MOVE.l d0,0(a0,d1 * 4)                        ; store current position in include

  MOVE.l A1,D2
  MOVE.l D2,include_base
  MOVE.l #$10000000,d3                          ; load whole file
  SUB.l D0,D3
  
  MOVEA.l _dosbase,A6 
  
  MOVE.l 8(A2),D1 : JSR _Read(A6)               ;d1:file, d2:buffer, d3:length

  TST.l D0 : BMI.w error_reading_file           ;-1 could not read from file
  
  MOVE.l D0,include_length                      ; how many bytes read from file

  TST.l include_length : BEQ.w next_includefile

  !ComData_GetL{comPtr_PreProcessor,include_preprocessor}
  !basic
  ilen.l  = PeekL(?include_length)
  ibase.l = PeekL(?include_base)
  ido.l   = PeekL(?include_process)
  *tn.preprocessor = PeekL(?include_preprocessor)
  If ido
    ioffset.l = SkipXtraHeader{ibase,ilen}
    nilen.l = preproc_Tokenize{*tn,ibase+ioffset,ibase,ilen-ioffset}
    If nilen>0
      ;For n.l=nilen To ilen-1
      ;  PokeB ibase+n,0
      ;Next
      PokeL ?include_length,nilen
    End If
  End If
  !asm

  MOVE.l #0,include_process

  MOVE.l include_length,D0
  LEA inctab,a0
  MOVEQ #0,d1
  MOVE.w ininclude,d1
  ADD.l d0,0(a0,d1 * 4)
  ; < new
  ;ADD.w D0,12(A2)
  ; ; was beq next_includefile
  MOVEA.l 4(A2),A5
  ;MOVE.w 12(A2),D0
  ; new <
   MOVE.l 0(a0,d1*4),d0
  ; < new
  CLR.b $0(A5,D0.l)

imakeend:
  MOVEA.l A5,A0

 'loop2
    TST.b (A0)+
  BNE.w 'loop2
  MOVE.l A0,14(A2)
RTS


include_length:        Dc.l 0                              ; for tokenizer!
include_base:          Dc.l 0
include_process:       Dc.l 0
include_preprocessor:  Dc.l 0


.next_includefile:
  MOVE.l 8(A2),D1 : JSR _Close(a6)
  CLR.l 8(a2)

  MOVEA.l _execbase,A6
  MOVEA.l 4(A2),A1 : JSR _FreeVec(a6)

  MOVE.l (A2),includebase
  MOVEA.l A2,A1
  MOVEQ.l #$00,D0 : MOVE.b 18(A2),D0
  MOVE.l mempool2,a0 : JSR _FreePooled(A6)

  JSR remove_includename

  SUBQ.w #1,ininclude : BNE.w read_includeline

  ;new >
 'l2a
  LEA _include,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA namebuffer,a1
 'l1b
    MOVE.b (a0)+,(a1)+
  BNE 'l1b
  MOVEQ #9,d2
  JSR findlabel2 : BNE 'd
    CLR.l 8(a2)
 'd
  MOVEM.l (a7)+,a0-a6/d0-d7
RTS


.free_unusedfunctions:
  MOVE.l unusedfunc,d0 : BEQ 'noclear
    MOVEM.l d0-d2/a0-a1/a6,-(a7)
    MOVE.l _execbase,a6    
   'f1
      MOVE.l d0,a1
      MOVE.l 4(a1),d0
      MOVE.l (a1),d2
      JSR _FreeMem(a6)
      MOVE.l d2,d0
    BNE 'f1
    CLR.l unusedfunc

    MOVEM.l (a7)+,a0-a1/a6/d0-d2
 'noclear
RTS

.free_xincludes:
  MOVEA.l xincludebase,A2
  CLR.l xincludebase

  MOVEA.l _execbase,A6
 'loop
    CMPA.w #$0,A2 : BEQ.w 'done
    
    MOVEQ.l #$00,D0 : MOVE.b 4+8(A2),D0           ; was 4 org
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVE.l mempool2,a0 : JSR _FreePooled(A6)
  BRA.w 'loop
 'done
RTS


.free_includes:
  MOVEA.l includebase,A2
  CLR.l includebase

  MOVEA.l _execbase,A6
 'loop
    CMPA.w #$0,A2 : BEQ.w 'done

    ;-- close the include file if still open
    MOVE.l 8(A2),D1 : BEQ.w 'noclose
      MOVEA.l _dosbase,A6
      JSR _Close(A6)
      MOVEA.l _execbase,A6
   'noclose

    ;-- free include content
    MOVE.l 4(A2),D0 : BEQ.w 'skip 
      MOVEA.l D0,A1 : JSR _FreeVec(a6)
   'skip

    ;-- free list entry
    MOVEQ.l #$00,D0 : MOVE.b 18(A2),D0
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVE.l mempool2,a0 : JSR _FreePooled(A6)
  BRA.w 'loop
 'done
RTS


pokedata2l:
  ;
  ;poke a long into data2!
  ;
  SWAP D0
  BSR.w pokedata2
  SWAP D0

pokedata2:
  ;poke a word into data2 (data staements)
  ;
  MOVEA.l data2,A4
  CMPA.l allat,A4
  BCC.w 'over
    MOVE.w D0,(A4)+
    MOVE.l A4,data2
    RTS
 'over
  MOVE.w #$FFFF,dontwrite_nomemleft        ; was -1
  ADDQ.l #2,data2
RTS


pokedata2b:
  MOVEA.l data2,A4
  CMPA.l allat,A4
  BCC.w 'over
    MOVE.b D0,(A4)+
    MOVE.l A4,data2
    RTS
 'over
  MOVE.w #$FFFF,dontwrite_nomemleft        ; was -1
  ADDQ.l #1,data2
RTS


getsp:
  ;get a string parameter for conditional stuff
  ;into a0
  CMP.w #$22,D0          ;'"'
  BNE.w syntaxerr

 'getsp2
    JSR get1bytemain
    CMP.b #$22,D0       ;'"'
    BEQ.w 'done
      TST.w D0
      BEQ.w syntaxerr
        MOVE.b D0,(A0)+
  BRA.w 'getsp2
 'done
  CLR.b (A0)
RTS


numcom:
  TST.l D3
RTS


strcom:
  ;--
  ;-- compare strings. set flags accordingly
  LEA namebuffer,A0
  LEA namebuffer2,A1

 'loop
    MOVE.b (A0)+,D0 : BEQ.w 'short
    
    CMP.b (A1)+,D0 : BEQ.w 'loop
    RTS
 'short
  TST.b (A1) : BNE.w 'lt
    RTS
 'lt
  CMP.w #$1,D0
RTS


;-----------built in tokens------------;
;tokes

.do_DEFTYPE:
  CMP.w #".",D0 : BNE.w syntaxerr                ;dodeftype
 
  BSR.w getparameter2
  LEA newtypebase,A2
  BSR.w findtype : BNE.w notypeerr

  ; new >
  TST.b declare  : BNE 'l1
    TST.b declare2 : BEQ 'l2
 'l1
    MOVE.b #2,nowdeclare
 'l2
  ; < new
  JSR reget : BNE.w 'more
    MOVE.l A2,defaulttype
    RTS
 'more
  ;
  ;deftype.l varlist...
  ;
  MOVE.l defaulttype,-(A7)
  MOVE.l A2,defaulttype

 'loopz
  BSR.w getparameter
  BSR.w fetchvars
  CMP.w #",",D0 : BNE.w 'done
    JSR get1bytemain                              ; was BSR.w
    BRA.w 'loopz
 'done
 
  MOVE.l (A7)+,defaulttype
RTS


maxprep1:   LEA $4(A5),A2                                            ;fehler function
maxprep2:   MOVE.l A2,D0

.do_MaxLen: ;-- set a strings maximum length.
  BSR.w getparameter
  BSR.w fetchvars
  BSR.w calcvar

  CMP.b #$7,D2 : BNE.w mismatcherr      ; typecheck if not string...

  MOVE.w varmode(PC),-(A7)
  CMP.w #"=",D0 : BNE.w syntaxerr
  

  BTST #$F,D2 : BNE.w 'already
    MOVE.w maxprep1(PC),D1
    BSR.w pokewda5s
    MOVE.w D3,D1
    BSR.w writeword
 'already

  MOVE.w maxprep2(PC),D1 : BSR.w writeword
  ADDQ.w #1,regnum
  MOVEQ.l #$03,D2
  BSR.w eval

  MOVE.l #$D000,D1              ; was #maxlen
  ; new >
  MOVE.l d1,lastinstruction
  ; < new
  TST.w (A7)+ : BEQ.w Atokejsr
  ADDQ.w #1,D1
BRA.w Atokejsr


.getmaxel:
  MOVE.w D0,D1 : BPL.w syntaxerr
  
  BCLR #$F,D1
  JSR searchinstr
  MOVE.l 18(A2),D0
  TST.w -$2(A2,D0.L) : BEQ.w freeerr

  MOVEQ.l #$02,D2
  MOVE.l A2,-(A7)
  ;
   BSR.w eval
  ;
  MOVEA.l (A7)+,A2
  MOVE.l A2,mymaxlib
  ;
  ADDA.l 18(A2),A2
  TST.b debugmode
   BEQ.w 'pen
  ;
  ;check maximum overflow
  ;
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$B07C,D1       ;cmp #x,dn
  BSR.w writeword
  MOVE.w -4(A2),D1
  BSR.w writeword
  MOVE.l maxchk,D1      ;bcs
  BSR.w writelong
  MOVE.l A2,-(A7)
  MOVE.w #$C30A,D1 : BSR.w Atokejsr     ; (runerrlib, maxerr)
  MOVEA.l (A7)+,A2

 'pen
  MOVE.w -$2(A2),D2     ;# shifts

 'loop
  MOVE.w regnum,D1
  OR.w lslimm,D1
  CMP.w #$8,D2
   BCS.w 'under
   BSR.w writeword
  SUBQ.w #8,D2
   BNE.w 'loop
 BRA.w 'shdone

 'under
  MOVE.w D2,D0
  LSL.w #8,D0
  LSL.w #1,D0
  OR.w D0,D1
  BSR.w writeword

 'shdone
RTS


;------                                                  ;disassembled code begin
free:
  Dc.b $26,$6D,$00,$00                                     ;MOVEA.L $0000(A5),A3
  Dc.b $D6,$C0                                             ;ADDA.W  D0,A3
freef:  ;
;------                                                  ;disassembled code end

mymaxlib:  Ds.l 1


.do_free:
  BSR.w getmaxel
  ;
  LEA free(PC),A0
  LEA freef(PC),A1
  MOVE.w -$6(A2),$2(A0)
  BSR.w pokecode
  ;
  MOVE.l -$A(A2),D1

maxjsr:
  BEQ.w JMP_nosuperr
  MOVEA.l mymaxlib(PC),A2
BRA.w Amakelibsub

.JMP_nosuperr: JMP nosuperr

.do_use:
  BSR.w getmaxel
  ;
  LEA use,A0
  LEA usef,A1
  MOVE.w -$6(A2),$2(A0)
  MOVE.w -$6(A2),-$2(A1)
  ADDQ.w #4,-$2(A1)
  BSR.w pokecode
  ;
  MOVE.l -14(A2),D1
  ;
BRA.w maxjsr


.do_else2:
  JSR get1bytemain

.do_else:
  MOVE.l firstiff,D0 : BEQ.w noiferr

  MOVEA.l D0,A0
  CMPI.b #$1,$D(A0) : BEQ.w illelseerr ;illegal else in while block

  MOVE.w ##opcode_BRA,D1
  
  CNIF #longbranch
    ; make a 32bit branch as $60FF indicates it,
    ; whereas $6000 indicates a 16bit jump
    TST.b optimize_integer : BEQ 'l1
      OR.l #$ff,d1  
      BSR writeword
   'l1
  CEND

  SWAP D1
  BSR.w writelong

  MOVEQ.l #$00,D1 : BSR.w doendif2
  MOVE.l destpointer,$8(A0)
BRA.w do_then


.do_cerr:
  LEA namebuffer,A0
  MOVE.l A0,-(A7)
  BSR.w getsp
BRA.w handle_compileerror


.do_cnif:
  BSR.w evalconst
  MOVEQ.l #$05,D1       ;beq
   ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  LEA numcom,A0
BRA.w compare


.do_csif:
  LEA namebuffer,A0
  BSR.w getsp
  JSR get1bytemain
  BSR.w collif
  LEA namebuffer2,A0
  BSR.w getsp
  LEA strcom,A0


.compare:
  ;use subroutine in a0, cc in d1 to compare then enable
  ;or disable compilation
  ;accordingly
  ;
  LSL.w #2,D1
  LEA CIF_branches,A1
  MOVE.l $0(A1,D1.W),-(A7)
  MOVEQ.l #-$01,D1           ;comp flag

  JSR (A0)

  MOVEA.l (A7)+,A1
JMP (A1)


cif_eq:
  BEQ.w cifdo
BRA.w cifdont

cif_ne:
  BNE.w cifdo
BRA.w cifdont

cif_lt:
  BLT.w cifdo
BRA.w cifdont

cif_le:
  BLE.w cifdo
BRA.w cifdont

cif_gt:
  BGT.w cifdo
BRA.w cifdont

cif_ge:
  BGE.w cifdo

cifdont:
  MOVEQ.l #$00,D1

cifdo:
  MOVEA.l concomsp,A0
  MOVE.w skipcode,(A0)+
  MOVE.l A0,concomsp
  MOVE.w D1,skipcode
  JSR get1bytemain
   BNE.w syntaxerr
JMP bakup


;------                                                  ;disassembled code begin
rescode:   Dc.b $2B,$7c,$00,$00,$00,$00 :   Ds.w 1         ;MOVE.L  #$00000000,$0000(A5)
rescode2:  Dc.b $2B,$40                 :   Ds.w 1         ;MOVE.L  D0,$0000(A5)
;------                                                  ;disassembled code end


.do_Restore:                                              ;Restore 'label'
  MOVE.w #$FC17,D1 : JSR uselib                              ;datalib
  
  JSR reget : BEQ.w 'resbeg
    BSR.w makealab2                                          ;get label name!
    MOVE.w rescode(PC),D1 : BSR.w writeword
    JSR addoff                                               ;add offset
    MOVE.l 12(A2),D1 : BSR.w writelong                       ; move labelpointer to A5
    MOVE.w rescode+6(PC),D1 : BSR.w writeword
    MOVE.l 4(A2),D1 : BEQ.w 'no                              ;is it outstanding?
      ;-- yes - tell it that reference is a DATA statement one
      MOVEA.l D1,A1
      ADDQ.l #1,$4(A1)                                        ;make odd - flag for data reference.
      RTS
    'no
      ;-- data label not outstanding...this not working!?!?
      RTS
 'resbeg  
                                                           ;restore to beginning...
  MOVE.w #$CD00,D1 : JSR Atokejsr                          ;#datalib, token to get datapointer in D0
  MOVE.l rescode2(PC),D1                                   ; move d0 to basic var in A5
JMP writelong


.do_read:
  MOVE.w #$FC17,D1 : JSR uselib                            ;#datalib, init

 'loop
    MOVE.l dataget,D1 : BSR.w writelong
    BSR.w getparameter
    BSR.w fetchvars
    BSR.w calcvar
    BTST #$E,D2 : BEQ.w 'notap
      MOVE.b #$6,D2                                           ;pointer becomes an address!
   'notap
  
    TST.b D2 : BEQ.w noleterr                                 ;read in a whole struct....later!

    TST.b debugmode : BEQ.w 'norerr
      MOVE.w #$7000,D1                                        ;moveq #0,d0
      MOVE.b D2,D1
      ANDI.b #$F,D1
      BSR.w writeword

      MOVE.w #$C310,D1                                        ; (runerrlib, datachk)
      MOVE.w D2,-(A7)
      BSR.w Atokejsr
      MOVE.w (A7)+,D2
   'norerr

    CMP.b #$7,D2 : BEQ.w 'string
    
    CMP.b #$1,D2 : BNE.w 'notbyte
      LEA dataletb2,A0
      LEA dataletb2f,A1
      BTST #$F,D2 : BEQ.w 'bimm
        BSR.w pokecode
        BRA.w 'next
     'bimm
      LEA dataletb,A0
      LEA dataletbf,A1
      ;
      TST.w varmode : BEQ.w 'byteglobal
        LEA dataletbl,A0
        LEA dataletblf,A1
     'byteglobal
      MOVE.w D3,$4(A0) : BSR.w pokecode
      BRA.w 'next
   'notbyte

    LEA dataletw,A0
    CMP.b #$3,D2 : BCS.w 'word
      LEA dataletl,A0
   'word

    BTST #$F,D2 : BEQ.w 'imm
      MOVE.w $4(A0),D1 : BSR.w writeword
      BRA.w 'next
   'imm

    TST.w varmode : BEQ.w 'wlglobal
      ADDQ.w #6,A0
   'wlglobal

    MOVE.w D3,$2(A0)
    MOVE.l (A0),D1 : BSR.w writelong

   'next
    MOVE.l dataput,D1 : BSR.w writelong
    CMP.w #",",D0 : BEQ.w 'more
      RTS
   'more

    JSR get1bytemain
  BRA.w 'loop

 'string
  MOVE.w stlenget,D1 : BSR.w writeword     ;move.l (a3)+,-(a7)

  BTST #$F,D2 : BNE.w 'ok
    TST.w varmode : BEQ.w 'sglobal
      MOVE.w D3,leaampl+2
      MOVE.l leaampl,D1
      BRA.w 'sskip
   'sglobal
      MOVE.w D3,leaamp+2
      MOVE.l leaamp,D1
   'sskip
    BSR.w writelong
 'ok

  MOVE.w #$C701,D1                         ; #allocstring
  MOVE.w varmode,D2 : BEQ.w 'global
   SUBQ.w #1,D1
 'global
  BSR.w Atokejsr

  MOVE.w #$FFFF,lasta6    ; was -1
  LEA stalign,A0
  LEA stalignf,A1
  BSR.w pokecode
BRA.w 'next


.getsize2:
  CMP.w #".",D0 : BNE.w 'word              ;definecode 'lb 'lw 'll
  
  JSR get1bytemain
  CMP.w #$77,D0 : BEQ.w 'word2        ;'w'
  CMP.w #$62,D0 : BEQ.w 'byte         ;'b'
  ; new >
  CMP.w #"s",d0 : BEQ 'single3        ;'s'
  CMP.w #"d",d0 : BEQ 'double3        ;'d'
  ; < new
  CMP.w #$6C,D0 : BNE.w syntaxerr     ;'l'
            
  MOVEQ.l #$02,D1
RTS
 ; new >
 'single3
  MOVE.b #1,iee
  MOVEQ.l #$3,d1
RTS

 'double3
  MOVE.b #1,iee
  MOVEQ.l #$4,d1
RTS
 ; < new

 'byte
  MOVEQ.l #$00,D1
RTS

 'word2
  MOVEQ.l #$01,D1
RTS

 'word
  MOVEQ.l #$01,D1
JMP bakup


.do_dcb:
  BSR.w getsize2

  MOVE.w D1,-(A7)
  BSR.w evalconst2
  CMP.w #",",D0    : BNE.w syntaxerr
   
  MOVE.l D3,-(A7)
  BSR.w evalconst2
  MOVE.l D3,D1        ;to put in memory
  MOVE.l (A7)+,D3     ;number of times
  MOVE.w (A7)+,D2
  BEQ.w 'byte
   ;bsr.w do_even
  ; new >
   ;addq.l #1,destpointer                                   ;even
   ;bclr #$0,destpointer+3
  ; < new
  CMP.w #$1,D2 : BEQ.w 'word

 'long
  SWAP D1 : BSR.w writeword
  SWAP D1 : BSR.w writeword
  SUBQ.l #1,D3 : BNE.w 'long
RTS

 'word
  BSR.w writeword
  SUBQ.l #1,D3 : BNE.w 'word
RTS

 'byte
   BSR.w writebyte
  SUBQ.l #1,D3 : BNE.w 'byte
RTS


.do_ds:
  BSR.w getsize2                                          ;definestorage
  MOVE.w D1,-(A7)
  BSR.w evalconst3
  MOVE.w (A7)+,D1
  LSL.l D1,D3
  ; new >
  MOVE.l d3,d0
  BEQ 'll5
  MOVEQ #0,d1

 'll10
    JSR writebyte
    SUBQ.l #1,d3
  BNE.s 'll10

 'll5
 ; < new
 ;ADD.l d3,pc   ; or source
RTS


.insasm2:
  MOVE.w D0,-(A7)
  LEA dummyasm,A0
  MOVEA.l destpointer,A1
  MOVE.w asmlen2,asmlen
  JSR insasm
  MOVE.w (A7)+,D0
RTS


.do_dc:
  BSR.w getsize2

  MOVE.l #namebuffer,asmbuff
  TST.w D1
   BEQ.w 'byte
  CMP.w #$1,D1
   BEQ.w 'word
  ; new >
  CMP.w #$2,d1
   BEQ 'long
  CMP.w #$3,d1
   BEQ 'single
  ; < new
  ;
  ;Long!
  ;
   MOVEQ.l #$0d,D3
   ;bsr.w do_even
  ; new >
   ;addq.l #1,destpointer                                   ;even
  ;bclr #$0,destpointer+3
  ; < new

 'lloop
   JSR asmconst
   BSR.w insasm2
   BSR.w writelong
   ; new >
   BSR   writelong
   ; < new
  CMP.w #",",D0    ; ','
   BEQ.w 'lloop
 RTS

  ; new >
 'long
  MOVEQ.l #$0B,D3
   ;bsr.w do_even
   ;addq.l #1,destpointer                                   ;even
  ;bclr #$0,destpointer+3
  MOVE.b #1,_dcb

 'lloopb
  JSR asmconst
  CLR.b _dcb
  BSR.w insasm2
  BSR writebyte
  BSR writebyte
  BSR writebyte                                            ;long
  BSR writebyte
  CMP.w #",",D0
   BEQ.w 'lloopb
 RTS

 'single
  MOVEQ.l #$0c,D3
  ;bsr.w do_even
  ;addq.l #1,destpointer                                    ;even
  ;bclr #$0,destpointer+3
  MOVE.b #1,_dcb

 'lloopa
    JSR asmconst
    CLR.b _dcb
    BSR.w insasm2
    BSR.w writebyte
    BSR.w writebyte
    BSR.w writebyte
    BSR.w writebyte
  CMP.w #",",D0 : BEQ.w 'lloopa
 RTS
  ; < new

 'byte  ;Byte!
  MOVEQ.l #$11,D3

 'bloop
    JSR get1bytemain

    CMP.w #$22,D0     : BNE.w 'notq               ;'"'
      
   'qloop
    ; JSR get1bytemain        ; org source

    MOVE.b (a5)+,d0   : BEQ.w JUMP_syntaxerr           ;bsr.w get1bytemain ascii dc.b
    CMP.w #$22,D0     : BEQ.w 'qdone              ;'"'
    CMP.b #"\",d0     : BNE 'n1
    CMP.b #"\",(a5)   : BEQ 'do1
  
   'n1
    ; < new
    MOVE.w D0,D1 : BSR.w writebyte
    BRA.w 'qloop

  ; new >
 'do1
  CMP.l #"__DA",1(a5) : BNE 'nodate1
  CMP.l #"TE__",5(a5) : BEQ 'c1
  CMP.l #"TE_G",5(a5) : BNE 'nodate1
  CMP.l #"ER__",9(a5) : BNE 'nodate1
  JSR compiledatedc_ger
  BRA 'n1

 'c1
  JSR compiledatedc
  BRA 'n1

 'nodate1
  CMP.l #"__VE",1(a5) :  BNE 'n1
  CMP.w #"R_",5(a5)   :  BNE 'n1
  JSR version_string_dc
 BRA.w 'qloop

 'qdone
  CLR.w instringon
  JSR get1bytemain
 BRA.w 'bdone

 'notq
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  JSR asmconst
  SUBQ.l #1,destpointer
  BSR.w insasm2
  ADDQ.l #1,destpointer
  BSR.w writebyte

 'bdone
  CMP.w #",",D0 : BEQ.w 'bloop
  RTS

 'word
  MOVEQ.l #$10,D3
   ;bsr.w do_even
  ; new >
   ;addq.l #1,destpointer                                   ;even
  ;bclr #$0,destpointer+3
  ; < new

 'wloop
  ; new >
  MOVE.b #1,_dcb
  ; < new
  JSR asmconst
  ; new >
  CLR.b _dcb
  ; < new
  BSR.w insasm2
  ;bsr writeword  ; org source
  ; new >
  BSR.w writebyte
  BSR.w writebyte
  ; < new
  CMP.w #",",D0 : BEQ.w 'wloop
RTS


.do_even4:                                                 ;long align
  ADDQ.l #3,destpointer
  ANDI.w #$FFFC,destpointer+2
RTS


.do_even8:                                                 ;phrase align
  ADDQ.l #7,destpointer
  ANDI.w #$FFF8,destpointer+2
RTS


.do_even:                                                  ;word align
  ADDQ.l #1,destpointer                                    ;even
  BCLR #$0,destpointer+3
RTS


datasize: Ds.w 1

pdt:
  ;-- insert type of data item into code
  ;-- if runtime error checking is on.....
  ;-- 
  ;-- codes for data..... Dn
  ;-- 
  TST.b debugmode : BEQ.w 'skip
    MOVE.w #$4420,D0                                         ;'D '
    MOVE.b datasize+1(PC),D0
    BRA.w pokedata2
 'skip
RTS

.do_data:
  MOVE.w #$FC17,D1 : JSR uselib                          ;#64535  "datalib"
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  JSR sizespec2                                          ;get size of it into d1
  MOVE.w D1,datasize
  ;--
  ;-- (eg. Data.w)
  ;--
  CMP.w #$7,D1 : BEQ.w 'string

  MOVE.w D1,-(A7)

 'more
    BSR.w pdt
    
    MOVE.w (A7),D2                                      ; datatype

    BSR.w fetchdata

    CMP.w (A7),D2 : BEQ.w 'dataok                           ;datamode
      MOVE.w D2,D1
      MOVE.w (A7),D2
      CMP.w #$2,D2 : BNE.w 'notw
        CMP.w #$3,D1 : BNE.w baddaterr
          CMP.l #$10000,D3 : BCC.w baddaterr                ; was  #65536
            BRA.w 'dataok
    'notw
      CMP.w #$1,D2 : BNE.w 'notb
        CMP.w #$2,D1 : BNE.w baddaterr
          CMP.l #$100,D3 : BCC.w baddaterr
            BRA.w 'dataok
    'notb
      BRA.w baddaterr
  'dataok

    CMP.w #$3,D2 : BCC.w 'notword
      BSR.w pokedata2
      BRA.w 'next
  'notword

    ; new >
    TST.b iee : BEQ 'old
      CMP.b #5,d2 : BNE 'old
        Dc.l $f2006400                                           ;  fpu data write fmove.s fp0,d0
        ;BSR writelong
  'old
    ; < new
    BSR.w pokedata2l                                          ;write data >3

  'next
    JSR reget
  CMP.w #",",D0 : BEQ.w 'more
  ADDQ.w #2,A7
RTS

'string
  BSR.w pdt
  MOVE.l data2,-(A7)
  BSR.w pokedata2l
  MOVEQ.l #$00,D1

  JSR get1bytemain : BEQ.w 'done
  CMP.w #$22,D0 : BEQ.w 'quoted     ;'"'
   
  CMP.w #",",D0 : BEQ.w 'done
   
 'loop2
    BSR.w pokedata2b
    ADDQ.w #1,D1
    JSR getchar

    TST.w D0 : BEQ.w 'done
    CMP.w #",",D0 : BEQ.w 'done
  BRA.w 'loop2

 'quoted
  ;BSR.w get1bytemain                                      ;data writestring
  ; new >
  MOVEQ #0,d0
  MOVE.b (a5)+,d0
  ; < new
  BEQ.w notqerr2
  CMP.w #$22,D0 : BEQ.w 'done2       ;'"'
    BSR.w pokedata2b
    ADDQ.w #1,D1
    BRA.w 'quoted
 'done2

  ; new >
  CLR.w instringon
  ; < new
  JSR get1bytemain

 'done
  MOVEA.l (A7)+,A0
  MOVE.w dontwrite_nomemleft,D2
  BNE.w 'nopoke
    MOVE.l D1,(A0)
 'nopoke
  ADDQ.l #1,data2
  BCLR #$0,data2+3
  CMP.w #",",D0 : BEQ.w 'string
RTS


; new >
notqerr2           JMP notqerr
JUMP_vardeclareerr JMP vardeclareerr
; < new


.do_shared:
  ;
  ;set up SHARED variables.....
  ;
  MOVE.w proceduremode,D1                               ;doshared
  ;BEQ.w sharederr
  ; new >
  BNE.w 'l1
  MOVE.w D1,-(A7)
  CLR.w proceduremode

 'again2
  LEA varbase,a2
  BSR.w getparameter
  MOVE.w d2,-(a7)
  JSR findvariable : BEQ 'checkdim

  LEA sharebase,a2
  MOVEQ #$f+4,d7
  BSR.w findlab : BEQ.b dupsherr                       ;find var
  

  BSR add_Label

  CMP.b #".",d0 : BNE JUMP_vardeclareerr

  MOVE.l a2,a3
  JSR claptonb       ; jump to a copy of fvaradd 'clapton
;      BSR.w getparameter2
;   LEA newtypebase,A2
;   BSR.w findtype
;   BNE.w notypeerr
;   MOVE.l a2,$A(A3)
;   MOVE.w flagmask,$6(A3)
;   MOVE.w globalvarpointer,$4(A3)
;   MOVEQ.l #4,d1
;   CMPI.l #$100,4(A2)
;    BCC.w 'l1d
;   MOVE.w 8(a2),d1

;  'l1d
;     ADD.w d1,globalvarpointer
;     CMP.b #".",d0
;     BNE vardeclareerr
;     JSR get1bytemain
;     CMP.b #"l",d0
;     BNE 'lo
;   BRA 'ok

;  'lo
;    CMP.l #"f",d0
;     BNE onlyfloatint

;  'ok
;     MOVE.w globalvarpointer,$4(A3)
;     ADD.w #4,globalvarpointer

 'domore
  MOVE.w (a7)+,d2
  CMP.b #",",d0
  BNE 'ret
    JSR get1bytemain
    BRA 'again2
 'ret
  MOVE.w (A7)+,proceduremode
  RTS

 'checkdim
  CMP.w #2,6(a2) : BEQ 'do
  CMP.w #$102,6(a2) : BEQ 'do
    JMP errormsg_declaredtwice                             ;was BRA 'errormsg_declaredtwice_
 'do
  LEA varbase,a0

 'm1
    MOVE.l (A0),D0 :  BEQ.b 'z1 ; ;find label
    
    CMP.l d0,a2 : BEQ 'z1
      MOVE.l d0,a0
  BRA 'm1
 'z1
  MOVE.l (a2),d1
  MOVE.l d1,(a0)
  CLR.l (a2)
  LEA sharebase,a0
  MOVE.l (a0),(a2)
  MOVE.l a2,(a0)
  JSR get1bytemain
  JSR get1bytemain
  BRA 'domore

 'l1
  MOVE.b #1,nowdeclare
  ; < new
  MOVE.w D1,-(A7)
  CLR.w proceduremode

 'loop2
  BSR.w getparameter
  MOVE.w D2,-(A7)
  ;
  LEA firstglob,A2
  BSR.w findvariable2
  BNE.b 'notfound

 'try2
    MOVE.b flagmask+1,D1
    MOVE.b $7(A2),D3
    EOR.b D3,D1
    BEQ.w dupsherr

    BSR.w findlab
  BEQ.b 'try2

 'notfound
  BSR.w add_Label
  MOVE.w (A7)+,D2
  MOVE.l A2,-(A7)   ;new glob
  BSR.w fetchvars
  MOVEA.l (A7)+,A2
  MOVEQ.l #$04,D1
  ADDQ.w #4,A2
  ADDQ.w #4,A3

 'loop
    MOVE.w (A3)+,(A2)+
  DBF D1,'loop

  BTST #$1,flagmask+1 : BEQ.w 'done
    JSR get1bytemain
    CMP.w #")",D0     : BNE.w JUMP_syntaxerr
    JSR get1bytemain
 'done

  CMP.w #",",D0       : BNE.w 'done2
    JSR get1bytemain
    BRA.w 'loop2
 'done2
  MOVE.w (A7)+,proceduremode
RTS


.do_xinclude:                                              
  ;--
  ;-- do EXCLUSIVE (once only!) include
  ;--

  BSR.w makeiname
  JSR check_incdir                                ; returns filelength  in d2

  MOVE.l d2,-(a7)

  LEA namebuffer,a1
  LEA includetemp,a0                              ; filename in includetemp packen
 'l4
    MOVE.b (a1)+,(a0)+
  BNE 'l4

  LEA namebuffer,a1                               ; move to end of filename
  MOVE.l a1,a0
 'l1
    TST.b (a0)+
  BNE 'l1

 'l2                                              ; extract path or devicename from beginning
    MOVE.b -(a0),d0
    CMP.b #":",d0 : BEQ 'out
    CMP.b #"/",d0 : BEQ 'out
    CMP.l a1,a0   : BEQ 'out2
  BRA 'l2
 'out
  ADDQ.l #1,a0                                     
 'out2
  
  MOVEQ.l #-$01,D2
 'l3
     ADDQ.w #1,D2
     MOVE.b (a0)+,(a1)+
  BNE 'l3
  CLR.b (a1)+

  LEA namebuffer,a1
  BSR.w findxinclude : BEQ.w 'outb                            ; if found, skip it !!
    MOVE.w D2,-(A7)
    BSR.w add_Label
    MOVE.w (A7)+,D2

    LEA includetemp,a0                                     ; namen in includetemp schreiben
    LEA namebuffer,a1
   'l4b
      MOVE.b (a0)+,(a1)+
    BNE 'l4b

    MOVE.l (a7)+,d2
    LEA namebuffer,a1

    BRA.w processInclude                            ; INCLUDE it
 'outb

  LEA includetemp,a0
  LEA namebuffer,a1
 'l4b2
    MOVE.b (a0)+,(a1)+
  BNE 'l4b2

  MOVE.l (a7)+,d2
  LEA namebuffer,a1
RTS


.do_IncBin:
  BSR.w makeiname                                              ; test and get the parameter (includestring)
  JSR check_IncBinDir                                          ; to fix the path problem in CLIMode  tomsmart1

  MOVE.l D0,D7 : BEQ.w error_cant_open_include                 ; store Lockpointer, no pointer => errormessage

  MOVEA.l _dosbase,A6

  MOVE.l ptr_macrobuffer_begin,D2                              ; used to store the fileinfoblock in...
  MOVE.l D7,D1 : JSR _Examine(A6)                              ; d1:lock, d2: fileinfoblock
  MOVE.l D7,D1 : JSR _UnLock(A6)                               ; unlock the file

  MOVEA.l ptr_macrobuffer_begin,A0
  MOVE.l $4(A0),D0 : BPL.w error_cant_open_include             ; fib_dirEntrytype > 0 means it is a directory !

  MOVE.l $7C(A0),D3                                            ; store the fib_Size of the file to include

  MOVE.l #namebuffer,D1                                ; begin Open and Load the file
  MOVE.l #MODE_OLDFILE,D2
  JSR _Open(A6)
  MOVE.l D0,D7 : BEQ.w error_cant_open_include

  MOVE.l destpointer,D0
  ADD.l D3,D0
  CMP.l destbufferend,D0 : BHI.w 'over
    MOVE.l destpointer,D2
    MOVE.l D7,D1
    JSR _Read(A6)
    CMP.l #$FFFFFFFF,D0              ; was -1
    BEQ.w error_reading_file

    ADD.l D0,destpointer
    BRA.w 'close
 'over
    MOVE.w #$FFFF,dontwrite_nomemleft          ; was -1
    MOVE.l D0,destpointer
 'close
  MOVE.l D7,D1
JMP _Close(A6)


JUMP_illdirerr JMP illdirerr

.do_INCLUDE:
  ;--
  ;-- do a standard include
  ;--
  TST.w direct_mode : BNE.w JUMP_illdirerr

  BSR.w makeiname
  JSR check_incdir                              ; returns filelength  in d2

processInclude:
  BSR.w findinclude : BEQ.w alincerr            ; if found, raise already included error

  LEA includebase,A2
  BSR.w addhere2
  ;
  CLR.w 12(A2)  ; not used
  CLR.l 4(A2)   ; ptr_sourcebuffer
  ; new >
  
  MOVE.l #namebuffer,D1
  MOVE.l D1,A0
  LEA includetemp2,a1
 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1
  JSR store_includeName

  MOVE.l #0,include_process

  CMP.l #$62623200,-4(a0) : BEQ 'ok                        ;.bb2
  CMP.l #$41423300,-4(a0) : BEQ 'ok_tokenize               ;.AB3
  CMP.l #$61623300,-4(a0) : BEQ 'ok_tokenize               ;.ab3
  CMP.l #$61623200,-4(a0) : BEQ 'ok_tokenize               ;.ab2
  CMP.l #$2e626200,-4(a0) : BEQ 'ok                        ;.bb files
    JMP errortoken                                         ;can only include
 'ok_tokenize
    MOVE.l #-1,include_process                             ; must tokenize the include
 'ok

  MOVEA.l _dosbase,A6

  MOVE.l #namebuffer,D1  
  MOVE.l #MODE_OLDFILE,D2
  JSR _Open(A6)
  MOVE.l D0,8(A2) : BEQ.w error_cant_open_include         ; 8(A2) filehandle

  CLR.l includeline

  MOVE.l d3,-(a7)
  
  MOVE.l 8(a2),d1                                          ; 8(A2) filehandle
  MOVEQ #0,d2                                              ; position = 0
  MOVEQ #1,d3                                              ; #OFFSET_END
  JSR _Seek(a6)

  MOVE.l 8(a2),d1
  MOVEQ #0,d2                                              ; position = 0
  MOVEQ #-1,d3                                             ; #OFFSET_BEGINNING
  JSR _Seek(a6)                                            ; Seek(D1:file, D2:position, D3:mode)
  
  MOVE.l (a7)+,d3

  ADDQ.l #4,d0                                             ; filesize from Seek_
  MOVE.l ##MEMF_CLEAR,D1
  MOVEA.l _execbase,A6 : JSR _AllocVec(a6)
  MOVE.l D0,4(A2)
  MOVE.l D0,14(A2)
  MOVEA.l D0,A5

  ADDQ.w #1,ininclude                                      ;enter include

  ; new >
 'l2a
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA _include,a0
  LEA namebuffer,a1
 'l1b
    MOVE.b (a0)+,(a1)+
  BNE 'l1b

  MOVEQ #9,d2
  JSR findlabel2 : BNE 'd
    MOVE.l #1,8(a2)
    BRA 'd2
 'd
    JSR add_LabelHash
    MOVE.l #$1,4(A2)
    MOVE.l #1,8(a2)
 'd2
  MOVEM.l (a7)+,a0-a6/d0-d7

  LEA inctab,a0
  MOVEQ #0,d1 : MOVE.w ininclude,d1
  CLR.l 0(a0,d1 * 4)

  MOVEA.l passstack,A7
JMP passnxt


JUMP_dupmacerr  JMP dupmacerr
JUMP_macenderr  JMP macenderr
JUMP_macnesterr JMP macnesterr


coolnest:   Ds.w 1
macline:    Ds.l 1


.do_Macro:
  ;shit!
  ;
  MOVE.l linenumat,macline
  ;
  BSR.w makename2 : BEQ.w JUMP_syntaxerr
  ; new >
  CLR.b thenmode
  ;  < new
   ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  BSR.w findmac : BEQ.w JUMP_dupmacerr

  BSR.w add_Label
  CLR.w $A(A2)
  MOVEA.l ptr_macrobuffer_begin,A0
  MOVEQ.l #$00,D2     ;flag for nothing got yet!
  CLR.w coolnest

  ; new >
 'l1
   MOVE.b (a5),d0 : BEQ 'l3
    
    CMP.b #" ",d0 : BNE 'l2                                              ;space macro
      ADDQ.l #1,a5
    BRA 'l1
   'l2
    CMP.b #";",d0 : BNE 'l3
     'l4
        MOVE.b (a5),d0 : BEQ 'l5
        
        BSR.w macputb                                      ;add comment
        ADDQ.l #1,a5
      BRA 'l4
     'l5
      MOVE.b #":",d0 : BSR.w macputb
      MOVE.b #"@",d0 : BSR.w macputb
 'l3
  MOVE.b #0,temp
  MOVE.b #0,thenmode

 'gather
  JSR getcharb   ;get next character, but not conditional stuff
  TST.w D0 : BNE.w 'skip
    MOVEM.l D2/A0/A2,-(A7)
    ; new >
    CMP.w #"@@",-3(a5) : BNE 'l2a
      JSR nextline : BEQ.w JUMP_macenderr
      MOVEM.l (A7)+,D2/A0/A2
      BRA.w 'gather
   'l2a
    ; < new
    JSR nextline : BEQ.w JUMP_macenderr
    MOVEM.l (A7)+,D2/A0/A2
    TST.w D2 : BEQ.w 'gather
    ; new <

   'l2b
      MOVE.b (a5),d0
      CMP.b #" ",d0 :BNE 'l1a
        ADDQ.w #1,a5
    BRA 'l2b
   'l1a

    TST.b thenmode : BEQ 'l3a
      MOVEQ #":",d0 : BSR.w macputb
      MOVE.w ##TokenID_End,D0 : BSR macputw                     ;write end if
      MOVE.w ##TokenID_If,D0 :  BSR.w macputw                   ; was $800b
      CLR.b thenmode
   'l3a
    ; < new
    MOVEQ.l #$3A,D0  ;":"
    ; new >
    MOVE.b #1,temp
    ; < new
    BRA.w 'notend2
 'skip

  BPL.w 'notend2
  CMP.w ##TokenID_Macro,D0 : BNE.w 'notamac                    ; was #$800d      / -$7FF3
    ADDQ.w #1,coolnest
    BRA.w 'notend
 'notamac
  ; new >

  CMP.w ##TokenID_Object,d0 : BNE 'l1x                         ;object ?
    TST.b objectcount : BNE JUMP_macnesterr
 'l1x

  CMP.w ##TokenID_Then,d0 : BNE 'nothen                        ; $8021
    MOVE.b #1,thenmode
 'nothen

  TST.b thenmode : BEQ 'l1c
    CMP.w ##TokenID_End,d0 : BNE 'l1c                          ; $8002 end
      MOVEM.l d0/a5,-(a7)
      JSR get1bytemain
      MOVE.w d0,d1
      MOVEM.l (a7)+,a5/d0
      CMP.w ##TokenID_If,d1 : BNE 'l1c                         ; $800b
        CLR.b thenmode
   'l1c
  ; < new
  CMP.w ##TokenID_End,D0 : BNE.w 'notend                       ; was #$8002 / -$7FFE
    ; new >
    MOVE.l a5,-(a7)
    JSR get1bytemain
    MOVE.l (a7)+,a5
    TST.w d0      : BEQ 'doend
    CMP.w #":",d0 : BEQ 'doend
    CMP.w #";",d0 : BEQ 'doend
    MOVE.l a5,-(a7)
    JSR get1bytemain
    MOVE.l -1(a5),d0
    MOVE.l (a7)+,a5
    CMP.l #"noa7",d0 : BEQ 'doend
      BRA 'morechar
   'doend
      MOVE.w ##TokenID_End,D0
      BSR.w macputw
      BRA 'gather
   'morechar
    ; < new
    JSR get1bytemain
    CMP.w ##TokenID_Macro,D0  : BEQ.w 'lo1                   ;was #$800d, -$7FF3 ;end macro
    CMP.w ##TokenID_Object,d0 : BNE 'notem                   ;end object
    SUBQ.b #1,objectcount
    TST.b developobject : BEQ 'lo1
      BSR skiprest
      RTS
   'lo1
      ; < new
      SUBQ.w #1,coolnest
      BMI.w 'macdone
   'notem
    MOVE.w D0,-(A7)
    MOVE.w ##TokenID_End,D0                                  ; $8002
    BSR.w macputw
    MOVE.w (A7)+,D0
    BRA.w 'notend
 'notend

  BSR.w macputw
  BRA.w 'gather

 'notend2
  ; new >
  CMP.w #"@@",-1(a5) : BNE 'no                              ;merge lines
    MOVEM.l D2/A0/A2,-(A7)
    JSR nextline : BEQ.w JUMP_macenderr
    MOVEM.l (A7)+,D2/A0/A2
    TST.w D2 : BEQ.w 'gather
    BRA 'gather
 'no
  ; < new
  BSR.w macputb
  BRA.w 'gather

 'macdone
  ADDQ.w #4,A7
  MOVE.l A0,D0
  SUB.l ptr_macrobuffer_begin,D0
  ;
  ;clean up leading and trailing ':'s
  ;
 'mclean
  BEQ.w 'cdone
  CMPI.b #":",-(A0) : BNE.w 'cdone
  CMP.w #$1,D0      : BEQ.w 'cdo
    TST.b -$1(A0)   : BMI.w 'cdone  
 'cdo
    SUBQ.w #1,D0
    BRA.w 'mclean
 'cdone

  MOVE.w D0,8(A2) : BEQ.w 'skip2
    MOVEA.l _execbase,A6
    MOVE.l mempool,a0 : JSR _AllocPooled(a6)
    MOVEA.l D0,A0

    MOVE.l A0,4(A2)
    MOVE.w 8(A2),D1 : BEQ.w 'skip2
      SUBQ.w #1,D1
      MOVEA.l ptr_macrobuffer_begin,A1
     'lll
        MOVE.b (A1)+,(A0)+
      DBF D1,'lll
 'skip2
JMP get1bytemain


macputw:
  MOVE.w D0,D1
  LSR.w #8,D1
  MOVE.b D1,(A0)+

macputb:
  MOVEQ.l #-$01,D2
  MOVE.b D0,(A0)+
  CMPA.l ptr_macrobuffer_end,A0 : BCC.w macbigerr2
RTS

 ; new >
macbigerr2 JMP macbigerr


skiprest:
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
  CLR.b skiptoggle

 'loop
    MOVE.b (a5),d0 : BEQ 'l3
    
    CMP.b #";",d0 : BNE 'l2
      MOVE.b #1,skiptoggle
   'l2
    TST.b skiptoggle : BNE 'l4
      CMP.b #":",d0 : BEQ 'l3
   'l4
    ADDQ #1,a5
  BRA 'loop
 'l3

  MOVE.w d0,lastchar
  MOVE.l (a7)+,d0
RTS
 ; < new


collif:
  ;collect a comparison thingy
  ;
  BSR.w ifchar : BNE.w JUMP_syntaxerr

  MOVE.w D0,D1
  JSR get1bytemain
  BSR.w ifchar : BNE.w 'skip
    ADDQ.w #1,D0
    MOVE.w D0,D2
    ADD.w D0,D0
    ADD.w D2,D0
    ADD.w D0,D1
    MOVE.w D1,D0
    ANDI.w #$3,D0
    CMP.w #$3,D0 : BEQ.w JUMP_syntaxerr

    JSR get1bytemain
 'skip
RTS


thetst1:  TST.b D0
thetst2:  TST.w D0
thetst3:  TST.l D0
thetst4:  TST.l (A7)+                                      ;Any Length?
thetst5:  JSR _SPTst(A6)   ; mathffp.library: SPTst()

posbr:    BEQ.w posbr
negbr:    BNE.w negbr


;dounless:                                                 ;??looks like not used??
  MOVEQ.l #-$01,D2
BRA.w doifm


.do_while:
  CLR.l fp0addr
  MOVEQ.l #$01,D1                                          ;while flag
  MOVEQ.l #$00,D2                                          ;negate flag
BRA.w doif2


.free_Repeats:
  LEA firstrep,A2
  MOVEQ.l #$08,D2
BRA.w freeslist


.free_Selects:
  LEA firstsel(PC),A2
  MOVEQ.l #$0E,D2

 freeslist:
    ;free a simple list. a2=lea of list, d2=size
    ;
  MOVEQ.l #$00,D3
    ;
;freelist:                                                 ;??looks like not used??
    ;a2=lea of list, d2=size of item
    ;d3=offset to sub list, d4=size of sublist item
    ;
    ;if d3=0 then single list free only.
    ;
  MOVEA.l _execbase,A6

  MOVE.l (A2),D0
  CLR.l (A2)
  MOVEA.l D0,A2
 'loop
    CMPA.w #$0,A2 : BEQ.w 'done

    TST.w D3 : BEQ.w 'skip
      MOVEM.l D2-D3/A2,-(A7)
      ADDA.w D3,A2
      MOVE.l D4,D2
      BSR.w freeslist
      MOVEM.l (A7)+,D2-D3/A2
   'skip
    MOVEA.l A2,A1
    MOVE.l D2,D0
    MOVEA.l (A2),A2
    MOVE.l mempool,a0 : JSR _FreePooled(A6)
  BRA.w 'loop
 'done
RTS

JUMP_eselerr: JMP eselerr


firstsel:  Ds.l 1

;------                                                  ;disassembled code begin
selpushb:   Dc.w $0240,$00FF                           ;ANDI.W  #$00FF,D0
;------                                                  ;disassembled code end

selpushw:   MOVE.w D0,-(A7)
selpushbf:   ;
selpushl:   MOVE.l D0,-(A7)
selpushlf:   ;
selpushs:   LEA $4(A7),A2                                  ;(a7)=len of string!
selpushsf:   ;

selcomb:    ANDI.w #$FF,D0
selcomw:    CMP.w (A7),D0
selcombf:    ;
selcoml:    CMP.l (A7),D0
selcomlf:    ;
selbne:     BNE.w selbne

endsel:     ADDQ.w #8,A7


doendsel:                                                  ;doendselect
  ;END SELECT
  ;
  MOVE.l firstsel(PC),D0 : BEQ.w JUMP_eselerr

  MOVEA.l D0,A2
  BSR.w fillbne

  ;--
  ;-- fill in all bras at end of cases!
  MOVEA.l _execbase,A6

 'loop
    MOVE.l 4(A2),D0 : BEQ.w 'done

    MOVEA.l D0,A3
    MOVEA.l $4(A3),A0
    MOVE.l destpointer,D1
    SUB.l A0,D1
    CNIF #longbranch
      TST.b optimize_integer : BEQ 'loop_l1
        MOVE.w dontwrite_nomemleft,D0 : BNE.w 'skip
          ADDQ.l #2,d1
          MOVE.l d1,-2(a0)
          BRA 'skip
     'loop_l1
    CEND

    TST.w dontwrite_nomemleft : BNE.w 'skip
      CMP.l #MaxWordSgnd,D1 : BHI.w JUMP_cbraerr
      MOVE.w D1,(A0)
   'skip  
                                                      ;free it up!
    MOVE.l (A3),4(A2)                                       ;next of me is new first
    MOVEA.l A3,A1
    MOVEQ.l #$08,D0
    MOVE.l mempool,a0 : JSR _FreePooled(A6)
  BRA.w 'loop
 'done

  JSR popselect                                            ;fix stack on select

  MOVEA.l _execbase,A6
  MOVEA.l firstsel(PC),A1
  MOVE.l (A1),firstsel
  MOVEQ.l #$0E,D0
  MOVE.l mempool,a0 : JSR _FreePooled(A6)
JMP get1bytemain


endselstr:
  MOVEA.l (A7)+,A1
  SUBQ.w #8,A1
  MOVEQ.l #$09,D0
  ADD.l (A1),D0

 endselstrf:
  ADDQ.w #2,A7                                             ;for runtime errs!
endselstrf2:   ;


.do_default:
  MOVE.l firstsel(PC),D0 : BEQ.w JUMP_defaerr
  
  MOVEA.l D0,A2
  BSR.w fillbra
  BSR.w fillbne
  CLR.l 8(A2)
  MOVE.w 12(A2),D2
BRA.w casechk

JUMP_defaerr: JMP defaerr


fillbne:
  ;a2=sel
  MOVE.l 8(A2),D0 : BEQ.w 'skip   ;none to do!
  MOVEA.l D0,A0
  MOVE.l destpointer,D1
  SUB.l A0,D1
  ; new >
  CNIF #longbranch
    TST.b optimize_integer : BEQ 'l1
      TST.w dontwrite_nomemleft : BNE.w 'skip

      ADDQ.l #2,d1
      MOVE.l D1,-2(A0)
      BRA 'skip
   'l1
  CEND

  TST.w dontwrite_nomemleft : BNE.w 'skip
  ; < new
  CMP.l #MaxWordSgnd,D1 : BHI.w JUMP_cbraerr

  MOVE.w D1,(A0)

 'skip
RTS

JUMP_cbraerr JMP cbraerr


fillbra:
  ;--
  ;-- make a bra if necessary
  MOVE.l 8(A2),D0 : BEQ.w 'skip

  ;-- 
  ;-- OK, we're after a case thingy. add a BRA
  ;--
  MOVEA.l D0,A3
  MOVE.w ##opcode_BRA,D1

  CNIF #longbranch
  TST.b optimize_integer : BEQ 'l1
    OR.l #$ff,d1
    BSR writeword
 'l1
  CEND
  BSR.w writeword

  MOVEQ.l #$08,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0 : JSR _AllocPooled(a6)
  MOVEA.l D0,A0

  MOVE.l 4(A2),(A0)
  MOVE.l A0,4(A2)
  MOVE.l destpointer,$4(A0)
  BRA.w writeword

 'skip
RTS


casechk:
  TST.b debugmode : BEQ.w 'norerr
    MOVE.w #$C313,D1        ; (runerrlib, casechkw)
    CMP.w #$3,D2 : BCS.w 'dochk
      ADDQ.w #1,D1          ; (runerrlib, casechkl
   'dochk
    BRA.w Atokejsr
 'norerr
RTS


JUMP_caseerr JMP caseerr

.do_case:
  ;-- eg : CASE a+10
  ;--
  ;-- first, fill in last bra (if there is one!)
  ;--
  MOVE.l firstsel(PC),D0 : BEQ.w JUMP_caseerr

  MOVEA.l D0,A2
  BSR.w fillbra
  BSR.w fillbne
  
  MOVE.w 12(A2),D2    ;type to get!
  MOVE.w D2,-(A7)
  BSR.w casechk
  MOVE.w (A7),D2

  BSR.w bakeval
  MOVE.w (A7)+,D2    ;types to compare
  LEA selcomb(PC),A0
  LEA selcombf(PC),A1
  CMP.w #$1,D2 : BEQ.w 'doit
    LEA selcomw(PC),A0
    CMP.w #$2,D2 : BEQ.w 'doit
      LEA selcoml(PC),A0
      LEA selcomlf(PC),A1
      CMP.w #$7,D2 : BCS.w 'doit ; -- Strings....
        MOVE.w #$CE01,D1 : BSR.w Atokejsr    ; was #casestrcomp
        BRA.w 'doneit
 'doit
    BSR.w pokecode
 'doneit

  MOVE.w selbne(PC),D1
  ; new >
  CNIF #longbranch
    TST.b optimize_integer : BEQ 'l1
      ORI.l #$ff,d1 : BSR writeword
  CEND
 'l1
  ; < new
  BSR.w writeword
  MOVEA.l firstsel(PC),A0
  MOVE.l destpointer,$8(A0)
BRA.w writeword


;------                                                  ;disassembled code begin
pcchk:      Dc.w $3F3C,$7345                             ;MOVE.W  #$7345,-(A7)   ;#"sE",-(a7) org source
clrst:      Dc.w $42A7                                   ;CLR.L   -(A7)
;------                                                  ;disassembled code end

sellineat:  Ds.l 1


.do_select:
  ;-- OK, as in : SELECT opt
  ;-- 
 
  TST.b debugmode : BEQ.w 'norerr
    MOVE.l pcchk(PC),D1                                      ;move #"sE",-(a7)
    BSR.w writelong
 'norerr

  MOVE.l linenumat,sellineat
   ;bsr.w pushstart                                        ;we may have to CLR -(a7)!
  ; new >
  MOVE.l destpointer,pushpc
  MOVE.l hunkoffsetbase,pushoff
  ; < new
  MOVEQ.l #$00,D2
  BSR.w bakevalu                                          ;Evaluate
  BSR.w pushdo

  CMP.w #$7,D2 : BNE.w 'nos                               ; check for string
    MOVE.w clrst(PC),D1
    BSR.w writeword
 'nos
  BSR.w pushput
  LEA selpushb(PC),A0
  LEA selpushbf(PC),A1
  CMP.w #$1,D2 : BEQ.w 'doit
  
  LEA selpushw(PC),A0
  CMP.w #$2,D2 : BEQ.w 'doit
  
  LEA selpushl(PC),A0
  LEA selpushlf(PC),A1
  CMP.w #$7,D2 : BCS.w 'doit
 
  MOVE.w moved0a3,D1 : BSR.w writeword  ;d0 to a3!
  LEA selpushs(PC),A0
  LEA selpushsf(PC),A1
  BSR.w pokecode
  MOVE.w #$C701,D1 : BSR.w Atokejsr     ; was #allocstring
  BRA.w 'doneit

 'doit
    BSR.w pokecode
 'doneit

  MOVEQ.l #$0E,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0 : JSR _AllocPooled(a6)
  MOVEA.l D0,A0

  MOVE.l firstsel(PC),(A0)
  MOVE.l A0,firstsel
  CLR.l $4(A0)
  CLR.l $8(A0)        ;default mode!
  MOVE.w D2,$C(A0)
RTS


.do_Forever:
  MOVE.l firstrep,D0 : BEQ.w JUMP_unterr1

  MOVE.w ##opcode_BRA,D1 : BSR.w writeword

  MOVEA.l D0,A0
  MOVE.l $4(A0),D1      ;dest pc
  SUB.l destpointer,D1
  TST.w D1 : BPL.w JUMP_unterr2

  TST.b optimize_jumps : BEQ 'braWord
  CMP.l #127,d1 : BGT 'braWord
  CMP.l #-128,d1 : BLT 'braWord
 
 'braByte
  SUBQ.l #2,destpointer
  MOVE.l d1,d2
  MOVE.w ##opcode_BRA,D1
  OR.b d2,d1
 
 'braWord
  BSR.w writeword

 'exit_forever 
  MOVEA.l _execbase,A6
BRA.w unlink_Repeat

JUMP_unterr2 JMP unterr2
JUMP_unterr1 JMP unterr1


.do_Until:
  MOVE.l firstrep,D0 : BEQ.w JUMP_unterr1    ;no repeat!
  
  BSR.w do_if            ;do the until
  ;
  JSR reget : BNE.w JUMP_syntaxerr
  ;
  MOVE.w dontwrite_nomemleft,D1 : BNE.w 'skip
  MOVEA.l firstrep,A0
  MOVEA.l destpointer,A1
  ; new >
  CNIF #longbranch
    TST.b optimize_integer : BEQ 'l1
      SUBQ.w #4,a1
      MOVE.l $4(A0),D2
      SUB.l A1,D2
      MOVE.l d2,(a1)
      BRA 'skip
  CEND

 'l1
  ; < new
  SUBQ.w #2,A1
  MOVE.l $4(A0),D2    ;dest pc.
  SUB.l A1,D2
  TST.w D2 : BPL.w JUMP_unterr2

  MOVE.w D2,(A1)      ;put in pra dest.

 'skip
  MOVEA.l firstiff,A1
  MOVE.l (A1),firstiff
  MOVEQ.l #$0E,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0 : JSR _FreePooled(A6)


.unlink_Repeat:
  MOVEA.l firstrep,A1
  MOVE.l (A1),firstrep
  MOVEQ.l #$08,D0
  MOVE.l mempool,a0
JMP _FreePooled(A6)


iflineat:   Ds.l 1


.do_if:
  MOVEQ.l #$00,D2   ;negate flag
  ; new >
  TST.b optimize_integer : BEQ 'l1
    MOVE.b #1,nostringopt
    MOVE.b #1,iniffcommand
 'l1
  ; < new
doifm:                                                ;??looks like double label??
  MOVEQ.l #$00,D1  ;if flag

doif2:
  ;the main IF bit
  ;
  ;
  MOVE.w D1,-(A7)
  MOVE.l destpointer,-(A7)
  MOVE.w D2,-(A7)
  MOVE.l linenumat,iflineat
  ;
  MOVEQ.l #$00,D2
  ; new >
  MOVE.b optistring,optistring2
  MOVE.b #1,optistring
  ; < new
  BSR.w bakevalu       ;Get True/False Expression!
  ; new >
  MOVE.b optistring2,optistring
  ; < new
  CMP.w #$5,D2 : BEQ.w 'float

  MOVE.w thetst1(PC),D1
  CMP.w #$1,D2 : BEQ.w 'writebranchcode

  MOVE.w thetst2(PC),D1
  CMP.w #$2,D2 : BEQ.w 'writebranchcode

  MOVE.w thetst4(PC),D1
  CMP.w #$7,D2 : BEQ.w 'writebranchcode

  MOVE.w thetst3(PC),D1
  BRA.w 'writebranchcode

 'float
  ; new >
  TST.b optimize_fpu : BEQ 'dofpu
    MOVE.l #$f200003a,d1 : BSR writelong
    MOVE.w #$f2c1,d1     : BSR writeword
    BSR writelong
    ADDQ.l #2,a7
    BRA.w 'br2
 'dofpu
  ; < new
  MOVE.w #$C900,D1 : BSR.w Atokejsr             ;was #getffpbase in A6
  MOVE.l thetst5(PC),D1 : BSR.w writelong
  BRA.w 'gotst2

 'writebranchcode      ; was 'gotst
  ; new >
  CLR.b iniffcommand
  
  TST.b optimize_integer : BEQ 'b6                         ;branchcode
  
  TST.b optimize_fpu : BEQ 'nofpu
    CNIF #optibreak
      ILLEGAL
    CEND
    MOVE.l destpointer,a0
    SUB.l load_var_addr,a0
    CMP.l #4,a0 : BEQ 'nofpu

    CMP.l #$f2400014,-4(a4) : BNE 'nolt                      ;<
      SUBQ.l #2,destpointer
      MOVE.w #$f293,-4(a4)                                   ;
      BRA 'brf
   'nolt

    CMP.l #$f2400015,-4(a4) : BNE 'nole                      ;<=
      SUBQ.l #2,destpointer
      MOVE.w #$f292,-4(a4)
      BRA 'brf
   'nole

    CMP.l #$f2400013,-4(a4) : BNE 'noge                      ;=>
      SUBQ.l #2,destpointer
      MOVE.w #$f294,-4(a4)
      BRA 'brf
   'noge

    CMP.l #$f2400012,-4(a4) : BNE 'nogt                      ;>
      SUBQ.l #2,destpointer
      MOVE.w #$f295,-4(a4)
      BRA 'brf 
   'nogt

    CMP.l #$f2400001,-4(a4) : BNE 'noeq                      ;=
      SUBQ.l #2,destpointer
      MOVE.w #$f28e,-4(a4)
      BRA 'brf
   'noeq

    CMP.l #$f240000e,-4(a4) : BNE 'none                      ;<>
      SUBQ.l #2,destpointer
      MOVE.w #$f281,-4(a4)
   'brf

    ADDQ.l #2,a7
    CNIF #longbranch
    TST.b optimize_integer : BEQ 'l1
      OR.b #$40,-3(a4)
      BSR writeword
   'l1
    CEND
    BSR writeword
    BRA.s 'br2

   'none                                                     ;??Looks like double label??
 'nofpu
  
  MOVE.l destpointer,a0
  SUB.l load_var_addr,a0
  CMP.l #4,a0 : BEQ 'gotst2

  CMP.w ##opcode_JSR,-6(a4) : BEQ 'b6

  CMP.w #$5ec0,-2(a4) : BNE.s 'lb1                         ;>
    MOVE.w #$6f00,-2(a4)                                   ;ble
    BRA.s 'br
 'lb1

  CMP.w #$5dc0,-2(a4) : BNE.s 'lb2                         ;<
    MOVE.w #$6c00,-2(a4)                                   ;bge
    BRA.s 'br
 'lb2
  CMP.w #$57c0,-2(a4) : BNE.s 'lb3                         ;=
    MOVE.w #$6600,-2(a4)                                   ;bne
    BRA.s 'br
 'lb3
 
  CMP.w #$56c0,-2(a4) : BNE.s 'lb4                         ;<>
    MOVE.w #$6700,-2(a4)                                   ;beq
    BRA.s 'br
 'lb4

  CMP.w #$5cc0,-2(a4) : BNE.s 'lb5                         ;>=
    MOVE.w #$6d00,-2(a4)                                   ;blt
    BRA.s 'br
 'lb5

  CMP.w #$5fc0,-2(a4) : BNE.s 'b6                          ;<=
    MOVE.w #$6e00,-2(a4)                                   ;bgt
 'br

  TST.w (a7)+
  CNIF #longbranch
  TST.b optimize_integer : BEQ 'l1a
    OR.b #$ff,-1(a4)                                       ;long branches
    BSR writeword
  'l1a
  CEND

  BSR writeword
  BRA.s 'br2

 'b6
  ; < new
  BSR.w writeword

 'gotst2
  MOVE.l posbr(PC),D1
  TST.w (A7)+ : BEQ.w 'skip
    MOVE.l negbr(PC),D1
 'skip
  ; new >
  TST.b optimize_integer : BEQ 'l1b
    OR.l #$00ff0000,d1
    BSR writelong
    BSR writeword
    BRA 'br2
 'l1b
    BSR.w writelong
 'br2
  ; < new
  MOVEQ.l #$0E,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0 :  JSR _AllocPooled(a6)
  MOVEA.l D0,A0

  MOVE.l firstiff,(A0)
  MOVE.l A0,firstiff
  MOVE.l (A7)+,$4(A0)
  MOVE.l destpointer,$8(A0)
  MOVE.w (A7)+,$C(A0)
  JSR reget : BEQ.w ifdone

  BSET #$7,$C(A0)    ;one liner
.do_then:
  ;bsr.w bakup       ;to reget last
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  MOVE.w #$003A,lastchar      ; ':'

  ifdone:
RTS


ongotocode:
  CMP.w #$1,D0 : BLT.w gc1skip ;4 + 4
  CMP.w #$0,D0 : BGT.w gc1skip ;2
 
    ADD.w D0,D0
    ADD.w D0,D0
    MOVEA.l gc1labs-4(PC,D0.W),A0
    JMP (A0)

  gc1skip:                                                ;??
  BRA.w gc1skip
  gc1labs:
ongotocodef:


ongosubcode:
  CMP.w #$1,D0 : BLT.w gc2skip ;4+4
  CMP.w #$0,D0 : BGT.w gc2skip ;2

    ADD.w D0,D0
    ADD.w D0,D0
    MOVEA.l gc2labs-4(PC,D0.W),A0
    JSR (A0)

  gc2skip:                                                ;??
  BRA.w gc2skip
  gc2labs:
ongosubcodef:


ongcode:
  CMP.w #$1,D0 : BLT.w gc3skip   ;4+4
  CMP.w #$0,D0 : BGT.w gc3skip   ;2
   
    ADD.w D0,D0
    ADD.w D0,D0
    MOVEA.l gc3labs-4(PC,D0.W),A0

    goset:
    MOVE.w #$6753,-(A7)                                      ;#'gS' ;for runtime error checking!
    JSR (A0)

  gc3skip:                                                ;??
  BRA.w gc3skip
  gc3labs:
ongcodef:


labcnt:   Ds.w 1


.do_Ongo:                                                  ;On expression Goto/Gosub Label[Label...]
    ;
    ;Get expression as a word.
    ;
  MOVEQ.l #$02,D2
   BSR.w bakeval
  ;
  LEA ongotocode(PC),A0
  LEA ongotocodef(PC),A1
  MOVE.w #gc1skip-ongotocode,D1      ; is #$001A

  CMP.w ##TokenID_Goto,D0                   ; was #$8005
  BEQ.w 'isok

  CMP.w ##TokenID_Gosub,D0                   ; was #$8006
  BNE.w JUMP_syntaxerr

  LEA ongosubcode(PC),A0
  LEA ongosubcodef(PC),A1
  MOVE.w #gc2skip-ongosubcode,D1     ; is #$001A
  ;
  TST.b debugmode
   BEQ.b 'isok
  ;
   JSR insert_stackchk
  LEA ongcode(PC),A0
  LEA ongcodef(PC),A1
  MOVE.w #gc3skip-ongcode,D1         ; is #$001E

 'isok
  MOVE.w D1,-(A7)
  MOVE.l destpointer,-(A7)                                 ;for when we know number of labels!
   BSR.w pokecode
  CLR.w labcnt
  ;
  ;now, make a labels list!
  ;

 'loop
   JSR get1bytemain
  SUBQ.l #2,destpointer                                    ;for makealab!
   BSR.w makealab2
  ADDQ.l #2,destpointer
   JSR addoff
  MOVE.l 8(A2),D1
   BSR.w writelong
  ADDQ.w #1,labcnt
   JSR reget
  CMP.w #",",D0 ; ','
   BEQ.w 'loop
  ;
  MOVEA.l (A7)+,A0
  MOVE.w (A7)+,D2
  MOVE.w dontwrite_nomemleft,D1
   BNE.w 'done
  ;
  MOVE.w labcnt(PC),D1
  MOVE.w D1,$A(A0)       ;for cmp#
  ADD.w D1,D1
  ADD.w D1,D1
  ADDQ.w #2,D1
  MOVE.w D1,$2(A0,D2.W)  ;for bra!

 'done
RTS


.do_gosub:
  TST.b debugmode : BEQ.w 'noerr
    JSR insert_stackchk
    MOVE.l goset,D1
    BSR.w writelong
 'noerr

  MOVE.w gosubcode,D1
BRA.w dogoto2


.do_goto:
  MOVE.w gotocode,D1

dogoto2:
  MOVE.w D1,-(A7)
  BSR.w makealab2
  MOVE.w (A7)+,D1
  BSR.w writeword
  JSR addoff
  MOVE.l 8(A2),D1
BRA.w writelong


.do_AsmExit:     ; was eos
  MOVE.w proceduremode,D1 : BEQ.w JUMP_badpenderr
  ;
  MOVE.w ##opcode_JMP,D1 : BSR.w writeword
  
  JSR addoff

  MOVEA.l _execbase,A6
  MOVEQ.l #$08,D0
  MOVE.l mempool,a0 : JSR _AllocPooled(a6)
  MOVEA.l D0,A0

  MOVE.l firstpend,(A0)
  MOVE.l A0,firstpend
  MOVE.l destpointer,$4(A0)
BRA.w writelong


stateret:
  BSR.w do_AsmExit
JMP get1bytemain


do_function_return:      ; was funcret
  ; new >
  MOVE.b #1,nostringopt
  MOVEM.l a0/a1/d1,-(a7)
  ; < new
  MOVEA.l currentfunction,A0
  ; new >
    CMP.l #0,a0
    BNE 'l1
    JMP errorasmexit

 'l1
  MOVEQ.l #$00,D2
  ; < new
  MOVE.b $5(A0),D2      ;type returning!
  BSR.w eval            ;put return val in d0.
  ; new >
 CNIF #function_support_returntype
  MOVEA.l currentfunction,A0
  MOVE.l funcstruct_returntype(a0),a0
  CMP.l #0,a0
  BEQ 'isstatement
  CMP.l #$100,4(a0)
  BLT.w 'isvar
  MOVE.l a2,a1
  TST.l typetocast
  BEQ 'nocast
  MOVE.l typetocast,a1

 'nocast
  CMP.l a0,a1
  BEQ 'ok
  CLR.l typetocast
  MOVE.l lasttoken,d1
  CMP.w ##TokenID_Null,d1                   ;$b581 ok, when token for null
  BEQ 'isnull

 'error
  JMP errorconvertreturntype

 'isnull
  ;MOVE.w ##opcode_RTS,d1                  ;write rts

 'isvar
 'ok
 'isstatement
 CEND
  MOVEM.l (a7)+,a0/a1/d1
  ; < new
  ;
BRA.w do_AsmExit

error_convert_types2 JMP error_convert_types


.do_return:
   ; new <
;  TST.w proceduremode                                      ; return work in functions
;  BEQ 'no                                                  ; must forbid gosub in functions
;  TST.l currentfunction                                    ; if that work
;  BEQ 'no
;  SUBQ.l #1,a5
;  BGT do_function_return
;  CMP.w #$ffff,proceduremode
;  BEQ stateret
;
;'no
  ; < new
  TST.b debugmode
  BEQ.w normret
    MOVE.w #$C305,D1 : BRA.w Atokejsr                       ; (runerrslib, #chkret)    
  normret:
  ;a normal return
  ;
;.noerrchk
  MOVE.w ##opcode_RTS,D1
BRA.w writeword


localslist:  Ds.l 1                                        ;all locals for procs.;??Looks like obsovled data??
proclocals:  Ds.l 1                                        ;for debugga!
procnum:     Ds.w 1
procnum2:    Ds.w 1
prolineat:   Ds.l 1


.do_statement:                   ; was dostate  org  source
   ; new >
   TST.w proceduremode :  BGT JUMP_sreterr
   ; < new
   CMP.w ##TokenID_Return,D0 : BEQ.w stateret     ;was #$8007 Token "Return"   

   MOVEQ.l #-$01,D1  ;statement flag
BRA.w do_function2

JUMP_sreterr JMP sreterr


checkused
  CLR.b skipfunc
  TST.l unusedfunc : BEQ 'ex

  MOVEM.l d0-d7/a0-a6,-(a7)
  MOVE.l unusedfunc,d1
  LEA namebuffer,a5

 'ag
    MOVE.l d1,a0
    LEA 12(a0),a2
    MOVE.l a5,a1
   'ch
      CMPM.b (a1)+,(a2)+ : BNE 'neq
    TST.b (a2) : BNE 'ch

    TST.b (a1) : BNE 'neq
      MOVE.b #1,skipfunc
      BRA 'out
   'neq
  MOVE.l (a0),d1 : BNE 'ag
 'out

  MOVEM.l (a7)+,d0-d7/a0-a6

 'ex
RTS


JUMP_dupprocerr  JMP dupprocerr
JUMP_illprocperr JMP illprocperr
JUMP_toovarerr   JMP toovarerr
JUMP_more6pard   JMP more6pard


.do_function:
  CMP.w #-1,proceduremode : BEQ JUMP_sreterr

  CMP.w ##TokenID_Return,D0 : BEQ.w do_function_return ; was #$8007
   
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  JSR check_FunctionReturnType
  JSR get1bytemain

do_function2:                                             ;do_statement jump to here
  ;-- do some checking.....
  ;-- 
  ; new >
  TST.b declare : BEQ 'l3
    MOVE.b #1,nowdeclare
 'l3
  ; < new
  JSR errchx                                           ;writejumpoverfunction

  ; new >
 ;returnaddr
  CLR.b fastfunc
  MOVE.l firstiff,firstiffstore

  CMP.l #"FAST",-1(a5) : BNE 'nofast
  CMP.b #" ",3(a5) : BNE 'nofast
    ADDQ.l #3,a5
   'x2                                                        ; skip all spaces
      CMP.b #" ",(a5) : BNE 'x1
      ADDQ #1,a5
    BRA 'x2

  'x1
   MOVE.l a5,lastsourcepos
   MOVE.b #1,fastfunc
 'nofast

  CMP.l #"NOOP",-1(a5)                                     ;compile 3* so its deactivate
  BRA 'noopt

  CMP.w #"T ",3(a5)                                        ;??Looks like dead code??
  BNE 'noopt                                               ;          "
  ADDQ.l #4,a5                                             ;          "

 'x2b                                                      ;          "
    CMP.b #" ",(a5)                                        ;          "
     BNE 'x1b                                              ;          "
    ADDQ #1,a5                                             ;          "
  BRA 'x2b
                                                           ;          "
 'x1b                                                      ;          "
  MOVE.l a5,lastsourcepos                                  ;          "
  JSR makename2                                            ;          "
  BRA 'l1                                                   ;          "

 'noopt
  JSR makename2
  JSR checkused
  TST.b skipfunc : BEQ 'l1
    JSR skipme
    CLR.b fastfunc
    RTS
 'l1
  ; < new
  MOVE.l linenumat,prolineat
  ;
  ADDQ.w #1,procnum2
  MOVE.w procnum2(PC),procnum
  MOVE.w D1,proceduremode
  CLR.w locvaroff

  CMP.w #"{",D0 : BNE.w JUMP_syntaxerr                     ;'{'

  ; new >
   MOVE.b #1,infunctioncode
  ; < new
  MOVEA.l tempvm,A0
  MOVE.w $C(A0),memlibstat
  BCLR #$7,$C(A0)                                          ;Bit out of range
  MOVE.w ##opcode_JMP,D1 : BSR.w writeword                 ;make a JMP around the proc
  
  JSR addoff
  BSR.w writelong
  ;
  JSR find_procedure : BEQ.w JUMP_dupprocerr              ;find_procedure function
  
  JSR add_Label
  ; new >
  MOVE.b #31,$20(a2)                                      ;increase if more pars
  MOVE.b #0,isfunc(a2)
  MOVE.l functionreturntype,funcstruct_returntype(a2)
  ; < new
  MOVE.l destpointer,14(A2)    ;new!
  MOVE.l A2,currentfunction
  ;
  LEA nops8,A0
  LEA nopsf,A1
  BSR.w pokecode2
  ;
  TST.b debugmode : BEQ.b 'nodebug
    MOVEQ.l #$04,D1 : JSR writetrap
    MOVE.l destpointer,proclocals
    BSR.w writelong
    BSR.w writelong
 'nodebug

  LEA $16(A2),A4
  MOVE.b proceduremode+1,$5(A2)
  MOVEQ.l #$00,D6
  MOVEQ.l #$00,D5
  JSR get1bytemain

  CMP.w #"}",D0 : BEQ.w 'done

 'more
  ; new >
  CMP.b #"@",d0 : BNE 'l2
    MOVE.l a0,-(a7)
    MOVE.l currentfunction,a0
    CMP.b #31,$20(a0) : BNE 'l4                             ;increase if morepars
      MOVE.b d6,$20(a0)                                     ;increase if morepars
   'l4
    JSR get1bytemain
    MOVE.l (a7)+,a0
 'l2
  ; < new
  BSR.w getparameter
  JSR fetchvars
  CMPI.l #$7,4(A2) : BNE.w 'notst
    LEA stbuff,A0
    MOVE.w D5,D1
    LSL.w #2,D1
    MOVE.w D6,$0(A0,D1.W)
    MOVE.w $4(A3),$2(A0,D1.W)
    ADDQ.w #1,D5
    MOVEQ.l #$07,D2
    BRA.w 'pgot
 'notst
  MOVE.w #$2940,D1
  MOVEQ.l #$03,D2
  BTST #$0,flagmask+1
  BNE.w 'sgot
    CMPI.l #$100,4(A2)
    BCC.w JUMP_illprocperr
      MOVE.w $6(A2),D2
      CMP.w #$2,D2
      BHI.w 'sgot
      BEQ.w 'wgot
        EORI.w #$3000,D1
        BRA.w 'sgot
     'wgot
      ORI.w #$1000,D1
 'sgot
  OR.w D6,D1
  ; new >
  TST.b optimize_fpu : BEQ 'nofpu
    CMP.b #5,d2 : BNE 'nofpu
      CMP.w #6,d6 : BLT 'l10a
        CMP.l #newtype_double,a2 : BEQ JUMP_more6pard
          BRA 'nofpu
     'l10a
      MOVE.l #$f22c6400,d1
      MOVEM.l d0/a4,-(a7)
      MOVE.l d6,d0
      ASL.l #7,d0
      OR.w d0,d1
      CMP.l #newtype_double,a2 : BNE 'l5
        OR.l #$1000,d1
     'l5
      BSR writelong
      MOVE.w 4(a3),d1
      BSR writeword
      MOVEM.l (a7)+,a4/d0
      BRA 'pgot
 'nofpu
  ; < new
  MOVE.l A4,-(A7)
  ; new >
   CMP.w #6,d6 : BLT 'l10
   
   MOVE.w #$c500-4,d1                                      ;savetemp+regnum
   ADD.w d6,d1
   JSR Atokejsr

   TST.w dontwrite_nomemleft
   BNE 'l10
   MOVE.l data1start,d1
   MOVE.l destpointer,a4
   ADD.l d1,-6(a4)
   MOVE.l destpointer,d1
   SUBQ.l #6,d1
   SUB.l destbufferstart,d1

   MOVE.l d2,-(a7)
   MOVE.l d1,d2
   JSR addhunkoffset                                       ;move.l $0,-x(a4)
   MOVE.l (a7)+,d2
   MOVE.l destpointer,a4
   CMP.w #2,d2
   BNE 'nw1

   MOVE.w #$3979,-8(a4)                                    ;move.w $0,-x(a4)
   ADD.l #2,-6(a4)

 'nw1
   CMP.w #1,d2 : BNE 'nb
     MOVE.w #$1979,-8(a4)                                    ;move.b $0,-x(a4)
     ADD.l #3,-6(a4)
  'nb
   MOVE.w $4(a3),-2(a4)
 BRA 'ne1

 'l10
  ; < new
  BSR.w writeword                                          ;write storeparameter

 'l20
  MOVE.w $4(A3),D1
   BSR.w writeword

 'ne1
  MOVEA.l (A7)+,A4

 'pgot
  ; new >
  CLR.l functionreturntype
  ; < new
  ADDQ.w #1,D6
  CMP.w #11,D6 : BCC.w JUMP_toovarerr                       ; was #7, max function parameters
   
  ; new >
  MOVE.l currentfunction,a0
  MOVE.l a2,funcstruct_parametertype-4(a0,d6*4)             ;-4 because d6 is increment before
  ; < new
  MOVE.b D2,(A4)+
  CMP.w #",",D0 : BNE.w 'nomore
    JSR get1bytemain
  ; new >
  ;   CMP.b #"@",d0
  ;   BNE 'more
  ;   MOVE.l a0,-(a7)
  ;   MOVE.l currentfunction,a0
  ;   CMP.b #31,$20(a0)                                       ;increase if morepars
  ;   BNE 'l6
  ;     MOVE.b d6,$20(a0)
  ;  'l6
  ;   JSR get1bytemain
  ;   MOVE.l (a7)+,a0
  ; < new
      BRA.w 'more
 'nomore
  CMP.w #"}",D0 : BNE.w JUMP_syntaxerr

 'done
  MOVEA.l currentfunction,A2
  LSL.w #4,D5
  OR.w D5,D6
  MOVE.b D6,4(A2)
  LSR.w #4,D6
  BEQ.w 'nostrings
  LEA stbuff,A0
  SUBQ.w #1,D6

 'stloop
  ;
  ;do all the string things
  ;
    MOVE.w D6,D1                                           ;function stringpars
    LSL.w #2,D1                                            ;stringsize was 2
  ; new >
    CNIF #more6string
      LSL.w #1,d1
      ADDQ.w #4,d1
    CEND
  ; < new
    ADDQ.w #8,D1
    MOVE.w D1,funcst+2
    MOVE.l funcst,D1
    BSR.w writelong
    MOVE.w (A0)+,D1
  ; new >
    CMP.b #5,d1
    BLE 's1
    MOVE.w #$266c,d1                                       ;native move.l 4(a4),a3
    BSR writeword                                          ; was writeinstruction  tomsmart1
    MOVE.w D6,D1                                           ;function stringpars
    LSL.w #2,D1                                            ;stringsize was 2
    CNIF #more6string
      LSL.w #1,d1
    CEND
    ADDQ.w #8,D1
    BSR writeword
    BRA 's2

   's1
   ; < new
    OR.w movedna3,D1
     BSR.w writeword

   's2
    MOVE.w (A0)+,least+2
    MOVE.l least,D1 : BSR.w writelong

    MOVE.l A0,-(A7)
    MOVE.w #$C700,D1 : BSR.w Atokejsr
    MOVEA.l (A7)+,A0
  DBF D6,'stloop

 'nostrings
JMP get1bytemain


linkput:
  MOVE.w dontwrite_nomemleft,D1 : BNE.w 'skip
    MOVE.l destpointer,-(A7)
    ;
    MOVE.l A0,destpointer
    MOVE.l linksize,D1 : BSR.w writelong                        ; LINK A4, -$0000

    TST.b fastfunc : BNE 'skip1
      MOVE.w #$CC00,D1 : BSR.w tokejsr2                         ; was #clrloc, clear local vars
   'skip1
    MOVE.l (A7)+,destpointer
 'skip
RTS


JUMP_errormsg_nofast  JMP errormsg_nofast

procfixer:
  ;-- fix up procs!
  ;--
  MOVEA.l currentfunction,A2
  MOVEA.l 14(A2),A0                         ;pc of proc
  MOVE.w 6(A2),D1 : BEQ.w 'skiplink
    MOVE.w D1,linksize+2                    ; set link size
    MOVE.w 8(A2),D1 : BNE.w 'howdy          ; check if function memalloc need
      ;
      ;link only
      ;
      ADDQ.w #6,A0
      MOVE.l A0,14(A2)
      BRA.w linkput
   'howdy
    ;link and jsr
    ;
    MOVE.l A0,-(A7)
    BSR.w linkput
    MOVEA.l (A7)+,A0
    LEA $A(A0),A0
    MOVEA.l currentfunction,A2
    BRA.w 'cont
 'skiplink

  MOVE.w 8(A2),D1 : BNE.w 'cont
    LEA $10(A0),A0
    MOVE.l A0,14(A2)
    RTS
 'cont

  MOVE.w dontwrite_nomemleft,D1 : BNE.w 'contskip  ;writeallocmem for functions (after releasemem called)
    ;
    ; new >
    TST.b fastfunc : BNE JUMP_errormsg_nofast
    ; < new
    MOVE.l destpointer,-(A7)
    MOVE.l A0,destpointer
    MOVE.w ##opcode_JSR,D1 : BSR.w writeword
    JSR addoff
    BSR.w writelong
    ;
    MOVEA.l (A7)+,A0
    MOVEA.l destpointer,A1
    MOVE.l A0,-(A1)
    MOVE.l A0,destpointer
 'contskip

  MOVE.w 8(A2),D4 : BPL.w 'linky
    MOVE.w #$C004,D1 : BSR.w tokejsr2            ; #newlocalmem: create a new local memory node
    MOVEA.l currentfunction,A2
    MOVE.w 8(A2),D4
    ANDI.w #$7FFF,D4                             ;#32767,
 'linky
  BEQ.w 'skipstat
  ;
  ;allocate statics!
  ;
  MOVE.b 4(A2),D1
  ANDI.w #$F,D1
  MOVE.w D1,-(A7)
  CMP.w #$5,D1 : BCS.w 'npush
    MOVE.w #$2F04,D1 : BSR.w writeword
 'npush
  MOVE.l locdatast,D3
  JSR datastart
  MOVE.w #$C501,D1 : BSR.w tokejsr2              ; was #localstat
  
  ;
  MOVE.w (A7)+,D1
  CMP.w #$5,D1 : BCS.w 'skipstat
    MOVE.w #$281F,D1 : BSR.w writeword
 'skipstat ;
  MOVE.w ##opcode_RTS,D1
BRA.w writeword


.do_mousewait:
  LEA mwait,A0
  LEA mwaitf,A1
BRA.w pokecode


JUMP_laberr    JMP laberr
JUMP_typeerr   JMP typeerr
JUMP_dupofferr JMP dupofferr

.do_newtype:
  CMP.w #".",D0 : BNE.w JUMP_syntaxerr
  
  JSR getparameter2 : BEQ.w JUMP_laberr

  LEA newtypebase,A2
  JSR findtype : BNE.w 'ok1
    CMPI.l #MaxByte,4(A2) : BNE.w JUMP_typeerr    ; was #$FF
      BRA.w 'ok2
 'ok1
    JSR add_Label
 'ok2

  CLR.l 4(A2)
  MOVE.l A2,thistype
  CLR.l prevtype
  CLR.w typelen
  CLR.w linemode
  JSR reget
  BNE.w typemode
RTS


typemode:
  CMP.w ##TokenID_End,D0 : BEQ.w doend2 ; was #$8002 / -$7FFE
  
   ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  MOVEQ.l #$00,D6                      ;not a pointer
  CMP.w #"*",D0 : BNE.w 'skip
    MOVEQ.l #$01,D6
    JSR get1bytemain
    BRA.w 'skipv
 'skip
    CMP.w #$40,D0 : BNE.w 'skipv         ;'@'
      MOVEQ.l #$05,D6
      JSR get1bytemain
 'skipv

  MOVE.w D6,flagmask
  JSR getparameter2 : BEQ.w JUMP_syntaxerr

  MOVEA.l thistype,A2
  ADDQ.w #4,A2
  JSR findvariable2 : BEQ.w JUMP_dupofferr     ;beq    .skip2
  ;
  JSR add_Label
  ;
; 'skip2                  ; org source
  MOVE.l A2,-(A7)
  CMP.w #".",D0 :  BEQ.w 'skip3
  CMP.w #"$",D0 :  BNE.w 'notstring
  
  MOVE.l #newtype_string,D2
  JSR get1bytemain
BRA.w 'skip4a

 'notstring
  MOVE.l prevtype,D2 : BEQ.w JUMP_notypeerr2
BRA.w 'skip4

 'skip3
  JSR getparameter2 : BEQ.w JUMP_syntaxerr
  
  LEA newtypebase,A2
  JSR findtype : BEQ.w 'gotit
    BTST #$0,flagmask+1 : BEQ.w JUMP_notypeerr2
    ;
    ;pointer type, gotta do something tricky!
    ;
    JSR add_Label

    ; new >
   'n
    ; < new
    MOVE.w linenumat+2,8(A2)
    MOVE.l #MaxByte,4(A2)       ; was $FF  ;set to pointer crap
 'gotit

  MOVE.l A2,D2

 'skip4
  CMP.l #newtype_byte,D2 : BEQ.w 'byte

 'skip4a
  ADDQ.w #1,typelen
  BCLR #$0,typelen+1

 'byte
  MOVEQ.l #$00,D3
  MOVEA.l D2,A2
  MOVE.l A2,prevtype
  MOVE.w 8(A2),D3
  MOVEA.l (A7)+,A2
  MOVE.l D2,$A(A2)
  MOVEQ.l #$00,D4
  MOVE.w typelen,D4
  MOVE.w D4,4(A2)
 
  BTST #$0,flagmask+1 : BEQ.w 'skipz
    MOVEQ.l #$04,D3
 'skipz

  CMP.w #"[",D0 : BNE.w 'skipzz
    ;
    ;get constant value!
    ;
    MOVEM.l D3-D4/A2,-(A7)
    BSR.w evalconst3

    CMP.w #"]",D0 : BNE.w JUMP_syntaxerr
    TST.w D6 : BNE.w JUMP_fpconerr

    MOVE.l D3,D1
    MOVEM.l (A7)+,D3-D4/A2
    JSR get1bytemain
    MOVE.w D1,8(A2)
    MULU.l d1,d3                                             ;>32k fix was mulu.w
    ORI.w #$2,flagmask
 'skipzz

  ADD.l D3,D4
  ; new >
  CNIF #types64
    CMP.l #65532,d4
  CELSE
    CMP.l #32764,d4
  CEND
  ; < new
  ; CMP.l   #32768,d4       ; org source
  BCC JUMP_toolongerr
  MOVE.w flagmask,$6(A2)
  MOVE.w D4,typelen
RTS


JUMP_badenderr  JMP badenderr
JUMP_noiferr    JMP noiferr
JUMP_toolongerr JMP toolongerr
JUMP_fpconerr   JMP fpconerr


doendif3:
  MOVE.l firstiff,D0 : BEQ.w JUMP_noiferr

  MOVEA.l D0,A0
  MOVE.w $C(A0),D0
  ANDI.w #$FF,D0
  CMP.w D0,D1 : BNE.w JUMP_badenderr

doendif2:
  CMP.w #$1,D1 : BNE.w 'calcbra
    ;-- put in BRA instruction
    MOVE.w ##opcode_BRA,D1

    CNIF #longbranch
      TST.b optimize_integer : BEQ 'l1
        OR.l #$ff,d1
     'l1
    CEND

    BSR.w writeword

    MOVEA.l destpointer,A1
    MOVE.l $4(A0),D1
    SUB.l A1,D1

    CNIF #longbranch
      TST.b optimize_integer : BEQ 'l2
        BSR writelong
        BRA 'calcbra
     'l2
    CEND

    BSR.w writeword
 'calcbra

  MOVEA.l $8(A0),A1                                        ;write if branch destination
  MOVE.l destpointer,D1
  SUB.l A1,D1
 
  CNIF #longbranch
    TST.b optimize_integer : BEQ 'l3
      ADDQ.l #4,D1
      MOVE.w dontwrite_nomemleft,D0 : BNE.w 'skip
        MOVE.l d1,-$4(a1)
        BRA 'skip
   'l3
  CEND

  ADDQ.l #2,d1

  TST.w dontwrite_nomemleft : BNE 'skip
    CMP.l #MinWordSgnd,D1 : BCC.w JUMP_bigiferr
    MOVE.w D1,-$2(A1)
 'skip
RTS

JUMP_bigiferr JMP bigiferr


.do_Wend:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

dowend2:
  MOVEQ.l #$01,D1
BRA.w doendif

.mydo_Endif2:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

mydoendif:
  MOVEQ.l #$00,D1

doendif:
  BSR.w doendif3
  BSR.w freetheifz
JMP get1bytemain


freetheifz:
  MOVE.l (A0),firstiff
  MOVEA.l A0,A1
  MOVEQ.l #$0E,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
JMP _FreePooled(A6)


JUMP_modeerr JMP modeerr
JUMP_interr3 JMP interr3
JUMP_interr JMP interr


doend2:
  JSR get1bytemain

.do_end:
  BEQ.w 'done
  ; new >
  CMP.l #"noa7",-1(a5) : BNE 'l1
    JSR get1bytemain
    JSR get1bytemain
    JSR get1bytemain
    MOVE.w #$3a,lastchar    ;":"
    BRA 'done
 'l1
  CMP.w #"d0",-1(a5) : BNE 'l2
    MOVE.b #1,returncode
    CLR.w lastchar
    BRA 'done
 'l2
  CMP.w ##TokenID_Object,d0 : BNE 'loop
    JSR skiprest
    RTS
  ; < new
 'loop
    BSR.w 'doend3
    JSR reget
  BNE.w 'loop
RTS

'doend3
  CMP.w ##TokenID_NEWTYPE,D0  : BNE.w 'nottype     ; was #$8001 / -$7FFF
    MOVE.w linemode,D1 : BNE.w JUMP_modeerr

    ADDQ.w #1,typelen
    BCLR #$0,typelen+1
    MOVEA.l thistype,A0
    MOVE.w typelen,$8(A0)
    MOVE.w #$FFFF,linemode        ; was -1
    JMP get1bytemain
 'nottype

  CMP.w ##TokenID_If,D0       : BEQ.w mydoendif    ; was #$800b
  CMP.w ##TokenID_While,D0    : BEQ.w dowend2      ; was #$800c
  CMP.w ##TokenID_Statement,D0: BNE.w 'notstate    ; was #$8008

 'state   ;end of statement/function processing!
  BRA.w endstate

 'notstate
  CMP.w ##TokenID_Function,D0 : BNE.w 'notfunc     ; was #$8009
  
  ; new >
  TST.b optimize_fpu : BEQ 'nof
    MOVEA.l currentfunction,A0
    CMP.l #0,a0 : BEQ 'nof
    CMP.b #5,$5(a0) : BNE 'nof
    MOVE.l #$f23c5000,d1 : BSR writelong           ;fmove.w #-1,fpx
    MOVE.w #0,d1 : BSR writeword
 'nof
    MOVE.w #$7000,D1 : BSR.w writeword             ;end function moveq #0,d0
    
    MOVEA.l currentfunction,A0
    CMP.l #0,a0 : BEQ 'state
   
    MOVE.l destpointer,d1
    SUB.l $e(a0),d1
    MOVE.l d1,isfunc+1(a0)
 
    CMPI.b #$7,$5(A0) : BNE.w 'state
    MOVE.w putstlen,D1 : BSR.w writeword
    BRA.w 'state

 'notfunc
  CMP.w ##TokenID_SetInt,D0 : BNE.w 'notsetint         ; was #$8000+48
  
    MOVE.w proceduremode,D1 : BNE.w JUMP_interr3

    ;-- close interrupt code defined by SetInt
    TST.b debugmode : BEQ.w 'norerrf1
      MOVEQ.l #$03,D1 : JSR writetrap
      MOVE.w dontwrite_nomemleft,D1 : BNE.w 'norerrf1
        MOVEA.l intcleanat,A0
        MOVE.l destpointer,(A0)
        MOVE.w #$C30C,D1 : BSR.w Atokejsr      ; (runerrlib, gouser)
   'norerrf1

    MOVE.w intstring,D1 : BEQ.w JUMP_interr
    BPL.w 'nosp
      MOVE.w intlevel,D1
      ORI.w #$7200,D1 : JSR writeword       ;moveq #level,d1
      MOVE.w #$C103,D1 : BSR.w Atokejsr  ; was #oldint,    
      CLR.w intlevel
   'nosp

    CLR.w intstring
    ;
    MOVE.l intfin,D1 : JSR writelong                    ;restore registers after interrupt code
    MOVE.l #$70004E75,D1 : JSR writelong                ;MOVEQ #0,d0:RTS
    

    MOVE.w dontwrite_nomemleft,D1 : BNE.w 'sintdone
      MOVEA.l intjmpat,A0                               ;patch jmp command right before interrupt routine (see setint)
      MOVE.l destpointer(PC),(A0)
   'sintdone
    JMP get1bytemain
 
 'notsetint
  CMP.w ##TokenID_Select,D0 : BEQ.w doendsel   ; was #$800e     ;end select?
  CMP.w ##TokenID_SetErr,D0 : BNE.w 'notseterr ; was #$8001+tnum
    JMP doendseterr
 'notseterr
  JMP syntaxerr

 'done
  TST.w direct_mode : BNE.w JUMP_baddirerr

  MOVE.w #$C800,D1 : JSR Atokejsr              ; (exitlib, #progend)
  ; new >
  CMP.l #"noa7",-4(a5) : BNE 'l10
    TST.w dontwrite_nomemleft : BNE 'l10
      MOVE.l destpointer,d1
      SUBQ.l #4,d1
      MOVE.l a0,-(a7)
      MOVE.l d1,a0
      MOVE.l (a0),a0
      MOVE.l #$60000002,(a0)+                  ;BRA next instruction
      MOVE.w #$588f,(a0)                       ;native addq.l #4,a7
      MOVE.l (a7)+,a0
 'l10
RTS
  ; < new


.do_Stop:
  TST.w direct_mode : BNE.w JUMP_baddirerr
  
  MOVE.w d0,d1 : BEQ 'l10
    CMP.b #$3a,d0 : BEQ 'l10    ;":"
      JSR get1bytemain
 'l10

  TST.b debugmode : BEQ.w newstop
    MOVE.w #$D501,D1 : BRA.w Atokejsr                            ; debuglib/Stop
  newstop:
    CNIF #stopignore
      RTS
    CEND
    MOVE.w d1,d0 : BEQ 'l10
      CMP.b #$3a,d0 : BEQ 'l10     ;":"
        SUB.b #$30,d0
        MOVE.w #opcode_TRAP0,d1
        BRA 'l11
   'l10
      MOVE.w #$4e4a,d1 : JMP writeword      ; TRAP #10 ?
   'l11
    ADD.b d0,d1
JMP writeword

.do_Cont:
JMP badconterr        ;cont not currently supported!



free_Fors:
  MOVEA.l _execbase,A6
  
  MOVEA.l firstfor,A2
  CLR.l firstfor
 'loop
    CMPA.w #$0,A2 : BEQ.w 'done
    
    MOVEA.l A2,A1
    MOVEA.l (A1),A2
    MOVEQ.l #$00,D0 : MOVE.b $10(A1),D0
    MOVE.l mempool2,a0 : JSR _FreePooled(A6)                ;freememfor_error
  BRA.w 'loop
 'done
RTS


JUMP_badpenderr JMP badpenderr                            ; Illegal End procedure
JUMP_noenderr   JMP noenderr

endstate:                                                 ;End Statement
  ;--
  ;-- first, fill in any FUNCTION RETURN type shit.....
  ;-- 
  MOVE.w proceduremode,D1 : BEQ.w JUMP_badpenderr
  ;
  MOVE.w dontwrite_nomemleft,D1 : BNE.w 'ship
    MOVEA.l firstpend,A2

   'loop0
      CMPA.w #$0,A2 : BEQ.w 'ship

      MOVEA.l 4(A2),A0
      MOVE.l destpointer,(A0)
      MOVEA.l (A2),A2
    BRA.w 'loop0
 'ship

  TST.b debugmode : BEQ.b 'ship2
    MOVEQ.l #$05,D1 : JSR writetrap
 'ship2

  MOVEA.l firstlocal,A2                                    ;firstlocal
  JSR calcstatic2b                                           ;calcstatic
  MOVEA.l currentfunction,A0
  ; new >
  MOVE.l destpointer,d1
  SUB.l $e(a0),d1
  MOVE.l d1,isfunc+1(a0)                                   ;store function size
  ; < new
  MOVE.w D4,$8(A0)                                         ;set if memalloc need
  MOVE.l D3,locdatast
  MOVEA.l tempvm,A1
  ; new >
  CLR.b infunctioncode
  MOVE.l firstiffstore,d1
  CMP.l firstiff,d1 : BNE JUMP_noenderr

  ; < new
  TST.w $C(A1) :   BPL.w 'nolskip                         ;dim
    BSET #$7,$8(A0)
    MOVE.w #$C005,D1 : BSR.w tokejsr2              ; #freelocalmem, write freemem statement
    BRA.w 'lskip2
 'nolskip
    MOVE.w memlibstat,$C(A1)
 'lskip2

  MOVEA.l currentfunction,A0
  MOVE.l $E(A0),-(A7)
  MOVE.w locvaroff,$6(A0)
  BCLR #$1,$7(A0)
  BCLR #$0,$7(A0)
  CMPI.b #$7,$5(A0) : BNE.w 'penis
    MOVE.w getstlen,D1
    JSR writeword
 'penis
  TST.w $6(A0) : BEQ.w 'nolink
    MOVE.w #$FC7B,D1 : JSR uselib                     ;#64635  clrlib
    MOVE.w unlinka4,D1 : JSR writeword
 'nolink
  ;
  ;fix the stacked string lengths!
  ;
  MOVEA.l currentfunction,A0
  MOVEQ.l #$00,D1
  MOVE.b $4(A0),D1
  LSR.w #4,D1 : BEQ.w 'nofix
  ; new >
  CNIF #more6string
     LSL.w #1,d1
  CEND
  ; < new
  CMP.w #$1,D1 : BNE.w 'not1
    MOVE.w fix1,D1
    JSR writeword
    BRA.w 'nofix
 'not1
  LSL.w #2,D1
  MOVE.w D1,-(A7)
  MOVE.w D1,moverts+2
  MOVE.l moverts,D1 : JSR writelong
  MOVE.w (A7)+,D1
  CMP.w #$8,D1 : BHI.w 'fix
    ANDI.w #$7,D1
    LSL.w #8,D1
    LSL.w #1,D1
    OR.w fixq,D1
    JSR writeword
    BRA.w 'nofix
 'fix
   MOVE.w D1,fixstack+2
    MOVE.l fixstack,D1
    JSR writelong
 'nofix
  BSR.w normret
  ;
  ;put in the setup stuff here!
  ;
   BSR.w procfixer
  ;
  MOVEA.l (A7)+,A0
  MOVE.w dontwrite_nomemleft,D1
   BNE.w 'skipjp
  MOVE.l destpointer,-(A0)

 'skipjp
  CLR.w proceduremode
  CLR.l currentfunction
  CLR.w procnum
   BSR.w droplocals
   JSR free_pEnds
JMP get1bytemain


droplocals:
  MOVEQ.l #$0C,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0 : JSR _AllocPooled(a6)
  MOVEA.l D0,A0

  MOVE.l alllocals,(A0)
  MOVE.l A0,alllocals
  ;
  MOVE.l firstlocal,D0
  CLR.l firstlocal
  MOVE.l D0,$4(A0)
  
  MOVE.l firstglob,D1
  CLR.l firstglob
  MOVE.l D1,$8(A0)
  ;
  TST.b debugmode : BEQ.b 'skip
    TST.w dontwrite_nomemleft : BNE.b 'skip
      MOVEA.l proclocals(PC),A0
      MOVE.l D0,(A0)+
      MOVE.l D1,(A0)
 'skip
RTS


JUMP_baddirerr JMP baddirerr
JUMP_noforerr  JMP noforerr


.do_next:
  TST.w direct_mode : BNE.w JUMP_baddirerr

  MOVE.l firstfor,D1 : BEQ.w JUMP_noforerr

  JSR reget : BEQ.w 'unknown
  ;--
  ;-- here, we've got 'Next Var[,Var...]'
  ;--

 'nextnext
  BSR.w getparameter
  MOVEA.l firstfor(PC),A2
  MOVEQ.l #$00,D1
  MOVE.b $10(A2),D1
  SUBI.w #$12,D1
  CMP.w D1,D2 : BNE.w JUMP_noforerr

  LEA namebuffer(PC),A0
  LEA $11(A2),A1
  SUBQ.w #1,D2

 'chkname
    CMPM.b (A0)+,(A1)+ : BNE.w JUMP_noforerr
  DBF D2,'chkname

  BSR.w 'unknown2
  JSR reget : BEQ.w 'byebye
    CMP.w #",",D0 : BNE.w JUMP_syntaxerr
    
    JSR get1bytemain
    BRA.w 'nextnext
 'byebye
  RTS

  ; new >
 'fpu2dats
  MOVE.l 8(a7),a2
  Dc.l  $f2124400                                          ;fmove.s (a2),fp0
  Dc.l  $F2174422                                          ;fadd.s (a7),fp0
  Dc.l  $F2126400                                          ;fmove.s fp0,(a2)
 'fpu2date
  ; < new

 'unknown
  MOVEA.l D1,A2

 'unknown2
  JSR popnext                                           ;error checking for next.
  MOVE.w 12(A2),D0
  ;
  LEA nextb,A0
  LEA nextbf,A1
  CMP.w #$1,D0 :  BEQ.w 'donext

  LEA nextw,A0
  LEA nextwf,A1
  CMP.w #$2,D0 :  BEQ.w 'donext

  LEA nextl,A0
  LEA nextlf,A1
  CMP.w #$5,D0 :  BNE.w 'donext

    ; new >
    TST.b optimize_fpu :  BEQ 'old
      LEA 'fpu2dats,a0                                         ;fpu next code
      LEA 'fpu2date,a1
      BRA 'donext
   'old
      ; < new
      MOVE.w #$C900,D1 : BSR.w Atokejsr     ; #getffpbase
      LEA nextf,A0
      LEA nextff,A1
 'donext
  JSR pokecode

  ; new >
  TST.b optimize_integer                                             ;fast for next deactivate
  BRA 'l1
                                                           ;??Looks like dead code??
  TST.b onestep : BEQ 'l1
    CLR.b onestep
    SUBQ.l #4,destpointer
    MOVE.w #$5292,d1 : JSR writeword
 'l1
  ; < new
  MOVE.l thebra(PC),D1 : JSR writelong
  ;
  MOVEA.l firstfor,A2
  MOVE.l (A2),firstfor
  ;
  ;pass2, o.k. to put in my BRA's!
  ;
  MOVEA.l 8(A2),A0
  MOVEA.l destpointer,A1
  MOVE.l A1,D1
  SUB.l A0,D1            ;d1=positive bra
  ADDQ.l #2,D1
  CMP.l #MinWordSgnd,D1 : BCC.w JUMP_bigforerr     ; #32768,
   
  TST.w dontwrite_nomemleft : BNE.w 'nopoke1
    MOVE.w D1,-$2(A0)
 'nopoke1
  MOVE.l A1,D1
  SUB.l 4(A2),D1
  SUBQ.l #6,D1
  CMP.l #MinWordSgnd,D1 :   BCC.w JUMP_bigforerr              ;#32768,
  
  TST.w dontwrite_nomemleft : BNE.w 'skip
    NEG.w D1
    MOVE.w D1,-$2(A1)
 'skip

  JSR popnext3                ;fix stack
  
  MOVEA.l _execbase,A6
  MOVEA.l A2,A1
  MOVEQ.l #$00,D0
  MOVE.b $10(A1),D0
  MOVE.l mempool2,a0 : JSR _FreePooled(A6)
JMP reget


JUMP_notallowd JMP notallowd
JUMP_bigforerr JMP bigforerr


forset: MOVE.w #$664F,-(A7)          ;#'fO',
thebra: BRA.w thebra

JUMP_error_dublicate_for JMP error_dublicate_for
JUMP_badforerr           JMP badforerr


forlineat:   Ds.l 1
fortemp:     Ds.w 1


.do_for:
  ;
  ;For var = START To FINISH [Step INCREMENT]
  ;
  ; new >
  CLR.l fp0addr
  ; < new
  TST.w direct_mode : BNE.w JUMP_baddirerr

  MOVE.l linenumat,forlineat
  ;
  ;new stuff!
  ;
  MOVE.l A5,letstart
  BSR.w getparameter
  MOVE.w D2,fortemp
  ;
  JSR findfor : BEQ.w JUMP_error_dublicate_for

  LEA firstfor,A2
  JSR addhere2

  MOVE.l A2,-(A7)

  TST.b debugmode : BEQ.b 'noerr
    JSR insert_stackchk
    MOVE.l forset,D1 : JSR  writelong
 'noerr

  MOVE.w fortemp(PC),D2
  ; new >
  MOVE.b #1,formode
  ; < new
  BSR.w dolet2                                         ;for get 1. value
  CLR.b formode

  CMP.w ##TokenID_To,D0 : BNE.w JUMP_syntaxerr       ; was #$8018,
  MOVE.w commode,D1 :  BNE.w JUMP_syntaxerr
  CMP.b #$6,D2      :  BCC.w JUMP_badforerr

  BTST #$F,D2 : BNE.w 'skip
    MOVE.w leaamp,D1
    JSR pokewda5s
    MOVE.w D3,D1
    JSR  writeword
 'skip

  MOVE.w pushindex,D1
  JSR  writeword         ;index lea on stack
  ANDI.w #$FF,D2

  MOVEA.l (A7),A1
  MOVE.w D2,$C(A1)
  ;
  MOVE.w D2,-(A7)
  BSR.w eval             ;get fin
  ; new >
  CLR.b onestep
  CMP.w ##TokenID_Step,d0 : BEQ 'l1
    MOVE.b #1,onestep
 'l1
  ; < new
  MOVE.w (A7),D2
  ;
  MOVE.w pushd0l,D1
  CMP.w #$3,D2 : BCC.w 'skip1
    MOVE.w pushd0wd,D1
 'skip1
  MOVE.w D1,-(A7)
  ; new >
  TST.b optimize_fpu : BEQ 'old
    CMP.b #5,d2 : BNE 'old
      MOVE.l #$f2276400,d1
      ;MOVE.l #$f2277400,d1
      JSR writelong
      BRA 'weit
 'old
  ; < new
    JSR  writeword        ;push fin on stack                                   ;fpu for end value

 'weit
  CMP.w ##TokenID_Step,D0 : BNE.w 'defstep
      ;
      BSR.w eval           ;get step
      ; new >
      TST.b optimize_fpu : BEQ 'pushstep
        CMP.b #5,d2 : BNE 'pushstep
          MOVE.l #$f2276400,d1                                    ;write step <> 1
          ;MOVE.l #$f2277400,d1                                    ;write step <> 1
          JSR writelong
          ; < new
          ; BRA.w 'pushstep
          ; < new
          MOVE.w (a7)+,d1
          BRA 'fpur
          ; < new
 'defstep
  CMP.w #$4,D2 : BCC.w 'qup
    MOVE.w #$7001,D1 : JSR writeword
    BRA.w 'pushstep
 'qup
    BNE.w 'notq
    MOVE.w #$7001,D1 : JSR writeword
    MOVE.w swapd0,D1 : JSR writeword
    BRA.w 'pushstep

 'notq
  ; new >
  TST.b optimize_fpu : BEQ 'old2
  CMP.b #5,d2 : BNE 'old2
    MOVE.l #$f23c5000,d1 : JSR writelong                    ;fmove.w #-1,fpx
    MOVE.w #$1,d1 : JSR writeword
    MOVE.l #$f2276400,d1 : JSR writelong
    MOVE.w (a7)+,d1
    BRA 'fpur
 'old2
    ; < new
    MOVE.w #$203C,D1 : JSR writeword                        ;write step 1
    MOVE.l #$80000041,D1 : JSR writelong                    ;ffp '1'
    
   'pushstep
    MOVE.w (A7)+,D1
    JSR writeword           ;push step on stack                                 ;push step on stack

  ; new >
 'fpur
  ; < new
  MOVE.w (A7)+,D2
  MOVEA.l (A7),A1
  MOVE.l destpointer,$4(A1)
  LEA forcompb,A0
  LEA forcompbf,A1
  CMP.w #$1,D2 : BEQ.w 'docomp

  LEA forcompw,A0
  LEA forcompwf,A1
  CMP.w #$2,D2 : BEQ.w 'docomp

  LEA forcompl,A0
  LEA forcomplf,A1
  CMP.w #$5,D2 : BNE.w 'docomp

    ; new >
    TST.b optimize_fpu : BEQ 'old3
      LEA fpu_start,a0
      LEA fpu_end,a1
      JSR pokecode
      BRA 'fpu3
   'old3
    ; < new
    LEA forcompf,A0
    LEA forcompff,A1
    JSR pokecode
    MOVE.w #$C900,D1 : BSR.w Atokejsr                      ; mathffplib, #getffpbase
   
    LEA forcompf2,A0
    LEA forcompf2f,A1
 'docomp
  JSR pokecode

  TST.b optimize_integer :   BEQ 's1                       ;fast for next
    CMP.w #3,d2 : BNE 's1
      TST.b onestep : BEQ 's1
        SUB.l #10,destpointer
        MOVE.w #$b081,d1 : JSR writeword                   ;CMP.L
 's1
 'fpu2
  ; < new
  MOVE.l thebgt(PC),D1 : JSR writelong

  ; > new
 'fpu3
  ; < new
  MOVEA.l (A7)+,A1
  MOVE.l destpointer,$8(A1)
JMP reget


; new >
fpu_start
  MOVEA.l 8(a7),a2
  Dc.l $f2124400                                           ;fmove.s (a2),fp0
  fmove.s 4(a7),fp1
  BTST.b #7,(a7) : BNE 'negi
    fcmp.x fp1,fp0
    BRA 'negi2
 'negi
    fcmp.x fp0,fp1
 'negi2
  Dc.l $f2920000                                           ;fbgt.w
fpu_end                                                   ;??Looks like double label??
; < new

thebgt:                  BGT.w thebgt

JUMP_error4char          JMP error4char
JUMP_error_convert_types JMP error_convert_types
JUMP_noleterr            JMP noleterr
JUMP_nocomerr            JMP nocomerr
JUMP_comerr              JMP comerr


.do_let:
  MOVE.l A5,letstart
  JSR getparameter

dolet2:
  ; new >
 'varassign
  MOVE.l destpointer,pushpc
  MOVE.l hunkoffsetbase,pushoff
  CLR.l rightsidetype
  CLR.w rightsideflagmask
  ; < new
  MOVE.w #$0001,regnum            ;don't disturb this reg!
  JSR fetchvars                   ;var in a3, type in a2
  JSR calcvar                     ;get offset stuff
  ; new >
  TST.b formode : BEQ 'lf1
    CMP.l #newtype_double,A2 : BEQ JUMP_notallowd

    MOVE.l a2,currtype
 'lf1

  CLR.w startoffsetmore
  CMP.w #"=",d0 :  BNE 'l1a
    BTST #15,d2 :  BEQ 'l1a
      CMP.b #1,d2 : BNE 'l1a
        MOVE.w leaa0a0+2,startoffsetmore
 'l1a
  ; < new
  CLR.w regnum                     ;don't disturb this reg
  BSR.w pushdo
  CLR.w commode
  ; new >
  CLR.w stackcorrect
  ; < new
  CLR.w pcodd
  ; new >
  MOVE.w startoffsetmore,d1       ; program counter ?

  BTST #0,d1 : BEQ 'l2a
    MOVE.w #1,pcodd
 'l2a
  ; < new
  ;
  CMP.w #"=",D0 : BEQ.w 'nextcom
  
    ; new >
   'l1
    MOVE.b (a5)+,d1 : BEQ 'l10
      CMP.b #":",d1 : BEQ 'l10
      CMP.b #";",d1 : BEQ 'l10
      CMP.b #"0",d1 : BLT 'l11
      CMP.b #"9",d1 : BGT 'l11
        BRA.s 'l1
   'l10
      MOVE.b #1,quickadd
   'l11
    ; < new
    ;--
    ;-- move char to start of var name!
    ;-- 
    MOVEA.l letstart,A5
    SUBQ.w #1,A5
 'nextcom

  CMP.b #$7,D2 : BNE.w 'notstring
    ;-- string get!
    ;--
    MOVEM.w D2-D3,-(A7)
    MOVE.l lastoffset_org,-(A7)
    MOVE.w varmode,-(A7)
    JSR setsvars          ;!@!

  ;end 457a
  ; < new
    MOVEQ.l #$07,D2
    JSR eval
    MOVE.w (A7)+,varmode
    MOVE.l (A7)+,lastoffset_org
    MOVE.w moved0a3,D1
    JSR writeword

    MOVE.w commode,D1 : BEQ.w 'stconti
      LEA pulla2st,A0
      LEA pulla2stf,A1
      JSR pokecode
      BRA.w 'stconti2
  'stconti
      BSR.w pushput
  'stconti2

    MOVEM.w (A7)+,D2-D3
    BTST #$F,D2 : BNE.w 'already
      MOVE.w D3,leaa5d3a2+2
      MOVE.l leaa5d3a2,D1
      JSR pokela5s
  'already
    MOVE.w #$FE6F,D1 : JSR uselib        ; was #65135, string2lib
    MOVE.l #$C700,D1                     ; was #lastring, memlib
    MOVE.l d1,lastinstruction
    MOVE.w varmode,D2 : BNE.w 'local
      ADDQ.w #1,D1                        ;use global allocmem
   'local
    BSR.w Atokejsr

    CMP.w #",",D0 : BNE.w 'done
    
    MOVE.w addq4a2,D1 : JSR writeword
    BRA.w 'nextstr
 'notstring

  BTST #$E,D2 : BNE.w 'skip           ;pointer, ignore!
   
  TST.b D2 : BEQ.w JUMP_noleterr       ;tried to assign a struct - later!

  ; new >
  TST.b optimize_newsyntax : BEQ 'skip2

  'atmode
    CMP.w #$4022,(a5) : BNE 'skip2
    CMP.l #3,d2 : BNE JUMP_error_convert_types

    ADDQ #2,a5
    MOVEQ #0,d0
    MOVE.b (a5)+,d0 :  BEQ 'skip2
    CMP.b #$22,d0 : BNE 'l5                     ;'"'
      MOVE.b #0,d0
      BRA 'do
  'l5
    ASL.l #8,d0
    MOVE.b (a5)+,d0 :  BEQ 'skip2
    CMP.b #$22,d0 : BNE 'l2                     ;'"'
      MOVE.b #0,d0
      ASR.l #8,d0
      BRA 'do
  'l2
    ASL.l #8,d0
    MOVE.b (a5)+,d0 : BEQ 'skip2

    CMP.b #$22,d0 : BNE 'l3                     ;'"'
      MOVE.b #0,d0
      ASR.l #8,d0
      BRA 'do
  'l3
      ASL.l #8,d0
      MOVE.b (a5)+,d0 : BEQ 'skip2
      CMP.b #$22,d0 : BNE 'l4                   ;'"'
        MOVE.b #0,d0
        ASR.l #8,d0
        BRA 'do
    'l4
      CMP.b #$22,(a5)+ : BNE JUMP_error4char    ;'"'
  'do
      MOVE.w #$2b7c,d1
      TST.w varmode : BEQ 'g3
        BCLR #9,d1
    'g3
      JSR writeword
      MOVE.l d0,d1
      JSR writelong
      MOVE.w d3,d1
      JSR writeword
      JSR get1bytemain
      RTS
  ; < new

  ; BRA.w 'skip2                                            ;??Looks like dead code??

  'skip
    ; new >
    MOVE.w d2,vartype
    ; < new
    MOVE.b #$3,D2
 'skip2

  ;-- 
  ;-- let's get what is to be assigned.....
  ;--
  ; new >
  CMP.b #5,d2 : BNE 'l1aa
    MOVE.l a2,currtype
 'l1aa

  ;MOVE.l currtype,-(a7)
  ; < new
  MOVEM.w D2-D3,-(A7)
  MOVE.w varmode,-(A7)
  ; new >
  MOVE.l a2,leftsidetype
  MOVE.w flagmask,leftsideflagmask
  BTST #$f,d2 : BEQ 'nomultiassign
    CLR.l leftsidetype                        ;its multiassign to type entries so no typecheck need
    CLR.w leftsideflagmask
 'nomultiassign
  ; < new
  ANDI.w #$FF,D2
  MOVE.l lastoffset_org,-(A7)
  JSR eval                                ; calc right side of var assign
  ; new >
  MOVEM.l a0/a1,-(a7)
  MOVE.l leftsidetype,a0
  CMP.l #0,a0 : BEQ 'nocheck
  CMP.w #1,leftsideflagmask : BEQ 'isptr
  CMP.l #$100,4(a0) : BLE 'nocheck

 'isptr
  TST.l typetocast : BEQ 'nocast
    MOVE.l typetocast,a1
    BRA 'typecheck
 'nocast

  TST.l rightsidetype : BEQ 'nocheck
    MOVE.l rightsidetype,a1
    CMP.w #1,rightsideflagmask : BEQ 'ok
    CMP.l #$100,4(a1) : BGE 'typecheck
    CMP.l #$3,4(a1) : BEQ 'ok                 ;long assign is allow with this codelines
    BRA 'error

   'typecheck
    TST.b typecheck :  BEQ 'nocheck
      TST.b notypecheck : BNE 'ok
      CMP.l a0,a1 : BEQ 'ok
                                              ; check if type is parent for var assign
      MOVE.l 4(a1),a1                         ; load the address of 1. type.
      CMP.l $a(a1),a0 : BEQ 'ok               ; check if the bigger type contain in first place same type as the function need

    'error
      JMP   error_convert_types     ;for SYNTAX 4  = typecheck
    'ok
 'nocheck

  CLR.l typetocast
  MOVEM.l (a7)+, a0/a1
  ; < new
  MOVE.l (A7)+,lastoffset_org
  MOVE.w commode,D1 : BNE.w 'conti
    BSR.w pushput
 'conti
  MOVE.w (A7)+,varmode
  MOVEM.w (A7)+,D2-D3
  ;
  ; new >
  ;MOVE.l (a7)+,currtype
  ; < new
  MOVE.w #$2B40,D1                              ;MOVE.L  D0,$0000(A5)
  MOVE.w varmode,D4 : BEQ.w 'skip1
    BCLR #$9,D1
 'skip1
  BTST #$F,D2 : BEQ.w 'code
  ;
  ; new >
  TST.b stackcorrect : BNE 'st1
    ; < new
    MOVE.w commode,D1 : BEQ.w 'skipc1
    ; new >
 'st1
  ; < new
  MOVE.w pulla2,D1
  JSR writeword
 'skipc1

  MOVE.w #$2480,D1               ;move.l d0,(a2)
  ;
  ; new >
  MOVEM.l a0/d0,-(a7)
  MOVEA.l lastoffset_org,A0
  MOVE.l A0,D0 : BEQ.w 'skipa
    MOVEA.l D0,A0
    MOVE.l $A(A0),currtype
 'skipa

  MOVEM.l (a7)+,a0/d0
  ; < new
  CMP.w #",",D0 : BNE.w 'code
  ;
  MOVE.w #$24C0,D1           ;move.l d0,(a2)+
  BSR.w 'code                                         ;write store

 'nextstr
  MOVE.l lastoffset_org,D0
  ;BEQ.w JUMP_nocomerr

  ; new >
 'dim1
  ; < new
  MOVE.w #$FFFF,commode    ; -1
  ;CLR.w varcodelen
  ; new >
  MOVE.b #1,optiarray
  ; < new
  MOVE.w pusha2,D1
   JSR writeword
  ; new >
  TST.l lastoffset_org : BEQ 'dimmore
  MOVEA.l lastoffset_org,A0
  ; < new
  MOVE.l (A0),D0 : BEQ.w JUMP_comerr          ;comma past end of struct

  MOVEA.l D0,A0
  MOVE.l A0,lastoffset_org
  BTST #$1,$7(A0) : BNE.w JUMP_nocomerr        ;can't use comma on multiple entries

  MOVEA.l $A(A0),A1
  MOVE.l $4(A1),D2
  ; new >
 'dimlet
  ; < new
  BTST #$0,$7(A0) : BNE.w 'nextpnt             ;pointer
  CMP.l #$100,D2 : BCC.l JUMP_nocomerr        ;or on structs

  BRA.w 'docom                                     ; do do type\x= 10,20,30....

  ; new >
 'dimmore
  CLR.b optiarray
  CMP.w #"@@",(a5) : BEQ 'n1
    BRA 'd1
 'n1
    JSR nextline
    MOVE.l a5,-(a7)

   'l6
      MOVE.b (a5)+,d0
      CMP.b #" ",d0
    BEQ 'l6
    MOVE.l (a7)+,a5
  CMP.b #";",d0
  BEQ 'n1
 'd1

  TST.w debugmode : BEQ 'nextcom

  MOVE.l a0,-(a7)
  MOVE.l pushat,a0
  CMP.l #0,a0 : BNE 'o1
    BRA 'skipb
 'o1
    ADD.l #1,2(a0)
 'skipb

  CLR.w commode
  MOVE.b #1,stackcorrect
  MOVE.l (a7)+,a0
  JMP 'nextcom
  ; < new

 'nextpnt
  CMP.l #$100,D2 : BCS.w 'nextpnt2
    MOVEQ.l #$00,D2
 'nextpnt2

  BSET #$E,D2

 'docom
  BSET #$F,D2
  BRA.w 'nextcom

  ; new >
 'farr                                     ; ??? look like not used ???
  MOVE.l destpointer,a4                   ;
  MOVE.l #$f22a6400,-4(a4)                ;
  MOVE.w arrayoffset,d1                   ;
  JMP writeword                             ;
  ; < new

 'code
  ;new >
  TST.b optimize_fpu : BEQ 'nofloat

  CMP.b #5,d2 : BNE 'nofloat               ; is it a float ?
  
  CLR.w fp0var
  LEA regtable,a4
  TST.l (a4) : BEQ 'noreg
  BTST #15,d2 : BNE 'noreg                  ;regvars
  
  CMP.w 0+4(a4),d3 : BNE 'doreg1
  MOVE.l #$f2000380,d1
  MOVE.w regnum,d0 : BNE 'noopt
                                                           ;fmove.x fp0,fp7 should be added
                                                           ;optimize if code before is
                                                           ;fmove.x fp7,fp1
                                                           ;fadd.x fp1,fp0
    MOVE.l destpointer,a4
    CMP.l #$f2001c80,-8(a4) : BNE 'noopt
    CMP.l #$f2000422,-4(a4) : BNE 'noopt
      MOVE.l #$f20003a2,d1
      SUB.l #8,destpointer
 'noopt
  ASL.w #7,d0
  OR.w d0,d1
  JSR writelong
  RTS

 'doreg1
  CMP.w 8+4(a4),d3 : BNE 'doreg2
    MOVE.l #$f2000300,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    JSR writelong
    RTS
 'doreg2
  CMP.w 16+4(a4),d3 : BNE 'doreg3
    MOVE.l #$f2000280,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    JSR  writelong
    RTS
 'doreg3
  CMP.w 24+4(a4),d3 : BNE 'doreg4
    MOVE.l #$f2000200,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    JSR writelong
    RTS
 'doreg4
  CMP.w 32+4(a4),d3 : BNE 'noreg
    MOVE.l #$f2000180,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    JSR writelong
    RTS
 'noreg

  TST.w regnum : BNE 'nofp0

  MOVE.l destpointer ,a4
  CMP.l #$f2304400,-6(a4) : BNE 'do5
    CMP.w #$1990,-2(a4) : BNE 'do5
      BTST #15,d2 : BNE 'do5                                   ;types ?
      
        MOVE.l #$2b701990,d1                                     ;var

        TST.w varmode : BEQ 'glob1
          BCLR #25,d1
       'glob1
        MOVE.l d1,-6(a4)
        MOVE.w d3,-2(a4)
        CLR.w fp0var
        MOVE.w #$ffff,fp0mode
        RTS
 'do5
  CMP.l #$f22d4400,-6(a4) : BNE 'do3                           ;fmove.s (a5),fp0
  
  CMP.l #newtype_double,currtype : BEQ 'do4

 'nd1
  MOVE.w #$2b6d,d1
  TST.w varmode : BEQ 'g2
    BCLR #9,d1
 'g2
  CMP.w #$2b6d,d1 : BNE 'd1a
    CMP.w -2(a4),d3 : BNE 'd1a
    SUBQ.l #6,destpointer
    BRA 'd12
 'd1a
    MOVE.w d1,-6(a4)                                       ;fmove.s to move.l mem,mem
    MOVE.w -2(a4),-4(a4)
    MOVE.w d3,-2(a4)
 'd12
    CLR.w fp0var
    MOVE.w #$ffff,fp0mode
    RTS

 'do3
  CMP.l #$f22c4400,-6(a4) : BNE 'do4                       ;fmove.s (a4)
    MOVE.w #$2b6c,d1
    TST.w varmode : BEQ 'g3a
      BCLR #9,d1
   'g3a
    MOVE.w d1,-6(a4)
    MOVE.w -2(a4),-4(a4)
    MOVE.w d3,-2(a4)
    CLR.w fp0var
    MOVE.w #$ffff,fp0mode
    RTS
 'do4
  MOVE.w d3,fp0var
  MOVE.w varmode,fp0mode
  ADDQ.l #6,a4
  MOVE.l a4,fp0addr
  MOVE.l firstiff,fp0iff

 'nofp0
  MOVEM.l d0/d4,-(a7)
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.w #7,d0                                             ;fpu store var

  BTST #15,d2 : BEQ 'var

  MOVE.w d1,d4
  CMP.w #$24c0,d4 : BNE 'nopl
    MOVE.l #$f21a6400,d1
    MOVEQ #0,d3
    BRA 'glob
 'nopl
    ;MOVE.l #$f22a6400,d1                                    ;for newtype
    MOVE.l #$f2126400,d1
    TST.w d3 : BNE 'offset                                   ;offset =0
      MOVE.l #$f2126400,d1
      ;   CMP.w #$24c0,d4
      ;   BNE 'glob
      ;   MOVE.l #$f21a6400,d1                                    ;fmove.s fp0,(a2)+
      ; BRA 'glob
   'offset
    ;SUBQ.l #4,destpointer
    MOVEQ #0,d3
    BRA 'glob

 'var
    MOVE.l #$f22d6400,d1                                     ;var
    TST.w varmode : BEQ 'glob
      BCLR #16,d1
 'glob
  OR.l d0,d1

 'weit
  CMP.l #newtype_double,currtype : BNE 'dbl1
    OR.l #$00001000,d1
 'dbl1
  JSR writelong
  CLR.l currtype
  MOVEM.l (a7)+,d0/d4
  MOVE.l d3,d1 : BEQ 'nooffs
    JMP writeword
 'nooffs
RTS

;  CMP.l #$f2126400,-4(a4)
;  BEQ 'exit
;  CMP.l #$f21a6400,-4(a4)
;  BEQ 'exit
; BRA writeword

; 'exit
; RTS

;JMP writeword                                              ;??looks like dead code?

 'nofloat
  TST.b optimize_integer : BEQ 'la10                                   ;write lea->xx(a2)
   
  CNIF #optibreak
    ILLEGAL
  CEND
  TST.b quickadd
  ;BNE 'lq1                                               ;to avoid bug
  CLR.b quickadd
  CMP.w #$2480,d1 : BNE 'la10
  TST.b optiarray : BNE 'la10
  MOVE.l destpointer,a4
  CMP.w #$45ea,-4(a4) : BNE 'la10
  CMP.w #8,pushclen : BEQ 'la100
  CMP.w #6,pushclen : BNE 'la10
  CMP.b #3,d2 : BCS 'la110
    MOVE.w #$2540,-2(a4)                                   ;store value
    MOVE.w arrayoffset,d1
    JMP writeword
   'lq1
    CLR.b quickadd
    RTS
 'la110
  CMP.b #2,d2 : BNE 'la120
    MOVE.w #$3540,-2(a4)
    MOVE.w arrayoffset,d1
    JMP writeword
 'la120
  CMP.b #1,d2 : BNE.s 'la10
    MOVE.w #$1540,-2(a4)
    MOVE.w arrayoffset,d1
    JMP writeword

 'la100
  CMP.b #3,d2 : BCS 'la11
    MOVE.w #$2540,-4(a4)
    RTS
 'la11
  CMP.b #2,d2 : BNE 'la12
    MOVE.w #$3540,-4(a4)
    RTS
 'la12
  CMP.b #1,d2 : BNE.s 'la10
    MOVE.w #$1540,-4(a4)
    RTS
 'la10
  CLR.b optiarray
  ; < new
  CMP.b #$1,D2 : BEQ.w 'byte
  BSR.w varalign
  CMP.b #$3,D2 : BCC.w 'writevarlong
   ; new >
  TST.b optimize_integer :  BEQ 'l10bc                         ;optiimmi
    CNIF #optibreak
     ILLEGAL
    CEND
    MOVE.l destpointer,a0
    SUB.l imm_addr,a0
    CMP.l #4,a0 : BNE 'l10c
      CLR.l imm_addr
      MOVE.l destpointer,a4
      OR.w #$107c,d1
      MOVE.w d1,-4(a4)
      MOVE.w D3,D1
      JMP writeword
   'l10c
  MOVE.l destpointer,a0
  SUB.l load_var_addr,a0
  CMP.l #4,a0 : BNE 'l10bc
  CMP.w #$302d,-4(a4) :   BNE 'l10bc                ;check 68k opcode
    CLR.l load_var_addr
    MOVE.l destpointer,a4
    OR.w #$102d,d1
    MOVE.w d1,-4(a4)
    MOVE.w d3,d1
    JMP writeword
 'l10bc
  ; < new
  ORI.w #$1000,D1                                          ;word
  BRA.w 'writestorevar


 'byte
  ; new >
  TST.b optimize_integer :  BEQ 'l10bb                               ;optiimmi
    CNIF #optibreak
      ILLEGAL
    CEND
  MOVE.l destpointer,a0
  SUB.l imm_addr,a0
  CMP.l #4,a0 : BNE 'l10d
    CLR.l imm_addr
    MOVE.l destpointer,a4
    OR.w #$7c,d1
    EORI #$3000,d1
    MOVE.w d1,-4(a4)
    MOVE.w D3,D1
    JMP writeword
 'l10d
  MOVE.l destpointer,a0
  SUB.l load_var_addr,a0
  CMP.l #4,a0 : BNE 'l10bb
    CLR.l load_var_addr
    MOVE.l destpointer,a4
    CMP.w #$1b6d,-4(a4) : BNE 'l10bb
      OR.w #$2d,d1
      EORI #$3000,d1
      MOVE.w d1,-4(a4)
      MOVE.w d3,d1
      JMP writeword
 'l10bb
  ; < new
  ADDQ.w #1,pcodd                                          ;byte
  EORI.w #$3000,D1

 'writestorevar                    ; was  'do  org source
  JSR writeword
  BTST #$7,D1 : BNE 'done
  MOVE.w D3,D1
  JMP writeword

 'writevarlong
  TST.b optimize_integer : BEQ 'l10ba                             ;optiimmi
    CNIF #optibreak
      ILLEGAL
    CEND
    MOVE.l destpointer,a0
    SUB.l imm_addr,a0
    CMP.l #6,a0 : BNE 'l10e
      CLR.l imm_addr
      MOVE.l destpointer,a4
      OR.w #$7c,d1
      MOVE.w d1,-6(a4)
      MOVE.w D3,D1
      JMP writeword
   'l10e
    MOVE.l destpointer,a0
    SUB.l load_var_addr,a0
    CMP.l #4,a0 : BNE 'l10ba
      CLR.l load_var_addr
      MOVE.l destpointer,a4
      CMP.w #$245f,-2(a4) : BEQ 'l10ba
        OR.w #"(",d1
        OR.w d1,-4(a4)
        CMP.w #$2b6d,-4(a4) : BNE 'd1aa
          CMP.w -2(a4),d3 : BNE 'd1aa
            SUBQ.l #4,destpointer
            RTS
      'd1aa
        MOVE.w d3,d1
        JMP writeword
 'l10ba
  ; < new
  JSR writeword
  BTST #$7,D1 : BNE.b 'done
    MOVE.w D3,D1
    JMP writeword
 'done
RTS


varalign:                       ; was  alignletpc  org source
  MOVE.w D1,-(A7)
  MOVE.w pcodd(PC),D1
  LSR.w #1,D1
   BCC.b 'done
  CLR.w pcodd
  MOVE.w add1a2,D1
   JSR writeword

 'done
  MOVE.w (A7)+,D1
RTS


;------                                                  ;disassembled code begin
add1a2:     Dc.b $52,$4A                                   ;ADDQ.W  #1,A2
;------                                                  ;disassembled code end

pcodd:     Ds.w 1                                          ;add 1 to this for bytes
listadd:   Ds.w 1                                          ;set to 8 if it's a list
listsize:  Ds.w 1


.do_dim:                         ; dodim org source
  ADDQ.w #1,regnum               ;get things into d1

  MOVE.b #1,nowdeclare

  CLR.b dimkeep
  CMP.w ##TokenID_KEEP,D0 : BNE.w 'nokeep
  ;CMP.l #"KEEP",-1(a5) : BNE 'nokeep  ; check "KEEP" option
  ;CMP.b #" ",3(a5) : BNE 'nokeep    ; skip the 4 characters if keep
  ;  ADDQ.l #3,a5              
  ; '2
  ;    CMP.b #" ",(a5) : BNE '1      ; skip spaces        
  ;    ADDQ #1,a5
  ;  BRA '2
  ; '1
    MOVE.b #1,dimkeep
    JSR get1bytemain
 'nokeep
 
  MOVE.w #$FF9A,D1 : JSR uselib     ; is #65434, arraylib, func: ?

  dodim2:
  CLR.w listadd
  CMP.w ##TokenID_List,D0 : BNE.w 'notalist
    MOVE.w #$0008,listadd           ; it's a list, we need 8 additional bytes for the links
    MOVE.w #$FFFA,D1 : JSR uselib   ; is #65530, memlib                      
    JSR get1bytemain
 'notalist

  CLR.w nonew
  JSR getparameter ; load the variable name from current position in D0 into namebuffer

  BTST #$1,flagmask+1 : BEQ.w JUMP_syntaxerr

  ;-- check if variable has been already declared as another type
  ;BSR checkdoubledeclare ; is buggy as it destroys content of namebuffer that is needed for fetchvars!!

  JSR fetchvars

  MOVE.w notshared,D1 : BNE.w 'added
    ;--
    ;-- Here, an Array is being Re-Dimmed
    ;--
    MOVE.w $8(A3),temp1

    MOVE.w proceduremode,D2 : BNE.w 'reloc
      ;
      ;!regs2stack
      ;!basic
      ;log2PED{"redim a gobal var!"}
      ;!asm
      ;!stack2regs
      MOVE.w globalvarpointer,-(A7)
      MOVE.w $4(A3),globalvarpointer
      ADDQ.w #4,globalvarpointer
      BSR.w write_dim_code
      MOVE.w (A7)+,globalvarpointer
      BRA.w 'next
      ; 'reloc                                                ;??
      ;;  MOVE.w locvaroff,-(A7)         ; org source
        ; new >
      ;  MOVE.w globalvarpointer,-(A7)
        ; < new
      ;  MOVE.w $4(A3),locvaroff
      ;  subq.w #4,locvaroff
      ;   BSR.w write_dim_code
      ;  MOVE.w (A7)+,locvaroff
      ;BRA.w 'next
      
   'reloc                           ; new
      ; new >
      MOVE.w globalvarpointer,-(A7)
      MOVE.w proceduremode,-(a7)
      CLR.w proceduremode
      MOVE.w $4(A3),globalvarpointer
      ADDQ.w #4,globalvarpointer
      BSR.w write_dim_code
      MOVE.w (a7)+,proceduremode
      MOVE.w (A7)+,globalvarpointer
      ; < new
      BRA.w 'next
 'added
    ;-- here, we are doing a brand new dim!
    ;--
    MOVE.w #$FFFF,temp1                  ; was -1  ;no care on # dims
    MOVE.w listadd(PC),D1 :BEQ.w 'isok
      MOVE.w #$4000,temp1                ;yes, we do care - must be 1 coz it's a list
      BSET #$0,$6(A3)                    ;set to list type of array
   'isok
    ; new >
    TST.w proceduremode : BNE 'l1
      MOVE.w locvaroff,-(a7)
   'l1
    ; < new
    BSR.w write_dim_code
    ; new >
    TST.w proceduremode : BNE 'next
      MOVE.w (A7)+,locvaroff
    ; < new
 'next
  JSR get1bytemain

  CMP.w #",",D0 : BNE.w 'done                ; ","
    JSR get1bytemain
    BRA.w dodim2
 'done
RTS


JUMP_syntaxerr JMP syntaxerr
JUMP_redimerr JMP redimerr


.write_dim_code:                                           ;dimwrite org source
  MOVE.w #$FFFF,nonew                                      ;#-1,nonew org source
  
  MOVE.w beginarr,D1 : JSR writeword                       ; write MOVE.l #$00000000,D0
  MOVEQ.l #$00,D1    : JSR writeword                       ; write MOVE.l x,d0

  MOVEQ.l #$04,D1
  BTST #$0,flagmask+1 :BNE.w 'pointer
    MOVE.w 8(A2),D1
 'pointer
  ADD.w listadd(PC),D1                                     ; size of one element.
  MOVE.w D1,listsize : JSR writeword                       ; write size to x (see above)

  CLR.w temp2                                              ;# dim's got
  MOVE.l A3,-(A7)

 'loop
  ADDQ.w #1,temp2
  MOVEQ.l #$03,D2                                          ;get word
  MOVE.w notshared,-(a7)
  JSR eval                                                 ;eval the next parameter ? and write NOVE.L <number arry elements>,D1
  MOVE.w (a7)+,notshared
  
  ;TST.b debugmode : BEQ.w 'norerr0
  ;  MOVE.w #$C30F,D1 : BSR.w Atokejsr                     ; (runeerslib, aarrayschk)
  ;'norerr0
  ;MOVE.w #$C402,D1 : BSR.w Atokejsr

  MOVE.w #$5281,d1 : JSR writeword                         ; write opcode addq.l #1,d1
  

  ;multiplycode:   Dc.b $0C,$81,$00,$00,$FF,$FF                   ;CMPI.L  #$0000FFFF,D1
  ;                Dc.b $64,$00,$00,$08                           ;BCC.W   bigmul
  ;                Dc.b $C1,$C1                                   ;  MULS.W D1,D0
  ;                Dc.b $60,$00,$00,$06                           ;  BRA endmul
  ;bigmul:                                                        ;bigmul
  ;                Dc.b $4C,$01,$08,$00                           ;  MULS.L D1,D0         ; 68020+ only!
  ;endmul:                                                        ;endmul
  ;------                                                  ;disassembled code end

  ;-- write MULS-code variants for 68000/68020+
  MOVE.l multiplycode(PC),D1    : JSR writelong
  MOVE.w multiplycode+4(PC),D1  : JSR writeword
  MOVE.l multiplycode+6(PC),D1  : JSR writelong            ; code for calculation needed mem size
  MOVE.w multiplycode+10(PC),D1 : JSR writeword
  MOVE.l multiplycode+12(PC),D1 : JSR writelong
  MOVE.l multiplycode+16(PC),D1 : JSR writelong            

  MOVE.w proceduremode,D2 : BEQ.w 'global
    SUBQ.w #4,locvaroff
    MOVE.w locvaroff,putarr+2
    BRA.w 'doit
 'global
    MOVE.w globalvarpointer,putarr+2
    ADDQ.w #4,globalvarpointer
 'doit

  TST.b dimkeep : BEQ 'doit_l1
    MOVEQ #0,d1
    MOVE.w putarr+2,d1
    OR.l  #$222d0000,d1
    MOVE.w proceduremode,D2 : BEQ 'doit_l2
      TST.w notshared : BEQ 'doit_l2
        SUB.l #$00010000,d1
   'doit_l2
    JSR writelong                                         ; something like  MOVE.L -$7FD3(a5),d1
 'doit_l1

  MOVE.l putarr,D1  
  TST.w notshared : BNE 'doit_l1a
    JSR writelong                                         ; something like MOVE.l d0,-$7FD3(a5)
    BRA 'doit_l4
 'doit_l1a
    JSR pokela5d                                          ; write A5
 'doit_l4

  CMP.w #",",D0 :  BEQ.w 'loop

  CMP.w #")",D0 :  BNE.w JUMP_syntaxerr

  MOVEA.l (A7)+,A3


  ;--
  ;-- is it a list?
  ;--
  MOVE.w temp1,D1 : BMI.w 'nocare  
    BTST #$E,D1 : BEQ.w 'notl
      CMPI.w #$1,temp2 : BNE.w JUMP_redimerr
      BRA.w 'nocare
   'notl
      CMP.w temp2,D1 : BNE.w JUMP_redimerr                      ;range too long

     'ok                                                        ;??looks like not used anymore??
      LEA globalvarpointer,A0
      MOVE.w proceduremode,D1 : BEQ.w 'gskip
        LEA locvaroff,A0
     'gskip
      MOVE.W extraword,(A0)
      BRA.W  'care
 'nocare
    MOVE.w temp2,$8(A3)                                    ;set # dim's
 'care
  LEA doarr,A0                                             ;load opcodes for filling D2 and D3 
                                                           ;MOVE.W  #$0000,D2
                                                           ;MOVE.W  #$0000,D3
  MOVE.w $4(A3),$2(A0)                                     ; put values into d2 and d3
  MOVE.w putarr+2,$6(A0)
  MOVE.l (A0)+,D1 :  JSR writelong                         ; something like MOVE.w #-$7FD7,d2 pointer to globalvar: pointer to existing array
  MOVE.l (A0),D1  :  JSR writelong                         ; something like MOVE.w #-$7FD3,d3 pointer to globalvar: size of existing array

  TST.b dimkeep : BNE 'care_l3
   'care_l1                                  ; obsolete label??
    MOVE.w #$C400,D1                         ; arrayslib: newarray
    BRA 'care_l2
 'care_l3
    MOVE.w #$C405,d1                         ; arrayslib: newarray2, this will copy the current array to the new one
 'care_l2

  MOVE.w proceduremode,D2 : BEQ.w 'isglobal
    TST.w notshared : BEQ 'isglobal
      ADDQ.w #1,D1                           ; switch to local array code
 'isglobal

  MOVE.w listadd(PC),D2 : BEQ.w 'isrg
    MOVE.w D1,-(A7)
    MOVE.w setles(PC),D1 : JSR writeword     ; writecode to write listsize into A4
    MOVE.w listsize(PC),D1 : JSR writeword
    MOVE.w (A7)+,D1
    ADDQ.w #3,D1                             ; switch from array to list code
 'isrg
BRA.w Atokejsr

;------                                                  ;disassembled code begin
setles:         Dc.w $383C,$0000                         ;MOVE.W  #$0000,D4
;------                                                  ;disassembled code end

;------                                                  ;disassembled code begin
multiplycode:   Dc.w $0C81,$0000,$FFFF                   ;CMPI.L  #$000FFFF,D1
                Dc.w $6400,$0008                         ;BCC.W   bigmul
                Dc.w $C0C1                               ;  MULU.W D1,D0
                Dc.w $6000,$0006                         ;  BRA endmul

bigmul:         Dc.w $4C01,$0800                         ;  MULS.L D1,D0
endmul:                                                  ;endmul
;------                                                  ;disassembled code end


fpu_pi:
CNIF #64bitconstant
  MOVE.l #$f23c5400,d1                                  ; opcode: fmove.d
CELSE
  MOVE.l #$f23c4400,d1                                  ; opcode: fmove.s
CEND
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.w d0,d1
  JSR writelong
CNIF #64bitconstant
  MOVE.l #$400921fb,d1
  JSR writelong
  MOVE.l #$54442D18,d1
CELSE
  MOVE.l #$40490fd9,d1
CEND
  JSR writelong
JMP get1bytemain


;-----------data-----------------------;

.mydata

;vbr:                Ds.l 1
cfetchmode:         Ds.w 1                               ;1=fetching a constant
                    ;intercept uselib!
constlibs           Dc.w $FDA7,$FCDF,$FD43               ;64935,64735,64835: ffplib, ldivlib, lmullib

    ;below is a PC for the constant evaluation routine
    ;
constpcat:          Ds.l 1
constlibat:         Ds.l 1
constmaxpc:         Dc.l $400
   ;
stacksize:          Dc.l #DEFAULT_STACKSIZE              ;stackfuck org source
currentlabeladdr:   Dc.l labelbase                       ;lastrescon org source
currentmacroaddr:   Dc.l macrobase                       ;lastresmac org source
lastrestype:        Dc.l newtype_string
rescnt:             Ds.w 1                               ;# resident
state_of_residents: Ds.w 1                               ;reschg org source ;flag for if res's have changed
resat:              Dc.l residents_table                 ;??looks like not used anymore??
linedone:           Ds.w 1
directbuffer:       Ds.w 11                              ;dirpcat  dc.w 0 org source
                                                         ;dira4    dc.l 0           ;Label not used in org source
                                                         ;dira5    dc.l 0           ;Label not used in org source
                                                         ;dira6    dc.l 0           ;Label not used in org source
                                                         ;dirstack dc.l 0           ;Label not used in org source

.handle_datatypes
convtable:
;byte
  Dc.l 0                                        ; bytetobyte      byte
  Dc.l convert_byte_to_word                     ; bytetoword      word
  Dc.l convert_byte_to_long                     ; bytetolong      long
  Dc.l convert_byte_to_quick                    ; bytetoquick     quick
  Dc.l convert_byte_to_float                    ; bytetofloat     float
  Dc.l convert_byte_to_long                     ; bytetolong      address??
  Dc.l error_convert_types                      ; noconerr        string

;word
  Dc.l convert_word_to_byte                     ; wordtobyte
  Dc.l 0                                        ; wordtoword
  Dc.l convert_word_to_long                     ; wordtolong
  Dc.l convert_word_to_quick                    ; wordtoquick
  Dc.l convert_word_to_float                    ; wordtofloat
  Dc.l convert_word_to_long                     ; wordtolong
  Dc.l error_convert_types                      ; noconerr

;long
  Dc.l convert_long_to_byte                     ; longtobyte
  Dc.l convert_long_to_word                     ; longtoword
  Dc.l 0                                        ; longtolong
  Dc.l convert_long_to_quick                    ; longtoquick
  Dc.l convert_long_to_float                    ; longtofloat
  Dc.l 0                                        ; longtolong
  Dc.l error_convert_types                      ; noconerr

;quick
  Dc.l convert_quick_to_byte                    ; quicktobyte
  Dc.l convert_quick_to_word                    ; quicktoword
  Dc.l convert_quick_to_long                    ; quicktolong
  Dc.l 0                                        ; quicktoquick
  Dc.l convert_quick_to_float                   ; quicktofloat
  Dc.l convert_quick_to_long                    ; quicktolong
  Dc.l error_convert_types                      ; noconerr

;float
  Dc.l convert_float_to_byte                    ; floattobyte
  Dc.l convert_float_to_word                    ; floattoword
  Dc.l convert_float_to_long                    ; floattolong
  Dc.l convert_float_to_quick                   ; floattoquick
  Dc.l 0                                        ; floattofloat
  Dc.l convert_float_to_long                    ; floattolong
  Dc.l error_convert_types                      ; noconerr

;address
  Dc.l convert_long_to_byte                     ; longtobyte
  Dc.l convert_long_to_word                     ; longtoword
  Dc.l 0                                        ; longtolong
  Dc.l convert_long_to_quick                    ; longtoquick
  Dc.l convert_long_to_float                    ; longtofloat
  Dc.l 0                                        ; longtolong
  Dc.l error_convert_types                      ; noconerr

;string
  Dc.l error_convert_types                      ; noconerr
  Dc.l error_convert_types                      ; noconerr
  Dc.l string_to_long                           ; stringtolong
  Dc.l error_convert_types                      ; noconerr
  Dc.l error_convert_types                      ; noconerr
  Dc.l string_to_long                           ; stringtolong
  Ds.l 1

    ;dc operator ascii
    ;dc.l   ..b,.w,.l,.q,.f,.a,.s                          ;dc.l   ..b,.w,.l,.q,.f,.s,.a org source seem wrong

operators:
  Dc.b $00,$2B                                  ;+ ; add
  Dc.l do_plus_byte                             ;doplusb
  Dc.l do_plus_word                             ;doplusw
  Dc.l do_plus_long                             ;doplusl
  Dc.l do_plus_long                             ;doplusl
  Dc.l do_plus_float                            ;doplusf
  Ds.l 1
  Dc.l add_strings                              ;addstrings
  Dc.b $0B,$B8
  ;
  Dc.b $00,$2D                                  ;- ; sub
  Dc.l do_minus_byte                            ;dominusb
  Dc.l do_minus_word                            ;dominusw
  Dc.l do_minus_long                            ;dominusl
  Dc.l do_minus_long                            ;dominusl
  Dc.l do_minus_float                           ;dominusf
  Ds.l 2
  Dc.b $0B,$B8
  ;
  Dc.b $00,$2A                                  ;* ; mul
  Dc.l do_times_byte                            ;dotimesb
  Dc.l do_times_word                            ;dotimesw
  Dc.l do_times_long                            ;dotimesl
  Dc.l do_times_quick                           ;dotimesq
  Dc.l do_times_float                           ;dotimesf
  Ds.l 2
  Dc.b $0F,$A0
  ;
  Dc.b $00,$2F                                  ;/ ; div
  Dc.l do_Div_byte                              ;dodivb
  Dc.l do_Div_word                              ;dodivb
  Dc.l do_Div_long                              ;dodivl
  Dc.l do_Div_quick                             ;dodivq
  Dc.l do_Div_float                             ;dodivf
  Ds.l 2
  Dc.b $0F,$A0
  ;
  Dc.b $00,$26                                  ;& ; & int
  Dc.l do_AND_byte                              ;doandb
  Dc.l do_AND_word                              ;doandw
  Dc.l do_AND_long                              ;doandl
  Dc.l do_AND_long                              ;doandl
  Ds.l 3
  Dc.b $13,$88
  ;
  Dc.b $00,$7C                                  ;| ;or int ;
  Dc.l do_OR_byte                               ;doorb
  Dc.l do_OR_word                               ;doorw
  Dc.l do_OR_long                               ;doorl
  Dc.l do_OR_long                               ;doorl
  Ds.l 3
  Dc.b $13,$88
  ;
  Dc.b $80,$42                                  ; AND int  ;(opand-opabcd)/$1c+$8000+fnum
  Dc.l do_AND_byte                              ;doandb
  Dc.l do_AND_word                              ;doandw
  Dc.l do_AND_long                              ;doandl
  Dc.l do_AND_long                              ;doandl
  Ds.l 3
  Dc.b $03,$E8
  ;
  Dc.b $80,$8A                                  ; OR int   ;(opor-opabcd)/$1c+$8000+fnum
  Dc.l do_OR_byte                               ;doorb
  Dc.l do_OR_word                               ;doorw
  Dc.l do_OR_long                               ;doorl
  Dc.l do_OR_long                               ;doorl
  Ds.l 3
  Dc.b $03,$E8
  ;
  Dc.b $80,$73                                  ; EOR int  ;(opeor-opabcd)/$1c+$8000+fnum
  Dc.l do_EOR_byte                              ;doeorb
  Dc.l do_EOR_word                              ;doeorw
  Dc.l do_EOR_long                              ;doeorl
  Dc.l do_EOR_long                              ;doeorl
  Ds.l 3
  Dc.b $03,$E8
  ;
  Dc.b $80,$7C                                  ; LSL int  ;(oplsl-opabcd)/$1c+$8000+fnum
  Dc.l do_LSL                                   ;dolslb
  Dc.l do_LSL                                   ;dolslw
  Dc.l do_LSL                                   ;dolsll
  Dc.l do_LSL                                   ;dolsll
  Ds.l 3
  Dc.b $17,$70
  ;
opls:
  Dc.b $3C,$3C                                  ;<< BitShift left
  Dc.l do_LSL
  Dc.l do_LSL
  Dc.l do_LSL
  Dc.l do_LSL
  Ds.l 3
  Dc.b $17,$70
  ;
oprs:
  Dc.b $3E,$3E                                  ;>> BitShift right
  Dc.l do_LSR
  Dc.l do_LSR
  Dc.l do_LSR
  Dc.l do_LSR
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$44                                  ; ASL int  ;(opasl-opabcd)/$1c+$8000+fnum
  Dc.l do_LSL                                   ;dolslb
  Dc.l do_LSL                                   ;dolslw
  Dc.l do_LSL                                   ;dolsll
  Dc.l do_LSL                                   ;dolsll
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$7D                                  ; LSR int  ;(oplsr-opabcd)/$1c+$8000+fnum
  Dc.l do_LSR                                   ;dolsrb
  Dc.l do_LSR                                   ;dolsrw
  Dc.l do_LSR                                   ;dolsrl
  Dc.l do_LSR                                   ;dolsrl
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$45                                  ; ASR int  ;(opasr-opabcd)/$1c+$8000+fnum
  Dc.l do_ASR                                   ;doasrb
  Dc.l do_ASR                                   ;doasrw
  Dc.l do_ASR                                   ;doasrl
  Dc.l do_ASR                                   ;doasrl
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$8E                                  ; ROL int  ;(opasr-opabcd)/$1c+$8000+fnum
  Dc.l do_ROL_b                                 ;dorolb
  Dc.l do_ROL_w                                 ;dorolw
  Dc.l do_ROL_l                                 ;doroll
  Dc.l do_ROL_l                                 ;doroll
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$8F                                  ; ROR int  ;(opasr-opabcd)/$1c+$8000+fnum
  Dc.l do_ROR_b                                 ;dororb
  Dc.l do_ROR_w                                 ;dororw
  Dc.l do_ROR_l                                 ;dororl
  Dc.l do_ROR_l                                 ;dororl
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$B9                                  ;mod       ;$8006+tnum
  Dc.l do_mod_byte                              ;domodb
  Dc.l do_mod_word                              ;domodw
  Dc.l do_mod_long                              ;domodl
  Dc.l do_mod_quick                             ;domodq
  Dc.l do_mod_float                             ;domodf
  Ds.l 2
  Dc.b $13,$88
  ;
oppow:
  Dc.b $00,$5E                                  ;^
  Dc.l do_pow                                   ;dopow
  Dc.l do_pow                                   ;dopow
  Dc.l do_pow                                   ;dopow
  Dc.l do_pow                                   ;dopow
  Dc.l do_pow                                   ;dopow
  Ds.l 2
  Dc.b $1B,$58                                  ;7000
  ;
opeq:
  Dc.b $00,$3D                                  ;=
  Dc.l do_equal_byte                            ;doeqb
  Dc.l do_equal_word                            ;doeqw
  Dc.l do_equal_long                            ;doeql
  Dc.l do_equal_long                            ;doeql
  Dc.l do_equal_float                           ;doeqf
  Dc.l do_equal_long                            ;doeql
  Dc.l do_equal_string                          ;doeqs
  Dc.b $07,$D0                                  ;2000
  ;
opne:
  Dc.b $3C,$3E                                  ;<>
  Dc.l do_not_equal_byte                        ;doneb
  Dc.l do_not_equal_word                        ;donew
  Dc.l do_not_equal_long                        ;donel
  Dc.l do_not_equal_long                        ;donel
  Dc.l do_not_equal_float                       ;donef
  Dc.l do_not_equal_long                        ;donel
  Dc.l do_not_equal_string                      ;dones
  Dc.b $07,$D0                                  ;2000
  ;
oplt:
  Dc.b $00,$3C                                  ;<
  Dc.l do_littler_byte                          ;doltb
  Dc.l do_littler_word                          ;doltw
  Dc.l do_littler_long                          ;doltl
  Dc.l do_littler_long                          ;doltl
  Dc.l do_littler_float                         ;doltf
  Dc.l do_littler_long                          ;doltl
  Dc.l do_littler_string                        ;dolts
  Dc.b $07,$D0                                  ;2000
  ;
ople:
  Dc.b $3C,$3D                                  ;<=
  Dc.l do_littler_equal_byte                    ;doleb
  Dc.l do_littler_equal_word                    ;doleb
  Dc.l do_littler_equal_long                    ;dolel
  Dc.l do_littler_equal_long                    ;dolel
  Dc.l do_littler_equal_float                   ;dolef
  Dc.l do_littler_equal_long                    ;dolel
  Dc.l do_littler_equal_string                  ;doles
  Dc.b $07,$D0                                  ;2000
  ;
opgt:
  Dc.b $00,$3E                                  ;>
  Dc.l do_greater_byte                          ;dogtb
  Dc.l do_greater_word                          ;dogtw
  Dc.l do_greater_long                          ;dogtl
  Dc.l do_greater_long                          ;dogtl
  Dc.l do_greater_float                         ;dogtf
  Dc.l do_greater_long                          ;dogtl
  Dc.l do_greater_string                        ;dogts
  Dc.b $07,$D0                                  ;2000
  ;
opge:
  Dc.b $3E,$3D                                  ;>=
  Dc.l do_greater_equal_byte                    ;dogeb
  Dc.l do_greater_equal_word                    ;dogew
  Dc.l do_greater_equal_long                    ;dogel
  Dc.l do_greater_equal_long                    ;dogel
  Dc.l do_greater_equal_float                   ;dogef
  Dc.l do_greater_equal_long                    ;dogel
  Dc.l do_greater_equal_string                  ;doges
  Dc.b $07,$D0                                  ;2000
  ;
  Dc.b $80,$CD                                  ;$8000+26+tnum
  Dc.l _BitTst
  Dc.l _BitTst
  Dc.l _BitTst
  Dc.l _BitTst
  Ds.l 3
  Dc.b $1F,$40                                  ;8000
  ;
  Dc.b $80,$CE                                  ;$8000+27+tnum
  Dc.l _BitSet
  Dc.l _BitSet
  Dc.l _BitSet
  Dc.l _BitSet
  Ds.l 3
  Dc.b $1F,$40                                  ;8000
  ;
  Dc.b $80,$CF                                  ;$8000+28+tnum
  Dc.l _BitClr
  Dc.l _BitClr
  Dc.l _BitClr
  Dc.l _BitClr
  Ds.l 3
  Dc.b $1F,$40                                  ;8000
  ;
  Dc.b $80,$D0                                  ;$8000+29+tnum
  Dc.l _BitChg
  Dc.l _BitChg
  Dc.l _BitChg
  Dc.l _BitChg
  Ds.l 3
  Dc.b $1F,$40                                  ;8000
  ;
  Dc.b $00,$00


modetable:   Dc.l typemode


newtypebase: Dc.l newtype_byte

newtype_byte:                                              ;bytetype     1
  Dc.l newtype_word
  Dc.l $00000001
  Dc.w $0001
  Dc.b 13,"b",0,0

newtype_word:                                              ;wordtype     2
  Dc.l newtype_long
  Dc.l $00000002
  Dc.w $0002
  Dc.b 13,"w",0,0

newtype_long:                                              ;longtype     3
  Dc.l newtype_quick
  Dc.l $00000003
  Dc.w $0004
  Dc.b 13,"l",0,0

newtype_quick:                                             ;quicktype    4
  Dc.l newtype_float
  Dc.l $00000004
  Dc.w $0004
  Dc.b 13,"q",0,0

newtype_float:                                             ;floattype    5
  ;Dc.l addresstype
  ;Dc.l $00000005
  Dc.l newtype_double,$05                                  ;make problems on old residents
  Dc.w $0004
  Dc.b 13,"f",0,0

;addresstype:                                               ;addresstype 6
;  Dc.l newtype_double
;  Dc.l $00000006
;  Dc.w $0004
;  Dc.b 13,"a",0,0

newtype_double:                                            ;doubletype   5
  Dc.l newtype_string
  Dc.l $00000005
  Dc.w $0008
  Dc.b 13,"d",0,0

newtype_string:                                            ;stringtype   7
  Dc.l $0000000
  Dc.l $00000007
  Dc.w $0004
  Dc.b 13,"s",0,0

dummytype:
  Dc.l $00000000
  Dc.l $00000000
  Dc.w $0000
  Dc.b $01,$00,$00,$00


incdir:               Ds.l 24                              ;dcb.b   96,0    org source
                                                           ;Even            org source


direct_mode:          Ds.w 1                               ;direct mode flag
                      Ds.l 1                               ;int org source ;intuition!
maxobject_pos:        Ds.w 1                               ;maxat org source ;max at
maxsat:               Ds.l 1                               ;data1 info pos
number_of_objects:    Ds.w 1                               ;nummaxs org source ;number of maximums
                                                           ;in libs
maxsused:             Ds.w 1                               ;maximums used in prog

; below are defaults to be saved with source
;dark:                 Ds.w 1                               ;dark compile?
;qlab:                 Ds.w 1                               ;quick lab allocate
defaulttype:          Dc.l newtype_quick                   ;dc.l quicktype org source
; end of defaults

anyerrs:              Dc.w -1                              ;Any Errors in compile ?
debugversion:         Ds.w 1                               ;makeexec org source ;make an executable file!
noinits:              Ds.l 1                               ;flag for if we have any init routines!
                                                           ;6.l=no!
letstart:             Ds.l 1
dontwrite_nomemleft:  Ds.w 1                               ;nomemleft org source
lastgloballabel:      Ds.l 32                              ;lastbiglab ds.b 128 org source
locdatast:            Ds.l 1
firstpend:            Ds.l 1

; one pass compiler stuff!
data2at:              Ds.l 1
data2:                Ds.l 1
data1start:           Ds.l 1                               ;data1at org source
data1:                Ds.l 1                               ;pc for initialized data!
destbufferstart:      Ds.l 1                               ;pcat org source
;destpointer:          Ds.l 1                               ;pc org source          ;ds.w 1  ;   moved to .pluginbase
                                                            ;pc+2; destpointer+2:    Ds.b 1
                                                            ;pc+3; destpointer+3:    Ds.b 1
destbufferend:        Ds.l 1                               ;libat org source
libend:               Ds.l 1                               ;lib org source
allat:                Ds.l 1                               ;highest allocmemd location for code
dummyasm:             Dc.w 0,0,0,0,0
                      Dc.l 0
                      Dc.w 0
;
;data for assembler
;
buff1:                Ds.l 1                               ;buffer for text get
buff2:                Ds.l 1                               ;ditto for dest
constmode:            Ds.w 1                               ;0 for norm, <>0 for assembler
asmtype:              Ds.w 1                               ;0=contains no prog reference
extraword:            Ds.w 1                               ;the extension word for assembler
extraword2:           Ds.w 1                               ;ditto
asmsize:              Ds.w 1
asmbuff:              Ds.l 1
asmlen:               Ds.w 1                               ;first (src) text len
asmlen2:              Ds.w 1                               ;second (dest)
templabel:            Ds.l 1                               ;linked list of expressions to resolve
;for one pass assembly.
;
macnum:               Ds.w 1
;nextinc0:            Dc.l 0                               ;address of next 0 in include fil
titleat:              Ds.l 1                               ;5 longs for compile streaks
progress_per_line:    Ds.w 5                               ;titleadd ds 5 org source ;5 adds for compile streaks (each include has its one progress)

connest:              Ds.w 1                               ;conditional nest level
firstconst:           Ds.l 1                               ;first constant (#a)
numarg:               Ds.w 1                               ;number of macro arguements
macrolineold:         Ds.l 1                               ;macro done yet?
macroline:            Ds.l 1                               ;pointer to current macro line
                                                           ;line in.....
concomstack:          Ds.l 16                              ;32 deep conditional compilation
concomsp:             Dc.l concomstack                     ;stack pointer
oldqflag:             Ds.w 1
;datalib:             Dc.l 0                               ;pointer to datalib.obj (64535)  ;org source
;lastconloc:          Ds.l 1
;lastconop:           Ds.w 1
firstfor:             Ds.l 1                               ;first for
stackpar:             Ds.w 1                               ;pushflag org source ;1 par to stack 0 normal
sbgot:                Ds.w 1                               ;flag for string got 2
convsize:             Ds.w 1                               ;usertype org source
userp:                Ds.w 1

;libspos               Dc.w  0   ;pos in libs dir                      ;org source
;numlibs               Dc.w  0   ;number of libraries in libslist      ;org source
;ptr_userlibs_list:    Ds.l 1                               ;libslist org source

a2offset:             Ds.w 1                               ;stackuse org source ;stack used when gathering lib parameters
numreps:              Ds.w 1                               ;number of repeats in a repeatable

;parameter list.....
locloc:               Ds.l 1
locchar:              Ds.w 1
stbuff:               Ds.l 32                              ;was 8    ;six string varoffs
commode:              Ds.w 1                               ;in comma mode...
lastoffset_org:       Ds.l 1                               ;lastoffset org source ;last offset in calcvar!
linenumat:            Dc.l $FFFFFFFF                       ;linecounter ;dc -1 org source ;line being processed
compilelinecounter:   Dc.l $FFFFFFFF                       ;menuret dc -1 org source ;menu return code
;optresoff:           Ds.w 1                               ;opt reset offset
;varcode:             Ds.l 64                              ;Ds.b vcodelen org source ;code used to generate
;varcode2:            Ds.l 64                              ;Ds.b vcodelen org source ;above for let.....
;varcodelen:           Ds.w 1                               ;and length
;varcodelen2:         Ds.w 1
;oldvcodelen:          Ds.w 3                               ;old varcodelen
;stringslib1:         Dc.l 0                               ;address of stringslib1  ; org source
;procjmppc:           Dc.l 0                               ;pc of jmp of proc ;?? in org source presend  but not used??
Even4
tempvm:               Ds.l 1                               ;memlib org source ;address of memory library
memlibstat:           Ds.w 1                               ;status of memory library during
                      ;procs
;tempvmode:           Dc.w 0
;tempvmode2:          Dc.w 0
varmode:              Ds.w 1                               ;0 a5 pointer to global
                                                           ;else pointer to locals
currentfunction:      Ds.l 1                               ;thisproc org source
firstproc:            Ds.l 1                               ;firstproc org source ;this procedure being 'done'
proceduremode:        Ds.w 1                               ;-1=statement/ function return type ;procmode org source  ;1 if statement, 2 if function
                                                           ;0 if norm!
skipcode:             Ds.w 1                               ;nocompile ;comflag org source ;0 if no compile
passstack:            Ds.l 1
zero:                 Ds.l 1                               ;ZERO!
ininclude:            Ds.w 1                               ;numincs org source ;number of include files
                                                           ;0=main RAM code
xincludebase:         Ds.l 1                               ;firstxinc org source ;first exclusive include.
includebase:          Ds.l 1                              ;firstinc org source ;first include
lasta6:               Dc.w $FFFF                           ;-1 org source
instringon:           Ds.w 1                               ;quoteflag org source
ptr_macrobuffer_begin:Ds.l 1                               ;macrobuff org source ;pointer to macro collection buffer ;begin
ptr_macrobuffer_end:  Ds.l 1                               ;macrobufff org source ;end of above ;end of
macrobase:            Ds.l 1                               ;firstmacro org source ;linked list of macro's ;macrolist
endop:                Ds.l 1                               ;end of program pc - before finishups!
labelbase:            Ds.l 1                               ;firstlabel org source ;first lib struct
end_of_tokenlist:     Ds.l 1                               ;lasttoken org source
numstatic:            Ds.w 1                               ;number of static structs
staticdata:           Ds.l 1                               ;data1 val for statics
libpointer:           Ds.l 1                               ;firstlib org source ;first lib struct
sbasegot:             Ds.w 1                               ;string base got?
litdata1:             Ds.l 1
    ;
    ;Optimization stuff
    ;
objlen:               Ds.l 1
hunkoffsetcounter:    Ds.l 1                               ;numoffs org source
hunkoffsetbase:       Ds.l 1                               ;firstoff org source ;pointer to linked list
                                                           ;of amigados type reloc offsets
flagmask:             Ds.w 1                               ;mask for flag of variable when
                                                           ;searching for it!
notshared:            Ds.w 1                               ;added org source ;flag for seeing if variable was added!
nonew:                Ds.w 1                               ;1 to inhibit new variable creation
temp1:                Ds.l 1
temp2:                Ds.l 1
;    cnop    0,4 org source
namebuffer:           Ds.b 128                             ;namebuff ds.b 128 org source
namebuffer2:          Ds.b 128
                      Ds.b 8 
;-- buffer fuer uselibs
optstuff:             Ds.b 64                              ;temp opt make buffer
Even



.ptr_xtradata:                                             ; optspnts org source ;pointers to options involved in source dependant
                                                           ; stuff
  Dc.w $0001                                               ; data size 1 byte
  Dc.l xtra_versionnumber                                  ; vers org source
  Dc.l set_create_iconfile                                     ; create icon for executable
  Dc.l $00000000 ; end of datablock

  Dc.w $0002                                               ; data size 2 bytes
.jimi0
  Dc.l set_use_debugger
  Dc.l default_obsolete                                    ;+obsolet: ohne inhalt
  Dc.l default_obsolete                                    ;+obsolet: debugger
  Dc.l default_obsolete                                    ;+obsolet: long arrays
  Dc.l default_obsolete                                    ;+obsolet: expand macros
  Dc.l set_FuncOptimize                                    ;+obsolet: was: quoted macros
  Dc.l set_make_smallestcode
  Dc.l set_link_debuginfo
  Dc.l set_autorun
  Dc.l set_interruptcheck
  Dc.l set_assemblercheck
  Dc.l set_overflowcheck
  Dc.l set_create_dbgfile                                  ;+obsolet: ohne inhalt
  Dc.l default_obsolete                                    ;+obsolet: interruptcheck vorgabe
  Dc.l default_obsolete                                    ;+obsolet: overflow vorgabe
.jimi1
  Dc.l $00000000 ; end of datablock

  Dc.w $0004                                               ; data size 4 bytes
.jimi2
bufferlist:                                                ; Maximums Int String Gadgets...
  Dc.l objectbuffer
  Dc.l libsbuffer
  Dc.l systembuffer
  Dc.l databuffer
  Dc.l macrobuffer_size
  Dc.l stringbuffer
.jimi3
  Dc.l $00000000 ; end of datablock
                                                           
  Dc.w $0220                                               ; data size 68*8=544 bytes
  Dc.l residents_table                                     ; Resident Buffer...
  Dc.l $00000000 ; end of datablock

  Dc.w $0180                                               ; data size 2*48=192 bytes
  Dc.l comStr_ExePath                                             ; exepath and exefile
  Dc.l $00000000  

  Ds.w 1
optssave:                                                  ; data size 982 bytes
  Ds.l 63    ;((jimi1-jimi0)/4*2)
  Ds.l 63    ;(jimi3-jimi2)
  Ds.l 63    ;(68*8)
  Ds.w 113   ;(192*2)+2
.ptr_endxtradata


xtra_versionnumber:   Ds.w 1                               ;vers org source


.read_xtrafile:                                            ;load xtrafile, filehandle via PED in D7
  CLR.b comStr_ExeFile

  TST.l d0 : BNE 'l10
    RTS
 'l10

  JSR free_Residents                                       ;jsr freeres2 org source
  JSR Clear_Residents_table                                 ; added for a full clear of the residents table  tomsmart1 2012 08 08
  JSR clear_lastcompileerrordatas                           ; added to fix problems if a residents load error happend  tomsmart1 2016 02 02

  ;-- read xtra datafield
  MOVEA.l _dosbase,A6
  LEA ptr_xtradata,A2
  MOVEQ.l #$00,D4
 'loop
    MOVE.w (A2)+,D4                                        ; anzahl bytes zum lesen
    BEQ.b 'done

   'loop2
      MOVE.l (A2)+,D2
      BEQ.b 'loop
      MOVE.l D4,D3
      MOVE.l D7,D1
      JSR _Read(A6)                                            ; d1: file, d2: buffer, d3:length
    TST.l D0
    BNE.b 'loop2
    BRA.w 'done2                                            ; if no data left, quit loading
 'done        
                                              ; set defaults
  TST.b xtra_versionnumber : BNE.b 'nover0
    MOVE.w #$0080,set_autorun                                ;auto run on
    MOVE.w #$0080,set_interruptcheck                         ;interupt checking on
    MOVE.w #$0000,set_assemblercheck                         ;assembler checking off
    MOVE.w #$0080,set_overflowcheck                          ;overflow chex
    BRA.b 'ver0
 'nover0
    MOVE.l D7,D1                                             ;load cli arg!
    MOVE.l #str_cliarguments,D2
    MOVE.l #116,D3                                           ; vorher 128 , jetzt 8 weniger fuer die Versionsdaten
    JSR _Read(A6)                                            ; d1: file, d2: buffer, d3:length
    MOVE.l #str_cliarguments,A0
    ADDA.l #115,A0
    MOVE.l #0,(a0) ; terminate it!

    MOVE.l D7,D1                                             ; I know, I know. Honitos started this horrible thing, see below...
    MOVE.l #stacksize,D2
    MOVE.l #4,D3
    JSR _Read(A6)
    CMP.l ##MIN_STACKSIZE,stacksize
    BGE 'stackok
      MOVE.l ##MIN_STACKSIZE,stacksize
   'stackok

    MOVE.l D7,D1
    MOVE.l #versioninformation,D2
    MOVE.l #4,D3
    JSR _Read(A6)

    MOVE.l D7,D1
    MOVE.l #number_of_builds,D2
    MOVE.l #4,D3
    JSR _Read(A6)
 'ver0
    ;here, we load in current max settings. done last coz of
    ;unknown number of max's
    ;
    MOVE.l a7,stackaddr                                      ; added to prevent a possible crash in CLIMode if #continue_on_error is set  tomsmart1
    MOVE.l A7,errstack
    MOVE.l #'done2,errcont
    MOVE.w #$FFFF,ezerr

   'dloop
      MOVE.l #temp1,D2                                       ;LOAD maxobjectsvalues
      MOVEQ.l #$04,D3
      MOVE.l D7,D1
      JSR _Read(A6)
      TST.l D0 : BEQ.b 'done2
        MOVE.w temp1,D1
        TST.w d1 : BEQ 'done2                                ;new
          JSR findlibnoerr
          ;BEQ.b 'done2
          CMP.l #0,a1 : BEQ 'dloop
            MOVE.l $12(A1),D0
            MOVE.w temp1+2,-$4(A1,D0.L)
    BRA.b 'dloop
 'done2

  ;-- load in residents
  LEA residents_table(PC),A0
  MOVEQ.l #$07,D0
 'loop3
    CLR.l $40(A0)
    LEA ResidentEntryStep(A0),A0
  DBF D0,'loop3

  MOVEM.l D7/A6,-(A7)
  JSR init_buffers
  JSR reloadresident
  MOVEM.l (A7)+,D7/A6
RTS


.write_xtrafile:                                           ;savextra org source ; D7 = filepointer A6 = dosbase
  MOVE.b #$1,xtra_versionnumber                            ;.xtra version number...

  ;-- write xtradata field
  MOVEA.l _dosbase,A6
  LEA ptr_xtradata,A2
  MOVEQ.l #$00,D4
 'loop
    MOVE.w (A2)+,D4                                        ; number of bytes to write
    BEQ.b 'done

   'loop2
      MOVE.l (A2)+,D2
      BEQ.b 'loop
        MOVE.l D4,D3
        MOVE.l D7,D1                                       ; d7: pointer to filehandle to write to
        JSR _Write(A6)                                     ; d1: file, d2: buffer, d3:length
    BRA.b 'loop2
 'done                    
 
  ;-- write string cliarguments      
  MOVE.l D7,D1
  MOVE.l #str_cliarguments,D2
  MOVE.l #116,D3
  JSR _Write(A6)                                           ; write out cli arguements ...

  ;-- write stacksize
  MOVE.l D7,D1
  MOVE.l #stacksize,D2
  MOVE.l #4,D3
  JSR _Write(A6)

  ;-- write versioninfo
  MOVE.l D7,D1
  MOVE.l #versioninformation,D2
  MOVE.l #4,D3
  JSR _Write(A6)

  ;-- write buildnumber
  MOVE.l D7,D1
  MOVE.l #number_of_builds,D2
  MOVE.l #4,D3
  JSR _Write(A6)

  ;-- write max object numbers for all libs
  ; lib#.w, max.w.
  LEA libpointer,A2
 'loop3
    MOVE.l (A2),D0
    BEQ.w 'done2
      MOVEA.l D0,A2
      MOVE.l 18(A2),D4
      TST.w -$2(A2,D4.L)
      BEQ.w 'loop3
        LEA 4(A2),A0
        MOVE.l A0,D2
        MOVEQ.l #$02,D3
        MOVE.l D7,D1                                           ; schreiben der Libnum mit 2 bytes
        JSR _Write(A6)                                         ; d1: file, d2: buffer, d3:length

        LEA -$4(A2,D4.L),A0
        MOVE.l A0,D2
        MOVEQ.l #$02,D3
        MOVE.l D7,D1                                           ; schreiben der Max Objects mit 2 bytes
        JSR _Write(A6)                                         ; d1: file, d2: buffer, d3:length
  BRA.w 'loop3
 'done2

  ;-- write 4 fill/pad/termination bytes because 
  ;-- the .read_xtrafile routine reads min 4 bytes more as saved, 
  ;-- this was moved from PED extend xtra Data save routine  tomsmart1
  LEA XTRAEndPadBytes,A2 ; get the start address of the 4 fill/pad/termination bytes
  MOVE.l A2,D2           
  MOVE.l #4,D3 
  MOVE.l D7,D1           
  JSR _Write(A6)         
RTS


; reset of the old menu_compileroptions:                                     ;menu4 org source  ;options requester
.BackupXtraData:    ;new tomsmart1
  LEA optssave,A0                      ; backup address
  LEA ptr_xtradata,A1                  ; source address

 'backuploop
  MOVE.w (A1)+,D0                      ; length of data to move
  BEQ.b 'backupdone
    SUBQ.w #1,D0
   'backuploop2
      MOVE.l (A1)+,D1
      BEQ.b 'backuploop
        MOVEA.l D1,A2
        MOVE.w D0,D1
       'backuploop3
          MOVE.b (A2)+,(A0)+
        DBF D1,'backuploop3
    BRA.w 'backuploop2
 'backupdone

  ;MAKE INT GADS!
  LEA bufferlist,A1

 'loop4
    MOVE.l (A1)+,D2
    BEQ.b 'loop4done

    MOVEA.l D2,A0
    MOVE.l (A0),D2
    ADDQ.w #8,A0
    JSR makelong
 BRA.b 'loop4

 'loop4done
  CLR.w state_of_residents                                 ;resident change
  CLR.w maxobject_pos
RTS   ; new tomsmart1


.RestoreXtraData:                                                ;cancel compilersettings
  LEA optssave,A0
  LEA ptr_xtradata,A1

 'restoreloop1
  MOVE.w (A1)+,D0
  BEQ.b 'restoredone
  SUBQ.w #1,D0

  'restoreloop2
    MOVE.l (A1)+,D1
    BEQ.b 'restoreloop1
    MOVEA.l D1,A2
    MOVE.w D0,D1

   'restoreloop3
      MOVE.b (A0)+,(A2)+
  DBF D1,'restoreloop3

 BRA.b 'restoreloop2

 'restoredone
RTS


.FreeClearResidentsForPED               ; added for Compiler settings in PED safty  tomsmart1 2012 06 09
  JSR free_Residents                    ; first free the allready loaded residents
  JSR Clear_Residents_table             ; second clear the complete resident table
RTS


.ReloadResidentsForPED                  ; need for Compiler settings window  tomsmart 2012 03 17
  JSR clear_lastcompileerrordatas       ; added to fix problems if a residents load error happend  tomsmart1 2016 02 02
  MOVE.w #$FFFF,state_of_residents
  MOVE.w state_of_residents,D0
  JSR reloadresident
RTS


; need for compilersettings and .ab3 save(climode)
.getobjectentry:    ; was  a copy of maxit org source
  ; new >
  MOVE.l d0,a1
  ; < new
  MOVEA.l libpointer,A2

 'loop
    MOVE.l 18(A2),D0
    TST.w -$2(A2,D0.L)
     BEQ.w 'next
    SUBQ.w #1,D1
     BPL.w 'next
    ;
    MOVEA.l -$1A(A2,D0.L),A3    ;token offset
    ADDA.l A2,A3

 'tt1
      MOVE.b (A3)+,(A1)+
    BNE.w 'tt1
 ; new >
    CLR.b -(A1)
 ; < new
    MOVE.w -$4(A2,D0.L),D0
 ; new >
    AND.l #$ffff,d0
 RTS
  ; < new

 'next
    MOVEA.l (A2),A2
BRA.w 'loop


; --
; -- compilersetting_datas
; --
; -- configuration data for debugger
; --
str_maxobjects_name:   Dc.b "              ",0 : Even
str_maxobjects_name2:  Dc.b "              ",0 : Even
objectbuffer:          Dc.l #DEFAULT_OBJECTBUFFERSIZE  ; replaced with a constant tomsmart1
                       Dc.l $00000000
str_objectbuffer:      Dc.b "16384",0,0,0,0,0,0,0      ; string max 12 columns

libsbuffer:            Dc.l #DEFAULT_LIBSBUFFERSIZE    ; replaced with a constant tomsmart1
                       Dc.l $00000000
str_libsbuffer:        Dc.b "32768",0,0,0,0,0,0,0      ;was "16384"; string max 12 columns

systembuffer:          Dc.l #DEFAULT_SYSTEMBUFFERSIZE  ; system buffer  ; replaced with a constant tomsmart1
                       Dc.l $00000000
str_systembuffer:      Dc.b "4096",0,0,0,0,0,0,0,0     ; string max 12 columns

databuffer:            Dc.l #DEFAULT_DATABUFFERSIZE    ; data buffer   ; replaced with a constant tomsmart1
                       Dc.l $00000000
str_databuffer:        Dc.b "4096",0,0,0,0,0,0,0,0     ; string max 12 columns

macrobuffer_size:      Dc.l #DEFAULT_MACROBUFFERSIZE   ; macro buffer ; was $00002000 ; replaced with a constant tomsmart1
                       Dc.l $00000000
str_macrobuffer:       Dc.b "40000",0,0,0,0,0,0,0      ; string max 12 columns

stringbuffer:          Dc.l #DEFAULT_STRINGBUFFERSIZE  ; string buffer ; replaced with a constant tomsmart1
                       Dc.l $00000000
str_stringbuffer:      Dc.b "10240",0,0,0,0,0,0,0      ; string max 12 columns

maxobjects_value:      Dc.w $0064
                       Dc.l $00000000
str_maxobjects_value:  Dc.b "100",0,0,0,0,0,0,0,0,0    ; string max 12 columns

maxobjects_value2:     Dc.w $0014
                       Dc.w $0000

str_maxobjects_value2: Dc.b "20",0,0,0,0,0,0,0,0,0,0   ; string max 12 columns

set_create_iconfile:   Dc.w $0080
set_create_dbgfile:    Dc.w $0000
set_link_debuginfo:    Dc.w $0000
set_make_smallestcode: Dc.w $0000
set_FuncOptimize:      Dc.w $0000
set_use_debugger:      Dc.w $0080
set_autorun:           Dc.w $0080
set_interruptcheck:    Dc.w $0080
set_assemblercheck:    Dc.w $0000
set_overflowcheck:     Dc.w $0080

default_obsolete:      Dc.w $0000
Even4


; -------------------------------------------------
residents_table:   ; 544 bytes, 68 bytes je eintrag
  Ds.l 136         ;resident files STEP $44 piece 8
                   ;ResidentEntryStep defined with $44 in common.ab3 for all sources tomsmart1 2012 05 24
residents_table_end:     ; Label added that this memspace can be cleared  tomsmart1 2012 06 08
; -------------------------------------------------

str_calcexpression:        Ds.l 32
destbufferend_backup_calc: Ds.l 1             ; was calclibat
Even


.menu_calculator:         ;calculator
  MOVE.l destbufferend,destbufferend_backup_calc
  ; new >
  MOVE.l a7,stackaddr                         ; added to prevent a possible crash in CLIMode if #continue_on_error is set  tomsmart1
  ; < new
  MOVE.l A7,errstack
  MOVE.l #Calc_Error_Exit,errcont

  ;-- get the flags for the conversion form the editor
  !basic
  !ComData_GetW{comWord_CalculatorButtonBinFlag,D0} : MOVE.w d0,CalculatorButtonBinFlag
  !ComData_GetW{comWord_CalculatorButtonDecFlag,D0} : MOVE.w d0,CalculatorButtonDecFlag
  !asm

  LEA str_calcexpression,A0

  ;-- calculate the expression !!
  JSR setcvars
  JSR setsvars               ; could speedup by unrolling the code here!
  ;
  CLR.w connest             ;no idea...
  LEA str_calcexpression,A5
  JSR evalconst3            ;evaluate constant
  ;
  LEA str_calcexpression,A0
  TST.l D3 : BPL.w 'ispos
    MOVE.b #"-",(A0)+
    NEG.l D3
 'ispos
  CMPI.w #$80,CalculatorButtonDecFlag : BEQ.w 'dec
  MOVEQ.l #$00,D1
  CMPI.w #$80,CalculatorButtonBinFlag : BNE.w 'hex
  ;--
  ;-- convert to bin
  MOVEQ.l #$1F,D0
  MOVE.b #"%",(A0)+
 'bloop
    LSL.l #1,D3 : BCC.w 'bzero
      MOVE.b #"1",(A0)+
      MOVEQ.l #-$01,D1
      BRA.w 'bnext
   'bzero
      TST.w D1 : BEQ.w 'bnext
        MOVE.b #"0",(A0)+
   'bnext
  DBF D0,'bloop
 'bdone
  TST.w D1 : BNE.w 'pc1
    MOVE.b #"0",(A0)+
 'pc1
  CLR.b (A0)
  BRA.w 'pc

  ;--
  ;-- convert to hex
 'hex
  MOVEQ.l #$07,D0
  MOVE.b #"$",(A0)+
 'hloop
    MOVE.l D3,D2
    SWAP D2
    LSR.w #8,D2
    LSR.w #4,D2
    ADDI.w #$30,D2
    CMP.w #$3A,D2 : BCS.w 'hok
      ADDQ.w #7,D2
   'hok
    CMP.w #$30,D2 : BEQ.w 'hzero
      MOVE.b D2,(A0)+
      MOVEQ.l #-$01,D1
      BRA.w 'hnext
   'hzero
    TST.w D1 : BEQ.w 'hnext
      MOVE.b D2,(A0)+
   'hnext
    LSL.l #4,D3
  DBF D0,'hloop
  BRA.w 'bdone

  ;--
  ;-- convert to dec
 'dec
  MOVE.l D3,D2
  JSR makelong          ;to long...
 'pc:

  Calc_Error_Exit:      ; was 'calcerr
  MOVE.l destbufferend_backup_calc,destbufferend
RTS

Even
str_cliarguments: Ds.b 255   ; a command line can acutally be 255 characters long

Even

;.menu_simcliarguments:   ; was menu9                                  ; deactivated becaus is now in PED  tomsmart1
   ;CLI ARGUEMENT
   ;
   ; new >
;   MOVEA.l comdata,A1
;  MOVEA.l $802(A1),A1                                      ; compiler says to PED: openwindow
;  !ComData_GetL{comPtr_CLIArgumentsString,A1}
;  MOVE.l #1001,D0                                          ; set indification for CLIArgs window
;  MOVE.l #str_cliarguments,D1                              ; set pointer for the string
;  JSR (A1)                                                 ; open PED window CLIArgs
;RTS
   ; < new


.skipme:                                                   ;??Looks like double label??
 'l1
    MOVE.b (a5)+,d0
    BEQ 'l2
    CMP.b #$80,d0
    BNE 'l1
    MOVE.b (a5)+,d0
    BEQ 'l2
    CMP.b #$02,d0
  BNE 'l1

 'l3
    CMP.b #" ",(a5)+
  BEQ 'l3
  SUBQ.l #1,a5
  TST.b (a5)
  BEQ 'l2
  CMP.w ##TokenID_Statement,(a5)                        ;$8008
  BEQ 'l4
  CMP.w ##TokenID_Function,(a5)                         ;$8009
  BEQ 'l4
 BRA 'l1

 'l4
  ADDQ.l #2,a5
  JSR skiprest
RTS

 'l2
  JSR nextline
  BNE 'l1
RTS


.compiledate
  !basic
  DateFormat 1
  i999.l = SystemDate
  a$=Date$ (i999)
  a$=Replace$(a$,"/",".")
  GetReg D0,&a$
  MOVEQ #8,d2
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b (a0)+,d0
  !asm
  ADD.l #9,d2
  ADD.l #9,a5
RTS


.compiledate_ger
  !basic
  DateFormat 0
  i999.l = SystemDate
  a$=Date$(i999)
  a$=Replace$(a$,"/",".")
  GetReg D0,&a$
  MOVEQ #8,d2
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b (a0)+,d0
  !asm
  ADD.l #9,d2
  ADD.l #13,a5
RTS


.compiledatedc
  !basic
  DateFormat 1
  i999.l = SystemDate
  a$ = Date$ (i999)
  a$ = Replace$(a$,"/",".")
  GetReg D0,&a$
  MOVEQ #8,d2
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR writebyte
  DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b (a0)+,d0
  !asm
  ADD.l #9,a5
RTS


.compiledatedc_ger
  !basic
  DateFormat 0
  i999.l = SystemDate
  a$=Date$ (i999)
  a$=Replace$(a$,"/",".")
  GetReg D0,&a$
  MOVEQ #8,d2
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR writebyte
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b (a0)+,d0
  !asm
  ADD.l #13,a5
RTS


.version_string:
  MOVE.l d2,-(a7)                                          ; D2 -> stack
  MOVE.l a5,d0
  !basic
  PutReg d0,_myD0.l
  If _myD0
    verstring$ = Left$(Peek.s(_myD0),9+3)
    verstring$ = UnRight$(verstring$,3)                      ; Compilerkonstantenbeginn \__ entfernen
  Else
    error{"INTERNAL: Invalid pointer in version_string!"}
  End If

  ; Version coded as : Majorversion Minorversion Patchlevel
  ;                    00           00           00
  actual_version.l = PeekL(?versioninformation)
  actual_build.l   = PeekL(?number_of_builds)

  Format "00"
  Select verstring$

    Case "VER_MAJOR"
     put_versionstr$ = Str$(actual_version LSR 24)

    Case "VER_MINOR"
     put_versionstr$ = Str$((actual_version LSL 8) LSR 24)

    Case "VER_PATCH"
     put_versionstr$ = Str$((actual_version LSL 16) LSR 24 )

    Case "VER_BUILD"
     Format ""
     put_versionstr$ = Str$(actual_build)

    Default
     put_versionstr$ = "{unknown compilerconstant}"
;    a5add.l = 4

  End Select
  Format ""

  GetReg D0,FLen(put_versionstr$)                              ; laenge zielstring -> Stack
  MOVE.l d0,d2
  MOVE.l d2,-(a7)
  SUB #1,d2

  GetReg D0,&put_versionstr$                                   ; kopieren des neuen Strings in den Zielstring
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
  DBF d2,'l1

  MOVEQ #0,d0
  !asm
  MOVE.l (a7)+,d0                                          ; laenge Zielstring <- Stack
  MOVE.l (a7)+,d2                                          ; d2 <-Stack
  ADD.l d0,d2
  ADD.l #12,a5                                             ; string_ptr um konstante weitersetzen
  MOVEQ #0,d0
RTS


.version_string_dc:
  MOVE.l a5,d0
  !basic
  PutReg d0,_myD0.l
  If _myD0
    verstring$ = Left$(Peek.s(_myD0),9+3)
    verstring$ = UnRight$(verstring$,3)                      ; Compilerkonstantenbeginn \__ entfernen
  Else
    error{"INTERNAL: Invalid pointer in version_string_dc!"}
  End If

  ; Version coded as : Majorversion Minorversion Patchlevel
  ;                    00           00           00
  actual_version.l = PeekL(?versioninformation)
  actual_build.l   = PeekL(?number_of_builds)

  Format ""
  Select verstring$

    Case "VER_MAJOR"
     put_versionstr$ = Str$(actual_version LSR 24)

    Case "VER_MINOR"
     put_versionstr$ = Str$((actual_version LSL 8) LSR 24)

    Case "VER_PATCH"
     put_versionstr$ = Str$((actual_version LSL 16) LSR 24 )

    Case "VER_BUILD"
     Format ""
     put_versionstr$ = Str$(actual_build)

    Default
     put_versionstr$ = "{unknown compilerconstant}"

  End Select
  Format ""

  GetReg D0,FLen(put_versionstr$)-1
  MOVE.l d0,d2

  GetReg D0,&put_versionstr$                                   ; kopieren des neuen Strings in den Zielstring
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR writebyte
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b -(a0),d0                                          ; letztes Zeichen in D0
  !asm
  ADD.l #12,a5                                             ; string_ptr um konstante weitersetzen
RTS


;.insert_functionname:
;; "\\__THIS_FUNCTION
;  MOVE.l d2,-(a7)                                          ; D2 -> stack
;  MOVE.l a5,d0
;  !basic
;  putreg d0, _myD0.l
;  If _myD0
;    constring$ = Left$(Peek.s(_myD0),13 + 3)
;    constring$ = UnRight$(constring$,3)                      ; Compilerkonstantenbeginn \__ entfernen
;  Else
;    error{"INTERNAL: Invalid pointer in insert_functionname!"}
;  End If
;  Select LCase$(constring$)
;
;   Case "this_function"
;    If PeekL(?currentfunction)<>0
;      currentfuncP.l = PeekL(?currentfunction)
;      If currentfuncP
;        condata$ = Peek.s(currentfuncP + 48 + 1)                  ;need change when use
;      Else
;        condata$ = "???"
;        error{"INTERNAL: Invalid pointer in currentfunction!"}
;      End If
;    Else
;      condata$ = "GLOBAL"
;    EndIf
;
;   Default
;    condata$ = constring$
;
;  End Select
;  GetD0 Len(condata$)                                      ; laenge zielstring -> Stack
;  MOVE.l d0,d2
;  MOVE.l d2,-(a7)
;
;  GetD0 &condata$                                          ; kopieren des neuen Strings in den Zielstring
;  MOVE.l d0,a0
;
; 'l1
;    MOVE.b (a0)+,d1
;    JSR pokedata1b
; DBF d2,'l1
;
;  !asm
;  MOVE.l (a7)+,d0                                          ; laenge Zielstring <- Stack
;  MOVE.l (a7)+,d2                                          ; d2 <-Stack
;  ADD.l d0,d2                                              ; eingefuegte chars zu D2 dazu
;  ADD.l #16,a5                                             ; string_ptr um konstante weitersetzen
;RTS
;
;
;.insert_codeline:
;; "\\__codeline
;  MOVE.l d2,-(a7)                                          ; D2 -> stack
;  MOVE.l a5,d0
;  !basic
;  _myD0.l = PutD0
;  If _myD0
;    constring$ = Left$(Peek.s(_myD0),8 + 3)
;    constring$ = UnRight$(constring$,3)                      ; Compilerkonstantenbeginn \__ entfernen
;  Else
;    error{"INTERNAL: Invalid pointer in insert_codeline!"}
;    constring$ = "???"
;  End If
;  Select LCase$(constring$)
;
;   Case "codeline"
;    condata$ = Str$(PeekL(?globallinecount))
;
;   Default
;    condata$ = constring$
;
;  End Select
;
;  GetD0 Len(condata$)                                      ; laenge zielstring -> Stack
;  MOVE.l d0,d2
;  MOVE.l d2,-(a7)
;  SUB #1,d2
;
;  GetD0 &condata$                                          ; kopieren des neuen Strings in den Zielstring
;  MOVE.l d0,a0
;
; 'l1
;    MOVE.b (a0)+,d1
;    JSR pokedata1b
; DBF d2,'l1
;
;  MOVEQ #0,d0
;  !asm
;  MOVE.l (a7)+,d0                                          ; laenge Zielstring <- Stack
;  MOVE.l (a7)+,d2                                          ; d2 <-Stack
;  ADD.l d0,d2
;  ADD.l #11,a5                                             ; string_ptr um konstante weitersetzen
;  MOVEQ #0,d0
;RTS
;
;

.checkcast
  MOVE.l a5,-(a7)
  !fget
  CMP.w #".",d0 : BNE 'skip
    MOVEM.l a2/d2,-(a7)
    LEA newtypebase,a2
    JSR getparameter2 :  BEQ.w JUMP_syntaxerr

    JSR findtype : BNE.w JUMP_notypeerr2

    MOVE.l a2,typetocast
    MOVEM.l (a7)+,a2/d2
    CMP.w #")",d0 : BNE JUMP_errorbracketmiss
    
    ADDQ.l #4,a7
    !fget
    JMP nocast
 'skip
  MOVE.l (a7)+,a5
JMP bracket


JUMP_errorbracketmiss JMP errorbracketmiss


Function.l ab3_GetIncludeLock{filename.s}
  incLock.l  = Lock_(&filename,#ACCESS_READ)   ; try bla.blub
  ex.s       = dos_GetExt{filename}

  ;log2PED{"... searching for  <" + filename + ">..."}

  If incLock = 0
    filename = dos_SetExt{filename,"ab3"}
    incLock  = Lock_(&filename,#ACCESS_READ)   ; try bla.ab3
  End If

  If incLock = 0
    filename = dos_SetExt{filename,"ab2"}
    incLock  = Lock_(&filename,#ACCESS_READ)   ; try bla.ab2
  End If

  If incLock = 0
    filename = dos_SetExt{filename,"bb2"}
    incLock  = Lock_(&filename,#ACCESS_READ)   ; try bla.bb2
  End If

  If incLock = 0
    filename = dos_SetExt{filename,ex + ".ab3"}
    incLock  = Lock_(&filename,#ACCESS_READ)   ; try bla.blub.ab3
  End If

  If incLock = 0
    filename = dos_SetExt{filename,"ab2"}
    incLock  = Lock_(&filename,#ACCESS_READ)   ; try bla.blub.ab2
  End If

  If incLock = 0
    filename = dos_SetExt{filename,"bb2"}
    incLock  = Lock_(&filename,#ACCESS_READ)   ; try bla.blub.bb2
  End If

  Function Return incLock
End Function


.check_incdir:
  !basic
  incString.s = Peek$(?namebuffer)

  ;-- check first, if include is in default Include Directory
  incFile.s = dos_AddPart{config\path_includes, incString}
  incLock.l = ab3_GetIncludeLock{incFile}

  ;-- if not found => check in current source directory
  If incLock = 0
    !ComData_LEA{comStr_SourceDir,D0} : PutReg d0,incDirP.l
    incDir_.s   = Peek.s(incDirP)
    incFile.s   = dos_AddPart{incDir_, incString}
    incLock.l   = ab3_GetIncludeLock{incFile}
  End If

  ;-- if not found => check relative to current source
  If incLock = 0
    incDepth.l = PeekW(?ininclude) - 1
    If incDepth >= 0 AND incDepth < #maxincludes
      incDir_.s = dos_PathPart{ incdim(incDepth) }
      incFile.s = dos_AddPart{incDir_, incString}
      incLock.l = ab3_GetIncludeLock{incFile}
    End If
  End If

  ;-- if still not found => check default Include Directory but without fileextention
  If incLock = 0
    incFile.s = dos_AddPart{config\path_includes, dos_FilePart{incString}}
    incLock.l = ab3_GetIncludeLock{incFile}
  End If

  If incLock <> 0
    MaxLen incFile = 1024
    NameFromLock_ incLock, &incFile, 1024
    UnLock_ incLock
  
    incFile = Peek.s(&incFile)
    Poke$ ?namebuffer,incFile
  
    il.b = FLen(incFile) : GetReg d0,il : MOVE.l d0,incfilenamelength
  End If

  !asm

  TST.l incfilenamelength : BEQ 'l1
    MOVE.l incfilenamelength,d2
 'l1
RTS


.check_IncBinDir:
  !basic
  incString.s = Peek$(?namebuffer)
  
  !ComData_LEA{comStr_SourceDir,D0} : PutReg d0,incDirP.l
  incDir_.s   = Peek.s(incDirP)
  incFile.s   = dos_AddPart{incDir_,incString}
  incLock.l   = Lock_(&incFile,#ACCESS_READ)

  If incLock = False                                        ; not found => try orignal string only to find
    incLock.l = Lock_(&incString,#ACCESS_READ)
  End If

  If incLock                                                ; found => store full path
    MaxLen incFile = 1024
    NameFromLock_ incLock,&incFile,1024
    incFile = Peek.s(&incFile)
    Poke$ ?namebuffer,incFile
  End If

  GetReg d0,incLock
  !asm
RTS


.gotoendsource
  JSR Aclearallvars

  JSR free_unusedfunctions

  ; MOVE.l stackaddr,a7
  MOVE.l #"NORE",reqmode
  JSR handle_compileerror

 .linemessage
  MOVE.l d0,-(a7)
  MOVE.l a5,d0
  !basica7
  PutReg d0,i.l
  If i
    a$ = Peek$(i)
    b$ = Peeks$(i-7,7)
    ;i = Request(!TRANS{"Do workaround ?"},b$ + a$,!TRANS{"Yes|No"})
    i = ask{!TRANS{"Do workaround ?"} + "\\n" + b$ + a$,!TRANS{"Yes|No"},!TRANS{"Info"} }    ; replaced it with a error.include function  tomsmart1
    MOVE.l d0,result
  End If
  !asma7
  MOVE.l (a7)+,d0
RTS


.check_of_same_source:
  !basic
  !ComData_LEA{comStr_SourceDir,D0} : PutReg d0,currentDirP.l
  !ComData_LEA{comStr_SourceName,D0} : PutReg d0,fileNameP.l

  check_dirname$  = Peek$(currentDirP)
  check_filename$ = Peek$(fileNameP)
  If (olddirname$ <> check_dirname$) OR (oldfilename$ <> check_filename$)
    JSR free_unusedfunctions
  End If
  olddirname$ = Peek$(check_dirname$)
  oldfilename$ = Peek$(check_filename$)
  For i = 0 To #maxincludes-1
    incline(i) = 0
  Next
  !asm
RTS


.addimmi
  MOVEQ #0,d1

 'l1
    MOVE.b (a5)+,d0 : BEQ 'er1
    CMP.b #" ",d0 : BEQ 'l1
    
    ADDQ #1,d1
  CMP.b #$22,d0 : BNE 'l1         ;'"'
RTS
'er1 : JMP syntaxerr



erro1t   Dc.b "Only one BSS / Chip Segment allowed",0 : Even
nodata   Dc.b "BSS Segment contains no Data!",0       : Even
Even


.bssseg
  TST.b exdebug : BNE 'l10
    MOVE.l ##opcode_NOP,d1 : JSR writeword
    MOVE.l destpointer,d0
    MOVE.l d0,d1
    ADDQ.l #3,d1
    AND.l #$fffffffc,d1
    MOVE.l d1,destpointer
    SUB.l destpointer,d0 : BEQ 'lnf1
    CMP.l #-1,bssstart  : BNE 'lnf1
    CMP.l #-1,chipstart : BNE 'lnf1
    MOVE.l destpointer,a4
    TST.w dontwrite_nomemleft : BNE 'lnf1
      MOVE.w ##opcode_NOP,-2(a4)
   'lnf1
  
    CMP.l #-1,bssstart : BEQ 'l11
      MOVE.l #erro1t,-(a7)
      JMP handle_compileerror
   'l11
  
    MOVE.l destpointer,bssstart
    MOVE.b #1,bssmode
  
   'x2
    TST.b chipmode : BEQ 'l10
      MOVE.l destpointer,chipend
      CLR.b chipmode
 'l10
  JSR get1bytemain
RTS


.chipseg:
  TST.b exdebug : BNE 'x1
    MOVE.l destpointer,d0
    MOVE.l d0,realbssend
    MOVE.l ##opcode_NOP,d1 : JSR writeword
    MOVE.l destpointer,d0
    MOVE.l d0,d1
    ADDQ.l #3,d1
    AND.l #$fffffffc,d1
    MOVE.l d1,destpointer
    SUB.l destpointer,d0 : BEQ 'lnf1
      MOVE.l destpointer,a4
      CMP.l #-1,bssstart : BNE 'lnf1
      CMP.l #-1,chipstart : BNE 'lnf1
      TST.w dontwrite_nomemleft : BNE 'lnf1
      MOVE.w ##opcode_NOP,-2(a4)
   'lnf1
    TST.b bssmode : BEQ 'l10
      MOVE.l destpointer,bssend
      CLR.b bssmode
   'l10
    ;addq.l #3,destpointer
    ;and.l #$fffffffc,destpointer
    CMP.l #-1,chipstart : BEQ 'l11
      MOVE.l #erro1t,-(a7)
      JMP handle_compileerror
   'l11
    MOVE.l destpointer,chipstart
    MOVE.b #1,chipmode
 'x1
  JSR get1bytemain
RTS


.store_includeName:
  !regs2stack
  !basic
  i.l = PeekW(?ininclude)
  If i>=0 AND i < #maxincludes
    incdim (i) = Peek.s(?includetemp2)
    incline(i) = PeekL(?includeline)

    If PeekW(?pass) = 0 Then log2PED{ "Include \\22" + incdim(i) + "\\22...",4}
  Else
    log2PED{ "WARNING, maxincludes reached!!"}
  End If
  !asm
  !stack2regs
RTS


.remove_includename:
  !basic
  i.l = PeekW(?ininclude)
  
  If i >= 0 AND i < #maxincludes
    ;log2PED{"include closed: " + incdim (i)}

    incdim (i) = ""
    incline(i) = 0
    If i > 0 Then PokeL (?includeline),incline(i-1) + 1
  End If
  !asm
RTS


.replacelib:
  LEA replacedat,a0
  Dc.w $3181,$0A00                                         ;MOVE.w d1,0(a0,d0.l*2)
RTS


.writeinit:
  TST.b optimize_fpu :  BEQ 'l1
 'l1
  MOVE.l destpointer,newinitaddr
  JSR writeword
  JSR writelong
RTS


.stripspaces: ; moves string pointer in A5 ahead until the first char is detected
 'll21
  TST.b (a5) : BEQ.s 'll20
   
    CMP.b #" ",(a5) : BNE.s 'll10
      ADDQ.l #1,a5
      BRA.s 'll21
   'll10

    CMP.b #";",(a5) : BNE.s 'll20
     'll25
        TST.b (a5)+ : BEQ.s 'll23
      BRA.s 'll25
     'll23
      SUBQ.l #1,a5
 'll20
RTS


.findconstant2:
  MOVEM.l a2/d2,-(a7)
  MOVEQ #0,d2
  LEA namebuffer,a0
  LEA chartab,a2

 fc2
  MOVE.b (a5),d0
  TST.b 0(a2,d0)
  BNE 'l10
  ADDQ.l #1,a5
  MOVE.b d0,(a0)+
  ADDQ.l #1,d2
 BRA fc2

 'l10
  CLR.b (a0)+
  JSR findlabel2
  MOVE.l a2,a0
  MOVEM.l (a7)+,a2/d2
RTS


.error:
  TST.l d0 : BNE 'l10           ; syntax
    MOVE.l #syntax_,-(a7)
    JMP handle_compileerror
 'l10
  CMP.l #1,d0 : BNE 'l20        ; overflow
    MOVE.l #overflow,-(a7)
    JMP handle_compileerror
 'l20
  ADD.l a2,d0
  MOVE.l d0,-(a7)
JMP handle_compileerror


;************************** don't scatter end             jumptable for fpulib
.functionsbase:
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP Atokejsr                                             ;-84
  JMP writeinit                                            ;-78
  JMP macroexecute                                         ;-72
  JMP findnext                                             ;-66
  JMP replacelib                                           ;-60
  JMP findconstant2                                        ;-54
  JMP findchar                                             ;-48 char in d1
  JMP stripspaces                                          ;-42
  JMP calc                                                 ;-36 
  JMP error                                                ;-30 d0 errortext
  JMP writelong                                            ;-24 d1 value
  JMP writeword                                            ;-18 d1 value
  JMP writebyte                                            ;-12 d1 value
  JMP exit                                                 ;-6


.pluginbase
  destpointer:       Ds.l 1                                ; was "pc" org source
  optimize_integer:  Dc.w 0                                ; optimize 1 = INTEGER
  optimize_fpu:      Dc.w 0                                ; optimize 2 = FPU
  optimize_newsyntax:Dc.w 0                                ; optimize 4 = newsyntax
  optimize_jumps:    Dc.w 0
  ;******************** don't scatter end


  optistring         Dc.b 0
  optistring2        Dc.b 0
  optiarray          Dc.b 0
  quickadd           Dc.b 0
  newmode            Dc.w 0
  mode               Dc.w 0
  string1            Dc.w 0
  load_var_size      Dc.w 0
  load_var_reg       Dc.w 0
  load_var_addr      Dc.l 0
  imm_size           Dc.w 0
  imm_reg            Dc.w 0
  imm_addr           Dc.l 0
  iee                Dc.b 0
  _dcb               Dc.b 0
  nohunkoffset       Dc.l 0

;-- data for ted
teddata:             Dc.l tokens                                                                ; 0 .. 3
                     Dc.l read_xtrafile                                                         ; 4 .. 11
                     Dc.l write_xtrafile                                                        ; 8 .. 15
                     Dc.l call_menuentry                                                        ; 12
                     Dc.b ":"                                                                   ; 16
                     Dc.b 34                                                                    ; 17
                     Dc.b "."                                                                   ; 18
                     Dc.b ";"                                                                   ; 19
                     Dc.l newtypebase                                                           ; 24 .. 35
realconstbase:       Dc.l labelbase                                                             ; 28 .. 39
                     Dc.l macrobase
ptr_deflibfilename:  Dc.l 0                                                                 ; 32 .. 43
ptr_incdirname:      Dc.l 0                                                                 ; 36 .. 47
                     Dc.l 0
                     Dc.l 0

_return         RTS
                Dc.b 0
chartab2        Ds.l 256
codeend         Dc.l 0
hunkoffsetnum   Dc.l 0
chipsize        Dc.l 0
bsssize         Dc.l 0
bssstart        Dc.l -1
bssend          Dc.l -1
chipstart       Dc.l -1
chipend         Dc.l -1
bssmode         Dc.b 0
chipmode        Dc.b 0
newhunk         Dc.b 0
bssnum          Dc.l 0
chipnum         Dc.l 0
lastinstruction Dc.l 0
lastinstructionaddr Dc.l 0

;--------- hunk headers for executable file
; HUNKS:  CODE, RELOC32 
tsthead:        Dc.l $000003F3   ; HUNK_HEADER
                Dc.l $00000000   ; num of resident libraries, shall be zero
                Dc.l $00000001   ; number of segments in binary
                Dc.l $00000000   ; first segment to load
                Dc.l $00000000   ; last segment to load (inclusive)
tstsize1:       Dc.l $00000100   ; size of segment 0
                Dc.l $000003E9   ; HUNK_CODE, A hunk describing a segment of code and constant data
tstsize2:       Dc.l $00000100   ; size of code hunk in longwords 
tstend:         Dc.l $000003EC   ; HUNK_RELOC32, A hunk containing relocation information
tstsize3:       Dc.l $00000000   ; number of offsets in this table
                Dc.l $00000000   ; segment number the relocs are used on (0)
tstdone:        Dc.l $000003F2   ; HUNK_END, terminate a segment

; HUNKS:  CODE, BSS
hunkbegin       Dc.l $000003F3  ; HUNK_HEADER
                Dc.l $00000000
                Dc.l $00000002  ; number of segments in binary
                Dc.l $00000000
                Dc.l $00000001  ; last segment to load (inclusive) 
tstsize1b:      Dc.l $00000000  ; size of hunk 0
bsssize2        Dc.l $00000001  ; size of hunk 1
                Dc.l $000003E9  ; HUNK_CODE
tstsize2b:      Dc.l $00000100  ; size of code hunk in longwords

; HUNKS:  CODE, BSS, DATA
hunkbegin2      Dc.l $000003F3  ; HUNK_HEADER
                Dc.l $00000000
                Dc.l $00000003  ; number of segments in binary
                Dc.l $00000000
                Dc.l $00000002  ; last segment to load (inclusive) 
tstsize1c:      Dc.l $00000000  ; size of hunk 0
bsssize3        Dc.l $00000001  ; size of hunk 1
chipsize2       Dc.l $00000001  ; size of hunk 2
                Dc.l $000003e9  ; HUNK_CODE
tstsize2c       Dc.l $00000000

hunkend         Dc.l $000003f2  ; HUNK_END 
                Dc.l $000003eb  ; HUNK_BSS
                Dc.l $00000000
                Dc.l $000003f2  ; HUNK_END 

hunkend2        Dc.l $000003f2  ; HUNK_END 
                Dc.l $000003ea  ; HUNK_DATA
                Dc.l $00000000
                Dc.l $000003f2  ; HUNK_END 
;--------- end of hunk header for executable file
sysdebug:       Dc.l $000003F0  ; HUNK_DEBUG

;-- data for debug information to link to executable
strcpy          Dc.b "strcpy",0
strcmp          Dc.b "strcmp",0
strvar          Dc.b "strvar",0
qmul            Dc.b "qmul",0
qdiv            Dc.b "qdiv",0
_MaxLen         Dc.b "maxlen",0
notf            Dc.b "????",0

errtextnoreg    Dc.b "Only reg addressing mode supported",0
fpuerr          Dc.b "Instruction not yet supported by 68K FPU ",0
cmplxerr        Dc.b "Formula too complex for 68K FPU or too much regload register used",0 : Even
peeksize        Dc.w 0

mainstart       Dc.l 0
infunctioncode  Dc.b 0
regnumstore     Dc.w 0
                Dc.b "$VER: AmiBlitz3 \\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH (\\__DATE_GER__) Build \\__VER_BUILD",0 : Even
testcode        Dc.b "print i",0
                Ds.b 100
devo            Dc.b "developobject",0 : Even
autostorename   Dc.b "__autoconstantnum",0
_include        Dc.b "__include",0
_debug          Dc.b "__debug",0
unusedfunc      Dc.l 0
Even

.errorstringparse: ; (A0 -> d0; A5 -> d1)
  MOVEM.l a0/a5,-(a7)
  MOVE.l A0,D0
  MOVE.l A5,D1
  !basic
  PutReg D0,*errorstring.l
  PutReg D1,*errorcause1.l
  MOVE.l lastsourcepos,A0 : SUBQ.l #1,a0 : MOVE.l A0,D0 : PutReg D0,*errorcause2.l

  MaxLen detokenline.s = #MAX_Columns + 1
  !ComData_GetL{comPtr_PreProcessor,include_preprocessor}
  *tn.preprocessor = PeekL(?include_preprocessor)

  If *errorstring Then error_type.s   = Peek.s(*errorstring) Else error_type.s = ""
  If *errorcause1 Then error_cause1.s = Peek.s(*errorcause1) Else error_cause1.s = ""
  If *errorcause2 
    written.l = preproc_DetokenizeLine{*tn,*errorcause2,&detokenline}
    If written > 0 Then PokeB &detokenline + written,0
    If written > 40 Then Poke.s &detokenline + 36, "..."   ; added to limit the width of the error requester  tomsmart1
    error_cause2.s = Peek.s(&detokenline)
  Else
    error_cause2.s = ""
  EndIf

  error_line.s = Str$(PeekL(?compilelinecounter) + 1)
  error_code.s = Str$(PeekL(?compileErrorCode))
  error_lineptr.s = "$" + Hex$(PeekL(?sourceline))

  If PeekL(?compileErrorCode) = 1
    errtok.s = "$" + Peek.s(?tokerrnum)
    errlibnum.w = Vallong(errtok) LSR 7
    error_libnum.s = Str$(errlibnum)
  EndIf

  If PeekL (?beforeparameterfetch)
    written.l = preproc_DetokenizeLine{*tn,PeekL (?beforeparameterfetch),&detokenline}
    If written > 0 Then PokeB &detokenline + written,0
    If written > 40 Then Poke.s &detokenline + 36, "..."   ; added to limit the width of the error requester  tomsmart1
    error_source.s = Peek.s(&detokenline)
  Else
    error_source = "NULL"
  End If
  error_myline.s = "$" + Hex$(PeekL(?macroline))
  !asm
  MOVEM.l (a7)+,a0/a5
RTS


.stdout_error:
  MOVE.l a0,-(a7)
  !basic
  If PeekW (?ininclude) > 0
    Poke.s (?includetemp2),incdim(PeekW(?ininclude)-1)
    errorline.l = PeekL(?includeline);-1
    PokeL ?compilelinecounter,PeekL(?includeline) - 1
    errorfile.s = Peek.s(?includetemp2)
  Else
    Poke.s (?includetemp2),Peek.s(?namebuffer)
    errorline.l = PeekL(?compilelinecounter) + 1
    errorfile.s = cli_sourcefile
  End If

  If error_type <> ""
    errortext.s = !TRANS{Replace$(error_type,"\\0a","\n")}
    errortext.s = Replace$(errortext,"\n","\\0a")
  Else
    errortext.s = "???"
  End If

  ;-- cli output
  NPrint "\\1b[1m",!TRANS{"Compiler Error"}," #",PeekL(?errorcounter)," in <",errorfile,">\\1b[0m: "
  NPrint "Line ",errorline,": ",error_type.s
  If error_source<>"NULL" Then NPrint "  --> ", error_source.s
  !asm
  MOVE.l (a7)+,a0
RTS


.save_errorfile:
  MOVE.l a0,-(a7)
  ;MOVE.l a0,d0                                             ;error string
  ;MOVE.l a5,a0                                             ;current sourceline
  !basic
  fid.l = file_Open{dos_AddPart{config\path_system,"ab_compileerror.txt"},#file_forcewrite}
  If fid <> -1
    file_WriteLine{fid,"ERROR  :" + error_type}
    file_WriteLine{fid,"ERRCODE:" + error_code}
    file_WriteLine{fid,"LINE   :" + error_line}
    file_WriteLine{fid,"LINEPTR:" + error_lineptr}
    file_WriteLine{fid,"CAUSE1 :" + error_cause1}
    file_WriteLine{fid,"CAUSE2 :" + error_cause2}
    file_WriteLine{fid,"SOURCE :" + error_source}
    file_WriteLine{fid,"LIBNUM :" + error_libnum}

    If PeekW (?ininclude) > 0
      Poke$ ?includetemp2,incdim(PeekW(?ininclude)-1)
    Else
      Poke$ ?includetemp2,""
    End If
    a$ = Peek$(?includetemp2)
    If a$
      file_WriteLine{fid,"INCLUDE:" + a$}
      file_WriteLine{fid,"INCLINE:" + Str$(PeekL(?includeline))}
      PokeL ?compilelinecounter,PeekL(?includeline) - 1
    Else
      file_WriteLine{fid,"INCLUDE:" + "none"}
      file_WriteLine{fid,"INCLINE:" + "none"}
    End If

    file_WriteLine{fid,"MYLINE :" + error_myline}
    file_WriteLine{fid,Str$(PeekL(?globallinecount))+" line(s) compiled"}
    file_WriteLine{fid,Hex$(PeekW(?globalvarpointer))+" global var base"}

    file_Close{fid}
  End If
  !asm
  MOVE.l (a7)+,a0
RTS

 
.update_progressbar:
  !regs2stack
  !basic
  PutReg d0, progress.l
  calcpro        = (progress * 100) / 100 + 1
  pass.l         = PeekW(?pass) + 1                          ; added +1 so the shown status info begin with 1 instead of 0  tomsmart1
  typ.l          = PeekW(?compiler_job)

  If (pass><pass_old) OR (typ><typ_old)

    If pass_old><pass
      passtatusstr.s = !TRANS{"Pass"} + " " + Str$(pass) + "..."
      log2PED{passtatusstr, 2}
    End If

    pass_old = pass
    typ_old  = typ
    update_comstatus_gui = True

    If typ = 0
      comBaseStatus = !TRANS{"Pass"} + " " + Str$(pass) + ": " + !TRANS{"Compiling Sources ..."}
      calcpro = 0                                             ; set gauge to 0
    End If
    If typ = 1
      comBaseStatus = !TRANS{"Pass"} + " " + Str$(pass) + ": " + !TRANS{"Building Executable ..."}
      calcpro = 0                                             ; set gauge to 0
    End If
  End If

  If (calcpro >< calcpro_old)
    log2PED{Str$(calcpro) + "% compiled...",5}
    calcpro_old = calcpro
    update_comstatus_gui = True
  EndIf

  If PeekW(?ininclude) > 0
    comMessage.s = " (" + dos_FilePart{incdim(PeekW(?ininclude)-1)} + ")"
    If comMessage <> ocomMessage.s
      ocomMessage = comMessage
      update_comstatus_gui = True
    EndIf
  Else
    If comMessage <> ""
      comMessage = ""
      update_comstatus_gui = True
    EndIf
  EndIf

  If update_comstatus_gui = True                                     ; check if a update of the gui nessecary
    comstatusstr = comBaseStatus + comMessage
    ;log2PED{comstatusstr, 3}
    !asm
    !ComData_JSR{comFunc_UpdateCompileStatusWin}          ; jsr to the gui updateroutine  tomsmart1 2012 05 12 ;no extra check needed for CLImode because without PED the function only has a RTS
    !basic
    update_comstatus_gui  = False                         ; because we update the gui
  EndIf
  !asm
  !stack2regs
RTS


;need for compilersettings and .ab3 save.(climode)
.storemaxobjects                                           ;was menu4c, and is no only a part of it
  MOVE.w maxobject_pos,D5                                  ;max objects 1. visible
  LEA maxobjects_value,A3                                  ;current value
  MOVEA.l libpointer,A2

 'ugwl
  CMPA.w #$0,A2
  BEQ.w 'igot
  MOVEA.l A2,A1
  ADDA.l $12(A1),A1
  TST.w -$2(A1)
  BEQ.w 'ugwl2
  SUBQ.w #1,D5
  BMI.w 'ugw2

 'ugwl2
  MOVEA.l (A2),A2
 BRA.w 'ugwl

 'ugw2
  MOVE.w (A3),-$4(A1)

 'igot
RTS


.do_LastRunErrsMode:
  MOVE.w debugnest,d0
  LEA storedebugmode, a0
  MOVE.b 0(a0,d0.w),debugmode
  
  TST.w debugnest : BEQ JUMP_unpairrunerrs

  SUBQ.w #1,debugnest
RTS

.do_honitos:
  !regs2stack
  !basic
  error{"hallo honitos!"}
  !asm
  !stack2regs
RTS


JUMP_runerrsoverflow JMP runerrsoverflow
JUMP_unpairrunerrs   JMP unpairrunerrs



.menu_dummyfunc:
  !basic
  error{!TRANS{"Invalid AmiBlitz3 menu item called!"} }
  !asm
RTS


.do_runerrson:
  TST.w set_use_debugger : BNE 'debugon
    CLR.w debugmode
    BRA.b 'debugoff
 'debugon
    SNE debugmode
    ;!regs2stack
    ;!basic
    ;log2PED{"Debugger turned on"}
    ;!asm
    ;!stack2regs
 'debugoff
RTS


.do_runerrsoff:
  ADDQ.w #1,debugnest
  MOVE.w debugnest,d0
  CMP.w #18,d0 : BGE JUMP_runerrsoverflow

  LEA storedebugmode, a0
  MOVE.b debugmode,0( a0,d0.w)

  SF debugmode

  ;!regs2stack
  ;!basic
  ;log2PED{"Debugger turned off"}
  ;!asm
  ;!stack2regs
RTS


usedpath:  Ds.l 32


.do_USEPATH:
  BEQ.w JUMP_syntaxerr

  LEA lastpath,A0
  MOVEM.l a0-a1/d0,-(a7)
  LEA lastpath2,a1
 'l2
    MOVE.b (a0)+,(a1)+
  BNE 'l2
  MOVEM.l (a7)+,a0-a1/d0

  LEA usedpath(PC),A0
  MOVEM.l a0-a1/d0,-(a7)
  LEA lastpath,a1
 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1
  MOVEM.l (a7)+,a0-a1/d0


 'loop
    TST.w D0 : BMI.w JUMP_syntaxerr

    MOVE.b D0,(A0)+
    BSR.w JUMP_get1bytemain
  BNE.w 'loop
  MOVE.b #$2,(A0)
RTS


.do_usepath2:                            ; copy of do_USEPATH  this is more original
  BEQ.w JUMP_syntaxerr
  LEA path2,A0
  ; new >
;  MOVEM.l a0-a1/d0,-(a7)
;  LEA lastpath,a1

; 'l1
;  MOVE.b (a0)+,(a1)+
;  BNE 'l1
;  MOVEM.l (a7)+,a0-a1/d0
   ; < new

 'loop
    TST.w D0 : BMI.w JUMP_syntaxerr
    MOVE.b D0,(A0)+
    BSR.w JUMP_get1bytemain
  BNE.w 'loop
  MOVE.b #$2,(A0)
RTS

.do_regsave:
  MOVE.l #$f22d6780,fpucodeglobal
  MOVE.l #$f22c6780,fpucodelocal
  LEA regtable,a0
  MOVE.l #7,maxregs

 'again
    MOVE.l (a0),d0 :  BEQ 'e1

    CLR.l (a0)
    MOVE.w 4(a0),d0
    MOVE.l fpucodeglobal,fpucode
    TST.w 6(a0)
    BEQ 'glob
      MOVE.l fpucodelocal,fpucode
   'glob
    MOVE.l fpucode,d1
    JSR writelong
    SUB.l #$80,fpucodelocal
    SUB.l #$80,fpucodeglobal
    MOVE.w d0,d1
    JSR writeword
    ADDQ #8,a0
  BRA 'again
 'e1
RTS

JUMP_errormsg_reg: JMP errormsg_reg
JUMP_notypeerr2 JMP notypeerr
JUMP_illtypeerr JMP illtypeerr

.do_regload:
  MOVE.l #$f22d4780,fpucodeglobal
  MOVE.l #$f22c4780,fpucodelocal
  LEA regtable,a0
  TST.l (a0) : BNE JUMP_errormsg_reg

  MOVE.l d7,-(a7)
  SUBQ.l #1,a5

 'l2
  JSR getparameter2 : BEQ.w 'nopar
  MOVE.w d0,lastchar
  JSR findvariable :  BNE 'islocal
  MOVE.l fpucodeglobal,fpucode
  MOVE.l #3,maxregs
  MOVEQ #0,d7

 'go
  CMP.l #newtype_float,$a(a2)  :   BEQ 'doit                              ;is float type
    CMP.l #newtype_double,$a(a2) :   BNE JUMP_illtypeerr
 'doit
  LEA regtable,a0
  MOVEQ #0,d0

 'loop
    TST.l (a0)   :   BEQ 'store
      ADDQ.l #4,d0
      ADDQ.l #8,a0
      CMP.l #16,d0 :   BCS 'loop
      MOVE.l #2,maxregs
      CMP.l #20,d0 :   BCS 'loop
      MOVE.l #1,maxregs
      CMP.l #24,d0 :   BCS 'loop
      JMP toovarerr
 'store

  TST.b optimize_fpu :   BEQ 'nofpu
    MOVE.l a2,(a0)
    MOVE.w 4(a2),4(a0)
    MOVE.w d7,6(a0)
    MOVE.l fpucode,d1
    SUB.l #$80,fpucodeglobal
    SUB.l #$80,fpucodelocal
    JSR writelong
    MOVE.w 4(a2),d1
    JSR writeword
 'nofpu

  MOVE.w lastchar,d0
  CMP.w #":",d0 : BEQ 'nopar
  TST.w d0      : BEQ 'nopar
  CMP.w #",",d0 : BNE JUMP_syntaxerr
  BRA 'l2
 'nopar
    MOVE.l (a7)+,d7
    RTS

 'islocal
  MOVEQ #1,d7
  MOVE.b #1,newvariable
  LEA firstlocal,a2
  JSR findvariable
  CLR.b newvariable
  CMP.l #-1,d0
  BEQ.w JUMP_notypeerr2
  MOVE.l fpucodelocal,fpucode
  BRA 'go

 _extb                                                     ;020 instr extb
  CMP.b #".",d0 : BNE 'l1
    BSR JUMP_get1bytemain
    BSR JUMP_get1bytemain
 'l1
  ORI .b #" ",d0
  CMP.b #"d",d0 : BNE JUMP_illeaerr

  BSR JUMP_get1bytemain
  SUB.b #$30,d0
  CMP.b #$7,d0 : BGT JUMP_syntaxerr

  MOVE.w #$49c0,d1
  ADD.b d0,d1
  JSR writeword
  BSR JUMP_get1bytemain
RTS


.do_uselastpath
  LEA lastpath,a0
  LEA usedpath(PC),A1

 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1

  LEA lastpath2,a0
  LEA lastpath,A1

 'l2
    MOVE.b (a0)+,(a1)+
  BNE 'l2
RTS


.do_Object:
  TST.b objectcount : BEQ 'l2a
    JMP macnesterr
 'l2a
  LEA devo,a0
  ADDQ.b #1,objectcount
  MOVEM.l a1/d2,-(a7)
  LEA namebuffer,a1
 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1

  MOVEQ #13,d2 : JSR findlabel2 : BNE 'd
    TST.l 8(a2) : BEQ 'd
      SUBQ.b #1,objectcount
      MOVEM.l (a7)+,a1/d2
      JSR skiprest
      MOVE.b #1,developobject
      RTS
 'd
  MOVEM.l (a7)+,a1/d2
  MOVE.b #1,resdisable

 'l2
  CLR.b developobject
JMP do_Macro


JUMP_illeaerr: JMP illeaerr


.do_SYNTAX:
  CLR.b typecheck
  CLR.b declare
  CLR.b declare2

  SUB.b #$30,d0
  BTST #0,d0 : BEQ 'l1
    MOVE.b #1,declare
 'l1
  BTST #1,d0 : BEQ 'l2
    MOVE.b #1,declare2
 'l2
  BTST #2,d0 : BEQ 'l3
    MOVE.b #1,typecheck
 'l3
  BSR.w JUMP_get1bytemain
RTS

JUMP_get1bytemain JMP get1bytemain


.Clear_Residents_table:
  !basic
  ;clear Residents_Table (fill with 0)  tomsmart1 2012 06 08
  MemCls ?residents_table,?residents_table_end-?residents_table,0
  !asm
Return


.check_newconstants:
;  !regs2stack
  MOVE.l d2,-(a7)                                          ; D2 -> stack
  ADDQ #1,a5
  MOVE.l a5,-(a7)
  !basic
  MOVE.l (a7)+,d0 : PutReg d0, _myD0.l
  If _myD0
    newconst$ = UCase$(Peek.s(_myD0))
  Else
    error{"INTERNAL: invalid pointer in check_newconstants!"}
    nwconst$="xxx"
  End If
  condata$ = ""
  PokeB ?skip_bytes,0
  If Left$(newconst$,2) = "__"
    Select Mid$(newconst$,3,4)

     Case "DATE"
      Select Mid$(newconst$,3,6)
      Case "DATE__" : DateFormat 1 : PokeB ?skip_bytes,8
      Case "DATE_G" : DateFormat 0 : PokeB ?skip_bytes,12
      End Select
      i.l=SystemDate
      condata$ = Date$ (i)
      condata$ = Replace$(condata$,"/",".")

     Case "VER_"
      ; Version coded as : Majorversion Minorversion Patchlevel
      ;                    00           00           00
      actual_version.l = PeekL(?versioninformation)
      actual_build.l   = PeekL(?number_of_builds)

      Format ""
      Select Mid$(newconst$,3,9)

       Case "VER_MAJOR"
        condata$ = Str$(actual_version LSR 24)

       Case "VER_MINOR"
        condata$ = Str$((actual_version LSL 8) LSR 24)

       Case "VER_PATCH"
        condata$ = Str$((actual_version LSL 16) LSR 24 )

       Case "VER_BUILD"
        Format ""
        condata$ = Str$(actual_build)

       Default
        condata$ = "{unknown compiler constant}"

      End Select
      Format ""
      PokeB ?skip_bytes,11

     Case "THIS"
      Select Mid$(newconst$,3,9)

       Case "THIS_FUNC"
        PokeB ?skip_bytes,15
        If PeekL(?currentfunction)<>0
          condata$ = Peek.s(PeekL(?currentfunction) + 32 + #funcentry_extend + 1)
        Else
          condata$ = "GLOBAL"
        EndIf

       Case "THIS_INCL"
        PokeB ?skip_bytes,14
        If PeekL(?includetemp2)<>0
          condata$ = dos_FilePart{Peek$(?includetemp2)}
        EndIf

       Case "THIS_POIN"
        PokeB ?skip_bytes,14
        If PeekL(?currentfunction)<>0
          condata$ = Hex$(PeekL(?currentfunction))
        EndIf

      End Select

     Case "CODE"
      PokeB ?skip_bytes,10
      If Mid$(newconst$,3,8) = "CODELINE"
        condata$ = Str$(PeekL(?globallinecount))
      EndIf

    End Select

  Else
    Select Left$(newconst$,1)

     Case "R"
      PokeB ?skip_bytes,3
      For i = 1 To Vallong(Mid$(newconst$,2,2))
        condata$ = condata$ + Mid$(newconst$,4,1)
      Next

     Case "N"
      PokeB ?skip_bytes,1
      condata$ = Chr$(10)

     Default
      char1.b = PeekB(&newconst$)
      char2.b = PeekB(&newconst$+1)
      nibble1.l = -1
      nibble2.l = -1

      If (char1>=@"0" AND char1<=@"9") Then nibble1 = char1-@"0"
      If (char2>=@"0" AND char2<=@"9") Then nibble2 = char2-@"0"

      If (char1>=@"a" AND char1<=@"f") Then nibble1 = char1-@"a" + 10
      If (char2>=@"a" AND char2<=@"f") Then nibble2 = char2-@"a" + 10

      If (char1>=@"A" AND char1<=@"F") Then nibble1 = char1-@"A" + 10
      If (char2>=@"A" AND char2<=@"F") Then nibble2 = char2-@"A" + 10

      If nibble1>=0 AND nibble2>=0
        newchar.l = (nibble1 LSL 4) + (nibble2)
        condata$ = Chr$(newchar)
        PokeB ?skip_bytes,2
      EndIf

    End Select
  EndIf
  If condata$ = "" AND PeekB(?skip_bytes)=0
    log2PED{">> " + Peek.s(_myD0-4) }
    log2PED{"detected unknown const: [" + newconst$ + "]"}
    condata$ = newconst$
  EndIf

  GetReg D0,FLen(condata$)-1                                    ; laenge zielstring -> Stack
  MOVE.l d0,d2
  MOVE.l d2,-(a7)

  GetReg D0,&condata$                                          ; kopieren des neuen Strings in den Zielstring
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
 DBF d2,'l1

  !asm
  MOVE.l (a7)+,d0                                          ; laenge Zielstring <- Stack
  MOVE.l (a7)+,d2                                          ; d2 <-Stack
  ADD.l d0,d2                                              ; eingefuegte chars zu D2 dazu
  ADD.l #1,d2

  MOVE.l #0,d0                                             ; a5 um konstantennamen weiterschieben
  MOVE.b skip_bytes,D0
  ADD.l D0,a5
RTS


.checkdoubledeclare                        ; check of double used var names  by bernd roesch  20150315
  MOVEM.l d0-d2/a0-a5,-(a7)

  TST.w proceduremode : BEQ 'global       ;1 in function
    LEA firstglob,a2
    JSR findvariable2 : BEQ 'isused
    
    MOVE.b #1,newvariable
    LEA firstlocal,a2
    JSR findvariable : BEQ 'isused
    
    CLR.b newvariable
    MOVEM.l (a7)+,d0-d2/a0-a5
    RTS
 'global
  
  JSR findvariable : BNE 'isunused

   'isused
    MOVE.w lastchar,-(a7)                               
    JSR getparameter2                                   ; get the type from source  
    MOVE.w (a7)+,lastchar

    MOVE.l $a(a2),a0                                    ; get the typename
    LEA $b(a0),a0
    LEA namebuffer,a1

   'again
      CMPM.b (a0)+,(a1)+ : BNE 'error                   ; compare typenames   
    TST.b (a1) : BNE 'again                                
    TST.b (a0) : BNE 'error                             ; it is same variable and same type so it is allowed to redim or redefine  

 'isunused

  MOVEM.l (a7)+,d0-d2/a0-a5
RTS

'error : JMP errormsg_declaredtwice


checka4a5
  MOVEM.l a3/d1,-(a7)
                 ; put register a4-a5 to stack if a AOS function use it
  CLR.b a4a5store

 'continue
  MOVE.b (a3)+,d1
  CMP.b #$15,d1 : BEQ 'find
  CMP.b #$14,d1 : BEQ 'find
  CMP.b #$ff,d1 : BNE 'continue
  BRA 'notfind
 'find
    MOVE.l #$48e7000c,d1 : JSR writelong                   ; write 68k movem.l a4/a5,-(a7)
    MOVE.b #1,a4a5store
 'notfind
    MOVEM.l (a7)+,a3/d1
RTS


restorea4a5
  TST.b a4a5store : BEQ 'no
    MOVE.l #$4cdf3000,d1 : JSR writelong                  ; write 68k movem.l (a7)+,a4/a5
    CLR.b a4a5store
 'no
RTS

.bigallox
 !basic
 If config\OnePassCompiling = True
   maxmem.l = (AvailMem_ (#MEMF_PUBLIC) LSR 2)  ; 1/4 of the available free mem
   objectlength.l = PeekL(?objlen)
   If PeekW(?set_use_debugger) = 0
     If (objectlength < 3670056) AND (maxmem > 3670056)
       MOVE.l #3145727,d2     ; objectbuffersize
       MOVE.l  #262143,d3     ; libsbuffersize
       MOVE.l  #131071,d4     ; systembuffersize
       MOVE.l  #131071,d5     ; databuffersize
       JSR make_allox  ; added 40 buffer more
       !basic
     Else
       If (objectlength < 1572904) AND (maxmem > 1572904)
         !asm
         MOVE.l #1310719,d2     ; objectbuffersize
         MOVE.l  #131071,d3     ; libsbuffersize
         MOVE.l   #65535,d4     ; systembuffersize
         MOVE.l   #65535,d5     ; databuffersize
         JSR make_allox ; added 40 buffer more
         !basic
       EndIf
     EndIf
   Else
     maxmem LSL 1 ; for debug test for 1/2 of the available mem
     If (objectlength < 12058664) AND (maxmem > 12058664)
       MOVE.l #5242879,d2     ; objectbuffersize
       MOVE.l  #262143,d3     ; libsbuffersize
       MOVE.l #6291455,d4     ; systembuffersize
       MOVE.l  #262143,d5     ; databuffersize
       JSR make_allox ; added 40 buffer more
       !basic
     Else
       If (objectlength < 6094888) AND (maxmem > 6094888)
         !asm
         MOVE.l #2621439,d2     ; objectbuffersize
         MOVE.l  #262143,d3     ; libsbuffersize
         MOVE.l #3145727,d4     ; systembuffersize
         MOVE.l   #65535,d5     ; databuffersize
         JSR make_allox ; added 40 buffer more
         !basic
       EndIf
     EndIf
   EndIf
   If objectlength = PeekL(?objlen)    ; test if big allox failed
      !asm                              ; yes it fails
        BSET #$7,set_make_smallestcode      ; active make small code again to prevent endless compile runs
      !basic
   EndIf
 EndIf
 !asm
RTS

.menu_createreleaseexe:
  !basic
  releaseexe = True

  ; store config values 
  releasedbg_save = PeekW(?set_create_dbgfile)
  releasefuncoptimize_save = PeekW(?set_FuncOptimize)
  releasemakesmall_save = PeekW(?set_make_smallestcode)
  releasedebugger_save = PeekW(?set_use_debugger)

  ; set optimum values
  PokeW ?set_create_dbgfile,0
  PokeW ?set_FuncOptimize,$80
  PokeW ?set_make_smallestcode,$80
  PokeW ?set_use_debugger,0
  !asm
 
  JSR menu_createexecutable
  
  !regs2stack
  !basic
  releaseexe = False        
  
  ;restore config values
  PokeW ?set_create_dbgfile,releasedbg_save
  PokeW ?set_FuncOptimize,releasefuncoptimize_save
  PokeW ?set_use_debugger,releasedebugger_save
  PokeW ?set_make_smallestcode,releasemakesmall_save
  !asm
  !stack2regs
RTS


.clear_lastcompileerrordatas     ; added to fix hits by errormessages for Residents by load- and switching the sourcecode tomsmart1 2016.02.02
  MOVE.l #0,beforeparameterfetch ; reset so no code will detoken , fix the hit
  MOVE.w #0,ininclude            ; reset we have no include code , fix the endless loop
  MOVE.l #-1,compilelinecounter  ; reset the line we have compiled
  MOVE.l #0,globallinecount      ; reset the linecounter
RTS

.check_fpu_before_run:
  MOVEQ #0,d0
  !basic
  check_fpu_mode.b = PeekB(?optimize_fpu) AND $2
  If check_fpu_mode
    If ProcessorFPU = 0
      error{"The generated code has been optimized to use FPU-features,\\nbut no FPU is present on this system.\\n\\nExecution is not possible."}
      !asm
      MOVEQ #1,d0
      RTS
    End If
  End If
  !asm
RTS



.read_userlibsfile:
  If tmp_userlibspointer.l = 0 Then tmp_userlibspointer.l = libdata\ptr_userlibs
  ;log2PED{"userlibspointer at address: " + Hex$(tmp_userlibspointer)}

  ulfh.l = Open_(&userlib_filename$,#MODE_OLDFILE)
  If ulfh
    ;-- read header data
    Read_ ulfh,?optstuff,$20                               ; read first 32 bytes
    
    ;-- calculate datachunk size and allocate memory for it
    datachunk_size.l = PeekL(?optstuff + 28) LSL 2
    datachunk_ptr.l  = AllocPooled_ (PeekL(?mempool), datachunk_size)    

    ;-- read datachunk from library
    Read_ ulfh,datachunk_ptr, datachunk_size
    ;log2PED_HexDump{datachunk_ptr,32}

    ;-- add blitzlib to internal blitzlib list    
    PokeL tmp_userlibspointer, datachunk_ptr                     ; add address to linked list
    tmp_userlibspointer = datachunk_ptr                           ; set list to current entry

    PokeL datachunk_ptr +  $6, datachunk_size                    ; write size of library into structure
    PokeL datachunk_ptr + $20, 0

    If Read_(ulfh,?optstuff,$0C) = $0C                            ; read additional 12 bytes
      udata.l = PeekL(?optstuff + 4)                             ; length of reloc info (lsl2)
      PokeL datachunk_ptr + $20, udata
      udata = udata LSL 2
      tmp_mem2.l = AllocPooled_ (PeekL(?mempool), udata)
      PokeL datachunk_ptr + $24, tmp_mem2
      Read_ ulfh, tmp_mem2, udata
    EndIf
    Close_ ulfh

    ;-- check if library with that libnumber is already in librarylist
    ;-- if so replace it with the loaded one
    libnum.w = PeekW(datachunk_ptr + 4)
    firsttoken.s = Get_Libinfo{datachunk_ptr + 4}

    tmpfound.b = False
    prevaddr.l = 0
    tmpaddr.l = PeekL(?libpointer)
    While (tmpaddr <> 0) AND (tmpfound = False)
      If PeekW(tmpaddr + 4) = libnum
        tmpfound = True
      Else
        prevaddr = tmpaddr
        tmpaddr = PeekL(tmpaddr)
      EndIf
    Wend

    If tmpfound
      log2PED{".. library with #" + Str$(libnum) + " already in library list, will replace the existing one", #log_warning}
      log2PED{".. old prev lib #" + Str$(PeekW(prevaddr + 4))}
      log2PED{".. old next lib #" + Str$(PeekW(PeekL(tmpaddr) + 4))}
      ;-- HACK: remove the old lib out of list, by removing the entry from linked list
      ;-- lib will be still in memory and not being freed
      PokeL prevaddr, PeekL(tmpaddr)
    Else
      ;-- write name and first token to tokenmapping file to make PED identify the lib with its number
      If tokmapfid <> -1
        log2PED{".. adding library #" + Str$(libnum) + " with first token <" + firsttoken + "> to token mapping file"}
        currentlib$ = LSet$(Peek.s(&fib\fib_FileName),30) + ";" 
        currentlib$ + LSet$(firsttoken,30)
        file_WriteLine{tokmapfid, currentlib$}
      EndIf
    EndIf

    ; just for debugging: list several libnuns of library list   
    ;    tmpfound.b = False
    ;    tmpaddr.l = PeekL(?libpointer)
    ;    While (tmpaddr <> 0)
    ;      libnum_next.w = 0
    ;
    ;      libnum.w = PeekW(tmpaddr + 4)
    ;      If PeekL(tmpaddr) <> 0 Then libnum_next.w = PeekW(PeekL(tmpaddr) + 4)
    ;      If libnum = 62 OR libnum=138 OR libnum = 120 Then log2PED{Str$(libnum) + " -> " + Str$(libnum_next)}
    ;      If libnum = 138
    ;        tmpfound + 1
    ;      EndIf
    ;      tmpaddr = PeekL(tmpaddr)
    ;    Wend
  Else
    error{"could not open userlibfile: " + userlib_filename$}
  EndIf
Return


;------------------------------- for debugging purpose only ------------------

.log_optimize:
    !regs2stack
    !basic
    ttt.w = PeekW(?optimize_jumps)
    log2PED{"optimizing JSRs is turned on"}
    !asm
    !stack2regs
RTS

.show_optimize:
    !regs2stack
    !basic
    log2PED{"optimize found!"}
    !asm
    !stack2regs
RTS



; ===========================================================================
.internal_commands:
.tokens:
INCLUDE "internal_commands.ab3"
Even


.CIF_branches:                                             ;cifbras
           Dc.l cif_lt                                     ;ciflt
           Dc.l cif_eq                                     ;cifeq
           Dc.l cif_gt                                     ;cifgt
           Ds.l 1                                          ;0
           Dc.l cif_le                                     ;cifle
           Dc.l cif_ne                                     ;cifne
           Dc.l cif_le                                     ;cifge
           Ds.l 1                                          ;0
           Dc.l cif_ge                                     ;cifge
           Dc.l cif_ne                                     ;cifne
           Dc.l cif_ge                                     ;cifge
           Ds.l 1                                          ;0

instructionbase:                                                     ;atokens org sourcs
           Dc.l do_newtype                                 ;donewtype       0001
           Dc.l do_end                                     ;doend           0002
           Dc.l do_let                                     ;dolet
           Dc.l do_dim                                     ;dodim
           Dc.l do_goto                                    ;dogoto
           Dc.l do_gosub                                   ;dogosub
           Dc.l do_return                                  ;doreturn
           Dc.l do_statement                               ;dostate
           Dc.l do_function                                ;dofunc
           Dc.l do_mousewait                               ;domwait
           Dc.l do_if                                      ;doif
           Dc.l do_while                                   ;dowhile
           Dc.l do_Macro                                   ;domacro
           Dc.l do_select                                  ;doselect
           Dc.l do_case                                    ;docase
           Dc.l do_default                                 ;dodefault
           Dc.l do_AsmExit                                 ;doasmexit
           Dc.l do_xinclude                                ;doxinclude
           Dc.l do_INCLUDE                                 ;doinclude
           Dc.l do_SYNTAX                                  ;syntaxerr
           Dc.l do_shared                                  ;doshared
           Dc.l do_for                                     ;dofor
           Dc.l do_next                                    ;donext
           Dc.l syntaxerr                                  ; To
           Dc.l syntaxerr                                  ; Step
           Dc.l do_data                                    ;dodata
           Dc.l do_read                                    ;doread          0027

; --
; -- the following should all be intercepted by getchar
           Dc.l syntaxerr                                  ; CNIF
           Dc.l syntaxerr                                  ; CSIF
           Dc.l syntaxerr                                  ; CELSE
           Dc.l syntaxerr                                  ; CEND
           Dc.l do_cerr                                    ;docerr
           Dc.l do_then                                    ;dothen
           Dc.l do_else                                    ;doelse
           Dc.l do_even4                                   ;doeven4
           Dc.l do_even8                                   ;doeven8         0036
;
           Dc.l do_dc                                      ;dodc
           Dc.l do_ds                                      ;dods
           Dc.l do_even                                    ;doeven
           Dc.l do_dcb                                     ;dodcb
           Dc.l do_GetReg                                  ;dosetreg
           Dc.l do_IncBin                                  ;doincbin
           Dc.l do_free                                    ;dofree
           Dc.l do_use                                     ;douse
           Dc.l do_Stop                                    ;dostop
           Dc.l do_Cont                                    ;docont
           Dc.l syntaxerr                                  ;syntaxeer
           Dc.l do_SetInt                                  ;dosetint        0048
           Dc.l do_ClrInt                                  ;doclrint
           Dc.l do_MaxLen                                  ;domaxlen
           Dc.l do_DEFTYPE                                 ;dodeftype
           Dc.l do_BLITZ                                   ;doblitz
           Dc.l do_AMIGA                                   ;doamiga
           Dc.l do_QAMIGA                                  ;doqamiga
           Dc.l do_VWait                                   ;dovwait
           Dc.l do_ALibJsr                                 ;dolibjsr        0056
           Dc.l do_TokeJsr                                 ;dotokejsr       0057
           Dc.l do_BLibJsr                                 ;doblibjsr       0058
           Dc.l _extb                                      ;syntaxerr       0059
    ;
    ;A break goes in here for the assembler stuff!
    ;
           Dc.l syntaxerr                                  ;syntaxerr      ;flash2 ; for list
           Dc.l do_SetErr                                  ;doseterr
           Dc.l do_ClrErr                                  ;doclrerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l do_ErrFail                                 ;doerrfail
           Dc.l syntaxerr
           Dc.l syntaxerr                                  ;mod
           Dc.l syntaxerr                                  ;Pi
           Dc.l do_Repeat                                  ;dorepeat
           Dc.l do_Until                                   ;dountil
           Dc.l do_PutReg                                  ;doputreg
           Dc.l do_Pop                                     ;dopop
           Dc.l do_INCDIR                                  ;doincdir
           Dc.l mydo_Endif2                                ;mydoendif2
           Dc.l do_Wend                                    ;dowend
           Dc.l do_SysJsr                                  ;dosysjsr
           Dc.l do_WBStartup                               ;dowbstartup
           Dc.l syntaxerr
           Dc.l do_Ongo                                    ;doongo
           Dc.l syntaxerr
           Dc.l do_Forever                                 ;doforever
           Dc.l do_Restore                                 ;dorestore
           Dc.l do_Exchange                                ;doexchange
           Dc.l do_USEPATH                                 ;dousepath
           Dc.l do_CloseEd                                 ;doclosed
           Dc.l do_NoCli                                   ;donocli
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l do_runerrson                               ;dorunerrson
           Dc.l do_runerrsoff                              ;dorunerrsoff
           Dc.l do_uselastpath
           Dc.l do_regload
           Dc.l do_regsave
           Dc.l do_Object
           Dc.l do_usepath2
           Dc.l do_LastRunErrsMode
           Dc.l do_honitos
atokensend:

;.compilermenu_entries:
; "COMPILE AND RUN        "
; "RUN                    "
; "CREATE EXECUTABLE      "
; "COMPILER OPTIONS       "
; "CREATE RESIDENT        "
; "VIEW NEWTYPES          "
; "CLI ARGUMENT           "
; "CALCULATOR             "
; "RELOAD ALL LIBS        "
; "LOAD DEBUG MODULE      "
menu_items:Dc.l menu_compile_run                                ;menuadds oreg source
           Dc.l menu_run
           Dc.l menu_createexecutable
           Dc.l menu_dummyfunc                                  ;was menu_compileroptions
           Dc.l menu_createresidentfile
           Dc.l menu_dummyfunc                                  ;was menu_viewnewtypes
           Dc.l menu_dummyfunc                                  ;was menu_simcliarguments
           Dc.l menu_dummyfunc                                  ;was menu_calculator
           Dc.l menu_reload_userlibs
           Dc.l menu_dummyfunc
           Dc.l menu_dummyfunc
           Dc.l menu_createexecutable
           Dc.l menu_dummyfunc
           Dc.l menu_dummyfunc
           Dc.l menu_createreleaseexe                           ; changed to make it possible to access the routine from PED tomsmart1
           Dc.l menu_dummyfunc
Even4


edstruct:                  Dc.l tokens                     ;data for ted
;                          Dc.l compilermenu_entries
                           Dc.l 0

                           Dc.l read_xtrafile              ;load .xtra routine
                           Dc.l write_xtrafile             ;save .xtra routine
                           Dc.l call_menuentry             ;Menu Routine
                           Ds.l 1                          ;cleanup (?)
                           Dc.b ":",34,".;"
Even4

;--                                                                                 ;disassembled code begin
;-- some object codes for compiler
;--
.objects 
lslimm:                    Dc.w $E148                                               ;LSL.W   #8,D0

use:                       Dc.w $266D,$0000                                         ;MOVEA.L $0000(A5),A3
                           Dc.w $D6C0                                               ;ADDA.W  D0,A3
                           Dc.w $2B4B,$0000                                         ;MOVE.L  A3,$0000(A5)
usef:                      ;same as beginarr

beginarr:                  Dc.w $203C,$0000,$0000                                   ;MOVE.L  #$00000000,D0

putarr:                    Dc.w $2B40,$0000                                         ;MOVE.L  D0,$0000(A5)

doarr:                     Dc.w $343C,$0000                                         ;MOVE.W  #$0000,D2
                           Dc.w $363C,$0000                                         ;MOVE.W  #$0000,D3
doarrf:

nops8:                     Dc.w opcode_NOP                                          ;NOP
                           Dc.w opcode_NOP                                          ;NOP
                           Dc.w opcode_NOP                                          ;NOP
                           Dc.w opcode_NOP                                          ;NOP
nops4:                     Dc.w opcode_NOP                                          ;NOP
                           Dc.w opcode_NOP                                          ;NOP
                           Dc.w opcode_NOP                                          ;NOP
                           Dc.w opcode_NOP                                          ;NOP
nopsf:

dataget:                   Dc.w $266D : Dc.w $0000                                  ;MOVEA.L $0000(A5),A3

dataput:                   Dc.w $2B4B : Dc.w $0000                                  ;MOVE.L  A3,$0000(A5)

stlenget:                  Dc.w $2F1B                                               ;MOVE.L  (A3)+,-(A7)

stalign:                   Dc.w $524B                                               ;ADDQ.W  #1,A3
                           Dc.w $C18B                                               ;EXG D0,A3
                           Dc.w $0880,$0000                                         ;BCLR    #0,D0
                           Dc.w $C18B                                               ;EXG D0,A3
stalignf:


;byte...
dataletb:                  Dc.w $524B                                               ;ADDQ.W  #1,A3
                           Dc.w $1B5B,$0000                                         ;MOVE.B  (A3)+,$0000(A5)
dataletbf:

dataletbl:                 Dc.w $524B                                               ;ADDQ.W  #1,A3
                           Dc.w $195B,$0000                                         ;MOVE.B  (A3)+,$0000(A4)
dataletblf:

dataletb2:                 Dc.w $524B                                               ;ADDQ.W  #1,A3
                           Dc.w $149B                                               ;MOVE.B  (A3)+,(A2)
dataletb2f:


;word...
dataletw:                  Dc.w $3B5B,$0000                                         ;MOVE.W  (A3)+,$0000(A5)
                           Dc.w $349B                                               ;MOVE.W  (A3)+,(A2)
                           Dc.w $395B,$0000                                         ;MOVE.W  (A3)+,$0000(A4)

;long...
dataletl:                  Dc.w $2B5B,$0000                                         ;MOVE.L  (A3)+,$0000(A5)
                           Dc.w $249B                                               ;MOVE.L  (A3)+,(A2)
                           Dc.w $295B,$0000                                         ;MOVE.L  (A3)+,$0000(A4)

nextfixw:                  Dc.w $504F                                               ;ADDQ.W  #8,A7

nextfixw2:                 Dc.w $4FEF,$000A                                         ;LEA $000A(A7),A7

nextfixl:                  Dc.w $4FEF,$000C                                         ;LEA $000C(A7),A7

nextfixl2:                 Dc.w $4FEF,$000E                                         ;LEA $000E(A7),A7

;a byte type next
nextb:                     Dc.w $246F,$0004                                         ;MOVEA.L $0004(A7),A2
                           Dc.w $3017                                               ;MOVE.W  (A7),D0
                           Dc.w $D112                                               ;ADD.B   D0,(A2)
nextbf:

;a word type next
nextw:                     Dc.w $246F,$0004                                         ;MOVEA.L $0004(A7),A2
                           Dc.w $3017                                               ;MOVE.W  (A7),D0
                           Dc.w $D152                                               ;ADD.W   D0,(A2)
nextwf:

;a long type next
nextl:                     Dc.w $246F,$0008                                         ;MOVEA.L $0008(A7),A2
                           Dc.w $2017                                               ;MOVE.L  (A7),D0
                           Dc.w $D192                                               ;ADD.L   D0,(A2)
nextlf:

;a float type next
nextf:                     Dc.w $246F,$0008                                         ;MOVEA.L $0008(A7),A2
                           Dc.w $2012                                               ;MOVE.L  (A2),D0
                           Dc.w $2217                                               ;MOVE.L  (A7),D1
                           Dc.w $4EAE,$FFBE                                         ;JSR -$0042(A6)
                           Dc.w $2480                                               ;MOVE.L  D0,(A2)
nextff:    


;the For...Next Compare..... for bytes
forcompb:                  Dc.w $246F,$0004                                         ;MOVEA.L $0004(A7),A2
                           Dc.w $1012                                               ;MOVE.B  (A2),D0
                           Dc.w $322F,$0002                                         ;MOVE.W  $0002(A7),D1
                           Dc.w $4A57                                               ;TST.W   (A7)
                           Dc.w $6A00,$0004                                         ;BPL.W   L000001         ;.skip org source
                           Dc.w $C141                                               ;EXG D0,D1
                                                                                    ;L000001:                  ;.skip org source
                           Dc.w $B001                                               ;CMP.B   D1,D0
forcompbf: 


;the For...Next Compare..... for words
forcompw:                  Dc.w $246F,$0004                                         ;MOVEA.L $0004(A7),A2
                           Dc.w $3012                                               ;MOVE.W  (A2),D0
                           Dc.w $322F,$0002                                         ;MOVE.W  $0002(A7),D1
                           Dc.w $4A57                                               ;TST.W   (A7)
                           Dc.w $6A00,$0004                                         ;BPL.W   L000002         ;.skip org source
                           Dc.w $C141                                               ;EXG D0,D1
                                                                                    ;L000002:                  ;.skip org source
                           Dc.w $B041                                               ;CMP.W   D1,D0
forcompwf: 


forcompl:                  Dc.w $246F,$0008                                         ;MOVEA.L $0008(A7),A2
                           Dc.w $2012                                               ;MOVE.L  (A2),D0
                           Dc.w $222F,$0004                                         ;MOVE.L  $0004(A7),D1
                           Dc.w $4A57                                               ;TST.W   (A7)
                           Dc.w $6A00,$0004                                         ;BPL.W   L000003         ;.skip org source
                           Dc.w $C141                                               ;EXG D0,D1
                                                                                    ;L000003:                  ;.skip org source
                           Dc.w $B081                                               ;CMP.L   D1,D0
forcomplf:


;floating point for/next compare.....
forcompf:                  Dc.w $246F,$0008                                         ;MOVEA.L $0008(A7),A2
                           Dc.w $2012                                               ;MOVE.L  (A2),D0
                           Dc.w $222F,$0004                                         ;MOVE.L  $0004(A7),D1
                           Dc.w $082F,$0007,$0003                                   ;BTST    #7,$0003(A7)
                           Dc.w $6700,$0004                                         ;BEQ.W   L000004
                           Dc.w $C141                                               ;EXG D0,D1
                                                                                    ;L000004:
forcompff: 


;continuation
forcompf2:                 Dc.w $4EAE,$FFD6                                         ;JSR -$002A(A6)
forcompf2f:

swapd0:                    Dc.w $4840                                               ;SWAP    D0

pushindex:                 Dc.w $2F0A                                               ;MOVE.L  A2,-(A7)

leaamp:                    Dc.w $45ED, $0000                                        ;LEA $0000(A5),A2
leaamp2:                   Dc.w $200A                                               ;MOVE.L  A2,D0

leaampl:                   Dc.w $45EC, $0000                                        ;LEA $0000(A4),A2

stamp:                     Dc.w $2012                                               ;MOVE.L  (A2),D0

stamp2:                    Dc.w $246D, $0000                                        ;MOVEA.L $0000(A5),A2

;lose string len!
stol:                      Dc.w $584F                                               ;ADDQ.W  #4,A7

pushd0wd:                  Dc.w $3F00                                               ;MOVE.W  D0,-(A7)

pushd0l:                   Dc.w $2F00                                               ;MOVE.L  D0,-(A7)

movenumrep:                Dc.w $3E3C, $0000                                        ;MOVE.W  #$0000,D7

preplibst:                 Dc.w $45EF, $0000                                        ;LEA $0000(A7),A2

fixlibst:                  Dc.w $4FEF, $0000                                        ;LEA $0000(A7),A7

pushdn:                    Dc.w $2F00                                               ;MOVE.L  D0,-(A7)

movea3a7:                  Dc.w $2F0B                                               ;MOVE.L  A3,-(A7)

movestst2:                 Dc.w $202F, $0006                                        ;MOVE.L  $0006(A7),D0
                           Dc.w $3F6F, $0004,$0008                                  ;MOVE.W  $0004(A7),$0008(A7)
                           Dc.w $2E9F                                               ;MOVE.L  (A7)+,(A7)
movestst2f:

movea7dn:                  Dc.w $202F,$0004                                         ;MOVE.L  $0004(A7),D0
                           Dc.w $2E9F                                               ;MOVE.L  (A7)+,(A7)
movea7dnf:


moved0a3:                  Dc.w $2640                                               ;MOVEA.L D0,A3

movestdn:                  Dc.w $202D, $0000                                        ;MOVE.L  $0000(A5),D0

;movea3dn:                 Dc.w $200B                                               ;MOVE.L  A3,D0

putstlen:                  Dc.w $2F00 ;push string length                           ;MOVE.L  D0,-(A7)

getstlen:                  Dc.w $201F ;pop string length                            ;MOVE.L  (A7)+,D0

moverts:                   Dc.w $2F57, $0000                                        ;MOVE.L  (A7),$0000(A7)

fixstack:                  Dc.w $4FEF, $0000                                        ;LEA $0000(A7),A7

fixq:                      Dc.w $504F                                               ;ADDQ.W  #8,A7

fix1:                      Dc.w $2E9F                                               ;MOVE.L  (A7)+,(A7)

movedna3:                  Dc.w $2640                                               ;MOVEA.L D0,A3

least:                     Dc.w $45EC, $0000                                        ;LEA $0000(A4),A2

funcst:                    Dc.w $2F2C, $0000                                        ;MOVE.L  $0000(A4),-(A7)

addq4a2:                   Dc.w $584A                                               ;ADDQ.W  #4,A2

;savesbase:                Dc.w $2F0B                                               ;MOVE.L  A3,-(A7)

;savesbase2:               Dc.w $2B4B, $0000                                        ;MOVE.L  A3,$0000(A5)
;savesbasef:

;ressbase:                 Dc.w $265F                                               ;MOVEA.L (A7)+,A3
;ressbase2:                Dc.w $2B4B, $0000                                        ;MOVE.L  A3,$0000(A5)
;ressbasef:

;exga4a5                   Dc.w $CB4C                                               ;EXG A5,A4

;linka4 ;org source
linksize:                  Dc.w $4E54, $0000                                        ;LINK    A4,#-$0000

unlinka4:                  Dc.w $4E5C                                               ;UNLK    A4

;a2toa7                    Dc.w $2F0A                                               ;MOVE.L  A2,-(A7)

;a7toa2                    Dc.w $245F                                               ;MOVEA.L (A7)+,A2


gotocode:                  Dc.w $4EF9,$0000,$0000                                   ;JMP $00000000

gosubcode:                 Dc.w $4EB9,$0000,$0000                                   ;JSR $00000000

                                                                                    ;L000005:                ;mwait: org source
mwait:                     Dc.w $0839, $0006, $00BF, $E001                          ;BTST    #6,$00BFE001
                           Dc.w $6600, $FFF6                                        ;BNE.W   L000005       ;mwait: org source
mwaitf:


libreg:                    Dc.w $2000                                               ;MOVE.L  D0,D0

libbase:                   Dc.w $2C6D, $0000                                        ;MOVEA.L $0000(A5),A6

libjsr:                    Dc.w $4EAE, $0000                                        ;JSR $0000(A6)

regtransd:                 Dc.w $202D, $0000                                        ;MOVE.L  $0000(A5),D0
regtransa:                 Dc.w $206D, $0000                                        ;MOVEA.L $0000(A5),A0


;litget                    Dc.w $267C, $0000                                        ;MOVEA.L #$00000000,A3
;litget2                   Dc.l $3F1B                                               ;MOVE.W  (A3)+,-(A7)

movea2dn:                  Dc.w $2012                                               ;MOVE.L  (A2),D0

moved3a5dn:                Dc.w $202D, $0000                                        ;MOVE.L  $0000(A5),D0

stvarget2:                 Dc.w $7000                                               ;MOVEQ   #$00,D0
                           Dc.w $2F00                                               ;MOVE.L  D0,-(A7)
                           Dc.w $4A92                                               ;TST.L   (A2)
                           Dc.w $6700, $000E                                        ;BEQ.W   L000006        ;varget2skip org source
                           Dc.w $2052                                               ;MOVEA.L (A2),A0
                           Dc.w $5948                                               ;SUBQ.W  #4,A0
                           Dc.w $2E98                                               ;MOVE.L  (A0)+,(A7)
stvarget2f:                Dc.w $4EB9, $0000, $0000                                 ;JSR $00000000
varget2skip:                                                                        ;L000006:                 ;varget2skip org source

addcode:                   Dc.w $201F                                               ;MOVE.L  (A7)+,D0
                           Dc.w $D197                                               ;ADD.L   D0,(A7)
;addcodef:


pushlen:                   Dc.w $2F18                                               ;MOVE.L  (A0)+,-(A7)

leaa5d3a2:                 Dc.w $45ED, $0000                                        ;LEA $0000(A5),A2

pusha2:                    Dc.w $2F0A                                               ;MOVE.L  A2,-(A7)

;geta2                     Dc.w $2457                                               ;MOVEA.L (A7),A2

pulla2:                    Dc.w $245F                                               ;MOVEA.L (A7)+,A2

pulla2st:                  Dc.w $246F, $0004                                        ;MOVEA.L $0004(A7),A2
                           Dc.w $2E9F                                               ;MOVE.L  (A7)+,(A7)
pulla2stf:

pusha3:                    Dc.w $2F2D, $0000                                        ;MOVE.L  $0000(A5),-(A7)
pusha32:                   Dc.w $2B4B, $0000                                        ;MOVE.L  A3,$0000(A5)
pusha3f:


pulla3:                    Dc.w $2B5F, $0000                                        ;MOVE.L  (A7)+,$0000(A5)
pulla3f:

geta3:                     Dc.w $266D, $0000                                        ;MOVEA.L $0000(A5),A3
geta3f:

numtoa0:                   Dc.w $207C, $0000, $0000                                 ;MOVEA.L #$00000000,A0

numtoa2:                   Dc.w $247C, $0000, $0000                                 ;MOVEA.L #$00000000,A2

                           ;free up all arrays code
endarray:                  Dc.w $383C, $0000                                        ;MOVE.W  #$0000,D4


;preparray                 Dc.w $34,$3C,$00,$00                                     ;MOVE.W  #$0000,D2
;                          Dc.w $36,$3C,$00,$00                                     ;MOVE.W  #$0000,D3
;preparrayf


;dimbegin:                 Dc.w $203C, $0000, $0004                                 ;MOVE.L  #$00000004,D0
;dimbeginf:

;dimb4:                    Dc.w $2B40, $0000                                        ;MOVE.L  D0,$0000(A5)
;dimb4f:   

;dimaf:                    Dc.w $C0C1                                               ;MULU.W  D1,D0
;dimaff:  
;dimfin:                   Dc.w $2B40, $0000                                        ;MOVE.L  D0,$0000(A5)
;dimfinf: 


movea0:                    Dc.w $2452                                               ;MOVEA.L (A2),A2

adda0a0:                   Dc.w $D5CA                                               ;ADDA.L  A2,A2
                           Dc.w $D5CA                                               ;ADDA.L  A2,A2

;getebase:                 Dc.w $2C78, $0004                                        ;MOVEA.L $0004,A6
;getebasef:                

movea5a0:                  Dc.w $246D,  $0000                                       ;MOVEA.L $0000(A5),A2

movea0a0:                  Dc.w $246A,  $0000                                       ;MOVEA.L $0000(A2),A2

addqa0:                    Dc.w $524A                                               ;ADDQ.W  #1,A2

leaa0a0:                   Dc.w $45EA,  $0000                                       ;LEA $0000(A2),A2

addrega2:                  Dc.w $D4C0                                               ;ADDA.W  D0,A2

Even
;-----------end of object codes!--------------

.iconImageData:
  Dc.b $FF,$FF
  Dc.b $FF,$FF,$FF,$FC
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$3F,$BB,$40
  Dc.b $80,$1F,$C0,$00
  Dc.b $00,$00,$80,$3F
  Dc.b $C0,$0F,$BB,$40
  Dc.b $80,$1F,$C0,$00
  Dc.b $00,$00,$8E,$00
  Dc.b $F8,$00,$00,$00
  Dc.b $8F,$01,$FF,$00
  Dc.b $3B,$40,$81,$E3
  Dc.b $F7,$C0,$00,$00
  Dc.b $80,$7F,$F8,$70
  Dc.b $3B,$40,$80,$0F
  Dc.b $7C,$E0,$00,$00
  Dc.b $80,$00,$FD,$80
  Dc.b $00,$00,$80,$01
  Dc.b $F6,$00,$FB,$40
  Dc.b $80,$03,$EF,$00
  Dc.b $00,$00,$80,$07
  Dc.b $87,$80,$3B,$40
  Dc.b $80,$0F,$01,$C0
  Dc.b $00,$00,$80,$03
  Dc.b $F0,$70,$1D,$40
  Dc.b $80,$00,$18,$1C
  Dc.b $00,$00,$80,$00
  Dc.b $10,$06,$03,$40
  Dc.b $80,$00,$20,$1F
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$01,$40
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$3F,$FC,$01
  Dc.b $BB,$44,$00,$60
  Dc.b $FE,$00,$00,$04
  Dc.b $00,$CF,$FF,$01
  Dc.b $BB,$44,$1F,$EF
  Dc.b $FF,$00,$00,$04
  Dc.b $33,$FF,$FF,$E0
  Dc.b $00,$04,$37,$FE
  Dc.b $7F,$FC,$1B,$44
  Dc.b $0F,$9C,$FF,$FF
  Dc.b $00,$04,$03,$E3
  Dc.b $FF,$FF,$DB,$44
  Dc.b $00,$7F,$BF,$FF
  Dc.b $80,$04,$00,$0F
  Dc.b $3F,$FE,$00,$04
  Dc.b $00,$06,$7F,$F8
  Dc.b $1B,$44,$00,$0C
  Dc.b $F7,$FC,$00,$04
  Dc.b $00,$19,$F9,$FE
  Dc.b $1B,$44,$00,$33
  Dc.b $FE,$7F,$00,$04
  Dc.b $00,$0F,$FF,$BF
  Dc.b $CD,$44,$00,$03
  Dc.b $EF,$EF,$F0,$04
  Dc.b $00,$00,$7F,$DF
  Dc.b $FB,$44,$00,$00
  Dc.b $FF,$A7,$FC,$04
  Dc.b $00,$00,$7E,$3F
  Dc.b $FD,$44,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $7F,$FF,$FF,$FF
  Dc.b $FF,$FC,$00,$00
  Dc.b $00,$01,$00,$00
  Dc.b $00,$00,$04
Even

; ====================================================================================
myversion            Dc.b "\\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH (\\__DATE_GER__) Build \\__VER_BUILD",0
Even
; ====================================================================================

BSS
_dosbase:            Ds.l 1
_mathffpbase:        Ds.l 1                           ;maths org source
regnum:              Ds.w 1                           ;regat org source       ;register being used!
typelen:             Ds.w 1
prevtype:            Ds.l 1
lastsourcepos:       Ds.l 1                           ;prevloc org source
lastchar:            Ds.w 1
thistype:            Ds.l 1
errstack:            Ds.l 1
errcont:             Ds.l 1
linemode:            Ds.w 1                          ;0 if norm, 1 if newtype
linesleft:           Ds.w 1
sourceline:          Ds.l 1                          ;thisitem org source
varbase:             Ds.l 1                          ;firstvar org source
alllocals:           Ds.l 1
firstlocal:          Ds.l 1
firstglob:           Ds.l 1
globalvarpointer:    Ds.w 1                          ;varoff org source
locvaroff:           Ds.w 1
firstitem_:          Ds.l 1
numlines_org:        Ds.w 1                          ;numlines org source
firstiff:            Ds.l 1                          ;firstif org source

linenum              Ds.l 1
includesourceline    Ds.l 1
globallinecount      Ds.l 1
leftsideflagmask     Ds.w 1    ;this contain the flag if pointer (1) or not
rightsideflagmask    Ds.w 1
debugnest            Ds.w 1
instringf            Ds.l 1
funcscanon           Ds.l 1
storedebugmode       Ds.b 20
funcparloop          Ds.b 1                   ; is 1 when function calling parameter are compile
blitzparloop         Ds.b 1                   ; is 1 when blitzlib calling parameters are compile
nostringopt          Ds.w 1
path2:               Ds.l 32

typebase             Ds.l 1
doublepeek           Ds.w 1
lastoffset           Ds.l 1
firsttime            Ds.w 1
lastdestpointer      Ds.l 1
prevwritedat         Ds.l 1
lastsourceline       Ds.l 1
lastwritedat         Ds.l 1
makeexec             Ds.w 1
makeexec_remember    Ds.w 1 ; used in climodesupport

sharebase            Ds.l 1
tempa7               Ds.l 1
incnif               Ds.w 1
incfilenamelength    Ds.l 1
result               Ds.l 1
automode             Ds.w 1
stackcorrect         Ds.w 1
formode              Ds.w 1
onestep              Ds.w 1
inctab               Ds.l 40
includeline          Ds.l 1
objectcount          Ds.w 1
savefuncspace        Ds.l 1
lasttrap1            Ds.l 1
currentfunccall      Ds.l 1
skipfunc             Ds.b 1
resdisable           Ds.b 1
skiptoggle           Ds.b 1
developobject        Ds.b 1
iniffcommand         Ds.w 1
startoffsetmore      Ds.w 1
fpucodeglobal        Ds.l 1
fpucodelocal         Ds.l 1
maxregs              Ds.l 1
fpucode              Ds.l 1
firstmline           Ds.w 1
regtable             Ds.l 16
asmpnts:             Ds.l 63  ;Ds.l tnum-fnum org source tokens for asm instructions
                     Ds.l 56

exdebug              Ds.w 1
a2offset2            Ds.w 1
parnumtemp           Ds.l 1
doimmediate          Ds.b 1
notypecheck          Ds.b 1
vartype              Ds.w 1
peekaddrsize         Ds.b 1
declare2             Ds.b 1
lasttoken            Ds.l 1
newvariable          Ds.w 1
declare              Ds.b 1
typecheck            Ds.b 1
nowdeclare           Ds.b 1
dimkeep              Ds.b 1
a4a5store            Ds.b 1
firstiffstore        Ds.l 1
destpointer2         Ds.l 1
stackaddr            Ds.l 1
allowtab             Ds.b 260
thenmode             Ds.w 1
temp                 Ds.w 1
tempregnum           Ds.w 1
numlines2            Ds.l 1
numlines             Ds.l 1
exmac                Ds.w 1
returncode           Ds.w 1
fp0iff               Ds.l 1
fp0addr              Ds.l 1
fp0mode              Ds.w 1
fp0var               Ds.w 1
fastfunc             Ds.w 1
retmode              Ds.w 1
parnum               Ds.w 1
regmask              Ds.w 1
regnumfunc           Ds.w 1
libmode              Ds.w 1
oldline              Ds.l 1
sourceline3          Ds.l 1
debugstore           Ds.b 200
deststore            Ds.l 1
loada                Ds.l 1
currtype             Ds.l 1
arrayoffset          Ds.l 1
lastlabel            Ds.l 1
curtemplabel         Ds.l 1
sourceline2          Ds.l 1
chartab              Ds.b 256
tempspace            Ds.b 120       ; used for calculator
instructionTable     Ds.l 65538 * 2 ; by every compile pass the content beginning from label labelhash to bssstore are cleared!
;-----------------------------
labelhash            Ds.l 8192      ;-bssstore clear every compile pass
replacedat           Ds.w 65538
variablehash         Ds.l 8192
newinitaddr          Ds.l 1
realbssend           Ds.l 1
saved0               Ds.w 1
lastpath             Ds.b 128
lastpath2            Ds.b 128
fpustackbase         Ds.w 100
lastconstantvalue    Ds.l 1  ; the value of the constant expression used in Function Parameter.check isconstantvalue <> 0 if its valid
isconstantvalue      Ds.w 1  ; contain a type (1-7) if a constant expression is used as a Parameter or on right side of =
lastfunction         Ds.l 1  ; the address of the function in the Parameter or rght side of =
leftsidetype         Ds.l 1  ;this contain the address of the type from the left side of the variable assign
rightsidetype        Ds.l 1  ; same as above but right side
bssstore                     ; after each pass this data section will be cleared: from labelhash to bbsstore
;-----------------------------
trap15temp           Ds.l 1
trap15temp2          Ds.l 1
templibend           Ds.l 1
tempdata1start       Ds.l 1
stacktrack           Ds.l 1
pad                  Ds.l 1
includetemp          Ds.b 256
includetemp2         Ds.b 256*10
funccall             Ds.w 1
ptr_resfile          Ds.l 1
CalculatorButtonBinFlag:    Ds.w 1
CalculatorButtonDecFlag:    Ds.w 1
ped_startup_addr:    Ds.l 1
skip_bytes:          Ds.b 1  ; for parsing newconstants
functionreturntype   Ds.l 1  ; a temp store of it.do not read this value
beforeparameterfetch Ds.l 1
typetocast           Ds.l 1
errorcounter         Ds.l 1
iserror              Ds.b 1
MorphOS:             Ds.b 1 ; added to be able to select the cacheclear function 0=AOS, 1=MorphOS  tomsmart1
log_blitzlibs:       Ds.b 1
XTRAEndPadBytes:     Ds.l 0                             ; 4 fill/pad/termination bytes for the xtra write function  tomsmart1
maxerrorcount:       Ds.l 1                             ; added to make it changeable in CLI Mode tomsmart1
CLIMode:             Ds.l 1
reqmode              Ds.l 1
versioninformation   Ds.l 1
number_of_builds:    Ds.l 1
Even
