; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "///"
; ExeFile         = "Amiblitz3"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 20000
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 3.9.9
; NumberOfBuilds  = 469
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 64000
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 1246
; CursorColumn    = 23
; LabelSearch     = "abnormal"
; LabelRemark     = 0
; LabelAll        = 1
; LabelCase       = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 25
; Max GadgetList  = 5
; Max Shape       = 100
; Max Bank        = 5
; Max MenuList    = 5
; Max GTList      = 25
; Max Palette     = 4
; Max BitMap      = 10
; Max Screen      = 5
; Max IntuiFont   = 5
; Max BlitzFont   = 4
; Max Window      = 25
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: AmiBlitz3                                                             /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, AmigaOS4, MOS                         /
;/                                                                             /
;/ Date: 01.05.2022                                                            /
;/                                                                             /
;/ Authors: 1990...1996 Mark Silby                                             /
;/          1991...2003 Red When Excited                                       /
;/          2003...2009 Bernd Roesch, Sven Droege                              /
;/          2009...     The Opensource Team                                    /
;/          20
;/                                                                             /
;/ Requirements: AmigaOS3.1+                                                   /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Compiler and framework for AmiBlitz3 programming language.                  /
;/                                                                             /
;/ Abstract:  (sorry, German only)                                             /
;/ AmiBlitz3 ist eine freie Entwicklungsumgebung fuer AmigaOS3.x und           /
;/ Kompatible. Um zu erlaeutern, was es mit AmiBlitz3 auf sich hat,            /
;/ muss man bei BlitzBasic beginnen.                                           /
;/                                                                             /
;/ BlitzBasic, spaeter BlitzBasic2, ist ein urspruenglich von Acidsoft und     /
;/ Red When Excited (RWE) fuer den Amiga entwickelter, umfangreicher           /
;/ und ein wenig eigenwilliger Basic-Dialekt.                                  /
;/ Trotz der Popularitaet, die dieser in den 90er Jahren erreichte, sah man    /
;/ sich bei Acidsoft nach der Commodore-Pleite und dem nachfolgenden           /
;/ Niedergang des Amiga Marktes dazu gezwungen,                                /
;/ die Entwicklung von BlitzBasic2 auf dem Amiga einzustellen und sich         /
;/ ausschliesslich einer Version fuer Windows-PCs zu widmen.                   /
;/                                                                             /
;/ Auf Bestreben von Bernd Roesch durfte die Amiga-Version disassembliert      /
;/ und weiterenwickelt werden. Um eine Verwechslung mit der PC-Version zu      /
;/ vermeiden, firmiert diese mittlerweile ueberarbeitete Amiga-Version seitdem /
;/ unter dem Namen AmiBlitz2.                                                  /
;/                                                                             /
;/ Mit der Umgestaltung und Modernisierung der Entwicklungsumgebung            /
;/ sowie der gesamten Dateistruktur erfolgte die konsequente Fortfuehrung      /
;/ der Namensgebung zu AmiBlitz3.                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////

OPTIMIZE 5                               ; don't use FPU (opt. 4)
SYNTAX 6                                 ; syntax strictness


Macro regs2stack                         ; helper macro
  MOVEM.l d0-d7/a0-a6,-(a7)
End Macro

Macro stack2regs                         ; helper macro
  MOVEM.l (a7)+,d0-d7/a0-a6
End Macro

Macro DPrint
;  MOVE.l d0,-(a7)
  !regs2stack
  !basic
  !cout{`1}
  ;MouseWait
  !asm
  !stack2regs
;  MOVE.l (a7)+,d0
End Macro

NEWTYPE.configuration
  localization.b
  OnePassCompiling.b

  blitz3assign.s
  path_system.s
  path_blitzlibs.s
  path_residents.s
  path_baselibs.s
  path_utillibs.s
  path_oslibs.s
  path_cslibs.s
  path_userlibs.s
  path_includes.s
  pedfile.s
  ptr_seg_ped.l
  default_debugger.s
  ptr_seg_debugger.l
End NEWTYPE
SHARED config.configuration

NEWTYPE.libdata
  size_baselibs.l
  ptr_baselibs.l

  size_utillibs.l
  ptr_utillibs.l

  size_oslibs.l
  ptr_oslibs.l

  size_cslibs.l
  ptr_cslibs.l

  ptr_userlibs.l
End NEWTYPE
SHARED libdata.libdata




!initasm                                 ; some initial mumbo jumbo
!basic
WBStartup
SHARED cli_verbose.l
SHARED CLIMode.l
cli_verbose = -1
CLIMode     = False
MaxLen cli_tempstr.s = 1024
GetCurrentDirName_ &cli_tempstr,1024  ; get the current dir to restore it on exit
cli_path.s = Peek.s(&cli_tempstr)

;#USE_WBSTARTUPMSG = 0   -> removed for parsing WBmessage if AmiBlitz3 is started by an Project-Icon

XINCLUDE "/Shared/library_offsets.ab3"   ; needed includes
XINCLUDE "/Shared/common.ab3"
XINCLUDE "/Shared/preprocessor.include.ab3"
XINCLUDE "/Shared/ted.include.ab3"

XINCLUDE "dos.include.ab3"
XINCLUDE "file.include.ab3"
XINCLUDE "asl.include.ab3"

XINCLUDE "PE/logging.include.ab3"


.TOOLTYPES
; --
; -- check, if an assign-value was set via Tooltype
config\blitz3assign = dos_GetToolString{"ASSIGN",default_assign}                                                                                                                                                                                         
If config\blitz3assign <> ""
    *AssignSema.SignalSemaphore = FindSemaphore_(&config\blitz3assign)    ; does it already exist?
    If *AssignSema
      ObtainSemaphoreShared_ *AssignSema
    Else
      ; no, create one...
      *AssignSema = AllocVec_ (SizeOf.SignalSemaphore,#MEMF_PUBLIC|#MEMF_CLEAR)
      If *AssignSema
        InitSemaphore_ *AssignSema

        *AssignSema\ss_Link\ln_Name = AllocVec_(FLen(config\blitz3assign)+1,#MEMF_PUBLIC|#MEMF_CLEAR)
        If *AssignSema\ss_Link\ln_Name
          Poke.s  *AssignSema\ss_Link\ln_Name,config\blitz3assign
        End If
        *AssignSema\ss_Link\ln_Pri  = 1
        *AssignSema\ss_Link\ln_Type = #NT_SIGNALSEM

        AddSemaphore_ *AssignSema
        ObtainSemaphoreShared_ *AssignSema

      End If
    End If

  ; -- create our assign & config the directory variables
  mydir.s = dos_GetProgDir{"Sys:"}
  If NOT dos_CheckAssign{config\blitz3assign}
    dos_SetAssign{config\blitz3assign,mydir,False}
  EndIf
  If dos_CheckAssign{config\blitz3assign}
    If NOT dos_AddAssign{"LIBS:",dos_AddPart{config\blitz3assign,"Libs"}}
      error{"could not set assign: "+ config\blitz3assign + "  " + mydir}
    EndIf
  EndIf

  config\default_debugger= dos_AddPart{config\blitz3assign,"Debug/DefaultDBug"}     ; /REDDebugger"}

  If dos_GetToolState{"INCLUDEDIR"} =-1 Then config\path_includes = dos_GetToolString{"INCLUDEDIR",dos_AddPart{config\blitz3assign , "Sourcecodes/Includes"}}

  config\path_includes  = dos_AddPart{config\blitz3assign, "Sourcecodes/Includes"}
  config\path_system    = dos_AddPart{config\blitz3assign, "System"}
  config\path_residents = dos_AddPart{config\blitz3assign, "BlitzLibs/Residents"}
  config\path_blitzlibs = dos_AddPart{config\blitz3assign, "BlitzLibs"}
  dos_CreateDir{config\path_blitzlibs}
  dos_CreateDir{config\path_userlibs}
  dos_CreateDir{config\path_residents}
  dos_CreateDir{config\path_system}
EndIf


XINCLUDE "translation.include.ab3"
XINCLUDE "CLIModeSupport.ab3"
If dos_FromCLI{}
  CLIMode.l = True
  error_SetFlags{#error_stdout}
End If
 
; -- check, if there is an alternative PED-executable set via Tooltype
config\pedfile = dos_GetToolString{"EDITOR",dos_AddPart{config\path_system,"PED"}}

; -- check the default biglib files
If dos_GetToolState{"BASELIBS"} =-1 Then config\path_baselibs = dos_GetToolString{"BASELIBS",dos_AddPart{config\blitz3assign , "BlitzLibs/baseLibs"}}
If dos_GetToolState{"BASELIBS"} = 0
  dos_SetToolState{"BASELIBS",True}
  config\path_baselibs = dos_AddPart{config\blitz3assign , "BlitzLibs/baseLibs"}
EndIf
If dos_GetToolState{"UTILLIBS"} =-1 Then config\path_utillibs  = dos_GetToolString{"UTILLIBS",dos_AddPart{config\blitz3assign , "BlitzLibs/utilLibs"}}
If dos_GetToolState{"UTILLIBS"} = 0
  dos_SetToolState{"UTILLIBS",True}
  config\path_utillibs  = dos_AddPart{config\blitz3assign , "BlitzLibs/utilLibs"}
EndIf
If dos_GetToolState{"OSLIBS"}   =-1 Then config\path_oslibs   = dos_GetToolString{"OSLIBS"  ,dos_AddPart{config\blitz3assign , "BlitzLibs/OsLibs"}}
If dos_GetToolState{"OSLIBS"}   = 0
  dos_SetToolState{"OSLIBS",True}
  config\path_oslibs   = dos_AddPart{config\blitz3assign , "BlitzLibs/OsLibs"}
EndIf
If dos_GetToolState{"CSLIBS"}   =-1 Then config\path_cslibs   = dos_GetToolString{"CSLIBS"  ,dos_AddPart{config\blitz3assign , "BlitzLibs/CsLibs"}}
If dos_GetToolState{"CSLIBS"}   = 0
  dos_SetToolState{"CSLIBS",True}
  config\path_cslibs   = dos_AddPart{config\blitz3assign , "BlitzLibs/CsLibs"}
EndIf

config\path_userlibs = dos_AddPart{config\blitz3assign , "BlitzLibs/UserLibs"}

; -- check if One pass compiling is set as Tooltype to use big buffers for compiling  tomsmart1
config\OnePassCompiling = dos_GetToolState{"ONEPASSCOMPILING"}

If dos_GetToolState{"DISABLE_LOCALIZATION"}  = -1
  config\localization = False
Else
  config\localization = True
  !TRANS_INIT{"AmiBlitz3"}     ; init localization via translation.include
EndIf

If dos_GetToolState{"LOG_USED_BLITZLIBS"} = -1
  Poke.b ?log_blitzlibs,1
EndIf


;--- MorphOS Check to use the CacheClearE function because it is faster under MorphOS as CacheClearU
If ( FindResident_("MorphOS") )
  Poke.b ?MorphOS,1      ; set it to use CacheClear_E
Else
  Poke.b ?MorphOS,0      ; set it to use CacheClear_U
EndIf

; added here so the init is also available for the climode
; for create release exe (minimized exe)
 releaseexe.l               = False
 releasedbg_save.w          = 0
 releasemakesmall_save.b    = 0
 releasefuncoptimize_save.b = 0
 releasedebugger_save.b     = 0

; for compiler status info
 MaxLen comBaseStatus.s = 100
 MaxLen comstatusstr.s = 100 ; set the max leng of the comstatusstring because if it not set the string get partly trashed do the first compile from init to pass 1
 comBaseStatus  = !TRANS{"Initializing Compiler..."} ;default settings
 calcpro.l      = 0
 calcpro_old.l  = 0
 typ_old.l      = -1
 pass_old.l     = -1
 update_comstatus_gui.b = False ; for the first

; for .dbg file creation
#MAX_dbg_detokenlinesBufferSize = 131072                   ;was 65536  changed because we reduce detokenline size to MAX_Columns for the error info  tomsmart1
MaxLen dbg_detokenlinesBuffer.s = #MAX_dbg_detokenlinesBufferSize
dbg_fid.l = -1 ; no debug file id yet!

#defaultmaxerrorcount              = 99                    ; moved it to support the change of maxerrorcount in CLIMode  tomsmart1
Poke.l ?maxerrorcount,#defaultmaxerrorcount                ; set the default value  tomsmart1
If CLIMode
  ; We assume no error happened so far ...
  err.l      = False                                       ; indicate that an error has occured
  showhelp.l = False                                       ; show the CLI tool's help

  ; Set the default values of your CLI arguments.
  cli_progpath.s      = dos_GetProgDir{default_assign}    ; replaced hardcoded path  tomsmart1 2012 03 09
  cli_sourcefile.s    = ""
  cli_exefile.s       = ""
  cli_savefile.s      = ""
  cli_dumpfile.s      = ""
  cli_includepath.s   = ""
  cli_blitzlibpath.s  = ""
  cli_debuginfo.l     = False
  cli_run.l           = False
  cli_dumpflags.l     = $FFFFFFFF
  cli_info.s          = ""
  cli_release.l       = False
  cli_numargs.l       = dos_GetNumArgs{}
  cli_gui.l           = False
  cli_dumpform.l      = 1                     ; 0 = bin, 1 = ASCII
  cli_verbose.l       = 1
  cli_comdbgflags.l   = $00000000             ; added to support compiler and debugger settings via CLI  tomsmart1
  cli_comstrbufsize.l = 0
  cli_exestacksize.l  = 0
  cli_maxerrors.l     = 0                     ; added to make maxerrorcount changable in CLIMode  tomsmart1
  config\OnePassCompiling    = False
  If cli_numargs = 0 Then showhelp = True

  ; Get the CLI arguments
  Repeat
    arg.s = dos_GetNextArg{}                               ; get the next CLI argument
    larg.s = LCase$(arg)                                   ; lower case the option string
    If Left$(larg,1)="-" Then larg = Right$(larg,FLen(larg)-1)
    Select larg
      Case "s" : larg="source"
      Case "e" : larg="exe"
      Case "d" : larg="debug"
      Case "r" : larg="release"
      Case "h" : larg="help"
      Case "v" : larg="verbose"
      Case "1" : larg="1pass"
    End Select

    Select larg
      Case "exe"      : cli_exefile     = dos_GetNextArg{}
      Case "source"   : cli_sourcefile  = dos_GetNextArg{}
      Case "save"     : cli_savefile    = dos_GetNextArg{}
      Case "debug"    : cli_debuginfo   = True
      Case "run"      : cli_run         = True
      Case "release"  : cli_release     = True
      Case "ped"      : cli_gui         = True
      Case "dform"    : cli_dumpform.l  = Vallong(dos_GetNextArg{})
      Case "dump"     : cli_info        = LCase$(dos_GetNextArg{})
                        cli_dumpfile    = dos_GetNextArg{}
                        cli_dumpflags   = $0
                        If Instr(cli_info,"all"  ) Then cli_dumpflags | $FFFFFFFF
                        If Instr(cli_info,"token") Then cli_dumpflags | #DUMPFLG_TOKENS
                        If Instr(cli_info,"label") Then cli_dumpflags | #DUMPFLG_LABELS
                        If Instr(cli_info,"var"  ) Then cli_dumpflags | #DUMPFLG_VARS
                        If Instr(cli_info,"const") Then cli_dumpflags | #DUMPFLG_CONSTANTS
                        If Instr(cli_info,"func" ) Then cli_dumpflags | #DUMPFLG_FUNCTIONS
                        If Instr(cli_info,"macro") Then cli_dumpflags | #DUMPFLG_MACROS
                        If Instr(cli_info,"type" ) Then cli_dumpflags | #DUMPFLG_NEWTYPES
                        If Instr(cli_info,"lib"  ) Then cli_dumpflags | #DUMPFLG_LIBS
                        If cli_dumpflags = $0
                         err=True
                         NPrint "\\1b[1m*** ERROR: Invalid flags for dumpfile \\22",cli_info,"\\22 specified!\\1b[0m"
                        End If
      ;check cli compiler settings args  tomsmart1
      Case "setcom"   : cli_setcom.s    = LCase$(dos_GetNextArg{})
                        cli_comflags.l  = $0
                        If Instr(cli_setcom,"icon"  ) Then cli_comflags | #CLI_COMSETICONFLAG     ; create Icon
                        If Instr(cli_setcom,"small" ) Then cli_comflags | #CLI_COMSETSMALLFLAG    ; make smallest code
                        If Instr(cli_setcom,"func"  ) Then cli_comflags | #CLI_COMSETFUNCFLAG     ; use Functionoptimizer
                        If Instr(cli_setcom,"ldbg"  ) Then cli_comflags | #CLI_COMSETLDBGFLAG     ; link debug info (Symbols) to the exe
                        If Instr(cli_setcom,"dbgf"  ) Then cli_comflags | #CLI_COMSETDBGFFLAG     ; create a .dbf file
                        If (cli_comflags & #CLI_COMSETALLFLAGS) = 0                               ; test if args are correct
                          err=True                                                                ; no
                          NPrint "\\1b[1m*** ERROR: Invalid flags for setcom \\22",cli_setcom,"\\22 specified!\\1b[0m"
                        Else
                          cli_comdbgflags | cli_comflags                                          ; yes then add it
                        EndIf
      ;check cli debugger settings args  tomsmart1
      Case "setdbg"   : cli_setdbg.s    = LCase$(dos_GetNextArg{})
                        cli_dbgflags.l  = $0
                        If Instr(cli_setdbg,"auto" ) Then cli_dbgflags | #CLI_DEBUGAUTOFLAG       ; autorun
                        If Instr(cli_setdbg,"irq"  ) Then cli_dbgflags | #CLI_DEBUGIRQFLAG        ; interrupt check
                        If Instr(cli_setdbg,"asm"  ) Then cli_dbgflags | #CLI_DEBUGASMFLAG        ; assembler check
                        If Instr(cli_setdbg,"ofl"  ) Then cli_dbgflags | #CLI_DEBUGOFLFLAG        ; overflow check
                        If (cli_dbgflags & #CLI_DEBUGALLFLAGS) = 0                                ; yes then add it
                          err=True                                                                ; no
                          NPrint "\\1b[1m*** ERROR: Invalid flags for setdbg \\22",cli_setdbg,"\\22 specified!\\1b[0m"
                        Else
                          cli_comdbgflags | cli_dbgflags                                          ; yes then add it
                        EndIf
      Case "strbufsize": cli_comstrbufsize = Vallong(dos_GetNextArg{})
      Case "stacksize" : cli_exestacksize  = Vallong(dos_GetNextArg{})
      Case "maxerrors" : cli_maxerrors     = Vallong(dos_GetNextArg{})                              ; added to make the maxerrorcount changeable in CLI MODE  tomsmart1
                         If ((cli_maxerrors > 0) AND (cli_maxerrors <4097))                        ; check
                           Poke.l ?maxerrorcount,cli_maxerrors
                         EndIf
      Case "1pass"     : config\OnePassCompiling = True   ; added to use big buffers for compile so only 1 pass is needed  tomsmart1
      Case "verbose"   : cli_verbose      = Vallong(dos_GetNextArg{})
      Case "help"      : showhelp         = True             ; show the help and quit
      Default
        If arg><""
          NPrint "\\1b[1m*** ERROR: Unknown option \\22",arg,"\\22 specified!\\1b[0m"
          err = True
        End If
    End Select
  Until arg = "" OR err=True          ; until we processed all arguments

  ; Show the help if something went wrong or help was requested
  If err><False OR showhelp = True
    If showhelp
      NPrint "AmiBlitz ",Peek.s(?myversion)
      NPrint "\\nSyntax: AmiBlitz3 [options]"
      NPrint "\\nOptions:"
      NPrint "  -(s)ource <file>    : input source code filename (bb2, ab2 or ab3)"
      NPrint "  -(e)xe <file>       : output executable filename"
      NPrint "  -(d)ebug            : compile and start runtime debugger"
      NPrint "  -(r)elease          : create release executable (size optimized)"
      NPrint "  -run                : run compiled program"
      NPrint "  -dump <info> <file> : dump compiler internals to file"
      NPrint "                        (info=all|token|label|var|func|const|macro|type|lib)"
      NPrint "  -setcom <options>   : set compiler settings (options=icon|small|func|ldbg|dbgf)"       ; added  tomsmart1
      NPrint "  -setdbg <check>     : set debugger settings (check=auto|irq|asm|ofl)"                  ; added  tomsmart1
      NPrint "  -strbufsize <n>     : set the string buffer size of the compiler"                      ; added  tomsmart1
      NPrint "  -stacksize <n>      : set the stacksize for the exe if it run/debug"                   ; added  tomsmart1
      NPrint "  -maxerrors <n>      : set maxerrorcounter of the compiler (1-4096; default=99)"        ; added  tomsmart1
      NPrint "  -(1)pass            : use large buffers for compile"
      NPrint "  -dform <n>          : format of compiler internals dump (0=bin, 1=ASCII; default=1)"
      NPrint "  -PED                : start AmiBlitz3 IDE (PED)"
      NPrint "  -save <file>        : re-save source code (convert format, if needed)"
      NPrint "  -(v)erbose <n>      : set verbose level (0, 1 or 2; default=1)"
      NPrint "  -(h)elp             : show this help"
      NPrint "\\nExample:"
      NPrint "  AmiBlitz3 -s \\22DH0:Sourcecodes/MyProgram.ab3\\22 -e RAM:MyProgram.exe"
      NPrint "\\nNote: To start the AmiBlitz3 IDE, run from Workbench or with -PED option."
    End If
    Pop If : Pop If
    Goto abnormal_exit
  End If

  If cli_gui        Then CLIMode = False : error_SetFlags{#error_requester}
  If cli_sourcefile Then Poke.s ?str_tempfilename, cli_sourcefile
Else                                                                                                                                                                                                                                                    
  _wbArgs.b = dos_GetWBNumArgs{}                                                                                                                                                                                                                         
  If _wbArgs                                                                                                                                                                                                                                             
    ; parameter 0 is the name of the executable                                                                                                                                                                                                          
    ; all furher parameters are the command line options
    sdir.s = dos_GetStartDir{""}                                                                                                                                                                                                                         
    sfil.s = dos_GetWBArg{1}
    cli_sourcefile = dos_AddPart{sdir,sfil}
    Poke.s ?str_tempfilename, cli_sourcefile
  EndIf
End If

Poke.l ?CLIMode,CLIMode

; --
; -- Konstanten- und Variableninitialisierung
.DEFINITIONS
  #assign_fulltypecheck       = 0                            ; if 1 report long to word or other size reduction as error.
  #function_typecheck         = 1
  #function_support_returntype= 1
  #continue_on_error          = 1
  #maxincludes                = 128
  #64bitconstant              = 0
  #funcscan                   = 0                          ; if set to "1" functions are added at beginning
  #debugmacro                 = 1                          ; macros can be debugged
  #more6string                = 1                          ; more than 6 strings can be used in function calls
  #errorconstant              = 0                          ; constants declared twice check
  #types64                    = 1                          ; types can use 64kb
  #longbranch                 = 1                          ; if 1 then we have no 32kb limit
  #stopignore                 = 1                          ; ignore "STOP" on release build
  #debugtrap                  = 0                          ; only use if you want debug the trap#15 compile feature
  #fpudebug                   = 1                          ; allow fpu code for debugger
  #optibreak                  = 0                          ; set breakpoints on all optimzed positions
  #moremem                    = 40
  #isfunc                     = $21                        ; increase if morepars than 14
  #funcentry_extend           = 16+48                      ;+16 need for 10 pars +44 need for 10 par long of type addr and return type +4 gap for maybe later 4 par enhance
  #funcstruct_returntype      = $2a
  #funcstruct_parametertype   = $2e
  #doublecheck                = $00080d64

  #USENEWCACHECLEAR_U         = 0                          ; switch to use the new and faster CachClear, but it is not save only for testing !
  ; removed #USECACHECLEAR_E because we now use a detection for MorphOS to set the use of CacheClearE else we use CacheClearU (because on AOS4 it crashs with CacheClearE)!

  #TokenID_NEWTYPE   = $8001 ;-$7FFF  
  #TokenID_End       = $8002 ;-$7FFE  
  #TokenID_Goto      = $8005 ;-$7FFB  
  #TokenID_Gosub     = $8006 ;-$7FFA  
  #TokenID_Return    = $8007 ;-$7FF9  
  #TokenID_Statement = $8008 ;-$7FF8  
  #TokenID_Function  = $8009 ;-$7FF7  
  #TokenID_If        = $800b ;-$7FF5  
  #TokenID_While     = $800c ;-$7FF4  
  #TokenID_Macro     = $800d ;-$7FF3  
  #TokenID_Select    = $800e ;-$7FF2  
  #TokenID_INCLUDE   = $8012 ;-$7FEE  
  #TokenID_XINCLUDE  = $8013 ;-$7FED  
  #TokenID_SYNTAX    = $8014 ;-$7FEC  
  #TokenID_For       = $8016 ;-$7FEA  
  #TokenID_To        = $8018 ;-$7FE8  
  #TokenID_Step      = $8019 ;-$7FE7  
  #TokenID_CNIF      = $801C ;-$7FE4  
  #TokenID_CSIF      = $801D ;-$7FE3  
  #TokenID_CELSE     = $801E ;-$7FE2  
  #TokenID_CEND      = $801F ;-$7FE1  
  #TokenID_Then      = $8021 ;-$7FDF  
  #TokenID_Else      = $8022 ;-$7FDE  
  #TokenID_Dc        = $8025 ;-$7FDB  
  #TokenID_SizeOf    = $802F ;-$7FD1  
  #TokenID_SetInt    = $8030 ;-$7FD0  
  #TokenID_ABCD      = $803C ;-$7FC4  
  #TokenID_Chip      = $807F ;-$7F81  
  #TokenID_Not       = $8089 ;-$7F77  
  #TokenID_BSS       = $80AD ;-$7F53  
  #TokenID_List      = $80B3 ;-$7F4D  
  #TokenID_SetErr    = $80B4 ;-$7F4C  
  #TokenID_Ern       = $80B6 ;-$7F4A  
  #TokenID_Addr      = $80B8 ;-$7F48  
  #TokenID_Pi        = $80BA ;-$7F46  
  #TokenID_Repeat    = $80BB ;-$7F45  
  #TokenID_Maximum   = $80C4 ;-$7F3C  
  #TokenID_On        = $80C5 ;-$7F3B  
  #TokenID_Off       = $80C6 ;-$7F3A  
  #TokenID_Used      = $80D1 ;-$7F2F  
  #TokenID_Object    = $80D7 ;-$7F29  


  #TokenID_Null      =  $B594                      ; TokenID of NULL from Lib 107 token 20  (was token 1  = $B581) to overwrite by the compiler!
  #TokenID_New       =  $C982                      ; TokenID of New from Lib 147 token "New" ($4982; LotanSystem)
  Dim incdim.s (#maxincludes)
  Dim incline.l(#maxincludes)

  hashsize                    EQU $3ff                     ;$ff=256,$1ff=512,$3ff=1024,$7ff=2048,$fff=4096


; --
; -- Macro definitions
.MACROS

Macro hashalgo                                             ;d1 currentchar d0 hashvalue
  MULS.w #5,d0                                             ;important for fast hash speed
  ADD.l d1,d0
End Macro


Macro newcalc
  MOVE.l destpointer,a1
  MOVE.l #$4e754e75,(a1)+                                 ; opcode: rts rts
  MOVEQ #0,d1
  MOVE.w (a0)+,d1

  CMP.l #$303c,d1                                         ;move.w    ;d0
  BNE 'nw1
    MOVE.w (a0)+,d0
    CMP.w #$48c0,(a0)                                     ;ext.l
    BNE 'nw2
      EXT.l d0
      ADDQ.l #2,a0
      BRA 'nw2
 'nw1
    CMP.l #$323c,d1                                       ;move.w     ;d1
    BNE 'nw1_w
      MOVE.w (a0)+,d1
      CMP.w #$48c1,(a0)                                   ;ext.l
      BNE 'nw2
        EXT.l d1
        ADDQ.l #2,a0
        BRA 'nw2
   'nw1_w
      CMP.l #$203c,d1                                     ;move.l #,d0
      BNE.s 'nw2_w                                        ;fault
        MOVE.l (a0)+,d0
        BRA 'nw2
     'nw2_w
      ;   CMP.l #$243c,d1                                 ;move.l #,d2
      ;   BNE 'nw2_d2
      ;   MOVE.l (a0)+,d2
      ;BRA 'nw2
     'nw2_d2
      CMP.l #$223c,d1                                     ;move.l #,d1
      BNE.s 'Fals`@                                       ;fault
        MOVE.l (a0)+,d1
 'nw2
;   CMP.w #$243c,(a0)
;   BNE.s 'nod2`@                                         ;no d2 load
;   MOVE.l 2(a0),d2
;   ADDQ.l #6,a0
 'nod2`@
  CMP.w #$223c,(a0)
  BNE.s 'nod1`@                                           ;no d1 load
    MOVE.l 2(a0),d1
    ADDQ.l #6,a0
 'nod1`@
;   CMP.w #$d081,(a0)
;   BNE.s 'noadd_l_d1                                     ;no add l d1,d0
;   ADD.l d1,d0
;   ADDQ.l #2,a0

; 'noadd_l_d1
  CMP.w #$d0bc,(a0)
  BNE.s 'noadd_i_d0                                       ;no add.l #,d0
    ADDQ.l #2,a0
    ADD.l (a0)+,d0
    BRA 'nosub_w_d2
 'noadd_i_d0

  CMP.w #$90bc,(a0)
  BNE.s 'nosub_i_d0                                        ;no sub.l #,d0
    ADDQ.l #2,a0
    SUB.l (a0)+,d0
    BRA 'nosub_w_d2
 'nosub_i_d0

  CMP.w #$8081,(a0)
  BNE.s 'noor_d1_d0                                       ;no or.l d1,d0
    ADDQ.l #2,a0
    OR.l d1,d0
    BRA 'nosub_w_d2
 'noor_d1_d0

  CMP.w #$d07c,(a0)
  BNE.s 'noadd_w_d1                                       ;no add w #,d0
    ADDQ.l #2,a0
    ADD.w (a0)+,d0
 'noadd_w_d1

  CMP.l #$4c3c0800,(a0)
  BNE.s 'nomul_l_d1                                       ; no mul.l #,d0
    MOVE.l d1,-(a7)
    ADDQ.l #4,a0
    MOVE.l (a0)+,d1
    MULS.l d1,d0
    MOVE.l (a7)+,d1
 'nomul_l_d1

  CMP.w #$94bc,(a0)
  BNE.s 'nosub_i_d2                                       ;no sub l #,d2
    ADDQ.l #2,a0
    SUB.l (a0)+,d2
 'nosub_i_d2

  CMP.w #$9081,(a0)
  BNE 'nosub_l_d1
    SUB.l d1,d0                                             ;no sub l d1,d0
    ADDQ.l #2,a0
 'nosub_l_d1
;   CMP.w #$9041,(a0)
;   bne 'nosub_w_d2
;   SUB.w d1,d0                                             ;no sub w d1,d0
;   ADDQ.l #2,a0

; 'nosub_w_d1
;   CMP.w #$9282,(a0)
;   BNE 'nosub_l_d2
;   SUB.l d2,d1                                             ;no sub l d2,d0
;   ADDQ.l #2,a0

; 'nosub_l_d2
;   CMP.w #$9242,(a0)
;   BNE'nosub_w_d2
;   SUB.w d2,d1                                             ;no sub w d2,d1
;   ADDQ.l #2,a0
 'nosub_w_d2

  CMP.w #$4480,(a0)
  BNE.s 'noneg`@                                          ;no neg
    NEG.l d0
    ADDQ.l #2,a0
 'noneg`@

  CMP.w #$48c0,(a0)                                       ; noext
  BNE 'noext
    EXT.l d0
    ADDQ.l #2,a0
 'noext

  CMP.w #$b081,(a0)                                       ; nocmp
  BNE 'nocmp
    ADDQ.l #2,a0
    CMP.w #$57c0,(a0)
    BNE 'se1
      CMP.l d1,d0
      SEQ d0
      BRA 'sw1
   'se1
    CMP.w #$56c0,(a0)
    BNE 'Fals`@
      CMP.l d1,d0
      SNE d0
   'sw1
    EXT.w d0
    ADDQ.l #6,a0
 'nocmp

  CMP.w #$4e75,(a0)                                       ; is last instruction
  BNE 'Fals`@
    TST.w regnum
    BNE 'Fals`@
      MOVEQ #1,d1
      BRA.s 'ok`@
 'Fals`@
  MOVEA.l forthsp(PC),A0
  MOVEQ #0,d1
 'ok`@
End Macro


Macro compare3
  TST.w D0
  BEQ.w 'lab1`@
  CMP.w #$3A,D0   ; 58   ":"
  BEQ.w 'lab1`@
  CMP.w #$2C,D0   ; 44   ","
 'lab1`@
End Macro


Macro test_for_letter
  CMP.w #$7A,D0  ; 122   "z"
   BHI 'lab2a`@
  CMP.w #$41,D0  ; 65    "A"
   BCS 'lab2a`@
  CMP.w #$61,D0  ; 97    "a"
   BCC 'lab1a`@
  CMP.w #$5A,D0  ; 90    "Z"
   BHI 'lab1a`@

 'lab1a`@
  CMP.w D0,D0

 'lab2a`@
End Macro


Macro fget
  MOVEQ #0,d0

 'laba1`@
  MOVE.l a5,lastsourcepos
  MOVE.b (a5)+,d0
  TST.w instringon
  BNE 'laba2`@
    CMP.b #$20,d0   ; 32 " "
    BEQ 'laba1`@
      CMP.b #";",d0
      BNE 'laba2`@
        MOVEQ #0,d0
 'laba2`@
  MOVE.w d0,lastchar
End Macro


;Macro fget2
;  MOVEQ #0,d0
;
; 'lab1`@
;  MOVE.l a5,lastsourcepos
;  MOVE.b (a5)+,d0
;  TST.w instringon
;  BNE 'lab2`@
;    CMP.b #$20,d0  ; 32 " "
;    BEQ 'lab1`@
;      CMP.b #";",d0
;        BNE 'lab2`@
;          MOVEQ #0,d0
; 'lab2@`
;  MOVE.w d0,lastchar
;End Macro
;

Macro test_for_literal
  CMP.w #$30,D0   ; 48 "0"
   BCS.w 'lab1`@
  CMP.w #$39,D0   ; 57 "9"
   BHI.w 'lab1`@
  CMP.w D0,D0

 'lab1`@
End Macro


Function.s Get_Libinfo{addr_libnum.l}
  ; diese Funktion holt aus der nativen lib im Speicher den ersten Tokennamen
  lib_ab2.b = False : lib_os.b = False
  addr_counter.l = addr_libnum
  skip.l = 0
  If addr_counter=0
    error{"INTERNAL: \\__THIS_FUNCTION: Invalid pointer!"}
    Function Return ""
  End If
;  runner.l = 0
;  !cout{Hex$(addr_counter)}
  Repeat
    mem.l = Peek.l(addr_counter)
;    If (runner MOD 8 = 0) AND (runner < $80)
;        !cout{Hex$(addr_counter)+": "+Hex$(mem) + " " + Hex$(Peek.l(addr_counter + 4))+"   "+Hex$(mem LSR 16)}
;    EndIf
;    runner + 2
    addr_counter + 2
    If (mem = $0000ffff) Then lib_ab2= True : skip = 8
    If (mem LSR 16) = $ffe2
;      !cout{"found."}
      lib_os = True
      skip = 10
      If Peek$(addr_counter+skip) = "" Then skip + 4
    EndIf
  Until (lib_ab2=True OR lib_os = True) OR (addr_counter>addr_libnum + $400)
  ;!cout{Hex$(addr_libnum),Peek$(addr_counter + skip),Peek$(addr_counter + skip+1),Peek$(addr_counter + skip+2)   }
  If (addr_counter>addr_libnum + $400)
;    !cout{"error"}
    Function Return ""
  Else
    Function Return Peek$(addr_counter + skip)
  EndIf
End Function



;d2 mode  1=byte 2 =word 3=long 4=quick 5=float  bit 15 newtype
;a3=current instruction struct
;34(a3)=Instruction Token

;SECTION "Segment0",CODE
;cnop 0,4
       ;labelbase   $0
                    ; $4 mode 0 = label 1 = constant
                    ; $8 addr/label value/constant
                    ; $c nexthash
                    ; $12 Bytecount
                    ; $13 name

       ;templabel   ; $0 next
                    ; $4 addr in code
                    ; $8 = resultmode 5 = word
                    ; $a
                    ; $e templabelsize
                    ; $10 addr in source or short string
       ;variable    ; $0
                    ; $4 offset of a5
                    ; $8 size
                    ; $a type addr add+4 for findvariable2 to find offset for Newtype
      ;typestruct
      ;             ; $4 Adress to typeitemlist or 1-7 if no structure
                    ; $8 size of newtype
      ;typeitemlist
                    ; $0 * nexttypeentry
                    ; $4.w Offset
                    ; $6
                    ; $8
                    ; $a addr to variable
                    ; $e name

; ------------------------------------------ BEGIN OF MAINPROGRAM -------------------------------
.MAINPROGRAM     ; was actual begin org source
  ;
  ;OKAY, Here it is - The actual compiler!
  ;
  ;
  ; new >
  !asm
  MOVEA.l _execbase,A6
  MOVEM.l d0/a0,-(a7)

  MOVEQ #127,d0
  LEA chartab,a0
 'l12
    MOVE.b #1,128(a0)
    CLR.b (a0)+
  DBF d0,'l12

  LEA chartab,a0
  MOVE.b #1,(a0)
  MOVE.b #1,","(a0)
  MOVE.b #1,";"(a0)
  MOVE.b #1,":"(a0)
  MOVE.b #1,"("(a0)
  MOVE.b #1,")"(a0)
  MOVE.b #1,"="(a0)
  MOVE.b #1,"+"(a0)
  MOVE.b #1,"-"(a0)
  MOVE.b #1,"*"(a0)
  MOVE.b #1,"/"(a0)
  MOVE.b #1,"$"(a0)
  MOVE.b #1,"%"(a0)
  MOVE.b #1,"."(a0)
  MOVE.b #1,"["(a0)
  MOVE.b #1,"]"(a0)
  MOVE.b #1,"{"(a0)
  MOVE.b #1,"}"(a0)
  MOVE.b #1,"\"(a0)
  MOVE.b #1,">"(a0)
  MOVE.b #1,"<"(a0)
  MOVE.b #1,"&"(a0)
  MOVE.b #1,"|"(a0)
  MOVE.b #1,"^"(a0)
  MOVE.b #1,$7e(a0)
  MOVE.w #$0101,1(a0)

  LEA instrtab,a0
  MOVE.l #labelhash-instrtab,d0
  ASR.l #2,d0
  SUBQ.l #1,d0

 'l10
   CLR.l (a0)+
   SUBQ.l #1,d0
  BNE 'l10

  LEA allowtab,a0
  MOVE.l #255,d0

 'la1
    CLR.b (a0)+
  DBF d0,'la1

  LEA allowtab,a0
  MOVE.b #1,$7d(a0)   ; }
  MOVE.b #1,$7c(a0)   ; pipe
  MOVE.b #1,$44(a0)   ; D
  MOVE.b #1,$45(a0)   ; E
  MOVE.b #1,$b9(a0)   ;
  MOVE.b #1,$89(a0)
  MOVE.b #1,$ce(a0)
  MOVE.b #1,$cf(a0)
  MOVE.b #1,$d0(a0)
  MOVE.b #1,$cd(a0)
  MOVEQ #0,d0

  ;MOVEA.l _execbase,a6
  ;MOVE.l #$10000,d0
  ;MOVE.l #80000,d1
  ;MOVE.l d1,d2
  ;JSR _CreatePool(a6)                                      ; alloc memory for own stuff
  ;MOVE.l d0,mempool
  !basic
  Poke.l ?mempool, CreatePool_(#MEMF_CLEAR,80000,80000)
  !asm

  MOVEM.l (a7)+,d0/a0

  TST.l mempool
  BEQ shutdown_compiler

  !basic
  *eb.ExecBase = execbase
  *compilerTask.Task = *eb\ThisTask
  !asm
  BSR.w open_doslibrary
  BEQ.w shutdown_compiler

  ;MOVE.l D2,stacksize
  MOVE.l #MIN_STACKSIZE,stacksize

  ; --
  ; -- get the last token of systemlib
  MOVEQ.l #$00,D0
  LEA tokens,A0
 'loop
    ADDQ.w #1,D0
    MOVE.l (A0),D1
    BEQ.w 'gotlast
      MOVEA.l D1,A0
  BRA.w 'loop
 'gotlast
  MOVE.l A0,end_of_tokenlist

  JSR make_AssemblerTable

  MOVE.w #$FFFF,returncode_org

  BSR.w open_mathlibrary
  BEQ.w freemem_and_quit4

  MOVE.l constmaxpc,D0
  MOVEQ.l #$02,D1                                          ;chipmem            ;01 org source
  MOVEA.l _execbase,A6
  JSR _AllocMem(A6)                                        ;mem for branch routine
  MOVE.l D0,constpcat
  BEQ.w freemem_and_quit3
  ADD.l constmaxpc,D0
  MOVE.l D0,constlibat

  MOVE.l macrobuffer_size,D0
  CMP.l #DEFAULT_MACROBUFFERSIZE,d0
  BGE 'ok
    MOVE.l #DEFAULT_MACROBUFFERSIZE,d0
    MOVE.l d0,macrobuffer_size
 'ok
  ADDQ.l #4,d0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  JSR _AllocMem(A6)                                          ; allocate memory for macros

  MOVE.l d0,a0
  MOVE.l macrobuffer_size,(a0)+
  MOVE.l a0,d0

  MOVE.l D0,ptr_macrobuffer_begin
  BEQ.w freemem_and_quit2
  ADD.l macrobuffer_size,D0
  MOVE.l D0,ptr_macrobuffer_end
  ;
  ; new >
  TST.l CLIMode
  BEQ load_ped                                               ;/* Emulate PED Environment */
    !basic
    succ.l = InitEmulatedPED{}
    GetReg D0,succ
    ;GetD0 succ
    !asm
    TST.l d0
    BEQ freemem_and_quit
    BRA skip_ped
 .load_ped:
    !basic
    config\ptr_seg_ped = LoadSeg_(config\pedfile)
    GetReg D0,config\ptr_seg_ped
    !asm
    TST.l D0
    BEQ.w cant_load_PED
    ; --
    ; -- calculate entryaddress for starting segment (BPTR)
    MOVEA.l D0,A2
    ADDA.l A2,A2
    ADDA.l A2,A2

    LEA teddata,A1                                           
    MOVE.l #"TEDY",D1 : JSR 4(A2)                            ; Run PED, TODO: use Basic "Call"

    MOVE.l A0,ped_startup_addr                               ; PED returns address of routine "startup_code"
    MOVE.l A1,comdata                                        ; PED returns address of comdata-area in A1

    !ComData_GetW{comWord_PEDIsAvailable,D0}                 ; if PED_IsAvailable=0, quit AmiBlitz
    BEQ.w unload_ped
 
    CMP.w ##ComDataVersionID,d0                              ; test if it the Ped version matched the compiler version
    BNE old_version_of_PED                                   ; no, than exit

 .skip_ped:
  !ComData_GetL{comData_Magic,D0}
  CMP.l ##MagicIdentifier_Long,D0                          ;"~::~",D0    ; replace with a constant  tomsmart1 2012 03 09
  BNE unload_ped

  ; -- extent_comdatas:
  !ComData_SetL{comPtr_Trap15            ,#directTrap15}
  !ComData_SetL{comPtr_DirectBuffer      ,#directbuffer}
  !ComData_SetL{comPtr_MacroBase         ,#macrobase}
  !ComData_SetL{comPtr_VarBase           ,#varbase}
  !ComData_SetL{comPtr_InstrBase         ,#instrtab}
  !ComData_SetL{comPtr_LibPointer        ,#libpointer}
  !ComData_SetL{comPtr_CompilerVersion   ,#myversion}
  !ComData_SetL{comPtr_VersionInformation,#versioninformation}
  !ComData_SetL{comPtr_NumberOfBuilds    ,#number_of_builds}
  !ComData_SetL{comFunc_SaveSource       ,#ab3_SaveSource}
  !ComData_SetL{comFunc_LoadSource       ,#ab3_LoadSource}
  !ComData_SetL{comFunc_ClearSource      ,#ab3_ClearSource}

  ; added by tomsmart1 for Calculator window in PED 2012 03 07
  !ComData_SetL{comFunc_CalculatExpression       ,#menu_calculator}
  !ComData_SetL{comPtr_CalculatorExpressionString,#str_calcexpression}

  ; added by tomsmart1 for compilersettingswin in PED 2012 03 22
  !ComData_SetL{comFunc_BackupXtraData           ,#BackupXtraData}
  !ComData_SetL{comFunc_RestoreXtraData          ,#RestoreXtraData}

  !ComData_SetL{comFunc_GetObjectEntry           ,#getobjectentry}
  !ComData_SetL{comFunc_StoreMaxObjects          ,#storemaxobjects}

  !ComData_SetL{comFunc_ReloadResidentsForPED    ,#ReloadResidentsForPED}
  !ComData_SetL{comFunc_FreeClearResidentsForPED ,#FreeClearResidentsForPED}    ; add tomsmart1 2012 06 09

  !ComData_SetL{comPtr_Residents_Table           ,#residents_table}
  !ComData_SetL{comPtr_StringBuffer_Long         ,#stringbuffer}
  !ComData_SetL{comPtr_Stacksize_Long            ,#stacksize}
  !ComData_SetL{comPtr_Create_IconFile_Byte      ,#create_iconfile}
  !ComData_SetL{comPtr_Make_SmallestCode_Byte    ,#make_smallestcode}
  !ComData_SetL{comPtr_Link_DebugInfo_Byte       ,#link_debuginfo}
  !ComData_SetL{comPtr_Use_Debugger_Byte         ,#use_debugger}
  !ComData_SetL{comPtr_Autorun_Byte              ,#autorun}
  !ComData_SetL{comPtr_InterruptCheck_Byte       ,#interruptcheck}
  !ComData_SetL{comPtr_AssemblerCheck_Byte       ,#assemblercheck}
  !ComData_SetL{comPtr_OverflowCheck_Byte        ,#overflowcheck}
  !ComData_SetL{comPtr_Number_of_Objects_Word    ,#number_of_objects}
  !ComData_SetL{comPtr_MaxObjects_Value_Word     ,#maxobjects_value}
  !ComData_SetL{comPtr_MaxObject_Pos_Word        ,#maxobject_pos}

  ; added by tomsmart1 for setcliargswin in PED 2013 12 02
  !ComData_SetL{comPtr_CLIArgumentsString       ,#str_cliarguments}
  CLR.w returncode_org

  !basic
  If CLIMode
    If cli_verbose >= 3 Then NPrint !TRANS{"Loading BlitzLibs..."}
  End If

  ; --
  ; -- load all baselibs, utillibs and userlibs
.load_libraries
  !asm
  MOVE.l #$FFFFffff,linenumat   ; was -1
  !basic
  Gosub scan_for_userlibs
  Gosub load_all_libraries
  !asm
  BSR.w init_buffers
  !basic

  ;--
  ;-- grab a panic bit
  ;--
  !asm
  MOVEQ.l #-$01,D0
  MOVEA.l _execbase,A6
  JSR _AllocSignal(A6)
  MOVE.l D0,signalNum
  MOVEQ.l #$00,D1
  BSET D0,D1              ; set the bit with number D0 in D1
  MOVE.l D1,signals

  ; --
  ; -- load_debugger:
  ; --
  ; -- loadseg default debugger (blitz2:dhandler)
  ;
  ;MOVE.l #str_defaultdbug,D1
  ;MOVEA.l _dosbase(PC),A6
  ;JSR _LoadSeg(A6)
  ;MOVE.l D0,ptr_seg_debugger
  !basic
  config\ptr_seg_debugger = LoadSeg_(config\default_debugger)
  If config\ptr_seg_debugger = 0
    error{!TRANS{"The Debugexecutor `Defaultdbug` was not found.\\nDebugging is not possible."}}
  EndIf

  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ AmiBlitz3 Command Line Interface                                           /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  ;TST.l CLIMode
  ;BEQ run_ped
  ;!basic
  If CLIMode = False Then Goto run_ped
  err.l = False

  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ Resolve pathes                                                             /
  ;/ Get the full qualified path for source code and executable file            /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  If cli_sourcefile
    lock.l = Lock_(&cli_sourcefile,#ACCESS_READ)
    If lock
      NameFromLock_ lock,&cli_tempstr,1024
      cli_sourcefile.s = Peek.s(&cli_tempstr)
      UnLock_ lock
    End If

    If cli_exefile
      SetCurrentDir{dos_PathPart{cli_sourcefile}}
      path.s = dos_PathPart{cli_exefile}
      lock.l = Lock_(&path,#ACCESS_READ)
      If lock
        NameFromLock_ lock,&cli_tempstr,1024
        path.s = Peek.s(&cli_tempstr)
        cli_exefile = dos_AddPart{path,dos_FilePart{cli_exefile}}
        UnLock_ lock
      End If
    End If
  End If

  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ Initialize Token Hashmap                                                   /
  ;/ Get the token hashmap to tokenize/detokenize source code files             /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  If cli_verbose >= 3 Then NPrint "Initializing token hashmap..."
  TokenHashMapFile.s = dos_AddPart{config\path_system,"TokenList.hashmap"}           ; replaced hardcoded path  tomsmart1 2012 03 09
  *PreProcessor.preprocessor = preproc_Create{}
  Poke.l ?comPtr_PreProcessor,*PreProcessor
  preproc_LoadTokens{*PreProcessor,TokenHashMapFile}
  If *PreProcessor\tokens=Null
    If cli_verbose >= 1 Then NPrint "No hashmap found (\\22"+TokenHashMapFile+"\\22), will be created..."
    preproc_QueryTokens{*PreProcessor}
    preproc_SaveTokens{*PreProcessor,TokenHashMapFile}
  End If

  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ Load and Compile Sourcecode                                                /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  If cli_sourcefile><"" AND err=False
    If cli_verbose>=3 Then NPrint "Loading sourcecode \\22",cli_sourcefile,"\\22..."
    succ = LoadSource{cli_sourcefile}
    If succ
      If cli_savefile=""                                                        ; added check if -save is used then we skip compiling and only save the source  tomsmart1
        If cli_verbose>=1 Then NPrint "Compiling \\22"+cli_sourcefile+"\\22..."
        comerr.l = CompileSource{cli_exefile,cli_debuginfo,cli_release,cli_comdbgflags,cli_comstrbufsize} ; expand to support CLI compiler and debugger settings  tomsmart1

        If comerr
        ; NPrint "*** ERROR: Error compiling source!"
        Else
        ; success!!!
        End If
      EndIf
    Else
      If cli_verbose>=0 NPrint "\\1b[1m*** ERROR: Unable to read source file!\\1b[0m" : err=True
    End If
  EndIf

  If cli_savefile><"" AND err=False
    If cli_verbose>=2 Then NPrint "Saving sourcefiles as "+cli_savefile+"..."
    SaveSource{cli_savefile}
  End If

  If cli_dumpfile><"" AND err=False
    If cli_verbose>=2 Then NPrint "Saving dumpfile..."
    DumpFile{cli_dumpfile,cli_dumpflags,cli_dumpform}
  End If

  If cli_run
    If comerr=False
      If cli_exefile
        If cli_verbose>=1 Then NPrint "Recompiling "+cli_sourcefile+" for debug..."
        comerr.l = CompileSource{"",cli_debuginfo,cli_release,cli_comdbgflags,cli_comstrbufsize} ; re-compile for launch! ; expand to support CLI compiler and debugger settings  tomsmart1
      End If
      If cli_verbose>=1 Then NPrint "Running program..."
      RunSource{cli_debuginfo,cli_exestacksize}         ; added debug info to indicate ted.lib use becaus is only needed for Debugging  tomsmart1 2011 06 11
      Repeat
        CLR.l d0
        !ComData_GetB{comByte_RunningFlag,D0}
        PutReg D0,running.l
        If running Then Delay_ 50
        ;NPrint "Runnign flag: ",running
      Until running=False
      If Peek.l(?_runerror)
        If cli_verbose>=0 Then NPrint "\\1b[1m*** ERROR: Unable to run compiled program!\\1b[0m" : err=True
      End If
    End If
  End If


  ;//////////////////////////////////////////////////////////////////////////////
  ;/                                                                            /
  ;/ Cleanup and prepare for exit                                               /
  ;/                                                                            /
  ;//////////////////////////////////////////////////////////////////////////////
  preproc_Free{*PreProcessor} : *PreProcessor=Null
  If cli_verbose >= 3 Then NPrint "Exit AmiBlitz3."
  DeinitEmulatedPED{}

  !asm
  JMP terminate_ab3

.run_ped
  !asm
  ; -- jump to the address ped returned before and pass a sourcename in A0
  LEA str_tempfilename,A0
  MOVEA.l ped_startup_addr,A1 : JSR (A1)

  ; -- wait until PED das been quit !!
                                                                                                                                                                                                                                                        
.terminate_ab3             ; was 'skip
  !basic
  FreeSignal_ Peek.l(?signalNum)
  If config\ptr_seg_debugger > 0 Then UnLoadSeg_ config\ptr_seg_debugger
  !asm

  BSR.w Aclearallvars
  BSR.w free_residents
  JSR free_blitzlibs

unload_ped:    ; was fail3 in org source
  !basic
  If config\ptr_seg_ped Then UnLoadSeg_ config\ptr_seg_ped
  !asm
  BRA freemem_and_quit     ; added by tomsmart1 for Ped errormessage

.old_version_of_PED:
  !basic
  error{!TRANS{"Old version of the Editor found at:\\n"} + pedfile$ + !TRANS{"\\nProgram will quit now."} }  ; show error message  tomsmart1
  !asm
  BRA freemem_and_quit

.cant_load_PED:
  !basic
  error{!TRANS{"Can't load the Editor:\\n"} + pedfile$ + !TRANS{"\\nProgram will quit now."} }  ; show error message  tomsmart1
  !asm


freemem_and_quit:         ; was fail2a
  BSR.w freeallox

  MOVEA.l ptr_macrobuffer_begin,A1
  ; new >
  MOVE.l -(a1),D0
  ADDQ.l #4,d0
  ; < new
  MOVEA.l _execbase,A6
  JSR _FreeMem(A6)

freemem_and_quit2:         ; was fail2

  ;MOVEA.l _dosbase,A1
  ;MOVEA.l _execbase,A6
  ;JSR _CloseLibrary(A6)

  ;MOVEA.l constpcat,A1
  ;MOVE.l constmaxpc,D0
  ;MOVEA.l _execbase,A6
  ;JSR _FreeMem(A6)
  !basic
  CloseLibrary_ Peek.l(?_dosbase)
  FreeMem_ Peek.l(?constpcat), Peek.l(?constmaxpc)
  !asm

freemem_and_quit3:         ; was failme
  ;MOVEA.l _mathffpbase,A1
  ;MOVEA.l _execbase,A6
  ;JSR _CloseLibrary(A6)
  !basic
  If Peek.l(?_mathffpbase) CloseLibrary_ Peek.l(?_mathffpbase)
  !asm

freemem_and_quit4:         ; was fail0
  ; new >                           ; added delete of mempool2  tomsmart1
  ;TST.l mempool2                    ; test if mempool2 is allocated
  ;BEQ shutdown_compiler             ; no jump
  ;  MOVEA.l _execbase,A6            ; yes delete it to free the memory
  ;  MOVE.l mempool2,a0
  ;  JSR _DeletePool(a6)
  ;  CLR.l mempool2
  !basic
  If Peek.l(?mempool2)
    DeletePool_ Peek.l(?mempool2)
  EndIf
  !asm

shutdown_compiler:
  ;TST.l mempool
  ;BEQ skip_freemempool
  ;  MOVEA.l _execbase,A6
  ;  MOVE.l mempool,a0
  ;  JSR _DeletePool(a6)
  ;skip_freemempool:

  ; < new
  !basic
  If Peek.l(?mempool)
    DeletePool_ Peek.l(?mempool)
  EndIf
  !asm
  CLR.l mempool
  CLR.l pushat
  JSR free_unusedfunctions
  MOVEQ #0,d0

abnormal_exit:
  !exitasm

  If config\blitz3assign  <> ""
    If *AssignSema
      ReleaseSemaphore_ *AssignSema
      If (AttemptSemaphore_ (*AssignSema))                 ; we are the exclusive owner of the sema now!
        If dos_RemAssign{"LIBS:",dos_AddPart{config\blitz3assign ,"Libs"}}
          ;If KickVersion < 47                              ; AssignLock_ freezes with OS 3.2 !
!cout{"removing assign"}
            If NOT dos_RemAssign{config\blitz3assign }
              error{"Could not remove assign: " + config\blitz3assign }
            EndIf
!cout{"assign successfully removed"}
          ;EndIf
        Else
          error{"Could not remove assign: " + dos_AddPart{config\blitz3assign ,"Libs"}}
        EndIf

        RemSemaphore_ *AssignSema
        ReleaseSemaphore_ *AssignSema

        If *AssignSema\ss_Link\ln_Name Then FreeVec_ *AssignSema\ss_Link\ln_Name : *AssignSema\ss_Link\ln_Name = Null
        FreeVec_ *AssignSema
        *AssignSema = Null
      End If
    End If
  EndIf

  SetCurrentDir{cli_path}
  !coutclose
End
; ------------------------------------------ END OF MAINPORGRAM --------------------------------


str_doslibrary:     Dc.b "dos.library",0 : Even
_dosbase:           Ds.l 1


.open_doslibrary:
  MOVEA.l _execbase,A6
  LEA str_doslibrary,A1
  JSR _OldOpenLibrary(A6)
  MOVE.l D0,_dosbase
RTS


.open_mathlibrary:
  MOVEA.l #str_mathffpname,A1
  MOVEA.l _execbase,A6
  JSR _OldOpenLibrary(A6)
  MOVE.l D0,_mathffpbase
RTS

.ab3_SaveSource:
  !basic
  PutReg D0,ab3save_filenameP.l
  If ab3save_filenameP
    ab3save_filename.s = Peek.s(ab3save_filenameP)
    ;error{"...as "+ab3save_filename}
    SaveSource{ab3save_filename}
  Else
    error{"INTERNAL ERROR: no filename passed in D0 to SaveSource{}!"}
  End If
  !asm
RTS
 
.ab3_LoadSource:
  !basic
  PutReg d0,ab3save_filenameP.l
  If ab3save_filenameP
    ab3save_filename.s = Peek.s(ab3save_filenameP)
    LoadSource{ab3save_filename}
  Else
    error{"INTERNAL ERROR: no filename passed in D0 to LoadSource{}!"}
  End If
  !asm
RTS

.ab3_ClearSource:
  !basic
  ClearSource{}
  !asm
RTS

.ab3_OpenConsole:
  !basic
  OpenConsoleFake{}
  !asm
RTS


.ab3_CloseConsole:
  !basic
  CloseConsoleFake{}
  !asm
RTS


.call_menuentry:
  MOVE.w D6,menuitemdebug                ; D6 comes from PED
  !regs2stack
  !basic
  menuitemx.w = Peek.w(?menuitemdebug)
  If menuitemx > 16 OR menuitemx < 0
    error{"Called invalid AB3 Menuitem #" + Hexw$(menuitemx) + "!"}
    menuitemx = 0
;  Else
;    error{"calling compilermenu: " + Hex$(menuitemx)}
  End If
  Poke.w ?menuitemdebug,menuitemx
  !asm
  !stack2regs
  MOVE.w menuitemdebug,d6

  ; D6: menuitem
  MOVE.l A5,firstitem_
  MOVE.w D7,numlines_org
  MOVE.l D7,numlines
  LSL.w #2,D6
  LEA menu_items,A0
  MOVEA.l $0(A0,D6.W),A0
  MOVE.l #$FFFFffff,linenumat             ; was -1
  MOVE.l #$FFFFffff,compilelinecounter    ; was -1
  JSR (A0)                              ; jsr to the function for the menuitem
  MOVE.l compilelinecounter,D0
RTS

menuitemdebug: Dc.l 0

mempool                Dc.l 0
;str_loaddebugmessage:  Dc.b "Debug module to load",0 : Even        ; was dtext org source
dloaderr:              JSR handle_compileerror
                       Dc.b "Can't LoadSeg debug module!",0 : Even


.menu_loaddebugmodule:
  !basic
  !ComData_GetL{comPtr_pedScreen,D0} : *pedScreen.Screen = PutRegD0
  aslfr_SetRequesterTitle{2,"Debug module to load:","Load","Cancel"}
  aslfr_SetPath {2,config\blitz3assign,Peek.s(?str_temp_debugmodulename),""}
  If NOT aslfr_Request{2,False,True,False,*pedScreen}
    Pop If
    !asm
    RTS
  EndIf
  GetRegD0 aslfr_GetNextFile{}
  !asm

;loaddmod
  ;d0=name of module to load!
  ;
  MOVE.l D0,ptr_temp_debugmodule

  MOVE.l A7,stackaddr                                      ; added to prevent a possible crash in CLIMode if #continue_on_error is set  tomsmart1
  MOVE.l A7,errstack
  MOVE.l #nodload,errcont

  ;MOVE.l ptr_temp_debugmodule,D1
  ;MOVEA.l _dosbase(PC),A6
  ;JSR _LoadSeg(A6)
  ;MOVE.l D0,D7
  ;BEQ.w dloaderr

  !basic
  temp_ptr.l = LoadSeg_(Peek.s(?ptr_temp_debugmodule))
  If temp_ptr <> 0
    If config\ptr_seg_debugger > 0 Then UnLoadSeg_ config\ptr_seg_debugger
    config\ptr_seg_debugger = temp_ptr
  Else
    Pop If
    !asm
    BRA dloaderr
  EndIf
  !asm
  nodload:
RTS


;str_request_exename:   Dc.b "Name of Executable to Create:",0 : Even                        ;xtext org source
exepath:               Ds.l 48                             ;Ds.b #MAX_STRINGSIZE ; Ds.l 48  ;xpath  dcb.b 192,0 org source
exefile:               Ds.l 48                             ;Ds.b #MAX_STRINGSIZE ; Ds.l 48  ;xname  dcb.b 192,0 org source
ptr_newexefilename:    Dc.l 0                                                               ;execname org

; new >
.menu_newcreate
  !basic
  exepath.s = Peek.s(?exepath)
  exefile.s = Peek.s(?exefile)
  If exefile <> ""                                         ; test if we have a filename
    If exepath <> ""                                       ; yes we have a filename ,test if we have a path
      If dos_Exist{exepath}= False Then Goto nonexistpath  ; yes we have a path, test if he exist
    EndIf
    exefile.s = dos_AddPart{exepath,exefile}               ; combinat path and filename
;    error{exepath + " " + exefile}
    Poke.s ?tempspace,exefile
    !asm
;  LEA exepath,a0
;  LEA exefilename,a1
;  TST.b (a1)
;  BEQ menu_createexecutable
;
;  LEA tempspace,a1
; 'l10
;  MOVE.b (a0)+,(a1)+
;  BNE 'l10
;  SUBQ.l #1,a1
;  CMP.b #":",-1(a1)
;  BEQ 'lw1
;  MOVE.b #"/",(a1)+

; 'lw1
;  LEA exefilename,a0

; 'l20
;  MOVE.b (a0)+,(a1)+
;  BNE 'l20
    LEA tempspace,a0
    MOVE.l a0,d0
   BRA newcreate2                                         ; jump to the compile
; < new
   EndIf                                                  ; we have no filename or no exists path so we need to ask the user
 nonexistpath
   !asm

.menu_createexecutable:    ;was menu1 org source
  ;compile/save
  ;
  ; new >
  !basic
  ;request_exename.s = Peek.s(?str_request_exename )
  ;request_exename   = !TRANS{request_exename}
  ;Getreg D0,&request_exename
  ;!asm
  ;MOVE.l D0,A2
  ; < new
  ;MOVEA.l comdata,A3
  ;MOVEA.l $18(A3),A3
  ;!ComData_GetL{comFunc_ASLFileRequest,A3}
  ;LEA str_request_exename,A2
  ;LEA exepath,A0
  ;LEA exefilename,A1
  ;JSR (A3)                                                 ;open ped filerequest
  ;BEQ.w cancel_createexe    ; was 'err

  !ComData_GetL{comPtr_pedScreen,D0} : *pedScreen.Screen = PutRegD0
  aslfr_SetRequesterTitle{2,"Name of Executable to Create:","Create","Cancel"}
  aslfr_SetPath {2,Peek.s(?exepath),Peek.s(?exefile),""}
  If NOT aslfr_Request{2,False,True,False,*pedScreen}
    Pop If
    !asm
    RTS
  EndIf
  Poke.s ?exepath, aslfr_GetPath{2}
  Poke.s ?exefile, aslfr_GetFile{2}
  newexefile$ = aslfr_GetNextFile{} : GetReg D0,&newexefile$
  !asm

.newcreate2    ; was 'tryit
  ; new >
  ADD.l #1,number_of_builds
  ; < new
  ;
  ;O.K.... Now to create it
  MOVE.l D0,ptr_newexefilename
  MOVE.w #-1,debugversion
  ;MOVE.w set_make_smallestcode,-(A7) ; deactivate because it make no sense  tomsmart1
  ;bset #$7,make_smallestcode        ;make small!                      ;set optimize for create file    ;make small!

  ; new >
 'l1
    MOVE.w #1,makeexec
    JSR ab3_OpenDebugFile
  ; < new
    BSR.w startcompile
  ; new >
    JSR ab3_CloseDebugFile
  ; < new
    CMP.l #"NORE",reqmode
  BEQ 'l1
  ; < new
  TST.w anyerrs
  BNE.b 'skip
    JSR savefile
 'skip
  ;MOVE.w (A7)+,set_make_smallestcode ; deactivate because it make no sense  tomsmart1

 cancel_createexe:   ; was 'err
RTS


.do_CloseEd:
  MOVE.w #-1,flag_noPED
RTS


.do_NoCli:
  MOVE.w #-1,flag_noCLI
RTS

; new >
ab3_CloseDebugFile:
  !basic
    If dbg_fid>=0
      If fillcount.l > 0                                         ; added to check if we still have data so save in the buffer  tomsmart1
        file_WriteMem{dbg_fid,&dbg_detokenlinesBuffer,fillcount} ; yes save it
        fillcount = 0                                            ; set it back to zero bytes
      EndIf
      file_Close{dbg_fid}
      dbg_fid = -1
    EndIf
    Poke.w ?word_WriteDebugFileNow,0
  !asm
RTS


ab3_OpenDebugFile:
  BSR ab3_CloseDebugFile     ; remove double code and replaced it with a call of the subroutine  tomsmart1
  !basic
  If dbg_fid.l<0
    CLR.l d0
    !ComData_GetW{comWord_CreateDebugFile,D0}
    PutReg d0,dbg_Create.l
    If (dbg_Create) ; only when set!
      exefileP.l = Peek.l (?ptr_newexefilename)
      exefile.s = ""
      If exefileP Then exefile.s = Peek.s(exefileP)
      If exefile><""
        dbg_fid = file_Open{exefile+".dbg",#file_forcewrite}
        If dbg_fid>=0
          Poke.w ?word_WriteDebugFileNow,-1
        End If
      End If
      oldhunkoffset.l = -1
      oldfile.s       = ""
      fillcount       = 0       ; set it to zero bytes in the buffer
    End If
  End If
  !asm
RTS


ab3_WriteDebugFile:
  TST.w word_WriteDebugFileNow
  BEQ 'skipdebugfile
  !basic
    If dbg_fid>=0
      pass.l          = Peek.w(?pass)
      makesmallest.b  = Peek.b(?make_smallestcode)               ; get the status of make_smallestcode  tomsmart1
      If pass><0 OR makesmallest=0                               ; check expand for makesmallestcode so if it not set that then the dbgfile will fill because we don't reach Pass>0  tomsmart1
        oldhunkoffset.l = hunkoffset.l
        oldfile.s       = codefile.s
        If Peek.w (?ininclude)>0
          codeline.l = Peek.l(?includeline);-1
          codefile.s = dos_FilePart{incdim(Peek.w(?ininclude)-1)}
        Else
          !ComData_LEA{comStr_SourceName,A0}
          MOVE.l A0,D0
          PutReg d0,sourceP.l
          codefile.s = Peek.s(sourceP)
          codeline.l = Peek.l(?linenumat)
        End If
        hunkoffset.l = Peek.l(?destpointer)-Peek.l(?destbufferstart)
        If oldhunkoffset><hunkoffset OR oldfile><codefile
          linebegintext.s = Hex$(hunkoffset)+" <"+codefile+"@"+Str$(codeline)+"> "
          linebeginlen.l  = FLen(linebegintext)
          Poke.s &dbg_detokenlinesBuffer+fillcount,linebegintext           ; copy the begin of the line text to the buffer
          fillcount + linebeginlen

          *sourceLine.SourceLine_t = Peek.l(?sourceline)
          If *sourceLine
            !ComData_GetL{comPtr_PreProcessor,include_preprocessor}
            *tn.preprocessor = Peek.l(?include_preprocessor)
            written.l = preproc_Detokenize{*tn,&*sourceLine\Text,&dbg_detokenlinesBuffer+fillcount,*sourceLine\CharLength}
            If written>0
              written-1
            EndIf
            fillcount + written                                            ; added the dekotenline size to the count
          Else
            Poke.s &dbg_detokenlinesBuffer+fillcount,"NULL"                ; copy it to the buffer
            fillcount + 4                                                  ; added the size to the count
          End If

          Poke.b &dbg_detokenlinesBuffer+fillcount,10                      ; copy line end (return) in to the buffer
          fillcount +1                                                     ; count +1

          If fillcount >= (#MAX_dbg_detokenlinesBufferSize - #MAX_Columns) ; check if we have no room for a nother line
            file_WriteMem{dbg_fid,&dbg_detokenlinesBuffer,fillcount}       ; no room write the buffer it do disk
            fillcount = 0                                                  ; set it back to zero bytes
          EndIf

        End If
      End If
    End If
  !asm

 'skipdebugfile
RTS

word_WriteDebugFileNow: Dc.w 0
; < new


flag_noPED:  Ds.w 1                                        ;closeed org source
flag_noCLI:  Ds.w 1                                        ;nocli org source


check_FunctionReturnType:           ; copy of sizespec2
  MOVEM.l A2-A3,-(A7)
  CLR.b doublepeek
  MOVE.l A5,lastsourcepos
  JSR getchar

  CMP.w #$2E,D0              ;'.'
   BEQ.w 'ok
  MOVEA.l defaulttype,A2
  CMP.w #$24,D0              ;'$'
   BNE.w 'none
  MOVEQ.l #$07,D1
  BRA.w 'skip

 'ok
  JSR getparameter2
  BEQ.w JUMP_syntaxerr1
  LEA newtypebase,A2
  JSR findtype
  BNE.w JUMP_notypeerr1

 'none
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

CNIF #function_support_returntype
  MOVE.l a2,functionreturntype
  CMPI.l #$100,$4(A2)
  BLE.w 'isvar
  ;CMP.w #"*",d0
  ;BNE JUMP_syntaxerr1
  ;!fget
  MOVEQ #3,d1
  BRA 'skip
 'isvar
CELSE
  CMPI.l #$100,$4(A2)                        ;check for normal var or type
  BLS.w JUMP_illtypeerr1
CEND

  MOVE.w $6(A2),D1
  CMP.w #8,8(a2)
  BNE 'l1
    MOVE.b #1,doublepeek
 'l1

 'skip
  MOVE.w D1,convsize
  MOVEM.l (A7)+,A2-A3
RTS

JUMP_notypeerr1  JMP notypeerr
JUMP_illtypeerr1 JMP illtypeerr
JUMP_syntaxerr1  JMP syntaxerr

clear_Cache:                       ; was flushc in orginal BB2 source
  MOVEM.l D0-D1/A0-A1/A6,-(A7)
  MOVEA.l _execbase,A6
  TST.b MorphOS                    ; test if we have MorphOS ( 0 no, 1 yes)
  BEQ 'useclearU                   ; if we have 0 = No MorpOS then jump
    MOVEQ.l #8,d1
    MOVE.l #200,d0
    JSR _CacheClearE(A6)
    BRA 'exit
 'useclearU
  ;  CMP.w #$27C,16(a6)               ; from orginal BB2 source
  ;  BCS 'exit                        ; from orginal BB2 source
CNIF #USENEWCACHECLEAR_U           ; it is bugy on MorphOS only for testing
  MOVE $128(A6),D0                 ; get CPU ID
  BTST #3,D0                       ; test if its CPU
  BEQ 'l10                         ; if yes skip ; was BRA.S   'l10

  MOVE.l a0,-(a7)
  JSR _SuperState(A6)
  JSR _Disable(A6)
  MOVEA.L (A7)+,A1

  Dc.w $f469 ;CPUSHL Dc,(A1)
  Dc.w $f489 ;CINVL Ic,(A1)
  ADDA #16,a1
  Dc.w $f469 ;CPUSHL Dc,(A1)
  Dc.w $f489 ;CINVL Ic,(A1)
  ADDA #16,a1
  Dc.w $f469 ;CPUSHL Dc,(A1)
  Dc.w $f489 ;CINVL Ic,(A1)
  ADDA #16,a1
  Dc.w $f469 ;CPUSHL Dc,(A1)
  Dc.w $f489 ;CINVL Ic,(A1)
  ADDA #16,a1
  Dc.w $f469 ;CPUSHL Dc,(A1)
  Dc.w $f489 ;CINVL Ic,(A1)
  ADDA #16,a1
  Dc.w $f469 ;CPUSHL Dc,(A1)
  Dc.w $f489 ;CINVL Ic,(A1)

  JSR _Enable(A6)
  JSR _UserState(A6)
  BRA 'exit
 'l10
CEND                              ; end for USENEWCACHECLEAR_U
  JSR _CacheClearU(A6)

 'exit
  MOVEM.l (A7)+,D0-D1/A0-A1/A6
RTS


.menu_compile_run:                ;compile/run
  ADD.l #1,number_of_builds
  CLR.w debugversion
  CLR.w flag_noPED
  CLR.w flag_noCLI

 'l1
    MOVE.w #0,makeexec                                     ;MOVE.w #$FFFF,debugversion
    BSR.w startcompile
    CMP.l #"NORE",reqmode
  BEQ 'l1
  ; < new

.menu_run:                                                   ; run the last compiled source
  TST.w anyerrs
  BNE.w dontrun

  JSR check_fpu_before_run                                  ; check if compiled with FPU-optimizations
  TST.w d0                                                  ; if optimized but no FPU present, prevent execution
  BNE.w dontrun

  MOVE.w flag_noPED(PC),D1                                  ; close IDE if option is set
  BEQ.w 'noclose
    !ComData_JSR{comFunc_CloseGUI}
    BRA.b 'runprogram
 'noclose
    BSR compilerequester
    !basic
    comstatusstr  = !TRANS{"Running executable..."} ;default settings
    calcpro = 100
    GetReg D0,&comstatusstr : !ComData_SetL{comPtr_CompileStatusString,d0}  ; set pointer of status string for gui tomsmart1 2012 05 12
    GetReg D0,&calcpro      : !ComData_SetL{comPtr_CompileCalcProLong ,d0}  ; set pointer of calcpro long for gui tomsmart1 2012 05 12
    !asm
    !ComData_JSR{comFunc_UpdateCompileStatusWin}          ; jsr to the gui updateroutine  tomsmart1 2012 05 12 ;no extra check needed for CLImode because without PED the function only has a RTS
 'runprogram                                                ; was 'nopanic org source

  ; find current dir...
  ;MOVEA.l _dosbase,A6
  ; new >
  ;LEA exepath,a0
  ;MOVE.l a0,d1
  ;MOVEQ #-2,d2
  ;JSR _Lock(a6)                                            ;lock
  ;MOVE.l d0,lock_exepath
  ; < new
  ;MOVE.l #0,d1
  ;JSR _CurrentDir(A6)
  ;MOVE.l D0,lock_currentdir
  ;MOVE.l D0,D1
  ;JSR _CurrentDir(A6)

  ; lock the current path or the set executable
  !basic
  Poke.l ?lock_exepath, Lock_(?exepath,#ACCESS_READ)
  If Peek.l(?lock_exepath) = 0
    error{"Could not lock the given Exepath ["+ Peek.s(?exepath) + "]"}
  EndIf
  Poke.l ?lock_currentdir, CurrentDir_(0)
  CurrentDir_ Peek.l(?lock_currentdir)
  ;!asm

  ;CLR.l ptr_exetask
  ;MOVE.l #str_process_name,D1
  ;MOVEQ.l #$00,D2
  ;MOVE.l #proc_seglist,D3 : LSR.l #2,D3
  ;MOVE.l stacksize,D4
  ;MOVEA.l _dosbase,A6
  ;JSR _CreateProc(A6)                                      ;runtask
  ;TST.l D0
  ;BEQ ErrorRunningProg
  ;!basic
  *exeTask.Task = Null
  process_name.s = "Blitz ][ Program Proc"
  process_seglist.l = (?proc_seglist) LSR 2
  ;!cout{"running the prog as [" + process_name + "] with stack " + Str$(Peek.l(?stacksize))}
  *processMsgPort.l = CreateProc_(&process_name,0,process_seglist,Peek.l(?stacksize))
  If *processMsgPort = 0
    Pop If
    !asm
    BRA ErrorRunningProg
  EndIf
  GetReg D0,*processMsgPort : MOVE.l d0,-(a7)
  !asm
  MOVE.l (a7)+,D0
  ;OK, task should be running here! see If we Get a panic!
  !ComData_SetB{comByte_RunningFlag,#1}   ; this should be done here, straigt after it is clear that
                                          ; the program task is running
 'notpanic
  TST.w flag_noPED
  BNE.b fatal
    BSR.w close_compilewin
  fatal:
  CLR.l firstlocal
  CLR.l firstglob

  MOVE.w flag_noPED(PC),D1
  BEQ.w 'noopen
    !ComData_JSR{comFunc_CreateGUI}
 'noopen

  dontrun:
  RTS

  ErrorRunningProg:
  MOVE.l #1,_runerror
BRA fatal


_runerror:          Dc.l 0
lock_currentdir:    Ds.l 1                                          ;tasklock org source
;ptr_exetask:        Ds.l 1                                          ;panictask org source
signalNum:          Ds.l 1                                          ;panicbit org source
signals:            Ds.l 1                                          ;panicmask org source
;str_process_name:   Dc.b "Blitz ][ Program Proc",0 : Even           ;procname org source
;                    Ds.b 5                                          ;cnop 0,4 :dc.l 0   ;length org source
Even4

;ptr_ThisTask:       Ds.l 1                                          ;length
.proc_seglist:      Ds.l 1                                          ;procstart org source ;next


runtheprog:                                                        ;??looks like label not used??
  ;MOVEA.l $4,A0
  ;MOVE.l  $114(A0),ptr_exetask

  !basic
  *exeTask.Task  = *eb\ThisTask

  If Peek.l(?lock_exepath) then CurrentDir_ Peek.l(?lock_exepath)
  If Peek.l(?stacksize) < #MIN_STACKSIZE
    error{"The stacksize is to low: " + Str$(Peek.l(?stacksize))}
  EndIf
  !asm

  ; -- set the running flag for IDE
  !ComData_SetB{comByte_RunningFlag,#1}

  ; -- optionally open the console
  MOVE.w flag_noCLI(PC),D1
  BNE.b skip_openconsole
    !ComData_JSR{comFunc_OpenConsole}
  skip_openconsole:

  ;BSR.w calculate_VBR
  ;MOVEA.l vbr,A0
  ;MOVE.l $84(a0),lasttrap1                                 ;activate for 68k low level trap
  ;MOVE.l #tokens,$84(A0)                                   ;set trap vectors  1
  ;MOVE.l newtype_string,$88(A0)                            ;2 activate for 68k low level trap
  ;MOVE.l #directTrap15,$BC(A0)                             ;15 for expression calculation
  CLR.w direct_mode
  CLR.l firstglob
  CLR.l firstlocal
  ;MOVE.l destpointer,directbuffer                          ;direct buffer

  MOVE.l stacksize,D2
  MOVE.l #$624C745A,D7                                      ;#'bLtZ',d7 org source ;force cli-type run
  LEA str_cliarguments,A0                                   ;cli arguement
  MOVEA.l destbufferstart,A1

  BSR.w clear_Cache

  JSR (A1)                                                 ; execute compiled code  ;Run the thing!


  ;MOVEA.l vbr,A0
  ;MOVE.l lasttrap1,$84(a0)
  CLR.l firstglob
  CLR.l firstlocal

  !basic
  If Peek.l(?lock_exepath) Then UnLock_ Peek.l(?lock_exepath)
  !asm

  !ComData_SetB{comByte_RunningFlag,#0}

  ; -- optionally close the console and bring ide to front
  MOVE.w flag_noCLI(PC),D1
  BNE.b 'skip_closeconsole
    !ComData_JSR{comFunc_CloseConsole}
 'skip_closeconsole

  ;MOVE.w #$0001,stopit      ;ended OK!
  ;MOVE.l signals(PC),D0
  ;MOVEA.l ptr_ThisTask,A1
  ;MOVEA.l _execbase,A6
  ;JSR _Signal(A6)
  !basic
  Poke.w ?stopit, 1
  ;Signal_ Peek.l(?ptr_ThisTask),Peek.l(?signals)
  Signal_ *compilerTask,Peek.l(?signals)
  !asm
RTS


;.calculate_VBR:             ; may be replaced by cr_vbr / environmentlib
;  MOVEA.l _execbase,A6
;  MOVE.w $128(A6),D0        ; execbase\AttnFlags
;  MOVEQ.l #$00,D1
;  ANDI.w #$F,D0
;
; 'loop
;    BEQ.b 'skip
;    ADDQ.w #1,D1
;    LSR.w #1,D0
;  BRA.b 'loop
; 'skip
;
;  MOVEQ.l #$00,D2
;  CMP.w #$2,D1
;  BCS.b 'skip2
;    MOVEA.l _execbase,A6
;    JSR _SuperState(A6)
;    Dc.l $4E7A2801                                           ;movec vbr,D2
;    JSR _UserState(A6)
; 'skip2
;  MOVE.l D2,vbr
;RTS


.menu_reload_userlibs:      ; was menu8 org source
  LEA instrtab,a0
  MOVE.l #labelhash-instrtab,d0
  ASR.l #2,d0
  SUBQ.l #1,d0
 'l10
    CLR.l (a0)+
    SUBQ.l #1,d0
  BNE 'l10

  !basic
  Gosub free_userlibs
  Gosub scan_for_userlibs
  Gosub load_userlibs
  !asm
RTS

.scan_for_userlibs:      ; was makeblitzlibs org source
  NEWTYPE.userlibentry
    ;*next_entry.libentry  ; pointer to next entry in list
    is_used.w             ; used flag: is entry used ?
    libname.s             ; name of the libfile
  End NEWTYPE
  Dim List userlibslist.userlibentry(0)
  DEFTYPE.FileInfoBlock fib
  ;!cout{"scanning " + Peek.s(?str_path_userlibs)}
  result.b = False
  tmp_lock.l = Lock_(&config\path_userlibs,#ACCESS_READ)
  If tmp_lock
    If Examine_(tmp_lock,fib)         ; fileInfoBlock
      If fib\fib_DirEntryType >= 0    ; /* Type of Directory. If < 0, Then a plain File.
                                      ;  * If > 0 a directory */
        While ExNext_(tmp_lock,fib)
          If fib\fib_DirEntryType < 0
            libname.s = Peek.s(&fib\fib_FileName)
            If LCase$(dos_GetExt{libname}) <> "info"
              libfound.b = False
              ResetList userlibslist()
              While NextItem(userlibslist()) OR (libfound = True)
                If userlibslist()\libname = libname Then libfound = True
              Wend
              If AddLast(userlibslist())
                userlibslist()\is_used = $FFFF
                userlibslist()\libname = libname
              EndIf
            EndIf
          EndIf
        Wend
        result = True
      Else
        error{"Given path for userlibs is not a directory: " + config\path_userlibs + "!"}
      EndIf
    EndIf
    UnLock_ tmp_lock
  EndIf
Return

;jumpingjack:
;  ; --
;  ; -- search for the userlibs-path
;  MOVE.l #str_path_userlibs,D1
;  MOVEQ.l #-$02,D2
;  MOVEA.l _dosbase,A6
;  JSR _Lock(A6)
;  MOVE.l D0,D7
;  BEQ.w 'done     ;exit_get_libraries
;
;  MOVE.l D7,D1
;  MOVE.l #ptr_parameterstore,D2
;  JSR _Examine(A6)
;  TST.l D0
;  BEQ.w 'done2   ;unlock_and_exit_get_libraries
;  MOVE.l fib_DirEntryType,D0
;  BMI.w 'done2   ;unlock_and_exit_get_libraries
;
;  ;OK to do exnext on dir...
;  ;
;  ; --
;  ; -- hier wird rekursiv in str_path_userlibs nach libs gesucht ...
;
; 'loop    ;scan_libsdrawer:
;    MOVE.l D7,D1
;    MOVE.l #ptr_parameterstore,D2
;    MOVEA.l _dosbase,A6
;    JSR _ExNext(A6)
;    TST.l D0
;    BEQ.w 'ok                                              ; kein weiteres File
;      MOVE.l fib_DirEntryType,D0                             ; positive for directoies, negative for files
;      BPL.w 'loop
;        LEA fib_FileName,A0                                    ; pruefen ob infofile
;        BSR.w check_for_infoextention
;        BEQ.w 'loop
;          MOVEA.l _execbase,A6                                   ; allocate $26 = 38 bytes fuer listeneintrag
;          MOVEQ.l #$26,D0
;          MOVEQ.l #$01,D1
;          MOVE.l mempool,a0
;          JSR _AllocPooled(a6)
;          MOVEA.l _dosbase,A6
;          MOVE.l D0,D6                                           ; sichere speicheradresse in D6
;          LEA ptr_userlibs_list,A0                               ; pruefe liste
;         'insloop
;            MOVE.l (A0),D5
;            BEQ.w 'here                                          ; kein pointer da? kann springe weiter
;              MOVEA.l D5,A2
;              ADDQ.w #6,A2                                       ; 6 bytes weiter gehen, um dateinamen zu speichern
;              LEA fib_FileName,A1                                ; vergleich, ob Dateiname schon in der liste ist
;             'comloop
;                MOVEQ.l #$00,D0
;                MOVE.b (A1)+,D0
;                BEQ.w 'here                                      ; dateiname komplett, dann weiter
;                  MOVEQ.l #$00,D1
;                  MOVE.b (A2)+,D1
;                  BEQ.w 'next
;                    !test_for_letter                                            ;bsr.w tstalpha
;                    BNE.w 'acskip
;                      ANDI.w #$DF,D0        ; was 255-32
;                   'acskip
;                    EXG.l D0,D1
;                    !test_for_letter                                            ;bsr.w tstalpha
;                    BNE.w 'acskip2
;                      ANDI.w #$DF,D0        ; was 255-32
;                   'acskip2
;                    EXG.l D0,D1
;                    CMP.b D1,D0
;                    BEQ.w 'comloop
;                    BCS.w 'here             ;I'm less than
;                 'next
;                  MOVEA.l D5,A0
;          BRA.w 'insloop
;         'here
;          MOVEA.l D6,A1                                          ; hier war die adresse des allokierten Speicers drin
;          MOVE.l (A0),(A1)            ;next of last is next of me
;          MOVE.l A1,(A0)              ;I am next of last
;          ADDQ.w #4,A1                                           ; pointer zum naechsten namen ueberspringen
;          MOVE.w #$FFFF,(A1)+         ; was - 1;set 'Used' flag  ; $FFFF schreiben
;          MOVEA.l #fib_FileName,A0    ; was #namebuff+8,         ; dateinamen in die liste kopieren
;         'coploop
;            MOVE.b (A0)+,(A1)+
;          BNE.w 'coploop
;  BRA.w 'loop
;
; 'ok    ;exit_scan_libsdrawer:
;  MOVE.l D7,D1
;  MOVEA.l _dosbase,A6
;  JSR _UnLock(A6)
;  MOVEQ.l #-$01,D0
;
; 'done     ;exit_get_libraries:
;  JSR showme
;  RTS
;
; 'done2     ;unlock_and_exit_get_libraries:
;  MOVE.l D7,D1
;  MOVEA.l _dosbase,A6
;  JSR _UnLock(A6)
;  MOVEQ.l #$00,D0
;RTS
;
;.showme:
;!basic
;!cout{Hex$(Peek.l(?ptr_userlibs_list))}
;!asm
;
;RTS

;
;.free_userlibslist:           ;free up  the list of loaded userlibs
;  !basic
;  ClearList userlibslist()
;  !asm
;RTS
;
;  MOVEA.l _execbase,A6
;  MOVEA.l ptr_userlibs_list,A2
;  CLR.l ptr_userlibs_list
;
; 'loop
;    CMPA.w #$0,A2
;    BEQ.w 'done
;      MOVEA.l A2,A1
;      MOVEQ.l #$26,D0
;      MOVEA.l (A2),A2
;      MOVE.l mempool,a0
;      MOVEA.l _execbase,A6
;      JSR _FreePooled(A6)
;  BRA.w 'loop
; 'done
;RTS


;-----------main compiler functions!------------;
pass:         Dc.w 0                                      ; smallpass org source
compiler_job: Dc.w 0                                      ; added by thilo: what the compiler is doing at the moment
                                                          ; 0 = compiling, 1 = code generation

.startcompile:                                            ; O.K. Here we go.....
  MOVE.l #0,compileErrorCode
  MOVE.l A7,errstack

  !regs2stack
  BTST #$7,make_smallestcode       ; test if makesmall is set
  BNE 'nobigallox                  ; yes makesmall is set, we don't change the buffers
    JSR bigallox                   ; no try to make big buffers for 1 pass compile
 'nobigallox
  !stack2regs

  CLR.l reqmode
  ; < new
  MOVE.l #Aclearallvars,errcont
  MOVE.l #concomstack,concomsp

  ;
  ; racing stripe stuff...
  ;
  MOVE.w #1450,D0
  LSR.w #3,D0
  SUBQ.w #7,D0                                             ; 173
  MOVE.w D0,progressbar_width
  SWAP D0
  CLR.w D0
  MOVE.l numlines,d1                                       ; was divu numlines,d0
  DIVU.l d1,d0                                             ; progressbar_width / numlines

  TST.w D0
  BNE.w 'ok
    MOVEQ.l #-$01,D0
 'ok
  MOVE.w D0,progress_per_line

  ;
  ; check if debugger should be turned on
  ;
  BTST #$7,use_debugger
  BNE 'debugon
    CLR.w debugmode
    BRA.b 'debugoff
 'debugon
    SNE debugmode
 'debugoff
  !ComData_SetB{comByte_DebugMode,debugmode}

  CLR.w direct_mode           ;direct mode flag                                  ;direct mode flag
  CLR.w ezerr             ;quiet error                                 ;quiet error
  CLR.l currentfunction
  CLR.w connest
  CLR.w varmode
  CLR.w proceduremode
  CLR.w ininclude
  CLR.w intstring
  CLR.w pass

  MOVE.w #0,compiler_job
  CLR.l errorcounter
  CLR.l beforeparameterfetch     ; add to prevent fals detokening by showing a the (compile)error requester  tomsmart1 2016 02 02
  ; < new

 'retry
  ; new >
  CNIF #funcscan                                           ; scan, welche funktionen verwendet werden
    MOVE.l #1,funcscanon
    BSR compileall
    ADDQ.w #1,pass
    JSR ab3_OpenDebugFile                                    ; added that the .dbg file only contains the data from one the next compile pass  tomsmart1
  CEND

  CLR.l funcscanon
  BSR.w compileall
  ADDQ.w #1,pass

  !regs2stack           ; added to get the needed size for the exe from the first compile for the create the release exe  tomsmart1
  !basic
  samesize.l = 0
  needsize0.l = Peek.l(?bigpc) -Peek.l(?destbufferstart)
  !asm
  !stack2regs

  TST.l errorcounter
  BEQ 'skiperrorstop
    RTS
 'skiperrorstop

  MOVE.w dontwrite_nomemleft,d0
  CMP.w #1,d0
  BNE 'l3
    TST.l errorcounter
    BNE 'l3
      CLR.w dontwrite_nomemleft
      JSR ab3_OpenDebugFile                                    ; added that the .dbg file only contains the data from one the next compile pass  tomsmart1
      BSR compileall                                           ;if a function is not found
      ADDQ.w #1,pass
 'l3


  !ComData_GetB{comByte_FuncOptimize,D0}  ; now its in the xtra file and can be put to GUI settings ; Wanderer
  BEQ 'out  ; only if func optimize is set >< 0; Wanderer
  LEA firstproc,a0
  CLR.l savefuncspace
  MOVE.l (a0),d0

 .'funcskiplist                                            ;??looks like double label??
 'lr1
    MOVE.l d0,a0
    BEQ 'out
    TST.b isfunc(a0)
    BNE 'nex
    MOVEM.l d2/a6/a0,-(a7)
    ;MOVE.l $4,a6
    MOVEQ #0,d0
    MOVE.b $21+#funcentry_extend-1(a0),d0
    SUB.w #$21+#funcentry_extend,d0
    ADD.w #16,d0
    MOVE.l #$10000,d1
    MOVE.l d0,d2
    MOVEA.l _execbase,A6
    JSR _AllocMem(a6)         ; thilo: not 100% sure about this!
    MOVE.l d0,a1
    MOVE.l d2,4(a1)
    MOVE.l unusedfunc,(a1)
    MOVE.l d0,unusedfunc
    MOVEM.l (a7)+,a6/a0/d2
    MOVE.l isfunc+1(a0),d0
    ADDQ.l #6,d0
    ADD.l d0,savefuncspace

 'l1f
    MOVE.l d0,8(a1)
    LEA 12(a1),a1
    MOVE.l a0,-(a7)
    LEA $21+#funcentry_extend(a0),a0

 'l1
      MOVE.b (a0)+,(a1)+
    BNE 'l1
    MOVE.l (a7)+,a0

 'nex
    MOVE.l (a0),d0
 BRA 'lr1

 'out
  BTST #$7,make_smallestcode
  BEQ.b 'nosmall                                             ;optimize for executable
  ; new >
  CLR.l morememadd
  ; < new

 'makesmall    ; was again
  BSR.w alloxadj
  BEQ.w 'anerr
  ;ADDQ.w #1,pass
  JSR ab3_OpenDebugFile                                      ; added that the .dbg file only contains the data from one the next compile pass  tomsmart1
  BSR.w compileall
  ; new >
  ADDQ.w #1,pass
  !regs2stack             ; added to get the needed size for the exe from the last (second) compile for the create the release exe  tomsmart1
  !basic
  If releaseexe = True                                       ; test if we create a release exe
    needsize1.l = Peek.l(?bigpc) - Peek.l(?destbufferstart)  ; get the size from the last compile
    If (needsize1 = needsize0) AND (releasedbg_save = 1)     ; test if we we can not reduce the size anymore and need to cread a dbg file
      !ComData_SetW{comWord_CreateDebugFile,#1}              ; set create .dbg file to one
      !asm
      JSR ab3_OpenDebugFile                                  ; open the .dbg flie
      !stack2regs
      BSR compileall                                         ; compile for the last time to creat the dbg file
      !regs2stack
      !basic
    EndIf
    If needsize1 < needsize0   ; test if the needed size is smaller then the compile befor
      needsize0 = needsize1    ; yes the new size is that the old size
      Pop If : Pop If
      !asm
      !stack2regs
      BRA 'l3                  ; back to the funcscan and compile again
    EndIf
  EndIf
  !asm
  !stack2regs
  ; < new

 'nosmall
  MOVE.w dontwrite_nomemleft,D1
  BEQ.w 'dosave
  ;
  ;MOVEA.l #comreq_datas,A0
  ;MOVEA.l comdata,A1
  ;MOVEA.l (A1),A1
  ; !ComData_GetL{comFunc_OpenWindow,A1}                    ; added for documentation  tomsmart1
  ;JSR (A1)    ;open the requester
   
 'loop
  ;MOVEA.l comdata,A1
  ;MOVEA.l $8(A1),A1
; !ComData_GetL{comFunc_CloseWindow,a1}                     ; added for documentation  tomsmart1
  ;JSR (A1)     ;getinput                                            ;compile requester more mem
  ;
  ;CMP.w #-$1,D7
   ;BNE.w 'loop
  ;CMP.w #$1,D6
  ; new >
   ;ADD.l #20000,morememadd
   ;ADD.l #500000,libsbuffer
  ; < new
 BRA.w 'inc     ; was beq
  ; new >
;  BRA.w 'retry
  ; < new
  ;CMP.w #$2,D6
  ; new >
   ;MOVE.l #30000,morememadd
   ;ADD.l #5000,libsbuffer
  ; < new
;  BRA.w 'makesmall    ; was again ;was beq
  ;CMP.w #$3,D6
   ;BNE.w 'loop

 'anerr
  MOVE.w #$FFFF,anyerrs        ; was -1
 BRA.w 'dosave

 'inc
  BSR.w alloxinc                                          ;increase all by 50%
  BEQ.w Aclearallvars
  JSR ab3_OpenDebugFile                                   ; added to fix that the .dbg file only holds the data from the second (last) compile if no make_smallest is set and the buffer was to small  tomsmart1
 BRA.w 'retry

 'dosave
  ; new >
  ;move.l $4,a6
  ;move.l mempool2,d0
  ;beq 'l10
  ;move.l d0,a0
  ;jsr -$2be(a6)
  ;clr.l mempool2

; 'l10:
  ; < new
BRA.w qfree        ;used to go after beq .nosave                          ;???????


.qfree:
  ;free up un-necessary stuff
  ;
  JSR freereps
  JSR freesels
  JSR freetlist
  JSR freepends
  JSR freeifs
  JSR freeincs
  JSR freexincs
  JSR freefors
JMP cleartemplabel

; new >
mempool2:  Dc.l 0
; < new

.Aclearallvars:      ; was freeemup  org source                                    ;called from ped every filechange
  ; new >
  JSR clear_Cache

  BTST #$7,use_debugger
  ;  SNE debugmode
  BNE 'debugon
    CLR.w debugmode
    BRA.b 'debugoff
 'debugon
    SNE debugmode
 'debugoff
;  MOVE.l comdata,a0
;  MOVE.b debugmode,$7ee(a0)
  !ComData_SetB{comByte_DebugMode,debugmode}

  LEA regtable,a0
  MOVEQ #10,d0

 'l1
    CLR.l (a0)+
  DBF d0,'l1

  LEA includetemp2,a0
  CLR.b (a0)
  MOVE.l #7,maxregs
  CLR.w debugnest
  CLR.b funcparloop
  CLR.b nostringopt
  CLR.b firsttime
  CLR.l lastdestpointer
  CLR.l lastwritedat
  CLR.l prevwritedat
  CLR.l includeline
  CLR.b incnif
  CLR.b formode
  CLR.b funccall
  CLR.w objectcount
  CLR.b resdisable
  CLR.b developobject
  CLR.b optistring
  CLR.b optistring2
  CLR.b optiarray
  CLR.b quickadd
  CLR.w newmode
  CLR.w mode
  CLR.w string1
  CLR.b fastfunc
  CLR.w load_var_size
  CLR.w load_var_reg
  CLR.l load_var_addr
  CLR.w imm_size
  CLR.w imm_reg
  CLR.l imm_addr
  CLR.b _dcb
  CLR.l nohunkoffset
  CLR.b peekaddrsize
  CLR.b typecheck
  CLR.b declare2
  CLR.b declare
  CLR.l myoline                                          ;check
  CLR.l myline                                          ;check
  CLR.b newvariable
  CLR.b saved0
  CLR.l bsssize
  CLR.l chipsize
  CLR.b infunctioncode
  CLR.l errorcounter
  MOVE.l #-1,bssstart
  MOVE.l #-1,bssend
  MOVE.l #-1,chipstart
  MOVE.l #-1,chipend
  MOVE.w #0,bssmode
  CLR.w a2offset
  CLR.w fast
  CLR.w fpu
  CLR.b iee
  CLR.w newsyntax
  ; < new
  BSR.w qfree
  JSR killoffs                ;free up DOS offset table
  JSR frallvars               ;free up Global vars
  JSR fralltypes              ;free up all types
  JSR free_Macros             ;free up actual macro defines.
  JSR clearfunctionlist       ;free up states/funcs
  ; new >                     
  TST.w pass                  
  ;bne freeprocvs
  ;< new
  JSR clearlabels             ;free up labels
  ; new >
  JSR clearhash

 'l2a
  LEA devo,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA ptr_parameterstore,a1

 'l1b
    MOVE.b (a0)+,(a1)+
  BNE 'l1b
  MOVEQ #13,d2
  JSR findlabel2
  BNE 'd
  CLR.l 8(a2)

 'd
  MOVEM.l (a7)+,a0-a6/d0-d7
  !basic
  dos_Delete{dos_AddPart{config\path_system,"ab_compileerror.txt"}}
  !asm
  CLR.b returncode
  ; < new
JMP freeprocvs                     ;free up outstanding proc stuff


.clearhash
  MOVE.l #bssstore-labelhash,d0
  ASR.l #2,d0
  LEA labelhash,a0

 'l10
    CLR.l (a0)+
    SUBQ.l #1,d0
  BNE.s 'l10

  LEA labelbase,a1
  MOVE.l (a1),d0
  BEQ 'l11

 'l21
    MOVE.l d0,a1
    TST.l 4(a1)
    BEQ 'l29
    LEA $13(a1),a0
    MOVEQ #0,d0
    MOVEQ #0,d1

 'l13
      MOVE.b (a0)+,d1
      BEQ 'l12
      !hashalgo
 BRA 'l13

 'l12
    LEA labelhash,a0
    AND.l #hashsize,d0
     ASL.l #2,d0
    MOVE.l 0(a0,d0),d1                                     ;*4
    MOVE.l d1,$c(a1)
    MOVE.l a1,0(a0,d0)

 'l29
    MOVE.l (a1),d0
  BNE 'l21

 'l11
RTS


fralltypes:
  MOVEA.l lastrestype,A0
  MOVEA.l (A0),A2
  CLR.l (A0)
JMP freetypes


frallvars:
  MOVEA.l varbase,A3
  CLR.l varbase

  ; new >
 'l10
  CMPA.w #$0,A3
  BEQ.w 'l20
  MOVEA.l A3,A1
  MOVEA.l (A3),A3
  MOVEQ.l #$00,D0
  MOVE.b $E+4(A1),D0
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _FreePooled(A6)
 BRA.w 'l10

 'l20
RTS

freeifs:
  LEA firstiff,A2
  MOVEQ.l #$0E,D2
JMP freeslist


;bmapmul:            Dc.w 0
;botline:            Dc.w 0                                ;offset to bottom of stripe

progressbar_width:   Dc.w 100                              ;riteend org source ;right end of include strip
inmacro:             Ds.w 1                                ;macmask org source ;macro found


.nextline:
  ;
  ;go on to the next line of the program.....
  ;
  CLR.w inmacro
  ; new >
  ADDQ.l #1,globallinecount
  CLR.b nostringopt
  ; < new
  BSR.w freembuff
  CLR.w instringon

  ; new >
mergeline:
  ; < new
  TST.w ininclude
  BEQ.w 'skip3
    ; new >
    ADDQ.l #1,includeline
    JSR ab3_WriteDebugFile
    ; < new
    JSR readinc
    BEQ.w 'skip3
    ;
    ;do include stripe
    ;
    MOVE.w ininclude,D0
    CMP.w #$4,D0
    BCC.w 'stskip
      ADD.w D0,D0
      LEA progress_per_line,A0
      MOVE.w $0(A0,D0.W),D2     ;offset in line
      CMP.w progressbar_width(PC),D2
      BCC.w 'stskip
        ADDQ.w #1,$0(A0,D0.W)
        ;
        LSR.w #1,D0
        MOVE.l d0,d1 : EXT.l d1
        MOVE.l d2,d0 : EXT.l d0
        JSR update_progressbar    ; d0=x, d1=y
        ; < new
   'stskip
    MOVEQ.l #-$01,D0
    RTS

 'skip3                                                         ;do main stripe
  MOVE.l titleat,D0
  MOVEQ.l #$00,D1 : MOVE.w progress_per_line,D1 : ADD.l D1,D0
  MOVE.l D0,D1
  SWAP D0
  CMP.w titleat,D0
  BEQ.w 'skip3a
    ; MOVEA.l comdata,A0                                       ; frueher wird direkt in die Planes geschrieben
    ;  MOVEA.l $24(A0),A0
    ;  !ComData_GetL{comLong__AL_0_84E2,a0}                     ; added for documentation  tomsmart1
    ; new >
    EXT.l d0
    MOVE.l d1,-(a7)
    ; MOVEQ #9,d1                                              ; y-pos runtersetzen
    MOVE.w #1,compiler_job                                    ; set to compiler job 1 (=build executable)
    JSR update_progressbar
    MOVE.w #0,compiler_job                                    ; set to compiler job 0 (=compile source)
    ; < new
    ;NOT.b -$1(A0,D0.W)
    ;ADDA.w botline(PC),A0                                     ;progress
    ;NOT.b -$1(A0,D0.W)
    ; new >
    MOVE.l (a7)+,d1
    ; < new
 'skip3a
  MOVE.l D1,titleat

 'skip2
  ADDQ.l #1,linenumat
  CLR.w linedone
  ; new >
  JSR ab3_WriteDebugFile  ; write to DebugFile every main source line
  ; < new

 'norunerr
  ;SUBQ.w #1,linesleft
  ; new >
  SUBQ.l #1,numlines2
  ; < new
   BEQ.w 'skip
  MOVEA.l sourceline,A0
  MOVEA.l (A0),A0
  MOVE.l A0,sourceline
  LEA $9(A0),A5

 'skip
RTS


hexascii:                                                  ;convert d1.w to ascii at a0
  MOVE.w D0,-(A7)
  MOVEQ.l #$03,D0

 'loop
    MOVE.w D1,D2
    ANDI.w #$F,D2
    ADDI.w #$30,D2
    CMP.w #$3A,D2
    BCS.w 'skip
     ADDQ.w #7,D2
   'skip
    MOVE.b D2,$0(A0,D0.W)
    LSR.w #4,D1
  DBF D0,'loop

  MOVE.w (A7)+,D0
RTS


JMP_notqerr:
JMP notqerr

findmacro:   ;expandmax org source
  ;
  ;go through statement and expand macros
  ;
  ;line at a5.....
  ;check it for !'s
  ;
  MOVE.w skipcode,D1
  BNE.w 'loop0
    RTS
 'loop0

  MOVE.l A5,-(A7)
  MOVEQ.l #$3A,D1      ;':'
  MOVEQ.l #$21,D2      ;'!'
  MOVEQ.l #$3B,D3      ;';'
  MOVEQ.l #$22,D4      ;'"'

 'loop
    MOVE.b (A5)+,D0
    BEQ.w 'done
      BPL.w 'test
        MOVE.b (A5)+,D0
  BRA.w 'loop

 'test
  CMP.b D4,D0
  BNE.w 'notq

 'qloop
  MOVE.b (A5)+,D0
   BEQ.w JMP_notqerr
   ;BPL.w 'qskip                                        ;morechar
  ;MOVE.b (A5)+,D0
; BRA.w 'qloop

 'qskip
  CMP.b #$22,D0        ;'"'
   BNE.w 'qloop
 BRA.w 'loop

 'notq
  CMP.b D1,D0
   BEQ.w 'done
  CMP.b D3,D0
   BEQ.w 'done       ;macro character!
  CMP.b D2,D0
   BNE.w 'loop
  ;
  ;expand the macro!
  ;
  MOVE.w #$FFFF,inmacro    ; was -1                                ; no runtimecheck in macros
  MOVEA.l A5,A3
  ;
  JSR getparameter2
  BNE.w 'fkitme
    JMP syntaxerr
 'fkitme
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  ;
   JSR findmac                                             ;find macro
   BEQ.w 'kl1
 JMP nomacerr

 'kl1
  ; new >
  TST.b debugmode
  BEQ 'sk1
  MOVE.w #$4e71,d1
  JSR writeword
  MOVE.l a5,-(a7)
  MOVE.l a3,a5
  SUBQ.l #1,a5
  MOVE.w #$0,inmacro
  BSR debugstuffa
  MOVE.w #$FFFF,inmacro
  MOVE.l (a7)+,a5
  MOVE.w #$4e71,d1
  JSR writeword

 'sk1
  ; < new
  MOVEA.l A5,A4            ;start of parameters!

  ; new >
 'l5a
   CMP.b #" ",(a4)+
    BEQ 'l5a
     SUBQ.l#1,a4
     CMP.b #",",(a4)
    BEQ 'nops

 'l5b
  ; < new
  MOVEQ.l #$00,D4          ;narg=0
  ; new >
  TST.b newsyntax
  BEQ 'l10b
  MOVEM.l a0/d0,-(a7)
  MOVE.l 4(a2),a0
  MOVE.w 8(a2),d0

 'x2
  CMP.b #"`",(a0)+
  BEQ 'x1
  SUBQ.w #1,d0
  BNE 'x2
 BRA 'x3

 'x1
  MOVEM.l (a7)+,a0/d0
 BRA 'l10

 'x3
  MOVEM.l (a7)+,a0/d0
 BRA 'nops

 'l10b
  ; < new
  CMPI.b #"{",(A4)
   BNE.w 'nops
  ; new >
  ;BNE 'l10

 'l5
  ADDQ.l #1,a4

 'l10
    CMP.b #" ",(a4)
    BEQ 'l5
    MOVEM.l a0/d0,-(a7)
    CLR.b exmac
    LEA chartab,a0
    MOVEQ #0,d0
    MOVE.b (a4),d0
    BMI 'm1
    TST.b 0(a0,d0)
    BEQ 'm1
    TST.b newsyntax
    BEQ 'ns1
    CMP.b #"#",d0
    BEQ 'm1
    CMP.b #"$",d0
    BEQ 'm1
    CMP.b #"-",d0
    BEQ 'm1

 'ns1
  CMP.b #",",d0
    BEQ 'm1
    CMP.b #"{",d0
    BNE 'm1b
    ADDQ.l #1,a4
 BRA 'm1

 'm1b
  TST.b newsyntax
    BEQ 'm1
    MOVE.b #1,exmac

 'm1
  MOVEM.l (a7)+,a0/d0
    TST.b exmac
    BNE 'nops
    ;CMP.b #"|",(a4)
    ;BEQ 'nops
    ;CMP.b #":",(a4)
    ;BEQ 'nops
    ;CMP.b #";",(a4)
    ;BEQ 'nops
  TST.b (a4)
  BEQ 'nops

 'oldlab
  ; < new
  MOVEA.l ptr_macrobuffer_begin,A0    ;start of parameter collect

 'ppl
  ADDQ.w #1,D4                        ;another p
  MOVE.l A4,(A0)
  ; new >
  CLR.w 4(a0)
  ; < new
   BSR.w findit
  ;move.l A4,D1
  ; new >
  ADDQ.l #4,a0
  ; < new
  ;sub.l (A0)+,D1
  ;subq.w #1,D1
  ;move.w D1,(A0)+
  ; new >
  SUBQ.w #1,(a0)+
  ; < new
  CMP.b #$7D,D0     ;'}'
  ; new >
  BEQ 'l10b1
  TST.b d0
  BEQ 'l10b1
 BRA 'ppl
  ;< new
   ;bne.w 'ppl

  ; new >
 'l10b1
  CLR.l sourceline3
  ; <new
  MOVEA.l A4,A5

 'nops
  MOVE.w D4,numarg
  ; new >
  ;tst.l myoline
  ;beq 'l1c
  ; < new
  ;move.l myline,d0
  ; new >
; bra 'l10c

 'l1c
  ; < new
  MOVE.l #$01,D1
  MOVEA.l _execbase,A6
  ; new >
  MOVE.l mempool,a0
  MOVE.l macrobuffer_size,D0
  CMP.l #DEFAULT_MACROBUFFERSIZE,d0                          ; replaced with a constant tomsmart1
  BGE 'l1mc
  MOVE.l #DEFAULT_MACROBUFFERSIZE,d0                         ; replaced with a constant tomsmart1
  MOVE.l d0,macrobuffer_size

 'l1mc
  JSR _AllocPooled(a6)
  ; < new
   ;jsr do_AllocMem
  ;
  MOVE.l myline,myoline

  ; new >
 'l10c
  ADDQ.l #1,d0
  ; < new
  MOVE.l D0,myline
  MOVEA.l D0,A1
  ; new <
  MOVE.b #":",-1(a1)
  ; < new
  MOVEA.l A1,A6
  ADDA.l macrobuffer_size,A6   ;end of macro buffer
  ;
  MOVEA.l (A7)+,A0             ;start of the line

 'loop2
  CMPA.l A6,A1
   BCC.w JMP_mbovererr
  MOVE.b (A0)+,(a1)+
  CMPA.l A3,A0
   BCS.w 'loop2
  SUBQ.w #1,A1                 ;back over '#'
  ;
  MOVE.w $8(A2),D1             ;mac len
   BEQ.w 'loop4
  MOVE.w $A(A2),macnum
  ADDQ.w #1,$A(A2)
  MOVEA.l $4(A2),A2
  SUBQ.w #1,D1
  ; new >
  CLR.b firstmline
  ; < new

 'loop3
    MOVEQ.l #$00,D0
    MOVE.b (A2)+,D0
  ; new >
    TST.b firstmline
    BNE 'c1
    CMP.b #$22,d0         ;'"'
    BNE 's1
    MOVE.b #1,firstmline

   's1
    CMP.b #":",d0
    BNE 'm1a
    MOVE.b #1,firstmline

   'm1a
    CMP.b #";",d0
    BNE 'c1

   'l1d
    SUBQ.w #1,d1                                           ;filter out comment
    MOVE.b (a2)+,d0
    CMP.w #":@",-1(a2)
    BEQ 'c2
    TST.w d1
    BNE 'l1d
   BRA 'oky2

   'c2
    CMP.b #":",1(a2)
      BNE 'l1d
      ADDQ #2,a2
      SUBQ #3,d1
      MOVE.b (a2)+,d0
      MOVE.b #1,firstmline

   'c1
  ; < new
    CMP.b #"`",D0
     BNE.w 'oky
    SUBQ.w #1,D1
    MOVE.b (A2)+,D0
    CMP.w #$7B,D0       ;'{'
     BEQ.w 'evalit
    CMP.w #$40,D0       ;'@'
     BNE.w 'notnum
    ;
    ;macro num parameter
    ;
    MOVEQ.l #$00,D2
    MOVE.w macnum,D2
    MOVEA.l A1,A0
    MOVE.w D1,-(A7)
    JSR makelong
    MOVEA.l A0,A1
    MOVE.w (A7)+,D1
    ;
   BRA.w 'oky2

   'notnum
    ORI.w #$20,D0
    CMP.w #$7A,D0       ;'z'
     BCS.w 'fkit
   JMP ilconsterr

   'fkit
    SUBI.w #$30,D0
    CMP.w #$A,D0
     BCS.w 'itsgot
    ;
    SUBI.w #$27,D0
    CMP.w #$A,D0
     BCC.w 'fkit2
   JMP ilconsterr

   'fkit2
   BRA.w 'itsgot

   'evalit
    MOVE.l A5,-(A7)
    MOVEM.l D1/A1-A2/A6,-(A7)
    MOVEA.l A2,A5
     JSR evalconst2
    CMP.w #$7D,D0      ;'}'
     BEQ.w 'allisok
   JMP syntaxerr

   'allisok
    MOVEM.l (A7)+,D1/A1-A2/A6
    MOVE.l A5,D2
    SUB.l A2,D2
    SUB.w D2,D1
    MOVEA.l A5,A2
    ;
    CLR.w instringon
    MOVEA.l (A7)+,A5
    ;
    MOVE.l D3,D0
    BPL.w 'itsgot
   JMP ilconsterr

   'itsgot
    SUBQ.w #1,D0
     BPL.w 'ok
    ;
    ;here, we do a numarg text replace
    ;
    MOVE.w numarg,D0
    DIVU #$A,D0
    ADDI.w #$30,D0
    CMPA.l A6,A1
     BCC.w JMP_mbovererr
    MOVE.b D0,(A1)+
    SWAP D0
    ADDI.w #$30,D0
    CMPA.l A6,A1
     BCC.w JMP_mbovererr
    MOVE.b D0,(A1)+
   BRA.w 'oky2

   'ok
    ;ok to do parameter replacement
    ;d0= number for parameter replacement!
    ;
    CMP.w numarg,D0
     BCC.w 'oky2
    LSL.w #1,D0
    MOVE.w D0,D4
    LSL.w #1,D0
    ADD.w D4,D0          ;*6
    MOVEA.l ptr_macrobuffer_begin,A0
    ADDA.w D0,A0
    MOVE.w $4(A0),D4     ;len of replacetext
     BEQ.w 'oky2
    MOVEA.l (A0),A0
    SUBQ.w #1,D4

   'plp
      CMPA.l A6,A1
       BCC.w JMP_mbovererr
    ; new >
      CMP.w #"@@",(a0)
       BNE 'l10e
      TST.w ininclude
       BNE JMP_errorjoin

    'l111e
      MOVE.l sourceline,a0
      MOVE.l (a0),a0
      CMP.l #0,a0
      BNE 'l11e
      MOVEQ #0,d0
      JSR error

    'l11e
      MOVE.l a0,sourceline
      ADDQ.l #1,linenumat
      LEA 9(a0),a0
      MOVE.l a0,-(a7)

    'l110e
      CMP.b #" ",(a0)+
       BEQ 'l110e
      CMP.b #";",-1(a0)
      MOVE.l (a7)+,a0
       BEQ 'l111e
      SUBQ.l #1,d4

    'l10e
     ; < new
      MOVE.b (A0)+,(A1)+
    DBF D4,'plp

    BRA.w 'oky2

   'oky
    CMPA.l A6,A1
     BCC.w JMP_mbovererr
    MOVE.b D0,(A1)+
     BPL.w 'oky2
    CMPA.l A6,A1
     BCC.w JMP_mbovererr
    MOVE.b (A2)+,(A1)+
    SUBQ.w #1,D1

   'oky2
   DBF D1,'loop3
  ; new >
  ;tst.l numarg
  ;beq 'loop4
  ;cmp.b #"}",-1(a5)
  ;beq 'loop4
  ;subq.l #1,a5
  ; < new

 'loop4
  CMPA.l A6,A1
   BCC.w JMP_mbovererr
  MOVE.b (A5)+,(A1)+
   BNE.w 'loop4
  ;
  MOVEA.l myline,A5
  ;
  MOVE.l myoline,D0
   BEQ.w 'skip3
  ; new >
  SUBQ.l #1,d0
  ; < new
  MOVEA.l D0,A1
  MOVE.l macrobuffer_size,D0
  MOVEA.l _execbase,A6
  ; new >
  MOVE.l mempool,a0
  JSR _FreePooled(A6)
  ; < new
  ;jsr freemem(a6)

 'skip3
 BRA.w 'loop0

 'done
  MOVEA.l (A7)+,A5
RTS

JMP_mbovererr: JMP mbovererr
JMP_errorjoin: JMP errorjoin

freembuff:
  MOVE.l myline,D0
  BEQ.w 'no
  ; new >
  SUBQ.l #1,d0
  ; < new
  CLR.l myline
  MOVEA.l D0,A1
  MOVE.l macrobuffer_size,D0
  MOVEA.l _execbase,A6
  ; new >
  MOVE.l mempool,a0
 JMP _FreePooled(A6)
  ; < new
  ;jmp freemem(a6)

 'no
RTS


findit:
  ;find the end of a parameter
  ;
  MOVEQ.l #$00,D2    ;no nesting

 'loop
  ; new >
  ADDQ.w #1,4(a0)
  ; < new
   MOVE.b (A4)+,D0
   ;beq.w syntaxerr
  ; new >
   BEQ exit1
  ; < new
   BPL.w 'tst
  ; new >
  ADDQ.w #1,4(a0)
  ; < new
  ADDQ.w #1,A4
 BRA.w 'loop

 'tst
  ; new >
   TST.w instringon
   BNE 'lnom
   CMP.b #";",d0
   BEQ exit2
   CMP.b #":",d0
   BEQ exit2

 'lnom
  ; < new
  CMP.b #$22,D0           ;'"'
   BNE.w 'notq
  NOT.w instringon
 BRA.w 'loop

 'notq
  TST.w instringon
   BNE.w 'loop
  ; new >
   CMP.b #"@",d0
   BNE 'l10
   CMP.b #"@",(a4)
   BNE 'l10
   TST.w ininclude
   BNE JMP_errorjoin
   MOVE.l sourceline3,a4
   CMP.l #0,a4
   BNE 'l11
   MOVE.l sourceline,a4

 'l11
  MOVE.l (a4),a4
      CMP.l #0,a4
      BNE 'l12
      MOVEQ #0,d0
      JSR error

 'l12
   MOVE.l a4,sourceline3
   LEA 9(a4),a4
   MOVEQ #",",d0

 'l10
  ; < new
  CMP.b #$2C,D0       ;','
   BNE.w 'notc
  TST.w D2
   BEQ.w 'done
 BRA.w 'loop

 'notc
  ;bsr.w isitopen
  ; new >
   CMP.b #$7B,D0      ; same as itisopen                                     ;"{"
   BEQ.w 'l10b
  CMP.b #$28,D0                                            ;"("

 'l10b
  ; < new
   BNE.w 'noto
  ADDQ.w #1,D2
 BRA.w 'loop

 'noto
  CMP.b #$7D,D0       ;'}'                                    ;"}"
   BNE.w 'notcb
 TST.w D2
   BEQ.w 'done

 'notcb
  ;bsr.w isitclose
  ; new >
   CMP.b #$7D,D0     ; same as isitclose                                       ;"}"
   BEQ.w 'l10a
  CMP.b #$29,D0                                            ;")"

 'l10a
  ; <  new
   BNE.w 'loop
  SUBQ.w #1,D2
BRA.w 'loop

 'done
RTS

;JMP_errorjoin JMP errorjoin


; new >
exit1
      SUBQ.l #1,a4
      CLR.l sourceline3
RTS


exit2
      MOVEQ #0,d0
      SUBQ.l #1,a4
      CLR.l sourceline3
RTS
; < new


isitopen:
  CMP.b #$7B,D0        ;'{'                                     ;"{"
  BEQ.w 'yes
  CMP.b #$28,D0        ;'('                                    ;"("

 'yes
RTS


isitclose:
  CMP.b #$7D,D0         ;'}'                                   ;"}"
  BEQ.w 'yes
  CMP.b #$29,D0         ;')'                                   ;")"

 'yes
RTS


;stopbit:   Ds.w 1
stopit:     Ds.w 1
clrreq:     Ds.w 1

;stopcode:                  ; was only used by the old openstopreq
;  MOVE.w stopit(PC),D1
;  BNE.b 'skip
;  MOVE.w stopbit(PC),D1
;  BTST D1,D0
;  BEQ.b 'skip
;  ;MOVE.w #-1,stopit
;  ;
;  MOVEM.l D0/A6,-(A7)
;  MOVE.l signals(PC),D0
;  MOVEA.l ptr_ThisTask,A1
;  MOVEA.l _execbase,A6
;  JSR _Signal(A6)
;  MOVEM.l (A7)+,D0/A6

; 'skip
;RTS


.close_compilewin:         ; was endstop  org source
  MOVE.w clrreq(PC),D0
  BEQ.w 'skip
    ;removed call to close window because is now closed by the GUI (PED)
    LEA clrreq,a0
    NOT.w (a0)                                               ;reass
    ;MOVEA.l ptr_ThisTask,A0
    ;CLR.l $1E(A0)
    ;CLR.l $2A(A0)
    !basic
    *compilerTask\tc_SigExcept = 0
    *compilerTask\tc_ExceptCode = 0
    !asm
 'skip
RTS


intsused:  Ds.w 1


setcvars:
  MOVE.w #-1,blitzoff
  CLR.w intsused
  CLR.w anyerrs
  CLR.w blitzmode
  CLR.w dontwrite_nomemleft                                              ;nomemleft
  CLR.w constmode
  CLR.w cmake
  CLR.w cfetchmode
  CLR.l intdata1
  CLR.w fuckpos
  CLR.w procnum
  CLR.w procnum2
  CLR.w dfetch
  CLR.l titleat
  CLR.b usedpath
  CLR.b path2
  CLR.w inerr
  CLR.w intlevel
  CLR.l cont_pc
  CLR.l cont_pc2
  CLR.l lastcontlink
  ;
  MOVE.l destbufferstart,destpointer
  MOVE.l destbufferstart,bigpc
  MOVE.l destbufferend,libend
  MOVE.l data1start,data1
  MOVE.l data2at,data2
  ;
  MOVE.w #-1,skipcode                                      ;#-1,comflag org source
  MOVE.w #-1,linemode                                      ;#-1,linemode org soruce
  CLR.w oldvcodelen
  CLR.b lastgloballabel                                    ;lastbiglab org source
  ;
RTS


debugmode:  Ds.w 1                                         ;debugga org source ;debugger enabled?


.compilerequester:           ; was openstopreq org source
  LEA  clrreq,a1
  MOVE.w #2000,(a1)
  !basic
  comstatusstr  = !TRANS{"Initializing Compiler..."} ;default settings
  calcpro       = 0
  calcpro_old   = 0
  typ_old       = -1
  pass_old      = -1
  update_comstatus_gui = True ; for the first

  GetReg D0,&comstatusstr : !ComData_SetL{comPtr_CompileStatusString,d0}  ; set pointer of status string for gui tomsmart1 2012 05 12
  GetReg D0,&calcpro      : !ComData_SetL{comPtr_CompileCalcProLong ,d0}  ; set pointer of calcpro long for gui tomsmart1 2012 05 12
  !asm
  ;removed call to open window because is now opened by the GUI (PED)

  CLR.w stopit
RTS


.compileall:   ; was dopass
  ;compile entire program based on 'pass'
  ;
  ; new >
  CLR.w storedebugmode
  CLR.b iserror
  ; < new
  BSR.w compilerequester
  ; new >
  MOVE.l #0,globallinecount
  JSR check_of_same_source
  ; < new
  BSR.w setcvars
  ;
  MOVE.w #$8000,globalvarpointer
  MOVE.l #newtype_quick,defaulttype
  ;
  MOVE.l A7,passstack
  MOVE.l #firstitem_,sourceline
  MOVE.w numlines_org,linesleft
  ; new >
  MOVE.l numlines,numlines2
  ; < new
  ADDQ.w #1,linesleft
  ADDQ.l #1,numlines2
  MOVE.l #-1,linenumat
  ;
  BSR.w resetlibs
  BSR.w Aclearallvars
  ;
  LEA progress_per_line+2,A0
  MOVEQ.l #$03,D0

 'okloop
    CLR.w (A0)+
  DBF D0,'okloop

  ; new >
 'l2a
  LEA _include,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA ptr_parameterstore,a1

 'l1b
    MOVE.b (a0)+,(a1)+
  BNE 'l1b

  MOVEQ #9,d2
  JSR findlabel2
  BNE 'd
    MOVE.l #0,8(a2)
    MOVEM.l (a7)+,a0-a6/d0-d7
    BRA 'd2
 'd
    JSR addlabelhash
    MOVE.l #$1,$4(A2)
    MOVE.l #0,8(a2)
    MOVEM.l (a7)+,a0-a6/d0-d7
 'd2

  LEA _debug,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA ptr_parameterstore,a1
 'l9b
    MOVE.b (a0)+,(a1)+
  BNE 'l9b

  MOVEQ #7,d2
  JSR findlabel2
  BNE 'd9
    MOVE.b debugmode(PC),D0
    EXT.w d0
    EXT.l d0
    MOVE.l d0,8(a2)
    MOVEM.l (a7)+,a0-a6/d0-d7
    BRA 'd9b
 'd9
    JSR addlabelhash
    MOVE.l #$1,$4(A2)
    MOVE.b debugmode(PC),D0
    EXT.w d0
    EXT.l d0
    MOVE.l d0,8(a2)
    MOVEM.l (a7)+,a0-a6/d0-d7
 'd9b

  ; check for DEBUG-String (no TOKEN!!)
  MOVE.l #firstitem_,a0
  MOVE.l (a0),a0
  LEA 9(a0),a0
  MOVE.w #0,exdebug
  TST.b debugmode
  BEQ 'l10
   'l2
    MOVE.b (a0)+,d0
    BEQ 'l10
    CMP.b #$20,d0
    BEQ 'l2
      SUBQ.l #1,a0
      CMP.l #"DEBU",(a0)
      BNE 'l10
        CMP.b #"G",4(a0)
        BNE 'l10
          MOVE.w #$0,debugversion
          MOVE.b #1,exdebug
 'l10
  ; < new
  ;
  ;put in 4 nops for dummy JSR to init routines! (was 3)
  ;
  LEA nops4,A0
  LEA nopsf,A1
  JSR pokecode2                                            ;write intro nops
  ; new >
  MOVE.l #$01010101,d1
  JSR writedatalong                                        ;for the 4 tempregs
  JSR writedatalong
  JSR writedatalong
  JSR writedatalong
  TST.b saved0
  BEQ 'l1
    MOVE.l #$4e714e71,d1
    JSR writelong                                            ;add 2 nops
    MOVE.l #$4e714e71,d1
    JSR writelong                                            ;add 2 nops
    MOVE.l #$4e714e71,d1
    JSR writelong                                            ;add 2 nops
     MOVE.l #$4e714e71,d1
    JSR writelong                                            ;add 2 nops
 'l1
  ; new >
  MOVE.b debugmode(PC),D1
  BEQ.b 'dskip
    MOVE.b debugmode,storedebugmode
    ;
    MOVE.w #$FFDC,D1        ;#runerrlib,
    BSR.w uselib
    ;
    TST.w debugversion                                       ;make a version for debugger
    BNE.b 'exec
      ;
      ;not executable!
      ;
      MOVE.w #$FA3C,D1        ;#debuglib,
      BSR.w uselib
      MOVE.w #$0001,D1        ;#dhandlerlib,
      BSR.w uselib
      BRA.b 'dskip
   'exec
    ;is executable!
    ;
    MOVE.w #$FA32,D1        ;#rundebuglib,
    BSR.w uselib
 'dskip

  BSR.w nextline
  ; new >
  CLR.l linenum
  CLR.l stacktrack
  ; < new


  passloop:
    ADDQ.l #1,linenum
    MOVE.l destpointer,destpointer2
    MOVE.l a5,sourceline2

    BSR.w compile_line                                        ;compile pass

    passnxt:
    BSR.w nextline
  BNE.w passloop

  BSR.w JUMP_do_runerrson
  BSR.w pointchk
  ; new >
  TST.b objectcount
  BNE JMP_macenderr
  ; < new
  CLR.l linenumat
  BSR.w errchx2
  ; new >
  CMP.l #-1,bssend
  BNE 'l30
    MOVE.l destpointer,bssend                                ;compile end
 'l30
  MOVE.l destpointer,d0

  CMP.l #-1,bssstart
  BNE 'lnf6
    CMP.l #-1,chipstart
    BNE 'lnf6
      BRA 'leven4
 'lnf6

  MOVE.l destpointer,d1
  ADDQ.l #3,d1
  AND.l #$fffffffc,d1                                      ;bug ?
  MOVE.l d1,destpointer

 'leven4
  MOVE.l destpointer,codeend
  CMP.l #-1,chipend
  BNE 'l31
    MOVE.l destpointer,chipend
 'l31                                                     ;write exitcode
  MOVE.l destpointer,d1
  ADDQ.l #1,d1
  AND.l #$fffffffe,d1                                     ;new evenexit
  MOVE.l d1,destpointer
  ; < new
  ;
  MOVE.b debugmode(PC),D1
  BEQ.b 'nodb
    BSR.w debugstuff
    MOVE.w #$C300,D1        ;#finalscheck,
    JSR Atokejsr
    BSR.w debugstuff
    MOVE.l eopcode(PC),D1
    JSR writelong
    MOVE.l lastcontlink(PC),D1
    BEQ.b 'nocl
      MOVEA.l D1,A0
      CLR.w $6(A0)
   'nocl
 'nodb
  ;
  ;end of whole program!
  ;
  MOVE.l destpointer,endop                                ;where end goes...
  ;
  TST.w blitzmode
  BEQ.w 'nobl
    BSR.w do_AMIGA                                          ;back to amiga if in blitz!
 'nobl

  TST.w intsused
  BEQ.b 'noints
    MOVE.w #$C105,D1                                        ;interupts off!
    JSR tokejsr2
 'noints

  BSR.w calcstatic
  MOVE.w D4,numstatic
  MOVE.l D3,staticdata
  BSR.w calcmaxs

  TST.l tokeslist
  BEQ.b 'skipjsrs
    MOVE.w gotocode,D1                                       ;jmp!
    JSR writeword
    MOVE.l destpointer,endjmpat
    BSR.w addoff
    JSR writelong
    BSR.w fixjsrs                                         ;has to be done before finits!
    ;
    ;misc finish-ups
    ;
    TST.w dontwrite_nomemleft
    BNE.b 'skipjsrs
      MOVEA.l endjmpat(PC),A4
      MOVE.l destpointer,(A4)
 'skipjsrs

  ; new >
  TST.b returncode
  BEQ 'l2
    MOVE.w #$2e80,d1
    JSR writeword
 'l2
  ; < new
  JSR makefinits
  ; new >
  TST.b returncode
  BEQ 'l3
    MOVE.w #$4e75,d1
    JSR writeword
    BRA 'l1
 'l3
    ; < new
    MOVE.l #$70004E75,D1
    JSR writelong                                            ;write moveq #0,d0:rts
 'l1
  JSR makeinits
  BSR.w asmfixer
  ;
  BSR.w close_compilewin
RTS


JUMP_do_runerrson JMP do_runerrson
JMP_macenderr JMP macenderr

;------                                                  ;disassembled code begin
eopcode:    Dc.b $70,$03                                   ;MOVEQ #$03,D0
            Dc.b $4E,$40                                   ;TRAP  #00
;------                                                  ;disassembled code end
endjmpat:   Ds.l 1

Even
pointchk:
  MOVEA.l newtype_string,A2
  MOVE.l #MaxByte,D0                                       ;move.l #$ff,d0 org source

 'loop
    CMPA.w #$0,A2
     BEQ.w 'done
    CMP.l $4(A2),D0
     BNE.w 'next
    MOVE.w $8(A2),linenumat+2                              ;type not found  ;move 8(a2),linenumat org source
 BRA.w JUMP_notypeerr1

 'next
    MOVEA.l (A2),A2
 BRA.w 'loop

 'done
RTS


errchx2:
  LEA labelbase,A2
  ;Make sure all the labels have been resolved

 'loop
  MOVE.l (A2),D0                                           ;testlabels
   BEQ.w 'done
  MOVEA.l D0,A2
  MOVE.l $4(A2),D0
  BTST #$0,D0
   BNE.w 'loop
  MOVE.l $8(A2),D0
   BNE.w 'loop
  MOVE.w $10(A2),linenumat+2
  MOVEQ #0,d0
  MOVE.b $12(a2),d0
  MOVE.w 0(a2,d0),linenumat
 JMP nolaberr                                               ;label not found

 'done
  MOVE.l concomsp,D0
  CMP.l #concomstack,D0
   BNE.w chxerr4
  MOVE.w connest,D1
   BNE.w chxerr4


errchx:
  MOVE.l D1,-(A7)
  MOVE.l firstsel,D1
   BNE.w 'err1
  MOVE.l firstrep,D1
   BNE.w 'err2
  MOVE.w intstring,D1
   BNE.w 'err3
  MOVE.l 4(a7),d1
  MOVE.w proceduremode,D1
   BNE.w 'err6
  MOVE.l firstiff,d1
   BNE 'err5
  MOVE.l firstfor,D1
   BNE.w 'err7
  MOVE.l (A7)+,D1
 RTS

 'err1
  MOVE.l sellineat,linenumat
 JMP selerrz

 'err2
  MOVE.l replineat,linenumat
 JMP unterr3

 'err3
  MOVE.l intlineat,linenumat
 JMP interr2

 'err5
  MOVE.l iflineat,linenumat
 JMP noenderr

 'err6
  MOVE.l prolineat,linenumat
 JMP nopenderr

 'err7
  MOVE.l forlineat,linenumat
JMP nonexterr


chxerr4:
  MOVE.l ciflineat,linenumat
JMP nocenderr


calcmaxs:                                                  ;How many max's used in prog?
  MOVE.l data1,maxsat
  MOVEQ.l #$00,D4
  MOVEA.l libpointer,A2

 'loop
    CMPA.w #$0,A2
     BEQ.w 'done
    TST.w $C(A2)
     BPL.w 'next
    MOVE.l $12(A2),D0
    TST.w -$2(A2,D0.L)
     BEQ.w 'next
    ;
    ADDQ.w #1,D4
    MOVE.w -$6(A2,D0.L),D1
    BSR.w pokedata1
    MOVEQ.l #$01,D1
    MOVE.w -$2(A2,D0.L),D2
    LSL.w D2,D1
    MULU -$4(A2,D0.L),D1                                   ;write objectspacesize
    BSR.w writedatalong

 'next
    MOVEA.l (A2),A2
 BRA.w 'loop

 'done
  MOVE.w D4,maxsused
   BEQ.w 'done2
  MOVE.w #$FFFA,D1       ;was #65530    ;use memlib                                  ;;use memlib
BRA.w uselib

 'done2
RTS


;was compilepass
.compile_line:                                              ;doline org source
  ; new >
  MOVE.l a7,stackaddr
  ; < new
  BSR.w compile_term
  BSR.w reget
  BNE.w JMP_illeolerr
  ; new >
  TST.w dontwrite_nomemleft
  BNE 'l1
    TST.l stacktrack
    BNE errormsg_stack
 'l1
  ; < new
  CMP.w ##TokenID_Else,D0            ; was #$8000+34
  BNE.w 'notelse
    JSR do_else2
    BRA.w compile_line
 'notelse
  TST.w D0
  BNE.w compile_line
    ;
    ;here we do any 'un-thens'
    ;
 'unthen
  MOVE.l firstiff,D0
  BEQ.w 'done
    MOVEA.l D0,A0
    MOVE.w $C(A0),D1
    BPL.w 'done
    ;
    ;an If...Then... found!
    ;
    BCLR #$F,D1
    JSR doendif2
    JSR freetheifz
  BRA.w 'unthen
 'done
RTS

JMP_illeolerr:  JMP illeolerr
JMP_nolocerr:   JMP nolocerr

createlab:                                                 ;loclabch fetched, make a big label!
  LEA lastgloballabel,A0
  TST.b (A0)
  BEQ.w JMP_nolocerr
  LEA ptr_parameterstore,A1

  MOVEQ.l #$00,D2
 'loop
    ADDQ.w #1,D2
    MOVE.b (A0)+,(A1)+
  BNE.w 'loop

  MOVE.b #$27,-$1(A1)
  MOVE.w D2,-(A7)
  JSR makename4
  CMP.w (A7)+,D2
  BEQ.w JUMP_syntaxerr1

  TST.w d0
  BPL 'done
    MOVE.w #$3a,lastchar
   SUBQ.l #2,a5
 'done
RTS


prepstack:
  MOVE.l #forthstack,forthsp
  MOVE.l #precstack,precsp
RTS


chkrealstop:
    ;
    ;return ne if really a stop!
    ;
  MOVEQ.l #$00,D4

 'loop                                                    ;??looks like label not used??
  !basic
  !ComData_GetB{comByte_CompileStatusAbortByte,d0} : PutReg d0,c_abort.b   ; get status of abort 0=no 1=yes , no separte routine because event handling move to ped update_compilerstatus_window  tomsmart 2012 02 26

  If (c_abort = 1)           ; check if set
    MOVEQ.l #-$01,d4
    MOVE.w D4,stopit
    !asm
    BRA 'skip
  EndIf
  !asm
  MOVEQ.l #$00,D6
  MOVEQ.l #$00,D7                                          ; clr Z-Flag for beq.b in chkstop_chk

 'skip
  ;MOVE.w D4,stopit
RTS


chkstop:
  MOVE.w stopit(PC),D0
  BEQ 'chk
  ; new >
  SUBQ.w #1,stopit
  ;BNE.b 'chk
  ; new >

 'rts
 RTS

 'chk
  ; new >
  MOVE.w #2000,stopit
  ; < new
  BSR.w chkrealstop
  BEQ.b 'rts
;
;gostop
  BSR.w close_compilewin
  ;
  MOVEA.l errstack,A7
  MOVEA.l errcont,A0
  MOVE.w #-1,anyerrs
JMP (A0)


d_pc:           Ds.l 1
d_bigpc:        Ds.l 1
d_nomemleft:    Ds.w 1
cont_pc:        Ds.l 1
cont_pc2:       Ds.l 1
lastcontlink:   Ds.l 1


writetrap:                                                 ;maketrap org source
  ORI.w #$4E40,D1
BRA.w JUMP_writeword


debugstuff:
  TST.b debugmode
  BEQ.w debugstuffa_rts

  ; new <
debugstuffa:
  CNIF #debugmacro=0
  ; < new
    TST.w inmacro
    BNE debugstuffa_rts                                     ;disable to show macros in debugger
  ; new >
  CEND
  ; < new                                                     ;no debugging of Macros!
  TST.w direct_mode                                            ;or while in direct mode...
   BNE debugstuffa_rts
  ;
  MOVE.l destpointer,d_pc
  MOVE.l bigpc,d_bigpc
  MOVE.w dontwrite_nomemleft,d_nomemleft
  ;
  MOVEM.l D0-D1,-(A7)
  ;
  MOVEQ.l #$01,D1
   BSR.w writetrap                                         ;write the adress to sourceline
  ;
  ;hook up cont address...
  ;
   MOVE.l destpointer,D0
  MOVE.l cont_pc,D1
  MOVE.l D0,cont_pc
  MOVE.l D1,cont_pc2
   BEQ.b 'skip
  ;
  TST.w dontwrite_nomemleft
   BNE.b 'skip
  ;
  MOVEA.l D1,A4
  SUB.l A4,D0
  MOVE.w D0,$6(A4)
  MOVE.l A4,lastcontlink

  ; new >
 'skip
  TST.w ininclude
  ;BEQ 'noinc
  TST.w makeexec
  BEQ 'l1
  TST.w exdebug
  BEQ 'noinc

 'l1
  MOVEM.l a0-a1/d2/d3,-(a7)                                ;write source for includes
  MOVE.l data1,d1
  TST.b firsttime
  BNE 'nofirst
  MOVE.b #1,firsttime
  MOVE.l #"DuCk",d1                                        ; to found from debugger the code start
  JSR writedatalong
  MOVE.l #"AmiB",d1
  JSR writedatalong
  MOVE.l destbufferstart,d1
  JSR writedatalong
  TST.w dontwrite_nomemleft
  BNE 'nohunk
  MOVE.l data1,d1
  SUBQ.l #4,d1
  SUB.l destbufferstart,d1
  MOVE.l d1,d2
  JSR addhunkoffset

 'nohunk
  MOVE.l destpointer,d2
  MOVE.l data1,d1

 'nofirst
  MOVE.l destpointer,d2
  MOVE.l d1,d3
  SUB.l destbufferstart,d1
  OR.l #$80000000,d1
  JSR writelong
  TST.w inmacro
  BEQ 'sc1
  MOVE.l myline,a0
  ;SUBQ.l #1,a0
 BRA 'inc2

 'sc1
  TST.w ininclude
  BEQ 'inc
  MOVE.l includesourceline,a0
 BRA 'inc2

 'inc
  MOVE.l sourceline,a0
  LEA 9(a0),a0

 'inc2
  MOVE.l d1,d2
  MOVE.l A5,D1
  SUB.l a0,D1
  ADD.l #9,d1
  BSR.w JUMP_writeword
  CMP.l #9,d1
  BEQ 'pos1
  TST.w dontwrite_nomemleft
  BNE 'nopad
  MOVE.l lastsourceline,d1
  MOVE.l d1,-6(a4)
 BRA 'nopad

 'pos1
  MOVE.l d2,lastsourceline
   MOVE.l destpointer,lastdestpointer
   MOVEQ #0,d1
  MOVE.l data1,d2
  SUB.l destbufferstart,d2
  JSR writedatalong
  TST.w dontwrite_nomemleft
  BNE 'no2
  JSR addhunkoffset

 'no2
  MOVE.l data1,d2
  SUB.l destbufferstart,d2
  JSR writedatalong
  TST.w dontwrite_nomemleft
  BNE 'no
  JSR addhunkoffset
  MOVE.l lastwritedat,a1
  CMP.l #0,a1
  BEQ 'no
  MOVE.l d3,(a1)
  MOVE.l prevwritedat,4(a1)
  MOVE.l lastwritedat,prevwritedat

 'no
  MOVE.l d3,lastwritedat
  MOVEQ #4,d1
  BSR pokedata1b

 'loop
  MOVE.b (a0)+,d1
  BEQ 'done
  BSR pokedata1b
 BRA 'loop

 'done
  MOVEQ #0,d1
  BSR pokedata1b
  MOVE.l data1,d1
  BTST #0,d1
  BEQ 'nopad
  MOVEQ #0,d1
  BSR pokedata1b

 'nopad
  MOVEM.l (a7)+,a0-a1/d2/d3
 BRA 'noinc2

 'noinc
  ; < new
  MOVE.l sourceline,D1
  JSR writelong
  MOVE.l A5,D1
  SUB.l sourceline,D1
  JSR writeword

 'noinc2
  MOVEQ.l #$00,D1
  JSR writeword          ;next cont goes here!                                  ; was: BSR.w writeword
  ;
  MOVEM.l (A7)+,D0-D1

 debugstuffa_rts:
RTS


undodebug:
  TST.b debugmode                                          ;extern debug
  BEQ.b 'rts
    TST.b direct_mode
    BNE 'rts
      ;
      ; new >
      CNIF #debugmacro=0
        TST.w inmacro
        BNE.b 'rts
      CEND
      ; < new
      MOVE.w d_nomemleft,dontwrite_nomemleft
      MOVE.l d_bigpc,bigpc
      MOVE.l d_pc,destpointer
      MOVE.l cont_pc2,cont_pc
 'rts
RTS


setsvars:                                                  ;set statement vars...
  ;bsr.w prepstack
  MOVE.l #forthstack,forthsp
  MOVE.l #precstack,precsp
  CLR.w regnum
  CLR.w nonew
  CLR.w sbasegot
  MOVE.w varcodelen,oldvcodelen
  CLR.w varcodelen
  MOVE.w #-1,lasta6
RTS


smode:                                                     ;special mode...d1...
  TST.w linemode
  BMI.b 'skip
    BSR.w undodebug
    MOVE.w linemode,D1
    ADDQ.w #4,A7
    LSL.w #2,D1
    LEA modetable,A0
    MOVEA.l $0(A0,D1.W),A0
    BSR.w reget
    JMP (A0)                                                   ;jumptokenroutine
 'skip
RTS


; was compileloop
.compile_term:        ; was  dostatement  org source      ;a0 sourceline  a5 sourcepos compile a term to next ":" or until end of line
  ;process individual statement
  ;                                      
  ; new >
  MOVE.w #0,leaa0a0+2
  CLR.b nowdeclare
  CLR.b notypecheck
  CLR.l lasttoken
  CLR.b doimmediate
  CLR.w vartype
  CLR.w regnumfunc
  CLR.b optistring
  CLR.b iniffcommand
  CLR.w instringon  ; new
  CLR.b funccall
  CLR.l currentfunccall
  CLR.l leftsidetype
  CLR.l rightsidetype
  CLR.w leftsideflagmask
  CLR.w rightsideflagmask
  CLR.b peekaddrsize
  CLR.b blitzparloop
  CLR.b funcparloop
  CLR.w parnum           ;7.2014

  TST.b debugmode
  BEQ 'fpu
    CNIF #fpudebug=0
      CLR.b fpu                                              ;fpu off when debug
    CEND
 'fpu
  MOVE.b fpu,iee

  MOVE.w stopit(PC),D0
  BNE 'chkstop_chkb
    ; < new
    BSR.w chkstop                                          ; message here
    ; new >
 'chkstop_chkb
  SUBQ.w #1,stopit

 'l20
  ; < new
  BSR.w findmacro                                          ;macro
  ; new >

  CNIF #funcscan
    TST.l funcscan
    BEQ funcscanskip

   ;.funcscan_
    CLR.b instringf
    BSR.w get1bytemain
    CMP.w #"#",d0
    BNE 'lf9b
    JSR handleconst
   BRA 'lf9b

   'lf9
    BSR.w get1bytemain

   'lf9b
    CMP.w #$22,d0
    BNE 'nos
    NOT.b instringf

   'nos
    TST.b instringf
    BNE 'sk3
    CMP.w ##TokenID_Statement,d0                      ; $8008
    ;BEQ 'lf4
    CMP.w ##TokenID_Function,d0                       ; $8009
    ;BEQ 'lf4

   'sk1
    CMP.w ##TokenID_XINCLUDE,d0                                        ;xinclude $8012
    BNE 'sk2
    ADDQ.l #2,lastsourcepos
    JSR do_xinclude

   'sk2
    CMP.w ##TokenID_INCLUDE,d0                                        ;include $8013
    BNE 'sk3
    ADDQ.l #2,lastsourcepos
    JSR do_INCLUDE

   'sk3
    TST.w lastchar
    BNE 'lf9
   RTS

   'lf4
   RTS
  CEND
   ; < new
   ;    bsr debugstuff
   ;
   ;bra    handlechar
   ;


funcscanskip:    ; was  handlechar   org source
  ;Handle the first character in statement
  ;
  ;BSR.w get1bytemain                                       ;gettokenmain
  ;new >
  TST.b debugmode
  BEQ.s 'l10
    TST.b exdebug
    BEQ 'l10a
      MOVE.w (a5),d0
      CMP.w ##TokenID_Dc,d0                                      ; $8025
      BEQ 'l10
   'l10a
    BSR.w debugstuffa                                         ;insert runtimecode debugcode
 'l10

 'l1
  BSR.w get1bytemain                                       ;gettokenmain
  BEQ.w undodebug

  CMP.w #$002b,d0                                            ;check for + cast sign
  BNE 'lb2
    BSR.w get1bytemain
    MOVE.b #1,notypecheck
 'lb2
  ; < new
  ;beq handleeol
  ; new >
   ;  CMP.l #2698,globallinecount
   ;BNE 'lb1
   ; trap #0

 'lb1
  MOVE.l #forthstack,forthsp
  MOVE.l #precstack,precsp
  CLR.w regnum
  CLR.w nonew
  CLR.w sbasegot
  MOVE.w varcodelen,oldvcodelen

  CLR.w varcodelen
  MOVE.w #$FFFF,lasta6
  ; < new
  ;bsr.w setsvars
  BSR.w smode
  ;
  ; new <
  TST.w D0                 ; was behind cmp ... and befor handleascii in org source
  BMI.w get_tokencode      ; "
  ; < new
  CMP.w #$2E,D0            ;'.'
   BEQ.w handlemouse                                         ;shortlist
  CMP.w #"#",D0
   BEQ.w handleconst                                         ;constant found
  CMP.w #$27,D0            ;'''  ; was #loclabch
   BEQ.w handlelocal                                            ;local label
  ;
;handleascii
  MOVE.l A5,letstart
  JSR getparameter
  BSR.w reget
  BEQ.w handle_label                                         ;label found
  CMP.w #$7B,D0                                              ;'{'
  BEQ.w handle_statement

  ; new >
  TST.w d0
  BPL 'll1
    TST.b newsyntax
    BEQ 'll1
      LEA allowtab,a0
      MOVEQ #0,d1
      MOVE.b d0,d1
      TST.b 0(a0,d1.w)
      BNE 'll1
        SUBQ.l #2,a5
        MOVE.w #":",lastchar                                     ;no doublepoint
        BRA handle_label
 'll1
  CMP.l #"equ ",-1(a5)
  BEQ 'll4
    CMP.l #"EQU ",-1(a5)
    BNE 'll2
 'll4
  ADDQ.l #2,a5
  JSR findlabel2
  BEQ.w 'lf1
    JSR addlabelhash
    MOVE.l #$1,$4(A2)
 'lf1
  CMPI.l #$1,$4(A2)
  BNE.w illconerr
  BSR get1bytemain
  MOVE.l A2,-(A7)
     ;cmp.b #$30,d0
     ;blt 'lnonum
     ;cmp.b #$39,d0
     ;bgt 'lnonum
     ;bra 'lnum

 'lnonum
     ;cmp.b #"#",d0
     ;beq 'lnum
     ;move.b #"#",-2(a5)
  SUBQ.l #1,a5

 'lnum
  SUBQ.l #1,a5
  JSR evalconst2
  MOVEA.l (A7)+,A2
  MOVE.l D3,$8(A2)
  RTS
  BSR get1bytemain

 'll2
  CMP.l #"SET ",-1(a5)
  BNE 'll3
 BRA 'll4

 'll3
 ; < new
JMP dolet2


handleeol:
  CMP.w ##TokenID_Else,D0    ; was #$8000+34,
  BEQ.w get_tokencode
BRA.w undodebug       ;!*!*!


handlelocal:
  BSR.w undodebug    ;!***!
  BSR.w createlab
BRA.w handlelab2


handlemouse:
  BSR.w get1bytemain
  BEQ.w handleeol     ;syntaxerr
  CMP.w #"'",D0        ; was #loclabch
  BEQ.w handlelocal
  JSR makename2
  ; new >
   TST.w d0
   BPL handle_label
   SUBQ.l #2,a5
   MOVE.w #":",lastchar
BRA handle_label                                              ;????
  ; < new

JMP_duplaberr: JMP duplaberr


handle_label:
  ;an ordinary label
  ;
  BSR.w undodebug      ;!***!
  ;
  LEA ptr_parameterstore,A0
  LEA lastgloballabel,A1

 'coplab:
  MOVE.b (A0)+,(A1)+
   BNE.w 'coplab


handlelab2:
  JSR findlabel2
  BEQ.w 'found
  ;
  JSR addlabelhash

 'done
  CLR.l $4(A2)                ;no refs
  MOVE.l destpointer,$8(A2)   ;pc of label.
  ; new >
  ;clr.l $c(a2)
  ; < new
  ;move.l data2,$C(A2)        ;pc for data statements
  MOVE.w procnum,$10(A2)
 RTS

 'found
  MOVE.l $4(A2),D0
  BTST #$0,D0
   BNE.w illlaberr
  ; new >
  TST.w pass
  ;bne 'done
  ; new >
  MOVE.l $8(A2),D0
   BNE.w JMP_duplaberr
  MOVE.w procnum,$10(A2)
  ;
  ;now, we have to fill in blanks in the Bloody past code....
  ;
  MOVEA.l $4(A2),A3      ;start of refs list
  MOVEA.l _execbase,A6

 'floop:
  CMPA.w #$0,A3
   BEQ.w 'done
  ; new >
    MOVE.l $4(A2),D1
    BTST #$0,D1
    BNE.w illlaberr
  ; < new
  MOVE.w $8(A3),D1
  CMP.w $10(A2),D1
   BEQ.w 'isok
  ; new >
   TST.b newsyntax
   BEQ 'l1
 BRA.w 'isok                                            ;label context out of range fix
  ; < new
  ;
  ;Bad Reference
  ;
 'l1
  MOVE.w $A(A3),linenumat+2                                ;move 10(a3),linenumat org source
 BRA.w referr

 'isok
  MOVE.w dontwrite_nomemleft,D1
   BNE.w 'isaskip
  MOVEA.l $4(A3),A1
  BTST #$0,$7(A3)
   BEQ.w 'pcref
  ;
  ;OK it's a 'Restore' references
  ;
  SUBQ.w #1,A1
  MOVE.l data2,(A1)
 BRA.w 'isaskip

 'pcref
  MOVE.l destpointer,(A1)

 'isaskip
  MOVEA.l A3,A1
  MOVEA.l (A3),A3
  MOVE.l A3,$4(A2)     ;new first.
  MOVEQ.l #$0C+2,D0    ; was #12
  ;jsr freemem(a6)
  ; new >
  MOVE.l mempool,a0
  MOVEA.l _execbase,A6
  JSR _FreePooled(A6)
  ; < new
 BRA.w 'floop


handleconst:
  ;bsr.w prepstack                    ;forth stax
  ; new >
  MOVE.l #forthstack,forthsp
  MOVE.l #precstack,precsp
  ; < new
  JSR getparameter2           ; BSR.w
  ; new >
;.constant2
 ; < new
  JSR findlabel2
  BEQ.w 'cfound
    JSR addlabelhash
    MOVE.l #$1,$4(A2)
    BRA.w 'cn
 'cfound
    CMPI.l #$1,$4(A2)
    BNE.w illconerr
  ; new >
CNIF #errorconstant=1
    TST.b declare2
    BNE errormsg_declaredtwice
    TST.b declare
    BNE errormsg_declaredtwice
CEND
  ; < new
 'cn
  CMP.w #$3D,D0                                            ;'='
  BEQ.w 'asscon
    RTS
 'asscon
  MOVE.l A2,-(A7)
  JSR evalconst2
  MOVEA.l (A7)+,A2
  MOVE.l D3,$8(A2)                                         ;store constant
  ; new >
  CMP.w #$0a,lastchar
  BNE 'l1
    MOVE.w #":",lastchar                                   ; hack to read wizard include files
 'l1
  ; < new
RTS


JMP_noprocerr:
JMP noprocerr

handle_statement:                                          ;a procedure! - eg gameover{score.l,player}
  JSR find_procedure                                      ; A2 contains address of function data
  BEQ '_statement
    TST.l unusedfunc
    BEQ JMP_noprocerr                                           ; but this label is NOT defined !?
    JSR gotoendsource
 '_statement

  TST.b $5(A2)                                              ; this value seems to be always $FFFFFFF now
  ;BPL.w illprocerr                                         ; error function was formly called without returnpar

  MOVE.l a2,currentfunccall

  MOVE.b #1,funccall
  MOVE.b #1,isfunc(a2)

  MOVE.l $E(A2),-(A7)                                       ; pc of proc.
  MOVEQ.l #$00,D0
  MOVE.b $4(A2),D0                                          ; defined parameter count
  MOVE.l d0,parnumtemp
  BEQ.w 'no_defined_parameters                              ; if no parameters defined, we dont have to analyse anything

  TST.b $20(a2)                                             ; startposition on first optional parameter (+1)
  BNE 'no0par                                               ; $1F if all Parameters are mandatory
                                                            ; $00 if only optional parameters defined

  ;-- the procedure has only optional parameters defined
  ;-- lets check if there are any given with the call and init them with default values
  ;-- this is new stuff from Bernd Roesch
  MOVE.l a5,a4                                              ; a5 seems to contain the current sourcestring
 'l1
    CMP.b #$20,(a4)+                                        ; 32 " " --> skip space-characters
  BEQ 'l1
  CMP.b #"}",-1(a4)                                         ; if no parameters are given at all
  BNE 'no0par                                               ; jump to n0par

  MOVEQ #0,d0

  LEA $16(A2),A1                                            ; pointer to variable type list:
                                                            ; 01 ... byte, 02 ... word, 03 ... long,
                                                            ; 04 ... quick, 05 ... float, 06 ... string
 'again
  MOVE.l d1,-(a7)
  MOVE.b (a1),d2                                            ; in D2 we have the parameter datatype
  MOVE.l d0,d1                                              ; seems to be the register number

  CMP.w #4,d2                                               ; is it Type 4 "quick"?
  BNE 'l1b                                                  ; if no, branch ahead
    ADD.l #$203c,d1                                         ; move.l x,y, $0x00 codes the D-Register:
    JSR writeword                                           ; $203c: D0, $223c, D1, $243c: D2, ...
    MOVE.l #$ffff0000,d1
    JSR writelong                                           ; concrete: move.l #-$10000,dx
    BRA 'l2b
 'l1b
    TST.b fpu                                                ; test against 0
    BNE 'l1c                                                 ; if Zero-Flag is NOT set, then branch
      CMP.w #5,d2                                            ; is the variable Type 5 "float"?
      BNE 'l1c
        ADD.l #$203c,d1                                     ; write code move.l x,y
        JSR writeword
        MOVE.l #$800000c1,d1
        JSR writelong                                       ; concrete: move.l #-$7FFFFF3F,d2
        BRA 'l2b
   'l1c
      ADD.l #$70ff,d1
      JSR writeword                                         ; moveq.l #-$1,dx -> dx register in d1 will be ADD-ed with opcode

      CMP.w #7,d2
      BNE 'l1d
        MOVE.l #$2f3c0000,d1                                ; write code move.l #0,-(a7)
        JSR writelong
        MOVEQ #0,d1
        JSR writeword

        MOVE.l #$2f3c0000,d1                                ; write code move.l #0,-(a7)
        JSR writelong
        MOVEQ #0,d1
        JSR writeword
   'l1d
      TST.b fpu                                             ;remove fpustuff, if no fpu mode; honitos 20191113
      BEQ 'l3b
        MOVE.l #$f23c5000,d1                                ; write code fmove.w #-1,fpx
        MOVE.l d0,d2
        ASR.l #2,d2
        ADD.l d2,d1
        JSR writelong
        MOVE.w #$ffff,d1
        JSR writeword                                       ; concrete fmove.w #$-$1,fpx, fpx is masked in the 2. word $5xxxx
     'l3b
 'l2b

  MOVE.l (a7)+,d1
  ADDQ.l #1,a1
  ADD.l #$0200,d0
  CMP.l #$0e00,d0
    BEQ syntaxerr
  TST.b (a1)
  BNE 'again

  BRA 'no_defined_parameters

 'no0par
  MOVE.w a2offset,a2offset2
  LEA $16(A2),A2
  MOVE.b funcparloop,-(a7)
  MOVE.b #1,funcparloop
  MOVE.b blitzparloop,-(a7)
  CLR.b blitzparloop
  ; < new
  BSR.w fetchpees2
  ; new >
  MOVE.b (a7)+,blitzparloop
  MOVE.b (a7)+,funcparloop
  ; < new
  BRA.w 'nopars3


 'no_defined_parameters
  BSR.w get1bytemain

 'nopars3
  CMP.w #$7D,D0        ;'}'
   BNE.w morepar_                                          ;syntax error morepar
   JSR chkstak
  MOVE.l (A7)+,D1
  ; new >
;  CMP.l #6,parnumtemp
;  BLE 'l1d
;  CMP.l #11,parnumtemp
;  BGE 'l1d
;   TST.w a2offset
;   BEQ 'l1d
;   MOVE.l d1,-(a7)
;   MOVE.w #$47ef,d1                                        ;lea x(a7),a3 nat
;   BSR writeword
;   MOVE.w a2offset,d1
;   SUB.w a2offset2,d1
;   BSR writeword
;   MOVE.l (a7)+,d1

; 'l1d
  ; < new
   JSR makefjsr
  ; new >
;   CMP.l #6,parnumtemp
;  BLE 'skip2b
;  CMP.l #11,parnumtemp
;  BGE 'skip2b
;   TST.w a2offset
;   BEQ.w 'skip2b                                        ; changed
;   MOVE.l d1,-(a7)
;   MOVE.l #$4fef0000,d1                                    ; lea $x(a7),a7   nat
;   MOVE.w a2offset,d1
;   SUB.w a2offset2,d1
;   BSR.w writelong                                         ; correct stack with more parameters
;  MOVE.w numreps,movenumrep+2
;   BEQ.w 'skip2c
;  MOVE.l movenumrep,D1
;   BSR.w writelong

; 'skip2c
;  MOVE.w a2offset2,a2offset
;  MOVE.l (a7)+,d1

; 'skip2b
  CLR.b funccall
  ; < new
BRA.w get1bytemain


;trapme: Dc.w $0

.get_tokencode:                   ; blitz instruction found without return value
  ; process a token in d0
  ;
  ; new >
  MOVE.l d0,lasttoken

  ; preplace some Tokens with other ones
  ;CMP.w #$E08C,d0                  ; hack to replace GetD0 ($409f-$8000=$C09F) with GetRegD0 ($5D05-$8000=$DD05)
  ;BNE 'l2                          ; $608C-$8000  = E08C
  ;  TRAP #5
  ;  MOVE.w #$FFFF,trapme
  ;'l2
  ; CMP.w #$40a0,d0                 ; hack to replace PutD0 ($40a0-$8000=$C0A0) with GetRegD0
  ; BNE 'l3                         ; $608d-$8000 = E08D
  ;   MOVE.w #$dd06,d0
  ;'l3

  ; check for inline assembly
  ;
  CMP.w ##TokenID_ABCD,D0               ; check if token is an asm-token
  BCS.w 'nono
  CMP.w ##TokenID_List,D0               ; we have 76 asm tokens defined
  BCC.w 'nono

    BTST #$7,assemblercheck        ; was optreq2ga3+13                            ;inline Assembler checking
    BNE.b 'asmok
    ; new >
    TST.b debugmode
    BEQ.b 'l10

    CNIF #debugmacro=0
      TST.w inmacro
      BNE.b 'l10
    CEND

    MOVE.w d_nomemleft,dontwrite_nomemleft
    MOVE.l d_bigpc,bigpc
    MOVE.l d_pc,destpointer
    MOVE.l cont_pc2,cont_pc
   'l10
    ; < new
     ;bsr.w undodebug

   'asmok
    BRA.w assemble_it                         ;assemble the bastard
 'nono

  ; handle standard blitzlib token
  BCLR #$F,D0                                 ; found a token of a blitzlib
  MOVE.w D0,D1
  ANDI.w #$7F00,D1
  BNE.w handlelib
  ;

  ; check if asm type things....
  ; If so, no Line remembering etc!
  CMP.w #$B3,D0                               ; internal Instruction
  BCS.w 'isokat
    SUBI.w #$77,D0     ; was #tnum-fnum,
    CMP.w #$4B,D0      ; was #fnum+15
    BEQ.w 'noerr
      CMP.w #$46,D0    ; was #fnum+10,
      BEQ.w 'noerr
        BRA.w 'doerr                          ; change tokennum
 'isokat
  CMP.w #$38,D0        ; ALibJsr              ;check for things which don't want
  BEQ.w 'noerr                                ;error checking...
  CMP.w #$39,D0        ; TokeJsr
  BEQ.w 'noerr
  CMP.w #$D,D0         ; Macro
  BEQ.w 'noerr
  CMP.w #$12,D0        ; XINCLUDE
  BEQ.w 'noerr
  CMP.w #$13,D0        ; Include
  BEQ.w 'noerr
  CMP.w #$1A,D0        ; Data
  BEQ.w 'noerr
  CMP.w #$2A,D0        ; INCBIN
  BHI.w 'doerr
  CMP.w #$23,D0        ; EvenX
  BCS.b 'doerr

 'noerr
  BSR.w undodebug

 'doerr                                                ; change tokennum
  SUBQ.w #1,D0
  LSL.w #2,D0
  ;CMP.w #$170,D0       ; was #atokensend-atokens,
   ;BCS.w 'ok
  ;
  ;Freaked out Token!
   ;BSR.w flash         ; was a routine that change the color of screen,background or pointer
 ;
 ;RTS

 'ok
  LEA instructionbase,A0
  MOVEA.l $0(A0,D0.W),A0
  MOVE.l A0,-(A7)
BRA.w get1bytemain
 

.handlelib:            ; token in D0 
  ; a token from a library!
  ;
  MOVE.w D0,D1      
  BSR.w searchinstr    ; input: d1=token, return: a2.l=lib, a3.l=sub (code for token)
  ; new >
  TST.b newmode
  BNE compile_term
  ; < new
  BTST #$2,$1(A3)                                          ;a3 = pointer to instr ;toke stuff in a3
  BNE.w stamigalib

  BTST #$0,$1(A3)
  BEQ.w needreturn_                                       ;syntax err need return   ;check it's a statement
  ;
  BSR.w sizespec                                         ;does it need a size specifier?
  BSR.w countpees

.dolibtoke:
  ; number of parameters in d1....
  ; a2=lib base, a3=sub for this toke
  ;
  MOVE.w numreps,-(A7)
  MOVE.w userp,-(A7)
  MOVE.w a2offset,-(A7)
  MOVE.l A2,-(A7)                                          ;recurs.
  MOVE.w convsize,userp
  LEA $6(A3),A1                                           ; jump to the calling definitions of the token, e.g. one, two or three parameters ("overload")
  ;
  ;now to find a form with d1 parameters in it..... D1 is the number of used parameters in source

 'loop
    MOVE.w (A1),D2
    BMI.w 'SERR                                              ;statement syntax error
    ANDI.w #$FF,D2
    CMP.w D2,D1
    BEQ.w 'found
      BCS.w 'next
        MOVE.b (A1),D3
        ANDI.w #$7,D3
        BEQ.w 'next
          MOVE.w D2,D4
          SUB.w D3,D4
          MOVEQ.l #$00,D5
          MOVE.w D1,D5
          SUB.w D4,D5
          DIVU D3,D5
          SWAP D5
          TST.w D5
          BEQ.w 'found
       'next
        ADDQ.w #2,A1
        ADDA.w D2,A1
        BSR.w aligna1
        BSR.w skiplibreg
 LEA $C(A1),A1
 BRA.w 'loop

 ; new <
 'SERR
  MOVE.w (a3),d2
  BTST #1,d2
  BEQ statement_
  CMP.w #1,d1
  BEQ statement_

 'l2                        ; skip spaces
    CMP.b #$20,(a5)+
  BEQ 'l2
  CMP.b #"(",-2(a5)         ; check for opening brackets, for parameters
  BNE 'l1
    BRA parameter_
 'l1
  BRA inbrackets_
 ; < new

 'found                     ;Got it!                                 ;Got it!
  MOVE.b (A1),D2
  LSL.w #8,D2
  OR.w D2,D1
  MOVE.l A1,-(A7)
  CLR.w a2offset
  TST.w D1
   BEQ.w 'nopees
  LEA $2(A1),A2             ; datatype of parameter
  ; new >
  MOVE.l lasttoken,-(a7)
  CLR.l lasttoken
  ; < new
  BSR.w fetchlibps
  ; new >
  MOVE.l (a7)+,lasttoken
  ; < new
  BRA.w 'skip

 'nopees
  BSR.w get1bytemain

 'skip
  MOVEA.l (A7)+,A1
  MOVEA.l (A7)+,A2
  MOVE.w a2offset,D1
  BEQ.w 'skip2
    MOVE.w D1,preplibst+2
    MOVE.l preplibst,D1
    JSR writelong                                           ;write array offset stack correct
    MOVE.w numreps,movenumrep+2
    BEQ.w 'skip2
      MOVE.l movenumrep,D1
      JSR writelong;??looks like double label??
     'l10
 'skip2                ;make the JSR 
  JSR userjsr

  ; new >
 'l20
  ; < new
  MOVE.w a2offset,D1
  BEQ.w 'skip3
    CMP.w #$8,D1
    BHI.w 'skip4
      ANDI.w #$7,D1
      LSL.w #8,D1
      LSL.w #1,D1
      ORI.w #$504F,D1       ;addq #x,a7
      JSR writeword
      BRA.w 'skip3
   'skip4
    MOVE.w D1,fixlibst+2
    MOVE.l fixlibst,D1
    JSR writelong
 'skip3
  MOVE.w (A7)+,a2offset
  MOVE.w (A7)+,userp
  MOVE.w (A7)+,numreps
BRA.w reget 


sizespec2:
  MOVEM.l A2-A3,-(A7)
  ; new >
  CLR.b doublepeek
  ; < new
  MOVE.l A5,lastsourcepos
  BSR.w getchar
  CMP.w #$2E,D0             ;','
  BEQ.w 'ok1
    MOVEA.l defaulttype,A2
    CMP.w #$24,D0           ;'$'
    BNE.w 'none
      MOVEQ.l #$07,D1
      BRA.w 'skip
 'ok1
  JSR getparameter2               ;bsr.w
  BEQ.w syntaxerr
  LEA newtypebase,A2
  JSR findtype            ; BSR.w
  BNE.w notypeerr

 'none
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
CNIF #function_support_returntype=0
  ; < new
  CMPI.l #$100,$4(A2)
  BCC.w illtypeerr
  ; new >
CEND
  ; < new
  MOVE.w $6(A2),D1
  ; new >
  CMP.w #8,8(a2)
  BNE 'l1
    MOVE.b #1,doublepeek
 'l1
  ; < new                                                       ;??looks like double label??
 'skip
  MOVE.w D1,convsize
  MOVEM.l (A7)+,A2-A3
RTS



sizespec
  BTST #$3,$1(A3)
  BEQ.w 'skip
  BSR.w sizespec2                                         ;read peek/poke size

  ORI.w #$7000,D1
  JSR writeword
  ADDQ.w #1,regnum

 'skip
RTS

;-----------subs-------------------------------;


;------                                                  ;disassembled code begin
swapb:
            Dc.b $10,$12                                   ;MOVE.B  (A2),D0
            Dc.b $14,$91                                   ;MOVE.B  (A1),(A2)
            Dc.b $12,$80                                   ;MOVE.B  D0,(A1)
swapbf:


swapw:      Dc.b $30,$12                                   ;MOVE.W  (A2),D0
            Dc.b $34,$91                                   ;MOVE.W  (A1),(A2)
            Dc.b $32,$80                                   ;MOVE.W  D0,(A1)
swapwf:


swapl:      Dc.b $20,$12                                   ;MOVE.L  (A2),D0
            Dc.b $24,$91                                   ;MOVE.L  (A1),(A2)
            Dc.b $22,$80                                   ;MOVE.L  D0,(A1)
swaplf:


pulla1:     Dc.b $22,$5F                                   ;MOVEA.L (A7)+,A1
;------                                                  ;disassembled code end

srctype:    Ds.w 1


Even
.do_Exchange:                                              ;'swap' 2 variables.
  BSR.w excget
  CMP.w #$2C,D0     ;','
   BNE.w syntaxerr
  MOVE.b D2,srctype
  MOVE.w pusha2,D1
  JSR writeword
  BSR.w get1bytemain
  BSR.w excget
  CMP.b srctype,D2
   BNE.w excerr2
  MOVE.w pulla1,D1
   JSR writeword
  ;
  CMP.b #$2,D2
   BCS.w 'byte
   BEQ.w 'word
  LEA swapl(PC),A0
  LEA swaplf(PC),A1
 JMP pokecode

 'word
  LEA swapw(PC),A0
  LEA swapwf(PC),A1
 JMP pokecode

 'byte
  LEA swapb(PC),A0
  LEA swapbf(PC),A1
JMP pokecode


excget:
  JSR getparameter
  JSR fetchvars
  JSR calcvar
  BTST #$E,D2
   BEQ.w 'skip
  MOVE.b #$4,D2

 'skip
  TST.b D2
   BEQ.w excerr
  BTST #$F,D2
   BNE.w 'done
  MOVE.w leaamp,D1
   JSR pokewda5s
  MOVE.w D3,D1
 JMP writeword

 'done
RTS


do_AllocMem:              ; not used anymore
  MOVE.l mempool,a0
  MOVEA.l _execbase,A6
JMP _AllocPooled(a6)


.do_WBStartup:
  MOVE.w #$BF00,D1       ; was #wbstart
JMP Atokejsr

.do_Pop:
  CMP.w ##TokenID_Gosub,D0       ; was  #$8006
   BEQ.w popreturn
  CMP.w ##TokenID_For,D0         ; was  #$8000+22,
   BEQ.w popnext2
  CMP.w ##TokenID_Select,D0       ; was  #$8000+14,
   BEQ.w popselect2

  CMP.w ##TokenID_If,D0       ; was  #$8000+11
   BEQ.w get1bytemain
  CMP.w ##TokenID_While,D0       ; was  #$8000+12
   BEQ.w get1bytemain

  CMP.w ##TokenID_SYNTAX,D0            ; was  #$8000+20
   BEQ.w get1bytemain
  CMP.w ##TokenID_Repeat,D0            ; was  #$8000+tnum+8
   BEQ.w get1bytemain
BRA.w syntaxerr


popreturn:
  TST.b debugmode
   BEQ.w 'norerr
  LEA 'rfix(PC),A0
  LEA 'rfixf(PC),A1
   JSR pokecode
  MOVE.w #$C305,D1
   JSR Atokejsr
  MOVE.w 'rfix2(PC),D1
   ;BSR.w writeword
   JSR writeword
 BRA.w get1bytemain

 'rfix
  CMPI.w #$6753,$4(A7)                                     ;#"gS",4(A7)
  BEQ.w 'rfix2

 'rfixf
  JSR $20000                                               ;reass
                                                           ;jsr 0 org source
 'rfix2
  ADDQ.w #6,A7

 'norerr
  MOVE.w 'sfix(PC),D1
  JSR writeword
BRA.w get1bytemain


;------                                                  ;disassembled code begin
'sfix
  Dc.b $58,$4F                                             ;ADDQ.W  #4,A7
;------                                                  ;disassembled code end

Even
popnext2:
  MOVE.l firstfor,D0
   BEQ.w noforerr
  MOVEA.l D0,A2
   BSR.w get1bytemain
  BSR.w popnext

 popnext3:
  TST.b debugmode
   BEQ.w 'ner
  MOVE.l nextfixw2,D1
  CMPI.w #$3,$C(A2)
   BCS.w 'writelong2
  MOVE.l nextfixl2,D1

 'writelong2
  JMP  writelong

 'ner
  CMPI.w #$3,$C(A2)
   BCS.w 'skip2
  MOVE.l nextfixl,D1
  JMP writelong

 'skip2
  MOVE.w nextfixw,D1
JMP writeword



popnext:
  MOVE.w $C(A2),D0
  TST.b debugmode
   BEQ.w 'norunerr
  MOVE.w #$C306,D1
  CMP.w #$3,D0
   BCS.w 'oktc
  ADDQ.w #1,D1

 'oktc
  MOVE.l A2,-(A7)
  JSR Atokejsr
  MOVEA.l (A7)+,A2

 'norunerr
RTS


popselect2:
  MOVE.l firstsel,D0
   BEQ.w eselerr
  MOVEA.l D0,A2
   BSR.w get1bytemain

 popselect:
  MOVE.w $C(A2),D2
  TST.b debugmode
   BEQ.w 'norerr
  MOVE.w #$C313,D1
  CMP.w #$3,D2
   BCS.w 'chkit
  ADDQ.w #1,D1

 'chkit
  JSR Atokejsr                                             ;make sure next thing on stack
            ;is a select

 'norerr
  MOVEQ.l #$02,D1
  CMP.w #$3,D2
   BCS.w 'doit
  MOVEQ.l #$04,D1
  CMP.w #$7,D2
   BCS.w 'doit
  LEA endselstr,A0
  LEA endselstrf,A1
  TST.b debugmode
   BEQ.w 'norerr3
  LEA endselstrf2,A1

 'norerr3
  JSR pokecode
  MOVE.w #$C003,D1                                         ;global freemem
 JMP Atokejsr

 'doit
  TST.b debugmode
   BEQ.w 'norerr2
  ADDQ.w #2,D1                                             ;for the "sE"

 'norerr2
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w endsel,D1
JMP writeword


firstrep:    Ds.l 1
replineat:   Ds.l 1


.do_Repeat:
    ;Repeat...
    ;.
    ;.
    ;.
    ;Until a=10
  CLR.l fp0addr
  MOVE.l linenumat,replineat
  MOVEQ.l #$08,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
   ;jsr do_AllocMem                                           ;allocmem8
  MOVEA.l D0,A0
  MOVE.l firstrep(PC),(A0)
  MOVE.l A0,firstrep
  MOVE.l destpointer,$4(A0)
RTS


str_temp:  Ds.w 3                                            ;infochk  ds.b 6 org source
   ;
check_for_infoextention:                                     ;does a0 end in .info?
  LEA str_temp(PC),A1
  CLR.w (A1)
  CLR.l $2(A1)

 'loop2
  MOVEQ.l #$04,D0

 'loop
    MOVE.b $1(A1),(A1)+
  DBF D0,'loop

;  !basic
;   logging{Peek$(?str_temp)+" "}
;  !asm
  LEA str_temp(PC),A1
  MOVE.b (A0),D0
  ORI.b #$20,D0
  MOVE.b D0,$5(A1)
  TST.b (A0)+
   BNE.w 'loop2
  CMPI.w #$2E69,(A1)+                                      ;".i"
   BNE.w 'no
  CMPI.l #$6E666F20,(A1)                                   ;"nfo "

 'no
RTS


gettokeps:                                                 ;toke jsr
  BPL.w 'evaltoke
  MOVE.w D0,D1
  ANDI.w #$7F80,D1
   BEQ.w tokeerr
  BCLR #$F,D0
  MOVE.w D0,D4                                             ;got toke number
  BSR.w get1bytemain
 BRA.w 'gotnum

 'evaltoke
  JSR evalconst
  CMP.l #MaxWord,D3
   BHI.w tokeerr
  TST.w D6
   BNE.w tokeerr
  MOVE.w D3,D4

 'gotnum
  MOVEQ.l #$00,D5
  CMP.w #$2C,D0
   BNE.w 'gotfrom
  MOVE.w D4,-(A7)
   JSR evalconst2
  CMP.l #MaxWord,D3
   BHI.w tokeerr
  TST.w D6
   BNE.w tokeerr
  MOVE.w D3,D5
  MOVE.w (A7)+,D4

 'gotfrom
RTS                                                        ;d4=toke, d5=form


.do_LibJsr:
  TST.w D0
   BSR.w gettokeps
  MOVE.w #$4EB9,D1
  JSR writeword
  BSR.w addoff
  MOVE.w D5,D1
  ORI.w #$8000,D1                                          ;Toke of Amiga type.
  SWAP D1
  MOVE.w D4,D1
JMP writelong


.do_BLibJsr:
  TST.w D0
   BSR.w gettokeps
  MOVE.w #$4EB9,D1
  JSR writeword
  BSR.w addoff
  MOVE.w D5,D1
  ORI.w #$C000,D1                                          ;Toke of Blitz type.
  SWAP D1
  MOVE.w D4,D1
  JMP writelong


.do_SysJsr:
  JSR evalconst
  CMP.l #$10000,D3
   BCC.w tokeerr
  MOVE.w D3,D1
JMP Atokejsr


.do_TokeJsr:
  BSR.w gettokeps
  MOVE.w #$4EB9,D1
  JSR writeword
  MOVE.l destpointer,D3
  BTST #$7,blitzmode
   BEQ.w 'inamiga
  BSET #$E,D5

 'inamiga
  BSR.w maketjsr
  BSR.w addoff
JMP writelong


.do_VWait:
  BEQ.w 'zero
  MOVEQ.l #$02,D2                                          ;get a word
  ;BSR.w bakeval
  JSR bakeval
  MOVE.w fvwait(PC),D1
 BRA.w 'vcont

 'zero
  MOVE.w #$7000,D1                                         ;moveq #0,d0

 'vcont
  JSR writeword
  MOVE.w #$C104,D1
JMP Atokejsr


fvwait:
  SUBQ.w #1,D0

cgoblitz:
  Dc.w $3b7c,$ffff,0                                       ;move.w #$FFFF,$0(A5) ;noopt

cgoamiga:
  Dc.l $426d0001                                           ;clr.w $0(A5)


debugmode_codelabel:                                       ;debugmode org source
  MOVE.b debugmode(PC),D1
  BEQ.b 'skip
    MOVE.w #$D500,D1
    JMP Atokejsr
 'skip
RTS


.do_BLITZ:                                                 ;go into Blitz mode!
  BSET #$0,blitzmode
  BSET #$7,blitzmode
  MOVE.w #$C200,D1
  JSR Atokejsr
  TST.b debugmode
  BEQ.w 'done
    MOVE.w cgoblitz(PC),D1
    JSR writeword
    MOVEQ.l #-$01,D1
    JSR writeword
    JSR getbbase
    JSR writeword
 'done
BRA.w debugmode_codelabel


.do_AMIGA:                                                 ;go into Amiga mode
  MOVE.w #$C201,D1
BRA.w do_AMIGA_toamode

.do_QAMIGA:                                                ;go into quick amiga mode
  MOVE.W  #$C202,D1

do_AMIGA_toamode:
  BSET #$0,blitzmode
  BCLR #$7,blitzmode
  JSR Atokejsr
  TST.b debugmode
  BEQ.w 'done
    MOVE.w cgoamiga(PC),D1
    JSR writeword
    JSR getbbase
    JSR writeword
 'done
BRA.w debugmode_codelabel


intstart0:
  MOVEM.l D2-D7/A2-A4,-(A7)

intfin:
  MOVEM.l (A7)+,D2-D7/A2-A4


.do_ClrInt:
  JSR evalconst

  CMP.l #$E,D3
  BCC.w interr4

  MOVE.w #$7000,D1
  OR.w D3,D1
  JSR writeword
  MOVE.w #$C101,D1
JMP Atokejsr                                               ;clear the interupt


inerr:       Ds.w 1                                        ;flag - in error trap mode
errjmp:      Ds.l 1                                        ;where err jump is
errcode:     Ds.l 1


.do_ClrErr:
  MOVE.W  #$D202,D1
JMP Atokejsr                                               ;BRA.W Atokejsr


doendseterr:
  MOVE.w inerr(PC),D1
   BEQ.w errerr3
  CLR.w inerr
  MOVE.w dontwrite_nomemleft,D1
   BNE.w 'skip
  MOVEA.l errjmp(PC),A0
  MOVE.l destpointer,(A0)

 'skip
BRA.w get1bytemain


.do_ErrFail:
  MOVE.w #$D205,D1
JMP Atokejsr


.do_SetErr:
  MOVE.w proceduremode,D1
   BNE.w errerr1
  MOVE.w inerr(PC),D1
   BNE.w errerr2
  LEA inerr,a0
  NOT.w (a0)                                               ;reass
  MOVE.w #$203C,D1                                         ;move.l #x,d0
  JSR writeword
  MOVE.l destpointer,errcode
  BSR.w addoff
  JSR writelong
  MOVE.w #$D201,D1
  JSR Atokejsr
  MOVE.w #$4EF9,D1                                         ;JMP
  JSR writeword
  MOVE.l destpointer,errjmp
  BSR.w addoff
  JSR writelong
  MOVE.w dontwrite_nomemleft,D1
  BNE.w 'skip
    MOVEA.l errcode(PC),A0
    MOVE.l destpointer,(A0)
 'skip
RTS


intlineat:  Ds.l 1


.do_SetInt:
  MOVEQ.l #-$01,D1                                        ;type - need new string space
  BSR.w errchx
  MOVE.w D1,intstring
  MOVE.l linenumat,intlineat
  JSR evalconst                                           ;get constant - int level
  CMP.l #$E,D3
  BCC.w interr4
  ST intsused
  MOVE.w D3,intlevel
  MOVE.w #$7000,D1
  OR.w D3,D1                                              
  JSR writeword                                         ;moveq #x,d0
  MOVE.w #$223C,D1                                        ;move.l #x,d1
  JSR writeword
  BSR.w addoff
  MOVE.l destpointer,-(A7)
  JSR writelong
  MOVE.w #$C100,D1                                      ;intlib: addAnInt
  JSR Atokejsr
  MOVE.w #$4EF9,D1                                        ;jmp
  JSR writeword
  BSR.w addoff
  MOVE.l destpointer,intjmpat
  JSR writelong
  MOVEA.l (A7)+,A0

  MOVE.w dontwrite_nomemleft,D1
  BNE.w 'dontpoke
    MOVE.l destpointer,(A0)
 'dontpoke

  MOVE.l intstart0(PC),D1
  JSR writelong

  TST.b debugmode
  BEQ.w 'norerr
    ;
    ;debugga stuff..
    ;
    MOVEQ.l #$02,D1
    BSR.w writetrap
    BSR.w addoff
    MOVE.l destpointer,intcleanat
    JSR writelong
    MOVE.w intlevel,D1
    JSR writeword
    MOVE.w #$C30B,D1                                         ;disable stack checks
    JSR Atokejsr
 'norerr
  MOVE.w #$FED3,D1
  BSR.w uselib            ; 65235, strings1lib
  MOVE.w #$C102,D1
  JSR Atokejsr
  MOVE.w #-1,lasta6
  MOVE.l linenumat,intline
RTS


;intallox:                                                 ;mask for allocates for interrupts
            Ds.w 1                                         ;??looks like obsolved data??

intdata1:   Ds.l 1                                         ;where in data1 a5 is being kept

intjmpat:   Ds.l 1
intline:    Ds.l 1
intstring:  Ds.w 1                                         ;flag 0 = no setint
                                                           ;>0=setint, no st space
                                                           ;<0=set, st space
intlevel:   Ds.w 1
intcleanat: Ds.l 1
ret15add:   Ds.l 1
ret15cc:    Ds.w 1


directTrap15:                                              ;directrap trap #15
  ADDI.l #$12,$2(A7)
  MOVE.l $2(A7),ret15add
  MOVE.w (A7),ret15cc
  MOVE.l #directdo,$2(A7)
RTE
  ;.l : input - code to compile
  ;.l : firstlocal
  ;.l : firstglobal
  ;.l : returned - 0 if no compile error, else pointer to err text
  ;.w : blitz mode status

.trap15                                                    ;??looks like double label??
directdo:                                                
  MOVE.l ret15add(PC),-(A7)
  MOVE.w ret15cc(PC),-(A7)                                 ;15*4
  MOVEM.l D0-D7/A0-A6,-(A7)
  MOVE.l destbufferend,trap15temp                          ;store high buff addr
  MOVE.l destbufferstart,trap15temp2
  MOVE.l libend,templibend
  MOVE.l data1start,tempdata1start
  CLR.l hunkoffsetcounter

  MOVE.l directbuffer,a0
  CNIF #debugtrap
    MOVE.l #$40000,a0
  CEND
  MOVE.l a0,destbufferstart
  ADD.l #3900,a0
  MOVE.l a0,destbufferend
  TST.b exdebug
  BEQ 'l1
  MOVE.l a0,libend
  ADD.l #4000,a0
  MOVE.l a0,data1start

 'l1
  MOVE.l #'dircont,errcont
  MOVE.l a7,stackaddr                                      ; added to prevent a possible crash in CLIMode if #continue_on_error is set  tomsmart1
  MOVE.l A7,errstack
  MOVE.w #$FFFF,direct_mode
  CNIF #debugtrap=0
    MOVEA.l ret15add(PC),A1
    MOVE.w -(A1),blitzmode
    CLR.l -(A1)
    MOVE.l -(A1),firstglob
    MOVE.l -(A1),firstlocal
  CEND
  CLR.w proceduremode
  MOVE.l firstglob,D0
  OR.l firstlocal,D0
  BEQ.b 'skip
  NOT.w proceduremode

 'skip
  MOVEA.l -(A1),A0                                         ;address of string
  CNIF #debugtrap
    LEA testcode,a0
  CEND
  MOVE.l A0,-(A7)
;  MOVEA.l comdata,A1
;  MOVEA.l $38(A1),A1
  !ComData_GetL{comFunc_DebugTrap,A1}
  JSR (A1)                                                 ;tokenise line.....

  MOVEA.l (A7)+,A5
  MOVE.l directbuffer,destpointer
  TST.b exdebug
  BEQ 'noexdebug
  MOVE.l a5,a0
  MOVE.l #200,d0

 'l2
    MOVE.b 0(a0,d0.l),8(a0,d0.l)
  DBF d0,'l2

  CNIF #debugtrap
    MOVE.l destbufferstart,destpointer
  CEND
  MOVE.l destpointer,a0
  MOVE.w #$207c,(a0)+
  MOVE.l a5,d0
  ADD.l #$206,d0                                           ;constant from debuglib
  MOVE.l d0,(a0)+
  MOVE.l a0,destpointer
  MOVE.l a5,a0
  MOVE.w #$8039,(a0)+                                      ;TokeJsr 164 (inputoutputlib) LSL 7+4
  MOVE.l #"$520",(a0)+
  MOVE.w #"4:",(a0)+

 'noexdebug
  CLR.w dontwrite_nomemleft
  MOVE.w #$FFFF,lasta6
  BSR.w compile_line                                        ;.....compile it
  TST.b exdebug
  BEQ 'noexdebug2
  JSR fixjsrs

 'noexdebug2
  CLR.w proceduremode
  BSR.w errchx
  MOVE.w #$4EF9,D1
  JSR writeword                                          ;JMP
  MOVE.l ret15add(PC),D1
  JSR writelong                                          ;jmp to done
  MOVE.w dontwrite_nomemleft,D0
   BNE.w nodirmem
  MOVE.l directbuffer,$3E(A7)                              ;install code address

 'direxit
  CLR.w direct_mode
  MOVE.w ret15cc(PC),$3C(A7)
  MOVE.l trap15temp,destbufferend
  MOVE.l trap15temp2,destbufferstart
  MOVE.l tempdata1start,data1start
  MOVE.l templibend,libend
  MOVEM.l (A7)+,D0-D7/A0-A6
  BSR.w clear_Cache                                        ;selden used
RTR

 'dircont                                                  ;direct mode error! - d0=error text
  MOVEA.l ret15add(PC),A0
  SUBQ.w #2,A0
  MOVE.l D0,-(A0)
BRA.w 'direxit


stamigalib:                                                ;an amigalib called through a statement!
  MOVE.w $6(A3),D1
  BSR.w uselib                                             ;get lib for base address
  MOVE.w $A(A1),-(A7)                                      ;libbase reg
  ADDQ.w #8,A3
  MOVE.w (A3)+,-(A7)                                       ;get offset for lib
  MOVE.l A3,-(A7)
  ;
  ;collect longs for lib
  ;
  MOVEQ.l #$00,D3
  ; new >
  JSR checka4a5
  ; < new

 'loop                                                   ;no return value amigalib call parameter compile (can use recursive)
  MOVE.b (A3)+,D1
   BMI.w 'done
  MOVEQ.l #$03,D2
  ADDQ.w #1,D3
  MOVEM.l D3/A3,-(A7)
  ; new >
  MOVE.b funcparloop,-(a7)
  MOVE.b #0,funcparloop
  MOVE.l leftsidetype,-(a7)
  MOVE.l rightsidetype,-(a7)
  MOVE.w leftsideflagmask,-(a7)
  MOVE.w rightsideflagmask,-(a7)
  CLR.l leftsidetype
  CLR.l rightsidetype
  CLR.w leftsideflagmask
  CLR.w rightsideflagmask
  MOVE.b blitzparloop,-(a7)
  MOVE.b #1,blitzparloop                                 ;write the parameter to stack
  ; < new
  JSR peval
  ; new >
  MOVE.b (a7)+,blitzparloop
  MOVE.w (a7)+,rightsideflagmask
  MOVE.w (a7)+,leftsideflagmask
  MOVE.l (a7)+,rightsidetype
  MOVE.l (a7)+,leftsidetype
  MOVE.b (a7)+,funcparloop
  MOVEM.l (A7)+,D3/A3
  ; < new
  CMP.w #$2C,D0     ; ','
   BEQ.w 'loop
  TST.b (A3)
   BPL.w syntaxerr

 'done
  MOVEA.l (A7)+,A3
  SUBQ.w #1,D3
   BPL.w 'toend
   BSR.w get1bytemain                                      ;no pars - get :
 BRA.w 'nopars

 'toend
  TST.b (A3)+                                              ;go to end of params
   BPL.w 'toend
  SUBQ.w #1,A3

 'loop2                                                    ;fetch the parameter from stack and put to correct register
   MOVEQ.l #$00,D1
   MOVE.b -(A3),D1
   BTST #$4,D1
    BNE.w 'addreg
   LSL.w #8,D1
   LSL.w #1,D1
   ORI.w #$201F,D1
 BRA.w 'gotit

  'addreg
   ANDI.w #$7,D1
   LSL.w #8,D1
   LSL.w #1,D1
   ORI.w #$205F,D1

  'gotit
    JSR writeword
  DBF D3,'loop2

 'nopars
  MOVE.w (A7)+,libjsr+2
  MOVE.w (A7)+,libbase+2
  MOVE.l libbase,D1
  JSR writelong
  MOVE.l libjsr,D1
  JSR writelong
  ; new >
  JSR restorea4a5
  ; < new
RTS


alloxinc:                                                  
  ;increment allocs by 150%
  ;
  ; new >
  MOVE.l data1,D4
  SUB.l data1start,D4
  ADD.l #10000,d4
  MOVE.l libend,D3
  SUB.l destbufferend,D3
  ADD.l #40000,d3
  MOVE.l bigpc,D2
  SUB.l destbufferstart,D2
  ADD.l #20000,d2
  MOVE.l databuffer,D5
  ADD.l #10000,D5
 BRA newallox
  ; < new                                                        

  MOVE.l objectbuffer,D2       ;??Looks like unused code??
  LSR.l #1,D2
  ADD.l objectbuffer,D2
  ;
  MOVE.l libsbuffer,D3
  LSR.l #1,D3
  ADD.l libsbuffer,D3
  ;
  MOVE.l systembuffer,D4
  LSR.l #1,D4
  ADD.l systembuffer,D4
  ;
  MOVE.l databuffer,D5
  LSR.l #1,D5
  ADD.l databuffer,D5
  ;
BRA.w newallox


alloxadj:                                                     ;ne if enough mem for allox
  MOVE.l bigpc,D2
  SUB.l destbufferstart,D2                                     ;size of object buffer
  SUB.l savefuncspace,d2
  ;ADD.l morememadd,d2
  TST.w debugversion
   BNE.b 'skip
  ADDI.l #$800,D2

 'skip
  MOVE.l libend,D3
  SUB.l destbufferend,D3
  ; new >
  ;ADD.l morememadd,d3
  ; < new
  MOVE.l data1,D4
  SUB.l data1start,D4
  ; new >
  ;ADD.l morememadd,d4
  ; < new
  MOVE.l data2,D5
  SUB.l data2at,D5
  ; new >
  ;ADD.l morememadd,d5
  CLR.l morememadd
  ; < new

newallox:
  BSR.w makeallox
  BNE.w 'done
 BRA.w init_buffers

 'done
RTS


freeallox:
  MOVEA.l _execbase,A6
  MOVE.l objlen,D0
  BEQ.w 'skip
    CLR.l objlen
    MOVEA.l destbufferstart,A1
    ; new >
    MOVE.l mempool,a0
    JMP _FreeVec(A6)
    ; < new
    ;jmp freemem(a6)
 'skip
RTS


.init_buffers:                                             ;makeiallox org source ;initial allox
  MOVE.l objectbuffer,D2
  MOVE.l libsbuffer,D3
  MOVE.l systembuffer,D4
  MOVE.l databuffer,D5

makeallox:
  ;d2=pc size,d3=lib size,d4=data1,d5=data2
  ;
  MOVE.w #$FFFF,anyerrs      ; was -1
  BSR.w freeallox
  ;
  ;word align blocks
  ;
  ADDQ.l #1,D2
  BCLR #$0,D2
  ADDQ.l #1,D3
  BCLR #$0,D3
  ADDQ.l #1,D4
  BCLR #$0,D4
  ; new >
  TST.l d5        ; ??? make no sence ??
  BNE 'l1

 'l1
  ; < new
  ADDQ.l #1,D5
  BCLR #$0,D5
  ;
  MOVE.l D2,D0
  ADD.l D3,D0
  ADD.l D4,D0
  ADD.l D5,D0
  ; new >
  ADD.l #moremem,d0
  ; < new
  MOVE.l D0,D6
  MOVE.l #MemfPublic_MemfClear,D1
  ; new >
  MOVE.l mempool,a0
  MOVEA.l _execbase,A6
  JSR _AllocVec(a6)                                        ;alloc mem for objectbuffer
  ; < new
  ;jsr do_AllocMem
  TST.l D0
  BEQ.w 'done
  MOVE.l D6,objlen
  MOVE.l D2,objectbuffer
  MOVE.l D3,libsbuffer
  MOVE.l D4,systembuffer
  MOVE.l D5,databuffer
  MOVE.l D0,destbufferstart
  ; new >
;  MOVE.l comdata,a0
;  MOVE.l d0,$1f0(a0)
  !ComData_SetL{comPtr_DestBufferStart,D0}
  !ComData_SetL{comLong_DestBufferSize,D6} ; add that the Debugger have the right size of the buffer  tomsmart1 2016 02 06
  ; < new
  ADD.l D2,D0
  MOVE.l D0,destbufferend
  ADD.l D3,D0
  MOVE.l D0,data1start
  ADD.l D4,D0
  MOVE.l D0,data2at
  ADD.l D5,D0
  MOVE.l D0,allat

 'done
RTS


divisors:
  Dc.b $00,$00,$00,$01                                     ;         1
  Dc.b $00,$00,$00,$0A                                     ;        10
  Dc.b $00,$00,$00,$64                                     ;       100
  Dc.b $00,$00,$03,$E8                                     ;      1000
  Dc.b $00,$00,$27,$10                                     ;     10000
  Dc.b $00,$01,$86,$A0                                     ;    100000
  Dc.b $00,$0F,$42,$40                                     ;   1000000
  Dc.b $00,$98,$96,$80                                     ;  10000000
  Dc.b $05,$F5,$E1,$00                                     ; 100000000
  Dc.b $3B,$9A,$CA,$00                                     ;1000000000

Even
makelong:                                                  ;put long in d2 into (a0)+
  MOVEQ.l #$00,D1                                          ;no zero printed
  MOVEQ.l #$24,D3                                          ; "$"

 'loop
  MOVEQ.l #$30,D4                                          ; "0"

 'loop2
    CMP.l divisors(PC,D3.W),D2
    BCS.w 'skip
    SUB.l divisors(PC,D3.W),D2
    ADDQ.w #1,D4
 BRA.w 'loop2

 'skip
  CMP.b #"0",D4
  BNE.w 'doit
  TST.w D1
  BEQ.w 'skip2

 'doit
  MOVE.b D4,(A0)+
  MOVEQ.l #$01,D1

 'skip2
  SUBQ.w #4,D3
  BPL.w 'loop
  TST.w D1
  BNE.w 'skip3
  MOVE.b #"0",(A0)+

 'skip3
  CLR.b (A0)
RTS


;str_residentrequester:  Dc.b "Name of Resident File to Create",0 : Even        ;restext org source
;str_residentpath:       Ds.l 48                                                ;respath org source
;str_residentname:       Ds.l 48                                                ;resname org source


.menu_createresidentfile:      ; was menu5
  ;make resident!
  ;
  MOVE.l macrobase,D0
  BNE.w 'skip
  MOVE.l newtype_string,D0
  BNE.w 'skip
  MOVEA.l labelbase,A2

 'loop
    CMPA.w #$0,A2
     BEQ.w 'err
    CMPI.l #$1,$4(A2)
     BEQ.w 'skip
    MOVEA.l (A2),A2
  BRA.w 'loop

 'err
  !basic
  error{!TRANS{"There is no data to be stored in a resident file.\\nTry again to create the resident after one compile pass."}}
  !asm
  RTS

 'err_cancel
  RTS

 'skip    ; was 'create_residentfile                                     ;.skip orgk source
  !basic
  !ComData_GetL{comPtr_pedScreen,D0} : *pedScreen.Screen = PutRegD0
  aslfr_SetRequesterTitle{2,"Name of Resident File to Create","Create","Cancel"}
  aslfr_SetPath {2,config\path_residents,".res","#?.res"}
  If NOT aslfr_Request{2,False,True,False,*pedScreen}
    Pop If
    !asm
    RTS
  EndIf
  GetRegD0 aslfr_GetNextFile{}
  !asm

; -- start of rewrite in basic
;  !basic
;  putreg d0,tempd0.l
;  residentfile.s = Peek.s(tempd0)
;  fh.l = Open_(residentfile,#HUNK_RELOC_8__MODE_NEWFILE)
;  If fh
;    !asm
;    ;MOVEM.l d2-d7/a0-a6,-(a7)
;    LEA devo,a0
;    LEA ptr_parameterstore,a1
;
;   'l1
;      MOVE.b (a0)+,(a1)+
;    BNE 'l1
;    MOVEQ #13,d2
;    JSR findlabel2
;    MOVE.l 8(a2),-(a7)
;    MOVE.l d0,-(a7)
;    !basic
;    MOVE (a7)+,d0 : putreg d0, tempd0.l
;    MOVE (a7)+,d0 : putreg d0, tempd1.l
;    If tempd0 <> 0 AND tempd1 = 0
;      !asm
;      BSR.w killoffs
;      !basic
;      Write_ fh,?tsthead,$20          ; write header
;
;      ; ...
;    Else
;      error{!TRANS{"Cannot create Resident with develope debug 1"}}
;    EndIf
;    Close_ fh
;
;
;  Else
;    error{"Could not open file " + residentfile}
;  EndIf
;  !asm
;RTS

  ;O.K.... Now to create it
  MOVE.l D0,D1
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVEA.l _dosbase(PC),A6
  JSR _Open(A6)
  MOVE.l D0,D7               ;handle                                ;handle
  BEQ.w 'err
  ; new >
  MOVEM.l d2-d7/a0-a6,-(a7)
  LEA devo,a0
  LEA ptr_parameterstore,a1

 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1
  MOVEQ #13,d2
  JSR findlabel2
  BNE 'd
  TST.l 8(a2)
  BEQ 'd2
    !basic
    error{!TRANS{"Cannot create Resident with develope debug 1"}}
    !asm
    MOVEM.l (a7)+,d2-d7/a0-a6
    MOVEA.l _dosbase(PC),A6
    MOVE.l d7,d1
    JSR _Close(a6)
    BRA 'err
 'd2
 'd
  MOVEM.l (a7)+,d2-d7/a0-a6
  ; < new
  ;
  BSR.w killoffs
  ;
  MOVE.l D7,D1
  MOVE.l #tsthead,D2        ;header                               ;header
  MOVEQ.l #$20,D3
  MOVEA.l _dosbase(PC),A6
  JSR _Write(A6)
  ;
  MOVEQ.l #$00,D6           ;offset from start of file!                               ;offset from start of file!
  BSR.w resident_Types
  BSR.w resident_Macros
  BSR.w resident_Constants
  ;
  MOVE.l D6,D3
  ADDQ.l #3,D3
  ANDI.l #$FFFFFFFC,D3      ;long word align                               ;long word align
  MOVE.l D3,-(A7)
  SUB.l D6,D3
  BEQ.w 'noalign
    MOVE.l #writelist,D2      ; was #hello,
    MOVE.l D7,D1
    MOVEA.l _dosbase,A6
    JSR _Write(A6)
 'noalign

  MOVE.l hunkoffsetcounter,tstsize3
  BEQ.w 'skip2a
  MOVE.l D7,D1
  MOVE.l #tstend,D2
  MOVEQ.l #$0C,D3
  MOVEA.l _dosbase,A6
  JSR _Write(A6)
  ;
  ;and offsets.....
  ;
  MOVEA.l hunkoffsetbase,A2

 'oloop
    CMPA.w #$0,A2
    BEQ.w 'skip2
      LEA $4(A2),A1
      MOVE.l D7,D1
      MOVE.l A1,D2
      MOVEQ.l #$04,D3
      MOVEA.l _dosbase,A6
      JSR _Write(A6)
      MOVEA.l (A2),A2
  BRA.w 'oloop
 'skip2
  MOVE.l D7,D1
  MOVE.l #zero,D2
  MOVEQ.l #$04,D3
  MOVEA.l _dosbase,A6
  JSR _Write(A6)

 'skip2a
  MOVE.l D7,D1
  MOVE.l #tstdone,D2
  MOVEQ.l #$04,D3
  MOVEA.l _dosbase,A6
  JSR _Write(A6)
  MOVE.l (A7)+,D0
  LSR.l #2,D0
  MOVE.l D0,temp1
  ;
  MOVE.l D7,D1
  MOVEQ.l #$14,D2
  MOVEQ.l #-$01,D3
  JSR _Seek(A6)
  MOVE.l D7,D1
  MOVE.l #temp1,D2
  MOVEQ.l #$04,D3
  JSR _Write(A6)
  MOVE.l D7,D1
  MOVEQ.l #$1C,D2
  MOVEQ.l #-$01,D3
  JSR _Seek(A6)
  MOVE.l D7,D1
  MOVE.l #temp1,D2
  MOVEQ.l #$04,D3
  JSR _Write(A6)
  ;
  MOVE.l D7,D1
  JSR _Close(A6)
RTS


writelist:                                                 ;hello   dc.b    'ZAP',0 org source
  ;a2=first, d5=.b len offset
  ; new >
  ADDQ.w #5,D1
  ADDQ.b #8,D0
  ; < new
                                                           
 'loop
    CMPA.w #$0,A2
    BEQ.w 'done
     BSR.w writeitem
    MOVEA.l (A2),A2
 BRA.w 'loop

 'done
RTS


writeitem:
  MOVEQ.l #$00,D3
  MOVE.b $0(A2,D5.W),D3
  ADDQ.w #1,D3
  BCLR #$0,D3                                              ;word align
  MOVE.l (A2),-(A7)
  BEQ.w 'skip
    BSR.w 'resoff
    ADD.l D3,D6
    MOVE.l D6,(A2)
    SUB.l D3,D6
 'skip
  ADD.l D3,D6
  MOVE.l A2,D2
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  JSR _Write(A6)
  MOVE.l (A7)+,(A2)
RTS

'resoff
  MOVE.l D6,D2
BRA.w addhunkoffset


writeoffs:
  ;write the offsets
  ;
 'loop
    CMPA.w #$0,A2
     BEQ.w 'done
    MOVEA.l newtypebase,A1
    MOVEQ.l #$00,D1

 'loop2
      CMPA.w #$0,A1
      BEQ.w 'found
      CMPA.l $A(A2),A1
       BEQ.w 'found
      ADDQ.w #1,D1
      MOVEA.l (A1),A1
 BRA.w 'loop2

 'found
    MOVE.w $A(A2),-(A7)
    MOVE.w D1,$A(A2)
     BSR.w writeitem
    MOVE.w (A7)+,$A(A2)
    MOVEA.l (A2),A2
 BRA.w 'loop

 'done
RTS


countem:
  MOVEQ.l #$00,D0

 'loop
  CMPA.w #$0,A2
   BEQ.w 'done
  ADDQ.w #1,D0
  MOVEA.l (A2),A2
 BRA.w 'loop

 'done
  MOVE.w D0,temp1
  MOVE.l D7,D1
  MOVE.l #temp1,D2
  MOVEQ.l #$02,D3
  ADDQ.l #2,D6
  MOVEA.l _dosbase,A6
JMP _Write(A6)


resident_Macros:
  ;put out! macros
  ;
  ; new >
   TST.b resdisable
   BEQ 'l1
   MOVE.l currentmacroaddr,a3
   CMP.l #0,a3
   BEQ 'l1
   MOVE.l (a3),a3
 BRA 'l2

 'l1
  ; < new
  MOVEA.l macrobase,A3                                     ;??begin org code??

 'l2
  MOVEA.l A3,A2
  BSR.w countem

 'loop
   CMPA.w #$0,A3
   BEQ.w 'done
  MOVE.l D6,D5
  MOVE.l (A3),-(A7)
  MOVE.l $4(A3),-(A7)
  MOVEQ.l #$00,D3
  MOVE.b $C(A3),D3
  ADDQ.w #1,D3
  BCLR #$0,D3
  ADD.l D3,D6                                              ;add len of struct
  TST.w $8(A3)
   BEQ.w 'notext
  MOVE.l D6,$4(A3)
  MOVE.l D5,D2
  ADDQ.l #4,D2
   BSR.w addhunkoffset

 'notext
  MOVEQ.l #$00,D4
  MOVE.w $8(A3),D4
  ADDQ.w #1,D4
  BCLR #$0,D4
  ADD.l D4,D6
  TST.l (A3)
   BEQ.w 'nomore
  MOVE.l D6,(A3)
  MOVE.l D5,D2
   BSR.w addhunkoffset

 'nomore
  MOVE.l A3,D2
  MOVE.l D7,D1
   MOVEA.l _dosbase,A6
   JSR _Write(a6)
  TST.l D4
   BEQ.w 'skip
  MOVE.l (A7),D2
  MOVE.l D4,D3
  MOVE.l D7,D1
    MOVEA.l _dosbase,A6
   JSR _Write(A6)

 'skip
  MOVE.l (A7)+,$4(A3)
  MOVE.l (A7)+,(A3)
  MOVEA.l (A3),A3
 BRA.w 'loop

 'done
RTS


resident_Types:
  ; new >
  TST.b resdisable
  BEQ 'l1
    MOVE.l lastrestype,a3
    CMP.l #0,a3
    BEQ 'l1
      MOVE.l (a3),a3
      BRA 'l2
 'l1
    ; < new
    MOVEA.l newtype_string,A3
 'l2
  MOVEA.l A3,A2
  BSR.w countem

 'loop
    CMPA.w #$0,A3
    BEQ.w 'done
      MOVE.l D6,-(A7)
      MOVEA.l $4(A3),A2
      MOVEQ.l #$0E,D5
      BSR.w writeoffs

      MOVE.l (A7)+,D0
      MOVE.l $4(A3),-(A7)
      MOVE.l D0,$4(A3)
      MOVE.l D6,D2
      ADDQ.l #4,D2
      BSR.w addhunkoffset
      MOVEQ.l #$00,D3
      MOVE.b $A(A3),D3
      ADDQ.w #1,D3
      BCLR #$0,D3
      ADD.l D3,D6
      MOVE.l A3,D2
      MOVE.l D7,D1
      MOVEA.l _dosbase,A6
      JSR _Write(A6)
      MOVE.l (A7)+,$4(A3)
      MOVEA.l (A3),A3
  BRA.w 'loop
 'done
RTS


resident_Constants:
  ; new >
   TST.b resdisable
   BEQ 'l1
   MOVE.l currentlabeladdr,a2
   CMP.l #0,a2
   BEQ 'l1
   MOVE.l (a2),a2
 BRA 'l2

 'l1
  ; < new
   MOVEA.l labelbase,A2

 'l2
   MOVEQ.l #$00,D0

 'loop
   CMPA.w #$0,A2
   BEQ.w 'done
  CMPI.l #$1,$4(A2)
   BNE.w 'next
  ADDQ.w #1,D0

 'next
  MOVEA.l (A2),A2
 BRA.w 'loop

 'done
  MOVE.w D0,temp1
  MOVE.l D7,D1
  MOVE.l #temp1,D2
  MOVEQ.l #$02,D3
  ADDQ.l #2,D6
    MOVEA.l _dosbase,A6
    JSR _Write(A6)
  ; new>
   TST.b resdisable
   BEQ 'done_l1
   MOVE.l currentlabeladdr,a2
   CMP.l #0,a2
   BEQ 'done_l1
   MOVE.l (a2),a2
 BRA 'loop2

 'done_l1
  ; < new
   MOVEA.l labelbase,A2                                    ;write resident labels

 'loop2
   CMPA.w #$0,A2
   BEQ.w 'done2
  CMPI.l #$1,$4(A2)
   BNE.w 'next2
   MOVEQ.l #$00,D3
  MOVE.b $12(A2),D3                                        ;length
  ADDQ.w #1,D3
  BCLR #$0,D3
  MOVE.l D6,D2
  ADD.l D3,D6
  MOVE.l (A2),-(A7)
  TST.l (A2)
   BEQ.w 'nonext
  MOVE.l D6,(A2)
   BSR.w addhunkoffset

 'nonext
  MOVE.l A2,D2
  MOVE.l D7,D1
    MOVEA.l _dosbase,A6
    JSR _Write(A6)
  MOVE.l (A7)+,(A2)

 'next2
  MOVEA.l (A2),A2
 BRA.w 'loop2

 'done2
RTS


; new >
.check_residentpath
   !basic
    MOVE.l ptr_resfile,d0
    resfileP.l = Peek.l(?ptr_resfile)
    If resfileP
      resfile$ = Peek.s(resfileP)
      tests.b = Instr(resfile$,"/")
      testc.b = Instr(resfile$,":")
      If tests=0 AND testc=0
        resfile$ = dos_AddPart{config\path_residents, resfile$}
        Poke.l ?ptr_resfile,&resfile$
      EndIf
    Else
      error{"INTERNAL: Invalid pointer in ptr_resfile!"}
    End If
   !asm
RTS
; < new


.reloadresident:  ;loadres org source
  ;load in resident structs.....
  ;
  MOVE.l a7,stackaddr                                      ; added to prevent a crash in CLIMode if #continue_on_error is set and residents can't load  tomsmart1
  MOVE.l A7,errstack
  ; new >
  ;JSR free_unusedfunctions
  ; < new
  MOVE.l #'next,errcont
  MOVE.w #$FFFF,ezerr         ; was -1
  ;
  BSR.w Aclearallvars
  BSR.w free_residents
  ;
  LEA residents_table,A5
  MOVEQ.l #$07,D6

 'loop
    TST.b (A5)
    BEQ.w 'next
    MOVE.l A5,ptr_resfile
    BSR check_residentpath
    MOVE.l ptr_resfile,d1
    MOVEA.l _dosbase,A6
    JSR _LoadSeg(A6)
    MOVE.l D0,$40(A5)
    BNE.w 'yeah
    ;
    BSR.w reserr

  'yeah
   ;res loaded O.K.
    MOVEA.l D0,A3
    ADDA.l A3,A3
    ADDA.l A3,A3
    ADDQ.w #4,A3                                           ;start of res
    ;
    BSR.w fixtypes
    BSR.w fixmacs                                        ;add macros to list
    BSR.w fixconsts                                        ;read labels

  'next
    LEA ResidentEntryStep(A5),A5       ;$44
  DBF D6,'loop

    ;
    ;check resident clashes!
    ;
  MOVE.l #free_residents,errcont

  MOVEA.l newtype_string,A3
  MOVEQ.l #$0B,D7
  BSR.w checkclash

  MOVEA.l macrobase,A3
  MOVEQ.l #$d,D7
  BSR.w checkclash

  MOVEA.l firstconst,A3
  MOVEQ.l #$19,D7
  BSR.w checkclash

 ;'skipresload                                             ;??looks like label not used??
RTS


checkclash:
  MOVEA.l A3,A4

 'loop
    CMPA.w #$0,A4
    BEQ.w 'done

    LEA ptr_parameterstore,A0
    LEA $0(A4,D7.W),A1
    MOVEQ.l #-$01,D2

 'loop2
      ADDQ.w #1,D2
      MOVE.b (A1)+,(A0)+
    BNE.w 'loop2
    MOVEA.l A3,A2

 'more
    BSR.w findlab
    BNE.w 'next                                  ;not found
    CMPA.l A2,A4
  ; new >
    BEQ.w 'l1
    MOVE.l a1,a5
  ; < new
 BRA clasherr      ; was bne

 'l1
 BRA.w 'more

 'next
    MOVEA.l (A4),A4
 BRA.w 'loop

 'done
RTS


.free_residents:
  MOVEA.l _dosbase,A6

  LEA newtype_string,A0
  MOVE.l A0,lastrestype
  CLR.l (A0)

  LEA macrobase,A0
  MOVE.l A0,currentmacroaddr
  CLR.l (A0)

  LEA labelbase,A0
  MOVE.l A0,currentlabeladdr
  CLR.l (A0)
  CLR.w rescnt

;  MOVEA.l comdata,A2
;  MOVE.b debugmode,$7ee(a2)
  !ComData_SetB{comByte_DebugMode,debugmode}

;freeres2:
  LEA residents_table,A2
  MOVEQ.l #$07,D2

 'loop
     MOVE.l $40(A2),D1
     BEQ.w 'next
      CLR.l $40(A2)
      MOVEA.l _dosbase,A6
      JSR _UnLoadSeg(A6)

  'next
     LEA ResidentEntryStep(A2),A2   ; $44
 DBF D2,'loop

RTS


fixconsts
  MOVE.w (A3)+,D1
  BEQ.w 'done
  MOVEA.l currentlabeladdr,A2
  MOVE.l A3,(A2)
  SUBQ.w #1,D1

 'loop
    MOVEA.l A3,A2
    MOVEA.l (A3),A3
  DBF D1,'loop

  ; new >
  CLR.l (a2)                                               ;bugfix for object
  ; < new
  MOVE.l A2,currentlabeladdr
  MOVEA.l A2,A3
  MOVEQ.l #$00,D0
  MOVE.b $12(A3),D0
  ADDQ.w #1,D0
  BCLR #$0,D0
  ADDA.w D0,A3

 'done
RTS


fixmacs
  MOVE.w (A3)+,D1
  BEQ.w 'done
  MOVEA.l currentmacroaddr,A2
  MOVE.l A3,(A2)
  SUBQ.w #1,D1

 'loop
    MOVEA.l A3,A2
    MOVEA.l (A3),A3
  DBF D1,'loop

  MOVE.l A2,currentmacroaddr
  MOVEA.l A2,A3
  MOVEQ.l #$00,D0
  MOVE.b $C(A3),D0
  ADDQ.w #1,D0
  BCLR #$0,D0
  MOVE.w $8(A3),D1
  ADDQ.w #1,D1
  BCLR #$0,D1
  ADDA.w D0,A3
  ADDA.w D1,A3

 'done
RTS


fixtypes
  ;fix up all load types
  MOVE.w (A3)+,D1            ;number of types to do
  BEQ.w 'done
  MOVE.w D1,-(A7)
  SUBQ.w #1,D1
  MOVEA.l lastrestype,A2
  MOVE.l A2,-(A7)

 'loop
      MOVE.l (A3),D0          ;skip through offsets
      BEQ.w 'loopme
      MOVEA.l D0,A3
 BRA.w 'loop

   'loopme
      MOVE.b $E(A3),D0
      ADDQ.w #1,D0
      BCLR #$0,D0
      ADDA.w D0,A3            ;a3=type
      MOVE.l A3,(A2)          ;link
      MOVEA.l A3,A2
      MOVEQ.l #$00,D0
      MOVE.b $A(A3),D0
      ADDQ.w #1,D0
      BCLR #$0,D0
      ADDA.w D0,A3            ;next offset
  DBF D1,'loop
  ;
  ;Now, Fix up pointers to Stuff!
  ;
  MOVEA.l (A7)+,A0
  MOVEA.l (A0),A0

 'floop
    CMPA.w #$0,A0
    BEQ.w 'fdone
    MOVEA.l $4(A0),A1          ;first offset!

 'floop2
    CMPA.w #$0,A1
    BEQ.w 'fofd
    ;
    MOVE.w $A(A1),D0           ;number of type
    MOVEA.l newtypebase,A4
    CMP.w #$7,D0
    BCS.w 'fsys
    SUB.w rescnt,D0

 'fsys
    SUBQ.w #1,D0
    BMI.w 'fdone2

 'floop3
       MOVEA.l (A4),A4
  DBF D0,'floop3

 'fdone2
    MOVE.l A4,$A(A1)
    MOVEA.l (A1),A1
 BRA.w 'floop2

 'fofd
    MOVEA.l (A0),A0
 BRA.w 'floop

 'fdone
  MOVE.w (A7)+,D0
  ADD.w D0,rescnt
  MOVE.l A2,lastrestype

 'done
RTS


; was runerropts at this point in org source
.make_AssemblerTable:                                 ; make a table of pointers to ASM data
                                                      ; d1: last token number of all loaded tokens
  LEA tokens,A0
  MOVE.w #$003A,D0                                    ; $003A : 58 dec
 'loop                                                ; skip 58 tokens, beginning of ASM instructions
    MOVEA.l (A0),A0
  DBF D0,'loop

  MOVEA.l #asmpnts,A1                                 ; create tokentab
  MOVE.w #$0076,D0        ; was #tnum-fnum-1,         ; $0076 : 118 dec

 'loop2
    LEA $6(A0),A2                                     ;get beginning of tokenname

   'loop3                                             ;skip tokenname
     TST.b (A2)+
    BNE.w 'loop3

   'loop4                                             ;skip token helptext
      TST.b (A2)+
    BNE.w 'loop4

    ADDQ.w #1,A2                                      ;
    EXG.l D1,A2                                       ;make sure the address is even
    BCLR #$0,D1                                       ;
    EXG.l D1,A2                                       ;

    MOVE.l A2,(A1)+                                   ;
    MOVEA.l (A0),A0
  DBF D0,'loop2
RTS


getimm:                                                    ;get an immediate value
  BSR.w asmconst
  MOVEQ.l #$0B,D5
RTS


unmove:  Ds.w 1


regmovems:                                                 ;d4=reg#
  MOVE.w #$48E7,D1
  BSR.w writeword                                          ;movem.l -(a7)
  MOVE.w #$000F,D2
  SUB.w D4,D2
  MOVEQ.l #-$01,D1
  BCLR D2,D1
  BSR.w writeword
  MOVEQ.l #-$01,D1
  BCLR D4,D1
  MOVE.w D1,unmove
RTS


dounmove:
  MOVE.w #$4CDF,D1
  BSR.w writeword
  MOVE.w unmove(PC),D1
 BRA.w writeword

    ;if bit 15 of d2 then code has been generated for
    ;address of thing in a2. else d3=offset from a5
    ;for simple variable.
    ;
    ;d2 & ff=type. 0=struct address
    ;
    ;bit 14 of d2=1 if result is a pointer
    ;


.do_PutReg:
  BSR.w get_reg2
  CMP.w #$2C,D0                                            ;#','
  BNE.w syntaxerr

  MOVE.l #$48E7FFFE,D1                                     ;movem.l d0-a6,-(a7)
  BSR.w writelong
  MOVE.w D4,D1
  ORI.w #$2F00,D1
  BSR.w writeword
  ;
  BSR.w get1bytemain
  JSR getparameter           ; bsr.w
  BSR.w fetchvars
  BSR.w calcvar
  BTST #$E,D2
  BEQ.w 'notp

 'issa
    MOVE.b #$3,D2
    BRA.w 'pd

 'notp
    TST.b D2
   BEQ.w 'issa
  CMP.b #$7,D2
   BEQ.w 'issa

 'pd
  BTST #$F,D2
   BNE.w 'nsimp
  MOVE.w #$45ED,D1                                         ;lea x(a5),a2
   BSR.w writeword
  MOVE.w D3,D1
   BSR.w writeword

 'nsimp
  MOVE.w #$201F,D1                                         ;move.l (a7)+,d0
   BSR.w writeword
  MOVE.w #$1480,D1
  CMP.b #$1,D2
   BEQ.w 'pg
  EORI.w #$3000,D1
  CMP.b #$2,D2
   BNE.w 'pg
  ORI.w #$1000,D1

 'pg
  BSR.w writeword
  MOVE.l #$4CDF7FFF,D1
BRA.w writelong


.do_GetReg:
  BSR.w get_reg2
  CMP.w #$2C,D0                  ;','
  BNE.w syntaxerr

  BSR.w regmovems
  MOVE.w D4,-(A7)
  MOVEQ.l #$03,D2                ;get a long
  JSR eval                       ; BSR.w
  MOVE.w (A7)+,D1
   BEQ.w 'done
  CMP.w #$8,D1
   BCC.w 'addreg
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2000,D1
   BSR.w writeword
 BRA.w 'done

 'addreg
  SUBQ.w #8,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2040,D1
  BSR.w writeword

 'done
BRA.w dounmove


get_reg:                ; was getreg
  BSR.w get1bytemain

get_reg2:
  ORI.w #$20,D0
  CMP.w #$64,D0       ;'d'      Dataregister
  BEQ.w getan3
  CMP.w #$61,D0       ;'a'      Addressregister
  BNE.w syntaxerr
  BSR.w getan3
  ADDQ.w #8,D4
RTS


getan:
  ; new >
  !fget                                                   ;bsr.w get1bytemain
  ; < new
  ORI.w #$20,D0

getan2:
  CMP.w #$61,D0     ;'a'
  BNE.w syntaxerr

getan3:
  ; new >
  !fget                                                    ;bsr.w get1bytemain
  ; < new
  SUBI.w #$30,D0    ; check if register number is within [0..7]
  BMI.w syntaxerr
  CMP.w #$7,D0       
  BHI.w syntaxerr
  MOVE.w D0,D4
  ; new >
  !fget
  ; < new
RTS                                                        ;bra.w get1bytemain


getmovem2:
  ADDQ.w #8,D4

getmovem:
  MOVEQ.l #$00,D5    ;bits for reg
  SUBI.w #$30,D4

 'loop
  CMP.w #$2D,D0      ;'-'
   BEQ.w 'range
  CMP.w #$2F,D0      ;'/'
   BEQ.w 'one
 BRA.w syntaxerr

 'done2
  BSET D4,D5

 'done
  MOVE.w D5,D4
  MOVEQ.l #$0F,D5
 RTS

 'one
  BSET D4,D5
  BSR.w get_reg
  ; new >
  !compare3                                                ;bsr.w tstend2
  ; < new
  BNE.w 'loop
 BRA.w 'done2

 'range
  MOVE.w D4,D1    ;from
   BSR.w get_reg
  CMP.w D4,D1
   BLS.w 'loop2
  EXG.l D4,D1

 'loop2
  BSET D1,D5
  ADDQ.w #1,D1
  CMP.w D4,D1
   BLS.w 'loop2
  ; new <
  !compare3                                                ;bsr.w tstend2
  ; < new
  BNE.w 'loop
BRA.w 'done


getea:
  ;evaluate the ea of an asm bit
  ;
  MOVEA.l A5,A4                                            ;bsr.w get1bytemain
  ; new >
   !fget
  ; < new
  CMP.w #$23,D0       ;'#'
   BEQ.w getimm
  CMP.w #$28,D0       ;'('
   BEQ.w 'ind
  CMP.w #$2D,D0       ;'-'
   BNE.w 'more
  ; new >
   !fget                                                   ;bsr.w get1bytemain       -(
  ; < new
  CMP.w #$28,D0       ;'('
   BNE.w 'notccr
   BSR.w getan
  CMP.w #$29,D0       ;')'
   BNE.w syntaxerr
  MOVEQ.l #$04,D5
  ; new >
  !fget                                                    ;bsr.w get1bytemain  
 RTS
  ; < new

 'ind
  BSR.w getan
  CMP.w #$29,D0      ;')'
   BNE.w syntaxerr
 ; new >
  !fget
 ; < new                                                     ;bsr.w get1bytemain
  CMP.w #$2B,D0      ;'+'
   BEQ.w 'postinc
  MOVEQ.l #$02,D5
 RTS

 'postinc
  MOVEQ.l #$03,D5
  ; new >
  !fget                                                    ;bra.w get1bytemain
 RTS
  ; new >

 'more
  ORI.w #$20,D0
  MOVE.w D0,D1      ;first
  ; new >
   !fget                                                   ;bsr.w get1bytemain  ;get second
  ; < new
  CMP.w #$64,D1     ;'d'
   BNE.w 'notdn
  CMP.w #$30,D0     ;'0'
   BCS.w 'notan
  CMP.w #$37,D0     ;'7'
   BHI.w 'notan
  MOVE.w D0,D4
  ; new >
   !fget                                                   ;bsr.w get1bytemain
   !compare3                                               ;bsr.w tstend2
  ; < new
   BEQ.w 'dn
  CMP.w #$2D,D0     ;'-'
   BEQ.w getmovem
  CMP.w #$2F,D0     ;'/'
   BEQ.w getmovem
 BRA.w 'notan2

 'dn
  MOVEQ.l #$00,D5
  SUBI.w #$30,D4
 RTS

 'notdn
   CMP.w #$61,D1    ;'a'
   BNE.w 'notan
  ;
  CMP.w #$30,D0     ;'0'
   BCS.w 'notan
  CMP.w #$37,D0     ;'7'
   BHI.w 'notan
  MOVE.w D0,D4
  ; new >
   !fget                                                   ;bsr.w get1bytemain
   !compare3                                               ;bsr.w tstend2
  ; < new
   BEQ.w 'an
  CMP.w #$2D,D0     ;'-'
   BEQ.w getmovem2                                         ;movem
  CMP.w #$2F,D0     ;'/'
   BEQ.w getmovem2
 BRA.w 'notan2

 'an
  ;
  ;An
  ;
  MOVEQ.l #1,d5
  SUBI.w #$30,D4
  ; new >
  BRA 'l10
  ADDQ.w #8,d4                             ; ??? looks like dead code ???
  MOVEQ #0,d5                              ;   "
  BSET d4,d5                               ;   "
  MOVE.w d5,d4                             ;   "
  MOVEQ.l #$0f,D5                          ;   "             ;01

 'l10
  ; > new
 RTS

 'notan
  ORI.w #$20,D0
  MOVE.w D0,D4
   !fget                                                   ;bsr.w get1bytemain ;get third

 'notan2
  ;d1,d4,d0=chars
  ; new >
  !compare3                                                ;bsr.w tstend2
  ; < new
   BNE.w 'notsx
  CMP.w #$73,D1       ;'s'
   BNE.w 'notsx
  CMP.w #$70,D4       ;'p'
   BNE.w 'notsp
  ; new >
   !compare3                                               ;bsr.w tstend2
  ; < new
   BNE.w 'notccr
  ;
  ;Sp
  ;
  MOVEQ.l #$07,D4
  MOVEQ.l #$01,D5
 RTS

 'notsp
  CMP.w #$72,D4      ;'r'
   BNE.w 'notccr
  ; new >
   !compare3                                               ;bsr.w tstend2
  ; < new
   BNE.w 'notccr
  MOVEQ.l #$0D,D5
 RTS

 'notsx
  ORI.w #$20,D0
  CMP.w #$63,D1      ;'c'
   BNE.w 'notccr0
  CMP.w #$63,D4      ;'c'
   BNE.w 'notccr
  CMP.w #$72,D0      ;'r'
   BNE.w 'notccr
   BSR.w get1bytemain                                      ;??wy not !fget
   BEQ.w 'ccr
  CMP.w #$2C,D0
   BNE.w 'notccr

 'ccr
  ;
  ;ccr
  ;
  MOVEQ.l #$0C,D5
 RTS

 'notccr0
  CMP.w #$75,D1      ;'u'
   BNE.w 'notccr
  CMP.w #$73,D4      ;'s'
   BNE.w 'notccr
  CMP.w #$70,D0      ;'p'
   BNE.w 'notccr
   BSR.w get1bytemain                                      ;??wy not !fget
   BEQ.w 'usp
  CMP.w #$2C,D0      ;','
   BNE.w 'notccr

 'usp
  MOVEQ.l #$0E,D5
 RTS

 'notccr
  ;
  ;not anything - must be a label or abs address of some kind
  ;
  MOVEA.l A4,A5
   BSR.w asmconst
  ;
  ; new >
   !compare3                                               ;bsr.w tstend2
  ; < new
   BEQ.w 'abs1
  CMP.w #$2E,D0      ;'.'
   BEQ.w 'absx
  CMP.w #$28,D0      ;'('
   BNE.w syntaxerr
   BSR.w get1bytemain                                      ;??wy not !fget
  ORI.w #$20,D0
  CMP.w #$70,D0      ;'p'
   BNE.w 'notpcrel
   BSR.w get1bytemain                                      ;??wy not !fget
  ORI.w #$20,D0
  CMP.w #$63,D0      ;'c'
   BNE.w syntaxerr
   BSR.w get1bytemain                                      ;??wy not !fget
   BSR.w getrest
  ADDQ.w #4,D5
 RTS

 'notpcrel
  BSR.w getan2
 BRA.w getrest

 'absx
   BSR.w get1bytemain                                     ;??wy not !fget
  ORI.w #$20,D0
  CMP.w #$77,D0      ;'w'
   BEQ.w 'absw
  CMP.w #$6C,D0      ;'l'
   BNE.w syntaxerr

 'abs1
  MOVEQ.l #$08,D5
 RTS

 'absw
  MOVEQ.l #$07,D5
RTS


tstend2:
  TST.w D0
   BEQ.w 'ok
  CMP.w #$3A,D0       ;':'
   BEQ.w 'ok
  CMP.w #$2C,D0       ;','

 'ok
RTS


getrest:
  CMP.w #$2C,D0       ;','
   BNE.w 'dis
   BSR.w get1bytemain                                      ;??wy not !fget
  ORI.w #$20,D0
  MOVEQ.l #$00,D1
  CMP.w #$64,D0       ;'d'
   BEQ.w 'ianxi
  CMP.w #$61,D0       ;'a'
   BNE.w syntaxerr
  BSET #$F,D1

 'ianxi
   BSR.w get1bytemain                                      ;??wy not !fget
  SUBI.w #$30,D0
   BMI.w syntaxerr
  CMP.w #$7,D0
   BHI.w syntaxerr
  LSL.w #8,D0
  LSL.w #4,D0
  OR.w D0,D1
   BSR.w get1bytemain                                      ;??wy not !fget
  CMP.w #$2E,D0       ;'.'
   BNE.w 'ok2
   BSR.w get1bytemain                                      ;??wy not !fget
  ORI.w #$20,D0
  CMP.w #$77,D0       ;'w'
   BEQ.w 'ok
  CMP.w #$6C,D0       ;'l'
   BNE.w syntaxerr
  BSET #$B,D1

 'ok
   BSR.w get1bytemain                                      ;??wy not !fget

 'ok2
  ; new >
   CMP.b #"*",d0                                            ;020 * Mode
            BNE 'l1
            BSR.w get1bytemain                             ;??wy not !fget
            CMP.b #"2",d0
            BNE 'l2
            OR.w #$200,d1
 BRA 'l1b

 'l2
            CMP.b #"4",d0
            BNE 'l3
            OR.w #$400,d1
 BRA 'l1b

 'l3
            CMP.b #"8",d0
            BNE syntaxerr
            OR.w #$600,d1

 'l1b
        BSR.w get1bytemain                                 ;??wy not !fget

 'l1
  ; < new
  CMP.w #$29,D0       ;')'
   BNE.w syntaxerr
  MOVE.w D1,extraword
  MOVEQ.l #$06,D5
 BRA.w get1bytemain                                         ;??wy not !fget

 'dis
  CMP.w #")",D0                                            ;")"
   BNE.w errorbracketmiss                                  ; was syntax error
  MOVEQ.l #$05,D5
BRA.w get1bytemain                                         ;??wy not !fget


asmconst:                                                  ;store the text of the eval into asmfirst...
    ;
    ;text till '(','.'
    ;
  MOVEA.l asmbuff,A0
  MOVE.w ininclude,D1
  OR.w inmacro,D1
  MOVE.w D1,(A0)+                                          ;flag!
   BNE.w copyconst
  MOVE.l A5,-(A7)
   BSR.w copyconst
  MOVEA.l asmbuff,A0
  CMP.w #$4,D1
   BLS.w 'leave
  TST.w lc
   BNE.w 'leave
  ADDQ.w #2,A0
  MOVE.l (A7)+,(A0)+
  CLR.b (A0)
  MOVE.w #$0004,asmlen2                                    ;pointer + 0
 RTS

 'leave
  NOT.w (A0)
  ADDQ.w #4,A7
RTS


lc:  Ds.w 1


copyconst:
  CLR.w lc
  MOVEQ.l #$00,D1

 'loop
   ADDQ.w #1,D1                                            ;label name
   ; new >
   !fget                                                   ;bsr.w get1bytemain
   ; < new
   BEQ.w 'done
   ;
   ; new >
   CMP.w #$22,d0
   BNE.s 'loop_l10
   NOT.w instringon

 'loop_l10
   CMP.w #":",d0
   BNE.s 'loop_l11
   TST.w instringon
   BEQ 'done

 'loop_l11
  ; < new
  TST.w D0
  BPL.w 'notmi
  MOVE.w D0,-(A7)
  LSR.w #8,D0
  MOVE.b D0,(A0)+
  MOVE.w (A7)+,D0
  MOVE.b D0,(A0)+
  ADDQ.w #1,D1
 BRA.s 'loop

 'notmi
   TST.w instringon
   BNE.w 'putbyte
  ; new >
   TST.b _dcb
   BNE 'notmi_l10
  ; < new
   CMP.w #$28,D0     ;'('
   BEQ.w 'done

 'notmi_l10
   ; < new
   CMP.w #$2C,D0     ;','
   BEQ.w 'done
   CMP.b #"'",D0           ; was #loclabch
   BNE.w 'putbyte
   MOVE.w D0,lc                                     ;locallabels
   MOVE.l A1,-(A7)
   LEA lastgloballabel,A1
   TST.b (A1)
   BEQ.w nolocerr

 'cloop
  ADDQ.w #1,D1
  MOVE.b (A1)+,(A0)+
   BNE.w 'cloop
  SUBQ.w #1,D1
  SUBQ.w #1,A0
  MOVEA.l (A7)+,A1

 'putbyte
  MOVE.b D0,(A0)+
 BRA.w 'loop

 'done
  CLR.b (A0)
  MOVE.w D1,asmlen2
RTS


.assemble_it:
  ;-------------------------------------------------
  ;-- Patch some instructions to be used by own code
  CMP.l ##TokenID_BSS,d0                                   ; token was asm instruction TAS
  BNE.s 'l12
    JMP bssseg
 'l12

  CMP.l ##TokenID_Chip,d0                                  ; token was asm instruction MOVEP
  BNE.s 'l13
    JMP chipseg
 'l13
  ;-------------------------------------------------

  ADDQ.l #1,destpointer                                    ;even
  BCLR #$0,destpointer+3
  ; < new
  SUBI.w #$803C,D0                                         ; substract offset in tokennumber, now d0 is the number of instruction as ...
                                                           ; 0.. ABCD
                                                           ; 1.. ADD ...
  LSL.w #2,D0                                              ; tokennumber * 4

  MOVEA.l #asmpnts,A0
  MOVEA.l $0(A0,D0.W),A0                                   ; begin inline assembler: get the asm instruction from token number
  MOVE.w D0,temp1
  MOVE.l A0,-(A7)
  ;
  MOVEQ.l #$01,D1         ; 1:no size, 0:byte, 4:word/defaultsize 8:longword
  ; new >
   !fget                                                   ;bsr.w get1bytemain
  ; < new
  CMP.w #$2E,D0           ;'.'                             check a size extention of the asm instruction
  BNE.w 'dsize
  ; new <
  !fget                                                    ;bsr.w get1bytemain
  ; < new
  ORI.w #$20,D0

  CMP.w #$77,D0           ;'w'                                  ;long
  BEQ.w 'wsize
  CMP.w #"W",D0           ;'W'
  BEQ.w 'wsize

  CMP.w #$62,D0           ;'b'                                 ;byte
  BEQ.w 'bsize
  CMP.w #"B",D0           ;B
  BEQ.w 'bsize

  CMP.w #$6C,D0           ;'l'                                 ;word
  BEQ.w 'lsize
  CMP.w #"L",D0           ;L
  BEQ.w 'lsize

  CMP.w #"s",d0           ;s equals b
  BNE syntaxerr

  BRA.w 'bsize             ; was 'lsize org source

 'bsize
    MOVEQ.l #$00,D1
    MOVE.w $8(A0),D0      ; some opcode mask and allowed operand size from instruction table in D0
    BRA.w 'tstsize
 'dsize                   ; defaultsize
    MOVEQ.l #$04,D1
    BRA.w 'putsize

 'wsize
    MOVEQ.l #$04,D1
    MOVE.w $8(A0),D0
    LSR.w #4,D0
    BRA.w 'tstsize

 'lsize
    MOVEQ.l #$08,D1
    MOVE.w $8(A0),D0
    LSR.w #8,D0

 'tstsize
    ANDI.w #$F,D0          ; check allowed operand size
    CMP.w #$F,D0           ; allowed sizes are coded this way: byte: $ff0, word: $f1f, long: $2ff, nosize: $fff, all sizes: $210
    ; new >
    BNE.w 'cl60
 'c10

  ; patch some instruction handling to support 32bit operands
   CMP.l #"MULS",-6(a0)    ; works only, if no helptext is available in the the token definition !!
   BNE 'c20
    MOVE.l #$4c000800,d1
    JMP do32
 'c20
   CMP.l #"MULU",-6(a0)
   BNE 'c30
    MOVE.l #$4c000000,d1
    JMP do32
 'c30
   CMP.l #"DIVS",-6(a0)
   BNE 'c40
    MOVE.l #$4c400800,d1
    JMP do32
  'c40
   CMP.l #"DIVU",-6(a0)
   BNE 'c50
    MOVE.l #$4c400000,d1
    JMP do32
  'c50
   ; < new
   BRA illsizeerr             ; in org source this was afte 'c160

 'cl60
  !fget                                                    ;bsr.w get1bytemain

 'putsize
  MOVE.w D1,asmsize                                          ; asmsize = operandsize
  MOVEQ.l #-$01,D3                                           ; set all bits of D3

  BSR.w reget                                                ; check further parameters of asm instruction
  BEQ.w 'done0                                               ; get values
    MOVE.l #ptr_parameterstore,asmbuff
    ;bsr.w bakup
    ; new >
    MOVE.w oldqflag,instringon
    MOVEA.l lastsourcepos,A5
    ;< new
    BSR.w getea
    MOVE.l D4,D2                                              ;to src
    MOVE.l D5,D3
    MOVE.w asmlen2,asmlen
    MOVEQ.l #-$01,D5
    MOVE.w extraword,extraword2

    CMP.w #$2C,D0                                             ;','
    BNE.w 'done0
      MOVE.l #namebuff2,asmbuff
      BSR.w getea                                              ;dest
 'done0
  ;
  ;all stuff fetched!
  ;now to assemble it.....
  ;
  MOVEA.l (A7)+,A0
  ;
  ;O.K. - Let's assemble it!
  ;
  ;d1=opcode,d2=srcreg,d3=srcea,d4=destreg,d5=destea
  ;
  MOVEA.l destpointer,A1    ; pc
  ;
  MOVEA.l A1,A4
  ADDQ.w #2,A1
  MOVE.w (A0),D1            ;opcode
  TST.w D3
  BMI.w 'none              ;no src/dest ea!
  ;
  ;make into movea, addi etc. if possible
  ;
  MOVE.w $E(A0),D0
  BPL.w 'noia

  BTST #$0,D0
  BEQ.w 'noa

  CMP.w #$1,D5
  BNE.w 'noa

  CMP.w #$E,D3
  BEQ.w 'noia

  MOVE.w temp1,D0
  ADDQ.w #4,D0
  BRA.w 'moveon

 'noa
  BTST #$1,D0
  BEQ.w 'noia

  CMP.w #$B,D3
  BNE.w 'noia

  MOVE.w temp1,D0

 'moveon
  ADDQ.w #4,D0
  MOVEA.l #asmpnts,A0
  MOVEA.l $0(A0,D0.W),A0
  MOVE.w (A0),D1

 'noia
  MOVE.l #ptr_parameterstore,buff1
  MOVE.l #namebuff2,buff2

  MOVE.l $A(A0),D0                          ; check if a error checking routine is defined in the token
  BEQ.w 'nojsr
    MOVEA.l D0,A3
    MOVE.w asmsize,D6
    JSR (A3)                                ; call errorchecking routine
    BPL.w 'noerr
      CMP.w #-$2,D0
      BEQ.w illsizeerr
      BRA.w illeaerr
   'noerr
    BEQ.w 'nojsr
    ;
    EXG.l D2,D4
    EXG.l D3,D5
    ;
    MOVE.l extraword,D6
    SWAP D6
    MOVE.l D6,extraword
    ;
    MOVE.l #namebuff2,buff1
    MOVE.l #ptr_parameterstore,buff2
    ;
    MOVE.w asmlen,D6
    MOVE.w asmlen2,D7
    MOVE.w D6,asmlen2
    MOVE.w D7,asmlen
 'nojsr

  MOVE.l buff1,asmbuff
  MOVE.w $E(A0),D0
  BEQ.w 'nothing
  BMI.w 'nothing
  ; new >
  CMP.w #$7000,d1
  BNE 'skip
  CMP.w #$b,d3
  BNE illeaerr

 'skip
  ; < new
   CMP.w #$1,D0
   BNE.w 'n1to8
   CMP.w #$B,D3
   BNE.w 'nothing

 'skipsrc
  BSR.w insasm
  MOVE.w D4,D2
  MOVE.w D5,D3
  BRA.w 'skipsrc2

 'n1to8
   CMP.w #$2,D0
   BNE.w 'notbcc
  CMP.w #$8,D3
   BNE.w illeaerr
  MOVEQ.l #$09,D3
 BRA.w 'nothing

 'notbcc
   CMP.w #$3,D0
   BEQ.w 'skipsrc
  ;
 ;'notmq
  CMP.w #$4,D0
   BEQ.w 'skipsrc
  ;
 ;'nottrap
  CMP.w #$5,D0
   BNE.w 'notdbf
  CMP.w #$8,D5
   BNE.w illeaerr
  OR.w D2,D1
  MOVEQ.l #$09,D5

 'notdbf
 'nothing
  MOVE.w $2(A0),D6
  MOVE.b $6(A0),D7
  MOVEM.l D4-D5,-(A7)
  MOVE.w extraword2,D4
  BSR.w doea          ;do src
  ;
  MOVEM.l (A7)+,D2-D3
 ;'skipsrc3
  TST.w D3

 'skipsrc2
  BMI.w 'one
  MOVE.w extraword,D4
  MOVE.w $4(A0),D6
  MOVE.b $7(A0),D7
  MOVE.l buff2,asmbuff
  MOVE.w asmlen2,asmlen
  BSR.w doea
  BRA.w 'putit

 'one
  MOVE.w $4(A0),D0
  BNE.w illeaerr
  BRA.w 'putit

 'none
  MOVE.w $2(A0),D0
  OR.w $4(A0),D0
  BNE.w illeaerr

 'putit
  ;put in the opcode
  ;
  MOVE.w $8(A0),D0
  ANDI.w #$F000,D0
  CMP.w #-$1000,D0    ;was #$f000
  BEQ.w 'nosizep
  LSR.w #8,D0
  LSR.w #4,D0         ;shift for size
  ;
  MOVE.w $8(A0),D2
  MOVE.w asmsize,D3
  LSR.w D3,D2
  ANDI.w #$F,D2
  LSL.w D0,D2
  OR.w D2,D1          ;size into opcode

 'nosizep
  CMPA.l destbufferend,A4
  BCS.w 'oky
  MOVE.w #$FFFF,dontwrite_nomemleft     ; was -1
  BRA.w 'done

 'oky
  MOVE.w D1,(A4)

 'done
  MOVE.l A1,destpointer
RTS


asmoff:                                                 ;add an offset
  MOVE.l destpointer,-(A7)
  MOVE.l A1,destpointer
   BSR.w addoff
  MOVEA.l destpointer,A1
  MOVE.l (A7)+,destpointer
RTS

; new >
.do32
  MOVEM.l d2-d6,-(a7)
  ;handle source register
  JSR stripspaces
  CMP.b #"d",(a5)+      ; only dataregisters allowed
  BNE noreg

  MOVE.b (a5)+,d0
  CMP.b #$30,d0         ; check if in range d0-d7
  BLT noreg

  CMP.b #$37,d0
  BGT noreg

  SUB.b #$30,d0
  MOVEQ #0,d3
  MOVE.b d0,d3                                             ;reg1
  ASL.l #8,d3
  ASL.l #8,d3

  ; handle dest register
  JSR stripspaces
  CMP.b #",",(a5)+
  BNE noreg

  JSR stripspaces
  CMP.b #"d",(a5)+
  BNE noreg

  MOVE.b (a5)+,d0
  CMP.b #$30,d0
  BLT noreg

  CMP.b #$37,d0
  BGT noreg

  SUB.b #$30,d0
  MOVEQ #0,d4
  MOVE.b d0,d4                                             ;reg2
  ASL.l #8,d4
  ASL.l #4,d4
  OR.b d0,d1
  OR.l d3,d1
  OR.l d4,d1
  JSR writelong
  MOVEM.l (a7)+,d2-d6
  MOVEM.l d1/a1-a3,-(a7)
BRA exit


noreg
  MOVEM.l (a7)+,d2-d6
  LEA errtext,a0
  MOVE.l a0,-(a7)
JMP handle_compileerror
; < new


asmfixer:                                                  ;end of pass asm filler-inner
  MOVE.w dontwrite_nomemleft,D1
  BNE.w 'done
  BTST #$7,make_smallestcode
  BEQ.w 'go
    MOVE.w pass(PC),D1
    BEQ.w 'done
 'go
  MOVEA.l templabel,A2                                     ;insert labels in Code
  MOVE.b #1,curtemplabel
  MOVE.w #$FFFF,constmode
  CLR.w regnum
  MOVE.l #forthstack,forthsp
  MOVE.l #precstack,precsp
  BSR.w prepstack

 'loop
  MOVE.l A2,-(A7)
  BSR.w chkstop
  MOVEA.l (A7)+,A2
  CMPA.w #$0,A2
  BEQ.w 'done2

  CLR.b iee
  MOVE.l A2,asmbuff
  LEA $10(A2),A5
  TST.b $F(A2)
  BNE.w 'skipo
    MOVEA.l (A5),A5                                          ;pointer to real text
 'skipo
  CLR.w asmtype
  CMP.b #".",(a5)
  BNE.s 'skipo_l10
    MOVE.l a2,-(a7)
    ADDQ.l #1,a5
    LEA newtypebase,a2
    BSR getparameter2
    BEQ.w syntaxerr
    BSR findtype
    BNE.w notypeerr
    LEA $4(a2),a2
    BSR getparameter2
    BEQ.w syntaxerr

    BSR.w findvariable2
    BNE.w notypeerr
    MOVE.w $4(a2),d3
    EXT.l d3
    BRA 'skipo_l30b
 'skipo_l10
    CMP.b #"\",(a5)
    BNE 'skipo_l20
    ADDQ.l #1,a5
    MOVE.l a2,-(a7)
    MOVE.l a5,a4
    LEA usedpath,a5
    CMP.b #"*",(a5)
    BNE 'skipo_lm1
      ADDQ.l #1,a5
   'skipo_lm1
    BSR.w getparameter2
    BEQ.w syntaxerr
    LEA varbase,A2
    MOVE.b #1,newvariable
    BSR.w findvariable
    CLR.b newvariable
    CMP.l #-1,d0
    BEQ.w notypeerr
    MOVE.l a4,a5
    MOVE.l $a(a2),a2
    LEA $4(a2),a2
    BSR getparameter2
    BEQ.w syntaxerr
    BSR.w findvariable2
    BNE.w notypeerr
    MOVE.w $4(A2),D3
    EXT.l D3
 'skipo_l30b
   CMP.b #"[",-1(a5)
   BNE 'skipo_l30c
     MOVEQ #0,d0
     MOVE.b (a5)+,d0
     MOVE.l d3,-(a7)
     MOVEQ #0,d3
     JSR atoi           ; get current character in d0, returns number in d3, frac10 in d5
     MOVE.l (a7)+,d1
     MOVE.l $a(a2),a2
     MOVE.w 8(a2),d0
     MULS d0,d3
     ADD.l d1,d3
  'skipo_l30c
   MOVE.l (a7)+,a2
   BRA 'oko

 'skipo_l20
  CMP.w #$c,$8(a2)
  BEQ 'skipo_lf1

    CMP.w #$d,$8(a2)
    BEQ 'skipo_lf1

 'skipo_lf2
  JSR evalconst3

 'skipo_l30
  MOVEA.l asmbuff,A2
  BEQ.w 'oko
  CMP.w #$28,D0
  BEQ.w 'oko
  CMP.w #$2C,D0
  BEQ.w 'oko
  BRA.w syntaxerr

 'skipo_lf1
  MOVE.b #1,iee
  BRA 'skipo_lf2

 'oko
  MOVEA.l $4(A2),A1

  MOVE.w $8(A2),D1                                         ;labelmode
  CMP.w #$5,D1
   BNE.w 'notdan

 'word
   BSR.w chkword                                           ;word

 'word2
  MOVE.w D3,(A1)
  BRA.w 'next

 'notdan
  CMP.w #$6,D1
  BNE.w 'notdanxi

 'isbyte
   BSR.w chkbyte                                           ;byte

 'isbyte2
  MOVE.b D3,$1(A1)
 BRA.w 'next

 'notdanxi
  CMP.w #$11,D1                                           ;byte
  BEQ.w 'isbyte2
  CMP.w #$c,d1
  BEQ 'single1
  CMP.w #$d,d1
  BEQ 'double1
  CMP.w #$7,D1
  BEQ.w 'word                                             ;word
  CMP.w #$8,D1
  BNE.w 'notabsl

 'isabsl
  MOVE.w asmtype,D1                                        ;long
  BEQ.w 'notpcrel
  BSR.w asmoff

 'notpcrel
  MOVE.l D3,(A1)
  BRA.w 'next

 'single1
  fmove.s fp0,0(a1)
  BRA.w 'next

 'double1
  fmove.d fp0,0(a1)
  BRA.w 'next

 'notabsl
  CMP.w #$9,D1
  BNE.w 'notdpc
  SUB.l A1,D3                                              ;branchword
  BSR.w chkword
  MOVE.w D3,(A1)
  BRA.w 'next

 'notdpc
  CMP.w #$A,D1
   BNE.w 'imm
  SUB.l A1,D3                                              ;branchbyte
  BRA.w 'isbyte

 'imm
  CMP.w #$11,d1
  BLE 'imm_org
    MOVE.l a3,-(a7)
    LEA pluginbase,a3
    MOVE.l 8(a2),a0
    JSR (a0)                                                 ;hook
    MOVE.l (a7)+,a3
    BRA 'next
 'imm_org

  MOVE.w $A(A2),D0
   BEQ.w 'noflag
  CMP.w #$1,D0
   BEQ.w 'tocount
  CMP.w #$3,D0
   BEQ.w 'tomoveq
  CMP.w #$4,D0
   BEQ.w 'totrap

 'noflag
  CMP.w #$B,D1                                             ;long
   BEQ.w 'isabsl
  BRA 'word2                                                ;word

 'totrap
  CMP.l #$F,D3
   BHI.w illtraperr
  OR.b D3,-(A1)
  BRA.w 'next

 'tocount
  CMP.l #$8,D3
   BHI.w illimmerr
  TST.l D3
   BEQ.w illimmerr
  ANDI.w #$7,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,-(A1)
  BRA.w 'next

 'tomoveq
  BSR.w chkbyte
  MOVE.b D3,-(A1)

 'next
  MOVEA.l (A2),A2
  BRA.w 'loop

 'done2
  CLR.w constmode

 'done
  CLR.b curtemplabel
RTS


doea:
    ;d2=reg, d3=ea, d4=extraword, d5=asm type
    ;d6=allowable mask, d7=shift data
    ;
    ;or in bits for opcode in d1
    ;
  BTST D3,D6
  BEQ.w illeaerr

  BSR.w makemode
  CMP.w #$7,D3
  BCS.w 'skip
    MOVE.w D3,D2
    SUBQ.w #7,D2
    CMP.w #$5,D2
    BCS.w 'skip0
      MOVEQ.l #$04,D2
   'skip0
    MOVEQ.l #$07,D3
 'skip

  MOVE.b D7,D0
  ANDI.w #$F,D0
  CMP.w #$F,D0
  BEQ.w 'skip2
    LSL.w D0,D3
    OR.w D3,D1
 'skip2

  LSR.w #4,D7
  ANDI.w #$F,D7
  CMP.w #$F,D7
  BEQ.w 'skip3
    LSL.w D7,D2
    OR.w D2,D1
 'skip3
RTS


chkbyte:
  CMP.l #$7F,D3
   BGT.w illdiserr
  CMP.l #$FFFFFF80,D3                                      ;#-128,d3 org source
   BLT.w illdiserr
RTS


chkword:
  CMP.l #$7fff,D3
   BGT.w illdiserr
  CMP.l #$FFFF8000,D3                                      ;#-32768,d3 org source
   BLT.w illdiserr
RTS


findchar                                                   ;??Looks like double label??
 'll20
    MOVE.b (a5)+,d0
    CMP.b d1,d0
    BEQ 'll10
      TST.b d0
  BNE 'll20

 'll10
  SUBQ #1,a5
RTS


findnext                                                   ;??looks like double label??
 'll20
  MOVE.b (a5)+,d0
  CMP.b #",",d0
  BEQ 'll10
    CMP.b #";",d0
    BEQ 'll10
      CMP.b #":",d0
      BEQ 'll10
  ;cmp.b #"(",d0
  ;beq 'll10
  TST.b d0
  BNE 'll20

 'll10
  SUBQ #1,a5
RTS


macroexecute
  ADD.l a2,d1
  LEA tempspace,a1
  MOVE.l d1,a0

 'l10
  MOVE.b (a0)+,(a1)+
  BNE.s 'l10
  SUBQ.l #1,a0
  SUBQ.l #1,a1

 'l20
  MOVE.b (a5)+,(a1)+
  BNE.s 'l20
  CLR.b (a1)
  LEA tempspace,a5
RTS


calc
  MOVEM.l D1-D2/A0,-(A7)
  MOVE.l d0,d2
  MOVEQ #0,d1
  MOVE.l a5,a4

 'll20
  ADDQ.l #1,d1
  MOVE.b (a5)+,d0
  CMP.b #",",d0
  BEQ 'll10
  CMP.b #";",d0
  BEQ 'll10
  CMP.b #":",d0
  BEQ 'll10
  CMP.b #"(",d0
  BEQ 'll10
  TST.b d0
  BNE 'll20

 'll10
  SUBQ #1,a5
  CMP.b #"'",(a4)
  BEQ 'llocal

  TST.w inmacro
  BNE 'lmacro

  MOVEQ.l #$14+4,D0
  ADD.l d1,d0

  MOVE.l d1,-(a7)
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
  MOVE.l (a7)+,d1
  TST.l d0
  BEQ out_of_memory

  MOVEA.l D0,A0
  ;MOVE.w linenumat+2,$C(A0)
  MOVE.w linenumat+2,$A(A0)
  ;MOVE.w linenumat,$c(a0)
  MOVE.l templabel,(A0)
  MOVE.l A0,templabel
  MOVE.l destpointer,$4(A0)
  MOVE.l d2,$8(A0)
  LEA $E(A0),A0
  MOVE.b #$14,(A0)+
  CLR.b (a0)+
  ;MOVE.l A4,(A0)+
  MOVE.l a0,d2
  ADDQ.l #4,d2
  MOVE.l d2,(a0)+

 'lc1
  MOVE.b (a4)+,(a0)+
  SUBQ.l #1,d1
  BNE 'lc1
  CLR.b (a0)+
  MOVE.w linenumat,(a0)
  MOVEM.l (A7)+,D1-D2/A0
 RTS

 'lmacro
  MOVEQ.l #$10+2,D0
  ADD.l d1,d0
  MOVEM.l a4/d3,-(a7)
  MOVE.l d1,d3
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
   ;jsr do_AllocMem                                          ;allocmemforcompile
  TST.l d0
  BEQ out_of_memory
  MOVEA.l D0,A0

 'o2
  MOVE.w linenumat+2,$C(A0)
  MOVE.l templabel,(A0)
  MOVE.l A0,templabel
  MOVE.l destpointer,$4(A0)
  MOVE.l d2,$8(A0)
  LEA $E(A0),A0
  MOVE.b d3,(A0)+
  ADD.b #$10,-1(a0)
  MOVE.b #$1,(a0)+
  SUBQ.w #1,d3

 'lm2
  MOVE.b (a4)+,(a0)+
  SUBQ.l #1,d3
  BNE.s 'lm2
  CLR.b (a0)+
  MOVE.w linenumat,(a0)
  MOVEM.l (a7)+,d3/a4
  MOVEM.l (A7)+,D1-D2/A0
 RTS

 'llocal
  LEA lastgloballabel,a1

 'll11
  ADDQ.l #1,d1
  TST.b (a1)+
  BNE.s 'll11
  MOVEQ.l #$10+2,D0
  ADD.l d1,d0
  MOVEM.l a4/d3,-(a7)
  MOVE.l d1,d3
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
   ;jsr do_AllocMem                                          ;allocmemforcompile
  TST.l d0
  BEQ out_of_memory
  MOVEA.l D0,A0

 'o3
  MOVE.w linenumat+2,$C(A0)
  MOVE.l templabel,(A0)
  MOVE.l A0,templabel
  MOVE.l destpointer,$4(A0)
  MOVE.l d2,$8(A0)
  LEA $E(A0),A0
  MOVE.b d3,(A0)+
  ADD.b #$10,-1(a0)
  MOVE.b #$1,(a0)+
  SUBQ.w #1,d3
  LEA lastgloballabel,a1

 'lm3
  SUBQ.l #1,d3
  MOVE.b (a1)+,(a0)+
  BNE.s 'lm3
  SUBQ.l #1,a0

 'lm1
  MOVE.b (a4)+,(a0)+
  SUBQ.l #1,d3
  BNE.s 'lm1
  CLR.b (a0)+
  MOVE.w linenumat,(a0)
  MOVEM.l (a7)+,d3/a4
  MOVEM.l (A7)+,D1-D2/A0
RTS


.out_of_memory
  !basic
  error{!TRANS{"No memory available!!!\\nAB3 will terminate due to low memory!"}}
  loop Delay_ 1
Goto loop


insasm:                                                    ;ass asmbuff, asmlen, pc, ea to list
  MOVEM.l D0-D2/A0,-(A7)
  MOVE.w $E(A0),-(A7)
   BPL.w 'ok
  CLR.w (A7)

 'ok
  MOVE.l A1,-(A7)
  MOVEQ.l #$10+2,D0
  ADD.w asmlen,D0
  MOVE.w D0,D2
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
   ;jsr do_AllocMem                                          ;allocmemforcompile
  MOVEA.l D0,A0

 ;'o                                                         ;??Looks like label not used??
  MOVE.w linenumat+2,$C(A0)
  MOVE.l templabel,(A0)
  MOVE.l A0,templabel
  MOVE.l (A7),$4(A0)
  MOVE.w d3,$8(A0)
  MOVE.w $4(A7),$A(A0)
  LEA $E(A0),A0
  MOVE.b D2,(A0)+                                           ;length
  MOVEA.l asmbuff,A1
  ADDQ.w #1,A1
  MOVE.b (A1)+,(A0)+                                        ;type - 0 = indirect,else direct
   BNE.w 'loop
  MOVE.l (A1)+,(A0)+
  MOVE.w linenumat,(a0)
 BRA.w 'loopdone

 'loop
   MOVE.b (A1)+,(A0)+
   BNE.w 'loop
   MOVE.w linenumat,(a0)

 'loopdone
  MOVEA.l (A7)+,A1
  ADDQ.w #2,A7
  MOVEM.l (A7)+,D0-D2/A0
RTS


makemode:
  CMP.w #$5,D3
   BCS.w 'done
  CMP.w #$B,D3
   BHI.w 'done2
   BEQ.w 'imm
   BSR.w insasm
  CMP.w #$5,D3
   BEQ.w 'word
  CMP.w #$6,D3
   BEQ.w 'dxi
  CMP.w #$7,D3
   BEQ.w 'word
  CMP.w #$8,D3
   BEQ.w 'long
  CMP.w #$9,D3
   BEQ.w 'word
   ;d(pc,xi)

 'dxi
  CMPA.l destbufferend,A1
   BCS.w 'ok7
  ADDQ.w #2,A1
 RTS

 'ok7
  MOVE.w D4,(A1)+
 RTS

 'imm
  CMPI.w #$8,asmsize
   BCC.w 'immlong
  MOVEQ.l #$10,D3
   BSR.w insasm
  MOVEQ.l #$0B,D3
 BRA.w 'word

 'immlong
  BSR.w insasm

 'long
  ADDQ.w #2,A1

 'word
  ADDQ.w #2,A1
 RTS

 'done2
  CMP.w #$F,D3
   BNE.w 'done
  CMPA.l destbufferend,A1
   BCS.w 'ok3
  ADDQ.w #2,A1
  ADDQ.w #4,A7
 RTS

 'ok3
  MOVE.w D2,(A1)+
  ADDQ.w #4,A7

 'done
RTS


countpees:
  ;count up how many parameters are following
  ;nest a-la {,(,},)
  ;
  ;return how many parameters in d1
  ;
  BSR.w storeloc
  ; new >
  MOVE.l linenumat,oldline
  ; < new
  MOVEQ.l #$00,D1
   BSR.w get1bytemain    ;eol?
   BEQ.w 'done
  MOVEQ.l #$00,D3
 BRA.w 'skiphelp

 'loop
   BSR.w get1bytemain
   BNE.w 'skip
  ; new >
 'ready
  ; < new
  TST.w D3
   BNE.w brackets_                                         ;syntax error brackets
 BRA.w 'done2

 'skip
   MOVE.w instringon,D4
   ;BNE.w 'loop
  ; new >
    BEQ 'skiphelp

 'l1
    MOVEQ #0,d0
     MOVE.b (a5)+,d0                                       ;fix "ue"
     MOVE.w d0,lastchar
     BEQ 'ready
     CMP.b #$22,d0
     BNE 'l1
     NOT.w instringon
 BRA 'loop
  ; < new

 'skiphelp
  ; new >
           CMP.b #"@",d0                                   ;expand line @@ 1. for parameter
           BNE 'l10
           CMP.b #"@",(a5)
           BNE 'l10

 'l111
           TST.w ininclude
           BNE 'inc
           MOVE.l sourceline3,a5
           CMP.l #0,a5
           BNE 'l11t
           MOVEA.l sourceline,A5

 'l11t
           MOVEA.l (A5),A5
           CMP.l #0,a5
           BEQ 'done2
           MOVE.l a5,sourceline3
           LEA $9(A5),A5
  BRA 'l11

 'inc
           ADDQ.l #1,a5
           TST.b (a5)
           BNE 'inc
           ;BEQ illeolerr

 'l11
           ADDQ.l #1,a5
           TST.b (a5)
           BEQ illeolerr
           MOVE.l a5,-(a7)

 'l110
      CMP.b #" ",(a5)+
      BEQ 'l110
       CMP.b #";",-1(a5)
       MOVE.l (a7)+,a5
       BEQ 'l111
  BRA 'loop

 'l10
  ; < new
   CMP.w #$29,D0      ;')'
   BNE.w 'skip2
  TST.w D3
   BEQ.w 'done2

 'skip3
  SUBQ.w #1,D3
 BRA.w 'loop

 'skip2
   CMP.w #$7D,D0      ;'}'
   BEQ.w 'skip3
  CMP.w #$28,D0       ;'('
   BNE.w 'skip4a

 'skip4
   ADDQ.w #1,D3
 BRA.w 'loop

 'skip4a
  CMP.w #$7B,D0        ;'{'
   BEQ.w 'skip4
  CMP.w #$2C,D0        ;','
   BNE.w 'loop
  TST.w D3
   BNE.w 'loop
  ADDQ.w #1,D1
 BRA.w 'loop

 'done2
  ADDQ.w #1,D1

 'done
  ; new >
  CLR.l sourceline3
  MOVE.l oldline,linenumat
  ; < new
BRA.w resloc


fetchlibps:                                 ;blitzlib parameter compile get parameter here (can recursive call )
  ; fetch library parameters....
  ;
  ; d1 = number. lo byte = # parameters
  ; hi byte and 7= number of repeatables
  ; (eg:- Line 0,0,319,0,319,199,0,199,0,0 ,3)
  ; hi byte and $78 lsr 3 = pos of first repeat
  ;
  ; a2 = start of types table.....
  ;
  CLR.w numreps
  MOVE.w D1,D0
  ANDI.w #$FF00,D0
  BEQ.w 'noreps
  LSR.w #8,D0
  LSR.w #4,D0           ;d0= start of reps
  BEQ.w 'skip
  SUB.b D0,D1           ;new number to fetch
  ; new >
   MOVE.w regnum,regnumfunc
   MOVE.b funcparloop,-(a7)
   MOVE.b #0,funcparloop
   MOVE.l leftsidetype,-(a7)
   MOVE.l rightsidetype,-(a7)
   MOVE.w leftsideflagmask,-(a7)
   MOVE.w rightsideflagmask,-(a7)
   CLR.l leftsidetype
   CLR.l rightsidetype
   CLR.w leftsideflagmask
   CLR.w rightsideflagmask
   MOVE.b blitzparloop,-(a7)
   MOVE.b #1,blitzparloop
  ; < new
   BSR.w fetchpees2      ;fetch first parms
  ; new >
   MOVE.b (a7)+,blitzparloop
   MOVE.w (a7)+,rightsideflagmask
   MOVE.w (a7)+,leftsideflagmask
   MOVE.l (a7)+,rightsidetype
   MOVE.l (a7)+,leftsidetype
   MOVE.b (a7)+,funcparloop
  ; < new
  CMP.w #$2C,D0          ;','
   BNE.w syntaxerr

 'skip
  ;O.K., now to fetch repeats.....
  ;
  MOVE.w D1,D2
  LSR.w #8,D2
  ANDI.w #$7,D2         ;# repeatable....

 'rloop                                               ;blitzlib parameter compile loop (can call recursive)
   CMP.b D2,D1
   BCS.w 'repsdone      ;all reps done....
  SUB.b D2,D1
  MOVEM.l D2/A2,-(A7)
  MOVE.w D2,D0
  ; new >
  MOVE.b funcparloop,-(a7)
  MOVE.b #0,funcparloop
  MOVE.l leftsidetype,-(a7)
  MOVE.l rightsidetype,-(a7)
  MOVE.w leftsideflagmask,-(a7)
  MOVE.w rightsideflagmask,-(a7)
  CLR.l leftsidetype
  CLR.l rightsidetype
  CLR.w leftsideflagmask
  CLR.w rightsideflagmask
  MOVE.b blitzparloop,-(a7)
  MOVE.b #1,blitzparloop
  ; < new
  BSR.w fetchpees4
  ; new >
  MOVE.b (a7)+,blitzparloop
  MOVE.w (a7)+,rightsideflagmask
  MOVE.w (a7)+,leftsideflagmask
  MOVE.l (a7)+,rightsidetype
  MOVE.l (a7)+,leftsidetype
  MOVE.b (a7)+,funcparloop
  ; < new
  MOVEM.l (A7)+,D2/A2
  ADDQ.w #1,numreps
 BRA.w 'rloop

 'repsdone
   MOVE.w numreps,D3
   BEQ.w syntaxerr
  ADDA.w D2,A2
  ANDI.w #$FF,D1
   BEQ.w 'done
;  ;
;  ;handle 'else' for repeating parameters...
;  ;
;  cmp #$8000+34,d0
;  beq 'done
;  ;
  CMP.w #$2C,D0       ;','
   BNE.w syntaxerr

 'noreps
   MOVE.w D1,D0
   BNE.w 'fetchpees2b

 'done
 RTS

  ; new >
 'fetchpees2b                           ;blitzlib parameter compile  ( var = blitzfunc) call this to get Parameter (can call recursive)
  MOVE.b funcparloop,-(a7)
  MOVE.l leftsidetype,-(a7)
  MOVE.l rightsidetype,-(a7)
  MOVE.w leftsideflagmask,-(a7)
  MOVE.w rightsideflagmask,-(a7)

  CLR.l leftsidetype
  CLR.l rightsidetype
  CLR.w leftsideflagmask
  CLR.w rightsideflagmask
  MOVE.b #0,funcparloop
  MOVE.b blitzparloop,-(a7)
  MOVE.b #1,blitzparloop
  BSR.w fetchpees2

  MOVE.b (a7)+,blitzparloop
  MOVE.w (a7)+,rightsideflagmask
  MOVE.w (a7)+,leftsideflagmask
  MOVE.l (a7)+,rightsidetype
  MOVE.l (a7)+,leftsidetype
  MOVE.b (a7)+,funcparloop
RTS
  ; < new

;------                                                  ;disassembled code begin
ptype:    Dc.b $3F,$3C,$00,$00                             ;MOVE.W  #$0000,-(A7)
;------                                                  ;disassembled code end

partostack:  Ds.w 1                                        ;pmode org source

Even
fetchpees4:                                                ;always push
  MOVEQ.l #$01,D2
BRA.w fetchpees3

fetchpees2:                                               ;dont push unless told.
  MOVEQ.l #$00,D2

fetchpees3:
  ANDI.w #$F,D0

;fetchpees:
  ; fetch a list of parameters.
  ;
  ; D0 = number to fetch,
  ; A2 = Pointer To Type Buffer
  ; D1 = push mode
  ;
  CLR.w parnum
  MOVE.w D1,-(A7)
  MOVE.w partostack(PC),-(A7)                              ;in case of recursion
  MOVE.w D2,partostack
  MOVE.w D0,-(A7)
  CMP.w #"@@",(a5)                                        
  BNE 'loop
    TST.w ininclude                                        ;merge macrolines
    BNE errorjoin
    MOVEA.l sourceline,A5
    MOVEA.l (A5),A5
    MOVE.l a5,sourceline
    LEA $9(A5),A5
    ADDQ.l #1,linenumat
 'loop

  MOVE.b (A2)+,D2                                          ;parameterloop   d2=vartype
  BNE.w 'skip0
    MOVE.w userp,D2                                          ;user selected type
 'skip0

  MOVE.l A2,-(A7)
  ADDQ.w #1,parnum
  TST.b funccall
  BEQ 'skip0_l1
  CMP.w #6,parnum
  BLE 'skip0_l1
  CMP.w #7,d2

CNIF #more6string=0
  BEQ more6par
CEND

 'skip0_l1
  TST.b fpu
  BEQ 'skip0_old
  TST.w regnumfunc
  BEQ 'skip0_old
  CMP.w #$48e7,-4(a4)
  BNE 'skip0_old
  MOVEQ #0,d1
  MOVE.w regnum,d1
  CMP regnumfunc,d1                                       ;fpu reg function save
  BGE 'skip0_old
  ASL.w #7,d1
  MOVE.l d0,-(a7)
  MOVE.w regnumfunc,d0
  CLR.w regmask

 'skip0_loop
  BSET d0,regmask
  SUBQ #1,d0
  BNE 'skip0_loop
  MOVEQ #0,d0
 'skip0_loop2
  BTST d0,regmask
  BEQ 'skip0_noa7
  MOVEQ #0,d1
  MOVE.w d0,d1
  SUBQ.w #1,d1
  ASL #7,d1
  OR.l #$f2277400,d1                                   ;fmove.d
 ;OR.l #$f2276400,d1                                   ;fmove.s
  BSR writelong

  ADDQ.l #2,stacktrack
  MOVE.l stacktrack,d1
  CMP.l #180,d1
  BGT conmemerr                                        ;formula too complex

  MOVE.l a0,-(a7)
  LEA fpustackbase,a0
  MOVE.w regmask,0(a0,d1)
  MOVE.l (a7)+,a0
 'skip0_noa7
  ADDQ.w #1,d0
  CMP.w regnumfunc,d0
  BLE 'skip0_loop2

 'skip0_ready
  MOVE.l (a7)+,d0

 'skip0_old
  MOVE.l currentfunccall,-(a7)
  MOVE.w parnum,-(a7)
  TST.l rightsidetype
  BSR.w handlep
  MOVE.w (a7)+,parnum
;  CLR.b funcparloop
  MOVE.l (a7)+,currentfunccall

CNIF #function_typecheck
  TST.b typecheck                            ;typecheck for function call
  BEQ 'notypecheck

  TST.b notypecheck
  BNE 'notypecheck

  TST.b blitzparloop
  BNE 'isblitzlibcall                                    ;no typecheck for blitzlibs currently

  CMP.l #0,currentfunccall
  BEQ 'isblitzlibcall

  MOVEM.l a0/a1,-(a7)
  MOVE.l currentfunccall,a0
  MOVE.w parnum,d1

  TST.b isconstantvalue
  BEQ 'noconstant
    CMP.l #0,lastconstantvalue
    BEQ 'isnull
 'noconstant

  MOVE.l funcstruct_parametertype-4(a0,d1*4),a0
  CMP.l #0,a0
  BEQ 'notype
  CMP.l #$100,4(a0)
  BLE 'notype
  MOVE.l lasttoken,d1
  CMP.w ##TokenID_Null,d1                   ;$b581 ok, when token for null
  BEQ 'isnull
  TST.l typetocast
  BEQ 'nocast
  MOVE.l typetocast,a1
  BRA 'typecheck

 'nocast
  MOVE.l rightsidetype,a1
  CMP.l #0,a1
  BEQ 'notype

 'typecheck
  CMP.l #$100,4(a1)
  ;BLE 'ok                                ; deactivate if long for Parameter is not allowed
  CMP.l a0,a1
  BEQ 'ok
                                          ; check if type is parent for function call
  CMP.l #$100,4(a1)                       ; is a type here
  BLE 'error

  MOVE.l 4(a1),a1                         ; load the address of type.
  CMP.l $a(a1),a0                         ; check if the bigger type contain in first place same type as the function need
  BEQ 'ok

 'error
  JMP error_convert_types                 ; for syntax 4

 'ok
 'notype
 'isnull
  CLR.l typetocast
  MOVEM.l (a7)+,a0/a1

 'isblitzlibcall
 'notypecheck
CEND

  CLR.l lastfunction

  TST.b fpu
  BEQ 'skip0_noprint

  MOVE.l (a7),a2
  ADDQ.l #1,a2
  CMP.b #5,d2
  BNE 'skip0_noprint

  CMP.b #$5d,24(a2)
  BNE 'skip0_noprint

  CMP.b #$81,25(a2)
  BLT 'skip0_noprint

  CMP.b #$86,25(a2)
  BEQ 'skip0_ok

  CMP.b #$87,25(a2)
  BEQ 'skip0_ok

  CMP.b #$88,25(a2)
  BEQ 'skip0_ok

  CMP.b #$83,25(a2)
  BGT 'skip0_noprint

 'skip0_ok
  MOVE.l destpointer,a4
  CMP.w #$2f00,-2(a4)
  BNE 'skip0_noprint

  SUBQ.l #2,destpointer
;  MOVE.w (a2),-(a7)                                        ;fpu print,nprint,str$
  MOVE.l #$f2277400,d1
  BSR writelong                                            ;fmove.d fp0,-(a7)
  ADDQ #4,a2offset
;  MOVE.w #$c0,(a2)
;  MOVE.l a2,-(a7)
;  JSR fetchregs
;  MOVE.l #$f2006400,d1                                     ;fmove.s fp0,d0
;  BSR writelong
;  MOVE.l #$4EAEFF94,d1                                     ;SPfieee
;  BSR writelong
;  MOVE.l (a7)+,a2
;   MOVE.w (a7)+,(a2)
  ;CMP.b #$83,25(a2)
  ;BEQ 'skip0_nomovea7
  ;MOVE.w #$2e80,d1
  ;BSR writeword
; 'skip0_nomovea7

 'skip0_noprint
  CLR.b optistring
  MOVEA.l (A7)+,A2
  CMP.w #"@",d0
  BNE 'skip0_l10

  CMP.b #"@",(a5)
  BNE 'skip0_l10

  TST.w ininclude
  BNE errorjoin

  MOVEA.l sourceline,A5
  MOVEA.l (A5),A5
  MOVE.l a5,sourceline
  ADDQ.l #1,linenumat
  LEA $9(A5),A5
  MOVEQ #0,d0
  BSR get1bytemain

 'skip0_l10
  CMP.b #32,(a5)+ ;for space after a ,
  BEQ 'skip0_l10:

  SUBQ.l #1,a5
  CMP.w #"@@",(a5)                                        ;if merge
  BNE 'skip0_l15
  MOVEM.l d0-d7/a0-a4/a6,-(a7)
  JSR mergeline
  MOVEM.l (a7)+,d0-d7/a0-a4/a6

; 'skip0_l111
;           MOVEA.l sourceline,A5
;           MOVEA.l (A5),A5
;           MOVE.l a5,sourceline
;  ADDQ.l #1,linenumat
;           LEA $9(A5),A5
;           TST.b (a5)
;           BEQ 'skip0_l111
;           MOVE.l a5,-(a7)

; 'skip0_l110
;   CMP.b #" ",(a5)+
;   BEQ 'skip0_l110
;   CMP.b #";",-1(a5)
;   MOVE.l (a7)+,a5
;   BEQ 'skip0_l111

 'skip0_l15
  SUBQ.w #1,(A7)
  BEQ.w 'done
  CMP.w #$2C,D0       ; 44 "," ... auf Komma checken
  ;BNE.w notparerr                                         ;not enough parameter
  BNE 'overloadfunc
  BRA.w 'loop

 'done
  ADDQ.w #2,A7
  MOVE.w (A7)+,partostack
  MOVE.w (A7)+,D1
  CLR.b isconstantvalue
  MOVE.l currentfunccall,lastfunction
  CLR.b funccall
  CLR.l currentfunccall
  RTS

 'overloadfunc
  CLR.b funccall
  MOVE.w regnum,d1
  MOVE.l currentfunccall,a4
  CMP.b $20(a4),d1                                         ;increase if more pars
  BLT notparerr                                           ; NO REFERENCE!!

 'ol2
  MOVE.b (a2)+,d2
  ADD.w #1,parnum

  TST.b fpu
  BEQ 'nofpu

  CMP.b #5,d2
  BNE 'nofpu

  MOVEQ #0,d1
  MOVE.w regnum,d1
  CMP.w #6,regnum
  BLT 'nostack2

CNIF #more6string=0
  CMP.l #$b,parnumtemp
  BGE more6par
CEND

  MOVE.w #$2c3c,d1
  BSR writeword

  MOVE.l #$bf800000,d1
  BSR writelong

  MOVE.w #$c4ff,d1                                         ;savetemp+regnum
  ADD.w parnum,d1
  JSR Atokejsr

  TST.w dontwrite_nomemleft
  BNE 'l1

  MOVE.l data1start,d1
  MOVE.l destpointer,a4
  ADD.l d1,-4(a4)
  MOVE.l destpointer,d1
  SUBQ.l #4,d1
  SUB.l destbufferstart,d1
  MOVE.l d2,-(a7)
  MOVE.l d1,d2
  JSR addhunkoffset
  MOVE.l (a7)+,d2
  BRA 'l1

 'nostack2
  ASL.l #7,d1
  OR.l #$F23C5000,d1                                       ;fmove.w #-1,fpx
  BSR writelong
  MOVEQ #-1,d1                                             ;-1
  BSR writeword
  BRA 'l1

 'nofpu
  MOVE.w regnum,d1
  CMP.w #6,regnum
  BLT 'nostack
CNIF #more6string=0
  CMP.l #$b,parnumtemp
  BGE more6par
CEND
  CMP.b #2,d2
  BGT 'nw
  BRA 'nos

 ; ADDQ #2,a2offset
 ; MOVE.l #$3f3cffff,d1
 ; BSR writelong
 ;BRA 'l1

 'nw
  ;ADDQ #4,a2offset
  CMP.w #7,d2
  BNE 'nos
  ADDQ #4,a2offset

CNIF #more6string
    MOVE.l #$48780000,d1
    BSR writelong
    ADDQ.w #4,a2offset
    MOVE.w #$2f3c,d1
    BSR writeword
    MOVE.l #-1,d1
    BSR writelong
    BRA 'l1
CEND
 'nos

  CMP.b #4,d2
  BNE 'noq
    MOVE.w #$2c3c,d1
    BSR writeword
    MOVE.l #$ffff0000,d1
    BSR writelong
    BRA 'noq2
 'noq

  CMP.b #5,d2
  BNE 'nof
    MOVE.w #$2c3c,d1
    BSR writeword
    MOVE.l #$800000c1,d1
    BSR writelong
    BRA 'noq2
 'nof

  MOVE.w #$7cff,d1
  BSR writeword

 'noq2
  MOVE.w #$c4ff,d1                                         ;savetemp+regnum
  ADD.w parnum,d1
  JSR Atokejsr
  TST.w dontwrite_nomemleft
  BNE 'l1
  MOVE.l data1start,d1
  MOVE.l destpointer,a4
  ADD.l d1,-4(a4)
  MOVE.l destpointer,d1
  SUBQ.l #4,d1
  SUB.l destbufferstart,d1
  MOVE.l d2,-(a7)
  MOVE.l d1,d2
  JSR addhunkoffset
  MOVE.l (a7)+,d2
  BRA 'l1

 'nostack
  ASL.l #8,d1
  ASL.l #1,d1
  OR.l #$203c,d1                                           ;-1
  BSR writeword

  MOVE.l #-1,d1
  CMP.b #4,d2
  BNE 'nq1
    MOVE.l #$ffff0000,d1
 'nq1

  CMP.b #5,d2
  BNE 'nof2
  TST.b fpu
  BNE 'nof2
    MOVE.l #$800000c1,d1
 'nof2

  BSR writelong
  CMP.b #7,d2
  BNE 'l1
    CNIF #more6string
    MOVE.l #$48780000,d1
    BSR writelong
    CEND
    ADDQ.w #4,a2offset                                      ; bug fix for string parameters
    MOVE.l #$594f,d1                                        ; subq #4,a7
    BSR writeword
 'l1
  SUBQ.w #1,(A7)
  BEQ.w 'done
  ADDQ.w #1,regnum
  BRA 'ol2


handlep:
  ;d2=what to get. various flags are as follows:
  ;
  ;BIT 7 : The Address of a var - d2.b = type of var
  ;BIT 6 : We want to push any results that
  ;   would normally go into D(regat).
  ;   this should apply to all others too.
  ;
  ;BIT 5 : We want array info.
  ;
   MOVE.w D2,D1
   ANDI.w #$40,D1          ;push bit
   MOVE.b D1,partostack
   TST.b D2
    BMI.w handlevara
   BTST #$5,D2
    BNE.w handlearr
  ;
  ;normal p get
  ;
  ; new >
    MOVE.w regnumstore,-(a7)
    MOVE.w tempregnum,-(a7)
    MOVE.w parnum,-(a7)
  ; < new
    BSR.w getap                                        ;recursive entry
  ; new >
    MOVE.w (a7)+,parnum
    MOVE.w (a7)+,tempregnum
    MOVE.w (a7)+,regnumstore
  ; < new

putap:
  ;push D(regat), type in d2.
  ;
    MOVE.w partostack(PC),D1
    BEQ.w putapincreg

pushap:
   ;push D(regat), type in d2.
   ADDQ.w #4,a2offset

   MOVE.w pushdn,D1
   OR.w regnum,D1      ;push long
   CMP.w #$3,D2
    BCC.w 'skip
   SUBQ.w #2,a2offset
   ORI.w #$1000,D1    ;push word only
   BSR.w writeword
 RTS

 'skip
  ; new >
  CMP.b #7,d2
  BNE 'l10a
    CMP.b #2,optistring
    ;BEQ 'l20a                                                ;muicycle fix
 'l10a
  TST.b iee
  BEQ 'olda
    CMP.b #5,d2
    BNE 'olda
 'olda
  ; < new
  BSR.w writeword                                          ;write val to stack
  RTS

  ; new >
 'l20a
  SUBQ.w #4,a2offset
RTS
  ; < new


putapincreg:
  ADDQ.w #1,regnum
RTS


putalp:
  MOVEQ.l #$03,D2
BRA.w putap


handlevara:
  ;Here, we want the address of a var type d2
  ;
  ANDI.w #$7,D2
  MOVE.w D2,-(A7)
  ;
   JSR ampersand2  ;ignore pnt to $         ;bsr.w
  ;
  CMP.b #$7,D2                                             ;ignore pnt to $
   BEQ.w 'nop2
  ;
  BTST #$E,D2
   BEQ.w 'nop
  MOVE.b #$3,D2      ;pointer to long                                      ;pointer to long
 BRA.w 'nop2

 'nop
   TST.b D2
   BNE.w 'nop2
  MOVE.b #$3,D2

 'nop2:
  MOVE.w (A7)+,D3
  TST.b D3
   BEQ.w 'unp
  CMP.b D2,D3
   BEQ.w putalp
 BRA.w mismatcherr

 'unp
  ADDQ.w #2,a2offset
  MOVE.w ptype(PC),D1
   BSR.w writeword
  MOVEQ.l #$00,D1
  MOVE.b D2,D1
   BSR.w writeword
BRA.w putalp


handlearr:
   MOVE.w D2,-(A7)
   BSR.w baseadd
  BTST #$4,$1(A7)
   BEQ.w 'nohigh
   BSR.w highadd

 'nohigh
   BTST #$3,$1(A7)
   BEQ.w 'notype
   BSR.w sendtype

 'notype
   MOVE.w (A7)+,D2
BRA.w get1bytemain


sendtype:
  ;OK, type of array is gonna be put on stack
  ;
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$7000,D1
  BTST #$0,$7(A3)
   BNE.w 'isap         ;A Pointer
  CMPI.l #$100,$4(A2)
   BCC.w arrerr1       ;illegal type to send
  MOVE.b $7(A2),D1

 'putit
  BSR.w writeword      ;moveq #type,d regat
  MOVEQ.l #$02,D2      ;just a word.
BRA.w pushap

 'isap
  MOVE.b #$3,D1
BRA.w 'putit


baseadd:
  ;send base on stack or in reg
  ;
   BSR.w get1bytemain                                      ;write array paramter code
   BSR.w getparameter
  BTST #$1,flagmask+1
   BEQ.w syntaxerr
   BSR.w fetchvars
  ;
   BSR.w get1bytemain
  CMP.w #$29,D0          ;')'  ;we just want a() or whatever                                 ;we just want a() or whatever
   BNE.w syntaxerr
  MOVE.w notshared,D1
   BNE.w noarrayerr
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w fbase(PC),D1
  ; new >
   TST.b varmode
   BEQ 'l1
   BCLR #0,d1

 'l1
  ; < new
   BSR.w writeword
  MOVE.w $4(A3),D1
   BSR.w writeword
BRA.w putalp      ;OK, we've got da base reg.


highadd:
  ;send high end of array on stack
  ;
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w fbase(PC),D1
  ; new >
   TST.b varmode
   BEQ 'l1
   BCLR #0,d1

 'l1
  ; < new
   BSR.w writeword
  ;
  MOVE.w $8(A3),D1
  LSL.w #2,D1
  MOVE.w varmode,D2
   BEQ.w 'isglob
  NEG.w D1

 'isglob
   ADD.w $4(A3),D1
   BSR.w writeword
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ;
  MOVE.w partostack(PC),D2
   BNE.w 'dopadd           ;we just pushed last parameter!
  CMPI.w #$7,regnum
   BCC.w 'dopadd           ;last was d6, it must have been
            ;pushed too.
  OR.w pushlast(PC),D1
  MOVE.w regnum,D2
  SUBQ.w #1,D2
  OR.w D2,D1
 BRA.w 'pp

 'dopadd
  ;last one was pushed. we have to add to stack!
  ;
  OR.w pushadd(PC),D1

 'pp
  BSR.w writeword
  MOVE.b #$1,partostack
BRA.w putalp


;------                                                  ;disassembled code begin
fbase:       Dc.b $20,$2D,$00,$00                           ;MOVE.L  $0000(A5),D0
pushadd:     Dc.b $D0,$97                                   ;ADD.L (A7),D0
pushlast:    Dc.b $D0,$80                                   ;ADD.L D0,D0
;------                                                  ;disassembled code end

Even
getap:
  ANDI.w #$7,D2                                            ;0-7 (unknown to string)
   BEQ.w evalu2
BRA.w eval


resetlibs:
  MOVEA.l libpointer,A1

 'loop
    CMPA.w #$0,A1
    BEQ.w 'done
      MOVE.w #-1,$A(A1)
      BCLR #$7,$C(A1)
      MOVEA.l (A1),A1
   BRA.w 'loop
 'done
RTS


usevars:                                                  ; was uselib2 in new source renamed to org name
                                                          ; because of the org source routine label uselib2
  MOVE.w #$FFFE,D1       ;#allocvars

uselib:                                                   ;lib number in d1 - turn it on baby!
  BSR.w findlib



uselib3:
  TST.w cfetchmode
  BEQ.w 'noconst
    BTST #$6,$C(A1)
    BNE.w 'constok
      BRA.w badconerr                                            ;Can't use this Library!
   'constok
    RTS
 'noconst
  BSET #$7,$C(A1)
  BNE.w 'skip                                         ;already done....
    CMPI.w #-1,$A(A1)
    BNE.w 'skip                                         ;something already here
      ;
      ;o.k. - move in the lib!
      ;
      TST.w direct_mode
      BEQ.b 'oktouse
      ;
      ; new >
        TST.b exdebug
        BEQ 'l1
          BRA.b 'oktouse
       'l1
          ; < new
          BCLR #$7,$C(A1)
          BRA.w dirliberr
       'oktouse                                                ;addlibrary
        ; new >
        MOVE.b debugmode,-(a7)
        ;< new


        TST.b log_blitzlibs
        BEQ.b 'skiplog
          TST.w pass
          BNE.b 'skiplog
            TST.l funcscanon
            BNE.b 'skiplog
              !regs2stack
              !basic
              PutReg D1,libnum2.l

              If Peek.w(?ininclude) > 0
                codefile.s = dos_FilePart{incdim(Peek.w(?ininclude)-1)}
                codeline.l = Peek.l(?includeline)
              Else
                codefile.s = ""
                codeline.l = Peek.l(?linenumat)
              EndIf
              GetReg D0,libnum2
              GetReg D1,&codefile
              GetReg D2,codeline
              GetReg D3,Peek.l(?sourceline)
              GetReg A1,Peek.l(?lastsourcepos)
              !ComData_JSR{comFunc_LogPrint}
            !asm
            !stack2regs
       'skiplog:


        MOVEM.l D1/A0/A2,-(A7)
        ;
        ;is it a maximum type lib....
        ;if so, create a varoff for it's structs.....
        ;
        ; new >
        ;  BTST #$7,use_debugger
        ;  SNE d1
        ;  MOVE.b d1,debugmode

        BTST #$7,use_debugger
        BNE 'debugon
          CLR.w D1
          BRA.b 'debugoff
       'debugon
          SNE D1
       'debugoff 
        MOVE.b d1,debugmode
        ; !basic
        ;  logging{"debugmode in d1, state:" +Str$(Peek.w(?debugmode))}
        ; !asm
        ; < new
        MOVEA.l A1,A0
        ADDA.l $12(A1),A0
        TST.w -$2(A0)
        BEQ.w 'notmax
          MOVEM.l A0-A1,-(A7)
          MOVE.w #$FB4F,D1            ; #64335,
          BSR.w uselib
          MOVEM.l (A7)+,A0-A1
          ADDQ.w #1,globalvarpointer
          BCLR #$0,globalvarpointer+1
          MOVE.w globalvarpointer,-$6(A0)
          ADDQ.w #4,globalvarpointer
          TST.l -$E(A0)
          BEQ.w 'notmax
            ADDQ.w #4,globalvarpointer
       'notmax
        MOVE.l libend,$28(A1)      ;pc of lib
        MOVEA.l A1,A0
        ADDA.l $12(A1),A0          ;start of lib
        ;
        MOVE.l A1,D1
        ADD.l $6(A1),D1            ;end of lib
        TST.l $2C(A1)
        BEQ.w 'nor
          TST.b debugmode
          BNE.w 'nor                ;errs turned on
            MOVE.l A1,D1
            ADD.l $2C(A1),D1           ;copy only non-errchks
       'nor
        MOVEA.l libend,A2

       'loop
        CMPA.l data1start,A2
        BCS.w 'okp
          MOVE.w #$FFFF,dontwrite_nomemleft     ; -1
         'bad
            ADDQ.w #2,A0
            ADDQ.w #2,A2
            CMPA.l D1,A0
            BCS.w 'bad
              BRA.w 'toreloc
       'okp
        MOVE.w (A0)+,(A2)+                                       ;copylibcode
        CMPA.l D1,A0
        BCS.w 'loop

       'toreloc
        MOVE.l A2,libend
        MOVE.l $20(A1),D1
        BEQ.w 'noreloc
        ;
        MOVEM.l D0/D2-D3,-(A7)
        MOVEA.l $24(A1),A0         ;start of reloc table
        MOVEQ.l #$00,D3            ;no tokejsrs (yet!)

       'reloop
        ;
        ;relocate library code!
        ;
        MOVE.l (A0)+,D2
        TST.l $2C(A1)
        BEQ.w 'skipr
          TST.b debugmode
          BNE.w 'skipr
            CMP.l $2C(A1),D2
            BCC.w 'next
       'skipr
        TST.w $0(A1,D2.L)
        BPL.w 'notajsr
          TST.l D3
          BNE.w 'notajsr      ;already done...
            MOVE.l A0,D0
           MOVE.l D1,D3         ;number left to do!
       'notajsr
        SUB.l $12(A1),D2
        BMI.w 'next
        ADD.l $28(A1),D2
        MOVE.l D2,-(A7)
        SUB.l destbufferstart,D2
        BSR.w addhunkoffset
        MOVEA.l (A7)+,A2

        TST.w dontwrite_nomemleft
        BNE.w 'next
          MOVE.l $28(A1),D2
          SUB.l $12(A1),D2
          ADD.l D2,(A2)
       'next

        SUBQ.l #1,D1
        BNE.w 'reloop

        MOVE.l D3,D2
        BEQ.w 'nohand
          MOVEA.l D0,A2
          SUBQ.w #4,A2
          ;
          BSR.w handlejsrs
       'nohand
        MOVEM.l (A7)+,D0/D2-D3

       'noreloc
        MOVEM.l (A7)+,D1/A0/A2
        ;
        MOVEM.l D1-D2,-(A7)
        TST.w $1A(A1)
        BNE.w 'skip2a
          CLR.w $A(A1)
          BRA.w 'skip2
      'skip2a
        ADDQ.w #1,globalvarpointer
        BCLR #$0,globalvarpointer+1
        MOVE.w globalvarpointer,$A(A1)
        ;
        CMP.w #-$12D,D1            ; was  #65235,
        BNE.w 'nots1
          MOVE.w $A(A1),movestdn+2
          MOVE.w $A(A1),pusha3+2
          MOVE.w $A(A1),pusha32+2
          MOVE.w $A(A1),pulla3+2
          MOVE.w $A(A1),geta3+2

       'nots1
        CMP.w #-$3E9,D1           ; was #64535,
        BNE.w 'notd
          MOVE.w $A(A1),dataget+2
          MOVE.w $A(A1),dataput+2
          MOVE.w $A(A1),rescode+6
          MOVE.w $A(A1),rescode2+2

       'notd
        ADDQ.w #2,globalvarpointer
        TST.w $1A(A1)
        BMI.w 'jword
          ADDQ.w #2,globalvarpointer
       'jword
        MOVEM.l D1/A1,-(A7)
        BSR.w usevars
        MOVEM.l (A7)+,D1/A1

       'skip2
        MOVE.w D1,D2
        MOVE.l $16(A1),D1
        BSR.w uselib2
        MOVE.l $1C(A1),D1
        BSR.w uselib2
        MOVEM.l (A7)+,D1-D2
        ;JSR clear_Cache
        MOVE.b (a7)+,debugmode
 'skip
RTS


fixjsrs:
  ;OK, we have to create code and fill in offsets
  ;for all tokejsrs done through the program
  ;
  MOVEQ.l #$00,D2       ;do list till this...

 'loop
  MOVEA.l tokeslist,A2
  CMPA.l D2,A2
   BEQ.w 'done
  MOVE.l A2,-(A7)       ;next till...

 'loop2                ;do this list...
  MOVEQ.l #$00,D3

 'loop3
  MOVEA.l $8(A2),A3
  CMPA.l D3,A3
   BEQ.w 'done4
  ;
  MOVE.l A3,-(A7)
  MOVEM.l D2-D3/A2-A3,-(A7)
  MOVE.w $4(A2),D1
  MOVE.w $6(A2),D2
  ;
   BSR.w tokecode
  ;
  MOVEM.l (A7)+,D2-D3/A2-A3
; 'loop4
  MOVE.w dontwrite_nomemleft,D0
   BEQ.w 'ok

 'loop5
  MOVEA.l (A3),A3
  CMPA.l D3,A3
   BNE.w 'loop5
 BRA.w 'skipz

 'ok
  MOVEA.l $4(A3),A0
  MOVE.l D7,(A0)
  MOVEA.l (A3),A3
  CMPA.l D3,A3
   BNE.w 'ok

 'skipz
  MOVE.l (A7)+,D3
 BRA.w 'loop3

 'done4
   MOVEA.l (A2),A2
  CMPA.l D2,A2
   BNE.w 'loop2
  MOVE.l (A7)+,D2
 BRA.w 'loop

 'done
RTS


tokecode:
  ;d1=token number, d2=form number!
  ;
  ;return d7, address to jsr!
  ;
  MOVE.w D2,-(A7)
  BSR.w searchinstr             ;Return: a2.l=lib, a3.l=SUB
  MOVE.w (A7)+,D2
  ;
  BCLR #$7,blitzmode
  BCLR #$E,D2
   BEQ.w 'isamiga
  BSET #$7,blitzmode

 'isamiga
  TST.w (A3)
   BEQ.w 'simple
  BTST #$2,$1(A3)
   BNE.w tokeerr
  BTST #$3,$1(A3)
   BNE.w tokeerr
  ;
  ;OK, it's a complex sorta token...
  ;
  LEA $6(A3),A3     ;skip node

 'loop
  MOVE.w (A3)+,D0
   BMI.w tokeerr
  ANDI.w #$FF,D0
  ADDA.w D0,A3
  ADDQ.w #1,A3
  EXG.l D0,A3
  BCLR #$0,D0
  EXG.l D0,A3
  SUBQ.w #1,D2
   BPL.w 'loop2
  ;
  TST.w (A3)
   BNE.w 'go4it          ;no libs to fetch....
  MOVE.l $2(A3),D0
  OR.l $A(A3),D0
   BNE.w 'go4it          ;no error chx...
  BTST #$0,$9(A3)
   BNE.w 'go4it          ;ditto...
  MOVE.l $6(A3),D7       ;sub offset
  MOVE.w $0(A2,D7.L),D0
  ANDI.w #$F000,D0
  CMP.w #-$6000,D0
   BEQ.w 'go4it

 'penis
  SUB.l $12(A2),D7
  ADD.l $28(A2),D7
 RTS

 'go4it
  LEA cutejsr,A0

 'putcode
  ;a0=route in
  MOVE.l destpointer,-(A7)
  MOVE.w #$FFFF,lasta6     ; was -1
  ;
   JSR (A0)
  MOVE.w #$4E75,D1
   BSR.w writeword
  ;
  MOVE.l (A7)+,D7
 RTS

 'loop2
  TST.w (A3)+
   BEQ.w 'skip
  ADDQ.w #2,A3
 BRA.w 'loop2

 'skip
  LEA $C(A3),A3
 BRA.w 'loop

 'simple
  TST.w D2
   BNE.w tokeerr
  ;
  TST.w $6(A3)
   BNE.w 'be4it
  MOVE.l $8(A3),D0
  OR.l $10(A3),D0
   BNE.w 'be4it
  BTST #$0,$F(A3)
   BNE.w 'be4it
  MOVE.l $C(A3),D7
  MOVE.w $0(A2,D7.L),D0
  ANDI.w #$F000,D0
  CMP.w #-$6000,D0        ; was #$a000
   BNE.w 'penis

 'be4it
  MOVE.l A3,D1
  SUB.l A2,D1
  LEA Amakelibsub,A0
BRA.w 'putcode


freetlist:
  MOVEA.l _execbase,A6
  MOVEA.l tokeslist,A2
  CLR.l tokeslist

 'floop
    CMPA.w #$0,A2
     BEQ.w 'done2
    MOVEA.l $8(A2),A3

 'floop2
      CMPA.w #$0,A3
       BEQ.w 'done3
      MOVEA.l A3,A1
      MOVEA.l (A3),A3
      MOVEQ.l #$08,D0
      ; new >
      MOVE.l mempool,a0
      MOVEA.l _execbase,A6
      JSR _FreePooled(A6)
      ; < new
      ;jsr freemem(a6)
 BRA.w 'floop2

 'done3
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$0C,D0
    ; new >
    MOVE.l mempool,a0
    MOVEA.l _execbase,A6
    JSR _FreePooled(A6)
    ; < new
    ;jsr freemem(a6)
 BRA.w 'floop

 'done2
RTS


handlejsrs:
  ;a2=first, d2=how many to do.
  ;
  MOVEM.l D3-D5/A1-A6,-(A7)
  MOVEA.l A1,A4

 'loop
  MOVE.l (A2)+,D3
  MOVE.w $0(A4,D3.L),D5
   BPL.w 'next
  ;
  TST.l $2C(A4)
   BEQ.w 'skipr
  TST.b debugmode
   BNE.w 'skipr
  CMP.l $2C(A4),D3
   BCC.w 'next

 'skipr
  BCLR #$F,D5             ;to offset number
  MOVE.w $2(A4,D3.L),D4
  SUB.l $12(A4),D3
  ADD.l $28(A4),D3
  ;
  MOVEM.l D2/A2/A4,-(A7)
   BSR.w maketjsr
  MOVEM.l (A7)+,D2/A2/A4

 'next
  SUBQ.l #1,D2
   BNE.w 'loop
  ;
  MOVEM.l (A7)+,D3-D5/A1-A6
RTS


maketjsr:
  ;d3=address to poke jsr into,
  ;d4=token number, d5=offset number
  ;bit 14 of d5=1 if BLITZ type.
  ;
  LEA tokeslist,A3
  MOVEA.l _execbase,A6

 'loop2
  MOVE.l (A3),D0
   BEQ.w 'notfound
  MOVEA.l D0,A3
  CMP.w $4(A3),D4
   BNE.w 'loop2
  CMP.w $6(A3),D5
   BNE.w 'loop2
 BRA.w 'found

 'notfound
  ;None done yet...make one up!
  ;
  MOVEQ.l #$0C,D0
  MOVEQ.l #$01,D1
  ; new >
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  ; < new
   ;jsr do_AllocMem
  MOVEA.l D0,A3
  MOVE.l tokeslist,(A3)
  MOVE.l A3,tokeslist
  MOVE.w D4,$4(A3)
  MOVE.w D5,$6(A3)
  CLR.l $8(A3)

 'found
  MOVEQ.l #$08,D0
  MOVEQ.l #$01,D1
  ; new >
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  ; < new
   ;jsr do_AllocMem
  MOVEA.l D0,A0
  MOVE.l D3,$4(A0)
  MOVE.l $8(A3),(A0)
  MOVE.l A0,$8(A3)
  ;
  MOVE.w D4,D1
BRA.w searchinstr       ;use this library - NOW!  return: a2.l=lib, a3.l=sub


tokeslist: Ds.l 1

;   00.l : Next
;   04.w : token number
;   06.w : form number  ;bit 14=1 if Blitz
;   08.l : list of offsets
        ;
        ;00.l : Next
        ;04.l : Offset



uselib2:
  BEQ.w 'skip
    MOVE.l A1,-(A7)
    ADDA.l D1,A1
    ADDQ.w #6,A1

   'loop
      MOVE.w (A1)+,D1
      BEQ.w 'done
        CMP.w D2,D1
        BEQ.w 'skip2
          MOVE.l A1,-(A7)
          BSR.w uselib
          MOVEA.l (A7)+,A1
     'skip2
      ADDQ.w #2,A1
    BRA.w 'loop
   'done
    MOVEA.l (A7)+,A1
 'skip
RTS


findlibnoerr:
  MOVEA.l libpointer,A1

 'loop
    CMPA.w #$0,A1
    BEQ.b 'rts
      CMP.w $4(A1),D1
      BEQ.w 'found
        MOVEA.l (A1),A1
  BRA.w 'loop
 'found
  MOVEQ.l #-$01,D1
 'rts
RTS


findlib:
  ;find lib number d1 - return in a1
  ;
  ; new >
  MOVEM.l d0/a2,-(a7)
  MOVEQ #0,d0
  LEA instrtab+4,a2
  MOVE.w d1,d0
  ASL.l #3,d0
  MOVE.l 0(a2,d0.l),a1                                     ;*8
  CMP.l #0,a1
  BNE 'foundb
  ; < new
  MOVEA.l libpointer,A1

 'loop
    CMPA.w #$0,A1
  ;
    BEQ.w noliberr
  ;
    CMP.w $4(A1),D1
    BEQ.w 'found
   MOVEA.l (A1),A1
 BRA.w 'loop

 'found
  ; new >
  MOVE.l a1,0(a2,d0.l)

 'foundb
  MOVEM.l (a7)+,d0/a2
  ; < new
RTS


searchinstr:        ; was  findtoke org source input: d1=token, return: a2.l=lib, a3.l=sub
  ; new >
  MOVEM.l d0-d1/a1,-(a7)
  MOVEQ #0,d0
  LEA instrtab,a1
  MOVE.w d1,d0
  ASL.l #3,d0
  MOVE.l 0(a1,d0.l),a3
  MOVE.l 4(a1,d0.l),a2
  CMP.l #0,a3
  BNE 'foundb
  ; < new

  MOVEA.l libpointer,A2

 'loop
  CMPA.w #$0,A2
  BEQ.w notokerr
  CMP.w $E(A2),D1
  BCS.w 'next
  CMP.w $10(A2),D1
  BCC.w 'next
  ;
  ;lib found!
  ;
  LEA $30(A2),A3
  TST.w $4(A2)
  BPL.w 'userlib

 'loop2
    CMP.w $E(A2),D1
    BEQ.w 'found
    SUBQ.w #1,D1
    MOVEA.l $2(A3),A3
 BRA.w 'loop2

 'found
  ; new >
  MOVE.l a3,0(a1,d0.l)
  MOVE.l a2,4(a1,d0.l)

 'foundb
  MOVEM.l (a7)+,d0-d1/a1
  ; < new
  MOVEM.l D1/A1-a3,-(A7)      ; was  movem.l d1/a1,-(a7)
  ; new >
  CMP.w #1,(a3)
  BNE.s 'ex10
  CMP.l #$12345678,$e(a3)
  BNE.s 'ex10
  CMP.w #$ffff,$16(a3)
  BNE.s 'ex10
  MOVE.l $12(a3),d1
  BEQ.s 'ex10
  LEA pluginbase,a3
  ;move.b #1,newmode
  JMP 0(a2,d1.l)                                             ;plugin

 'ex10
  ; < new
  MOVEA.l A2,A1
  ; new >
  CLR.b newmode
  ; < new
  MOVE.w $4(A1),D1       ;set lib#
  ; new >
  ;CMP.w #$fed3,d1
  ;BEQ 'l1
  ; < new
  BSR.w uselib3
  MOVEM.l (A7)+,D1/A1-a3
 RTS

  ; new >                               ;??? looks like not used ???
 'l1                                    ; "
  MOVE.w globalvarpointer,-(a7)         ; "
  MOVE.w #$8004,globalvarpointer        ; "
  BSR.w uselib3                         ; "
  MOVE.w (a7)+,globalvarpointer         ; "
  MOVEM.l (A7)+,D1/A1-a3
 RTS
  ; < new

 'userlib
    CMP.w $E(A2),D1
    BEQ.w 'found
    SUBQ.w #1,D1
    MOVEA.l $2(A3),A3
 BRA.w 'userlib

 'next
  MOVEA.l (A2),A2
BRA.w 'loop

; new >             
exit:                ; used from do32
  MOVEM.l (A7)+,D1/A1-a3
  JSR stripspaces
  MOVEQ #0,d0
  MOVE.b (a5)+,d0
  MOVE.w d0,lastchar
  ADDQ.l #4,a7
RTS
; < new

JUMP_writeword JMP writeword
ptr_EndOfLibs.l = 0

Function.l load_libsfile{libfilename.s, libpointer.l, mempool.l}
SHARED ptr_EndOfLibs.l

  If libfilename <> ""
    libfilesize.l = dos_GetFileSize{libfilename}
    libfilehandle.l = Open_(&libfilename,#HUNK_RELOC_16__MODE_OLDFILE)
    If libfilehandle AND (libfilesize > 0)
      tmp_buffer.l = AllocPooled_(mempool, libfilesize)
      tmp_size.l = Read_(libfilehandle, tmp_buffer, libfilesize)
      If tmp_size > 0
;        !cout{"read ok "  + Str$(tmp_size)}
;        !cout{"libpointer: " + Hex$(libpointer)}
        ;If append_to_list
        ;  While Peek.l(libpointer) <> 0
        ;    !cout{Hex$(Peek.l(libpointer)) + "  "}
        ;    libpointer = Peek.l(libpointer)
        ;  Wend
        ;EndIf
        ;-- process loaded libsfile
        GetReg D0,libpointer : MOVE.l d0,-(a7)
        GetReg D0,tmp_buffer : MOVE.l d0,-(a7)
        !asm
        MOVE.l (a7)+,A0     ; memory address of loaded libsfile
        MOVE.l (a7)+,A3     ; libpointer
        linkloop:
          MOVE.l (A0)+,D0                                  ; naechster Longwert nach DO
          BEQ.w linkdone                                   ; wenn <> 0, dann
          !regs2stack
          MOVE.l d0,-(a7)
          !basic
          MOVE.l (a7)+, d0 : PutReg d0,tmpv.l
          ;!cout{"verarbeite lib mit laenge : " + Str$(tmpv)}
          !asm
          !stack2regs
          LEA $20(A0),A1  ;link in.                        ;   lade inhalt von D0+40bytes nach A1
          MOVE.l A1,(A3)                                   ;   kopiere Adresse in A1 zum libpointer
          MOVEA.l A1,A3                                    ;   kopiere A1 nach A3
          ADDA.l D0,A0                                     ;   addiere inhalt von D0 zu A0 hinzu
          ;
          ;fix stuff - done by loadalib
          ;
          MOVE.l -$4(A1),D0    ;number of longwords.       ;   hole die 4bytes vor nach D0
          ADD.l D0,D0          ;to bytes...                ;   verdoppele D0
          ADD.l D0,D0                                      ;   verdoppele D0 nochmal
          MOVE.l D0,$6(A1)     ;fix 1                      ;   schreibe D0 6bytes nach A1
          CLR.l $20(A1)        ;no relocs                  ;   loesche D0+40bytes
          LEA $C(A1,D0.L),A2   ;reloc info.                ;   lade inhalt von (A1)+D0+$C nach A2
          CMPA.l A0,A2         ;is it over?
          BCC.w linkloop                                  ; wenn A0=>A2
            MOVE.l -$8(A2),$20(A1)  ;number of relocs.     ;
            MOVE.l A2,$24(A1)       ;pointer to relocs.    ;
        BRA.w linkloop
        linkdone:
        MOVE.l A3,D0
        !basic
        PutReg d0,ptr_EndOfLibs
 ;       !cout{"read done at " + Hex$(ptr_EndOfLibs)}
      Else
        error{"could not read libfile " + libfilename}
      EndIf
      Close_ libfilehandle
    Else
      error{"The libsfile " + libfilename + " could not be opened."}
    EndIf
    Function Return tmp_buffer
  EndIf
End Function




; input  : D0: size,D1: ptr_strname
; returns: D0: buffer addr
;.load_libsfile:                                            ;loadlibgroup org source  ;load a group of libraries!
;;BRA gothere
;  ;
;  ;d0=len, d1=name; a3= current libpointer
;  ;return d0=address
;  ;
;  MOVE.l a3,-(a7)
;  MOVE.l d1,-(a7)
;  MOVE.l d0,-(a7)
;  !basic
;  MOVE.l (a7)+,d0 : putreg d0, libsize.l
;  MOVE.l (a7)+,d0 : putreg d0, tempd0.l : libname.s = Peek.s(tempd0)
;  !cout{Str$(libsize) + " : " + libname}
;  If libsize > 0
;    filehandle.l = Open_(libname,#HUNK_RELOC_16__MODE_OLDFILE)
;    If filehandle
;      tmp_buffer.l = AllocPooled_(Peek.l(?mempool),libsize)
;      ;!cout{"tmp_buffer:" + Hex$(tmp_buffer)}
;      tmp_size.l = Read_(filehandle,tmp_buffer,libsize)
;      If tmp_size > 0
;        !cout{"read ok "  + Str$(tmp_size)}
;        !cout{"libpointer: " + Hex$(?libpointer)}
;        ;-- process loaded libsfile
;        Getreg D0,tmp_buffer : MOVE.l d0,-(a7)
;        !asm
;        MOVE.l (a7)+,A0     ; memory address of loaded libsfile
;        MOVE.l (a7)+,A3
;        linkloop:
;          MOVE.l (A0)+,D0                                    ; naechster Longwert nach DO
;          BEQ.w linkdone                                    ; wenn <> 0, dann
;          !regs2stack
;          MOVE.l d0,-(a7)
;          !basic
;          MOVE.l (a7)+, d0 : putreg d0, tmpv.l
;          !cout{"verarbeite lib mit laenge : " + Str$(tmpv)}
;          !asm
;          !stack2regs
;            LEA $20(A0),A1  ;link in.                        ;   lade inhalt von D0+40bytes nach A1
;            MOVE.l A1,(A3)                                   ;   kopiere Adresse in A1 zum libpointer
;            MOVEA.l A1,A3                                    ;   kopiere A1 nach A3
;            ADDA.l D0,A0                                     ;   addiere inhalt von D0 zu A0 hinzu
;            ;
;            ;fix stuff - done by loadalib
;            ;
;            MOVE.l -$4(A1),D0    ;number of longwords.       ;   hole die 4bytes vor nach D0
;            ADD.l D0,D0          ;to bytes...                ;   verdoppele D0
;            ADD.l D0,D0                                      ;   verdoppele D0 nochmal
;            MOVE.l D0,$6(A1)     ;fix 1                      ;   schreibe D0 6bytes nach A1
;            CLR.l $20(A1)        ;no relocs                  ;   loesche D0+40bytes
;            LEA $C(A1,D0.L),A2   ;reloc info.                ;   lade inhalt von (A1)+D0+$C nach A2
;            CMPA.l A0,A2         ;is it over?
;            BCC.w linkloop                                  ; wenn A0=>A2
;              MOVE.l -$8(A2),$20(A1)  ;number of relocs.     ;
;              MOVE.l A2,$24(A1)       ;pointer to relocs.    ;
;          BRA.w linkloop
;        linkdone:
;        !basic
;        !cout{"read done"}
;
;      Else
;        !cout{"could not read libfile " + libname}
;      EndIf
;      Close_ filehandle
;    Else
;      error{"The libsfile " + libname + " could not be opened."}
;    EndIf
;  EndIf
;  ;-- return memory address in D0
;  Getreg D0,tmp_buffer : MOVE.l d0,-(a7)
;  !asm
;  MOVE.l (a7)+,d0
;RTS

;gothere:
;  TST.l D0
;  BEQ.w _quit
;    MOVE.l D0,D6                                           ;d6=len
;    MOVEA.l _dosbase,A6
;    MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
;    JSR _Open(A6)
;    MOVE.l D0,D7
;    BEQ.w _quit
;      MOVE.l D6,D0
;      MOVEQ.l #$01,D1
;      MOVEA.l _execbase,A6
;      ;jsr do_AllocMem
;      ; new >
;      MOVE.l mempool,a0
;      JSR _AllocPooled(a6)
;      ; new >
;      MOVE.l D0,D5                                         ;start address
;
;      MOVE.l D7,D1                                         ; handle
;      MOVE.l D5,D2                                         ; buffer addr
;      MOVE.l D6,D3                                         ; size
;      MOVEA.l _dosbase,A6
;      JSR _Read(A6)
;      MOVE.l D7,D1
;      JSR _Close(A6)
;      ;
;      MOVEA.l D5,A0                                        ; buffer addr
;
;      ; --
;      ; -- process loaded acid/utillibs
;      ; -- (libpointer steht ja in A3)
;     linkloop2:
;      TRAP #0
;      MOVE.l (A0)+,D0                                    ; naechster Longwert nach DO
;      BEQ.b linkdone2                                    ; wenn <> 0, dann
;          !regs2stack
;          MOVE.l d0,-(a7)
;          !basic
;          MOVE.l (a7)+, d0 : putreg d0, tmpv.l
;          !cout{"verarbeite lib: " + Hex$(tmpv)}
;          !asm
;          !stack2regs
;
;
;
;        LEA $20(A0),A1  ;link in.                        ;   lade inhalt von D0+40bytes nach A1
;        MOVE.l A1,(A3)                                   ;   kopiere Adresse in A1 zum libpointer
;        MOVEA.l A1,A3                                    ;   kopiere A1 nach A3
;        ADDA.l D0,A0                                     ;   addiere inhalt von D0 zu A0 hinzu
;        ;
;        ;fix stuff - done by loadalib
;        ;
;        MOVE.l -$4(A1),D0    ;number of longwords.       ;   hole die 4bytes vor nach D0
;        ADD.l D0,D0          ;to bytes...                ;   verdoppele D0
;        ADD.l D0,D0                                      ;   verdoppele D0 nochmal
;        MOVE.l D0,$6(A1)     ;fix 1                      ;   schreibe D0 6bytes nach A1
;        CLR.l $20(A1)        ;no relocs                  ;   loesche D0+40bytes
;        LEA $C(A1,D0.L),A2   ;reloc info.                ;   lade inhalt von (A1)+D0+$C nach A2
;        CMPA.l A0,A2         ;is it over?
;        BCC.b linkloop2                                  ; wenn A0=>A2
;        ;
;        MOVE.l -$8(A2),$20(A1)  ;number of relocs.     ;
;        MOVE.l A2,$24(A1)       ;pointer to relocs.    ;
;      BRA.w linkloop2
;     linkdone2:
;      MOVE.l D5,D0
;_quit:
;RTS


.load_all_libraries:
  tempmapping$ = dos_AddPart{config\path_system,"token_mapping_userlibs.txt"}
  dos_Delete{tempmapping$}
  fid.l = file_Open{tempmapping$,#file_forcewrite}

  ;-- load baseLibs
  ;!cout{"baseLibs"}
  If config\path_baselibs <> ""
    libdata\size_baselibs = dos_GetFileSize{config\path_baselibs}
    If libdata\size_baselibs < 0
      error{"BASELIBS [" + config\path_baselibs + "] not found, none of the stored functions will be available."}
    Else
      libdata\ptr_baselibs = load_libsfile{config\path_baselibs,?libpointer,Peek.l(?mempool)}
    EndIf
  Else
    ptr_EndOfLibs = ?libpointer
  EndIf

  ;-- load utilLibs
  ;!cout{"utilLibs"}
  If config\path_utillibs <> ""
    libdata\size_utillibs = dos_GetFileSize{config\path_utillibs}
    If libdata\size_utillibs < 0
      error{"UTILLIBS [" + config\path_utillibs + "] not found, none of the stored functions will be available."}
    Else
      tmp_mem.l = load_libsfile{config\path_utillibs,ptr_EndOfLibs,Peek.l(?mempool)}
      libdata\ptr_utillibs = tmp_mem
    End If
  EndIf

  ;-- load oslibs
  ;!cout{"osLibs"}
  If config\path_oslibs <> ""
    libdata\size_oslibs = dos_GetFileSize{config\path_oslibs}
    If libdata\size_oslibs < 0
      error{"OSLIBS [" + config\path_oslibs + "] not found, none of the stored functions will be available."}
    Else
      tmp_mem.l = load_libsfile{config\path_oslibs,ptr_EndOfLibs,Peek.l(?mempool)}
      libdata\ptr_oslibs = tmp_mem
    End If
  EndIf

  ;-- load cslibs
  ;!cout{"csLibs"}
  If config\path_cslibs <> ""
    libdata\size_cslibs = dos_GetFileSize{config\path_cslibs}
    If libdata\size_cslibs < 0
      error{"CSLIBS [" + config\path_cslibs + "] not found, none of the stored functions will be available."}
    Else
      tmp_mem.l = load_libsfile{config\path_cslibs,ptr_EndOfLibs,Peek.l(?mempool)}
      libdata\ptr_cslibs = tmp_mem
    End If
  EndIf

  libdata\ptr_userlibs = ptr_EndOfLibs
  Poke.l ptr_EndOfLibs,0  ; setting pointer to next lib to 0

.load_userlibs:
  ;!cout{"userlibs"}
  ResetList userlibslist()
  While NextItem(userlibslist())
    userlib_filename$ = dos_AddPart{config\path_userlibs,userlibslist()\libname}
    tmp_lock.l = Lock_(&userlib_filename$,#ACCESS_READ)
    If tmp_lock
      ;  DEFTYPE.FileInfoBlock fib
      If Examine_(tmp_lock,fib)
        ;!cout{"userlib in liste wird geladen: " + userlib_filename$}
        If dos_GetExt{Peek.s(&fib\fib_FileName)} <> "info"
          userlib_filename$ = dos_AddPart{config\path_userlibs,Peek.s(&fib\fib_FileName)}
          Gosub open_userlibfile
        EndIf
      EndIf
      UnLock_ tmp_lock
    EndIf
  Wend
  If tmp_userlibspointer.l <> 0 Then Poke.l tmp_userlibspointer,0    ; setting pointer to next lib to 0

  If fid<>-1
    file_Close{fid}      ; close temp_mapping file opened above
    fid = -1
  EndIf
  ;!cout{"process libs"}
  !asm
BRA.w process_libraries


.open_userlibfile:  ; was loadalib  org source
  If tmp_userlibspointer.l = 0 Then tmp_userlibspointer.l = libdata\ptr_userlibs

  ;!cout{"userlibspointer at: " + Hex$(tmp_userlibspointer)}
  ulfh.l = Open_(&userlib_filename$,#HUNK_RELOC_16__MODE_OLDFILE)
  If ulfh
    Read_ ulfh,?optstuff,$20                               ; 32 bytes lesen
    datachunk_size.l = Peek.l(?optstuff+28) LSL 2          ; calculate datachunk size

    datachunk_ptr.l  = AllocPooled_ (Peek.l(?mempool),datachunk_size)    ; read datachunk from library
    Read_ ulfh,datachunk_ptr,datachunk_size

    Poke.l tmp_userlibspointer, datachunk_ptr                      ; tmp_mem > (A3)
    ;!cout{"added library pointer to liblist at " + Hex$(tmp_userlibspointer) + " datachunksize: " + Str$(datachunk_size) }
    Poke.l datachunk_ptr + $6, datachunk_size
    Poke.l datachunk_ptr + $20,0

    ; write libdata to tokenreference
    If fid<>-1
      addr_libnum.l = datachunk_ptr + 4
      libnum.w = Peek.w(addr_libnum)
      currentlib$ = LSet$(Peek.s(&fib\fib_FileName),30) + ";" + LSet$(Get_Libinfo{addr_libnum},30) ;+";"+Str$(libnum))
      file_WriteLine{fid,currentlib$}
    EndIf

    If Read_(ulfh,?optstuff,$0C) = $0C                            ; read 12 bytes
      udata.l = Peek.l(?optstuff + 4)                             ; length of reloc info (lsl2)
      Poke.l datachunk_ptr + $20, udata
      udata = udata LSL 2
      tmp_mem2.l = AllocPooled_ (Peek.l(?mempool), udata)
      Poke.l datachunk_ptr + $24, tmp_mem2
      Read_ ulfh, tmp_mem2, udata
    EndIf
    Close_ ulfh

    tmp_userlibspointer = datachunk_ptr                            ; tmp_mem > A3
  Else
    error{"could not open userlibfile: " + userlib_filename$}
  EndIf
Return


; --
; -- prepare userlibs and adding to librarylist
.process_libraries:   ;was fixlibs org source
    ;fill in blanks in lib list
    ;
    ;tokens, links etc
    ;
  CLR.w number_of_objects
  MOVEA.l end_of_tokenlist,A3
  MOVEA.l libpointer,A2
  ;!regs2stack
  ;!basic
  ;!cout{"process libs at libpointer: " + Hex$(?libpointer)}
  ;!asm
  ;!stack2regs

  tokenloop:
    CMPA.w #$0,A2
    BEQ.w tokendone

      MOVE.w $4(A2),D7                                   ; <-- get tokennumber
      BMI.w 'syslib
        LSL.w #7,D7
        ADDQ.w #1,D7
        MOVE.w D7,$E(A2)
     'syslib
      LEA $30(A2),A1
      LEA temp1,A4

     'loop2
        MOVE.w (A1),D0
        BMI.w 'next
        MOVE.l A1,(A4)
        MOVEA.l A1,A4      ;last link for subs
        ADDQ.w #2,A4
        ADDQ.w #6,A1
        CMP.w #$8,D0
        BEQ.w 'addtoke
          ANDI.w #$F,D0
          BNE.w 'something
            ;
            ;skip sys sub
            ;
            BSR.w skiplibreg
            LEA $C(A1),A1
            ADDQ.w #1,D7   ;in case it's a user lib
      BRA.w 'loop2
     'something
      BTST #$2,D0
      BEQ.w 'notalib
        ADDQ.w #4,A1
       'alibloop
          TST.b (A1)+
        BPL.w 'alibloop
        BSR.w aligna1
        BRA.w 'addtoke
     'notalib
      ;process standard function or statement
     'stloop
        MOVE.w (A1)+,D0
        BMI.w 'addtoke
          ANDI.w #$FF,D0
          ADDA.w D0,A1
          BSR.w aligna1
          BSR.w skiplibreg
          LEA $C(A1),A1
      BRA.w 'stloop

     'addtoke
        MOVE.l A1,(A3)
        MOVEA.l A1,A3
        ADDQ.w #4,A1
        ;
        MOVE.w D7,(A1)+
     'tokeloop
        TST.b (A1)+
      BNE.w 'tokeloop

     'tokeloop2
        TST.b (A1)+
      BNE.w 'tokeloop2
      BSR.w aligna1
      ADDQ.w #1,D7
      BRA.w 'loop2

   'next
    TST.w $4(A2)
    BMI.w 'notulib
      MOVE.w D7,$10(A2)
   'notulib
    ADDQ.w #2,A1
    TST.l (A1)+
    BEQ.w 'nomax
      ADDQ.w #1,number_of_objects
      LEA $16(A1),A1
   'nomax
    SUBA.l A2,A1
    MOVE.l A1,$12(A2)
    MOVEA.l (A2),A2
  BRA.w tokenloop

  tokendone:
  CLR.l (A3)
  ; new >
  MOVE.l a7,stackaddr       ; added to prevent a possible crash in CLIMode if #continue_on_error is set  tomsmart1
  ; < new
  MOVE.l A7,errstack
  MOVE.l #'cont,errcont
  MOVE.w #$FFFF,ezerr       ; was -1

  MOVE.w #$FFFA,D1          ;#65530
  BSR.w findlib             ;get address of mem lib
  MOVE.l A1,tempvm

  MOVE.w #$FDA7,D1          ;#64935,
  BSR.w findlib
  MOVE.l A1,ffplib

 'cont
RTS


ffplib:  Ds.l 1


skiplibreg:
    TST.w (A1)+
    BEQ.w 'done
    ADDQ.w #2,A1
 BRA.w skiplibreg

 'done
RTS


aligna0:
  EXG.l A1,A0
  BSR.w aligna1
  EXG.l A1,A0
RTS


aligna1:
  EXG.l D0,A1
  ADDQ.l #1,D0
  BCLR #$0,D0
  EXG.l D0,A1
RTS


.free_userlibs:       ; was freeblitzlibs org source                                      ;freeblitzlibs
  tmp_current.l = libdata\ptr_userlibs
  tmp_current = Peek.l(tmp_current) ; this is the begin of the first userlib
;  !cout{"userlibs beginn here: " + Hex$(tmp_current)}
  While tmp_current <> 0
    tmp_next.l = Peek.l(tmp_current)
    datachunk_size.l = Peek.l(tmp_current + $20)
    If datachunk_size <> 0
;      !cout{"delete datachunk_size: " + Hex$(datachunk_size LSL 2) + " at " + Hex$(tmp_current+$24)}
      FreePooled_ Peek.l(?mempool),Peek.l(tmp_current+$24),datachunk_size LSL 2
    EndIf
;    !cout{"delete lib at " + Hex$(tmp_current) + " size " + Hex$(Peek.l(tmp_current + $6))}
    FreePooled_ Peek.l(?mempool), tmp_current, Peek.l(tmp_current+$6)

    tmp_current = tmp_next
  Wend

  ClearList userlibslist()
Return

;  TRAP #0
;  MOVEA.l _execbase,A6
;  MOVEA.l ptr_userlibs,A2
;  MOVE.l (A2),D0
;  CLR.l (A2)
;  MOVEA.l D0,A2
;
; 'loop
;    CMPA.w #$0,A2
;    BEQ.w free_userlibslist   ; and at the end... free the list with all the libnames
;
;    MOVE.l $20(A2),D0
;    BEQ.b 'skip
;      LSL.l #2,D0
;      MOVE.l mempool,a0
;      MOVEA.l $24(A2),A1
;      JSR _FreePooled(A6)     ; a0=poolheader, a1=memory, d0=memsize
;   'skip
;    MOVEA.l A2,A1
;    MOVE.l $6(A1),D0
;    MOVE.l mempool,a0
;    MOVEA.l (A2),A2
;    MOVEA.l _execbase,A6
;    JSR _FreePooled(A6)
;BRA.w 'loop


.free_blitzlibs:                                           ;freelibs org source    ;free up all memory used by libs
  !basic
  Gosub free_userlibs

  Poke.l ?libpointer, 0
  Poke.l Peek.l(?end_of_tokenlist),0

  If libdata\size_baselibs Then FreePooled_ Peek.l(?mempool),libdata\ptr_baselibs,libdata\size_baselibs
  If libdata\size_utillibs Then FreePooled_ Peek.l(?mempool),libdata\ptr_utillibs,libdata\size_utillibs

  !asm
RTS


;  BSR.w free_userlibs
;  ;
;  TRAP #0
;  MOVEA.l _execbase,A6
;  CLR.l libpointer
;  MOVEA.l end_of_tokenlist,A0
;  CLR.l (A0)
;  ;
;  MOVE.l size_baselibs,D0
;  BEQ.b 'acidskip
;    MOVE.l ptr_baselibs,D1
;    BEQ.b 'acidskip
;      CLR.l ptr_baselibs
;      MOVEA.l D1,A1
;      MOVE.l mempool,a0
;      MOVEA.l _execbase,A6
;      JSR _FreePooled(A6)                                 ; free baselibs
; 'acidskip
;
;  MOVE.l size_utillibs,D0
;  BEQ.b 'defskip
;    MOVE.l ptr_utillibs,D1
;    BEQ.b 'defskip
;      CLR.l ptr_utillibs                                    ; d0: memorySize
;      MOVEA.l D1,A1                                        ; a1: memory
;      MOVE.l mempool,a0                                    ; a0: poolHeader
;      MOVEA.l _execbase,A6
;      JSR _FreePooled(A6)                                  ; free utillibs
; 'defskip
;RTS


free_Macros:
  MOVEA.l currentmacroaddr,A0
  MOVEA.l (A0),A2
  CLR.l (A0)
  MOVEA.l _execbase,A6

 'loop
    CMPA.w #$0,A2
    BEQ.w 'done
    MOVEQ.l #$00,D0
    MOVE.w $8(A2),D0
    BEQ.w 'skip
    MOVEA.l $4(A2),A1
    ; new >
    MOVE.l mempool,a0
    JSR _FreePooled(A6)
    ; < new
    ;jsr freemem(a6)

 'skip
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$00,D0
    MOVE.b $C(A1),D0
    ; new >
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
    ; < new
    ;jsr freemem(a6)

 BRA.w 'loop

 'done
RTS


cleartemplabel:                                            ;freeasms org code
  MOVEA.l templabel,A2
  CLR.l templabel
  ; new >
RTS
  ; < new
  MOVEA.l _execbase,A6                                     ;??looks like dead code?

 'loop
    CMPA.w #$0,A2
    BEQ.w 'done
    MOVEQ.l #$00,D0
    MOVE.b $E(A2),D0                                       ;labeltemp
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    ; new >
    MOVE.l mempool2,a0
    ;jsr _FreePooled(A6)
    ;< new
    ;jsr freemem(a6)

 BRA.w 'loop

 'done
RTS


pokedata1b:                                               ;byte into data1
  MOVEA.l data1,A4
  CMPA.l data2at,A4
  BCC.w 'over
    MOVE.b D1,(A4)+
    MOVE.l A4,data1
 RTS

 'over
  MOVE.w #$FFFF,dontwrite_nomemleft     ; was -1                             ;move #-1, org source
  ADDQ.l #1,data1
RTS


writedatalong:                                             ;pokedata1l org source
  SWAP D1
  BSR.w pokedata1
  SWAP D1

pokedata1:                                                ;poke word in d1 into data block
  MOVEA.l data1,A4
  CMPA.l data2at,A4
   BCC.w 'over
  MOVE.w D1,(A4)+
  MOVE.l A4,data1
 RTS

 'over
  MOVE.w #$FFFF,dontwrite_nomemleft    ; was -1
  ADDQ.l #2,data1
RTS


calcstatic2b:               ;copy of calcstatic2, this is the original code
  MOVE.l data1,D3                                      ;write local string/type allocs
  MOVEQ.l #$00,D4

 'loop
  CMPA.w #$0,A2
   BEQ.w 'done
  TST.w $6(A2)
   BNE.w 'next
  MOVEA.l $A(A2),A3
  CMPI.l #$100,$4(A3)
   BCS.w 'next
  MOVE.w $4(A2),D1
   BSR.w pokedata1
  MOVE.w $8(A3),D1
   BSR.w pokedata1
  ADDQ.w #1,D4

 'next
   MOVEA.l (A2),A2
 BRA.w 'loop

 'done
   TST.w D4
   BEQ.w calcstatic2_skip
  MOVE.w #$FF37,D1              ;#65335
   BSR.w uselib                 ;use statics lib
  MOVE.w #$FFFA,D1              ;use memlib
BRA.w uselib


calcstatic:
    ;calculate static structures stuff - put num of structs d4.w
    ;address of data1 table in d3.l
    ;
    ;data1: .w=structsize,.w=offset
    ;
  MOVEA.l varbase,A2                                       ;add alloc mem for types/strings global

calcstatic2:
  MOVE.l data1,D3
  MOVEQ.l #$00,D4
  ; new >
  TST.b iserror
  BEQ 'loop
  RTS
  ; < new

 'loop
   CMPA.w #$0,A2
   BEQ.w 'done
  TST.w $6(A2)
   BNE.w 'next
  MOVEA.l $A(A2),A3
  CMPI.l #$100,$4(A3)
   BCS.w 'next
  MOVE.w $4(A2),D1
   BSR.w pokedata1
  MOVE.w $8(A3),D1
   BSR.w pokedata1
  ADDQ.w #1,D4

 'next
  MOVEA.l (A2),A2
 BRA.w 'loop

 'done                                                 ;??looks like double label ?
  ; new >
 ;calcstaticb:          ; copy of calcstatic
  MOVEA.l sharebase,A2  ; org  varbase

 'loopb                 ; copy of calcstatic2
  CMPA.w #$0,A2
   BEQ.w 'doneb

  TST.w $6(A2)
   BNE.w 'nextb
  MOVEA.l $A(A2),A3
  CMPI.l #$100,$4(A3)
   BCS.w 'nextb
  MOVE.w $4(A2),D1
   BSR.w pokedata1
  MOVE.w $8(A3),D1
   BSR.w pokedata1
  ADDQ.w #1,D4

 'nextb
  MOVEA.l (A2),A2
 BRA.w 'loopb

 'doneb
  ; < new
   TST.w D4
   BEQ.w calcstatic2_skip
  MOVE.w #$FF37,D1      ;#65335
   BSR.w uselib         ;use statics lib                                   ;use statics lib
  MOVE.w #$FFFA,D1      ;use memlib                                   ;use memlib
BRA.w uselib

calcstatic2_skip:
RTS


datastart:                                                 ;set up a2 (d3.l) and d4 (d4.w)
  MOVE.w numtoa2,D1
   BSR.w writeword
   BSR.w addoff
  MOVE.l D3,D1
   BSR.w writelong
  SUBQ.w #1,D4
  MOVE.w D4,endarray+2
  MOVE.l endarray,D1
BRA.w writelong


mywrite:
  MOVE.l D3,-(A7)
  ;new >
  ; JSR _Reschedule(A6)  ;<= this is probably wrong, it's Write() from dos.lib
  MOVEA.l _dosbase,A6
  ; < new
  JSR _Write(a6)
  CMP.l (A7)+,D0
   BNE.w 'skip
 RTS

 'skip
  MOVE.l D7,D1
  ; new >
  ;JSR _ExitIntr(A6)   ; <= this is probably wrong, it's Close() from dos.lib
  MOVEA.l _dosbase,A6
  ; < new
  JSR _Close(a6)

execerr:
JMP error_create_exe
;RTS                                                       ;??looks like dead code??


.savefile:
  ;
  ;make all abs refs pcat relative
  ;
  ; new >
  MOVE.l a7,stackaddr                                      ; added to prevent a possible crash in CLIMode if #continue_on_error is set and the file can't create  tomsmart1
  ; < new
  MOVE.l A7,errstack
  ; new <
  MOVEM.l d2-d7/a2-a6,-(a7)
  ; < new
  MOVE.l #'rts,errcont
  ;
  MOVE.w #$FFFF,anyerrs   ; was -1
  ; new >
  CMP.l #-1,chipstart
  BEQ 'l01
  MOVE.l chipend,d1
  ADDQ.l #3,d1
  AND.l #$fffffffc,d1                                      ;bug
  MOVE.l d1,chipend
  MOVE.l d1,a1
  MOVE.l chipstart,a0
  MOVE.l a1,d1
  SUB.l a0,d1
  MOVE.l d1,chipsize

 'l01
  CMP.l #-1,bssstart
  BEQ 'l11
  MOVE.l realbssend,a1
  MOVE.l bssstart,a0
  MOVE.l a1,d1
  SUB.l a0,d1
  MOVE.l d1,bsssize
  BEQ 'l11

 'l32
  TST.b (a0)+
  BEQ 'l31
  TST.b debugmode
  BEQ 'l1
  TST.b exdebug
  BNE 'l31

 'l1
  MOVE.l #nodata,-(a7)
  JMP handle_compileerror

 'l31
  CMP.l a0,a1
  BGT 'l32
  MOVE.l bssend,d1
  ADDQ.l #3,d1
  AND.l #$fffffffc,d1                                      ;bug
  MOVE.l d1,bssend
  MOVE.l d1,a1
  MOVE.l bssstart,a0
  MOVE.l a1,d1
  SUB.l a0,d1
  MOVE.l d1,bsssize

 'l11
  MOVEM.l d5-d7/d3,-(a7)
  ; < new
  MOVE.w dontwrite_nomemleft,D1
  BNE.w 'fixdone
  ; new >
  MOVE.l chipsize,d5
  MOVE.l bsssize,d3
  MOVE.l chipstart,d7
  MOVE.l bssstart,d6
  ; < new
  MOVEA.l hunkoffsetbase,A2
  MOVEA.l destbufferstart,A1
  MOVE.l A1,D2
  ADD.l noinits,D2
  ; new >
  CLR.l hunkoffsetnum
  ; < new

 'loop0
  CMPA.w #$0,A2
   BEQ.w 'fixdone
  MOVE.l $4(A2),D0
  ; new >
   LEA $0(a1,d0.l),a0
   MOVE.l (a0),d1
  TST.l d1
   BMI.w 'lm1a
  MOVE.b #0,newhunk
  CMP.l #-1,chipstart
  BEQ 'l10a
  CMP.l chipstart,d1
  BLT 'l10a
  MOVE.b #1,newhunk
  CMP.l chipend,d1
  BGE 'l110a
  SUB.l d7,(a0)
  ADD.l #$80000000,4(a2)
 BRA 'noway

 'l110a
  SUB.l d5,0(a0)

 'l10a
  CMP.l #-1,bssstart
    BEQ 'l11a
  CMP.l bssstart,d1
  BLT 'l11a
  CMP.l bssend,d1
  BGE 'l111a
  TST.b newhunk
  BEQ 'ln1a
  ADD.l d5,(a0)

 'ln1a
  SUB.l d6,(a0)
  ADD.l #$40000000,4(a2)
 BRA 'noway

 'l111a
  SUB.l d3,0(a0)

 'l11a
  SUB.l D2,(A0)

 'lm1a
  ADDQ.l #1,hunkoffsetnum
  ; < new

 'noway
   MOVEA.l (A2),A2
 BRA.w 'loop0

 'fixdone
  ; new >
  MOVEM.l (a7)+,d5-d7/d3
  ; < new

  MOVE.l ptr_newexefilename,D1
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVEA.l _dosbase,A6
   JSR _Open(A6)
  MOVE.l D0,D7
   BEQ.w execerr
  ;
  MOVE.l objlen,D0
  ; new >
  SUB.l #moremem,d0
  ; < new
  SUB.l noinits,D0
  ; new >
  CMP.l #-1,bssstart
  BEQ 'l60
  SUB.l bsssize,d0
  SUB.l chipsize,d0
 BRA.s 'l61

 'l60
  CMP.l #-1,chipstart
  BEQ 'l61
  SUB.l bsssize,d0
  SUB.l chipsize,d0

 'l61
  ; < new
  ADDQ.l #3,D0
  LSR.l #2,D0
  MOVE.l D0,tstsize1
  MOVE.l D0,tstsize2
  MOVE.l D7,D1
  MOVE.l #tsthead,D2                                      ;hunkbegin
  MOVEQ.l #$20,D3
  ; new >
  CMP.l #-1,bssstart
  BEQ 'lb1
  CMP.l #-1,chipstart
  BEQ 'lb1
  MOVE.l #1,bssnum
  MOVE.l #2,chipnum
  MOVEQ.l #$28,D3
  MOVE.l bsssize,d2
  ADDQ.l #3,d2
  ASR.l #2,d2
  MOVE.l d2,hunkend+8
  MOVE.l d2,bsssize3
  MOVE.l chipsize,d2
  ADDQ.l #3,d2
  ASR.l #2,d2
  MOVE.l d2,chipsize2
  ADD.l #$40000000,chipsize2
  MOVE.l d2,hunkend2+8
  MOVE.l D0,tstsize1c
  MOVE.l D0,tstsize2c
  MOVE.l #hunkbegin2,d2
 BRA 'l100b

 'lb1
  CMP.l #-1,bssstart
  BEQ 'l10b
  MOVE.l #1,bssnum
  MOVEQ.l #$24,D3
  MOVE.l bsssize,d2
  ADDQ.l #3,d2
  ASR.l #2,d2
  MOVE.l d2,hunkend+8
  MOVE.l d2,bsssize2
  MOVE.l D0,tstsize1b
  MOVE.l D0,tstsize2b
  MOVE.l #hunkbegin,d2

 'l10b
  CMP.l #-1,chipstart
  BEQ 'l100b
  MOVE.l #1,chipnum
  MOVEQ.l #$24,D3
  MOVE.l chipsize,d2
  ADDQ.l #3,d2
  ASR.l #2,d2
  MOVE.l d2,hunkend2+8
  MOVE.l d2,bsssize2
  ADD.l #$40000000,bsssize2
  MOVE.l D0,tstsize1b
  MOVE.l D0,tstsize2b
  MOVE.l #hunkbegin,d2

 'l100b
  ; < new
   BSR.w mywrite
  ;
  MOVE.l destbufferstart,D2
  ADD.l noinits,D2
  MOVE.l objlen,D3
  SUB.l #moremem,d3
  SUB.l noinits,D3
  ; new >
  CMP.l #-1,bssstart
  BNE 'l40
  CMP.l #-1,chipstart
  BNE 'l40
 BRA 'l41

 'l40
  MOVE.l codeend,d1
    SUB.l d2,d1
    MOVE.l d1,d3
  SUB.l bsssize,d3
  SUB.l chipsize,d3
  MOVE.l D7,D1
  BSR.w mywrite
  MOVE.l objlen,D3
  SUB.l #moremem,d3
  SUB.l noinits,D3
  MOVE.l d3,d1
  MOVE.l destbufferstart,D2
  ADD.l noinits,D2
  ADD.l d2,d1
  SUB.l codeend,d1
  MOVE.l d1,d3
  MOVE.l codeend,d2

 'l41
  MOVE.l d2,d1
  ADD.l d3,d1
  ; < new
  ADDQ.l #3,D1
  ANDI.l #$FFFFFFFC,D1
  ; new >
  SUB.l d2,d1
  MOVE.l d1,d3
  MOVE.l D7,D1
  ; < new
   BSR.w mywrite
  ;
  MOVE.l hunkoffsetcounter,tstsize3
   BEQ.w 'skip
  MOVE.l D7,D1
  MOVE.l #tstend,D2
  MOVEQ.l #$04,D3           ; was #12
   BSR.w mywrite
  ; new >
   MOVEA.l _execbase,A6
   MOVE.l hunkoffsetcounter,d0
   ASL.l #2,d0
   ADD.l #12,d0
   MOVEQ #0,d1
   JSR _AllocMem(a6)
   TST.l d0
   BEQ 'nomem
   MOVE.l noinits,D4
   MOVE.l d5,-(a7)
   MOVE.l d0,d5
   MOVE.l d0,a1
   MOVEA.l hunkoffsetbase,A2
   MOVE.b #0,newhunk

 'oloopb                      ; copy of 'oloop
  CMPA.w #$0,A2
   BEQ.w 'savehunk
  MOVE.l destbufferstart,D2
  ADD.l noinits,D2
  MOVE.l  $4(A2),d1
  BTST #31,d1
  BEQ 'lh1
  MOVE.b #1,newhunk
 BRA 'lh3

 'lh1
  BTST #30,d1
  BEQ 'lh2
  MOVE.b #1,newhunk
 BRA 'lh3

 'lh2
  ADD.l d1,d2
  CMP.l chipend,d2
  BLT 'l102c
  SUB.l chipsize,d1

 'l102c
  CMP.l bssend,d2
  BLT 'l101c
  SUB.l bsssize,d1

 'l101c
  MOVE.l d1,(a1)
  SUB.l D4,(A1)+

 'lh3
  MOVEA.l (A2),A2
 BRA.w 'oloopb

 'savehunk
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  MOVE.l hunkoffsetnum,tstsize3
  BEQ 'ln1c
  MOVE.l #tstend+4,d2
    MOVEQ #8,d3
   JSR _Write(A6)
  MOVE.l d7,d1
  MOVE.l hunkoffsetnum,d3
  ASL.l #2,d3
  MOVE.l d5,D2
  JSR _Write(a6)

 'ln1c
  TST.b newhunk
  BEQ 'l10c
  MOVEA.l hunkoffsetbase,A2
  MOVE.l d5,a0
  ADDQ #8,a0
  MOVE.l bssnum,-4(a0)
  MOVEQ #0,d6

 'lh2c
  CMPA.w #$0,A2
   BEQ.w 'lh3c
  MOVE.l destbufferstart,D2
  ADD.l noinits,D2
  MOVE.l  $4(A2),d1
  BTST #30,d1
  BEQ 'lh1c
  BCLR #30,d1
  MOVE.l d1,(a0)
  SUB.l D4,(A0)+
  ADDQ.l #1,d6

 'lh1c
  MOVE.l (a2),a2
 BRA 'lh2c

 'lh3c
  TST.l d6
    BEQ 'lh10c
    MOVE.l d5,a0
    MOVE.l d6,(a0)
    MOVE.l d7,d1
    MOVE.l d5,d2
    MOVE.l d6,d3
    ASL.l #2,d3
    ADDQ.l #8,d3
    BSR.w mywrite

 'lh10c
  MOVEA.l hunkoffsetbase,A2
  MOVE.l d5,a0
  ADDQ #8,a0
  MOVE.l chipnum,-4(a0)
  MOVEQ #0,d6

 'lh20c
  CMPA.w #$0,A2
   BEQ.w 'lh30c
  MOVE.l destbufferstart,D2
  ADD.l noinits,D2
  MOVE.l  $4(A2),d1
  BTST #31,d1
  BEQ 'lh11c
  BCLR #31,d1
  MOVE.l d1,(a0)
  SUB.l D4,(A0)+
  ADDQ.l #1,d6

 'lh11c
  MOVE.l (a2),a2
 BRA 'lh20c

 'lh30c
  TST.l d6
    BEQ 'l10c
    MOVE.l d5,a0
    MOVE.l d6,(a0)
    MOVE.l d7,d1
    MOVE.l d5,d2
    MOVE.l d6,d3
    ASL.l #2,d3
    ADDQ.l #8,d3
    BSR.w mywrite

 'l10c
   ;MOVE.l $4,a6
   MOVEA.l _execbase,A6
   MOVE.l hunkoffsetcounter,d0
   ASL.l #2,d0
   ADD.l #12,d0
   MOVE.l d5,a1
   JSR _FreeMem(a6)
   MOVEA.l _dosbase,A6
   MOVE.l (a7)+,d5
 BRA 'skip2

 'nomem
  ; < new
  MOVEA.l hunkoffsetbase,A2
  MOVE.l noinits,D4

 'loop
  CMPA.w #$0,A2                                            ;write hunkoffsets
  BEQ.w 'skip2
  LEA $4(A2),A1
  SUB.l D4,(A1)
  MOVE.l D7,D1
  MOVE.l A1,D2
  MOVEQ.l #$04,D3
  BSR.w mywrite
  ;
  ADD.l D4,$4(A2)
  MOVEA.l (A2),A2
 BRA.w 'loop

 'skip2
  CLR.l tstsize3
  MOVE.l D7,D1
  MOVE.l #tstsize3,D2
  MOVEQ.l #$04,D3
   BSR.w mywrite

 'skip
  BTST #$7,link_debuginfo
   BEQ.w 'nodebug
  ;
  MOVE.l #sysdebug,D2                                      ;debughunks
  MOVEQ.l #$04,D3
  MOVE.l D7,D1
   BSR.w mywrite
  ;
  MOVEA.l labelbase,A2

 'deloop
  CMPA.w #$0,A2
   BEQ.w 'dedone
  BTST #$0,$7(A2)
   BEQ.w 'dedeb
  CMPI.l #$1,$4(A2)
   ;BNE.w 'denext
  ; new >
  BRA.w 'denext                                            ;only addr labels
  ; < new

 'dedeb
  MOVEQ.l #$00,D4
  MOVE.b $12(A2),D4
  SUBI.w #$13,D4
  ADDQ.w #2,D4
  ANDI.w #$FFFC,D4     ;long align
  MOVE.l D4,D5
  LSR.w #2,D5
  MOVE.l D5,temp1
  LSL.w #2,D5          ;#bytes
  ; new >
  MOVE.l #temp1,a1
  ; < new
  ;move.l #temp1,D2
  ; new >
  LEA debugstore,a0
  MOVE.l (a1),(a0)+
  ; < new
  MOVEQ.l #$04,D3
  ;move.l D7,D1
  ;bsr.w mywrite
  ;
  LEA $13(A2),A1
  ; new >
  MOVE.l d4,d1
  SUBQ.l #1,d1

 'l10d
    MOVE.b (a1)+,d0
    BEQ 'l21d
    CMP.b #"'",d0                                            ; ' does reassembler/assembler not like, so replace
    BNE 'ok
    MOVE.b #"_",d0

 'ok
   MOVE.b d0,(a0)+                                      ; copy labeltext to debuginfo
  DBF d1,'l10d

  BRA 'l22d

 'l21d
      CLR.b (a0)+
  DBF d1,'l21d

 'l22d
  ADD.l d4,d3
  ; < new
  ;move.l A1,D2
  ;move.l D4,D3
  ;move.l D7,D1
   ;bsr.w mywrite
  ;
  SUB.l D4,D5
   BEQ.w 'deoff
  ; new >
  MOVE.l #zero,a1
  ; < new
  ;move.l #zero,D2
  ; new >
  MOVE.l (a1),(a0)+
  ; < new
  ;move.l D5,D3
  ; new >
  ADD.l d5,d3
  ; < new
  ;move.l D7,D1
   ;bsr.w mywrite

 'deoff
  MOVE.l $8(A2),D2
  SUB.l destbufferstart,D2
  SUB.l noinits,D2
  MOVE.l D2,temp1
  ; new >
  MOVE.l #temp1,a1
  ; < new
  ;move.l #temp1,D2
  ; new >
  MOVE.l (a1),(a0)+
  ADD.l #4,d3
  LEA debugstore,a0
  MOVE.l a0,d2
  ; < new
  ;moveq.l #$04,D3
  MOVE.l D7,D1
  BSR.w mywrite

 'denext
  MOVEA.l (A2),A2
 BRA.w 'deloop

 'dedone
  MOVE.l #zero,D2
  MOVEQ.l #$04,D3
  MOVE.l D7,D1
  BSR.w mywrite

 'nodebug
  MOVE.l D7,D1
  MOVE.l #tstdone,D2                                      ;hunkend
  MOVEQ.l #$04,D3
  ; new >
  CMPI.l #-1,bssstart
  BEQ 'l10e
  MOVEQ #16,d3
  MOVE.l #hunkend,d2
  CMPI.l #-1,chipstart
  BEQ 'l10e
  MOVE.l d7,d1
  MOVEQ #12,d3
  BSR.w mywrite

 'l10e
  CMPI.l #-1,chipstart
  BEQ 'l11e
  MOVEQ #12,d3
  MOVE.l #hunkend2,d2
  MOVE.l d7,d1
  BSR.w mywrite
  MOVE.l d7,d1
  MOVE.l chipstart,d2
  MOVE.l chipsize,d3
  BSR.w mywrite
  MOVEQ #4,d3
  MOVE.l #hunkend,d2
  MOVE.l d7,d1

 'l11e
  ; < new
  BSR.w mywrite
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  JSR _Close(A6)
  ;
  ; --
  ; -- create the optional icon for the executable
  ;.create_icon
  BTST #$7,create_iconfile
   BEQ.w 'done
  ;
  ;OK, create an icon for the object code!
  ;
  MOVEA.l ptr_newexefilename,A0

 'iloop
    TST.b (A0)+
  BNE.w 'iloop
  SUBQ.w #1,A0
  MOVE.l A0,-(A7)        ;to later null out!
  LEA str_infoextention2,A1

 'iloop2
    MOVE.b (A1)+,(A0)+
  BNE.w 'iloop2
  ;
  MOVE.l ptr_newexefilename,D1
  MOVEQ.l #-$02,D2
  MOVEA.l _dosbase,A6
  JSR _Lock(A6)
  MOVE.l D0,D1
  BEQ.w 'dildo      ;not exist                                    ;no icon exit so jump to create one  tomsmart1
  JSR _UnLock(A6)                                          ;OH!! there is a Icon so we must Unlock it  tomsmart1
 BRA.w 'ifail                                            ;and skip writing a Icon  tomsmart1

 'dildo
  MOVE.l ptr_newexefilename,D1
  MOVE.l #HUNK_RELOC_8__MODE_NEWFILE,D2
  MOVEA.l _dosbase,A6
   JSR _Open(A6)
  MOVE.l D0,D7
   BEQ.w 'ifail
  MOVE.l #icongfx_data,D2                                  ; icon graphics
  MOVE.l #icongfx_data_end-icongfx_data,D3                 ; length of gfx-data
  MOVE.l D7,D1
  MOVEA.l _dosbase,A6
  JSR _Write(A6)
  MOVE.l D7,D1
  JSR _Close(A6)

 'ifail
  MOVEA.l (A7)+,A0
  CLR.b (A0)

 'done        ; was skip createicon
  ; new >
  ; --
  ; -- restore offsets for extern debug
  TST.b exdebug
   BEQ 'fixdoneb
  MOVE.w dontwrite_nomemleft,D1
  BNE.w 'fixdoneb
  MOVE.l chipsize,d5
  MOVE.l bsssize,d3
  MOVE.l chipstart,d7
  MOVE.l bssstart,d6
  MOVEA.l hunkoffsetbase,A2
  MOVEA.l destbufferstart,A1
  MOVE.l A1,D2
  ADD.l noinits,D2
  CLR.l hunkoffsetnum

 'loop0b                ; copy savefile 'loop0
  CMPA.w #$0,A2
   BEQ.w 'fixdoneb
  MOVE.l $4(A2),D0
   LEA $0(a1,d0.l),a0
   MOVE.l (a0),d1
  TST.l d1
   BMI.w 'lm1f
  MOVE.b #0,newhunk
  CMP.l #-1,chipstart
  BEQ 'l10f
  CMP.l chipstart,d1
  BLT 'l10f
  MOVE.b #1,newhunk
  CMP.l chipend,d1
  BGE 'l110f
  ADD.l d7,(a0)
  ADD.l #$80000000,4(a2)
 BRA 'nowayb

 'l110f
  ADD.l d5,0(a0)

 'l10f
  CMP.l #-1,bssstart
    BEQ 'l11f
  CMP.l bssstart,d1
  BLT 'l11f
  CMP.l bssend,d1
  BGE 'l111f
  TST.b newhunk
  BEQ 'ln1f
  ADD.l d5,(a0)

 'ln1f
  ADD.l d6,(a0)
  ADD.l #$40000000,4(a2)
 BRA 'nowayb

 'l111f
  ADD.l d3,0(a0)

 'l11f
  ADD.l D2,(A0)                                            ;only normal code offsets restore

 'lm1f
  ADDQ.l #1,hunkoffsetnum

 'nowayb
  MOVEA.l (A2),A2
 BRA.w 'loop0b

 'fixdoneb                        ; end of copy
  ; < new
  MOVEM.l (a7)+,d2-d7/a2-a6

 'rts
RTS


addoff:
  ;add pc to list of offsets
  ;
  MOVE.l D2,-(A7)
  MOVE.l destpointer,D2
  SUB.l destbufferstart,D2
  BSR.w addhunkoffset
  MOVE.l (A7)+,D2
RTS


.addhunkoffset:  ; was addoff2 org source
  ;add d2 to linked list of all offsets
  ;
  MOVEM.l D0-D1/A0-A1/A6,-(A7)
  ; new >
  TST.b nohunkoffset
  BNE 'l10
  ; < new
  MOVEQ.l #$8,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  ; new >
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
  ; < new
  ;jsr do_AllocMem
  ;
  ADDQ.l #1,hunkoffsetcounter
  MOVEA.l D0,A0
  MOVE.l hunkoffsetbase,(A0)
  MOVE.l A0,hunkoffsetbase
  MOVE.l D2,$4(A0)

  ; new >
 'l10
  ; < new
  MOVEM.l (A7)+,D0-D1/A0-A1/A6
RTS


killoffs:
  ;kill all offsets
  ;
  CLR.l hunkoffsetbase
  MOVEA.l _execbase,A6
  MOVEA.l hunkoffsetbase,A2

 'loop
    CMPA.w #$0,A2
    BEQ.w 'skip

    MOVEA.l A2,A1
    MOVEQ.l #$08,D0
    MOVEA.l (A2),A2
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)

  BRA.w 'loop

 'skip
  CLR.l hunkoffsetcounter
RTS


cmakebuff:  Ds.l 6                                          ;dc.w 12 org source
cmakea5:    Ds.l 1
cmake:      Ds.w 1
cmakebak:   Ds.l 32                                         ;ds.b 128 org source


getchar: ; A5=sourcepos, return D0 = next char
  MOVE.l A5,lastsourcepos
  MOVE.w instringon,oldqflag
   ;bsr.w getcharb                                          ;gettokennum

  MOVEQ.l #$00,D0
  MOVE.b (A5)+,D0
  BEQ 'donea
  BPL 'stuffa
  LSL.l #8,D0
  MOVE.b (A5)+,D0
  MOVE.l a1,-(a7)
  LEA replacedat,a1
  Dc.w $4a71,$0a00                                         ;TST.w 0(a1,d0.l*2)
  BEQ 'l10
  Dc.w $3031,$0a00                                         ;MOVE.w 0(a1,d0.l*2),d0

 'l10
  ;MOVE.l d0,lasttoken
  MOVE.l (a7)+,a1
 BRA 'weiter

 'stuffa
  CMP.w #$22,D0
   BEQ.b 'swapquotea
  CMP.w #$3B,D0
   BNE.b 'donea
  TST.w instringon
   BNE.b 'donea

 'loopa
  MOVE.b (A5)+,D0
             BEQ 'l1
             CMP.b #":",d0
             BNE 'loopa                                ;:@
             CMP.b #"@",(a5)
             BNE 'loopa
             ADDQ #1,a5

 'l1
  MOVE.w D0,lastchar

 'donea
  BRA.s 'weiter

 'swapquotea
  NOT.w instringon

 'weiter
  MOVE.w D0,lastchar
  BEQ.w 'done
   BPL.w 'done2
  CMP.w ##TokenID_CNIF,D0
   BEQ.w 'cnif
  CMP.w ##TokenID_CSIF,D0
   BEQ.w 'csif
  CMP.w ##TokenID_CELSE,D0
   BEQ.w 'celse
  CMP.w ##TokenID_CEND,D0
   BEQ.w 'cend

 'done2
  TST.w skipcode
   BEQ.w getchar
  CMP.w #$7E,D0
   BEQ.w 'cmake                                            ;tilde
  CMP.w #$2,D0
   BNE.w 'notunpath
  MOVEA.l usedfrom,A5
  CLR.l usedfrom
 BRA.w getchar

 'notunpath
  CMP.w #$1,D0
   BNE.w 'done
    ;
    ;End of Cmake chars got
    ;
  MOVEA.l cmakea5(PC),A5
 BRA.w getchar

 'cmake
  TST.w cmake
   BNE.w 'done

  MOVEM.l D0-D7/A0-A6,-(A7)
  LEA cmake,a0                                            ;reass
  NOT.w (a0)
  LEA cmakebak(PC),A0
  LEA ptr_parameterstore,A1
  MOVEQ.l #$1F,D0

 'cmloop
    MOVE.l (A1)+,(A0)+
  DBF D0,'cmloop

 ;  BSR.w evalconst3                                      ;get constant into d3
   JSR evalconst3
  CMP.w #$7E,D0
   BNE.w syntaxerr
  MOVE.l A5,cmakea5                                      ;tilde
  LEA cmakebuff(PC),A0
  MOVE.l D3,D2
  BSR.w makelong
  ADDQ.b #1,(A0)
  LEA cmake,a0
  NOT.w (a0)                                               ;reass
  LEA cmakebak(PC),A0
  LEA ptr_parameterstore,A1
  MOVEQ.l #$1F,D0

 'cmloop2
    MOVE.l (A0)+,(A1)+
  DBF D0,'cmloop2

  MOVEM.l (A7)+,D0-D7/A0-A6
  LEA cmakebuff(PC),A5
 BRA.w getchar

 'done
 RTS

 'csif
  MOVE.l linenumat,ciflineat                               ;csif
  TST.w skipcode
   BEQ.w 'incnest
   BSR.w get1bytemain
   MOVE.l a1,-(a7)
   JSR do_csif
   MOVE.l (a7)+,a1
 BRA.w getchar

 'cnif
  MOVE.l linenumat,ciflineat                               ;cnif
  TST.w skipcode
   BEQ.w 'incnest
   BSR.w get1bytemain
   CMP.b #"@",d0
   BNE 'cnif_ok2
   BSR.w get1bytemain
   MOVE.b #1,incnif
   JSR findconstant2
   BEQ 'cnif_ok2

 'cnif_ok2
   MOVE.w fast,-(a7)
   CLR.b fast
   MOVE.l a1,-(a7)
   JSR do_cnif
   CLR.b incnif
   MOVE.l (a7)+,a1
   MOVE.w (a7)+,fast
 BRA.w getchar

 'incnest
  ADDQ.w #1,connest
 BRA.w getchar

 'celse
  MOVE.w connest,D0                                      ;celse
   BNE.w getchar
  NOT.w skipcode
 BRA.w getchar

 'cend
  SUBQ.w #1,connest                                      ;cend
   BPL.w getchar
  ADDQ.w #1,connest
  MOVEA.l concomsp,A0
  CMPA.l #concomstack,A0
   BEQ.w nociferr
  SUBQ.w #2,A0
  MOVE.l A0,concomsp
  MOVE.w (A0),skipcode
BRA.w getchar


ciflineat:   Ds.l 1


getcharb:
    ;
    ;get next character into d0... a5=charpointer
    ;set hi bit if token, and lo 15 bits to token number (0-32767)
    ;
  MOVEQ.l #$00,D0
  MOVE.b (A5)+,D0
   BEQ.b 'done
   BPL.b 'stuff
  LSL.w #8,D0
  MOVE.b (A5)+,D0
 RTS

 'stuff
  CMP.w #$22,D0
   BEQ.b 'swapquote
  CMP.w #$3B,D0
   BNE.b 'done
  TST.w instringon
   BNE.b 'done

 'loop
  MOVE.b (A5)+,D0
            BEQ 'loop_l1
            CMP.b #":",d0
            BNE 'loop
            CMP.b #"@",(a5)
            BNE 'loop

 'loop_l1
  MOVE.w D0,lastchar

 'done
 RTS

 'swapquote
  NOT.w instringon
RTS


get1byte_:                                                 ;getchar2 org source  ;as above and skip spaces
  BSR.w getchar
  TST.w instringon
   BNE.w 'skip
  CMP.w #$20,D0        ;' '
   BEQ.w get1byte_

 'skip
RTS


gs:        Ds.w 13                                         ;ds.b 26  org source
           Dc.b $F6,$E4,$FC,$D6                            ;dc.b 228,246,252,196,214,220 org source
           Dc.b $C4,$DC

Even

.get1bytemain:                                             ;getchar3 org source    ;as above. return z=1 if 0 or ':'
  ;bsr.w get1byte_
  ; new >
  BSR.w getchar

  TST.w instringon
  BNE.w gchar2
    CMP.w #$20,D0               ; 32 " "
    BEQ.w get1bytemain
      ; < new
      TST.w D0
  gchar2:
  BEQ.b 'zero
    TST.w instringon
    BEQ.b 'noqoute
      CMP.b #$20,D0           ; 32 " "
      BCC.b 'skip
        MOVE.b gs(PC,D0.W),D0
        RTS
   'noqoute
    CMP.w ##TokenID_Else,D0                                         ;cmp #$8000+34,d0 org source  ;else
    BEQ.b 'zero
      CMP.w #$3A,D0             ;':'
      BEQ.b 'zero

   'skip
    TST.w D0

   'zero
RTS


reget:
  MOVE.w lastchar,D0
BRA.w gchar2


bakup:
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
RTS


storeloc:                                                  ;remember character pointer
  MOVE.w D0,locchar
  MOVE.l A5,locloc
RTS


resloc:                                                    ;recall char pointer....
  MOVEA.l locloc,A5
  MOVE.w locchar,D0
  MOVE.w D0,lastchar
RTS


.error_messages:
XINCLUDE "internal_errormsg.ab3"

ezerr:   Ds.w 1                                            ;for simple errors
            ;(ie not during compile)


.comperror   ;compile time error...


.handle_compileerror:                                      ;err org source
  ; new >
  MOVE.l myline,d0
  BNE 'l2
    CNIF #continue_on_error
      MOVE.l a5,lastsourcepos
    CEND
    SUBA.l a5,a5
 'l2

  TST.l usedfrom
  BEQ 'org
    MOVEA.l usedfrom,a5
 'org
  ; < new

  TST.w direct_mode
  BNE.b 'quiet

    MOVE.w ezerr(PC),D0
    BNE.w 'skip
      MOVE.w cfetchmode,D0
      BEQ.w 'skip2
        MOVE.l oldlibat,destbufferend                      ;fix up lib thing.
     'skip2
      MOVE.w constmode,D0
      BEQ.b 'skip3
        BSR.w asmerr2
     'skip3
      MOVE.l firstlocal,D1
      OR.l firstglob,D1
      BEQ.b 'notproc                                           ;?!?!?!
      ; new >
        TST.l CLIMode                                          ; test for climode, added to prevend the freeing of some datas this prevend false errors in climode with continue_on_error active  tomsmart1
        BNE 'notproc                                           ; yes skip
        ; < new
          JSR droplocals                                        ; no free some data ????
     'notproc
      MOVE.w #$FFFF,anyerrs                                    ;#-1,anyerrs org source
      ; new >
      CMP.l #"NORE",reqmode                                    ;for used functions
      BEQ 'notproc_l1
        ; < new
        MOVE.l linenumat,compilelinecounter
     'notproc_l1
      JSR close_compilewin
   'skip
    MOVEA.l (A7)+,A0
    ; new >
    MOVE.l errorcounter,d0                                   ; added to make maxerrorcount changable in CLIMode  tomsmart1
    CMP.l maxerrorcount,d0                                   ; changed to make maxerrorcount changable in CLIMode  tomsmart1
    BLT 'lesserror
      LEA errorlimit_text,a0
  'lesserror
    ADDQ.l #1,errorcounter

    JSR errorstringparse

    CMP.l #"NORE",reqmode                                    ;for used functions
    BEQ 'skip_Lxx2
      TST.l CLIMode
      BNE 'climode_output
       'guimode_output
        JSR save_errorfile
        BRA 'end_output
     'climode_output
        JSR stdout_error

        CNIF #continue_on_error
          MOVE.l errorcounter,d0                          ; added to make maxerrorcount changable in CLIMode  tomsmart1
          CMP.l maxerrorcount,d0                          ; changed to make maxerrorcount changable in CLIMode  tomsmart1
          BGT 'end_output
            MOVE.l lastsourcepos,a5

           'loop
              TST.b (a5)
              BEQ 'ok2
                MOVE.b (a5)+,d0                                  ; position to usefull source position to avoid following errors
                BEQ 'ok
                  CMP.b #":",d0
                  BEQ 'ok
            BRA 'loop
           'ok
            SUBQ.l #1,a5

           'ok2
            MOVE.w #0,lastchar
            MOVE.b #1,iserror
            MOVE.l stackaddr,a7
            RTS
        CEND
     'end_output

  ;-- show Error Requester
  MOVE.l A0,-(a7)
  !ComData_GetL{comFunc_ErrorRequest,A1}
  MOVE.l (a7)+,A0
  MOVEM.l d6/D7/A6,-(A7)
  MOVE.l includeline,d7
  MOVE.l #"INLN",a6
  MOVE.l errstack,tempa7
  JSR (A1)                                                  ;open ped errorrequest
  MOVEM.l (A7)+,D7/d6/A6

  MOVE.l tempa7,a7
  MOVEA.l errcont,A0
 RTS

 'skip_Lxx2
  MOVEA.l errstack,A7
  MOVEA.l errcont,A0
 ;JMP (A0)                                                  ;clear all vars
 RTS

  ; < new
 'quiet
  MOVE.l (A7),D0
  MOVEA.l errstack,A7
  MOVEA.l errcont,A0
JMP (A0)


tstalpha:
    ;tst if d0 is alphabetic
    ;return z=1 if yes
  CMP.w #$7A,D0                                            ;'z'
   BHI.w 'no
  CMP.w #$41,D0                                            ;'A'
   BCS.w 'no
  CMP.w #$61,D0                                            ;'a'
   BCC.w 'yes
  CMP.w #$5A,D0                                            ;'Z'
   BHI.w 'no

 'yes
  CMP.w D0,D0

 'no
RTS


tstlab:                                                   ; tst if d0 is a valid label character
                                                          ; eq=1 if yes
  !test_for_letter                                        ;bsr.w tstalpha
  BEQ.w 'skip
    !test_for_literal                                     ;bsr.w tstnum2
    BEQ.w 'skip
      CMP.w #$5F,D0                                       ;'_'
        BEQ.w 'skip
          CMP.w #$27,D0                                   ;''' ;#loclabch,d0 org source
 'skip
RTS


makename2:
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new

getparameter2:                                            ;makename org source
  ;pick up label name from a5...
  ;
  ;put into name buff, return len in d2 (eq if zero)
  ;
  ; new >
  MOVE.l a5,beforeparameterfetch
  ; < new
  LEA ptr_parameterstore,A1

makename3:
  MOVEQ.l #$00,D2

makename4:
  ; new >
  LEA chartab,a0
  MOVEQ #0,d0
  MOVE.l A5,lastsourcepos
  MOVE.w instringon,oldqflag

 'retry
    MOVE.b (a5)+,d0
  CMP.b #$20,d0                                            ;space deftype
  BEQ 'retry

  MOVE.w d0,lastchar
  TST.b 0(a0,d0.w)
  BNE 'done

  ;move.l a0,-(a7)
  ; < new
  ;cmp.w #$5F,D0                                            ;'_'
   ;beq.w 'loop
   ; new >
   ;test_for_letter                                                ;bsr.w tstalpha
   ; < new
   ;bne.w 'done
; 'oloop  ;not    quoteflag   ;force 'space' gets

 'loop
  MOVE.b D0,(A1)+
  ADDQ.l #1,D2
  ;
  ; new >
  MOVE.l A5,lastsourcepos

 'loop_ln1
  MOVE.b (a5)+,d0
  MOVE.b d0,lastchar+1
  CMP.b #$20,d0
  BEQ 'loop_l20

  TST.b 0(a0,d0)
  BEQ 'loop
  CMP.b #2,d0
  BNE 'loop_lf1
  MOVEA.l usedfrom,A5
  CLR.l usedfrom
 BRA 'loop_ln1

 'loop_lf1
  CMP.b #1,d0
  BNE 'loop_l20
  MOVEA.l cmakea5(PC),A5
 BRA 'loop_ln1

 'loop_l20
  CMP.b #$7e,d0
            BNE 'loop_lt
            TST.w cmake
            BNE.w 'loop_a1
            SUBQ.l #1,a5
            BSR.w get1bytemain
 BRA 'loop

 'loop_a1                                         ;??looks like double label??
 'loop_lt
 BRA 'loop_gpex

 'loop_old                                        ;tstlab org source ;??looks like a copy??
  ; < new
  BSR.w getchar
  ; new >
   !test_for_letter                                               ;bsr.w tstalpha
   BEQ.w 'loop_getp1
   !test_for_literal                                               ;bsr.w tstnum
   BEQ.w 'loop_getp1
  CMP.w #$5F,D0                                            ;'_'
   BEQ.w 'loop_getp1
  CMP.w #$27,D0                                            ;''';#loclabch,d0 org source

 ;'skip                                                   ;??Looklike dead label??
 'loop_getp1
      BNE 'loop_gpex
      CMP.b #$20,d0
      ; < new
      BNE.w 'loop
      ; new >
 'loop_gpex
     TST.b d0
     BPL 'loop_l10
     SUBQ.l #1,a5
     BSR get1byte_

 'loop_l10
  ; < new
  ;
  ;not    quoteflag   ;back to norm...
  ;not    oldqflag
  ;
   CMP.w #$20,D0
   BNE.w 'done
   ; new >
   MOVEQ #0,d0
  MOVE.l a5,lastsourcepos

 'loop_l103
  MOVE.b (a5)+,d0                                          ;neuneu
  BPL 'loop_l101
  ASL.w #8,d0
  MOVE.b (a5)+,d0

 'loop_l101
  TST.w instringon
  BNE 'loop_l102
  CMP.b #$20,d0
  BEQ 'loop_l103
  CMP.b #";",d0
  BNE 'loop_l102

 'loop_lr
  MOVE.b (A5)+,D0
             BEQ 'loop_l1
             CMP.b #":",d0
             BNE 'loop_lr                         ;:@
             CMP.b #"@",(a5)
             BNE 'loop_lr
             ADDQ #1,a5

 'loop_l1                                        ;??looks like double label?
 'loop_l102
  MOVE.w d0,lastchar
  ; < new
   ;BSR.w get1bytemain

 'done
  ; new >
  CMP.b #";",d0
  BEQ 'done_l11
  ; < new
  CLR.b (A1)
  ; new >
  ;move.l (a7)+,a0
  ; < new
  TST.w D2
 RTS

  ; new >
 'done_l11
  CLR.b (a1)
  MOVEQ #0,d0
  MOVE.w d0,lastchar
  ;move.l (a7)+,a0
  ; < new
  TST.w D2
RTS
  ;< new


findlast:                                                  ;??looks like not used??
  ;look for last entry in list from a2
  ;
  MOVE.l (A2),D0

 'loop
  BEQ.w 'here
  MOVEA.l D0,A2
 BRA.w 'loop

 'here
BRA.w reget


addhere2:
  ;insert at beginning
  ;
  MOVE.l (A2),-(A7)
  BSR.w addlabel
  MOVE.l (A7)+,(A2)
RTS


; new >
addlabelhash:                                              
  CLR.l fp0addr
  TST.w direct_mode
   BNE.w illdirerr
  MOVEQ.l #$00,D0
  MOVE.w D7,D0
  ADD.w D2,D0
  ADDQ.w #1,D0
  MOVE.w D0,D2
  ADDQ.l #2,d0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
   ;jsr do_AllocMem
  MOVE.l lastlabel,a2
  MOVE.l D0,(A2)
  MOVE.l d0,a0
  CLR.l (a0)
  MOVE.l a0,lastlabel
  MOVE.l d0,A2
  LEA -$1(A0,D7.W),A0
  MOVE.b D2,(A0)+
  LEA ptr_parameterstore,A1
  MOVEQ #0,d0
  MOVEQ #0,d1

 'loop2a
  MOVE.b (A1)+,d1
   BEQ 'l1
   !hashalgo
   MOVE.b d1,(A0)+
 BRA 'loop2a

 'l1
   CLR.b (a0)+
   LEA labelhash,a0
   AND.l #hashsize,d0
   ASL.l #2,d0
   MOVE.l 0(a0,d0),d1
   MOVE.l d1,$c(a2)
   MOVE.l a2,0(a0,d0)
   MOVEQ #0,d0
BRA.w reget


addvariable:
   TST.b newvariable
   BNE addlabel

 'l1
  TST.w direct_mode
   BNE.w illdirerr
  MOVEQ.l #$00,D0
  MOVE.w D7,D0
  ADD.w D2,D0
  ADDQ.w #1,D0
  MOVE.w D0,D2
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
  MOVEA.l D0,A0
   ;jsr do_AllocMem
  LEA varbase,a2
  MOVE.l (a2),(a0)
  MOVE.l A0,(A2)
  MOVEA.l A0,A2
  LEA -$1(A0,D7.W),A0
  MOVE.b D2,(A0)+
  LEA ptr_parameterstore,A1
  MOVEQ #0,d0
  MOVEQ #0,d1

 'l11
  MOVE.b (A1)+,d1
   BEQ 'l12
   !hashalgo
   MOVE.b d1,(A0)+
 BRA 'l11

 'l12
  CLR.b (a0)+
  LEA variablehash,a0
   AND.l #hashsize,d0
   ASL.l #2,d0
   MOVE.l 0(a0,d0),d1
   MOVE.l d1,$e(a2)
   MOVE.l a2,0(a0,d0)
   MOVEQ #0,d0
BRA.w reget
; < new

.addlabel:        ; was addhere org source
  TST.w direct_mode
   BNE.w illdirerr
  ;
  ;add namebuff after a2,d7
  ;
  ;d2=len of name, name in namebuff
  ;set a2 to address of struct
  ;
  MOVEQ.l #$00,D0
  MOVE.w D7,D0
  ADD.w D2,D0
  ADDQ.w #1,D0
  MOVE.w D0,D2
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  ; new >
  MOVE.l mempool2,a0
  JSR _AllocPooled(a6)
  ; < new
  ;jsr do_AllocMem
  ;
  MOVEA.l D0,A0
  MOVE.l A0,(A2)
  CLR.l (a0)              ;clear next
  ; new >
  CLR.l 8(a0)
  MOVEA.l A0,A2
  ; < new
  LEA -$1(A0,D7.W),A0
  MOVE.b D2,(A0)+          ;put in struct length
  LEA ptr_parameterstore,A1
  ; new >
  MOVEQ #0,d0
  MOVEQ #0,d1
  ; < new

 'loop2
  MOVE.b (A1)+,d1       ; was move.b  (a1)+,(a0)+                                              ;??looks like label not used anymore??
  MOVE.b d1,(A0)+       ; "
  BNE.w 'loop2
BRA.w reget


.findconstant:       ; was findinc org source
  MOVEQ.l #$13,D7
  LEA constantbase,A2
BRA.w findlab


findxinc:
  MOVEQ.l #$05+8,D7        ; was #5                                ;#5,d7 org source
  LEA xinclude_base,A2
BRA.w findlab


findconst_org:
  MOVEQ.l #$09,D7
  LEA firstconst,A2
BRA.w findlab


findmac:
  MOVEQ.l #$0d,D7                                          ;find macro
  LEA macrobase,A2
BRA.w findlab


.findlabel2:      ; was findadd  org source
  LEA labelhash,A2
  MOVEQ.l #$13,D7
  ; new >
  EXT.l d2
  LEA ptr_parameterstore,A0
  MOVEQ #0,d0
  MOVEQ #0,d1

 'l20
    MOVE.b (a0)+,d1
    BEQ 'l15
      !hashalgo
  BRA 'l20
 'l15
  AND.l #hashsize,d0
  ASL.l #2,d0
  MOVE.l 0(a2,d0),d0
  BRA 'l11

 'loop
    MOVE.l $c(A2),D0          ;  begin copy of findlabel

   'l11
    BEQ findlab_no
    MOVEA.l D0,A2
    MOVEQ.l #$00,D0
    MOVE.b -$1(A2,D7.l),D0
    LEA ptr_parameterstore,A0
    SUB.l D7,D0
    SUBQ.l #1,D0
  CMP.l D0,D2
  BNE.b 'loop

  LEA $0(A2,D7.W),A1
  SUBQ.l #1,D0

 'loop2
    MOVE.b (a1)+,d1
    CMP.b (a0)+,d1
    ;CMPM.b (A1)+,(A0)+
    BNE.b 'loop
  DBF D0,'loop2

  BSR.w reget
  CMP.w D0,D0
RTS                     ; end copy of findlab
  ; < new

findtype:
  MOVEQ.l #$0B,D7
BRA.w findlab


find_procedure:
  LEA firstproc,A2
  MOVE.l #$21+#funcentry_extend,D7    ; was #33,
BRA findlab


findfor:
  LEA firstfor,A2
  MOVEQ.l #$11,D7
BRA.w findlab


findvariable2       ; was findvar org source
  MOVEQ.l #$0F,D7
  ; new >
BRA.w findlab


findvariable:
  MOVEQ.l #$0F+4,D7
  TST.b newvariable
   BNE.w findlab
  LEA variablehash,A2
  LEA ptr_parameterstore,A0
  MOVEQ #0,d0
  MOVEQ #0,d1

 'l20
    MOVE.b (a0)+,d1
    BEQ 'l15
    !hashalgo
 BRA 'l20

 'l15
  AND.l #hashsize,d0
  ASL.l #2,d0
  MOVE.l 0(a2,d0),d0
 BRA 'l11

 'l10
  MOVE.l $e(A2),D0                                         ;find label

 'l11
  BEQ findlab_no
  MOVEA.l D0,A2
  MOVEQ.l #$00,D0
  MOVE.b -$1(A2,D7.W),D0
  LEA ptr_parameterstore,A0
  SUB.w D7,D0
  SUBQ.l #1,D0
  CMP.w D0,D2
   BNE.b 'l10
  LEA $0(A2,D7.W),A1
  SUBQ.l #1,D0

 'l201
    MOVE.b (a1)+,d1
    CMP.b (a0)+,d1
    ;CMPM.b (A1)+,(A0)+
    BNE.b 'l10
  DBF D0,'l201

  BSR.w reget
  CMP.w D0,D0
RTS
  ; < new


findlab:
  ;see if namebuff is in list at a2, char offset in d7
  ;z=1 if yes, a2=item loc
  ;if no, a2=last for link

 'loop
    MOVE.l (A2),D0                                         ;find label
    BEQ.b findlab_no
    MOVEA.l D0,A2
    MOVEQ.l #$00,D0
    MOVE.b -$1(A2,D7.W),D0
    SUB.l D7,D0
    SUBQ.l #1,D0
  CMP.w D0,D2
  BNE.b 'loop

  LEA $0(A2,D7.W),A1
  LEA ptr_parameterstore,A0
  SUBQ.l #1,D0

 'loop2
    MOVE.b (a1)+,d1
    CMP.b (a0)+,d1
    BNE.b 'loop
  DBF D0,'loop2

  BSR.w reget
  CMP.w D0,D0
  RTS

  findlab_no:
  BSR.w reget
  MOVEQ.l #-$01,D1
RTS


freeprocvs:
  MOVEA.l alllocals,A4
  CLR.l alllocals
  ; new >
; BRA 'done
  ; < new

 'loop
    CMPA.w #$0,A4
     BEQ.b 'done
    MOVEA.l $4(A4),A3
    ;BSR.w 'freevarsb       ; was freevars
    MOVEA.l $8(A4),A3
    ;BSR.w freevars
    MOVEA.l A4,A1
    MOVEA.l (A4),A4
    MOVEQ.l #$0C,D0
    MOVEA.l _execbase,A6
    ; new >
    MOVE.l mempool,a0
    JSR _FreePooled(A6)
    ; < new
    ;jsr freemem(a6)
 BRA.b 'loop

 'done
  ; new >
  CLR.l firstglob                                          ;fix 2*aclearallvar called
  CLR.l firstlocal
  CLR.l sharebase
  TST.l mempool2
  BEQ 'done_l10
  ;MOVE.l $4,a6
  MOVEA.l _execbase,A6
  MOVE.l mempool2,a0
  CLR.l mempool2
  JSR _DeletePool(a6)

 'done_l10
  MOVE.l _execbase,a6
  MOVE.l #$10000,d0
  MOVE.l #80000,d1
  MOVE.l d1,d2
  JSR _CreatePool(a6)
  MOVE.l d0,mempool2
  ; < new
RTS


freevars:
  ;free up var structs from a3 on
  CMPA.w #$0,A3
   BEQ.w 'done
  MOVEA.l A3,A1
  MOVEA.l (A3),A3
  MOVEQ.l #$00,D0
  MOVE.b $E(A1),D0
  MOVEA.l _execbase,A6
  ; new >
  MOVE.l mempool2,a0
  JSR _FreePooled(A6)
  ; < new
  ;jsr freemem(a6)
 BRA.w freevars

  ; new >
 'freevarsb
    CMPA.w #$0,A3
     BEQ.w 'done
    MOVEA.l A3,A1
    MOVEA.l (A3),A3
    MOVEQ.l #$00,D0
    MOVE.b $E+4(A1),D0
    MOVEA.l _execbase,A6
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
 BRA.w 'freevarsb
  ; < new

 'done
RTS


clearlabels: ; was freelabels org source
  ;free up label structs from firstlabel on...
  ;
  MOVEA.l currentlabeladdr,A0
  MOVE.l a0,lastlabel
  MOVEA.l (A0),A2
  CLR.l (A0)
  MOVEA.l _execbase,A6

 'loop
  CMPA.w #$0,A2
   BEQ.w 'done
  MOVE.l $4(A2),D0
  BTST #$0,D0
   BNE.w 'skip
  MOVEA.l D0,A3

 'loop2
    CMPA.w #$0,A3
     BEQ.w 'skip
    MOVEA.l A3,A1
    MOVEA.l (A3),A3
    MOVEQ.l #$0C+2,D0     ; was #12                                 ;cancel fix
    ; new >
    MOVE.l mempool,a0
    JSR _FreePooled(A6)
    ; < new
    ;jsr freemem(a6)
 BRA.w 'loop2

 'skip
  MOVEQ.l #$00,D0
  MOVE.b $12(A2),D0
  MOVEA.l A2,A1
  MOVEA.l (A2),A2
  ; new >
  MOVE.l mempool2,a0
   ;JSR _FreePooled(A6)                                     ;nofreemem
  ; < new
  ;jsr freemem(a6)
 BRA.w 'loop

 'done
RTS


freepends:
  MOVEA.l firstpend,A3
  CLR.l firstpend
  MOVEA.l _execbase,A6

 'fpnd2
    CMPA.w #$0,A3
     BEQ.w 'done
    MOVEA.l A3,A1
    MOVEQ.l #$08,D0
    MOVEA.l (A3),A3
    ; new >
    MOVE.l mempool,a0
    JSR _FreePooled(A6)
    ; < new
    ;jsr freemem(a6)
 BRA.w 'fpnd2

 'done
RTS


clearfunctionlist:  ; was freeprocs org source
  ;free up all proc structs
  ;
  MOVEA.l firstproc,A2
  CLR.l firstproc
  MOVEA.l _execbase,A6

 'loop
    CMPA.w #$0,A2
     BEQ.w 'done
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$00,D0
    MOVE.b $20+#funcentry_extend(A1),D0    ; was 32(a1),
    ; new >
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
    ; < new
    ;jsr freemem(a6)
 BRA.w 'loop

 'done
RTS


freetypes:
  ;free up type structs from a2 on
  CMPA.w #$0,A2
   BEQ.w 'done
  MOVEA.l $4(A2),A3
  CMPA.w #$FF,A3
   BEQ.w 'noway
  ;
  ;free offsets too
  ;
   BSR.w freevars

 'noway
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$00,D0
    MOVE.b $A(A1),D0
    MOVEA.l _execbase,A6
    ; new >
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
    ; < new
    ;jsr freemem(a6)
 BRA.w freetypes

 'done
RTS


fetchvars:
  ;find/create variable/struct from namebuff
  ;flagmask.0=1 if pointer
  ;
  ;get pointer to variable in a3, pointer to type in a2
  ;
  JSR usevars

  CLR.w notshared
  CLR.w varmode           ;local mode
  MOVE.w proceduremode,D1
   BNE.w fvarlocal
  ;
  LEA varbase,A2
  ; new >
  LEA ptr_parameterstore,a0
  CMP.b #$22,(a0)
  BNE fvarback
  MOVEQ #0,d0
 JMP error
  ; < new


fvarback:
  BSR.w findvariable

 'more
  BNE.w fvaradd

  ; new >
 'moreb
  ; < new
  MOVE.b flagmask+1,D1
  MOVE.b $7(A2),D3
  EOR.b D3,D1
  ; new >
  BNE 'l2
  CMP.b #2,nowdeclare
  BEQ errormsg_declaredtwice
 BRA.w fvarfound

 'l2
  ; < new
  BSR.w findlab
  ; new >
  BNE 'l1
  CMP.b #2,nowdeclare
  BEQ errormsg_declaredtwice
  CMP.w d0,d0

 'l1
  ; < new
 BRA.w 'more


fvaradd:
   MOVE.l a2,-(a7)
   LEA sharebase,a2
   MOVEQ #$f+4,d7
   BSR.w findlab
   BEQ 'l2x
   MOVE.l (a7)+,a2
 BRA 'cont

 'l2x
  ADDQ.l #4,a7
  CLR.w varmode
  MOVE.b flagmask+1,D1
  MOVE.b $7(A2),D3
  EOR.b D3,D1
  BNE vardeclareerr
 BRA fvarfound

 'cont
  ; < new
   MOVE.w nonew,D1
   BNE.w nonewerr
  ; new >
   TST.b nowdeclare
   BNE 'l2b
   TST.b declare2
   BEQ 'l1b
   CMP.b #$2e,d0
   BEQ 'l2b
   CMP.b #"$",d0
   BEQ 'l2b
 BRA vardeclareerr

 'l1b
  TST.b declare
   BNE vardeclareerr

 'l2b
  ; < new
  BSR.w addvariable      ;create var
  NOT.w notshared        ;set added flag
  MOVEA.l A2,A3
  MOVEA.l defaulttype,A2
  CMP.w #$2E,D0         ;'.'
   BEQ.w 'clapton
  CMP.w #$24,D0         ;'$'
   BNE.w 'usedef
  LEA newtype_string,A2
   BSR.w get1bytemain
 BRA.w 'usedef

 'clapton
  BSR.w getparameter2
  LEA newtypebase,A2
   BSR.w findtype
   BNE.w notypeerr

 'usedef
  CMPA.l #newtype_byte,A2
   BEQ.w 'byte
  MOVE.w varmode,D1
   BNE.w 'pit
  ADDQ.w #1,globalvarpointer

 'pit
  BCLR #$0,globalvarpointer+1

 'byte
  MOVE.l A2,$A(A3)           ;set type
  MOVE.w flagmask,$6(A3)                                  ;??????????
  MOVEQ.l #$04,D1
  BTST #$0,flagmask+1
   BNE.w 'skip3
  BTST #$1,flagmask+1
   BNE.w 'skip3
  CMPI.l #$100,$4(A2)
   BCC.w 'skip3
  MOVE.w $8(A2),D1

 'skip3
  TST.w varmode
   BEQ.w fvaradd_pit2
  NEG.w D1
  ADD.w D1,globalvarpointer
  MOVE.w globalvarpointer,$4(A3)
 RTS

 fvaradd_pit2:
  MOVE.w globalvarpointer,$4(A3)
  ADD.w D1,globalvarpointer
RTS


; new >
claptonb:                     ; is a copy of fvaradd 'clapton
   BSR.w getparameter2
  LEA newtypebase,A2
   BSR.w findtype
   BNE.w notypeerr

 'usedef
  CMPA.l #newtype_byte,A2
   BEQ.w 'byte
  MOVE.w varmode,D1
   BNE.w 'pit
  ADDQ.w #1,globalvarpointer

 'pit
  BCLR #$0,globalvarpointer+1

 'byte
  MOVE.l A2,$A(A3)              ;set type
  MOVE.w flagmask,$6(A3)                                  ;??????????
  ;MOVE.w #0,$6(A3)                                         ;??????????
  MOVEQ.l #$04,D1
  BTST #$0,flagmask+1
   BNE.w 'skip3
  BTST #$1,flagmask+1
   BNE.w 'skip3
  CMPI.l #$100,$4(A2)
   BCC.w 'skip3
  MOVE.w $8(A2),D1

 'skip3
  TST.w varmode
BRA.w fvaradd_pit2

;  NEG.w D1                                                 ;??looks like dead code??
;  ADD.w D1,globalvarpointer
;  MOVE.w globalvarpointer,$4(A3)
;RTS
; < new


fvarlocal:
  LEA firstglob,A2
   BSR.w findvariable2

 'more
  BNE.w 'hendrix
  MOVE.b flagmask+1,D1
  MOVE.b $7(A2),D3
  EOR.b D3,D1
   BEQ.w fvarfound
   BSR.w findlab
 BRA.w 'more

 'hendrix
  MOVE.w #$FFFF,varmode           ; was -1
  MOVE.w globalvarpointer,-(A7)
  MOVE.w locvaroff,globalvarpointer
  LEA firstlocal,A2
  ; new >
  MOVE.b #1,newvariable
  ; < new
   BSR.w fvarback
  ; new >
  CLR.b newvariable
  ; < new
  MOVE.w globalvarpointer,locvaroff
  MOVE.w (A7)+,globalvarpointer
RTS


fvarfound:
  MOVEA.l A2,A3
  ;
  ;var found, establish if type is correct!
  ;
  CMP.w #$2E,D0         ;'.'
   BEQ.w 'skipsh
  CMP.w #$24,D0         ;'$'
   BNE.w 'skip4
  CMPI.l #newtype_string,$A(A3)
   BNE.w rongtypeerr
   BSR.w get1bytemain
 BRA.w 'skip4

 'skipsh
   BSR.w getparameter2
  LEA newtypebase,A2
   BSR.w findtype
   BNE.w notypeerr
  CMPA.l $A(A3),A2
   BNE.w rongtypeerr

 'skip4
  BTST #$0,flagmask+1
   BEQ.w 'skipz
  ;
  BTST #$0,$7(A3)
   BEQ.w pointerr

 'skipz
  MOVEA.l $A(A3),A2
RTS


addd0a0:
   TST.l D3                                                ;newtype >32kb  .w to .l
   BEQ.w 'done2a
  ; new >
   MOVE.l destpointer,loada
   ;TST.b fast
   ;BNE 'done3a
 BRA 'done3a
                                                           ;??looks like dead code now??
  ; < new
  CMP.w #$9,D3                                             ;_addq_arrays
   BCC.w 'done3a
  ; new >
  MOVE.w d3,arrayoffset
  ; < new
  ANDI.w #$7,D3
  LSL.w #8,D3
  LSL.w #1,D3
  ANDI.w #$F1FF,addqa0
  OR.w D3,addqa0
  MOVE.w addqa0,D1
 BRA.w writeword

 'done3a
  ; new >
  CMP.l #$7fff,d3                                          ;>32kb newtypes
  BGT longoffset
  ; < new
  MOVE.w D3,leaa0a0+2
  ; new >
  MOVE.w d3,arrayoffset
  ; < new
  MOVE.l leaa0a0,D1                                       ; LEA $0000(A2),A2
  BSR.w writelong

 'done2a
RTS

; new >
longoffset
   MOVE.w #$d5fc,d1                                       ; add ??
   BSR writeword
   MOVE.l d3,d1
   BSR.w writelong
RTS
; < new

zarrchk:
  Dc.w $b0ad,0000                                          ;cmp.l $0(A5),D0    ;nooptimize

arrchk2:
   BCS.w arrchk3                                           
   JSR $20000                                              ;jsr 0
arrchk3



makeamul:
  ;
makelmul:                                                   ;make long multiply for array calc
  ;
  ; new >
  TST.b fast
  BEQ 'l1
    MOVEQ #0,d1                                             ;faster arrays
    MOVE.w regnum,d2
    MOVE.w d2,d1
    LSL.w #8,d1
    LSL.w #4,d1
    ADD.w d2,d1
    OR.l #$4c2d0000,d1
    TST.w varmode
    BEQ 'l1a
      BCLR #16,d1
   'l1a
  BSR writelong
  MOVE.w $4(A7),D1
  BSR.w writeword
  MOVE.w regnum,D1
  SUBQ.w #1,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$D080,D1
  OR.w regnum,D1
  BSR.w writeword
  RTS
 'l1
  ; < new
  MOVE.w regnum,D2
  ;
  MOVE.w arrmul1(PC),D1
  OR.w D2,D1
  SUBQ.w #1,D1
   BSR.w writeword
  MOVE.w arrmul2(PC),D1
  OR.w D2,D1
  MOVE.w D2,D3
  SUBQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w writeword
  MOVE.w arrmul3(PC),D1
  MOVE.w D2,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w pokewda5s
  MOVE.w $4(A7),D1         ; was 4+0
  ADDQ.w #2,D1
   BSR.w writeword
  ;
  MOVE.w arrmul4(PC),D1
  MOVE.w D2,D3
  SUBQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w pokewda5s
  MOVE.w $4(A7),D1       ; was 4+0
   BSR.w writeword
  ;
  MOVE.w arrmul5(PC),D1
  OR.w D2,D1
  SUBQ.w #1,D1
   BSR.w writeword
  MOVE.w arrmul6(PC),D1
  OR.w D2,D1
  SUBQ.w #1,D1
   BSR.w writeword
  MOVE.w arrmul7(PC),D1
  OR.w D2,D1
  SUBQ.w #1,D1
  MOVE.w D2,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w writeword
  MOVE.w arrmul8(PC),D1
  MOVE.w D2,D3
  SUBQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
   BSR.w writeword
  ;
  MOVE.w regnum,D1
  SUBQ.w #1,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$D080,D1
  OR.w regnum,D1
BRA.w writeword


    ;code for doing long array calculations.
    ;d1.w=this subscript, d0.l=array offset
    ;
    ;do a x(a5).l * d1 + d0.l
    ;
arrmul1:   MOVE.l d0,-(a7)                                ;write array access
arrmul2:   MOVE  d0,d0
arrmul3:   MULU 0(a5),d0                                  ;mulu   x+2(a5),d1  ;lo*lo
arrmul4:   MULU 0(a5),d0                                  ;mulu   x(a5),d0    ;hi*lo
;
arrmul5:   SWAP d0
arrmul6:   CLR d0
arrmul7:   ADD.l d0,d0
arrmul8:   MOVE.l (a7)+,d0

;arraynew   Dc.l $4c150000                                  ; MULU.l 0(a5),d0  ;new arrayaccess

;------                                                  ;disassembled code begin
listcode1:  Dc.b $24,$6D :              Dc.b $00,$00       ;MOVEA.L $0000(A5),A2      ;pointer to start of array data
listcode2:  Dc.b $24,$6A,$FF,$E0                           ;MOVEA.L -$0020(A2),A2     ;pointer to current
listarfix:  Dc.b $50,$4A                                   ;ADDQ.W  #8,A2
;------                                                  ;disassembled code end

Even
calcvar:
    ;used to optimize this...no more!
    ;
;calcvar2:                                                 ;??looks like label not used??
    ;use a3 = var, a2 = type, flagmask = flags.
    ;
    ;if bit 15 of d2 then code has been generated for
    ;address of thing in a2. else d3=offset from a5
    ;for simple variable.
    ;
    ;d2 & ff=type. 0=struct address
    ;
    ;bit 14 of d2=1 if result is a pointer
    ;
  CLR.l lastoffset_org
  BTST #$1,$7(A3)
  BEQ.w 'notarr
  MOVE.w notshared,D1
  BNE.w noarrerr
  BSR.w get1bytemain
  CMP.w #$29,D0
  BNE.w 'notalist
  BTST #$0,$6(A3)
  BEQ.w nolisterr
  MOVE.w $4(A3),listcode1+2
  MOVE.l listcode1(PC),D1
  BSR.w pokela5s
  MOVE.l listcode2(PC),D1
  BSR.w writelong
  TST.b debugmode
  BEQ.w 'nolrerr
    ;
    ;a2=0 error check
    ;
    MOVE.l A2,-(A7)
    MOVE.w #$C315,D1
    BSR.w Atokejsr
    MOVEA.l (A7)+,A2
 'nolrerr
  MOVE.w listarfix(PC),D1                                 ;addq #8,a2
  ;skip node.
  BSR.w writeword
  BRA.w 'normalar

 'listoff:
  Ds.w 1

 'notalist
  CLR.w 'listoff
  BTST #$0,$6(A3)
  BEQ.w 'knop
    MOVE.w #$0008,'listoff                            ;adjust size of one element if list.
 'knop
  MOVEM.l A2-A3,-(A7)
  MOVE.w varmode,-(A7)
  MOVE.w $8(A3),-(A7)                                       ;number of dims
  MOVE.w $4(A3),-(A7)                                       ;varoff
  MOVE.l A2,-(A7)
  MOVE.w flagmask,-(A7)
   ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  BSR.w arreval
  MOVE.w (A7)+,flagmask
  MOVE.w $8(A7),varmode
  TST.b debugmode
  BEQ.w 'noszchk
   ;BSR.w arrszchk                                        ;skip for dim >65536
 'noszchk
  MOVEA.l (A7)+,A2
  MOVEQ.l #$04,D1
  BTST #$0,flagmask+1                                      ;pointer?
  BNE.b 'domul                                             ;yes, then use 4 byte mul...
    MOVE.w $8(A2),D1
 'domul
  ADD.w 'listoff(PC),D1
  BSR.w muld1
  ADDQ.w #1,regnum

 'arloop
  ADDQ.w #4,(A7)
  TST.w $4(A7)
  BEQ.w 'isglob
    SUBQ.w #8,(A7)                                         ;range check local array
 'isglob
  TST.b debugmode
  BEQ.w 'noer1
    MOVE.w regnum,D1
    SUBQ.w #1,D1
    LSL.w #8,D1
    LSL.w #1,D1
    OR.w zarrchk(PC),D1
    BSR.w pokewda5s                                        ;cmp.l x(a5),D regat
    MOVE.w (A7),D1
    BSR.w writeword
    MOVE.l arrchk2(PC),D1
    BSR.w writelong
    MOVE.w #$C309,D1
    BSR.w Atokejsr
 'noer1
  SUBQ.w #1,$2(A7)
  BEQ.w 'ardone
    CMP.w #$2C,D0
    BNE.w syntaxerr
      TST.b fast
      BNE 'l1
        BSR.w arrevalchk
        BRA 'l2
     'l1
        BSR arreval
     'l2
    MOVE.w $4(A7),varmode
    BSR.w makeamul
    BRA.w 'arloop
 'ardone

  CMP.w #$29,D0
  BNE.w syntaxerr
  SUBQ.w #1,regnum
  ADDQ.w #6,A7
  MOVEM.l (A7)+,A2-A3
  MOVE.w $4(A3),movea5a0+2
  MOVE.l movea5a0,D1
  BSR.w pokela5s

  MOVE.w regnum,D1
  ORI.w #$D5C0,D1                                          ;add.l Dr,a2
  BSR.w writeword
  BTST #$0,$6(A3)
  BEQ.w 'normalar
    ;
    ;addq #8,a2 to skip node.
    ;
    MOVE.w listarfix(PC),D1
    BSR.w writeword
 'normalar

  BSR.w get1bytemain
  ;
  ;this shit added lately - after the major fucking crash!
  ;
  BTST #$0,$7(A3)
  BEQ.w 'noppnt
    CMP.w #$5C,D0
    BNE.w 'pmskip
      MOVE.w 'pfix(PC),D1
      BSR.w writeword
 'noppnt
  MOVE.w #$8000,D2
  BRA.w 'loopml

 'pmskip
  MOVE.w #$C000,D2
  BRA.w 'loopml

;------                                                  ;disassembled code begin
 'pfix:   Dc.b $24,$52                                   ;MOVEA.L (A2),A2
;------                                                  ;disassembled code end

 Even
 'notarr
  CMP.w #$28,D0
   BEQ.w noarrerr
  CMPI.l #$100,$4(A2)
   BCS.w 'simpvar
  BTST #$0,$7(A3)
   BEQ.w 'notap
    ;
    ;it's a pointer - is it a simple one?
    ;
  CMP.w #$5C,D0
   BEQ.w 'notap
  MOVEQ.l #$00,D2
 BRA.w 'simpvar2

 'notap
  MOVE.w #$8000,D2
  MOVE.w $4(A3),movea5a0+2
  MOVE.l movea5a0,D1
   BSR.w pokela5s                                         ;move.l x(a5),a2
                                                           ;check read pointer <=0
   TST.b debugmode
   BEQ.w 'skip
   MOVE.w #$c320,D1
   JSR Atokejsr

 'skip                                                     ;??looks liks double label??
 'loopml
  MOVEQ.l #$00,D3

 'loop0
  CMP.w #$5C,D0
   BNE.w 'done
  CMPI.l #$100,$4(A2)
   BCS.w rongtypeerr
  MOVE.w D2,-(A7)
   BSR.w getparameter2
   BEQ.w syntaxerr
  ADDQ.w #4,A2
   BSR.w findvariable2
   BNE.w noofferr
  MOVE.w (A7)+,D2
  MOVEA.l A2,A3                                             ;pointer to offset
  MOVEA.l $A(A3),A2                                         ;pointer to type
  MOVEQ #0,d1
  MOVE.w 4(a3),d1
  ADD.l d1,d3
  ;ADD.w $4(A3),D3                                          ;offset for newtype
  MOVE.l A3,lastoffset_org
  CMP.w #$5B,D0
   BNE.w 'realdone
  BTST #$1,$7(A3)                                           ;a array [] in newtype is found
   BEQ.w rongtypeerr
   BSR.w addd0a0
  MOVEM.l A2-A3,-(A7)
  MOVE.w varmode,-(A7)
  MOVE.l lastoffset_org,-(A7)
  MOVE.w pusha2,D1
  BSR.w writeword
  MOVEQ.l #$03,D2                                          ;was 2 >32kb types
  MOVE.l destpointer,deststore
  MOVE.l leftsidetype,-(a7)
  MOVE.l rightsidetype,-(a7)

  MOVE.w leftsideflagmask,-(a7)
  MOVE.w rightsideflagmask,-(a7)
  CLR.l rightsidetype
  CLR.l leftsidetype
  CLR.w leftsideflagmask
  CLR.w rightsideflagmask
  BSR.w eval
  MOVE.w (a7)+,rightsideflagmask
  MOVE.w (a7)+,leftsideflagmask
  MOVE.l (a7)+,rightsidetype
  MOVE.l (a7)+,leftsidetype

  CMP.w #$5D,D0
  BNE.w syntaxerr

  TST.b fast                                               ;a2,-(a7) array
  BEQ 'loop0_l10
    CNIF #optibreak
      ILLEGAL
    CEND
    MOVE.l destpointer,d1
    SUB.l deststore,d1
    CMP.l #4,d1
    BNE 'loop0_l10
    MOVE.l destpointer,a4
    MOVE.l -4(a4),-6(a4)
    SUBQ.l #2,destpointer
    CLR.l imm_addr
    CLR.l load_var_addr
    BRA 'loop0_l20
 'loop0_l10
    MOVE.w pulla2,D1
    BSR.w writeword
 'loop0_l20

  MOVE.l (A7)+,lastoffset_org
  MOVE.w (A7)+,varmode
  MOVEM.l (A7)+,A2-A3
    ;
    ;[] ***** error checking here! *****
    ;
    ;8(a3) = how many we can handle. special case for 0!
    ;
  TST.w debugmode
  BEQ.b 'nobchk
  MOVE.w $8(A3),D1
  BEQ.b 'nobchk                                   ;no [0] checks!
    ;
    ;ok, check regat<8(a3)
    ;
  MOVE.w D1,brchkcode+2
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w brchkcode0(PC),D1
  MOVE.w D1,brchkcode
  MOVE.l brchkcode(PC),D1
  BSR.w writelong
  MOVE.l brchkcode+4(PC),D1
  BSR.w writelong
  MOVE.w brchkcode+8(PC),D1
  BSR.w writeword
 'nobchk
  MOVEQ.l #$04,D1

  BTST #$0,$7(A3)
  BNE.w 'dothemul
    MOVE.w $8(A2),D1
 'dothemul
  BSR.w muld1

  MOVE.w addrega2,D1                                      ; ADDA.W  D0,A2
  OR.w regnum,D1
  OR.w #$100,d1                                           ; >32kb types
  BSR.w writeword

  BSR.w get1bytemain
  MOVEQ.l #$00,D3
  MOVE.w #$8000,D2
 'realdone
  BTST #$0,$7(A3)
  BNE.w 'pointer
    BRA.w 'loop0
 'pointer
  CMP.w #$5C,D0
  BNE.w 'done3
  TST.w D3
  BNE.w 'pskip
    MOVE.w movea0,D1
    BSR.w writeword
    BRA.w 'pmore
 'pskip
    MOVE.w D3,movea0a0+2
    MOVE.l movea0a0,D1
    BSR.w writelong
 'pmore

  BTST #$2,$7(A3)
  BEQ.w 'loopml
  MOVE.l adda0a0,D1
  BSR.w writelong
  BRA.w 'loopml

 'done3
  BSET #$E,D2
  BTST #$2,$7(A3)
   BNE.w 'done
  BSET #$D,D2

 'done
  CMPI.l #$100,$4(A2)
   BCC.w 'done2
  MOVE.b $7(A2),D2

 'done2
 BRA.w addd0a0

 'simpvar
  MOVE.w $6(A2),D2

 'simpvar2
  MOVE.w $4(A3),D3
  BTST #$0,$7(A3)
   BEQ.w 'nopoint
  BSET #$E,D2

 'nopoint
RTS


;------                                                  ;disassembled code begin
brchkcode0:  Dc.b $B0,$7C,$00,$00                          ;CMP.W   #$0000,D0
brchkcode:   Dc.b $B0,$7C :             Dc.b $00,$00       ;CMP.W   #$0000,D0
             Dc.b $65,$04                                  ;BCS.B   brchkcode_ok
             Dc.b $70,$02                                  ;MOVEQ   #$02,D0
             Dc.b $4E,$40                                  ;TRAP    #00
brchkcode_ok:
;------                                                  ;disassembled code end


;-----------Poking to Object code stuff-------------------;

pokewda5s:
  TST.w varmode
   BEQ.w writeword
  BCLR #$0,D1
BRA.w writeword

pokewda5d:                                                 ;??looks like not used??
  TST.w varmode
   BEQ.w writeword
  BCLR #$9,D1
BRA.w writeword

pokela5d:
  TST.w proceduremode
   BEQ.w writelong
  BCLR #$19,D1
BRA.w writelong

pokela5s:
  TST.w varmode
  BEQ.w writelong
  BCLR #$10,D1

.writelong:                                                ;pokel org source
; write 4 bytes in D1 to destpointer and increase
;  SWAP d1                                                ;code org source
;  BSR writeword
;poke1c:
;  SWAP d1
  ; new >
  ADDQ.l #1,destpointer                                   ; this is a copy of the writewordcode
  BCLR #$0,destpointer+3
  MOVEA.l destpointer,A4

  CMPA.l destbufferend,A4
  BCC.w 'overa
    MOVE.l D1,(A4)+
 'msa
    MOVE.l A4,destpointer
    CMPA.l bigpc(PC),A4
    BHI.w 'nbpa
      RTS
   'nbpa                                                     ; copied from writeword code  tomsmart1
    TST.w cfetchmode                                         ; to complete the subroutine
    BNE.w 'nbp2a                                             ;
      MOVE.l A4,bigpc                                        ;
   'nbp2a
    RTS
 'overa

  MOVE.w #$FFFF,dontwrite_nomemleft                                  ;#-1 org source
  CLR.b fast
  CLR.b fpu
  CLR.b iee                                                ; in writeword this is #2
  ADDQ.w #4,A4
  BRA.w 'msa
  ; < new


;.writeinstruction:                                        ;same as writeword replaced with writeword  tomsmart1
;  ADDQ.l #1,destpointer
;  BCLR #$0,destpointer+3
;  MOVEA.l destpointer,A4
;  CMPA.l destbufferend,A4
;   BCC.w writeword__over
;  MOVE.w D1,(A4)+
;
;  MOVE.l A4,destpointer
;  CMPA.l bigpc(PC),A4
;   BHI.w writeword__nbp
;RTS


.writeword:                        ;pokewd org source  ;poke d1.w into pc - not an opcode
  ADDQ.l #1,destpointer
  BCLR #$0,destpointer+3
  MOVEA.l destpointer,A4
  CMPA.l destbufferend,A4
  BCC.w 'over
    MOVE.w D1,(A4)+
 'ms
  MOVE.l A4,destpointer
  CMPA.l bigpc(PC),A4
  BHI.w 'nbp
    RTS
 'nbp
    TST.w cfetchmode
    BNE.w 'nbp2
      MOVE.l A4,bigpc
   'nbp2
      RTS

 'over
  MOVE.w #$FFFF,dontwrite_nomemleft                                  ;#-1 org source
  ADDQ.w #2,A4
  CLR.b fast
  CLR.b fpu
  CLR.b iee
BRA.w 'ms


writebyte:                                                 ;pokebyte org source
  MOVEA.l destpointer,A4
  CMPA.l destbufferend,A4
   BCC.w 'over
  MOVE.b D1,(A4)+

 'ms
  MOVE.l A4,destpointer
  CMPA.l bigpc(PC),A4
   BHI.w 'nbp
 RTS

 'nbp
  TST.w cfetchmode
   BNE.w 'nbp2
  MOVE.l A4,bigpc

 'nbp2
 RTS

 'over
  MOVE.w #-1,dontwrite_nomemleft
  ADDQ.w #1,A4
  CLR.b fast
  CLR.b fpu
  CLR.b iee
BRA.w 'ms


bigpc:   Ds.l 1


pokecode:                                                  ;a0=start of code to poke, a1=end
  MOVE.w (A0)+,D1
  BSR.w writeword

 'loop
    CMPA.l A1,A0
    BCC.w 'done
      MOVE.w (A0)+,D1
      BSR.w writeword
 BRA.w 'loop

 'done
RTS


pokecode2:
  MOVE.w (A0)+,D1
  BSR.w writeword
  CMPA.l A1,A0
  BCS.w pokecode2
RTS

;-----------End of poking to Object code------------------;


convert_byte_to_word:  ; was bytetoword                                              ;byte to word
  ; new
  TST.b iniffcommand
  BEQ 'l1
    MOVE.w #$4880,D1
    OR.w regnum,D1
    BSR writeword
 'l1
 ;  < new
RTS
  ;
  ;Below should ALWAYS be done when something is fetched
  ;

convert_byte_to_long:   ; was bytetolong
  BSR.w convert_byte_to_word

convert_word_to_long:   ; was wordtolong                                             ;word to long word_to_fpu
  ; new >
  TST.b iee
  BEQ 'old
  CMP.b #5,d2
  BEQ wtof

 'old
  ;< new
  MOVE.w #$48C0,D1                              ; EXT.L
  OR.w regnum,D1
BRA.w writeword

; new >
wtof
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2005000,d1
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
BRA writelong
; < new

convert_byte_to_quick:
  BSR.w convert_byte_to_word

convert_word_to_quick:
  MOVE.w #$4840,D1
  OR.w regnum,D1
   BSR.w writeword
  MOVE.w #$4240,D1
  OR.w regnum,D1
BRA.w writeword

; new >
convert_long2float                                                      ;long to fpu
  CMP.w #$ffdc,d1
  BNE 'negfpu
    MOVEQ #0,d0
    MOVE.w regnum,d0
    ASL.l #7,d0
    MOVE.l #$f2004000,d1                                     ; F203 4000 fmove.l d3, fp0
    OR.l d0,d1
    ASL.l #1,d0
    ASL.l #8,d0
    OR.l d0,d1
    BRA writelong
 'negfpu
  MOVEQ #0,d1
  MOVE.w regnum,d1                                         ;fpu neg
  ASL.l #7,d1
  OR.l #$f200001a,d1
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #8,d0
  ASL.l #2,d0
  OR.l d0,d1
  MOVE.l (a7)+,d0
BRA writelong
; < new


convert_byte_to_float:  ; was bytetofloat
   ; new >
   TST.b iee
   BNE wtof
   ; < new
   BSR.w convert_byte_to_long

bytetof2:
   MOVE.w #$FFDC,D1

fdo2:
   ; new >
   TST.b iee
   BNE convert_long2float
   ; < new
   MOVE.w D1,libjsr+2
   BSR.w savereg
  MOVE.l D4,D1
   BSR.w pokemovem
  MOVE.w #$C900,D1      ; #getffpbase,
   BSR.w Atokejsr
   BSR.w PutRegXToD0
  MOVE.l libjsr,D1
   BSR.w writelong
   BSR.w PutD0ToRegX
  MOVE.l D5,D1
BRA.w pokemovem

RTS ; dead old code

convert_word_to_byte:  ; was wordtobyte
  MOVE.w #$C317,D1     ;#wtobover
  ; new >
  TST.b typecheck
  BEQ 'l1
   TST.b notypecheck
   BNE 'l1
   TST.l lasttoken
  CNIF #assign_fulltypecheck
    BEQ typeerror
  CEND

 'l1                                                       ;??looks like double label??
  ; < new

overchk:
  ;d1=overflow check routine.
  TST.b debugmode
   BEQ.w 'skip
  BTST #$7,overflowcheck      ;;*** was 7! overflow checking?
   BEQ.w 'skip
  ;
  TST.w cfetchmode
   BNE.w 'skip
  ;
  TST.w regnum
   BEQ.w 'isok
  MOVE.w D1,-(A7)
  MOVE.w 'code1(PC),D1
   BSR.w writeword
  MOVE.w regnum,D1
  OR.w 'code3(PC),D1
   BSR.w writeword
  MOVE.w (A7)+,D1
   BSR.w 'isok
  MOVE.w 'code2(PC),D1
 BRA.w writeword

 'isok
  MOVEM.l D0-D7/A0-A6,-(A7)
   BSR.w Atokejsr
  MOVEM.l (A7)+,D0-D7/A0-A6

 'skip
 RTS

 'code1
  MOVE.l D0,-(A7)

 'code2
  MOVE.l (A7)+,D0

 'code3
  MOVE.l D0,D0



convert_word_to_float:  ; was wordtofloat
  BSR.w convert_word_to_long
  ; new >
  TST.b iee
  BEQ 'old
  CMP.b #5,d2
  BNE 'old
 RTS

 'old
 ; < new
BRA.w bytetof2

convert_long_to_byte:   ; was longtobyte
  MOVE.w #$C316,D1      ; #ltobover
  ; new >
  TST.b typecheck
  BEQ 'l1
  TST.b peekaddrsize
  BNE 'l1
  TST.b notypecheck
  BNE 'l1
  TST.l lasttoken
  CNIF #assign_fulltypecheck
    BEQ typeerror
  CEND

 'l1
 ; < new
BRA.w overchk

convert_long_to_word:   ; was longtoword
  MOVE.w #$C318,D1      ; #ltowover,
  ; new >
  TST.b typecheck
  BEQ 'l1
  TST.b peekaddrsize
  BNE 'l1
  TST.b notypecheck
  BNE 'l1
  TST.l lasttoken
  CNIF #assign_fulltypecheck
    BEQ typeerror
  CEND

 'l1
 ; < new
BRA.w overchk

convert_long_to_quick:  ; was longtoquick
  MOVE.w #$C318,D1      ;#ltowover,
  ; new >
  TST.b typecheck
  BEQ 'l1
  TST.b notypecheck
  BNE 'l1
  TST.l lasttoken
  CNIF #assign_fulltypecheck
    BEQ typeerror
  CEND

 'l1
  ; < new
  BSR.w overchk
BRA.w convert_word_to_quick

convert_long_to_float:   ; was longtofloat
BRA.w bytetof2

RTS ; dead old code

convert_quick_to_byte:     ; was quicktobyte
  MOVE.w #$C319,D1         ; #qtobover,
  ; new >
  TST.b typecheck
  BEQ 'l1
  TST.b notypecheck
  BNE 'l1
  TST.l lasttoken
  CNIF #assign_fulltypecheck
    BEQ typeerror
  CEND

 'l1
  ; < new
  BSR.w overchk

quicktob2:
  MOVE.w #$4240,D1
  OR.w regnum,D1
  BSR.w writeword
  MOVE.w #$4840,D1
  OR.w regnum,D1
BRA.w writeword

convert_quick_to_word:     ;was quicktoword
BRA.w quicktob2

convert_quick_to_long:     ; was quicktolong
  BSR.w quicktob2
BRA.w convert_word_to_long

; new >
 qtof                                                      ;quick to fpu
 'l2                                                       ;??Looks like double label??
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2004000,d1                                     ; F203 4000 fmove.l d3, fp0
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
  BSR writelong
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f23c4423,d1                                     ;fmul.s #1/65536,fpreg
  OR.w d0,d1
  BSR writelong
  MOVE.l #$37800000,d1
  BSR writelong
RTS
; < new

convert_quick_to_float:     ; was quicktofloat;
  ;put my own routine here
  ;
  ; new >
  TST.b iee
  BNE qtof
  ; < new
  MOVE.w #$D300,D1       ; #qutofl,

qtof2:
  MOVE.w D1,-(A7)
   BSR.w savereg
  MOVE.l D4,D1
   BSR.w pokemovem
  ;
   BSR.w PutRegXToD0
  MOVE.w (A7)+,D1
   BSR.w Atokejsr
  ;
   BSR.w PutD0ToRegX
  MOVE.l D5,D1
BRA.w pokemovem

RTS ; dead old code

convert_float_to_byte:      ; was floattobyte
  ; new >
  TST.b typecheck
  BEQ 'l1
  TST.b notypecheck
  BNE 'l1
  TST.l lasttoken
  CNIF #assign_fulltypecheck
   BEQ typeerror
  CEND

 'l1
  TST.b iee
  BNE ftol
  ; < new
  MOVE.w #$C31A,D1       ; #ftobover
  BSR.w overchk
  ;
  BSR.w floattolong2
BRA.w convert_long_to_byte

RTS ; dead old code

convert_float_to_word:    ; was floattoword
  ; new >
  TST.b typecheck
  BEQ 'l1
  TST.b notypecheck
  BNE 'l1
  TST.l lasttoken
 CNIF #assign_fulltypecheck
  BEQ typeerror
 CEND

 'l1
  TST.b iee
  BNE ftol
  ; < new
  MOVE.w #$C31B,D1         ; #ftowover
  BSR.w overchk
  ;
  BSR.w floattolong2
BRA.w convert_long_to_word

RTS  ; dead old code

convert_float_to_long:       ; was floattolong ;
  ; new >
  TST.b iee
  BNE ftol
  ; < new
  MOVE.w #$C31C,D1     ; #ftolover,
  BSR.w overchk

floattolong2:
  MOVE.w #$FFE2,D1     ; #-30,
BRA.w fdo2

;new >
ftol                                                      ;fpu to long
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2006000,d1
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
  MOVE.l (a7)+,d0
BRA writelong


ftoq                                                       ;fpu to quick
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
  MOVE.l #$f23c4023,d1
  MOVE.w regnum,d0
  ASL.l #7,d0
  OR.l d0,d1
  BSR writelong
  MOVE.l #$00010000,d1
  BSR writelong
  MOVE.w regnum,d0
  ASL.l #7,d0
  MOVE.l #$f2006000,d1
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
  BSR writelong
  MOVE.l (a7)+,d0
RTS
; < new

RTS         ; dead old code


convert_float_to_quick:   ; was floattoquick;
  ;do my own routine here for float to quick conversion
  ;
  ; new >
  TST.b iee
  BNE ftoq
  ; < new
  MOVE.w #$C31B,D1    ; #ftowover,
  BSR.w overchk
  ;
  MOVE.w #$D301,D1    ; #fltoqu,
BRA.w qtof2


string_to_long:
  ; new >                                      ; allowed as calling parameter for blitzlibs and functions
   TST.b blitzparloop
   BNE 'l1
   TST.b funcparloop
   BNE 'l1
   BRA error_convert_types

 'l1
  CMP.b #2,optistring
  BEQ JLrts
  ; < new
  MOVE.w stol,D1
  BSR.w writeword
  ; new >
  CMPI.w #$2,sbgot
  ; < new
  BCS.w sbtolong                     ; was BRA
  ; new >
  MOVE.w ceos(PC),D1                 ; begin copy of sbtolong
  BSR.w writeword
  ;
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  CMPI.w #$2,sbgot
  BCS.w sbtolong_skip2
  MOVE.w a2offset,D3
  SUB.w thisstuse,D3
  CMP.w #$6,D3
  BNE.w 'lenonly
  OR.w movestst2,D1
  BSR.w writeword
  LEA movestst2+2,A0
  LEA movestst2f,A1
 BRA.w pokecode2

 'lenonly                                                ;OS call 2 strings fix
  OR.w movea7dn,D1
  BSR.w writeword
  MOVE.l #0,D1
BRA.w writeword                      ; end of copy
  ; < new


convtypef:
  ;as below, but regat+1 should be saved!
  ;
  ADDQ.w #1,fuckpos
  BSR.w writeconvertcode
  SUBQ.w #1,fuckpos
  ; new >
JLrts
  ;> new
RTS


writeconvertcode:                                          ;convtype org source   ;convert type d3 to d2
  MOVE.w D3,D1
  ; new >
  CMP.w #7,d1
  BLE 'ok
  JMP errorinternalconvert

 'ok
  ; < new
  SUBQ.w #1,D1
  MULU #$7,D1
  ADD.w D2,D1
  SUBQ.w #1,D1
  LSL.w #2,D1
  LEA convtable,A0
  MOVE.l $0(A0,D1.W),D1
  BEQ.w 'skip
    MOVEA.l D1,A0
  ; new >
    CMP.b #$ff,d3
    BEQ 'skip
  ; < new
 JMP (A0)

 'skip
RTS


usedfrom:  Ds.l 1


getparameter:                                             ; get vname org source
                                                          ; transfer chars to namebuff. set flagmask according
                                                          ; to array/pointer etc status
  CMP.w #"\",D0
  BNE.w 'skip0
    ; new >
    CMP.b #"\",(a5)
    BNE 'first
      MOVE.l A5,usedfrom
      LEA path2,A5
      BRA 'g1
   'first
    ; < new
    SUBQ.w #1,A5
    MOVE.l A5,usedfrom
    LEA usedpath,A5                                          ;read path
    ; new >
   'g1
    ; < new
    BSR.w get1bytemain
 'skip0
  CLR.w flagmask
  CMP.w #$2A,D0             ;'*'
  BNE.w 'skip
  MOVE.w #$0001,flagmask
 'more2
   BSR.w getparameter2

 'more
   BEQ.w syntaxerr
  CMP.w #$28,D0             ;'('
   BEQ.w 'setmask
  CMP.w #$2E,D0             ;'.'
   BEQ.w 'morem
  CMP.w #$24,D0             ;'$'
   BNE.w 'done
  ORI.w #$8,flagmask
   BSR.w storeloc
   BSR.w get1bytemain
 BRA.w 'morez


 'morem
  BSR.w storeloc
  MOVE.w D2,-(A7)
  LEA namebuff2,A1
   BSR.w makename3
   BEQ.w syntaxerr
  MOVE.w (A7)+,D2

 'morez
   MOVE.w D0,D1
   BSR.w resloc
   CMP.w #$28,D1             ;'('
   BNE.w 'done

 'setmask
  ORI.w #$2,flagmask

 'done
  RTS

 'skip
  CMP.w #$40,D0              ;'@'
  BNE.w 'skip2
    MOVE.w #$0005,flagmask
    BRA.w 'more2
 'skip2
  BSR.w makename2
BRA.w 'more


dopusha3:
  MOVE.w #$FED3,D1          ; #65235
   BSR.w uselib
  LEA pusha3,A0
  LEA pusha3f,A1
BRA.w pokecode


dopulla3:
  MOVE.w #$FED3,D1          ; #65235
   BSR.w uselib
  LEA pulla3,A0
  LEA pulla3f,A1
BRA.w pokecode


;------                                                  ;disassembled code begin
ceos:   Dc.b $42,$1B                                       ;CLR.B   (A3)+             ;*!
;------                                                  ;disassembled code end

Even
sbtolong:                                                 ;make sbase into a long
  ; new >
    CMP.b #2,optistring
   BEQ 'l10
  ; < new
   MOVE.w ceos(PC),D1
   BSR.w writeword                                         ;clr.b (a3)
  ;
  ; new >
 'l10
  ; new <
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  CMPI.w #$2,sbgot
   BCS.w sbtolong_skip2
  MOVE.w a2offset,D3                                       ;stackuse,d3 org source
  SUB.w thisstuse,D3
  CMP.w #$6,D3
   BNE.w 'lenonly
  OR.w movestst2,D1
   BSR.w writeword
  LEA movestst2+2,A0
  LEA movestst2f,A1
 BRA.w pokecode2

 'lenonly
   OR.w movea7dn,D1
   BSR.w writeword
  MOVE.l movea7dn+2,D1
  ; new >
;  CNIF #more6string
;    MOVE.w #$0008,d1
;    BSR writeword
;    MOVE.w #$2f6f,d1                                       ;native move.l 4(a7),8(a7)
;    BSR writeword    ; was writeinstruction  tomsmart1
;    MOVE.l #$00040008,d1
;    BSR writelong
;    MOVE.w #$588f,d1                                       ;native addq.l #4,a7
;    BSR writeword
;  RTS
;  CEND
  BSR writelong
  ; new >
 CNIF #more6string
   CMP.w #6,regnum
   BEQ 'l1
   TST.w stackpar
   BNE 'l1
   TST.b funcparloop
   BEQ 'l1
   MOVE.l #$48780000,d1
   BSR writelong

 'l1
 CEND
 RTS
  ; < new

sbtolong_skip2:        ;was 'skip
  ; new >
  CNIF #more6string
     MOVE.l d1,-(a7)
     CMP.w #6,regnum
     BEQ 'l1
     TST.w stackpar
     BNE 'l1
     TST.b funcparloop
     BEQ 'l1
     MOVE.l #$48780000,d1
     BSR writelong

    'l1
     MOVE.l (a7)+,d1
  CEND
  ; < new
   OR.w movestdn,D1
   BSR.w writeword
  MOVE.w #$FED3,D1        ;#65235
   BSR.w uselib
  MOVE.w $A(A1),D1
BRA.w writeword


unknown:    Ds.w 1

;------                                                  ;disassembled code begin
somecode:   Dc.b $0C,$80,$00,$01,$00,$00                   ;CMPI.L  #$00010000,D0
somecode2:  Dc.b $65,$00,$00,$08                           ;BCS.W   codeisok
            Dc.b $4E,$B9,$00,$00,$00,$00                   ;JSR $00000000
codeisok:
;------                                                  ;disassembled code end


arrevalchk:
  TST.b debugmode
  BEQ.w sharreval
 BSR.w arreval

arrszchk:
  MOVE.w somecode(PC),D1
  OR.w regnum,D1
  BSR.w writeword

  MOVEQ.l #$01,D1
  SWAP D1
  BSR.w writelong

  MOVE.l somecode2(PC),D1
  BSR.w writelong

  MOVE.w #$C309,D1          ; was #arrerr,
BRA.w Atokejsr


sharreval:
  MOVEQ.l #$02,D2
  MOVEQ.l #$00,D1
  MOVEQ.l #$00,D3
BRA.w maineval2


arreval:
  MOVEQ.l #$03,D2           ;getlong
  MOVEQ.l #$00,D1           ;no push
  MOVEQ.l #$00,D3           ;and convert
  MOVE.b notypecheck,-(a7)
  MOVE.b #1,notypecheck                                    ;typecheck need switch off for array offset calculation code
  JSR maineval2             ;2!* ;was bra
  ; new >
  MOVE.b (a7)+,notypecheck                                 ;now its switch to old state
RTS
  ; < new

bakpevalu:                                                 ;??looks like labe not used??
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  MOVEQ.l #-$01,D1
  MOVEQ.l #-$01,D3
BRA.w peval


bakpeval:
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
peval:                                                 ; write blitzlib function calls
  MOVEQ.l #-$01,D1
  MOVEQ.l #$00,D3
  ; new >
  MOVE.l leftsidetype,-(a7)
  MOVE.l rightsidetype,-(a7)
  MOVE.w leftsideflagmask,-(a7)
  MOVE.w rightsideflagmask,-(a7)
  CLR.l leftsidetype
  CLR.l rightsidetype
  CLR.w leftsideflagmask
  CLR.w rightsideflagmask
  ; < new
  JSR maineval                    ; was bra
  ; new >
  MOVE.w (a7)+,rightsideflagmask
  MOVE.w (a7)+,leftsideflagmask
  MOVE.l (a7)+,rightsidetype
  MOVE.l (a7)+,leftsidetype
RTS
  ; < new

bakevalu:
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
evalu
  MOVEQ.l #$00,D1
  MOVEQ.l #-$01,D3
BRA.w maineval


evalu2:
  MOVEQ.l #$01,D1
  MOVEQ.l #-$01,D3
BRA.w maineval


bakeval:
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new

eval:
  MOVEQ.l #$00,D1      ;no push
  MOVEQ.l #$00,D3

maineval:
    ;CLR.b isconstantvalue
    ;CLR.l lastconstantvalue
                                                                                                                                                                                                                                                        
    ;Big Evaluation routine.....
    ;
    ;d2 = type to collect - 0 if unknown
    ;
    ;d3 = 0 if conv to original type
    ;
    ;d1 = push result flag, 0 = no push, < 0 = push result
    ;     > 0 = push type when known
    ;
    ;result will be pushed anyway if using reg d6+
    ;
    ;if getting a string, then strings len is on stack
    ;(a long), and a3 points at arse end of string
    ;while D(regat) points to start of string
    ;
   CMPI.w #$6,regnum
   BCS.w maineval2
   ; new >
   MOVEQ #0,d1
   MOVE.l destpointer,a4

   CMPA.l destbufferend,A4
   BCC.w 'l2

   CMP.w #$2f0a,-2(a4)                                    ;bug is a move.l a2,-(a7) before (show temp calc)?
                                                          ;then put not to stack
   BNE 'l2
;   JSR linemessage
;   TST.l result
;   BEQ 'l2
BRA 'l1

 'l2
  ; < new
  MOVEQ.l #-$01,D1                                         ;do stackpar write

 'l1
  MOVE.w #$0006,regnum                                     ;write a func par To stack

maineval2:
  ;
  ;d2=type to get, d1=push flag (should I push result?)
  ;
  MOVE.w thisstuse,-(A7)
  MOVE.w a2offset,thisstuse
  ;
  MOVE.w stackpar,-(A7)
  MOVE.w D1,stackpar
  MOVE.w sbgot,-(A7)
  CLR.w sbgot                ;not pushed yet
  MOVE.w unknown(PC),-(A7)
  MOVE.w D3,unknown
  ;
  MOVE.w D2,-(a7)
  ; new >
  MOVE.w d2,mode
  ; < new
   BSR.w eval3
  MOVE.w (a7)+,d3            ;type asked for
   BEQ.w 'noconv
  MOVE.w unknown(PC),D1
   BNE.w 'noconv
  EXG.l D2,D3
  ; new >
   MOVE.l a2,-(a7)
   TST.b curtemplabel
   BEQ 'l10
   MOVE.l asmbuff,a2
   CMP.w #$c,$8(a2)
   BEQ 'l20
   CMP.w #$d,$8(a2)
   BEQ 'l20

 'l10
  CMP.w d2,d3
  BEQ 'l20
    BSR.w writeconvertcode
    CLR.b doimmediate
 'l20
  MOVE.l (a7)+,a2

 'noconv
  ; < new
  MOVE.w (A7)+,unknown
  MOVE.w stackpar,D1
  BEQ.w 'skipme
  BMI.w 'skipme
  ;
  ;push the type got.
  ;
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  CMP.w #$7,D2
  BNE.w 'hi1
    ; new >
    CMP.b #2,optistring
    BEQ 'hi1a
    ; < new
    MOVE.w D1,-(A7)
    OR.w getstlen,D1
    BSR.w writeword
    MOVE.w (A7)+,D1
 'hi1
  ADDQ.w #2,a2offset                                        ;lib mode to stack
  ;ORI.w #$7000,D1
  ;ADDI.w #$200,D1      ;moveq #x,dREGAT+1
  ;OR.w D2,D1
  ; new >
  MOVE.w #$3f3c,d1
  ; < new
  BSR.w writeword
  ;move.w pushut(PC),D1
  ;or.w regnum,D1
  ;addq.w #1,D1
  ; new >
  MOVE.w d2,d1
  MOVE.w d1,libmode
  ; < new
  BSR.w writeword
  ;
  CMP.w #$7,D2
  BNE.w 'skipme
    MOVE.w putstlen,D1
    OR.w regnum,D1
    BSR.w writeword
 'skipme
  CMP.w #$7,D2
  BNE.w 'notst
   ;
   ; new >
; CNIF #more6string
;   CMP.w #6,regnum
;   BEQ 'skipme_l1
;   TST.b funcparloop
;   BEQ 'skipme_l1
;   MOVE.l #$48780000,d1
;   BSR writelong
;
; 'skipme_l1
; CEND
  CMP.b #2,optistring
  BEQ 'skipme_l10
  ; < new
  ADDQ.w #4,a2offset     ;a length on da stack.....
  BSR.w sbtolong
  BRA.w 'notst2

  ; new >
 'skipme_l10
  CNIF #more6string
    CMP.w #6,regnum
    BEQ 'skipme_l10_l1
    TST.b funcparloop
    BEQ 'skipme_l10_l1
    MOVE.l #$48780000,d1
    BSR writelong

   'skipme_l10_l1
  CEND
  BRA.w 'notst2

 'hi1a
  ADDQ.w #2,a2offset
  BRA 'skipme
  ; < new

 'notst
  CMPI.w #$2,sbgot
  BCS.w 'notst2                                         ;correct stack
    MOVE.w ststfix(PC),D1
    BSR.w writeword
 'notst2
  MOVE.w (A7)+,sbgot
  ;
  MOVE.w stackpar,D1
  BPL.w 'skip
  ; new >
  CMP.b #7,d2
  BEQ 'notst2_l1
  TST.b funcparloop
  BEQ 'notst2_l1
  CMP.b #5,d2
  BNE 'notst2_skip
  TST.b fpu
  BEQ 'notst2_skip
  MOVE.l #$f2066700,d1                                     ;fmove.s fp6,d6
  JSR writelong
 'notst2_skip

  MOVE.w #$c4ff,d1                                         ;savetemp+regnum
  ADD.w parnum,d1
  JSR Atokejsr
  TST.w dontwrite_nomemleft
  BNE 'notst2_l1
    MOVE.l data1start,d1
    MOVE.l destpointer,a4
    ADD.l d1,-4(a4)
    MOVE.l destpointer,d1
    SUBQ.l #4,d1
    SUB.l destbufferstart,d1
    MOVE.l d2,-(a7)
    MOVE.l d1,d2
    JSR addhunkoffset
    MOVE.l (a7)+,d2
    BRA 'skip
 'notst2_l1
  ; < new
  ADDQ.w #2,a2offset
  MOVE.w pushd0wd,D1
  CMP.w #$3,D2                                             ;write parameter to stack
  BCS.w 'ok
  ADDQ.w #2,a2offset
  ; new >
  TST.b fpu
  BEQ 'notst2_nofpu
    CMP.w #5,d2
    BNE 'notst2_nofpu
    MOVEQ #0,d1
    MOVE.w regnum,d1
    ASL.l #7,d1
    OR.l #$f2276400,d1
    BSR writelong
    BRA 'skip
 'notst2_nofpu
  ; < new
  MOVE.w pushd0l,D1

 'ok
   OR.w regnum,D1
   BSR.w writeword                                         ;nat

 'skip
  MOVE.w (A7)+,stackpar
  MOVE.w (A7)+,thisstuse
RTS


thisstuse: Ds.w 1

;------                                                  ;disassembled code begin
ststfix:   Dc.b $58,$4F                                    ;ADDQ.W  #4,A7
pushut:    Dc.b $3F,$00                                    ;MOVE.W  D0,-(A7)
;------                                                  ;disassembled code end
Even

eval3:
  BSR.w eval4
  SUBI.l #$12,forthsp
RTS


eval4:
  MOVEQ.l #$01,D1
   ;BSR.w pushprec
  ; new >
  MOVEA.l precsp(PC),A1
  MOVE.l A0,(A1)+
  MOVE.w D1,(A1)+
  MOVE.l A1,precsp
  ; < new
  BSR.w calcloop

  TST.w D1
  BNE.w syntaxerr
  ;
  SUBQ.l #6,precsp           ;pop the prec set up
RTS


calcloop:  ; was eval5 org source
  BSR.w eval2

 'more
  MOVEA.l precsp(PC),A1
  CMP.w -(A1),D1
  BHI.w 'higher
    RTS
 'higher
  ;BSR.w pushprec
  ;
  ; new >
  MOVEA.l precsp(PC),A1
  MOVE.l A0,(A1)+
  MOVE.w D1,(A1)+
  MOVE.l A1,precsp
  ; < new
  MOVE.w D2,-(A7)
  ADDQ.w #1,regnum
  BSR.w calcloop               ;constant optimizer
  SUBQ.w #1,regnum
  MOVE.w (A7)+,D3
  MOVEM.l D1/A0,-(A7)
  BEQ.w 'skip
    BSR.w convtypef            ;could possibly fuck regat+1 !
 'skip
  BSR.w popprec
  BSR.w writecode
  ;
  ;O.K., lets check the forth stack to see if last
  ;two operators are constants!
  ;
  ;if so, we can JSR the routine to optimize into a constant!
  ;
  MOVEA.l forthsp(PC),A0
  MOVE.w -$2(A0),D1
  OR.w -$14(A0),D1
  MOVE.w D1,-$14(A0)
  BNE.w 'no

  MOVE.w dontwrite_nomemleft,D1
  BNE.w 'no
  ;
  ;YES! We can do it!
  ;
  ;Set up MOVE.l regat,d0
  ;
  ; new >
  MOVEA.l -$24(A0),A0

  !newcalc
  BEQ 'l10
    MOVEA.l forthsp(PC),A0
    MOVE.w -$18(A0),lasta6
    MOVE.l -$1C(A0),lasta6
    MOVEA.l -$24(A0),A0
    MOVE.l A0,destpointer
    MOVEA.l _mathffpbase,A6
    MOVEA.l ffplib,A1
    BRA 'cont1
 'l10
    ; < new
    MOVE.w #$2000,D1                              ; opcode: move.l d0,d0
    OR.w regnum,D1                                ; was regat(pc),
    BSR.w writeword
    ; new >
    TST.b fpu
    BEQ 'nofpu1
      MOVEQ #0,d1
      MOVE.w regnum,D1
      ASL.l #8,d1
      ASL.l #2,d1
      OR.l #$f2000000,d1                            ; opcode: fmove.x fp0       FPU-check: ok
      BSR writelong
   'nofpu1
    ; < new
    MOVE.w #$4E75,D1                              ; opcode: rts
    BSR.w writeword

    MOVE.w -$18(A0),lasta6
    MOVE.l -$1C(A0),lasta6
    MOVEA.l -$24(A0),A0
    MOVE.l A0,destpointer
    ;
    MOVEM.l D2/A5,-(A7)
    ;
    MOVEA.l _mathffpbase,A6
    MOVEA.l ffplib,A1
    MOVE.w $A(A1),D0
    LEA _mathffpbase,A5
    SUBA.w D0,A5
    ;
    JSR clear_Cache                                          ;neg +
    ; new >
    CLR.l load_var_addr
    CLR.l imm_addr
    TST.w dontwrite_nomemleft
    BNE '1
      ; < new
      ;TRAP #5
      JSR (A0)                                                 ;calc constant inline expression
   '1
    MOVEM.l (A7)+,D2/A5
    ;
    ;d0 has got constant!
    ;
    ; new >
 'cont1

  MOVE.b d2,isconstantvalue
  MOVE.l d0,lastconstantvalue
  ; < new
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1                                            ; opcode: move.l #x,dn
  CMP.w #$3,D2
  BCC.w 'ok
    ORI.w #$1000,D1
    BSR.w writeword
    MOVE.w D0,D1
    BSR.w writeword
    BRA.w 'mode
 'ok
    ; new >
    TST.b iee                                                ; fpu constant
    BEQ 'l10b
      CMP.b #5,d2
      BNE 'l10b
        TST.b fpu
        BEQ 'nofpu2
          MOVEQ #0,d1
          MOVE.w regnum,D1
          ASL.l #7,d1
          OR.l #$f23c5400,d1                                   ; opcode: fmove.d
          BSR writelong
          SUBQ.l #8,a7
          fmove.d fp0,0(a7)
          MOVE.l (a7)+,d1
          BSR writelong
        'nofpu2

        MOVE.l (a7)+,d1
        BSR writelong
        BRA 'mode
   'l10b
      ; < new
      BSR.w writeword
      MOVE.l D0,D1
      BSR.w writelong
 'mode
  ;Move #x,Dn
  ;
  ;clean up offset stack
  ;
  MOVEA.l forthsp(PC),A0
  MOVEA.l -$20(A0),A3
  MOVEA.l hunkoffsetbase,A2
  MOVE.l A3,hunkoffsetbase
  MOVEA.l _execbase,A6

 'loop
  CMPA.l A3,A2
  BEQ.w 'done
    SUBQ.l #1,hunkoffsetcounter
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEQ.l #$8,D0
    ; new >
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
    ; < new
    ;jsr freemem(a6)
  BRA.w 'loop
 'done
  MOVEA.l forthsp(PC),A0

 'no
  LEA -$12(A0),A0
  MOVE.l A0,forthsp
  ;
  MOVEM.l (A7)+,D1/A0
  BSR.w reget
BRA.w 'more


eval2:
  ;
  ; get 1 element and operator
  ; d1 = op prec, or 0 if .done
  ; a0 = operator address
  ;
  BSR.w getelement
  ; new >
  TST.w d0
  BEQ 'done
    CMP.b #",",d0
    BEQ 'done
      CMP.b #"@",d0                                            ;expandline @@
      BEQ 'done
        ; < new
        ;
        LEA operators,A0
 'loop
  TST.w (A0)
  BEQ.w 'done
    CMP.w (A0),D0
    BEQ.w 'found
      LEA $20(A0),A0
  BRA.w 'loop

 'done
  MOVEQ.l #$00,D1
RTS

 'found
  CMP.w #$3C,D0            ;<
  BNE.w 'notlt
    BSR.w get1bytemain
    CMP.w #$3D,D0          ;=
    BNE.w 'notlteq
      LEA ople,A0
      BRA.w 'found2
   'notlteq
    CMP.W #$3C,D0          ;<
    BNE.W 'nolshift
      LEA opls,A0
      BRA.w 'found2
   'nolshift

    CMP.w #$3E,D0          ;'>'
    BNE.w 'found3
      BRA.w 'isne
 'notlt

  CMP.w #$3E,D0           ;'>'
  BNE.w 'notqt
    BSR.w get1bytemain
    CMP.w #$3D,D0          ;'='
    BNE.w 'notgteq
      LEA opge,A0
      BRA.w 'found2
   'notgteq
    CMP.W #$3E,D0          ;>
    BNE.W 'norshift
      LEA oprs,A0
      BRA.w 'found2
   'norshift
    CMP.w #$3C,D0          ;'<'
    BEQ.w 'isne

 'found3
    ;bsr.w bakup
    ; new >
    MOVE.w oldqflag,instringon
    MOVEA.l lastsourcepos,A5
    ; < new
  BRA.w 'found2

 'notqt
  CMP.w #$3D,D0          ;'='
  BNE.w 'found2
    BSR.w get1bytemain
    CMP.w #$3E,D0          ;'>'
    BNE.w 'noteqgt
      LEA opge,A0
      BRA.w 'found2
   'noteqgt
      CMP.w #$3C,D0          ;'<'
      BNE.w 'found3
     'isne
      LEA opne,A0
 'found2
  ;
  ;We've found the operator.
  ;
  MOVE.w $1E(A0),D1
RTS


writecode:                                                 ;doop org source
  ;a0=operator,d2=type
  ;
  ; new >
  ;CLR.b iniffcommand
  ; < new
  MOVE.w d2,d1
  SUBQ.w #1,D1
  BMI.w illoperr

  LSL.w #2,D1
  MOVE.l $2(A0,D1.W),D1
  BEQ.w illoperr

  MOVEA.l D1,A0
JMP (A0)


;pushprec:
  ;push operator on stack
  ;
  ;MOVEA.l precsp(PC),A1
  ;MOVE.l A0,(A1)+
  ;MOVE.w D1,(A1)+
  ;MOVE.l A1,precsp
;RTS


popprec:
  ;pull precedence into d1 from stack
  ;
  MOVEA.l precsp(PC),A1
  CMPA.l #precstackf,A1
   BCC.w pserr
  MOVE.w -(A1),D1
  MOVEA.l -(A1),A0
  MOVE.l A1,precsp
RTS


precsp:      Dc.l precstack
precstack:   Ds.l 63                                       ;ds 6*32 org source   ;Lotsa Room?
             Ds.l 33
precstackf:  ;


;-----------PLUS------------;

mseq:  SEQ D0
msne:    SNE D0
mslt:    SLT D0
msle:    SLE D0
msgt:    SGT D0
msge:    SGE D0

cmp0:    CMP.b D0,D0
cmp1:    CMP.w D0,D0
cmp2:    CMP.l D0,D0


do_equal_byte:
  MOVE.w cmp0(PC),D1
BRA.w doeqcmp2                                            ;writecompare


do_not_equal_byte:
  MOVE.w cmp0(PC),D1
BRA.w donecmp2


do_littler_byte:
  MOVE.w cmp0(PC),D1
BRA.w doltcmp2


do_littler_equal_byte:
  MOVE.w cmp0(PC),D1
BRA.w dolecmp2


do_greater_byte:
  MOVE.w cmp0(PC),D1
BRA.w dogtcmp2


do_greater_equal_byte:                                                ;??Looks like double label??
dogeb
  MOVE.w cmp0(PC),D1
BRA.w dogecmp2


do_equal_word:
  MOVE.w cmp1(PC),D1
BRA.w doeqcmp2


do_not_equal_word:
  MOVE.w cmp1(PC),D1
BRA.w donecmp2


do_littler_word:
  MOVE.w cmp1(PC),D1
BRA.w doltcmp2


do_littler_equal_word:
  MOVE.w cmp1(PC),D1
BRA.w dolecmp2


do_greater_word:
  MOVE.w cmp1(PC),D1
BRA.w dogtcmp2


do_greater_equal_word:
dogew                                                      ;??looks like double label??
  MOVE.w cmp1(PC),D1
BRA.w dogecmp2


do_equal_long:
  MOVE.w cmp2(PC),D1                                   ;writecomparelong
BRA doeqcmp2

do_not_equal_long:
  MOVE.w cmp2(PC),D1
BRA donecmp2


do_littler_long:
  MOVE.w cmp2(PC),D1
BRA.w doltcmp2


do_littler_equal_long:
  MOVE.w cmp2(PC),D1
BRA.w dolecmp2


do_greater_long:
  MOVE.w cmp2(PC),D1
BRA.w dogtcmp2


do_greater_equal_long:
  MOVE.w cmp2(PC),D1
BRA.w dogecmp2


cfregat:  Ds.w 1


docflib:
  MOVE.w D1,libjsr+2
   BSR.w savereg
  MOVE.l D4,D1
   BSR.w pokemovem
  MOVE.w #$C900,D1
   BSR.w Atokejsr
   BSR.w PutRegXToD0
  MOVE.l libjsr,D1
   BSR.w writelong
  MOVE.w regnum,cfregat
  CLR.w regnum
RTS


docflib2:                                                  
  MOVE.w cfregat,regnum
   BSR.w PutD0ToRegX
  MOVE.l D5,D1
BRA.w pokemovem


do_equal_float:                                            ;doeqf org source
   MOVEQ.l #-$2A,D1
   TST.b fpu
   BEQ 'nofpu
   MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVEQ.l #1,d2
   MOVE.w #1,d1                                            ;fpu comp fseq
   BSR writeword
 RTS

 'nofpu
   BSR.w docflib
   BSR.w doeqcmp
BRA.w docflib2


do_not_equal_float:                                        ;donef org source
  MOVEQ.l #-$2A,D1
  TST.b fpu
   BEQ 'nofpu
   MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #1,d2
   MOVE.w #$e,d1                                           ;fpu comp fsne
   BSR writeword
 RTS

 'nofpu
   BSR.w docflib
   BSR.w donecmp
BRA.w docflib2


do_littler_float:                                          ;doltf org source
  MOVEQ.l #-$2A,D1
    TST.b fpu
   BEQ 'nofpu
   MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #$1,d2
   MOVE.w #$14,d1                                          ;fpu comp fslt
   BSR writeword
 RTS

 'nofpu
   BSR.w docflib
   BSR.w doltcmp
BRA.w docflib2


do_littler_equal_float:                                    ;dolef org source
  MOVEQ.l #-$2A,D1
  TST.b fpu
  BEQ 'nofpu
    MOVEQ #0,d1
    MOVE.w regnum,d1
    MOVE.l d1,d2
    ASL.l #7,d1
    ADDQ  #1,d2
    ASL.l #8,d2
    ASL.l #2,d2
    OR.l d2,d1
    OR.l #$f2000038,d1
    JSR writelong
    MOVE.w #$f240,d1
    OR.w regnum,d1
    BSR writeword
    MOVE.l #1,d2
    MOVE.w #$15,d1                                          ;fpu comp fsle
    BSR writeword
    RTS
 'nofpu
  BSR.w docflib
  BSR.w dolecmp
BRA.w docflib2


do_greater_float:                                          ;dogtf org source
  MOVEQ.l #-$2A,D1
   TST.b fpu
   BEQ 'nofpu
    MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #1,d2
   MOVE.w #$12,d1                                          ;fpu comp fsgt
   BSR writeword
 RTS

 'nofpu
   BSR.w docflib
   BSR.w dogtcmp
BRA.w docflib2


do_greater_equal_float:                                   ;dogef org source
  MOVEQ.l #-$2A,D1
 TST.b fpu
   BEQ 'nofpu
   MOVEQ #0,d1
   MOVE.w regnum,d1
   MOVE.l d1,d2
   ASL.l #7,d1
   ADDQ  #1,d2
   ASL.l #8,d2
   ASL.l #2,d2
   OR.l d2,d1
   OR.l #$f2000038,d1
   JSR writelong
   MOVE.w #$f240,d1
   OR.w regnum,d1
   BSR writeword
   MOVE.l #1,d2
   MOVE.w #$13,d1                                          ;fpu comp fsge
   BSR writeword
 RTS

 'nofpu
   BSR.w docflib
   BSR.w dogecmp
BRA.w docflib2



do_equal_string:                                           ;doeqs org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w doeqcmp


do_not_equal_string:                                       ;dones org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w donecmp


do_littler_string:                                         ;dolts org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w doltcmp


do_littler_equal_string:                                   ;doles org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w dolecmp


do_greater_string:                                         ;dogts org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w dogtcmp


do_greater_equal_string:                                   ;doges org source
  MOVE.l #$CE00,D1
   MOVE.l d1,lastinstruction
   BSR.w Atokejsr
BRA.w dogecmp



cmpit:
  TST.b fast                                               ;compare
  BEQ 'org
  CNIF #optibreak
    ILLEGAL
  CEND
  MOVE.l destpointer,a0
  SUB.l imm_addr,a0
  CMP.l #6,a0
  BNE 'l11
  MOVE.l imm_addr,a0
  CMP.w #$223c,imm_addr
  BNE 'org
  ADD.w #$8e80,-6(a4)

 'l2b
  CLR.l imm_addr
 RTS

 'l11
  CMP.l #4,a0
  BNE 'l10
  CMP.b #2,d3
  BNE 'l11b
  ADD.w #$7e40,-4(a4)
 RTS

 'l11b
  ADD.w #$7e00,-4(a4)
 RTS

 'l10
   MOVE.l destpointer,a0
   SUB.l load_var_addr,a0
   CMP.w #4,a0
   BNE 'org
   CMP.b #3,d3
   BCS 'lv1
   CLR.l load_var_addr
   ADD.w #$9080-$200,-4(a4)
 RTS

 'lv1
  CMP.b #2,d3
   BNE 'org
   CLR.l load_var_addr
   ADD.w #$8040-$200,-4(a4)
 RTS

 'org                                               ;begin org source
  MOVE.w regnum,D3
  OR.w D3,D1
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
  ADDQ.w #1,D1
BRA.w writeword


doeqcmp2:
   BSR.w cmpit

 doeqcmp:
   MOVE.w mseq(PC),D1
BRA.w cpoke


donecmp2:
  BSR.w cmpit

 donecmp:
  MOVE.w msne(PC),D1
BRA.w cpoke


doltcmp2:
  BSR.w cmpit

 doltcmp:
   MOVE.w mslt(PC),D1
BRA.w cpoke


dolecmp2:
   BSR.w cmpit

 dolecmp:
   MOVE.w msle(PC),D1
BRA.w cpoke


dogtcmp2:
   BSR.w cmpit

 dogtcmp:
   MOVE.w msgt(PC),D1
BRA.w cpoke


dogecmp2:
  BSR.w cmpit

 dogecmp:
   MOVE.w msge(PC),D1

cpoke:
   OR.w regnum,D1
   CMP.w #5,d2
   BNE 'nod0
   CMP.w #5,d3
   BNE 'nod0
   MOVE.l d1,-(a7)
   MOVE.l #$44004a00,d1                                    ;68k neg.b:tst.b
   BSR writelong
   MOVE.l (a7)+,d1

 'nod0
   BSR.w writeword                                         ;writeseq
   MOVEQ.l #1,d2
   MOVE.l lasttoken,d1
    TST.b fast
    BEQ.s 'l11
   CMP.l ##TokenID_If,d1                                   ; $800b
   BEQ 'l10

 'l11
  MOVE.w #$4880,D1                                         ;ext.w D regat
  OR.w regnum,D1
   BSR.w writeword                                         ;writeext.w
  MOVEQ.l #$02,D2                                          ;type now WORD!

 'l10
RTS



do_plus_byte:                                              ;doplusb org source
  MOVE.w #$D040,D1
  MOVEQ.l #$02,D2                                          ;writeaddword   ;now a word
BRA.w doplus2


do_plus_word:                                              ;doplusw org source
  MOVE.w #$D040,D1
  MOVEQ.l #$03,D2                                          ;now a long
   BSR.w doplus2
BRA.w convert_word_to_long


do_plus_long:                                              ;doplusl org source  ;add regat+1 to regat
  MOVE.w #$D080,D1                                         ;writeaddlong

doplus2:
  MOVE.w d1,a1
  TST.b fast
  BEQ 'l10
  CNIF #optibreak
    ILLEGAL
  CEND
  ASR.w #8,d1
  CMP.b #$90,d1
  BEQ 'sub1
  CMP.b #$d0,d1
  BNE 'l10
  CMP.b #3,d3
  BCS 'lq10
  TST.b quickadd
  ;BNE 'lq1                                        ;????????????activate

 'lq10
   MOVE.l destpointer,a0
   CLR.b quickadd
   CLR.l load_var_addr
   SUB.l imm_addr,a0
   CMP.w #6,a0
   BEQ 'li10
   CMP.w #4,a0
   BNE.s 'li1
   CLR.l imm_addr
   ADD.w #$a040-$200,-4(a4)
 RTS

 'lq1
   MOVE.l a4,a0
   SUB.l load_var_addr,a0
   CMP.l #$a,a0
   BNE 'l10e
   CLR.l load_var_addr
   MOVE.w -$8(a4),d1
   MOVE.l -$4(a4),-$8(a4)
   MOVE.w d1,-$4(a4)
   SUB.w #$1980,-$a(a4)
   SUBQ.l #2,destpointer
 RTS

 'l10e
  CLR.b quickadd
 BRA 'l10

 'li10
   CLR.l imm_addr
   TST.l -4(a4)                                            ;skip If ADD.l #0,dx
   BNE 'doit
   SUBQ.l #6,destpointer
 RTS

 'doit
   ADD.w #$b080-$200,-6(a4)
 RTS

 'li1
   MOVE.l destpointer,a0
   SUB.l load_var_addr,a0
   CMP.w #4,a0
   BNE 'l10
   CMP.b #3,d3
   BNE 'lv1
   CLR.l load_var_addr
   ADD.w #$b080-$200,-4(a4)
 RTS

 'lv1
  CMP.b #2,d3
  BNE 'l10
  CLR.l load_var_addr
  ADD.w #$a040-$200,-4(a4)
 RTS

 'l10:
  MOVE.w regnum,D3
  MOVE.w a1,d1
  OR.w D3,D1
  ADDQ.w #1,D1
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
 BRA.w writeword

 'sub1
   CMP.b #3,d3
   BCS 'sub1_lq10
   TST.b quickadd
   ;BNE 'sub1_lqs1

 'sub1_lq10                                       ;??lookslike same code as 'lq10:
   MOVE.l destpointer,a0
   CLR.b quickadd
   CLR.l load_var_addr
   SUB.l imm_addr,a0
   CMP.w #6,a0
   BEQ 'sub1_li10
   CMP.w #4,a0
   BNE.s 'sub1_li1
   CLR.l imm_addr
   ADD.w #$6040-$200,-4(a4)
 RTS

 'sub1_lqs1
   MOVE.l a4,a0
    SUB.l load_var_addr,a0
    CMP.l #$a,a0
    BNE 'sub1_l10e
   CLR.l load_var_addr
   MOVE.w -$8(a4),d1
   MOVE.l -$4(a4),-$8(a4)
   MOVE.w d1,-$4(a4)
   SUB.w #$1b80,-$a(a4)
   SUBQ.l #2,destpointer
 RTS

 'sub1_l10e:                                       ;??looks like same code as 'l10e:
  CLR.b quickadd
 BRA 'sub1_l10

 'sub1_li10
   CLR.l imm_addr
   ADD.w #$7080-$200,-6(a4)
 RTS

 'sub1_li1                                        ;??looks like same code as 'li1:
   MOVE.l destpointer,a0
   SUB.l load_var_addr,a0
   CMP.w #4,a0
   BNE 'sub1_l10
   CMP.b #3,d3
   BNE 'sub1_lv1
   CLR.l load_var_addr
   ADD.w #$7080-$200,-4(a4)
 RTS

 'sub1_lv1                                       ;??looks like same code as 'lv1:
   CMP.b #2,d3
   BNE 'sub1_l10
   CLR.l load_var_addr
   ADD.w #$6040-$200,-4(a4)
 RTS

 'sub1_l10                                       ;??looks like same code as 'l10:
  MOVE.w regnum,D3
  MOVE.w a1,d1
  OR.w D3,D1
  ADDQ.w #1,D1
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
BRA.w writeword


do_plus_float_fadd1:
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ADDQ #1,d0
  ASL.w #8,d0
  ASL.w #2,d0
  MOVE.l #$f2000022,d1                                     ;fpu add
  OR.l d0,d1
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.l d0,d1
BRA.w writelong


 do_plus_float:                                            ;doplusf org source
    ;
    ;ffp add
    ;
  TST.b iee
  BNE do_plus_float_fadd1
  MOVE.w #$FFBE,D1                                         ;#-66,d1 org soruce ;floatadd

 doflib:
   MOVE.w D1,libjsr+2
   BSR.w savereg
  MOVE.l D4,D1
   BSR.w pokemovem
  MOVE.w #$C900,D1
   BSR.w Atokejsr
   BSR.w PutRegXToD0
  MOVE.l libjsr,D1
   BSR.w writelong
   BSR.w PutD0ToRegX
  MOVE.l D5,D1
BRA.w pokemovem


add_strings:                                               ;addstrings org source
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  MOVE.w D1,-(A7)
  CMP.w #3072,d1
  BEQ 'l1
  OR.w addcode,D1                                          ;move.l (a7)+,d0
BRA 'l2

 'l1
   MOVE.w #$588f,d1                                        ;addq.l #4,a7

 'l2
   BSR.w writeword
  MOVE.w (A7)+,D1
  OR.w addcode+2,D1                                        ;native string add.l d0,(a7)
BRA.w writeword


;-----------end of PLUS, start of MINUS---------;

do_minus_byte:
  MOVE.w #$9040,D1
BRA.w doplus2


do_minus_word:
  MOVE.w #$9040,D1
BRA.w doplus2


do_minus_long:
  MOVE.w #$9080,D1
BRA.w doplus2


do_minus_float:
   TST.b iee
    BNE 'fs1
  MOVE.w #$FFB8,D1                                         ;floatsub
BRA.w doflib

 'fs1                                      ;fpu sub
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ADDQ #1,d0
  ASL.w #8,d0
  ASL.w #2,d0
  MOVE.l #$f2000028,d1
  OR.l d0,d1
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.l d0,d1
BRA.w writelong


;-----------end of MINUS, start of TIMES---------;

do_times_byte:
  MOVE.w #$C1C0,D1
  MOVEQ.l #$02,D2                                          ;now a word
BRA.w doplus2


do_times_word:
  MOVE.w #$C1C0,D1
  MOVEQ.l #$03,D2                                          ;now a long.
BRA.w doplus2


do_times_quick:
  MOVE.w #$CA00,D1                                         ;quickmul
BRA.w domylib


do_times_long:
  TST.b fast
  BNE.s 'l10
    MOVE.w #$CA01,D1                                         ;writelongmul
    BRA.w domylib
 'l10
  ;bsr.w savereg

  mull
  ;move.l D4,D1
  ;bsr.w pokemovem
  ;bsr.w PutRegXToD0
  MOVE.l destpointer,a0
  SUB.l imm_addr,a0
  CMP.w #6,a0
  BNE 'li1
  MOVEQ.l #2,d1
  MOVEQ #1,d3

 'ag
    CMP.l -4(a4),d1
    BEQ 'oklsl
      LSL.l #1,d1
      ADD.l #1,d3
      CMP.l #9,d3
  BNE 'ag
  MOVE.w -2(a4),d1
  BSR writeword
  MOVE.w -6(a4),-4(a4)
  MOVE.l #$4c3c0800,-8(a4)                                ; MULU.L
  MOVE.w regnum,D3
  MULS #$1000,D3
  OR.w D3,-6(a4)
  CLR.l load_var_addr
  CLR.l imm_addr
  BRA 'li3

 'oklsl
  CMP.w #8,d3
  BEQ 'ok
    ASL.l #1,d3
    ASL.l #8,d3
    MOVE.w #$e188,d1                                        ;lsl.l #,dx
    OR.w d3,d1
    MOVE.w d1,-6(a4)
    BRA 'okls
 'ok
  MOVE.w #$e188,-6(a4)                                     ;lsl.l #,dx

 'okls
  MOVE.w regnum,d3
  OR.b d3,-5(a4)
  SUBQ.l #4,destpointer
  CLR.l load_var_addr
  CLR.l imm_addr
  BRA 'li3

 'li1
  MOVE.l destpointer,a0
  SUB.l load_var_addr,a0
  CMP.w #4,a0
  BNE 'li2
    MOVE.w -2(a4),d1
    BSR writeword
    MOVE.b #$4c,-6(a4)
    MOVE.w #$0800,-4(a4)
    MOVE.w regnum,D3
    MULS #$1000,d3
    OR.w D3,-4(a4)
    BRA 'li3
 'li2
    MOVE.l #$4c010800,d1                                   ; muls.l d1,d0: 68020+ only
    MOVE.w regnum,D3
    EXT.l d3
    MULS #$1000,d3
    OR.w D3,d1
    MULS #$10,d3
    ADD.l d3,d1
    BSR writelong
 'li3
  ;bsr.w PutD0ToRegX
  ;move.l D5,D1
RTS


domylib:
  MOVE.w D1,-(A7)
  BSR.w savereg
  MOVE.l D4,D1
  BSR.w pokemovem
  BSR.w PutRegXToD0
  MOVEQ #0,d1
  MOVE.w (A7)+,D1
  MOVE.l d1,lastinstruction
  BSR.w Atokejsr
  BSR.w PutD0ToRegX
  MOVE.l D5,D1
BRA.w pokemovem


do_times_float:
  TST.b iee
  BNE fm1
    MOVE.w #$FFB2,D1                                       ;floatmul
    BRA.w doflib
  fm1                                                       ;fpu mul
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ADDQ #1,d0
  ASL.w #8,d0
  ASL.w #2,d0
  MOVE.l #$f2000023,d1
  OR.l d0,d1
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.l d0,d1
BRA.w writelong


do_pow:
  MOVE.w D2,-(A7)                                          ;dopow
  MOVE.w D2,D3
  MOVEQ.l #$05,D2
  BSR.w convtypef
  ADDQ.w #1,regnum
  MOVE.w (A7)+,D3
  MOVEQ.l #$05,D2
  BSR.w writeconvertcode
  SUBQ.w #1,regnum
  BSR.w nocando

  TST.b fpu
  BEQ 'old
    MOVEQ #0,d1
    MOVE.w regnum,d1
    MOVE.l d1,d0
    ASL.w #7,d1
    ASL.w #8,d0
    ASL.w #2,d0
    OR.w d0,d1
    MOVE.l d1,-(a7)
    ;OR.l #$f2000014,d1                                      ;flogn.x fp0      ;fpu ^ pow
    OR.l #$f2000016,d1                                       ;flog2.x fp0      ;fpu ^ pow
    BSR writelong
    MOVE.w regnum,d0
    ADDQ #1,d0
    ASL.w #8,d0
    ASL.w #2,d0
    MOVE.l #$f2000023,d1
    OR.l d0,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.l d0,d1
    OR.l #$f2000023,d1                                      ;fmulx.x fp1,fp0
    BSR writelong
    MOVE.l (a7)+,d1
    ;OR.l #$f2000010,d1                                      ;fetox.x fp0
    OR.l #$f2000011,d1                                      ;ftwotox.x fp0
    BSR writelong
    RTS
'old
  MOVE.w #$6001,D1
BRA.w domylib


nocando:
    ;can't eval this as a const!
    ;
  MOVEA.l forthsp(PC),A0
  MOVE.w #$FFFF,-(A0)                                      ;#-1,-(a0) org source
RTS


;-----------end of times, start of mod-------;

do_mod_byte:
  MOVE.w #$D400,D1
BRA.w domylib


do_mod_word:
  MOVE.w #$D401,D1
BRA.w domylib


do_mod_long:
   BSR.w nocando                                           ;modlib uses an alibjsr here!
  MOVE.w #$D402,D1
BRA.w domylib


do_mod_quick:
  MOVE.w #$D403,D1
  MOVEQ.l #$02,D2                                          ;now a word.
BRA.w domylib


do_mod_float:
   BSR.w nocando                                           ;modlib lib uses an alibjsr!  ;domod float
  TST.b fpu
  BEQ 'old
  MOVEQ #0,d1
  MOVE.w regnum,d1                                         ;fpu mod
  MOVE.l d1,d0
  ADDQ.l #1,d1
  ASL.l #7,d0
  ASL.l #8,d1
  ASL.l #2,d1
  OR.l d0,d1
  MOVE.l d0,-(a7)
  OR.l #$f2000021,d1
  BSR writelong
  MOVE.l (a7)+,d0
 RTS

'old
  MOVE.w #$D404,D1
  MOVEQ.l #$03,D2                                          ;now a long
BRA.w domylib


;-----------end of mod, start of POWER OF----;

;-----------end of mod, start of DIVIDE------;

do_Div_byte:
  MOVE.w #$48C0,D1                                        ; optcode EXT.l d0
  OR.w regnum,D1
   BSR.w writeword
  ADDQ.w #1,D1
   BSR.w writeword

 do_Div_word:
   MOVE.w #$48C0,D1                                         ; opcode EXT.L d0
  OR.w regnum,D1
   BSR.w writeword
  MOVE.w #$81C0,D1
BRA.w doplus2


do_Div_long:                                                ;longdiv
  TST.b fast
  BNE.s 'l10
  MOVE.w #$CB01,D1
BRA.w domylib

 'l10
  CNIF #optibreak
    ILLEGAL
  CEND
  BSR.w savereg
  MOVE.l D4,D1
  BSR.w pokemovem
  BSR.w PutRegXToD0
;   MOVE.l destpointer,a4
;   MOVEQ.l #2,d1                                           ;have problem on negative float
;   MOVE.l d3,-(a7)                                         ;-18/8 =-3 should be -2
;   MOVEQ #1,d3
;
; 'ag
;       CMP.l -4(a4),d1
;       BEQ 'oklsr
;       LSL.l #1,d1
;       ADD.l #1,d3
;       CMP.l #9,d3
;       BNE 'ag
;   MOVE.l (a7)+,d3
   MOVE.l #$4c410800,d1
   BSR writelong

 'weit
  MOVE.w #$4e71,d1
  ;bsr writeword
  BSR.w PutD0ToRegX
  MOVE.l D5,D1
  BRA.w pokemovem

 'oklsr
  CMP.w #8,d3
  BEQ 'ok
    ASL.l #1,d3
    ASL.l #8,d3
    MOVE.w #$e080,d1
    OR.w d3,d1
    BRA 'oklsr2
 'ok
    MOVE.w #$e080,d1                                         ;lsr.l #,dx
 'oklsr2
  SUBQ.l #6,destpointer
  BSR writeword
  MOVE.l (a7)+,d3
  MOVEQ #0,d1
  CLR.l load_var_addr
  CLR.l imm_addr
BRA pokemovem


do_Div_quick:
  MOVE.w #$CB00,D1                                         ;quickdiv
BRA.w domylib


do_Div_float:
  TST.b iee
  BNE 'fdiv1
    MOVE.w #$FFAC,D1                                       ;floatdiv
    BRA.w doflib
 'fdiv1
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ADDQ #1,d0
  ASL.w #8,d0
  ASL.w #2,d0
  MOVE.l #$f2000020,d1                                     ;fpu div
  OR.l d0,d1
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.l d0,d1
BRA.w writelong

;-----------end of DIVIDE, start of AND-----------;
do_AND_byte:
  MOVE.w #$C000,D1
BRA.w doplus2


do_AND_word:
  MOVE.w #$C040,D1
BRA.w doplus2


do_AND_long:
  MOVE.w #$C080,D1
BRA.w doplus2

;-----------end if AND, start of OR---------------;
do_OR_byte:
  MOVE.w #$8000,D1
BRA.w doplus2


do_OR_word:
  MOVE.w #$8040,D1
BRA.w doplus2


do_OR_long:
  MOVE.w #$8080,D1
BRA.w doplus2

;-----------end if OR, start of EOR---------------;
do_EOR_byte:
  MOVE.w #$B100,D1

doeor2:
   MOVE.w regnum,D3
  OR.w D3,D1
  ADDQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
BRA.w writeword


do_EOR_word:
  MOVE.w #$B140,D1
BRA.w doeor2


do_EOR_long:
  MOVE.w #$B180,D1
BRA.w doeor2

;-----------end of OR, start of LSL---------------;
do_LSL:
  MOVE.w #$E1A8,D1
BRA.w shpoke

;-----------end of LSL, start of LSR--------------;
do_LSR:
  MOVE.w #$E0A8,D1
BRA.w shpoke

;-----------end of LSR, start of ASR--------------;
do_ASR:
  MOVE.w #$E0A0,D1
BRA.w shpoke
;-----------------end of ASR----------------------;
do_ROL_b:
  MOVE.w #$E138,D1
BRA.w shpoke

do_ROL_w:
  MOVE.w #$E178,D1
BRA.w shpoke

do_ROL_l:
  MOVE.w #$E1B8,D1
BRA.w shpoke

do_ROR_b:
  MOVE.w #$E038,D1
BRA.w shpoke

do_ROR_w:
  MOVE.w #$E078,D1
BRA.w shpoke

do_ROR_l:
  MOVE.w #$E0B8,D1
BRA.w shpoke



shpoke:
  MOVE.w D1,-(A7)
  ADDQ.w #1,regnum   ;make second a word!
  MOVE.w D2,-(A7)
  MOVE.w D2,D3
  MOVEQ.l #$02,D2

  ; new >
 'l1
   ;MOVE.b notypecheck,-(a7)
   ;MOVE.b #1,notypecheck
  ; < new
   BSR.w writeconvertcode
  ; new >
   ;MOVE.b (a7)+,notypecheck
  ; < new
  MOVE.w (A7)+,D2     ;type
  SUBQ.w #1,regnum
  CMP.w #$4,D2        ;don't fuck with quix
   BEQ.w 'skip
  MOVE.w D2,D3
  MOVEQ.l #$03,D2
   BSR.w convtypef    ;make first (and current) a long

 'skip
   MOVE.w (A7)+,D1
  ;
  MOVE.w regnum,D3
  OR.w D3,D1
  ADDQ.w #1,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,D1
BRA.w writeword

;-----------start of bittst-----------------;
_BitTst:
  MOVE.w #$0100,D1
   BSR.w dothebit
  ;
  MOVE.w regnum,D1
  ORI.w #$56C0,D1    ;sne regat
   BSR.w writeword
  ;
  MOVE.w regnum,D1
  ORI.w #$4880,D1    ;ext.w D regat
   BSR.w writeword
  ;
  MOVEQ.l #$02,D2    ;type now WORD!
RTS


_BitSet:
  MOVE.w #$01C0,D1

dothemip:
   BSR.w dothebit
  ;
  MOVEQ.l #$03,D2    ;type now LONG!
RTS


_BitClr:
  MOVE.w #$0180,D1
BRA.w dothemip


_BitChg:
  MOVE.w #$0140,D1
BRA.w dothemip


dothebit:
  MOVE.w D1,-(A7)
  ;
  ;make first a long
  ;
  MOVE.w D2,-(A7)
  MOVE.w D2,D3
  MOVEQ.l #$03,D2         ;first to long!
   BSR.w convtypef
  ;
  MOVE.w (A7)+,D3
  MOVEQ.l #$01,D2         ;second to byte!
  ADDQ.w #1,regnum
   BSR.w writeconvertcode
  SUBQ.w #1,regnum
  ;
  MOVE.w regnum,D1
  MOVE.w D1,D2
  ADDQ.w #1,D2
  LSL.w #8,D2
  LSL.w #1,D2
  OR.w (A7)+,D1
  OR.w D2,D1
BRA.w writeword        ;btst regat+1,regat


PutRegXToD0:               ;put regat to d0
  MOVE.w regnum,D1
  BEQ.w 'skip
    ORI.w #$2000,D1
    BSR.w writeword
    ADDI.w #$201,D1
    BSR.w writeword
 'skip
RTS


PutD0ToRegX:                 ;get regat from d0
  MOVE.w regnum,D1
  BEQ.w 'skip
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$2000,D1
    BSR.w writeword
 'skip
RTS


getelement:                                               ; code only when debuggercode is enabled
  ;TRAP #1
  ; new >
  CLR.b isconstantvalue
  CLR.l lastconstantvalue
  ; < new
  CMPI.w #$7,regnum
  BCS.w getelement2

  ; new >
  TST.b fpu
  BEQ.b 'nofpu
    MOVE.l #$f2277700,d1                                    ; fmove.d fp6,-(a7)
    BSR writelong
 'nofpu

  MOVE.w #$2F06,D1                                        ; d6 to stack
  ; < new
  ;MOVE.w #$3F06,D1                                       ; d6 to stack
  CMP.w #$3,D2
  BCS.w 'skip
    MOVE.w #$2F06,D1
 'skip
  BSR.w writeword
  MOVE.w D1,-(A7)
  ;
  SUBQ.w #1,regnum
  BSR.w getelement2

  ADDQ.w #1,regnum
  ;
  ; new >
  TST.b fpu
  BEQ.b 'nofpu1
    MOVE.l #$f2001b80,d1
    BSR writelong
 'nofpu1
  ; < new
  MOVE.w #$3E06,D1
  CMP.w #$3,D2
  BCS.w 'skip2
    MOVE.w #$2E06,D1
 'skip2
  BSR.w writeword
  ;
  MOVE.w (A7)+,D1
  ANDI.w #$F000,D1
  ORI.w #$C1F,D1
  JSR writeword
  ; new <

  TST.b fpu
  BEQ.b 'nofpu3
    MOVE.l #$f21f5700,d1                                     ;fmove.d (a7)+,fp6
    BRA writelong
 'nofpu3
  RTS
  ; < new


negate:
  BSR.w getelement2
  MOVE.w #$4440,D1
  CMP.w #$3,D2
   BCS.w 'doneg
  MOVE.w #$4480,D1
  CMP.w #$5,D2
   BCS.w 'doneg
  CMP.w #$6,D2
   BCC.w illoperr
  MOVE.w #$FFC4,D1   ; was -60
 BRA.w fdo2

 'doneg
  OR.w regnum,D1                                           ;negate
  ; new >
  CLR.l imm_addr
  ; < new
BRA.w writeword


bracket:                                                 ;eval between brackets
   BSR.w eval4
  CMP.w #")",D0
   BEQ.w 'done
  CMP.w #"}",D0
   BNE.w brackets_                                         ;syntax error brackets

 'done
BRA.w get1bytemain


notit:
  BSR.w eval4
  CMP.w #$5,D2        ; datatype string
  BCC.w illoperr

  MOVE.w regnum,D1
  ORI.w #$4640,D1     ; opcode "not.w"
  CMP.w #$3,D2
   BCS.w writeword
  EORI.w #$C0,D1
BRA.w writeword


fetch_Pi:
  MOVEQ.l #$05,D2         ;return Pi.;move.l #x,dnf

  TST.b fpu
  BEQ 'old
    JMP fpu_pi
 'old
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1
  BSR.w writeword         ;move.l #x,dn
  MOVE.l #$C90FDA42,D1
  BSR.w writelong
BRA.w get1bytemain


    ;stack contains.....
    ;pc.l,firstoff.l,optat.l,lasta6.w,0,constgot.w!
    ;
    ;18 bytes!

forthstack:  Ds.l 63                                       ;ds.b  18*32 org source
             Ds.l 63
             Ds.l 18
forthsp:     Dc.l forthstack


JUMP_checkcast     JMP checkcast
JUMP_syntaxerropt4 JMP syntaxerropt4

getelement2:
  ;
  ;recursive stuff first.....
  ;
   ;bsr.w get1bytemain
  ; new >
  !fget
  CMP.b #$7e,d0
  BNE 'noc
    SUBQ.l #1,a5
    BSR get1bytemain
 'noc

  CMP.b #"#",d0
  BNE 'ld1
    CMP.b #$22,(a5)
    BNE 'ld1
      JSR addimmi
 'ld1

  CMP.b #$22,d0
  BNE 'l11
   ;BTST #$d,vartype
   ;BNE 'ls1
   ;CMP.b #7,d2                                             ;long pointer string error
   ;BEQ 'ls1
   ;TST.b vartype+1
   ;BEQ 'ls1
   ; BRA error_convert_types
   'ls1
    NOT.w instringon
 'l11
   TST.b d0
   BPL 'l10
   LSL.w #8,d0
   MOVE.b (a5)+,d0                      ; get blitzlib instruction with returnvalue(called in functions/statement)
   MOVE.l d0,lasttoken
   MOVE.w d0,lastchar
   CLR.l rightsidetype                  ; blitzlibs do currently no type check
   CLR.w rightsideflagmask

 'l10
  ; < new
  CMP.w #"(",D0
   BEQ.w JUMP_checkcast                 ; was  beq bracket org source

  ; new >
 nocast:                                ; used from .checkcast
  ; < new
  CMP.w #"{",D0
  BEQ.w bracket

  CMP.w #$2D,D0         ;'-'
  BEQ.w negate

  CMP.w ##TokenID_Not,D0      ; was #(opnot-opabcd)/$1c+$8000+fnum,
  BEQ.w notit
  ;
  MOVEA.l forthsp(PC),A1
  CMPA.l #forthsp,A1
   BCC.w conmemerr
  ;
  MOVE.l destpointer,(A1)+
  MOVE.l hunkoffsetbase,(A1)+
  MOVE.l lasta6,(A1)+
  MOVE.w lasta6,(A1)+
  CLR.w (A1)+
  ;
  CLR.w (A1)+
  MOVE.l A1,forthsp
  ;
  ;First, we have stuff which won't fuck constgot
  ;
   ;bsr.w tstnum
  ; new >
   !test_for_literal
  ; < new
   BEQ.w fetchnum
  CMP.w #".",D0
   BEQ.w fetchfrac
  CMP.w #"#",D0
   BEQ.w fetch_Constant
  CMP.w #"$",D0
   BEQ.w fetch_HexValue
  CMP.w #"%",D0
   BEQ.w fetch_BinValue

  CMP.w ##TokenID_SizeOf,D0    ; was #$8000+47,
   BEQ.w fetch_SizeOf
  CMP.w ##TokenID_Pi,D0    ; was #$8007+tnum,
   BEQ.w fetch_Pi
  CMP.w ##TokenID_On,D0    ; was #$8000+tnum+18,
   BEQ.w fetch_On
  CMP.w ##TokenID_Off,D0    ; was #$8000+tnum+19,
   BEQ.w fetch_Off
  ;

  MOVE.w constmode,D1
   BEQ.w 'noasm
  ; new >
   !test_for_letter                                               ;bsr.w tstalpha
  ; < new
   BEQ.w fetchasm
  CMP.w #$5F,D0     ;'_'
   BEQ.w fetchasm
  CMP.w #$22,D0     ;'"'
   BEQ.w fetchqasm
  ;
 BRA.w syntaxerr

 'noasm
  MOVE.w cfetchmode,D1
  BEQ.w 'asmok
     BRA.w badconerr       ;we're trying to get a const here!
 'asmok

  NOT.w -(A1)    ;set forth stack type to non-const
  ;
  ;Here, we have stuff which will fuck it!
  ;
  ; new >
  !test_for_letter                                                ;bsr.w tstalpha
  ; < new
  BEQ.w variable
  CMP.w #$2A,D0     ;'*'
  BEQ.w variable
  CMP.w #$5C,D0     ;'\'
  BEQ.w variable
  CMP.w #$22,D0     ;'"'
  BEQ.w litstring
  BTST #$F,D0
  BNE.w f_unction
  CMP.w #"&",D0
  BEQ.w getvaraddr                                          ;jump to & address of var code
  CMP.w #"?",D0
  BEQ.w qmark
  ;
  ; new >
 ;.atmode_iff
  CMP.b #"@",d0
  BNE syntaxerr

  TST.b newsyntax
  BEQ JUMP_syntaxerropt4

  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1
  BSR.w writeword
  CMP.b #$22,(a5)
  BNE syntaxerr

  ADDQ #1,a5
  MOVEQ #0,d0
  CMP.b #1,d2
  BEQ 'l3b
  CMP.b #2,d2
  BEQ 'l2b
  CMP.b #4,d2
  BEQ error_convert_types

  MOVE.b (a5)+,d0
  BEQ syntaxerr
  CMP.b #$22,d0
  BNE 'l1
    MOVE.b #0,d0
    BRA 'do
 'l1
  ASL.l #8,d0
  MOVE.b (a5)+,d0
  BEQ syntaxerr
  CMP.b #$22,d0
  BNE 'l2
    MOVE.b #0,d0
    ASR.l #8,d0
    BRA 'do
 'l2
  ASL.l #8,d0

 'l2b
  MOVE.b (a5)+,d0
  BEQ syntaxerr
  CMP.b #$22,d0
  BNE 'l3
   MOVE.b #0,d0
    ASR.l #8,d0
    BRA 'do
 'l3
  ASL.l #8,d0

 'l3b
  MOVE.b (a5)+,d0
  BEQ syntaxerr
  CMP.b #$22,d0
  BNE 'l4
    MOVE.b #0,d0
    ASR.l #8,d0
    BRA 'do
 'l4
    CMP.b #$22,(a5)+
    BNE error4char
 'do
  MOVE.l d0,d1
  BSR writelong
  BSR get1bytemain
RTS
  ; < new


fetch_SizeOf:   ;was _SizeOf
  BSR.w get1bytemain
  CMP.w #$2E,D0     ; '.'
   BEQ.b sizeobj
  ;
  ;find size of a var!
  ;
   ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  MOVE.w D2,-(A7)
   BSR.w getparameter2
   BEQ.w syntaxerr
  LEA varbase,A2
   BSR.w findvariable
   BNE.w notypeerr         ;!

 'found
  MOVE.w $4(A2),D3
  EXT.l D3
  MOVE.w (A7)+,D2
BRA.w fetchnum2


sizeobj:
  MOVE.w D2,-(A7)
   BSR.w getparameter2
   BEQ.w syntaxerr
  LEA newtypebase,A2
   BSR.w findtype
   BNE.w notypeerr
  MOVEQ.l #$00,D3
  CMP.w #$5C,D0     ;'\'
   BNE.w 'jty
   BSR.w getparameter2
   BEQ.w syntaxerr
  LEA $4(A2),A2
   BSR.w findvariable2
   BNE.w noofferr
  MOVE.w $4(A2),D3
 BRA.w 'jty2

 'jty
  MOVE.w $8(A2),D3

 'jty2
  MOVE.w (A7)+,D2
BRA.w fetchnum2


fetch_On:
  MOVEQ.l #-$01,D3
  BSR.w get1bytemain
BRA.w fetchnum2


fetch_Off:
  MOVEQ.l #$00,D3
   BSR.w get1bytemain
BRA.w fetchnum2


is_Hex:       ; was chkhex org source
  ;is d0 a hex number?
  ;
  CMP.w #$30,D0     ;'0'
   BCS.w 'no
  CMP.w #$39,D0     ;'9'
   BLS.w 'yes
  ANDI.w #$FFDF,D0
  CMP.w #$46,D0     ;'F'
   BHI.w 'no
  CMP.w #$41,D0     ;'A'
   BCS.w 'no

 'yes
   CMP.w D0,D0

 'no
RTS


is_Bin:
  CMP.w #$31,D0    ;'1'
   BEQ.w 'ok
  CMP.w #$30,D0    ;'0'

 'ok
RTS


; new >
get_hexbyte
   MOVEQ #0,d0
   MOVE.b (a5)+,d0
   MOVE.b (a5)+,d0
   BSR is_Hex
   BNE syntaxerr
   SUBI.w #$30,D0
   CMP.w #$9,D0
   BLS.w 'l1
   SUBQ.w #7,D0

 'l1
   MOVE.l d0,d1
   MOVE.b (a5)+,d0
     BSR is_Hex
    BNE syntaxerr
    LSL.l #4,d1
    SUBI.w #$30,D0
   CMP.w #$9,D0
   BLS.w 'l2
   SUBQ.w #7,D0

 'l2
  ADD.l d1,d0
RTS
; < new

fetch_HexValue:     ;was fetchhex org source
  BSR.w get1bytemain
  BSR.w is_Hex
  BNE.w syntaxerr

  MOVEQ.l #$00,D3
  ; new >
  CMP.w #5,d2                                 ; is it a float ?
  BNE 'loop

  CMP.l #newtype_float,a2
  BNE 'loop

  ;CMP.l #newtype_double,a2
  ;BNE 'loopa

  TST.b fpu
  BEQ.b 'nofpu
    fmove.s #0,fp0
 'nofpu

 'loopa
  TST.b fpu
  BEQ 'loop
    fmove.w #16,fp1
    fmul.x fp1,fp0
    SUBI.w #$30,D0
    CMP.w #$9,D0
    BLS.w 'skipa
      SUBQ.w #7,D0
   'skipa
    fmove.w d0,fp1
    fadd.x fp1,fp0
    BSR.w get1bytemain
    BSR.w is_Hex
    BEQ.w 'loopa
    BRA.w nofpregload
    ; < new
 'loop
    CMP.l #$10000000,D3
    BCC.w overerr

    LSL.l #4,D3
    SUBI.w #$30,D0
    CMP.w #$9,D0
    BLS.w 'skip
      SUBQ.w #7,D0
   'skip
    OR.w D0,D3
    BSR.w get1bytemain
    BSR.w is_Hex
  BEQ.w 'loop
BRA.w fetchnum2


fetch_BinValue:
  BSR.w get1bytemain
  BSR.w is_Bin
  BNE.w syntaxerr
  MOVEQ.l #$00,D3

 'loop
    LSL.l #1,D3
    BCS.w overerr
    SUBI.w #$30,D0
    OR.w D0,D3
    BSR.w get1bytemain
    BSR.w is_Bin
  BEQ.w 'loop
BRA.w fetchnum2


fetch_Constant:     ; was fetchconst org source
  MOVE.w d2,-(A7)
  ; new >
  MOVE.b #0,automode

  CMP.b #"@",(a5)
  BNE 'l1
    ADDQ.l #1,a5
    MOVE.b #1,automode
    BSR getparameter2
    BSR findlabel2
    BNE 'addit
    BRA errormsg_autocount

   'addit
    BSR.w addlabelhash
    MOVE.l #$1,$4(A2)
    MOVEM.l a2/a5,-(a7)
    MOVE.w lastchar,-(a7)
    LEA autostorename,a5
    BSR getparameter2
    BSR findlabel2
    BEQ 'found
      BSR.w addlabelhash
      MOVE.l #$1,$4(A2)
      MOVE.l #0,8(a2)
   'found
    MOVE.w (a7)+,d0
    MOVE.w d0,lastchar
    MOVE.l 8(a2),d3
    ADD.l #1,8(a2)
    MOVEM.l (a7)+,a2/a5
    MOVE.l d3,8(a2)
    MOVE.l $8(A2),D3
    BRA.l 'l3
 'l1
    ; < new
    BSR.w getparameter2
    ; new >
    TST.b incnif
    BEQ 'lc1
      BSR.w findlabel2
      BNE 'l5
        MOVEQ #1,d3
        MOVE.w (A7)+,D2
        BRA fetchnum2
     'l5
      MOVEQ #0,d3
      MOVE.w (A7)+,D2
      BRA fetchnum2
   'lc1
    ; < new
    BSR.w findlabel2
    BNE.w cnferr

   'l2
    CMPI.l #$1,$4(A2)
    BNE.w cnferr

 'l3
  MOVE.l $8(A2),D3
  MOVE.w (A7)+,D2
BRA.w fetchnum2     ;to right type.


getvaraddr:    ; was ampersand
  ; new >
  CLR.w vartype
  MOVE.b #3,peekaddrsize
  ; < new
  BSR.w ampersand2
  ; new <
  MOVE.l a2,rightsidetype
  MOVE.w flagmask,rightsideflagmask
  ; < new
  MOVEQ.l #$03,D2
RTS


ampersand2:                             ; "@"-Symbol
  BSR.w get1bytemain
  ; new <
  !test_for_literal
  BEQ andop2
  ; < new
  BSR.w getparameter
  BSR.w fetchvars
  BSR.w calcvar
  ;
  CMP.b #$7,D2
  BNE.w 'notst
    BTST #$F,D2
    BNE.w 'algot2
      MOVE.w D3,stamp2+2
      MOVE.l stamp2,D1
      BSR.w pokela5s
      BRA.w 'algot
   'algot2
    MOVE.w regnum,D1
    LSL.w #8,D1
    LSL.w #1,D1
    OR.w stamp,D1
    BSR.w writeword
    RTS
 'notst
  BTST #$F,D2
  BNE.w 'algot
    MOVE.w D3,leaamp+2
    MOVE.l leaamp,D1
    BSR.w pokela5s
 'algot
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w leaamp2,D1
BRA.w writeword


doern:
  ;read err number
  MOVE.w #$D200,D1     ; was #ern,
  BSR.w Atokejsr
  MOVEQ.l #$03,D2
RTS


;------                                                  ;disassembled code begin
addrcode:  Dc.b $20,$6D,$00,$00                            ;MOVEA.L $0000(A5),A0
           Dc.b $D0,$C0                                    ;ADDA.W  D0,A0
           Dc.b $20,$08                                    ;MOVE.L  A0,D0
addrcodef:
;------                                                  ;disassembled code end


fetchit:
   BSR.w get1bytemain
  ;
  MOVE.w D0,D1
   BPL.w syntaxerr
  MOVE.w D2,-(A7)
  BCLR #$F,D1
   BSR.w JMP_searchinstr
  MOVE.l $12(A2),D0
  TST.w -$2(A2,D0.L)
   BEQ.w freeerr
  MOVE.w (A7)+,D2
RTS

JMP_searchinstr:
JMP searchinstr

usedcode:
  MOVE.l $0(A5),D0
   BNE.b ucodeskip
  MOVEQ.l #-$01,D0
BRA.b usedcodef

ucodeskip:
  SUB.l $0(A5),D0

ucodediv:
  LSR.w #8,D0
usedcodef:   ;


usedcode2:
   MOVE.l $0(A5),D0
   BNE.b ucodeskip2
  MOVEQ.l #-$01,D0
BRA.b usedcode2f

ucodeskip2:
  SUB.l $0(A5),D0                                          ;usedcode2
  LSR.w #8,D0

ucodediv2:
  LSR.w #8,D0
usedcode2f:  ;


usedprep:
  MOVE.l D0,-(A7)

useddone:
  MOVE.l (A7)+,D0

usedfix:
  MOVE.l D0,D0


doused:
    ;return 'used' object.
    ;
  BSR.w fetchit
    ;
  MOVE.w -$2(A2,D0.L),D3
  CMP.w #$9,D3
   BCC.w 'skip
    ;
    ;shift 1-8
    ;
  LEA usedcode(PC),A0
  LEA usedcodef(PC),A1
    ;
  ANDI.w #$F1FF,$E+4(A0)                                   ;and #$f1ff,ucodediv-usedcode(a0) org source
  ANDI.w #$7,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,$E+4(A0)                                         ;or  d3,ucodediv-usedcode(a0) org source
 BRA.w 'skip2

 'skip
    ;shift 9+
    ;
  LEA usedcode2(PC),A0
  LEA usedcode2f(PC),A1
    ;
  ANDI.w #$F1FF,$10+4(A0)                                  ;and #$f1ff,ucodediv2-usedcode2(a0) org source
  SUBQ.w #8,D3
  LSL.w #8,D3
  LSL.w #1,D3
  OR.w D3,$10+4(A0)                                        ;or  d3,ucodediv2-usedcode2(a0) org source

 'skip2
  MOVE.w -$6(A2,D0.L),D3
  MOVE.w D3,$C+4(A0)                                       ;move d3,ucodeskip-usedcode+2(a0) org source
  ADDQ.w #4,D3
  MOVE.w D3,$2(A0)
  MOVE.w regnum,D1
   BEQ.w 'skip3
  MOVE.w usedprep(PC),D1
   BSR.w writeword

 'skip3
  BSR.w pokecode
  MOVE.w regnum,D1
   BEQ.w 'skip4
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w usedfix(PC),D1
   BSR.w writeword
  MOVE.w useddone(PC),D1
   BSR.w writeword

 'skip4
   MOVEQ.l #$02,D2
BRA.w get1bytemain


domaximum:
  ;number of maximums
  ;
  ;eg a=Maximum Shape
  ;
   BSR.w fetchit
  ;
  MOVEQ.l #$00,D3
  MOVE.w -$4(A2,D0.L),D3
   BSR.w get1bytemain
BRA.w fetchnum2


doaddr:
  ;address of something
  ;eg a.l=Addr Window(0)
  ;
   BSR.w get1bytemain    ;get the token
  MOVE.w D0,-(A7)
   BSR.w get1bytemain    ;and the bracket?
  CMP.w #$28,D0          ;'('
   BNE.w syntaxerr
  MOVE.w (A7)+,D0
   BSR.w getmaxel
   BSR.w reget
  CMP.w #$29,D0          ;')'
   BNE.w syntaxerr
  ;
  ;OK, now a2=lib it's from
  ;
  LEA addrcode(PC),A0
  LEA addrcodef(PC),A1
  MOVE.w -$6(A2),$2(A0) ;x(a5)
  MOVE.w $4(A0),D1
  ANDI.w #$FFF8,D1
  OR.w regnum,D1
  MOVE.w D1,$4(A0)      ;add Dregat,a0
  MOVE.w $6(A0),D1
  ANDI.w #$F1FF,D1
  MOVE.w regnum,D0
  LSL.w #8,D0
  LSL.w #1,D0
  OR.w D0,D1
  MOVE.w D1,$6(A0)      ;move.l a0,Dregat
   BSR.w pokecode
  MOVEQ.l #$03,D2       ;now a long
BRA.w get1bytemain



f_unction:       ; was function
  ;do a function
  CMP.w ##TokenID_List,D0                              ;first Token after asm-tokens
  BHI.w 'overasm
    BRA.w syntaxerr
 'overasm                                              ; varassign lib commands. $b581 Null from lotanlib

  JSR showdebug

 ; new >
.do_null: ;(blitzlib Elmoresyslib)
  CMP.w ##TokenID_Null,d0                                ; #$b594-$8000 check for lib 107 token "NULL" form elomorsyslib
  BNE 'nonull
    MOVE.l d0,lastinstruction
    MOVE.w #$7000,d1                                   ; asm instr moveq #0,dx
    MOVE.w regnum,d0
    ASL.l #7,d0
    ASL.l #2,d0
    OR.l d0,d1
    BSR writeword
    JSR get1bytemain
    RTS
 'nonull

  CMP.w ##TokenID_New,d0                                     ; $c982-$8000=$4982 check for lib 147 token $4982 "New" from LotanSystem
  BNE nonew_

.do_new: ;(blitzlib LotanSystem)
  MOVE.l a5,-(a7)
  MOVE.w lastchar,-(a7)
  JSR get1bytemain

  CMP.w #"(",d0                                        ; use oldcode
  BNE 'newcode
    JSR get1bytemain
    CMP.w #")",d0
      BEQ 'newcode
        MOVE.w (a7)+,lastchar
        MOVE.l (a7)+,a5
        MOVE.w lastchar,d0
        BRA nonew_
 'newcode
  MOVE.l a0,-(a7)
  TST.b blitzparloop
  BNE 'err
    TST.b funcparloop
    BNE 'err
      BRA 'ok
 'err
    JMP errornewnotincalls
 'ok
  MOVE.l #$203c0000,d1
  BSR writelong                                            ; 68k asm move.l #$xx,d0
  MOVEQ #0,d1
  MOVE.w 8(a0),d1
  BSR writeword
  MOVE.w #$7200,d1                                         ; 68k asm "moveq #0,d1"
  BSR writeword

  MOVE.w #$C002,D1                                         ;call function to alloc global mem
  BSR.w tokejsr2

  MOVE.l (a7)+,a0
  ADDQ.l #6,a7                      ; a5 need not restore
  CMP.w #")",d0
  BNE 'nobracket
    JSR get1bytemain
'nobracket
RTS

nonew_
  ; < new
  CMP.w ##TokenID_Ern,D0      ; was #$8003+tnum,
  BEQ.w doern
  CMP.w ##TokenID_Addr,D0      ; was #$8005+tnum,
  BEQ.w doaddr
  CMP.w ##TokenID_Maximum,D0      ; was #$8011+tnum,
  BEQ.w domaximum
  CMP.w ##TokenID_Used,D0      ; was #$801e+tnum,
  BEQ.w doused
  ;
  MOVE.w D2,-(A7)       ;remember old type!
  MOVE.w D0,D1
  BCLR #$F,D1
  ; new >
  ;CLR.b quickpeek
  ; < new
  JSR searchinstr       ; BSR.w
  MOVE.w (A3),D1
  BTST #$1,D1
  BEQ.w noreturn_                                         ;syntax error noreturn
  BTST #$2,D1
  BNE.w amigalib
  ;
libfunction:
  ;do a user library function -
  ;eg a=pixel{x,y}
  ;
  LSR.w #8,D1
  BTST #$3,$1(A3)
  BEQ.w 'no0
    JSR sizespec2
 'no0
  ; new >
  CLR.l rightsidetype
  CLR.w rightsideflagmask
  ; < new
  MOVE.w D1,-(A7)                                         ;is library instruction
  CMP.w #$7,D1
  BNE.w 'notst0
    MOVE.l A2,-(A7)
    BSR.w makesbase
    MOVEA.l (A7)+,A2
 'notst0
  BSR.w savem
  MOVE.w D3,-(A7)        ;the movem regs
  ;
  BSR.w get1bytemain
  MOVEQ.l #$00,D1
  CMP.w #$28,D0          ;'('
  BNE.w 'nopars
    JSR countpees
    TST.w D1
    BEQ.w syntaxerr
      BRA.w 'skip0
 'nopars
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new

 'skip0                               ; IMPORTANT: Dont add more values to stack until 'no2
  MOVE.w regnum,-(A7)
  ; new >
  MOVE.w regnum,regnumstore
  TST.b fpu
  BEQ 'nofloat
    CMP.w #$ffff,28(a3)
    BNE 'nofloat
    CMP.w #$3c01,34(a3)                            ;val do nofpu stuff
    BEQ 'nofloat
    CMP.w #$3c02,34(a3)                            ;int skip
    BEQ 'quick1
    CMP.b #5,(a3)
    BNE 'nofloat

 'quick1
  CLR.l load_var_addr
  BRA 'isfpu

 'nofloat                                                 ; regnum clear, when a function is call  in a function
  ; new >
  CLR.w regnum

 'isfpu
  MOVE.w D1,-(A7)
  BTST #$3,$1(A3)
  BEQ.w 'no2
  ; new >
;   TST.b fast
;   BEQ 'l2a
;   CMP.w #$ffff,24(a3)
;   BNE 'l2a
;   CMP.w #$5a02,30(a3)                                     ;peek
;   BNE 'l2a
;  MOVE.w $6(A7),D1
;  MOVE.w d1,peeksize
;  TST.b fpu
;  BEQ 'l2a
;  CMP.w #5,d1                                              ;is float on fpu
;  BNE 'l1a
;  ;MOVE.b #1,quickpeek
;
; 'l1a
; BRA 'l11

 'l2a
  ; < new
  MOVE.w $6(A7),D1
  ; new >
  MOVE.w d1,peeksize
;  CMP.w #$5a02,30(a3)                                      ;peek
;  BNE 'l10
;  CMP.b #7,d1                                              ;optimize dont work in peek.w(peek.w))
;  BEQ 'l10
;  TST.b fast
;  BEQ 'l10
; BRA 'l11

; 'l10
  ; < new
  ORI.w #$7000,D1
  BSR.w writeword                                          ;write peekmode

; 'l11
  ADDQ.w #1,regnum
  MOVE.w (A7),D1

 'no2
  ; new >
  MOVE.w 2(a7),tempregnum
  MOVE.w parnum,-(a7)                                       ;7.2014 parnum need store to allow functioncall in parameter >6
  CLR.w parnum                                              ;7.2014
  ; < new
  JSR dolibtoke                                             ;write code of blitzfunc
  ; new >
  MOVE.w (a7)+,parnum                                       ;7.2014 new restore parnum
  ; < new
  TST.w (A7)+
  BEQ.w 'skip
  CMP.w #")",D0                                             ; check if ) here for correct end of blitzlib function call
  BNE.w errorbracketmiss                                    ; was syntax error
  ; new >
  CLR.l lasttoken
  ; < new
  BSR.w get1bytemain

 'skip
  MOVE.w (A7)+,D1
  MOVE.w D1,regnum
  BEQ.w 'skip2
  ; new >
  CMP.w #$3c01,24(a2)                                     ;val skipped
  BNE 'noval
    TST.b fpu
    BEQ 'noval
      CLR.l load_var_addr
      MOVEQ #0,d1
      MOVE.w regnum,d1
      LSL.l #7,d1
      OR.l #$f2000000,d1                                     ; opcode: fmove.x fp0       FPU-check: ok
      BSR writelong
      BRA 'skip2
 'noval
  CMP.w #$3c02,24(a2)                                     ;int skipped
  BEQ 'quick
    CMP.b #5,d2
    BNE 'nofpu2
    TST.b fpu
    BEQ 'nofpu2
    ;CLR.l load_var_addr
    ;BRA 'nofpu2
 'quick
    CLR.l load_var_addr
    BRA 'skip2
 'nofpu2
  ; < new
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2000,D1
  BSR.w writeword      ;move.l d0,regat                                    ;write move.l d0,dx

  ; new >
  TST.b fpu
  BEQ 'skip2
    MOVEQ #0,d1
    MOVE.w regnum,d1
    LSL.l #7,d1
    OR.l #$f2000000,d1                                      ; opcode: fmove.x fp0       FPU-check ok
    ;BSR writelong
    ; < new
 'skip2
  MOVE.w (A7)+,D3
  BEQ.w 'nomovem
  ; new >
  TST.b fpu
  BEQ 'nofpu3
    MOVE.l d0,-(a7)
    MOVE.l a0,-(a7)
    MOVE.l stacktrack,d1
    LEA fpustackbase,a0
    MOVE.w 0(a0,d1),regmask
    MOVE.l (a7)+,a0
    MOVE.w #8,d0
 'loop
    BEQ 'ready
    BTST d0,regmask
    BEQ 'noa7
      MOVEQ #0,d1
      MOVE.w d0,d1
      SUBQ.w #1,d1
      ASL #7,d1
      ;OR.l #$f21f4400,d1                                   ;fmove.s (a7)+
      OR.l #$f21f5400,d1                                   ;fmove.d (a7)+
      BSR writelong
      SUBQ.l #2,stacktrack
   'noa7
    SUBQ.w #1,d0
  BNE 'loop

 'ready
  MOVE.l (a7)+,d0
  SUBQ.l #2,stacktrack                                 ;int track

 'nofpu3
  ; < new
  MOVE.w #$4CDF,D1
  BSR.w writeword                                         ;write movem.l (a7)+,
  MOVEQ.l #$00,D1
  MOVEQ.l #$0F,D4

 'loopsw
  LSL.w #1,D3
  ROXR.w #1,D1
  DBF D4,'loopsw
  BSR.w writeword      ;poke movem (a7)+...
  ; new >
  TST.b fast
  BEQ 'nomovem
    TST.w regnum
    BEQ 'nomovem
    CMP.w #$3c0e,$1c(a3)                                    ;true
    BNE 'l1b
      MOVE.w regnum,d1
      ASL.l #8,d1
      ASL.l #1,d1
      OR.w #$70ff,d1
      SUB.l #12,destpointer
      BSR writeword
   'l1b
    CMP.w #$3c0f,$1c(a3)                                     ;false
    BNE 'l2b
      MOVE.w regnum,d1
      ASL.l #8,d1
      ASL.l #1,d1
      OR.w #$7000,d1
      SUB.l #12,destpointer
      BSR writeword
   'l2b                                                       ;??looks like double label??
  ; < new
 'nomovem

  MOVE.w (A7)+,D2
  CMP.w #$7,D2                                             ;destination var type
  BNE.w 'notst
    MOVE.w putstlen,D1
    OR.w regnum,D1
    BSR.w writeword
 'notst
BRA.w varcont



amigalib:
  MOVE.w $6(A3),D1
   JSR uselib           ;get lib for base address       BSR.w
   BSR.w savereg
  MOVE.l D4,D1
  MOVE.l D5,-(A7)
   BSR.w pokemovem
  MOVE.w $A(A1),-(A7)     ;libbase reg
  ADDQ.w #8,A3
  MOVE.w (A3)+,-(A7)      ;get offset for lib
  MOVE.l A3,-(A7)
   BSR.w get1bytemain
  MOVE.w D0,-(A7)         ;remember first bracket....
  ;
  ;collect longs for lib
  ;
  MOVEQ.l #$00,D3
  ; new >
  JSR checka4a5
  ; < new

 'loop
  MOVE.b (A3)+,D1
   BMI.w 'done
  MOVEQ.l #$03,D2
  ADDQ.w #1,D3
  MOVEM.l D3/A3,-(A7)
  ; new >
  MOVE.b funcparloop,-(a7)
  CLR.b funcparloop
  MOVE.b blitzparloop,-(a7)
  MOVE.b #1,blitzparloop
  MOVE.l lasttoken,-(a7)
  MOVE.l leftsidetype,-(a7)
  MOVE.l rightsidetype,-(a7)
  ; < new
  BSR.w peval
  ; new >
  MOVE.l (a7)+,rightsidetype
  MOVE.l (a7)+,leftsidetype
  MOVE.l (a7)+,lasttoken
  MOVE.b (a7)+,blitzparloop
  MOVE.b (a7)+,funcparloop
  ; < new
  SUBQ.w #4,a2offset              ;readjust stack! it's coming off later!
  MOVEM.l (A7)+,D3/A3
  CMP.w #$2C,D0                   ;','
   BEQ.w 'loop
  TST.b (A3)
   BPL.w syntaxerr

 'done
  MOVE.w (A7)+,D1
   BSR.w tstbras
  MOVEA.l (A7)+,A3
  SUBQ.w #1,D3
   BMI.w 'nopars

 'toend               
  TST.b (A3)+                     ;go to end of params
   BPL.w 'toend
  SUBQ.w #1,A3

 'loop2
    MOVEQ.l #$00,D1
    MOVE.b -(A3),D1
    BTST #$4,D1
     BNE.w 'addreg
    CMP.w regnum,D1
     BCC.w 'nomovem
    BSET D1,D5
    MOVEQ.l #$0F,D0
    SUB.w D1,D0
    BSET D0,D4

   'nomovem
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$201F,D1
   BRA.w 'gotit

   'addreg
    ANDI.w #$7,D1
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$205F,D1

   'gotit
     BSR.w writeword
  DBF D3,'loop2

 'nopars
  MOVE.w (A7)+,libjsr+2
  MOVE.w (A7)+,libbase+2
  MOVE.l libbase,D1
   BSR.w writelong
  MOVE.l libjsr,D1
   BSR.w writelong
  MOVE.w regnum,D1
   BEQ.w 'nofin
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2000,D1
   BSR.w writeword

 'nofin
  MOVE.l (A7)+,D1
   BSR.w pokemovem
   ; new >
   JSR restorea4a5
   ; < new
  MOVEQ.l #$03,D2
   BSR.w reget
BRA.w varcont



tstbras:
  ;chk that d1 (first bra char) and d0 (last)
  ;are consistent with d3 (number of parameters)
  ;also, skip last if nec.
  ;
  TST.w D3
   BEQ.w 'nopars
  CMP.w #$28,D1      ;'('
   BNE.w syntaxerr
  CMP.w #$29,D0      ;')'
   BNE.w syntaxerr
 BRA.w get1bytemain

 'nopars
  CMP.w #$28,D1       ;'('
   BNE.w 'skip
   BSR.w get1bytemain
  CMP.w #$29,D0       ;')'
   BNE.w syntaxerr
 BRA.w get1bytemain

 'skip
RTS


pokemovem:
  TST.w D1
   BNE.w writelong
RTS


savereg:
  ;set up d4 for movem -(a7) and d5 for movem (a7)+
  MOVE.w #$48E7,D4
  SWAP D4
  CLR.w D4
  MOVE.w #$4CDF,D5
  SWAP D5
  CLR.w D5
  MOVE.w regnum,D1
   BEQ.w 'skip
  BSET #$F,D4
  BSET #$0,D5
  CMP.w #$2,D1
   BCS.w 'skip2

 'skip3
  BSET #$E,D4
  BSET #$1,D5

 'skip2
 RTS

 'skip
  TST.w fuckpos
  BNE.w 'skip3
RTS


fuckpos:  Ds.w 1


makesbase:
  MOVE.w sbasegot,D1
   BEQ.w 'skip
    ;
    ;S base has been got, was it for this Eval?
    ;
  MOVE.w sbgot(PC),D1
   BNE.w 'skip2
    ;
    ;No, push it on da stack!
    ;
  MOVE.w #$0002,sbgot
  MOVE.w movea3a7,D1
 BRA.w writeword

 'skip2
 RTS

 'skip                                         ;add tempstring
   ;no sbase got at all!                                              
   ;
  MOVE.w #$0001,sbgot                                      ;voodoo magic! - Will it work?

  MOVE.l #$C601,D1                  ; was #workstart,
  MOVE.w #-1,sbasegot               
  ; new >
  MOVE.l d1,lastinstruction
  ; < new
  BSR.w Atokejsr
RTS



litstring:
  MOVE.l data1,litdata1
  ; new >
  TST.b fast
  BEQ 'l50                                                 ;optistring  seem impossible to get work
                                                           ;100% compatible see string$ for problems
                                                           ;only assign constant and case constant is activate
                                                           ;when on print "test",fi$  fail
 BRA 'l50                                                  ;to deactivate

  CNIF #optibreak                                          ;??looks like dead code??
    ILLEGAL
  CEND

  TST.b optistring
  BNE.s 'l21
  CLR.b string1
  MOVE.b #1,optistring
  TST.b nostringopt
  BNE 'l21
  MOVE.l a5,a4
  SUBQ.l #1,a4

 'l10
    TST.b (a4)
    BMI 'l19a
    BEQ.s 'l20
    CMP.b #$22,(a4)
    BEQ.s 'l19

 'l18
    TST.w string1
    BNE 'l11
    CMP.b #":",(a4)
    BEQ.s 'l20
    CMP.b #";",(a4)
    BEQ.s 'l20
    CMP.b #"+",(a4)
    BEQ.s 'l21
    CMP.b #",",(a4)
    BEQ.s 'l20                                             ;was l21
    CMP.b #")",(a4)
    BEQ.s 'l20                                             ;was l21

 'l11
    ADDQ.l #1,a4
 BRA.s 'l10

 'l19
  BCHG #0,string1
 BRA 'l18

 'l19a
  ADDQ.l #1,a4
  TST.b (a4)
  BEQ 'l21
 BRA 'l11

 'l20
  MOVE.l a5,a4
  SUBQ.l #1,a4

 'll1
  CMP.b #$20,-(a4)
  BEQ 'll1
  CMP.b #"+",(a4)
  BEQ 'l21
  ;CMP.b #",",(a4)
  ;BEQ 'l22
  ;CMP.b #"(",(a4)
  ;BEQ 'l22
; BRA 'l21

;; CMP.b #"=",(a4)
;; BEQ 'l21
  ;CMP.b #">",(a4)
  ;BEQ 'l21
  ;CMP.b #"<",(a4)
  ;BEQ 'l21

 'l22
  MOVE.b #2,optistring

 'l21
  CMP.b #2,optistring
  BEQ.s 'l100

 'l50
  BSR.w makesbase
  ; < new
  BSR.w pokedata1                                          ;writestringsizespace
  BSR.w pokedata1

 'l100
  MOVEQ.l #$00,D2

  ; new >
  'writestring:
    MOVE.l a5,lastsourcepos
    MOVEQ #0,d0
    MOVE.b (a5)+,d0
   ; < new
    TST.w D0
     BEQ.w notqerr
    CMP.w #$22,D0     ; '"'                                     ; --- " ---
     BEQ.w 'done
   ; new >
    CMP.b #"\",d0
     BNE 'l1
    CMP.b #"\",(a5)
     BNE 'l1
    TST.b newsyntax
     BEQ 'l1
    CMP.w #"\\",1(a5)                                      ; new compiler constants
    BNE 'l2
    ADDQ #2,a5

 'l1
    ADDQ.w #1,D2
    MOVE.w D0,D1
    BSR.w pokedata1b                                        ;writestring
 BRA.w 'writestring

 'l2                                                       ;\\char//
    JSR check_newconstants
 BRA 'writestring

  ; < new
 'done
  ; new >
  NOT instringon
  ; < new
  MOVE.w dontwrite_nomemleft,D1
  BNE.w 'skip
  ; new >
  CMP.b #2,optistring
  BEQ 'skip
  ; < new
    MOVEA.l litdata1,A0
    CLR.w (A0)+                                            ;writesize
    MOVE.w D2,(A0)

 'skip
  BSR.w makelit                                          ;writestringconstantcode
  ADDQ.l #1,data1
  BCLR #$0,data1+3
  MOVEQ.l #$07,D2
BRA.w get1bytemain


makealab2:
  ; new >
  BSR.w makename2
  ; < new
  BSR.w findlabel2
  BEQ.w 'found
  ;
  BSR.w addlabelhash
  CLR.l $4(A2)           ;no refs
  CLR.l $8(A2)           ;not created yet (no PC)
  ;clr.l $C(A2)          ;no data label
  MOVE.w linenumat+2,$10(A2)  ; was linenumat,    ;context
  ; new >
  MOVE.w linenumat,d0
  MOVEQ #0,d1
  MOVE.b -1(a2,d7),d1
  MOVE.w d0,0(a2,d1)
  ; < new
 BRA.w 'makeit

 'found
  TST.l $8(A2)
  BNE.w 'gotit    ;already made
  ;
  ;create an oustanding reference to this label!
  ;

 'makeit
  MOVEA.l _execbase,A6
  MOVEQ.l #$0C+2,D0      ; was 12
  MOVEQ.l #$01,D1
  ; new >
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  ; < new
   ;jsr do_AllocMem
  MOVEA.l D0,A0
  MOVE.l $4(A2),(A0)
  MOVE.l A0,$4(A2)
  MOVE.l destpointer,$4(A0)
  ADDQ.l #2,$4(A0)
  MOVE.w procnum,$8(A0)
  MOVE.w linenumat+2,$A(A0)   ; was linenumat,
  ; new >
  MOVE.w linenumat,$c(a0)
  ; < new
 RTS

 'gotit
  MOVE.l $4(A2),D1
  BTST #$0,D1
   BNE.w illlaberr
  MOVE.w procnum,D1
  CMP.w $10(A2),D1
   BNE.w referr

 'skip
RTS


makelit:
  ;put lit string from d3 (data1) into stringbuff
  ;
  MOVE.w D0,-(A7)
  ; new >
  CMP.b #2,optistring
  BEQ 'l10

 'l35
  ; < new
  MOVE.w numtoa0,D1
   BSR.w writeword
   BSR.w addoff
  MOVE.l litdata1,D1
   BSR.w writelong
  MOVE.w pushlen,D1
   BSR.w writeword
  MOVE.w #$C600,D1        ; was #copstring
   BSR.w Atokejsr
  MOVE.w (A7)+,D0
 RTS

  ; new >
 'l10
  MOVEQ #0,d1
  BSR.w pokedata1b
  MOVE.l destpointer,a4
  MOVE.w #$203c,d1
  TST.w mode
  BNE 'lm10
   ADDQ.w #4,a2offset
  MOVE.w #$2f3c,d1

 'lm10
  TST.w mode
  BEQ 'lm3
  MOVE.w regnum,D0
  LSL.w #8,D0
  LSL.w #1,D0
  OR.w d0,d1
  BSR writeword
  BSR.w addoff
  MOVE.l litdata1,D1
  BSR.w writelong
  CMP.w #3,mode
  BEQ 'l30
   ADDQ.w #4,a2offset
  MOVE.w #$4878,D1
  BSR.w writeword
  MOVE.l d2,d1
  BSR writeword

 'l30
  MOVE.w (A7)+,D0
  RTS

 'lm3
  MOVE.l #$3f3c0007,d1
  BSR writelong
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$2f3c,d1
  BSR writeword
   ADDQ.w #4,a2offset
  MOVE.l d2,d1
  BSR writelong
  MOVE.w #$2f3c,d1
  BSR writeword
  BSR.w addoff
  MOVE.l litdata1,D1
  BSR.w writelong
  MOVE.w (A7)+,D0
RTS
  ; < new


qmark:
  BSR.w get1bytemain
  BSR.w makealab2
  ;
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$203C,D1
  BSR.w writeword        ;create move.l #loc,dn
  BSR.w addoff
  MOVE.l $8(A2),D1
  BSR.w writelong
  MOVEQ.l #$03,D2
  ; new >
  CLR.b peekaddrsize
  ; < new
BRA.w reget


fetchqasm:
  MOVEQ.l #$00,D3

 'loop
    BSR.w get1bytemain
    BEQ.w syntaxerr
    CMP.w #$22,D0         ;'"'
    BEQ.w 'done
      LSL.l #8,D3
      MOVE.b D0,D3
  BRA.w 'loop

 'done
  BSR.w get1bytemain
BRA.w fetchnum2


fetchasm:
  MOVE.w D2,-(A7)              ; basic vars for asm
  BSR.w makename2              ; get the things name
  BSR.w findlabel2
  BEQ.w 'l10
    LEA ptr_parameterstore,a0
    CMP.b #"@",-1(a0,d2.w)
    ; < new
    BNE cnferr
    ; new >
    CLR.b -1(a0,d2.w)
    SUBQ.l #1,d2
    LEA varbase,a2
    BSR findvariable
    BNE cnferr

    CMP.b #"\",d0
    BNE 'l6
      ADDQ #1,lastsourcepos
      MOVE.l $a(a2),a2
      ADDQ.l #4,a2
      BSR.w makename2
      BSR findvariable2
      BNE cnferr
      BRA.s 'l6                                                  ;???
   'l6
    MOVE.w $4(a2),d3
    EXT.l d3
    BRA 'npc
 'l10
  ; < new
  MOVE.l $8(A2),D3          ;val.
  CMPI.l #$1,$4(A2)
  BEQ.w 'npc
    NOT.w asmtype
 'npc
  MOVE.w (A7)+,D2
BRA.w fetchnum2


variable:
  MOVE.w D2,-(A7)                                        ;remember old type
  BSR.w getparameter

  CMP.w #"{",D0                                          ;test if var = function{}
  BEQ.w handle_function

  BSR.w fetchvars
                                                         ;called when do var = var
  BSR.w calcvar                                          ;getvaroffset+type
  BSR.w variable2
   ; new >
  MOVE.l a2,rightsidetype
  MOVE.w flagmask, rightsideflagmask
   ;BTST #$d,vartype
   ;BNE 'ls1
   ;CMP.b #7,vartype+1                                      ;long pointer string error
   ;BEQ 'ls1
   ;TST.b vartype+1
   ;BEQ 'ls1
   ;CMP.b #7,d2
   ;BNE 'ls1
; BRA error_convert_types

 'ls1
  TST.b typecheck
  BEQ varcont
  CMP.l #$da01,lasttoken                                  ; poke
  BEQ 'l1
    CMP.l #$da02,lasttoken                                 ; peek
    BNE 'l2
 'l1
   CMP.w #1,parnum                                         ; is not call when & is used in parameter
   BNE varcont
   MOVE.b d2,peekaddrsize
   BRA varcont
 'l2
  CLR.b peekaddrsize
  ; < new

  varcont:
  CMP.w #$1,D2
  BNE.w 'notabyte
    ;
    ;ALWAYS CONVERT BYTE TO WORD.
    ;
    MOVE.w regnum,D1
    ORI.w #$4880,D1      ;ext.w Dn
    BSR.w writeword
 'notabyte

  MOVE.w (A7)+,D3                           ; old type
  BEQ.w 'done                               ; type not set yet...
                                            ; it is now!
  ; new >
  MOVE.l lastinstructionaddr,a0
  ; < new
  CMP.w #$3,D3
  BNE.w 'nob
    CMP.w #$4,D2
    BEQ.w 'conv2
 'nob
    CMP.w D2,D3
    BLS.w 'done
 'conv2

  EXG.l D2,D3
  ; new >
  MOVE.l a0,-(a7)
  TST.b typecheck
  BEQ 'ok
  TST.b notypecheck
  BNE 'ok
  MOVE.l leftsidetype,a0
  CMP.l #0,leftsidetype
  BEQ 'ok
  CMP.w #1,leftsideflagmask
  BEQ 'isptr
  CMP.l #$100,4(a0)
  BLE 'ok

 'isptr
  CMP.b #3,d3
  BEQ 'ok
  CMP.b #7,d3
  BEQ 'ok
  JMP   error_convert_types      ;for all syntax only long and string allowed to assign to a type

 'ok
  MOVE.l (a7)+,a0
  ; < new
  BSR.w writeconvertcode         ;called from var assign      ;bump up new type to old...

 'done
BRA.w reget


savemfunc:                       ; it is a copy of the savem routine
  MOVEQ.l #$00,D3
  MOVE.w regnum,D1
  BEQ.w savem_skip
  SUBQ.w #1,D1

 'loop
     LSR.l #1,D3
     BSET #$F,D3
  DBF D1,'loop
  ; new >
   TST.b fpu
   BEQ 'l1
   ADDQ.l #2,stacktrack                                    ;intern command
    MOVE.l a0,-(a7)
    MOVE.l stacktrack,d1
    LEA fpustackbase,a0
    CLR.w 0(a0,d1)
    CLR.w regmask
    MOVE.l (a7)+,a0

 'l1
  ; < new
  MOVE.w #$48E7,D1
   BSR.w writeword                                         ;write movem.l d0/d1,-(a7)
  MOVE.w D3,D1
BRA.w writeword
; < new


savem:
  MOVEQ.l #$00,D3
  MOVE.w regnum,D1
   BEQ.w savem_skip
  SUBQ.w #1,D1

 'loop
    LSR.l #1,D3
    BSET #$F,D3
  DBF D1,'loop
  ; new >
   TST.b fpu
   BEQ 'l1
   ADDQ.l #2,stacktrack                                    ;intern command
    MOVE.l a0,-(a7)
    MOVE.l stacktrack,d1
    LEA fpustackbase,a0
    CLR.w 0(a0,d1)
   CMP.b #5,(a3)                                           ;result float ?
    BNE 'nofpu
;    MOVE.w #1,0(a0,d1.w)
    MOVE.w regnum,regnumfunc

 'nofpu
  CLR.w regmask
    MOVE.l (a7)+,a0

 'l1
  ; < new
  MOVE.w #$48E7,D1
   BSR.w writeword                                         ; write movem.l d0/d1,-(a7)
  MOVE.w D3,D1
 BRA.w writeword

savem_skip:
RTS


makefjsr:
  MOVE.l D1,-(A7)
  MOVE.w #$4EB9,D1                                         ; write JSR
  BSR.w writeword
  BSR.w addoff
  MOVE.l (A7)+,D1
BRA.w writelong


handle_function:                                           ;do var = function {}
                                                           ;do a local function -
                                                           ;eg a=pixel{x,y}
  BSR.w find_procedure
  BEQ 'l1a
    TST.l unusedfunc
    BEQ noprocerr
      JSR gotoendsource
 'l1a

  MOVE.l funcstruct_returntype(a2),rightsidetype

  TST.l typetocast
  BEQ 'nocast
    MOVE.l typetocast,rightsidetype
    CLR.l typetocast
    MOVE.l a1,-(a7)
    MOVE.l rightsidetype,a1
    CMP.l leftsidetype,a1
    BEQ 'ok
      JMP errorconvertreturntype2
   'ok
    MOVE.l (a7)+,a1
 'nocast

  MOVE.l a2,currentfunccall
  MOVEQ.l #$00,D1
  MOVE.b $5(A2),D1
  MOVE.b d1,retmode
  BMI.w illprocerr
  MOVE.b #1,isfunc(a2)
  MOVE.w D1,-(A7)
  MOVEQ.l #$00,D1
  MOVE.b $4(A2),D1
  LSR.w #4,D1
  BEQ.w 'skip
    LSL.w #2,D1
    SUB.w D1,a2offset                                   ; a2offset : stackuse
 'skip

  CMPI.w #$7,(A7)                                       ; if function return type is "string"
  BNE.b 'sss
    MOVE.l A2,-(A7)
    BSR.w makesbase
    MOVEA.l (A7)+,A2
 'sss

  MOVE.w sbasegot,-(A7)
  BEQ.b 'sssz
    BSR.w dopusha3
 'sssz

  BSR.w savemfunc

  MOVE.w D3,-(A7)                                        ;the movem regs
  ;
  MOVE.l $E(A2),D1                                       ; pc of function call

  TST.b $20(a2)                                          ; counter of parameters
  BNE 'no0par

  MOVE.l a5,a4                                           ; skip spaces and search for "}"
 'l1
    CMP.b #$20,(a4)+
  BEQ 'l1
  CMP.b #"}",-1(a4)
  BNE  'no0par                                           ; if "}" found, there are not parameters given

  ;--
  ;--  analyse the given parameters
  ;--
  MOVEQ #0,d0
  LEA $16(A2),A1                                         ; parameter description list (1..byte, 2..word, etc.)

 'again
  MOVE.l d1,-(a7)
  MOVE.b (a1),d2
  MOVE.l d0,d1

  CMP.w #4,d2                                            ; is parameter of type "quick"?
  BNE 'l1b
    ADD.l #$203c,d1
    BSR writeword
    MOVE.l #$ffff0000,d1
    BSR writelong
    BRA 'l2b
 'l1b
    TST.b fpu                                            ; test for fpu-optimization mode
    BNE 'l1c
      CMP.w #5,d2                                        ; is parameter of type "float"?
      BNE 'l1c
        ADD.l #$203c,d1
        BSR writeword
        MOVE.l #$800000c1,d1
        BSR writelong
        BRA 'l2b
   'l1c
      ADD.l #$70ff,d1
      BSR writeword

      CMP.w #7,d2                                           ; is parameter of type "string"?
      BNE 'l1d
        MOVE.l #$2f3c0000,d1                                 ; write code move.l #0,-(a7)
        BSR writelong
        MOVEQ #0,d1
        BSR writeword

        MOVE.l #$2f3c0000,d1                                ; write code move.l #0,-(a7)
        BSR writelong
        MOVEQ #0,d1
        BSR writeword
    'l1d
        TST.b fpu                                             ;remove fpustuff, if no fpu mode; honitos 20191113
        BEQ 'l3b
          MOVE.l #$f23c5000,d1                                ; write code fmove.w #-1,fpx
          MOVE.l d0,d2
          ASR.l #2,d2
          ADD.l d2,d1
          BSR writelong
          MOVE.w #$ffff,d1
          BSR writeword
       'l3b
 'l2b
  MOVE.l (a7)+,d1
  ADDQ.l #1,a1
  ADD.l #$0200,d0
  CMP.l #$0e00,d0
  BEQ syntaxerr
  TST.b (a1)
  BNE 'again
  BRA 'p1

 'no0par
  ; < new
  TST.b $4(A2)
  BNE.w 'somepars

  ; new >
 'p1
  ; < new
  BSR.w makefjsr
  BSR.w get1bytemain
  BRA.w 'nopars


 'somepars
  ; new >
  MOVE.w parnum,-(a7)                                      ;7.2014 need store so function calls in parameter >6 can work
  ; < new
  MOVE.w regnum,-(A7)         ;old regat
  ; new >
  MOVE.w regnum,regnumfunc

 '_func
  ; < new
  MOVE.l D1,-(A7)                                          ;write functioncall with pars
  ; new >
  MOVE.b #1,funccall
  ; < new
  MOVEQ.l #$00,D0
  MOVE.b $4(A2),D0
  ; new >
  MOVE.w a2offset,a2offset2
  MOVE.b 5(a2),retmode
  MOVE.l a2,currentfunccall
  ; < new
  LEA $16(A2),A2              ;pointer to var desc
  CLR.w regnum
  ; new >
  CLR.w regmask
  MOVE.b isconstantvalue,-(a7)
  MOVE.b funcparloop,-(a7)
  MOVE.b #1,funcparloop
  MOVE.l rightsidetype,-(a7)
  MOVE.l leftsidetype,-(a7)                               ;store values To stack so it can work recursive
  MOVE.b blitzparloop,-(a7)
  CLR.b blitzparloop
  ; < new
  JSR fetchpees2
  ;
  ; new >
  MOVE.b (a7)+,blitzparloop
  MOVE.l (a7)+,leftsidetype
  MOVE.l (a7)+,rightsidetype
  MOVE.b (a7)+,funcparloop
  MOVE.b (a7)+,isconstantvalue
  ; < new
  JSR chkstak
  MOVE.l (A7)+,D1
  ; new >
;  CMP.l #6,parnumtemp
;  BLE 'l1f
;  CMP.l #11,parnumtemp
;  BGE 'l1f
;   TST.w a2offset
;   BEQ 'l1f
;   MOVE.l d1,-(a7)
;   MOVE.w #$47ef,d1                                        ;lea x(a7),a3 nat
;   BSR writeword
;   MOVE.w a2offset,d1
;   SUB.w a2offset2,d1
;   BSR writeword
;   MOVE.l (a7)+,d1

; 'l1f
   BTST #0,d1
   BNE intern1
   ; < new
   BSR.w makefjsr
   ; new >
;   CMP.l #6,parnumtemp
;  BLE 'le
;  CMP.l #11,parnumtemp
;  BGE 'le
;   TST.w a2offset
;   BEQ 'le                                                 ;changed
;   MOVE.l d1,-(a7)
;   MOVE.l #$4fef0000,d1                                    ;lea $x(a7),a7   nat
;   MOVE.w a2offset,d1
;   SUB.w a2offset2,d1
;   BSR.w writelong                                         ;correct stack with more parameters
;  MOVE.w numreps,movenumrep+2
;   BEQ.w 'le2
;  MOVE.l movenumrep,D1
;   BSR.w writelong

; 'le2
;  MOVE.w a2offset2,a2offset
;  MOVE.l (a7)+,d1

 'le
  ; < new
  MOVE.w (A7)+,regnum
  ; new >
  MOVE.w (a7)+,parnum                                     ;07.2014
  ; < new

 'nopars
  CMP.w #"}",D0
   BNE.w errorbracketmiss2
  ;
  ; new >
   MOVEQ #0,d1                                            ; end of function call pars
  ; < new
  MOVE.w regnum,D1
  BEQ.w 'nopars3
  ; new >
  TST.b fpu
  BEQ 'old
    CMP.b #5,retmode
    BNE 'old
      ASL.l #7,d1
      OR.l #$f2000000,d1                             ; opcode: fmove.x fp0       FPU-check: ok
      BSR writelong
      BRA 'nopars3
 'old
    ; < new
    LSL.w #8,D1
    LSL.w #1,D1
    ORI.w #$2000,D1
    BSR.w writeword         ;move.l d0,regat
 'nopars3
  MOVE.w (A7)+,D3
  BEQ.w 'nomovem
  ; new >
  TST.b fpu
  BEQ 'old2
  MOVE.l d0,-(a7)
  MOVE.w #8,d0
  MOVE.l a0,-(a7)
  MOVE.l stacktrack,d1
  LEA fpustackbase,a0
  MOVE.w 0(a0,d1),regmask
  MOVE.l (a7)+,a0

 'loop
  BEQ 'ready
   BTST d0,regmask
   BEQ 'noa7
   MOVEQ #0,d1
   MOVE.w d0,d1
   SUBQ.w #1,d1
   ASL #7,d1
   ;OR.l #$f21f4400,d1
   OR.l #$f21f5400,d1                                      ;fmove.d (a7)+
   BSR writelong
   SUBQ.l #2,stacktrack

 'noa7
   SUBQ.w #1,d0
   BNE 'loop

 'ready
  SUBQ.l #2,stacktrack                                     ;integer sub
  MOVE.l (a7)+,d0

 'old2
  ; < new
  MOVE.w #$4CDF,D1
   BSR.w writeword
  MOVEQ.l #$00,D1
  MOVEQ.l #$0F,D4

 'loopsw
    LSL.w #1,D3
    ROXR.w #1,D1
  DBF D4,'loopsw                                         ;movem.l (a7)+,dx

    BSR.w writeword        ;poke movem (a7)+...
  ; new >
   CLR.w regnumfunc
  ; < new

 'nomovem
  MOVE.w (A7)+,D1
   BEQ.b 'nores
  CMPI.w #$7,(A7)
   BEQ.b 'issb
  ;not a string...set a3 back to start of any strings...
  LEA geta3,A0
  LEA geta3f,A1
   BSR.w pokecode
 BRA.b 'nosb

 'issb
  ;is a string, wack off last '0'
  MOVE.w deca3,D1
  BSR.w writeword

 'nosb
  BSR.w dopulla3          ;fix up string base

 'nores
  MOVE.w (A7)+,D2         ;what it returns!
  CMP.w #$7,D2
  BNE.w 'notst
    MOVE.w putstlen,D1
    OR.w regnum,D1
    BSR.w writeword
 'notst
  BSR.w get1bytemain
BRA.w varcont


;------                                                  ;disassembled code begin
deca3:   Dc.b $53,$4B                                      ;SUBQ.W  #1,A3
;------                                                  ;disassembled code end

Even
stvar:
  ;handle string variable get!
  ;
  ; new >
  CMP.b #2,optistring
  BEQ 'fs2
  ; < new
  BSR.w makesbase                                          ;writestringvariable
  BTST #$F,D2
   BNE.w 'already
  MOVE.w D3,leaa5d3a2+2
  MOVE.l leaa5d3a2,D1
   BSR.w pokela5s

 'already
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$7000,D1
  LEA stvarget2,A0
  MOVE.w D1,(A0)
  MOVE.w regnum,D1
  ANDI.w #$FFF8,$2(A0)
  OR.w D1,$2(A0)
  LEA stvarget2f,A1
   BSR.w pokecode
  MOVE.w #$C600,D1     ; was #copstring,
   BSR.w Atokejsr
  MOVEQ.l #$07,D2
 BRA.w reget

  ; new >
 'fs2
     TST.w stackpar
     BMI 'l10
     MOVE.l #$3f3c0007,d1
     ADDQ.w #2,a2offset
     BSR writelong

 'l10
  MOVE.w #$4878,d1
     CLR.w stackpar
     BSR writeword
     MOVE.w #$0,d1
     BSR writeword
     MOVE.w #$246d,d1
     BSR writeword
     MOVE.w d3,d1
     BSR writeword
     MOVE.l #$4a926704,d1
     BSR writelong
     MOVE.l #$2eaafffc,d1
     BSR writelong
     MOVE.w #$2f0a,d1
     ADDQ.w #8,a2offset
     BSR writeword
BRA.w reget
  ; < new


variable2:
  CMP.b #$7,D2                                             ;load basic var
  BEQ.w stvar
   ; new >
  TST.b iee
  BEQ 'noiee
    CMP.b #5,d2
    BNE 'noiee
      MOVE.l d0,-(a7)                                         ;fpu load var
      BTST #15,d2
      BEQ 'var
    CMP.l #$7fff,d3
    BGT 'longoffset
      MOVE.l #$f22a4400,d1                                    ;newtype     >32kb
      TST.w d3                                                ;offset =0
      BNE 'offset
   'longoffset
    MOVE.l #$f2124400,d1
    MOVEQ #0,d3
    BRA 'glob

 'offset
  SUBQ.l #4,destpointer
  BRA 'glob

 'var
  TST.b fast
  BEQ 'nofastload
   TST.w regnum
   BNE 'nofastload

   CMP.l fp0addr,a4
   BNE 'nofastload

   MOVE.l fp0iff,d1
   CMP.l firstiff,d1
   BNE 'nofastload

   MOVE.w varmode,d1
   CMP.w fp0mode,d1
   BNE 'nofastload

   CMP.w fp0var,d3
   BNE 'nofastload

   BCLR #16,d2
   MOVE.l (a7)+,d0
   RTS
 'nofastload
  MOVEQ #0,d0
  MOVE.w regnum,d0
  CMP.l maxregs,d0
  BLE 'ok
    LEA cmplxerr,a0
    MOVE.l a0,-(a7)
    JMP handle_compileerror
 'ok
    LEA regtable,a4
    TST.l (a4)
    BEQ 'noreg
    CMP.w 0+4(a4),d3
    BNE 'doreg1
    MOVE.l #$f2001c00,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    BSR writelong
    MOVE.l (a7)+,d0
    RTS
 'doreg1
  CMP.w 8+4(a4),d3
  BNE 'doreg2
    MOVE.l #$f2001800,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    BSR writelong
    MOVE.l (a7)+,d0
    RTS
 'doreg2
  CMP.w 16+4(a4),d3
  BNE 'doreg3
    MOVE.l #$f2001400,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    BSR  writelong
    MOVE.l (a7)+,d0
    RTS
 'doreg3
  CMP.w 24+4(a4),d3
  BNE 'doreg4
    MOVE.l #$f2001000,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    BSR writelong
    MOVE.l (a7)+,d0
    RTS
 'doreg4
  CMP.w 32+4(a4),d3
  BNE 'noreg
    MOVE.l #$f2000c00,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    BSR writelong
    MOVE.l (a7)+,d0
    RTS
 'noreg
  MOVE.l #$f22d4400,d1                                    ;var
  TST.w varmode
  BEQ 'glob
    BCLR #16,d1                                              ;local
 'glob
  MOVEQ #0,d0
  MOVE.w regnum,d0
  CMP.w #7,d0
  BLE 'ok2
    LEA cmplxerr,a0
    MOVE.l a0,-(a7)
    JMP handle_compileerror
 'ok2
  ASL.w #7,d0
  OR.l d0,d1
  CMP.l #doublecheck,8(a2)
  BNE 'dbl
    OR.l #$00001000,d1
 'dbl
  BSR writelong
  MOVE.l (a7)+,d0
  AND.w #$ff,d2
  MOVE.w d3,d1
  BEQ 'nooffs
    BRA writeword
 'nooffs
  ;CMP.l #$f2124400,-4(a4)
  ;BNE writeword
  RTS

 'noiee
  MOVE.w regnum,D1
  ; new >
  MOVE.w d1,load_var_reg
  ; < new
  LSL.w #8,D1
  ; new >
  MOVE.l destpointer,load_var_addr
  MOVE.w d2,load_var_size
  ; < new
  LSL.w #1,D1
  BTST #$E,D2
  BNE.w 'pointer
    TST.b D2
    BNE.w 'skip2
      MOVEQ.l #$03,D2
      ORI.w #$200A,D1
      BRA.w writeword
 'pointer
  MOVE.b #$3,D2

 'skip2
  BTST #$F,D2
  BEQ.w 'simpvar                                         ;loadarray
  ; new >
   TST.b fast                                              ;lea->move xx(a2)
   BEQ 'la10
   CNIF #optibreak
     ILLEGAL
   CEND

   CLR.l load_var_addr
   BRA 'la10

   CMP.w #$2012,movea2dn                                  ;??Looks like dead code??
   BNE 'la10
   TST.b optiarray
   BNE 'la10
   MOVE.l destpointer,a4
   SUB.l loada,a4
   CMP.w #4,a4
   BEQ 'la100
   CMP.w #2,a4
   BNE 'la10
   MOVE.l destpointer,a4
   CMP.b #3,d2
   BCS 'la110
   MOVE.w #$202a,-2(a4)
   OR.w d1,-2(a4)
   MOVE.w arrayoffset,d1
   BSR writeword
 BRA 'more

 'la110
   CMP.b #2,d2
   BNE 'la120
    MOVE.w #$302a,-2(a4)
   OR.w d1,-2(a4)

   MOVE.w arrayoffset,d1
   BSR writeword
 BRA 'more

 'la120
  CMP.b #1,d2
   BNE.s 'la10
    MOVE.w #$102a,-2(a4)
   OR.w d1,-2(a4)
   MOVE.w arrayoffset,d1
   BSR writeword
 BRA 'more

 'la100
  MOVE.l destpointer,a4
   CMP.w #$45ea,-2(a4)
   BNE 'la10
   CMP.b #3,d2
   BCS 'la11
   MOVE.w #$202a,-4(a4)
   OR.w d1,-4(a4)
 BRA 'more

 'la11
   CMP.b #2,d2
   BNE 'la12
    MOVE.w #$302a,-4(a4)
   OR.w d1,-4(a4)
 BRA 'more

 'la12
  CMP.b #1,d2
   BNE.s 'la10
    MOVE.w #$102a,-4(a4)
   OR.w d1,-4(a4)
 BRA 'more

 'la10
  ; < new
   OR.w movea2dn,D1
   BSR.w 'size
   BSR.w writeword

 'more
  ANDI.w #$FF,D2
 RTS

  ; new >
 'farr2                               ;??? looks like not used ???
   MOVE.l destpointer,a4              ; "
   MOVE.l #$f22a4400,-4(a4)           ; "
   MOVE.w arrayoffset,d1              ; "
 BRA writeword
  ; < new

 'simpvar
  OR.w moved3a5dn,D1                                        ;write move.l 0(a5),reg
   BSR.w 'size
   BSR.w pokewda5s
  MOVE.w D3,D1
   BSR.w writeword
 BRA.w 'more

 'size
  ;correct for size
  ;
  BTST #$E,D2
   BNE.w 'long
  CMP.b #$1,D2
   BEQ.w 'byte
  CMP.b #$2,D2
   BEQ.w 'word

 'long
 RTS

 'byte
  EORI.w #$3000,D1
 RTS

 'word
  ORI.w #$1000,D1
RTS


;----------- fetch number and update type if necessary!----------;

fetchdata:
  MOVE.w #$FFFF,dfetch    ; was -1
  BSR.w get1bytemain

  CMP.w #$2D,D0           ;'-'
  BNE.w 'datado

  BSR.w get1bytemain
  BSR.w 'datado
  ;
  CMP.w #$5,D2            ; float ?
  BCC.w 'nfp
    NEG.l D0
    RTS
 'nfp
  ; new >
  TST.b fpu
  BEQ 'noneg
    fneg.x fp0
    RTS
 'noneg
  ; < new
  ;negate floating point data!
  BCHG #$7,D0
  RTS


 'datado
  CMP.w #$24,D0          ;'$'
  BEQ.w fetch_HexValue

  CMP.w #$25,D0          ;'%'
  BEQ.w fetch_BinValue

 'doit
  CMP.w #$2E,D0          ;'.'
  BNE.w fetchnum

fetchfrac:
  MOVEQ.l #$00,D3
BRA.w fetchpoint2


fetchnum:
  MOVEQ.l #$00,D3                                          ; number
  BSR.w atoi                                               ; get current character in d0, returns number in d3
  ;
  CMP.w #$2E,D0                                            ; '.'
  BEQ.w fetchpoint

  ORI.w #$20,D0                                            ; 32
  CMP.w #$65,D0                                            ; 'e'
  BNE.w fetchnum2

  CMP.l #$800000,D3
  BCC.w overerr

  MOVEQ.l #-$01,D6

  TST.b fpu
  BEQ 'nofpu1
    fmove.l d3,fp0
 'nofpu1
  MOVE.l D3,D0
  MOVEA.l _mathffpbase,A6
  JSR _SPFlt(A6)                                           ;int to ffp
  MOVE.l D0,D3

  BSR.w do_the_E

  BSR.w reget
  BSR.w consttype2
BRA.w fetchnum3


fetchpoint:
  ; new >
  CMP.b #4,d2
  BEQ 'l4
    MOVE.b #5,d2                                             ;nprint 2/0.5 bugfix
 'l4


  TST.b fpu
  BNE 'l1
  ; < new
    CMP.l #$800000,D3
    BCC.w overerr
  ; new >
    BRA fetchpoint2
 'l1
  CMP.l #$7fffffff,d3
  BCC.w overerr
   ; < new


fetchpoint2:
  MOVEQ.l #-$01,D6         ;now a float.

  ; new >
  TST.b fpu
  BEQ 'nofpu2
    fmove.l d3,fp0
 'nofpu2
  MOVE.l D3,D0
  MOVEA.l _mathffpbase,A6
  JSR _SPFlt(A6)            ;int to ffp                                       ;integer to ffp
  MOVE.l D0,-(A7)          ;save whole number

  BSR.w get1bytemain
  !test_for_literal
  BNE.w syntaxerr

  MOVEQ.l #$00,D3

  BSR.w atoi              ; get int frac, returns 10th in d5, int number in d3

  TST.l D3
  BEQ.w 'pskip

  TST.b fpu
  BNE 'l1
    CMP.l #$800000,D3
    BCC.w overerr
    BRA 'l2
 'l1
    CMP.l #$7fffffff,d3
    BCC overerr
 'l2

  TST.b fpu
  BEQ 'nofpu4
    fmove.l d5,fp1
    fmove.l d3,fp2
    fdiv.x fp1,fp2
    fadd.x fp2,fp0
 'nofpu4
  MOVE.l D5,D0
  JSR _SPFlt(A6)        ; divisor to FFP
  MOVE.l D0,D5
  MOVE.l D3,D0
  JSR _SPFlt(A6)        ; to FFP
  MOVE.l D5,D1
  JSR _SPDiv(A6)        ; num/divisor (eg .25=25/100)
  MOVE.l (A7)+,D1
  JSR _SPAdd(A6)        ; add 'em
  MOVE.l D0,D3

  BSR.w reget             ; get previous char to D0
  ORI.w #$20,D0
  CMP.w #$65,D0           ; 'e'
  BNE.w 'pskip2
    BSR.w do_the_E
 'pskip2

  BSR.w reget
  BSR.w consttype2

;  trap#5
  BRA.w fetchnum3

 'pskip
  MOVE.l (A7)+,D3
BRA.w 'pskip2


do_the_E:                                                     ; Suss stuff after the E
  ; input: d3/fp0 = number
  ; input: d0 = current source
  ; returns division in d3/fp0
  BSR.w get1bytemain
  CMP.w #$2B,D0                  ;'+'
  BEQ.w 'pos
    CMP.w #$2D,D0                ;'-'
    BNE.w 'pos2
      ;neg
      BSR.w get1bytemain
      BSR.w get_Sign             ;d3/fp0=number, d4/fp1=divisor

      TST.b fpu
      BEQ 'nofpu10
        fdiv.x fp1,fp0
     'nofpu10
      MOVE.l D3,D0
      MOVE.l D4,D1
      JSR _SPDiv(A6)
      MOVE.l D0,D3
      RTS
 'pos
  BSR.w get1bytemain

 'pos2
  BSR.w get_Sign                ;d3/fp0=number, d4/fp1=multiplier

  TST.b fpu
  BEQ 'nofpu8
    fmul.x fp1,fp0
 'nofpu8
  MOVE.l D3,D0
  MOVE.l D4,D1
  JSR _SPMul(A6)
  MOVE.l D0,D3
RTS


get_Sign:
  !test_for_literal
  BNE.w syntaxerr

  MOVE.w D0,D4
  SUBI.w #$30,D4
  BSR.w get1bytemain

  !test_for_literal
  BNE.w 'skip
    MULU #$A,D4
    SUBI.w #$30,D0
    ADD.w D0,D4
    BSR.w get1bytemain
 'skip
  ;d4=number E+10
  CMP.w #$12,D4
  BHI.w overerr

  ; new >
  LSL.w #3,D4
  LEA fputab,a0
  ADD.l d4,a0

  TST fpu
  BEQ 'skipfpu
    fmove.d 0(a0),fp1
 'skipfpu
  ; < new

  LSR.w #1,d4               ; was #2
  MOVE.l facts(PC,D4.W),D4
RTS


fputab
  Dc.d 1,10,100,1000,10000,100000,1000000,10000000,100000000  ;,1000000000,10000000000
  ;Dc.d 100000000000,1000000000000,10000000000000,100000000000000


facts:
  Dc.l $80000041
  Dc.l $A0000044
  Dc.l $C8000047
  Dc.l $FA00004A
  Dc.l $9C40004E
  Dc.l $C3500051
  Dc.l $F4240054
  Dc.l $98968058
  Dc.l $BEBC205B
  Dc.l $EE6B285E
  Dc.l $9502F962
  Dc.l $BA43B765
  Dc.l $E8D4A568
  Dc.l $9184E76C
  Dc.l $B5E6A96F
  Dc.l $E35F2972
  Dc.l $8E1BCA76
  Dc.l $B1A2BD79
  Dc.l $DE0B6C7C


atoi:                                                     ; fetchdec org source, converts string to integer
                                                          ; returns number in D3, divisor for frac in D5

  MOVEQ.l #$01,D5                                         ; divisor for frac convert will be in D5
 'loop
  LSL.l #1,D5                                             ; calculate 10 powerof(loopruns) like:
  MOVE.l D5,D1                                            ; 10 ...
  LSL.l #2,D5                                             ; 100 ...
  ADD.l D1,D5                                             ; 1000 ...

  LSL.l #1,D3                                             ; d3 * 2
  BCS.w overerr                                           ;
                                                          ;
  MOVE.l D3,D1                                            ; d1 = d3
  LSL.l #1,D3                                             ; d3 * 2
  BCS.w overerr                                           ;
                                                          ;
  LSL.l #1,D3                                             ; d3 * 2
  BCS.w overerr                                           ;
                                                          ;
  ADD.l D1,D3                                             ; d3 = d3 + d1
  SUBI.w #$30,D0                                          ; d0 = d0 - 48 (48: asc("0"))
  ADD.l D0,D3                                             ; d3 = d3 + d0
  ; new >
  !fget                                                   ;
  CMP.b #1,d0                                             ; if
  BNE 'cm1
    SUBQ.l #1,a5
    BSR get1bytemain
 'cm1

  CMP.b #$7e,d0                                             ; 127
  BNE 'cm2
    SUBQ.l #1,a5
    BSR get1bytemain
 'cm2

  TST.b d0
  BPL 'l10
    LSL.w #8,d0
    MOVE.b (a5)+,d0
    MOVE.w d0,lastchar
 'l10

  !test_for_literal                                                ;bsr.w tstnum ;cmake bug
  ; < new
  BEQ.w 'loop
RTS


dfetch:  Ds.w 1                                            ;fetching data?


fetchnum3:
  MOVE.w dfetch(PC),D1
  BEQ.w 'doit
    CLR.w dfetch
     RTS                ;1 number value write
 'doit

  ; new >
  MOVE.b d2,isconstantvalue
  MOVE.l d0,lastconstantvalue
  MOVE.w d2,imm_size
  MOVE.w regnum,imm_reg
  MOVE.l destpointer,imm_addr                           ; long
  ;< new

  ;datatypes...
  ;#byte=1
  ;#word=2
  ;#long=3
  ;#quick=4
  ;#float=5
  ;#string=7

  CMP.w #$3,D2          ; order of cmp/beq in org soure is different
  BEQ.w 'long
  CMP.w #$5,D2                                          ;float
  BEQ.w 'long
  CMP.w #$1,D2
  BEQ.w 'word
  CMP.w #$2,D2
  BEQ.w 'word
  CMP.w #$4,D2
  BEQ.w 'long
  BRA.w mismatcherr

 'word
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$303C,D1
  BSR.w writeword      ; old label "pokewd"
  MOVE.w D0,D1
  BSR.w writeword
  BRA.w reget

 'long
  MOVEQ #0,d1
  MOVE.w regnum,D1

  TST.b fpu                                         ; fpu-optimization on ??
  BEQ 'f1
    CMP.w #5,d2                                     ; float ?
    BEQ 'l10
      BRA 'f2
 'f1
  TST.b iee
  BNE 'l10
 'f2

  LSL.w #8,D1                                       ; move register number to the left opcode byte
  LSL.w #1,D1

;  CMP.l #127,D0                                     ; check if value is in byte range and optimize opcode to "moveq"
;  BGT 'nomoveq
;    CMP.l #-128,D0
;    BLT 'nomoveq
;      BRA 'writemoveq
; 'nomoveq:
  ORI.w #$203C,D1                                   ; write opcode "move.l"
  BSR.w writeword
  MOVE.l D0,D1
  BSR.w writelong
  BRA.w reget

  ; --- FPU optimization: use fpu-calls instead 68k ones
 'l10                                               ;fpu constant
  MOVEQ #5,d2
  ASL.l #7,d1
  SUBQ.l #8,a7
CNIF #64bitconstant
  OR.l #$f23c5400,d1                                   ;fmove.d
  fmove.d fp0,0(a7)
CELSE
  OR.l #$f23c4400,d1                                   ;fmove.s
  fmove.s fp0,0(a7)
CEND
  JSR writelong
  MOVE.l (a7)+,d1
  JSR writelong
  MOVE.l (a7)+,d1

CNIF #64bitconstant
  BSR writelong
CEND
  BRA.w reget
  ; < new

'writemoveq:
  ;AND.w #$0F00,D1                                   ;Fix the opcode from "move.l" to "moveq"
  OR.w #$7000,D1
  OR.b D0,D1
  BSR.w writeword
BRA.w reget



;-----------end of number fetch-------------;

makeint:
  MOVE.l D3,D0
  TST.w D6
  BEQ.w 'skip                   ;already integer
    MOVEA.l _mathffpbase,A6
    JSR _SPFix(A6)
  BVC.w 'skip
    ADDQ.w #4,A7
    BRA.w numdofloat
 'skip
  RTS


fetchnum2:
  MOVEQ.l #$00,D6          ;no frac

  TST.b fpu
  BEQ 'nofpu3
    fmove.l d3,fp0
 'nofpu3

 nofpregload:
  ;< new
  BSR.w consttype2
BRA.w fetchnum3


constotype:                             ; ??? looks like not used ???
  ;fetch a constant of type d2          ;
  ;                                     ;
  ;return new type in d2!               ;
  ;                                     ;
  MOVE.w D2,-(A7)                       ;
  BSR.w evalconst                      ;  "
  MOVE.w (A7)+,D2

consttype2:
  TST.w D2
  BNE.w 'something
    ;
    ;Let's set type
    ;
    TST.w D6
    BEQ.w 'nofrac
      MOVEQ.l #$04,D2
      BRA.w 'quick2
   'nofrac
    MOVEQ.l #$02,D2
    BRA.w 'byte

 'something
  CMP.w #$1,D2
  BEQ.w 'byte
    CMP.w #$2,D2
    BEQ.w 'word
      CMP.w #$3,D2
      BEQ.w 'long
        CMP.w #$4,D2
        BEQ.w 'quick
          CMP.w #$5,D2
            BEQ.w 'float
              BRA.w mismatcherr

 'byte
  BSR.w makeint                                          ;bugfix if a.b=$90 bug fix
  CMP.l #$7f,D0             ;127
  BGT.w 'over1
    CMP.l #$FFFFFF80,D0       ;-128
    BGE.w 'dobword
 'over1
  MOVEQ.l #$02,D2                                          ;was 2 before
  CMP.l #$7fff,D0           ;32767
  BGT.w 'byte2
    CMP.l #$FFFF8000,D0       ;32768
    BGE.w 'dobword
 'byte2
  MOVEQ.l #$03,D2
  BRA.w 'dobword

  ; new >
; errorbytes2                                                ;??looks like not used anymore
; JMP errorbytes


; 'byte                                                ;??looks like old doubled code??
;  BSR.w makeint                                          ;if a.b=$90 bug
;  CMP.l #$7F,D0
;   BGT.w 'over1
;  CMP.l #$FFFFFF80,D0
;   BGE.w 'dobword

; 'over1
;   MOVEQ.l #$02,D2
;  CMP.l #MaxWordSgnd,D0
;   BGT.w 'byte2
;  CMP.l #$FFFF8000,D0
;   BGE.w 'dobword

; 'byte2
;  MOVEQ.l #$03,D2
; BRA.w 'dobword
   ; < new

 'word
  TST.w D6
  BNE.w 'quick2
    BSR.w makeint
    BRA.w 'over1

 'quick
  BSR.w makeint
  TST.w D6
  BEQ.w 'qint

 'quick2
  CMP.l #MaxWordSgnd,D0   ; 32767
  BGT.w numdofloat
  CMP.l #$FFFF8000,D0     ; -32768
  BLT.w numdofloat
  ;
  MOVE.w D0,-(A7)         ; save whole part
  JSR _SPFlt(A6)          ; back to ffp
  MOVE.l D0,D1
  MOVE.l D3,D0
  JSR _SPSub(A6)          ; subtract - d0=fraction!
  MOVE.l #$80000051,D1    ; 65536
  JSR _SPMul(A6)          ; *65536
  JSR _SPFix(A6)          ; back to int
  ;
  BEQ.w 'knob             ; numdofloat
    CMP.l #$10000,D0      ; 65536
    BCC.w 'knob           ; numdofloat
      MOVE.w D0,D1
      MOVE.w (A7)+,D0
      SWAP D0
      MOVE.w D1,D0
      BRA.w 'dolong
 'knob
  ADDQ.w #2,A7
  BRA.w numdofloat

 'qint
  CMP.l #MaxWordSgnd,D0   ;#32767
  BGT.w 'byte2

  CMP.l #$FFFF8000,D0     ;#32768
  BLT.w 'byte2

  SWAP D0
  BRA.w 'dolong

 'long
  TST.w D6
  BNE.w numdofloat

  MOVE.l D3,D0
  BRA.w 'dolong

 'float
  TST.w D6
  BNE.w numdofloat

  MOVE.l D3,D0
  MOVEA.l _mathffpbase,A6
  JSR _SPFlt(A6)           ;int to float
  MOVE.l D0,D3
  BRA.w numdofloat

 'dobword
 'dolong
RTS


numdofloat:
  MOVEQ.l #$05,D2
  MOVE.l D3,D0
RTS


;pushfrom:                                                 :??Looks like not used??
            Ds.l 1                                         ;??Looks like unused data??
pushpc:     Ds.l 1
pushoff:    Ds.l 1
pushdooff:  Ds.l 1
pushclen:   Ds.w 1
pushat:     Ds.l 1


pushstart:
  ;Here, we prepare to collect code to be saved and added
  ;later
  MOVE.l destpointer,pushpc
  MOVE.l hunkoffsetbase,pushoff
 RTS


pushdo:
  ;OK, push code since push start
  ;
  MOVEM.l D0-D1/A0-A1,-(A7)
  ;
  MOVE.l destpointer,D0
  MOVE.l pushpc(PC),D1
  MOVE.l D1,destpointer    ;New PC
  SUB.l D1,D0              ;len
  MOVE.w D0,pushclen
   BEQ.w 'skip
  MOVE.w dontwrite_nomemleft,D1
   BNE.w 'skip
  ;
  ; new >
   CMP.w #1000,pushclen
   BGE conmemerr
   MOVE.l pushat,d0
   BNE 'nomem
   MOVE.l #1024,d0
  ; < new
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  ; new >
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  ; < new
  ;jsr do_AllocMem
  MOVE.l D0,pushat

  ; new >
 'nomem
  ; < new
  MOVEA.l D0,A0          ;destination
  MOVEA.l pushpc,A1      ;source
  MOVE.l A1,destpointer
  MOVE.w pushclen,D0
  LSR.w #1,D0
  SUBQ.w #1,D0           ;to word dbf

 'loop
    MOVE.w (A1)+,(A0)+
  DBF D0,'loop

   MOVE.l hunkoffsetbase,pushdooff

 'skip
  MOVEM.l (A7)+,D0-D1/A0-A1
RTS


pushput:
  ;replace pulled out code!
  ;
  MOVEM.l D0-D1/A0-A1,-(A7)
  MOVEQ.l #$00,D0
  MOVE.w pushclen,D0
   BEQ.w 'skip
  MOVE.l destpointer,D1     ;pc before put
  ADD.l D0,destpointer
  TST.w dontwrite_nomemleft
   BNE.w 'skip
  ;
  LSR.w #1,D0
  SUBQ.w #1,D0
  ;
  MOVEA.l D1,A1
  MOVEA.l pushat,A0

 'loop
    CMPA.l destbufferend,A1
    BCS.w 'ok

    MOVE.w #$FFFF,dontwrite_nomemleft    ; was -1
  BRA.w 'skip

   'ok
     MOVE.w (A0)+,(A1)+                                    ;copylibcode
  DBF D0,'loop
  ;
  ;OK, now all offsets between pushdooff and pushoff must
  ;be adjusted by d1-pushpc
  ;
  SUB.l pushpc,D1
  BEQ.w 'skip2
  MOVEA.l pushdooff,A0

 'loop2
  CMPA.l pushoff,A0
  BEQ.w 'done
  MOVEA.l $4(A0),A1          ;address in prog.
  ADDA.l destbufferstart,A1
  CMPA.l destbufferend,A1
  BCC.w 'next                ;leave offs >= lib
  ADD.l D1,$4(A0)

 'next
  MOVEA.l (A0),A0
 BRA.w 'loop2

 'done   ;Whew!
 'skip2
  MOVEA.l pushat,A1
  MOVEQ.l #$00,D0
  MOVE.w pushclen,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
   ;JSR _FreePooled(A6)

 'skip
  MOVEM.l (A7)+,D0-D1/A0-A1
RTS


muld1:                            ;generate code for #d1.w*regat
  MOVE.l D1,-(A7)                 ;array mul
  MOVEQ.l #$00,D2
  MOVEQ.l #$0F,D3

 'shloop
    LSL.w #1,D1
    BCC.w 'shskip
      ADDQ.w #1,D2
      MOVE.w D3,D4
   'shskip
  DBF D3,'shloop

  SUBQ.w #1,D2
  BNE.w 'domul
    ADDQ.w #4,A7           ; was 2
    MOVE.w D4,D1
    BEQ.w 'done
      CMP.w #$8,D1
      BCS.w 'once
        SUBI.w #$8,D1
        BSR.w 'once
          MOVEQ.l #$00,D1
     'once
      LSL.w #8,D1
      LSL.w #1,D1
      ORI.w #$E188,D1                               ;lsl.l #,dx
      OR.w regnum,D1
      BRA.w writeword
   'done
    RTS
 'domul

  ; new >
  MOVEQ #0,d1
  MOVE.w regnum,D1
  ; < new


  BRA 'nooptimize
  ;TST #0;##optimize_68020
  ;BEQ 'nooptimize
    LSL.l #8,D1
    LSL.l #4,D1
    OR.l #$4c3c0000,d1    ; MULU.L #x,d0
    OR.w regnum,d1
    BSR.w writelong
    MOVE.l (A7)+,D1
    BRA writelong
    ;BRA 'optimize_end
  'nooptimize
    LSL #8,d1
    LSL #1,d1
    ORI #$C0FC,D1       ; MULU.w #x,d0
    BSR writeword
    MOVE.l (a7)+,d1
    BRA writeword
  'optimize_end


makeinits:
  ;make any initialing jsr's
  ;
  MOVE.l destpointer,-(A7)
  MOVEQ.l #-$01,D7

 'loop
    BSR.w findhilib
     BEQ.w 'done
    TST.w $C(A2)
     BPL.w 'loop
    MOVE.l $16(A2),D1
    BEQ.w 'loop
    ;
    MOVE.w $4(A2),D1                                       ; check state in D1 and do some things
    CMP.w #-$2,D1          ; was #allocvars
     BNE.w 'notvar
    BSR.w makevsize
 BRA.w 'more

 'notvar
    CMP.w #-$5C4,D1       ; was #debuglib
     BNE.w 'notdebuglib
  ;
  ;pass flag in d0 : non zero=auto run
  ;
    MOVE.w #$7000,D1      ;moveq #0,d0
    BTST #$7,autorun
    SNE D1
    BSR.w writeword
 BRA.w 'more

 'notdebuglib
    CMP.w #-$12D,D1       ; was 65235
     BNE.w 'notstring1
    BSR.w makessize
 BRA.w 'more

 'notstring1
    CMP.w #-$1F5,D1       ; was 65035
     BNE.w 'notexit
  ;
    MOVE.w #$203C,D1
    BSR.w writeword
    BSR.w addoff
    MOVE.l endop,D1
    BSR.w writelong
 BRA.w 'more

 'notexit
    CMP.w #-$3E9,D1       ; was 64535
    BNE.w 'notdatalib
      MOVE.w #$203C,D1
      BSR.w writeword
      BSR.w addoff
      MOVE.l data2at,D1
      BSR.w writelong
      BRA.w 'more
   'notdatalib
      CMP.w #$1,D1          ; was #dhandlerlib
      BNE.w 'notdhandler
        MOVE.w #$203C,D1
        BSR.w writeword
        MOVE.l d0,-(a7)      ; store d0
        !basic
        GetReg D0,config\ptr_seg_debugger
        !asm
        ;MOVE.l ptr_seg_debugger,D1
        MOVE.l D0,D1
        MOVE.l (a7)+,D0      ; restore d0
        BSR.w writelong
     'notdhandler
   'more
    MOVE.l $16(A2),D1
    MOVE.w #$FFFF,lasta6     ; was -1
    BSR.w Amakelibsub
    CMPI.w #$FFFE,$4(A2)     ; was #allocvars
     BNE.w 'notvar2
  ;
    MOVE.l intdata1,D1
     BEQ.w 'notvar2
    MOVE.w putidata1,D1
    BSR.w writeword
    BSR.w addoff
    MOVE.l intdata1,D1
    BSR.w writelong

 'notvar2
    MOVE.w #$2B40,D1
    TST.w $1A(A2)
     BEQ.w 'loop
     BPL.w 'long
    MOVE.w #$3B40,D1

 'long
    BSR.w writeword
    MOVE.w $A(A2),D1
     BSR.w writeword
    CMPI.w #$FFFA,$4(A2)   ; was #65530
     BNE.w 'loop
    ;
    MOVE.w D7,-(A7)
    MOVE.w numstatic,D4
     BEQ.w 'nostats
    MOVE.l staticdata,D3
     JSR datastart
    MOVE.w #$C500,D1       ; was #alstat
     BSR.w tokejsr2

 'nostats
    MOVE.w maxsused,D4
     BEQ.w 'nomaxs
    MOVE.l maxsat,D3
     JSR datastart
    MOVE.w #$CF00,D1      ; was #setmaxs
     BSR.w tokejsr2

 'nomaxs
    MOVE.w (A7)+,D7
    ;
 BRA.w 'loop

 'done
  ;
  ;misc inits
  ;
  MOVE.l destpointer,D1
  CMP.l (A7),D1
   BNE.w 'yi
  MOVE.w #$0008,noinits+2
 BRA.w 'yi3

 'yi
  CLR.w noinits+2
  MOVE.w dontwrite_nomemleft,D1
   BNE.w 'yi2
  ; new >
  TST.l newinitaddr
   BEQ 'l10
  MOVE.l newinitaddr,D2
  SUB.l destbufferstart,D2
  ADDQ.l #2,d2
  ; < new
  MOVEA.l newinitaddr,A0                                   ;write newinitcode
  ; new >
  ;MOVE.w #$2f00,(a0)+
  ; < new
  MOVE.w #$4EB9,(A0)+
  MOVE.l (A7),(A0)+
  ; new >
  ;MOVE.l #$202f0048,(a0)
 BRA 'l20

 'l10
  MOVEA.l destbufferstart,A0                               ;write initcode
  TST.b saved0
  BEQ 'l1
  MOVE.w #$23c0,(a0)+
  MOVE.l a0,a1
  ADDQ.l #6,a1
  MOVE.l a1,(a0)+
  ; < new
  MOVEQ.l #$02,D2
  BSR.w addhunkoffset
  ; new >
  MOVE.w #$6004,(a0)+
  MOVE.l #$4e714e71,(a0)+

 'l1
  MOVE.w #$4EB9,(A0)+
  MOVE.l (A7),(A0)+
  MOVEQ #2,d2
  TST.b saved0
  BEQ 'l20
  MOVEQ.l #14,D2

 'l2
  BSR.w addhunkoffset
  MOVE.w #$2039,(a0)+
  MOVE.l a1,(a0)+
  MOVEQ.l #20,d2

 'l20
  BSR.w addhunkoffset
  ; < new

 'yi2
  MOVE.w #$4E75,D1
  BSR.w writeword

 'yi3
  ADDQ.w #4,A7
RTS


;------                                                  ;disassembled code begin
;prepd1:                                                   ;??looks like label not used??
  Dc.b $22,$2D,$00,$00                                     ;MOVE.L  $0000(A5),D1
putidata1:
  Dc.b $23,$CD,$00,$00,$00,$00                             ;MOVE.L  A5,$00000000
;prepint:                                                  ;??looks like label not used??
  Dc.b $24,$7C,$00,$00,$00,$00                             ;MOVEA.L #$00000000,A2
;------                                                  ;disassembled code end
Even

makessize:
  MOVE.l stringbuffer,D1
BRA.w makesize

makevsize:
  ;create code for amount of variables in d0
  ;
  MOVEQ.l #$00,D1
  MOVE.w globalvarpointer,D1
  SUBI.w #$8000,D1
  BNE.w makesize
    MOVEQ.l #$08,D1

makesize:
  ;create code for #d1 into d0
  ;
  MOVE.l D1,-(A7)
  MOVE.w #$203C,D1                       ;move.l #x,d0
  BSR.w writeword
  MOVE.l (A7)+,D1
BRA.w writelong


findhilib:
    ;find highest lib# under d7. set d7 to this lib number
    ;
    ;ne if found, eq if not
    ;
  MOVEQ.l #$00,D1
  MOVEA.l libpointer,A1

 'loop
    CMPA.w #$0,A1
    BEQ.w 'done
      CMP.w $4(A1),D7
      BLS.w 'next
        CMP.w $4(A1),D1
        BCC.w 'next
          MOVE.w $4(A1),D1
          MOVEA.l A1,A2

 'next
    MOVEA.l (A1),A1
 BRA.w 'loop

 'done
  MOVE.w D1,D7
RTS


findlolib:
    ;find lowest lib# above d7. set d7 to this lib number
    ;
    ;ne if found, eq if not
    ;
  MOVEQ.l #-$01,D1
  MOVEA.l libpointer,A1

 'loop
    CMPA.w #$0,A1
     BEQ.w 'done
    CMP.w $4(A1),D7
     BCC.w 'next
    CMP.w $4(A1),D1
     BLS.w 'next
    MOVE.w $4(A1),D1
    MOVEA.l A1,A2

 'next
    MOVEA.l (A1),A1
BRA.w 'loop

 'done
  MOVE.w D1,D7
  CMP.w #-$1,D1
RTS


makefinits:
    ;create jsr's to FINIT routines from libs
;
;also calculate the REGAT variables for inits!
;
  ADDQ.w #1,globalvarpointer
  BCLR #$0,globalvarpointer+1
  MOVEQ.l #$00,D7

 'loop
    BSR.w findlolib
    BEQ.w 'azdone
    TST.w $C(A2)
    BPL.w 'loop

 'skipvar
    MOVEA.l A2,A1
    ADDA.l $12(A1),A1
    TST.w -$2(A1)
    BEQ.w 'nomax
  ;
  ;A max lib, possible multiple frees!
  ;
    MOVE.l -$A(A1),D1
    LEA $6(A2,D1.L),A3

 'plop
      TST.w (A3)+
      BEQ.w 'plopf
        ADDQ.w #2,A3
 BRA.w 'plop

 'plopf
    TST.l $4(A3)
    BEQ.w 'nomax
  ;
  ;Something to Do!
  ;
      MOVE.w freemax(PC),D1    ;move.w #x,-(a7)
      BSR.w writeword
      MOVE.w -$4(A1),D1
      BSR.w writeword          ;x (max)
      MOVE.l free,D1
      MOVE.w -$6(A1),D1
      BSR.w writelong          ;move.l x(a5),a3
      ;
      MOVE.l destpointer,-(A7)
      MOVEQ.l #$01,D1
      MOVE.w -$2(A1),D2
      LSL.w D2,D1
      MOVE.w D1,-(A7)
      MOVE.l -$A(A1),D1
      BSR.w Amakelibsub
      MOVE.w freemax3(PC),D1
      BSR.w writeword          ;lea x(a3),a3
      MOVE.w (A7)+,D1
      BSR.w writeword
      MOVE.l freemax2(PC),D1
      BSR.w writelong
      MOVE.l (A7)+,D1
      SUB.l destpointer,D1
      BSR.w writeword
      MOVE.w freemax4(PC),D1
      BSR.w writeword

 'nomax
    MOVE.l $1C(A2),D1
    BEQ.w 'loop
  ;
  ;check special cases!
  ;
    MOVE.w $4(A2),D1
    CMP.w #-$2,D1              ; was #allocvars
    BNE.w 'notvfin
      BSR.w makevsize
 BRA.w 'more

 'notvfin
    CMP.w #-$12D,D1            ; was #65235
    BNE.w 'more
      BSR.w makessize
 BRA.w 'more

 'notstring1
 'more
    MOVE.l $1C(A2),D1
    MOVE.w #$FFFF,lasta6       ; was -1
    BSR.w Amakelibsub
 BRA.w 'loop

 'azdone
RTS


;------                                                  ;disassembled code begin
freemax:   Dc.b $3F,$3C,$00,$00                            ;MOVE.W  #$0000,-(A7)

freemax2:  Dc.b $53,$57                                    ;SUBQ.W  #1,(A7)
           Dc.b $66,$00,$FF,$FC                            ;BNE.W freemax2
freemax4:  Dc.b $54,$4F                                    ;ADDQ.W  #2,A7
freemax3:  Dc.b $47,$EB,$00,$00                            ;LEA $0000(A3),A3
;------                                                  ;disassembled code end

Even
chkstak:
  TST.b debugmode
  BEQ.b 'skip
    TST.w debugversion
    BNE.b 'skip
      MOVE.w #$C308,D1
      BRA.w Atokejsr
 'skip
RTS


tokejsr2:
  MOVE.w #$FFFF,lasta6

Atokejsr:                                                 ;tokejsr org source
    ;make a jsr (or simple reg get) from d1
    ;
  MOVEM.l D0-d7/A0-a6,-(A7)
  MOVE.b #1,nostringopt
  JSR searchinstr
  MOVE.l A3,D1
  SUB.l A2,D1
  BSR.w Amakelibsub
  MOVEM.l (A7)+,d0-d7/a0-a6
RTS


userjsr:
    ;a2 = lib base of the current command
    ;a1 = start of #parameters
    ;
  MOVE.l libisat,-(A7)                                   ;library write
  MOVE.l A2,libisat

  MOVEA.l A1,A2
  MOVE.w (A2)+,D1
  MOVE.l a2,lastinstructionaddr
  ANDI.w #$FF,D1
  ADDA.w D1,A2
  EXG.l D0,A2
  ADDQ.l #1,D0
  BCLR #$0,D0
  EXG.l D0,A2
BRA.w makelsub2


cutejsr:
  MOVE.l libisat,-(A7)
  MOVE.l A2,libisat
  MOVEA.l A3,A2
BRA.w makelsub2


scantype
  MOVE.l a1,-(a7)

 'more
  MOVE.l d0,a0
  MOVE.l $a(a0),d0
  MOVE.l d0,a1
  CMP.l #8,4(a1)
  BLE 'norec
  MOVE.l a0,-(a7)
  MOVE.l typebase,-(a7)
  MOVEQ #0,d0
  MOVE.w 4(a0),d0
  ADD.l d0,typebase
  MOVE.l $4(a1),d0
  BSR scantype
  MOVE.l (a7)+,typebase
  MOVE.l (a7)+,a0

 'norec
  CMP.l #newtype_string,d0
  BNE 'nostring
  ADDQ #2,a2offset
  MOVE.l #$3f3c0000,d1
  MOVEQ #0,d0
  MOVE.w 4(a0),d0
  ADD.l typebase,d0
  MOVE.w d0,d1
  BSR writelong
  TST.b debugmode
  BEQ 'l1a
  MOVE.l d1,-(a7)
  MOVE.l #$c308,d1
  JSR Atokejsr
  MOVE.l (a7)+,d1

 'l1a
  TST.w 8(a0)
  BEQ 'nostring
  MOVEM.l d2/d3,-(a7)
  MOVE.l d1,d2
  MOVEQ #0,d3
  MOVE.w 8(a0),d3
  SUBQ.l #1,d3
  BEQ 'nostring2

 'loop
  ADDQ.l #4,d2
  MOVE.l d2,d1
  BSR writelong
  TST.b debugmode
  BEQ 'l1
  MOVE.l #$c308,d1
  JSR Atokejsr

 'l1
  ADDQ #2,a2offset
  SUBQ.l #1,d3
  BNE 'loop

 'nostring2
  MOVEM.l (a7)+,d2/d3

 'nostring
  MOVE.l (a0),d0
  BNE 'more
  MOVE.l (a7)+,a1
RTS


libisat:   Ds.l 1


Amakelibsub:                                               ;makelibsub org source
  ;lib in a2, sub offset in d1
  ;
  MOVE.l libisat,-(A7)                                   
  MOVE.l A2,libisat
  LEA $6(A2,D1.L),A2

makelsub2:                                                ;??Look like double label??
  ; new >
 .writetype
  CMP.l #$3e19436c,$1c-8(a2)                               ;clear type
  BEQ 'dowritevar
  CMP.l #$3e18436f,$1c-8(a2)                               ;copy type
  BEQ 'dowritevar
  CMP.l #$3e175265,$1c(a2)
  BEQ 'dowritevar
  CMP.l #$3e165772,$1c(a2)
  BNE 'nowritef

 'dowritevar
  MOVEM.l a0-a2/d2,-(a7)
  MOVEQ #0,d1
  MOVE.l #0,typebase
  MOVE.l $a(a3),a0
  MOVE.l $4(a0),d0
  CMP.l #8,d0
  BLE 'notype
    BSR scantype
 'notype

  MOVE.l #$3f3c0000,d1
  MOVE.w a2offset,d1
  BSR writelong
  MOVE.l #$3f3c0000,d1
  MOVE.l $a(a3),a0
  MOVE.w 8(a0),d1
  BSR writelong
  MOVE.l #$3f3cab12,d1
  BSR writelong
  ADDQ.w #6,a2offset
  MOVEM.l (a7)+,a0-a2/d2

 'nowritef
  TST.b fpu
  BEQ 'nofpu2

  CMP.l #$496e7400,$1a(a2)                                  ; "Int"
  BNE 'noint
  MOVEQ #0,d1
  SUBQ.l #8,destpointer                                    ;fpu int

  CLR.w a2offset
  CMP.b #2,d2                                              ; word ?
  BGT 'noword
    MOVE.w #$48c0,d1                                       ; opcode EXT.l d0+
    OR.w regnumstore,d1
    BSR writeword
    BRA 'exit2
 'noword

  CMP.b #3,d2                                              ; long ?
  BNE 'nolong
    BRA 'exit2
 'nolong

  CMP.b #4,d2                                              ; quick ?
  BNE 'noquick
    MOVE.w #$e080,d1
    OR.w regnumstore,d1
    BSR writeword
    MOVE.w #$e080,d1
    OR.w regnumstore,d1
    BSR writeword
    BRA 'exit2
 'noquick

  MOVEQ #0,d0
  MOVEQ #0,d1
  MOVE.w regnumstore,d0
  ASL.l #7,d0
  OR.l #$f23c4428,d1                                 ;fsub.s 0.5,fpx
  OR.l d0,d1
  ;BSR writelong
  MOVE.l #$3f000000,d1
  ;BSR writelong
  MOVEQ #0,d0
  MOVEQ #0,d1
  MOVE.w regnumstore,d0
  ASL.l #7,d0
  MOVE.l d0,d1
  OR.l #$f2000003,d1                                 ;fintrz fpx
  ASL.l #3,d0
  OR.l d0,d1
  BSR writelong
  MOVEQ #0,d0
  MOVE.w regnumstore,d0
  ASL.l #7,d0
  MOVE.l #$f2006000,d1                               ;fmove.l fp0,d0
  OR.l d0,d1
  ASL.l #1,d0
  ASL.l #8,d0
  OR.l d0,d1
  BRA 'exit

 'noint
  CMP.w #$3c01,24(a2)
  BNE 'noval
    MOVE.l a2,-(a7)
    BSR.w makelsub3
    MOVE.l (a7)+,a2
    BRA 'exit2

;  MOVE.l (a7),a2
;  MOVE.w (a2),-(a7)                                        ;fpu val
;  MOVE.w #$c0,(a2)
;  BSR.w fetchregs
;  MOVE.l #$4eaeff9a,d1                                     ;SPtieee
;  BSR writelong
;  MOVE.l 2(a7),a2
;  MOVE.w (a7)+,(a2)
;  MOVE.l (a7)+,a2
;  MOVE.l #$4a876604,d1
;  BSR writelong
;  MOVE.l #$f2004400,d1                                     ;fmove.s d0,fp0
;BRA 'exit

 'noval
  CMP.l #$41627300,$1a(a2)                                  ; "Abs"
  BNE 'noabs
    MOVEQ #0,d1
    MOVE.w regnumstore,d1
    MOVE.w d1,d0
    ASL.w #7,d1
    ASL.w #8,d0
    ASL.w #2,d0
    OR.w d0,d1
    SUBQ.l #8,destpointer                                    ;fpu abs
    MOVEM.l d3/d1,-(a7)
    MOVE.w #5,d3
    EXG d2,d3
    MOVE.w regnum,-(a7)
    MOVE.w regnumstore,regnum
    BSR writeconvertcode
    MOVE.w (a7)+,regnum
    EXG d2,d3
    MOVEM.l (a7)+,d3/d1
    OR.l #$f2000018,d1
    CLR.w a2offset
    BRA 'exit
 'noabs

  CMP.b #5,d2                                                ; do we have a float?
  BNE 'nofpu2

  MOVE.b 24(a2),d0
  CMP.b #$60,d0                                            ;nolib $edxx
  BNE 'nofpu

  MOVEQ #0,d1
  MOVE.w regnumstore,d1
  MOVE.w d1,d0
  ASL.w #7,d1
  ASL.w #8,d0
  ASL.w #2,d0
  OR.w d0,d1

  MOVE.b 25(a2),d0
  CMP.b #5,d0
  BNE 'nocos
    OR.l #$f200001d,d1                                       ;fpu cos
    BRA 'exit
 'nocos
  CMP.b #$c,d0
  BNE 'nosqr
    OR.l #$f2000004,d1                                       ;fpu sqr
    BRA 'exit
 'nosqr
  CMP.b #$d,d0
  BNE 'notan
    OR.l #$f200000f,d1                                       ;fpu tan
    BRA 'exit
 'notan
  CMP.b #$a,d0
  BNE 'nosin
    OR.l #$f200000e,d1                                       ;fpu sin
    BRA 'exit
 'nosin
  CMP.b #$3,d0
  BNE 'noasin
    OR.l #$f200000c,d1                                       ;fpu asin
    BRA 'exit
 'noasin
  CMP.b #$2,d0
  BNE 'noacos
    OR.l #$f200001c,d1                                       ;fpu acos
    BRA 'exit
 'noacos
  CMP.b #$4,d0
  BNE 'noatan
    OR.l #$f200000a,d1                                       ;fpu atan
    BRA 'exit
 'noatan
  CMP.b #$e,d0
  BNE 'nohtan
    OR.l #$f2000009,d1                                       ;fpu htan
    BRA 'exit
 'nohtan
  CMP.b #$6,d0
  BNE 'nohcos
    OR.l #$f2000019,d1                                       ;fpu hcos
    BRA 'exit
 'nohcos
  CMP.b #$b,d0
  BNE 'nohsin
    OR.l #$f2000002,d1                                       ;fpu hsin
    BRA 'exit
 'nohsin
  CMP.b #$9,d0
  BNE 'nolog
    OR.l #$f2000014,d1                                       ;fpu log
    BRA 'exit
 'nolog
  CMP.b #$8,d0
  BNE 'nolog10
    OR.l #$f2000015,d1                                       ;fpu log10
    BRA 'exit
 'nolog10
  CMP.b #$7,d0
  BNE 'noexp
    OR.l #$f2000010,d1                                       ;fpu exp
    BRA 'exit
 'noexp
  LEA fpuerr,a0
  MOVE.l a0,-(a7)
  JMP handle_compileerror
 ;BRA 'exit                                                  ;??Looks like unneeded code??

 'nofpu
  CMP.b #$3c,d0
  BNE 'nofpu2

  MOVEQ #0,d1
  MOVE.w regnumstore,d1
  MOVE.w d1,d0
  ASL.w #7,d1
  ASL.w #8,d0
  ASL.w #2,d0
  OR.w d0,d1

  CMP.b #$03,25(a2)
  BNE 'nosgn
    ;BRA 'noexp
    SUBQ.l #8,destpointer                                ;fpu sgn
    OR.l #$f200003a,d1
    BSR writelong
    CLR.w a2offset
    MOVE.l #$F28E0006,d1
    BSR writelong
    MOVE.l #$7000600a,d1
    BSR writelong
    MOVE.l #$70014840,d1
    BSR writelong
    MOVE.l #$F292,d1
    BSR writeword
    MOVE.l #$000470FF,d1
    BRA 'exit
 'nosgn
  CMP.l #"Frac",$1a(a2)
  BNE 'nofrac
    JMP notwork

;        MOVE.l d0,-(a7)
;        MOVEQ #0,d1
;        MOVE.w regnumstore,d1
;        ASL.w #7,d1
;        OR.l #$f23c4428,d1
;        ;OR.l #$f2000380,d1
;        BSR writelong                                      ;fsub.s #-0.5,fp0
;        MOVE.l #$3f000000,d1
;        BSR writelong
;        MOVE.w regnumstore,d1
;        ASL.l #8,d1
;        ASL.l #8,d1
;        OR.l #$f2006000,d1                                 ;fmove.l fp0,d0
;        MOVE.w regnumstore,d0
;        ASL.w #7,d0
;        OR.w d0,d1
;        ;OR.l #$f2000380,d1                                 ;fmove.x fpx,fp7
;        BSR writelong
;        ;MOVE.l #$f2001f83,d1                              ;fintrz,fp7
;        ;BSR writelong
;        MOVEQ #0,d1
;        MOVE.w regnumstore,d1
;        ASL.w #7,d1
;        OR.l #$f23c4422,d1
;
;        BSR writelong                                      ;fadd.s #-0.5,fp0
;        MOVE.l #$3f000000,d1
;        BSR writelong
;        MOVEQ #0,d1
;        MOVE.w regnumstore,d1
;        ASL.l #8,d1
;        ASL.l #8,d1                                        ;fsub.l d0,fp0
;        OR.l #$f2004028,d1
;        MOVE.w regnumstore,d0
;        ASL.w #7,d0
;        OR.w d0,d1
;        ;SUBQ.l #8,destpointer                              ;fpu frac
;        CLR.w a2offset
;        MOVE.l (a7)+,d0
    BRA 'exit

 'nofrac                                                   ;??Looks like double label??
 'nofpu2
  ; < new
  BSR.w makelsub3                                          ;write lib code
  MOVE.l (A7)+,libisat
  RTS

  ; new >
 'exit
  BSR writelong

 'exit2
  MOVE.l (A7)+,libisat
RTS
  ; < new

makelsub3:
  BSR.w fetchregs         ; get register values, f.e. move.l <basicvar>,d0
  ;
  TST.b debugmode
  BEQ.w 'norerr
  ;
  MOVE.l (A2),D1
  OR.l $8(A2),D1
  BCLR #$0,D1
  TST.l D1
  BEQ.w 'norerr
  ;
  MOVE.l (A2)+,D1
  BTST #$0,D1
  BEQ.w 'skiptt
    TST.w blitzmode
    BPL.w blitzerr
      TST.b debugmode
      BEQ.w 'skiptt2
        MOVE.l D1,-(A7)
        MOVE.w #$C311,D1   ; was #inblitz,
        BSR.w makebtst
        MOVE.l (A7)+,D1
     'skiptt2
      BCLR #$0,D1
 'skiptt
  TST.l D1
  BSR.w doajsr

  MOVE.l (A2)+,D1
  BSR.w doajsrrout
  MOVE.l (A2)+,D1
  BSR.w doajsr
  BRA.w 'more

 'norerr
  BTST #$0,$3(A2)
  BEQ.w 'penis
    ;
    ;Here, the routine can only run in Blitz Mode
    ;
    MOVE.w blitzmode(PC),D1
    BPL.w blitzerr
 'penis

  MOVE.l $4(A2),D1
  BSR.w doajsrrout

 'more
  MOVEA.l libisat,A2
RTS


doajsrrout:
  ;Here, we suss out bit 0 to see if this
  ;can only happen in Amiga mode.
  ;
  BTST #$0,D1
   BEQ.w 'doajsr
  TST.w blitzmode
   BMI.w amigaerr
  TST.b debugmode
   BEQ.w 'doajsr2      
  MOVE.l D1,-(A7)
  MOVE.w #$C312,D1     ; #inamiga,
   BSR.w makebtst
  MOVE.l (A7)+,D1

 'doajsr2
  BCLR #$0,D1

 'doajsr
  TST.l D1

doajsr:
  BEQ.w 'skip
    MOVE.l A1,-(A7)
    BSR.w doajsr2
    MOVEA.l (A7)+,A1
 'skip
RTS


doajsr2:
  MOVEA.l libisat,A0
  TST.w cfetchmode
  BEQ.w 'nfetch
    ADD.l A0,D1
    MOVE.l D1,-(A7)
    MOVE.w #$4EB9,D1
    BSR.w writeword
    MOVE.l (A7)+,D1
    BRA.w writelong
 'nfetch
  ;
  ;d1 is an offset from start of lib.
  ;a0 is start of lib.
  ;
  LEA $0(A0,D1.L),A1
  CLR.w inline

 'cute
  CMPI.b #$A0,(A1)+
  BNE.w 'ugly
  TST.b (A1)+
  BEQ.w 'iszero
    CMPI.b #$1,-$1(A1)
    BEQ.w 'isone
 'iszero
    ;here, code can be made inline.
    MOVE.w (A1)+,inline
    ADDQ.l #4,D1
    BRA.w 'cute
 'isone
    ;here, a blitzmode variation is available
    ;
  TST.w blitzmode
  BPL.w 'inamiga
  ;
  TST.b debugmode
  BEQ.w 'nobrerr

  MOVE.w #$C311,D1       ; was #inblitz,
  BSR.w makebtst

 'nobrerr
  MOVE.l (A1)+,D1
  LEA $0(A0,D1.L),A1
  BRA.w 'cute

 'inamiga
  TST.b debugmode
  BEQ.w 'noarerr
    MOVE.l D1,-(A7)
    MOVE.w #$C312,D1       ; was #inamiga,
    BSR.w makebtst
    MOVE.l (A7)+,D1
 'noarerr
  ADDQ.w #4,A1
  ADDQ.l #6,D1
  BRA.w 'cute

 'ugly
  TST.w inline
   BEQ.w 'notin
  ;here, we copy the inline code.
  SUBQ.w #1,A1
  MOVEA.l A1,A0
  ADDA.w inline(PC),A1
 BRA.w pokecode2

 'notin
  MOVEM.l a0/D1,-(A7)          ; was  d1,-(a7)
  ; new >
  TST.w debugversion
  BEQ 'l11
  BTST #$7,link_debuginfo
  BEQ.w 'l11
  MOVE.l lastinstruction,d1
  BEQ 'l11
  CLR.l lastinstruction
  CMP.l #$e000,d1
  BGE 'ln99
  LEA notf,a0
  CMP.l #$c601,d1
  BNE 'ln1
  LEA strcpy,a0
 BRA 'ln3

 'ln1
  CMP.l #$c700,d1
  BNE 'ln2
  LEA strvar,a0
 BRA 'ln3

 'ln2
  CMP.l #$ce00,d1
  BNE 'ln4
  LEA strcmp,a0
 BRA 'ln3

 'ln4
  CMP.l #$ca00,d1
  BNE 'ln5
  LEA qmul,a0
 BRA 'ln3

 'ln5
  CMP.l #$d000,d1
     BNE 'ln6
     LEA _MaxLen,a0
 BRA 'ln3

 'ln6
  CMP.l #$cb00,d1
  BNE 'ln3
  LEA qdiv,a0
 BRA 'ln3

 'ln99
  MOVE.l d1,a0
  LEA $8(a0),a0

 'l1
  CMP.w #$ffff,(a0)+
  BNE 'l1
  LEA 6(a0),a0

 'ln3
  MOVEM.l a1/a2/d7/d2,-(a7)
  MOVEQ #0,d2
  LEA ptr_parameterstore,a1

 'l2
  ADDQ.l #1,d2
  MOVE.b (a0)+,d0
  CMP.b #"$",d0                                         ;A label contain $ does not work for reassembler and assembler.it is replace with S
  BNE 'nodollar
  MOVE.b #"S",d0

 'nodollar
  CMP.b #"?",d0
  BEQ 'nolabelwrite
  MOVE.b d0,(a1)+
  BNE 'l2
  MOVE.w #"__",-1(a1)
  ADDQ.l #2,d2
  CLR.b 1(a1)
  JSR findlabel2
  BEQ 'l3
  JSR addlabelhash

 'l3
  CLR.l 4(a2)
  MOVE.l $14(a7),a0
  MOVE.l $10(a7),d1
  SUB.l $12(a0),d1
  ADD.l $28(a0),d1
  MOVE.l d1,8(a2)

 'nolabelwrite
  MOVEM.l (a7)+,a1/a2/d7/d2

 'l11                                                      ;peek/poke
  TST.b typecheck
  BEQ 'p1
  MOVE.l lasttoken,d1
  CMP.l #$da01,d1                                          ;poke
  BEQ 'lp1
  CMP.l #$da02,d1                                          ;peek
  BNE 'p1

 'lp1
  TST.b peekaddrsize
  BEQ 'p1
  CMP.b #3,peekaddrsize
  BNE errormsg_onlylong
  CLR.b peekaddrsize
;  BEQ 'p1

; 'p2
;  CMP.w #3,lasttoken
;  BNE errormsg_onlylong

 'p1
   TST.b fpu
  BNE 'optf
  TST.b fast
  BEQ 'l10

 'optf
  CNIF #optibreak
    ILLEGAL
  CEND
  CMP.l #"Poke",20(a2)                                     ;poke
  BNE 'peekopt
  TST.b 24(a2)
  BNE 'peekopt
  CMP.b #3,d2
  BNE 'lw1

 'll1
  MOVE.l #$21821990,d1
 BRA.s 'exitjsr

 'lw1
  CMP.b #2,d2
  BNE 'lb1
  MOVE.l #$31821990,d1
 BRA.s 'exitjsr

 'lb1
  CMP.b #1,d2
  BNE 'lp3
  MOVE.l #$11821990,d1
 BRA.s 'exitjsr

 'lp3
  CMP.b #5,d2
    BNE 'l10
    TST.b fpu
    BEQ 'll1
     MOVE.l destpointer,a4
    CMP.l #$f22d4500,-6(a4)
    BNE 'noglob
    TST.b doublepeek
    BNE 'noglob
    MOVE.w -2(a4),-4(a4)
    MOVE.w #$21ad,-6(a4)
    MOVE.w #$1990,-2(a4)
    MOVE.w #9,peeksize
    ADDQ #8,a7
 RTS

 'noglob
    CMP.l #$f22c4500,-6(a4)
    BNE 'nolocal
    MOVE.w -2(a4),-4(a4)
    TST.b doublepeek                                       ;dont move longfix on double floats
    BNE 'nolocal
    MOVE.w #$21ac,-6(a4)
    MOVE.w #$1990,-2(a4)
    MOVE.w #9,peeksize
    ADDQ #8,a7
 RTS

 'nolocal
    MOVE.w #$f230,d1
    BSR writeword
  MOVE.l #$65001990,d1
  TST.b doublepeek
  BEQ 'exitjsr
  OR.l   #$10000000,d1

 'exitjsr
  ADDQ #8,a7
  MOVE.w #9,peeksize
 BRA writelong

 'peekopt
  CMP.l #"Peek",20(a2)
  BNE 'l10
  TST.b 24(a2)
  BNE 'l10
  CMP.w #7,peeksize
  BEQ 'l10
   CMP.w #3,peeksize
   BNE.s 'lw1a

 'll1a
  MOVE.l #$20301990,d1
 BRA 'exitjsr

 'lw1a
  CMP.w #2,peeksize
   BNE.s 'lb1a
   MOVE.l #$30301990,d1
 BRA 'exitjsr

 'lb1a
  CMP.w #1,peeksize
   BNE.s 'lf1
   MOVE.l #$10301990,d1
 BRA 'exitjsr

 'lf1
  CMP.w #5,peeksize
   BNE 'l10
   TST.b fpu
   BEQ 'll1a
   MOVE.w #$f230,d1
   BSR writeword
   MOVEQ #0,d1
   MOVE.w tempregnum,d1
   ASL.l #7,d1
   ASL.l #8,d1
   ASL.l #8,d1
   ADD.l #$44001990,d1
    TST.b doublepeek
    BEQ 'exitjsr2
    OR.l   #$10000000,d1

 'exitjsr2
 BRA 'exitjsr

 'l10
  ; < new
  MOVE.w #$4EB9,D1
   BSR.w writeword                                         ;writesysjsr
  MOVEM.l (A7)+,a0/D1        ; was  (a7)+,d1
   JSR addoff
  SUB.l $12(A0),D1
  ADD.l $28(A0),D1
BRA.w writelong
                                                       ;??Looks like unneeded code??


makebtst:
  MOVE.w D1,-(A7)
  MOVE.w tstmode(PC),D1
   BSR.w writeword
   BSR.w getbbase
   BSR.w writeword
  MOVE.w (A7)+,D1
  MOVEM.l D0/D3-D7/A0-A2/A4,-(A7)
   BSR.w Atokejsr
  MOVEM.l (A7)+,D0/D3-D7/A0-A2/A4
RTS


getbbase:
    ;this return returns varoff for blitzmode flag
    ;in d1
    ;it will create blitzoff if necessary
    ;
  MOVE.w blitzoff(PC),D1
  CMP.w #-$1,D1
   BNE.w 'done
  ADDQ.w #1,globalvarpointer
  BCLR #$0,globalvarpointer+1
  MOVE.w globalvarpointer,D1
  MOVE.w D1,blitzoff
  ADDQ.w #2,globalvarpointer

 'done
RTS


;------                                                  ;disassembled code begin
tstmode:    Dc.b $4A,$6D,$00,$00                           ;TST.W $0000(A5)
;------                                                  ;disassembled code end

inline:     Ds.w 1
blitzoff:   Dc.w $FFFF                                   ;-1 org source
blitzmode:  Ds.w 1                                       ;+=amiga, -=blitz

Even
fetchregs:
  MOVE.w (A2)+,D1
  BEQ.w 'done
    MOVE.w (A2)+,D2
    BSR.w toreg
    BRA.w fetchregs
 'done
RTS


toreg:
    ;d1=lib num, d2.b=reg num
    ;
  CMP.w #-$100,D2
   BCC.w 'yeah
    ;
  BCLR #$F,D2
   BEQ.w 'nobm
    ;OK, blitz mode must be ON for us to bother doing this one
  TST.w blitzmode
   BMI.w 'yeah
 RTS

 'nobm
  BCLR #$E,D2
   BEQ.w 'yeah
    ;OK, must be in amiga mode
  TST.w blitzmode
   BPL.w 'yeah
 RTS

 'yeah
  JSR uselib
  TST.b D2
  BEQ.w 'norm

  CMP.b #$4,D2
  BNE.w 'suv
    MOVE.w #$0004,-(A7)
    MOVE.l #$FFFFFFFA,-(A7)                                  ;#-6,-(a7) org source
    BRA.w 'sendmd
 'suv
    CMP.b #$3,D2
    BNE.w 'notnmax
      CLR.w -(A7)
      MOVE.l #$FFFFFFFC,-(A7)                                  ;#-4,-(a7) org source
      ;
      ; O.K., we are going to send the current maximum settings.
      ;
 'sendmd
  LSR.w #8,D2
  MOVE.w #$303C,D1                                         ;move.w #x,dn
  BTST #$7,D2
   BEQ.w 'skipad
  MOVE.w #$307C,D1                                         ;move.w #x,an
  CMP.w #$16,D2
   BNE.w 'skipad
  MOVE.w #$FFFF,lasta6                                     ;-1 org source

 'skipad
  ANDI.w #$7,D2
  LSL.w #8,D2
  LSL.w #1,D2
  OR.w D2,D1
   BSR.w writeword
  MOVE.l $12(A1),D1
  ADD.l (A7)+,D1
  MOVE.w $0(A1,D1.L),D1
  ADD.w (A7)+,D1
 BRA.w writeword

 'notnmax
  MOVE.w D2,-(A7)
  LSR.w #8,D2
  CMP.w #$16,D2
   BNE.w 'isnta6
  MOVE.w #$FFFF,lasta6                                     ;-1 org source

 'isnta6
  MOVE.l $12(A1),D1                                        ;objectspace
  MOVE.w -$6(A1,D1.L),-(A7)
   BSR.w makeregop
   BSR.w writeword
  MOVE.w (A7)+,D1
  MOVE.w (A7)+,D2
  TST.b D2
   BPL.w 'skippy1
    ;
    ;<0 - the rest is a register spec.
    ;this reg is used to calc a max item (must be dn)
    ;
   BSR.w writeword                                         ;move.l x(a5),dn
  MOVE.w D2,-(A7)                                          ;store reg used
    ;
  ADDA.l $12(A1),A1
  MOVE.b D2,D1
  ANDI.w #$7,D1
    ;
  TST.b debugmode
   BEQ.w 'norerr
    ;
  MOVE.w D1,-(A7)
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$B07C,D1                                          ;cmp #x,dn
   BSR.w writeword
  MOVE.w -$4(A1),D1
   BSR.w writeword
  MOVE.l maxchk(PC),D1                                  ;bcs
   BSR.w writelong
  MOVE.l A2,-(A7)
  MOVE.w #$C30A,D1
   BSR.w Atokejsr
  MOVEA.l (A7)+,A2
  MOVE.w (A7)+,D1

 'norerr
  MOVE.w -$2(A1),D2                                        ;shift amount

 'shloop
  CMP.w #$9,D2
   BCS.w 'simp
  MOVEM.w D1-D2,-(A7)
    ;
  MOVEQ.l #$00,D2                                          ;!!!!!
    ;
  LSL.w #8,D2
  LSL.w #1,D2
  OR.w D2,D1
  OR.w lsldn(PC),D1
   BSR.w writeword
  MOVEM.w (A7)+,D1-D2
  SUBQ.w #8,D2
 BRA.w 'shloop

 'simp
  MOVE.w D1,-(A7)
  OR.w #$48c0,d1                                          ; EXT.l d0
  BSR writeword
  MOVE.w (a7),d1
  TST.w D2
  BEQ.w 'simp2
    ;
  ANDI.w #$7,D2                                            ;?????
    ;
  LSL.w #8,D2
  LSL.w #1,D2
  OR.w D2,D1
  OR.w lsldn(PC),D1
   BSR.w writeword

 'simp2
    ;
    ;Shifts are done, add'em to the opcode
    ;
  MOVE.w (A7)+,D1
  ANDI.w #$7,D1
  OR.w maxdo(PC),D1
  MOVE.w (A7)+,D2
  LSL.w #1,D2
  ANDI.w #$E00,D2
  OR.w D2,D1
 BRA.w writeword

 'skippy1
  CMP.b #$1,D2
  BEQ.w 'skippy
    ;
    ;select used of a max block
    ;
    ADDQ.w #4,D1
    ;
    TST.b debugmode
    BEQ.w 'skippy
      BSR.w writeword
      SWAP D1
      MOVE.w 'theretest(PC),D1
      SWAP D1
      BSR.w writelong
      MOVE.l 'theretest+4(PC),D1
      BSR.w writelong
      MOVE.l 'theretest+8(PC),D1
      BRA.w writelong
 'skippy                                            ;select base of a max block
BRA.w writeword


;------                                                  ;disassembled code begin
 'theretest
            Dc.b $4A,$AD,$00,$00                           ;TST.L  $0000(A5)
            Dc.b $66,$00,$00,$06                           ;BNE.W  'ttskip
            Dc.b $70,$01                                   ;MOVEQ  #$01,D0
            Dc.b $4E,$40                                   ;TRAP   #00
 'ttskip
;------                                                  ;disassembled code end

 'norm
  LSR.w #8,D2
  CMP.b #$16,D2
  BNE.w 'nota6
    MOVE.w $A(A1),D1
    CMP.w lasta6,D1
    BEQ.w 'sk
      MOVE.w D1,lasta6
 'nota6

  BSR.w makeregop
  TST.w $1A(A1)
  BPL.w 'long
    CMP.w stackop(PC),D1
    BNE.w 'notst
      SUBQ.w #2,a2offset
   'notst
    ORI.w #$1000,D1
 'long
  BSR.w writeword
  MOVE.w $A(A1),D1
  BSR.w writeword

 'sk
RTS


;------                                                                 ;disassembled code begin
lsldn:      Dc.b $E1,$88                 ;Dc.b $48 ;object long acsess    ;LSL.L   #8,D0
maxchk:     Dc.b $65,$00,$00,$08                                          ;BCS.W   maxchk_ok
            Dc.b $4E,$B9,$00,$00,$00,$00                                  ;JSR     $00000000
maxchk_ok:

maxdo:      Dc.b $D1,$C0                                                  ;ADDA.L  D0,A0        ;old Dc.b $d0 $C0,00   ;ADDA.W  D0,A0

;stackopuse:                                                              ;??looks like not used??
            Dc.b $00,$00
stackop:    Dc.b $2F,$2D,$00,$00                                          ;MOVE.L  $0000(A5),-(A7)
;------                                                  ;disassembled code end


makeregop:
    ;make move x(a5),dn/an based on d2
    ;
  CMP.b #$FF,D2
   BNE.w 'notst
  MOVE.w stackop(PC),D1
  ADDQ.w #4,a2offset
 RTS

 'notst
  MOVE.l A3,-(A7)
  LEA regtransd,A3
  BTST #$4,D2
   BEQ.w 'skip
  LEA regtransa,A3

 'skip
  ANDI.w #$7,D2
  MOVE.w D2,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w (A3),D1
  MOVEA.l (A7)+,A3
RTS


ifchar:
    ;return eq=1 if <,=,>
    ;
  CMP.w #$3C,D0
   BCS.w 'no
  CMP.w #$3E,D0
   BHI.w 'no
  SUBI.w #$3C,D0
  CMP.w D0,D0

 'no
RTS


evalconst:
  ;bsr.w bakup
  ;
  ;evaluate a constant at a5...
  ;first char in d0...
  ;
  ;get long into d3 (d6=0)
  ;or ffp into d3 (d6<>0)
  ;
  ; new <
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new

evalconst2  ;
evalconst3:
  ;move.l maths,a6
  ;
  ;MOVE.b isconstantvalue,-(a7)                 ;new
  ;MOVE.l lastconstantvalue,-(a7)
  MOVE.w regnum,-(A7)
  CLR.w regnum
  MOVE.l destpointer,-(A7)
  MOVE.l destbufferend,-(A7)
  MOVE.w dontwrite_nomemleft,-(A7)
  MOVE.w lasta6,-(A7)
  MOVE.w cfetchmode,-(A7)
  BNE.w 'something
    MOVE.l destbufferend,oldlibat
    MOVEA.l constpcat,A0
    MOVE.l A0,destpointer
    BRA.w 'some2
 'something
    ;already cfetching!
    ;
    MOVEA.l destpointer,A0     ;continue in cmode buff
 'some2

  MOVE.l A0,-(A7)
  MOVE.l constlibat,destbufferend      ;for overflow
  CLR.w dontwrite_nomemleft

  MOVE.w #$FFFF,lasta6                 ; was -1
  MOVE.w #$FFFF,cfetchmode             ; was -1
  ; new >
  ;clr.b _neg
  ; < new
  BSR.w arreval                      ;!
  ; new >
  MOVE.l (a7),a0

  !newcalc
  BEQ 'l10
    MOVE.l d0,d3
    MOVEA.l (A7)+,A0
    BRA 'bc1
 'l10
    ; <new
    MOVE.w #$2600,D1              ;move.l d0,d3
    OR.w regnum,D1
    BSR.w writeword
    MOVE.w #$4E75,D1               ;rts!
    BSR.w writeword
    ;
    MOVE.w dontwrite_nomemleft,D1
    BNE.w conmemerr
    ;
    MOVEA.l (A7)+,A0
    ; new >
    NOP
    ; < new
    JSR clear_Cache                                         ;simple expression
    JSR (A0)                                                ;writeresult
 'bc1
  MOVE.w (A7)+,cfetchmode
  MOVE.w (A7)+,lasta6
  MOVE.w (A7)+,dontwrite_nomemleft
  MOVE.l (A7)+,destbufferend
  MOVE.l (A7)+,destpointer
  MOVE.w (A7)+,regnum
  ; new >
  ;MOVE.l (a7)+,lastconstantvalue
  ;MOVE.b (a7)+,isconstantvalue
  ; < new
JMP reget


oldlibat:   Ds.l 1


.do_INCDIR:
  LEA incdir,A0

 'loop
  CMP.w #$22,D0     ;'"'
   BEQ.w 'skip
  MOVE.b D0,(A0)+
  TST.w D0
   BEQ.w 'done
   BMI.w syntaxerr

 'skip
  JSR get1bytemain                                         ;_long
 BRA.w 'loop

 'done
RTS


makeiname:
  ;
  ;create include name
  ;
  LEA ptr_parameterstore,A1                                ;getparameter
  LEA incdir,A0
  MOVEQ.l #-$01,D2

 'loop0
    ADDQ.w #1,D2
    MOVE.b (A0)+,(A1)+
  BNE.w 'loop0
  SUBQ.w #1,A1
   ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new

 'loop:
  JSR get1bytemain
  TST.w D0
   BMI.w syntaxerr
  CMP.b #$22,D0         ;'"'
   BEQ.w 'loop
  MOVE.b D0,(A1)+
   BEQ.w 'done
  ADDQ.w #1,D2
 BRA.w 'loop

 'done
  TST.w D2
   BEQ.w syntaxerr
RTS


readinc:
  ;do include next line
  ;a5=position in buffer
  ;
  MOVEA.l constantbase,A2
  ;
  MOVEA.l $E(A2),A5
  ; new >
  MOVE.l a5,includesourceline
  LEA inctab,a0
  MOVE.w ininclude,d0
  MOVE.l $0(a0,d0*4),d0
  ; < new
  MOVEA.l $4(A2),A0
  ;MOVE.w $C(A2),D0
  LEA $0(A0,D0.l),A0   ;end of buffer!
  MOVEA.l A5,A1

 'loop
    CMPA.l A0,A1
     BCC.w readpend
  TST.b (A1)+
  BNE.w 'loop
BRA.w imakeend

readpend:
  ;o.k., no 0's past where we're at!
  ;
  MOVEA.l $4(A2),A1

 'loop
  CMPA.l A0,A5
  BCC.w 'skip
  MOVE.b (A5)+,(A1)+
 BRA.w 'loop

 'skip
  MOVE.l A1,D0
  SUB.l $4(A2),D0
  ; new >
  LEA inctab,a0
  MOVEQ #0,d1
  MOVE.w ininclude,d1
  MOVE.l d0,0(a0,d1*4)
  ; < new
  ;MOVE.w D0,$C(A2)            ;chars in there
  MOVEA.l _dosbase,A6
  MOVE.l $8(A2),D1
  MOVE.l A1,D2
  ; new >
  MOVE.l D2,include_base
  MOVE.l #$10000000,d3                                     ;load whole file
  ; < new
  ;MOVE.l #$3FF*8,D3           ; was #inclen-1
  SUB.l D0,D3
  ;
   JSR _Read(A6)
  ;
  TST.l D0
   BMI.w error_reading_file
  ; new >
   BEQ.w closeinc
   MOVE.l D0,include_length
   !ComData_GetL{comPtr_PreProcessor,include_preprocessor}
   !basic
   ilen.l  = Peek.l(?include_length)
   ibase.l = Peek.l(?include_base)
   ido.l   = Peek.l(?include_process)
   *tn.preprocessor = Peek.l(?include_preprocessor)
   If ido
     ioffset.l = SkipXtraHeader{ibase,ilen}
     nilen.l = preproc_Tokenize{*tn,ibase+ioffset,ibase,ilen-ioffset}
     If nilen>0
       ;For n.l=nilen To ilen-1
       ;  Poke.b ibase+n,0
       ;Next
       Poke.l ?include_length,nilen
     End If
   End If
   !asm
   MOVE.l #0,include_process
   MOVE.l include_length,D0
   LEA inctab,a0
   MOVEQ #0,d1
   MOVE.w ininclude,d1
   ADD.l d0,0(a0,d1*4)
  ; < new
  ;ADD.w D0,$C(A2)
  ; ; was beq closeinc
  MOVEA.l $4(A2),A5
  ;MOVE.w $C(A2),D0
  ; new <
   MOVE.l 0(a0,d1*4),d0
  ; < new
  CLR.b $0(A5,D0.l)

imakeend:
  MOVEA.l A5,A0

 'loop2
    TST.b (A0)+
  BNE.w 'loop2
  MOVE.l A0,$E(A2)
RTS


include_length:        Dc.l 0                              ; for tokenizer!
include_base:          Dc.l 0
include_process:       Dc.l 0
include_preprocessor:  Dc.l 0


closeinc:
  MOVE.l $8(A2),D1
  MOVEA.l _dosbase,A6
  JSR _Close(a6)
  MOVEA.l _execbase,A6
  MOVEA.l $4(A2),A1
  MOVE.l #$400*8,D0         ; #inclen                               ;exit include
  ;jsr _FreeMem(A6)
  ; new >
  ;MOVE.l mempool,a0
  ;JSR _FreePooled(a6)
  JSR _FreeVec(a6)
  ; < new

  MOVE.l (A2),constantbase
  MOVEA.l A2,A1
  MOVEQ.l #$00,D0
  MOVE.b $12(A2),D0
  MOVEA.l _execbase,A6
  ;jsr freemem(a6)
  ; new >
  MOVE.l mempool2,a0
  JSR _FreePooled(A6)
  JSR zero_includename
  ; < new
  SUBQ.w #1,ininclude
  BNE.w readinc

  ;new >
 'l2a
  LEA _include,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA ptr_parameterstore,a1

 'l1b
    MOVE.b (a0)+,(a1)+
  BNE 'l1b
  MOVEQ #9,d2
  JSR findlabel2
  BNE 'd
  CLR.l 8(a2)

 'd
  MOVEM.l (a7)+,a0-a6/d0-d7
  ; < new
RTS


; new >
.free_unusedfunctions:
  MOVE.l unusedfunc,d0
  BEQ 'noclear
  MOVEM.l d0-d2/a0-a1/a6,-(a7)

 'f1
    MOVE.l d0,a1
    MOVE.l 4(a1),d0
    MOVE.l (a1),d2
    MOVE.l _execbase,a6
    JSR _FreeMem(a6)
    MOVE.l d2,d0
  BNE 'f1
  CLR.l unusedfunc
  MOVEM.l (a7)+,a0-a1/a6/d0-d2

 'noclear
RTS
; < new


freexincs:
  MOVEA.l xinclude_base,A2
  CLR.l xinclude_base

 'loop
    CMPA.w #$0,A2
     BEQ.w 'done
    MOVEQ.l #$00,D0
    MOVE.b 4+8(A2),D0           ; was 4 org
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEA.l _execbase,A6
    ;jsr freemem(a6)
    ; new >
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
    ; < new
 BRA.w 'loop

 'done
RTS


freeincs:
  MOVEA.l constantbase,A2
  CLR.l constantbase

 'loop
    CMPA.w #$0,A2
     BEQ.w 'done
    MOVE.l $8(A2),D1
     BEQ.w 'noclose
    MOVEA.l _dosbase,A6
     JSR _Close(A6)

  'noclose
    MOVE.l $4(A2),D0
     BEQ.w 'skip
    MOVEA.l D0,A1
    MOVE.l #$400*8,D0          ; was #inclen
    MOVEA.l _execbase,A6
    ;jsr freemem(a6)
    ; new >
    MOVE.l mempool,a0
    JSR _FreeVec(a6)
    ; < new

  'skip
    MOVEQ.l #$00,D0
    MOVE.b $12(A2),D0
    MOVEA.l A2,A1
    MOVEA.l (A2),A2
    MOVEA.l _execbase,A6
    ;jsr freemem(a6)
    ; new >
    MOVE.l mempool2,a0
    JSR _FreePooled(A6)
    ; < new
 BRA.w 'loop

 'done
RTS


pokedata2l:
  ;
  ;poke a long into data2!
  ;
  SWAP D0
  BSR.w pokedata2
  SWAP D0

pokedata2:
  ;poke a word into data2 (data staements)
  ;
  MOVEA.l data2,A4
  CMPA.l allat,A4
  BCC.w 'over
    MOVE.w D0,(A4)+
    MOVE.l A4,data2
    RTS
 'over
  MOVE.w #$FFFF,dontwrite_nomemleft        ; was -1
  ADDQ.l #2,data2
RTS


pokedata2b:
  MOVEA.l data2,A4
  CMPA.l allat,A4
  BCC.w 'over
    MOVE.b D0,(A4)+
    MOVE.l A4,data2
    RTS
 'over
  MOVE.w #$FFFF,dontwrite_nomemleft        ; was -1
  ADDQ.l #1,data2
RTS


getsp:
  ;get a string parameter for conditional stuff
  ;into a0
  CMP.w #$22,D0          ;'"'
  BNE.w syntaxerr

 'getsp2
    JSR get1bytemain
    CMP.b #$22,D0
    BEQ.w 'done
      TST.w D0
      BEQ.w syntaxerr
        MOVE.b D0,(A0)+
  BRA.w 'getsp2
 'done
  CLR.b (A0)
RTS


numcom:
  TST.l D3
RTS


strcom:
  ;compare strings. set flags accordingly
  ;
  LEA ptr_parameterstore,A0
  LEA namebuff2,A1

 'loop
    MOVE.b (A0)+,D0
    BEQ.w 'short
  CMP.b (A1)+,D0
  BEQ.w 'loop
 RTS

 'short
  TST.b (A1)
  BNE.w 'lt
 RTS

 'lt
  CMP.w #$1,D0
RTS


;-----------built in tokens------------;
;tokes

.do_DEFTYPE:
  CMP.w #$2E,D0                ;"."                            ;dodeftype
   BNE.w syntaxerr
  BSR.w getparameter2
  LEA newtypebase,A2
  BSR.w findtype
   BNE.w notypeerr
  ; new >
  TST.b declare
   BNE 'l1
  TST.b declare2
   BEQ 'l2

 'l1
  MOVE.b #2,nowdeclare

 'l2
  ; < new
  JSR reget
   BNE.w 'more
  MOVE.l A2,defaulttype
 RTS

 'more
  ;
  ;deftype.l varlist...
  ;
  MOVE.l defaulttype,-(A7)
  MOVE.l A2,defaulttype

 'loopz
  BSR.w getparameter
   BSR.w fetchvars
  CMP.w #$2C,D0            ;","
   BNE.w 'done
   JSR get1bytemain                                        ; was BSR.w
 BRA.w 'loopz

 'done
  MOVE.l (A7)+,defaulttype
RTS


maxprep1:
  LEA $4(A5),A2                                            ;fehler function

maxprep2:
  MOVE.l A2,D0

.do_MaxLen:                   ;set a strings maximum length.
  BSR.w getparameter
  BSR.w fetchvars
  BSR.w calcvar

  CMP.b #$7,D2
  BNE.w mismatcherr

  MOVE.w varmode(PC),-(A7)
  CMP.w #$3D,D0            ;"="
  BNE.w syntaxerr

  BTST #$F,D2
  BNE.w 'already
    MOVE.w maxprep1(PC),D1
    BSR.w pokewda5s
    MOVE.w D3,D1
    BSR.w writeword
 'already

  MOVE.w maxprep2(PC),D1
  BSR.w writeword
  ADDQ.w #1,regnum
  MOVEQ.l #$03,D2
  BSR.w eval
  MOVE.l #$D000,D1              ; was #maxlen
  ; new >
  MOVE.l d1,lastinstruction
  ; < new
  TST.w (A7)+
  BEQ.w Atokejsr
    ADDQ.w #1,D1
BRA.w Atokejsr


getmaxel:
  MOVE.w D0,D1
   BPL.w syntaxerr
  BCLR #$F,D1
   JSR searchinstr
  MOVE.l $12(A2),D0
  TST.w -$2(A2,D0.L)
   BEQ.w freeerr
  MOVEQ.l #$02,D2
  MOVE.l A2,-(A7)
  ;
   BSR.w eval
  ;
  MOVEA.l (A7)+,A2
  MOVE.l A2,mymaxlib
  ;
  ADDA.l $12(A2),A2
  TST.b debugmode
   BEQ.w 'pen
  ;
  ;check maximum overflow
  ;
  MOVE.w regnum,D1
  LSL.w #8,D1
  LSL.w #1,D1
  ORI.w #$B07C,D1       ;cmp #x,dn
   BSR.w writeword
  MOVE.w -$4(A2),D1
   BSR.w writeword
  MOVE.l maxchk,D1      ;bcs
   BSR.w writelong
  MOVE.l A2,-(A7)
  MOVE.w #$C30A,D1      ; was #maxerr,
   BSR.w Atokejsr
  MOVEA.l (A7)+,A2

 'pen
  MOVE.w -$2(A2),D2     ;# shifts

 'loop
  MOVE.w regnum,D1
  OR.w lslimm,D1
  CMP.w #$8,D2
   BCS.w 'under
   BSR.w writeword
  SUBQ.w #8,D2
   BNE.w 'loop
 BRA.w 'shdone

 'under
  MOVE.w D2,D0
  LSL.w #8,D0
  LSL.w #1,D0
  OR.w D0,D1
  BSR.w writeword

 'shdone
RTS


;------                                                  ;disassembled code begin
free:
  Dc.b $26,$6D,$00,$00                                     ;MOVEA.L $0000(A5),A3
  Dc.b $D6,$C0                                             ;ADDA.W  D0,A3
freef:  ;
;------                                                  ;disassembled code end

mymaxlib:  Ds.l 1


.do_free:
  BSR.w getmaxel
  ;
  LEA free(PC),A0
  LEA freef(PC),A1
  MOVE.w -$6(A2),$2(A0)
  BSR.w pokecode
  ;
  MOVE.l -$A(A2),D1

maxjsr:
  BEQ.w JMP_nosuperr
  MOVEA.l mymaxlib(PC),A2
BRA.w Amakelibsub

.JMP_nosuperr:
JMP nosuperr

.do_use:
  BSR.w getmaxel
  ;
  LEA use,A0
  LEA usef,A1
  MOVE.w -$6(A2),$2(A0)
  MOVE.w -$6(A2),-$2(A1)
  ADDQ.w #4,-$2(A1)
  BSR.w pokecode
  ;
  MOVE.l -$E(A2),D1
  ;
BRA.w maxjsr


.do_else2:
  ;BSR.w get1bytemain
  JSR get1bytemain

.do_else:
  MOVE.l firstiff,D0
   BEQ.w noiferr
  MOVEA.l D0,A0
  CMPI.b #$1,$D(A0)
   BEQ.w illelseerr
  MOVE.w #$6000,D1
  ; new >
  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    OR.l #$ff,d1
    BSR writeword
  CEND

 'l1
  ; < new
  SWAP D1
  BSR.w writelong
  MOVEQ.l #$00,D1
  BSR.w doendif2
  MOVE.l destpointer,$8(A0)
BRA.w do_then


.do_cerr:
  LEA ptr_parameterstore,A0
  MOVE.l A0,-(A7)
  BSR.w getsp
BRA.w handle_compileerror


.do_cnif:
  BSR.w evalconst
  MOVEQ.l #$05,D1       ;beq
   ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  LEA numcom,A0
BRA.w compare


.do_csif:
  LEA ptr_parameterstore,A0
  BSR.w getsp
  JSR get1bytemain
  BSR.w collif
  LEA namebuff2,A0
  BSR.w getsp
  LEA strcom,A0


.compare:
  ;use subroutine in a0, cc in d1 to compare then enable
  ;or disable compilation
  ;accordingly
  ;
  LSL.w #2,D1
  LEA CIF_branches,A1
  MOVE.l $0(A1,D1.W),-(A7)
  MOVEQ.l #-$01,D1           ;comp flag

  JSR (A0)

  MOVEA.l (A7)+,A1
JMP (A1)


cif_eq:
  BEQ.w cifdo
BRA.w cifdont

cif_ne:
  BNE.w cifdo
BRA.w cifdont

cif_lt:
  BLT.w cifdo
BRA.w cifdont

cif_le:
  BLE.w cifdo
BRA.w cifdont

cif_gt:
  BGT.w cifdo
BRA.w cifdont

cif_ge:
  BGE.w cifdo

cifdont:
  MOVEQ.l #$00,D1

cifdo:
  MOVEA.l concomsp,A0
  MOVE.w skipcode,(A0)+
  MOVE.l A0,concomsp
  MOVE.w D1,skipcode
  JSR get1bytemain
   BNE.w syntaxerr
JMP bakup


;------                                                  ;disassembled code begin
rescode:   Dc.b $2B,$7c,$00,$00,$00,$00 :   Ds.w 1         ;MOVE.L  #$00000000,$0000(A5)
rescode2:  Dc.b $2B,$40                 :   Ds.w 1         ;MOVE.L  D0,$0000(A5)
;------                                                  ;disassembled code end


.do_Restore:
    ;Restore 'label'
    ;
  MOVE.w #$FC17,D1            ;datalib
  JSR uselib
    ;
  JSR reget
   BEQ.w 'resbeg
  BSR.w makealab2                                          ;get label name!
  MOVE.w rescode(PC),D1
  BSR.w writeword
  JSR addoff                                               ;add offset
  MOVE.l $C(A2),D1
  BSR.w writelong
  MOVE.w rescode+6(PC),D1
  BSR.w writeword
  MOVE.l $4(A2),D1                                         ;is it outstanding?
  BEQ.w 'no
    ;yes - tell it that reference is a DATA statement one
  MOVEA.l D1,A1
  ADDQ.l #1,$4(A1)                                         ;make odd - flag for data reference.
 RTS

 'no
    ;data label not outstanding...this not working!?!?
    ;
 RTS

 'resbeg                                                   ;restore to beginning...
  MOVE.w #$CD00,D1
  JSR Atokejsr
  MOVE.l rescode2(PC),D1
JMP writelong


.do_read:
  MOVE.w #$FC17,D1
  JSR uselib

 'loop
  MOVE.l dataget,D1
  BSR.w writelong
  BSR.w getparameter
  BSR.w fetchvars
  BSR.w calcvar
  BTST #$E,D2
   BEQ.w 'notap
  ;
  MOVE.b #$6,D2      ;pointer becomes an address!

 'notap
  TST.b D2
   BEQ.w noleterr   ;read in a whole struct....later!
  TST.b debugmode
   BEQ.w 'norerr
  ;
  MOVE.w #$7000,D1
  MOVE.b D2,D1
  ANDI.b #$F,D1
  BSR.w writeword
  MOVE.w #$C310,D1     ; was  #datachk
  MOVE.w D2,-(A7)
  BSR.w Atokejsr
  MOVE.w (A7)+,D2

 'norerr
  CMP.b #$7,D2
   BEQ.w 'string
  CMP.b #$1,D2
   BNE.w 'notbyte
  ;
  LEA dataletb2,A0
  LEA dataletb2f,A1
  BTST #$F,D2
   BEQ.w 'bimm
  BSR.w pokecode
 BRA.w 'next

 'bimm
  LEA dataletb,A0
  LEA dataletbf,A1
  ;
  TST.w varmode
   BEQ.w 'byteglobal
  LEA dataletbl,A0
  LEA dataletblf,A1

 'byteglobal
  MOVE.w D3,$4(A0)
  BSR.w pokecode
 BRA.w 'next

 'notbyte
  LEA dataletw,A0
  CMP.b #$3,D2
   BCS.w 'word
  LEA dataletl,A0

 'word
  BTST #$F,D2
   BEQ.w 'imm
  MOVE.w $4(A0),D1
   BSR.w writeword
 BRA.w 'next

 'imm
  TST.w varmode
   BEQ.w 'wlglobal
  ADDQ.w #6,A0

 'wlglobal
  MOVE.w D3,$2(A0)
  MOVE.l (A0),D1
  BSR.w writelong

 'next
  MOVE.l dataput,D1
   BSR.w writelong
  CMP.w #$2C,D0        ;','
   BEQ.w 'more
 RTS

 'more
  JSR get1bytemain
 BRA.w 'loop

 'string
  MOVE.w stlenget,D1
   BSR.w writeword     ;move.l (a3)+,-(a7)
  BTST #$F,D2
   BNE.w 'ok
  ;
  TST.w varmode
   BEQ.w 'sglobal
  MOVE.w D3,leaampl+2
  MOVE.l leaampl,D1
 BRA.w 'sskip

 'sglobal
  MOVE.w D3,leaamp+2
  MOVE.l leaamp,D1

 'sskip
  BSR.w writelong

 'ok
  MOVE.w #$C701,D1     ;was  #astring
  MOVE.w varmode,D2
   BEQ.w 'global
  SUBQ.w #1,D1

 'global
  BSR.w Atokejsr
  MOVE.w #$FFFF,lasta6    ; was -1
  LEA stalign,A0
  LEA stalignf,A1
  BSR.w pokecode
BRA.w 'next


getsize2:
  CMP.w #$2E,D0        ;'.'                                    ;definecode 'lb 'lw 'll
  BNE.w 'word
    JSR get1bytemain
    CMP.w #$77,D0        ;'w'
    BEQ.w 'word2
      CMP.w #$62,D0        ;'b'
      BEQ.w 'byte
        ; new >
        CMP.w #"s",d0        ;'s'
        BEQ 'single3
          CMP.w #"d",d0        ;'d'
          BEQ 'double3
            ; < new
            CMP.w #$6C,D0        ;'l'
            BNE.w syntaxerr
              MOVEQ.l #$02,D1
              RTS
 ; new >
 'single3
  MOVE.b #1,iee
  MOVEQ.l #$3,d1
  RTS

 'double3
  MOVE.b #1,iee
  MOVEQ.l #$4,d1
  RTS
 ; < new

 'byte
  MOVEQ.l #$00,D1
  RTS

 'word2
  MOVEQ.l #$01,D1
  RTS

 'word
  MOVEQ.l #$01,D1
JMP bakup


.do_dcb:
  BSR.w getsize2

  MOVE.w D1,-(A7)
   BSR.w evalconst2
  CMP.w #$2C,D0        ;','
   BNE.w syntaxerr
  MOVE.l D3,-(A7)
   BSR.w evalconst2
  MOVE.l D3,D1        ;to put in memory
  MOVE.l (A7)+,D3     ;number of times
  MOVE.w (A7)+,D2
   BEQ.w 'byte
   ;bsr.w do_even
  ; new >
   ;addq.l #1,destpointer                                   ;even
   ;bclr #$0,destpointer+3
  ; < new
  CMP.w #$1,D2
   BEQ.w 'word

 'long
  SWAP D1
   BSR.w writeword
  SWAP D1
   BSR.w writeword
  SUBQ.l #1,D3
   BNE.w 'long
 RTS

 'word
   BSR.w writeword
  SUBQ.l #1,D3
   BNE.w 'word
 RTS

 'byte
   BSR.w writebyte
  SUBQ.l #1,D3
   BNE.w 'byte
RTS


.do_ds:
  BSR.w getsize2                                          ;definestorage
  MOVE.w D1,-(A7)
  BSR.w evalconst3
  MOVE.w (A7)+,D1
  LSL.l D1,D3
  ; new >
  MOVE.l d3,d0
  BEQ 'll5
  MOVEQ #0,d1

 'll10
    JSR writebyte
    SUBQ.l #1,d3
  BNE.s 'll10

 'll5
 ; < new
 ;add.l d3,pc   ; or source
RTS


.insasm2:
  MOVE.w D0,-(A7)
  LEA dummyasm,A0
  MOVEA.l destpointer,A1
  MOVE.w asmlen2,asmlen
  JSR insasm
  MOVE.w (A7)+,D0
RTS


.do_dc:
  BSR.w getsize2

  MOVE.l #ptr_parameterstore,asmbuff
  TST.w D1
   BEQ.w 'byte
  CMP.w #$1,D1
   BEQ.w 'word
  ; new >
  CMP.w #$2,d1
   BEQ 'long
  CMP.w #$3,d1
   BEQ 'single
  ; < new
  ;
  ;Long!
  ;
   MOVEQ.l #$0d,D3
   ;bsr.w do_even
  ; new >
   ;addq.l #1,destpointer                                   ;even
  ;bclr #$0,destpointer+3
  ; < new

 'lloop
   JSR asmconst
   BSR.w insasm2
   BSR.w writelong
   ; new >
   BSR   writelong
   ; < new
  CMP.w #$2C,D0    ; ','
   BEQ.w 'lloop
 RTS

  ; new >
 'long
  MOVEQ.l #$0B,D3
   ;bsr.w do_even
   ;addq.l #1,destpointer                                   ;even
  ;bclr #$0,destpointer+3
  MOVE.b #1,_dcb

 'lloopb
  JSR asmconst
  CLR.b _dcb
  BSR.w insasm2
  BSR writebyte
  BSR writebyte
  BSR writebyte                                            ;long
  BSR writebyte
  CMP.w #$2C,D0
   BEQ.w 'lloopb
 RTS

 'single
  MOVEQ.l #$0c,D3
  ;bsr.w do_even
  ;addq.l #1,destpointer                                    ;even
  ;bclr #$0,destpointer+3
  MOVE.b #1,_dcb

 'lloopa
  JSR asmconst
  CLR.b _dcb
  BSR.w insasm2
  BSR.w writebyte
  BSR.w writebyte
  BSR.w writebyte
  BSR.w writebyte
  CMP.w #$2C,D0
   BEQ.w 'lloopa
 RTS
  ; < new

 'byte
  ;Byte!
  ;
  MOVEQ.l #$11,D3

 'bloop
  JSR get1bytemain
  CMP.w #$22,D0     ;'"'
   BNE.w 'notq

 'qloop
  ; JSR get1bytemain        ; org source
  ; new >
  MOVE.b (a5)+,d0                                          ;bsr.w get1bytemain ascii dc.b
  ; < new
   BEQ.w syntaxerr
  CMP.w #$22,D0   ;'"'
   BEQ.w 'qdone
  ; new >
  CMP.b #"\",d0
   BNE 'n1
  CMP.b #"\",(a5)
   BEQ 'do1

 'n1
  ; < new
  MOVE.w D0,D1
  BSR.w writebyte
 BRA.w 'qloop

  ; new >
 'do1
  CMP.l #"__DA",1(a5)
   BNE 'nodate1
  CMP.l #"TE__",5(a5)
   BEQ 'c1
  CMP.l #"TE_G",5(a5)
   BNE 'nodate1
  CMP.l #"ER__",9(a5)
   BNE 'nodate1
  JSR compiledatedc_ger
 BRA 'n1

 'c1
  JSR compiledatedc
 BRA 'n1

 'nodate1
  CMP.l #"__VE",1(a5)
   BNE 'n1
  CMP.w #"R_",5(a5)
   BNE 'n1
  JSR version_string_dc
 BRA.w 'qloop

 'qdone
  ; new >
  CLR.w instringon
  ; < new
  JSR get1bytemain
 BRA.w 'bdone

 'notq
  ;bsr.w bakup
  ; new >
   MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
   JSR asmconst
  SUBQ.l #1,destpointer
   BSR.w insasm2
  ADDQ.l #1,destpointer
   BSR.w writebyte

 'bdone
  CMP.w #$2C,D0   ;','
   BEQ.w 'bloop
 RTS

 'word
  MOVEQ.l #$10,D3
   ;bsr.w do_even
  ; new >
   ;addq.l #1,destpointer                                   ;even
  ;bclr #$0,destpointer+3
  ; < new

 'wloop
  ; new >
  MOVE.b #1,_dcb
  ; < new
  JSR asmconst
  ; new >
  CLR.b _dcb
  ; < new
  BSR.w insasm2
  ;bsr writeword  ; org source
  ; new >
  BSR.w writebyte
  BSR.w writebyte
  ; < new
  CMP.w #$2C,D0      ;','
   BEQ.w 'wloop
RTS


.do_even4:                                                 ;long align
  ADDQ.l #3,destpointer
  ANDI.w #$FFFC,destpointer+2
RTS


.do_even8:                                                 ;phrase align
  ADDQ.l #7,destpointer
  ANDI.w #$FFF8,destpointer+2
RTS


.do_even:                                                  ;word align
  ADDQ.l #1,destpointer                                    ;even
  BCLR #$0,destpointer+3
RTS


datasize: Ds.w 1



pdt:
    ;insert type of data item into code
    ;if runtime error checking is on.....
    ;
    ;codes for data..... Dn
    ;
  TST.b debugmode
  BEQ.w 'skip
  MOVE.w #$4420,D0                                         ;'D '
  MOVE.b datasize+1(PC),D0
 BRA.w pokedata2

 'skip
RTS

.do_data:
  MOVE.w #$FC17,D1                                          ;#64535  "datalib"
  JSR uselib
  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  JSR sizespec2                                             ;get size of it into d1
  MOVE.w D1,datasize
  ;
  ;(eg. Data.w)
  ;
  CMP.w #$7,D1
  BEQ.w 'string

  MOVE.w D1,-(A7)

 'more
  BSR.w pdt
  MOVE.w (A7),D2
  BSR.w fetchdata

  CMP.w (A7),D2                                            ;datamode
  BEQ.w 'dataok
    MOVE.w D2,D1
    MOVE.w (A7),D2
    CMP.w #$2,D2
    BNE.w 'notw
      CMP.w #$3,D1
      BNE.w baddaterr
        CMP.l #$10000,D3        ; was  #65536
        BCC.w baddaterr
          BRA.w 'dataok
   'notw
    CMP.w #$1,D2
    BNE.w 'notb
      CMP.w #$2,D1
      BNE.w baddaterr
        CMP.l #$100,D3
        BCC.w baddaterr
          BRA.w 'dataok
   'notb
    BRA.w baddaterr
 'dataok

  CMP.w #$3,D2
  BCC.w 'notword
    BSR.w pokedata2
    BRA.w 'next
 'notword

  ; new >
  TST.b iee
  BEQ 'old
    CMP.b #5,d2
    BNE 'old
      Dc.l $f2006400                                           ;  fpu data write fmove.s fp0,d0
      ;BSR writelong
 'old
  ; < new
  BSR.w pokedata2l                                          ;write data >3

 'next
  JSR reget
  CMP.w #$2C,D0     ;','
  BEQ.w 'more
    ADDQ.w #2,A7
    RTS

 'string
  BSR.w pdt
  MOVE.l data2,-(A7)
  BSR.w pokedata2l
  MOVEQ.l #$00,D1

  JSR get1bytemain
  BEQ.w 'done
  CMP.w #$22,D0       ;'"'
   BEQ.w 'quoted
  CMP.w #$2C,D0       ;','
   BEQ.w 'done

 'loop2
  BSR.w pokedata2b
  ADDQ.w #1,D1
  JSR getchar
  TST.w D0
  BEQ.w 'done
    CMP.w #$2C,D0
    BEQ.w 'done       ;','
  BRA.w 'loop2

 'quoted
  ;BSR.w get1bytemain                                      ;data writestring
  ; new >
  MOVEQ #0,d0
  MOVE.b (a5)+,d0
  ; < new
  BEQ.w notqerr2
  CMP.w #$22,D0       ;'"'
  BEQ.w 'done2
    BSR.w pokedata2b
    ADDQ.w #1,D1
    BRA.w 'quoted
 'done2

  ; new >
  CLR.w instringon
  ; < new
  JSR get1bytemain

 'done
  MOVEA.l (A7)+,A0
  MOVE.w dontwrite_nomemleft,D2
  BNE.w 'nopoke
    MOVE.l D1,(A0)
 'nopoke
  ADDQ.l #1,data2
  BCLR #$0,data2+3
  CMP.w #$2C,D0      ;','
  BEQ.w 'string
RTS


; new >
notqerr2           JMP notqerr
JUMP_vardeclareerr JMP vardeclareerr
; < new


.do_shared:
  ;
  ;set up SHARED variables.....
  ;
  MOVE.w proceduremode,D1                                  ;doshared
  ;BEQ.w sharederr
  ; new >
  BNE.w 'l1
  MOVE.w D1,-(A7)
  CLR.w proceduremode

 'again2
  LEA varbase,a2
  BSR.w getparameter
  MOVE.w d2,-(a7)
  JSR findvariable
  BEQ 'checkdim

  LEA sharebase,a2
  MOVEQ #$f+4,d7
  BSR.w findlab                                         ;find var
  BEQ.b dupsherr

  BSR addlabel

  CMP.b #".",d0
  BNE JUMP_vardeclareerr

  MOVE.l a2,a3
  JSR claptonb       ; jump to a copy of fvaradd 'clapton
;      BSR.w getparameter2
;   LEA newtypebase,A2
;   BSR.w findtype
;   BNE.w notypeerr
;   MOVE.l a2,$A(A3)
;   MOVE.w flagmask,$6(A3)
;   MOVE.w globalvarpointer,$4(A3)
;   MOVEQ.l #4,d1
;   CMPI.l #$100,$4(A2)
;    BCC.w 'l1d
;   MOVE.w 8(a2),d1

;  'l1d
;     ADD.w d1,globalvarpointer
;     CMP.b #$2e,d0
;     BNE vardeclareerr
;     JSR get1bytemain
;     CMP.b #"l",d0
;     BNE 'lo
;   BRA 'ok

;  'lo
;    CMP.l #"f",d0
;     BNE onlyfloatint

;  'ok
;     MOVE.w globalvarpointer,$4(A3)
;     ADD.w #4,globalvarpointer

 'domore
  MOVE.w (a7)+,d2
  CMP.b #",",d0
  BNE 'ret
    JSR get1bytemain
    BRA 'again2
 'ret
  MOVE.w (A7)+,proceduremode
  RTS

 'checkdim
  CMP.w #2,6(a2)
  BEQ 'do
    CMP.w #$102,6(a2)
    BEQ 'do
      JMP errormsg_declaredtwice                                 ;was BRA 'errormsg_declaredtwice_
 'do
  LEA varbase,a0

 'm1
  MOVE.l (A0),D0                                           ;find label
  BEQ.b 'z1
    CMP.l d0,a2
    BEQ 'z1
      MOVE.l d0,a0
      BRA 'm1
 'z1
  MOVE.l (a2),d1
  MOVE.l d1,(a0)
  CLR.l (a2)
  LEA sharebase,a0
  MOVE.l (a0),(a2)
  MOVE.l a2,(a0)
  JSR get1bytemain
  JSR get1bytemain
  BRA 'domore

 'l1
  MOVE.b #1,nowdeclare
  ; < new
  MOVE.w D1,-(A7)
  CLR.w proceduremode

 'loop2
  BSR.w getparameter
  MOVE.w D2,-(A7)
  ;
  LEA firstglob,A2
  BSR.w findvariable2
  BNE.b 'notfound

 'try2
    MOVE.b flagmask+1,D1
    MOVE.b $7(A2),D3
    EOR.b D3,D1
    BEQ.w dupsherr

    BSR.w findlab
  BEQ.b 'try2

 'notfound
  BSR.w addlabel
  MOVE.w (A7)+,D2
  MOVE.l A2,-(A7)   ;new glob
  BSR.w fetchvars
  MOVEA.l (A7)+,A2
  MOVEQ.l #$04,D1
  ADDQ.w #4,A2
  ADDQ.w #4,A3

 'loop
    MOVE.w (A3)+,(A2)+
  DBF D1,'loop

  BTST #$1,flagmask+1
  BEQ.w 'done
    JSR get1bytemain
    CMP.w #$29,D0         ;')'
    BNE.w JUMP_syntaxerr
      JSR get1bytemain
 'done
  CMP.w #$2C,D0         ;','
  BNE.w 'done2
    JSR get1bytemain
    BRA.w 'loop2
 'done2
  MOVE.w (A7)+,proceduremode
RTS


.do_xinclude:
   ;
   ;do EXCLUSIVE (once only!) include
   ;
   BSR.w makeiname
   JSR check_incdir                                        ; ergebnis in d2
   ; new >
   LEA ptr_parameterstore,a1
   MOVE.l d2,-(a7)
   LEA includetemp,a0                                      ; filename in includetemp packen

 'l4
     MOVE.b (a1)+,(a0)+
   BNE 'l4

   LEA ptr_parameterstore,a1
   MOVE.l a1,a0

 'l1
    TST.b (a0)+
   BNE 'l1

 'l2
     MOVE.b -(a0),d0
     CMP.b #":",d0
      BEQ 'out
     CMP.b #"/",d0
      BEQ 'out
     CMP.l a1,a0
      BEQ 'out2
 BRA 'l2

 'out
   ADDQ.l #1,a0                                            ; dateinamen vom pfad extrahiert

 'out2
   MOVEQ.l #-$01,D2

 'l3
     ADDQ.w #1,D2
     MOVE.b (a0)+,(a1)+
   BNE 'l3
   CLR.b (a1)+

   LEA ptr_parameterstore,a1
   BSR.w findxinc                                         ;find include
    BEQ.w 'outb
   ; < new
   MOVE.w D2,-(A7)
   BSR.w addlabel
   MOVE.w (A7)+,D2
   ; new >
   LEA ptr_parameterstore,a1
   LEA includetemp,a0                                      ; namen in includetemp schreiben

 'l4b
    MOVE.b (a0)+,(a1)+
   BNE 'l4b

   MOVE.l (a7)+,d2
   LEA ptr_parameterstore,a1
  ; < new
 BRA.w doinc2

  ; new >
 'outb
   LEA ptr_parameterstore,a1
   LEA includetemp,a0

 'l4b2
    MOVE.b (a0)+,(a1)+
   BNE 'l4b2

   MOVE.l (a7)+,d2
   LEA ptr_parameterstore,a1
 ; < new
RTS


.do_IncBin:
  BSR.w makeiname                                              ; test and get the parameter (includestring)
  ;move.l  #ptr_parameterstore,d1 ; org source
  ;moveq   #-2,d2                 ; org source
  ; new >
  JSR check_IncBinDir                                          ; to fix the path problem in CLIMode  tomsmart1
  ; < new
  MOVEA.l _dosbase,A6
  ;jsr _Lock(a6)                 ; org source
  MOVE.l D0,D7                                                 ; store Lockpointer
   BEQ.w error_cant_open_include                               ; no pointer => errormessage
  MOVE.l D7,D1                                                 ; begin get the size of the file to include
  MOVE.l ptr_macrobuffer_begin,D2
   JSR _Examine(A6)
  MOVEA.l ptr_macrobuffer_begin,A0
  MOVE.l $4(A0),D0
   BPL.w error_cant_open_include                               ; something went wrong => errormessage
  MOVE.l $7C(A0),D3      ;length                                       ; store the size of the file to include
  MOVE.l D7,D1                                                 ; begin unlock the file
   JSR _UnLock(A6)

  MOVE.l #ptr_parameterstore,D1                                ; begin Open and Load the file
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2                       
   JSR _Open(A6)
  MOVE.l D0,D7
   BEQ.w error_cant_open_include
  MOVE.l destpointer,D0
  ADD.l D3,D0
  CMP.l destbufferend,D0
   BHI.w 'over
  MOVE.l destpointer,D2
  MOVE.l D7,D1
   JSR _Read(A6)
  CMP.l #$FFFFFFFF,D0              ; was -1
   BEQ.w error_reading_file
  ADD.l D0,destpointer
 BRA.w 'close

 'over
  MOVE.w #$FFFF,dontwrite_nomemleft          ; was -1
  MOVE.l D0,destpointer

 'close
  MOVE.l D7,D1
JMP _Close(A6)


JUMP_illdirerr JMP illdirerr

.do_INCLUDE:
  ;
  ;do a standard include
  ;
  TST.w direct_mode                                            ;include  open
   BNE.w JUMP_illdirerr
  ;
  BSR.w makeiname
  ; new >
  JSR check_incdir
  ; < new

doinc2:
  BSR.w findconstant
   BEQ.w alincerr

  LEA constantbase,A2
  BSR.w addhere2
  ;
  CLR.w $C(A2)
  CLR.l $4(A2)
  ; new >
  MOVE.l #ptr_parameterstore,D1
  MOVE.l d1,a0
  LEA includetemp2,a1

 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1
  JSR save_includename
  MOVE.l #0,include_process

  CMP.l #$62623200,-4(a0)                                  ;.bb2
  BEQ 'ok
  CMP.l #$41423300,-4(a0)                                  ;.AB3
  BEQ 'ok_tokenize
  CMP.l #$61623300,-4(a0)                                  ;.ab3
  BEQ 'ok_tokenize
  CMP.l #$61623200,-4(a0)                                  ;.ab2
  BEQ 'ok_tokenize
  CMP.l #$2e626200,-4(a0)                                  ;.bb files
  BEQ 'ok
    JMP errortoken                                         ;can only include

 'ok_tokenize
  MOVE.l #-1,include_process                              ; must tokenize the include

 'ok
  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
  MOVEA.l _dosbase,A6
  JSR _Open(A6)
  MOVE.l D0,$8(A2)
  BEQ.w error_cant_open_include
  CLR.l includeline
  MOVE.l 8(a2),d1
  MOVE.l d3,-(a7)
  MOVEQ #0,d2
  MOVEQ #1,d3
  JSR _Seek(a6)                                            ; -66
  MOVE.l 8(a2),d1
  MOVEQ #0,d2
  MOVEQ #-1,d3
  JSR _Seek(a6)                                            ; -66
  MOVE.l (a7)+,d3
  ADDQ.l #4,d0
  ; < new
  ;MOVE.l #$400*8,D0      ;#inclen,
  ; new >
  MOVE.l ##MEMF_CLEAR,D1        ; $10000
  MOVEA.l _execbase,A6
  ;MOVE.l mempool,a0
  ;JSR _AllocPooled(a6)
  JSR _AllocVec(a6) ; allocvec_
  ;  < new
   ;jsr do_AllocMem
  ;
  MOVE.l D0,$4(A2)
  MOVE.l D0,$E(A2)
  MOVEA.l D0,A5
;  MOVE.l #ptr_parameterstore,D1
;  MOVE.l #HUNK_RELOC_16__MODE_OLDFILE,D2
;  MOVEA.l _dosbase,A6
;   jsr _Open(A6)
  ;
;  MOVE.l D0,$8(A2)
  ; BEQ.w error_cant_open_include
  ADDQ.w #1,ininclude                                      ;enter include

  ; new >
 'l2a
  LEA _include,a0
  MOVEM.l a0-a6/d0-d7,-(a7)
  LEA ptr_parameterstore,a1

 'l1b
    MOVE.b (a0)+,(a1)+
  BNE 'l1b

  MOVEQ #9,d2
  JSR findlabel2
  BNE 'd
  MOVE.l #1,8(a2)
  MOVEM.l (a7)+,a0-a6/d0-d7
 BRA 'd2

 'd
  JSR addlabelhash
  MOVE.l #$1,$4(A2)
  MOVE.l #1,8(a2)
  MOVEM.l (a7)+,a0-a6/d0-d7

 'd2
  LEA inctab,a0
  MOVEQ #0,d1
  MOVE.w ininclude,d1
  CLR.l $0(a0,d1*4)
  ; < new
  MOVEA.l passstack,A7
JMP passnxt


JUMP_dupmacerr  JMP dupmacerr
JUMP_macenderr  JMP macenderr
JUMP_macnesterr JMP macnesterr


coolnest:   Ds.w 1
macline:    Ds.l 1


.do_Macro:
  ;shit!
  ;
  MOVE.l linenumat,macline
  ;
   BSR.w makename2
   BEQ.w JUMP_syntaxerr
  ; new >
   CLR.b thenmode
  ;  < new
   ;bsr.w bakup
  ; new >
   MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
   BSR.w findmac
   BEQ.w JUMP_dupmacerr
   BSR.w addlabel
  CLR.w $A(A2)
  MOVEA.l ptr_macrobuffer_begin,A0
  MOVEQ.l #$00,D2     ;flag for nothing got yet!
  CLR.w coolnest

  ; new >
 'l1
  MOVE.b (a5),d0
     BEQ 'l3
     CMP.b #" ",d0
      BNE 'l2                                              ;space macro
      ADDQ.l #1,a5
 BRA 'l1

 'l2
  CMP.b #";",d0
  BNE 'l3

 'l4
   MOVE.b (a5),d0
   BEQ 'l5
     BSR.w macputb                                      ;add comment
     ADDQ.l #1,a5
     BRA 'l4

 'l5
   MOVE.b #":",d0
   BSR.w macputb
   MOVE.b #"@",d0
   BSR.w macputb

 'l3
   MOVE.b #0,temp
   MOVE.b #0,thenmode

 'gather
  JSR getcharb   ;get next character
            ;but not conditional stuff
  TST.w D0
   BNE.w 'skip
  MOVEM.l D2/A0/A2,-(A7)
  ; new >
  CMP.w #"@@",-3(a5)
  BNE 'l2a
  JSR nextline
  BEQ.w JUMP_macenderr
  MOVEM.l (A7)+,D2/A0/A2
 BRA.w 'gather

 'l2a
  ; < new
   JSR nextline
   BEQ.w JUMP_macenderr
  MOVEM.l (A7)+,D2/A0/A2
  TST.w D2
   BEQ.w 'gather

  ; new <
 'l2b
  MOVE.b (a5),d0
      CMP.b #" ",d0
      BNE 'l1a
      ADDQ.w #1,a5
 BRA 'l2b

 'l1a
  TST.b thenmode
  BEQ 'l3a
     MOVEQ #":",d0
     BSR.w macputb
     MOVE.w ##TokenID_End,D0                                     ;write end if
     BSR macputw
     MOVE.w ##TokenID_If,D0                                      ; was $800b
     BSR.w macputw
     CLR.b thenmode

 'l3a
  ; < new
   MOVEQ.l #$3A,D0
  ; new >
     MOVE.b #1,temp
  ; < new

 BRA.w 'notend2

 'skip
  BPL.w 'notend2
  CMP.w ##TokenID_Macro,D0                                 ; was #$800d      / -$7FF3
   BNE.w 'notamac
  ADDQ.w #1,coolnest
 BRA.w 'notend

 'notamac
  ; new >
  CMP.w ##TokenID_Object,d0                                          ;object ?
  BNE 'l1x
    TST.b objectcount
    BNE JUMP_macnesterr

 'l1x
  CMP.w ##TokenID_Then,d0                                            ; $8021
  BNE 'nothen
    MOVE.b #1,thenmode
 'nothen

  TST.b thenmode
  BEQ 'l1c
    CMP.w ##TokenID_End,d0                                           ; $8002 end
    BNE 'l1c
      MOVEM.l d0/a5,-(a7)
      JSR get1bytemain
      MOVE.w d0,d1
      MOVEM.l (a7)+,a5/d0
      CMP.w ##TokenID_If,d1                                          ; $800b
      BNE 'l1c
        CLR.b thenmode
 'l1c
  ; < new
  CMP.w ##TokenID_End,D0                                             ; was #$8002 / -$7FFE
  BNE.w 'notend
    ; new >
  MOVE.l a5,-(a7)
  JSR get1bytemain
  MOVE.l (a7)+,a5
  TST.w d0
  BEQ 'doend
  CMP.w #":",d0
  BEQ 'doend
  CMP.w #";",d0
  BEQ 'doend
  MOVE.l a5,-(a7)
  JSR get1bytemain
  MOVE.l -1(a5),d0
  MOVE.l (a7)+,a5
  CMP.l #"noa7",d0
  BEQ 'doend
  BRA 'morechar

 'doend
  MOVE.w ##TokenID_End,D0
   BSR.w macputw
  BRA 'gather

 'morechar
  ; < new
  JSR get1bytemain
   CMP.w ##TokenID_Macro,D0                                ;was #$800d, -$7FF3 ;end macro
  ; new >
   BEQ.w 'lo1
  CMP.w ##TokenID_Object,d0                                          ;end object
  ; < new
  BNE 'notem
  ; > new
  SUBQ.b #1,objectcount
  TST.b developobject
  BEQ 'lo1
    BSR skiprest
    RTS
 'lo1
  ; < new
  SUBQ.w #1,coolnest
   BMI.w 'macdone

 'notem
  MOVE.w D0,-(A7)
  MOVE.w ##TokenID_End,D0                                  ; $8002
  BSR.w macputw
  MOVE.w (A7)+,D0
  BRA.w 'notend

 'notend
  BSR.w macputw
  BRA.w 'gather

 'notend2
  ; new >
  CMP.w #"@@",-1(a5)                                     ;merge lines
  BNE 'no
    MOVEM.l D2/A0/A2,-(A7)
    JSR nextline
    BEQ.w JUMP_macenderr
    MOVEM.l (A7)+,D2/A0/A2
    TST.w D2
    BEQ.w 'gather
    BRA 'gather
 'no
  ; < new
  BSR.w macputb
  BRA.w 'gather

 'macdone
  ADDQ.w #4,A7
  MOVE.l A0,D0
  SUB.l ptr_macrobuffer_begin,D0
  ;
  ;clean up leading and trailing ':'s
  ;

 'mclean
  BEQ.w 'cdone
  CMPI.b #":",-(A0)
  BNE.w 'cdone
  CMP.w #$1,D0
  BEQ.w 'cdo
  TST.b -$1(A0)
  BMI.w 'cdone

 'cdo
  SUBQ.w #1,D0
 BRA.w 'mclean

 'cdone
  MOVE.w D0,$8(A2)
   BEQ.w 'skip2
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  ; new >
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  ; < new
   ;jsr do_AllocMem
  MOVEA.l D0,A0
  MOVE.l A0,$4(A2)
  MOVE.w $8(A2),D1
   BEQ.w 'skip2
  SUBQ.w #1,D1
  MOVEA.l ptr_macrobuffer_begin,A1

 'lll
    MOVE.b (A1)+,(A0)+
  DBF D1,'lll

 'skip2
JMP get1bytemain


macputw:
  MOVE.w D0,D1
  LSR.w #8,D1
  MOVE.b D1,(A0)+

macputb:
  MOVEQ.l #-$01,D2
  MOVE.b D0,(A0)+
  CMPA.l ptr_macrobuffer_end,A0
   BCC.w macbigerr2
RTS

 ; new >
macbigerr2 JMP macbigerr


skiprest:
  MOVE.l d0,-(a7)
  MOVEQ #0,d0
  CLR.b skiptoggle

 'loop
    MOVE.b (a5),d0
    BEQ 'l3
    CMP.b #";",d0
    BNE 'l2
    MOVE.b #1,skiptoggle

 'l2
    TST.b skiptoggle
    BNE 'l4
    CMP.b #":",d0
    BEQ 'l3

 'l4
    ADDQ #1,a5
 BRA 'loop

 'l3
  MOVE.w d0,lastchar
  MOVE.l (a7)+,d0
RTS
 ; < new


collif:
  ;collect a comparison thingy
  ;
  BSR.w ifchar
   BNE.w JUMP_syntaxerr
  MOVE.w D0,D1
  JSR get1bytemain
  BSR.w ifchar
   BNE.w 'skip
  ADDQ.w #1,D0
  MOVE.w D0,D2
  ADD.w D0,D0
  ADD.w D2,D0
  ADD.w D0,D1
  MOVE.w D1,D0
  ANDI.w #$3,D0
  CMP.w #$3,D0
   BEQ.w JUMP_syntaxerr

  JSR get1bytemain

 'skip
RTS


thetst1:  TST.b D0
thetst2:  TST.w D0
thetst3:  TST.l D0
thetst4:  TST.l (A7)+                                      ;Any Length?
thetst5:  JSR _Reschedule(A6)

posbr:    BEQ.w posbr
negbr:    BNE.w negbr


;dounless:                                                 ;??looks like not used??
  MOVEQ.l #-$01,D2
BRA.w doifm


.do_while:
  CLR.l fp0addr
  MOVEQ.l #$01,D1                                          ;while flag
  MOVEQ.l #$00,D2                                          ;negate flag
BRA.w doif2


freereps:
  LEA firstrep,A2
  MOVEQ.l #$08,D2
BRA.w freeslist


freesels:
  LEA firstsel(PC),A2
  MOVEQ.l #$0E,D2

 freeslist:
    ;free a simple list. a2=lea of list, d2=size
    ;
  MOVEQ.l #$00,D3
    ;
;freelist:                                                 ;??looks like not used??
    ;a2=lea of list, d2=size of item
    ;d3=offset to sub list, d4=size of sublist item
    ;
    ;if d3=0 then single list free only.
    ;
  MOVE.l (A2),D0
  CLR.l (A2)
  MOVEA.l D0,A2
  MOVEA.l _execbase,A6

 'loop
    CMPA.w #$0,A2
     BEQ.w 'done
    TST.w D3
     BEQ.w 'skip
    MOVEM.l D2-D3/A2,-(A7)
    ADDA.w D3,A2
    MOVE.l D4,D2
    BSR.w freeslist
    MOVEM.l (A7)+,D2-D3/A2

 'skip
    MOVEA.l A2,A1
    MOVE.l D2,D0
    MOVEA.l (A2),A2
    MOVE.l mempool,a0
    JSR _FreePooled(A6)
 BRA.w 'loop

 'done
RTS

JUMP_eselerr JMP eselerr


firstsel:  Ds.l 1

;------                                                  ;disassembled code begin
selpushb:   Dc.b $02,$40,$00,$FF                           ;ANDI.W  #$00FF,D0
;------                                                  ;disassembled code end

selpushw:   MOVE.w D0,-(A7)
selpushbf:   ;
selpushl:   MOVE.l D0,-(A7)
selpushlf:   ;
selpushs:   LEA $4(A7),A2                                  ;(a7)=len of string!
selpushsf:   ;

selcomb:    ANDI.w #$FF,D0
selcomw:    CMP.w (A7),D0
selcombf:    ;
selcoml:    CMP.l (A7),D0
selcomlf:    ;
selbne:     BNE.w selbne

endsel:     ADDQ.w #8,A7


doendsel:                                                  ;doendselect
    ;END SELECT
    ;
  MOVE.l firstsel(PC),D0                                  
   BEQ.w JUMP_eselerr
  MOVEA.l D0,A2
   BSR.w fillbne
    ;
    ;fill in all bras at end of cases!
  MOVEA.l _execbase,A6

 'loop
  MOVE.l $4(A2),D0
   BEQ.w 'done
  MOVEA.l D0,A3
  MOVEA.l $4(A3),A0
  MOVE.l destpointer,D1
  SUB.l A0,D1
  CNIF #longbranch
    TST.b fast
    BEQ 'loop_l1
    MOVE.w dontwrite_nomemleft,D0
    BNE.w 'skip
    ADDQ.l #2,d1
    MOVE.l d1,-2(a0)
  BRA 'skip
  CEND

 'loop_l1
  TST.w dontwrite_nomemleft
     BNE.w 'skip
  CMP.l #MaxWordSgnd,D1
   BHI.w JUMP_cbraerr
  MOVE.w D1,(A0)

 'skip                                                     ;free it up!
  MOVE.l (A3),$4(A2)                                       ;next of me is new first
  MOVEA.l A3,A1
  MOVEQ.l #$08,D0
  MOVE.l mempool,a0
   JSR _FreePooled(A6)
 BRA.w 'loop

 'done
  JSR popselect                                            ;fix stack on select
  MOVEA.l firstsel(PC),A1
  MOVE.l (A1),firstsel
  MOVEQ.l #$0E,D0
  MOVEA.l _execbase,A6
  MOVE.l mempool,a0
  JSR _FreePooled(A6)
JMP get1bytemain


endselstr:
  MOVEA.l (A7)+,A1
  SUBQ.w #8,A1
  MOVEQ.l #$09,D0
  ADD.l (A1),D0

 endselstrf:
  ADDQ.w #2,A7                                             ;for runtime errs!
endselstrf2:   ;


.do_default:
  MOVE.l firstsel(PC),D0
   BEQ.w JUMP_defaerr
  MOVEA.l D0,A2
  BSR.w fillbra
  BSR.w fillbne
  CLR.l $8(A2)
  MOVE.w $C(A2),D2
BRA.w casechk

JUMP_defaerr JMP defaerr


fillbne:
  ;a2=sel
  MOVE.l $8(A2),D0
   BEQ.w 'skip   ;none to do!
  MOVEA.l D0,A0
  MOVE.l destpointer,D1
  SUB.l A0,D1
  ; new >
  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    TST.w dontwrite_nomemleft
    BNE.w 'skip
    ADDQ.l #2,d1
    MOVE.l D1,-2(A0)
  BRA 'skip
  CEND

 'l1
  TST.w dontwrite_nomemleft
     BNE.w 'skip
  ; < new
   CMP.l #MaxWordSgnd,D1
   BHI.w JUMP_cbraerr
  MOVE.w D1,(A0)

 'skip
RTS

JUMP_cbraerr JMP cbraerr


fillbra:
  ;make a bra if necessary
  ;
  MOVE.l $8(A2),D0
   BEQ.w 'skip
  ;
  ;OK, we're after a case thingy. add a BRA
  ;
  MOVEA.l D0,A3
  MOVE.w #$6000,D1
  ; new >
 CNIF #longbranch
   TST.b fast
   BEQ 'l1
   OR.l #$ff,d1
   BSR writeword
 CEND

 'l1
  ; <new
  BSR.w writeword
  MOVEQ.l #$08,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
  ; new >
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  ; < new
   ;jsr do_AllocMem
  MOVEA.l D0,A0
  MOVE.l $4(A2),(A0)
  MOVE.l A0,$4(A2)
  MOVE.l destpointer,$4(A0)
 BRA.w writeword

 'skip
RTS


casechk:
  TST.b debugmode
   BEQ.w 'norerr
  MOVE.w #$C313,D1
  CMP.w #$3,D2
   BCS.w 'dochk
  ADDQ.w #1,D1

 'dochk
 BRA.w Atokejsr

 'norerr
RTS


JUMP_caseerr JMP caseerr

.do_case:
  ;eg : CASE a+10
  ;
  ;first, fill in last bra (if there is one!)
  ;
  MOVE.l firstsel(PC),D0
   BEQ.w JUMP_caseerr
  MOVEA.l D0,A2
   BSR.w fillbra
   BSR.w fillbne
  ;
  MOVE.w $C(A2),D2    ;type to get!
  MOVE.w D2,-(A7)
   BSR.w casechk
  MOVE.w (A7),D2

 ;'norerr
   BSR.w bakeval
  MOVE.w (A7)+,D2    ;types to compare
  LEA selcomb(PC),A0
  LEA selcombf(PC),A1
  CMP.w #$1,D2
   BEQ.w 'doit
  LEA selcomw(PC),A0
  CMP.w #$2,D2
   BEQ.w 'doit
  LEA selcoml(PC),A0
  LEA selcomlf(PC),A1
  CMP.w #$7,D2
   BCS.w 'doit
  ;Strings....
  MOVE.w #$CE01,D1     ; was #casestrcomp
   BSR.w Atokejsr
 BRA.w 'doneit

 'doit
  BSR.w pokecode

 'doneit
  MOVE.w selbne(PC),D1
  ; new >
  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    ORI.l #$ff,d1
    BSR writeword
  CEND

 'l1
  ; < new
  BSR.w writeword
  MOVEA.l firstsel(PC),A0
  MOVE.l destpointer,$8(A0)
BRA.w writeword


;------                                                  ;disassembled code begin
pcchk:      Dc.b $3F,$3C,$73,$45                           ;MOVE.W  #$7345,-(A7)   ;#"sE",-(a7) org source
clrst:      Dc.b $42,$A7                                   ;CLR.L   -(A7)
;------                                                  ;disassembled code end

sellineat:  Ds.l 1


.do_select:
    ;OK, as in : SELECT opt
    ;
  TST.b debugmode
   BEQ.w 'norerr
  MOVE.l pcchk(PC),D1                                      ;move #"sE",-(a7)
   BSR.w writelong

 'norerr
  MOVE.l linenumat,sellineat
   ;bsr.w pushstart                                        ;we may have to CLR -(a7)!
  ; new >
   MOVE.l destpointer,pushpc
  MOVE.l hunkoffsetbase,pushoff
  ; < new
  MOVEQ.l #$00,D2
   BSR.w bakevalu                                          ;Evaluate
   BSR.w pushdo
  CMP.w #$7,D2
   BNE.w 'nos
  MOVE.w clrst(PC),D1
   BSR.w writeword

 'nos
   BSR.w pushput
  LEA selpushb(PC),A0
  LEA selpushbf(PC),A1
  CMP.w #$1,D2
   BEQ.w 'doit
  LEA selpushw(PC),A0
  CMP.w #$2,D2
   BEQ.w 'doit
  LEA selpushl(PC),A0
  LEA selpushlf(PC),A1
  CMP.w #$7,D2
   BCS.w 'doit
    ;
  MOVE.w moved0a3,D1                                       ;d0 to a3!
   BSR.w writeword
  LEA selpushs(PC),A0
  LEA selpushsf(PC),A1
   BSR.w pokecode
  MOVE.w #$C701,D1     ; was #astring
   BSR.w Atokejsr
 BRA.w 'doneit

 'doit
  BSR.w pokecode

 'doneit
  MOVEQ.l #$0E,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
   ;jsr do_AllocMem    ;get the mem
  ; new >
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  ; < new
  MOVEA.l D0,A0
  MOVE.l firstsel(PC),(A0)
  MOVE.l A0,firstsel
  CLR.l $4(A0)
  CLR.l $8(A0)        ;default mode!
  MOVE.w D2,$C(A0)
RTS


.do_Forever:
  MOVE.l firstrep,D0
   BEQ.w JUMP_unterr1
  MOVE.w #$6000,D1      ;BRA
  BSR.w writeword
  MOVEA.l D0,A0
  MOVE.l $4(A0),D1      ;dest pc
  SUB.l destpointer,D1
  TST.w D1
   BPL.w JUMP_unterr2
  BSR.w writeword
  MOVEA.l _execbase,A6
BRA.w unlinkrep

JUMP_unterr2 JMP unterr2
JUMP_unterr1 JMP unterr1


.do_Until:
  MOVE.l firstrep,D0
   BEQ.w JUMP_unterr1    ;no repeat!
  BSR.w do_if            ;do the until
  ;
  JSR reget
   BNE.w JUMP_syntaxerr
  ;
  MOVE.w dontwrite_nomemleft,D1
   BNE.w 'skip
  MOVEA.l firstrep,A0
  MOVEA.l destpointer,A1
  ; new >
  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    SUBQ.w #4,a1
    MOVE.l $4(A0),D2
    SUB.l A1,D2
    MOVE.l d2,(a1)
  BRA 'skip
  CEND

 'l1
  ; < new
  SUBQ.w #2,A1
  MOVE.l $4(A0),D2    ;dest pc.
  SUB.l A1,D2
  TST.w D2
   BPL.w JUMP_unterr2
  MOVE.w D2,(A1)      ;put in pra dest.

 'skip
  MOVEA.l firstiff,A1
  MOVE.l (A1),firstiff
  MOVEQ.l #$0E,D0
  MOVEA.l _execbase,A6
  ;jsr freemem(a6)
  ; new >
  MOVE.l mempool,a0
  JSR _FreePooled(A6)
  ; < new

unlinkrep:
  MOVEA.l firstrep,A1
  MOVE.l (A1),firstrep
  MOVEQ.l #$08,D0
  ;jsr freemem(a6)
  ; new >
  MOVE.l mempool,a0
JMP _FreePooled(A6)
  ; < new

iflineat:   Ds.l 1


.do_if:
  MOVEQ.l #$00,D2   ;negate flag
  ; new >
  TST.b fast
  BEQ 'l1
  MOVE.b #1,nostringopt
  MOVE.b #1,iniffcommand

 'l1
  ; < new
doifm:                                                ;??looks like double label??
  MOVEQ.l #$00,D1  ;if flag

doif2:
  ;the main IF bit
  ;
  ;
  MOVE.w D1,-(A7)
  MOVE.l destpointer,-(A7)
  MOVE.w D2,-(A7)
  MOVE.l linenumat,iflineat
  ;
  MOVEQ.l #$00,D2
  ; new >
  MOVE.b optistring,optistring2
  MOVE.b #1,optistring
  ; < new
  BSR.w bakevalu       ;Get True/False Expression!
  ; new >
  MOVE.b optistring2,optistring
  ; < new
  CMP.w #$5,D2
   BEQ.w 'float
  MOVE.w thetst1(PC),D1
  CMP.w #$1,D2
   BEQ.w 'writebranchcode
  MOVE.w thetst2(PC),D1
  CMP.w #$2,D2
   BEQ.w 'writebranchcode
  MOVE.w thetst4(PC),D1
  CMP.w #$7,D2
   BEQ.w 'writebranchcode
  MOVE.w thetst3(PC),D1
 BRA.w 'writebranchcode

 'float
  ; new >
  TST.b fpu
  BEQ 'dofpu
  MOVE.l #$f200003a,d1
  BSR writelong
  MOVE.w #$f2c1,d1       
  BSR writeword
  BSR writelong
  ADDQ.l #2,a7
 BRA.w 'br2

 'dofpu
  ; < new
   MOVE.w #$C900,D1     ;was #getffpbase
   BSR.w Atokejsr
  MOVE.l thetst5(PC),D1
   BSR.w writelong
 BRA.w 'gotst2

 'writebranchcode      ; was 'gotst
  ; new >
         CLR.b iniffcommand
         TST.b fast                                        ;branchcode
         BEQ 'b6
         TST.b fpu
         BEQ 'nofpu
         CNIF #optibreak
           ILLEGAL
         CEND
          MOVE.l destpointer,a0
         SUB.l load_var_addr,a0
         CMP.l #4,a0
         BEQ 'nofpu
         CMP.l #$f2400014,-4(a4)                           ;<
         BNE 'nolt
         SUBQ.l #2,destpointer
         MOVE.w #$f293,-4(a4)                              ;
 BRA 'brf

 'nolt
  CMP.l #$f2400015,-4(a4)                                  ;<=
         BNE 'nole
         SUBQ.l #2,destpointer
         MOVE.w #$f292,-4(a4)
 BRA 'brf

 'nole
  CMP.l #$f2400013,-4(a4)                                  ;=>
         BNE 'noge
         SUBQ.l #2,destpointer
         MOVE.w #$f294,-4(a4)
 BRA 'brf

 'noge
  CMP.l #$f2400012,-4(a4)                                  ;>
         BNE 'nogt
         SUBQ.l #2,destpointer
         MOVE.w #$f295,-4(a4)
 BRA 'brf

 'nogt
  CMP.l #$f2400001,-4(a4)                                  ;=
         BNE 'noeq
         SUBQ.l #2,destpointer
         MOVE.w #$f28e,-4(a4)
 BRA 'brf

 'noeq
  CMP.l #$f240000e,-4(a4)                                  ;<>
         BNE 'none
         SUBQ.l #2,destpointer
         MOVE.w #$f281,-4(a4)

 'brf
  ADDQ.l #2,a7
  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    OR.b #$40,-3(a4)
    BSR writeword
  CEND

 'l1
  BSR writeword
 BRA.s 'br2

 'none                                                     ;??Looks like double label??
 'nofpu
  MOVE.l destpointer,a0
         SUB.l load_var_addr,a0
         CMP.l #4,a0
         BEQ 'gotst2
         CMP.w #$4eb9,-6(a4)
         BEQ 'b6
         CMP.w #$5ec0,-2(a4)                               ;>
     BNE.s 'lb1
         MOVE.w #$6f00,-2(a4)                              ;ble
 BRA.s 'br

 'lb1
  CMP.w #$5dc0,-2(a4)                                       ;<
  BNE.s 'lb2
         MOVE.w #$6c00,-2(a4)                              ;bge
 BRA.s 'br

 'lb2
  CMP.w #$57c0,-2(a4)                                      ;=
  BNE.s 'lb3
         MOVE.w #$6600,-2(a4)                              ;bne
 BRA.s 'br

 'lb3
  CMP.w #$56c0,-2(a4)                                      ;<>
  BNE.s 'lb4
         MOVE.w #$6700,-2(a4)                              ;beq
 BRA.s 'br

 'lb4
  CMP.w #$5cc0,-2(a4)                                      ;>=
  BNE.s 'lb5
         MOVE.w #$6d00,-2(a4)                              ;blt
 BRA.s 'br

 'lb5
  CMP.w #$5fc0,-2(a4)                                      ;<=
        BNE.s 'b6
         MOVE.w #$6e00,-2(a4)                              ;bgt

 'br
  TST.w (a7)+
  CNIF #longbranch
        TST.b fast
        BEQ 'l1a
        OR.b #$ff,-1(a4)                                   ;long branches
        BSR writeword
  CEND

 'l1a
        BSR writeword
 BRA.s 'br2

 'b6
  ; < new
  BSR.w writeword

 'gotst2
  MOVE.l posbr(PC),D1
  TST.w (A7)+
   BEQ.w 'skip
  MOVE.l negbr(PC),D1

 'skip
  ; new >
  TST.b fast
           BEQ 'l1b
           OR.l #$00ff0000,d1
           BSR writelong
           BSR writeword
 BRA 'br2

 'l1b
  BSR.w writelong

 'br2
  ; < new
  MOVEQ.l #$0E,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
   ;jsr do_AllocMem
  ; new >
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  ; < new
  ;
  MOVEA.l D0,A0
  MOVE.l firstiff,(A0)
  MOVE.l A0,firstiff
  MOVE.l (A7)+,$4(A0)
  MOVE.l destpointer,$8(A0)
  MOVE.w (A7)+,$C(A0)
   JSR reget
   BEQ.w ifdone
  BSET #$7,$C(A0)    ;one liner


.do_then:
  ;bsr.w bakup       ;to reget last
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  MOVE.w #$003A,lastchar      ; ':'

ifdone:
RTS


ongotocode:
  CMP.w #$1,D0     ;4
   BLT.w gc1skip   ;4
  CMP.w #$0,D0     ;2
   BGT.w gc1skip
  ADD.w D0,D0
  ADD.w D0,D0
  MOVEA.l gc1labs-4(PC,D0.W),A0
 JMP (A0)

gc1skip:                                                ;??
 BRA.w gc1skip
gc1labs: ;
ongotocodef:


ongosubcode:
  CMP.w #$1,D0     ;4
   BLT.w gc2skip   ;4
  CMP.w #$0,D0     ;2
   BGT.w gc2skip
  ADD.w D0,D0
  ADD.w D0,D0
  MOVEA.l gc2labs-4(PC,D0.W),A0
  JSR (A0)

gc2skip:                                                ;??
 BRA.w gc2skip
gc2labs:
ongosubcodef:


ongcode:
  CMP.w #$1,D0    ;4
   BLT.w gc3skip  ;4
  CMP.w #$0,D0    ;2
   BGT.w gc3skip
  ADD.w D0,D0
  ADD.w D0,D0
  MOVEA.l gc3labs-4(PC,D0.W),A0

goset:
  MOVE.w #$6753,-(A7)                                      ;#'gS' ;for runtime error checking!
   JSR (A0)

gc3skip:                                                ;??
 BRA.w gc3skip
gc3labs:
ongcodef:


labcnt:   Ds.w 1


.do_Ongo:                                                  ;On expression Goto/Gosub Label[Label...]
    ;
    ;Get expression as a word.
    ;
  MOVEQ.l #$02,D2
   BSR.w bakeval
  ;
  LEA ongotocode(PC),A0
  LEA ongotocodef(PC),A1
  MOVE.w #gc1skip-ongotocode,D1      ; is #$001A

  CMP.w ##TokenID_Goto,D0                   ; was #$8005
  BEQ.w 'isok

  CMP.w ##TokenID_Gosub,D0                   ; was #$8006
  BNE.w JUMP_syntaxerr

  LEA ongosubcode(PC),A0
  LEA ongosubcodef(PC),A1
  MOVE.w #gc2skip-ongosubcode,D1     ; is #$001A
  ;
  TST.b debugmode
   BEQ.b 'isok
  ;
   JSR chkstak
  LEA ongcode(PC),A0
  LEA ongcodef(PC),A1
  MOVE.w #gc3skip-ongcode,D1         ; is #$001E

 'isok
  MOVE.w D1,-(A7)
  MOVE.l destpointer,-(A7)                                 ;for when we know number of labels!
   BSR.w pokecode
  CLR.w labcnt
  ;
  ;now, make a labels list!
  ;

 'loop
   JSR get1bytemain
  SUBQ.l #2,destpointer                                    ;for makealab!
   BSR.w makealab2
  ADDQ.l #2,destpointer
   JSR addoff
  MOVE.l $8(A2),D1
   BSR.w writelong
  ADDQ.w #1,labcnt
   JSR reget
  CMP.w #$2C,D0 ; ','
   BEQ.w 'loop
  ;
  MOVEA.l (A7)+,A0
  MOVE.w (A7)+,D2
  MOVE.w dontwrite_nomemleft,D1
   BNE.w 'done
  ;
  MOVE.w labcnt(PC),D1
  MOVE.w D1,$A(A0)       ;for cmp#
  ADD.w D1,D1
  ADD.w D1,D1
  ADDQ.w #2,D1
  MOVE.w D1,$2(A0,D2.W)  ;for bra!

 'done
RTS


.do_gosub:
  TST.b debugmode
   BEQ.w 'noerr
  ;
   JSR chkstak
  MOVE.l goset,D1
   BSR.w writelong

 'noerr
  MOVE.w gosubcode,D1
BRA.w dogoto2


.do_goto:
  MOVE.w gotocode,D1

dogoto2:
  MOVE.w D1,-(A7)
   BSR.w makealab2
  MOVE.w (A7)+,D1
   BSR.w writeword
   JSR addoff
  MOVE.l $8(A2),D1
BRA.w writelong


.do_AsmExit:     ; was eos
  MOVE.w proceduremode,D1
   BEQ.w JUMP_badpenderr
  ;
  MOVE.w #$4EF9,D1                    ; JMP
   BSR.w writeword
   JSR addoff
  ;
  MOVEA.l _execbase,A6
  MOVEQ.l #$08,D0
  MOVEQ.l #$01,D1
   ;jsr do_AllocMem
  ; new >
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  ; < new
  MOVEA.l D0,A0
  MOVE.l firstpend,(A0)
  MOVE.l A0,firstpend
  MOVE.l destpointer,$4(A0)
  ;
BRA.w writelong


stateret:
  BSR.w do_AsmExit
JMP get1bytemain


do_function_return:      ; was funcret
  ; new >
  MOVE.b #1,nostringopt
  MOVEM.l a0/a1/d1,-(a7)
  ; < new
  MOVEA.l currentfunction,A0
  ; new >
    CMP.l #0,a0
    BNE 'l1
    JMP errorasmexit

 'l1
  MOVEQ.l #$00,D2
  ; < new
  MOVE.b $5(A0),D2      ;type returning!
  BSR.w eval            ;put return val in d0.
  ; new >
 CNIF #function_support_returntype
  MOVEA.l currentfunction,A0
  MOVE.l funcstruct_returntype(a0),a0
  CMP.l #0,a0
  BEQ 'isstatement
  CMP.l #$100,4(a0)
  BLT.w 'isvar
  MOVE.l a2,a1
  TST.l typetocast
  BEQ 'nocast
  MOVE.l typetocast,a1

 'nocast
  CMP.l a0,a1
  BEQ 'ok
  CLR.l typetocast
  MOVE.l lasttoken,d1
  CMP.w ##TokenID_Null,d1                   ;$b581 ok, when token for null
  BEQ 'isnull

 'error
  JMP errorconvertreturntype

 'isnull
  ;MOVE.w #$4e75,d1                  ;write rts

 'isvar
 'ok
 'isstatement
 CEND
  MOVEM.l (a7)+,a0/a1/d1
  ; < new
  ;
BRA.w do_AsmExit

error_convert_types2 JMP error_convert_types


.do_return:
   ; new <
;  TST.w proceduremode                                      ; return work in functions
;  BEQ 'no                                                  ; must forbid gosub in functions
;  TST.l currentfunction                                    ; if that work
;  BEQ 'no
;  SUBQ.l #1,a5
;  BGT do_function_return
;  CMP.w #$ffff,proceduremode
;  BEQ stateret
;
;'no
  ; < new
  TST.b debugmode
   BEQ.w normret
  MOVE.w #$C305,D1        ; was #chkret,
BRA.w Atokejsr


normret:
  ;a normal return
  ;
;.noerrchk
  MOVE.w #$4E75,D1
BRA.w writeword


localslist:  Ds.l 1                                        ;all locals for procs.;??Looks like obsovled data??
proclocals:  Ds.l 1                                        ;for debugga!
procnum:     Ds.w 1
procnum2:    Ds.w 1
prolineat:   Ds.l 1


.do_statement:                   ; was dostate  org  source
   ; new >
   TST.w proceduremode
   BGT JUMP_sreterr
   ; < new
   CMP.w ##TokenID_Return,D0     ;was #$8007 Token "Return"
   BEQ.w stateret
   MOVEQ.l #-$01,D1  ;statement flag
BRA.w do_function2

JUMP_sreterr JMP sreterr


checkused
  CLR.b skipfunc
  TST.l unusedfunc
  BEQ 'ex
  MOVEM.l d0-d7/a0-a6,-(a7)
  MOVE.l unusedfunc,d1
  LEA ptr_parameterstore,a5

 'ag
  MOVE.l d1,a0
  LEA 12(a0),a2
  MOVE.l a5,a1
 'ch
  CMPM.b (a1)+,(a2)+
  BNE 'neq
  TST.b (a2)
  BNE 'ch
  TST.b (a1)
  BNE 'neq
  MOVE.b #1,skipfunc
 BRA 'out

 'neq
  MOVE.l (a0),d1
  BNE 'ag

 'out
  MOVEM.l (a7)+,d0-d7/a0-a6

 'ex
RTS


JUMP_dupprocerr  JMP dupprocerr
JUMP_illprocperr JMP illprocperr
JUMP_toovarerr   JMP toovarerr
JUMP_more6pard   JMP more6pard


.do_function:
  CMP.w #-1,proceduremode                                  
   BEQ JUMP_sreterr
  CMP.w ##TokenID_Return,D0      ; was #$8007
   BEQ.w do_function_return

  ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  JSR check_FunctionReturnType
  JSR get1bytemain

do_function2:                                             ;do_statement jump to here
  ;do some checking.....
  ;
  ; new >
  TST.b declare
  BEQ 'l3
  MOVE.b #1,nowdeclare

 'l3
  ; < new
  JSR errchx                                           ;writejumpoverfunction

  ; new >
 ;returnaddr
  CLR.b fastfunc
  MOVE.l firstiff,firstiffstore
  CMP.l #"FAST",-1(a5)
  BNE 'nofast
  CMP.b #" ",3(a5)
  BNE 'nofast
  ADDQ.l #3,a5

 'x2
    CMP.b #" ",(a5)
     BNE 'x1
    ADDQ #1,a5
 BRA 'x2

 'x1
  MOVE.l a5,lastsourcepos
  MOVE.b #1,fastfunc

 'nofast
  CMP.l #"NOOP",-1(a5)                                     ;compile 3* so its deactivate
 BRA 'noopt

  CMP.w #"T ",3(a5)                                        ;??Looks like dead code??
  BNE 'noopt                                               ;          "
  ADDQ.l #4,a5                                             ;          "

 'x2b                                                      ;          "
    CMP.b #" ",(a5)                                        ;          "
     BNE 'x1b                                              ;          "
    ADDQ #1,a5                                             ;          "
 BRA 'x2b
                                                           ;          "
 'x1b                                                      ;          "
  MOVE.l a5,lastsourcepos                                  ;          "
  JSR makename2                                            ;          "
 BRA 'l1                                                   ;          "

 'noopt
  JSR makename2
  JSR checkused
  TST.b skipfunc
  BEQ 'l1
    JSR skipme
    CLR.b fastfunc
    RTS
 'l1
  ; < new
  MOVE.l linenumat,prolineat
  ;
  ADDQ.w #1,procnum2
  MOVE.w procnum2(PC),procnum
  MOVE.w D1,proceduremode
  CLR.w locvaroff

  CMP.w #$7B,D0   ;'{'
   BNE.w JUMP_syntaxerr
  ; new >
   MOVE.b #1,infunctioncode
  ; < new
  MOVEA.l tempvm,A0
  MOVE.w $C(A0),memlibstat
  BCLR #$7,$C(A0)                                          ;Bit out of range
  MOVE.w #$4EF9,D1                                         ;make a JMP around the proc
  BSR.w writeword
  JSR addoff
  BSR.w writelong
  ;
  JSR find_procedure                                      ;find_procedure function
  BEQ.w JUMP_dupprocerr
  JSR addlabel
  ; new >
  MOVE.b #31,$20(a2)                                      ;increase if more pars
  MOVE.b #0,isfunc(a2)
  MOVE.l functionreturntype,funcstruct_returntype(a2)
  ; < new
  MOVE.l destpointer,$E(A2)    ;new!
  MOVE.l A2,currentfunction
  ;
  LEA nops8,A0
  LEA nopsf,A1
  BSR.w pokecode2
  ;
  TST.b debugmode
  BEQ.b 'nodebug
    MOVEQ.l #$04,D1
    JSR writetrap
    MOVE.l destpointer,proclocals
    BSR.w writelong
    BSR.w writelong
 'nodebug

  LEA $16(A2),A4
  MOVE.b proceduremode+1,$5(A2)
  MOVEQ.l #$00,D6
  MOVEQ.l #$00,D5
  JSR get1bytemain

  CMP.w #$7D,D0        ; '}'
  BEQ.w 'done

 'more
  ; new >
  CMP.b #"@",d0
  BNE 'l2
    MOVE.l a0,-(a7)
    MOVE.l currentfunction,a0
    CMP.b #31,$20(a0)                                       ;increase if morepars
    BNE 'l4
      MOVE.b d6,$20(a0)                                     ;increase if morepars
   'l4
    JSR get1bytemain
    MOVE.l (a7)+,a0
 'l2
  ; < new
  BSR.w getparameter
  JSR fetchvars
  CMPI.l #$7,$4(A2)
  BNE.w 'notst
    LEA stbuff,A0
    MOVE.w D5,D1
    LSL.w #2,D1
    MOVE.w D6,$0(A0,D1.W)
    MOVE.w $4(A3),$2(A0,D1.W)
    ADDQ.w #1,D5
    MOVEQ.l #$07,D2
    BRA.w 'pgot
 'notst
  MOVE.w #$2940,D1
  MOVEQ.l #$03,D2
  BTST #$0,flagmask+1
  BNE.w 'sgot
    CMPI.l #$100,$4(A2)
    BCC.w JUMP_illprocperr
      MOVE.w $6(A2),D2
      CMP.w #$2,D2
      BHI.w 'sgot
      BEQ.w 'wgot
        EORI.w #$3000,D1
        BRA.w 'sgot
     'wgot
      ORI.w #$1000,D1
 'sgot
  OR.w D6,D1
  ; new >
  TST.b fpu
  BEQ 'nofpu
    CMP.b #5,d2
    BNE 'nofpu
      CMP.w #6,d6
      BLT 'l10a
        CMP.l #newtype_double,a2
        BEQ JUMP_more6pard
          BRA 'nofpu

     'l10a
      MOVE.l #$f22c6400,d1
      MOVEM.l d0/a4,-(a7)
      MOVE.l d6,d0
      ASL.l #7,d0
      OR.w d0,d1
      CMP.l #newtype_double,a2
      BNE 'l5
        OR.l #$1000,d1
     'l5
      BSR writelong
      MOVE.w 4(a3),d1
      BSR writeword
      MOVEM.l (a7)+,a4/d0
      BRA 'pgot
 'nofpu
  ; < new
  MOVE.l A4,-(A7)
  ; new >
   CMP.w #6,d6
   BLT 'l10
   MOVE.w #$c500-4,d1                                      ;savetemp+regnum
   ADD.w d6,d1
   JSR Atokejsr
   TST.w dontwrite_nomemleft
   BNE 'l10
   MOVE.l data1start,d1
   MOVE.l destpointer,a4
   ADD.l d1,-6(a4)
   MOVE.l destpointer,d1
   SUBQ.l #6,d1
   SUB.l destbufferstart,d1

   MOVE.l d2,-(a7)
   MOVE.l d1,d2
   JSR addhunkoffset                                       ;move.l $0,-x(a4)
   MOVE.l (a7)+,d2
   MOVE.l destpointer,a4
   CMP.w #2,d2
   BNE 'nw1

   MOVE.w #$3979,-8(a4)                                    ;move.w $0,-x(a4)
   ADD.l #2,-6(a4)

 'nw1
   CMP.w #1,d2
   BNE 'nb
   MOVE.w #$1979,-8(a4)                                    ;move.b $0,-x(a4)
   ADD.l #3,-6(a4)

 'nb
   MOVE.w $4(a3),-2(a4)
 BRA 'ne1

 'l10
  ; < new
  BSR.w writeword                                          ;write storeparameter

 'l20
  MOVE.w $4(A3),D1
   BSR.w writeword

 'ne1
  MOVEA.l (A7)+,A4

 'pgot
  ; new >
  CLR.l functionreturntype
  ; < new
  ADDQ.w #1,D6
  CMP.w #11,D6          ; was #7                            ;max function parameters
   BCC.w JUMP_toovarerr
  ; new >
  MOVE.l currentfunction,a0
  MOVE.l a2,funcstruct_parametertype-4(a0,d6*4)             ;-4 because d6 is increment before
  ; < new
  MOVE.b D2,(A4)+
  CMP.w #$2C,D0      ;','
  BNE.w 'nomore
    JSR get1bytemain
  ; new >
  ;   CMP.b #"@",d0
  ;   BNE 'more
  ;   MOVE.l a0,-(a7)
  ;   MOVE.l currentfunction,a0
  ;   CMP.b #31,$20(a0)                                       ;increase if morepars
  ;   BNE 'l6
  ;     MOVE.b d6,$20(a0)
  ;  'l6
  ;   JSR get1bytemain
  ;   MOVE.l (a7)+,a0
  ; < new
      BRA.w 'more
 'nomore
  CMP.w #$7D,D0                                             ; "}"
  BNE.w JUMP_syntaxerr

 'done
  MOVEA.l currentfunction,A2
  LSL.w #4,D5
  OR.w D5,D6
  MOVE.b D6,$4(A2)
  LSR.w #4,D6
  BEQ.w 'nostrings
  LEA stbuff,A0
  SUBQ.w #1,D6

 'stloop
  ;
  ;do all the string things
  ;
    MOVE.w D6,D1                                           ;function stringpars
    LSL.w #2,D1                                            ;stringsize was 2
  ; new >
    CNIF #more6string
      LSL.w #1,d1
      ADDQ.w #4,d1
    CEND
  ; < new
    ADDQ.w #8,D1
    MOVE.w D1,funcst+2
    MOVE.l funcst,D1
    BSR.w writelong
    MOVE.w (A0)+,D1
  ; new >
    CMP.b #5,d1
    BLE 's1
    MOVE.w #$266c,d1                                       ;native move.l 4(a4),a3
    BSR writeword                                          ; was writeinstruction  tomsmart1
    MOVE.w D6,D1                                           ;function stringpars
    LSL.w #2,D1                                            ;stringsize was 2
    CNIF #more6string
      LSL.w #1,d1
    CEND
    ADDQ.w #8,D1
    BSR writeword
    BRA 's2

   's1
   ; < new
    OR.w movedna3,D1
     BSR.w writeword

   's2
    MOVE.w (A0)+,least+2
    MOVE.l least,D1
     BSR.w writelong
    MOVE.l A0,-(A7)
    MOVE.w #$C700,D1
     BSR.w Atokejsr
    MOVEA.l (A7)+,A0
  DBF D6,'stloop

 'nostrings
JMP get1bytemain


linkput:
  MOVE.w dontwrite_nomemleft,D1
  BNE.w 'skip
    MOVE.l destpointer,-(A7)
    ;
    MOVE.l A0,destpointer
    MOVE.l linksize,D1
    BSR.w writelong                                         ;writefunctions jumppos
    ; new >
    TST.b fastfunc
    BNE 'skip1
      ; < new
      MOVE.w #$CC00,D1                                        ; was #clrloc
      BSR.w tokejsr2                                          ;write clearvars
   'skip1
    MOVE.l (A7)+,destpointer
 'skip
RTS


JUMP_errormsg_nofast  JMP errormsg_nofast

procfixer:
  ;fix up procs!
  ;
  MOVEA.l currentfunction,A2
  MOVEA.l $E(A2),A0          ;pc of proc
  MOVE.w $6(A2),D1
   BEQ.w 'skiplink
  MOVE.w D1,linksize+2
  MOVE.w $8(A2),D1                                         ;check if function memalloc need
   BNE.w 'howdy
  ;
  ;link only
  ;
  ADDQ.w #6,A0
  MOVE.l A0,$E(A2)
 BRA.w linkput

 'howdy
  ;link and jsr
  ;
  MOVE.l A0,-(A7)
   BSR.w linkput
  MOVEA.l (A7)+,A0
  LEA $A(A0),A0
  MOVEA.l currentfunction,A2
 BRA.w 'cont

 'skiplink
  MOVE.w $8(A2),D1
  BNE.w 'cont
  LEA $10(A0),A0
  MOVE.l A0,$E(A2)
  RTS

 'cont
  MOVE.w dontwrite_nomemleft,D1                                     ;writeallocmem for functions (after releasemem called)
  BNE.w 'contskip
  ;
  ; new >
  TST.b fastfunc
  BNE JUMP_errormsg_nofast
  ; < new
  MOVE.l destpointer,-(A7)
  MOVE.l A0,destpointer
  MOVE.w #$4EB9,D1      ;jsr
   BSR.w writeword
   JSR addoff
   BSR.w writelong
  ;
  MOVEA.l (A7)+,A0
  MOVEA.l destpointer,A1
  MOVE.l A0,-(A1)
  MOVE.l A0,destpointer

 'contskip
  MOVE.w $8(A2),D4
   BPL.w 'linky
  MOVE.w #$C004,D1   ; was  #newmem
   BSR.w tokejsr2
  MOVEA.l currentfunction,A2
  MOVE.w $8(A2),D4
  ANDI.w #$7FFF,D4        ;#32767,

 'linky
   BEQ.w 'skipstat
  ;
  ;allocate statics!
  ;
  MOVE.b $4(A2),D1
  ANDI.w #$F,D1
  MOVE.w D1,-(A7)
  CMP.w #$5,D1
  BCS.w 'npush
    MOVE.w #$2F04,D1
    BSR.w writeword
 'npush
  MOVE.l locdatast,D3
  JSR datastart
  MOVE.w #$C501,D1    ; was #localstat
  BSR.w tokejsr2
  ;
  MOVE.w (A7)+,D1
  CMP.w #$5,D1
  BCS.w 'skipstat
    MOVE.w #$281F,D1
    BSR.w writeword
 'skipstat ;
  MOVE.w #$4E75,D1
BRA.w writeword


.do_mousewait:
  LEA mwait,A0
  LEA mwaitf,A1
BRA.w pokecode


JUMP_laberr    JMP laberr
JUMP_typeerr   JMP typeerr
JUMP_dupofferr JMP dupofferr

.do_newtype:
  CMP.w #$2E,D0           ;'.'
  BNE.w JUMP_syntaxerr

  JSR getparameter2
  BEQ.w JUMP_laberr

  LEA newtypebase,A2
  JSR findtype
  BNE.w 'ok1
    CMPI.l #MaxByte,$4(A2)    ; was #$FF
    BNE.w JUMP_typeerr
      BRA.w 'ok2
 'ok1
  JSR addlabel

 'ok2
  CLR.l $4(A2)
  MOVE.l A2,thistype
  CLR.l prevtype
  CLR.w typelen
  CLR.w linemode
  JSR reget
  BNE.w typemode
RTS


typemode:
  CMP.w ##TokenID_End,D0      ; was #$8002 / -$7FFE
  BEQ.w doend2
   ;bsr.w bakup
  ; new >
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5
  ; < new
  MOVEQ.l #$00,D6      ;not pointer
  CMP.w #$2A,D0        ;'*'
  BNE.w 'skip
  MOVEQ.l #$01,D6
  JSR get1bytemain
 BRA.w 'skipv

 'skip
  CMP.w #$40,D0         ;'@'
  BNE.w 'skipv
  MOVEQ.l #$05,D6
  JSR get1bytemain

 'skipv
  MOVE.w D6,flagmask
  JSR getparameter2
  BEQ.w JUMP_syntaxerr
  MOVEA.l thistype,A2
  ADDQ.w #4,A2
  JSR findvariable2
  BEQ.w JUMP_dupofferr     ;beq    .skip2
  ;
  JSR addlabel
  ;
; 'skip2                  ; org source
  MOVE.l A2,-(A7)
  CMP.w #$2E,D0           ;'.'
   BEQ.w 'skip3
  CMP.w #$24,D0           ;'$'
   BNE.w 'notstring
  MOVE.l #newtype_string,D2
   JSR get1bytemain
 BRA.w 'skip4a

 'notstring
  MOVE.l prevtype,D2
  BEQ.w JUMP_notypeerr2
 BRA.w 'skip4

 'skip3
  JSR getparameter2
   BEQ.w JUMP_syntaxerr
  LEA newtypebase,A2
   JSR findtype
   BEQ.w 'gotit
  BTST #$0,flagmask+1
   BEQ.w JUMP_notypeerr2
  ;
  ;pointer type, gotta do something tricky!
  ;
  JSR addlabel

  ; new >
 'n
  ; < new
  MOVE.w linenumat+2,$8(A2)
  MOVE.l #MaxByte,$4(A2)       ; was $FF  ;set to pointer crap

 'gotit
  MOVE.l A2,D2

 'skip4
  CMP.l #newtype_byte,D2
   BEQ.w 'byte

 'skip4a
  ADDQ.w #1,typelen
  BCLR #$0,typelen+1

 'byte
  MOVEQ.l #$00,D3
  MOVEA.l D2,A2
  MOVE.l A2,prevtype
  MOVE.w $8(A2),D3
  MOVEA.l (A7)+,A2
  MOVE.l D2,$A(A2)
  MOVEQ.l #$00,D4
  MOVE.w typelen,D4
  MOVE.w D4,$4(A2)
  BTST #$0,flagmask+1
   BEQ.w 'skipz
  MOVEQ.l #$04,D3

 'skipz
  CMP.w #$5B,D0            ;'['
   BNE.w 'skipzz
  ;
  ;get constant value!
  ;
  MOVEM.l D3-D4/A2,-(A7)
   BSR.w evalconst3
  CMP.w #$5D,D0            ;']'
   BNE.w JUMP_syntaxerr
  TST.w D6
   BNE.w JUMP_fpconerr
  MOVE.l D3,D1
  MOVEM.l (A7)+,D3-D4/A2
   JSR get1bytemain
  MOVE.w D1,$8(A2)
  MULU.l d1,d3                                             ;>32k fix was mulu.w
  ORI.w #$2,flagmask

 'skipzz
  ADD.l D3,D4
  ; new >
  CNIF #types64
    CMP.l #65532,d4
  CELSE
    CMP.l #32764,d4
  CEND
  ; < new
  ; cmp.l   #32768,d4       ; org source
  BCC JUMP_toolongerr
  MOVE.w flagmask,$6(A2)
  MOVE.w D4,typelen
RTS


JUMP_badenderr  JMP badenderr
JUMP_noiferr    JMP noiferr
JUMP_toolongerr JMP toolongerr
JUMP_fpconerr   JMP fpconerr


doendif3:
  MOVE.l firstiff,D0
   BEQ.w JUMP_noiferr
  MOVEA.l D0,A0
  MOVE.w $C(A0),D0
  ANDI.w #$FF,D0
  CMP.w D0,D1
   BNE.w JUMP_badenderr

doendif2:
  CMP.w #$1,D1
  BNE.w 'calcbra
  ;put in while bra
  MOVE.w #$6000,D1
  ; new >
  CNIF #longbranch
    TST.b fast
    BEQ 'l1
    OR.l #$ff,d1
  CEND

 'l1
  ; < new
  BSR.w writeword
  MOVEA.l destpointer,A1
  MOVE.l $4(A0),D1
  SUB.l A1,D1
  ; new >
  CNIF #longbranch
    TST.b fast
    BEQ 'l2
    BSR writelong
  BRA 'calcbra
  CEND

 'l2
  ; < new
  BSR.w writeword

 'calcbra
  MOVEA.l $8(A0),A1                                        ;write if branch destination
  MOVE.l destpointer,D1
  SUB.l A1,D1
  ; new >
  CNIF #longbranch
    TST.b fast
    BEQ 'l3
    ADDQ.l #4,D1
    MOVE.w dontwrite_nomemleft,D0
    BNE.w 'skip
    MOVE.l d1,-$4(a1)
  BRA 'skip
  CEND

 'l3
  ; < new
  ADDQ.l #2,d1
  ; new >
  TST.w dontwrite_nomemleft
  ;< new
  BNE 'skip
  ; new >
  CMP.l #MinWordSgnd,D1
  BCC.w JUMP_bigiferr
  ; < new
  MOVE.w D1,-$2(A1)

 'skip
RTS

JUMP_bigiferr JMP bigiferr


.do_Wend:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

dowend2:
  MOVEQ.l #$01,D1
BRA.w doendif

.mydo_Endif2:
  ;bsr.w bakup
  MOVE.w oldqflag,instringon
  MOVEA.l lastsourcepos,A5

mydoendif:
  MOVEQ.l #$00,D1

doendif:
  BSR.w doendif3
  BSR.w freetheifz
JMP get1bytemain


freetheifz:
  MOVE.l (A0),firstiff
  MOVEA.l A0,A1
  MOVEQ.l #$0E,D0
  MOVEA.l _execbase,A6
  ;jmp freemem(a6)
  ; new >
  MOVE.l mempool,a0
JMP _FreePooled(A6)
  ; < new


JUMP_modeerr JMP modeerr
JUMP_interr3 JMP interr3
JUMP_interr JMP interr


doend2:
  JSR get1bytemain

.do_end:
  BEQ.w 'done
  ; new >
  CMP.l #"noa7",-1(a5)
  BNE 'l1
  JSR get1bytemain
  JSR get1bytemain
  JSR get1bytemain
  MOVE.w #$3a,lastchar
 BRA 'done

 'l1
  CMP.w #"d0",-1(a5)
  BNE 'l2
  MOVE.b #1,returncode
  CLR.w lastchar
 BRA 'done

 'l2
  CMP.w ##TokenID_Object,d0
  BNE 'loop
  JSR skiprest
 RTS
  ; < new

 'loop
  BSR.w 'doend3
  JSR reget
  BNE.w 'loop
 RTS

 'doend3


  CMP.w ##TokenID_NEWTYPE,D0        ; was #$8001 / -$7FFF
  BNE.w 'nottype
    MOVE.w linemode,D1
    BNE.w JUMP_modeerr
      ADDQ.w #1,typelen
      BCLR #$0,typelen+1
      MOVEA.l thistype,A0
      MOVE.w typelen,$8(A0)
      MOVE.w #$FFFF,linemode        ; was -1
       JMP get1bytemain
 'nottype

  CMP.w ##TokenID_If,D0    ; was #$800b
  BEQ.w mydoendif

; 'notif
  CMP.w ##TokenID_While,D0    ; was #$800c
   BEQ.w dowend2

; 'notwhile
  CMP.w ##TokenID_Statement,D0    ; was #$8008
   BNE.w 'notstate

 'state
  ;end of statement/function processing!
  ;
 BRA.w endstate

 'notstate
  CMP.w ##TokenID_Function,D0        ; was #$8009
  BNE.w 'notfunc
  ; new >
  TST.b fpu
  BEQ 'nof
    MOVEA.l currentfunction,A0
    CMP.l #0,a0
    BEQ 'nof
    CMP.b #5,$5(a0)
    BNE 'nof
    MOVE.l #$f23c5000,d1                           ;fmove.w #-1,fpx
    BSR writelong
    MOVE.w #0,d1
    BSR writeword
 'nof
    ; < new
    MOVE.w #$7000,D1                                         ;end function moveq #0,d0
    BSR.w writeword
    MOVEA.l currentfunction,A0
    ; new >
    CMP.l #0,a0
    BEQ 'state
    MOVE.l destpointer,d1
    SUB.l $e(a0),d1
    MOVE.l d1,isfunc+1(a0)
    ; < new
    CMPI.b #$7,$5(A0)
    BNE.w 'state
    MOVE.w putstlen,D1
    BSR.w writeword
    BRA.w 'state

 'notfunc
  CMP.w ##TokenID_SetInt,D0         ; was #$8000+48
   BNE.w 'notsetint
  ;
  MOVE.w proceduremode,D1
   BNE.w JUMP_interr3
  ;
  TST.b debugmode
   BEQ.w 'norerrf1
  ;
  MOVEQ.l #$03,D1
   JSR writetrap
  ;
  MOVE.w dontwrite_nomemleft,D1
   BNE.w 'norerrf1
  ;
  MOVEA.l intcleanat,A0
  MOVE.l destpointer,(A0)
  ;
  MOVE.w #$C30C,D1       ; was #gouse
   BSR.w Atokejsr        ;for runerrlib stack chex

 'norerrf1
  MOVE.w intstring,D1
   BEQ.w JUMP_interr
   BPL.w 'nosp
  ;
  MOVE.w intlevel,D1
  ORI.w #$7200,D1
   BSR.w writeword       ;moveq #level,d1
  MOVE.w #$C103,D1       ; was #oldint,
   BSR.w Atokejsr
  CLR.w intlevel

 'nosp
  CLR.w intstring
  ;
  MOVE.l intfin,D1
   BSR.w writelong
  ;
  MOVE.l #$70004E75,D1
   BSR.w writelong
  ;
  MOVE.w dontwrite_nomemleft,D1
   BNE.w 'sintdone
  MOVEA.l intjmpat,A0
  MOVE.l destpointer(PC),(A0)

 'sintdone
 JMP get1bytemain

 'notsetint
  CMP.w ##TokenID_Select,D0   ; was #$800e     ;end select?
   BEQ.w doendsel
  CMP.w ##TokenID_SetErr,D0  ; was #$8001+tnum
   BNE.w 'notseterr
 JMP doendseterr

 'notseterr
  ;
 JMP syntaxerr

 'done
  TST.w direct_mode
  BNE.w JUMP_baddirerr
  MOVE.w #$C800,D1      ; #endjmp
  JSR Atokejsr          ; was bra org source                                  ;end
  ; new >
  CMP.l #"noa7",-4(a5)
  BNE 'l10
  TST.w dontwrite_nomemleft
  BNE 'l10
  MOVE.l destpointer,d1
  SUBQ.l #4,d1
  MOVE.l a0,-(a7)
  MOVE.l d1,a0
  MOVE.l (a0),a0
  MOVE.l #$60000002,(a0)+
  MOVE.w #$588f,(a0)
  MOVE.l (a7)+,a0

 'l10
RTS
  ; < new


.do_Stop:
  TST.w direct_mode                                            ;stop
  BNE.w JUMP_baddirerr
  ; new >
  MOVE.w d0,d1
  BEQ 'l10
  CMP.b #$3a,d0
  BEQ 'l10
  JSR get1bytemain

 'l10
  ; < new
  TST.b debugmode
  BEQ.w newstop
  MOVE.w #$D501,D1
BRA.w Atokejsr


; new >
newstop
  CNIF #stopignore
    RTS
  CEND
  MOVE.w d1,d0
  BEQ 'l10
  CMP.b #$3a,d0
  BEQ 'l10
  SUB.b #$30,d0
  MOVE.w #$4e40,d1
 BRA 'l11

 'l10
  MOVE.w #$4e4a,d1
  JMP writeword

 'l11
  ADD.b d0,d1
JMP writeword
; < new

.do_Cont:
JMP badconterr        ;cont not currently supported!

;n_o_p:                ; was nop org source ; ??? looks like not used ???
;  MOVE.w #$4E71,D1
;BRA.w writeword



freefors:
  MOVEA.l firstfor,A2
  CLR.l firstfor
  MOVEA.l _execbase,A6

 'loop
  CMPA.w #$0,A2
  BEQ.w 'done
  MOVEA.l A2,A1
  MOVEA.l (A1),A2
  MOVEQ.l #$00,D0
  MOVE.b $10(A1),D0
  ;jsr freemem(a6)
  ; new >
  MOVE.l mempool2,a0  
  JSR _FreePooled(A6)                                      ;freememfor_error
  ; < new
 BRA.w 'loop

 'done
RTS


JUMP_badpenderr JMP badpenderr
JUMP_noenderr   JMP noenderr

endstate:                                                 ;End Statement
    ;
    ;first, fill in any FUNCTION RETURN type shit.....
    ;
  MOVE.w proceduremode,D1
   BEQ.w JUMP_badpenderr
  ;
  MOVE.w dontwrite_nomemleft,D1
   BNE.w 'ship
  MOVEA.l firstpend,A2

 'loop0
  CMPA.w #$0,A2
   BEQ.w 'ship
  MOVEA.l $4(A2),A0
  MOVE.l destpointer,(A0)
  MOVEA.l (A2),A2
 BRA.w 'loop0

 'ship
  TST.b debugmode
   BEQ.b 'ship2
  ;
  MOVEQ.l #$05,D1
  JSR writetrap

 'ship2
  MOVEA.l firstlocal,A2                                    ;firstlocal
  JSR calcstatic2b                                           ;calcstatic
  MOVEA.l currentfunction,A0
  ; new >
  MOVE.l destpointer,d1
  SUB.l $e(a0),d1
  MOVE.l d1,isfunc+1(a0)                                   ;store function size
  ; < new
  MOVE.w D4,$8(A0)                                         ;set if memalloc need
  MOVE.l D3,locdatast
  MOVEA.l tempvm,A1
  ; new >
  CLR.b infunctioncode
  MOVE.l firstiffstore,d1
  CMP.l firstiff,d1
  BNE JUMP_noenderr
  ; < new
  TST.w $C(A1)                                             ;dim
   BPL.w 'nolskip
 BSET #$7,$8(A0)
  MOVE.w #$C005,D1      ;#freelast,
   BSR.w tokejsr2                                          ;writefreememstatement
 BRA.w 'lskip2

 'nolskip
  MOVE.w memlibstat,$C(A1)

 'lskip2
  MOVEA.l currentfunction,A0
  MOVE.l $E(A0),-(A7)
  MOVE.w locvaroff,$6(A0)
  BCLR #$1,$7(A0)
  BCLR #$0,$7(A0)
  CMPI.b #$7,$5(A0)
  BNE.w 'penis
    MOVE.w getstlen,D1
    JSR writeword
 'penis
  TST.w $6(A0)
  BEQ.w 'nolink
    MOVE.w #$FC7B,D1   ;#64635  clrlib
    JSR uselib
    MOVE.w unlinka4,D1
    JSR writeword
 'nolink
  ;
  ;fix the stacked string lengths!
  ;
  MOVEA.l currentfunction,A0
  MOVEQ.l #$00,D1
  MOVE.b $4(A0),D1
  LSR.w #4,D1
   BEQ.w 'nofix
  ; new >
  CNIF #more6string
     LSL.w #1,d1
  CEND
  ; < new
  CMP.w #$1,D1
   BNE.w 'not1
  MOVE.w fix1,D1
   JSR writeword
 BRA.w 'nofix

 'not1
  LSL.w #2,D1
  MOVE.w D1,-(A7)
  MOVE.w D1,moverts+2
  MOVE.l moverts,D1
   JSR writelong
  MOVE.w (A7)+,D1
  CMP.w #$8,D1
   BHI.w 'fix
  ANDI.w #$7,D1
  LSL.w #8,D1
  LSL.w #1,D1
  OR.w fixq,D1
   JSR writeword
 BRA.w 'nofix

 'fix
   MOVE.w D1,fixstack+2
  MOVE.l fixstack,D1
   JSR writelong

 'nofix
   BSR.w normret
  ;
  ;put in the setup stuff here!
  ;
   BSR.w procfixer
  ;
  MOVEA.l (A7)+,A0
  MOVE.w dontwrite_nomemleft,D1
   BNE.w 'skipjp
  MOVE.l destpointer,-(A0)

 'skipjp
  CLR.w proceduremode
  CLR.l currentfunction
  CLR.w procnum
   BSR.w droplocals
   JSR freepends
JMP get1bytemain


droplocals:
  MOVEQ.l #$0C,D0
  MOVEQ.l #$01,D1
  MOVEA.l _execbase,A6
   ;jsr do_AllocMem
  ; new >
  MOVE.l mempool,a0
  JSR _AllocPooled(a6)
  ; < new
  MOVEA.l D0,A0
  MOVE.l alllocals,(A0)
  MOVE.l A0,alllocals
  ;
  MOVE.l firstlocal,D0
  CLR.l firstlocal
  MOVE.l D0,$4(A0)
  MOVE.l firstglob,D1
  CLR.l firstglob
  MOVE.l D1,$8(A0)
  ;
  TST.b debugmode
   BEQ.b 'skip
  TST.w dontwrite_nomemleft
   BNE.b 'skip
  ;
  MOVEA.l proclocals(PC),A0
  MOVE.l D0,(A0)+
  MOVE.l D1,(A0)

 'skip
RTS


JUMP_baddirerr JMP baddirerr
JUMP_noforerr  JMP noforerr


.do_next:
  TST.w direct_mode
   BNE.w JUMP_baddirerr
  MOVE.l firstfor,D1
   BEQ.w JUMP_noforerr
  JSR reget
   BEQ.w 'unknown
  ;
  ;here, we've got 'Next Var[,Var...]'
  ;

 'nextnext
  BSR.w getparameter
  MOVEA.l firstfor(PC),A2
  MOVEQ.l #$00,D1
  MOVE.b $10(A2),D1
  SUBI.w #$12,D1
  CMP.w D1,D2
   BNE.w JUMP_noforerr
  LEA ptr_parameterstore(PC),A0
  LEA $11(A2),A1
  SUBQ.w #1,D2

 'chkname
    CMPM.b (A0)+,(A1)+
    BNE.w JUMP_noforerr
  DBF D2,'chkname

   BSR.w 'unknown2
   JSR reget
   BEQ.w 'byebye
  CMP.w #$2C,D0           ; ','
   BNE.w JUMP_syntaxerr
   JSR get1bytemain
 BRA.w 'nextnext

 'byebye
 RTS

  ; new >
 'fpu2dats
  MOVE.l 8(a7),a2
  Dc.l  $f2124400                                          ;fmove.s (a2),fp0
  Dc.l  $F2174422                                          ;fadd.s (a7),fp0
  Dc.l  $F2126400                                          ;fmove.s fp0,(a2)
 'fpu2date
  ; < new

 'unknown
  MOVEA.l D1,A2

 'unknown2
  JSR popnext                                           ;error checking for next.
  MOVE.w $C(A2),D0
  ;
  LEA nextb,A0
  LEA nextbf,A1
  CMP.w #$1,D0
   BEQ.w 'donext
  LEA nextw,A0
  LEA nextwf,A1
  CMP.w #$2,D0
   BEQ.w 'donext
  LEA nextl,A0
  LEA nextlf,A1
  CMP.w #$5,D0
   BNE.w 'donext
   ; new >
   TST.b fpu
   BEQ 'old
   LEA 'fpu2dats,a0                                         ;fpu next code
   LEA 'fpu2date,a1
 BRA 'donext

 'old
  ; < new
  MOVE.w #$C900,D1     ; #getffpbase
   BSR.w Atokejsr
  LEA nextf,A0
  LEA nextff,A1

 'donext
  JSR pokecode
  ; new >
   TST.b fast                                             ;fast for next deactivate
 BRA 'l1
                                                           ;??Looks like dead code??
    TST.b onestep
    BEQ 'l1
    CLR.b onestep
    SUBQ.l #4,destpointer
    MOVE.w #$5292,d1
    JSR writeword

 'l1
  ; < new
  MOVE.l thebra(PC),D1
   JSR writelong
  ;
  MOVEA.l firstfor,A2
  MOVE.l (A2),firstfor
  ;
  ;pass2, o.k. to put in my BRA's!
  ;
  MOVEA.l $8(A2),A0
  MOVEA.l destpointer,A1
  MOVE.l A1,D1
  SUB.l A0,D1            ;d1=positive bra
  ADDQ.l #2,D1
  CMP.l #MinWordSgnd,D1  ; #32768,
   BCC.w JUMP_bigforerr
  TST.w dontwrite_nomemleft
   BNE.w 'nopoke1
  MOVE.w D1,-$2(A0)

 'nopoke1
  MOVE.l A1,D1
  SUB.l $4(A2),D1
  SUBQ.l #6,D1
  CMP.l #MinWordSgnd,D1 ;#32768,
   BCC.w JUMP_bigforerr
  TST.w dontwrite_nomemleft
   BNE.w 'skip
  NEG.w D1
  MOVE.w D1,-$2(A1)

 'skip
  JSR popnext3                ;fix stack
  ;
  MOVEA.l _execbase,A6
  MOVEA.l A2,A1
  MOVEQ.l #$00,D0
  MOVE.b $10(A1),D0
  ;jsr freemem(a6)
  ; new >
  MOVE.l mempool2,a0
  JSR _FreePooled(A6)
  ; < new
JMP reget


JUMP_notallowd JMP notallowd
JUMP_bigforerr JMP bigforerr


forset:
  MOVE.w #$664F,-(A7)          ;#'fO',

thebra:                                                      ;??
 BRA.w thebra


JUMP_error_dublicate_for JMP error_dublicate_for
JUMP_badforerr           JMP badforerr


forlineat:   Ds.l 1
fortemp:     Ds.w 1


.do_for:
  ;
  ;For var = START To FINISH [Step INCREMENT]
  ;
  ; new >
  CLR.l fp0addr
  ; < new
  TST.w direct_mode
  BNE.w JUMP_baddirerr

  MOVE.l linenumat,forlineat
  ;
  ;new stuff!
  ;
  MOVE.l A5,letstart
  BSR.w getparameter
  MOVE.w D2,fortemp
  ;
  JSR findfor
  BEQ.w JUMP_error_dublicate_for

  LEA firstfor,A2
  JSR addhere2
  MOVE.l A2,-(A7)

  TST.b debugmode
  BEQ.b 'noerr
    JSR chkstak
    MOVE.l forset,D1
    JSR  writelong
 'noerr
  MOVE.w fortemp(PC),D2
  ; new >
  MOVE.b #1,formode
  ; < new
  BSR.w dolet2                                         ;for get 1. value
  CLR.b formode

  CMP.w ##TokenID_To,D0       ; was #$8018,
    BNE.w JUMP_syntaxerr
  MOVE.w commode,D1
    BNE.w JUMP_syntaxerr
  CMP.b #$6,D2
    BCC.w JUMP_badforerr

  BTST #$F,D2
  BNE.w 'skip
    MOVE.w leaamp,D1
    JSR pokewda5s
    MOVE.w D3,D1
    JSR  writeword
 'skip

  MOVE.w pushindex,D1
  JSR  writeword         ;index lea on stack
  ANDI.w #$FF,D2

  MOVEA.l (A7),A1
  MOVE.w D2,$C(A1)
  ;
  MOVE.w D2,-(A7)
  BSR.w eval             ;get fin
  ; new >
  CLR.b onestep
  CMP.w ##TokenID_Step,d0
  BEQ 'l1
    MOVE.b #1,onestep
 'l1
  ; < new
  MOVE.w (A7),D2
  ;
  MOVE.w pushd0l,D1
  CMP.w #$3,D2
  BCC.w 'skip1
    MOVE.w pushd0wd,D1
 'skip1
  MOVE.w D1,-(A7)
  ; new >
  TST.b fpu
  BEQ 'old
    CMP.b #5,d2
    BNE 'old
      MOVE.l #$f2276400,d1
      ;MOVE.l #$f2277400,d1
      JSR writelong
      BRA 'weit
 'old
  ; < new
    JSR  writeword        ;push fin on stack                                   ;fpu for end value

 'weit
  CMP.w ##TokenID_Step,D0      ; was #$8019,
    BNE.w 'defstep
      ;
      BSR.w eval           ;get step
      ; new >
      TST.b fpu
      BEQ 'pushstep
        CMP.b #5,d2
        BNE 'pushstep
          MOVE.l #$f2276400,d1                                    ;write step <> 1
          ;MOVE.l #$f2277400,d1                                    ;write step <> 1
          JSR writelong
          ; < new
          ; BRA.w 'pushstep
          ; < new
          MOVE.w (a7)+,d1
          BRA 'fpur
          ; < new
 'defstep
  CMP.w #$4,D2
  BCC.w 'qup
    MOVE.w #$7001,D1
    JSR writeword
    BRA.w 'pushstep
 'qup
    BNE.w 'notq
    MOVE.w #$7001,D1
    JSR writeword
    MOVE.w swapd0,D1
    JSR writeword
    BRA.w 'pushstep

 'notq
  ; new >
  TST.b fpu
  BEQ 'old2
  CMP.b #5,d2
  BNE 'old2
    MOVE.l #$f23c5000,d1                                    ;fmove.w #-1,fpx
    JSR writelong
    MOVE.w #$1,d1
    JSR writeword
    MOVE.l #$f2276400,d1
    JSR writelong
    MOVE.w (a7)+,d1
    BRA 'fpur
 'old2
    ; < new
    MOVE.w #$203C,D1                                         ;write step 1
    JSR writeword
    MOVE.l #$80000041,D1     ;ffp '1'                                ;ffp '1'
    JSR writelong

   'pushstep
    MOVE.w (A7)+,D1
    JSR writeword           ;push step on stack                                 ;push step on stack

  ; new >
 'fpur
  ; < new
  MOVE.w (A7)+,D2
  MOVEA.l (A7),A1
  MOVE.l destpointer,$4(A1)
  LEA forcompb,A0
  LEA forcompbf,A1
  CMP.w #$1,D2
  BEQ.w 'docomp

  LEA forcompw,A0
  LEA forcompwf,A1
  CMP.w #$2,D2
  BEQ.w 'docomp

  LEA forcompl,A0
  LEA forcomplf,A1
  CMP.w #$5,D2
  BNE.w 'docomp

  ; new >
  TST.b fpu
  BEQ 'old3
    LEA fpu_start,a0
    LEA fpu_end,a1
    JSR pokecode
    BRA 'fpu3
 'old3
  ; < new
  LEA forcompf,A0                                         ;
  LEA forcompff,A1
  JSR pokecode
  MOVE.w #$C900,D1       ; #getffpbase,
  BSR.w Atokejsr
  LEA forcompf2,A0
  LEA forcompf2f,A1

 'docomp
  JSR pokecode
  ; new >
  TST.b fast                                               ;fast for next
  BEQ 's1
    CMP.w #3,d2
    BNE 's1
      TST.b onestep
      BEQ 's1
        SUB.l #10,destpointer
        MOVE.w #$b081,d1
        JSR writeword
 's1                                                       ;??Looks like double label??
 'fpu2
  ; < new
  MOVE.l thebgt(PC),D1
  JSR writelong

  ; > new
 'fpu3
  ; < new
  MOVEA.l (A7)+,A1
  MOVE.l destpointer,$8(A1)
JMP reget


; new >
fpu_start
  MOVEA.l 8(a7),a2
  Dc.l $f2124400                                           ;fmove.s (a2),fp0
  fmove.s 4(a7),fp1
  BTST.b #7,(a7)
  BNE 'negi
    fcmp.x fp1,fp0
    BRA 'negi2
 'negi
    fcmp.x fp0,fp1
 'negi2
  Dc.l $f2920000                                           ;fbgt.w
fpu_end                                                   ;??Looks like double label??
; < new


thebgt:
  BGT.w thebgt


JUMP_error4char          JMP error4char
JUMP_error_convert_types JMP error_convert_types
JUMP_noleterr            JMP noleterr
JUMP_nocomerr            JMP nocomerr
JUMP_comerr              JMP comerr


.do_let:
  MOVE.l A5,letstart
  JSR getparameter

dolet2:
  ; new >
 'varassign
  MOVE.l destpointer,pushpc
  MOVE.l hunkoffsetbase,pushoff
  CLR.l rightsidetype
  CLR.w rightsideflagmask
  ; < new
  MOVE.w #$0001,regnum            ;don't disturb this reg!
  JSR fetchvars                   ;var in a3, type in a2
  JSR calcvar                     ;get offset stuff
  ; new >
  TST.b formode
  BEQ 'lf1
    CMP.l #newtype_double,A2
    BEQ JUMP_notallowd

    MOVE.l a2,currtype
 'lf1
  CLR.w startoffsetmore
  CMP.w #$3d,d0
  BNE 'l1a
    BTST #15,d2
    BEQ 'l1a
      CMP.b #1,d2
      BNE 'l1a
        MOVE.w leaa0a0+2,startoffsetmore
 'l1a
  ; < new
  CLR.w regnum                     ;don't disturb this reg
  BSR.w pushdo
  CLR.w commode
  ; new >
  CLR.w stackcorrect
  ; < new
  CLR.w pcodd
  ; new >
  MOVE.w startoffsetmore,d1

  BTST #0,d1
  BEQ 'l2a
    MOVE.w #1,pcodd
 'l2a
  ; < new
  ;
  CMP.w #$3D,D0              ;'='                              ;=
  BEQ.w 'nextcom
    ; new >
   'l1
    MOVE.b (a5)+,d1
    BEQ 'l10
      CMP.b #":",d1
      BEQ 'l10
        CMP.b #";",d1
        BEQ 'l10
          CMP.b #"0",d1
          BLT 'l11
            CMP.b #"9",d1
            BGT 'l11
              BRA.s 'l1
   'l10
    MOVE.b #1,quickadd
   'l11
    ; < new
    ;
    ;move char to start of var name!
    ;
    MOVEA.l letstart,A5
    SUBQ.w #1,A5
 'nextcom
  CMP.b #$7,D2
  BNE.w 'notstring
  ; new >
  ;   TST.b infunctioncode
  ;   BEQ 'l12
  ;   MOVE.b #1,addmemcode

  ; 'l12
  ; < new
  ;
  ;string get!
  ;
  MOVEM.w D2-D3,-(A7)
  MOVE.l lastoffset_org,-(A7)
  MOVE.w varmode,-(A7)
  ; JSR setsvars          ;!@!
  ; new >
  MOVE.l #forthstack,forthsp
  MOVE.l #precstack,precsp
  CLR.w regnum
  CLR.w nonew
  CLR.w sbasegot
  MOVE.w varcodelen,oldvcodelen
  CLR.w varcodelen
  MOVE.w #$FFFF,lasta6

 ;end 457a
 ; < new
  MOVEQ.l #$07,D2
  JSR eval
  MOVE.w (A7)+,varmode
  MOVE.l (A7)+,lastoffset_org
  MOVE.w moved0a3,D1
  JSR writeword

  MOVE.w commode,D1
  BEQ.w 'stconti
    LEA pulla2st,A0
    LEA pulla2stf,A1
    JSR pokecode
    BRA.w 'stconti2
 'stconti
    BSR.w pushput
 'stconti2
    MOVEM.w (A7)+,D2-D3
    BTST #$F,D2
    BNE.w 'already
      MOVE.w D3,leaa5d3a2+2
      MOVE.l leaa5d3a2,D1
      JSR pokela5s
   'already
    MOVE.w #$FE6F,D1         ; was #65135, string2lib
    JSR uselib
    MOVE.l #$C700,D1         ; was #lastring,
    MOVE.l d1,lastinstruction
    MOVE.w varmode,D2
    BNE.w 'local
      ADDQ.w #1,D1           ;use global allocmem
 'local
  BSR.w Atokejsr
  CMP.w #$2C,D0           ;','
  BNE.w 'done

  MOVE.w addq4a2,D1
  JSR writeword
 BRA.w 'nextstr

 'notstring
   BTST #$E,D2             ;pointer, ignore!
   BNE.w 'skip
  TST.b D2
   BEQ.w JUMP_noleterr     ;tried to assign a struct - later!
  ; new >
   TST.b newsyntax
   BEQ 'skip2

 'atmode
  CMP.w #$4022,(a5)
  BNE 'skip2
  CMP.l #3,d2
  BNE  JUMP_error_convert_types
  ADDQ #2,a5
  MOVEQ #0,d0
  MOVE.b (a5)+,d0
  BEQ 'skip2
  CMP.b #$22,d0
  BNE 'l5
  MOVE.b #0,d0
  BRA 'do

 'l5
  ASL.l #8,d0
  MOVE.b (a5)+,d0
  BEQ 'skip2
  CMP.b #$22,d0
  BNE 'l2
  MOVE.b #0,d0
  ASR.l #8,d0
  BRA 'do

 'l2
  ASL.l #8,d0
  MOVE.b (a5)+,d0
  BEQ 'skip2

  CMP.b #$22,d0
  BNE 'l3
    MOVE.b #0,d0
    ASR.l #8,d0
    BRA 'do
 'l3
    ASL.l #8,d0
    MOVE.b (a5)+,d0
    BEQ 'skip2
    CMP.b #$22,d0
    BNE 'l4
      MOVE.b #0,d0
      ASR.l #8,d0
      BRA 'do
   'l4
    CMP.b #$22,(a5)+
    BNE JUMP_error4char
 'do
    MOVE.w #$2b7c,d1
    TST.w varmode
    BEQ 'g3
      BCLR #9,d1
   'g3
    JSR writeword
    MOVE.l d0,d1
    JSR writelong
    MOVE.w d3,d1
    JSR writeword
    JSR get1bytemain
    RTS
 ; < new

; BRA.w 'skip2                                            ;??Looks like dead code??

 'skip
  ; new >
  MOVE.w d2,vartype
  ; < new
  MOVE.b #$3,D2

 'skip2
  ;
  ;let's get what is to be assigned.....
  ;
  ; new >
  CMP.b #5,d2
  BNE 'l1aa
  MOVE.l a2,currtype

 'l1aa
  ;MOVE.l currtype,-(a7)
  ; < new
  MOVEM.w D2-D3,-(A7)
  MOVE.w varmode,-(A7)
  ; new >
  MOVE.l a2,leftsidetype
  MOVE.w flagmask,leftsideflagmask
  BTST #$f,d2
  BEQ 'nomultiassign
  CLR.l leftsidetype                        ;its multiassign to type entries so no typecheck need
  CLR.w leftsideflagmask

 'nomultiassign
  ; < new
  ANDI.w #$FF,D2
  MOVE.l lastoffset_org,-(A7)
  JSR eval                                ; calc right side of var assign
  ; new >
  MOVEM.l a0/a1,-(a7)
  MOVE.l leftsidetype,a0
  CMP.l #0,a0
  BEQ 'nocheck
  CMP.w #1,leftsideflagmask
  BEQ 'isptr
  CMP.l #$100,4(a0)
  BLE 'nocheck

 'isptr
  TST.l typetocast
  BEQ 'nocast
  MOVE.l typetocast,a1
  BRA 'typecheck

 'nocast
  TST.l rightsidetype
  BEQ 'nocheck
  MOVE.l rightsidetype,a1
  CMP.w #1,rightsideflagmask
  BEQ 'ok
  CMP.l #$100,4(a1)
  BGE 'typecheck
  CMP.l #$3,4(a1)
  BEQ 'ok                              ;long assign is allow with this codelines
  BRA 'error

 'typecheck
  TST.b typecheck
  BEQ 'nocheck
  TST.b notypecheck
  BNE 'ok
  CMP.l a0,a1
  BEQ 'ok
                                    ; check if type is parent for var assign
  MOVE.l 4(a1),a1                   ; load the address of 1. type.
  CMP.l $a(a1),a0                   ; check if the bigger type contain in first place same type as the function need
  BEQ 'ok

 'error
  JMP   error_convert_types     ;for SYNTAX 4  = typecheck

 'ok
 'nocheck
   CLR.l typetocast
   MOVEM.l (a7)+, a0/a1
  ; < new
  MOVE.l (A7)+,lastoffset_org
  MOVE.w commode,D1
   BNE.w 'conti
   BSR.w pushput

 'conti
  MOVE.w (A7)+,varmode
  MOVEM.w (A7)+,D2-D3
  ;
  ; new >
  ;MOVE.l (a7)+,currtype
  ; < new
  MOVE.w #$2B40,D1
  MOVE.w varmode,D4
   BEQ.w 'skip1
  BCLR #$9,D1

 'skip1
  BTST #$F,D2
   BEQ.w 'code
  ;
  ; new >
   TST.b stackcorrect
   BNE 'st1
  ; < new
  MOVE.w commode,D1
   BEQ.w 'skipc1

  ; new >
 'st1
  ; < new
  MOVE.w pulla2,D1
   JSR writeword

 'skipc1
  MOVE.w #$2480,D1               ;move.l d0,(a2)
  ;
  ; new >
   MOVEM.l a0/d0,-(a7)
   MOVEA.l lastoffset_org,A0
   MOVE.l A0,D0
   BEQ.w 'skipa
   MOVEA.l D0,A0
   MOVE.l $A(A0),currtype

 'skipa
  MOVEM.l (a7)+,a0/d0
  ; < new
  CMP.w #$2C,D0                ; ','
   BNE.w 'code
  ;
    MOVE.w #$24C0,D1           ;move.l d0,(a2)+
   BSR.w 'code                                         ;write store

 'nextstr
   MOVE.l lastoffset_org,D0
   ;BEQ.w JUMP_nocomerr

  ; new >
 'dim1
  ; < new
  MOVE.w #$FFFF,commode    ; -1
  CLR.w varcodelen
  ; new >
  MOVE.b #1,optiarray
  ; < new
  MOVE.w pusha2,D1
   JSR writeword
  ; new >
  TST.l lastoffset_org
  BEQ 'dimmore
  MOVEA.l lastoffset_org,A0
  ; < new
  MOVE.l (A0),D0
   BEQ.w JUMP_comerr          ;comma past end of struct
  MOVEA.l D0,A0
  MOVE.l A0,lastoffset_org
  BTST #$1,$7(A0)
   BNE.w JUMP_nocomerr        ;can't use comma on multiple entries
  MOVEA.l $A(A0),A1
  MOVE.l $4(A1),D2
  ; new >
 'dimlet
  ; < new
  BTST #$0,$7(A0)
   BNE.w 'nextpnt             ;pointer
  CMP.l #$100,D2
   BCC.l JUMP_nocomerr        ;or on structs
 BRA.w 'docom                                     ; do do type\x= 10,20,30....

  ; new >
 'dimmore
  CLR.b optiarray
  CMP.w #"@@",(a5)
  BEQ 'n1
    BRA 'd1
 'n1
    JSR nextline
    MOVE.l a5,-(a7)

   'l6
      MOVE.b (a5)+,d0
      CMP.b #$20,d0
    BEQ 'l6
    MOVE.l (a7)+,a5
  CMP.b #";",d0
  BEQ 'n1
 'd1

  TST.w debugmode
  BEQ 'nextcom

  MOVE.l a0,-(a7)
  MOVE.l pushat,a0
  CMP.l #0,a0
  BNE 'o1
    BRA 'skipb
 'o1
    ADD.l #1,2(a0)
 'skipb

  CLR.w commode
  MOVE.b #1,stackcorrect
  MOVE.l (a7)+,a0
  JMP 'nextcom
  ; < new

 'nextpnt
  CMP.l #$100,D2
  BCS.w 'nextpnt2
    MOVEQ.l #$00,D2
 'nextpnt2

  BSET #$E,D2

 'docom
  BSET #$F,D2
  BRA.w 'nextcom

  ; new >
 'farr                                     ; ??? look like not used ???
  MOVE.l destpointer,a4                   ;
  MOVE.l #$f22a6400,-4(a4)                ;
  MOVE.w arrayoffset,d1                   ;
  JMP writeword                             ;
  ; < new

 'code
  ;new >
  TST.b fpu
  BEQ 'nofloat

  CMP.b #5,d2                                              ; is it a float ?
  BNE 'nofloat

  CLR.w fp0var
  LEA regtable,a4
  TST.l (a4)
  BEQ 'noreg
  BTST #15,d2                                              ;regvars
  BNE 'noreg
  CMP.w 0+4(a4),d3
  BNE 'doreg1
  MOVE.l #$f2000380,d1
  MOVE.w regnum,d0
  BNE 'noopt
                                                           ;fmove.x fp0,fp7 should be added
                                                           ;optimize if code before is
                                                           ;fmove.x fp7,fp1
                                                           ;fadd.x fp1,fp0
    MOVE.l destpointer,a4
    CMP.l #$f2001c80,-8(a4)
    BNE 'noopt

    CMP.l #$f2000422,-4(a4)
    BNE 'noopt

    MOVE.l #$f20003a2,d1
    SUB.l #8,destpointer
 'noopt
  ASL.w #7,d0
  OR.w d0,d1
  JSR writelong
  RTS

 'doreg1
  CMP.w 8+4(a4),d3
  BNE 'doreg2
    MOVE.l #$f2000300,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    JSR writelong
    RTS
 'doreg2
  CMP.w 16+4(a4),d3
  BNE 'doreg3
    MOVE.l #$f2000280,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    JSR  writelong
    RTS
 'doreg3
  CMP.w 24+4(a4),d3
  BNE 'doreg4
    MOVE.l #$f2000200,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    JSR writelong
    RTS
 'doreg4
  CMP.w 32+4(a4),d3
  BNE 'noreg
    MOVE.l #$f2000180,d1
    MOVE.w regnum,d0
    ASL.w #7,d0
    OR.w d0,d1
    JSR writelong
    RTS
 'noreg

  TST.w regnum
  BNE 'nofp0

  MOVE.l destpointer ,a4
  CMP.l #$f2304400,-6(a4)
  BNE 'do5
    CMP.w #$1990,-2(a4)
    BNE 'do5
      BTST #15,d2                                             ;types ?
      BNE 'do5
        MOVE.l #$2b701990,d1                                     ;var

        TST.w varmode
        BEQ 'glob1
          BCLR #25,d1
       'glob1
        MOVE.l d1,-6(a4)
        MOVE.w d3,-2(a4)
        CLR.w fp0var
        MOVE.w #$ffff,fp0mode
        RTS
 'do5
  CMP.l #$f22d4400,-6(a4)                                 ;fmove.s (a5),fp0
  BNE 'do3
  CMP.l #newtype_double,currtype
  BEQ 'do4

 'nd1
  MOVE.w #$2b6d,d1
  TST.w varmode
  BEQ 'g2
    BCLR #9,d1
 'g2
  CMP.w #$2b6d,d1
  BNE 'd1a
    CMP.w -2(a4),d3
    BNE 'd1a
    SUBQ.l #6,destpointer
    BRA 'd12
 'd1a
    MOVE.w d1,-6(a4)                                       ;fmove.s to move.l mem,mem
    MOVE.w -2(a4),-4(a4)
    MOVE.w d3,-2(a4)
 'd12
    CLR.w fp0var
    MOVE.w #$ffff,fp0mode
    RTS

 'do3
  CMP.l #$f22c4400,-6(a4)                                  ;fmove.s (a4)
  BNE 'do4
    MOVE.w #$2b6c,d1
    TST.w varmode
    BEQ 'g3a
     BCLR #9,d1
   'g3a
    MOVE.w d1,-6(a4)
    MOVE.w -2(a4),-4(a4)
    MOVE.w d3,-2(a4)
    CLR.w fp0var
    MOVE.w #$ffff,fp0mode
    RTS
 'do4
  MOVE.w d3,fp0var
  MOVE.w varmode,fp0mode
  ADDQ.l #6,a4
  MOVE.l a4,fp0addr
  MOVE.l firstiff,fp0iff

 'nofp0
  MOVEM.l d0/d4,-(a7)
  MOVEQ #0,d0
  MOVE.w regnum,d0
  ASL.w #7,d0                                             ;fpu store var

  BTST #15,d2
  BEQ 'var

  MOVE.w d1,d4
  CMP.w #$24c0,d4
  BNE 'nopl
    MOVE.l #$f21a6400,d1
    MOVEQ #0,d3
    BRA 'glob
 'nopl
    ;MOVE.l #$f22a6400,d1                                    ;for newtype
    MOVE.l #$f2126400,d1
    TST.w d3                                                ;offset =0
    BNE 'offset
      MOVE.l #$f2126400,d1
      ;   CMP.w #$24c0,d4
      ;   BNE 'glob
      ;   MOVE.l #$f21a6400,d1                                    ;fmove.s fp0,(a2)+
      ; BRA 'glob
   'offset
    ;SUBQ.l #4,destpointer
    MOVEQ #0,d3
    BRA 'glob

 'var
    MOVE.l #$f22d6400,d1                                     ;var
    TST.w varmode
    BEQ 'glob
      BCLR #16,d1
 'glob
  OR.l d0,d1

 'weit
  CMP.l #newtype_double,currtype
  BNE 'dbl1
    OR.l #$00001000,d1
 'dbl1
  JSR writelong
  CLR.l currtype
  MOVEM.l (a7)+,d0/d4
  MOVE.l d3,d1
  BEQ 'nooffs
    JMP writeword
 'nooffs
RTS

;  CMP.l #$f2126400,-4(a4)
;  BEQ 'exit
;  CMP.l #$f21a6400,-4(a4)
;  BEQ 'exit
; BRA writeword

; 'exit
; RTS

;JMP writeword                                              ;??looks like dead code?

 'nofloat
    TST.b fast                                             ;write lea->xx(a2)
   BEQ 'la10
   CNIF #optibreak
     ILLEGAL
   CEND
   TST.b quickadd
   ;BNE 'lq1                                               ;to avoid bug
     CLR.b quickadd
   CMP.w #$2480,d1
   BNE 'la10
   TST.b optiarray
   BNE 'la10
   MOVE.l destpointer,a4
   CMP.w #$45ea,-4(a4)
   BNE 'la10
   CMP.w #8,pushclen
   BEQ 'la100
   CMP.w #6,pushclen
   BNE 'la10
   CMP.b #3,d2
   BCS 'la110
                                                           ;store value
   MOVE.w #$2540,-2(a4)
   MOVE.w arrayoffset,d1
 JMP writeword

 'lq1
   CLR.b quickadd
 RTS

 'la110
   CMP.b #2,d2
   BNE 'la120
    MOVE.w #$3540,-2(a4)
   MOVE.w arrayoffset,d1
 JMP writeword

 'la120
  CMP.b #1,d2
   BNE.s 'la10
    MOVE.w #$1540,-2(a4)
   MOVE.w arrayoffset,d1
 JMP writeword

 'la100
   CMP.b #3,d2
   BCS 'la11
   MOVE.w #$2540,-4(a4)
 RTS

 'la11
   CMP.b #2,d2
   BNE 'la12
    MOVE.w #$3540,-4(a4)
 RTS

 'la12
   CMP.b #1,d2
   BNE.s 'la10
    MOVE.w #$1540,-4(a4)
 RTS

 'la10
  CLR.b optiarray
   ; < new
   CMP.b #$1,D2
   BEQ.w 'byte
   BSR.w varalign
   CMP.b #$3,D2
   BCC.w 'writevarlong
   ; new >
   TST.b fast                                              ;optiimmi
   BEQ 'l10bc
   CNIF #optibreak
     ILLEGAL
   CEND

   MOVE.l destpointer,a0
   SUB.l imm_addr,a0
   CMP.l #4,a0
   BNE 'l10c
   CLR.l imm_addr
   MOVE.l destpointer,a4
   OR.w #$107c,d1
   MOVE.w d1,-4(a4)
    MOVE.w D3,D1
 JMP writeword

 'l10c
  MOVE.l destpointer,a0
  SUB.l load_var_addr,a0
  CMP.l #4,a0
  BNE 'l10bc
  CMP.w #$302d,-4(a4)                                      ;check 68k opcode
  BNE 'l10bc

  CLR.l load_var_addr
  MOVE.l destpointer,a4
  OR.w #$102d,d1
  MOVE.w d1,-4(a4)
  MOVE.w d3,d1
 JMP writeword

 'l10bc
  ; < new
  ORI.w #$1000,D1                                          ;word
 BRA.w 'writestorevar


 'byte
   ; new >
   TST.b fast                                              ;optiimmi
   BEQ 'l10bb
   CNIF #optibreak
     ILLEGAL
   CEND

   MOVE.l destpointer,a0
   SUB.l imm_addr,a0
   CMP.l #4,a0
   BNE 'l10d
   CLR.l imm_addr
   MOVE.l destpointer,a4
   OR.w #$7c,d1
   EORI #$3000,d1
   MOVE.w d1,-4(a4)
      MOVE.w D3,D1
 JMP writeword

 'l10d
  MOVE.l destpointer,a0
  SUB.l load_var_addr,a0
  CMP.l #4,a0
  BNE 'l10bb
  CLR.l load_var_addr
  MOVE.l destpointer,a4
   CMP.w #$1b6d,-4(a4)
   BNE 'l10bb
   OR.w #$2d,d1
   EORI #$3000,d1
   MOVE.w d1,-4(a4)
  MOVE.w d3,d1
 JMP writeword

 'l10bb
  ; < new
  ADDQ.w #1,pcodd                                          ;byte
  EORI.w #$3000,D1

 'writestorevar                    ; was  'do  org source
  JSR writeword
  BTST #$7,D1
   BNE 'done
  MOVE.w D3,D1
 JMP writeword

 'writevarlong
   TST.b fast                                              ;optiimmi
   BEQ 'l10ba
   CNIF #optibreak
     ILLEGAL
   CEND
   MOVE.l destpointer,a0
   SUB.l imm_addr,a0
   CMP.l #6,a0
   BNE 'l10e
   CLR.l imm_addr
   MOVE.l destpointer,a4
   OR.w #$7c,d1
   MOVE.w d1,-6(a4)
    MOVE.w D3,D1
 JMP writeword

 'l10e
  MOVE.l destpointer,a0
  SUB.l load_var_addr,a0
  CMP.l #4,a0
  BNE 'l10ba
  CLR.l load_var_addr
  MOVE.l destpointer,a4
  CMP.w #$245f,-2(a4)
  BEQ 'l10ba
  OR.w #$28,d1
  OR.w d1,-4(a4)
  CMP.w #$2b6d,-4(a4)
  BNE 'd1aa
  CMP.w -2(a4),d3
  BNE 'd1aa
  SUBQ.l #4,destpointer
 RTS

 'd1aa
  MOVE.w d3,d1
 JMP writeword

 'l10ba
  ; < new
  JSR writeword
  BTST #$7,D1
   BNE.b 'done
  MOVE.w D3,D1
 JMP writeword

 'done
RTS


varalign:                       ; was  alignletpc  org source
  MOVE.w D1,-(A7)
  MOVE.w pcodd(PC),D1
  LSR.w #1,D1
   BCC.b 'done
  CLR.w pcodd
  MOVE.w add1a2,D1
   JSR writeword

 'done
  MOVE.w (A7)+,D1
RTS


;------                                                  ;disassembled code begin
add1a2:     Dc.b $52,$4A                                   ;ADDQ.W  #1,A2
;------                                                  ;disassembled code end

pcodd:     Ds.w 1                                          ;add 1 to this for bytes
listadd:   Ds.w 1                                          ;set to 8 if it's a list
listsize:  Ds.w 1


.do_dim:                         ; dodim org source
  ;dim an array
  ;
  ADDQ.w #1,regnum               ;get things into d1
  ; new >
  MOVE.b #1,nowdeclare
  CLR.b dimkeep
  CMP.l #"KEEP",-1(a5)
  BNE 'nokeep
    CMP.b #" ",3(a5)
    BNE 'nokeep
      ADDQ.l #3,a5
     '2
        CMP.b #" ",(a5)
        BNE '1
          ADDQ #1,a5
      BRA '2
     '1
    MOVE.l a5,lastsourcepos
    MOVE.b #1,dimkeep
 'nokeep
 
;  TST.b infunctioncode
;  BEQ 'l10
;  MOVE.b #1,addmemcode
;'l10
  ; < new
  MOVE.w #$FF9A,D1           ; is #65434, arraylib
  JSR uselib                 ;arrays lib!

  dodim2:
  CLR.w listadd
  CMP.w ##TokenID_List,D0           ; was #$8000+tnum,d0
  BNE.w 'notlist
    MOVE.w #$0008,listadd      ;it's a list
    MOVE.w #$FFFA,D1           ; is #65530, memlib
    JSR uselib                ;use memlib
    JSR get1bytemain
 'notlist
  CLR.w nonew
  JSR getparameter
  ; new >
  JSR checkdoubledeclare
  ; < new
  BTST #$1,flagmask+1
  BEQ.w JUMP_syntaxerr
  JSR fetchvars
  MOVE.w notshared,D1      ; added,
  BNE.w 'added
  ;
  ;Here, an Array is being Re-Dimmed
  ;
  MOVE.w $8(A3),temp1
  MOVE.w proceduremode,D2
  BNE.w 'reloc
  ;
  MOVE.w globalvarpointer,-(A7)
  MOVE.w $4(A3),globalvarpointer
  ADDQ.w #4,globalvarpointer
  BSR.w write_dim_code
  MOVE.w (A7)+,globalvarpointer
  BRA.w 'next

; 'reloc                                                ;??
;;  MOVE.w locvaroff,-(A7)         ; org source
   ; new >
;  MOVE.w globalvarpointer,-(A7)
   ; < new
;  MOVE.w $4(A3),locvaroff
;  subq.w #4,locvaroff
;   BSR.w write_dim_code
;  MOVE.w (A7)+,locvaroff
;BRA.w 'next

 'reloc                           ; new
  ; new >
  MOVE.w globalvarpointer,-(A7)
  MOVE.w proceduremode,-(a7)
  CLR.w proceduremode
  MOVE.w $4(A3),globalvarpointer
  ADDQ.w #4,globalvarpointer
  BSR.w write_dim_code
  MOVE.w (a7)+,proceduremode
  MOVE.w (A7)+,globalvarpointer
  ; < new
  BRA.w 'next

 'added
  ;here, we are doing a brand new dim!
  ;
  MOVE.w #$FFFF,temp1                ; was -1  ;no care on # dims
  MOVE.w listadd(PC),D1
  BEQ.w 'isok
    MOVE.w #$4000,temp1                ;yes, we do care - must be 1
                                       ;coz it's a list
    BSET #$0,$6(A3)                    ;set to list type of array
 'isok
  ; new >
        TST.w proceduremode
       BNE 'l1
       MOVE.w locvaroff,-(a7)

 'l1
  ; < new
  BSR.w write_dim_code
  ; new >
        TST.w proceduremode
        BNE 'next
       MOVE.w (A7)+,locvaroff
  ; < new

 'next
  JSR get1bytemain
  CMP.w #$2C,D0                ; ","
  BNE.w 'done
    JSR get1bytemain
    BRA.w dodim2
 'done
RTS


JUMP_syntaxerr JMP syntaxerr
JUMP_redimerr JMP redimerr


write_dim_code:                                            ;dimwrite org source
  MOVE.w #$FFFF,nonew                                      ;#-1,nonew org source
  MOVE.w beginarr,D1
  JSR writeword
  MOVEQ.l #$00,D1
  JSR writeword
  MOVEQ.l #$04,D1
  BTST #$0,flagmask+1
  BNE.w 'pointer
    MOVE.w $8(A2),D1
 'pointer
  ADD.w listadd(PC),D1                                     ;size of one element.
  MOVE.w D1,listsize
  JSR writeword
  CLR.w temp2                                              ;# dim's got
  MOVE.l A3,-(A7)

 'loop
  ADDQ.w #1,temp2
  MOVEQ.l #$03,D2                                          ;get word
  MOVE.w notshared,-(a7)
  JSR eval
  MOVE.w (a7)+,notshared
  ;TST.b debugmode
  ;BEQ.w 'norerr0
  ;  MOVE.w #$C30F,D1
  ;  BSR.w Atokejsr
  ;'norerr0
  ;MOVE.w #$C402,D1
  ;BSR.w Atokejsr
  MOVE.w #$5281,d1                                     ; opcode addq.l #1,d1
  JSR writeword

;multiplycode:   Dc.b $0C,$81,$00,$00,$FF,$FF                   ;CMPI.L  #$000FFFF,D1
;                Dc.b $64,$00,$00,$08                           ;BCC.W   bigmul
;                Dc.b $C1,$C1                                   ;  MULS.W D1,D0
;                Dc.b $60,$00,$00,$06                           ;  BRA endmul
;bigmul:                                                        ;bigmul
;                Dc.b $4C,$01,$08,$00                           ;  MULS.L D1,D0
;endmul:                                                        ;endmul
;------                                                  ;disassembled code end

  ; write MULS-code variants for 68000/68020+
  MOVE.l multiplycode(PC),D1    : JSR writelong
  MOVE.w multiplycode+4(PC),D1  : JSR writeword

  MOVE.l multiplycode+6(PC),D1  : JSR writelong

  MOVE.w multiplycode+10(PC),D1 : JSR writeword

  MOVE.l multiplycode+12(PC),D1 : JSR writelong
  MOVE.l multiplycode+16(PC),D1 : JSR writelong

  ;MOVE.l #$4c010800,d1                                 ;dim >65536 fix:  muls.l d1,d0 68020+ only!
  ;JSR writelong

  MOVE.w proceduremode,D2
  BEQ.w 'global
    SUBQ.w #4,locvaroff
    MOVE.w locvaroff,putarr+2
    BRA.w 'doit
 'global
  MOVE.w globalvarpointer,putarr+2
  ADDQ.w #4,globalvarpointer

 'doit
  TST.b dimkeep
  BEQ 'doit_l1
    MOVEQ #0,d1
    MOVE.w putarr+2,d1
    OR.l  #$222d0000,d1
    MOVE.w proceduremode,D2
    BEQ 'doit_l2
      TST.w notshared
      BEQ 'doit_l2
        SUB.l #$00010000,d1
   'doit_l2
    JSR writelong
 'doit_l1
  MOVE.l putarr,D1
  TST.w notshared
  BNE 'doit_l1a
    JSR writelong
    BRA 'doit_l4
 'doit_l1a
  JSR pokela5d

 'doit_l4
  CMP.w #$2C,D0
   BEQ.w 'loop
  CMP.w #$29,D0
   BNE.w JUMP_syntaxerr
  MOVEA.l (A7)+,A3
  MOVE.w temp1,D1
   BMI.w 'nocare
    ;
    ;is it a list?
    ;
  BTST #$E,D1
  BEQ.w 'notl
    CMPI.w #$1,temp2
    BNE.w JUMP_redimerr
    BRA.w 'nocare
 'notl
  CMP.w temp2,D1
  BNE.w JUMP_redimerr                                     ;range too long

 'ok                                                        ;??looks like not used anymore??
  LEA globalvarpointer,A0
  MOVE.w proceduremode,D1
  BEQ.w 'gskip
    LEA locvaroff,A0
 'gskip
  MOVE.W extraword,(A0)
  BRA.W  'care

 'nocare
  MOVE.w temp2,$8(A3)                                      ;set # dim's

 'care
  LEA doarr,A0
  MOVE.w $4(A3),$2(A0)
  MOVE.w putarr+2,$6(A0)
  MOVE.l (A0)+,D1
  JSR writelong
  MOVE.l (A0),D1
  JSR writelong

  TST.b dimkeep
  BNE 'care_l3
   'care_l1                                  ; obsolete label??
    MOVE.w #$C400,D1                         ; arrayslib: newarray
    BRA 'care_l2
 'care_l3
    MOVE.w #$C405,d1                         ; arrayslib: newarray2
 'care_l2
  MOVE.w proceduremode,D2
  BEQ.w 'isglobal
    TST.w notshared
    BEQ 'isglobal
      ADDQ.w #1,D1
 'isglobal
  MOVE.w listadd(PC),D2
  BEQ.w 'isrg
    MOVE.w D1,-(A7)
    MOVE.w setles(PC),D1
    JSR writeword
    MOVE.w listsize(PC),D1
    JSR writeword
    MOVE.w (A7)+,D1
    ADDQ.w #3,D1
 'isrg
BRA.w Atokejsr

;------                                                  ;disassembled code begin
setles:   Dc.b $38,$3C,$00,$00                             ;MOVE.W  #$0000,D4
;------                                                  ;disassembled code end

;------                                                  ;disassembled code begin
multiplycode:   Dc.b $0C,$81,$00,$00,$FF,$FF                   ;CMPI.L  #$000FFFF,D1
                Dc.b $64,$00,$00,$08                           ;BCC.W   bigmul
                Dc.b $C1,$C1                                   ;  MULS.W D1,D0
                Dc.b $60,$00,$00,$06                           ;  BRA endmul
bigmul:                                                        ;bigmul
                Dc.b $4C,$01,$08,$00                           ;  MULS.L D1,D0
endmul:                                                        ;endmul
;------                                                  ;disassembled code end


fpu_pi:
CNIF #64bitconstant
  MOVE.l #$f23c5400,d1                                  ; opcode: fmove.d
CELSE
  MOVE.l #$f23c4400,d1                                  ; opcode: fmove.s
CEND
  MOVE.w regnum,d0
  ASL.w #7,d0
  OR.w d0,d1
  JSR writelong
CNIF #64bitconstant
  MOVE.l #$400921fb,d1
  JSR writelong
  MOVE.l #$54442D18,d1
CELSE
  MOVE.l #$40490fd9,d1
CEND
  JSR writelong
JMP get1bytemain


;-----------data-----------------------;

.mydata

;vbr:                Ds.l 1
cfetchmode:         Ds.w 1                               ;1=fetching a constant
                    ;intercept uselib!
constlibs           Dc.w $FDA7,$FCDF,$FD43               ;64935,64735,64835  org source

    ;below is a PC for the constant evaluation routine
    ;
constpcat:          Ds.l 1
constlibat:         Ds.l 1
constmaxpc:         Dc.l $400
   ;
stacksize:          Dc.l #DEFAULT_STACKSIZE              ;stackfuck org source
currentlabeladdr:   Dc.l labelbase                       ;lastrescon org source
currentmacroaddr:   Dc.l macrobase                       ;lastresmac org source
lastrestype:        Dc.l newtype_string
rescnt:             Ds.w 1                               ;# resident
state_of_residents: Ds.w 1                               ;reschg org source ;flag for if res's have changed
resat:              Dc.l residents_table                 ;??looks like not used anymore??
linedone:           Ds.w 1
directbuffer:       Ds.w 11                              ;dirpcat  dc.w 0 org source
                                                         ;dira4    dc.l 0           ;Label not used in org source
                                                         ;dira5    dc.l 0           ;Label not used in org source
                                                         ;dira6    dc.l 0           ;Label not used in org source
                                                         ;dirstack dc.l 0           ;Label not used in org source

.handle_datatypes                                        
convtable:
;byte
  Dc.l 0                                        ; bytetobyte
  Dc.l convert_byte_to_word                     ; bytetoword
  Dc.l convert_byte_to_long                     ; bytetolong
  Dc.l convert_byte_to_quick                    ; bytetoquick
  Dc.l convert_byte_to_float                    ; bytetofloat
  Dc.l convert_byte_to_long                     ; bytetolong
  Dc.l error_convert_types                      ; noconerr

;word
  Dc.l convert_word_to_byte                     ; wordtobyte
  Dc.l 0                                        ; wordtoword
  Dc.l convert_word_to_long                     ; wordtolong
  Dc.l convert_word_to_quick                    ; wordtoquick
  Dc.l convert_word_to_float                    ; wordtofloat
  Dc.l convert_word_to_long                     ; wordtolong
  Dc.l error_convert_types                      ; noconerr

;long
  Dc.l convert_long_to_byte                     ; longtobyte
  Dc.l convert_long_to_word                     ; longtoword
  Dc.l 0                                        ; longtolong
  Dc.l convert_long_to_quick                    ; longtoquick
  Dc.l convert_long_to_float                    ; longtofloat
  Dc.l 0                                        ; longtolong
  Dc.l error_convert_types                      ; noconerr

;quick
  Dc.l convert_quick_to_byte                    ; quicktobyte
  Dc.l convert_quick_to_word                    ; quicktoword
  Dc.l convert_quick_to_long                    ; quicktolong
  Dc.l 0                                        ; quicktoquick
  Dc.l convert_quick_to_float                   ; quicktofloat
  Dc.l convert_quick_to_long                    ; quicktolong
  Dc.l error_convert_types                      ; noconerr

;float
  Dc.l convert_float_to_byte                    ; floattobyte
  Dc.l convert_float_to_word                    ; floattoword
  Dc.l convert_float_to_long                    ; floattolong
  Dc.l convert_float_to_quick                   ; floattoquick
  Dc.l 0                                        ; floattofloat
  Dc.l convert_float_to_long                    ; floattolong
  Dc.l error_convert_types                      ; noconerr

;address
  Dc.l convert_long_to_byte                     ; longtobyte
  Dc.l convert_long_to_word                     ; longtoword
  Dc.l 0                                        ; longtolong
  Dc.l convert_long_to_quick                    ; longtoquick
  Dc.l convert_long_to_float                    ; longtofloat
  Dc.l 0                                        ; longtolong
  Dc.l error_convert_types                      ; noconerr

;string
  Dc.l error_convert_types                      ; noconerr
  Dc.l error_convert_types                      ; noconerr
  Dc.l string_to_long                           ; stringtolong
  Dc.l error_convert_types                      ; noconerr
  Dc.l error_convert_types                      ; noconerr
  Dc.l string_to_long                           ; stringtolong
  Ds.l 1

    ;dc operator ascii
    ;dc.l   ..b,.w,.l,.q,.f,.a,.s                          ;dc.l   ..b,.w,.l,.q,.f,.s,.a org source seem wrong

operators:
  Dc.b $00,$2B                                  ;+ ; add
  Dc.l do_plus_byte                             ;doplusb
  Dc.l do_plus_word                             ;doplusw
  Dc.l do_plus_long                             ;doplusl
  Dc.l do_plus_long                             ;doplusl
  Dc.l do_plus_float                            ;doplusf
  Ds.l 1
  Dc.l add_strings                              ;addstrings
  Dc.b $0B,$B8
  ;
  Dc.b $00,$2D                                  ;- ; sub
  Dc.l do_minus_byte                            ;dominusb
  Dc.l do_minus_word                            ;dominusw
  Dc.l do_minus_long                            ;dominusl
  Dc.l do_minus_long                            ;dominusl
  Dc.l do_minus_float                           ;dominusf
  Ds.l 2
  Dc.b $0B,$B8
  ;
  Dc.b $00,$2A                                  ;* ; mul
  Dc.l do_times_byte                            ;dotimesb
  Dc.l do_times_word                            ;dotimesw
  Dc.l do_times_long                            ;dotimesl
  Dc.l do_times_quick                           ;dotimesq
  Dc.l do_times_float                           ;dotimesf
  Ds.l 2
  Dc.b $0F,$A0
  ;
  Dc.b $00,$2F                                  ;/ ; div
  Dc.l do_Div_byte                              ;dodivb
  Dc.l do_Div_word                              ;dodivb
  Dc.l do_Div_long                              ;dodivl
  Dc.l do_Div_quick                             ;dodivq
  Dc.l do_Div_float                             ;dodivf
  Ds.l 2
  Dc.b $0F,$A0
  ;
  Dc.b $00,$26                                  ;& ; & int
  Dc.l do_AND_byte                              ;doandb
  Dc.l do_AND_word                              ;doandw
  Dc.l do_AND_long                              ;doandl
  Dc.l do_AND_long                              ;doandl
  Ds.l 3
  Dc.b $13,$88
  ;
  Dc.b $00,$7C                                  ;| ;or int ;
  Dc.l do_OR_byte                               ;doorb
  Dc.l do_OR_word                               ;doorw
  Dc.l do_OR_long                               ;doorl
  Dc.l do_OR_long                               ;doorl
  Ds.l 3
  Dc.b $13,$88
  ;
  Dc.b $80,$42                                  ; AND int  ;(opand-opabcd)/$1c+$8000+fnum
  Dc.l do_AND_byte                              ;doandb
  Dc.l do_AND_word                              ;doandw
  Dc.l do_AND_long                              ;doandl
  Dc.l do_AND_long                              ;doandl
  Ds.l 3
  Dc.b $03,$E8
  ;
  Dc.b $80,$8A                                  ; OR int   ;(opor-opabcd)/$1c+$8000+fnum
  Dc.l do_OR_byte                               ;doorb
  Dc.l do_OR_word                               ;doorw
  Dc.l do_OR_long                               ;doorl
  Dc.l do_OR_long                               ;doorl
  Ds.l 3
  Dc.b $03,$E8
  ;
  Dc.b $80,$73                                  ; EOR int  ;(opeor-opabcd)/$1c+$8000+fnum
  Dc.l do_EOR_byte                              ;doeorb
  Dc.l do_EOR_word                              ;doeorw
  Dc.l do_EOR_long                              ;doeorl
  Dc.l do_EOR_long                              ;doeorl
  Ds.l 3
  Dc.b $03,$E8
  ;
  Dc.b $80,$7C                                  ; LSL int  ;(oplsl-opabcd)/$1c+$8000+fnum
  Dc.l do_LSL                                   ;dolslb
  Dc.l do_LSL                                   ;dolslw
  Dc.l do_LSL                                   ;dolsll
  Dc.l do_LSL                                   ;dolsll
  Ds.l 3
  Dc.b $17,$70
  ;
opls:
  Dc.b $3C,$3C                                  ;<< BitShift left
  Dc.l do_LSL
  Dc.l do_LSL
  Dc.l do_LSL
  Dc.l do_LSL
  Ds.l 3
  Dc.b $17,$70
  ;
oprs:
  Dc.b $3E,$3E                                  ;>> BitShift right
  Dc.l do_LSR
  Dc.l do_LSR
  Dc.l do_LSR
  Dc.l do_LSR
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$44                                  ; ASL int  ;(opasl-opabcd)/$1c+$8000+fnum
  Dc.l do_LSL                                   ;dolslb
  Dc.l do_LSL                                   ;dolslw
  Dc.l do_LSL                                   ;dolsll
  Dc.l do_LSL                                   ;dolsll
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$7D                                  ; LSR int  ;(oplsr-opabcd)/$1c+$8000+fnum
  Dc.l do_LSR                                   ;dolsrb
  Dc.l do_LSR                                   ;dolsrw
  Dc.l do_LSR                                   ;dolsrl
  Dc.l do_LSR                                   ;dolsrl
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$45                                  ; ASR int  ;(opasr-opabcd)/$1c+$8000+fnum
  Dc.l do_ASR                                   ;doasrb
  Dc.l do_ASR                                   ;doasrw
  Dc.l do_ASR                                   ;doasrl
  Dc.l do_ASR                                   ;doasrl
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$8E                                  ; ROL int  ;(opasr-opabcd)/$1c+$8000+fnum
  Dc.l do_ROL_b                                 ;dorolb
  Dc.l do_ROL_w                                 ;dorolw
  Dc.l do_ROL_l                                 ;doroll
  Dc.l do_ROL_l                                 ;doroll
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$8F                                  ; ROR int  ;(opasr-opabcd)/$1c+$8000+fnum
  Dc.l do_ROR_b                                 ;dororb
  Dc.l do_ROR_w                                 ;dororw
  Dc.l do_ROR_l                                 ;dororl
  Dc.l do_ROR_l                                 ;dororl
  Ds.l 3
  Dc.b $17,$70
  ;
  Dc.b $80,$B9                                  ;mod       ;$8006+tnum
  Dc.l do_mod_byte                              ;domodb
  Dc.l do_mod_word                              ;domodw
  Dc.l do_mod_long                              ;domodl
  Dc.l do_mod_quick                             ;domodq
  Dc.l do_mod_float                             ;domodf
  Ds.l 2
  Dc.b $13,$88
  ;
oppow:
  Dc.b $00,$5E                                  ;^
  Dc.l do_pow                                   ;dopow
  Dc.l do_pow                                   ;dopow
  Dc.l do_pow                                   ;dopow
  Dc.l do_pow                                   ;dopow
  Dc.l do_pow                                   ;dopow
  Ds.l 2
  Dc.b $1B,$58                                  ;7000
  ;
opeq:
  Dc.b $00,$3D                                  ;=
  Dc.l do_equal_byte                            ;doeqb
  Dc.l do_equal_word                            ;doeqw
  Dc.l do_equal_long                            ;doeql
  Dc.l do_equal_long                            ;doeql
  Dc.l do_equal_float                           ;doeqf
  Dc.l do_equal_long                            ;doeql
  Dc.l do_equal_string                          ;doeqs
  Dc.b $07,$D0                                  ;2000
  ;
opne:
  Dc.b $3C,$3E                                  ;<>
  Dc.l do_not_equal_byte                        ;doneb
  Dc.l do_not_equal_word                        ;donew
  Dc.l do_not_equal_long                        ;donel
  Dc.l do_not_equal_long                        ;donel
  Dc.l do_not_equal_float                       ;donef
  Dc.l do_not_equal_long                        ;donel
  Dc.l do_not_equal_string                      ;dones
  Dc.b $07,$D0                                  ;2000
  ;
oplt:
  Dc.b $00,$3C                                  ;<
  Dc.l do_littler_byte                          ;doltb
  Dc.l do_littler_word                          ;doltw
  Dc.l do_littler_long                          ;doltl
  Dc.l do_littler_long                          ;doltl
  Dc.l do_littler_float                         ;doltf
  Dc.l do_littler_long                          ;doltl
  Dc.l do_littler_string                        ;dolts
  Dc.b $07,$D0                                  ;2000
  ;
ople:
  Dc.b $3C,$3D                                  ;<=
  Dc.l do_littler_equal_byte                    ;doleb
  Dc.l do_littler_equal_word                    ;doleb
  Dc.l do_littler_equal_long                    ;dolel
  Dc.l do_littler_equal_long                    ;dolel
  Dc.l do_littler_equal_float                   ;dolef
  Dc.l do_littler_equal_long                    ;dolel
  Dc.l do_littler_equal_string                  ;doles
  Dc.b $07,$D0                                  ;2000
  ;
opgt:
  Dc.b $00,$3E                                  ;>
  Dc.l do_greater_byte                          ;dogtb
  Dc.l do_greater_word                          ;dogtw
  Dc.l do_greater_long                          ;dogtl
  Dc.l do_greater_long                          ;dogtl
  Dc.l do_greater_float                         ;dogtf
  Dc.l do_greater_long                          ;dogtl
  Dc.l do_greater_string                        ;dogts
  Dc.b $07,$D0                                  ;2000
  ;
opge:
  Dc.b $3E,$3D                                  ;>=
  Dc.l do_greater_equal_byte                    ;dogeb
  Dc.l do_greater_equal_word                    ;dogew
  Dc.l do_greater_equal_long                    ;dogel
  Dc.l do_greater_equal_long                    ;dogel
  Dc.l do_greater_equal_float                   ;dogef
  Dc.l do_greater_equal_long                    ;dogel
  Dc.l do_greater_equal_string                  ;doges
  Dc.b $07,$D0                                  ;2000
  ;
  Dc.b $80,$CD                                  ;$8000+26+tnum
  Dc.l _BitTst
  Dc.l _BitTst
  Dc.l _BitTst
  Dc.l _BitTst
  Ds.l 3
  Dc.b $1F,$40                                  ;8000
  ;
  Dc.b $80,$CE                                  ;$8000+27+tnum
  Dc.l _BitSet
  Dc.l _BitSet
  Dc.l _BitSet
  Dc.l _BitSet
  Ds.l 3
  Dc.b $1F,$40                                  ;8000
  ;
  Dc.b $80,$CF                                  ;$8000+28+tnum
  Dc.l _BitClr
  Dc.l _BitClr
  Dc.l _BitClr
  Dc.l _BitClr
  Ds.l 3
  Dc.b $1F,$40                                  ;8000
  ;
  Dc.b $80,$D0                                  ;$8000+29+tnum
  Dc.l _BitChg
  Dc.l _BitChg
  Dc.l _BitChg
  Dc.l _BitChg
  Ds.l 3
  Dc.b $1F,$40                                  ;8000
  ;
  Dc.b $00,$00


modetable:   Dc.l typemode


newtypebase: Dc.l newtype_byte

newtype_byte:                                              ;bytetype
  Dc.l newtype_word,$01                                    
  Dc.w $0001
  Dc.b 13,"b",0,0

newtype_word:                                              ;wordtype
  Dc.l newtype_long,$02
  Dc.w $0002
  Dc.b 13,"w",0,0

newtype_long:                                              ;longtype
  Dc.l newtype_quick,$03                                   
  Dc.w $0004
  Dc.b 13,"l",0,0

newtype_quick:                                             ;quicktype
  Dc.l newtype_float,$04                                   
  Dc.w $0004
  Dc.b 13,"q",0,0

newtype_float:                                             ;floattype
  ;Dc.l addresstype,$05                                     
  Dc.l newtype_double,$05                                  ;make problems on old residents
  Dc.w $0004
  Dc.b 13,"f",0,0

newtype_double:
  Dc.l newtype_string,$05                                  ;?? has to by $06 becous is number 6 not 5
  Dc.w $0008
  Dc.b 13,"d",0,0

;addresstype:                                               ;addresstype
;  Dc.l newtype_double,$06
;  Dc.w $0004
;  Dc.b 13,"a",0,0

newtype_string:
  Dc.l $0000000,$07                                        ;stringtype
  Dc.w $0004
  Dc.b 13,"s",0,0

dummytype:
  Dc.l $00,$00
  Dc.w $0000
  Dc.b $01,$00,$00,$00


incdir:               Ds.l 24                              ;dcb.b   96,0    org source
                                                           ;Even            org source


direct_mode:          Ds.w 1                               ;direct mode flag
                      Ds.l 1                               ;int org source ;intuition!
maxobject_pos:        Ds.w 1                               ;maxat org source ;max at
maxsat:               Ds.l 1                               ;data1 info pos
number_of_objects:    Ds.w 1                               ;nummaxs org source ;number of maximums
                                                           ;in libs
maxsused:             Ds.w 1                               ;maximums used in prog

; below are defaults to be saved with source
dark:                 Ds.w 1                               ;dark compile?
qlab:                 Ds.w 1                               ;quick lab allocate
defaulttype:          Dc.l newtype_quick                   ;dc.l quicktype org source
; end of defaults

anyerrs:              Dc.w -1                              ;Any Errors in compile ?
debugversion:         Ds.w 1                               ;makeexec org source ;make an executable file!
noinits:              Ds.l 1                               ;flag for if we have any init routines!
                                                           ;6.l=no!
letstart:             Ds.l 1
dontwrite_nomemleft:  Ds.w 1                               ;nomemleft org source
lastgloballabel:      Ds.l 32                              ;lastbiglab ds.b 128 org source
locdatast:            Ds.l 1
firstpend:            Ds.l 1

; one pass compiler stuff!
data2at:              Ds.l 1
data2:                Ds.l 1
data1start:           Ds.l 1                               ;data1at org source
data1:                Ds.l 1                               ;pc for initialized data!
destbufferstart:      Ds.l 1                               ;pcat org source
;destpointer:          Ds.l 1                               ;pc org source          ;ds.w 1  ;   moved to .pluginbase
                                                            ;pc+2; destpointer+2:    Ds.b 1
                                                            ;pc+3; destpointer+3:    Ds.b 1
destbufferend:        Ds.l 1                               ;libat org source
libend:               Ds.l 1                               ;lib org source
allat:                Ds.l 1                               ;highest allocmemd location for code
dummyasm:             Dc.w 0,0,0,0,0
                      Dc.l 0
                      Dc.w 0
;
;data for assembler
;
buff1:                Ds.l 1                               ;buffer for text get
buff2:                Ds.l 1                               ;ditto for dest
constmode:            Ds.w 1                               ;0 for norm, <>0 for assembler
asmtype:              Ds.w 1                               ;0=contains no prog reference
extraword:            Ds.w 1                               ;the extension word for assembler
extraword2:           Ds.w 1                               ;ditto
asmsize:              Ds.w 1
asmbuff:              Ds.l 1
asmlen:               Ds.w 1                               ;first (src) text len
asmlen2:              Ds.w 1                               ;second (dest)
templabel:            Ds.l 1                               ;linked list of expressions to resolve
;for one pass assembly.
;
macnum:               Ds.w 1
;nextinc0:                                                 ;??Looks like not used??
                      Dc.l 0                               ;address of next 0 in include fil
titleat:              Ds.l 1                               ;5 longs for compile streaks
progress_per_line:    Ds.w 5                               ;titleadd ds 5 org source ;5 adds for compile streaks
connest:              Ds.w 1                               ;conditional nest level
firstconst:           Ds.l 1                               ;first constant (#a)
numarg:               Ds.w 1                               ;number of macro arguements
myoline:              Ds.l 1                               ;macro done yet?
myline:               Ds.l 1                               ;pointer to some memory to create
                      ;line in.....
;mylinef:                                                  ;??looks like not used??
                      Ds.l 1
concomstack:          Ds.l 16                              ;32 deep conditional compilation
concomsp:             Dc.l concomstack                     ;stack pointer
oldqflag:             Ds.w 1
;datalib:              Dc.l 0                               ;pointer to datalib.obj (64535)  ;org source
;lastconloc:                                               ;??looks like not used??
                      Ds.l 1
;lastconop:                                                ;??looks like not used??
                      Ds.w 1
firstfor:             Ds.l 1                               ;first for
stackpar:             Ds.w 1                               ;pushflag org source ;1 par to stack 0 normal
sbgot:                Ds.w 1                               ;flag for string got 2
convsize:             Ds.w 1                               ;usertype org source
userp:                Ds.w 1

;libspos               Dc.w  0   ;pos in libs dir                      ;org source
;numlibs               Dc.w  0   ;number of libraries in libslist      ;org source

;ptr_userlibs_list:    Ds.l 1                               ;libslist org source
a2offset:             Ds.w 1                               ;stackuse org source ;stack used when gathering lib parameters
numreps:              Ds.w 1                               ;number of repeats in a repeatable

;parameter list.....
locloc:               Ds.l 1
locchar:              Ds.w 1
stbuff:               Ds.l 32                              ;was 8    ;six string varoffs
commode:              Ds.w 1                               ;in comma mode...
lastoffset_org:       Ds.l 1                               ;lastoffset org source ;last offset in calcvar!
linenumat:            Dc.l $FFFFFFFF                       ;linecounter ;dc -1 org source ;line being processed
compilelinecounter:   Dc.l $FFFFFFFF                       ;menuret dc -1 org source ;menu return code
;optresoff:                                                ;??looks like not used??
                      Ds.w 1                               ;opt reset offset
;varcode:                                                  ;??looks like not used??
                      Ds.l 64                              ;Ds.b vcodelen org source ;code used to generate
;varcode2:                                                 ;??looks like not used??
                      Ds.l 64                              ;Ds.b vcodelen org source ;above for let.....
varcodelen:           Ds.w 1                               ;and length
;varcodelen2:                                              ;??looks like not used??
                      Ds.w 1
oldvcodelen:          Ds.w 3                               ;old varcodelen
;stringslib1:          Dc.l 0                               ;address of stringslib1  ; org source
;procjmppc:            Dc.l 0                               ;pc of jmp of proc ;?? in org source presend  but not used??
Even4
tempvm:               Ds.l 1                               ;memlib org source ;address of memory library
memlibstat:           Ds.w 1                               ;status of memory library during
                      ;procs
;tempvmode:                                                ;??looks like not used??
                      Dc.w 0
;tempvmode2:                                               ;??looks like not used??
                      Dc.w 0

varmode:              Ds.w 1                               ;0 a5 pointer to global
                      ;else pointer to locals
currentfunction:      Ds.l 1                               ;thisproc org source
firstproc:            Ds.l 1                               ;firstproc org source ;this procedure being 'done'
proceduremode:        Ds.w 1                               ;-1=statement/ function return type ;procmode org source  ;1 if statement, 2 if function
                      ;0 if norm!
skipcode:             Ds.w 1                               ;nocompile ;comflag org source ;0 if no compile
passstack:            Ds.l 1
zero:                 Ds.l 1                               ;ZERO!
ininclude:            Ds.w 1                               ;numincs org source ;number of include files
                      ;0=main RAM code
xinclude_base:        Ds.l 1                               ;firstxinc org source ;first exclusive include.
constantbase:         Ds.l 1                               ;firstinc org source ;first include
lasta6:               Dc.w $FFFF                           ;-1 org source
instringon:           Ds.w 1                               ;quoteflag org source
ptr_macrobuffer_begin:Ds.l 1                               ;macrobuff org source ;pointer to macro collection buffer ;begin
ptr_macrobuffer_end:  Ds.l 1                               ;macrobufff org source ;end of above ;end of
macrobase:            Ds.l 1                               ;firstmacro org source ;linked list of macro's ;macrolist
endop:                Ds.l 1                               ;end of program pc - before finishups!
labelbase:            Ds.l 1                               ;firstlabel org source ;first lib struct
end_of_tokenlist:     Ds.l 1                               ;lasttoken org source
numstatic:            Ds.w 1                               ;number of static structs
staticdata:           Ds.l 1                               ;data1 val for statics
libpointer:           Ds.l 1                               ;firstlib org source ;first lib struct
sbasegot:             Ds.w 1                               ;string base got?
litdata1:             Ds.l 1
    ;
    ;Optimization stuff
    ;
objlen:               Ds.l 1
hunkoffsetcounter:    Ds.l 1                               ;numoffs org source
hunkoffsetbase:       Ds.l 1                               ;firstoff org source ;pointer to linked list
                      ;of amigados type reloc offsets
flagmask:             Ds.w 1                               ;mask for flag of variable when
                      ;searching for it!
notshared:            Ds.w 1                               ;added org source ;flag for seeing if variable was added!
nonew:                Ds.w 1                               ;1 to inhibit new variable creation
temp1:                Ds.l 1
temp2:                Ds.l 1
;    cnop    0,4 org source
ptr_parameterstore:   Ds.l 1                               ;namebuff ds.b 128 org source
fib_DirEntryType:     Ds.l 1                               ;namebuff+4 org source
fib_FileName:         Ds.l 29                              ;namebuff+8 org source
fib_Size:             Ds.l 1                               ;namebuff+124 org source

namebuff2:            Ds.b 128
                      Ds.b 8                               ;for fileinfoblock

; buffer fuer uselibs
optstuff:             Ds.b 64                              ;temp opt make buffer


Even

;.menu_viewnewtypes:                                        ; deactivated  becaus it is now in PED  tomsmart1
;  MOVEA.l comdata,A1
;  MOVEA.l $802(A1),A1                                      ; compiler says to PED: openwindow
;  !ComData_GetL{comPtr_CLIArgumentsString,A1}
;  MOVE.l #1000,D0                                          ; set indification for NeyType window
;  JSR (A1)                                                 ; open PED window NewTypes
;RTS


.ptr_xtradata:                                             ; optspnts org source ;pointers to options involved in source dependant
                                                           ; stuff
  Dc.b $00,$01                                             ; 1 byte schreiben ;one byte stuff...
  Dc.l xtra_versionnumber                                  ; vers org source
  Dc.l create_iconfile                                     ; create icon for executable
  Ds.l 1

  Dc.b $00,$02                                             ; 2 bytes schreiben  ;two byte stuff...
;jimi0 org source
  Dc.l set_use_debugger
  Dc.l AL_0_11010                                          ;+obsolet: debugger
  Dc.l AL_0_1103C                                          ;+obsolet: long arrays
  Dc.l AL_0_11068                                          ;+obsolet: expand macros
  Dc.l AL_0_11094                                          ;+obsolet: quoted macros
  Dc.l set_make_smallestcode
  Dc.l set_link_debuginfo
  Dc.l set_autorun
  Dc.l set_interruptcheck
  Dc.l set_assemblercheck
    ;
  Dc.l set_overflowcheck
  Dc.l default_obsolete                                    ;+obsolet: ohne inhalt
  Dc.l default_interruptcheck                              ;+obsolet: interruptcheck vorgabe
  Dc.l default_overflowcheck                               ;+obsolet: overflow vorgabe
    ;
;jimi1  ;org source
  Ds.l 1
    ;
  Dc.b $00,$04                                             ; 4 bytes schreiben..  ;four byte stuff...

;jimi2:  ;org source
bufferlist:                                                ;Maximums Int String Gadgets...
  Dc.l objectbuffer
  Dc.l libsbuffer
  Dc.l systembuffer
  Dc.l databuffer
  Dc.l macrobuffer_size
  Dc.l stringbuffer

;jimi3   ;org source
  Ds.l 1
                                                           ;Resident Buffer...
  Dc.b $02,$20                                             ;dc 68*8; 544 bytes schreiben.
  Dc.l residents_table,0

  ;
  ;Executable name!
  Dc.b $01,$80                                             ;dc 192*2; 384 bytes schreiben
  Dc.l exepath,0                                           ; exepath und exefilename jeweils 192 bytes
  Ds.w 1
;optspntsf   ;                                             ;??looks like not used??

optssave: ;ds.b ((jimi1-jimi0)/4*2)+(jimi3-jimi2)+(68*8)+(192*2)+2 org source ; 982 bytes
  Ds.l 63
  Ds.l 63
  Ds.l 63
  Ds.w 113
.ptr_endxtradata

comsettings_message:  Ds.w 1                               ;allchg org source
xtra_versionnumber:   Ds.w 1                               ;vers org source


.read_xtrafile:                                            ;load xtrafile, filehandle via PED in D7
  CLR.b exefile

  TST.l d0
  BNE 'l10
    RTS
 'l10              

  JSR free_residents                                       ;jsr freeres2 org source
  JSR Clear_Residents_table                                 ; added for a full clear of the residents table  tomsmart1 2012 08 08
  JSR clear_lastcompileerrordatas                           ; added to fix problems if a residents load error happend  tomsmart1 2016 02 02

  LEA ptr_xtradata,A2
  MOVEQ.l #$00,D4

 'loop
    MOVE.w (A2)+,D4                                        ; anzahl bytes zum lesen
    BEQ.b 'done

 'loop2
    MOVE.l (A2)+,D2
  BEQ.b 'loop

  MOVE.l D4,D3
  MOVE.l D7,D1
  JSR _Read(A6)                                            ; d1: file, d2: buffer, d3:length
  TST.l D0
  BNE.b 'loop2
 BRA.w 'done2

 'done                                                     ; set defaults
  TST.b xtra_versionnumber
  BNE.b 'nover0
    MOVE.w #$0080,set_autorun                                ;auto run on
    MOVE.w default_interruptcheck,set_interruptcheck         ;interupt checking on
    CLR.w set_assemblercheck                                 ;assembler checking off
    MOVE.w default_overflowcheck,set_overflowcheck           ;overflow chex
    BRA.b 'ver0
 'nover0
    MOVE.l D7,D1                                             ;load cli arg!
    MOVE.l #str_cliarguments,D2
    MOVE.l #116,D3                                           ; vorher 128 , jetzt 8 weniger fuer die Versionsdaten
    JSR _Read(A6)                                            ; d1: file, d2: buffer, d3:length
    MOVE.l #str_cliarguments,A0
    ADDA.l #115,A0
    MOVE.l #0,(a0) ; terminate it!

    MOVE.l D7,D1                                             ; I know, I know. Honitos started this horrible thing, see below...
    MOVE.l #stacksize,D2
    MOVE.l #4,D3
    JSR _Read(A6)
    CMP.l ##MIN_STACKSIZE,stacksize
    BGE 'stackok
      MOVE.l ##MIN_STACKSIZE,stacksize
   'stackok

    MOVE.l D7,D1
    MOVE.l #versioninformation,D2
    MOVE.l #4,D3
    JSR _Read(A6)

    MOVE.l D7,D1
    MOVE.l #number_of_builds,D2
    MOVE.l #4,D3
    JSR _Read(A6)
 'ver0
    ;here, we load in current max settings. done last coz of
    ;unknown number of max's
    ;
    MOVE.l a7,stackaddr                                      ; added to prevent a possible crash in CLIMode if #continue_on_error is set  tomsmart1
    MOVE.l A7,errstack
    MOVE.l #'done2,errcont
    MOVE.w #$FFFF,ezerr

   'dloop
      MOVE.l #temp1,D2                                   ;LOAD maxobjectsvalues
      MOVEQ.l #$04,D3
      MOVE.l D7,D1
      JSR _Read(A6)
      TST.l D0
      BEQ.b 'done2
        MOVE.w temp1,D1
        TST.w d1                                               ;new
        BEQ 'done2                                         ;new
          JSR findlibnoerr
          ;BEQ.b 'done2
          CMP.l #0,a1
          BEQ 'dloop
            MOVE.l $12(A1),D0
            MOVE.w temp1+2,-$4(A1,D0.L)
    BRA.b 'dloop
 'done2
  ;
  ;load in residents
  ;
  LEA residents_table(PC),A0
  MOVEQ.l #$07,D0
 'loop3
    CLR.l $40(A0)
    LEA ResidentEntryStep(A0),A0   ; $44
  DBF D0,'loop3

  MOVEM.l D7/A6,-(A7)
  JSR init_buffers
  JSR reloadresident
  MOVEM.l (A7)+,D7/A6
RTS


.write_xtrafile:                                           ;savextra org source ; D7 = filepointer A6 = dosbase
  MOVEA.l _dosbase,A6
  MOVE.b #$1,xtra_versionnumber                            ;.xtra version number...

;  LEA ptr_xtradata,A2
;  MOVE.l A2,-(a7)
;  MOVE.l D7,-(a7)
;  !basic
;  MOVE.l (a7)+,d0 : putreg d0, td7.l
;  MOVE.l (a7)+,d0 : putreg d0, testD0.l
;  !cout{"xtradata at: ",Hex$(testD0)}
;  !cout{"d7: " + Str$(td7)}
;  !asm

  LEA ptr_xtradata,A2
  MOVEQ.l #$00,D4

  ; -- write boolean options
 'loop
    MOVE.w (A2)+,D4                                        ; number of bytes to write
    BEQ.b 'done

   'loop2
      MOVE.l (A2)+,D2
      BEQ.b 'loop
        MOVE.l D4,D3
        MOVE.l D7,D1                                       ; d7: pointer to filehandle to write to
        JSR _Write(A6)                                     ; d1: file, d2: buffer, d3:length
    BRA.b 'loop2
 'done                                                     ; 
  MOVE.l D7,D1
  MOVE.l #str_cliarguments,D2
  MOVE.l #116,D3
  JSR _Write(A6)                                           ; write out cli arguements ...

  MOVE.l D7,D1
  MOVE.l #stacksize,D2
  MOVE.l #4,D3
  JSR _Write(A6)

  MOVE.l D7,D1
  MOVE.l #versioninformation,D2
  MOVE.l #4,D3
  JSR _Write(A6)

  MOVE.l D7,D1
  MOVE.l #number_of_builds,D2
  MOVE.l #4,D3
  JSR _Write(A6)
  ;
  ;OK, now to write out max's
  ;
  ;lib#.w,
  ;max.w.
  LEA libpointer,A2
 'loop3
    MOVE.l (A2),D0
    BEQ.w 'done2
      MOVEA.l D0,A2
      MOVE.l $12(A2),D4
      TST.w -$2(A2,D4.L)
      BEQ.w 'loop3
        LEA $4(A2),A0
        MOVE.l A0,D2
        MOVEQ.l #$02,D3
        MOVE.l D7,D1                                           ; schreiben der Libnum mit 2 bytes
        JSR _Write(A6)                                         ; d1: file, d2: buffer, d3:length

        LEA -$4(A2,D4.L),A0
        MOVE.l A0,D2
        MOVEQ.l #$02,D3
        MOVE.l D7,D1                                           ; schreiben der Max Objects mit 2 bytes
        JSR _Write(A6)                                         ; d1: file, d2: buffer, d3:length
  BRA.w 'loop3
 'done2

  ; write 4 fill/pad/termination bytes because the .read_xtrafile routine read min 4 bytes more as saved, this was moved form PED extend xtra Data save routine  tomsmart1
  LEA XTRAEndPadBytes,A2 ; get the start address off the 4 fill/pad/termination bytes
  MOVE.l A2,D2           ; move the address to d2
  MOVE.l #4,D3           ; we only need 4 bytes to save
  MOVE.l D7,D1           ; we set the file handle
  JSR _Write(A6)         ; and we write it.

RTS


; reset of the old menu_compileroptions:                                     ;menu4 org source  ;options requester
.BackupXtraData:    ;new tomsmart1
  LEA optssave,A0                      ; backup address
  LEA ptr_xtradata,A1                  ; source address

 'backuploop
  MOVE.w (A1)+,D0                                          ;length of data move
  BEQ.b 'backupdone
  SUBQ.w #1,D0

  'backuploop2
    MOVE.l (A1)+,D1
    BEQ.b 'backuploop
    MOVEA.l D1,A2
    MOVE.w D0,D1

     'backuploop3
      MOVE.b (A2)+,(A0)+
  DBF D1,'backuploop3

 BRA.w 'backuploop2

 'backupdone
  ;MAKE INT GADS!
  LEA bufferlist,A1

 'loop4
    MOVE.l (A1)+,D2
    BEQ.b 'loop4done

    MOVEA.l D2,A0
    MOVE.l (A0),D2
    ADDQ.w #8,A0
    JSR makelong
 BRA.b 'loop4

 'loop4done
  CLR.w state_of_residents                                 ;resident change
  CLR.w comsettings_message                                ;alloc change
  CLR.w maxobject_pos
RTS   ; new tomsmart1


.RestoreXtraData:                                                ;cancel compilersettings
  LEA optssave,A0
  LEA ptr_xtradata,A1

 'restoreloop1
  MOVE.w (A1)+,D0
  BEQ.b 'restoredone
  SUBQ.w #1,D0

  'restoreloop2
    MOVE.l (A1)+,D1
    BEQ.b 'restoreloop1
    MOVEA.l D1,A2
    MOVE.w D0,D1

   'restoreloop3
      MOVE.b (A0)+,(A2)+
  DBF D1,'restoreloop3

 BRA.b 'restoreloop2

 'restoredone
RTS


.FreeClearResidentsForPED               ; added for Compiler settings in PED safty  tomsmart1 2012 06 09
  JSR free_residents                    ; first free the allready loaded residents
  JSR Clear_Residents_table             ; second clear the complete resident table
RTS


.ReloadResidentsForPED                  ; need for Compiler settings window  tomsmart 2012 03 17
  JSR clear_lastcompileerrordatas       ; added to fix problems if a residents load error happend  tomsmart1 2016 02 02
  MOVE.w #$FFFF,state_of_residents
  MOVE.w state_of_residents,D0
  JSR reloadresident
RTS


; need for compilersettings and .ab3 save(climode)
.getobjectentry:    ; was  a copy of maxit org source
  ; new >
  MOVE.l d0,a1
  ; < new
  MOVEA.l libpointer,A2

 'loop
    MOVE.l $12(A2),D0
    TST.w -$2(A2,D0.L)
     BEQ.w 'next
    SUBQ.w #1,D1
     BPL.w 'next
    ;
    MOVEA.l -$1A(A2,D0.L),A3    ;token offset
    ADDA.l A2,A3

 'tt1
      MOVE.b (A3)+,(A1)+
    BNE.w 'tt1
 ; new >
    CLR.b -(A1)
 ; < new
    MOVE.w -$4(A2,D0.L),D0
 ; new >
    AND.l #$ffff,d0
 RTS
  ; < new

 'next
    MOVEA.l (A2),A2
BRA.w 'loop


; --
; -- compilersetting_datas
str_maxobjects_name:   Dc.b "              ",0 : Even
str_maxobjects_name2:  Dc.b "              ",0 : Even
objectbuffer:          Dc.l #DEFAULT_OBJECTBUFFERSIZE  ; replaced with a constant tomsmart1
                       Dc.l $00000000
str_objectbuffer:      Dc.b "16384",0,0,0,0,0,0,0      ; string max 12 columns

libsbuffer:            Dc.l #DEFAULT_LIBSBUFFERSIZE    ; replaced with a constant tomsmart1
                       Dc.l $00000000
str_libsbuffer:        Dc.b "32768",0,0,0,0,0,0,0      ;was "16384"; string max 12 columns

systembuffer:          Dc.l #DEFAULT_SYSTEMBUFFERSIZE  ; system buffer  ; replaced with a constant tomsmart1
                       Dc.l $00000000
str_systembuffer:      Dc.b "4096",0,0,0,0,0,0,0,0     ; string max 12 columns

databuffer:            Dc.l #DEFAULT_DATABUFFERSIZE    ; data buffer   ; replaced with a constant tomsmart1
                       Dc.l $00000000
str_databuffer:        Dc.b "4096",0,0,0,0,0,0,0,0     ; string max 12 columns

macrobuffer_size:      Dc.l #DEFAULT_MACROBUFFERSIZE   ; macro buffer ; was $00002000 ; replaced with a constant tomsmart1
                       Dc.l $00000000
str_macrobuffer:       Dc.b "40000",0,0,0,0,0,0,0      ; string max 12 columns

stringbuffer:          Dc.l #DEFAULT_STRINGBUFFERSIZE  ; string buffer ; replaced with a constant tomsmart1
                       Dc.l $00000000
str_stringbuffer:      Dc.b "10240",0,0,0,0,0,0,0      ; string max 12 columns

maxobjects_value:      Dc.w $0064
                       Dc.l $00000000
str_maxobjects_value:  Dc.b "100",0,0,0,0,0,0,0,0,0    ; string max 12 columns

maxobjects_value2:     Dc.w $0014
                       Dc.w $0000
                   ;   Ds.w 1
str_maxobjects_value2: Dc.b "20",0,0,0,0,0,0,0,0,0,0   ; string max 12 columns



set_create_iconfile:   Dc.b $00
create_iconfile:       Dc.b $80,$01,$01                    ;create icon
                       Dc.b $00,$01

set_use_debugger:      Dc.b $00                            ; Flags.w
use_debugger:          Dc.b $80,$01,$01                    ; Activation.w
                       Dc.b $00,$01                        ; GadgetType.w
AL_0_11010:            Dc.b $00,$80,$01,$01                ; flags, activation
AL_0_1103C:            Dc.b $00,$80,$01,$01                ; flags, activation
AL_0_11068:            Dc.b $00,$80,$01,$01                ; flags, activation
AL_0_11094:            Ds.w 1

set_make_smallestcode: Ds.b 1
make_smallestcode:     Dc.b $00,$01,$01                    ;make smallest
                       Dc.b $00,$01
set_link_debuginfo:    Ds.b 1
link_debuginfo:        Dc.b $00,$01,$01                    ;create debuginfo
                       Dc.b $00,$01


; -------------------------------------------------
residents_table:   ; 544 bytes, 68 bytes je eintrag
  Ds.l 136         ;resident files STEP $44 piece 8
                   ;ResidentEntryStep defined with $44 in common.ab3 for all sources tomsmart1 2012 05 24
residents_table_end:     ; Label added that this memspace can be cleared  tomsmart1 2012 06 08
; -------------------------------------------------

str_calcexpression:        Ds.l 32
destbufferend_backup_calc: Ds.l 1             ; was calclibat
Even


.menu_calculator:         ;calculator
  MOVE.l destbufferend,destbufferend_backup_calc
  ; new >
  MOVE.l a7,stackaddr                         ; added to prevent a possible crash in CLIMode if #continue_on_error is set  tomsmart1
  ; < new
  MOVE.l A7,errstack
  MOVE.l #Calc_Error_Exit,errcont

  ; get the flags for the conversion form the editor
  !basic
  !ComData_GetW{comWord_CalculatorButtonBinFlag,D0} : MOVE.w d0,CalculatorButtonBinFlag
  !ComData_GetW{comWord_CalculatorButtonDecFlag,D0} : MOVE.w d0,CalculatorButtonDecFlag
  !asm

  LEA str_calcexpression,A0

  ; auswerten der expression
  JSR setcvars
  JSR setsvars
  ;
  CLR.w connest             ;no idea...
  LEA str_calcexpression,A5
  JSR evalconst3            ;evaluate constant
  ;
  LEA str_calcexpression,A0
  TST.l D3
   BPL.w 'ispos
  MOVE.b #$2D,(A0)+         ;'-'
  NEG.l D3

 'ispos
  CMPI.w #$80,CalculatorButtonDecFlag
   BEQ.w 'dec
  MOVEQ.l #$00,D1
  CMPI.w #$80,CalculatorButtonBinFlag
   BNE.w 'hex
  ;
  ;bin Print
  MOVEQ.l #$1F,D0
  MOVE.b #$25,(A0)+      ;'%'

 'bloop
      LSL.l #1,D3
       BCC.w 'bzero
      MOVE.b #"1",(A0)+
      MOVEQ.l #-$01,D1
  BRA.w 'bnext

   'bzero
      TST.w D1
      BEQ.w 'bnext
      MOVE.b #"0",(A0)+

   'bnext
 DBF D0,'bloop

 'bdone
  TST.w D1
  BNE.w 'pc1
  MOVE.b #"0",(A0)+

 'pc1
  CLR.b (A0)
 BRA.w 'pc

 'hex
  MOVEQ.l #$07,D0
  MOVE.b #$24,(A0)+  ;'$'

 'hloop
    MOVE.l D3,D2
    SWAP D2
    LSR.w #8,D2
    LSR.w #4,D2
    ADDI.w #$30,D2
    CMP.w #$3A,D2
     BCS.w 'hok
    ADDQ.w #7,D2

   'hok
    CMP.w #$30,D2
    BEQ.w 'hzero
    MOVE.b D2,(A0)+
    MOVEQ.l #-$01,D1
  BRA.w 'hnext

   'hzero
    TST.w D1
     BEQ.w 'hnext
    MOVE.b D2,(A0)+

   'hnext
    LSL.l #4,D3
 DBF D0,'hloop

 BRA.w 'bdone

 'dec
  MOVE.l D3,D2
  JSR makelong          ;to long...

 'pc:
;RTS                        ; deactive tomsmart 2012 03 07 vor Calculator in PED


Calc_Error_Exit:            ; was 'calcerr
  MOVE.l destbufferend_backup_calc,destbufferend
;BRA.w 'pc                  ; deactive tomsmart 2012 03 07 vor Calculator in PED
RTS                         ; added tomsmart 2012 03 07 vor Calculator in PED


Even
str_cliarguments: Ds.b 255   ; a command line can acutally be 255 characters long

Even

;.menu_simcliarguments:   ; was menu9                                  ; deactivated becaus is now in PED  tomsmart1
   ;CLI ARGUEMENT
   ;
   ; new >
;   MOVEA.l comdata,A1
;  MOVEA.l $802(A1),A1                                      ; compiler says to PED: openwindow
;  !ComData_GetL{comPtr_CLIArgumentsString,A1}
;  MOVE.l #1001,D0                                          ; set indification for CLIArgs window
;  MOVE.l #str_cliarguments,D1                              ; set pointer for the string
;  JSR (A1)                                                 ; open PED window CLIArgs
;RTS
   ; < new


.skipme:                                                   ;??Looks like double label??
 'l1
    MOVE.b (a5)+,d0
    BEQ 'l2
    CMP.b #$80,d0
    BNE 'l1
    MOVE.b (a5)+,d0
    BEQ 'l2
    CMP.b #$02,d0
  BNE 'l1

 'l3
    CMP.b #$20,(a5)+
  BEQ 'l3
  SUBQ.l #1,a5
  TST.b (a5)
  BEQ 'l2
  CMP.w ##TokenID_Statement,(a5)                        ;$8008
  BEQ 'l4
  CMP.w ##TokenID_Function,(a5)                         ;$8009
  BEQ 'l4
 BRA 'l1

 'l4
  ADDQ.l #2,a5
  JSR skiprest
RTS

 'l2
  JSR nextline
  BNE 'l1
RTS


.compiledate
  !basic
  DateFormat 1
  i999.l = SystemDate
  a$=Date$ (i999)
  a$=Replace$(a$,"/",".")
  GetReg D0,&a$
  MOVEQ #8,d2
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b (a0)+,d0
  !asm
  ADD.l #9,d2
  ADD.l #9,a5
RTS


.compiledate_ger
  !basic
  DateFormat 0
  i999.l = SystemDate
  a$=Date$(i999)
  a$=Replace$(a$,"/",".")
  GetReg D0,&a$
  MOVEQ #8,d2
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b (a0)+,d0
  !asm
  ADD.l #9,d2
  ADD.l #13,a5
RTS


.compiledatedc
  !basic
  DateFormat 1
  i999.l = SystemDate
  a$ = Date$ (i999)
  a$ = Replace$(a$,"/",".")
  GetReg D0,&a$
  MOVEQ #8,d2
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR writebyte
  DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b (a0)+,d0
  !asm
  ADD.l #9,a5
RTS


.compiledatedc_ger
  !basic
  DateFormat 0
  i999.l = SystemDate
  a$=Date$ (i999)
  a$=Replace$(a$,"/",".")
  GetReg D0,&a$
  MOVEQ #8,d2
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR writebyte
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b (a0)+,d0
  !asm
  ADD.l #13,a5
RTS


.version_string:
  MOVE.l d2,-(a7)                                          ; D2 -> stack
  MOVE.l a5,d0
  !basic
  PutReg d0,_myD0.l
  If _myD0
    verstring$ = Left$(Peek.s(_myD0),9+3)
    verstring$ = UnRight$(verstring$,3)                      ; Compilerkonstantenbeginn \__ entfernen
  Else
    error{"INTERNAL: Invalid pointer in version_string!"}
  End If

  ; Version coded as : Majorversion Minorversion Patchlevel
  ;                    00           00           00
  actual_version.l = Peek.l(?versioninformation)
  actual_build.l   = Peek.l(?number_of_builds)

  Format "00"
  Select verstring$

    Case "VER_MAJOR"
     put_versionstr$ = Str$(actual_version LSR 24)

    Case "VER_MINOR"
     put_versionstr$ = Str$((actual_version LSL 8) LSR 24)

    Case "VER_PATCH"
     put_versionstr$ = Str$((actual_version LSL 16) LSR 24 )

    Case "VER_BUILD"
     Format ""
     put_versionstr$ = Str$(actual_build)

    Default
     put_versionstr$ = "{unknown compilerconstant}"
;    a5add.l = 4

  End Select
  Format ""

  GetReg D0,FLen(put_versionstr$)                              ; laenge zielstring -> Stack
  MOVE.l d0,d2
  MOVE.l d2,-(a7)
  SUB #1,d2

  GetReg D0,&put_versionstr$                                   ; kopieren des neuen Strings in den Zielstring
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
  DBF d2,'l1

  MOVEQ #0,d0
  !asm
  MOVE.l (a7)+,d0                                          ; laenge Zielstring <- Stack
  MOVE.l (a7)+,d2                                          ; d2 <-Stack
  ADD.l d0,d2
  ADD.l #12,a5                                             ; string_ptr um konstante weitersetzen
  MOVEQ #0,d0
RTS


.version_string_dc:
  MOVE.l a5,d0
  !basic
  PutReg d0,_myD0.l
  If _myD0
    verstring$ = Left$(Peek.s(_myD0),9+3)
    verstring$ = UnRight$(verstring$,3)                      ; Compilerkonstantenbeginn \__ entfernen
  Else
    error{"INTERNAL: Invalid pointer in version_string_dc!"}
  End If

  ; Version coded as : Majorversion Minorversion Patchlevel
  ;                    00           00           00
  actual_version.l = Peek.l(?versioninformation)
  actual_build.l   = Peek.l(?number_of_builds)

  Format ""
  Select verstring$

    Case "VER_MAJOR"
     put_versionstr$ = Str$(actual_version LSR 24)

    Case "VER_MINOR"
     put_versionstr$ = Str$((actual_version LSL 8) LSR 24)

    Case "VER_PATCH"
     put_versionstr$ = Str$((actual_version LSL 16) LSR 24 )

    Case "VER_BUILD"
     Format ""
     put_versionstr$ = Str$(actual_build)

    Default
     put_versionstr$ = "{unknown compilerconstant}"

  End Select
  Format ""

  GetReg D0,FLen(put_versionstr$)-1
  MOVE.l d0,d2

  GetReg D0,&put_versionstr$                                   ; kopieren des neuen Strings in den Zielstring
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR writebyte
 DBF d2,'l1

  MOVEQ #0,d0
  MOVE.b -(a0),d0                                          ; letztes Zeichen in D0
  !asm
  ADD.l #12,a5                                             ; string_ptr um konstante weitersetzen
RTS


;.insert_functionname:
;; "\\__THIS_FUNCTION
;  MOVE.l d2,-(a7)                                          ; D2 -> stack
;  MOVE.l a5,d0
;  !basic
;  putreg d0, _myD0.l
;  If _myD0
;    constring$ = Left$(Peek.s(_myD0),13 + 3)
;    constring$ = UnRight$(constring$,3)                      ; Compilerkonstantenbeginn \__ entfernen
;  Else
;    error{"INTERNAL: Invalid pointer in insert_functionname!"}
;  End If
;  Select LCase$(constring$)
;
;   Case "this_function"
;    If Peek.l(?currentfunction)<>0
;      currentfuncP.l = Peek.l(?currentfunction)
;      If currentfuncP
;        condata$ = Peek.s(currentfuncP + 48 + 1)                  ;need change when use
;      Else
;        condata$ = "???"
;        error{"INTERNAL: Invalid pointer in currentfunction!"}
;      End If
;    Else
;      condata$ = "GLOBAL"
;    EndIf
;
;   Default
;    condata$ = constring$
;
;  End Select
;  GetD0 Len(condata$)                                      ; laenge zielstring -> Stack
;  MOVE.l d0,d2
;  MOVE.l d2,-(a7)
;
;  GetD0 &condata$                                          ; kopieren des neuen Strings in den Zielstring
;  MOVE.l d0,a0
;
; 'l1
;    MOVE.b (a0)+,d1
;    JSR pokedata1b
; DBF d2,'l1
;
;  !asm
;  MOVE.l (a7)+,d0                                          ; laenge Zielstring <- Stack
;  MOVE.l (a7)+,d2                                          ; d2 <-Stack
;  ADD.l d0,d2                                              ; eingefuegte chars zu D2 dazu
;  ADD.l #16,a5                                             ; string_ptr um konstante weitersetzen
;RTS
;
;
;.insert_codeline:
;; "\\__codeline
;  MOVE.l d2,-(a7)                                          ; D2 -> stack
;  MOVE.l a5,d0
;  !basic
;  _myD0.l = PutD0
;  If _myD0
;    constring$ = Left$(Peek.s(_myD0),8 + 3)
;    constring$ = UnRight$(constring$,3)                      ; Compilerkonstantenbeginn \__ entfernen
;  Else
;    error{"INTERNAL: Invalid pointer in insert_codeline!"}
;    constring$ = "???"
;  End If
;  Select LCase$(constring$)
;
;   Case "codeline"
;    condata$ = Str$(Peek.l(?globallinecount))
;
;   Default
;    condata$ = constring$
;
;  End Select
;
;  GetD0 Len(condata$)                                      ; laenge zielstring -> Stack
;  MOVE.l d0,d2
;  MOVE.l d2,-(a7)
;  SUB #1,d2
;
;  GetD0 &condata$                                          ; kopieren des neuen Strings in den Zielstring
;  MOVE.l d0,a0
;
; 'l1
;    MOVE.b (a0)+,d1
;    JSR pokedata1b
; DBF d2,'l1
;
;  MOVEQ #0,d0
;  !asm
;  MOVE.l (a7)+,d0                                          ; laenge Zielstring <- Stack
;  MOVE.l (a7)+,d2                                          ; d2 <-Stack
;  ADD.l d0,d2
;  ADD.l #11,a5                                             ; string_ptr um konstante weitersetzen
;  MOVEQ #0,d0
;RTS
;
;

.checkcast
  MOVE.l a5,-(a7)
  !fget
  CMP.w #".",d0
  BNE 'skip
  MOVEM.l a2/d2,-(a7)
  LEA newtypebase,a2
  JSR getparameter2
  BEQ.w JUMP_syntaxerr
  JSR findtype
  BNE.w JUMP_notypeerr2
  MOVE.l a2,typetocast
  MOVEM.l (a7)+,a2/d2
  CMP.w #")",d0
  BNE JUMP_errorbracketmiss
  ADDQ.l #4,a7
  !fget
  JMP nocast

 'skip
  MOVE.l (a7)+,a5
JMP bracket


JUMP_errorbracketmiss JMP errorbracketmiss


Function.l ab3_GetIncludeLock{filename.s}
  incLock.l  = Lock_(&filename,#ACCESS_READ)   ; try bla.blub
  ex.s       = dos_GetExt{filename}
;
  If incLock = False
    filename = dos_SetExt{filename,"ab3"}
    incLock  = Lock_(&filename,#ACCESS_READ)   ; try bla.ab3
  End If
;
  If incLock = False
    filename = dos_SetExt{filename,"ab2"}
    incLock  = Lock_(&filename,#ACCESS_READ)   ; try bla.ab2
  End If

  If incLock = False
    filename = dos_SetExt{filename,"bb2"}
    incLock  = Lock_(&filename,#ACCESS_READ)   ; try bla.bb2
  End If

  If incLock = False
    filename = dos_SetExt{filename,ex+".ab3"}
    incLock  = Lock_(&filename,#ACCESS_READ)   ; try bla.blub.ab3
  End If
;
  If incLock = False
    filename = dos_SetExt{filename,"ab2"}
    incLock  = Lock_(&filename,#ACCESS_READ)   ; try bla.blub.ab2
  End If
;
  If incLock = False
    filename = dos_SetExt{filename,"bb2"}
    incLock  = Lock_(&filename,#ACCESS_READ)   ; try bla.blub.bb2
  End If
;
 Function Return incLock
End Function


.check_incdir:
  !basic
  incString.s = Peek$(?ptr_parameterstore)                  ; name of include file

  ;-- check first, if include is in current directory                                    
  !ComData_LEA{comStr_SourceDir,D0} : PutReg d0,incDirP.l
  incDir_.s   = Peek.s(incDirP)                             ; get current Sourcefiledir
  incFile.s   = dos_AddPart{incDir_,incString}              ; adding Sourcefiledir and Includestring
  incLock.l   = ab3_GetIncludeLock{incFile}                 ; check if file exist

  If incLock = False ; not found => check default Include Directory
    incFile.s = dos_AddPart{config\path_includes,incString}
    incLock.l = ab3_GetIncludeLock{incFile}
  End If

  If incLock = False ; not found => check relative to current source
    incDepth.l = Peek.w(?ininclude)-1
    If incDepth >= 0 AND incDepth < #maxincludes
      incDir_.s = dos_PathPart{incdim (incDepth)} ;= Peek.s(?includetemp2)
      incFile.s = dos_AddPart{incDir_,incString}
      incLock.l = ab3_GetIncludeLock{incFile}
    End If
  End If

  If incLock = False ; still not found => check default Include Directory and name only
    incFile.s = dos_AddPart{config\path_includes,dos_FilePart{incString}}
    incLock.l = ab3_GetIncludeLock{incFile}
  End If

  If incLock
    MaxLen incFile = 1024
    NameFromLock_ incLock,&incFile,1024
    incFile = Peek.s(&incFile)
    Poke$ ?ptr_parameterstore,incFile
    il.b = FLen(incFile)
    GetReg d0,il
    MOVE.l d0,tempstore
    UnLock_ incLock
  End If

  !asm
  TST.l tempstore
   BEQ 'l1
  MOVE.l tempstore,d2

 'l1
RTS


.check_IncBinDir:                                           ; to fix includepathes in CLIMode   tomsmart1
  !basic
  incString.s = Peek$(?ptr_parameterstore)                  ; get the string
  !ComData_LEA{comStr_SourceDir,D0}                        ; get pointer to current Sourcefiledir
  PutReg d0,incDirP.l                                       ;    "
  incDir_.s   = Peek.s(incDirP)                             ; get current Sourcefiledir
  incFile.s   = dos_AddPart{incDir_,incString}              ; adding Sourcefiledir and Includestring
  incLock.l   = Lock_(&incFile,#ACCESS_READ)                ; check if file exist

  If incLock = False                                        ; not found => try orignal string only to find
    incLock.l = Lock_(&incString,#ACCESS_READ)
  End If

  If incLock                                                ; found => store full path
    MaxLen incFile = 1024
    NameFromLock_ incLock,&incFile,1024
    incFile = Peek.s(&incFile)
    Poke$ ?ptr_parameterstore,incFile
  End If

  GetReg d0,incLock                                         ; store Lockpointer in D0 for a futher use in the orginal routine (errormsg, Examine, UnLock)
  !asm
RTS


.gotoendsource
  ; MOVE.w #1,dontwrite_nomemleft

;'l1
  ; JSR naloextline
  ; BNE 'l1
  ; ADDQ.l #1,numlines2
  ; ;JSR skiprest
  JSR Aclearallvars
  JSR free_unusedfunctions
  ;
;'l2
  ; MOVE.l firstiff,d0
  ; BEQ 'done
  ; MOVE.l d0,a1
  ; MOVE.l (A1),firstiff
  ; MOVEQ.l #$0E,D0
  ; movea.l _execbase,A6
  ; MOVE.l mempool,a0
  ; JSR _FreePooled(A6)
;BRA 'l2

 'done
  ; MOVE.l stackaddr,a7
  MOVE.l #"NORE",reqmode
JSR handle_compileerror

 .linemessage
  MOVE.l d0,-(a7)
  MOVE.l a5,d0
  !basica7
  PutReg d0,i.l
  If i
    a$ = Peek$(i)
    b$ = Peeks$(i-7,7)
    ;i = Request(!TRANS{"Do workaround ?"},b$ + a$,!TRANS{"Yes|No"})
    i = ask{!TRANS{"Do workaround ?"} + "\\n" + b$ + a$,!TRANS{"Yes|No"},!TRANS{"Info"} }    ; replaced it with a error.include function  tomsmart1
    MOVE.l d0,result
  End If
  !asma7
  MOVE.l (a7)+,d0
RTS


.check_of_same_source:
  !basic
  !ComData_LEA{comStr_SourceDir,D0}
  PutReg d0,currentDirP.l

  !ComData_LEA{comStr_SourceName,D0}
  PutReg d0,fileNameP.l

  check_dirname$  = Peek$(currentDirP)
  check_filename$ = Peek$(fileNameP)
  If (olddirname$<>check_dirname$) OR (oldfilename$<>check_filename$)
    JSR free_unusedfunctions
  End If
  olddirname$ = Peek$(check_dirname$)
  oldfilename$ = Peek$(check_filename$)
  For i = 0 To #maxincludes-1
    incline(i) = 0
  Next
  !asm
RTS


.addimmi
  MOVEQ #0,d1

 'l1
    MOVE.b (a5)+,d0
    BEQ 'er1
    CMP.b #$20,d0
  BEQ 'l1
  ADDQ #1,d1
  CMP.b #$22,d0
  BNE 'l1
 RTS

 'er1
JMP syntaxerr



erro1t   Dc.b "Only one BSS / Chip Segment allowed",0 : Even
nodata   Dc.b "BSS Segment contains Data!!!!",0       : Even
Even


.bssseg
  TST.b exdebug
  BNE 'l10
  MOVE.l #$4e71,d1
  JSR writeword
  MOVE.l destpointer,d0
  MOVE.l d0,d1
  ADDQ.l #3,d1
  AND.l #$fffffffc,d1
  MOVE.l d1,destpointer
  SUB.l destpointer,d0
  BEQ 'lnf1
  CMP.l #-1,bssstart
  BNE 'lnf1
  CMP.l #-1,chipstart
  BNE 'lnf1
  MOVE.l destpointer,a4
  TST.w dontwrite_nomemleft
  BNE 'lnf1
  MOVE.w #$4e71,-2(a4)

 'lnf1
  CMP.l #-1,bssstart
  BEQ 'l11
  MOVE.l #erro1t,-(a7)
 JMP handle_compileerror

 'l11
  MOVE.l destpointer,bssstart
  MOVE.b #1,bssmode

 'x2
  TST.b chipmode
  BEQ 'l10
  MOVE.l destpointer,chipend
  CLR.b chipmode

 'l10
  JSR get1bytemain
RTS


.chipseg
   TST.b exdebug
  BNE 'x1
  MOVE.l destpointer,d0
  MOVE.l d0,realbssend
  MOVE.l #$4e71,d1
  JSR writeword
  MOVE.l destpointer,d0
  MOVE.l d0,d1
  ADDQ.l #3,d1
  AND.l #$fffffffc,d1
  MOVE.l d1,destpointer
  SUB.l destpointer,d0
  BEQ 'lnf1
  MOVE.l destpointer,a4
  CMP.l #-1,bssstart
  BNE 'lnf1
  CMP.l #-1,chipstart
  BNE 'lnf1
  TST.w dontwrite_nomemleft
  BNE 'lnf1
  MOVE.w #$4e71,-2(a4)

 'lnf1
  TST.b bssmode
  BEQ 'l10
  MOVE.l destpointer,bssend
  CLR.b bssmode

 'l10
  ;addq.l #3,destpointer
  ;and.l #$fffffffc,destpointer
  CMP.l #-1,chipstart
  BEQ 'l11
  MOVE.l #erro1t,-(a7)
 JMP handle_compileerror

 'l11
  MOVE.l destpointer,chipstart
  MOVE.b #1,chipmode

 'x1
  JSR get1bytemain
RTS


.save_includename:
  !basic
;  For i = 0 To  #maxincludes-1
;    If dos_FilePart{incdim(i)} = dos_FilePart{Peek$(?includetemp2)}
;      !cout{"schon drin: " + Peek$(?includetemp2)}
;      Pop For
;      !asm
;      RTS
;    EndIf
;  Next i
;  !cout{"storing: ",Peek$(?includetemp2),Peek.l(?includeline)}
  i.l = Peek.w(?ininclude)
  If i>=0 AND i<#maxincludes
    incdim (i) = Peek.s(?includetemp2)
    incline(i) = Peek.l(?includeline)

    If CLIMode
      If cli_verbose>=2 Then NPrint "Include \\22",incdim(i),"\\22..."
    End If
  End If

  !asm
RTS


.zero_includename:
  !basic
  i.l = Peek.w(?ininclude)
  If i>=0 AND i<#maxincludes
    incdim (i) = ""
    incline(i) = 0
    If i>0 Then Poke.l (?includeline),incline(i-1)+1
  End If
  !asm
RTS


.replacelib:
  LEA replacedat,a0
  Dc.w $3181,$0A00                                         ;MOVE.w d1,0(a0,d0.l*2)
RTS


.writeinit:
  TST.b fpu
  BEQ 'l1

 'l1
  MOVE.l destpointer,newinitaddr
  JSR writeword
  JSR writelong
RTS


.stripspaces:                                              ;??Looks like double label??
 'll21
  TST.b (a5)
   BEQ.s 'll20
  CMP.b #$20,(a5)
   BNE.s 'll10
  ADDQ.l #1,a5
 BRA.s 'll21

 'll10
  CMP.b #";",(a5)
  BNE.s 'll20

 'll25
  TST.b (a5)+
  BEQ.s 'll23
 BRA.s 'll25

 'll23
  SUBQ.l #1,a5

 'll20
RTS


.findconstant2:
  MOVEM.l a2/d2,-(a7)
  MOVEQ #0,d2
  LEA ptr_parameterstore,a0
  LEA chartab,a2

 fc2
  MOVE.b (a5),d0
  TST.b 0(a2,d0)
  BNE 'l10
  ADDQ.l #1,a5
  MOVE.b d0,(a0)+
  ADDQ.l #1,d2
 BRA fc2

 'l10
  CLR.b (a0)+
  JSR findlabel2
  MOVE.l a2,a0
  MOVEM.l (a7)+,a2/d2
RTS


.error:
  TST.l d0
  BNE 'l10
    MOVE.l #syntax_,-(a7)
    JMP handle_compileerror
 'l10
  CMP.l #1,d0
  BNE 'l20
    MOVE.l #overflow,-(a7)
    JMP handle_compileerror
 'l20
  ADD.l a2,d0
  MOVE.l d0,-(a7)
  JMP handle_compileerror


;************************** don't scatter end
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP _return
  JMP Atokejsr
  JMP writeinit
  JMP macroexecute
  JMP findnext
  JMP replacelib
  JMP findconstant2
  JMP findchar                                             ;char in d1
  JMP stripspaces
  JMP calc                                                 ;d0 varmode
  JMP error
  JMP writelong                                            ;d1 value
  JMP writeword                                            ;d1 value
  JMP writebyte                                            ;d1 value
JMP exit


.pluginbase
  destpointer:    Ds.l 1                                ;pc org source      ;Ds.w 1
                                                        ;destpointer+2:      Ds.b 1
                                                        ;destpointer+3:      Ds.b 1
  fast            Dc.w 0                                ; optimize 1 = INTEGER
  fpu             Dc.w 0                                ; optimize 2 = FPU
  newsyntax       Dc.w 0                                ; optimize 4 = newsyntax
  ;******************** don't scatter end
  optistring      Dc.b 0
  optistring2     Dc.b 0
  optiarray       Dc.b 0
  quickadd        Dc.b 0
  newmode         Dc.w 0
  mode            Dc.w 0
  string1         Dc.w 0
  load_var_size   Dc.w 0
  load_var_reg    Dc.w 0
  load_var_addr   Dc.l 0 
  imm_size        Dc.w 0
  imm_reg         Dc.w 0
  imm_addr        Dc.l 0
  iee             Dc.b 0
  _dcb            Dc.b 0
  nohunkoffset    Dc.l 0

;-- data for ted
teddata:        Dc.l tokens                                                                ; 0 .. 3
                Dc.l read_xtrafile                                                         ; 4 .. 11
                Dc.l write_xtrafile                                                        ; 8 .. 15
                Dc.l call_menuentry                                                        ; 12
                Dc.b ":"                                                                   ; 16
                Dc.b 34                                                                    ; 17
                Dc.b "."                                                                   ; 18
                Dc.b ";"                                                                   ; 19
                Dc.l newtypebase                                                           ; 24 .. 35
realconstbase:  Dc.l labelbase                                                             ; 28 .. 39
ptr_deflibfilename: Dc.l 0                                                                 ; 32 .. 43
ptr_incdirname:     Dc.l 0                                                                 ; 36 .. 47
                Dc.l 0                                                                     ; 40 .. 51
                Dc.l 0
                Dc.l 0

_return         RTS
                Dc.b 0
chartab2        Ds.l 256
codeend         Dc.l 0
hunkoffsetnum   Dc.l 0
chipsize        Dc.l 0
bsssize         Dc.l 0
bssstart        Dc.l -1
bssend          Dc.l -1
chipstart       Dc.l -1
chipend         Dc.l -1
bssmode         Dc.b 0
chipmode        Dc.b 0
newhunk         Dc.b 0
bssnum          Dc.l 0
chipnum         Dc.l 0
lastinstruction Dc.l 0
lastinstructionaddr Dc.l 0
hunkbegin       Dc.l $03F3,$00,$02,$00,$01
tstsize1b:      Ds.l 1
bsssize2        Dc.l 1
                Dc.l $03E9
tstsize2b:      Dc.l $100
hunkbegin2      Dc.l $03F3,$00,$03,$00,$02
tstsize1c:      Ds.l 1
bsssize3        Dc.l 1
chipsize2       Dc.l 1
                Dc.l $3e9
tstsize2c       Dc.l 0
hunkend         Dc.l $3f2,$3eb,0,$3f2
hunkend2        Dc.l $3f2,$3ea,0,$3f2
strcpy          Dc.b "strcpy",0
strcmp          Dc.b "strcmp",0
strvar          Dc.b "strvar",0
qmul            Dc.b "qmul",0
qdiv            Dc.b "qdiv",0
_MaxLen         Dc.b "maxlen",0
notf            Dc.b "????",0
;_intuiname      Dc.b "intuition.library",0
errtext         Dc.b "only reg addressing Mode supported",0
fpuerr          Dc.b "Instruction not yet supported by 68K FPU ",0
cmplxerr        Dc.b "Formula too complex for 68K FPU or too much regload register used",0 : Even
peeksize        Dc.w 0

mainstart       Dc.l 0
;addmemcode      Dc.b 0
infunctioncode  Dc.b 0
regnumstore     Dc.w 0
                Dc.b "$VER: AmiBlitz3 \\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH (\\__DATE_GER__) Build \\__VER_BUILD",0 : Even
testcode        Dc.b "print i",0
                Ds.b 100
devo            Dc.b "developobject",0 : Even
autostorename   Dc.b "__autoconstantnum",0
_include        Dc.b "__include",0
_debug          Dc.b "__debug",0
unusedfunc      Dc.l 0
Even
 
.errorstringparse:
  MOVEM.l a0/a5,-(a7)
  MOVE.l A0,D0
  MOVE.l A5,D1
  !basic
  PutReg D0,*errorstring.l
  PutReg D1,*errorcause1.l
  MOVE.l lastsourcepos,A0 : SUBQ.l #1,a0 : MOVE.l A0,D0 : PutReg D0,*errorcause2.l

  error_type.s = Peek.s(*errorstring)
  error_cause1.s=Peek.s(*errorcause1)
  error_cause2.s= Peek.s(*errorcause2)
  error_line.s = Str$(Peek.l(?compilelinecounter) + 1)
  error_code.s = Str$(Peek.l(?compileErrorCode))                                                                                                                                                                                                         
  error_lineptr.s = "$" + Hex$(Peek.l(?sourceline))
  If Peek.l(?compileErrorCode) = 1
    errtok.s = "$" + Peek.s(?tokerrnum)
    errlibnum.w = Vallong(errtok) LSR 7
    error_libnum.s = Str$(errlibnum)
  EndIf

  If Peek.l (?beforeparameterfetch)
    MaxLen detokenline.s = #MAX_Columns + 1        ; was 65536  changed it to the max size of a sourceline  tomsmart1
    !ComData_GetL{comPtr_PreProcessor,include_preprocessor}
    *tn.preprocessor = Peek.l(?include_preprocessor)
    written.l = preproc_DetokenizeLine{*tn,Peek.l (?beforeparameterfetch),&detokenline}
    If written > 0 Then Poke.b &detokenline + written,0
    If written > 40 Then Poke.s &detokenline + 36, "..."   ; added to limit the width of the error requester  tomsmart1
    error_source.s = Peek.s(&detokenline)
  Else
    error_source = "NULL"
  End If
 
  !asm
  MOVEM.l (a7)+,a0/a5
RTS


.stdout_error:
  MOVE.l a0,-(a7)
;  MOVE.l a0,d0
 ; MOVE.l a5,a0                                             ;macro title
  !basic
;  PutReg d0,i

;  MOVEQ #20,d0
; 'l2
;    MOVE.b -(a0),d1
;    BEQ 'l1
;    CMP.b #":",d1
;    BEQ 'l1
;    SUBQ.l #1,d0
;    BNE 'l2
; 'l1
;  ADDQ #1,a0
;  MOVE.l a0,d0
;  PutReg d0,i2.l

  If Peek.w (?ininclude) > 0
    Poke.s (?includetemp2),incdim(Peek.w(?ininclude)-1)
    errorline.l = Peek.l(?includeline);-1
    Poke.l ?compilelinecounter,Peek.l(?includeline) - 1
    errorfile.s = Peek.s(?includetemp2)
  Else
    Poke.s (?includetemp2),Peek.s(?ptr_parameterstore)
    errorline.l = Peek.l(?compilelinecounter) + 1
    errorfile.s = cli_sourcefile
  End If

  If error_type <> ""
    errortext.s = !TRANS{Replace$(error_type,"\\0a","\n")}
    errortext.s = Replace$(errortext,"\n","\\0a")
  Else
    errortext.s = "???"
  End If

  NPrint "\\1b[1m",!TRANS{"Compiler Error"}," #",Peek.l(?errorcounter)," <",errorfile,"@",errorline,">\\1b[0m "
  NPrint "  ",error_type.s,"\\n  ",error_source.s
;    NPrint peek.s(i2)
;  NPrint Peek.l(?globallinecount)," ",!TRANS{"line(s) compiled."}
;  NPrint Hex$(Peek.w(?globalvarpointer))+" global var base"
  !asm
  MOVE.l (a7)+,a0
RTS


.save_errorfile
  MOVE.l a0,-(a7)
;  MOVE.l a0,d0                                             ;error string
;  MOVE.l a5,a0                                             ;current sourceline
  !basic
;  PutReg d0,ptr_errorstring.l
;
;  MOVEQ #20,d0
; 'l2
;    MOVE.b -(a0),d1
;    BEQ 'l1
;      CMP.b #":",d1
;      BEQ 'l1
;        SUBQ.l #1,d0
;  BNE 'l2
; 'l1
;  ADDQ #1,a0
; 
;  MOVE.l a0,d0
;  PutReg d0,ptr_sourceextract.l


  fid.l = file_Open{dos_AddPart{config\path_system,"ab_compileerror.txt"},#file_forcewrite}
  If fid <> -1
    file_WriteLine{fid,"ERROR  :" + error_type}
    file_WriteLine{fid,"ERRCODE:" + error_code}
    file_WriteLine{fid,"LINE   :" + error_line}
    file_WriteLine{fid,"LINEPTR:" + error_lineptr}
    file_WriteLine{fid,"CAUSE1 :" + error_cause1}
    file_WriteLine{fid,"CAUSE2 :" + error_cause2}
    file_WriteLine{fid,"SOURCE :" + error_source}
    file_WriteLine{fid,"LIBNUM :" + error_libnum}

    If Peek.w (?ininclude) > 0
      Poke$ ?includetemp2,incdim(Peek.w(?ininclude)-1)
    Else
      Poke$ ?includetemp2,""
    End If
    a$ = Peek$(?includetemp2)
    If a$
      file_WriteLine{fid,"INCLUDE:" + a$}
      file_WriteLine{fid,"INCLINE:" + Str$(Peek.l(?includeline))}
      Poke.l ?compilelinecounter,Peek.l(?includeline) - 1
    Else 
      file_WriteLine{fid,"INCLUDE:" + "none"}
      file_WriteLine{fid,"INCLINE:" + "none"}      
    End If

    file_WriteLine{fid,Str$(Peek.l(?globallinecount))+" line(s) compiled"}
    file_WriteLine{fid,Hex$(Peek.w(?globalvarpointer))+" global var base"}
    file_Close{fid}
    ;error{"written"}
  End If
  !asm
  MOVE.l (a7)+,a0
RTS


.update_progressbar
  !basic
  PutReg d0, progress.l
  total.l        = Peek.w(?progressbar_width)
  calcpro        = (progress * 100) / total +1
  pass.l         = Peek.w(?pass) + 1                          ; added +1 so the shown status info begin with 1 instead of 0  tomsmart1
  typ.l          = Peek.w(?compiler_job)

;  !cout{typ,pass,progress,Peek.l(?lastsourcepos)}


  If (pass><pass_old) OR (typ><typ_old)

    If pass_old><pass
      passtatusstr.s = !TRANS{"Pass"}+" "+Str$(pass)+"..."
      If cli_verbose>=1 Then NPrint passtatusstr              ; changed form 2 to get compilepass number in verbose mode 1  tomsmart1
    End If

    pass_old = pass
    typ_old  = typ
    update_comstatus_gui = True

    If typ = 0
      comBaseStatus = !TRANS{"Pass"}+" "+Str$(pass)+": "+!TRANS{"Compiling Sources ..."}
      calcpro = 0                                             ; set gauge to 0
    End If
    If typ = 1
      comBaseStatus = !TRANS{"Pass"}+" "+Str$(pass)+": "+!TRANS{"Building Executable ..."}
      calcpro = 0                                             ; set gauge to 0
    End If

    If cli_verbose>=3 Then NPrint comstatusstr
  End If

  If (calcpro >< calcpro_old)
    If cli_verbose>=4 Then NPrint calcpro,"% compiled..."
    calcpro_old = calcpro
    update_comstatus_gui = True
  EndIf

  If incString <> oincString.s
    oincString = incString
    comMessage.s = ""
    If incString <> "" Then comMessage = " (" + incString + ")"
    update_comstatus_gui = True
  EndIf


  If update_comstatus_gui = True                                     ; check if a update of the gui nessecary
    comstatusstr = comBaseStatus + comMessage
    !asm
    !ComData_JSR{comFunc_UpdateCompileStatusWin}          ; jsr to the gui updateroutine  tomsmart1 2012 05 12 ;no extra check needed for CLImode because without PED the function only has a RTS
    !basic
    update_comstatus_gui  = False ; because we update the gui
  EndIf
  !asm
RTS
 

;need for compilersettings and .ab3 save.(climode)
.storemaxobjects                                           ;was menu4c, and is no only a part of it
  MOVE.w maxobject_pos,D5                                  ;max objects 1. visible
  LEA maxobjects_value,A3                                  ;current value
  MOVEA.l libpointer,A2

 'ugwl
  CMPA.w #$0,A2
  BEQ.w 'igot
  MOVEA.l A2,A1
  ADDA.l $12(A1),A1
  TST.w -$2(A1)
  BEQ.w 'ugwl2
  SUBQ.w #1,D5
  BMI.w 'ugw2

 'ugwl2
  MOVEA.l (A2),A2
 BRA.w 'ugwl

 'ugw2
  MOVE.w (A3),-$4(A1)

 'igot
RTS


.do_LastRunErrsMode:
  MOVE.w debugnest,d0
  LEA storedebugmode, a0
  MOVE.b 0(a0,d0.w),debugmode
  TST.w debugnest
  BEQ JUMP_unpairrunerrs
  SUBQ.w #1,debugnest
RTS

.do_honitos:
  !regs2stack
  !basic
  error{"hallo honitos!"}
  !asm
  !stack2regs
RTS


JUMP_runerrsoverflow JMP runerrsoverflow
JUMP_unpairrunerrs   JMP unpairrunerrs


.menu_toggledebug:
  BCHG #$7,use_debugger

  BTST #$7,use_debugger
  BNE 'debugon
    CLR.w debugmode
    BRA.b 'debugoff
 'debugon
    SNE debugmode
 'debugoff
  MOVE.l a0,-(a7)
;  MOVE.l comdata,a0
;  MOVE.b debugmode,$7ee(a0)
  !ComData_SetB{comByte_DebugMode,debugmode}

;  !basic
;  !cout{Peek.b(?debugmode)}
;  !asm
  MOVE.l (a7)+,a0
RTS



.do_runerrson:
  BTST #$7,use_debugger
  ; new >
  BNE 'debugon
    CLR.w debugmode
    BRA.b 'debugoff
 'debugon
    ; < new
    SNE debugmode
 'debugoff
RTS


.do_runerrsoff:
  ; new >
  ADDQ.w #1,debugnest
  MOVE.w debugnest,d0
  CMP.w #18,d0
   BGE JUMP_runerrsoverflow
  LEA storedebugmode, a0
  MOVE.b debugmode,0( a0,d0.w)

 'l1
  ; < new
  SF debugmode
RTS


usedpath:  Ds.l 32


.do_USEPATH:
  BEQ.w JUMP_syntaxerr
  LEA lastpath,A0
  ; new >
  MOVEM.l a0-a1/d0,-(a7)
  LEA lastpath2,a1

 'l2
    MOVE.b (a0)+,(a1)+
  BNE 'l2
  MOVEM.l (a7)+,a0-a1/d0
  LEA usedpath(PC),A0
  MOVEM.l a0-a1/d0,-(a7)
  LEA lastpath,a1

 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1
  MOVEM.l (a7)+,a0-a1/d0
  ; < new

 'loop
  TST.w D0
   BMI.w JUMP_syntaxerr
  MOVE.b D0,(A0)+
  BSR.w JUMP_get1bytemain
   BNE.w 'loop

 ;'done
  MOVE.b #$2,(A0)
RTS


.do_usepath2:                            ; copy of do_USEPATH  this is more original
  BEQ.w JUMP_syntaxerr
  LEA path2,A0
  ; new >
;  MOVEM.l a0-a1/d0,-(a7)
;  LEA lastpath,a1

; 'l1
;  MOVE.b (a0)+,(a1)+
;  BNE 'l1
;  MOVEM.l (a7)+,a0-a1/d0
   ; < new

 'loop
  TST.w D0
   BMI.w JUMP_syntaxerr
  MOVE.b D0,(A0)+
  BSR.w JUMP_get1bytemain
   BNE.w 'loop

 ;'done
  MOVE.b #$2,(A0)
RTS

; new >
JUMP_errormsg_reg JMP errormsg_reg


.do_regsave:
  MOVE.l #$f22d6780,fpucodeglobal
  MOVE.l #$f22c6780,fpucodelocal
  LEA regtable,a0
  MOVE.l #7,maxregs

 'again
  MOVE.l (a0),d0
  BEQ 'e1
  CLR.l (a0)
  MOVE.w 4(a0),d0
  MOVE.l fpucodeglobal,fpucode
  TST.w 6(a0)
  BEQ 'glob
  MOVE.l fpucodelocal,fpucode

 'glob
  MOVE.l fpucode,d1
  JSR writelong
  SUB.l #$80,fpucodelocal
  SUB.l #$80,fpucodeglobal
  MOVE.w d0,d1
  JSR writeword
  ADDQ #8,a0
 BRA 'again

 'e1
RTS


JUMP_notypeerr2 JMP notypeerr
JUMP_illtypeerr JMP illtypeerr

.do_regload:
  MOVE.l #$f22d4780,fpucodeglobal
  MOVE.l #$f22c4780,fpucodelocal
  LEA regtable,a0
  TST.l (a0)
   BNE JUMP_errormsg_reg
  MOVE.l d7,-(a7)
  SUBQ.l #1,a5

 'l2
  JSR getparameter2
  BEQ.w 'nopar
  MOVE.w d0,lastchar
  JSR findvariable
  BNE 'islocal
  MOVE.l fpucodeglobal,fpucode
  MOVE.l #3,maxregs
  MOVEQ #0,d7

 'go
  CMP.l #newtype_float,$a(a2)                              ;is float type
   BEQ 'doit
  CMP.l #newtype_double,$a(a2)
   BNE JUMP_illtypeerr

 'doit
  LEA regtable,a0
  MOVEQ #0,d0

 'loop
  TST.l (a0)
   BEQ 'store
  ADDQ.l #4,d0
  ADDQ.l #8,a0
  CMP.l #16,d0
   BCS 'loop
  MOVE.l #2,maxregs
  CMP.l #20,d0
   BCS 'loop
  MOVE.l #1,maxregs
  CMP.l #24,d0
   BCS 'loop
 JMP toovarerr

 'store
  TST.b fpu
   BEQ 'nofpu
  MOVE.l a2,(a0)
  MOVE.w 4(a2),4(a0)
  MOVE.w d7,6(a0)
  MOVE.l fpucode,d1
  SUB.l #$80,fpucodeglobal
  SUB.l #$80,fpucodelocal
  JSR writelong
  MOVE.w 4(a2),d1
  JSR writeword

 'nofpu
  MOVE.w lastchar,d0
  CMP.w #":",d0
   BEQ 'nopar
  TST.w d0
   BEQ 'nopar
  CMP.w #",",d0
  BNE JUMP_syntaxerr
 BRA 'l2

 'nopar
   MOVE.l (a7)+,d7
 RTS

 'islocal
  MOVEQ #1,d7
  MOVE.b #1,newvariable
  LEA firstlocal,a2
  JSR findvariable
  CLR.b newvariable
  CMP.l #-1,d0
  BEQ.w JUMP_notypeerr2
  MOVE.l fpucodelocal,fpucode
 BRA 'go

 _extb                                                     ;020 instr extb
  CMP.b #".",d0
   BNE 'l1
  BSR JUMP_get1bytemain
  BSR JUMP_get1bytemain

 'l1
  ORI .b #$20,d0
  CMP.b #"d",d0
   BNE JUMP_illeaerr
  BSR JUMP_get1bytemain
  SUB.b #$30,d0
  CMP.b #$7,d0
   BGT JUMP_syntaxerr
  MOVE.w #$49c0,d1
  ADD.b d0,d1
  JSR writeword
  BSR JUMP_get1bytemain
RTS


.do_uselastpath
  LEA lastpath,a0
  LEA usedpath(PC),A1

 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1

  LEA lastpath2,a0
  LEA lastpath,A1

 'l2
    MOVE.b (a0)+,(a1)+
  BNE 'l2
RTS


.do_Object:
  TST.b objectcount
  BEQ 'l2a
    JMP macnesterr
 'l2a
  LEA devo,a0
  ADDQ.b #1,objectcount
  MOVEM.l a1/d2,-(a7)
  LEA ptr_parameterstore,a1

 'l1
    MOVE.b (a0)+,(a1)+
  BNE 'l1

  MOVEQ #13,d2
  JSR findlabel2
  BNE 'd
    TST.l 8(a2)
    BEQ 'd
      SUBQ.b #1,objectcount
      MOVEM.l (a7)+,a1/d2
      JSR skiprest
      MOVE.b #1,developobject
      RTS
 'd
  MOVEM.l (a7)+,a1/d2
  MOVE.b #1,resdisable

 'l2
  CLR.b developobject
JMP do_Macro
;RTS                                                        ;??looks like unneeded code??

JUMP_illeaerr JMP illeaerr


.do_SYNTAX:
  CLR.b typecheck
  CLR.b declare
  CLR.b declare2
  SUB.b #$30,d0
  BTST #0,d0
  BEQ 'l1
    MOVE.b #1,declare
 'l1
  BTST #1,d0
  BEQ 'l2
    MOVE.b #1,declare2
 'l2
  BTST #2,d0
  BEQ 'l3
    MOVE.b #1,typecheck
 'l3
  BSR.w JUMP_get1bytemain
RTS

JUMP_get1bytemain JMP get1bytemain


.Clear_Residents_table:
  !basic
  ;clear Residents_Table (fill with 0)  tomsmart1 2012 06 08
  FillMem ?residents_table,?residents_table_end-?residents_table,0
  !asm
Return


.check_newconstants:
;  !regs2stack
  MOVE.l d2,-(a7)                                          ; D2 -> stack
  ADDQ #1,a5
  MOVE.l a5,-(a7)
  !basic
  MOVE.l (a7)+,d0 : PutReg d0, _myD0.l
  If _myD0
    newconst$ = UCase$(Peek.s(_myD0))
  Else
    error{"INTERNAL: invalid pointer in check_newconstants!"}
    nwconst$="xxx"
  End If
  condata$ = ""
  Poke.b ?skip_bytes,0
  If Left$(newconst$,2) = "__"
    Select Mid$(newconst$,3,4)

     Case "DATE"
      Select Mid$(newconst$,3,6)
      Case "DATE__" : DateFormat 1 : Poke.b ?skip_bytes,8
      Case "DATE_G" : DateFormat 0 : Poke.b ?skip_bytes,12
      End Select
      i.l=SystemDate
      condata$ = Date$ (i)
      condata$ = Replace$(condata$,"/",".")

     Case "VER_"
      ; Version coded as : Majorversion Minorversion Patchlevel
      ;                    00           00           00
      actual_version.l = Peek.l(?versioninformation)
      actual_build.l   = Peek.l(?number_of_builds)

      Format ""
      Select Mid$(newconst$,3,9)

       Case "VER_MAJOR"
        condata$ = Str$(actual_version LSR 24)

       Case "VER_MINOR"
        condata$ = Str$((actual_version LSL 8) LSR 24)

       Case "VER_PATCH"
        condata$ = Str$((actual_version LSL 16) LSR 24 )

       Case "VER_BUILD"
        Format ""
        condata$ = Str$(actual_build)

       Default
        condata$ = "{unknown compiler constant}"

      End Select
      Format ""
      Poke.b ?skip_bytes,11

     Case "THIS"
      Select Mid$(newconst$,3,9)

       Case "THIS_FUNC"
        Poke.b ?skip_bytes,15
        If Peek.l(?currentfunction)<>0
          condata$ = Peek.s(Peek.l(?currentfunction) + 32 + #funcentry_extend + 1)
        Else
          condata$ = "GLOBAL"
        EndIf

       Case "THIS_INCL"
        Poke.b ?skip_bytes,14
        If Peek.l(?includetemp2)<>0
          condata$ = dos_FilePart{Peek$(?includetemp2)}
        EndIf

       Case "THIS_POIN"
        Poke.b ?skip_bytes,14
        If Peek.l(?currentfunction)<>0
          condata$ = Hex$(Peek.l(?currentfunction))
        EndIf

      End Select

     Case "CODE"
      Poke.b ?skip_bytes,10
      If Mid$(newconst$,3,8) = "CODELINE"
        condata$ = Str$(Peek.l(?globallinecount))
      EndIf

    End Select

  Else
    Select Left$(newconst$,1)

     Case "R"
      Poke.b ?skip_bytes,3
      For i = 1 To Vallong(Mid$(newconst$,2,2))
        condata$ = condata$ + Mid$(newconst$,4,1)
      Next

     Case "N"
      Poke.b ?skip_bytes,1
      condata$ = Chr$(10)

     Default
      char1.b = Peek.b(&newconst$)
      char2.b = Peek.b(&newconst$+1)
      nibble1.l = -1
      nibble2.l = -1

      If (char1>=@"0" AND char1<=@"9") Then nibble1 = char1-@"0"
      If (char2>=@"0" AND char2<=@"9") Then nibble2 = char2-@"0"

      If (char1>=@"a" AND char1<=@"f") Then nibble1 = char1-@"a" + 10
      If (char2>=@"a" AND char2<=@"f") Then nibble2 = char2-@"a" + 10

      If (char1>=@"A" AND char1<=@"F") Then nibble1 = char1-@"A" + 10
      If (char2>=@"A" AND char2<=@"F") Then nibble2 = char2-@"A" + 10

      If nibble1>=0 AND nibble2>=0
        newchar.l = (nibble1 LSL 4) + (nibble2)
        condata$ = Chr$(newchar)
        Poke.b ?skip_bytes,2
      EndIf

    End Select
  EndIf
  If condata$ = "" AND Peek.b(?skip_bytes)=0
    !cout{">> " + Peek.s(_myD0-4) }
    !cout{"detected unknown const: [" + newconst$ + "]"}
    condata$ = newconst$
  EndIf

  GetReg D0,FLen(condata$)-1                                    ; laenge zielstring -> Stack
  MOVE.l d0,d2
  MOVE.l d2,-(a7)

  GetReg D0,&condata$                                          ; kopieren des neuen Strings in den Zielstring
  MOVE.l d0,a0

 'l1
    MOVE.b (a0)+,d1
    JSR pokedata1b
 DBF d2,'l1

  !asm
  MOVE.l (a7)+,d0                                          ; laenge Zielstring <- Stack
  MOVE.l (a7)+,d2                                          ; d2 <-Stack
  ADD.l d0,d2                                              ; eingefuegte chars zu D2 dazu
  ADD.l #1,d2

  MOVE.l #0,d0                                             ; a5 um konstantennamen weiterschieben
  MOVE.b skip_bytes,D0
  ADD.l D0,a5
RTS

;  CMP.l #"__DA",1(a5)
;   BEQ 'date
;
;  CMP.l #"__VE",1(a5)
;   BEQ 'versionstring
;
;  CMP.l #"__TH",1(a5)
;   BEQ 'functionname
;
;  CMP.l #"__CO",1(a5)
;   BEQ 'codeline
;
;  CMP.b #"R",1(a5)
;   BNE 'l21
;
;  ADDQ #1,a5
;  JSR get_hexbyte
;  SUBQ #1,d0
;  MOVE.b (a5),d1
;
; 'lr1
;    ADDQ #1,d2
;    BSR.w pokedata1b
;  DBF d0,'lr1
;
;  ADDQ.l #1,a5
;BRA 'writestring
;
; 'l21
;  CMP.b #"n",1(a5)
;   BNE 'l22
;  MOVEQ #$a,d0
;  ADDQ.l #2,a5
;BRA 'l1
;
;'l22
;  JSR get_hexbyte
;BRA 'l1
;
;'date
;  CMP.l #"TE__",5(a5)
;   BNE 'l1b
;  JSR compiledate
;BRA 'l1
;
; 'l1b
;  CMP.l #"TE_G",5(a5)
;   BNE 'l1
;  CMP.l #"ER__",9(a5)
;   BNE 'l1
;  JSR compiledate_ger
;BRA 'l1
;
; 'functionname
;  CMP.w #"IS",5(a5)
;   BNE 'l1
;  JSR insert_functionname
;BRA 'writestring
;
; 'codeline
;  CMP.w #"DE",5(a5)
;   BNE 'l1
;  JSR insert_codeline
;BRA 'l1
;
; 'versionstring
;  CMP.w #"R_",5(a5)
;   BNE 'l1
;  JSR version_string
;
;RTS


checkdoubledeclare                        ; check of double used var names  by bernd roesch  20150315
  MOVEM.l d0-d2/a0-a5,-(a7)
  TST.w proceduremode                                     ;1 in function
  BEQ 'global
  LEA firstglob,a2
  JSR findvariable2
  BEQ 'isused
  MOVE.b #1,newvariable
  LEA firstlocal,a2
  JSR findvariable
  BEQ 'isused
  CLR.b newvariable
  MOVEM.l (a7)+,d0-d2/a0-a5
  RTS

 'global
  JSR findvariable
  BNE 'isunused

 'isused
   MOVE.w lastchar,-(a7)                                  ;get the typename from source
   JSR getparameter2
   MOVE.w (a7)+,lastchar
   MOVE.l $a(a2),a0                                       ; get the name of the type
   LEA $b(a0),a0
   LEA ptr_parameterstore,a1

 'again
   CMPM.b (a0)+,(a1)+                                     ; compare name
   BNE'error
   TST.b (a1)
   BNE 'again                                             ; it is same variable and same type so it is allow to redim or redefine
   TST.b (a0)
   BNE 'error

 'isunused
  MOVEM.l (a7)+,d0-d2/a0-a5
 RTS

 'error
JMP errormsg_declaredtwice


checka4a5
  MOVEM.l a3/d1,-(a7)
                 ; put register a4-a5 to stack if a AOS function use it
  CLR.b a4a5store

 'continue
  MOVE.b (a3)+,d1
  CMP.b #$15,d1
  BEQ 'find
  CMP.b #$14,d1
  BEQ 'find
  CMP.b #$ff,d1
  BNE 'continue
  BRA 'notfind

 'find
  MOVE.l #$48e7000c,d1                  ; write 68k movem.l a4/a5,-(a7)
  JSR writelong
  MOVE.b #1,a4a5store

 'notfind
  MOVEM.l (a7)+,a3/d1
RTS


restorea4a5
  TST.b a4a5store
  BEQ 'no
  MOVE.l #$4cdf3000,d1                  ; write 68k movem.l (a7)+,a4/a5
  JSR writelong
  CLR.b a4a5store

 'no
RTS
; < new

.internal_commands:
.tokens:
INCLUDE "internal_commands.ab3"
Even


.CIF_branches:                                             ;cifbras
           Dc.l cif_lt                                     ;ciflt
           Dc.l cif_eq                                     ;cifeq
           Dc.l cif_gt                                     ;cifgt
           Ds.l 1                                          ;0
           Dc.l cif_le                                     ;cifle
           Dc.l cif_ne                                     ;cifne
           Dc.l cif_le                                     ;cifge
           Ds.l 1                                          ;0
           Dc.l cif_ge                                     ;cifge
           Dc.l cif_ne                                     ;cifne
           Dc.l cif_ge                                     ;cifge
           Ds.l 1                                          ;0

instructionbase:                                                     ;atokens org sourcs
           Dc.l do_newtype                                 ;donewtype
           Dc.l do_end                                     ;doend
           Dc.l do_let                                     ;dolet
           Dc.l do_dim                                     ;dodim
           Dc.l do_goto                                    ;dogoto
           Dc.l do_gosub                                   ;dogosub
           Dc.l do_return                                  ;doreturn
           Dc.l do_statement                               ;dostate
           Dc.l do_function                                ;dofunc
           Dc.l do_mousewait                               ;domwait
           Dc.l do_if                                      ;doif
           Dc.l do_while                                   ;dowhile
           Dc.l do_Macro                                   ;domacro
           Dc.l do_select                                  ;doselect
           Dc.l do_case                                    ;docase
           Dc.l do_default                                 ;dodefault
           Dc.l do_AsmExit                                 ;doasmexit
           Dc.l do_xinclude                                ;doxinclude
           Dc.l do_INCLUDE                                 ;doinclude
           Dc.l do_SYNTAX                                  ;syntaxerr
           Dc.l do_shared                                  ;doshared
           Dc.l do_for                                     ;dofor
           Dc.l do_next                                    ;donext
           Dc.l syntaxerr                                  ; To
           Dc.l syntaxerr                                  ; Step
           Dc.l do_data                                    ;dodata
           Dc.l do_read                                    ;doread

; --
; -- the following should all be intercepted by getchar
           Dc.l syntaxerr                                  ; CNIF
           Dc.l syntaxerr                                  ; CSIF
           Dc.l syntaxerr                                  ; CELSE
           Dc.l syntaxerr                                  ; CEND
           Dc.l do_cerr                                    ;docerr
           Dc.l do_then                                    ;dothen
           Dc.l do_else                                    ;doelse
           Dc.l do_even4                                   ;doeven4
           Dc.l do_even8                                   ;doeven8
;
           Dc.l do_dc                                      ;dodc
           Dc.l do_ds                                      ;dods
           Dc.l do_even                                    ;doeven
           Dc.l do_dcb                                     ;dodcb
           Dc.l do_GetReg                                  ;dosetreg
           Dc.l do_IncBin                                  ;doincbin
           Dc.l do_free                                    ;dofree
           Dc.l do_use                                     ;douse
           Dc.l do_Stop                                    ;dostop
           Dc.l do_Cont                                    ;docont
           Dc.l syntaxerr                                  ;syntaxeer
           Dc.l do_SetInt                                  ;dosetint
           Dc.l do_ClrInt                                  ;doclrint
           Dc.l do_MaxLen                                  ;domaxlen
           Dc.l do_DEFTYPE                                 ;dodeftype
           Dc.l do_BLITZ                                   ;doblitz
           Dc.l do_AMIGA                                   ;doamiga
           Dc.l do_QAMIGA                                  ;doqamiga
           Dc.l do_VWait                                   ;dovwait
           Dc.l do_LibJsr                                  ;dolibjsr
           Dc.l do_TokeJsr                                 ;dotokejsr
           Dc.l do_BLibJsr                                 ;doblibjsr
           Dc.l _extb                                      ;syntaxerr
    ;
    ;A break goes in here for the assembler stuff!
    ;
           Dc.l syntaxerr                                  ;syntaxerr      ;flash2 ; for list
           Dc.l do_SetErr                                  ;doseterr
           Dc.l do_ClrErr                                  ;doclrerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l do_ErrFail                                 ;doerrfail
           Dc.l syntaxerr
           Dc.l syntaxerr                                  ;mod
           Dc.l syntaxerr                                  ;Pi
           Dc.l do_Repeat                                  ;dorepeat
           Dc.l do_Until                                   ;dountil
           Dc.l do_PutReg                                  ;doputreg
           Dc.l do_Pop                                     ;dopop
           Dc.l do_INCDIR                                  ;doincdir
           Dc.l mydo_Endif2                                ;mydoendif2
           Dc.l do_Wend                                    ;dowend
           Dc.l do_SysJsr                                  ;dosysjsr
           Dc.l do_WBStartup                               ;dowbstartup
           Dc.l syntaxerr
           Dc.l do_Ongo                                    ;doongo
           Dc.l syntaxerr
           Dc.l do_Forever                                 ;doforever
           Dc.l do_Restore                                 ;dorestore
           Dc.l do_Exchange                                ;doexchange
           Dc.l do_USEPATH                                 ;dousepath
           Dc.l do_CloseEd                                 ;doclosed
           Dc.l do_NoCli                                   ;donocli
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l syntaxerr                                  ;syntaxerr
           Dc.l do_runerrson                               ;dorunerrson
           Dc.l do_runerrsoff                              ;dorunerrsoff
           Dc.l do_uselastpath
           Dc.l do_regload
           Dc.l do_regsave
           Dc.l do_Object
           Dc.l do_usepath2
           Dc.l do_LastRunErrsMode
           Dc.l do_honitos
atokensend:

;.compilermenu_entries:
;   Dc.b "COMPILER",0
;   Dc.b "COMPILE AND RUN        ",0,"X"
;   Dc.b "RUN                    ",0,"M"
;   Dc.b "CREATE EXECUTABLE      ",0,"E"
;   Dc.b "COMPILER OPTIONS       ",0,"O"
;   Dc.b "CREATE RESIDENT        ",0,";"
;   Dc.b "VIEW NEWTYPES          ",0,"-"
;   Dc.b "CLI ARGUMENT           ",0,"="
;   Dc.b "CALCULATOR             ",0,"H"
;   Dc.b "RELOAD ALL LIBS        ",0,"\"
;   Dc.b "LOAD DEBUG MODULE      ",0,"."
;   ifeq    final
;    Dc.b "PRINT TOKENS"          ",0,0
;   endc
;   Dc.b    0
;   Even



menu_items:Dc.l menu_compile_run                                ;menuadds oreg source
           Dc.l menu_run
           Dc.l menu_createexecutable
           Dc.l menu_dummyfunc                                  ;was menu_compileroptions
           Dc.l menu_createresidentfile
           Dc.l menu_dummyfunc                                  ;was menu_viewnewtypes not needed anymore because is in PED tomsmart1
           Dc.l menu_dummyfunc                                  ;was menu_simcliarguments not needed anymore because is in PED tomsmart1
           Dc.l menu_dummyfunc                                  ;was menu_calculator
           Dc.l menu_reload_userlibs
           Dc.l menu_loaddebugmodule
           Dc.l menu_dummyfunc
           Dc.l menu_newcreate
           Dc.l menu_dummyfunc
           Dc.l menu_toggledebug
           Dc.l menu_createreleaseexe                           ; changed to make it possible to access the routine from PED tomsmart1
           Dc.l menu_dummyfunc
Even4


menu_dummyfunc:
  !basic
  error{!TRANS{"Invalid AmiBlitz3 menu item called!"} }
  !asm
RTS


; --
; -- configuration data for debugger
set_autorun:               Dc.b $00
autorun:                   Dc.b $80,$01,$01,$00,$01

set_interruptcheck:        Dc.b $00
interruptcheck             Dc.b $80,$01,$01,$00,$01

set_assemblercheck:        Ds.b 1
assemblercheck:            Dc.b $00,$01,$01,$00,$01

set_overflowcheck:         Ds.b 1
overflowcheck:             Dc.b $00,$01,$01,$00,$01

default_obsolete:          Dc.b $00,$80,$01,$01,$00,$01
default_interruptcheck:    Dc.b $00,$80,$01,$01,$00,$01
default_overflowcheck:     Dc.b $00,$80,$01,$01,$00,$01
Even4


tsthead:                   Dc.l $000003F3,$00000000,$00000001
                           Dc.l $00000000,$00000000
tstsize1:                  Dc.l $00000100,$000003E9
tstsize2:                  Dc.l $00000100
tstend:                    Dc.l $000003EC
tstsize3:                  Ds.l 2
tstdone:                   Dc.l $000003F2


edstruct:                  Dc.l tokens                     ;data for ted


;                          Dc.l compilermenu_entries
                           Dc.l 0

                           Dc.l read_xtrafile              ;load .xtra routine
                           Dc.l write_xtrafile             ;save .xtra routine
                           Dc.l call_menuentry             ;Menu Routine
                           Ds.l 1                          ;cleanup (?)
                           Dc.b ":",34,".;"
Even4

asmpnts:                   Ds.l 63                                                  ;Ds.l tnum-fnum org source  hat was mit tok zu tun
                           Ds.l 56

;------                                                                             ;disassembled code begin
.objects ;some object codes for compile

lslimm:                    Dc.b $E1,$48                                             ;LSL.W   #8,D0


use:                       Dc.b $26,$6D,$00,$00                                     ;MOVEA.L $0000(A5),A3
                           Dc.b $D6,$C0                                             ;ADDA.W  D0,A3
                           Dc.b $2B,$4B,$00,$00                                     ;MOVE.L  A3,$0000(A5)
usef:                      ;


beginarr:                  Dc.b $20,$3C,$00,$00,$00,$00                             ;MOVE.L  #$00000000,D0


;mularr:                   ;??looks like not used??
                           Dc.b $C0,$C1                                             ;MULU.W  D1,D0


putarr:                    Dc.b $2B,$40 :                            Dc.b $00,$00   ;MOVE.L  D0,$0000(A5)


doarr:                     Dc.b $34,$3C,$00,$00                                     ;MOVE.W  #$0000,D2
                           Dc.b $36,$3C,$00,$00                                     ;MOVE.W  #$0000,D3

;doarrf:                   ;??looks like not used??


;tstword:                  ;??looks like not used??
                           Dc.b $4A,$40                                             ;TST.W   D0


;tstlong:                  ;??looks like not used??
                           Dc.b $4A,$80                                             ;TST.L   D0


nops8:                     Dc.b $4E,$71                                             ;NOP
                           Dc.b $4E,$71                                             ;NOP
                           Dc.b $4E,$71                                             ;NOP
                           Dc.b $4E,$71                                             ;NOP
nops4:                     Dc.b $4E,$71                                             ;NOP
;nops3:                    ;??looks like not used??
                           Dc.b $4E,$71                                             ;NOP
                           Dc.b $4E,$71                                             ;NOP
                           Dc.b $4E,$71                                             ;NOP
nopsf:


dataget:                   Dc.b $26,$6D :                            Dc.b $00,$00   ;MOVEA.L $0000(A5),A3


dataput:                   Dc.b $2B,$4B :                            Dc.b $00,$00   ;MOVE.L  A3,$0000(A5)


stlenget:                  Dc.b $2F,$1B                                             ;MOVE.L  (A3)+,-(A7)


stalign:                   Dc.b $52,$4B                                             ;ADDQ.W  #1,A3
                           Dc.b $C1,$8B                                             ;EXG D0,A3
                           Dc.b $08,$80,$00,$00                                     ;BCLR    #0,D0
                           Dc.b $C1,$8B                                             ;EXG D0,A3
stalignf:


    ;byte...
    ;
dataletb:                  Dc.b $52,$4B                                             ;ADDQ.W  #1,A3
                           Dc.b $1B,$5B,$00,$00                                     ;MOVE.B  (A3)+,$0000(A5)
dataletbf:



dataletbl:                 Dc.b $52,$4B                                             ;ADDQ.W  #1,A3
                           Dc.b $19,$5B,$00,$00                                     ;MOVE.B  (A3)+,$0000(A4)
dataletblf:


dataletb2:                 Dc.b $52,$4B                                             ;ADDQ.W  #1,A3
                           Dc.b $14,$9B                                             ;MOVE.B  (A3)+,(A2)
dataletb2f:


    ;word...
    ;
dataletw:                  Dc.b $3B,$5B,$00,$00                                     ;MOVE.W  (A3)+,$0000(A5)
                           Dc.b $34,$9B                                             ;MOVE.W  (A3)+,(A2)
                           Dc.b $39,$5B,$00,$00                                     ;MOVE.W  (A3)+,$0000(A4)


    ;long...
dataletl:                  Dc.b $2B,$5B,$00,$00                                     ;MOVE.L  (A3)+,$0000(A5)
                           Dc.b $24,$9B                                             ;MOVE.L  (A3)+,(A2)
                           Dc.b $29,$5B,$00,$00                                     ;MOVE.L  (A3)+,$0000(A4)


nextfixw:                  Dc.b $50,$4F                                             ;ADDQ.W  #8,A7


nextfixw2:                 Dc.b $4F,$EF,$00,$0A                                     ;LEA $000A(A7),A7


nextfixl:                  Dc.b $4F,$EF,$00,$0C                                     ;LEA $000C(A7),A7


nextfixl2:                 Dc.b $4F,$EF,$00,$0E                                     ;LEA $000E(A7),A7


nextb:                     ;
                           Dc.b $24,$6F,$00,$04                                     ;MOVEA.L $0004(A7),A2
                           Dc.b $30,$17                                             ;MOVE.W  (A7),D0
                           Dc.b $D1,$12                                             ;ADD.B   D0,(A2)
nextbf:


nextw:                     ;a word type next
                           Dc.b $24,$6F,$00,$04                                     ;MOVEA.L $0004(A7),A2
                           Dc.b $30,$17                                             ;MOVE.W  (A7),D0
                           Dc.b $D1,$52                                             ;ADD.W   D0,(A2)
nextwf:                    ;


nextl:                     ;
                           Dc.b $24,$6F,$00,$08                                     ;MOVEA.L $0008(A7),A2
                           Dc.b $20,$17                                             ;MOVE.L  (A7),D0
                           Dc.b $D1,$92                                             ;ADD.L   D0,(A2)
nextlf:


nextf:                     ;
                           Dc.b $24,$6F,$00,$08                                     ;MOVEA.L $0008(A7),A2
                           Dc.b $20,$12                                             ;MOVE.L  (A2),D0
                           Dc.b $22,$17                                             ;MOVE.L  (A7),D1
                           Dc.b $4E,$AE,$FF,$BE                                     ;JSR -$0042(A6)
                           Dc.b $24,$80                                             ;MOVE.L  D0,(A2)
nextff                     ;


forcompb:                  ;
                           Dc.b $24,$6F,$00,$04                                     ;MOVEA.L $0004(A7),A2
                           Dc.b $10,$12                                             ;MOVE.B  (A2),D0
                           Dc.b $32,$2F,$00,$02                                     ;MOVE.W  $0002(A7),D1
                           Dc.b $4A,$57                                             ;TST.W   (A7)
                           Dc.b $6A,$00,$00,$04                                     ;BPL.W   L000001         ;.skip org source
                           Dc.b $C1,$41                                             ;EXG D0,D1

                                                                                  ;L000001:                  ;.skip org source
                           Dc.b $B0,$01                                             ;CMP.B   D1,D0
forcompbf:                 ;


forcompw:                  ;the For...Next Compare..... for words
                           Dc.b $24,$6F,$00,$04                                     ;MOVEA.L $0004(A7),A2
                           Dc.b $30,$12                                             ;MOVE.W  (A2),D0
                           Dc.b $32,$2F,$00,$02                                     ;MOVE.W  $0002(A7),D1
                           Dc.b $4A,$57                                             ;TST.W   (A7)
                           Dc.b $6A,$00,$00,$04                                     ;BPL.W   L000002         ;.skip org source
                           Dc.b $C1,$41                                             ;EXG D0,D1

                                                                                  ;L000002:                  ;.skip org source
                           Dc.b $B0,$41                                             ;CMP.W   D1,D0
forcompwf:                 ;


forcompl:                  ;
                           Dc.b $24,$6F,$00,$08                                     ;MOVEA.L $0008(A7),A2
                           Dc.b $20,$12                                             ;MOVE.L  (A2),D0
                           Dc.b $22,$2F,$00,$04                                     ;MOVE.L  $0004(A7),D1
                           Dc.b $4A,$57                                             ;TST.W   (A7)
                           Dc.b $6A,$00,$00,$04                                     ;BPL.W   L000003         ;.skip org source
                           Dc.b $C1,$41                                             ;EXG D0,D1

                                                                                  ;L000003:                  ;.skip org source
                           Dc.b $B0,$81                                             ;CMP.L   D1,D0
forcomplf:


forcompf:                  ;floating point for/next compare.....
                           Dc.b $24,$6F,$00,$08                                     ;MOVEA.L $0008(A7),A2
                           Dc.b $20,$12                                             ;MOVE.L  (A2),D0
                           Dc.b $22,$2F,$00,$04                                     ;MOVE.L  $0004(A7),D1
                           Dc.b $08,$2F,$00,$07,$00,$03                             ;BTST    #7,$0003(A7)
                           Dc.b $67,$00,$00,$04                                     ;BEQ.W   L000004
                           Dc.b $C1,$41                                             ;EXG D0,D1

                                                                                  ;L000004:
forcompff:                 ;


forcompf2:                 ;continuation
                           Dc.b $4E,$AE,$FF,$D6                                     ;JSR -$002A(A6)
forcompf2f:                ;


swapd0:                    Dc.b $48,$40                                             ;SWAP    D0


pushindex:                 Dc.b $2F,$0A                                             ;MOVE.L  A2,-(A7)


leaamp:                    Dc.b $45,$ED :                            Dc.b $00,$00   ;LEA $0000(A5),A2
leaamp2:                   Dc.b $20,$0A                                             ;MOVE.L  A2,D0


leaampl:                   Dc.b $45,$EC :                            Dc.b $00,$00   ;LEA $0000(A4),A2


stamp:                     Dc.b $20,$12                                             ;MOVE.L  (A2),D0


stamp2:                    Dc.b $24,$6D :                            Dc.b $00,$00   ;MOVEA.L $0000(A5),A2


stol:                      ;lose string len!
                           Dc.b $58,$4F                                             ;ADDQ.W  #4,A7


pushd0wd:                  Dc.b $3F,$00                                             ;MOVE.W  D0,-(A7)


pushd0l:                   Dc.b $2F,$00                                             ;MOVE.L  D0,-(A7)


movenumrep:                Dc.b $3E,$3C :                            Dc.b $00,$00   ;MOVE.W  #$0000,D7


preplibst:                 Dc.b $45,$EF :                            Dc.b $00,$00   ;LEA $0000(A7),A2


fixlibst:                  Dc.b $4F,$EF :                            Dc.b $00,$00   ;LEA $0000(A7),A7


pushdn:                    Dc.b $2F,$00                                             ;MOVE.L  D0,-(A7)


movea3a7:                  Dc.b $2F,$0B                                             ;MOVE.L  A3,-(A7)


movestst2:                 Dc.b $20,$2F :                            Dc.b $00,$06   ;MOVE.L  $0006(A7),D0
                           Dc.b $3F,$6F,$00,$04,$00,$08                             ;MOVE.W  $0004(A7),$0008(A7)
                           Dc.b $2E,$9F                                             ;MOVE.L  (A7)+,(A7)
movestst2f:


movea7dn:                  Dc.b $20,$2F :                            Dc.b $00,$04   ;MOVE.L  $0004(A7),D0
                           Dc.b $2E,$9F                                             ;MOVE.L  (A7)+,(A7)
;movea7dnf:                ;??looks like not used??


moved0a3:                  Dc.b $26,$40                                             ;MOVEA.L D0,A3


movestdn:                  Dc.b $20,$2D :                            Dc.b $00,$00   ;MOVE.L  $0000(A5),D0


;movea3dn:                 ;??looks like not used??
                           Dc.b $20,$0B                                             ;MOVE.L  A3,D0


putstlen:                  ;push string length
                           Dc.b $2F,$00                                             ;MOVE.L  D0,-(A7)


getstlen:                  ;pop string length
                           Dc.b $20,$1F                                             ;MOVE.L  (A7)+,D0


moverts:                   Dc.b $2F,$57 :                            Dc.b $00,$00   ;MOVE.L  (A7),$0000(A7)


fixstack:                  Dc.b $4F,$EF :                            Dc.b $00,$00   ;LEA $0000(A7),A7


fixq:                      Dc.b $50,$4F                                             ;ADDQ.W  #8,A7


fix1:                      Dc.b $2E,$9F                                             ;MOVE.L  (A7)+,(A7)


movedna3:                  Dc.b $26,$40                                             ;MOVEA.L D0,A3


least:                     Dc.b $45,$EC :                            Dc.b $00,$00   ;LEA $0000(A4),A2


funcst:                    Dc.b $2F,$2C :                            Dc.b $00,$00   ;MOVE.L  $0000(A4),-(A7)


addq4a2:                   Dc.b $58,$4A                                             ;ADDQ.W  #4,A2


;savesbase:                ;??looks like not used??
                           Dc.b $2F,$0B                                             ;MOVE.L  A3,-(A7)

;savesbase2:               ;??looks like not used??
                           Dc.b $2B,$4B,$00,$00                                     ;MOVE.L  A3,$0000(A5)

;savesbasef:               ;??looks like not used??


;ressbase                  ;??looks like not used??
                           Dc.b $26,$5F                                             ;MOVEA.L (A7)+,A3

;ressbase2                 ;??looks like not used??
                           Dc.b $2B,$4B,$00,$00                                     ;MOVE.L  A3,$0000(A5)

;ressbasef                 ;??looks like not used??


;exga4a5                   ;??looks like not used??
                           Dc.b $CB,$4C                                             ;EXG A5,A4


;linka4 ;org source
linksize:                  Dc.b $4E,$54 :                            Dc.b $00,$00   ;LINK    A4,#-$0000


unlinka4:                  Dc.b $4E,$5C                                             ;UNLK    A4


;a2toa7                    ;??looks like not used??
                           Dc.b $2F,$0A                                             ;MOVE.L  A2,-(A7)


;a7toa2                    ;??looks like not used??
                           Dc.b $24,$5F                                             ;MOVEA.L (A7)+,A2


gotocode:                  Dc.b $4E,$F9,$00,$00,$00,$00                             ;JMP $00000000


gosubcode:                 Dc.b $4E,$B9,$00,$00,$00,$00                             ;JSR $00000000

                                                                                  ;L000005:                ;mwait: org source

mwait:                     Dc.b $08,$39,$00,$06,$00,$BF,$E0,$01                     ;BTST    #6,$00BFE001
                           Dc.b $66,$00,$FF,$F6                                     ;BNE.W   L000005       ;mwait: org source
mwaitf:


libreg:                    Dc.b $20,$00                                             ;MOVE.L  D0,D0


libbase:                   Dc.b $2C,$6D :                            Dc.b $00,$00   ;MOVEA.L $0000(A5),A6


libjsr:                    Dc.b $4E,$AE :                            Dc.b $00,$00   ;JSR $0000(A6)


regtransd:                 Dc.b $20,$2D,$00,$00                                     ;MOVE.L  $0000(A5),D0
regtransa:                 Dc.b $20,$6D,$00,$00                                     ;MOVEA.L $0000(A5),A0


;litget                    ;??looks like not used??
                           Dc.b $26,$7C,$00,$00                                     ;MOVEA.L #$00000000,A3
;litget2                   ;??looks like not used??
                           Dc.l $3F1B                                               ;MOVE.W  (A3)+,-(A7)


movea2dn:                  Dc.b $20,$12                                             ;MOVE.L  (A2),D0


moved3a5dn:                Dc.b $20,$2D,$00,$00                                     ;MOVE.L  $0000(A5),D0


stvarget2:                 Dc.b $70,$00                                             ;MOVEQ   #$00,D0
                           Dc.b $2F,$00                                             ;MOVE.L  D0,-(A7)
                           Dc.b $4A,$92                                             ;TST.L   (A2)
                           Dc.b $67,$00,$00,$0E                                     ;BEQ.W   L000006        ;varget2skip org source
                           Dc.b $20,$52                                             ;MOVEA.L (A2),A0
                           Dc.b $59,$48                                             ;SUBQ.W  #4,A0
                           Dc.b $2E,$98                                             ;MOVE.L  (A0)+,(A7)
stvarget2f:                ;
                           Dc.b $4E,$B9,$00,$00,$00,$00                             ;JSR $00000000
                           ;
varget2skip:               ;                                                      ;L000006:                 ;varget2skip org source


addcode:                   Dc.b $20,$1F                                             ;MOVE.L  (A7)+,D0
                           Dc.b $D1,$97                                             ;ADD.L   D0,(A7)
;addcodef                  ;??looks like not used??


pushlen:                   Dc.b $2F,$18                                             ;MOVE.L  (A0)+,-(A7)


leaa5d3a2:                 Dc.b $45,$ED :                            Dc.b $00,$00   ;LEA $0000(A5),A2


pusha2:                    Dc.b $2F,$0A                                             ;MOVE.L  A2,-(A7)


;geta2                     ;??looks like not used??
                           Dc.b $24,$57                                             ;MOVEA.L (A7),A2


pulla2:                    Dc.b $24,$5F                                             ;MOVEA.L (A7)+,A2


pulla2st:                  Dc.b $24,$6F,$00,$04                                     ;MOVEA.L $0004(A7),A2
                           Dc.b $2E,$9F                                             ;MOVE.L  (A7)+,(A7)
pulla2stf:                 ;


pusha3:                    Dc.b $2F,$2D :                            Dc.b $00,$00   ;MOVE.L  $0000(A5),-(A7)
pusha32:                   Dc.b $2B,$4B :                            Dc.b $00,$00   ;MOVE.L  A3,$0000(A5)
pusha3f:


pulla3:                    Dc.b $2B,$5F :                            Dc.b $00,$00   ;MOVE.L  (A7)+,$0000(A5)
pulla3f:


geta3:                     Dc.b $26,$6D :                            Dc.b $00,$00   ;MOVEA.L $0000(A5),A3
geta3f:


numtoa0:                   Dc.b $20,$7C,$00,$00,$00,$00                             ;MOVEA.L #$00000000,A0


numtoa2:                   Dc.b $24,$7C,$00,$00,$00,$00                             ;MOVEA.L #$00000000,A2


                           ;free up all arrays code
endarray:                  Dc.b $38,$3C :                            Dc.b $00,$00   ;MOVE.W  #$0000,D4


;preparray                 ;??looks like not used??
                           Dc.b $34,$3C,$00,$00                                     ;MOVE.W  #$0000,D2
                           Dc.b $36,$3C,$00,$00                                     ;MOVE.W  #$0000,D3
;preparrayf                ;??looks like not used??


;dimbegin:                 ;??looks like not used??
                           Dc.b $20,$3C,$00,$00,$00,$04                             ;MOVE.L  #$00000004,D0
;dimbeginf:                ;??looks like not used??


;dimb4:                    ;??looks like not used??
                           Dc.b $2B,$40,$00,$00                                     ;MOVE.L  D0,$0000(A5)
;dimb4f:                   ;??looks like not used??


;dimaf:                    ;??looks like not used??
                           Dc.b $C0,$C1                                             ;MULU.W  D1,D0
;dimaff:                   ;??looks like not used??

;dimfin:                   ;??looks like not used??
                           Dc.b $2B,$40,$00,$00                                     ;MOVE.L  D0,$0000(A5)
;dimfinf:                  ;??looks like not used??


movea0:                    Dc.b $24,$52                                             ;MOVEA.L (A2),A2


adda0a0:                   Dc.b $D5,$CA                                             ;ADDA.L  A2,A2
                           Dc.b $D5,$CA                                             ;ADDA.L  A2,A2


;getebase:                 ;??looks like not used??
                           Dc.b $2C,$78,$00,$04                                     ;MOVEA.L $0004,A6
;getebasef:                ;??looks like not used??


movea5a0:                  Dc.b $24,$6D :                            Dc.b $00,$00   ;MOVEA.L $0000(A5),A2


movea0a0:                  Dc.b $24,$6A :                            Dc.b $00,$00   ;MOVEA.L $0000(A2),A2


addqa0:                    Dc.b $52,$4A                                             ;ADDQ.W  #1,A2


leaa0a0:                   Dc.b $45,$EA :                            Dc.b $00,$00   ;LEA $0000(A2),A2


addrega2:                  Dc.b $D4,$C0                     ;ADDA.W  D0,A2

;------                                                     ;disassembled code end
;tstname:                  ;??looks like not used??
                           Dc.b "ram:test",0
Even

;-----------end of object codes!--------------;
;memat:                    ;??looks like not used??
                           Dc.l  0                          ;was  Ds.w 3 org source
;memlen:                   ;??looks like not used??
                           Dc.w  0

.memstackf:   ;
_mathffpbase:              Ds.l 1                           ;maths org source
regnum:                    Ds.w 1                           ;regat org source       ;register being used!
typelen:                   Ds.w 1
prevtype:                  Ds.l 1
lastsourcepos:             Ds.l 1                           ;prevloc org source
lastchar:                  Ds.w 1
thistype:                  Ds.l 1
errstack:                  Ds.l 1
errcont:                   Ds.l 1
linemode:                  Ds.w 1                          ;0 if norm, 1 if newtype
linesleft:                 Ds.w 1
sourceline:                Ds.l 1                          ;thisitem org source
varbase:                   Ds.l 1                          ;firstvar org source
alllocals:                 Ds.l 1
firstlocal:                Ds.l 1
firstglob:                 Ds.l 1
globalvarpointer:          Ds.w 1                          ;varoff org source
locvaroff:                 Ds.w 1
firstitem_:                Ds.l 1
numlines_org:              Ds.w 1                          ;numlines org source
returncode_org:            Ds.w 1                          ;returncode org source
firstiff:                  Ds.l 1                          ;firstif org source
str_mathffpname:           Dc.b "mathffp.library",0 : Even ;mathsname org source
str_tempfilename:          Ds.b #MAX_STRINGSIZE
str_temp_debugmodulename:  Ds.b #MAX_STRINGSIZE            ;dname org source
ptr_temp_debugmodule:      Ds.l 1                          ;dname2 org source
Even


.icongfx_data:                                             ;objicon org sourcename
  Dc.b $E3,$10,$00,$01                                     ;icondata  
  Dc.b $00,$00,$00,$00
  Dc.b $00,$19,$00,$11
  Dc.b $00,$2E,$00,$18
  Dc.b $00,$04,$00,$03
  Dc.b $00,$01,$00,$22
  Dc.b $73,$68,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $03,$22,$00,$21
  Dc.b $3C,$28,$00,$22
  Dc.b $6E,$C0,$00,$00
  Dc.b $00,$12,$00,$00
  Dc.b $00,$0E,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$2E
  Dc.b $00,$17,$00,$02
  Dc.b $00,$01,$8E,$80
  Dc.b $03,$00,$00,$00
  Dc.b $00,$00,$FF,$FF
  Dc.b $FF,$FF,$FF,$FC
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$3F,$BB,$40
  Dc.b $80,$1F,$C0,$00
  Dc.b $00,$00,$80,$3F
  Dc.b $C0,$0F,$BB,$40
  Dc.b $80,$1F,$C0,$00
  Dc.b $00,$00,$8E,$00
  Dc.b $F8,$00,$00,$00
  Dc.b $8F,$01,$FF,$00
  Dc.b $3B,$40,$81,$E3
  Dc.b $F7,$C0,$00,$00
  Dc.b $80,$7F,$F8,$70
  Dc.b $3B,$40,$80,$0F
  Dc.b $7C,$E0,$00,$00
  Dc.b $80,$00,$FD,$80
  Dc.b $00,$00,$80,$01
  Dc.b $F6,$00,$FB,$40
  Dc.b $80,$03,$EF,$00
  Dc.b $00,$00,$80,$07
  Dc.b $87,$80,$3B,$40
  Dc.b $80,$0F,$01,$C0
  Dc.b $00,$00,$80,$03
  Dc.b $F0,$70,$1D,$40
  Dc.b $80,$00,$18,$1C
  Dc.b $00,$00,$80,$00
  Dc.b $10,$06,$03,$40
  Dc.b $80,$00,$20,$1F
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$01,$40
  Dc.b $80,$00,$00,$00
  Dc.b $00,$00,$80,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $00,$3F,$FC,$01
  Dc.b $BB,$44,$00,$60
  Dc.b $FE,$00,$00,$04
  Dc.b $00,$CF,$FF,$01
  Dc.b $BB,$44,$1F,$EF
  Dc.b $FF,$00,$00,$04
  Dc.b $33,$FF,$FF,$E0
  Dc.b $00,$04,$37,$FE
  Dc.b $7F,$FC,$1B,$44
  Dc.b $0F,$9C,$FF,$FF
  Dc.b $00,$04,$03,$E3
  Dc.b $FF,$FF,$DB,$44
  Dc.b $00,$7F,$BF,$FF
  Dc.b $80,$04,$00,$0F
  Dc.b $3F,$FE,$00,$04
  Dc.b $00,$06,$7F,$F8
  Dc.b $1B,$44,$00,$0C
  Dc.b $F7,$FC,$00,$04
  Dc.b $00,$19,$F9,$FE
  Dc.b $1B,$44,$00,$33
  Dc.b $FE,$7F,$00,$04
  Dc.b $00,$0F,$FF,$BF
  Dc.b $CD,$44,$00,$03
  Dc.b $EF,$EF,$F0,$04
  Dc.b $00,$00,$7F,$DF
  Dc.b $FB,$44,$00,$00
  Dc.b $FF,$A7,$FC,$04
  Dc.b $00,$00,$7E,$3F
  Dc.b $FD,$44,$00,$00
  Dc.b $00,$00,$00,$04
  Dc.b $7F,$FF,$FF,$FF
  Dc.b $FF,$FC,$00,$00
  Dc.b $00,$01,$00,$00
  Dc.b $00,$00,$04
.icongfx_data_end:                                            ;objiconf org source

str_infoextention2:  Dc.b ".info",0                           ;infoname org source
errorlimit_text:     Dc.b "There are too much errors, compiling will stop now. Please fix errors first and try again",0
Even

sysdebug:            Dc.l $3F0
Even


.bigallox
 !basic
 If config\OnePassCompiling = True
   maxmem.l = (AvailMem_ (#MEMF_PUBLIC) LSR 2)  ; 1/4 of the available free mem
   objectlength.l = Peek.l(?objlen)
   If Peek.b(?use_debugger) = 0
     If (objectlength < 3670056) AND (maxmem > 3670056)
       MOVE.l #3145727,d2     ; objectbuffersize
       MOVE.l  #262143,d3     ; libsbuffersize
       MOVE.l  #131071,d4     ; systembuffersize
       MOVE.l  #131071,d5     ; databuffersize
       JSR makeallox  ; added 40 buffer more
       !basic
     Else
       If (objectlength < 1572904) AND (maxmem > 1572904)
         !asm
         MOVE.l #1310719,d2     ; objectbuffersize
         MOVE.l  #131071,d3     ; libsbuffersize
         MOVE.l   #65535,d4     ; systembuffersize
         MOVE.l   #65535,d5     ; databuffersize
         JSR makeallox ; added 40 buffer more
         !basic
       EndIf
     EndIf
   Else
     maxmem LSL 1 ; for debug test for 1/2 of the available mem
     If (objectlength < 12058664) AND (maxmem > 12058664)
       MOVE.l #5242879,d2     ; objectbuffersize
       MOVE.l  #262143,d3     ; libsbuffersize
       MOVE.l #6291455,d4     ; systembuffersize
       MOVE.l  #262143,d5     ; databuffersize
       JSR makeallox ; added 40 buffer more
       !basic
     Else
       If (objectlength < 6094888) AND (maxmem > 6094888)
         !asm
         MOVE.l #2621439,d2     ; objectbuffersize
         MOVE.l  #262143,d3     ; libsbuffersize
         MOVE.l #3145727,d4     ; systembuffersize
         MOVE.l   #65535,d5     ; databuffersize
         JSR makeallox ; added 40 buffer more
         !basic
       EndIf
     EndIf
   EndIf
   If objectlength = Peek.l(?objlen)    ; test if big allox failed
      !asm                              ; yes it fails
        BSET #$7,make_smallestcode      ; active make small code again to prevent endless compile runs
      !basic
   EndIf
 EndIf
 !asm
RTS

.menu_createreleaseexe:                               ; moved from PED to create minimized exe size = release exe  tomsmart1
 !basic
   releaseexe = True                                  ; set release modus to on
   !ComData_GetW{comWord_CreateDebugFile,D0}          ; get the status for creating .dbg file
   PutReg d0, releasedbg_save                         ; save the status
   !ComData_SetW{comWord_CreateDebugFile,#0}          ; set it of so it will not create with every needed compile run
   releasemakesmall_save = Peek.b(?make_smallestcode) ; save the status of make smallest code
   Poke.b ?make_smallestcode,-128                     ; set it on so we can create a minimized exe and we don't need to set it manuely in the compiler settings
   !ComData_GetB{comByte_FuncOptimize,D0}             ; get the status of function optimizer
   PutReg d0, releasefuncoptimize_save                ; save it
   !ComData_SetB{comByte_FuncOptimize,#1}             ; set it on
   releasedebugger_save = Peek.b(?use_debugger)       ; save the status of the use of the debugger
   Poke.b ?use_debugger,0                             ; set if off because we create a release verion and need no debugging code
 !asm
 JSR menu_newcreate                                   ; jump to start the compiling
 !regs2stack                                          ; save the registers
 !basic
   releaseexe = False                                 ; set creat release exe off
   GetReg D0,releasedbg_save                              ; set the old status of create .dbg file back
   !ComData_SetW{comWord_CreateDebugFile,D0}          ;                      "
   Poke.b ?use_debugger,releasedebugger_save          ; set the old status of use Debugger back
   GetReg D0,releasefuncoptimize_save                     ; set the old status of function optimizer back
   !ComData_SetB{comByte_FuncOptimize,D0}             ;                       "
   Poke.b ?make_smallestcode,releasemakesmall_save    ; set the old status of make smallest code back
 !asm
 !stack2regs                                          ; set registers back
RTS


.clear_lastcompileerrordatas     ; added to fix hits by errormessages for Residents by load- and switching the sourcecode tomsmart1 2016.02.02
  MOVE.l #0,beforeparameterfetch ; reset so no code will detoken , fix the hit
  MOVE.w #0,ininclude            ; reset we have no include code , fix the endless loop
  MOVE.l #-1,compilelinecounter  ; reset the line we have compiled
  MOVE.l #0,globallinecount      ; reset the linecounter
RTS

.check_fpu_before_run:
  MOVEQ #0,d0
  !basic
  check_fpu_mode.b = Peek.b(?fpu) AND $2
  If check_fpu_mode
    If ProcessorFPU = 0
      error{"The generated code has been optimized to use FPU-features,\\nbut no FPU is present on this system.\\n\\nExecution ist not possible."}
      !asm
      MOVEQ #1,d0
      RTS
    End If
  End If
  !asm
RTS


;------------------------------- for debugging purpose only ------------------
showdebug
  !regs2stack
  !basic
  tmp_token.w = PutRegD0
  tmp_libnum.b = tmp_token LSR 7
If tmp_libnum = -129
  !cout{"Token " + Hexw$(tmp_token) + "  Libnum: " + Str$(tmp_libnum)}
EndIf
  !asm
  !stack2regs
RTS

.honitos_data:
  !basic
  MOVE a4,d0
  GetReg D0,d0.l
  adr.l = Peek.l(d0)
  address.l = Peek.l(?currentfunccall)
  parameter_count.b = Peek.b(address + $4) AND 15
  string_counter.b = Peek.b(address + $4) LSR 4
  returnpar.b = Peek.b(address + $5)

  ptr_varlist.l = address + $16
  types$ = ""
  runner.b = 0
  For runner = 0 To parameter_count - 1
    types$ + Str$(Peek.b(ptr_varlist + runner)) + " "
  Next runner

  pcount2.b = Peek.b(address + $20)
  flag.b = Peek.b(address + $60)
  name$ = Peek$(address + $61)

  info$ = "----------------- name: (" + name$ + ") address: " + Hex$(address) + "  Flag $60: "+ Hex$(flag)
  !cout{info$}
  !cout{"- parameters $4: ", Bin$(parameter_count), " pcount $20: ", Bin$(pcount2) }
  !cout{"- types      $16: ", types$, " string_counter: ", string_counter}
  !asm
RTS

Even
lock_exepath              Ds.l 1



includesourceline    Dc.l 0
linenum              Ds.l 1
globallinecount      Ds.l 1
myversion            Dc.b "\\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH (\\__DATE_GER__) Build \\__VER_BUILD",0 : Even
calc_option          Dc.l 1
versioninformation   Dc.l $00
number_of_builds     Dc.l $00
leftsideflagmask     Ds.w 1    ;this contain the flag if pointer (1) or not
rightsideflagmask    Ds.w 1

BSS
debugnest            Ds.w 1
instringf            Ds.l 1
funcscanon           Ds.l 1
storedebugmode       Ds.b 20
firsttimepref        Ds.l 1
funcparloop          Ds.b 1                   ; is 1 when function calling parameter are compile
blitzparloop         Ds.b 1                   ; is 1 when blitzlib calling parameters are compile
nostringopt          Ds.w 1
path2:               Ds.l 32
typebase             Dc.l 0
doublepeek           Dc.w 0
lastoffset           Dc.l 0
firsttime            Dc.w 0
lastdestpointer      Dc.l 0
prevwritedat         Dc.l 0
lastsourceline       Dc.l 0
lastwritedat         Dc.l 0
makeexec             Dc.w 0
makeexec_remember    Dc.w 0
sharebase            Ds.l 1
tempa7               Ds.l 1
incnif               Ds.w 1
tempstore            Ds.l 1
result               Ds.l 1
automode             Ds.w 1
stackcorrect         Ds.w 1
formode              Ds.w 1
limitregs            Ds.l 1
onestep              Ds.w 1
reqmode              Ds.l 1
inctab               Ds.l 40
funcoptimize_deprecated  Ds.w 1 ; deprecated, see comByte_FuncOptimize ; Wanderer
includeline          Ds.l 1
morememadd           Ds.l 1
objectcount          Ds.w 1
savefuncspace        Ds.l 1
lasttrap1            Ds.l 1
currentfunccall      Ds.l 1
skipfunc             Ds.b 1
resdisable           Ds.b 1
skiptoggle           Ds.b 1
developobject        Ds.b 1
iniffcommand         Ds.w 1
startoffsetmore      Ds.w 1
olddebugmode         Ds.w 1
fpucodeglobal        Ds.l 1
fpucodelocal         Ds.l 1
maxregs              Ds.l 1
fpucode              Ds.l 1
firstmline           Ds.w 1
regtable             Ds.l 16
exdebug              Ds.w 1
a2offset2            Ds.w 1
parnumtemp           Ds.l 1
doimmediate          Ds.b 1
notypecheck          Ds.b 1
vartype              Ds.w 1
peekaddrsize         Ds.b 1
declare2             Ds.b 1
parameternum         Ds.w 1
lasttoken            Ds.l 1
newvariable          Ds.w 1
declare              Ds.b 1
typecheck            Ds.b 1
nowdeclare           Ds.b 1
dimkeep              Ds.b 1
a4a5store            Ds.b 1
___freetouse         Ds.b 1
firstiffstore        Ds.l 1
destpointer2         Ds.l 1
stackaddr            Ds.l 1
allowtab             Ds.b 260
templine             Ds.b 256
thenmode             Ds.w 1
temp                 Ds.w 1
tempregnum           Ds.w 1
;quickpeek            Ds.w 1
numlines2            Ds.l 1
numlines             Ds.l 1
exmac                Ds.w 1
returncode           Ds.w 1
fp0iff               Ds.l 1
fp0addr              Ds.l 1
fp0mode              Ds.w 1
fp0var               Ds.w 1
fastfunc             Ds.w 1
retmode              Ds.w 1
parnum               Ds.w 1
regmask              Ds.w 1
regnumfunc           Ds.w 1
libmode              Ds.w 1
oldline              Ds.l 1
sourceline3          Ds.l 1
debugstore           Ds.b 200
deststore            Ds.l 1
;_Screen              Ds.l 1
loada                Ds.l 1
;_intuibase           Ds.l 1
currtype             Ds.l 1
arrayoffset          Ds.l 1
lastlabel            Ds.l 1
curtemplabel         Ds.l 1
sourceline2          Ds.l 1
chartab              Ds.b 256
tempspace            Ds.b 384   ; was 120 change because it used as temp exepath save and it can be up to 384 bytes!  tomsmart1
instrtab             Ds.l 65538*2
; by every compile pass the content beginning from label labelhash to bssstore are cleared!
labelhash            Ds.l 8192                             ;-bssstore clear every compile pass
replacedat           Ds.w 65538
variablehash         Ds.l 8192
newinitaddr          Ds.l 1
realbssend           Ds.l 1
saved0               Ds.w 1
lastpath             Ds.b 128
lastpath2            Ds.b 128
fpustackbase         Ds.w 100
lastconstantvalue    Dc.l 0  ; the value of the constant expression used in Function Parameter.check isconstantvalue <> 0 if its valid
isconstantvalue      Dc.w 0  ; contain a type (1-7) if a constant expression is used as a Parameter or on right side of =
lastfunction         Dc.l 0  ; the address of the function in the Parameter or rght side of =
leftsidetype         Dc.l 0  ;this contain the address of the type from the left side of the variable assign
rightsidetype        Dc.l 0  ; same as above but right side
bssstore

trap15temp           Ds.l 1
trap15temp2          Ds.l 1
templibend           Ds.l 1
tempdata1start       Ds.l 1
stacktrack           Ds.l 1
pad                  Ds.l 1
includetemp          Ds.b 256
includetemp2         Ds.b 256*10
funccall             Ds.w 1
;progressrp           Ds.l 1
;_gfxbase             Ds.l 1
ptr_resfile          Ds.l 1
CalculatorButtonBinFlag:    Ds.w 1
CalculatorButtonDecFlag:    Ds.w 1
ped_startup_addr:    Ds.l 1
skip_bytes:          Ds.b 1
functionreturntype   Ds.l 1  ; a temp store of it.do not read this value
beforeparameterfetch Ds.l 1
typetocast           Ds.l 1
errorcounter         Ds.l 1
iserror              Ds.b 1
MorphOS:             Ds.b 1 ; added to be able to select the cacheclear function 0=AOS, 1=MorphOS  tomsmart1
log_blitzlibs:       Ds.b 1
Even

CLIMode:             Dc.l 0
XTRAEndPadBytes:     Dc.l 0                             ; 4 fill/pad/termination bytes for the xtra write function  tomsmart1
maxerrorcount:       Ds.l 1                             ; added to make it changeable in CLI Mode tomsmart1
