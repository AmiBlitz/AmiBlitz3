; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "///Debug"
; ExeFile         = "REDDebugger"
; CreateIcon      = 0
; Residents       = "all.res,asmmacs.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 3.6.7
; NumberOfBuilds  = 3
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 1
; OverflowCheck   = 1
; AssemblerCheck  = 1
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 5
; CursorColumn    = 1
; LabelSearch     = "$ver"
; LabelRemark     = 0
; LabelAll        = 1
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 50
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 50
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 50
; Max BlitzFont   = 4
; Max GTList      = 50
; /XTRA
; Changelog

; 2.73
; recompiled with updated (fpuless) Val()-command
;
; 2.72
; change save and readpath to Blitz3:Debug
; replaced Peek$() with Peek.s()

; 2.71
; add version check of needed Librarys
; extend OS check to check for MOS to because MOS behaves like OS3
; change Versionstring to Buildsystem

; 2.70
; add a check for OS4 to remove the programsize Bug

; 2.69
; changed: fixes a forgotten peeks()

; 2.68
; changed: replaced PeekS() with Peek.s()

; 2.67
; ??

; 2.66
; changed:  old Blitz2:-Assigns updated to Blitz3
; changed:  requester
; changed:  helpfunction uses AB3HelpViewer now


; LIBRARY CHANGES MADE TO ACIDLIBS:
;  DebugLib      - Loads of changes including extra handlers,
;                  new return values of extra TRAP checking
;                  BLITZ MODE support - special controls
;  Switchlib     - BLITZ MODE support - special controls
;  StringFuncLib - Hexb$, Hexw$, Binb$, Binw$
;  ValLib        - ValLong()
;  Gadgetslib    - New prop gadget commands / Arrow Gadgets

; EXTRA LIBS NEEDED to compile:
;  LESDebugLib   - custom commands for the debugger
;                  (including COPPER disasm)
;  RIDisAsm      - Program disassembly
;  NeilsReqtoolsLib
;  RISortLib     - sorting names into alphabetical order

; LIBS NEEDED to use:
;  DebugLib      - MUST HAVE THIS UPDATE INSTALLED!
;  Switchlib     - MUST HAVE THIS UPDATE INSTALLED!
;  RIDebugLib    - optional but very useful

; Written by
;  different people


;***********************************************************

optimize 5 ; don't use fpu because all calc must in FFP!!!!
Syntax 6

XINCLUDE "error.include.ab3"
XINCLUDE "dos.include.ab3"
XINCLUDE "/Shared/common.ab3"
XINCLUDE "/Shared/ted.include.ab3"
XINCLUDE "rastport.include.ab3"
XINCLUDE "useful.include.ab3"
XINCLUDE "asl.include.ab3"

SystemBitMap 1
; Constants
; ATTENTION dont use variable i (it is the sourceline address)
#longs                  = 0    ; show mem in longs  (not yet)
#lowestaddr             = 1024 ; to avoid enforcer hits
#maxhistory             = 10

;Debuginfo in Code
;trap #1     structsize = 10 ($a)Bytes
;dc.l sourcelineaddr from ted
;dc.w 9
;dc.w offset to next trap #1

#test                   = 0
#BACKGROUND_DBUG        = 1

#maxheight_ever         = 2048

#save_numwindows        = 13
#wizardwindows          = 24

#IDENTIFIER             = $44425547 ; "DBUG"
#MAXCUSTOMCOMMANDS      = 20

#bufflen                = 4096
#buffand                = #bufflen-1

; Evaluate request types:
#_null00                = 0
#_memwindow             = 1
#_newtypewindow         = 2 ; REMOVED
#_newtypewindowmax      = 3 ; REMOVED
#_variablelocate        = 4
#_disasmaddress         = 5
#_autoevalresult        = 6
#_discopaddress         = 7
#_arrayfind             = 8
#_structaddress         = 9
#_mouseable_eval        = 10
; EXECute types:
#_viewblitz             = 50
#_newtypewindow         = 51

; Window allocation
#_winSource             = 0
#_winControl            = 1
#_winRegisters          = 2
#_winBackdrop           = 3
#_winMemory1            = 4
#_winMemory2            = 5
#_winSearch             = 6
#_winVariables          = 7
#_winDisAsm             = 8
#_winDisCop             = 9
#_winCustom             = 10
#_winArray              = 11
#_winMouseables         = 12
#_winObject0            = 13
#_winObject9            = 22
#fpuwin                 = 23
#bubble                 = 24
#noresize               = %10001000010   ; bits represent windows

; Windows that require the special gadget down handling
; (provides 'key repeat' type handling for gadgets)
; If not set here, a windows #IDCMP_GADGETDOWN events are ignored
#gadgetdown             = %11111111111111111110000000000000+(0 BitSet #_winSource)+(0 BitSet #_winMouseables)+(0 BitSet #_winArray)
; Gadgets
#SRC_SGAD               = 1 ; Source window
#SRC_LGAD               = 2
#SRC_RGAD               = 3
#MSE_SGAD               = 4 ; Mouseables window
#MSE_UGAD               = 5
#MSE_DGAD               = 6
#OBJ_SGAD               = 7
#OBJ_UGAD               = 8
#OBJ_DGAD               = 9
#ARR_YGAD               = 10
#ARR_XGAD               = 11
#ARR_UGAD               = 12
#ARR_DGAD               = 13
#ARR_LGAD               = 14
#ARR_RGAD               = 15

; Debug library commands:
#_addtrace              = 255
#_deltrace              = 254
#_varwindow             = 253
#_diswindow             = 252
#_copperlist            = 251
#_proccontrol           = 250
#_memwindowmove         = 249

; Variable types
#_byte                  = 1
#_word                  = 2
#_long                  = 3
#_string                = 4
#_quick                 = 5
#_float                 = 6

#SCR_WB                 = 0
#SCR_LIKEWB             = 1
#SCR_CUSTOM             = 2
#SCR_DEFPUB             = 3
#SCR_NAMEDPUB           = 4

; Max breakpoints
#maxbreakpoints         = 5

; Breakpoint types
#break_permanent        = 1
#break_count            = 2
#break_simple           = 3
#break_countdown        = 4

; Windows that cannot be opened from LoadConfig in openwindow
#winprotect             = %100000001010

#RUNNING                = 0
#TRACE                  = 1
#STOPPED                = 2
#BLITZMODE              = 3

#NOSIGNAL               = 0
#SIGNAL                 = 1

; Screentags tags
#Left                   = $80000021
#Top                    = $80000022
#Width                  = $80000023
#Height                 = $80000024
#_Depth                 = $80000025
#DetailPen              = $80000026
#_BlockPen              = $80000027
#Title                  = $80000028
#Colors                 = $80000029
#ErrorCode              = $8000002A
#Font                   = $8000002B
#SysFont                = $8000002C
#_Type                  = $8000002D
#_BitMap                = $8000002E
#PubName                = $8000002F
#PubSig                 = $80000030
#PubTask                = $80000031
#DisplayID              = $80000032
#DClip                  = $80000033
#Overscan               = $80000034
#Obsolete1              = $80000035

#ShowTitle              = $80000036
#Behind                 = $80000037
#_Quiet                 = $80000038
#AutoScroll             = $80000039
#Pens                   = $8000003A
#FullPalette            = $8000003B
#ColorMapEntries        = $8000003C
#Parent                 = $8000003D
#Draggable              = $8000003E
#Exclusive              = $8000003F

#SharePens              = $80000040
#BackFill               = $80000041
#_Interleaved           = $80000042
#Colors32               = $80000043
#VideoControl           = $80000044
#FrontChild             = $80000045
#BackChild              = $80000046
#LikeWorkbench          = $80000047
#Reserved               = $80000048

#AUTOKNOB               = $0001 ; this flag sez:  gimme that old auto-knob
#FREEHORIZ              = $0002 ; if set, the knob can move horizontally
#FREEVERT               = $0004 ; if set, the knob can move vertically
#PROPBORDERLESS         = $0008 ; if set, no border will be rendered
#KNOBHIT                = $0100 ; set when this Knob is hit
#PROPNEWLOOK            = $0010 ; set this if you want to get the new
                                ; V36 look
#GFLG_RELBOTTOM         = $0008 ; set if rel to bottom, clear if to top
#GFLG_RELRIGHT          = $0010 ; set if rel to right, clear if to left

; set the GFLG_RELWIDTH bit to spec that Width is relative to width of screen
#GFLG_RELWIDTH          = $0020

; set the GFLG_RELHEIGHT bit to spec that Height is rel to height of screen
#GFLG_RELHEIGHT         = $0040

#RIGHTREL               = %1
#BOTTOMREL              = %10
#RIGHTBORDER            = %100
#BOTTOMBORDER           = %1000

#VPROP_AFLAGS           = #GFLG_RELRIGHT|#GFLG_RELHEIGHT
#VPROP_PFLAGS           = #AUTOKNOB|#FREEVERT|#PROPBORDERLESS|#PROPNEWLOOK
#HPROP_AFLAGS           = #GFLG_RELBOTTOM|#GFLG_RELWIDTH
#HPROP_PFLAGS           = #AUTOKNOB|#FREEHORIZ|#PROPBORDERLESS|#PROPNEWLOOK

#RK_HELP                = $5F

; OS Version to enable/disable various features
#AmigaOS3 = 1
#AmigaOS4 = 2
#MorphOS  = 3
#AROS     = 4

;***********************************************************
; Newtypes
Macro versions
  "\\__VER_MAJOR.\\__VER_MINOR"
End Macro


NEWTYPE .prefstype

  fontname.s
  fontsize.l
End NEWTYPE


NEWTYPE.wininfotype

  x.w
  y.w
  w.w
  h.w
  flags.l
  title.s
  gadlist.w
  helplink.l
End NEWTYPE


NEWTYPE.variabletype


  address.l ; address of variable
  typ.b     ; type = 1-6
  form.b    ; 0 = dec, 1 = hex, 2 = binary
  name.s     ; name of variable
End NEWTYPE


NEWTYPE.d_event ; a debug event!
                ;
  t.w           ; type...0=supervisor error
                ;        1 = user error
                ;        2 = eval result
                ;        3 = trace this line...
                ;        4 = end
                ;
  i.w           ; buffer put val!
  s$            ; string
                ;
End NEWTYPE


NEWTYPE.structurewindow
  objadr.l      ; Object type definition address
  objbaseadr.l  ; BASE address for object, e.g. addr object(0)
  typepointer.l ; Address of object
  mem_type.l    ; Pointer to block of mem holding type information

  type_sizeof   ; Sizeof.type
  winnum.b      ; Allocated window for object
  numitems.b
  is_bbobject.w ; Is this a Blitz object type?
  tracenum.w    ; Currently traced number
  maxobject.w   ; Maximum object number
  typewidth.w   ; Max width of \type text
  t$            ; Name of type
End NEWTYPE


; Info block returned from RTEZScreenModeRequest
;NEWTYPE.screeninfo
;
;  id.l         ; Screen mode ID
;  width.w      ; width
;  height.w     ; height
;  _depth.w     ; depth
;  overscan.w   ; overscan type
;  autoscroll.l ; autoscroll status
;End NEWTYPE


;***********************************************************
; Variable type declarations
DEFTYPE.b dowin,objectbusy,pmode,pmodevalid,end_init
DEFTYPE.b evalrequest,execrequest,autoeval
DEFTYPE.b kbshift,nt,nf,flag,editflag
DEFTYPE.b mflag,winnum,searchtype,memchecktimer
DEFTYPE.w gosubstatus,bitm,tokenise,exitflag
DEFTYPE.w reply,num,tracenum,xadm,pfregs
DEFTYPE.w wx,wy,sw,sh,a,mytype,jump,mylen,maxheight
DEFTYPE.w Ascii,mysr,old_dstatus,procstatus,blitzcontrol
DEFTYPE.w xarraynum,yarraynum,arraytype,xarrayoff,yarrayoff
DEFTYPE.w swidth,sheight,arraydatasize,arraylabelsize,arrayitemsize
DEFTYPE.w bp,evalrequestex,num_mouseables,mouseables_off
DEFTYPE.w old_active_win,active_win,n,source_char_offset
DEFTYPE.w scrmode,signal,newted
DEFTYPE.l disasm_ad,typepointer,maxobject,ad,si,areg,old_ad,ad1,ad2
DEFTYPE.l ev,evq,evw,mem,dreg,token_addr
DEFTYPE.l array1,array2,ModeID,stepnumber,breakpoint_adr
DEFTYPE.l mouseables,rp,task,signalset
DEFTYPE.l arexxport,*ComData_Pointer
DEFTYPE.l
DEFTYPE.q mq
DEFTYPE.f mf,ffp

DEFTYPE.l address,address2,memadr
DEFTYPE.w winheight,ox,oy,ow,typelength,typewidth

DEFTYPE.Gadget *arrowgad
DEFTYPE._Screen scr

.@begin
; set of the Version and Revison in the internal data
Poke.b ?initstate  ,Vallong("\\__VER_MAJOR")
Poke.b ?initstate+1,Vallong("\\__VER_MINOR")


prefs.prefstype\fontname = ""; use system default "topaz.font",8
prefs.prefstype\fontsize = 0 ; use system default "topaz.font",8
stepnumber               = 1
searchtype               = 1
dowin                    = -1
pmodevalid               = 0
configsize.l             = Peek.w(?sizeofsave)
array$                   = ""


; set default Border and Font infos  tomsmart1 2016 03 15
ScreenBarHeight.l   = 10 + 1
ScreenFontNameStr.s = "topaz.font"
ScreenFontYSize.l   = 8
WinBorTop.l         = 2
WinBorTextTop.l     = WinBorTop + ScreenFontYSize + 1
WinBorLeft.l        = 4
WinBorRight.l       = 4
WinBorBottom.l      = 2
WinSizeBorRight.l   = 18    ; set default size for hires
WinSizeBorBottom.l  = 10    ; set default size for hires


proz.l = Processor                                     ; needed for fpu register pos
If proz = 3 OR proz = 2 Then MOVE.l #-200   ,fpuoffset ; 020/030
If proz = 4 Then MOVE.l #-200+24,fpuoffset             ; 040
If proz = 5 Then MOVE.l #-200+18,fpuoffset             ; 060

;***********************************************************
; Arrays and lists

Dim List varinfo.variabletype(19)
Dim List d_e.d_event(50)
Dim List objwins.structurewindow(9)

Dim wininfo.wininfotype(Maximum Window)
Dim memwin.w(1),mempointer.l(1),memlock$(1),memlockpf$(1)
Dim winstatus.w(Maximum Window)
Dim customcomm$(#MAXCUSTOMCOMMANDS)
Dim srcStr.s(200)
Dim disStr.s(200)
Dim memStr.s(200)
Dim fp$(8)

mempointer(0)  = 0
mempointer(1)  = 0
objtype$       = "bwlsqf"  ;this is for the type check to trace variables
old_active_win = -1
active_win     = -1
breakpoint_adr = ?breakpoint
breakstore.l   = ?breakstore
watch0.l       = False ; this check the NULL pointer, works only on OS3 wihtout enforcer
;***********************************************************
; Some strings......

typetitle$     = ""
warn1$         = "REDDebugger is attempting to close its screen.\\nPlease close all visitor windows."
srStr.s        = String$(Chr$(0),5) ; needed for Outtext and D_GetSR in RedrawRegs{}       ; important must be pre filled (Spaces) in the needed size for D_CheckNMoveA else it produce Hits
regaStr.s      = String$(" ",30+16) ; needed for Outtext and D_CheckNMoveA in RedrawRegs{} ; important must be pre filled (Spaces) in the needed size for D_CheckNMoveA else it produce Hits
regdStr.s      = String$(" ",4)     ; needed for Outtext and D_CheckNMoveA in RedrawRegs{} ; important must be pre filled (Spaces) in the needed size for D_CheckNMoveA else it produce Hits ; rename it to match for Registers D
laststructure$ = ""
scrtitle$      = "RED Debugger v"+!versions
varfollow$     = "Variable trace"
cntrlwin$      = "Program mode:       "                    ; 6 spaces in string for mode!

MaxLen autoeval$   = 80
MaxLen strg$       = 128
MaxLen ex$         = 128
MaxLen ev$         = 128
MaxLen evalbuffer$ = 256

;; ==================================================     ; All Checks deactivated while Ped this done already (Marco 21.01.15)
;;---  Check  if  all  needed  Librarys  are  available  with  the  needed  min  Version
;errorout.s = ""                                            ; for the error text
;ende.b     = False                                         ; abort indicater
;
;If dos_CheckLib{"wizard.library",42} = False               ; needed for Compiler, PED and REDDebugger                             c
;  errorout.s = {"Missing wizard.library:\\nThis library is required in version 42 by this IDE.\\n\\n"}
;  ende = True
;EndIf
;
;If dos_CheckLib{"reqtools.library",39} = False             ; needed for PED and REDDebugger
;  errorout.s = errorout.s + {"Missing reqtools.library:\\nThis library is required in version 39 by the IDE.\\n\\n"}
;  ende = True
;EndIf
;
;If dos_CheckLib{"ted.library",1} = False                   ; needed for PED and REDDebugger
;  errorout.s = errorout.s + {"Missing ted.library:\\nThis library is required in version 1 by the IDE.\\n\\n"}
;  ;ende = True
;EndIf
;
;If dos_CheckLib{"disassembler.library",40} = False         ; only needed for REDDebugger
;  errorout.s = errorout.s + {"Missing disassembler.library:\\nThis library is required in version 40 for REDDebugger so ASM debugging won't work.\\n\\n"}
;EndIf
;
;If errorout.s <> ""                                        ; check if somthing to show
;   errorout.s = errorout.s + {"Please reinstall AmiBlitz3 or install the needed librarys in LIBS:  "}
;   If ende
;     errorout.s = errorout.s + {"that the REDDebugger can start!"} ; for abort
;   Else
;     errorout.s = errorout.s + {"for a full working REDDebugger!"} ; for limited start
;   EndIf
;   error{errorout}
;EndIf
;
;;--- Abort if needed library or Version is not available
;If ende Then End
;;-----


;--- Test if VBR is located at $0              ; moved to prevent endless error message  tomsmart1 2012 07 12
vbr_test.l = cr_vbr
If vbr_test = 0
   error{"The VBR is currently located at memory address 0!\\nIt is recommended to move the VBR to Fast-Ram!\\nUse a tool like  MPC, VBRControl etc..\\nThe Debugger might cause enforcer hits now."}
EndIf
;---


;--- OS Check for set ASM window to prevend a Crash on OS4
SHARED OSVersion.l
OSVersion = #AmigaOS3
If (dos_CheckLib{"exec.library",50} ) Then OSVersion = #AmigaOS4 ;: message{"REDDebugger: I think I run on OS4, because I was able to open exec.library v50+!"}
If (FindResident_("MorphOS") ) Then OSVersion = #MorphOS ;: message{"REDDebugger: I think I run on MOS, because I found the 'MorphOS' Resident!"}
;-----


Gosub StartOfDayInit

CNIF #BACKGROUND_DBUG
  .BACKGROUND:
  ; variables and statements  for BACKGROUND_DBUG     tomsmart1 2012 07 12

  ; Right, we need some global variables...
  ; -  msgport.l      is the address of Debugger's message port
  ; -  msgportname$   is the name of Debugger's message port
  ; -  msg.l          is the address of Debugger's message

  rexxwiny.w    = ScreenBarHeight
  rexxwinx.w    = 0
  rexxportname$ = "REDDebugger"

  Statement CreateDebuggerPort{}
  SHARED  rexxport.l,rexxportname$

    rexxport.l=CreateMsgPort_
    If rexxport
      Poke.l rexxport+10,&rexxportname$
      AddPort_ rexxport
    EndIf
  End Statement


  Statement ReplyDebuggerMsg{}
  SHARED msg.l,rexxport.l

    If rexxport=0 Then Statement Return
    If msg Then ReplyMsg_ msg
    msg = 0
  End Statement


  Statement DeleteDebuggerPort{}
  SHARED rexxport.l

    If rexxport=0 Then Statement Return
    RemPort_ rexxport
    DeleteMsgPort_ rexxport
  End Statement

  ; start code for #BACKGROUND_DBUG   tomsmart1 2012 07 12

  If FindPort_(&rexxportname$)
    a = RTEZRequest(scrtitle$,"    Already running!    ","  _Ok  ")
    End
  EndIf
  CreateDebuggerPort{}
  AddWaitEvent PortSigBit(rexxport),$10000000 ; add port to WaitEvent
  background_redo.w=1

  Repeat
    If background_redo
      *scr._Screen = GetPubScreen(0,"Workbench")
      textlen.w    = TextLength_(*scr\_RastPort,scrtitle$,Len(scrtitle$))
      Window 0,rexxwinx,rexxwiny,textlen+64,WinBorTextTop,$21000e,scrtitle$,-1,-1 ; rexxportname$,-1,-1
      background_redo = 0
    EndIf

    ev = WaitEvent ; close mini win
    If ev = $10000000
      rexxwinx = WindowX
      rexxwiny = WindowY
      ;DetachGTList 0 ; <= I am not sure if we want this, there is no GTList at all in the entire REDDebugger! (Thilo)
      Free Screen 0
      ReleasePubScreen 0,"Workbench"
      msg = 1

      While msg <> 0
        msg = GetMsg_(rexxport)
        If msg
          ad.l = Peek.l(msg+20)
          If Peek.l(msg + 24) = #IDENTIFIER
            GetReg a0,ad
            MOVE.l a0,d_table
            MOVE.l a5,d_a5
            MaxLen d_d$=256 : MaxLen d_ev$=256 : MaxLen d_ex$=256
            Poke.l ?d_dadd,&d_d$
            statego.w = 0 : dstatus.w = 0 : prtcode.w = 0 : Poke.l ?statego_,&statego
            buffmem.l = AllocMem_(#bufflen,$10001) : Poke.l ?buffmem_,buffmem : CLR bufferput
            FillArray winstatus(),0
            ReplyDebuggerMsg{}
            Gosub mainstart
            ;FillArray winstatus(),0
            FillArray memwin(),0
            FillArray mempointer(),0
            ClearList varinfo()
            ClearList d_e()
            ClearList objwins()
            ali.l = 0 : lt$ = "" : task = 0 : autoeval = 0 : autoeval$ = ""
            pfregs = 0
            !ComData_SetB{comByte_RunningFlag,#0}
            ted_CloseLib{}
          EndIf
          ;ReplyDebuggerMsg{}
        EndIf
      Wend

      background_redo = 2
    EndIf
  Until ev = $200                 ;replace endless loop for normal end condition  tomsmart1 2012 07 12

  DeleteDebuggerPort{}

CELSE   ;#BACKGROUND_DBUG
  error{"very suspicious init stuff!"}
  MOVE.l 4,a0 : MOVE.l 276(a0),a0 : MOVE.l 88(a0),d_table
  MOVE.l a5,d_a5
  MaxLen d_d$ = 256 : MaxLen d_ev$ = 256 : MaxLen d_ex$ = 256
  Poke.l ?d_dadd,&d_d$
  statego.w = 0 : dstatus.w = 0 : prtcode.w = 0 : Poke.l ?statego_,&statego
  buffmem = AllocMem_(#bufflen,$10001) : Poke.l ?buffmem_,buffmem : CLR bufferput
  Gosub mainstart
  ted_CloseLib{} ; close ted.library
CEND   ;#BACKGROUND_DBUG

End

Macro d_call
  MOVE.l d_table,a2
  MOVE.l `1 LSL 2(a2),a2
  JSR (a2)
End Macro


Statement d_sethandler{adr.l}
SHARED token_addr,task,signal,signalset,vbr_temp.l,*TokenBase_Pointer.l

  LEA htable(pc),a0 : !d_call{2}
  MOVE.l a0,mybuffer
  MOVE.l a1,progmode
  PutReg a2,token_addr
  PutReg a3,task ; blitz program process
  PutReg d0,signal
  signalset = (0 BitSet signal)
  TST.b newdebug
  BEQ nd1

  ; moved comdata access to mainstart tedlib access  tomsmart1 2012 07 14
  If *TokenBase_Pointer <> 0                   ; test if we had a vailed comdata_tokenbase pointer
    token_addr = *TokenBase_Pointer            ; yes then we use it insteed of the debuglib one
  EndIf

  vbr_temp.l = cr_vbr
  ;MOVE.l d0,a0
  MOVE.l vbr_temp@(A5),a0
  MOVE.l trap15addr,$bc(a0)

 nd1:
End Statement


Function$ d_detoke{sa.l}
SHARED d_d$

  GetReg a0,sa : GetReg a1,&d_d$
  !d_call{3}
  Function Return d_d$
End Function


Function.l getad {ad.l}
SHARED startcode.l

  If (ad = 0) Then error{"\\__THIS_FUNCTION: Null pointer exception!"} : Function Return 0
  i2.l = Peek.l(ad)
  If Peek.l(ad) AND $80000000
    i2 = i2 AND $7fffffff
    If startcode = 0
      GetRegD0 ad : MOVE.l d0,a0
      MOVE.l #"DuCk",d1
      MOVE.l #"AmiB",d2
      MOVE.l #10 000 000,d0

     'loop
      ADDQ.l #1,a0
      CMP.l (a0),d1
      BEQ 'loop1
      SUBQ.l #1,d0
      BNE 'loop
      BRA 'loop3

     'loop1
      CMP.l 4(a0),d2
      BNE 'loop
      MOVE.l a0,d0
      startcode = PutRegD0
      startcode = Peek.l(startcode+8)

     'loop3
    EndIf
    Function Return i2+startcode
  Else
    Function Return Peek.l(ad)
  EndIf
End Function


.getad2
Function.l getad2 {ad.l}
SHARED startcode.l

  If (ad = 0) Then error{"\\__THIS_FUNCTION: Null pointer exception!"} : Function Return 0
  i2.l = Peek.l(ad)
  If Peek.l(ad) AND $80000000
    i2 = i2 AND $7fffffff
    If startcode = 0
      GetRegD0 ad : MOVE.l d0,a0
      MOVE.l #"DuCk",d1
      MOVE.l #"AmiB",d2
      MOVE.l #10 000 000,d0

     'loop
      ADDQ.l #1,a0
      CMP.l (a0),d1
      BEQ 'loop1
      SUBQ.l #1,d0
      BNE 'loop
      BRA 'loop3

     'loop1
      CMP.l 4(a0),d2
      BNE 'loop
      MOVE.l a0,d0
      startcode = PutRegD0
      startcode = Peek.l(startcode+8)

     'loop3
    EndIf
    Function Return i2+startcode
  Else
    Function Return ad
  EndIf
End Function


Statement d_eval{t$,dosignal.w}
SHARED d_ev$,stepcnt,task,signalset,dstatus

  CNIF #test = 0
    d_ev$=t$ : GetReg a0,&d_ev$ : !d_call{4}
    If task
      If dosignal = #SIGNAL
        If dstatus = #STOPPED
          stepcnt+1
          ;error{"Before signal!"}
          Signal_ task,signalset
          ;error{"After signal!"}
        EndIf
      EndIf
    Else
      error{"Task = 0"}
    EndIf
  CELSE
    EZRequest "ILLEGAL TEST MODE d_eval{} CALL"
  CEND
End Statement


Statement d_exec{t$}
SHARED d_ex$,stepcnt,task,signalset,dstatus

  CNIF #test = 0
    d_ex$=t$ : GetReg a0,&d_ex$ : !d_call{5}
    If dstatus = #STOPPED
      stepcnt+1
      Signal_ task,signalset
    EndIf
  CELSE
    EZRequest "ILLEGAL TEST MODE d_exec{} CALL"
  CEND
End Statement


Statement d_quit{}
SHARED stepcnt,task,signalset,dstatus

  If dstatus <> #STOPPED
    !d_call{1}
    stepcnt = 0
    Delay_ 2
  EndIf
  ; quit the debugger
  !d_call{6}
  stepcnt+1
  Signal_ task,signalset
End Statement


Statement d_skip{}

  !d_call{8}
End Statement


Macro d_basic
  MOVE.l d_a5(pc),a5
End Macro


add_event
Statement add_event{t.l,s$}
SHARED d_e()

  Forbid_
   If AddLast(d_e())
     d_e()\t = t
     MOVE.w bufferput(pc),d0 : SUBQ.w #4,d0 : AND.w #buffand,d0 : PutReg d0,d_e()\i
     d_e()\s = s$
   EndIf
  Permit_
End Statement


progversion:
  Dc.b "$VER: REDDebugger "
  Dc.b !versions," (\\__DATE_GER__) Build \\__VER_PATCH.\\__VER_BUILD",0
  Even


varhandler:     Dc.l 0 ; Message waiting for debugger
mybuffer:       Dc.l 0 ; Pointer to registers!
progmode:       Dc.l 0 ; Pointer to word that hold program mode
                       ; < 0 = blitz, 0 = amiga, >0 = qamiga
d_dadd:         Dc.l 0
d_table:        Dc.l 0
d_a5:           Dc.l 0
statego_:       Dc.l 0
buffmem_:       Dc.l 0
bufferput:      Dc.w 0

htable: ; handler table
 Dc.l d_statehandler   ,d_superhandler,d_userhandler
 Dc.l d_waithandler    ,d_evalhandler ,d_cleanup
 Dc.l d_vartracehandler,d_prochandler

._D_Handlers:
d_statehandler:
  MOVE.l buffmem_(pc),a1 : ADD bufferput(pc),a1 : MOVE.l 64(a0),(a1)
  ADDQ #4,bufferput : ANDI #buffand,bufferput

  MOVE.l    (a1),a0
  LEA       breakpoint(pc),a1

 'check:
  TST.l     (a1)
  !SBEQ     {'skipit}
  CMP.l     (a1),a0
  !SBEQ     {'ok}
  ADDQ.l    #8,a1
  !SBRA     {'check}

 'skipit:
  MOVE.l    statego_(pc),a1
  TST       (a1)
 RTS

 'ok:
  CMPI.w    #break_simple,4(a1)
  !SBNE     {'noclear}
  SUB.w     #1,6(a1) ; Got simple breakpoint
  !SBEQ     {'clear_em}
  !SBRA     {'skipit}

 'noclear:
  CMPI.w    #break_permanent,4(a1)
  BEQ       '_return
  ADD.w     #1,6(a1)
  !SBRA     {'skipit}

; move all following breakpoints down
 'clear_em
  TST.l     (a1)
  !SBEQ     {'_return}
  ADDQ.l    #8,a1
  MOVE.l    (a1),-8(a1)
  MOVE.l    4(a1),-4(a1)
  !SBRA     {'clear_em}

 '_return:
  MOVE.l    a5,-(a7)
  !d_basic
  Gosub     stopit
  MOVE.l    (a7)+,a5
  ST        donebreakpoint
  MOVE.l    statego_(pc),a1
  TST       (a1)
RTS


donebreakpoint: Dc.w 0

breakpoint:     Dc.l 0,0 ; 0
                Dc.l 0,0 ; 1
                Dc.l 0,0 ; 2
                Dc.l 0,0 ; 3
                Dc.l 0,0 ; 4
                Dc.l 0,0 ; [reserved]
                Dc.l 0,0

breakstore:     Dc.w 0
                Dc.w 0
                Dc.w 0
                Dc.w 0
                Dc.w 0
                Dc.w 0
                Dc.w 0

d_superhandler:
  MOVE.l a7,regpos
  !d_basic : PutReg a0,sa.l
  Gosub stopit : add_event{0,Peek.s(sa)}
Return


d_userhandler:
  !d_basic : PutReg a0,sa
  Gosub stopit : add_event{1,Peek.s(sa)}
Return


d_waithandler:
  !d_basic
  TST.b   noredraw
  !SBNE   {label}
  If prtcode ; print code out?
    prtbusy.l = -1
    add_event{3,""} ; print me out!
    Wait_ signalset
    While prtbusy : Delay_ 1 : Wend ; vwait wait till printed!
  EndIf

 label:
  MOVE.l a7,regpos
  If pfregs = 0 Then PFRegisters Peek.l(MyBufferAddress.l) : pfregs = -1
  SF noredraw
  If dstatus = #STOPPED ; stopped?
    If stepcnt = 0 Then Wait_ signalset ; wait blitz dbug prg process
    stepcnt-1
  EndIf
  If (dstatus = #TRACE OR dstatus = #STOPPED) AND blitzcontrol
    MOVEQ #-1,d0
  Else
    If dstatus = #BLITZMODE Then dstatus = #STOPPED : BCHG #1,$bfe001
    MOVEQ #0,d0
  EndIf
Return


noredraw:   Dc.w  0


d_evalhandler:
  !d_basic : PutReg a0,sa
  add_event{2,Peek.s(sa)}
  ST    noredraw
Return


d_cleanup:
  !d_basic : add_event{4,""}
Return


d_vartracehandler:
  MOVEM.l d0-d7/a0-a6,-(a7)
  'loop1 : TST.l varhandler : !SBNE {'loop1}
  MOVE.l  a0,varhandler
  'loop2 : TST.l varhandler : !SBNE {'loop2}
  MOVEM.l (a7)+,d0-d7/a0-a6
RTS


;d0 = 0 for start of procedure
;d1 = -1 for end of procedure
; Controlled by variable procstatus (not called by debuglib.obj
; unless procstatus is non-zero).
d_prochandler:
  TST.b   d1
  BNE     'setstop

 'setgo:
  ADD.w   #1,proccount
  CMPI.w  #1,proccount ; First procedure?
  !SBNE   {'exitthis}

  MOVE.l  statego_(pc),a1 : TST (a1)
  !SBEQ   {'running}
  MOVE.w  #0,stopstate
  !d_basic
  old_dstatus = dstatus
  prtcode = 0 : dstatus = 0 : statego = 0

 'exitthis
 RTS

 'setstop
  TST.w   proccount
  !SBEQ   {'exitthis}

  SUB.w   #1,proccount
  TST.w   proccount   ; Last procedure?
  !SBNE   {'exitthis} ; Nope - continue running

  TST.w   stopstate   ; Was original state running?
  !SBNE   {'exitthis} ; Nope - continue running then
;  MOVE.l  d0,procreturnval
  !d_basic
  prtcode = -1 : stepcnt = 0 : dstatus = old_dstatus : statego = -1
 RTS

 'running:
  MOVE.w  #-1,stopstate
RTS


proccount:      Dc.w 0
stopstate:      Dc.w 0
procreturnval:  Dc.l 0


; ad2 = instruction pointer
; returns d_d$ instruction string
GETInstruction:
  GetReg a0,Peek.l(ad2)+9
  MOVE.l d_dadd(pc),a1 : !d_call{3} : SUB.l d_dadd(pc),a1 : SUBQ #1,a1
  MOVE.l d_dadd(pc),a0 : MOVE.l a1,-(a0)
Return


;*****************************************************************
.Statements:

Statement DoHelp{a$}
SHARED arexxport,scrtitle$,pubname$

  If arexxport = 0
    a.l = RTEZRequest(scrtitle$,"Online help not available because RexxMast"+Chr$(10)+"is not running.","  Ok  ")
    Statement Return
  EndIf

  If pubname$ = ""
    p$ = "Workbench"
  Else
    p$ = pubname$
  EndIf

  GetPubScreen 1,p$
  ShowScreen 1
  ReleasePubScreen 1,p$
  Poke.l Addr Screen(1),0

  Use Screen 0
  If FindPort_("DEBUGGERHELP.1")
    RXSendCommand "DEBUGGERHELP.1","'link "+a$+"'"
  Else
    command$ = "run " + dos_AddPart{default_assign$,"Tools/AB3HelpViewer"} + " -t " + a$
    command$ + " -d " + dos_AddPart{default_assign$,"Docs"} + " -l REDDebugger -s " + p$
    Execute_ command$,0,0
  EndIf
End Statement


;Open a new window, based on the wininfo() array
Statement NewWindow{win.w}
 SHARED wininfo(),winstatus(),sw,sh,end_init,maxheight
 SHARED scrtitle$
 SHARED old_active_win,active_win
 SHARED WinBorTextTop.l,WinSizeBorBottom.l,prefs
 DEFTYPE.w x,y,w,h,typ
 DEFTYPE.l f

  winstatus(win) = 0

  If (OSVersion = #AmigaOS4 OR OSVersion = #MorphOS)
    If (win = #_winMemory1) OR (win = #_winMemory2) OR (win = #_winDisCop) OR (win = #_winCustom) OR (win = #_winSearch)
       error{"This feature/window is disabled on AmigaOS4/MorphOS.\\nHint: Save preferences if this pops up on startup."}
       Statement Return
     EndIf
  EndIf

  If win = #_winMouseables
    If ask{"This feature is currently broken.\\nDo you want to open the window anyway?","Yes, please.|Ooops!"}=0
      Statement Return
    EndIf
  EndIf

  If win = #_winMemory1 OR win = #_winMemory2
    typ.w = 1
    Poke.l ?__more+4,?__memwin
  Else
    Poke.l ?__more+4,?__norm
    Poke.l ?__tl_mh+4,maxheight
  EndIf
  x.w = wininfo(win)\x
  y.w = wininfo(win)\y
  w.w = wininfo(win)\w
  h.w = wininfo(win)\h
  f.l = wininfo(win)\flags

  If win = #_winRegisters      ; test for Register window and set the max height of the window to 9 text lines
    maxRegHeight.w = prefs\fontsize*9 +WinBorTextTop +WinSizeBorBottom +1   ; max height for register window
    Poke.l ?__tl_mh+4,maxRegHeight
    If h > maxRegHeight
      h = maxRegHeight
      wininfo(win)\h = maxRegHeight
    EndIf
  EndIf

  If end_init
    f+$1000
    old_active_win = active_win
    active_win = win
  EndIf

  ;If (#noresize BitTst win) = 0 AND typ = 0
    ;If x+w > sw Then w = sw-x
    ;If y+h > sh Then h = sh-y
  ;Else
    ;If x+w > sw Then x = sw-w
    ;If y+h > sh Then y = sy.l-h
  ;EndIf
  Poke.l ?__gimmi+4,0

  AddIDCMP #IDCMP_MOUSEMOVE
  If win = #_winSource
    AddIDCMP #IDCMP_MOUSEMOVE
    f = f OR #WFLG_REPORTMOUSE
    ;Poke.l ?__gimmi+4,1
  EndIf

  f = f OR #WFLG_REPORTMOUSE
  Poke.l ?__tl_scr+4,&scrtitle$
  Poke.l ?__tl_w  +4,w
  Poke.l ?__tl_h  +4,h
  Poke.l ?__tl_l  +4,x
  Poke.l ?__tl_t  +4,y

  If wininfo(win)\gadlist<>-1
    Poke.l ?__tl_g+4,Peek.l(Addr GadgetList(wininfo(win)\gadlist))
  Else
    Poke.l ?__tl_g+4,0
  EndIf

  WindowTags win,f,wininfo(win)\title,?__Taglist
  winstatus(win) = -1
  wininfo(win)\w = w,h

  GTSetMenu 0
    WindowFont 1
  If (win = #_winSearch) OR (win = #_winCustom) OR (win = #_winArray) OR (win > 12)
    WindowFont 0
  EndIf

  If win = #_winDisAsm Then InnerCls 2   ; clear/fill win with colour 2

  Statement Return

  __Taglist:
            Dc.l  #WA_NewLookMenus  ,   1
  __gimmi   Dc.l  #WA_GimmeZeroZero ,   1
  __tl_w:   Dc.l  #WA_Width         ,   0
  __tl_h:   Dc.l  #WA_Height        ,   0
  __tl_l:   Dc.l  #WA_Left          ,   0
  __tl_t:   Dc.l  #WA_Top           ,   0
  __tl_g:   Dc.l  #WA_Gadgets       ,   0
            Dc.l  #WA_MenuHelp      ,   1
  __tl_scr: Dc.l  #WA_ScreenTitle   ,   0
  __more:   Dc.l  #TAG_MORE         ,   0

  __norm:
            Dc.l  #WA_MinWidth      ,  160
            Dc.l  #WA_MinHeight     ,   70
            Dc.l  #WA_MaxWidth      , 1920
  __tl_mh:  Dc.l  #WA_MaxHeight     , #maxheight_ever
            Dc.l  #TAG_END

  __memwin: Dc.l  #WA_MinWidth      ,  208
            Dc.l  #WA_MinHeight     ,   70
            Dc.l  #WA_MaxWidth      , 1920
            Dc.l  #WA_MaxHeight     , #maxheight_ever
            Dc.l  #TAG_END
End Statement


Statement Domemtitle{num.w}
 SHARED memlock$(),wininfo()

  win.w = #_winMemory1+num
  a$    = wininfo(win)\title
  If memlock$(num)
    a$+" ("+UCase$(memlock$(num))+")"
  EndIf
  If (Peek.l(Addr Window(win)))
    Use Window win
    WTitle a$
  EndIf
End Statement


; Open a new memory window
Statement NewMemWindow{win.w}
 SHARED wininfo()

  wininfo(win)\flags   = $20002f
  wininfo(win)\gadlist = -1
  NewWindow{win}

  If win = #_winMemory1 Then num.b = 0 Else num = 1
  Domemtitle{num}
End Statement


; Delete a window, after storing its size and position.
; Stores data so that the window can be reopened easily.
Statement DelWindow{win.w}
 SHARED wininfo(),winstatus()

  If (Peek.l(Addr Window(win))=0) Then Use Window 0 :Statement Return
  If win > 22
    Use Window win
    wininfo(win)\x = WindowX,WindowY,WindowWidth,WindowHeight
    winstatus(win) = 0
    WZCloseWindow win
    Use Window 0
  Else
    Use Window win
    wininfo(win)\x = WindowX,WindowY,WindowWidth,WindowHeight
    winstatus(win) = 0
    CloseWindow win
    Use Window 0
  EndIf
End Statement


Statement FindStructureWin{evw.l}
 SHARED objwins()

  FirstItem objwins()
  While objwins()\winnum<>evw
    NextItem objwins()
  Wend
End Statement


Statement SaveIt{p$}
 SHARED ad2,configsize,prefs

  If ad2
    If dos_Exist{p$} ; added to check if the path exist
      If WriteFile(0,dos_AddPart{p$,"RED_DBug.prefs"} )
        WriteMem 0,ad2,configsize
        CloseFile 0
      EndIf
      If WriteFile(0,dos_AddPart{p$,"RED_DBug2.prefs"} )
        WriteType 0,prefs
        CloseFile 0
      EndIf
    EndIf
  Else
    error{"Internal Error: Unable to save config because ad2=NULL !!!"}
  EndIf
End Statement


Statement RedrawArray{refreshtype.b}
 SHARED arrayadd,array1,array2,ix,iy
 SHARED xarraynum,yarraynum,arraytype
 SHARED xarrayoff,yarrayoff,arraydatasize,arrayitemsize
 SHARED arraylabelsize

  If (Peek.l(Addr Window(#_winArray))=0) Then Statement Return
  Use Window #_winArray : Use BitMap 1
  If refreshtype = 1
    If arrayitemsize > 0
      xarraynum = (InnerWidth ASR 3)/(arrayitemsize)
      xarraynum-2
    EndIf
    If xarraynum < 0 Then xarraynum = 0
    SetPropInfo #_winArray,#ARR_XGAD,xarraynum,array1,xarrayoff
    If xarraynum > array1
      xarraynum = array1
      xarrayoff = 0
    Else
      If xarrayoff+xarraynum+1 > array1 Then xarrayoff = array1-xarraynum
    EndIf

    yarraynum = (InnerHeight-8) ASR 3
    yarraynum-1
    SetPropInfo #_winArray,#ARR_YGAD,yarraynum,array2,yarrayoff
    If yarraynum > array2
      yarraynum = array2
      yarrayoff = 0
    Else
      If yarrayoff+yarraynum+1 > array2 Then yarrayoff = array2-yarraynum
    EndIf

    Redraw #_winArray,#ARR_XGAD
    Redraw #_winArray,#ARR_YGAD
  EndIf

  ;Cls
  w.w  = InnerWidth
  hi.w = InnerHeight
  ;Boxf 0,0,w,hi,0
  ;WBox 0,0,w,hi,0

  Select arraylabelsize

    Case 1
      a.l = 2

    Case 2
      a   = 4

    Case 3
      a   = 8
  End Select

  ;FInverse -1
  ;FLocate 0,0
  WLocate 0,0
  NPrint String$(" ",arrayitemsize)
  ;FPrint String$(" ",arrayitemsize)
  b$ = String$(" ",arrayitemsize-a)
  For x.w = xarrayoff To xarrayoff+xarraynum
    a$ = GetHex$(x,arraylabelsize)
    Print b$+a$
    ;FPrint b$+a$
  Next x
  WLocate 0,8
  ;FLocate 0,1
  For y.w = yarrayoff To yarrayoff+yarraynum
    a$ = GetHex$(y,arraylabelsize)
    ;FNPrint b$+a$
    NPrint b$+a$
  Next y
  ;FInverse 0

  Select arraydatasize

    Case 1
      a      = 2
      skip.l = 1

    Case 2
      a      = 4
      skip   = 2

    Case 3
      a      = 8
      skip   = 4
  End Select

  a$ = String$(" ",arrayitemsize-a)

  ad.l = arrayadd+(xarrayoff*skip)+(yarrayoff*(array1+1)*skip)
  For y = yarrayoff To yarrayoff+yarraynum
    ad2.l = ad : ad+((array1+1)*skip)
    ;FLocate arrayitemsize,y-yarrayoff+1
    WLocate arrayitemsize*8,(y-yarrayoff+1)*8 ; change fontsize
    For x = xarrayoff To xarrayoff+xarraynum
      Print a$+GetHexAdr$(ad2,arraydatasize)
      ;FPrint a$+GetHexAdr$(ad2,arraydatasize)
      ad2+skip
    Next x
  Next y

  ;BitMaptoWindow 1,#_winArray,0,0,ix,iy,InnerWidth,InnerHeight
End Statement


Statement RedrawSearchWin{ad.l}
 SHARED searchtype

  If (Peek.l(Addr Window(#_winSearch))=0) Then Statement Return
  Use Window #_winSearch

  WLocate   4,04 : Print "Start address:"
  WLocate   4,18 : Print "End address  :"

  WLocate   4,38 : Print "Search value :"
  WLocate   4,52 : Print "Search type  :"
  WLocate 190,52
  ad+(searchtype*7)-7 : Print Peek.s(ad)
End Statement


Statement RedrawCustomWin{}

  If (Peek.l(Addr Window(#_winCustom))=0) Then Statement Return
  Use Window #_winCustom

  WLocate   4,04 : Print "Address$:"
  WLocate   4,18 : Print "Name    :"
End Statement


Statement UpdateDisCop{}
 SHARED discop_ad,ix,iy

  If (Peek.l(Addr Window(#_winDisCop))=0) Then Statement Return
  Use Window #_winDisCop : Use BitMap 1
  w.w  = InnerWidth : If w > 320 Then w = 320
  hi.w = InnerHeight
  ;Boxf 0,0,w,hi,0

  ;FLocate 0,0
  WLocate 0,0
  ad.l = discop_ad
  For h.w = 1 To (hi/WinFontHeight)
    If ad
      NPrint Hex$(ad)+" "+GetCopIns$(ad)
      ad+4
    EndIf
  Next h
  ;RefreshWindowFrame_(!windowaddr)
  ;BitMaptoWindow 1,#_winDisCop,0,0,ix,iy,w,hi   ; deactived to reduce flick of the border of the win tomsmart1
End Statement


Statement UpdateDisAsm{@clear.l}
 SHARED disasm_ad,d_d$,breakpoint_adr,tokenise
 SHARED disStr(),asmstep,breakstore,winstatus()

 SHARED ProgramStart.l, ProgramSize.l , MyBufferAddress.l

  If winstatus(#_winDisAsm) = 0 Then Statement Return
  If (Peek.l(Addr Window(#_winDisAsm)) = 0) Then Statement Return

  ad.l = Peek.l(MyBufferAddress)   ; replaced ASM code with BASIC  tomsmart1
  If ad
    pc.l = Peek.l(ad+64)-2
  EndIf

  ad = disasm_ad
  If ad < 4096 Then ad = 4096

  Use Window #_winDisAsm
  If tokenise = 1 Then bitm.w = 3 Else bitm = 1
  Use BitMap bitm
  inw.l   = InnerWidth  -1
  inh.l   = InnerHeight -1
  fonth.w = WinFontHeight

  If clear = 1 Then InnerCls 2  ; clear/fill win with colour 2
  WColour 1,2  ; set background colour
  WLocate 0,1
  For h.l = 0 To (inh/fonth)-1

    If (ad < ProgramStart) OR (ad > (ProgramStart+ProgramSize) )
      Statement Return
    EndIf
    If (pc < ProgramStart) OR (pc > (ProgramStart+ProgramSize) )
      Statement Return
    EndIf
    If ((ad-2) < ProgramStart) AND asmstep
      Statement Return
    EndIf

    outtxtStr.s = "$" + Hex$(ad)
    If pc = ad
      outtxtStr + "**>"
    Else
      outtxtStr + "   "
    EndIf

    If Peek.w(ad) = $4e41
      ad+2
      ad2.l  = breakpoint_adr-8
      flag.w = 0
      While flag = 0
        ad2+8
        break.l = Peek.l(ad2)
        If break = ad Then flag = -1
        If break = 0  Then flag = 1
      Wend
      If flag = -1
        If asmstep
          bt1.l = ad2-breakpoint_adr
          bt1   = bt1+breakstore
          ad-2
          Poke.w ad,Peek.w(bt1)
        EndIf
        btype.w = Peek.w(ad2+4)
        ;FInverse On
        If btype = #break_simple
          outtxtStr + "["+Hexw$(Peek.w(ad2+6))+"]" ;: FInverse Off : ;Countdown
          outtxtStr + " "
        Else
          If btype = #break_permanent
            outtxtStr + "[*]" ;: FInverse Off :
            outtxtStr + "    "
          Else
            outtxtStr + "[="+Hexw$(Peek.w(ad2+6))+"]" ;Counter
          EndIf
        EndIf
        ;FInverse Off
      Else
        ;FInverse On :
        outtxtStr + ">>>" ;: FInverse Off :
        outtxtStr + "    "
      EndIf
      If asmstep AND flag = -1
        a$        = DisAssemble$(ad)
        disStr(h) = a$
        outtxtStr + a$
        Poke.w ad,$4e41
        ad+InstrSize
      Else
        ;ret.l = getad{ad}
        ;FPrintDetoke ret+9,Peek.w(ad+4)-9,-1,0
        ;*lineptr.l=PutRegD0 : x$=peek.s(*lineptr)
        ;Gosub sysprintdetoke
        ;FLocate 0,0
        outtxtStr + "Basic Token                     " ; it was the basic token
        WColour 3,2   ;set draw colour to 3 (token colour)
        ad+8
      EndIf
    Else
      a$        = DisAssemble$(ad)
      disStr(h) = a$
      outtxtStr + "      " + a$ ; added 1 Space befor the ASM instuction to prevent a overwrite of the first character  tomsmart1
      ad+InstrSize
    EndIf

    outtxtleng.l = TextFit(outtxtStr,inw)    ; calc the chars we can print
    If outtxtleng>0                          ; test if we have space to print the string
      If FLen(outtxtStr)>outtxtleng          ; test is we have space to print the complete string
        outtxtStr=Left$(outtxtStr,outtxtleng); no , cut it down to the space we have
      EndIf
      NPrint outtxtStr
    Else
      h= (inh/fonth)-1                       ; no can't print jump to the last to exit the loop
    EndIf
    WColour 1,2  ; set to draw to colour 1 and background to 2
  Next h
  WColour 1,0  ; set colours back to defaults
End Statement


Statement UpdateVarWindow{}
 SHARED varinfo(),winstatus(),ffp,i

  If (Peek.l(Addr Window(#_winVariables) ) = 0) Then Statement Return

  Use Window #_winVariables
  fonth.w = WinFontHeight
  inw.l = InnerWidth              -1
  inh.l = InnerHeight-(fonth + 2) -1  ; get and calc the height, minus the 1 textline and the border
  Use BitMap 1
  xpos.w = TextLength_(RastPort,"1234567890123456789",19) ; get the position to start with the print value
  inw - xpos  ; to get the width of the window we can use to print the value

  If (inh > fonth) AND (inw > 0)  ; test if we have the height and the width to print the Values
    ResetList varinfo()
    mq.q = 0 : mf.f = 0
    count.l = 0

    While NextItem(varinfo())
      ad.l = varinfo()\address
      If ad
        count+1
        f.b = varinfo()\form
        Select varinfo()\typ

          Case 1 ; BYTE
            Select f

              Case 0
                a$ = Str$(Peek.b(ad)) + "  " ; added space to clear possible old value  tomsmart1 2016 02 05

              Case 1
                a$ = "$"+GetHexAdr$(ad,1)

              Case 2
                a$ = "%"+Binb$(Peek.b(ad))

            End Select

          Case 2 ; WORD
            Select f

              Case 0
                a$ = Str$(Peek.w(ad)) + "    "   ; added space to clear possible old value  tomsmart1 2016 02 05

              Case 1
                a$ = "$"+GetHexAdr$(ad,2)

              Case 2
                a$ = "%"+Binw$(Peek.w(ad))

            End Select

          Case 3 ; LONGWORD
            Select f

              Case 0
                a$ = Str$(Peek.l(ad)) + "         "  ; added space to clear possible old value  tomsmart1 2016 02 05

              Case 1
                a$ = "$"+GetHexAdr$(ad,3)

              Case 2
                a$ = "%"+Bin$(Peek.l(ad))

            End Select

          Case 4 ; STRING trace output
            ssize.l    = Peek.l(Peek.l(ad)-4)
            smaxsize.l = Peek.l(Peek.l(ad)-8)
            If f = 1
              a$ = "'" + Peek.s(Peek.l(ad)) +"' ["+Str$(ssize)+"/"+Str$(smaxsize)+"]"
            Else
              a$ = "'" + Peek.s(Peek.l(ad)) + "'"
            EndIf
            If smaxsize > ssize                   ; added tomsmart1
              For times.l=1 To (smaxsize-ssize+3) ; to get the space to overwrite old Strings and sizeinfo
                a$ + " " ; added Space to overwrite/clear
              Next
            EndIf

          Case 5 ; QUICK
            Poke.l &mq,Peek.l(ad)
            a$ = Str$(mq)

          Case 6 ; FLOAT
            If winstatus(#fpuwin)
              i = Peek.l(ad)
              Dc.l $f2276800 ;fmove.x fp0,-(a7)
              fmove.s i@(a4),fp0
              JSR fpuffp
              Dc.l $f21f4800
              ;fmove.x (a7)+,fp0
              a$ = Str$(ffp)
            Else
              Poke.l &mf,Peek.l(ad)
              a$ = Str$(mf)
            EndIf

        End Select

        If (count*fonth) < inh           ; test if the position is in the window
          outtxtleng.l = TextFit(a$,inw) ; calc the chars we can print
          If outtxtleng >0               ; test if we have space to print the string
            WLocate xpos,(count*fonth)+2 ; set the position to print the value
            If FLen(a$)>outtxtleng       ; test is we have space to print the complete string
              a$=Left$(a$,outtxtleng)    ; no , cut it down to the space we have
            EndIf
            NPrint a$
          Else
            LastItem varinfo()           ; no can't print jump to the last entry in the list to exit the loop
          EndIf
        Else
          LastItem varinfo()             ; no jump to the last entry in the list to exit the loop
        EndIf
      EndIf
    Wend

  EndIf
End Statement


Statement RedrawVarWindow{}
 SHARED varinfo(),objtype$

  If (Peek.l(Addr Window(#_winVariables)) = 0) Then Statement Return
  Use Window #_winVariables

  inw.l   = InnerWidth  -1  ; -1 to get the right size to calculate
  inh.l   = InnerHeight -1  ;           "
  fonth.w = WinFontHeight

  Use BitMap 1
  InnerCls
  xpos.l = TextLength_(RastPort,"1234567890123456789",19) ; get the position to start with the print of the value

  ; print statusline
  If  inh > fonth + 1 ; test if we have the height to print the status line
    a$ = "Variable"
    outtxtleng.l = TextFit(a$,inw)
    WLocate 0,0
    If outtxtleng > 0           ; test if we have space width to print the string
      If FLen(a$)>outtxtleng    ; test is we have space to print the complete string
        a$=Left$(a$,outtxtleng) ; no , cut it down to the space width we have
      EndIf
      Print a$
      WLocate xpos,0
      a$ = "Value"
      outtxtleng = TextFit(a$,inw-xpos)
      If outtxtleng > 0           ; test if we have space width to print the string
        If FLen(a$)>outtxtleng    ; test is we have space to print the complete string
          a$=Left$(a$,outtxtleng) ; no , cut it down to the space width we have
        EndIf
        Print a$
      EndIf
    Else
      Statement Return
    EndIf

    ; draw separation line
    Wline WLeftOff, WTopOff + fonth, WLeftOff + inw, WTopOff + fonth, 1

    ; print variable names
    WLocate 0,fonth+2
    inh - (fonth+2)               ; reduce the innerheight, with the 1 textline and the borderline
    count.l = 0
    If inw < xpos Then xpos= inw  ; for the case the window are smaller then the value position
    ResetList varinfo()

    While NextItem(varinfo())
      count+1
      If (count*fonth)<inh        ; test if we have space height to print
        a$ = "."+Mid$(objtype$,varinfo()\typ,1)   ; get type to print
        If a$ = ".s" AND Right$(varinfo()\name,1) = "$" Then a$ = ""  ; test if we have a String with $
        a$ = varinfo()\name+a$    ; generate the complette string with var name and type
        outtxtleng = TextFit(a$,xpos)
        If FLen(a$)>outtxtleng    ; test is we have space width to print the complete string
          a$=Left$(a$,outtxtleng) ; no , cut it down to the space we have
        EndIf
        NPrint a$
      Else
        LastItem varinfo()        ; no , jump to last entry to exit the loop
      EndIf
    Wend

  EndIf
End Statement


Function.l GetStructVal{num.w}
 SHARED objwins()

  ad.l  = objwins()\typepointer
  ads.l = objwins()\mem_type
  While Peek.b(ads) <> 0 AND num <> 0
    ad+Peek.w(ads+2)
    ads+4
    num-1
  Wend

  If Peek.w(ads) = 0 Then Function Return -1

  Select Peek.w(ads)

    Case 1
      ad = Peek.b(ad)

    Case 2
      ad = Peek.w(ad)

    Case 3
      ad = Peek.l(ad)

    Case 4
      ad = Peek.l(ad)
  End Select
  Function Return ad
End Function


; Update the object trace window
Statement RefreshTypeWindow{}
SHARED winstatus(),ix,iy
SHARED objwins()

  DEFTYPE.q mq
  DEFTYPE.f mf

  If (Peek.l(Addr Window(objwins()\winnum)) = 0) Then Statement Return

  Use Window objwins()\winnum
  ad.l = objwins()\typepointer

  ;FLocate 0,0

  typewidth.w = objwins()\typewidth
  WLocate typewidth,0
  inw.l = InnerWidth
  inh.l = InnerHeight
  Use BitMap 1
  ;Boxf 0,0,inw-typewidth,inh AND %1111111111111000,0
  WBox typewidth,WTopOff+1,inw-typewidth,inh AND %1111111111111000,0
  If ad OR objwins()\is_bbobject=0
    ;FNPrint Hex$(ad)
    WLocate typewidth,0 : NPrint Hex$(ad) ; change for fontsize
    ads.l  = objwins()\mem_type
    defy.l = 10
    While Peek.w(ads) <> 0
      WLocate typewidth,defy
      defy+8
      a.w = Peek.w(ads)
      If a < 4
        ;FNPrint GetHexAdr$(ad,a)
        NPrint GetHexAdr$(ad,a)
      Else
        Select a

          Case 4
            If Peek.l(ad) <> 0 Then NPrint  PeekMax$(Peek.l(ad),80) Else NPrint  ""
            ;If Peek.l(ad)<>0 Then FNPrint PeekMax$(Peek.l(ad),80) Else FNPrint ""

          Case 5 ; QUICK
            Poke.l &mq,Peek.l(ad)
            ;FNPrint Str$(mq)
            NPrint Str$(mq)

          Case 6 ; FLOAT
            Poke.l &mf,Peek.l(ad)
            ;FNPrint Str$(mf)
            NPrint Str$(mf)
        End Select
      EndIf
      ad+Peek.w(ads+2)
      ads+4
    Wend
  Else
    Print "No object found"
    ;FPrint "No object found"
  EndIf

  ;BitMaptoWindow 1,objwins()\winnum,0,0,typewidth,iy+1,inw-typewidth,inh AND %1111111111111000
End Statement


Function.l FindBreakPoint{ad.l}
SHARED breakpoint_adr

  ad2.l  = breakpoint_adr
  flag.l = 0
  While Peek.l(ad2) <> 0 AND flag = 0
    If Peek.l(ad2) = ad
      flag = -1
    Else
      ad2+8
    EndIf
  Wend
  If flag = 0 Then ad2 = 0
  Function Return ad2
End Function


Statement RedrawMouseables{n.w}
SHARED mouseables,num_mouseables,mouseables_off,ix,iy

  If Peek.l(Addr Window(#_winMouseables))=0 Then Statement Return
  Use Window #_winMouseables : Use BitMap 1
  w.w  = InnerWidth
  hi.w = InnerHeight
  h.w  = hi ASR 3

  If n = True
    SetPropInfo #_winMouseables,#MSE_SGAD,h,num_mouseables,mouseables_off
    Redraw #_winMouseables,#MSE_SGAD
  EndIf

  ;Boxf 0,0,w,hi,0
  InnerCls
  WLocate 0,0
  ;FLocate 0,0
  y.w  = 0
  ad.l = mouseables
  If mouseables_off
    For loop.w = 1 To mouseables_off
      If ad Then ad = Peek.l(ad)
    Next loop
  EndIf

  If ad <> 0
    While y < h AND y < num_mouseables
      If ad Then ad2.l = Peek.l(ad+4)
      If ad2 Then a$ = ExtractLabel(ad2)
      NPrint a$
      y+1
      If ad Then ad = Peek.l(ad)
    Wend
  EndIf
  ;BitMaptoWindow 1,#_winMouseables,0,0,ix,iy,w,hi
End Statement


Statement GetCustomMenus{}
SHARED customcomm$(),my_path$

  If ReadFile(0,dos_AddPart{my_path$,"REDDebugger.menus"} ) ; change path
    GTMenuTitle 0,4,"Custom"
    FileInput 0
    n.l = 0
    Repeat
      a$ = Edit$(256)
      If a$ <> ""
        D_InitParse a$
        b$   = D_NextArg$
        typ$ = D_NextArg$
        s$   = D_NextArg$
        customcomm$(n) = D_NextArg$
        customcomm$(n) = D_NextArg$
        If s$ = Chr$(126) Then s$ = ""
        If b$ <> Chr$(126)
          GTMenuItem 0,0,4,n,b$,s$
        Else
          GTMenuItem 0,0,4,n
        EndIf
        n+1
      EndIf
    Until Eof(0) OR n = #MAXCUSTOMCOMMANDS
    PopInput
    CloseFile 0
  EndIf
End Statement

.@regs
Statement InitRegsWin{}
 SHARED winstatus()

  If winstatus(#_winRegisters) AND (Peek.l(Addr Window(#_winRegisters) ) >< 0)
    Use Window #_winRegisters
    InnerCls
    *rp.RastPort = RastPort(#_winRegisters)
    inw.l   = InnerWidth  -1
    inh.l   = InnerHeight -1
    fonth.w = WinFontHeight
    iy.w    = WTopOff
    ix.w    = WLeftOff
    textlen.w=TextLength_(*rp," ",1) ; this works only for nonproportional fonts !
    maxcharperline.l = inw/textlen
    If (inh > fonth) AND (maxcharperline >= 4) ; test if we have the heigth and weidth to print something
      OutTextPen *rp,1
      y.l = iy+1
      For h.l = 0 To 7
        If inh >= (fonth*(h+1))     ; test if we have the height to print the line
          ; data registers
          OutText ix           ,y,*rp,"d"+Str$(h)+"=$"
          If maxcharperline >= (4+8)
            ;OutText ix+ 4*textlen,y,*rp,"--------"
            ; address registers
            If maxcharperline >= (20+4)
              OutText ix+20*textlen,y,*rp,"a"+Str$(h)+"=$"
              If maxcharperline >= (24+8)
                ;OutText ix+24*textlen,y,*rp,"--------"
              EndIf
            EndIf
          EndIf
          y + fonth
        Else
          h = 7
        EndIf
      Next h
      If inh >= (fonth*9)     ; test if we have the height to print the line
        ; status register
        OutText ix           ,y,*rp,"sr=$"
        If maxcharperline >= (4+4)
          ;OutText ix+ 4*textlen,y,*rp,"----"
          If maxcharperline >= (13+5)
            OutText ix+13*textlen,y,*rp,"-----"
            ; program counter
            If maxcharperline >= (19+5)
              OutText ix+19*textlen,y,*rp,"BPC=$"
              ;If maxcharperline >= (24+8)
              ;  OutText ix+24*textlen,y,*rp,"--------"
              ;EndIf
            EndIf
          EndIf
        EndIf
      EndIf

    EndIf

  EndIf
End Statement



Statement RedrawRegs{}
 SHARED winstatus(),MyBufferAddress.l ,fpuneedupdate.l
 SHARED srStr.s , regaStr.s , regdStr.s    ; important must be pre filled (Spaces) in the needed size for D_CheckNMoveA else it produce Hits

  If winstatus(#_winRegisters) AND (Peek.l(Addr Window(#_winRegisters) ) >< 0)
    ad.l = Peek.l(MyBufferAddress)
    If ad
      Use Window #_winRegisters
      *rp.RastPort = RastPort(#_winRegisters)
      inw.l   = InnerWidth  -1
      inh.l   = InnerHeight -1
      fonth.w = WinFontHeight

      iy.w    = WTopOff
      ix.w    = WLeftOff
      textlen.w = TextLength_(*rp," ",1)  ; this works only for nonproportional fonts !
      maxcharperline.l = inw/textlen
      If (inh > fonth+1) AND (maxcharperline >= (4+8) ) ; test if we have the heigth and weidth to print something
        y.l = iy+1
        For h.l = 0 To 7
          If inh >= (fonth*(h+1))     ; test if we have the height to print the line
            ;data regs
            dreg.l = Peek.l(ad)         ; get address of the first data register
            OutText ix + 4*textlen,y,*rp,Hex$(dreg)
            If maxcharperline >= (13+4)
              D_CheckNMoveA ad,&regdStr
              OutText ix + 13*textlen,y,*rp,regdStr

              If maxcharperline >= (24+8)
                ;address regs
                areg.l = Peek.l(ad+32)  ; get address of the first address register
                OutText ix+24*textlen,y,*rp,Hex$(areg)

                If OSVersion = #AmigaOS3        ; added to prevent Hits  with AmigaOS4 and maybe MorphOS
                  If maxcharperline >= (33+46)
                    ; begin show Adressregisterpointer values !!!!
                    If areg > #lowestaddr
                      CNIF #longs = 1
                      CELSE
                        D_HexWord areg,&regaStr,6
                      CEND
                        D_CheckNMoveA areg,&regaStr+31,3
                      OutText ix + 33*textlen,y,*rp,regaStr
                     EndIf
                   EndIf
                 EndIf

              EndIf

            EndIf

            ad + 4     ; go to next register 4 bytes = 1Long
            y + fonth  ; vertical step for
          Else
            h = 7      ; we have not the height to print the line we have to end the loop
          EndIf
        Next h
;        MOVE.l #-200,fpreg
;        For i=0 To 4
;        MOVE.l regpos,a0
;        ADD.l fpreg,a0
;        ADD.l #12,fpreg
;        Dc.l $f2284800 : Dc.w 0 ; fmove.x 0(a0),fp0
;        fmove.s fp0,d0
;        JSR fpuffp
;        OutText i*120+4,84,rp,"F"+Str$(i)+"="+Str$(ffp)
;        Next
        ; status register
        If inh >= (fonth*9)     ; test if we have the height to print the line
          mysr.w = Peek.w(ad+32+4)
          OutText ix + 4*textlen,y,*rp,Hexw$(mysr)
          If maxcharperline >= (13+5)
            D_GetSR &srStr,mysr
            OutText ix + 13*textlen,y,*rp,srStr
            If maxcharperline >= (24+8)
              ; program counter
              areg = Peek.l(ad+32) ; Get program counter
              OutText ix + 24*textlen,y,*rp,Hex$(areg-2)
            EndIf
          EndIf
        EndIf

      EndIf
    EndIf
  EndIf
  fpuneedupdate = 6
End Statement


Statement DrawMem{number.b}
 SHARED mempointer(),memStr()

  If Peek.l(Addr Window(#_winMemory1+number) )
    inw.l   = InnerWidth  -1
    inh.l   = InnerHeight -1
    fonth.w = WinFontHeight
    iy.w    = WTopOff
    ix.w    = WLeftOff

    *rp.RastPort = RastPort(#_winMemory1+number)
    w.l  = (inw/TextLength_(*rp,"$1",1) ) ; calc the max char
    If w >= (10 + 7)  ;address + word hexvalue + space + two ASCII chars
      w-10  ; - the size of the address '$xxxxxxxx '
      a$ = String$(" ",w)
      w/7  ; calc how many values to show in one line for (word hexvalue + space + two ASCII chars)
      ad.l = mempointer(number)
      If ad
        WTitle "$" + Hex$(ad)
        ad2.l = &a$ + (w*5) + 1
        OutTextPen *rp,1
        y.l = iy +1
        For h.l = 0 To (inh/fonth)-1
          D_HexWord ad,&a$,w
          D_CheckNMoveWord ad,ad2,w
          OutText ix,y,*rp,"$" + Hex$(ad) + " " + a$
          memStr(h) = "$" + Hex$(Peek.l(ad) )
          y + fonth
          ad + (w ASL 1)
        Next h
      EndIf
    EndIf
  EndIf
End Statement


Statement RedrawMem{}
 SHARED winstatus(), dowin
  If winstatus(#_winMemory1) AND (dowin = 0 OR dowin = -1) AND (Peek.l(Addr Window(#_winMemory1)) >< 0)
    Use Window #_winMemory1
    num.b = 0
    DrawMem{num}
  EndIf

  If winstatus(#_winMemory2) AND (dowin = 1 OR dowin = -1) AND (Peek.l(Addr Window(#_winMemory2)) >< 0)
    Use Window #_winMemory2
    num = 1
    DrawMem{num}
  EndIf

  dowin = -1
End Statement

;*****************************************************************

.StartOfDayInit:
  WBStartup
  AddIDCMP #IDCMP_MENUHELP
  CNIF #test = 0
    If (Maximum Window) < 25 OR (Maximum GadgetList) < 25
      error{"Object Maximums too small\\nIncrease Window and  Gadgetlist Objectsize >25"}
      End
    EndIf
  CEND
  my_path$ = dos_GetProgDir{dos_AddPart{default_assign$,"Debug"} }

  ; try to get border sizes and system font
  Dim GTags.TagItem(4) ; -- Tags for getting the size gadget image
  If Used Screen < 0 Then WbToScreen 0
  *wbscreen.Screen = Peek.l(Addr Screen(Used Screen))
  If *wbscreen <> 0
    ScreenBarHeight   = *wbscreen\BarHeight + 1
    ScreenFontNameStr = Peek.s(*wbscreen\Font\ta_Name)
    ScreenFontYSize   = *wbscreen\Font\ta_YSize
    WinBorTop         = *wbscreen\WBorTop
    WinBorTextTop     = WinBorTop + ScreenFontYSize + 1
    WinBorLeft        = *wbscreen\WBorLeft
    WinBorRight       = *wbscreen\WBorRight
    WinBorBottom      = *wbscreen\WBorBottom

    ; try to get real size of the sizegadget
    *drawinfo.DrawInfo = GetScreenDrawInfo_(*wbscreen)
    If *drawinfo
      If (*wbscreen\Flags & #SCREENHIRES)
        sis.l=#SYSISIZE_HIRES
      Else
        sis  =#SYSISIZE_MEDRES
      EndIf
      GTags(0)\ti_Tag = #SYSIA_DrawInfo,*drawinfo
      GTags(1)\ti_Tag = #SYSIA_Which,#SIZEIMAGE
      GTags(2)\ti_Tag = #SYSIA_Size,sis
      GTags(3)\ti_Tag = #TAG_DONE
      *img.Image = NewObjectA_(0,"sysiclass",&GTags(0))
      If *img
        WinSizeBorRight  = *img\Width
        WinSizeBorBottom = *img\Height
        DisposeObject_ *img
      EndIf
      FreeScreenDrawInfo_ *wbscreen,*drawinfo
    EndIf

  EndIf

  If FindPort_("REXX")
    arexxport = RXCreatePort("DEBUGGER.PRIVATE")
  Else
    arexxport = 0
  EndIf
Return


.mainstart:
  ClearProcessPtrs
  debug_pathname$      = ""          ; added rest to defaults  tomsmart1 2016 02 08
  debug_pathname_Ptr.l = 0
  debug_filename$      = ""
  debug_filename_Ptr.l = 0
  num_mouseables       = 0
  mouseables           = 0
  *TokenBase_Pointer.l = 0
  CLR.l programsize
  CLR.l programstart
  CLR.l trap15addr
  CLR.b newdebug                     ; moved to here because if we have no tedlib we have also no newdebug  tomsmart1 2016 02 08
  CLR.l comdata

  If ted_OpenLib{0}
    *ComData_Pointer = TEDGetJumpTable{}
    If *ComData_Pointer <> 0            ; added a check if we get the pointer  tomsmart1 2012 07 12
      GetRegD0 *ComData_Pointer
      MOVE.l d0,comdata                 ; store the pointer form the basic variable to the comdata table  tomsmart1

      !ComData_GetL{comData_Magic,D0}   ; get the idenifier
      magic.l = PutRegD0
      If magic = #MagicIdentifier_Long  ; Replaced "~::~" with a constant and changed flow  tomsmart1 2012 07 12
        !ComData_GetW{comWord_PEDIsAvailable,D0}     ; add to make a Version check of the comdata Structure to support the new changes  tomsmart1 2016 02 08
        ComDataVersion.l = PutRegD0                     ;
        If ComDataVersion = #ComDataVersionID        ;
          !ComData_LEA{comLong_NewDebug,A0}
          CMP.l #"newd",(A0)
          BNE 'l1
          !ComData_GetL{comPtr_Trap15,trap15addr}
          MOVE.b #1,newdebug

          ; move out of d_sethandler{} because is only need to set once tomsmart1 2012 07 14
          !ComData_GetL{comPtr_DirectBuffer,A0}
          MOVE.l #direktbuffer,(a0)

         'l1
          ; move out of d_sethandler{} to prevent NULL pointer access  tomsmart1 2012 07 14
          !ComData_GetL{comPtr_TokenBase,D0}     : *TokenBase_Pointer = PutRegD0 ; set token base pointer

          !ComData_GetL{comLong_DestBufferSize,A0} ; add to set the right size of the buffer because the compiler alloced the buffer  tomsmart1 2016 02 06
          MOVE.l a0,programsize                    ;
          !ComData_GetL{comPtr_DestBufferStart,A0}
          MOVE.l a0,programstart

          ProgramStart.l=Peek.l(?programstart)
          ProgramSize .l=Peek.l(?programsize)

          !ComData_GetL{comPtr_LabelList    ,d0} : mouseables = PutRegD0
          !ComData_GetW{comWord_LabelCounter,d0} : num_mouseables = PutRegD0
          !ComData_GetL{comPtr_SourceName   ,d0} : debug_filename_Ptr = PutRegD0 : debug_filename$ = Peek.s(debug_filename_Ptr)
          !ComData_GetL{comPtr_CurrentDir   ,d0} : debug_pathname_Ptr = PutRegD0 : debug_pathname$ = Peek.s(debug_pathname_Ptr)
          debug_pathspec$ = dos_AddPart{debug_pathname$,debug_filename$}
          AddProcessPtr "f",&debug_filename$
          AddProcessPtr "d",&debug_pathname$
          AddProcessPtr "F",&debug_pathspec$
        Else ; comdata version id
          error{"comdata structure version does not match!"}
        EndIf
      Else ;Magicidenifer
        error{"Invalid comdata structure!"}
      EndIf
    Else ; *ComData_Pointer
      error{"No comdata structure available!"}
    EndIf
  Else ; ted_OpenLib
    error{"No ted.library,Old Debugger!?"}
  EndIf

  MyBufferAddress = ?mybuffer
  Gosub openwindow

  FillMem ?breakpoint,5*8
  CNIF #test = 0
    d_sethandler{&procstatus}
  CEND

  SetupLESDebug token_addr,tokenise
  RedrawMem{}


  exitflag = 0
  end_init = -1

.@mainloop
  Repeat
    d_sethandler{&procstatus}
    Gosub getevent
    gad.l   = GadgetHit
    i$      = Inkey$
    evq     = EventQualifier
    evw     = EventWindow
    kbshift = evq AND %11

    If ev = 256
      On MenuHit+1 Gosub domenu0,domenu1,domenu2,domenu3,domenu4
    EndIf

    If ev = 8 Then Gosub MousePress
    If ev = 1024 ; Rawkey for gadgets
      flag = 0
      ec.l = EventCode
      ;skip = 0
      Select ec

        Case $21
          gosubstatus = 0
          procstatus  = 0
          flag        = 2
          skip.l      = 0
          FlushEvents

        Case $22 ; key d
          flag        = 2
          skip        = 1
          gosubstatus = 1
          procstatus  = 1
          FlushEvents

        Case $17
          flag = 3

        Case $14
          flag = 4

        Case $13
          flag = 5

        Case $38
          flag = 6

        Case $39
          flag = 7

        Case $32
          flag = 8

        Case $12
          flag = 9

        Case $34
          flag = 10
      End Select
      If flag
        gad = flag : ev = 64 : evw = #_winControl
        ;Repeat : Until RawStatus(ec) = 0
      EndIf
    EndIf

    Select ev

      Case 2 ; newsize
        ;Gosub CorruptWindow

      Case 4 ; refresh
        Gosub CorruptWindow

      Case 32
        If (#gadgetdown BitTst evw) Then Gosub GadgetDown

      Case 64 ; gadget up
        If evw = #_winControl Then Gosub SourceGadgets
        If evw = #_winSearch  Then Gosub SearchGadgets
        If evw = #_winCustom  Then Gosub CustomGadgets

      Case 512 ;**CLOSE WINDOW**
        flag = -1
        Gosub RemoveWindow

      Case 1024 ;**RAWKEY CHECK ON WINDOW**
        Gosub CheckKeyboard

      Case #IDCMP_ACTIVEWINDOW
        Use Window evw
        old_active_win = active_win
        active_win     = evw

      Case #IDCMP_IDCMPUPDATE
        Use Window evw
        Select WZGadName

          Case "fpr00"
            temp.l = 0 : Gosub setfpu

          Case "fpr01"
            temp = 1 : Gosub setfpu

          Case "fpr02"
            temp = 2 : Gosub setfpu

          Case "fpr03"
            temp = 3 : Gosub setfpu

          Case "fpr04"
            temp = 4 : Gosub setfpu

          Case "fpr05"
            temp = 5 : Gosub setfpu

          Case "fpr06"
            temp = 6 : Gosub setfpu

          Case "fpr07"
            temp = 7 : Gosub setfpu
        End Select

      Case #IDCMP_MENUHELP
        Gosub MenuHelp

    End Select
  Until exitflag
  Gosub FreeStuff
Return


.backoff:
  If pb.l
    pb = 0 : i = Peek.l(buffmem+cb.l) : mc.l = -1 : Gosub prtcode
  EndIf
Return


sourceallow
  temp2.l = Peek.l(MyBufferAddress)
  temp2   = Peek.l(temp2+64)
  If Peek.w(temp2-2) = $4e41 AND Peek.w(temp2-2+Peek.w(temp2+6)) = $4e41
    temp2 = 0
  Else
    temp2 = 1
  EndIf
Return


backward:
  If pb = 0 Then bb.l = cb
  bb-4 AND #buffand : i = Peek.l(buffmem+bb)
  If i = 0
    If pb = 0 Then Return
    bb+4 AND #buffand
    t$ = "At end of buffer"
    Goto wprint
  EndIf
  If syntax_.l Then Gosub getsyntax
  pb = -1 : mc = -1
Goto prtcode


forward:
  bb+4 AND #buffand
  If (bb+4 AND #buffand) = Peek.w(?bufferput) Then pb = 0
  i = Peek.l(buffmem+bb)
  If syntax_ Then Gosub getsyntax
  mc = -1
Goto prtcode


.prtcode:
;
;i = info
;
;mc = -1 to make current
;cil = current ins. line, cio=current offset
;
  If i = 0 Then Return
  Gosub sourceallow
  If temp2 Then Return
  il.l = Peek.l(i) : io.l = Peek.w(i+4)-9
  il = getad {i}
  If mc.l Then cil.l = il : cio.l = io : mc = 0
  ;
  Gosub prtcode2
  ;
  ali = i
Return


prtcode2
  bitm = 3
  If (Peek.l(Addr Window(#_winSource)))

  Use Window #_winSource
  *rp.RastPort = RastPort(#_winSource)
  *win.Window  = Peek.l(Addr Window(#_winSource))
  If *rp
    rp_SetClipExt{*rp,*win\BorderLeft,*win\BorderTop,*win\Width-*win\BorderRight-1,*win\Height-*win\BorderBottom-1}
  EndIf

  If tokenise = 1 Then bitm = 3 Else bitm = 1
  Use BitMap bitm : ;BitmapOutput 1
  w.w  = WindowWidth
  hi.w = InnerHeight

  ;WBox  WLeftOff,WTopOff,w+WLeftOff,hi-16,0
  ;Boxf 0,0,w,hi,0
  ypc.l = 0
  y.l = ym.l : i2.l = il
  While y <= ih.l-WinFontHeight AND i2 <> 0
    Gosub prti2:
     i2 = Peek.l(i2)
    srcStr(y/WinFontHeight) = t$ ; add line to sourcearray for clickvar
    y+WinFontHeight
  Wend
;  While y <= ih-WinFontHeight : WLocate 0,y : NPrint "\\R99 \\R99 " : y+WinFontHeight : Wend
  If (y < ih)
    WBox *win\BorderLeft,y+*win\BorderTop,*win\Width-*win\BorderRight-1,ih+*win\BorderTop,2
  EndIf

  y = ym-WinFontHeight : i2 = Peek.l(il+4)
  While y >= 0 AND i2 <> 0
    Gosub prti2:
    srcStr(y/WinFontHeight) = t$
    y-WinFontHeight
    ;y-ScreenFontYSize
    i2 = Peek.l(i2+4)
  Wend
;  While y >= 0 : WLocate 0,y : NPrint "\\R99 \\R99 " : y-WinFontHeight : Wend
  If (y > 0)
    WBox *win\BorderLeft,*win\BorderTop,*win\Width-*win\BorderRight-1,y+*win\BorderTop-1,2
  EndIf

  ;BitMaptoWindow bitm,#_winSource,0,0,ix,iy,iw,ih
  ;If ypc > 0 Then WLocate 0,ypc : Print ">"
  ;RefreshWindowFrame_ (!windowaddr)

  If *rp
    rp_RemClipExt{*rp}
  EndIf
  EndIf
  prtbusy = 0
Return


prti2 ; i2 at y
  If i2 = cil
    n.w = cio
    ypc = y
    If pb Then m.w = 0 Else m = -1
  Else
    n = -1
  EndIf
  FLocate 0,0 ; y/8   ; this is necessary, otherweise FPrintDetoke doesnt find the correct line
  ret.l = getad2 {i2}
  FPrintDetoke ret+9,n,m,0 ; source_char_offset
  *lineptr.l = PutRegD0

  Gosub sysprintdetoke
Return


sysprintdetoke:
  alog$           = ""
  tog.l           = 0
  *win\RPort\cp_x = *win\BorderLeft
  x.l             = -source_char_offset * *win\RPort\TxWidth
  WLocate x,y
  t$              = Peek.s(*lineptr)
  ;If source_char_offset>=1
  ;  a$ = Left$(t$,source_char_offset-1)
  ;  ocur.l = CharCount(a$,$c0)
  ;  If ocur AND 1 Then tog = -1
  ;EndIf
  ;t$ = Mid$(t$,source_char_offset)
  t$              = Replace$(t$,"End\\c0\\c0If","EndIf")
  InitArgParse t$
  a$        = NextArgChar$($c0)
  drawoff.l = 0 ; source_char_offset
  hldone.l  = False

 _more
  If i2 = cil AND drawoff >= cio AND hldone = False
    If tog
      WColour 3,0
      WindowFont 2,#FSF_BOLD
    Else
      WColour 1,0
      WindowFont 2,#FSF_BOLD
    EndIf
    If Instr(a$,":")    Then hldone = True
    If Instr(a$,"Then") Then hldone = True
  Else
    If tog
      WColour 3,2
      WindowFont 2,#FSF_BOLD
    Else
      WColour 1,2
      WindowFont 1
    EndIf
  EndIf

  a$ = Replace$(a$,"==> ","")
  a$ = Replace$(a$,"=> " ,"")
  drawoff + FLen(a$)
  x + FLen(a$) * *win\RPort\TxWidth
  If Instr(a$,";")
    xpos.l = Instr(a$,";")-1
    Print Left$(a$,xpos)
    WindowFont 1,#FSF_ITALIC
    WColour 0,2
    Print Right$(a$,FLen(a$)-xpos)
  Else
    Print a$
  EndIf
  If logcon.l
    If (i2 = cil) AND (i2 <> lasti2.l) Then alog$ = alog$+a$
  EndIf

  a$ = NextArgChar$($c0)
  If a$ <> "" Then tog = NOT tog : Goto _more

  t$ = Replace$(t$,"\\c0","")
  WColour 1,0
  WindowFont 1
  x + *win\BorderLeft
  If x < *win\Width-*win\BorderRight Then WBox x,y+*win\BorderTop,*win\Width-*win\BorderRight-1,y+*win\BorderTop-1+WinFontHeight,2
  If alog$ Then !cout{alog$} : lasti2 = i2

Return


SearchGadgets:
  If (Peek.l(Addr Window(#_winSearch)) = 0) Then Return

  Use Window #_winSearch
  Select gad

    Case 2
      SetString 2,1,"$"+Hex$(mempointer(0))
      Redraw #_winSearch,1

    Case 3
      SetString 2,1,"$"+Hex$(mempointer(1))
      Redraw #_winSearch,1

    Case 5
      SetString 2,4,"$"+Hex$(mempointer(0))
      Redraw #_winSearch,4

    Case 6
      SetString 2,4,"$"+Hex$(mempointer(1))
      Redraw #_winSearch,4

    Case 8
      searchtype+1 : If searchtype = 7 Then searchtype = 1
      WLocate 190,52
      ad = (?variabletypes+(searchtype*7)-7) : Print Peek.s(ad)

    Case 10
      Gosub SearchMemory
  End Select
Return


.GadgetDown:
  Use Window evw
  *arrowgad = EventiAddress
  If evw >= #_winObject0 AND evw <= #_winObject9
    FindStructureWin{evw}
  EndIf
  Repeat
    Delay_ 1
    Select gad

      Case #SRC_SGAD
        source_char_offset = GetPropCurrent(#_winSource,1)

        If ali Then Gosub prtcode2

      Case #SRC_LGAD
        If source_char_offset > 0
          source_char_offset-1
          MoveProp #_winSource,#SRC_SGAD,source_char_offset,#_winSource
          If ali Then Gosub prtcode2
        EndIf

      Case #SRC_RGAD
        If source_char_offset < (250-cw.l)
          source_char_offset+1
          MoveProp #_winSource,#SRC_SGAD,source_char_offset,#_winSource
          If ali Then Gosub prtcode2
        EndIf

      Case #MSE_SGAD
        num = GetPropCurrent(#_winMouseables,#MSE_SGAD)
        If num <> mouseables_off
          mouseables_off = num
          RedrawMouseables{False}
        EndIf

      Case #MSE_UGAD
        If mouseables_off > 0
          mouseables_off-1
          MoveProp #_winMouseables,#MSE_SGAD,mouseables_off,#_winMouseables
          RedrawMouseables{False}
        EndIf

      Case #MSE_DGAD
        h.l = (InnerHeight ASR 3)
        If mouseables_off < (num_mouseables-h)
          mouseables_off+1
          MoveProp #_winMouseables,#MSE_SGAD,mouseables_off,#_winMouseables
          RedrawMouseables{False}
        EndIf

      Case #OBJ_SGAD
        If objwins()\is_bbobject
          a = GetPropCurrent(evw,#OBJ_SGAD)
          If a <> objwins()\tracenum
            objwins()\tracenum = a
            Gosub RefType
          EndIf
        EndIf

      Case #OBJ_UGAD
        If objwins()\is_bbobject
          If objwins()\tracenum > 0
            objwins()\tracenum-1
            Gosub RefType2
            Delay_ 2
          EndIf
        EndIf

      Case #OBJ_DGAD
        If objwins()\is_bbobject
          If objwins()\tracenum < (objwins()\maxobject-1)
            objwins()\tracenum+1
            Gosub RefType2
            Delay_ 2
          EndIf
        EndIf

      Case #ARR_YGAD
        n = GetPropCurrent(#_winArray,#ARR_YGAD)
        If n <> yarrayoff
          yarrayoff = n
          RedrawArray{2}
        EndIf

      Case #ARR_XGAD
        n = GetPropCurrent(#_winArray,#ARR_XGAD)
        If n <> xarrayoff
          xarrayoff = n
          RedrawArray{2}
        EndIf

      Case #ARR_UGAD ; up
        If yarrayoff > 0
          yarrayoff-1
          RedrawArray{1}
        EndIf

      Case #ARR_DGAD ; down
        If yarrayoff < array2-yarraynum
          yarrayoff+1
          RedrawArray{1}
        EndIf

      Case #ARR_LGAD ; left
        If xarrayoff > 0
          xarrayoff-1
          RedrawArray{1}
        EndIf

      Case #ARR_RGAD ; right
        If xarrayoff < array1-xarraynum
          xarrayoff+1
          RedrawArray{1}
        EndIf

    End Select
  Until (*arrowgad\Flags AND #GFLG_SELECTED) = 0
  ev = 0
Return


RefType2:
  MoveProp evw,#OBJ_SGAD,objwins()\tracenum,evw
  RefType:
  a = objwins()\tracenum
  objwins()\typepointer = objwins()\objbaseadr+(a*objwins()\type_sizeof)
  WTitle "Newtype: "+objwins()\t+" #"+Str$(a)+"/"+Str$(objwins()\maxobject-1)
  RefreshTypeWindow{}
Return


.SourceGadgets:
  Select gad

    Case 1 ;**STOP**
      CNIF #test = 0
        If dstatus <> #STOPPED Then !d_call{1}
        stepcnt = 0
      CEND

    Case 2 ;**STEP**
  .@asmstep
      If asmstep
        CacheClearU_
        ad    = Peek.l(MyBufferAddress)
        pc.l  = Peek.l(ad+64)
        st1.l = FindBreakPoint{pc}

        If st1
          bd1.l = st1-breakpoint_adr
          temp  = Peek.w (bd1+?breakstore)
          Poke.w pc-2,temp
        EndIf
        If Peek.w (pc-2) = $4e41
          pc = pc+10
        Else
          Poke.l ad+64,pc-10
        EndIf

        pc-2
        temp$     = DisAssemble$(pc)
        ad        = pc+InstrSize
        temp      = Peek.w (pc)
        adtemp2.l = 0
        adtemp.l  =  0

        If temp = $4eb9 Then ad = Peek.l (pc+2)  ; jsr $xxx
        If skip AND temp = $4eb9 Then ad = pc+6  ; skip jsr
        If temp >= $6000 AND temp <= $6f00       ; bcc bra bsr
          If (temp AND $ff) = $ff                ; 32bit
            ad      = pc+Peek.l(pc+2)+2
            adtemp2 = pc+6
          Else
            If temp AND %00000000 11111111
              ad      = pc+Peek.b(pc+1)+2        ; 8 bit
              adtemp2 = pc+2
            Else
              ad      = pc+Peek.w(pc+2)+2        ; 16 bit
              adtemp2 = pc+4
            EndIf
          EndIf
        EndIf
        If skip AND temp = $6100 Then ad = pc+4 : adtemp2 = 0 ; skip bsr
        If temp = $4e75 Then ad = Peek.l(MyBufferAddress) : ad = Peek.l (ad+60) : ad = Peek.l(ad) ; rts
        If temp = $4ef9 Then ad = Peek.l(pc+2)
        temp1.l = temp AND %11110000 11111000 ; dbxx
        If temp1 = %01010000 11001000
          If skip
            ad = pc+4
          Else
            ad = pc+Peek.w(pc+2)+2 : adtemp2 = pc+4
          EndIf
        EndIf
        brk1.l = FindBreakPoint{ad+2}
        If brk1
          brk2.l = Peek.l(brk1+4)
          Poke.l brk1+4,$00010000
          Goto _nobreak
        EndIf
        temp = Peek.w (ad)
        Poke.w ad,$4e41
        adtemp = ad
        typ.w  = #break_simple
        Gosub addbreakpoint_quiet

       _nobreak
        If adtemp2
          ad    = adtemp2
          temp1 = Peek.w (adtemp2)
          Poke.w adtemp2,$4e41
          typ.w = #break_simple
          Gosub addbreakpoint_quiet
        EndIf
        cil = 0 : pb = 0 : Gosub refwindow : ali = 0 : lt$ = ""

        Forbid_
         CacheClearU_
         prtcode = 0 : dstatus = #RUNNING : statego = 0
        Permit_

        Signal_ task,signalset
         ;Delay_(2)
        CacheClearU_
         Delay_(2)
        If adtemp
          ad = FindBreakPoint{adtemp+2}
          If ad Then Gosub deletebreakpoint
          Poke.w adtemp,temp
        EndIf
        If adtemp2
          ad = FindBreakPoint{adtemp2+2}
          If ad Then Gosub deletebreakpoint
          Poke.w adtemp2,temp1
        EndIf
        If st1
          Poke.w (Peek.l (st1)-2),$4e41
        EndIf
        If brk1
          Poke.l brk1+4,brk2
        EndIf
        CacheClearU_
        Goto _nostep
      EndIf
      If dstatus = #STOPPED
        flag = 0
        If gosubstatus OR skip = 1
          ad   = Peek.l(MyBufferAddress)
          pc.l = Peek.l(ad+64)
          If Peek.w(pc+8) = $4EB9         ; JSR
            If Peek.l(pc+8+6) = $3f3c6753 ; MOVE.w #$6753,-(a7)
              ad    = pc+Peek.w(pc+6)-2   ; calc next instruction addr
              typ.w = #break_simple
              Gosub addbreakpoint_quiet
              CacheClearU_
                                          ; *** STEP GOSUB ***
              If flag AND (dstatus OR skip)
                cil = 0 : pb = 0 : Gosub refwindow : ali = 0 : lt$ = ""
                Forbid_
                 prtcode = 0 : dstatus = #RUNNING : statego = 0
                Permit_
              Else
                flag = 0
              EndIf
            EndIf
          EndIf
        EndIf
        If flag = 0
          If (evq AND %1000)
            stepnumber = RTEZGetLongRange(scrtitle$,"# commands to step:",0,1000,stepnumber)
            If stepnumber
              stepcnt+stepnumber
              flag = 1
            EndIf
          Else
            stepcnt+1
            flag = 1
            ; // CHECK AUTOEVAL!
            If autoeval
              evalrequest = #_autoevalresult
              d_eval{autoeval$,#NOSIGNAL}
            EndIf
          EndIf
        EndIf
        If flag Then Signal_ task,signalset
      EndIf

     _nostep

    Case 3 ;**SKIP**
      If dstatus = #STOPPED
        !d_call{8} : stepcnt+1
        Signal_ task,signalset
      EndIf

    Case 4 ;**TRACE**
      Forbid_
       dstatus = #TRACE : statego = -1
      Permit_
      Signal_ task,signalset

    Case 5 ;**RUN**
      If dstatus
        cil = 0 : pb = 0 : Gosub refwindow : ali = 0 : lt$ = ""
        Forbid_
         prtcode = 0 : dstatus = #RUNNING : statego = 0
        Permit_
        Signal_ task,signalset
      EndIf

    Case 6 ;**<<**
      If dstatus = #STOPPED Then Gosub backward

    Case 7 ;**>>**
      If dstatus = #STOPPED AND pb <> 0 Then Gosub forward

    Case 8 ;**execute**
      ex$ = RTEZGetString(scrtitle$,"Execute...",128,ex$)
      Gosub storefpuregs
      If ex$ Then d_exec{ex$}
      Delay_(2)
      Gosub restorefpuregs

    Case 9 ;**evaluate**
      ev$ = RTEZGetString(scrtitle$,"Evaluate...",128,ev$)
      Gosub storefpuregs
      If ev$ Then d_eval{ev$,#SIGNAL}
      Delay_(2)
      Gosub restorefpuregs

    Case 10 ;**BLITZ GADGET**
      CNIF #test = 0
        If dstatus = #STOPPED
          If pmode <> 0
            Disable #_winControl,10
            execrequest = #_viewblitz
            d_exec{"Mousewait"}
            dstatus = #BLITZMODE
          Else
            reply = RTEZRequest(scrtitle$,"   Not in BLITZ mode   ","_Abort")
          EndIf
        EndIf
      CEND

    Case 11 ;**REGISTER WINDOW**
      If winstatus(#_winRegisters) = 0
        NewWindow{#_winRegisters}
        InitRegsWin{}
        RedrawRegs{}
      Else
        DelWindow{#_winRegisters}
      EndIf

    Case 12 ;**MEM WINDOW 1**
      If winstatus(#_winMemory1) = 0
        NewMemWindow{#_winMemory1}
        dowin = 0
        RedrawMem{}
      Else
        DelWindow{#_winMemory1}
      EndIf

    Case 13 ;**MEM WINDOW 2**
      If winstatus(#_winMemory2) = 0
        NewMemWindow{#_winMemory2}
        dowin = 1
        RedrawMem{}
      Else
        DelWindow{#_winMemory2}
      EndIf

    Case 14 ;**VARIABLE WINDOW**
      If winstatus(#_winVariables) = 0
        NewWindow{#_winVariables}
        RedrawVarWindow{}
        UpdateVarWindow{}
      Else
        DelWindow{#_winVariables}
      EndIf

    Case 15 ;**DISASM WINDOW**
      If winstatus(#_winDisAsm) = 0
        NewWindow{#_winDisAsm}
        UpdateDisAsm{}
      Else
        DelWindow{#_winDisAsm}
      EndIf

    Case 16 ;**COPPER WINDOW**
      If winstatus(#_winDisCop) = 0
        NewWindow{#_winDisCop}
        UpdateDisCop{}
      Else
        DelWindow{#_winDisCop}
      EndIf

    Case 17
      gosubstatus = GadgetStatus(#_winControl,17)

    Case 18
      procstatus = GadgetStatus(#_winControl,18)
      MOVE.w  #0,proccount

    Case 19
      blitzcontrol = GadgetStatus(#_winControl,19)

  End Select
     ;procstatus  = oldprocstatus
     ;gosubstatus = oldgosubstatus
Return


.CustomGadgets:
  a$ = StringText$(3,0)
  b$ = StringText$(3,1)
  If a$ = "" AND gad = 0 Then Return
  If b$ = "" AND gad = 1 Then Return
  ad = Vallong("$"+a$)
  b$ = UCase$(b$)

  If gad = 0
    If (ad AND 1)
      a$ = "<ILLEGAL>"
    Else
      If ad > $dff000 Then ad-$dff000
      b$ = GetCustomReg(ad)
      a$ = Hexw$(ad)
      If b$ = "" Then b$ = "<UNKNOWN>"
    EndIf
  Else
    ad = GetCustomRegAdr(b$)
    If ad = -1
      a$ = "<UNKNOWN>"
    Else
      a$ = Hexw$(ad)
    EndIf
  EndIf
  SetString 3,0,a$
  Redraw #_winCustom,0
  SetString 3,1,b$
  Redraw #_winCustom,1
Return


; Get variable details from user and initialise a search for
; the variable (using EVAL)
.GetNewVariable: ; add vartrace
  Gosub GetVariableNameAndType    ; moved code to subroutine  tomsmart1 2016 02 14
  If na$ <> ""                    ; check if we get a name
    If nt > 0 AND nt < 7          ; check variable type
      If nt = 4
        nf = RTEZRequest(varfollow$,"Show string length and maxlen?:","_No|_Yes|_Cancel")
      EndIf
    Else
      nf = 1
    EndIf
    If nt <> 0 AND nf <> 0
      AddLast varinfo()
      varinfo()\name    = na$
      varinfo()\address = 0
      varinfo()\typ     = nt
      varinfo()\form    = nf-1
      CNIF #test = 0
        d_eval{"&"+na$,#SIGNAL}
        evalrequest = #_variablelocate
      CEND
    EndIf
  EndIf
Return


;n$ = string which should be something like: d0=<val>
.ParseRegs:
  flag = 0
  b$   = UCase$(Left$(n$,1))
  num = 0
  If Mid$(n$,3,1) = "="
    If b$ = "D" OR b$ = "A"
      num = Vallong(Mid$(n$,2,1))
      If b$ = "A" AND num = 7
        num  = -1
        flag = 1
        reply = RTEZRequest(scrtitle$,"Cannot modify register a7","_Abort")
      EndIf
      If num >= 0 AND num < 8
        a$ = Mid$(n$,4)
        If Len(a$) = 6 AND Left$(a$,1) = Chr$(34) AND Right$(a$,1) = Chr$(34)
          si = Cvl(Mid$(a$,2,4))
        Else
          si = Vallong(a$)
        EndIf
        If b$ = "A" Then num+8
        flag = -1
      EndIf
    EndIf
  EndIf
  If flag = 0
    reply = RTEZRequest(scrtitle$,"Malformed argument string","_Abort")
  EndIf
Return


.MousePress:
.@mousebuttons
  If (Peek.l(Addr Window(evw)) = 0) Then Return
  Use Window evw
  wx = WMouseX-ix : wy = WMouseY-iy
  wfonth.w = WinFontHeight
  Gosub checkclicks

  If evw = #_winSource
    ;If winbubble = 0 Then Window #bubble,SMouseX-10,SMouseY+12,WindowWidth,ScreenFontYSize*3+4,$800,"",0,1:winbubble=1
  EndIf

  If (evw = #_winDisAsm) AND (disasm_ad > 4096)
    xwidth.l = TextLength_(RastPort,"$12345678",9)
    If (wx > xwidth) AND (wy >= 0) AND (wy < InnerHeight)
      wy/wfonth
      ad = disasm_ad
      While wy > 0
        If Peek.w(ad) = $4e41 AND Peek.w(ad+Peek.w(ad+8)) = $4e41
          ad+10
        Else
          ad2 = FindBreakPoint{ad+2}
          If ad2
            Poke.w ad,Peek.w((ad2-breakpoint_adr)+?breakstore)
          EndIf
          a$ = DisAssemble$(ad)
          If ad2
            Poke.w ad,$4e41
          EndIf
          ad+InstrSize
        EndIf
        wy-1
      Wend
      If (Peek.w(ad) = $4e41 OR asmstep) AND (WMouseX < xwidth+TextLength_(RastPort,"12345678",8) AND WMouseX > xwidth) ; only add breakpoint in range
        flag = 0
        ad2 = FindBreakPoint{ad+2}
        If ad2
          a = RTEZRequest(scrtitle$,"Change or delete breakpoint?","C_hange|_Delete|_Cancel")
          If a <> 1 Then flag = -1
          If a = 2
            ad = ad2
            Gosub deletebreakpoint
          EndIf
        EndIf

        If flag = 0
          Gosub addbreakpoint
        EndIf
      EndIf
    EndIf

    flag = 1
  EndIf

  If evw = #_winRegisters AND dstatus = #STOPPED
    If (wx > 0) AND (wy > 0) AND (wy < InnerHeight)
      xwidth = TextLength_(RastPort," ",1)
      wx / xwidth  ; calc char position
      wy / wfonth  ; calc line position
      If (wy < 8)
        flag = 0
        num  = wy
        ; check for data register
        If (wx < 12) Then flag = 1 : a$ = "d"
        ; check for address register
        If (wx > 19) AND (wx < 32) Then flag = 2 : a$ = "a"
        If flag
          CNIF #test = 0
            ad = Peek.l(MyBufferAddress)
            ad+(num ASL 2)+(flag-1)*32
            si = Peek.l(ad)
            If EventQualifier AND 3
              n$ = ""
              If winstatus(#_winMemory2) = 0 Then NewMemWindow{#_winMemory2}
              mempointer(1) = si
              RedrawMem{}
              Goto _novalue
            EndIf
            n$ = RTEZGetString("Register value",Peek.s(?setregvalue),20,a$+Str$(num)+"=$"+Hex$(si))

           _novalue
            If n$
              Gosub ParseRegs
              If flag = -1
                ad = Peek.l(MyBufferAddress)+(num ASL 2)
                Poke.l ad,si
                RedrawRegs{}
              EndIf
            EndIf
          CEND
        EndIf
      EndIf
      ; check for programcounter
      If (wy = 8) AND (wx > 18) AND (wx < 32)
        .setprogramcounter
        ad = Peek.l(MyBufferAddress)
        si = Peek.l(ad+64)
        n$ = RTEZGetString("Programcounter value",Peek.s(?setregvalue),20,"$"+Hex$(si-2))
        If n$
          Poke.l ad+64,Vallong(n$)+2
          RedrawRegs{}
          UpdateDisAsm{}
        EndIf
      EndIf

    EndIf
  EndIf

  If (evw >= #_winObject0) AND (evw <= #_winObject9)
    y   = wy-8
    x.l = wx
    FindStructureWin{evw.l}
    If objwins()\is_bbobject = 0 AND y >= 0 AND x >= typewidth-4
      ad = GetStructVal{y ASR 3}
      If ad <> -1
        reply = RTEZRequest(scrtitle$,"Move to location $"+Hex$(ad),"_Okay|_Cancel")
        If reply = 1
          objwins()\typepointer = ad
          RefreshTypeWindow{}
        EndIf
      EndIf
    EndIf
  EndIf

  If (evw = #_winMouseables)
    If num_mouseables AND evalrequest = 0
      wy = wy ASR 3
      If wx >= 0 AND wx < InnerWidth AND wy >= 0 AND wy < (InnerHeight ASR 3)
        wy+mouseables_off
        If wy < num_mouseables
          ad = mouseables
          While wy
            ad = Peek.l(ad)
            wy-1
          Wend
          a$ = ExtractLabel(Peek.l(ad+4))
          If old_active_win <> #_winMouseables
            Activate old_active_win
            evalrequest   = #_mouseable_eval
            evalrequestex = old_active_win
            d_eval{"?"+a$,#SIGNAL}
          EndIf
        EndIf
      EndIf
    EndIf
  EndIf
Return


CheckKeyboard:
.@message_key
  num = 1
  If kbshift
    Use Window evw
    num = InnerHeight ASR 6
  EndIf

  Select EventCode

    Case $23 ; f
      d_exec{"dbl_flip {}"}

    Case $19 ; p
      If evw = #_winDisAsm
        ad        = Peek.l(MyBufferAddress)
        ad.l      = Peek.l(ad+64)
        disasm_ad = ad - 2
        UpdateDisAsm{}
      EndIf

    Case $35 ; b
      If evw = #_winSource OR evw=#_winDisAsm
        If ali
          t$   = "Move To Breakpoint"
          flag = -1
          Gosub SelectBP
          If bp
            ad = breakpoint_adr
            bp-1
            ad+(bp ASL 3)
            If evw = #_winSource
              il = Peek.l(Peek.l(ad))
              Gosub prtcode2
            Else
              disasm_ad = Peek.l(ad)-2
              UpdateDisAsm{}
            EndIf
          EndIf
        EndIf
      EndIf

    Case $40 ; <SPACE>
      If evw = #_winMemory1 Then dowin=0
      If evw = #_winMemory2 Then dowin=1
      If dowin <> -1
        winnum=evw
        x = 0 : y = 0
        Gosub MemEdit
      EndIf

    Case $28 ; L
      If evw = #_winMemory1 Then dowin = 0 : a$ = memlock$(0)
      If evw = #_winMemory2 Then dowin = 1 : a$ = memlock$(1)
      If evw = #_winDisAsm  Then dowin = 2 : a$ = disasmlock$
      If dowin <> -1
        flag = 0
        a$ = RTEZGetString("Lock window","Enter expression to lock onto:",80,a$)
        ConvToPostFix a$,&evalbuffer$
        ad = PFEvaluate(Peek.s(&evalbuffer$))
        If PFErrorType
          reply = RTEZRequest("Lock window","Malformed argument","_Okay")
        Else
          If evw <> #_winDisAsm
            If a$ <> "" Then mempointer(dowin) = ad
            memlock$(dowin) = a$
            memlockpf$(dowin) = Peek.s(&evalbuffer$)
            Domemtitle{dowin}
            RedrawMem{}
          Else
            If a$ <> "" Then disasm_ad = ad
            disasmlock$   = a$
            disasmlockpf$ = Peek.s(&evalbuffer$)
            Poke$ ?disasmlockstr,a$
            If (Peek.l(Addr Window(#_winDisAsm)))
              Use Window #_winDisAsm
              t$ = "Disassembly"
              If disasmlock$ <> "" Then t$+" ("+disasmlock$+")"
              WTitle t$
              UpdateDisAsm{}
            EndIf
          EndIf
        EndIf
      EndIf

    Case $42 ; TAB
      If evw < 0 Then evw =- 1
      Repeat
        evw+1
        If evw = #_winBackdrop Then evw+1
        If evw > (Maximum Window-1) Then evw = 0
      Until Peek.l(Addr Window(evw)) <> 0
      Activate evw
      WindowToFront_ Peek.l(Addr Window(evw))

    Case $4c ; UP cursor
      FlushEvents
      Select evw

        Case #_winSource
          flag = 0
          ;num = 1 : If kbshift Then num = ch
          If ali
            For h = 1 To num
              If Peek.l(il+4)
                il3.l = Peek.l(il+4) : aflag.l = -1
                If Peek.l(il3) = il Then il = il3
              EndIf
            Next h
            If aflag Then Gosub prtcode2
          EndIf

        Case #_winMemory1
          flag = -1 : dowin = 0 : Gosub Movemem

        Case #_winMemory2
          flag = -1 : dowin = 1 : Gosub Movemem

        Case #_winDisAsm
          ;If kbshift Then disasm_ad-20
          For h = 1 To num
            offset.l = 0
            Repeat
              offset+2
            Until (DisAssemble$(disasm_ad-offset) <> "?????" AND InstrSize = offset) OR offset = 8
            If offset = 8 Then offset = 2
            disasm_ad-offset
          Next h
          UpdateDisAsm{}

        Case #_winDisCop
          discop_ad-(num ASL 2)
          UpdateDisCop{}

      End Select

    Case $4d ; DOWN cursor
      FlushEvents
      Select evw

        Case #_winSource
          flag = 0
          ;num = 1 : If kbshift Then num = ch
          If ali
            For h = 1 To num
              If Peek.l(il)
                il3.l = Peek.l(il) : aflag = -1
                If Peek.l(il3) <> 0 Then il = il3
              EndIf
            Next h
            If aflag Gosub prtcode2
          EndIf

        Case #_winMemory1
          flag = 1 : dowin = 0 : Gosub Movemem

        Case #_winMemory2
          flag = 1 : dowin = 1 : Gosub Movemem

        Case #_winDisAsm
          ;If kbshift Then disasm_ad+20
          For h = 1 To num
            If Peek.w(disasm_ad) = $4e41
              disasm_ad+10
            Else
              a$ = DisAssemble$(disasm_ad)
              If a$ <> "?????"
                disasm_ad+InstrSize
              Else
                disasm_ad+2
              EndIf
            EndIf
          Next h
          UpdateDisAsm{}

        Case #_winDisCop
          discop_ad+(num ASL 2)
          UpdateDisCop{}
      End Select

    Case $4F ; Left cursor
      If evw = #_winMemory1 Then jump = 1 : flag = -1 : dowin = 0 : Gosub _doMovemem
      If evw = #_winMemory2 Then jump = 1 : flag = -1 : dowin = 1 : Gosub _doMovemem

    Case $4E ; Right cursor
      If evw = #_winMemory1 Then jump = 1 : flag = 1 : dowin = 0 : Gosub _doMovemem
      If evw = #_winMemory2 Then jump = 1 : flag = 1 : dowin = 1 : Gosub _doMovemem

    Case $45 ; ESCape
      CNIF #test = 1
        exitflag = 1
      CELSE
        d_quit{}
      CEND

    Case $37 ; m
      Select evw

        Case #_winMemory1
          cur.l = 0
          If kbshift
            lt$ = lasteval$
          EndIf
          Gosub goto_MemWindow

        Case #_winMemory2
          cur = 1
          If kbshift
            lt$ = lasteval$
          EndIf
          Gosub goto_MemWindow

        Case #_winDisAsm
          evalrequest = #_disasmaddress
          If evq AND $8
            !ComData_GetL{comPtr_CurrentSourceLine,D0} : temp45.l = PutRegD0 ; replaced TEDGetCurrentLine{} ;was TEDGetCurrentLine_()                ;ped line to disasm window
            MOVE.l programstart,a0
            MOVE.l a0,a1
            ADD.l programsize,a1

           _pg2
            CMP.w #$4e41,(a0)+
            BNE _pg3
            MOVE.l (a0),d1
            AND.l #$80000000,d1
            BEQ _noe
            MOVE.l (a0),d1
            AND.l #$7fffffff,d1
            ADD.l startcode@(a5),d1
            MOVE.l d1,a3
            MOVE.l temp45@(a5),a2
            LEA 9(a2),a2
            LEA 9(a3),a3
            MOVEQ #0,d0
            MOVE.b -1(a2),d0
            ADDQ.l #4,a0

           _l1
             CMPM.b (a2)+,(a3)+
             BNE _pg3
            DBF d0,_l1

           BRA _pg4

           _noe
            CMP.l (a0)+,d0
            BEQ _pg4

           _pg3
            CMP.l a0,a1
            BGT _pg2
           BRA _pg5

           _pg4
            MOVE.l a0,d0
            SUBQ.l #6,d0
            disasm_ad = PutRegD0
            UpdateDisAsm{}

           _pg5
          Else
            Gosub goto_disassemble
          EndIf

        Case #_winDisCop
          evalrequest = #_discopaddress
          Gosub goto_disassemble

        Default
          If evw >= #_winObject0 AND evw <= #_winObject9
            Gosub goto_objectwin
          EndIf

      End Select

    Case #RK_HELP ; help key
      If wininfo(evw)\helplink
        a$ = Peek.s(wininfo(evw)\helplink)
        DoHelp{a$}
      EndIf
  End Select
Return


.GetAddress:
goto_MemWindow:
  If kbshift = 0
    strg$ = "$"+Hex$(mempointer(cur))
    lt$   = strg$
    strg$ = RTEZGetString("Memory location","Enter address to jump to:",40,strg$)
  Else
    strg$ = lt$
  EndIf
  If strg$
    evalrequest   = #_memwindow
    evalrequestex = cur
    ;d_eval{strg$,#SIGNAL}
    ConvToPostFix strg$,&evalbuffer$
    mempointer(cur) = PFEvaluate(Peek.s(&evalbuffer$))
    RedrawMem{}
  Else
    evalrequest = 0
  EndIf
Return


goto_disassemble:
  If kbshift = 0
    strg$ = "$"+Hex$(disasm_ad)
    lt$   = strg$
    strg$ = RTEZGetString("Set location","Enter base address:",40,strg$)
  Else
    strg$ = lt$
  EndIf
  If strg$
    If evalrequest <> #_discopaddress
    ConvToPostFix strg$,&evalbuffer$
    disasm_ad=PFEvaluate(Peek.s(&evalbuffer$))
   UpdateDisAsm{}
   Else
    d_eval{strg$,#SIGNAL}
   EndIf
  Else
    evalrequest = 0
  EndIf
Return


goto_objectwin:
  FindStructureWin{evw}
  If objwins()\is_bbobject = 0
    evalrequest = #_structaddress
    PushItem objwins()
    Gosub goto_disassemble
    Return
  EndIf
  If objwins()\maxobject = 1 Then Return
  If kbshift = 0
    strg$ = RTEZGetString("Object number","Enter object number:",40,strg$)
  Else
    strg$ = lt$
  EndIf
  a.w = Vallong(strg$)
  If a < 0 OR a >= objwins()\maxobject
    reply=RTEZRequest(scrtitle$,"Object value out of range!","  _Ok  ")
    Return
  EndIf
  objwins()\tracenum    = a
  objwins()\typepointer = objwins()\objbaseadr+(a*objwins()\type_sizeof)
  If (Peek.l(Addr Window(objwins()\winnum)))

    Use Window objwins()\winnum
    WTitle "Newtype: "+objwins()\t+" #"+Str$(objwins()\tracenum)+"/"+Str$(objwins()\maxobject-1)

    MoveProp objwins()\winnum,#OBJ_SGAD,a,objwins()\winnum

    RefreshTypeWindow{}
  EndIf
Return


.domenu0:
  If ItemHit < 5
    Select ItemHit

      Case 0
        ad = ?help_sr

      Case 1
        ad = ?help_debug

      Case 3
        ad = ?help_keyboard

    End Select
    reply = RTEZRequest(scrtitle$,Peek.s(ad),"_Okay",2,1,4)
  Else
    Select ItemHit

      Case 5
        Gosub Savewindows

      Case 6
        Gosub doscreenmode

      Case 7
        Gosub dowindowheight

      Case 8  ; select font
        aslfo_SetRequesterTitle {"Please select Source-Font:","",""} ; changed to asl font requester  tomsmart1 2016 03 01
        aslfo_SetInitialFont{prefs\fontname,prefs\fontsize}
        If aslfo_Request{False}  ; only nonproportionalfonts are allowed
          prefs\fontname = aslfo_GetFontName{}
          prefs\fontsize = aslfo_GetFontSize{}
          message{"Choose Menu Save configuration or quit and restart debugger","Save prefs and restart debugger"}
;         reply = GTMenuChecked(0,0,8)
;         If reply <> tokenise
;           If reply Then tokenise=1 Else tokenise = 0
;           tokenise = 1
;           SetupLESDebug token_addr,tokenise
;           If tokenise = 1
;             BitMap 3,640,maxheight,2
;           Else
;             Use Window #_winSource
;               w.w  = InnerWidth
;               hi.w = InnerHeight
;               ;Boxf 0,0,w,hi,0
;             ;InnerCls
;             Gosub wprint
;             Free BitMap 3
;           EndIf
;           If winstatus(#_winDisAsm)
;             Use Window #_winDisAsm
;             ;InnerCls
;               w.w  = InnerWidth
;               hi.w = InnerHeight
;               ;Boxf 0,0,w,hi,0
;               UpdateDisAsm{}
;
;           EndIf
;           pb = 0 : mc = -1 : Gosub prtcode
;         EndIf
        EndIf

      Case 9
        syntax_ = GTMenuChecked(0,0,9)
        Gosub newsize
        Gosub refwindow

      Case 10
        logcon = GTMenuChecked(0,0,10)

      Case 11
        CNIF #test = 1
          exitflag = 1
        CELSE
          d_quit{}
        CEND

      Case 12
        reply = RTEZRequest(scrtitle$,Peek.s(?hardquit),"_Quit|_Cancel",2,1,4)
        If reply Then exitflag = 1

    End Select
  EndIf
Return


hardquit: Dc.b "Perform hard Quit?",10,"Warning: Debug process will not",10,"exit.",0
          Even


.domenu1:
  If ItemHit < 9
    evw = #_winControl
    ev  = 64
    gad = ItemHit+11
    i$  = ""
    If gad = 17 Then Toggle #_winControl,17 : Redraw #_winControl,17
    If gad = 18 Then Toggle #_winControl,18 : Redraw #_winControl,18
    If gad = 19 Then Toggle #_winControl,19 : Redraw #_winControl,19
  Else
    Select ItemHit

      Case 10
        If winstatus(#_winSearch) = 0
          NewWindow{#_winSearch}
          RedrawSearchWin{?variabletypes}
        Else
          DelWindow{#_winSearch}
        EndIf

      Case 11
        array$ = RTEZGetString("Arrays","Enter array name:",80)
        If array$ <> ""
          a   = Instr(array$,"(")
          b.l = Instr(array$,",")
          c.l = Instr(array$,")")
          If b = 0
            array1 = 0
            array2 = Vallong(Mid$(array$,a+1,c-1))
          Else
            array1 = Vallong(Mid$(array$,a+1,b-a-1))
            array2 = Vallong(Mid$(array$,b+1,c-b-1))
          EndIf
          array$ = Left$(array$,a-1)
          nt = RTEZRequest("Arrays","Enter variable type:","_b|_w|_l|_Cancel")
          If nt <> 0
            If array1 <> 0
              d_eval{"&"+array$+"(0,0)",#SIGNAL}
            Else
              d_eval{"&"+array$+"(0)",#SIGNAL}
            EndIf
            arrayitemsize = (2^nt)+1
            arraydatasize = nt

            If array1 > array2
              si = array1
            Else
              si = array2
            EndIf
            a$ = Hex$(si)
            If si > 255
              If si > 65535
                arraylabelsize = 4
              Else
                arraylabelsize = 2
              EndIf
            Else
              arraylabelsize = 1
            EndIf
            pos.l = 1
            While Mid$(a$,pos,1) = "0"
              pos+1
            Wend
            pos = (9-pos)+1
            If pos > arrayitemsize Then arrayitemsize = pos
            evalrequest = #_arrayfind
          EndIf
        EndIf

      Case 12
        is_bb.l = 0
        Gosub NewTypeWindow

      Case 13
        If winstatus(#_winCustom) = 0
          NewWindow{#_winCustom}
          RedrawCustomWin{}
        Else
          DelWindow{#_winCustom}
        EndIf

      Case 14
        If winstatus(#_winMouseables) = 0
          NewWindow{#_winMouseables}
          RedrawMouseables{True}
        Else
          DelWindow{#_winMouseables}
        EndIf

      Case 15
        If winstatus(#fpuwin) = 0
          If wininfo(#fpuwin)\w = 0 Then wininfo(#fpuwin)\w = 539 : wininfo(#fpuwin)\h = 36
          wininfo(#fpuwin)\gadlist = -1
          WZWindow #fpuwin,?wzdat,20,wininfo(#fpuwin)\x,wininfo(#fpuwin)\y,wininfo(#fpuwin)\w,(wininfo(#fpuwin)\h*WinFontHeight)/8,1
          winstatus(#fpuwin) = -1
        Else
          DelWindow{#fpuwin}
        EndIf
        If winstatus(#_winVariables) Then UpdateVarWindow{}  ; only the values are print
        RedrawRegs{}

      Case 16
        asmstep = NOT asmstep

      Case 17
        If watch0 = False
          If ask{"This feature bangs the address 0!","Go ahead!|Oopps!"}
            Poke $0,$beaddeef
            addr0.l  = Peek.l (0)
            watch0.l = NOT watch0
          EndIf
        Else
          watch0 = False
        EndIf
    End Select
  EndIf
Return


Statement newwizardwin{h.l,num.l,ad.l}
SHARED winstatus(),wininfo()

  If wininfo(h)\w = 0 Then wininfo(h)\w = 539 : wininfo(h)\h = 36
  wininfo(h)\gadlist = -1
  WZWindow h,ad,20,wininfo(h)\x,wininfo(h)\y,wininfo(h)\w,wininfo(h)\h,num
  winstatus(#fpuwin) = -1
End Statement


.domenu2:
  If objectbusy = 0 AND dstatus = #STOPPED
    mytype  = ItemHit
    address = Peek.l(?MyTypes+(mytype ASL 2))
    is_bb   = -1
    Gosub NewTypeWindow
  EndIf
Return


.domenu3:   ; misc menu events
  Select ItemHit

    Case 0 ;add trace
      Gosub GetNewVariable
      If winstatus(#_winVariables) = 0
        NewWindow{#_winVariables}
      EndIf

    Case 1 ;del trace
      Gosub GetVariableNameAndType    ; changed to a subroutine call to get the type too  tomsmart1 2016 02 14
      If na$ <> ""                    ; check if we have a name
        If nt > 0 AND nt < 7          ; check id we have a type
          Gosub _Deltrace

          If a AND winstatus(#_winVariables)
            RedrawVarWindow{}
            UpdateVarWindow{}
          EndIf
        EndIf
      EndIf

    Case 2 ; del all...
      reply = RTEZRequest(varfollow$,"Clear all variables?","_Yes|_No")
      If reply = 1
        ClearList varinfo()
        If winstatus(#_winVariables) Then RedrawVarWindow{}
      EndIf

    Case 3 ; sort
      StringSort varinfo(),SizeOf.variabletype,6   ; sizeof (.l + .b + .b) added offset because i changed the layout befor so the string is on the end  tomsmart1
      If winstatus(#_winVariables)
        RedrawVarWindow{}
        UpdateVarWindow{}
      EndIf

    Case 5 ; auto eval
      autoeval = GTMenuChecked(0,3,5)
      If autoeval <> 0 AND na$ = "" Then Gosub DefAutoEval

    Case 6
      Gosub DefAutoEval

    Case 8
      a$ = RTEZGetString(scrtitle$,"Enter breakpoint address:",10)
      If a$ <> ""
        ad = Vallong(a$)
        Gosub addbreakpoint
      EndIf

    Case 9
      t$   = "Select breakpoint to delete:"
      flag = -1
      Gosub SelectBP
      If bp
        ad = breakpoint_adr+((bp-1)ASL 3)
        Gosub deletebreakpoint
      EndIf

    Case 10
      If Peek.l(breakpoint_adr)
        a = RTEZRequest(scrtitle$,"Kill all breakpoints?","_Okay|_Cancel")
        If a
          FillMem ?breakpoint,5*8
          If winstatus(#_winDisAsm) Then UpdateDisAsm{}
        EndIf
      EndIf

    Case 11
      t$   = "Current breakpoints:"
      flag = 0
      Gosub SelectBP
  End Select
Return


.domenu4:
  D_InitParse customcomm$(ItemHit)
  a$ = ProcessString
  Execute_ a$,0,0
Return


;ad = address
;typ = type of breakpoint (#break_?????)
;Returns: flag = 0 for error, else -1 for added okay
addbreakpoint_quiet:
  If Peek.w(ad) = $4e41
    ad+2
    a = typ
    If a
      ad2 = breakpoint_adr
      num = 0
      While Peek.l(ad2) <> 0
        If Peek.l(ad2) = ad
          Poke.l ad2,0
        Else
          ad2+8
          num+1
        EndIf
      Wend

      Poke.l ad2,ad
      Poke.w ad2+4,a
      If a = #break_simple Then b = 1 Else b = 0
      Poke.w ad2+6,b
      flag = -1
    EndIf
  EndIf
Return


DefAutoEval:
  na$ = RTEZGetString("Auto EVAL","Please enter string to evaluate:",80,autoeval$)
  If na$ <> ""
    autoeval$ = na$
    autoeval  = 1
  Else
    autoeval  = 0
    autoeval$ = ""
  EndIf
  GTSetMenuChecked 0,3,5,autoeval
Return


.addbreakpoint:
  If Peek.w(ad) = $4e41 OR asmstep
    ad+2
    a = RTEZRequest(scrtitle$,"Select a breakpoint or function:","_Permanent|C_ount|_Simple|Cnt _down|_Remove Stop|Set PC|_Cancel")
    b = 0
    If a = 4
      a$ = RTEZGetString(scrtitle$,"Enter the counter value for this breakpoint:",20)
      b = Vallong(a$)
      If b = 0 Then a = 0
    EndIf
    If a = 6
      pc_ad.l = Peek.l(MyBufferAddress)
      Poke.l pc_ad+64,ad
      RedrawRegs{}
      UpdateDisAsm{}
      a = 0
    EndIf
    If a
      If a = 5
        Poke.l ad+8,$4e714e71 : Poke.w ad+12,$4e71 : UpdateDisAsm{} : disasm_ad = ad
        CacheClearU_
        Return
      EndIf
      ad2 = breakpoint_adr
      num = 0
      While Peek.l(ad2) <> 0 AND num < #maxbreakpoints
        If Peek.l(ad2) = ad
          Poke.l ad2,0
        Else
          ad2+8
          num+1
        EndIf
      Wend
      If num < #maxbreakpoints
        If a = #break_simple    Then b = 1
        If a = #break_countdown Then a = #break_simple
        bt1.l = ad2-breakpoint_adr
        Poke.w bt1+?breakstore,Peek.w(ad-2)
        If asmstep Then Poke.w ad-2,$4e41
        Poke.l ad2,ad
        Poke.w ad2+4,a
        Poke.w ad2+6,b
      Else
        a = RTEZRequest(scrtitle$,"No spare breakpoints available.","_Okay")
      EndIf
      If winstatus(#_winDisAsm) Then UpdateDisAsm{}
    EndIf
  Else
    a = RTEZRequest(scrtitle$,"Can only breakpoint basic instructions.","_Okay")
  EndIf
Return


;ad = address of breakpoint to delete
.deletebreakpoint:
  bt1 = ad-breakpoint_adr
  Poke.w Peek.l(ad)-2,Peek.w(bt1+?breakstore)
  While Peek.l(ad) <> 0
    Poke.l ad,Peek.l(ad+8)
    Poke.l ad+4,Peek.l(ad+12)
    ad+8
  Wend
  If winstatus(#_winDisAsm) Then UpdateDisAsm{}
Return


;t$ = text to display
; Returns breakpoint number in bp (or 0 for cancel)
.SelectBP:
  a$   = ""
  b$   = ""
  ad.l = breakpoint_adr
  If Peek.l(ad) = 0
    a  = RTEZRequest(scrtitle$,"No breakpoints defined.","_Okay")
    bp = 0
  Else
    num = 0
    While Peek.l(ad) <> 0
      num+1
      ad2 = Peek.l(ad)
      Gosub GETInstruction

      a$+"BP "+Str$(num)+": "+GetHex$(ad2-2,3)+" >>> "+Left$(d_d$,40)+Chr$(10)
      If flag Then b$+"_"+Str$(num)+"|"
      ad+8
    Wend
    If flag
      b$+"_Cancel"
    Else
      b$ = "_Okay"
    EndIf
    bp = RTEZRequest(scrtitle$,t$+Chr$(10)+a$,b$)
  EndIf
Return


.doscreenmode:
  If SubHit < 4
    scrmode = SubHit
  Else
    Select SubHit

      Case 5
        *myscr.screeninfo = 0
        *myscr            = RTEZScreenModeRequest("Editor screen mode",%1000010000000000000)
        If *myscr
          If *myscr\width >= 640 AND *myscr\height >= 200
            ModeID  = *myscr\id
            swidth  = *myscr\width
            sheight = *myscr\height
          Else
            reply = RTEZRequest(scrtitle$,"Minimum screen size is 640 x 200.","_Okay")
          EndIf
        EndIf

    End Select
  EndIf
  Gosub CheckScrModeMenus
Return


.CheckScrModeMenus:
  If scrmode = 1 OR scrmode = 2
    a = On
  Else
    a = Off
  EndIf

  GTMenuState 0,0,6,6,a
  GTMenuState 0,0,6,7,a
Return


dowindowheight:
  a = RTEZGetLongRange(scrtitle$,"Maximum window height:",200,1024,maxheight)
  If a <> 0
    maxheight = a
    BitMap 1,640,maxheight,1 ; WIDTH MUST NOT CHANGE!
    If tokenise Then BitMap 3,640,maxheight,2
  EndIf
Return


.CorruptWindow:
  If evw >= #_winObject0 AND evw <= #_winObject9
    FindStructureWin{evw}
    RefreshTypeWindow{}
    Return
  EndIf
  Select evw

    Case #_winSource
      Use Window #_winSource
      ;BeginRefresh_ !windowaddr
        Gosub newsize
        Gosub refwindow
      ;EndRefresh_  !windowaddr,True

    Case #_winMemory1
      Use Window #_winMemory1
      InnerCls
      dowin = 0
      RedrawMem{}

    Case #_winMemory2
      Use Window #_winMemory2
      InnerCls
      dowin = 1
      RedrawMem{}

    Case #_winVariables
      RedrawVarWindow{}
      UpdateVarWindow{}

    Case #_winDisAsm
      UpdateDisAsm{1}   ; force clear of the Window

    Case #_winDisCop
      UpdateDisCop{}

    Case #_winRegisters
      InitRegsWin{}
      RedrawRegs{}

    Case #_winSearch
      RedrawSearchWin{?variabletypes}

    Case #_winArray
      RedrawArray{1}

    Case #_winCustom
      RedrawCustomWin{}

    Case #_winMouseables
      mouseables_off = 0
      RedrawMouseables{True}

  End Select
Return


.Movetoregister:
  a = Vallong(Right$(strg$,1))
  If a >= 0 AND a <= 7
    ad              = Peek.l(MyBufferAddress)
    mempointer(cur) = Peek.l(ad+32+(32*(a$="d"))+(a ASL 2))
    If mflag Then mempointer(cur) = Peek.l(mempointer(cur))
  Else
    reply = RTEZRequest(scrtitle$,"Invalid register number!","Ok")
  EndIf
Return


;i=code line to grab
.getsyntax:
  syntax_$ = ""
  If i
    toke.w   = Peek.w(getad{i}+Peek.w(i+4))
    ;toke.w   = Peek.w(Peek.l(i)+Peek.w(i+4))
    tokead.l = token_addr
    toke = toke AND $7fff
    While (tokead <> 0 AND toke <> -1)
      If Peek.w(tokead+4) = toke
        syntax_$ = Peek.s(tokead+6)
        syntax_$+" "+Peek.s(tokead+7+Len(syntax_$))
        toke = -1
      EndIf
      tokead = Peek.l(tokead)
    Wend
  EndIf
  Gosub syntaxprint
Return


.wprint:
  If (Peek.l(Addr Window(#_winSource)))
    Use Window #_winSource
    lt$ = t$
    y.l = wprinty.l
    Gosub printlin
    If syntax_ = 0
      ;NPrint "                                                                                                       "
      Return
    EndIf

syntaxprint:
    Use Window #_winSource
    y  = wprinty-WinFontHeight-5
    t$ = syntax_$
    Gosub printlin
  EndIf
Return


; y = y pixel to print at
; t$ = line to print
printlin:
  Wline ix.l,y-1,ix+iw.l-1,y-1,1
  Wline ix.l,y,ix+iw-1,y,2
  WBox ix,y+1,ix+iw-1,y+WinFontHeight+2,0
  b = FLen(t$)
  a = TextFit_(RastPort(#_winSource),t$,b,&myextent.TextExtent,0,1,iw-2,1024)

  WLocate 1,y-iy+2 : WColour 1,0
  If b < a
    Print t$
  Else
    Print Left$(t$,a)
  EndIf
Return

; wy = offset from top of window
.initgads:

  Restore buttondata
  ;Borders 4,2 :
  BorderPens 2,1
  Borders 4,5
  GadgetsHeight.l = 5*2 +8 ; 5= border top and buttom,  8= topaz fontYSize
  gx.l = WinBorLeft : gn.l = 1 : wy = WinBorTextTop.l;+2
  Repeat
    Read t$
    If t$ <> ""
      gf.l = 0
      If t$ = "GS" OR t$ = "PS" OR t$ = "BC" Then gf = %1
      TextGadget #_winControl,gx,wy,gf,gn,t$ : gx+Len(t$)LSL 3+4*2; 4 = border left and right
      gn+1
    EndIf
  Until t$ = ""

;Search window:
  BorderPens 1,2
  StringGadget 3, 88,wy   ,0,0, 10,160
  StringGadget 3, 88,wy+14,0,1, 10,160

  StringGadget 2,160,wy   ,0,1, 40,160
  StringGadget 2,160,wy+14,0,4, 40,160

  StringGadget 2,160,wy+34,0,7,256,160

  BorderPens 2,1
  TextGadget 2,160,wy+48,0, 8,"  "

  TextGadget 2,332,wy   ,0, 2,"MEM1"
  TextGadget 2,372,wy   ,0, 3,"MEM2"
  TextGadget 2,332,wy+14,0, 5,"MEM1"
  TextGadget 2,372,wy+14,0, 6,"MEM2"

  Borders 8,4
  TextGadget 2,150,wy+69,0,10," Start search "
  Borders 4,2

;Array window
  PropGadget  #_winArray,-13,wy+1,#VPROP_AFLAGS,#ARR_YGAD,10,-17-WinFontHeight-22,#VPROP_PFLAGS,3

  ArrowGadget #_winArray,#ARR_UGAD,#UPIMAGE,-17,-20-11,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
  ArrowGadget #_winArray,#ARR_DGAD,#DOWNIMAGE,-17,-20,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2

  PropGadget  #_winArray,3,-7,#HPROP_AFLAGS,#ARR_XGAD,-22-33,6,#HPROP_PFLAGS,3

  ArrowGadget #_winArray,#ARR_LGAD,#LEFTIMAGE,-49,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
  ArrowGadget #_winArray,#ARR_RGAD,#RIGHTIMAGE,-33,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
  SetPropInfo #_winArray,#ARR_YGAD,1,1
  SetPropInfo #_winArray,#ARR_XGAD,1,1

;Source window
  PropGadget  #_winSource,3,-7,#HPROP_AFLAGS,#SRC_SGAD,-22-33,6,#HPROP_PFLAGS,3
  ArrowGadget #_winSource,#SRC_LGAD,#LEFTIMAGE,-49,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
  ArrowGadget #_winSource,#SRC_RGAD,#RIGHTIMAGE,-33,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2

;label window
  PropGadget  #_winMouseables,-13,wy+1,#VPROP_AFLAGS,#MSE_SGAD,10,-17-WinFontHeight-22,#VPROP_PFLAGS,3
  ArrowGadget #_winMouseables,#MSE_UGAD,#UPIMAGE,-17,-20-11,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
  ArrowGadget #_winMouseables,#MSE_DGAD,#DOWNIMAGE,-17,-20,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
Return


buttondata:
  Data$ "STOP","STEP","SKIP","TRACE","RUN","<",">","EXEC"
  Data$ "EVAL","BLTZ","REG","MEM1","MEM2","VAR","ASM"
  Data$ "COP","GS","PS","BC",""


; -2 = workbench
; -1 = like workbench
.findsc:
  ;*scr     = 0
  dreg     = 0
  pubname$ = ""

  Use IntuiFont 1
  Select scrmode

    Case #SCR_WB
      FindScreen 0,"Workbench"
      pubname$ = "Workbench"
      dreg     = &pubname$

    Case #SCR_DEFPUB
      dreg = 0

    Case #SCR_NAMEDPUB
      dreg = &pubscreenname$
  End Select

  If ExecVersion < 39 AND scrmode = #SCR_LIKEWB
    ModeID = $8000 : swidth = 640 : sheight = DispHeight
  EndIf

  If scrmode = #SCR_LIKEWB OR scrmode = #SCR_CUSTOM
    If scrmode = #SCR_LIKEWB AND ExecVersion >= 39
      si = ?myscreentags1
      CNIF #test = 1
        Poke.l ?scrbehind1+4,0
      CEND
    Else
      If ExecVersion < 39
        si = ?myscreentagsv37
      Else
        si = ?myscreentags2
      EndIf
      Gosub SetupScreenTags
      CNIF #test = 1
        Poke.l ?scrbehind2+4,0
      CEND
    EndIf

    If pubscreen.l = 0
      Poke.l si+4,0
    Else
      Poke.l si+4,?pubname
    EndIf

    If ScreenTags(0,scrtitle$,si)<1024
      ModeID  = $8000
      swidth  = 640
      sheight = DispHeight
      Gosub SetupScreenTags
      ScreenTags 0,scrtitle$,si
    EndIf

    s0.l = Peek.l(Addr Screen(0))
    If pubscreen
      PubScreenStatus_ s0,0
      pubname$ = "REDDebugger"
    EndIf

    sw = Peek.w(s0+12) : sh = Peek.w(s0+14)
    CNIF #test=0
      Window #_winBackdrop,0,0,sw,sh,$200900,"",1,2
    CELSE
      Window #_winBackdrop,0,0,sw,sh,$201900,"",1,2
    CEND
  Else
    If GetPubScreen(0,dreg) = 0
      GetPubScreen 0,0
      dreg = 0
    EndIf
    s0 = Peek.l(Addr Screen(0))
  EndIf
     ;FindScreen(0)
   ;   If FindTask_("amiblitz2")=0
   ;      Execute_ "blitz2:amiblitz2",0,0
   ;      Delay_ 100
   ;   EndIf

  AddProcessPtr "s",&pubname$

  sw = Peek.w(s0+12) : sh = Peek.w(s0+14)
Return


SetupScreenTags:
  Poke.l ?scrmodeid+4,ModeID
  ;Poke.l ?scrwidth+4,swidth
  ;Poke.l ?scrheight+4,sheight
Return


.myscreentags1:
              Dc.l  #SA_PubName,pubname ; MUST BE FIRST TAG!
              Dc.l  #SA_Type,#PUBLICSCREEN
              Dc.l  #LikeWorkbench,1
              ;Dc.l  #_Depth,2
              Dc.l  #AutoScroll,-1
  ;scrbehind1: Dc.l  #Behind,-1
              Dc.l #SA_SharePens,-1
              Dc.l  0,0

myscreentagsv37:
              Dc.l  #Pens,pens

myscreentags2:
              Dc.l  #SA_PubName,pubname ; MUST BE FIRST TAG!
              Dc.l  #SA_Type,#PUBLICSCREEN
              Dc.l  #LikeWorkbench,1
              ;Dc.l  #_Depth,2
  scrmodeid:  Dc.l  #DisplayID,0
  scrwidth:   ;Dc.l  #Width,0
  scrheight:  ;Dc.l  #Height,0
              Dc.l  #AutoScroll,-1
              Dc.l #SA_SharePens,-1
  ;scrbehind2: Dc.l  #Behind,0
              Dc.l  0,0

pubname:      Dc.b  "ab2debugger",0
              Even

pens:         Dc.w  -1


.printsourcewin
.refwindow:
  If ali <> 0 OR lt$ <> ""
    Use Window #_winSource:
    ;WindowFont 1
    WBox ix,iy+(ch.l/WinFontHeight ),ix+iw-1,y,0
    If ali Then i = ali : Gosub prtcode
    If syntax_
      y = wprinty-6-WinFontHeight
    Else
      y = wprinty-1
    EndIf

    t$ = lt$ : Gosub wprint
  EndIf
  WLocate 0,0
Return


; Close a window
; evw = window number
; flag = 0 means DON'T CLOSE DEFAULT WINDOWS!
.RemoveWindow:
  If evw = #_winSource OR evw=#_winControl
    If flag
      CNIF #test = 1
        exitflag = 1
      CELSE
        d_quit{}
      CEND
    EndIf
  Else
    If evw >= #_winObject0 AND evw <= #_winObject9
      FindStructureWin{evw}
      FreeMem objwins()\mem_type,(objwins()\numitems ASL 2)+4
      KillItem objwins()
    EndIf
    DelWindow{evw}
    If evw >= #_winObject0 AND evw <= #_winObject9
      Free GadgetList evw
    EndIf
  EndIf
Return


.openwindow:
  wininfo(#_winMemory1)   \title = "Memory 1"
  wininfo(#_winMemory2)   \title = "Memory 2"
  wininfo(#_winControl)   \x     = 0, ScreenBarHeight, 632 + WinBorLeft + WinBorRight, 5*2+8, $20002e, cntrlwin$, #_winControl, ?help_cntrlwin
  wininfo(#_winRegisters) \flags = $20002f, "Register Window", -1 ,?help_reg
  wininfo(#_winSource)    \flags = $0002f, "Sourcecode View", #_winSource, ?help_source
  wininfo(#_winVariables) \flags = $20002f, varfollow$, -1, ?help_var
  wininfo(#_winDisAsm)    \flags = $20002f, "Disassembly", -1, ?help_asm
  wininfo(#_winDisCop)    \flags = $20002f, "Copper Instructions",-1, ?help_cop
  wininfo(#_winSearch)    \x     = 0,ScreenBarHeight + WinBorTextTop,412 + WinBorLeft + WinBorRight,100,$20002e,"Search Window", 2, ?help_search
  wininfo(#_winArray)     \flags = $20003f, "Array", #_winArray, ?help_array
  wininfo(#_winCustom)    \x     = 0,ScreenBarHeight + WinBorTextTop,264 + WinBorLeft + WinBorRight, 41,$20002e,"Custom Chip Window", 3, ?help_chips
  wininfo(#_winMouseables)\flags = $20003f, "Label List", #_winMouseables, ?help_labels

  ad2 = -1
  If dos_Exist{my_path$} ; Path changed (Marco 21.01.15)
    If ReadFile(0,dos_AddPart{my_path$,"RED_DBug.prefs"} ) ; Path changed (Marco 21.01.15)
      ;If Lof(0) = configsize
        ad2 = AllocVec_(configsize+4096,#MEMF_PUBLIC|#MEMF_CLEAR)
        ad  = ad2
        ReadMem 0,ad2,configsize
        If Peek.w(ad2) <> ( (Vallong("\\__VER_MAJOR") ASL 8) + Vallong("\\__VER_MINOR") )
          FreeVec_ ad2
          ad2 = -1
        EndIf
      ;EndIf
      If ReadFile(0,dos_AddPart{my_path$,"RED_DBug2.prefs"} ) ; Path changed (Marco 21.01.15)
        ReadType 0,prefs
        ;If prefs\fontname = "" Then prefs\fontname = "topaz.font",8
        CloseFile 0
      EndIf
      CloseFile 0
    ;Else
    ;  error{"Unable to find \\22ENV:RED_DBug.prefs\\22!"}
    EndIf
  EndIf

  If prefs\fontname >< "" AND prefs\fontsize > 4
    ta.TextAttr\ta_Name = &prefs\fontname
    ta\ta_YSize         = prefs\fontsize
    ta\ta_Style         = 0
    ta\ta_Flags         = 0
    *testfont.TextFont  = OpenDiskFont_ (ta)
  Else
    *testfont = 0
  EndIf

  If *testfont = 0 ; unable to open font => use system default
    InitRastPort_ testrp.RastPort  ; no (*)pointer else it get zeropagehits and crashs
    AskFont_ testrp,ta.TextAttr ; might be better
    prefs\fontname = Peek.s(ta\ta_Name)
    prefs\fontsize = ta\ta_YSize
  EndIf

  LoadFont 1,prefs\fontname,prefs\fontsize
  LoadFont 2,prefs\fontname,prefs\fontsize,#FSF_BOLD
  LoadFont 3,prefs\fontname,prefs\fontsize,#FSF_ITALIC

  If ad2 = -1
    ad = ?initstate
    defaultuse.l = True         ; added to indicate that we use default settings to arrange the Windows  tomsmart1 2016 03 15
  Else
    defaultuse   = False
  EndIf

  startcode = 0
  scrmode   = Peek.w(ad+2)
  ad+4
  ModeID    = Peek.l(ad)
  swidth    = Peek.w(ad+4)
  sheight   = Peek.w(ad+6)
  tokenise  = Peek.b(ad+8)
  tokenise  = 1
  pubscreen = Peek.b(ad+9)
  maxheight = Peek.w(ad+10)
  BitMap 1,640,maxheight,1 ; WIDTH MUST NOT CHANGE!
  If tokenise Then BitMap 3,640,maxheight,2
  Gosub findsc
  address.l = ad
  Gosub openmenus
  ad = address

  ;fontstruct.TextAttr\ta_Name=?topazname,8,0,0
  LoadFont 0,"topaz.font",8
  ;LoadFont 0,prefs\fontname,prefs\fontsize

  Gosub initgads
  num = Peek.w(ad+12)
  ad+14

  For h = 0 To num-1                           ; copy and set the window position and dimentions
    winstatus(h) = Peek.w(ad) : ad+2
    If (#noresize BitTst h)
      wininfo(h)\h + WinBorTextTop + WinBorBottom
    Else
      wininfo(h)\w = Peek.w(ad+4),Peek.w(ad+6)
    EndIf
    If defaultuse = False                      ; added to better arrange the windows if we use default settings  tomsmart1 2016 03 15
      wininfo(h)\x = Peek.w(ad),Peek.w(ad+2)
    Else
      If h = #_winControl                      ; check if we have the control window
        wininfo(h)\x = 0,ScreenBarHeight       ; to open the control window not over the screenbar
      Else
        wininfo(h)\x = 0,ScreenBarHeight + WinBorTextTop + WinBorBottom + GadgetsHeight ; to open the other windows not over the control window
      EndIf
    EndIf

    ad+8
  Next h

  MaxLen disasmlock$   = 85
  MaxLen disasmlockpf$ = 85
  procstatus     = Peek.b(ad) : ad+1 : If procstatus   Then Toggle #_winControl,18,On
  blitzcontrol   = Peek.b(ad) : ad+1 : If blitzcontrol Then Toggle #_winControl,19,On
  gosubstatus    = Peek.b(ad) : ad+1 : If gosubstatus  Then Toggle #_winControl,17,On
  defpubscreen.l = Peek.b(ad) : ad+1
  syntax_        = Peek.b(ad) : ad+1

 .@prefsload
  disasmlock$ = Peek.s(ad)
  If disasmlock$ = "" Then disasmlock$ = "pc-2"
  Poke$ ?disasmlockstr,disasmlock$
  ConvToPostFix disasmlock$,&evalbuffer$
  i = PFEvaluate(Peek.s(&evalbuffer$))
  disasmlockpf$ = Peek.s(&evalbuffer$)
  If disasmlock$ <> ""
    wininfo(#_winDisAsm)\title = "Disassembly ("+disasmlock$+")"
    initdiss.l                 = 20
  EndIf

  ad+128
  num2.l = Peek.w(ad)
  ad+2
  For h = 23 To num2-1
    winstatus(h) = Peek.w(ad) : ad+2
    If (#noresize BitTst h)
      wininfo(h)\h + WinBorTextTop + WinBorBottom
    Else
      wininfo(h)\w = Peek.w(ad+4),Peek.w(ad+6)
    EndIf

    wininfo(h)\x = Peek.w(ad),Peek.w(ad+2)

    ad+8
  Next h

  If ad2 <> -1 Then FreeVec_ ad2

  If scrmode = #SCR_LIKEWB OR scrmode = #SCR_CUSTOM
    If pubscreen AND defpubscreen Then SetDefaultPubScreen_ ?pubname
  Else
    ReleasePubScreen 0,dreg
  EndIf

  For h = 23 To num2-1
      If winstatus(h) AND (#winprotect BitTst h) = 0
         newwizardwin{h,1,?wzdat}
        evw = h
      EndIf
  Next h

  NewWindow{#_winControl}

  For h = 0 To num-1
    If winstatus(h) AND (#winprotect BitTst h) = 0
      If h = #_winMemory1 OR h = #_winMemory2
        NewMemWindow{h}
      Else
        NewWindow{h}
        evw = h
        Gosub CorruptWindow
      EndIf
    Else
      winstatus(h) = 0
    EndIf
  Next h

  GTSetMenuChecked 0,0, 8  ,tokenise
  GTSetMenuChecked 0,0, 6,6,pubscreen
  GTSetMenuChecked 0,0, 6,7,defpubscreen
  GTSetMenuChecked 0,0, 9  ,syntax_
  GTSetMenuChecked 0,0,10  ,logcon
  GTSetMenuChecked 0,0, 6  ,scrmode,On
  GTSetMenuChecked 0,1,16  ,asmstep
  Gosub CheckScrModeMenus

  Use Window #_winSource
  ;WindowFont 0

  CatchDosErrs
  CNIF #test = 1
    Activate #_winControl
  CEND
Return


.newsize:
  If rememberInnerWidth.l >< InnerWidth OR rememberInnerHeight.l >< InnerHeight
    Use Window #_winSource ; : InnerCls
    ;WindowFont 1
    rememberInnerWidth.l  = InnerWidth
    rememberInnerHeight.l = InnerHeight
    ix = WLeftOff : iy = WTopOff : iw = InnerWidth : ih = InnerHeight-WinFontHeight-5
    ;ix = 0 : iy = 0 : iw = InnerWidth : ih = InnerHeight-ScreenFontYSize-5
    wprinty = iy+ih+2
    ;iy = 11
    If syntax_ Then ih-WinFontHeight-5
    cw = iw/8 : ch = ih/WinFontHeight
    ym = ch LSR 1 : If ch&1 = 0 Then ym-1
    ym*WinFontHeight:spc$=String$(" ",cw)
    Gosub printsourcewin
    SetPropInfo #_winSource,1,cw,1000,source_char_offset
    Redraw #_winSource,1
  EndIf
Return


.openmenus:
  ;Menu 0
  GTMenuTitle       0,0    ,"Project"
   GTMenuItem 0,    0,0,0  ,"Status register"     ,"" ,    0,?help_menus
   GTMenuItem 0,    0,0,1  ,"About Debugger"      ,"" ,    0,?help_about
   GTMenuItem 0,    0,0,2
   GTMenuItem 0,    0,0,3  ,"Keyboard shortcuts"  ,""  ,    0,?help_menus
   GTMenuItem 0,    0,0,4
   GTMenuItem 0,    0,0,5  ,"Save configuration"  ,"W" ,    0,?help_configuration
   GTMenuItem 0,    0,0,6  ,"Screen mode..."      ,""  ,    0,?help_screenmode

    GTSubItem  0,   %1,0,6,0,"Workbench"           ,""  ,%1110,?help_screenmode
    GTSubItem  0,   %1,0,6,1,"Like Workbench"      ,""  ,%1101,?help_screenmode
    GTSubItem  0,   %1,0,6,2,"Custom"              ,""  ,%1011,?help_screenmode
    GTSubItem  0,   %1,0,6,3,"Default public"      ,""  ,%0111,?help_screenmode
    GTSubItem  0,   %1,0,6,4
    GTSubItem  0,   %0,0,6,5,"Select custom..."    ,""  ,    0,?help_screenmode
    GTSubItem  0,%1001,0,6,6,"Public screen"       ,""  ,    0,?help_screenmode
    GTSubItem  0,%1001,0,6,7,"Default pubscreen"   ,""  ,    0,?help_screenmode

   GTMenuItem 0,    0,0, 7 ,"Window height..."    ,""  ,    0,?help_screenmode
   GTMenuItem 0,    0,0, 8 ,"Choose Font"         ,""  ,    0,?help_menus
   GTMenuItem 0,%1001,0, 9 ,"Show syntax"         ,""  ,    0,?help_menus
   GTMenuItem 0,%1001,0,10 ,"Trace Log"
   GTMenuItem 0,    0,0,11 ,"Quit"
   ;GTMenuItem 0,    0,0,12 ,"Quit & die"

  ;Menu 1
  GTMenuTitle       0,1    ,"Windows"
   GTMenuItem 0,    0,1, 0 ,"Registers"           ,"D" ,    0,?help_reg
   GTMenuItem 0,    0,1, 1 ,"Memory 1"            ,"M" ,    0,?help_mem
   GTMenuItem 0,    0,1, 2 ,"Memory 2"            ,"N" ,    0,?help_mem
   GTMenuItem 0,    0,1, 3 ,"Variables"           ,"V" ,    0,?help_var
   GTMenuItem 0,    0,1, 4 ,"Disassembly"         ,"6" ,    0,?help_asm
   GTMenuItem 0,    0,1, 5 ,"Copper"              ,"C" ,    0,?help_cop
   GTMenuItem 0,    0,1, 6 ,"Gosub Step"          ,"G" ,    0,?help_gs
   GTMenuItem 0,    0,1, 7 ,"Procedure Step"      ,"P" ,    0,?help_ps
   GTMenuItem 0,    0,1, 8 ,"Blitz Control"       ,"B" ,    0,?help_bc
   GTMenuItem 0,    0,1, 9
   GTMenuItem 0,    0,1,10 ,"Search memory"       ,"S" ,    0,?help_search
   GTMenuItem 0,    0,1,11 ,"Array..."            ,"R" ,    0,?help_array
   GTMenuItem 0,    0,1,12 ,"Structure..."        ,"T" ,    0,?help_struct
   GTMenuItem 0,    0,1,13 ,"Custom chips"        ,""  ,    0,?help_chips
   GTMenuItem 0,    0,1,14 ,"Label list"          ,""  ,    0,?help_labels
   GTMenuItem 0,    0,1,15 ,"FPU On"              ,""  ,    0,?help_fpu
   GTMenuItem 0,%1001,1,16 ,"Asm Step..."         ,""  ,    0,?help_asmstep
   GTMenuItem 0,%1001,1,17 ,"Check Addr 0 Change" ,""  ,    0,?help_watch0

  ;Menu 2
  GTMenuTitle 0,2,"Objects"
  si  = ?MyTypes
  num = 0
  Repeat
    ad1 = Peek.l(si)
    si+4
    If ad1
      a$ = Peek.s(ad1+2)
      If num = 0 Then a$ = a$+"       "
      GTMenuItem 0,0,2,num,a$,"",0,?help_objects
      num+1
    EndIf
  Until ad1 = 0

  ;Menu 3
  GTMenuTitle       0,3    ,"Misc"
   GTMenuItem 0,    0,3, 0 ,"Add trace..."        ,"A" ,    0,?help_menus
   GTMenuItem 0,    0,3, 1 ,"Delete trace..."     ,""  ,    0,?help_menus
   GTMenuItem 0,    0,3, 2 ,"Delete all..."       ,""  ,    0,?help_menus
   GTMenuItem 0,    0,3, 3 ,"Sort names"          ,""  ,    0,?help_menus
   GTMenuItem 0,    0,3, 4
   GTMenuItem 0,%1001,3, 5 ,"Auto EVAL"           ,""  ,    0,?help_autoeval
   GTMenuItem 0,    0,3, 6 ,"Define"              ,"Z" ,    0,?help_autoeval
   GTMenuItem 0,    0,3, 7
   GTMenuItem 0,    0,3, 8 ,"Add breakpoint..."   ,"[" ,    0,?help_breakpoints
   GTMenuItem 0,    0,3, 9 ,"Delete..."           ,"]" ,    0,?help_breakpoints
   GTMenuItem 0,    0,3,10 ,"Delete all..."       ,""  ,    0,?help_breakpoints
   GTMenuItem 0,    0,3,11 ,"List..."             ,""  ,    0,?help_breakpoints
  GetCustomMenus{}

  CreateMenuStrip 0
Return


stopit:
  prtcode = -1 : stepcnt = 0 : dstatus = #STOPPED : statego = -1
Return


.getevent:
.@memcheckloop
  Repeat
    ;error{"eventloop!"}
    ev = Event
    If ev = 0
      If dstatus = #TRACE
        Delay_ 1
      Else
        Delay_ 2
      EndIf
    EndIf

   _again1
    If ev.l = #IDCMP_MOUSEMOVE
      If winbubble.l Then CloseWindow #bubble : winbubble.l = 0
      ev = Event : Pop If : Goto _again1
    EndIf
    memchecktimer-1
    currentwin.l = Used Window
    If watch0
      If Peek.l (0) <> addr0
        Use Window 0 : WTitle "!!!! Address 0 is changed !! $"+Hex$(Peek.l(0))+" "+Left$(Peek.s(Peek.l(0)),30)
        Use Window currentwin
      EndIf
    EndIf
    ;BTST #8,$dff016
    ;BNE _nomid
    ;BTST #6,$bfe001
    ;BNE _nomouse
;    If (EventQualifier AND $1000) = 0 Then Goto _nomid
;      ev = Event
;    !cout{EventQualifier}
;
;
;
;   _nomid

    ;AddIDCMP #IDCMP_INTUITICKS

    Goto _skip

   ;error{"clicks..."}

   checkclicks
    If (EventCode AND $80) <> 0 Then Goto _nomid2 ; ignore up mouse
    If (EventQualifier AND $1000) = 0 Then Goto _nomid3
    If evw = #_winMemory2
      If EventQualifier AND $30
        JSR memhistoryup
        Delay_(10)
      EndIf
      If EventQualifier AND $c0
        JSR memhistorydown
        Delay_(10)
      EndIf
    EndIf
    If evw = #_winDisAsm
      If EventQualifier AND $30
        JSR historyup
        Delay_(10)
        FlushEvents
      EndIf
      If EventQualifier AND $c0
        JSR historydown
        Delay_(10)
        FlushEvents
      EndIf
    EndIf

   _nomid3
    If (EventQualifier AND $1000) <> 0 Then Goto _nomid2
    If ActiveWindow = Peek.l (Addr Window (#_winMemory2))
      Use Window #_winMemory2
      ev     = Event
      xpos.l = WMouseX-WLeftOff
      ypos.l = WMouseY-WTopOff
      memvalueStrpos.l = TextLength_(RastPort,&memStr(0),10)  ; get the x startposition
      If (xpos > memvalueStrpos) AND (xpos < InnerWidth) AND (ypos > 0) AND (ypos < InnerHeight)
        xpos   - memvalueStrpos
        ypos   = ypos/WinFontHeight
        xpos   = TextFit(memStr(ypos),xpos)
        *ptr.l = (.l)&memStr(ypos)
        If *ptr
          Gosub getterm
        Else
          part$ = ""
        EndIf
        If part$ <> ""
          JSR addmemhistory
          ConvToPostFix part$,&evalbuffer$
          temp = PFEvaluate(Peek.s(&evalbuffer$))
          If PFErrorType = 0
            mempointer(1) = temp
            RedrawMem{}
            WTitle part$
            Delay_ 10
          EndIf
        EndIf
      EndIf
      Use Window currentwin
    EndIf

    If (ActiveWindow = Peek.l (Addr Window (#_winDisAsm) ) ) AND (OSVersion = #AmigaOS3)
      Use Window #_winDisAsm
      xpos = WMouseX-WLeftOff ; left border
      ypos = WMouseY-WTopOff  ; top border
      disasmStrpos.l = TextLength_(RastPort,&disStr(1),18)  ; get the x startposition of the DisAsm string
      If (xpos > disasmStrpos) AND (xpos < InnerWidth) AND (ypos > 0) AND (ypos < InnerHeight)
        ; calculate the position
        xpos - disasmStrpos               ; calc the mouse x position of the disasmstring
        ypos = ypos/WinFontHeight         ; calc the line of the string by the mouse y
        xpos = TextFit(disStr(ypos),xpos) ; get the charnumber positionen of string
        If xpos < 8 Then xpos = 8         ; to prevent a false detection on the asm command
        *ptr = (.l)&disStr(ypos)          ; get the pointer of the string
        If *ptr
          Gosub getterm    ; need xpos and i
        Else
          part$ = ""
        EndIf
        If part$ <> ""
          If Left$(part$,1) <> "#"       ; test if we have a address and no value
            part2$ = Replace$ (part$,"(","+")
            If part2$ <> part$
              part$ = Left$(part2$,Len(part2$)-4)
              If Left$(part$,1) <> "-" Then part$ = "+"+part$
              part2$ = Mid$(part2$,Len(part2$)-2,2)
              part$ = part2$+part$
            EndIf
            WTitle part$

            ConvToPostFix part$,&evalbuffer$
            temp = PFEvaluate(Peek.s(&evalbuffer$))
            If PFErrorType = 0
              ev = Event
              If EventQualifier AND $30
                JSR addhistory
                disasm_ad = temp
                UpdateDisAsm{}
                Delay_(20)
              Else
                If winstatus(#_winMemory2) = 0 Then NewMemWindow{#_winMemory2}
                mempointer(1) = temp
                RedrawMem{}
              EndIf
            EndIf
            memchecktimer = 33
            Use Window currentwin
          EndIf
        EndIf
      EndIf
    EndIf

   .@sourcewinclick
    If ActiveWindow = Peek.l (Addr Window (#_winSource))
      Use Window #_winSource

      ;JSR printbubble
      xpos = WMouseX-WLeftOff
      ypos = WMouseY-WTopOff

      If xpos => 0 AND xpos < InnerWidth AND ypos > 2 AND ypos < InnerHeight
        ypos+1
        ;xpos-2
        ypos = ypos/WinFontHeight
        *ptr = (.l)&srcStr(ypos)
        xpos = TextFit(srcStr(ypos),xpos)
        If winbubble.l = 0 Then Window #bubble,SMouseX-10,SMouseY-WinFontHeight*5,WindowWidth,WinFontHeight*3+4,$800,"",0,1 : winbubble = 1
        If *ptr
          Gosub getterm
        Else
          part $ = ""
        EndIf
        Gosub storefpuregs
        If Left$(part$,8) = "optimize" Then part$ = "not support"
        If Left$(part$,8) = "Syntax" Then part$ = "not support"
        If Left$(part$,1) = "\" Then part$ = path$+poin$+part$ ; Then :
        If poin$ Then part$ = poin$+part$
        If part$ Then d_eval{part$,#SIGNAL}
        WTitle part$
        Delay_(2)
        Gosub restorefpuregs

        ev$           = part$
        memchecktimer = 33
        Use Window currentwin
      EndIf
    EndIf

   _nomid2
    Return

   _skip
   _nomouse
    If winstatus(#fpuwin) AND fpuneedupdate.l
      fpuneedupdate-1
      currentwin = Used Window
      Use Window #fpuwin
      MOVE.l fpuoffset,fpreg
      Dc.l $f2276800 ;fmove.x fp0,-(a7)
      TST.l regpos
      BEQ _noreg
      For temp = 0 To 7
        MOVE.l regpos,a0
        ADD.l fpreg,a0
        Dc.l $f2284800 : Dc.w 0 ;fmove.x 0(a0),fp0
        ADD.l #12,fpreg
        fmove.s fp0,d0
        JSR fpuffp
        fp$(temp) = Str$(ffp)
        WZPrint "fpr0"+Str$(temp),&fp$(temp)
      Next temp

     _noreg
      Dc.l $f21f4800 ;fmove.x (a7)+,fp0
      ;error{"Resuse win!"}
      Use Window currentwin
    EndIf
    If winstatus(#_winDisAsm) AND initdiss
      ad = PFEvaluate(disasmlockpf$) ; update disasm
      disasm_ad = ad
      If winstatus(#_winDisAsm) Then UpdateDisAsm{}
      initdiss-1
    EndIf
    If Peek.w(?donebreakpoint)
      t$ = "[Breakpoint]"
      Gosub wprint
      CLR.w donebreakpoint
    EndIf
    If memchecktimer < 1
      a$ = "Chip: "+Str$(AvailMem_(%10))+" Fast:"+Str$(AvailMem_(%100))
      If Peek.l(Addr Window (#_winSource))
        Use Window #_winSource
        ;WTitle a$
        memchecktimer = 33
      EndIf
    EndIf
    If Peek.l(?varhandler)
      asa.l = Peek.l(?varhandler)
      n$    = Peeks$(asa,256)
      Poke.l ?varhandler,0
      Gosub _CheckTrace
    EndIf
    While FirstItem(d_e())
      ; Program running mode into title of #_winControl
      ad = Peek.l(?progmode)
      a  = Peek.w(ad)
      If pmodevalid = 0 OR a <> pmode
        pmodevalid = -1
        pmode      = a
        GetProgMode pmode,&cntrlwin$+14
        SetWindowTitles_ Peek.l(Addr Window(#_winControl)),&cntrlwin$,-1
      EndIf

      If memlock$(0)
        mempointer(0) = PFEvaluate(memlockpf$(0))
      EndIf
      If memlock$(1)
        mempointer(1) = PFEvaluate(memlockpf$(1))
      EndIf

      If winstatus(#_winMemory1) OR winstatus(#_winMemory2) Then RedrawMem{}
      If winstatus(#_winRegisters) Then RedrawRegs{}
      If winstatus(#_winVariables) Then UpdateVarWindow{}   ; only the values are print
      ResetList objwins()
      While NextItem(objwins())
        If objwins()\typepointer >= 0 Then RefreshTypeWindow{}
      Wend

      Select d_e()\t

        Case 0 ; supervisor mode error!
          t$ = "(*) "+d_e()\s
          Gosub wprint
          Gosub goterr

        Case 1 ; user mode error!
          t$ = d_e()\s
          Gosub wprint
          Gosub goterr

        Case 2 ; EVAL result
          If execrequest = #_newtypewindow
            PopItem objwins()
            objwins()\typepointer = 0
            objwins()\maxobject   = 1
            execrequest           = 0
            objectbusy            = 0
            RefreshTypeWindow{}
          Else
            t$        = d_e()\s
            lasteval$ = t$
            If FLen(t$) < 11

              ;OPTIMIZE 7 ; this would require an FPU    why ??? Val() has been updated
               t$ = t$+" $"+Hex$(Val(t$))+" %"+Bin$(Val(t$))
              ;OPTIMIZE 5

            EndIf
            Gosub EVALHandle ; print eval result
            Delay_ 1
            If winbubble = 1 AND part$ <> ""
              evalstr$ = t$
              Use Window #bubble
              Gosub printbubble
            EndIf
            Gosub wprint
          EndIf

        Case 3 ; dump code baby!
          If execrequest = #_newtypewindow
            PopItem objwins()
            execrequest           = 0
            objwins()\typepointer = objwins()\objbaseadr
            t$                    = ""
            SetPropInfo objwins()\winnum,#OBJ_SGAD,1,objwins()\maxobject,0
            Redraw objwins()\winnum,#OBJ_SGAD
            Use Window objwins()\winnum
            WTitle "Newtype: "+objwins()\t+" #"+Str$(objwins()\tracenum)+"/"+Str$(objwins()\maxobject-1)
            RefreshTypeWindow{}
            objectbusy = 0
          EndIf
          If execrequest = #_viewblitz
            Enable #_winControl,10
            execrequest = 0
          EndIf
          cb = d_e()\i
          i  = Peek.l(buffmem+cb)

          If disasmlockpf$ <> ""
            ad = PFEvaluate(disasmlockpf$) ; update disasm
            If ad <> disasm_ad
              disasm_ad = ad
              If winstatus(#_winDisAsm) Then UpdateDisAsm{}
            EndIf
          EndIf

          If syntax_ Then Gosub getsyntax

          pb = 0 : mc = -1 : Gosub prtcode : ;prtbusy = 0
          Signal_ task,signalset

        Case 4 ; QUIT - outa-here
          exitflag = 1

      End Select
      MaxLen d_e()\s = 0 : KillItem d_e()
    Wend
    ;error{"here!"}
    ;ev = Event : If ev = 0 Then Delay_(3) : memchecktimer-1
  Until ev <> 0 OR exitflag <> 0

  Use Window currentwin
  Delay_ 2
Return


.EVALHandle:
  evw.l       = evalrequest
  evalrequest = 0
  Select evw

    Case #_mouseable_eval
      ad = Vallong(d_e()\s)

      Select evalrequestex

        Case #_winMemory1
          mempointer(0) = ad
          cur           = 0
          RedrawMem{}

        Case #_winMemory2
          mempointer(1) = ad
          cur           = 1
          RedrawMem{}

        Case #_winDisAsm
          disasm_ad = ad
          UpdateDisAsm{}

        Case #_winSource
          il = Peek.l(ad+2)
          Gosub prtcode2
      End Select

    Case #_memwindow
      mempointer(evalrequestex) = Vallong(d_e()\s)
      cur                       = evalrequestex
      RedrawMem{}
      t$=""

    Case #_structaddress
      PopItem objwins()
      objwins()\typepointer = Vallong(d_e()\s)
      RefreshTypeWindow{}

    Case #_variablelocate
      varinfo()\address = Vallong(d_e()\s)
      If varinfo()\address = 0
        KillItem varinfo()
        reply = RTEZRequest(scrtitle$,"Variable not found!","_Abort")
      Else
        If varinfo()\typ = 4
          mem = varinfo()\address
          Gosub FindString
          varinfo()\address = ad
          If ad = -1 Then KillItem varinfo() : a = RTEZRequest(scrtitle$,"String not found!","_Ok")
        EndIf
        If winstatus(#_winVariables)
          RedrawVarWindow{}
          UpdateVarWindow{}
        EndIf
      EndIf
      t$ = ""

    Case #_disasmaddress
      disasm_ad = Vallong(d_e()\s) AND $fffffffe
      UpdateDisAsm{}

    Case #_discopaddress
      discop_ad = Vallong(d_e()\s) AND $fffffffe
      UpdateDisCop{}

    Case #_autoevalresult
      t$ = autoeval$+"="+t$

    Case #_arrayfind
      arrayadd = Vallong(d_e()\s)
      If winstatus(#_winArray) = 0
        NewWindow{#_winArray}
      EndIf
      Use Window #_winArray
      a$ = array$+"("
      If array1 <> 0
        a$+Str$(array1)+","+Str$(array2)+")"
      Else
        a$+Str$(array2)+")"
      EndIf
      WTitle a$
      RedrawArray{1}
  End Select
Return


.FreeStuff:
  For h = 0 To (Maximum Window)-1
    If Peek.l(Addr Window(h))
      If h > 22
        WZCloseWindow h
      Else
        Free Window h
      EndIf
      If Peek.l(Addr GadgetList(h)) Then Free GadgetList(h)
    EndIf

  Next h

 _again20
  For h = 1 To 100
    If NewCloseScreen(0) <> 0 Then h = 250
    Delay_ 1
  Next
  If h <= 101 Then a = RTEZRequest(scrtitle$,warn1$,"_Ok") : Goto _again20
  Free GTMenuList 0
  FreeMem_ buffmem,#bufflen
Return


._CheckTrace:
  Ascii = Peek.b(&n$) AND $ff
  nt    = Peek.b(&n$+1)
  nf    = Peek.b(&n$+2)
  si    = Peek.l(&n$+4)
  na$   = Peek.s(&n$+8)
  Select Ascii

    Case #_memwindowmove
      If nt = 0 OR nt = 1
        mempointer(nt) = si
        If nt=0 Then nt = #_winMemory1 Else nt = #_winMemory2
        If winstatus(nt) = 0
          NewMemWindow{nt}
        EndIf
      EndIf

    Case #_diswindow
      disasm_ad = si AND $fffffffe
      If winstatus(#_winDisAsm) = 0
        NewWindow{#_winDisAsm}
      EndIf
      UpdateDisAsm{}

    Case #_varwindow
      If winstatus(#_winVariables) = 0
        NewWindow{#_winVariables}
      EndIf
      a = 1

    Case #_deltrace
      Gosub _Deltrace

    Case #_addtrace
      Gosub _Addtrace

    Case #_copperlist
      discop_ad = si
      If winstatus(#_winDisCop) = 0
        NewWindow{#_winDisCop}
      EndIf
      UpdateDisCop{}

    Case #_proccontrol
      If nf = 0 ; (do Toggle)
        procstatus = NOT(procstatus)
      Else
        procstatus = nt
      EndIf
      Toggle #_winControl,18,procstatus
      Redraw #_winControl,18

  End Select
  If a AND winstatus(#_winVariables)
    RedrawVarWindow{}
    UpdateVarWindow{}
  EndIf
Return


._Deltrace:
  a = 0
  ResetList varinfo()
  While NextItem(varinfo())
    If varinfo()\name = na$
      If varinfo()\typ = nt ; added check of type to be sure we delete the right entry in the var trace  tomsmart1 2016 02 14
        KillItem varinfo()
        a=-1
      EndIf
    EndIf
  Wend
Return


._Addtrace:
  AddLast varinfo()
  varinfo()\name    = na$
  varinfo()\address = si
  varinfo()\typ     = nt
  varinfo()\form    = nf-1
  a = 1
  If varinfo()\typ = 4
    mem = varinfo()\address
    Gosub FindString
    varinfo()\address = ad
    If ad = -1 Then KillItem varinfo() : a = 0
  EndIf
Return


; dowin = window to update
; flag = -1 for move backwards
.Movemem:
  If dowin = 0 Then Use Window #_winMemory1 Else Use Window #_winMemory2
  wwide.l = (InnerWidth ASR 3)-10
  wwide/7
  jump = wwide ASL 1
  If kbshift Then jump = jump*(InnerHeight ASR 6)

_doMovemem:
  If flag = -1
    mempointer(dowin)-jump
  Else
    mempointer(dowin)+jump
  EndIf
  RedrawMem{}
Return








Statement DoCurs{xad.b,num.b}
SHARED ix,iy,mad,mempointer(),wwide,editflag

  If (Peek.l(Addr Window(#_winMemory1+num)) = 0) Then Statement Return
  y.l  = (((mad-mempointer(num))/wwide)ASL 3)+iy
  *rp.RastPort = RastPort(#_winMemory1+num)
  SetDrMd_ *rp,2
  If editflag = 0
    x.l = ix+72+(xad ASL 3)
    If (mad AND %1) ; Odd address
      x+(((xad-1)ASR 2) ASL 3)
    Else
      x+((xad ASR 2) ASL 3)
    EndIf
  Else
    x = ix+80+(wwide*20)+(xad ASL 3)
  EndIf
  RectFill_ *rp,x,y,x+7,y+7
  SetDrMd_ *rp,1
End Statement


.MemEdit:
  If (Peek.l(Addr Window(winnum)) = 0) Then Return

  Use Window winnum
  Activate winnum
  WTitle "Edit mode"
  Gosub meminfo
  DoCurs{0,dowin}

  FlushEvents
  flag = 0
  Repeat
    ev  = WaitEvent
    evw = (EventWindow=winnum)
    evq = EventQualifier
    a$  = Inkey$
    If evw = 0 OR ev = $80000 Then a$ = " " : ev = 0 : evq = 0
    If ev AND evw
      Select ev

        Case 2
          Gosub meminfo

        Case 4
          Gosub meminfo
          ;InnerCls
            w.w  = InnerWidth
            hi.w = InnerHeight
            ;Boxf 0,0,w,hi,0

        Case 512
          a$ = " " : ev = 0 : evq = 0

        Case 1024
          Select EventCode

            Case $4c ; UP cursor
              mad-wwide : flag = -1

            Case $4d ; DOWN cursor
              mad+wwide : flag = -1

            Case $4F ; Left cursor
              xad.l-1 : If xad = -1 Then xad = wxad.l-1 : mad.l-wwide.l
              flag = -1

            Case $4E ; Right cursor
              xad+1: flag = -1
          End Select
          If flag Then a$ = ""
      End Select
    EndIf

    b$ = ""
    If a$ <> ""
      If (evq AND %1000) Then b$ = a$
      If a$ <> " " AND a$ <> Chr$(9) Then b$ = a$
    EndIf
    If editflag
      If b$ <> ""
        Poke.b mad+xad,Asc(a$)
        xad+1
        flag = -1
        a$ = ""
      EndIf
    Else
      If b$ <> ""
        b$ = UCase$(b$)
        If (b$ >= "0" AND b$ <= "9") OR (b$ >= "A" AND b$ <= "F")
          a = Peek.b(mad+(xad ASR 1))
          b = Vallong("$"+b$)
          If (xad AND %1)
            a = (a AND $f0) OR b
          Else
            a = (a AND $0f) OR (b ASL 4)
          EndIf
          Poke.b mad+(xad ASR 1),a
          xad+1
          flag = -1
        EndIf
        a$ = ""
      EndIf
    EndIf
    If a$ = Chr$(9)
      editflag = 1-editflag
      If editflag = 0
        wxad ASL 1
        xad ASL 1
      Else
        wxad = wxad ASR 1
        xad  = xad ASR 1
      EndIf
      flag = 1
    EndIf
    If flag
      If xad > wxad-1 Then xad = 0 : mad+wwide
      If mad >= nmad.l Then mad = nmad : mempointer(dowin)+wwide : nmad+wwide
      If mad < mempointer(dowin) Then mempointer(dowin)-wwide : mad = mempointer(dowin) : nmad-wwide
      num = dowin
      DrawMem{dowin}
      DoCurs{xad,dowin}
      flag = 0
    EndIf
  Until a$ = " "
  DoCurs{xad,dowin}
  Domemtitle {dowin}
  dowin = -1
  RedrawMem{}
Return


meminfo:
  wwide = (InnerWidth ASR 3)-10
  wwide/7
  wxad = wwide ASL 2
  wwide ASL 1

  mad.l  = mempointer(dowin)
  nmad.l = mad+((InnerHeight ASR 3)*wwide)
  xad    = 0 ; count number of 4 bit groups from address ad
  flag   = -1
  If editflag Then wxad = wxad ASR 1
Return


FindString:       ; added more checks to avoid Nullpointer access  tomsmart1 2016 02 05
  ad = Peek.l(MyBufferAddress)
  If (ad)
    ad2 = Peek.l(ad+52)  ; get Value of Register A5
    If (ad2)
    ; replaced the search in the basic variable store with a Basic routine
    ;  ad = D_FindStringPtr(ad2,mem)
      ad2_offset.l = $8000 +2   ; set the size to search
      ad = -1 ; for the case we don't find the string pointer
      Repeat
        ad2_offset - 2 ;
        If Peek.l(ad2 - ad2_offset) = mem  ; test if the pointers match
          ad = ad2 - ad2_offset ; yes get address
          ad2_offset = 0 ; for end until
        EndIf
      Until ad2_offset = 0  ; test if we reach the end
    Else
      ad = -1
    EndIf
  EndIf
  If ad = -1
  ; replaced the unsave search on the stack with one that respected the Stack size and limts
  ;  ad = Peek.l(MyBufferAddress)
  ;  If (ad)
  ;    ad2 = Peek.l(ad+60) ; get Value of Register A7
  ;    If (ad2)
  ;      ad = D_FindStringPtr(ad2+$8000,mem) ; search in stack
  ;    Else
  ;     ad = -1
  ;    EndIf
    *progtask.Task = task        ; get the task pointer of the program to debug
    If (*progtask)               ; test if we have a vaild pointer
      ad2_offset.l = *progtask\tc_SPUpper -3 ; get the upper Stack address and -3 for peek.l to prevent hits
      ad = -1 ; for the case we don't find the string pointer
      Repeat
        ad2_offset -1
        If Peek.l(ad2_offset) = mem  ; test if the pointers match
          ad = ad2_offset ; yes get address
          ad2_offset = *progtask\tc_SPLower ; for end until
        EndIf
      Until ad2_offset = *progtask\tc_SPLower ; test if we reach the lower Stack address
    Else
      ad = -1
    EndIf
  EndIf
Return


.SearchMemory:
  ad1        = Vallong(StringText$(2,1))
  old_ad     = ad1
  ad2        = Vallong(StringText$(2,4))
  searchfor$ = StringText$(2,7)
  nt         = searchtype

  If nt = 0 Then Return

  If nt < 4 Then si = Vallong(searchfor$)
  If nt = 4 Then si = &searchfor$

  ;OPTIMIZE 7 ; this would require an FPU   why ??? Val() has been updated
   If nt = 5 Then mq = Val(searchfor$) : si = Peek.l(&mq)
   If nt = 6 Then mf = Val(searchfor$) : si = Peek.l(&mf)
  ;OPTIMIZE 5

  t$ = "Searching memory.... <SPACE> to abort"
  Gosub wprint
  num = 0

 _doagain
  ad = SearchMem(nt,si,ad1,ad2)

  If ad <> 0 AND ad <> 1
    num+1
    ad = SearchMemFound
    b$ = Peek.s(?search0)+Hex$(old_ad)+Peek.s(?search01)+Hex$(ad2)
    b$+Peek.s(?search1)+Hex$(ad)+Peek.s(?search2)+Hex$(ad-old_ad)+Peek.s(?search3)+Hex$(num)+Peek.s(?search4)
    reply = RTEZRequest("Search",b$,"Mem_1|Mem_2|_Again|_Exit")
    If reply <> 0
      If reply = 3 Then ad1 = ad+1 : Goto _doagain
      mempointer(reply-1) = ad
      RedrawMem{}
    EndIf
  Else
    If ad = 1 Then a$ = Peek.s(?exitpress) Else a$ = Peek.s(?notfound)
    reply = RTEZRequest("Search",a$,"_Okay")
  EndIf

  t$ = "" : Gosub wprint
Return


exitpress: Dc.b       "Search aborted - value not found!",0
notfound:  Dc.b       "Value not found within given range!",0
search0:   Dc.b       "Search start address      $",0
search01:  Dc.b 10,   "Search end address        $",0
search1:   Dc.b 10,   "Found value at address    $",0
search2:   Dc.b 10,   "Offset from start address $",0
search3:   Dc.b 10,   "Total occurences found    $",0
search4:   Dc.b 10,10,"  Move memory window to address?",0
Even







goterr:
  ShowScreen 0
  If Peek.l(Addr Window(0))
    Activate 0
  EndIf
  MOVE.w  #0,proccount
  If winstatus(#_winArray) Then RedrawArray{0}
Return


; Open an object trace window
; address.l = addr
; is_bb.b = 0 or -1
.NewTypeWindow:
  If AddItem(objwins()) = 0
    reply = RTEZRequest(scrtitle$,"No more object windows!","_Okay")
    Return
  EndIf

  ; Get a spare window
  num = #_winObject0
  While Peek.l(Addr Window(num)) <> 0
    num+1
  Wend

  objwins()\winnum      = num
  objwins()\objadr      = address
  objwins()\objbaseadr  = 0
  objwins()\is_bbobject = is_bb

  ; A few variables we're gonna use
  ox = 0 : oy = WinFontHeight+3 : ow = 320
  typelength = 7
  num        = 0
  *_scr.Screen = Peek.l(Addr Screen(0))
  If *_scr
    winheight = *_scr\BarHeight  +WinFontHeight + *_scr\WBorBottom +2 + *_scr\WBorTop
  Else
    winheight = 23+WinFontHeight
  EndIf

  If is_bb
    wininfo(objwins()\winnum)\helplink = ?help_objects
    Gosub ObjectWin
  Else
    wininfo(objwins()\winnum)\helplink = ?help_struct
    Gosub StructWin
  EndIf
  If reply = 0
    KillItem objwins()
    Return
  EndIf

  If num < 3 Then winheight+(3-num)*8

  objwins()\numitems = num
  objwins()\t        = typetitle$
  memadr             = AllocMem((num ASL 2)+4,65536)
  If memadr = 0
    KillItem objwins()
    Return
  EndIf

  typewidth = ix+(typelength ASL 3)+8+16

  PropGadget objwins()\winnum,-13,WinFontHeight+5,#VPROP_AFLAGS,#OBJ_SGAD,10,-17-WinFontHeight-22,#VPROP_PFLAGS,3
  SetPropInfo objwins()\winnum,#OBJ_SGAD,1,1
  ArrowGadget objwins()\winnum,#OBJ_UGAD,#UPIMAGE,-17,-20-11,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
  ArrowGadget objwins()\winnum,#OBJ_DGAD,#DOWNIMAGE,-17,-20,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2

  SizeLimits typewidth+22,winheight,640,1600;winheight
  wflg.l = #WFLG_ACTIVATE|#WFLG_DRAGBAR|#WFLG_DEPTHGADGET|#WFLG_CLOSEGADGET|#WFLG_NEWLOOKMENUS|#WFLG_SIZEGADGET|#WFLG_SIZEBRIGHT
  Window objwins()\winnum,ox,oy,ow,winheight,wflg,"Newtype: "+typetitle$,1,2,objwins()\winnum

 ; DEFTYPE.tag10 wtags
;  wtags\ti_Tag = #WA_AutoAdjust,1,#WA_InnerWidth,ow,#WA_InnerHeight,winheight,#TAG_DONE,0
;  WindowTags objwins()\winnum,$103f|$200000,"Newtype: "+typetitle$,&wtags
  GTSetMenu 0
  WindowFont 0
  winstatus(objwins()\winnum) = -1

  Wline typewidth-5,iy,typewidth-5,iy+InnerHeight-1,1

  objwins()\tracenum    = 0
  objwins()\typewidth   = typewidth
  objwins()\typepointer = -1,memadr
  rp                    = RastPort(objwins()\winnum)

  OutTextPen rp,1
  OutText ix+2,iy+1,rp,"Address"
  oy = 9+iy
  If is_bb
    Gosub ObjectWinD
  Else
    Gosub StructWinD
  EndIf
Return


printbubble
  If winbubble = 0 Then Return
  Use Window #bubble
  WindowFont 1
  xs.l = WindowWidth : ys.l = WinFontHeight*3+4

  WCls
  WBox 0,0,xs-1,ys-1,3
  Wline    0,   0,xs-1,   0,1
  Wline xs-1,   0,xs-1,ys-1,1
  Wline xs-1,ys-1,   0,ys-1,1
  Wline    0,ys-1,   0,   0,1
  WJam 0 : WColour 2
  WLocate 1,1 : Print part$
  WLocate 1,WinFontHeight+1 : Print evalstr$
  WLocate 1,WinFontHeight*2+2 : Print "01234567890123456789012345678901234567890 String Lineal"
  WColour 1 : WJam 1
Return


.NewType_Rout:
ObjectWin:
  objwins()\type_sizeof = Peek.w(address)
  address+2

  typetitle$ = Peek.s(address)
  address+Len(typetitle$)+1
  address2 = address
  y2.l     = sh-oy
  If y2 > maxheight Then y2 = maxheight
  Repeat
    a$ = Peek.s(address)
    address+Len(a$)+3
    If a$
      num+1
      If (Len(a$)) > typelength Then typelength = Len(a$)
      winheight+8
      If (winheight+8) > y2 Then a$ = ""
    EndIf
  Until a$ = ""
  reply = -1
Return


ObjectWinD:
  address = address2
  For h = 1 To num
    a$ = Peek.s(address)
    address+Len(a$)+1
    typ   = Peek.b(address)
    skp.b = Peek.b(address+1)
    If skp = -1
      If typ < 3 Then skp = typ Else skp = 4
    EndIf
    OutText ix+2,oy,rp,LSet$(a$,typelength)+"."+Mid$(objtype$,typ,1)
    oy+8
    Poke.w memadr,typ
    Poke.w memadr+2,skp
    memadr+4
    address+2
  Next h

  CNIF #test = 0
    a$ = "poke.w "+Str$(&objwins()\maxobject)+",maximum "+typetitle$
    a$+":Poke.l "+Str$(&objwins()\objbaseadr)+",Addr "+typetitle$+"(0)"
    d_exec{a$}
    execrequest = #_newtypewindow
    objectbusy  = -1
    PushItem objwins()
  CELSE
    typepointer = Addr Shape(0)
    RefreshTypeWindow{}
  CEND
Return


StructWin:
  suc.l = OpenFile(0,dos_AddPart{my_path$,"structure.lookup"})
  fil$  = ""
  If suc = 0
    reply = RTEZRequest(scrtitle$,"Couldn't locate structure.lookup file.","_Abort")
    reply = 0
    Return
  EndIf
  t$ = RTEZGetString(scrtitle$,"Enter structure name:",80,laststructure$)
  If t$ = "" Then reply = 0 : Return
  laststructure$ = t$
  t$             = LCase$(t$)
  a$             = ""
  b$             = ""
  filepos.l      = 0
  FileInput 0
  flag = 0
  While b$ <> t$ AND NOT(Eof(0))
    a$ = Edit$(256)
    If Left$(a$,1) = "!"
      fil$ = Mid$(a$,2)
    Else
      b$ = LCase$(Mid$(a$,10))
    EndIf
  Wend
  filepos = Vallong("$"+Left$(a$,8))
  If b$ <> t$
    reply = RTEZRequest(scrtitle$,"Type not found!","_Okay")
    CloseFile 0
    reply = 0
    WindowInput 0
    Return
  EndIf
  CloseFile 0
  suc = OpenFile(0,fil$)
  If suc = 0
    reply = RTEZRequest(scrtitle$,"File not found!","_Okay")
    CloseFile 0
    reply = 0
    WindowInput 0
    Return
  EndIf
  FileInput 0
  FileSeek 0,filepos
  a$                    = Edit$(256)
  typetitle$            = Left$(a$,Len(a$)-1)
  a$                    = Edit$(256)
  objwins()\type_sizeof = Val(Mid$(a$,8,6))
  a$                    = "!"
  y2                    = sh-oy

  If y2 > maxheight Then y2 = maxheight

  While a$ <> ""
    a$ = Edit$(256)
    If a$ <> "" AND Right$(a$,1) <> ":"
      a$ = Mid$(a$,22)
      num+1
      If (Len(a$)) > typelength Then typelength = Len(a$)
      winheight+8
      If (winheight+8) > y2 Then a$ = ""
    Else
      a$ = ""
    EndIf
  Wend
  reply = -1
Return


StructWinD:
  FileSeek 0,filepos
  FileInput 0

  flag   = 0
  a$     = Edit$(256)
  a$     = Edit$(256)
  prev.w = 0

  For h = 1 To num
    a$  = Edit$(256)
    typ = Val(Mid$(a$,3,5))
    skp = typ-prev
    If h > 1 Then Poke.w memadr-2,skp

    prev = typ

    Select Val(Mid$(a$,17,3))

      Case 1
        typ = 1

      Case 2
        typ = 2

      Case 4
        typ = 3

      Default
        typ = 0
    End Select

    a$ = Mid$(a$,22)
    b$ = LCase$(a$)

    If Instr(b$,"name") AND skp = 4
      If flag = 0
        reply = RTEZRequest(scrtitle$,"Keyword 'name' found."+Chr$(10)+"Point "+a$+" to string?","_Yes|_All|_No")
        If reply <> 0 Then typ = 4
        If reply = 2 Then flag = -1
      Else
        typ = 4
      EndIf
    EndIf
    a$ = LSet$(a$,typelength)+"."
    If typ > 0
      a$+Mid$(objtype$,typ,1)
    Else
      a$+"?"
      typ = 1
    EndIf
    OutText ix+2,oy,rp,a$
    oy+8
    Poke.w memadr,typ
    memadr+4
  Next h

  WindowInput 0
  CloseFile 0

  objwins()\typepointer = 0
  RefreshTypeWindow{}
Return


.Savewindows:
  ad2 = AllocVec_(configsize+4096,#MEMF_CLEAR|#MEMF_PUBLIC)
  If ad2
    ad = ad2
    Poke.b ad   ,Vallong("\\__VER_MAJOR")
    Poke.b ad+ 1,Vallong("\\__VER_MINOR")
    Poke.w ad+ 2,scrmode
    Poke.l ad+ 4,ModeID
    Poke.w ad+ 8,swidth
    Poke.w ad+10,sheight
    Poke.b ad+12,tokenise
    Poke.b ad+13,GTMenuChecked(0,0,6,6)
    Poke.w ad+14,maxheight
    Poke.w ad+16,#save_numwindows
    ad+18
    For h = 0 To #save_numwindows-1
      Poke.w ad,winstatus(h) : ad+2
      If (Peek.l(Addr Window(h) ) >< 0)
        Use Window h
        wininfo(h)\x = WindowX
        wininfo(h)\y = WindowY
        wininfo(h)\w = WindowWidth
        wininfo(h)\h = WindowHeight
      EndIf
      Poke.w ad,wininfo(h)\x : ad+2
      Poke.w ad,wininfo(h)\y : ad+2
      Poke.w ad,wininfo(h)\w : ad+2
      Poke.w ad,wininfo(h)\h : ad+2
    Next h

    Poke.b ad,procstatus              : ad+1
    Poke.b ad,blitzcontrol            : ad+1
    Poke.b ad,gosubstatus             : ad+1
    Poke.b ad,GTMenuChecked(0,0,6,7)  : ad+1
    Poke.b ad,syntax_                 : ad+1
  .@prefssave
    Poke.s ad,disasmlock$              : ad+128
    Poke.w ad,#wizardwindows          : ad+2
    For h = 23 To #wizardwindows-1
      Poke.w ad,winstatus(h)          : ad+2
      If (Peek.l(Addr Window(h) ) >< 0)
        Use Window h
        wininfo(h)\x = WindowX
        wininfo(h)\y = WindowY
        wininfo(h)\w = WindowWidth
        wininfo(h)\h = WindowHeight
      Else
        Poke.w ad,wininfo(h)\x : ad+2
        Poke.w ad,wininfo(h)\y : ad+2
        Poke.w ad,wininfo(h)\w : ad+2
        Poke.w ad,wininfo(h)\h : ad+2
      EndIf
    Next h

    ;SaveIt{"ENVARC:"} ; no longer needed (Marco 21.01.15)
    SaveIt{my_path$} ; Path changed (Marco 21.01.15)
    FreeVec_ ad2
  Else
    error{"Unable to save config - not enough memory!"}
  EndIf
Return


.MenuHelp:
  ec.l = EventCode
  If ec <> -1
    hitmenu.w    = -1
    hititem.w    = -1
    hitsubitem.w = -1

    If (ec AND 31) <> 31 Then hitmenu = (ec AND 31)

    n = (ec ASR 5) AND 63
    If n <> 63 Then hititem = n

    n = ((ec ASR 11) AND 31)
    If n <> 31 Then hitsubitem = n

    ad.l = GTGetUserData(0,hitmenu,hititem,hitsubitem)
    If ad <> 0
      a$ = Peek.s(ad)
      DoHelp{a$}
    EndIf
  EndIf
Return


variabletypes:
  Dc.b "Byte  ",0
  Dc.b "Word  ",0
  Dc.b "Long  ",0
  Dc.b "String",0
  Dc.b "Quick ",0
  Dc.b "Float ",0

help_sr:
  Dc.b "Status register flags:",10
  Dc.b "X: Extension",10
  Dc.b "N: Negative ",10
  Dc.b "Z: Zero     ",10
  Dc.b "O: Overflow ",10
  Dc.b "C: Carry    ",0

help_debug:
  Dc.b "This program handles runtime error",10,"debugging for programs compiled",10
  Dc.b "and run inside AmiBasic3.",10," ",10,"The original version was written by",10
  Dc.b "Mark Sibly of ACID software.",10," ",10,"This version has been written by",10
  Dc.b "Stephen McNamara of Red When Excited.",10
  Dc.b "Updated in 2002 by Bernd Roesch",10
  Dc.b "Additional updates in 2007 by Sven Dr�ge",10
  Dc.b "Updates 2009-2015 by the Opensource Team",10
  Dc.b 0

.help_keyboard:
  Dc.b "Keyboard Shortcuts",10,10
  Dc.b "BREAK      - CTRL ALT C    STEP  - S",10
  Dc.b "STEPOVER   - D  Call dbl_Flip {} - F",10
  Dc.b "SKIP       - I             TRACE - T",10
  Dc.b "RUN        - R             <<    - ,",10
  Dc.b ">>         - .             EXEC  - X",10
  Dc.b "EVAL       - E             QUIT- ESc",10
  Dc.b "     TAB - Cycle active window      ",10
  Dc.b 10
  Dc.b "Whilst in some windows,",10
  Dc.b "'m' = Enter startadress Shift+m last eval address" ,10
  Dc.b "'l' = Lock Window to Register",10
  Dc.b "'SPACE' in memwin allow change value(SPACE for exit)",10
  Dc.b "ALT+LMB Jump into",10
  Dc.b "ALT+MMB Jump to last position before ALT+LMB",10
  Dc.b "CTRL 'm' in disasmwin show line in ped",10
  Dc.b "'b' = show next breakpoint",0


setregvalue:
  Dc.b "Enter new register value:",10
  Dc.b "    e.g. d0=12345678     ",10
  Dc.b "         d7=$0           ",10
  Dc.b "         a0=",34,"bLtZ",34,"       ",0

closevisitors:

  Even

;Array Aof type definitions
MyTypes:
  Dc.l BitmapType
  Dc.l BlitzfontType
  Dc.l BufferType
  Dc.l Coplisttype
  Dc.l FileType
  Dc.l GTListType
  Dc.l GTMenuListType
  Dc.l IntuifontType
  Dc.l MapObjType
  Dc.l ModuleType
  Dc.l PaletteType
  Dc.l QueueType
  Dc.l ShapeType
  Dc.l SliceType
  Dc.l SoundType
  Dc.l SpriteType
  Dc.l StencilType
  Dc.l TapeType
  Dc.l WindowType
  Dc.l 0

;General form:
;               Sizeof.objtype
;               Object name$
;               [item$
;                item type (#_byte to #_float)
;                item type size (byte size or -1 to take size from type)
;               ]
;All strings should be null terminated.

PaletteType:
  Dc.w 128
  Dc.b "Palette",0
  Dc.b "*_pdata",0,#_long,-1
  Dc.b "numcols",0,#_word,-1
  Dc.b "[locol",0,#_word,-1
  Dc.b "hicol",0,#_word,-1
  Dc.b "speed",0,#_word,-1
  Dc.b "var]",0,#_word,-1
  Dc.b 0

Even
BitmapType:
  Dc.w 64
  Dc.b "Bitmap",0
  Dc.b "_ebwidth",0,#_word,-1
  Dc.b "_height",0,#_word,-1
  Dc.b "_depth",0,#_word,-1
  Dc.b "_pad",0,#_word,-1
  Dc.b "_plane0",0,#_long,-1
  Dc.b "_plane1",0,#_long,-1
  Dc.b "_plane2",0,#_long,-1
  Dc.b "_plane3",0,#_long,-1
  Dc.b "_plane4",0,#_long,-1
  Dc.b "_plane5",0,#_long,-1
  Dc.b "_plane6",0,#_long,-1
  Dc.b "_plane7",0,#_long,-1
  Dc.b "_xcurs",0,#_word,-1
  Dc.b "_ycurs",0,#_word,-1
  Dc.b "_pad[8]",0,#_byte,8
  Dc.b "_flags",0,#_word,-1
  Dc.b "_bitplanemod",0,#_word,-1
  Dc.b "_xclip",0,#_word,-1
  Dc.b "_yclip",0,#_word,-1
  Dc.b "_cclip",0,#_word,-1
  Dc.b "_isreal",0,#_word,-1
  Dc.b 0

Even
ModuleType:
  Dc.w 8
  Dc.b "Module",0
  Dc.b "_mt_data",0,#_long,-1
  Dc.b "_length",0,#_long,-1
  Dc.b 0

Even
BlitzfontType:
  Dc.w 4
  Dc.b "Blitzfont",0
  Dc.b "_font",0,#_long,-1
  Dc.b 0

Even
ShapeType:
  Dc.w 32
  Dc.b "Shape",0
  Dc.b "_pixelwidth",0,#_word,-1
  Dc.b "_pixelheight",0,#_word,-1
  Dc.b "_depth",0,#_word,-1
  Dc.b "_ebwidth",0,#_word,-1
  Dc.b "_bltsize",0,#_word,-1
  Dc.b "_xhandle",0,#_word,-1
  Dc.b "_yhandle",0,2,-1
  Dc.b "_data",0,#_long,-1
  Dc.b "_cookie",0,#_long,-1
  Dc.b "_onebpmem",0,#_word,-1
  Dc.b "_onebpmemx",0,#_word,-1
  Dc.b "_allbpmem",0,#_word,-1
  Dc.b "_allbpmemx",0,#_word,-1
  Dc.b "_pad[2]",0,#_byte,2
  Dc.b 0

Even
TapeType:
  Dc.w 16
  Dc.b "Tape",0
  Dc.b "_ielist",0,#_long,-1
  Dc.b "_timevalhi",0,#_long,-1
  Dc.b "_timevallo",0,#_long,-1
  Dc.b "_pad[4]",0,#_byte,4
  Dc.b 0

Even
StencilType:
  Dc.w 8
  Dc.b "Stencil",0
  Dc.b "_ebwidth",0,#_word,-1
  Dc.b "_height",0,#_word,-1
  Dc.b "_data",0,#_long,-1
  Dc.b 0

Even
QueueType:
  Dc.w 16
  Dc.b "Queue",0
  Dc.b "*currentitem",0,#_long,-1
  Dc.b "*nextitem",0,#_long,-1
  Dc.b "_length",0,#_long,-1
  Dc.b "_pad[4]",0,#_byte,4
  Dc.b 0

Even
FileType:
  Dc.w 32
  Dc.b "File",0
  Dc.b "_handle",0,#_long,-1
  Dc.b "_reclen",0,#_long,-1
  Dc.b "_pad[4]",0,#_byte,4
  Dc.b "*fields",0,#_long,-1
  Dc.b "_buffer",0,#_long,-1
  Dc.b "_flags",0,#_word,-1
  Dc.b "_valid",0,#_word,-1
  Dc.b "_seekoff",0,#_word,-1
  Dc.b "_seek",0,#_long,-1
  Dc.b 0

Even
BufferType:
  Dc.w 16
  Dc.b "Buffer",0
  Dc.b "_current",0,#_long,-1
  Dc.b "_first",0,#_long,-1
  Dc.b "_length",0,#_long,-1
  Dc.b "_pad[4]",0,#_byte,4
  Dc.b 0

Even
SliceType:
  Dc.w 64
  Dc.b "Slice",0
  Dc.b "_ypos",0,#_word,-1
  Dc.b "_flags",0,#_word,-1
  Dc.b "_numbitplanes",0,#_word,-1
  Dc.b "_numsprites",0,#_word,-1
  Dc.b "_numcolours",0,#_word,-1
  Dc.b "_bitplanes",0,#_long,-1
  Dc.b "_sprites",0,#_long,-1
  Dc.b "_colours",0,#_long,-1
  Dc.b "_BPLCON1",0,#_long,-1
  Dc.b "_BPLCON2",0,#_long,-1
  Dc.b "_pad[2]",0,#_byte,2
  Dc.b 0

Even
SoundType:
  Dc.w 16
  Dc.b "Sound",0
  Dc.b "_data",0,#_long,-1
  Dc.b "_period",0,#_word,-1
  Dc.b "_length",0,#_word,-1
  Dc.b "_loop",0,#_long,-1
  Dc.b "_looplength",0,#_word,-1
  Dc.b "_pad[2]",0,#_byte,2
  Dc.b 0

Even
SpriteType:
  Dc.w 16
  Dc.b "Sprite",0
  Dc.b "_data",0,#_long,-1
  Dc.b "_height",0,#_word,-1
  Dc.b "_channels",0,#_word,-1
  Dc.b "_flags",0,#_word,-1
  Dc.b "_nextoff",0,#_word,-1
  Dc.b "_xhandle",0,#_word,-1
  Dc.b "_yhandle",0,#_word,-1
  Dc.b 0

Even
WindowType:
  Dc.w 32
  Dc.b "Window",0
  Dc.b "_window",0,#_long,-1
  Dc.b "_cursx",0,#_word,-1
  Dc.b "_cursy",0,#_word,-1
  Dc.b "_pointer",0,#_long,-1
  Dc.b "_length",0,#_long,-1
  Dc.b 0

Even
IntuifontType:
  Dc.w 16
  Dc.b "Intuifont",0
  Dc.b "_fontname",0,#_string,-1
  Dc.b "_ysize",0,#_word,-1
  Dc.b "_pad",0,#_word,-1
  Dc.b "_font",0,#_long,-1
  Dc.b "_pad2[4]",0,#_byte,4
  Dc.b 0

Even
Coplisttype:
  Dc.w 128
  Dc.b "Coplist",0
  Dc.b "size",0,#_long,-1
  Dc.b "coppos",0,#_long,-1
  Dc.b "colors",0,#_long,-1
  Dc.b "sprites",0,#_long,-1
  Dc.b "bpcons",0,#_long,-1
  Dc.b "bplanes",0,#_long,-1
  Dc.b "dot",0,#_long,-1
  Dc.b "customs",0,#_long,-1
  Dc.b "dob",0,#_long,-1
  Dc.b "bot",0,#_word,-1
  Dc.b "numbp",0,#_word,-1
  Dc.b "colpokes",0,#_word,-1
  Dc.b "fetchwid",0,#_word,-1
  Dc.b "xand",0,#_word,-1
  Dc.b "xshift",0,#_word,-1
  Dc.b "ypos",0,#_word,-1
  Dc.b "height",0,#_word,-1
  Dc.b "res",0,#_word,-1
  Dc.b "numsprites",0,#_word,-1
  Dc.b "numcols",0,#_word,-1
  Dc.b "numcustoms",0,#_word,-1
  Dc.b "cpline",0,#_word,-1
  Dc.b "x0",0,#_quick,-1
  Dc.b "x1",0,#_quick,-1
  Dc.b "bplcon3",0,#_word,-1
  Dc.b "aga",0,#_word,-1
  Dc.b 0

GTListType:
  Dc.w 16
  Dc.b "GTList",0
  Dc.b "gadptr",0,#_long,-1
  Dc.b "visualinfo",0,#_long,-1
  Dc.b "current",0,#_long,-1
  Dc.b "windowptr",0,#_long,-1
  Dc.b 0

MapObjType:
  Dc.w 32
  Dc.b "MapObject",0
  Dc.b "width"    ,0,#_word,-1
  Dc.b "height"   ,0,#_word,-1
  Dc.b "bwidth"   ,0,#_word,-1
  Dc.b "bheight"  ,0,#_word,-1
  Dc.b "datasize" ,0,#_byte,-1
  Dc.b "mapnull"  ,0,#_byte,-1
  Dc.b "*mapdata" ,0,#_long,-1
  Dc.b "viewx"    ,0,#_word,-1
  Dc.b "viewy"    ,0,#_word,-1
  Dc.b "*mapname" ,0,#_string,-1
  Dc.b 0

GTMenuListType:
  Dc.w 16
  Dc.b "GTMenuList",0
  Dc.b "*Menulist",0,#_long,-1
  Dc.b "*Privatelist",0,#_long,-1
  Dc.b "numitems",0,#_word,-1
  Dc.b 0

;Window status,position and size.
;Format: Status.w (0=closed)
;        x position
;        y position
;        x size
;        y size

Even
.@prefsstruct
initstate:
  Dc.b 0 ; will be set at program start
  Dc.b 0 ; will be set at program start
  Dc.w #SCR_WB                                             ; actual screen type
  Dc.l $8000                                               ; Screen mode ID
  Dc.w 640                                                 ; Screen width
  Dc.w 256                                                 ; Screen height
  Dc.b 0                                                   ; Tokenise
  Dc.b 0                                                   ; public screen
  Dc.w 2048                                                ; max window height
  Dc.w #save_numwindows                                    ; number of window definitions
  Dc.w -1,0,124,432,256-124                                ; Source window pos,size
  Dc.w -1,0,11,640,26                                      ; Control window pos,size
  Dc.w 0,0,37,640,87                                       ; Registers
  Dc.w 0,0,0,0,0                                           ; Backdrop
  Dc.w 0,432,124,208,256-124                               ; Mem1
  Dc.w 0,432,124,208,256-124                               ; Mem2
  Dc.w 0,0,11,420,100                                      ; Search window
  Dc.w 0,0,11,320,128                                      ; Variable window
  Dc.w 0,0,11,320,128                                      ; 680x0 Disassembly window
  Dc.w 0,0,11,320,128                                      ; Copper Disassembly window
  Dc.w 0,0,11,320,128                                      ; Custom chip registers
  Dc.w 0,0,11,320,128                                      ; Array window
  Dc.w 0,0,11,160,200                                      ; Label List window
  Dc.b 0                                                   ; Status of ProcedureStep
  Dc.b 0                                                   ; Status of Blitzcontrol
  Dc.b 0                                                   ; Status of GosubStep
  Dc.b 0                                                   ; default Public screen mode
  Dc.b 0                                                   ; show syntax mode
  Dcb.b 31,0

disasmlockstr: Dc.b "pc-2",0 : Ds.b 128-5
  Dc.w 0,0,11,420,100                                      ; FPU Reg Window

endof_init:
  Even

sizeofsave:         Dc.w endof_init-initstate

help_menus:         Dc.b "MENUS",0
help_about:         Dc.b "ABOUT",0
help_cntrlwin:      Dc.b "WIN_PROGCNTRL",0
help_source:        Dc.b "WIN_SOURCE",0
help_configuration: Dc.b "NODEconfiguration",0
help_screenmode:    Dc.b "NODEscrmode",0
help_reg:           Dc.b "WIN_REGS",0
help_mem:           Dc.b "WIN_MEM",0
help_var:           Dc.b "WIN_VARS",0
help_asm:           Dc.b "WIN_DISASM",0
help_cop:           Dc.b "WIN_COPPER",0
help_gs:            Dc.b "NODEgosubstep",0
help_ps:            Dc.b "NODEproccontrol",0
help_bc:            Dc.b "NODEblitzcontrol",0
help_search:        Dc.b "WIN_SEARCH",0
help_array:         Dc.b "WIN_ARRAY",0
help_struct:        Dc.b "WIN_STRUCTURES",0
help_chips:         Dc.b "WIN_CUSTOMCHIPS",0
help_labels:        Dc.b "WIN_LABELLIST",0
help_objects:       Dc.b "WIN_OBJECTS",0
help_autoeval:      Dc.b "NODEautoeval",0
help_breakpoints:   Dc.b "NODEbreakpoints",0
help_fpu:           Dc.b "WIN_FPU",0
help_asmstep:       Dc.b "WIN_ASMSTEP",0
help_watch0:        Dc.b "WIN_WATCH0",0
Even
wzdat:              IncBin "reddebug.wizard"
Even


fpuffp
  fpu.l = PutRegD0
  ffp   = SPFieee_(ffp) ; for mathtranspointer
  GetRegD0 fpu
  JSR -$6c(a6)
  MOVE.l d0,ffp@(a5)
Return


setfpu
  fp$(temp) = RTEZGetString("Insert FPU Value","Insert FPU Value",80,fp$(temp))

  ;OPTIMIZE 7 ; this requires an FPU      why ??? Val() has been updated
  ffp = Val(fp$(temp))
  ;OPTIMIZE 5

  ffp2.f = SPTieee_(ffp2) ; for mathtranspointer
  MOVE.l ffp@(a5),d0
  JSR -102(a6)
  fmove.s d0,fp0
  MOVE.l regpos,a0
  ADD.l fpuoffset,a0
  GetRegD0 temp
  MULS #12,d0
  ADD.w d0,a0
  Dc.l $f2106800    ;fmove.x fp0,(a0)
  RedrawRegs{}
Return


.getterm ;in: *ptr , xpos , i ; ret: part$
  inbrack.l = 0
  poin$     = ""
  ;error{"Get the term!"}
  temp = Peek.b(*ptr+xpos)
  If temp = @"\"
;    If Peek.l(i) AND $80000000
;      i3.l = (Peek.l(i) AND $7fffffff)+startcode
;    Else
;      i3 = Peek.l(i)
;    EndIf
;    Repeat
;      il3.l = Peek.l(i3+4):
;      If Peek.l(il3)=i3
;         i3 = il3
;      Else
;        i3 = 0
;      EndIf
;      If i3
;         p$ = peek.s (i3+9)
;         If Instr(p$,Mki$ ($80ca))
;           InitArgParse p$
;           ret$  = NextArg$
;           path$ = NextArgChar$(@" ","","")
;           i3    = 0
;         EndIf
;      EndIf
;    Until i3 = 0
    typepath$ = RTEZGetString(scrtitle$,"Insert a path for newtype begin with \",128,path$)
  EndIf
  If temp = @"*"
    poin$ = "*"
  EndIf
  If temp = @"#"
    poin$ = "#"
  EndIf

 _wloop
  temp = Peek.b(*ptr+xpos)

  xpos-1
  ;If temp = $2e OR temp = 36 OR temp = 45 Then Goto _wloop
  If temp = @"." OR temp = @"$" OR temp = @"-" OR temp = @"#" Then Goto _wloop ; added the check of '#' DisAsm can identify Values and adresses  tomsmart1
  If temp = @"+" Then Goto _wout
  If temp = @"\"
    If Peek.l(i) AND $80000000
      i3.l = (Peek.l(i) AND $7fffffff)+startcode
    Else
      i3 = Peek.l(i)
    EndIf
    Repeat
      il3.l = Peek.l(i3+4)          ; :
      If Peek.l(il3) = i3
        i3 = il3
      Else
        i3 = 0
      EndIf
      If i3
        p$ = Peek.s (i3+9)
        If Instr(p$,Mki$ ($80ca))
          InitArgParse p$
          ret$ = NextArg$
          If typepath$ = ""
            path$ = NextArgChar$(@" ","","")
          Else
            path$ = typepath$
          EndIf
          i3 = 0
        EndIf
      EndIf
    Until i3 = 0
  EndIf
  If temp = @"{" Then xpos+1 : Goto _wout
  If temp >= $30 AND temp <= $39 Then Goto _wloop ; 0-9
  If temp < $40 Then xpos+1 : Goto _wout
  If xpos < 0 Then Goto _wout
  Goto _wloop

 _wout
  xpos+1 : schar.l = xpos
  temp = Peek.b (*ptr+xpos)
  If temp = @"$" OR temp = @"-" Then xpos+1 : If Peek.b(*ptr+xpos) = @"$" Then xpos+1

 _wloop2
  temp = Peek.b(*ptr+xpos)
  If temp = @"(" Then inbrack+1
  If temp = @")" AND inbrack = 0  Then Goto _wout2
  If temp = @"-" AND inbrack <> 0 Then Goto _weit1
  If temp = @" " AND inbrack <> 0 Then Goto _weit1
  If temp = $22  AND inbrack <> 0 Then Goto _weit1
  If temp = @")" Then inbrack-1
  If temp = @"}" Then Goto _wout2
  If inbrack <> 0 AND temp = @"," Then Goto _weit1
  If temp = @"." OR temp = @"(" OR temp = @")" OR temp = @"$" OR temp = @"*" OR temp = @"#" Then Goto _weit1
  If temp >= $30 AND temp <= $39 Then Goto _weit1
  If temp < $40 Then Goto _wout2

 _weit1
  xpos+1
  Goto _wloop2

 _wout2
  part$ = Peeks$(*ptr+schar,xpos-schar)
Return


storefpuregs
  TST.l regpos
  BEQ 'skip  ;<= this prevents an enforcer hit!

  MOVE.l regpos,a0
  ADD.l fpuoffset,a0
  MOVEQ #7,d0
  LEA fpustore,a1

 'l1
    MOVE.l (a0)+,(a1)+
    MOVE.l (a0)+,(a1)+
    MOVE.l (a0)+,(a1)+
  DBF d0,'l1

 'skip
RTS


restorefpuregs
  TST.l regpos
  BEQ 'skip  ; <= this prevents an enforcer hit!

  MOVE.l regpos,a0
  ADD.l fpuoffset,a0
  MOVEQ #7,d0
  LEA fpustore,a1

 'l1
    MOVE.l (a1)+,(a0)+
    MOVE.l (a1)+,(a0)+
    MOVE.l (a1)+,(a0)+
  DBF d0,'l1

  'skip
RTS


.@addhistory
addhistory ; d0 linenum
  MOVEM.l a0/d1,-(a7)
  LEA history,a0
  MOVEQ #0,d1
  MOVE.w historypointer,d1
  GetRegD0 disasm_ad
  MOVE.l d0,0(a0,d1)
  ADDQ.w #4,d1
  CMP.w  #maxhistory*4,d1
  BLE 'nowrap
  MOVEQ #0,d1

 'nowrap
  MOVE.w d1,historypointer
  MOVEM.l (a7)+,a0/d1
RTS


addmemhistory ; d0 linenum
  MOVEM.l a0/d1,-(a7)
  LEA memhistory,a0
  GetRegD0 mempointer(1)
  MOVEQ #0,d1
  MOVE.w memhistorypointer,d1
  MOVE.l d0,0(a0,d1)
  ADDQ.w #4,d1
  CMP.w  #maxhistory*4,d1
  BLE 'nowrap
  MOVEQ #0,d1

 'nowrap
  MOVE.w d1,memhistorypointer
  MOVEM.l (a7)+,a0/d1
RTS


memhistoryup
.jump_memhistoryup
  MOVE.l a1,-(a7)
  LEA memhistory,a0
  MOVE.w memhistorypointer,d1
  SUBQ #4,d1
  BPL 'l10
  MOVEQ #maxhistory*4,d1

 'l10
  MOVE.w d1,memhistorypointer
  MOVE.l 0(a0,d1.w),d0
  PutReg d0,mempointer(1)
  RedrawMem{}
  MOVE.l (a7)+,a1
RTS


memhistorydown
.jump_memhistorydown
  MOVE.l a1,-(a7)
  LEA memhistory,a0
  MOVE.w memhistorypointer,d1
  ADDQ #4,d1
  CMP.w #maxhistory*4,d1
  BLE 'l10
  MOVEQ #0,d1

 'l10
  MOVE.w d1,memhistorypointer
  MOVE.l 0(a0,d1.w),d0
  PutReg d0,mempointer(1)

  RedrawMem{}
  MOVE.l (a7)+,a1
RTS


historyup
.jump_historyup
  MOVE.l a1,-(a7)
  LEA history,a0
  MOVE.w historypointer,d1
  SUBQ #4,d1
  BPL 'l10
  MOVEQ #maxhistory*4,d1

 'l10
  MOVE.w d1,historypointer
  MOVE.l 0(a0,d1.w),d0
  disasm_ad = PutRegD0
  UpdateDisAsm{}
  MOVE.l (a7)+,a1
RTS


historydown
.jump_historydown
  MOVE.l a1,-(a7)
  LEA history,a0
  MOVE.w historypointer,d1
  ADDQ #4,d1
  CMP.w #maxhistory*4,d1
  BLE 'l10
  MOVEQ #0,d1

 'l10
  MOVE.w d1,historypointer
  MOVE.l 0(a0,d1.w),d0
  disasm_ad=PutRegD0
  UpdateDisAsm{}
  MOVE.l (a7)+,a1
RTS

Even
.GetVariableNameAndType:   ; subroutine from code of addtrace to use it in deltrace too  tomsmart1 2016 02 14
  na$ = RTEZGetString(varfollow$,"Enter variable name:",80,part$)
  If na$ <> ""
    a$ = Left$(na$,1)
    If a$ = "%"
      nf = 3
    Else
      If a$ = "$"
        nf = 2
      Else
        nf = 1
      EndIf
    EndIf
    If nf <> 1 Then na$ = Mid$(na$,2)
    nt = -1
    If Right$(na$,1) = "$" Then nt = 4
    If Len(na$) > 2 AND Mid$(na$,Len(na$)-1,1) = "."
      nt  = Instr(objtype$,LCase$(Right$(na$,1)))  ; try to get type of the variable
      na$ = Left$(na$,Len(na$)-2)
    EndIf
    If nt = -1 Then nt = RTEZRequest(varfollow$,"Enter variable type:","_b|_w|_l|_s|_q|_f|_Cancel")
  Else
    nt = -1
  EndIf
Return


Even
memhistorypointer:  Dc.l 0
historypointer:     Dc.l 0
regpos:             Dc.l 0
fpreg:              Dc.l 0
fpuoffset:          Dc.l 0
currlinestart:      Dc.l 0
topazname           Dc.b "topaz.font",0
Even
BSS
history:            Ds.l #maxhistory+2
memhistory:         Ds.l #maxhistory+2
fpustore:           Ds.l 3*9
programstart:       Ds.l 1
programsize:        Ds.l 1
newdebug:           Dc.w 1
trap15addr:         Ds.l 1
direktbuffer:       Ds.b 4096
