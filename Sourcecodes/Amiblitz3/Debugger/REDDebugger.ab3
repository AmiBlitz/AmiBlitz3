; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Blitz3:Debug"
; ExeFile         = "REDDebugger"
; CreateIcon      = 0
; Residents       = "all.res,asmmacs.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 3.11.0
; NumberOfBuilds  = 169
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 1
; AssemblerCheck  = 1
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 60
; CursorColumn    = 1
; LabelSearch     = "optimize"
; LabelRemark     = 0
; LabelAll        = 1
; LabelCase       = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 5
; Max GadgetList  = 50
; Max Shape       = 100
; Max Bank        = 5
; Max MenuList    = 50
; Max GTList      = 50
; Max BitMap      = 10
; Max Screen      = 5
; Max IntuiFont   = 5
; Max Window      = 50
; Max Palette     = 4
; Max BlitzFont   = 4
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max TagList     = 5
; Max Database    = 16
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
; Changelog

; 2.73
; recompiled with updated (fpuless) Val()-command
;
; 2.72
; change save and readpath to Blitz3:Debug
; replaced Peek$() with Peek.s()

; 2.71
; add version check of needed Librarys
; extend OS check to check for MOS to because MOS behaves like OS3
; change Versionstring to Buildsystem

; 2.70
; add a check for OS4 to remove the programsize Bug

; 2.69
; changed: fixes a forgotten peeks()

; 2.68
; changed: replaced PeekS() with Peek.s()

; 2.67
; ??

; 2.66
; changed:  old Blitz2:-Assigns updated to Blitz3
; changed:  requester
; changed:  helpfunction uses AB3HelpViewer now


; LIBRARY CHANGES MADE TO ACIDLIBS:
;  DebugLib      - Loads of changes including extra handlers,
;                  new return values of extra TRAP checking
;                  BLITZ MODE support - special controls
;  Switchlib     - BLITZ MODE support - special controls
;  StringFuncLib - Hexb$, Hexw$, Binb$, Binw$
;  ValLib        - ValLong()
;  Gadgetslib    - New prop gadget commands / Arrow Gadgets

; EXTRA LIBS NEEDED to compile:
;  RILESDebugLib   - custom commands for the debugger
;                  (including COPPER disasm)
;  RIDisAsm      - Program disassembly
;  NeilsReqtoolsLib
;  RISortLib     - sorting names into alphabetical order

; LIBS NEEDED to use:
;  DebugLib      - MUST HAVE THIS UPDATE INSTALLED!
;  Switchlib     - MUST HAVE THIS UPDATE INSTALLED!
;  RIDebugLib    - optional but very useful

; Written by
;  different people


;***********************************************************
#USE_WIZARD          = 1     ; use wizard library?
OPTIMIZE 13 ; don't use fpu because all calc must in FFP!!!!
SYNTAX 6

XINCLUDE "error.include.ab3"
XINCLUDE "dos.include.ab3"
XINCLUDE "/Shared/common.ab3"
XINCLUDE "/Shared/ted.include.ab3"
XINCLUDE "rastport.include.ab3"
XINCLUDE "useful.include.ab3"
XINCLUDE "asl.include.ab3"

XINCLUDE "logging.include.ab3"
XINCLUDE "wizard_Tools.include.ab3"



;  systemBitMap 1
; Constants
; ATTENTION dont use variable i (it is the sourceline address)
#longs                  = 0    ; show mem in longs  (not yet)
#lowestaddr             = 1024 ; to avoid enforcer hits
#maxhistory             = 10

;Debuginfo in Code
;trap #1     structsize = 10 ($a)Bytes
;dc.l sourcelineaddr from ted
;dc.w 9
;dc.w offset to next trap #1

#test                   = 0
#BACKGROUND_DBUG        = 1

#maxheight_ever         = 2048

#save_numwindows        = 13
#wizardwindows          = 24

#IDENTIFIER             = $44425547 ; "DBUG" ; to identify the rexxmsg from defaultdebug (debugger starter)
#MAXCUSTOMCOMMANDS      = 20

#bufflen                = 4096
#buffand                = #bufflen-1

; Evaluate request types:
#_null00                = 0
#_memwindow             = 1
#_newtypewindow         = 2 ; REMOVED
#_newtypewindowmax      = 3 ; REMOVED
#_variablelocate        = 4
#_disasmaddress         = 5
#_autoevalresult        = 6
#_discopaddress         = 7
#_arrayfind             = 8
#_structaddress         = 9
#_mouseable_eval        = 10
; EXECute types:
#_viewblitz             = 50
#_newtypewindow         = 51

; Window allocation
#_winSource             = 0
#_winControl            = 1
#_winRegisters          = 2
#_winBackdrop           = 3
#_winMemory1            = 4
#_winMemory2            = 5
#_winSearch             = 6
#_winVariables          = 7
#_winDisAsm             = 8
#_winDisCop             = 9
#_winCustom             = 10
#_winArray              = 11
#_winMouseables         = 12
#_winObject0            = 13
#_winObject9            = 22
#fpuwin                 = 23

#noresize               = %10001000010   ; bits represent windows

; Windows that require the special gadget down handling
; (provides 'key repeat' type handling for gadgets)
; If not set here, a windows #IDCMP_GADGETDOWN events are ignored
#gadgetdown             = %11111111111111111110000000000000+(0 BitSet #_winSource)+(0 BitSet #_winMouseables)+(0 BitSet #_winArray)
; Gadgets
#SRC_SGAD               = 1 ; Source window
#SRC_LGAD               = 2
#SRC_RGAD               = 3
#MSE_SGAD               = 4 ; Mouseables window
#MSE_UGAD               = 5
#MSE_DGAD               = 6
#OBJ_SGAD               = 7
#OBJ_UGAD               = 8
#OBJ_DGAD               = 9
#ARR_YGAD               = 10
#ARR_XGAD               = 11
#ARR_UGAD               = 12
#ARR_DGAD               = 13
#ARR_LGAD               = 14
#ARR_RGAD               = 15

; Debug library commands:
#_addtrace              = 255
#_deltrace              = 254
#_varwindow             = 253
#_diswindow             = 252
#_copperlist            = 251
#_proccontrol           = 250
#_memwindowmove         = 249

; Variable types
#_byte                  = 1
#_word                  = 2
#_long                  = 3
#_string                = 4
#_quick                 = 5
#_float                 = 6

#SCR_WB                 = 0
#SCR_LIKEWB             = 1
#SCR_CUSTOM             = 2
#SCR_DEFPUB             = 3
#SCR_NAMEDPUB           = 4

; Max breakpoints
#maxbreakpoints         = 5

; Breakpoint types
#break_permanent        = 1
#break_count            = 2
#break_simple           = 3
#break_countdown        = 4

; Windows that cannot be opened from loadPrefs in openwindows
#winprotect             = %100000001010

#RUNNING                = 0
#TRACE                  = 1
#STOPPED                = 2
#BLITZMODE              = 3

#NOSIGNAL               = 0
#SIGNAL                 = 1

#AUTOKNOB               = $0001 ; this flag sez:  gimme that old auto-knob
#FREEHORIZ              = $0002 ; if set, the knob can move horizontally
#FREEVERT               = $0004 ; if set, the knob can move vertically
#PROPBORDERLESS         = $0008 ; if set, no border will be rendered
#KNOBHIT                = $0100 ; set when this Knob is hit
#PROPNEWLOOK            = $0010 ; set this if you want to get the new
                                ; V36 look
#GFLG_RELBOTTOM         = $0008 ; set if rel to bottom, clear if to top
#GFLG_RELRIGHT          = $0010 ; set if rel to right, clear if to left

; set the GFLG_RELWIDTH bit to spec that Width is relative to width of screen
#GFLG_RELWIDTH          = $0020

; set the GFLG_RELHEIGHT bit to spec that Height is rel to height of screen
#GFLG_RELHEIGHT         = $0040

#RIGHTREL               = %1
#BOTTOMREL              = %10
#RIGHTBORDER            = %100
#BOTTOMBORDER           = %1000

#VPROP_AFLAGS           = #GFLG_RELRIGHT|#GFLG_RELHEIGHT
#VPROP_PFLAGS           = #AUTOKNOB|#FREEVERT|#PROPBORDERLESS|#PROPNEWLOOK
#HPROP_AFLAGS           = #GFLG_RELBOTTOM|#GFLG_RELWIDTH
#HPROP_PFLAGS           = #AUTOKNOB|#FREEHORIZ|#PROPBORDERLESS|#PROPNEWLOOK

; OS Version to enable/disable various features
#AmigaOS3 = 1
#AmigaOS4 = 2
#MorphOS  = 3
#AROS     = 4


; -- OPCODES
#opcode_TRAP1 = $4e41
#opcode_NOP   = $4e71
#opcode_RTS   = $4e75
#opcode_JSR   = $4EB9
#opcode_JMP   = $4EF9

; -- Keycodes
; Raw
#RAWKEY_E          = $12
#RAWKEY_R          = $13
#RAWKEY_T          = $14
#RAWKEY_I          = $17
#RAWKEY_P          = $19
#RAWKEY_S          = $21
#RAWKEY_D          = $22
#RAWKEY_F          = $23
#RAWKEY_L          = $28
#RAWKEY_X          = $32
#RAWKEY_V          = $34
#RAWKEY_B          = $35
#RAWKEY_M          = $37
#RAWKEY_SMALLER    = $38
#RAWKEY_GREATER    = $39
#RAWKEY_SPACE      = $40
#RAWKEY_TAB        = $42
#RAWKEY_RETURN     = $44
#RAWKEY_ESC        = $45
#RAWKEY_UP         = $4C
#RAWKEY_DOWN       = $4D
#RAWKEY_RIGHT      = $4E
#RAWKEY_LEFT       = $4F
#RAWKEY_F1         = $50
#RAWKEY_F10        = $59
#RAWKEY_HELP       = $5F

; Vanilla
#VANILLAKEY_BACKSPACE = $08
#VANILLAKEY_TAB    = $09
#VANILLAKEY_RETURN = $0D
#VANILLAKEY_ESC    = $1B
#VANILLAKEY_UP     = $1C
#VANILLAKEY_DOWN   = $1D
#VANILLAKEY_RIGHT  = $1E
#VANILLAKEY_LEFT   = $1F
#VANILLAKEY_DELETE = $7F
#VANILLAKEY_F1     = $81
#VANILLAKEY_F2     = $82
#VANILLAKEY_F3     = $83
#VANILLAKEY_F4     = $84
#VANILLAKEY_F5     = $85
#VANILLAKEY_F6     = $86
#VANILLAKEY_F7     = $87
#VANILLAKEY_F8     = $88
#VANILLAKEY_F9     = $89
#VANILLAKEY_F10    = $8A
#VANILLAKEY_HELP   = $8B


;***********************************************************
; Newtypes

;-- The *PC entry points to another 'info' block:
NEWTYPE.pcinfo
  *sourceLine.sourceLine   ;pointer to start of source code line
  lineOffset.w             ;pointer to offset in source line of current statement.
  skipOffset.w             ;offset to next statement (so we can skip this one if we want!)
End NEWTYPE
DEFTYPE.pcinfo *pcInfo

;-- STATEHANDLER - called before the execution of every line of program
;-- code, except for stuff in supervisor mode (ie: interupts).
;-- This routine is only allowed to play with A0 and A1 (to keep things fast).
;-- On entry, A0 contains a pointer to an 'info' block:
NEWTYPE.statehandlerinfo
  DRegs.l[8]          ; contents of data registers D0...D7
  ARegs.l[8]          ; contents of address registers A0...A7
  *pc.pcinfo          ; program counter
  conditionCodes.w    ; condition codes
End NEWTYPE

NEWTYPE.variabletype
  address.l ; address of variable
  typ.b     ; type = 1-7, byte,word,long,quick,float,,string
  form.b    ; 0 = dec, 1 = hex, 2 = binary
  name.s    ; name of variable
End NEWTYPE

#DEVENT_SUPERVISORERROR = 0
#DEVENT_USERERROR = 1
#DEVENT_EVALRESULT = 2
#DEVENT_TRACELINE = 3
#DEVENT_END = 4
NEWTYPE.d_event ; a debug event!
  t.w           ; type...0 = supervisor error
                ;        1 = user error
                ;        2 = eval result
                ;        3 = trace this line...
                ;        4 = end
                ;
  i.w           ; buffer put val!
  s$            ; string
End NEWTYPE


NEWTYPE .prefstype
  fontname.s
  fontsize.l
End NEWTYPE


NEWTYPE.wininfotype
  x.w
  y.w
  w.w
  h.w
  flags.l
  title.s
  gadlist.w
  helplink.l
End NEWTYPE

NEWTYPE.structurewindow
  objadr.l      ; Object type definition address
  objbaseadr.l  ; BASE address for object, e.g. addr object(0)
  typepointer.l ; Address of object
  mem_type.l    ; Pointer to block of mem holding type information

  type_sizeof   ; Sizeof.type
  winnum.b      ; Allocated window for object
  numitems.b
  is_bbobject.w ; Is this a Blitz object type?
  tracenum.w    ; Currently traced number
  maxobject.w   ; Maximum object number
  typewidth.w   ; Max width of \type text
  t$            ; Name of type
End NEWTYPE


;***********************************************************
; Variable type declarations
DEFTYPE.b dowin,objectbusy,pmode,pmodevalid,end_init
DEFTYPE.b evalrequest,execrequest,autoeval
DEFTYPE.b kbshift,nt,nf,flag,editflag
DEFTYPE.b mflag,winnum,searchtype
DEFTYPE.w exitflag
DEFTYPE.w reply,num,tracenum,xadm,pfregs
DEFTYPE.w wx,wy,a,mytype,jump,mylen
DEFTYPE.w Ascii,mysr,old_dstatus
DEFTYPE.w xarraynum,yarraynum,arraytype,xarrayoff,yarrayoff
DEFTYPE.w arraydatasize,arraylabelsize,arrayitemsize
DEFTYPE.w bp,evalrequestex,num_mouseables,mouseables_off
DEFTYPE.w old_active_win,active_win,n
DEFTYPE.w signal
DEFTYPE.l disasm_ad,typepointer,maxobject,ad,si,areg,old_ad,ad1,ad2
DEFTYPE.l ev,evq,evw,mem,dreg
DEFTYPE.l array1,array2,stepnumber,breakpoint_adr
DEFTYPE.l mouseables,rp,exetask,signalset
DEFTYPE.l *ComData_Pointer
DEFTYPE.l
DEFTYPE.q mq
DEFTYPE.f mf,ffp

DEFTYPE.tokendata *tokenbase
DEFTYPE.l address,address2,memadr
DEFTYPE.w winheight,ox,oy,ow,typelength,typewidth

.@begin
; set of the Version and Revison in the internal data
Poke.b ?initstate  ,Vallong("\\__VER_MAJOR")
Poke.b ?initstate+1,Vallong("\\__VER_MINOR")

prefs.prefstype\fontname = ""; use system default "topaz.font",8
prefs.prefstype\fontsize = 0 ; use system default "topaz.font",8
stepnumber               = 1
searchtype               = 1
dowin                    = -1
pmodevalid               = 0
prefsSize.l             = Peek.w(?sizeofPrefs)
array$                   = ""


NEWTYPE.redData
  osType.l
  logging.l
  checkVbr.b
  arexxPort.l

  defaultPubScreen.b
  usePubScreen.b
  pubscreenName.s
  screenType.w
  screenModeId.l
  screenWidth.w
  screenHeight.w

  windowMaxHeight.w

  *scr.Screen
  ScreenBarHeight.l
  ScreenFontNameStr.s
  ScreenFontYSize.l
  WinBorTop.l
  WinBorTextTop.l
  WinBorLeft.l
  WinBorRight.l
  WinBorBottom.l
  WinSizeBorRight.l
  WinSizeBorBottom.l

  syntaxTextY.w
  statusTextY.w

  appTitle.s
  appPath.s
  *appDiscObject.DiskObject_
  ab3Path.s

  tokenize.b
  asmStep.b
  watch0.b          ; this check the NULL pointer, works only on OS3 wihtout enforcer
  showSyntaxHelp.b
  showLineNumbers.b
  procStatus.b
  blitzControl.b
  gosubStatus.b
End NEWTYPE
DEFTYPE.redData redData

NEWTYPE.sourceWindow
  *win.Window
  ;-- source window data
  boxLeft.w
  boxTop.w
  boxWidth.w
  boxHeight.w
  lineNumberDigits.b


  ;buffer data
  bufferMem.l
  inBackBuffer.b
  currentBufferIndex.w
  backBufferIndex.w

  startCode.l

  *lastCurrentLine.sourceLine
  *currentLine.sourceLine
  ;*firstSourceLine.sourceLine
  ;*lastPrintedLine.sourceLine

  visibleColumns.w
  visibleLines.w
  charOffset.w

  lineOffset.l
  displayLine.l
  totalLines.l
End NEWTYPE
DEFTYPE.sourceWindow sourceWindow


NEWTYPE.rexxData      ; rexxdata for background mode
  winy.w
  winx.w
  portname.s
  *port.MsgPort
  *Msg.IntuiMessage
  signal.l
End NEWTYPE

NEWTYPE.redMessage
  _Class.l
  _Code.w
  _Qualifier.w
  _IAddress.l
  _MouseX.w
  _MouseY.w
  _Seconds.l
  _Micros.l

  _WindowID.l
  *_Gadget.Gadget
  _GadgetID.l
End NEWTYPE

DEFTYPE.redMessage redMessage

;proz.l = Processor                                     ; needed for fpu register pos
;If proz = 3 OR proz = 2 Then MOVE.l #-200   ,fpuoffset ; 020/030
;If proz = 4 Then MOVE.l #-200+24,fpuoffset             ; 040
;If proz = 5 Then MOVE.l #-200+18,fpuoffset             ; 060

fpuproz.l = ProcessorFPU                                ; 0=none, 1=68881, 2=68882, 3=68040, 4=68060"
Select fpuproz
Case 1 : MOVE.l #-200   ,fpuoffset ; 020/030
Case 2 : MOVE.l #-200   ,fpuoffset ; 020/030
Case 3 : MOVE.l #-200+24,fpuoffset ; 040
Case 4 : MOVE.l #-200+18,fpuoffset ; 040
End Select


;***********************************************************
; Arrays and lists

Dim List varinfo.variabletype(19)
Dim List d_e.d_event(50)
Dim List objwins.structurewindow(9)

Dim wininfo.wininfotype(Maximum Window)
Dim memwin.w(1),mempointer.l(1),memlock$(1),memlockpf$(1)
Dim winstatus.w(Maximum Window)
Dim customcomm$(#MAXCUSTOMCOMMANDS)
Dim textBuffer.s(200)
Dim disStr.s(200)
Dim memStr.s(200)
Dim fpuRegValues$(8)

mempointer(0)  = 0
mempointer(1)  = 0
objtype$       = "bwlsqf"  ;this is for the type check to trace variables
old_active_win = -1
active_win     = -1
breakpoint_adr = ?breakpoint
breakstore.l   = ?breakstore

;***********************************************************
; Some strings......

typetitle$     = ""
warn1$         = "REDDebugger is attempting to close its screen.\\nPlease close all visitor windows."
srStr.s        = String$(Chr$(0),5) ; needed for Outtext and D_GetSR in RedrawRegs{}       ; important must be pre filled (Spaces) in the needed size for D_CheckNMoveA else it produce Hits
regaStr.s      = String$(" ",30+16) ; needed for Outtext and D_CheckNMoveA in RedrawRegs{} ; important must be pre filled (Spaces) in the needed size for D_CheckNMoveA else it produce Hits
regdStr.s      = String$(" ",4)     ; needed for Outtext and D_CheckNMoveA in RedrawRegs{} ; important must be pre filled (Spaces) in the needed size for D_CheckNMoveA else it produce Hits ; rename it to match for Registers D
aststructure$  = ""
redData\appTitle = "RED Debugger \\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH"
varfollow$     = "Variable trace"
cntrlwin$      = "Program mode:       "                    ; 6 spaces in string for mode!

MaxLen autoeval$   = 80
MaxLen strg$       = 128
MaxLen ex$         = 128
MaxLen eval$         = 128
MaxLen evalbuffer$ = 256

; -- Statement to log text into PEDs log
Statement log2PED{message.s}
SHARED redData

  If NOT redData\logging Then Statement Return

  !ComData_LEA{comFunc_LogPrint,D0} : tmpD0.l = PutRegD0
  If Peek.l(tmpD0) <> 0
    message = "\\1B[42mRED " + message + "\\1B[40m"
    tmpL.l = 0 : tmpW.w = 0
    GetReg A1,&message  ; logtext
    GetReg D0,tmpW      ; logvalue0: libnumber
    GetReg D1,tmpL      ; include file name
    GetReg D2,tmpL      ; logvalue1: code line num
    GetReg D3,tmpL      ; pointer source line
    GetReg D4,tmpL      ; pointer to source text of current line

    !ComData_JSR{comFunc_LogPrint}
  ;Else
  ;  error{"Log-function of PED not available for output: \\n" + message}
  EndIf
End Statement

Macro log2PED_HexDump
    For imh.l = 0 To `2 Step 8
      memaddr.l = `1 + imh
      memdata.l = Peek.l(memaddr)
      memdata2.l= Peek.l(memaddr+4)

      logtxt$ = Hex$(memaddr-`1)+" ("+LSet$(Str$(imh),4)+") # "
      logtxt$ + Hex$(memaddr)+": "+ Hex$(memdata)+" "+Hex$(memdata2)+"  " + CharStream{Peeks$(memaddr,8)}+" "
      logtxt$ + Str$(memdata) + "  " + Str$(memdata2)
      log2PED{logtxt$}
   Next
End Macro




; =========================================================================================================================
.StartOfDayInit:
; =========================================================================================================================
WBStartup

; -- setup wizard GUI
WZLoadGUI ?wzgui
AddIDCMP #IDCMP_MENUHELP|#IDCMP_GADGETHELP

;--- OS Check for set ASM window to prevend a Crash on OS4
redData\osType = #AmigaOS3
If (dos_CheckLib{"exec.library",50} ) Then redData\osType = #AmigaOS4
If (FindResident_("MorphOS") ) Then redData\osType = #MorphOS
;-----

CNIF #test = 0
  If (Maximum Window) < 25 OR (Maximum GadgetList) < 25
    error{"Object Maximums too small\\nIncrease Window and Gadgetlist Objectsize >25"}
    End
  EndIf
CEND
redData\appPath = dos_GetProgDir{dos_AddPart{default_assign,"Debug"} }
redData\ab3Path = default_assign

;-- try to get border sizes and system font
If Used Screen < 0 Then WbToScreen 0
*wbscreen.Screen = Peek.l(Addr Screen(Used Screen))
If *wbscreen <> 0
  redData\ScreenBarHeight   = *wbscreen\BarHeight + 1
  redData\ScreenFontNameStr = Peek.s(*wbscreen\Font\ta_Name)
  redData\ScreenFontYSize   = *wbscreen\Font\ta_YSize
  redData\WinBorTop         = *wbscreen\WBorTop
  redData\WinBorTextTop     = redData\WinBorTop + redData\ScreenFontYSize + 1
  redData\WinBorLeft        = *wbscreen\WBorLeft
  redData\WinBorRight       = *wbscreen\WBorRight
  redData\WinBorBottom      = *wbscreen\WBorBottom

  ;-- try to get real size of the sizegadget
  *drawinfo.DrawInfo = GetScreenDrawInfo_(*wbscreen)
  If *drawinfo
    If (*wbscreen\Flags & #SCREENHIRES)
      sis.l = #SYSISIZE_HIRES
    Else
      sis   = #SYSISIZE_MEDRES
    EndIf
    *img.Image = NewObjectA_(0,"sysiclass",Tags(#SYSIA_DrawInfo,*drawinfo, @@
                                                #SYSIA_Which,#SIZEIMAGE, @@
                                                #SYSIA_Size,sis, @@
                                                #TAG_DONE,0))
    If *img
      redData\WinSizeBorRight  = *img\Width
      redData\WinSizeBorBottom = *img\Height
      DisposeObject_ *img
    EndIf
    FreeScreenDrawInfo_ *wbscreen,*drawinfo
  EndIf

EndIf

If FindPort_("REXX")
  redData\arexxPort = RXCreatePort("DEBUGGER.PRIVATE")
Else
  redData\arexxPort = 0
EndIf



CNIF #BACKGROUND_DBUG
  .BACKGROUND:
  ; Right, we need some global variables...
  ; -  msgport.l      is the address of Debugger's message port
  ; -  msgportname$   is the name of Debugger's message port
  DEFTYPE.rexxData rexxData

  rexxData\winy    = redData\ScreenBarHeight
  rexxData\winx    = 0
  rexxData\portname= "REDDebugger"
  rexxData\signal  = $10000000

  Statement CreateDebuggerPort{}
  SHARED rexxData

    rexxData\port = CreateMsgPort_
    If rexxData\port
      rexxData\port\mp_Node\ln_Name = &rexxData\portname
      AddPort_ rexxData\port
    EndIf

  End Statement

  Statement ReplyDebuggerMsg{}
  SHARED rexxData

    If rexxData\Msg
      If rexxData\port
        ReplyMsg_ rexxData\Msg
        rexxData\Msg = 0
      EndIf
    EndIf

  End Statement


  Statement DeleteDebuggerPort{}
  SHARED rexxData

    If rexxData\port <> 0
      RemPort_ rexxData\port
      DeleteMsgPort_ rexxData\port
    EndIf

  End Statement

  ; =============================================================== start code for #BACKGROUND_DBUG
  If FindPort_(rexxData\portname)
    error{"The debugger is already running!"}
    End
  EndIf

  CreateDebuggerPort{}
  AddWaitEvent PortSigBit(rexxData\port),rexxData\signal ; add port to WaitEvent

  background_redo.w = 1
  Repeat
    If background_redo
      log2PED{"recreating listening window ..."}
      *scr._Screen = GetPubScreen(0,"Workbench")
      textlen.w    = TextLength_(*scr\_RastPort,redData\appTitle,FLen(redData\appTitle)) + 64
      Window 0, rexxData\winx, rexxData\winy,textlen,redData\WinBorTextTop,$21000e,redData\appTitle,-1,-1 ; rexxportname$,-1,-1
      background_redo = 0
    EndIf

    ev = WaitEvent

    If ev = rexxData\signal
      log2PED{"received rexx signal ..."}
      rexxData\winx = WindowX
      rexxData\winy = WindowY

      ;DetachGTList 0 ; <= I am not sure if we want this, there is no GTList at all in the entire REDDebugger! (Thilo)

      Free Screen 0 : ReleasePubScreen 0,"Workbench"

      rexxData\Msg = 1        ; hack to enter loop
      While rexxData\Msg <> 0
        rexxData\Msg = GetMsg_(rexxData\port)
        If rexxData\Msg
          userdata.l = rexxData\Msg\Class
          identifier.l = rexxData\Msg\Code LSL 16 + rexxData\Msg\Qualifier
          ;log2PED{"Identifier:" + Hex$(identifier)}
          If identifier = #IDENTIFIER   ; get ID "DBUG" to check msg comes from debugger starter
            GetReg a0, userdata.l      ; userdata of defaultdbug, stored in IntuiMessage\Class
            MOVE.l a0, d_table
            MOVE.l a5, d_a5
            MaxLen d_d$ = 256 : MaxLen d_ev$ = 256 : MaxLen d_ex$ = 256
            Poke.l ?d_dadd,&d_d$
            statego.w = 0 : dstatus.w = 0 : prtcode.w = 0 : Poke.l ?statego_,&statego
            sourceWindow\bufferMem = AllocMem_(#bufflen,$10001) : Poke.l ?buffmem_,sourceWindow\bufferMem : CLR bufferput
            ArrayFill winstatus(),0
            ReplyDebuggerMsg{}
            ;
            Gosub mainstart
            ;
            ArrayFill memwin(),0
            ArrayFill mempointer(),0
            ClearList varinfo()
            ClearList d_e()
            ClearList objwins()
            ali.l = 0 : lt$ = "" : exetask = 0 : autoeval = 0 : autoeval$ = ""
            pfregs = 0
            !ComData_SetB{comByte_RunningFlag,#0}
          EndIf
        Else
          ReplyDebuggerMsg{}
        EndIf
      Wend

      background_redo = 2
    EndIf
  Until ev = #IDCMP_CLOSEWINDOW
  DeleteDebuggerPort{}

CELSE   ;#BACKGROUND_DBUG
  MOVE.l 4,a0 : MOVE.l 276(a0),a0 : MOVE.l 88(a0),d_table  ; get jumptable out of tasks userdata
  MOVE.l a5,d_a5
  MaxLen d_d$ = 256 : MaxLen d_ev$ = 256 : MaxLen d_ex$ = 256
  Poke.l ?d_dadd,&d_d$
  statego.w = 0 : dstatus.w = 0 : prtcode.w = 0 : Poke.l ?statego_,&statego
  sourceWindow\bufferMem = AllocMem_(#bufflen,$10001) : Poke.l ?buffmem_,sourceWindow\bufferMem : CLR bufferput
  ;
  Gosub mainstart
  ;
CEND   ;#BACKGROUND_DBUG

; =======================================================================================================================================
ted_CloseLib{}
End
; =======================================================================================================================================

Macro debuglib_Call
  ; jumptable - d_table - to call functions in debuglib
  ; 0 newmode
  ; 1 stop
  ; 2 sethandler
  ; 3 detoke
  ; 4 evaluate
  ; 5 execute
  ; 6 quit
  ; 7 findoff
  ; 8 skip

  MOVE.l d_table,a2
  MOVE.l `1 LSL 2(a2),a2
  JSR (a2)
End Macro


Statement d_sethandler{adr.l}
SHARED *tokenbase,exetask,signal,signalset,vbr_temp.l,*TokenBase_Pointer.l

  LEA htable(pc),a0 : !debuglib_Call{2}
  MOVE.l a0,mybuffer
  MOVE.l a1,progmode
  PutReg a2,*tokenbase                         ; is empty? debuglib does not send it ?
  PutReg a3,exetask ; blitz program process
  PutReg d0,signal
  signalset = (0 BitSet signal)

  If *TokenBase_Pointer <> 0                   ; test if we had a vailed comdata_tokenbase pointer
    *tokenbase = *TokenBase_Pointer            ; yes then we use it insteed of the debuglib one
  EndIf

  vbr_temp.l = VBRcheck
  MOVE.l d0,a0
  MOVE.l vbr_temp@(A5),a0
  MOVE.l trap15addr,$bc(a0)

End Statement

Function$ d_detoke{sa.l}
SHARED d_d$

  GetReg a0,sa : GetReg a1,&d_d$
  !debuglib_Call{3}
  Function Return d_d$
End Function


Function.l getStartCode{ad.l}
SHARED sourceWindow

  ; if there are includes in the source, we need a indicator that points to the entry point of the source
  ; the compiler adds "DuckAmiB" at this point
  ;
  If sourceWindow\startCode = 0                 
    GetRegD0 ad : MOVE.l d0,a0          
    MOVE.l #"DuCk",d1
    MOVE.l #"AmiB",d2
    MOVE.l #10 000 000,d0

    _adloop:
      ADDQ.l #1,a0
      CMP.l (a0),d1 : BEQ _adloop1
        SUBQ.l #1,d0 : BNE _adloop
        BRA _adloop3
      _adloop1:
      CMP.l 4(a0),d2
    BNE _adloop

    MOVE.l a0,d0 : sourceWindow\startCode = PutRegD0
    sourceWindow\startCode = Peek.l(sourceWindow\startCode + 8)
    
    _adloop3:
  EndIf

  Function Return sourceWindow\startCode
End Function


Function.l getad{ad.l}
  If (ad = 0) Then error{"\\__THIS_FUNCTION: Null pointer exception!"} : Function Return 0

  peekad.l = Peek.l(ad)
  If peekad AND $80000000   ; address is an offset
    peekad = peekad AND $7fffffff
    peekad = peekad + getStartCode{ad}
  EndIf

  Function Return peekad
End Function


Function.l getad2{ad.l}
  If (ad = 0) Then error{"\\__THIS_FUNCTION: Null pointer exception!"} : Function Return 0

  peekad.l = Peek.l(ad)
  If peekad AND $80000000   ; address is an offset
    peekad = peekad AND $7fffffff
    peekad = peekad + getStartCode{ad}
    Function Return peekad
  Else
    Function Return ad
  EndIf
End Function


Statement d_eval{t$, dosignal.w}
SHARED d_ev$, stepcnt, exetask, signalset, dstatus

  CNIF #test = 0
    log2PED{"calling d_eval: " + t$}
    d_ev$ = t$ : GetReg a0,&d_ev$ : !debuglib_Call{4}

    If exetask
      If dosignal = #SIGNAL
        If dstatus = #STOPPED
          stepcnt + 1
          ;error{"Before signal!"}
          Signal_ exetask,signalset
          ;error{"After signal!"}
        EndIf
      EndIf
    Else
      error{"Task = 0"}
    EndIf
  CELSE
    EZRequest "ILLEGAL TEST MODE d_eval{} CALL"
  CEND
End Statement


Statement d_exec{t$}
SHARED d_ex$,stepcnt,exetask,signalset,dstatus

  CNIF #test = 0
    d_ex$=t$ : GetReg a0,&d_ex$ : !debuglib_Call{5}
    If dstatus = #STOPPED
      stepcnt+1
      Signal_ exetask,signalset
    EndIf
  CELSE
    EZRequest "ILLEGAL TEST MODE d_exec{} CALL"
  CEND
End Statement


Statement d_quit{}
SHARED stepcnt,exetask,signalset,dstatus

  If dstatus <> #STOPPED
    !debuglib_Call{1}
    stepcnt = 0
    Delay_ 2
  EndIf
  ; quit the debugger
  !debuglib_Call{6}
  stepcnt+1
  Signal_ exetask,signalset
End Statement


Statement d_skip{}

  !debuglib_Call{8}
End Statement


Macro d_basic
  MOVE.l d_a5(pc),a5
End Macro


Statement add_event{t.l, s$}
SHARED d_e()
  Forbid_
  If AddLast(d_e())
    d_e()\t = t
    ; copy data to event object and remove it from buffer
    MOVE.w bufferput(pc),d0 : SUBQ.w #4,d0 : AND.w #buffand,d0 : PutReg d0,d_e()\i
    d_e()\s = s$
  EndIf
  Permit_
End Statement


progversion:    ; version info for cli version command
  Dc.b "$VER: REDDebugger \\__VER_MAJOR.\\__VER_MINOR.\\__VER_PATCH Build \\__VER_BUILD [\\__DATE_GER__]",0
Even


varhandler:     Dc.l 0 ; Message waiting for debugger
mybuffer:       Dc.l 0 ; Pointer to registers!
progmode:       Dc.l 0 ; Pointer to word that hold program mode
                       ; < 0 = blitz, 0 = amiga, >0 = qamiga
d_dadd:         Dc.l 0
d_table:        Dc.l 0
d_a5:           Dc.l 0
statego_:       Dc.l 0
buffmem_:       Dc.l 0
bufferput:      Dc.w 0

htable: ; handler table
 Dc.l d_statehandler   ,d_superhandler,d_userhandler
 Dc.l d_waithandler    ,d_evalhandler ,d_cleanup
 Dc.l d_vartracehandler,d_prochandler

._D_Handlers:
d_statehandler: ; A0 points to statehandlerinfoblock
                ; copy the pcinfo pointer into buffer
  MOVE.l buffmem_(pc),a1 : ADD bufferput(pc),a1 : MOVE.l 64(a0),(a1)
  ADDQ #4,bufferput : ANDI #buffand,bufferput

  MOVE.l    (a1),a0
  LEA       breakpoint(pc),a1

 'check:
  TST.l     (a1)
  !SBEQ     {'skipit}
  CMP.l     (a1),a0
  !SBEQ     {'ok}
  ADDQ.l    #8,a1
  !SBRA     {'check}

 'skipit:
  MOVE.l    statego_(pc),a1
  TST       (a1)
 RTS

 'ok:
  CMPI.w    #break_simple,4(a1)
  !SBNE     {'noclear}
  SUB.w     #1,6(a1) ; Got simple breakpoint
  !SBEQ     {'clear_em}
  !SBRA     {'skipit}

 'noclear:
  CMPI.w    #break_permanent,4(a1)
  BEQ       '_return
  ADD.w     #1,6(a1)
  !SBRA     {'skipit}

; move all following breakpoints down
 'clear_em
  TST.l     (a1)
  !SBEQ     {'_return}
  ADDQ.l    #8,a1
  MOVE.l    (a1),-8(a1)
  MOVE.l    4(a1),-4(a1)
  !SBRA     {'clear_em}

 '_return:
  MOVE.l    a5,-(a7)
  !d_basic
  Gosub     stopit
  MOVE.l    (a7)+,a5
  ST        donebreakpoint
  MOVE.l    statego_(pc),a1
  TST       (a1)
RTS


donebreakpoint: Dc.w 0

breakpoint:     Dc.l 0,0 ; 0
                Dc.l 0,0 ; 1
                Dc.l 0,0 ; 2
                Dc.l 0,0 ; 3
                Dc.l 0,0 ; 4
                Dc.l 0,0 ; [reserved]
                Dc.l 0,0

breakstore:     Dc.w 0
                Dc.w 0
                Dc.w 0
                Dc.w 0
                Dc.w 0
                Dc.w 0
                Dc.w 0

d_superhandler:
  MOVE.l a7,regpos
  !d_basic : PutReg a0,sa.l
  Gosub stopit : add_event{#DEVENT_SUPERVISORERROR,Peek.s(sa)}
Return


d_userhandler:
  !d_basic : PutReg a0,sa
  Gosub stopit : add_event{#DEVENT_USERERROR,Peek.s(sa)}
Return


d_waithandler:
  !d_basic
  TST.b   noredraw
  !SBNE   {label}
  If prtcode ; print code out?
    prtbusy.l = -1
    add_event{#DEVENT_TRACELINE,""} ; print me out!
    Wait_ signalset
    While prtbusy : Delay_ 1 : Wend ; vwait wait till printed!
  EndIf

 label:
  MOVE.l a7,regpos
  If pfregs = 0 Then PFRegisters Peek.l(MyBufferAddress.l) : pfregs = -1
  SF noredraw
  If dstatus = #STOPPED ; stopped?
    If stepcnt = 0 Then Wait_ signalset ; wait blitz dbug prg process
    stepcnt-1
  EndIf
  If (dstatus = #TRACE OR dstatus = #STOPPED) AND redData\blitzControl
    MOVEQ #-1,d0
  Else
    If dstatus = #BLITZMODE Then dstatus = #STOPPED : BCHG #1,$bfe001
    MOVEQ #0,d0
  EndIf
Return


noredraw:   Dc.w  0


d_evalhandler:
  !d_basic : PutReg a0,sa
  add_event{#DEVENT_EVALRESULT,Peek.s(sa)}
  ST    noredraw
Return


d_cleanup:
  !d_basic : add_event{#DEVENT_END,""}
Return


d_vartracehandler:
  MOVEM.l d0-d7/a0-a6,-(a7)
  'loop1 : TST.l varhandler : !SBNE {'loop1}
  MOVE.l  a0,varhandler
  'loop2 : TST.l varhandler : !SBNE {'loop2}
  MOVEM.l (a7)+,d0-d7/a0-a6
RTS


;d0 = 0 for start of procedure
;d1 = -1 for end of procedure
; Controlled by variable procstatus (not called by debuglib.obj
; unless procstatus is non-zero).
d_prochandler:
  TST.b   d1
  BNE     'setstop

 'setgo:
  ADD.w   #1,proccount
  CMPI.w  #1,proccount ; First procedure?
  !SBNE   {'exitthis}

  MOVE.l  statego_(pc),a1 : TST (a1)
  !SBEQ   {'running}
  MOVE.w  #0,stopstate
  !d_basic
  old_dstatus = dstatus
  prtcode = 0 : dstatus = 0 : statego = 0

 'exitthis
 RTS

 'setstop
  TST.w   proccount
  !SBEQ   {'exitthis}

  SUB.w   #1,proccount
  TST.w   proccount   ; Last procedure?
  !SBNE   {'exitthis} ; Nope - continue running

  TST.w   stopstate   ; Was original state running?
  !SBNE   {'exitthis} ; Nope - continue running then
;  MOVE.l  d0,procreturnval
  !d_basic
  prtcode = -1 : stepcnt = 0 : dstatus = old_dstatus : statego = -1
 RTS

 'running:
  MOVE.w  #-1,stopstate
RTS


proccount:      Dc.w 0
stopstate:      Dc.w 0
procreturnval:  Dc.l 0


; ad2 = instruction pointer
; returns d_d$ instruction string
GETInstruction:
  GetReg a0,Peek.l(ad2)+9
  MOVE.l d_dadd(pc),a1 : !debuglib_Call{3} : SUB.l d_dadd(pc),a1 : SUBQ #1,a1
  MOVE.l d_dadd(pc),a0 : MOVE.l a1,-(a0)
Return


;*****************************************************************
.Statements:

;-- Open a new window, based on the wininfo() array
Statement NewWindow{winNumber.w}
 SHARED redData, sourceWindow, prefs
 SHARED wininfo(),winstatus(),end_init
 SHARED old_active_win,active_win

  log2PED{"NewWindow " + Str$(winNumber)}

  winstatus(winNumber) = 0

  If (redData\osType = #AmigaOS4 OR redData\osType = #MorphOS)
    If (winNumber = #_winMemory1) OR (winNumber = #_winMemory2) OR (winNumber = #_winDisCop) OR (winNumber = #_winCustom) OR (winNumber = #_winSearch)
       error{"This feature/window is disabled on AmigaOS4/MorphOS.\\nHint: Save preferences if this pops up on startup."}
       Statement Return
     EndIf
  EndIf

  If winNumber = #_winMouseables
    If ask{"This feature is currently broken.\\nDo you want to open the window anyway?","Yes, please.|Ooops!"}=0
      Statement Return
    EndIf
  EndIf

  If winNumber = #_winMemory1 OR winNumber = #_winMemory2
    typ.w = 1
    Poke.l ?__more+4,?__memwin
  Else
    Poke.l ?__more+4,?__norm
    Poke.l ?__tl_mh+4,redData\windowMaxHeight
  EndIf
  x.w = wininfo(winNumber)\x
  y.w = wininfo(winNumber)\y
  w.w = wininfo(winNumber)\w
  h.w = wininfo(winNumber)\h

  winFlags.l = wininfo(winNumber)\flags

  If winNumber = #_winRegisters      ; test for Register window and set the max height of the window to 9 text lines    
    maxRegHeight.w = prefs\fontsize * 9 + redData\WinBorTextTop + redData\WinSizeBorBottom +1   ; max height for register window
    Poke.l ?__tl_mh+4,maxRegHeight
    If h > maxRegHeight
      h = maxRegHeight
      wininfo(winNumber)\h = maxRegHeight
    EndIf
  EndIf

  If end_init
    winFlags + #WFLG_ACTIVATE
    old_active_win = active_win
    active_win = winNumber
  EndIf

  ;If (#noresize BitTst winNumber) = 0 AND typ = 0
    ;If x+w > redData\scr\Width Then w = redData\scr\Width - x
    ;If y+h > redData\scr\Height Then h = redData\scr\Height - y
  ;Else
    ;If x+w > redData\scr\Width Then x = redData\scr\Width - w
    ;If y+h > redData\scr\Height Then y = sy.l - h
  ;EndIf
  Poke.l ?__gimmi+4,0

  AddIDCMP #IDCMP_MOUSEMOVE
  If winNumber = #_winSource
    AddIDCMP #IDCMP_MOUSEMOVE|#IDCMP_IDCMPUPDATE
    winFlags = winFlags OR #WFLG_REPORTMOUSE
    ;Poke.l ?__gimmi+4,1
  EndIf

  winFlags = winFlags OR #WFLG_REPORTMOUSE
  Poke.l ?__tl_scr+4,&redData\appTitle
  Poke.l ?__tl_w + 4,w
  Poke.l ?__tl_h + 4,h
  Poke.l ?__tl_l + 4,x
  Poke.l ?__tl_t + 4,y

  Poke.l ?__tl_g + 4,0

  If wininfo(winNumber)\gadlist <> -1
    Poke.l ?__tl_g + 4,Peek.l(Addr GadgetList(wininfo(winNumber)\gadlist))
  EndIf

  log2PED{Str$(x)+ ", " + Str$(y)+ ", " + Str$(w) + ", " + Str$(h)+ ", " + wininfo(winNumber)\title}
  WindowTags winNumber, winFlags, wininfo(winNumber)\title, ?__Taglist

  winstatus(winNumber) = -1
  wininfo(winNumber)\w = w,h

  If ExecVersion > 38
    HelpControl_ Peek.l(Addr Window(winNumber)), #HC_GADGETHELP
  EndIf

  If winNumber = #_winSource Then sourceWindow\win = Peek.l(Addr Window(winNumber))

  GTSetMenu 0
  WindowFont 1
  If (winNumber = #_winSearch) OR (winNumber = #_winCustom) OR (winNumber = #_winArray) OR (winNumber > 12)
    WindowFont 0
  EndIf

  If winNumber = #_winDisAsm Then InnerCls 2   ; clear/fill winNumber with colour 2

  Statement Return

  __Taglist:
            Dc.l  #WA_NewLookMenus  ,   1
  __gimmi   Dc.l  #WA_GimmeZeroZero ,   1
  __tl_w:   Dc.l  #WA_Width         ,   0
  __tl_h:   Dc.l  #WA_Height        ,   0
  __tl_l:   Dc.l  #WA_Left          ,   0
  __tl_t:   Dc.l  #WA_Top           ,   0
  __tl_g:   Dc.l  #WA_Gadgets       ,   0
            Dc.l  #WA_MenuHelp      ,   1
  __tl_scr: Dc.l  #WA_ScreenTitle   ,   0
  __more:   Dc.l  #TAG_MORE         ,   0

  __norm:
            Dc.l  #WA_MinWidth      ,  160
            Dc.l  #WA_MinHeight     ,   70
            Dc.l  #WA_MaxWidth      , 1920
  __tl_mh:  Dc.l  #WA_MaxHeight     , #maxheight_ever
            Dc.l  #TAG_END

  __memwin: Dc.l  #WA_MinWidth      ,  208
            Dc.l  #WA_MinHeight     ,   70
            Dc.l  #WA_MaxWidth      , 1920
            Dc.l  #WA_MaxHeight     , #maxheight_ever
            Dc.l  #TAG_END
End Statement


Statement Domemtitle{num.w}
 SHARED memlock$(),wininfo()

  win.w = #_winMemory1+num
  a$    = wininfo(win)\title
  If memlock$(num)
    a$+" ("+UCase$(memlock$(num))+")"
  EndIf
  If (Peek.l(Addr Window(win)))
    Use Window win
    WTitle a$
  EndIf
End Statement


; Open a new memory window
Statement NewMemWindow{win.w}
 SHARED wininfo()

  wininfo(win)\flags   = #WFLG_SIZEBBOTTOM|#WFLG_CLOSEGADGET|#WFLG_DEPTHGADGET|#WFLG_DRAGBAR|#WFLG_SIZEGADGET|#WFLG_NEWLOOKMENUS ;$20002f
  wininfo(win)\gadlist = -1
  NewWindow{win}

  If win = #_winMemory1 Then num.b = 0 Else num = 1
  Domemtitle{num}
End Statement


; Delete a window, after storing its size and position.
; Stores data so that the window can be reopened easily.
Statement DelWindow{win.w}
SHARED wininfo(),winstatus()

  If (Peek.l(Addr Window(win))=0) Then Use Window 0 :Statement Return

  log2PED{"DelWindow " + Str$(win)}

  If win > 22
    Use Window win
    wininfo(win)\x = WindowX,WindowY,WindowWidth,WindowHeight
    winstatus(win) = 0
    WZCloseWindow win
    Use Window 0
  Else
    Use Window win
    wininfo(win)\x = WindowX,WindowY,WindowWidth,WindowHeight
    winstatus(win) = 0
    CloseWindow win
    Use Window 0
  EndIf
End Statement


Statement FindStructureWin{evw.l}
 SHARED objwins()

  FirstItem objwins()
  While objwins()\winnum<>evw
    NextItem objwins()
  Wend
End Statement


Statement SavePrefs{memptr.l, memsize.l}
SHARED redData, prefs

  If memptr
    If dos_Exist{p$} ; added to check if the path exist
      If WriteFile(0,dos_AddPart{redData\appPath,"RED_DBug.prefs"} )
        WriteMem 0,memptr,memsize
        log2PED{"writing prefs from mem location " + Hex$(memptr)}
        ;!log2PED_HexDump{memptr,memsize}
        CloseFile 0
      EndIf
      If WriteFile(0,dos_AddPart{redData\appPath,"RED_DBug2.prefs"} )
        WriteType 0,prefs
        CloseFile 0
      EndIf
    EndIf
  Else
    error{"Internal Error: Unable to save config because memptr=NULL !!!"}
  EndIf
End Statement


Statement RedrawArray{refreshtype.b}
 SHARED arrayadd,array1,array2,redData
 SHARED xarraynum,yarraynum,arraytype
 SHARED xarrayoff,yarrayoff,arraydatasize,arrayitemsize
 SHARED arraylabelsize

  If (Peek.l(Addr Window(#_winArray))=0) Then Statement Return
  Use Window #_winArray
  
  If refreshtype = 1
    If arrayitemsize > 0
      xarraynum = (InnerWidth ASR 3)/(arrayitemsize)
      xarraynum-2
    EndIf
    If xarraynum < 0 Then xarraynum = 0
    SetPropInfo #_winArray,#ARR_XGAD,xarraynum,array1,xarrayoff
    If xarraynum > array1
      xarraynum = array1
      xarrayoff = 0
    Else
      If xarrayoff+xarraynum+1 > array1 Then xarrayoff = array1-xarraynum
    EndIf

    yarraynum = (InnerHeight-8) ASR 3
    yarraynum-1
    SetPropInfo #_winArray,#ARR_YGAD,yarraynum,array2,yarrayoff
    If yarraynum > array2
      yarraynum = array2
      yarrayoff = 0
    Else
      If yarrayoff+yarraynum+1 > array2 Then yarrayoff = array2-yarraynum
    EndIf

    Redraw #_winArray,#ARR_XGAD
    Redraw #_winArray,#ARR_YGAD
  EndIf

  w.w  = InnerWidth
  hi.w = InnerHeight

  Select arraylabelsize
    Case 1
      a.l = 2
    Case 2
      a   = 4
    Case 3
      a   = 8
  End Select

  WLocate 0,0 : NPrint String$(" ",arrayitemsize)
  b$ = String$(" ",arrayitemsize-a)
  For x.w = xarrayoff To xarrayoff+xarraynum
    a$ = GetHex$(x, arraylabelsize)
    Print b$ + a$
  Next x

  WLocate 0,8
  For y.w = yarrayoff To yarrayoff+yarraynum
    a$ = GetHex$(y,arraylabelsize)
    NPrint b$+a$
  Next y

  Select arraydatasize
    Case 1
      a      = 2
      skip.l = 1

    Case 2
      a      = 4
      skip   = 2

    Case 3
      a      = 8
      skip   = 4
  End Select

  a$ = String$(" ",arrayitemsize-a)

  ad.l = arrayadd+(xarrayoff*skip)+(yarrayoff*(array1+1)*skip)
  For y = yarrayoff To yarrayoff+yarraynum
    ad2.l = ad : ad + ((array1+1) * skip)
    WLocate arrayitemsize * 8, (y-yarrayoff+1) * 8
    For x = xarrayoff To xarrayoff+xarraynum
      Print a$ + GetHexAdr$(ad2, arraydatasize)
      ad2+skip
    Next x
  Next y

End Statement


Statement UpdateDisCop{}
SHARED discop_ad,redData

  If (Peek.l(Addr Window(#_winDisCop))=0) Then Statement Return

  Use Window #_winDisCop
  WLocate 0,0

  ad.l = discop_ad
  For h.w = 1 To (InnerHeight / WinFontHeight)
    If ad
      NPrint Hex$(ad) + " " + GetCopIns$(ad)
      ad + 4
    EndIf
  Next h
End Statement


Statement UpdateDisAsm{@clear.l}
SHARED disasm_ad,d_d$,breakpoint_adr,redData
SHARED disStr(),breakstore,winstatus()
SHARED ProgramStart.l, ProgramSize.l , MyBufferAddress.l

  If winstatus(#_winDisAsm) = 0 Then Statement Return
  If (Peek.l(Addr Window(#_winDisAsm)) = 0) Then Statement Return

  log2PED{"..updateDisassemblerWindow"}

  ad.l = Peek.l(MyBufferAddress)   ; replaced ASM code with BASIC  tomsmart1
  If ad
    pc.l = Peek.l(ad + 64)-2
  EndIf

  ad = disasm_ad
  If ad < 4096 Then ad = 4096

  Use Window #_winDisAsm

  inw.l   = InnerWidth  -1
  inh.l   = InnerHeight -1
  fonth.w = WinFontHeight

  If clear = 1 Then InnerCls 2  ; clear/fill win with colour 2

  ;log2PED{"inh: " + Str$(inh) + " fonth: " + Str$(fonth)}
  ;log2PED{"ad: " + Hex$(ad)}
  ;log2PED{"pc: " + Hex$(pc)}
  ;log2PED{"ps: " + Hex$(ProgramStart)}
  ;log2PED{"psize: " + Hex$(ProgramSize)}
  ;log2PED{"p+p: " + Hex$(ProgramStart+ProgramSize)}
  WColour 1,2 : WLocate 0,1
  For h.l = 0 To (inh/fonth)-1

    If (ad < ProgramStart) OR (ad > (ProgramStart+ProgramSize) ) Then Statement Return
    If (pc < ProgramStart) OR (pc > (ProgramStart+ProgramSize) ) Then Statement Return
    If ((ad-2) < ProgramStart) AND redData\asmStep Then Statement Return
    outtxtStr.s = "$" + Hex$(ad)
    If pc = ad
      outtxtStr + "**>"
    Else
      outtxtStr + "   "
    EndIf

    If Peek.w(ad) = #opcode_TRAP1
      ad + 2
      ad2.l  = breakpoint_adr-8
      flag.w = 0
      While flag = 0
        ad2+8
        break.l = Peek.l(ad2)
        If break = ad Then flag = -1
        If break = 0  Then flag = 1
      Wend
      If flag = -1
        If redData\asmStep
          bt1.l = ad2-breakpoint_adr
          bt1   = bt1+breakstore
          ad-2
          Poke.w ad,Peek.w(bt1)
        EndIf
        btype.w = Peek.w(ad2+4)
        ;FInverse On
        If btype = #break_simple
          outtxtStr + "["+Hexw$(Peek.w(ad2+6))+"]" ;: FInverse Off : ;Countdown
          outtxtStr + " "
        Else
          If btype = #break_permanent
            outtxtStr + "[*]" ;: FInverse Off :
            outtxtStr + "    "
          Else
            outtxtStr + "[="+Hexw$(Peek.w(ad2+6))+"]" ;Counter
          EndIf
        EndIf
        ;FInverse Off
      Else
        ;FInverse On :
        outtxtStr + ">>>" ;: FInverse Off :
        outtxtStr + "    "
      EndIf
      If redData\asmStep AND flag = -1
        a$        = DisAssemble$(ad)
        disStr(h) = a$
        outtxtStr + a$
        Poke.w ad,#opcode_TRAP1
        ad + InstrSize
      Else
        outtxtStr + "Basic Token                     " ; it was the basic token
        WColour 3,2   ;set draw colour to 3 (token colour)
        ad + 8
      EndIf
    Else
      a$        = DisAssemble$(ad)
      disStr(h) = a$
      outtxtStr + "      " + a$
      ad + InstrSize
    EndIf

    outtxtleng.l = TextFit(outtxtStr,inw)      ; calc the chars we can print
    If outtxtleng > 0                          ; test if we have space to print the string
      If FLen(outtxtStr) > outtxtleng          ; test is we have space to print the complete string
        outtxtStr = Left$(outtxtStr,outtxtleng); no , cut it down to the space we have
      EndIf
      NPrint outtxtStr
    Else
      h = (inh/fonth)-1                       ; no can't print jump to the last to exit the loop
    EndIf
    log2PED{">> " + outtxtStr}
    WColour 1,2  ; set to draw to colour 1 and background to 2
  Next h
  WColour 1,0  ; set colours back to defaults
End Statement


Statement UpdateVarWindow{}
SHARED varinfo(),winstatus(),ffp;,i

  If (Peek.l(Addr Window(#_winVariables) ) = 0) Then Statement Return

  Use Window #_winVariables
  fonth.w = WinFontHeight
  inw.l = InnerWidth              -1
  inh.l = InnerHeight-(fonth + 2) -1  ; get and calc the height, minus the 1 textline and the border

  xpos.w = TextLength_(RastPort(#_winVariables),"1234567890123456789",19) ; get the position to start with the print value
  inw - xpos  ; to get the width of the window we can use to print the value

  If (inh > fonth) AND (inw > 0)  ; test if we have the height and the width to print the Values
    ResetList varinfo()
    mq.q = 0 : mf.f = 0
    count.l = 0

    While NextItem(varinfo())
      ad.l = varinfo()\address
      If ad
        count + 1
        f.b = varinfo()\form

        Select varinfo()\typ
          Case 1 ; BYTE
            Select f
              Case 0 : a$ = Str$(Peek.b(ad)) + "  " ; added space to clear possible old value  tomsmart1 2016 02 05
              Case 1 : a$ = "$" + GetHexAdr$(ad,1)
              Case 2 : a$ = "%" + Binb$(Peek.b(ad))
            End Select

          Case 2 ; WORD
            Select f
              Case 0 : a$ = Str$(Peek.w(ad)) + "    "   ; added space to clear possible old value  tomsmart1 2016 02 05
              Case 1 : a$ = "$" + GetHexAdr$(ad,2)
              Case 2 : a$ = "%" + Binw$(Peek.w(ad))
            End Select

          Case 3 ; LONGWORD
            Select f
              Case 0 : a$ = Str$(Peek.l(ad)) + "         "  ; added space to clear possible old value  tomsmart1 2016 02 05
              Case 1 : a$ = "$"+GetHexAdr$(ad,3)
              Case 2 : a$ = "%"+Bin$(Peek.l(ad))
            End Select

          Case 4 ; STRING trace output
            ssize.l    = Peek.l(Peek.l(ad)-4)
            smaxsize.l = Peek.l(Peek.l(ad)-8)
            If f = 1
              a$ = "'" + Peek.s(Peek.l(ad)) +"' ["+Str$(ssize)+"/"+Str$(smaxsize)+"]"
            Else
              a$ = "'" + Peek.s(Peek.l(ad)) + "'"
            EndIf
            If smaxsize > ssize                   ; added tomsmart1
              For times.l = 1 To (smaxsize-ssize+3) ; to get the space to overwrite old Strings and sizeinfo
                a$ + " " ; added Space to overwrite/clear
              Next
            EndIf

          Case 5 ; QUICK
            Poke.l &mq,Peek.l(ad)
            a$ = Str$(mq)

          Case 6 ; FLOAT
            If winstatus(#fpuwin)
              i.l = Peek.l(ad)
              Dc.l $f2276800    ;fmove.x fp0,-(a7)
              fmove.s i@(a4),fp0
              JSR fpuffp
              Dc.l $f21f4800    ;fmove.x (a7)+,fp0
              a$ = Str$(ffp)
            Else
              Poke.l &mf,Peek.l(ad)
              a$ = Str$(mf)
            EndIf

        End Select

        If (count * fonth) < inh         ; test if the position is in the window
          outtxtleng.l = TextFit(a$,inw) ; calc the chars we can print
          If outtxtleng >0               ; test if we have space to print the string
            WLocate xpos,(count*fonth)+2 ; set the position to print the value
            If FLen(a$)>outtxtleng       ; test is we have space to print the complete string
              a$=Left$(a$,outtxtleng)    ; no , cut it down to the space we have
            EndIf
            NPrint a$
          Else
            LastItem varinfo()           ; no can't print jump to the last entry in the list to exit the loop
          EndIf
        Else
          LastItem varinfo()             ; no jump to the last entry in the list to exit the loop
        EndIf
      EndIf
    Wend

  EndIf
End Statement


Statement RedrawVarWindow{}
SHARED varinfo(),objtype$

  If (Peek.l(Addr Window(#_winVariables)) = 0) Then Statement Return
  Use Window #_winVariables

  inw.l   = InnerWidth  -1  ; -1 to get the right size to calculate
  inh.l   = InnerHeight -1  ;           "
  fonth.w = WinFontHeight

  InnerCls
  xpos.l = TextLength_(RastPort(#_winVariables),"1234567890123456789",19) ; get the position to start with the print of the value

  ; print statusline
  If  inh > fonth + 1 ; test if we have the height to print the status line
    a$ = "Variable"
    outtxtleng.l = TextFit(a$,inw)
    WLocate 0,0
    If outtxtleng > 0           ; test if we have space width to print the string
      If FLen(a$)>outtxtleng    ; test is we have space to print the complete string
        a$=Left$(a$,outtxtleng) ; no , cut it down to the space width we have
      EndIf
      Print a$
      WLocate xpos,0
      a$ = "Value"
      outtxtleng = TextFit(a$,inw-xpos)
      If outtxtleng > 0           ; test if we have space width to print the string
        If FLen(a$)>outtxtleng    ; test is we have space to print the complete string
          a$=Left$(a$,outtxtleng) ; no , cut it down to the space width we have
        EndIf
        Print a$
      EndIf
    Else
      Statement Return
    EndIf

    ; draw separation line
    Wline WLeftOff, WTopOff + fonth, WLeftOff + inw, WTopOff + fonth, 1

    ; print variable names
    WLocate 0,fonth+2
    inh - (fonth+2)               ; reduce the innerheight, with the 1 textline and the borderline
    count.l = 0
    If inw < xpos Then xpos= inw  ; for the case the window are smaller then the value position
    ResetList varinfo()

    While NextItem(varinfo())
      count+1
      If (count*fonth)<inh        ; test if we have space height to print
        a$ = "."+Mid$(objtype$,varinfo()\typ,1)   ; get type to print
        If a$ = ".s" AND Right$(varinfo()\name,1) = "$" Then a$ = ""  ; test if we have a String with $
        a$ = varinfo()\name+a$    ; generate the complette string with var name and type
        outtxtleng = TextFit(a$,xpos)
        If FLen(a$)>outtxtleng    ; test is we have space width to print the complete string
          a$=Left$(a$,outtxtleng) ; no , cut it down to the space we have
        EndIf
        NPrint a$
      Else
        LastItem varinfo()        ; no , jump to last entry to exit the loop
      EndIf
    Wend

  EndIf
End Statement


Function.l GetStructVal{num.w}
 SHARED objwins()

  ad.l  = objwins()\typepointer
  ads.l = objwins()\mem_type
  While Peek.b(ads) <> 0 AND num <> 0
    ad + Peek.w(ads+2)
    ads + 4
    num - 1
  Wend

  If Peek.w(ads) = 0 Then Function Return -1

  Select Peek.w(ads)
    Case 1 : ad = Peek.b(ad)
    Case 2 : ad = Peek.w(ad)
    Case 3 : ad = Peek.l(ad)
    Case 4 : ad = Peek.l(ad)
  End Select

  Function Return ad
End Function


; Update the object trace window
Statement RefreshTypeWindow{}
SHARED winstatus(),redData
SHARED objwins()

  DEFTYPE.q mq
  DEFTYPE.f mf

  If (Peek.l(Addr Window(objwins()\winnum)) = 0) Then Statement Return

  Use Window objwins()\winnum
  ad.l = objwins()\typepointer

  typewidth.w = objwins()\typewidth
  WLocate typewidth,0
  inw.l = InnerWidth
  inh.l = InnerHeight
  WBox typewidth,WTopOff+1,inw-typewidth,inh AND %1111111111111000,0
  If ad OR objwins()\is_bbobject=0
    WLocate typewidth,0 : NPrint Hex$(ad) ; change for fontsize
    ads.l  = objwins()\mem_type
    defy.l = 10
    While Peek.w(ads) <> 0
      WLocate typewidth,defy
      defy+8
      a.w = Peek.w(ads)
      If a < 4
        NPrint GetHexAdr$(ad,a)
      Else
        Select a

          Case 4
            If Peek.l(ad) <> 0 Then NPrint  PeekMax$(Peek.l(ad),80) Else NPrint  ""
            ;If Peek.l(ad)<>0 Then FNPrint PeekMax$(Peek.l(ad),80) Else FNPrint ""

          Case 5 ; QUICK
            Poke.l &mq,Peek.l(ad)
            NPrint Str$(mq)

          Case 6 ; FLOAT
            Poke.l &mf,Peek.l(ad)
            NPrint Str$(mf)
        End Select
      EndIf
      ad + Peek.w(ads + 2)
      ads + 4
    Wend
  Else
    Print "No object found"
  EndIf
End Statement


Function.l FindBreakPoint{ad.l}
SHARED breakpoint_adr

  ad2.l  = breakpoint_adr
  found.b = False
  While Peek.l(ad2) <> 0 AND NOT found
    If Peek.l(ad2) = ad
      found = True
    Else
      ad2 + 8
    EndIf
  Wend
  If found = 0 Then ad2 = 0
  Function Return ad2
End Function


Statement RedrawMouseables{n.w}
SHARED mouseables,num_mouseables,mouseables_off,redData

  If Peek.l(Addr Window(#_winMouseables))=0 Then Statement Return
  Use Window #_winMouseables
  w.w  = InnerWidth
  hi.w = InnerHeight
  h.w  = hi ASR 3

  If n = True
    SetPropInfo #_winMouseables,#MSE_SGAD,h,num_mouseables,mouseables_off
    Redraw #_winMouseables,#MSE_SGAD
  EndIf

  InnerCls
  WLocate 0,0
  y.w  = 0
  ad.l = mouseables
  If mouseables_off
    For loop.w = 1 To mouseables_off
      If ad Then ad = Peek.l(ad)
    Next loop
  EndIf

  If ad <> 0
    While y < h AND y < num_mouseables
      If ad Then ad2.l = Peek.l(ad+4)
      If ad2 Then a$ = ExtractLabel(ad2)
      NPrint a$
      y+1
      If ad Then ad = Peek.l(ad)
    Wend
  EndIf
End Statement


Statement GetCustomMenus{}
SHARED redData, customcomm$()

  If ReadFile(0,dos_AddPart{redData\appPath,"REDDebugger.menus"} ) ; change path
    GTMenuTitle 0,4,"Custom"
    FileInput 0
    n.l = 0
    Repeat
      a$ = Edit$(256)
      If a$ <> ""
        D_InitParse a$
        b$   = D_NextArg$
        typ$ = D_NextArg$
        s$   = D_NextArg$
        customcomm$(n) = D_NextArg$
        customcomm$(n) = D_NextArg$
        If s$ = Chr$(126) Then s$ = ""
        If b$ <> Chr$(126)
          GTMenuItem 0,0,4,n,b$,s$
        Else
          GTMenuItem 0,0,4,n
        EndIf
        n+1
      EndIf
    Until Eof(0) OR n = #MAXCUSTOMCOMMANDS
    PopInput
    CloseFile 0
  EndIf
End Statement

.@regs
Statement InitRegsWin{}
 SHARED winstatus()

  log2PED{"InitRegsWin()"}
  If winstatus(#_winRegisters) AND (Peek.l(Addr Window(#_winRegisters) ) >< 0)
    Use Window #_winRegisters
    InnerCls
    *rp.RastPort = RastPort(#_winRegisters)
    inw.l   = InnerWidth  -1
    inh.l   = InnerHeight -1
    fonth.w = WinFontHeight
    iy.w    = WTopOff
    ix.w    = WLeftOff
    textlen.w=TextLength_(*rp," ",1) ; this works only for nonproportional fonts !
    maxcharperline.l = inw/textlen
    If (inh > fonth) AND (maxcharperline >= 4) ; test if we have the heigth and weidth to print something
      ;OutTextPen *rp,1
      SetAPen_ *rp, 1
      y.l = iy + 1
      For h.l = 0 To 7
        If inh >= (fonth*(h + 1))     ; test if we have the height to print the line
          ; data registers
          OutText ix,y,*rp,"d"+Str$(h)+"=$"
          If maxcharperline >= (4+8)
            ;OutText ix+4*textlen,y,*rp,"--------"
            ; address registers
            If maxcharperline >= (20+4)
              OutText ix+20*textlen,y,*rp,"a"+Str$(h)+"=$"
              If maxcharperline >= (24+8)
                ;OutText ix+24*textlen,y,*rp,"--------"
              EndIf
            EndIf
          EndIf
          y + fonth
        Else
          h = 7
        EndIf
      Next h
      If inh >= (fonth*9)     ; test if we have the height to print the line
        ; status register
        OutText ix           ,y,*rp,"sr=$"
        If maxcharperline >= (4+4)
          ;OutText ix+ 4*textlen,y,*rp,"----"
          If maxcharperline >= (13+5)
            OutText ix+13*textlen,y,*rp,"-----"
            ; program counter
            If maxcharperline >= (19+5)
              OutText ix+19*textlen,y,*rp,"BPC=$"
              ;If maxcharperline >= (24+8)
              ;  OutText ix+24*textlen,y,*rp,"--------"
              ;EndIf
            EndIf
          EndIf
        EndIf
      EndIf

    EndIf

  EndIf
End Statement



Statement RedrawRegs{}
 SHARED redData, winstatus(),MyBufferAddress.l ,fpuneedupdate.l
 SHARED srStr.s , regaStr.s , regdStr.s    ; important must be pre filled (Spaces) in the needed size for D_CheckNMoveA else it produce Hits

  log2PED{"RedrawRegs()"}
  If winstatus(#_winRegisters) AND (Peek.l(Addr Window(#_winRegisters) ) >< 0)
    ad.l = Peek.l(MyBufferAddress)
    If ad
      Use Window #_winRegisters
      *rp.RastPort = RastPort(#_winRegisters)
      inw.l   = InnerWidth  -1
      inh.l   = InnerHeight -1
      fonth.w = WinFontHeight

      iy.w    = WTopOff
      ix.w    = WLeftOff
      textlen.w = TextLength_(*rp," ",1)  ; this works only for nonproportional fonts !
      maxcharperline.l = inw/textlen
      If (inh > fonth+1) AND (maxcharperline >= (4+8) ) ; test if we have the heigth and weidth to print something
        y.l = iy+1
        For h.l = 0 To 7
          If inh >= (fonth*(h+1))     ; test if we have the height to print the line
            ;data regs
            dreg.l = Peek.l(ad)         ; get address of the first data register
            OutText ix + 4*textlen,y,*rp,Hex$(dreg)
            If maxcharperline >= (13+4)
              D_CheckNMoveA ad,&regdStr
              OutText ix + 13*textlen,y,*rp,regdStr

              If maxcharperline >= (24+8)
                ;address regs
                areg.l = Peek.l(ad+32)  ; get address of the first address register
                OutText ix+24*textlen,y,*rp,Hex$(areg)

                If redData\osType = #AmigaOS3        ; added to prevent Hits  with AmigaOS4 and maybe MorphOS
                  If maxcharperline >= (33+46)
                    ; begin show Adressregisterpointer values !!!!
                    If areg > #lowestaddr
                      CNIF #longs = 1
                      CELSE
                        D_HexWord areg,&regaStr,6
                      CEND
                        D_CheckNMoveA areg,&regaStr+31,3
                      OutText ix + 33*textlen,y,*rp,regaStr
                     EndIf
                   EndIf
                 EndIf

              EndIf

            EndIf

            ad + 4     ; go to next register 4 bytes = 1Long
            y + fonth  ; vertical step for
          Else
            h = 7      ; we have not the height to print the line we have to end the loop
          EndIf
        Next h
;        MOVE.l #-200,fpreg
;        For i=0 To 4
;        MOVE.l regpos,a0
;        ADD.l fpreg,a0
;        ADD.l #12,fpreg
;        Dc.l $f2284800 : Dc.w 0 ; fmove.x 0(a0),fp0
;        fmove.s fp0,d0
;        JSR fpuffp
;        OutText i*120+4,84,rp,"F"+Str$(i)+"="+Str$(ffp)
;        Next
        ; status register
        If inh >= (fonth*9)     ; test if we have the height to print the line
          mysr.w = Peek.w(ad+32+4)
          OutText ix + 4*textlen,y,*rp,Hexw$(mysr)
          If maxcharperline >= (13+5)
            D_GetSR &srStr,mysr
            OutText ix + 13*textlen,y,*rp,srStr
            If maxcharperline >= (24+8)
              ; program counter
              areg = Peek.l(ad+32) ; Get program counter
              OutText ix + 24*textlen,y,*rp,Hex$(areg-2)
            EndIf
          EndIf
        EndIf

      EndIf
    EndIf
  EndIf
  fpuneedupdate = 6
End Statement


Statement DrawMem{number.b}
 SHARED mempointer(),memStr()

  If Peek.l(Addr Window(#_winMemory1+number) )
    inw.l   = InnerWidth  -1
    inh.l   = InnerHeight -1
    fonth.w = WinFontHeight
    iy.w    = WTopOff
    ix.w    = WLeftOff

    *rp.RastPort = RastPort(#_winMemory1+number)
    w.l  = (inw/TextLength_(*rp,"$1",1) ) ; calc the max char
    If w >= (10 + 7)  ;address + word hexvalue + space + two ASCII chars
      w-10  ; - the size of the address '$xxxxxxxx '
      a$ = String$(" ",w)
      w/7  ; calc how many values to show in one line for (word hexvalue + space + two ASCII chars)
      ad.l = mempointer(number)
      If ad
        WTitle "$" + Hex$(ad)
        ad2.l = &a$ + (w*5) + 1
        ;OutTextPen *rp,1
        SetAPen_ *rp, 1
        y.l = iy +1
        For h.l = 0 To (inh/fonth)-1
          D_HexWord ad,&a$,w
          D_CheckNMoveWord ad,ad2,w
          OutText ix,y,*rp,"$" + Hex$(ad) + " " + a$
          memStr(h) = "$" + Hex$(Peek.l(ad) )
          y + fonth
          ad + (w ASL 1)
        Next h
      EndIf
    EndIf
  EndIf
End Statement


Statement RedrawMem{}
 SHARED winstatus(), dowin
  If winstatus(#_winMemory1) AND (dowin = 0 OR dowin = -1) AND (Peek.l(Addr Window(#_winMemory1)) >< 0)
    Use Window #_winMemory1
    num.b = 0
    DrawMem{num}
  EndIf

  If winstatus(#_winMemory2) AND (dowin = 1 OR dowin = -1) AND (Peek.l(Addr Window(#_winMemory2)) >< 0)
    Use Window #_winMemory2
    num = 1
    DrawMem{num}
  EndIf

  dowin = -1
End Statement


Function.b RED_CheckForTrap1{}
SHARED MyBufferAddress

  result.b = False
  temp2.l = Peek.l(MyBufferAddress)
  temp2   = Peek.l(temp2 + 64)
  If Peek.w(temp2-2) = #opcode_TRAP1 AND Peek.w(temp2-2+Peek.w(temp2+6)) = #opcode_TRAP1
    result = True
  EndIf
  Function Return result
End Function


Statement RED_PrintText{y.w,text.s}   ; y = y pixel to print at, text.s = line to print
SHARED sourceWindow
USEPATH sourceWindow

  Use Window #_winSource

  ;-- clear area and draw decorative lines
  Wline \win\BorderLeft,y - 1,\win\BorderLeft + \boxWidth-1,y-1,1
  Wline \win\BorderLeft,y    ,\win\BorderLeft + \boxWidth-1,y,2
  WBox  \win\BorderLeft,y + 1,\win\BorderLeft + \boxWidth-1,y + WinFontHeight + 2,0

  tlen.w = FLen(text)
  tfit.w = TextFit_(\win\RPort, text, tlen, &myextent.TextExtent,0,1,\boxWidth - 2,1024)
  If tlen > tfit Then text = Left$(text,tfit)

  WColour 1,0 : WLocate 1, y - \boxTop + 2 : Print text
End Statement

Function.s RED_PrintSourceLine{i2.l, y.w, @cln.w}
SHARED redData, sourceWindow

  ret.l = getad2{i2}
  t$  = DetokenizeLine(ret, True)
  t$  = Replace$(t$,"End\\c0\\c0If","EndIf")      ; change "End If" to "EndIf"
  InitArgParse t$

  If redData\showLineNumbers
    Format String$("#",sourceWindow\lineNumberDigits)
    If i2 = sourceWindow\currentLine
      WindowFont 2,#FSF_BOLD
    Else
      WindowFont 2,0
    EndIf
    WLocate 0,y : WColour 1,2 : Print Str$(cln)
    Format ""
  EndIf

  ;sourceWindow\win\RPort\cp_x = sourceWindow\boxLeft
  x.l = sourceWindow\boxLeft - sourceWindow\charOffset * sourceWindow\win\RPort\TxWidth
  WLocate x, y

  drawOffset.l = sourceWindow\charOffset
  hldone.l  = False
  tog.l = 0 ; toggle output
  a$  = NextArgChar$($c0)                         ; extract tokens, they are bounded by character $c0
  Repeat
    If i2 = sourceWindow\currentLine AND drawOffset >= sourceWindow\lineOffset AND hldone = False
      If tog
        WColour 3,0 : WindowFont 2,#FSF_BOLD
      Else
        WColour 1,0 : WindowFont 2,#FSF_BOLD
      EndIf
      If Instr(a$,":")    Then hldone = True
      If Instr(a$,"Then") Then hldone = True
    Else
      If tog
        WColour 3,2 : WindowFont 2,#FSF_BOLD
      Else
        WColour 1,2 : WindowFont 1
      EndIf
    EndIf

    ;a$ = Replace$(a$,"==> ","")
    ;a$ = Replace$(a$,"=> " ,"")
    drawOffset + FLen(a$)
    x = x + FLen(a$) * sourceWindow\win\RPort\TxWidth

    If Instr(a$,";")
      ; -- handle comments
      xpos.w = Instr(a$,";") - 1
      Print Left$(a$,xpos)
      WindowFont 1,#FSF_ITALIC : WColour 0,2
      Print Right$(a$,FLen(a$)-xpos)
    Else
      Print a$
    EndIf

    a$ = NextArgChar$($c0)
    tog = NOT tog
  Until a$ = ""

  WColour 1,0
  WindowFont 1
  x = x + sourceWindow\win\BorderLeft
  If x < sourceWindow\win\Width - sourceWindow\win\BorderRight
    WBox x,y + sourceWindow\win\BorderTop, sourceWindow\win\Width - sourceWindow\win\BorderRight - 1, @@
           y + sourceWindow\win\BorderTop-1 + sourceWindow\win\RPort\TxHeight,2
  EndIf

  t$ = Replace$(t$,"\\c0","")
  ;If (i2 = sourceWindow\currentLine) AND (i2 <> sourceWindow\lastCurrentLine)
  ;  log2PED{">>" + t$}
  ;EndIf

  sourceWindow\lastCurrentLine = i2
  Function Return t$
End Statement



Function.b RED_ShowSyntaxHelp{*pc.pcinfo}
SHARED redData, *tokenbase

  If redData\showSyntaxHelp
    syntax_$ = ""
    If *pc
      ; -- TODO: trim source line to remove leading spaces !!
      toke.w = Peek.w(getad{*pc} + *pc\lineOffset)
      toke = toke AND $7fff
      log2PED{"searching token help..."}
      found.b = False
      *token.tokendata = *tokenbase
      While *token AND (NOT found)
        If *token\number = toke
          syntax_$ = Peek.s(&*token\dat)
          syntax_$ + " " + Peek.s(&*token\dat + FLen(syntax_$) + 1)
          found = True
        EndIf
        *token = *token\next_token
      Wend
    Else
      log2PED{"showsyntaxhelp: no *pc"}
    EndIf

    log2PED{"syntaxprint: [" + syntax_$ + "]"}
    RED_PrintText{redData\syntaxTextY, syntax_$}
  EndIf
End Statement


Statement RED_ShowStatusText{t$}
SHARED redData, lt$, *pcInfo

  If (Peek.l(Addr Window(#_winSource)))
    RED_PrintText{redData\statusTextY, t$}
    lt$ = t$
    RED_ShowSyntaxHelp{*pcInfo}
  Else
    log2PED{"can not show status text."}
  EndIf

End Statement



Statement RED_PrintSource{@*sl.sourceLine}
SHARED redData,sourceWindow, textBuffer(), prtbusy
USEPATH sourceWindow

  If (Peek.l(Addr Window(#_winSource)))
    rp_SetClipExt{\win\RPort,\win\BorderLeft,\win\BorderTop,\win\Width-\win\BorderRight-1,\win\Height-\win\BorderBottom-1}
    Use Window #_winSource

    If *sl = -1 Then *sl = sourceWindow\currentLine
    ;!log2PED_HexDump{*sl,32}

    If redData\showLineNumbers
      ;-- get line number
      lineNumber.l = 0
      *tmpSl.sourceLine = *sl
      While *tmpSl
        lineNumber + 1
        *tmpSl = *tmpSl\previousLine
      Wend

      ;-- get total number of lines
      totalLines.l = lineNumber - 1
      *tmpSl.sourceLine = *sl
      While *tmpSl
        totalLines + 1
        *tmpSl = *tmpSl\nextLine
      Wend

      \lineNumberDigits = 5
      If totalLines < 10000 Then \lineNumberDigits = 4
      If totalLines < 1000 Then \lineNumberDigits = 3
      If totalLines < 100 Then \lineNumberDigits = 2
      If totalLines < 10 Then \lineNumberDigits = 2

      ;-- draw seperator line
      tmps.s = String$("0",\lineNumberDigits)
      \boxLeft = \win\BorderLeft + TextLength_(\win\RPort,&tmps,\lineNumberDigits) + 4
      WBox \win\BorderLeft, \boxTop, \boxLeft, \boxTop + \boxHeight,2
      Wline \boxLeft-1, \boxTop, \boxLeft-1, \boxTop + \boxHeight,1
      Wline \boxLeft-2, \boxTop, \boxLeft-2, \boxTop + \boxHeight,0

      log2PED{"current line number: " + Str$(lineNumber) + ", total lines: " + Str$(totalLines)}
    EndIf

    ;-- clear source text area
    WBox \boxLeft, \boxTop, \boxLeft+\boxWidth,\boxTop+\boxHeight,2

    ;-- calculate middle row in windows, align center
    ym.l = sourceWindow\visibleLines / 2
    If sourceWindow\visibleLines & 1 = 0 Then ym - 1
    ym = ym * sourceWindow\win\RPort\TxHeight

    ;-- print current line number and following lines
    y.l = ym : tmpLn.l = lineNumber
    *tmpSl = *sl
    While *sl AND (y <= \boxHeight - \win\RPort\TxHeight)
      textBuffer(y / \win\RPort\TxHeight) = RED_PrintSourceLine{*sl, y, tmpLn} ; add line to sourcearray for clickvar
      tmpLn + 1
      y + \win\RPort\TxHeight

      *sl = *sl\nextLine
    Wend

    ;-- print previous lines up until box top is reached
    y = ym - \win\RPort\TxHeight : tmpLn = lineNumber
    *sl = *tmpSl : *sl = *sl\previousLine
    While *sl AND y >= 0
      tmpLn - 1
      textBuffer(y / \win\RPort\TxHeight) = RED_PrintSourceLine{*sl, y, tmpLn}
      y - \win\RPort\TxHeight

      *sl = *sl\previousLine
    Wend

    rp_RemClipExt{\win\RPort}

    ;t$ = Str$(lineNumber) + ":" + Str$(totalLines) : RED_ShowStatusText{t$}
  EndIf

  prtbusy = 0
End Statement

Statement RED_UpdateSourceWindow{*pcInfo.pcinfo}
SHARED sourceWindow, ali.l

  If *pcInfo
    If RED_CheckForTrap1{}
      sourceWindow\currentLine = getad {*pcInfo}
      sourceWindow\lineOffset = *pcInfo\lineOffset - 9
      ;
      RED_PrintSource{}
      ;
      ali = *pcInfo
      RED_ShowSyntaxHelp{*pcInfo}
    EndIf
  Else
    log2PED{"UpdateSourceWindow: no *pcInfo!"}
  EndIf
End Statement


Statement ShowHelp{a$}
SHARED redData

  If redData\arexxPort = 0
    message{"Online help not available because <RexxMast> is not running."}
    Statement Return
  EndIf

  If redData\pubscreenName = ""
    p$ = "Workbench"
  Else
    p$ = redData\pubscreenName
  EndIf

  GetPubScreen 1,p$
  ShowScreen 1
  ReleasePubScreen 1,p$
  Poke.l Addr Screen(1),0

  Use Screen 0
  If FindPort_("DEBUGGERHELP.1")
    log2PED{"... RexxPort for DEBUGGERHELP.1 found, sending command"}
    RXSendCommand "DEBUGGERHELP.1","'link " + a$ + "'"
  Else
    commandlineStr.s = " -t " + a$
    commandlineStr + " -d " + dos_AddPart{redData\ab3Path,"Docs"}
    commandlineStr + " -l REDDebugger -s " + p$
    log2PED{"... no RexxPort for DEBUGGERHELP.1 found, using AB3Helpviewer: " + commandlineStr}
    RED_ShowStatusText{"opening Helpviewer for ["+ a$ + "] ..."}
    dos_RunCli{dos_AddPart{redData\ab3Path,"Tools/AB3HelpViewer"},0,8192,False,commandlineStr}
  EndIf
End Statement



;*****************************************************************


.mainstart:
  log2PED{"Init Debugger-GUI..."}

  ClearProcessPtrs
  debug_pathname$      = ""          ; added rest to defaults  tomsmart1 2016 02 08
  debug_pathname_Ptr.l = 0
  debug_filename$      = ""
  debug_filename_Ptr.l = 0
  num_mouseables       = 0
  mouseables           = 0
  *TokenBase_Pointer.l = 0
  sourceWindow\startCode = 0
  CLR.l programsize
  CLR.l programstart
  CLR.l trap15addr
  CLR.l comdata

  If ted_OpenLib{0}
    *ComData_Pointer = TEDGetJumpTable{} ; only used to get the comdata pointer
    If *ComData_Pointer <> 0
      ; -- synchronize pointertable from PED with debuggers comdata-structure
      GetRegD0 *ComData_Pointer : MOVE.l d0,comdata

      !ComData_GetL{comData_Magic,D0} : magic.l = PutRegD0
      If magic = #MagicIdentifier_Long
        ; -- version check of the comdata structure to support the new changes
        !ComData_GetW{comWord_PEDIsAvailable,D0} : ComDataVersion.l = PutRegD0
        If ComDataVersion = #ComDataVersionID
          !ComData_GetL{comPtr_Trap15,trap15addr}

          ; move out of d_sethandler{} because is only need to set once tomsmart1 2012 07 14
          !ComData_GetL{comPtr_DirectBuffer,A0} : MOVE.l #direktbuffer,(a0)

          ; set token base pointer
          !ComData_GetL{comPtr_TokenBase,D0} : *TokenBase_Pointer = PutRegD0

          ;!ComData_GetL{comPtr_FirstSourceLine,D0} : redData\firstSourceLine = PutRegD0
          ;!ComData_GetL{comLong_TotalLines,D0} : redData\totalLines = PutRegD0
          ;log2PED{"total source lines: " + Str$(redData\totalLines)}
          ;tmp$ = DetokenizeLine(redData\firstSourceLine,False)
          ;log2PED{"first sourceline at " + Hex$(redData\firstSourceLine)+": " + tmp$}

          ; added to set the right size of the buffer because the compiler allocated the buffer  tomsmart1 2016 02 06
          !ComData_GetL{comPtr_DestBufferStart,A0} : MOVE.l a0,programstart : ProgramStart.l = Peek.l(?programstart)
          !ComData_GetL{comLong_DestBufferSize,A0} : MOVE.l a0,programsize  : ProgramSize .l = Peek.l(?programsize)
          !ComData_GetL{comPtr_LabelList    ,d0} : mouseables = PutRegD0
          !ComData_GetW{comWord_LabelCounter,d0} : num_mouseables = PutRegD0
          !ComData_GetL{comPtr_SourceName   ,d0} : debug_filename_Ptr = PutRegD0 : debug_filename$ = Peek.s(debug_filename_Ptr)
          !ComData_GetL{comPtr_SourceDir   ,d0} : debug_pathname_Ptr = PutRegD0 : debug_pathname$ = Peek.s(debug_pathname_Ptr)

          debug_pathspec$ = dos_AddPart{debug_pathname$,debug_filename$}
          AddProcessPtr "f",&debug_filename$
          AddProcessPtr "d",&debug_pathname$
          AddProcessPtr "F",&debug_pathspec$
        Else ; comdata version id
          error{"comdata structure version does not match!"}
        EndIf
      Else ;Magicidenifer
        error{"Invalid comdata structure!"}
      EndIf
    Else ; *ComData_Pointer
      error{"No comdata structure available!"}
    EndIf
  Else ; ted_OpenLib
    error{"No ted.library available!"}
  EndIf
  CNIF #test = 0
    d_sethandler{&redData\procStatus}
  CEND

  MyBufferAddress = ?mybuffer
  FillMem ?breakpoint,5 * 8

  log2PED{"synchronized data structures with PED ..."}

  log2PED{"load preferences ..."}
  Gosub loadPrefs

  ;--- Test if VBR is located at $0  
  If redData\checkVbr AND VBRcheck = 0
    message.s = "The VBR is currently located at memory address 0!\\n"
    message   + "It is recommended to move the VBR to Fast-Ram,\\nthe Debugger might cause enforcer hits otherwise.\\n\\n"
    message   + "Do you want to move the VBR now ?"
    If ask{message,"Yes|No"} = 1
      If VBRmove = 0
        error{"Could not move the VBR."}
      EndIf
    EndIf
  EndIf
  ;---


  log2PED{"opening windows ..."}
  Gosub openwindows : Activate #_winControl
  log2PED{"all windows opened ..."}

  SetupLESDebug *tokenbase,redData\tokenize
  log2PED{"Tokenbase at: " + Hex$(*tokenbase)}

  RedrawMem{}
  exitflag = 0
  end_init = -1
; ==========================================================================================================================================
.@mainloop
; ==========================================================================================================================================
  Repeat
    d_sethandler{&redData\procStatus}

    Gosub getevent

    Use Window redMessage\_WindowID

    If redMessage\_Class <> #IDCMP_IDCMPUPDATE AND redMessage\_Class <> #IDCMP_INTUITICKS AND redMessage\_Class <> #IDCMP_GADGETHELP
      ;log2PED{"handling of event: $" +  Hex$(redMessage\_Class)}
      ;RED_ShowStatusText{""}
    EndIf

    kbshift = redMessage\_Qualifier AND %11

    Select redMessage\_Class
      Case #IDCMP_MOUSEBUTTONS
        Gosub handle_MouseButtons

      Case #IDCMP_NEWSIZE
        ;Gosub handle_RefreshWindow

      Case #IDCMP_REFRESHWINDOW
        Gosub handle_RefreshWindow

      Case #IDCMP_GADGETDOWN
        If (#gadgetdown BitTst redMessage\_WindowID) Then Gosub handle_SourceGadgets

      Case #IDCMP_GADGETUP
        If redMessage\_WindowID = #_winControl Then Gosub handle_ControlGadgets
        If redMessage\_WindowID = #_winSearch  Then Gosub handle_SearchGadgets
        If redMessage\_WindowID = #_winCustom  Then Gosub handle_CustomGadgets

      Case #IDCMP_GADGETHELP
        ;-- check if we got a window, or a gadget-Pointer
        If redMessage\_IAddress <> Peek.l(Addr Window(EventWindow))
          *g.Gadget = redMessage\_IAddress
          If *g
            log2PED{"gadgethelp event for gadget at " + Hex$(*g)}
            If *g\GadgetID <> 0
              log2PED{"GadgetID: " + Hex$(*g\GadgetID)}
            EndIf
          Else
            WZ_ShowBubble{}
          EndIf
        EndIf

      Case #IDCMP_MENUHELP
        Gosub MenuHelp

      Case #IDCMP_MENUPICK
        Gosub handle_Menu

      Case #IDCMP_CLOSEWINDOW
        flag = -1
        Gosub RemoveWindow

      Case #IDCMP_ACTIVEWINDOW
        Use Window redMessage\_WindowID
        old_active_win = active_win
        active_win     = redMessage\_WindowID

      Case #IDCMP_IDCMPUPDATE
        Use Window redMessage\_WindowID
        Select WZGadName
          Case "fpr00"  : temp.l = 0 : Gosub setfpu
          Case "fpr01"  : temp = 1 : Gosub setfpu
          Case "fpr02"  : temp = 2 : Gosub setfpu
          Case "fpr03"  : temp = 3 : Gosub setfpu
          Case "fpr04"  : temp = 4 : Gosub setfpu
          Case "fpr05"  : temp = 5 : Gosub setfpu
          Case "fpr06"  : temp = 6 : Gosub setfpu
          Case "fpr07"  : temp = 7 : Gosub setfpu
        End Select

      Case #IDCMP_RAWKEY
        flag = 0
        Gosub handle_rawkey
        If flag
          redMessage\_GadgetID = flag : redMessage\_Class = #IDCMP_GADGETUP : redMessage\_WindowID = #_winControl    
          Gosub handle_ControlGadgets
        EndIf

    End Select
  Until exitflag

  Gosub FreeStuff
Return
; ====================================================================================================================
; ====================================================================================================================

;.backoff: ; jump to first buffer entry
 ; If sourceWindow\inBackBuffer
 ;   sourceWindow\inBackBuffer = 0 : *pcInfo = Peek.l(sourceWindow\bufferMem + sourceWindow\currentBufferIndex) : RED_UpdateSourceWindow{*pcInfo}
 ; EndIf
;Return

.backward:
  log2PED{"backward"}

  If sourceWindow\inBackBuffer = 0 Then sourceWindow\backBufferIndex = sourceWindow\currentBufferIndex

  sourceWindow\backBufferIndex = sourceWindow\backBufferIndex - 4 AND #buffand
  *pcInfo = Peek.l(sourceWindow\bufferMem + sourceWindow\backBufferIndex)
  If *pcInfo = 0
    If sourceWindow\inBackBuffer = 0 Then Return
    sourceWindow\backBufferIndex + 4 AND #buffand             ; restore decreased bufferindex
    t$ = "End of buffer reached!" : RED_ShowStatusText{t$}
  Else
    sourceWindow\inBackBuffer = -1 : RED_UpdateSourceWindow{*pcInfo}
  EndIf
Return

.forward:
  log2PED{"forward"}

  If sourceWindow\inBackBuffer = 0
    t$ = "Current source position reached!" : RED_ShowStatusText{t$}
  Else
    sourceWindow\backBufferIndex = sourceWindow\backBufferIndex + 4 AND #buffand
    If (sourceWindow\backBufferIndex + 4 AND #buffand) = Peek.w(?bufferput) Then sourceWindow\inBackBuffer = 0
    *pcInfo = Peek.l(sourceWindow\bufferMem + sourceWindow\backBufferIndex)
    RED_UpdateSourceWindow{*pcInfo}
  EndIf
Return


handle_SearchGadgets:
  log2PED{"handle search gadgets: "+ Str$(redMessage\_GadgetID)}

  If (Peek.l(Addr Window(#_winSearch)) = 0) Then Return

  Use Window #_winSearch
  Select redMessage\_GadgetID

    Case 2
      GTSetString 2,1, "$" + Hex$(mempointer(0))
 
    Case 3
      GTSetString 2,1, "$" + Hex$(mempointer(1))

    Case 5
      GTSetString 2,4, "$" + Hex$(mempointer(0))

    Case 6
      GTSetString 2,4, "$" + Hex$(mempointer(1))

    Case 8
      searchtype = redMessage\_Code + 1
      log2PED{"searchtype changed to " + Str$(searchtype)}

    Case 10
      Gosub SearchMemory
  End Select
Return


.handle_SourceGadgets:
  log2PED{"handle source gadgets, gadID " + Str$(redMessage\_GadgetID)}

  Use Window redMessage\_WindowID

  If redMessage\_WindowID >= #_winObject0 AND redMessage\_WindowID <= #_winObject9
    FindStructureWin{redMessage\_WindowID}
  EndIf

  Repeat
    Delay_ 1
    Select redMessage\_GadgetID

      Case #SRC_SGAD
        sourceWindow\charOffset = GetPropCurrent(#_winSource,1)

        ;If ali Then 
        RED_PrintSource{}

      Case #SRC_LGAD
        If sourceWindow\charOffset > 0
          sourceWindow\charOffset-1
          MoveProp #_winSource,#SRC_SGAD,sourceWindow\charOffset,#_winSource
          ;If ali Then 
          RED_PrintSource{}
        EndIf

      Case #SRC_RGAD
        If sourceWindow\charOffset < (250-sourceWindow\visibleColumns)
          sourceWindow\charOffset+1
          MoveProp #_winSource,#SRC_SGAD,sourceWindow\charOffset,#_winSource
          ;If ali Then 
          RED_PrintSource{}
        EndIf

      Case #MSE_SGAD
        num = GetPropCurrent(#_winMouseables,#MSE_SGAD)
        If num <> mouseables_off
          mouseables_off = num
          RedrawMouseables{False}
        EndIf

      Case #MSE_UGAD
        If mouseables_off > 0
          mouseables_off-1
          MoveProp #_winMouseables,#MSE_SGAD,mouseables_off,#_winMouseables
          RedrawMouseables{False}
        EndIf

      Case #MSE_DGAD
        h.l = (InnerHeight ASR 3)
        If mouseables_off < (num_mouseables-h)
          mouseables_off+1
          MoveProp #_winMouseables,#MSE_SGAD,mouseables_off,#_winMouseables
          RedrawMouseables{False}
        EndIf

      Case #OBJ_SGAD
        If objwins()\is_bbobject
          a = GetPropCurrent(redMessage\_WindowID,#OBJ_SGAD)
          If a <> objwins()\tracenum
            objwins()\tracenum = a
            Gosub RefType
          EndIf
        EndIf

      Case #OBJ_UGAD
        If objwins()\is_bbobject
          If objwins()\tracenum > 0
            objwins()\tracenum-1
            Gosub RefType2
            Delay_ 2
          EndIf
        EndIf

      Case #OBJ_DGAD
        If objwins()\is_bbobject
          If objwins()\tracenum < (objwins()\maxobject-1)
            objwins()\tracenum+1
            Gosub RefType2
            Delay_ 2
          EndIf
        EndIf

      Case #ARR_YGAD
        n = GetPropCurrent(#_winArray,#ARR_YGAD)
        If n <> yarrayoff
          yarrayoff = n
          RedrawArray{2}
        EndIf

      Case #ARR_XGAD
        n = GetPropCurrent(#_winArray,#ARR_XGAD)
        If n <> xarrayoff
          xarrayoff = n
          RedrawArray{2}
        EndIf

      Case #ARR_UGAD ; up
        If yarrayoff > 0
          yarrayoff-1
          RedrawArray{1}
        EndIf

      Case #ARR_DGAD ; down
        If yarrayoff < array2-yarraynum
          yarrayoff+1
          RedrawArray{1}
        EndIf

      Case #ARR_LGAD ; left
        If xarrayoff > 0
          xarrayoff-1
          RedrawArray{1}
        EndIf

      Case #ARR_RGAD ; right
        If xarrayoff < array1-xarraynum
          xarrayoff+1
          RedrawArray{1}
        EndIf

    End Select
  Until (redMessage\_Gadget\Flags AND #GFLG_SELECTED) = 0

Return


RefType2:
  MoveProp redMessage\_WindowID,#OBJ_SGAD,objwins()\tracenum,redMessage\_WindowID
  RefType:
  a = objwins()\tracenum
  objwins()\typepointer = objwins()\objbaseadr+(a*objwins()\type_sizeof)
  WTitle "Newtype: "+objwins()\t+" #"+Str$(a)+"/"+Str$(objwins()\maxobject-1)
  RefreshTypeWindow{}
Return


.handle_ControlGadgets:
  log2PED{"handle control gadgets, gadID " + Str$(redMessage\_GadgetID)}

  Select redMessage\_GadgetID

    Case 1 ;**STOP**
      CNIF #test = 0
        If dstatus <> #STOPPED Then !debuglib_Call{1}
        stepcnt = 0
      CEND

    Case 2 ;**STEP**
      If redData\asmStep
        CacheClearU_
        ad    = Peek.l(MyBufferAddress)
        pc.l  = Peek.l(ad+64)
        st1.l = FindBreakPoint{pc}

        If st1
          bd1.l = st1-breakpoint_adr
          temp  = Peek.w (bd1+?breakstore)
          Poke.w pc-2,temp
        EndIf
        If Peek.w (pc-2) = #opcode_TRAP1
          pc = pc+10
        Else
          Poke.l ad+64,pc-10
        EndIf

        pc-2
        temp$     = DisAssemble$(pc)
        ad        = pc+InstrSize
        temp      = Peek.w (pc)
        adtemp2.l = 0
        adtemp.l  =  0

        If temp = #opcode_JSR Then ad = Peek.l (pc+2)  ; jsr $xxx
        If skip.l AND temp = #opcode_JSR Then ad = pc+6  ; skip jsr
        If temp >= $6000 AND temp <= $6f00       ; bcc bra bsr
          If (temp AND $ff) = $ff                ; 32bit
            ad      = pc+Peek.l(pc+2)+2
            adtemp2 = pc+6
          Else
            If temp AND %00000000 11111111
              ad      = pc+Peek.b(pc+1)+2        ; 8 bit
              adtemp2 = pc+2
            Else
              ad      = pc+Peek.w(pc+2)+2        ; 16 bit
              adtemp2 = pc+4
            EndIf
          EndIf
        EndIf
        If skip AND temp = $6100 Then ad = pc+4 : adtemp2 = 0 ; skip bsr
        If temp = #opcode_RTS Then ad = Peek.l(MyBufferAddress) : ad = Peek.l (ad+60) : ad = Peek.l(ad) ; rts
        If temp = #opcode_JMP Then ad = Peek.l(pc+2)
        temp1.l = temp AND %11110000 11111000 ; dbxx
        If temp1 = %01010000 11001000
          If skip
            ad = pc+4
          Else
            ad = pc+Peek.w(pc+2)+2 : adtemp2 = pc+4
          EndIf
        EndIf
        brk1.l = FindBreakPoint{ad+2}
        If brk1
          brk2.l = Peek.l(brk1+4)
          Poke.l brk1+4,$00010000
          Goto _nobreak
        EndIf
        temp = Peek.w (ad)
        Poke.w ad,#opcode_TRAP1
        adtemp = ad
        typ.w  = #break_simple
        Gosub addbreakpoint_quiet

       _nobreak
        If adtemp2
          ad    = adtemp2
          temp1 = Peek.w (adtemp2)
          Poke.w adtemp2,#opcode_TRAP1
          typ.w = #break_simple
          Gosub addbreakpoint_quiet
        EndIf
        sourceWindow\currentLine = 0
        sourceWindow\inBackBuffer = 0
        Gosub refreshSourceWindow : ali = 0 : lt$ = ""

        Forbid_
         CacheClearU_
         prtcode = 0 : dstatus = #RUNNING : statego = 0
        Permit_

        Signal_ exetask,signalset
         ;Delay_(2)
        CacheClearU_
         Delay_(2)
        If adtemp
          ad = FindBreakPoint{adtemp+2}
          If ad Then Gosub deletebreakpoint
          Poke.w adtemp,temp
        EndIf
        If adtemp2
          ad = FindBreakPoint{adtemp2+2}
          If ad Then Gosub deletebreakpoint
          Poke.w adtemp2,temp1
        EndIf
        If st1
          Poke.w (Peek.l (st1)-2),#opcode_TRAP1
        EndIf
        If brk1
          Poke.l brk1+4,brk2
        EndIf
        CacheClearU_
        Goto _nostep
      EndIf
      If dstatus = #STOPPED
        flag = 0
        If redData\gosubStatus OR skip = 1
          ad   = Peek.l(MyBufferAddress)
          pc.l = Peek.l(ad+64)
          If Peek.w(pc+8) = #opcode_JSR         ; JSR
            If Peek.l(pc+8+6) = $3f3c6753 ; MOVE.w #$6753,-(a7)
              ad    = pc+Peek.w(pc+6)-2   ; calc next instruction addr
              typ.w = #break_simple
              Gosub addbreakpoint_quiet
              CacheClearU_
                                          ; *** STEP GOSUB ***
              If flag AND (dstatus OR skip)
                sourceWindow\currentLine = 0
                sourceWindow\inBackBuffer = 0
                Gosub refreshSourceWindow : ali = 0 : lt$ = ""
                Forbid_
                 prtcode = 0 : dstatus = #RUNNING : statego = 0
                Permit_
              Else
                flag = 0
              EndIf
            EndIf
          EndIf
        EndIf
        If flag = 0
          If (redMessage\_Qualifier AND %1000)
            stepnumber = RTEZGetLongRange(redData\appTitle,"# commands to step:",0,1000,stepnumber)
            If stepnumber
              stepcnt+stepnumber
              flag = 1
            EndIf
          Else
            stepcnt+1
            flag = 1
            ; // CHECK AUTOEVAL!
            If autoeval
              evalrequest = #_autoevalresult
              d_eval{autoeval$,#NOSIGNAL}
            EndIf
          EndIf
        EndIf
        If flag Then Signal_ exetask,signalset
      EndIf

     _nostep

    Case 3 ;**SKIP**
      If dstatus = #STOPPED
        !debuglib_Call{8} : stepcnt+1
        Signal_ exetask,signalset
      EndIf

    Case 4 ;**TRACE**
      Forbid_
       dstatus = #TRACE : statego = -1
      Permit_
      Signal_ exetask,signalset

    Case 5 ;**RUN**
      If dstatus
        sourceWindow\currentLine = 0
        sourceWindow\inBackBuffer = 0
        Gosub refreshSourceWindow : ali = 0 : lt$ = ""
        Forbid_
         prtcode = 0 : dstatus = #RUNNING : statego = 0
        Permit_
        Signal_ exetask,signalset
      EndIf

    Case 6 ;**<<**
      If dstatus = #STOPPED Then Gosub backward

    Case 7 ;**>>**
      If dstatus = #STOPPED Then Gosub forward

    Case 8 ;**execute**
      ex$ = RTEZGetString(redData\appTitle,"Execute...",128,ex$)
      Gosub storefpuregs
      If ex$ Then d_exec{ex$}
      Delay_(2)
      Gosub restorefpuregs

    Case 9 ;**evaluate**
      eval$ = RTEZGetString(redData\appTitle,"Evaluate...",128,eval$)
      Gosub storefpuregs
      If eval$ Then d_eval{eval$,#SIGNAL}
      Delay_(2)
      Gosub restorefpuregs

    Case 10 ;**BLITZ GADGET**
      CNIF #test = 0
        If dstatus = #STOPPED
          If pmode <> 0
            GTDisable #_winControl,10
            execrequest = #_viewblitz
            d_exec{"Mousewait"}
            dstatus = #BLITZMODE
          Else
            reply = RTEZRequest(redData\appTitle,"   Not in BLITZ mode   ","_Abort")
          EndIf
        EndIf
      CEND

    Case 11 ;**REGISTER WINDOW**
      If winstatus(#_winRegisters) = 0
        NewWindow{#_winRegisters}
        InitRegsWin{}
        RedrawRegs{}
      Else
        DelWindow{#_winRegisters}
      EndIf

    Case 12 ;**MEM WINDOW 1**
      If winstatus(#_winMemory1) = 0
        NewMemWindow{#_winMemory1}
        dowin = 0
        RedrawMem{}
      Else
        DelWindow{#_winMemory1}
      EndIf

    Case 13 ;**MEM WINDOW 2**
      If winstatus(#_winMemory2) = 0
        NewMemWindow{#_winMemory2}
        dowin = 1
        RedrawMem{}
      Else
        DelWindow{#_winMemory2}
      EndIf

    Case 14 ;**VARIABLE WINDOW**
      If winstatus(#_winVariables) = 0
        NewWindow{#_winVariables}
        RedrawVarWindow{}
        UpdateVarWindow{}
      Else
        DelWindow{#_winVariables}
      EndIf

    Case 15 ;**DISASM WINDOW**
      If winstatus(#_winDisAsm) = 0
        NewWindow{#_winDisAsm}
        UpdateDisAsm{}
      Else
        DelWindow{#_winDisAsm}
      EndIf

    Case 16 ;**COPPER WINDOW**
      If winstatus(#_winDisCop) = 0
        NewWindow{#_winDisCop}
        UpdateDisCop{}
      Else
        DelWindow{#_winDisCop}
      EndIf

    Case 17
      redData\gosubStatus = GTStatus(#_winControl,17)

    Case 18
      redData\procStatus = GTStatus(#_winControl,18)
      MOVE.w  #0,proccount

    Case 19
      redData\blitzControl = GTStatus(#_winControl,19)

  End Select
     ;redData\procStatus  = oldprocstatus
     ;redData\gosubStatus = oldgosubstatus
Return


.handle_CustomGadgets:
  log2PED{"handle custom gadgets, gadID  " + Str$(redMessage\_GadgetID)}

  a$ = GTGetString(3,0)
  b$ = GTGetString(3,1)
  If a$ = "" AND redMessage\_GadgetID = 0 Then Return
  If b$ = "" AND redMessage\_GadgetID = 1 Then Return
  ad = Vallong("$" + a$)
  b$ = UCase$(b$)

  If redMessage\_GadgetID = 0
    If (ad AND 1)
      a$ = "<ILLEGAL>"
    Else
      If ad > $dff000 Then ad-$dff000
      b$ = GetCustomReg(ad)
      a$ = Hexw$(ad)
      If b$ = "" Then b$ = "<UNKNOWN>"
    EndIf
  Else
    ad = GetCustomRegAdr(b$)
    If ad = -1
      a$ = "<UNKNOWN>"
    Else
      a$ = Hexw$(ad)
    EndIf
  EndIf
  GTSetString 3,0,a$
  GTSetString 3,1,b$
Return


;-- Get variable details from user and initialise a search for
;-- the variable (using EVAL)
.GetNewVariable: ; add vartrace
  Gosub GetVariableNameAndType    ; moved code to subroutine  tomsmart1 2016 02 14
  
  If na$ <> ""                    ; check if we get a name
    If nt > 0 AND nt < 7          ; check variable type
      If nt = 4
        nf = RTEZRequest(varfollow$,"Show string length and maxlen?:","_No|_Yes|_Cancel")
      EndIf
    Else
      nf = 1
    EndIf
    
    If nt <> 0 AND nf <> 0
      AddLast varinfo()
      varinfo()\name    = na$
      varinfo()\address = 0
      varinfo()\typ     = nt
      varinfo()\form    = nf-1
      CNIF #test = 0
        d_eval{"&" + na$, #SIGNAL}
        evalrequest = #_variablelocate
      CEND
    EndIf
  EndIf
Return


;n$ = string which should be something like: d0=<val>
.ParseRegs:
  flag = 0
  b$   = UCase$(Left$(n$,1))
  num = 0
  If Mid$(n$,3,1) = "="
    If b$ = "D" OR b$ = "A"
      num = Vallong(Mid$(n$,2,1))
      If b$ = "A" AND num = 7
        num  = -1
        flag = 1
        reply = RTEZRequest(redData\appTitle,"Cannot modify register a7","_Abort")
      EndIf
      If num >= 0 AND num < 8
        a$ = Mid$(n$,4)
        If Len(a$) = 6 AND Left$(a$,1) = Chr$(34) AND Right$(a$,1) = Chr$(34)
          si = Cvl(Mid$(a$,2,4))
        Else
          si = Vallong(a$)
        EndIf
        If b$ = "A" Then num+8
        flag = -1
      EndIf
    EndIf
  EndIf
  If flag = 0
    reply = RTEZRequest(redData\appTitle,"Malformed argument string","_Abort")
  EndIf
Return


.handle_MouseButtons:
  log2PED{"Mousebutton " + Hexw$(redMessage\_Code) + " " + Hexw$(redMessage\_Qualifier)}

  If (Peek.l(Addr Window(redMessage\_WindowID)) = 0) Then Return

  If (redMessage\_Code AND #IDCMP_REQSET) <> 0 Then Return

  If (redMessage\_Qualifier AND #IEQUALIFIERB_MIDBUTTON) <> 0
    If redMessage\_WindowID = #_winMemory2
      If redMessage\_Qualifier AND (#IEQUALIFIER_LALT|#IEQUALIFIER_RALT)
        JSR memhistoryup : Delay_(10)
      EndIf
      If redMessage\_Qualifier AND $c0 ;  (#IEQUALIFIER_LCOMMAND|#IEQUALIFIER_RCOMMAND)
        JSR memhistorydown : Delay_(10)
      EndIf
    EndIf
    If redMessage\_WindowID = #_winDisAsm
      If redMessage\_Qualifier AND  (#IEQUALIFIER_LALT|#IEQUALIFIER_RALT)
        JSR historyup : Delay_(10)
        FlushEvents
      EndIf
      If redMessage\_Qualifier AND $c0 ;  (#IEQUALIFIER_LCOMMAND|#IEQUALIFIER_RCOMMAND)
        JSR historydown : Delay_(10)
        FlushEvents
      EndIf
    EndIf

    Return
  EndIf

  Use Window redMessage\_WindowID

  wx = WMouseX - sourceWindow\boxLeft
  wy = WMouseY - sourceWindow\boxTop
  wfonth.w = WinFontHeight

  Select ActiveWindow
  Case Peek.l (Addr Window (#_winSource))
      Use Window #_winSource
      xpos.l = WMouseX - WLeftOff
      ypos.l = WMouseY - WTopOff
      log2PED{"click in source window at " + Str$(xpos) + "," + Str$(ypos)}

      If xpos => 0 AND xpos < InnerWidth AND ypos > 2 AND ypos < InnerHeight
        ypos + 1
        ypos = ypos / WinFontHeight
        *ptr.l = (.l)&textBuffer(ypos)
        If *ptr
          xpos = TextFit(textBuffer(ypos), xpos)
          Gosub getterm
        Else
          part$ = ""
        EndIf

        If Left$(part$,8) = "OPTIMIZE" Then part$ = "not support"
        If Left$(part$,8) = "SYNTAX" Then part$ = "not support"
        If Left$(part$,1) = "\" Then part$ = path$ + poin$ + part$
        If poin$ Then part$ = poin$ + part$
        If part$ <> ""
          log2PED{"evaluating '" + part$ + "'"}
          ;Gosub storefpuregs
          d_eval{part$, #SIGNAL}
          Delay_(2)
          ;Gosub restorefpuregs
        EndIf

        eval$ = part$
        Use Window currentwin.l
        log2PED{"end of source window mb handling"}
      EndIf

  Case Peek.l (Addr Window (#_winMemory2))
      Use Window #_winMemory2
      ev     = Event
      xpos.l = WMouseX-WLeftOff
      ypos.l = WMouseY-WTopOff
      memvalueStrpos.l = TextLength_(RastPort(#_winMemory2),&memStr(0),10)  ; get the x startposition
      If (xpos > memvalueStrpos) AND (xpos < InnerWidth) AND (ypos > 0) AND (ypos < InnerHeight)
        xpos   - memvalueStrpos
        ypos   = ypos/WinFontHeight
        xpos   = TextFit(memStr(ypos),xpos)
        *ptr.l = (.l)&memStr(ypos)
        If *ptr
          Gosub getterm
        Else
          part$ = ""
        EndIf
        If part$ <> ""
          JSR addmemhistory
          ConvToPostFix part$,&evalbuffer$
          temp = PFEvaluate(Peek.s(&evalbuffer$))
          If PFErrorType = 0
            mempointer(1) = temp
            RedrawMem{}
            WTitle part$
            Delay_ 10
          EndIf
        EndIf
      EndIf
      Use Window currentwin.l

  Case Peek.l (Addr Window (#_winDisAsm) )
    If redData\osType = #AmigaOS3
      Use Window #_winDisAsm
      xpos = WMouseX-WLeftOff ; left border
      ypos = WMouseY-WTopOff  ; top border
      disasmStrpos.l = TextLength_(RastPort(#_winDisAsm),&disStr(1),18)  ; get the x startposition of the DisAsm string
      If (xpos > disasmStrpos) AND (xpos < InnerWidth) AND (ypos > 0) AND (ypos < InnerHeight)
        ; calculate the position
        xpos - disasmStrpos               ; calc the mouse x position of the disasmstring
        ypos = ypos/WinFontHeight         ; calc the line of the string by the mouse y
        xpos = TextFit(disStr(ypos),xpos) ; get the charnumber positionen of string
        If xpos < 8 Then xpos = 8         ; to prevent a false detection on the asm command
        *ptr = (.l)&disStr(ypos)          ; get the pointer of the string
        If *ptr
          Gosub getterm    ; need xpos and i
        Else
          part$ = ""
        EndIf
        If part$ <> ""
          If Left$(part$,1) <> "#"       ; test if we have a address and no value
            part2$ = Replace$ (part$,"(","+")
            If part2$ <> part$
              part$ = Left$(part2$,Len(part2$)-4)
              If Left$(part$,1) <> "-" Then part$ = "+"+part$
              part2$ = Mid$(part2$,Len(part2$)-2,2)
              part$ = part2$+part$
            EndIf
            WTitle part$

            ConvToPostFix part$,&evalbuffer$
            temp = PFEvaluate(Peek.s(&evalbuffer$))
            If PFErrorType = 0
              ev = Event
              If redMessage\_Qualifier AND $30
                JSR addhistory
                disasm_ad = temp
                UpdateDisAsm{}
                Delay_(20)
              Else
                If winstatus(#_winMemory2) = 0 Then NewMemWindow{#_winMemory2}
                mempointer(1) = temp
                RedrawMem{}
              EndIf
            EndIf
            Use Window currentwin
          EndIf
        EndIf
      EndIf
    EndIf
  End Select

  Select redMessage\_WindowID
  Case #_winDisAsm
    If disasm_ad > 4096
      xwidth.l = TextLength_(RastPort(#_winDisAsm),"$12345678",9)
      If (wx > xwidth) AND (wy >= 0) AND (wy < InnerHeight)
        wy/wfonth
        ad = disasm_ad
        While wy > 0
          If Peek.w(ad) = #opcode_TRAP1 AND Peek.w(ad+Peek.w(ad+8)) = #opcode_TRAP1
            ad+10
          Else
            ad2 = FindBreakPoint{ad+2}
            If ad2
              Poke.w ad,Peek.w((ad2-breakpoint_adr)+?breakstore)
            EndIf
            a$ = DisAssemble$(ad)
            If ad2
              Poke.w ad,#opcode_TRAP1
            EndIf
            ad+InstrSize
          EndIf
          wy-1
        Wend
        If (Peek.w(ad) = #opcode_TRAP1 OR redData\asmStep) AND (WMouseX < xwidth+TextLength_(RastPort(#_winDisAsm),"12345678",8) AND WMouseX > xwidth) ; only add breakpoint in range
          flag = 0
          ad2 = FindBreakPoint{ad+2}
          If ad2
            a = RTEZRequest(redData\appTitle,"Change or delete breakpoint?","C_hange|_Delete|_Cancel")
            If a <> 1 Then flag = -1
            If a = 2
              ad = ad2
              Gosub deletebreakpoint
            EndIf
          EndIf

          If flag = 0
            Gosub addbreakpoint
          EndIf
        EndIf
      EndIf

      flag = 1
    EndIf

  Case #_winRegisters 
    If dstatus = #STOPPED
      If (wx > 0) AND (wy > 0) AND (wy < InnerHeight)
        xwidth = TextLength_(RastPort(#_winRegisters)," ",1)
        wx / xwidth  ; calc char position
        wy / wfonth  ; calc line position
        If (wy < 8)
          flag = 0
          num  = wy
          ; check for data register
          If (wx < 12) Then flag = 1 : a$ = "d"
          ; check for address register
          If (wx > 19) AND (wx < 32) Then flag = 2 : a$ = "a"
          If flag
            CNIF #test = 0
              ad = Peek.l(MyBufferAddress)
              ad+(num ASL 2)+(flag-1)*32
              si = Peek.l(ad)
              If redMessage\_Qualifier AND 3
                n$ = ""
                If winstatus(#_winMemory2) = 0 Then NewMemWindow{#_winMemory2}
                mempointer(1) = si
                RedrawMem{}
                Goto _novalue
              EndIf
              n$ = RTEZGetString("Register value",Peek.s(?setregvalue),20,a$+Str$(num)+"=$"+Hex$(si))

            _novalue
              If n$
                Gosub ParseRegs
                If flag = -1
                  ad = Peek.l(MyBufferAddress)+(num ASL 2)
                  Poke.l ad,si
                  RedrawRegs{}
                EndIf
              EndIf
            CEND
          EndIf
        EndIf
        ; check for programcounter
        If (wy = 8) AND (wx > 18) AND (wx < 32)
          .setprogramcounter
          ad = Peek.l(MyBufferAddress)
          si = Peek.l(ad+64)
          n$ = RTEZGetString("Programcounter value",Peek.s(?setregvalue),20,"$"+Hex$(si-2))
          If n$
            Poke.l ad+64,Vallong(n$)+2
            RedrawRegs{}
            UpdateDisAsm{}
          EndIf
        EndIf

      EndIf
    EndIf

  Case redMessage\_WindowID = #_winMouseables
    If num_mouseables AND evalrequest = 0
      wy = wy ASR 3
      If wx >= 0 AND wx < InnerWidth AND wy >= 0 AND wy < (InnerHeight ASR 3)
        wy+mouseables_off
        If wy < num_mouseables
          ad = mouseables
          While wy
            ad = Peek.l(ad)
            wy-1
          Wend
          a$ = ExtractLabel(Peek.l(ad+4))
          If old_active_win <> #_winMouseables
            Activate old_active_win
            evalrequest   = #_mouseable_eval
            evalrequestex = old_active_win
            d_eval{"?" + a$,#SIGNAL}
          EndIf
        EndIf
      EndIf
    EndIf

  Default
    If (redMessage\_WindowID >= #_winObject0) AND (redMessage\_WindowID <= #_winObject9)
      y.l = wy-8
      x.l = wx
      FindStructureWin{redMessage\_WindowID}
      If objwins()\is_bbobject = 0 AND y >= 0 AND x >= typewidth-4
        ad = GetStructVal{y ASR 3}
        If ad <> -1
          reply = RTEZRequest(redData\appTitle,"Move to location $"+Hex$(ad),"_Okay|_Cancel")
          If reply = 1
            objwins()\typepointer = ad
            RefreshTypeWindow{}
          EndIf
        EndIf
      EndIf
    EndIf
  End Select
Return


.handle_rawkey:
  num = 1
  If kbshift
    Use Window redMessage\_WindowID
    num = InnerHeight ASR 6
  EndIf

  Select redMessage\_Code

    Case #RAWKEY_F
      d_exec{"dbl_flip {}"}

    Case #RAWKEY_P
      If redMessage\_WindowID = #_winDisAsm
        ad        = Peek.l(MyBufferAddress)
        ad.l      = Peek.l(ad+64)
        disasm_ad = ad - 2
        UpdateDisAsm{}
      EndIf

    Case #RAWKEY_B
      If redMessage\_WindowID = #_winSource OR redMessage\_WindowID=#_winDisAsm
        ;If ali
          t$   = "Move To Breakpoint"
          flag = -1
          Gosub SelectBP
          If bp
            ad = breakpoint_adr
            bp-1
            ad+(bp ASL 3)
            If redMessage\_WindowID = #_winSource
              sourceWindow\currentLine = Peek.l(Peek.l(ad))
              RED_PrintSource{}
            Else
              disasm_ad = Peek.l(ad)-2
              UpdateDisAsm{}
            EndIf
          EndIf
        ;EndIf
      EndIf

    Case #RAWKEY_SPACE
      If redMessage\_WindowID = #_winMemory1 Then dowin = 0
      If redMessage\_WindowID = #_winMemory2 Then dowin = 1
      If dowin <> -1
        winnum=redMessage\_WindowID
        x = 0 : y = 0
        Gosub MemEdit
      EndIf

    Case #RAWKEY_L
      If redMessage\_WindowID = #_winMemory1 Then dowin = 0 : a$ = memlock$(0)
      If redMessage\_WindowID = #_winMemory2 Then dowin = 1 : a$ = memlock$(1)
      If redMessage\_WindowID = #_winDisAsm  Then dowin = 2 : a$ = disasmlock$
      If dowin <> -1
        flag = 0
        a$ = RTEZGetString("Lock window","Enter expression to lock onto:",80,a$)
        ConvToPostFix a$,&evalbuffer$
        ad = PFEvaluate(Peek.s(&evalbuffer$))
        If PFErrorType
          reply = RTEZRequest("Lock window","Malformed argument","_Okay")
        Else
          If redMessage\_WindowID <> #_winDisAsm
            If a$ <> "" Then mempointer(dowin) = ad
            memlock$(dowin) = a$
            memlockpf$(dowin) = Peek.s(&evalbuffer$)
            Domemtitle{dowin}
            RedrawMem{}
          Else
            If a$ <> "" Then disasm_ad = ad
            disasmlock$   = a$
            disasmlockpf$ = Peek.s(&evalbuffer$)
            Poke$ ?disasmlockstr,a$
            If (Peek.l(Addr Window(#_winDisAsm)))
              Use Window #_winDisAsm
              t$ = "Disassembly"
              If disasmlock$ <> "" Then t$+" ("+disasmlock$+")"
              WTitle t$
              UpdateDisAsm{}
            EndIf
          EndIf
        EndIf
      EndIf

    Case #RAWKEY_TAB
      If redMessage\_WindowID < 0 Then redMessage\_WindowID =- 1
      Repeat
        redMessage\_WindowID + 1
        If redMessage\_WindowID = #_winBackdrop Then redMessage\_WindowID+1
        If redMessage\_WindowID > (Maximum Window-1) Then redMessage\_WindowID = 0
      Until Peek.l(Addr Window(redMessage\_WindowID)) <> 0
      Activate redMessage\_WindowID
      WindowToFront_ Peek.l(Addr Window(redMessage\_WindowID))

    Case #RAWKEY_UP
      FlushEvents
      Select redMessage\_WindowID

        Case #_winSource
          flag = 0
          ;num = 1 : If kbshift Then num = sourceWindow\visibleLines
          log2PED{"num = " + Str$(num)}
          For h = 1 To num
            If sourceWindow\currentLine\previousLine
              sourceWindow\currentLine = sourceWindow\currentLine\previousLine
            EndIf
          Next h
          RED_PrintSource{}

        Case #_winMemory1
          flag = -1 : dowin = 0 : Gosub Movemem

        Case #_winMemory2
          flag = -1 : dowin = 1 : Gosub Movemem

        Case #_winDisAsm
          ;If kbshift Then disasm_ad-20
          For h = 1 To num
            offset.l = 0
            Repeat
              offset+2
            Until (DisAssemble$(disasm_ad-offset) <> "?????" AND InstrSize = offset) OR offset = 8
            If offset = 8 Then offset = 2
            disasm_ad-offset
          Next h
          UpdateDisAsm{}

        Case #_winDisCop
          discop_ad-(num ASL 2)
          UpdateDisCop{}

      End Select

    Case #RAWKEY_DOWN
      FlushEvents
      Select redMessage\_WindowID

        Case #_winSource
          flag = 0
          ;num = 1 : If kbshift Then num = sourceWindow\visibleLines
          log2PED{"num = " + Str$(num)}
          For h = 1 To num
            If sourceWindow\currentLine\nextLine
              sourceWindow\currentLine = sourceWindow\currentLine\nextLine
            EndIf
          Next h
          RED_PrintSource{}

        Case #_winMemory1
          flag = 1 : dowin = 0 : Gosub Movemem

        Case #_winMemory2
          flag = 1 : dowin = 1 : Gosub Movemem

        Case #_winDisAsm
          ;If kbshift Then disasm_ad+20
          For h = 1 To num
            If Peek.w(disasm_ad) = #opcode_TRAP1
              disasm_ad+10
            Else
              a$ = DisAssemble$(disasm_ad)
              If a$ <> "?????"
                disasm_ad+InstrSize
              Else
                disasm_ad+2
              EndIf
            EndIf
          Next h
          UpdateDisAsm{}

        Case #_winDisCop
          discop_ad+(num ASL 2)
          UpdateDisCop{}
      End Select

    Case #RAWKEY_LEFT
      If redMessage\_WindowID = #_winMemory1 Then jump = 1 : flag = -1 : dowin = 0 : Gosub _doMovemem
      If redMessage\_WindowID = #_winMemory2 Then jump = 1 : flag = -1 : dowin = 1 : Gosub _doMovemem

    Case #RAWKEY_RIGHT
      If redMessage\_WindowID = #_winMemory1 Then jump = 1 : flag = 1 : dowin = 0 : Gosub _doMovemem
      If redMessage\_WindowID = #_winMemory2 Then jump = 1 : flag = 1 : dowin = 1 : Gosub _doMovemem

    Case #RAWKEY_ESC
      CNIF #test = 1
        exitflag = 1
      CELSE
        d_quit{}
      CEND

    Case #RAWKEY_M
      Select redMessage\_WindowID

        Case #_winMemory1
          cur.l = 0
          If kbshift
            lt$ = lasteval$
          EndIf
          Gosub goto_MemWindow

        Case #_winMemory2
          cur = 1
          If kbshift
            lt$ = lasteval$
          EndIf
          Gosub goto_MemWindow

        Case #_winDisAsm
          evalrequest = #_disasmaddress
          If redMessage\_Qualifier AND $8
            startcode.l = sourceWindow\startCode
            !ComData_GetL{comPtr_CurrentSourceLine,D0} : temp45.l = PutRegD0

            MOVE.l programstart,a0 : MOVE.l a0,a1 : ADD.l programsize,a1

           _pg2
            CMP.w ##opcode_TRAP1,(a0)+ : BNE _pg3
            MOVE.l (a0),d1
            AND.l #$80000000,d1
            BEQ _noe
            MOVE.l (a0),d1 : AND.l #$7fffffff,d1 : ADD.l startcode@(a5),d1
            MOVE.l d1,a3
            MOVE.l temp45@(a5),a2
            LEA 9(a2),a2
            LEA 9(a3),a3
            MOVEQ #0,d0
            MOVE.b -1(a2),d0
            ADDQ.l #4,a0

           _l1
             CMPM.b (a2)+,(a3)+
             BNE _pg3
            DBF d0,_l1

           BRA _pg4

           _noe
            CMP.l (a0)+,d0
            BEQ _pg4

           _pg3
            CMP.l a0,a1
            BGT _pg2
           BRA _pg5

           _pg4
            MOVE.l a0,d0
            SUBQ.l #6,d0
            disasm_ad = PutRegD0
            UpdateDisAsm{}

           _pg5
          Else
            Gosub goto_disassemble
          EndIf

        Case #_winDisCop
          evalrequest = #_discopaddress
          Gosub goto_disassemble

        Default
          If redMessage\_WindowID >= #_winObject0 AND redMessage\_WindowID <= #_winObject9
            Gosub goto_objectwin
          EndIf

      End Select

    Case #RAWKEY_HELP ; help key
      If wininfo(redMessage\_WindowID)\helplink
        a$ = Peek.s(wininfo(redMessage\_WindowID)\helplink)
        ShowHelp{a$}
      EndIf

    ;-- invoke GADGET EVENT ?
    Case #RAWKEY_S
      flag        = 2
      skip.l      = 0
      redData\gosubStatus = 0
      redData\procStatus  = 0
      FlushEvents

    Case #RAWKEY_D
      flag        = 2
      skip        = 1
      redData\gosubStatus = 1
      redData\procStatus  = 1
      FlushEvents

    Case #RAWKEY_I : flag = 3
    Case #RAWKEY_T : flag = 4
    Case #RAWKEY_R : flag = 5
    Case #RAWKEY_SMALLER : flag = 6
    Case #RAWKEY_GREATER : flag = 7
    Case #RAWKEY_X : flag = 8
    Case #RAWKEY_E : flag = 9
    Case #RAWKEY_V : flag = 10
  End Select

Return


.GetAddress:
goto_MemWindow:
  If kbshift = 0
    strg$ = "$"+Hex$(mempointer(cur))
    lt$   = strg$
    strg$ = RTEZGetString("Memory location","Enter address to jump to:",40,strg$)
  Else
    strg$ = lt$
  EndIf
  If strg$
    evalrequest   = #_memwindow
    evalrequestex = cur
    ;d_eval{strg$,#SIGNAL}
    ConvToPostFix strg$,&evalbuffer$
    mempointer(cur) = PFEvaluate(Peek.s(&evalbuffer$))
    RedrawMem{}
  Else
    evalrequest = 0
  EndIf
Return


goto_disassemble:
  If kbshift = 0
    strg$ = "$"+Hex$(disasm_ad)
    lt$   = strg$
    strg$ = RTEZGetString("Set location","Enter base address:",40,strg$)
  Else
    strg$ = lt$
  EndIf
  If strg$
    If evalrequest <> #_discopaddress
    ConvToPostFix strg$,&evalbuffer$
    disasm_ad=PFEvaluate(Peek.s(&evalbuffer$))
   UpdateDisAsm{}
   Else
    d_eval{strg$,#SIGNAL}
   EndIf
  Else
    evalrequest = 0
  EndIf
Return


goto_objectwin:
  FindStructureWin{redMessage\_WindowID}
  If objwins()\is_bbobject = 0
    evalrequest = #_structaddress
    PushItem objwins()
    Gosub goto_disassemble
    Return
  EndIf
  If objwins()\maxobject = 1 Then Return
  If kbshift = 0
    strg$ = RTEZGetString("Object number","Enter object number:",40,strg$)
  Else
    strg$ = lt$
  EndIf
  a.w = Vallong(strg$)
  If a < 0 OR a >= objwins()\maxobject
    reply=RTEZRequest(redData\appTitle,"Object value out of range!","  _Ok  ")
    Return
  EndIf
  objwins()\tracenum    = a
  objwins()\typepointer = objwins()\objbaseadr+(a*objwins()\type_sizeof)
  If (Peek.l(Addr Window(objwins()\winnum)))

    Use Window objwins()\winnum
    WTitle "Newtype: "+objwins()\t+" #"+Str$(objwins()\tracenum)+"/"+Str$(objwins()\maxobject-1)

    MoveProp objwins()\winnum,#OBJ_SGAD,a,objwins()\winnum

    RefreshTypeWindow{}
  EndIf
Return

.handle_Menu:
  log2PED{"handle menu " + Str$(MenuHit +  1)}
  On MenuHit + 1 Gosub domenu0, domenu1, domenu2, domenu3, domenu4
Return

.domenu0:
  Select ItemHit
    Case 0
      message.s = "Status register flags:\\0A"
      message   + "X: Extension\\0A"
      message   + "N: Negative \\0A"
      message   + "Z: Zero     \\0A"
      message   + "O: Overflow \\0A"
      message   + "C: Carry    "
      message{message}

    Case 1
      message.s = redData\appTitle + "\\0A\\0A"
      message   + "This program handles runtime errors and provides debugging\\0A"
      message   + "functions for programs compiled and run inside AmiBlitz3.\\0A"
      message   + "\\0A"
      message   + "The original version was written by Mark Sibly of ACID software.\\0A"
      message   + "An improved version has been written by Stephen McNamara of Red When Excited.\\0A"
      message   + "\\0A"
      message   + "Updated in 2002 by Bernd Roesch\\0A"
      message   + "Additional updates in 2007 by Sven Drge\\0A"
      message   + "Updates 2009-2015 by the Opensource Team\\0A"
      message   + "Further updates 2016-2024 by Sven Drge"
      message{message}

    Case 3
      message.s = "Keyboard Shortcuts \\0A\\0A"
      message   + "BREAK      - CTRL ALT C    STEP  - S\\0A"
      message   + "STEPOVER   - D  Call dbl_Flip {} - F\\0A"
      message   + "SKIP       - I             TRACE - T\\0A"
      message   + "RUN        - R             <<    - ,\\0A"
      message   + ">>         - .             EXEC  - X\\0A"
      message   + "EVAL       - E             QUIT- ESc\\0A"
      message   + "     TAB - Cycle active window      \\0A"
      message   + "\\0A"
      message   + "Whilst in some windows,\\0A"
      message   + "'m' = Enter startadress Shift+m last eval address\\0A"
      message   + "'l' = Lock Window to Register\\0A"
      message   + "'b' = show next breakpoint\\0A"
      message   + "'SPACE' in memwin allow change value(SPACE for exit)\\0A"
      message   + "ALT+LMB Jump into\\0A"
      message   + "ALT+MMB Jump to last position before ALT+LMB\\0A"
      message   + "CTRL 'm' in disasmwin show line in PED\\0A"
      message{message}

    Case 5
      Gosub UpdatePrefs
      SavePrefs{*prefsPtr.l, prefsSize}

    Case 6
      Gosub doscreenmode

    Case 7
      Gosub dowindowheight

    Case 8  ; select font
      aslfo_SetRequesterTitle {"Please select Source-Font:","",""} ; changed to asl font requester  tomsmart1 2016 03 01
      aslfo_SetInitialFont{prefs\fontname,prefs\fontsize}
      If aslfo_Request{False}  ; only nonproportionalfonts are allowed
        prefs\fontname = aslfo_GetFontName{}
        prefs\fontsize = aslfo_GetFontSize{}
        message{"Choose Menu Save configuration or quit and restart debugger","Save prefs and restart debugger"}
;         reply = GTMenuChecked(0,0,8)
;         If reply <> redData\tokenize
;           If reply Then redData\tokenize=1 Else redData\tokenize = 0
;           redData\tokenize = 1
;           SetupLESDebug *tokenbase,redData\tokenize
;             Use Window #_winSource
;               w.w  = InnerWidth
;               hi.w = InnerHeight
;               ;Boxf 0,0,w,hi,0
;             ;InnerCls
;             Gosub wprint
;           If winstatus(#_winDisAsm)
;             Use Window #_winDisAsm
;             ;InnerCls
;               w.w  = InnerWidth
;               hi.w = InnerHeight
;               ;Boxf 0,0,w,hi,0
;               UpdateDisAsm{}
;
;           EndIf
;           sourceWindow\inBackBuffer = 0 :   RED_UpdateSourceWindow{*pcInfo}
;         EndIf
      EndIf

    Case 9
      redData\showLineNumbers = GTMenuChecked(0,0,9)
      Gosub newsizeSourceWindow
      Gosub refreshSourceWindow

    Case 10
      redData\showSyntaxHelp = GTMenuChecked(0,0,10)
      Gosub newsizeSourceWindow
      Gosub refreshSourceWindow

    Case 11
      redData\logging = GTMenuChecked(0,0,11)

    Case 12
      CNIF #test = 1
        exitflag = 1
      CELSE
        d_quit{}
      CEND

    Case 13
      message.s = "Perform a hard quit?\\0A"
      message   + "Warning: The Debug process itself will not exit."
      reply = ask{message,"_Quit|_Cancel",redData\appTitle}
      If reply Then exitflag = 1

  End Select
Return


.domenu1:
  If ItemHit < 9
    redMessage\_Class  = #IDCMP_GADGETUP
    redMessage\_WindowID = #_winControl
    redMessage\_GadgetID = ItemHit + 11
    i$  = ""
    If redMessage\_GadgetID = 17 Then GTToggle #_winControl,17
    If redMessage\_GadgetID = 18 Then GTToggle #_winControl,18
    If redMessage\_GadgetID = 19 Then GTToggle #_winControl,19
    Gosub handle_ControlGadgets
  Else
    Select ItemHit

      Case 10
        If winstatus(#_winSearch) = 0
          NewWindow{#_winSearch} : AttachGTList 2,#_winSearch
        Else
          DelWindow{#_winSearch}
        EndIf

      Case 11
        array$ = RTEZGetString("Arrays","Enter array name:",80)
        If array$ <> ""
          a   = Instr(array$,"(")
          b.l = Instr(array$,",")
          c.l = Instr(array$,")")
          If b = 0
            array1 = 0
            array2 = Vallong(Mid$(array$,a+1,c-1))
          Else
            array1 = Vallong(Mid$(array$,a+1,b-a-1))
            array2 = Vallong(Mid$(array$,b+1,c-b-1))
          EndIf
          array$ = Left$(array$,a-1)
          nt = RTEZRequest("Arrays","Enter variable type:","_b|_w|_l|_Cancel")
          If nt <> 0
            If array1 <> 0
              d_eval{"&"+array$+"(0,0)",#SIGNAL}
            Else
              d_eval{"&"+array$+"(0)",#SIGNAL}
            EndIf
            arrayitemsize = (2^nt)+1
            arraydatasize = nt

            If array1 > array2
              si = array1
            Else
              si = array2
            EndIf
            a$ = Hex$(si)
            If si > 255
              If si > 65535
                arraylabelsize = 4
              Else
                arraylabelsize = 2
              EndIf
            Else
              arraylabelsize = 1
            EndIf
            pos.l = 1
            While Mid$(a$,pos,1) = "0"
              pos+1
            Wend
            pos = (9-pos)+1
            If pos > arrayitemsize Then arrayitemsize = pos
            evalrequest = #_arrayfind
          EndIf
        EndIf

      Case 12
        is_bb.l = 0
        Gosub NewTypeWindow

      Case 13
        If winstatus(#_winCustom) = 0
          NewWindow{#_winCustom} : AttachGTList 3,#_winCustom
        Else
          DelWindow{#_winCustom}
        EndIf

      Case 14
        If winstatus(#_winMouseables) = 0
          NewWindow{#_winMouseables}
          RedrawMouseables{True}
        Else
          DelWindow{#_winMouseables}
        EndIf

      Case 15
        If winstatus(#fpuwin) = 0
          If wininfo(#fpuwin)\w = 0 Then wininfo(#fpuwin)\w = 539 : wininfo(#fpuwin)\h = 36
          wininfo(#fpuwin)\gadlist = -1
          WZWindow #fpuwin,?wzgui,20,wininfo(#fpuwin)\x,wininfo(#fpuwin)\y,wininfo(#fpuwin)\w,(wininfo(#fpuwin)\h * WinFontHeight)/8,1
          winstatus(#fpuwin) = -1
        Else
          DelWindow{#fpuwin}
        EndIf
        If winstatus(#_winVariables) Then UpdateVarWindow{}  ; only the values are print
        RedrawRegs{}

      Case 16
        redData\asmStep = NOT redData\asmStep

      Case 17
        If redData\watch0 = False
          If ask{"This feature bangs the address 0!","Go ahead!|Oopps!"}
            Poke $0,$beaddeef
            addr0.l  = Peek.l (0)
            redData\watch0 = NOT redData\watch0
          EndIf
        Else
          redData\watch0 = False
        EndIf
    End Select
  EndIf
Return


Statement newwizardwin{winNumber.w,num.l,wzguiPtr.l}
SHARED winstatus(),wininfo()

  If wininfo(winNumber)\w = 0 Then wininfo(winNumber)\w = 539 : wininfo(winNumber)\h = 36

  wininfo(winNumber)\gadlist = -1

  WZWindow winNumber,wzguiPtr, 20,wininfo(winNumber)\x,wininfo(winNumber)\y,wininfo(winNumber)\w,wininfo(winNumber)\h,num
  winstatus(#fpuwin) = -1
End Statement


.domenu2:
  If objectbusy = 0 AND dstatus = #STOPPED
    mytype  = ItemHit
    address = Peek.l(?MyTypes+(mytype ASL 2))
    is_bb   = -1
    Gosub NewTypeWindow
  EndIf
Return


.domenu3:   ; misc menu events
  Select ItemHit

    Case 0 ;add trace
      Gosub GetNewVariable
      If winstatus(#_winVariables) = 0
        NewWindow{#_winVariables}
      EndIf

    Case 1 ;del trace
      Gosub GetVariableNameAndType    ; changed to a subroutine call to get the type too  tomsmart1 2016 02 14
      If na$ <> ""                    ; check if we have a name
        If nt > 0 AND nt < 7          ; check id we have a type
          Gosub _Deltrace

          If a AND winstatus(#_winVariables)
            RedrawVarWindow{}
            UpdateVarWindow{}
          EndIf
        EndIf
      EndIf

    Case 2 ; del all...
      reply = RTEZRequest(varfollow$,"Clear all variables?","_Yes|_No")
      If reply = 1
        ClearList varinfo()
        If winstatus(#_winVariables) Then RedrawVarWindow{}
      EndIf

    Case 3 ; sort
      StringSort varinfo(),SizeOf.variabletype,6   ; sizeof (.l + .b + .b) added offset because i changed the layout befor so the string is on the end  tomsmart1
      If winstatus(#_winVariables)
        RedrawVarWindow{}
        UpdateVarWindow{}
      EndIf

    Case 5 ; auto eval
      autoeval = GTMenuChecked(0,3,5)
      If autoeval <> 0 AND na$ = "" Then Gosub DefAutoEval

    Case 6
      Gosub DefAutoEval

    Case 8
      a$ = RTEZGetString(redData\appTitle,"Enter breakpoint address:",10)
      If a$ <> ""
        ad = Vallong(a$)
        Gosub addbreakpoint
      EndIf

    Case 9
      t$   = "Select breakpoint to delete:"
      flag = -1
      Gosub SelectBP
      If bp
        ad = breakpoint_adr+((bp-1)ASL 3)
        Gosub deletebreakpoint
      EndIf

    Case 10
      If Peek.l(breakpoint_adr)
        a = RTEZRequest(redData\appTitle,"Kill all breakpoints?","_Okay|_Cancel")
        If a
          FillMem ?breakpoint,5*8
          If winstatus(#_winDisAsm) Then UpdateDisAsm{}
        EndIf
      EndIf

    Case 11
      t$   = "Current breakpoints:"
      flag = 0
      Gosub SelectBP
  End Select
Return


.domenu4:
  D_InitParse customcomm$(ItemHit)
  a$ = ProcessString
  Execute_ a$,0,0
Return


;ad = address
;typ = type of breakpoint (#break_?????)
;Returns: flag = 0 for error, else -1 for added okay
addbreakpoint_quiet:
  If Peek.w(ad) = #opcode_TRAP1
    ad+2
    a = typ
    If a
      ad2 = breakpoint_adr
      num = 0
      While Peek.l(ad2) <> 0
        If Peek.l(ad2) = ad
          Poke.l ad2,0
        Else
          ad2+8
          num+1
        EndIf
      Wend

      Poke.l ad2,ad
      Poke.w ad2+4,a
      If a = #break_simple Then b = 1 Else b = 0
      Poke.w ad2+6,b
      flag = -1
    EndIf
  EndIf
Return


DefAutoEval:
  na$ = RTEZGetString("Auto EVAL","Please enter string to evaluate:",80,autoeval$)
  If na$ <> ""
    autoeval$ = na$
    autoeval  = 1
  Else
    autoeval  = 0
    autoeval$ = ""
  EndIf
  GTSetMenuChecked 0,3,5,autoeval
Return


.addbreakpoint:
  If Peek.w(ad) = #opcode_TRAP1 OR redData\asmStep
    ad+2
    a = RTEZRequest(redData\appTitle,"Select a breakpoint or function:","_Permanent|C_ount|_Simple|Cnt _down|_Remove Stop|Set PC|_Cancel")
    b = 0
    If a = 4
      a$ = RTEZGetString(redData\appTitle,"Enter the counter value for this breakpoint:",20)
      b = Vallong(a$)
      If b = 0 Then a = 0
    EndIf
    If a = 6
      pc_ad.l = Peek.l(MyBufferAddress)
      Poke.l pc_ad+64,ad
      RedrawRegs{}
      UpdateDisAsm{}
      a = 0
    EndIf
    If a
      If a = 5
        Poke.w ad+8 ,#opcode_NOP
        Poke.w ad+10,#opcode_NOP
        Poke.w ad+12,#opcode_NOP
        UpdateDisAsm{} : disasm_ad = ad
        CacheClearU_
        Return
      EndIf
      ad2 = breakpoint_adr
      num = 0
      While Peek.l(ad2) <> 0 AND num < #maxbreakpoints
        If Peek.l(ad2) = ad
          Poke.l ad2,0
        Else
          ad2+8
          num+1
        EndIf
      Wend
      If num < #maxbreakpoints
        If a = #break_simple    Then b = 1
        If a = #break_countdown Then a = #break_simple
        bt1.l = ad2-breakpoint_adr
        Poke.w bt1+?breakstore,Peek.w(ad-2)
        If redData\asmStep Then Poke.w ad-2,#opcode_TRAP1
        Poke.l ad2,ad
        Poke.w ad2+4,a
        Poke.w ad2+6,b
      Else
        a = RTEZRequest(redData\appTitle,"No spare breakpoints available.","_Okay")
      EndIf
      If winstatus(#_winDisAsm) Then UpdateDisAsm{}
    EndIf
  Else
    a = RTEZRequest(redData\appTitle,"Can only breakpoint basic instructions.","_Okay")
  EndIf
Return


;ad = address of breakpoint to delete
.deletebreakpoint:
  bt1 = ad-breakpoint_adr
  Poke.w Peek.l(ad)-2,Peek.w(bt1+?breakstore)
  While Peek.l(ad) <> 0
    Poke.l ad,Peek.l(ad+8)
    Poke.l ad+4,Peek.l(ad+12)
    ad+8
  Wend
  If winstatus(#_winDisAsm) Then UpdateDisAsm{}
Return


;t$ = text to display
; Returns breakpoint number in bp (or 0 for cancel)
.SelectBP:
  a$   = ""
  b$   = ""
  ad.l = breakpoint_adr
  If Peek.l(ad) = 0
    a  = RTEZRequest(redData\appTitle,"No breakpoints defined.","_Okay")
    bp = 0
  Else
    num = 0
    While Peek.l(ad) <> 0
      num+1
      ad2 = Peek.l(ad)
      Gosub GETInstruction

      a$+"BP "+Str$(num)+": "+GetHex$(ad2-2,3)+" >>> "+Left$(d_d$,40)+Chr$(10)
      If flag Then b$+"_"+Str$(num)+"|"
      ad+8
    Wend
    If flag
      b$+"_Cancel"
    Else
      b$ = "_Okay"
    EndIf
    bp = RTEZRequest(redData\appTitle,t$+Chr$(10)+a$,b$)
  EndIf
Return


.doscreenmode:
  If SubHit < 4
    redData\screenType = SubHit
  Else
    Select SubHit

      Case 5
        *myscr.screeninfo = 0
        *myscr            = RTEZScreenModeRequest("Editor screen mode",%1000010000000000000)
        If *myscr
          If *myscr\width >= 640 AND *myscr\height >= 200
            redData\screenModeId  = *myscr\id
            redData\screenWidth  = *myscr\width
            redData\screenHeight = *myscr\height
          Else
            reply = RTEZRequest(redData\appTitle,"Minimum screen size is 640 x 200.","_Okay")
          EndIf
        EndIf

    End Select
  EndIf
  Gosub CheckScrModeMenus
Return


.CheckScrModeMenus:
  If redData\screenType = 1 OR redData\screenType = 2
    redData\usePubScreen = True
    redData\defaultPubScreen = True
  Else
    redData\usePubScreen = False
    redData\defaultPubScreen = False
  EndIf

  GTMenuState 0,0,6,6,redData\usePubScreen
  GTMenuState 0,0,6,7,redData\defaultPubScreen
Return


dowindowheight:
  a = RTEZGetLongRange(redData\appTitle,"Maximum window height:",200,1024,redData\windowMaxHeight)
  If a <> 0
    redData\windowMaxHeight = a
  EndIf
Return


.handle_RefreshWindow:
  log2PED{"handle Refreshwindows"}

  If redMessage\_WindowID >= #_winObject0 AND redMessage\_WindowID <= #_winObject9
    FindStructureWin{redMessage\_WindowID}
    RefreshTypeWindow{}
    Return
  EndIf

  Select redMessage\_WindowID
    Case #_winSource
      Use Window #_winSource
      ;BeginRefresh_ !windowaddr
        Gosub newsizeSourceWindow
        Gosub refreshSourceWindow
      ;EndRefresh_  !windowaddr,True

    Case #_winMemory1
      Use Window #_winMemory1
      InnerCls
      dowin = 0
      RedrawMem{}

    Case #_winMemory2
      Use Window #_winMemory2
      InnerCls
      dowin = 1
      RedrawMem{}

    Case #_winVariables
      RedrawVarWindow{}
      UpdateVarWindow{}

    Case #_winDisAsm
      UpdateDisAsm{1}   ; force clear of the Window

    Case #_winDisCop
      UpdateDisCop{}

    Case #_winRegisters
      InitRegsWin{}
      RedrawRegs{}

    Case #_winArray
      RedrawArray{1}

    Case #_winMouseables
      mouseables_off = 0
      RedrawMouseables{True}

  End Select
Return


.Movetoregister:
  a = Vallong(Right$(strg$,1))
  If a >= 0 AND a <= 7
    ad              = Peek.l(MyBufferAddress)
    mempointer(cur) = Peek.l(ad+32+(32*(a$="d"))+(a ASL 2))
    If mflag Then mempointer(cur) = Peek.l(mempointer(cur))
  Else
    reply = RTEZRequest(redData\appTitle,"Invalid register number!","Ok")
  EndIf
Return


.initgads:
  Restore buttondata

  GTGZZPosition On
  ;BorderPens 2,1 : Borders 4,5

  gadHeight.w = 2 * 2 + redData\ScreenFontYSize
  gadNumber.w = 1
  gadX.l = redData\WinBorLeft
  gadY.w = redData\WinBorTextTop
  gadH.w = redData\ScreenFontYSize + 4 + 2
  Repeat
    Read gadName.s
    If gadName <> ""
      gadW.l =  FLen(gadName) LSL 3 + 3 * 2 ; 3 = border left and right
      gadFlags.l = #PLACETEXT_IN
      If gadName = "GS" OR gadName = "PS" OR gadName = "BC" Then gadFlags = #PLACETEXT_IN|$100|$2000 ;GTToggle #_winControl,gadNumber,On
      
      *gadget.Gadget = GTButton(#_winControl, gadNumber, gadX, gadY, gadW, gadH, gadName, gadFlags)

      gadX = gadX + gadW
      gadNumber + 1
    EndIf
  Until gadName = ""
  wControlWidth.w = gadX + redData\WinBorRight

;Custom window:
  gadY.w = redData\WinBorTextTop + 2
  gadH.w = redData\ScreenFontYSize + 4 + 2
  GTString 3, 0,  88, gadY               , 160, gadH, "Address$",#PLACETEXT_LEFT,10
  GTString 3, 1,  88, gadY + (gadH + 2)*1, 160, gadH, "Name",#PLACETEXT_LEFT,10

;Search window:
  
  gadY.w = redData\WinBorTextTop + 2
  gadH.w = redData\ScreenFontYSize + 2
  GTString 2, 1, 160, gadY + (gadH + 2)*0, 160, gadH, "Start address",#PLACETEXT_LEFT,40
  GTString 2, 4, 160, gadY + (gadH + 2)*1, 160, gadH, "End address",#PLACETEXT_LEFT,40
  GTString 2, 7, 160, gadY + (gadH + 2)*2, 160, gadH, "Search value",#PLACETEXT_LEFT,256
  ;GTCycle GTList#,id,x,y,w,h,Text$,flags,Options$
  variableTypesList$ = "Byte|Word|Long|String|Quick|Float"
  GTCycle  2, 8, 160, gadY + (gadH + 2)*3, 160, gadH, "Search type",#PLACETEXT_LEFT,variableTypesList$
  GTButton 2, 2, 332, gadY + (gadH + 2)*0 , 4*(8+2),gadH,"MEM1",0
  GTButton 2, 3, 372, gadY + (gadH + 2)*0 , 4*(8+2),gadH,"MEM2",0
  GTButton 2, 5, 332, gadY + (gadH + 2)*1 , 4*(8+2),gadH,"MEM1",0
  GTButton 2, 6, 372, gadY + (gadH + 2)*1 , 4*(8+2),gadH,"MEM2",0
  GTButton 2,10, 160, gadY + (gadH + 2)*4 ,160, gadH,"Start search",0

;Array window
  Borders 4,2
  PropGadget  #_winArray,-13,gadY+1,#VPROP_AFLAGS,#ARR_YGAD,10,-17-WinFontHeight-22,#VPROP_PFLAGS,3

  ArrowGadget #_winArray,#ARR_UGAD,#UPIMAGE,-17,-20-11,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
  ArrowGadget #_winArray,#ARR_DGAD,#DOWNIMAGE,-17,-20,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2

  PropGadget  #_winArray,3,-7,#HPROP_AFLAGS,#ARR_XGAD,-22-33,6,#HPROP_PFLAGS,3

  ArrowGadget #_winArray,#ARR_LGAD,#LEFTIMAGE,-49,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
  ArrowGadget #_winArray,#ARR_RGAD,#RIGHTIMAGE,-33,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
  SetPropInfo #_winArray,#ARR_YGAD,1,1
  SetPropInfo #_winArray,#ARR_XGAD,1,1

;Source window
  PropGadget  #_winSource,3,-7,#HPROP_AFLAGS,#SRC_SGAD,-22-33,6,#HPROP_PFLAGS,3
  ArrowGadget #_winSource,#SRC_LGAD,#LEFTIMAGE,-49,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
  ArrowGadget #_winSource,#SRC_RGAD,#RIGHTIMAGE,-33,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2

;label window
  PropGadget  #_winMouseables,-13,gadY+1,#VPROP_AFLAGS,#MSE_SGAD,10,-17-WinFontHeight-22,#VPROP_PFLAGS,3
  ArrowGadget #_winMouseables,#MSE_UGAD,#UPIMAGE,-17,-20-11,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
  ArrowGadget #_winMouseables,#MSE_DGAD,#DOWNIMAGE,-17,-20,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
Return


buttondata:
  Data$ "STOP","_STEP","SK_IP","_TRACE","_RUN","_<","_>","E_XEC"
  Data$ "E_VAL","BLTZ","REG","MEM1","MEM2","VAR","ASM"
  Data$ "COP","GS","PS","BC",""


; -2 = workbench
; -1 = like workbench
.init_Screen:
  ;*scr     = 0
  dreg     = 0
  redData\pubscreenName = ""

  Use IntuiFont 1
  Select redData\screenType

    Case #SCR_WB
      FindScreen 0,"Workbench"
      redData\pubscreenName = "Workbench"
      dreg     = &redData\pubscreenName

    Case #SCR_DEFPUB
      dreg = 0

    Case #SCR_NAMEDPUB
      dreg = &pubscreenname$
  End Select

  If ExecVersion < 39 AND redData\screenType = #SCR_LIKEWB
    redData\screenModeId = $8000 : redData\screenWidth = 640 : redData\screenHeight = DispHeight
  EndIf

  If redData\screenType = #SCR_LIKEWB OR redData\screenType = #SCR_CUSTOM
    If redData\screenType = #SCR_LIKEWB AND ExecVersion >= 39
      si = ?myscreentags1
      CNIF #test = 1
        Poke.l ?scrbehind1+4,0
      CEND
    Else
      If ExecVersion < 39
        si = ?myscreentagsv37
      Else
        si = ?myscreentags2
      EndIf
      Gosub SetupScreenTags
      CNIF #test = 1
        Poke.l ?scrbehind2+4,0
      CEND
    EndIf

    If redData\usePubScreen = 0
      Poke.l si+4,0
    Else
      Poke.l si+4,?pubname
    EndIf

    If ScreenTags(0,redData\appTitle,si)<1024
      redData\screenModeId  = $8000
      redData\screenWidth  = 640
      redData\screenHeight = DispHeight
      Gosub SetupScreenTags
      ScreenTags 0,redData\appTitle,si
    EndIf

    redData\scr = Peek.l(Addr Screen(0))
    If redData\usePubScreen
      PubScreenStatus_ redData\scr,0
      redData\pubscreenName = "REDDebugger"
    EndIf

    CNIF #test=0
      Window #_winBackdrop,0,0,redData\scr\Width,redData\scr\Height,$200900,"",1,2
    CELSE
      Window #_winBackdrop,0,0,redData\scr\Width,redData\scr\Height,$201900,"",1,2
    CEND
  Else
    If GetPubScreen(0,dreg) = 0
      GetPubScreen 0,0
      dreg = 0
    EndIf
    redData\scr = Peek.l(Addr Screen(0))
  EndIf

  AddProcessPtr "s",&redData\pubscreenName

  If redData\screenType = #SCR_LIKEWB OR redData\screenType = #SCR_CUSTOM
    If redData\usePubScreen AND redData\defaultPubScreen Then SetDefaultPubScreen_ ?pubname
  Else
    ReleasePubScreen 0,dreg
  EndIf
Return


SetupScreenTags:
  Poke.l ?scrmodeid+4,redData\screenModeId
  ;Poke.l ?scrwidth+4,redData\screenWidth
  ;Poke.l ?scrheight+4,redData\screenHeight
Return


.myscreentags1:
              Dc.l #SA_PubName,pubname ; MUST BE FIRST TAG!
              Dc.l #SA_Type,#PUBLICSCREEN
              Dc.l #SA_LikeWorkbench,1
              Dc.l #SA_AutoScroll,-1
              Dc.l #SA_SharePens,-1
              Dc.l 0,0

myscreentagsv37:
              Dc.l #SA_Pens,pens

myscreentags2:
              Dc.l #SA_PubName,pubname ; MUST BE FIRST TAG!
              Dc.l #SA_Type,#PUBLICSCREEN
              Dc.l #SA_LikeWorkbench,1
  scrmodeid:  Dc.l #SA_DisplayID,0
              Dc.l #SA_AutoScroll,-1
              Dc.l #SA_SharePens,-1
  scrbehind2: Dc.l #SA_Behind,0
              Dc.l 0,0

pubname:      Dc.b  "ab3debugger",0
              Even

pens:         Dc.w  -1


.refreshSourceWindow:
  log2PED{"refreshSourceWindow..."}
  ;If ali Then *pcInfo = ali : 
  RED_UpdateSourceWindow{*pcInfo}
  If lt$ <> "" Then RED_ShowStatusText{lt$}
Return


; Close a window
; redMessage\_WindowID = window number
; flag = 0 means DON'T CLOSE DEFAULT WINDOWS!
.RemoveWindow:
  If redMessage\_WindowID = #_winSource OR redMessage\_WindowID=#_winControl
    If flag
      CNIF #test = 1
        exitflag = 1
      CELSE
        d_quit{}
      CEND
    EndIf
  Else
    If redMessage\_WindowID >= #_winObject0 AND redMessage\_WindowID <= #_winObject9
      FindStructureWin{redMessage\_WindowID}
      FreeMem_ objwins()\mem_type,(objwins()\numitems ASL 2)+4
      KillItem objwins()
    EndIf
    DelWindow{redMessage\_WindowID}
    If redMessage\_WindowID >= #_winObject0 AND redMessage\_WindowID <= #_winObject9
      Free GadgetList redMessage\_WindowID
    EndIf
  EndIf
Return


.loadPrefs:
  ;-- defaults for new settings
  redData\logging = True
  redData\showLineNumbers = True
  redData\checkVbr = True

  ;TODO: change to tooltypes as settings
  tt.s = dos_AddPart{redData\ab3Path,"AmiBlitz3"}
  log2PED{"opening tooltypes for <" + tt.s + ">"}
  redData\appDiscObject = dos_OpenToolTypes{tt.s}
  If redData\appDiscObject
    log2PED{"Diskobject found"}
    If UCase$(dos_GetToolString{"LOG_LEVEL", "NOTHING" ,tt}) = "NOTHING" Then redData\logging = False
    If dos_GetToolState{"LINENUMBERS", tt} = 1 Then redData\showLineNumbers = False
    If dos_GetToolState{"CHECKVBR", tt} = 1
      log2PED{"VBR check at startup disabled!"}
      redData\checkVbr = False
    EndIf
  Else
    log2PED{"No Diskobject found"}
  EndIf

  If NOT dos_Exist{redData\appPath} Then log2PED{"Path not exist: \\22" + redData\appPath + "\\22"}

  ; ***********************************************************************************************
  If ReadFile(0,dos_AddPart{redData\appPath,"RED_DBug2.prefs"} )
    ReadType 0,prefs : CloseFile 0
  Else
    log2PED{"Unable to find prefsfile: \\22" + redData\appPath + ":RED_DBug2.prefs\\22!"}
  EndIf

  If prefs\fontname >< "" AND prefs\fontsize > 4
    ta.TextAttr\ta_Name = &prefs\fontname
    ta\ta_YSize         = prefs\fontsize
    ta\ta_Style         = 0
    ta\ta_Flags         = 0
    *testfont.TextFont  = OpenDiskFont_ (ta)
  Else
    *testfont = 0
  EndIf

  If *testfont = 0 ; unable to open font => use system default
    InitRastPort_ testrp.RastPort  ; no (*)pointer else it get zeropagehits and crashs
    AskFont_ testrp,ta.TextAttr ; might be better
    prefs\fontname = Peek.s(ta\ta_Name)
    prefs\fontsize = ta\ta_YSize
  EndIf

  LoadFont 0,prefs\fontname,prefs\fontsize
  LoadFont 1,prefs\fontname,prefs\fontsize
  LoadFont 2,prefs\fontname,prefs\fontsize,#FSF_BOLD
  LoadFont 3,prefs\fontname,prefs\fontsize,#FSF_ITALIC

  ; ***********************************************************************************************
  *prefsPtr.l = ?initstate : defaultPrefs.b = True
  If ReadFile(0,dos_AddPart{redData\appPath,"RED_DBug.prefs"} ) ; Path changed (Marco 21.01.15)
    *storePtr.l = AllocVec_(prefsSize + 4096,#MEMF_PUBLIC|#MEMF_CLEAR)
    ReadMem 0,*storePtr,prefsSize : CloseFile 0
    If Peek.w(*storePtr) <> ( (Vallong("\\__VER_MAJOR") ASL 8) + Vallong("\\__VER_MINOR") )
      log2PED{"Version mismatch for prefs, using defaults..."}
    Else
      CopyMem_ *storePtr,*prefsPtr,prefsSize
      defaultPrefs = False
    EndIf
    FreeVec_ *storePtr
  Else
    log2PED{"Unable to find prefsfile: \\22" + redData\appPath + ":RED_DBug.prefs\\22!"}
  EndIf
  If defaultPrefs Then *prefsPtr = ?initstate
  log2PED{"prefs stored a location " + Hex$(*prefsPtr)}
  ;!log2PED_HexDump{*prefsPtr,prefsSize}

  ad.l = *prefsPtr : ad + 2
  redData\screenType      = Peek.w(ad) : ad + 2
  redData\screenModeId    = Peek.l(ad) : ad + 4
  redData\screenWidth     = Peek.w(ad) : ad + 2
  redData\screenHeight    = Peek.w(ad) : ad + 2
  redData\tokenize = True              : ad + 1
  redData\usePubScreen    = Peek.b(ad) : ad + 1
  redData\windowMaxHeight = Peek.w(ad) : ad + 2

  ;---- copy and set the window position and dimensions
  winBaseFlags.l = #WFLG_SIZEBBOTTOM|#WFLG_CLOSEGADGET|#WFLG_DEPTHGADGET|#WFLG_DRAGBAR|#WFLG_SIZEGADGET
  wininfo(#_winSource)    \flags = winBaseFlags, "Sourcecode View", #_winSource, ?help_source
  wininfo(#_winControl)   \x     = 0, redData\ScreenBarHeight, redData\WinBorLeft + redData\WinBorRight + 200, redData\WinBorTextTop + redData\WinBorBottom + (redData\ScreenFontYSize+4) + 2, $20002e, cntrlwin$, #_winControl, ?help_cntrlwin
  wininfo(#_winMemory1)   \title = "Memory 1"
  wininfo(#_winMemory2)   \title = "Memory 2"
  wininfo(#_winRegisters) \flags = winBaseFlags|#WFLG_NEWLOOKMENUS, "Register Window", -1 ,?help_reg
  wininfo(#_winVariables) \flags = winBaseFlags|#WFLG_NEWLOOKMENUS, varfollow$, -1, ?help_var
  wininfo(#_winDisAsm)    \flags = winBaseFlags|#WFLG_NEWLOOKMENUS, "Disassembly", -1, ?help_asm
  wininfo(#_winDisCop)    \flags = winBaseFlags|#WFLG_NEWLOOKMENUS, "Copper Instructions",-1, ?help_cop
  wininfo(#_winSearch)    \x     = 0,redData\ScreenBarHeight + redData\WinBorTextTop,412 + redData\WinBorLeft + redData\WinBorRight,120,$20002e,"Search Window", 2, ?help_search
  wininfo(#_winArray)     \flags = winBaseFlags|#WFLG_NEWLOOKMENUS|#WFLG_SIZEBRIGHT, "Array", #_winArray, ?help_array
  wininfo(#_winCustom)    \x     = 0,redData\ScreenBarHeight + redData\WinBorTextTop,264 + redData\WinBorLeft + redData\WinBorRight, 68,$20002e,"Custom Chip Window", 3, ?help_chips
  wininfo(#_winMouseables)\flags = winBaseFlags|#WFLG_NEWLOOKMENUS|#WFLG_SIZEBRIGHT, "Label List", #_winMouseables, ?help_labels

  ;-- loading standard windows
  num = Peek.w(ad) : ad + 2
  log2PED{"data for " + Str$(num) + " windows available."}

  For h = 0 To num-1
    winstatus(h) = Peek.w(ad) : ad + 2

    wininfo(h)\x = Peek.w(ad), Peek.w(ad + 2)

    If (#noresize BitTst h)
      ;wininfo(h)\h + redData\WinBorTextTop
    Else
      wininfo(h)\w = Peek.w(ad + 4), Peek.w(ad + 6)
    EndIf

    ;-- better arrange the windows if we use default settings
    If defaultPrefs = True
      If h = #_winControl   
        wininfo(h)\x = 0, redData\ScreenBarHeight
      Else
        wininfo(h)\x = 0, wininfo(#_winControl)\y + wininfo(#_winControl)\h
      EndIf
    EndIf
    ad + 8
  Next h

  redData\procStatus     = Peek.b(ad) : ad + 1
  redData\blitzControl   = Peek.b(ad) : ad + 1
  redData\gosubStatus    = Peek.b(ad) : ad + 1
  redData\defaultPubScreen=Peek.b(ad) : ad + 1
  redData\showSyntaxHelp = Peek.b(ad) : ad + 1
;  redData\showLineNumbers= Peek.b(ad) : ad + 1
;  redData\logging        = Peek.b(ad) : ad + 1

  ;-- load disasmlock
  MaxLen disasmlock$   = 85
  MaxLen disasmlockpf$ = 85

  disasmlock$ = Peek.s(ad)
  If disasmlock$ = "" Then disasmlock$ = "pc-2"
  Poke$ ?disasmlockstr,disasmlock$
  ConvToPostFix disasmlock$, &evalbuffer$
  ;log2PED{"disasmlock converted to postfix: " + Peek.s(&evalbuffer$)}
  i.l = PFEvaluate(Peek.s(&evalbuffer$))
  disasmlockpf$ = Peek.s(&evalbuffer$)
  log2PED{"disasmlock PF: " + disasmlockpf$ + ": " + Str$(i)}
  If disasmlock$ <> ""
    wininfo(#_winDisAsm)\title = "Disassembly (" + disasmlock$ + ")"
    initdiss.l                 = 20
  EndIf

  ;-- load window settings for wizardwindows
  ad + 128
  num2.l = Peek.w(ad) : ad + 2
  log2PED{"data for 23 - " + Str$(num2-1) + " wzwindows available."}
  For h = 23 To num2 - 1
    winstatus(h) = Peek.w(ad) : ad+2
    If (#noresize BitTst h)
      wininfo(h)\h + redData\WinBorTextTop + redData\WinBorBottom
    Else
      wininfo(h)\w = Peek.w(ad+4),Peek.w(ad+6)
    EndIf

    wininfo(h)\x = Peek.w(ad),Peek.w(ad+2)

    ad + 8
  Next h
Return

.openwindows:
  Gosub init_Screen
  Gosub init_Menus
  Gosub initgads

  If redData\procStatus   Then GTToggle #_winControl,18,On
  If redData\blitzControl Then GTToggle #_winControl,19,On
  If redData\gosubStatus  Then GTToggle #_winControl,17,On

  For h = 23 To num2-1
      If winstatus(h) AND (#winprotect BitTst h) = 0
        newwizardwin{h,1,?wzgui}
        redMessage\_WindowID = h
      EndIf
  Next h

  wininfo(#_winControl)\w = wControlWidth
  NewWindow{#_winControl} : AttachGTList #_winControl,#_winControl

  For h = 0 To num - 1
    If winstatus(h) AND (#winprotect BitTst h) = 0
      If h = #_winMemory1 OR h = #_winMemory2
        NewMemWindow{h}
      Else
        NewWindow{h}
        redMessage\_WindowID = h
        Gosub handle_RefreshWindow
      EndIf
    Else
      winstatus(h) = 0
    EndIf
  Next h

  GTSetMenuChecked 0,0, 8  ,redData\tokenize
  GTSetMenuChecked 0,0, 6  ,redData\screenType,On
  GTSetMenuChecked 0,0, 6,6,redData\usePubScreen
  GTSetMenuChecked 0,0, 6,7,redData\defaultPubScreen
  GTSetMenuChecked 0,0, 9  ,redData\showLineNumbers
  GTSetMenuChecked 0,0,10  ,redData\showSyntaxHelp
  GTSetMenuChecked 0,0,11  ,redData\logging
  GTSetMenuChecked 0,1,16  ,redData\asmStep
  Gosub CheckScrModeMenus

  Use Window #_winSource
  ;WindowFont 0

  CatchDosErrs

  CNIF #test = 1
    Activate #_winControl
  CEND
Return


.newsizeSourceWindow:

  ;If rememberInnerWidth.l >< InnerWidth OR rememberInnerHeight.l >< InnerHeight
    Use Window #_winSource
    rememberInnerWidth.l  = sourceWindow\win\GZZWidth
    rememberInnerHeight.l = sourceWindow\win\GZZHeight

    sourceWindow\boxLeft = sourceWindow\win\BorderLeft
    sourceWindow\boxTop = sourceWindow\win\BorderTop

    sourceWindow\boxWidth = sourceWindow\win\GZZWidth
    sourceWindow\boxHeight = sourceWindow\win\GZZHeight - sourceWindow\win\RPort\TxHeight - 5

    redData\statusTextY = sourceWindow\boxTop + sourceWindow\boxHeight + 2

    If redData\showSyntaxHelp Then sourceWindow\boxHeight - sourceWindow\win\RPort\TxHeight - 5
    redData\syntaxTextY = redData\statusTextY - sourceWindow\win\RPort\TxHeight - 4


    sourceWindow\visibleColumns = sourceWindow\boxWidth / 8
    sourceWindow\visibleLines = sourceWindow\boxHeight / sourceWindow\win\RPort\TxHeight

    spc$ = String$(" ",sourceWindow\visibleColumns)
   ; Gosub refreshSourceWindow

    SetPropInfo #_winSource,1,sourceWindow\visibleColumns,1000,sourceWindow\charOffset
    Redraw #_winSource,1
  ;EndIf
Return


.init_Menus:
  ;Menu 0
  GTMenuTitle       0,0    ,"Project"
   GTMenuItem 0,    0,0,0  ,"Status register"     ,"" ,    0,?help_menus
   GTMenuItem 0,    0,0,1  ,"About Debugger"      ,"" ,    0,?help_about
   GTMenuItem 0,    0,0,2
   GTMenuItem 0,    0,0,3  ,"Keyboard shortcuts"  ,""  ,    0,?help_menus
   GTMenuItem 0,    0,0,4
   GTMenuItem 0,    0,0,5  ,"Save configuration"  ,"W" ,    0,?help_configuration
   GTMenuItem 0,    0,0,6  ,"Screen mode..."      ,""  ,    0,?help_screenmode

    GTSubItem 0,   %1,0,6,0,"Workbench"           ,""  ,%1110,?help_screenmode
    GTSubItem 0,   %1,0,6,1,"Like Workbench"      ,""  ,%1101,?help_screenmode
    GTSubItem 0,   %1,0,6,2,"Custom"              ,""  ,%1011,?help_screenmode
    GTSubItem 0,   %1,0,6,3,"Default public"      ,""  ,%0111,?help_screenmode
    GTSubItem 0,   %1,0,6,4
    GTSubItem 0,   %0,0,6,5,"Select custom..."    ,""  ,    0,?help_screenmode
    GTSubItem 0,%1001,0,6,6,"Public screen"       ,""  ,    0,?help_screenmode
    GTSubItem 0,%1001,0,6,7,"Default pubscreen"   ,""  ,    0,?help_screenmode

   GTMenuItem 0,    0,0, 7 ,"Window height..."    ,""  ,    0,?help_screenmode
   GTMenuItem 0,    0,0, 8 ,"Choose Font"         ,""  ,    0,?help_menus
   GTMenuItem 0,%1001,0, 9 ,"Show linenumbers"    ,""  ,    0,?help_menus
   GTMenuItem 0,%1001,0,10 ,"Show syntax"         ,""  ,    0,?help_menus
   GTMenuItem 0,%1001,0,11 ,"Trace Log"
   GTMenuItem 0,    0,0,12 ,"Quit"
   ;GTMenuItem 0,    0,0,12 ,"Quit & die"

  ;Menu 1
  GTMenuTitle       0,1    ,"Windows"
   GTMenuItem 0,    0,1, 0 ,"Registers"           ,"D" ,    0,?help_reg
   GTMenuItem 0,    0,1, 1 ,"Memory 1"            ,"M" ,    0,?help_mem
   GTMenuItem 0,    0,1, 2 ,"Memory 2"            ,"N" ,    0,?help_mem
   GTMenuItem 0,    0,1, 3 ,"Variables"           ,"V" ,    0,?help_var
   GTMenuItem 0,    0,1, 4 ,"Disassembly"         ,"6" ,    0,?help_asm
   GTMenuItem 0,    0,1, 5 ,"Copper"              ,"C" ,    0,?help_cop
   GTMenuItem 0,    0,1, 6 ,"Gosub Step"          ,"G" ,    0,?help_gs
   GTMenuItem 0,    0,1, 7 ,"Procedure Step"      ,"P" ,    0,?help_ps
   GTMenuItem 0,    0,1, 8 ,"Blitz Control"       ,"B" ,    0,?help_bc
   GTMenuItem 0,    0,1, 9
   GTMenuItem 0,    0,1,10 ,"Search memory"       ,"S" ,    0,?help_search
   GTMenuItem 0,    0,1,11 ,"Array..."            ,"R" ,    0,?help_array
   GTMenuItem 0,    0,1,12 ,"Structure..."        ,"T" ,    0,?help_struct
   GTMenuItem 0,    0,1,13 ,"Custom chips"        ,""  ,    0,?help_chips
   GTMenuItem 0,    0,1,14 ,"Label list"          ,""  ,    0,?help_labels
   GTMenuItem 0,    0,1,15 ,"FPU On"              ,""  ,    0,?help_fpu
   GTMenuItem 0,%1001,1,16 ,"Asm Step..."         ,""  ,    0,?help_asmstep
   GTMenuItem 0,%1001,1,17 ,"Check Addr 0 Change" ,""  ,    0,?help_watch0

  ;Menu 2
  GTMenuTitle 0,2,"Objects"
  si  = ?MyTypes
  num = 0
  Repeat
    ad1 = Peek.l(si)
    si+4
    If ad1
      a$ = Peek.s(ad1 + 2)
      If num = 0 Then a$ = a$ + "       "
      GTMenuItem 0,0,2,num,a$,"",0,?help_objects
      num + 1
    EndIf
  Until ad1 = 0

  ;Menu 3
  GTMenuTitle       0,3    ,"Misc"
   GTMenuItem 0,    0,3, 0 ,"Add trace..."        ,"A" ,    0,?help_menus
   GTMenuItem 0,    0,3, 1 ,"Delete trace..."     ,""  ,    0,?help_menus
   GTMenuItem 0,    0,3, 2 ,"Delete all..."       ,""  ,    0,?help_menus
   GTMenuItem 0,    0,3, 3 ,"Sort names"          ,""  ,    0,?help_menus
   GTMenuItem 0,    0,3, 4
   GTMenuItem 0,%1001,3, 5 ,"Auto EVAL"           ,""  ,    0,?help_autoeval
   GTMenuItem 0,    0,3, 6 ,"Define"              ,"Z" ,    0,?help_autoeval
   GTMenuItem 0,    0,3, 7
   GTMenuItem 0,    0,3, 8 ,"Add breakpoint..."   ,"[" ,    0,?help_breakpoints
   GTMenuItem 0,    0,3, 9 ,"Delete..."           ,"]" ,    0,?help_breakpoints
   GTMenuItem 0,    0,3,10 ,"Delete all..."       ,""  ,    0,?help_breakpoints
   GTMenuItem 0,    0,3,11 ,"List..."             ,""  ,    0,?help_breakpoints
  GetCustomMenus{}

  CreateMenuStrip 0
Return


stopit:
  prtcode = -1 : stepcnt = 0 : dstatus = #STOPPED : statego = -1
Return


.getevent:
  redMessage\_Code      = 0
  redMessage\_Qualifier = 0
  redMessage\_IAddress  = 0
  redMessage\_MouseX    = 0
  redMessage\_MouseY    = 0
  redMessage\_Seconds   = 0
  redMessage\_Micros    = 0
  redMessage\_WindowID    = 0
  redMessage\_GadgetID  = 0


  Repeat
    redMessage\_Class = Event

    If redMessage\_Class = 0
      If dstatus = #TRACE
        Delay_ 1
      Else
        Delay_ 2
      EndIf
    EndIf

    If redMessage\_Class = #IDCMP_MOUSEMOVE      ; this is to reduce the amount of updates if mouse is moved around
      WZ_HideBubble{}
      Pop If : Pop Repeat
      Goto getevent
    EndIf

    currentwin.l = Used Window

    Gosub UpdateWindows

    Gosub handle_DebuggerEvents

  Until redMessage\_Class <> 0 OR exitflag <> 0

  redMessage\_Code      = EventCode
  redMessage\_Qualifier = EventQualifier
  redMessage\_IAddress  = EventiAddress
  redMessage\_MouseX    = EMouseX
  redMessage\_MouseY    = EMouseY
  redMessage\_Seconds   = EventSeconds
  redMessage\_Micros    = EventMicros

  redMessage\_WindowID    = EventWindow
  redMessage\_Gadget      = redMessage\_IAddress
  If redMessage\_Gadget
    redMessage\_GadgetID  = redMessage\_Gadget\GadgetID
  EndIf
Return

.handle_DebuggerEvents:
  If FirstItem(d_e())
    log2PED{"** handle debugger events..."}

    While FirstItem(d_e())
      log2PED{"-- d_event: " + Str$(d_e()\t)}

      ;-- Program running mode into title of #_winControl
      ad = Peek.l(?progmode)
      a  = Peek.w(ad)
      If pmodevalid = 0 OR a <> pmode
        pmodevalid = -1
        pmode      = a
        GetProgMode pmode,&cntrlwin$ + 14
        SetWindowTitles_ Peek.l(Addr Window(#_winControl)),&cntrlwin$,-1
      EndIf

      If memlock$(0) Then mempointer(0) = PFEvaluate(memlockpf$(0))
      If memlock$(1) Then mempointer(1) = PFEvaluate(memlockpf$(1))

      If winstatus(#_winMemory1) OR winstatus(#_winMemory2) Then RedrawMem{}
      If winstatus(#_winRegisters) Then RedrawRegs{}
      If winstatus(#_winVariables) Then UpdateVarWindow{}   ; only the values are print

      ResetList objwins()
      While NextItem(objwins())
        If objwins()\typepointer >= 0 Then RefreshTypeWindow{}
      Wend

      Select d_e()\t

        Case #DEVENT_SUPERVISORERROR                 ; supervisor mode error!
          t$ = "(*) " + d_e()\s
          RED_ShowStatusText{t$}
          Gosub goterr

        Case #DEVENT_USERERROR                       ; user mode error!
          t$ = d_e()\s
          RED_ShowStatusText{t$}
          Gosub goterr

        Case #DEVENT_EVALRESULT                      ; EVAL result
          If execrequest = #_newtypewindow
            PopItem objwins()
            objwins()\typepointer = 0
            objwins()\maxobject   = 1
            execrequest           = 0
            objectbusy            = 0
            RefreshTypeWindow{}
          Else
            t$ = d_e()\s


            lasteval$ = t$
            If FLen(t$) < 11
              t$ = t$ + " $" + Hex$(Val(t$)) + " %" + Bin$(Val(t$))
            EndIf

            log2PED{"eval result: " + t$}

            Gosub EVALHandle ; print eval result

            Delay_ 1

            If part$ <> ""
              evalstr$ = t$
              Gosub printbubble
            EndIf

           RED_ShowStatusText{t$}
          EndIf

        Case #DEVENT_TRACELINE                       ; dump code baby!
          log2PED{"DEVENT: Trace current line!"}

          If execrequest = #_newtypewindow
            PopItem objwins()
            execrequest           = 0
            objwins()\typepointer = objwins()\objbaseadr
            t$                    = ""
            SetPropInfo objwins()\winnum,#OBJ_SGAD,1,objwins()\maxobject,0
            Redraw objwins()\winnum,#OBJ_SGAD
            Use Window objwins()\winnum
            WTitle "Newtype: "+objwins()\t+" #"+Str$(objwins()\tracenum)+"/"+Str$(objwins()\maxobject-1)
            RefreshTypeWindow{}
            objectbusy = 0
          EndIf
          If execrequest = #_viewblitz
            GTEnable #_winControl,10
            execrequest = 0
          EndIf

          sourceWindow\currentBufferIndex = d_e()\i
          *pcInfo = Peek.l(sourceWindow\bufferMem + sourceWindow\currentBufferIndex)
          ;log2PED{"current buffer data: " + Hexw$(sourceWindow\currentBufferIndex)}
          ;log2PED{"offset to current sourceline: " + Hex$(Peek.l(*pcInfo))}
          ;log2PED{"startCode at " + Hex$(sourceWindow\startCode)}
          ;log2PED{"pointer to current sourceline: " + Hex$((Peek.l(*pcInfo) AND $7fffffff) + sourceWindow\startCode)}
          ;!log2PED_HexDump{(Peek.l(*pcInfo) AND $7fffffff) + sourceWindow\startCode,32}

          If disasmlockpf$ <> ""
            ad = PFEvaluate(disasmlockpf$) ; update disasm
            If ad <> disasm_ad
              disasm_ad = ad
              If winstatus(#_winDisAsm) Then UpdateDisAsm{}
            EndIf
          EndIf

          sourceWindow\inBackBuffer = 0
          RED_UpdateSourceWindow{*pcInfo}
          Signal_ exetask,signalset

        Case #DEVENT_END                             ; QUIT - outa-here
          exitflag = 1

      End Select
      MaxLen d_e()\s = 0 : KillItem d_e()
    Wend
    log2PED{"** all events handled."}
  EndIf
Return


.UpdateWindows:
  ;log2PED{"... updating windows"}

  If redData\watch0
    If Peek.l (0) <> addr0
      Use Window 0
      WTitle "!!!! Address 0 has changed !! $" + Hex$(Peek.l(0)) + " " + Left$(Peek.s(Peek.l(0)),30)
      Use Window currentwin
    EndIf
  EndIf

  If winstatus(#fpuwin) AND fpuneedupdate.l
    fpuneedupdate - 1
    Use Window #fpuwin
    MOVE.l fpuoffset,fpreg
    Dc.l $f2276800 ;fmove.x fp0,-(a7)
    TST.l regpos : BEQ _noreg
      For temp = 0 To 7
        MOVE.l regpos,a0 : ADD.l fpreg,a0
        Dc.l $f2284800 : Dc.w 0 ;fmove.x 0(a0),fp0
        ADD.l #12,fpreg
        fmove.s fp0,d0
        JSR fpuffp
        fpuRegValues$(temp) = Str$(ffp)
        WZPrint "fpr0" + Str$(temp), &fpuRegValues$(temp)
      Next temp
    _noreg
    Dc.l $f21f4800 ;fmove.x (a7)+,fp0
    Use Window currentwin
  EndIf

  If winstatus(#_winDisAsm) AND initdiss
    ad = PFEvaluate(disasmlockpf$) ; update disasm
    disasm_ad = ad
    If winstatus(#_winDisAsm) Then UpdateDisAsm{}
    initdiss - 1
  EndIf

  If Peek.w(?donebreakpoint)
    t$ = "[Breakpoint]" : RED_ShowStatusText{t$}
    CLR.w donebreakpoint
  EndIf

  If Peek.l(?varhandler)
    asa.l = Peek.l(?varhandler)
    n$    = Peeks$(asa,256)
    Poke.l ?varhandler,0
    Gosub _CheckTrace
  EndIf
Return






.EVALHandle:
  evw.l       = evalrequest
  evalrequest = 0
  Select evw

    Case #_mouseable_eval
      ad = Vallong(d_e()\s)

      Select evalrequestex

        Case #_winMemory1
          mempointer(0) = ad
          cur           = 0
          RedrawMem{}

        Case #_winMemory2
          mempointer(1) = ad
          cur           = 1
          RedrawMem{}

        Case #_winDisAsm
          disasm_ad = ad
          UpdateDisAsm{}

        Case #_winSource
          sourceWindow\currentLine =Peek.l(ad+2)
          RED_PrintSource{}
      End Select

    Case #_memwindow
      mempointer(evalrequestex) = Vallong(d_e()\s)
      cur                       = evalrequestex
      RedrawMem{}
      t$=""

    Case #_structaddress
      PopItem objwins()
      objwins()\typepointer = Vallong(d_e()\s)
      RefreshTypeWindow{}

    Case #_variablelocate
      varinfo()\address = Vallong(d_e()\s)
      If varinfo()\address = 0
        KillItem varinfo()
        reply = RTEZRequest(redData\appTitle,"Variable not found!" + "\\0a\\0a" + t$,"_Abort")
      Else
        If varinfo()\typ = 4
          mem = varinfo()\address
          Gosub FindString
          varinfo()\address = ad
          If ad = -1 Then KillItem varinfo() : a = RTEZRequest(redData\appTitle,"String not found!","_Ok")
        EndIf
        If winstatus(#_winVariables)
          RedrawVarWindow{}
          UpdateVarWindow{}
        EndIf
      EndIf
      t$ = ""

    Case #_disasmaddress
      disasm_ad = Vallong(d_e()\s) AND $fffffffe
      UpdateDisAsm{}

    Case #_discopaddress
      discop_ad = Vallong(d_e()\s) AND $fffffffe
      UpdateDisCop{}

    Case #_autoevalresult
      t$ = autoeval$ + "=" + t$

    Case #_arrayfind
      arrayadd = Vallong(d_e()\s)
      If winstatus(#_winArray) = 0
        NewWindow{#_winArray}
      EndIf
      Use Window #_winArray

      a$ = array$ + "("
      If array1 <> 0
        a$ + Str$(array1) + "," + Str$(array2) + ")"
      Else
        a$ + Str$(array2) + ")"
      EndIf
      WTitle a$

      RedrawArray{1}
  End Select
Return

.FreeStuff:
  For h = 0 To (Maximum Window)-1
    If Peek.l(Addr Window(h))
      If h > 22
        WZCloseWindow h
      Else
        If Peek.l(Addr GTList(h)) Then DetachGTList h : Free GTList(h)
        Free Window h
      EndIf
      If Peek.l(Addr GadgetList(h)) Then Free GadgetList(h)
    EndIf

  Next h

 _again20
  For h = 1 To 100
    If NewCloseScreen(0) <> 0 Then h = 250
    Delay_ 1
  Next
  If h <= 101 Then a = RTEZRequest(redData\appTitle,warn1$,"_Ok") : Goto _again20
  Free GTMenuList 0
  FreeMem_ sourceWindow\bufferMem,#bufflen
Return


._CheckTrace:
  Ascii = Peek.b(&n$) AND $ff
  nt    = Peek.b(&n$+1)
  nf    = Peek.b(&n$+2)
  si    = Peek.l(&n$+4)
  na$   = Peek.s(&n$+8)
  Select Ascii

    Case #_memwindowmove
      If nt = 0 OR nt = 1
        mempointer(nt) = si
        If nt=0 Then nt = #_winMemory1 Else nt = #_winMemory2
        If winstatus(nt) = 0
          NewMemWindow{nt}
        EndIf
      EndIf

    Case #_diswindow
      disasm_ad = si AND $fffffffe
      If winstatus(#_winDisAsm) = 0
        NewWindow{#_winDisAsm}
      EndIf
      UpdateDisAsm{}

    Case #_varwindow
      If winstatus(#_winVariables) = 0
        NewWindow{#_winVariables}
      EndIf
      a = 1

    Case #_deltrace
      Gosub _Deltrace

    Case #_addtrace
      Gosub _Addtrace

    Case #_copperlist
      discop_ad = si
      If winstatus(#_winDisCop) = 0
        NewWindow{#_winDisCop}
      EndIf
      UpdateDisCop{}

    Case #_proccontrol
      If nf = 0 ; (do Toggle)
        redData\procStatus = NOT(redData\procStatus)
      Else
        redData\procStatus = nt
      EndIf
      GTToggle #_winControl,18,redData\procStatus

  End Select
  If a AND winstatus(#_winVariables)
    RedrawVarWindow{}
    UpdateVarWindow{}
  EndIf
Return


._Deltrace:
  a = 0
  ResetList varinfo()
  While NextItem(varinfo())
    If varinfo()\name = na$
      If varinfo()\typ = nt ; added check of type to be sure we delete the right entry in the var trace  tomsmart1 2016 02 14
        KillItem varinfo()
        a=-1
      EndIf
    EndIf
  Wend
Return


._Addtrace:
  AddLast varinfo()
  varinfo()\name    = na$
  varinfo()\address = si
  varinfo()\typ     = nt
  varinfo()\form    = nf-1
  a = 1
  If varinfo()\typ = 4
    mem = varinfo()\address
    Gosub FindString
    varinfo()\address = ad
    If ad = -1 Then KillItem varinfo() : a = 0
  EndIf
Return


; dowin = window to update
; flag = -1 for move backwards
.Movemem:
  If dowin = 0 Then Use Window #_winMemory1 Else Use Window #_winMemory2
  wwide.l = (InnerWidth ASR 3)-10
  wwide/7
  jump = wwide ASL 1
  If kbshift Then jump = jump*(InnerHeight ASR 6)

_doMovemem:
  If flag = -1
    mempointer(dowin)-jump
  Else
    mempointer(dowin)+jump
  EndIf
  RedrawMem{}
Return








Statement DoCurs{xad.b,num.b}
SHARED sourceWindow,mad,mempointer(),wwide,editflag

  If (Peek.l(Addr Window(#_winMemory1+num)) = 0) Then Statement Return

  *rp.RastPort = RastPort(#_winMemory1 + num)

  y.l  = (((mad-mempointer(num))/wwide)ASL 3)+sourceWindow\boxTop

  SetDrMd_ *rp,2

  If editflag = 0
    x.l = sourceWindow\boxLeft + 72 + (xad ASL 3)
    If (mad AND %1) ; Odd address
      x + (((xad-1)ASR 2) ASL 3)
    Else
      x + ((xad ASR 2) ASL 3)
    EndIf
  Else
    x = sourceWindow\boxLeft + 80 + (wwide*20)+(xad ASL 3)
  EndIf
  RectFill_ *rp,x,y,x + 7,y + 7
  SetDrMd_ *rp,1
End Statement


.MemEdit:
  If (Peek.l(Addr Window(winnum)) = 0) Then Return

  Use Window winnum
  Activate winnum
  WTitle "Edit mode"
  Gosub meminfo
  DoCurs{0,dowin}

  FlushEvents
  flag = 0
  Repeat
    ev  = WaitEvent
    evw = (EventWindow=winnum)
    evq = EventQualifier
    a$  = Inkey$
    If evw = 0 OR ev = $80000 Then a$ = " " : ev = 0 : evq = 0
    If ev AND evw
      Select ev

        Case 2
          Gosub meminfo

        Case 4
          Gosub meminfo
          ;InnerCls
            w.w  = InnerWidth
            hi.w = InnerHeight
            ;Boxf 0,0,w,hi,0

        Case 512
          a$ = " " : ev = 0 : evq = 0

        Case 1024
          Select EventCode

            Case $4c ; UP cursor
              mad-wwide : flag = -1

            Case $4d ; DOWN cursor
              mad+wwide : flag = -1

            Case $4F ; Left cursor
              xad.l-1 : If xad = -1 Then xad = wxad.l-1 : mad.l-wwide.l
              flag = -1

            Case $4E ; Right cursor
              xad+1: flag = -1
          End Select
          If flag Then a$ = ""
      End Select
    EndIf

    b$ = ""
    If a$ <> ""
      If (evq AND %1000) Then b$ = a$
      If a$ <> " " AND a$ <> Chr$(9) Then b$ = a$
    EndIf
    If editflag
      If b$ <> ""
        Poke.b mad+xad,Asc(a$)
        xad+1
        flag = -1
        a$ = ""
      EndIf
    Else
      If b$ <> ""
        b$ = UCase$(b$)
        If (b$ >= "0" AND b$ <= "9") OR (b$ >= "A" AND b$ <= "F")
          a = Peek.b(mad+(xad ASR 1))
          b = Vallong("$"+b$)
          If (xad AND %1)
            a = (a AND $f0) OR b
          Else
            a = (a AND $0f) OR (b ASL 4)
          EndIf
          Poke.b mad+(xad ASR 1),a
          xad+1
          flag = -1
        EndIf
        a$ = ""
      EndIf
    EndIf
    If a$ = Chr$(9)
      editflag = 1-editflag
      If editflag = 0
        wxad ASL 1
        xad ASL 1
      Else
        wxad = wxad ASR 1
        xad  = xad ASR 1
      EndIf
      flag = 1
    EndIf
    If flag
      If xad > wxad-1 Then xad = 0 : mad+wwide
      If mad >= nmad.l Then mad = nmad : mempointer(dowin)+wwide : nmad+wwide
      If mad < mempointer(dowin) Then mempointer(dowin)-wwide : mad = mempointer(dowin) : nmad-wwide
      num = dowin
      DrawMem{dowin}
      DoCurs{xad,dowin}
      flag = 0
    EndIf
  Until a$ = " "
  DoCurs{xad,dowin}
  Domemtitle {dowin}
  dowin = -1
  RedrawMem{}
Return


meminfo:
  wwide = (InnerWidth ASR 3)-10
  wwide/7
  wxad = wwide ASL 2
  wwide ASL 1

  mad.l  = mempointer(dowin)
  nmad.l = mad+((InnerHeight ASR 3)*wwide)
  xad    = 0 ; count number of 4 bit groups from address ad
  flag   = -1
  If editflag Then wxad = wxad ASR 1
Return


FindString:       ; added more checks to avoid Nullpointer access  tomsmart1 2016 02 05
  ad = Peek.l(MyBufferAddress)
  If (ad)
    ad2 = Peek.l(ad+52)  ; get Value of Register A5
    If (ad2)
    ; replaced the search in the basic variable store with a Basic routine
    ;  ad = D_FindStringPtr(ad2,mem)
      ad2_offset.l = $8000 +2   ; set the size to search
      ad = -1 ; for the case we don't find the string pointer
      Repeat
        ad2_offset - 2 ;
        If Peek.l(ad2 - ad2_offset) = mem  ; test if the pointers match
          ad = ad2 - ad2_offset ; yes get address
          ad2_offset = 0 ; for end until
        EndIf
      Until ad2_offset = 0  ; test if we reach the end
    Else
      ad = -1
    EndIf
  EndIf
  If ad = -1
  ; replaced the unsave search on the stack with one that respected the Stack size and limts
  ;  ad = Peek.l(MyBufferAddress)
  ;  If (ad)
  ;    ad2 = Peek.l(ad+60) ; get Value of Register A7
  ;    If (ad2)
  ;      ad = D_FindStringPtr(ad2+$8000,mem) ; search in stack
  ;    Else
  ;     ad = -1
  ;    EndIf
    *progtask.Task = exetask        ; get the task pointer of the program to debug
    If (*progtask)               ; test if we have a vaild pointer
      ad2_offset.l = *progtask\tc_SPUpper -3 ; get the upper Stack address and -3 for peek.l to prevent hits
      ad = -1 ; for the case we don't find the string pointer
      Repeat
        ad2_offset -1
        If Peek.l(ad2_offset) = mem  ; test if the pointers match
          ad = ad2_offset ; yes get address
          ad2_offset = *progtask\tc_SPLower ; for end until
        EndIf
      Until ad2_offset = *progtask\tc_SPLower ; test if we reach the lower Stack address
    Else
      ad = -1
    EndIf
  EndIf
Return


.SearchMemory:
  ad1        = Vallong(GTGetString(2,1))
  old_ad     = ad1
  ad2        = Vallong(GTGetString(2,4))
  searchfor$ = GTGetString(2,7)
  nt         = searchtype

  If nt = 0 Then Return

  If nt < 4 Then si = Vallong(searchfor$)
  If nt = 4 Then si = &searchfor$

  ;OPTIMIZE 7 ; this would require an FPU   why ??? Val() has been updated
   If nt = 5 Then mq = Val(searchfor$) : si = Peek.l(&mq)
   If nt = 6 Then mf = Val(searchfor$) : si = Peek.l(&mf)
  ;OPTIMIZE 5

  t$ = "Searching memory.... <SPACE> to abort" : RED_ShowStatusText{t$}
  num = 0

 _doagain
  ad = SearchMem(nt,si,ad1,ad2)

  If ad <> 0 AND ad <> 1
    num+1
    ad = SearchMemFound
    b$ = Peek.s(?search0) + Hex$(old_ad) + Peek.s(?search01) + Hex$(ad2)
    b$ + Peek.s(?search1) + Hex$(ad) + Peek.s(?search2) + Hex$(ad-old_ad) + Peek.s(?search3) + Hex$(num) + Peek.s(?search4)
    reply = RTEZRequest("Search", b$, "Mem_1|Mem_2|_Again|_Exit")
    If reply <> 0
      If reply = 3 Then ad1 = ad + 1 : Goto _doagain
      mempointer(reply-1) = ad
      RedrawMem{}
    EndIf
  Else
    If ad = 1 Then a$ = Peek.s(?exitpress) Else a$ = Peek.s(?notfound)
    reply = RTEZRequest("Search",a$,"_Okay")
  EndIf

  t$ = "" : RED_ShowStatusText{t$}
Return


exitpress: Dc.b       "Search aborted - value not found!",0
notfound:  Dc.b       "Value not found within given range!",0
search0:   Dc.b       "Search start address      $",0
search01:  Dc.b 10,   "Search end address        $",0
search1:   Dc.b 10,   "Found value at address    $",0
search2:   Dc.b 10,   "Offset from start address $",0
search3:   Dc.b 10,   "Total occurences found    $",0
search4:   Dc.b 10,10,"  Move memory window to address?",0
Even







.goterr:
  log2PED{"error " + Str$(d_e()\t) + ": " + d_e()\s}
  ShowScreen 0
  If Peek.l(Addr Window(0)) Then Activate 0
  MOVE.w  #0,proccount
  If winstatus(#_winArray) Then RedrawArray{0}
  log2PED{"goterr finished."}
Return


; Open an object trace window
; address.l = addr
; is_bb.b = 0 or -1
.NewTypeWindow:
  If AddItem(objwins()) = 0
    reply = RTEZRequest(redData\appTitle,"No more object windows!","_Okay")
    Return
  EndIf

  ; Get a spare window
  num = #_winObject0
  While Peek.l(Addr Window(num)) <> 0
    num+1
  Wend

  objwins()\winnum      = num
  objwins()\objadr      = address
  objwins()\objbaseadr  = 0
  objwins()\is_bbobject = is_bb

  ; A few variables we're gonna use
  ox = 0 : oy = WinFontHeight+3 : ow = 320
  typelength = 7
  num        = 0
  *_scr.Screen = Peek.l(Addr Screen(0))
  If *_scr
    winheight = *_scr\BarHeight  +WinFontHeight + *_scr\WBorBottom +2 + *_scr\WBorTop
  Else
    winheight = 23+WinFontHeight
  EndIf

  If is_bb
    wininfo(objwins()\winnum)\helplink = ?help_objects
    Gosub ObjectWin
  Else
    wininfo(objwins()\winnum)\helplink = ?help_struct
    Gosub StructWin
  EndIf
  If reply = 0
    KillItem objwins()
    Return
  EndIf

  If num < 3 Then winheight+(3-num)*8

  objwins()\numitems = num
  objwins()\t        = typetitle$
  memadr             = AllocMem_((num ASL 2)+4,#MEMF_CLEAR)
  If memadr = 0
    KillItem objwins()
    Return
  EndIf

  typewidth = sourceWindow\boxLeft+(typelength ASL 3)+8+16

  PropGadget objwins()\winnum,-13,WinFontHeight+5,#VPROP_AFLAGS,#OBJ_SGAD,10,-17-WinFontHeight-22,#VPROP_PFLAGS,3
  SetPropInfo objwins()\winnum,#OBJ_SGAD,1,1
  ArrowGadget objwins()\winnum,#OBJ_UGAD,#UPIMAGE,-17,-20-11,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
  ArrowGadget objwins()\winnum,#OBJ_DGAD,#DOWNIMAGE,-17,-20,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2

  SizeLimits typewidth+22,winheight,640,1600;winheight
  wflg.l = #WFLG_ACTIVATE|#WFLG_DRAGBAR|#WFLG_DEPTHGADGET|#WFLG_CLOSEGADGET|#WFLG_NEWLOOKMENUS|#WFLG_SIZEGADGET|#WFLG_SIZEBRIGHT
  Window objwins()\winnum,ox,oy,ow,winheight,wflg,"Newtype: "+typetitle$,1,2,objwins()\winnum

 ; DEFTYPE.tag10 wtags
;  wtags\ti_Tag = #WA_AutoAdjust,1,#WA_InnerWidth,ow,#WA_InnerHeight,winheight,#TAG_DONE,0
;  WindowTags objwins()\winnum,$103f|$200000,"Newtype: "+typetitle$,&wtags
  GTSetMenu 0
  WindowFont 0
  winstatus(objwins()\winnum) = -1

  Wline typewidth-5,sourceWindow\boxTop,typewidth-5,sourceWindow\boxTop+InnerHeight-1,1

  objwins()\tracenum    = 0
  objwins()\typewidth   = typewidth
  objwins()\typepointer = -1,memadr
  *rp.RastPort          = RastPort(objwins()\winnum)

  ;OutTextPen rp,1
  SetAPen_ *rp,1
  OutText sourceWindow\boxLeft+2,sourceWindow\boxTop+1,rp,"Address"
  oy = 9+sourceWindow\boxTop
  If is_bb
    Gosub ObjectWinD
  Else
    Gosub StructWinD
  EndIf
Return


.printbubble:
  bubblehelp$ = part$ + "\\0a"
  bubblehelp$ + evalstr$ + "\\0a"
  bubblehelp$ + "01234567890123456789012345678901234567890 String Lineal"
  ;log2PED{"printbubble: " + part$}
  WZ_ShowBubble{bubblehelp$}
Return


.NewType_Rout:
ObjectWin:
  objwins()\type_sizeof = Peek.w(address)
  address + 2

  typetitle$ = Peek.s(address)
  address+Len(typetitle$)+1
  address2 = address
  y2.l     = redData\scr\Height - oy
  If y2 > redData\windowMaxHeight Then y2 = redData\windowMaxHeight
  Repeat
    a$ = Peek.s(address)
    address + Len(a$)+3
    If a$
      num + 1
      If (Len(a$)) > typelength Then typelength = Len(a$)
      winheight + 8
      If (winheight+8) > y2 Then a$ = ""
    EndIf
  Until a$ = ""
  reply = -1
Return


ObjectWinD:
  address = address2
  For h = 1 To num
    a$ = Peek.s(address)
    address+Len(a$)+1
    typ   = Peek.b(address)
    skp.b = Peek.b(address+1)
    If skp = -1
      If typ < 3 Then skp = typ Else skp = 4
    EndIf
    OutText sourceWindow\boxLeft+2,oy,rp,LSet$(a$,typelength)+"."+Mid$(objtype$,typ,1)
    oy+8
    Poke.w memadr,typ
    Poke.w memadr+2,skp
    memadr+4
    address+2
  Next h

  CNIF #test = 0
    a$ = "poke.w "+Str$(&objwins()\maxobject)+",maximum "+typetitle$
    a$+":Poke.l "+Str$(&objwins()\objbaseadr)+",Addr "+typetitle$+"(0)"
    d_exec{a$}
    execrequest = #_newtypewindow
    objectbusy  = -1
    PushItem objwins()
  CELSE
    typepointer = Addr Shape(0)
    RefreshTypeWindow{}
  CEND
Return


StructWin:
  suc.l = OpenFile(0,dos_AddPart{redData\appPath,"structure.lookup"})
  fil$  = ""
  If suc = 0
    reply = RTEZRequest(redData\appTitle,"Couldn't locate structure.lookup file.","_Abort")
    reply = 0
    Return
  EndIf
  t$ = RTEZGetString(redData\appTitle,"Enter structure name:",80,laststructure$)
  If t$ = "" Then reply = 0 : Return
  laststructure$ = t$
  t$             = LCase$(t$)
  a$             = ""
  b$             = ""
  filepos.l      = 0
  FileInput 0
  flag = 0
  While b$ <> t$ AND NOT(Eof(0))
    a$ = Edit$(256)
    If Left$(a$,1) = "!"
      fil$ = Mid$(a$,2)
    Else
      b$ = LCase$(Mid$(a$,10))
    EndIf
  Wend
  filepos = Vallong("$"+Left$(a$,8))
  If b$ <> t$
    reply = RTEZRequest(redData\appTitle,"Type not found!","_Okay")
    CloseFile 0
    reply = 0
    WindowInput 0
    Return
  EndIf
  CloseFile 0
  suc = OpenFile(0,fil$)
  If suc = 0
    reply = RTEZRequest(redData\appTitle,"File not found!","_Okay")
    CloseFile 0
    reply = 0
    WindowInput 0
    Return
  EndIf
  FileInput 0
  FileSeek 0,filepos
  a$                    = Edit$(256)
  typetitle$            = Left$(a$,Len(a$)-1)
  a$                    = Edit$(256)
  objwins()\type_sizeof = Val(Mid$(a$,8,6))
  a$                    = "!"
  y2                    = redData\scr\Height - oy

  If y2 > redData\windowMaxHeight Then y2 = redData\windowMaxHeight

  While a$ <> ""
    a$ = Edit$(256)
    If a$ <> "" AND Right$(a$,1) <> ":"
      a$ = Mid$(a$,22)
      num+1
      If (Len(a$)) > typelength Then typelength = Len(a$)
      winheight+8
      If (winheight+8) > y2 Then a$ = ""
    Else
      a$ = ""
    EndIf
  Wend
  reply = -1
Return


StructWinD:
  FileSeek 0,filepos
  FileInput 0

  flag   = 0
  a$     = Edit$(256)
  a$     = Edit$(256)
  prev.w = 0

  For h = 1 To num
    a$  = Edit$(256)
    typ = Val(Mid$(a$,3,5))
    skp = typ-prev
    If h > 1 Then Poke.w memadr-2,skp

    prev = typ

    Select Val(Mid$(a$,17,3))

      Case 1
        typ = 1

      Case 2
        typ = 2

      Case 4
        typ = 3

      Default
        typ = 0
    End Select

    a$ = Mid$(a$,22)
    b$ = LCase$(a$)

    If Instr(b$,"name") AND skp = 4
      If flag = 0
        reply = RTEZRequest(redData\appTitle,"Keyword 'name' found."+Chr$(10)+"Point "+a$+" to string?","_Yes|_All|_No")
        If reply <> 0 Then typ = 4
        If reply = 2 Then flag = -1
      Else
        typ = 4
      EndIf
    EndIf
    a$ = LSet$(a$,typelength)+"."
    If typ > 0
      a$+Mid$(objtype$,typ,1)
    Else
      a$+"?"
      typ = 1
    EndIf
    OutText sourceWindow\boxLeft+2,oy,rp,a$
    oy+8
    Poke.w memadr,typ
    memadr+4
  Next h

  WindowInput 0
  CloseFile 0

  objwins()\typepointer = 0
  RefreshTypeWindow{}
Return


.UpdatePrefs:
  If *prefsPtr
    *storePtr.l = *prefsPtr
    Poke.b *storePtr   ,Vallong("\\__VER_MAJOR")
    Poke.b *storePtr+ 1,Vallong("\\__VER_MINOR")
    Poke.w *storePtr+ 2,redData\screenType
    Poke.l *storePtr+ 4,redData\screenModeId
    Poke.w *storePtr+ 8,redData\screenWidth
    Poke.w *storePtr+10,redData\screenHeight
    Poke.b *storePtr+12,redData\tokenize
    Poke.b *storePtr+13,redData\usePubScreen
    Poke.w *storePtr+14,redData\windowMaxHeight
    Poke.w *storePtr+16,#save_numwindows
    *storePtr + 18
    For h = 0 To #save_numwindows-1
      Poke.w *storePtr,winstatus(h) : *storePtr+2
      If (Peek.l(Addr Window(h) ) >< 0)
        Use Window h
        wininfo(h)\x = WindowX
        wininfo(h)\y = WindowY
        wininfo(h)\w = WindowWidth
        wininfo(h)\h = WindowHeight
      EndIf
      Poke.w *storePtr,wininfo(h)\x : *storePtr+2
      Poke.w *storePtr,wininfo(h)\y : *storePtr+2
      Poke.w *storePtr,wininfo(h)\w : *storePtr+2
      Poke.w *storePtr,wininfo(h)\h : *storePtr+2
    Next h

    Poke.b *storePtr,redData\procStatus       : *storePtr + 1
    Poke.b *storePtr,redData\blitzControl     : *storePtr + 1
    Poke.b *storePtr,redData\gosubStatus      : *storePtr + 1
    Poke.b *storePtr,redData\defaultPubScreen : *storePtr + 1
    Poke.b *storePtr,redData\showSyntaxHelp   : *storePtr + 1
    ;*storePtr + 31
  .@prefssave
    Poke.s *storePtr,disasmlock$              : *storePtr + 128
    Poke.w *storePtr,#wizardwindows           : *storePtr + 2
    For h = 23 To #wizardwindows-1
      Poke.w *storePtr,winstatus(h)           : *storePtr + 2
      If (Peek.l(Addr Window(h) ) >< 0)
        Use Window h
        wininfo(h)\x = WindowX
        wininfo(h)\y = WindowY
        wininfo(h)\w = WindowWidth
        wininfo(h)\h = WindowHeight
      Else
        Poke.w *storePtr,wininfo(h)\x : *storePtr+2
        Poke.w *storePtr,wininfo(h)\y : *storePtr+2
        Poke.w *storePtr,wininfo(h)\w : *storePtr+2
        Poke.w *storePtr,wininfo(h)\h : *storePtr+2
      EndIf
    Next h
  Else
    log2PED{"prefsPtr is NULL!"}
  EndIf
Return


.MenuHelp:
  log2PED{"** menuhelp: " + Hex$(redMessage\_Code)}
  If redMessage\_Code <> -1
    hitmenu.w    = -1
    hititem.w    = -1
    hitsubitem.w = -1

    n = (redMessage\_Code AND 31) 
    If n <> 31 Then hitmenu = (redMessage\_Code AND 31)

    n = (redMessage\_Code ASR 5) AND 63
    If n <> 63 Then hititem = n

    n = ((redMessage\_Code ASR 11) AND 31)
    If n <> 31 Then hitsubitem = n

    ad.l = GTGetUserData(0,hitmenu,hititem,hitsubitem)
    If ad <> 0 Then ShowHelp{Peek.s(ad)}
  EndIf
Return

setregvalue:
  Dc.b "Enter new register value:",10
  Dc.b "    e.g. d0=12345678     ",10
  Dc.b "         d7=$0           ",10
  Dc.b "         a0=",34,"bLtZ",34,"       ",0

  Even

;Array Aof type definitions
MyTypes:
  Dc.l BitmapType
  Dc.l BlitzfontType
  Dc.l BufferType
  Dc.l Coplisttype
  Dc.l FileType
  Dc.l GTListType
  Dc.l GTMenuListType
  Dc.l IntuifontType
  Dc.l MapObjType
  Dc.l ModuleType
  Dc.l PaletteType
  Dc.l QueueType
  Dc.l ShapeType
  Dc.l SliceType
  Dc.l SoundType
  Dc.l SpriteType
  Dc.l StencilType
  Dc.l TapeType
  Dc.l WindowType
  Dc.l 0

;General form:
;               Sizeof.objtype
;               Object name$
;               [item$
;                item type (#_byte to #_float)
;                item type size (byte size or -1 to take size from type)
;               ]
;All strings should be null terminated.

PaletteType:
  Dc.w 128
  Dc.b "Palette",0
  Dc.b "*_pdata",0,#_long,-1
  Dc.b "numcols",0,#_word,-1
  Dc.b "[locol",0,#_word,-1
  Dc.b "hicol",0,#_word,-1
  Dc.b "speed",0,#_word,-1
  Dc.b "var]",0,#_word,-1
  Dc.b 0

Even
BitmapType:
  Dc.w 64
  Dc.b "Bitmap",0
  Dc.b "_ebwidth",0,#_word,-1
  Dc.b "_height",0,#_word,-1
  Dc.b "_depth",0,#_word,-1
  Dc.b "_pad",0,#_word,-1
  Dc.b "_plane0",0,#_long,-1
  Dc.b "_plane1",0,#_long,-1
  Dc.b "_plane2",0,#_long,-1
  Dc.b "_plane3",0,#_long,-1
  Dc.b "_plane4",0,#_long,-1
  Dc.b "_plane5",0,#_long,-1
  Dc.b "_plane6",0,#_long,-1
  Dc.b "_plane7",0,#_long,-1
  Dc.b "_xcurs",0,#_word,-1
  Dc.b "_ycurs",0,#_word,-1
  Dc.b "_pad[8]",0,#_byte,8
  Dc.b "_flags",0,#_word,-1
  Dc.b "_bitplanemod",0,#_word,-1
  Dc.b "_xclip",0,#_word,-1
  Dc.b "_yclip",0,#_word,-1
  Dc.b "_cclip",0,#_word,-1
  Dc.b "_isreal",0,#_word,-1
  Dc.b 0

Even
ModuleType:
  Dc.w 8
  Dc.b "Module",0
  Dc.b "_mt_data",0,#_long,-1
  Dc.b "_length",0,#_long,-1
  Dc.b 0

Even
BlitzfontType:
  Dc.w 4
  Dc.b "Blitzfont",0
  Dc.b "_font",0,#_long,-1
  Dc.b 0

Even
ShapeType:
  Dc.w 32
  Dc.b "Shape",0
  Dc.b "_pixelwidth",0,#_word,-1
  Dc.b "_pixelheight",0,#_word,-1
  Dc.b "_depth",0,#_word,-1
  Dc.b "_ebwidth",0,#_word,-1
  Dc.b "_bltsize",0,#_word,-1
  Dc.b "_xhandle",0,#_word,-1
  Dc.b "_yhandle",0,2,-1
  Dc.b "_data",0,#_long,-1
  Dc.b "_cookie",0,#_long,-1
  Dc.b "_onebpmem",0,#_word,-1
  Dc.b "_onebpmemx",0,#_word,-1
  Dc.b "_allbpmem",0,#_word,-1
  Dc.b "_allbpmemx",0,#_word,-1
  Dc.b "_pad[2]",0,#_byte,2
  Dc.b 0

Even
TapeType:
  Dc.w 16
  Dc.b "Tape",0
  Dc.b "_ielist",0,#_long,-1
  Dc.b "_timevalhi",0,#_long,-1
  Dc.b "_timevallo",0,#_long,-1
  Dc.b "_pad[4]",0,#_byte,4
  Dc.b 0

Even
StencilType:
  Dc.w 8
  Dc.b "Stencil",0
  Dc.b "_ebwidth",0,#_word,-1
  Dc.b "_height",0,#_word,-1
  Dc.b "_data",0,#_long,-1
  Dc.b 0

Even
QueueType:
  Dc.w 16
  Dc.b "Queue",0
  Dc.b "*currentitem",0,#_long,-1
  Dc.b "*nextitem",0,#_long,-1
  Dc.b "_length",0,#_long,-1
  Dc.b "_pad[4]",0,#_byte,4
  Dc.b 0

Even
FileType:
  Dc.w 32
  Dc.b "File",0
  Dc.b "_handle",0,#_long,-1
  Dc.b "_reclen",0,#_long,-1
  Dc.b "_pad[4]",0,#_byte,4
  Dc.b "*fields",0,#_long,-1
  Dc.b "_buffer",0,#_long,-1
  Dc.b "_flags",0,#_word,-1
  Dc.b "_valid",0,#_word,-1
  Dc.b "_seekoff",0,#_word,-1
  Dc.b "_seek",0,#_long,-1
  Dc.b 0

Even
BufferType:
  Dc.w 16
  Dc.b "Buffer",0
  Dc.b "_current",0,#_long,-1
  Dc.b "_first",0,#_long,-1
  Dc.b "_length",0,#_long,-1
  Dc.b "_pad[4]",0,#_byte,4
  Dc.b 0

Even
SliceType:
  Dc.w 64
  Dc.b "Slice",0
  Dc.b "_ypos",0,#_word,-1
  Dc.b "_flags",0,#_word,-1
  Dc.b "_numbitplanes",0,#_word,-1
  Dc.b "_numsprites",0,#_word,-1
  Dc.b "_numcolours",0,#_word,-1
  Dc.b "_bitplanes",0,#_long,-1
  Dc.b "_sprites",0,#_long,-1
  Dc.b "_colours",0,#_long,-1
  Dc.b "_BPLCON1",0,#_long,-1
  Dc.b "_BPLCON2",0,#_long,-1
  Dc.b "_pad[2]",0,#_byte,2
  Dc.b 0

Even
SoundType:
  Dc.w 16
  Dc.b "Sound",0
  Dc.b "_data",0,#_long,-1
  Dc.b "_period",0,#_word,-1
  Dc.b "_length",0,#_word,-1
  Dc.b "_loop",0,#_long,-1
  Dc.b "_looplength",0,#_word,-1
  Dc.b "_pad[2]",0,#_byte,2
  Dc.b 0

Even
SpriteType:
  Dc.w 16
  Dc.b "Sprite",0
  Dc.b "_data",0,#_long,-1
  Dc.b "_height",0,#_word,-1
  Dc.b "_channels",0,#_word,-1
  Dc.b "_flags",0,#_word,-1
  Dc.b "_nextoff",0,#_word,-1
  Dc.b "_xhandle",0,#_word,-1
  Dc.b "_yhandle",0,#_word,-1
  Dc.b 0

Even
WindowType:
  Dc.w 32
  Dc.b "Window",0
  Dc.b "_window",0,#_long,-1
  Dc.b "_cursx",0,#_word,-1
  Dc.b "_cursy",0,#_word,-1
  Dc.b "_pointer",0,#_long,-1
  Dc.b "_length",0,#_long,-1
  Dc.b 0

Even
IntuifontType:
  Dc.w 16
  Dc.b "Intuifont",0
  Dc.b "_fontname",0,#_string,-1
  Dc.b "_ysize",0,#_word,-1
  Dc.b "_pad",0,#_word,-1
  Dc.b "_font",0,#_long,-1
  Dc.b "_pad2[4]",0,#_byte,4
  Dc.b 0

Even
Coplisttype:
  Dc.w 128
  Dc.b "Coplist",0
  Dc.b "size",0,#_long,-1
  Dc.b "coppos",0,#_long,-1
  Dc.b "colors",0,#_long,-1
  Dc.b "sprites",0,#_long,-1
  Dc.b "bpcons",0,#_long,-1
  Dc.b "bplanes",0,#_long,-1
  Dc.b "dot",0,#_long,-1
  Dc.b "customs",0,#_long,-1
  Dc.b "dob",0,#_long,-1
  Dc.b "bot",0,#_word,-1
  Dc.b "numbp",0,#_word,-1
  Dc.b "colpokes",0,#_word,-1
  Dc.b "fetchwid",0,#_word,-1
  Dc.b "xand",0,#_word,-1
  Dc.b "xshift",0,#_word,-1
  Dc.b "ypos",0,#_word,-1
  Dc.b "height",0,#_word,-1
  Dc.b "res",0,#_word,-1
  Dc.b "numsprites",0,#_word,-1
  Dc.b "numcols",0,#_word,-1
  Dc.b "numcustoms",0,#_word,-1
  Dc.b "cpline",0,#_word,-1
  Dc.b "x0",0,#_quick,-1
  Dc.b "x1",0,#_quick,-1
  Dc.b "bplcon3",0,#_word,-1
  Dc.b "aga",0,#_word,-1
  Dc.b 0

GTListType:
  Dc.w 16
  Dc.b "GTList",0
  Dc.b "gadptr",0,#_long,-1
  Dc.b "visualinfo",0,#_long,-1
  Dc.b "current",0,#_long,-1
  Dc.b "windowptr",0,#_long,-1
  Dc.b 0

MapObjType:
  Dc.w 32
  Dc.b "MapObject",0
  Dc.b "width"    ,0,#_word,-1
  Dc.b "height"   ,0,#_word,-1
  Dc.b "bwidth"   ,0,#_word,-1
  Dc.b "bheight"  ,0,#_word,-1
  Dc.b "datasize" ,0,#_byte,-1
  Dc.b "mapnull"  ,0,#_byte,-1
  Dc.b "*mapdata" ,0,#_long,-1
  Dc.b "viewx"    ,0,#_word,-1
  Dc.b "viewy"    ,0,#_word,-1
  Dc.b "*mapname" ,0,#_string,-1
  Dc.b 0

GTMenuListType:
  Dc.w 16
  Dc.b "GTMenuList",0
  Dc.b "*Menulist",0,#_long,-1
  Dc.b "*Privatelist",0,#_long,-1
  Dc.b "numitems",0,#_word,-1
  Dc.b 0


Even
.@prefsstruct
initstate:
  Dc.b 0                                                   ; major version number of debugger that stored the config
  Dc.b 0                                                   ; minor version number of debugger that stored the config
  Dc.w #SCR_WB                                             ; actual screen type
  Dc.l $8000                                               ; Screen mode ID
  Dc.w 640                                                 ; Screen width
  Dc.w 256                                                 ; Screen height
  Dc.b -1                                                  ; Tokenize
  Dc.b 0                                                   ; public screen
  Dc.w 2048                                                ; max window height
  Dc.w #save_numwindows                                    ; number of window definitions
                                                           ; --- window settings: status (0=closed),x,y,width,height
  Dc.w -1,0,11,640,256                                     ; window Source
  Dc.w -1,0,11,640,14                                      ; window Control
  Dc.w  0,0,37,640,87                                      ; window Registers
  Dc.w  0,0,0,0,0                                          ; window Backdrop
  Dc.w  0,432,124,208,256-124                              ; window Mem1
  Dc.w  0,432,124,208,256-124                              ; window Mem2
  Dc.w  0,0,11,420,100                                     ; window Search
  Dc.w  0,0,11,320,128                                     ; window Variable
  Dc.w  0,0,11,320,128                                     ; window 680x0 Disassembly
  Dc.w  0,0,11,320,128                                     ; window Copper Disassembly
  Dc.w  0,0,11,320,128                                     ; window Custom chip registers
  Dc.w  0,0,11,320,128                                     ; window Array
  Dc.w  0,0,11,160,200                                     ; window Label List
                                                           ; --- Options
  Dc.b 0                                                   ; Status of ProcedureStep
  Dc.b 0                                                   ; Status of Blitzcontrol
  Dc.b 0                                                   ; Status of GosubStep
  Dc.b 0                                                   ; default Public screen
  Dc.b 0                                                   ; show syntax help

disasmlockstr:
  Dc.b "pc-2",0 : Ds.b 128-5
                                                           ; --- window settingf for wizard windows
  Dc.w #wizardwindows                                      ; beginning index number of wizard windows to load
  Dc.w 0,0,11,420,100                                      ; window FPU Reg

  Dc.b -1                                                  ; show linenumbers
  Dc.b -1                                                  ; log trace

endof_init:
  Even

sizeofPrefs:        Dc.w endof_init-initstate

help_menus:         Dc.b "MENUS",0
help_about:         Dc.b "ABOUT",0
help_cntrlwin:      Dc.b "WIN_PROGCNTRL",0
help_source:        Dc.b "WIN_SOURCE",0
help_configuration: Dc.b "NODEconfiguration",0
help_screenmode:    Dc.b "NODEscrmode",0
help_reg:           Dc.b "WIN_REGS",0
help_mem:           Dc.b "WIN_MEM",0
help_var:           Dc.b "WIN_VARS",0
help_asm:           Dc.b "WIN_DISASM",0
help_cop:           Dc.b "WIN_COPPER",0
help_gs:            Dc.b "NODEgosubstep",0
help_ps:            Dc.b "NODEproccontrol",0
help_bc:            Dc.b "NODEblitzcontrol",0
help_search:        Dc.b "WIN_SEARCH",0
help_array:         Dc.b "WIN_ARRAY",0
help_struct:        Dc.b "WIN_STRUCTURES",0
help_chips:         Dc.b "WIN_CUSTOMCHIPS",0
help_labels:        Dc.b "WIN_LABELLIST",0
help_objects:       Dc.b "WIN_OBJECTS",0
help_autoeval:      Dc.b "NODEautoeval",0
help_breakpoints:   Dc.b "NODEbreakpoints",0
help_fpu:           Dc.b "WIN_FPU",0
help_asmstep:       Dc.b "WIN_ASMSTEP",0
help_watch0:        Dc.b "WIN_WATCH0",0

Even
wzgui:              IncBin "reddebug.wizard"
Even


fpuffp
  fpu.l = PutRegD0
  ffp   = SPFieee_(ffp) ; for mathtranspointer
  GetRegD0 fpu
  JSR -$6c(a6)
  MOVE.l d0,ffp@(a5)
Return


.setfpu:
  fpuRegValues$(temp) = RTEZGetString("Insert FPU Value","Insert FPU Value",80,fpuRegValues$(temp))

  ;OPTIMIZE 7 ; this requires an FPU      why ??? Val() has been updated
  ffp = Val(fpuRegValues$(temp))
  ;OPTIMIZE 5

  ffp2.f = SPTieee_(ffp2) ; for mathtranspointer
  MOVE.l ffp@(a5),d0
  JSR -102(a6)
  fmove.s d0,fp0
  MOVE.l regpos,a0 : ADD.l fpuoffset,a0
  GetRegD0 temp : MULS #12,d0 : ADD.w d0,a0
  Dc.l $f2106800    ;fmove.x fp0,(a0)
  RedrawRegs{}
Return


.getterm:     ;in: *ptr , xpos , i ; ret: part$
  inbrack.l = 0
  poin$     = ""
  log2PED{"Getting the term at mouse position: " + Peeks$(*ptr,32)}

  temp = Peek.b(*ptr + xpos)
  If temp = @"\"
;    If Peek.l(i) AND $80000000
;      i3.l = (Peek.l(i) AND $7fffffff)+sourceWindow\startcode
;    Else
;      i3 = Peek.l(i)
;    EndIf
;    Repeat
;      il3.l = Peek.l(i3+4):
;      If Peek.l(il3)=i3
;         i3 = il3
;      Else
;        i3 = 0
;      EndIf
;      If i3
;         p$ = peek.s (i3+9)
;         If Instr(p$,Mki$ ($80ca))
;           InitArgParse p$
;           ret$  = NextArg$
;           path$ = NextArgChar$(@" ","","")
;           i3    = 0
;         EndIf
;      EndIf
;    Until i3 = 0
    typepath$ = RTEZGetString(redData\appTitle,"Insert a path for newtype begin with \",128,path$)
  EndIf
  If temp = @"*" Then poin$ = "*"
  If temp = @"#" Then poin$ = "#"
  
  _wloop:
    temp = Peek.b(*ptr + xpos)

    xpos-1

    ;If temp = $2e OR temp = 36 OR temp = 45 Then Goto _wloop
    If temp = @"." OR temp = @"$" OR temp = @"-" OR temp = @"#" Then Goto _wloop ; added the check of '#' DisAsm can identify Values and adresses  tomsmart1
    If temp = @"+" Then Goto _wout
    If temp = @"\"
      If Peek.l(i) AND $80000000
        i3.l = (Peek.l(i) AND $7fffffff) + sourceWindow\startCode
      Else
        i3 = Peek.l(i)
      EndIf
      Repeat
        il3.l = Peek.l(i3 + 4)          ; :
        If Peek.l(il3) = i3
          i3 = il3
        Else
          i3 = 0
        EndIf
        If i3
          p$ = Peek.s (i3+9)
          If Instr(p$,Mki$ ($80ca))
            InitArgParse p$
            ret$ = NextArg$
            If typepath$ = ""
              path$ = NextArgChar$(@" ","","")
            Else
              path$ = typepath$
            EndIf
            i3 = 0
          EndIf
        EndIf
      Until i3 = 0
    EndIf
    If temp = @"{" Then xpos+1 : Goto _wout
    If temp >= $30 AND temp <= $39 Then Goto _wloop ; 0-9
    If temp < $40 Then xpos+1 : Goto _wout
    If xpos < 0 Then Goto _wout
  Goto _wloop
 _wout:
  xpos + 1 : schar.l = xpos

  temp = Peek.b (*ptr + xpos)
  If temp = @"$" OR temp = @"-" Then xpos + 1 
  If Peek.b(*ptr + xpos) = @"$" Then xpos + 1
 _wloop2:
    temp = Peek.b(*ptr + xpos)
    If temp = @"(" Then inbrack+1
    If temp = @")" AND inbrack = 0  Then Goto _wout2
    If temp = @"-" AND inbrack <> 0 Then Goto _weit1
    If temp = @" " AND inbrack <> 0 Then Goto _weit1
    If temp = $22  AND inbrack <> 0 Then Goto _weit1
    If temp = @")" Then inbrack-1
    If temp = @"}" Then Goto _wout2
    If inbrack <> 0 AND temp = @"," Then Goto _weit1
    If temp = @"." OR temp = @"(" OR temp = @")" OR temp = @"$" OR temp = @"*" OR temp = @"#" Then Goto _weit1
    If temp >= $30 AND temp <= $39 Then Goto _weit1
    If temp < $40 Then Goto _wout2

   _weit1:
    xpos + 1
  Goto _wloop2

 _wout2:
  part$ = Peeks$(*ptr + schar,xpos - schar)
  log2PED{"mouse clicked on: [" + part$ + "]"}
Return


.storefpuregs:
  TST.l regpos : BEQ 'skip
    TST.l fpuoffset : BEQ 'skip
      MOVE.l regpos,a0 : ADD.l fpuoffset,a0
      MOVEQ #7,d0
      LEA fpustore,a1
     'l1
        MOVE.l (a0)+,(a1)+
        MOVE.l (a0)+,(a1)+
        MOVE.l (a0)+,(a1)+
      DBF d0,'l1
 'skip
RTS


.restorefpuregs:
  TST.l regpos : BEQ 'skip 
    TST.l fpuoffset : BEQ 'skip
      MOVE.l regpos,a0 : ADD.l fpuoffset,a0
      MOVEQ #7,d0
      LEA fpustore,a1
     'l1
        MOVE.l (a1)+,(a0)+
        MOVE.l (a1)+,(a0)+
        MOVE.l (a1)+,(a0)+
      DBF d0,'l1

  'skip
RTS


.@addhistory
addhistory ; d0 linenum
  MOVEM.l a0/d1,-(a7)
  LEA history,a0
  MOVEQ #0,d1
  MOVE.w historypointer,d1
  GetRegD0 disasm_ad
  MOVE.l d0,0(a0,d1)
  ADDQ.w #4,d1
  CMP.w  #maxhistory*4,d1 : BLE 'nowrap
    MOVEQ #0,d1
 'nowrap
  MOVE.w d1,historypointer
  MOVEM.l (a7)+,a0/d1
RTS


addmemhistory ; d0 linenum
  MOVEM.l a0/d1,-(a7)
  LEA memhistory,a0
  GetRegD0 mempointer(1)
  MOVEQ #0,d1
  MOVE.w memhistorypointer,d1
  MOVE.l d0,0(a0,d1)
  ADDQ.w #4,d1
  CMP.w  #maxhistory*4,d1 : BLE 'nowrap
    MOVEQ #0,d1
 'nowrap
  MOVE.w d1,memhistorypointer
  MOVEM.l (a7)+,a0/d1
RTS


memhistoryup
.jump_memhistoryup
  MOVE.l a1,-(a7)
  LEA memhistory,a0
  MOVE.w memhistorypointer,d1
  SUBQ #4,d1 : BPL 'l10
    MOVEQ #maxhistory*4,d1
 'l10
  MOVE.w d1,memhistorypointer
  MOVE.l 0(a0,d1.w),d0
  PutReg d0,mempointer(1)
  RedrawMem{}
  MOVE.l (a7)+,a1
RTS


memhistorydown
.jump_memhistorydown
  MOVE.l a1,-(a7)
  LEA memhistory,a0
  MOVE.w memhistorypointer,d1
  ADDQ #4,d1
  CMP.w #maxhistory*4,d1 : BLE 'l10
    MOVEQ #0,d1
 'l10
  MOVE.w d1,memhistorypointer
  MOVE.l 0(a0,d1.w),d0
  PutReg d0,mempointer(1)

  RedrawMem{}
  MOVE.l (a7)+,a1
RTS


historyup
.jump_historyup
  MOVE.l a1,-(a7)
  LEA history,a0
  MOVE.w historypointer,d1
  SUBQ #4,d1
  BPL 'l10
  MOVEQ #maxhistory*4,d1

 'l10
  MOVE.w d1,historypointer
  MOVE.l 0(a0,d1.w),d0
  disasm_ad = PutRegD0
  UpdateDisAsm{}
  MOVE.l (a7)+,a1
RTS


historydown
.jump_historydown
  MOVE.l a1,-(a7)
  LEA history,a0
  MOVE.w historypointer,d1
  ADDQ #4,d1
  CMP.w #maxhistory*4,d1
  BLE 'l10
  MOVEQ #0,d1

 'l10
  MOVE.w d1,historypointer
  MOVE.l 0(a0,d1.w),d0
  disasm_ad=PutRegD0
  UpdateDisAsm{}
  MOVE.l (a7)+,a1
RTS

Even
; subroutine from code of addtrace to use it in deltrace too  tomsmart1 2016 02 14
.GetVariableNameAndType:
  na$ = RTEZGetString(varfollow$,"Enter variable name:",80,part$)
  If na$ <> ""
    a$ = Left$(na$,1)
    
    Select a$
    Case "%" : nf = 3
    Case "$" : nf = 2
    Default  : nf = 1
    End Select
    
    If nf <> 1 Then na$ = Mid$(na$,2)
    nt = -1
    If Right$(na$,1) = "$" Then nt = 4
    
    If Len(na$) > 2 AND Mid$(na$,Len(na$)-1,1) = "."
      nt  = Instr(objtype$,LCase$(Right$(na$,1)))  ; try to get type of the variable
      na$ = Left$(na$,Len(na$)-2)
    EndIf

    If nt = -1 Then nt = RTEZRequest(varfollow$,"Enter variable type:","_b|_w|_l|_s|_q|_f|_Cancel")
  Else
    nt = -1
  EndIf
Return

Even
memhistorypointer:  Dc.l 0
historypointer:     Dc.l 0
regpos:             Dc.l 0
fpreg:              Dc.l 0
fpuoffset:          Dc.l 0
currlinestart:      Dc.l 0
Even
BSS
history:            Ds.l #maxhistory+2
memhistory:         Ds.l #maxhistory+2
fpustore:           Ds.l 3*9
programstart:       Ds.l 1
programsize:        Ds.l 1
trap15addr:         Ds.l 1
direktbuffer:       Ds.b 4096
