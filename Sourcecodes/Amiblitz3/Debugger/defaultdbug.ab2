optimize 5     ;dont use fpu because all calc must in FFP!!!!
XINCLUDE "dos.include.bb2"

; Changelog
; 2.70
; add a check for OS4 to remove the programsize Bug
; 2.69
; changed: fixes a forgotten peeks()
; 2.68
; changed: replaced PeekS() with Peek.s()
; 2.67
; ??
; 2.66
; changed:  old Blitz2:-Assigns updated to Blitz3
; changed:  requester
; changed:  helpfunction uses AB3HelpViewer now


; LIBRARY CHANGES MADE TO ACIDLIBS:
;  DebugLib      - Loads of changes including extra handlers,
;                  new return values of extra TRAP checking
;                  BLITZ MODE support - special controls
;  Switchlib     - BLITZ MODE support - special controls
;  StringFuncLib - Hexb$, Hexw$, Binb$, Binw$
;  ValLib        - ValLong()
;  Gadgetslib    - New prop gadget commands / Arrow Gadgets

; EXTRA LIBS NEEDED to compile:
;  LESDebugLib   - custom commands for the debugger
;                  (including COPPER disasm)
;  RIDisAsm      - Program disassembly
;  NeilsReqtoolsLib
;  RISortLib     - sorting names into alphabetical order

; LIBS NEEDED to use:
;  DebugLib      - MUST HAVE THIS UPDATE INSTALLED!
;  Switchlib     - MUST HAVE THIS UPDATE INSTALLED!
;  RIDebugLib    - optional but very useful

;Written by
;  different people


;***********************************************************
; Constants
;ATTENTION dont use variable i (it is the sourceline address)
#longs = 0             ; show mem in longs  (not yet)
#lowestaddr = 1024     ; to avoid enforcer hits
#maxhistory = 10
;Debuginfo in Code
;trap #1     structsize =10 ($a)Bytes
;dc.l sourcelineaddr from ted
;dc.w 9
;dc.w offset to next trap #1
#test = 0
#BACKGROUND_DBUG    =1



#save_numwindows  =13
#wizardwindows    =24
#dbug_version     =2
#dbug_revision    =5
#IDENTIFIER       =$44425547    ; "DBUG"
#MAXCUSTOMCOMMANDS=20

#bufflen          =4096
#buffand          =#bufflen-1

;Evaluate request types:
#_null00          =0
#_memwindow       =1
#_newtypewindow   =2      ; REMOVED
#_newtypewindowmax=3      ; REMOVED
#_variablelocate  =4
#_disasmaddress   =5
#_autoevalresult  =6
#_discopaddress   =7
#_arrayfind       =8
#_structaddress   =9
#_mouseable_eval  =10
;EXECute types:
#_viewblitz       =50
#_newtypewindow   =51

;Window allocation
#_winSource       =0
#_winControl      =1
#_winRegisters    =2
#_winBackdrop     =3
#_winMemory1      =4
#_winMemory2      =5
#_winSearch       =6
#_winVariables    =7
#_winDisAsm       =8
#_winDisCop       =9
#_winCustom       =10
#_winArray        =11
#_winMouseables   =12
#_winObject0      =13
#_winObject9      =22
#fpuwin           =23
#bubble           =24
#noresize         =%10001000110

;Windows that require the special gadget down handling
;(provides 'key repeat' type handling for gadgets)
;If not set here, a windows #IDCMP_GADGETDOWN events are ignored
#gadgetdown       =%11111111111111111110000000000000+(0 BitSet #_winSource)+(0 BitSet #_winMouseables)+(0 BitSet #_winArray)
;Gadgets
#SRC_SGAD         =1          ; Source window
#SRC_LGAD         =2
#SRC_RGAD         =3
#MSE_SGAD         =4          ; Mouseables window
#MSE_UGAD         =5
#MSE_DGAD         =6
#OBJ_SGAD         =7
#OBJ_UGAD         =8
#OBJ_DGAD         =9
#ARR_YGAD         =10
#ARR_XGAD         =11
#ARR_UGAD         =12
#ARR_DGAD         =13
#ARR_LGAD         =14
#ARR_RGAD         =15

;Debug library commands:
#_addtrace        =255
#_deltrace        =254
#_varwindow       =253
#_diswindow       =252
#_copperlist      =251
#_proccontrol     =250
#_memwindowmove   =249

;Variable types
#_byte            =1
#_word            =2
#_long            =3
#_string          =4
#_quick           =5
#_float           =6

#SCR_WB           =0
#SCR_LIKEWB       =1
#SCR_CUSTOM       =2
#SCR_DEFPUB       =3
#SCR_NAMEDPUB     =4

;Max breakpoints
#maxbreakpoints   =5

;Breakpoint types
#break_permanent  =1
#break_count      =2
#break_simple     =3
#break_countdown  =4

;Windows that cannot be opened from LoadConfig in openwindow
#winprotect       =%100000001010

#RUNNING          =0
#TRACE            =1
#STOPPED          =2
#BLITZMODE        =3

#NOSIGNAL         =0
#SIGNAL           =1

;Screentags tags
#Left             =$80000021
#Top              =$80000022
#Width            =$80000023
#Height           =$80000024
#_Depth           =$80000025
#DetailPen        =$80000026
#_BlockPen        =$80000027
#Title            =$80000028
#Colors           =$80000029
#ErrorCode        =$8000002A
#Font             =$8000002B
#SysFont          =$8000002C
#_Type            =$8000002D
#_BitMap          =$8000002E
#PubName          =$8000002F
#PubSig           =$80000030
#PubTask          =$80000031
#DisplayID        =$80000032
#DClip            =$80000033
#Overscan         =$80000034
#Obsolete1        =$80000035

#ShowTitle        =$80000036
#Behind           =$80000037
#_Quiet           =$80000038
#AutoScroll       =$80000039
#Pens             =$8000003A
#FullPalette      =$8000003B
#ColorMapEntries  =$8000003C
#Parent           =$8000003D
#Draggable        =$8000003E
#Exclusive        =$8000003F

#SharePens        =$80000040
#BackFill         =$80000041
#_Interleaved     =$80000042
#Colors32         =$80000043
#VideoControl     =$80000044
#FrontChild       =$80000045
#BackChild        =$80000046
#LikeWorkbench    =$80000047
#Reserved         =$80000048

#AUTOKNOB         =$0001  ; this flag sez:  gimme that old auto-knob
#FREEHORIZ        =$0002  ; if set, the knob can move horizontally
#FREEVERT         =$0004  ; if set, the knob can move vertically
#PROPBORDERLESS   =$0008  ; if set, no border will be rendered
#KNOBHIT          =$0100  ; set when this Knob is hit
#PROPNEWLOOK      =$0010  ; set this if you want to get the new
                          ; V36 look
#GFLG_RELBOTTOM   =$0008 ; set if rel to bottom, clear if to top
#GFLG_RELRIGHT    =$0010 ; set if rel to right, clear if to left
; set the GFLG_RELWIDTH bit to spec that Width is relative to width of screen
#GFLG_RELWIDTH    =$0020
; set the GFLG_RELHEIGHT bit to spec that Height is rel to height of screen
#GFLG_RELHEIGHT   =$0040

#RIGHTREL         =%1
#BOTTOMREL        =%10
#RIGHTBORDER      =%100
#BOTTOMBORDER     =%1000

#VPROP_AFLAGS     =#GFLG_RELRIGHT|#GFLG_RELHEIGHT
#VPROP_PFLAGS     =#AUTOKNOB|#FREEVERT|#PROPBORDERLESS|#PROPNEWLOOK
#HPROP_AFLAGS     =#GFLG_RELBOTTOM|#GFLG_RELWIDTH
#HPROP_PFLAGS     =#AUTOKNOB|#FREEHORIZ|#PROPBORDERLESS|#PROPNEWLOOK

#RK_HELP          =$5F

;check for OS4
succ.l=dos_CheckLib{"exec.library",50}
If succ
  os4_present.b=1
Else
  os4_present=0
EndIf

;***********************************************************
; Newtypes

Macro versions
"2.70"
End Macro

NEWTYPE .prefstype
  fontname.s
  fontsize.l
End NEWTYPE

NEWTYPE.wininfotype
  x.w : y.w : w.w : h.w : flags.l : title$ : gadlist.w
  helplink.l
End NEWTYPE

NEWTYPE.variabletype
  name$                 ; name of variable
  address.l             ; address of variable
  typ.b                 ; type=1-6
  form.b                ; 0=dec, 1=hex, 2=binary
End NEWTYPE

NEWTYPE.d_event         ;a debug event!
                        ;
t.w                     ;type...0=supervisor error
                        ;       1=user error
                        ;       2=eval result
                        ;       3=trace this line...
                        ;       4=end
                        ;
i.w                     ;buffer put val!
s$                      ;string
                        ;
End NEWTYPE

NEWTYPE.structurewindow
  objadr.l              ; Object type definition address
  objbaseadr.l          ; BASE address for object, e.g. addr object(0)
  typepointer.l         ; Address of object
  mem_type.l            ; Pointer to block of mem holding
                        ; type information
  type_sizeof           ; Sizeof.type
  winnum.b              ; Allocated window for object
  numitems.b
  is_bbobject.w         ; Is this a Blitz object type?
  tracenum.w            ; Currently traced number
  maxobject.w           ; Maximum object number
  typewidth.w           ; Max width of \type text
  t$                    ; Name of type
End NEWTYPE

;Info block returned from RTEZScreenModeRequest
;NEWTYPE.screeninfo
;  id.l                  ;Screen mode ID
;  width.w               ;width
;  height.w              ;height
;  _depth.w              ;depth
;  overscan.w            ;overscan type
;  autoscroll.l          ;autoscroll status
;End NEWTYPE

;***********************************************************
; Variable type declarations
DEFTYPE.b dowin,objectbusy,pmode,pmodevalid,end_init
DEFTYPE.b evalrequest,execrequest,autoeval
DEFTYPE.b kbshift,nt,nf,flag,editflag
DEFTYPE.b mflag,winnum,searchtype,memchecktimer
DEFTYPE.w gosubstatus,bitm,tokenise,exitflag
DEFTYPE.w reply,num,tracenum,xadm,pfregs
DEFTYPE.w wx,wy,sw,sh,a,mytype,jump,mylen,maxheight
DEFTYPE.w Ascii,mysr,old_dstatus,procstatus,blitzcontrol
DEFTYPE.w xarraynum,yarraynum,arraytype,xarrayoff,yarrayoff
DEFTYPE.w swidth,sheight,arraydatasize,arraylabelsize,arrayitemsize
DEFTYPE.w bp,evalrequestex,num_mouseables,mouseables_off
DEFTYPE.w old_active_win,active_win,n,source_char_offset
DEFTYPE.w scrmode,signal,newted
DEFTYPE.l disasm_ad,typepointer,maxobject,ad,si,areg,old_ad,ad1,ad2
DEFTYPE.l ev,evq,evw,mem,dreg,token_addr
DEFTYPE.l array1,array2,ModeID,stepnumber,breakpoint_adr
DEFTYPE.l mouseables,rp,task,signalset
DEFTYPE.l arexxport
DEFTYPE.l
DEFTYPE.q mq
DEFTYPE.f mf,ffp

DEFTYPE.l address,address2,memadr
DEFTYPE.w winheight,ox,oy,ow,typelength,typewidth

DEFTYPE.Gadget *arrowgad
DEFTYPE._Screen scr
. @begin
prefs.prefstype\fontname="topaz.font",8
stepnumber = 1
searchtype = 1
dowin = -1
pmodevalid = 0
configsize.l = Peek.w(?sizeofsave)
array$ = ""
Dim src.s(200)
Dim dis.s(200)
Dim mem.s(200)
Dim fp$(8)

proz.l = Processor ; needed for fpu register pos
If proz = 3 OR proz = 2 Then MOVE.l #-200,fpuoffset       ;020/030
If proz = 4             Then MOVE.l #-200+24,fpuoffset    ;040
If proz = 5             Then MOVE.l #-200+18,fpuoffset    ;060

;***********************************************************
; Arrays and lists

Dim List varinfo.variabletype(19)
Dim List d_e.d_event(50)
Dim List objwins.structurewindow(9)
Dim wininfo.wininfotype(Maximum Window)
Dim memwin.w(1),mempointer.l(1),memlock$(1),memlockpf$(1)
Dim winstatus.w(Maximum Window)
Dim customcomm$(#MAXCUSTOMCOMMANDS)

mempointer(0) = 0 : mempointer(1)=0
objtype$ = "bwlsqf"
old_active_win = -1
active_win = -1
breakpoint_adr = ?breakpoint
breakstore.l = ?breakstore
;***********************************************************
; Some strings......

typetitle$ = ""
warn1$ = "REDDebugger is attempting to close its screen.  Please"+Chr$(10)
warn1$ + "close all visitor windows."

sr$ = String$(Chr$(0),5)
rega$ = String$(" ",31+16)
regb$ = String$(" ",4)
laststructure$ = ""
scrtitle$ = "RED Debugger v"+!versions
varfollow$ = "Variable trace"
cntrlwin$ = "Program mode:       "  ; 6 spaces in string for mode!

MaxLen autoeval$ = 80
MaxLen strg$ = 128
MaxLen ex$ = 128
MaxLen ev$ = 128
MaxLen evalbuffer$ = 256

; ==================================================
Gosub StartOfDayInit

CNIF #BACKGROUND_DBUG
.BACKGROUND:
; Right, we need some global variables...
; -  msgport.l      is the address of Debugger's message port
; -  msgportname$   is the name of Debugger's message port
; -  msg.l          is the address of Debugger's message

rexxwiny.w=11
rexxwinx.w=0
rexxportname$="REDDebugger"
Statement CreateDebuggerPort{}
  SHARED  rexxport.l,rexxportname$
  rexxport.l=CreateMsgPort_
  If rexxport
    Poke.l rexxport+10,&rexxportname$
    AddPort_ rexxport
  EndIf
End Statement

Statement ReplyDebuggerMsg{}
  SHARED msg.l,rexxport.l
  If rexxport=0 Then Statement Return
  If msg Then ReplyMsg_ msg
  msg=0
End Statement
Statement DeleteDebuggerPort{}
  SHARED rexxport.l
  If rexxport=0 Then Statement Return
  RemPort_ rexxport
  DeleteMsgPort_ rexxport
End Statement

  If FindPort_(&rexxportname$)
    a=RTEZRequest(scrtitle$,"    Already running!    ","  _Ok  ")
    End
  EndIf
  CreateDebuggerPort{}
  AddWaitEvent PortSigBit(rexxport),$10000000  ; add port to WaitEvent
  background_redo.w=1
  Repeat
    If background_redo
      *scr._Screen=GetPubScreen(0,"Workbench")
      textlen.w=TextLength_(*scr\_RastPort,scrtitle$,Len(scrtitle$))
      If background_redo=1 Then rexxwiny=*scr\BarHeight+1
      Window 0,rexxwinx,rexxwiny,textlen+64,*scr\BarHeight+1,$21000e,scrtitle$,-1,-1 ;rexxportname$,-1,-1
      background_redo=0
    EndIf
    ev = WaitEvent                             ;close mini win
    If ev = $10000000
      rexxwinx = WindowX
      rexxwiny = WindowY
      DetachGTList 0
      Free Screen 0
      ReleasePubScreen 0,"Workbench"
      msg = 1
      While msg<>0
        msg = GetMsg_(rexxport)
        If msg
          ad.l = Peek.l(msg+20)
          If Peek.l(msg + 24) = #IDENTIFIER
            GetReg a0,ad
            MOVE.l a0,d_table
            MOVE.l a5,d_a5
            MaxLen d_d$=256:MaxLen d_ev$=256:MaxLen d_ex$=256
            Poke.l ?d_dadd,&d_d$
            statego.w=0:dstatus.w=0:prtcode.w=0:Poke.l ?statego_,&statego
            buffmem.l=AllocMem_(#bufflen,$10001):Poke.l ?buffmem_,buffmem:CLR bufferput
            FillArray winstatus(),0
            ReplyDebuggerMsg{}
            Gosub mainstart
            ;FillArray winstatus(),0
            FillArray memwin(),0
            FillArray mempointer(),0
            ClearList varinfo()
            ClearList d_e()
            ClearList objwins()
            ali.l=0 : lt$="" : task=0 : autoeval=0 : autoeval$=""
            pfregs=0
            Poke.b comdata+$1ea,0
          EndIf
          ;ReplyDebuggerMsg{}

        EndIf
      Wend
      background_redo = 2
    Else
      If ev = $200 Then DeleteDebuggerPort{} : End
    EndIf
  Forever
CELSE
  MOVE.l 4,a0:MOVE.l 276(a0),a0:MOVE.l 88(a0),d_table
  MOVE.l a5,d_a5
  MaxLen d_d$=256:MaxLen d_ev$=256:MaxLen d_ex$=256
  Poke.l ?d_dadd,&d_d$
  statego.w=0:dstatus.w=0:prtcode.w=0:Poke.l ?statego_,&statego
  buffmem=AllocMem_(#bufflen,$10001):Poke.l ?buffmem_,buffmem:CLR bufferput
  Gosub mainstart
  End
CEND

Macro d_call
  MOVE.l d_table,a2:MOVE.l `1 LSL 2(a2),a2:JSR (a2)
End Macro

Statement d_sethandler{adr.l}
  SHARED token_addr,task,signal,signalset

  LEA htable(pc),a0:!d_call{2}
  MOVE.l a0,mybuffer
  MOVE.l a1,progmode
  PutReg a2,token_addr
  PutReg a3,task         ;blitz program process
  PutReg d0,signal
  signalset=(0 BitSet signal)
  TST.b newdebug
  BEQ nd1
  MOVE.l comdata@(a5),a0
  MOVE.l $7b8(a0),token_addr@(a5)
  MOVE.l $7e6(a0),a0
  MOVE.l #direktbuffer,(a0)
  temp.l=cr_vbr
  MOVE.l d0,a0
  MOVE.l trap15addr,$bc(a0)

nd1:
End Statement
Function$ d_detoke{sa.l}
  SHARED d_d$

  GetReg a0,sa:GetReg a1,&d_d$
  !d_call{3}
  Function Return d_d$
End Function
Function.l getad {ad.l}
SHARED startcode.l
i2=Peek.l(ad)
If Peek.l(ad) AND $80000000
     i2=i2 AND $7fffffff
     If startcode=0
      GetD0 ad:MOVE.l d0,a0
      MOVE.l #"DuCk",d1
      MOVE.l #"AmiB",d2
      MOVE.l #10 000 000,d0
'loop ADDQ.l #1,a0
      CMP.l (a0),d1
      BEQ 'loop1
      SUBQ.l #1,d0
      BNE 'loop
      BRA 'loop3
'loop1 CMP.l 4(a0),d2
       BNE 'loop
       MOVE.l a0,d0
       startcode=PutD0
       startcode=Peek.l(startcode+8)
'loop3
     End If
     Function Return i2+startcode
Else
     Function Return Peek.l(ad)
End If
End Function
.getad2
Function.l getad2 {ad.l}
SHARED startcode.l
i2=Peek.l(ad)
If Peek.l(ad) AND $80000000
     i2=i2 AND $7fffffff
     If startcode=0
         GetD0 ad:MOVE.l d0,a0
         MOVE.l #"DuCk",d1
         MOVE.l #"AmiB",d2
         MOVE.l #10 000 000,d0
       'loop ADDQ.l #1,a0
         CMP.l (a0),d1
         BEQ 'loop1
         SUBQ.l #1,d0
         BNE 'loop
         BRA 'loop3
       'loop1 CMP.l 4(a0),d2
          BNE 'loop
          MOVE.l a0,d0
          startcode=PutD0
          startcode=Peek.l(startcode+8)
       'loop3
     End If
     Function Return i2+startcode
Else
     Function Return ad
End If
End Function

Statement d_eval{t$,dosignal.w}
  SHARED d_ev$,stepcnt,task,signalset,dstatus
  CNIF #test=0
    d_ev$=t$:GetReg a0,&d_ev$:!d_call{4}
    If dosignal=#SIGNAL
      If dstatus=#STOPPED
        stepcnt+1
        Signal_ task,signalset
      EndIf
    EndIf
  CELSE
    EZRequest "ILLEGAL TEST MODE d_eval{} CALL"
  CEND
End Statement

Statement d_exec{t$}
  SHARED d_ex$,stepcnt,task,signalset,dstatus
  CNIF #test=0
    d_ex$=t$:GetReg a0,&d_ex$:!d_call{5}
    If dstatus=#STOPPED
      stepcnt+1
      Signal_ task,signalset
    EndIf
  CELSE
    EZRequest "ILLEGAL TEST MODE d_exec{} CALL"
  CEND
End Statement

Statement d_quit{}
  SHARED stepcnt,task,signalset
  If dstatus<>#STOPPED
  !d_call{1}
  stepcnt=0
  Delay_ 2
  End If
   ;quit the debugger
  !d_call{6}
  stepcnt+1
  Signal_ task,signalset

End Statement

Statement d_skip{}
  !d_call{8}
End Statement

Macro d_basic
  MOVE.l d_a5(pc),a5
End Macro

add_event
Statement add_event{t,s$}
  ;
  SHARED d_e()
  Forbid_
  If AddLast(d_e())
    d_e()\t=t
    MOVE bufferput(pc),d0:SUBQ #4,d0:AND #buffand,d0:PutReg d0,d_e()\i
    d_e()\s=s$
  EndIf
  Permit_
End Statement

progversion:
  Dc.b "$VER: REDDebugger "
  Dc.b !versions,0
  Even

varhandler:     Dc.l 0      ; Message waiting for debugger
mybuffer:       Dc.l 0      ; Pointer to registers!
progmode:       Dc.l 0      ; Pointer to word that hold program mode
                            ; <0= blitz, 0=amiga, >0=qamiga
d_dadd:         Dc.l 0
d_table:        Dc.l 0
d_a5:           Dc.l 0
statego_:       Dc.l 0
buffmem_:       Dc.l 0
bufferput:      Dc.w 0

htable:  ;handler table
Dc.l d_statehandler,d_superhandler,d_userhandler
Dc.l d_waithandler,d_evalhandler,d_cleanup
Dc.l d_vartracehandler,d_prochandler

._D_Handlers:
d_statehandler:
  MOVE.l buffmem_(pc),a1:ADD bufferput(pc),a1:MOVE.l 64(a0),(a1)
  ADDQ #4,bufferput:ANDI #buffand,bufferput

  MOVE.l    (a1),a0
  LEA       breakpoint(pc),a1
'check:
  TST.l     (a1)
  !SBEQ     {'skipit}
  CMP.l     (a1),a0
  !SBEQ     {'ok}
  ADDQ.l    #8,a1
  !SBRA     {'check}
'skipit:
  MOVE.l    statego_(pc),a1
  TST       (a1)
  RTS

'ok:
  CMPI.w    #break_simple,4(a1)
  !SBNE     {'noclear}
  SUB.w     #1,6(a1)                   ; Got simple breakpoint
  !SBEQ     {'clear_em}
  !SBRA     {'skipit}
'noclear:
  CMPI.w    #break_permanent,4(a1)
  BEQ       '_return
  ADD.w     #1,6(a1)
  !SBRA     {'skipit}

;move all following breakpoints down
'clear_em
  TST.l     (a1)
  !SBEQ     {'_return}
  ADDQ.l    #8,a1
  MOVE.l    (a1),-8(a1)
  MOVE.l    4(a1),-4(a1)
  !SBRA     {'clear_em}
'_return:
  MOVE.l    a5,-(a7)
  !d_basic
  Gosub     stopit
  MOVE.l    (a7)+,a5
  ST        donebreakpoint
  MOVE.l    statego_(pc),a1
  TST       (a1)
  RTS
donebreakpoint:Dc.w 0
breakpoint: Dc.l    0,0              ;0
            Dc.l    0,0              ;1
            Dc.l    0,0              ;2
            Dc.l    0,0              ;3
            Dc.l    0,0              ;4
            Dc.l    0,0              ;[reserved]
            Dc.l    0,0
breakstore:  Dc.w 0
            Dc.w 0
            Dc.w 0
            Dc.w 0
            Dc.w 0
            Dc.w 0
            Dc.w 0
d_superhandler:
  MOVE.l a7,regpos
  !d_basic:PutReg a0,sa.l
  Gosub stopit:add_event{0,Peek$(sa)}
  RTS

d_userhandler:
  !d_basic:PutReg a0,sa
  Gosub stopit:add_event{1,Peek$(sa)}
  RTS

d_waithandler:
  !d_basic
  TST.b   noredraw
  !SBNE   {label}
  If prtcode    ;print code out?
    prtbusy=-1
    add_event{3,""} ;print me out!
    Wait_ signalset
    While prtbusy:Delay_ 1:Wend  ;vwait wait till printed!
  EndIf
label:
  MOVE.l a7,regpos
  If pfregs=0 Then PFRegisters Peek.l(?mybuffer) : pfregs=-1
  SF      noredraw
  If dstatus=#STOPPED  ;stopped?
    If stepcnt=0 Then Wait_ signalset    ;wait blitz dbug prg process
    stepcnt-1
  EndIf
  If (dstatus=#TRACE OR dstatus=#STOPPED) AND blitzcontrol
    MOVEQ #-1,d0
  Else
    If dstatus=#BLITZMODE Then dstatus=#STOPPED:BCHG #1,$bfe001
    MOVEQ #0,d0
  EndIf
  RTS

noredraw: Dc.w  0

d_evalhandler:
  ;
  !d_basic:PutReg a0,sa
  add_event{2,Peek$(sa)}
  ST    noredraw
  RTS

d_cleanup:
  ;
  !d_basic:add_event{4,""}:RTS

d_vartracehandler:
  MOVEM.l d0-d7/a0-a6,-(a7)
  'loop1:TST.l varhandler : !SBNE {'loop1}
  MOVE.l  a0,varhandler
  'loop2:TST.l varhandler : !SBNE {'loop2}
  MOVEM.l (a7)+,d0-d7/a0-a6
  RTS

;d0=0 for start of procedure
;d1=-1 for end of procedure
;Controlled by variable procstatus (not called by debuglib.obj
;unless procstatus is non-zero).
d_prochandler:
  TST.b   d1
  BNE     'setstop

'setgo:
  ADD.w   #1,proccount
  CMPI.w  #1,proccount      ; First procedure?
  !SBNE   {'exitthis}

  MOVE.l  statego_(pc),a1:TST (a1)
  !SBEQ   {'running}
  MOVE.w  #0,stopstate
  !d_basic
  old_dstatus=dstatus
  prtcode=0:dstatus=0:statego=0
'exitthis
  RTS

'setstop
  TST.w   proccount
  !SBEQ   {'exitthis}

  SUB.w   #1,proccount
  TST.w   proccount         ; Last procedure?
  !SBNE   {'exitthis}       ; Nope - continue running

  TST.w   stopstate         ; Was original state running?
  !SBNE   {'exitthis}       ; Nope - continue running then
;  MOVE.l  d0,procreturnval
  !d_basic
  prtcode=-1:stepcnt=0:dstatus=old_dstatus:statego=-1
  RTS

'running:
  MOVE.w  #-1,stopstate
  RTS

proccount:  Dc.w 0
stopstate:  Dc.w 0
procreturnval:Dc.l 0

;ad2=instruction pointer
;returns d_d$ instruction string
GETInstruction:
  GetReg a0,Peek.l(ad2)+9
  MOVE.l d_dadd(pc),a1:!d_call{3}:SUB.l d_dadd(pc),a1:SUBQ #1,a1
  MOVE.l d_dadd(pc),a0:MOVE.l a1,-(a0)
Return

;*****************************************************************
.Statements:
Statement DoHelp{a$}
  SHARED arexxport,scrtitle$
  SHARED pubname$

  If arexxport=0
    a.l=RTEZRequest(scrtitle$,"Online help not available because RexxMast"+Chr$(10)+"is not running.","  Ok  ")
    Statement Return
  EndIf

  If pubname$=""
    p$="Workbench"
  Else
    p$=pubname$
  EndIf

  GetPubScreen 1,p$
  ShowScreen 1
  ReleasePubScreen 1,p$
  Poke.l Addr Screen(1),0

  Use Screen 0
  If FindPort_("DEBUGGERHELP.1")
    RXSendCommand "DEBUGGERHELP.1","'link "+a$+"'"
  Else
    command$ = "run Blitz3:Tools/AB3HelpViewer -t " + a$
    command$ + " -d Blitz3:Docs/ -l REDDebugger -s " + p$
    Execute_ command$,0,0
  EndIf
End Statement

;Open a new window, based on the wininfo() array
Statement NewWindow{win.w}
  SHARED wininfo(),winstatus(),sw,sh,end_init,maxheight
  SHARED scrtitle$
  SHARED old_active_win,active_win

  DEFTYPE.w x,y,w,h,typ
  DEFTYPE.l f

  If win=#_winMemory1 OR win=#_winMemory2
    typ=1
    Poke.l ?__more+4,?__memwin
  Else
    Poke.l ?__more+4,?__norm
    Poke.l ?__tl_mh+4,maxheight
  EndIf
  x=wininfo(win)\x
  y=wininfo(win)\y
  w=wininfo(win)\w
  h=wininfo(win)\h
  f=wininfo(win)\flags
  If end_init
    f+$1000
    old_active_win=active_win
    active_win=win
  EndIf

  If (#noresize BitTst win)=0 AND typ=0
    ;If x+w>sw Then w=sw-x
    ;If y+h>sh Then h=sh-y
  Else
    ;If x+w>sw Then x=sw-w
    ;If y+h>sh Then y=sy.l-h
  EndIf
   Poke.l ?__gimmi+4,0
   AddIDCMP #IDCMP_MOUSEMOVE
     If win=#_winSource
        AddIDCMP #IDCMP_MOUSEMOVE
        f=f OR #WFLG_REPORTMOUSE
        ;Poke.l ?__gimmi+4,1
     End If
     f=f OR #WFLG_REPORTMOUSE
  Poke.l ?__tl_scr+4,&scrtitle$
  Poke.l ?__tl_w+4,w
  Poke.l ?__tl_h+4,h
  Poke.l ?__tl_l+4,x
  Poke.l ?__tl_t+4,y
  If wininfo(win)\gadlist<>-1
    Poke.l ?__tl_g+4,Peek.l(Addr GadgetList(wininfo(win)\gadlist))
  Else
    Poke.l ?__tl_g+4,0
  EndIf
  WindowTags win,f,wininfo(win)\title,?__Taglist
  winstatus(win)=-1
  wininfo(win)\w=w,h
#_winSource       =0
#_winControl      =1
#_winRegisters    =2
#_winBackdrop     =3
#_winMemory1      =4
#_winMemory2      =5
#_winSearch       =6
#_winVariables    =7
#_winDisAsm       =8
#_winDisCop       =9
#_winCustom       =10
#_winArray        =11
#_winMouseables   =12
#_winObject0      =13
#_winObject9      =22

  GTSetMenu 0
     WindowFont 1
  If win=#_winSearch OR win=#_winCustom OR win=#_winArray OR win=#_winRegisters OR  win>12
    WindowFont 0
  End If



  Statement Return

__Taglist:
          Dc.l  #WA_NewLookMenus,1
__gimmi   Dc.l  #WA_GimmeZeroZero,1
__tl_w:   Dc.l  #WA_Width,0
__tl_h:   Dc.l  #WA_Height,0
__tl_l:   Dc.l  #WA_Left,0
__tl_t:   Dc.l  #WA_Top,0
__tl_g:   Dc.l  #WA_Gadgets,0
          Dc.l  #WA_MenuHelp,1
__tl_scr: Dc.l  #WA_ScreenTitle,0
__more:   Dc.l  #TAG_MORE,0

__norm:
          Dc.l  #WA_MinWidth,160
          Dc.l  #WA_MinHeight,70
          Dc.l  #WA_MaxWidth,1280
__tl_mh:  Dc.l  #WA_MaxHeight,256
          Dc.l  #TAG_END

__memwin: Dc.l  #WA_MinWidth,208
          Dc.l  #WA_MinHeight,70
          Dc.l  #WA_MaxWidth,-1
          Dc.l  #WA_MaxHeight,-1
          Dc.l  #TAG_END

End Statement

Statement Domemtitle{num.w}
  SHARED memlock$(),wininfo()
  DEFTYPE.w win

  win=#_winMemory1+num
  a$=wininfo(win)\title
  If memlock$(num)
    a$+" ("+UCase$(memlock$(num))+")"
  EndIf
  Use Window win
  WTitle a$
End Statement

;Open a new memory window
Statement NewMemWindow{win.w}
  SHARED wininfo(),winstatus()
  SHARED sw,sh,end_init,maxheight
  SHARED scrtitle$
  DEFTYPE.w x,y,w,h
  DEFTYPE.b num
  wininfo(win)\flags=$20002f
  wininfo(win)\gadlist=-1

  NewWindow{win}

  If win=#_winMemory1 Then num=0 Else num=1
  Domemtitle{num}
End Statement

;Delete a window, after storing its size and position.
;Stores data so that the window can be reopened easily.
Statement DelWindow{win.w}
  SHARED wininfo(),winstatus()
  If win>22
    Use Window win
    wininfo(win)\x=WindowX,WindowY,WindowWidth,WindowHeight
    winstatus(win)=0
    WZCloseWindow win
    Use Window 0
    Else
    Use Window win
    wininfo(win)\x=WindowX,WindowY,WindowWidth,WindowHeight
    winstatus(win)=0
    CloseWindow win
    Use Window 0
    End If
End Statement

Statement FindStructureWin{evw.l}
  SHARED objwins()

  FirstItem objwins()
  While objwins()\winnum<>evw
    NextItem objwins()
  Wend
End Statement

Statement SaveIt{p$}
  SHARED ad2,configsize,prefs
  If WriteFile(0,p$+"RED_DBug.prefs")
    WriteMem 0,ad2,configsize
    CloseFile 0
  EndIf
  If WriteFile(0,p$+"RED_DBug2.prefs")
    WriteType 0,prefs
    CloseFile 0
  EndIf
                                                                                                                                                                                                                                                        


End Statement

Statement RedrawArray{refreshtype.b}
  SHARED arrayadd,array1,array2,ix,iy
  SHARED xarraynum,yarraynum,arraytype
  SHARED xarrayoff,yarrayoff,arraydatasize,arrayitemsize
  SHARED arraylabelsize

  DEFTYPE.w x,y,w,h

  Use Window #_winArray
  Use BitMap 1
  If refreshtype=1
    xarraynum=(InnerWidth ASR 3)/(arrayitemsize)
    xarraynum-2
    SetPropInfo #_winArray,#ARR_XGAD,xarraynum,array1,xarrayoff
    If xarraynum>array1
      xarraynum=array1
      xarrayoff=0
    Else
      If xarrayoff+xarraynum+1>array1 Then xarrayoff=array1-xarraynum
    EndIf

    yarraynum=(InnerHeight-8) ASR 3
    yarraynum-1
    SetPropInfo #_winArray,#ARR_YGAD,yarraynum,array2,yarrayoff
    If yarraynum>array2
      yarraynum=array2
      yarrayoff=0
    Else
      If yarrayoff+yarraynum+1>array2 Then yarrayoff=array2-yarraynum
    EndIf

    Redraw #_winArray,#ARR_XGAD
    Redraw #_winArray,#ARR_YGAD
  EndIf

  ;Cls
   w.w=InnerWidth
  hi.w=InnerHeight
  ;Boxf 0,0,w,hi,0
  ;WBox 0,0,w,hi,0
                                                                                                                              
  Select arraylabelsize
    Case 1
      a.l=2
    Case 2
      a=4
    Case 3
      a=8
  End Select

  ;FInverse -1
  ;FLocate 0,0
  WLocate 0,0
  NPrint String$(" ",arrayitemsize)
  ;FPrint String$(" ",arrayitemsize)
  b$=String$(" ",arrayitemsize-a)
  For x=xarrayoff To xarrayoff+xarraynum
    a$=GetHex$(x,arraylabelsize)
    Print b$+a$
    ;FPrint b$+a$
  Next x
  WLocate 0,8
  ;FLocate 0,1
  For y=yarrayoff To yarrayoff+yarraynum
    a$=GetHex$(y,arraylabelsize)
    ;FNPrint b$+a$
    NPrint b$+a$
  Next y
  FInverse 0

  Select arraydatasize
    Case 1
      a=2
      skip.l=1
    Case 2
      a=4
      skip=2
    Case 3
      a=8
      skip=4
  End Select

  a$=String$(" ",arrayitemsize-a)

  ad.l=arrayadd+(xarrayoff*skip)+(yarrayoff*(array1+1)*skip)
  For y=yarrayoff To yarrayoff+yarraynum
    ad2.l=ad : ad+((array1+1)*skip)
    ;FLocate arrayitemsize,y-yarrayoff+1
    WLocate arrayitemsize*8,(y-yarrayoff+1)*8 ;change fontsize
    For x=xarrayoff To xarrayoff+xarraynum
      Print a$+GetHexAdr$(ad2,arraydatasize)
      ;FPrint a$+GetHexAdr$(ad2,arraydatasize)
      ad2+skip
    Next x
  Next y

  ;BitMaptoWindow 1,#_winArray,0,0,ix,iy,InnerWidth,InnerHeight
End Statement

Statement RedrawSearchWin{ad.l}
  SHARED searchtype

  Use Window #_winSearch

  WLocate 4,04 : Print "Start address:"
  WLocate 4,18 : Print "End address  :"

  WLocate 4,38 : Print "Search value :"
  WLocate 4,52 : Print "Search type  :"
  WLocate 190,52
  ad+(searchtype*7)-7 : Print Peek$(ad)
End Statement

Statement RedrawCustomWin{}
  Use Window #_winCustom

  WLocate 4,04 : Print "Address$:"
  WLocate 4,18 : Print "Name    :"
End Statement

Statement UpdateDisCop{}
  SHARED discop_ad,ix,iy

  Use Window #_winDisCop
  Use BitMap 1
  w.w=InnerWidth : If w>320 Then w=320
  hi.w=InnerHeight
  ;Boxf 0,0,w,hi,0

  ;FLocate 0,0
  WLocate 0,0
  ad.l=discop_ad
  For h.w=1 To (hi/WinFontHeight)
    NPrint Hex$(ad)+" "+GetCopIns$(ad)
    ad+4
  Next h
  RefreshWindowFrame_(!windowaddr)
  ;BitMaptoWindow 1,#_winDisCop,0,0,ix,iy,w,hi
End Statement

Statement UpdateDisAsm{}
  SHARED disasm_ad,ix,iy,d_d$,breakpoint_adr,tokenise
  SHARED dis(),asmstep,breakstore,winstatus()
  DEFTYPE.w bitm
  If winstatus(#_winDisAsm)=0 Then Statement Return
  MOVE.l mybuffer,d0
  BEQ nobuff
  ad.l =PutD0
  pc.l=Peek.l(ad+64)-2
nobuff:  ad.l=disasm_ad
   If ad<4096 ad=4096
  Use Window #_winDisAsm
  If tokenise=1 Then bitm=3 Else bitm=1
  Use BitMap bitm
  w.w=InnerWidth
  hi.w=InnerHeight
  ;InnerCls
  ;Boxf 0,0,w,hi,0

  FLocate 0,0
  WLocate 0,0
   For h.w=1 To (hi/WinFontHeight)

    If pc=ad Then Print "$"+Hex$(ad)+"**>":Else Print "$"+Hex$(ad)+"   "
    If Peek.w(ad)=$4e41
      ad+2
      ad2.l=breakpoint_adr-8
      flag.w=0
      While flag=0
        ad2+8
        break.l=Peek.l(ad2)
        If break=ad Then flag=-1
        If break=0 Then flag=1
      Wend
      If flag=-1
        If asmstep
        bt1.l=ad2-breakpoint_adr
        bt1=bt1+breakstore
        ad-2
        Poke.w ad,Peek.w(bt1)
        End If
        btype.w=Peek.w(ad2+4)
        FInverse On
        If btype=#break_simple
          Print "["+Hexw$(Peek.w(ad2+6))+"]":FInverse Off: Print " "
        Else
          If btype=#break_permanent
            Print "[*]":FInverse Off: Print "    "
          Else
            Print "[="+Hexw$(Peek.w(ad2+6))+"]"
          EndIf
        EndIf
        FInverse Off
      Else
        FInverse On : Print ">>>" : FInverse Off : Print "    "
      EndIf
      If asmstep AND flag=-1
          a$=DisAssemble$(ad)
          dis(h)=a$
          NPrint pc$+a$+"                                                     "
          Poke.w ad,$4e41
          ad+InstrSize
      Else
          ret=getad {ad}
          FPrintDetoke ret+9,Peek.w(ad+4)-9,-1,0
          *lineptr=PutD0 :x$=Peek$(*lineptr)
          Gosub sysprintdetoke
          FLocate 0,0;h
          WLocate 0,h*WinFontHeight
          ad+8
      End If
    Else
          a$=DisAssemble$(ad)
      dis(h)=a$
      NPrint "     "+a$+"                                                                      "
      ad+InstrSize
    EndIf
  Next h
  ;BitMaptoWindow bitm,#_winDisAsm,0,0,ix,iy,w,hi
  RefreshWindowFrame_ (!windowaddr)
End Statement
Statement UpdateVarWindow{}
  SHARED varinfo(),ix,iy,winstatus(),ffp,i

  Use Window #_winVariables
  inw.w=InnerWidth
  inh.w=InnerHeight-12
  Use BitMap 1
  ;BitmapOutput 1
  ;Boxf 0,0,inw-144,inh-1,0

  ResetList varinfo()
  mq.q=0 : mf.f=0
  ;FLocate 0,0
  WLocate 0,WinFontHeight+2
  count=0
  While NextItem(varinfo())
    ad.l=varinfo()\address
    If ad
      count+1
      f.b=varinfo()\form
      Select varinfo()\typ
        Case 1                             ;BYTE
          Select f
            Case 0
              a$=Str$(Peek.b(ad))
            Case 1
              a$="$"+GetHexAdr$(ad,1)
            Case 2
              a$="%"+Binb$(Peek.b(ad))
          End Select
        Case 2                             ;WORD
          Select f
            Case 0
              a$=Str$(Peek.w(ad))
            Case 1
              a$="$"+GetHexAdr$(ad,2)
            Case 2
              a$="%"+Binw$(Peek.w(ad))
          End Select
        Case 3                             ;LONGWORD
          Select f
            Case 0
              a$=Str$(Peek.l(ad))
            Case 1
              a$="$"+GetHexAdr$(ad,3)
            Case 2
              a$="%"+Bin$(Peek.l(ad))
          End Select
        Case 4                             ;STRING trace output
          If f=1
            a$=Peek$(Peek.l(ad))+" ["+Str$(Peek.l(Peek.l(ad)-4))+"/"+Str$(Peek.l(Peek.l(ad)-8))+"]"
          Else
            a$=Peek$(Peek.l(ad))
          EndIf
        Case 5                             ;QUICK
          Poke.l &mq,Peek.l(ad)
          a$=Str$(mq)
        Case 6                             ;FLOAT
          If winstatus(#fpuwin)
          i=Peek.l(ad)
          Dc.l $f2276800 ;fmove.x fp0,-(a7)
          fmove.s i@(a4),fp0
          JSR fpuffp
          Dc.l $f21f4800
          ;fmove.x (a7)+,fp0
          a$=Str$(ffp)
          Else
          Poke.l &mf,Peek.l(ad)
          a$=Str$(mf)
          End If
      End Select
      WLocate TextLength_(RastPort,"1234567890123456789",19),(count*WinFontHeight)+2
      NPrint a$
    EndIf
  Wend
  RefreshWindowFrame_(!windowaddr)
  ;BitMaptoWindow 1,#_winVariables,0,0,ix+144,iy+12,inw-144,inh-1
End Statement

Statement RedrawVarWindow{}
  SHARED varinfo(),ix,iy,objtype$

  Use Window #_winVariables
  Use BitMap 1
  InnerCls
   w.w=InnerWidth
  hi.w=InnerHeight
  ;Boxf 0,0,w,hi,0
                                                                                                                              


  ;FLocate 0,0
  ;FNPrint "Variable          Value"
  WLocate 0,0
  NPrint "Variable          Value"
                                                                                                                                                                                                                                                        


  ;WLocate 0,0
  ;NPrint "Variable          Value"
  ;Boxf 139,0,141,7,1
  ;Line 0,8,639,8,1
  Wline WLeftOff,WTopOff+WinFontHeight,InnerWidth,WTopOff+WinFontHeight,1
  WLocate 0,WinFontHeight+2
  ;FYOffset 3
  ResetList varinfo()
  While NextItem(varinfo())
    a$="."+Mid$(objtype$,varinfo()\typ,1)
    If a$=".s" AND Right$(varinfo()\name,1)="$" Then a$=""
    ;FNPrint varinfo()\name+a$
    NPrint varinfo()\name+a$
  Wend
  ;BitMaptoWindow 1,#_winVariables,0,0,ix,iy+1,InnerWidth,InnerHeight-12
  ;FYOffset 0
End Statement

Function.l GetStructVal{num.w}
  SHARED objwins()
  DEFTYPE.l ad,ads

  ad=objwins()\typepointer
  ads=objwins()\mem_type
  While Peek.b(ads)<>0 AND num<>0
    ad+Peek.w(ads+2)
    ads+4
    num-1
  Wend

  If Peek.w(ads)=0 Then Function Return -1

  Select Peek.w(ads)
    Case 1
      ad=Peek.b(ad)
    Case 2
      ad=Peek.w(ad)
    Case 3
      ad=Peek.l(ad)
    Case 4
      ad=Peek.l(ad)
  End Select
  Function Return ad
End Function

;Update the object trace window
Statement RefreshTypeWindow{}
  SHARED winstatus(),ix,iy
  SHARED objwins()

  DEFTYPE.l ad,ads
  DEFTYPE.w typewidth,inw,inh
  DEFTYPE.q mq
  DEFTYPE.f mf

  Use Window objwins()\winnum
  ad.l=objwins()\typepointer

  ;FLocate 0,0

  typewidth=objwins()\typewidth
  WLocate typewidth,0
  inw=InnerWidth
  inh=InnerHeight
  Use BitMap 1
  ;Boxf 0,0,inw-typewidth,inh AND %1111111111111000,0
  WBox typewidth,WTopOff+1,inw-typewidth,inh AND %1111111111111000,0
  If ad OR objwins()\is_bbobject=0
    ;FNPrint Hex$(ad)
  WLocate typewidth,0:NPrint Hex$(ad)  ;change for fontsize
    ads=objwins()\mem_type
    defy=10
    While Peek.w(ads)<>0
    WLocate typewidth,defy
    defy+8
      a.w=Peek.w(ads)
      If a<4
        ;FNPrint GetHexAdr$(ad,a)
        NPrint GetHexAdr$(ad,a)
      Else
        Select a
        Case 4
          If Peek.l(ad)<>0 Then NPrint PeekMax$(Peek.l(ad),80) Else NPrint ""
          If Peek.l(ad)<>0 Then FNPrint PeekMax$(Peek.l(ad),80) Else FNPrint ""
        Case 5                             ;QUICK
          Poke.l &mq,Peek.l(ad)
          ;FNPrint Str$(mq)
          NPrint Str$(mq)
        Case 6                             ;FLOAT
          Poke.l &mf,Peek.l(ad)
          ;FNPrint Str$(mf)
          NPrint Str$(mf)
      End Select
      EndIf
      ad+Peek.w(ads+2)
      ads+4
    Wend
  Else
    Print "No object found"
    ;FPrint "No object found"
  EndIf

  ;BitMaptoWindow 1,objwins()\winnum,0,0,typewidth,iy+1,inw-typewidth,inh AND %1111111111111000
End Statement

Function.l FindBreakPoint{ad}
  SHARED breakpoint_adr

  ad2.l=breakpoint_adr
  flag=0
  While Peek.l(ad2)<>0 AND flag=0
    If Peek.l(ad2)=ad
      flag=-1
    Else
      ad2+8
    EndIf
  Wend
  If flag=0 Then ad2=0
  Function Return ad2
End Function

Statement RedrawMouseables{n.w}
  SHARED mouseables,num_mouseables,mouseables_off,ix,iy

  Use Window #_winMouseables
  Use BitMap 1
  w.w=InnerWidth
  hi.w=InnerHeight
  h.w=hi ASR 3

  If n=True
    SetPropInfo #_winMouseables,#MSE_SGAD,h,num_mouseables,mouseables_off
    Redraw #_winMouseables,#MSE_SGAD
  EndIf

  ;Boxf 0,0,w,hi,0
  InnerCls
  WLocate 0,0
  ;FLocate 0,0
  y.w=0
  ad.l=mouseables
  If mouseables_off
    For loop.w=1 To mouseables_off
      ad=Peek.l(ad)
    Next loop
  EndIf

  If ad<>0
    While y<h AND y<num_mouseables
      ad2.l=Peek.l(ad+4)
      a$=ExtractLabel(ad2)
      NPrint a$
      y+1
      ad=Peek.l(ad)
    Wend
  EndIf
  ;BitMaptoWindow 1,#_winMouseables,0,0,ix,iy,w,hi
End Statement

Statement GetCustomMenus{}
  SHARED customcomm$()
  If ReadFile (0,"ENV:REDDebugger.menus")
    GTMenuTitle 0,4,"Custom"
    FileInput 0
    n=0
    Repeat
      a$=Edit$(256)
      If a$<>""
        D_InitParse a$
        b$=D_NextArg$
        typ$=D_NextArg$
        s$=D_NextArg$
        customcomm$(n)=D_NextArg$
        customcomm$(n)=D_NextArg$
        If s$=Chr$(126) Then s$=""
        If b$<>Chr$(126)
          GTMenuItem 0,0,4,n,b$,s$
        Else
          GTMenuItem 0,0,4,n
        EndIf
        n+1
      EndIf
    Until Eof(0) OR n=#MAXCUSTOMCOMMANDS
    PopInput
    CloseFile 0
  EndIf
End Statement

;*****************************************************************

.StartOfDayInit:
  WBStartup
  AddIDCMP #IDCMP_MENUHELP
  CNIF #test=0
    If (Maximum Window)<25 OR (Maximum GadgetList)<25
      i=Request("Object Maximums too small","Increase Window and  Gadgetlist Objectsize >25","BAD")
      End
    EndIf
  CEND
  my_path$ = dos_GetProgDir{"Blitz3:Debug/"}
  FindScreen (0)
  *scr._Screen = Peek.l(Addr Screen(0))
  *myfont.TextAttr = *scr\Font
  fontheight = WZYFontsize

  ;fontgeight=*myfont\ta_YSize
  ad1.l = *myfont\ta_Name
  fontname$ = Peek$(ad1)
  ;LoadFont 1,fontname$,WZYFontsize
  ;LoadFont 1,prefs\fontname,fontsize
  If FindPort_("REXX")
    arexxport = RXCreatePort("DEBUGGER.PRIVATE")
  Else
    arexxport = 0
  EndIf
  newted = Exists("libs:ted.library")
Return

.mainstart:
  ClearProcessPtrs
  If newted
    comdata = TEDGetJumpTable_()
    MOVE.l d0,a0
    CLR.b newdebug
    CMP.l #"newd",$7de(a0)
    BNE 'l1
    MOVE.l $7e2(a0),trap15addr
    MOVE.b #1,newdebug
   'l1:
    MOVE.l $1F0(a0),a0                        ; -- get "programstart" out of comdata-struct
    MOVE.l a0,programstart                    ; --
    If os4_present=0
     MOVE.l -4(a0),programsize                 ; -- get some unknown data
    Else
     MOVE.l #10,programsize
    EndIf
    mouseables = TEDGetLabelList_()
    num_mouseables = TEDGetLabelCount_()
    debug_filename$ = Peek$(TEDGetFilename_)

    debug_pathname$ = "" ;Peek$(?????)
    debug_pathspec$ = debug_pathname$
    If Right$(debug_pathspec$,1)<>":" Then debug_pathspec$+"/"
    debug_pathspec$ + debug_filename$
    AddProcessPtr "f",&debug_filename$
    AddProcessPtr "d",&debug_pathname$
    AddProcessPtr "F",&debug_pathspec$
  EndIf

  Gosub openwindow
  Gosub InitRegsWin
  FillMem ?breakpoint,5*8

  CNIF #test = 0
    d_sethandler{&procstatus}
  CEND

  SetupLESDebug token_addr,tokenise
  Gosub RedrawMem
  Gosub RedrawRegs
  exitflag=0
  end_init=-1
. @mainloop
  Repeat
    d_sethandler{&procstatus}
    Gosub getevent
    gad = GadgetHit
    i$ = Inkey$
    evq = EventQualifier
    evw = EventWindow
    kbshift = evq AND %11

    If ev = 256
      On MenuHit+1 Gosub domenu0,domenu1,domenu2,domenu3,domenu4
    EndIf

    If ev = 8 Then Gosub MousePress
    If ev = 1024                    ; Rawkey for gadgets
      flag = 0
      ec.l = EventCode
      ;skip=0
      Select ec
        Case $21
          gosubstatus=0
          procstatus=0
          flag=2
          skip=0
          FlushEvents
        Case $22                 ;key d
          flag=2
          skip=1
          gosubstatus=1
          procstatus=1
          FlushEvents
        Case $17
          flag=3
        Case $14
          flag=4
        Case $13
          flag=5
        Case $38
          flag=6
        Case $39
          flag=7
        Case $32
          flag=8
        Case $12
          flag=9
        Case $34
          flag=10
      End Select
      If flag
        gad=flag : ev=64 : evw=#_winControl
        ;Repeat : Until RawStatus(ec)=0
      EndIf
    EndIf

    Select ev
      Case 2                      ;newsize
        ;Gosub CorruptWindow

      Case 4                      ;refresh
        Gosub CorruptWindow

      Case 32
        If (#gadgetdown BitTst evw) Then Gosub GadgetDown

      Case 64                     ;gadget up
        If evw=#_winControl Then Gosub SourceGadgets
        If evw=#_winSearch Then Gosub SearchGadgets
        If evw=#_winCustom Then Gosub CustomGadgets
      Case 512                    ;**CLOSE WINDOW**
        flag=-1
        Gosub RemoveWindow

      Case 1024                   ;**RAWKEY CHECK ON WINDOW**
        Gosub CheckKeyboard

      Case #IDCMP_ACTIVEWINDOW
        Use Window evw
        old_active_win=active_win
        active_win=evw

      Case #IDCMP_IDCMPUPDATE
       Use Window evw
        Select WZGadName
         Case "fpr00"
         temp=0:Gosub setfpu
         Case "fpr01"
         temp=1:Gosub setfpu
         Case "fpr02"
         temp=2:Gosub setfpu
         Case "fpr03"
         temp=3:Gosub setfpu
         Case "fpr04"
         temp=4:Gosub setfpu
         Case "fpr05"
         temp=5:Gosub setfpu
         Case "fpr06"
         temp=6:Gosub setfpu
         Case "fpr07"
         temp=7:Gosub setfpu
        End Select
      Case #IDCMP_MENUHELP
        Gosub MenuHelp
    End Select
  Until exitflag
  Gosub FreeStuff
Return

.backoff:
  If pb
    pb=0:i=Peek.l(buffmem+cb):mc=-1:Gosub prtcode
  EndIf
Return
sourceallow
temp2=Peek.l(?mybuffer)
temp2=Peek.l(temp2+64)
  If Peek.w(temp2-2)=$4e41 AND Peek.w(temp2-2+Peek.w(temp2+6))=$4e41
    temp2=0
    Else
    temp2=1
    End If
  Return
backward:
  If pb=0 Then bb=cb
  bb-4 AND #buffand:i=Peek.l(buffmem+bb)
  If i=0
    If pb=0 Then Return
    bb+4 AND #buffand:t$="At end of buffer":Goto wprint
  EndIf
  If syntax_ Then Gosub getsyntax
  pb=-1:mc=-1:Goto prtcode

forward:
  bb+4 AND #buffand
  If (bb+4 AND #buffand)=Peek.w(?bufferput) Then pb=0
  i=Peek.l(buffmem+bb)
  If syntax_ Then Gosub getsyntax
  mc=-1:Goto prtcode

.prtcode:
;
;i=info
;
;mc=-1 to make current
;cil=current ins. line, cio=current offset
;
  If i=0 Then Return
  Gosub sourceallow
  If temp2 Then Return
  il=Peek.l(i):io=Peek.w(i+4)-9
  il=getad {i}
  If mc Then cil=il:cio=io:mc=0
  ;
  Gosub prtcode2
  ;
  ali=i:Return

prtcode2
  bitm=3
  Use Window #_winSource

  If tokenise=1 Then bitm=3 Else bitm=1
  Use BitMap bitm:;BitmapOutput 1
  w.w=WindowWidth
  hi.w=InnerHeight

  ;WBox  WLeftOff,WTopOff,w+WLeftOff,hi-16,0
  ;Boxf 0,0,w,hi,0
  ypc=0
  y=ym:i2=il
  While y<=ih-WinFontHeight AND i2<>0
    Gosub prti2:
     i2=Peek.l(i2)
    src(y/WinFontHeight)=t$       ;add line to sourcearray for clickvar
    y+WinFontHeight
  Wend
  While y<=ih-WinFontHeight:WLocate 0,y:NPrint "\\R99 \\R99 ":y+WinFontHeight:Wend

  y=ym-WinFontHeight:i2=Peek.l(il+4)
  While y>=0 AND i2<>0
    Gosub prti2:
    src(y/WinFontHeight)=t$
    y-WinFontHeight
    ;y-fontheight
    i2=Peek.l(i2+4)
  Wend
  While y>=0:WLocate 0,y:NPrint "\\R99 \\R99 ":y-WinFontHeight:Wend
  ;
  ;BitMaptoWindow bitm,#_winSource,0,0,ix,iy,iw,ih
  ;If ypc>0 Then WLocate 0,ypc:Print ">"
  RefreshWindowFrame_ (!windowaddr)
  prtbusy=0
Return
prti2 ;i2 at y
  If i2=cil
    n.w=cio
    ypc=y
    If pb Then m.w=0 Else m=-1
  Else
    n=-1
  EndIf
  FLocate 0,0;y/8
  ret.l=getad2 {i2}
  FPrintDetoke ret+9,n,m,0;source_char_offset
  *lineptr=PutD0

  WLocate 0,y
  Gosub sysprintdetoke
Return
sysprintdetoke
alog$=""
tog=0
t$=Peek$(*lineptr)
If source_char_offset>=1
     a$=Left$(t$,source_char_offset-1)
     ocur=CharCount(a$,$c0)
     If ocur AND 1 Then tog=-1
End If
t$=Mid$(t$,source_char_offset)
t$=Replace$(t$,"End\\c0\\c0If","EndIf")
InitArgParse t$
a$=NextArgChar$($c0)
more
If tog
   WColour 3
Else
   WColour 1
End If
   Print a$:
   If logcon
   If (i2=cil) AND (i2<>lasti2.l) Then alog$=alog$+a$
   End If
a$=NextArgChar$($c0)
If a$<>"" Then tog=NOT tog  :Goto more
t$=Replace$(t$,"\\c0","")
WColour 1
NPrint "\\R99 \\R99 \\R99 \\R99 \\R99 "
If alog$ Then !cout{alog$}:lasti2=i2

Return

SearchGadgets:
  Use Window #_winSearch
  Select gad
    Case 2
      SetString 2,1,"$"+Hex$(mempointer(0))
      Redraw #_winSearch,1
    Case 3
      SetString 2,1,"$"+Hex$(mempointer(1))
      Redraw #_winSearch,1
    Case 5
      SetString 2,4,"$"+Hex$(mempointer(0))
      Redraw #_winSearch,4
    Case 6
      SetString 2,4,"$"+Hex$(mempointer(1))
      Redraw #_winSearch,4
    Case 8
      searchtype+1 : If searchtype=7 Then searchtype=1
      WLocate 190,52
      ad=(?variabletypes+(searchtype*7)-7) : Print Peek$(ad)
    Case 10
      Gosub SearchMemory
  End Select
Return
.GadgetDown:
  Use Window evw
  *arrowgad=EventiAddress
  If evw>=#_winObject0 AND evw<=#_winObject9
    FindStructureWin{evw}
  EndIf
  Repeat
    Delay_ 1
    Select gad
      Case #SRC_SGAD
        source_char_offset=GetPropCurrent(#_winSource,1)

        If ali Then Gosub prtcode2

      Case #SRC_LGAD
        If source_char_offset>0
          source_char_offset-1
          MoveProp #_winSource,#SRC_SGAD,source_char_offset,#_winSource
          If ali Then Gosub prtcode2
        EndIf

      Case #SRC_RGAD
        If source_char_offset<(250-cw)
          source_char_offset+1
          MoveProp #_winSource,#SRC_SGAD,source_char_offset,#_winSource
          If ali Then Gosub prtcode2
        EndIf

      Case #MSE_SGAD
        num=GetPropCurrent(#_winMouseables,#MSE_SGAD)
        If num<>mouseables_off
          mouseables_off=num
          RedrawMouseables{False}
        EndIf

      Case #MSE_UGAD
        If mouseables_off>0
          mouseables_off-1
          MoveProp #_winMouseables,#MSE_SGAD,mouseables_off,#_winMouseables
          RedrawMouseables{False}
        EndIf

      Case #MSE_DGAD
        h=(InnerHeight ASR 3)
        If mouseables_off<(num_mouseables-h)
          mouseables_off+1
          MoveProp #_winMouseables,#MSE_SGAD,mouseables_off,#_winMouseables
          RedrawMouseables{False}
        EndIf

      Case #OBJ_SGAD
        If objwins()\is_bbobject
          a=GetPropCurrent(evw,#OBJ_SGAD)
          If a<>objwins()\tracenum
            objwins()\tracenum=a
            Gosub RefType
          EndIf
        EndIf

      Case #OBJ_UGAD
        If objwins()\is_bbobject
          If objwins()\tracenum>0
            objwins()\tracenum-1
            Gosub RefType2
            Delay_ 2
          EndIf
        EndIf

      Case #OBJ_DGAD
        If objwins()\is_bbobject
          If objwins()\tracenum<(objwins()\maxobject-1)
            objwins()\tracenum+1
            Gosub RefType2
            Delay_ 2
          EndIf
        EndIf

      Case #ARR_YGAD
        n=GetPropCurrent(#_winArray,#ARR_YGAD)
        If n<>yarrayoff
          yarrayoff=n
          RedrawArray{2}
        EndIf

      Case #ARR_XGAD
        n=GetPropCurrent(#_winArray,#ARR_XGAD)
        If n<>xarrayoff
          xarrayoff=n
          RedrawArray{2}
        EndIf

      Case #ARR_UGAD        ; up
        If yarrayoff>0
          yarrayoff-1
          RedrawArray{1}
        EndIf

      Case #ARR_DGAD        ; down
        If yarrayoff<array2-yarraynum
          yarrayoff+1
          RedrawArray{1}
        EndIf

      Case #ARR_LGAD        ; left
        If xarrayoff>0
          xarrayoff-1
          RedrawArray{1}
        EndIf

      Case #ARR_RGAD        ; right
        If xarrayoff<array1-xarraynum
          xarrayoff+1
          RedrawArray{1}
        EndIf
    End Select
  Until (*arrowgad\Flags AND #GFLG_SELECTED)=0
  ev=0
Return

RefType2:
  MoveProp evw,#OBJ_SGAD,objwins()\tracenum,evw
RefType:
  a=objwins()\tracenum
  objwins()\typepointer=objwins()\objbaseadr+(a*objwins()\type_sizeof)
  WTitle "Newtype: "+objwins()\t+" #"+Str$(a)+"/"+Str$(objwins()\maxobject-1)
  RefreshTypeWindow{}
Return

.SourceGadgets:
  Select gad
    Case 1                ;**STOP**
      CNIF #test=0
      If dstatus<>#STOPPED Then !d_call{1}
      stepcnt=0
      CEND
    Case 2                ;**STEP**
. @asmstep
      If asmstep
      CacheClearU_
      ad=Peek.l(?mybuffer)
      pc.l=Peek.l(ad+64)
      st1=FindBreakPoint{pc}
           If st1
           bd1=st1-breakpoint_adr
           temp=Peek.w (bd1+?breakstore)
           Poke.w pc-2,temp
           End If
           If Peek.w (pc-2)=$4e41
           pc=pc+10
           Else
           Poke.l ad+64,pc-10
           End If
      pc-2
      temp$=DisAssemble$(pc)
      ad=pc+InstrSize
      temp=Peek.w (pc)
      adtemp2=0
      adtemp=0
           If temp=$4eb9 Then ad=Peek.l (pc+2) ;jsr $xxx
           If skip AND temp=$4eb9 Then ad=pc+6 ;skip jsr
           If temp >=$6000 AND temp<=$6f00        ;bcc bra bsr
            If (temp AND $ff)=$ff               ;32bit
              ad=pc+Peek.l(pc+2)+2
              adtemp2=pc+6
            Else
               If temp AND %00000000 11111111
               ad=pc+Peek.b(pc+1)+2               ;8 bit
               adtemp2=pc+2
               Else
               ad=pc+Peek.w(pc+2)+2              ;16 bit
               adtemp2=pc+4
               End If
            End If
           End If
           If skip AND temp=$6100 Then ad=pc+4:adtemp2=0  ;skip bsr
           If temp=$4e75 Then ad=Peek.l(?mybuffer):ad=Peek.l (ad+60):ad=Peek.l(ad) ;rts
           If temp=$4ef9 Then ad=Peek.l (pc+2)
           temp1=temp AND %11110000 11111000 ;dbxx
           If temp1=%01010000 11001000
                If skip
                    ad=pc+4
                    Else
                    ad=pc+Peek.w(pc+2)+2:adtemp2=pc+4
                End If
           End If
           brk1=FindBreakPoint{ad+2}
           If brk1
           brk2=Peek.l(brk1+4)
           Poke.l brk1+4,$00010000
           BRA nobreak
           End If
           temp=Peek.w (ad)
           Poke.w ad,$4e41
           adtemp=ad
           typ.w=#break_simple
           Gosub addbreakpoint_quiet
nobreak
      If adtemp2
       ad=adtemp2
       temp1=Peek.w (adtemp2)
       Poke.w adtemp2,$4e41
       typ.w=#break_simple
       Gosub addbreakpoint_quiet
      End If
      cil=0:pb=0:Gosub refwindow:ali=0:lt$=""
                Forbid_
                CacheClearU_
                prtcode=0:dstatus=#RUNNING:statego=0
                Permit_
      Signal_ task,signalset
       ;Delay_(2)
      CacheClearU_
       Delay_(2)
      If adtemp
      ad=FindBreakPoint{adtemp+2}
          If ad Then Gosub deletebreakpoint
          Poke.w adtemp,temp
      End If
      If adtemp2
         ad=FindBreakPoint{adtemp2+2}
         If ad Then Gosub deletebreakpoint
      Poke.w adtemp2,temp1
      End If
      If st1
       Poke.w (Peek.l (st1)-2),$4e41
      End If
      If brk1
            Poke.l brk1+4,brk2
      End If
      CacheClearU_
      Goto nostep
      EndIf
      If dstatus=#STOPPED
        flag=0
        If gosubstatus OR skip=1
          ad=Peek.l(?mybuffer)
          pc.l=Peek.l(ad+64)
          If Peek.w(pc+8)=$4EB9             ; JSR
            If Peek.l(pc+8+6)=$3f3c6753     ; MOVE.w #$6753,-(a7)
              ad=pc+Peek.w(pc+6)-2          ; calc next instruction addr
              typ.w=#break_simple
              Gosub addbreakpoint_quiet
              CacheClearU_
                                            ; *** STEP GOSUB ***
              If flag AND (dstatus OR skip)
                cil=0:pb=0:Gosub refwindow:ali=0:lt$=""
                Forbid_
                prtcode=0:dstatus=#RUNNING:statego=0
                Permit_
              Else
                flag=0
              EndIf
            EndIf
          EndIf
        EndIf
        If flag=0
          If (evq AND %1000)
            stepnumber=RTEZGetLongRange(scrtitle$,"# commands to step:",0,1000,stepnumber)
            If stepnumber
              stepcnt+stepnumber
              flag=1
            EndIf
          Else
            stepcnt+1
            flag=1
            ; // CHECK AUTOEVAL!
            If autoeval
              evalrequest=#_autoevalresult
              d_eval{autoeval$,#NOSIGNAL}
            EndIf
          EndIf
        EndIf
        If flag Then Signal_ task,signalset
      EndIf
nostep
    Case 3                ;**SKIP**
      If dstatus=#STOPPED
        !d_call{8}:stepcnt+1
        Signal_ task,signalset
      EndIf
    Case 4                ;**TRACE**
      Forbid_:dstatus=#TRACE:statego=-1:Permit_
      Signal_ task,signalset
    Case 5                ;**RUN**
      If dstatus
        cil=0:pb=0:Gosub refwindow:ali=0:lt$=""
        Forbid_
        prtcode=0:dstatus=#RUNNING:statego=0
        Permit_
        Signal_ task,signalset
      EndIf
    Case 6                ;**<<**
      If dstatus=#STOPPED Then Gosub backward
    Case 7                ;**>>**
      If dstatus=#STOPPED AND pb<>0 Then Gosub forward
    Case 8                ;**execute**
      ex$=RTEZGetString(scrtitle$,"Execute...",128,ex$)
      Gosub storefpuregs
      If ex$ Then d_exec{ex$}
      Delay_(2)
      Gosub restorefpuregs
    Case 9                ;**evaluate**
      ev$=RTEZGetString(scrtitle$,"Evaluate...",128,ev$)
      Gosub storefpuregs
      If ev$ Then d_eval{ev$,#SIGNAL}
      Delay_(2)
      Gosub restorefpuregs
    Case 10
      CNIF #test=0        ;**BLITZ GADGET**
      If dstatus=#STOPPED
        If pmode<>0
          Disable #_winControl,10
          execrequest=#_viewblitz
          d_exec{"Mousewait"}
          dstatus=#BLITZMODE
        Else
          reply=RTEZRequest(scrtitle$,"   Not in BLITZ mode   ","_Abort")
        EndIf
      EndIf
      CEND
    Case 11               ;**REGISTER WINDOW**
      If winstatus(#_winRegisters)=0
        NewWindow{#_winRegisters}
        Gosub InitRegsWin
        Gosub RedrawRegs
      Else
        DelWindow{#_winRegisters}
      EndIf
    Case 12               ;**MEM WINDOW 1**
      If winstatus(#_winMemory1)=0
        NewMemWindow{#_winMemory1}
        dowin=0
        Gosub RedrawMem
      Else
        DelWindow{#_winMemory1}
      EndIf
    Case 13               ;**MEM WINDOW 2**
      If winstatus(#_winMemory2)=0
        NewMemWindow{#_winMemory2}
        dowin=1
        Gosub RedrawMem
      Else
        DelWindow{#_winMemory2}
      EndIf
    Case 14               ;**VARIABLE WINDOW**
      If winstatus(#_winVariables)=0
        NewWindow{#_winVariables}
        RedrawVarWindow{}
        UpdateVarWindow{}
      Else
        DelWindow{#_winVariables}
      EndIf
    Case 15               ;**DISASM WINDOW**
      If winstatus(#_winDisAsm)=0
        NewWindow{#_winDisAsm}
        UpdateDisAsm{}
      Else
        DelWindow{#_winDisAsm}
      EndIf
    Case 16               ;**COPPER WINDOW**
      If winstatus(#_winDisCop)=0
        NewWindow{#_winDisCop}
        UpdateDisCop{}
      Else
        DelWindow{#_winDisCop}
      EndIf
    Case 17
      gosubstatus=GadgetStatus(#_winControl,17)
    Case 18
      procstatus=GadgetStatus(#_winControl,18)
      MOVE.w  #0,proccount
    Case 19
      blitzcontrol=GadgetStatus(#_winControl,19)
  End Select
     ;procstatus=oldprocstatus
     ;gosubstatus=oldgosubstatus
Return

.CustomGadgets:
  a$=StringText$(3,0)
  b$=StringText$(3,1)
  If a$="" AND gad=0 Then Return
  If b$="" AND gad=1 Then Return
  ad=Vallong("$"+a$)
  b$=UCase$(b$)

  If gad=0
    If (ad AND 1)
      a$="<ILLEGAL>"
    Else
      If ad>$dff000 Then ad-$dff000
      b$=GetCustomReg(ad)
      a$=Hexw$(ad)
      If b$="" Then b$="<UNKNOWN>"
    EndIf
  Else
    ad=GetCustomRegAdr(b$)
    If ad=-1
      a$="<UNKNOWN>"
    Else
      a$=Hexw$(ad)
    EndIf
  EndIf
  SetString 3,0,a$
  Redraw #_winCustom,0
  SetString 3,1,b$
  Redraw #_winCustom,1
Return

;Get variable details from user and initialise a search for
;the variable (using EVAL)
.GetNewVariable:              ;add vartrace
  na$=RTEZGetString(varfollow$,"Enter variable name:",80,part$)
  If na$<>""
    a$=Left$(na$,1)
    If a$="%"
      nf=3
    Else
      If a$="$"
        nf=2
      Else
        nf=1
      EndIf
    EndIf
    If nf<>1 Then na$=Mid$(na$,2)
    nt=-1
    If Right$(na$,1)="$" Then nt=4
    If Len(na$)>2 AND Mid$(na$,Len(na$)-1,1)="."
      nt=Instr(objtype$,LCase$(Right$(na$,1)))
      na$=Left$(na$,Len(na$)-2)
    EndIf
    If nt=-1 Then nt=RTEZRequest(varfollow$,"Enter variable type:","_b|_w|_l|_s|_q|_f|_Cancel")
    If nt>0 AND nt<5
      If nt=4
        nf=RTEZRequest(varfollow$,"Show string length and maxlen?:","_No|_Yes|_Cancel")
      EndIf
    Else
      nf=1
    EndIf
    If nt<>0 AND nf<>0
AddLast varinfo()
      varinfo()\name=na$,0,nt,nf-1
      CNIF #test=0
        d_eval{"&"+na$,#SIGNAL}
        evalrequest=#_variablelocate
      CEND
    EndIf
  EndIf
Return

;n$=string which should be something like: d0=<val>
.ParseRegs:
  flag=0
  b$=UCase$(Left$(n$,1))
  num=0
  If Mid$(n$,3,1)="="
    If b$="D" OR b$="A"
      num=Vallong(Mid$(n$,2,1))
      If b$="A" AND num=7
        num=-1
        flag=1
        reply=RTEZRequest(scrtitle$,"Cannot modify register a7","_Abort")
      EndIf
      If num>=0 AND num<8
        a$=Mid$(n$,4)
        If Len(a$)=6 AND Left$(a$,1)=Chr$(34) AND Right$(a$,1)=Chr$(34)
          si=Cvl(Mid$(a$,2,4))
        Else
          si=Vallong(a$)
        EndIf
        If b$="A" Then num+8
        flag=-1
      EndIf
    EndIf
  EndIf
  If flag=0
    reply=RTEZRequest(scrtitle$,"Malformed argument string","_Abort")
  EndIf
Return

.MousePress:
. @mousebuttons
  Use Window evw
  wx=WMouseX-ix : wy=WMouseY-iy
  Gosub checkclicks
  If evw=#_winSource
          ;If winbubble=0 Then Window #bubble,SMouseX-10,SMouseY+12,WindowWidth,fontheight*3+4,$800,"",0,1:winbubble=1
  End If
  If evw=#_winDisAsm
    xwidth=TextLength_(RastPort,"12345678",8)
    If wx>xwidth AND wy>=0 AND wy<InnerHeight
      wy/WinFontHeight
      ad=disasm_ad
      While wy>0
        If Peek.w(ad)=$4e41 AND Peek.w(ad+Peek.w(ad+8))=$4e41
          ad+10
        Else
          ad2=FindBreakPoint{ad+2}
          If ad2
          Poke.w ad,Peek.w((ad2-breakpoint_adr)+?breakstore)
          End If
          a$=DisAssemble$(ad)
          If ad2
          Poke.w ad,$4e41
          End If
          ad+InstrSize
        EndIf
        wy-1
      Wend
      If (Peek.w(ad)=$4e41 OR asmstep) AND (WMouseX<xwidth+TextLength_(RastPort,"12345678",8) AND WMouseX>xwidth) ;only add breakpoint in range
        flag=0
          ad2=FindBreakPoint{ad+2}
        If ad2
          a=RTEZRequest(scrtitle$,"Change or delete breakpoint?","C_hange|_Delete|_Cancel")
          If a<>1 Then flag=-1
          If a=2
            ad=ad2
            Gosub deletebreakpoint
          EndIf
        EndIf

        If flag=0
          Gosub addbreakpoint
        EndIf
      EndIf
    EndIf

    flag=1
  EndIf

  If evw=#_winRegisters AND dstatus=#STOPPED
    If wy>=1 AND wy<=64
      flag=0
      num=(wy-1) ASR 3
      If wx>=4 AND wx<=91 Then flag=1 : a$="d"
      If wx>4+144 AND wx<=91+144 AND num<8 Then flag=2 : a$="a"
      If flag
        CNIF #test=0
        ad=Peek.l(?mybuffer)
        ad+(num ASL 2)+(flag-1)*32
        si=Peek.l(ad)
        If EventQualifier AND 3
        n$=""
        If winstatus(#_winMemory2)=0 Then NewMemWindow{#_winMemory2}
        mempointer(1)=si
        Gosub RedrawMem
        Goto novalue
        End If
         n$=RTEZGetString("Register value",Peek$(?setregvalue),20,a$+Str$(num)+"=$"+Hex$(si))
novalue: If n$
          Gosub ParseRegs
          If flag=-1
            ad=Peek.l(?mybuffer)+(num ASL 2)
            Poke.l ad,si : Gosub RedrawRegs
          EndIf
        EndIf
        CEND
      EndIf
    EndIf
    If wy >64 AND wy <74
      If wx >154 AND wx <240
      ad=Peek.l(?mybuffer)
      si=Peek.l (ad+64)
    n$=RTEZGetString("Programcounter value",Peek$(?setregvalue),20,"$"+Hex$(si-2))
          If n$
           Poke.l ad+64,Vallong(n$)+2 : Gosub RedrawRegs:
          UpdateDisAsm{}:
.setprogrammcounter
          End If
      End If
    EndIf
  EndIf
  If evw>=#_winObject0 AND evw<=#_winObject9
    y=wy-8
    x=wx
    FindStructureWin{evw.l}
    If objwins()\is_bbobject=0 AND y>=0 AND x>=typewidth-4
      ad=GetStructVal{y ASR 3}
      If ad<>-1
        reply=RTEZRequest(scrtitle$,"Move to location $"+Hex$(ad),"_Okay|_Cancel")
        If reply=1
          objwins()\typepointer=ad
          RefreshTypeWindow{}
        EndIf
      EndIf
    EndIf
  EndIf
  If evw=#_winMouseables
    If num_mouseables AND evalrequest=0
      wy=wy ASR 3
      If wx>=0 AND wx<InnerWidth AND wy>=0 AND wy<(InnerHeight ASR 3)
        wy+mouseables_off
        If wy<num_mouseables
          ad=mouseables
          While wy
            ad=Peek.l(ad)
            wy-1
          Wend
          a$=ExtractLabel(Peek.l(ad+4))
          If old_active_win<>#_winMouseables
            Activate old_active_win
            evalrequest=#_mouseable_eval
            evalrequestex=old_active_win
            d_eval{"?"+a$,#SIGNAL}
          EndIf
        EndIf
      EndIf
    EndIf
  EndIf
Return

CheckKeyboard:
. @message_key
  num = 1
  If kbshift
    Use Window evw
    num = InnerHeight ASR 6
  EndIf

  Select EventCode
    Case $23         ;f
      d_exec{"dbl_flip {}"}

    Case $19         ;p
      If evw = #_winDisAsm
        ad = Peek.l(?mybuffer)
        ad.l = Peek.l(ad+64)
        disasm_ad = ad - 2
        UpdateDisAsm{}
      End If

    Case $35         ;b
      If evw = #_winSource OR evw=#_winDisAsm
        If ali
          t$ = "Move To Breakpoint"
          flag = -1
          Gosub SelectBP
          If bp
            ad=breakpoint_adr
            bp-1
            ad+(bp ASL 3)
            If evw=#_winSource
              il=Peek.l(Peek.l(ad))
              Gosub prtcode2
            Else
              disasm_ad=Peek.l(ad)-2
              UpdateDisAsm{}
            EndIf
          EndIf
        EndIf
      EndIf

    Case $40        ; <SPACE>
      If evw=#_winMemory1 Then dowin=0
      If evw=#_winMemory2 Then dowin=1
      If dowin<>-1
        winnum=evw
        x=0 : y=0
        Gosub MemEdit
      EndIf

    Case $28        ; L
      If evw=#_winMemory1 Then dowin=0:a$=memlock$(0)
      If evw=#_winMemory2 Then dowin=1:a$=memlock$(1)
      If evw=#_winDisAsm  Then dowin=2:a$=disasmlock$
      If dowin<>-1
        flag=0
        a$=RTEZGetString("Lock window","Enter expression to lock onto:",80,a$)
        ConvToPostFix a$,&evalbuffer$
        ad=PFEvaluate(Peek$(&evalbuffer$))
        If PFErrorType
          reply=RTEZRequest("Lock window","Malformed argument","_Okay")
        Else
          If evw<>#_winDisAsm
            If a$<>"" Then mempointer(dowin)=ad
            memlock$(dowin)=a$
            memlockpf$(dowin)=Peek$(&evalbuffer$)
            Domemtitle{dowin}
            Gosub RedrawMem
          Else
            If a$<>"" Then disasm_ad=ad
            disasmlock$=a$
            disasmlockpf$=Peek$(&evalbuffer$)
            Poke$ ?disasmlockstr,a$
            Use Window #_winDisAsm
            t$="Disassembly"
            If disasmlock$<>"" Then t$+" ("+disasmlock$+")"
            WTitle t$
            UpdateDisAsm{}
          EndIf
        EndIf
      EndIf

    Case $42       ; TAB
      If evw<0 Then evw=-1
      Repeat
        evw+1
        If evw=#_winBackdrop Then evw+1
        If evw>(Maximum Window-1) Then evw=0
      Until Peek.l(Addr Window(evw))<>0
      Activate evw
      WindowToFront_ Peek.l(Addr Window(evw))

    Case $4c       ; UP cursor
      FlushEvents
      Select evw
        Case #_winSource
          flag=0
          ;num=1 : If kbshift Then num=ch
          If ali
            For h=1 To num
              If Peek.l(il+4)
                il3.l=Peek.l(il+4):aflag=-1
                If Peek.l(il3)=il Then il=il3
              EndIf
            Next h
            If aflag Then Gosub prtcode2
          EndIf
        Case #_winMemory1
          flag=-1 : dowin=0 : Gosub Movemem
        Case #_winMemory2
          flag=-1 : dowin=1 : Gosub Movemem
        Case #_winDisAsm
          ;If kbshift Then disasm_ad-20
          For h=1 To num
            offset=0
            Repeat
              offset+2
            Until (DisAssemble$(disasm_ad-offset)<>"?????" AND InstrSize=offset) OR offset=8
            If offset=8 Then offset=2
            disasm_ad-offset
          Next h
          UpdateDisAsm{}
        Case #_winDisCop
          discop_ad-(num ASL 2)
          UpdateDisCop{}
      End Select

    Case $4d      ; DOWN cursor
      FlushEvents
      Select evw
        Case #_winSource
          flag=0
          ;num=1 : If kbshift Then num=ch
          If ali
            For h=1 To num
              If Peek.l(il)
                il3.l=Peek.l(il):aflag=-1
                If Peek.l(il3)<>0 Then il=il3
              EndIf
            Next h
            If aflag Gosub prtcode2
          EndIf
        Case #_winMemory1
          flag=1 : dowin=0 : Gosub Movemem
        Case #_winMemory2
          flag=1 : dowin=1 : Gosub Movemem
        Case #_winDisAsm
          ;If kbshift Then disasm_ad+20
          For h=1 To num
            If Peek.w(disasm_ad)=$4e41
              disasm_ad+10
            Else
              a$=DisAssemble$(disasm_ad)
              If a$<>"?????"
                disasm_ad+InstrSize
              Else
                disasm_ad+2
              EndIf
            EndIf
          Next h
          UpdateDisAsm{}
        Case #_winDisCop
          discop_ad+(num ASL 2)
          UpdateDisCop{}
        End Select

    Case $4F                     ; Left cursor
      If evw=#_winMemory1 Then jump=1 : flag=-1 : dowin=0 : Gosub _doMovemem
      If evw=#_winMemory2 Then jump=1 : flag=-1 : dowin=1 : Gosub _doMovemem

    Case $4E                     ; Right cursor
      If evw=#_winMemory1 Then jump=1 : flag=1 : dowin=0 : Gosub _doMovemem
      If evw=#_winMemory2 Then jump=1 : flag=1 : dowin=1 : Gosub _doMovemem

    Case $45                     ; ESCape
      CNIF #test=1
        exitflag=1
      CELSE
        d_quit{}
      CEND

    Case $37                     ; m
      Select evw
      Case #_winMemory1
        cur=0
        If kbshift
         lt$ = lasteval$
        End If
        Gosub goto_MemWindow

      Case #_winMemory2
        cur=1
        If kbshift
          lt$ = lasteval$
        End If
        Gosub goto_MemWindow

      Case #_winDisAsm
        evalrequest=#_disasmaddress
        If evq AND $8
          temp45.l = TEDGetCurrentLine_()   ;ped line to disasm window
          MOVE.l programstart,a0
          MOVE.l a0,a1
          ADD.l programsize,a1
          pg2:
          CMP.w #$4e41,(a0)+
          BNE pg3
          MOVE.l (a0),d1
          AND.l #$80000000,d1
          BEQ noe
          MOVE.l (a0),d1
          AND.l #$7fffffff,d1
          ADD.l startcode@(a5),d1
          MOVE.l d1,a3
          MOVE.l temp45@(a5),a2
          LEA 9(a2),a2
          LEA 9(a3),a3
          MOVEQ #0,d0
          MOVE.b -1(a2),d0
          ADDQ.l #4,a0
'l1       CMPM.b (a2)+,(a3)+
          BNE pg3
          DBF d0,'l1

          BRA pg4
noe       CMP.l (a0)+,d0
          BEQ pg4
pg3:
          CMP.l a0,a1
          BGT pg2
          BRA pg5
pg4:      MOVE.l a0,d0
          SUBQ.l #6,d0
          disasm_ad=PutD0
          UpdateDisAsm{}
pg5:    Else
          Gosub goto_disassemble
        End If

      Case #_winDisCop
        evalrequest=#_discopaddress
        Gosub goto_disassemble
      Default
        If evw>=#_winObject0 AND evw<=#_winObject9
          Gosub goto_objectwin
        EndIf
      End Select

    Case #RK_HELP               ; help key
      If wininfo(evw)\helplink
        a$ = Peek$(wininfo(evw)\helplink)
        DoHelp{a$}
      EndIf

  End Select
Return

.GetAddress:
goto_MemWindow:
  If kbshift = 0
    strg$="$"+Hex$(mempointer(cur))
    lt$=strg$
    strg$=RTEZGetString("Memory location","Enter address to jump to:",40,strg$)
  Else
    strg$=lt$
  EndIf
  If strg$
    evalrequest=#_memwindow
    evalrequestex=cur
    ;d_eval{strg$,#SIGNAL}
    ConvToPostFix strg$,&evalbuffer$
    mempointer(cur)=PFEvaluate(Peek$(&evalbuffer$))
    Gosub RedrawMem
  Else
    evalrequest=0
  EndIf
Return

goto_disassemble:
  If kbshift=0
    strg$="$"+Hex$(disasm_ad)
    lt$=strg$
    strg$=RTEZGetString("Set location","Enter base address:",40,strg$)
  Else
    strg$=lt$
  EndIf
  If strg$
    If evalrequest<>#_discopaddress
    ConvToPostFix strg$,&evalbuffer$
    disasm_ad=PFEvaluate(Peek$(&evalbuffer$))
   UpdateDisAsm{}
   Else
    d_eval{strg$,#SIGNAL}
   End If
  Else
    evalrequest=0
  EndIf
Return

goto_objectwin:
  FindStructureWin{evw}
  If objwins()\is_bbobject=0
    evalrequest=#_structaddress
    PushItem objwins()
    Gosub goto_disassemble
    Return
  EndIf
  If objwins()\maxobject=1 Then Return
  If kbshift=0
    strg$=RTEZGetString("Object number","Enter object number:",40,strg$)
  Else
    strg$=lt$
  EndIf
  a.w=Vallong(strg$)
  If a<0 OR a>=objwins()\maxobject
    reply=RTEZRequest(scrtitle$,"Object value out of range!","  _Ok  ")
    Return
  EndIf
  objwins()\tracenum=a
  objwins()\typepointer=objwins()\objbaseadr+(a*objwins()\type_sizeof)
  Use Window objwins()\winnum
  WTitle "Newtype: "+objwins()\t+" #"+Str$(objwins()\tracenum)+"/"+Str$(objwins()\maxobject-1)

  MoveProp objwins()\winnum,#OBJ_SGAD,a,objwins()\winnum

  RefreshTypeWindow{}
Return

.domenu0:
  If ItemHit<5
    Select ItemHit
      Case 0
        ad=?help_sr
      Case 1
        ad=?help_debug
      Case 3
        ad=?help_keyboard
    End Select
    reply=RTEZRequest(scrtitle$,Peek$(ad),"_Okay",2,1,4)
  Else
    Select ItemHit
      Case 5
        Gosub Savewindows
      Case 6
        Gosub doscreenmode
      Case 7
        Gosub dowindowheight
      Case 8
      *font.TextAttr=RTEZFontRequest("Choose a debugger font")
      prefs\fontname=Peek$(*font.TextAttr\ta_Name)
      prefs\fontsize=*font.TextAttr\ta_YSize
      ret=Request("Choose Menu Save configuration or quit and restart debugger","Save prefs and restart debugger","ok")
;        reply=GTMenuChecked(0,0,8)
;        If reply<>tokenise
;          If reply Then tokenise=1 Else tokenise=0
;          tokenise=1
;          SetupLESDebug token_addr,tokenise
;          If tokenise=1
;            BitMap 3,640,maxheight,2
;          Else
;            Use Window #_winSource
;              w.w=InnerWidth
;              hi.w=InnerHeight
;              ;Boxf 0,0,w,hi,0
;            ;InnerCls
;            Gosub wprint
;            Free BitMap 3
;          EndIf
;          If winstatus(#_winDisAsm)
;            Use Window #_winDisAsm
;            ;InnerCls
;              w.w=InnerWidth
;              hi.w=InnerHeight
;              ;Boxf 0,0,w,hi,0
;              UpdateDisAsm{}
;
;          EndIf
;          pb=0:mc=-1:Gosub prtcode
;        EndIf
      Case 9
        syntax_=GTMenuChecked(0,0,9)
        Gosub newsize
        Gosub refwindow
      Case 10
        logcon=GTMenuChecked(0,0,10)
      Case 11
        CNIF #test=1
          exitflag=1
        CELSE
          d_quit{}
        CEND
      Case 12
        reply=RTEZRequest(scrtitle$,Peek$(?hardquit),"_Quit|_Cancel",2,1,4)
        If reply Then exitflag=1
    End Select
  EndIf
Return

hardquit: Dc.b "Perform hard Quit?",10,"Warning: Debug process will not",10,"exit.",0
          Even

.domenu1:
  If ItemHit<9
    evw=#_winControl
    ev=64
    gad=ItemHit+11
    i$=""
    If gad=17 Then Toggle #_winControl,17 : Redraw #_winControl,17
    If gad=18 Then Toggle #_winControl,18 : Redraw #_winControl,18
    If gad=19 Then Toggle #_winControl,19 : Redraw #_winControl,19
  Else
    Select ItemHit
    Case 10
      If winstatus(#_winSearch)=0
        NewWindow{#_winSearch}
        RedrawSearchWin{?variabletypes}
      Else
        DelWindow{#_winSearch}
      EndIf
    Case 11
      array$=RTEZGetString("Arrays","Enter array name:",80)
      If array$<>""
        a=Instr(array$,"(")
        b=Instr(array$,",")
        c=Instr(array$,")")
        If b=0
          array1=0
          array2=Vallong(Mid$(array$,a+1,c-1))
        Else
          array1=Vallong(Mid$(array$,a+1,b-a-1))
          array2=Vallong(Mid$(array$,b+1,c-b-1))
        EndIf
        array$=Left$(array$,a-1)
        nt=RTEZRequest("Arrays","Enter variable type:","_b|_w|_l|_Cancel")
        If nt<>0
          If array1<>0
            d_eval{"&"+array$+"(0,0)",#SIGNAL}
          Else
            d_eval{"&"+array$+"(0)",#SIGNAL}
          EndIf
          arrayitemsize=(2^nt)+1
          arraydatasize=nt

          If array1>array2
            si=array1
          Else
            si=array2
          EndIf
          a$=Hex$(si)
          If si>255
            If si>65535
              arraylabelsize=4
            Else
              arraylabelsize=2
            EndIf
          Else
            arraylabelsize=1
          EndIf
          pos=1
          While Mid$(a$,pos,1)="0"
            pos+1
          Wend
          pos=(9-pos)+1
          If pos>arrayitemsize Then arrayitemsize=pos
          evalrequest=#_arrayfind
        EndIf
      EndIf
    Case 12
      is_bb=0
      Gosub NewTypeWindow
    Case 13
      If winstatus(#_winCustom)=0
        NewWindow{#_winCustom}
        RedrawCustomWin{}
      Else
        DelWindow{#_winCustom}
      EndIf
    Case 14
      If winstatus(#_winMouseables)=0
        NewWindow{#_winMouseables}
        RedrawMouseables{True}
      Else
        DelWindow{#_winMouseables}
      EndIf
    Case 15
     If winstatus(#fpuwin)=0
     If wininfo(#fpuwin)\w=0 Then wininfo(#fpuwin)\w=539:wininfo(#fpuwin)\h=36
      wininfo(#fpuwin)\gadlist=-1
      WZWindow #fpuwin,?wzdat,20,wininfo(#fpuwin)\x,wininfo(#fpuwin)\y,wininfo(#fpuwin)\w,(wininfo(#fpuwin)\h*WinFontHeight)/8,1
      winstatus(#fpuwin)=-1
     Else
       DelWindow{#fpuwin}
     End If
     If winstatus(#_winVariables) UpdateVarWindow{}
     Gosub RedrawRegs
    Case 16
     asmstep=NOT asmstep
    Case 17
     Poke $0,$beaddeef
     addr0=Peek.l (0)
     watch0=NOT watch0
    End Select
  EndIf
Return
Statement newwizardwin{h,num,ad.l}
SHARED winstatus(),wininfo()
     If wininfo(h)\w=0 Then wininfo(h)\w=539:wininfo(h)\h=36
      wininfo(h)\gadlist=-1
      WZWindow h,ad,20,wininfo(h)\x,wininfo(h)\y,wininfo(h)\w,wininfo(h)\h,num
      winstatus(#fpuwin)=-1
End Statement
.domenu2:
  If objectbusy=0 AND dstatus=#STOPPED
    mytype=ItemHit
    address=Peek.l(?MyTypes+(mytype ASL 2))
    is_bb=-1
    Gosub NewTypeWindow
  EndIf
Return

.domenu3:
  Select ItemHit
    Case 0
      Gosub GetNewVariable
      If winstatus(#_winVariables)=0
        NewWindow{#_winVariables}
        End If
    Case 1
      na$=RTEZGetString(varfollow$,"Enter variable name:",80)
      If na$<>""
        Gosub _Deltrace

        If a AND winstatus(#_winVariables)
          RedrawVarWindow{}
          UpdateVarWindow{}
        EndIf
      EndIf
    Case 2
      reply=RTEZRequest(varfollow$,"Clear all variables?","_Yes|_No")
      If reply=1
        ClearList varinfo()
        If winstatus(#_winVariables) Then RedrawVarWindow{}
      EndIf
    Case 3
      StringSort varinfo(),SizeOf.variabletype
      If winstatus(#_winVariables)
        RedrawVarWindow{}
        UpdateVarWindow{}
      EndIf
    Case 5
      autoeval=GTMenuChecked(0,3,5)
      If autoeval<>0 AND na$="" Then Gosub DefAutoEval
    Case 6
      Gosub DefAutoEval
    Case 8
      a$=RTEZGetString(scrtitle$,"Enter breakpoint address:",10)
      If a$<>""
        ad=Vallong(a$)
        Gosub addbreakpoint
      EndIf
    Case 9
      t$="Select breakpoint to delete:"
      flag=-1
      Gosub SelectBP
      If bp
        ad=breakpoint_adr+((bp-1)ASL 3)
        Gosub deletebreakpoint
      EndIf
    Case 10
      If Peek.l(breakpoint_adr)
        a=RTEZRequest(scrtitle$,"Kill all breakpoints?","_Okay|_Cancel")
        If a
          FillMem ?breakpoint,5*8
          If winstatus(#_winDisAsm) Then UpdateDisAsm{}
        EndIf
      EndIf
    Case 11
      t$="Current breakpoints:"
      flag=0
      Gosub SelectBP
  End Select
Return

.domenu4:
  D_InitParse customcomm$(ItemHit)
  a$=ProcessString
  Execute_ a$,0,0
Return

;ad=address
;typ=type of breakpoint (#break_?????)
;Returns: flag=0 for error, else -1 for added okay
addbreakpoint_quiet:
  If Peek.w(ad)=$4e41
    ad+2
    a=typ
    If a
      ad2=breakpoint_adr
      num=0
      While Peek.l(ad2)<>0
        If Peek.l(ad2)=ad
          Poke.l ad2,0
        Else
          ad2+8
          num+1
        EndIf
      Wend

      Poke.l ad2,ad
      Poke.w ad2+4,a
      If a=#break_simple Then b=1 Else b=0
      Poke.w ad2+6,b
      flag=-1
    EndIf
  EndIf
Return

DefAutoEval:
  na$=RTEZGetString("Auto EVAL","Please enter string to evaluate:",80,autoeval$)
  If na$<>""
    autoeval$=na$
    autoeval=1
  Else
    autoeval=0
    autoeval$=""
  EndIf
  GTSetMenuChecked 0,3,5,autoeval
Return

.addbreakpoint:
  If Peek.w(ad)=$4e41 OR asmstep
    ad+2
    a=RTEZRequest(scrtitle$,"Select a breakpoint or function:","_Permanent|C_ount|_Simple|Cnt _down|_Remove Stop|Set PC|_Cancel")
    b=0
    If a=4
      a$=RTEZGetString(scrtitle$,"Enter the counter value for this breakpoint:",20)
      b=Vallong(a$)
      If b=0 Then a=0
    EndIf
     If a=6
           pc_ad=Peek.l(?mybuffer)
           Poke.l pc_ad+64,ad : Gosub RedrawRegs:
           UpdateDisAsm{}:
         a=0
     End If
    If a

      If a=5
          Poke.l ad+8,$4e714e71:Poke.w ad+12,$4e71:UpdateDisAsm{}:disasm_ad=ad
          CacheClearU_
      Return
      End If
      ad2=breakpoint_adr
      num=0
      While Peek.l(ad2)<>0 AND num<#maxbreakpoints
        If Peek.l(ad2)=ad
          Poke.l ad2,0
        Else
          ad2+8
          num+1
        EndIf
      Wend
      If num<#maxbreakpoints
        If a=#break_simple Then b=1
        If a=#break_countdown Then a=#break_simple
        bt1=ad2-breakpoint_adr
        Poke.w bt1+?breakstore,Peek.w(ad-2)
        If asmstep Then Poke.w ad-2,$4e41
        Poke.l ad2,ad
        Poke.w ad2+4,a
        Poke.w ad2+6,b
      Else
        a=RTEZRequest(scrtitle$,"No spare breakpoints available.","_Okay")
      EndIf
      If winstatus(#_winDisAsm) Then UpdateDisAsm{}
    EndIf
  Else
    a=RTEZRequest(scrtitle$,"Can only breakpoint basic instructions.","_Okay")
  EndIf
Return

;ad=address of breakpoint to delete
.deletebreakpoint:
  bt1=ad-breakpoint_adr
  Poke.w Peek.l(ad)-2,Peek.w(bt1+?breakstore)
  While Peek.l(ad)<>0
    Poke.l ad,Peek.l(ad+8)
    Poke.l ad+4,Peek.l(ad+12)
    ad+8
  Wend
  If winstatus(#_winDisAsm) Then UpdateDisAsm{}
Return

;t$=text to display
;Returns breakpoint number in bp (or 0 for cancel)
.SelectBP:
  a$=""
  b$=""
  ad.l=breakpoint_adr
  If Peek.l(ad)=0
    a=RTEZRequest(scrtitle$,"No breakpoints defined.","_Okay")
    bp=0
  Else
    num=0
    While Peek.l(ad)<>0
      num+1
      ad2=Peek.l(ad)
      Gosub GETInstruction

      a$+"BP "+Str$(num)+": "+GetHex$(ad2-2,3)+" >>> "+Left$(d_d$,40)+Chr$(10)
      If flag Then b$+"_"+Str$(num)+"|"
      ad+8
    Wend
    If flag
      b$+"_Cancel"
    Else
      b$="_Okay"
    EndIf
    bp.w=RTEZRequest(scrtitle$,t$+Chr$(10)+a$,b$)
  EndIf
Return

.doscreenmode:
  If SubHit<4
    scrmode=SubHit
  Else
    Select SubHit
      Case 5
        *myscr.screeninfo=0
        *myscr=RTEZScreenModeRequest("Editor screen mode",%1000010000000000000)
        If *myscr
          If *myscr\width>=640 AND *myscr\height>=200
            ModeID=*myscr\id

            swidth=*myscr\width
            sheight=*myscr\height
          Else
            reply=RTEZRequest(scrtitle$,"Minimum screen size is 640 x 200.","_Okay")
          EndIf
        EndIf
    End Select
  EndIf
  Gosub CheckScrModeMenus
Return

.CheckScrModeMenus:
  If scrmode=1 OR scrmode=2
    a=On
  Else
    a=Off
  EndIf

  GTMenuState 0,0,6,6,a
  GTMenuState 0,0,6,7,a
Return

dowindowheight:
  a=RTEZGetLongRange(scrtitle$,"Maximum window height:",200,1024,maxheight)
  If a<>0
    maxheight=a
    BitMap 1,640,maxheight,1          ; WIDTH MUST NOT CHANGE!
    If tokenise Then BitMap 3,640,maxheight,2
  EndIf
Return

.CorruptWindow:
  If evw>=#_winObject0 AND evw<=#_winObject9
    FindStructureWin{evw}
    RefreshTypeWindow{}
    Return
  EndIf
  Select evw
    Case #_winSource
    Use Window #_winSource
    ;BeginRefresh_ !windowaddr
      Gosub newsize
      Gosub refwindow
    ;EndRefresh_  !windowaddr,True
    Case #_winMemory1
      Use Window #_winMemory1
      ;InnerCls
        w.w=InnerWidth
  hi.w=InnerHeight
  ;Boxf 0,0,w,hi,0
      dowin=0
      Gosub RedrawMem
    Case #_winMemory2
      Use Window #_winMemory2
      ;InnerCls
        w.w=InnerWidth
        hi.w=InnerHeight
        ;Boxf 0,0,w,hi,0
      dowin=1
      Gosub RedrawMem
    Case #_winVariables
      RedrawVarWindow{}
      UpdateVarWindow{}
    Case #_winDisAsm
      UpdateDisAsm{}
    Case #_winDisCop
      UpdateDisCop{}
    Case #_winSearch
      RedrawSearchWin{?variabletypes}
    Case #_winArray
      RedrawArray{1}
    Case #_winCustom
      RedrawCustomWin{}
    Case #_winMouseables
      mouseables_off=0
      RedrawMouseables{True}
  End Select
Return

.Movetoregister:
  a=Vallong(Right$(strg$,1))
  If a>=0 AND a<=7
    ad=Peek.l(?mybuffer)
    mempointer(cur)=Peek.l(ad+32+(32*(a$="d"))+(a ASL 2))
    If mflag Then mempointer(cur)=Peek.l(mempointer(cur))
  Else
    reply=RTEZRequest(scrtitle$,"Invalid register number!","Ok")
  EndIf
Return

;i=code line to grab
.getsyntax:
  syntax_$=""
  If i
    toke.w=Peek.w(getad{i}+Peek.w(i+4))
    ;toke.w=Peek.w(Peek.l(i)+Peek.w(i+4))
    tokead.l=token_addr
    toke=toke AND $7fff
    While (tokead<>0 AND toke<>-1)
      If Peek.w(tokead+4)=toke
        syntax_$=Peek$(tokead+6)
        syntax_$+" "+Peek$(tokead+7+Len(syntax_$))
        toke=-1
      EndIf
      tokead=Peek.l(tokead)
    Wend
  EndIf
  Gosub syntaxprint
Return

.wprint:
  Use Window #_winSource
  lt$=t$
  y=wprinty
  Gosub printlin
  If syntax_=0 Then NPrint "                                                                                                       ":Return
syntaxprint:
  Use Window #_winSource
  y=wprinty-WinFontHeight-5
  t$=syntax_$
  Gosub printlin
Return

;y=y pixel to print at
;t$=line to print
printlin:
  Wline ix,y-1,ix+iw-1,y-1,1
  Wline ix,y,ix+iw-1,y,2
  WBox ix,y+1,ix+iw-1,y+WinFontHeight+2,0
  b=Len(t$)
  a=TextFit_(RastPort(#_winSource),t$,b,&myextent.TextExtent,0,1,iw-2,1024)

  WLocate 1,y-iy+2:WColour 1,0
  If b<a
    Print t$
  Else
    Print Left$(t$,a)
  EndIf
Return

;wy=offset from top of window
.initgads:

  Restore buttondata
  Borders 4,2:BorderPens 2,1
  gx=4:gn=1:wy=topborder+2
  Repeat
    Read t$
    If t$<>""
      gf=0
      If t$="GS" OR t$="PS" OR t$="BC" Then gf=%1
      TextGadget #_winControl,gx,wy,gf,gn,t$:gx+Len(t$)LSL 3+8
      gn+1
    EndIf
  Until t$=""
;Search window:
  BorderPens 1,2
  StringGadget 3,88,wy,0,0,10,160
  StringGadget 3,88,wy+14,0,1,10,160

  StringGadget 2,160,wy,0,1,40,160
  StringGadget 2,160,wy+14,0,4,40,160

  StringGadget 2,160,wy+34,0,7,256,160

  BorderPens 2,1
  TextGadget 2,160,wy+48,0,8,"  "

  TextGadget 2,332,wy,0,2,"MEM1"
  TextGadget 2,372,wy,0,3,"MEM2"
  TextGadget 2,332,wy+14,0,5,"MEM1"
  TextGadget 2,372,wy+14,0,6,"MEM2"

  Borders 8,4
  TextGadget 2,150,wy+69,0,10," Start search "
  Borders 4,2

;Array window
  PropGadget  #_winArray,-13,wy+1,#VPROP_AFLAGS,#ARR_YGAD,10,-17-WinFontHeight-22,#VPROP_PFLAGS,3

  ArrowGadget #_winArray,#ARR_UGAD,#UPIMAGE,-17,-20-11,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
  ArrowGadget #_winArray,#ARR_DGAD,#DOWNIMAGE,-17,-20,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2

  PropGadget  #_winArray,3,-7,#HPROP_AFLAGS,#ARR_XGAD,-22-33,6,#HPROP_PFLAGS,3

  ArrowGadget #_winArray,#ARR_LGAD,#LEFTIMAGE,-49,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
  ArrowGadget #_winArray,#ARR_RGAD,#RIGHTIMAGE,-33,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
  SetPropInfo #_winArray,#ARR_YGAD,1,1
  SetPropInfo #_winArray,#ARR_XGAD,1,1

;Source window
  PropGadget  #_winSource,3,-7,#HPROP_AFLAGS,#SRC_SGAD,-22-33,6,#HPROP_PFLAGS,3
  ArrowGadget #_winSource,#SRC_LGAD,#LEFTIMAGE,-49,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
  ArrowGadget #_winSource,#SRC_RGAD,#RIGHTIMAGE,-33,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2

;label window
  PropGadget  #_winMouseables,-13,wy+1,#VPROP_AFLAGS,#MSE_SGAD,10,-17-WinFontHeight-22,#VPROP_PFLAGS,3
  ArrowGadget #_winMouseables,#MSE_UGAD,#UPIMAGE,-17,-20-11,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
  ArrowGadget #_winMouseables,#MSE_DGAD,#DOWNIMAGE,-17,-20,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
Return

buttondata:
Data$ "STOP","STEP","SKIP","TRACE","RUN","<",">","EXEC"
Data$ "EVAL","BLTZ","REG","MEM1","MEM2","VAR","ASM"
Data$ "COP","GS","PS","BC",""

;-2=workbench
;-1=like workbench
.findsc:
  ;*scr=0
  dreg=0
  pubname$=""

  Use IntuiFont 1
  Select scrmode
    Case #SCR_WB
      FindScreen 0,"Workbench"
      pubname$="Workbench"
      dreg=&pubname$
    Case #SCR_DEFPUB
      dreg=0
    Case #SCR_NAMEDPUB
      dreg=&pubscreenname$
  End Select

                                                                                                                                                                                                                                                        


  If ExecVersion<39 AND scrmode=#SCR_LIKEWB
    ModeID=$8000:swidth=640:sheight=DispHeight
  EndIf

  If scrmode=#SCR_LIKEWB OR scrmode=#SCR_CUSTOM
    If scrmode=#SCR_LIKEWB AND ExecVersion>=39
      si=?myscreentags1
      CNIF #test=1
        Poke.l ?scrbehind1+4,0
      CEND
    Else
      If ExecVersion<39
        si=?myscreentagsv37
      Else
        si=?myscreentags2
      EndIf
      Gosub SetupScreenTags
      CNIF #test=1
        Poke.l ?scrbehind2+4,0
      CEND
    EndIf

    If pubscreen=0
      Poke.l si+4,0
    Else
      Poke.l si+4,?pubname
    EndIf

    If ScreenTags(0,scrtitle$,si)<1024
      ModeID=$8000
      swidth=640
      sheight=DispHeight
      Gosub SetupScreenTags
      ScreenTags 0,scrtitle$,si
    EndIf

    s0=Peek.l(Addr Screen(0))
    If pubscreen
      PubScreenStatus_ s0,0
      pubname$="REDDebugger"
    End If

    sw=Peek.w(s0+12):sh=Peek.w(s0+14)
    CNIF #test=0
      Window #_winBackdrop,0,0,sw,sh,$200900,"",1,2
    CELSE
      Window #_winBackdrop,0,0,sw,sh,$201900,"",1,2
    CEND
  Else
    If GetPubScreen(0,dreg)=0
      GetPubScreen 0,0
      dreg=0
    EndIf
    s0=Peek.l(Addr Screen(0))
  EndIf
     ;FindScreen(0)
   ;   If FindTask_("amiblitz2")=0
   ;      Execute_ "blitz2:amiblitz2",0,0
   ;      Delay_ 100
   ;   End If


   
  AddProcessPtr "s",&pubname$

  sw=Peek.w(s0+12):sh=Peek.w(s0+14)
Return

SetupScreenTags:
  Poke.l ?scrmodeid+4,ModeID
  ;Poke.l ?scrwidth+4,swidth
  ;Poke.l ?scrheight+4,sheight
Return

.myscreentags1:
              Dc.l  #SA_PubName,pubname    ; MUST BE FIRST TAG!
              Dc.l  #SA_Type,#PUBLICSCREEN
              Dc.l  #LikeWorkbench,1
              ;Dc.l  #_Depth,2
              Dc.l  #AutoScroll,-1
  ;scrbehind1: Dc.l  #Behind,-1
              Dc.l #SA_SharePens,-1
              Dc.l  0,0

myscreentagsv37:
              Dc.l  #Pens,pens
myscreentags2:
              Dc.l  #SA_PubName,pubname    ; MUST BE FIRST TAG!
              Dc.l  #SA_Type,#PUBLICSCREEN
              Dc.l  #LikeWorkbench,1
              ;Dc.l  #_Depth,2
  scrmodeid:  Dc.l  #DisplayID,0
  scrwidth:   ;Dc.l  #Width,0
  scrheight:  ;Dc.l  #Height,0
              Dc.l  #AutoScroll,-1
              Dc.l #SA_SharePens,-1
  ;scrbehind2: Dc.l  #Behind,0
              Dc.l  0,0
pubname:      Dc.b  "ab2debugger",0
              Even
pens:         Dc.w  -1

.printsourcewin
.refwindow:

  If ali<>0 OR lt$<>""
   Use Window #_winSource:
    ;WindowFont 1
    WBox ix,iy+(ch/WinFontHeight ),ix+iw-1,y,0
    If ali Then i=ali:Gosub prtcode
    If syntax_
      y=wprinty-6-WinFontHeight
    Else
      y=wprinty-1
    EndIf

    t$=lt$:Gosub wprint
  EndIf
  WLocate 0,0
Return

;Close a window
;evw=window number
;flag=0 means DON'T CLOSE DEFAULT WINDOWS!
.RemoveWindow:
  If evw=#_winSource OR evw=#_winControl
    If flag
      CNIF #test=1
        exitflag=1
      CELSE
        d_quit{}
      CEND
    EndIf
  Else
    If evw>=#_winObject0 AND evw<=#_winObject9
      FindStructureWin{evw}
      FreeMem objwins()\mem_type,(objwins()\numitems ASL 2)+4
      KillItem objwins()
    EndIf
    DelWindow{evw}
    If evw>=#_winObject0 AND evw<=#_winObject9
      Free GadgetList evw
    EndIf
  EndIf
Return

.openwindow:
  topborder.l=WTopOff
  bottomborder.l=WBottomSize
  wininfo(#_winMemory1)\title="Memory 1"
  wininfo(#_winMemory2)\title="Memory 2"
  wininfo(#_winControl)\x=0,11,640,17,$20002e,cntrlwin$,#_winControl,?help_cntrlwin
  wininfo(#_winRegisters)\x=0,37,640,77,$20002e,"Register window",-1,?help_reg
  wininfo(#_winSource)\flags=$0002f,"",#_winSource,?help_source
  wininfo(#_winVariables)\flags=$20002f,varfollow$,-1,?help_var
  wininfo(#_winDisAsm)\flags=$20002f,"Disassembly",-1,?help_asm
  wininfo(#_winDisCop)\flags=$20002f,"Copper instructions",-1,?help_cop
  wininfo(#_winSearch)\x=0,11,420,100,$20002e,"Search window",2,?help_search
  wininfo(#_winArray)\flags=$20003f,"Array",#_winArray,?help_array
  wininfo(#_winCustom)\x=0,11,272,41,$20002e,"Custom Chip window",3,?help_chips
  wininfo(#_winMouseables)\flags=$20003f,"Label List",#_winMouseables,?help_labels

  ad2=-1
  If D_FindVolume("ENV")
    If ReadFile(0,"ENV:RED_DBug.prefs")
      ;If Lof(0)=configsize
        ad2=AllocMem_(configsize+10,%1)
        ad=ad2
        ReadMem 0,ad2,configsize
        If Peek.w(ad2)<>((#dbug_version ASL 8)+#dbug_revision)
          FreeMem_ ad2,configsize+10
          ad2=-1
        EndIf
      ;EndIf
      If ReadFile(0,"ENV:RED_DBug2.prefs")
        ReadType 0,prefs
        If prefs\fontname="" Then prefs\fontname="topaz.font",8
        CloseFile 0
      EndIf
      CloseFile 0
    EndIf
  EndIf

  LoadFont 1,prefs\fontname,prefs\fontsize
  If ad2=-1 Then ad=?initstate
  startcode=0
  scrmode=Peek.w(ad+2)
   ad+4
  ModeID=Peek.l(ad)
  swidth=Peek.w(ad+4)
  sheight=Peek.w(ad+6)
  tokenise=Peek.b(ad+8)
  tokenise=1
  pubscreen=Peek.b(ad+9)
  maxheight=Peek.w(ad+10)
  BitMap 1,640,maxheight,1          ; WIDTH MUST NOT CHANGE!
  If tokenise Then BitMap 3,640,maxheight,2
  Gosub findsc
  address.l=ad
  Gosub openmenus
  ad=address
  fontstruct.TextAttr\ta_Name=?topazname,8,0,0
  LoadFont 0,"topaz.font",8
  Gosub initgads
  num=Peek.w(ad+12)
  ad+14
  For h=0 To num-1
    winstatus(h)=Peek.w(ad) : ad+2
    If (#noresize BitTst h)
      wininfo(h)\h+topborder+bottomborder
    Else
      wininfo(h)\w=Peek.w(ad+4),Peek.w(ad+6)
    EndIf

    wininfo(h)\x=Peek.w(ad),Peek.w(ad+2)

    ad+8
  Next h
  MaxLen disasmlock$=85
  MaxLen disasmlockpf$=85
  procstatus=Peek.b(ad)   : ad+1 : If procstatus Then Toggle #_winControl,18,On
  blitzcontrol=Peek.b(ad) : ad+1 : If blitzcontrol Then Toggle #_winControl,19,On
  gosubstatus=Peek.b(ad)  : ad+1 : If gosubstatus Then Toggle #_winControl,17,On
  defpubscreen=Peek.b(ad) : ad+1
  syntax_=Peek.b(ad)       : ad+1
 . @prefsload
  disasmlock$=Peek$(ad)
  If disasmlock$="" Then disasmlock$="pc-2"
  Poke$ ?disasmlockstr,disasmlock$
  ConvToPostFix disasmlock$,&evalbuffer$
  i=PFEvaluate(Peek$(&evalbuffer$))
   disasmlockpf$=Peek$(&evalbuffer$)
  If disasmlock$<>""
wininfo(#_winDisAsm)\title="Disassembly ("+disasmlock$+")"
  initdiss=20
  End If

  ad+128
  num2=Peek.w(ad)
  ad+2
  For h=23 To num2-1
    winstatus(h)=Peek.w(ad) : ad+2
    If (#noresize BitTst h)
      wininfo(h)\h+topborder+bottomborder
    Else
      wininfo(h)\w=Peek.w(ad+4),Peek.w(ad+6)
    EndIf

    wininfo(h)\x=Peek.w(ad),Peek.w(ad+2)

    ad+8
  Next h
  If scrmode=#SCR_LIKEWB OR scrmode=#SCR_CUSTOM
    If pubscreen AND defpubscreen Then SetDefaultPubScreen_ ?pubname
  Else
    ReleasePubScreen 0,dreg
  EndIf
  If ad2<>-1 Then FreeMem_ ad2,configsize+10
   For h=23 To num2-1
      If winstatus(h) AND (#winprotect BitTst h)=0
         newwizardwin{h,1,?wzdat}
        evw=h
      End If
  Next
  NewWindow{#_winControl}
  ;NewWindow{#_winRegisters}

  For h=0 To num-1
    If winstatus(h) AND (#winprotect BitTst h)=0
      If h=#_winMemory1 OR h=#_winMemory2
        NewMemWindow{h}
      Else
        NewWindow{h}
        evw=h
        Gosub CorruptWindow
      EndIf
    Else
      winstatus(h)=0
    EndIf
  Next h
  GTSetMenuChecked 0,0,8,tokenise
  GTSetMenuChecked 0,0,6,6,pubscreen
  GTSetMenuChecked 0,0,6,7,defpubscreen
  GTSetMenuChecked 0,0,9,syntax_
  GTSetMenuChecked 0,0,10,logcon
  GTSetMenuChecked 0,0,6,scrmode,On
  GTSetMenuChecked 0,1,16,asmstep
  Gosub CheckScrModeMenus
                                                                                                                                                                                                                                                        


  Use Window #_winSource
  ;WindowFont 0

  CatchDosErrs
  CNIF #test=1
    Activate #_winControl
  CEND
Return

.newsize:
  Use Window #_winSource:InnerCls
  ;WindowFont 1
  ix=WLeftOff:iy=WTopOff:iw=InnerWidth:ih=InnerHeight-WinFontHeight-5
  ;ix=0:iy=0:iw=InnerWidth:ih=InnerHeight-fontheight-5
  wprinty=iy+ih+2
  ;iy=11
  If syntax_ Then ih-WinFontHeight-5
  cw=iw/8:ch=ih/WinFontHeight
  ym=ch LSR 1:If ch&1=0 Then ym-1
  ym*WinFontHeight:spc$=String$(" ",cw)
  Gosub printsourcewin
  SetPropInfo #_winSource,1,cw,1000,source_char_offset
  Redraw #_winSource,1
Return

.openmenus:
  ;Menu 0
  GTMenuTitle 0,0,"Project"
  GTMenuItem 0,0,0,0,"Status register","",0,?help_menus
  GTMenuItem 0,0,0,1,"About Debugger","",0,?help_about
  GTMenuItem 0,0,0,2
  GTMenuItem 0,0,0,3,"Keyboard shortcuts","",0,?help_menus
  GTMenuItem 0,0,0,4
  GTMenuItem 0,0,0,5,"Save configuration","W",0,?help_configuration
  GTMenuItem 0,0,0,6,"Screen mode...","",0,?help_screenmode

  GTSubItem  0,%1,0,6,0,"Workbench","",%1110,?help_screenmode
  GTSubItem  0,%1,0,6,1,"Like Workbench","",%1101,?help_screenmode
  GTSubItem  0,%1,0,6,2,"Custom","",%1011,?help_screenmode
  GTSubItem  0,%1,0,6,3,"Default public","",%0111,?help_screenmode
  GTSubItem  0,%1,0,6,4
  GTSubItem  0,%0,0,6,5,"Select custom...","",0,?help_screenmode
  GTSubItem  0,%1001,0,6,6,"Public screen","",0,?help_screenmode
  GTSubItem  0,%1001,0,6,7,"Default pubscreen","",0,?help_screenmode

  GTMenuItem 0,0,0,7,"Window height...","",0,?help_screenmode
  GTMenuItem 0,0,0,8,"Choose Font","",0,?help_menus
  GTMenuItem 0,%1001,0,9,"Show syntax","",0,?help_menus
  GTMenuItem 0,%1001,0,10,"Trace Log"
  GTMenuItem 0,0,0,11,"Quit"
  ;GTMenuItem 0,0,0,12,"Quit & die"

  ;Menu 1
  GTMenuTitle 0,1,"Windows"
  GTMenuItem 0,0,1,0,"Registers","D",0,?help_reg
  GTMenuItem 0,0,1,1,"Memory 1","M",0,?help_mem
  GTMenuItem 0,0,1,2,"Memory 2","N",0,?help_mem
  GTMenuItem 0,0,1,3,"Variables","V",0,?help_var
  GTMenuItem 0,0,1,4,"Disassembly","6",0,?help_asm
  GTMenuItem 0,0,1,5,"Copper","C",0,?help_cop
  GTMenuItem 0,0,1,6,"Gosub Step","G",0,?help_gs
  GTMenuItem 0,0,1,7,"Procedure Step","P",0,?help_ps
  GTMenuItem 0,0,1,8,"Blitz Control","B",0,?help_bc
  GTMenuItem 0,0,1,9
  GTMenuItem 0,0,1,10,"Search memory","S",0,?help_search
  GTMenuItem 0,0,1,11,"Array...","R",0,?help_array
  GTMenuItem 0,0,1,12,"Structure...","T",0,?help_struct
  GTMenuItem 0,0,1,13,"Custom chips","",0,?help_chips
  GTMenuItem 0,0,1,14,"Label list","",0,?help_labels
  GTMenuItem 0,0,1,15,"FPU On","",0,?help_fpu
  GTMenuItem 0,%1001,1,16,"Asm Step...","",0,?help_asmstep
  GTMenuItem 0,%1001,1,17,"Check Addr 0 Change","",0,?help_watch0
  ;Menu 2
  GTMenuTitle 0,2,"Objects"
  si=?MyTypes
  num=0
  Repeat
    ad1=Peek.l(si)
    si+4
    If ad1
      a$=Peek$(ad1+2)
      If num=0 Then a$=a$+"       "
      GTMenuItem 0,0,2,num,a$,"",0,?help_objects
      num+1
    EndIf
  Until ad1=0
  ;Menu 3
  GTMenuTitle 0,3,"Misc"
  GTMenuItem 0,0,3,0, "Add trace...","A",0,?help_menus
  GTMenuItem 0,0,3,1, "Delete trace...","",0,?help_menus
  GTMenuItem 0,0,3,2, "Delete all...","",0,?help_menus
  GTMenuItem 0,0,3,3, "Sort names","",0,?help_menus
  GTMenuItem 0,0,3,4
  GTMenuItem 0,%1001,3,5, "Auto EVAL","",0,?help_autoeval
  GTMenuItem 0,0,3,6, "Define","Z",0,?help_autoeval
  GTMenuItem 0,0,3,7
  GTMenuItem 0,0,3,8, "Add breakpoint...","[",0,?help_breakpoints
  GTMenuItem 0,0,3,9, "Delete...","]",0,?help_breakpoints
  GTMenuItem 0,0,3,10, "Delete all...","",0,?help_breakpoints
  GTMenuItem 0,0,3,11,"List...","",0,?help_breakpoints
  GetCustomMenus{}

  CreateMenuStrip 0
Return

stopit:
  prtcode=-1:stepcnt=0:dstatus=#STOPPED:statego=-1
Return
.getevent:
. @memcheckloop
  Repeat
   ev=Event:
   If ev=0
    If dstatus=#TRACE
      Delay_ 1
    Else
      Delay_ 2
    End If
   End If
again1
   If ev=#IDCMP_MOUSEMOVE Then CloseWindow #bubble:winbubble=0:ev=Event:Goto again1
   memchecktimer-1
   currentwin=Used Window
   If watch0 Then If Peek.l (0) <> addr0
     Use Window 0:WTitle "!!!! Address 0 is changed !! $"+Hex$(Peek.l(0))+" "+Left$(Peek.s(Peek.l(0)),30)
     Use Window currentwin
   End If
   ;BTST #8,$dff016
   ;BNE nomid
  ;BTST #6,$bfe001
   ;BNE nomouse
;    If (EventQualifier AND $1000)=0 Then Goto nomid
;      ev=Event
;    !cout{EventQualifier}
;
;
;
;   nomid:

   ;AddIDCMP #IDCMP_INTUITICKS

Goto _skip

checkclicks
If (EventCode AND $80)<>0 Then Goto nomid2       ;ignore up mouse
If (EventQualifier AND $1000)=0 Then Goto nomid3
  If evw=#_winMemory2
     If EventQualifier AND $30
      JSR memhistoryup
      Delay_(10)
    End If
    If EventQualifier AND $c0
     JSR memhistorydown
     Delay_(10)
    End If
  End If
  If evw=#_winDisAsm
       If EventQualifier AND $30
       JSR historyup
        Delay_(10)
        FlushEvents
       End If
       If EventQualifier AND $c0
       JSR historydown
        Delay_(10)
        FlushEvents
       End If
  End If
nomid3
If (EventQualifier AND $1000)<> 0 Then Goto nomid2
If ActiveWindow=Peek.l (Addr Window (#_winMemory2))
     Use Window #_winMemory2
     ev=Event
     xpos=WMouseX-WLeftOff
     ypos=WMouseY-WTopOff
     If xpos>8 AND xpos < InnerWidth AND ypos>0 AND ypos<(InnerHeight+8)
          ;xpos-72
          ypos/WinFontHeight
          xpos=5;TextFit(mem(ypos),xpos)
          *ptr=&mem(ypos)
          JSR getterm
          JSR addmemhistory
           ConvToPostFix part$,&evalbuffer$
           mempointer(1)=PFEvaluate(Peek$(&evalbuffer$))
           Gosub RedrawMem
           WTitle part$
           Delay_ 10
     End If
     Use Window currentwin
End If

If ActiveWindow=Peek.l (Addr Window (#_winDisAsm))
     Use Window #_winDisAsm
     xpos=WMouseX-WLeftOff
     ypos=WMouseY-WTopOff
If xpos>TextLength_(RastPort,&dis(1),15) AND xpos < InnerWidth AND ypos>0 AND ypos<(InnerHeight+8)
     ypos+WinFontHeight+1
     xpos+TextLength_(RastPort,&dis(1),18)
     ypos=ypos/WinFontHeight
     xpos=xpos/TextFit(dis(ypos),xpos)
     *ptr=&dis(ypos)
   JSR getterm
    If winstatus(#_winMemory2)=0 Then NewMemWindow{#_winMemory2}
        part2$=Replace$ (part$,"(","+")
        If part2$<>part$
        part$=Left$(part2$,Len(part2$)-4)
        If Left$(part$,1)<>"-" Then part$="+"+part$
        part2$=Mid$(part2$,Len(part2$)-2,2)
        part$=part2$+part$
        End If
        WTitle part$

        ConvToPostFix part$,&evalbuffer$
        ev=Event
        If EventQualifier AND $30
        JSR addhistory

        disasm_ad=PFEvaluate(Peek$(&evalbuffer$))
        UpdateDisAsm{}
        Delay_(20)
        Else
        mempointer(1)=PFEvaluate(Peek$(&evalbuffer$))
        Gosub RedrawMem
        End If
    memchecktimer=33
Use Window currentwin
End If
End If
.@sourcewinclick
If ActiveWindow=Peek.l (Addr Window (#_winSource))
     Use Window #_winSource

       ;JSR printbubble
      xpos=WMouseX-WLeftOff
      ypos=WMouseY-WTopOff

If xpos=>0 AND xpos < InnerWidth AND ypos>2 AND ypos<InnerHeight
    ypos+1
     ;xpos-2
     ypos=ypos/WinFontHeight
      *ptr=&src(ypos)
       xpos=TextFit(src(ypos),xpos)
If winbubble=0 Then Window #bubble,SMouseX-10,SMouseY-WinFontHeight*5,WindowWidth,WinFontHeight*3+4,$800,"",0,1:winbubble=1
   If *ptr
     JSR getterm
   Else
     part $=""
   End If
    Gosub storefpuregs
    If Left$(part$,8)="optimize" Then part$="not support"
    If Left$(part$,8)="Syntax" Then part$="not support"
    If Left$(part$,1)="\" part$=path$+poin$+part$:
    If poin$ Then part$=poin$+part$
    If part$ Then d_eval{part$,#SIGNAL}
     WTitle part$
    Delay_(2)
    Gosub restorefpuregs

     ev$=part$
    memchecktimer=33
Use Window currentwin
End If
End If
nomid2: Return
_skip:
nomouse:   If winstatus(#fpuwin) AND fpuneedupdate
       fpuneedupdate-1
      currentwin=Used Window
       Use Window #fpuwin
       MOVE.l fpuoffset,fpreg
       Dc.l $f2276800 ;fmove.x fp0,-(a7)
       TST.l regpos
       BEQ noreg
       For temp=0 To 7
       MOVE.l regpos,a0
      ADD.l fpreg,a0
      Dc.l $f2284800:Dc.w 0;fmove.x 0(a0),fp0
      ADD.l #12,fpreg
      fmove.s fp0,d0
      JSR fpuffp
      fp$(temp)=Str$(ffp)
      WZPrint "fpr0"+Str$(temp),&fp$(temp)
      Next
    noreg:  Dc.l $f21f4800 ;fmove.x (a7)+,fp0
      Use Window currentwin
  End If
    If winstatus(#_winDisAsm) AND initdiss
           ad=PFEvaluate(disasmlockpf$)    ;update disasm
              disasm_ad=ad
              If winstatus(#_winDisAsm) Then UpdateDisAsm{}
              initdiss-1
          EndIf
    If Peek.w(?donebreakpoint)
      t$="[Breakpoint]"
      Gosub wprint
      CLR.w donebreakpoint
    EndIf
    If memchecktimer<1
      a$="Chip: "+Str$(AvailMem_(%10))+" Fast:"+Str$(AvailMem_(%100))
      Use Window #_winSource
      WTitle a$
      memchecktimer=33
    EndIf
    If Peek.l(?varhandler)
      asa=Peek.l(?varhandler)
      n$=Peeks$(asa,256)
      Poke.l ?varhandler,0
      Gosub _CheckTrace
    EndIf
    While FirstItem(d_e())
      ; Program running mode into title of #_winControl
      ad=Peek.l(?progmode)
      a=Peek.w(ad)
      If pmodevalid=0 OR a<>pmode
        pmodevalid=-1
        pmode=a
        GetProgMode pmode,&cntrlwin$+14
        SetWindowTitles_ Peek.l(Addr Window(#_winControl)),&cntrlwin$,-1
      EndIf

      If memlock$(0)
        mempointer(0)=PFEvaluate(memlockpf$(0))
      EndIf
      If memlock$(1)
        mempointer(1)=PFEvaluate(memlockpf$(1))
      EndIf

      If winstatus(#_winMemory1) OR winstatus(#_winMemory2) Then Gosub RedrawMem
      If winstatus(#_winRegisters) Then Gosub RedrawRegs
      If winstatus(#_winVariables) Then UpdateVarWindow{}
      ResetList objwins()
      While NextItem(objwins())
        If objwins()\typepointer>=0 Then RefreshTypeWindow{}
      Wend

      Select d_e()\t
        Case 0                      ;supervisor mode error!
          t$="(*) "+d_e()\s
          Gosub wprint
          Gosub goterr
        Case 1                      ;user mode error!
          t$=d_e()\s
          Gosub wprint
          Gosub goterr
        Case 2                      ;EVAL result
          If execrequest=#_newtypewindow
            PopItem objwins()
            objwins()\typepointer=0
            objwins()\maxobject=1
            execrequest=0
            objectbusy=0
            RefreshTypeWindow{}
          Else
            t$=d_e()\s
            lasteval$=t$
            If Len(t$)<11
            optimize 7
            t$=t$+" $"+Hex$(Val(t$))+" %"+Bin$(Val(t$))
            optimize 5
            End If
            Gosub EVALHandle       ;print eval result
            Delay_ 1
          If winbubble=1 AND part$<>""
            evalstr$=t$
            Use Window #bubble:
            Gosub printbubble
          End If
            Gosub wprint
          EndIf
        Case 3                      ;dump code baby!
          If execrequest=#_newtypewindow
            PopItem objwins()
            execrequest=0
            objwins()\typepointer=objwins()\objbaseadr
            t$=""
            SetPropInfo objwins()\winnum,#OBJ_SGAD,1,objwins()\maxobject,0
            Redraw objwins()\winnum,#OBJ_SGAD
            Use Window objwins()\winnum
            WTitle "Newtype: "+objwins()\t+" #"+Str$(objwins()\tracenum)+"/"+Str$(objwins()\maxobject-1)
            RefreshTypeWindow{}
            objectbusy=0
          EndIf
          If execrequest=#_viewblitz
            Enable #_winControl,10
            execrequest=0
          EndIf
          cb=d_e()\i
          i=Peek.l(buffmem+cb)

          If disasmlockpf$<>""
            ad=PFEvaluate(disasmlockpf$)    ;update disasm
            If ad<>disasm_ad
              disasm_ad=ad
              If winstatus(#_winDisAsm) Then UpdateDisAsm{}
            EndIf
          EndIf

          If syntax_ Then Gosub getsyntax

          pb=0:mc=-1:Gosub prtcode:;prtbusy=0
          Signal_ task,signalset
        Case 4                      ;QUIT - outa-here
          exitflag=1
      End Select
      MaxLen d_e()\s=0:KillItem d_e()
    Wend
    ;ev=Event:If ev=0 Then Delay_(3) : memchecktimer-1
  Until ev<>0 OR exitflag<>0
 Use Window currentwin
 Delay_ 2
Return

.EVALHandle:
  evw.l=evalrequest
  evalrequest=0
  Select evw
    Case #_mouseable_eval
      ad=Vallong(d_e()\s)
      Select evalrequestex
        Case #_winMemory1
          mempointer(0)=ad
          cur=0
          Gosub RedrawMem
        Case #_winMemory2
          mempointer(1)=ad
          cur=1
          Gosub RedrawMem
        Case #_winDisAsm
          disasm_ad=ad
          UpdateDisAsm{}
        Case #_winSource
          il=Peek.l(ad+2)
          Gosub prtcode2
      End Select
    Case #_memwindow
      mempointer(evalrequestex)=Vallong(d_e()\s)
      cur=evalrequestex
      Gosub RedrawMem
      t$=""
    Case #_structaddress
      PopItem objwins()
      objwins()\typepointer=Vallong(d_e()\s)
      RefreshTypeWindow{}
    Case #_variablelocate
      varinfo()\address=Vallong(d_e()\s)
      If varinfo()\address=0
        KillItem varinfo()
        reply=RTEZRequest(scrtitle$,"Variable not found!","_Abort")
      Else
        If varinfo()\typ=4
          mem=varinfo()\address
          Gosub FindString
          varinfo()\address=ad
          If ad=-1 Then KillItem varinfo() : a=RTEZRequest(scrtitle$,"String not found!","_Ok")
        EndIf
        If winstatus(#_winVariables)
          RedrawVarWindow{}
          UpdateVarWindow{}
        EndIf
      EndIf
      t$=""
    Case #_disasmaddress
      disasm_ad=Vallong(d_e()\s) AND $fffffffe
      UpdateDisAsm{}
    Case #_discopaddress
      discop_ad=Vallong(d_e()\s) AND $fffffffe
      UpdateDisCop{}
    Case #_autoevalresult
      t$=autoeval$+"="+t$
    Case #_arrayfind
      arrayadd=Vallong(d_e()\s)
      If winstatus(#_winArray)=0
        NewWindow{#_winArray}
      EndIf
      Use Window #_winArray
      a$=array$+"("
      If array1<>0
        a$+Str$(array1)+","+Str$(array2)+")"
      Else
        a$+Str$(array2)+")"
      EndIf
      WTitle a$
      RedrawArray{1}
  End Select
Return

.FreeStuff:
  For h=0 To (Maximum Window)-1
    If Peek.l(Addr Window(h))
    If h>22
      WZCloseWindow h
      Else
      Free Window h
      End If
      If Peek.l(Addr GadgetList(h)) Then Free GadgetList(h)
    End If

  Next h
again20:  For h= 1 To 100
  If  NewCloseScreen(0)<> 0 Then h=250
  Delay_ 1
  Next
  If h <= 101 Then a=RTEZRequest(scrtitle$,warn1$,"_Ok"):Goto again20
   Free GTMenuList 0
  FreeMem_ buffmem,#bufflen
Return

._CheckTrace:
  Ascii=Peek.b(&n$) AND $ff
  nt=Peek.b(&n$+1)
  nf=Peek.b(&n$+2)
  si=Peek.l(&n$+4)
  na$=Peek$(&n$+8)
  Select Ascii
    Case #_memwindowmove
      If nt=0 OR nt=1
        mempointer(nt)=si
        If nt=0 Then nt=#_winMemory1 Else nt=#_winMemory2
        If winstatus(nt)=0
          NewMemWindow{nt}
        EndIf
      EndIf
    Case #_diswindow
      disasm_ad=si AND $fffffffe
      If winstatus(#_winDisAsm)=0
        NewWindow{#_winDisAsm}
      EndIf
      UpdateDisAsm{}
    Case #_varwindow
      If winstatus(#_winVariables)=0
        NewWindow{#_winVariables}
      EndIf
      a=1
    Case #_deltrace
      Gosub _Deltrace
    Case #_addtrace
      Gosub _Addtrace
    Case #_copperlist
      discop_ad=si
      If winstatus(#_winDisCop)=0
        NewWindow{#_winDisCop}
      EndIf
      UpdateDisCop{}
    Case #_proccontrol
      If nf=0    ; (do Toggle)
        procstatus=NOT(procstatus)
      Else
        procstatus=nt
      EndIf
      Toggle #_winControl,18,procstatus
      Redraw #_winControl,18
  End Select
  If a AND winstatus(#_winVariables)
    RedrawVarWindow{}
    UpdateVarWindow{}
  EndIf
Return

._Deltrace:
  a=0
  ResetList varinfo()
  While NextItem(varinfo())
    If varinfo()\name=na$
      KillItem varinfo()
      a=-1
    EndIf
  Wend
Return

._Addtrace:
  AddLast varinfo()
  varinfo()\name=na$,si,nt,nf-1
  a=1
  If varinfo()\typ=4
    mem=varinfo()\address
    Gosub FindString
    varinfo()\address=ad
    If ad=-1 Then KillItem varinfo() : a=0
  EndIf

Return

;dowin=window to update
;flag=-1 for move backwards
.Movemem:
  If dowin=0 Then Use Window #_winMemory1 Else Use Window #_winMemory2
  wwide=(InnerWidth ASR 3)-10
  wwide/7
  jump=wwide ASL 1
  If kbshift Then jump=jump*(InnerHeight ASR 6)
_doMovemem:
  If flag=-1
    mempointer(dowin)-jump
  Else
    mempointer(dowin)+jump
  EndIf
  Gosub RedrawMem
Return

.RedrawMem:
  If winstatus(#_winMemory1) AND (dowin=0 OR dowin=-1)
    Use Window #_winMemory1
    num=0
    Gosub DrawMem
  EndIf

  If winstatus(#_winMemory2) AND (dowin=1 OR dowin=-1)
    Use Window #_winMemory2
    num=1
    Gosub DrawMem
  EndIf

  dowin=-1
Return

.DrawMem:
  ;w=(InnerWidth/8)-10
  w=(InnerWidth/TextLength_(RastPort(#_winMemory1+num),"$1",1))-10
  a$=String$(" ",w+10)
  w/7
  ad=mempointer(num)
  WTitle Hex$(ad)
  ad2=&a$+(w*5)+1
  rp=RastPort(#_winMemory1+num)
  OutTextPen rp,1
  y=iy
  For h=0 To (InnerHeight/WinFontHeight)-1
    D_HexWord ad,&a$,w
    D_CheckNMoveWord ad,ad2,w
    OutText ix,y,rp,Hex$(ad)+" "+a$
    mem(h)="$"+Hex$(Peek.l(ad))
    y+WinFontHeight
    ad+(w ASL 1)
  Next h
  RefreshWindowFrame_(!windowaddr)
Return

Statement DoCurs{xad.b,num.b}
  SHARED ix,iy,mad,mempointer(),wwide,editflag

  y=(((mad-mempointer(num))/wwide)ASL 3)+iy
  rp.l=RastPort(#_winMemory1+num)
  SetDrMd_ rp,2
  If editflag=0
    x=ix+72+(xad ASL 3)
    If (mad AND %1)         ; Odd address
      x+(((xad-1)ASR 2) ASL 3)
    Else
      x+((xad ASR 2) ASL 3)
    EndIf
  Else
    x=ix+80+(wwide*20)+(xad ASL 3)
  EndIf
  RectFill_ rp,x,y,x+7,y+7
  SetDrMd_ RastPort(#_winMemory1+num),1
End Statement

.MemEdit:
  Use Window winnum
  Activate winnum
  WTitle "Edit mode"
  Gosub meminfo
  DoCurs{0,dowin}

  FlushEvents
  flag=0
  Repeat
    ev=WaitEvent
    evw=(EventWindow=winnum)
    evq=EventQualifier
    a$=Inkey$
    If evw=0 OR ev=$80000 Then a$=" " : ev=0 : evq=0
    If ev AND evw
      Select ev
        Case 2
          Gosub meminfo
        Case 4
          Gosub meminfo
          ;InnerCls
            w.w=InnerWidth
            hi.w=InnerHeight
            ;Boxf 0,0,w,hi,0
        Case 512
          a$=" " : ev=0 : evq=0
        Case 1024
          Select EventCode
            Case $4c                     ; UP cursor
              mad-wwide : flag=-1
            Case $4d                     ; DOWN cursor
              mad+wwide : flag=-1
            Case $4F                     ; Left cursor
              xad-1 : If xad=-1 Then xad=wxad-1 : mad-wwide
              flag=-1
            Case $4E                     ; Right cursor
              xad+1: flag=-1
          End Select
          If flag Then a$=""
      End Select
    EndIf
    b$=""
    If a$<>""
      If (evq AND %1000) Then b$=a$
      If a$<>" " AND a$<>Chr$(9) Then b$=a$
    EndIf
    If editflag
      If b$<>""
        Poke.b mad+xad,Asc(a$)
        xad+1
        flag=-1
        a$=""
      EndIf
    Else
      If b$<>""
        b$=UCase$(b$)
        If (b$>="0" AND b$<="9") OR (b$>="A" AND b$<="F")
          a=Peek.b(mad+(xad ASR 1))
          b=Vallong("$"+b$)
          If (xad AND %1)
            a=(a AND $f0) OR b
          Else
            a=(a AND $0f) OR (b ASL 4)
          EndIf
          Poke.b mad+(xad ASR 1),a
          xad+1
          flag=-1
        EndIf
        a$=""
      EndIf
    EndIf
    If a$=Chr$(9)
      editflag=1-editflag
      If editflag=0
        wxad ASL 1
        xad ASL 1
      Else
        wxad=wxad ASR 1
        xad=xad ASR 1
      EndIf
      flag=1
    EndIf
    If flag
      If xad>wxad-1 Then xad=0 : mad+wwide
      If mad>=nmad Then mad=nmad : mempointer(dowin)+wwide : nmad+wwide
      If mad<mempointer(dowin) Then mempointer(dowin)-wwide : mad=mempointer(dowin) : nmad-wwide
      num=dowin
      Gosub DrawMem
      DoCurs{xad,dowin}
      flag=0
    EndIf
  Until a$=" "
  DoCurs{xad,dowin}
  Domemtitle {dowin}
  dowin=-1
  Gosub RedrawMem
Return

meminfo:
  wwide=(InnerWidth ASR 3)-10
  wwide/7
  wxad=wwide ASL 2
  wwide ASL 1

  mad.l=mempointer(dowin)
  nmad.l=mad+((InnerHeight ASR 3)*wwide)
  xad=0   ; count number of 4 bit groups from address ad
  flag=-1
  If editflag Then wxad=wxad ASR 1
Return

FindString:
  ad=Peek.l(?mybuffer)
  ad2=Peek.l(ad+52)
  ad=D_FindStringPtr(ad2,mem)
  If ad=-1
  ad=Peek.l(?mybuffer)
  ad2=Peek.l(ad+60)
  ad=D_FindStringPtr(ad2+$8000,mem) ;search in stack
  End If
Return


.SearchMemory:
  ad1=Vallong(StringText$(2,1))
  old_ad=ad1
  ad2=Vallong(StringText$(2,4))
  searchfor$=StringText$(2,7)

  nt=searchtype
  If nt=0 Then Return

  If nt<4 Then si=Vallong(searchfor$)
  If nt=4 Then si=&searchfor$
  optimize 7
  If nt=5 Then mq=Val(searchfor$) : si=Peek.l(&mq)
  If nt=6 Then mf=Val(searchfor$) : si=Peek.l(&mf)
  optimize 5
  t$="Searching memory.... <SPACE> to abort"
  Gosub wprint
  num=0
doagain:
  ad=SearchMem(nt,si,ad1,ad2)

  If ad<>0 AND ad<>1
    num+1
    ad=SearchMemFound
    b$=Peek$(?search0)+Hex$(old_ad)+Peek$(?search01)+Hex$(ad2)
    b$+Peek$(?search1)+Hex$(ad)+Peek$(?search2)+Hex$(ad-old_ad)+Peek$(?search3)+Hex$(num)+Peek$(?search4)
    reply=RTEZRequest("Search",b$,"Mem_1|Mem_2|_Again|_Exit")
    If reply<>0
      If reply=3 Then ad1=ad+1: Goto doagain
      mempointer(reply-1)=ad
      Gosub RedrawMem
    EndIf
  Else
    If ad=1 Then a$=Peek$(?exitpress) Else a$=Peek$(?notfound)
    reply=RTEZRequest("Search",a$,"_Okay")
  EndIf

  t$="" : Gosub wprint
Return

exitpress:Dc.b "Search aborted - value not found!",0
notfound: Dc.b "Value not found within given range!",0
search0: Dc.b       "Search start address      $",0
search01:Dc.b 10,   "Search end address        $",0
search1: Dc.b 10,   "Found value at address    $",0
search2: Dc.b 10,   "Offset from start address $",0
search3: Dc.b 10,   "Total occurences found    $",0
search4: Dc.b 10,10,"  Move memory window to address?",0
Even

.RedrawRegs:
. @regs
  If winstatus(#_winRegisters)
    Use Window #_winRegisters
    WindowFont 0
    rp=RastPort(#_winRegisters)
    ad=Peek.l(?mybuffer)
    If ad
      y=iy+1
      For h=0 To 7
    ;data regs
        dreg=Peek.l(ad)

        OutText 3*8+4+ix,y,rp,Hex$(dreg)
        D_CheckNMoveA ad,&regb$
        OutText 12*8+4+ix,y,rp,regb$
    ;address regs
        areg=Peek.l(ad+32)
        OutText 21*8+4+ix,y,rp,Hex$(areg)
        If areg >#lowestaddr
          CNIF #longs=1
          CELSE
          D_HexWord areg,&rega$,6
          CEND
           D_CheckNMoveA areg,&rega$+32,3
        OutText 30*8+4+ix,y,rp,rega$
        End If
        ad+4
        y+8
      Next h
;      MOVE.l #-200,fpreg
;      For i=0 To 4
;      MOVE.l regpos,a0
;      ADD.l fpreg,a0
;      ADD.l #12,fpreg
;      Dc.l $f2284800:Dc.w 0;fmove.x 0(a0),fp0
;      fmove.s fp0,d0
;      JSR fpuffp
;      OutText i*120+4,84,rp,"F"+Str$(i)+"="+Str$(ffp)
;      Next
      mysr=Peek.w(ad+32+4)
      If winstatus(#_winRegisters)OutText 3*8+4+ix,y,rp,Hexw$(mysr)
      D_GetSR &sr$,mysr
      If winstatus(#_winRegisters)OutText 12*8+4+ix,y,rp,sr$

      areg=Peek.l(ad+32)                 ; Get program counter
      If winstatus(#_winRegisters)OutText 21*8+4+ix,y,rp,Hex$(areg-2)
    EndIf
  WindowFont 1
  EndIf
  fpuneedupdate=6
Return

InitRegsWin:
  If winstatus(#_winRegisters)

    WindowFont 0
    rp=RastPort(#_winRegisters)
    OutTextPen rp,1
    For h=0 To 7
      OutText 4+ix,iy+1+(h ASL 3),rp,"d"+Str$(h)+"=--------       a"+Str$(h)+"=--------"
    Next h
    OutText 4+ix,iy+1+64,rp,"sr=----    -----  BPC="
    WindowFont 1
  EndIf
Return

goterr:
  ShowScreen 0
  Activate 0
  MOVE.w  #0,proccount
  If winstatus(#_winArray) Then RedrawArray{0}
Return

;Open an object trace window
;address.l=addr
;is_bb.b=0 or -1
.NewTypeWindow:
  If AddItem(objwins())=0
    reply=RTEZRequest(scrtitle$,"No more object windows!","_Okay")
    Return
  EndIf

  ; Get a spare window
  num=#_winObject0
  While Peek.l(Addr Window(num))<>0
    num+1
  Wend

  objwins()\winnum=num
  objwins()\objadr=address
  objwins()\objbaseadr=0
  objwins()\is_bbobject=is_bb

  ; A few variables we're gonna use
  ox=0 : oy=WinFontHeight+3 : ow=320
  typelength=7
  num=0
  winheight=23+WinFontHeight

  If is_bb
    wininfo(objwins()\winnum)\helplink=?help_objects
    Gosub ObjectWin
  Else
    wininfo(objwins()\winnum)\helplink=?help_struct
    Gosub StructWin
  EndIf
  If reply=0
    KillItem objwins()
    Return
  EndIf

  If num<3 Then winheight+(3-num)*8

  objwins()\numitems=num
  objwins()\t=typetitle$
  memadr=AllocMem((num ASL 2)+4,65536)
  If memadr=0
    KillItem objwins()
    Return
  EndIf

  typewidth=ix+(typelength ASL 3)+8+16

  PropGadget objwins()\winnum,-13,WinFontHeight+5,#VPROP_AFLAGS,#OBJ_SGAD,10,-17-WinFontHeight-22,#VPROP_PFLAGS,3
  SetPropInfo objwins()\winnum,#OBJ_SGAD,1,1
  ArrowGadget objwins()\winnum,#OBJ_UGAD,#UPIMAGE,-17,-20-11,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
  ArrowGadget objwins()\winnum,#OBJ_DGAD,#DOWNIMAGE,-17,-20,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2

  SizeLimits typewidth+22,winheight,640,winheight
  Window objwins()\winnum,ox,oy,ow,winheight,$103f|$200000,"Newtype: "+typetitle$,1,2,objwins()\winnum
  GTSetMenu 0
  WindowFont 0
  winstatus(objwins()\winnum)=-1

  Wline typewidth-5,iy,typewidth-5,iy+InnerHeight-1,1

  objwins()\tracenum=0
  objwins()\typewidth=typewidth
  objwins()\typepointer=-1,memadr

  rp=RastPort(objwins()\winnum)
  OutTextPen rp,1
  OutText ix+2,iy+1,rp,"Address"
  oy=9+iy
  If is_bb
    Gosub ObjectWinD
  Else
    Gosub StructWinD
  EndIf
Return


printbubble
If winbubble=0 Then Return
Use Window #bubble
 WindowFont 1
 xs=WindowWidth:ys=WinFontHeight*3+4

   WCls
   WBox 0,0,xs-1,ys-1,3
   Wline    0,   0,xs-1,   0,1
   Wline xs-1,   0,xs-1,ys-1,1
   Wline xs-1,ys-1,   0,ys-1,1
   Wline    0,ys-1,   0,   0,1
   WJam 0:WColour 2
   WLocate 1,1:Print part$:WLocate 1,WinFontHeight+1:Print evalstr$:
   WLocate 1,WinFontHeight*2+2:Print "01234567890123456789012345678901234567890 String Lineal"
   WColour 1:WJam 1
Return


.NewType_Rout:
ObjectWin:
  objwins()\type_sizeof=Peek.w(address)
  address+2

  typetitle$=Peek$(address)
  address+Len(typetitle$)+1
  address2=address
  y2=sh-oy
  If y2>maxheight Then y2=maxheight
  Repeat
    a$=Peek$(address)
    address+Len(a$)+3
    If a$
      num+1
      If (Len(a$))>typelength Then typelength=Len(a$)
      winheight+8
      If (winheight+8)>y2 Then a$=""
    EndIf
  Until a$=""
  reply=-1
Return

ObjectWinD:
  address=address2
  For h=1 To num
    a$=Peek$(address)
    address+Len(a$)+1
    typ=Peek.b(address)
    skp.b=Peek.b(address+1)
    If skp=-1
      If typ<3 Then skp=typ Else skp=4
    EndIf
    OutText ix+2,oy,rp,LSet$(a$,typelength)+"."+Mid$(objtype$,typ,1)
    oy+8
    Poke.w memadr,typ
    Poke.w memadr+2,skp
    memadr+4
    address+2
  Next h

  CNIF #test=0
    a$="poke.w "+Str$(&objwins()\maxobject)+",maximum "+typetitle$
    a$+":Poke.l "+Str$(&objwins()\objbaseadr)+",Addr "+typetitle$+"(0)"
    d_exec{a$}
    execrequest=#_newtypewindow
    objectbusy=-1
    PushItem objwins()
  CELSE
    typepointer=Addr Shape(0)
    RefreshTypeWindow{}
  CEND
Return

StructWin:
  suc = OpenFile(0,dos_AddPart{my_path$,"structure.lookup"})
  fil$=""
  If suc=0
    reply=RTEZRequest(scrtitle$,"Couldn't locate structure.lookup file.","_Abort")
    reply=0
    Return
  EndIf
  t$=RTEZGetString(scrtitle$,"Enter structure name:",80,laststructure$)
  If t$="" Then reply=0 : Return
  laststructure$=t$
  t$=LCase$(t$)
  a$="" : b$=""
  filepos.l=0
  FileInput 0
  flag=0
  While b$<>t$ AND NOT(Eof(0))
    a$=Edit$(256)
    If Left$(a$,1)="!"
      fil$=Mid$(a$,2)
    Else
      b$=LCase$(Mid$(a$,10))
    EndIf
  Wend
  filepos=Vallong("$"+Left$(a$,8))
  If b$<>t$
    reply=RTEZRequest(scrtitle$,"Type not found!","_Okay")
    CloseFile 0
    reply=0
    WindowInput 0
    Return
  EndIf
  CloseFile 0
  suc=OpenFile(0,fil$)
  If suc=0
    reply=RTEZRequest(scrtitle$,"File not found!","_Okay")
    CloseFile 0
    reply=0
    WindowInput 0
    Return
  EndIf
  FileInput 0
  FileSeek 0,filepos
  a$=Edit$(256)
  typetitle$=Left$(a$,Len(a$)-1)
  a$=Edit$(256)
  objwins()\type_sizeof=Val(Mid$(a$,8,6))
  a$="!"

  y2=sh-oy
  If y2>maxheight Then y2=maxheight

  While a$<>""
    a$=Edit$(256)
    If a$<>"" AND Right$(a$,1)<>":"
      a$=Mid$(a$,22)
      num+1
      If (Len(a$))>typelength Then typelength=Len(a$)
      winheight+8
      If (winheight+8)>y2 Then a$=""
    Else
      a$=""
    EndIf
  Wend
  reply=-1
Return

StructWinD:
  FileSeek 0,filepos
  FileInput 0

  flag=0
  a$=Edit$(256)
  a$=Edit$(256)
  prev.w=0

  For h=1 To num
    a$=Edit$(256)
    typ=Val(Mid$(a$,3,5))
    skp=typ-prev
    If h>1 Then Poke.w memadr-2,skp

    prev=typ

    Select Val(Mid$(a$,17,3))
      Case 1
        typ=1
      Case 2
        typ=2
      Case 4
        typ=3
      Default
        typ=0
    End Select

    a$=Mid$(a$,22)
    b$=LCase$(a$)

    If Instr(b$,"name") AND skp=4
      If flag=0
        reply=RTEZRequest(scrtitle$,"Keyword 'name' found."+Chr$(10)+"Point "+a$+" to string?","_Yes|_All|_No")
        If reply<>0 Then typ=4
        If reply=2 Then flag=-1
      Else
        typ=4
      EndIf
    EndIf
    a$=LSet$(a$,typelength)+"."
    If typ>0
      a$+Mid$(objtype$,typ,1)
    Else
      a$+"?"
      typ=1
    EndIf
    OutText ix+2,oy,rp,a$
    oy+8
    Poke.w memadr,typ
    memadr+4
  Next h

  WindowInput 0
  CloseFile 0

  objwins()\typepointer=0
  RefreshTypeWindow{}
Return

.Savewindows:
  ad2=AllocMem_(configsize,$10001)
  ad=ad2
  Poke.b ad,#dbug_version
  Poke.b ad+1,#dbug_revision
  Poke.w ad+2,scrmode
  Poke.l ad+4,ModeID
  Poke.w ad+8,swidth
  Poke.w ad+10,sheight
  Poke.b ad+12,tokenise
  Poke.b ad+13,GTMenuChecked(0,0,6,6)
  Poke.w ad+14,maxheight
  Poke.w ad+16,#save_numwindows
  ad+18
  For h=0 To #save_numwindows-1
    Poke.w ad,winstatus(h) : ad+2
    If Peek.l(Addr Window(h))
      Use Window h
      Poke.w ad,WindowX : ad+2
      Poke.w ad,WindowY : ad+2
      Poke.w ad,WindowWidth : ad+2
      Poke.w ad,WindowHeight : ad+2
    Else
      Poke.w ad,wininfo(h)\x : ad+2
      Poke.w ad,wininfo(h)\y : ad+2
      Poke.w ad,wininfo(h)\w : ad+2
      Poke.w ad,wininfo(h)\h : ad+2
    EndIf
  Next h

  Poke.b ad,procstatus    : ad+1
  Poke.b ad,blitzcontrol  : ad+1
  Poke.b ad,gosubstatus   : ad+1
  Poke.b ad,GTMenuChecked(0,0,6,7)  : ad+1
  Poke.b ad,syntax_        : ad+1
. @prefssave
  Poke$ ad,disasmlock$    :ad+128
  Poke.w ad,#wizardwindows:ad+2
  For h=23 To #wizardwindows-1
    Poke.w ad,winstatus(h) : ad+2
    If Peek.l(Addr Window(h))
      Use Window h
      Poke.w ad,WindowX : ad+2
      Poke.w ad,WindowY : ad+2
      Poke.w ad,WindowWidth : ad+2
      Poke.w ad,WindowHeight : ad+2
    Else
      Poke.w ad,wininfo(h)\x : ad+2
      Poke.w ad,wininfo(h)\y : ad+2
      Poke.w ad,wininfo(h)\w : ad+2
      Poke.w ad,wininfo(h)\h : ad+2
    EndIf
  Next h
                                                                                                                              


  SaveIt{"ENVARC:"}
  SaveIt{"ENV:"}
  FreeMem_ ad2,256

Return

.MenuHelp:
  ec.l=EventCode
  If ec<>-1
    hitmenu.w=-1
    hititem.w=-1
    hitsubitem.w=-1

    If (ec AND 31)<>31 Then hitmenu=(ec AND 31)

    n=(ec ASR 5) AND 63
    If n<>63 Then hititem=n

    n=((ec ASR 11) AND 31)
    If n<>31 Then hitsubitem=n

    ad.l=GTGetUserData(0,hitmenu,hititem,hitsubitem)
    If ad<>0
      a$=Peek$(ad)
      DoHelp{a$}
    EndIf
  EndIf
Return

variabletypes:
  Dc.b "Byte  ",0
  Dc.b "Word  ",0
  Dc.b "Long  ",0
  Dc.b "String",0
  Dc.b "Quick ",0
  Dc.b "Float ",0

help_sr:
  Dc.b "Status register flags:",10
  Dc.b "X: Extension",10
  Dc.b "N: Negative ",10
  Dc.b "Z: Zero     ",10
  Dc.b "O: Overflow ",10
  Dc.b "C: Carry    ",0

help_debug:
  Dc.b "This program handles runtime error",10,"debugging for programs compiled",10
  Dc.b "and run inside AmiBasic3.",10," ",10,"The original version was written by",10
  Dc.b "Mark Sibly of ACID software.",10," ",10,"This version has been written by",10
  Dc.b "Stephen McNamara of Red When Excited.",10
  Dc.b "Updated in 2002 by Bernd Roesch",10
  Dc.b "Additional updates in 2007 by Sven Drge",10
  Dc.b 0

.help_keyboard:
  Dc.b "Keyboard Shortcuts",10,10
  Dc.b "BREAK - CTRL ALT C         STEP  - S",10
  Dc.b "STEPOVER   - D Call dbl_flip {}    F",10
  Dc.b "SKIP       - I             TRACE - T",10
  Dc.b "RUN        - R             <<    - ,",10
  Dc.b ">>         - .             EXEC  - X",10
  Dc.b "EVAL       - E             QUIT- ESc",10
  Dc.b "   TAB - Cycle active window   ",10
  Dc.b 10
  Dc.b "Whilst in some windows,",10
  Dc.b "'m' = Enter startadress Shift+m last eval address" ,10
  Dc.b "'l' = Lock Window to Register",10
  Dc.b "'SPACE' in memwin allow change value(SAPCE for exit)",10
  Dc.b "ALT+LMB Jump into",10
  Dc.b "ALT+MMB Jump to last position before ALT+LMB",10
  Dc.b "CTRL 'm' in disasmwin show line in ped",10
  Dc.b "'b' = show next breakpoint",0


setregvalue:
  Dc.b "Enter new register value:",10
  Dc.b "    e.g. d0=12345678     ",10
  Dc.b "         d7=$0           ",10
  Dc.b "         a0=",34,"bLtZ",34,"       ",0

closevisitors:

  Even

;Array Aof type definitions
MyTypes:
  Dc.l BitmapType
  Dc.l BlitzfontType
  Dc.l BufferType
  Dc.l Coplisttype
  Dc.l FileType
  Dc.l GTListType
  Dc.l GTMenuListType
  Dc.l IntuifontType
  Dc.l MapObjType
  Dc.l ModuleType
  Dc.l PaletteType
  Dc.l QueueType
  Dc.l ShapeType
  Dc.l SliceType
  Dc.l SoundType
  Dc.l SpriteType
  Dc.l StencilType
  Dc.l TapeType
  Dc.l WindowType
  Dc.l 0

;General form:
;               Sizeof.objtype
;               Object name$
;               [item$
;                item type (#_byte to #_float)
;                item type size (byte size or -1 to take size from type)
;               ]
;All strings should be null terminated.
PaletteType:
Dc.w 128
Dc.b "Palette",0
Dc.b "*_pdata",0,#_long,-1
Dc.b "numcols",0,#_word,-1
Dc.b "[locol",0,#_word,-1
Dc.b "hicol",0,#_word,-1
Dc.b "speed",0,#_word,-1
Dc.b "var]",0,#_word,-1
Dc.b 0
Even
BitmapType:
Dc.w 64
Dc.b "Bitmap",0
Dc.b "_ebwidth",0,#_word,-1
Dc.b "_height",0,#_word,-1
Dc.b "_depth",0,#_word,-1
Dc.b "_pad",0,#_word,-1
Dc.b "_plane0",0,#_long,-1
Dc.b "_plane1",0,#_long,-1
Dc.b "_plane2",0,#_long,-1
Dc.b "_plane3",0,#_long,-1
Dc.b "_plane4",0,#_long,-1
Dc.b "_plane5",0,#_long,-1
Dc.b "_plane6",0,#_long,-1
Dc.b "_plane7",0,#_long,-1
Dc.b "_xcurs",0,#_word,-1
Dc.b "_ycurs",0,#_word,-1
Dc.b "_pad[8]",0,#_byte,8
Dc.b "_flags",0,#_word,-1
Dc.b "_bitplanemod",0,#_word,-1
Dc.b "_xclip",0,#_word,-1
Dc.b "_yclip",0,#_word,-1
Dc.b "_cclip",0,#_word,-1
Dc.b "_isreal",0,#_word,-1
Dc.b 0

Even
ModuleType:
Dc.w 8
Dc.b "Module",0
Dc.b "_mt_data",0,#_long,-1
Dc.b "_length",0,#_long,-1
Dc.b 0

Even
BlitzfontType:
Dc.w 4
Dc.b "Blitzfont",0
Dc.b "_font",0,#_long,-1
Dc.b 0

Even
ShapeType:
Dc.w 32
Dc.b "Shape",0
Dc.b "_pixelwidth",0,#_word,-1
Dc.b "_pixelheight",0,#_word,-1
Dc.b "_depth",0,#_word,-1
Dc.b "_ebwidth",0,#_word,-1
Dc.b "_bltsize",0,#_word,-1
Dc.b "_xhandle",0,#_word,-1
Dc.b "_yhandle",0,2,-1
Dc.b "_data",0,#_long,-1
Dc.b "_cookie",0,#_long,-1
Dc.b "_onebpmem",0,#_word,-1
Dc.b "_onebpmemx",0,#_word,-1
Dc.b "_allbpmem",0,#_word,-1
Dc.b "_allbpmemx",0,#_word,-1
Dc.b "_pad[2]",0,#_byte,2
Dc.b 0

Even
TapeType:
Dc.w 16
Dc.b "Tape",0
Dc.b "_ielist",0,#_long,-1
Dc.b "_timevalhi",0,#_long,-1
Dc.b "_timevallo",0,#_long,-1
Dc.b "_pad[4]",0,#_byte,4
Dc.b 0

Even
StencilType:
Dc.w 8
Dc.b "Stencil",0
Dc.b "_ebwidth",0,#_word,-1
Dc.b "_height",0,#_word,-1
Dc.b "_data",0,#_long,-1
Dc.b 0

Even
QueueType:
Dc.w 16
Dc.b "Queue",0
Dc.b "*currentitem",0,#_long,-1
Dc.b "*nextitem",0,#_long,-1
Dc.b "_length",0,#_long,-1
Dc.b "_pad[4]",0,#_byte,4
Dc.b 0

Even
FileType:
Dc.w 32
Dc.b "File",0
Dc.b "_handle",0,#_long,-1
Dc.b "_reclen",0,#_long,-1
Dc.b "_pad[4]",0,#_byte,4
Dc.b "*fields",0,#_long,-1
Dc.b "_buffer",0,#_long,-1
Dc.b "_flags",0,#_word,-1
Dc.b "_valid",0,#_word,-1
Dc.b "_seekoff",0,#_word,-1
Dc.b "_seek",0,#_long,-1
Dc.b 0

Even
BufferType:
Dc.w 16
Dc.b "Buffer",0
Dc.b "_current",0,#_long,-1
Dc.b "_first",0,#_long,-1
Dc.b "_length",0,#_long,-1
Dc.b "_pad[4]",0,#_byte,4
Dc.b 0

Even
SliceType:
Dc.w 64
Dc.b "Slice",0
Dc.b "_ypos",0,#_word,-1
Dc.b "_flags",0,#_word,-1
Dc.b "_numbitplanes",0,#_word,-1
Dc.b "_numsprites",0,#_word,-1
Dc.b "_numcolours",0,#_word,-1
Dc.b "_bitplanes",0,#_long,-1
Dc.b "_sprites",0,#_long,-1
Dc.b "_colours",0,#_long,-1
Dc.b "_BPLCON1",0,#_long,-1
Dc.b "_BPLCON2",0,#_long,-1
Dc.b "_pad[2]",0,#_byte,2
Dc.b 0

Even
SoundType:
Dc.w 16
Dc.b "Sound",0
Dc.b "_data",0,#_long,-1
Dc.b "_period",0,#_word,-1
Dc.b "_length",0,#_word,-1
Dc.b "_loop",0,#_long,-1
Dc.b "_looplength",0,#_word,-1
Dc.b "_pad[2]",0,#_byte,2
Dc.b 0

Even
SpriteType:
Dc.w 16
Dc.b "Sprite",0
Dc.b "_data",0,#_long,-1
Dc.b "_height",0,#_word,-1
Dc.b "_channels",0,#_word,-1
Dc.b "_flags",0,#_word,-1
Dc.b "_nextoff",0,#_word,-1
Dc.b "_xhandle",0,#_word,-1
Dc.b "_yhandle",0,#_word,-1
Dc.b 0

Even
WindowType:
Dc.w 32
Dc.b "Window",0
Dc.b "_window",0,#_long,-1
Dc.b "_cursx",0,#_word,-1
Dc.b "_cursy",0,#_word,-1
Dc.b "_pointer",0,#_long,-1
Dc.b "_length",0,#_long,-1
Dc.b 0

Even
IntuifontType:
Dc.w 16
Dc.b "Intuifont",0
Dc.b "_fontname",0,#_string,-1
Dc.b "_ysize",0,#_word,-1
Dc.b "_pad",0,#_word,-1
Dc.b "_font",0,#_long,-1
Dc.b "_pad2[4]",0,#_byte,4
Dc.b 0

Even
Coplisttype:
Dc.w 128
Dc.b "Coplist",0
Dc.b "size",0,#_long,-1
Dc.b "coppos",0,#_long,-1
Dc.b "colors",0,#_long,-1
Dc.b "sprites",0,#_long,-1
Dc.b "bpcons",0,#_long,-1
Dc.b "bplanes",0,#_long,-1
Dc.b "dot",0,#_long,-1
Dc.b "customs",0,#_long,-1
Dc.b "dob",0,#_long,-1
Dc.b "bot",0,#_word,-1
Dc.b "numbp",0,#_word,-1
Dc.b "colpokes",0,#_word,-1
Dc.b "fetchwid",0,#_word,-1
Dc.b "xand",0,#_word,-1
Dc.b "xshift",0,#_word,-1
Dc.b "ypos",0,#_word,-1
Dc.b "height",0,#_word,-1
Dc.b "res",0,#_word,-1
Dc.b "numsprites",0,#_word,-1
Dc.b "numcols",0,#_word,-1
Dc.b "numcustoms",0,#_word,-1
Dc.b "cpline",0,#_word,-1
Dc.b "x0",0,#_quick,-1
Dc.b "x1",0,#_quick,-1
Dc.b "bplcon3",0,#_word,-1
Dc.b "aga",0,#_word,-1
Dc.b 0

GTListType:
Dc.w 16
Dc.b "GTList",0
Dc.b "gadptr",0,#_long,-1
Dc.b "visualinfo",0,#_long,-1
Dc.b "current",0,#_long,-1
Dc.b "windowptr",0,#_long,-1
Dc.b 0

MapObjType:
Dc.w 32
Dc.b "MapObject",0
Dc.b "width",0,#_word,-1
Dc.b "height",0,#_word,-1
Dc.b "bwidth",0,#_word,-1
Dc.b "bheight",0,#_word,-1
Dc.b "datasize",0,#_byte,-1
Dc.b "mapnull",0,#_byte,-1
Dc.b "*mapdata",0,#_long,-1
Dc.b "viewx",0,#_word,-1
Dc.b "viewy",0,#_word,-1
Dc.b "*mapname",0,#_string,-1
Dc.b 0

GTMenuListType:
Dc.w 16
Dc.b "GTMenuList",0
Dc.b "*Menulist",0,#_long,-1
Dc.b "*Privatelist",0,#_long,-1
Dc.b "numitems",0,#_word,-1
Dc.b 0

;Window status,position and size.
;Format: Status.w (0=closed)
;        x position
;        y position
;        x size
;        y size

Even
. @prefsstruct
initstate:
  Dc.b #dbug_version            ; Program version number
  Dc.b #dbug_revision           ; Program revision number
  Dc.w #SCR_WB                  ; actual screen type
  Dc.l $8000                    ; Screen mode ID
  Dc.w 640                      ; Screen width
  Dc.w 256                      ; Screen height
  Dc.b 0                        ; Tokenise
  Dc.b 0                        ; public screen
  Dc.w 256                      ; max window height
  Dc.w #save_numwindows         ; number of window definitions
  Dc.w -1,0,124,432,256-124     ; Source window pos,size
  Dc.w -1,0,11,640,26           ; Control window pos,size
  Dc.w -1,0,37,640,87           ; Registers
  Dc.w 0,0,0,0,0                ; Backdrop
  Dc.w -1,432,124,208,256-124   ; Mem1
  Dc.w 0,432,124,208,256-124    ; Mem2
  Dc.w 0,0,11,420,100           ; Search window
  Dc.w 0,0,11,320,128           ; Variable window
  Dc.w 0,0,11,320,128           ; 680x0 Disassembly window
  Dc.w 0,0,11,320,128           ; Copper Disassembly window
  Dc.w 0,0,11,320,128           ; Custom chip registers
  Dc.w 0,0,11,320,128           ; Array window
  Dc.w 0,0,11,160,200           ; Label List window
  Dc.b 0                        ; Status of ProcedureStep
  Dc.b 0                        ; Status of Blitzcontrol
  Dc.b 0                        ; Status of GosubStep
  Dc.b 0                        ; default Public screen mode
  Dc.b 0                        ; show syntax mode
  Dcb.b 31,0
disasmlockstr: Dc.b "pc-2",0:Ds.b 128-5
  Dc.w 0,0,11,420,100           ; FPU Reg Window
endof_init:
  Even

sizeofsave: Dc.w endof_init-initstate

help_menus:         Dc.b "MENUS",0
help_about:         Dc.b "ABOUT",0
help_cntrlwin:      Dc.b "WIN_PROGCNTRL",0
help_source:        Dc.b "WIN_SOURCE",0
help_configuration: Dc.b "NODEconfiguration",0
help_screenmode:    Dc.b "NODEscrmode",0
help_reg:           Dc.b "WIN_REGS",0
help_mem:           Dc.b "WIN_MEM",0
help_var:           Dc.b "WIN_VARS",0
help_asm:           Dc.b "WIN_DISASM",0
help_cop:           Dc.b "WIN_COPPER",0
help_gs:            Dc.b "NODEgosubstep",0
help_ps:            Dc.b "NODEproccontrol",0
help_bc:            Dc.b "NODEblitzcontrol",0
help_search:        Dc.b "WIN_SEARCH",0
help_array:         Dc.b "WIN_ARRAY",0
help_struct:        Dc.b "WIN_STRUCTURES",0
help_chips:         Dc.b "WIN_CUSTOMCHIPS",0
help_labels:        Dc.b "WIN_LABELLIST",0
help_objects:       Dc.b "WIN_OBJECTS",0
help_autoeval:      Dc.b "NODEautoeval",0
help_breakpoints:   Dc.b "NODEbreakpoints",0
help_fpu:           Dc.b "WIN_FPU",0
help_asmstep:       Dc.b "WIN_ASMSTEP",0
help_watch0:        Dc.b "WIN_WATCH0",0
Even
wzdat: IncBin "reddebug.wizard"
Even

fpuffp
  fpu = PutD0
  ffp = SPFieee_(ffp)   ;for mathtranspointer
  GetD0 fpu
  JSR -$6c(a6)
  MOVE.l d0,ffp@(a5)
Return

setfpu
  fp$(temp)=RTEZGetString("Insert FPU Value","Insert FPU Value",80,fp$(temp))
  optimize 7
  ffp=Val(fp$(temp))
  optimize 5
  ffp2.f=SPTieee_(ffp2)   ;for mathtranspointer
  MOVE.l ffp@(a5),d0
  JSR -102(a6)
  fmove.s d0,fp0
  MOVE.l regpos,a0
  ADD.l fpuoffset,a0
  GetD0 temp
  MULS #12,d0
  ADD.w d0,a0
  Dc.l $f2106800    ;fmove.x fp0,(a0)
  JSR RedrawRegs
RTS


.getterm ;in: *ptr ret:part$
  inbrack = 0
  poin$ = ""
  temp = Peek.b(*ptr+xpos)
  If temp = @"\"
;If Peek.l(i) AND $80000000
;  i3.l=(Peek.l(i) AND $7fffffff)+startcode
;Else
;  i3=Peek.l(i)
;EndIf
;Repeat
;  il3.l=Peek.l(i3+4):
;  If Peek.l(il3)=i3
;     i3=il3
;  Else
;  i3=0
;  End If
;If i3
;     p$=Peek$ (i3+9)
;     If Instr(p$,Mki$ ($80ca))
;     InitArgParse p$
;     ret$=NextArg$
;     path$=NextArgChar$(@" ","","")
;     i3=0
;     End If
;End If
;Until i3=0
    typepath$ = RTEZGetString(scrtitle$,"Insert a path for newtype begin with \",128,path$)
  End If
  If temp = @"*"
    poin$ = "*"
  End If
  If temp = @"#"
    poin$="#"
  End If

  wloop:
    temp = Peek.b(*ptr+xpos)

    xpos-1
    ;If temp=$2e OR temp=36 OR temp=45 Goto wloop
    If temp=@"." OR temp=@"$" OR temp=@"-" Then  Goto wloop
    If temp=@"+" Then Goto wout
    If temp=@"\"
       If Peek.l(i) AND $80000000
         i3.l=(Peek.l(i) AND $7fffffff)+startcode
       Else
         i3=Peek.l(i)
       EndIf
       Repeat
         il3.l=Peek.l(i3+4):
         If Peek.l(il3)=i3
            i3=il3
         Else
         i3=0
         End If
       If i3
            p$=Peek$ (i3+9)
            If Instr(p$,Mki$ ($80ca))
            InitArgParse p$
            ret$=NextArg$
            If typepath$=""
              path$=NextArgChar$(@" ","","")
            Else
            path$=typepath$
            End If
            i3=0
            End If
       End If
       Until i3=0
     End If
     If temp=@"{" Then xpos+1:Goto wout
     If temp>=$30 AND temp <=$39 Then Goto wloop
     If temp<$40 Then xpos+1:Goto wout
     If xpos<0 Then Goto wout
     Goto wloop
wout:xpos+1:schar=xpos
     temp=Peek.b (*ptr+xpos)
     If temp=@"$" OR temp=@"-" Then xpos+1:If Peek.b(*ptr+xpos)=@"$" Then xpos+1
wloop2: temp=Peek.b(*ptr+xpos)
     If temp=@"(" Then inbrack+1
     If temp=@")" AND inbrack=0 Then Goto wout2
     If temp=@"-" AND inbrack<>0 Then Goto weit1
     If temp=@" " AND inbrack<>0 Then Goto weit1
     If temp=$22  AND inbrack<>0 Then Goto weit1
     If temp=@")" Then inbrack-1
     If temp=@"}" Then Goto wout2
     If inbrack<>0 AND temp=@"," Then Goto weit1
     If temp=@"." OR temp=@"(" OR temp=@")" OR temp=@"$" OR temp =@"*" OR temp=@"#" Then Goto weit1
     If temp>=$30 AND temp <=$39 Goto weit1
     If temp<$40 Then Goto wout2
  weit1: xpos+1
  Goto wloop2
  wout2
  part$=Peeks$(*ptr+schar,xpos-schar)
RTS

storefpuregs
  MOVE.l regpos,a0
  ADD.l fpuoffset,a0
  MOVEQ #7,d0
  LEA fpustore,a1
 'l1:
    MOVE.l (a0)+,(a1)+
    MOVE.l (a0)+,(a1)+
    MOVE.l (a0)+,(a1)+
  DBF d0,'l1
RTS

restorefpuregs
  MOVE.l regpos,a0
  ADD.l fpuoffset,a0
  MOVEQ #7,d0
  LEA fpustore,a1
 'l1:
    MOVE.l (a1)+,(a0)+
    MOVE.l (a1)+,(a0)+
    MOVE.l (a1)+,(a0)+
  DBF d0,'l1
RTS

.@addhistory
addhistory               ;d0 linenum
  MOVEM.l a0/d1,-(a7)
  LEA history,a0
  MOVEQ #0,d1
  MOVE.w historypointer,d1
  GetD0 disasm_ad
  MOVE.l d0,0(a0,d1)
  ADDQ.w #4,d1
  CMP.w  #maxhistory*4,d1
  BLE 'nowrap
  MOVEQ #0,d1
 'nowrap
  MOVE.w d1,historypointer
  MOVEM.l (a7)+,a0/d1
RTS

addmemhistory               ;d0 linenum
  MOVEM.l a0/d1,-(a7)
  LEA memhistory,a0
  GetD0 mempointer(1)
  MOVEQ #0,d1
  MOVE.w memhistorypointer,d1
  MOVE.l d0,0(a0,d1)
  ADDQ.w #4,d1
  CMP.w  #maxhistory*4,d1
  BLE 'nowrap
  MOVEQ #0,d1
 'nowrap
  MOVE.w d1,memhistorypointer
  MOVEM.l (a7)+,a0/d1
RTS

memhistoryup
.jump_memhistoryup
  MOVE.l a1,-(a7)
  LEA memhistory,a0
  MOVE.w memhistorypointer,d1
  SUBQ #4,d1
  BPL 'l10
  MOVEQ #maxhistory*4,d1
 'l10
  MOVE.w d1,memhistorypointer
  MOVE.l 0(a0,d1.w),d0
  PutReg d0,mempointer(1)
  Gosub RedrawMem
  MOVE.l (a7)+,a1
RTS

memhistorydown
.jump_memhistorydown
  MOVE.l a1,-(a7)
  LEA memhistory,a0
  MOVE.w memhistorypointer,d1
  ADDQ #4,d1
  CMP.w #maxhistory*4,d1
  BLE 'l10
  MOVEQ #0,d1
 'l10
  MOVE.w d1,memhistorypointer
  MOVE.l 0(a0,d1.w),d0
  PutReg d0,mempointer(1)

  Gosub RedrawMem
  MOVE.l (a7)+,a1
RTS

historyup
.jump_historyup
  MOVE.l a1,-(a7)
  LEA history,a0
  MOVE.w historypointer,d1
  SUBQ #4,d1
  BPL 'l10
  MOVEQ #maxhistory*4,d1
 'l10
  MOVE.w d1,historypointer
  MOVE.l 0(a0,d1.w),d0
  disasm_ad = PutD0
  UpdateDisAsm{}
  MOVE.l (a7)+,a1
RTS

historydown
.jump_historydown
  MOVE.l a1,-(a7)
  LEA history,a0
  MOVE.w historypointer,d1
  ADDQ #4,d1
  CMP.w #maxhistory*4,d1
  BLE 'l10
  MOVEQ #0,d1
 'l10
  MOVE.w d1,historypointer
  MOVE.l 0(a0,d1.w),d0
  disasm_ad=PutD0
  UpdateDisAsm{}
  MOVE.l (a7)+,a1
RTS


memhistorypointer:  Dc.l 0
historypointer:     Dc.l 0
regpos:             Dc.l 0
fpreg:              Dc.l 0
fpuoffset:          Dc.l 0
currlinestart:      Dc.l 0
topazname           Dc.b "topaz.font",0
Even
BSS
history:            Ds.l #maxhistory+2
memhistory:         Ds.l #maxhistory+2
fpustore:           Ds.l 3*9
programstart:       Ds.l 1
programsize:        Ds.l 1
newdebug:           Dc.w 1
trap15addr:         Ds.l 1

direktbuffer:       Ds.b 4096
