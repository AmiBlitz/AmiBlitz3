; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "c:"
; ExeFile         = "https"
; CreateIcon      = 1
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 0
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 151
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 7
; CursorColumn    = 9
; LabelSearch     = "geth"
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 20
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 20
; Max ChunkyBuffer= 2
; /XTRA
; bsd.include.bb2 automatically generated by FD2Include (Thilo Koehler)

CNIF #__include=0
optimize 5
Syntax 2
CEND

XINCLUDE "error.include.ab3"

; Library offsets:
#_LVO_SOCKETBASE_socket              = -30
#_LVO_SOCKETBASE_bind                = -36
#_LVO_SOCKETBASE_listen              = -42
#_LVO_SOCKETBASE_accept              = -48
#_LVO_SOCKETBASE_connect             = -54
#_LVO_SOCKETBASE_sendto              = -60
#_LVO_SOCKETBASE_send                = -66
#_LVO_SOCKETBASE_recvfrom            = -72
#_LVO_SOCKETBASE_recv                = -78
#_LVO_SOCKETBASE_shutdown            = -84
#_LVO_SOCKETBASE_setsockopt          = -90
#_LVO_SOCKETBASE_getsockopt          = -96
#_LVO_SOCKETBASE_getsockname         = -102
#_LVO_SOCKETBASE_getpeername         = -108
#_LVO_SOCKETBASE_IoctlSocket         = -114
#_LVO_SOCKETBASE_CloseSocket         = -120
#_LVO_SOCKETBASE_WaitSelect          = -126
#_LVO_SOCKETBASE_SetSocketSignals    = -132
#_LVO_SOCKETBASE_getdtablesize       = -138
#_LVO_SOCKETBASE_ObtainSocket        = -144
#_LVO_SOCKETBASE_ReleaseSocket       = -150
#_LVO_SOCKETBASE_ReleaseCopyOfSocket = -156
#_LVO_SOCKETBASE_Errno               = -162
#_LVO_SOCKETBASE_SetErrnoPtr         = -168
#_LVO_SOCKETBASE_Inet_NtoA           = -174
#_LVO_SOCKETBASE_inet_addr           = -180
#_LVO_SOCKETBASE_Inet_LnaOf          = -186
#_LVO_SOCKETBASE_Inet_NetOf          = -192
#_LVO_SOCKETBASE_Inet_MakeAddr       = -198
#_LVO_SOCKETBASE_inet_network        = -204
#_LVO_SOCKETBASE_gethostbyname       = -210
#_LVO_SOCKETBASE_gethostbyaddr       = -216
#_LVO_SOCKETBASE_getnetbyname        = -222
#_LVO_SOCKETBASE_getnetbyaddr        = -228
#_LVO_SOCKETBASE_getservbyname       = -234
#_LVO_SOCKETBASE_getservbyport       = -240
#_LVO_SOCKETBASE_getprotobyname      = -246
#_LVO_SOCKETBASE_getprotobynumber    = -252
#_LVO_SOCKETBASE_vsyslog             = -258
#_LVO_SOCKETBASE_Dup2Socket          = -264
#_LVO_SOCKETBASE_sendmsg             = -270
#_LVO_SOCKETBASE_recvmsg             = -276
#_LVO_SOCKETBASE_gethostname         = -282
#_LVO_SOCKETBASE_gethostid           = -288
#_LVO_SOCKETBASE_SocketBaseTagList   = -294
#_LVO_SOCKETBASE_GetSocketEvents     = -300

;/*
; * AmiTCP asynchronous Event definitions
; */
#FD_ACCEPT   = $001 ; /* there is a connection To accept() */
#FD_CONNECT  = $002 ; /* connect() completed */
#FD_OOB      = $004 ; /* socket has out-of-band Data */
#FD_READ     = $008 ; /* socket is readable */
#FD_WRITE    = $010 ; /* socket is writeable */
#FD_ERROR    = $020 ; /* asynchronous error On socket */
#FD_CLOSE    = $040 ; /* connection closed (graceful OR NOT) */

;/*
; * Definition For Release(CopyOf)Socket unique id
; */
#UNIQUE_ID = (-1)

;/*
; * This is Used instead of -1, since the
; * SOCKET Type is unsigned.
; */
#SOCKET_ERROR   = -1
#INVALID_SOCKET = $FFFFFFFF

;/*
; * Types
; */
#SOCK_STREAM     =1  ; /* stream socket */
#SOCK_DGRAM      =2  ; /* datagram socket */
#SOCK_RAW        =3  ; /* raw-protocol interface */
#SOCK_RDM        =4  ; /* reliably-delivered message */
#SOCK_SEQPACKET  =5  ; /* sequenced packet stream */

;/*
; * Option flags per-socket.
; */
#SO_DEBUG       = $0001   ; /* turn On debugging info recording */
#SO_ACCEPTCONN  = $0002   ; /* socket has had listen() */
#SO_REUSEADDR   = $0004   ; /* allow local address reuse */
#SO_KEEPALIVE   = $0008   ; /* keep connections alive */
#SO_DONTROUTE   = $0010   ; /* just Use interface addresses */
#SO_BROADCAST   = $0020   ; /* permit sending of broadcast msgs */
#SO_USELOOPBACK = $0040   ; /* bypass hardware when possible */
#SO_LINGER      = $0080   ; /* linger On close If Data present */
#SO_OOBINLINE   = $0100   ; /* leave received OOB Data in Line */

;/*
; * Additional options, NOT kept in so_options.
; */
#SO_SNDBUF    = $1001   ; /* send Buffer size */
#SO_RCVBUF    = $1002   ; /* receive Buffer size */
#SO_SNDLOWAT  = $1003   ; /* send Low-water mark */
#SO_RCVLOWAT  = $1004   ; /* receive Low-water mark */
#SO_SNDTIMEO  = $1005   ; /* send timeout */
#SO_RCVTIMEO  = $1006   ; /* receive timeout */
#SO_ERROR     = $1007   ; /* Get error status AND clear */
#SO_TYPE      = $1008   ; /* Get socket Type */

;/*
; * AmiTCP/IP specific socket options
; */
#SO_EVENTMASK = $2001   ; /* socket Event mask,     */
         ; /* defaults To no events (0) */

;/*
; * Structure Used For manipulating linger option.
; */
NEWTYPE.linger
  l_onoff.l   ; /* option on/off */
  l_linger.l  ; /* linger time */
End NEWTYPE

;/*
; * Level number For (Get/set)sockopt() To apply To socket itself.
; */
#SOL_SOCKET = $ffff   ; /* options For socket level */

;/*
; * Address families.
; */
#AF_UNSPEC     = 0  ; /* unspecified */
#AF_UNIX       = 1  ; /* local To host (pipes, portals) */
#AF_INET       = 2  ; /* internetwork: UDP, TCP, etc. */
#AF_IMPLINK    = 3  ; /* arpanet imp addresses */
#AF_PUP        = 4  ; /* pup protocols: e.g. BSP */
#AF_CHAOS      = 5  ; /* mit CHAOS protocols */
#AF_NS         = 6  ; /* XEROX NS protocols */
#AF_ISO        = 7  ; /* ISO protocols */
#AF_OSI        = #AF_ISO
#AF_ECMA       = 8  ; /* european computer manufacturers */
#AF_DATAKIT    = 9  ; /* datakit protocols */
#AF_CCITT      = 10   ; /* CCITT protocols, X.25 etc */
#AF_SNA        = 11   ; /* IBM SNA */
#AF_DECnet     = 12   ; /* DECnet */
#AF_DLI        = 13   ; /* DEC Direct Data LINK interface */
#AF_LAT        = 14   ; /* LAT */
#AF_HYLINK     = 15   ; /* NSC Hyperchannel */
#AF_APPLETALK  = 16   ; /* Apple Talk */
#AF_ROUTE      = 17   ; /* Internal Routing Protocol */
#AF_LINK       = 18   ; /* LINK layer interface */
#pseudo_AF_XTP = 19   ; /* eXpress Transfer Protocol (no AF) */

#AF_MAX        =  20

;/*
; * Structure Used by kernel To store most
; * addresses.
; */
NEWTYPE.sockaddr
  sa_len.b        ; /* total length */
  sa_family.b     ; /* address family */
  sa_data.b[14]   ; /* actually longer; address value */
End NEWTYPE

;/*
; * Structure Used by kernel To pass protocol
; * information in raw sockets.
; */
NEWTYPE.sockproto
  sp_family.w   ; /* address family */
  sp_protocol.w   ; /* protocol */
End NEWTYPE

;/*
; * Protocol families, same as address families For now.
; */
#PF_UNSPEC    = #AF_UNSPEC
#PF_UNIX      = #AF_UNIX
#PF_INET      = #AF_INET
#PF_IMPLINK   = #AF_IMPLINK
#PF_PUP       = #AF_PUP
#PF_CHAOS     = #AF_CHAOS
#PF_NS        = #AF_NS
#PF_ISO       = #AF_ISO
#PF_OSI       = #AF_ISO
#PF_ECMA      = #AF_ECMA
#PF_DATAKIT   = #AF_DATAKIT
#PF_CCITT     = #AF_CCITT
#PF_SNA       = #AF_SNA
#PF_DECnet    = #AF_DECnet
#PF_DLI       = #AF_DLI
#PF_LAT       = #AF_LAT
#PF_HYLINK    = #AF_HYLINK
#PF_APPLETALK = #AF_APPLETALK
#PF_ROUTE     = #AF_ROUTE
#PF_LINK      = #AF_LINK
#PF_XTP       = #pseudo_AF_XTP; /* really just proto family, no AF */

#PF_MAX       = #AF_MAX

;/*
; * Maximum Queue Length specifiable by listen.
; */
#SOMAXCONN = 5

;/*
; * Message header For recvmsg AND sendmsg calls.
; * Used value-result For recvmsg, value only For sendmsg.
; */
NEWTYPE.iovec
  iov_base.l
  iov_len.l
End NEWTYPE

NEWTYPE.msghdr
  msg_name.l          ; /* optional address */
  msg_namelen.l       ; /* size of address */
  *msg_iov.iovec      ; /* scatter/gather array */
  msg_iovlen.l        ; /* # elements in msg_iov */
  msg_control.l       ; /* ancillary data, see below */
  msg_controllen.l    ; /* ancillary data buffer len */
  msg_flags.l         ; /* flags on received message */
End NEWTYPE

#MSG_OOB       =  $1  ; /* process out-of-band Data */
#MSG_PEEK      =  $2  ; /* Peek at incoming message */
#MSG_DONTROUTE =  $4  ; /* send without using routing tables */
#MSG_EOR       =  $8  ; /* Data completes Record */
#MSG_TRUNC     = $10  ; /* Data discarded before delivery */
#MSG_CTRUNC    = $20  ; /* control Data lost before delivery */
#MSG_WAITALL   = $40  ; /* Wait For full Request OR error */

;/*
; * Header For ancillary Data objects in msg_control Buffer.
; * Used For additional information with/about a datagram
; * NOT expressible by flags.  The Format is a sequence
; * of message elements headed by cmsghdr structures.
; */
NEWTYPE.cmsghdr
  cmsg_len.l  ; /* data byte count, including hdr */
  cmsg_level.l;  ; /* originating protocol */
  cmsg_type.l;   ; /* protocol-specific type */
;/* followed by  u_char  cmsg_data[]; */
End NEWTYPE

;/* given Pointer To struct adatahdr, Return Pointer To Data */
;#CMSG_DATA(cmsg)   ((u_char *)((cmsg) + 1))

;/* given Pointer To struct adatahdr, Return Pointer To Next adatahdr */
;#CMSG_NXTHDR(mhdr, cmsg) \
;  (((caddr_t)(cmsg) + (cmsg)->cmsg_len + SizeOf(struct cmsghdr) > \
;      (mhdr)->msg_control + (mhdr)->msg_controllen) ? \
;      (struct cmsghdr *)Null : \
;      (struct cmsghdr *)((caddr_t)(cmsg) + ALIGN((cmsg)->cmsg_len)))

;#CMSG_FIRSTHDR(mhdr) ((struct cmsghdr *)(mhdr)->msg_control)

;/* "Socket"-level control message types: */
#SCM_RIGHTS = $01   ; /* access rights (array of Int) */

;/*
; * 4.3 compat sockaddr, MOVE To compat File later
; */
NEWTYPE.osockaddr
  sa_family.w     ; /* address family */
  sa_data.b[14]   ; /* up to 14 bytes of direct address */
End NEWTYPE

;/*
; * 4.3-compat message header (MOVE To compat File later).
; */
NEWTYPE.omsghdr
  msg_name.l         ; /* optional address */
  msg_namelen.l      ; /* size of address */
  *msg_iov.iovec     ; /* scatter/gather array */
  msg_iovlen.l       ; /* # elements in msg_iov */
  msg_accrights.l    ; /* access rights sent/received */
  msg_accrightslen.l
End NEWTYPE

;/*
; * Macros For network/external number representation conversion.
; */
Macro ntohl ; (x)
(`1)
End Macro
Macro ntohs ;  (x)
(`1)
End Macro
Macro htonl ;  (x)
(`1)
End Macro
Macro htons ;  (x)
(`1)
End Macro

;/*
; * Constants AND structures defined by the internet system,
; * Per RFC 790, September 1981.
; */

;/*
; * Protocols
; */
#IPPROTO_IP   =   0   ; /* dummy For IP */
#IPPROTO_ICMP =   1   ; /* control message protocol */
#IPPROTO_GGP  =   3   ; /* gateway^2 (deprecated) */
#IPPROTO_TCP  =   6   ; /* tcp */
#IPPROTO_EGP  =   8   ; /* exterior gateway protocol */
#IPPROTO_PUP  =  12   ; /* pup */
#IPPROTO_UDP  =  17   ; /* user datagram protocol */
#IPPROTO_IDP  =  22   ; /* xns idp */
#IPPROTO_TP   =  29   ; /* tp-4 w/ class negotiation */
#IPPROTO_EON  =  80   ; /* ISO cnlp */

#IPPROTO_RAW  = 255   ; /* raw IP packet */
#IPPROTO_MAX  = 256

; /*
; * Local port number conventions:
; * Ports < IPPORT_RESERVED are reserved For
; * privileged processes (e.g. root).
; * Ports > IPPORT_USERRESERVED are reserved
; * For servers, NOT necessarily privileged.
; */
#IPPORT_RESERVED     = 1024
#IPPORT_USERRESERVED = 5000

; /*
; * Internet address (a structure For historical reasons)
; */
NEWTYPE.in_addr
  s_addr.l
End NEWTYPE

; /*
; * Definitions of bits in internet address integers.
; * On subnets, the decomposition of addresses To host AND net parts
; * is done according To subnet mask, NOT the masks here.
; */
;#IN_CLASSA(i)    (((long)(i) & 0x80000000) == 0)
#IN_CLASSA_NET     = $ff000000
#IN_CLASSA_NSHIFT  = 24
#IN_CLASSA_HOST    = $00ffffff
#IN_CLASSA_MAX     = 128

;#IN_CLASSB(i)    (((long)(i) & 0xc0000000) == 0x80000000)
#IN_CLASSB_NET     = $ffff0000
#IN_CLASSB_NSHIFT  = 16
#IN_CLASSB_HOST    = $0000ffff
#IN_CLASSB_MAX     = 65536

;#IN_CLASSC(i)    (((long)(i) & 0xe0000000) == 0xc0000000)
#IN_CLASSC_NET     = $ffffff00
#IN_CLASSC_NSHIFT  = 8
#IN_CLASSC_HOST    = $000000ff

;#IN_CLASSD(i)    (((long)(i) & 0xf0000000) == 0xe0000000)
;#IN_MULTICAST(i)   IN_CLASSD(i)

;#IN_EXPERIMENTAL(i)  (((long)(i) & 0xe0000000) == 0xe0000000)
;#IN_BADCLASS(i)    (((long)(i) & 0xf0000000) == 0xf0000000)

#INADDR_ANY       = $00000000
#INADDR_BROADCAST = $ffffffff  ; /* must be masked */
#INADDR_NONE      = $ffffffff    ; /* -1 Return */
#IN_LOOPBACKNET   = 127     ; /* official! */

; /*
; * Socket address, internet style.
; */
NEWTYPE.sockaddr_in
  sin_len.b
  sin_family.b
  sin_port.w
  sin_addr.in_addr
  sin_zero.b[8]
End NEWTYPE

; /*
; * Structure Used To describe IP options.
; * Used To store options internally, To pass them To a process,
; * OR To Restore options retrieved earlier.
; * The ip_dst is Used For the first-hop gateway when using a source route
; * (this gets Put into the header proper).
; */
NEWTYPE.ip_opts
  ip_dst.in_addr   ; /* first hop, 0 w/o src rt */
  ip_opts.b[40]    ; /* actually variable in size */
End NEWTYPE

; /*
; * Options For Use with [gs]etsockopt at the IP level.
; * First Word of comment is Data Type; bool is stored in int.
; */
#IP_OPTIONS     = 1 ; /* buf/ip_opts; set/get IP per-packet options */
#IP_HDRINCL     = 2 ; /* Int; header is included with data (raw) */
#IP_TOS         = 3 ; /* Int; IP type of service and precedence */
#IP_TTL         = 4 ; /* Int; IP time to live */
#IP_RECVOPTS    = 5 ; /* bool; receive all IP options w/datagram */
#IP_RECVRETOPTS = 6 ; /* bool; receive IP options for response */
#IP_RECVDSTADDR = 7 ; /* bool; receive IP dst addr w/datagram */
#IP_RETOPTS     = 8 ; /* ip_opts; set/get IP per-packet options */

;/*
; * Structures returned by network Data base library, taken from the
; * BSD File netdb.h.  All addresses are supplied in host order, AND
; * returned in network order (suitable For Use in system calls).
; */

NEWTYPE.hostent
*h_name.b           ; /* official name of host */
*h_aliases.l        ; /* alias list */
h_addrtype.l        ; /* host address type */
h_length.l          ; /* length of address */
*h_addr_list.l      ; /* list of addresses */
End NEWTYPE

;/*
; * It is assumed here that a network number
; * fits in 32 bits.
; */
NEWTYPE.netent
*n_name.b        ; /* official name of net */
*n_aliases.l     ; /* alias list */
n_addrtype.l     ; /* net address type */
n_net.l          ; /* network # */
End NEWTYPE

NEWTYPE.servent
*s_name.b        ; /* official service name */
*s_aliases.l     ; /* alias list */
s_port.l         ; /* port # */
*s_proto.b       ; /* protocol to use */
End NEWTYPE

NEWTYPE.protoent
*p_name.b        ; /* official protocol name */
*p_aliases.l     ; /* alias list */
p_proto.l        ; /* protocol # */
End NEWTYPE

#HOST_NOT_FOUND  = 1 ;/* Authoritative Answer Host NOT found */
#TRY_AGAIN       = 2 ;/* NOn-Authoritive Host NOT found, OR SERVERFAIL */
#NO_RECOVERY     = 3 ;/* NOn recoverable errors, FORMERR, REFUSED, NOTIMP */
#NO_DATA         = 4 ;/* Valid name, no Data Record of requested Type */
#NO_ADDRESS      =#NO_DATA  ; /* no address, look For MX Record */


SHARED *_SocketBase.Library

; Helper Macros:
Macro __SocketBase_SaveRegs
MOVE.l a4,-(a7) : MOVE.l a5,-(a7) : MOVE.l a6,-(a7) : MOVE.l d7,-(a7)
End Macro

Macro __SocketBase_RestoreRegs
MOVE.l (a7)+,d7 : MOVE.l (a7)+,a6 : MOVE.l (a7)+,a5 : MOVE.l (a7)+,a4
End Macro


; Wrapper Macros:
Macro bsd_socket;{ret.l,domain,type,protocol}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg d2,`4
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_socket(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_bind;{ret.l,s,name,namelen}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg d1,`4
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_bind(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_listen;{ret.l,s,backlog}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_listen(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_accept;{ret.l,s,addr,addrlen}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg a1,`4
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_accept(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_connect;{ret.l,s,name,namelen}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg d1,`4
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_connect(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_sendto;{ret.l,s,msg,len,flags,to,tolen}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg d1,`4
GetReg d2,`5
GetReg a1,`6
GetReg d3,`7
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_sendto(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_send;{ret.l,s,msg,len,flags}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg d1,`4
GetReg d2,`5
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_send(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_recvfrom;{ret.l,s,buf,len,flags,from,fromlen}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg d1,`4
GetReg d2,`5
GetReg a1,`6
GetReg a2,`7
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_recvfrom(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_recv;{ret.l,s,buf,len,flags}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg d1,`4
GetReg d2,`5
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_recv(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_shutdown;{ret.l,s,how}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_shutdown(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_setsockopt;{ret.l,s,level,optname,optval,optlen}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg d2,`4
GetReg a0,`5
GetReg d3,`6
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_setsockopt(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_getsockopt;{ret.l,s,level,optname,optval,optlen}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg d2,`4
GetReg a0,`5
GetReg a1,`6
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_getsockopt(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_getsockname;{ret.l,s,hostname,namelen}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg a1,`4
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_getsockname(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_getpeername;{ret.l,s,hostname,namelen}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg a1,`4
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_getpeername(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_IoctlSocket;{ret.l,d,request,argp}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg a0,`4
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_IoctlSocket(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_CloseSocket;{ret.l,d}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_CloseSocket(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_WaitSelect;{ret.l,nfds,readfds,writefds,execptfds,timeout,maskp}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg a1,`4
GetReg a2,`5
GetReg a3,`6
GetReg d1,`7
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_WaitSelect(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_SetSocketSignals;{ret.l,SIGINTR,SIGIO,SIGURG}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg d2,`4
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_SetSocketSignals(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_getdtablesize;{ret.l}
!__SocketBase_SaveRegs
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_getdtablesize(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_ObtainSocket;{ret.l,id,domain,type,protocol}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg d2,`4
GetReg d3,`5
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_ObtainSocket(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_ReleaseSocket;{ret.l,fd,id}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_ReleaseSocket(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_ReleaseCopyOfSocket;{ret.l,fd,id}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_ReleaseCopyOfSocket(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_Errno;{ret.l}
!__SocketBase_SaveRegs
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_Errno(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_SetErrnoPtr;{ret.l,errno_p,size}
!__SocketBase_SaveRegs
GetReg a0,`2
GetReg d0,`3
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_SetErrnoPtr(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_Inet_NtoA;{ret.l,in}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_Inet_NtoA(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_inet_addr;{ret.l,cp}
!__SocketBase_SaveRegs
GetReg a0,`2
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_inet_addr(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_Inet_LnaOf;{ret.l,in}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_Inet_LnaOf(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_Inet_NetOf;{ret.l,in}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_Inet_NetOf(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_Inet_MakeAddr;{ret.l,net,host}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_Inet_MakeAddr(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_inet_network;{ret.l,cp}
!__SocketBase_SaveRegs
GetReg a0,`2
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_inet_network(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_gethostbyname;{ret.l,name}
!__SocketBase_SaveRegs
GetReg a0,`2
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_gethostbyname(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_gethostbyaddr;{ret.l,addr,len,type}
!__SocketBase_SaveRegs
GetReg a0,`2
GetReg d0,`3
GetReg d1,`4
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_gethostbyaddr(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_getnetbyname;{ret.l,name}
!__SocketBase_SaveRegs
GetReg a0,`2
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_getnetbyname(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_getnetbyaddr;{ret.l,net,type}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_getnetbyaddr(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_getservbyname;{ret.l,name,proto}
!__SocketBase_SaveRegs
GetReg a0,`2
GetReg a1,`3
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_getservbyname(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_getservbyport;{ret.l,port,proto}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_getservbyport(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_getprotobyname;{ret.l,name}
!__SocketBase_SaveRegs
GetReg a0,`2
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_getprotobyname(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_getprotobynumber;{ret.l,proto}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_getprotobynumber(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_vsyslog;{ret.l,level,format,ap}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg a1,`4
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_vsyslog(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_Dup2Socket;{ret.l,fd1,fd2}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg d1,`3
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_Dup2Socket(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_sendmsg;{ret.l,s,msg,flags}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg d1,`4
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_sendmsg(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_recvmsg;{ret.l,s,msg,flags}
!__SocketBase_SaveRegs
GetReg d0,`2
GetReg a0,`3
GetReg d1,`4
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_recvmsg(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_gethostname;{ret.l,hostname,size}
!__SocketBase_SaveRegs
GetReg a0,`2
GetReg d0,`3
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_gethostname(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_gethostid;{ret.l}
!__SocketBase_SaveRegs
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_gethostid(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_SocketBaseTagList;{ret.l,taglist}
!__SocketBase_SaveRegs
GetReg a0,`2
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_SocketBaseTagList(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro

Macro bsd_GetSocketEvents;{ret.l,eventmaskp}
!__SocketBase_SaveRegs
GetReg a0,`2
GetReg a6,*_SocketBase
JSR _LVO_SOCKETBASE_GetSocketEvents(a6)
!__SocketBase_RestoreRegs
`1 = PutD0
End Macro


; Open/Close Library:
Function.l bsd_OpenLib{@minVersion.l}
If (*_SocketBase)
  If (minVersion<=*_SocketBase\lib_Version) Then Function Return *_SocketBase
  CloseLibrary_ *_SocketBase : *_SocketBase = 0
End If
If minVersion<0 Then minVersion = 0
*_SocketBase = OpenLibrary_ ("bsdsocket.library",minVersion)
If *_SocketBase
  ; (!) Do some other init stuff here...
Else
  If (minVersion>0)
    error{"Unable to open bsdsocket.library (v"+Str$(minVersion)+"+)!"}
  Else
    error{"Unable to open bsdsocket.library!"}
  End If
End If
Function Return *_SocketBase
End Function

Statement bsd_CloseLib{}
If *_SocketBase
  ; (!) Do some freeing stuff here that you inited in _SocketBase_Init{}...
  CloseLibrary_ *_SocketBase : *_SocketBase = 0
End If
End Statement
!autoexit{bsd_CloseLib}


; Wrapper Functions:
Function.l bsd_socket{_domain.l,_type.l,_protocol.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_socket{socket.l,_domain,_type,_protocol}
End If
Function Return socket
End Function

;Int PASCAL FAR bind (IN SOCKET s,IN const struct sockaddr FAR *Addr,IN Int namelen);
;The bind Function associates a local address with a socket.
Function.l bsd_bind{socket.l,*name.sockaddr,namelen.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_bind{result.l,socket,*name,namelen}
End If
Function Return result
End Function

Function.l bsd_listen{socket.l,_backlog.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_listen{result.l,socket,_backlog}
End If
Function Return result
End Function

; SOCKET PASCAL FAR accept ( IN SOCKET s, OUT struct sockaddr FAR *Addr, IN OUT Int FAR *addrlen);
Function.l bsd_accept{socket.l,*_addr.sockaddr,*_addrlen.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_accept{resocket.l,socket,*_addr,*_addrlen}
End If
Function Return resocket
End Function

;Int PASCAL FAR connect (IN SOCKET s,IN const struct sockaddr FAR *name,IN Int namelen);
Function.l bsd_connect{socket.l,*name.sockaddr,namelen.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_connect{result.l,socket,*name,namelen}
End If
Function Return result
End Function

; Int PASCAL FAR sendto (IN SOCKET s,IN const char FAR * buf,IN Int Len,IN Int flags,IN const struct sockaddr FAR *To,IN Int tolen);
Function.l bsd_sendto{socket.l,*msg.b,msglen.l,flags.l,*toaddr.sockaddr,tolen.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_sendto{result.l,socket,*msg,msglen,flags,*toaddr,tolen}
End If
Function Return result
End Function

; Int PASCAL FAR send (IN SOCKET s,IN const char FAR * buf,IN Int Len,IN Int flags);
Function.l bsd_send{socket.l,*msg.b,msglen.l,flags.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_send{result.l,socket,*msg,msglen,flags}
End If
Function Return result
End Function

Function.l bsd_recvfrom{socket.l,_buf.l,_len.l,_flags.l,_from.l,_fromlen.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_recvfrom{result.l,socket,_buf,_len,_flags,_from,_fromlen}
End If
Function Return result
End Function

; Int PASCAL FAR recv (IN SOCKET s,__out_bcount_part(Len, Return) __out_data_source(NETWORK) char FAR * buf,IN Int Len,IN Int flags);
Function.l bsd_recv{socket.l,*buf.l,_len.l,flags.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_recv{result.l,socket,*buf,_len,flags}
End If
Function Return result
End Function

Function.l bsd_shutdown{socket.l,_how.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_shutdown{result.l,socket,_how}
End If
Function Return result
End Function

Function.l bsd_setsockopt{socket.l,_level.l,_optname.l,_optval.l,_optlen.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_setsockopt{result.l,socket,_level,_optname,_optval,_optlen}
End If
Function Return result
End Function

;Int PASCAL FAR getsockopt (IN SOCKET s,IN Int level,IN Int optname,__out_bcount(*optlen) char FAR * optval,IN OUT Int FAR *optlen);
Function.l bsd_getsockopt{socket.l,level.l,optname.l,optval.s,*optlen.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_getsockopt{result.l,socket,level,optname,&optval,*optlen}
End If
Function Return result
End Function

; Int PASCAL FAR getsockname (IN SOCKET s,OUT struct sockaddr FAR *name,IN OUT Int FAR * namelen);
Function.l bsd_getsockname{socket.l,*hostname.sockaddr,namelen.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_getsockname{result.l,socket,*hostname,namelen}
End If
Function Return result
End Function

; getpeername (IN SOCKET s,OUT struct sockaddr FAR *name,IN OUT Int FAR * namelen);
; The getpeername function retrieves the address of the peer to which a socket is connected.
Function.l bsd_getpeername{socket.l,*hostname.sockaddr,namelen.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_getpeername{result.l,socket,*hostname,namelen}
End If
Function Return result
End Function

; Int PASCAL FAR ioctlsocket (IN SOCKET s,IN long cmd,IN OUT u_lng FAR *argp);
Function.l bsd_IoctlSocket{socket.l,_request.l,*argp.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_IoctlSocket{result.l,socket,_request,*argp}
End If
Function Return result
End Function

Function.l bsd_CloseSocket{socket.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_CloseSocket{result.l,socket}
End If
Function Return result
End Function

Function.l bsd_WaitSelect{_nfds.l,_readfds.l,_writefds.l,_execptfds.l,_timeout.l,_maskp.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_WaitSelect{result.l,_nfds,_readfds,_writefds,_execptfds,_timeout,_maskp}
End If
Function Return result
End Function

Function.l bsd_SetSocketSignals{_SIGINTR.l,_SIGIO.l,_SIGURG.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_SetSocketSignals{result.l,_SIGINTR,_SIGIO,_SIGURG}
End If
Function Return result
End Function

Function.l bsd_getdtablesize{}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_getdtablesize{result.l}
End If
Function Return result
End Function

Function.l bsd_ObtainSocket{_id.l,_domain.l,_type.l,_protocol.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_ObtainSocket{result.l,_id,_domain,_type,_protocol}
End If
Function Return result
End Function

Function.l bsd_ReleaseSocket{_fd.l,_id.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_ReleaseSocket{result.l,_fd,_id}
End If
Function Return result
End Function

Function.l bsd_ReleaseCopyOfSocket{_fd.l,_id.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_ReleaseCopyOfSocket{result.l,_fd,_id}
End If
Function Return result
End Function

Function.l bsd_Errno{}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_Errno{result.l}
End If
Function Return result
End Function

Function.l bsd_SetErrnoPtr{_errno_p.l,_size.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_SetErrnoPtr{result.l,_errno_p,_size}
End If
Function Return result
End Function

Function.s bsd_Inet_NtoA{in_addr.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_Inet_NtoA{resultP.l,in_addr}
  If resultP Then result.s=Peek.s(resultP)
End If
Function Return result
End Function

;unsigned long PASCAL FAR inet_addr (IN const char FAR * cp);
Function.l bsd_inet_addr{cp.s}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_inet_addr{result.l,&cp}
End If
Function Return result
End Function

Function.l bsd_Inet_LnaOf{_in.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_Inet_LnaOf{result.l,_in}
End If
Function Return result
End Function

Function.l bsd_Inet_NetOf{_in.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_Inet_NetOf{result.l,_in}
End If
Function Return result
End Function

Function.l bsd_Inet_MakeAddr{_net.l,_host.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_Inet_MakeAddr{result.l,_net,_host}
End If
Function Return result
End Function

Function.l bsd_inet_network{_cp.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_inet_network{result.l,_cp}
End If
Function Return result
End Function

;struct hostent FAR * PASCAL FAR gethostbyname(IN const char FAR * name);
Function.l bsd_gethostbyname{name.s}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_gethostbyname{*result.hostent,&name}
End If
Function Return *result
End Function

;struct hostent FAR * PASCAL FAR gethostbyaddr(IN const char FAR * Addr,IN Int Len,IN Int Type);
Function.l bsd_gethostbyaddr{_addr.l,_len.l,_type.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_gethostbyaddr{*result.hostent,_addr,_len,_type}
End If
Function Return *result
End Function

Function.l bsd_getnetbyname{_name.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_getnetbyname{result.l,_name}
End If
Function Return result
End Function

Function.l bsd_getnetbyaddr{_net.l,_type.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_getnetbyaddr{result.l,_net,_type}
End If
Function Return result
End Function

Function.l bsd_getservbyname{_name.l,_proto.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_getservbyname{result.l,_name,_proto}
End If
Function Return result
End Function

Function.l bsd_getservbyport{_port.l,_proto.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_getservbyport{result.l,_port,_proto}
End If
Function Return result
End Function

Function.l bsd_getprotobyname{_name.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_getprotobyname{result.l,_name}
End If
Function Return result
End Function

Function.l bsd_getprotobynumber{_proto.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_getprotobynumber{result.l,_proto}
End If
Function Return result
End Function

Function.l bsd_vsyslog{_level.l,_format.l,_ap.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_vsyslog{result.l,_level,_format,_ap}
End If
Function Return result
End Function

Function.l bsd_Dup2Socket{socket1.l,socket2.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_Dup2Socket{result.l,socket1,socket2}
End If
Function Return result
End Function

Function.l bsd_sendmsg{socket.l,_msg.l,_flags.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_sendmsg{result.l,socket,_msg,_flags}
End If
Function Return result
End Function

Function.l bsd_recvmsg{socket.l,_msg.l,_flags.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_recvmsg{result.l,socket,_msg,_flags}
End If
Function Return result
End Function

;Int PASCAL FAR gethostname (__out_bcount_part(namelen, Return) char FAR * name,IN Int namelen);
Function.l bsd_gethostname{*hostname.b,namelen.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_gethostname{result.l,*hostname,namelen}
End If
Function Return result
End Function

Function.l bsd_gethostid{}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_gethostid{result.l}
End If
Function Return result
End Function

Function.l bsd_SocketBaseTagList{_taglist.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_SocketBaseTagList{result.l,_taglist}
End If
Function Return result
End Function

Function.l bsd_GetSocketEvents{_eventmaskp.l}
If (bsd_OpenLib{}) ; (!) put your min version here if needed!
  !bsd_GetSocketEvents{result.l,_eventmaskp}
End If
Function Return result
End Function


CNIF #__include=0
hostname.s = "www.google.de"
hostip.s   = "127.0.0.1"

;/* resolve a DNS name */
*myhost.hostent = bsd_gethostbyname{hostname}
If *myhost
  hostip.s = bsd_Inet_NtoA{Peek.l(Peek.l(*myhost\h_addr_list))}
  NPrint "Hostname:   ",Peek.s(*myhost\h_name)
  NPrint "IP-Address: ",hostip
End If

;/* create a socket */
NPrint "Creating socket..."
socket.l = bsd_socket{#PF_INET, #SOCK_STREAM, #IPPROTO_TCP}
If socket = -1
  NPrint "Cannot create tcp/ip socket!"
  End
Else
  NPrint "Socket #",socket," created."
EndIf

s_addr.sockaddr_in\sin_family      = #AF_INET
s_addr.sockaddr_in\sin_port        = 80
s_addr.sockaddr_in\sin_addr\s_addr = bsd_inet_addr{hostip}

NPrint "Connecting to ",hostip,"..."
If bsd_connect{socket, &s_addr, SizeOf .sockaddr_in} = #SOCKET_ERROR
  errorcode.l = bsd_Errno{}
  NPrint "Connect() failed with error #",errorcode,"!"
Else
  NPrint "Connect() successful!"
EndIf

NPrint "Shutdown..."
bsd_CloseSocket{socket}

NPrint "Done."
End

CEND


