; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = ""
; ExeFile         = ""
; CreateIcon      = 1
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 0
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 95
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 80000
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 1
; AssemblerCheck  = 1
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 1796
; CursorColumn    = 1
; LabelSearch     = "defaultoutput"
; LabelRemark     = 0
; LabelAll        = 1
; LabelCase       = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 11
; Max GadgetList  = 5
; Max Shape       = 100
; Max Bank        = 5
; Max MenuList    = 5
; Max GTList      = 26
; Max Palette     = 4
; Max BitMap      = 10
; Max Screen      = 5
; Max IntuiFont   = 5
; Max BlitzFont   = 4
; Max Window      = 20
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max TagList     = 5
; Max Database    = 16
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
; +---------------------------------------------------------------------------------------------------------+
; |                                                                                                         |
; | Wizard_Table.Include Version 1.7                                                                        |
; | usefull routines to extend wizard-functionality                                                         |
; | (c) 2006-2023 - Sven Droege - eMail: sven.droege@hotmail.com                                            |
; |                                                                                                         |
; |                                                                                                         |
; | CHANGES:                                                                                                |
; | V1.7 : + replaced LotanDraw-calls with native OS-Calls                                                  |
; | V1.6 : + internal improvements                                                                          |
; | V1.5 : + internal improvements                                                                          |
; | V1.4 : + replaced reqtools-Requester with error.include                                                 |
; | V1.3 : + Doubleclick-detection, returns eventcode #WZTABLEEVENT_DOUBLCLICK                              |
; |        + sorting a row by clicking on the row head possible                                             |
; |        + condditional compilation added, if image.include or tools.include not available                |
; |                                                                                                         |
; | Declarations:                                                                                           |
; | - an empty wizardobject of type "space" is needed to render the table inside                            |
; | - functions use that object by addressing it by its wizard-Id                                           |
; | - the gui-data is accessed by the reference  "?wzgui", that means the wizard data has to be loaded      |
; |   like WZLoadGUI ?wzgui                                                                                 |
; |                                                                                                         |
; |                                                                                                         |
; |                                                                                                         |
; | This include offers the following extentions to wzlib                                                   |
; |                                                                                                         |
; | * Table-functions                                                                                       |
; | +  WZ_InitTable       : befuellt das NewType "wztabledata" mit Eingangswerten, die das Aussehen         |
; |                         der Tabelle beeinflussen (siehe Kommentare in der Struktur)                     |
; | +  WZ_DrawTable       : Zeichnet die Tabelle in das WizarObject ohne Daten                              |
; | +  WZ_UpdateTable     : Fuellt die Tabelle mit Werten aus der Liste wzrow()                             |
; | +  WZ_AddRow          : Fuegt der Liste wzrow() eine neue Zeile mit Inhalt zu                           |
; | +  WZ_MouseRow        : gibt an, in welche Zeile der User geklickt hat (FENSTERBEZOGEN)                 |
; | +  WZ_MouseColumn     : gibt an, in welche Spalte der User geklickt hat (FENSTERBEZOGEN)                |
; | +  WZ_HighlightTable  : malt eine Balken hinter die angegebene Zeile                                    |
; | +  WZ_EditCell        : malt ein GT-String in die angegebene Zelle (FENSTERBEZOGEN!)                    |
; | +  WZ_CheckTableEvent : behandelt ausgeloeste Events, wie TAB oder ENTER                                |
; | +  WZ_ClearTable      : loescht alle Listeneintraege                                                    |
; | +  WZ_KillTable       : loescht die kompletten Tabellendaten                                            |
; | +  WZ_GetCell         : gibt den Inhalt einer Zelle zurueck (absolute Zellenkoordinaten!)               |
; | +  WZ_SetCell         : setzt den Inhalt einer Zelle (absolute Zellenkoordinaten!)                      |
; | +  WZ_SetCellPen      : setzt Farben/styles fuer einzelne Zellen                                        |
; |                                                                                                         |
; | BEACHTEN: Einige Funktionen geben die relative Zelle zurueck, also im gerade sichtbaren                 |
; |           Tabellenausschnitt, einige Funktionen erwarten absoluten Zellenkoordinaten !!                 |
; |                                                                                                         |
; |                                                                                                         |
; | * Popup-Menu                                                                                            |
; | - WZ_SetPopUpMenu{}   : erstellt die Menueintrdge, die Eintraege werden durch chr$(10) getrennet        |
; | - WZ_PopUp{x,y}       : ruft das popupmenu auf und liefert den angewaehlten Eintrag zur|ck              |
; |                                                                                                         |
; |                                                                                                         |
; |                                                                                                         |
; | * Hilfebubble                                                                                           |
; | - Vorausgesetzt wird ein WZFenster WIN_BUBBLEHELP mit gesetztem Borderless-Attribut                     |
; | - Es werden die Hilfetexte, die im Wizard eingetragen wurden, bei der aktuellen Mausposition angezeigt  |
; | +  WZ_ShowBubble{}  : muss zum Ereignis IDCMP_GADGETHELP aufgerufen werdwen                             |
; | +  WZ_HideBubble{}  : dient zum loeschen der Bubble nach einem anderen Ereignis                         |
; |                                                                                                         |
; | * Fortschrittsanzeige                                                                                   |
; | - Vorausgesetzt wird ein WZFenster WIN_PROGRESS mit einem Objekt                                        |
; |   Args "FORTSCHRITT und einem GAUGE "GAUGE"                                                             |
; | + WZ_ShowMessage{} ; stellt das InfoFenster mit uebergebenem String dar                                 |
; | + WZ_HideMessage{} : schliesst das InfoFenster wieder                                                   |
; | + WZ_Update_Gauge  : aktualisiert das GAUGE im InfoFenster, Angabe:  Prozentsatz,Gesamtwert             |
; +---------------------------------------------------------------------------------------------------------+


CNIF #__include=0
  OPTIMIZE 4
  SYNTAX 6
  #max_images=100
  #WZ_USE_IMAGES=0 ; if no graphics are used, all image_*-functions are not compiled
                   ; useful for Kick2.0-sytems without datatype.library
CELSE
  #WZ_USE_IMAGES=0
CEND

#WZ_TABLE_VERSION = 16
;CNIF #__include = 0
; z.Zt. noch im Quellcode, um Fenster wie die Fortschrittsanzeige zu unterdruecken
; ist #USE_WIZARD nicht definiert, dann werden WZ_Fenster nicht angezeigt.
; die Wizard.lib wird verwendet:
  #USE_WIZARD = 1
;CEND

;SHARED wzgui.l

XINCLUDE "error.include.ab3"
XINCLUDE "dos.include.ab3"
XINCLUDE "screen.include.ab3"
XINCLUDE "wizard_Tools.include.ab3"

CNIF #WZ_USE_IMAGES <> 0
  XINCLUDE "image.include.ab3"
CEND

; check if include was compiled with enough space for used objects
If ((Maximum GTList) < 25) OR ((Maximum File) < 10)
  dummy.l = ask{"Object Maximum too small\\nIncrease Objectsize for GTList to >25\\nand Objectsize for Files to >10","Exit","Error"}
  End
EndIf


#WZ_MAXCOLUMNS             = 10
#WZTABLEEVENT_CELLSELECTED =  8
#WZTABLEEVENT_CELLCHANGED  =  9
#WZTABLEEVENT_POPUPMENU    = 10
#WZTABLEEVENT_DOUBLECLICK  = 11

NEWTYPE.wzcolumns
  title.s[#WZ_MAXCOLUMNS]         ; hier werden die Spaltentitel abgelegt
  priority.l[#WZ_MAXCOLUMNS]      ; hier wird eine Prioritaet fuer jeder maxColumns vergeben, die ueber die relative Breite entscheidet
  breite.w[#WZ_MAXCOLUMNS]        ; gibt die Breite der jeweiligen Spalte an
  editable_.l[#WZ_MAXCOLUMNS]     ; gibt an, ob die Spalte editierbar ist
  align.l[#WZ_MAXCOLUMNS]
  entrytype.l[#WZ_MAXCOLUMNS]     ; gibt an, ob die Spalte Text oder Images enthalten soll
End NEWTYPE

NEWTYPE.wztabledata
  ;
  ; WARNING: NO pointer to OS-structures, e.g. *win.Window can be added
  ;          as the compiler will crash with guru. Maybe to large?
  ;
  LeftEdge.l
  TopEdge.l
  Width.l
  Height.l
  GadgetID.l
  GTListID.w

  FrontPen.l                    ; Textfarbe des Tabelleninhaltes
  BackPen.l                     ; Hintergrundfarbe der Tabelle
  HeaderPen.l                   ; Textfarbe des Tabellentitels
  HeaderBackPen.l               ; Hintergrundfarbe des Tabellentitels
  HighlightBackPen.l            ; Farbe des Balkens, der die aktuelle Zeile angibt

  vlines.b                      ; legt fest, ob horizontale Linien gezogen werden sollen, BOOL
  hlines.b

  maxColumns.l                  ; legt die Anzahl der maxColumns fest
  readOnly.l                    ; legt fest, ob die Tabelle grundsaetzlich editierbar sein sollen
  isSortable.b                  ; left fest, ob die Tabelle durch klick sortiert werden kann

  id.s
  order.b                       ; gibt an,ob am Anfang oder am Ende hinzugefuegt werden soll
  window_.b                     ; gibt an, welchem Fenster die Tabelle zugeordnet ist
  isOpen.b                      ; gibt an, ob die Tabelle gerade angezeigt wird, BOOL
  zeilen.w                      ; gibt an, wieviele Zeilen derzeit in die Tabelle passen, INTERN
  erste_zeile.w                 ; gibt ab, welche Zeile der Liste als ganz oben in der Tabelle steht
  maxzeilen.w                   ; gibt die Gesamtzeilenzahl der Liste an
  aktuelle_zeile.w              ; gibt die aktuelle Zeile (relativ) in der Tabelle an (nicht in der Liste !)
  aktuelle_spalte.w             ; gibt die aktuelle Spalte (relativ) in der Tabelle an (nicht in der Liste !)
  isBeingEdited.b               ; gibt an, ob gerade eine Zelle editiert wird
  scale_images.l                ; ist dieser Schalter gesetzt, werden Images an die Zeilenhvhe skaliert
                                ; ansonsten wird die Zeile so hoch wie die Imagehoehe
  sorted_by.w                   ; optionale Tabellensortierung nach Spalte ..
  hasBeenChanged.b
  selected_popup.l

  columnsHeight.l               ; height of a column in pixels
  columns.wzcolumns             ; colum data
End NEWTYPE

NEWTYPE.wzrow
  id.l
  hasBeenChanged.b
  isSelected.b
  ;
  cell.s[#WZ_MAXCOLUMNS]
  FrontPen.l[#WZ_MAXCOLUMNS]
  BackPen.l[#WZ_MAXCOLUMNS]
  Style.b[#WZ_MAXCOLUMNS]
End NEWTYPE


NEWTYPE.wzimage
  table.s
  id.l
  Name.s
  Width.l
  Height.l
  _Depth.l
End NEWTYPE


DEFTYPE.wztabledata wztabledata
Dim List wzrow.wzrow(0)
Dim List wzimage.wzimage(0)
SHARED wzimage()


Macro WZ_VerifyVisibility
  If (`1 = (wztabledata\erste_zeile-1) + wztabledata\zeilen)
    If (wztabledata\erste_zeile-1) + `1 = wztabledata\maxzeilen
      `1 + 1
      col = 0
      wztabledata\erste_zeile + 1
    Else
      col = 0
      wztabledata\erste_zeile + 1
      `1 + 1
    EndIf
    ; bereichspruefung
    If wztabledata\erste_zeile-1 + wztabledata\zeilen < wztabledata\maxzeilen
    Else
      `1 - 1
      wztabledata\erste_zeile - 1
    EndIf
  Else
    If (wztabledata\erste_zeile-1) + `1 = wztabledata\maxzeilen
      `1 = 1
      col = 0
      wztabledata\erste_zeile = 1
    Else
      `1 + 1
      col = 0
    EndIf
  EndIf
End Macro


Macro WZ_StdTable
  WZWindow WZID("WIN_TABELLE"),?wzgui,64,-1,-1,-1,-1,WZID("WIN_TABELLE")
  WTitle `1
  WZ_InitTable{"WIN_TABELLE","TABELLE",2,0}
  ; Fuegt Zeilen an die Tabelle "TABELLE2" an
   WZ_SetTableColors{"TABELLE",2,4,1,0,4}
  WZ_SetTableTitle{"TABELLE",`2,`3}
  WZ_SetPriority{"TABELLE",`4,`5}
  WZ_SetTableReadOnly{"TABELLE",False}
  WZ_SetTableLines{"TABELLE",On,Off}
  WZ_SetTableAlign{"TABELLE",#ALIGN_LEFT,#ALIGN_LEFT}
End Macro

Macro WZ_ShowTable
  WZ_DrawTable{"TABELLE"}
  WZ_UpdateTable{"TABELLE"}
  mkt.b = False
  Repeat
    ev = WaitEvent
    If ev = #IDCMP_CLOSEWINDOW
      WZ_KillTable{"TABELLE"}
      WZCloseWindow WZID("WIN_TABELLE")
      mkt = True
    Else
      dummy = WZ_CheckTableEvent{ev}
    EndIf
  Until mkt
End Macro


;Function.s GTGetString_MOS{lst.l,id.l}
;  *g.Gadget = GTGadPtr(lst,id)
;  *w.Window = Peek.l(Addr Window(Used Window))
;  If *g <> 0
;    ;*g3.StringInfo = *g2\SpecialInfo ; private Data, sollte man nicht machen
;    ;numchars.l = *g3\NumChars        ;
;    strptr.l = 0
;    Dim myTags.TagItem(1)
;    myTags(0)\ti_Tag = #GTST_String
;    myTags(0)\ti_Data = &strptr
;    myTags(1)\ti_Tag = #TAG_DONE
;    dummy.l = GT_GetGadgetAttrsA_(*g,*w,0,&myTags(0))<>0
;    text$ = PeekS(strptr,FLen(strptr))
;  Else
;    text$ = ""
;  EndIf
;  Function Return text$
;End Function


Statement WZ_DrawImage{gadgetid$,image_name$,wx.l,wy.l}
;* draws the given image into the tableframe
;* .
;* gadgetid$   : eindeutiger ID-String, der die Tabelle kennzeichnet; siehe WZ_InitTable()
;* image_name$ : ID-String des anzuzeigenden Images, siehe WZ_AddImage()
;* wx.l        : x-Position innerhalb des Gadgets
;* wy.l        : y-Position innerhalb des Gadgets
 SHARED wztabledata
 CNIF @#max_images<>0
 CNIF #WZ_USE_IMAGES<>0
  If FirstItem(wzimage())
    Repeat
      If wzimage()\Name = image_name$
;        NIBDrawImage{wzimage()\id,#NIB_NORMAL, WZID(gadgetid$),wx,wy}
;      !cout{image_AlphaIsUsed{wzimage()\id}}
        If wzimage()\Height<wztabledata\columnsHeight
           image_BlitMask{wzimage()\id,wx+1,wy+1}
        Else
          image_FancyBlit{wzimage()\id,wx+1,wy+1,wzimage()\Width,wztabledata\columnsHeight-1}
        EndIf
        Statement Return
      EndIf
    Until NOT NextItemFast(wzimage())
  EndIf
 CEND
 CEND
End Statement


Statement WZ_KillImages{gadgetid$}
 CNIF @#max_images<>0
 CNIF #WZ_USE_IMAGES<>0
  If FirstItem(wzimage())
    Repeat
      If wzimage()\table = gadgetid$ Then image_Free{wzimage()\id} : KillItem wzimage()
    Until NOT NextItemFast(wzimage())
    If NOT FirstItem(wzimage()) Then ClearList wzimage()
  EndIf
 CEND
 CEND
End Statement


Function.l WZ_AddImage{gadgetid$,image_name$,fname$}
 CNIF @#max_images<>0
 CNIF #WZ_USE_IMAGES<>0
  If AddLast(wzimage())
    wzimage()\table= gadgetid$
    wzimage()\Name = image_name$
    wzimage()\id = Index(wzimage()) - 1

    If image_Load {wzimage()\id,fname$,0}
      wzimage()\Width = image_GetWidth{wzimage()\id} +1
      wzimage()\Height= image_GetHeight{wzimage()\id } +1
    Else
      KillItem wzimage()
      Function Return False
    EndIf
  EndIf
 CEND
 CEND
End Function


Function.l WZ_ImageHeight{image_name$}
 CNIF @#max_images<>0
  If FirstItem( wzimage())
    Repeat
      If wzimage()\Name = image_name$ Then Function Return wzimage()\Height
    Until NOT NextItemFast(wzimage())
  EndIf
 CEND
End Function


Function.l WZ_ImageWidth{image_name$}
 CNIF @#max_images<>0
  If FirstItem( wzimage())
    Repeat
      If wzimage()\Name = image_name$ Then Function Return wzimage()\Width
    Until NOT NextItemFast(wzimage())
  EndIf
 CEND
End Function


Function.l WZ_RemoveImage{image_name$}
 CNIF @#max_images<>0
 CNIF #WZ_USE_IMAGES<>0
  If FirstItem(wzimage())
    Repeat
      If wzimage()\Name = image_name$
        image_Free{wzimage()\id}
        KillItem wzimage()
      EndIf
    Until NOT NextItemFast(wzimage())
  EndIf
 CEND
 CEND
End Function


Function.s WZ_TrimCellValue{value.s, size.w}
SHARED wztabledata
  *tablewin.Window = WZWindowAddr
  cut_lenz.l = FLen(value)
  If cut_lenz > 0
    While (TextLength_(*tablewin\RPort, &value, cut_lenz) > (size - 4)) AND (cut_lenz > -1)
      cut_lenz - 1
      value = Left$(value,cut_lenz)
    Wend
    Function Return value
  EndIf
End Function


Statement WZ_DrawRow{zeile.w}
SHARED wztabledata, wzrow()
USEPATH wztabledata

  *tablewin.Window = WZWindowAddr

  For j.l = 1 To \maxColumns
    If (zeile <= \maxzeilen) AND (zeile <= \zeilen) AND (\columns\breite[j] > 0)
      sbreite.w = \columns\breite[j]
      a$ = wzrow()\cell[j]

      If j = 1
        sx.w = 0
        wx.w = \LeftEdge
        wy.w = \TopEdge
        ww.w = \Width
        wh.w = \Height
        gh.w = \columnsHeight
      EndIf

      Select \columns\entrytype[j]

        Case #WNE_TEXT
          a$ = WZ_TrimCellValue {a$, sbreite}
          text_height.l = WZYFontsize
          If Left$(a$,4) = "####"

            If text_height < gh Then yadd.l = (gh - text_height) / 2 Else yadd = 0
            wypos.w = wy + (text_height * 1.5) + yadd + gh * (zeile-1)
            !SetLinePattern{*tablewin\RPort,%0101010101010101}                   ;+ zeilenhoehe
            WZ_DrawLine{wx + sx, wypos, wx + sx + sbreite, wypos, wzrow()\FrontPen[j]}
            !SetLinePattern{*tablewin\RPort,-1}

            sx + sbreite
          Else
            If wzrow()\Style[j] > 0
              SetSoftStyle_ *tablewin\RPort,wzrow()\Style[j],AskSoftStyle_(*tablewin\RPort)
            Else
              SetSoftStyle_ *tablewin\RPort,0,AskSoftStyle_(*tablewin\RPort)
            EndIf

            If text_height < gh Then yadd.l = (gh - text_height) / 2 Else yadd = 0
            wypos.w = wy + text_height + yadd + gh * (zeile - 1)

            SetDrMd_ *tablewin\RPort,0

            Select \columns\align[j]
              Case #ALIGN_LEFT
                WZ_DrawText{a$, wx + sx + 4, wypos, wzrow()\FrontPen[j]}
                sx + sbreite

              Case #ALIGN_RIGHT
                sx + sbreite
                tl.l = TextLength_(*tablewin\RPort,&a$,FLen(a$))
                WZ_DrawText{a$, wx + sx - tl, wypos, wzrow()\FrontPen[j]}

              Case #ALIGN_CENTER
                tl.l = (sbreite - TextLength_(*tablewin\RPort,&a$,FLen(a$))) / 2
                WZ_DrawText{a$, wx + sx + tl , wypos,wzrow()\FrontPen[j]}
                sx + sbreite

            End Select
          EndIf

        Case #WNE_IMAGE
          image_width.l = WZ_ImageWidth{a$} : image_height.l = WZ_ImageHeight{a$}
          If image_height < gh Then yadd.l = (gh - image_height) / 2 Else yadd = 0
          wypos.w = wy + WZYFontsize + yadd + gh * (zeile - 1)
          Select \columns\align[j]

            Case #ALIGN_LEFT
              WZ_DrawImage{gadgetid$,a$,wx + sx,wypos}
              sx + sbreite

            Case #ALIGN_RIGHT
              sx + sbreite :
              WZ_DrawImage{gadgetid$,a$,wx + sx - image_width ,wypos}

            Case #ALIGN_CENTER
              tl.l = (sbreite - WZ_ImageWidth{a$}) / 2
              WZ_DrawImage{gadgetid$,a$,wx + sx + tl,wypos}
              sx + sbreite

          End Select


      End Select
    EndIf
  Next j
End Statement


Function.b RestoreTable{gadgetid$}
 SHARED wztabledata,wzrow()

  dir$ = "RAM:T/"
  ClearType wztabledata
  ClearList wzrow()

  result.b = False
  If Exists(dir$ + gadgetid$ + ".data")
    If OpenFile(10,dir$ + gadgetid$ + ".data")
      ReadType 10,wztabledata
      CloseFile 10
      result = True
    EndIf
    If OpenFile(10,dir$ + gadgetid$ + ".content")
      lf.l = Lof(10)
      While Loc(10)<>lf
        If AddLast(wzrow())
          ReadType 10,wzrow()
        EndIf
      Wend
      CloseFile 10
    EndIf
  EndIf
  Function Return result
End Function


Statement SaveTable{gadgetid$}
SHARED wztabledata,wzrow()

  dir$ = "RAM:T/"
  DeleteFile_ dir$ + gadgetid$ + ".data"
  DeleteFile_ dir$ + gadgetid$ + ".content"

  If OpenFile(10,dir$ + gadgetid$ + ".data")
    wztabledata\hasBeenChanged = False
    WriteType 10,wztabledata
    CloseFile 10
  EndIf
  If OpenFile(10,dir$ + gadgetid$ + ".content")
    ResetList wzrow()
    While NextItemFast(wzrow())
      WriteType 10,wzrow()
    Wend
    CloseFile 10
  EndIf

  DefaultOutput
  ClearType wztabledata
  ClearList wzrow()
End Statement



Function.b SetActualTable{gadgetid$}
SHARED wztabledata,wzrow()
USEPATH wztabledata

  result.b = False

  If (gadgetid$ <> \id)
    If (\id <> "")
      If (\isBeingEdited = True)
        *g.Gadget = WZGadAddr(gadgetid$)
        If *g <> 0
          id.l = *g\GadgetID
          If GTGadPtr(\GTListID,0) <> 0
            zeile.w  =  \aktuelle_zeile + (\erste_zeile-1)
            spalte.w =  \aktuelle_spalte
            text$ = GTGetString(\GTListID,0)
            ; workaround fuer MorphOS
;            If text$ = ""
;              text$ = GTGetString_MOS{\GTListID,0}
;            EndIf

            ResetList wzrow()
            While NextItemFast(wzrow())
              If Index(wzrow())-1 = zeile
                If wzrow()\cell[spalte] <> text$
                  wzrow()\cell[spalte] = text$
                  wzrow()\hasBeenChanged = True
                  \hasBeenChanged = True
                EndIf
              EndIf
            Wend
            \isBeingEdited = False
            DetachGTList \GTListID
            Free GTList \GTListID
          EndIf
        Else
          error{"The designated table " + gadgetid$ + " does not exist."}
        EndIf
      EndIf
      If (\hasBeenChanged = True) Then SaveTable{\id}
    EndIf

    result = RestoreTable{gadgetid$}
  Else
    result = True
  EndIf

  If result Then Use Window \window_
  Function Return result
End Function


Statement WZ_SetRowID{gadgetid$,id.l}
SHARED wzrow()
  wzrow()\id = id
End Statement


Function.l WZ_GetRowID{gadgetid$}
SHARED wzrow()
  Function Return wzrow()\id
End Function

Statement WZ_AddRow{gadgetid$,@n1$,@n2$,@n3$,@n4$,@n5$,@n6$,@n7$,@n8$,@n9$}
SHARED wztabledata,wzrow()

  If SetActualTable{gadgetid$}
    Select wztabledata\order
    Case 0 : dummy.l = AddLast(wzrow())
    Case 1 : dummy = AddFirst(wzrow())
    End Select

    If dummy = True
      wzrow()\cell[1] = n1$
      wzrow()\cell[2] = n2$
      wzrow()\cell[3] = n3$
      wzrow()\cell[4] = n4$
      wzrow()\cell[5] = n5$
      wzrow()\cell[6] = n6$
      wzrow()\cell[7] = n7$
      wzrow()\cell[8] = n8$
      wzrow()\cell[9] = n9$

      For i.l = 1 To (#WZ_MAXCOLUMNS - 1)
        wzrow()\FrontPen[i] = wztabledata\FrontPen
        wzrow()\BackPen[i]  = wztabledata\BackPen
      Next i

      wztabledata\maxzeilen + 1
      wztabledata\hasBeenChanged = True
    EndIf
  Else
    error{"Actual table not set!"}
  EndIf
End Statement


Statement WZ_SetTableLines{gadgetid$,vstate.l,@hstate.l}
SHARED wztabledata

;  SetActualTable{gadgetid$}
  wztabledata\vlines = vstate
  wztabledata\hlines = hstate
End Statement


Statement WZ_SetCellPen{gadgetid$,spalte.l,FrontPen.l,BackPen.l,@Style.b}
SHARED wzrow()
  wzrow()\FrontPen[spalte] = FrontPen.l
  wzrow()\BackPen[spalte] = Backpen.l
  wzrow()\Style[spalte] = Style.b
End Statement


Statement WZ_SetRowPen{gadgetid$,FrontPen.l,BackPen.l,@Style.b}
SHARED wzrow()
  If SetActualTable{gadgetid$}
    For i.l = 1 To (#WZ_MAXCOLUMNS - 1)
      If FrontPen<>-1 Then wzrow()\FrontPen[i] = FrontPen
      If BackPen<>-1 Then wzrow()\BackPen[i] = BackPen
      wzrow()\Style[i] = Style.b
    Next i
  EndIf
End Statement



Statement WZ_ClearTable{gadgetid$}
SHARED wztabledata,wzrow()
  If SetActualTable{gadgetid$}
    ClearList wzrow()
    wztabledata\maxzeilen = 0
    wztabledata\hasBeenChanged = True
    wztabledata\erste_zeile = 1
    wztabledata\aktuelle_zeile = 0
  EndIf
End Statement



Statement WZ_InitTable{winid$,gadgetid$,maxColumns.w,@order.w}
;* Initialisiert eine neue Tabelle aus den anzugebenen Daten:
;* .
;* winid$    : der eindeutige ID-String der zu initialisierenden Tabelle
;* gadgetid$ : der Wizard-ID-String des Gadgets, in dem die Tabelle erstellt werden soll
;* maxColumns.w : Anzahl der maxColumns fuer die Tabelle
;* order.w   : Sortierreihenfolge der Eintraege, 0 = von oben nach unten, 1 = andersrum
SHARED wzgui,wztabledata

  DeleteFile_ "ram:t/" + gadgetid$ + ".data"
  DeleteFile_ "ram:t/" + gadgetid$ + ".content"

  If SetActualTable{gadgetid$}
    error{"Table " + Str$(gagetid$) + " already exists!"}
  EndIf

  wztabledata\window_ = WZID(winid$)
  wztabledata\GTListID= WZID(winid$)
  wztabledata\id = gadgetid$
  wztabledata\readOnly = False
  wztabledata\isSortable = True
  wztabledata\hlines = False
  wztabledata\vlines = True

  wztabledata\maxColumns = maxColumns

  wztabledata\erste_zeile = 1
  wztabledata\aktuelle_zeile=  0

  wztabledata\FrontPen = 1;#WZRD_TEXTPEN
  wztabledata\BackPen =  0;#WZRD_BACKGROUNDPEN
  wztabledata\HeaderPen = 2;#WZRD_BARDETAILPEN
  wztabledata\HeaderBackPen = 3;#WZRD_BARBLOCKPEN
  wztabledata\HighlightBackPen = 3;#WZRD_FILLPEN

  If order = -1 Then order = 0
  wztabledata\order = order

  wztabledata\hasBeenChanged = True
  For i.w = 1 To maxColumns.w
    wztabledata\columns\priority[i] = 1
    wztabledata\columns\editable_[i] = False
    wztabledata\columns\title[i] = ""
    wztabledata\columns\entrytype[i] = #WNE_TEXT
  Next i
End Statement


Statement WZ_KillTable{gadgetid$}
SHARED wztabledata,wzrow()
  If SetActualTable{gadgetid$}
    DeleteFile_ "ram:t/" + gadgetid$ + ".data"
    DeleteFile_ "ram:t/" + gadgetid$ + ".content"
    WZ_KillImages{gadgetid$}
    ClearType wztabledata
    ClearList wzrow()
  EndIf
End Statement


Statement WZ_SetTableReadOnly{gadgetid$,ro.w}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    wztabledata\readOnly = ro
    wztabledata\hasBeenChanged = True
  EndIf
End Statement


Statement WZ_SetTableColors{gadgetid$,fp.l,bp.l,@tp.w,@tb.w,@hl.w}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    wztabledata\FrontPen = fp
    wztabledata\BackPen = bp
    If tp<>-1 Then wztabledata\HeaderPen = tp
    If tb<>-1 Then wztabledata\HeaderBackPen = tb
    If hl<>-1 Then wztabledata\HighlightBackPen = hl
    wztabledata\hasBeenChanged = True
  EndIf
End Statement


Statement WZ_SetTableAlign{gadgetid$,@n1.w,@n2.w,@n3.w,@n4.w,@n5.w,@n6.w,@n7.w,@n8.w,@n9.w}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    wztabledata\columns\align[1] = n1
    If n2 <>-1 Then wztabledata\columns\align[2] = n2
    If n3 <>-1 Then wztabledata\columns\align[3] = n3
    If n4 <>-1 Then wztabledata\columns\align[4] = n4
    If n5 <>-1 Then wztabledata\columns\align[5] = n5
    If n6 <>-1 Then wztabledata\columns\align[6] = n6
    If n7 <>-1 Then wztabledata\columns\align[7] = n7
    If n8 <>-1 Then wztabledata\columns\align[8] = n8
  EndIf
End Statement



Statement WZ_SetRowType{gadgetid$,@n1.w,@n2.w,@n3.w,@n4.w,@n5.w,@n6.w,@n7.w,@n8.w,@n9.w}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    wztabledata\columns\entrytype[1] = n1
    If n2<>-1 Then wztabledata\columns\entrytype[2] = n2
    If n3<>-1 Then wztabledata\columns\entrytype[3] = n3
    If n4<>-1 Then wztabledata\columns\entrytype[4] = n4
    If n5<>-1 Then wztabledata\columns\entrytype[5] = n5
    If n6<>-1 Then wztabledata\columns\entrytype[6] = n6
    If n7<>-1 Then wztabledata\columns\entrytype[7] = n7
    If n8<>-1 Then wztabledata\columns\entrytype[8] = n8
  EndIf
End Statement


Statement WZ_SetTableTitle{gadgetid$,@n1$,@n2$,@n3$,@n4$,@n5$,@n6$,@n7$,@n8$,@n9$}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    wztabledata\columns\title[1] = n1$
    wztabledata\columns\title[2] = n2$
    wztabledata\columns\title[3] = n3$
    wztabledata\columns\title[4] = n4$
    wztabledata\columns\title[5] = n5$
    wztabledata\columns\title[6] = n6$
    wztabledata\columns\title[7] = n7$
    wztabledata\columns\title[8] = n8$
  EndIf
End Statement


Statement WZ_SetTableOrder{gadgetid$,order.w}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    wztabledata\order = order
  EndIf
End Statement


Statement WZ_SetSortable{gadgetid$,mode.b}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    wztabledata\isSortable = mode
  EndIf
End Statement


Statement WZ_SetPriority{gadgetid$,@n1.w,@n2.w,@n3.w,@n4.w,@n5.w,@n6.w,@n7.w,@n8.w,@n9.w}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    If n1<>-1 Then wztabledata\columns\priority[1] = n1
    If n2<>-1 Then wztabledata\columns\priority[2] = n2
    If n3<>-1 Then wztabledata\columns\priority[3] = n3
    If n4<>-1 Then wztabledata\columns\priority[4] = n4
    If n5<>-1 Then wztabledata\columns\priority[5] = n5
    If n6<>-1 Then wztabledata\columns\priority[6] = n6
    If n7<>-1 Then wztabledata\columns\priority[7] = n7
    If n8<>-1 Then wztabledata\columns\priority[8] = n8
    If n9<>-1 Then wztabledata\columns\priority[9] = n9
  EndIf
End Statement


Statement WZ_SetEditable{gadgetid$,@n1.w,@n2.w,@n3.w,@n4.w,@n5.w,@n6.w,@n7.w,@n8.w,@n9.w}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    wztabledata\columns\editable_[1] = n1
    wztabledata\columns\editable_[2] = n2
    wztabledata\columns\editable_[3] = n3
    wztabledata\columns\editable_[4] = n4
    wztabledata\columns\editable_[5] = n5
    wztabledata\columns\editable_[6] = n6
    wztabledata\columns\editable_[7] = n7
    wztabledata\columns\editable_[8] = n8
    wztabledata\columns\editable_[9] = n9
  EndIf
End Statement


Function.l WZ_GetNumberOfEntries{gadgetid$}
SHARED wztabledata

  If SetActualTable{gadgetid$}
    Function Return wztabledata\maxzeilen
  Else
    Function Return 0
  EndIf
End Function


Function.s WZ_GetCell{gadgetid$,zeile.l,spalte.l}
SHARED wzrow()
  If (zeile > 0) AND (spalte > 0)
    SetActualTable{gadgetid$}
    ResetList wzrow()
    While NextItemFast(wzrow())
      If Index(wzrow())-1 = zeile
        Function Return wzrow()\cell[spalte]
      EndIf
    Wend
  EndIf
End Function


Function.b WZ_SetCell{gadgetid$,zeile.l,spalte.l,wert$}
SHARED wztabledata,wzrow()
  If SetActualTable{gadgetid$}
    ResetList wzrow()
    While NextItemFast(wzrow())
      If Index(wzrow())-1 = zeile
        If wzrow()\cell[spalte] <> wert$
          wzrow()\cell[spalte] = wert$
          wzrow()\hasBeenChanged = True
          wztabledata\hasBeenChanged = True
          Function Return True
        EndIf
      EndIf
    Wend
  EndIf
End Function

Statement WZ_EditExit{gadgetid$}
SHARED wztabledata

  SetActualTable{gadgetid$}

  If wztabledata\isBeingEdited = True
    *g.Gadget = WZGadAddr(gadgetid$)
    If *g
      id.l = *g\GadgetID
      zeile.w  = wztabledata\aktuelle_zeile
      spalte.w = wztabledata\aktuelle_spalte
      text$ = GTGetString(wztabledata\GTListID,0)
      ; workaround fuer MorphOS
      ; If text$ = ""
      ;   text$ = GTGetString_MOS{wztabledata\GTListID,0}
      ; EndIf
      ;
      z.b = WZ_SetCell{gadgetid$,zeile,spalte,text$}
      wztabledata\isBeingEdited = False
      DetachGTList wztabledata\GTListID
      Free GTList wztabledata\GTListID
    EndIf
  EndIf
End Statement


Statement WZ_SetActiveRow{gadgetid$,zeile.l}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    wztabledata\aktuelle_zeile = zeile
  EndIf
End Statement


Statement WZ_SetActiveColumn{gadgetid$,spalte.l}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    wztabledata\aktuelle_spalte = spalte
  EndIf
End Statement


Function.b WZ_RowChanged{gadgetid$,zeile.l}
SHARED wzrow()
  If SetActualTable{gadgetid$}
    ResetList wzrow()
    While NextItemFast(wzrow())
      If Index(wzrow())-1 = zeile
        If wzrow()\hasBeenChanged = True Then Function Return True
      EndIf
    Wend
  EndIf
End Function


Function.w WZ_Row{gadgetid$}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    If (wztabledata\aktuelle_zeile>0) AND (NOT wztabledata\readOnly)
      l.l = wztabledata\aktuelle_zeile
      If l > wztabledata\maxzeilen Then l = 0
      Function Return l
    Else
      Function Return 0
    EndIf
  EndIf
End Function


Function.w WZ_Column{gadgetid$}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    If NOT wztabledata\readOnly
      Function Return wztabledata\aktuelle_spalte
    EndIf
  EndIf
End Function


Function.w WZ_RelativeRow{gadgetid$}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    If (wztabledata\aktuelle_zeile>0) AND (NOT wztabledata\readOnly)
      l.l = wztabledata\aktuelle_zeile
      If l > wztabledata\maxzeilen Then l = 0
      Function Return l
    Else
      Function Return 0
    EndIf
  EndIf
End Function



Function.w WZ_MouseRow{gadgetid$,mx.w,my.w}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    *gad.Gadget = WZGadAddr(gadgetid$)
    If *gad
      wx.l = wztabledata\LeftEdge
      wy.l = wztabledata\TopEdge
      ww.l = wztabledata\Width
      wh.l = wztabledata\Height
      If (mx > wx) AND (mx<(wx + ww)) AND (my>wy) AND (my<(wy+wh))
        gh.l = wztabledata\columnsHeight
        If my < (wy + WZYFontsize)
          row.w = 0
        Else
          row.w = (wztabledata\erste_zeile-1) + Int( (my - (wy+WZYFontsize))) / gh + 1
        EndIf
        Function Return row
      Else
        Function Return 0
      EndIf
    Else
      Function Return 0
    EndIf
  EndIf
End Function


Function.w WZ_MouseColumn{gadgetid$,mx.w,my.w}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    *gad.Gadget = WZGadAddr(gadgetid$)
    If *gad<>0
      wx.l = wztabledata\LeftEdge
      wy.l = wztabledata\TopEdge
      ww.l = wztabledata\Width
      wh.l = wztabledata\Height
      x.l = wx
      If (mx > wx) AND (mx<(wx+ww)) AND (my>wy) AND (my<(wy+wh))
        For j.l = 1 To wztabledata\maxColumns
          x + wztabledata\columns\breite[j]
          If (mx < x) Then Function Return j
        Next j
      Else
        Function Return 0
      EndIf
    Else
      Function Return 0
    EndIf
  EndIf
End Function


Statement WZ_ImageScaleOff{gadgetid$}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    wztabledata\scale_images = Off
  EndIf
End Statement

Statement WZ_ImageScaleOn{gadgetid$}
SHARED wztabledata
  If SetActualTable{gadgetid$}
    wztabledata\scale_images = On
  EndIf
End Statement


Statement WZ_DrawTable{gadgetid$}
SHARED wztabledata,liste$()
USEPATH wztabledata

  SetActualTable{gadgetid$}

  If FirstItem(wzimage())
    Repeat
      If wzimage()\table = gadgetid$
        If \columnsHeight < wzimage()\Height Then \columnsHeight = wzimage()\Height + 2
      EndIf
    Until NOT NextItemFast(wzimage())
  EndIf
                                                                                                                                                                                                                                                     
  If \scale_images = Off
    If \columnsHeight < WZYFontsize + 2 Then \columnsHeight = WZYFontsize + 2
  Else
    \columnsHeight = WZYFontsize + 2
  EndIf

  Use Window \window_

  *tablewin.Window = WZWindowAddr

  *g.Gadget = WZGadAddr(gadgetid$)
  If *g
    \LeftEdge = *g\LeftEdge + 1
    \TopEdge  = *g\TopEdge + 1
    \Width    = *g\Width  - 3
    \Height   = *g\Height - 1
    \GadgetID = *g\GadgetID

    zeilenhoehe.l = WZYFontsize
    If zeilenhoehe > 72
      zeilenhoehe = *tablewin\IFont\tf_YSize
      error{"There was a problem with WZYFontSize.\\nThis problem is related to AFA_OS.\\nApplication may fail."}
    EndIf

    WZ_EditExit{gadgetid$} ; sichern evtl. gemachter Eingaben im Gadget

    If \columnsHeight <> 0
      \zeilen = (\Height - zeilenhoehe) / (\columnsHeight)
    Else
      error{"There has been an error while processing WZ_DrawTable(). columnsHeight is 0."}
      Statement Return
    EndIf

    ;breite = \Width / \maxColumns

    gesamtp.l = 0
    For p.l = 1 To \maxColumns
      If \columns\entrytype[p] = #WNE_TEXT Then gesamtp + \columns\priority[p]
    Next p

    For p.l = 1 To \maxColumns
      If \columns\entrytype[p] = #WNE_IMAGE
        If FirstItem( wzimage())
          image_width.l = 0
          Repeat
            If image_width < wzimage()\Width Then image_width = wzimage()\Width
          Until NOT NextItemFast(wzimage())
        EndIf
        image_width + 2
        \columns\breite[p] = image_width

      EndIf
    Next p

    ;-- calculate the width of each column in relation to its priority and the width of the spacer
    table_width.l = \Width - image_width
    If gesamtp > 0
      For p.l = 1 To \maxColumns
        If \columns\entrytype[p] = #WNE_TEXT
          anteil.q = \columns\priority[p] / gesamtp
          \columns\breite[p] = anteil * table_width
        EndIf
      Next p
    EndIf

    WZ_DrawRect{\LeftEdge,\TopEdge     ,\LeftEdge+\Width,\TopEdge+\Height-2,\BackPen}
    WZ_DrawRect{\LeftEdge,\TopEdge     ,\LeftEdge+\Width,\TopEdge + zeilenhoehe,\HeaderBackPen}
    WZ_DrawLine{\LeftEdge, \TopEdge+zeilenhoehe, @@
                  \LeftEdge + \Width, @@
                  \TopEdge + zeilenhoehe,1}
    GTGZZPosition On
    WJam 0
    sx.w = 0

    For x.l = 1 To \maxColumns
      If \columns\breite[x] > 0
        a$ = \columns\title[x]
        sbreite.w = \columns\breite[x]

        ; Zeichnen des Sortiersymbols in der Titelzeile
        SetDrMd_ *tablewin\RPort, 0
        If \sorted_by = x
          If \columns\align[x] = #ALIGN_LEFT
            lw.w = 8
            lx.l = \LeftEdge + sx + sbreite - 8
          Else
            lw.w = 8
            lx.l = \LeftEdge + sx + 4
          EndIf
          ly.l = 1 + \TopEdge + zeilenhoehe * zeile.w
          lh.w = zeilenhoehe - 3
          WZ_DrawRect  {lx-1,ly, lx+lw,ly+lh,0}
          WZ_DrawLineEx{lx-1,ly,  lx+(lw/2)-1,ly+lh, lx-1+lw,ly,  2}
          WZ_DrawLineEx{lx  ,ly,  lx+(lw/2)  ,ly+lh, lx  +lw,ly, 1}
        EndIf

        ; Zeichnen der Titelnamen
        SetSoftStyle_ *tablewin\RPort,2,AskSoftStyle_(*tablewin\RPort)

        a$ = WZ_TrimCellValue{a$, sbreite}
        Select \columns\align[x]
        Case #ALIGN_LEFT
          WZ_DrawText{a$, \LeftEdge + sx + 4, \TopEdge + zeilenhoehe * zeile.w , \HeaderPen}
          sx + sbreite
        Case #ALIGN_RIGHT
          sx + sbreite : tl.l = WZ_GetTextLength{a$} + 4
          WZ_DrawText{a$, \LeftEdge + sx - tl , \TopEdge + zeilenhoehe * zeile,\HeaderPen}
        Case #ALIGN_CENTER
          tl.l = (sbreite - WZ_GetTextLength{a$}) / 2
          WZ_DrawText{a$, \LeftEdge + sx + tl , \TopEdge + zeilenhoehe * zeile,\HeaderPen}
          sx + sbreite
        End Select

        ; zeichne titeltrennlinien
        If x<\maxColumns
          WZ_DrawLine{\LeftEdge + sx    , \TopEdge, \LeftEdge + sx    , \TopEdge+zeilenhoehe,1}
          WZ_DrawLine{\LeftEdge + sx + 1, \TopEdge, \LeftEdge + sx + 1, \TopEdge+zeilenhoehe,2}
        EndIf
      Else
        ; width of column is zero!!
      EndIf
    Next x

    SetSoftStyle_ *tablewin\RPort,0, AskSoftStyle_(*tablewin\RPort)
    WJam 1
    If \vlines = False Then linesh.l = zeilenhoehe+ 1 Else linesh = \Height
    sx = \columns\breite[1]
    For x.l = 2 To \maxColumns
      If \columns\breite[x]>0
        sbreite = \columns\breite[x]
        !SetLinePattern{*tablewin\RPort,%0101010101010101}                   ;+ zeilenhoehe
        WZ_DrawLine{\LeftEdge + sx    , \TopEdge + zeilenhoehe, \LeftEdge + sx    , \TopEdge+linesh - 2,1}
        !SetLinePattern{*tablewin\RPort,-1}
        sx + sbreite
      EndIf
    Next x

    \isOpen = True
  EndIf
End Statement





Statement WZ_HighlightRow{gadgetid$,zeile.w}
 SHARED wztabledata,wzrow()
 DEFTYPE.w sx,sbreite

  *bgad.Gadget = WZGadAddr(gadgetid$)
  If *bgad > 0
    Use Window wztabledata\window_
    wx.l = wztabledata\LeftEdge
    wy.l = wztabledata\TopEdge
    ww.l = wztabledata\Width
    wh.l = wztabledata\Height
    gh.l = wztabledata\columnsHeight

    *tablewin.Window = WZWindowAddr

    zeile = zeile - (wztabledata\erste_zeile-1)
    If (zeile > 0) AND (zeile <= wztabledata\zeilen) AND (zeile<=wztabledata\maxzeilen) AND (wztabledata\readOnly = False)
      gy.q = WZYFontsize + (zeile-1) * gh

      WZ_DrawRect{wx,wy + gy + 1 ,wx + ww,wy+gy + gh-1,wztabledata\HighlightBackPen}

      If wztabledata\vlines = True
        sx  = wztabledata\columns\breite[1]
        For j.l = 2 To wztabledata\maxColumns
          If wztabledata\columns\breite[j]>0
            sbreite = wztabledata\columns\breite[j]
            !SetLinePattern{*tablewin\RPort,%0101010101010101}
            WZ_DrawLine{wx + sx  ,wy + gy, wx + sx  ,wy + gy + gh,1}
            !SetLinePattern{*tablewin\RPort,-1}
            sx + sbreite
          EndIf
        Next j
      EndIf

      wy + WZYFontsize + 2 ; direkt unter der Titelzeile anfangen
      ResetList wzrow()
      While NextItemFast(wzrow())
        If (Index(wzrow())) = (wztabledata\erste_zeile + zeile)
          WZ_DrawRow{zeile}
          Pop While : Goto uquit
        EndIf
      Wend

    uquit:
    EndIf
  EndIf
End Statement




Statement WZ_UpdateTable{gadgetid$}
SHARED wztabledata,wzrow()

  SetActualTable{gadgetid$} : Use Window wztabledata\window_

  *g.Gadget = WZGadAddr(gadgetid$)
  If (*g <> 0) ;AND (Index(wzrow())>0)
    *tablewin.Window = WZWindowAddr

    WZPrint gadgetid$+"_SCROLLER",wztabledata\erste_zeile - 1,wztabledata\zeilen  ; ,wztabledata\maxzeilen-1
    If wztabledata\maxzeilen = 0
      dummy.b = SetGadgetAttrsA_(WZGadAddr(gadgetid$+"_SCROLLER"),WZWindowAddr,0,Tags(#WSCROLLERA_Total,1))
    Else
      dummy = SetGadgetAttrsA_(WZGadAddr(gadgetid$+"_SCROLLER"),WZWindowAddr,0,Tags(#WSCROLLERA_Total,wztabledata\maxzeilen))
    EndIf

    WZ_DrawRect{wztabledata\LeftEdge,wztabledata\TopEdge + WZYFontsize + 1,wztabledata\LeftEdge + wztabledata\Width-1,wztabledata\TopEdge+wztabledata\Height-2, wztabledata\BackPen}

    hline_color.l = 1 ; GetBestPen{ GetRGBValue{wztabledata\BackPen} * 2 }
    If wztabledata\hlines = True
      For y.w = 1 To wztabledata\zeilen
        !SetLinePattern{*tablewin\RPort,%0101010101010101}
        WZ_DrawLine{wztabledata\LeftEdge, wztabledata\TopEdge + WZYFontsize + y * wztabledata\columnsHeight, wztabledata\LeftEdge+wztabledata\Width,wztabledata\TopEdge+WZYFontsize + y*wztabledata\columnsHeight,hline_color}
        !SetLinePattern{*tablewin\RPort,-1}
      Next y
    EndIf
    If wztabledata\vlines = True
      sx.w = wztabledata\columns\breite[1]
      For x.l = 2 To wztabledata\maxColumns
        If wztabledata\columns\breite[x]>0
          sbreite.w = wztabledata\columns\breite[x]
          !SetLinePattern{*tablewin\RPort,%0101010101010101}
          WZ_DrawLine{wztabledata\LeftEdge + sx    , wztabledata\TopEdge, wztabledata\LeftEdge + sx    , wztabledata\TopEdge+wztabledata\Height-1,1}
          !SetLinePattern{*tablewin\RPort,-1}
          sx + sbreite
        EndIf
      Next x
    EndIf

    ; bis zum darstellbaren Bereich gehen
    ResetList wzrow()
    Repeat
      dummy = NextItemFast(wzrow())
    Until (Index(wzrow())-1 = wztabledata\erste_zeile) OR (dummy = False)

    ; Darstellbaren Bereich der Tabelle malen
    zeile.w = 1
    Repeat
      sx = 0
      WZ_DrawRow{zeile}
      If zeile+wztabledata\erste_zeile-1 = wztabledata\aktuelle_zeile
        PushItem wzrow()
        WZ_HighlightRow{gadgetid$,zeile+wztabledata\erste_zeile-1}
        PopItem wzrow()
      EndIf
      zeile + 1
      dummy.b = NextItemFast(wzrow())
    Until (zeile > wztabledata\zeilen) OR (dummy = False)

  EndIf
End Statement







Statement WZ_EditCell{gadgetid$,zeile.l,spalte.l}
SHARED wztabledata,wzrow()

  If (zeile>0) AND (zeile<=wztabledata\maxzeilen) AND (NOT wztabledata\readOnly);  AND (NOT wztabledata\isBeingEdited)
    *bgad.Gadget = WZGadAddr(gadgetid$)
    If *bgad > 0
      Use Window wztabledata\window_

      wx.l = wztabledata\LeftEdge
      wy.l = wztabledata\TopEdge
      ww.l = wztabledata\Width
      wh.l = wztabledata\Height
      gh.l = wztabledata\columnsHeight
      id.l = wztabledata\GadgetID

      If (zeile > 0)
        For j.l = 1 To spalte - 1
          sx.w + wztabledata\columns\breite[j]
        Next j
        gn$ = WZ_GetCell{gadgetid$,zeile,spalte}
        breite.l = ww / wztabledata\maxColumns
        wypos.l  = wy + WZYFontsize + gh * (zeile-wztabledata\erste_zeile)
        gapx.l   = -2
        *gad.Gadget = GTString(wztabledata\GTListID,0,wx + sx + gapx, wypos ,wztabledata\columns\breite[spalte]+6,gh+1,"",0,64,gn$)
        If *gad<>0
          *gad\GadgetRender = False
          AttachGTList wztabledata\GTListID,wztabledata\window_
          ; workaround for MorphOS, to erase the gadgetborder again, as gadgetRender=False does not work there
          If (ExecVersion > 40)
            WZ_DrawRect{wx + sx + 2, wypos+1,wztabledata\columns\breite[spalte]+wx+sx - 1,wypos + gh-1,wztabledata\BackPen}
          EndIf
          GTActivateGadget wztabledata\GTListID,0
          wztabledata\isBeingEdited = True
          wztabledata\aktuelle_spalte = spalte
          wztabledata\aktuelle_zeile  = zeile
        EndIf
      EndIf
    EndIf
  EndIf
End Statement


Statement WZ_TableSort{gadgetid$,column.w}
SHARED wztabledata, wzrow()

  SetActualTable{gadgetid$}
  StringSort wzrow(),SizeOf.wzrow,6 + column * 4
End Statement



Function.l WZ_CheckTableEvent{ev.l,@ev_win.l}
SHARED wztabledata,wzrow(),wzold_row

  If ev_win = -1 Then ev_win = EventWindow
  If ev_win < 0 Then Function Return 0

  Use Window ev_win

   ; patch fuer AB2/elmorelib, um WZ_Tools auch in AB2 verwenden zu koennen
  CNIF @#WZ_singletable = 0
    found.b = False
    If (EventWindow <> wztabledata\window_) AND (ev<>#IDCMP_GADGETHELP)
      ChDir "ram:T" : found = False
      While (MoreEntries = True) AND (found = False)
        gadgetid$ = EntryName$
        If Right$(gadgetid$,8) = ".content"
          gadgetid$ = Replace$(gadgetid$,".content","")
          SetActualTable{gadgetid$}
          If EventWindow = wztabledata\window_ Then found = True
        EndIf
      Wend
    Else
      found.b = True
      gadgetid$ = wztabledata\id
    EndIf
  CELSE
    If (EventWindow = wztabledata\window_)  AND (ev<>#IDCMP_GADGETHELP)
      found.b = True
      gadgetid$ = wztabledata\id
    EndIf
  CEND

  If found AND (wztabledata\window_>0)
    mb.l = MButtons
    Select ev
    Case #IDCMP_NEWSIZE
      WZ_DrawTable{wztabledata\id}
      WZ_UpdateTable{wztabledata\id}
;      If wztabledata\aktuelle_zeile > 0
;        WZ_HighlightRow{gadgetid$,wztabledata\erste_zeile + wztabledata\aktuelle_zeile - 1}
;      EndIf
      Function Return ev
                                                                                                                                                                                                                                        
    Case #IDCMP_RAWKEY
        *w.Window = WZWindowAddr
        v.w = *w\MessageKey\Code
        v2.w = *w\MessageKey\Qualifier + 32768
        If (v2 = #IEQUALIFIER_LSHIFT) OR (v2 = #IEQUALIFIER_RSHIFT) Then shift.b = True
;        DefaultOutput
;        NPrint Hex$(v2)
        row.w = wztabledata\aktuelle_zeile
        col.w = wztabledata\aktuelle_spalte
        zei.w = wztabledata\erste_zeile
        Select v
        Case #CURSORUP
          If NOT shift
            If row > (wztabledata\erste_zeile)
              row - 1
            Else
              If wztabledata\erste_zeile > 1
                wztabledata\erste_zeile - 1
                row - 1
              EndIf
            EndIf
          Else
            wztabledata\erste_zeile = 1
            row = 1
          EndIf
        ;  WZ_UpdateTable{gadgetid$}
        ;  wztabledata\aktuelle_zeile = row
        ;  wztabledata\aktuelle_spalte = col
        ;  WZ_HighlightRow{gadgetid$,wztabledata\aktuelle_zeile}
        ;  Function Return ev
        Case #CURSORDOWN
          If NOT shift
            !WZ_VerifyVisibility{row}
          Else
            wztabledata\erste_zeile = wztabledata\maxzeilen - wztabledata\zeilen + 1
            row = wztabledata\maxzeilen
          EndIf
        End Select
        If (wztabledata\aktuelle_zeile <> row) OR (wztabledata\aktuelle_spalte <> col) OR (wztabledata\erste_zeile <> zei)
          WZ_SetActiveRow{gadgetid$,row}
          WZ_SetActiveColumn{gadgetid$,col}
          WZ_UpdateTable{gadgetid$}
          Function Return #WZTABLEEVENT_CELLSELECTED
        EndIf

    Case #IDCMP_VANILLAKEY
      row.w = wztabledata\aktuelle_zeile
      col.w = wztabledata\aktuelle_spalte
      zei.w = wztabledata\erste_zeile

      tabkey$ = Chr$(EventCode)
      ResetList wzrow()
      While NextItemFast(wzrow()) AND Index(wzrow())-1<wztabledata\aktuelle_zeile
      Wend
      While NextItemFast(wzrow())
        r$ = wzrow()\cell[1]
        If Left$(r$,1) = tabkey$
          row = Index(wzrow()) - 1
          If row - wztabledata\erste_zeile => wztabledata\zeilen
            wztabledata\erste_zeile = row - wztabledata\zeilen + 1
          EndIf
          Goto exit_vanilla
        EndIf
      Wend
      exit_vanilla:
      If (wztabledata\aktuelle_zeile <> row) OR (wztabledata\aktuelle_spalte <> col) OR (wztabledata\erste_zeile <> zei)
        WZ_SetActiveRow{gadgetid$,row}
        WZ_SetActiveColumn{gadgetid$,col}
        WZ_UpdateTable{gadgetid$}
        Function Return #WZTABLEEVENT_CELLSELECTED
      EndIf


    Case #IDCMP_IDCMPUPDATE
      If (WZGadHit<>-1) AND (WZGadHit<>255) AND (ev<>#IDCMP_GADGETHELP)
        If WZGadName = gadgetid$ + "_SCROLLER"
          WZ_EditExit{gadgetid$}

          ;-- I do not know, what this code was meant for !!
          ;Repeat
          ;  ev2.l = WaitEvent : VWait
          ;Until (ev2 <> #IDCMP_DELTAMOVE) AND (ev2<>#IDCMP_MOUSEMOVE)
          ;FlushEvents

          ; workaround: WZInput sometimes returns incredible high values
          If WZInput <= wztabledata\maxzeilen
            If (WZInput + 1) <>  wztabledata\erste_zeile Then wztabledata\erste_zeile = WZInput + 1
            WZ_SetActiveRow{gadgetid$,wztabledata\erste_zeile}
            WZ_UpdateTable{gadgetid$}
;            WZ_HighlightRow{gadgetid$,wztabledata\aktuelle_zeile}
            Function Return #WZTABLEEVENT_CELLSELECTED
          EndIf
        Else
          ; EditExit, falls waehrend der Editierung Editieren deaktivert wird
          If wztabledata\isBeingEdited = True
            For i.l = 1 To wztabledata\maxColumns
              j.l + wztabledata\columns\editable_[i]
            Next i
            If j = 0
              WZ_EditExit{gadgetid$}
              WZ_UpdateTable{gadgetid$}
;              WZ_HighlightRow{gadgetid$,wztabledata\aktuelle_zeile}
              Function Return #WZTABLEEVENT_CELLSELECTED
            EndIf
          EndIf
        EndIf
      EndIf
    Case #IDCMP_GADGETUP ; pruefen welches Ereignis das GTString beendet hat: TAB oder ENTER, ..
      If (GadgetHit = 0) AND (ev<>#IDCMP_GADGETHELP)    ; GTString-gadget
        WZ_EditExit{gadgetid$}
        *w.Window = WZWindowAddr
        v.w = *w\MessageKey\Code
        w.w = *w\MessageKey\Qualifier
        row = wztabledata\aktuelle_zeile
        col = wztabledata\aktuelle_spalte

        Select v
        Case $9 ; TAB
          found = False
          Repeat
            Repeat
              col + 1
            Until (wztabledata\columns\editable_[col] = True) OR (col>wztabledata\maxColumns)

            If (wztabledata\columns\editable_[col] = False) OR (col>wztabledata\maxColumns)
              If col => wztabledata\maxColumns
                If row = wztabledata\zeilen
                  If row = wztabledata\maxzeilen
                    row = 1
                    col = 0
                    wztabledata\erste_zeile = 1
                  Else
                    col = 0
                    wztabledata\erste_zeile + 1
                  EndIf
                Else
                  If row = wztabledata\maxzeilen
                    row = 1
                    col = 0
                    wztabledata\erste_zeile = 1
                  Else
                    row + 1
                    col = 0
                  EndIf
                EndIf
              EndIf
            Else
              found = True
            EndIf
          Until found = True

          WZ_UpdateTable{gadgetid$}
          wztabledata\aktuelle_zeile = row
          wztabledata\aktuelle_spalte = col
;          WZ_HighlightRow{gadgetid$,row}
;          If wztabledata\columns\editable_[col] = True Then WZ_EditCell{gadgetid$,row, col}
        Default
          WZ_UpdateTable{gadgetid$}
          wztabledata\aktuelle_zeile = 0;row
          wztabledata\aktuelle_spalte = 0;col
        End Select
        Function Return #WZTABLEEVENT_CELLSELECTED
      EndIf

    Case #IDCMP_MOUSEBUTTONS
;        Use Window wztabledata\window_
      mx.w = WMouseX : my.w = WMouseY
      row = WZ_MouseRow{gadgetid$,mx,my}
      column.w = WZ_MouseColumn{gadgetid$,mx,my}
      If (row > 0) AND (column>0) AND (row <= wztabledata\maxzeilen)

        If wztabledata\isBeingEdited=True
;          WZ_EditExit{gadgetid$}
          wztabledata\isBeingEdited = False
          DetachGTList wztabledata\GTListID
          Free GTList wztabledata\GTListID
        EndIf
        If (wztabledata\aktuelle_spalte<>column) OR (wztabledata\aktuelle_zeile<>row)
          WZ_SetActiveRow{gadgetid$,row}
          WZ_SetActiveColumn{gadgetid$,column}
          WZ_UpdateTable{gadgetid$}


          If wztabledata\columns\editable_[column] = True
            WZ_EditCell{gadgetid$,row,column}
          EndIf
          FlushEvents
          ;Function Return ev
        Else

          Select mb
          Case 6 ; Right, up
            If NOT wztabledata\columns\editable_[column]
              If row = wztabledata\aktuelle_zeile
                WZ_EditExit{gadgetid$}
                a.b = WZ_PopUp{SMouseX-4,SMouseY-8}
                If a = 0
                  wztabledata\selected_popup = 0
                  Function Return False
                Else
                  wztabledata\selected_popup = a
                  Function Return #WZTABLEEVENT_POPUPMENU
                EndIf
              Else
                Function Return False
              EndIf
            EndIf
          Default
            If wztabledata\columns\editable_[column] Then WZ_EditExit{gadgetid$}
          End Select
        EndIf

        If EventDoubleclick
          If wzold_row = row
            Function Return #WZTABLEEVENT_DOUBLECLICK
          EndIf
        Else
          If row < > 0 Then wzold_row = row
          Function Return #WZTABLEEVENT_CELLSELECTED
        EndIf

      Else
        If (row = 0) AND (wztabledata\isSortable = True)
          wztabledata\sorted_by = column
          WZ_TableSort{gadgetid$,column}
          WZ_DrawTable{gadgetid$}
          WZ_UpdateTable{gadgetid$}
        EndIf
      EndIf
    End Select
  EndIf
  Function Return False
End Statement


; ======================================================================================================================
CNIF #__include = 0
!WZ_CheckLibrary

WBStartup ;: NoCli
WbToScreen 0 : Use Screen 0 : ScreenToFront_ 0
RunErrsOff
WZLoadGUI ?wzgui
RunErrsOn

;-- show a simple progress bar without actually doing something...
Goto skip
WZ_ShowMessage{"Initiation in progress !",1}
For i.l = 1 To 100
  !WZ_Update_Gauge{i,100}
  VWait 1
Next i
WZ_HideMessage{}
skip:

;-- open the wzgui-window, centered to the screen
WZWindow WZID("WIN_TABELLE"),?wzgui,64,ScreenWidth/4,ScreenHeight/4,ScreenWidth/2,ScreenHeight/2,WZID("WIN_TABELLE")

;-- use the font that is set in th wizardfile
WZ_SetFont{"WIN_TABELLE"}

;-- init a new table for use in the spacer named "TABELLE" that was defined in window "WIN_TABELLE" in wzgui
;-- the table shall have 5 columns, the sorting shall be normal (0), backwards would be (1)
WZ_InitTable{"WIN_TABELLE","TABELLE",5,0}

;-- set alignment for each column
WZ_SetTableAlign{"TABELLE",#ALIGN_LEFT,#ALIGN_CENTER,#ALIGN_RIGHT,#ALIGN_RIGHT,#ALIGN_LEFT}

;-- enable drawing of separation lines
WZ_SetTableLines{"TABELLE",On,On}

;-- setting colors
; Vordergrundfarbe 1
; Hintergrundfarbe 0
; Titelvordergrund
; Titelhintergrund
; Auswahlleiste
;WZ_SetTableColors{"TABELLE",2,4,1,5,6}

; Setzen der Spaltentitel fuer die erste Zeile
WZ_SetTableTitle{"TABELLE","Name","Type","Size","Bits","Comment"}

; Legt die Prioritaet der 6 maxColumns fest
WZ_SetPriority{"TABELLE",3,1,1,2,2}

; Setzt die zweite Spalte der Tabelle "TABELLE" auf nicht editierbar
WZ_SetEditable{"TABELLE",True,False,False,False,False}

; Setzt die Tabelle auf nur lesbar, auch nicht anklickbar
;WZ_SetTableReadOnly{"TABELLE",True}

; Setzt fuer die zweite Spalte ein Image als Inhalt fest
; Standardmaessig wird #WNE_TEXT als Inhalt gesetzt
WZ_SetRowType{"TABELLE",#WNE_TEXT,#WNE_IMAGE}

; Laedt zwei Images ein, die der Tabelle "TABELLE" zugeordnet werden
WZ_AddImage{"TABELLE","Dir" ,"ram:env/sys/def_drawer"}
WZ_AddImage{"TABELLE","File","ram:env/sys/def_ascii"}

; Fuegt Zeilen an die Tabelle "TABELLE" an
ChDir "sys:" : a.l = 0
While MoreEntries
  a + 1
  If EntryDIR Then d$ ="Dir" Else d$ = "File"
  WZ_AddRow{"TABELLE",EntryName$,d$,Str$(EntrySize),EntryBits$,"####"};EntryComment$}
Wend

;-- enables scaling of images
;WZ_ImageScaleOn{"TABELLE"}
                                                                                                                                                                                                                               
; Malt die leere Tabelle in das WZGadget "TABELLE"
WZ_DrawTable{"TABELLE"}

; Fuellt die Tabelle mit den Werten, die mit WZAddRow{} erstellt wurden
WZ_UpdateTable{"TABELLE"}

;erstellt die Menueintraege f|r das zeilenabhaengige popupmenu
;wird die zeile weggelassen, ist das menu deaktiviert...
; das Menu kann zur Laufzeit geaendert werden
WZ_SetPopUpMenu{"Testmenu" + Chr$(10) + "row1" + Chr$(10) + "row2"}

;
; main loop
;
exit.b = False
Repeat
  ev.l = WaitEvent

  ; close bubblehelp of open
  If (ev <> #IDCMP_INTUITICKS) AND (ev <> #IDCMP_ACTIVEWINDOW)
    WZ_HideBubble{}
  EndIf

  Select ev
    Case #IDCMP_CLOSEWINDOW
      Select EventWindow

        Case WZID("WIN_TABELLE")
          exit = True

        Case WZID("WIN_TABELLE2")
          WZ_KillTable{"TABELLE2"}
          WZCloseWindow WZID("WIN_TABELLE2")
          WZ_UnlockWindow{"WIN_TABELLE"}
          tabelle_offen.b = False
      End Select

    Case #IDCMP_GADGETHELP
      WZ_ShowBubble{}

    Case #IDCMP_IDCMPUPDATE
;      Goto skipall
      Use Window EventWindow
      Select EventWindow

        Case WZID("WIN_TABELLE")
          Select WZGadName

            Case "BUTTON_TABELLE2"
              If tabelle_offen = False
                WZ_LockWindow{"WIN_TABELLE"}
                WZWindow WZID("WIN_TABELLE2"),?wzgui,64,-1,-1,-1,-1,WZID("WIN_TABELLE2")
                WZ_InitTable{"WIN_TABELLE2","TABELLE2",2,1}
                ; Fuegt Zeilen an die Tabelle "TABELLE2" an
      ;          WZ_SetTableColors{"TABELLE2",1,9,1,8,0}
                WZ_SetTableTitle{"TABELLE2","Zahl","Zufall"}
                WZ_SetPriority{"TABELLE2",1,3}
                WZ_SetTableReadOnly{"TABELLE2",False}
                WZ_SetTableLines{"TABELLE2",Off,Off}
                WZ_SetTableAlign{"TABELLE2",#ALIGN_CENTER,#ALIGN_CENTER}
                For a = 1 To 9
                  zufall$ =""
                  For b.w = 1 To 9
                    zufall$ + Str$(Chr$(64+Rnd(20)))
                  Next b
                  WZ_AddRow{"TABELLE2",Str$(a),zufall$}
                Next a

                WZ_DrawTable{"TABELLE2"}
                WZ_UpdateTable{"TABELLE2"}
                tabelle_offen = True
              Else
                tabelle_offen = False
                WZ_KillTable{"TABELLE2"}
                WZCloseWindow WZID("WIN_TABELLE2")
                WZ_UnlockWindow{"WIN_TABELLE"}
              EndIf
          End Select

      End Select

  End Select

  Select WZ_CheckTableEvent{ev}

    Case #WZTABLEEVENT_DOUBLECLICK
      x.w = WZ_Row{wztabledata\id}
      y.w = WZ_Column{wztabledata\id}
      error{"Selected via doubleclick: "+Str$(x)+","+Str$(y)}

    Case #WZTABLEEVENT_CELLSELECTED
      x.w = WZ_Row{wztabledata\id}
      y.w = WZ_Column{wztabledata\id}
      If (x > 0) AND (y > 0)
        z$ = wztabledata\id + ": cell " + Str$(x) + "," + Str$(y) + ":" + WZ_GetCell{wztabledata\id,x,y} + "___" + WZ_GetCell{wztabledata\id,x,2}
        WZ_SetPopUpMenu{wztabledata\id + "\\n row "+Str$(x)+" \\n column "+Str$(y)}
      Else
        If x <> ox.w
          z$ = "selected row: " + Str$(x)
        Else
          z$ = "no row selected"
        EndIf
      EndIf
      ox.w = x
      Use Window WZID("WIN_TABELLE")
      WZPrint "TABELLE_STATUS",&z$

    Case #WZTABLEEVENT_POPUPMENU
      z$ = "selected entry: " + Str$(wztabledata\selected_popup)
      WZPrint "TABELLE_STATUS",&z$
  End Select

skipall:
Until exit = True
WZ_HideBubble{}

;-- removes all entries of the tables
WZ_KillTable{"TABELLE2"} : WZCloseWindow WZID("WIN_TABELLE2")
WZ_KillTable{"TABELLE"} : WZCloseWindow WZID("WIN_TABELLE")
End

Goto wzguiEnd:

wzgui:
IncBin "blitz3:sourcecodes/includes/wizard_Tools.include.wizard"
wzguiEnd:
CEND
