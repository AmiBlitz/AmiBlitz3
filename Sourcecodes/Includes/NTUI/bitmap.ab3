; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "RAM:"
; ExeFile         = "Prog.exe"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 8192
; MakeSmallest    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 4
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 32768
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 1
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 2104
; CursorColumn    = 27
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 20
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 20
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: ntui_bitmap.include                                                   /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 06/01/2009                                                            /
;/                                                                             /
;/ Author: <unknown>                                                           /
;/                                                                             /
;/ Requirements:  Amiblitz3                                                    /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Extend AB3 functionality.                                                   /
;/ * no description available *                                                /
;/                                                                             /
;/ Abstract:                                                                   /
;/ * no abstract available *                                                   /
;/                                                                             /
;/ User Constants:                                                             /
;/ #max_objects   = n                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ntui_CreateRastPort{width.l,height.l}
flags.l = #BMF_MINPLANES|#BMF_SPECIALFMT|(#PIXFMT_ARGB32 LSL 24)
bdepth.l = 24
*bmap.BitMap = AllocBitMap_(width,height,bdepth,flags,#NULL)
If *bmap
  *layerinfo.Layer_Info = NewLayerInfo_
  If *layerinfo
    *layer.Layer    =  CreateUpfrontHookLayer_ (*layerinfo,*bmap,0,0,width-1,height-1,0,#LAYERS_NOBACKFILL,0)
    If *layer
      *rp.RastPort = *layer\rp
    End If
  End If
End If
Function Return *rp
End Function


Statement ntui_FreeRastPort{*rp.RastPort}
If *rp
  *bmap.BitMap          = *rp\BitMap
  *layerinfo.Layer_Info = *rp\Layer\LayerInfo
  *layer.Layer          = *rp\Layer
  If *layer     Then DeleteLayer_ 0,*layer
  If *layerinfo Then DisposeLayerInfo_ *layerinfo
  If *bmap Then FreeBitMap_ *bmap
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ntui_WritePixelArrayAlpha {*srcA.tuiARGB,sx.l,sy.l,*dstRP.RastPo:: /
;/ rt,dx.l,dy.l,width.l,height.l,mode.l}                                       /
;/                                                                             /
;/ Description:                                                                /
;/ private
;/                                                                            /
;/ Inputs:                                                                     /
;/ - *srcA.tuiARGB    : ???                                                    /
;/ - sx.l    : ???                                                             /
;/ - sy.l    : ???                                                             /
;/ - *dstRP.RastPort    : ???                                                  /
;/ - dx.l    : ???                                                             /
;/ - dy.l    : ???                                                             /
;/ - width.l    : ???                                                          /
;/ - height.l    : ???                                                         /
;/ - mode.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ntui_WritePixelArray9Patch{*srcA.tuiARGB,*tpa.tuiPixelArray,*srcRect.tuiRect,*dstRP.RastPort,*dstRect.tuiRect,imode.l,bgARGB.l}
swidth.l  = !tuiRectWidth {*srcRect}
sheight.l = !tuiRectHeight{*srcRect}
dwidth.l  = !tuiRectWidth {*dstRect}
dheight.l = !tuiRectHeight{*dstRect}

sbpr.l = (*tpa\width)*4
dbpr.l = dwidth*4

srcBase.l = *srcA + (1 + *srcRect\top)*sbpr + (1+*srcRect\left)*4
scaleBase.l = *srcA

If *srcA><#NULL AND sbpr>0 AND dbpr>0

; bug the values must come from the state Bitmap, not the general one
rhM.l = (dwidth - *tpa\hfix)
rhD.l = *tpa\hscale

rvM.l = (dheight - *tpa\vfix)
rvD.l = *tpa\vscale


tmp.l = _ntui_ObtainTempBuffer{dwidth*dheight*4}
If tmp
  bgARGB=-1
  If bgARGB=-1
    ReadPixelArray_ tmp,0,0,dbpr,*dstRP,*dstRect\left,*dstRect\top,dwidth,dheight,#RECTFMT_ARGB
  Else
    dR.l = (bgARGB LSR 16 ) &$FF
    dG.l = (bgARGB LSR 8  ) &$FF
    dB.l = (bgARGB        ) &$FF
  End If
  RunErrsOff
  syr.l = 0
  For dy.l = 0 To dheight-1
    sy.l = syr / rvM
    scaleP.l = *srcA + sbpr + sy*sbpr
    sR.l=(Peek.b(scaleP)); & $FF) LSR 4
    ;syr = syr + (1-sR)*rvM + ((sR) * rvD)
    If sR
      syr + rvD
    Else
      syr + rvM
    End If

    ;sy.l = dy * sheight/dheight
    dstP.l = tmp + dbpr * dy
    sxr.l = 0
    For dx.l = 0 To dwidth-1
      sx.l = sxr / rhM
      srcP.l   = srcBase + sbpr * sy + sx*4
      scaleP.l = *srcA + 4 + sx*4

      ;sR.l=(Peek.b(scaleP) & $FF) LSR 4
      ;sxr = sxr + (15-sR)*rhM + ((sR) * rhD)
      sR.l = Peek.b(scaleP)
      ;sxr + (sR * rhD) + ((1-sR) * rhM)
      If sR
        sxr + rhD
      Else
        sxr + rhM
      End If


      sA.l=Peek.b(srcP+0) & $FF
      sR.l=Peek.b(srcP+1) & $FF
      sG.l=Peek.b(srcP+2) & $FF
      sB.l=Peek.b(srcP+3) & $FF

      dA.l=256-sA
      dR.l=Peek.b(dstP+1) & $FF
      dG.l=Peek.b(dstP+2) & $FF
      dB.l=Peek.b(dstP+3) & $FF

      R.l = (sR*sA + dR*dA) LSR 8
      G.l = (sG*sA + dG*dA) LSR 8
      B.l = (sB*sA + dB*dA) LSR 8

      Poke.l dstP,(R LSL 16) | (G LSL 8) | (B LSL 0)
      dstP+4
    Next
  Next
  LastRunErrsMode
  WritePixelArray_ tmp,0,0,dbpr,*dstRP,*dstRect\left,*dstRect\top,dwidth,dheight,#RECTFMT_ARGB
  _ntui_ReleaseTempBuffer{}
End If
End If

End Statement

Statement _ntui_WritePixelArrayScaled{*srcA.tuiARGB,*srcRect.tuiRect,*dstRP.RastPort,*dstRect.tuiRect,imode.l,bgARGB.l}
swidth.l  = !tuiRectWidth {*srcRect}
sheight.l = !tuiRectHeight{*srcRect}
dwidth.l  = !tuiRectWidth {*dstRect}
dheight.l = !tuiRectHeight{*dstRect}

sbpr.l = (swidth+2)*4
dbpr.l = dwidth*4

srcBase.l = *srcA + sbpr + 4

If *srcA><#NULL AND sbpr>0 AND dbpr>0

tmp.l = _ntui_ObtainTempBuffer{dwidth*dheight*4}
If tmp
  bgARGB=-1
  If bgARGB=-1
    ReadPixelArray_ tmp,0,0,dbpr,*dstRP,*dstRect\left,*dstRect\top,dwidth,dheight,#RECTFMT_ARGB
  Else
    dR.l = (bgARGB LSR 16 ) &$FF
    dG.l = (bgARGB LSR 8  ) &$FF
    dB.l = (bgARGB        ) &$FF
  End If
  RunErrsOff
  For dy.l = 0 To dheight-1
    sy.l = dy * sheight/dheight
    dstP.l = tmp + dbpr * dy
    For dx.l = 0 To dwidth-1
      sx.l = dx * swidth / dwidth
      srcP.l = srcBase + sbpr * sy + sx*4

      sA.l=Peek.b(srcP+0) & $FF
      sR.l=Peek.b(srcP+1) & $FF
      sG.l=Peek.b(srcP+2) & $FF
      sB.l=Peek.b(srcP+3) & $FF

      dA.l=256-sA
      dR.l=Peek.b(dstP+1) & $FF
      dG.l=Peek.b(dstP+2) & $FF
      dB.l=Peek.b(dstP+3) & $FF

      R.l = (sR*sA + dR*dA) LSR 8
      G.l = (sG*sA + dG*dA) LSR 8
      B.l = (sB*sA + dB*dA) LSR 8

      Poke.l dstP,(R LSL 16) | (G LSL 8) | (B LSL 0)
      dstP+4
    Next
  Next
  LastRunErrsMode
  WritePixelArray_ tmp,0,0,dbpr,*dstRP,*dstRect\left,*dstRect\top,dwidth,dheight,#RECTFMT_ARGB
  _ntui_ReleaseTempBuffer{}
End If
End If

End Statement


Statement _ntui_WritePixelArrayAlpha{*srcA.tuiARGB,sx.l,sy.l,*dstRP.RastPort,dx.l,dy.l,width.l,height.l,mode.l,bgARGB.l}
raw_ptr.l = *srcA
bpr.l = width*4
If raw_ptr><#NULL AND bpr>0
tmp.l = _ntui_ObtainTempBuffer{width*height*4}
If tmp
  If mode=#TUIIM_FOCUS Then mode=#TUIIM_NORMAL
  If mode=#TUIIM_MOVER Then mode=#TUIIM_NORMAL
  If bgARGB=-1
    ReadPixelArray_ tmp,0,0,width*4,*dstRP,dx,dy,width,height,#RECTFMT_ARGB
  Else
    dR.l = (bgARGB LSR 16 ) &$FF
    dG.l = (bgARGB LSR 8  ) &$FF
    dB.l = (bgARGB        ) &$FF
    mode + 10
  End If

  RunErrsOff
  For y.l = 0 To height-1
    dst.l = tmp     + (y)*width*4
    src.l = raw_ptr + (y+sy)*bpr     + sx*4
    Select mode
    Case #TUIIM_NORMAL + 10
      For x.l = 0 To width-1
        sA.l=Peek.b(src+0) & $FF
        sR.l=Peek.b(src+1) & $FF
        sG.l=Peek.b(src+2) & $FF
        sB.l=Peek.b(src+3) & $FF

        dA.l=256-sA

        R.l = (sR*sA + dR*dA) LSR 8
        G.l = (sG*sA + dG*dA) LSR 8
        B.l = (sB*sA + dB*dA) LSR 8

        Poke.l dst,(R LSL 16) | (G LSL 8) | (B LSL 0)
        dst+4 : src+4
      Next

    Case #TUIIM_ACTIVE + 10
       For x.l = 0 To width-1
         sA.l=((Peek.b(src+0) & $FF))
         sR.l=((Peek.b(src+1) & $FF) * 330) LSR 8 : If sR>255 Then sR=255
         sG.l=((Peek.b(src+2) & $FF) * 330) LSR 8 : If sG>255 Then sG=255
         sB.l=((Peek.b(src+3) & $FF) * 330) LSR 8 : If sB>255 Then sB=255

         dA.l=256-sA

         R.l = (sR*sA + dR*dA) LSR 8
         G.l = (sG*sA + dG*dA) LSR 8
         B.l = (sB*sA + dB*dA) LSR 8

         Poke.l dst,(R LSL 16) | (G LSL 8) | (B LSL 0)
         dst+4 : src+4
       Next

    Case #TUIIM_DISABLED + 10
       For x.l = 0 To width-1
         sA.l=(Peek.b(src+0) & $FF) LSR 1
         sX.l=((Peek.b(src+1) & $FF) + (Peek.b(src+2) & $FF) + (Peek.b(src+3) & $FF)) LSR 2

         dA.l=256-sA

         R.l = (sX*sA + dR*dA) LSR 8
         G.l = (sX*sA + dG*dA) LSR 8
         B.l = (sX*sA + dB*dA) LSR 8

         Poke.l dst,(R LSL 16) | (G LSL 8) | (B LSL 0)
         dst+4 : src+4
       Next

    Case #TUIIM_NORMAL
      For x.l = 0 To width-1
        sA.l=Peek.b(src+0) & $FF
        sR.l=Peek.b(src+1) & $FF
        sG.l=Peek.b(src+2) & $FF
        sB.l=Peek.b(src+3) & $FF

        dA.l=256-sA
        dR.l=Peek.b(dst+1) & $FF
        dG.l=Peek.b(dst+2) & $FF
        dB.l=Peek.b(dst+3) & $FF

        R.l = (sR*sA + dR*dA) LSR 8
        G.l = (sG*sA + dG*dA) LSR 8
        B.l = (sB*sA + dB*dA) LSR 8

        Poke.l dst,(R LSL 16) | (G LSL 8) | (B LSL 0)
        dst+4 : src+4
      Next

    Case #TUIIM_ACTIVE
       For x.l = 0 To width-1
         sA.l=((Peek.b(src+0) & $FF))
         sR.l=((Peek.b(src+1) & $FF) * 330) LSR 8 : If sR>255 Then sR=255
         sG.l=((Peek.b(src+2) & $FF) * 330) LSR 8 : If sG>255 Then sG=255
         sB.l=((Peek.b(src+3) & $FF) * 330) LSR 8 : If sB>255 Then sB=255

         dA.l=256-sA
         dR.l=Peek.b(dst+1) & $FF
         dG.l=Peek.b(dst+2) & $FF
         dB.l=Peek.b(dst+3) & $FF

         R.l = (sR*sA + dR*dA) LSR 8
         G.l = (sG*sA + dG*dA) LSR 8
         B.l = (sB*sA + dB*dA) LSR 8

         Poke.l dst,(R LSL 16) | (G LSL 8) | (B LSL 0)
         dst+4 : src+4
       Next

    Case #TUIIM_DISABLED
       For x.l = 0 To width-1
         sA.l=(Peek.b(src+0) & $FF) LSR 1
         sX.l=((Peek.b(src+1) & $FF) + (Peek.b(src+2) & $FF) + (Peek.b(src+3) & $FF)) LSR 2

         dA.l=256-sA
         dR.l=Peek.b(dst+1) & $FF
         dG.l=Peek.b(dst+2) & $FF
         dB.l=Peek.b(dst+3) & $FF

         R.l = (sX*sA + dR*dA) LSR 8
         G.l = (sX*sA + dG*dA) LSR 8
         B.l = (sX*sA + dB*dA) LSR 8

         Poke.l dst,(R LSL 16) | (G LSL 8) | (B LSL 0)
         dst+4 : src+4
       Next
    End Select
  Next
  LastRunErrsMode
  WritePixelArray_ tmp,0,0,width*4,*dstRP,dx,dy,width,height,#RECTFMT_ARGB
  _ntui_ReleaseTempBuffer{}
End If
End If
End Statement



Statement _ntui_WritePixelArray{*srcA.tuiARGB,sx.l,sy.l,*dstRP.RastPort,dx.l,dy.l,width.l,height.l,mode.l}
raw_ptr.l = *srcA
bpr.l = width*4
If raw_ptr><#NULL AND bpr>0
If mode=#TUIIM_NORMAL Then WritePixelArray_ *srcA,sx,sy,width*4,*dstRP,dx,dy,width,height,#RECTFMT_ARGB : Statement Return
tmp.l = _ntui_ObtainTempBuffer{width*height*4}
If tmp
  RunErrsOff
  For y.l = 0 To height-1
    dst.l = tmp     + (y)*width*4
    src.l = raw_ptr + (y+sy)*bpr     + sx*4
    Select mode
      Case #TUIIM_ACTIVE
         For x.l = 0 To width-1
           sR.l=((Peek.b(src+1) & $FF) * 330) LSR 8 : If sR>255 Then sR=255
           sG.l=((Peek.b(src+2) & $FF) * 330) LSR 8 : If sG>255 Then sG=255
           sB.l=((Peek.b(src+3) & $FF) * 330) LSR 8 : If sB>255 Then sB=255
           Poke.l dst,(sR LSL 16) | (sG LSL 8) | (sB LSL 0)
           dst+4 : src+4
         Next

      Case #TUIIM_DISABLED
         For x.l = 0 To width-1
           sX.l=((Peek.b(src+1) & $FF) + (Peek.b(src+2) & $FF) + (Peek.b(src+3) & $FF)) LSR 2
           R.l = (sX) LSR 1 + 127
           Poke.l dst,(R LSL 16) | (R LSL 8) | (R LSL 0)
           dst+4 : src+4
         Next
    End Select
  Next
  LastRunErrsMode
  WritePixelArray_ tmp,0,0,width*4,*dstRP,dx,dy,width,height,#RECTFMT_ARGB
  _ntui_ReleaseTempBuffer{}
End If
End If
End Statement


Statement _ntui_ThresholdAlpha{*srcA.tuiARGB,width.l,height.l,threshold.l}
raw_ptr.l = *srcA
bpr.l = width*4
If raw_ptr><#NULL AND bpr>0
  For y.l = 0 To height-1
    src.l = raw_ptr + y*bpr
    For x.l = 0 To width-1
      A.l=Peek.b(src+0) & $FF
      If A<threshold Then A=0
      Poke.b src,A
      src+4
    Next
  Next
End If
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_LoadBitMapViaPNG {filename.s,*width.l,*height.l}   /
;/                                                                             /
;/ Description:                                                                /
;/ private: load an 32bit ARGB PNG image vis custom routines                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s   : ???                                                       /
;/ - *width.l     : ???                                                         /
;/ - *height.l    : ???                                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ntui_LoadBitMapViaPNG{filename.s,*width.l,*height.l}
*raw.tuiARGB =#NULL
*tuiPNG.tuiPNG= ntui_ReadPNG{filename}
If *tuiPNG
  pwidth.l  = ntui_GetPNGWidth{*tuiPNG}
  pheight.l = ntui_GetPNGHeight{*tuiPNG}
  If pwidth>0 AND pheight>0
    *raw = AllocVec_(pwidth*pheight*4,#MEMF_ANY)
    If *raw
      Poke.l *width,pwidth
      Poke.l *height,pheight
      ntui_DecodePNG{*tuiPNG,*raw,pwidth*4}
    End If
  End If
  ntui_FreePNG{*tuiPNG }
End If
Function Return *raw
End Function


Function.l _ntui_LoadBitMapViaIcon{filename.s,*tpa.tuiPixelArray}
SHARED version_iconlib.l
*raw.tuiARGB =#NULL

If version_iconlib=0 Then version_iconlib = dos_GetLibVersion{"icon.library"}
If version_iconlib<44 Then Function Return *raw

If LCase$(Right$(filename.s,5))=".info"
  filename.s=UnLeft$(filename.s,5)
EndIf
*icon.DiskObject = GetDiskObjectNew_(&filename.s)

If *icon
  DEFTYPE.Rectangle rectLI
  rectLI\MinX = 0,0,0,0

  tag5.tag5\ti_Tag = #ICONDRAWA_Borderless,True,#ICONDRAWA_EraseBackground,False,#TAG_DONE,0
RunErrsOff
  MOVE.l a4,-(a7)
  MOVE.l a5,-(a7)
  MOVE.l a6,-(a7)
  MOVE.l d7,-(a7)
  GetIconRectangleA_ 0,*icon,0,rectLI,tag5
  MOVE.l (a7)+,d7
  MOVE.l (a7)+,a6
  MOVE.l (a7)+,a5
  MOVE.l (a7)+,a4
LastRunErrsMode
  width.l  = rectLI\MaxX - rectLI\MinX +1
  height.l = rectLI\MaxY - rectLI\MinY +1
  xoff.l   = -rectLI\MinX
  yoff.l   = -rectLI\MinY

  *rp1.RastPort = ntui_CreateRastPort{width,height}
  *rp2.RastPort = ntui_CreateRastPort{width,height}
  *tpa\width  = width
  *tpa\height = height

  If *rp1><#NULL AND *rp2><#NULL
    For n.l=0 To 1
      If n=0 Then state.l=#IDS_NORMAL : Else state=#IDS_SELECTED

      FillPixelArray_ *rp1,0,0,width,height,$00000000
      tag5.tag5\ti_Tag = #ICONDRAWA_Borderless,True,#ICONDRAWA_EraseBackground,True,#TAG_DONE,0
      DrawIconStateA_ *rp1,*icon,#NULL,xoff,yoff,state,tag5
      bmaplock.l = LockBitMapTagList_(*rp1\BitMap,Tags(#LBMI_BASEADDRESS,&rawptr1.l,#LBMI_BYTESPERROW,&bpr1.l))
      UnLockBitMap_ bmaplock

      FillPixelArray_ *rp2,0,0,width,height,$00FFFFFF
      tag5.tag5\ti_Tag = #ICONDRAWA_Borderless,True,#ICONDRAWA_EraseBackground,True,#TAG_DONE,0
      DrawIconStateA_ *rp2,*icon,#NULL,xoff,yoff,state,tag5
      bmaplock.l = LockBitMapTagList_(*rp2\BitMap,Tags(#LBMI_BASEADDRESS,&rawptr2.l,#LBMI_BYTESPERROW,&bpr2.l))
      UnLockBitMap_ bmaplock

      *raw = AllocVec_(width*height*4,#MEMF_ANY)
      If *raw
        For y.l = 0 To height-1 ; Opaque Alpha Channel
          *src2.tuiARGB = rawptr2 + y*bpr2
          *src1.tuiARGB = rawptr1 + y*bpr1
          *dst.tuiARGB = *raw + y*width*4
          For x.l = 0 To width-1
            a.l = (((*src2\R&$FF) - (*src1\R&$FF))); + ((*src2\G&$FF) - (*src1\G&$FF)) + ((*src2\B&$FF) - (*src1\B&$FF))) / 3
            ;If a<0 Then a=0
            ;If a>255 Then a=255
            a=255-a
            ;R.l = ((*src1\R&$FF)+(*src2\R&$FF)) LSR 1; *256/(a+1); If a>0 Then R*255 / a : If R>255 Then R=255
            ;G.l = ((*src1\G&$FF)+(*src2\G&$FF)) LSR 1; *256/(a+1);: If a>0 Then G*255 / a : If G>255 Then G=255
            ;B.l = ((*src1\B&$FF)+(*src2\B&$FF)) LSR 1; *256/(a+1);: If a>0 Then B*255 / a : If B>255 Then B=255

            R.l = ((*src1\R&$FF)*256/(a+1)); If a>0 Then R*255 / a : If R>255 Then R=255
            G.l = ((*src1\G&$FF)*256/(a+1));: If a>0 Then G*255 / a : If G>255 Then G=255
            B.l = ((*src1\B&$FF)*256/(a+1));: If a>0 Then B*255 / a : If B>255 Then B=255



            *dst\A = a,R,G,B
            *dst+4
            *src1+4
            *src2+4
          Next
        Next
      End If
      If n=0 Then *tpa\normal = *raw : Else *tpa\active=*raw
    Next
  End If
  If *rp1 Then ntui_FreeRastPort{*rp1}
  If *rp2 Then ntui_FreeRastPort{*rp2}

  FreeDiskObject_ *icon
EndIf
Function Return *tpa\normal
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_LoadBitMapViaDT {filename.s,imgnum.l,*width.l,*h:: /
;/ eight.l}                                                                    /
;/                                                                             /
;/ Description:                                                                /
;/ privtae: load an image via Datatypes.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : ???                                                       /
;/ - imgnum.l    : ???                                                         /
;/ - *width.l    : ???                                                         /
;/ - *height.l    : ???                                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ntui_LoadBitMapViaDT{filename.s,imgnum.l,*width.l,*height.l}
DEFTYPE.BitMapHeader *bmhdp
DEFTYPE.pdtBlitPixelArray DTM
*raw.tuiARGB = #NULL : succ.l=False
If imgnum<0 Then imgnum=0
tag5.tag5\ti_Tag = #PDTA_DestMode, #PMODE_V43, #DTA_SourceType, #DTST_FILE, #DTA_GroupID, #GID_PICTURE, #PDTA_Remap, False,#PDTA_WhichPicture,imgnum,#TAG_DONE,0
*DTPic._Object = NewDTObjectA_ (&filename.s,tag5)
If *DTPic
  tag5.tag5\ti_Tag = #PDTA_BitMapHeader,&*bmhdp,#TAG_DONE,0
  GetDTAttrsA_ *DTPic,tag5
  *raw = AllocVec_(*bmhdp\bmh_Width * *bmhdp\bmh_Height *4,#MEMF_ANY)
  bpr.l = *bmhdp\bmh_Width*4
  Poke.l *width ,*bmhdp\bmh_Width
  Poke.l *height,*bmhdp\bmh_Height

  ; try to get as ARGB immediately, good datatpyes support this, but not all!
  ;If *bmhdp\bmh_Depth>8 ; dont even try if depth <=8
    DTM\MethodID            = #PDTM_READPIXELARRAY
    DTM\pbpa_PixelData      = *raw              ; /* The pixel data to transfer to/from */
    DTM\pbpa_PixelFormat    = #PBPAFMT_ARGB     ; /* Format of the pixel data (see "Pixel Formats" below) */
    DTM\pbpa_PixelArrayMod  = bpr               ; /* Number of bytes per row */
    DTM\pbpa_Left           = 0                 ; /* Left edge of the rectangle to transfer pixels to/from */
    DTM\pbpa_Top            = 0                 ; /* Top edge of the rectangle to transfer pixels to/from */
    DTM\pbpa_Width          = *bmhdp\bmh_Width  ; /* Width of the rectangle to transfer pixels to/from */
    DTM\pbpa_Height         = *bmhdp\bmh_Height
    If DoMethodA (*DTPic,&DTM) Then succ = True
  ;End If

  ; Try READPIXELARRAY LUT8, if we couldn't catch the bitmap (outch!)
  If succ=False
    penArray8.l = AllocVec_(*bmhdp\bmh_Height * *bmhdp\bmh_Width,#MEMF_ANY)
    lut.l       = AllocVec_(256*4,#MEMF_CLEAR)
    If penArray8><0 AND lut><0
      DTM\MethodID            = #PDTM_READPIXELARRAY
      DTM\pbpa_PixelData      = penArray8         ; /* The pixel data to transfer to/from */
      DTM\pbpa_PixelFormat    = #PBPAFMT_LUT8     ; /* Format of the pixel data (see "Pixel Formats" below) */
      DTM\pbpa_PixelArrayMod  = *bmhdp\bmh_Width  ; /* Number of bytes per row */
      DTM\pbpa_Left           = 0                 ; /* Left edge of the rectangle to transfer pixels to/from */
      DTM\pbpa_Top            = 0                 ; /* Top edge of the rectangle to transfer pixels to/from */
      DTM\pbpa_Width          = *bmhdp\bmh_Width  ; /* Width of the rectangle to transfer pixels to/from */
      DTM\pbpa_Height         = *bmhdp\bmh_Height
      If DoMethodA (*DTPic,&DTM)
        tag5.tag5\ti_Tag = #PDTA_ColorRegisters,&colMap.l,#TAG_DONE,0
        If GetDTAttrsA_ (*DTPic,tag5)
          For pen.l=0 To (1 LSL *bmhdp\bmh_Depth)-1
            *CReg.ColorRegister = colMap + 3*pen
            Poke.l lut + (pen LSL 2),((*CReg\red&$00FF) LSL 16) | ((*CReg\green & $00FF) LSL 8) | (*CReg\blue & $FF)
          Next
          For y.l = 0 To *bmhdp\bmh_Height -1
            For x.l = 0 To *bmhdp\bmh_Width -1
              pen.l = Peek.b(penArray8+y**bmhdp\bmh_Width+x) & $FF
              Poke.l *raw+y*bpr+(x LSL 2),(Peek.l(lut+(pen LSL 2)) );& $FEFEFEFE) LSR 1
            Next
          Next
          succ.l = True
        End If
      End If
      If penArray8 Then FreeVec_ penArray8 : penArray8 = 0
      If lut       Then FreeVec_ lut       : lut       = 0
    End If
  End If
  If succ=False
    FreeVec_ *raw : *raw=#NULL
  Else
    For y.l = 0 To *bmhdp\bmh_Height-1 ; Opaque Alpha Channel
      *dst.tuiARGB = *raw + y*bpr
      For x.l = 0 To *bmhdp\bmh_Width-1
        *dst\A=255
        *dst+4
      Next
    Next
  End If
  DisposeDTObject_ (*DTPic)
End If
Function Return *raw
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_ObtainTuiBitMap {imagefile.s}                      /
;/                                                                             /
;/ Description:                                                                /
;/ private
;/                                                                            /
;/ Inputs:                                                                     /
;/ - imagefile.s    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ntui_ObtainTuiBitMap{imagefile.s}
*tbm.tuiBitMap = #NULL

If tuiGlobal\bitMapCache\tuiBitMapA  ; check if the image is already in cache ...
  For n.l=0 To tuiGlobal\bitMapCache\tuiBitMapsUsed-1
    *tbm = Peek.l(tuiGlobal\bitMapCache\tuiBitMapA + n*SizeOf.l)
    If *tbm
      If str_Read{&*tbm\name}=imagefile Then *tbm\useCount+1 : Function Return *tbm
    End If
  Next
End If

If tuiGlobal\bitMapCache\tuiBitMapsAlloc<=tuiGlobal\bitMapCache\tuiBitMapsUsed  ; it is not in cache, check if we need to increase the buffer
  newAlloc.l =  tuiGlobal\bitMapCache\tuiBitMapsUsed+16
  *newList.tuiBitMap = AllocVec_ (newAlloc*SizeOf.l,#MEMF_CLEAR)
  If *newList
;    : error {"increase image cache buffer"}
    If tuiGlobal\bitMapCache\tuiBitMapA
      CopyMem_ tuiGlobal\bitMapCache\tuiBitMapA,*newList,SizeOf.l*tuiGlobal\bitMapCache\tuiBitMapsUsed
      FreeVec_ tuiGlobal\bitMapCache\tuiBitMapA
    End If
    tuiGlobal\bitMapCache\tuiBitMapA = *newList
    tuiGlobal\bitMapCache\tuiBitMapsAlloc = newAlloc
  End If
End If

If tuiGlobal\bitMapCache\tuiBitMapsAlloc>tuiGlobal\bitMapCache\tuiBitMapsUsed  ; if buffer is large enough, add new image
  *tbm = AllocVec_(SizeOf.tuiBitMap,#MEMF_ANY)

  *tbm\pixelArrayA = AllocVec_(SizeOf.tuiPixelArray*4,#MEMF_ANY)
  If *tbm\pixelArrayA
    *tbm\name              = #NULL
    *tbm\pixelArraysUsed   = 1
    *tbm\pixelArraysAlloc  = 4

    *tpa.tuiPixelArray = *tbm\pixelArrayA
    *tpa\normal   = #NULL
    *tpa\active   = #NULL
    *tpa\disabled = #NULL
    *tpa\focus    = #NULL
    *tpa\mover    = #NULL
    *tpa\width  = 1
    *tpa\height = 1
    *tbm\bmode=#TUIIBM_OPAQUE

    If *tpa\normal=#NULL ; try Icon first...
      If Right$(imagefile,5)=".info"
        If _ntui_LoadBitMapViaIcon{imagefile,*tpa}
          *tbm\bmode=#TUIIBM_MASK
        End If
      End If
    End If

    If *tpa\normal=#NULL ; try PNG next...
      *tpa\normal  = _ntui_LoadBitMapViaPNG{imagefile,&w.l,&h.l}
      *tpa\width   = w
      *tpa\height  = h
      If *tpa\normal
        *tpa\active   = _ntui_LoadBitMapViaPNG{imagefile+"_s",&w.l,&h.l}
        *tpa\disabled = _ntui_LoadBitMapViaPNG{imagefile+"_g",&w.l,&h.l}
        *tpa\mover    = _ntui_LoadBitMapViaPNG{imagefile+"_m",&w.l,&h.l}
        *tpa\focus    = _ntui_LoadBitMapViaPNG{imagefile+"_f",&w.l,&h.l}
        If Right$(imagefile,6)=".9.png"
          *tbm\bmode=#TUIIBM_9PATCH
        Else
          *tbm\bmode=#TUIIBM_MASK
        End If
      End If
    End If

    If *tpa\normal=#NULL ; try picture Datatype...
      *tpa\normal = _ntui_LoadBitMapViaDT{imagefile,0,&w.l,&h.l}
      *tbm\bmode=#TUIIBM_OPAQUE
      *tpa\width   = w
      *tpa\height  = h
    End If

    If *tpa\normal=#NULL ; still nothing? try DefIcon...
      If _ntui_LoadBitMapViaIcon{imagefile,*tpa}
        *tbm\bmode=#TUIIBM_MASK
      End If
    End If

    If *tpa\normal=#NULL ; well seems not be existent!
      FreeVec_ *tbm\pixelArrayA : *tbm\pixelArrayA = #NULL
      FreeVec_ *tbm : *tbm = #NULL
    Else
      Poke.l tuiGlobal\bitMapCache\tuiBitMapA + (tuiGlobal\bitMapCache\tuiBitMapsUsed*SizeOf.l),*tbm
      *tbm\useCount              = 1
      str_Write{&*tbm\name,imagefile}
      tuiGlobal\bitMapCache\tuiBitMapsUsed+1


      If *tbm\bmode = #TUIIBM_9PATCH
        bpr.l     = *tpa\width*4
        iwidth.l  = *tpa\width-2
        iheight.l = *tpa\height-2

        *tpa\hscale = 0
        srcP.l = *tpa\normal + 4
        For x.l = 0 To iwidth-1
          sA.l=Peek.b(srcP) & $FF
          ;*tpa\hscale + (sA LSR 4)
          If sA>127 Then Poke.b srcP,1 : *tpa\hscale+1 : Else Poke.b srcP,0
          srcP+4
        Next
        *tpa\hfix  = (iwidth) - *tpa\hscale

        *tpa\vscale = 0
        srcP.l = *tpa\normal + bpr
        For x.l = 0 To iheight-1
          sA.l=Peek.b(srcP) & $FF
          ;*tpa\vscale + (sA LSR 4)
          If sA>127 Then Poke.b srcP,1 : *tpa\vscale+1 : Else Poke.b srcP,0
          srcP+bpr
        Next
        *tpa\vfix  = (iheight) - *tpa\vscale

        *tpa\border\left = 0
        x.l = 1
        y.l = *tpa\height-1
        srcP.l = *tpa\normal + (bpr*y) + x*4
        For x.l = 0 To iwidth-1
          sA.l=Peek.b(srcP) & $FF : srcP+4
          If sA>=128
            x = iwidth
          Else
            *tpa\border\left + 1
          End If
        Next

        *tpa\border\right = 0
        x.l = *tpa\width-1-1
        y.l = *tpa\height-1
        srcP.l = *tpa\normal + (bpr*y) + x*4
        For x.l = 0 To iwidth-1
          sA.l=Peek.b(srcP) & $FF : srcP-4
          If sA>=128
            x = iwidth
          Else
            *tpa\border\right + 1
          End If
        Next

        *tpa\border\top = 0
        x.l = *tpa\width-1
        y.l = 1
        srcP.l = *tpa\normal + (bpr*y) + x*4
        For x.l = 0 To iheight-1
          sA.l=Peek.b(srcP) & $FF : srcP+bpr
          If sA>=128
            x = iheight
          Else
            *tpa\border\top + 1
          End If
        Next

        *tpa\border\bottom = 0
        x.l = *tpa\width-1
        y.l = *tpa\height-1-1
        srcP.l = *tpa\normal + (bpr*y) + x*4
        For x.l = 0 To iheight-1
          sA.l=Peek.b(srcP) & $FF : srcP-bpr
          If sA>=128
            x = iheight
          Else
            *tpa\border\bottom + 1
          End If
        Next
        a.s = Str$(*tpa\border\left)+"/"+Str$(*tpa\border\top)+"/"+Str$(*tpa\border\right)+"/"+Str$(*tpa\border\bottom)
        b.s = Str$(*tpa\hscale)+"/"+Str$(*tpa\vscale)+"/"+Str$(*tpa\width)+"/"+Str$(*tpa\height)
        ;error{imagefile+": scale="+b.s+"content: "+a.s}
      End If

    End If

;    If *tpa\normal   Then _ntui_ThresholdAlpha{*tpa\normal  ,*tpa\width,*tpa\height,20}
;    If *tpa\selected Then _ntui_ThresholdAlpha{*tpa\selected,*tpa\width,*tpa\height,20}
;    If *tpa\disabled  Then _ntui_ThresholdAlpha{*tpa\disabled ,*tpa\width,*tpa\height,20}
  Else
    FreeVec_ *tbm : *tbm = #NULL
  End If
End If
Function Return *tbm
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ntui_ReleaseTuiBitMap {*tbm.tuiBitMap}                             /
;/                                                                             /
;/ Description:                                                                /
;/ private
;/                                                                            /
;/ Inputs:                                                                     /
;/ - *tbm.tuiBitMap    : ???                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ntui_ReleaseTuiBitMap{*tbm.tuiBitMap}
*tbm\useCount-1
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ntui_ScalePixelArray {srcA.l,srcWidth.l,srcHeight.l,srcBPR.l,dst:: /
;/ A.l,dstWidth.l,dstHeight.l,dstBPR.l,mode.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - srcA.l       : ???                                                           /
;/ - srcWidth.l   : ???                                                       /
;/ - srcHeight.l  : ???                                                      /
;/ - srcBPR.l     : ???                                                         /
;/ - dstA.l       : ???                                                           /
;/ - dstWidth.l   : ???                                                       /
;/ - dstHeight.l  : ???                                                      /
;/ - dstBPR.l     : ???                                                         /
;/ - mode.l       : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
RunErrsOff
Statement _ntui_ScalePixelArray{srcA.l,srcWidth.l,srcHeight.l,srcBPR.l,dstA.l,dstWidth.l,dstHeight.l,dstBPR.l,mode.l}
sxs.l  = srcWidth
sys.l  = srcHeight
dxs.l  = dstWidth
dys.l  = dstHeight
fracX.l = 0
fracY.l = 0
sy.l = 0
Select mode
  Case 0
    fracY.l = sys ASR 1
    For dy.l=0 To dys-1
      sptr.l = srcA + sy * srcBPR
      dptr.l = dstA + dy * dstBPR
      fracY+sys : While fracY>dys:fracY-dys:sy+1:Wend
      fracX.l = sxs ASR 1
      For dx.l = 0 To dxs-1
        Poke.l dptr,Peek.l(sptr) :dptr+4
        fracX+sxs : While fracX>dxs:fracX-dxs:sptr+4:Wend
      Next
    Next

  Case 2
    tmp.l    = dstA
    tmpbpr.l = dstBPR

    destbase.l   = tmp
    dbpr.l       = tmpbpr
    sourcebase.l = srcA
    sbpr.l       = srcBPR

    ; scale step
    fracY.l = 0
    pw.l = sxs*sys : If pw<1 Then pw=1
    For dy.l=0 To dys-1
      weightY1.l = (dys-fracY)
      cy.l=0 : fracY+sys : While fracY>dys:fracY-dys:cy+1:Wend
      sptr.l = srcA + sy * srcBPR
      dptr.l = dstA + dy * dstBPR
      fracX.l = 0
      For dx.l = 0 To dxs-1
        weightX1.l = (dxs-fracX)
        cx.l=0 : fracX+sxs : While fracX>dxs:fracX-dxs:cx+1:Wend

        ; Calculate the pixel...
        R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
        weightY.l = weightY1
        nsptr.l = sptr + (cx LSL 2)
        For m.l = 0 To cy
          weightX.l = weightX1
          If m = cy Then weightY = weightY + (fracY-dys)
          For n.l = 0 To cx
            If n = cx Then weightX = weightX + (fracX-dxs)
            tpw.l = weightX*weightY
            A.l + (Peek.b(sptr  ) & $FF) * tpw
            R.l + (Peek.b(sptr+1) & $FF) * tpw
            G.l + (Peek.b(sptr+2) & $FF) * tpw
            B.l + (Peek.b(sptr+3) & $FF) * tpw
            weightX = (dxs)
            sptr+4
          Next
          sptr - 4*(cx+1) + srcBPR
          weightY = (dys)
        Next
        sptr = nsptr

        Poke.b dptr  ,A / pw
        Poke.b dptr+1,R / pw
        Poke.b dptr+2,G / pw
        Poke.b dptr+3,B / pw
        dptr+4
      Next
      sy+cy
    Next

    fracX.l = 0
    fracY.l = 0
    sy.l = 0
    winsize.l = 128
    If winsize<1 Then winsize = 1
    If winsize>256 Then winsize = 256
    winxs.l = (sxs * winsize) LSR 8 : If winxs<1 Then winxs=1
    winx.l = (sxs-winxs) / 2
    winys.l = (sys * winsize) LSR 8 : If winys<1 Then winys=1
    winy.l = (sys-winys) / 2
    pw.l = winxs*winys

    r.l = pw / $1000
    If r<1 Then r=1
    r=r*r
    pw / (r)
    If pw<1 Then pw=1

    destbase.l   = dstA
    dbpr.l       = dstBPR
    sourcebase.l = srcA
    sbpr.l       = srcBPR
    tmpbase.l    = tmp
    tbpr.l       = tmpbpr
    ; the sharpen step

    For dy.l=0 To dys-1
      fracYR.l = fracY + winy
      cyO.l=0 : While fracYR>dys :fracYR-dys:cyO+1:Wend
      weightY1.l = (dys-fracYR)
      cy.l=0 : fracY+sys : While fracY>dys:fracY-dys:cy+1:Wend
      ny.l = sy+cy
      cyR.l=0 : fracYR+winys : While fracYR>dys :fracYR-dys:cyR+1:Wend
      sy + cyO
      sptr.l = sourcebase + sy * sbpr
      dptr.l = destbase   + dy * dbpr
      tptr.l = tmpbase    + dy * tbpr
      fracX.l = 0

      For dx.l = 0 To dxs-1
        fracXR.l = fracX + winx
        cxO.l=0 : While fracXR>dxs :fracXR-dxs:cxO+1:Wend
        weightX1.l = (dxs-fracXR)
        cx.l=0 : fracX+sxs : While fracX>dxs :fracX-dxs:cx+1:Wend
        cxR.l=0 : fracXR+winxs : While fracXR>dxs :fracXR-dxs:cxR+1:Wend
        ; Calculate the pixel...
        R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
        weightY.l = weightY1
        nsptr.l = sptr + (cx LSL 2)
        sptr + (cxO LSL 2)

        ; get the sourounding ...
        div.l = 0
        aR.l = 0
        aG.l = 0
        aB.l = 0
        If dx>0
          aR.l + (Peek.b(tptr+1-4) & $FF) LSL 1
          aG.l + (Peek.b(tptr+2-4) & $FF) LSL 1
          aB.l + (Peek.b(tptr+3-4) & $FF) LSL 1
          div+2
        End If
        If dx<dxs-1
          aR.l + (Peek.b(tptr+1+4) & $FF) LSL 1
          aG.l + (Peek.b(tptr+2+4) & $FF) LSL 1
          aB.l + (Peek.b(tptr+3+4) & $FF) LSL 1
          div+2
        End If
        If dy>0
          aR.l + (Peek.b(tptr+1-tbpr) & $FF) LSL 1
          aG.l + (Peek.b(tptr+2-tbpr) & $FF) LSL 1
          aB.l + (Peek.b(tptr+3-tbpr) & $FF) LSL 1
          div+2
        End If
        If dy<dys-1
          aR.l + (Peek.b(tptr+1+tbpr) & $FF) LSL 1
          aG.l + (Peek.b(tptr+2+tbpr) & $FF) LSL 1
          aB.l + (Peek.b(tptr+3+tbpr) & $FF) LSL 1
          div+2
        End If

        If dx>0 AND dy>0
          aR.l + (Peek.b(tptr+1-4-tbpr) & $FF)
          aG.l + (Peek.b(tptr+2-4-tbpr) & $FF)
          aB.l + (Peek.b(tptr+3-4-tbpr) & $FF)
          div+1
        End If
        If dx<dxs-1 AND dy<dys-1
          aR.l + (Peek.b(tptr+1+4+tbpr) & $FF)
          aG.l + (Peek.b(tptr+2+4+tbpr) & $FF)
          aB.l + (Peek.b(tptr+3+4+tbpr) & $FF)
          div+1
        End If
        If dy>0 AND dx<dxs-1
          aR.l + (Peek.b(tptr+1+4-tbpr) & $FF)
          aG.l + (Peek.b(tptr+2+4-tbpr) & $FF)
          aB.l + (Peek.b(tptr+3+4-tbpr) & $FF)
          div+1
        End If
        If dy<dys-1 AND dx>0
          aR.l + (Peek.b(tptr+1-4+tbpr) & $FF)
          aG.l + (Peek.b(tptr+2-4+tbpr) & $FF)
          aB.l + (Peek.b(tptr+3-4+tbpr) & $FF)
          div+1
        End If

        If div>0
          aR / div
          aG / div
          aB / div
        End If
        addWeight.l = 0

        For m.l = 0 To cyR
          weightX.l = weightX1
          If m = cyR Then weightY = weightY + (fracYR-dys)
          For n.l = 0 To cxR
            If n = cxR Then weightX = weightX + (fracXR-dxs)
            tpw.l = (weightX*weightY)/(r)
            If tpw<1 Then tpw=1

            tR.l = Peek.b(sptr+1) & $FF
            tG.l = Peek.b(sptr+2) & $FF
            tB.l = Peek.b(sptr+3) & $FF

            dR.l = aR-tR ;: If dR<0 Then dR = -dR
            dG.l = aG-tG ;: If dG<0 Then dG = -dG
            dB.l = aB-tB ;: If dB<0 Then dB = -dB
            f.f = Sqr(dR*dR+dG*dG+dB*dB) * 0.5
            d.l = f
            d = d+1;(d LSR 1) + 1

            tA.l = (Peek.b(sptr  ) & $FF)
            fX.l = (tpw * (d)  * tA) LSR 8
            A = A+(tA*tpw)
            R.l + (tR * fX) : G.l + (tG * fX) : : B.l + (tB * fX)
            addWeight + fX
            weightX = dxs
            sptr+4
          Next
          sptr - 4*(cxR+1) + sbpr
          weightY = dys
        Next
        sptr = nsptr
        A / pw    : If A>255 Then A=255
        If addWeight>0
          R / addWeight  ;: If R>255 Then R=255
          G / addWeight  ;: If G>255 Then G=255
          B / addWeight  ;: If B>255 Then B=255
        End If

        Poke.b dptr  ,A
        Poke.b dptr+1,R
        Poke.b dptr+2,G
        Poke.b dptr+3,B

        dptr+4
        tptr+4
      Next
      sy=ny
    Next

  Default ; sliding window interpolation
    fracY.l = 0
    pw.l = sxs*sys
    r.l = pw / $100000
    If r<1 Then r=1
    r=r*r
    pw / (r)
    For dy.l=0 To dys-1
      weightY1.l = (dys-fracY)
      cy.l=0 : fracY+sys : While fracY>dys:fracY-dys:cy+1:Wend
      sptr.l = srcA + sy * srcBPR
      dptr.l = dstA + dy * dstBPR
      fracX.l = 0
      For dx.l = 0 To dxs-1
        weightX1.l = (dxs-fracX)
        cx.l=0 : fracX+sxs : While fracX>dxs:fracX-dxs:cx+1:Wend

        ; Calculate the pixel...
        R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
        weightY.l = weightY1
        nsptr.l = sptr + (cx LSL 2)
        For m.l = 0 To cy
          weightX.l = weightX1
          If m = cy Then weightY = weightY + (fracY-dys)
          For n.l = 0 To cx
            If n = cx Then weightX = weightX + (fracX-dxs)
            tpw.l = weightX*weightY/r
            A.l + (Peek.b(sptr  ) & $FF) * tpw
            R.l + (Peek.b(sptr+1) & $FF) * tpw
            G.l + (Peek.b(sptr+2) & $FF) * tpw
            B.l + (Peek.b(sptr+3) & $FF) * tpw
            weightX = (dxs)
            sptr+4
          Next
          sptr - 4*(cx+1) + srcBPR
          weightY = (dys)
        Next
        sptr = nsptr

        Poke.b dptr  ,A / pw
        Poke.b dptr+1,R / pw
        Poke.b dptr+2,G / pw
        Poke.b dptr+3,B / pw
        dptr+4
      Next
      sy+cy
    Next
End Select
End Statement
LastRunErrsMode

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_CreatePixelArray {*tbm.tuiBitMap,width.l,height.:: /
;/ l,mode.l}                                                                   /
;/                                                                             /
;/ Description:                                                                /
;/     ; scale step                                                            /
;/         ; Calculate the pixel...                                            /
;/     ; the sharpen step                                                      /
;/         ; Calculate the pixel...                                            /
;/         ; get the sourounding ...                                           /
;/             dR.l = aR-tR ;: If dR<0 Then dR = -dR                           /
;/             dG.l = aG-tG ;: If dG<0 Then dG = -dG                           /
;/             dB.l = aB-tB ;: If dB<0 Then dB = -dB                           /
;/             d = d+1;(d LSR 1) + 1                                           /
;/           R / addWeight  ;: If R>255 Then R=255                             /
;/           G / addWeight  ;: If G>255 Then G=255                             /
;/           B / addWeight  ;: If B>255 Then B=255                             /
;/         ; Calculate the pixel...                                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tbm.tuiBitMap    : ???                                                   /
;/ - width.l    : ???                                                          /
;/ - height.l    : ???                                                         /
;/ - mode.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ntui_CreatePixelArray{*tbm.tuiBitMap,width.l,height.l,mode.l}
If *tbm=#NULL Then Function Return #NULL
If *tbm\pixelArrayA=#NULL Then Function Return #NULL

If *tbm\pixelArraysAlloc<=*tbm\pixelArraysUsed
  ;error {"Extent pixelarray!"}
  newAlloc.l = *tbm\pixelArraysUsed+4
  *newList.tuiPixelArray = AllocVec_ (newAlloc*SizeOf.tuiPixelArray,#MEMF_ANY)
  If *newList
    CopyMem_ *tbm\pixelArrayA,*newList,SizeOf.tuiPixelArray * *tbm\pixelArraysUsed
    If *tbm\pixelArrayA Then FreeVec_ *tbm\pixelArrayA
    *tbm\pixelArrayA  = *newList
    *tbm\pixelArraysAlloc = newAlloc
  End If
End If
If *tbm\pixelArraysAlloc<=*tbm\pixelArraysUsed Then Function Return #NULL

*srcPixelArray.tuiPixelArray = *tbm\pixelArrayA
*dstPixelArray.tuiPixelArray = *tbm\pixelArrayA + SizeOf.tuiPixelArray* *tbm\pixelArraysUsed
*dstPixelArray\normal    = #NULL
*dstPixelArray\active    = #NULL
*dstPixelArray\disabled   = #NULL
*dstPixelArray\focus     = #NULL
*dstPixelArray\mover     = #NULL


If (*srcPixelArray\normal)
  *dstPixelArray\normal = AllocVec_(width*height*4,#MEMF_ANY)
  If (*dstPixelArray\normal)
    _ntui_ScalePixelArray{*srcPixelArray\normal,*srcPixelArray\width,*srcPixelArray\height,*srcPixelArray\width*4,*dstPixelArray\normal,width,height,width*4,mode}
  End If
End If

If (*srcPixelArray\active)
  *dstPixelArray\active = AllocVec_(width*height*4,#MEMF_ANY)
  If (*dstPixelArray\active)
    _ntui_ScalePixelArray{*srcPixelArray\active,*srcPixelArray\width,*srcPixelArray\height,*srcPixelArray\width*4,*dstPixelArray\active,width,height,width*4,mode}
  End If
End If
 
If (*srcPixelArray\disabled)
  *dstPixelArray\disabled = AllocVec_(width*height*4,#MEMF_ANY)
  If (*dstPixelArray\disabled)
    _ntui_ScalePixelArray{*srcPixelArray\disabled,*srcPixelArray\width,*srcPixelArray\height,*srcPixelArray\width*4,*dstPixelArray\disabled,width,height,width*4,mode}
  End If
End If

If (*srcPixelArray\focus)
  *dstPixelArray\focus = AllocVec_(width*height*4,#MEMF_ANY)
  If (*dstPixelArray\focus)
    _ntui_ScalePixelArray{*srcPixelArray\focus,*srcPixelArray\width,*srcPixelArray\height,*srcPixelArray\width*4,*dstPixelArray\focus,width,height,width*4,mode}
  End If
End If

If (*srcPixelArray\mover)
  *dstPixelArray\mover = AllocVec_(width*height*4,#MEMF_ANY)
  If (*dstPixelArray\mover)
    _ntui_ScalePixelArray{*srcPixelArray\mover,*srcPixelArray\width,*srcPixelArray\height,*srcPixelArray\width*4,*dstPixelArray\mover,width,height,width*4,mode}
  End If
End If


*tbm\pixelArraysUsed+1
*dstPixelArray\width  = width
*dstPixelArray\height = height
Function Return *dstPixelArray
End Function
 

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_AccessTBImage {*tbi.tuiTBImage}                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tbi.tuiTBImage    : ???                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ntui_AccessTBImage{*tbi.tuiTBImage}
*tbm.tuiBitMap = *tbi\tuiBitMap
If *tbm
  *tpa.tuiPixelArray = *tbm\pixelArrayA
  If *tbi\tuiWidth =#TUISIZE_NATIVE Then width.l =*tbm\pixelArrayA\width  : Else width =*tbi\tuiEngine\defSize[*tbi\tuiWidth]
  If *tbi\tuiHeight=#TUISIZE_NATIVE Then height.l=*tbm\pixelArrayA\height : Else height=*tbi\tuiEngine\defSize[*tbi\tuiHeight]

  If (*tbm\pixelArrayA\height)>0
    swidth.l    = *tbm\pixelArrayA\width  * height / *tbm\pixelArrayA\height
    If swidth<width   Then width = swidth
  End If
  If (*tbm\pixelArrayA\width>0)
    sheight.l   = *tbm\pixelArrayA\height * width  / *tbm\pixelArrayA\width
    If sheight<height Then height =sheight
  End If
  ; find the bitmap...
  For n.l=0 To *tbm\pixelArraysUsed-1
    *tpa.tuiPixelArray = *tbm\pixelArrayA + n*SizeOf.tuiPixelArray
    If *tpa\height = height AND *tpa\width <=width  Then Function Return *tpa
    If *tpa\width  = width  AND *tpa\height<=height Then Function Return *tpa
  Next
  *tpa = _ntui_CreatePixelArray{*tbm,width,height,2}
Else
  *tpa=#NULL
End If
Function Return *tpa
End Function




;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_GetTBImageWidth {*tbi.tuiTBImage}                   /
;/                                                                             /
;/ Description:                                                                /
;/   ; find the bitmap...                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tbi.tuiTBImage    : ???                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ntui_GetTBImageWidth{*tbi.tuiTBImage}
*tpa.tuiPixelArray=_ntui_AccessTBImage{*tbi}
If *tpa Then Function Return *tpa\width
If *tbi\tuiWidth=#TUISIZE_NATIVE
  If *tbi\tuiBitMap
    Function Return *tbi\tuiBitMap\pixelArrayA\width
  Else
    Function Return *tbi\tuiEngine\defSize[#TUISIZE_NATIVE];24
  End If
End If
Function Return *tbi\tuiEngine\defSize[*tbi\tuiWidth]
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_GetTBImageHeight {*tbi.tuiTBImage}                  /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tbi.tuiTBImage    : ???                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ntui_GetTBImageHeight{*tbi.tuiTBImage}
*tpa.tuiPixelArray=_ntui_AccessTBImage{*tbi}
If *tpa Then Function Return *tpa\height
If *tbi\tuiHeight=#TUISIZE_NATIVE
  If *tbi\tuiBitMap
    Function Return *tbi\tuiBitMap\pixelArrayA\height
  Else
    Function Return *tbi\tuiEngine\defSize[#TUISIZE_NATIVE]
  End If
End If
Function Return *tbi\tuiEngine\defSize[*tbi\tuiHeight]
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ntui_FreeBitMapCache {}                                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ntui_FreeBitMapCache{}
If tuiGlobal\bitMapCache\tuiBitMapA
  For n.l=0 To tuiGlobal\bitMapCache\tuiBitMapsUsed-1
    *tbm.tuiBitMap = Peek.l(tuiGlobal\bitMapCache\tuiBitMapA + (SizeOf.l*n))
    If *tbm
      If *tbm\pixelArrayA
        For m.l=0 To *tbm\pixelArraysUsed-1
          *tpa.tuiPixelArray = *tbm\pixelArrayA + (SizeOf.tuiPixelArray*m)
          If *tpa\active   Then FreeVec_ *tpa\active   : *tpa\active   =#NULL
          If *tpa\normal   Then FreeVec_ *tpa\normal   : *tpa\normal   =#NULL
          If *tpa\focus    Then FreeVec_ *tpa\focus    : *tpa\focus    =#NULL
          If *tpa\mover    Then FreeVec_ *tpa\mover    : *tpa\mover    =#NULL
          If *tpa\disabled Then FreeVec_ *tpa\disabled : *tpa\disabled =#NULL
        Next
        FreeVec_ *tbm\pixelArrayA
      End If
      *tbm\pixelArrayA=#NULL
      *tbm\pixelArraysUsed     = 0
      *tbm\pixelArraysAlloc = 0
      FreeVec_ *tbm
      Poke.l tuiGlobal\bitMapCache\tuiBitMapA + (4*n),0
    End If

  Next
  FreeVec_ tuiGlobal\bitMapCache\tuiBitMapA
End If
tuiGlobal\bitMapCache\tuiBitMapA      = #NULL
tuiGlobal\bitMapCache\tuiBitMapsUsed  = 0
tuiGlobal\bitMapCache\tuiBitMapsAlloc = 0
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_CreateTBImage {*tuiEngine.tuiEngine,image.s,@tuiW:: /
;/ idth.l,@tuiHeight.l}                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tuiEngine.tuiEngine    : ???                                             /
;/ - image.s    : ???                                                          /
;/ - tuiWidth.l    : ???                                                       /
;/ - tuiHeight.l    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Dim tuiAISS.s(#TUIMAX_IMAGES-1)
SHARED tuiAISS()
tuiAISS(#TUIIMAGE_CHECKMARK ) = "TBImages:list_checkmark"
tuiAISS(#TUIIMAGE_PATH      ) = "TBImages:folder"
tuiAISS(#TUIIMAGE_FILE      ) = "TBImages:file"
tuiAISS(#TUIIMAGE_SAVE      ) = "TBImages:save"
tuiAISS(#TUIIMAGE_FONT      ) = "TBImages:font_type"
tuiAISS(#TUIIMAGE_SCREEN    ) = "TBImages:screen"
tuiAISS(#TUIIMAGE_CYCLE     ) = "TBImages:refresh"
tuiAISS(#TUIIMAGE_PLUS      ) = "TBImages:add"
tuiAISS(#TUIIMAGE_MINUS     ) = "TBImages:remove"
tuiAISS(#TUIIMAGE_ARROWUP   ) = "TBImages:scrollup"
tuiAISS(#TUIIMAGE_ARROWDOWN ) = "TBImages:scrolldown"
tuiAISS(#TUIIMAGE_ARROWLEFT ) = "TBImages:scrollleft"
tuiAISS(#TUIIMAGE_ARROWRIGHT) = "TBImages:scrollright"



Function.l ntui_CreateTBImage{*tuiEngine.tuiEngine,image.s,@tuiWidth.l,@tuiHeight.l}
If *tuiEngine=#NULL Then Function Return #NULL
*tbi.tuiTBImage = AllocVec_ (SizeOf.tuiTBImage,#MEMF_CLEAR)
If *tbi

  *tbi\tuiEngine = *tuiEngine
  If tuiWidth<=0  Then *tbi\tuiWidth     = #TUISIZE_NATIVE : Else *tbi\tuiWidth  = tuiWidth
  If tuiHeight<=0 Then *tbi\tuiHeight    = #TUISIZE_NATIVE : Else *tbi\tuiHeight = tuiHeight
  *tbi\tuiBitMap = #NULL

  Select image
    Case ""             : *tbi\tuiImage = #TUIIMAGE_UNKNOWN      ; default image
    Case "CHECKMARK"    : *tbi\tuiImage = #TUIIMAGE_CHECKMARK    ; checkbox
    Case "UNCHECKMARK"  : *tbi\tuiImage = #TUIIMAGE_CHECKMARK2   ; checkbox
    Case "CHECKON"      : *tbi\tuiImage = #TUIIMAGE_CHECKON    ; checkbox
    Case "CHECKOFF"     : *tbi\tuiImage = #TUIIMAGE_CHECKOFF   ; checkbox
    Case "PATH"         : *tbi\tuiImage = #TUIIMAGE_PATH         ; for ASLFR
    Case "FILE"         : *tbi\tuiImage = #TUIIMAGE_FILE         ; for ASLFR
    Case "FONT"         : *tbi\tuiImage = #TUIIMAGE_FONT         ; for ASLFO
    Case "SCREEN"       : *tbi\tuiImage = #TUIIMAGE_SCREEN       ; for ASLSR
    Case "ARROWUP"      : *tbi\tuiImage = #TUIIMAGE_ARROWUP      ; scroller arrows
    Case "ARROWLEFT"    : *tbi\tuiImage = #TUIIMAGE_ARROWLEFT
    Case "ARROWRIGHT"   : *tbi\tuiImage = #TUIIMAGE_ARROWRIGHT
    Case "ARROWDOWN"    : *tbi\tuiImage = #TUIIMAGE_ARROWDOWN
    Case "CYCLE"        : *tbi\tuiImage = #TUIIMAGE_CYCLE        ; cycle gadget
    Case "PLUSMINUS"    : *tbi\tuiImage = #TUIIMAGE_PLUSMINUS
    Case "PLUS"         : *tbi\tuiImage = #TUIIMAGE_PLUS
    Case "MINUS"        : *tbi\tuiImage = #TUIIMAGE_MINUS
    Case "SAVE"         : *tbi\tuiImage = #TUIIMAGE_SAVE
    Case "POPUP"        : *tbi\tuiImage = #TUIIMAGE_POPUP
    Case "OLARROWUP"    : *tbi\tuiImage = #TUIIMAGE_OLARROWUP    ; scroller arrows
    Case "OLARROWLEFT"  : *tbi\tuiImage = #TUIIMAGE_OLARROWLEFT
    Case "OLARROWRIGHT" : *tbi\tuiImage = #TUIIMAGE_OLARROWRIGHT
    Case "OLARROWDOWN"  : *tbi\tuiImage = #TUIIMAGE_OLARROWDOWN
    Case "POPUP"        : *tbi\tuiImage = #TUIIMAGE_POPUP        ; menu arrows
    Case "DROPDOWN"     : *tbi\tuiImage = #TUIIMAGE_DROPDOWN
    Case "LEFT"         : *tbi\tuiImage = #TUIIMAGE_LEFT
    Case "RIGHT"        : *tbi\tuiImage = #TUIIMAGE_RIGHT
    Case "AMIGA"        : *tbi\tuiImage = #TUIIMAGE_AMIGA
    Case "CTRL"         : *tbi\tuiImage = #TUIIMAGE_CTRL
    Case "SHIFT"        : *tbi\tuiImage = #TUIIMAGE_SHIFT
    Case "ALT"          : *tbi\tuiImage = #TUIIMAGE_ALT
    Case "RADIOON"      : *tbi\tuiImage = #TUIIMAGE_RADIOON
    Case "RADIOOFF"     : *tbi\tuiImage = #TUIIMAGE_RADIOOFF
    Case "DELETE"       : *tbi\tuiImage = #TUIIMAGE_DELETE
    Case "EDIT"         : *tbi\tuiImage = #TUIIMAGE_EDIT
    Case "NEW"          : *tbi\tuiImage = #TUIIMAGE_NEW
    Default             : *tbi\tuiImage = #TUIIMAGE_BITMAP
      ; resolve NTUI: path
      If Left$(image,5)="NTUI:"
        image = str_Read{&*tuiEngine\skinPath}+"/"+Right$(image,FLen(image)-5)
      End If
      *tbi\tuiBitMap = _ntui_ObtainTuiBitMap{image}
      If *tbi\tuiBitMap=#NULL Then *tbi\tuiImage = #TUIIMAGE_UNKNOWN
  End Select

  If *tuiEngine\useAISS
    If tuiAISS(*tbi\tuiImage)><"" ; map to AISS!
        *tbi\tuiBitMap = _ntui_ObtainTuiBitMap{tuiAISS(*tbi\tuiImage)}
        If *tbi\tuiBitMap Then *tbi\tuiImage = #TUIIMAGE_BITMAP
    End If
  End If
End If
Function Return *tbi
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_FreeTBImage {*tbi.tuiTBImage}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tbi.tuiTBImage    : ???                                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_FreeTBImage{*tbi.tuiTBImage}
If *tbi=#NULL Then Statement Return
If *tbi\tuiBitMap Then _ntui_ReleaseTuiBitMap{*tbi\tuiBitMap} : *tbi\tuiBitMap = #NULL
FreeVec_ *tbi
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_DrawTBImage {*tbi.tuiTBImage,*rp.RastPort,x1.l,y1.l,x2.l,y2.:: /
;/ l,flags.l,bgTuiPen.l}                                                       /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tbi.tuiTBImage    : ???                                                  /
;/ - *rp.RastPort    : ???                                                     /
;/ - x1.l    : ???                                                             /
;/ - y1.l    : ???                                                             /
;/ - x2.l    : ???                                                             /
;/ - y2.l    : ???                                                             /
;/ - flags.l    : ???                                                          /
;/ - bgTuiPen.l    : ???                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_DrawTBImage{*tbi.tuiTBImage,*rp.RastPort,*bbox.tuiRect,*cbox.tuiRect,flags.l,bgTuiPen.l}
If *tbi=#NULL Then Statement Return
*tuiEngine.tuiEngine = *tbi\tuiEngine
If *tuiEngine=#NULL Then Statement Return

If bgTuiPen>=0
  bgPen.l  = *tuiEngine\pen[bgTuiPen]
  bgARGB.l = *tuiEngine\penInfo[bgTuiPen]\ARGB
Else
  bgPen.l  = -1
  bgARGB.l = -1
End If

x1.l = *cbox\left
y1.l = *cbox\top
x2.l = *cbox\right
y2.l = *cbox\bottom

If *tbi\tuiImage><#TUIIMAGE_BITMAP
  If bgPen>=0
    SetAPen_ *rp,bgPen
    RectFill_ *rp,*bbox\left,*bbox\top,*bbox\right,*bbox\bottom
  End If
End If

CNIF #TUI_DEBUG
    SetAPen_ *rp,1
    RectFill_ *rp,*bbox\left,*bbox\top,*bbox\right,*bbox\bottom
    SetAPen_ *rp,2
    RectFill_ *rp,*cbox\left,*cbox\top,*cbox\right,*cbox\bottom
    bgPen=-1
CEND


If (flags&#TUIF_DISABLED)
  fgPen.l = *tuiEngine\pen[#TUIPEN_HALFSHADOW]
 Else
  If (flags&#TUIF_ACTIVE)
    fgPen = *tuiEngine\pen[#TUIPEN_WHITE]
  Else
    fgPen = *tuiEngine\pen[#TUIPEN_BLACK]
  End If
End If

SetAPen_ *rp,fgPen

sizey.l = *tuiEngine\defSize[*tbi\tuiHeight]
sizex.l = *tuiEngine\defSize[*tbi\tuiWidth]

If sizex<sizey Then size.l=sizex: Else size.l=sizey

Macro _ntui_keyborder
sx2.l = (size-1)/2
sy2.l = (size)/3
x.l = (x1+x2)/2
y.l = (y1+y2)/2

If sy2<#TUI_MINPIXELSIZE/2+2 Then sy2=#TUI_MINPIXELSIZE/2+2
If sx2<#TUI_MINPIXELSIZE/2+2 Then sx2=#TUI_MINPIXELSIZE/2+2
If sy2*2<sizey AND sx2*2<sizex
  pen.l = *rp\FgPen
  SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHINE]

  RectFill_ *rp,x-sx2+1,y-sy2+1,x+sx2-1,y+sy2-1
  SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHINE]
  Move_ *rp,x-sx2+1,y-sy2 : Draw_ *rp,x+sx2-1,y-sy2 ; button
  Move_ *rp,x-sx2,y-sy2+1 : Draw_ *rp,x-sx2,y+sy2-1

;   Move_ *rp,x-sx2-1,y-sy2-1 : Draw_ *rp,x+sx2+1,y-sy2-1
;   Move_ *rp,x-sx2-1,y-sy2-1 : Draw_ *rp,x-sx2-1,y+sy2+1

  SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHADOW]
  Move_ *rp,x+sx2,y-sy2+1 : Draw_ *rp,x+sx2,y+sy2-1
  Move_ *rp,x-sx2+1,y+sy2 : Draw_ *rp,x+sx2-1,y+sy2

  ;SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHADOW]
  Move_ *rp,x-sx2+1-1,y+sy2+1 : Draw_ *rp,x+sx2,y+sy2+1
  Move_ *rp,x+sx2+1,y-sy2+1-1 : Draw_ *rp,x+sx2+1,y+sy2
  WritePixel_ *rp,x+sx2,y+sy2
  SetAPen_ *rp,pen
End If
End Macro
 


Select *tbi\tuiImage
  Case #TUIIMAGE_AMIGA
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    !_ntui_keyborder

    x.l = (x1+x2)/2
    y.l = (y1+y2)/2

    sy2.l = (size)/3-2
    If sy2<#TUI_MINPIXELSIZE/2 Then sy2=#TUI_MINPIXELSIZE/2
    sx2.l=sy2
    Move_ *rp,x+sx2,y-sy2     : Draw_ *rp,x+sx2,y+sy2 ; A
    Move_ *rp,x+sx2-1,y-sy2+1 : Draw_ *rp,x+sx2-1,y+sy2
    Move_ *rp,x+sx2,y-sy2 : Draw_ *rp,x-sx2,y+sy2
    Move_ *rp,x,y+1 : Draw_ *rp,x+sx2,y+1

    Move_ *rp,x+sx2-2,y+sy2     : Draw_ *rp,x+sx2+1,y+sy2 ; A
    Move_ *rp,x-sx2-1,y+sy2     : Draw_ *rp,x-sx2+1,y+sy2 ; A

  Case #TUIIMAGE_SHIFT
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    !_ntui_keyborder

    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    sy2=size/3-2
    If sy2<#TUI_MINPIXELSIZE/2 Then sy2=#TUI_MINPIXELSIZE/2
    sx2=sy2/2
    sh.l = sx2+1
    Move_ *rp,x-sx2,y+sy2 : Draw_ *rp,x-sx2,y-sy2+sh
    Move_ *rp,x+sx2,y+sy2 : Draw_ *rp,x+sx2,y-sy2+sh

    Move_ *rp,x,y-sy2 : Draw_ *rp,x-sh,y-sy2+sh
    Move_ *rp,x,y-sy2 : Draw_ *rp,x+sh,y-sy2+sh
    Move_ *rp,x-sx2,y+sy2 : Draw_ *rp,x+sx2,y+sy2

  Case #TUIIMAGE_CTRL
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    !_ntui_keyborder

    ys.l = 6
    xs.l = 3
    x = (x1+x2-size)/2+2
    y = (y1+y2)/2 -ys/2

    xblow.l = (size-4-4-4-3-4)/4
    If xblow<0 Then xblow=0
    size.l = xblow*4 + 4+4+4+3
    x = (x1+x2)/2 - size/2

    xs.l = 3 + xblow
    Move_ *rp,x,y+1      : Draw_ *rp,x,y+ys-2                ; C
    Move_ *rp,x+1,y      : Draw_ *rp,x+xs-1,y
    Move_ *rp,x+1,y+ys-1 : Draw_ *rp,x+xs-1,y+ys-1
    x+xs+1
    xs=3 + xblow
    Move_ *rp,x,y : Draw_ *rp,x+xs-1,y; T
    Move_ *rp,x+xs/2,y : Draw_ *rp,x+xs/2,y+ys-1
    x + xs+1
    xs = 3 + xblow
    Move_ *rp,x,y : Draw_ *rp,x,y+ys-1 ; R
    Move_ *rp,x,y : Draw_ *rp,x+xs-1,y
    Move_ *rp,x,y+ys/2 : Draw_ *rp,x+xs-1,y+ys/2
    Move_ *rp,x+xs-1,y : Draw_ *rp,x+xs-1,y+ys/2
    Move_ *rp,x,y+ys/2 : Draw_ *rp,x+xs-1,y+ys-1
    x+xs+1
    xs=2 + xblow
    Move_ *rp,x,y : Draw_ *rp,x,y+ys-1 ; L
    Move_ *rp,x,y+ys-1 : Draw_ *rp,x+xs-1,y+ys-1


  Case #TUIIMAGE_ALT
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    !_ntui_keyborder

    ys.l = 6
    xs.l = 3
    x = (x1+x2-size)/2+2
    y = (y1+y2)/2 -ys/2

    xblow.l = (size-4-2-4-4)/3
    If xblow<0 Then xblow=0

    size.l = xblow*3 + 4+2+4
    x = (x1+x2)/2 - size/2
    xs.l = 3 + xblow
    Move_ *rp,x,y+1      : Draw_ *rp,x,y+ys-1                ; A
    Move_ *rp,x+xs-1,y+1 : Draw_ *rp,x+xs-1,y+ys-1
    Move_ *rp,x+1,y      : Draw_ *rp,x+xs-1-1,y
    Move_ *rp,x,y+ys/2 : Draw_ *rp,x+xs-1,y+ys/2
    x+xs+1
    xs=1 + xblow
    Move_ *rp,x,y      : Draw_ *rp,x,y+ys-1 ; L
    Move_ *rp,x,y+ys-1 : Draw_ *rp,x+xs,y+ys-1
    x + xs+1
    xs = 3 + xblow
    Move_ *rp,x,y      : Draw_ *rp,x+xs-1,y ; T
    Move_ *rp,x+xs/2,y : Draw_ *rp,x+xs/2,y+ys-1


  Case #TUIIMAGE_CYCLE
    If size>14 Then size*5/6
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    sizex = size-size/4
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    a.tuiPixel\x = x-size/2         ,y-size/2
    b.tuiPixel\x = x+size/2 -size/8 ,y+size/2
    c.tuiPixel\x = x-size/3         ,y-size/3
    d.tuiPixel\x = x+size/3 -size/8 ,y+size/3

    Move_ *rp,c\x,a\y:Draw_ *rp,d\x,a\y:Draw_ *rp,b\x,c\y:Draw_ *rp,b\x,d\y:Move_ *rp,d\x,b\y:Draw_ *rp,c\x,b\y:Draw_ *rp,a\x,d\y:Draw_ *rp,a\x,c\y:Draw_ *rp,c\x,a\y
    Move_ *rp,c\x+1,a\y+1:Draw_ *rp,d\x-1,a\y+1:Draw_ *rp,b\x-1,c\y+1:Draw_ *rp,b\x-1,d\y-1:Move_ *rp,d\x-1,b\y-1:Draw_ *rp,c\x+1,b\y-1:Draw_ *rp,a\x+1,d\y-1:Draw_ *rp,a\x+1,c\y+1:Draw_ *rp,c\x+1,a\y+1
    Move_ *rp,c\x+1,a\y:Draw_ *rp,d\x-1,a\y:Draw_ *rp,b\x-1,c\y:Draw_ *rp,b\x-1,d\y:Move_ *rp,d\x-1,b\y:Draw_ *rp,c\x+1,b\y:Draw_ *rp,a\x+1,d\y:Draw_ *rp,a\x+1,c\y:Draw_ *rp,c\x+1,a\y

    For n.l=0 To size/4
      Move_ *rp,b\x-n-1,d\y-n
      Draw_ *rp,b\x+n,d\y-n
    Next

  Case #TUIIMAGE_RADIOOFF
    If size>14 Then size*5/6
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    size/4
    size*4

    w.l = size/2
    a\x = x-w,y-w
    b\x = x-w/2,y-w/2
    c\x = x+w/2,y+w/2
    d\x = x+w,y+w
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHADOW]
    End If

    Move_ *rp,b\x,a\y
    Draw_ *rp,c\x,a\y
    SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    Draw_ *rp,d\x,b\y
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHINE]
    End If
    Draw_ *rp,d\x,c\y
    Draw_ *rp,c\x,d\y
    Draw_ *rp,b\x,d\y
    SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    Draw_ *rp,a\x,c\y
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHADOW]
    End If

    Draw_ *rp,a\x,b\y
    Draw_ *rp,b\x,a\y

    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHINE]
    End If
    w.l = (size/2) -2
    a\x = x-w,y-w
    b\x = x-w/2,y-w/2
    c\x = x+w/2,y+w/2
    d\x = x+w,y+w
    For n.l=0 To w
      Move_ *rp,x-w,y-n
      Draw_ *rp,x+w,y-n
      Move_ *rp,x-w,y+n
      Draw_ *rp,x+w,y+n
      If n>=w/2 Then w=w-1
    Next

    If (flags&(#TUIF_ACTIVE))
      SetAPen_ *rp,fgPen
      w.l = (size/4) -1
      a\x = x-w,y-w
      b\x = x-w/2,y-w/2
      c\x = x+w/2,y+w/2
      d\x = x+w,y+w

      For n.l=0 To w
        Move_ *rp,x-w,y-n
        Draw_ *rp,x+w,y-n
        Move_ *rp,x-w,y+n
        Draw_ *rp,x+w,y+n
        If n>=w/2 Then w=w-1
      Next
    EndIf

  Case #TUIIMAGE_CHECKON
    If size>14 Then size*5/6
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHINE]
    End If

    RectFill_ *rp,x-size/2+2,y-size/2+2,x+size/2-2,y+size/2-2

    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_WHITE]
    End If

    Move_ *rp,x+size/2,y-size/2
    Draw_ *rp,x+size/2,y+size/2
    Draw_ *rp,x-size/2,y+size/2
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHADOW]
    End If

    Draw_ *rp,x-size/2,y-size/2
    Draw_ *rp,x+size/2,y-size/2

    SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    WritePixel_ *rp,x-size/2,y+size/2
    WritePixel_ *rp,x+size/2,y-size/2

    SetAPen_ *rp,fgPen
    a.tuiPixel\x = x+size/2-3,y-size/2+3
    b.tuiPixel\x = x-size/2+3,y+size/2-3
    c.tuiPixel\x = x-size/2+3,y-1

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x+1,a\y
    Draw_  *rp,b\x+1,b\y
    Draw_  *rp,c\x+1,c\y

  Case #TUIIMAGE_CHECKOFF
    If size>14 Then size*5/6
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHINE]
    End If

    RectFill_ *rp,x-size/2+2,y-size/2+2,x+size/2-2,y+size/2-2

    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_WHITE]
    End If

    Move_ *rp,x+size/2,y-size/2
    Draw_ *rp,x+size/2,y+size/2
    Draw_ *rp,x-size/2,y+size/2
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHADOW]
    End If

    Draw_ *rp,x-size/2,y-size/2
    Draw_ *rp,x+size/2,y-size/2

    SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    WritePixel_ *rp,x-size/2,y+size/2
    WritePixel_ *rp,x+size/2,y-size/2

    If (flags&(#TUIF_ACTIVE))
      SetAPen_ *rp,fgPen
      a.tuiPixel\x = x+size/2-3,y-size/2+3
      b.tuiPixel\x = x-size/2+3,y+size/2-3
      c.tuiPixel\x = x-size/2+3,y-1

      Move_  *rp,a\x,a\y
      Draw_  *rp,b\x,b\y
      Draw_  *rp,c\x,c\y

      Move_  *rp,a\x+1,a\y
      Draw_  *rp,b\x+1,b\y
      Draw_  *rp,c\x+1,c\y
    End If

  Case #TUIIMAGE_RADIOON
    If size>14 Then size*5/6
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    size/4
    size*4

    w.l = size/2
    a\x = x-w,y-w
    b\x = x-w/2,y-w/2
    c\x = x+w/2,y+w/2
    d\x = x+w,y+w
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHADOW]
    End If
    Move_ *rp,b\x,a\y
    Draw_ *rp,c\x,a\y
    SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    Draw_ *rp,d\x,b\y
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHINE]
    End If
    Draw_ *rp,d\x,c\y
    Draw_ *rp,c\x,d\y
    Draw_ *rp,b\x,d\y
    SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    Draw_ *rp,a\x,c\y
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHADOW]
    End If
    Draw_ *rp,a\x,b\y
    Draw_ *rp,b\x,a\y

    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHINE]
    End If
    w.l = (size/2) -2
    a\x = x-w,y-w
    b\x = x-w/2,y-w/2
    c\x = x+w/2,y+w/2
    d\x = x+w,y+w

    For n.l=0 To w
      Move_ *rp,x-w,y-n
      Draw_ *rp,x+w,y-n
      Move_ *rp,x-w,y+n
      Draw_ *rp,x+w,y+n
      If n>=w/2 Then w=w-1
    Next

    SetAPen_ *rp,fgPen
    w.l = (size/4) -1
    a\x = x-w,y-w
    b\x = x-w/2,y-w/2
    c\x = x+w/2,y+w/2
    d\x = x+w,y+w

    For n.l=0 To w
      Move_ *rp,x-w,y-n
      Draw_ *rp,x+w,y-n
      Move_ *rp,x-w,y+n
      Draw_ *rp,x+w,y+n
      If n>=w/2 Then w=w-1
    Next

  Case #TUIIMAGE_OLARROWUP
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2)/2
    y.l = (y1+y2-size+1)/2
    Move_ *rp,x-size/2,y+size-1 : Draw_ *rp,x+size/2,y+size-1
    Move_ *rp,x ,y : Draw_ *rp,x+size/2,y+size-1
    Move_ *rp,x ,y : Draw_ *rp,x-size/2,y+size-1

  Case #TUIIMAGE_OLARROWDOWN
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2)/2
    y.l = (y1+y2-size+1)/2
    x1 = x-size/2
    x2 = x+size/2
    y1 = y
    y2 = y+size-1
    Move_ *rp,x1,y1 : Draw_ *rp,x2,y1
    Move_ *rp,x ,y2 : Draw_ *rp,x1,y1
    Move_ *rp,x ,y2 : Draw_ *rp,x2,y1

  Case #TUIIMAGE_OLARROWRIGHT
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2-size+1)/2
    y.l = (y1+y2)/2
    x1 = x : x2 = x+size-1
    y1 = y - size/2 : y2=y+size/2
    Move_ *rp,x1,y1 : Draw_ *rp,x1,y2
    Move_ *rp,x1,y1 : Draw_ *rp,x2,y
    Move_ *rp,x1,y2 : Draw_ *rp,x2,y

  Case #TUIIMAGE_OLARROWLEFT
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2-size+1)/2
    y.l = (y1+y2)/2
    x1 = x : x2 = x+size-1
    y1 = y - size/2 : y2=y+size/2
    Move_ *rp,x2,y1 : Draw_ *rp,x2,y2
    Move_ *rp,x2,y1 : Draw_ *rp,x1,y
    Move_ *rp,x2,y2 : Draw_ *rp,x1,y

  Case #TUIIMAGE_LEFT
    size/2+1 : If size<6 Then size=6
    x.l = (x1+x2-size+1)/2
    y.l = (y1+y2)/2
    s2.l = size/2
    x1 = x : x2 = x1+s2-1 : x3.l=x1+s2+1 : x4.l=x3+s2-1

    y1 = y-s2+1 : y2=y+s2-1
    Move_ *rp,x2,y1 : Draw_ *rp,x1,y
    Move_ *rp,x2,y2 : Draw_ *rp,x1,y
    Move_ *rp,x4,y1 : Draw_ *rp,x3,y
    Move_ *rp,x4,y2 : Draw_ *rp,x3,y

    Move_ *rp,x2-1,y1 : Draw_ *rp,x1-1,y
    Move_ *rp,x2-1,y2 : Draw_ *rp,x1-1,y
    Move_ *rp,x4-1,y1 : Draw_ *rp,x3-1,y
    Move_ *rp,x4-1,y2 : Draw_ *rp,x3-1,y

    Move_ *rp,x2,y1+1 : Draw_ *rp,x1+1,y
    Move_ *rp,x2,y2-1 : Draw_ *rp,x1+1,y
    Move_ *rp,x4,y1+1 : Draw_ *rp,x3+1,y
    Move_ *rp,x4,y2-1 : Draw_ *rp,x3+1,y

  Case #TUIIMAGE_RIGHT
    size/2+1 : If size<6 Then size=6
    x.l = (x1+x2+size)/2
    y.l = (y1+y2)/2
    s2.l = size/2
    x1 = x : x2 = x1-s2+1 : x3 = x1-s2-1 : x4.l=x3-s2+1
    y1 = y-s2+1 : y2=y+s2-1
    Move_ *rp,x2,y1 : Draw_ *rp,x1,y
    Move_ *rp,x2,y2 : Draw_ *rp,x1,y
    Move_ *rp,x4,y1 : Draw_ *rp,x3,y
    Move_ *rp,x4,y2 : Draw_ *rp,x3,y

    Move_ *rp,x2+1,y1 : Draw_ *rp,x1+1,y
    Move_ *rp,x2+1,y2 : Draw_ *rp,x1+1,y
    Move_ *rp,x4+1,y1 : Draw_ *rp,x3+1,y
    Move_ *rp,x4+1,y2 : Draw_ *rp,x3+1,y

    Move_ *rp,x2,y1+1 : Draw_ *rp,x1-1,y
    Move_ *rp,x2,y2-1 : Draw_ *rp,x1-1,y
    Move_ *rp,x4,y1+1 : Draw_ *rp,x3-1,y
    Move_ *rp,x4,y2-1 : Draw_ *rp,x3-1,y

  Case #TUIIMAGE_DROPDOWN
    size/2+1 : If size<4 Then size=4
    x.l = (x1+x2)/2
    ys2.l = size/2
    y.l = (y1+y2-ys2-2)/2
    x1.l = x-ys2
    x2.l = x+ys2
    Move_ *rp,x1,y+ys2+2   : Draw_ *rp,x2,y+ys2+2
    Move_ *rp,x1,y+ys2+3   : Draw_ *rp,x2,y+ys2+3

    Move_ *rp,x1  ,y       : Draw_ *rp,x,y +ys2
    Move_ *rp,x1+1,y-1     : Draw_ *rp,x,y +ys2-2
    Move_ *rp,x2  ,y       : Draw_ *rp,x,y +ys2
    Move_ *rp,x2-1,y-1     : Draw_ *rp,x,y +ys2-2
    Move_ *rp,x1  ,y-1     : Draw_ *rp,x,y-1+ys2
    Move_ *rp,x2  ,y-1     : Draw_ *rp,x,y-1+ys2

  Case #TUIIMAGE_POPUP
    size/2+1 : If size<4 Then size=4
    x.l = (x1+x2)/2
    ys2.l = size/2
    y.l = (y1+y2-ys2-2)/2
    x1.l = x-ys2
    x2.l = x+ys2
    Move_ *rp,x1,y+ys2+2   : Draw_ *rp,x2,y+ys2+2
    Move_ *rp,x1,y+ys2+3   : Draw_ *rp,x2,y+ys2+3

    Move_ *rp,x1  ,y+ys2   : Draw_ *rp,x,y
    Move_ *rp,x1+1,y+ys2   : Draw_ *rp,x,y+1
    Move_ *rp,x2  ,y+ys2   : Draw_ *rp,x,y
    Move_ *rp,x2-1,y+ys2   : Draw_ *rp,x,y+1
    Move_ *rp,x1  ,y+ys2-1 : Draw_ *rp,x,y-1
    Move_ *rp,x2  ,y+ys2-1 : Draw_ *rp,x,y-1

  Case #TUIIMAGE_ARROWUP
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2)/2
    y.l = (y1+y2-size+1)/2
    For n.l=0 To size-1
      Move_ *rp,x-n/2,y+n
      Draw_ *rp,x+n/2,y+n
    Next

  Case #TUIIMAGE_ARROWDOWN
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2)/2
    y.l = (y1+y2-size+1)/2
    For n.l=0 To size-1
      Move_ *rp,x-n/2,y+size-n-1
      Draw_ *rp,x+n/2,y+size-n-1
    Next

  Case #TUIIMAGE_ARROWRIGHT
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2-size+1)/2
    y.l = (y1+y2)/2
    For n.l=0 To size-1
      Move_ *rp,x+size-n-1,y-n/2
      Draw_ *rp,x+size-n-1,y+n/2
    Next

  Case #TUIIMAGE_ARROWLEFT
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2-size+1)/2
    y.l = (y1+y2)/2
    For n.l=0 To size-1
      Move_ *rp,x+n,y-n/2
      Draw_ *rp,x+n,y+n/2
    Next

  Case #TUIIMAGE_PATH
    If size>12 Then size=size*5/6 -2
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1

    xd.l = (x1+x2-1)/2 -x1 -size/2
    yd.l = (y1+y2-1)/2 -y1 -size/2
    If xd<0 Then xd=0
    If yd<0 Then yd=0

    a.tuiPixel\x = x1+xd,y1+yd
    b.tuiPixel\x = x2-xd,y2-yd

    th.l = size/4;*3/10
    If th<2 Then th=2
    c.tuiPixel\x = (x1+x2)/2-th/2,a\y+th
    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,b\y : Draw_ *rp,b\x,b\y : Draw_ *rp,b\x,c\y : Draw_ *rp,a\x,c\y
    Move_ *rp,a\x,a\y : Draw_ *rp,c\x,a\y : Draw_ *rp,c\x+th,c\y

  Case #TUIIMAGE_FILE
    If size>12 Then size=size*5/6 -2
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1

    xd.l = (x1+x2-1)/2 -x1 -size*9/20
    yd.l = (y1+y2-1)/2 -y1 -size/2
    If xd<0 Then xd=0
    If yd<0 Then yd=0

    a.tuiPixel\x = x1+xd,y1+yd
    b.tuiPixel\x = x2-xd,y2-yd
    c.tuiPixel\x = b\x-size/6-2,a\y+size/6+2

    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,b\y : Draw_ *rp,b\x,b\y : Draw_ *rp,b\x,c\y : Draw_ *rp,c\x,a\y : Draw_ *rp,a\x,a\y
    Move_ *rp,c\x,a\y : Draw_ *rp,c\x,c\y : Draw_ *rp,b\x,c\y

   offset.l = 2
   If size>12 Then offset=3
    For n.l=a\y+offset To b\y-offset Step 2
      If n>c\y+1
         Move_ *rp,a\x+offset,n : Draw_ *rp,b\x-offset,n
      Else
         Move_ *rp,a\x+offset,n : Draw_ *rp,c\x-2,n
      End If
    Next

  Case #TUIIMAGE_SAVE
    If size>12 Then size*5/6 -2
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    xd.l = (x1+x2-1)/2 -x1 -size/2
    yd.l = (y1+y2-1)/2 -y1 -size/2
    If xd<0 Then xd=0
    If yd<0 Then yd=0

    a.tuiPixel\x = x1+xd,y1+yd
    b.tuiPixel\x = x2-xd,y2-yd
    c.tuiPixel\x = b\x-size/5,a\y+size/5    ; rahmen
    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,b\y : Draw_ *rp,b\x,b\y : Draw_ *rp,b\x,c\y : Draw_ *rp,c\x,a\y : Draw_ *rp,a\x,a\y

    a.tuiPixel\x = x1+xd+size/4,y1+yd       ; schieber
    b.tuiPixel\x = x2-xd-size/4,y1+yd+size/3 +1
    sx.l = size/5+2
    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,b\y : Draw_ *rp,b\x,b\y : Draw_ *rp,b\x,a\y ;: Draw_ *rp,a\x,a\y
    Move_ *rp,b\x-sx,a\y : Draw_ *rp,b\x-sx,b\y-2 : Draw_ *rp,b\x-2,b\y-2 : Draw_ *rp,b\x-2,a\y ;: Draw_ *rp,a\x,a\y

    a.tuiPixel\x = x1+xd+size/6,y2-yd    ; label
   ; b.tuiPixel\x = x2-xd-size/6,y2-yd-size/2-1
    b.tuiPixel\x = x2-xd-size/6,y1+yd+size/3 +3
    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,b\y : Draw_ *rp,b\x,b\y : Draw_ *rp,b\x,a\y : Draw_ *rp,a\x,a\y
    SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHADOW]
    For n.l = a\y +2 To b\y-1 Step 2
      Move_ *rp,a\x+1,n : Draw_ *rp,b\x-1,n
    Next

  Case #TUIIMAGE_SCREEN
    If size>12 Then size*5/6 -2
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2

    a.tuiPixel\x = x-size/2,y-size/2
    b.tuiPixel\x = x+size/2,y+size/2
    c.tuiPixel\x = x,y+size/3
    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,c\y : Draw_ *rp,b\x,c\y : Draw_ *rp,b\x,a\y : Draw_ *rp,a\x,a\y
 ;   Move_ *rp,a\x+2,a\y+2 : Draw_ *rp,a\x+2,c\y-2 : Draw_ *rp,b\x-2,c\y-2 : Draw_ *rp,b\x-2,a\y+2 : Draw_ *rp,a\x+2,a\y+2
    RectFill_ *rp,a\x+2,a\y+2,b\x-2,c\y-2

    Move_ *rp,a\x+2,b\y : Draw_ *rp,b\x-2,b\y
    Move_ *rp,c\x,c\y : Draw_ *rp,c\x,b\y
    Move_ *rp,c\x-1,c\y : Draw_ *rp,c\x-1,b\y
    Move_ *rp,c\x+1,c\y : Draw_ *rp,c\x+1,b\y

    WritePixel_ *rp,b\x-5,c\y-1
    WritePixel_ *rp,b\x-3,c\y-1

  Case #TUIIMAGE_FONT
    If size>12 Then size*5/6 -2
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    a.tuiPixel\x = x-size/2,y-size/2
    b.tuiPixel\x = x+size/2,y+size/2
    c.tuiPixel\x = x+size/4,y

    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,b\y
    Move_ *rp,a\x,a\y : Draw_ *rp,c\x,a\y
    Move_ *rp,a\x,c\y : Draw_ *rp,c\x-size/4,c\y

    Move_ *rp,a\x+1,a\y : Draw_ *rp,a\x+1,b\y
    Move_ *rp,a\x,a\y+1 : Draw_ *rp,c\x,a\y+1
    Move_ *rp,a\x,c\y-1 : Draw_ *rp,c\x-size/4,c\y-1

    Move_ *rp,a\x+2,a\y : Draw_ *rp,a\x+2,b\y
 ;   Move_ *rp,a\x,a\y+2 : Draw_ *rp,c\x,a\y+2

    a.tuiPixel\x = x+size/4,y
    b.tuiPixel\x = x+size/2,y+size/2
    c.tuiPixel\x = x+size/2,y+size/4

    Move_ *rp,a\x,a\y+1 : Draw_ *rp,a\x,b\y
    Move_ *rp,a\x+1,a\y : Draw_ *rp,c\x,a\y
    Move_ *rp,a\x-size/8,c\y : Draw_ *rp,c\x-size/8 ,c\y

  Case #TUIIMAGE_PLUS
    size/2+1 : If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1

    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    Move_ *rp,x-size/2,y : Draw_ *rp,x+size/2,y
    Move_ *rp,x,y-size/2 : Draw_ *rp,x,y+size/2
    Move_ *rp,x-size/2,y+1 : Draw_ *rp,x+size/2,y+1
    Move_ *rp,x+1,y-size/2 : Draw_ *rp,x+1,y+size/2
    Move_ *rp,x-size/2,y-1 : Draw_ *rp,x+size/2,y-1
    Move_ *rp,x-1,y-size/2 : Draw_ *rp,x-1,y+size/2

  Case #TUIIMAGE_MINUS
    size/2+1 : If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    Move_ *rp,x-size/2,y : Draw_ *rp,x+size/2,y
    Move_ *rp,x-size/2,y+1 : Draw_ *rp,x+size/2,y+1
    Move_ *rp,x-size/2,y-1 : Draw_ *rp,x+size/2,y-1

  Case #TUIIMAGE_CHECKMARK
    size/2+1 : If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    size=(size+1)/2

    size*2

    x1.l = (x1+x2-size+1)/2   : x2 = x1+size-1
    y1.l = (y1+y2-size+1)/2   : y2 = y1+size-1
    If False
    a.tuiPixel\x = x1,y1+size/2
    b.tuiPixel\x = x1+size/2,y2
    c.tuiPixel\x = x2,y1
    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y-1
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y-2
    Draw_  *rp,c\x,c\y
    Else
    a.tuiPixel\x = x2,y1
    b.tuiPixel\x = x1,y2
    c.tuiPixel\x = x1,y2-size/2-1

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x+1,a\y
    Draw_  *rp,b\x+1,b\y
    Draw_  *rp,c\x+1,c\y

;    Move_  *rp,a\x,a\y
;    Draw_  *rp,b\x,b\y-2
;    Draw_  *rp,c\x,c\y

    End If

  Case #TUIIMAGE_CHECKMARK2
    If False
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_BACKGROUND]
    Else
      If (flags&#TUIF_ACTIVE)
        SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_WHITE]
      Else
        SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFHALFSHADOW]
      End If
    End If

    size/2+1 : If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    size=(size+1)/2

    size*2

    x1.l = (x1+x2-size)/2   : x2 = x1+size
    y1.l = (y1+y2-size)/2   : y2 = y1+size

    a.tuiPixel\x = x1,y1+size/2
    b.tuiPixel\x = x1+size/2,y2
    c.tuiPixel\x = x2,y1
    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y-1
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y-2
    Draw_  *rp,c\x,c\y
    End If

  Case #TUIIMAGE_BITMAP
    *tpa.tuiPixelArray = _ntui_AccessTBImage{*tbi}
    If (*tpa)

      If (flags&#TUIF_DISABLED)
        If (*tpa\disabled)
          *pa.tuiARGB = *tpa\disabled
          imode.l = #TUIIM_NORMAL
        Else
          *pa.tuiARGB = *tpa\normal
          imode.l = #TUIIM_DISABLED
        End If
      Else
        If (flags&#TUIF_ACTIVE)
          If (*tpa\active)
            *pa.tuiARGB = *tpa\active
            imode.l = #TUIIM_NORMAL
          Else
            *pa.tuiARGB = *tpa\normal
            imode.l = #TUIIM_ACTIVE
          End If
        Else     ; TODO: check also focus and mover!
          If (flags&#TUIF_FOCUS)
            If (*tpa\focus)
              *pa.tuiARGB = *tpa\focus
              imode.l = #TUIIM_NORMAL
            Else
              *pa.tuiARGB = *tpa\normal
              imode.l = #TUIIM_FOCUS
            End If
          Else
            If (flags&#TUIF_MOVER)
              If (*tpa\mover)
                *pa.tuiARGB = *tpa\mover
                imode.l = #TUIIM_NORMAL
              Else
                *pa.tuiARGB = *tpa\normal
                imode.l = #TUIIM_MOVER
              End If

            Else
              *pa.tuiARGB = *tpa\normal
              imode.l = #TUIIM_NORMAL
            End If
          End If
        End If
      End If

      Select *tbi\tuiBitMap\bmode
        Case #TUIIBM_MASK
          If flags&#TUIF_BOTTOM
            by1.l = y2-*tpa\height+1
          Else
            If flags&#TUIF_TOP
              by1.l = y1
            Else
              by1.l = (y1+y2+1)/2-(*tpa\height)/2
            End If
          End If
          bx1.l = (x1+x2+1)/2-(*tpa\width)/2
          ;If bx1<x1 Then bx1=x1
          ;If by1<y1 Then by1=y1

          _ntui_WritePixelArrayAlpha{*pa,0,0,*rp,bx1,by1,*tpa\width,*tpa\height,imode,bgARGB}

          If bgPen>=0
            SetAPen_ *rp,bgPen
            If bx1>*bbox\left Then RectFill_ *rp,*bbox\left,*bbox\top,bx1-1,*bbox\bottom ; left
            If by1>*bbox\top  Then RectFill_ *rp,*bbox\left,*bbox\top,*bbox\right,by1-1 ; top
            If bx1+*tpa\width -1<*bbox\right Then RectFill_ *rp,bx1+*tpa\width,*bbox\top,*bbox\right,*bbox\bottom ; right
            If by1+*tpa\height-1<*bbox\bottom Then RectFill_ *rp,*bbox\left,by1+*tpa\height,*bbox\right,*bbox\bottom ; bottom
          End If

        Case #TUIIBM_9PATCH
           ;    ax.s = Str$(*tpa\border\left)+"/"+Str$(*tpa\border\top)+"/"+Str$(*tpa\border\right)+"/"+Str$(*tpa\border\bottom)
           ;    bx.s = Str$(*tpa\hscale)+"/"+Str$(*tpa\vscale)+"/"+Str$(*tpa\width)+"/"+Str$(*tpa\height)
           ;    error{"draw: scale="+bx.s+"content: "+ax.s}
           srect.tuiRect\left = 0,0
           srect\right  = *tpa\width-1-2
           srect\bottom = *tpa\height-1-2
           drect.tuiRect\left = x1,y1,x2,y2
           _ntui_WritePixelArray9Patch{*pa,*tpa,srect,*rp,drect,imode,bgARGB}

        Default ; #TUIIBM_OPAQUE
          If flags&#TUIF_BOTTOM
            by1.l = y2-*tpa\height+1
          Else
            If flags&#TUIF_TOP
              by1.l = y1
            Else
              by1.l = (y1+y2-*tpa\height)/2
            End If
          End If
          bx1.l = (x1+x2-*tpa\width)/2
          ;If bx1<x1 Then bx1=x1
          ;If by1<y1 Then by1=y1

          _ntui_WritePixelArray{*pa,0,0,*rp,bx1,by1,*tpa\width,*tpa\height,imode}

          If bgPen>=0
            SetAPen_ *rp,bgPen
            If bx1>*bbox\left Then RectFill_ *rp,*bbox\left,*bbox\top,bx1-1,*bbox\bottom ; left
            If by1>*bbox\top  Then RectFill_ *rp,*bbox\left,*bbox\top,*bbox\right,by1-1 ; top
            If bx1+*tpa\width -1<*bbox\right Then RectFill_ *rp,bx1+*tpa\width,*bbox\top,*bbox\right,*bbox\bottom ; right
            If by1+*tpa\height-1<*bbox\bottom Then RectFill_ *rp,*bbox\left,by1+*tpa\height,*bbox\right,*bbox\bottom ; bottom
          End If

      End Select



    End If

  Default
    Move_    *rp,x1  ,y1
    Draw_    *rp,x2  ,y1
    Draw_    *rp,x2  ,y2
    Draw_    *rp,x1  ,y2
    Draw_    *rp,x1  ,y1
    Draw_    *rp,x2  ,y2
    Move_    *rp,x1,  y2
    Draw_    *rp,x2,  y1
End Select
End Statement


Statement _ntui_GetImageBorderSize{*tbi.tuiTBImage,*border.tuiRect}
*tpa.tuiPixelArray = _ntui_AccessTBImage{*tbi}
If *tpa
  !tuiCopyRect{*border,*tpa\border}
Else
  *border\left = 0,0,0,0
End If
End Statement


