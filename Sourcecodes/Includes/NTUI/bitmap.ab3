; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "RAM:"
; ExeFile         = "Prog.exe"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 8192
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 9
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 32768
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 1
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 1737
; CursorColumn    = 1
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 20
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 20
; /XTRA
#TUI_HAS_BITMAP

Function.RastPort ntui_CreateRastPort{width.l,height.l,*friend.BitMap}

  flags.l = #BMF_MINPLANES
  If *friend ; create with same specs like friend bitmap    ; changed the if then to match rastport include  tomsmart1
    bdepth.l = GetBitMapAttr_(*friend,#BMA_DEPTH)
    flags    | GetBitMapAttr_(*friend,#BMA_FLAGS) ; added to have the same flags as the source  tomsmart1
  Else               ; create a custom ARGB bitmap
    flags | #BMF_SPECIALFMT|(#PIXFMT_ARGB32 LSL 24)
    bdepth = 32 ; change it because we need alpha and 24 are only RGB  tomsmart1
  End If
  *bmap.BitMap = AllocBitMap_(width,height,bdepth,flags,*friend)
  If *bmap
    *layerinfo.Layer_Info = NewLayerInfo_
    If *layerinfo
      *layer.Layer    =  CreateUpfrontHookLayer_ (*layerinfo,*bmap,0,0,width-1,height-1,0,#LAYERS_NOBACKFILL,0)
      If *layer
        *rp.RastPort = *layer\rp
      End If
    End If
  End If

  Function Return *rp

End Function


Statement ntui_FreeRastPort{*rp.RastPort}

  If *rp
    *bmap.BitMap          = *rp\BitMap
    *layerinfo.Layer_Info = *rp\Layer\LayerInfo
    *layer.Layer          = *rp\Layer
    If *layer     Then DeleteLayer_ 0,*layer
    If *layerinfo Then DisposeLayerInfo_ *layerinfo
    If *bmap      Then FreeBitMap_ *bmap
  End If

End Statement


Statement _ntui_WritePixelArray9Patch{*srcA.tuiARGB,*tpa.tuiPixelArray,*srcRect.tuiRect,*dstRP.RastPort,*dstRect.tuiRect,imode.l,bgARGB.l}
swidth.l  = !tuiRectWidth {*srcRect}
sheight.l = !tuiRectHeight{*srcRect}
dwidth.l  = !tuiRectWidth {*dstRect}
dheight.l = !tuiRectHeight{*dstRect}

sbpr.l = (*tpa\width)*4
dbpr.l = dwidth*4

srcBase.l = *srcA + (1 + *srcRect\top)*sbpr + (1+*srcRect\left)*4
scaleBase.l = *srcA

If *srcA><Null AND sbpr>0 AND dbpr>0

; bug the values must come from the state Bitmap, not the general one
rhM.l = (dwidth - *tpa\hfix)
rhD.l = *tpa\hscale
rhF.l = rhM

rvM.l = (dheight - *tpa\vfix)
rvD.l = *tpa\vscale
rvF.l = rvM

If rhM<=0
  rhD=*tpa\hscale * dwidth
  rhM=dwidth
  rhF=*tpa\hfix
End If

If rvM<=0
  rvD=*tpa\vscale *dheight
  rvM=dheight
  rvF=*tpa\vfix
End If

tmp.l = _ntui_ObtainTempBuffer{dwidth*dheight*4}
If tmp
  bgARGB=-1
  If bgARGB=-1
    ReadPixelArray_ tmp,0,0,dbpr,*dstRP,*dstRect\left,*dstRect\top,dwidth,dheight,#RECTFMT_ARGB
  Else
    dR.l = (bgARGB LSR 16 ) &$FF
    dG.l = (bgARGB LSR 8  ) &$FF
    dB.l = (bgARGB        ) &$FF
  End If
  RunErrsOff
  syr.l = 0
  For dy.l = 0 To dheight-1
    sy.l = syr / rvM
    scaleP.l = *srcA + sbpr + sy*sbpr
    scy.l=(Peek.b(scaleP)); & $FF) LSR 4
    ;syr = syr + (1-sR)*rvM + ((sR) * rvD)
    If scy
      syr + rvD
    Else
      syr + rvF
    End If

   f.f = rhM
   g.f = rhD
   ff.f = 1024*4/rhM
   gg.f = 1024*4*rhD/rhM

   rhMi.l=1024*4
   rhDi.l=gg

    rhMi = rhF
    rhDi = rhD

    dstP.l = tmp + dbpr * dy
    sxr.l = 0
    srcXBase.l   = srcBase + sbpr *sy
    scaleXBase.l = *srcA + 4
    For dx.l = 0 To dwidth-1
      ;sx.l = (sxr LSR 10) & $FFFFFFFC
      sx.l = (sxr / rhM) LSL 2
      srcP.l = srcXBase + sx
      If (Peek.b(scaleXBase+sx)&scy)
        sxr + rhDi
        ;Poke.l dstP,Peek.l(srcP)

        sA.l=Peek.b(srcP  ) & $FF
        sR.l=Peek.b(srcP+1) & $FF
        sG.l=Peek.b(srcP+2) & $FF
        sB.l=Peek.b(srcP+3) & $FF

        dA.l=256-sA
        dR.l=Peek.b(dstP+1) & $FF
        dG.l=Peek.b(dstP+2) & $FF
        dB.l=Peek.b(dstP+3) & $FF

        R.l = (sR*sA + dR*dA) LSR 8
        G.l = (sG*sA + dG*dA) LSR 8
        B.l = (sB*sA + dB*dA) LSR 8

        Poke.l dstP,(R LSL 16) | (G LSL 8) | (B LSL 0)


      Else
        If (Peek.b(scaleXBase+sx)) Then sxr + rhDi:Else sxr+rhMi
        sA.l=Peek.b(srcP  ) & $FF
        sR.l=Peek.b(srcP+1) & $FF
        sG.l=Peek.b(srcP+2) & $FF
        sB.l=Peek.b(srcP+3) & $FF

        dA.l=256-sA
        dR.l=Peek.b(dstP+1) & $FF
        dG.l=Peek.b(dstP+2) & $FF
        dB.l=Peek.b(dstP+3) & $FF

        R.l = (sR*sA + dR*dA) LSR 8
        G.l = (sG*sA + dG*dA) LSR 8
        B.l = (sB*sA + dB*dA) LSR 8

        Poke.l dstP,(R LSL 16) | (G LSL 8) | (B LSL 0)
      End If
      dstP+4
    Next
  Next
  LastRunErrsMode
  WritePixelArray_ tmp,0,0,dbpr,*dstRP,*dstRect\left,*dstRect\top,dwidth,dheight,#RECTFMT_ARGB
  _ntui_ReleaseTempBuffer{}
End If
End If
End Statement


Statement _ntui_WritePixelArrayScaled_deprecated{*srcA.tuiARGB,*srcRect.tuiRect,*dstRP.RastPort,*dstRect.tuiRect,imode.l,bgARGB.l}
swidth.l  = !tuiRectWidth {*srcRect}
sheight.l = !tuiRectHeight{*srcRect}
dwidth.l  = !tuiRectWidth {*dstRect}
dheight.l = !tuiRectHeight{*dstRect}

sbpr.l = (swidth+2)*4
dbpr.l = dwidth*4

srcBase.l = *srcA + sbpr + 4

If *srcA><Null AND sbpr>0 AND dbpr>0

tmp.l = _ntui_ObtainTempBuffer{dwidth*dheight*4}
If tmp
  bgARGB=-1
  If bgARGB=-1
    ReadPixelArray_ tmp,0,0,dbpr,*dstRP,*dstRect\left,*dstRect\top,dwidth,dheight,#RECTFMT_ARGB
  Else
    dR.l = (bgARGB LSR 16 ) &$FF
    dG.l = (bgARGB LSR 8  ) &$FF
    dB.l = (bgARGB        ) &$FF
  End If
  RunErrsOff
  For dy.l = 0 To dheight-1
    sy.l = dy * sheight/dheight
    dstP.l = tmp + dbpr * dy
    For dx.l = 0 To dwidth-1
      sx.l = dx * swidth / dwidth
      srcP.l = srcBase + sbpr * sy + sx*4

      sA.l=Peek.b(srcP+0) & $FF
      sR.l=Peek.b(srcP+1) & $FF
      sG.l=Peek.b(srcP+2) & $FF
      sB.l=Peek.b(srcP+3) & $FF

      dA.l=256-sA
      dR.l=Peek.b(dstP+1) & $FF
      dG.l=Peek.b(dstP+2) & $FF
      dB.l=Peek.b(dstP+3) & $FF

      R.l = (sR*sA + dR*dA) LSR 8
      G.l = (sG*sA + dG*dA) LSR 8
      B.l = (sB*sA + dB*dA) LSR 8

      Poke.l dstP,(R LSL 16) | (G LSL 8) | (B LSL 0)
      dstP+4
    Next
  Next
  LastRunErrsMode
  WritePixelArray_ tmp,0,0,dbpr,*dstRP,*dstRect\left,*dstRect\top,dwidth,dheight,#RECTFMT_ARGB
  _ntui_ReleaseTempBuffer{}
End If
End If

End Statement


#TUIWPA_SOLID = 10
Statement _ntui_WritePixelArrayAlpha4{*srcA.tuiARGB,sx.l,sy.l,*dstRP.RastPort,dx.l,dy.l,width.l,height.l,softmode.l,bgpen.l}

  raw_ptr.l  = *srcA
  bpr.l      = width*4
  If raw_ptr = Null OR bpr<=0 Then Statement Return
  width16.l = (((width+15) LSR 4) LSL 4)
  tmp8.l     = _ntui_ObtainTempBuffer{width16*height}
  
  If tmp8
    CopyMem_ *dstRP,&temprp.RastPort,SizeOf.RastPort
    temprp\Layer = Null
    temprp\BitMap = AllocBitMap_ (width16,1,8,0,0)
    temprp\BitMap\BytesPerRow = width16 LSR 3
    bpr8.l     = width16

    If bgpen=-1
      ReadPixelArray8_ *dstRP,dx,dy,dx+width-1,dy+height-1,tmp8,temprp          
    End If

    RunErrsOff
    For y.l = 0 To height-1
      dst.l = tmp8    + (y)*bpr8
      src.l = raw_ptr + (y+sy)*bpr     + sx*4
      For x.l = 0 To width-1
        sA.l=Peek.b(src+0) & $FF

        If sA>$20
        ;If sA>$80 OR ((x+y)&1><0)
          sR.l=Peek.b(src+1) & $FF
          sG.l=Peek.b(src+2) & $FF
          sB.l=Peek.b(src+3) & $FF
        
          c.l = (sR+sG+sB)/3
          c0.l = sR
          If sG<c0 Then c0=sG
          If sB<c0 Then c0=sB
          c1.l = sR
          If sG>c1 Then c1=sG
          If sB>c1 Then c1=sB
          If c>0 Then d.l = (c1-c0)*256/c:Else d=0
          
          pen.l=1
          If c>$20 Then pen=0
          If c>$B0 Then pen=2
          If d>$60 Then pen=3
          
            Poke.b dst,pen
         ; End If
        Else
          If bgpen>0 Then Poke.b dst,bgpen
        End If
        dst+1 : src+4
      Next
    Next
    WritePixelArray8_ *dstRP,dx,dy,dx+width-1,dy+height-1,tmp8,&temprp
    LastRunErrsMode
    FreeBitMap_ temprp\BitMap

    _ntui_ReleaseTempBuffer{}
  End If

End Statement


Statement _ntui_WritePixelArrayAlpha{*srcA.tuiARGB,sx.l,sy.l,*dstRP.RastPort,dx.l,dy.l,width.l,height.l,softmode.l,bgARGB.l}

  raw_ptr.l = *srcA
  bpr.l = width*4
  If raw_ptr = Null OR bpr<=0 Then Statement Return

  tmp.l = _ntui_ObtainTempBuffer{width*height*4}
  If tmp
    If softmode=#TUIIM_FOCUS Then softmode=#TUIIM_NORMAL ; no extra softmode for focus
    If softmode=#TUIIM_MOVER Then softmode=#TUIIM_NORMAL ; no extra softmode for mover
    If bgARGB=-1
      ReadPixelArray_ tmp,0,0,width*4,*dstRP,dx,dy,width,height,#RECTFMT_ARGB
    Else
      dR.l = (bgARGB LSR 16 ) &$FF
      dG.l = (bgARGB LSR 8  ) &$FF
      dB.l = (bgARGB        ) &$FF
      softmode + #TUIWPA_SOLID
    End If

    RunErrsOff
    For y.l = 0 To height-1
      dst.l = tmp     + (y)*width*4
      src.l = raw_ptr + (y+sy)*bpr     + sx*4
      Select softmode
        Case #TUIIM_NORMAL + #TUIWPA_SOLID
          For x.l = 0 To width-1
            sA.l=Peek.b(src+0) & $FF
            sR.l=Peek.b(src+1) & $FF
            sG.l=Peek.b(src+2) & $FF
            sB.l=Peek.b(src+3) & $FF

            dA.l=256-sA

            R.l = (sR*sA + dR*dA) LSR 8
            G.l = (sG*sA + dG*dA) LSR 8
            B.l = (sB*sA + dB*dA) LSR 8

            Poke.l dst,(R LSL 16) | (G LSL 8) | (B LSL 0)
            dst+4 : src+4
          Next

        Case #TUIIM_ACTIVE + #TUIWPA_SOLID
           For x.l = 0 To width-1
             sA.l=((Peek.b(src+0) & $FF))
             sR.l=((Peek.b(src+1) & $FF) * 330) LSR 8 : If sR>255 Then sR=255
             sG.l=((Peek.b(src+2) & $FF) * 330) LSR 8 : If sG>255 Then sG=255
             sB.l=((Peek.b(src+3) & $FF) * 330) LSR 8 : If sB>255 Then sB=255

             dA.l=256-sA

             R.l = (sR*sA + dR*dA) LSR 8
             G.l = (sG*sA + dG*dA) LSR 8
             B.l = (sB*sA + dB*dA) LSR 8

             Poke.l dst,(R LSL 16) | (G LSL 8) | (B LSL 0)
             dst+4 : src+4
           Next

        Case #TUIIM_DISABLED + #TUIWPA_SOLID
           For x.l = 0 To width-1
             sA.l=(Peek.b(src+0) & $FF) LSR 1
             sX.l=((Peek.b(src+1) & $FF) + (Peek.b(src+2) & $FF) + (Peek.b(src+3) & $FF)) LSR 2

             dA.l=256-sA

             R.l = (sX*sA + dR*dA) LSR 8
             G.l = (sX*sA + dG*dA) LSR 8
             B.l = (sX*sA + dB*dA) LSR 8

             Poke.l dst,(R LSL 16) | (G LSL 8) | (B LSL 0)
             dst+4 : src+4
           Next

        Case #TUIIM_NORMAL
          For x.l = 0 To width-1
            sA.l=Peek.b(src+0) & $FF
            sR.l=Peek.b(src+1) & $FF
            sG.l=Peek.b(src+2) & $FF
            sB.l=Peek.b(src+3) & $FF

            dA.l=256-sA
            dR.l=Peek.b(dst+1) & $FF
            dG.l=Peek.b(dst+2) & $FF
            dB.l=Peek.b(dst+3) & $FF

            R.l = (sR*sA + dR*dA) LSR 8
            G.l = (sG*sA + dG*dA) LSR 8
            B.l = (sB*sA + dB*dA) LSR 8

            Poke.l dst,(R LSL 16) | (G LSL 8) | (B LSL 0)
            dst+4 : src+4
          Next

        Case #TUIIM_ACTIVE
           For x.l = 0 To width-1
             sA.l=((Peek.b(src+0) & $FF))
             sR.l=((Peek.b(src+1) & $FF) * 330) LSR 8 : If sR>255 Then sR=255
             sG.l=((Peek.b(src+2) & $FF) * 330) LSR 8 : If sG>255 Then sG=255
             sB.l=((Peek.b(src+3) & $FF) * 330) LSR 8 : If sB>255 Then sB=255

             dA.l=256-sA
             dR.l=Peek.b(dst+1) & $FF
             dG.l=Peek.b(dst+2) & $FF
             dB.l=Peek.b(dst+3) & $FF

             R.l = (sR*sA + dR*dA) LSR 8
             G.l = (sG*sA + dG*dA) LSR 8
             B.l = (sB*sA + dB*dA) LSR 8

             Poke.l dst,(R LSL 16) | (G LSL 8) | (B LSL 0)
             dst+4 : src+4
           Next

        Case #TUIIM_DISABLED
           For x.l = 0 To width-1
             sA.l=(Peek.b(src+0) & $FF) LSR 1
             sX.l=((Peek.b(src+1) & $FF) + (Peek.b(src+2) & $FF) + (Peek.b(src+3) & $FF)) LSR 2

             dA.l=256-sA
             dR.l=Peek.b(dst+1) & $FF
             dG.l=Peek.b(dst+2) & $FF
             dB.l=Peek.b(dst+3) & $FF

             R.l = (sX*sA + dR*dA) LSR 8
             G.l = (sX*sA + dG*dA) LSR 8
             B.l = (sX*sA + dB*dA) LSR 8

             Poke.l dst,(R LSL 16) | (G LSL 8) | (B LSL 0)
             dst+4 : src+4
           Next
      End Select
    Next
    LastRunErrsMode
    WritePixelArray_ tmp,0,0,width*4,*dstRP,dx,dy,width,height,#RECTFMT_ARGB
    _ntui_ReleaseTempBuffer{}
  End If

End Statement


Statement _ntui_WritePixelArray{*srcA.tuiARGB,sx.l,sy.l,*dstRP.RastPort,dx.l,dy.l,width.l,height.l,softmode.l}

  raw_ptr.l = *srcA
  bpr.l = width*4
  If raw_ptr=Null OR bpr<=0 Then Statement Return

  If softmode=#TUIIM_NORMAL OR softmode=#TUIIM_MOVER OR softmode=#TUIIM_FOCUS
    WritePixelArray_ *srcA,sx,sy,width*4,*dstRP,dx,dy,width,height,#RECTFMT_ARGB : Statement Return
  End If
  tmp.l = _ntui_ObtainTempBuffer{width*height*4}
  If tmp
    RunErrsOff
    For y.l = 0 To height-1
      dst.l = tmp     + (y)*width*4
      src.l = raw_ptr + (y+sy)*bpr     + sx*4
      Select softmode
        Case #TUIIM_ACTIVE
           For x.l = 0 To width-1
             sR.l=((Peek.b(src+1) & $FF) * 330) LSR 8 : If sR>255 Then sR=255
             sG.l=((Peek.b(src+2) & $FF) * 330) LSR 8 : If sG>255 Then sG=255
             sB.l=((Peek.b(src+3) & $FF) * 330) LSR 8 : If sB>255 Then sB=255
             Poke.l dst,(sR LSL 16) | (sG LSL 8) | (sB LSL 0)
             dst+4 : src+4
           Next

        Case #TUIIM_DISABLED
           For x.l = 0 To width-1
             sX.l=((Peek.b(src+1) & $FF) + (Peek.b(src+2) & $FF) + (Peek.b(src+3) & $FF)) LSR 2
             R.l = (sX) LSR 1 + 127
             Poke.l dst,(R LSL 16) | (R LSL 8) | (R LSL 0)
             dst+4 : src+4
           Next

      End Select
    Next
    LastRunErrsMode
    WritePixelArray_ tmp,0,0,width*4,*dstRP,dx,dy,width,height,#RECTFMT_ARGB
    _ntui_ReleaseTempBuffer{}
  End If

End Statement


Statement _ntui_ThresholdAlpha{*srcA.tuiARGB,width.l,height.l,threshold.l}

  raw_ptr.l = *srcA
  bpr.l = width*4
  If raw_ptr><Null AND bpr>0
    For y.l = 0 To height-1
      src.l = raw_ptr + y*bpr
      For x.l = 0 To width-1
        A.l=Peek.b(src+0) & $FF
        If A<threshold Then A=0
        Poke.b src,A
        src+4
      Next
    Next
  End If

End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_LoadBitMapViaPNG {filename.s,*width.l,*height.l}   /
;/                                                                             /
;/ Description:                                                                /
;/ private: load an 32bit ARGB PNG image vis custom routines                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s   : ???                                                       /
;/ - *width.l     : ???                                                         /
;/ - *height.l    : ???                                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.tuiARGB _ntui_LoadBitMapViaPNG{filename.s,*width.l,*height.l}

  *raw.tuiARGB = Null
  *tuiPNG.tuiPNG = ntui_ReadPNG{filename}
  If *tuiPNG
    pwidth.l  = ntui_GetPNGWidth{*tuiPNG}
    pheight.l = ntui_GetPNGHeight{*tuiPNG}
    If pwidth>0 AND pheight>0
      *raw = AllocVec_(pwidth*pheight*4,#MEMF_ANY)
      If *raw
        Poke.l *width,pwidth
        Poke.l *height,pheight
        ntui_DecodePNG{*tuiPNG,*raw,pwidth*4}
      End If
    End If
    ntui_FreePNG{*tuiPNG }
  End If

  Function Return *raw

End Function


Function.tuiARGB _ntui_LoadBitMapViaIconV36{filename.s,*tpa.tuiPixelArray}
  SHARED version_iconlib.l

  *raw.tuiARGB =Null
  FindScreen 0
  *scr.Screen = Peek.l(Addr Screen (0))
  *drawinfo.DrawInfo = GetScreenDrawInfo_(*scr)

  If version_iconlib=0 Then version_iconlib = _ntui_GetLibVersion{"icon.library"}
  If version_iconlib<36 Then Function Return *raw

  If LCase$(Right$(filename.s,5))=".info"
    filename.s=UnLeft$(filename.s,5)
  EndIf

  ;tag5.tag5\ti_Tag = #ICONGETA_FailIfUnavailable,0,#ICONGETA_GetPaletteMappedIcon,0,#ICONGETA_RemapIcon,0,#ICONGETA_GenerateImageMasks,0, #TAG_END,0
  ;*icon.DiskObject = GetIconTagList_ (&filename,&tag5)
  *icon.DiskObject = GetDiskObjectNew_(&filename)
  ;tag5.tag5\ti_Tag = #ICONGETA_FailIfUnavailable,#FALSE,#ICONGETA_GetPaletteMappedIcon,#FALSE,#ICONGETA_RemapIcon,#FALSE,#ICONGETA_GenerateImageMasks,#FALSE,#ICONGETA_GetDefaultType,#WBPROJECT, #TAG_END,0

  If *icon
    DEFTYPE.Rectangle rectLI
    rectLI\MinX = 0,0,0,0

    itags.tag5\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#TAG_DONE,0
    width.l  = *icon\do_Gadget\Width
    height.l = *icon\do_Gadget\Height
    xoff.l   = 0
    yoff.l   = 0

    *tpa\width  = width
    *tpa\height = height

    *rp1.RastPort = ntui_CreateRastPort{width,height,*scr\BitMap}
    *rp2.RastPort = ntui_CreateRastPort{width,height,*scr\BitMap}

    If *rp1><Null AND *rp2><Null
      For n.l=0 To 1
        *img.Image = *icon\do_Gadget\GadgetRender
        *gad.Gadget = *icon\do_Gadget

        If n=0 Then state.l=#IDS_NORMAL : Else state=#IDS_SELECTED : *img = *icon\do_Gadget\SelectRender

        FillPixelArray_ *rp1,0,0,width,height,$00000000
        itags\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#TAG_DONE,0
        DrawImage_ *rp1,*img,0,0
        ;DrawImageState_ *rp1,*img,0,0,#IDS_NORMAL,*drawinfo
        DrawIconStateA_ *rp1,*icon,Null,xoff,yoff,state,itags
        ;rawptr2.l = 0
        ;bmaplock.l = LockBitMapTagList_(*rp1\BitMap,Tags(#LBMI_BASEADDRESS,&rawptr1.l,#LBMI_BYTESPERROW,&bpr1.l))
        ;UnLockBitMap_ bmaplock

        FillPixelArray_ *rp2,0,0,width,height,$00FFFFFF
        itags\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#TAG_DONE,0
        DrawImage_ *rp2,*img,0,0
        ;DrawImageState_ *rp2,*img,0,0,#IDS_NORMAL,*drawinfo
        ;DrawIconStateA_ *rp2,*icon,Null,xoff,yoff,state,tag5
        ;rawptr2.l = Null
        ;bmaplock.l = LockBitMapTagList_(*rp2\BitMap,Tags(#LBMI_BASEADDRESS,&rawptr2.l,#LBMI_BYTESPERROW,&bpr2.l))
        ;UnLockBitMap_ bmaplock

        *raw.tuiARGB = AllocVec_(width*height*4,#MEMF_ANY)
        *tmp.tuiARGB = AllocVec_(width*height*4,#MEMF_ANY)
        If *raw><Null AND *tmp><Null
          rawptr1.l = *raw
          rawptr2.l = *tmp
          bpr1.l    = width*4
          bpr2.l    = width*4
          ReadPixelArray_ *raw,0,0,bpr1,*rp1,0,0,width,height,#RECTFMT_ARGB
          ReadPixelArray_ *tmp,0,0,bpr2,*rp2,0,0,width,height,#RECTFMT_ARGB

          For y.l = 0 To height-1 ; get Alpha Channel
            *src2.tuiARGB = rawptr2 + y*bpr2
            *src1.tuiARGB = rawptr1 + y*bpr1
            *dst.tuiARGB = *raw + y*width*4
            For x.l = 0 To width-1
              a.l = (((*src2\R&$FF) - (*src1\R&$FF)))
              a=255-a
              a = 255
              If a=0 OR a=255
                *dst\A = a,*src1\R,*src1\G,*src1\B
              Else
                R.l = ((*src1\R&$FF)*255/(a));: If a>0 Then R*255 / a : If R>255 Then R=255
                G.l = ((*src1\G&$FF)*255/(a));: If a>0 Then G*255 / a : If G>255 Then G=255
                B.l = ((*src1\B&$FF)*255/(a));: If a>0 Then B*255 / a : If B>255 Then B=255
               *dst\A = a,R,G,B
              End If

              *dst+4
              *src1+4
              *src2+4
            Next
          Next

          FreeVec_ *tmp
        End If

        If n=0 Then *tpa\normal = *raw : Else *tpa\active=*raw
      Next
    End If
    If *rp1 Then ntui_FreeRastPort{*rp1}
    If *rp2 Then ntui_FreeRastPort{*rp2}

    FreeDiskObject_ *icon
  EndIf

  Function Return *tpa\normal

End Function


Function.tuiARGB _ntui_LoadBitMapViaIcon_dep{filename.s,*tpa.tuiPixelArray}
  SHARED version_iconlib.l

  *raw.tuiARGB =Null
  ;FindScreen 0
  ;*scr.Screen = Peek.l(Addr Screen (0))
  ;*drawinfo.DrawInfo = GetScreenDrawInfo_(*scr)

  If version_iconlib=0 Then version_iconlib = _ntui_GetLibVersion{"icon.library"}
  If version_iconlib<44 Then Function Return *raw

  If LCase$(Right$(filename.s,5))=".info"
    filename.s=UnLeft$(filename.s,5)
  Else

  EndIf

  itags.tag10\ti_Tag = #ICONGETA_FailIfUnavailable,#FALSE,#ICONGETA_GetPaletteMappedIcon,#FALSE,#ICONGETA_RemapIcon,#TRUE,#ICONGETA_GenerateImageMasks,#TRUE,#TAG_END,0
;  itags.tag10\ti_Tag = #ICONGETA_FailIfUnavailable,#FALSE,#ICONGETA_GetPaletteMappedIcon,#FALSE,#ICONGETA_RemapIcon,#FALSE,#ICONGETA_GenerateImageMasks,#FALSE,#ICONGETA_GetDefaultType,#WBPROJECT, #TAG_END,0

  *icon.DiskObject = GetIconTagList_ (&filename,itags)

  If *icon
    DEFTYPE.Rectangle rectLI
    rectLI\MinX = 0,0,0,0

;    itags\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#ICONDRAWA_DrawInfo,*drawinfo,#TAG_DONE,0
    itags\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#TAG_DONE,0
    RunErrsOff
    ;MOVE.l a4,-(a7)
    ;MOVE.l a5,-(a7)
    ;MOVE.l a6,-(a7)
    ;MOVE.l d7,-(a7)
    GetIconRectangleA_ 0,*icon,0,rectLI,itags
    ;MOVE.l (a7)+,d7
    ;MOVE.l (a7)+,a6
    ;MOVE.l (a7)+,a5
    ;MOVE.l (a7)+,a4
    LastRunErrsMode

    width.l  = rectLI\MaxX - rectLI\MinX +1
    height.l = rectLI\MaxY - rectLI\MinY +1
    xoff.l   = -rectLI\MinX
    yoff.l   = -rectLI\MinY

    *rp1.RastPort = ntui_CreateRastPort{width,height,Null};*scr\BitMap}
    *rp2.RastPort = ntui_CreateRastPort{width,height,Null};*scr\BitMap}

    ;*rp1.RastPort = ntui_CreateRastPort{width,height}
    ;*rp2.RastPort = ntui_CreateRastPort{width,height}

    *tpa\width  = width
    *tpa\height = height

    If *rp1><Null AND *rp2><Null
      For n.l=0 To 1
        If n=0 Then state.l=#IDS_NORMAL : Else state=#IDS_SELECTED

        FillPixelArray_ *rp1,0,0,width,height,$00000000
        itags\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#TAG_DONE,0
        DrawIconStateA_ *rp1,*icon,Null,xoff,yoff,state,itags

        FillPixelArray_ *rp2,0,0,width,height,$00FFFFFF
        itags\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#TAG_DONE,0
        DrawIconStateA_ *rp2,*icon,Null,xoff,yoff,state,itags

        bmaplock1.l = 0;LockBitMapTagList_(*rp1\BitMap,Tags(#LBMI_BASEADDRESS,&*rawptr1.tuiARGB,#LBMI_BYTESPERROW,&bpr1.l))
        bmaplock2.l = 0;LockBitMapTagList_(*rp2\BitMap,Tags(#LBMI_BASEADDRESS,&*rawptr2.tuiARGB,#LBMI_BYTESPERROW,&bpr2.l))

        If bmaplock1=0 ; direct lock didnt work, so allocate pixelarray
          *rawptr1.tuiARGB = AllocVec_(width*height*4,#MEMF_ANY)
          bpr1.l = width*4
          ReadPixelArray_ *rawptr1,0,0,bpr1,*rp1,0,0,width,height,#RECTFMT_ARGB
        End If

        If bmaplock2=0
          *rawptr2.tuiARGB = AllocVec_(width*height*4,#MEMF_ANY)
          bpr2.l = width*4
          ReadPixelArray_ *rawptr2,0,0,bpr2,*rp2,0,0,width,height,#RECTFMT_ARGB
        End If

        *raw = AllocVec_(width*height*4,#MEMF_ANY)
        If *raw
          For y.l = 0 To height-1 ; get Alpha Channel
            *src2.tuiARGB = *rawptr2 + y*bpr2
            *src1.tuiARGB = *rawptr1 + y*bpr1
            *dst.tuiARGB  = *raw + y*width*4
            For x.l = 0 To width-1
              a.l = 255-((*src2\R-*src1\R)&$FF)
              If a=0 OR a=255
                *dst\A = a,*src1\R,*src1\G,*src1\B
              Else
                R.l = ((*src1\R&$FF)*255/(a))
                G.l = ((*src1\G&$FF)*255/(a))
                B.l = ((*src1\B&$FF)*255/(a))
               *dst\A = a,R,G,B
              End If
              *dst+4
              *src1+4
              *src2+4
            Next
          Next
        End If

        ;Exchange *raw,*rawptr2

        If n=0 Then *tpa\normal = *raw : Else *tpa\active=*raw
        If bmaplock1 Then UnLockBitMap_ bmaplock1 : *rawptr1 = Null
        If bmaplock2 Then UnLockBitMap_ bmaplock2 : *rawptr2 = Null
      Next
    End If

    If *rp1 Then ntui_FreeRastPort{*rp1}
    If *rp2 Then ntui_FreeRastPort{*rp2}
    If *rawptr1 Then FreeVec_ *rawptr1
    If *rawptr2 Then FreeVec_ *rawptr2

    FreeDiskObject_ *icon
  EndIf

  Function Return *tpa\normal

End Function


Function.tuiARGB _ntui_LoadBitMapViaIcon{filename.s,*tpa.tuiPixelArray}
  SHARED version_iconlib.l
  *raw.tuiARGB =Null
  If version_iconlib=0 Then version_iconlib = _ntui_GetLibVersion{"icon.library"}
  If version_iconlib<44 
    *raw = _ntui_LoadBitMapViaIconV36{filename,*tpa}
    Function Return *raw
  End If

  If LCase$(Right$(filename.s,5))=".info" Then filename.s=UnLeft$(filename.s,5)

;  itags.tag10\ti_Tag = #ICONGETA_FailIfUnavailable,#FALSE,#ICONGETA_GetPaletteMappedIcon,#FALSE,#ICONGETA_RemapIcon,#TRUE,#ICONGETA_GenerateImageMasks,#TRUE,#TAG_END,0
  itags.tag10\ti_Tag = #ICONGETA_FailIfUnavailable,#FALSE,#TAG_END,0
  *icon.DiskObject = GetIconTagList_ (&filename,itags)

  If *icon
    DEFTYPE.Rectangle rectLI
    rectLI\MinX = 0,0,0,0
    itags\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#TAG_DONE,0
    RunErrsOff
    GetIconRectangleA_ 0,*icon,0,rectLI,itags
    LastRunErrsMode
    width.l  = rectLI\MaxX - rectLI\MinX +1
    height.l = rectLI\MaxY - rectLI\MinY +1
    xoff.l   = -rectLI\MinX;-1 "off by one" fix for AfA
    yoff.l   = -rectLI\MinY;-1
    aspect.l = 1
    If width>=height*2-1 Then aspect=2
    *friend.BitMap = Null
    
    ;FindScreen 0
    ;*scr.Screen = Peek.l(Addr Screen (0))
    ;*friend.BitMap = *scr\BitMap
    check.l = -1
    
    *rp.RastPort = ntui_CreateRastPort{width,height,*friend}
    *tpa\width  = width
    *tpa\height = height*aspect
    *rawW.tuiARGB = Null
    *rawB.tuiARGB = Null
    bprB.l = width*4
    bprW.l = width*4
    
    If *rp><Null
      For n.l=0 To 1
        If n=0 Then state.l=#IDS_NORMAL : Else state=#IDS_SELECTED
        tryiconagain:
        FillPixelArray_ *rp,0,0,width,height,$00000000
        itags\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#TAG_DONE,0
        DrawIconStateA_ *rp,*icon,Null,xoff,yoff,state,itags
        If *rawB=Null Then *rawB = AllocVec_(width*height*4*aspect,#MEMF_ANY)
        ReadPixelArray_ *rawB,0,0,bprB,*rp,0,0,width,height,#RECTFMT_ARGB
        If check><0
          check.l = 0
          For y.l=0 To height-1
            For x.l=0 To width-1
              check.l + Peek.l(*rawB+y*bprB + x*4)
            Next
          Next
          
          If check=0
            FindScreen 0
            *scr.Screen = Peek.l(Addr Screen (0))
            *friend.BitMap = *scr\BitMap
            ntui_FreeRastPort{*rp} : *rp=Null
            *rp.RastPort = ntui_CreateRastPort{width,height,*friend}
            Pop If:Pop If:Goto tryiconagain
          End If
          
          check=0
        End If

        FillPixelArray_ *rp,0,0,width,height,$00FFFFFF
        itags\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#TAG_DONE,0
        DrawIconStateA_ *rp,*icon,Null,xoff,yoff,state,itags
        If *rawW=Null Then *rawW = AllocVec_(width*height*4*aspect,#MEMF_ANY)
        ReadPixelArray_ *rawW,0,0,bprW,*rp,0,0,width,height,#RECTFMT_ARGB

        For y.l = 0 To height-1 ; get Alpha Channel
          *srcW.tuiARGB = *rawW + y*bprW
          *srcB.tuiARGB = *rawB + y*bprB
          *dst.tuiARGB  = *rawB + y*bprB
          For x.l = 0 To width-1
            A.l = ($FF-*srcW\R+*srcB\R) & $FF
            If A=0 OR A=$FF
              *dst\A = A;,*srcB\R,*srcB\G,*srcB\B
            Else
              R.l = (*srcB\R & $FF)*$FF/A
              G.l = (*srcB\G & $FF)*$FF/A
              B.l = (*srcB\B & $FF)*$FF/A
             *dst\A = A,R,G,B
            End If
            *dst+4
            *srcB+4
            *srcW+4
          Next
        Next

        If aspect=2
          For y.l = 0 To height-1
            *src.tuiARGB = *rawB + y  *bprB
            *dst.tuiARGB = *rawW + y*2*bprW
            CopyMem_ *src,*dst,bprW
            CopyMem_ *src,*dst+bprW,bprW
          Next
          Exchange *rawB,*rawW
        End If

        If n=0 Then *tpa\normal = *rawB : Else *tpa\active=*rawB
        *rawB = Null
      Next
    End If

    If *rp Then ntui_FreeRastPort{*rp}
    If *rawW Then FreeVec_ *rawW : *rawW = Null

    FreeDiskObject_ *icon
  EndIf

  Function Return *tpa\normal

End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_LoadBitMapViaDT {filename.s,imgnum.l,*width.l,*h:: /
;/ eight.l}                                                                    /
;/                                                                             /
;/ Description:                                                                /
;/ privtae: load an image via Datatypes.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : ???                                                       /
;/ - imgnum.l    : ???                                                         /
;/ - *width.l    : ???                                                         /
;/ - *height.l    : ???                                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.tuiARGB _ntui_LoadBitMapViaDT{filename.s,imgnum.l,*width.l,*height.l}
DEFTYPE.BitMapHeader *bmhdp
DEFTYPE.pdtBlitPixelArray DTM
*raw.tuiARGB = Null : succ.l=False
If imgnum<0 Then imgnum=0
tag5.tag5\ti_Tag = #PDTA_DestMode, #PMODE_V43, #DTA_SourceType, #DTST_FILE, #DTA_GroupID, #GID_PICTURE, #PDTA_Remap,#FALSE,#PDTA_WhichPicture,imgnum,#TAG_DONE,0
*DTPic._Object = NewDTObjectA_ (&filename.s,tag5)
If *DTPic
  tag5.tag5\ti_Tag = #PDTA_BitMapHeader,&*bmhdp,#TAG_DONE,0
  GetDTAttrsA_ *DTPic,tag5
  *raw = AllocVec_(*bmhdp\bmh_Width * *bmhdp\bmh_Height *4,#MEMF_ANY)
  bpr.l = *bmhdp\bmh_Width*4
  Poke.l *width ,*bmhdp\bmh_Width
  Poke.l *height,*bmhdp\bmh_Height

  ; try to get as ARGB immediately, good datatpyes support this, but not all!
  ;If *bmhdp\bmh_Depth>8 ; dont even try if depth <=8
    DTM\MethodID            = #PDTM_READPIXELARRAY
    DTM\pbpa_PixelData      = *raw              ; /* The pixel data to transfer to/from */
    DTM\pbpa_PixelFormat    = #PBPAFMT_ARGB     ; /* Format of the pixel data (see "Pixel Formats" below) */
    DTM\pbpa_PixelArrayMod  = bpr               ; /* Number of bytes per row */
    DTM\pbpa_Left           = 0                 ; /* Left edge of the rectangle to transfer pixels to/from */
    DTM\pbpa_Top            = 0                 ; /* Top edge of the rectangle to transfer pixels to/from */
    DTM\pbpa_Width          = *bmhdp\bmh_Width  ; /* Width of the rectangle to transfer pixels to/from */
    DTM\pbpa_Height         = *bmhdp\bmh_Height
    If DoMethodA (*DTPic,&DTM) Then succ = True
  ;End If

  ; Try READPIXELARRAY LUT8, if we couldn't catch the bitmap (outch!)
  If succ=False
    *penArray8.b = AllocVec_(*bmhdp\bmh_Height * *bmhdp\bmh_Width,#MEMF_ANY)
    *lut.b       = AllocVec_(256*4,#MEMF_CLEAR)
    If *penArray8><Null AND *lut><Null
      DTM\MethodID            = #PDTM_READPIXELARRAY
      DTM\pbpa_PixelData      = *penArray8        ; /* The pixel data to transfer to/from */
      DTM\pbpa_PixelFormat    = #PBPAFMT_LUT8     ; /* Format of the pixel data (see "Pixel Formats" below) */
      DTM\pbpa_PixelArrayMod  = *bmhdp\bmh_Width  ; /* Number of bytes per row */
      DTM\pbpa_Left           = 0                 ; /* Left edge of the rectangle to transfer pixels to/from */
      DTM\pbpa_Top            = 0                 ; /* Top edge of the rectangle to transfer pixels to/from */
      DTM\pbpa_Width          = *bmhdp\bmh_Width  ; /* Width of the rectangle to transfer pixels to/from */
      DTM\pbpa_Height         = *bmhdp\bmh_Height
      If DoMethodA (*DTPic,&DTM)
        tag5.tag5\ti_Tag = #PDTA_ColorRegisters,&*colMap.b,#TAG_DONE,0
        If GetDTAttrsA_ (*DTPic,tag5)
          For pen.l=0 To (1 LSL *bmhdp\bmh_Depth)-1
            *CReg.ColorRegister = *colMap + 3*pen
            Poke.l *lut + (pen LSL 2),((*CReg\red&$00FF) LSL 16) | ((*CReg\green & $00FF) LSL 8) | (*CReg\blue & $FF)
          Next
          For y.l = 0 To *bmhdp\bmh_Height -1
            For x.l = 0 To *bmhdp\bmh_Width -1
              pen.l = Peek.b(*penArray8+y*Int(*bmhdp\bmh_Width)+x) & $FF
              Poke.l *raw+y*bpr+(x LSL 2),(Peek.l(*lut+(pen LSL 2)) );& $FEFEFEFE) LSR 1
            Next
          Next
          succ.l = True
        End If
      End If
      If *penArray8 Then FreeVec_ *penArray8 : *penArray8 = 0
      If *lut       Then FreeVec_ *lut       : *lut       = 0
    End If
  End If
  If succ=False
    FreeVec_ *raw : *raw=Null
  Else
    For y.l = 0 To *bmhdp\bmh_Height-1 ; Opaque Alpha Channel
      *dst.tuiARGB = *raw + y*bpr
      For x.l = 0 To *bmhdp\bmh_Width-1
        *dst\A=255
        *dst+4
      Next
    Next
  End If
  DisposeDTObject_ (*DTPic)
End If
Function Return *raw
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_ObtainTuiBitMap {imagefile.s}                      /
;/                                                                             /
;/ Description:                                                                /
;/ private
;/                                                                            /
;/ Inputs:                                                                     /
;/ - imagefile.s    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.tuiBitMap _ntui_AttemptTuiBitMap{imagefile.s}

  If tuiGlobal\bitMapCache\tuiBitMapA  ; check if the image is already in cache ...
    For n.l=0 To tuiGlobal\bitMapCache\tuiBitMapsUsed-1
      *tbm.tuiBitMap = Peek.l(tuiGlobal\bitMapCache\tuiBitMapA + n*SizeOf.l)
      If *tbm
        If str_Read{&*tbm\name}=imagefile Then *tbm\useCount+1 : Function Return *tbm
      End If
    Next
  End If

  Function Return Null

End Function


Function.l _ntui_ExpandTuiBitMapCache{bitmapN.l}

  If tuiGlobal\bitMapCache\tuiBitMapsAlloc<=bitmapN  ; it is not in cache, check if we need to increase the buffer
    newAlloc.l =  bitmapN+128
    *newList.tuiBitMap = AllocVec_ (newAlloc*SizeOf.l,#MEMF_CLEAR)
    If *newList
      If tuiGlobal\bitMapCache\tuiBitMapA
        CopyMem_ tuiGlobal\bitMapCache\tuiBitMapA,*newList,SizeOf.l*tuiGlobal\bitMapCache\tuiBitMapsUsed
        FreeVec_ tuiGlobal\bitMapCache\tuiBitMapA
      End If
      tuiGlobal\bitMapCache\tuiBitMapA      = *newList
      tuiGlobal\bitMapCache\tuiBitMapsAlloc = newAlloc
    Else
      Function Return False
    End If

  End If

  Function Return True

End Function


Function.tuiBitMap _ntui_ObtainTuiBitMap{imagefile.s}

  *tbm.tuiBitMap = _ntui_AttemptTuiBitMap{imagefile}
  If *tbm Then Function Return *tbm 

  If _ntui_ExpandTuiBitMapCache{tuiGlobal\bitMapCache\tuiBitMapsUsed} ; if buffer is large enough, add new image
    *tbm = AllocVec_(SizeOf.tuiBitMap,#MEMF_ANY)

    *tbm\pixelArrayA = AllocVec_(SizeOf.tuiPixelArray*4,#MEMF_ANY)
    If *tbm\pixelArrayA
      *tbm\name              = Null
      *tbm\pixelArraysUsed   = 1
      *tbm\pixelArraysAlloc  = 4

      *tpa.tuiPixelArray = *tbm\pixelArrayA
      *tpa\normal   = Null
      *tpa\active   = Null
      *tpa\disabled = Null
      *tpa\focus    = Null
      *tpa\mover    = Null
      *tpa\width    = 1
      *tpa\height   = 1
      *tbm\bmode    = #TUIIBM_OPAQUE

      If *tpa\normal=Null ; try Icon first...
        If Right$(imagefile,5)=".info"
          If _ntui_LoadBitMapViaIcon{imagefile,*tpa}
            *tbm\bmode=#TUIIBM_MASK
          End If
        End If
      End If

      If *tpa\normal=Null ; try PNG next...
        *tpa\normal  = _ntui_LoadBitMapViaPNG{imagefile,&w.l,&h.l}
        *tpa\width   = w
        *tpa\height  = h
        If *tpa\normal
          *tpa\active   = _ntui_LoadBitMapViaPNG{imagefile+"_s",&w.l,&h.l}
          *tpa\disabled = _ntui_LoadBitMapViaPNG{imagefile+"_g",&w.l,&h.l}
          *tpa\mover    = _ntui_LoadBitMapViaPNG{imagefile+"_m",&w.l,&h.l}
          *tpa\focus    = _ntui_LoadBitMapViaPNG{imagefile+"_f",&w.l,&h.l}
          If Right$(imagefile,6)=".9.png"
            *tbm\bmode=#TUIIBM_9PATCH
          Else
            *tbm\bmode=#TUIIBM_MASK
          End If
        End If
      End If

      If *tpa\normal=Null ; try picture Datatype...
        *tpa\normal  = _ntui_LoadBitMapViaDT{imagefile,0,&w.l,&h.l}
        *tbm\bmode   = #TUIIBM_OPAQUE
        *tpa\width   = w
        *tpa\height  = h
      End If

      If *tpa\normal=Null ; still nothing? try DefIcon...
        If _ntui_LoadBitMapViaIcon{imagefile,*tpa}
          *tbm\bmode=#TUIIBM_MASK
        End If
      End If

      If *tpa\normal=Null ; well seems not be existent!
        FreeVec_ *tbm\pixelArrayA : *tbm\pixelArrayA = Null
        FreeVec_ *tbm : *tbm = Null
      Else
        Poke.l tuiGlobal\bitMapCache\tuiBitMapA + (tuiGlobal\bitMapCache\tuiBitMapsUsed*SizeOf.l),*tbm
        *tbm\useCount              = 1
        str_Write{&*tbm\name,imagefile}
        tuiGlobal\bitMapCache\tuiBitMapsUsed+1

        If *tbm\bmode = #TUIIBM_9PATCH
          bpr.l     = *tpa\width*4
          iwidth.l  = *tpa\width-2
          iheight.l = *tpa\height-2

          *tpa\hscale = 0
          srcP.l = *tpa\normal + 4
          For x.l = 0 To iwidth-1
            sA.l=Peek.b(srcP) & $FF
            If sA>127
              Poke.b srcP,1 : *tpa\hscale+1
              *tpa\trans\right = x
            Else
              Poke.b srcP,0 : If *tpa\hscale=0 Then *tpa\trans\left+1
            End If
            srcP+4
          Next
          *tpa\hfix  = (iwidth) - *tpa\hscale
          *tpa\trans\right = iwidth-*tpa\trans\right

          *tpa\vscale = 0
          srcP.l = *tpa\normal + bpr
          For x.l = 0 To iheight-1
            sA.l=Peek.b(srcP) & $FF
            If sA>127
              Poke.b srcP,1 : *tpa\vscale+1
              *tpa\trans\bottom = x
            Else
              Poke.b srcP,0 : If *tpa\vscale=0 Then *tpa\trans\top+1
            End If
            srcP+bpr
          Next
          *tpa\vfix  = (iheight) - *tpa\vscale
          *tpa\trans\bottom = iwidth-*tpa\trans\bottom

          *tpa\border\left = 0
          x.l = 1
          y.l = *tpa\height-1
          srcP.l = *tpa\normal + (bpr*y) + x*4
          For x.l = 0 To iwidth-1
            sA.l=Peek.b(srcP) & $FF : srcP+4
            If sA>=128
              x = iwidth
            Else
              *tpa\border\left + 1
            End If
          Next

          *tpa\border\right = 0
          x.l = *tpa\width-1-1
          y.l = *tpa\height-1
          srcP.l = *tpa\normal + (bpr*y) + x*4
          For x.l = 0 To iwidth-1
            sA.l=Peek.b(srcP) & $FF : srcP-4
            If sA>=128
              x = iwidth
            Else
              *tpa\border\right + 1
            End If
          Next

          *tpa\border\top = 0
          x.l = *tpa\width-1
          y.l = 1
          srcP.l = *tpa\normal + (bpr*y) + x*4
          For x.l = 0 To iheight-1
            sA.l=Peek.b(srcP) & $FF : srcP+bpr
            If sA>=128
              x = iheight
            Else
              *tpa\border\top + 1
            End If
          Next

          *tpa\border\bottom = 0
          x.l = *tpa\width-1
          y.l = *tpa\height-1-1
          srcP.l = *tpa\normal + (bpr*y) + x*4
          For x.l = 0 To iheight-1
            sA.l=Peek.b(srcP) & $FF : srcP-bpr
            If sA>=128
              x = iheight
            Else
              *tpa\border\bottom + 1
            End If
          Next
          a.s = Str$(*tpa\border\left)+"/"+Str$(*tpa\border\top)+"/"+Str$(*tpa\border\right)+"/"+Str$(*tpa\border\bottom)
          b.s = Str$(*tpa\hscale)+"/"+Str$(*tpa\vscale)+"/"+Str$(*tpa\width)+"/"+Str$(*tpa\height)
          ;error{imagefile+": scale="+b.s+"content: "+a.s}
        End If

      End If

  ;    If *tpa\normal   Then _ntui_ThresholdAlpha{*tpa\normal  ,*tpa\width,*tpa\height,20}
  ;    If *tpa\selected Then _ntui_ThresholdAlpha{*tpa\selected,*tpa\width,*tpa\height,20}
  ;    If *tpa\disabled  Then _ntui_ThresholdAlpha{*tpa\disabled ,*tpa\width,*tpa\height,20}
    Else
      FreeVec_ *tbm : *tbm = Null
    End If
  End If

  Function Return *tbm

End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ntui_ReleaseTuiBitMap {*tbm.tuiBitMap}                             /
;/                                                                             /
;/ Description:                                                                /
;/ private
;/                                                                            /
;/ Inputs:                                                                     /
;/ - *tbm.tuiBitMap    : ???                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ntui_ReleaseTuiBitMap{*tbm.tuiBitMap}

  *tbm\useCount-1

End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ntui_ScalePixelArray {srcA.l,srcWidth.l,srcHeight.l,srcBPR.l,dst:: /
;/ A.l,dstWidth.l,dstHeight.l,dstBPR.l,mode.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - srcA.l       : ???                                                           /
;/ - srcWidth.l   : ???                                                       /
;/ - srcHeight.l  : ???                                                      /
;/ - srcBPR.l     : ???                                                         /
;/ - dstA.l       : ???                                                           /
;/ - dstWidth.l   : ???                                                       /
;/ - dstHeight.l  : ???                                                      /
;/ - dstBPR.l     : ???                                                         /
;/ - mode.l       : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
RunErrsOff
Statement _ntui_ScalePixelArray{srcA.l,srcWidth.l,srcHeight.l,srcBPR.l,dstA.l,dstWidth.l,dstHeight.l,dstBPR.l,mode.l}
sxs.l   = srcWidth
sys.l   = srcHeight
dxs.l   = dstWidth
dys.l   = dstHeight
fracX.l = 0
fracY.l = 0
sy.l    = 0

pw.l = sxs*sys : If pw<1 Then pw=1

shift.l = 0

While pw>$1000 : pw/2 : shift+1 : Wend
If shift>0 AND mode=2 Then mode=1

Select mode
  Case 0
    fracY.l = sys ASR 1
    For dy.l=0 To dys-1
      sptr.l = srcA + sy * srcBPR
      dptr.l = dstA + dy * dstBPR
      fracY+sys : While fracY>dys:fracY-dys:sy+1:Wend
      fracX.l = sxs ASR 1
      For dx.l = 0 To dxs-1
        Poke.l dptr,Peek.l(sptr) :dptr+4
        fracX+sxs : While fracX>dxs:fracX-dxs:sptr+4:Wend
      Next
    Next

  Default
    For dy.l=0 To dys-1
      weightY1.l = (dys-fracY)
      cy.l=0 : fracY+sys : While fracY>dys:fracY-dys:cy+1:Wend
      sptr.l = srcA + sy * srcBPR
      dptr.l = dstA + dy * dstBPR
      fracX.l = 0
      For dx.l = 0 To dxs-1
        weightX1.l = (dxs-fracX)
        cx.l=0 : fracX+sxs : While fracX>dxs:fracX-dxs:cx+1:Wend

        ; Calculate the pixel...
        R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
        weightY.l = weightY1
        nsptr.l = sptr + (cx LSL 2)
        For m.l = 0 To cy
          weightX.l = weightX1
          If m = cy Then weightY = weightY + (fracY-dys)
          For n.l = 0 To cx
            If n = cx Then weightX = weightX + (fracX-dxs)
            tpw.l = (weightX*weightY) LSR shift
            tA.l = (Peek.b(sptr  ) & $FF) *tpw
            A.l + tA
            R.l + (Peek.b(sptr+1) & $FF) * (tA)
            G.l + (Peek.b(sptr+2) & $FF) * (tA)
            B.l + (Peek.b(sptr+3) & $FF) * (tA)
            weightX = dxs
            sptr+4
          Next
          sptr - 4*(cx+1) + srcBPR
          weightY = (dys)
        Next
        sptr = nsptr
        If A>0
          Poke.b dptr  ,(A / pw)
          Poke.b dptr+1,(R / A)
          Poke.b dptr+2,(G / A)
          Poke.b dptr+3,(B / A)
        Else
          Poke.l dptr,0
        End If
        dptr+4
      Next
      sy+cy
    Next
  End Select

  If mode = 2
    ; the sharpen step

    fracX.l = 0
    fracY.l = 0
    sy.l = 0
    pw.l = sxs*sys : If pw<1 Then pw=1
    sn.l = 256;196

    For dy.l=0 To dys-1
      weightY1.l = (dys-fracY)
      cy.l=0 : fracY+sys : While fracY>dys:fracY-dys:cy+1:Wend
      sptr.l = srcA + sy * srcBPR
      dptr.l = dstA + dy * dstBPR
      tptr.l = dstA + dy * dstBPR
      tbpr.l = dstBPR

      fracX.l = 0
      For dx.l = 0 To dxs-1
        weightX1.l = (dxs-fracX)
        cx.l=0 : fracX+sxs : While fracX>dxs:fracX-dxs:cx+1:Wend

        ; Calculate the pixel...
        R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
        weightY.l = weightY1
        nsptr.l = sptr + (cx LSL 2)

        ; get the sourounding ...
        div.l = 0
        aR.l = 0
        aG.l = 0
        aB.l = 0
        If dx>0
          aR.l + (Peek.b(tptr+1-4) & $FF) LSL 1
          aG.l + (Peek.b(tptr+2-4) & $FF) LSL 1
          aB.l + (Peek.b(tptr+3-4) & $FF) LSL 1
          div+2
        End If
        If dx<dxs-1
          aR.l + (Peek.b(tptr+1+4) & $FF) LSL 1
          aG.l + (Peek.b(tptr+2+4) & $FF) LSL 1
          aB.l + (Peek.b(tptr+3+4) & $FF) LSL 1
          div+2
        End If
        If dy>0
          aR.l + (Peek.b(tptr+1-tbpr) & $FF) LSL 1
          aG.l + (Peek.b(tptr+2-tbpr) & $FF) LSL 1
          aB.l + (Peek.b(tptr+3-tbpr) & $FF) LSL 1
          div+2
        End If
        If dy<dys-1
          aR.l + (Peek.b(tptr+1+tbpr) & $FF) LSL 1
          aG.l + (Peek.b(tptr+2+tbpr) & $FF) LSL 1
          aB.l + (Peek.b(tptr+3+tbpr) & $FF) LSL 1
          div+2
        End If
        If dx>0 AND dy>0
          aR.l + (Peek.b(tptr+1-4-tbpr) & $FF)
          aG.l + (Peek.b(tptr+2-4-tbpr) & $FF)
          aB.l + (Peek.b(tptr+3-4-tbpr) & $FF)
          div+1
        End If
        If dx<dxs-1 AND dy<dys-1
          aR.l + (Peek.b(tptr+1+4+tbpr) & $FF)
          aG.l + (Peek.b(tptr+2+4+tbpr) & $FF)
          aB.l + (Peek.b(tptr+3+4+tbpr) & $FF)
          div+1
        End If
        If dy>0 AND dx<dxs-1
          aR.l + (Peek.b(tptr+1+4-tbpr) & $FF)
          aG.l + (Peek.b(tptr+2+4-tbpr) & $FF)
          aB.l + (Peek.b(tptr+3+4-tbpr) & $FF)
          div+1
        End If
        If dy<dys-1 AND dx>0
          aR.l + (Peek.b(tptr+1-4+tbpr) & $FF)
          aG.l + (Peek.b(tptr+2-4+tbpr) & $FF)
          aB.l + (Peek.b(tptr+3-4+tbpr) & $FF)
          div+1
        End If
        If div>0
          aR / div
          aG / div
          aB / div
        End If
        addWeight.l = 0

        For m.l = 0 To cy
          weightX.l = weightX1
          If m = cy Then weightY = weightY + (fracY-dys)
          For n.l = 0 To cx
            If n = cx Then weightX = weightX + (fracX-dxs)
            tpw.l = weightX*weightY

            tA.l = Peek.b(sptr  ) & $FF
            tR.l = Peek.b(sptr+1) & $FF
            tG.l = Peek.b(sptr+2) & $FF
            tB.l = Peek.b(sptr+3) & $FF

            dR.l = aR-tR
            dG.l = aG-tG
            dB.l = aB-tB
            d.l = ((dR*dR + dG*dG + dB*dB) * sn ) LSR 16
            If d<1 Then d=1

            fX.l = (tpw * d * tA) LSR 8

            R.l + (tR * fX)
            G.l + (tG * fX)
            B.l + (tB * fX)
            addWeight + fX
            weightX = dxs
            sptr+4
          Next
          sptr - 4*(cx+1) + srcBPR
          weightY = (dys)
        Next
        sptr = nsptr

        If addWeight>0
          R / addWeight
          G / addWeight
          B / addWeight
        End If

        Poke.b dptr+1,R ;/ pw
        Poke.b dptr+2,G ;/ pw
        Poke.b dptr+3,B ;/ pw
        dptr +4
        tptr +4
      Next
      sy+cy
    Next

  End If

End Statement
LastRunErrsMode

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_CreatePixelArray {*tbm.tuiBitMap,width.l,height.:: /
;/ l,mode.l}                                                                   /
;/                                                                             /
;/ Description:                                                                /
;/     ; scale step                                                            /
;/         ; Calculate the pixel...                                            /
;/     ; the sharpen step                                                      /
;/         ; Calculate the pixel...                                            /
;/         ; get the sourounding ...                                           /
;/             dR.l = aR-tR ;: If dR<0 Then dR = -dR                           /
;/             dG.l = aG-tG ;: If dG<0 Then dG = -dG                           /
;/             dB.l = aB-tB ;: If dB<0 Then dB = -dB                           /
;/             d = d+1;(d LSR 1) + 1                                           /
;/           R / addWeight  ;: If R>255 Then R=255                             /
;/           G / addWeight  ;: If G>255 Then G=255                             /
;/           B / addWeight  ;: If B>255 Then B=255                             /
;/         ; Calculate the pixel...                                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tbm.tuiBitMap    : ???                                                   /
;/ - width.l    : ???                                                          /
;/ - height.l    : ???                                                         /
;/ - mode.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ntui_CreatePixelArray{*tbm.tuiBitMap,width.l,height.l,mode.l}

  If *tbm=Null Then Function Return Null
  If *tbm\pixelArrayA=Null Then Function Return Null

  If *tbm\pixelArraysAlloc<=*tbm\pixelArraysUsed
    ;error {"Extent pixelarray!"}
    newAlloc.l = *tbm\pixelArraysUsed+4
    *newList.tuiPixelArray = AllocVec_ (newAlloc*SizeOf.tuiPixelArray,#MEMF_ANY)
    If *newList
      CopyMem_ *tbm\pixelArrayA,*newList,SizeOf.tuiPixelArray * *tbm\pixelArraysUsed
      If *tbm\pixelArrayA Then FreeVec_ *tbm\pixelArrayA
      *tbm\pixelArrayA  = *newList
      *tbm\pixelArraysAlloc = newAlloc
    End If
  End If
  If *tbm\pixelArraysAlloc<=*tbm\pixelArraysUsed Then Function Return Null

  *srcPixelArray.tuiPixelArray = *tbm\pixelArrayA
  *dstPixelArray.tuiPixelArray = *tbm\pixelArrayA + SizeOf.tuiPixelArray* *tbm\pixelArraysUsed
  *dstPixelArray\normal    = Null
  *dstPixelArray\active    = Null
  *dstPixelArray\disabled   = Null
  *dstPixelArray\focus     = Null
  *dstPixelArray\mover     = Null


  If (*srcPixelArray\normal)
    *dstPixelArray\normal = AllocVec_(width*height*4,#MEMF_ANY)
    If (*dstPixelArray\normal)
      _ntui_ScalePixelArray{*srcPixelArray\normal,*srcPixelArray\width,*srcPixelArray\height,*srcPixelArray\width*4,*dstPixelArray\normal,width,height,width*4,mode}
    End If
  End If

  If (*srcPixelArray\active)
    *dstPixelArray\active = AllocVec_(width*height*4,#MEMF_ANY)
    If (*dstPixelArray\active)
      _ntui_ScalePixelArray{*srcPixelArray\active,*srcPixelArray\width,*srcPixelArray\height,*srcPixelArray\width*4,*dstPixelArray\active,width,height,width*4,mode}
    End If
  End If

  If (*srcPixelArray\disabled)
    *dstPixelArray\disabled = AllocVec_(width*height*4,#MEMF_ANY)
    If (*dstPixelArray\disabled)
      _ntui_ScalePixelArray{*srcPixelArray\disabled,*srcPixelArray\width,*srcPixelArray\height,*srcPixelArray\width*4,*dstPixelArray\disabled,width,height,width*4,mode}
    End If
  End If

  If (*srcPixelArray\focus)
    *dstPixelArray\focus = AllocVec_(width*height*4,#MEMF_ANY)
    If (*dstPixelArray\focus)
      _ntui_ScalePixelArray{*srcPixelArray\focus,*srcPixelArray\width,*srcPixelArray\height,*srcPixelArray\width*4,*dstPixelArray\focus,width,height,width*4,mode}
    End If
  End If

  If (*srcPixelArray\mover)
    *dstPixelArray\mover = AllocVec_(width*height*4,#MEMF_ANY)
    If (*dstPixelArray\mover)
      _ntui_ScalePixelArray{*srcPixelArray\mover,*srcPixelArray\width,*srcPixelArray\height,*srcPixelArray\width*4,*dstPixelArray\mover,width,height,width*4,mode}
    End If
  End If


  *tbm\pixelArraysUsed+1
  *dstPixelArray\width  = width
  *dstPixelArray\height = height

  Function Return *dstPixelArray

End Function
 

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_AccessTBImage {*tbi.tuiTBImage}                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tbi.tuiTBImage    : ???                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ntui_AccessTBImage{*tbi.tuiTBImage}

  *tbm.tuiBitMap = *tbi\tuiBitMap
  If *tbm
    *tpa.tuiPixelArray = *tbm\pixelArrayA
    If *tbi\tuiWidth =#TUISIZE_NATIVE Then width.l =*tbm\pixelArrayA\width  : Else width =*tbi\engine\defSize[*tbi\tuiWidth]
    If *tbi\tuiHeight=#TUISIZE_NATIVE Then height.l=*tbm\pixelArrayA\height : Else height=*tbi\engine\defSize[*tbi\tuiHeight]

    If (*tbm\pixelArrayA\height)>0
      swidth.l    = *tbm\pixelArrayA\width  * height / *tbm\pixelArrayA\height
      If swidth<width   Then width = swidth
    End If
    If (*tbm\pixelArrayA\width>0)
      sheight.l   = *tbm\pixelArrayA\height * width  / *tbm\pixelArrayA\width
      If sheight<height Then height =sheight
    End If
    ; find the bitmap...
    For n.l=0 To *tbm\pixelArraysUsed-1
      *tpa.tuiPixelArray = *tbm\pixelArrayA + n*SizeOf.tuiPixelArray
      If *tpa\height = height AND *tpa\width <=width  Then Function Return *tpa
      If *tpa\width  = width  AND *tpa\height<=height Then Function Return *tpa
    Next
    *tpa = _ntui_CreatePixelArray{*tbm,width,height,2}
  Else
    *tpa=Null
  End If

  Function Return *tpa

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_GetTBImageWidth {*tbi.tuiTBImage}                   /
;/                                                                             /
;/ Description:                                                                /
;/   ; find the bitmap...                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tbi.tuiTBImage    : ???                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ntui_GetTBImageWidth{*tbi.tuiTBImage}

  *tpa.tuiPixelArray=_ntui_AccessTBImage{*tbi}
  If *tpa Then Function Return *tpa\width

  If *tbi\tuiWidth=#TUISIZE_NATIVE
    If *tbi\tuiBitMap
      Function Return *tbi\tuiBitMap\pixelArrayA\width
    Else
      Function Return *tbi\engine\defSize[#TUISIZE_NATIVE];24
    End If
  End If

  Function Return *tbi\engine\defSize[*tbi\tuiWidth]

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_GetTBImageHeight {*tbi.tuiTBImage}                  /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tbi.tuiTBImage    : ???                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ntui_GetTBImageHeight{*tbi.tuiTBImage}

  *tpa.tuiPixelArray=_ntui_AccessTBImage{*tbi}
  If *tpa Then Function Return *tpa\height

  If *tbi\tuiHeight=#TUISIZE_NATIVE
    If *tbi\tuiBitMap
      Function Return *tbi\tuiBitMap\pixelArrayA\height
    Else
      Function Return *tbi\engine\defSize[#TUISIZE_NATIVE]
    End If
  End If

  Function Return *tbi\engine\defSize[*tbi\tuiHeight]

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ntui_FreeBitMapCache {}                                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ntui_FreeBitMapCache{}

  If tuiGlobal\bitMapCache\tuiBitMapA
    For n.l=0 To tuiGlobal\bitMapCache\tuiBitMapsUsed-1
      *tbm.tuiBitMap = Peek.l(tuiGlobal\bitMapCache\tuiBitMapA + (SizeOf.l*n))
      If *tbm
        If *tbm\pixelArrayA
          For m.l=0 To *tbm\pixelArraysUsed-1
            *tpa.tuiPixelArray = *tbm\pixelArrayA + (SizeOf.tuiPixelArray*m)
            If *tpa\active   Then FreeVec_ *tpa\active   : *tpa\active   =Null
            If *tpa\normal   Then FreeVec_ *tpa\normal   : *tpa\normal   =Null
            If *tpa\focus    Then FreeVec_ *tpa\focus    : *tpa\focus    =Null
            If *tpa\mover    Then FreeVec_ *tpa\mover    : *tpa\mover    =Null
            If *tpa\disabled Then FreeVec_ *tpa\disabled : *tpa\disabled =Null
          Next
          FreeVec_ *tbm\pixelArrayA
        End If
        *tbm\pixelArrayA      = Null
        *tbm\pixelArraysUsed  = 0
        *tbm\pixelArraysAlloc = 0
        FreeVec_ *tbm
        Poke.l tuiGlobal\bitMapCache\tuiBitMapA + (4*n), Null
      End If

    Next
    FreeVec_ tuiGlobal\bitMapCache\tuiBitMapA
  End If
  tuiGlobal\bitMapCache\tuiBitMapA      = Null
  tuiGlobal\bitMapCache\tuiBitMapsUsed  = 0
  tuiGlobal\bitMapCache\tuiBitMapsAlloc = 0

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_CreateTBImage {*engine.tuiEngine,image.s,@tuiW:: /
;/ idth.l,@tuiHeight.l}                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *engine.tuiEngine    : ???                                             /
;/ - image.s    : ???                                                          /
;/ - tuiWidth.l    : ???                                                       /
;/ - tuiHeight.l    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Dim tuiAISS.s(#TUIMAX_IMAGES-1)
SHARED tuiAISS()
tuiAISS(#TUIIMAGE_CHECKMARK ) = "TBImages:list_checkmark"
tuiAISS(#TUIIMAGE_PATH      ) = "TBImages:drawer"
tuiAISS(#TUIIMAGE_FILE      ) = "TBImages:file"
tuiAISS(#TUIIMAGE_SAVE      ) = "TBImages:save"
tuiAISS(#TUIIMAGE_FONT      ) = "TBImages:font_type"
tuiAISS(#TUIIMAGE_SCREEN    ) = "TBImages:screen"
tuiAISS(#TUIIMAGE_CYCLE     ) = "TBImages:refresh"
tuiAISS(#TUIIMAGE_INC       ) = "TBImages:increase"
tuiAISS(#TUIIMAGE_DEC       ) = "TBImages:decrease"
tuiAISS(#TUIIMAGE_ARROWUP   ) = "TBImages:arrowupfilled";scrollup"
tuiAISS(#TUIIMAGE_ARROWDOWN ) = "TBImages:arrowdownfilled";scrolldown"
tuiAISS(#TUIIMAGE_ARROWLEFT ) = "TBImages:arrowleftfilled";scrollleft"
tuiAISS(#TUIIMAGE_ARROWRIGHT) = "TBImages:arrowrightfilled";scrollright"
tuiAISS(#TUIIMAGE_OLARROWUP   ) = "TBImages:arrowup";scrollup"
tuiAISS(#TUIIMAGE_OLARROWDOWN ) = "TBImages:arrowdown";scrolldown"
tuiAISS(#TUIIMAGE_OLARROWLEFT ) = "TBImages:arrowleft";scrollleft"
tuiAISS(#TUIIMAGE_OLARROWRIGHT) = "TBImages:arrowright";scrollright"
tuiAISS(#TUIIMAGE_POPUP     ) = "TBImages:stape_eject"
tuiAISS(#TUIIMAGE_DROPDOWN  ) = "TBImages:stape_insert"
tuiAISS(#TUIIMAGE_LEFT      ) = "TBImages:stape_rew"
tuiAISS(#TUIIMAGE_RIGHT     ) = "TBImages:stape_ffw"
tuiAISS(#TUIIMAGE_DELETE    ) = "TBImages:delete"
tuiAISS(#TUIIMAGE_NEW       ) = "TBImages:new"
tuiAISS(#TUIIMAGE_EDIT      ) = "TBImages:edit"
tuiAISS(#TUIIMAGE_AMIGA     ) = "TBImages:key_amigal"
tuiAISS(#TUIIMAGE_CTRL      ) = "TBImages:key_ctrl"
tuiAISS(#TUIIMAGE_SHIFT     ) = "TBImages:key_capslock"
tuiAISS(#TUIIMAGE_ALT       ) = "TBImages:key_alt"
tuiAISS(#TUIIMAGE_CHECKOFF  ) = "TBImages:list_checkbox_s"
tuiAISS(#TUIIMAGE_CHECKON   ) = "TBImages:list_checkbox"
tuiAISS(#TUIIMAGE_RADIOOFF  ) = "TBImages:list_led"
tuiAISS(#TUIIMAGE_RADIOON   ) = "TBImages:list_ledblue_s"
tuiAISS(#TUIIMAGE_NODEEXPAND) = "TBImages:list_node_expand"
tuiAISS(#TUIIMAGE_NODECOLLAPSE) = "TBImages:list_node_collaps"

Function.tuiTBImage ntui_CreateTBImage{*engine.tuiEngine,image.s,@tuiWidth.l,@tuiHeight.l}
!_ASSERT{*engine}

  *tbi.tuiTBImage = AllocVec_ (SizeOf.tuiTBImage,#MEMF_CLEAR)
  If *tbi = Null Then Function Return Null

  *tbi\engine = *engine
  If tuiWidth<=0  Then *tbi\tuiWidth     = #TUISIZE_NATIVE : Else *tbi\tuiWidth  = tuiWidth
  If tuiHeight<=0 Then *tbi\tuiHeight    = #TUISIZE_NATIVE : Else *tbi\tuiHeight = tuiHeight
  *tbi\tuiBitMap = Null

  epos.l = Instr(image,"|")
  If epos
    emblem.s = Right$(image,FLen(image)-epos)
    image    = Left$(image,epos-1)
    *tbi\emblem = ntui_CreateTBImage{*engine,emblem,#TUISIZE_EMBLEM,#TUISIZE_EMBLEM}
  End If

  Select image
    Case ""             : *tbi\tuiImage = #TUIIMAGE_UNKNOWN      ; default image
    Case "CHECKMARK"    : *tbi\tuiImage = #TUIIMAGE_CHECKMARK    ; checkbox
    Case "UNCHECKMARK"  : *tbi\tuiImage = #TUIIMAGE_CHECKMARK2   ; checkbox
    Case "CHECKON"      : *tbi\tuiImage = #TUIIMAGE_CHECKON      ; checkbox
    Case "CHECKOFF"     : *tbi\tuiImage = #TUIIMAGE_CHECKOFF     ; checkbox
    Case "PATH"         : *tbi\tuiImage = #TUIIMAGE_PATH         ; for ASLFR
    Case "FILE"         : *tbi\tuiImage = #TUIIMAGE_FILE         ; for ASLFR
    Case "FONT"         : *tbi\tuiImage = #TUIIMAGE_FONT         ; for ASLFO
    Case "SCREEN"       : *tbi\tuiImage = #TUIIMAGE_SCREEN       ; for ASLSR
    Case "ARROWUP"      : *tbi\tuiImage = #TUIIMAGE_ARROWUP      ; scroller arrows
    Case "ARROWLEFT"    : *tbi\tuiImage = #TUIIMAGE_ARROWLEFT
    Case "ARROWRIGHT"   : *tbi\tuiImage = #TUIIMAGE_ARROWRIGHT
    Case "ARROWDOWN"    : *tbi\tuiImage = #TUIIMAGE_ARROWDOWN
    Case "CYCLE"        : *tbi\tuiImage = #TUIIMAGE_CYCLE        ; cycle gadget
    Case "PLUSMINUS"    : *tbi\tuiImage = #TUIIMAGE_PLUSMINUS
    Case "INC"          : *tbi\tuiImage = #TUIIMAGE_INC
    Case "DEC"          : *tbi\tuiImage = #TUIIMAGE_DEC
    Case "SAVE"         : *tbi\tuiImage = #TUIIMAGE_SAVE
    Case "OLARROWUP"    : *tbi\tuiImage = #TUIIMAGE_OLARROWUP    ; scroller arrows
    Case "OLARROWLEFT"  : *tbi\tuiImage = #TUIIMAGE_OLARROWLEFT
    Case "OLARROWRIGHT" : *tbi\tuiImage = #TUIIMAGE_OLARROWRIGHT
    Case "OLARROWDOWN"  : *tbi\tuiImage = #TUIIMAGE_OLARROWDOWN
    Case "POPUP"        : *tbi\tuiImage = #TUIIMAGE_POPUP        ; menu arrows
    Case "DROPDOWN"     : *tbi\tuiImage = #TUIIMAGE_DROPDOWN
    Case "LEFT"         : *tbi\tuiImage = #TUIIMAGE_LEFT
    Case "RIGHT"        : *tbi\tuiImage = #TUIIMAGE_RIGHT
    Case "AMIGA"        : *tbi\tuiImage = #TUIIMAGE_AMIGA
    Case "CTRL"         : *tbi\tuiImage = #TUIIMAGE_CTRL
    Case "SHIFT"        : *tbi\tuiImage = #TUIIMAGE_SHIFT
    Case "ALT"          : *tbi\tuiImage = #TUIIMAGE_ALT
    Case "RADIOON"      : *tbi\tuiImage = #TUIIMAGE_RADIOON
    Case "RADIOOFF"     : *tbi\tuiImage = #TUIIMAGE_RADIOOFF
    Case "DELETE"       : *tbi\tuiImage = #TUIIMAGE_DELETE
    Case "EDIT"         : *tbi\tuiImage = #TUIIMAGE_EDIT
    Case "NODEEXPAND"   : *tbi\tuiImage = #TUIIMAGE_NODEEXPAND
    Case "NODECOLLAPSE" : *tbi\tuiImage = #TUIIMAGE_NODECOLLAPSE
    Case "NEW"          : *tbi\tuiImage = #TUIIMAGE_NEW
    Default             : *tbi\tuiImage = #TUIIMAGE_BITMAP
      *buff.b = AllocVec_(4096,#MEMF_ANY)
      If *buff
        ;imagefile.s=image
        lock.l = Lock_ (&image,#ACCESS_READ)
        If lock
          If NameFromLock_(lock,*buff,4095) = 0 Then imagefile.s=Peek.s(*buff) : Else imagefile=image
          UnLock_ lock
          *tbi\tuiBitMap = _ntui_ObtainTuiBitMap{imagefile}
        End If
        ;If image="aiss" Then error{"trying "+imagefile+" = "+Hex$(*tbi\tuiBitMap)}
      
        If *tbi\tuiBitMap = Null
          If str_Len{*engine\imagePath}>0
            imagefile = dos_AddPart{str_Read{&*engine\imagePath},image}
            lock.l = Lock_ (&imagefile,#ACCESS_READ)
            If lock
              If NameFromLock_(lock,*buff,4095) = 0 Then imagefile=Peek.s(*buff)
              UnLock_ lock
              *tbi\tuiBitMap = _ntui_ObtainTuiBitMap{imagefile}
            End If
          End If
          ;If image="aiss" Then error{"trying "+imagefile+" = "+Hex$(*tbi\tuiBitMap)}
        End If
      
        If *tbi\tuiBitMap = Null
          If str_Len{*engine\aissPath}>0
            imagefile = dos_AddPart{str_Read{&*engine\aissPath},image}
            lock.l = Lock_ (&imagefile,#ACCESS_READ)
            If lock
              If NameFromLock_(lock,*buff,4095) = 0 Then imagefile=Peek.s(*buff)
              UnLock_ lock
              *tbi\tuiBitMap = _ntui_ObtainTuiBitMap{imagefile}
            End If
          End If
          ;If image="aiss" Then error{"trying "+imagefile+" = "+Hex$(*tbi\tuiBitMap)}
        End If
      
        FreeVec_ *buff
      End If
      
      If *tbi\tuiBitMap=Null Then *tbi\tuiImage = #TUIIMAGE_UNKNOWN ;: error{"Loading error: "+image}
  End Select

  If *tbi\tuiBitMap=Null
    If *engine\useAISS
      If *tbi\tuiImage>=0 AND *tbi\tuiImage<#TUIMAX_IMAGES
        If tuiAISS(*tbi\tuiImage)><"" ; map to AISS!
          *tbi\tuiBitMap = _ntui_ObtainTuiBitMap{tuiAISS(*tbi\tuiImage)}
          If *tbi\tuiBitMap Then *tbi\tuiImage = #TUIIMAGE_BITMAP
        End If
      End If
    End If
  End If

  Function Return *tbi

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_FreeTBImage {*tbi.tuiTBImage}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tbi.tuiTBImage    : ???                                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_FreeTBImage{*tbi.tuiTBImage}

  If *tbi=Null Then Statement Return
  If *tbi\tuiBitMap Then _ntui_ReleaseTuiBitMap{*tbi\tuiBitMap} : *tbi\tuiBitMap = Null
  If *tbi\emblem Then ntui_FreeTBImage{*tbi\emblem}  : *tbi\emblem = Null
  FreeVec_ *tbi : *tbi = Null

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_DrawTBImage {*tbi.tuiTBImage,*rp.RastPort,x1.l,y1.l,x2.l,y2.:: /
;/ l,flags.l,bgTuiPen.l}                                                       /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tbi.tuiTBImage    : ???                                                  /
;/ - *rp.RastPort    : ???                                                     /
;/ - x1.l    : ???                                                             /
;/ - y1.l    : ???                                                             /
;/ - x2.l    : ???                                                             /
;/ - y2.l    : ???                                                             /
;/ - flags.l    : ???                                                          /
;/ - bgTuiPen.l    : ???                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_DrawTBImage{*tbi.tuiTBImage,*rp.RastPort,*bbox.tuiRect,*cbox.tuiRect,flags.l,bgTuiPen.l}
  !_ASSERT{*tbi}
  *engine.tuiEngine = *tbi\engine
  !_ASSERT{*engine}

  If bgTuiPen>=0
    bgPen.l  = *engine\pen[bgTuiPen]
    bgARGB.l = *engine\penInfo[bgTuiPen]\rgb_
  Else
    bgPen.l  = -1
    bgARGB.l = -1
  End If

  x1.l = *cbox\left
  y1.l = *cbox\top
  x2.l = *cbox\right
  y2.l = *cbox\bottom

  If *tbi\tuiImage><#TUIIMAGE_BITMAP
    If bgPen>=0
      SetAPen_ *rp,bgPen
      RectFill_ *rp,*bbox\left,*bbox\top,*bbox\right,*bbox\bottom
    End If
  End If

  CNIF #TUI_DEBUG
    SetAPen_ *rp,1
    RectFill_ *rp,*bbox\left,*bbox\top,*bbox\right,*bbox\bottom
    SetAPen_ *rp,2
    RectFill_ *rp,*cbox\left,*cbox\top,*cbox\right,*cbox\bottom
    bgPen=-1
  CEND

  If (flags&#TUIF_DISABLED)
    fgPen.l = *engine\pen[#TUIPEN_HALFSHADOW]
   Else
    If (flags&#TUIF_ACTIVE)
      fgPen = *engine\pen[#TUIPEN_WHITE]
    Else
      fgPen = *engine\pen[#TUIPEN_BLACK]
    End If
  End If

  SetAPen_ *rp,fgPen

  sizey.l = *engine\defSize[*tbi\tuiHeight]
  sizex.l = *engine\defSize[*tbi\tuiWidth]

  If sizex<sizey Then size.l=sizex: Else size.l=sizey

Macro _ntui_keyborder
sx2.l = (size-1)/2
sy2.l = (size)/3
x.l = (x1+x2)/2
y.l = (y1+y2)/2

If sy2<#TUI_MINPIXELSIZE/2+1 Then sy2=#TUI_MINPIXELSIZE/2+1
If sx2<#TUI_MINPIXELSIZE/2+1 Then sx2=#TUI_MINPIXELSIZE/2+1
If sy2*2<sizey AND sx2*2<sizex
  pen.l = *rp\FgPen
  SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHINE]
  SetDrMd_ *rp,#JAM2
  RectFill_ *rp,x-sx2+1,y-sy2+1,x+sx2-1,y+sy2-1
  SetAPen_ *rp,*engine\pen[#TUIPEN_SHINE]
  Move_ *rp,x-sx2+1,y-sy2 : Draw_ *rp,x+sx2-1,y-sy2 ; button
  Move_ *rp,x-sx2,y-sy2+1 : Draw_ *rp,x-sx2,y+sy2-1

;   Move_ *rp,x-sx2-1,y-sy2-1 : Draw_ *rp,x+sx2+1,y-sy2-1
;   Move_ *rp,x-sx2-1,y-sy2-1 : Draw_ *rp,x-sx2-1,y+sy2+1

  SetAPen_ *rp,*engine\pen[#TUIPEN_SHADOW]
  Move_ *rp,x+sx2,y-sy2+1 : Draw_ *rp,x+sx2,y+sy2-1
  Move_ *rp,x-sx2+1,y+sy2 : Draw_ *rp,x+sx2-1,y+sy2

  ;SetAPen_ *rp,*engine\pen[#TUIPEN_SHADOW]
  ;Move_ *rp,x-sx2+1-1,y+sy2+1 : Draw_ *rp,x+sx2,y+sy2+1
  ;Move_ *rp,x+sx2+1,y-sy2+1-1 : Draw_ *rp,x+sx2+1,y+sy2
  ;WritePixel_ *rp,x+sx2,y+sy2
  SetAPen_ *rp,pen
End If
End Macro
 


Select *tbi\tuiImage
  Case #TUIIMAGE_AMIGA
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    !_ntui_keyborder

    x.l = (x1+x2)/2
    y.l = (y1+y2)/2

    sy2.l = (size)/3-4
    If sy2<#TUI_MINPIXELSIZE/2-1 Then sy2=#TUI_MINPIXELSIZE/2-1
    sx2.l=sy2
    Move_ *rp,x+sx2,y-sy2     : Draw_ *rp,x+sx2,y+sy2 ; A
    Move_ *rp,x+sx2-1,y-sy2+1 : Draw_ *rp,x+sx2-1,y+sy2
    Move_ *rp,x+sx2,y-sy2 : Draw_ *rp,x-sx2,y+sy2
    Move_ *rp,x,y+1 : Draw_ *rp,x+sx2,y+1

    Move_ *rp,x+sx2-2,y+sy2     : Draw_ *rp,x+sx2+1,y+sy2 ; A
    Move_ *rp,x-sx2-1,y+sy2     : Draw_ *rp,x-sx2+1,y+sy2 ; A

  Case #TUIIMAGE_SHIFT
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    !_ntui_keyborder

    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    sy2=size/3-4
    If sy2<#TUI_MINPIXELSIZE/2-1 Then sy2=#TUI_MINPIXELSIZE/2-1
    sx2=sy2/2
    sh.l = sx2+1
    Move_ *rp,x-sx2,y+sy2 : Draw_ *rp,x-sx2,y-sy2+sh
    Move_ *rp,x+sx2,y+sy2 : Draw_ *rp,x+sx2,y-sy2+sh

    Move_ *rp,x,y-sy2 : Draw_ *rp,x-sh,y-sy2+sh
    Move_ *rp,x,y-sy2 : Draw_ *rp,x+sh,y-sy2+sh
    Move_ *rp,x-sx2,y+sy2 : Draw_ *rp,x+sx2,y+sy2

  Case #TUIIMAGE_CTRL
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    !_ntui_keyborder

    ys.l = 6
    xs.l = 3
    x = (x1+x2-size)/2+2
    y = (y1+y2)/2 -ys/2

    xblow.l = (size-4-4-4-3-4)/4
    If xblow<0 Then xblow=0
    size.l = xblow*4 + 4+4+4+3
    x = (x1+x2)/2 - size/2

    xs.l = 3 + xblow
    Move_ *rp,x,y+1      : Draw_ *rp,x,y+ys-2                ; C
    Move_ *rp,x+1,y      : Draw_ *rp,x+xs-1,y
    Move_ *rp,x+1,y+ys-1 : Draw_ *rp,x+xs-1,y+ys-1
    x+xs+1
    xs=3 + xblow
    Move_ *rp,x,y : Draw_ *rp,x+xs-1,y; T
    Move_ *rp,x+xs/2,y : Draw_ *rp,x+xs/2,y+ys-1
    x + xs+1
    xs = 3 + xblow
    Move_ *rp,x,y : Draw_ *rp,x,y+ys-1 ; R
    Move_ *rp,x,y : Draw_ *rp,x+xs-1,y
    Move_ *rp,x,y+ys/2 : Draw_ *rp,x+xs-1,y+ys/2
    Move_ *rp,x+xs-1,y : Draw_ *rp,x+xs-1,y+ys/2
    Move_ *rp,x,y+ys/2 : Draw_ *rp,x+xs-1,y+ys-1
    x+xs+1
    xs=2 + xblow
    Move_ *rp,x,y : Draw_ *rp,x,y+ys-1 ; L
    Move_ *rp,x,y+ys-1 : Draw_ *rp,x+xs-1,y+ys-1


  Case #TUIIMAGE_ALT
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    !_ntui_keyborder

    ys.l = 6
    xs.l = 3
    x = (x1+x2-size)/2+2
    y = (y1+y2)/2 -ys/2

    xblow.l = (size-4-2-4-4)/3
    If xblow<0 Then xblow=0

    size.l = xblow*3 + 4+2+4
    x = (x1+x2)/2 - size/2
    xs.l = 3 + xblow
    Move_ *rp,x,y+1      : Draw_ *rp,x,y+ys-1                ; A
    Move_ *rp,x+xs-1,y+1 : Draw_ *rp,x+xs-1,y+ys-1
    Move_ *rp,x+1,y      : Draw_ *rp,x+xs-1-1,y
    Move_ *rp,x,y+ys/2 : Draw_ *rp,x+xs-1,y+ys/2
    x+xs+1
    xs=1 + xblow
    Move_ *rp,x,y      : Draw_ *rp,x,y+ys-1 ; L
    Move_ *rp,x,y+ys-1 : Draw_ *rp,x+xs,y+ys-1
    x + xs+1
    xs = 3 + xblow
    Move_ *rp,x,y      : Draw_ *rp,x+xs-1,y ; T
    Move_ *rp,x+xs/2,y : Draw_ *rp,x+xs/2,y+ys-1


  Case #TUIIMAGE_CYCLE
    If size>14 Then size*5/6-1
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    sizex = size-size/4
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    a.tuiPixel\x = x-size/2         ,y-size/2
    b.tuiPixel\x = x+size/2 -size/8 ,y+size/2
    c.tuiPixel\x = x-size/3         ,y-size/3
    d.tuiPixel\x = x+size/3 -size/8 ,y+size/3

    Move_ *rp,c\x,a\y:Draw_ *rp,d\x,a\y:Draw_ *rp,b\x,c\y:Draw_ *rp,b\x,d\y:Move_ *rp,d\x,b\y:Draw_ *rp,c\x,b\y:Draw_ *rp,a\x,d\y:Draw_ *rp,a\x,c\y:Draw_ *rp,c\x,a\y
    Move_ *rp,c\x+1,a\y+1:Draw_ *rp,d\x-1,a\y+1:Draw_ *rp,b\x-1,c\y+1:Draw_ *rp,b\x-1,d\y-1:Move_ *rp,d\x-1,b\y-1:Draw_ *rp,c\x+1,b\y-1:Draw_ *rp,a\x+1,d\y-1:Draw_ *rp,a\x+1,c\y+1:Draw_ *rp,c\x+1,a\y+1
    Move_ *rp,c\x+1,a\y:Draw_ *rp,d\x-1,a\y:Draw_ *rp,b\x-1,c\y:Draw_ *rp,b\x-1,d\y:Move_ *rp,d\x-1,b\y:Draw_ *rp,c\x+1,b\y:Draw_ *rp,a\x+1,d\y:Draw_ *rp,a\x+1,c\y:Draw_ *rp,c\x+1,a\y

    For n.l=0 To size/4
      Move_ *rp,b\x-n-1,d\y-n
      Draw_ *rp,b\x+n,d\y-n
    Next

  Case #TUIIMAGE_RADIOOFF
    If size>14 Then size*5/6
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    size/4
    size*4

    w.l = size/2
    a\x = x-w,y-w
    b\x = x-w/2,y-w/2
    c\x = x+w/2,y+w/2
    d\x = x+w,y+w
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_SHADOW]
    End If

    Move_ *rp,b\x,a\y
    Draw_ *rp,c\x,a\y
    SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    Draw_ *rp,d\x,b\y
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_SHINE]
    End If
    Draw_ *rp,d\x,c\y
    Draw_ *rp,c\x,d\y
    Draw_ *rp,b\x,d\y
    SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    Draw_ *rp,a\x,c\y
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_SHADOW]
    End If

    Draw_ *rp,a\x,b\y
    Draw_ *rp,b\x,a\y

    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_SHINE]
    End If
    w.l = (size/2) -2
    a\x = x-w,y-w
    b\x = x-w/2,y-w/2
    c\x = x+w/2,y+w/2
    d\x = x+w,y+w
    For n.l=0 To w
      Move_ *rp,x-w,y-n
      Draw_ *rp,x+w,y-n
      Move_ *rp,x-w,y+n
      Draw_ *rp,x+w,y+n
      If n>=w/2 Then w=w-1
    Next

    If (flags&(#TUIF_ACTIVE))
      SetAPen_ *rp,fgPen
      w.l = (size/4) -1
      a\x = x-w,y-w
      b\x = x-w/2,y-w/2
      c\x = x+w/2,y+w/2
      d\x = x+w,y+w

      For n.l=0 To w
        Move_ *rp,x-w,y-n
        Draw_ *rp,x+w,y-n
        Move_ *rp,x-w,y+n
        Draw_ *rp,x+w,y+n
        If n>=w/2 Then w=w-1
      Next
    EndIf

  Case #TUIIMAGE_CHECKON
    If size>14 Then size*5/6
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_SHINE]
    End If

    RectFill_ *rp,x-size/2+2,y-size/2+2,x+size/2-2,y+size/2-2

    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_WHITE]
    End If

    Move_ *rp,x+size/2,y-size/2
    Draw_ *rp,x+size/2,y+size/2
    Draw_ *rp,x-size/2,y+size/2
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_SHADOW]
    End If

    Draw_ *rp,x-size/2,y-size/2
    Draw_ *rp,x+size/2,y-size/2

    SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    WritePixel_ *rp,x-size/2,y+size/2
    WritePixel_ *rp,x+size/2,y-size/2

    SetAPen_ *rp,fgPen
    a.tuiPixel\x = x+size/2-3,y-size/2+3
    b.tuiPixel\x = x-size/2+3,y+size/2-3
    c.tuiPixel\x = x-size/2+3,y-1

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x+1,a\y
    Draw_  *rp,b\x+1,b\y
    Draw_  *rp,c\x+1,c\y

  Case #TUIIMAGE_CHECKOFF
    If size>14 Then size*5/6
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_SHINE]
    End If

    RectFill_ *rp,x-size/2+2,y-size/2+2,x+size/2-2,y+size/2-2

    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_WHITE]
    End If

    Move_ *rp,x+size/2,y-size/2
    Draw_ *rp,x+size/2,y+size/2
    Draw_ *rp,x-size/2,y+size/2
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_SHADOW]
    End If

    Draw_ *rp,x-size/2,y-size/2
    Draw_ *rp,x+size/2,y-size/2

    SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    WritePixel_ *rp,x-size/2,y+size/2
    WritePixel_ *rp,x+size/2,y-size/2

    If (flags&(#TUIF_ACTIVE))
      SetAPen_ *rp,fgPen
      a.tuiPixel\x = x+size/2-3,y-size/2+3
      b.tuiPixel\x = x-size/2+3,y+size/2-3
      c.tuiPixel\x = x-size/2+3,y-1

      Move_  *rp,a\x,a\y
      Draw_  *rp,b\x,b\y
      Draw_  *rp,c\x,c\y

      Move_  *rp,a\x+1,a\y
      Draw_  *rp,b\x+1,b\y
      Draw_  *rp,c\x+1,c\y
    End If

  Case #TUIIMAGE_RADIOON
    If size>14 Then size*5/6
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    size/4
    size*4

    w.l = size/2
    a\x = x-w,y-w
    b\x = x-w/2,y-w/2
    c\x = x+w/2,y+w/2
    d\x = x+w,y+w
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_SHADOW]
    End If
    Move_ *rp,b\x,a\y
    Draw_ *rp,c\x,a\y
    SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    Draw_ *rp,d\x,b\y
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_SHINE]
    End If
    Draw_ *rp,d\x,c\y
    Draw_ *rp,c\x,d\y
    Draw_ *rp,b\x,d\y
    SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    Draw_ *rp,a\x,c\y
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_SHADOW]
    End If
    Draw_ *rp,a\x,b\y
    Draw_ *rp,b\x,a\y

    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHINE]
    Else
      SetAPen_ *rp,*engine\pen[#TUIPEN_SHINE]
    End If
    w.l = (size/2) -2
    a\x = x-w,y-w
    b\x = x-w/2,y-w/2
    c\x = x+w/2,y+w/2
    d\x = x+w,y+w

    For n.l=0 To w
      Move_ *rp,x-w,y-n
      Draw_ *rp,x+w,y-n
      Move_ *rp,x-w,y+n
      Draw_ *rp,x+w,y+n
      If n>=w/2 Then w=w-1
    Next

    SetAPen_ *rp,fgPen
    w.l = (size/4) -1
    a\x = x-w,y-w
    b\x = x-w/2,y-w/2
    c\x = x+w/2,y+w/2
    d\x = x+w,y+w

    For n.l=0 To w
      Move_ *rp,x-w,y-n
      Draw_ *rp,x+w,y-n
      Move_ *rp,x-w,y+n
      Draw_ *rp,x+w,y+n
      If n>=w/2 Then w=w-1
    Next

  Case #TUIIMAGE_OLARROWUP
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2)/2
    y.l = (y1+y2-size+1)/2
    Move_ *rp,x-size/2,y+size-1 : Draw_ *rp,x+size/2,y+size-1
    Move_ *rp,x ,y : Draw_ *rp,x+size/2,y+size-1
    Move_ *rp,x ,y : Draw_ *rp,x-size/2,y+size-1

  Case #TUIIMAGE_OLARROWDOWN
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2)/2
    y.l = (y1+y2-size+1)/2
    x1 = x-size/2
    x2 = x+size/2
    y1 = y
    y2 = y+size-1
    Move_ *rp,x1,y1 : Draw_ *rp,x2,y1
    Move_ *rp,x ,y2 : Draw_ *rp,x1,y1
    Move_ *rp,x ,y2 : Draw_ *rp,x2,y1

  Case #TUIIMAGE_OLARROWRIGHT
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2-size+1)/2
    y.l = (y1+y2)/2
    x1 = x : x2 = x+size-1
    y1 = y - size/2 : y2=y+size/2
    Move_ *rp,x1,y1 : Draw_ *rp,x1,y2
    Move_ *rp,x1,y1 : Draw_ *rp,x2,y
    Move_ *rp,x1,y2 : Draw_ *rp,x2,y

  Case #TUIIMAGE_OLARROWLEFT
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2-size+1)/2
    y.l = (y1+y2)/2
    x1 = x : x2 = x+size-1
    y1 = y - size/2 : y2=y+size/2
    Move_ *rp,x2,y1 : Draw_ *rp,x2,y2
    Move_ *rp,x2,y1 : Draw_ *rp,x1,y
    Move_ *rp,x2,y2 : Draw_ *rp,x1,y

  Case #TUIIMAGE_LEFT
    size/2+1 : If size<6 Then size=6
    x.l = (x1+x2-size+1)/2
    y.l = (y1+y2)/2
    s2.l = size/2
    x1 = x : x2 = x1+s2-1 : x3.l=x1+s2+1 : x4.l=x3+s2-1

    y1 = y-s2+1 : y2=y+s2-1
    Move_ *rp,x2,y1 : Draw_ *rp,x1,y
    Move_ *rp,x2,y2 : Draw_ *rp,x1,y
    Move_ *rp,x4,y1 : Draw_ *rp,x3,y
    Move_ *rp,x4,y2 : Draw_ *rp,x3,y

    Move_ *rp,x2-1,y1 : Draw_ *rp,x1-1,y
    Move_ *rp,x2-1,y2 : Draw_ *rp,x1-1,y
    Move_ *rp,x4-1,y1 : Draw_ *rp,x3-1,y
    Move_ *rp,x4-1,y2 : Draw_ *rp,x3-1,y

    Move_ *rp,x2,y1+1 : Draw_ *rp,x1+1,y
    Move_ *rp,x2,y2-1 : Draw_ *rp,x1+1,y
    Move_ *rp,x4,y1+1 : Draw_ *rp,x3+1,y
    Move_ *rp,x4,y2-1 : Draw_ *rp,x3+1,y

  Case #TUIIMAGE_RIGHT
    size/2+1 : If size<6 Then size=6
    x.l = (x1+x2+size)/2
    y.l = (y1+y2)/2
    s2.l = size/2
    x1 = x : x2 = x1-s2+1 : x3 = x1-s2-1 : x4.l=x3-s2+1
    y1 = y-s2+1 : y2=y+s2-1
    Move_ *rp,x2,y1 : Draw_ *rp,x1,y
    Move_ *rp,x2,y2 : Draw_ *rp,x1,y
    Move_ *rp,x4,y1 : Draw_ *rp,x3,y
    Move_ *rp,x4,y2 : Draw_ *rp,x3,y

    Move_ *rp,x2+1,y1 : Draw_ *rp,x1+1,y
    Move_ *rp,x2+1,y2 : Draw_ *rp,x1+1,y
    Move_ *rp,x4+1,y1 : Draw_ *rp,x3+1,y
    Move_ *rp,x4+1,y2 : Draw_ *rp,x3+1,y

    Move_ *rp,x2,y1+1 : Draw_ *rp,x1-1,y
    Move_ *rp,x2,y2-1 : Draw_ *rp,x1-1,y
    Move_ *rp,x4,y1+1 : Draw_ *rp,x3-1,y
    Move_ *rp,x4,y2-1 : Draw_ *rp,x3-1,y

  Case #TUIIMAGE_DROPDOWN
    size/2+1 : If size<4 Then size=4
    x.l = (x1+x2)/2
    ys2.l = size/2
    y.l = (y1+y2-ys2-2)/2
    x1.l = x-ys2
    x2.l = x+ys2
    Move_ *rp,x1,y+ys2+2   : Draw_ *rp,x2,y+ys2+2
    Move_ *rp,x1,y+ys2+3   : Draw_ *rp,x2,y+ys2+3

    Move_ *rp,x1  ,y       : Draw_ *rp,x,y +ys2
    Move_ *rp,x1+1,y-1     : Draw_ *rp,x,y +ys2-2
    Move_ *rp,x2  ,y       : Draw_ *rp,x,y +ys2
    Move_ *rp,x2-1,y-1     : Draw_ *rp,x,y +ys2-2
    Move_ *rp,x1  ,y-1     : Draw_ *rp,x,y-1+ys2
    Move_ *rp,x2  ,y-1     : Draw_ *rp,x,y-1+ys2

  Case #TUIIMAGE_POPUP
    size/2+1 : If size<4 Then size=4
    x.l = (x1+x2)/2
    ys2.l = size/2
    y.l = (y1+y2-ys2-2)/2
    x1.l = x-ys2
    x2.l = x+ys2
    Move_ *rp,x1,y+ys2+2   : Draw_ *rp,x2,y+ys2+2
    Move_ *rp,x1,y+ys2+3   : Draw_ *rp,x2,y+ys2+3

    Move_ *rp,x1  ,y+ys2   : Draw_ *rp,x,y
    Move_ *rp,x1+1,y+ys2   : Draw_ *rp,x,y+1
    Move_ *rp,x2  ,y+ys2   : Draw_ *rp,x,y
    Move_ *rp,x2-1,y+ys2   : Draw_ *rp,x,y+1
    Move_ *rp,x1  ,y+ys2-1 : Draw_ *rp,x,y-1
    Move_ *rp,x2  ,y+ys2-1 : Draw_ *rp,x,y-1

  Case #TUIIMAGE_ARROWUP
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2)/2
    y.l = (y1+y2-size+1)/2
    For n.l=0 To size-1
      Move_ *rp,x-n/2,y+n
      Draw_ *rp,x+n/2,y+n
    Next

  Case #TUIIMAGE_ARROWDOWN
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2)/2
    y.l = (y1+y2-size+1)/2
    For n.l=0 To size-1
      Move_ *rp,x-n/2,y+size-n-1
      Draw_ *rp,x+n/2,y+size-n-1
    Next

  Case #TUIIMAGE_ARROWRIGHT
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2-size+1)/2
    y.l = (y1+y2)/2
    For n.l=0 To size-1
      Move_ *rp,x+size-n-1,y-n/2
      Draw_ *rp,x+size-n-1,y+n/2
    Next

  Case #TUIIMAGE_ARROWLEFT
    size/2+1 : If size<6 Then size=6
    size/2 : size*2
    x.l = (x1+x2-size+1)/2
    y.l = (y1+y2)/2
    For n.l=0 To size-1
      Move_ *rp,x+n,y-n/2
      Draw_ *rp,x+n,y+n/2
    Next

  Case #TUIIMAGE_PATH
    If size>12 Then size=size*5/6 -2
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1

    xd.l = (x1+x2-1)/2 -x1 -size/2
    yd.l = (y1+y2-1)/2 -y1 -size/2
    If xd<0 Then xd=0
    If yd<0 Then yd=0

    a.tuiPixel\x = x1+xd,y1+yd
    b.tuiPixel\x = x2-xd,y2-yd

    th.l = size/4;*3/10
    If th<2 Then th=2
    c.tuiPixel\x = (x1+x2)/2-th/2,a\y+th
    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,b\y : Draw_ *rp,b\x,b\y : Draw_ *rp,b\x,c\y : Draw_ *rp,a\x,c\y
    Move_ *rp,a\x,a\y : Draw_ *rp,c\x,a\y : Draw_ *rp,c\x+th,c\y

  Case #TUIIMAGE_FILE
    If size>12 Then size=size*5/6 -2
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1

    xd.l = (x1+x2-1)/2 -x1 -size*9/20
    yd.l = (y1+y2-1)/2 -y1 -size/2
    If xd<0 Then xd=0
    If yd<0 Then yd=0

    a.tuiPixel\x = x1+xd,y1+yd
    b.tuiPixel\x = x2-xd,y2-yd
    c.tuiPixel\x = b\x-size/6-2,a\y+size/6+2

    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,b\y : Draw_ *rp,b\x,b\y : Draw_ *rp,b\x,c\y : Draw_ *rp,c\x,a\y : Draw_ *rp,a\x,a\y
    Move_ *rp,c\x,a\y : Draw_ *rp,c\x,c\y : Draw_ *rp,b\x,c\y

   offset.l = 2
   If size>12 Then offset=3
    For n.l=a\y+offset To b\y-offset Step 2
      If n>c\y+1
         Move_ *rp,a\x+offset,n : Draw_ *rp,b\x-offset,n
      Else
         Move_ *rp,a\x+offset,n : Draw_ *rp,c\x-2,n
      End If
    Next

  Case #TUIIMAGE_SAVE
    If size>12 Then size*5/6 -2
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    xd.l = (x1+x2-1)/2 -x1 -size/2
    yd.l = (y1+y2-1)/2 -y1 -size/2
    If xd<0 Then xd=0
    If yd<0 Then yd=0

    a.tuiPixel\x = x1+xd,y1+yd
    b.tuiPixel\x = x2-xd,y2-yd
    c.tuiPixel\x = b\x-size/5,a\y+size/5    ; rahmen
    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,b\y : Draw_ *rp,b\x,b\y : Draw_ *rp,b\x,c\y : Draw_ *rp,c\x,a\y : Draw_ *rp,a\x,a\y

    a.tuiPixel\x = x1+xd+size/4,y1+yd       ; schieber
    b.tuiPixel\x = x2-xd-size/4,y1+yd+size/3 +1
    sx.l = size/5+2
    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,b\y : Draw_ *rp,b\x,b\y : Draw_ *rp,b\x,a\y ;: Draw_ *rp,a\x,a\y
    Move_ *rp,b\x-sx,a\y : Draw_ *rp,b\x-sx,b\y-2 : Draw_ *rp,b\x-2,b\y-2 : Draw_ *rp,b\x-2,a\y ;: Draw_ *rp,a\x,a\y

    a.tuiPixel\x = x1+xd+size/6,y2-yd    ; label
   ; b.tuiPixel\x = x2-xd-size/6,y2-yd-size/2-1
    b.tuiPixel\x = x2-xd-size/6,y1+yd+size/3 +3
    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,b\y : Draw_ *rp,b\x,b\y : Draw_ *rp,b\x,a\y : Draw_ *rp,a\x,a\y
    SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
    For n.l = a\y +2 To b\y-1 Step 2
      Move_ *rp,a\x+1,n : Draw_ *rp,b\x-1,n
    Next

  Case #TUIIMAGE_SCREEN
    If size>12 Then size*5/6 -2
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2

    a.tuiPixel\x = x-size/2,y-size/2
    b.tuiPixel\x = x+size/2,y+size/2
    c.tuiPixel\x = x,y+size/3
    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,c\y : Draw_ *rp,b\x,c\y : Draw_ *rp,b\x,a\y : Draw_ *rp,a\x,a\y
 ;   Move_ *rp,a\x+2,a\y+2 : Draw_ *rp,a\x+2,c\y-2 : Draw_ *rp,b\x-2,c\y-2 : Draw_ *rp,b\x-2,a\y+2 : Draw_ *rp,a\x+2,a\y+2
    RectFill_ *rp,a\x+2,a\y+2,b\x-2,c\y-2

    Move_ *rp,a\x+2,b\y : Draw_ *rp,b\x-2,b\y
    Move_ *rp,c\x,c\y : Draw_ *rp,c\x,b\y
    Move_ *rp,c\x-1,c\y : Draw_ *rp,c\x-1,b\y
    Move_ *rp,c\x+1,c\y : Draw_ *rp,c\x+1,b\y

    WritePixel_ *rp,b\x-5,c\y-1
    WritePixel_ *rp,b\x-3,c\y-1

  Case #TUIIMAGE_FONT
    If size>12 Then size*5/6 -2
    If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    a.tuiPixel\x = x-size/2,y-size/2
    b.tuiPixel\x = x+size/2,y+size/2
    c.tuiPixel\x = x+size/4,y

    Move_ *rp,a\x,a\y : Draw_ *rp,a\x,b\y
    Move_ *rp,a\x,a\y : Draw_ *rp,c\x,a\y
    Move_ *rp,a\x,c\y : Draw_ *rp,c\x-size/4,c\y

    Move_ *rp,a\x+1,a\y : Draw_ *rp,a\x+1,b\y
    Move_ *rp,a\x,a\y+1 : Draw_ *rp,c\x,a\y+1
    ;Move_ *rp,a\x,c\y-1 : Draw_ *rp,c\x-size/4,c\y-1

    Move_ *rp,a\x+2,a\y : Draw_ *rp,a\x+2,b\y
 ;   Move_ *rp,a\x,a\y+2 : Draw_ *rp,c\x,a\y+2

    WritePixel_ *rp,a\x-1,b\y  ; lower serif l
    WritePixel_ *rp,a\x+3,b\y  ; lower serif  r
    WritePixel_ *rp,a\x-1,a\y  ; upper serif
    WritePixel_ *rp,c\x,a\y+2  ; top down serif
    WritePixel_ *rp,c\x-size/4,c\y-1  ; mid serif
    WritePixel_ *rp,c\x-size/4,c\y+1  ; mid serif

    a.tuiPixel\x = x+size/4,y
    b.tuiPixel\x = x+size/2,y+size/2
    c.tuiPixel\x = x+size/2,y+size/4

    Move_ *rp,a\x,a\y+1 : Draw_ *rp,a\x,b\y
    Move_ *rp,a\x+1,a\y : Draw_ *rp,c\x,a\y
    Move_ *rp,a\x-size/8,c\y : Draw_ *rp,c\x-size/8 ,c\y


  Case #TUIIMAGE_NODEEXPAND
    If size>12 Then size*4/6 : If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE
    If size>9
      If (size&1) Then size-1
    Else
      If (size&1=0) Then size-1
    End If
    x.l = (x1+x2+1)/2
    y.l = (y1+y2+1)/2
    x1.l = x-size/2
    y1.l = y-size/2
    x2.l = x1+size-1
    y2.l = y1+size-1

    Move_ *rp,x1,y1
    Draw_ *rp,x2,y1
    Draw_ *rp,x2,y2
    Draw_ *rp,x1,y2
    Draw_ *rp,x1,y1

    Move_ *rp,x1+2,y : Draw_ *rp,x2-2,y
    If size>9 Then Move_ *rp,x1+2,y-1 : Draw_ *rp,x2-2,y-1
    Move_ *rp,x,y1+2 : Draw_ *rp,x,y2-2
    If size>9 Then Move_ *rp,x-1,y1+2 : Draw_ *rp,x-1,y2-2

  Case #TUIIMAGE_NODECOLLAPSE
    If size>12 Then size*4/6 : If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE
    If size>9
      If (size&1) Then size-1
    Else
      If (size&1=0) Then size-1
    End If

    x.l = (x1+x2+1)/2
    y.l = (y1+y2+1)/2
    x1.l = x-size/2
    y1.l = y-size/2
    x2.l = x1+size-1
    y2.l = y1+size-1

    Move_ *rp,x1,y1
    Draw_ *rp,x2,y1
    Draw_ *rp,x2,y2
    Draw_ *rp,x1,y2
    Draw_ *rp,x1,y1

    Move_ *rp,x1+2,y : Draw_ *rp,x2-2,y
    If size>9 Then Move_ *rp,x1+2,y-1 : Draw_ *rp,x2-2,y-1

  Case #TUIIMAGE_INC
    size/2+1 : If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1

    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    Move_ *rp,x-size/2,y : Draw_ *rp,x+size/2,y
    Move_ *rp,x,y-size/2 : Draw_ *rp,x,y+size/2
    Move_ *rp,x-size/2,y+1 : Draw_ *rp,x+size/2,y+1
    Move_ *rp,x+1,y-size/2 : Draw_ *rp,x+1,y+size/2
    Move_ *rp,x-size/2,y-1 : Draw_ *rp,x+size/2,y-1
    Move_ *rp,x-1,y-size/2 : Draw_ *rp,x-1,y+size/2

  Case #TUIIMAGE_DEC
    size/2+1 : If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    x.l = (x1+x2)/2
    y.l = (y1+y2)/2
    Move_ *rp,x-size/2,y : Draw_ *rp,x+size/2,y
    Move_ *rp,x-size/2,y+1 : Draw_ *rp,x+size/2,y+1
    Move_ *rp,x-size/2,y-1 : Draw_ *rp,x+size/2,y-1

  Case #TUIIMAGE_CHECKMARK
    size/2+1 : If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    size=(size+1)/2

    size*2

    x1.l = (x1+x2-size+1)/2   : x2 = x1+size-1
    y1.l = (y1+y2-size+1)/2   : y2 = y1+size-1
    If False
    a.tuiPixel\x = x1,y1+size/2
    b.tuiPixel\x = x1+size/2,y2
    c.tuiPixel\x = x2,y1
    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y-1
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y-2
    Draw_  *rp,c\x,c\y
    Else
    a.tuiPixel\x = x2,y1
    b.tuiPixel\x = x1,y2
    c.tuiPixel\x = x1,y2-size/2-1

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x+1,a\y
    Draw_  *rp,b\x+1,b\y
    Draw_  *rp,c\x+1,c\y

;    Move_  *rp,a\x,a\y
;    Draw_  *rp,b\x,b\y-2
;    Draw_  *rp,c\x,c\y

    End If

  Case #TUIIMAGE_CHECKMARK2
    If (flags&#TUIF_DISABLED)
      SetAPen_ *rp,*engine\pen[#TUIPEN_BACKGROUND]
    Else
      If (flags&#TUIF_ACTIVE)
        SetAPen_ *rp,*engine\pen[#TUIPEN_WHITE]
      Else
        SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHADOW]
      End If
    End If

    size/2+1 : If size<#TUI_MINPIXELSIZE Then size=#TUI_MINPIXELSIZE-1
    size=(size+1)/2

    size*2

    x1.l = (x1+x2-size)/2   : x2 = x1+size-1
    y1.l = (y1+y2-size)/2   : y2 = y1+size-1

    If False
    a.tuiPixel\x = x1,y1+size/2
    b.tuiPixel\x = x1+size/2,y2
    c.tuiPixel\x = x2,y1
    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y-1
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y-2
    Draw_  *rp,c\x,c\y
    Else
    a.tuiPixel\x = x2,y1
    b.tuiPixel\x = x1,y2
    c.tuiPixel\x = x1,y2-size/2-1

    Move_  *rp,a\x,a\y
    Draw_  *rp,b\x,b\y
    Draw_  *rp,c\x,c\y

    Move_  *rp,a\x+1,a\y
    Draw_  *rp,b\x+1,b\y
    Draw_  *rp,c\x+1,c\y

    End If

  Case #TUIIMAGE_BITMAP
    *tpa.tuiPixelArray = _ntui_AccessTBImage{*tbi}
    If (*tpa)

      If (flags&#TUIF_DISABLED)
        If (*tpa\disabled)
          *pa.tuiARGB = *tpa\disabled
          imode.l = #TUIIM_NORMAL
        Else
          *pa.tuiARGB = *tpa\normal
          imode.l = #TUIIM_DISABLED
        End If
      Else
        If (flags&#TUIF_ACTIVE)
          If (*tpa\active)
            *pa.tuiARGB = *tpa\active
            imode.l = #TUIIM_NORMAL
          Else
            *pa.tuiARGB = *tpa\normal
            imode.l = #TUIIM_ACTIVE
          End If
        Else     ; TODO: check also focus and mover!
          If (flags&#TUIF_FOCUS)
            If (*tpa\focus)
              *pa.tuiARGB = *tpa\focus
              imode.l = #TUIIM_NORMAL
            Else
              *pa.tuiARGB = *tpa\normal
              imode.l = #TUIIM_FOCUS
            End If
          Else
            If (flags&#TUIF_MOVER)
              If (*tpa\mover)
                *pa.tuiARGB = *tpa\mover
                imode.l = #TUIIM_NORMAL
              Else
                *pa.tuiARGB = *tpa\normal
                imode.l = #TUIIM_MOVER
              End If

            Else
              *pa.tuiARGB = *tpa\normal
              imode.l = #TUIIM_NORMAL
            End If
          End If
        End If
      End If

      Select *tbi\tuiBitMap\bmode
        Case #TUIIBM_MASK
          If flags&#TUIF_BOTTOM
            by1.l = y2-*tpa\height+1
          Else
            If flags&#TUIF_TOP
              by1.l = y1
            Else
              by1.l = (y1+y2+1)/2-(*tpa\height)/2
            End If
          End If
          bx1.l = (x1+x2+1)/2-(*tpa\width)/2
          ;If bx1<x1 Then bx1=x1
          ;If by1<y1 Then by1=y1
          If *engine\cModel=#TUICM_TRUECOLOR
            _ntui_WritePixelArrayAlpha{*pa,0,0,*rp,bx1,by1,*tpa\width,*tpa\height,imode,bgARGB}
          Else
            _ntui_WritePixelArrayAlpha4{*pa,0,0,*rp,bx1,by1,*tpa\width,*tpa\height,imode,bgPen}
          End If

          If bgPen>=0
            SetAPen_ *rp,bgPen
            If bx1>*bbox\left Then RectFill_ *rp,*bbox\left,*bbox\top,bx1-1,*bbox\bottom ; left
            If by1>*bbox\top  Then RectFill_ *rp,*bbox\left,*bbox\top,*bbox\right,by1-1 ; top
            If bx1+*tpa\width -1<*bbox\right Then RectFill_ *rp,bx1+*tpa\width,*bbox\top,*bbox\right,*bbox\bottom ; right
            If by1+*tpa\height-1<*bbox\bottom Then RectFill_ *rp,*bbox\left,by1+*tpa\height,*bbox\right,*bbox\bottom ; bottom
          End If

        Case #TUIIBM_9PATCH
           ;    ax.s = Str$(*tpa\border\left)+"/"+Str$(*tpa\border\top)+"/"+Str$(*tpa\border\right)+"/"+Str$(*tpa\border\bottom)
           ;    bx.s = Str$(*tpa\hscale)+"/"+Str$(*tpa\vscale)+"/"+Str$(*tpa\width)+"/"+Str$(*tpa\height)
           ;    error{"draw: scale="+bx.s+"content: "+ax.s}
           srect.tuiRect\left = 0,0
           srect\right  = *tpa\width-1-2
           srect\bottom = *tpa\height-1-2
           drect.tuiRect\left = x1,y1,x2,y2
           _ntui_WritePixelArray9Patch{*pa,*tpa,srect,*rp,drect,imode,bgARGB}

        Default ; #TUIIBM_OPAQUE
          If flags&#TUIF_BOTTOM
            by1.l = y2-*tpa\height+1
          Else
            If flags&#TUIF_TOP
              by1.l = y1
            Else
              by1.l = (y1+y2-*tpa\height)/2
            End If
          End If
          bx1.l = (x1+x2-*tpa\width)/2
          ;If bx1<x1 Then bx1=x1
          ;If by1<y1 Then by1=y1

          If *engine\cModel=#TUICM_TRUECOLOR
            _ntui_WritePixelArray      {*pa,0,0,*rp,bx1,by1,*tpa\width,*tpa\height,imode}
          Else
            _ntui_WritePixelArrayAlpha4{*pa,0,0,*rp,bx1,by1,*tpa\width,*tpa\height,imode,bgPen}
          End If

          If bgPen>=0
            SetAPen_ *rp,bgPen
            If bx1>*bbox\left Then RectFill_ *rp,*bbox\left,*bbox\top,bx1-1,*bbox\bottom ; left
            If by1>*bbox\top  Then RectFill_ *rp,*bbox\left,*bbox\top,*bbox\right,by1-1 ; top
            If bx1+*tpa\width -1<*bbox\right Then RectFill_ *rp,bx1+*tpa\width,*bbox\top,*bbox\right,*bbox\bottom ; right
            If by1+*tpa\height-1<*bbox\bottom Then RectFill_ *rp,*bbox\left,by1+*tpa\height,*bbox\right,*bbox\bottom ; bottom
          End If

      End Select

    End If

  Default
    Move_    *rp,x1  ,y1
    Draw_    *rp,x2  ,y1
    Draw_    *rp,x2  ,y2
    Draw_    *rp,x1  ,y2
    Draw_    *rp,x1  ,y1
    Draw_    *rp,x2  ,y2
    Move_    *rp,x1,  y2
    Draw_    *rp,x2,  y1
End Select

  If *tbi\emblem
    !tuiCopyRect{ebox.tuiRect,*cbox}
    *tpa = _ntui_AccessTBImage{*tbi\emblem}
    If (*tpa)
    ebox\bottom = *cbox\bottom + *tpa\height/2 : If ebox\bottom>*bbox\bottom Then ebox\bottom = *bbox\bottom
    ebox\right  = *cbox\right  + *tpa\width /2 : If ebox\right >*bbox\right  Then ebox\right  = *bbox\right
    ebox\top    = ebox\bottom-*tpa\height+1
    ebox\left   = ebox\right -*tpa\width+1
    ntui_DrawTBImage{*tbi\emblem,*rp,ebox,ebox,flags,#TUIPEN_TRANSPARENT}
    End If
  End If

End Statement


Statement _ntui_GetImageBorderSize{*tbi.tuiTBImage,*border.tuiRect}

  *tpa.tuiPixelArray = _ntui_AccessTBImage{*tbi}
  If *tpa
    !tuiCopyRect{*border,*tpa\border}
  Else
    *border\left = 0,0,0,0
  End If

End Statement
