; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "RAM:"
; ExeFile         = "Prog.exe"
; CreateIcon      = 0
; Residents       = "all.res,SDSTCP2.res,xpk.res,ttengine.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 8192
; MakeSmallest    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 19
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 32768
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 1
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 1983
; CursorColumn    = 37
; LabelSearch     = "dele"
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 20
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 20
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: ntui_textbox.include                                                  /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 06/01/2009                                                            /
;/                                                                             /
;/ Author: <unknown>                                                           /
;/                                                                             /
;/ Requirements:  Amiblitz3                                                    /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Extend AB3 functionality.                                                   /
;/ * no description available *                                                /
;/                                                                             /
;/ Abstract:                                                                   /
;/ * no abstract available *                                                   /
;/                                                                             /
;/ User Constants:                                                             /
;/ #max_objects   = n                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
#TUI_HAS_TEXTBOX = 1

;/* ntui TextBox Sub-Types */
#TUITB_TEXTBOX            = 0 ; multiline textbox
#TUITB_STRING             = 1 ; single line string gadget
#TUITB_STRING_NUMERIC     = 2 ; single line numeric gadget
#TUITB_STRING_PASSWORD    = 3 ; sinle line string gadget with password style
#TUITB_STRING_FILE        = 4 ; string gadget with file ASL
#TUITB_STRING_PATH        = 5 ; string gadget with path ASL
#TUITB_STRING_FONT        = 6 ; string gadget with font ASL
#TUITB_STRING_SCREEN      = 7 ; string gadget with screen ASL
#TUITB_CONSOLE            = 8

;/* ntui TextBox Flags */
#TUITBF_LEFTWRAP              = $00000001
#TUITBF_RIGHTWRAP             = $00000002
#TUITBF_LOOSESELECTION        = $00000004 ; selection gets lost of mouse move or key press
#TUITBF_DELWRAP               = $00000008 ; join lines on left delete
#TUITBF_REMWRAP               = $00000010 ; join lines on right remove
#TUITBF_DRAGCURSOR            = $00000020 ; cursor is dragged and set to end of selection
#TUITBF_HIDECURSORONSELECT    = $00000040 ; cursor is hidden whenselection is done
#TUITBF_SHIFTSELECT           = $00000080 ; allow to select with shift key pressed
#TUITBF_RETURNBREAK           = $00000200 ; return breaks the line
#TUITBF_BACKUP                = $00000400
#TUITBF_AUTOINDENT            = $00000800 ; set spaces according the top line
#TUITBF_REDRAWONSCROLL        = $00002000 ; scroll through complete re-draw
#TUITBF_LINECURSOR            = $00004000 ; line cursor, block cursor otherwise
#TUITBF_READONLY              = $00008000 ; read only text box, curosr is there, but no edit
#TUITBF_REALTAB               = $00040000 ; tab is treated as tab, not N spaces
#TUITBF_WANTRETURN            = $00080000 ; return creates a new line
#TUITBF_SELECTONFOCUS         = $00100000 ; when textbox gains focus, the entire text is selected
#TUITBF_LOOSESELECTIONONFOCUS = $00200000 ; when textbox gains focus, selection is lost
#TUITBF_WANTTAB               = $00400000 ; tab is inserted in text, otherwise may jump to next gui item
#TUITBF_BLOCKSELECT           = $00800000
#TUITBF_SHOWCR                = $01000000 ; show carriage return code

#TUITBF_NotePad    = #TUITBF_LEFTWRAP|#TUITBF_RIGHTWRAP|#TUITBF_LOOSESELECTION|#TUITBF_DELWRAP|#TUITBF_REMWRAP|#TUITBF_DRAGCURSOR|#TUITBF_HIDECURSORONSELECT|#TUITBF_SHIFTSELECT|#TUITBF_RETURNBREAK|#TUITBF_REALTAB|#TUITBF_WANTRETURN
#TUITBF_String     = #TUITBF_LEFTWRAP|#TUITBF_RIGHTWRAP|#TUITBF_LOOSESELECTION|#TUITBF_DRAGCURSOR|#TUITBF_SHIFTSELECT|#TUITBF_REALTAB|#TUITBF_LOOSESELECTIONONFOCUS|#TUITBF_SELECTONFOCUS
#TUITBF_Ped        = #TUITBF_WANTRETURN|#TUITBF_RETURNBREAK
#TUITBF_Message    = #TUITBF_READONLY|#TUITBF_HIDECURSORONSELECT|#TUITBF_LOOSESELECTION|#TUITBF_LINECURSOR|#TUITBF_LEFTWRAP|#TUITBF_RIGHTWRAP|#TUITBF_SHIFTSELECT
#TUITBF_Console    = #TUITBF_LEFTWRAP|#TUITBF_RIGHTWRAP|#TUITBF_LOOSESELECTION|#TUITBF_SHIFTSELECT|#TUITBF_REALTAB|#TUITBF_WANTRETURN

;/* ntui TextBox Pens */
#TUITBPEN_BG              =  0 ; pen for background
#TUITBPEN_Text            =  1 ; pen for normal text
#TUITBPEN_Token           =  2 ; pen for Tokens
#TUITBPEN_Number          =  3 ; pen for numeric values
#TUITBPEN_Newtype         =  4 ; pen for structs
#TUITBPEN_Constant        =  5 ; pen for constants/macros
#TUITBPEN_Comment         =  6 ; pen for comments
#TUITBPEN_Macro           =  7 ; pen for macros
#TUITBPEN_String          =  8 ; pen for string constants
#TUITBPEN_Function        =  9 ; pen for functions
#TUITBPEN_Directive       = 10 ; pen for directives
#TUITBPEN_Tag             = 11 ; pen for tag
#TUITBPEN_Attr            = 12 ; pen for tag attribute
#TUITBPEN_Focus           = 13 ; pen for background with focus
#TUITBPEN_NoFocus         = 14 ; pen for background without focus
#TUITBPEN_DisabledBG      = 15 ; pen for disabled background
#TUITBPEN_DisabledFG      = 16 ; pen for disabled text
#TUITBPEN_EnabledFG       = 17 ; pen for enabled text
#TUITBPEN_MAX             = 18

;/* ntui TextBox Line Flags */
#TUITBLF_NONE             = $0   ; no flags
#TUITBLF_COMMENT          = $1   ; propagate multi-line comment
#TUITBLF_INIT             = $2
#TUITBLF_DETOKENIZED      = $4
#TUITBLF_STOLEN           = $8   ; line is not allocated by us
#TUITBLF_ALLOC            = $10  ; was allocated by us
#TUITBLF_RETURN_LF        = $20  ; return code line feed ($0A)
#TUITBLF_RETURN_CR        = $40  ; return code return carrier ($0D)

;/* ntui TextBox Attributes */
#TUITBA_BASE               =  #TUIA_USER
#TUITBA_CURSOR_LINE        =  0 | #TUITBA_BASE ; rw
#TUITBA_CURSOR_COLUMN      =  1 | #TUITBA_BASE ; rw
#TUITBA_BEGINSELECT_LINE   =  2 | #TUITBA_BASE ; rw
#TUITBA_BEGINSELECT_COLUMN =  3 | #TUITBA_BASE ; rw
#TUITBA_ENDSELECT_LINE     =  4 | #TUITBA_BASE ; rw
#TUITBA_ENDSELECT_COLUMN   =  5 | #TUITBA_BASE ; rw
#TUITBA_TBFLAGS            =  6 | #TUITBA_BASE ; rw
#TUITBA_SETTBFLAGS         =  7 | #TUITBA_BASE ;  w
#TUITBA_CLEARTBFLAGS       =  8 | #TUITBA_BASE ;  w
#TUITBA_BLINKSPEED         =  9 | #TUITBA_BASE ; rw
#TUITBA_ROWHEIGHT          = 10 | #TUITBA_BASE ; r
#TUITBA_SPACEWIDTH         = 11 | #TUITBA_BASE ; r
#TUITBA_TABWIDTH           = 12 | #TUITBA_BASE ; rw
#TUITBA_VISIBLELINES       = 13 | #TUITBA_BASE ; r
#TUITBA_TOTALLINES         = 14 | #TUITBA_BASE ; r
#TUITBA_TOPLINE            = 15 | #TUITBA_BASE ; rw
#TUITBA_VISIBLEWIDTH       = 16 | #TUITBA_BASE ; r
#TUITBA_TOTALWIDTH         = 17 | #TUITBA_BASE ; r
#TUITBA_LEFTOFFSET         = 18 | #TUITBA_BASE ; rw
#TUITBA_MAXCOLUMNS         = 19 | #TUITBA_BASE ; rw
#TUITBA_MAXLINES           = 20 | #TUITBA_BASE ; rw
#TUITBA_FONT               = 21 | #TUITBA_BASE ; rw
#TUITBA_LINE               = 22 | #TUITBA_BASE ; rw
#TUITBA_LINELENGTH         = 23 | #TUITBA_BASE ; r
#TUITBA_SELECTION          = 24 | #TUITBA_BASE ; rw
#TUITBA_HIGHLIGHTNING      = 25 | #TUITBA_BASE ; rw

NEWTYPE.tline ; line contains ASCII text and special tokenized version
flags.l      ; like #tflag_comment

blength.l    ; allocated length
clength.l    ; character length (including return code)
text.l       ; pointer to 0 terminated text string

;tclength.l  ; allocated length
;tblength.l  ; character length
;ttext.l     ; tokenized version of text
End NEWTYPE


NEWTYPE.tuiTextBox
obj.tuiObject        ; tui object header
subTypeID.l
maxChars.l
maxLines.l
*hScroller.tuiScroller
*vScroller.tuiScroller
*funcButton.tuiButton
*doc.tline           ; Zeiger auf Pointer array
*tank.b              ; pointer to text tank from load function
allocLines.l         ; Maximum Numer of Textlines
visibleLines.l
topLine.l
totalWidth.l
visibleWidth.l
leftOffset.l
totalLines.l         ;  Number of used lines in Ted
step_.tuiPixel
numMin.l             ; boundaries for numeric string
numMax.l

cursor_lpos.l
cursor_cpos.l
cursor_pixpos.l
selection_begin_lpos.l
selection_begin_cpos.l
selection_end_lpos.l
selection_end_cpos.l
damage_begin_lpos.l
damage_end_lpos.l
bracket1_lpos.l
bracket1_cpos.l
bracket1_char.b
bracket2_char.b
bracket2_lpos.l
bracket2_cpos.l

last_flags.l
*font.TextFont
fontstolen.l
rowheight.l
spacing.l
space_width.l
tab_width.l
editable.l
accept.l

cursor_show.l
cursor_count.l

anker_lpos.l
anker_cpos.l

search_lpos.l
search_cpos.l

scrollborder_x.l
scrollborder_y.l

edflags.l

tokenizing.l
blink_speed.l
tabsize.l ; tab size in spaces
returncode.l
max_cpos.l

validChar.b[256]

; pens
pen.l         [#TUITBPEN_MAX]
penSelect.l   [#TUITBPEN_MAX]
tuiPen.l      [#TUITBPEN_MAX]
tuiPenSelect.l[#TUITBPEN_MAX]
End NEWTYPE

USEPATH *textBox

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !line_use {lpos}                                                    /
;/                                                                             /
;/ Description:
;/ Helper macro to get the pointer to a text line or NULL, if out of range.                                                              /
;/                                                                             /
;/ Inputs:
;/ - *tline  : name of the varialbe that holds the pointer                                                                 /
;/ - lpos    : line position                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro line_use ;{*tline,lpos}
If (`2) < *textBox\allocLines AND (`2)>=0
  `1.tline = *textBox\doc + ((`2) * SizeOf.tline)
Else
  `1       = Null
End If
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_CopyMem {sourceaddr.l,destaddr.l,blength.l}                     /
;/                                                                             /
;/ Description:                                                                /
;/ Copymem() reimplementation that supports overlapping memory areas                                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - sourceaddr.l  : source memory address                                                     /
;/ - destaddr.l    : destination memory address                                                       /
;/ - blength.l     : byte length of memory area                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST _tb_CopyMem{sourceaddr.l,destaddr.l,blength.l}
UNLK a4
TST.l d2
BLE copy_exit
MOVE.l d0,a0
MOVE.l d1,a1
MOVE.l d2,d3
CMP.l d0,d1
BLT copy_normal
BEQ copy_exit
ADD.l d2,a0
ADD.l d2,a1
copy_reverse: ; --------------------------------- REVERSE
LSR.l #5,d3
BEQ copy_reverse_norow
copy_reverse_row:
MOVE.l -(a0),-(a1) ;1
MOVE.l -(a0),-(a1) ;2
MOVE.l -(a0),-(a1) ;3
MOVE.l -(a0),-(a1) ;4
MOVE.l -(a0),-(a1) ;5
MOVE.l -(a0),-(a1) ;6
MOVE.l -(a0),-(a1) ;7
MOVE.l -(a0),-(a1) ;8
SUB.l #1,d3
BGT copy_reverse_row
copy_reverse_norow:
AND.l #31,d2
BEQ copy_exit
copy_reverse_byte:
MOVE.b -(a0),-(a1)
SUB.l #1,d2
BGT copy_reverse_byte
copy_exit:
RTS
copy_normal: ; ------------------------------------ NORMAL
LSR.l #5,d3
BEQ copy_normal_norow
copy_normal_row:
MOVE.l (a0)+,(a1)+  ;1
MOVE.l (a0)+,(a1)+  ;2
MOVE.l (a0)+,(a1)+  ;3
MOVE.l (a0)+,(a1)+  ;4
MOVE.l (a0)+,(a1)+  ;5
MOVE.l (a0)+,(a1)+  ;6
MOVE.l (a0)+,(a1)+  ;7
MOVE.l (a0)+,(a1)+  ;8
SUB.l #1,d3
BGT copy_normal_row
copy_normal_norow:
AND.l #31,d2
BEQ copy_exit
copy_normal_byte:
MOVE.b (a0)+,(a1)+
SUB.l #1,d2
BGT copy_normal_byte
RTS
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l =  _tb_Instr {textptr.l,c.b,mlen.l,@pos.l}                 /
;/                                                                             /
;/ Description:                                                                /
;/ Find position of first occurence of c in text string, mlen to search and from pos.
;/                                                                             /
;/ Inputs:                                                                     /
;/ - textptr.l  : ???                                                        /
;/ - c.b        : ???                                                              /
;/ - mlen.l     : ???                                                           /
;/ - pos.l      : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l   : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST _tb_Instr{textptr.l,c.b,mlen.l,@pos.l}

  If pos<0 Then pos = 0
  While Peek.b(textptr+pos)><c AND pos<mlen:pos+1:Wend
  If pos=mlen Then pos=-1
  Function Return pos

End Function


Function.l FAST _tb_NVC{textptr.l,mlen.l,@pos.l}

  If pos<0 Then pos = 0
  While (Peek.b(textptr+pos)&$FF)>=32 AND pos<mlen:pos+1:Wend
  If pos=mlen Then pos=-1
  Function Return pos

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _tb_GetTextLength {*rp.RastPort,textptr.l,mlen.l}        /
;/                                                                             /
;/ Description:                                                                /
;/ Replacement for TextLength() OS function, but respects TAB sizes            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *rp.RastPort    : destination RastPort                                                    /
;/ - textptr.l       : text pointer                                                        /
;/ - mlen.l          : max length to test                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l        : length in pixel of the textstring                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST _tb_GetTextLength{*rp.RastPort,textptr.l,mlen.l}

  pos.l = _tb_Instr{textptr,$09,mlen}
  If pos<0
    slen.l = TextLength_(*rp,textptr,mlen)
  Else
    lpos.l=0
    While pos>=0
      If pos-lpos>0 Then slen.l + TextLength_(*rp,textptr+lpos,pos-lpos)
      lpos.l = pos+1
      pos.l = _tb_Instr{textptr,$09,mlen,lpos}
      slen + 50
    Wend
    If mlen-lpos>0 Then slen.l + TextLength_(*rp,textptr+lpos,mlen-lpos)
  End If
  Function Return slen

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _tb_pos2x {*textBox.tuiTextBox,lpos.l,cpos.l}         /
;/                                                                             /
;/ Description:                                                                /
;/ convert cursor position to x coordinate.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - cpos.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _tb_pos2x{*textBox.tuiTextBox,lpos.l,cpos.l,*rp.RastPort}

  x.l = 0
  cw.l = \space_width
  ;*tuiWindow.tuiWindow = *textBox\obj\tuiWindow
  ;If *tuiWindow Then *win.Window = *tuiWindow\win
  ;If *win Then *rp.RastPort = *win\RPort
  If *rp=-1 Then *rp=Null
  If *rp
    SetFont_ *rp,\font
    !line_use{*tline,lpos}
    If *tline
      If *tline\text
        If cpos>=*tline\clength
          ;If *tline\ttext AND *tline\tclength>0
            ;x.l = _tb_GetTokenLength{*rp,*tline\ttext,*tline\tclength} + \space_width * (cpos-*tline\clength)
          ;Else
            x.l = _tb_GetTextLength{*rp,*tline\text,*tline\clength} + \space_width * (cpos-*tline\clength)
          ;End If
        Else
          ;If *tline\ttext AND *tline\tclength>0
            ;x.l = _tb_GetTokenLength2{*rp,*tline\ttext,cpos}
          ;Else
            x.l = _tb_GetTextLength{*rp,*tline\text,cpos}
          ;End If
        End If
      Else
        x = \space_width * cpos
      End If
    Else
      x = \space_width * cpos
    End If
  End If
  Function Return x

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _tb_pos2cw {*textBox.tuiTextBox,lpos.l,cpos.l}        /
;/                                                                             /
;/ Description:                                                                /
;/ Get the cursor width of the given position                                                                            /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - cpos.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _tb_pos2cw{*textBox.tuiTextBox,lpos.l,cpos.l,*rp.RastPort}

  cw.l = \space_width
  ;*tuiWindow.tuiWindow = *textBox\obj\tuiWindow
  ;If *tuiWindow Then *win.Window = *tuiWindow\win
  ;If *win Then *rp.RastPort = *win\RPort
  If *rp=-1 Then *rp=Null
  If *rp
    SetFont_ *rp,\font
    !line_use{*tline,lpos}
    If *tline
      If *tline\text
        If cpos>=*tline\clength
          cw.l = \space_width
        Else
          ;If *tline\ttext
            ;string.s = _tb_DeTokenize{*tline\ttext,*tline\tclength}
            ;cw.l = _tb_GetTextLength{*rp,&string.s+cpos,1}
            ;cw.l = _tb_tokenlength{*rp,*tline\ttext+cpos,1}
          ;Else
            cw.l = _tb_GetTextLength{*rp,*tline\text+cpos,1}
          ;End If
        End If
      End If
    End If
  End If
  Function Return cw-1

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _tb_x2pos {*textBox.tuiTextBox,lpos.l,x.l}            /
;/                                                                             /
;/ Description:
;/ Convert the x position at line pos to character position.                                                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - x.l    : ???                                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _tb_x2pos{*textBox.tuiTextBox,lpos.l,x.l,*rp.RastPort}

  If *rp=-1 OR *rp=Null Then Function Return 0
  SetFont_ *rp,\font
  cpos.l = 0
  !line_use{*tline,lpos}
  If *tline
    If *tline\text
      ;If *tline\ttext AND *tline\tclength>0
        ;string.s = _tb_DeTokenize{*tline\ttext,*tline\tclength}
      ;Else
        string.s = Peeks$(*tline\text,*tline\clength-1)
      ;End If

      slen.l = FLen(string.s)

      While x>0
        If cpos<slen
          x-_tb_GetTextLength{*rp,&string.s + cpos,1}
        Else
          x-\space_width
        End If
        If x>=0 Then cpos+1
      Wend
      clength.l = slen ; *tline\clength
    Else
      cpos = x / \space_width  : clength = 0
    End If
  Else
    cpos = x / \space_width  : clength = 0
  End If
  If (\edflags&#TUITBF_RIGHTWRAP)><0 AND cpos>=clength Then cpos=clength-1
  Function Return cpos

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_Text {*rp.RastPort,textptr.l,mlen.l}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Sample like Text(), but respect the TAB sizes.
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *rp.RastPort    : ???                                                     /
;/ - textptr.l    : ???                                                        /
;/ - mlen.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_Text_{*rp.RastPort,textptr.l,mlen.l}

  pos.l = _tb_Instr{textptr,$09,mlen}
  If pos<0
    slen.l = Text_(*rp,textptr,mlen)
  Else
    lpos.l=0
    apen.l = *rp\FgPen
    bpen.l = *rp\BgPen
    While pos>=0
      If pos-lpos>0
        Text_ *rp,textptr+lpos,pos-lpos
      End If
      lpos.l = pos+1
      pos.l = _tb_Instr{textptr,$09,mlen,lpos}
      SetAPen_ *rp,bpen
      RectFill_ *rp,*rp\cp_x,*rp\cp_y-*rp\TxBaseline,*rp\cp_x+50,*rp\cp_y-*rp\TxBaseline+*rp\TxHeight
      SetAPen_ *rp,apen
      Move_ *rp,*rp\cp_x+50,*rp\cp_y
    Wend
    If mlen-lpos>0 Then Text_ *rp,textptr+lpos,mlen-lpos
  End If

End Statement


Statement _tb_Text{*rp.RastPort,textptr.l,mlen.l}
  lpos.l=0
  apen.l = *rp\FgPen
  bpen.l = *rp\BgPen

  Repeat
    pos.l = _tb_NVC{textptr,mlen,lpos}
    If pos<0 ; no nvc till end
      SetAPen_ *rp,3
      Text_ *rp,textptr+lpos,mlen-lpos
      lpos=mlen
    Else
      If pos-lpos>0 Then Text_ *rp,textptr+lpos,pos-lpos
      lpos = pos+1
      SetAPen_ *rp,apen
      RectFill_ *rp,*rp\cp_x,*rp\cp_y-*rp\TxBaseline,*rp\cp_x+7,*rp\cp_y-*rp\TxBaseline+*rp\TxHeight-1
      SetAPen_ *rp,bpen
      RectFill_ *rp,*rp\cp_x+1,*rp\cp_y-*rp\TxBaseline+1,*rp\cp_x+7-1,*rp\cp_y-*rp\TxBaseline+*rp\TxHeight -2
      Move_ *rp,*rp\cp_x+8,*rp\cp_y
      SetAPen_ *rp,apen
    End If
  Until lpos>=mlen

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l =  _tb_y2line {*textBox.tuiTextBox,y.l}                 /
;/                                                                             /
;/ Description:                                                                /
;/ Convert y coordinate to line.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox : TextBox Object                                           /
;/ - y.l                    : y-coordinate relative to left/top edge of TextBox                                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l               : line                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST _tb_y2line{*textBox.tuiTextBox,y.l}

  If \rowheight>0
    lpos.l = ((y) / \rowheight + \topLine)
  Else
    lpos = 0
  End If
  If lpos>=\totalLines Then lpos=\totalLines-1
  If lpos<0 Then lpos=0
  Function Return lpos

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l =  _tb_line2y {*textBox.tuiTextBox,lpos.l}              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST _tb_line2y{*textBox.tuiTextBox,lpos.l}

  Function Return (lpos-\topLine) * \rowheight

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_DoBlink {*textBox.tuiTextBox,*rp.RastPort,mode.l}            /
;/                                                                             /
;/ Description:                                                                /
;/ View or hide the text cursor.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox  : TextBox Object                                           /
;/ - *rp.RastPort            : ???                                                     /
;/ - mode.l                  : 1 = auto blink, -1=show, 0=hide                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_DoBlink{*textBox.tuiTextBox,*rp.RastPort,mode.l}

  If *textBox\obj\flags&#TUIF_ONSCREEN=0 Then Statement Return
  If *rp=Null Then Statement Return

  If (\edflags&#TUITBF_HIDECURSORONSELECT=0)  OR (\selection_begin_lpos=-1) OR (\selection_end_cpos=\selection_begin_cpos AND \selection_begin_lpos=\selection_end_lpos)
    If \accept=False Then mode=Off
    If mode=1 AND \blink_speed>0
      \cursor_count+1
      If \cursor_count>=\blink_speed
        If \cursor_show Then mode=Off : Else mode=On
        \cursor_count=0
      End If
    Else
      \cursor_count=0
    End If

    If mode=\cursor_show OR mode=1 Then Statement Return

    xs.l = _tb_pos2x {*textBox,\cursor_lpos,\cursor_cpos,*rp}
    If \edflags&#TUITBF_LINECURSOR
      cw.l = 0
    Else
      cw.l = _tb_pos2cw{*textBox,\cursor_lpos,\cursor_cpos,*rp}
    End If

    x.l = *textBox\obj\cbox\left  - \leftOffset  + xs
    y.l = *textBox\obj\cbox\top   + (\cursor_lpos-\topLine) *\rowheight ;- \view_ypos

    \cursor_show = mode
    SetDrMd_ *rp,-1
    RectFill_ *rp,x,y,x+cw,y+\rowheight-1
    SetDrMd_ *rp,0

  EndIf

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_DrawRawLine {*textBox.tuiTextBox,*rp.RastPort,lpos.l,x.l,y:: /
;/ .l,x2.l}                                                                    /
;/                                                                             /
;/ Description:
;/ Draw a text line at the given coordinates.                                                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/ - lpos.l    : ???                                                           /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/ - x2.l    : ???                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_DrawRawLine{*textBox.tuiTextBox,*rp.RastPort,lpos.l,x.l,y.l,x2.l}
done.l = 0
!line_use{*tline, lpos}
If *tline
  If *tline\text
    If \selection_begin_lpos=lpos OR \selection_end_lpos=lpos
      If \selection_begin_lpos=lpos Then cpos1.l = \selection_begin_cpos: Else cpos1=0
      If \selection_end_lpos=lpos Then cpos2.l = \selection_end_cpos: Else cpos2=*tline\clength

      If cpos1>0
        SetBPen_ *rp,\pen[#TUITBPEN_BG]
        SetAPen_ *rp,\pen[#TUITBPEN_Text]
        Move_ *rp,x,y+*rp\TxBaseline
        _tb_Text{ *rp,*tline\text,cpos1}
      End If

      xadd.l = _tb_pos2x{*textBox,lpos,cpos1,*rp}
      SetBPen_ *rp,\penSelect[#TUITBPEN_BG]
      SetAPen_ *rp,\penSelect[#TUITBPEN_Text]
      Move_ *rp,x+xadd,y+*rp\TxBaseline
      _tb_Text{ *rp,*tline\text+cpos1,cpos2-cpos1}

      If cpos2<*tline\clength
        xadd.l = _tb_pos2x{*textBox,lpos,cpos2,*rp}
        SetBPen_ *rp,\pen[#TUITBPEN_BG]
        SetAPen_ *rp,\pen[#TUITBPEN_Text]
        Move_ *rp,x+xadd,y+*rp\TxBaseline
        _tb_Text{ *rp,*tline\text+cpos2,*tline\clength-cpos2}
      End If

      If \selection_end_lpos><lpos
        xadd.l = x + _tb_GetTextLength{*rp,*tline\text,*tline\clength}
        If *textBox\edflags&#TUITBF_SHOWCR
          If xadd<=x2
            Move_ *rp,xadd,y+*rp\TxBaseline
            If *textBox\edflags&#TUITBF_BLOCKSELECT
              SetAPen_ *rp,\penSelect[#TUITBPEN_Text]
              SetBPen_ *rp,\penSelect[#TUITBPEN_BG]
            Else
              SetAPen_ *rp,*textBox\obj\tuiEngine\pen[#TUIPEN_HALFSHADOW]
              SetBPen_ *rp,\pen[#TUITBPEN_BG]
            End If
            a.s = "¶"
            Text_ *rp,&a.s,1
            xadd.l + TextLength_(*rp,&a.s,1)
          End If
        End If
          If xadd<=x2
            If *textBox\edflags&#TUITBF_BLOCKSELECT
              SetAPen_ *rp,\penSelect[#TUITBPEN_BG]
            Else
              SetAPen_ *rp,\pen[#TUITBPEN_BG]
            End If
            RectFill_ *rp,xadd,y,x2,y+\rowheight-1
          End If
      Else
        xadd.l = x + _tb_GetTextLength{*rp,*tline\text,*tline\clength}
        If xadd<=x2
          SetAPen_ *rp,\pen[#TUITBPEN_BG]
          RectFill_ *rp,xadd,y,x2,y+\rowheight-1
        End If
      End If
    Else
      xadd.l = x + _tb_GetTextLength{*rp,*tline\text,*tline\clength}
      If \selection_begin_lpos<lpos AND \selection_end_lpos>lpos
        If *textBox\edflags&#TUITBF_SHOWCR
          If xadd<=x2
            Move_ *rp,xadd,y+*rp\TxBaseline
            If *textBox\edflags&#TUITBF_BLOCKSELECT
              SetAPen_ *rp,\penSelect[#TUITBPEN_Text]
              SetBPen_ *rp,\penSelect[#TUITBPEN_BG]
            Else
              SetAPen_ *rp,*textBox\obj\tuiEngine\pen[#TUIPEN_HALFSHADOW]
              SetBPen_ *rp,\pen[#TUITBPEN_BG]
            End If
            a.s = "¶"
            Text_ *rp,&a.s,1
            xadd.l + TextLength_(*rp,&a.s,1)
          End If
        End If

        If xadd<=x2
          If *textBox\edflags&#TUITBF_BLOCKSELECT
            SetAPen_ *rp,\penSelect[#TUITBPEN_BG]
          Else
            SetAPen_ *rp,\pen[#TUITBPEN_BG]
          End If
          RectFill_ *rp,xadd,y,x2,y+\rowheight-1
        End If

        SetAPen_ *rp,\penSelect[#TUITBPEN_Text]
        SetBPen_ *rp,\penSelect[#TUITBPEN_BG]
      Else
        If xadd<=x2
          SetAPen_ *rp,\pen[#TUITBPEN_BG]
          RectFill_ *rp,xadd,y,x2,y+\rowheight-1
        End If
        SetAPen_ *rp,\pen[#TUITBPEN_Text]
        SetBPen_ *rp,\pen[#TUITBPEN_BG]
      End If
      Move_ *rp,x,y+*rp\TxBaseline
      _tb_Text{ *rp,*tline\text,*tline\clength}
    End If
    done.l=-1
  End If
End If
If done=False
  If (\selection_begin_lpos<=lpos AND \selection_end_lpos>lpos)
    If *textBox\edflags&#TUITBF_SHOWCR
      Move_ *rp,x,y+*rp\TxBaseline
      If *textBox\edflags&#TUITBF_BLOCKSELECT
        SetAPen_ *rp,\penSelect[#TUITBPEN_Text]
        SetBPen_ *rp,\penSelect[#TUITBPEN_BG]
      Else
        SetAPen_ *rp,*textBox\obj\tuiEngine\pen[#TUIPEN_HALFSHADOW]
        SetBPen_ *rp,\pen[#TUITBPEN_BG]
      End If

      a.s = "¶"
      Text_ *rp,&a.s,1
      x + TextLength_(*rp,&a.s,1)
    Else
      If (*textBox\edflags&#TUITBF_BLOCKSELECT)=0
        SetAPen_ *rp,\penSelect[#TUITBPEN_BG]
        Move_ *rp,x,y
        Draw_ *rp,x,y+\rowheight-1 : x+1
      End If
    End If
    If *textBox\edflags&#TUITBF_BLOCKSELECT
      SetAPen_ *rp,\penSelect[#TUITBPEN_BG]
    Else
      SetAPen_ *rp,\pen[#TUITBPEN_BG]
    End If
  Else
    SetAPen_ *rp,\pen[#TUITBPEN_BG]
  End If
  If x<=x2 Then RectFill_ *rp,x,y,x2,y+\rowheight-1
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_ShowBrackets {*textBox.tuiTextBox}                           /
;/                                                                             /
;/ Description:                                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_ShowBrackets{*textBox.tuiTextBox,*rp.RastPort}

  If *rp
    If \bracket1_lpos>=0 AND \bracket2_lpos>=0
    ;  _tb_DrawLine{*textBox,\bracket1_lpos}
    ;  _tb_DrawLine{*textBox,\bracket2_lpos}
      bx1.l = _tb_pos2x{*textBox,\bracket1_lpos,\bracket1_cpos,*rp}   - \leftOffset
      bx2.l = _tb_pos2x{*textBox,\bracket2_lpos,\bracket2_cpos,*rp}   - \leftOffset
      by1.l = _tb_line2y{*textBox,\bracket1_lpos}                +*rp\TxBaseline
      by2.l = _tb_line2y{*textBox,\bracket2_lpos}                +*rp\TxBaseline
      SetAPen_ *rp,\pen[#TUITBPEN_Text]
      SetDrMd_ *rp,0
      Move_ *rp,bx1,by1
      Text_ *rp,&\bracket1_char,1

      Move_ *rp,bx1+1,by1
      Text_ *rp,&\bracket1_char,1

      Move_ *rp,bx2,by2
      Text_ *rp,&\bracket2_char,1

      Move_ *rp,bx2+1,by2
      Text_ *rp,&\bracket2_char,1

    End If
  End If

End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_CheckTextBoxString {*textBox.tuiTextBox}                    /
;/                                                                             /
;/ Description:                                                                /
;/ Copy the text from a textbox into the string/value parameter of String/NumString Objects.
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : textbox object                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ntui_UpdateTextBoxString{*textBox.tuiTextBox}

  Select *textBox\subTypeID
    Case #TUITB_STRING_NUMERIC
      !line_use{*tline, 0}
      value.l=*textBox\obj\value
      If *tline
        If *tline\text
          string.s    = Peeks$(*tline\text,*tline\clength)
          string.s    = Replace$(string,"+","")
          value.l     = Vallong(string)
          If value<*textBox\numMin Then value = *textBox\numMin
          If value>*textBox\numMax Then value = *textBox\numMax
          newstring.s = Str$(value)
          If newstring><string
            If *tline\blength<=FLen(newstring)
              nl.l = FLen(newstring)+1+8
              FreeMem_ *tline\text,*tline\blength
              *tline\text = AllocMem_ (nl,#MEMF_ANY)
              *tline\blength = nl
            End If
            *tline\clength = FLen(newstring)
            Poke.s *tline\text,newstring
          End If
        End If
      End If
      *textBox\obj\value=value

    ;Case #TUITB_STRING
      ;!line_use{*tline, 0}
      ;If *tline
      ;  If *tline\text
      ;    str_WritePtr{&*textBox\obj\string,*tline\text,*tline\clength}
      ;  End If
      ;End If

  End Select

End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ntui_DrawTextBox {*textBox.tuiTextBox,x1.l,y1.l,x2.l,y2.l,*rp:: /
;/ .RastPort}                                                                  /
;/                                                                             /
;/ Description:                                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - x1.l    : ???                                                             /
;/ - y1.l    : ???                                                             /
;/ - x2.l    : ???                                                             /
;/ - y2.l    : ???                                                             /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ntui_DrawTextBoxIntern{*textBox.tuiTextBox,x1.l,y1.l,x2.l,y2.l,*rp.RastPort}
If *textBox=Null Then Statement Return
If *rp=Null OR *rp=-1 OR \rowheight<=0 Then Statement Return

*tuiEngine.tuiEngine = *textBox\obj\tuiEngine

If (*textBox\obj\flags&#TUIF_DISABLED)
  *textBox\pen[#TUITBPEN_Text]=*textBox\pen[#TUITBPEN_DisabledFG]
  *textBox\pen[#TUITBPEN_BG]  =*textBox\pen[#TUITBPEN_DisabledBG]
Else
  *textBox\pen[#TUITBPEN_Text]=*textBox\pen[#TUITBPEN_EnabledFG]
  If *textBox\obj\flags&#TUIF_FOCUS
    If *textBox\tuiPen[#TUITBPEN_Focus]>=0   Then *textBox\pen[#TUITBPEN_BG]=*textBox\pen[#TUITBPEN_Focus]
  Else
    If *textBox\tuiPen[#TUITBPEN_NoFocus]>=0 Then *textBox\pen[#TUITBPEN_BG]=*textBox\pen[#TUITBPEN_NoFocus]
    If *textBox\edflags&#TUITBF_LOOSESELECTIONONFOCUS
;    _tb_SetSelect{*textBox}
      *textBox\selection_begin_lpos  = -1
      *textBox\selection_end_lpos  = -1
      _ntui_UpdateTextBoxString{*textBox.tuiTextBox}
    End If
  End If
End If
 
_tb_DoBlink{*textBox,*rp,Off}
SetFont_ *rp,\font
If *textBox\obj\flags&#TUIF_BOLD   Then SetSoftStyle_ *rp,#FSF_BOLD,#FSF_BOLD
If *textBox\obj\flags&#TUIF_ITALIC Then SetSoftStyle_ *rp,#FSF_ITALIC,#FSF_ITALIC

SetDrMd_ *rp,1

SetAPen_ *rp,*textBox\pen[#TUITBPEN_BG]
mx.l = *textBox\obj\cbox\right
my.l = *textBox\obj\cbox\bottom

If x1<*textBox\obj\cbox\left Then x1=*textBox\obj\cbox\left
If y1<*textBox\obj\cbox\top  Then y1=*textBox\obj\cbox\top
If x2>mx OR x2<0 Then x2 = mx
If y2>my OR y2<0 Then y2 = my

tbx.l = *textBox\obj\cbox\left ;innerPos\x
tby.l = *textBox\obj\cbox\top  ;innerPos\y

;If y1<tby Then y1=tby
;If y2>=tby+*textBox\obj\size\y OR y2<0 Then y2=tby + *textBox\obj\size\y-1

;If x1<tbx Then x1=tby
;If x2>=tbx+*textBox\obj\size\x OR x2<0 Then x2=tbx + *textBox\obj\size\x-1

lpos_a.l = (y1-tby)/\rowheight
If lpos_a<0 Then lpos_a=0

y.l      = lpos_a * \rowheight + tby
If y>y1
  SetAPen_ *rp,\pen[#TUITBPEN_BG]
  RectFill_ *rp,x1,y1,x2,y-1
End If

If tbx>x1
  SetAPen_ *rp,\pen[#TUITBPEN_BG]
  RectFill_ *rp,x1,y1,tbx-1,y2
End If

lpos_a   + \topLine
If lpos_a<0 Then lpos_a=0

lpos_b.l = lpos_a + ((!tuiRectHeight{*textBox\obj\cbox}-1) / \rowheight)
If lpos_b>\totalLines-1 Then lpos_b = \totalLines-1

x.l      = tbx - \leftOffset


SetAPen_ *rp,\pen[#TUITBPEN_Text]
SetBPen_ *rp,\pen[#TUITBPEN_BG]
ntui_SetClip{*rp,*textBox\obj\cbox}
If \tokenizing=False
  For lpos.l = lpos_a To lpos_b
    _tb_DrawRawLine{*textBox,*rp,lpos,x,y,x2}
    y + \rowheight
  Next
Else
;      For lpos.l = lpos_a To lpos_b
;        _tb_draw_tokenline{*textBox,lpos,x,y,x2}
;        y + \rowheight
;      Next

;    End If
End If
If *textBox\obj\flags&(#TUIF_ACTIVE|#TUIF_FOCUS)
  ;_tb_DoBlink{*textBox,*rp,On}
  _tb_ShowBrackets{*textBox,*rp}
End If

ntui_RemClip{*rp}
If y<=y2 AND *textBox\subTypeID=#TUITB_TEXTBOX

  SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_HALFSHINE]
  Move_* rp,x1,y : Draw_ *rp,x2,y :y+1
End If

If y<=y2
  SetAPen_ *rp,\pen[#TUITBPEN_BG]
  RectFill_ *rp,x1,y,x2,y2
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_Scroll {*textBox.tuiTextBox,dx.l,dy.l,upd.l}                 /
;/                                                                             /
;/ Description:                                                                /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - dx.l    : ???                                                             /
;/ - dy.l    : ???                                                             /
;/ - upd.l    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_Scroll{*textBox.tuiTextBox,dx.l,dy.l,*rp.RastPort}
If *rp Then *win.Window  = *rp\Layer\Window : Else *win   = Null

If dy><0
  oldtop.l = \topLine
  \topLine + dy
 ; If \topLine>(\totalLines - *textBox\innerSize\y/\rowheight) Then \topLine=(\totalLines - *textBox\innerSize\y/\rowheight)
  If \topLine>(\totalLines - *textBox\visibleLines) Then \topLine=(\totalLines - *textBox\visibleLines)
  If \topLine<0 Then \topLine=0

  dypix.l = (\topLine-oldtop) * \rowheight
  If dypix><0 AND *rp><Null
    If (Abs(dypix)<!tuiRectWidth{*textBox\obj\cbox}) AND (*textBox\edflags&#TUITBF_REDRAWONSCROLL=0)
      If *win
        ScrollWindowRaster_ *win,0,dypix,*textBox\obj\cbox\left,*textBox\obj\cbox\top,*textBox\obj\cbox\right,*textBox\obj\cbox\bottom
      Else
        If *rp Then ScrollRasterBF_ *rp,0,dypix,*textBox\obj\cbox\left,*textBox\obj\cbox\top,*textBox\obj\cbox\right,*textBox\obj\cbox\bottom
      End If
      If dypix<0
        _ntui_DrawTextBoxIntern{*textBox,-1,-1,-1,*textBox\obj\cbox\top-dypix,*rp}
      Else
        _ntui_DrawTextBoxIntern{*textBox,-1,*textBox\obj\cbox\bottom+1-dypix,-1,-1,*rp}
      End If
    Else
      _ntui_DrawTextBoxIntern{*textBox,-1,-1,-1,-1,*rp}
    End If
  End If
End If

If dx><0
  oldx.l = \leftOffset
  \leftOffset + dx
  If \leftOffset<0 Then \leftOffset=0
  dxpix.l = (\leftOffset-oldx)
  If dxpix><0 AND *rp><Null
    If (Abs(dxpix)<!tuiRectWidth{*textBox\obj\cbox}) AND (*textBox\edflags&#TUITBF_REDRAWONSCROLL=0)
      If *win
        ScrollWindowRaster_ *win,dxpix,0,*textBox\obj\cbox\left,*textBox\obj\cbox\top,*textBox\obj\cbox\right,*textBox\obj\cbox\bottom
      Else
        If *rp Then ScrollRasterBF_ *rp,dxpix,0,*textBox\obj\cbox\left,*textBox\obj\cbox\top,*textBox\obj\cbox\right,*textBox\obj\cbox\bottom
      End If

      If dxpix<0
        _ntui_DrawTextBoxIntern{*textBox,-1,-1,*textBox\obj\cbox\left-dxpix,-1,*rp}
      Else
        _ntui_DrawTextBoxIntern{*textBox,*textBox\obj\cbox\right-dxpix+1,-1,-1,-1,*rp}
      End If
    Else
      _ntui_DrawTextBoxIntern{*textBox,-1,-1,-1,-1,*rp}
    End If
  End If
End If
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_ScrollTo {*textBox.tuiTextBox,lpos.l,cpos.l}                 /
;/                                                                             /
;/ Description:                                                                /
;/   ;_tb_update_scroller{*textBox,upd}                                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - cpos.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_ScrollTo{*textBox.tuiTextBox,lpos.l,cpos.l,*rp.RastPort}
If *textBox
  If lpos<\topLine+\scrollborder_y Then _tb_Scroll{*textBox,0,lpos-\topLine-\scrollborder_y,*rp}
;  If lpos>\topLine+*textBox\innerSize\y/\rowheight-1-\scrollborder_y Then _tb_Scroll{*textBox,0,lpos-\topLine-*textBox\innerSize\y/\rowheight+1+\scrollborder_y,*rp}
  If lpos>\topLine+*textBox\visibleLines-1-\scrollborder_y Then _tb_Scroll{*textBox,0,lpos-\topLine-\visibleLines+1+\scrollborder_y,*rp}

  pixpos.l = _tb_pos2x{*textBox,lpos,cpos,*rp} - \leftOffset
  If pixpos<\scrollborder_x Then _tb_Scroll{*textBox,pixpos-\scrollborder_x,0,*rp}
;  If pixpos>*textBox\innerSize\x-\rowheight-\scrollborder_x Then _tb_Scroll{*textBox,pixpos-*textBox\innerSize\x+\rowheight+\scrollborder_x,0,*rp}
  If pixpos>!tuiRectWidth{*textBox\obj\cbox}-\scrollborder_x Then _tb_Scroll{*textBox,pixpos-!tuiRectWidth{*textBox\obj\cbox}+\scrollborder_x,0,*rp}

End If
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_ScrollToSelect {*textBox.tuiTextBox}                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_ScrollToSelection{*textBox.tuiTextBox,*rp.RastPort}
If *textBox
  If \selection_begin_lpos>=0 Then _tb_ScrollTo{*textBox,\selection_begin_lpos,\selection_begin_cpos,*rp}
  If \selection_end_lpos>=0 Then _tb_ScrollTo{*textBox,\selection_end_lpos,\selection_end_cpos,*rp}
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_ScrollToCursor {*textBox.tuiTextBox}                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_ScrollToCursor{*textBox.tuiTextBox,*rp.RastPort}
If *textBox
  _tb_ScrollTo{*textBox,*textBox\cursor_lpos,*textBox\cursor_cpos,*rp}
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_DrawLine {*textBox.tuiTextBox,lpos.l,*rp.RastPort}           /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement  ____tb_DrawLine{*textBox.tuiTextBox,lpos.l,*rp.RastPort}
y1.l = _tb_line2y{*textBox,lpos}
If y1>-\rowheight AND y1<!tuiRectHeight{*textBox\obj\cbox}
  y1 + *textBox\obj\cbox\top
  _ntui_DrawTextBoxIntern{*textBox,-1,y1,-1,y1+\rowheight-1,*rp}
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_RedrawDamaged {*textBox.tuiTextBox}                          /
;/                                                                             /
;/ Description:                                                                /
;/     ;minlpos.l = Min(\selection_end_lpos,lpos2)                                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_Repair{*textBox.tuiTextBox,*rp.RastPort}

  If *textBox
    If *textBox\damage_begin_lpos<=*textBox\damage_end_lpos
      If *rp
        y1.l = _tb_line2y{*textBox,*textBox\damage_begin_lpos} + *textBox\obj\cbox\top ;innerPos\y
        y2.l = _tb_line2y{*textBox,*textBox\damage_end_lpos}   + *textBox\obj\cbox\top + \rowheight-1
        _ntui_DrawTextBoxIntern{*textBox,-1,y1,-1,y2,*rp}
      End If
      *textBox\damage_begin_lpos = 0
      *textBox\damage_end_lpos   = -1
    End If
  End If

End Statement


Statement _tb_Damage{*textBox.tuiTextBox,lpos_begin.l,lpos_end.l}

  If *textBox
    If *textBox\damage_begin_lpos<=*textBox\damage_end_lpos ; expand damage range
      If lpos_begin<*textBox\damage_begin_lpos Then *textBox\damage_begin_lpos = lpos_begin
      If lpos_end  >*textBox\damage_end_lpos   Then *textBox\damage_end_lpos   = lpos_end
    Else
      *textBox\damage_begin_lpos = lpos_begin ; first damaged line
      *textBox\damage_end_lpos   = lpos_end
    End If
  End If

End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_SetSelection {*textBox.tuiTextBox,@lpos1.l,@cpos1.l,@lpos2.l,:: /
;/ @cpos2.l,@*rp.RastPort}                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos1.l    : ???                                                          /
;/ - cpos1.l    : ???                                                          /
;/ - lpos2.l    : ???                                                          /
;/ - cpos2.l    : ???                                                          /
;/ - upd.l    : ???                                                            /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_SetSelection{*textBox.tuiTextBox,@lpos1.l,@cpos1.l,@lpos2.l,@cpos2.l}
  If lpos2<lpos1 Then Exchange lpos1,lpos2 : Exchange cpos1,cpos2
  If lpos2=lpos1 AND cpos1>cpos2 Then Exchange cpos1,cpos2
  If cpos1<0 Then cpos1=0
  If cpos2<0 Then cpos2=0

  !line_use{*tline, lpos1}
  If *tline
    If cpos1>*tline\clength Then cpos1=*tline\clength
  End If
  !line_use{*tline, lpos2}
  If *tline
    If cpos2>*tline\clength Then cpos2=*tline\clength
  End If

  If lpos1=-1 ; remove selection
    minlpos.l = \selection_begin_lpos
    maxlpos.l = \selection_end_lpos
  Else
    If \selection_begin_lpos=-1 ; add selection
      minlpos = lpos1
      maxlpos = lpos2
    Else

      succ.l = False
      If lpos1><\selection_begin_lpos
        minlpos.l = Min(\selection_begin_lpos,lpos1)
        maxlpos.l = Max(\selection_begin_lpos,lpos1)
        If lpos2><\selection_end_lpos
          ;minlpos.l = Min(\selection_end_lpos,lpos2)
          maxlpos.l = Max(\selection_end_lpos,lpos2)
        End If
      Else
        If lpos2><\selection_end_lpos
          minlpos.l = Min(\selection_end_lpos,lpos2)
          maxlpos.l = Max(\selection_end_lpos,lpos2)
        Else
          If \selection_begin_cpos><cpos1
            minlpos = lpos1
            maxlpos = lpos1
          End If
          If \selection_end_cpos><cpos2
            minlpos = lpos2
            maxlpos = lpos2
          End If
        End If
      End If
    End If
  End If

  If \selection_begin_cpos><cpos1 Then \selection_begin_cpos = cpos1  :succ.l = True
  If \selection_end_cpos  ><cpos2 Then \selection_end_cpos   = cpos2  :succ.l = True
  If \selection_begin_lpos><lpos1 Then \selection_begin_lpos = lpos1  :succ.l = True
  If \selection_end_lpos  ><lpos2 Then \selection_end_lpos   = lpos2  :succ.l = True

  If succ=True
    _tb_Damage{*textBox,minlpos,maxlpos}
  End If

End Statement




;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_SetCursor {*textBox.tuiTextBox,lpos.l,cpos.l,@pixupd.l,@lo:: /
;/ ose.l,@*rp.RastPort}                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ Set the cursor to lpos/cpos position and make it visible.                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : the textbox object in question                                      /
;/ - lpos.l    : new line position                                                /
;/ - cpos.l    : new character position in line                                                          /
;/ - pixupd.l  : use this pixel x position as anker for verctial cursor movements                      /
;/ - loose.l   : loose the selection                                                        /
;/ - *rp.RastPort : rastport to draw changes to, can be Null                                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_SetCursor{*textBox.tuiTextBox,lpos.l,cpos.l,@pixupd.l,@loose.l,@*rp.RastPort}

  If *rp=-1 Then *rp=Null
  ;tb_line_settokencase{*textBox.tuiTextBox}
  If lpos>=\totalLines Then lpos=\totalLines-1
  If lpos<0 Then lpos=0
  If cpos<0 Then cpos=0
  If \edflags&#TUITBF_RIGHTWRAP
    !line_use{*tline, lpos}
    If *tline
      If cpos>*tline\clength Then cpos = *tline\clength
    Else
      cpos=0
    End If
  End If
  \cursor_cpos     = cpos
  \cursor_lpos     = lpos
  If pixupd Then \cursor_pixpos = _tb_pos2x{*textBox,lpos,cpos,*rp}
  If ((\edflags&#TUITBF_LOOSESELECTION)><0) AND loose><False Then _tb_SetSelection{*textBox,-1,-1,-1,-1}
  _tb_ScrollTo{*textBox,\cursor_lpos,\cursor_cpos,*rp}
  If *rp Then _tb_ShowBrackets{*textBox,*rp}

End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_MouseDrag {*textBox.tuiTextBox,*rp.RastPort,mx.l,my.l}       /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/ - mx.l    : ???                                                             /
;/ - my.l    : ???                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_MouseDrag{*textBox.tuiTextBox,*rp.RastPort,mx.l,my.l}
If *textBox
  ;mx = \xwin\MouseX - *textBox\obj\pos\x
  ;my = \xwin\MouseY - *textBox\obj\pos\y
  mx +\leftOffset

  lpos1.l = \anker_lpos ;tb_y2line{*textBox,\ry}
  cpos1.l = \anker_cpos ;tb_x2pos {*textBox,lpos1,\rx}

  lpos2.l = _tb_y2line{*textBox,my}
  cpos2.l = _tb_x2pos {*textBox,lpos2,mx,*rp}

  If \edflags&#TUITBF_DRAGCURSOR Then _tb_DoBlink{*textBox,*rp,Off} :_tb_SetCursor{*textBox,lpos2,cpos2,True,False}

  If lpos1><lpos2 OR cpos1><cpos2
    _tb_SetSelection{*textBox,lpos1,cpos1,lpos2,cpos2}
  End If

  If lpos2<\topLine Then _tb_Scroll{*textBox,0,-1,*rp}
;  If lpos2>=\topLine+*textBox\obj\size\y/\rowheight Then _tb_Scroll{*textBox,0,1,*rp}
  If lpos2>=\topLine+*textBox\visibleLines Then _tb_Scroll{*textBox,0,1,*rp}
  If mx<\leftOffset Then _tb_Scroll{*textBox,-\rowheight,0,*rp}
  If mx>\leftOffset+!tuiRectWidth{*textBox\obj\cbox} Then _tb_Scroll{*textBox,\rowheight,0,*rp}
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_SetCursorXY {*textBox.tuiTextBox,x.l,y.l}                    /
;/                                                                             /
;/ Description:                                                                /
;/   ;mx = \xwin\MouseX - *textBox\obj\pos\x                                /
;/   ;my = \xwin\MouseY - *textBox\obj\pos\y                                /
;/   lpos1.l = \anker_lpos ;tb_y2line{*textBox,\ry}                         /
;/   cpos1.l = \anker_cpos ;tb_x2pos {*textBox,lpos1,\rx}                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_SetCursorXY{*textBox.tuiTextBox,x.l,y.l,*rp.RastPort}
lpos.l = _tb_y2line{*textBox,y}
cpos.l = _tb_x2pos{*textBox,lpos,x,*rp}
_tb_SetCursor{*textBox,lpos,cpos}
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_MouseClick {*textBox.tuiTextBox,*rp.RastPort,mx.l,my.l,mb.:: /
;/ l,dbl.l}                                                                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/ - mx.l    : ???                                                             /
;/ - my.l    : ???                                                             /
;/ - mb.l    : ???                                                             /
;/ - dbl.l    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_MouseClick{*textBox.tuiTextBox,*rp.RastPort,mx.l,my.l,mb.l,dbl.l}

  _tb_SetCursorXY{*textBox ,mx+\leftOffset,my,*rp}
  Select dbl
    Case 1
    !line_use{*tline, \cursor_lpos}
    If *tline
      If *tline\text
      cpos.l = _tb_x2pos {*textBox,\anker_lpos,mx+\leftOffset,*rp}
      breakme.l=False
      While cpos>=0 AND breakme=False
        c.b = Peek.b(*tline\text+cpos)
        If (c>=@"A" AND c<=@"Z") OR (c>=@"a" AND c<=@"z") OR (c>=@"0" AND c<=@"9") OR c=@"_" OR c<0
          cpos-1
        Else
          breakme.l = True
          cpos+1
        End If
      Wend
      If cpos<0 Then cpos=0
      apos.l = cpos
      cpos.l = _tb_x2pos {*textBox,\anker_lpos,mx+\leftOffset,*rp}
      breakme.l=False
      While cpos<*tline\clength AND breakme=False
        c.b = Peek.b(*tline\text+cpos)
        If (c>=@"A" AND c<=@"Z") OR (c>=@"a" AND c<=@"z") OR (c>=@"0" AND c<=@"9") OR c=@"_" OR c<0
          cpos+1
        Else
          breakme.l = True
        End If
      Wend
      If cpos>*tline\clength Then cpos=*tline\clength
      _tb_SetSelection{*textBox,\cursor_lpos,apos,\cursor_lpos,cpos}
      End If
    End If
    Case 2
      !line_use{*tline, \cursor_lpos}
      If *tline
        _tb_SetSelection{*textBox,\cursor_lpos,0,\cursor_lpos,*tline\clength}
      End If
    Default
    _tb_SetSelection{*textBox,-1,-1,-1,-1}
  End Select
  \anker_lpos = _tb_y2line{*textBox,my}
  \anker_cpos = _tb_x2pos {*textBox,\anker_lpos,mx+\leftOffset,*rp}

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_MoveCursor {*textBox.tuiTextBox,dx.l,dy.l,shift.l,*rp.Rast:: /
;/ Port}                                                                       /
;/                                                                             /
;/ Description:                                                                /
;/ If mb=1                                                                     /
;/ End If                                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - dx.l    : ???                                                             /
;/ - dy.l    : ???                                                             /
;/ - shift.l    : ???                                                          /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_MoveCursor{*textBox.tuiTextBox,dx.l,dy.l,shift.l,*rp.RastPort}
If shift AND (\edflags&#TUITBF_SHIFTSELECT><0)
  If \selection_begin_lpos<0 OR \selection_end_lpos<0
    \anker_lpos = \cursor_lpos
    \anker_cpos = \cursor_cpos
  End If
End If

If dx><0
  If shift AND (\edflags&#TUITBF_SHIFTSELECT=0)
    If dx>0
      clength.l = 1
      !line_use{*tline, \cursor_lpos}
      If *tline
        clength = *tline\clength
      End If
      \cursor_cpos = clength-1
    Else
      \cursor_cpos = 0
    End If
  Else
    \cursor_cpos+dx
  End If

  If (\edflags&#TUITBF_LEFTWRAP><0)
    While \cursor_cpos<0
      If \cursor_lpos>0
        \cursor_lpos-1
        !line_use{*tline, \cursor_lpos}
        If *tline
          \cursor_cpos + *tline\clength
        Else
          \cursor_cpos + 1
        End If
      Else
        \cursor_cpos = 0
      End If
    Wend
  End If

  If (\edflags&#TUITBF_RIGHTWRAP><0)
    !line_use{*tline, \cursor_lpos}
    If *tline
      clength.l=*tline\clength-1
    Else
      clength=0
    End If

    While \cursor_cpos>clength
      If \cursor_lpos<\totalLines-1
        \cursor_cpos-clength-1
        \cursor_lpos+1
        !line_use{*tline, \cursor_lpos}
        If *tline
          clength=*tline\clength-1
        Else
          clength=0
        End If
      Else
        If *tline Then \cursor_cpos = *tline\clength:Else \cursor_cpos=0
        clength = *tline\clength
      End If
    Wend
  End If
  \cursor_pixpos = _tb_pos2x{*textBox,\cursor_lpos,\cursor_cpos,*rp}
End If

If dy><0
  ;_tb_line_Settokencase{*textBox}
  If shift AND (\edflags&#TUITBF_SHIFTSELECT=0) Then dy.l = *textBox\visibleLines * Sgn(dy)

  \cursor_lpos + dy
  If \cursor_lpos>=\totalLines Then \cursor_lpos=\totalLines-1
  If \cursor_lpos<0 Then \cursor_lpos=0
  \cursor_cpos = _tb_x2pos{*textBox,\cursor_lpos,\cursor_pixpos,*rp}
End If

;If \cursor_lpos<\topLine Then _tb_scroll{*textBox,0,\cursor_lpos-\topLine}
;If \cursor_lpos>\topLine + *textBox\innerSize\y/\rowheight-1 Then _tb_scroll{*textBox,0,\cursor_lpos-\topLine-*textBox\innerSize\y/\rowheight+1}

;pixpos.l = _tb_pos2x{*textBox,\cursor_lpos,\cursor_cpos} - \leftOffset
;If pixpos<0 Then _tb_scroll{*textBox,pixpos,0}
;If pixpos>*textBox\innerSize\x-\rowheight Then _tb_scroll{*textBox,pixpos-*textBox\innerSize\x+\rowheight,0}
_tb_ScrollToCursor{*textBox,*rp}

If shift AND (\edflags&#TUITBF_SHIFTSELECT><0)
  _tb_SetSelection{*textBox,\anker_lpos,\anker_cpos,\cursor_lpos,\cursor_cpos}
  ;_tb_Drag{*textBox,\cursor_lpos,\cursor_cpos}
Else
  If (\edflags&#TUITBF_LOOSESELECTION><0) Then _tb_SetSelection{*textBox,-1,-1,-1,-1}
End If
If *rp Then _tb_ShowBrackets{*textBox,*rp}
End Statement


Function.w _tb_Expand{*textBox.tuiTextBox,minLines.l}

  succ.l = False
  If minLines>\allocLines
    newdoc.l = AllocVec_((minLines)*SizeOf.tline,#MEMF_CLEAR)
    If newdoc
      If \doc
        CopyMem_ \doc,newdoc,\allocLines*SizeOf.tline
        FreeVec_ \doc
      End If
      \doc = newdoc
      \allocLines = minLines
      succ.l = True
    End If
  End If
  Function Return succ

End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_AllocLine {*textBox.tuiTextBox,lpos.l,text.l,@clength.l}    /
;/                                                                             /
;/ Description:                                                                /
;/ "Insert" at line 5 moves line 5-end to position 6 and creates new line at:: /
;/  position 5                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : intert position or -1 for append at end of text                                                           /
;/ - text.l    : initial text for new line                                                           /
;/ - clength.l    : optional character length of text                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_InsertNewLine{*textBox.tuiTextBox,lpos.l,textP.l,tlength.l}

  If lpos<0 OR lpos>\totalLines Then lpos = \totalLines

  If \totalLines>=\allocLines Then If _tb_Expand{*textBox.tuiTextBox,\allocLines+32}=False Then Statement Return

  ;undo_Store{\undo,#TEDUNDO_insert_line,0,0,lpos}
  !line_use{*tline, lpos}
  If *tline
    flags.l = *tline\flags
  Else
    flags.l = \last_flags ; happens if we are the last line
  End If
  If \totalLines-lpos>0 Then _tb_CopyMem{\doc+(lpos*SizeOf.tline),\doc+((lpos+1)*SizeOf.tline),(\totalLines-lpos)*SizeOf.tline};:error{"Lut shift !"} ; LUT shift
  \totalLines+1

  !line_use{*tline, lpos}
  If *tline
    *tline\flags = flags
    If tlength<0 Then tlength = 0 : If textP Then While Peek.b(textP+tlength) : tlength+1:Wend
    If tlength=0 OR textP=Null Then dummy.w = $0A00 : a.s = "\\n" : textP=&a : tlength=1

      *tline\blength = (tlength+1+7)/8*8 ; 8-byte align
      *tline\text = AllocMem_ (*tline\blength,#MEMF_CLEAR)
      If *tline\text
        If tlength>0 Then _tb_CopyMem{textP,*tline\text,tlength}

        If (Peek.b(*tline\text+tlength-1)=$0A)
          ;tlength-1
        Else
          Poke.b *tline\text+tlength,$0A ; LF terminated
          tlength+1
        End If
        *tline\flags|#TUITBLF_RETURN_LF
        If (tlength>0)
          If (Peek.b(*tline\text+tlength-1)=$0D)
            tlength-1
            *tline\flags|#TUITBLF_RETURN_CR
          End If
        End If
        *tline\clength = tlength
        ;_tb_Tokenize{*textBox,lpos}
        ;error{"Line insterted at: "+Str$(lpos)+" = "+Peek.s(*tline\text)}
      Else
        *tline\clength = 0
      End If
    ;Else
    ;  *tline\clength = 0
    ;  *tline\text    = Null
    ;End If

    If lpos<=\cursor_lpos          Then \cursor_lpos+1
    If lpos<=\selection_begin_lpos Then \selection_begin_lpos+1
    If lpos<=\selection_end_lpos   Then \selection_end_lpos+1

  End If
  _tb_Damage{*textBox,lpos,*textBox\totalLines} ; ... to the end of text

End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_InsertInLine {*textBox.tuiTextBox,lpos.l,cpos.l,text.l,@ilength.l} /
;/                                                                             /
;/ Description:                                                                /
;/ insert at cpos 5 will move characters 5-end to cpos 6 and fill cpos with :: /
;/ inerttext                                                                   /
;/ insert at higher cpos than clength will add some spaces between             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : textbox object                                           /
;/ - lpos.l    : line position                                                          /
;/ - cpos.l    : character position or -1 for end-of-line                                                           /
;/ - text.l    : text to insert                                                           /
;/ - ilength.l    : length of text to insert or -1 for 0-terminated string                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_InsertInLine{*textBox.tuiTextBox,lpos.l,cpos.l,textP.l,tlength.l}

  If lpos<0 OR lpos>\totalLines Then Statement Return
  If lpos=\totalLines Then _tb_InsertNewLine{*textBox,lpos,textP,tlength} : Statement Return

  If tlength<0 Then tlength = 0 : If textP Then While Peek.b(textP+tlength) : tlength+1:Wend

  !line_use{*tline, lpos}
  If *tline
    If cpos<0 Then cpos=*tline\clength-1

    spacelength.l  = cpos - *tline\clength : If spacelength<0 Then spacelength=0
    clength.l      = *tline\clength + spacelength + tlength
    copylength.l   = *tline\clength - cpos : If copylength<0 Then copylength=0

    ;undo_Store{\undo,#TEDUNDO_insert,*tline\text,*tline\clength,lpos}
    If clength>=*tline\blength OR *tline\text=Null ; Zeile erneuern
      blength.l = (clength+1+7)/8*8
      newline.l = AllocMem_ (blength,#MEMF_CLEAR)
      If *tline\text
        _tb_CopyMem{ *tline\text,newline,*tline\clength}
        FreeMem_ *tline\text,*tline\blength
      End If
      *tline\blength = blength
      *tline\text    = newline
    End If

    If *tline\text

      For n.l=0 To copylength-1; copy including the return code
        Poke.b *tline\text+clength-n-1,Peek.b(*tline\text+*tline\clength-n-1)
      Next
      For n.l=0 To spacelength-1 ; insert spaces, if any
        Poke.b *tline\text+*tline\clength-1+n,$20
      Next
      For n.l=0 To tlength-1 ; insert text
        Poke.b *tline\text+cpos+n,Peek.b(textP+n)
      Next

      If lpos=\cursor_lpos
        If cpos<=\cursor_cpos Then \cursor_cpos+tlength
        If \cursor_cpos>=clength Then \cursor_cpos=clength-1
        If \cursor_cpos<0 Then \cursor_cpos=0
      End If

      If lpos=\selection_begin_lpos
        If cpos<=\selection_begin_cpos Then \selection_begin_cpos+tlength
        If \selection_begin_cpos>=clength Then \selection_begin_cpos=clength-1
        If \selection_begin_cpos<0 Then \selection_begin_cpos=0
      End If

      If lpos=\selection_end_lpos
        If cpos<=\selection_end_cpos Then \selection_end_cpos+tlength
        If \selection_end_cpos>=clength Then \selection_end_cpos=clength-1
        If \selection_end_cpos<0 Then \selection_end_cpos=0
      End If

      *tline\clength = clength
    End If
;    If ilength<2 Then _tb_Tokenize{*textBox,lpos,False}:Else _tb_tokenize{*textBox,lpos,True}
    _tb_Damage{*textBox,lpos,lpos}
  End If

End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_DeleteLine {*textBox.tuiTextBox,lpos.l}                      /
;/                                                                             /
;/ Description:                                                                /
;/ "Delete" at line 5 frees line 5 and moves line 6-end to position 5          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_DeleteLine{*textBox.tuiTextBox,lpos.l}

  If lpos<0 OR lpos>=\totalLines Then lpos=\totalLines-1
  If lpos<0 Then Statement Return

  !line_use{*tline, lpos}
  If *tline
    ;undo_Store{\undo,#TEDUNDO_delete_line,*tline\text,*tline\clength,lpos}
    If *tline\text Then FreeMem_ *tline\text ,*tline\blength : *tline\text=Null : *tline\blength=0 : *tline\clength=0
    ;_tb_Tokenize{*textBox ,lpos}
  End If

  _tb_Damage{*textBox,lpos,*textBox\totalLines} ; ... to the end of text

  \totalLines-1
  If \totalLines-lpos>0 Then _tb_CopyMem{ \doc+((lpos+1)*SizeOf.tline),\doc+(lpos*SizeOf.tline),(\totalLines-lpos)*SizeOf.tline} ;:error{"Lut shift !"}

  If lpos<\cursor_lpos Then \cursor_lpos-1
  If \cursor_lpos>=\totalLines Then \cursor_lpos=\totalLines-1
  If \cursor_lpos<0 Then \cursor_lpos=0
  If lpos<\selection_begin_lpos Then \selection_begin_lpos-1
  If lpos<\selection_end_lpos   Then \selection_end_lpos-1
End Statement


Statement _tb_DeleteInLine{*textBox.tuiTextBox,lpos.l,cpos.l,dlength.l}

  If lpos<0 OR lpos>=\totalLines OR dlength<=0 Then Statement Return

  !line_use{*tline, lpos}
  If *tline
    If *tline\text
      ;undo_Store{\undo,#TEDUNDO_delete,*tline\text,*tline\clength,lpos}
      If dlength<0 Then dlength = *tline\clength-cpos
      dlength.l = Min(dlength,*tline\clength-cpos)
      clength.l = *tline\clength-dlength  ; new length of string
      If clength<=0
        clength=0
        If *tline\text Then FreeMem_ *tline\text,*tline\blength : *tline\text=Null
      Else
        copylength.l = *tline\clength-cpos-dlength ; length of string on right side
        If copylength>0 ; move left ...
          _tb_CopyMem{ *tline\text+cpos+dlength,*tline\text+cpos,copylength}
        End If
      End If
      *tline\clength = clength

      If lpos=\cursor_lpos
        If cpos<\cursor_cpos Then \cursor_cpos-dlength
        If \cursor_cpos>=clength Then \cursor_cpos=clength-1
        If \cursor_cpos<0 Then \cursor_cpos=0
      End If

      If lpos=\selection_begin_lpos
        If cpos<\selection_begin_cpos Then \selection_begin_cpos-dlength
        If \selection_begin_cpos>=clength Then \selection_begin_cpos=clength-1
        If \selection_begin_cpos<0 Then \selection_begin_cpos=0
      End If

      If lpos=\selection_end_lpos
        If cpos<\selection_end_cpos Then \selection_end_cpos-dlength
        If \selection_end_cpos>=clength Then \selection_end_cpos=clength-1
        If \selection_end_cpos<0 Then \selection_end_cpos=0
      End If

    End If
  End If
  ;_tb_Tokenize{*textBox,lpos,force}
  _tb_Damage{*textBox,lpos,lpos} ; damage this line

End Statement


Statement _tb_Delete{*textBox.tuiTextBox,lpos.l,cpos.l,lpos_end.l,cpos_end.l}

  If lpos<0 Then lpos=0
  If cpos<0 Then cpos=0
  If lpos_end>=\totalLines Then lpos_end=\totalLines-1

  While lpos<=lpos_end
    !line_use{*tline, lpos}

    If *tline
      cpos2.l =  *tline\clength
      If lpos=lpos_end Then cpos2=cpos_end    ; it is the last line in selection
      dlength.l = cpos2-cpos
      If cpos2>=*tline\clength ; we delete the return code
        If cpos>0 AND *tline\text Then _tb_InsertInLine{*textBox,lpos+1,0,*tline\text,cpos}
        _tb_DeleteLine{*textBox,lpos} : lpos-1 : lpos_end-1
      Else
        If dlength>0 Then _tb_DeleteInLine{*textBox,lpos,cpos,dlength}
      End If
      cpos = 0
    End If

    lpos+1
  Wend

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_Delete {*textBox.tuiTextBox,lpos.l,cpos.l,elength.l}         /
;/                                                                             /
;/ Description:                                                                /
;/ "delete" at cpos -1 removes elength-1 characters and appends the rest to :: /
;/ upper line                                                                  /
;/ "delete" at cpos 0 removes elength characters including position 0          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - cpos.l    : ???                                                           /
;/ - elength.l    : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ____tb_Delete_dep{*textBox.tuiTextBox,lpos.l,cpos.l,lpos_end.l,cpos_end.l}

If lpos<0 OR lpos>=\totalLines Then lpos =\totalLines-1
If lpos>=0
  !line_use{*tline, lpos}
  If *tline
  elength.l=0
    If elength<2 Then force.l=False:Else force=True
    If elength>0
      If cpos<0
        If lpos>0 AND (\edflags&#TUITBF_DELWRAP><0)
          elength-1 ; join lines
          !line_use{*tline, lpos}
          !line_use{*tline2, lpos-1}
          If *tline2 ; \doc\base[lpos-1]
            clength.l= *tline2\clength ; \doc\base[lpos-1]\clength
            If clength>0 AND *tline\text><False
              _tb_InsertInLine{*textBox,lpos-1,clength,*tline\text,*tline\clength}
              _tb_DeleteLine{*textBox,lpos}
            Else
              If *tline\text=False
                _tb_DeleteLine{*textBox,lpos}
              Else
                _tb_DeleteLine{*textBox,lpos-1}
              End If
              clength=1
            End If
            lpos-1
            cpos+clength
          Else
            _tb_DeleteLine{*textBox,lpos-1}
            lpos-1
            cpos=0
          End If
        Else
          elength-1 : cpos=0
        End If
      End If
    End If

    If elength>0
      !line_use{*tline, lpos}
      If *tline
        If cpos>=*tline\clength AND (\edflags&#TUITBF_REMWRAP><0) ; join lines from down
          If lpos<\totalLines-1
            !line_use{*tline, lpos}
            !line_use{*tline2, lpos+1}
            If *tline2 ; \doc\base[lpos+1]
              clength.l= *tline2\clength ; \doc\base[lpos+1]\clength
              If *tline2\text><0 AND clength>0
                ;cpos+*tline\clength
                _tb_InsertInLine{*textBox,lpos,*tline\clength,*tline2\text,clength}

              End If
              _tb_DeleteLine{*textBox,lpos+1}
            End If
          End If
          elength-1 ; ... ; drag from next line
        End If
      End If
    End If

    If elength>0
      !line_use{*tline, lpos}
      If *tline
        If *tline\text
          ;undo_Store{\undo,#TEDUNDO_delete,*tline\text,*tline\clength,lpos}
          If elength<0 Then elength = *tline\clength-cpos
          elength.l = Min(elength,*tline\clength-cpos)
          clength.l = *tline\clength-elength  ; new length of string
          If clength<0 Then clength=0
          copylength.l = *tline\clength-cpos-elength+1 ; length of string on right side
          If clength>0
            If copylength>0 ; move left ...
              _tb_CopyMem{ *tline\text+cpos+elength,*tline\text+cpos,copylength}
            End If
          Else
            If *tline\text Then FreeMem_ *tline\text,*tline\blength : *tline\text=Null
          End If
          *tline\clength = clength
        End If
      End If
    End If
    ;_tb_Tokenize{*textBox,lpos,force}
  End If
End If
If \cursor_lpos>\totalLines-1 Then \cursor_lpos=\totalLines-1
If \topLine>\totalLines-1 Then \topLine=\totalLines-1
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _tb_ReturnBreak {*textBox.tuiTextBox,lpos.l,cpos.l,:: /
;/ @indent.l}                                                                  /
;/                                                                             /
;/ Description:                                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - cpos.l    : ???                                                           /
;/ - indent.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _tb_ReturnBreak{*textBox.tuiTextBox,lpos.l,cpos.l,@indent.l}
n.l=0
!line_use{*tline, lpos}
If *tline
  If *tline\text
    copylength.l = 0
    If (\edflags&#TUITBF_AUTOINDENT)><0 AND indent
      While Peek.b(*tline\text+n)=32 OR Peek.b(*tline\text+n)=9 AND n<*tline\clength
        copylength+1
      Wend
      If copylength>\cursor_cpos Then copylength=0
    End If

    If cpos<*tline\clength
      _tb_InsertNewLine{*textBox,lpos,Null,0}
    Else
      _tb_InsertNewLine{*textBox,lpos+1,*tline\text,copylength}
    End If
  Else
    _tb_InsertNewLine{*textBox,lpos+1,Null,0}
  End If
Else
  _tb_InsertNewLine{*textBox,lpos+1,Null,0}
End If
Function Return n
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_InsertString {*textBox.tuiTextBox,lpos.l,cpos.l,str_ptr.l,:: /
;/ @blength.l,@upd.l}                                                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - cpos.l    : ???                                                           /
;/ - str_ptr.l    : ???                                                        /
;/ - blength.l    : ???                                                        /
;/ - upd.l    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _tb_Insert{*textBox.tuiTextBox,lpos.l,cpos.l,text.l,ilength.l}

  If ilength<0 Then ilength=0 : While Peek.b(text+ilength) : ilength+1:Wend

  first.l = True
  epos.l = cpos
  apos.l = 0
  bpos.l = 0
  xpos.l = 0
  While xpos<ilength
    Select Peek.b(text+xpos)
      Case 10
        If first=True AND lpos<\totalLines
          _tb_InsertInLine{*textBox,lpos,cpos,text+apos,bpos-apos}
          cpos.l = _tb_ReturnBreak{*textBox,lpos,cpos+bpos-apos,False}
          cpos=0
          epos.l = cpos+bpos-apos
        Else
          _tb_InsertNewLine{*textBox,lpos,text+apos,bpos-apos+1}
          cpos=0
          epos.l = bpos-apos
        End If
        first=False
        apos=xpos+1
        bpos=xpos+1
        lpos+1
      Case 13
        ; .... do not insert the 13!
        If Peek.b(text+xpos+1)><10 Then bpos+1
      Default
        bpos+1

    End Select
    xpos+1
  Wend
  ;If bpos>apos
    _tb_InsertInLine{*textBox,lpos,cpos,text+apos,bpos-apos}
    epos.l = cpos+bpos-apos
 ; End If

  Function Return epos
End Function


Statement _tb_Paste{*textBox.tuiTextBox,lpos.l,cpos.l}

  *cH.clipboardHandle = clipboard_OpenRead{0}
  If *cH
    *text.str = Null
    Repeat
      hasData.l = clipboard_ReadLine{*cH,&*text}
      If hasData
        _tb_Insert{*textBox,lpos,cpos,str_GetPtr{*text},str_Len{*text}}
        lpos+1 : cpos=0
      End If
    Until hasData = 0
    str_Free{&*text}
    clipboard_Free{*cH}
  End If

End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_FreeText {*textBox.tuiTextBox}                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_FreeText{*textBox.tuiTextBox}
If \doc
  For lpos.l = 0 To \totalLines-1
    !line_use {*tline, lpos}
    If *tline
      If *tline\text  Then FreeMem_ *tline\text  ,*tline\blength  : *tline\text=Null
;      If *tline\ttext Then FreeMem_ *tline\ttext ,*tline\tblength : *tline\ttext=Null
  ;    ted_tokenize {*ted ,lpos}
      ;FreeMem_ *tline,SizeOf.tline
      ;Poke.l \doc+lpos*4,0
    End If
  Next
End If
\totalLines = 0
\totalWidth = 1
;undo_Flush{\undo}
;undo_SetSaved{\undo}
End Statement




Statement ntui_SetTextBoxText{*textBox.tuiTextBox,text.l,@blength.l,@*rp.RastPort}
If *textBox
  _tb_FreeText{*textBox}
  _tb_Insert{*textBox,0,0,text,blength}
  \cursor_lpos   = 0
  \cursor_cpos   = 0
  \topLine       = 0
  \cursor_pixpos = 0
End If
End Statement




;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_SetValidTextBoxChars {*textBox.tuiTextBox,chars.s}          /
;/                                                                             /
;/ Description:                                                                /
;/ Define the characters that are allowed to be typed into the textbox.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - chars.s    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_SetValidTextBoxChars{*textBox.tuiTextBox,chars.s}
For n.l=0 To 255
  *textBox\validChar[n]=False
Next
For n.l=0 To FLen(chars)-1
  ind.l = Peek.b(&chars+n) & $FF
  *textBox\validChar[ind]=True
Next
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.s = ntui_GetTextBoxSelection {*textBox.tuiTextBox,@only:: /
;/ Selection.l}                                                                   /
;/                                                                             /
;/ Description:                                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - onlySelection.l    : ???                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s ntui_GetTextBoxSelection{*textBox.tuiTextBox,@onlySelection.l}
If onlySelection
  lpos_a.l = \selection_begin_lpos
  lpos_b.l = \selection_end_lpos
  cpos_a.l = \selection_begin_cpos
  cpos_b.l = \selection_end_cpos
Else
  lpos_a.l = 0
  lpos_b.l = \totalLines-1
  cpos_a.l = 0
  cpos_b.l = $7FFFFFFF
End If
If cpos_a<0 Then cpos_a=0
If cpos_b<0 Then cpos_b=0

string.s = ""

If lpos_a>=0

  For lpos.l = lpos_a+1 To lpos_b-1
    !line_use{*tline, lpos}
    If *tline
      If *tline\text
        string.s + Peeks$(*tline\text,*tline\clength)
      End If
    End If
    string.s+Chr$(10)
    If FLen(string.s)>(1024/2-8) Then Pop For:Pop If:error{"\\__THIS_FUNCTION: Not enough string buffer for clipboard!"}:string.s = "":Goto xskipcopy
  Next

  If lpos_a=lpos_b
    !line_use{*tline, lpos_a}
    If *tline
      If cpos_b>*tline\clength Then cpos_b=*tline\clength
      elength.l = cpos_b-cpos_a
      If elength>0
        If *tline\text
          string.s = LSet$(" ",elength)+string.s
          CopyMem_ *tline\text+cpos_a,&string.s,elength
        End If
      End If
    End If
  Else
    string_add.s = ""
    !line_use{*tline, lpos_a}
    If *tline
      If *tline\text
        elength = *tline\clength-cpos_a
        If elength>0
          string_add.s = Peeks$(*tline\text+cpos_a,*tline\clength-cpos_a)
        End If
      End If
    End If
    string.s = string_add.s + Chr$(10) + string.s

    !line_use{*tline, lpos_b}
    If *tline
      If cpos_b>*tline\clength Then cpos_b=*tline\clength
      elength = cpos_b
      If *tline\text
        string.s = string.s + LSet$(" ",elength)
        CopyMem_ *tline\text,&string.s + FLen(string.s)-elength,elength
      End If
    End If
  End If

End If
xskipcopy:
Function Return string.s
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_DeleteSelection {*textBox.tuiTextBox,*rp.RastPort}              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ____tb_DeleteSelection_deprecated{*textBox.tuiTextBox,*rp.RastPort}
lpos_a.l = \selection_begin_lpos
lpos_b.l = \selection_end_lpos
If lpos_a>=0
  For lpos.l = lpos_a+1 To lpos_b-1
    _tb_DeleteLine{*textBox,lpos_a+1}
  Next

  If lpos_a=lpos_b
    elength.l = \selection_end_cpos-\selection_begin_cpos
    ;_tb_Delete{*textBox,lpos_a,\selection_begin_cpos,elength}
  Else
    !line_use{*tline, lpos_a}
    If *tline
      elength = *tline\clength-\selection_begin_cpos
      If \selection_begin_cpos=0
        _tb_DeleteLine{*textBox,lpos_a} : lpos_a-1
      Else
       ; _tb_Delete{*textBox,lpos_a,\selection_begin_cpos,elength}
      End If
    End If

    !line_use{*tline, lpos_a+1}
    If *tline
      elength = \selection_end_cpos
      ;If elength = *tline\clength
      ;  _tb_delete_line{*textBox,lpos_a+1}
      ;Else
        ;_tb_Delete{*textBox,lpos_a+1,0,elength}
      ;End If
    End If
  End If
  _tb_SetCursor{*textBox,\selection_begin_lpos,\selection_begin_cpos,-1,-1,False}
  _tb_SetSelection{*textBox}
  If *rp Then _ntui_DrawTextBoxIntern{*textBox,-1,-1,-1,-1,*rp}
  ;If upd Then _tb_UpdateScroller{*textBox}
End If
End Statement


Statement _tb_Copy{*textBox.tuiTextBox,lpos.l,cpos.l,lpos_end.l,cpos_end.l}

  If lpos<0 Then lpos=0
  If cpos<0 Then cpos=0
  If lpos_end>=\totalLines Then lpos_end=\totalLines-1

  *cH.clipboardHandle = clipboard_OpenWrite{0}

  While lpos<=lpos_end
    !line_use{*tline, lpos}

    If *tline
      cpos2.l =  *tline\clength+1
      If lpos=lpos_end Then cpos2=Min(cpos_end,cpos2)    ; it is the last line in selection
      copylength.l = cpos2-cpos
      If *cH
        If *tline\text
          clipboard_WriteLine{*cH,*tline\text+cpos,copylength}
        Else
          If copylength>0
            a.s = "\\n"
            clipboard_WriteLine{*cH,&a.s,1}
          End If
        End If
      End If

      cpos = 0
    End If

    lpos+1
  Wend

  If *cH Then clipboard_Free{*cH}

End Statement


Statement _tb_Cut{*textBox.tuiTextBox,lpos.l,cpos.l,lpos_end.l,cpos_end.l}

  _tb_Copy{*textBox,lpos,cpos,lpos_end,cpos_end}
  _tb_Delete{*textBox,lpos,cpos,lpos_end,cpos_end}

End Statement



Statement ____tb_DoSelection{*textBox.tuiTextBox,copy.w,del.w,loose.w,*rp.RastPort}
  lpos.l     = \selection_begin_lpos
  lpos_end.l = \selection_end_lpos
  cpos.l     = \selection_begin_cpos
  cpos_end.l = \selection_end_cpos

  If lpos<0 Then lpos=0
  If cpos<0 Then cpos=0

  If copy Then *cH.clipboardHandle = clipboard_OpenWrite{0} : Else *cH = Null

  While lpos<=lpos_end
    !line_use{*tline, lpos}

    If *tline
      cpos2.l =  *tline\clength+1
      If lpos=lpos_end Then cpos2=cpos_end    ; it is the last line in selection
      elength.l = cpos2-cpos
      If *cH
        If *tline\text
          clipboard_WriteLine{*cH,*tline\text+cpos,elength}
        Else
          If elength>0
            a.s = "\\n"
            clipboard_WriteLine{*cH,&a.s,1}
          End If
        End If
      End If

      If del
        If cpos2>=*tline\clength+1 ; we delete the return code
          If cpos=0 ; we delete the whole line
            _tb_DeleteLine{*textBox,lpos} : lpos-1 : lpos_end-1
          Else
            ;_tb_Delete{*textBox,lpos,cpos,elength}
          End If
        Else
          ;_tb_Delete{*textBox,lpos,cpos,elength}
        EndIf
      End If
      cpos = 0
    End If

    lpos+1
  Wend
  ;  _tb_SetCursor{*textBox,\selection_begin_lpos,\selection_begin_cpos,-1,-1,False}
  If loose Then _tb_SetSelection{*textBox}
  If *rp Then _ntui_DrawTextBoxIntern{*textBox,-1,-1,-1,-1,*rp}
  ;If upd Then _tb_UpdateScroller{*textBox}

  If *cH Then clipboard_Free{*cH}

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_SetTextBoxSelection {*textBox.tuiTextBox,@*rp.RastPort,@b:: /
;/ eginLine.l,@beginCharacter.l,@endLine.l,@endCharacter.l}                    /
;/                                                                             /
;/ Description:                                                                /
;/ Set a range of characters as selected.                                                                            /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort      : ???                                                     /
;/ - beginLine.l       : ???                                                      /
;/ - beginCharacter.l  : ???                                                 /
;/ - endLine.l         : ???                                                        /
;/ - endCharacter.l    : ???                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_SetTextBoxSelection{*textBox.tuiTextBox,@*rp.RastPort,@beginLine.l,@beginCharacter.l,@endLine.l,@endCharacter.l}
If *rp=-1 Then *rp=Null
If beginLine<0
  _tb_SetSelection{*textBox,0,0,\totalLines-1,$7FFFFFFF}
Else
  _tb_SetSelection{*textBox,beginLine,beginCharacter,endLine,endCharacter}
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_ClearTextBoxSelection {*textBox.tuiTextBox,@*rp.RastPort}   /
;/                                                                             /
;/ Description:                                                                /
;/ Remove the textob xselection, if any (the selected text will not be removed, only fact that it is selected)                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_ClearTextBoxSelection{*textBox.tuiTextBox,@*rp.RastPort}
If *rp=-1 Then *rp=Null
_tb_SetSelection{*textBox,-1,-1,-1,-1}
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_DeleteTextBoxSelection {*textBox.tuiTextBox,@*rp.RastPort}  /
;/                                                                             /
;/ Description:                                                                /
;/ Delete the text that is currently selected.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_DeleteTextBoxSelection{*textBox.tuiTextBox,@*rp.RastPort}
If *rp=-1 Then *rp=Null
_tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
End Statement




Function.l ntui_LoadTextBox{*textBox.tuiTextBox,filename.s,*rp.RastPort}
_tb_FreeText{*textBox}
fid.l = Open_ (&filename,#MODE_OLDFILE)
If fid
  blength.l = 0
  If Seek_ (fid,0,#OFFSET_END)><-1
    blength   = Seek_ (fid,0,#OFFSET_BEGINNING)
  End If
  If blength>0
    *textBox\tank = AllocVec_(blength,#MEMF_ANY)
    If *textBox\tank

      Read_ fid,*textBox\tank,blength

      cpos.l = 0
      allocLines.l = 32
      totalLines.l = 0
      _tb_Expand{*textBox.tuiTextBox,allocLines}
      While cpos<blength
        !line_use{*tline,totalLines}
        If *tline
          totalLines+1
          *tline\flags   = #TUITBLF_STOLEN
          *tline\text    = *textBox\tank+cpos

          ;*tline\tclength = 0
          ;*tline\tblength = 0
          ;*tline\ttext    = Null
          eol.l = False
          spos.l = cpos
          While eol
            c.b = Peek.b(*textBox\tank+cpos)
            If cpos>=blength Then eol=True
            If c=10 Then eol=True
            cpos+1
          Wend
          *tline\blength = cpos-spos
          *tline\clength = cpos-spos
        End If
      Wend
    End If
  End If
  Close_ fid
End If
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.w = _ntui_TextBoxVanillaKey {*textBox.tuiTextBox,*tuiEv:: /
;/ ent.tuiEvent}                                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *tuiEvent.tuiEvent    : ???                                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.w     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.w _ntui_TextBoxVanillaKey{*textBox.tuiTextBox,*tuiEvent.tuiEvent,*rp.RastPort}
  done.w = False
  vanillakeyP.l = ntui_GetEventAttr{*tuiEvent,#TUIEVA_STRING,0}
  If vanillakeyP=Null Then Function Return False
  quali.l       = ntui_GetEventAttr{*tuiEvent,#TUIEVA_QUALIFIER,0}
  Select Peek.b(vanillakeyP)
    Case 13 ; return
      If *textBox\edflags&#TUITBF_WANTRETURN
        ;undo_Start{*textBox\undo}
        If \selection_begin_lpos>=0 Then _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
        If (quali&#TUIQUAL_SHIFT) OR (\edflags&#TUITBF_RETURNBREAK)
          If (quali&#TUIQUAL_SHIFT) Then indent.l=False:Else indent=True
          npos.l = _tb_ReturnBreak{*textBox,\cursor_lpos,\cursor_cpos,indent}
          _tb_SetCursor{*textBox,\cursor_lpos+1,npos}
        Else
          a.s = ""
          If \edflags&#TUITBF_AUTOINDENT
            !line_use{*tline, \cursor_lpos}
            If *tline
              If *tline\text
                n.l = 0
                While Peek.b(*tline\text+n)=32 AND n<*tline\clength
                  n+1
                Wend
                a.s = LSet$(" ",n)
              End If
            End If
          End If
          _tb_InsertNewLine{*textBox,\cursor_lpos+1,&a.s,FLen(a.s)}
          _tb_SetCursor{*textBox,\cursor_lpos+1,FLen(a.s)}
        End If
        done.w = True
        str_Dup{&*tuiEvent\notifyID,*textBox\obj\onKeyDown}
        _ntui_DrawTextBoxIntern{*textBox,-1,-1,-1,-1,*rp}
      Else ; single line textbox
        \accept=False
        ;*tuiEvent\notify=*textBox\obj\notify
        str_Dup{&*tuiEvent\notifyID,*textBox\obj\onKeyDown}
        _ntui_UpdateTextBoxString{*textBox}
        _ntui_DrawTextBoxIntern{*textBox,-1,-1,-1,-1,*rp}
      End If

    Case 127 ; backspace
      If \selection_begin_lpos>=0 AND \selection_end_lpos>=0
        _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
      Else
        ;undo_Start{*textBox\undo}
        oldlines.l = \totalLines
        _tb_Delete{*textBox,\cursor_lpos,\cursor_cpos,\cursor_lpos,\cursor_cpos+1}
      End If
      done.w = True
      str_Dup{&*tuiEvent\notifyID,*textBox\obj\onKeyDown}

    Case 8 ; delete
      If \selection_begin_lpos>=0 AND \selection_end_lpos>=0
        _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
      Else
        ;undo_Start{*textBox\undo}
        delpos.l   = \cursor_cpos-1
        delline.l  = \cursor_lpos
        If delpos<0
          delline-1
          !line_use{*tline, delline}
          If *tline
            delpos = *tline\clength-1
          End If
        End If
        _tb_Delete{*textBox,delline,delpos,delline,delpos+1}
      End If
      done = True
      str_Dup{&*tuiEvent\notifyID,*textBox\obj\onKeyDown}

    Default
      key.l = Peek.b(vanillakeyP)
      If (quali&#TUIQUAL_COM)
        Select key
          Case @"v":
            _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
            _tb_Paste{*textBox,\cursor_lpos,\cursor_cpos}
            done = True
          ;Case @"z" : _tb_DoUndo{*textBox} : done.w = True
          Case @"x":
            _tb_Cut{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
            done = True
          Case @"c":
            _tb_Copy{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
            done = True
          Case @"d":
            If ((\edflags&#TUITBF_LOOSESELECTION)><0) AND (\selection_begin_lpos>=0 AND \selection_end_lpos>=0)
              _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
            Else
              !line_use{*tline, *textBox\totalLines-1}
              If *tline
                _tb_DeleteLine{*textBox,\cursor_lpos}
              End If
            End If
            done = True
          Case @"a":
            cpos.l = 0
            !line_use{*tline, *textBox\totalLines-1}
            If *tline
              cpos = *tline\clength
            End If
            _tb_SetSelection{*textBox,0,0,*textBox\totalLines,cpos}
            done = True
        End Select
        key=0
      End If

;    If (quali&#TUIQUAL_CTRL)
;      Select key
;        Case 4 ; D
;          If ((\edflags&#TUITBF_LOOSESELECTION)><0)  AND (\selection_begin_lpos>=0 AND \selection_end_lpos>=0)
;            _tb_DeleteSelection{*textBox,*rp}
;          Else
;            ;ntui_TBDeleteLine{*textBox}
;          End If
;          done.w = True
;        ;Case 22 : _tb_do_paste{*textBox} :tuievent\notify=False; V
;        ;Case 26 : _tb_do_undo{*textBox}  :tuievent\notify=False; Z
;        ;Case 24 : _tb_do_cut{*textBox}   :tuievent\notify=False; X
;        ;Case 3  : _tb_do_copy{*textBox}   :tuievent\notify=False; C
;      End Select
;      key=0
;    End If

      If key>31 OR key<0 OR key=9
        If *textBox\validChar[key&$FF]
          ;undo_Start{*textBox\undo}
          _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
          a.s = Chr$(key);Peek.s(vanillakeyP)
          _tb_Insert{*textBox,\cursor_lpos,\cursor_cpos,&a.s,FLen(a.s)}
          ;_tb_MoveCursor{*textBox,1,0,False,*rp}
          done = True
          str_Dup{&*tuiEvent\notifyID,*textBox\obj\onKeyDown}
        End If
      End If

  End Select

  Function Return done

End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.w = _ntui_KeyStrokeTextBox {*textBox.tuiTextBox,*tuiEve:: /
;/ nt.tuiEvent}                                                                /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - rkey.l    : ???                                                           /
;/ - vkey.l    : ???                                                           /
;/ - string.s    : ???                                                         /
;/ - *tuiEvent.tuiEvent    : ???                                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.w     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.w _ntui_KeyStrokeTextBox{*textBox.tuiTextBox,*tuiEvent.tuiEvent,*rp.RastPort}

  rkey.l   = ntui_GetEventAttr{*tuiEvent,#TUIEVA_VALUE,0}
  vkeyP.l  = ntui_GetEventAttr{*tuiEvent,#TUIEVA_STRING,0}
  If vkeyP Then vkey.l   = Peek.b(vkeyP) & $FF  : Else vkey=0
  quali.l  = ntui_GetEventAttr{*tuiEvent,#TUIEVA_QUALIFIER,0}

  done.w = False
  _tb_DoBlink{*textBox,*rp,Off}
  If (quali&#TUIQUAL_SHIFT) Then shift.l=True:Else shift=False

  If \accept=0
    If vkey=13 ; switch to accept input
      \accept=1
      _tb_DoBlink{*textBox,*rp,On}
      Function Return True
    Else
      Function Return False
    End If
  End If

  Select rkey
    Case #RAWKEY_RIGHT ; 78 ; >
      _tb_MoveCursor{*textBox,1,0,shift,*rp}  : done=True

    Case #RAWKEY_LEFT ; 79 ; <
      _tb_MoveCursor{*textBox,-1,0,shift,*rp} : done=True

    Case #RAWKEY_UP ; 76 ; up
      _tb_MoveCursor{*textBox,0,-1,shift,*rp} : done=True

    Case #RAWKEY_DOWN ; 77 ; down
      _tb_MoveCursor{*textBox,0,1,shift,*rp}  : done=True

    Case #RAWKEY_TAB ; 66 ; TAB
      If ((*textBox\edflags&#TUITBF_READONLY)=0)
        If ((*textBox\edflags&#TUITBF_WANTTAB))
          If shift=False
            done=_ntui_TextBoxVanillaKey{*textBox,*tuiEvent,*rp}
          End If
        End If
      End If

    Default
      If ((*textBox\edflags&#TUITBF_READONLY)=0)
        done = _ntui_TextBoxVanillaKey{*textBox,*tuiEvent,*rp}
      Else
        If (quali&(#TUIQUAL_COM|#TUIQUAL_CTRL)) ; ok, copy is supported in ReadOnly!
        ;Select vkey
;          Case @"c" : _tb_do_copy{*textBox} :tuievent\notify=False
;          Case 3    : _tb_do_copy{*textBox} :tuievent\notify=False; C
        ;End Select
        End If
      End If
  End Select
  _tb_Repair{*textBox,*rp}
  _tb_DoBlink{*textBox,*rp,On}

  Function Return done

End Function




_ntui_SetTextBoxAttr:
Function.w _ntui_SetTextBoxAttr{*textBox.tuiTextBox,ti_Tag.l,ti_Data.l}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

  done.w = True

  *rp.RastPort = ntui_ObtainRastPort{*textBox}

  Select ti_Tag
    Case #TUITBA_CURSOR_LINE        : _tb_SetCursor{*textBox,ti_Data,*textBox\cursor_cpos,-1,-1,*rp}
    Case #TUITBA_CURSOR_COLUMN      : _tb_SetCursor{*textBox,*textBox\cursor_lpos,ti_Data,-1,-1,*rp}
    Case #TUITBA_BEGINSELECT_LINE   : _tb_SetSelection{*textBox,ti_Data,*textBox\selection_begin_cpos,*textBox\selection_end_lpos,*textBox\selection_end_cpos}
    Case #TUITBA_BEGINSELECT_COLUMN : _tb_SetSelection{*textBox,*textBox\selection_begin_lpos,ti_Data,*textBox\selection_end_lpos,*textBox\selection_end_cpos}
    Case #TUITBA_ENDSELECT_LINE     : _tb_SetSelection{*textBox,*textBox\selection_begin_lpos,*textBox\selection_begin_cpos,ti_Data,*textBox\selection_end_cpos}
    Case #TUITBA_ENDSELECT_COLUMN   : _tb_SetSelection{*textBox,*textBox\selection_begin_lpos,*textBox\selection_begin_cpos,*textBox\selection_end_lpos,ti_Data}
    Case #TUITBA_TBFLAGS            : *textBox\edflags = ti_Data   : ntui_Refresh{*textBox,Null}
    Case #TUITBA_SETTBFLAGS         : *textBox\edflags | ti_Data   : ntui_Refresh{*textBox,Null}
    Case #TUITBA_CLEARTBFLAGS       : *textBox\edflags | ti_Data - ti_Data  : ntui_Refresh{*textBox,Null}
    Case #TUITBA_BLINKSPEED         : *textBox\blink_speed = ti_Data
    Case #TUITBA_TABWIDTH           : *textBox\tab_width = ti_Data  : ntui_Refresh{*textBox,Null}
    Case #TUITBA_TOPLINE            : _tb_Scroll{*textBox,0,ti_Data-*textBox\topLine,*rp}  : _ntui_PropagateBind{*textBox,#TUIEV_BIND_VVALUE,*textBox\topLine,Null}
    Case #TUITBA_LEFTOFFSET         : _tb_Scroll{*textBox,ti_Data-*textBox\leftOffset,0,*rp} : _ntui_PropagateBind{*textBox,#TUIEV_BIND_HVALUE,*textBox\leftOffset,Null}
    Case #TUITBA_MAXCOLUMNS         : *textBox\maxChars = ti_Data
    Case #TUITBA_MAXLINES           : *textBox\maxLines = ti_Data
    Case #TUITBA_FONT               : *textBox\font = ti_Data : *textBox\fontstolen = True : ntui_Refresh{*textBox,Null}
    Case #TUITBA_LINE               : ; todo
    Case #TUITBA_SELECTION          : ; todo
    Case #TUITBA_HIGHLIGHTNING      : *textBox\tokenizing = ti_Data  : ntui_Refresh{*textBox,Null}
    Case #TUIA_STRING               : ntui_SetTextBoxText{*textBox,ti_Data}

    Case #TUIA_XMLATTR
      *xmlA.tuiXmlAttr = ti_Data
      Select Peek.s(*xmlA\nameP)
        Case "text"
          ntui_SetTextBoxText{*textBox,*xmlA\stringP}
        Default
          done = False
       End Select

    Default
      done = False
  End Select

  If *rp
    _tb_Repair{*textBox,*rp}
    ntui_ReleaseRastPort{*textBox}
  End If

  Function Return done
End Function

_ntui_GetTextBoxAttr:
Function.w _ntui_GetTextBoxAttr{*textBox.tuiTextBox,ti_Tag.l,*ti_Data.longP}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

  done.w = True
  Select ti_Tag
    Case #TUITBA_CURSOR_LINE        : *ti_Data\l = *textBox\cursor_lpos
    Case #TUITBA_CURSOR_COLUMN      : *ti_Data\l = *textBox\cursor_cpos
    Case #TUITBA_BEGINSELECT_LINE   : *ti_Data\l = *textBox\selection_begin_lpos
    Case #TUITBA_BEGINSELECT_COLUMN : *ti_Data\l = *textBox\selection_begin_cpos
    Case #TUITBA_ENDSELECT_LINE     : *ti_Data\l = *textBox\selection_end_lpos
    Case #TUITBA_ENDSELECT_COLUMN   : *ti_Data\l = *textBox\selection_end_cpos
    Case #TUITBA_TBFLAGS            : *ti_Data\l = *textBox\edflags
    Case #TUITBA_BLINKSPEED         : *ti_Data\l = *textBox\blink_speed
    Case #TUITBA_ROWHEIGHT          : *ti_Data\l = *textBox\rowheight
    Case #TUITBA_SPACEWIDTH         : *ti_Data\l = *textBox\space_width
    Case #TUITBA_TABWIDTH           : *ti_Data\l = *textBox\tab_width
    Case #TUITBA_VISIBLELINES       : *ti_Data\l = *textBox\visibleLines
    Case #TUITBA_TOTALLINES         : *ti_Data\l = *textBox\totalLines
    Case #TUITBA_TOPLINE            : *ti_Data\l = *textBox\topLine
    Case #TUITBA_VISIBLEWIDTH       : *ti_Data\l = *textBox\visibleWidth
    Case #TUITBA_TOTALWIDTH         : *ti_Data\l = *textBox\totalWidth
    Case #TUITBA_LEFTOFFSET         : *ti_Data\l = *textBox\leftOffset
    Case #TUITBA_MAXCOLUMNS         : *ti_Data\l = *textBox\maxChars
    Case #TUITBA_MAXLINES           : *ti_Data\l = *textBox\maxLines
    Case #TUITBA_FONT               : *ti_Data\l = *textBox\font
    Case #TUITBA_LINE               : !line_use{*tline,*ti_Data\l}
                                      *ti_Data\l = Null
                                      If *tline
                                        If *tline\text
                                          *ti_Data\l = *tline\text
                                        End If
                                      End If
    Case #TUITBA_LINELENGTH         : !line_use{*tline,*ti_Data\l}
                                      *ti_Data\l = 0
                                      If *tline
                                        *ti_Data\l = *tline\clength
                                      End If
    Case #TUITBA_SELECTION          : *ti_Data\l = 0 ; todo
    Case #TUITBA_HIGHLIGHTNING      : *ti_Data\l = *textBox\tokenizing
    Case #TUIA_STRING               : !line_use{*tline,0}
                                      *ti_Data\l = Null
                                      If *tline
                                        If *tline\text
                                          *ti_Data\l = *tline\text
                                        End If
                                      End If

    Default
      done = False
  End Select

  Function Return done
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.w = _ntui_DispatchTextBox {*textBox.tuiTextBox,*tuiEvent.:: /
;/ tuiEvent}                                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ * do what happens if the user operates the String */                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *tuiEvent.tuiEvent    : ???                                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.w     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
_ntui_DispatchTextBoxEvent:
Function.w _ntui_DispatchTextBoxEvent{*textBox.tuiTextBox,*tuiEvent.tuiEvent}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}
  !_ASSERT{*tuiEvent}
  *tui.tuiObject = *textBox\obj
  done.w = False

  Select *tuiEvent\evID
    Case #TUIEV_MOUSEDOWN:
      If *tuiEvent\value=0
        If ntui_HitObject{*textBox,*tuiEvent\pos\x,*tuiEvent\pos\y}
          ntui_SetFocus{*textBox}
          *textBox\obj\flags | #TUIF_ACTIVE
          str_Dup{&*tuiEvent\notifyID,*textBox\obj\onTouch}
          ntui_Refresh{*textBox,Null}
          \accept=1

          dbl.l = 0
          If *tuiEvent\qualifier_&#TUIQUAL_DOUBLECLICK Then dbl = 1
          If *tuiEvent\qualifier_&#TUIQUAL_TRIPLECLICK Then dbl = 2
          ox.l = *tuiEvent\pos\x - *textBox\obj\cbox\left
          oy.l = *tuiEvent\pos\y - *textBox\obj\cbox\top

          *rp.RastPort = ntui_ObtainRastPort{*textBox}

          _tb_DoBlink{*textBox,*rp,Off}
          _tb_MouseClick{*textBox,*rp,ox,oy,0,dbl}

          If *textBox\edflags&#TUITBF_SELECTONFOCUS
            If *textBox\selection_begin_lpos<0
              If *textBox\cursor_lpos>=0
                !line_use{*tline, *textBox\cursor_lpos}
                If *tline
                  If *textBox\cursor_cpos>=*tline\clength
                    ntui_SetTextBoxSelection{*textBox.tuiTextBox,*rp}
                  End If
                End If
              End If
            End If
          End If
          _tb_DoBlink{*textBox,*rp,On}
          If *rp Then ntui_ReleaseRastPort{*textBox}

          done=True
        End If
      End If

    Case #TUIEV_MOUSEUP
      If (*textBox\obj\flags | #TUIF_ACTIVE)
        str_Dup{&*tuiEvent\notifyID,*textBox\obj\onRelease}
        done.w = True
      End If

    Case #TUIEV_MOUSEMOVE
      If (*textBox\obj\flags | #TUIF_ACTIVE)
        If tuiMouseButtonMap(0)
          ox.l = *tuiEvent\pos\x - *textBox\obj\cbox\left
          oy.l = *tuiEvent\pos\y - *textBox\obj\cbox\top
          *rp.RastPort = ntui_ObtainRastPort{*textBox}
          _tb_MouseDrag{*textBox,*rp,ox,oy}
          If *rp Then ntui_ReleaseRastPort{*textBox}
          done=True
;          str_Dup{&*tuiEvent\notifyID,*textBox\obj\onMove}
        End If
      End If

    Case #TUIEV_KEYDOWN
      *rp.RastPort = ntui_ObtainRastPort{*textBox}
      done = _ntui_KeyStrokeTextBox{*textBox.tuiTextBox,*tuiEvent.tuiEvent,*rp}
      If *rp Then ntui_ReleaseRastPort{*textBox}

    Case #TUIEV_TICK
      *rp.RastPort = ntui_ObtainRastPort{*textBox}
      ntui_SetClip{*rp,*textBox\obj\cbox}
      _tb_DoBlink{*textBox,*rp,1}
      ntui_RemClip{*rp}
      If *rp Then ntui_ReleaseRastPort{*textBox}

    Case #TUIEV_HSCROLL
      If *textBox\maxLines>1
        _ntui_SetTextBoxAttr{*textBox,#TUITBA_LEFTOFFSET,*textBox\leftOffset + *textBox\step_\x * *tuiEvent\value }
        done = True
      End If

    Case #TUIEV_VSCROLL
      If *textBox\maxLines>1
        _ntui_SetTextBoxAttr{*textBox,#TUITBA_TOPLINE,*textBox\topLine + *textBox\step_\y * *tuiEvent\value }
        done = True
      End If

    Case #TUIEV_BIND_HDELTA
      If *textBox\maxLines>1
        *rp.RastPort = ntui_ObtainRastPort{*textBox}
        _tb_Scroll{*textBox,*textBox\step_\x * *tuiEvent\value, 0, *rp}
        If *rp Then ntui_ReleaseRastPort{*textBox}
        done = True
      End If

    Case #TUIEV_BIND_VDELTA
      If *textBox\maxLines>1
        *rp.RastPort = ntui_ObtainRastPort{*textBox}
        _tb_Scroll{*textBox,0,*textBox\step_\y * *tuiEvent\value,*rp}
        If *rp Then ntui_ReleaseRastPort{*textBox}
        done = True
      End If

    Case #TUIEV_BIND_HVALUE
      If *textBox\maxLines>1
        *rp.RastPort = ntui_ObtainRastPort{*textBox}
        _tb_Scroll{*textBox,*tuiEvent\value-*textBox\leftOffset,0,*rp}
        If *rp Then ntui_ReleaseRastPort{*textBox}
        done = True
      End If

    Case #TUIEV_BIND_VVALUE
      If *textBox\maxLines>1
        *rp.RastPort = ntui_ObtainRastPort{*textBox}
        _tb_Scroll{*textBox,0,*tuiEvent\value-*textBox\topLine,*rp}
        If *rp Then ntui_ReleaseRastPort{*textBox}
        done = True
      End If

    Case #TUIEV_PROPAGATE
      If *textBox\maxLines>1
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_VTOTAL  ,*textBox\totalLines   ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_VVALUE  ,*textBox\topLine      ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_VVISIBLE,*textBox\visibleLines ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_VSTEP   ,*textBox\step_\y      ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_HTOTAL  ,*textBox\totalWidth   ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_HVALUE  ,*textBox\leftOffset   ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_HVISIBLE,*textBox\visibleWidth ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_HSTEP   ,*textBox\step_\x      ,Null}
        done=True
      End If

    Default
      done = False
End Select

  If done
    If (*tuiEvent\notifyID)
      *tuiEvent\tuiObject = *textBox
      _ntui_QueueEvent{*textBox\obj\tuiEngine\outQ,*tuiEvent}
    Else
      _ntui_DestroyEvent{*tuiEvent}
    End If
  End If

Function Return done
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_DrawTextBox {*textBox.tuiTextBox,*rp.RastPort}              /
;/                                                                             /
;/ Description:                                                                /
;/       ; ....                                                                /
;/ * draw the button in all its beauty */                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
_ntui_DrawTextBox:
Statement _ntui_DrawTextBox{*textBox.tuiTextBox,*rp.RastPort,*rpclip.tuiRect}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

  *tuiEngine.tuiEngine = *textBox\obj\tuiEngine
  !_ASSERT{*tuiEngine}
  !_ASSERT{*rp}

  !tuiAndRect{bclip.tuiRect,*textBox\obj\bbox,*rpclip}
  If !tuiValidRect{bclip}=False Then Statement Return

  If (*textBox\obj\borderType><#TUIBORDER_NONE)
    bgDone.l = ntui_DrawBorder{*tuiEngine,*rp,*textBox\obj\bbox,*textBox\obj\borderType,*textBox\obj\flags}
  Else
    bgDone = False
  End If

    If *textBox\hScroller
      If (*textBox\hScroller\obj\flags&#TUIF_ONSCREEN) Then _ntui_Draw{*textBox\hScroller,*rp,*rpclip}
    End If
    If *textBox\vScroller
      If (*textBox\vScroller\obj\flags&#TUIF_ONSCREEN) Then _ntui_Draw{*textBox\vScroller,*rp,*rpclip}
    End If
    If *textBox\funcButton
      If (*textBox\funcButton\obj\flags&#TUIF_ONSCREEN) Then _ntui_Draw{*textBox\funcButton,*rp,*rpclip}
    End If


  !tuiAndRect{iclip.tuiRect,*rpclip,*textBox\obj\ibox}
  If !tuiValidRect{iclip}=False Then Statement Return

  If *textBox\tuiPen[#TUITBPEN_BG]><#TUIPEN_TRANSPARENT AND bgDone=False
    CNIF #TUI_DEBUG
    SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_GREEN]
    CELSE
    SetAPen_ *rp,*tuiEngine\pen[*textBox\tuiPen[#TUITBPEN_BG]]
    CEND
    !tuiAndRect{iclip.tuiRect,*textBox\obj\ibox,*rpclip}
    If !tuiValidRect{iclip}
      RectFill_ *rp,iclip\left,iclip\top,iclip\right,iclip\bottom
    End If
  End If


  !tuiAndRect{cclip.tuiRect,*rpclip,*textBox\obj\cbox}
  If !tuiValidRect{cclip}=False Then Statement Return

  x1.l = cclip\left
  x2.l = cclip\right
  y1.l = cclip\top
  y2.l = cclip\bottom

  Select *textBox\subTypeID
    Case #TUITB_TEXTBOX
      _tb_DoBlink{*textBox,*rp,Off}
      SetAPen_ *rp,*tuiEngine\pen[#TUIPEN_SHADOW]
      x.l =  *textBox\obj\cbox\right+1
      ;Move_ *rp,x,y1 : Draw_ *rp,x,y2
      _ntui_DrawTextBoxIntern{*textBox,x1,y1,x2,y2,*rp}
      If (*textBox\obj\flags&#TUIF_FOCUS) Then _tb_DoBlink{*textBox,*rp,On}

    Default
      _tb_DoBlink{*textBox,*rp,Off}
      _ntui_DrawTextBoxIntern{*textBox,x1,y1,x2,y2,*rp}
      If (*textBox\obj\flags&#TUIF_FOCUS) _tb_DoBlink{*textBox,*rp,On}

  End Select

End Statement

_ntui_LayoutTextBox:
Statement _ntui_LayoutTextBox{*textBox.tuiTextBox,*rp.RastPort,*bbox.tuiRect}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

  *tui.tuiObject = *textBox
  *tuiEngine.tuiEngine = *textBox\obj\tuiEngine
  !_ASSERT{*tuiEngine}
  !_ASSERT{*rp}

  If *bbox
    !tuiCopyRect{*tui\bbox,*bbox}
  End If
  _ntui_GetBorderSize{*tui\tuiEngine,*tui\borderType,*tui\flags,*tui\border}
  !tuiRemBorder{*tui\ibox,*tui\bbox,*tui\border}
  !tuiRemBorder{*tui\cbox,*tui\ibox,*tui\padding}

  If (*textBox\fontstolen OR *textBox\font=Null)
    *textBox\fontstolen                = True
    tuifont.l = _ntui_SetFont{*tuiEngine,*textBox\obj\flags}
    *textBox\font                      = *tuiEngine\font[tuifont]
    *textBox\space_width               = *textBox\font\tf_XSize-1
    *textBox\rowheight                 = *textBox\font\tf_YSize
  End If

  If *textBox\vScroller
    xs.l = *textBox\vScroller\obj\minsize\x
    !tuiCopyRect{sbox.tuiRect,*tui\ibox}
    *tui\ibox\right - xs
    *tui\cbox\right = *tui\ibox\right
    sbox\left  = *tui\cbox\right +1

    If *textBox\funcButton
      ys.l = *textBox\hScroller\obj\minsize\y
      !tuiCopyRect{fbox.tuiRect,sbox}
      sbox\bottom - ys
      fbox\top    = sbox\bottom+1
      _ntui_Layout{*textBox\funcButton,*rp,fbox}
    End If

    _ntui_Layout{*textBox\vScroller,*rp,sbox}
  End If

  If *textBox\hScroller
    ys.l = *textBox\hScroller\obj\minsize\y
    !tuiCopyRect{sbox.tuiRect,*tui\ibox}
    *tui\ibox\bottom - ys
    *tui\cbox\bottom = *tui\ibox\bottom
    sbox\top  = *tui\cbox\bottom +1
    _ntui_Layout{*textBox\hScroller,*rp,sbox}
  End If

  *textBox\visibleLines = !tuiRectHeight{*tui\cbox} /*textBox\rowheight
  *textBox\visibleWidth = !tuiRectWidth{*tui\cbox}

  If *textBox\vScroller Then _ntui_UpdateScroller{*textBox\vScroller,*textBox\topLine,*textBox\visibleLines,*textBox\totalLines,1,False}
  If *textBox\hScroller Then _ntui_UpdateScroller{*textBox\hScroller,*textBox\leftOffset,*textBox\visibleWidth,*textBox\totalWidth,1,False}
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_GetTextBoxMinSize {*textBox.tuiTextBox,*rp.Ra:: /
;/ stPort}                                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * calculate the minimum size for the button */                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
_ntui_CalculateTextBoxMinSize:
Function.l _ntui_CalculateTextBoxMinSize{*textBox.tuiTextBox,*rp.RastPort}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

*tuiEngine.tuiEngine = *textBox\obj\tuiEngine : If *tuiEngine=Null OR *rp=Null Then Function Return *textBox\obj\minsize

If (*textBox\fontstolen OR *textBox\font=Null)
  tuifont.l                             = _ntui_SetFont{*tuiEngine,*textBox\obj\flags}
  *textBox\font                      = *tuiEngine\font[tuifont]
  *textBox\fontstolen                = True
  *textBox\space_width               = *textBox\font\tf_XSize-1
  *textBox\rowheight                 = *textBox\font\tf_YSize
End If

For n.l=0 To #TUITBPEN_MAX -1
  If *textBox\tuiPen[n]      >=0 Then *textBox\pen[n]       = *tuiEngine\pen[*textBox\tuiPen[n]]
  If *textBox\tuiPenSelect[n]>=0 Then *textBox\penSelect[n] = *tuiEngine\pen[*textBox\tuiPenSelect[n]]
Next

If *textBox\vScroller Then _ntui_CalculateScrollerMinSize{*textBox\vScroller,*rp}
If *textBox\hScroller Then _ntui_CalculateScrollerMinSize{*textBox\hScroller,*rp}

Select *textBox\subTypeID
  Case #TUITB_TEXTBOX
    minlines.l = *textBox\maxLines
    If minlines>3 Then minlines=3
    *textBox\obj\minsize\x  + *textBox\rowheight * minlines
    *textBox\obj\minsize\y  + *textBox\rowheight * minlines

  Default
    If *textBox\obj\flags&(#TUIF_SMALL|#TUIF_SERIF|#TUIF_FIX)
      *textBox\obj\minsize\y  = *tuiEngine\defSize[#TUISIZE_BUTTON]
    Else
      *textBox\obj\minsize\y  = *tuiEngine\defSize[#TUISIZE_BUTTON]
    End If
    ;*textBox\obj\minsize\y = *textBox\rowheight
    *textBox\obj\minsize\x = *textBox\obj\minsize\y ; *textBox\font\tf_YSize

End Select

*textBox\obj\minsize\x + !tuiBorderWidth{*textBox\obj\padding}
*textBox\obj\minsize\y + !tuiBorderHeight{*textBox\obj\padding}

_ntui_GetBorderSize{*tuiEngine,*textBox\obj\borderType,*textBox\obj\flags,*textBox\obj\border}
*textBox\obj\minsize\x + !tuiBorderWidth{*textBox\obj\border}
*textBox\obj\minsize\y + !tuiBorderHeight{*textBox\obj\border}


Function Return *textBox\obj\minsize
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ntui_FreeTextBox {*textBox.tuiTextBox}                          /
;/                                                                             /
;/ Description:                                                                /
;/    ted_tokenize {*ted ,lpos}                                                /
;/ undo_Flush{\undo}                                                           /
;/ undo_SetSaved{\undo}                                                        /
;/ * free everything special that we allocated for the button */               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
_ntui_DeinitTextBox:
Statement _ntui_DeinitTextBox{*textBox.tuiTextBox}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

  If \doc
    _tb_FreeText{*textBox}
    FreeVec_ \doc
    \allocLines=0
    \doc = Null
  End If
  ;If \undo Then undo_Free{\undo} : \undo = Null
  If \fontstolen = False AND \font><Null Then CloseFont_ \font
  \font = Null

End Statement


Function.l _ntui_PlainTextBox{maxLines.l,@help.s,@flags.l,@nameID.s}
If (flags=#TUI_NOFLAGS) Then flags=0
*textBox.tuiTextBox = _ntui_CreateObject{#TUICLASS_TEXTBOX,SizeOf.tuiTextBox,help,flags,nameID}
If *textBox
  *textBox\maxChars                     = 32767
  *textBox\maxLines                     = maxLines

  For n.l=0 To #TUITBPEN_MAX -1
    *textBox\tuiPen[n]       =-1
    *textBox\pen[n]          = 0
    *textBox\tuiPenSelect[n] =-1
    *textBox\penSelect[n]    = 0
  Next

  For n.l=0 To 255 ; accpet all ASCII characters
    *textBox\validChar[n]=True
  Next

  *textBox\step_\x = *textBox\obj\tuiEngine\defStep\x
  *textBox\step_\y = 1

  *textBox\tuiPen[#TUITBPEN_BG]      = #TUIPEN_BG
  *textBox\tuiPen[#TUITBPEN_Text]    = #TUIPEN_TEXT
  *textBox\tuiPen[#TUITBPEN_Focus]   = #TUIPEN_BG
  *textBox\tuiPen[#TUITBPEN_NoFocus] = #TUIPEN_BG

  *textBox\tuiPenSelect[#TUITBPEN_BG]      = #TUIPEN_MARKER
  *textBox\tuiPenSelect[#TUITBPEN_Text]    = #TUIPEN_ACTIVETEXT
  *textBox\tuiPenSelect[#TUITBPEN_Focus]   = #TUIPEN_MARKER
  *textBox\tuiPenSelect[#TUITBPEN_NoFocus] = #TUIPEN_HALFMARKER

  *textBox\font                         = Null
  *textBox\fontstolen                   = True
  *textBox\space_width                  = 8
  *textBox\rowheight                    = 8
  *textBox\doc                          = Null
  *textBox\edflags                      = #TUITBF_NotePad|#TUITBF_LINECURSOR;|#TUITBF_SHOWCR ;|#TUITBF_BLOCKSELECT;
  *textBox\blink_speed                  = 5
  *textBox\obj\borderType               = #TUIBORDER_RECESSED
  *textBox\leftOffset                   = 0
  *textBox\topLine                      = 0
  *textBox\obj\pointerID                = #TUIPOINTER_TEXT
  *textBox\selection_begin_lpos = -1
  *textBox\selection_end_lpos =-1

  !_GetFuncPointer{*textBox\obj\Draw            ,_ntui_DrawTextBox,{0,0,0}}
  !_GetFuncPointer{*textBox\obj\Layout          ,_ntui_LayoutTextBox,{0,0,0}}
  !_GetFuncPointer{*textBox\obj\DispatchEvent   ,_ntui_DispatchTextBoxEvent,{0,0}}
  !_GetFuncPointer{*textBox\obj\CalculateMinSize,_ntui_CalculateTextBoxMinSize,{0,0}}
  !_GetFuncPointer{*textBox\obj\Deinit          ,_ntui_DeinitTextBox,{0}}
  !_GetFuncPointer{*textBox\obj\SetAttr         ,_ntui_SetTextBoxAttr,{0,0,0}}
  !_GetFuncPointer{*textBox\obj\GetAttr         ,_ntui_GetTextBoxAttr,{0,0,0}}

End If
Function Return *textBox
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_TextBox {string.s,maxLines.l,@notify.l,@help.s,@f:: /
;/ lags.l,@userID.l}                                                           /
;/                                                                             /
;/ Description:                                                                /
;/ * create function for tui String */                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - string.s    : ???                                                         /
;/ - maxLines.l    : ???                                                       /
;/ - notify.l    : ???                                                         /
;/ - help.s    : ???                                                           /
;/ - flags.l    : ???                                                          /
;/ - userID.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ntui_TextBox{initialText.s,maxLines.l,@help.s,@flags.l,@nameID.s}
If (flags=#TUI_NOFLAGS) Then flags=0
flags | #TUIF_CENTER|#TUIF_MIDDLE|#TUIF_WANTMOVER|#TUIF_WANTTAB
*textBox.tuiTextBox = _ntui_PlainTextBox{maxLines,help,flags,nameID}
If *textBox
  *textBox\maxChars                        = 32767
  *textBox\maxLines                        = maxLines

  *textBox\subTypeID                       = #TUITB_TEXTBOX
  *textBox\tuiPen[#TUITBPEN_BG]            = #TUIPEN_WHITE
  *textBox\tuiPen[#TUITBPEN_Focus]         = #TUIPEN_WHITE
  *textBox\tuiPen[#TUITBPEN_NoFocus]       = #TUIPEN_WHITE
  *textBox\tuiPen[#TUITBPEN_DisabledBG]    = #TUIPEN_HALFSHINE
  *textBox\tuiPen[#TUITBPEN_EnabledFG]     = #TUIPEN_TEXT
  *textBox\tuiPen[#TUITBPEN_DisabledFG]    = #TUIPEN_HALFSHADOW
  *textBox\tuiPen[#TUITBPEN_Text]          = #TUIPEN_TEXT
  *textBox\tuiPenSelect[#TUITBPEN_BG]      = #TUIPEN_MARKER
  *textBox\tuiPenSelect[#TUITBPEN_Focus]   = #TUIPEN_MARKER
  *textBox\tuiPenSelect[#TUITBPEN_NoFocus] = #TUIPEN_HALFMARKER
  *textBox\tuiPenSelect[#TUITBPEN_Text]    = #TUIPEN_ACTIVETEXT
  *textBox\font                            = Null
  *textBox\fontstolen                      = True
  *textBox\space_width                     = 8
  *textBox\rowheight                       = 8
  *textBox\doc                             = Null
  *textBox\edflags                         = #TUITBF_NotePad|#TUITBF_LINECURSOR;|#TUITBF_SHOWCR ;|#TUITBF_BLOCKSELECT;
  *textBox\blink_speed                     = 5
  *textBox\obj\borderType                  = #TUIBORDER_RECESSED
  *textBox\leftOffset                      = 0
  *textBox\topLine                         = 0

  ntui_SetTextBoxText{*textBox,&initialText,FLen(initialText),Null}

  ;tuiGlobal\buildHelper\tuiParent          = *textBox
  ;tuiGlobal\buildHelper\tuiPrev            = Null
  *textBox\obj\pointerID = #TUIPOINTER_TEXT

  _ntui_BeginChildren{*textBox}

  *textBox\vScroller    = ntui_VScroller{*textBox\topLine,*textBox\totalLines,*textBox\visibleLines}
  If *textBox\vScroller
    ntui_AddArrows{Null}
    *textBox\vScroller\obj\borderType=#TUIBORDER_NONE
  End If

  *textBox\hScroller    = ntui_HScroller{*textBox\leftOffset,*textBox\totalWidth,*textBox\visibleWidth}
  If *textBox\hScroller
    ntui_AddArrows{Null}
    *textBox\hScroller\obj\borderType=#TUIBORDER_NONE
  End If

  ;*textBox\funcButton   = ntui_FunctionButton{#TUIBUTTON_SAVE}

  _ntui_EndChildren{#TUICLASS_TEXTBOX}

  If (*textBox\vScroller) Then ntui_Bind{*textBox,*textBox\vScroller}
  If (*textBox\hScroller) Then ntui_Bind{*textBox,*textBox\hScroller}

End If
Function Return *textBox
End Function


Function.l ntui_WriteConsole{*con.tuiTextBox,textP.l}
If textP=Null Then Function Return False
appendLine.l = *con\totalLines
_tb_Insert{*con,appendLine,0,textP,-1}
Function Return True
End Function


Function.l ntui_Console{initialText.s,maxLines.l,@help.s,@flags.l,@nameID.s}
If (flags=#TUI_NOFLAGS) Then flags=0
flags | #TUIF_CENTER|#TUIF_MIDDLE|#TUIF_WANTMOVER|#TUIF_WANTTAB
*textBox.tuiTextBox = _ntui_PlainTextBox{maxLines,help,flags,nameID}
If *textBox
  *textBox\maxChars                     = 32767
  *textBox\maxLines                     = maxLines

  *textBox\subTypeID                    = #TUITB_CONSOLE
  *textBox\tuiPen[#TUITBPEN_BG]         = #TUIPEN_BACKGROUND
  *textBox\tuiPen[#TUITBPEN_Focus]      = #TUIPEN_BACKGROUND
  *textBox\tuiPen[#TUITBPEN_NoFocus]    = #TUIPEN_BACKGROUND
  *textBox\tuiPen[#TUITBPEN_DisabledBG] = #TUIPEN_HALFSHADOW
  *textBox\tuiPen[#TUITBPEN_EnabledFG]  = #TUIPEN_TEXT
  *textBox\tuiPen[#TUITBPEN_DisabledFG] = #TUIPEN_SHADOW
  *textBox\tuiPen[#TUITBPEN_Text]       = #TUIPEN_TEXT
  *textBox\tuiPenSelect[#TUITBPEN_BG]   = #TUIPEN_MARKER
  *textBox\tuiPenSelect[#TUITBPEN_Text] = #TUIPEN_ACTIVETEXT
  *textBox\font                         = Null
  *textBox\fontstolen                   = True
  *textBox\space_width                  = 8
  *textBox\rowheight                    = 8
  *textBox\doc                          = Null
  *textBox\edflags                      = #TUITBF_NotePad|#TUITBF_LINECURSOR|#TUITBF_SHOWCR|#TUITBF_READONLY
  *textBox\blink_speed                  = -1
  *textBox\obj\borderType               = #TUIBORDER_RECESSED
  *textBox\leftOffset                   = 0
  *textBox\topLine                      = 0

  ntui_SetTextBoxText{*textBox,&initialText,FLen(initialText),Null}

  *textBox\obj\pointerID = #TUIPOINTER_TEXT

  _ntui_BeginChildren{*textBox}

  *textBox\vScroller    = ntui_VScroller{*textBox\topLine,*textBox\totalLines,*textBox\visibleLines}
  If *textBox\vScroller
    ntui_AddArrows{Null}
    *textBox\vScroller\obj\borderType=#TUIBORDER_NONE
  End If

  *textBox\hScroller    = ntui_HScroller{*textBox\leftOffset,*textBox\totalWidth,*textBox\visibleWidth}
  If *textBox\hScroller
    ntui_AddArrows{Null}
    *textBox\hScroller\obj\borderType=#TUIBORDER_NONE
  End If

  _ntui_EndChildren{#TUICLASS_TEXTBOX}

  If (*textBox\vScroller) Then ntui_Bind{*textBox,*textBox\vScroller}
  If (*textBox\hScroller) Then ntui_Bind{*textBox,*textBox\hScroller}


End If
Function Return *textBox
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_String {string.s,maxChars.l,@notify.l,@help.s,@fl:: /
;/ ags.l,@userID.l}                                                            /
;/                                                                             /
;/ Description:                                                                /
;/ * create function for tui String */                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - string.s    : ???                                                         /
;/ - maxChars.l    : ???                                                       /
;/ - notify.l    : ???                                                         /
;/ - help.s    : ???                                                           /
;/ - flags.l    : ???                                                          /
;/ - userID.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ntui_String{string.s,maxChars.l,@help.s,@flags.l,@nameID.s}
If (flags=#TUI_NOFLAGS) Then flags=0
flags | #TUIF_CENTER|#TUIF_MIDDLE |#TUIF_FIXHEIGHT|#TUIF_WANTMOVER
*textBox.tuiTextBox = _ntui_PlainTextBox{1,help,flags,nameID}
If *textBox
  *textBox\maxChars                     = maxChars
  *textBox\maxLines                     = 1
  *textBox\subTypeID                    = #TUITB_STRING
  *textBox\leftOffset                   = 0
  *textBox\topLine                      = 0
  *textBox\tuiPen[#TUITBPEN_Focus]      = #TUIPEN_HALFSHINE
  *textBox\tuiPen[#TUITBPEN_NoFocus]    = #TUIPEN_BACKGROUND
  *textBox\tuiPen[#TUITBPEN_Text]       = #TUIPEN_TEXT
  *textBox\tuiPenSelect[#TUITBPEN_BG]   = #TUIPEN_MARKER
  *textBox\tuiPenSelect[#TUITBPEN_Text] = #TUIPEN_ACTIVETEXT
  *textBox\tuiPen[#TUITBPEN_DisabledBG] = #TUIPEN_BACKGROUND
  *textBox\tuiPen[#TUITBPEN_EnabledFG]  = #TUIPEN_TEXT
  *textBox\tuiPen[#TUITBPEN_DisabledFG] = #TUIPEN_SHADOW
  *textBox\obj\pointerID                = #TUIPOINTER_TEXT
  *textBox\font                         = Null
  *textBox\fontstolen                   = True
  *textBox\space_width                  = 8
  *textBox\rowheight                    = 8
  *textBox\doc                          = Null
  *textBox\edflags                      = #TUITBF_String|#TUITBF_LINECURSOR
  *textBox\blink_speed                  = 5
  *textBox\obj\borderType               = #TUIBORDER_STRING

  ntui_SetTextBoxText{*textBox,&string,FLen(string),Null}

End If
Function Return *textBox
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_EditLabel {string.s,maxChars.l,bgTuiPen.l,@notify:: /
;/ .l,@help.s,@flags.l,@userID.l}                                              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - string.s    : ???                                                         /
;/ - maxChars.l    : ???                                                       /
;/ - bgTuiPen.l    : ???                                                       /
;/ - notify.l    : ???                                                         /
;/ - help.s    : ???                                                           /
;/ - flags.l    : ???                                                          /
;/ - userID.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ntui_EditLabel{string.s,maxChars.l,bgTuiPen.l,@help.s,@flags.l,@nameID.s}
*textBox.tuiTextBox = ntui_String{string,maxChars,help,flags,nameID}
If *textBox
  *textBox\tuiPen[#TUITBPEN_Focus]      = bgTuiPen
  *textBox\tuiPen[#TUITBPEN_NoFocus]    = bgTuiPen
  *textBox\tuiPen[#TUITBPEN_DisabledBG] = bgTuiPen
  *textBox\obj\borderType               = #TUIBORDER_NONE
End If
Function Return *textBox
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_NumString {value.l,minValue.l,maxValue.l,@notify.:: /
;/ l,@help.s,@flags.l,@userID.l}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * create function for tui String */                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - value.l    : ???                                                          /
;/ - minValue.l    : ???                                                       /
;/ - maxValue.l    : ???                                                       /
;/ - notify.l    : ???                                                         /
;/ - help.s    : ???                                                           /
;/ - flags.l    : ???                                                          /
;/ - userID.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ntui_NumString{value.l,minValue.l,maxValue.l,@help.s,@flags.l,@nameID.s}
If minValue>maxValue Then Exchange minValue,maxValue
If value<minValue Then value=minValue
If value>maxValue Then value=maxValue
string.s =  Str$(value)
*textBox.tuiTextBox = ntui_String{string,16,help,flags,nameID}
If *textBox
  *textBox\subTypeID                 = #TUITB_STRING_NUMERIC
  *textBox\numMin                    = minValue
  *textBox\numMax                    = maxValue
  *textBox\obj\value                 = value
  ntui_SetValidTextBoxChars{*textBox,"0123456789+-"}
End If
Function Return *textBox
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_NumEditLabel {value.l,minValue.l,maxValue.l,bgTui:: /
;/ Pen.l,@notify.l,@help.s,@flags.l,@userID.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - value.l    : ???                                                          /
;/ - minValue.l    : ???                                                       /
;/ - maxValue.l    : ???                                                       /
;/ - bgTuiPen.l    : ???                                                       /
;/ - notify.l    : ???                                                         /
;/ - help.s    : ???                                                           /
;/ - flags.l    : ???                                                          /
;/ - userID.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ntui_NumEditLabel{value.l,minValue.l,maxValue.l,bgTuiPen.l,@help.s,@flags.l,@nameID.s}
*textBox.tuiTextBox = ntui_NumString{value,minValue,maxValue,help,flags,nameID}
If *textBox
  *textBox\obj\borderType               = #TUIBORDER_NONE
  *textBox\tuiPen[#TUITBPEN_Focus]      = bgTuiPen
  *textBox\tuiPen[#TUITBPEN_NoFocus]    = bgTuiPen
  *textBox\tuiPen[#TUITBPEN_DisabledBG] = bgTuiPen
End If
Function Return *textBox
End Function




