; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "RAM:"
; ExeFile         = "Prog.exe"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 8192
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 37
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 32768
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 1
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 546
; CursorColumn    = 8
; LabelSearch     = "triml"
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 20
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 20
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: ntui_textbox.include                                                  /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 06/01/2009                                                            /
;/                                                                             /
;/ Author: <unknown>                                                           /
;/                                                                             /
;/ Requirements:  Amiblitz3                                                    /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Extend AB3 functionality.                                                   /
;/ * no description available *                                                /
;/                                                                             /
;/ Abstract:                                                                   /
;/ * no abstract available *                                                   /
;/                                                                             /
;/ User Constants:                                                             /
;/ #max_objects   = n                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
#TUI_HAS_TEXTBOX = 1

#ASCII_CR = 13
#ASCII_LF = 10

;/* ntui TextBox Sub-Types */
#TUITB_TEXTBOX            = 0 ; multiline textbox
#TUITB_STRING             = 1 ; single line string gadget
#TUITB_STRING_NUMERIC     = 2 ; single line numeric gadget
#TUITB_STRING_PASSWORD    = 3 ; sinle line string gadget with password style
#TUITB_STRING_FILE        = 4 ; string gadget with file ASL
#TUITB_STRING_PATH        = 5 ; string gadget with path ASL
#TUITB_STRING_FONT        = 6 ; string gadget with font ASL
#TUITB_STRING_SCREEN      = 7 ; string gadget with screen ASL
#TUITB_CONSOLE            = 8

;/* ntui TextBox Attributes */
#TUITBA_BASE               = #TUIA_USER
#TUITBA_CURSORLINE         = #TUITBA_BASE +  0; rw
#TUITBA_CURSORCHAR         = #TUITBA_BASE +  1; rw
#TUITBA_BEGINSELECTLINE    = #TUITBA_BASE +  2; rw
#TUITBA_BEGINSELECTCHAR    = #TUITBA_BASE +  3; rw
#TUITBA_ENDSELECTLINE      = #TUITBA_BASE +  4; rw
#TUITBA_ENDSELECTCHAR      = #TUITBA_BASE +  5; rw
#TUITBA_TBFLAGS            = #TUITBA_BASE +  6; rw
#TUITBA_SETTBFLAGS         = #TUITBA_BASE +  7;  w
#TUITBA_CLEARTBFLAGS       = #TUITBA_BASE +  8;  w
#TUITBA_BLINKSPEED         = #TUITBA_BASE +  9; rw
#TUITBA_ROWHEIGHT          = #TUITBA_BASE + 10; r
#TUITBA_SPACEWIDTH         = #TUITBA_BASE + 11; r
#TUITBA_TABWIDTH           = #TUITBA_BASE + 12; rw
#TUITBA_VISIBLELINES       = #TUITBA_BASE + 13; r
#TUITBA_TOTALLINES         = #TUITBA_BASE + 14; r
#TUITBA_TOPLINE            = #TUITBA_BASE + 15; rw
#TUITBA_VISIBLEWIDTH       = #TUITBA_BASE + 16; r
#TUITBA_TOTALWIDTH         = #TUITBA_BASE + 17; r
#TUITBA_LEFTOFFSET         = #TUITBA_BASE + 18; rw
#TUITBA_MAXCHARS           = #TUITBA_BASE + 19; rw
#TUITBA_MAXLINES           = #TUITBA_BASE + 20; rw
#TUITBA_FONT               = #TUITBA_BASE + 21; rw
#TUITBA_LINE               = #TUITBA_BASE + 22; rw
#TUITBA_LINELENGTH         = #TUITBA_BASE + 23; r
#TUITBA_SELECTION          = #TUITBA_BASE + 24; rw
#TUITBA_READONLY           = #TUITBA_BASE + 25; rw
#TUITBA_ONCHANGE           = #TUITBA_BASE + 26; rw
#TUITBA_ONCHANGECB         = #TUITBA_BASE + 27; rw
#TUITBA_ONKEY              = #TUITBA_BASE + 28; rw
#TUITBA_ONKEYCB            = #TUITBA_BASE + 29; rw
#TUITBA_ONCURSOR           = #TUITBA_BASE + 30; rw
#TUITBA_ONCURSORCB         = #TUITBA_BASE + 31; rw
#TUITBA_ONEDIT             = #TUITBA_BASE + 32; rw
#TUITBA_ONEDITCB           = #TUITBA_BASE + 33; rw
#TUITBA_TEXT               = #TUIA_STRING ; rw
#TUITBA_NUMBER             = #TUIA_VALUE
#TUITBA_SUBCLASSID         = #TUITBA_BASE + 34; rw
#TUITBA_SCROLLERMODE       = #TUITBA_BASE + 35
#TUITBA_FILENAME           = #TUITBA_BASE + 36
#TUITBA_EDITED             = #TUITBA_BASE + 37
#TUITBA_UNDO               = #TUITBA_BASE + 38
#TUITBA_HINT               = #TUITBA_BASE + 39
#TUITBA_STYLECB            = #TUITBA_BASE + 40
#TUITBA_ONFILELISTENERCLOSE   = #TUITBA_BASE + 41; rw
#TUITBA_ONFILELISTENERCLOSECB = #TUITBA_BASE + 42; rw
#TUITBA_APPENDTEXT         = #TUITBA_BASE + 43
#TUITBA_LOADFILE           = #TUITBA_BASE + 44
#TUITBA_ONSUBMIT           = #TUITBA_BASE + 45; rw
#TUITBA_ONSUBMITCB         = #TUITBA_BASE + 46; rw
#TUITBA_AUTOINDENT         = #TUITBA_BASE + 47; rw
#TUITBA_UNDOSTEPS          = #TUITBA_BASE + 48; rw
#TUITBA_NUMBEROFCHANGES    = #TUITBA_BASE + 49; rw
#TUITBA_DEFAULTSHORTCUTS   = #TUITBA_BASE + 50; rw
#TUITBA_ONCLICK            = #TUITBA_BASE + 51; rw
#TUITBA_ONCLICKCB          = #TUITBA_BASE + 52; rw
#TUITBA_ONPOSTKEY          = #TUITBA_BASE + 53; rw
#TUITBA_ONPOSTKEYCB        = #TUITBA_BASE + 54; rw
#TUITBA_CURSORSTYLE        = #TUITBA_BASE + 55; rw

; ntui TextBox Cursor Styles
#TUITBCS_BLOCK      = 0
#TUITBCS_LINE       = 1
#TUITBCS_BOLDLINE   = 2
#TUITBCS_UNDERSCORE = 3

;/* ntui TextBox Flags */
#TUITBF_LEFTWRAP              = $00000001
#TUITBF_RIGHTWRAP             = $00000002
#TUITBF_LOOSESELECTION        = $00000004 ; selection gets lost of mouse move or key press
#TUITBF_DELWRAP               = $00000008 ; join lines on left delete
#TUITBF_REMWRAP               = $00000010 ; join lines on right remove
#TUITBF_DRAGCURSOR            = $00000020 ; cursor is dragged and set to end of selection
#TUITBF_HIDECURSORONSELECT    = $00000040 ; cursor is hidden whenselection is done
#TUITBF_SHIFTSELECT           = $00000080 ; allow to select with shift key pressed
#TUITBF_RETURNBREAK           = $00000200 ; return breaks the line
#TUITBF_BACKUP                = $00000400
#TUITBF_AUTOINDENT            = $00000800 ; set spaces according the top line
#TUITBF_REDRAWONSCROLL        = $00002000 ; scroll through complete re-draw
#TUITBF_TRIMWHITESPACES       = $00004000 ; time trailing white spaces
#TUITBF_READONLY              = $00008000 ; read only text box, curosr is there, but no edit
#TUITBF_REALTAB               = $00040000 ; tab is treated as tab, not N spaces
#TUITBF_WANTRETURN            = $00080000 ; return creates a new line
#TUITBF_SELECTONFOCUS         = $00100000 ; when textbox gains focus, the entire text is selected
#TUITBF_LOOSESELECTIONONFOCUS = $00200000 ; when textbox gains focus, selection is lost
#TUITBF_WANTTAB               = $00400000 ; tab is inserted in text, otherwise may jump to next gui item
#TUITBF_BLOCKSELECT           = $00800000
#TUITBF_SHOWCR                = $01000000 ; show carriage return code
#TUITBF_DEFAULTSHORTCUTS      = $02000000
#TUITBF_SHOWBRACKETS          = $04000000

#TUITBF_Default    = #TUITBF_DEFAULTSHORTCUTS|#TUITBF_SHIFTSELECT|#TUITBF_LOOSESELECTION|#TUITBF_REALTAB|#TUITBF_HIDECURSORONSELECT|#TUITBF_LEFTWRAP|#TUITBF_RIGHTWRAP|#TUITBF_DRAGCURSOR|#TUITBF_SHOWBRACKETS
#TUITBF_NotePad    = #TUITBF_Default|#TUITBF_DELWRAP|#TUITBF_REMWRAP|#TUITBF_RETURNBREAK|#TUITBF_WANTRETURN|#TUITBF_WANTTAB
#TUITBF_String     = #TUITBF_Default|#TUITBF_SELECTONFOCUS|#TUITBF_SHOWCR
#TUITBF_Ped        = #TUITBF_WANTRETURN|#TUITBF_RETURNBREAK|#TUITBF_DEFAULTSHORTCUTS
#TUITBF_Message    = #TUITBF_Default|#TUITBF_READONLY
#TUITBF_Console    = #TUITBF_Default|#TUITBF_WANTRETURN

;/* ntui TextBox Pens */
#TUITBPEN_BG              =  0 ; pen for background
#TUITBPEN_TEXT            =  1 ; pen for normal text
#TUITBPEN_MARKER          =  2
#TUITBPEN_TOKEN           =  3 ; pen for Tokens
#TUITBPEN_NUMBER          =  4 ; pen for numeric values
#TUITBPEN_TYPE            =  5 ; pen for structs
#TUITBPEN_CONSTANT        =  6 ; pen for constants/macros
#TUITBPEN_COMMENT         =  7 ; pen for comments
#TUITBPEN_MACRO           =  8 ; pen for macros
#TUITBPEN_MEMBER          =  9 ; pen for macros
#TUITBPEN_STRING          = 10 ; pen for string constants
#TUITBPEN_FUNCTION        = 11 ; pen for functions
#TUITBPEN_DIRECTIVE       = 12 ; pen for directives
#TUITBPEN_LABEL           = 13 ; pen for labels
#TUITBPEN_TAG             = 14 ; pen for tag
#TUITBPEN_ATTR            = 15 ; pen for tag attribute
#TUITBPEN_BGFOCUS         = 16 ; pen for background with focus
#TUITBPEN_BGNOFOCUS       = 17 ; pen for background without focus
#TUITBPEN_BGDISABLED      = 18 ; pen for disabled background
#TUITBPEN_HINTTEXT        = 19
#TUITBPEN_BG2             = 20
#TUITBPEN_MAX             = 21

;/* ntui TextBox Line Flags */
#TUITBLF_NONE             = $0   ; no flags
#TUITBLF_INCOMMENT        = $1   ; propagate multi-line comment
#TUITBLF_INTAG            = $2   ; propagate multi-line comment
#TUITBLF_INIT             = $4
#TUITBLF_STOLEN           = $8   ; line is not allocated by us
#TUITBLF_ALLOC            = $10  ; was allocated by us
#TUITBLF_HOT              = $20
#TUITBLF_STYLED           = $40

#TUITBLF_STYLEFLAGS       = #TUITBLF_INCOMMENT|#TUITBLF_INTAG|#TUITBLF_HOT|#TUITBLF_STYLED

; Undo containers
#TUITBUNDO_INSERTNEWLINE = 1
#TUITBUNDO_INSERTINLINE  = 2
#TUITBUNDO_DELETELINE    = 3
#TUITBUNDO_DELETEINLINE  = 4

; Undo steps
#TUITBUNDOSTEP_UNDEFINED = 0
#TUITBUNDOSTEP_KEYSTROKE = 1
#TUITBUNDOSTEP_PASTE     = 2
#TUITBUNDOSTEP_DELETE    = 3
#TUITBUNDOSTEP_CUT       = 3
#TUITBUNDOSTEP_REPLACE   = 4
#TUITBUNDOSTEP_SETTEXT   = 5
#TUITBUNDOSTEP_APPEND    = 6

#TUITBEV_APPEND  = #TUIEV_USER +1
#TUITBEV_FLCLOSE = #TUIEV_USER +2

NEWTYPE.styleCommand

 clength.b  ; length to next command
 command.b  ; command
 data1.b    ; data of command
 data2.b    ; reserved
 
End NEWTYPE


NEWTYPE.tline ; line contains ASCII text and special tokenized version

  flags.l       ; like #tflag_comment

  blength.l     ; allocated length
  clength.l     ; character length (including return code)
  *text.b       ; pointer to (NOT 0 terminated!) text string

  sblength.l    ; allocated length in bytes
  sclength.l    ; command length
  *style.styleCommand ; tokenized info for text
                      ; format is length/command
End NEWTYPE

; Tui TextBox Style Command
#TUITBSC_RESET      =  0 ; reset all decoration
#TUITBSC_PENS       =  1 ; set for and background pen (#TUITBPEN_...)
#TUITBSC_BOLD       =  2 ; set bold
#TUITBSC_ITALIC     =  3 ; set italic
#TUITBSC_UNDERLINED =  4 ; set underlined
#TUITBSC_WARN       =  5 ; set warning underline
#TUITBSC_MARKED     =  6 ; set a marking with #pen TextBoxPen
#TUITBSC_BOXED      =  7 ; text is in a "box"
#TUITBSC_REPLACE    =  8 ; set replacement text
#TUITBSC_FGPEN      =  9 ; set forground pen (#TUITBPEN_...)
#TUITBSC_BGPEN      = 10 ; set background pen (#TUITBPEN_...)
#TUITBSC_SKIP       = 11 ; skip the following n chars
#TUITBSC_INSERT     = 12 ; insert n characters
#TUITBSC_HLC        = 13 ; highlight character

; styling callback return codes
#TUISCB_DONE        =  0  ; we are done tokenizing
#TUISCB_ERROR       = -1 ; error during tokenizing
#TUISCB_NEXT        =  1  ; tokenize next line too
#TUISCB_PREV        =  2  ; tokenize prev line FIRST

NEWTYPE.tuiTextBox
obj.tuiObject        ; tui object header
subClassID.l
maxChars.l
maxLines.l
scrollerMode.l
*hScroller.tuiScroller
*vScroller.tuiScroller
*funcButton.tuiButton
*doc.tline           ; Zeiger auf Pointer array
*tank.b              ; pointer to text tank from load function
allocLines.l         ; Maximum Numer of Textlines
visibleLines.l
topLine.l
totalWidth.l
visibleWidth.l
leftOffset.l
totalLines.l         ;  Number of used lines in Ted
step_.tuiPixel
numMin.l             ; boundaries for numeric string
numMax.l

cursor_lpos.l
cursor_cpos.l
cursor_pixpos.l
selection_begin_lpos.l
selection_begin_cpos.l
selection_end_lpos.l
selection_end_cpos.l
current_lpos.l
current_cpos.l
damage_begin_lpos.l
damage_end_lpos.l
damage_binding.l
anker_lpos.l
anker_cpos.l
search_lpos.l
search_cpos.l
bracket1_lpos.l
bracket1_cpos.l
bracket1_char.b
bracket2_char.b
bracket2_lpos.l
bracket2_cpos.l

last_flags.l
*font.TextFont
fontstolen.l
*fontI.TextFont
*fontB.TextFont
*fontBI.TextFont
rowheight.l
spacing.l
space_width.l
ndc_width.l
tab_width.l
editable.l
accept.l

cursor_show.l
cursor_count.l

scrollborder_x.l
scrollborder_y.l

edflags.l
cursorStyle.l
blink_speed.l
tabsize.l ; tab size in spaces
returncode.l
max_cpos.l

validChar.b[256]

; pens
penN.l   [#TUITBPEN_MAX] ; pen to draw normal
penS.l   [#TUITBPEN_MAX] ; pen to draw selected
tuiPenN.l[#TUITBPEN_MAX] ; tuiPen the actual pen is based on
tuiPenS.l[#TUITBPEN_MAX] ; tuiPen the actual pen is based on
argb.l   [#TUITBPEN_MAX] ; ARGB value the actual pen is based on (has precedence over tuiPen, if not -1)
penObtained.w [#TUITBPEN_MAX]
*undo.tuiUndoStack            ; undo stack object

onChange.tuiNotifyHandler     ; called everytime the text changes (but not on every key)
onKey.tuiNotifyHandler        ; called before every key-stroke
onPostKey.tuiNotifyHandler    ; called after every key-stroke
onEdit.tuiNotifyHandler       ; called when textbox first edited
onCursor.tuiNotifyHandler     ; called everytime the cursor changes its position
onFileListenerClose.tuiNotifyHandler
onSubmit.tuiNotifyHandler     ; called when the user hits RETURN in String
onClick.tuiNotifyHandler     ; called when the user clicks into the textbox

*styleCB.tuiFunc

*filename.str    ; file name of last loaded file or NULL
edited.l         ; text has been edited

*hint.str

*fileListener.tuiFileListener
End NEWTYPE

USEPATH *textBox

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !line_use {lpos}                                                    /
;/                                                                             /
;/ Description:
;/ Helper macro to get the pointer to a text line or NULL, if out of range.                                                              /
;/                                                                             /
;/ Inputs:
;/ - *tline  : name of the varialbe that holds the pointer                                                                 /
;/ - lpos    : line position                                                             /
;/                                                                            /
;///////////////////////////////////////////////////////////////////////////////
Macro line_use ;{*tline,lpos}
If (`2) < *textBox\allocLines AND (`2)>=0
  `1.tline = *textBox\doc + ((`2) * SizeOf.tline)
Else
  `1       = Null
End If
End Macro


Macro line_hasreturn
 (*tline\clength>0) Then If (Peek.b(*tline\text+*tline\clength-1)=#ASCII_LF)
End Macro

Function.l FAST _tb_line_hasreturn{*tline.tline}
  If *tline
    If *tline\text
      If (*tline\clength>0)
        If (Peek.b(*tline\text+*tline\clength-1)=#ASCII_LF)
          Function Return 1
        End If
      End If
    End If
  End If
  Function Return 0

End Function

Function.l FAST _tb_vlength{*tline.tline}

  Function Return *tline\clength-_tb_line_hasreturn{*tline}

End Function

Function.l FAST ntui_ToLower{c.l}

  If c>=@"A" AND c<=@"Z" Then Function Return c-@"A"+@"a"
  Function Return c

End Function

Function.l FAST ntui_ToUpper{c.l}

  If c>=@"A" AND c<=@"Z" Then Function Return c-@"A"+@"a"
  Function Return c

End Function

Function.l FAST ntui_CaseCmp{a.l,b.l}

  If a=b Then Function Return 0
    If a>=@"A" AND a<=@"Z" Then a=a-@"A"+@"a"
  If b>=@"A" AND b<=@"Z" Then b=b-@"A"+@"a"
  If a<b Then Function Return -1
  If a>b Then Function Return 1

  Function Return 0
End Function
  
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_CopyMem {sourceaddr.l,destaddr.l,blength.l}                     /
;/                                                                             /
;/ Description:                                                                /
;/ Copymem() reimplementation that supports overlapping memory areas                                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - sourceaddr.l  : source memory address                                                     /
;/ - destaddr.l    : destination memory address                                                       /
;/ - blength.l     : byte length of memory area                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_CopyMemd{sourceaddr.l,destaddr.l,blength.l}
If sourceaddr>destaddr
  For n.l=0 To blength-1
    Poke.b (destaddr+n),Peek.b(sourceaddr+n)
  Next
Else
  For n.l=blength-1 To 0 Step -1
    Poke.b (destaddr+n),Peek.b(sourceaddr+n)
  Next
End If
End Statement


Statement FAST _tb_CopyMemxy{sourceaddr.l,destaddr.l,blength.l}
UNLK a4
TST.l d2
BLE ecopy_exit
MOVE.l d0,a0
MOVE.l d1,a1

CMP.l d0,d1
BLT ecopy_normal
BEQ ecopy_exit


ADD.l d2,a0
ADD.l d2,a1
ecopy_reverse: ; --------------------------------- REVERSE
MOVE.b -(a0),-(a1)
SUB.l #1,d2
BGT ecopy_reverse
BRA ecopy_exit


ecopy_normal: ; ------------------------------------ NORMAL
MOVE.b (a0)+,(a1)+
SUB.l #1,d2
BGT ecopy_normal

ecopy_exit:
RTS
End Statement


Statement FAST _tb_CopyMem{sourceaddr.l,destaddr.l,blength.l}
UNLK a4
TST.l d2
BLE copy_exit
MOVE.l d0,a0
MOVE.l d1,a1
MOVE.l d2,d3
CMP.l d0,d1
BLT copy_normal
BEQ copy_exit
ADD.l d2,a0
ADD.l d2,a1
copy_reverse: ; --------------------------------- REVERSE
LSR.l #5,d3
BEQ copy_reverse_norow
copy_reverse_row:
MOVE.l -(a0),-(a1) ;1
MOVE.l -(a0),-(a1) ;2
MOVE.l -(a0),-(a1) ;3
MOVE.l -(a0),-(a1) ;4
MOVE.l -(a0),-(a1) ;5
MOVE.l -(a0),-(a1) ;6
MOVE.l -(a0),-(a1) ;7
MOVE.l -(a0),-(a1) ;8
SUB.l #1,d3
BGT copy_reverse_row
copy_reverse_norow:
AND.l #31,d2
BEQ copy_exit
copy_reverse_byte:
MOVE.b -(a0),-(a1)
SUB.l #1,d2
BGT copy_reverse_byte
copy_exit:
RTS
copy_normal: ; ------------------------------------ NORMAL
LSR.l #5,d3
BEQ copy_normal_norow
copy_normal_row:
MOVE.l (a0)+,(a1)+  ;1
MOVE.l (a0)+,(a1)+  ;2
MOVE.l (a0)+,(a1)+  ;3
MOVE.l (a0)+,(a1)+  ;4
MOVE.l (a0)+,(a1)+  ;5
MOVE.l (a0)+,(a1)+  ;6
MOVE.l (a0)+,(a1)+  ;7
MOVE.l (a0)+,(a1)+  ;8
SUB.l #1,d3
BGT copy_normal_row
copy_normal_norow:
AND.l #31,d2
BEQ copy_exit
copy_normal_byte:
MOVE.b (a0)+,(a1)+
SUB.l #1,d2
BGT copy_normal_byte
RTS
End Statement
               
               
Macro _tb_IsWS ; {c.l}
  ((`1)=$20 OR (`1)=$10 OR (`1)=$13 OR (`1)=$09)
End Macro

Function.l FAST _tb_IsWS{c.l}
  Function Return !_tb_IsWS{c}
End Function


Function.l FAST _tb_TrimLine{*tline.tline}

  If *tline = Null Then Function Return False
  If *tline\text = Null Then Function Return False
  retcode.l = _tb_line_hasreturn{*tline}
  If *tline\clength <= retcode Then Function Return False
  tpos.l = *tline\clength-1-retcode
  If _tb_IsWS{Peek.b(*tline\text + tpos)} = False Then Function Return False
  
  While tpos >= 0  AND _tb_IsWS{Peek.b(*tline\text + tpos)}
    tpos-1
  Wend 
  For  n.l = 0 To retcode-1
    Poke.b *tline\text + tpos + retcode - n,Peek.b(*tline\text + *tline\clength-1-n)
  Next
  *tline\clength = tpos + retcode +1
  Function Return True
  
End Function


Function.l _tb_ExpandStyle_deprecated{*tline.tline,minCommands.l}

  succ.l = False
  If minCommands*SizeOf.styleCommand>*tline\sblength
    newstyle.l = AllocMem_(minCommands*SizeOf.styleCommand,#MEMF_ANY)
    If newstyle
      If *tline\style
        CopyMem_ *tline\style,newstyle,*tline\sblength
        FreeMem_ *tline\style,*tline\sblength*SizeOf.styleCommand
      End If
      *tline\style    = newstyle
      *tline\sblength = minCommands
      succ.l = True
    End If
  End If
  Function Return succ

End Function

Function.l _ntui_TextBoxHasSelecton{*textBox.tuiTextBox}

  If \selection_end_lpos>\selection_begin_lpos Then Function Return True
  If \selection_end_lpos=\selection_begin_lpos
    If \selection_end_cpos>\selection_begin_cpos Then Function Return True
  End If
  Function Return False
  
End Function


Function.l _tb_RemStyleCommand{*tline.tline, cpos1.l, cpos2.l, command.b}

  seekcpos.l = 0
  scpos.l    = 0
  *sc.styleCommand = *tline\style

  While seekcpos<=cpos2 AND scpos<*tline\sclength
    ncpos.l = seekcpos + (*sc\clength)&$FF
    If ncpos>=cpos1 AND ncpos<=cpos2 AND *sc\command = command
      clength.l = *sc\clength&$FF
      copylen.l = *tline\sclength-scpos-1
      If copylen>0
        _tb_CopyMem{*sc+SizeOf.styleCommand,*sc,copylen*SizeOf.styleCommand}
        *sc\clength + clength
      End If
      *tline\sclength-1
    Else
      seekcpos + (*sc\clength&$FF)
      *sc      + SizeOf.styleCommand
      scpos    + 1
    End If
  Wend

End Function

Function.styleCommand _tb_GetStyleCommand{*tline.tline, cpos.l, command.b}

  seekcpos.l = 0
  scpos.l    = 0
  *sc.styleCommand = *tline\style

  While seekcpos<=cpos AND scpos<*tline\sclength
    ncpos.l = seekcpos + (*sc\clength)&$FF
    If ncpos = cpos AND *sc\command = command
      Function Return *sc
    Else
      seekcpos + (*sc\clength&$FF)
      *sc      + SizeOf.styleCommand
      scpos    + 1
    End If
  Wend
  
  Function Return Null

End Function


Statement _tb_DebugCommand{*tline.tline,*rp.RastPort,x.l,y.l}
SHARED countxxx.l
  *old.Region = ntui_SetClip{*rp,Null}
  If *tline\style = Null
    a.s  = "<no style>                         "
  Else
    a.s + Str$(*tline\sclength)+"::"
    For n.l=0 To *tline\sclength-1
      *sc.styleCommand = n*SizeOf.styleCommand + *tline\style
      Select *sc\command
        Case #TUITBSC_FGPEN
          a.s + "fg:"+Str$(*sc\data1)
        Case #TUITBSC_BOLD
          a.s + "BD:"+Str$(*sc\data1)
        Case #TUITBSC_MARKED
          a.s + "MK:"+Str$(*sc\data1)
        Default
          a.s + "#"+Str$(*sc\command)+":"+Str$(*sc\data1)
      End Select
      a.s + "/"
    Next
  End If
  a.s + "                         "+Str$(countxxx)+"                  " : countxxx+1
  SetAPen_ *rp,1
  SetBPen_ *rp,0
  SetDrMd_ *rp,#JAM2
  Move_ *rp,x,y
  Text_ *rp,&a,FLen(a)
  ntui_RemClip{*rp,*old}
End Statement

Function.l _tb_SetStyleCommand{*tline.tline, cpos.l, command.b, @data1.b, @data2.b}

  If cpos>=*tline\clength Then Function Return False

  If (*tline\sclength>=*tline\sblength)
    newsblen.l = (*tline\sclength+8)
    newstyle.l = AllocMem_(newsblen*SizeOf.styleCommand,#MEMF_ANY)
    If newstyle
      If *tline\style
        CopyMem_ *tline\style,newstyle,*tline\sblength*SizeOf.styleCommand
        FreeMem_ *tline\style,*tline\sblength*SizeOf.styleCommand
      End If
      *tline\style    = newstyle
      *tline\sblength = newsblen
    Else
      Function Return False
    End If
  End If

  seekcpos.l = 0
  scpos.l    = 0
  *sc.styleCommand = *tline\style
  While seekcpos<=cpos AND scpos<*tline\sclength
    seekcpos + (*sc\clength&$FF)
    *sc      + SizeOf.styleCommand
    scpos    + 1
  Wend
  If seekcpos>cpos
    *sc - SizeOf.styleCommand
    scpos -1
    seekcpos - (*sc\clength)&$FF
    *sc\clength = seekcpos + ((*sc\clength)&$FF) - cpos
    ;*sc + SizeOf.styleCommand
  End If

  copysize.l = *tline\sclength-scpos

  If copysize>0
    _tb_CopyMem{*sc,*sc+SizeOf.styleCommand,copysize*SizeOf.styleCommand}
  End If
  length_.l = cpos - seekcpos
  
  *sc\clength = length_
  *sc\command = command
  *sc\data1   = data1
  *sc\data2   = data2
  *tline\sclength+1

  Function Return True

End Function


_tb_DefaultStyleCB:
Function.l _tb_DefaultStyleCB{*textBox.tuiTextBox,lpos.l,*tline.tline}
  Function Return #TUISCB_DONE
  If *tline\text
    *tline\sclength = 0

    For cpos.l = 0 To *tline\clength-1
      c.b = Peek.b(*tline\text+cpos)
      If c=@"A"
        _tb_SetStyleCommand{*tline,cpos  ,#TUITBSC_BOLD,1,0}
        _tb_SetStyleCommand{*tline,cpos+1,#TUITBSC_BOLD,0,0}
      End If
    Next
    *tline\flags|#TUITBLF_STYLED
  End If
  Function Return #TUISCB_DONE

End Function
!_MakeGlobalFuncPointer{_tb_DefaultStyleCB,{Null,0,Null}}



Function.l _tb_ReleasePen{*textBox.tuiTextBox,tuiTBPen.l}

  If *textBox\penObtained[tuiTBPen]
    ntui_ReleaseTuiPen{*textBox\obj\engine,*textBox\tuiPenN[tuiTBPen]}
    ntui_ReleaseTuiPen{*textBox\obj\engine,*textBox\tuiPenS[tuiTBPen]}
    *textBox\penObtained[tuiTBPen]=False
  End If

  Function Return True

End Function



Function.l _tb_ReleasePens{*textBox.tuiTextBox}

  *engine.tuiEngine = *textBox\obj\engine

  For n.l=0 To #TUITBPEN_MAX -1
    If *textBox\penObtained[n]
      ntui_ReleaseTuiPen{*engine,*textBox\tuiPenN[n]}
      ntui_ReleaseTuiPen{*engine,*textBox\tuiPenS[n]}
      *textBox\penObtained[n]=False
    End If
  Next

  Function Return True

End Function


Function.l _tb_UpdatePens{*textBox.tuiTextBox}
  *engine.tuiEngine = *textBox\obj\engine

  For n.l=0 To #TUITBPEN_MAX -1

    If *textBox\tuiPenN[n]><#TUIPEN_TRANSPARENT
      *textBox\penN      [n]=*engine\pen[*textBox\tuiPenN[n]]
    Else
      *textBox\penN      [n]=0
    End If

    If *textBox\tuiPenS[n]><#TUIPEN_TRANSPARENT
      *textBox\penS      [n]=*engine\pen[*textBox\tuiPenS[n]]
    Else
      *textBox\penS      [n]=0
    End If

  Next
  Function Return True

End Function



Function.l _tb_ObtainPens{*textBox.tuiTextBox}
  *engine.tuiEngine = *textBox\obj\engine

  _tb_ReleasePens{*textBox}

  rm.l = ((*textBox\argb[#TUITBPEN_MARKER] & $00ff0000) LSR 16 )
  gm.l = ((*textBox\argb[#TUITBPEN_MARKER] & $0000ff00) LSR 8  )
  bm.l = ((*textBox\argb[#TUITBPEN_MARKER] & $000000ff)        )

  a.l = 192 ; mix ration

  For n.l=0 To #TUITBPEN_MAX -1

    If *textBox\argb[n]><-1 ; obtain from argb
      argb.l = *textBox\argb[n]
      *textBox\tuiPenN[n] = ntui_ObtainTuiPen{*engine,argb}
      r.l = ((*textBox\argb[n] & $00ff0000) LSR 16 ) * a + rm * (256-a)
      g.l = ((*textBox\argb[n] & $0000ff00) LSR 8  ) * a + gm * (256-a)
      b.l = ((*textBox\argb[n] & $000000ff)        ) * a + bm * (256-a)
      argb.l = r LSL 24 | g LSL 16 | b
      *textBox\tuiPenS[n] = ntui_ObtainTuiPen{*engine,argb}
      *textBox\penObtained[n]=True
    End If

  Next
  _tb_UpdatePens{*textBox}

  Function Return True

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l =  _tb_Instr {textptr.l,c.b,mlen.l,@pos.l}                 /
;/                                                                             /
;/ Description:                                                                /
;/ Find position of first occurence of c in text string, mlen to search and from pos.
;/                                                                             /
;/ Inputs:                                                                     /
;/ - textptr.l  : ???                                                        /
;/ - c.b        : ???                                                              /
;/ - mlen.l     : ???                                                           /
;/ - pos.l      : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l   : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST _tb_Instr{textptr.l,c.b,mlen.l,@pos.l}

  If pos<0 Then pos = 0
  While Peek.b(textptr+pos)><c AND pos<mlen:pos+1:Wend
  If pos=mlen Then pos=-1
  Function Return pos

End Function


Function.l FAST _tb_NVC{textptr.l,mlen.l,@pos.l}

  If pos<0 Then pos = 0
  While (Peek.b(textptr+pos)&$FF)>=32 AND pos<mlen:pos+1:Wend
  If pos=mlen Then pos=-1
  Function Return pos

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _tb_GetTextLength {*rp.RastPort,textptr.l,mlen.l}        /
;/                                                                             /
;/ Description:                                                                /
;/ Replacement for TextLength() OS function, but respects TAB sizes            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *rp.RastPort    : destination RastPort                                                    /
;/ - textptr.l       : text pointer                                                        /
;/ - mlen.l          : max length to test                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l        : length in pixel of the textstring                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _tb_GetTextPixWidth{*textBox.tuiTextBox,*rp.RastPort,textptr.l,mlen.l,tx.l}

  lpos.l   = 0
  pixlen.l = 0

  SetFont_ *rp,\font
  If *textBox\obj\flags&#TUIF_BOLD   Then SetSoftStyle_ *rp,#FSF_BOLD,#FSF_BOLD
  If *textBox\obj\flags&#TUIF_ITALIC Then SetSoftStyle_ *rp,#FSF_ITALIC,#FSF_ITALIC

  Repeat
    pos.l = _tb_NVC{textptr,mlen,lpos}
    If pos<0 ; no nvc till end
      pixlen + TextLength_ (*rp,textptr+lpos,mlen-lpos)
      lpos=mlen
    Else
      If pos-lpos>0 Then pixlen+TextLength_ (*rp,textptr+lpos,pos-lpos)
      lpos = pos+1

      cw.l = *textBox\ndc_width

      Select Peek.b(textptr+lpos-1)
        Case 10 ;

        Case 9 ; TAB
          tabpos.l = (tx+pixlen)
          tabpos   = (tabpos + *textBox\tab_width)/*textBox\tab_width
          tabpos   = tabpos * *textBox\tab_width
          cw.l = tabpos-(tx+pixlen)+1

        Default

      End Select

      pixlen + cw
    End If
  Until lpos>=mlen

  Function Return pixlen

End Function




;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _tb_pos2x {*textBox.tuiTextBox,lpos.l,cpos.l}         /
;/                                                                             /
;/ Description:                                                                /
;/ convert cursor position to x coordinate.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - cpos.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _tb_pos2x{*textBox.tuiTextBox,lpos.l,cpos.l,*rp.RastPort}

  x.l = 0
  cw.l = \space_width
  ;*win.tuiWindow = *textBox\obj\tuiWindow
  ;If *win Then *win.Window = *win\win
  ;If *win Then *rp.RastPort = *win\RPort
  If *rp=-1 Then *rp=Null
  If *rp
    !line_use{*tline,lpos}
    If *tline
      If *tline\text
        If cpos>=*tline\clength
          ;If *tline\ttext AND *tline\tclength>0
            ;x.l = _tb_GetTokenLength{*rp,*tline\ttext,*tline\tclength} + \space_width * (cpos-*tline\clength)
          ;Else
            x.l = _tb_GetTextPixWidth{*textBox,*rp,*tline\text,*tline\clength,0} + \space_width * (cpos-*tline\clength)
          ;End If
        Else
          ;If *tline\ttext AND *tline\tclength>0
            ;x.l = _tb_GetTokenLength2{*rp,*tline\ttext,cpos}
          ;Else
            x.l = _tb_GetTextPixWidth{*textBox,*rp,*tline\text,cpos,0}
          ;End If
        End If
      Else
        x = \space_width * cpos
      End If
    Else
      x = \space_width * cpos
    End If
  End If
  Function Return x

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _tb_pos2cw {*textBox.tuiTextBox,lpos.l,cpos.l}        /
;/                                                                             /
;/ Description:                                                                /
;/ Get the cursor width of the given position                                                                            /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - cpos.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _tb_pos2cw{*textBox.tuiTextBox,lpos.l,cpos.l,*rp.RastPort}

  cw.l = \space_width
  ;*win.tuiWindow = *textBox\obj\tuiWindow
  ;If *win Then *win.Window = *win\win
  ;If *win Then *rp.RastPort = *win\RPort
  If *rp=-1 Then *rp=Null
  If *rp
    !line_use{*tline,lpos}
    If *tline
      If *tline\text
        If cpos>=*tline\clength
          cw.l = \space_width
        Else
          ;If *tline\ttext
            ;string.s = _tb_DeTokenize{*tline\ttext,*tline\tclength}
            ;cw.l = _tb_GetTextLength{*rp,&string.s+cpos,1}
            ;cw.l = _tb_tokenlength{*rp,*tline\ttext+cpos,1}
          ;Else
            tx.l = _tb_GetTextPixWidth{*textBox,*rp,*tline\text,cpos,0}
            cw.l = _tb_GetTextPixWidth{*textBox,*rp,*tline\text+cpos,1,tx}
          ;End If
        End If
      End If
    End If
  End If
  Function Return cw-1

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _tb_x2pos {*textBox.tuiTextBox,lpos.l,x.l}            /
;/                                                                             /
;/ Description:
;/ Convert the x position at line pos to character position.                                                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - x.l    : ???                                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _tb_x2pos_deprecated{*textBox.tuiTextBox,lpos.l,x.l,*rp.RastPort}

  !_ASSERT{*rp}

  cpos.l = 0

  !line_use{*tline,lpos}
  If *tline
    If *tline\text

      pixlen.l = _tb_GetTextPixWidth{*textBox,*rp,*tline\text,*tline\clength,0}

      If x>pixlen ; position is over the end of the line
        spaces.l = (x-pixlen)/\space_width

      Else

      End If
      llength.l = TextFit_ (*rp,*tline\text,*tline\clength,Null,tcx.TextExtent,1,x,\rowheight)
      clength.l = 0
;      If (*tline\flags&#TUITBLF_RETURN_LF) Then clength-1
      If _tb_line_hasreturn{*tline} Then clength-1
    Else
      cpos = x / \space_width  : clength = 0
    End If
  Else
    cpos = x / \space_width  : clength = 0
  End If
  If (\edflags&#TUITBF_RIGHTWRAP)><0 AND cpos>=clength
    cpos=clength
  End If
  Function Return cpos

End Function



Function.l _tb_x2pos{*textBox.tuiTextBox,lpos.l,x.l,*rp.RastPort}

  !_ASSERT{*rp}

  cpos.l = 0

  !line_use{*tline,lpos}
  If *tline
    If *tline\text

      string.s = Peeks$(*tline\text,*tline\clength)
      slen.l = FLen(string.s)

      While x>0
        If cpos<slen
          ;needs a fix, btw, binsearch!?
          x-_tb_GetTextPixWidth{*textBox,*rp,&string.s + cpos,1,0}
        Else
          x-\space_width
        End If
        If x>=0 Then cpos+1
      Wend
      clength.l = slen ; *tline\clength
      ;If (*tline\flags&#TUITBLF_RETURN_LF) Then clength-1
      If _tb_line_hasreturn{*tline} Then clength-1
    Else
      cpos = x / \space_width  : clength = 0
    End If
  Else
    cpos = x / \space_width  : clength = 0
  End If
  If (\edflags&#TUITBF_RIGHTWRAP)><0 AND cpos>=clength
    cpos=clength

  End If
  Function Return cpos

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_Text {*rp.RastPort,textptr.l,mlen.l}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Sample like Text(), but respect the TAB sizes.
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *rp.RastPort    : ???                                                     /
;/ - textptr.l    : ???                                                        /
;/ - mlen.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////

Function.l _tb_Text{*textBox.tuiTextBox,*rp.RastPort,textptr.l,mlen.l,*skipx.l}
  lpos.l = 0
  apen.l = *rp\FgPen
  bpen.l = *rp\BgPen

  Repeat
    pos.l = _tb_NVC{textptr,mlen,lpos}
    If pos<0 ; no nvc till end
      TextExtent_ *rp,textptr+lpos,mlen-lpos,te.TextExtent
      Text_ *rp,textptr+lpos,mlen-lpos
      lpos=mlen
      tx.l = *rp\cp_x
      Poke.l *skipx , te\te_Extent\MaxX+1 - te\te_Width
    Else
      If pos-lpos>0
        Text_ *rp,textptr+lpos,pos-lpos
        TextExtent_ *rp,textptr+lpos,pos-lpos,te.TextExtent
        tx.l = *rp\cp_x
        Poke.l *skipx, te\te_Extent\MaxX+1 - te\te_Width
      Else
        tx.l = *rp\cp_x
      End If
      lpos = pos+1
      ty.l = *rp\cp_y -*rp\TxBaseline
      cw.l = *textBox\ndc_width
      Select Peek.b(textptr+pos)
        Case 10 ;\n
          If (*textBox\edflags&#TUITBF_SHOWCR)
            If False
              a.s = "\\B6"
              Text_ *rp,&a,1
              tx.l = *rp\cp_x : cw.l = 0
            Else
              SetAPen_ *rp,bpen
              RectFill_ *rp,tx+Peek.l(*skipx),ty,tx+cw-1,ty+*rp\TxHeight-1
              SetAPen_ *rp,apen
              Move_ *rp,tx+cw-2 ,ty+*rp\TxHeight/2
              Draw_ *rp,tx+cw-2 ,ty+*rp\TxHeight-3
              Draw_ *rp,tx+1  , ty+*rp\TxHeight-3
              Move_ *rp,tx+2, ty+*rp\TxHeight-4
              Draw_ *rp,tx+2, ty+*rp\TxHeight-2
              Move_ *rp,tx+3, ty+*rp\TxHeight-5
              Draw_ *rp,tx+3, ty+*rp\TxHeight-1
            End If
            Poke.l *skipx,0
          Else
            cw=0
          End If
          dorect.l=False
        Case 13 ; \r
          If (*textBox\edflags&#TUITBF_SHOWCR OR True)
              SetAPen_ *rp,bpen
              RectFill_ *rp,tx+Peek.l(*skipx),ty,tx+cw-1,ty+*rp\TxHeight-1
              SetAPen_ *rp,apen
              WritePixel_ *rp,tx+cw/2, ty+*rp\TxHeight/2
            
            Poke.l *skipx,0
          Else
            cw=0
          End If
          dorect.l=False

        Case 9 ; TAB
          tabpos.l = tx - *textBox\obj\cbox\left + *textBox\leftOffset
          tabpos   = (tabpos + *textBox\tab_width)/*textBox\tab_width
          tabpos   = tabpos * *textBox\tab_width + *textBox\obj\cbox\left - *textBox\leftOffset
          cw.l = tabpos-tx+1
          SetAPen_ *rp,bpen
          RectFill_ *rp,tx+Peek.l(*skipx),ty,tx+cw-1,ty+*rp\TxHeight-1
          SetAPen_ *rp,apen
          For n.l=2 To (cw-1) Step 3
            WritePixel_ *rp,tx + cw-n,ty+*rp\TxBaseline
          Next
          dorect=False
          Poke.l *skipx,0

        Case 0
          SetAPen_ *rp,bpen
          RectFill_ *rp,tx+Peek.l(*skipx),ty,tx+cw-1,ty+*rp\TxHeight-1
          dorect.l=True
          SetAPen_ *rp,apen
          txm.l = tx+cw/2-1
          tym.l = ty +*rp\TxHeight/2
          nxs.l = cw/2-2
          nys.l = *rp\TxBaseline/2 -2
          If nxs<1 Then nxs=1
          If nys<1 Then nys=1
          Move_ *rp,txm-nxs+1     ,tym-nys : Draw_ *rp,txm+nxs-1     ,tym-nys
          Move_ *rp,txm+nxs     ,tym-nys+1 : Draw_ *rp,txm+nxs     ,tym+nys-1
          Move_ *rp,txm+nxs-1     ,tym+nys : Draw_ *rp,txm-nxs+1     ,tym+nys
          Move_ *rp,txm-nxs     ,tym+nys-1 : Draw_ *rp,txm-nxs     ,tym-nys+1
          nms.l = Min(nxs,nys)
          Move_ *rp,txm-nms+1     ,tym-nms+1 : Draw_ *rp,txm+nms-1     ,tym+nms-1
          dorect.l=False;True
          Poke.l *skipx,0

        Default ; NDC
          SetAPen_ *rp,bpen
          RectFill_ *rp,tx+Peek.l(*skipx),ty,tx+cw-1,ty+*rp\TxHeight-1
          dorect.l=True

      End Select

      If dorect
        SetAPen_ *rp,apen
        Move_ *rp,tx+1     ,ty+1
        Draw_ *rp,tx+cw-2  ,ty+1
        Draw_ *rp,tx+cw-2  ,ty+*rp\TxBaseline
        Draw_ *rp,tx+1     ,ty+*rp\TxBaseline
        Draw_ *rp,tx+1     ,ty+1
        Poke.l *skipx,0
      End If
      tx+cw
      Move_ *rp,tx,ty+*rp\TxBaseline

    End If
  Until lpos>=mlen

  Function Return tx

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l =  _tb_y2line {*textBox.tuiTextBox,y.l}                 /
;/                                                                             /
;/ Description:                                                                /
;/ Convert y coordinate to line.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox : TextBox Object                                           /
;/ - y.l                    : y-coordinate relative to left/top edge of TextBox                                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l               : line                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST _tb_y2line{*textBox.tuiTextBox,y.l}

  If \rowheight>0
    lpos.l = ((y) / \rowheight + \topLine)
  Else
    lpos = 0
  End If
  If lpos>=\totalLines Then lpos=\totalLines-1
  If lpos<0 Then lpos=0
  Function Return lpos

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l =  _tb_line2y {*textBox.tuiTextBox,lpos.l}              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST _tb_line2y{*textBox.tuiTextBox,lpos.l}

  Function Return (lpos-\topLine) * \rowheight

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_DoBlink {*textBox.tuiTextBox,*rp.RastPort,mode.l}            /
;/                                                                             /
;/ Description:                                                                /
;/ View or hide the text cursor.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox  : TextBox Object                                           /
;/ - *rp.RastPort            : ???                                                     /
;/ - mode.l                  : 1 = auto blink, -1=show, 0=hide                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_DoBlink{*textBox.tuiTextBox,*rp.RastPort,mode.l}

  If *textBox\obj\flags&#TUIF_ONSCREEN=0 Then Statement Return
  If *rp=Null Then Statement Return

  If (\edflags&#TUITBF_HIDECURSORONSELECT=0)  OR (\selection_begin_lpos=-1) OR (\selection_end_cpos=\selection_begin_cpos AND \selection_begin_lpos=\selection_end_lpos)
    If \accept=False Then mode=Off
    If mode=1 AND \blink_speed>0
      \cursor_count+1
      If \cursor_count>=\blink_speed
        If \cursor_show Then mode=Off : Else mode=On
        \cursor_count=0
      End If
    Else
      \cursor_count=0
    End If

    If mode=\cursor_show OR mode=1 Then Statement Return

    xs.l = _tb_pos2x {*textBox,\cursor_lpos,\cursor_cpos,*rp}
    ;If \edflags&#TUITBF_LINECURSOR
    ;  cw.l = 0
    ;Else
      cw.l = _tb_pos2cw{*textBox,\cursor_lpos,\cursor_cpos,*rp}
    ;End If

    x.l = *textBox\obj\cbox\left  - \leftOffset  + xs
    y.l = *textBox\obj\cbox\top   + (\cursor_lpos-\topLine) *\rowheight ;- \view_ypos

    \cursor_show = mode
    
    SetDrMd_ *rp,-1
    Select *textBox\cursorStyle
      Case #TUITBCS_LINE       : RectFill_ *rp,x,y,x,y+\rowheight-1
      Case #TUITBCS_BOLDLINE   : RectFill_ *rp,x,y,x+1,y+\rowheight-1
      Case #TUITBCS_UNDERSCORE : RectFill_ *rp,x,y+\rowheight-2,x+cw,y+\rowheight-1
      Default ; Case #TUITBCS_BLOCK 
        RectFill_ *rp,x,y,x+cw,y+\rowheight-1
    End Select
    SetDrMd_ *rp,0

  EndIf

End Statement

Statement _tb_Damage{*textBox.tuiTextBox,lpos_begin.l,lpos_end.l}

  If *textBox
    If *textBox\damage_begin_lpos<=*textBox\damage_end_lpos ; expand damage range
      If lpos_begin<*textBox\damage_begin_lpos Then *textBox\damage_begin_lpos = lpos_begin
      If lpos_end  >*textBox\damage_end_lpos   Then *textBox\damage_end_lpos   = lpos_end
    Else
      *textBox\damage_begin_lpos = lpos_begin ; first damaged line
      *textBox\damage_end_lpos   = lpos_end
    End If
  End If

End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_DrawRawLine {*textBox.tuiTextBox,*rp.RastPort,lpos.l,x.l,y:: /
;/ .l,x2.l}                                                                    /
;/                                                                             /
;/ Description:
;/ Draw a text line at the given coordinates.                                                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/ - lpos.l    : ???                                                           /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/ - x2.l    : ???                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_DrawRawLine{*textBox.tuiTextBox,*rp.RastPort,lpos.l,x.l,y.l,x2.l}
xpos.l = x

;   SetAPen_ *rp,4
;    RectFill_ *rp,x,y,x2,y+\rowheight-1
;   Delay_ 1

skipx.l = 0
!line_use{*tline, lpos}
If *tline
  If *tline\text
    If \selection_end_lpos>=lpos AND \selection_begin_lpos<=lpos
      If \selection_begin_lpos=lpos Then cpos1.l = \selection_begin_cpos : Else cpos1=0
      If \selection_end_lpos  =lpos Then cpos2.l = \selection_end_cpos   : Else cpos2=*tline\clength
      If cpos2>*tline\clength Then cpos2=*tline\clength
      If cpos1>*tline\clength Then cpos1=*tline\clength
    Else
      cpos1=0 : cpos2=0
    End If

    If cpos1>0
      Move_ *rp,xpos,y+*rp\TxBaseline
      If \tuiPenN[#TUITBPEN_BG]><#TUIPEN_TRANSPARENT Then SetBPen_ *rp,\penN[#TUITBPEN_BG] : SetDrMd_ *rp,#JAM2
      SetAPen_ *rp,\penN[#TUITBPEN_TEXT]
      xpos = _tb_Text{ *textBox,*rp,*tline\text,cpos1,&skipx.l}
    End If

    If cpos2>0
      Move_ *rp,xpos,y+*rp\TxBaseline
      SetBPen_ *rp,\penS[#TUITBPEN_BG] : SetDrMd_ *rp,#JAM2
      SetAPen_ *rp,\penS[#TUITBPEN_TEXT]
      xpos=_tb_Text{ *textBox,*rp,*tline\text+cpos1,cpos2-cpos1,&skipx}
      If \tuiPenN[#TUITBPEN_BG]=#TUIPEN_TRANSPARENT Then SetDrMd_ *rp,#JAM1
    End If

    If cpos2<*tline\clength
      Move_ *rp,xpos,y+*rp\TxBaseline
      If \tuiPenN[#TUITBPEN_BG]><#TUIPEN_TRANSPARENT Then SetBPen_ *rp,\penN[#TUITBPEN_BG] : SetDrMd_ *rp,#JAM2
      SetAPen_ *rp,\penN[#TUITBPEN_TEXT]
      xpos = _tb_Text{*textBox, *rp,*tline\text+cpos2,*tline\clength-cpos2,&skipx}
    End If

  End If
End If

xpos + skipx

If (xpos-x+1)>\totalWidth Then ntui_SetAttr{*textBox,#TUITBA_TOTALWIDTH ,xpos-x+1}

If xpos<=x2
  If \tuiPenN[#TUITBPEN_BG]><#TUIPEN_TRANSPARENT
    If ((*textBox\edflags&#TUITBF_BLOCKSELECT)=0) Then SetAPen_ *rp,\penN[#TUITBPEN_BG] : Else SetAPen_ *rp,*rp\BgPen
 ;   SetAPen_ *rp,3
    RectFill_ *rp,xpos,y,x2,y+\rowheight-1
  EndIf
End If

End Statement

Macro _tb_StyledText
  Move_ *rp,xpos,y+*rp\TxBaseline
  plen.l = *tline\clength-cpos
  If plen>clen Then plen=clen
  xpos2.l = _tb_Text{*textBox, *rp,*tline\text+cpos,plen,&skipx.l}

  If boxed
    SetAPen_ *rp,*penA\pen[#TUITBPEN_TEXT]
    bbox.tuiRect\left=xpos,y,xpos2-2,y
    _ntui_DrawDottedLine{\obj\engine,*rp,bbox,-1,2}

    bbox.tuiRect\left=xpos,y+*rp\TxHeight-1,xpos2-2,y+*rp\TxHeight-1
    _ntui_DrawDottedLine{\obj\engine,*rp,bbox,-1,2}
    SetAPen_ *rp,*penA\pen[fgTBPen]
  End If

  If warn
    SetAPen_ *rp,\obj\engine\pen[warnPen]
    For lx.l=xpos To xpos2 Step 4
      Move_ *rp,lx,y+*rp\TxHeight-2
      Draw_ *rp,lx+1,y+*rp\TxHeight-2
      Move_ *rp,lx+2,y+*rp\TxHeight-1
      Draw_ *rp,lx+3,y+*rp\TxHeight-1
    Next
    SetAPen_ *rp,*penA\pen[fgTBPen]
  End If

  xpos = xpos2
End Macro


NEWTYPE.penA
  pen.l[#TUITBPEN_MAX]
End NEWTYPE

Statement _tb_SetFontStyle{*textBox.tuiTextBox,*rp.RastPort,flags.l}

  If flags&#TUIF_BOLD
    If flags&#TUIF_ITALIC
      SetFont_ *rp,*textBox\fontBI
      SetSoftStyle_ *rp,#FSF_ITALIC,#FSF_ITALIC
    Else
      SetFont_ *rp,*textBox\fontB
      SetSoftStyle_ *rp,#FS_NORMAL,#FSF_ITALIC
    End If
    SetSoftStyle_ *rp,#FSF_BOLD,#FSF_BOLD
  Else
    If flags&#TUIF_ITALIC
      SetFont_ *rp,*textBox\fontI
      SetSoftStyle_ *rp,#FSF_ITALIC,#FSF_ITALIC
    Else
      SetFont_ *rp,*textBox\font
      SetSoftStyle_ *rp,#FS_NORMAL,#FSF_ITALIC
    End If
    SetSoftStyle_ *rp,#FS_NORMAL,#FSF_BOLD
  End If

  If flags&#TUIF_UNDERLINED Then SetSoftStyle_ *rp,#FSF_UNDERLINED,#FSF_UNDERLINED : Else SetSoftStyle_ *rp,#FS_NORMAL,#FSF_UNDERLINED

End Statement

Statement _tb_DrawStyledLine{*textBox.tuiTextBox,*rp.RastPort,lpos.l,x.l,y.l,x2.l}

  xpos.l = x
  !line_use{*tline, lpos}
  If *tline

    If (*tline\flags&#TUITBLF_STYLED)=0
      minlpos.l = lpos+1
      maxlpos.l = lpos-1
      curlpos.l = lpos
    
      Repeat
        more.l = False
        If \styleCB
          !line_use{*xtline,curlpos}
          If *xtline
            !_CallFuncPointer{\styleCB,result.l,*textBox,curlpos,*xtline}
            If result = #TUISCB_NEXT Then curlpos+1 : more=True : If curlpos>maxlpos Then maxlpos=curlpos
            If result = #TUISCB_PREV Then curlpos-1 : more=True : If curlpos<minlpos Then minlpos=curlpos 
            If result = #TUISCB_DONE AND curlpos<lpos Then curlpos+1 : more=True
          End If
        Else
          *tline\flags = (*tline\flags|#TUITBLF_STYLED)
          result = #TUISCB_DONE
        End If
        
      Until more=False
    End If

    If minlpos<maxlpos Then _tb_Damage{*textBox,minlpos,maxlpos}

    fontFlags.l = 0

    ;SetSoftStyle_ *rp,#FS_NORMAL,#FSF_BOLD
    ;SetSoftStyle_ *rp,#FS_NORMAL,#FSF_UNDERLINED
    ;SetSoftStyle_ *rp,#FS_NORMAL,#FSF_ITALIC
    _tb_SetFontStyle{*textBox,*rp,fontFlags}
    fgTBPen.l = #TUITBPEN_TEXT
    bgTBPen.l = #TUITBPEN_BG
    warn.l    = False
    boxed.l   = False
    skip.l    = 0
    skipx.l   = 0
    warnPen.l = #TUIPEN_RED
    *penA.penA = &*textBox\penN[0]

    If \selection_end_lpos>lpos AND \selection_begin_lpos<lpos
      *penA = &*textBox\penS[0]
    End If
    
    If \selection_begin_lpos=lpos
      _tb_SetStyleCommand{*tline,\selection_begin_cpos,#TUITBSC_MARKED,1}
    End If
    
    If \selection_end_lpos=lpos
      If \selection_begin_lpos<lpos
        *penA = &*textBox\penS[0]
      End If
      _tb_SetStyleCommand{*tline,\selection_end_cpos,#TUITBSC_MARKED,0}
    End If
    ;_tb_DebugCommand{*tline,*rp,\obj\bbox\left,\obj\ibox\top+10}

    SetAPen_ *rp,*penA\pen[fgTBPen]
    If \tuiPenN[bgTBPen]=#TUIPEN_TRANSPARENT Then SetDrMd_ *rp,#JAM1:Else SetDrMd_ *rp,#JAM2 : SetBPen_ *rp,*penA\pen[bgTBPen]

    If *tline\text
      *sc.styleCommand = Null
      If *tline\sclength>0 Then *sc = *tline\style
      cpos.l = 0
      While cpos<*tline\clength
        If *sc
          clen.l = (*sc\clength)&$FF - skip
          If clen > 0
            !_tb_StyledText
            cpos + clen
          Else
            skip = -clen
          End If

          Select *sc\command
            Case #TUITBSC_RESET
              fontFlags.l = 0
              _tb_SetFontStyle{*textBox,*rp,fontFlags}
              ;SetSoftStyle_ *rp,#FS_NORMAL,#FSF_BOLD
              ;SetSoftStyle_ *rp,#FS_NORMAL,#FSF_UNDERLINED
              ;SetSoftStyle_ *rp,#FS_NORMAL,#FSF_ITALIC
              fgTBPen.l = #TUITBPEN_TEXT
              bgTBPen.l = #TUITBPEN_BG
              warn.l    = False
              boxed.l   = False

            Case #TUITBSC_SKIP
              cpos + *sc\data1
              skip + *sc\data1

            Case #TUITBSC_BOLD
              ;If *sc\data1 Then SetSoftStyle_ *rp,#FSF_BOLD,#FSF_BOLD : Else SetSoftStyle_ *rp,#FS_NORMAL,#FSF_BOLD
              If *sc\data1 Then fontFlags|#TUIF_BOLD : Else fontFlags|#TUIF_BOLD - #TUIF_BOLD
              _tb_SetFontStyle{*textBox,*rp,fontFlags}

            Case #TUITBSC_HLC
              If *sc\data1 
                _tb_SetFontStyle{*textBox,*rp,fontFlags|#TUIF_BOLD}
              Else
                _tb_SetFontStyle{*textBox,*rp,fontFlags}
              End If

            Case #TUITBSC_ITALIC
              ;If *sc\data1 Then SetSoftStyle_ *rp,#FSF_ITALIC,#FSF_ITALIC : Else SetSoftStyle_ *rp,#FS_NORMAL,#FSF_ITALIC
              If *sc\data1 Then fontFlags|#TUIF_ITALIC : Else fontFlags|#TUIF_ITALIC - #TUIF_ITALIC
              _tb_SetFontStyle{*textBox,*rp,fontFlags}

            Case #TUITBSC_UNDERLINED
              ;If *sc\data1 Then SetSoftStyle_ *rp,#FSF_UNDERLINED,#FSF_UNDERLINED : Else SetSoftStyle_ *rp,#FS_NORMAL,#FSF_UNDERLINED
              If *sc\data1 Then fontFlags|#TUIF_UNDERLINED : Else fontFlags|#TUIF_UNDERLINED - #TUIF_UNDERLINED
              _tb_SetFontStyle{*textBox,*rp,fontFlags}

            Case #TUITBSC_FGPEN
              If *sc\data1>=0 Then fgTBPen = *sc\data1 : SetAPen_ *rp,*penA\pen[fgTBPen]

            Case #TUITBSC_BGPEN
              If *sc\data1>=0
                bgTBPen = *sc\data1
                If \tuiPenN[bgTBPen]=#TUIPEN_TRANSPARENT Then SetDrMd_ *rp,#JAM1:Else SetDrMd_ *rp,#JAM2 : SetBPen_ *rp,*penA\pen[bgTBPen]
              End If

            Case #TUITBSC_WARN
              warn = *sc\data1
              If *sc\data2>=0 Then warnPen = *sc\data2

            Case #TUITBSC_BOXED
              If *sc\data1
                If boxed=False
                  boxed=True
                  bbox.tuiRect\left=xpos,y,xpos-1,y+*rp\TxHeight-1
                  _ntui_DrawDottedLine{\obj\engine,*rp,bbox,-1,2}
                End If
              Else
                If boxed
                  bbox.tuiRect\left=xpos-1,y,xpos-1,y+*rp\TxHeight-1
                  _ntui_DrawDottedLine{\obj\engine,*rp,bbox,-1,2}
                  boxed=False
                End If
              End If

            Case #TUITBSC_MARKED
              If *sc\data1=0 Then *penA = &*textBox\penN[0] : Else *penA = &*textBox\penS[0]
              SetAPen_ *rp,*penA\pen[fgTBPen]
              If \tuiPenN[bgTBPen]=#TUIPEN_TRANSPARENT Then SetDrMd_ *rp,#JAM1:Else SetDrMd_ *rp,#JAM2 : SetBPen_ *rp,*penA\pen[bgTBPen]

            Default
              ; unkown command
          End Select
          *sc + SizeOf.styleCommand
          If (*sc-*tline\style)/SizeOf.styleCommand>=*tline\sclength Then *sc=Null
        Else
          clen = *tline\clength-cpos
          If clen > 0
            !_tb_StyledText
            cpos + clen
          End If
        End If
      Wend
    End If

    If \selection_begin_lpos=lpos
      _tb_RemStyleCommand{*tline,\selection_begin_cpos,\selection_begin_cpos,#TUITBSC_MARKED}
    End If

    If \selection_end_lpos=lpos
      _tb_RemStyleCommand{*tline,\selection_end_cpos,\selection_end_cpos,#TUITBSC_MARKED}
    End If
    ;_tb_DebugCommand{*tline,*rp,\obj\bbox\left,\obj\ibox\top+100}
  End If

  xpos + skipx
  If (xpos-x+1)>\totalWidth Then ntui_SetAttr{*textBox,#TUITBA_TOTALWIDTH ,xpos-x+1}

  If xpos<=x2
    If \tuiPenN[#TUITBPEN_BG]><#TUIPEN_TRANSPARENT
;      If ((*textBox\edflags&#TUITBF_BLOCKSELECT)=0) Then SetAPen_ *rp,\penN[#TUITBPEN_BG] : Else SetAPen_ *rp,*penA\pen[#TUITBPEN_BG]
      SetAPen_ *rp,*penA\pen[bgTBPen]
      RectFill_ *rp,xpos,y,x2,y+\rowheight-1
    EndIf
  End If

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_ShowBrackets {*textBox.tuiTextBox}                           /
;/                                                                             /
;/ Description:                                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_ShowBrackets{*textBox.tuiTextBox}
  ;If *textBox\edflags & #TUITBF_SHOWBRACKETS) = 0 Then Statement Return
  If \bracket1_lpos>=0 AND \bracket2_lpos>=0
    !line_use{*tline,\bracket1_lpos}
    If *tline = Null Then Statement Return
    _tb_SetStyleCommand{*tline, \bracket1_cpos, #TUITBSC_HLC, 1}
    _tb_SetStyleCommand{*tline, \bracket1_cpos+1, #TUITBSC_HLC, 0}
      
    !line_use{*tline,\bracket2_lpos}
    If *tline = Null Then Statement Return
    _tb_SetStyleCommand{*tline, \bracket2_cpos, #TUITBSC_HLC, 1}
    _tb_SetStyleCommand{*tline, \bracket2_cpos+1, #TUITBSC_HLC, 0}

    _tb_Damage{*textBox,\bracket1_lpos,\bracket2_lpos}
  End If
  
End Statement


Statement _tb_HideBrackets{*textBox.tuiTextBox}
  ;If *textBox\edflags & #TUITBF_SHOWBRACKETS) = 0 Then Statement Return
  If \bracket1_lpos>=0 AND \bracket2_lpos>=0
    !line_use{*tline,\bracket1_lpos}
    If *tline = Null Then Statement Return
    _tb_RemStyleCommand{*tline, \bracket1_cpos, \bracket1_cpos+1, #TUITBSC_HLC}
    
    !line_use{*tline,\bracket2_lpos}
    If *tline = Null Then Statement Return
    _tb_RemStyleCommand{*tline, \bracket2_cpos, \bracket2_cpos+1, #TUITBSC_HLC}      
    
    _tb_Damage{*textBox,\bracket1_lpos,\bracket2_lpos}
  End If
  
End Statement

Function.l _tb_UpdateBrackets{*textBox.tuiTextBox, lpos.l, cpos.l}
  If ((*textBox\edflags & #TUITBF_SHOWBRACKETS) = 0) Then Function Return False
  _tb_HideBrackets{*textBox}
  *textBox\bracket1_cpos = -1
  *textBox\bracket1_lpos = -1
  *textBox\bracket1_char = 0
  *textBox\bracket2_cpos = -1
  *textBox\bracket2_lpos = -1
  *textBox\bracket2_char = 0
  copen.b = 0
  cclose.b = 0
  !line_use{*tline,lpos}
  If *tline = Null Then Function Return False
  If *tline\clength <= 0 Then Function Return False
  
  If cpos<0 Then cpos=0 : Else If cpos>=*tline\clength Then cpos=*tline\clength-1
  c.b = Peek.b(*tline\text+cpos)

  If c = @"(" OR c = @"{" OR c = @"[" OR c = @")" OR c = @"}" OR c = @"]"
    ; ok
  Else
    cpos - 1
    If cpos >= 0 Then c = Peek.b(*tline\text+cpos)
    ;If c = @"(" OR c = @"{" OR c = @"[" OR c = @")" OR c = @"}" OR c = @"]"
      ; ok
    ;Else
    ;  cpos + 1
    ;  If cpos < *tline\clength Then cpos + 1 : c = Peek.b(*tline\text+cpos)
    ;End If
  End If

  If c = @"(" OR c = @"{" OR c = @"["
    *textBox\bracket1_cpos = cpos
    *textBox\bracket1_lpos = lpos
    *textBox\bracket1_char = c
    copen = c
    Select c
      Case @"(" : cclose = @")"
      Case @"{" : cclose = @"}"
      Case @"[" : cclose = @"]"
    End Select
  End If
  
  If c = @")" OR c = @"}" OR c = @"]"
    *textBox\bracket2_cpos = cpos
    *textBox\bracket2_lpos = lpos
    *textBox\bracket2_char = c
    cclose = c
    Select c
      Case @")" : copen = @"("
      Case @"}" : copen = @"{"
      Case @"]" : copen = @"["
    End Select
  End If
    
  ; no bracket under cursor
  If *textBox\bracket1_char = 0 AND *textBox\bracket2_char = 0 Then Function Return False;
    
  If *textBox\bracket1_char = 0
    nest.l = 0
    While lpos>=0
      !line_use{*tline,lpos}
      If *tline
        If cpos<0 Then cpos=*tline\clength-1 : Else If cpos>=*tline\clength Then cpos=*tline\clength-1
        While cpos>=0
          c.b = Peek.b(*tline\text+cpos)
          If c=copen
            nest - 1
            If nest = 0
              *textBox\bracket1_cpos = cpos
              *textBox\bracket1_lpos = lpos
              *textBox\bracket1_char = c
              _tb_ShowBrackets{*textBox}
              Function Return True ; found!
            End If
          End If
          If c=cclose
            nest + 1
          End If
          cpos-1
        Wend
      End If
      lpos-1
    Wend
  End If

  If *textBox\bracket2_char = 0
    nest.l = 0
    While lpos < *textBox\totalLines    
      !line_use{*tline,lpos}
      If *tline
        While cpos < *tline\clength
          c.b = Peek.b(*tline\text+cpos)
          If c=cclose
            nest - 1
            If nest = 0
              *textBox\bracket2_cpos = cpos
              *textBox\bracket2_lpos = lpos
              *textBox\bracket2_char = c
              _tb_ShowBrackets{*textBox}
              Function Return True ; found!
            End If
          End If
          If c=copen
            nest+1
          End If
          cpos+1
        Wend
      End If
      lpos+1
      cpos=0
    Wend
  End If

  Function Return False
  
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_CheckTextBoxString {*textBox.tuiTextBox}                    /
;/                                                                             /
;/ Description:                                                                /
;/ Copy the text from a textbox into the string/value parameter of String/NumString Objects.
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : textbox object                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ntui_UpdateTextBoxString_deprecated{*textBox.tuiTextBox}

  Select *textBox\subClassID
    Case #TUITB_STRING_NUMERIC
      !line_use{*tline, 0}
      value.l=*textBox\obj\value
      If *tline
        If *tline\text
          string.s    = Peeks$(*tline\text,*tline\clength)
          string.s    = Replace$(string,"+","")
          value.l     = Vallong(string)
          If value<*textBox\numMin Then value = *textBox\numMin
          If value>*textBox\numMax Then value = *textBox\numMax
          newstring.s = Str$(value)
          If newstring><string
            If *tline\blength<=FLen(newstring)
              nl.l = FLen(newstring)+1+8
              If ((*tline\flags&#TUITBLF_STOLEN)=0) Then FreeMem_ *tline\text ,*tline\blength : Else *tline\flags-#TUITBLF_STOLEN
              *tline\text = AllocMem_ (nl,#MEMF_ANY)
              *tline\blength = nl
            End If
            *tline\clength = FLen(newstring)
            Poke.s *tline\text,newstring
          End If
        End If
      End If
      *textBox\obj\value=value

    ;Case #TUITB_STRING
      ;!line_use{*tline, 0}
      ;If *tline
      ;  If *tline\text
      ;    str_WritePtr{&*textBox\obj\string,*tline\text,*tline\clength}
      ;  End If
      ;End If

  End Select

End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ntui_DrawTextBox {*textBox.tuiTextBox,x1.l,y1.l,x2.l,y2.l,*rp:: /
;/ .RastPort}                                                                  /
;/                                                                             /
;/ Description:                                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - x1.l    : ???                                                             /
;/ - y1.l    : ???                                                             /
;/ - x2.l    : ???                                                             /
;/ - y2.l    : ???                                                             /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
;SHARED countxxx.l

Statement _ntui_DrawTextBoxIntern{*textBox.tuiTextBox,x1.l,y1.l,x2.l,y2.l,*rp.RastPort}
  !_ASSERT{*textBox}

  If *rp=Null OR *rp=-1 OR \rowheight<=0 Then Statement Return
  *engine.tuiEngine = *textBox\obj\engine

;  *textBox\tuiPenN[#TUITBPEN_BG]  = bgTuiPen
;  If bgTuiPen><#TUIPEN_TRANSPARENT Then *textBox\pen[#TUITBPEN_BG] = *engine\pen[bgTuiPen] : Else *textBox\pen[#TUITBPEN_BG]=0

  SetFont_ *rp,\font
  If *textBox\obj\flags&#TUIF_BOLD   Then SetSoftStyle_ *rp,#FSF_BOLD,#FSF_BOLD
  If *textBox\obj\flags&#TUIF_ITALIC Then SetSoftStyle_ *rp,#FSF_ITALIC,#FSF_ITALIC

  mx.l = *textBox\obj\cbox\right
  my.l = *textBox\obj\cbox\bottom

  If x1<*textBox\obj\cbox\left   OR x1=-1 Then x1 = *textBox\obj\cbox\left
  If y1<*textBox\obj\cbox\top    OR y1=-1 Then y1 = *textBox\obj\cbox\top
  If x2>*textBox\obj\cbox\right  OR x2=-1 Then x2 = *textBox\obj\cbox\right
  If y2>*textBox\obj\cbox\bottom OR y2=-1 Then y2 = *textBox\obj\cbox\bottom

  tbx.l = *textBox\obj\cbox\left ;innerPos\x
  tby.l = *textBox\obj\cbox\top  ;innerPos\y

  lpos_a.l = (y1-tby)/\rowheight
  If lpos_a<0 Then lpos_a=0
  y.l      = lpos_a * \rowheight + tby

  If *textBox\tuiPenN[#TUITBPEN_BG]><#TUIPEN_TRANSPARENT
    SetAPen_ *rp,*textBox\penN[#TUITBPEN_BG]

    If y>y1 ; top padding
      SetAPen_ *rp,\penN[#TUITBPEN_BG]
      RectFill_ *rp,x1,y1,x2,y-1
    End If

    If tbx>x1 ; left padding
      SetAPen_ *rp,\penN[#TUITBPEN_BG]
      RectFill_ *rp,x1,y1,tbx-1,y2
    End If
    SetBPen_ *rp,\penN[#TUITBPEN_BG]
    SetDrMd_ *rp,#JAM2
  Else
    SetDrMd_ *rp,#JAM1
  EndIf

  lpos_a   + \topLine
  If lpos_a<0 Then lpos_a=0

  lpos_b.l = (y2-tby)/\rowheight +\topLine
  If lpos_b<0 Then lpos_b=0
  If lpos_b>\totalLines-1 Then lpos_b = \totalLines-1

  x.l      = tbx - \leftOffset

  SetAPen_ *rp,\penN[#TUITBPEN_TEXT]

  cbox.tuiRect\left = x1,y1,x2,y2
  *oldRegion.Region = ntui_AddClip{*rp,&cbox}
  _tb_DoBlink{*textBox,*rp,Off}

  If \styleCB><Null ;tokenizing=False
    For lpos.l = lpos_a To lpos_b
      _tb_DrawStyledLine{*textBox,*rp,lpos,x,y,x2}
      y + \rowheight
    Next
  Else
    For lpos.l = lpos_a To lpos_b
      _tb_DrawRawLine{*textBox,*rp,lpos,x,y,x2}
      y + \rowheight
    Next
  End If

  y = (\totalLines-\topLine)*\rowheight +tby

  If *textBox\totalLines<=1 AND lpos_a = 0
    drawHint.l = True
    !line_use{*tline, 0}
    If *tline
      If *tline\clength>0 Then drawHint=False
    End If
    If str_Len{*textBox\hint}<=0 Then drawHint=False
    If drawHint
      SetAPen_ *rp,*textBox\penN[#TUITBPEN_HINTTEXT]
      Move_ *rp,tbx,tby+*rp\TxBaseline
      _tb_Text{*textBox,*rp,str_GetPtr{*textBox\hint},str_Len{*textBox\hint},&skipx.l}
      y + \rowheight
    End If
  End If

  If *textBox\obj\flags&(#TUIF_ACTIVE|#TUIF_FOCUS)
    ;_tb_DoBlink{*textBox,*rp,On}
   ; _tb_ShowBrackets{*textBox,*rp}
  End If

  If y<=y2 AND *textBox\tuiPenN[#TUITBPEN_BG]><#TUIPEN_TRANSPARENT
    SetAPen_ *rp,\penN[#TUITBPEN_BG]
    RectFill_ *rp,x1,y,x2,y2
  End If

  If y<=y2 AND *textBox\subClassID=#TUITB_TEXTBOX
    ;SetAPen_ *rp,*engine\pen[#TUIPEN_HALFSHINE]
    ;Move_* rp,x1,y : Draw_ *rp,x2,y
    DEFTYPE.tuiRect dotLine
    dotLine\left = x1,y,x2,y
    _ntui_DrawDottedLine{*engine,*rp,dotLine,*textBox\tuiPenN[#TUITBPEN_TEXT],4}
    y+1
  End If

  ntui_RemClip{*rp,*oldRegion}

End Statement

Statement __tb_UpdateCursorPixelPos_dep{*textBox.tuiTextBox,*rp.RastPort}
\cursor_pixpos = _tb_pos2x{*textBox,\cursor_lpos,\cursor_cpos,*rp}
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_Scroll {*textBox.tuiTextBox,dx.l,dy.l,upd.l}                    /
;/                                                                             /
;/ Description:                                                                /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                              /
;/ - dx.l    : ???                                                             /
;/ - dy.l    : ???                                                             /
;/ - upd.l    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_Scroll{*textBox.tuiTextBox,dx.l,dy.l,*rp.RastPort}
If *rp Then *win.Window  = *rp\Layer\Window : Else *win   = Null

If dy><0
  oldtop.l = \topLine
  \topLine + dy
 ; If \topLine>(\totalLines - *textBox\innerSize\y/\rowheight) Then \topLine=(\totalLines - *textBox\innerSize\y/\rowheight)
  If \topLine>(\totalLines - *textBox\visibleLines) Then \topLine=(\totalLines - *textBox\visibleLines)
  If \topLine<0 Then \topLine=0

  dypix.l = (\topLine-oldtop) * \rowheight
  If dypix><0 AND *rp><Null
    If (Abs(dypix)<!tuiRectWidth{*textBox\obj\cbox}) AND (*textBox\edflags&#TUITBF_REDRAWONSCROLL=0)
      If *win
        ScrollWindowRaster_ *win,0,dypix,*textBox\obj\cbox\left,*textBox\obj\cbox\top,*textBox\obj\cbox\right,*textBox\obj\cbox\bottom
      Else
        If *rp Then ScrollRasterBF_ *rp,0,dypix,*textBox\obj\cbox\left,*textBox\obj\cbox\top,*textBox\obj\cbox\right,*textBox\obj\cbox\bottom
      End If
      If dypix<0
        _ntui_DrawTextBoxIntern{*textBox,-1,-1,-1,*textBox\obj\cbox\top-dypix,*rp}
      Else
        _ntui_DrawTextBoxIntern{*textBox,-1,*textBox\obj\cbox\bottom+1-dypix,-1,-1,*rp}
      End If
    Else
      _ntui_DrawTextBoxIntern{*textBox,-1,-1,-1,-1,*rp}
    End If
  End If
End If

If dx><0
  oldx.l = \leftOffset
  \leftOffset + dx
  If \leftOffset<0 Then \leftOffset=0
  dxpix.l = (\leftOffset-oldx)
  If dxpix><0 AND *rp><Null
    If (Abs(dxpix)<!tuiRectWidth{*textBox\obj\cbox}) AND (*textBox\edflags&#TUITBF_REDRAWONSCROLL=0)
      If *win
        ScrollWindowRaster_ *win,dxpix,0,*textBox\obj\cbox\left,*textBox\obj\cbox\top,*textBox\obj\cbox\right,*textBox\obj\cbox\bottom
      Else
        If *rp Then ScrollRasterBF_ *rp,dxpix,0,*textBox\obj\cbox\left,*textBox\obj\cbox\top,*textBox\obj\cbox\right,*textBox\obj\cbox\bottom
      End If

      If dxpix<0
        _ntui_DrawTextBoxIntern{*textBox,-1,-1,*textBox\obj\cbox\left-dxpix,-1,*rp}
      Else
        _ntui_DrawTextBoxIntern{*textBox,*textBox\obj\cbox\right-dxpix+1,-1,-1,-1,*rp}
      End If
    Else
      _ntui_DrawTextBoxIntern{*textBox,-1,-1,-1,-1,*rp}
    End If
  End If
End If
End Statement




;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_ScrollTo {*textBox.tuiTextBox,lpos.l,cpos.l}                 /
;/                                                                             /
;/ Description:                                                                /
;/   ;_tb_update_scroller{*textBox,upd}                                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - cpos.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_ScrollTo{*textBox.tuiTextBox,lpos.l,cpos.l,*rp.RastPort}
If *textBox
  If lpos<\topLine+\scrollborder_y Then ntui_SetAttr{*textBox,#TUITBA_TOPLINE,lpos-\scrollborder_y};_tb_Scroll{*textBox,0,lpos-\topLine-\scrollborder_y,*rp}
;  If lpos>\topLine+*textBox\innerSize\y/\rowheight-1-\scrollborder_y Then _tb_Scroll{*textBox,0,lpos-\topLine-*textBox\innerSize\y/\rowheight+1+\scrollborder_y,*rp}
  If lpos>\topLine+*textBox\visibleLines-1-\scrollborder_y Then ntui_SetAttr{*textBox,#TUITBA_TOPLINE,lpos-\visibleLines+1+\scrollborder_y};_tb_Scroll{*textBox,0,lpos-\topLine-\visibleLines+1+\scrollborder_y,*rp}

  pixpos.l = _tb_pos2x{*textBox,lpos,cpos,*rp} - \leftOffset
  If pixpos<\scrollborder_x Then ntui_SetAttr{*textBox,#TUITBA_LEFTOFFSET,pixpos-\scrollborder_x+\leftOffset};_tb_Scroll{*textBox,pixpos-\scrollborder_x,0,*rp}
;  If pixpos>*textBox\innerSize\x-\rowheight-\scrollborder_x Then _tb_Scroll{*textBox,pixpos-*textBox\innerSize\x+\rowheight+\scrollborder_x,0,*rp}
  If pixpos>!tuiRectWidth{*textBox\obj\cbox}-\scrollborder_x Then ntui_SetAttr{*textBox,#TUITBA_LEFTOFFSET,pixpos-!tuiRectWidth{*textBox\obj\cbox}+\scrollborder_x+\leftOffset}
  ;_tb_Scroll{*textBox,pixpos-!tuiRectWidth{*textBox\obj\cbox}+\scrollborder_x,0,

End If
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_ScrollToSelect {*textBox.tuiTextBox}                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_ScrollToSelection{*textBox.tuiTextBox,*rp.RastPort}
If *textBox
  If \selection_begin_lpos>=0 Then _tb_ScrollTo{*textBox,\selection_begin_lpos,\selection_begin_cpos,*rp}
  If \selection_end_lpos>=0 Then _tb_ScrollTo{*textBox,\selection_end_lpos,\selection_end_cpos,*rp}
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_ScrollToCursor {*textBox.tuiTextBox}                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_ScrollToCursor{*textBox.tuiTextBox,*rp.RastPort}
If *textBox
  _tb_ScrollTo{*textBox,*textBox\cursor_lpos,*textBox\cursor_cpos,*rp}
End If
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_RedrawDamaged {*textBox.tuiTextBox}                          /
;/                                                                             /
;/ Description:                                                                /
;/     ;minlpos.l = Min(\selection_end_lpos,lpos2)                                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_Repair{*textBox.tuiTextBox,*rp.RastPort}

  If *textBox
    While *textBox\damage_begin_lpos<=*textBox\damage_end_lpos
      If (*rp><Null) AND (*textBox\obj\flags&#TUIF_ONSCREEN><0)
        If *textBox\damage_begin_lpos < *textBox\topLine Then *textBox\damage_begin_lpos = *textBox\topLine
        If *textBox\damage_end_lpos   > *textBox\topLine+*textBox\visibleLines Then *textBox\damage_end_lpos = *textBox\topLine + *textBox\visibleLines
        If *textBox\damage_begin_lpos<=*textBox\damage_end_lpos
          y1.l = _tb_line2y{*textBox,*textBox\damage_begin_lpos} + *textBox\obj\cbox\top ;innerPos\y
          y2.l = _tb_line2y{*textBox,*textBox\damage_end_lpos}   + *textBox\obj\cbox\top + \rowheight-1

          *textBox\damage_begin_lpos = 0
          *textBox\damage_end_lpos   = -1

          _ntui_DrawTextBoxIntern{*textBox,-1,y1,-1,y2,*rp}

        End If
      Else
        *textBox\damage_begin_lpos = 0
        *textBox\damage_end_lpos   = -1
      End If

    Wend

    If \damage_binding
      If *textBox\maxLines><1
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_VTOTAL  ,*textBox\totalLines   ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_VVALUE  ,*textBox\topLine      ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_VVISIBLE,*textBox\visibleLines ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_VSTEP   ,*textBox\step_\y      ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_HTOTAL  ,*textBox\totalWidth   ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_HVALUE  ,*textBox\leftOffset   ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_HVISIBLE,*textBox\visibleWidth ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_HSTEP   ,*textBox\step_\x      ,Null}
      End If
      _ntui_PropagateBind{*textBox,#TUIEV_BIND_VALUE   ,*textBox\obj\value,Null}
      ntui_GetAttr{*textBox,#TUITBA_TEXT,(.longP)&l.l} ; this reads out obj\string
      _ntui_PropagateBind{*textBox,#TUIEV_BIND_STRING  ,*textBox\obj\value,*textBox\obj\string}
    End If
    \damage_binding = False
  End If

End Statement





;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_SetSelection {*textBox.tuiTextBox,@lpos1.l,@cpos1.l,@lpos2.l,:: /
;/ @cpos2.l,@*rp.RastPort}                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos1.l    : ???                                                          /
;/ - cpos1.l    : ???                                                          /
;/ - lpos2.l    : ???                                                          /
;/ - cpos2.l    : ???                                                          /
;/ - upd.l    : ???                                                            /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_SetSelection{*textBox.tuiTextBox,@lpos1.l,@cpos1.l,@lpos2.l,@cpos2.l}
  If lpos2<lpos1 Then Exchange lpos1,lpos2 : Exchange cpos1,cpos2
  If lpos2=lpos1 AND cpos1>cpos2 Then Exchange cpos1,cpos2
  If cpos1<0 Then cpos1=0
  If cpos2<0 Then cpos2=0

  !line_use{*tline, lpos1}
  If *tline
    If cpos1>*tline\clength Then cpos1=*tline\clength
  End If
  !line_use{*tline, lpos2}
  If *tline
    If cpos2>*tline\clength Then cpos2=*tline\clength
  End If

  If lpos1=-1 ; remove selection
    minlpos.l = \selection_begin_lpos
    maxlpos.l = \selection_end_lpos
  Else
    If \selection_begin_lpos=-1 ; add selection
      minlpos = lpos1
      maxlpos = lpos2
    Else

      succ.l = False
      If lpos1><\selection_begin_lpos
        minlpos.l = Min(\selection_begin_lpos,lpos1)
        maxlpos.l = Max(\selection_begin_lpos,lpos1)
        If lpos2><\selection_end_lpos
          ;minlpos.l = Min(\selection_end_lpos,lpos2)
          maxlpos.l = Max(\selection_end_lpos,lpos2)
        End If
      Else
        If lpos2><\selection_end_lpos
          minlpos.l = Min(\selection_end_lpos,lpos2)
          maxlpos.l = Max(\selection_end_lpos,lpos2)
        Else
          If \selection_begin_cpos><cpos1
            minlpos = lpos1
            maxlpos = lpos1
          End If
          If \selection_end_cpos><cpos2
            minlpos = lpos2
            maxlpos = lpos2
          End If
        End If
      End If
    End If
  End If

  If \selection_begin_cpos><cpos1 Then \selection_begin_cpos = cpos1  :succ.l = True
  If \selection_end_cpos  ><cpos2 Then \selection_end_cpos   = cpos2  :succ.l = True
  If \selection_begin_lpos><lpos1 Then \selection_begin_lpos = lpos1  :succ.l = True
  If \selection_end_lpos  ><lpos2 Then \selection_end_lpos   = lpos2  :succ.l = True

  If succ=True
    _tb_Damage{*textBox,minlpos,maxlpos}
  End If

End Statement




;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_SetCursor {*textBox.tuiTextBox,lpos.l,cpos.l,@pixupd.l,@lo:: /
;/ ose.l,@*rp.RastPort}                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ Set the cursor to lpos/cpos position and make it visible.                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : the textbox object in question                                      /
;/ - lpos.l    : new line position                                                /
;/ - cpos.l    : new character position in line                                                          /
;/ - pixupd.l  : use this pixel x position as anker for verctial cursor movements                      /
;/ - loose.l   : loose the selection                                                        /
;/ - *rp.RastPort : rastport to draw changes to, can be Null                                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_SetCursor{*textBox.tuiTextBox,lpos.l,cpos.l,@pixupd.l,@loose.l,@*rp.RastPort}

  If *rp=-1 Then *rp=Null
  ;tb_line_settokencase{*textBox.tuiTextBox}
  If lpos>=\totalLines Then lpos=\totalLines-1
  If lpos<0 Then lpos=0
  If cpos<0 Then cpos=0
  If \edflags&#TUITBF_RIGHTWRAP
    !line_use{*tline, lpos}
    If *tline
      clength.l = *tline\clength - _tb_line_hasreturn{*tline}
      If cpos>clength Then cpos = clength
    Else
      cpos=0
    End If
  End If
  \cursor_cpos     = cpos
  \cursor_lpos     = lpos
  If pixupd Then \cursor_pixpos = _tb_pos2x{*textBox,lpos,cpos,*rp}
  If ((\edflags&#TUITBF_LOOSESELECTION)><0) AND loose><False Then _tb_SetSelection{*textBox,-1,-1,-1,-1}
  _tb_ScrollTo{*textBox,\cursor_lpos,\cursor_cpos,*rp}
  If \undo Then ntui_StopUndoStep{\undo}
  _tb_UpdateBrackets{*textBox,lpos,cpos}

End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_MouseDrag {*textBox.tuiTextBox,*rp.RastPort,mx.l,my.l}       /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/ - mx.l    : ???                                                             /
;/ - my.l    : ???                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_MouseDrag{*textBox.tuiTextBox,*rp.RastPort,mx.l,my.l}
If *textBox
  ;mx = \xwin\MouseX - *textBox\obj\pos\x
  ;my = \xwin\MouseY - *textBox\obj\pos\y
  mx +\leftOffset

  lpos1.l = \anker_lpos ;tb_y2line{*textBox,\ry}
  cpos1.l = \anker_cpos ;tb_x2pos {*textBox,lpos1,\rx}

  lpos2.l = _tb_y2line{*textBox,my}
  cpos2.l = _tb_x2pos {*textBox,lpos2,mx,*rp}

  If \edflags&#TUITBF_DRAGCURSOR Then _tb_DoBlink{*textBox,*rp,Off} : _tb_SetCursor{*textBox,lpos2,cpos2,True,False,*rp}


  If lpos1><lpos2 OR cpos1><cpos2
    _tb_SetSelection{*textBox,lpos1,cpos1,lpos2,cpos2}
  End If

  _tb_ScrollTo{*textBox,lpos2,cpos2,*rp}
  Statement Return

  If lpos2<\topLine Then ntui_SetAttr{*textBox,#TUITBA_TOPLINE,\topLine-1};_tb_Scroll{*textBox,0,-1,*rp}
;  If lpos2>=\topLine+*textBox\obj\size\y/\rowheight Then _tb_Scroll{*textBox,0,1,*rp}
  If lpos2>=\topLine+*textBox\visibleLines Then ntui_SetAttr{*textBox,#TUITBA_TOPLINE,\topLine+1};_tb_Scroll{*textBox,0,1,*rp}
  If mx<\leftOffset Then ntui_SetAttr{*textBox,#TUITBA_LEFTOFFSET,\leftOffset-\rowheight};_tb_Scroll{*textBox,-\rowheight,0,*rp}
  If mx>\leftOffset+!tuiRectWidth{*textBox\obj\cbox} Then ntui_SetAttr{*textBox,#TUITBA_LEFTOFFSET,\leftOffset+\rowheight};_tb_Scroll{*textBox,\rowheight,0,*rp}
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_SetCursorXY {*textBox.tuiTextBox,x.l,y.l}                    /
;/                                                                             /
;/ Description:                                                                /
;/   ;mx = \xwin\MouseX - *textBox\obj\pos\x                                /
;/   ;my = \xwin\MouseY - *textBox\obj\pos\y                                /
;/   lpos1.l = \anker_lpos ;tb_y2line{*textBox,\ry}                         /
;/   cpos1.l = \anker_cpos ;tb_x2pos {*textBox,lpos1,\rx}                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_SetCursorByXY{*textBox.tuiTextBox,x.l,y.l,*rp.RastPort}
lpos.l = _tb_y2line{*textBox,y}
cpos.l = _tb_x2pos{*textBox,lpos,x,*rp}
_tb_SetCursor{*textBox,lpos,cpos,True,True,*rp}
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_MouseClick {*textBox.tuiTextBox,*rp.RastPort,mx.l,my.l,mb.:: /
;/ l,dbl.l}                                                                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/ - mx.l    : ???                                                             /
;/ - my.l    : ???                                                             /
;/ - mb.l    : ???                                                             /
;/ - dbl.l    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_MouseClick{*textBox.tuiTextBox,*rp.RastPort,mx.l,my.l,mb.l,dbl.l}

  currentLine.l = *textBox\cursor_lpos
  _tb_SetCursorByXY{*textBox ,mx+\leftOffset,my,*rp}
  If currentLine >< *textBox\cursor_lpos Then dbl=0
  ;_tb_UpdateCursorPixelPos{*textBox,*rp}

  Select dbl
    Case 1
      !line_use{*tline, \cursor_lpos}
      If *tline
        If *tline\text
        cpos.l = _tb_x2pos {*textBox,\anker_lpos,mx+\leftOffset,*rp}
        breakme.l=False
        While cpos>=0 AND breakme=False
          c.b = Peek.b(*tline\text+cpos)
          If (c>=@"A" AND c<=@"Z") OR (c>=@"a" AND c<=@"z") OR (c>=@"0" AND c<=@"9") OR c=@"_" OR c<0
            cpos-1
          Else
            breakme.l = True
            cpos+1
          End If
        Wend
        If cpos<0 Then cpos=0
        apos.l = cpos
        cpos.l = _tb_x2pos {*textBox,\anker_lpos,mx+\leftOffset,*rp}
        breakme.l=False
        While cpos<*tline\clength AND breakme=False
          c.b = Peek.b(*tline\text+cpos)
          If (c>=@"A" AND c<=@"Z") OR (c>=@"a" AND c<=@"z") OR (c>=@"0" AND c<=@"9") OR c=@"_" OR c<0
            cpos+1
          Else
            breakme.l = True
          End If
        Wend
        If cpos>*tline\clength Then cpos=*tline\clength
        _tb_SetSelection{*textBox,\cursor_lpos,apos,\cursor_lpos,cpos}
        End If
      End If

    Case 0
      _tb_SetSelection{*textBox,-1,-1,-1,-1}

    Default
      !line_use{*tline, \cursor_lpos}
      If *tline
        _tb_SetSelection{*textBox,\cursor_lpos,0,\cursor_lpos,*tline\clength}
      End If

  End Select
  \anker_lpos = _tb_y2line{*textBox,my}
  \anker_cpos = _tb_x2pos {*textBox,\anker_lpos,mx+\leftOffset,*rp}

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_MoveCursor {*textBox.tuiTextBox,dx.l,dy.l,shift.l,*rp.Rast:: /
;/ Port}                                                                       /
;/                                                                             /
;/ Description:                                                                /
;/ If mb=1                                                                     /
;/ End If                                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - dx.l    : ???                                                             /
;/ - dy.l    : ???                                                             /
;/ - shift.l    : ???                                                          /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_MoveCursor{*textBox.tuiTextBox,dx.l,dy.l,mark.l,page_.l,*rp.RastPort}

  cpos.l =  \cursor_cpos
  lpos.l =  \cursor_lpos
  pixup.l = False

  ;If (quali & #TUIQUAL_SHIFT) AND (\edflags&#TUITBF_SHIFTSELECT><0)
  If mark
    If \selection_begin_lpos<0 OR \selection_end_lpos<0
      \anker_lpos = lpos
      \anker_cpos = cpos
    End If
  End If

  If dx><0
    ;If shift AND ((\edflags&#TUITBF_SHIFTSELECT)=0)
    If page_
      If dx>0 ; jump to end of line
        !line_use{*tline, lpos}
        If *tline
          cpos = *tline\clength-_tb_line_hasreturn{*tline}
        End If
      Else    ; jump to begin of line
        cpos = 0
      End If
    Else
      cpos+dx
    End If

    If (\edflags&#TUITBF_LEFTWRAP><0)
      While cpos<0
        If lpos>0
          lpos-1
          !line_use{*tline, lpos}
          If *tline
            cpos + *tline\clength
          Else
            cpos + 1
          End If
        Else
          cpos = 0
        End If
      Wend
    Else
      If cpos<0 Then cpos=0
    End If

    If (\edflags&#TUITBF_RIGHTWRAP><0)
      !line_use{*tline, lpos}
      If *tline
        clength.l=*tline\clength ;- _tb_line_hasreturn{*tline}
      Else
        clength=0
      End If

      While cpos>clength
        If lpos<\totalLines-1
          cpos-clength
          lpos+1
          !line_use{*tline, lpos}
          If *tline
            clength=*tline\clength ;- _tb_line_hasreturn{*tline}
          Else
            clength=0
          End If
        Else
          If *tline Then cpos = clength:Else cpos=0
        End If
      Wend

      !line_use{*tline, lpos}
      If *tline
        clength.l=*tline\clength - _tb_line_hasreturn{*tline}
      Else
        clength=0
      End If
      If cpos>clength Then cpos=0 : lpos+1

    End If
    pixup=True

  End If

  If dy><0
    ;_tb_line_Settokencase{*textBox}
    ;If shift AND (\edflags&#TUITBF_SHIFTSELECT=0) Then dy.l = *textBox\visibleLines * Sgn(dy)
    If page_
      dy.l = *textBox\visibleLines * Sgn(dy)
    End If

    lpos + dy
    If lpos>=\totalLines
      lpos=\totalLines-1
      !line_use{*tline, lpos}
      If *tline
        cpos=*tline\clength
      End If
    End If
    If lpos<0 Then lpos=0
    cpos = _tb_x2pos{*textBox,lpos,\cursor_pixpos,*rp}

  End If

  _tb_SetCursor{*textBox,lpos,cpos,pixup,False,*rp}
;  If shift
;  Stop
;  End If
 ; _tb_ScrollToCursor{*textBox,*rp}

  ;If shift AND (\edflags&#TUITBF_SHIFTSELECT><0)
  If mark
    _tb_SetSelection{*textBox,\anker_lpos,\anker_cpos,\cursor_lpos,\cursor_cpos}
    ;_tb_Drag{*textBox,\cursor_lpos,\cursor_cpos}
  Else
    If (\edflags&#TUITBF_LOOSESELECTION><0) Then _tb_SetSelection{*textBox}
  End If
  !tuiHandleNotify{done.l,*textBox,onCursor,Null}
End Statement


Function.l _tb_Expand{*textBox.tuiTextBox,minLines.l}

  succ.l = False
  If minLines>\allocLines
    newdoc.l = AllocVec_(minLines*SizeOf.tline,#MEMF_CLEAR)
    If newdoc
      If \doc
        CopyMem_ \doc,newdoc,\allocLines*SizeOf.tline
        FreeVec_ \doc
      End If
      \doc = newdoc
      \allocLines = minLines
      succ.l = True
    End If
  End If
  Function Return succ

End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_AllocLine {*textBox.tuiTextBox,lpos.l,text.l,@clength.l}    /
;/                                                                             /
;/ Description:                                                                /
;/ "Insert" at line 5 moves line 5-end to position 6 and creates new line at:: /
;/  position 5                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : intert position or -1 for append at end of text                                                           /
;/ - text.l    : initial text for new line                                                           /
;/ - clength.l    : optional character length of text                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_InsertNewLine{*textBox.tuiTextBox,lpos.l,textP.l,tlength.l}

  If lpos<0 OR lpos>\totalLines Then lpos = \totalLines

  If \totalLines>=\allocLines Then If _tb_Expand{*textBox.tuiTextBox,\allocLines+32}=False Then Statement Return

  If \undo Then ntui_StoreUndoContainer{\undo,#TUITBUNDO_INSERTNEWLINE,Null,0,lpos,0}

  !line_use{*tline, lpos}
  If *tline
    flags.l = *tline\flags
  Else
    flags.l = \last_flags ; happens if we are the last line
  End If
  If \totalLines-lpos>0
    !_ASSERT{lpos>=0}
    !_ASSERT{lpos+1<\allocLines}
    !_ASSERT{\totalLines-lpos<\allocLines}
    !_ASSERT{\doc}
    !_ASSERT{\totalLines<\allocLines}

    ;_tb_CopyMem{\doc+(lpos*SizeOf.tline),\doc+((lpos+1)*SizeOf.tline),(\totalLines-lpos-1)*SizeOf.tline};:error{"Lut shift !"} ; LUT shift
    For n.l= \totalLines-1 To lpos Step -1
      ap.l = \doc + (n*SizeOf.tline)
      bp.l = \doc + ((n+1)*SizeOf.tline)
      CopyMem_ ap,bp,SizeOf.tline
    Next
  End If
  \totalLines+1 : \damage_binding = True

  !line_use{*tline, lpos}
  If *tline

    *tline\flags = (flags | #TUITBLF_STYLED) - #TUITBLF_STYLED
    *tline\sclength = 0
    *tline\sblength = 0
    *tline\style    = Null
    If tlength<0 Then tlength = 0 : If textP Then While Peek.b(textP+tlength) : tlength+1:Wend

    *tline\blength = (tlength+1+7)/8*8 ; 8-byte align
    *tline\text = AllocMem_ (*tline\blength,#MEMF_ANY)
    If *tline\text
      ;If tlength>0 AND textP Then CopyMem_ textP,*tline\text,tlength
      If tlength>0 AND textP Then _tb_CopyMem{textP,*tline\text,tlength}

      *tline\clength = tlength
      ;_tb_Tokenize{*textBox,lpos}
    Else
      *tline\clength = 0
    End If

    If lpos<=\cursor_lpos          Then \cursor_lpos+1 : If \cursor_lpos>=\totalLines Then \cursor_lpos=\totalLines-1
    If lpos<=\cursor_lpos          Then \cursor_cpos = *tline\clength - _tb_line_hasreturn{*tline}
    If lpos<=\selection_begin_lpos Then \selection_begin_lpos+1
    If lpos<=\selection_end_lpos   Then \selection_end_lpos+1
    _tb_UpdateBrackets{*textBox,\cursor_lpos,\cursor_cpos}

  End If
  \edited+1
  _tb_Damage{*textBox,lpos,*textBox\totalLines} ; ... to the end of text

End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_InsertInLine {*textBox.tuiTextBox,lpos.l,cpos.l,text.l,@ilength.l} /
;/                                                                             /
;/ Description:                                                                /
;/ insert at cpos 5 will move characters 5-end to cpos 6 and fill cpos with :: /
;/ inerttext                                                                   /
;/ insert at higher cpos than clength will add some spaces between             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : textbox object                                           /
;/ - lpos.l    : line position                                                          /
;/ - cpos.l    : character position or -1 for end-of-line                                                           /
;/ - text.l    : text to insert                                                           /
;/ - ilength.l    : length of text to insert or -1 for 0-terminated string                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_InsertInLine{*textBox.tuiTextBox,lpos.l,cpos.l,textP.l,tlength.l}

  If lpos<0 OR lpos>\totalLines Then Statement Return
  If lpos=\totalLines Then _tb_InsertNewLine{*textBox,lpos,textP,tlength} : Statement Return

  If tlength<0 Then tlength = 0 : If textP Then While Peek.b(textP+tlength) : tlength+1:Wend

  !line_use{*tline, lpos}
  If *tline
    retcode.l = 0
    If _tb_line_hasreturn{*tline} Then retcode.l = 1
    
    If cpos<0 Then cpos=*tline\clength-1
    
    spacelength.l  = cpos - *tline\clength + retcode : If spacelength<0 Then spacelength=0
    clength.l      = *tline\clength + spacelength + tlength
    copylength.l   = *tline\clength - cpos : If copylength<retcode Then copylength=retcode

    If \undo Then ntui_StoreUndoContainer{\undo,#TUITBUNDO_INSERTINLINE,Null,0,lpos,(cpos LSL 16) | tlength}

    If clength>*tline\blength OR *tline\text=Null ; Zeile erneuern
      blength.l = (clength+1+7)/8*8
      newline.l = AllocMem_ (blength,#MEMF_CLEAR)
      If *tline\text
        ;_tb_CopyMem{ *tline\text,newline,*tline\clength}
        CopyMem_ *tline\text,newline,*tline\clength
        If ((*tline\flags&#TUITBLF_STOLEN)=0) Then FreeMem_ *tline\text,*tline\blength : Else *tline\flags-#TUITBLF_STOLEN
      End If
      *tline\blength = blength
      *tline\text    = newline
    End If

    If *tline\text
     
      For n.l=0 To copylength-1; copy including the return code
        Poke.b *tline\text+clength-n-1,Peek.b(*tline\text+*tline\clength-n-1)
      Next
      
      For n.l=0 To spacelength-1 ; insert spaces, if any
        Poke.b *tline\text+*tline\clength-1+n,$20
      Next
      
      If textP
        For n.l=0 To tlength-1 ; insert text
          Poke.b *tline\text+cpos+n,Peek.b(textP+n)
        Next
      End If

      If lpos=\cursor_lpos
        If cpos<=\cursor_cpos Then \cursor_cpos+tlength
        ;If \cursor_cpos>=clength Then \cursor_cpos=clength-1
        If \cursor_cpos<0 Then \cursor_cpos=0
      End If

      If lpos=\selection_begin_lpos
        If cpos<=\selection_begin_cpos Then \selection_begin_cpos+tlength
        If \selection_begin_cpos>=clength Then \selection_begin_cpos=clength-1
        If \selection_begin_cpos<0 Then \selection_begin_cpos=0
      End If

      If lpos=\selection_end_lpos
        If cpos<=\selection_end_cpos Then \selection_end_cpos+tlength
        If \selection_end_cpos>=clength Then \selection_end_cpos=clength-1
        If \selection_end_cpos<0 Then \selection_end_cpos=0
      End If
      _tb_UpdateBrackets{*textBox,\cursor_lpos,\cursor_cpos}
      *tline\clength = clength
    End If
    \edited+1
    *tline\flags = (*tline\flags | #TUITBLF_STYLED) - #TUITBLF_STYLED
;    If ilength<2 Then _tb_Tokenize{*textBox,lpos,False}:Else _tb_tokenize{*textBox,lpos,True}
    _tb_Damage{*textBox,lpos,lpos}
  End If

End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_DeleteLine {*textBox.tuiTextBox,lpos.l}                      /
;/                                                                             /
;/ Description:                                                                /
;/ "Delete" at line 5 frees line 5 and moves line 6-end to position 5          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_DeleteLine{*textBox.tuiTextBox,lpos.l}

  If lpos<0 OR lpos>=\totalLines Then lpos=\totalLines-1
  If lpos<0 Then Statement Return

  !line_use{*tline, lpos}
  If *tline
    If \undo Then ntui_StoreUndoContainer{\undo,#TUITBUNDO_DELETELINE,*tline\text,*tline\clength,lpos,0}
    If *tline\text
      If ((*tline\flags&#TUITBLF_STOLEN)=0) Then FreeMem_ *tline\text ,*tline\blength : Else *tline\flags-#TUITBLF_STOLEN
      *tline\text=Null : *tline\blength=0 : *tline\clength=0
    End If
    If *tline\style
      FreeMem_ *tline\style,*tline\sblength*SizeOf.styleCommand
      *tline\style=Null : *tline\sblength = 0 : *tline\sclength=0
    End If
  End If
  \edited+1
  _tb_Damage{*textBox,lpos,*textBox\totalLines} ; ... to the end of text

  \totalLines-1 : \damage_binding = True

  If \totalLines-lpos>0 Then _tb_CopyMem{ \doc+((lpos+1)*SizeOf.tline),\doc+(lpos*SizeOf.tline),(\totalLines-lpos)*SizeOf.tline} ;:error{"Lut shift !"}
  If lpos<\cursor_lpos Then \cursor_lpos-1
  If \cursor_lpos>=\totalLines Then \cursor_lpos=\totalLines-1
  If \cursor_lpos<0 Then \cursor_lpos=0
  If lpos<\selection_begin_lpos Then \selection_begin_lpos-1
  If lpos<\selection_end_lpos   Then \selection_end_lpos-1
  _tb_UpdateBrackets{*textBox,\cursor_lpos,\cursor_cpos}  
End Statement


Statement _tb_DeleteInLine{*textBox.tuiTextBox,lpos.l,cpos.l,dlength.l}

  If lpos<0 OR lpos>=\totalLines OR dlength<=0 Then Statement Return

  !line_use{*tline, lpos}
  If *tline
    If *tline\text
      If \undo Then ntui_StoreUndoContainer{\undo,#TUITBUNDO_DELETEINLINE,*tline\text+cpos,dlength,lpos,cpos}
      If dlength<0 Then dlength = *tline\clength-cpos
      dlength.l = Min(dlength,*tline\clength-cpos)
      clength.l = *tline\clength-dlength  ; new length of string
      If clength<=0
        clength=0
        If *tline\text
          If ((*tline\flags&#TUITBLF_STOLEN)=0) Then FreeMem_ *tline\text ,*tline\blength : Else *tline\flags-#TUITBLF_STOLEN
          *tline\text=Null : *tline\blength = 0 : *tline\clength = 0
        End If
        If *tline\style
          FreeMem_ *tline\style,*tline\sblength*SizeOf.styleCommand
          *tline\style=Null : *tline\sblength = 0 : *tline\sclength=0
        End If
      Else
        copylength.l = *tline\clength-cpos-dlength ; length of string on right side
        If copylength>0 ; move left ...
          _tb_CopyMem{ *tline\text+cpos+dlength,*tline\text+cpos,copylength}
        End If
      End If
      *tline\clength = clength

      If lpos=\cursor_lpos
        ;If \cursor_cpos>cpos+dlength Then \cursor_cpos-dlength
        If \cursor_cpos>cpos Then \cursor_cpos - Min(dlength,\cursor_cpos-cpos)
        ;If \cursor_cpos>=clength Then \cursor_cpos=clength-1
        If \cursor_cpos<0 Then \cursor_cpos=0
      End If

      If lpos=\selection_begin_lpos
        If cpos<\selection_begin_cpos Then \selection_begin_cpos-dlength
        ;If \selection_begin_cpos>=clength Then \selection_begin_cpos=clength-1
        If \selection_begin_cpos<0 Then \selection_begin_cpos=0
      End If

      If lpos=\selection_end_lpos
        If cpos<\selection_end_cpos Then \selection_end_cpos-dlength
        ;If \selection_end_cpos>=clength Then \selection_end_cpos=clength-1
        If \selection_end_cpos<0 Then \selection_end_cpos=0
      End If

      ; test validity
      If \selection_begin_lpos = \selection_end_lpos AND \selection_begin_cpos>=\selection_end_cpos
        \selection_begin_lpos = -1
        \selection_end_lpos   = -1
      End If

    End If
    _tb_UpdateBrackets{*textBox,\cursor_lpos,\cursor_cpos}    
    \edited+1
    *tline\flags = (*tline\flags | #TUITBLF_STYLED) - #TUITBLF_STYLED
    _tb_Damage{*textBox,lpos,lpos} ; damage this line
  End If

End Statement


Statement _tb_Delete{*textBox.tuiTextBox,lpos_begin.l,cpos_begin.l,lpos_end.l,cpos_end.l}

  If lpos_begin<0 Then lpos_begin=0
  If cpos_begin<0 Then cpos_begin=0
  If lpos_end>=\totalLines Then lpos_end=\totalLines-1
  If lpos_begin>=\totalLines Then lpos_begin=\totalLines-1
  If lpos_end<lpos_begin Then Statement Return

  If lpos_begin = lpos_end
    _tb_DeleteInLine{*textBox,lpos_begin,cpos_begin,cpos_end - cpos_begin}
  Else

    ; delete all "middle lines"
    While lpos_begin+1<lpos_end
      _tb_DeleteLine{*textBox,lpos_begin+1} : lpos_end-1
    Wend

    ; delete the first line
    !line_use{*tline, lpos_begin}
    If *tline
      If cpos_begin=0 AND (cpos_end>=*tline\clength OR lpos_end>lpos_begin)  ; the entire first line will be deleted!
        _tb_DeleteLine{*textBox,lpos_begin} : lpos_end-1
      Else
        _tb_DeleteInLine{*textBox,lpos_begin,cpos_begin,*tline\clength-cpos_begin} ; only the end will be deleted
      End If
    End If

    ; delete the last line
    !line_use{*tline, lpos_end}
    If *tline
      If (cpos_end>=*tline\clength AND lpos_end>lpos_begin) ; the entire last line will be deleted!
        _tb_DeleteLine{*textBox,lpos_end} : lpos_end-1
      Else
        _tb_DeleteInLine{*textBox,lpos_end,0,cpos_end}
      End If
    End If
  End If

  ; join the lines
  !line_use{*tline, lpos_begin}
  If *tline
    If _tb_line_hasreturn{*tline}=0
      !line_use{*tline2, lpos_begin+1}
      If *tline2
        ;_tb_InsertInLine{*textBox,lpos_begin,*tline\clength,*tline2\text,*tline2\clength}
        ;_tb_DeleteLine{*textBox,lpos_begin+1}
        _tb_InsertInLine{*textBox,lpos_begin+1,0,*tline\text,*tline\clength}
        _tb_DeleteLine{*textBox,lpos_begin}
      End If
    End If
  End If

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _tb_ReturnBreak {*textBox.tuiTextBox,lpos.l,cpos.l,:: /
;/ @indent.l}                                                                  /
;/                                                                             /
;/ Description:                                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - cpos.l    : ???                                                           /
;/ - indent.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l __tb_ReturnBreak__dep{*textBox.tuiTextBox,lpos.l,cpos.l,@indent.l}
n.l=0
!line_use{*tline, lpos}
If *tline
  If *tline\text
    copylength.l = 0
    If (\edflags&#TUITBF_AUTOINDENT)><0 AND indent
      While Peek.b(*tline\text+n)=32 OR Peek.b(*tline\text+n)=9 AND n<*tline\clength
        copylength+1
      Wend
      If copylength>\cursor_cpos Then copylength=0
    End If

    If cpos<*tline\clength
      _tb_InsertNewLine{*textBox,lpos,Null,0}
    Else
      _tb_InsertNewLine{*textBox,lpos+1,*tline\text,copylength}
    End If
  Else
    _tb_InsertNewLine{*textBox,lpos+1,Null,0}
  End If
Else
  _tb_InsertNewLine{*textBox,lpos+1,Null,0}
End If
Function Return n
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_InsertString {*textBox.tuiTextBox,lpos.l,cpos.l,str_ptr.l,:: /
;/ @blength.l,@upd.l}                                                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - lpos.l    : ???                                                           /
;/ - cpos.l    : ???                                                           /
;/ - str_ptr.l    : ???                                                        /
;/ - blength.l    : ???                                                        /
;/ - upd.l    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_Insert{*textBox.tuiTextBox,lpos.l,cpos.l,textP.l,ilength.l}

  If textP=Null Then Statement Return

  If ilength<0
    ilength=0
    While Peek.b(textP+ilength) : ilength+1 : Wend
  End If

  epos.l = cpos
  apos.l = 0
  bpos.l = 0

  If \maxLines><1
    xpos.l = 0
    first.l = True
    While xpos<ilength
      Select Peek.b(textP+xpos)
        Case 10
          If first=True AND lpos<\totalLines
            ;If bpos>apos Then
            _tb_InsertInLine{*textBox,lpos,cpos,textP+apos,bpos-apos+1}
            splitpos.l = cpos+bpos-apos+1
            !line_use{*tline, lpos}
            If *tline
              If *tline\text
                _tb_InsertNewLine{*textBox,lpos,*tline\text,splitpos}
              End If
            End If
            _tb_DeleteInLine{*textBox,lpos+1,0,splitpos}
            cpos=0
            epos.l = cpos+bpos-apos
          Else
            _tb_InsertNewLine{*textBox,lpos,textP+apos,bpos-apos+1}
            cpos=0
            epos.l = bpos-apos
          End If
          first=False
          apos=xpos+1
          bpos=xpos+1
          lpos+1
        ;Case 13
          ; .... do not insert the 13!
        ;  If Peek.b(textP+xpos+1)><10 Then bpos+1

        Default
          bpos+1

      End Select
      xpos+1
    Wend
  Else
    bpos = ilength
  End If

  _tb_InsertInLine{*textBox,lpos,cpos,textP+apos,bpos-apos}
  \current_cpos = cpos+bpos-apos
  \current_lpos = lpos

End Statement


Statement _tb_Paste{*textBox.tuiTextBox,lpos.l,cpos.l}

  *cH.clipboardHandle = clipboard_OpenRead{0}
  If *cH
    *text.str = Null
    Repeat
      hasData.l = clipboard_ReadLine{*cH,&*text}
      If hasData
        _tb_Insert{*textBox,lpos,cpos,str_GetPtr{*text},str_Len{*text}}
        lpos=\current_lpos : cpos=\current_cpos
      End If
    Until hasData = 0
    str_Free{&*text}
    clipboard_Free{*cH}
  End If

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _tb_FreeText {*textBox.tuiTextBox}                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _tb_FreeText{*textBox.tuiTextBox}

  If \doc
    For lpos.l = 0 To \totalLines-1
      !line_use {*tline, lpos}
      If *tline
        If *tline\text
          If ((*tline\flags&#TUITBLF_STOLEN)=0) Then FreeMem_ *tline\text ,*tline\blength : Else *tline\flags-#TUITBLF_STOLEN
        End If
        *tline\text     = Null
        *tline\blength  = 0
        *tline\clength  = 0
        If *tline\style
          FreeMem_ *tline\style ,*tline\sblength*SizeOf.styleCommand
        End If
        *tline\style    = Null
        *tline\sclength = 0
        *tline\sblength = 0
      End If
    Next
  End If

  If \tank Then FreeVec_ \tank : \tank=Null

  _tb_Damage{*textBox,0,\totalLines}

  If \undo
    ntui_FlushUndoStack{\undo}
    ntui_SetUndoStackAttr{\undo,#TUIUSA_NUMBEROFCHANGES,0}
  End If

  \totalLines = 0
  \totalWidth = 1
  \leftOffset = 0
  \topLine    = 0
  \damage_binding = True

  \cursor_lpos   = 0
  \cursor_cpos   = 0
  \topLine       = 0
  \cursor_pixpos = 0
  \selection_begin_lpos = -1
  \selection_begin_cpos = 0
  \selection_end_lpos = -1
  \selection_end_cpos = 0
  \current_lpos  = 0
  \current_cpos  = 0

End Statement


Statement _ntui_SetTextBoxText{*textBox.tuiTextBox,*textP.b,length_.l}

  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

  _tb_FreeText{*textBox}
  If *textP
    If length_<0
      length_ = 0
      While Peek.b(*textP+length_): length_+1 : Wend
    End If
  Else
    length_ = 0
  End If

  If length_>0
  ;If *textP Then _tb_Insert{*textBox,0,0,*textP,length_}
  
  *textBox\tank = AllocVec_(length_,#MEMF_ANY)
  If *textBox\tank
    CopyMem_ *textP,*textBox\tank,length_
;        If Read_ (fid,*textBox\tank,blength) = blength Then err=0

    totalLines.l = 1
    ptr.l = *textBox\tank
    For cpos.l=0 To length_-1 ; count the total number of lines
      If Peek.b(ptr)=#ASCII_LF Then totalLines+1
      ptr+1
    Next
    _tb_Expand{*textBox,totalLines+16}

    cpos.l = 0
    lineX.l = 0
    *tline.tline = Null

    While cpos<length_
      !line_use{*tline,lineX}
      If *tline
        *tline\flags   = #TUITBLF_STOLEN
        *tline\text    = *textBox\tank+cpos

        eol.l = False
        spos.l = cpos
        Repeat
          c.b = Peek.b(*textBox\tank+cpos)
          If c=#ASCII_LF Then eol=True
          cpos+1
          If cpos>=length_ Then eol=True
        Until eol
        *tline\blength = cpos-spos
        *tline\clength = cpos-spos
        lineX+1
      Else
        cpos=length_ ; error, we misscounted the amount of lines!
      End If
    Wend
    
    addlastline.l = False
    If *tline=Null 
      addlastline=True
    Else
      If _tb_line_hasreturn{*tline} Then addlastline=True
    End If
    
    If addlastline
      lineX+1
      !line_use{*tline,lineX}
      If *tline
        *tline\flags   = 0
        *tline\text    = Null
        *tline\clength = 0
        *tline\blength = 0
      End If
    End If

    *textBox\totalLines = lineX 
  End If
  End If
  \damage_binding = True
  *textBox\cursor_lpos   = 0
  *textBox\cursor_cpos   = 0
  *textBox\topLine       = 0
  *textBox\cursor_pixpos = 0

End Statement




;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_SetValidTextBoxChars {*textBox.tuiTextBox,chars.s}          /
;/                                                                             /
;/ Description:                                                                /
;/ Define the characters that are allowed to be typed into the textbox.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - chars.s    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_SetValidTextBoxChars{*textBox.tuiTextBox,chars.s}
For n.l=0 To 255
  *textBox\validChar[n]=False
Next
For n.l=0 To FLen(chars)-1
  ind.l = Peek.b(&chars+n) & $FF
  *textBox\validChar[ind]=True
Next
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.s = ntui_GetTextBoxSelection {*textBox.tuiTextBox,@only:: /
;/ Selection.l}                                                                   /
;/                                                                             /
;/ Description:                                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - onlySelection.l    : ???                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s ntui_GetTextBoxText{*textBox.tuiTextBox,@all.l}
If all=False
  lpos_a.l = \selection_begin_lpos
  lpos_b.l = \selection_end_lpos
  cpos_a.l = \selection_begin_cpos
  cpos_b.l = \selection_end_cpos
Else
  lpos_a.l = 0
  lpos_b.l = \totalLines-1
  cpos_a.l = 0
  cpos_b.l = $7FFFFFFF
End If
If cpos_a<0 Then cpos_a=0
If cpos_b<0 Then cpos_b=0

string.s = ""

If lpos_a>=0

  For lpos.l = lpos_a+1 To lpos_b-1
    !line_use{*tline, lpos}
    If *tline
      If *tline\text
        string.s + Peeks$(*tline\text,*tline\clength)
      End If
    End If
    ;string.s+Chr$(10)
    ;If FLen(string.s)>(1024/2-8) Then Pop For:Pop If:error{"\\__THIS_FUNCTION: Not enough string buffer for clipboard!"}:string.s = "":Goto xskipcopy
  Next

  If lpos_a=lpos_b
    !line_use{*tline, lpos_a}
    If *tline
      If cpos_b>*tline\clength Then cpos_b=*tline\clength
      elength.l = cpos_b-cpos_a
      If elength>0
        If *tline\text
          string.s = LSet$(" ",elength)+string.s
          CopyMem_ *tline\text+cpos_a,&string.s,elength
        End If
      End If
    End If
  Else
    string_add.s = ""
    !line_use{*tline, lpos_a}
    If *tline
      If *tline\text
        elength = *tline\clength-cpos_a
        If elength>0
          string_add.s = Peeks$(*tline\text+cpos_a,*tline\clength-cpos_a)
        End If
      End If
    End If
    string.s = string_add.s + string.s

    !line_use{*tline, lpos_b}
    If *tline
      If cpos_b>*tline\clength Then cpos_b=*tline\clength
      elength = cpos_b
      If *tline\text
        string.s = string.s + LSet$(" ",elength)
        CopyMem_ *tline\text,&string.s + FLen(string.s)-elength,elength
      End If
    End If
  End If

End If
xskipcopy:
Function Return string.s
End Function



Statement _tb_Copy{*textBox.tuiTextBox,lpos.l,cpos.l,lpos_end.l,cpos_end.l}

  If lpos<0 Then lpos=0
  If cpos<0 Then cpos=0
  If lpos_end>=\totalLines Then lpos_end=\totalLines-1

  *cH.clipboardHandle = clipboard_OpenWrite{0}

  While lpos<=lpos_end
    !line_use{*tline, lpos}

    If *tline
      cpos2.l =  *tline\clength;+1 not +1, since the return code is included...
      If lpos=lpos_end Then cpos2=Min(cpos_end,cpos2)    ; it is the last line in selection
      copylength.l = cpos2-cpos
      If *cH
        If *tline\text
          clipboard_WriteLine{*cH,*tline\text+cpos,copylength}
        Else
          If copylength>0
            a.s = "\\n"
            clipboard_WriteLine{*cH,&a.s,1}
          End If
        End If
      End If

      cpos = 0
    End If

    lpos+1
  Wend

  If *cH Then clipboard_Free{*cH}

End Statement


Statement _tb_Cut{*textBox.tuiTextBox,lpos.l,cpos.l,lpos_end.l,cpos_end.l}

  _tb_Copy{*textBox,lpos,cpos,lpos_end,cpos_end}
  _tb_Delete{*textBox,lpos,cpos,lpos_end,cpos_end}

End Statement

Statement _tb_ExpandSelection{*textBox.tuiTextBox,lpos.l,cpos.l}
If \selection_begin_lpos<0    Then \selection_begin_lpos = lpos : \selection_begin_cpos = cpos
If \selection_begin_lpos>lpos Then \selection_begin_lpos = lpos : \selection_begin_cpos = cpos
If \selection_begin_lpos=lpos AND \selection_begin_cpos>cpos Then \selection_begin_cpos = cpos

If \selection_end_lpos<0    Then \selection_end_lpos = lpos : \selection_end_cpos = cpos
If \selection_end_lpos<lpos Then \selection_end_lpos = lpos : \selection_end_cpos = cpos
If \selection_end_lpos=lpos AND \selection_end_cpos<cpos Then \selection_end_cpos = cpos
End Statement

Function.l _tb_Undo{*textBox.tuiTextBox}
  !_ASSERT{*textBox}

  ntui_StopUndoStep{\undo} ; there will be no "undoing" anymore Until Next Call of StartUndoStep
  cpos.l = \cursor_cpos
  lpos.l = \cursor_lpos
  done.l = False
  \selection_begin_lpos = -1
  \selection_begin_cpos = -1
  \selection_end_lpos   = -1
  \selection_end_cpos   = -1

  While ntui_GetUndoContainer{\undo}
    ntui_GetUndoStackAttr{\undo,#TUIUSA_CURRENTCONTAINERID,&cID.l}
    Select cID
      Case #TUITBUNDO_DELETEINLINE ; text was deleted, insert again
        ntui_GetUndoStackAttr{\undo,#TUIUSA_CURRENTCONTAINERSIZE,&blength.l}
        ntui_GetUndoStackAttr{\undo,#TUIUSA_CURRENTCONTAINERUSERDATA1,&lpos}
        ntui_GetUndoStackAttr{\undo,#TUIUSA_CURRENTCONTAINERUSERDATA2,&cpos}
        _tb_InsertInLine {*textBox,lpos,cpos,Null,blength}
        !line_use{*tline, lpos}
        If *tline
          If *tline\text><Null AND *tline\blength>=blength+cpos
            ntui_GetUndoStackAttr{\undo,#TUIUSA_CURRENTCONTAINERDATA,*tline\text+cpos}
            _tb_ExpandSelection{*textBox,lpos,cpos}
            lpos = lpos
            cpos = cpos + blength
            _tb_ExpandSelection{*textBox,lpos,cpos}
          End If
        End If

      Case #TUITBUNDO_INSERTINLINE ; text was inserted, delete it again
        ntui_GetUndoStackAttr{\undo,#TUIUSA_CURRENTCONTAINERUSERDATA1,&lpos}
        ntui_GetUndoStackAttr{\undo,#TUIUSA_CURRENTCONTAINERUSERDATA2,&cpos}
        dlength.l = (cpos&$0000FFFF)
        cpos.l    = (cpos&$FFFF0000) LSR 16
        _tb_DeleteInLine {*textBox,lpos,cpos,dlength}
        lpos = lpos
        cpos = cpos
        _tb_ExpandSelection{*textBox,lpos,cpos}

      Case #TUITBUNDO_DELETELINE ; a line was deleted, insert and load the data into it
        ntui_GetUndoStackAttr{\undo,#TUIUSA_CURRENTCONTAINERUSERDATA1,&lpos}
        ntui_GetUndoStackAttr{\undo,#TUIUSA_CURRENTCONTAINERSIZE,&blength}
        _tb_InsertNewLine{*textBox,lpos,Null,blength}
        !line_use{*tline, lpos}
        If *tline
          If *tline\text><Null AND *tline\blength>=blength
            ntui_GetUndoStackAttr{\undo,#TUIUSA_CURRENTCONTAINERDATA,*tline\text}
            _tb_ExpandSelection{*textBox,lpos,0}
            If _tb_line_hasreturn{*tline}>0
              lpos + 1
              cpos = 0
            Else
              cpos = *tline\clength
              lpos = lpos
            End If
            _tb_ExpandSelection{*textBox,lpos,cpos}
          End If
        End If

      Case #TUITBUNDO_INSERTNEWLINE ; a new line was created, simply delete it again
        If ntui_GetUndoStackAttr{\undo,#TUIUSA_CURRENTCONTAINERUSERDATA1,&lpos}
          _tb_DeleteLine{*textBox,lpos}
          cpos = 0
          lpos = lpos-1
          !line_use{*tline, lpos}
          If *tline
            If *tline\text><Null
              cpos = *tline\clength - _tb_line_hasreturn{*tline}
              ;_tb_ExpandSelection{*textBox,lpos,cpos}
            End If
          End If
        End If

      Default
        ; WTF?
    End Select

    done.l = True
  Wend

  If ntui_GetUndoStackAttr{*textBox\undo,#TUIUSA_NUMBEROFCHANGES,&numchanges.l}
    If numchanges=0 Then \edited=0
  End If

  If \selection_end_lpos>=0 AND  \selection_end_lpos>= \selection_begin_lpos
    lpos1.l = \selection_begin_lpos
    cpos1.l = \selection_begin_cpos
    lpos2.l = \selection_end_lpos
    cpos2.l = \selection_end_cpos
    _tb_SetCursor{*textBox,lpos2,cpos2,True,True,Null}
    _tb_SetSelection{*textBox,lpos1,cpos1,lpos2,cpos2}
  Else
    _tb_SetSelection{*textBox}
  End If

  Function Return done

End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_SetTextBoxSelection {*textBox.tuiTextBox,@*rp.RastPort,@b:: /
;/ eginLine.l,@beginCharacter.l,@endLine.l,@endCharacter.l}                    /
;/                                                                             /
;/ Description:                                                                /
;/ Set a range of characters as selected.                                                                            /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort      : ???                                                     /
;/ - beginLine.l       : ???                                                      /
;/ - beginCharacter.l  : ???                                                 /
;/ - endLine.l         : ???                                                        /
;/ - endCharacter.l    : ???                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_SetTextBoxSelection{*textBox.tuiTextBox,@*rp.RastPort,@beginLine.l,@beginCharacter.l,@endLine.l,@endCharacter.l}
If *rp=-1 Then *rp=Null
If beginLine<0
  _tb_SetSelection{*textBox,0,0,\totalLines-1,$7FFFFFFF}
Else
  _tb_SetSelection{*textBox,beginLine,beginCharacter,endLine,endCharacter}
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_ClearTextBoxSelection {*textBox.tuiTextBox,@*rp.RastPort}   /
;/                                                                             /
;/ Description:                                                                /
;/ Remove the textob xselection, if any (the selected text will not be removed, only fact that it is selected)                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_ClearTextBoxSelection{*textBox.tuiTextBox,@*rp.RastPort}

  If *rp=-1 Then *rp=Null
  _tb_SetSelection{*textBox,-1,-1,-1,-1}

End Statement


Function.l _tb_match{*textBox.tuiTextBox,*textP.b,textLen.l,lpos.l,cpos.l,casesensitive.l}

  count.l = 0

  If casesensitive    
    While lpos<*textBox\totalLines AND count<textLen
      !line_use{*tline,lpos}
      If *tline
        While cpos<*tline\clength AND count<textLen
          a.b = Peek.b(*tline\text+cpos)
          b.b = Peek.b(*textP+count)
          If a><b Then Function Return False ; no match
          cpos+1
          count+1
        Wend
      End If
      lpos+1
      cpos=0
    Wend
  Else
    While lpos<*textBox\totalLines AND count<textLen
      !line_use{*tline,lpos}
      If *tline
        While cpos<*tline\clength AND count<textLen
          If ntui_CaseCmp{Peek.b(*tline\text+cpos)&$FF,Peek.b(*textP+count)&$FF} Then Function Return False ; no match
          cpos+1
          count+1
        Wend
      End If
      lpos+1
      cpos=0
    Wend    
  End If
  If count=textLen Then Function Return True ; found!
  Function Return False ; end of text exceeded

End Function


Statement _tb_seek{*textBox.tuiTextBox,*lposP.longP,*cposP.longP,cdelta.l}

  lpos.l = *lposP\l
  cpos.l = *cposP\l
  If cpos<0 Then cpos=0

  While cdelta>0 AND lpos<*textBox\totalLines
    !line_use{*tline,lpos}
    cpos+cdelta  : cdelta=0
    If cpos>=*tline\clength
      cdelta = cpos-*tline\clength
      lpos+1
      cpos = 0
    End If
  Wend

  While cdelta<0 AND lpos>=0
    !line_use{*tline,lpos}
    cpos+cdelta : cdelta=0
    If cpos<0
      cdelta=cpos
      lpos-1
      cpos = *tline\clength
    End If
  Wend

  If lpos<0 Then lpos=0
  If lpos>=*textBox\totalLines Then lpos=*textBox\totalLines-1
  If cpos<0 Then cpos=0
  !line_use{*tline,lpos}
  If *tline
    If cpos>*tline\clength Then cpos=*tline\clength
  End If

  *lposP\l = lpos
  *cposP\l = cpos

End Statement


Function.l ntui_FindNextTextBoxText{*textBox.tuiTextBox,*textP.b,textLen.l,*lposP.longP,*cposP.longP,casesensitive.l}

  first.b = ntui_ToLower{Peek.b(*textP)&$FF}
  lpos.l = *lposP\l
  cpos.l = *cposP\l
  If cpos<0 Then cpos=0

  While lpos<*textBox\totalLines
    !line_use{*tline,lpos}
    If *tline
      While cpos<*tline\clength
        c.b = ntui_ToLower{Peek.b(*tline\text+cpos)&$FF}
        If c=first
          If _tb_match{*textBox,*textP,textLen,lpos,cpos,casesensitive}
            *lposP\l = lpos
            *cposP\l = cpos
            Function Return True ; found!
          End If
        End If
        cpos+1
      Wend
    End If
    lpos+1
    cpos=0
  Wend

  Function Return False ; not found

End Function


Function.l ntui_FindPrevTextBoxText{*textBox.tuiTextBox,*textP.b,textLen.l,*lposP.longP,*cposP.longP,casesensitive.l}

  first.b = ntui_ToLower{Peek.b(*textP)&$FF}

  _tb_seek{*textBox,*lposP,*cposP,-textLen}
  lpos.l = *lposP\l
  cpos.l = *cposP\l

  While lpos>=0
    !line_use{*tline,lpos}
    If *tline
      If cpos<0 Then cpos=*tline\clength-1 : Else If cpos>=*tline\clength Then cpos=*tline\clength-1
      While cpos>=0
        c.b = ntui_ToLower{Peek.b(*tline\text+cpos)&$FF}
        If c=first
          If _tb_match{*textBox,*textP,textLen,lpos,cpos,casesensitive}
            *lposP\l = lpos
            *cposP\l = cpos
            Function Return True ; found!
          End If
        End If
        cpos-1
      Wend
    End If
    lpos-1
  Wend

  Function Return False ; not found

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_DeleteTextBoxSelection {*textBox.tuiTextBox,@*rp.RastPort}  /
;/                                                                             /
;/ Description:                                                                /
;/ Delete the text that is currently selected.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_DeleteTextBoxSelection{*textBox.tuiTextBox,@*rp.RastPort}

  If *rp=-1 Then *rp=Null
  edited.l = *textBox\edited
  _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}

  If edited=0 AND *textBox\edited><0
    !tuiHandleNotify{done.l,*textBox,onEdit,Null}
  End If

End Statement

Function.l ntui_ReplaceTextBoxSelection{*textBox.tuiTextBox,*replace.b,replaceLen.l}
  DEFTYPE.longP lposaP,lposbP,cposaP,cposbP

  ntui_GetAttr{*textBox,#TUITBA_BEGINSELECTLINE,lposaP}
  ntui_GetAttr{*textBox,#TUITBA_BEGINSELECTCHAR,cposaP}
  ntui_GetAttr{*textBox,#TUITBA_ENDSELECTLINE,lposbP}
  ntui_GetAttr{*textBox,#TUITBA_ENDSELECTCHAR,cposbP}
  edited.l = *textBox\edited

  If lposaP\l<lposbP\l OR (lposaP\l=lposbP\l AND cposaP\l<=cposbP\l)
    _tb_Delete{*textBox,lposaP\l,cposaP\l,lposbP\l,cposbP\l}
    If *replace><Null AND replaceLen>0
      _tb_Insert{*textBox,lposaP\l,cposaP\l,*replace,replaceLen}
      _tb_seek{*textBox,lposaP,cposaP,replaceLen}
    End If
  End If
  
  If edited=0 AND *textBox\edited><0
    !tuiHandleNotify{done.l,*textBox,onEdit,Null}
  End If
  
  ;_tb_Repair{*textBox.tuiTextBox,*rp.RastPort}
  ntui_Refresh{*textBox,Null}
    
  Function Return True

End Function


Function.l ntui_ReplaceTextBoxText{*textBox.tuiTextBox,*replace.b,replaceLen.l,*find.b,findLen.l,casesensitive.l,all.l}

  DEFTYPE.longP lposaP,lposbP,cposaP,cposbP

  ntui_GetAttr{*textBox,#TUITBA_BEGINSELECTLINE,lposaP}
  ntui_GetAttr{*textBox,#TUITBA_BEGINSELECTCHAR,cposaP}
  ntui_GetAttr{*textBox,#TUITBA_ENDSELECTLINE,lposbP}
  ntui_GetAttr{*textBox,#TUITBA_ENDSELECTCHAR,cposbP}

  If *textBox\undo Then ntui_StartUndoStep{*textBox\undo,#TUITBUNDOSTEP_REPLACE}

  edited.l = *textBox\edited
  succ.l   = False
  count.l  = 0

  Repeat
    succ = False

    If lposaP\l<lposbP\l OR (lposaP\l=lposbP\l AND cposaP\l<cposbP\l)
      _tb_Delete{*textBox,lposaP\l,cposaP\l,lposbP\l,cposbP\l}
      If *replace><Null AND replaceLen>0
        _tb_Insert{*textBox,lposaP\l,cposaP\l,*replace,replaceLen}
        _tb_seek{*textBox,lposaP,cposaP,replaceLen}
      End If
      count+1
    End If

    If *find><Null AND findLen>0
      If ntui_FindNextTextBoxText{*textBox,*find,findLen,lposaP,cposaP,casesensitive}
        lposbP\l = lposaP\l
        cposbP\l = cposaP\l
        _tb_seek{*textBox,lposbP,cposbP,findLen}
        succ=True
      End If
    End If

  Until all=False OR succ=False

  If edited=0 AND *textBox\edited><0
    !tuiHandleNotify{done.l,*textBox,onEdit,Null}
  End If

  ntui_Refresh{*textBox,Null}
  Function Return count

End Function


Function.l ntui_AppendTextBox{*textBox.tuiTextBox,textP.l,length_.l}

  If textP=Null Then Function Return False
  lpos.l = *textBox\totalLines-1
  edited.l = *textBox\edited

  If *textBox\undo Then ntui_ContinueUndoStep{*textBox\undo,#TUITBUNDOSTEP_APPEND}

  !line_use{*tline,lpos}
  If *tline
    cpos.l = *tline\clength
    _tb_Insert{*textBox,lpos,cpos,textP,length_}
  Else
    _tb_Insert{*textBox,0,0,textP,length_}
  End If

  If edited=0 AND *textBox\edited><0
    !tuiHandleNotify{done.l,*textBox,onEdit,Null}
  End If

  Function Return True

End Function


Statement ntui_ScrollTextBoxBottom{*textBox.tuiTextBox}

  If *textBox\obj\flags&#TUIF_ONSCREEN
    *rp.RastPort = ntui_ObtainRastPort{*textBox}
    If *rp
      _tb_Repair{*textBox,*rp}
      lpos.l = *textBox\totalLines-1
      _tb_SetCursor{*textBox,lpos,-1,-1,-1,*rp}
      _tb_DoBlink{*textBox,*rp,On}
      ntui_ReleaseRastPort{*textBox}
    End If
  End If

End Statement

Statement ntui_ScrollTextBoxToLastChar{*textBox.tuiTextBox}

  If *textBox\obj\flags&#TUIF_ONSCREEN
    *rp.RastPort = ntui_ObtainRastPort{*textBox}
    If *rp
      _tb_Repair{*textBox,*rp}
      lpos.l = *textBox\totalLines-1
      cpos.l = 0
      !line_use{*tline, lpos}
      If *tline
        cpos.l = *tline\clength
      End If
      _tb_SetCursor{*textBox,lpos,cpos,-1,-1,*rp}
      _tb_DoBlink{*textBox,*rp,On}
      ntui_ReleaseRastPort{*textBox}
    End If
  End If

End Statement


RunErrsOff ; debugger must be switched off
; return 0 if everything is fine, or error code
_tb_OnDataCB:
Function.l _tb_OnDataCB{*fileListener.tuiFileListener,dataP.l,dataLen.l}

  ;*ev.tuiEvent = _ntui_CreateEventAsync{*fileListener\obj\engine,#TUITBEV_APPEND}
   ;If *ev
     ;str_WritePtrAsync{&*ev\string,dataP,dataLen}
     ;_ntui_QueueEventAsync{*fileListener\obj\engine\eventQ,*ev}
     ntui_PostEvent{*fileListener\obj,#TUITBEV_APPEND,0,dataP}
     Function Return #TUIFLE_OK
   ;End If

   ;Function Return #TUIFLE_USERERROR

End Function
!_MakeGlobalFuncPointer_RunErrsOff{_tb_OnDataCB,{Null,Null,0}}

; return 0 if everything is fine, or error code
_tb_OnCloseCB:
Function.l _tb_OnCloseCB{*fileListener.tuiFileListener}

  ;*ev.tuiEvent = _ntui_CreateEventAsync{*fileListener\obj\engine,#TUITBEV_FLCLOSE}
  ; If *ev
  ;   _ntui_QueueEventAsync{*fileListener\obj\engine\eventQ,*ev}
     ntui_PostEvent{*fileListener\obj,#TUITBEV_FLCLOSE}
     Function Return #TUIFLE_OK
  ; End If

  ; Function Return #TUIFLE_USERERROR

End Function
!_MakeGlobalFuncPointer_RunErrsOff{_tb_OnCloseCB,{Null}}

_tb_OnFailCB:
Function.l _tb_OnFailCB{*fileListener.tuiFileListener,err.l}

   !_CallFuncPointer{*fileListener\onDataCB,  *fileListener\err,*fileListener,?__tb_errmsg,12}
   Function Return err

   __tb_errmsg:
   Dc.b "Pipe ERROR!",10,0
End Function
!_MakeGlobalFuncPointer_RunErrsOff{_tb_OnFailCB,{Null,0}}


; return 0 if everything is fine, or error code
_tb_OnOpenCB:
Function.l _tb_OnOpenCB{*fileListener.tuiFileListener}

  Function Return #TUIFLE_OK

End Function
!_MakeGlobalFuncPointer_RunErrsOff{_tb_OnOpenCB,{Null}}
LastRunErrsMode


Function.l ntui_SetTextBoxFileListener{*textBox.tuiTextBox,*filenameP.b}
  !_ASSERT{*textBox}
  !_ASSERT{*filenameP}

  If *textBox\fileListener Then ntui_FreeFileListener{*textBox\fileListener}
  *textBox\fileListener = ntui_FileListener{*textBox,*filenameP,(.tuiFunc)*_tb_OnOpenCB,(.tuiFunc)*_tb_OnCloseCB,(.tuiFunc)*_tb_OnFailCB,(.tuiFunc)*_tb_OnDataCB}
  Function Return *textBox\fileListener><Null

End Function

Statement ntui_TrimTextBox{*textBox.tuiTextBox}

  For lpos.l=0 To *textBox\totalLines-1
    !line_use{*tline,lpos}
    If *tline
      If *tline\text
        _tb_TrimLine{*tline}
      End If
    End If
  Next

End Statement


Function.l ntui_SaveTextBox{*textBox.tuiTextBox,*filenameP.b}

  err.l = 1
  str_WritePtr{&*textBox\filename,*filenameP}
  fid.l = Null

  If str_Len{*textBox\filename}>0
    fid.l = Open_ (str_GetPtr{*textBox\filename},#MODE_NEWFILE)
  End If

  If fid
    err=0
    For lpos.l=0 To *textBox\totalLines-1
      !line_use{*tline,lpos}
      If *tline
        If *tline\text
          If *textBox\edflags & #TUITBF_TRIMWHITESPACES
            _tb_TrimLine{*tline}
          End If
          If Write_ (fid,*tline\text,*tline\clength)><*tline\clength Then lpos = \totalLines : err=-1
        End If
      End If
    Next
    Close_ fid

  End If

  Function Return err

End  Function

Function.l ntui_LoadTextBox{*textBox.tuiTextBox,*filenameP.b}

   err.l = 1
  _tb_FreeText{*textBox}

  str_WritePtr{&*textBox\filename,*filenameP}
  fid.l = Null

  If str_Len{*textBox\filename}>0
    fid.l = Open_ (str_GetPtr{*textBox\filename},#MODE_OLDFILE)
  End If

  If fid
    err=-1
    blength.l = 0
    If Seek_ (fid,0,#OFFSET_END)><-1
      blength   = Seek_ (fid,0,#OFFSET_BEGINNING)
    End If
    If blength>0
      *textBox\tank = AllocVec_(blength,#MEMF_ANY)
      If *textBox\tank

        If Read_ (fid,*textBox\tank,blength) = blength Then err=0

        totalLines.l = 1
        ptr.l = *textBox\tank
        For cpos.l=0 To blength-1 ; count the total number of lines
          If Peek.b(ptr)=10 Then totalLines+1
          ptr+1
        Next
        _tb_Expand{*textBox,totalLines+16}

        cpos.l = 0
        lineX.l = 0
        *tline.tline = Null

        While cpos<blength
          !line_use{*tline,lineX}
          If *tline
            *tline\flags   = #TUITBLF_STOLEN
            *tline\text    = *textBox\tank+cpos

            eol.l = False
            spos.l = cpos
            Repeat
              c.b = Peek.b(*textBox\tank+cpos)
              If c=10 Then eol=True
              cpos+1
              If cpos>=blength Then eol=True
            Until eol
            *tline\blength = cpos-spos
            *tline\clength = cpos-spos
            lineX+1
          Else
            cpos=blength ; error, we misscounted the amount of lines!
          End If
        Wend
        addlastline.l = False
        If *tline=Null Then addlastline=True
        If _tb_line_hasreturn{*tline} Then addlastline=True
        If addlastline
          lineX+1
          !line_use{*tline,lineX}
          If *tline
            *tline\flags   = 0
            *tline\text    = Null
            *tline\clength = 0
            *tline\blength = 0
          End If
        End If

        *textBox\totalLines = lineX : \damage_binding = True
      End If
    End If
    Close_ fid
  End If
  ;_tb_Damage{*textBox,0,*textBox\totalLines}
  ;If *rp Then _tb_Repair{*textBox,*rp}
  ntui_Refresh{*textBox,Null}
  Function Return err

End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_TextBoxVanillaKey {*textBox.tuiTextBox,*tuiEv:: /
;/ ent.tuiEvent}                                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *ev.tuiEvent    : ???                                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ntui_TextBoxVanillaKey{*textBox.tuiTextBox,*ev.tuiEvent,*rp.RastPort}
!_ASSERT{*textBox}
!_ASSERT{*ev}
  done.l = False
  ntui_GetEventAttr{*ev,#TUIEVA_STRING,&vkeyP.l}
  If vkeyP=Null Then Function Return False
  ntui_GetEventAttr{*ev,#TUIEVA_QUALIFIER,&quali.l}
  firstChar.l  = Peek.b(vkeyP)
  Select firstChar
    Case 13 ; return
      If (*textBox\edflags&#TUITBF_WANTRETURN)
        If \undo Then ntui_StartUndoStep{*textBox\undo,#TUITBUNDOSTEP_KEYSTROKE}
        If \selection_begin_lpos>=0 Then _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}

        If (quali&#TUIQUAL_SHIFT) OR (\edflags&#TUITBF_RETURNBREAK)
          a.s = "\\n"
          If (quali&#TUIQUAL_SHIFT) Then indent.l=False:Else indent=True
          If indent AND \edflags&#TUITBF_AUTOINDENT
            !line_use{*tline,\cursor_lpos}
            If *tline
              If *tline\text
                cpos.l = 0
                While cpos<*tline\clength AND (Peek.b(*tline\text+cpos)&$FF<=32 AND cpos<\cursor_cpos)
                  cpos+1
                Wend
                a.s +Peeks$(*tline\text,cpos)

                cpos.l = \cursor_cpos
                While cpos<*tline\clength AND (Peek.b(*tline\text+cpos)&$FF<=32) AND (Peek.b(*tline\text+cpos)&$FF><10)  AND (Peek.b(*tline\text+cpos)&$FF><13)
                  cpos+1
                Wend
                _tb_DeleteInLine{*textBox,\cursor_lpos,\cursor_cpos,cpos-\cursor_cpos}

              End If
            End If
          End If
          _tb_Insert{*textBox,\cursor_lpos,\cursor_cpos,&a,FLen(a)}
          _tb_ScrollToCursor{*textBox,*rp}
        Else
          a.s = "\\n"
          _tb_InsertNewLine{*textBox,\cursor_lpos+1,&a,1}
          _tb_SetCursor{*textBox,\cursor_lpos+1,0}
        End If
        done.l = True
      Else ; single line textbox
        ;\accept=False
        !tuiHandleNotify{done,*textBox,onSubmit,*ev}
      End If

    Case 127 ; backspace
      If \selection_begin_lpos<\selection_end_lpos OR \selection_begin_cpos<\selection_end_cpos
        If \undo Then ntui_StartUndoStep{*textBox\undo,#TUITBUNDOSTEP_DELETE}
        _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
      Else
        If \undo Then ntui_ContinueUndoStep{*textBox\undo,#TUITBUNDOSTEP_KEYSTROKE}
        oldlines.l = \totalLines
        _tb_Delete{*textBox,\cursor_lpos,\cursor_cpos,\cursor_lpos,\cursor_cpos+1}
      End If
      done.l = True
      _tb_ScrollToCursor{*textBox,*rp}

    Case 8 ; delete
      If \selection_begin_lpos<\selection_end_lpos OR \selection_begin_cpos<\selection_end_cpos
        If \undo Then ntui_StartUndoStep{*textBox\undo,#TUITBUNDOSTEP_DELETE}
        _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
      Else
        If \undo Then ntui_ContinueUndoStep{*textBox\undo,#TUITBUNDOSTEP_KEYSTROKE}
        delpos.l   = \cursor_cpos-1
        delline.l  = \cursor_lpos
        If delpos<0
          delline-1
          !line_use{*tline, delline}
          If *tline
            delpos = *tline\clength-1
          End If
        End If
        _tb_Delete{*textBox,delline,delpos,delline,delpos+1}
      End If
      \cursor_pixpos = _tb_pos2x{*textBox,\cursor_lpos,\cursor_cpos,*rp}
      done = True

    Default
      command.l = #TUIQUAL_COM
      command | #TUIQUAL_CTRL
      If (quali&command)
        If (*textBox\edflags&#TUITBF_DEFAULTSHORTCUTS)><0
          Select firstChar
            Case @"v":
              If \undo Then ntui_StartUndoStep{*textBox\undo,#TUITBUNDOSTEP_PASTE}
              _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
              _tb_Paste{*textBox,\cursor_lpos,\cursor_cpos}
              done = True
            Case @"z":
              _tb_Undo{*textBox}
              done = True
            Case @"x":
              If \undo Then ntui_StartUndoStep{*textBox\undo,#TUITBUNDOSTEP_CUT}
              _tb_Cut{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
              done = True
            Case @"c":
              _tb_Copy{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
              done = True
            Case @"d":
              If \undo Then ntui_StartUndoStep{*textBox\undo,#TUITBUNDOSTEP_DELETE}
              If ((\edflags&#TUITBF_LOOSESELECTION)><0) AND (\selection_begin_lpos>=0 AND \selection_end_lpos>=0)
                _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
              Else
                !line_use{*tline, *textBox\totalLines-1}
                If *tline
                  _tb_DeleteLine{*textBox,\cursor_lpos}
                End If
              End If
              done = True
            Case @"a":
              cpos.l = 0
              !line_use{*tline, *textBox\totalLines-1}
              If *tline
                cpos = *tline\clength
              End If
              _tb_SetSelection{*textBox,0,0,*textBox\totalLines,cpos}
              done = True
          End Select
        End If
        done=True
      End If

      If done=False
        If *textBox\validChar[firstChar&$FF]
          If \undo Then ntui_ContinueUndoStep{*textBox\undo,#TUITBUNDOSTEP_KEYSTROKE}
          If \selection_begin_lpos>=0 Then _tb_Delete{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
          a.s = Peek.s(vkeyP)
          _tb_Insert{*textBox,\cursor_lpos,\cursor_cpos,&a.s,FLen(a.s)}
          \cursor_pixpos = _tb_pos2x{*textBox,\cursor_lpos,\cursor_cpos,*rp}
          done = True
        End If
      End If

  End Select
  _tb_ScrollToCursor{*textBox,*rp}
  ;!tuiHandleNotify{done,*textBox,onChange,*ev}

  Function Return done

End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_KeyStrokeTextBox {*textBox.tuiTextBox,*tuiEve:: /
;/ nt.tuiEvent}                                                                /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - rkey.l    : ???                                                           /
;/ - vkey.l    : ???                                                           /
;/ - string.s    : ???                                                         /
;/ - *ev.tuiEvent    : ???                                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ntui_KeyStrokeTextBox{*textBox.tuiTextBox,*ev.tuiEvent,*rp.RastPort}
!_ASSERT{*textBox}
!_ASSERT{*ev}
  ntui_GetEventAttr{*ev,#TUIEVA_VALUE,&rkey.l}
  ntui_GetEventAttr{*ev,#TUIEVA_STRING,&vkeyP.l}
  If vkeyP Then vkey.l = Peek.b(vkeyP) & $FF  : Else vkey=0
  ntui_GetEventAttr{*ev,#TUIEVA_QUALIFIER,&quali.l}
  edited.l = *textBox\edited
  done.l = False
  _tb_DoBlink{*textBox,*rp,Off}
  
  If (quali&#TUIQUAL_SHIFT) 
    If (*textBox\edflags&#TUITBF_SHIFTSELECT)
      mark.l = True
    Else
      page_.l = True
    End If
  End If
  
  If (quali&#TUIQUAL_ALT)
    page_.l = True
  End If

  If \accept=0
    If vkey=13 ; switch to accept input
      \accept=1
      _tb_DoBlink{*textBox,*rp,On}
      Function Return True
    Else
      If \undo Then ntui_StopUndoStep{\undo}
;      !tuiHandleNotify{done,*textBox,onChange,*ev}
      Function Return False
    End If
  End If

  Select rkey
    Case #RAWKEY_RIGHT ; 78 ; >
      If \undo Then ntui_StopUndoStep{\undo}
      If mark=False AND _ntui_TextBoxHasSelecton{*textBox}
        _tb_SetCursor{*textBox,\selection_end_lpos,\selection_end_cpos,True,True,*rp}
      Else      
        _tb_MoveCursor{*textBox,1,0,mark,page_,*rp}
      End If
      done=True

    Case #RAWKEY_LEFT ; 79 ; <
      If \undo Then ntui_StopUndoStep{\undo}
      If mark=False AND _ntui_TextBoxHasSelecton{*textBox}
        _tb_SetCursor{*textBox,\selection_begin_lpos,\selection_begin_cpos,True,True,*rp}
      Else
        _tb_MoveCursor{*textBox,-1,0,mark,page_,*rp}
      End If
      done=True

    Case #RAWKEY_UP ; 76 ; up
      If \undo Then ntui_StopUndoStep{\undo}
      _tb_MoveCursor{*textBox,0,-1,mark,page_,*rp} : done=True

    Case #RAWKEY_DOWN ; 77 ; down
      If \undo Then ntui_StopUndoStep{\undo}
      _tb_MoveCursor{*textBox,0,1,mark,page_,*rp}  : done=True
      
    Case #RAWKEY_ESC
      done=False

    Case #RAWKEY_TAB ; 66 ; TAB
      If _ntui_TextBoxHasSelecton{*textBox}
        _tb_SetCursor{*textBox,\selection_end_lpos,\selection_end_cpos,True,True,*rp}
        done = True
      Else      
        If ((*textBox\edflags&#TUITBF_READONLY)=0)
          If ((*textBox\edflags&#TUITBF_WANTTAB))
            If (quali&#TUIQUAL_SHIFT) = 0
              done=_ntui_TextBoxVanillaKey{*textBox,*ev,*rp}
            End If
          End If
        End If
        If done=False
          If \undo Then ntui_StopUndoStep{\undo}
        End If
      End If
      
    Default
      If ((*textBox\edflags&#TUITBF_READONLY)=0)
        done = _ntui_TextBoxVanillaKey{*textBox,*ev,*rp}
      Else
        ntui_GetEventAttr{*ev,#TUIEVA_STRING,&vanillakeyP.l}
        If vanillakeyP Then key.l = Peek.b(vanillakeyP) : Else key=0
        ntui_GetEventAttr{*ev,#TUIEVA_QUALIFIER,&quali.l}

        If (quali&#TUIQUAL_COM)
          If (*textBox\edflags&#TUITBF_DEFAULTSHORTCUTS)><0
            Select key
              Case @"c":
                _tb_Copy{*textBox,\selection_begin_lpos,\selection_begin_cpos,\selection_end_lpos,\selection_end_cpos}
                done = True
              Case @"a":
                cpos.l = 0
                !line_use{*tline, *textBox\totalLines-1}
                If *tline
                  cpos = *tline\clength
                End If
                _tb_SetSelection{*textBox,0,0,*textBox\totalLines,cpos}
                done = True
            End Select
          End If
          done=True
        End If
      End If
  End Select
  _tb_Repair{*textBox,*rp}
  _tb_DoBlink{*textBox,*rp,On}

  If edited=0 AND *textBox\edited><0
    !tuiHandleNotify{done,*textBox,onEdit,*ev}
  End If

  Function Return done

End Function


Function.l ntui_KeyStrokeTextBox{*textBox.tuiTextBox,rawKey_.l,*vanillaKeyP.b,qualifier_.l}

  *ev.tuiEvent   = _ntui_CreateEvent{*textBox\obj\engine,#TUIEV_KEYDOWN}
  *ev\target_    = *textBox
  *ev\value      = rawKey_
  str_WritePtr{&*ev\string,*vanillaKeyP}
  *ev\pos\x      = 0,0
  *ev\size\x     = 0,0
  *ev\qualifier_ = qualifier_

  *rp.RastPort = ntui_ObtainRastPort{*textBox}
  result.l = _ntui_KeyStrokeTextBox{*textBox,*ev,*rp}
  If *rp Then ntui_ReleaseRastPort{*textBox}
  _ntui_DestroyEvent{*textBox\obj\engine,*ev}

  Function Return result

End Function




Statement _tb_AddFontStyles{*textBox.tuiTextBox}

  tuiFont.l = _ntui_SetFont{*textBox\obj\engine,*textBox\obj\flags}
  fontSize.l  = *textBox\obj\engine\fontSize[tuiFont];*textBox\font\tf_YSize
  ;str_WritePrt{&*fontName.str,*textBox\font\ta_Name}
  *fontName.str = Null
  str_WritePtr{&*fontName,str_GetPtr{*textBox\obj\engine\fontName[tuiFont]}}

  *textBox\fontI   = _ntui_OpenFont{*fontName,fontSize,#TUIF_ITALIC            |*textBox\obj\flags,*textBox\obj\engine\screen_}
  *textBox\fontB   = _ntui_OpenFont{*fontName,fontSize,#TUIF_BOLD              |*textBox\obj\flags,*textBox\obj\engine\screen_}
  *textBox\fontBI  = _ntui_OpenFont{*fontName,fontSize,#TUIF_BOLD|#TUIF_ITALIC |*textBox\obj\flags,*textBox\obj\engine\screen_}
  str_Free{&*fontName}

End Statement


_ntui_SetTextBoxAttr:
Function.l _ntui_SetTextBoxAttr{*textBox.tuiTextBox,ti_Tag.l,ti_Data.l}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

  done.l = True

  *rp.RastPort = ntui_ObtainRastPort{*textBox}

  Select ti_Tag
    Case #TUIA_BGPEN                : _tb_ReleasePen{*textBox,#TUITBPEN_BG}
                                      *textBox\argb   [#TUITBPEN_BG] = -1
                                      *textBox\tuiPenN[#TUITBPEN_BG] = ti_Data
                                      *textBox\tuiPenS[#TUITBPEN_BG] = #TUIPEN_MARKER
                                      _tb_UpdatePens{*textBox} : done=False

    Case #TUIA_FGPEN                : _tb_ReleasePen{*textBox,#TUITBPEN_TEXT}
                                      *textBox\argb   [#TUITBPEN_TEXT] = -1
                                      *textBox\tuiPenN[#TUITBPEN_TEXT] = ti_Data
                                      *textBox\tuiPenS[#TUITBPEN_TEXT] = #TUIPEN_WHITE
                                      _tb_UpdatePens{*textBox} : done=False

    Case #TUITBA_EDITED             :
      If *textBox\edited >< ti_Data
        If *textBox\edited=0
          *textBox\edited = ti_Data
          !tuiHandleNotify{done,*textBox,onEdit,Null}
          done.l = True
        Else
          *textBox\edited = ti_Data
        End If
      End If

    Case #TUITBA_CURSORLINE         : _tb_SetCursor{*textBox,ti_Data,*textBox\cursor_cpos,-1,-1,*rp}
    Case #TUITBA_CURSORCHAR         : _tb_SetCursor{*textBox,*textBox\cursor_lpos,ti_Data,-1,-1,*rp}
    Case #TUITBA_BEGINSELECTLINE    : _tb_SetSelection{*textBox,ti_Data,*textBox\selection_begin_cpos,*textBox\selection_end_lpos,*textBox\selection_end_cpos}
    Case #TUITBA_BEGINSELECTCHAR    : _tb_SetSelection{*textBox,*textBox\selection_begin_lpos,ti_Data,*textBox\selection_end_lpos,*textBox\selection_end_cpos}
    Case #TUITBA_ENDSELECTLINE      : _tb_SetSelection{*textBox,*textBox\selection_begin_lpos,*textBox\selection_begin_cpos,ti_Data,*textBox\selection_end_cpos}
    Case #TUITBA_ENDSELECTCHAR      : _tb_SetSelection{*textBox,*textBox\selection_begin_lpos,*textBox\selection_begin_cpos,*textBox\selection_end_lpos,ti_Data}
    Case #TUITBA_TBFLAGS            : *textBox\edflags = ti_Data   : ntui_Refresh{*textBox,Null}
    Case #TUITBA_READONLY           : *textBox\edflags | #TUITBF_READONLY : If ti_Data=False Then *textBox\edflags - #TUITBF_READONLY
    Case #TUITBA_SETTBFLAGS         : *textBox\edflags | ti_Data   : ntui_Refresh{*textBox,Null}
    Case #TUITBA_CURSORSTYLE        : *textBox\cursorStyle = ti_Data   : ntui_Refresh{*textBox,Null}
    Case #TUITBA_AUTOINDENT         : *textBox\edflags | #TUITBF_AUTOINDENT : If ti_Data=False Then *textBox\edflags - #TUITBF_AUTOINDENT
    Case #TUITBA_DEFAULTSHORTCUTS   : *textBox\edflags | #TUITBF_DEFAULTSHORTCUTS : If ti_Data=False Then *textBox\edflags - #TUITBF_DEFAULTSHORTCUTS
    Case #TUITBA_CLEARTBFLAGS       : *textBox\edflags | ti_Data - ti_Data  : ntui_Refresh{*textBox,Null}
    Case #TUITBA_BLINKSPEED         : *textBox\blink_speed = ti_Data
    Case #TUITBA_TABWIDTH           : *textBox\tab_width = ti_Data
      If *textBox\tab_width<=0 Then *textBox\tab_width=1
      ntui_Refresh{*textBox,Null}
    Case #TUITBA_TOPLINE            : _tb_Scroll{*textBox,0,ti_Data-*textBox\topLine,*rp}    : _ntui_PropagateBind{*textBox,#TUIEV_BIND_VVALUE,*textBox\topLine,Null}
    Case #TUITBA_LEFTOFFSET         : _tb_Scroll{*textBox,ti_Data-*textBox\leftOffset,0,*rp} : _ntui_PropagateBind{*textBox,#TUIEV_BIND_HVALUE,*textBox\leftOffset,Null}
    Case #TUITBA_VISIBLELINES       : *textBox\visibleLines = ti_Data : _ntui_PropagateBind{*textBox,#TUIEV_BIND_VVISIBLE,*textBox\visibleLines,Null}
    Case #TUITBA_TOTALLINES         : *textBox\totalLines   = ti_Data : _ntui_PropagateBind{*textBox,#TUIEV_BIND_VTOTAL  ,*textBox\totalLines,Null}
    Case #TUITBA_VISIBLEWIDTH       : *textBox\visibleWidth = ti_Data : _ntui_PropagateBind{*textBox,#TUIEV_BIND_HVISIBLE,*textBox\visibleWidth,Null}
    Case #TUITBA_TOTALWIDTH         : *textBox\totalWidth   = ti_Data : _ntui_PropagateBind{*textBox,#TUIEV_BIND_HTOTAL  ,*textBox\totalWidth,Null}
    Case #TUITBA_MAXCHARS           : *textBox\maxChars = ti_Data
    Case #TUITBA_MAXLINES           : *textBox\maxLines = ti_Data
    Case #TUITBA_FONT               : *textBox\font = ti_Data : *textBox\fontstolen = True : ntui_Refresh{*textBox,Null}
    Case #TUITBA_LINE               : ; todo
    Case #TUITBA_SELECTION          : ; todo
    Case #TUITBA_TEXT               : _ntui_SetTextBoxText{*textBox,ti_Data,-1}   ;: ntui_Refresh{*textBox,Null}
    Case #TUITBA_NUMBER             : Format ""
                                      string.s = Str$(ti_Data)
                                      _ntui_SetTextBoxText{*textBox,&string,FLen(string)}
    Case #TUITBA_APPENDTEXT         : ntui_AppendTextBox {*textBox,ti_Data,-1}
                                      If (*textBox\topLine + *textBox\visibleLines >= *textBox\totalLines)
                                        ntui_ScrollTextBoxBottom{*textBox}
                                      End If

    Case #TUITBA_ONCHANGE           : str_WritePtr{&*textBox\onChange\notifyID ,ti_Data}
    Case #TUITBA_ONCHANGECB         : *textBox\onChange\callback = ti_Data
    Case #TUITBA_ONCLICK            : str_WritePtr{&*textBox\onClick\notifyID ,ti_Data}
    Case #TUITBA_ONCLICKCB          : *textBox\onClick\callback = ti_Data    
    Case #TUITBA_ONKEY              : str_WritePtr{&*textBox\onKey\notifyID ,ti_Data}
    Case #TUITBA_ONKEYCB            : *textBox\onKey\callback = ti_Data
    Case #TUITBA_ONPOSTKEY          : str_WritePtr{&*textBox\onPostKey\notifyID ,ti_Data}
    Case #TUITBA_ONPOSTKEYCB        : *textBox\onPostKey\callback = ti_Data
    Case #TUITBA_ONEDIT             : str_WritePtr{&*textBox\onEdit\notifyID ,ti_Data}
    Case #TUITBA_ONEDITCB           : *textBox\onEdit\callback = ti_Data
    Case #TUITBA_ONSUBMIT           : str_WritePtr{&*textBox\onSubmit\notifyID ,ti_Data}
    Case #TUITBA_ONSUBMITCB         : *textBox\onSubmit\callback = ti_Data
    Case #TUITBA_ONCURSOR           : str_WritePtr{&*textBox\onCursor\notifyID ,ti_Data}
    Case #TUITBA_ONCURSORCB         : *textBox\onCursor\callback = ti_Data
    Case #TUITBA_ONFILELISTENERCLOSE   :  str_WritePtr{&*textBox\onFileListenerClose\notifyID ,ti_Data}
    Case #TUITBA_ONFILELISTENERCLOSECB : *textBox\onFileListenerClose\callback = ti_Data
    Case #TUITBA_SCROLLERMODE       : *textBox\scrollerMode = ti_Data
    Case #TUITBA_FILENAME           : str_WritePtr{&*textBox\filename,ti_Data}
    Case #TUITBA_LOADFILE           : ntui_LoadTextBox{*textBox,ti_Data}
    Case #TUITBA_HINT               : str_WritePtr{&*textBox\hint ,ti_Data} : _tb_Damage{*textBox,0,0}
    Case #TUITBA_STYLECB            : *textBox\styleCB = ti_Data
      *tline.tline = *textBox\doc
      For lpos.l = 0 To *textBox\totalLines-1
        *tline\flags = (*tline\flags|#TUITBLF_STYLEFLAGS) - (#TUITBLF_STYLEFLAGS)
        *tline + SizeOf.tline
      Next
      If *textBox\styleCB><Null
        _tb_AddFontStyles{*textBox}
      End If
      ;_tb_Damage{*textBox,0,*textBox\totalLines-1}
      ntui_Refresh{*textBox,*textBox\obj\cbox}

    Case #TUITBA_UNDO
      If ti_Data=0
        If \undo Then ntui_FreeUndoStack{\undo} : \undo = Null
      Else
        If \undo = Null Then \undo = ntui_CreateUndoStack{*textBox\obj\engine\undoEngine}
        If \undo = Null Then done=False
      End If

    Default
      done = False
  End Select

  If *rp
    _tb_Repair{*textBox,*rp}
    ntui_ReleaseRastPort{*textBox}
  End If

  Function Return done
End Function
!_MakeGlobalFuncPointer{_ntui_SetTextBoxAttr,{Null,0,0}}


_ntui_GetTextBoxAttr:
Function.l _ntui_GetTextBoxAttr{*textBox.tuiTextBox,ti_Tag.l,*ti_Data.longP}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

  done.l = True
  Select ti_Tag
    Case #TUITBA_EDITED             : *ti_Data\l = *textBox\edited
    Case #TUITBA_CURSORLINE         : *ti_Data\l = *textBox\cursor_lpos
    Case #TUITBA_CURSORCHAR         : *ti_Data\l = *textBox\cursor_cpos
    Case #TUITBA_BEGINSELECTLINE    : *ti_Data\l = *textBox\selection_begin_lpos
    Case #TUITBA_BEGINSELECTCHAR    : *ti_Data\l = *textBox\selection_begin_cpos
    Case #TUITBA_ENDSELECTLINE      : *ti_Data\l = *textBox\selection_end_lpos
    Case #TUITBA_ENDSELECTCHAR      : *ti_Data\l = *textBox\selection_end_cpos
    Case #TUITBA_TBFLAGS            : *ti_Data\l = *textBox\edflags
    Case #TUITBA_CURSORSTYLE        : *ti_Data\l = *textBox\cursorStyle    
    Case #TUITBA_READONLY           : *ti_Data\l = (*textBox\edflags&#TUITBF_READONLY)><0
    Case #TUITBA_DEFAULTSHORTCUTS   : *ti_Data\l = (*textBox\edflags&#TUITBF_DEFAULTSHORTCUTS)><0
    Case #TUITBA_AUTOINDENT         : *ti_Data\l = (*textBox\edflags&#TUITBF_AUTOINDENT)><0
    Case #TUITBA_BLINKSPEED         : *ti_Data\l = *textBox\blink_speed
    Case #TUITBA_ROWHEIGHT          : *ti_Data\l = *textBox\rowheight
    Case #TUITBA_SPACEWIDTH         : *ti_Data\l = *textBox\space_width
    Case #TUITBA_TABWIDTH           : *ti_Data\l = *textBox\tab_width
    Case #TUITBA_VISIBLELINES       : *ti_Data\l = *textBox\visibleLines
    Case #TUITBA_TOTALLINES         : *ti_Data\l = *textBox\totalLines
    Case #TUITBA_TOPLINE            : *ti_Data\l = *textBox\topLine
    Case #TUITBA_VISIBLEWIDTH       : *ti_Data\l = *textBox\visibleWidth
    Case #TUITBA_TOTALWIDTH         : *ti_Data\l = *textBox\totalWidth
    Case #TUITBA_LEFTOFFSET         : *ti_Data\l = *textBox\leftOffset
    Case #TUITBA_MAXCHARS           : *ti_Data\l = *textBox\maxChars
    Case #TUITBA_MAXLINES           : *ti_Data\l = *textBox\maxLines
    Case #TUITBA_FONT               : *ti_Data\l = *textBox\font
    Case #TUITBA_SCROLLERMODE       : *ti_Data\l = *textBox\scrollerMode
    Case #TUITBA_LINE               : !line_use{*tline,*ti_Data\l}
                                      *ti_Data\l = Null
                                      If *tline
                                        If *tline\text
                                          str_WritePtr{&*textBox\obj\string,*tline\text,*tline\clength}
                                          *ti_Data\l = str_GetPtr{*textBox\obj\string}
                                        End If
                                      End If
    Case #TUITBA_LINELENGTH         : !line_use{*tline,*ti_Data\l}
                                      *ti_Data\l = 0
                                      If *tline
                                        *ti_Data\l = *tline\clength
                                      End If
    Case #TUITBA_SELECTION          : *ti_Data\l = 0 ; todo
    Case #TUITBA_TEXT               : cLength.l = 0
                                      For lpos.l = 0 To *textBox\totalLines-1
                                        !line_use{*tline,lpos}
                                        If *tline
                                          If *tline\text
                                            cLength + *tline\clength
                                          End If
                                        End If
                                      Next
                                      str_Alloc{&*textBox\obj\string,cLength}
                                      *ti_Data\l = str_GetPtr{*textBox\obj\string}
                                      done.l = 0
                                      For lpos = 0 To *textBox\totalLines-1
                                        !line_use{*tline,lpos}
                                        If *tline
                                          If *tline\text
                                            CopyMem_ *tline\text,  *ti_Data\l + done, *tline\clength
                                            done + *tline\clength
                                          End If
                                        End If
                                      Next
    Case #TUITBA_NUMBER             : _ntui_GetTextBoxAttr{*textBox,#TUITBA_TEXT,*ti_Data}
                                      If *ti_Data\l
                                        string.s = Peek.s(*ti_Data\l)
                                        *ti_Data\l = Vallong(string)
                                      End If

    Case #TUITBA_ONCLICK            : *ti_Data\l = str_GetPtr{*textBox\onClick\notifyID}
    Case #TUITBA_ONCLICKCB          : *ti_Data\l = *textBox\onClick\callback
    Case #TUITBA_ONCHANGE           : *ti_Data\l = str_GetPtr{*textBox\onChange\notifyID}
    Case #TUITBA_ONCHANGECB         : *ti_Data\l = *textBox\onChange\callback
    Case #TUITBA_ONKEY              : *ti_Data\l = str_GetPtr{*textBox\onKey\notifyID}
    Case #TUITBA_ONKEYCB            : *ti_Data\l = *textBox\onKey\callback
    Case #TUITBA_ONPOSTKEY          : *ti_Data\l = str_GetPtr{*textBox\onPostKey\notifyID}
    Case #TUITBA_ONPOSTKEYCB        : *ti_Data\l = *textBox\onPostKey\callback
    Case #TUITBA_ONEDIT             : *ti_Data\l = str_GetPtr{*textBox\onEdit\notifyID}
    Case #TUITBA_ONEDITCB           : *ti_Data\l = *textBox\onEdit\callback
    Case #TUITBA_ONSUBMIT           : *ti_Data\l = str_GetPtr{*textBox\onSubmit\notifyID}
    Case #TUITBA_ONSUBMITCB         : *ti_Data\l = *textBox\onSubmit\callback
    Case #TUITBA_ONCURSOR           : *ti_Data\l = str_GetPtr{*textBox\onCursor\notifyID}
    Case #TUITBA_ONCURSORCB         : *ti_Data\l = *textBox\onCursor\callback
    Case #TUITBA_ONFILELISTENERCLOSE   : *ti_Data\l = str_GetPtr{*textBox\onCursor\notifyID}
    Case #TUITBA_ONFILELISTENERCLOSECB : *ti_Data\l = *textBox\onCursor\callback
    Case #TUITBA_FILENAME           : *ti_Data\l = str_GetPtr{*textBox\filename}
    Case #TUITBA_HINT               : *ti_Data\l = str_GetPtr{*textBox\hint}
    Case #TUITBA_UNDO               : *ti_Data\l = (*textBox\undo><Null)
    Case #TUITBA_UNDOSTEPS          : *ti_Data\l = 0
                                      If (*textBox\undo><Null)
                                        ntui_GetUndoStackAttr{*textBox\undo,#TUIUSA_UNDOSTEPS,*ti_Data}
                                      End If
    Case #TUITBA_NUMBEROFCHANGES    : *ti_Data\l = 0
                                      If (*textBox\undo><Null)
                                        ntui_GetUndoStackAttr{*textBox\undo,#TUIUSA_NUMBEROFCHANGES,*ti_Data}
                                      End If

    Case #TUITBA_STYLECB            : *ti_Data\l = *textBox\styleCB
    Default
      done = False
  End Select

  Function Return done

End Function
!_MakeGlobalFuncPointer{_ntui_GetTextBoxAttr,{Null,0,Null}}


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_DispatchTextBox {*textBox.tuiTextBox,*ev.:: /
;/ tuiEvent}                                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ * do what happens if the user operates the String */                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *ev.tuiEvent    : ???                                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
_ntui_DispatchTextBoxEvent:
Function.l _ntui_DispatchTextBoxEvent{*textBox.tuiTextBox,*ev.tuiEvent}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}
  !_ASSERT{*ev}
  *obj.tuiObject = *textBox\obj
  done.l = False

  Select *ev\id
    Case #TUIEV_LOSEFOCUS
      *rp.RastPort = ntui_ObtainRastPort{*textBox}
      _tb_DoBlink{*textBox,*rp,Off}

      If *textBox\edflags&#TUITBF_LOOSESELECTIONONFOCUS
        _tb_SetSelection{*textBox}           ; select nothing
      End If
      _tb_Repair{*textBox,*rp}

      If *rp Then ntui_ReleaseRastPort{*textBox}
      !tuiHandleNotify{done,*textBox\obj,onLoseFocus,*ev}
      done=True

    Case #TUIEV_FOCUS
      *rp.RastPort = ntui_ObtainRastPort{*textBox}
      *textBox\accept = True
      *textBox\obj\flags | #TUIF_ACTIVE - #TUIF_ACTIVE
      If *textBox\edflags&#TUITBF_SELECTONFOCUS
        If *textBox\selection_begin_lpos<0
          If *textBox\cursor_lpos>=0
            !line_use{*tline, *textBox\cursor_lpos}
            If *tline
              If *textBox\cursor_cpos>=*tline\clength
                ;_tb_SetSelection{*textBox}
                ntui_SetTextBoxSelection{*textBox,*rp}  ; select all
              End If
            End If
          End If
        End If
      End If
      _tb_Repair{*textBox,*rp}
      _tb_DoBlink{*textBox,*rp,On}

      If *rp Then ntui_ReleaseRastPort{*textBox}
      !tuiHandleNotify{done,*textBox\obj,onFocus,*ev}
      done=True

    Case #TUIEV_LOSEMOVER
      !tuiHandleNotify{done,*textBox\obj,onLoseMover,*ev}
      done=True

    Case #TUIEV_MOVER
      !tuiHandleNotify{done,*textBox\obj,onMover,*ev}
      done=True

    Case #TUITBEV_APPEND:    
      ntui_AppendTextBox{*textBox,str_GetPtr{*ev\string},str_Len{*ev\string}}
      If (*textBox\topLine + *textBox\visibleLines >= *textBox\totalLines-1)
        ntui_ScrollTextBoxBottom{*textBox}
      End If
      ;ntui_SetAttr{*textbox,#TUITBA_APPEND,str_GetPtr{*ev\string}}

    Case #TUITBEV_FLCLOSE:
      !tuiHandleNotify{done.l,*textBox,onFileListenerClose,*ev}
      done=True

    Case #TUIEV_MOUSEDOWN:
      If *ev\value=0
        If ntui_HitObject{*textBox,*ev\pos\x,*ev\pos\y}
          If (!tuiRectHit{*textBox\obj\cbox,*ev\pos\x,*ev\pos\y});
          *textBox\obj\flags | #TUIF_ACTIVE
          \accept=1

          dbl.l = 0
          If *ev\qualifier_&#TUIQUAL_DOUBLECLICK Then dbl = 1
          If *ev\qualifier_&#TUIQUAL_TRIPLECLICK Then dbl = 2
          ox.l = *ev\pos\x - *textBox\obj\cbox\left
          oy.l = *ev\pos\y - *textBox\obj\cbox\top

          *rp.RastPort = ntui_ObtainRastPort{*textBox}

          _tb_DoBlink{*textBox,*rp,Off}
          _tb_MouseClick{*textBox,*rp,ox,oy,0,dbl}

          ntui_SetFocus{*textBox}
          ;If *textBox\edflags&#TUITBF_SELECTONFOCUS
          ;  If *textBox\selection_begin_lpos<0
          ;    If *textBox\cursor_lpos>=0
          ;      !line_use{*tline, *textBox\cursor_lpos}
          ;      If *tline
          ;        If *textBox\cursor_cpos>=*tline\clength
          ;          ntui_SetTextBoxSelection{*textBox.tuiTextBox,*rp}
          ;        End If
          ;      End If
          ;    End If
          ;  End If
          ;End If
          _tb_Repair{*textBox,*rp}
          _tb_DoBlink{*textBox,*rp,On}
          If *rp Then ntui_ReleaseRastPort{*textBox}

          done=True
          End If
        End If
        
      End If

    Case #TUIEV_MOUSEUP
      If (*textBox\obj\flags & #TUIF_ACTIVE)
        !tuiHandleNotify{done,*textBox,onClick,*ev}
        done.l = True
        *textBox\obj\flags | #TUIF_ACTIVE - #TUIF_ACTIVE
      End If
      
    Case #TUIEV_MOUSEMOVE
      If (*textBox\obj\flags & #TUIF_ACTIVE)
        If tuiMouseButtonMap(0)
          ox.l = *ev\pos\x - *textBox\obj\cbox\left
          oy.l = *ev\pos\y - *textBox\obj\cbox\top
          *rp.RastPort = ntui_ObtainRastPort{*textBox}
          _tb_MouseDrag{*textBox,*rp,ox,oy}
          _tb_Repair{*textBox,*rp}
          If *rp Then ntui_ReleaseRastPort{*textBox}
          done=True
        End If
      End If

    Case #TUIEV_KEYDOWN
      !tuiHandleNotify{done,*textBox,onKey,*ev}
      If done=False
        *rp.RastPort = ntui_ObtainRastPort{*textBox}
        done = _ntui_KeyStrokeTextBox{*textBox,*ev,*rp}
        If *rp Then ntui_ReleaseRastPort{*textBox}
        !tuiHandleNotify{discard.l,*textBox,onPostKey,*ev}
        If discard
          *rp.RastPort = ntui_ObtainRastPort{*textBox}
          _tb_Repair{*textBox,*rp}
          If *rp Then ntui_ReleaseRastPort{*textBox}
        End If
      End If

    Case #TUIEV_TICK
      *rp.RastPort = ntui_ObtainRastPort{*textBox}
      If *rp
        *oldRegion.Region = ntui_AddClip{*rp,*textBox\obj\cbox}
        _tb_DoBlink{*textBox,*rp,1}
        ntui_RemClip{*rp,*oldRegion}
        ntui_ReleaseRastPort{*textBox}
      End If

    Case #TUIEV_HSCROLL
      ;If *textBox\maxLines>1
        _ntui_SetTextBoxAttr{*textBox,#TUITBA_LEFTOFFSET,*textBox\leftOffset + *textBox\step_\x * *ev\value }
        done = True
      ;End If

    Case #TUIEV_VSCROLL
      If *textBox\maxLines><1
        _ntui_SetTextBoxAttr{*textBox,#TUITBA_TOPLINE,*textBox\topLine + *textBox\step_\y * *ev\value }
        done = True
      End If

    Case #TUIEV_BIND_HDELTA
      ;If *textBox\maxLines>1
        *rp.RastPort = ntui_ObtainRastPort{*textBox}
        _tb_Scroll{*textBox,*textBox\step_\x * *ev\value, 0, *rp}
        If *rp Then ntui_ReleaseRastPort{*textBox}
        done = True
      ;End If

    Case #TUIEV_BIND_VDELTA
      If *textBox\maxLines><1
        *rp.RastPort = ntui_ObtainRastPort{*textBox}
        _tb_Scroll{*textBox,0,*textBox\step_\y * *ev\value,*rp}
        If *rp Then ntui_ReleaseRastPort{*textBox}
        done = True
      End If

    Case #TUIEV_BIND_HVALUE
      ;If *textBox\maxLines>1
        *rp.RastPort = ntui_ObtainRastPort{*textBox}
        _tb_Scroll{*textBox,*ev\value-*textBox\leftOffset,0,*rp}
        If *rp Then ntui_ReleaseRastPort{*textBox}
        done = True
      ;End If

    Case #TUIEV_BIND_VVALUE
      If *textBox\maxLines><1
        *rp.RastPort = ntui_ObtainRastPort{*textBox}
        _tb_Scroll{*textBox,0,*ev\value-*textBox\topLine,*rp}
        If *rp Then ntui_ReleaseRastPort{*textBox}
        done = True
      End If

    Case #TUIEV_BIND_VALUE
      If *textBox\subClassID=#TUITB_STRING_NUMERIC
        *textBox\obj\value = *ev\value
      End If
      ntui_Refresh{*textBox,Null}
      done=True

    Case #TUIEV_BIND_STRING
      _ntui_SetTextBoxText{*textBox,str_GetPtr{*ev\string},str_Len{*ev\string}}
      ntui_Refresh{*textBox,Null}
      !tuiHandleNotify{done,*textBox,onChange,*ev}
      done=True

    Case #TUIEV_PROPAGATE
      If *textBox\maxLines><1
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_VTOTAL  ,*textBox\totalLines   ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_VVALUE  ,*textBox\topLine      ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_VVISIBLE,*textBox\visibleLines ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_VSTEP   ,*textBox\step_\y      ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_HTOTAL  ,*textBox\totalWidth   ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_HVALUE  ,*textBox\leftOffset   ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_HVISIBLE,*textBox\visibleWidth ,Null}
        _ntui_PropagateBind{*textBox,#TUIEV_BIND_HSTEP   ,*textBox\step_\x      ,Null}
      End If
      _ntui_PropagateBind{*textBox,#TUIEV_BIND_VALUE   ,*textBox\obj\value,Null}
      _ntui_GetTextBoxAttr{*textBox,#TUITBA_TEXT,(.longP)&l.l} ; this reads out obj\string
      _ntui_PropagateBind{*textBox,#TUIEV_BIND_STRING  ,*textBox\obj\value,*textBox\obj\string}
      done=True

    Default
      done = False
End Select

Function Return done
End Function
!_MakeGlobalFuncPointer{_ntui_DispatchTextBoxEvent,{Null,Null}}


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_DrawTextBox {*textBox.tuiTextBox,*rp.RastPort}              /
;/                                                                             /
;/ Description:                                                                /
;/       ; ....                                                                /
;/ * draw the button in all its beauty */                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
_ntui_DrawTextBox:
Statement _ntui_DrawTextBox{*textBox.tuiTextBox,*rp.RastPort,*rpclip.tuiRect}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

  *engine.tuiEngine = *textBox\obj\engine
  !_ASSERT{*engine}
  !_ASSERT{*rp}

  !tuiAndRect{bclip.tuiRect,*textBox\obj\bbox,*rpclip}
  If !tuiValidRect{bclip}=False Then Statement Return


;  *textBox\tuiPen[#TUITBPEN_BG]  =*textBox\tuiPen[#TUITBPEN_NoFocus]
;
;  If (*textBox\obj\flags&#TUIF_DISABLED)
;    *textBox\pen[#TUITBPEN_Text]=*textBox\pen[#TUITBPEN_DisabledFG]
;    *textBox\pen[#TUITBPEN_BG]  =*textBox\pen[#TUITBPEN_DisabledBG]
;  Else
;    *textBox\pen[#TUITBPEN_Text]=*textBox\pen[#TUITBPEN_EnabledFG]
;    *textBox\pen[#TUITBPEN_BG]  =*textBox\pen[#TUITBPEN_NoFocus]
;    If *textBox\obj\flags&#TUIF_FOCUS
;      If *textBox\tuiPen[#TUITBPEN_Focus]>=0   Then *textBox\pen[#TUITBPEN_BG]=*textBox\pen[#TUITBPEN_Focus]
;    Else
;      If *textBox\tuiPen[#TUITBPEN_NoFocus]>=0 Then *textBox\pen[#TUITBPEN_BG]=*textBox\pen[#TUITBPEN_NoFocus]
;      If *textBox\edflags&#TUITBF_LOOSESELECTIONONFOCUS
;  ;    _tb_SetSelect{*textBox}
;        *textBox\selection_begin_lpos = -1
;        *textBox\selection_end_lpos   = -1
;        _ntui_UpdateTextBoxString{*textBox.tuiTextBox}
;      End If
;    End If
;  End If
  ;If ((*textBox\obj\flags&#TUIF_FOCUS) = 0)
  ;  If *textBox\edflags&#TUITBF_LOOSESELECTIONONFOCUS
  ;    tb_SetSelection{*textBox}
  ;  End If
    ;_ntui_UpdateTextBoxString{*textBox.tuiTextBox}
  ;End If

  bgTuiPen.l = _ntui_DrawBG{*engine,*rp,*textBox\obj\bbox,*textBox\obj\ibox,*rpclip,Null,*textBox\tuiPenN[#TUITBPEN_BG],*textBox\obj\borderType,*textBox\obj\flags|#TUIF_ACTIVE,*textBox\obj\gradient}
;  If (*textBox\obj\borderType><#TUIBORDER_NONE)
;    bgDone.l = ntui_DrawBorder{*engine,*rp,*textBox\obj\bbox,*textBox\obj\borderType,*textBox\obj\flags}
;  Else
;    bgDone = False
;  End If
  ;bgTuiPen = #TUIPEN_BG

  If *textBox\hScroller
    If (*textBox\hScroller\obj\flags&#TUIF_ONSCREEN) Then _ntui_Draw{*textBox\hScroller,*rp,*rpclip}
  End If
  If *textBox\vScroller
    If (*textBox\vScroller\obj\flags&#TUIF_ONSCREEN) Then _ntui_Draw{*textBox\vScroller,*rp,*rpclip}
  End If
  If *textBox\funcButton
    If (*textBox\funcButton\obj\flags&#TUIF_ONSCREEN) Then _ntui_Draw{*textBox\funcButton,*rp,*rpclip}
  End If

  !tuiAndRect{iclip.tuiRect,*rpclip,*textBox\obj\ibox}
  If !tuiValidRect{iclip}=False Then Statement Return

  ; draw the background, obsolete, see above
  If bgTuiPen><#TUIPEN_TRANSPARENT AND False
    CNIF #TUI_DEBUG
    SetAPen_ *rp,*engine\pen[#TUIPEN_GREEN]
    CELSE
    SetAPen_ *rp,*textBox\penN[#TUITBPEN_BG]
    CEND
    !tuiAndRect{iclip.tuiRect,*textBox\obj\ibox,*rpclip}
    If !tuiValidRect{iclip}
      RectFill_ *rp,iclip\left,iclip\top,iclip\right,iclip\bottom
    End If
  End If

  !tuiAndRect{cclip.tuiRect,*rpclip,*textBox\obj\cbox}
  If !tuiValidRect{cclip}=False Then Statement Return

  x1.l = cclip\left
  x2.l = cclip\right
  y1.l = cclip\top
  y2.l = cclip\bottom

  If *textBox\maxLines><1 OR True Then bgTuiPen = *textBox\tuiPenN[#TUITBPEN_BG]

  Select *textBox\subClassID
    Case #TUITB_TEXTBOX
      _tb_DoBlink{*textBox,*rp,Off}
      ;SetAPen_ *rp,*engine\pen[#TUIPEN_SHADOW]
      ;x.l =  *textBox\obj\cbox\right+1
      ;Move_ *rp,x,y1 : Draw_ *rp,x,y2
      _ntui_DrawTextBoxIntern{*textBox,x1,y1,x2,y2,*rp}
      If (*textBox\obj\flags&#TUIF_FOCUS) Then _tb_DoBlink{*textBox,*rp,On}

    Default
      _tb_DoBlink{*textBox,*rp,Off}
      _ntui_DrawTextBoxIntern{*textBox,x1,y1,x2,y2,*rp}
      If (*textBox\obj\flags&#TUIF_FOCUS) Then _tb_DoBlink{*textBox,*rp,On}

  End Select

End Statement
!_MakeGlobalFuncPointer{_ntui_DrawTextBox,{Null,Null,Null}}



_ntui_LayoutTextBox:
Statement _ntui_LayoutTextBox{*textBox.tuiTextBox,*rp.RastPort,*bbox.tuiRect}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

  *obj.tuiObject = *textBox\obj
  *engine.tuiEngine = *textBox\obj\engine
  !_ASSERT{*engine}
  !_ASSERT{*rp}

  If *bbox
    !tuiCopyRect{*obj\bbox,*bbox}
  End If

  _ntui_GetBorderSize{*obj\engine,*obj\borderType,*obj\flags,*obj\border}
  !tuiRemBorder{*obj\ibox,*obj\bbox,*obj\border}
  !tuiRemBorder{*obj\cbox,*obj\ibox,*obj\padding}

  If (*textBox\fontstolen OR *textBox\font=Null)
    *textBox\fontstolen                = True
    tuifont.l = _ntui_SetFont{*engine,*textBox\obj\flags}
    *textBox\font                      = *engine\font[tuifont]
  End If

  *textBox\space_width               = *textBox\font\tf_XSize
  *textBox\ndc_width                 = *textBox\font\tf_XSize
  *textBox\rowheight                 = *textBox\font\tf_YSize

  If *textBox\vScroller><Null AND *textBox\scrollerMode=#TUISCROLLER_ALWAYS
    xs.l = *textBox\vScroller\obj\minsize\x
    !tuiCopyRect{sbox.tuiRect,*obj\ibox}
    *obj\ibox\right - xs
    *obj\cbox\right = *obj\ibox\right
    sbox\left  = *obj\cbox\right +1

    If *textBox\funcButton
      ys.l = *textBox\hScroller\obj\minsize\y
      !tuiCopyRect{fbox.tuiRect,sbox}
      sbox\bottom - ys
      fbox\top    = sbox\bottom+1
      _ntui_Layout{*textBox\funcButton,*rp,fbox}
    End If

    _ntui_Layout{*textBox\vScroller,*rp,sbox}
  End If

  If *textBox\hScroller><Null AND *textBox\scrollerMode=#TUISCROLLER_ALWAYS
    ys.l = *textBox\hScroller\obj\minsize\y
    !tuiCopyRect{sbox.tuiRect,*obj\ibox}
    *obj\ibox\bottom - ys
    *obj\cbox\bottom = *obj\ibox\bottom
    sbox\top  = *obj\cbox\bottom +1
    _ntui_Layout{*textBox\hScroller,*rp,sbox}
  End If

  *textBox\visibleLines = !tuiRectHeight{*obj\cbox} /*textBox\rowheight
  *textBox\visibleWidth = !tuiRectWidth{*obj\cbox}

  If *textBox\vScroller Then _ntui_UpdateScroller{*textBox\vScroller,*textBox\topLine,*textBox\visibleLines,*textBox\totalLines,1,False}
  If *textBox\hScroller Then _ntui_UpdateScroller{*textBox\hScroller,*textBox\leftOffset,*textBox\visibleWidth,*textBox\totalWidth,1,False}

End Statement
!_MakeGlobalFuncPointer{_ntui_LayoutTextBox,{Null,Null,Null}}

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ntui_GetTextBoxMinSize {*textBox.tuiTextBox,*rp.Ra:: /
;/ stPort}                                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * calculate the minimum size for the button */                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
_ntui_CalculateTextBoxMinSize:
Statement _ntui_CalculateTextBoxMinSize{*textBox.tuiTextBox,*rp.RastPort}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

*engine.tuiEngine = *textBox\obj\engine : If *engine=Null OR *rp=Null Then Statement Return

If (*textBox\fontstolen OR *textBox\font=Null)
  tuifont.l                             = _ntui_SetFont{*engine,*textBox\obj\flags}
  *textBox\font                      = *engine\font[tuifont]
  *textBox\fontstolen                = True
End If

*textBox\space_width               = *textBox\font\tf_XSize-1
*textBox\ndc_width                 = *textBox\font\tf_XSize
*textBox\rowheight                 = *textBox\font\tf_YSize
*textBox\tab_width                 = *textBox\font\tf_XSize*4
*textBox\scrollborder_x            = *textBox\tab_width
;obsolete, done in layout
;For n.l=0 To #TUITBPEN_MAX -1
;  If *textBox\tuiPen[n]      >=0 Then *textBox\pen[n]       = *engine\pen[*textBox\tuiPen[n]]
;  If *textBox\tuiPenSelect[n]>=0 Then *textBox\penSelect[n] = *engine\pen[*textBox\tuiPenSelect[n]]
;Next

 _tb_ObtainPens{*textBox}

If *textBox\vScroller Then _ntui_CalculateScrollerMinSize{*textBox\vScroller,*rp}
If *textBox\hScroller Then _ntui_CalculateScrollerMinSize{*textBox\hScroller,*rp}

Select *textBox\subClassID
  Case #TUITB_TEXTBOX
    minlines.l = *textBox\maxLines
    If minlines>3 Then minlines=3
    *textBox\obj\minsize\x  + *textBox\rowheight * minlines
    *textBox\obj\minsize\y  + *textBox\rowheight * minlines

  Default
    If *textBox\obj\flags&(#TUIF_SMALL|#TUIF_SERIF|#TUIF_FIX)
      *textBox\obj\minsize\y  = *engine\defSize[#TUISIZE_BUTTON]
    Else
      *textBox\obj\minsize\y  = *engine\defSize[#TUISIZE_BUTTON]
    End If
    ;*textBox\obj\minsize\y = *textBox\rowheight
    *textBox\obj\minsize\x = *textBox\obj\minsize\y ; *textBox\font\tf_YSize

End Select

*textBox\obj\minsize\x + !tuiBorderWidth{*textBox\obj\padding}
*textBox\obj\minsize\y + !tuiBorderHeight{*textBox\obj\padding}

_ntui_GetBorderSize{*engine,*textBox\obj\borderType,*textBox\obj\flags,*textBox\obj\border}
*textBox\obj\minsize\x + !tuiBorderWidth{*textBox\obj\border}
*textBox\obj\minsize\y + !tuiBorderHeight{*textBox\obj\border}

End Statement
!_MakeGlobalFuncPointer{_ntui_CalculateTextBoxMinSize,{Null,Null}}


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ntui_FreeTextBox {*textBox.tuiTextBox}                          /
;/                                                                             /
;/ Description:                                                                /
;/    ted_tokenize {*ted ,lpos}                                                /
;/ undo_Flush{\undo}                                                           /
;/ undo_SetSaved{\undo}                                                        /
;/ * free everything special that we allocated for the button */               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *textBox.tuiTextBox    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
_ntui_DeinitTextBox:
Statement _ntui_DeinitTextBox{*textBox.tuiTextBox}
  !_ASSERT{*textBox}
  !_ASSERT{*textBox\obj\classID=#TUICLASS_TEXTBOX}

  _tb_ReleasePens{*textBox}

  If \doc
    _tb_FreeText{*textBox}
    FreeVec_ \doc
    \allocLines=0
    \doc = Null
  End If
  If \undo Then ntui_FreeUndoStack{\undo} : \undo = Null
  If \fontstolen = False AND \font><Null Then CloseFont_ \font
  \font = Null
  !tuiFreeNotifyHandler{*textBox\onChange}
  !tuiFreeNotifyHandler{*textBox\onClick}
  !tuiFreeNotifyHandler{*textBox\onKey}
  !tuiFreeNotifyHandler{*textBox\onPostKey}
  !tuiFreeNotifyHandler{*textBox\onEdit}
  !tuiFreeNotifyHandler{*textBox\onSubmit}
  !tuiFreeNotifyHandler{*textBox\onCursor}
  !tuiFreeNotifyHandler{*textBox\onFileListenerClose}
  str_Free{&\filename}

  If *textBox\fileListener Then ntui_FreeFileListener{*textBox\fileListener} : *textBox\fileListener=Null

End Statement
!_MakeGlobalFuncPointer{_ntui_DeinitTextBox,{Null}}


ntui_TextBox:
Function.tuiTextBox ntui_TextBox{*tagList.TagItem}

  flags.l = #TUIF_CENTER|#TUIF_MIDDLE|#TUIF_WANTMOVER|#TUIF_WANTTAB
  *textBox.tuiTextBox = (.tuiTextBox)_ntui_CreateObject{#TUICLASS_TEXTBOX,SizeOf.tuiTextBox,flags}

  If *textBox
    *textBox\maxChars                        = 32767
    *textBox\maxLines                        = -1

    For n.l=0 To #TUITBPEN_MAX -1
      *textBox\tuiPenN[n]      = #TUIPEN_TEXT
      *textBox\tuiPenS[n]      = #TUIPEN_ACTIVETEXT
      *textBox\argb[n]         =-1
      *textBox\penN[n]         = 0
      *textBox\penS[n]         = 0
      *textBox\penObtained[n]  = False
    Next

    For n.l=0 To 255 ; accpet all ASCII characters
      *textBox\validChar[n]=True
    Next
    *textBox\validChar[$9B] = False
    *textBox\validChar[$03] = False
    *textBox\validChar[$9B] = False
    *textBox\validChar[$9B] = False

    *textBox\step_\x                         = *textBox\obj\engine\defStep\x
    *textBox\step_\y                         = 4

    ; regular pens
    *textBox\tuiPenN[#TUITBPEN_TEXT]         = #TUIPEN_TEXT
    *textBox\tuiPenN[#TUITBPEN_BG]           = #TUIPEN_WHITE
    *textBox\tuiPenS[#TUITBPEN_BG]           = #TUIPEN_MARKER
    *textBox\tuiPenN[#TUITBPEN_HINTTEXT]     = #TUIPEN_SHADOW
    *textBox\tuiPenN[#TUITBPEN_MARKER]       = #TUIPEN_MARKER

    ; highlightning
    *textBox\tuiPenN[#TUITBPEN_STRING]       = #TUIPEN_SHADOW
    *textBox\tuiPenN[#TUITBPEN_TOKEN]        = #TUIPEN_BLUE
    *textBox\tuiPenN[#TUITBPEN_NUMBER]       = #TUIPEN_DARKMAGENTA
    *textBox\tuiPenN[#TUITBPEN_CONSTANT]     = #TUIPEN_DARKMAGENTA
    *textBox\tuiPenN[#TUITBPEN_FUNCTION]     = #TUIPEN_DARKGREEN
    *textBox\tuiPenN[#TUITBPEN_DIRECTIVE]    = #TUIPEN_RED
    *textBox\tuiPenN[#TUITBPEN_COMMENT]      = #TUIPEN_DARKGREEN
    *textBox\tuiPenN[#TUITBPEN_MACRO]        = #TUIPEN_RED
    *textBox\tuiPenN[#TUITBPEN_TYPE]         = #TUIPEN_DARKCYAN
    *textBox\tuiPenN[#TUITBPEN_MEMBER]       = #TUIPEN_DARKBLUE
    *textBox\tuiPenN[#TUITBPEN_TAG]          = #TUIPEN_BLUE
    *textBox\tuiPenN[#TUITBPEN_ATTR]         = #TUIPEN_DARKGREEN
    *textBox\tuiPenN[#TUITBPEN_LABEL]        = #TUIPEN_BLUE
    *textBox\tuiPenN[#TUITBPEN_BG2]          = #TUIPEN_TOOLTIPBG;#TUIPEN_SHINE
    *textBox\tuiPenS[#TUITBPEN_BG2]          = #TUIPEN_MARKER
    *textBox\tuiPenN[#TUITBPEN_BG2]          = #TUIPEN_TOOLTIPBG;#TUIPEN_SHINE

    *textBox\font                            = Null
    *textBox\fontI                           = Null
    *textBox\fontB                           = Null
    *textBox\fontBI                          = Null
    *textBox\fontstolen                      = True
    *textBox\space_width                     = 8
    *textBox\ndc_width                       = 8
    *textBox\rowheight                       = 8
    *textBox\doc                             = Null
    *textBox\tank                            = Null
    *textBox\edflags                         = #TUITBF_NotePad;|#TUITBF_SHOWCR ;|#TUITBF_BLOCKSELECT;
    *textBox\blink_speed                     = 5
    *textBox\edited                          = 0
    *textBox\obj\borderType                  = #TUIBORDER_RECESSED
    *textBox\leftOffset                      = 0
    *textBox\topLine                         = 0
    *textBox\obj\pointerID                   = #TUIPOINTER_TEXT
    *textBox\selection_begin_lpos            = -1
    *textBox\selection_end_lpos              = -1
    *textBox\undo                            = Null
    *textBox\subClassID                      = #TUITB_TEXTBOX
    *textBox\edflags                         = #TUITBF_NotePad|#TUITBF_DEFAULTSHORTCUTS;|#TUITBF_SHOWCR ;|#TUITBF_BLOCKSELECT;
    *textBox\cursorStyle                     = #TUITBCS_LINE
    *textBox\blink_speed                     = 5
    *textBox\obj\borderType                  = #TUIBORDER_RECESSED
    *textBox\leftOffset                      = 0
    *textBox\topLine                         = 0
    *textBox\scrollerMode                    = #TUISCROLLER_AUTO
    *textBox\obj\gradient                    = #TUIORIENT_NONE
    *textBox\scrollborder_x                  = *textBox\tab_width
    *textBox\scrollborder_y                  = 0
    *textBox\filename                        = Null
    *textBox\hint                            = Null
    *textBox\styleCB                         = Null ; *_tb_DefaultStyleCB
    *textBox\obj\Draw                        = *_ntui_DrawTextBox
    *textBox\obj\Layout                      = *_ntui_LayoutTextBox
    *textBox\obj\DispatchEvent               = *_ntui_DispatchTextBoxEvent
    *textBox\obj\CalculateMinSize            = *_ntui_CalculateTextBoxMinSize
    *textBox\obj\Deinit                      = *_ntui_DeinitTextBox
    *textBox\obj\SetAttr                     = *_ntui_SetTextBoxAttr
    *textBox\obj\GetAttr                     = *_ntui_GetTextBoxAttr

    !tuiInitNotifyHandler{*textBox\onClick}
    !tuiInitNotifyHandler{*textBox\onChange}
    !tuiInitNotifyHandler{*textBox\onKey}
    !tuiInitNotifyHandler{*textBox\onPostKey}
    !tuiInitNotifyHandler{*textBox\onEdit}
    !tuiInitNotifyHandler{*textBox\onSubmit}
    !tuiInitNotifyHandler{*textBox\onCursor}
    !tuiInitNotifyHandler{*textBox\onFileListenerClose}

    If *tagList Then ntui_SetAttrs{*textBox,*tagList}

    _ntui_BeginChildren{*textBox}

    *textBox\vScroller    = ntui_VScroller{Null}
    If *textBox\vScroller
      ntui_SetAttr{*textBox\vScroller,#TUISCA_HASARROWS,True}
      ntui_SetAttr{*textBox\vScroller,#TUIA_BORDERTYPE,#TUIBORDER_NONE}
    End If

    *textBox\hScroller    = ntui_HScroller{Null}
    If *textBox\hScroller
      ntui_SetAttr{*textBox\hScroller,#TUISCA_HASARROWS,True}
      ntui_SetAttr{*textBox\hScroller,#TUIA_BORDERTYPE,#TUIBORDER_NONE}
    End If

    ;*textBox\funcButton   = ntui_FunctionButton{#TUIBUTTON_SAVE}

    _ntui_EndChildren{#TUICLASS_TEXTBOX}

    If (*textBox\vScroller) Then ntui_Bind{*textBox,*textBox\vScroller}
    If (*textBox\hScroller) Then ntui_Bind{*textBox,*textBox\hScroller}

    *textBox\fileListener = Null
  End If

  Function Return *textBox

End Function
!_MakeGlobalFuncPointer{ntui_TextBox,{Null}}

Function.l ntui_GetTextBoxPixelCoordinates{*textBox.tuiTextBox,lpos.l,cpos.l,*pos.tuiPixel}

  *rp.RastPort = ntui_ObtainRastPort{*textBox}
  If *rp
    *pos\x = _tb_pos2x{*textBox,lpos,cpos,*rp}   - \leftOffset + *textBox\obj\bbox\left
    *pos\y = _tb_line2y{*textBox,lpos}           + *textBox\obj\bbox\top
    ntui_ReleaseRastPort{*textBox}
    Function Return True
  End If
  
  Function Return False
  
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_String {string.s,maxChars.l,@notify.l,@help.s,@fl:: /
;/ ags.l,@userID.l}                                                            /
;/                                                                             /
;/ Description:                                                                /
;/ * create function for tui String */                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - string.s    : ???                                                         /
;/ - maxChars.l    : ???                                                       /
;/ - notify.l    : ???                                                         /
;/ - help.s    : ???                                                           /
;/ - flags.l    : ???                                                          /
;/ - userID.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
ntui_String:
Function.tuiTextBox ntui_String{*tagList.TagItem}

  DEFTYPE.tagL10 ltagList : n.l = 0
  ltagList\tag[n]\ti_Tag = #TUIA_SETFLAGS,#TUIF_FIXHEIGHT        : n=n+1
  ltagList\tag[n]\ti_Tag = #TUITBA_MAXLINES,1        : n=n+1
  ltagList\tag[n]\ti_Tag = #TUITBA_SCROLLERMODE,#TUISCROLLER_NEVER : n=n+1
  ltagList\tag[n]\ti_Tag = #TAG_DONE,0

  *textBox.tuiTextBox = ntui_TextBox{ltagList}
  If *textBox
    *textBox\subClassID                      = #TUITB_STRING
    *textBox\tuiPenN[#TUITBPEN_BG]           = #TUIPEN_BACKGROUND
    *textBox\tuiPenN[#TUITBPEN_BGFOCUS]      = #TUIPEN_BACKGROUND
    *textBox\tuiPenN[#TUITBPEN_BGNOFOCUS]    = #TUIPEN_BACKGROUND
    *textBox\tuiPenN[#TUITBPEN_BGDISABLED]   = #TUIPEN_HALFSHADOW
    *textBox\obj\pointerID                   = #TUIPOINTER_TEXT
    *textBox\edflags                         = #TUITBF_String
    *textBox\blink_speed                     = 5
    *textBox\obj\borderType                  = #TUIBORDER_STRING
    *textBox\obj\gradient                    = #TUIORIENT_HORIZONTAL
    *textBox\obj\gradient                    = #TUIORIENT_NONE

    *textBox\tuiPenN[#TUITBPEN_BG]           = #TUIPEN_HALFSHINE
    *textBox\tuiPenN[#TUITBPEN_BGFOCUS]      = #TUIPEN_SHINE
    *textBox\tuiPenN[#TUITBPEN_BGNOFOCUS]    = #TUIPEN_HALFSHINE
    *textBox\tuiPenN[#TUITBPEN_BGDISABLED]   = #TUIPEN_BACKGROUND

    If *tagList Then ntui_SetAttrs{*textBox,*tagList}

  End If

  Function Return *textBox

End Function
!_MakeGlobalFuncPointer{ntui_String,{Null}}


Statement ntui_InitTextBoxClass{}

  classID.l = ntui_RegisterClass{"textbox",(.tuiFunc)*ntui_TextBox,Null}

  ntui_RegisterAttr{classID,"cursorstyle"      ,#TUITBA_CURSORSTYLE        ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"cursorline"       ,#TUITBA_CURSORLINE         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"cursorchar"       ,#TUITBA_CURSORCHAR         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"beginselectline"  ,#TUITBA_BEGINSELECTLINE    ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"beginselectchar"  ,#TUITBA_BEGINSELECTCHAR    ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"endselectline"    ,#TUITBA_ENDSELECTLINE      ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"endselectchar"    ,#TUITBA_ENDSELECTCHAR      ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"tbflags"          ,#TUITBA_TBFLAGS            ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"settbflags"       ,#TUITBA_SETTBFLAGS         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"cleartbflags"     ,#TUITBA_CLEARTBFLAGS       ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"blinkspeed"       ,#TUITBA_BLINKSPEED         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"rowheight"        ,#TUITBA_ROWHEIGHT          ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"spacewidth"       ,#TUITBA_SPACEWIDTH         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"tabwidth"         ,#TUITBA_TABWIDTH           ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"visiblelines"     ,#TUITBA_VISIBLELINES       ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"totallines"       ,#TUITBA_TOTALLINES         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"topline"          ,#TUITBA_TOPLINE            ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"visiblewidth"     ,#TUITBA_VISIBLEWIDTH       ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"totalwidth"       ,#TUITBA_TOTALWIDTH         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"leftoffset"       ,#TUITBA_LEFTOFFSET         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"maxchars"         ,#TUITBA_MAXCHARS           ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"maxlines"         ,#TUITBA_MAXLINES           ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"font"             ,#TUITBA_FONT               ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"line"             ,#TUITBA_LINE               ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"linelength"       ,#TUITBA_LINELENGTH         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"selection"        ,#TUITBA_SELECTION          ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"readonly"         ,#TUITBA_READONLY           ,#TUIAT_BOOL     , 0,0 }
  ntui_RegisterAttr{classID,"onchange"         ,#TUITBA_ONCHANGE           ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"onchangecb"       ,#TUITBA_ONCHANGECB         ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"onkey"            ,#TUITBA_ONKEY              ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"onkeycb"          ,#TUITBA_ONKEYCB            ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"onpostkey"        ,#TUITBA_ONPOSTKEY          ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"onpostkeycb"      ,#TUITBA_ONPOSTKEYCB        ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"oncursor"         ,#TUITBA_ONCURSOR           ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"oncursorcb"       ,#TUITBA_ONCURSORCB         ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"onfilelistenerclose"         ,#TUITBA_ONFILELISTENERCLOSE          ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"onfilelistenerclosecb"       ,#TUITBA_ONFILELISTENERCLOSECB         ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"onedit"           ,#TUITBA_ONEDIT             ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"oneditcb"         ,#TUITBA_ONEDITCB           ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"text"             ,#TUITBA_TEXT               ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"subclassid"       ,#TUITBA_SUBCLASSID         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"scrollermode"     ,#TUITBA_SCROLLERMODE       ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"defaultshortcuts" ,#TUITBA_DEFAULTSHORTCUTS   ,#TUIAT_BOOL     , 0,0 }
  ntui_RegisterAttr{classID,"undo"             ,#TUITBA_UNDO               ,#TUIAT_BOOL     , 0,0 }
  ntui_RegisterAttr{classID,"edited"           ,#TUITBA_EDITED             ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"hint"             ,#TUITBA_HINT               ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"autoindent"       ,#TUITBA_AUTOINDENT         ,#TUIAT_BOOL     , 0,0 }
  ntui_RegisterAttr{classID,"onclick"          ,#TUITBA_ONCLICK            ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"onclickcb"        ,#TUITBA_ONCLICKCB          ,#TUIAT_PTR      , 0,0 }

  ntui_RegisterValue{classID,"never"           ,#TUISCROLLER_NEVER}
  ntui_RegisterValue{classID,"always"          ,#TUISCROLLER_ALWAYS}
  ntui_RegisterValue{classID,"auto"            ,#TUISCROLLER_AUTO}
  
  ntui_RegisterValue{classID,"block"           ,#TUITBCS_BLOCK}
  ntui_RegisterValue{classID,"line"            ,#TUITBCS_LINE}
  ntui_RegisterValue{classID,"boldline"        ,#TUITBCS_BOLDLINE}
  ntui_RegisterValue{classID,"underscore"      ,#TUITBCS_UNDERSCORE}

  classID.l = ntui_RegisterClass{"string",(.tuiFunc)*ntui_String,Null}

  ntui_RegisterAttr{classID,"cursorchar"       ,#TUITBA_CURSORCHAR         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"cursorstyle"      ,#TUITBA_CURSORSTYLE        ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"beginselectchar"  ,#TUITBA_BEGINSELECTCHAR    ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"endselectchar"    ,#TUITBA_ENDSELECTCHAR      ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"tbflags"          ,#TUITBA_TBFLAGS            ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"settbflags"       ,#TUITBA_SETTBFLAGS         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"cleartbflags"     ,#TUITBA_CLEARTBFLAGS       ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"blinkspeed"       ,#TUITBA_BLINKSPEED         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"rowheight"        ,#TUITBA_ROWHEIGHT          ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"spacewidth"       ,#TUITBA_SPACEWIDTH         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"tabwidth"         ,#TUITBA_TABWIDTH           ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"visiblewidth"     ,#TUITBA_VISIBLEWIDTH       ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"totalwidth"       ,#TUITBA_TOTALWIDTH         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"leftoffset"       ,#TUITBA_LEFTOFFSET         ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"maxchars"         ,#TUITBA_MAXCHARS           ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"font"             ,#TUITBA_FONT               ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"selection"        ,#TUITBA_SELECTION          ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"onchange"         ,#TUITBA_ONCHANGE           ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"onchangecb"       ,#TUITBA_ONCHANGECB         ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"onkey"            ,#TUITBA_ONKEY              ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"onkeycb"          ,#TUITBA_ONKEYCB            ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"onpostkey"        ,#TUITBA_ONPOSTKEY          ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"onpostkeycb"      ,#TUITBA_ONPOSTKEYCB        ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"oncursor"         ,#TUITBA_ONCURSOR           ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"oncursorcb"       ,#TUITBA_ONCURSORCB         ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"text"             ,#TUITBA_TEXT               ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"undo"             ,#TUITBA_UNDO               ,#TUIAT_BOOL     , 0,0 }
  ntui_RegisterAttr{classID,"defaultshortcuts" ,#TUITBA_DEFAULTSHORTCUTS   ,#TUIAT_BOOL     , 0,0 }
  ntui_RegisterAttr{classID,"edited"           ,#TUITBA_EDITED             ,#TUIAT_INT      , 0,0 }
  ntui_RegisterAttr{classID,"hint"             ,#TUITBA_HINT               ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"onsubmit"         ,#TUITBA_ONSUBMIT           ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"onsubmitcb"       ,#TUITBA_ONSUBMITCB         ,#TUIAT_PTR      , 0,0 }
  ntui_RegisterAttr{classID,"onclick"          ,#TUITBA_ONCLICK            ,#TUIAT_STRING   , 0,0 }
  ntui_RegisterAttr{classID,"onclickcb"        ,#TUITBA_ONCLICKCB          ,#TUIAT_PTR      , 0,0 }

End Statement

ntui_InitTextBoxClass{}
