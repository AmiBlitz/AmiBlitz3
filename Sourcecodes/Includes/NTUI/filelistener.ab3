; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "ram:"
; ExeFile         = "Empty"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 100000
; MakeSmallest    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 11
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8192
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 98
; CursorColumn    = 16
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 100
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 100
; Max GadgetList  = 100
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 200
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 100
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 1
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 10
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 100
; Max BlitzFont   = 1
; Max GTList      = 100
; /XTRA


NEWTYPE.tuiFileListener

  *obj.tuiObject
  *fileName.str
  *process.Process
  *onOpenCB.tuiFunc
  *onCloseCB.tuiFunc
  *onDataCB.tuiFunc
  *onFailCB.tuiFunc

  ; file handle
  fh.l
  err.w

  ; flags
  killme.w
  ready.w
  done.w

End NEWTYPE


SHARED *_ntui_FileListenerParam.tuiFileListener

; example callbacks
RunErrsOff ; debugger must be switched off
; return 0 if everything is fine, or error code
Function.l _ntui_OnDataCB{*fileListener.tuiFileListener,dataP.l,dataLen.l}

   If *fileListener\obj
     ; do something with the data and the object
     ; remember not to touch the object, only send events
     Function Return 0 ; ok
   End If

   Function Return -1 ; error

End Function

; return 0 if everything is fine, or error code
Function.l _ntui_OnCloseCB{*fileListener.tuiFileListener}

   If *fileListener\obj
     ; examine the error code
     Function Return 0
   End If

   Function Return -1

End Function

; return 0 if everything is fine, or error code
Function.l _ntui_OnOpenCB{*fileListener.tuiFileListener}

   If *fileListener\obj
     ; we may store the *listener in the *obj for later reference
     Function Return 0
   End If

   Function Return -1

End Function

; return 0 if everything is fine, or error code
Function.l _ntui_OnFailCB{*fileListener.tuiFileListener, err.l}

   Function Return err

End Function


LastRunErrsMode



RunErrsOff ; debugger must be switched off
_ntui_FileListenLooper
Function.w _ntui_FileListenLooper{}

  MOVE.l _ntui_filelistener_amiblitz_globalbase,A5
  *fileListener.tuiFileListener = *_ntui_FileListenerParam
  *fileListener\err = 0
  *fileListener\fh  = Open_ (str_GetPtr{*fileListener\fileName},#MODE_OLDFILE)

  !_CallFuncPointer{*fileListener\onDataCB,  *fileListener\err,*fileListener,?_debug_open,14}
  !_CallFuncPointer{*fileListener\onDataCB,  *fileListener\err,*fileListener,str_GetPtr{*fileListener\fileName},str_Len{*fileListener\fileName}}
  !_CallFuncPointer{*fileListener\onDataCB,  *fileListener\err,*fileListener,?_debug_open2,5}

  If *fileListener\fh
    If *fileListener\onOpenCB
      !_CallFuncPointer{*fileListener\onOpenCB,*fileListener\err,*fileListener}
    End If
    *fileListener\ready = True         ; filename must not be touched anymore

    If *fileListener\err=0
      Repeat
        done.l = Read_ (*fileListener\fh,&dat.l,1)
        If done>0
          If *fileListener\onDataCB
            !_CallFuncPointer{*fileListener\onDataCB,  *fileListener\err,*fileListener,&dat,done}
          End If
        End If
      Until done<=0 OR *fileListener\err><0

      If *fileListener\err = 0
        If *fileListener\onCloseCB
          !_CallFuncPointer{*fileListener\onCloseCB,*fileListener\err,*fileListener}
        End If
      Else
        If *fileListener\onFailCB
          !_CallFuncPointer{*fileListener\onFailCB,  *fileListener\err,*fileListener,*fileListener\err }
          !_CallFuncPointer{*fileListener\onDataCB,  *fileListener\err,*fileListener,?_debug_err,16}
        End If
      End If
    Else
      !_CallFuncPointer{*fileListener\onDataCB,  *fileListener\err,*fileListener,?_debug_nofh,23}
    End If
    Close_ *fileListener\fh
  Else
    *fileListener\err   = True
    *fileListener\ready = True
    !_CallFuncPointer{*fileListener\onDataCB,  *fileListener\err,*fileListener,?_debug_err,16}
  End If
  *fileListener\done = True
  !_CallFuncPointer{*fileListener\onDataCB,  *fileListener\err,*fileListener,?_debug_closed,11}

  Function Return 0
  _ntui_filelistener_amiblitz_globalbase:
  Dc.l 0
  _debug_open:
  Dc.b "Listening to ",34,10,0
  _debug_open2:
  Dc.b 34,"...",10,0
  _debug_err:
  Dc.b "=> Error!!!!!!!",10,0
  _debug_nofh:
  Dc.b "=> Unable to open file!",10,0
  _debug_done:
  Dc.b "Pipe done......",10,0
  _debug_ready:
  Dc.b "Ready.",10,0
  _debug_busy:
  Dc.b "Pipe busy......",10,0
  _debug_closed:
  Dc.b "=> Closed.",10,0

End Function
!_MakeGlobalFuncPointer{_ntui_FileListenLooper,{}}
LastRunErrsMode


Function.tuiFileListener ntui_FileListener{*obj.tuiObject,*filenameP.b,*onOpenCB.tuiFunc,*onCloseCB.tuiFunc,*onFailCB.tuiFunc,*onDataCB.tuiFunc}
  !_ASSERT{*obj}
  !_ASSERT{*filenameP}
  Stop
  *fileListener.tuiFileListener = AllocVec_(SizeOf.tuiFileListener,#MEMF_ANY)
  If *fileListener
    DEFTYPE.tag5 tagList
    MOVE.l a5,_ntui_filelistener_amiblitz_globalbase
    name.s = "NTUI FileListenLooper #"+Hex$(*obj)
    tagList\ti_Tag = #NP_Entry,*_ntui_FileListenLooper,#NP_Name,&name,#NP_Priority,0,#NP_StackSize,8192,#TAG_DONE,0

    *fileListener\fileName  = Null
    *fileListener\ready     = False
    *fileListener\done      = False
    *fileListener\killme    = False
    *fileListener\err       = 0
    *fileListener\obj       = *obj
    *fileListener\onOpenCB  = *onOpenCB
    *fileListener\onCloseCB = *onCloseCB
    *fileListener\onFailCB  = *onFailCB
    *fileListener\onDataCB  = *onDataCB
     str_WritePtr{&*fileListener\fileName,*filenameP}
    *_ntui_FileListenerParam = *fileListener
    *fileListener\process   = CreateNewProc_(tagList)
    If *fileListener\process
      While (*fileListener\ready = False) : Delay_ 1 : Wend
    Else
      *fileListener\err=1
    EndIf

    If *fileListener\err
      str_Free{&*fileListener\fileName}
      FreeVec_ *fileListener
      *fileListener = Null
    End If
  End If

  Function Return *fileListener

End Function

Statement ntui_FreeFileListener{*fileListener.tuiFileListener}

  If *fileListener\done=False
    *fileListener\killme = True

    If *fileListener\ready=True AND *fileListener\err=0
      fh.l = Open_ (str_GetPtr{*fileListener\fileName},#MODE_NEWFILE)
      If fh
        Close_ fh
      End If
    End If
    ; wait until fl returns..
    While (*fileListener\done=False) : Delay_ 1 : Wend
  End If

  str_Free{&*fileListener\fileName}
  FreeVec_ *fileListener

End Statement


