; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "ram:"
; ExeFile         = "Empty"
; CreateIcon      = 0
; Residents       = "all.res,SDSTCP2.res,xpk.res,ttengine.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 100000
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 21
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8193
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 1041
; CursorColumn    = 32
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 100
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 100
; Max GadgetList  = 100
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 200
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 100
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 1
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 10
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 100
; Max BlitzFont   = 1
; Max GTList      = 100
; Max ChunkyBuffer= 2
; /XTRA
#NTUI_HAS_WINDOW = 1

;/* tuiWindow attributes */
#TUIWA_BASE          =  #TAG_USER
#TUIWA_ONWINDROP     =  #TUIWA_BASE + 1 ; rw
#TUIWA_ONWINDROPCB   =  #TUIWA_BASE + 2 ; rw
#TUIWA_ONCLOSE       =  #TUIWA_BASE + 3 ; rw
#TUIWA_ONCLOSECB     =  #TUIWA_BASE + 4 ; rw
#TUIWA_ONACTIVE      =  #TUIWA_BASE + 5 ; rw
#TUIWA_ONACTIVECB    =  #TUIWA_BASE + 6 ; rw
#TUIWA_ONINACTIVE    =  #TUIWA_BASE + 7 ; rw
#TUIWA_ONINACTIVECB  =  #TUIWA_BASE + 8 ; rw
#TUIWA_ONTICK        =  #TUIWA_BASE + 9 ; rw
#TUIWA_ONTICKCB      =  #TUIWA_BASE + 10 ; rw
#TUIWA_INSTANCEID    =  #TUIWA_BASE + 11 ; r
#TUIWA_TITLE         =  #TUIWA_BASE + 12
;#TUIWA_OSWINFLAGS    =  #TUIWA_BASE + 13 ; w
#TUIWA_ONHOTKEY      =  #TUIWA_BASE + 14
#TUIWA_ONHOTKEYCB    =  #TUIWA_BASE + 15
#TUIWA_BACKDROP      =  #TUIWA_BASE + 16
#TUIWA_CLOSEABLE     =  #TUIWA_BASE + 17
#TUIWA_SIZEABLE      =  #TUIWA_BASE + 18
#TUIWA_DRAGABLE      =  #TUIWA_BASE + 19
#TUIWA_BORDERLESS    =  #TUIWA_BASE + 20
#TUIWA_SCREENPOSX    =  #TUIWA_BASE + 21
#TUIWA_SCREENPOSY    =  #TUIWA_BASE + 22
#TUIWA_SCREENBOX     =  #TUIWA_BASE + 23

;X Are onXZY events thrown?
;X Are onXZY event handlers initialized (constructor) and freed (Deinit)?
;X Are onXZY event handlers reachable via XML and SetAttr/GetAttr
;- remove *ev\tuiObject=... when notifyID is sent <======================== Why?
;X bool return values .w (get/setAttr/Dispatch are Bool!)
;X have all Pointer Return values? cast will be (.tuiType)
;X XML wrapper should Use SetObjectAttr instead of SetAttr For performance issues
;X is Syntax of getters AND setters OK (take pointers to fill, return value is bool)?
;X Every Setter should have a Getter AND v.v.
;X*ev shall be never never destroyed, Use tuiHandleNotify Macro !!!
;X Double Definitions of TUIA_ NOT allowed! Make own AND wrapp
;X are ASSERTs Used where it makes sense? (also assert the Object class!!!)
;X set "b" Builder functions
;- are all string freed On deinit?
;- does it only draw If visible?
;X does dispatch Event correctly
;X make constructor with only taglist
;X Make punction pointers via global variable (MakeGlobalFunctionPointer)
;X do we read/write notifyIDs to \notifyID and not the NotifyHandler itself?
;X has #TUI_HAS_XZY ?


Function.l ntui_RegisterHotKey{*obj.tuiObject,keyCode_.l,isRaw.l,qualifier_.l}
  !_ASSERT{*obj}

  *win.tuiWindow = ntui_GetRootWindow{*obj}
  If *win=Null Then Function Return False

  If *win\hotKeyX>=*win\hotKeyN OR *win\hotKeyA = Null
    hotKeyN.l = *win\hotKeyX+8
    *hotKeyA.tuiHotKey = AllocVec_(SizeOf.tuiHotKey * hotKeyN,#MEMF_ANY)
    If *hotKeyA
      If *win\hotKeyA
        CopyMem_ *win\hotKeyA,*hotKeyA,SizeOf.tuiHotKey * *win\hotKeyX
        FreeVec_ *win\hotKeyA
      End If
      *win\hotKeyA = *hotKeyA
      *win\hotKeyN = hotKeyN
    End If
  End If

  If *win\hotKeyX<*win\hotKeyN AND *win\hotKeyA><Null
    *hk.tuiHotKey = *win\hotKeyA + *win\hotKeyX * SizeOf.tuiHotKey
    *hk\target     = *obj
    *hk\keyCode_   = keyCode_
    *hk\isRaw      = isRaw
    *hk\qualifier_ = qualifier_
    *win\hotKeyX+1
    Function Return True
  End If

  Function Return False

End Statement


Function.l ntui_UnregisterHotKey{*obj.tuiObject,keyCode_.l,isRaw.l,qualifier_.l}
  !_ASSERT{*obj}

  *win.tuiWindow = ntui_GetRootWindow{*obj}
  If *win=Null Then Function Return 0

  count.l = 0
  For n.l=0 To *win\hotKeyX-1
    *hk.tuiHotKey = *win\hotKeyA + SizeOf.tuiHotKey * n
    If *hk\target = *obj
      If *hk\keyCode_ = keyCode_ OR keyCode_ = -1
        If *hk\isRaw=*hk\isRaw OR isRaw = -1
          If *hk\qualifier_ = qualifier_ OR qualifier_ = -1
            ; remove
            For m.l= n+1 To *win\hotKeyX-1
              CopyMem_ *win\hotKeyA + m * SizeOf.tuiHotKey,*win\hotKeyA + (m-1) * SizeOf.tuiHotKey,SizeOf.tuiHotKey
            Next
            *win\hotKeyX -1
            count+1
          End If
        End If
      End If
    End If
  Next

  Function Return count

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_GetWindowByID {*obj.tuiObject,@winID.l,@instanceI:: /
;/ D.l}                                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ Find a tuiWindow by winID, optionally add instanceID for more restrict search. */    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *obj.tuiObject  : tuiObject from were to start the search (this is typically a tuiEngine)                                                   /
;/ - winID.l         : winID of the tuiWindow                                                          /
;/ - instanceID.l    : instanceID of the tuiWindow (if any)                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l        : pointer to the tuiWindow or NULL if not found                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.tuiWindow ntui_GetWindowByID{*obj.tuiObject,nameID.s,@instanceID.l}
If *obj=Null Then Function Return Null
If (*obj\classID=#TUICLASS_WINDOW)
  l.l = &nameID-4
  *IDs.str = l ; this is ugly; I know
  If ((str_Comp{*obj\nameID,*IDs}=0) OR (nameID=""))
    *win.tuiWindow = (.tuiWindow)*obj
    If ((*win\instanceID=instanceID) OR (instanceID=-1))
      Function Return *win
    End If
  End If
End If

*obj.tuiObject = *obj\child
While *obj><Null
  *found.tuiWindow = ntui_GetWindowByID{*obj,nameID,instanceID}
  If *found Then Function Return *found
  *obj=*obj\next_
Wend
Function Return Null
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_HideWindow {*win.tuiWindow}                   /
;/                                                                             /
;/ Description:                                                                /
;/ Hide a tuiWindow.                                                                            /
;/* note: The window is not present on the screen anymore. But the whole tuiWindow object still exists and can be manipulated as if it was open.
;/* A call of ntui_ShowWindow will make it visible again. Use ntui_FreeWindow to aktually destroy the window object.
;/*
;/ Inputs:                                                                     /
;/ - *win.tuiWindow : pointer to the tuiWindow                                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : true if the window was hidden, false otherwise                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ntui_AmigaStripIntuiMessages{*oswin.Window}
  ; flush the IDCMP Events...
  If *oswin
    If *oswin\UserPort
      *mp.MsgPort = *oswin\UserPort
      If *mp\mp_MsgList
        *msg.IntuiMessage = (.IntuiMessage)*mp\mp_MsgList\lh_Head
        If *msg><Null
          While (*msg\ExecMessage\mn_Node\ln_Succ)
            *succ.Node = *msg\ExecMessage\mn_Node\ln_Succ
            If( *msg\IDCMPWindow=*oswin)
              Remove_ *msg
              ReplyMsg_ *msg
            End If
            *msg = (.IntuiMessage)*succ
            If *msg=-1 Then error{"Messgae succ is -1!!!!"}
          Wend
        End If
      End If
    End If
  End If
End Statement


Function.l ntui_HideWindow{*win.tuiWindow}
  !_ASSERT{*win}
  !_ASSERT{*win\obj\classID=#TUICLASS_WINDOW}

  If *win\appWin
    RemoveAppWindow_ *win\appWin
    *win\appWin=Null
  End If

  *oswin.Window = *win\oswin

  If *oswin

    Forbid_
      _ntui_AmigaStripIntuiMessages{*oswin}
      *oswin\UserPort = Null
      ModifyIDCMP_ *oswin, 0
    Permit_

    *win\obj\bbox\left = 0,0,*oswin\Width-1,*oswin\Height-1
    *win\obj\border\left = *oswin\BorderLeft, *oswin\BorderTop, *oswin\BorderRight , *oswin\BorderBottom

    *win\screenPos\x = *win\oswin\LeftEdge,*win\oswin\TopEdge

    CloseWindow_  *oswin
    *win\oswin = Null
    *win\state = #TUISTATE_CLOSED
  End If

  ntui_FlushRawKeys{}

  ntui_ClearFlags{*win,#TUIF_ONSCREEN,False}
  Function Return True

End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_DrawWindow {*win.tuiWindow,*rp.RastPort}                 /
;/                                                                             /
;/ Description:
;/ private: Draw the content of a tuiWindow into the given RastPort.
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *win.tuiWindow : tuiWindow                                             /
;/ - *rp.RastPort         : rastport                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
_ntui_DrawWindow:
Statement _ntui_DrawWindow{*win.tuiWindow,*rp.RastPort,*rpclip.tuiRect}

  !_ASSERT{*win}
  !_ASSERT{*win\obj\classID=#TUICLASS_WINDOW}
  *engine.tuiEngine = *win\obj\engine
  !_ASSERT{*engine}
  *obj.tuiObject = *win
  If ((*obj\flags&#TUIF_ONSCREEN)=0) Then Statement Return

  !tuiAndRect{clip.tuiRect,*obj\ibox,*rpclip}
  If !tuiValidRect{clip}=False Then Statement Return

  If *win\obj\bgImage
    *oldRegion.Region = ntui_AddClip{*rp,clip}
    ntui_DrawTBImage{*win\obj\bgImage,*rp,*win\obj\ibox,*win\obj\cbox,0,*win\obj\bgTuiPen}
    ntui_RemClip{*rp,*oldRegion}
    ; draw the background image
  Else
  If *win\obj\bgTuiPen>=0
    CNIF #NTUI_DEBUG
      SetAPen_ *rp, RNDPen{}
    CELSE
      SetAPen_ *rp,*engine\pen[*win\obj\bgTuiPen]
    CEND
    RectFill_ *rp,clip\left,clip\top,clip\right,clip\bottom
  EndIf

  End If

  *child.tuiObject = *win\obj\child
  While *child
    _ntui_Draw{*child,*rp,clip}
    *child = *child\next_
  Wend

  If *win\oswin
    If !tuiRectInside{*rpclip,*win\obj\ibox}
       ; no refresh!
       ;   error{"CLip is inside the ibox!"}
      ; a.s = " / Ibox: "+Str$(*win\obj\ibox\left)+"/"+Str$(*win\obj\ibox\top)+" - "+Str$(*win\obj\ibox\right)+"/"+Str$(*win\obj\ibox\bottom)
      ; error{"Refresh Bounds:"+Str$(*rpclip\left)+"/"+Str$(*rpclip\top)+" - "+Str$(*rpclip\right)+"/"+Str$(*rpclip\bottom)+a.s}
    Else
      If ((*win\oswin\Flags&#WFLG_WINDOWREFRESH)=0) ; only if we are not in intuitions refresh mode!
       ; RefreshWindowFrame_ *win\oswin ; intuition is doing this for us
      End If
    End If
  End If

End Statement
!_MakeGlobalFuncPointer{_ntui_DrawWindow,{Null,Null,Null}}


_ntui_CalculateWindowMinSize:
Statement _ntui_CalculateWindowMinSize{*win.tuiWindow,*rp.RastPort}
  !_ASSERT{*win}
  *obj.tuiObject = *win\obj
  !_ASSERT{*rp}
  *engine.tuiEngine = *obj\engine
  !_ASSERT{*engine}
  initsize.tuiPixel\x = *obj\minsize\x,*obj\minsize\y
  ;ntui_GetBorderSize{*engine,*obj\borderType,bs.tuiBorderSize}
  ;*obj\border\west = bs\west,bs\north,bs\east,bs\south

  *obj\minsize\x = 0,0
  *child.tuiObject = *obj\child
  While *child
    _ntui_CalculateMinSize{*child,*rp}

    minX.l = *child\minsize\x + !tuiBorderWidth{*child\margin}
    minY.l = *child\minsize\y + !tuiBorderHeight{*child\margin}
    If False
      *obj\minsize\x  + minX
      If *obj\minsize\y<minY Then *obj\minsize\y=minY
    Else
      If *obj\minsize\x<minX Then *obj\minsize\x=minX
      *obj\minsize\y + minY
    End If
    *child=*child\next_
  Wend

  *obj\minsize\x + !tuiBorderWidth{*obj\padding}
  *obj\minsize\y + !tuiBorderHeight{*obj\padding}

  ; actually, we shall add the borderize too, but we dont know it yet (window is closed at this stage)
;  *obj\minsize\x + *obj\border\left  + *obj\border\right
;  *obj\minsize\y + *obj\border\top   + *obj\border\bottom

End Statement
!_MakeGlobalFuncPointer{_ntui_CalculateWindowMinSize,{Null,Null}}


_ntui_SetWindowAttr:
Function.l _ntui_SetWindowAttr{*win.tuiWindow,ti_Tag.l,ti_Data.l}
  !_ASSERT{*win}
  !_ASSERT{*win\obj\classID=#TUICLASS_WINDOW}

  done.l = True
  Select ti_Tag
    ;Case #TUIWA_OSWINFLAGS   : *win\oswinFlags = ti_Data
    Case #TUIWA_ONCLOSE      : str_WritePtr{&*win\onClose\notifyID    ,ti_Data}
    Case #TUIWA_ONWINDROP    : str_WritePtr{&*win\onWinDrop\notifyID  ,ti_Data}
    Case #TUIWA_ONACTIVE     : str_WritePtr{&*win\onActive\notifyID   ,ti_Data}
    Case #TUIWA_ONINACTIVE   : str_WritePtr{&*win\onInactive\notifyID ,ti_Data}
    Case #TUIWA_ONTICK       : str_WritePtr{&*win\onTick\notifyID     ,ti_Data}
    Case #TUIWA_ONCLOSECB    : *win\onClose\callback    = ti_Data
    Case #TUIWA_ONWINDROPCB  : *win\onWinDrop\callback  = ti_Data
    Case #TUIWA_ONACTIVECB   : *win\onActive\callback   = ti_Data
    Case #TUIWA_ONINACTIVECB : *win\onInactive\callback = ti_Data
    Case #TUIWA_ONTICKCB     : *win\onTick\callback     = ti_Data
    Case #TUIWA_ONHOTKEY     : str_WritePtr{&*win\onHotKey\notifyID     ,ti_Data}
    Case #TUIWA_ONHOTKEYCB   : *win\onHotKey\callback    = ti_Data
    Case #TUIWA_BORDERLESS   : *win\borderless   = ti_Data
    Case #TUIWA_BACKDROP     : *win\backdrop     = ti_Data
    Case #TUIWA_CLOSEABLE    : *win\closeable    = ti_Data
    Case #TUIWA_SIZEABLE     : *win\sizeable     = ti_Data
    Case #TUIWA_DRAGABLE     : *win\dragable     = ti_Data

    Case #TUIWA_TITLE        : str_WritePtr{&*win\obj\string ,ti_Data}
      If *win\oswin Then SetWindowTitles_ *win\oswin,str_GetPtr{*win\obj\string},-1
    Case #TUIWA_INSTANCEID  : *win\instanceID = ti_Data
    Case #TUIWA_SCREENBOX   : 
      *bbox.tuiRect = (.tuiRect)ti_Data
      *win\screenPos\x = *bbox\left
      *win\screenPos\y = *bbox\top
      
      ;_ntui_Layout{*win,*rp,*bbox}
      If *win\oswin
        ChangeWindowBox_ *win\oswin,*bbox\left,*bbox\top,!tuiRectWidth{*bbox},!tuiRectHeight{*bbox}
      Else
        *win\obj\bbox\left      = 0
        *win\obj\bbox\top       = 0
        *win\obj\bbox\right     = !tuiRectWidth{*bbox} -1
        *win\obj\bbox\bottom    = !tuiRectHeight{*bbox}-1
        ;!tuiCopyRect{*win\obj\bbox,*bbox}
      End If
      
    Case #TUIWA_SCREENPOSX   : 
      *win\screenPos\x = ti_Data
      
    Case #TUIWA_SCREENPOSY   : 
      *win\screenPos\y = ti_Data

    Default
      done = False
  End Select
  Function Return done
End Function
!_MakeGlobalFuncPointer{_ntui_SetWindowAttr,{Null,0,0}}


_ntui_GetWindowAttr:
Function.l _ntui_GetWindowAttr{*win.tuiWindow,ti_Tag.l,*ti_Data.longP}
  !_ASSERT{*win}
  !_ASSERT{*win\obj\classID=#TUICLASS_WINDOW}

  done.l = True
  Select ti_Tag
    Case #TUIWA_TITLE        : *ti_Data\l = str_GetPtr{*win\obj\string}
    ;Case #TUIWA_OSWINFLAGS   : *ti_Data\l = *win\oswinFlags
    Case #TUIWA_ONCLOSE      : *ti_Data\l = str_GetPtr{*win\onClose\notifyID    }
    Case #TUIWA_ONWINDROP    : *ti_Data\l = str_GetPtr{*win\onWinDrop\notifyID  }
    Case #TUIWA_ONACTIVE     : *ti_Data\l = str_GetPtr{*win\onActive\notifyID   }
    Case #TUIWA_ONINACTIVE   : *ti_Data\l = str_GetPtr{*win\onInactive\notifyID }
    Case #TUIWA_ONTICK       : *ti_Data\l = str_GetPtr{*win\onTick\notifyID     }
    Case #TUIWA_ONCLOSECB    : *ti_Data\l = *win\onClose\callback
    Case #TUIWA_ONWINDROPCB  : *ti_Data\l = *win\onWinDrop\callback
    Case #TUIWA_ONACTIVECB   : *ti_Data\l = *win\onActive\callback
    Case #TUIWA_ONINACTIVECB : *ti_Data\l = *win\onInactive\callback
    Case #TUIWA_ONTICKCB     : *ti_Data\l = *win\onTick\callback
    Case #TUIWA_INSTANCEID   : *ti_Data\l = *win\instanceID
    Case #TUIWA_ONHOTKEY     : *ti_Data\l = str_GetPtr{*win\onHotKey\notifyID     }
    Case #TUIWA_ONHOTKEYCB   : *ti_Data\l = *win\onHotKey\callback
    Case #TUIWA_BORDERLESS   : *ti_Data\l = *win\borderless
    Case #TUIWA_BACKDROP     : *ti_Data\l = *win\backdrop
    Case #TUIWA_SIZEABLE     : *ti_Data\l = *win\sizeable
    Case #TUIWA_DRAGABLE     : *ti_Data\l = *win\dragable
    Case #TUIWA_CLOSEABLE    : *ti_Data\l = *win\closeable
    Case #TUIWA_SCREENPOSX   : *ti_Data\l = *win\screenPos\x
      If *win\oswin Then *ti_Data\l = *win\oswin\LeftEdge
    Case #TUIWA_SCREENPOSY   : *ti_Data\l = *win\screenPos\y
      If *win\oswin Then *ti_Data\l = *win\oswin\TopEdge
    Default
      done = False
  End Select
  Function Return done
End Function
!_MakeGlobalFuncPointer{_ntui_GetWindowAttr,{Null,0,Null}}

Function.l _ntui_MatchHotKey{*hk.tuiHotKey,rawKey_.l,vanillaKey.l,qualifier_.l}

  If *hk\isRaw Then keyCode_.l = rawKey_ : Else keyCode_.l = vanillaKey

  If keyCode_ >< *hk\keyCode_ Then Function Return False

  ok.l = True

  Select (*hk\qualifier_&#TUIQUAL_SHIFT)
    Case #TUIQUAL_RSHIFT : If (qualifier_&#TUIQUAL_RSHIFT = 0) Then ok = False
    Case #TUIQUAL_LSHIFT : If (qualifier_&#TUIQUAL_LSHIFT = 0) Then ok = False
    Case #TUIQUAL_SHIFT  : If (qualifier_&#TUIQUAL_SHIFT  = 0) Then ok = False
    Default
     If (qualifier_&#TUIQUAL_SHIFT >< 0) Then ok = False
  End Select

  Select (*hk\qualifier_&#TUIQUAL_ALT)
    Case #TUIQUAL_RALT : If (qualifier_&#TUIQUAL_RALT = 0) Then ok = False
    Case #TUIQUAL_LALT : If (qualifier_&#TUIQUAL_LALT = 0) Then ok = False
    Case #TUIQUAL_ALT  : If (qualifier_&#TUIQUAL_ALT  = 0) Then ok = False
    Default
     If (qualifier_&#TUIQUAL_ALT >< 0) Then ok = False
  End Select

  Select (*hk\qualifier_&#TUIQUAL_COM)
    Case #TUIQUAL_RCOM : If (qualifier_&#TUIQUAL_RCOM = 0) Then ok = False
    Case #TUIQUAL_LCOM : If (qualifier_&#TUIQUAL_LCOM = 0) Then ok = False
    Case #TUIQUAL_COM  : If (qualifier_&#TUIQUAL_COM  = 0) Then ok = False
    Default
     If (qualifier_&#TUIQUAL_COM >< 0) Then ok = False
  End Select

  If (*hk\qualifier_&#TUIQUAL_CTRL)
     If (qualifier_&#TUIQUAL_CTRL = 0) Then ok = False
  End If

  Function Return ok

End Function


_ntui_DispatchWindowEvent
Function.l _ntui_DispatchWindowEvent{*win.tuiWindow,*ev.tuiEvent}
  !_ASSERT{*win}
  !_ASSERT{*win\obj\classID=#TUICLASS_WINDOW}

  !_ASSERT{*ev}
  *engine.tuiEngine = *win\obj\engine
  !_ASSERT{*engine}

  closeToolTip.l = False
  done.l = False

  Select *ev\id
    Case #TUIEV_CLOSE
      !tuiHandleNotify{done,*win,onClose,*ev}
      closeToolTip=True

    Case #TUIEV_FOCUS
      If *win\focus
        ntui_SetFocus{*win\focus}
      End If

      If *win\obj\child
        *mover.tuiObject = ntui_HitObject{*win\obj\child,*ev\pos\x,*ev\pos\y}
        If *mover Then _ntui_SetMover{*mover}
      End If

      !tuiHandleNotify{done,*win,onActive,*ev}
      closeToolTip=True
      done=True

    Case #TUIEV_LOSEFOCUS
      ntui_FlushRawKeys{}
      ntui_SetFocus{*win\obj\engine}
      !tuiHandleNotify{done,*win,onInactive,*ev}
      closeToolTip=True
      done=True

    Case #TUIEV_MOUSEDOWN
      If ((*win\focus><Null) AND (*win\focus><*win))
        If (*win\focus\flags&#TUIF_DISABLED)=0
          If *win\focus\DispatchEvent Then !_CallFuncPointer{*win\focus\DispatchEvent,done,*win\focus,*ev}
        End If
      End If

      If done=False
        If *win\obj\child
          *mover.tuiObject = ntui_HitObject{*win\obj\child,*ev\pos\x,*ev\pos\y}
        Else
          *mover=Null
        End If

        If *mover
          If (*mover\flags&#TUIF_DISABLED)=0
            If *mover\DispatchEvent Then !_CallFuncPointer{*mover\DispatchEvent,done,*mover,*ev}
            *engine\restingTime = -1000
          End If
        End If
      End If
      closeToolTip=True

    Case #TUIEV_MOUSEUP
      If ((*win\focus><Null) AND (*win\focus><*win))
        If (*win\focus\flags&#TUIF_DISABLED)=0
          If *win\focus\DispatchEvent Then !_CallFuncPointer{*win\focus\DispatchEvent,done,*win\focus,*ev}
        End If
      End If

      If done=False
        If *win\obj\child
          *mover.tuiObject = ntui_HitObject{*win\obj\child,*ev\pos\x,*ev\pos\y}
        Else
          *mover=Null
        End If

        If *mover
          If (*mover\flags&#TUIF_DISABLED)=0
            If *mover\DispatchEvent Then !_CallFuncPointer{*mover\DispatchEvent,done,*mover,*ev}
          End If
        End If
      End If

    Case #TUIEV_MOUSEMOVE
      If ((*win\focus><Null) AND (*win\focus><*win))
        If (*win\focus\flags&#TUIF_DISABLED)=0
          If *win\focus\DispatchEvent Then !_CallFuncPointer{*win\focus\DispatchEvent,done,*win\focus,*ev}
        End If
      End If

      If done=False
        If *win\obj\child
          *mover.tuiObject = ntui_HitObject{*win\obj\child,*ev\pos\x,*ev\pos\y}
        Else
          *mover=Null
        End If

        If *mover >< *engine\mover
          _ntui_SetMover{*mover}
          *engine\restingTime = 0
          closeToolTip=True
        End If

        If *mover
          If (*mover\flags&#TUIF_DISABLED)=0
            If *mover\DispatchEvent Then !_CallFuncPointer{*mover\DispatchEvent,done,*mover,*ev}
          End If
        End If
      End If

    Case #TUIEV_KEYUP
      If *win\hotKeyX>0
        qualmask.l = #TUIQUAL_SHIFT|#TUIQUAL_CTRL|#TUIQUAL_COM|#TUIQUAL_ALT

        vanillaKey.l = ntui_MapRawKey{*ev\value,(*ev\qualifier_|qualmask) - qualmask}
        rawKey_.l    = *ev\value

        For n.l=0 To *win\hotKeyX-1
          *hk.tuiHotKey = *win\hotKeyA + SizeOf.tuiHotKey * n
          If (*hk\target\flags&#TUIF_DISABLED)=0 AND *hk\target\DispatchEvent
            If _ntui_MatchHotKey{*hk,rawKey_,vanillaKey,*ev\qualifier_}
              *ev\id = #TUIEV_HOTKEYUP
              If *hk\target\DispatchEvent Then !_CallFuncPointer{*hk\target\DispatchEvent,done,*hk\target,*ev}
              *ev\id = #TUIEV_KEYUP
            End If
          End If
        Next
      End If

      If done=False
        If ((*win\focus><Null) AND (*win\focus><*win) AND (done=False))
          If (*win\focus\flags&#TUIF_DISABLED)=0
            If *win\focus\DispatchEvent Then !_CallFuncPointer{*win\focus\DispatchEvent,done,*win\focus,*ev}
          End If
        End If
      End If

    Case #TUIEV_KEYDOWN
      If *win\hotKeyX>0
        qualmask.l = #TUIQUAL_SHIFT|#TUIQUAL_CTRL|#TUIQUAL_COM|#TUIQUAL_ALT
        vanillaKey.l = ntui_MapRawKey{*ev\value,(*ev\qualifier_|qualmask) - qualmask}
        rawKey_.l    = *ev\value

        For n.l=0 To *win\hotKeyX-1
          *hk.tuiHotKey = *win\hotKeyA + SizeOf.tuiHotKey * n
          If (*hk\target\flags&#TUIF_DISABLED)=0 AND *hk\target\DispatchEvent
            If _ntui_MatchHotKey{*hk,rawKey_,vanillaKey,*ev\qualifier_}
              *ev\id = #TUIEV_HOTKEYDOWN
              If *hk\target\DispatchEvent Then !_CallFuncPointer{*hk\target\DispatchEvent,done,*hk\target,*ev}
              *ev\id = #TUIEV_KEYDOWN
            End If
          End If
        Next
      End If

      If done=False
        If ((*win\focus><Null) AND (*win\focus><*win) AND (done=False))
          If (*win\focus\flags&#TUIF_DISABLED)=0
            If *win\focus\DispatchEvent Then !_CallFuncPointer{*win\focus\DispatchEvent,done,*win\focus,*ev}
          End If
        End If
      End If

      If done=False
        If (*ev\value=#RAWKEY_TAB OR *ev\value=#RAWKEY_RIGHT OR *ev\value=#RAWKEY_LEFT OR *ev\value=#RAWKEY_DOWN OR *ev\value=#RAWKEY_UP)
          If *win\focus=Null Then ntui_SetFocus{*win}
          If *win\focus
            *current.tuiObject = Null
            If *ev\value=#RAWKEY_LEFT OR *ev\value=#RAWKEY_UP Then dx.l=0:Else dx.l=1
            If  (*ev\qualifier_&#TUIQUAL_SHIFT) Then dx=1-dx
            If dx
              *current = ntui_GetNextTabObject{*win\focus}
            Else
              *current = ntui_GetPrevTabObject{*win\focus}
            End If
            If *current Then ntui_SetFocus{*current}
;            found.l = False
;            While *current><Null AND NOT(found)
;              If *current\child            ; descend
;                *current = *current\child
;                If ((*current\flags&#TUIF_WANTTAB)><0) AND ((*current\flags&#TUIF_DISABLED)=0)
;                  ntui_SetFocus{*current} : found=True
;                End If
;              Else
;                If *current\next_
;                  *current = *current\next_  ; go side
;                  If ((*current\flags&#TUIF_WANTTAB)><0) AND ((*current\flags&#TUIF_DISABLED)=0)
;                    ntui_SetFocus{*current} : found=True
;                  End If
;                Else
;                  found2.l = False
;                  While *current\parent><Null AND NOT(found2)      ; go up
;                    *current = *current\parent
;                    If *current\next_
;                      *current = *current\next_  ; go side
;                      If ((*current\flags&#TUIF_WANTTAB)><0) AND ((*current\flags&#TUIF_DISABLED)=0)
;                        ntui_SetFocus{*current} : found=True
;                      End If
;                      found2=True
;                    End If
;                  Wend
;                  If found2=False
;                    found=True
;                    ntui_SetFocus{*win}
;                  End If
;                End If
;              End If
;            Wend
          End If
        End If
;
;        If (*ev\value=#RAWKEY_TAB AND (*ev\qualifier_&#TUIQUAL_SHIFT)><0) OR *ev\value=#RAWKEY_LEFT OR *ev\value=#RAWKEY_UP
;          If *win\focus=Null Then ntui_SetFocus{*win}
;          If *win\focus
;            *current.tuiObject = *win\focus
;            found.l = False
;            While *current><Null AND NOT(found)
;              If *current\child            ; descend
;                *current = *current\child
;                While *current\next_ : *current=*current\next_ : Wend ; go to the last child
;                If ((*current\flags&#TUIF_WANTTAB)><0) AND ((*current\flags&#TUIF_DISABLED)=0)
;                  ntui_SetFocus{*current} : found=True
;                End If
;              Else
;                If *current\prev
;                  *current = *current\prev  ; go side
;                  If ((*current\flags&#TUIF_WANTTAB)><0) AND ((*current\flags&#TUIF_DISABLED)=0)
;                    ntui_SetFocus{*current} : found=True
;                  End If
;                Else
;                  found2.l = False
;                  While *current\parent><Null AND NOT(found2)      ; go up
;                    *current = *current\parent
;                    If *current\prev
;                      *current = *current\prev  ; go side
;                      If ((*current\flags&#TUIF_WANTTAB)><0) AND ((*current\flags&#TUIF_DISABLED)=0)
;                        ntui_SetFocus{*current} : found=True
;                      End If
;                      found2=True
;                    End If
;                  Wend
;                  If found2=False
;                    found=True
;                    ntui_SetFocus{*win}
;                  End If
;                End If
;              End If
;            Wend
;          End If
;        End If
      End If
      closeToolTip=True

    Case #TUIEV_RESIZE
      If (*win\obj\flags&#TUIF_ONSCREEN><0) AND *win\oswin><Null
        If !tuiRectWidth{*win\obj\bbox}><*win\oswin\Width OR !tuiRectHeight{*win\obj\bbox}><*win\oswin\Height
        *rp.RastPort = ntui_ObtainRastPort{*win}
        If *rp
          _ntui_Layout{*win,*rp,Null}
          ntui_ReleaseRastPort{*win}
          _ntui_Redraw{*win,*win\obj\bbox}
        End If
        End If
      End If
      closeToolTip=True

    Case #TUIEV_TICK
      If ((*win\focus><Null) AND (*win\focus><*win))
        If (*win\focus\flags&#TUIF_DISABLED)=0
          If *win\focus\DispatchEvent Then !_CallFuncPointer{*win\focus\DispatchEvent,done,*win\focus,*ev}
        End If
      End If

      If done=False
        If *engine\mover
          If (*engine\mover\flags&#TUIF_ACTIVE = 0)
            If *engine\mover\help
              If *engine\toolTip = Null
                *engine\restingTime+1
                If *engine\restingTime=12
                  ntui_PostEvent{*engine\mover,#TUIEV_TOOLTIP,*engine\restingTime}
                End If
              End If
            End If
          End If
        End If
        !tuiHandleNotify{done,*win,onTick,*ev}
      End If

    Case #TUIEV_WINDOWDROP
      If ((*win\focus><Null) AND (*win\focus><*win))
        If (*win\focus\flags&#TUIF_DISABLED)=0
          If *win\focus\DispatchEvent Then !_CallFuncPointer{*win\focus\DispatchEvent,done,*win\focus,*ev}
        End If
      End If

      If done=False
        If *win\obj\child
          *mover.tuiObject = ntui_HitObject{*win\obj\child,*ev\pos\x,*ev\pos\y}
        Else
          *mover=Null
        End If

        If *mover
          If (*mover\flags&#TUIF_DISABLED)=0
            If *mover\DispatchEvent Then !_CallFuncPointer{*mover\DispatchEvent,done,*mover,*ev}
            *engine\restingTime = -1000
          End If
        End If
      End If

      If done=False
        ;If *mover
        ;  *ev\obj = *mover
        ;Else
        ;  *ev\obj = *win
        ;End If
        !tuiHandleNotify{done,*win,onWinDrop,*ev}
      End If
      closeToolTip=True

    Case #TUIEV_HSCROLL
      If *win\obj\child
        *mover.tuiObject = ntui_HitObject{*win\obj\child,*ev\pos\x,*ev\pos\y}
      Else
        *mover=Null
      End If

      If *mover
        If (*mover\flags&#TUIF_DISABLED)=0
          If *mover\DispatchEvent Then !_CallFuncPointer{*mover\DispatchEvent,done,*mover,*ev}
        End If
      End If

      If done=False
        If ((*win\focus><Null) AND (*win\focus><*win))
          If (*win\focus\flags&#TUIF_DISABLED)=0
            If *win\focus\DispatchEvent Then !_CallFuncPointer{*win\focus\DispatchEvent,done,*win\focus,*ev}
          End If
        End If
      End If

    Case #TUIEV_VSCROLL
      If *win\obj\child
        *mover.tuiObject = ntui_HitObject{*win\obj\child,*ev\pos\x,*ev\pos\y}
      Else
        *mover=Null
      End If

      While *mover><Null AND done=False AND *mover><*win
        If (*mover\flags&#TUIF_DISABLED)=0
          If *mover\DispatchEvent Then !_CallFuncPointer{*mover\DispatchEvent,done,*mover,*ev}
        End If
        *mover = *mover\parent
      Wend

      If done=False
        If ((*win\focus><Null) AND (*win\focus><*win))
          If (*win\focus\flags&#TUIF_DISABLED)=0
            If *win\focus\DispatchEvent Then !_CallFuncPointer{*win\focus\DispatchEvent,done,*win\focus,*ev}
          End If
        End If
      End If

    Default ; no events left to send to focus/mover object...
      ;If ((*win\focus><Null) AND (*win\focus><*win))
      ;  If (*win\focus\flags&#TUIF_DISABLED)=0
      ;    If *win\focus\DispatchEvent Then !_CallFuncPointer{*win\focus\DispatchEvent,done,*win\focus,*ev}
      ;  End If
      ;End If

  End Select

  If closeToolTip Then If *engine\toolTip Then ntui_FreeObject{*engine\toolTip} : *engine\toolTip=Null

  Function Return done

End Function
!_MakeGlobalFuncPointer{_ntui_DispatchWindowEvent,{Null,Null}}


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ntui_FreeWindow {*win.tuiWindow}                             /
;/                                                                             /
;/ Description:                                                                /
;/ private: free a tuiWindow
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *win.tuiWindow    : ???                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
_ntui_DeinitWindow:
Statement _ntui_DeinitWindow{*win.tuiWindow}
  !_ASSERT{*win}
  !_ASSERT{*win\obj\classID=#TUICLASS_WINDOW}

  ntui_HideWindow{*win}
  !tuiFreeNotifyHandler{*win\onClose}
  !tuiFreeNotifyHandler{*win\onWinDrop}
  !tuiFreeNotifyHandler{*win\onActive}
  !tuiFreeNotifyHandler{*win\onInactive}
  !tuiFreeNotifyHandler{*win\onTick}
  !tuiFreeNotifyHandler{*win\onHotKey}

  If *win\hotKeyA
    FreeVec_ *win\hotKeyA
    *win\hotKeyX = 0
    *win\hotKeyN = 0
    *win\hotKeyA = Null
  End If

End Statement
!_MakeGlobalFuncPointer{_ntui_DeinitWindow,{Null}}


_ntui_LayoutWindow:
Statement _ntui_LayoutWindow{*win.tuiWindow,*rp.RastPort,*bbox.tuiRect}
  !_ASSERT{*win}
  !_ASSERT{*win\obj\classID=#TUICLASS_WINDOW}

  *obj.tuiObject = *win\obj
  !_ASSERT{*rp}
  *engine.tuiEngine = *obj\engine
  !_ASSERT{*engine}

  If *bbox  ; set new boundig box
    !tuiCopyRect{*obj\bbox,*bbox}
    
    ;*obj\bbox\left      = 0;*bbox\left ; this is the bounding box of the content, not the window! see *win\screenPos
    ;*obj\bbox\top       = 0;*bbox\top
    ;*obj\bbox\right     = !tuiRectWidth{*bbox}-1
    ;*obj\bbox\bottom    = !tuiRectHeight{*bbox}-1

    If *win\oswin
      nx.l = *win\screenPos\x
      ny.l = *win\screenPos\y
      nw.l = !tuiRectWidth {*obj\bbox}
      nh.l = !tuiRectHeight{*obj\bbox}
      ;If nw><*win\oswin\Width OR nh><*win\oswin\Height
        ChangeWindowBox_ *win\oswin,nx,ny,nw,nh
        ;SizeWindow_ *win\oswin,nw-*win\oswin\Width,nh-*win\oswin\Height
      ;End If
    End If
  End If

  If *win\oswin ; update border end content box
    *obj\bbox\left      = 0
    *obj\bbox\top       = 0
    *obj\bbox\right     = *win\oswin\Width -1
    *obj\bbox\bottom    = *win\oswin\Height-1
    *obj\border\left    = *win\oswin\BorderLeft
    *obj\border\top     = *win\oswin\BorderTop
    *obj\border\right   = *win\oswin\BorderRight
    *obj\border\bottom  = *win\oswin\BorderBottom
    *win\screenPos\x    = *win\oswin\LeftEdge
    *win\screenPos\y    = *win\oswin\TopEdge
  End If

  !tuiRemBorder{*obj\ibox,*obj\bbox,*obj\border}
  !tuiRemBorder{*obj\cbox,*obj\ibox,*obj\padding}

  *obj\flags      = *obj\flags | (#TUIF_ONSCREEN|#TUIF_DIRTY)

  !tuiCopyRect{cbox.tuiRect,*obj\cbox}

  menuBarHeight.l = 0
  *child.tuiObject = *obj\child
  If *child
    If *child\classID=#TUICLASS_GROUP
      *objGroup.tuiGroup=(.tuiGroup)*child
      If *objGroup\subClassID=#TUIGROUP_MENUBAR
        cbox\bottom = *child\minsize\y + !tuiBorderHeight{*child\margin}
        _ntui_Layout{*child,*rp,cbox}
        cbox\top=cbox\bottom+1
        cbox\bottom = *obj\cbox\bottom
        *child=*child\next_
      End If
    End If

    If *child
      _ntui_Layout{*child,*rp,cbox}
    End If
  End If
End Statement
!_MakeGlobalFuncPointer{_ntui_LayoutWindow,{Null,Null,Null}}


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_ShowWindow {*win.tuiWindow,@xpos.l,@ypos.l,:: /
;/ @*masterWindow.tuiWindow}                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Make a tuiWindow visible on the screen.
;/ Note: this function has no effect if the tuiEngine, to which the tuiWindow belongs too, is not popped up on a screen (=iconified)
;/ Note: if the window is aready visible on the screen, it will be activated and put to front.
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *win.tuiWindow    : tuiWindow                                             /
;/ - xpos.l                  : initial x position                                                          /
;/ - ypos.l                  : initial y position                                                           /
;/ - *masterWindow.tuiWindow : masterwindow, if any (for internal menu use only)                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ntui_ShowWindow{*win.tuiWindow,@xpos.l,@ypos.l,@*masterWindow.tuiWindow,@catchFocus.l}   ; master win should not be in Show function
!_ASSERT{*win\obj\classID=#TUICLASS_WINDOW}

  *obj.tuiObject = *win\obj
  *engine.tuiEngine = *obj\engine
  If (*engine\screen_ = Null) Then _ntui_OpenScreen{*engine,Null}
  If (*engine\screen_ = Null) Then Function Return False ; no screen

  succ.l = False
  If *win\oswin
    WindowToFront_ *win\oswin
    If (*win\oswinFlags&#WFLG_ACTIVATE) Then ActivateWindow_ *win\oswin
    succ=True
  Else
;    Forbid_
;    *oldFont.TextFont = *engine\scr\RastPort\Font
    _ntui_CalculateMinSize{*win,*engine\buildRP}
;    SetFont_ *engine\scr\RastPort,*oldFont
;    Permit_
    ;/* set sizes ... */
    iww.l = Max(*obj\minsize\x,*obj\bbox\right -*obj\bbox\left+1 - *obj\border\left-*obj\border\right )
    iwh.l = Max(*obj\minsize\y,*obj\bbox\bottom-*obj\bbox\top +1 - *obj\border\top -*obj\border\bottom)

    DEFTYPE.NewWindow nw
    ;nw\LeftEdge    = xpos
    ;nw\TopEdge     = ypos

    ;If nw\LeftEdge =-1 Then nw\LeftEdge = *win\screenPos\x
    ;If nw\TopEdge  =-1 Then nw\TopEdge  = *win\screenPos\y

    ;If nw\LeftEdge =-1 Then nw\LeftEdge = (*engine\screen_\Width    - iww)/2
    ;If nw\TopEdge  =-1 Then nw\TopEdge  = (*engine\screen_\Height   - iwh)/3

    ; use the setup screen pos
    nw\LeftEdge    = *win\screenPos\x
    nw\TopEdge     = *win\screenPos\y

    ; if we set a new pos via parameters, use them!
    If xpos>=0 Then nw\LeftEdge = xpos
    If ypos>=0 Then nw\TopEdge  = ypos

    ; if position still unset, use middle of the screen
    If nw\LeftEdge =-1 Then nw\LeftEdge = (*engine\screen_\Width    - iww)/2
    If nw\TopEdge  =-1 Then nw\TopEdge  = (*engine\screen_\Height   - iwh)/3

    nw\Width       = iww
    nw\Height      = iwh
    nw\DetailPen   = -1 ; use intuitions default
    nw\BlockPen    = -1
    nw\IDCMPFlags  = 0
    IDCMPFlags.l   = #IDCMP_CLOSEWINDOW|#IDCMP_ACTIVEWINDOW|#IDCMP_INACTIVEWINDOW|#IDCMP_REFRESHWINDOW|#IDCMP_NEWSIZE
    IDCMPFlags     = IDCMPFlags|#IDCMP_MOUSEBUTTONS|#IDCMP_MOUSEMOVE|#IDCMP_INTUITICKS|#IDCMP_RAWKEY
    IDCMPFlags     = IDCMPFlags|#IDCMP_EXTENDEDMOUSE ;/* OS4 Xtra-Sausage
    ;IDCMPFlags     = IDCMPFlags|#IDCMP_SIZEVERIFY ; may help

    *win\oswinFlags|#WFLG_ACTIVATE    : If catchFocus     =False Then *win\oswinFlags - #WFLG_ACTIVATE
    *win\oswinFlags|#WFLG_CLOSEGADGET : If *win\closeable =False Then *win\oswinFlags - #WFLG_CLOSEGADGET
    *win\oswinFlags|#WFLG_DRAGBAR     : If *win\dragable  =False Then *win\oswinFlags - #WFLG_DRAGBAR
    *win\oswinFlags|#WFLG_DEPTHGADGET : If *win\dragable  =False Then *win\oswinFlags - #WFLG_DEPTHGADGET
    *win\oswinFlags|#WFLG_BACKDROP    : If *win\backdrop  =False Then *win\oswinFlags - #WFLG_BACKDROP
    *win\oswinFlags|#WFLG_SIZEGADGET  : If *win\sizeable  =False Then *win\oswinFlags - #WFLG_SIZEGADGET
    *win\oswinFlags|#WFLG_BORDERLESS
    If *win\borderless = False
      *win\oswinFlags - #WFLG_BORDERLESS
    Else
      *win\oswinFlags | #WFLG_CLOSEGADGET : *win\oswinFlags - #WFLG_CLOSEGADGET           ;fixed the remove tomsmart1
      *win\oswinFlags | #WFLG_SIZEGADGET  : *win\oswinFlags - #WFLG_SIZEGADGET
      *win\oswinFlags | #WFLG_DEPTHGADGET : *win\oswinFlags - #WFLG_DEPTHGADGET
      *win\oswinFlags | #WFLG_HASZOOM     : *win\oswinFlags - #WFLG_HASZOOM
      *win\oswinFlags | #WFLG_DRAGBAR     : *win\oswinFlags - #WFLG_DRAGBAR
    End If

    nw\Flags       = *win\oswinFlags

    If (*win\obj\flags&#TUIF_FIXWIDTH)=0 OR (*win\obj\flags&#TUIF_FIXHEIGHT)=0 ; we need a size gadget
      If (nw\Flags&#WFLG_BORDERLESS) = 0 ; unless it is borderless...
        If *win\sizeable = True                                                ; added to allow no sizeable windows   
          nw\Flags | #WFLG_SIZEGADGET|#WFLG_HASZOOM|#WFLG_SIZEBBOTTOM
        EndIf
      Else
        nw\Flags | #WFLG_SIZEGADGET|#WFLG_HASZOOM|#WFLG_SIZEBBOTTOM
        nw\Flags - #WFLG_SIZEGADGET-#WFLG_HASZOOM-#WFLG_SIZEBBOTTOM
      End If
    End If


    badFlags.l = #WFLG_NW_EXTENDED | #WFLG_SUPER_BITMAP | #WFLG_GIMMEZEROZERO
    nw\Flags = (nw\Flags | badFlags) - badFlags ; just in case someone set this flags!!!
    nw\FirstGadget = Null
    nw\CheckMark   = Null
    If str_Len{*win\obj\string}>0 AND (nw\Flags&#WFLG_BORDERLESS) = 0
      nw\Title  = str_GetPtr{*win\obj\string}
    Else
      nw\Title  = Null
    End If
    nw\Screen      = *engine\screen_
    nw\BitMap      = Null
    nw\MinWidth    = 0
    nw\MinHeight   = 0
    nw\MaxWidth    = 0
    nw\MaxHeight   = 0
    nw\Type        = #CUSTOMSCREEN

    DEFTYPE.tag5 wtags
    wtags\ti_Tag =#WA_AutoAdjust,1,#WA_InnerWidth,iww,#WA_InnerHeight,iwh,#WA_BackFill,#LAYERS_NOBACKFILL,#TAG_DONE,0
    *win\oswin = OpenWindowTagList_(nw,wtags)
    If *win\oswin
      *win\oswin\UserData = *win
      *win\state = #TUISTATE_OPEN
      succ=True

      CNIF #NTUI_SAFERESIZE
      CopyMem_ *win\oswin\RPort,&*win\rp,SizeOf.RastPort
;      SetOutlinePen_ *win\rp,256
      *win\rp\AOlPen = 0
      ;Make layout
      CEND

      wx.l  = *win\oswin\BorderLeft
      wy.l  = *win\oswin\BorderTop
      ww.l  = *win\oswin\Width
      wh.l  = *win\oswin\Height
      iww.l = *win\oswin\Width     -*win\oswin\BorderRight -*win\oswin\BorderLeft
      iwh.l = *win\oswin\Height    -*win\oswin\BorderBottom-*win\oswin\BorderTop

      If (*win\obj\flags&#TUIF_FIXWIDTH)
        *win\obj\maxsize\x = *win\obj\minsize\x
      Else
        *win\obj\maxsize\x = 32767
      End If
      If (*win\obj\flags&#TUIF_FIXHEIGHT)
        *win\obj\maxsize\y = *win\obj\minsize\y
      Else
        *win\obj\maxsize\y = 32767
      End If

      *win\screenPos\x = *win\oswin\LeftEdge,*win\oswin\TopEdge

      minW.l = *win\obj\minsize\x + *win\oswin\BorderLeft + *win\oswin\BorderRight
      minH.l = *win\obj\minsize\y + *win\oswin\BorderTop  + *win\oswin\BorderBottom
      maxW.l = *win\obj\maxsize\x + *win\oswin\BorderLeft + *win\oswin\BorderRight
      maxH.l = *win\obj\maxsize\y + *win\oswin\BorderTop  + *win\oswin\BorderBottom

      WindowLimits_ *win\oswin, minW,minH,maxW,maxH
      *win\oswin\UserPort = *engine\winPort
      ModifyIDCMP_ *win\oswin,IDCMPFlags

      If *masterWindow><Null AND *masterWindow><-1
        *win\oswin\WLayer\Window = *masterWindow\oswin
      Else
        If *engine\appPort
          tag5.tag5\ti_Tag = #TAG_DONE,0
          *win\appWin = AddAppWindowA_(#APP_WINDOWDROP,*win,*win\oswin,*engine\appPort,tag5)
        End If
      End If
     ; If str_Read{&*win\obj\nameID}="stop"
     ; Stop
     ; End If
      ;*rp.RastPort = *win\oswin\RPort;
      *rp.RastPort = ntui_ObtainRastPort{*win}
      If *rp
        _ntui_Layout{*win,*rp,Null}
        _ntui_Draw{*win,*rp,*win\obj\bbox}
        ntui_ReleaseRastPort{*win}
      End If

    End If
  End If
  Function Return succ

End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_CreateWindow {*engine.tuiEngine,title.s,winID.:: /
;/ l,@instanceID.l,@WFlags.l,@notify.l,@help.s,@flags.l,@userID.l}             /
;/                                                                             /
;/ Description:                                                                /
;/ Create a tuiWindow. This function will lock the tui.library until you call ntui_EndWidow. The tuiWindow will work as a suitable parent object for all sub-tuiObjects.                                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *engine.tuiEngine : tuiEngine to which the tuiWindow belongs to                                             /
;/ - title.s      : Window Title                                                          /
;/ - winID.l      : winID                                                          /
;/ - instanceID.l : instanceID                                                    /
;/ - WFlags.l     : AmigaOS Window Flags (#WFLG_...)                                                         /
;/ - notify.l     : notify value if Close-Gadget is hit                                                         /
;/ - help.s       : short help text                                                           /
;/ - flags.l      : tuiFlags (#TUIF...)/
;/ - userID.l     : userID                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : tuiWindow of NULL if failed or window with winID/instanceID is already created                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
ntui_BeginWindow:
Function.tuiWindow ntui_BeginWindow{*tagList.TagItem}

  *win.tuiWindow = (.tuiWindow)_ntui_CreateObject{#TUICLASS_WINDOW,SizeOf.tuiWindow,#TUI_NOFLAGS}
  If *win

    *win\obj\bgTuiPen   = #TUIPEN_BACKGROUND

    *win\instanceID     = 0
    *win\pointerID      = #TUIPOINTER_DEFAULT
    *win\state          = #TUISTATE_CLOSED
    *win\focus          = Null

    *win\oswin          = Null
    *win\oswinFlags     = #WFLG_ACTIVATE|#WFLG_NEWLOOKMENUS|#WFLG_REPORTMOUSE|#WFLG_RMBTRAP
    *win\osrefreshing   = False
    *win\appWin         = Null
    *win\hotKeyX        = 0
    *win\hotKeyN        = 0
    *win\hotKeyA        = Null
    *win\screenPos\x    = -1,-1 ; default

    If *win\obj\engine\windowSmartRefresh
      *win\oswinFlags   | #WFLG_SMART_REFRESH
    Else
      *win\oswinFlags   | #WFLG_SIMPLE_REFRESH
    End If

    *win\backdrop    = False               ; window properties
    *win\closeable   = True
    *win\sizeable    = True
    *win\dragable    = True
    *win\borderless  = False

    *win\oswinFlags|#WFLG_CLOSEGADGET : If *win\closeable =False Then *win\oswinFlags - #WFLG_CLOSEGADGET
    *win\oswinFlags|#WFLG_DRAGBAR     : If *win\dragable  =False Then *win\oswinFlags - #WFLG_DRAGBAR
    *win\oswinFlags|#WFLG_DEPTHGADGET : If *win\dragable  =False Then *win\oswinFlags - #WFLG_DEPTHGADGET
    *win\oswinFlags|#WFLG_BORDERLESS  : If *win\borderless=False Then *win\oswinFlags - #WFLG_BORDERLESS
    *win\oswinFlags|#WFLG_BACKDROP    : If *win\backdrop  =False Then *win\oswinFlags - #WFLG_BACKDROP
    *win\oswinFlags|#WFLG_SIZEGADGET  : If *win\sizeable  =False Then *win\oswinFlags - #WFLG_SIZEGADGET

    *win\obj\Draw             = *_ntui_DrawWindow
    *win\obj\Layout           = *_ntui_LayoutWindow
    *win\obj\DispatchEvent    = *_ntui_DispatchWindowEvent
    *win\obj\CalculateMinSize = *_ntui_CalculateWindowMinSize
    *win\obj\Deinit           = *_ntui_DeinitWindow
    *win\obj\SetAttr          = *_ntui_SetWindowAttr
    *win\obj\GetAttr          = *_ntui_GetWindowAttr

    !tuiInitNotifyHandler{*win\onWinDrop }
    !tuiInitNotifyHandler{*win\onClose   }
    !tuiInitNotifyHandler{*win\onActive  }
    !tuiInitNotifyHandler{*win\onInactive}
    !tuiInitNotifyHandler{*win\onTick    }
    !tuiInitNotifyHandler{*win\onHotKey  }

    InitSemaphore_ *win\lock

;    tuiGlobal\buildHelper\tuiWindow               = *win
    tuiGlobal\buildHelper\parent               = *win
    tuiGlobal\buildHelper\prev                 = Null
    If tuiGlobal\buildHelper\windowDepth=0
      tuiGlobal\buildHelper\rootWin            = *win
    End If
    tuiGlobal\buildHelper\windowDepth+1

    If *tagList Then ntui_SetAttrs{*win,*tagList}

  End If

  Function Return *win

End Function
!_MakeGlobalFuncPointer{ntui_BeginWindow,{Null}}

Function.tuiWindow ntuib_BeginWindow{title.s,nameID.s,@instanceID.l,@WFlags.l,@flags.l}

  DEFTYPE.tagL10 tagList : n.l = 0
  tagList\tag[n]\ti_Tag = #TUIWA_INSTANCEID      ,instanceID  : n=n+1
  If title      Then tagList\tag[n]\ti_Tag = #TUIWA_TITLE      ,&title   : n=n+1
  If nameID     Then tagList\tag[n]\ti_Tag = #TUIA_ID          ,&nameID  : n=n+1
;  If WFlags><-1 Then tagList\tag[n]\ti_Tag = #TUIWA_OSWINFLAGS ,WFlags   : n=n+1
  If flags><#TUI_NOFLAGS Then tagList\tag[n]\ti_Tag = #TUIA_SETFLAGS,flags : n=n+1
  tagList\tag[n]\ti_Tag = #TAG_DONE,0

  *win.tuiWindow = ntui_BeginWindow{tagList}

  Function Return *win

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_EndWindow {}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ End a window definition,                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : tuiWindow that was just terminated.                                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
ntui_EndWindow:
Function.tuiWindow ntui_EndWindow{}

  tuiGlobal\buildHelper\rootWin = Null
  tuiGlobal\buildHelper\windowDepth -1

  tuiGlobal\buildHelper\prev    = tuiGlobal\buildHelper\parent
  tuiGlobal\buildHelper\current = tuiGlobal\buildHelper\parent
  If tuiGlobal\buildHelper\parent
    tuiGlobal\buildHelper\parent = tuiGlobal\buildHelper\parent\parent
  Else
    tuiGlobal\buildHelper\parent = Null
  End If
  If tuiGlobal\buildHelper\current
    If tuiGlobal\buildHelper\current\classID><#TUICLASS_WINDOW
      error{"\\__THIS_FUNCTION: EndWindow does not match a BeginWindow!"}
    Else
      *win.tuiWindow = (.tuiWindow)tuiGlobal\buildHelper\current
      If *win\obj\child
        addflags.l = *win\obj\child\flags&#TUIF_FIXSIZE
        *win\obj\flags | addflags
      End If
    End If
  Else
    error{"\\__THIS_FUNCTION: EndWindow without BeginWindow!"}
  End If

  Function Return *win

End Function
!_MakeGlobalFuncPointer{ntui_EndWindow,{}}


Statement ntui_InitWindowClass{}

  classID.l = ntui_RegisterClass{"window",(.tuiFunc)*ntui_BeginWindow,(.tuiFunc)*ntui_EndWindow}

;  ntui_RegisterAttr{classID,"oswinflags"  ,#TUIWA_OSWINFLAGS    ,#TUIAT_INT    ,0,0}
  ntui_RegisterAttr{classID,"onwindrop"   ,#TUIWA_ONWINDROP     ,#TUIAT_STRING ,0,0}
  ntui_RegisterAttr{classID,"onwindropcb" ,#TUIWA_ONWINDROPCB   ,#TUIAT_PTR    ,0,0}
  ntui_RegisterAttr{classID,"onclose"     ,#TUIWA_ONCLOSE       ,#TUIAT_STRING ,0,0}
  ntui_RegisterAttr{classID,"onclosecb"   ,#TUIWA_ONCLOSECB     ,#TUIAT_PTR    ,0,0}
  ntui_RegisterAttr{classID,"onactive"    ,#TUIWA_ONACTIVE      ,#TUIAT_STRING ,0,0}
  ntui_RegisterAttr{classID,"onactivecb"  ,#TUIWA_ONACTIVECB    ,#TUIAT_PTR    ,0,0}
  ntui_RegisterAttr{classID,"oninactive"  ,#TUIWA_ONINACTIVE    ,#TUIAT_STRING ,0,0}
  ntui_RegisterAttr{classID,"oninactivecb",#TUIWA_ONINACTIVECB  ,#TUIAT_PTR    ,0,0}
  ntui_RegisterAttr{classID,"ontick"      ,#TUIWA_ONTICK        ,#TUIAT_STRING ,0,0}
  ntui_RegisterAttr{classID,"onhotkey"    ,#TUIWA_ONHOTKEY      ,#TUIAT_STRING ,0,0}
  ntui_RegisterAttr{classID,"onhotkeycb"  ,#TUIWA_ONHOTKEYCB    ,#TUIAT_PTR    ,0,0}
  ntui_RegisterAttr{classID,"ontickcb"    ,#TUIWA_ONTICKCB      ,#TUIAT_PTR    ,0,0}
  ntui_RegisterAttr{classID,"instanceid"  ,#TUIWA_INSTANCEID    ,#TUIAT_INT    ,0,0}
  ntui_RegisterAttr{classID,"title"       ,#TUIWA_TITLE         ,#TUIAT_STRING ,0,0}
  ntui_RegisterAttr{classID,"borderless"  ,#TUIWA_BORDERLESS    ,#TUIAT_BOOL   ,0,0}
  ntui_RegisterAttr{classID,"backdrop"    ,#TUIWA_BACKDROP      ,#TUIAT_BOOL   ,0,0}
  ntui_RegisterAttr{classID,"sizeable"    ,#TUIWA_SIZEABLE      ,#TUIAT_BOOL   ,0,0}
  ntui_RegisterAttr{classID,"closeable"   ,#TUIWA_CLOSEABLE     ,#TUIAT_BOOL   ,0,0}
  ntui_RegisterAttr{classID,"dragable"    ,#TUIWA_DRAGABLE      ,#TUIAT_BOOL   ,0,0}

End Statement


ntui_InitWindowClass{}





