; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "///"
; ExeFile         = "test"
; CreateIcon      = 0
; Residents       = "all.res,SDSTCP2.res,xpk.res,ttengine.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; Version         = 0.1.0
; NumberOfBuilds  = 92
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 32768
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 297
; CursorColumn    = 83
; LabelSearch     = "cre"
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 20
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 20
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: ntui_event.include                                                    /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 06/01/2009                                                            /
;/                                                                             /
;/ Author: <unknown>                                                           /
;/                                                                             /
;/ Requirements:  Amiblitz3                                                    /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Extend AB3 functionality.                                                   /
;/ * no description available *                                                /
;/                                                                             /
;/ Abstract:                                                                   /
;/ * no abstract available *                                                   /
;/                                                                             /
;/ User Constants:                                                             /
;/ #max_objects   = n                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////

Dim tuiRawKeyMap.l     (#TUIMAX_RAWKEYS)
Dim tuiMouseButtonMap.l(#TUIMAX_MOUSEBUTTONS)

SHARED tuiRawKeyMap()
SHARED tuiMouseButtonMap()

CNIF @#NTUIEV_USEPOOLED=0
  #NTUIEV_USEPOOLED = 0
CEND

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_FlushRawKey {}                                                 /
;/                                                                             /
;/ Description:                                                                /
;/                                                                             /
;/ Reset all rawkeys to be unpressed.                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_FlushRawKeys{}
For n.l=0 To #TUIMAX_RAWKEYS-1
  tuiRawKeyMap(n)=0
Next
For n.l=0 To #TUIMAX_MOUSEBUTTONS-1
  tuiMouseButtonMap(n)=0
Next
End Statement



#TUIEVA_NOTIFY        =  1 ; (string) notify string

#TUIEVA_VALUE         =  2 ; (int) event integer value
#TUIEVA_MOUSEBUTTON   =  2 ; (int) mouse button number (maps to value)
#TUIEVA_RAWKEY        =  2 ; (int) raw key code (maps to value)
#TUIEVA_VANILLAKEY    =  3 ; (int) vanilla key code (first character of vanilla key, use TUIEV_STRING for full key input)
#TUIEVA_QUALIFIER     =  4 ; (int) qualifiers like CTRL, SHIFT, ALT etc. (#TUIQUAL_...)

#TUIEVA_STRING        =  5 ; (string) event data string
#TUIEVA_MESSAGE       =  5 ; (string) arexx message (maps to string)

#TUIEVA_OBJECT        =  6 ; (int) event tuiObject
#TUIEVA_WINDOW        =  7 ; (int) event tuiWindow

#TUIEVA_WINXPOS       =  8 ; (int) x pixel position relative to window
#TUIEVA_WINYPOS       =  9 ; (int) y pixel position relative to window
#TUIEVA_SCREENXPOS    = 10 ; (int) x pixel position absolute on screen
#TUIEVA_SCREENYPOS    = 11 ; (int) y pixel position absolute on screen
#TUIEVA_OBJXPOS       = 12 ; (int) x pixel position relative to object bounding box
#TUIEVA_OBJYPOS       = 13 ; (int) y pixel position realtive to object bounding box
#TUIEVA_CXPOS         = 14 ; (int) x pixel position relative to object content box
#TUIEVA_CYPOS         = 15 ; (int) y pixel position relative to object content box

#TUIEVA_WIDTH         = 16 ; (int) width in pixels
#TUIEVA_HEIGHT        = 17 ; (int) height in pixels

#TUIEVA_WINDOWID      = 18 ; (string) id of object window
#TUIEVA_ID            = 19 ; (string) id of object
#TUIEVA_WININSTANCEID = 20 ; (int) instance id of object window

#TUIEVA_MOVER         = 21 ; (bool) event position is currently over tuiObject

#TUIQUAL_LSHIFT       = $0001                                    ; left shift key
#TUIQUAL_RSHIFT       = $0002                                    ; right shift key
#TUIQUAL_SHIFT        = #TUIQUAL_LSHIFT|#TUIQUAL_RSHIFT          ; any sift key
#TUIQUAL_LALT         = $0010                                    ; left alt key
#TUIQUAL_RALT         = $0020                                    ; right alt key
#TUIQUAL_ALT          = #TUIQUAL_LALT|#TUIQUAL_RALT              ; any alt key
#TUIQUAL_CTRL         = $0008                                    ; control key
#TUIQUAL_LCOM         = $0040                                    ; left command key (=left AMIGA key)
#TUIQUAL_RCOM         = $0080                                    ; right command key (=right AMIGA key)
#TUIQUAL_COM          = #TUIQUAL_LCOM|#TUIQUAL_RCOM              ; any command key
#TUIQUAL_RMB          = $2000                                    ; right mouse button
#TUIQUAL_LMB          = $4000                                    ; left mouse button
#TUIQUAL_MMB          = $1000                                    ; middle mouse button
#TUIQUAL_MB           = #TUIQUAL_LMB|#TUIQUAL_RMB|#TUIQUAL_MMB   ; any mouse button
#TUIQUAL_CAPSLOCK     = $0004                                    ; capslock key
#TUIQUAL_NUMPAD       = $0100                                    ; numpad key
#TUIQUAL_REPEAT       = $0200                                    ; is a key repeat event
#TUIQUAL_DOUBLECLICK  = $10000                                   ; is a double click event
#TUIQUAL_TRIPLECLICK  = $20000                                   ; is a tripple click event

#TUIEVF_QUEUED          = $0001
#TUIEVF_VALID           = $0002
#TUIEVF_NOTIFY_MALLOC   = $0004
#TUIEVF_NOTIFY_POOLED   = $0008
#TUIEVF_STRING_MALLOC   = $0010
#TUIEVF_STRING_POOLED   = $0020
#TUIEVF_MALLOC          = $0040
#TUIEVF_POOLED          = $0080



Function.w ntui_GetEventAttr{*ev.tuiEvent,ti_Tag.l,*ti_Data_.l}

  If *ev=Null Then Function Return False
  done.w = True
  *ti_Data.longP = (.longP)*ti_Data_

  Select ti_Tag
    Case #TUIEVA_NOTIFY    : *ti_Data\l = str_GetPtr{*ev\notifyID}
    Case #TUIEVA_VALUE     : *ti_Data\l = *ev\value
    Case #TUIEVA_STRING    : *ti_Data\l = str_GetPtr{*ev\string}
    Case #TUIEVA_VANILLAKEY
        If *ev\string
          *ti_Data\l = (Peek.b(&*ev\string\str) & $FF)
        Else
          *ti_Data\l = 0
        End If
    Case #TUIEVA_OBJECT    : *ti_Data\l = *ev\obj
    Case #TUIEVA_QUALIFIER : *ti_Data\l = *ev\qualifier_
    Case #TUIEVA_WINDOW    : *ti_Data\l = ntui_GetWindow{*ev\obj}
    Case #TUIEVA_WINDOWID  : *win.tuiWindow = ntui_GetWindow{*ev\obj} : If *win Then *ti_Data\l = str_GetPtr{*win\obj\nameID} : Else done=False
    Case #TUIEVA_WININSTANCEID : *win.tuiWindow = ntui_GetWindow{*ev\obj} : If *win Then *ti_Data\l = *win\instanceID : Else done = False
    Case #TUIEVA_ID        : *ti_Data\l = str_GetPtr{*ev\obj\nameID}
    Case #TUIEVA_MOVER
      *ti_Data\l = 0
      If ((*ev\pos\y>=*ev\obj\bbox\top) AND (*ev\pos\y<*ev\obj\bbox\bottom))
        If ((*ev\pos\x>=*ev\obj\bbox\left) AND (*ev\pos\x<*ev\obj\bbox\right))
          *ti_Data\l = 1
        End If
      End If

    Case #TUIEVA_WINXPOS    : *ti_Data\l = *ev\pos\x
    Case #TUIEVA_WINYPOS    : *ti_Data\l = *ev\pos\y
    Case #TUIEVA_SCREENXPOS : *ti_Data\l = *ev\pos\x : *win.tuiWindow = ntui_GetWindow{*ev\obj} : If *win Then If *win\oswin Then *ti_Data\l + *win\oswin\LeftEdge
    Case #TUIEVA_SCREENYPOS : *ti_Data\l = *ev\pos\y : *win.tuiWindow = ntui_GetWindow{*ev\obj} : If *win Then If *win\oswin Then *ti_Data\l + *win\oswin\TopEdge
    Case #TUIEVA_OBJXPOS    : *ti_Data\l = *ev\pos\x - *ev\obj\bbox\left
    Case #TUIEVA_OBJYPOS    : *ti_Data\l = *ev\pos\y - *ev\obj\bbox\top
    Case #TUIEVA_CXPOS      : *ti_Data\l = *ev\pos\x - *ev\obj\cbox\left
    Case #TUIEVA_CYPOS      : *ti_Data\l = *ev\pos\y - *ev\obj\cbox\top
    Case #TUIEVA_WIDTH      : *ti_Data\l = *ev\size\x
    Case #TUIEVA_HEIGHT     : *ti_Data\l = *ev\size\y
    Default
      done = False
  End Select

  Function Return done

End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_GetSigFlag {*engine.tuiEngine}                   /
;/                                                                             /
;/ Description:                                                                /
;/ Get the signal flag mask of the event message port(s) for use with Wait_().      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *engine.tuiEngine : tuiEngine from which to retrieve the signal flags                                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l             : signal flag mask                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ntui_GetSigFlag{*engine.tuiEngine}
  !_ASSERT{*engine}
  sigFlag.l=*engine\outQ\sigFlag
  If *engine\winPort Then sigFlag | (1 LSL *engine\winPort\mp_SigBit)
  If *engine\rxPort  Then sigFlag | (1 LSL *engine\rxPort\mp_SigBit )
  If *engine\appPort Then sigFlag | (1 LSL *engine\appPort\mp_SigBit)
  sigFlag = sigFlag | *engine\inQ\sigFlag
  Function Return sigFlag
End Function


Function.l _ntui_UnqueueEvent{*eventQ.tuiEventQ}

  !_ASSERT{*eventQ}

  ObtainSemaphore_ *eventQ\lock
  If *eventQ\head
    *ev.tuiEvent = *eventQ\head
    *eventQ\head    = *eventQ\head\next_
    If (*eventQ\head=Null)
      *eventQ\tail = Null
    End If
    ReleaseSemaphore_ *eventQ\lock
    *ev\evFlags = (*ev\evFlags | #TUIEVF_QUEUED) - #TUIEVF_QUEUED
    Function Return *ev
  End If
  ReleaseSemaphore_ *eventQ\lock
  Function Return Null

End Function

RunErrsOff ; debugger must be switched off for file listener
Statement _ntui_QueueEvent{*eventQ.tuiEventQ,*ev.tuiEvent}

  !_ASSERT{*eventQ}
  !_ASSERT{*ev}
  *obj.tuiObject = *ev\obj
  !_ASSERT{*obj}
  *engine.tuiEngine = *obj\engine
  !_ASSERT{*engine}

  If (*ev=$DEADBEEF) Then error{"Event is DEADBEEF!!!"} :Statement Return
  If (*ev\evFlags&#TUIEVF_QUEUED) Then error{"Tried to queue event twice!"} : Statement Return

  *ev\evFlags | #TUIEVF_QUEUED

  ObtainSemaphore_ *eventQ\lock
  If *eventQ\tail
    *eventQ\tail\next_ = *ev
  Else
    *eventQ\head = *ev
  End If
  *eventQ\tail = *ev
  ReleaseSemaphore_ *eventQ\lock

  Signal_ *eventQ\sigTask,*eventQ\sigFlag

End Statement


Function.tuiEvent _ntui_CreateEvent{*obj.tuiObject,evID.l}

  !_ASSERT{*obj}
  *engine.tuiEngine = *obj\engine
  !_ASSERT{*engine}

  CNIF #NTUIEV_USEPOOLED
    *ev.tuiEvent = AllocPooled_(*engine\eventPool,SizeOf.tuiEvent)
  CELSE
    *ev.tuiEvent = AllocMem_(SizeOf.tuiEvent,#MEMF_ANY)
  CEND
  If *ev
    *ev\next_      = Null
    *ev\obj        = *obj
    *ev\notifyID   = Null
    *ev\value      = 0
    *ev\string     = Null
    *ev\pos\x      = 0,0
    *ev\size\x     = 0,0
    *ev\qualifier_ = 0
    *ev\evID       = evID
    *ev\seconds    = 0
    *ev\micros     = 0
    CNIF #NTUIEV_USEPOOLED
      *ev\evFlags    = #TUIEVF_VALID|#TUIEVF_POOLED
    CELSE
      *ev\evFlags    = #TUIEVF_VALID|#TUIEVF_MALLOC
    CEND
  End If

  Function Return *ev

End Function
LastRunErrsMode

Statement _ntui_DestroyEvent{*ev.tuiEvent}

  !_ASSERT{*ev}
  *obj.tuiObject = *ev\obj
  !_ASSERT{*obj}
  *engine.tuiEngine = *obj\engine
  !_ASSERT{*engine}

  If (*ev=$DEADBEEF) Then error{"Event is DEADBEEF!!!"} :Statement Return

  If ((*ev\evFlags&#TUIEVF_VALID ) = 0) Then error{"Tried to free an invalid event!"}:Statement Return
  If ((*ev\evFlags&#TUIEVF_QUEUED)    ) Then error{"Tired to free an queued event!"}:Statement Return

  If *ev\string
    If (Peek.l(*ev\string)=$DEADBEEF) Then error{"Event string is DEADBEEF!!!"} :Statement Return
    If (Peek.l(*ev\string)=$BEEFDEAD) Then error{"Event string is BEEFDEAD!!!"} :Statement Return
  End If

  If (*ev\evFlags&#TUIEVF_STRING_POOLED) Then If (*ev\string  ) Then str_Free{&*ev\string}
  If (*ev\evFlags&#TUIEVF_NOTIFY_POOLED) Then If (*ev\notifyID) Then str_Free{&*ev\notifyID}
  If (*ev\evFlags&#TUIEVF_STRING_MALLOC) Then If (*ev\string  ) Then str_FreeAsync{&*ev\string}
  If (*ev\evFlags&#TUIEVF_NOTIFY_MALLOC) Then If (*ev\notifyID) Then str_FreeAsync{&*ev\notifyID}

  *ev\notifyID = Null ; the notify pointer is only stolen!
  If (*ev\evFlags&#TUIEVF_POOLED) Then *ev\evFlags = 0 : FreePooled_ *engine\eventPool,*ev,SizeOf.tuiEvent : Statement Return
  If (*ev\evFlags&#TUIEVF_MALLOC) Then *ev\evFlags = 0 : FreeMem_ *ev,SizeOf.tuiEvent : Statement Return

  *ev\evFlags = (*ev\evFlags | #TUIEVF_VALID) - #TUIEVF_VALID

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_CauseEvent {notify.l,*win.tuiWindow,@*tuiOb:: /
;/ ject.tuiObject,@x.l,@y.l,@width.l,@height.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Cause an event to happen manually. The event will be passed to the tuiEngines input queue.                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - notify.l               : notify value                                                         /
;/ - *win.tuiWindow   : tuiWindow of the event                                             /
;/ - *obj.tuiObject   : tuiObject of the event (if any)                                             /
;/ - x/y.l                  : x/y position of event                                                    /
;/ - width.l                : ???                                                          /
;/ - height.l               : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l               : pointer to created tuiEvent struture                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_PostNotify{*obj.tuiObject,notifyID.s,@value.l,@string.s,@x.l,@y.l,@width.l,@height.l}
  !_ASSERT{*obj}
  *engine.tuiEngine = *obj\engine
  !_ASSERT{*engine}
  *ev.tuiEvent = _ntui_CreateEvent{*obj,#TUIEV_USER}
  If *ev
    If (notifyID) Then str_Write{&*ev\notifyID,notifyID} : *ev\evFlags | #TUIEVF_NOTIFY_POOLED
    If (string)   Then str_Write{&*ev\string,string}     : *ev\evFlags | #TUIEVF_STRING_POOLED
    *ev\value  = value
    *ev\pos\x  = x,y
    *ev\size\x = width,height
    _ntui_QueueEvent{*engine\outQ,*ev}
  End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = ntui_CauseEvent {notify.l,*win.tuiWindow,@*tuiOb:: /
;/ ject.tuiObject,@x.l,@y.l,@width.l,@height.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Cause an event to happen manually. The event will be passed to the tuiEngines input queue.                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - notify.l               : notify value                                                         /
;/ - *win.tuiWindow   : tuiWindow of the event                                             /
;/ - *obj.tuiObject   : tuiObject of the event (if any)                                             /
;/ - x/y.l                  : x/y position of event                                                    /
;/ - width.l                : ???                                                          /
;/ - height.l               : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l               : pointer to created tuiEvent struture                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_PostEvent{*obj.tuiObject,evID.l,@value.l,@string.s,@x.l,@y.l,@width.l,@height.l}
  !_ASSERT{*obj}
  *engine.tuiEngine = *obj\engine
  !_ASSERT{*engine}
  *ev.tuiEvent = _ntui_CreateEvent{*obj,evID}
  If *ev
    If (string) Then str_Write{&*ev\string,string} : *ev\evFlags | #TUIEVF_STRING_POOLED
    *ev\value  = value
    *ev\pos\x  = x,y
    *ev\size\x = width,height
    _ntui_QueueEvent{*engine\inQ,*ev}
  End If
End Statement




;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ntui_FlushEvents {*engine.tuiEngine,@*win.tuiWindow}       /
;/                                                                             /
;/ Description:                                                                /
;/ Flush events that are waiting in the tasks event queue.                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *engine.tuiEngine    : tuiEngine to flush                                             /
;/ - *win.tuiWindow    : optional window, otherwise flush all window events                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ntui_FlushEvents_deprecated{*win.tuiWindow}
  !_ASSERT{*win}
  *engine.tuiEngine = *win\obj\engine
  !_ASSERT{*engine}

  *ev.tuiEvent = *engine\outQ\head
  *tuiPrev.tuiEvent  = Null
  *tuiNext.tuiEvent  = Null
  *engine\outQ\head = Null
  *engine\outQ\tail = Null

  While *ev
    *tuiNext.tuiEvent = *ev\next_
    If ntui_GetWindow{*ev\obj} = *win
      _ntui_DestroyEvent{*ev}
      If *tuiPrev Then *tuiPrev\next_ = *tuiNext
    Else
      If *engine\outQ\head=Null Then *engine\outQ\head = *ev
      *engine\outQ\tail = *ev
      *tuiPrev = *ev
    End If
    *ev = *tuiNext
  Wend

  *ev.tuiEvent = *engine\inQ\head
  *tuiPrev.tuiEvent  = Null
  *tuiNext.tuiEvent  = Null
  *engine\inQ\head = Null
  *engine\inQ\tail = Null

  While *ev
    *tuiNext.tuiEvent = *ev\next_
    If ntui_GetWindow{*ev\obj} = *win
      _ntui_DestroyEvent{*ev}
      If *tuiPrev Then *tuiPrev\next_ = *tuiNext
    Else
      If *engine\inQ\head=Null Then *engine\inQ\head = *ev
      *engine\inQ\tail = *ev
      *tuiPrev = *ev
    End If
    *ev = *tuiNext
  Wend

  ntui_FlushRawKeys{}
End Statement


Statement ntui_FlushObjEvents{*obj.tuiObject}
  !_ASSERT{*obj}
  *engine.tuiEngine = *obj\engine
  !_ASSERT{*engine}

  ObtainSemaphore_ *engine\outQ\lock
  *ev.tuiEvent = *engine\outQ\head
  *tuiPrev.tuiEvent  = Null
  *tuiNext.tuiEvent  = Null
  *engine\outQ\head = Null
  *engine\outQ\tail = Null

  While (*ev)
    *tuiNext.tuiEvent = *ev\next_
    If (*ev\obj = *obj)
      _ntui_DestroyEvent{*ev}
      If *tuiPrev Then *tuiPrev\next_ = *tuiNext
    Else
      If *engine\outQ\head=Null Then *engine\outQ\head = *ev
      *engine\outQ\tail = *ev
      *tuiPrev = *ev
    End If
    *ev = *tuiNext
  Wend
  ReleaseSemaphore_ *engine\outQ\lock

  ObtainSemaphore_ *engine\inQ\lock
  *ev.tuiEvent = *engine\inQ\head
  *tuiPrev.tuiEvent  = Null
  *tuiNext.tuiEvent  = Null
  *engine\inQ\head = Null
  *engine\inQ\tail = Null

  While (*ev)
    *tuiNext.tuiEvent = *ev\next_
    If (*ev\obj = *obj)
      _ntui_DestroyEvent{*ev}
      If *tuiPrev Then *tuiPrev\next_ = *tuiNext
    Else
      If *engine\inQ\head=Null Then *engine\inQ\head = *ev
      *engine\inQ\tail = *ev
      *tuiPrev = *ev
    End If
    *ev = *tuiNext
  Wend
  ReleaseSemaphore_ *engine\inQ\lock

End Statement

_ntui_DefaultNotifyCallback:
Function.w _ntui_DefaultNotifyCallback{*notifyID.str,*ev.tuiEvent}

  If *notifyID ; if we have a notify value...
    ;If *ev=Null Then *ev=_ntui_CreateEvent{*obj,#TUIEV_UNDEFINED}
    If *ev ; and for safety, the event must be valid
      ;error{"Notify: "+str_Read{&*notifyID}}
      *ev\notifyID = *notifyID ; set the notifyID
      _ntui_QueueEvent{*ev\obj\engine\outQ,*ev} ; and queue it to the out queue
      ;Function Return True ; tell we have used this event up
    End If
  End If

  Function Return False

End Function


Function.w _ntui_DefaultNotifyCallback_dep{*obj.tuiObject,*ev.tuiEvent,*notifyID.str}
  If *notifyID
    If *ev=Null
      *ev = _ntui_CreateEvent{*obj,#TUIEV_UNDEFINED}
    End If
    If *ev
      str_Dup{&*ev\notifyID,*notifyID}
      *ev\obj = *obj
      _ntui_QueueEvent{*obj\engine\inQ,*ev}
      Function Return True
    End If
  End If
  Function Return False
End Function


