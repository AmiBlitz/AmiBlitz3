; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = ""
; ExeFile         = ""
; CreateIcon      = 1
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 0
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 74
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 12
; CursorColumn    = 30
; LabelSearch     = "encod"
; LabelRemark     = 0
; LabelAll        = 1
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 20
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 20
; Max ChunkyBuffer= 2
; /XTRA
; /**
;  * ISO9796-1 Message Encoding/Decoding with RSA-Encryption.
;  *
;  * <p>This implementation is fully ISO9796-1 compatible.

optimize 4
;XINCLUDE "PE/PE_Tools.include.bb2"
#log_Width = 100
XINCLUDE "PE/logging.include.ab3"
XINCLUDE "PE/BigInt.include.ab3"
XINCLUDE "PE/RIPEMD160.include.ab3"
;XINCLUDE "PE/RSA.include.ab3"
DEFTYPE.w


; --
; -- copies a String to a dimed Array
;
; ConvertStringtoArray{ME(i),t,MEStr}
Macro ConvertStringtoArray
  For i.w = 0 To `2 - 1
    `1 = Asc( Mid$(`3,i+1,1) )
  Next i
End Macro

; copies an array to a string
;
; ConvertStringtoArray{_MR(i),t,MRStr}
Macro ConvertArraytoString
  `3 = ""
  For i.w = 0 To `2 - 1
    `3 + Chr$(`1)
  Next i
End Macro

Function.w GetBitLength{a$}
  If Len(a$)<1 Then Function Return 0

  bits.w = Len(a$) * 8 - 8
  byte.w = Asc(Left$(a$,1))
  For i.b = 7 To 0 Step -1
;    !cout{Bin$(byte)+" AND "+ Bin$(1 LSL i)+" = "+Bin$(byte AND (1 LSL i))}
    If (byte AND (1 LSL i)) = (1 LSL i)
;      !cout{"bit gesetzt."}
      add_bits.b = (i+1) : Pop For : Goto exit_for
    EndIf
  Next i
  exit_for:
  Function Return bits+add_bits
End Function


Dim SHADOW.w(257)
SHARED SHADOW()
DEFTYPE.w i : i = 0
Restore shadow
Repeat
  Read permut.w
  SHADOW(i) = permut
  i + 1
Until permut = -1

shadow:
Data.w  $ee,  $e3,  $e5,  $e8, $e9,  $e4,  $e2,  $ef, $e0,  $ed,  $eb,  $e6, $e7,  $ea,  $ec,  $e1
Data.w  $3e,  $33,  $35,  $38, $39,  $34,  $32,  $3f, $30,  $3d,  $3b,  $36, $37,  $3a,  $3c,  $31
Data.w  $5e,  $53,  $55,  $58, $59,  $54,  $52,  $5f, $50,  $5d,  $5b,  $56, $57,  $5a,  $5c,  $51
Data.w  $8e,  $83,  $85,  $88, $89,  $84,  $82,  $8f, $80,  $8d,  $8b,  $86, $87,  $8a,  $8c,  $81
Data.w  $9e,  $93,  $95,  $98, $99,  $94,  $92,  $9f, $90,  $9d,  $9b,  $96, $97,  $9a,  $9c,  $91
Data.w  $4e,  $43,  $45,  $48, $49,  $44,  $42,  $4f, $40,  $4d,  $4b,  $46, $47,  $4a,  $4c,  $41
Data.w  $2e,  $23,  $25,  $28, $29,  $24,  $22,  $2f, $20,  $2d,  $2b,  $26, $27,  $2a,  $2c,  $21
Data.w  $fe,  $f3,  $f5,  $f8, $f9,  $f4,  $f2,  $ff, $f0,  $fd,  $fb,  $f6, $f7,  $fa,  $fc,  $f1
Data.w  $0e,  $03,  $05,  $08, $09,  $04,  $02,  $0f, $00,  $0d,  $0b,  $06, $07,  $0a,  $0c,  $01
Data.w  $de,  $d3,  $d5,  $d8, $d9,  $d4,  $d2,  $df, $d0,  $dd,  $db,  $d6, $d7,  $da,  $dc,  $d1
Data.w  $be,  $b3,  $b5,  $b8, $b9,  $b4,  $b2,  $bf, $b0,  $bd,  $bb,  $b6, $b7,  $ba,  $bc,  $b1
Data.w  $6e,  $63,  $65,  $68, $69,  $64,  $62,  $6f, $60,  $6d,  $6b,  $66, $67,  $6a,  $6c,  $61
Data.w  $7e,  $73,  $75,  $78, $79,  $74,  $72,  $7f, $70,  $7d,  $7b,  $76, $77,  $7a,  $7c,  $71
Data.w  $ae,  $a3,  $a5,  $a8, $a9,  $a4,  $a2,  $af, $a0,  $ad,  $ab,  $a6, $a7,  $aa,  $ac,  $a1
Data.w  $ce,  $c3,  $c5,  $c8, $c9,  $c4,  $c2,  $cf, $c0,  $cd,  $cb,  $c6, $c7,  $ca,  $cc,  $c1
Data.w  $1e,  $13,  $15,  $18, $19,  $14,  $12,  $1f, $10,  $1d,  $1b,  $16, $17,  $1a,  $1c,  $11
Data.w -1

; -- The inverse Pi Function according To ISO9796-1:1991.
; -- See also the Shadow Function S.
Dim PI_INV.w(16)
SHARED PI_INV()
PI_INV(0) =  $08, $0f, $06, $01, $05, $02, $0b, $0c, $03, $04, $0d, $0a, $0e, $09, $00, $07





Dim Perm1.w(16)
SHARED Perm1()
Perm1(0) = $08, $0f, $06, $01, $05, $02, $0b, $0c, $03, $04, $0d, $0a, $0e, $09, $00, $07

Dim Perm.b(16)
SHARED Perm()
Perm(0)   = $0E, $03, $05, $08, $09, $04, $02, $0F, $00, $0D, $0B, $06, $07, $0A, $0C, $01

Function.b S{x.w}
  Function Return ( (Perm((x LSR 4) & $0F) LSL 4) OR Perm(x & $0F) )
End Function


Function.s ISO9796_encodeSign{bitStringMessage$,*key_privateExponent.bigint,*key_modulus.bigint }

  DEFTYPE.bigint bModulus
  CopyType *key_modulus,bModulus

  log_Print{"Eingangshash: " + Hexstream{bitStringMessage$}}

  ;-- Erstellen eines Bytearrays "modulus" aus dem Modulus-key
  temp_mod$ = bigint_Big2Str{bModulus}
  Dim modulus.b(Len(temp_mod$))
  !ConvertStringtoArray{modulus(i),Len(temp_mod$),temp_mod$}
  log_Print{"modulus caught..."}

  ;-- prepareForSig
  ; byte[] mp=new byte[buffer.length]
  ; System.arraycopy{src    , src_position , dst, dst_position , Length}
  ; System.arraycopy(buffer , 0            , mp , 0            , buffer.length);
  Dim mp.b(Len(bitStringMessage$)) : mp_length.w = Len(bitStringMessage$)
  !ConvertStringtoArray{mp(i),mp_length,bitStringMessage$}

  ;log_Print{"Signaturmodulus:"}
  ;log_Print{Hexstream{temp_mod$}}
  DEFTYPE.w k : k = GetBitLength{temp_mod$}
  DEFTYPE.w z : z = mp_length
  log_Print{"k is "+Str$(k)+", z is "+Str$(z)}
  DEFTYPE.w r : r = 1

  If  NOT ((z LSL 4) <= (k+3))
    log_Print{"16*z ist greater than k"}
    Function Return ""
  EndIf


  ; extension (concatenate MP multiple times)
  log_Print{"extension of MP..."}
  DEFTYPE.w t : t = (k-1) LSR 4
  If ((k-1) & $0F) <> 0 Then t + 1
  log_Print{"t is "+Str$(t)}

  ;-- byte[] me = getMEfromMP(mp, t)
  Dim me.b(t) : me_length.w = t
  DEFTYPE.w sum : sum = 0
  DEFTYPE.w diff: diff = 0
  While sum < t
    If (sum + mp_length) <= t
      ; System.arraycopy{src , src_position , dst, dst_position            , Length}
      ; System.arraycopy(mp  , 0            , ret, ret.length-sum-mp.length, mp.length)
      For i = 0 To mp_length - 1
        me(me_length-sum-mp_length) = mp(i)
      Next i
      sum + mp_length
    Else
      diff = t - sum
      ; System.arraycopy{src , src_position  , dst, dst_position , Length}
      ; System.arraycopy(mp  , mp.length-diff, ret, 0            , diff)
      For i = diff To 0 Step -1
        me(diff-i) = mp(mp_length-i)
      Next i
      sum + diff
    EndIf
  Wend

  ; creating redundancy by interleaving the extended message bytes with redundancy bytes
  log_Print{"creating redundancy..."}
  ;-- byte[] mr = getMRfromME(me,t,z,r)
  Dim _mr.b( 2*t ) : mr_length.w = 2*t
  For i=0 To t-1
    _mr( 2*t-1 - (2*i) ) = me(t-1-i)
    _mr( 2*t-1 - (2*i+1))= S{ me(t-1-i) }
  Next
  _mr( (t-z)LSL 1) = Xor( _mr( (t-z)LSL 1),r )

  ; get intermediate integer
  log_Print{"get intermediate integer..."}
  ;-- byte[] ir = getIRfromMR(mr, k)
  DEFTYPE.w _len : _len = mr_length
  Dim ir.b(_len)
  ;System.arraycopy(mr,0,ir,0,len)
  For i =0 To _len
    ir(i) = _mr(i)
  Next
  ir(0) = ir(0) &  (1 LSL (7-((_len LSL 3)-k)))-1
  ir(0) = ir(0) OR (1 LSL (7-((_len LSL 3)-k)))
  ir(_len-1) = ((ir(_len-1) & $0F)LSL 4) OR $06

  ; calculate signature
  log_Print{"calculating signature..."}
  ; byte[] rr=ir
  DEFTYPE.bigint rr
  DEFTYPE.bigint irAsNumber
  !ConvertArraytoString{ir(i),_len,irString$}
  bigint_Str2Big{irString$,irAsNumber}

  ; -- Convert 'ir' To the BigInteger representation of 'rr'.
  CopyType irAsNumber,rr

  DEFTYPE.bigint bPrivExponent
  CopyType *key_privateExponent,bPrivExponent

  ; -- Calc Signature
  DEFTYPE.bigint bIS
  bigint_ExpMod{rr,bPrivExponent,bModulus,bIS}

  ; byte[] sig=getSigFromIS(is, modulus)
  DEFTYPE.bigint bSig,bIS2
  bigint_Sub{bModulus,bIS,bIS2}
  If bigint_IsGreater{bIS,bIS2}
    CopyType bIS2,bSig
  Else
    CopyType bIS,bSig
  EndIf
  log_Print{"done."}
  bsigstring$ = bigint_Big2Str{bSig}
  log_Print{"signature:"}
  log_Print{Hexstream{bsigstring$}}
  sigma$ = bigint_Big2Str{bSig}
  Function Return sigma$
End Function


;
; ISO9796-1 RSA-Signature Decoding with Message Recovery.
;
; <p> This is the inverse operation of
; encodeMessage(ISO97696Part1RSACodec, boolean)
;
; @param bitStringSignature the Signature as ISO9796Part1BitString with a
; bitLength of k-1 bits. Where k is the bitLength of the public key
; modulus.
; @Return the recoverd message as ISO9796Part1Message OR Null If the
; signature is rejected.
; throws NullPointerException If bitStringSignature is Null.
; @throws IllegalStateException If this Codec Object isn't initialized
; For decoding.
;
Function.s ISO9796_verifySign{bitStringSignature$,*key_publicExponent.bigint,*key_modulus.bigint}
  ; -- Debugging info ...
  log_Print{"Entering decodeMessage with <bitStringMessage="+Hexstream{bitStringSignature$}+">"}

  ; --
  ; --
  ; -- Pre-Conditions check
  ; --
  ; --
  If bitStringSignature$ = ""
    log_Print{"Parameter <bitStringSignature> is null."}
    Function Return ""
  EndIf

  ;
  ; --
  ; --
  ; -- RSA Verification Function (A.5) AND Signature opening(6.1)
  ; --
  ; --

  ; -- Get 'modulus'
  DEFTYPE.bigint modulus
  CopyType *key_modulus,modulus
  log_Print{"decoded <Modulus="+bigint_AsString{modulus}+">"}

  ; -- Get 'sigma'.
  Dim sigma.w( Len(bitStringSignature$) )
  !ConvertStringtoArray{sigma(i),Len(bitStringSignature$),bitStringSignature$}

  ; -- Debug 'sigma'.
  log_Print{"Recovered result of sigma()"}

  ; -- Convert the signature 'sigma' To the BigInteger representation of the
  ; -- signature 'sigma' - denoted as 'sigmaAsNumber'.
  DEFTYPE.bigint sigmaAsNumber
  bigint_Str2Big{bitStringSignature$,sigmaAsNumber}

  ; -- Debug
  log_Print{"Have created from sigma() <sigmaAsNumber="+bigint_AsString{sigmaAsNumber}+">"}

  ; If (sigmaAsNumber >= n/2)
  DEFTYPE.bigint n_halbe
  bigint_Div{modulus,BN_2,n_halbe}
  If bigint_IsGreater{sigmaAsNumber, n_halbe}
    log_Print{"Return from decodeSignature(...)."}
    log_Print{"Reject Signature! \\nSignature is not a positive integer less than modulus/2."}
    ; -- reject signature.
    Function Return ""
  EndIf

  ; -- Setup RSA public exponent.
  DEFTYPE.bigint publicExponent
  CopyType *key_publicExponent, publicExponent

  ; -- Debug info
  log_Print{"Have set <publicExponent = "+bigint_AsString{publicExponent}+">"}

  ; -- Do RSA encryption operation, according To Rivest, Shamir AND Adelmann.
  ; -- Here it will be Used To _decrypt_ the the signature 'sigma' with
  ; -- help of the signers public key. The result will be the resulting
  ; -- integer 'is'

  ;final BigInteger is = (sigmaAsNumber.modPow(publicExponent, modulus));
  DEFTYPE.bigint is
  bigint_ExpMod{sigmaAsNumber,publicExponent,modulus,is}

  ; -- Debug info
  log_Print{"Have decrypted <is="+bigint_AsString{is}+">"}

  ; --
  ; -- In the following code section, we do recover the intermediate
  ; -- integer ir, first as a number an Then we will it convert To a
  ; -- byte array.
  ; --

  ; -- The recovered intermediate integer 'ir'
  DEFTYPE.bigint irAsNumber

  ; -- public exponent is Even
  ; If (publicExponent.mod(TWO).equals(ZERO)) {
  DEFTYPE.bigint tempBN
  bigint_Mod{publicExponent,BN_2,tempBN}
  If bigint_IsNull{tempBN}
    ; -- Debug info
    log_Print{"Public exponent is even."}
    ; ...
;    //If (is % 16 == 6)
;    If (is.mod(SIXTEEN).equals(SIX)) {
;        If (Log.isLoggable(Level.FINEST)) {
;            Log.finest("is mod 16 is congruent to 6.");
;        }
;
;        //ir = is
;        irAsNumber = is;
;
;        If (Log.isLoggable(Level.FINEST)) {
;            Log.finest("Have set <irAsNumber="+irAsNumber+
;            "> = <is="+is+">.");
;        }
;
;    //If ((modulus - is) % 16 == 6)
;    } Else If (modulus.subtract(is).mod(SIXTEEN).equals(SIX)) {
;        If (Log.isLoggable(Level.FINEST)) {
;            Log.finest("(modulus - is) mod 16 is congruent to 6.");
;        }
;
;        //ir = modulus - is
;        irAsNumber = modulus.subtract(is);
;
;        If (Log.isLoggable(Level.FINEST)) {
;            Log.finest("Have calculated <irAsNumber="+irAsNumber+
;            "> = <modulus="+modulus+"> - <is="+is+">.");
;        }
;
;
;    //If (is % 8 == 3)
;    } Else If (is.mod(EIGHT).equals(THREE)) {
;        If (Log.isLoggable(Level.FINEST)) {
;            Log.finest("is mod 8 is congruent to 3.");
;        }
;
;        //ir = 2is
;        irAsNumber = is.multiply(TWO);
;
;        If (Log.isLoggable(Level.FINEST)) {
;            Log.finest("Have calculated <irAsNumber="+irAsNumber+
;            "> = 2 * <is="+is+">.");
;        }
;
;    //If ((modulus - is) % 8 == 3)
;    } Else If (modulus.subtract(is).mod(EIGHT).equals(THREE)) {
;        If (Log.isLoggable(Level.FINEST)) {
;            Log.finest("(modulus - is) mod 8 is congruent to 3.");
;        }
;
;        //ir = 2(modulus - is)
;        irAsNumber = modulus.subtract(is).multiply(TWO);
;
;        If (Log.isLoggable(Level.FINEST)) {
;            Log.finest("Have calculated <irAsNumber="+irAsNumber+
;            "> = 2 * (<modulus="+modulus+"> - <is="+is+">).");
;        }
;
;    //is OR modulus-is is NOT congruent To 3 MOD 8
;    } Else {
;        Log.finer(
;        "Return from decodeSignature(...). " +
;        "Reject Signature! " +
;        "is or (modulus - is) is not congruent to 3 mod 8 or to " +
;        "6 mod 16.");
;
;        //reject signature.
;        Return Null;
;    }
;
  ; -- public exponent is odd
  Else
    ; --Debug info
    log_Print{"Public exponent is odd."}

    ; If (is % 16 == 6)
    bigint_Mod{is,BN_16,tempBN}
    If bigint_IsEqual{tempBN,BN_6}
      ; Debug info
      log_Print{"<is> mod 16 is congruent to 6."}

      ; -- ir = is
      CopyType is,irAsNumber

      ; Debug info
      log_Print{"Have set <irAsNumber=> = <is=>."}

      ; -- If ((modulus - is) % 16 == 6)
    Else
;   Else If (modulus.subtract(is).mod(SIXTEEN).equals(SIX)) {
      DEFTYPE.bigint mod_is
      bigint_Sub{modulus,is,mod_is}
      bigint_Mod{mod_is,BN_16,tempBN}
      If bigint_IsEqual{tempBN,BN_6}
        ; -- Debug info
        log_Print{"(modulus - is) mod 16 is congruent to 6."}

        ; -- ir = modulus - is
        CopyType mod_is,irAsNumber

        ; -- Debug info
        log_Print{"Have calculated <irAsNumber> = <modulus> - <is>."}

      ; -- <is> or modulus-is is not congruent To 6 MOD 16
      Else
        ; -- Debug info
        log_Print{"Return from decodeSignature(...). "}
        log_Print{"Reject Signature!"}
        log_Print{"<is> or (modulus - is) is not congruent to 6 mod 16."}

        ; -- reject signature.
        Function Return ""
      EndIf
    EndIf
  EndIf

  ; -- 'k' is the Length of the 'modulus' in bits.
  ;final Int k = modulus.bitLength();
  k.w = GetBitLength{bigint_Big2Str{modulus}}
  ;k.w = 760 ; 768

  ; -- Debug info
  log_Print{"Have set <k="+Str$(k)+">: modulus.bitLength()"}

  ; -- The lower bound for 'ir'
  ;final BigInteger lowerBound = TWO.pow(k - 2)
  DEFTYPE.bigint lowerBound
  bigint_Int2Big{2,lowerBound}
  For i.w = 1 To (k - 2) - 1
    bigint_ShiftLeft{lowerBound}
  Next i

  ; -- The upper bound for 'ir'
  ;final BigInteger upperBound = TWO.pow(k - 1).subtract(ONE);
  DEFTYPE.bigint upperBound
  bigint_Int2Big{2,upperBound}
  For i.w = 1 To (k - 1) - 1
    bigint_ShiftLeft{upperBound}
  Next i
  bigint_Sub{upperBound,BN_1,upperBound}

  ; -- If (ir < lowerBound)                                ************** ERROR ************
  If bigint_Cmp{irAsNumber,lowerBound} < 0
    ; -- Debug info
    log_Print{"Return from decodeSignature(...). "}
    log_Print{"Reject Signature! \\n<irAsNumber> is less than of 2^(k-2)."}

    ; -- reject signature.
    Function Return ""
  EndIf

  ; -- If (import > upperBound)
  If bigint_Cmp{irAsNumber,upperBound} > 0
    ; -- Debug Info
    log_Print{"Return from decodeSignature(...). "}
    log_Print{"Reject Signature! \\n<irAsNumber> is greater than 2^(k-1)-1."}

    ; -- reject signature.
    Function Return ""
  EndIf

  ; -- Convert the BigInteger representation of 'ir', denoted as
  ; -- 'irAsNumber', to the byte array representation of 'ir', denoted
  ; -- as 'ir'.
  ;byte[] ir = BigIntegerUtil.toUnsignedByteArray(irAsNumber);
  irAsString$ = bigint_Big2Str{irAsNumber}
  Dim ir.w( Len(irAsString$) )  : ir_length.w = Len(irAsString$)
  !ConvertStringtoArray{ir(i),Len(irAsString$),irAsString$}

  ; -- Debug Info
  log_Print{"Have converted ir() = "+bigint_AsString{irAsNumber}}

  ; -- We dont have To check If 'ir' is a bit string of 'ks' bits, because
  ; -- we do this with the BigInteger bound checkeing, where we check above
  ; -- If irAsNumber is in the range between 2^(k-2) To 2^(k-1)-1
  ; -- inclusively.
  ;
  ; -- Check If the least significant nibble is valued To 6
  ;If ((ir[ir.length - 1] & $0f) != $06) {
  If (ir( ir_length - 1 ) & $0F) <> $06
    ; -- LSN isn't 6
    log_Print{"Return from decodeSignature(...). "}
    log_Print{"Reject Signature! "}
    log_Print{"Least significant nibble of ir isn't 6"}
    ; "<(ir[<ir.length=ir.length+"> - 1] & $0f)="+(ir[ir.length - 1] & $0f)+">."

    ; -- reject signature.
    Function Return ""
  EndIf

  ; -- Debug 'ir'.
  log_Print{"Recovered result of <ir>."}

  ;  -----
  ;  --
  ;  -- Message recovery
  ;  --
  ;  -----

  ; -- 'ks' the Length of the signature 'sigma' in bits.
  ;final Int ks = k - 1;
  ks.w = k - 1

  ; -- Debug info
  log_Print{"Have calculated <ks="+Str$(ks)+"> = <k"+Str$(k)+"> - 1."}

  ; -- 't' is the least integer, such that a string of '2t bytes' includes at
  ; -- least 'ks-1 bits'.
  ;final Int t = (ks + 14) / 16 ;
  t.w = (ks + 14) / 16

  ; -- Debug info
  log_Print{"Have calculated <t="+Str$(t)+"> = (<ks="+Str$(ks)+"> + 14) / 16."}

  ; -- Create 'mr' with a Length of '2t bytes'
  ;final byte[] mr = New byte[2 * t];
  Dim mr_.w(2 * t) : mr_length.w  = 2 * t

  log_Print{"Have created <mr> = new byte[2 * <t="+Str$(t)+">]"}

  ; -- Copy 'ir' into 'mr'. We have To distinguish between two cases:
  ; -- 1. The number of bytes in ir is greater than OR equal To the
  ; --    number of bytes in mr.
  ; -- 2. The number of bytes in ir is less than the number of bytes in mr.
  ; -- This differentiation is necessary, because the number of bytes in mr
  ; -- is a multiple of 16 AND the number of bytes in ir is multiple of 8.

  If (ir_length >= mr_length)
    ;System.arraycopy(ir, ir.length - mr.length, mr, 0, mr.length);
    For i = 0 To mr_length - 1
      mr_(i) = ir( ir_length - mr_length + i)
    Next i
  Else ; --(ir.length < mr.length)
    ;System.arraycopy(ir, 0, mr, mr.length - ir.length, ir.length);
    For i = 0 To ir_length
      mr_(mr_length - ir_length) = ir(i)
    Next i
    ;!cout{ "********"}
  EndIf

  log_Print{"Have copied <ir> into <mr> aligned to the right."}

  ; -- Mask out (pad) all 16t - (ks - 1) bits To the left as padding bits.
  ; -- This is the reverse operation To the truncation operation.
  If ((ks - 1) MOD 16) < 8
    If ((ks - 1) MOD 8) = 0
      mr_(0) = mr_(0) & $FF
      ; Debug info
      log_Print{"Have set <mr[0]> &= $ff."}
    Else
      mr_(0) = mr_(0) & $00
      ; Debug info
      log_Print{"Have set <mr[0]> &= $00."}
    EndIf
    mr_(1) = mr_(1) & $FF LSR ((8 - (ks - 1) MOD 8) MOD 8)

  Else
    ; -- ((ks - 1) % 16 >= 8)
    mr_(0) = mr_(0) & $FF LSR (8 - (ks - 1) MOD 8)
  EndIf

  ; -- This is the reverse operation To the forcing operation.
  mr_(mr_length - 1) = ((PI_INV( (mr_(mr_length - 2) LSR 4) & $0F) LSL 4) | ((mr_(mr_length - 1) LSR 4) & $0F))

  ; Debug info
  log_Print{"Do reverse operation of forcing to <mr[<mr.length="+Str$(mr_length)+"> - 1]="}

  ; -- Debug 'mr'.
  log_Print{"Recovered result of <mr>."}

  ; -- Declare AND initialize the flag tSumsAreNull, the number z AND
  ; -- the Index r.
  tSumsAreNull.b = True
  z.w = 0
  r.w = 0

  ; -- Search For z AND r in mr, While looking For the first non Null sum.
  For i = 1 To t
    ; -- Debug m_2i AND S(m_2i-1)
    sumA.w = mr_(mr_length - (2 * i))
    sumB.w = SHADOW( mr_(mr_length - ((2 * i) - 1) ) & $FF)
    ; -- Compute the 't'-th 'sum'.
    sum.w = Xor( mr_( mr_length - (2 * i)) , SHADOW( mr_(mr_length - ((2 * i) - 1) ) & $FF))

    ;log_Print{"Look For first Non Null sum."}
    ; -- We found the first NOn Null 'sum'.
    If sum<>0
      ;log_Print{"Found first non null sum!"}
      ; -- Tell the flag that we have found the first NOn Null sum.
      tSumsAreNull = False
      ; -- Number 'z' is recovered as the position  of the first
      ; -- Non Null 'sum'.
      z = i
      ;log_Print{"Have set <z="+Str$(z)+"> = <i="+Str$(i)+">."}
      ; -- Index 'r' is recovered as the value  of the least significant
      ; -- nibble of the first NOn Null 'sum'.
      r = sum & $0F
      log_Print{"Have calculated <r="+Str$(r)+"> = <sum="+Str$(sum)+"> & $0f."}
      Pop For: Goto fexit
    EndIf
  Next i
  fexit:

  ; -- The signature sigma shall be rejected If  the t sums are Null.
  If tSumsAreNull
    ; -- reject signature
    log_Print{"Return from decodeSignature(...). "+Chr$(10)+"Reject Signature! "+Chr$(10)+"All <t="+Str$(t)+"> sums are null."}
    ; -- reject signature.
    Function Return ""
  EndIf

  ; -- The signature sigma shall be rejected If  If Index r is NOT
  ; -- valued from 1 To 8.
  If ( r < 1 ) OR (r > 8)
    log_Print{"Return from decodeSignature(...). "+Chr$(10)+"Reject Signature! "+Chr$(10)+"<r="+Str$(r)+"> is out of range. r have to be (1 <= r <= 8)."}
    ; -- reject signature.
    Function Return ""
  EndIf

  ; -- Create 'mp' with a Length of 'z' bytes.
  Dim mp.w(z) : mp_length.w = z
  ;log_Print{"Have created <mp> = new byte[<z="+Str$(z)+">]"}

  ; -- The recovered padded message 'mp' is the string of the 'z' least
  ; -- significant bytes in odd position in 'mr'
  For i = 1 To z
    mp( mp_length - i) = mr_(mr_length - ((2 * i) - 1))
  Next i

  ; -- Check the padded zero bits in 'mp'.
  If ((mp(0) & ($FF LSL (9 - r))) & $FF)<>0
    ; -- The 'r' - 1  most significant bits of 'mp' are NOT zero.
    log_Print{"Return from decodeSignature(...). "+Chr$(10)+"Reject Signature! "}
    ; -- reject signature.
    Function Return ""
  EndIf

  ; -- Debug 'ir'.
  ;log_Print{"Recovered result of <mp=>."}
  temp$ = ""
  For i = 0 To mp_length - 1
    temp$ + Right$(Hex$(mp(i)),2)+"'"
  Next i
  ;!cout{temp$}


  ;  -----
  ;  --
  ;  -- Redundancy checking
  ;  --
  ;  -----
  ;
  ; --The signature 'sigma' shall only be accepted If AND only If the
  ; --'ks'-1 least significant bits of 'mr' are equal To the 'ks'-1 least
  ; --significant bits of another extended message with redundancy
  ; --'anotherMr' computed from the recovered padded message 'mp'.
  ;
  ; --The another extended message with redundancy have to be created in
  ; --two steps:
  ; --1. Create another extended message 'anotherMe' by repeating the
  ; --   'z' bytes of 'mp', as many times as necessary, in order AND
  ; --   concatenated To the left, Until forming a string of t bytes.
  ; --2. Create another extende message with redundancy 'anotherMr' by
  ; --   interleaving the 't' bytes of 'anotherMe' in odd positions AND
  ; --   't' bytes of redundancy in Even positions. Altered by Index 'r',
  ; --   the least significant nibble of the '2z-th byte' of 'anotherMr'
  ; --   codes the message Length by its value in its position.
  ; --For performance AND memory reasons we haven't an extra 'anotherMe'.
  ; --So we create 'anotherMp' with all 'anotherMe'-like operations defined
  ; --in ISO9796-1:1991.
  ;
  ; --Create anotherMr with a Length of '2t bytes'
  Dim anotherMr.w(2 * t) : anotherMr_length.w = 2 * t
  log_Print{"Have created <anotherMr> = new byte[2 * <t="+Str$(t)+">]"}

  ; -- Extend AND interleave the padded message mp.
  For i = 1 To t
    ; -- odd position in 'anotherMr' -> (2i-1) -> 't' byte of 'me'
    anotherMr( 2*t - (2*i-1) ) = mp( z-(((i-1) MOD z) + 1))
    ; -- Even -> (2i)   -> 't' byte of redundancy with the help of SHADOW.
    anotherMr( 2*t - (2*i) ) = SHADOW( mp( z-(((i-1) MOD z) + 1) ) & $ff)
  Next i

  log_Print{"Have extended and interleaved <anotherMr=>."}

  ; -- The '2z-th byte' of 'anotherMr' equals the exclusive-or of index 'r'
  ; -- with the shadow of the 'z-th byte' of 'anotherMe'.
  anotherMr( 2*t - (2*z)) = Xor(anotherMr( 2*t - (2*z)) , r)

  log_Print{"Have xored <r> to the 2*z-th byte of anothermr: "}

  ; -- Mask out (pad) all 16t - (ks - 1) bits To the left as padding bits.
  ; -- This is the reverse operation To the truncation operation.
  If ((ks - 1) MOD 16) < 8
    If ((ks - 1) MOD 8) = 0
      anotherMr(0) = anotherMr(0) & $FF
      log_Print{"Have set <anotherMr[0]=> &= $ff."}
    Else
      anotherMr(0) = anotherMr(0) & $00
      log_Print{"Have set <anotherMr[0]=> &= $00."}
    EndIf
    anotherMr(1) = (anotherMr(1) & $ff) LSR ((8 - (ks - 1) MOD 8) MOD 8)
    log_Print{"Have set <anotherMr[1]=> &= <$ff >>> ((8 - (<ks="+Str$(ks)+"> - 1) % 8) % 8)"}

  Else ; -- ((ks - 1) % 16 >= 8)
    anotherMr(0) = anotherMr(0) & $ff LSR (8 - (ks - 1) MOD 8)
    log_Print{"Have set <anotherMr[0]=> &= <$ff >>> (8 - (<ks="+Str$(ks)+"> - 1) % 8)"}
  EndIf

  ; -- Debug anotherMr.
  log_Print{"Final result of <anotherMr="}
  temp$ =""
  For i = 0 To anotherMr_length - 1
    temp$ + Right$(Hex$(anotherMr(i)),2)+"."
  Next i
  ;!cout{temp$}

  log_Print{"mr: "}
  temp$ = ""
  For i = 0 To mr_length - 1
    temp$ + Right$(Hex$(mr_(i)),2)+"."
  Next i
  ;!cout{temp$}

  ; -- Verify if 'mr' and 'anotherMr' are the same. One Step further we
  ; -- masked the 16t - (ks - 1) padding bits so we compare now only the
  ; -- ks - 1 least significant bits in 'mr' with the ks - 1 least
  ; -- significant bits in 'anotherMr'.
  !ConvertArraytoString{mr_(i),mr_length,mr_string$}
  !ConvertArraytoString{anotherMr(i),anotherMr_length,anotherMr_string$}
  If anotherMr_string$ <> mr_string$
    ; -- ks - 1 least significant bits in 'mr' are different To the ks - 1
    ; -- least significant bits in 'anotherMr'.
    log_Print{"Return from decodeSignature(...). "+Chr$(10)+"Reject Signature! "+Chr$(10)+"<ks="+Str$(ks)+"> - 1 least significant bits in <mr=> are different Ôï the <ks="+Str$(ks)+" - 1 least significant bits in <anotherMr=>."}
    ; -- reject signature.
    Function Return ""
  EndIf

  log_Print{"<mr=> is equal to <anotherMr=>."}

  ; -- Calculate the 'message' bit string Length 'messageBitLength'.
  messageBitLength.w = (z * 8) - (r - 1)

  log_Print{"Have calculated <messageBitLength="+Str$(messageBitLength)+"> = (<z="+Str$(z)+"> * 8) - (<r"+Str$(r)+"> - 1)."}

  ; -- Create the bitStringMessage Object.
  ;  ISO9796Part1BitString bitStringMessage =
  ;  New ISO9796Part1BitString (mp, messageBitLength);
  !ConvertArraytoString{mp(i),mp_length,bitStringMessage$}
  log_Print{"ok."}
  log_Print{"decoded message:"}
  log_Print{Hexstream{bitStringMessage$}}
  ; -- We are right so we Return the recovered message.
  Function Return bitStringMessage$
End Function



CNIF #__include = 0
NoCli : WbToScreen 0 : WBenchToFront_ ;Peek.l(Addr Screen(0))
;  ; --------------------------------------------------------------------
;  ; -  Signieren der Cryp-Tool Demodatei                               -
;  ; --------------------------------------------------------------------
;  ;
;;;  datei$ = "windh_c:programme/Cryptool/examples/startbeispiel-de.txt"
;;datei$ = "windh_c:install.log"
;;  NPrint "- lese Datei "+datei$
;;  If OpenFile(1,datei$)
;;    lf.l = Lof(1) : input$ = ""
;;    *mem.l = AllocMem( lf,0)
;;    ReadMem 1,*mem,lf
;;    CloseFile 1
;;  Else
;;    Print "datei nicht lesbar."
;;    MouseWait
;;    End
;;  EndIf
;;  input$ = PeekS(*mem,lf)
;;
;;  hash$ = RIPEMD160{input$}
;;  NPrint "*** RIPEMD160-Hashwert: "+hash$ + " ***"
;;  NPrint ""
;;  bitStream$ = ""
;;  For i = 1 To Len(hash$) Step 2
;;    bitStream$ + Chr$( Val( "$"+Mid$(hash$,i,2) ) )
;;  Next i
;;
;;  NPrint "lade schluessel..."
;;  DEFTYPE.bigint N
;;
;;  If ReadFile(1,"ISO9796Part1_demokeys.txt")
;;    FileInput 1
;;    ld.l = Lof(1)
;;    While Loc(1)<ld
;;      z$ = Edit$(400) ;: NPrint "*"+z$
;;      Select z$
;;      Case "N"
;;        n$ = Edit$(400)
;;      Case "d"
;;        d$ = Edit$(400)
;;      End Select
;;    Wend
;;    CloseFile 1
;;  Else
;;    NPrint "error"
;;    MouseWait
;;    End
;;  EndIf
;;  ;!cout{"N="+n$}
;;  ;!cout{"d="+d$}
;;
;;  NPrint "erzeuge bigints."
;;  DEFTYPE.bigint N,e,d
;;  Print "exponent, "
;;  bigint_Int2Big{65537,e}
;;  NPrint "e: ",bigint_AsString{e}
;;  Print "N,"
;;  bigint_Dec2Big{n$,N}
;;  ;NPrint "N: ",bigint_AsString{N}
;;  NPrint "d"
;;  bigint_Dec2Big{d$,d}
;;  ;NPrint "d: ",bigint_AsString{d}
;;  NPrint "ok."
;;  NPrint ""
;;  NPrint "erzeuge signatur..."
;;  sign$ = ISO9796_encodeSign{bitStream$,e,d}
;;  NPrint "Ergebnis:"
;;  NPrint Hexstream{sign$}
;;MouseWait
;;End
;;
;
;  ; ---------------------------------------------------------------------
;  ; - Dekodierung einer HBCI-Signatur aus einem Beispieldiaglog         -
;  ; ---------------------------------------------------------------------
;  datei$ = "ISO9796Part1_log13.txt"
;  NPrint "- lese Datei "+datei$
;  If OpenFile(1,datei$)
;    lf.l = Lof(1) : input$ = ""
;    *mem.l = AllocMem( lf,0)
;    ReadMem 1,*mem,lf
;    CloseFile 1
;  Else
;    NPrint "datei nicht lesbar..."
;    MouseWait
;    End
;  EndIf
;
;  ; optionale anzeige als Hex
;    For i.w = 0 To lf - 1 Step 16
;      c$ = ""
;      For j.w = 0 To 15
;        b$ = PeekS(*mem+i+j,1) : If (Asc(b$)>30) AND (Asc(b$)<128) Then c$ + b$ Else c$+"."
;;        Print Right$(Hex$(Asc(b$)),2)," "
;      Next j
;;      Print i+j
;;      NPrint "  :  "+c$+" "
;    Next i
;
;  ; holen des oeffentlichen exponenten
;    sexponent$ = PeekS(*mem+628,3) ; 628 fuer log13
;    Print "oeffentl. Signierexponent: ",Len(sexponent$),"    "
;
;  ; holen des oeffentlichen Modulus
;    smodulus$ = PeekS(*mem+525,96) ; 525 fuer log13
;    NPrint "oeffentl. Modulus: ",Len(smodulus$)
;    NPrint Bitstream{smodulus$},"<<<"
;
;  ; holen der nutzdaten in message$
;;    message$ = PeekS(*mem+167,653) ; 167 fuer log13
;    NPrint "nutzdatenlaenge: ",Len(message$),"   ",Left$(message$,4),"...",Right$(message$,2)
;  ; holen der signatur in signatur$
;    signatur$ = PeekS(*mem+849,96) ; 849 fuer log13
;    NPrint "signaturlaenge : ",Len(signatur$)
;
;  For i.w = 1 To 96
;    b = i MOD 10
;    If b = 1 Then Print b Else Print "."
;  Next i
;  NPrint ""
;
;  NPrint Bitstream{signatur$},"<<<"
;  ;  For i = 1 To 96
;  ;    a$=Mid$(signatur$,i,1)
;  ;    If (Asc(a$)>30)AND(Asc(a$)<127) Then Print a$ Else Print "."
;  ;  Next i
;  FreeMem *mem,lf
;
;  bigint_Str2Big{smodulus$,modulus.bigint}
;  bigint_Str2Big{sexponent$,exponent.bigint}
;  NPrint "los gehts..."
;  test$ = ISO9796_verifySign{signatur$,exponent,modulus}
;  Print "decodierte Signatur: ",Hexstream{test$}
;  VWait 50
;MouseWait
;End
;

  log_SetDestination{#log_toboth,"ram:iso_test.log"}
  log_Reset{}
  log_SetFormat{#log_nodate}
  log_Print{"Lade Schlüssel..."}

  fid.l = file_Open{"ISO9796Part1_keyset2.txt",#file_read}
  If fid<>-1
    ld.l = file_GetLength{fid}
    While file_GetSeekPos{fid} < ld
      z$ = file_ReadLine{fid}
      !cout{z$}
      Select z$
      Case "N"
        n$ = file_ReadLine{fid}
        !cout{"n$",n$}
      Case "d"
        d$ = file_ReadLine{fid}
        !cout{"d$",d$}
      End Select
    Wend
    file_Close{fid}
  Else
    !cout{"Konnte Datei nicht oeffnen..."}
    MouseWait
    End
  EndIf

  log_Print{"Erzeuge bigints..."}
  DEFTYPE.bigint N,e,d
  bigint_Int2Big{65537,e} : log_Print{"e: "+bigint_AsString{e}}
  bigint_Dec2Big{n$,N}    : log_Print{"N: "+bigint_AsString{N}}
  bigint_Dec2Big{d$,d}    : log_Print{"d: "+bigint_AsString{d}}
  If d$="" Then End
  ;
  ; verschluesseln
  ;
  ;
;  datei$ = "system:programme/Cryptool/examples/startbeispiel-de.txt"
  datei$ = "sys:signatur.txt"
 

  log_Print{"- lese Datei "+datei$}
  If OpenFile(1,datei$)
    lf.l = Lof(1) : input$ = ""
    If lf>0
      *mem.l = AllocMem( lf,0)
      ReadMem 1,*mem,lf
    EndIf
    CloseFile 1
  EndIf
  input$ = PeekX(*mem,lf)

  ;
  ; bilden des Hashwertes nach RIPEMD160
  ;
  ;
  hash$ = RIPEMD160{input$}
  log_Print{"RIPEMD160-Hashwert:"+hash$}
  bitStream$ = ""
  For i = 1 To Len(hash$) Step 2
    bitStream$ + Chr$( Val( "$"+Mid$(hash$,i,2) ) )
  Next i

  ;
  ; signieren des Hashwertes
  ;
  ;
  log_Print{"Erzeuge Signatur für bitstream <"+Bitstream{bitStream$}+">"}
  signatur$ = ISO9796_encodeSign{bitStream$,e,d}

  ;
  ; entschluesseln
  ;
;  NPrint "":NPrint ""
;  NPrint "lade signatur..."
;  datei$ = "windh_c:programme/cryptool/examples/cry-rsa.hex" ;-startbeispiel-de.hex"
;  NPrint "- lese Datei "+datei$
;  If OpenFile(1,datei$)
;    lf.l = Lof(1) : input$ = ""
;    *mem.l = AllocMem( lf,0)
;    ReadMem 1,*mem,lf
;    CloseFile 1
;  Else
;    Print "datei nicht lesbar."
;    MouseWait
;    End
;  EndIf
;  signatur$ = PeekS(*mem+16,96) ; 849 fuer log13
;  NPrint "signaturlaenge : ",Len(signatur$)
;  NPrint Hexstream{signatur$}

  bitStream$ = signatur$
  log_Print{"\\nPrüfe Signatur..."}
  sign$ = ISO9796_verifySign{bitStream$,e,N}
  log_Print{"Pruefergebnis: <"+Hexstream{sign$}+">"}
  !cout{"Ready"}
MouseWait
Delay_ 25
MouseWait
!coutclose
WBenchToBack_
End

CEND


