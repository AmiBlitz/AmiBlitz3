; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Ram Disk:"
; ExeFile         = "test"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 103
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 128000
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 1662
; CursorColumn    = 1
; LabelSearch     = "wz_c"
; LabelRemark     = 0
; LabelAll        = 1
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 15
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 20
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 30
; /XTRA
; +---------------------------------------------------------------------------------------------------------+
; |                                                                                                         |
; | Wizard_Table.Include Version 1.6                                                                        |
; | nuetzliche Routinen zur Erweiterung der Wizard-Funktionalitaeten                                        |
; | (c) 2006-2008 - Sven Droege - eMail: honitos2001@yahoo.de                                               |
; |                                                                                                         |
; |                                                                                                         |
; | CHANGES:                                                                                                |
; | V1.3 : + Doubleclick-Erkennung, liefert #WZTABLEEVENT_DOUBLCLICK zurueck                                |
; |        + Sortieren nach Spalten bei Klick auf Spaltentitel moeglich                                     |
; |        + bedingte Kompilierung eingebaut, falls image.include oder tools.include nicht vorhanden sind   |
; |                                                                                                         |
; | Deklarationen:                                                                                          |
; | - Es wird ein leeres Wizardobject SPACE in einem Fenster benoetigt, z.B. in einer HGroup                |
; | - Ueber dessen ID z.B. "Tabelle1" greifen die Funktionen auf das Object zu                              |
; | - Standardmdssig wird auf die GUI-Daten |ber die Variable "wzgui" zugegriffen, diese ist mit            |
; |   WZLoadGUI ?wzgui einzubinden                                                                          |
; |                                                                                                         |
; |                                                                                                         |
; |                                                                                                         |
; | Dieses Include bietet derzeit folgende Erweiterungen:                                                   |
; |                                                                                                         |
; | * Tabellenfunktionen                                                                                    |
; | +  WZ_InitTable       : befuellt das NewType "wztabledata" mit Eingangswerten, die das Aussehen         |
; |                         der Tabelle beeinflussen (siehe Kommentare in der Struktur)                     |
; | +  WZ_DrawTable       : Zeichnet die Tabelle in das WizarObject ohne Daten                              |
; | +  WZ_UpdateTable     : Fuellt die Tabelle mit Werten aus der Liste wzrow()                             |
; | +  WZ_AddRow          : Fuegt der Liste wzrow() eine neue Zeile mit Inhalt zu                           |
; | +  WZ_MouseRow        : gibt an, in welche Zeile der User geklickt hat (FENSTERBEZOGEN)                 |
; | +  WZ_MouseColumn     : gibt an, in welche Spalte der User geklickt hat (FENSTERBEZOGEN)                |
; | +  WZ_HighlightTable  : malt eine Balken hinter die angegebene Zeile                                    |
; | +  WZ_EditCell        : malt ein GT-String in die angegebene Zelle (FENSTERBEZOGEN!)                    |
; | +  WZ_CheckTableEvent : behandelt ausgeloeste Events, wie TAB oder ENTER                                |
; | +  WZ_ClearTable      : loescht alle Listeneintraege                                                    |
; | +  WZ_KillTable       : loescht die kompletten Tabellendaten                                            |
; | +  WZ_GetCell         : gibt den Inhalt einer Zelle zurueck (absolute Zellenkoordinaten!)               |
; | +  WZ_SetCell         : setzt den Inhalt einer Zelle (absolute Zellenkoordinaten!)                      |
; | +  WZ_SetCellPen      : setzt Farben/styles fuer einzelne Zellen                                        |
; |                                                                                                         |
; | BEACHTEN: Einige Funktionen geben die relative Zelle zurueck, also im gerade sichtbaren                 |
; |           Tabellenausschnitt, einige Funktionen erwarten absoluten Zellenkoordinaten !!                 |
; |                                                                                                         |
; |                                                                                                         |
; | * Popup-Menu                                                                                            |
; | - WZ_SetPopUpMenu{}   : erstellt die Menueintrdge, die Eintraege werden durch chr$(10) getrennet        |
; | - WZ_PopUp{x,y}       : ruft das popupmenu auf und liefert den angewaehlten Eintrag zur|ck              |
; |
; |
; |                                                                                                         |
; | * Hilfebubble                                                                                           |
; | - Vorausgesetzt wird ein WZFenster WIN_HELP mit gesetztem Borderless-Attribut                           |
; | - Es werden die Hilfetexte, die im Wizard eingetragen wurden, bei der aktuellen Mausposition angezeigt  |
; | +  WZ_ShowHelp{}  : muss zum Ereignis IDCMP_GADGETHELP aufgerufen werdwen                               |
; | +  WZ_HideHelp{}  : dient zum loeschen der Bubble nach einem anderen Ereignis                           |
; |                                                                                                         |
; | * Fortschrittsanzeige                                                                                   |
; | - Vorausgesetzt wird ein WZFenster WIN_PROGRESS mit einem Objekt                                        |
; |   Args "FORTSCHRITT und einem GAUGE "GAUGE"                                                             |
; | + WZ_ShowMessage{} ; stellt das InfoFenster mit uebergebenem String dar                                 |
; | + WZ_HideMessage{} : schliesst das InfoFenster wieder                                                   |
; | + WZ_Update_Gauge  : aktualisiert das GAUGE im InfoFenster, Angabe:  Prozentsatz,Gesamtwert             |
; +---------------------------------------------------------------------------------------------------------+
;
; made it Syntax 6 comaptible and fix some small bugs  tomsmart1 2013 02
; replaced reqtools commands with error.include function calls  tomsmart1 2013 03


;optimize 5            ; added for testing only and deactived becasue else we overwrite the optimze stettings form the main source  tomsmart1
;Syntax 6              ; added for testing only and deactived becasue else we overwrite the optimze stettings form the main source  tomsmart1

#WZ_TABLE_VERSION = 16
;CNIF #__include = 0
; z.Zt. noch im Quellcode, um Fenster wie die Fortschrittsanzeige zu unterdruecken
; ist #USE_WIZARD nicht definiert, dann werden WZ_Fenster nicht angezeigt.
; die Wizard.lib wird verwendet:
  #USE_WIZARD = 1
;CEND

;DEFTYPE.l             ; not needed anymore becaus is syntax 6 comaptible  tomsmart1
SHARED wzgui.l


XINCLUDE "PE/wizard_Tools.include.ab3"
XINCLUDE "screen.include.bb2"
XINCLUDE "error.include.bb2" ; added to replace reqtools commands tomsmart1
;XINCLUDE "image.include.bb2"

; check if include was compiled with enough space for used objects
If ((Maximum GTList) < 25) OR ((Maximum File)<10)
  dummy.l = ask{"Object Maximum too small\\nIncrease Objectsize for GTList to >25\\nand Objectsize for Files to >10","Exit","Error"} ; replaced reqtools command with error.include function call  tomsmart1
  End
EndIf


#MAX_SPALTEN               = 10
#WZTABLEEVENT_CELLSELECTED =  8
#WZTABLEEVENT_CELLCHANGED  =  9
#WZTABLEEVENT_POPUPMENU    = 10
#WZTABLEEVENT_DOUBLECLICK  = 11


NEWTYPE.wztabledata
  LeftEdge.l
  TopEdge.l
  Width.l
  Height.l
  GadgetID.l
  GTListID.w

  FrontPen.l                    ; Textfarbe des Tabelleninhaltes
  BackPen.l                     ; Hintergrundfarbe der Tabelle
  TitlePen.l                    ; Textfarbe des Tabellentitels
  TitleBack.l                   ; Hintergrundfarbe des Tabellentitels
  Highlight.l                   ; Farbe des Balkens, der die aktuelle Zeile angibt
  vlines.b                      ; legt fest, ob horizontale Linien gezogen werden sollen, BOOL
  hlines.b
  spalten.l                     ; legt die Anzahl der Spalten fest
  readonly.l                    ; legt fest, ob die Tabelle grundsaetzlich editierbar sein sollen
  sortable.b                    ; left fest, ob die Tabelle durch klick sortiert werden kann

  id.s
  order.b                       ; gibt an,ob am Anfang oder am Ende hinzugefuegt werden soll
  window_.b                     ; gibt an, welchem Fenster die Tabelle zugeornet ist
  is_open.b                     ; gibt an, ob die Tabelle gerade angezeigt wird, BOOL
  zeilen.w                      ; gibt an, wieviele Zeilen derzeit in die Tabelle passen, INTERN
  erste_zeile.w                 ; gibt ab, welche Zeile der Liste als ganz oben in der Tabelle steht
  maxzeilen.w                   ; gibt die Gesamtzeilenzahl der Liste an
  aktuelle_zeile.w              ; gibt die aktuelle Zeile (relativ) in der Tabelle an (nicht in der Liste !)
  aktuelle_spalte.w             ; gibt die aktuelle Spalte (relativ) in der Tabelle an (nicht in der Liste !)
  edit_.b                       ; gibt an, ob gerade eine ZElle editiert wird
  title.s[#MAX_SPALTEN]         ; hier werden die Spaltentitel abgelegt
  priority.l[#MAX_SPALTEN]      ; hier wird eine Prioritaet fuer jeder Spalten vergeben, die ueber die relative Breite entscheidet
  breite.w[#MAX_SPALTEN]        ; gibt die Breite der jeweiligen Spalte an
  editable_.l[#MAX_SPALTEN]     ; gibt an, ob die Spalte editierbar ist
  align.l[#MAX_SPALTEN]
  entrytype.l[#MAX_SPALTEN]     ; gibt an, ob die Spalte Text oder Images enthalten soll
  columnheight.l                ; enthaelt die Zeilenhoehe in Pixel
  scale_images.l                ; ist dieser Schalter gesetzt, werden Images an die Zeilenhvhe skaliert
                                ; ansonsten wird die Zeile so hoch wie die Imagehoehe
  sorted_by.w                   ; optionale Tabellensortierung nach Spalte ..
  changed.b
  menu.s
  selected_popup.l
End NEWTYPE


NEWTYPE.wzrow
  id.l
  changed.b
  highlighted.b
  cell.s[#MAX_SPALTEN]
  FrontPen.l[#MAX_SPALTEN]
  BackPen.l[#MAX_SPALTEN]
  Style.b[#MAX_SPALTEN]
End NEWTYPE


NEWTYPE.wzimage
  table.s
  id.l
  Name.s
  Width.l
  Height.l
  _Depth.l
End NEWTYPE


DEFTYPE.wztabledata wztabledata
Dim List wzrow.wzrow(0)
Dim List wzimage.wzimage(0)
SHARED wzimage()



Macro WZ_VerifyVisibility
            If (`1 = (wztabledata\erste_zeile-1) + wztabledata\zeilen)
              If (wztabledata\erste_zeile-1) + `1 = wztabledata\maxzeilen
                `1 + 1
                col = 0
                wztabledata\erste_zeile + 1
              Else
                col = 0
                wztabledata\erste_zeile + 1
                `1 + 1
              EndIf
              ; bereichspruefung
              If wztabledata\erste_zeile-1 + wztabledata\zeilen < wztabledata\maxzeilen
              Else
                `1 - 1
                wztabledata\erste_zeile - 1
              EndIf
            Else
              If (wztabledata\erste_zeile-1) + `1 = wztabledata\maxzeilen
                `1 = 1
                col = 0
                wztabledata\erste_zeile = 1
              Else
                `1 + 1
                col = 0
              EndIf
            EndIf
End Macro


Macro WZ_CutCell
  cut_lenz.l = StrLen(`1)
  If cut_lenz > 0
    While (DrTextLen(`1) > (`2 - 4)) AND (cut_lenz > -1)
      cut_lenz - 1
      `1 = StrLeft(`1,cut_lenz)
    Wend
  EndIf
End Macro


Macro WZ_DrawRow
  ;DEFTYPE.l yadd

  For j.l = 1 To wztabledata\spalten
    If (zeile.w<=wztabledata\maxzeilen) AND (zeile<=wztabledata\zeilen) AND (wztabledata\breite[j]>0)
      sbreite.w = wztabledata\breite[j]
      a$ = wzrow()\cell[j]

      If j = 1
        sx.w = 0
        wx.l = wztabledata\LeftEdge
        wy.l = wztabledata\TopEdge
        ww.l = wztabledata\Width
        wh.l = wztabledata\Height
        gh.l = wztabledata\columnheight
      EndIf


      Select wztabledata\entrytype[j]


        Case #WNE_TEXT
          !WZ_CutCell {a$,sbreite}
          If Left$(a$,4)="####"
            text_height.l = WZYFontsize
            If text_height < gh Then yadd.l = (gh - text_height) / 2 Else yadd = 0
            wypos.l = wy + (WZYFontsize*1.5) + yadd + gh * (zeile-1)
            !SetDrMd{*tablewin\RPort,%0101010101010101}                   ;+ zeilenhoehe
            DrLine wx + sx,wypos,wx+sx+sbreite,wypos,wzrow()\FrontPen[j]
            !SetDrMd{*tablewin\RPort,-1}

            sx + sbreite
          Else
            If wzrow()\Style[j]>0
              SetSoftStyle_ DrPort,wzrow()\Style[j],AskSoftStyle_(DrPort)
            Else
              SetSoftStyle_ DrPort,0,AskSoftStyle_(DrPort)
            EndIf
            text_height.l = WZYFontsize

            If text_height < gh Then yadd.l = (gh - text_height) / 2 Else yadd = 0
            wypos.l = wy + WZYFontsize + yadd + gh * (zeile-1)
            DrMode 0
            Select wztabledata\align[j]

              Case #ALIGN_LEFT
                DrText a$, wx + sx +  4 , wypos,wzrow()\FrontPen[j]
                sx + sbreite

              Case #ALIGN_RIGHT
                sx + sbreite : tl.l = DrTextLen(a$) + 4
                DrText a$, wx + sx - tl , wypos,wzrow()\FrontPen[j]

              Case #ALIGN_CENTER
                tl.l = (sbreite - DrTextLen(a$)) / 2
                DrText a$, wx + sx + tl , wypos,wzrow()\FrontPen[j]
                sx + sbreite

            End Select
          EndIf


        Case #WNE_IMAGE
          image_width.l = WZ_ImageWidth{a$} : image_height.l = WZ_ImageHeight{a$}
          If image_height < gh Then yadd.l = (gh - image_height) / 2 Else yadd = 0
          wypos.l = wy + WZYFontsize + yadd + gh * (zeile - 1)
          Select wztabledata\align[j]

            Case #ALIGN_LEFT
              WZ_DrawImage{gadgetid$,a$,wx + sx,wypos}
              sx + sbreite

            Case #ALIGN_RIGHT
              sx + sbreite :
              WZ_DrawImage{gadgetid$,a$,wx + sx - image_width ,wypos}

            Case #ALIGN_CENTER
              tl.l = (sbreite - WZ_ImageWidth{a$}) / 2
              WZ_DrawImage{gadgetid$,a$,wx + sx + tl,wypos}
              sx + sbreite

          End Select


      End Select
    EndIf
  Next j
End Macro


Macro WZ_StdTable
  WZWindow WZID("WIN_TABELLE"),?wzgui,64,-1,-1,-1,-1,WZID("WIN_TABELLE")
  WTitle `1
  WZ_InitTable{"WIN_TABELLE","TABELLE",2,0}
  ; Fuegt Zeilen an die Tabelle "TABELLE2" an
   WZ_SetTableColors{"TABELLE",2,4,1,0,4}
  WZ_SetTableTitle{"TABELLE",`2,`3}
  WZ_SetPriority{"TABELLE",`4,`5}
  WZ_SetTableReadOnly{"TABELLE",False}
  WZ_SetTableLines{"TABELLE",On,Off}
  WZ_SetTableAlign{"TABELLE",#ALIGN_LEFT,#ALIGN_LEFT}
End Macro
 

Macro WZ_FillTable
  WZ_AddRow{"TABELLE",`1,`2}
End Macro


Macro WZ_KillTable
  WZ_KillTable{"TABELLE"}
  WZCloseWindow WZID("WIN_TABELLE")
End Macro


Macro WZ_ShowTable
  WZ_DrawTable{"TABELLE"}
  WZ_UpdateTable{"TABELLE"}
  mkt.b = False
  Repeat
    ev = WaitEvent
    If ev = #IDCMP_CLOSEWINDOW
      !WZ_KillTable
      mkt = True
    Else
      dummy = WZ_CheckTableEvent{ev}
    EndIf
  Until mkt
End Macro


;Function.s GTGetString_MOS{lst.l,id.l}
;  *g.Gadget = GTGadPtr(lst,id)
;  *w.Window = Peek.l(Addr Window(Used Window))
;  If *g <> 0
;    ;*g3.StringInfo = *g2\SpecialInfo ; private Data, sollte man nicht machen
;    ;numchars.l = *g3\NumChars        ;
;    strptr.l = 0
;    Dim myTags.TagItem(1)
;    myTags(0)\ti_Tag = #GTST_String
;    myTags(0)\ti_Data = &strptr
;    myTags(1)\ti_Tag = #TAG_DONE
;    dummy.l = GT_GetGadgetAttrsA_(*g,*w,0,&myTags(0))<>0
;    text$ = PeekS(strptr,StrLen(strptr))
;  Else
;    text$ = ""
;  EndIf
;  Function Return text$
;End Function


Statement WZ_DrawImage{gadgetid$,image_name$,wx.l,wy.l}
;* Zeichnet das angegene Image im TAbellengadget
;* .
;* gadgetid$   : eindeutiger ID-String, der die Tabelle kennzeichnet; siehe WZ_InitTable()
;* image_name$ : ID-String des anzuzeigenden Images, siehe WZ_AddImage()
;* wx.l        : x-Position innerhalb des Gadgets
;* wy.l        : y-Position innerhalb des Gadgets
 SHARED wztabledata

 CNIF @#max_images<>0
  If FirstItem(wzimage())
    Repeat
      If wzimage()\Name = image_name$
;        NIBDrawImage{wzimage()\id,#NIB_NORMAL, WZID(gadgetid$),wx,wy}
;      !cout{image_AlphaIsUsed{wzimage()\id}}
        If wzimage()\Height<wztabledata\columnheight
           image_BlitMask{wzimage()\id,wx+1,wy+1}
        Else
          image_FancyBlit{wzimage()\id,wx+1,wy+1,wzimage()\Width,wztabledata\columnheight-1}
        EndIf
        Statement Return
      EndIf
    Until NOT NextItemFast(wzimage())
  EndIf
 CEND
End Statement


Statement WZ_KillImages{gadgetid$}
 CNIF @#max_images<>0 :
  If FirstItem(wzimage())
    Repeat
      If wzimage()\table = gadgetid$ Then image_Free{wzimage()\id} : KillItem wzimage()
    Until NOT NextItemFast(wzimage())
    If NOT FirstItem(wzimage()) Then ClearList wzimage()
  EndIf
 CEND
End Statement


Function.l WZ_AddImage{gadgetid$,image_name$,fname$}
 CNIF @#max_images<>0 :
  If AddLast(wzimage())
    wzimage()\table= gadgetid$
    wzimage()\Name = image_name$
    wzimage()\id = Index(wzimage()) - 1

    If image_Load {wzimage()\id,fname$,0}
      wzimage()\Width = image_GetWidth{wzimage()\id} +1
      wzimage()\Height= image_GetHeight{wzimage()\id } +1
    Else
      KillItem wzimage()
      Function Return False
    EndIf
  EndIf
 CEND
End Function


Function.l WZ_ImageHeight{image_name$}
 CNIF @#max_images<>0 :
  If FirstItem( wzimage())
    Repeat
      If wzimage()\Name = image_name$ Then Function Return wzimage()\Height
    Until NOT NextItemFast(wzimage())
  EndIf
 CEND
End Function


Function.l WZ_ImageWidth{image_name$}
 CNIF @#max_images<>0
  If FirstItem( wzimage())
    Repeat
      If wzimage()\Name = image_name$ Then Function Return wzimage()\Width
    Until NOT NextItemFast(wzimage())
  EndIf
 CEND
End Function


Function.l WZ_RemoveImage{image_name$}
 CNIF @#max_images<>0
  If FirstItem(wzimage())
    Repeat
      If wzimage()\Name = image_name$
;        NIBFreeIcon{wzimage()\id}
        image_Free{wzimage()\id}
        KillItem wzimage()
      EndIf
    Until NOT NextItemFast(wzimage())
  EndIf
 CEND
End Function


Statement ShowTable{g$}
 SHARED wzrow()

  If FirstItem(wzrow())
      j.l =  Index(wzrow()) : i.l = 1
      DefaultOutput
      NPrint ""
      NPrint g$ + ":"
      Repeat
        If (i<3) OR (i>32)
          NPrint i,": ", wzrow()\cell[1],"  -  ",wzrow()\cell[2]
        EndIf
        i + 1
      Until (NOT NextItemFast(wzrow()))
   EndIf
End Statement


Statement RestoreTable{gadgetid$}
 SHARED wztabledata,wzrow()

  dir$ = "RAM:T/"
  ClearType wztabledata
  ClearList wzrow()

  If Exists(dir$+gadgetid$+".data")
    If OpenFile(10,dir$ + gadgetid$ + ".data")
      ReadType 10,wztabledata
      CloseFile 10
    EndIf
    If OpenFile(10,dir$ + gadgetid$ + ".content")
      lf.l = Lof(10)
      While Loc(10)<>lf
        If AddLast(wzrow())
          ReadType 10,wzrow()
        EndIf
      Wend
      CloseFile 10
    EndIf
;    ShowTable{"LOAD "+gadgetid$}
  EndIf
End Statement


Statement SaveTable{gadgetid$}
 SHARED wztabledata,wzrow()

  dir$ = "RAM:T/"
  DeleteFile_ dir$ + gadgetid$ + ".data"
  DeleteFile_ dir$ + gadgetid$ + ".content"

  If OpenFile(10,dir$ + gadgetid$ + ".data")
    wztabledata\changed = False
    WriteType 10,wztabledata
    CloseFile 10
  EndIf
  If OpenFile(10,dir$ + gadgetid$ + ".content")
    ResetList wzrow()
    While NextItemFast(wzrow())
      WriteType 10,wzrow()
    Wend
    CloseFile 10
  EndIf

;  ShowTable{"SAVE "+gadgetid$}
  DefaultOutput
  ClearType wztabledata
  ClearList wzrow()
End Statement



Statement SetActualTable{gadgetid$}
 SHARED  wztabledata,wzrow()
  DEFTYPE.l dummy

  If (gadgetid$<>wztabledata\id)
    If (wztabledata\id<>"")
      If (wztabledata\edit_ = True)
        *g.Gadget = WZGadAddr(gadgetid$ )
        If *g<>0
          id.l = *g\GadgetID
          If GTGadPtr(wztabledata\GTListID,0) <> 0
            zeile.w  =  wztabledata\aktuelle_zeile + (wztabledata\erste_zeile-1)
            spalte.w =  wztabledata\aktuelle_spalte
            text$ = GTGetString(wztabledata\GTListID,0)
            ; workaround fuer MorphOS
;            If text$ = ""
;              text$ = GTGetString_MOS{wztabledata\GTListID,0}
;            EndIf

            ResetList wzrow()
            While NextItemFast(wzrow())
              If Index(wzrow())-1 = zeile
                If wzrow()\cell[spalte] <> text$
                  wzrow()\cell[spalte] = text$
                  wzrow()\changed = True
                  wztabledata\changed = True
                EndIf
              EndIf
            Wend
            wztabledata\edit_ = False
            DetachGTList wztabledata\GTListID
            Free GTList wztabledata\GTListID
          EndIf
        Else
          error{"The designated table "+gadgetid$+" does not exist."} ; replaced reqtools command with error.include function call  tomsmart1
        EndIf
      EndIf
      If (wztabledata\changed = True) Then SaveTable{wztabledata\id}
    EndIf
    RestoreTable{gadgetid$}
  EndIf
  Use Window wztabledata\window_
End Statement


Statement WZ_SetRowID{gadgetid$,id.l}
 SHARED wztabledata,wzrow()

  wzrow()\id = id
End Statement


Function.l WZ_GetRowID{gadgetid$}
 SHARED wztabledata,wzrow()

  Function Return wzrow()\id
End Function
 


Statement WZ_AddRow{gadgetid$,@n1$,@n2$,@n3$,@n4$,@n5$,@n6$,@n7$,@n8$,@n9$}
 SHARED wztabledata,wzrow()

  SetActualTable{gadgetid$}

  Select wztabledata\order
  Case 0 : dummy.l = AddLast(wzrow())
  Case 1 : dummy = AddFirst(wzrow())
  End Select

  If dummy = True
    wzrow()\cell[1] = n1$
    wzrow()\cell[2] = n2$
    wzrow()\cell[3] = n3$
    wzrow()\cell[4] = n4$
    wzrow()\cell[5] = n5$
    wzrow()\cell[6] = n6$
    wzrow()\cell[7] = n7$
    wzrow()\cell[8] = n8$
    wzrow()\cell[9] = n9$

    For i.l = 1 To (#MAX_SPALTEN - 1)
      wzrow()\FrontPen[i] = wztabledata\FrontPen
      wzrow()\BackPen[i]  = wztabledata\BackPen
    Next i
    wztabledata\maxzeilen + 1
    wztabledata\changed = True
  EndIf

End Statement


Statement WZ_SetTableLines{gadgetid$,vstate.l,@hstate.l}
 SHARED wztabledata

;  SetActualTable{gadgetid$}
  wztabledata\vlines = vstate
  wztabledata\hlines = hstate
End Statement


Statement WZ_SetCellPen{gadgetid$,spalte.l,FrontPen.l,BackPen.l,@Style.b}
SHARED wztabledata,wzrow()
  wzrow()\FrontPen[spalte] = FrontPen.l
  wzrow()\BackPen[spalte] = Backpen.l
  wzrow()\Style[spalte] = Style.b
End Statement


Statement WZ_SetRowPen{gadgetid$,FrontPen.l,BackPen.l,@Style.b}
SHARED wztabledata,wzrow()
    For i.l = 1 To (#MAX_SPALTEN - 1)
      wzrow()\FrontPen[i] = FrontPen
      wzrow()\BackPen[i] = BackPen
      wzrow()\Style[i] = Style.b
    Next i
End Statement



Statement WZ_ClearTable{gadgetid$}
SHARED wztabledata,wzrow()

  SetActualTable{gadgetid$}

  ClearList wzrow()
  wztabledata\maxzeilen = 0
  wztabledata\changed = True
  wztabledata\erste_zeile = 1
  wztabledata\aktuelle_zeile = 0
End Statement



Statement WZ_InitTable{winid$,gadgetid$,spalten.w,@order.w}
;* Initialisiert eine neue Tabelle aus den anzugebenen Daten:
;* .
;* winid$    : der eindeutige ID-String der zu initialisierenden Tabelle
;* gadgetid$ : der Wizard-ID-String des Gadgets, in dem die Tabelle erstellt werden soll
;* spalten.w : Anzahl der Spalten fuer die Tabelle
;* order.w   : Sortierreihenfolge der Eintraege, 0 = von oben nach unten, 1 = andersrum
SHARED wzgui,wztabledata

  DeleteFile_ "ram:t/" + gadgetid$ + ".data"
  DeleteFile_ "ram:t/" + gadgetid$ + ".content"
  SetActualTable{gadgetid$}

  wztabledata\window_ = WZID(winid$)
  wztabledata\GTListID= WZID(winid$)
  wztabledata\id = gadgetid$
  wztabledata\readonly = False
  wztabledata\sortable = True
  wztabledata\hlines = False
  wztabledata\vlines = True

  wztabledata\spalten = spalten

  wztabledata\erste_zeile = 1
  wztabledata\aktuelle_zeile=  0

  wztabledata\FrontPen = 1;#WZRD_TEXTPEN
  wztabledata\BackPen =  0;#WZRD_BACKGROUNDPEN
  wztabledata\TitlePen = 2;#WZRD_BARDETAILPEN
  wztabledata\TitleBack = 3;#WZRD_BARBLOCKPEN
  wztabledata\Highlight = 3;#WZRD_FILLPEN

  If order = -1 Then order = 0
  wztabledata\order = order

  wztabledata\changed = True
  For i.w = 1 To spalten.w
    wztabledata\priority[i] = 1
    wztabledata\editable_[i] = False
    wztabledata\title[i] = ""
    wztabledata\entrytype[i] = #WNE_TEXT
  Next i
End Statement


Statement WZ_KillTable{gadgetid$}
SHARED wzgui,wztabledata,wzrow()

  SetActualTable{gadgetid$}
  DeleteFile_ "ram:t/" + gadgetid$ + ".data"
  DeleteFile_ "ram:t/" + gadgetid$ + ".content"
  WZ_KillImages{gadgetid$}
  ClearType wztabledata
  ClearList wzrow()
End Statement


Statement WZ_SetTableReadOnly{gadgetid$,ro.w}
SHARED wzgui,wztabledata
  SetActualTable{gadgetid$}
  wztabledata\readonly = ro
  wztabledata\changed = True
End Statement


Statement WZ_SetTableColors{gadgetid$,fp.l,bp.l,@tp.w,@tb.w,@hl.w}
SHARED wzgui,wztabledata
  SetActualTable{gadgetid$}
  wztabledata\FrontPen = fp
  wztabledata\BackPen = bp
  If tp<>-1 Then  wztabledata\TitlePen = tp
  If tb<>-1 Then  wztabledata\TitleBack = tb
  If hl<>-1 Then  wztabledata\Highlight = hl
  wztabledata\changed = True
End Statement


Statement WZ_SetTableAlign{gadgetid$,@n1.w,@n2.w,@n3.w,@n4.w,@n5.w,@n6.w,@n7.w,@n8.w,@n9.w}
SHARED wzgui,wztabledata

  SetActualTable{gadgetid$}

  wztabledata\align[1] = n1
  If n2 <>-1 Then wztabledata\align[2] = n2
  If n3 <>-1 Then wztabledata\align[3] = n3
  If n4 <>-1 Then wztabledata\align[4] = n4
  If n5 <>-1 Then wztabledata\align[5] = n5
  If n6 <>-1 Then wztabledata\align[6] = n6
  If n7 <>-1 Then wztabledata\align[7] = n7
  If n8 <>-1 Then wztabledata\align[8] = n8
End Statement
 


Statement WZ_SetRowType{gadgetid$,@n1.w,@n2.w,@n3.w,@n4.w,@n5.w,@n6.w,@n7.w,@n8.w,@n9.w}
SHARED wzgui,wztabledata

  SetActualTable{gadgetid$}

  wztabledata\entrytype[1] = n1
  If n2<>-1 Then wztabledata\entrytype[2] = n2
  If n3<>-1 Then wztabledata\entrytype[3] = n3
  If n4<>-1 Then wztabledata\entrytype[4] = n4
  If n5<>-1 Then wztabledata\entrytype[5] = n5
  If n6<>-1 Then wztabledata\entrytype[6] = n6
  If n7<>-1 Then wztabledata\entrytype[7] = n7
  If n8<>-1 Then wztabledata\entrytype[8] = n8
End Statement


Statement WZ_SetTableTitle{gadgetid$,@n1$,@n2$,@n3$,@n4$,@n5$,@n6$,@n7$,@n8$,@n9$}
SHARED wzgui,wztabledata

  SetActualTable{gadgetid$}
  wztabledata\title[1] = n1$
  wztabledata\title[2] = n2$
  wztabledata\title[3] = n3$
  wztabledata\title[4] = n4$
  wztabledata\title[5] = n5$
  wztabledata\title[6] = n6$
  wztabledata\title[7] = n7$
  wztabledata\title[8] = n8$
End Statement


Statement WZ_SetTableOrder{gadgetid$,order.w}
SHARED wzgui,wztabledata

  SetActualTable{gadgetid$}
  wztabledata\order = order
End Statement


Statement WZ_SetSortable{gadgetid$,mode.b}
SHARED wztabledata
  SetActualTable{gadgetid$}
  wztabledata\sortable = mode
End Statement


Statement WZ_SetPriority{gadgetid$,@n1.w,@n2.w,@n3.w,@n4.w,@n5.w,@n6.w,@n7.w,@n8.w,@n9.w}
SHARED wzgui,wztabledata

  SetActualTable{gadgetid$}

  If n1<>-1 Then  wztabledata\priority[1] = n1
  If n2<>-1 Then  wztabledata\priority[2] = n2
  If n3<>-1 Then  wztabledata\priority[3] = n3
  If n4<>-1 Then  wztabledata\priority[4] = n4
  If n5<>-1 Then  wztabledata\priority[5] = n5
  If n6<>-1 Then  wztabledata\priority[6] = n6
  If n7<>-1 Then  wztabledata\priority[7] = n7
  If n8<>-1 Then  wztabledata\priority[8] = n8
  If n9<>-1 Then  wztabledata\priority[9] = n9

End Statement


Statement WZ_SetEditable{gadgetid$,@n1.w,@n2.w,@n3.w,@n4.w,@n5.w,@n6.w,@n7.w,@n8.w,@n9.w}
SHARED wzgui,wztabledata
  SetActualTable{gadgetid$}

  wztabledata\editable_[1] = n1
  wztabledata\editable_[2] = n2
  wztabledata\editable_[3] = n3
  wztabledata\editable_[4] = n4
  wztabledata\editable_[5] = n5
  wztabledata\editable_[6] = n6
  wztabledata\editable_[7] = n7
  wztabledata\editable_[8] = n8
  wztabledata\editable_[9] = n9

End Statement


Function.l WZ_GetNumberOfEntries{gadgetid$}
SHARED wzgui,wztabledata,wzrow()
  SetActualTable{gadgetid$}
  Function Return wztabledata\maxzeilen
End Function


Function.s WZ_GetCell{gadgetid$,zeile.l,spalte.l}
SHARED wzgui,wztabledata,wzrow()

  If (zeile>0) AND (spalte>0)
    SetActualTable{gadgetid$}
    ResetList wzrow()
    While NextItemFast(wzrow())
      If Index(wzrow())-1 = zeile
        r$ = wzrow()\cell[spalte]
        Function Return r$
      EndIf
    Wend
  EndIf
End Function


Function.b WZ_SetCell{gadgetid$,zeile.l,spalte.l,wert$}
SHARED wzgui,wztabledata,wzrow()

  SetActualTable{gadgetid$}
  ResetList wzrow()
  While NextItemFast(wzrow())
    If Index(wzrow())-1 = zeile
      If wzrow()\cell[spalte] <> wert$
        wzrow()\cell[spalte] = wert$
        wzrow()\changed = True
        wztabledata\changed = True
        Function Return True
      EndIf
    EndIf
  Wend
End Function



Statement WZ_EditExit{gadgetid$}
SHARED wzgui,wztabledata

  SetActualTable{gadgetid$}
  If wztabledata\edit_ = True
    *g.Gadget = WZGadAddr(gadgetid$)
    *w.Window = WZWindowAddr
    If *g<>0
      id.l = *g\GadgetID
      zeile.w  =  wztabledata\aktuelle_zeile
      spalte.w =  wztabledata\aktuelle_spalte
      text$ = GTGetString(wztabledata\GTListID,0)
      ; workaround fuer MorphOS
;      If text$ = ""
;        text$ = GTGetString_MOS{wztabledata\GTListID,0}
;      EndIf
      ;
      z.b = WZ_SetCell{gadgetid$,zeile,spalte,text$}
      wztabledata\edit_ = False
      DetachGTList wztabledata\GTListID
      Free GTList wztabledata\GTListID
    EndIf
  EndIf
End Statement


Statement WZ_SetActiveRow{gadgetid$,zeile.l}
SHARED wztabledata,wzrow()
  SetActualTable{gadgetid$}
;  ResetList wzrow()
;  While NextItemFast(wzrow())
;    If Index(wzrow())-1 = wztabledata\erste_zeile + zeile
;      wzrow()\highlighted = True
;    Else
;      wzrow()\highlighted = True
;;      wztabledata\aktuelle_zeile = zeile
;    EndIf
;  Wend
  wztabledata\aktuelle_zeile = zeile
End Statement


Statement WZ_SetActiveColumn{gadgetid$,spalte.l}
SHARED wztabledata,wzrow()
  SetActualTable{gadgetid$}

  wztabledata\aktuelle_spalte = spalte
End Statement


Function.b WZ_RowChanged{gadgetid$,zeile.l}
SHARED wztabledata,wzrow()

  SetActualTable{gadgetid$}
  ResetList wzrow()
  While NextItemFast(wzrow())
    If Index(wzrow())-1 = zeile
      If wzrow()\changed = True Then Function Return True
    EndIf
  Wend
End Function


Function.w WZ_Row{gadgetid$}
SHARED wztabledata,wzrow()

  SetActualTable{gadgetid$}
  If (wztabledata\aktuelle_zeile>0) AND (NOT wztabledata\readonly)
    l.l = wztabledata\aktuelle_zeile
    If l > wztabledata\maxzeilen Then l = 0
    Function Return l
  Else
    Function Return 0
  EndIf
End Function


Function.w WZ_Column{gadgetid$}
SHARED wzgui,wztabledata,wzrow()
  
  SetActualTable{gadgetid$}
  If NOT wztabledata\readonly
    Function Return wztabledata\aktuelle_spalte
  EndIf
End Function


Function.w WZ_RelativeRow{gadgetid$}
SHARED wztabledata,wzrow()

  SetActualTable{gadgetid$}
  If (wztabledata\aktuelle_zeile>0) AND (NOT wztabledata\readonly)
    l.l = wztabledata\aktuelle_zeile
    If l>wztabledata\maxzeilen Then l = 0
    Function Return l
  Else
    Function Return 0
  EndIf
End Function



Function.w WZ_MouseRow{gadgetid$,mx.w,my.w}
SHARED wzgui,wztabledata,wzrow()

  SetActualTable{gadgetid$}
  *gad.Gadget = WZGadAddr(gadgetid$)
  If *gad<>0
    wx.l = wztabledata\LeftEdge
    wy.l = wztabledata\TopEdge
    ww.l = wztabledata\Width
    wh.l = wztabledata\Height
    If (mx > wx) AND (mx<(wx + ww)) AND (my>wy) AND (my<(wy+wh))
      gh.l = wztabledata\columnheight
      If my < (wy + WZYFontsize)
        row.w = 0
      Else
        row.w = (wztabledata\erste_zeile-1) + Int( (my - (wy+WZYFontsize))) / gh + 1
      EndIf
      Function Return row
    Else
      Function Return 0
    EndIf
  Else
    Function Return 0
  EndIf
End Function


Function.w WZ_MouseColumn{gadgetid$,mx.w,my.w}
SHARED wzgui,wztabledata,wzrow()

  SetActualTable{gadgetid$}
  *gad.Gadget = WZGadAddr(gadgetid$)
  If *gad<>0
    wx.l = wztabledata\LeftEdge
    wy.l = wztabledata\TopEdge
    ww.l = wztabledata\Width
    wh.l = wztabledata\Height
    x.l = wx
    If (mx > wx) AND (mx<(wx+ww)) AND (my>wy) AND (my<(wy+wh))
      For j.l = 1 To wztabledata\spalten
        x + wztabledata\breite[j]
        If (mx < x) Then Function Return j
      Next j
    Else
      Function Return 0
    EndIf
  Else
    Function Return 0
  EndIf
End Function


Statement WZ_ImageScaleOff{gadgetid$}
SHARED wztabledata
DEFTYPE .l
  SetActualTable{gadgetid$}
  wztabledata\scale_images = Off
End Statement

Statement WZ_ImageScaleOn{gadgetid$}
SHARED wztabledata
DEFTYPE .l
  SetActualTable{gadgetid$}
  wztabledata\scale_images = On
End Statement




Statement WZ_DrawTable{gadgetid$}
SHARED wztabledata,liste$()
DEFTYPE .l
  SetActualTable{gadgetid$}

  If FirstItem(wzimage())
    Repeat
      If wzimage()\table = gadgetid$
        If wztabledata\columnheight < wzimage()\Height Then wztabledata\columnheight = wzimage()\Height + 2
      EndIf
    Until NOT NextItemFast(wzimage())
  EndIf
  If wztabledata\scale_images = Off
    If wztabledata\columnheight < WZYFontsize + 2 Then wztabledata\columnheight = WZYFontsize + 2
  Else
    wztabledata\columnheight = WZYFontsize + 2
  EndIf

  Use Window wztabledata\window_
  *g.Gadget = WZGadAddr(gadgetid$)
  If *g<>0
    wztabledata\LeftEdge = *g\LeftEdge + 1
    wztabledata\TopEdge  = *g\TopEdge + 1
    wztabledata\Width    = *g\Width  - 3
    wztabledata\Height   = *g\Height - 1
    wztabledata\GadgetID = *g\GadgetID
    *tablewin.Window = WZWindowAddr : DrPort *tablewin\RPort
    zeilenhoehe.l = WZYFontsize
    If zeilenhoehe > 72
      zeilenhoehe = *tablewin\IFont\tf_YSize
      error{"There was a problem with WZYFontSize.\\nThis problem is related to AFA_OS.\\nApplication may fail."}
    EndIf

    WZ_EditExit{gadgetid$} ; sichern evtl. gemachter Eingaben im Gadget

    If wztabledata\columnheight <> 0
      wztabledata\zeilen = (wztabledata\Height - zeilenhoehe) / (wztabledata\columnheight)
    Else
      error{"There has been an error while processing WZ_DrawTable(). columnheight is 0."}
      Statement Return
    EndIf

    ;breite = wztabledata\Width / wztabledata\spalten

    gesamtp.l = 0
    For p.l = 1 To wztabledata\spalten
      If wztabledata\entrytype[p] = #WNE_TEXT Then gesamtp + wztabledata\priority[p]
    Next p

    For p.l = 1 To wztabledata\spalten
      If wztabledata\entrytype[p] = #WNE_IMAGE
        If FirstItem( wzimage())
          image_width.l = 0
          Repeat
            If image_width < wzimage()\Width Then image_width = wzimage()\Width
          Until NOT NextItemFast(wzimage())
        EndIf
        image_width + 2
        wztabledata\breite[p] = image_width

      EndIf
    Next p

    table_width.l = wztabledata\Width - image_width
    If gesamtp>0
      For p.l = 1 To wztabledata\spalten
        If wztabledata\entrytype[p] = #WNE_TEXT
          anteil.q = wztabledata\priority[p] / gesamtp
          wztabledata\breite[p] = Int(anteil * table_width)
        EndIf
      Next p
    EndIf

    DrBoxf  wztabledata\LeftEdge,wztabledata\TopEdge     ,wztabledata\LeftEdge+wztabledata\Width,wztabledata\TopEdge+wztabledata\Height-2,wztabledata\BackPen
    DrBoxf  wztabledata\LeftEdge,wztabledata\TopEdge     ,wztabledata\LeftEdge+wztabledata\Width,wztabledata\TopEdge + zeilenhoehe,wztabledata\TitleBack
    DrLine wztabledata\LeftEdge,wztabledata\TopEdge+zeilenhoehe,wztabledata\LeftEdge+wztabledata\Width,wztabledata\TopEdge + zeilenhoehe,1
    GTGZZPosition On
    WJam 0
    sx.w = 0

    For x.l = 1 To wztabledata\spalten
      If wztabledata\breite[x]>0
        a$ = wztabledata\title[x]
        sbreite.w = wztabledata\breite[x]

        ; Zeichnen des Sortiersymbols in der Titelzeile
        DrMode 0
        If wztabledata\sorted_by = x
          If wztabledata\align[x] = #ALIGN_LEFT
            lw.w = 8
            lx.l = wztabledata\LeftEdge + sx + sbreite - 8
          Else
            lw.w = 8
            lx.l = wztabledata\LeftEdge + sx + 4
          EndIf
          ly.l = 1 + wztabledata\TopEdge + zeilenhoehe * zeile.w
          lh.w = zeilenhoehe - 3
          DrBoxf lx-1,ly, lx+lw,ly+lh,0
          DrLine lx-1,ly,  lx+(lw/2)-1,ly+lh, lx-1+lw,ly,  2
          DrLine lx  ,ly,  lx+(lw/2)  ,ly+lh, lx  +lw,ly, 1
        EndIf

        ; Zeichnen der Titelnamen
        !WZ_CutCell {a$, sbreite}
        SetSoftStyle_ DrPort,2,AskSoftStyle_(DrPort)
        Select wztabledata\align[x]
        Case #ALIGN_LEFT
          DrText a$, wztabledata\LeftEdge + sx + 4, wztabledata\TopEdge + zeilenhoehe * zeile.w , wztabledata\TitlePen
          sx + sbreite
        Case #ALIGN_RIGHT
          sx + sbreite : tl.l = DrTextLen(a$) + 4
          DrText a$, wztabledata\LeftEdge + sx - tl , wztabledata\TopEdge + zeilenhoehe * zeile,wztabledata\TitlePen
        Case #ALIGN_CENTER
          tl.l = (sbreite - DrTextLen(a$)) / 2
          DrText a$, wztabledata\LeftEdge + sx + tl , wztabledata\TopEdge + zeilenhoehe * zeile,wztabledata\TitlePen
          sx + sbreite
        End Select
        ; zeichne titeltrennlinien
        If x<wztabledata\spalten
          DrLine wztabledata\LeftEdge + sx    , wztabledata\TopEdge, wztabledata\LeftEdge + sx    , wztabledata\TopEdge+zeilenhoehe,1
          DrLine wztabledata\LeftEdge + sx + 1, wztabledata\TopEdge, wztabledata\LeftEdge + sx + 1, wztabledata\TopEdge+zeilenhoehe,2
        EndIf
      EndIf
    Next x
    SetSoftStyle_ DrPort,0,AskSoftStyle_(DrPort)
    WJam 1
    If wztabledata\vlines = False Then linesh.l = zeilenhoehe+ 1 Else linesh = wztabledata\Height
    sx = wztabledata\breite[1]
    For x.l = 2 To wztabledata\spalten
      If wztabledata\breite[x]>0
        sbreite = wztabledata\breite[x]
        !SetDrMd{*tablewin\RPort,%0101010101010101}                   ;+ zeilenhoehe
        DrLine wztabledata\LeftEdge + sx    , wztabledata\TopEdge + zeilenhoehe, wztabledata\LeftEdge + sx    , wztabledata\TopEdge+linesh - 2,1
        !SetDrMd{*tablewin\RPort,-1}
        sx + sbreite
      EndIf
    Next x

    wztabledata\is_open = True
  EndIf
End Statement





Statement WZ_HighlightRow{gadgetid$,zeile.w}
 SHARED wztabledata,wzrow()
 DEFTYPE.w sx,sbreite

  *bgad.Gadget = WZGadAddr(gadgetid$)
  If *bgad> 0
    Use Window wztabledata\window_
    wx.l = wztabledata\LeftEdge
    wy.l = wztabledata\TopEdge
    ww.l = wztabledata\Width
    wh.l = wztabledata\Height
    gh.l = wztabledata\columnheight

    *tablewin.Window = WZWindowAddr
    DrPort *tablewin\RPort

    zeile = zeile - (wztabledata\erste_zeile-1)
    If (zeile > 0) AND (zeile <= wztabledata\zeilen) AND (zeile<=wztabledata\maxzeilen) AND (wztabledata\readonly = False)
      gy.q = WZYFontsize + (zeile-1) * gh

      DrBoxf wx,wy + gy + 1 ,wx + ww,wy+gy + gh-1,wztabledata\Highlight

      If wztabledata\vlines = True
        sx  = wztabledata\breite[1]
        For j.l = 2 To wztabledata\spalten
          If wztabledata\breite[j]>0
            sbreite = wztabledata\breite[j]
            !SetDrMd{*tablewin\RPort,%0101010101010101}
            DrLine wx + sx  ,wy + gy, wx + sx  ,wy + gy + gh,1
;            DrLine wx + sx+1,wy + gy, wx + sx+1,wy + gy + gh,2
            !SetDrMd{*tablewin\RPort,-1}
            sx + sbreite
          EndIf
        Next j
      EndIf

      wy + WZYFontsize + 2 ; direkt unter der Titelzeile anfangen
      ResetList wzrow()
      While NextItemFast(wzrow())
        If (Index(wzrow())) = (wztabledata\erste_zeile + zeile)
          !WZ_DrawRow
          Pop While : Goto uquit
        EndIf
      Wend

    uquit:
    EndIf
  EndIf
End Statement
 



Statement WZ_UpdateTable{gadgetid$}
SHARED wztabledata,wzrow()

  SetActualTable{gadgetid$} : Use Window wztabledata\window_

  *g.Gadget = WZGadAddr(gadgetid$)
  If (*g <> 0) ;AND (Index(wzrow())>0)
    *tablewin.Window = WZWindowAddr : DrPort *tablewin\RPort

    WZPrint gadgetid$+"_SCROLLER",wztabledata\erste_zeile - 1,wztabledata\zeilen  ; ,wztabledata\maxzeilen-1
    If wztabledata\maxzeilen = 0
      dummy.b = SetGadgetAttrsA_(WZGadAddr(gadgetid$+"_SCROLLER"),WZWindowAddr,0,Tags(#WSCROLLERA_Total,1))
    Else
      dummy = SetGadgetAttrsA_(WZGadAddr(gadgetid$+"_SCROLLER"),WZWindowAddr,0,Tags(#WSCROLLERA_Total,wztabledata\maxzeilen))
    EndIf

    DrBoxf wztabledata\LeftEdge,wztabledata\TopEdge + WZYFontsize + 1,wztabledata\LeftEdge + wztabledata\Width-1,wztabledata\TopEdge+wztabledata\Height-2, wztabledata\BackPen

    hline_color.l = 1 ; GetBestPen{ GetRGBValue{wztabledata\BackPen} * 2 }
    If wztabledata\hlines = True
      For y.w = 1 To wztabledata\zeilen
        !SetDrMd{*tablewin\RPort,%0101010101010101}
        DrLine wztabledata\LeftEdge, wztabledata\TopEdge + WZYFontsize + y * wztabledata\columnheight, wztabledata\LeftEdge+wztabledata\Width,wztabledata\TopEdge+WZYFontsize + y*wztabledata\columnheight,hline_color
        !SetDrMd{*tablewin\RPort,-1}
      Next y
    EndIf
    If wztabledata\vlines = True
      sx.w = wztabledata\breite[1]
      For x.l = 2 To wztabledata\spalten
        If wztabledata\breite[x]>0
          sbreite.w = wztabledata\breite[x]
       !SetDrMd{*tablewin\RPort,%0101010101010101}
          DrLine wztabledata\LeftEdge + sx    , wztabledata\TopEdge, wztabledata\LeftEdge + sx    , wztabledata\TopEdge+wztabledata\Height-1,1
;          DrLine wztabledata\LeftEdge + sx + 1, wztabledata\TopEdge, wztabledata\LeftEdge + sx + 1, wztabledata\TopEdge+wztabledata\Height-1,2
      !SetDrMd{*tablewin\RPort,-1}
          sx + sbreite
        EndIf
      Next x
    EndIf

    ; bis zum darstellbaren Bereich gehen
    ResetList wzrow()
    Repeat
      dummy = NextItemFast(wzrow())
    Until (Index(wzrow())-1 = wztabledata\erste_zeile) OR (dummy = False)

    ; Darstellbaren Bereich der Tabelle malen
    zeile.w = 1
    Repeat
      sx = 0
      !WZ_DrawRow
      If zeile+wztabledata\erste_zeile-1 = wztabledata\aktuelle_zeile
        PushItem wzrow()
        WZ_HighlightRow{gadgetid$,zeile+wztabledata\erste_zeile-1}
        PopItem wzrow()
      EndIf
      zeile + 1
      dummy.b = NextItemFast(wzrow())
    Until (zeile > wztabledata\zeilen) OR (dummy = False)

  EndIf
End Statement







Statement WZ_EditCell{gadgetid$,zeile.l,spalte.l}
SHARED wztabledata,wzrow()

  If (zeile>0) AND (zeile<=wztabledata\maxzeilen) AND (NOT wztabledata\readonly);  AND (NOT wztabledata\edit_)
    *bgad.Gadget = WZGadAddr(gadgetid$)
    If *bgad > 0
      Use Window wztabledata\window_
      DrPort RastPort(wztabledata\window_)
      wx.l = wztabledata\LeftEdge
      wy.l = wztabledata\TopEdge
      ww.l = wztabledata\Width
      wh.l = wztabledata\Height
      gh.l = wztabledata\columnheight
      id.l = wztabledata\GadgetID

      If (zeile > 0)
        For j.l = 1 To spalte - 1
          sx.w + wztabledata\breite[j]
        Next j
        gn$ = WZ_GetCell{gadgetid$,zeile,spalte}
        breite.l = ww / wztabledata\spalten
        wypos.l  = wy + WZYFontsize + gh * (zeile-wztabledata\erste_zeile)
        gapx.l   = -2
        *gad.Gadget = GTString(wztabledata\GTListID,0,wx + sx + gapx, wypos ,wztabledata\breite[spalte]+6,gh+1,"",0,64,gn$)
        If *gad<>0
          *gad\GadgetRender = False
          AttachGTList wztabledata\GTListID,wztabledata\window_
          ; WorkAround fuer MorphOS, damit der GadgetBorder wieder gelvscht wird
          If (KickVersion > 40)
            DrBoxf wx + sx + 2, wypos+1,wztabledata\breite[spalte]+wx+sx - 1,wypos + gh-1,wztabledata\BackPen
          EndIf
          GTActivateGadget wztabledata\GTListID,0
          wztabledata\edit_ = True
          wztabledata\aktuelle_spalte = spalte
          wztabledata\aktuelle_zeile  = zeile
        EndIf
      EndIf
    EndIf
  EndIf
End Statement


Statement WZ_TableSort{gadgetid$,column.w}
SHARED wztabledata, wzrow()
  SetActualTable{gadgetid$}

  StringSort wzrow(),SizeOf.wzrow,6 + column*4
;  If FirstItem(wzrow())
;    Repeat
;      dummy = NextItemFast(wzrow())
;      !cout{wzrow\spalte[column]}
;    Until NOT NextItemFast(wzrow())
;  EndIf
End Statement



Function.l WZ_CheckTableEvent{ev.l,@ev_win.l}
SHARED wztabledata,wzrow(),wzold_row

  If ev_win = -1 Then ev_win = EventWindow
  If ev_win<0 Then Function Return 0
  Use Window ev_win
  ; patch fuer AB2/elmorelib, um WZ_Tools auch in AB2 verwenden zu koennen
  CNIF @#WZ_singletable = 0
    found.b = False
    If (EventWindow <> wztabledata\window_) AND (ev<>#IDCMP_GADGETHELP)
      ChDir "ram:T" : found = False
      While (MoreEntries = True) AND (found = False)
        gadgetid$ = EntryName$
        If Right$(gadgetid$,8) = ".content"
          gadgetid$ = StrChg(gadgetid$,".content","")
          SetActualTable{gadgetid$}
          If EventWindow = wztabledata\window_ Then found = True
        EndIf
      Wend
    Else
      found.b = True
      gadgetid$ = wztabledata\id
    EndIf
  CELSE
    If (EventWindow = wztabledata\window_)  AND (ev<>#IDCMP_GADGETHELP)
      found.b = True
      gadgetid$ = wztabledata\id
    EndIf
  CEND

  If found AND (wztabledata\window_>0)
    mb.l = MButtons
    Select ev
    Case #IDCMP_NEWSIZE
      WZ_DrawTable{wztabledata\id}
      WZ_UpdateTable{wztabledata\id}
;      If wztabledata\aktuelle_zeile > 0
;        WZ_HighlightRow{gadgetid$,wztabledata\erste_zeile + wztabledata\aktuelle_zeile - 1}
;      EndIf
      Function Return ev
    Case #IDCMP_RAWKEY
        *w.Window = WZWindowAddr
        v.w = *w\MessageKey\Code
        v2.w = *w\MessageKey\Qualifier + 32768
        If (v2 = #IEQUALIFIER_LSHIFT) OR (v2 = #IEQUALIFIER_RSHIFT) Then shift.b = True
;        DefaultOutput
;        NPrint Hex$(v2)
        row.w = wztabledata\aktuelle_zeile
        col.w = wztabledata\aktuelle_spalte
        zei.w = wztabledata\erste_zeile
        Select v
        Case #CURSORUP
          If NOT shift
            If row > (wztabledata\erste_zeile)
              row - 1
            Else
              If wztabledata\erste_zeile > 1
                wztabledata\erste_zeile - 1
                row - 1
              EndIf
            EndIf
          Else
            wztabledata\erste_zeile = 1
            row = 1
          EndIf
        ;  WZ_UpdateTable{gadgetid$}
        ;  wztabledata\aktuelle_zeile = row
        ;  wztabledata\aktuelle_spalte = col
        ;  WZ_HighlightRow{gadgetid$,wztabledata\aktuelle_zeile}
        ;  Function Return ev
        Case #CURSORDOWN
          If NOT shift
            !WZ_VerifyVisibility{row}
          Else
            wztabledata\erste_zeile = wztabledata\maxzeilen - wztabledata\zeilen + 1
            row = wztabledata\maxzeilen
          EndIf
        End Select
        If (wztabledata\aktuelle_zeile <> row) OR (wztabledata\aktuelle_spalte <> col) OR (wztabledata\erste_zeile <> zei)
          WZ_SetActiveRow{gadgetid$,row}
          WZ_SetActiveColumn{gadgetid$,col}
          WZ_UpdateTable{gadgetid$}
          Function Return #WZTABLEEVENT_CELLSELECTED
        EndIf

    Case #IDCMP_VANILLAKEY
      row.w = wztabledata\aktuelle_zeile
      col.w= wztabledata\aktuelle_spalte
      zei.w = wztabledata\erste_zeile

      tabkey$ = Chr$(EventCode)
      ResetList wzrow()
      While NextItemFast(wzrow()) AND Index(wzrow())-1<wztabledata\aktuelle_zeile
      Wend
      While NextItemFast(wzrow())
        r$ = wzrow()\cell[1]
        If Left$(r$,1) = tabkey$
          row = Index(wzrow()) - 1
          If row - wztabledata\erste_zeile => wztabledata\zeilen
            wztabledata\erste_zeile = row - wztabledata\zeilen + 1
          EndIf
          Goto exit_vanilla
        EndIf
      Wend
      exit_vanilla:
      If (wztabledata\aktuelle_zeile <> row) OR (wztabledata\aktuelle_spalte <> col) OR (wztabledata\erste_zeile <> zei)
        WZ_SetActiveRow{gadgetid$,row}
        WZ_SetActiveColumn{gadgetid$,col}
        WZ_UpdateTable{gadgetid$}
        Function Return #WZTABLEEVENT_CELLSELECTED
      EndIf
 


    Case #IDCMP_IDCMPUPDATE
      If (WZGadHit<>-1) AND (WZGadHit<>255) AND (ev<>#IDCMP_GADGETHELP)
        If WZGadName = gadgetid$ + "_SCROLLER"
          WZ_EditExit{gadgetid$}
          Repeat
            ev2.l = Wait : VWait
          Until (ev2 <> #IDCMP_DELTAMOVE) AND (ev2<>#IDCMP_MOUSEMOVE)
          FlushEvents

          ; Workaround: WZInput liefert ab und an riesiger Werte zur|ck
          If WZInput <= wztabledata\maxzeilen
            If (WZInput + 1) <>  wztabledata\erste_zeile Then wztabledata\erste_zeile = WZInput + 1
            WZ_SetActiveRow{gadgetid$,wztabledata\erste_zeile}
            WZ_UpdateTable{gadgetid$}
;            WZ_HighlightRow{gadgetid$,wztabledata\aktuelle_zeile}
            Function Return #WZTABLEEVENT_CELLSELECTED
          EndIf
        Else
          ; EditExit, falls waehrend der Editierung Editieren deaktivert wird
          If wztabledata\edit_ = True
            For i.l = 1 To wztabledata\spalten
              j.l + wztabledata\editable_[i]
            Next i
            If j = 0
              WZ_EditExit{gadgetid$}
              WZ_UpdateTable{gadgetid$}
;              WZ_HighlightRow{gadgetid$,wztabledata\aktuelle_zeile}
              Function Return #WZTABLEEVENT_CELLSELECTED
            EndIf
          EndIf
        EndIf
      EndIf
    Case #IDCMP_GADGETUP ; pruefen welches Ereignis das GTString beendet hat: TAB oder ENTER, ..
      If (GadgetHit = 0) AND (ev<>#IDCMP_GADGETHELP)    ; GTString-gadget
        WZ_EditExit{gadgetid$}
        *w.Window = WZWindowAddr
        v.w = *w\MessageKey\Code
        w.w = *w\MessageKey\Qualifier
        row = wztabledata\aktuelle_zeile
        col = wztabledata\aktuelle_spalte

        Select v
        Case $9 ; TAB
          found = False
          Repeat
            Repeat
              col + 1
            Until (wztabledata\editable_[col] = True) OR (col>wztabledata\spalten)

            If (wztabledata\editable_[col] = False) OR (col>wztabledata\spalten)
              If col => wztabledata\spalten
                If row = wztabledata\zeilen
                  If row = wztabledata\maxzeilen
                    row = 1
                    col = 0
                    wztabledata\erste_zeile = 1
                  Else
                    col = 0
                    wztabledata\erste_zeile + 1
                  EndIf
                Else
                  If row = wztabledata\maxzeilen
                    row = 1
                    col = 0
                    wztabledata\erste_zeile = 1
                  Else
                    row + 1
                    col = 0
                  EndIf
                EndIf
              EndIf
            Else
              found = True
            EndIf
          Until found = True

          WZ_UpdateTable{gadgetid$}
          wztabledata\aktuelle_zeile = row
          wztabledata\aktuelle_spalte = col
;          WZ_HighlightRow{gadgetid$,row}
;          If wztabledata\editable_[col] = True Then WZ_EditCell{gadgetid$,row, col}
        Default
          WZ_UpdateTable{gadgetid$}
          wztabledata\aktuelle_zeile = 0;row
          wztabledata\aktuelle_spalte = 0;col
        End Select
        Function Return #WZTABLEEVENT_CELLSELECTED
      EndIf

    Case #IDCMP_MOUSEBUTTONS
;        Use Window wztabledata\window_
      mx.w = WMouseX : my.w = WMouseY
      row = WZ_MouseRow{gadgetid$,mx,my}
      column.w = WZ_MouseColumn{gadgetid$,mx,my}
      If (row > 0) AND (column>0) AND (row <= wztabledata\maxzeilen)

        If wztabledata\edit_=True
;          WZ_EditExit{gadgetid$}
          wztabledata\edit_ = False
          DetachGTList wztabledata\GTListID
          Free GTList wztabledata\GTListID
        EndIf
        If (wztabledata\aktuelle_spalte<>column) OR (wztabledata\aktuelle_zeile<>row)
          WZ_SetActiveRow{gadgetid$,row}
          WZ_SetActiveColumn{gadgetid$,column}
          WZ_UpdateTable{gadgetid$}


          If wztabledata\editable_[column] = True
            WZ_EditCell{gadgetid$,row,column}
          EndIf
          FlushEvents
          ;Function Return ev
        Else

          Select mb
          Case 6 ; Right, up
            If NOT wztabledata\editable_[column]
              If row = wztabledata\aktuelle_zeile
                WZ_EditExit{gadgetid$}
                a.b = WZ_PopUp{SMouseX-4,SMouseY-8}
                If a = 0
                  wztabledata\selected_popup = 0
                  Function Return False
                Else
                  wztabledata\selected_popup = a
                  Function Return #WZTABLEEVENT_POPUPMENU
                EndIf
              Else
                Function Return False
              EndIf
            EndIf
          Default
            If wztabledata\editable_[column] Then WZ_EditExit{gadgetid$}
          End Select
        EndIf

        If EventDoubleclick
          If wzold_row = row
            Function Return #WZTABLEEVENT_DOUBLECLICK
          EndIf
        Else
          If row < > 0 Then wzold_row = row
          Function Return #WZTABLEEVENT_CELLSELECTED
        EndIf

      Else
        If (row = 0) AND (wztabledata\sortable = True)
          wztabledata\sorted_by = column
          WZ_TableSort{gadgetid$,column}
          WZ_DrawTable{gadgetid$}
          WZ_UpdateTable{gadgetid$}
        EndIf
      EndIf
    End Select
  EndIf
  Function Return False
End Statement



CNIF #__include = 0
optimize 5                 ; added  for testing tomsmart1
Syntax 6                   ; added  for testing tomsmart1

!WZ_CheckLibrary
;!WZ_CheckLibraryRT       ; not needed annymore reqtools are replace with error.include tomsmart1
WBStartup :; NoCli
WbToScreen 0 : Use Screen 0
screen_Open{"",-1}
WZLoadGUI ?wzgui

;Startup_Open{"blitz2:quelltexte/proBanking/probanking.logo"}
;Startup_Print{"Erstelle Systemumgebung."}
;VWait 100
;Startup_Close{}
;End
;



;msg$ = "Kickversion: "+ Str$(KickVersion)+Chr$(10)
;dummy = RTEZRequest("SysInfo",msg$,"_Ok")



;WZ_ShowMessage{"Los gehts !"}
;For i = 1 To 100
;  !WZ_Update_Gauge{i,100}
;Next i
;WZ_HideMessage{}
;MouseWait
;End


;Oeffnen des Fensters aus der Wizard-GUI, zentriert
WZWindow WZID("WIN_TABELLE"),?wzgui,64,ScreenWidth/4,ScreenHeight/4,ScreenWidth/2,ScreenHeight/2,WZID("WIN_TABELLE")

;t.b = WZ_Request{"REQ_TEST"}
; Der in der WZ-GUI eingestellte Font wird als IntuiFont gesetzt
WZ_SetFont{"WIN_TABELLE"}

; Initialisieren einer Tabelle fuer den Platzhalter "TABELLE" der WZ-GUI
; im Fenster "WIN_TABELLE" mit 6 Spalten.
; Sortierreihenfolge: 0 normal, 1 rueckwaerts
WZ_InitTable{"WIN_TABELLE","TABELLE",5,0}
;wztabledata\scale_images = On
; Textausrichtung der Spalte
WZ_SetTableAlign{"TABELLE",#ALIGN_LEFT,#ALIGN_CENTER,#ALIGN_RIGHT,#ALIGN_RIGHT,#ALIGN_LEFT}

; Trennlinien ausschalten
WZ_SetTableLines{"TABELLE",On,On}

; Setzen der Farben:
; Vordergrundfarbe 1
; Hintergrundfarbe 0
; Titelvordergrund
; Titelhintergrund
; Auswahlleiste
;WZ_SetTableColors{"TABELLE",2,4,1,5,6}

; Setzen der Spaltentitel fuer die erste Zeile
WZ_SetTableTitle{"TABELLE","Name","Art","Gre","Bits","Kommentar"}

; Legt die Prioritaet der 6 Spalten fest
WZ_SetPriority{"TABELLE",3,1,1,2,2}

; Setzt die zweite Spalte der Tabelle "TABELLE" auf nicht editierbar
WZ_SetEditable{"TABELLE",True,False,False,False,False,False}

; Setzt die Tabelle auf nur lesbar, auch nicht anklickbar
;WZ_SetTableReadOnly{"TABELLE",True}


; Setzt fuer die zweite Spalte ein Image als Inhalt fest
; Standardmaessig wird #WNE_TEXT als Inhalt gesetzt
WZ_SetRowType{"TABELLE",#WNE_TEXT,#WNE_IMAGE}

; Laedt zwei Images ein, die der Tabelle "TABELLE" zugeordnet werden
WZ_AddImage{"TABELLE","Dir" ,"sys:programme/probonds/system/gfx/pfeilhoch.iff"};"ram:env/sys/def_drawer"}
WZ_AddImage{"TABELLE","File","sys:programme/probonds/system/gfx/pfeilrunter.iff"};"ram:env/sys/def_ascii"}



; Fuegt Zeilen an die Tabelle "TABELLE" an
ChDir "sys:" : a.l = 0
While MoreEntries
  a + 1
  If EntryDIR Then d$ ="Dir" Else d$ = "File"
  WZ_AddRow{"TABELLE",EntryName$,d$,Str$(EntrySize),EntryBits$,"####"};EntryComment$}
Wend
;WZ_ImageScaleOn{"TABELLE"}
; Malt die leere Tabelle in das WZGadget "TABELLE"
WZ_DrawTable{"TABELLE"}
; Fuellt die Tabelle mit den Werten, die mit WZAddRow{} erstellt wurden
WZ_UpdateTable{"TABELLE"}
;erstellt die Menueintraege f|r das zeilenabhaengige popupmenu
;wird die zeile weggelassen, ist das menu deaktiviert...
; das Menu kann zur Laufzeit geaendert werden
WZ_SetPopUpMenu{"Testmenu"+Chr$(10)+"zeile1"+Chr$(10)+"zeile2"}

exit.b = False
Repeat
  ev.l = WaitEvent
  ; schliesst die evtl. geoeffnete HilfeBubble
  If (ev<>#IDCMP_INTUITICKS) AND (ev<>#IDCMP_ACTIVEWINDOW) Then WZ_HideHelp{}
  Select ev
    Case #IDCMP_CLOSEWINDOW
      Select EventWindow

        Case WZID("WIN_TABELLE")
          exit = True

        Case WZID("WIN_TABELLE2")
          WZ_KillTable{"TABELLE2"}
          WZCloseWindow WZID("WIN_TABELLE2")
          WZ_UnlockWindow{"WIN_TABELLE"}
          tabelle_offen.b = False

      End Select

    Case #IDCMP_GADGETHELP
      WZ_ShowHelp{}

    Case #IDCMP_IDCMPUPDATE
      Use Window EventWindow
      Select EventWindow

        Case WZID("WIN_TABELLE")
          Select WZGadName

            Case "BUTTON_TABELLE2"
              If tabelle_offen = False
                WZ_LockWindow{"WIN_TABELLE"}
                WZWindow WZID("WIN_TABELLE2"),?wzgui,64,-1,-1,-1,-1,WZID("WIN_TABELLE2")
                WZ_InitTable{"WIN_TABELLE2","TABELLE2",2,1}
                ; Fuegt Zeilen an die Tabelle "TABELLE2" an
      ;          WZ_SetTableColors{"TABELLE2",1,9,1,8,0}
                WZ_SetTableTitle{"TABELLE2","Zahl","Zufall"}
                WZ_SetPriority{"TABELLE2",1,3}
                WZ_SetTableReadOnly{"TABELLE2",False}
                WZ_SetTableLines{"TABELLE2",Off,Off}
                WZ_SetTableAlign{"TABELLE2",#ALIGN_CENTER,#ALIGN_CENTER}
                For a = 1 To 9
                  zufall$ =""
                  For b.w = 1 To 9
                    zufall$ + Str$(Chr$(64+Rnd(20)))
                  Next b
                  WZ_AddRow{"TABELLE2",Str$(a),zufall$}
                Next a

                WZ_DrawTable{"TABELLE2"}
                WZ_UpdateTable{"TABELLE2"}
                tabelle_offen = True
              Else
                tabelle_offen = False
                WZ_KillTable{"TABELLE2"}
                WZCloseWindow WZID("WIN_TABELLE2")
                WZ_UnlockWindow{"WIN_TABELLE"}
              EndIf

          End Select

      End Select

  End Select

  Select WZ_CheckTableEvent{ev}

    Case #WZTABLEEVENT_DOUBLECLICK
      x.w = WZ_Row{wztabledata\id}
      y.w = WZ_Column{wztabledata\id}
      !Dialog{"Selected via doubleclick: "+Str$(x)+","+Str$(y)}

    Case #WZTABLEEVENT_CELLSELECTED
      x.w = WZ_Row{wztabledata\id}
      y.w = WZ_Column{wztabledata\id}
      If (x>0) AND (y>0)
        z$ = wztabledata\id+": Zelle "+Str$(x)+","+Str$(y)+":"+WZ_GetCell{wztabledata\id,x,y} + "___" + WZ_GetCell{wztabledata\id,x,2}
        WZ_SetPopUpMenu{wztabledata\id+"\\n Zeile "+Str$(x)+" \\n Spalte "+Str$(y)+"\\nsfsf\\nsfsf\\nsfsf\\nsfsf\\nsfsf\\ndfgdg\\ndfdfg\\n dfgdfg   "}
      Else
        If x <> ox.w
          z$ = "Zeile: "+Str$(x)
        Else
          z$ = "keine Zelle markiert"
        EndIf
      EndIf
      ox.w = x
      Use Window WZID("WIN_TABELLE")
      WZPrint "TABELLE_STATUS",&z$

    Case #WZTABLEEVENT_POPUPMENU
      ; hier je nach auswahl weiter...
      z$ = "gewhlter Eintrag: " + Str$(wztabledata\selected_popup)
      WZPrint "TABELLE_STATUS",&z$

  End Select
Until exit= True



WZ_HideHelp{}
; Loescht alle Eintraege der Tabelle
WZ_KillTable{"TABELLE"}
WZ_KillTable{"TABELLE2"}

WZCloseWindow WZID("WIN_TABELLE2")
WZCloseWindow WZID("WIN_TABELLE")
End

Goto wzguiEnd:

wzgui:
IncBin "blitz3:sourcecodes/includes/PE/wizard_Tools.include.wizard"
wzguiEnd:
CEND

