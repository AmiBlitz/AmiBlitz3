; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Ram Disk:"
; ExeFile         = "test"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 20
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 16
; CursorColumn    = 1
; LabelSearch     = "gui"
; LabelRemark     = 0
; LabelAll        = 1
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 15
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 20
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 30
; /XTRA
; +---------------------------------------+
; | Wizard_Tools.include                  |
; +---------------------------------------+

; Functionapplications:
;
; - Show/Hide Messages & Gauge
; - Show/Hide Bubblehelp
; - WZ_Popup_Date
; - WZ_Popup_Menu
; - SetFont for WZ-windows
; - WZ_GetLocaleString

; converted and activate untokenized and deactivated code to make PED Bubbel help work again  tomsmart1 2013 02
; make the code Syntax 6 compatible  tomsmart1 2013 02
;optimize 5              ; added for testing only and deactived it because else it override the mainsource optimize stettings  tomsmart1
;Syntax 6                ; added for testing only and deactived it because else it override the mainsource syntax stettings  tomsmart1




#WZ_TOOLS_VERSION = 11
#WZHELP_BACKGROUND = $EEEEEE
; check if include was compiled with enough space for used objects
;If (Maximum Window) < 25
;  dummy.l = RTEZRequest("","Object Maximums too small\\nIncrease Objectsize for Windows to >25","Exit")
;End
;EndIf
XINCLUDE "screen.include.bb2"
XINCLUDE "PE/PE_Tools.include.ab3"
;optimize 5              ; added for testing only and deactived it because else it override the mainsource optimize stettings  tomsmart1
;Syntax 6                ; changed to 6 for testing only and deactived it because else it override the mainsource syntax stettings  tomsmart1



NEWTYPE.popupdata
  entry.l
  selected_entry.l
End NEWTYPE

SHARED popupliste.List
SHARED popupdata.popupdata
SHARED wzbubblebackground.l


; Newtypes zur Verwendung der Hierarchy-Listviews
NEWTYPE.childstruct
  _handle.l
  name.s
  _list.List
  parent.childstruct
End NEWTYPE

NEWTYPE.parentstruct
  _handle.l
  name.s
  childlist.List
End NEWTYPE
Dim List parent.parentstruct(0)

Statement HIERARCHY_Clear{liste.l}
SHARED parent()
  ResetList parent()
  While LastItem(parent())
    WZListRemove parent()\childlist
    KillItem parent()
  Wend
  If LastItem(parent())
    Request "","List","Ok"
  EndIf
  WZListRemove liste
End Statement

Function.b HIERARCHY_AddParent{liste.l,p$,@gruppe.l}
SHARED parent()
  If AddLast(parent())
    WZListRemove parent()\childlist
    parent()\_handle = WZListAddTree(liste,p$,0,-1,parent()\childlist,gruppe)
    parent()\name = p$
  EndIf
End Function

Function.l HIERARCHY_GetParentID{main$}
SHARED parent()
  ResetList parent()
  While NextItem(parent())
    If parent()\name = main$ Then Function Return parent()\_handle
  Wend
End Function

Function.b HIERARCHY_AddChild{parenthandle.l,child$,@gruppe.l}
SHARED parent()
  ResetList parent()
  While NextItem(parent())
    If parent()\_handle = parenthandle Then WZListAddTree parent()\childlist,child$,parent()\_handle,-1,0,gruppe
  Wend
End Function




Macro WZ_CheckLibrary
  If Exists("libs:wizard.library")=0
    dummy = RTEZRequest("","wizard.library wird benötigt.","_Ok")
    End
  EndIf
End Macro

Macro WZ_CheckLibraryRT
  If NOT IsReqToolsActive
    dummy = Request("","reqtools.library wird benötigt.","_Ok")
    End
  EndIf
End Macro


; prueft, ob das angegebene Fenster bereits geoeffnet ist
Function.b WZ_CheckOpen{w$}
CNIF @#USE_WIZARD <> 0
  If Peek.l(Addr Window(WZID(w$))) = 0 Then Function Return False Else Function Return True
CEND
End Function
 


Statement WZ_SetFont{winid$,@Style.b}
 *win.Window = Peek.l(Addr Window( WZID(winid$) ) )
 If (*win <> 0)
   Use Window WZID(winid$)
   *han.WizardWindowHandle = WZHandlenocheck
   If (*han <> 0)
     ;*scr.Screen = Peek.l(Addr Screen(0))
     foname$ = Peek.s(*han\DrawInfo\dri_Font\tf_Message\mn_Node\ln_Name)
     fosize.w = WZYFontsize
     ;foname$ = Peek.s(*scr\Font\ta_Name)
     ;fosize.w = *scr\Font\ta_YSize
   Else
    *scr.Screen = Peek.l(Addr Screen(0))
    foname$ = Peek.s(*scr\Font\ta_Name)
    fosize.w = *scr\Font\ta_YSize
   EndIf

   If Exists("fonts:"+ fonname$)
     LoadFont 0,foname$,fosize
     If Style=-1 Then Style = 0
     WindowFont 0,Style
   EndIf
 EndIf
End Statement


Statement WZ_SetPopUpMenu{menu$,@sorted.b}
 entries.l = 0
 WZListRemove popupliste
 While (menu$<>"") AND (menu$<>Chr$(10))
   z.l = 0 : quit.b = 0
   While quit = 0
     z + 1
     If (z=Len(menu$)) OR (Mid$(menu$,z,1)=Chr$(10)) Then quit = 1
   Wend
   If z > 1
     entries + 1
     entry$ = StrPack(Left$(menu$,z),Chr$(10))
     ;search.b = FindStrg("%%",entry$)                  ; converted back from '????Lib 125/2("%%",entry$)'  tomsmart1
     search.l = Instr(entry$,"%%")
     If search > 0
       Select Mid$(entry$,search + 1,1)
       Case "5"
         WZTags #WENTRYA_TextPen,screen_GetPen{$EE,$EE,$EE},#WENTRYA_TextStyle,#FSF_TAGGED
       Case "4"
         WZTags #WENTRYA_TextPen,screen_GetPen{$00,$00,$AA}
       Case "2"
         WZTags #WENTRYA_TextPen,screen_GetPen{$AA,$00,$00}
       Case "1"
         WZTags #WENTRYA_TextPen,screen_GetPen{$00,$AA,$00}
       Default
         WZTags #WENTRYA_TextStyle,#FSF_BOLD
       End Select
       entry$ = Right$(entry$,Len(entry$)-3)
     EndIf

     If sorted = -1
       WZListAdd popupliste, entry$,-2
     Else
       WZListAdd popupliste, entry$,-1
     EndIf
     menu$= Right$(menu$,Len(menu$)-z)
   EndIf
 Wend
End Statement

Function.b WZ_GetPopUpMenu{}
  Function Return popupdata\selected_entry
End Function
 

Function.s WZ_GetPopUpEntry{entry.l}
SHARED popupliste
 If (entry > -1) AND (entry<=WZListItems(popupliste))
   Function Return WZListString(popupliste,entry - 1,1)  ; achtung mode beachten
 Else
   Function Return ""
 EndIf
End Function

Statement WZ_SetPopUpEntry{entry.l}
SHARED popupdata
 If (entry > -1) AND (entry<WZListItems(popupliste))
   win_use.l = Used Window
   WZPrint "POPUP_PAGE",_page.b                                 ; set type to .b to be Syntax 6 compatible  tomsmart1
   WZPrint "POPUPMENU"+Str$(_page),entry,&popupliste
   popupdata\selected_entry = entry
   Use Window win_use
 EndIf
End Statement

Statement WZ_PopUp_Nonmodal{x.w,y.w,@w.w,@h.w}
  win_use.l = Used Window
  entries.w = WZListItems(popupliste)
  width.w = 0
  If entries > 0
    For i.w = 1 To entries
      entry$ = WZListString(popupliste,i-1,-1)
      width.w = Max(width,TextLength_(RastPort(WZID("WIN_LABELS")),entry$,FLen(entry$)))
    Next i
    height.w = (WZYFontsize+2) * entries + 2
    If w = -1 Then w = width + 8
    If (h = -1) OR (h > height)
      h = height
    EndIf

    mos_screenw.w = screen_GetWidth{}/1.5
    mos_screenh.w = screen_GetHeight{}/1.5
    If h > mos_screenh Then h = mos_screenh
    If h < 32 Then h = 32
    If w > mos_screenw Then w = mos_screenw
    If w < 32 Then w = 32
    If (x + w) > screen_GetWidth{} Then x = (screen_GetWidth{} - w)
    If (y + h) > screen_GetHeight{} Then y = (screen_GetHeight{} - h)
    If x < 0 Then x = 0
    If y < 0 Then y = 0

    If height > h
      _page.b = 0
    Else
      _page = 1
    EndIf

    If WZ_CheckOpen{"WIN_POPUP"}
      Use Window WZID("WIN_POPUP")
      If (h <> WindowHeight) OR (w<>WindowWidth)
        ChangeWindowBox_ WZWindowAddr,WindowX,WindowY,w,h
      EndIf
    Else
      WZWindow WZID("WIN_POPUP"),?wzgui,64,x,y,w,h,WZID("WIN_POPUP")
    EndIf
    ClearType popupdata
    WZPrint "POPUP_PAGE",_page
    WZPrint "POPUPMENU"+Str$(_page),0,&popupliste
  EndIf
End Statement

Function.l WZ_PopUp{x.w,y.w,@w.w,@h.w}
 entries.w = WZListItems(popupliste)
 width.l = 0
 If entries > 0
   For i.l = 1 To entries
     entry$ = WZListString(popupliste,i-1,-1)
     width.l = Max(width,(WZXFontsize+2) * Len(entry$))
   Next i
   height.l = (WZYFontsize+2) * entries + 2

   If w = -1 Then w = width + 2
   If (h = -1) OR (h > height)
     h = height
   EndIf
   If h<32 Then h= 32
   If x + w > screen_GetWidth{} Then x = screen_GetWidth{} - w
   If y + h > screen_GetHeight{} Then y = screen_GetHeight{} - h
   If x < 0 Then x = 0
   If y < 0 Then y = 0
   If height > h
     _page.b = 0
   Else
     _page = 1
   EndIf
   ;
   win_use.l = Used Window

   WZWindow WZID("WIN_POPUP"),?wzgui,64,x,y,w,h,WZID("WIN_POPUP")
   WZPrint "POPUP_PAGE",_page
   WZPrint "POPUPMENU"+Str$(_page),-1,&popupliste
   exit.l = 0 : selected.l = -1 : FlushEvents
   Repeat
     popev.l = WaitEvent
     If EventWindow = WZID("WIN_POPUP")
       Select popev
       Case #IDCMP_IDCMPUPDATE
         If WZGadName = "POPUPMENU" + Str$(_page)
           selected = WZInput + 1
           exit = True
         EndIf
       Case #IDCMP_MOUSEBUTTONS
         mb.b = MButtons
         If (mb = 1) OR (mb=2)
           FlushEvents
           exit = True
         EndIf
       End Select
     Else
       exit = True
     EndIf
   Until exit
   WZCloseWindow WZID("WIN_POPUP")
   If win_use<>-1 Then Use Window win_use
;    WZListRemove popupliste
   popupdata\selected_entry = selected
   Function Return selected
 EndIf
End Function



Function.l WZ_Date{x.w,y.w,@_date.l}
 DateFormat 0
 da$ = Date$(SystemDate)
 da2$ = StrChg(da$,"/",".")
 heute.l = DateAsLong{da2$}
 If _date  < 20000000 Then _date = heute
 win_use.l = Used Window
 WZWindow WZID("WIN_DATE"),?wzgui,64,x,y,-1,-1,WZID("WIN_DATE")
 WZPrint "DATE_TODAY",DateAsString{heute,#DATUM_TTMMJJJJ}
 WZPrint "DATE_DATESTRING",DateAsString{_date,#DATUM_TTMMJJJJ}
 da2$ = DateAsString{_date,#DATUM_TTMMJJJJ}
 tag.l = DateAsLong{da2$,#DATUM_DAYS}
 monat.l = DateAsLong{da2$,#DATUM_MONTHS}
 jahr.l = DateAsLong{da2$,#DATUM_YEARS}
 WZPrint "DATE_DATE",tag,monat,jahr
 exit.l = 0 : FlushEvents
 Repeat
   popev.l = WaitEvent
   If EventWindow = WZID("WIN_DATE")
     Select popev
     Case #IDCMP_IDCMPUPDATE
       Select WZGadName
       Case "DATE_DATE"
         tag = WZInput
         _date = DateAsLong{Str$(tag)+"."+Str$(monat)+"."+Str$(jahr)}
         WZPrint "DATE_DATESTRING",DateAsString{_date,#DATUM_TTMMJJJJ}
         exit = True
       Case "DATE_LEFT"
         monat - 1
         If monat = 0 Then jahr-1 : monat = 12 : tag = 1
         WZPrint "DATE_DATE",tag,monat,jahr
         _date = DateAsLong{Str$(tag)+"."+Str$(monat)+"."+Str$(jahr)}
         WZPrint "DATE_DATESTRING",DateAsString{_date,#DATUM_TTMMJJJJ}
       Case "DATE_RIGHT"
         monat + 1
         If monat = 13 Then jahr+1 : monat = 1: tag = 1
         WZPrint "DATE_DATE",tag,monat,jahr
         _date = DateAsLong{Str$(tag)+"."+Str$(monat)+"."+Str$(jahr)}
         WZPrint "DATE_DATESTRING",DateAsString{_date,#DATUM_TTMMJJJJ}
       End Select

     Case #IDCMP_MOUSEBUTTONS
       mb.b = MButtons
       If (mb = 5)
         FlushEvents
         exit = True
       EndIf
     End Select
   Else
     exit = True
   EndIf
 Until exit

 WZCloseWindow WZID("WIN_DATE")
 If win_use<>-1 Then Use Window win_use
 Function Return DateAsLong{Str$(tag)+"."+Str$(monat)+"."+Str$(jahr)}
End Function


Statement WZ_ShowHelp{}
  Dim hilfe$(7)
  ew.l = EventWindow
  Use Window ew
  *g.Gadget = EventiAddress
  If *g<>0
;    msg$= "ID: " + Str$(*g\GadgetID) + " "
;    msg$+ "GadgetPos: X:"+Str$(*g\LeftEdge)+" Y:"+Str$(*g\TopEdge)+" "
;    msg$+ "Hilfe: " + WZGadHelp
    If *g\GadgetID > 0
      t$ = WZGadHelp
      tlen.l = Len(t$)
      If tlen > 0
        x.l = SMouseX + 8
        y.l = SMouseY + 8
        If Peek.l(Addr Window(WZID("WIN_HELP")))>0 Then CloseWindow WZID("WIN_HELP")

        AddIDCMP #IDCMP_NEWSIZE|#IDCMP_INTUITICKS|#IDCMP_DELTAMOVE
        Window WZID("WIN_HELP"),0,0,1,1,#WFLG_BORDERLESS,"",0,1
        WZ_SetFont{"WIN_HELP"}
        Use Window WZID("WIN_HELP")
        *win.Window = Peek.l(Addr Window(WZID("WIN_HELP")))
        *scr.Screen = Peek.l(Addr Screen(0))
        DrPort *win\RPort                             ; activated and converted back from '????Lib 197/0 *win\RPort'  tomsmart1

        lines.l = 1 : longest.l = 1 : anz.l = 0
        found.b = True : tl.l = tlen
        While found = True
          p.l = FindStrg(Chr$(10),t$)                 ; activated and converted back from '????Lib 125/2(Chr$(10),t$)' tomsmart1
          If p > 0
            hilfe$(lines) = StrLeft(t$,p - 2)
            lines + 1
            t$ = StrRight(t$,tl - p + 1)
            tl - p + 1
          Else
            found = False
          EndIf
        Wend
        hilfe$(lines) = t$
        For i.l = 1 To lines
          breite.l = Max(DrTextLen(hilfe$(i)),breite)  ; activated and converted back from 'MAX(????Lib 197/7(hilfe$(i)),breite)'  tomsmart1
        Next i

        If (breite > 4)
          lgth.l = tlen
          ww.l = breite + 12
          wh.l = WZYFontsize * lines + 6

          If (x + ww) > *scr\Width  Then wx.w = *scr\Width  - ww Else wx = x   ; set type to .w to be Syntax 6 compatible  tomsmart1
          If (y + wh) > *scr\Height Then wy.w = *scr\Height - wh Else wy = y   ; set type to .w to be Syntax 6 compatible  tomsmart1
          If (wy < 0) Then wy = 0
          If (wx < 0) Then wx = 0
          If ww > *scr\Width  Then ww = *scr\Width
          If wh > *scr\Height Then wh = *scr\Height
          MoveWindow_ *win,wx,wy
          SizeWindow_ *win,ww,wh
          Repeat : Delay_ 2 : Until Event = #IDCMP_NEWSIZE
          FlushEvents

          If wzbubblehelpbackground.l = 0                  ; set type to .l  to make it Syntax 6 compatible  tomsmart1
            ;wzbubblehelpbackground = screen_GetPen{#WZHELP_BACKGROUND LSR 16,#WZHELP_BACKGROUND LSR 8,#WZHELP_BACKGROUND AND $FF}
            wzbubblehelpbackground = screen_GetPenRGB{#WZHELP_BACKGROUND}
            If wzbubblehelpbackground = 1 Then wzbubblehelpbackground = 0
            If wzbubblehelpbackground = 0 Then wzbubblehelpbackground = 2
          EndIf
          DrCls wzbubblehelpbackground                     ; activated and converted back from '????Lib 197/10 wzbubblehelpbackground '  tomsmart1
          DrMode 0                                         ; activated and converted back from '????Lib 197/12 0'  tomsmart1
          DrBox 0,0,ww,wh,1                                ; activated and converted back from '????Lib 197/2 0,0,ww,wh,1'  tomsmart1
          For i = 1 To lines
            DrText hilfe$(i), 6,3 + (i-1) * WZYFontsize,1  ; activated and converted back from '????Lib 197/6 hilfe$(i), 6,3 + (i-1) * WZYFontsize,1'  tomsmart1
          Next i
          Use Window ew
        EndIf
      EndIf
    EndIf
  EndIf
End Statement


Statement WZ_HideHelp{@test.l}
CNIF @#USE_WIZARD<>0
  helpwin_addr.l = Addr Window( WZID("WIN_HELP") )
;  !cout{helpwin_addr}
  If helpwin_addr
 ; !cout{"HideHelp: " + Hex$(helpwin_addr)}
    *win.Window = Peek.l(helpwin_addr)
    If (*win <> 0)
     CloseWindow WZID("WIN_HELP")
     Use Window EventWindow
    EndIf
  EndIf
CEND
End Statement


Macro WZ_Update_Gauge
CNIF @#USE_WIZARD <> 0
  If `2>0
    gzt.l = (`1 * 100) / `2
    ;If (gzt MOD 10) = 0
      If Peek.l(Addr Window( WZID("WIN_PROGRESS")) ) > 0
        ggt$ = Str$(gzt) + "%%"
        uw.l = Used Window
        Use Window WZID("WIN_PROGRESS")
        WZPrint "GAUGE",gzt,100,&ggt$
        Use Window uw
      EndIf
    ;EndIf
  EndIf
CEND
End Macro

Macro WZ_GaugeInfo
CNIF @#USE_WIZARD <> 0
  gaugewin_addr.l = Addr Window( WZID("WIN_PROGRESS"))
  If gaugewin_addr
    If Peek.l(gaugewin_addr ) > 0
      uw.l = Used Window
      Use Window WZID("WIN_PROGRESS")
      WZPrint WZID("GAUGE"),0,1,`1
      Use Window uw
    EndIf
  EndIf
CEND
End Macro


Statement WZ_ShowMessage{smt$,@mode.l}
CNIF @#USE_WIZARD <> 0
  win_use.l = Used Window                          ; set type to .l to make it Syntax 6 compatible  tomsmart1
  n$=""
  If mode = -1 Then mode = 1 Else mode = 0
  Use Window WZID("WIN_PROGRESS")
  If Peek.l(Addr Window(Used Window)) = 0
    WZWindow WZID("WIN_PROGRESS"),?wzgui,16,-2,-2,-2,-2,WZID("WIN_PROGRESS")  ; replace "gui with "wzgui"  tomsmart1
  EndIf
  Use Window WZID("WIN_PROGRESS")
  WZPrint "PROGRESS_PAGE",mode
;  WZTags #WA_TextStyle,#FSF_BOLD
  WZPrint "FORTSCHRITT"+Str$(mode),smt$
  WZPrint "GAUGE",0,100,&n$
  If win_use<>-1 Then Use Window win_use
CEND
End Statement

Statement WZ_HideMessage{}
CNIF @#USE_WIZARD <> 0
  win_use.l = Used Window                          ; set type to .l to make it Syntax 6 compatible  tomsmart1
  Use Window WZID("WIN_PROGRESS")
  If Peek.l(Addr Window(Used Window)) <> 0
    WZCloseWindow WZID("WIN_PROGRESS")
  EndIf
  If win_use<>-1 Then Use Window win_use
CEND
End Statement

Function.l WZ_Request{id$,@addon$}
  usedwin.l = Used Window
  If usedwin>-1 Then WZ_LockWindow_ WZHandle

  DEFTYPE.EasyStruct es
  DEFTYPE.l erg
  easy.l = WZ_InitEasyStruct_ (WZSurface,&es,WZID(id$),SizeOf.EasyStruct)
  If easy
    ;flgs.l = es\es_Flags
    t$   = Peek$(es\es_Title)
    msg$ = Peek$(es\es_TextFormat) + addon$
    gad$ = Peek$(es\es_GadgetFormat)
    erg =  RTEZRequest(t$,msg$,gad$)
  EndIf
  If usedwin>-1
    Use Window usedwin
    WZ_UnlockWindow_ WZHandle
  EndIf
  Function Return erg
End Function

Function.s WZ_GetLocaleString{id$}
  DEFTYPE.EasyStruct es
  DEFTYPE.l erg
  easy.l = WZ_InitEasyStruct_ (WZSurface,&es,WZID(id$),SizeOf.EasyStruct)
  If easy
    msg$ = Peek$(es\es_TextFormat)
    Function Return msg$
  EndIf
End Function

Function.s WZ_GetStringField{wzgadid$}
   straddr.l = WZInput(wzgadid$)
   If straddr<>0
     Function Return Peek$(straddr)
   Else
     Function Return ""
   EndIf
End Function


Statement WZ_LockWindow{id$}
  usedwin.l = Used Window
  Use Window WZID(id$)
  WZ_LockWindow_ WZHandle
  If usedwin<>-1 Then Use Window usedwin
End Statement

Statement WZ_UnlockWindow{id$}
  usedwin.l = Used Window
  Use Window WZID(id$)
  WZ_UnlockWindow_ WZHandle
  If usedwin<>-1 Then Use Window usedwin
End Statement


Function.s WZ_MenuName{}
  selmenu.l = 65536 - 32 + MenuHit
  selitem.l = 65536 - 2048 + (ItemHit*32)
  selsubi.l = 65536 - 65408 + (SubHit*32)
End Function
;

