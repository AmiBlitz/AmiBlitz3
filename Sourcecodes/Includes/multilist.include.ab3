; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "Ram Disk:"
; ExeFile         = "MLDemo"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 100000
; MakeSmallest    = 0
; FuncOptimize    = 0
; Version         = 0.0.0
; NumberOfBuilds  = 8
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 928
; CursorColumn    = 1
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 15
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 15
; Max BlitzFont   = 4
; Max GTList      = 15
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Date: 19/01/2007                                                            /
;/                                                                             /
;/ Name: multilist.include                                                     /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Author: Thilo Koehler                                                       /
;/                                                                             /
;/ Requirements:  Amiblitz2.4                                                  /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Provide multi-list functionality.                                           /
;/ The "multi-list" is actually very similar to a "tree".                      /
;/                                                                             /
;/ Abstract:                                                                   /
;/ A multi-list is a "normal" list, but each item can have another multi-lis:: /
;/ t atached.                                                                  /
;/ This is the most common way to represent a file directory structure. This:: /
;/  is why this include has some special functions for file handling and a f:: /
;/ unction to draw the multi list, which is used in tui.include.               /
;/ Each node can have a label string and a user string, and a user value.      /
;/ The user value could be used to store ID numbers or a pointer to more dat:: /
;/ a belonging to the node. The structure is not very flexible, but ideal fo:: /
;/ r tree-views on data like file systems.                                     /
;/                                                                             /
;/ User Constants:  none                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
#node_simple  = 1
#node_invalid = 0
#node_tree    = 2


CNIF #__include=0
Syntax 2
optimize 5
CEND

XINCLUDE "error.include.ab3"
XINCLUDE "strptr.include.ab3"


NEWTYPE.ml_node
*next_node.ml_node
*prev_node.ml_node
*parent_node.ml_node
*child_node.ml_node
expanded.b
typ.b
active.b
dummy.b
label_text.l
user_data.l
user_text.l
End NEWTYPE

#MAX_MLTEMPSTRING = 4096
MaxLen ml_tempstring.s = #MAX_MLTEMPSTRING

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = _ml_AddPart {pathpart.s,filepart.s}                     /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - pathpart.s    : ???                                                       /
;/ - filepart.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s _ml_AddPart {pathpart.s,filepart.s}
SHARED ml_tempstring.s
ml_tempstring = pathpart
AddPart_ &ml_tempstring,&filepart.s,#MAX_MLTEMPSTRING
Function Return Peek.s(&ml_tempstring)
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = _ml_FilePart {filename.s}                               /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s _ml_FilePart {filename.s}
fptr.l = FilePart_(&filename.s)
If fptr
  filepart.s = Peek.s(fptr)
Else
  filepath.s = ""
End If
Function Return filepart.s
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = _ml_PathPart {filename.s}                               /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s _ml_PathPart {filename.s}
pathpart.s = Left$(filename.s,PathPart_(&filename.s)-&filename.s)
Function Return pathpart.s
End Function
 


USEPATH *node
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ml_AddNode {*prev_node.ml_node,typ.b,label_text.s,use:: /
;/ r_text.s,user_data.l}                                                       /
;/                                                                             /
;/ Description:                                                                /
;/ Add a new node to the list after prev_node.                                 /
;/ If prev node is Null, a new node is created without precessor => the root of a new multi list is created */
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *prev_node.ml_node : previous node or null                                                  /
;/ - typ.b              :                                                   /
;/ - label_text.s       : ???                                                  /
;/ - user_text.s        : ???                                                  /
;/ - user_data.l        : ???                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_AddNode {*prev_node.ml_node,typ.b,label_text.s,user_text.s,user_data.l}
*node.ml_node = AllocMem_ (SizeOf.ml_node,#MEMF_CLEAR)
If *node
  \prev_node = *prev_node

  If *prev_node
    \next_node = *prev_node\next_node
    *prev_node\next_node = *node
  Else
    \next_node = 0
  End If

  If \next_node
    \next_node\prev_node = *node
  End If

  \typ      = typ
  str_WritePtr {&\label_text,&label_text.s}
  str_WritePtr {&\user_text ,&user_text.s}
  \user_data = user_data
  \expanded = False
End If
Function Return *node
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  *node.l = ml_AddChild {*parent_node.ml_node,typ.b,label_text.s,u:: /
;/ ser_text.s,user_data.l}                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Add a new node as a child to an existing node.                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *parent_node.ml_node : pointer to a node                                  /
;/ - typ.b                : ???                                                /
;/ - label_text.s         : text string for the node name                      /
;/ - user_text.s          : text string for the node content                   /
;/ - user_data.l          : long word for various use                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - *node.ml_node     : pointer to the resulting node                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_AddChild {*parent_node.ml_node,typ.b,label_text.s,user_text.s,user_data.l}
If *parent_node
  *node.ml_node = AllocMem_ (SizeOf.ml_node,#MEMF_CLEAR)
  If *node
    *next_node.ml_node = *parent_node\child_node
    *parent_node\child_node = *node
    If *next_node Then *next_node\prev_node = *node

    \prev_node = 0
    \next_node = *next_node
    \parent_node = *parent_node
    \child_node = 0

    \typ      = typ
    str_WritePtr {&\label_text,&label_text.s}
    str_WritePtr {&\user_text ,&user_text.s}
    \user_data = user_data
    \expanded = False
    \parent_node\typ = #node_tree
  End If
Else
  *node = ml_AddNode {0,typ,label_text.s,user_text.s,user_data.l}
End If
Function Return *node
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ml_AddNodeSorted {*next_node.ml_node,typ.b,label_text:: /
;/ .s,user_text.s,user_data.l}                                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Add a new node to the list refered by next_node, but insert it sorted acc:: /
;/ ording the label_text.                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *next_node.ml_node : ???                                                  /
;/ - typ.b              : ???                                                  /
;/ - label_text.s       : ???                                                  /
;/ - user_text.s        : ???                                                  /
;/ - user_data.l        : ???                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_AddNodeSorted {*next_node.ml_node,typ.b,label_text.s,user_text.s,user_data.l}
If *next_node
  *node.ml_node = AllocMem_ (SizeOf.ml_node,#MEMF_CLEAR)
  If *node
    *parent_node.ml_node = *next_node\parent_node
    While *next_node\prev_node:*next_node = *next_node\prev_node:Wend
    *prev_node.ml_node = 0
    b.s = UCase$(label_text.s)
    If typ><#node_tree
      breakme.l = False
      While *next_node AND breakme = False
        If *next_node\typ=#node_tree
          *prev_node = *next_node
          *next_node = *next_node\next_node
        Else
          breakme.l = True
        End If
      Wend
    End If

    breakme.l = False
    While *next_node AND breakme=False

      a.s = UCase$(str_Read{&*next_node\label_text})
      If a.s<b.s AND typ=*next_node\typ

        *prev_node = *next_node
        *next_node = *next_node\next_node

      Else
        breakme=True
      End If
    Wend

    If *prev_node=0 AND *parent_node><0 Then *parent_node\child_node = *node

    If *next_node Then *next_node\prev_node = *node
    If *prev_node Then *prev_node\next_node = *node

    \prev_node = *prev_node
    \next_node = *next_node
    \parent_node = *parent_node
    \child_node = 0

    \typ      = typ
    str_WritePtr {&\label_text,&label_text.s}
    str_WritePtr {&\user_text ,&user_text.s}
    \user_data = user_data
    \expanded = False
    If \parent_node Then \parent_node\typ = #node_tree
  End If
Else
  *node = ml_AddNode {0,typ,label_text.s,user_text.s,user_data.l}
End If
Function Return *node
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ml_AddChildSorted {*parent_node.ml_node,typ.b,label_t:: /
;/ ext.s,user_text.s,user_data.l}                                              /
;/                                                                             /
;/ Description:                                                                /
;/ Add a new node as a child to an existing node. The node will be inserted :: /
;/ sorted after the label text.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *parent_node.ml_node : ???                                                /
;/ - typ.b                : ???                                                /
;/ - label_text.s         : ???                                                /
;/ - user_text.s          : ???                                                /
;/ - user_data.l          : ???                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_AddChildSorted {*parent_node.ml_node,typ.b,label_text.s,user_text.s,user_data.l}
If *parent_node
  *node.ml_node = AllocMem_ (SizeOf.ml_node,#MEMF_CLEAR)
  If *node
    *prev_node.ml_node = 0
    *next_node.ml_node = *parent_node\child_node

    b.s = UCase$(label_text.s)
    If typ><#node_tree
      breakme.l = False
      While *next_node AND breakme = False
        If *next_node\typ=#node_tree
          *prev_node = *next_node
          *next_node = *next_node\next_node
        Else
          breakme.l = True
        End If
      Wend
    End If

    breakme.l = False
    While *next_node AND breakme=False

      a.s = UCase$(str_Read{&*next_node\label_text})
      If a.s<b.s AND typ=*next_node\typ
        *prev_node = *next_node
        *next_node = *next_node\next_node

      Else
        breakme=True
      End If
    Wend

    If *prev_node=0 Then *parent_node\child_node = *node
    If *next_node Then *next_node\prev_node = *node
    If *prev_node Then *prev_node\next_node = *node

    \prev_node = *prev_node
    \next_node = *next_node
    \parent_node = *parent_node
    \child_node = 0

    \typ      = typ
    str_WritePtr {&\label_text,&label_text.s}
    str_WritePtr {&\user_text ,&user_text.s}
    \user_data = user_data
    \expanded = False
    \parent_node\typ = #node_tree
  End If
Else
  *node = ml_AddNode {0,typ,label_text.s,user_text.s,user_data.l}
End If
Function Return *node
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  *head.l = ml_GetFirstNode {*node.ml_node}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Get the first node of the list referred by node.                            /
;/ NOTE: This is useful if you plan to scan all items from this list.          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : node                                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - *head.ml_node    : first node in list                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_GetFirstNode {*node.ml_node}
If *node Then While *node\prev_node:*node=*node\prev_node:Wend
Function Return *node
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_RemoveNode {*node.ml_node}                                       /
;/                                                                             /
;/ Description:                                                                /
;/ Remove a node (and all its children).                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : node to remove                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_RemoveNode {*node.ml_node}
If *node
  If \prev_node Then \prev_node\next_node = \next_node
  If \next_node Then \next_node\prev_node = \prev_node
  If \parent_node
    If \parent_node\child_node = *node
      \parent_node\child_node = \next_node
    End If
  End If
  While \child_node
    ml_RemoveNode {\child_node}
  Wend
  str_Free {&\label_text}
  str_Free {&\user_text}
  FreeMem_ *node,SizeOf.ml_node
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  *node.l = ml_GetNextNode {*node.ml_node}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Get the next node of the list.                                              /
;/ If the function returns 0, you reached the end of the list.                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : node                                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - *node.ml_node    : next node                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_GetNextNode {*node.ml_node}
If *node
  Function Return *node\next_node
Else
  Function Return 0
End If
End Function

Function.l ml_GetParentNode {*node.ml_node}
If *node
  Function Return *node\parent_node
Else
  Function Return 0
End If
End Function

Function.l ml_GetChildNode {*node.ml_node}
If *node
  Function Return *node\child_node
Else
  Function Return 0
End If
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  *node.l = ml_GetPrevNode {*node.ml_node}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Get the previous node of the list.                                          /
;/ If the function return 0, you passed the head of the list.                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node  : node                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - *node.ml_node  : previous node                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_GetPrevNode {*node.ml_node}
If *node
  Function Return *node\prev_node
Else
  Function Return 0
End If
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  label.s = ml_GetLabelString {*node.ml_node}                        /
;/                                                                             /
;/ Description:                                                                /
;/ Get the label string of the node.                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node  : node                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - label.s        : label string                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s ml_GetLabelString{*node.ml_node}
If *node
  Function Return str_Read{&\label_text}
Else
  Function Return ""
End If
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_SetLabelString {*node.ml_node,string.s}                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : ???                                                    /
;/ - string.s    : ???                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_SetLabelString{*node.ml_node,string.s}
If *node Then str_Write{&\label_text,string}
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_SetUserString {*node.ml_node,string.s}                           /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : ???                                                    /
;/ - string.s    : ???                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_SetUserString{*node.ml_node,string.s}
  If *node Then str_Write{&\user_text,string}
End Statement

Statement ml_SetUserData{*node.ml_node,value.l}
  If *node Then \user_data = value
End Statement

Function.l ml_GetUserData{*node.ml_node}
  If *node Then Function Return \user_data
  Function Return 0
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  string.s = ml_GetUserString {*node.ml_node}                        /
;/                                                                             /
;/ Description:                                                                /
;/ Get the user string of the node                                             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node   : node                                                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - string.s        : user string                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s ml_GetUserString{*node.ml_node}
If *node
  Function Return str_Read{&\user_text}
Else
  Function Return ""
End If
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_RemoveAllNodes {*node.ml_node}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Remove the complete list (and all child lists) referred by node. The node:: /
;/  does not need to be the head of the list.                                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : node                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_RemoveAllNodes {*node.ml_node}
If *node Then While *node\prev_node:*node=*node\prev_node:Wend

While *node
  *next_node.ml_node=*node\next_node
  If \prev_node Then \prev_node\next_node = \next_node
  If \next_node Then \next_node\prev_node = \prev_node
  If \parent_node
    If \parent_node\child_node = *node
      \parent_node\child_node = \next_node
    End If
  End If
  While \child_node
    ml_RemoveNode {\child_node}
  Wend
  str_Free {&\label_text}
  str_Free {&\user_text}
  FreeMem_ *node,SizeOf.ml_node
  *node = *next_node
Wend
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_RemoveAllChildren {*node.ml_node}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Remove all children of the node.                                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : node                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_RemoveAllChildren {*node.ml_node}
If *node
  While \child_node
    ml_RemoveNode {\child_node}
  Wend
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_SetExpanded {*node.ml_node}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Set the expanded flag of the node. If you draw the node, it will show its:: /
;/  children.                                                                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : node                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_SetExpanded {*node.ml_node}
If *node
  \expanded = True
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_SetCollapsed {*node.ml_node}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Clear the expanded flag of the node. If you draw the node, it will not sh:: /
;/ ow its children.                                                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : ???                                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_SetCollapsed {*node.ml_node}
If *node
  \expanded = False
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_ActivateNode {*node.ml_node}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Mark a node as active.                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : pointer to a node                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_ActivateNode {*node.ml_node}
If *node
  \active = True
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_DeactivateNode {*node.ml_node}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Mark a node as in-active.                                                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : node                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_DeactivateNode {*node.ml_node}
If *node
  \active = False
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  rows.l = ml_GetRowHeight {*node.ml_node}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Calculate the number of rows the list would need to be shown, respecting :: /
;/ which node is expanded and which is collapsed.                              /
;/ NOTE: This is useful to set the dimensions of a scroller bar if you plan :: /
;/ to make the list visible.                                                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node   : node                                                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - rows.l          : number of rows                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_GetRowHeight {*node.ml_node}
lpos.l = 0
While *node
  If \typ = #node_tree
    If \expanded
      lpos + ml_GetRowHeight{\child_node}
    End If
  End If
  lpos + 1
  *node=\next_node
Wend
Function Return lpos
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ml_GetNode {*node.ml_node,spos.l}                       /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : ???                                                    /
;/ - spos.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_GetNode {*node.ml_node,spos.l}
lpos.l = 0
While *node
  If lpos=spos Then Poke.l ?getnode_res,*node
  If \typ = #node_tree
    If \expanded
      lpos + ml_GetNode{\child_node,spos-lpos-1}
    End If
  End If
  lpos + 1
  *node=\next_node
Wend
Function Return lpos
getnode_res:
Dc.l 0
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ml_FindNode {*node.ml_node,spos.l}                      /
;/                                                                             /
;/ Description:                                                                /
;/ Find a node at the position spos.                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node : ???                                                       /
;/ - spos.l        : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_FindNode {*node.ml_node,spos.l}
MOVE.l #0,getnode_res
dummy.l = ml_GetNode {*node.ml_node,spos.l}
MOVE.l getnode_res,d0
*hitnode.ml_node = PutRegD0
Function Return *hitnode
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_DeactivateAll {*node.ml_node}                                    /
;/                                                                             /
;/ Description:                                                                /
;/ Deactivate recursively all nodes and their children.                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : ???                                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_DeactivateAll {*node.ml_node}
While *node
  *node\active = False
  If \typ = #node_tree
    ml_DeactivateAll{\child_node}
  End If
  *node=\next_node
Wend
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  pixels.l = ml_GetPixelWidth {*rp.RastPort,*node.ml_node,sdepth.l}  /
;/                                                                             /
;/ Description:                                                                /
;/ Calculate the width in pixels needed to draw the list in the current state. /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *rp.RastPort   : rastport to draw into                                    /
;/ - *node.ml_node  : node to start                                            /
;/ - sdepth.l       : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - pixels.l     : number of pixels                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_GetPixelWidth {*rp.RastPort,*node.ml_node,sdepth.l}
pixwidth.l=1
xs.l = sdepth * *rp\TxWidth*2
While *node
  If \typ = #node_tree
    If \expanded
     b.s = "[-] "+str_Read{&\label_text}
     tstwidth.l = TextLength_ (*rp,&b.s,Peek.l(&b.s-4)) +xs
     pixwidth.l = Max(tstwidth,pixwidth)
     tstwidth.l = ml_GetPixelWidth{*rp,\child_node,sdepth+1}
    Else
     b.s = "[+] "+str_Read{&\label_text}
     tstwidth.l = TextLength_ (*rp,&b.s,Peek.l(&b.s-4)) + xs
    End If
  Else
    b.s = str_Read{&\label_text}
    tstwidth.l = TextLength_ (*rp,&b.s,Peek.l(&b.s-4)) + xs
  End If
  pixwidth.l = Max(tstwidth,pixwidth)
  *node=\next_node
Wend
Function Return pixwidth
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ml_Draw {*rp.RastPort,*node.ml_node,firstpos.l,lastpo:: /
;/ s.l,x.l,y.l,sdepth.l,bgpen.l,bgpen_m.l}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Draw a multilist into a rastport from firstpos to lastpos.                  /
;/ The rastport needs to have a suitable clip region set to not overdraw the:: /
;/  window borders etc.                                                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *rp.RastPort    : rastport to draw into                                   /
;/ - *node.ml_node   : node                                                    /
;/ - firstpos.l      : first pos                                               /
;/ - lastpos.l       : last pos                                                /
;/ - x.l             : x coordinate                                            /
;/ - y.l             : y coodrinate                                            /
;/ - sdepth.l        : spedth to start from                                    /
;/ - bgpen.l         : background pen                                          /
;/ - bgpen_m.l       : background marked pen                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_Draw {*rp.RastPort,*node.ml_node,firstpos.l,lastpos.l,x.l,y.l,sdepth.l,bgpen.l,bgpen_m.l}
lpos.l = 0
x1.l = x + sdepth   * *rp\TxWidth ; *2
y1.l = y - firstpos * *rp\TxHeight + *rp\TxBaseline
y2.l = y - firstpos * *rp\TxHeight
SetDrMd_ *rp,1
While *node AND lpos<=lastpos
  SetAPen_ *rp,bgpen:RectFill_ *rp,x,y2+lpos * *rp\TxHeight,3200,y2+(lpos+1) * *rp\TxHeight-1

  If \active
    SetBPen_ *rp,bgpen_m
  Else
    SetBPen_ *rp,bgpen
  End If
  If \typ = #node_tree

    SetAPen_ *rp,2
    If \expanded
      If lpos>=firstpos
        b.s = "[-] "+str_Read{&\label_text}
        Move_ *rp,x1,y1+lpos * *rp\TxHeight
        Text_ *rp,&b.s,Peek.l(&b.s-4)
      End If
      lpos + ml_Draw{*rp,\child_node,firstpos-lpos-1,lastpos-lpos-1,x,y,sdepth+1,bgpen,bgpen_m}
    Else
      If lpos>=firstpos
        b.s = "[+] "+str_Read{&\label_text}
        Move_ *rp,x1,y1+lpos * *rp\TxHeight
        Text_ *rp,&b.s,Peek.l(&b.s-4)
      End If
    End If
  Else
    SetAPen_ *rp,1
    If lpos>=firstpos
      b.s = str_Read{&\label_text}
      Move_ *rp,x1,y1+lpos * *rp\TxHeight
      Text_ *rp,&b.s,Peek.l(&b.s-4)
    End If
  End If
  lpos + 1
  *node=\next_node
Wend
Function Return lpos
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_AddPathChild {*parent_node.ml_node,path.s,@pattern.s}            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *parent_node.ml_node : ???                                                /
;/ - path.s               : ???                                                /
;/ - pattern.s            : ???                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_AddPathChild {*parent_node.ml_node,path.s,@pattern.s}
DEFTYPE.FileInfoBlock fib
If *parent_node
  If pattern.s = "" Then pattern.s = "~(#?.(info|bak|xtra))"
  lock.l = Lock_(&path.s,#ACCESS_READ)
  If lock
    oldlock.l = CurrentDir_(lock)
    If oldlock

      buf.s = LSet$(" ",FLen(pattern.s)*3+4)
      ParsePatternNoCase_ &pattern.s,&buf.s,FLen(buf.s)
      pattern.s = Peek.s(&buf.s)
      If Examine_(lock,&fib)
        While ExNext_(lock,&fib)
          filename.s = _ml_AddPart{path.s,Peek.s(&fib\fib_FileName)}
          If fib\fib_DirEntryType<0
            If MatchPatternNoCase_ (&pattern.s,&fib\fib_FileName)
              *node.ml_node = ml_AddChildSorted {*parent_node,#node_simple,_ml_FilePart{filename.s},filename.s,0}
            End If
          Else
            *node.ml_node = ml_AddChildSorted {*parent_node,#node_tree,_ml_FilePart{filename.s},filename.s,1}
          End If
        Wend
      End If

      oldlock = CurrentDir_ (oldlock)
    End If
    UnLock_ lock
  End If
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ml_AddPathNode {*node.ml_node,path.s,@pattern.s}        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node : ???                                                       /
;/ - path.s        : ???                                                       /
;/ - pattern.s     : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l      : ???                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_AddPathNode {*node.ml_node,path.s,@pattern.s,@alldirs.l}
DEFTYPE.FileInfoBlock fib
  If pattern.s = "" Then pattern.s = "~(#?.(info|bak|xtra))"
  lock.l = Lock_(&path.s,#ACCESS_READ)
  If lock
    oldlock.l = CurrentDir_(lock)
    If oldlock
      buf.s = LSet$(" ",FLen(pattern.s)*3+4)
      ParsePatternNoCase_ &pattern.s,&buf.s,FLen(buf.s)
      pattern.s = Peek.s(&buf.s)
      If Examine_(lock,&fib)
        While ExNext_(lock,&fib)
          filename.s = _ml_AddPart{path.s,Peek.s(&fib\fib_FileName)}
          If fib\fib_DirEntryType<0
            If MatchPatternNoCase_ (&pattern.s,&fib\fib_FileName)
              *node.ml_node = ml_AddNodeSorted {*node,#node_simple,_ml_FilePart{filename.s},filename.s,0}
            End If
          Else
             If alldirs
               *node.ml_node = ml_AddNodeSorted {*node,#node_tree,_ml_FilePart{filename.s},filename.s,1}
             Else
               If MatchPatternNoCase_ (&pattern.s,&fib\fib_FileName)
                 *node.ml_node = ml_AddNodeSorted {*node,#node_tree,_ml_FilePart{filename.s},filename.s,1}
               End If
             End If
          End If
        Wend
      End If
      oldlock = CurrentDir_ (oldlock)
    End If
    UnLock_ lock
  End If
If *node Then While *node\prev_node:*node=*node\prev_node:Wend
Function Return *node
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ml_CreatePathTreeRoot {path.s,name.s}                   /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - path.s    : ???                                                           /
;/ - name.s    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_CreatePathTreeRoot {path.s,name.s}
*parent_node.ml_node=ml_AddNode {0,#node_tree,name.s,path.s,0}
Function Return *parent_node
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ml_CreatePathTree {path.s,@pattern.s}                   /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - path.s      : ???                                                         /
;/ - pattern.s   : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l    : ???                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ml_CreatePathTree {path.s,@pattern.s,@alldirs.l}
*newnode.ml_node=ml_AddPathNode {0,path.s,pattern.s,alldirs}
Function Return *newnode
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_ExpandPath {*node.ml_node,@pattern.s}                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node  : ???                                                      /
;/ - pattern.s      : ???                                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_ExpandPath {*node.ml_node,@pattern.s}
If *node
  If \typ=#node_tree
    ml_RemoveAllChildren {*node}
    ml_AddPathChild {*node,str_Read{&*node\user_text},pattern.s}
    ml_SetExpanded {*node}
  End If
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ml_CollapsePath {*node.ml_node}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *node.ml_node    : ???                                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ml_CollapsePath {*node.ml_node}
If *node
  If \typ=#node_tree
    ml_RemoveAllChildren {*node}
    ml_SetCollapsed {*node}
  End If
End If
End Statement

CNIF #__include=0
  *parent.ml_node = ml_CreatePathTree {"sys:"}
  ml_ExpandPath {*parent}
  *node.ml_node = ml_GetNode {*parent,20}
  ml_ExpandPath {*node}
  WbToScreen 0
  Window 0,0,0,320,200,$E,"",0,1
  *rp.RastPort = RastPort(0)
  dummy.l = ml_Draw {*rp,*parent,0,1000,0,0,0,4,1}
  ml_RemoveNode {*parent}
  ;Delay_ 400
  While WaitEvent><#IDCMP_CLOSEWINDOW : Wend
  End
CEND

