; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "/Bin"
; ExeFile         = "ImageDemo3"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 1290
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 1
; DebugInfo       = 1
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 1
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 8323
; CursorColumn    = 6
; LabelSearch     = "image_loadviapng"
; LabelRemark     = 0
; LabelAll        = 1
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 1
; Max GadgetList  = 1
; Max Shape       = 1
; Max Bank        = 1
; Max MenuList    = 1
; Max BlitzFont   = 1
; Max GTList      = 30
; Max Palette     = 1
; Max BitMap      = 10
; Max Screen      = 2
; Max Window      = 30
; Max IntuiFont   = 12
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 1
; Max Sound       = 10
; Max MedModule   = 1
; Max Buffer      = 10
; Max Queue       = 1
; Max Sprite      = 1
; Max Module      = 1
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 1
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 1
; Max XBSound     = 10
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: image.include                                                         /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 28.12.2006                                                            /
;/                                                                             /
;/ Author: Thilo Koehler                                                       /
;/                                                                             /
;/ Requirements: Amiblitz V2.4                                                 /
;/               ab3zlib.library (for png support)                          /
;/               jpeg.library    (for jpeg support)                         /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Replace and heavily extend the custom chip blit commands and shape comman:: /
;/ ds and make them system friendly.                                           /
;/                                                                             /
;/ Abstract:                                                                   /
;/ This include provides commands to load images via datatypes (e.g. IFF-ILB:: /
;/ M, JPG, PNG, GIF) and blit them into a window on a screen with any color :: /
;/ depth or convert them into blitz shape objects.                             /
;/ It can also save images in IFF-ILBM, PNG and JPEG.                          /
;/ Images are stored as "image" objects, similar to blitz objects. Every ima:: /
;/ ge object is references by an ID, that ranges from 0 to #max_images-1.      /
;/                                                                             /
;/ AB3I format                                                                 /
;/ The include comes with its own file format called AB3I (AmiBlitz3 Image),:: /
;/  that can be raw or compressed data (both require z.library).               /
;/ The use of this proprietary file format is to store images in an "unreada:: /
;/ ble" format for other applications like paint programs.                     /
;/ One AB3I file can also contain multiple pictures, that can make up e.g. a:: /
;/ n animation or a complete sprite set for a game.                            /
;/ The AB3I format stores automatically all information of an image object, :: /
;/ like its handle, transparent color, alpha channel or bitmask.               /
;/ There is also a AB2I format, but I recommend AB3I, because it has a better  /
;/ and faster compression, and more features to control the compression.       /
;/                                                                             /
;/ User Constants:                                                             /
;/ #max_images = 100                                                           /
;/ Set this BEFORE you include the image.include to control the maximum numb:: /
;/ er of images you need.                                                      /
;/ Don't use object IDs above #max_images-1.                                   /
;/                                                                             /
;/ #use_jpeg_library = 1                                                       /
;/ Set this to 0, if your program doesn't need to write JPEG pictures. Your :: /
;/ program will not require the jpeg.library any more.                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
CNIF @#max_images = 0
  #max_images = 100        ; Same like object maximums in debugger,
CEND

CNIF #__include=0
  optimize 5               ; It needs at least optimize 4 turned on !
  Syntax 6
  XINCLUDE "eclock.include.ab3"
  #use_jpeg_library = 1
CEND

CNIF @#use_maskfile = 0
  #use_maskfile = 0        ; check for external .msk file for alpha channel
CEND

CNIF @#use_jpeg_library = 0
  #use_jpeg_library = 1    ; jpeg support is turned on by default (requires jpeg.library)
CEND

CNIF @#use_shapeslib = 0
  #use_shapeslib = 1       ; shapelib is turned on by default
CEND

XINCLUDE "error.include.ab3"
XINCLUDE "zlib.include.ab3"
XINCLUDE "screen.include.ab3"
XINCLUDE "image_blitmacros.ab3"
XINCLUDE "convert.include.ab3"
XINCLUDE "file.include.ab3"
XINCLUDE "iff-ilbm.include.ab3"
XINCLUDE "bmp.include.ab3"
CNIF #use_jpeg_library
XINCLUDE "jpeg.include.ab3"
CEND
XINCLUDE "png.include.ab3"
XINCLUDE "cmap.include.ab3"
XINCLUDE "tempbuffer.include.ab3"
XINCLUDE "v43+.definitions.ab3"

.IMAGE_CONSTANTS
; Save Flags for use with image_Save{}
#image_sf_progressive     = $1   ; save as progressive image (supported by png and jpeg)
#image_sf_smoothing       = $2   ; do smoothing before encoding (used by jpeg)
#image_sf_moresmoothing   = $4   ; do more smoothing before encoding (used by jpeg)
#image_sf_YUV             = $8   ; used by AB3I for better compression
#image_sf_lossy           = $10  ; used by AB3I for lossy compression
#image_sf_fast            = $20  ; used by AB3I for fair, but fast compression

; Blitmodes for FancyBlit
#image_blitmode_opaque   = 0
#image_blitmode_trans    = 1
#image_blitmode_alpha    = 2
#image_blitmode_add      = 3
#image_blitmode_sub      = 4
#image_blitmode_bump     = 5
#image_blitmode_mul      = 6
#image_blitmode_invalpha = 7
#image_blitmode_shadow   = 8
#image_blitmode_muladd   = 9
#image_blitmode_alphaadd = 10
#image_blitmode_suba     = 11

#image_scaleres = 13860

; dithermodes
#image_dithermode_default      = -1 ; default, currently errnoisefast
#image_dithermode_none         = 0  ; no dithering, simple bit truncation
#image_dithermode_err          = 1  ; error dithering, looks like FS dithering
#image_dithermode_noise        = 2  ; pure noise dithering
#image_dithermode_tk           = 3  ; Thilo's special experimental dithering
#image_dithermode_errnoise     = 4  ; error + noise dithering
#image_dithermode_noneshift    = 5  ; no dithering, but shifting, might be better than just truncation
#image_dithermode_errnoisefast = 6  ; error + noise dithering, fast version
#image_dithermode_errfast      = 7  ; error dithering, fast version
#image_dithermode_errnoiseadd  = 8  ; error in add mode + noise dithering, experimental

; interpolation modes for image_Resize
#image_interpol_none           = 0 ; no interpolation => nearest neighbour
#image_interpol_linear         = 1 ; linear interpolation
#image_interpol_window         = 2 ; window interpolation (good quality for downsizing)
#image_interpol_gui            = 3 ; improved window interpolation
#image_interpol_alpha          = 4
#image_interpol_test           = 5
#image_interpol_gui_depricated = 6
#image_interpol_cos            = 7
#image_interpol_cubic          = 8

;Check if libs are installed, otherwise it makes no sense to run this program
CNIF #use_jpeg_library
  image_lib.s = "jpeg.library"
  image_jpegbase.l  = OpenLibrary_ (&image_lib.s,1)
  If image_jpegbase = False
    error{"\\__THIS_INCLUDE: Please install jpeg.library!"} : End
  Else
    CloseLibrary_ image_jpegbase
  End If
CEND

.IMAGE_NEWTYPES
NEWTYPE.imagedat
  isused.l

  ; Picture dimensions
  img_height.l
  img_width.l

  ; Handle
  handle_x.l
  handle_y.l

  ; Blit Clip Bounds
  clip_x.l
  clip_y.l
  clip_xs.l
  clip_ys.l

  ; Settings
  dither_mode.w
  dither_threshold.w
  mask_tolerance.w
  mask_threshold.w
  mask_trgb.l

  ; Mask
  mask_isused.l
  mask_ptr.l
  mask_bytesize.l
  mask_bpr.l

  is_solid.l

  ; Shadow Bitmap
  *bitmap_ptr.BitMap

  ; ARGB Bitmap
  *ARGBbitmap_ptr.BitMap
  *rastport_ptr.RastPort
  *layerinfo_ptr.Layer_Info
  *layer_ptr.Layer
  bmaplock.l
  bmaplock_count.l
  raw_ptr.l
  bpr.l
  bpp.l

  ; Alpha channel
  alpha_isused.l

  filename.s
End NEWTYPE

NEWTYPE.imageengine
  ; Bernds load divisor
  devisor.l
  exWidth.l
  exHeight.l
  exDepth.l
  exNumImg.l
  *cmap.cmap
End NEWTYPE


; used for image_textureblit
NEWTYPE.texturearray
  x1.w
  y1.w
  x2.w
  y2.w
  x3.w
  y3.w
  x4.w
  y4.w
End NEWTYPE


.IMAGE_GLOBALS
DEFTYPE.texturearray texturearray
SHARED imageengine.imageengine
DEFTYPE.BitScaleArgs bsa
Dim imagedat.imagedat(#max_images-1)
Dim imgargs.l(30)
version_iconlib.l     = 0
version_newiconlib.l  = 0
version_graphicslib.l = 0
version_jpeglib.l     = 0
version_doslib.l      = 0
version_execlib.l     = 0

SHARED imagedat()

Statement image_CopyConfig{image.l,src_image.l}
SHARED imagedat()

  imagedat(image)\dither_mode      = imagedat(src_image)\dither_mode
  imagedat(image)\dither_threshold = imagedat(src_image)\dither_threshold
  imagedat(image)\mask_tolerance   = imagedat(src_image)\mask_tolerance
  imagedat(image)\mask_threshold   = imagedat(src_image)\mask_threshold
  imagedat(image)\mask_trgb        = imagedat(src_image)\mask_trgb
  imagedat(image)\alpha_isused     = imagedat(src_image)\alpha_isused
  imagedat(image)\handle_x         = imagedat(src_image)\handle_x
  imagedat(image)\handle_y         = imagedat(src_image)\handle_y
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: conv_ARGB_0RGB{src.l,dst.l,pixel.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/ Note: This function is not used at all.                                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - src.l    : ???                                                            /
;/ - dst.l    : ???                                                            /
;/ - pixel.l    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _image_ARGB20RGB{src.l,dst.l,pixel.l}

  For n.l = 0 To pixel-1
    argb.l = Peek.l(src+n*4)
    Poke.b dst+n*3+0,(argb LSR 16) & $FF
    Poke.b dst+n*3+1,(argb LSR  8) & $FF
    Poke.b dst+n*3+2,(argb LSR  0) & $FF
  Next
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: conv_0RGB_ARGB{src.l,dst.l,img_width.l,img_height.l,@img_bpr.l}     /
;/                                                                             /
;/ Description:                                                                /
;/                                                                             /
;/ * private *                                                                 /
;/ Note: This function is not used at all.                                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - src.l    : ???                                                            /
;/ - dst.l    : ???                                                            /
;/ - img_width.l    : ???                                                      /
;/ - img_height.l    : ???                                                     /
;/ - img_bpr.l    : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _image_0RGB2ARGB{src.l,dst.l,img_width.l,img_height.l,@img_bpr.l}

  If img_bpr <1 Then img_bpr = img_width*4
  ARGB.l = 0
  For y.l = 0 To img_height-1
    ptrA.l = src + y * img_width*3
    ptrB.l = dst + y * img_bpr
    For x.l = 0 To img_width-1
      r.l = Peek.b(ptrA+0) & $FF
      g.l = Peek.b(ptrA+1) & $FF
      b.l = Peek.b(ptrA+2) & $FF : ptrA+3
      argb.l = (r LSL 16) | (g LSL 8) | b
      ARGB.l + argb
      Poke.l ptrB,ARGB
      ptrB + 4
    Next
  Next
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_RGB2YUV24{src.l,srcbpr.l,w.l,h.l,@GMASK.l,@CMASK.l}           /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - src.l    : ???                                                            /
;/ - srcbpr.l    : ???                                                         /
;/ - w.l    : ???                                                              /
;/ - h.l    : ???                                                              /
;/ - GMASK.l    : ???                                                          /
;/ - CMASK.l    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _image_RGB2YUV24{src.l,srcbpr.l,w.l,h.l,@GMASK.l,@CMASK.l}

  GMASK & $FF
  CMASK & $FF
  gloss.l = ($FF-GMASK+1)/2
  closs.l = ($FF-CMASK)+1
  For y.l = 0 To h-1
    ptrA.l = src + y*srcbpr
    For x.l = 0 To w-1
      r.l = Peek.b(ptrA+0) & $FF
      g.l = Peek.b(ptrA+1) & $FF
      b.l = Peek.b(ptrA+2) & $FF
      t.l = ((r + g + b+1) / 3) & GMASK + gloss
      tr.l = ((r-t+closs) ASR 1) & CMASK
      tb.l = ((b-t+closs) ASR 1) & CMASK
      Poke.b ptrA+0,t
      Poke.b ptrA+1,(tr)
      Poke.b ptrA+2,(tb)
      ptrA+3
    Next
  Next
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_YUV2RGB24{src.l,srcbpr.l,w.l,h.l}                             /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - src.l    : ???                                                            /
;/ - srcbpr.l    : ???                                                         /
;/ - w.l    : ???                                                              /
;/ - h.l    : ???                                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _image_YUV2RGB24{src.l,srcbpr.l,w.l,h.l}

  For y.l = 0 To h-1
    ptrA.l = src + y*srcbpr
    For x.l = 0 To w-1
      t.l  = (Peek.b(ptrA+0) & $FF)
      tr.l = Peek.b(ptrA+1) LSL 1  ;: If tr<0 Then tr + 1
      tb.l = Peek.b(ptrA+2) LSL 1  ;: If tb<0 Then tb + 1
      r.l = t + tr
      b.l = t + tb
      g.l = t-tr-tb
      If g < 0 Then g = 0
      If r < 0 Then r = 0
      If b < 0 Then b = 0
;      If g > 255 Then g = 255
;      If r > 255 Then r = 255
;      If b > 255 Then b = 255
      Poke.b ptrA+0,r
      Poke.b ptrA+1,g
      Poke.b ptrA+2,b
      ptrA+3
    Next
  Next
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_RGB2YUV32{src.l,srcbpr.l,w.l,h.l,@GMASK.l,@CMASK.l}           /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - src.l    : ???                                                            /
;/ - srcbpr.l    : ???                                                         /
;/ - w.l    : ???                                                              /
;/ - h.l    : ???                                                              /
;/ - GMASK.l    : ???                                                          /
;/ - CMASK.l    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _image_RGB2YUV32{src.l,srcbpr.l,w.l,h.l,@GMASK.l,@CMASK.l}

  GMASK & $FF
  CMASK & $FF
  gloss.l = ($FF-GMASK+1)/2
  closs.l = ($FF-CMASK)+1

  For y.l = 0 To h-1
    ptrA.l = src + y*srcbpr
    For x.l = 0 To w-1
      r.l = Peek.b(ptrA+1) & $FF
      g.l = Peek.b(ptrA+2) & $FF
      b.l = Peek.b(ptrA+3) & $FF
      t.l  = (((r + g + b+1) / 3) & GMASK) + gloss
      tr.l = (((r-t+closs) ASR 1) & CMASK)
      tb.l = (((b-t+closs) ASR 1) & CMASK)
      Poke.b ptrA+1,t
      Poke.b ptrA+2,(tr)
      Poke.b ptrA+3,(tb)
      ptrA+4
    Next
  Next
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_YUV2RGB32{src.l,srcbpr.l,w.l,h.l}                             /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - src.l    : ???                                                            /
;/ - srcbpr.l    : ???                                                         /
;/ - w.l    : ???                                                              /
;/ - h.l    : ???                                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _image_YUV2RGB32{src.l,srcbpr.l,w.l,h.l}

  For y.l = 0 To h-1
    ptrA.l = src + y*srcbpr
    For x.l = 0 To w-1
      t.l  = (Peek.b(ptrA+1) & $FF)
      tr.l = Peek.b(ptrA+2) LSL 1
      tb.l = Peek.b(ptrA+3) LSL 1
      ;If tr < 0 Then tr + 1
      ;If tb < 0 Then tb + 1
      g.l = t - tr-tb
      r.l = t + tr
      b.l = t + tb
      If g < 0 Then g = 0
      If r < 0 Then r = 0
      If b < 0 Then b = 0
      ;If g > 255 Then g = 255
      ;If r > 255 Then r = 255
      ;If b > 255 Then b = 255
      Poke.b ptrA+1,r
      Poke.b ptrA+2,g
      Poke.b ptrA+3,b
      ptrA+4
    Next
  Next
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_FilterDelta24{src.l,srcbpr.l,dst.l,dstbpr.l,w.l,h.l}          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - src.l    : ???                                                            /
;/ - srcbpr.l    : ???                                                         /
;/ - dst.l    : ???                                                            /
;/ - dstbpr.l    : ???                                                         /
;/ - w.l    : ???                                                              /
;/ - h.l    : ???                                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _image_FilterDelta24{src.l,srcbpr.l,dst.l,dstbpr.l,w.l,h.l}

  LR.b = 128 : LG.b = 128: LB.b = 128
  For y.l = 0 To h-1
    ptrA.l = src + y*srcbpr
    ptrB.l = dst + y*dstbpr
    For x.l = 0 To w-1
      R.b = Peek.b(ptrA+0)
      G.b = Peek.b(ptrA+1)
      B.b = Peek.b(ptrA+2)
      DR.b = R-LR : LR = R
      DG.b = G-LG : LG = G
      DB.b = B-LB : LB = B
      Poke.b ptrB+0,DR
      Poke.b ptrB+1,DG
      Poke.b ptrB+2,DB
      ptrA+3
      ptrB+3
    Next
  Next
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_FilterDelta32{src.l,srcbpr.l,dst.l,dstbpr.l,w.l,h.l,@ARGBM::  /
;/ ASK.l}                                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - src.l    : ???                                                            /
;/ - srcbpr.l    : ???                                                         /
;/ - dst.l    : ???                                                            /
;/ - dstbpr.l    : ???                                                         /
;/ - w.l    : ???                                                              /
;/ - h.l    : ???                                                              /
;/ - ARGBMASK.l    : ???                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _image_FilterDelta32{src.l,srcbpr.l,dst.l,dstbpr.l,w.l,h.l,@ARGBMASK.l}

  LARGB.l = $80808080 & ARGBMASK
  LR.b = 128 : LG.b = 128 : LB.b = 128 : LX.b = 128
  For y.l = 0 To h-1
    ptrA.l = src + y*srcbpr
    ptrB.l = dst + y*dstbpr
    For x.l = 0 To w-1
     ;ARGB.l = Peek.l(ptrA) & ARGBMASK
     ;DIFF.l = ARGB-LARGB : LARGB = ARGB
     ;Poke.l ptrB,DIFF
      A.b = Peek.b(ptrA+0)
      R.b = Peek.b(ptrA+1)
      G.b = Peek.b(ptrA+2)
      B.b = Peek.b(ptrA+3)
      DA.b = A-LX : LX = A
      DR.b = R-LR : LR = R
      DG.b = G-LG : LG = G
      DB.b = B-LB : LB = B
      Poke.b ptrB+0,DA
      Poke.b ptrB+1,DR
      Poke.b ptrB+2,DG
      Poke.b ptrB+3,DB
      ptrA+4
      ptrB+4
    Next
  Next
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_UnfilterDelta32{src.l,srcbpr.l,dst.l,dstbpr.l,w.l,h.l,@ARG::  /
;/ BMASK.l}                                                                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - src.l    : ???                                                            /
;/ - srcbpr.l    : ???                                                         /
;/ - dst.l    : ???                                                            /
;/ - dstbpr.l    : ???                                                         /
;/ - w.l    : ???                                                              /
;/ - h.l    : ???                                                              /
;/ - ARGBMASK.l    : ???                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _image_UnfilterDelta32{src.l,srcbpr.l,dst.l,dstbpr.l,w.l,h.l,@ARGBMASK.l}

  ARGB.l = $80808080 & ARGBMASK
  A.b = 128
  R.b = 128
  G.b = 128
  B.b = 128
  For y.l = 0 To h-1
    ptrA.l = src + y*srcbpr
    ptrB.l = dst + y*dstbpr
    For x.l = 0 To w-1
      ;DIFF.l = Peek.l(ptrA)
      ;ARGB.l + DIFF
      ;Poke.l ptrB,ARGB
      DA.b = Peek.b(ptrA+0)
      DR.b = Peek.b(ptrA+1)
      DG.b = Peek.b(ptrA+2)
      DB.b = Peek.b(ptrA+3)
      A.b +DA
      R.b +DR
      G.b +DG
      B.b +DB
      Poke.b ptrB+0,A
      Poke.b ptrB+1,R
      Poke.b ptrB+2,G
      Poke.b ptrB+3,B
      ptrB + 4
      ptrA + 4
    Next
  Next
End Statement

.IMAGE_FUNCTIONS
USEPATH imagedat(image)
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l =  image_IsUsed{image.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Test if the image number is in use (e.g. is loaded) or not                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - True if image is used, otherwise False                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_IsUsed{image.l}
SHARED imagedat()

  succ.l = False
  If image >= 0 AND image<#max_images
    If \isused >< False Then succ = True
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_Lock{image.l}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_Lock{image.l}
SHARED imagedat()

  If \ARGBbitmap_ptr
    If \bmaplock
      \bmaplock_count+1
    Else
      RunErrsOff
      tag5.tag5\ti_Tag = #LBMI_BASEADDRESS,&\raw_ptr,#LBMI_BYTESPERROW,&\bpr,#LBMI_BYTESPERPIX,&\bpp,#TAG_DONE,0
      \bmaplock = LockBitMapTagList_(\ARGBbitmap_ptr,tag5)
      If \bmaplock Then UnLockBitMap_ \bmaplock : \bmaplock = 0
      LastRunErrsMode
      \bmaplock_count = 1
      If \raw_ptr = Null Then \raw_ptr = \ARGBbitmap_ptr\Planes
      If \bpp < 4 Then \bpp = 4
      Format ""
      If \bpr < \img_width*\bpp Then error{"BPR: "+Str$(\bpr)+", but width is "+Str$(\img_width)} : \bpr = (\img_width+15)/16 : \bpr * 16 * \bpp
    End If
  End If

  If \raw_ptr = 0; OR \bmaplock=0
    If \bmaplock Then UnLockBitMap_ \bmaplock : \bmaplock = 0  :\bmaplock_count = 0
    error{"\\__THIS_FUNCTION: Uninitialized image ("+Str$(image)+")!"}
  End If
  Function Return \bmaplock_count
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_UnlockForce{image.l}                                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/                                                                             /
;/ See also:    image_Lock                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_UnlockForce{image.l}
SHARED imagedat()

  \bmaplock_count = 0
  If \bmaplock
     UnLockBitMap_ \bmaplock
     \bmaplock = 0
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Unlock{image.l}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/                                                                             /
;/ See also:    image_Lock                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Unlock{image.l}
SHARED imagedat()

  If \bmaplock_count > 0
    \bmaplock_count-1
    If \bmaplock_count = 0 AND \bmaplock >< 0 Then UnLockBitMap_ \bmaplock : \bmaplock = 0
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  width.l =  image_GetWidth{image.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Return the width of the specified image.                                    /
;/                                                                             /
;/ NOTE: Never use imagedat() variables directly as they may change in the f:: /
;/ uture                                                                       /
;/ NOTE: There exists also a macro, if you need to be really fast!             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - width.l : width of the image                                              /
;/                                                                             /
;/ See also:    !image_width, image_height                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_GetWidth{image.l}
SHARED imagedat()

  Function Return \img_width
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_GetWidth                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Get the width in pixel of an image. This is a faster version of the funct:: /
;/ ion image_width.                                                            /
;/                                                                             /
;/ See also:    image_width                                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_GetWidth

  imagedat(`1)\img_width
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l =  image_GetHeight{image.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Return the height of the specified image                                    /
;/                                                                             /
;/ NOTE: Never use imagedat() variables directly as they may change in the f:: /
;/ uture                                                                       /
;/ NOTE: There exists also a macro, if you need to be really fast!             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - height : height of the image                                              /
;/                                                                             /
;/ See also:    !image_height, image_width                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_GetHeight{image.l}
SHARED imagedat()

  Function Return \img_height
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_GetHeight                                                    /
;/                                                                             /
;/ Description:                                                                /
;/ Get the height in pixel of an image. This is a faster version of the func:: /
;/ tion image_height.                                                          /
;/                                                                             /
;/ See also:    image_height                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_GetHeight

  imagedat(`1)\img_height
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Release{image.l}                                              /
;/                                                                             /
;/ Description:                                                                /
;/ Releases the colormap allocations on the screen. Use this only if your im:: /
;/ age is not visible any more the idea of this is to free the pens allocate:: /
;/ d for this picture on the screen to get free pens for other graphic opera:: /
;/ tions.                                                                      /
;/                                                                             /
;/ NOTE: after you have called this you have no guarrantee that your image i:: /
;/ s displayed with the right colors                                           /
;/ NOTE: on 16/24bit screens this has no visual effect, because the image al:: /
;/ locates no pens from the screens colormap                                   /
;/ NOTE: before you close a screen where did some blitting you MUST call thi:: /
;/ s function or free the images before                                        /
;/ NOTE: before you blit the image to another screen you MUST release it!      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Release{image.l}
SHARED imagedat()

  USEPATH imagedat(image)
  If \bitmap_ptr Then FreeBitMap_ \bitmap_ptr : \bitmap_ptr = False
  USELASTPATH
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_ReleaseAll{}                                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Same like image_Release{} but releases all blitted images.                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_ReleaseAll{}
SHARED imagedat()

  USEPATH imagedat(image)
  For image.l = 0 To #max_images-1
    If \isused Then image_Release{image}
  Next
  If imageengine\cmap Then cmap_Free{imageengine\cmap} : imageengine\cmap = 0
  USELASTPATH
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_FreeMask{image.l}                                             /
;/                                                                             /
;/ Description:                                                                /
;/ Frees the image data of a loaded image but the color allocations are stil:: /
;/ l present.                                                                  /
;/ NOTE: after you have called this you can not blit the image anymore.        /
;/ NOTE: use this if you want to free the memory of the image but it should :: /
;/ stay visible in the correct colors.                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID (valid range is from 0 to #max_images-1, look:: /
;/ on top for the maximum                                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_FreeMask{image.l}
SHARED imagedat()

  USEPATH imagedat(image)
  If \mask_ptr Then FreeVec_ \mask_ptr : \mask_ptr = False
  \mask_isused = False
  \is_solid    = 1
  USELASTPATH
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_FreeAlpha{image.l}                                            /
;/                                                                             /
;/ Description:                                                                /
;/ Free the alpha channel of an image.                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_FreeAlpha{image.l}
SHARED imagedat()

  USEPATH imagedat(image)
  \alpha_isused = False
  \is_solid     = 1
  USELASTPATH
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l =  image_AlphaIsUsed{image.l}                               /
;/                                                                             /
;/ Description:                                                                /
;/ Check if the image has an alpha channel attached.                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l    : -1, if the image has an alpha channel, 0 if not               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_AlphaIsUsed{image.l}

  If image >= 0 Then Function Return \alpha_isused
  Function Return False
End Function

Statement FAST image_ReuseAlpha{image.l}

  If image >= 0 Then \alpha_isused = True
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  image_MaskIsUsed{image.l}                              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_MaskIsUsed{image.l}

  If image >= 0 Then Function Return (\mask_ptr >< 0)
  Function Return False
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_FreeARGB{image.l}                                             /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_FreeARGB{image.l}
SHARED imagedat()

  image_UnlockForce{image.l}
  If \ARGBbitmap_ptr Then FreeBitMap_ \ARGBbitmap_ptr : \ARGBbitmap_ptr = 0 : \raw_ptr = 0
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_FreeBitMap{image.l}                                           /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/ Free the shadow bitmap of an image.                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_FreeBitMap{image.l}
SHARED imagedat()

  If \bitmap_ptr Then FreeBitMap_ \bitmap_ptr : \bitmap_ptr = False
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_FreeRP{image.l}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_FreeRP{image.l}
SHARED imagedat()

  If \layer_ptr Then DeleteLayer_ 0,\layer_ptr : \layer_ptr = 0
  If \layerinfo_ptr Then DisposeLayerInfo_ \layerinfo_ptr : \layerinfo_ptr = 0
  If \rastport_ptr Then \rastport_ptr = 0
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_FreeData{image.l}                                             /
;/                                                                             /
;/ Description:                                                                /
;/ Free all image data except the pen allocations on the screen.               /
;/ The image can not be blitted anymore, but can stay visible on the screen.   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_FreeData{image.l}
SHARED imagedat():USEPATH imagedat(image)

  image_FreeMask{image}
  image_FreeBitMap{image}
  image_FreeAlpha{image}
  image_FreeRP{image}
  image_FreeARGB{image}
  \filename = ""
  USELASTPATH
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Free{image.l}                                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Free a loaded image and its color allocations on the screen.                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Free{image.l}
SHARED imagedat()

  USEPATH imagedat(image)
  image_Release{image}
  image_FreeData{image}
  \handle_x       = 0
  \handle_y       = 0
  \mask_trgb      = -1
  \isused         = False
  \bmaplock       = 0
  \bmaplock_count = 0
  USELASTPATH
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_InitRP{image.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_InitRP{image.l}
SHARED imagedat()

  succ.l = False
  If \rastport_ptr Then Function Return -1
  If \ARGBbitmap_ptr
    \layerinfo_ptr = NewLayerInfo_
    If \layerinfo_ptr
  ;    \layer_ptr    =  CreateUpfrontLayer_ (\layerinfo_ptr,\ARGBbitmap_ptr,0,0,\img_width-1,\img_height-1,0,0)
      \layer_ptr =  CreateUpfrontHookLayer_ (\layerinfo_ptr,\ARGBbitmap_ptr,0,0,\img_width-1,\img_height-1,0,#LAYERS_NOBACKFILL,0)
      If \layer_ptr
        \rastport_ptr = \layer_ptr\rp
      Else
        error{"\\__THIS_FUNCTION: Unable to create upfront layer!"}
      End If
    Else
      error{"\\__THIS_FUNCTION : Unable to allocate LayerInfo!"}
    End If
  Else
    error{"\\__THIS_FUNCTION : Unable to get ARGB bitmap!"}
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_Create{image.l,img_width.l,img_height.l,@nofil::  /
;/ l.l,@argb.l}                                                                /
;/                                                                             /
;/ Description:                                                                /
;/ Create a new image object from scratch.                                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - img_width.l    : pixel width                                              /
;/ - img_height.l    : pixel height                                            /
;/ - nofill.l    : set this to 0 if you want to image to be filled with the :: /
;/ argb parameter                                                              /
;/ - argb.l    : ARGB value to fill the image width.                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_Create{image.l,img_width.l,img_height.l,@nofill.l,@argb.l}
SHARED imagedat(),imageengine

  USEPATH imagedat(image)
  If img_width < 1 OR img_height < 1 Then error{"\\__THIS_FUNCTION: Tried to create an image with invalid dimensions ("+Str$(img_width)+"x"+Str$(img_height)+")!"} : Function Return False
  If \isused
    If \img_width = img_width AND \img_height = img_height ; same dimensions ? then keep the bitmap!
      image_Release{image}
      image_FreeMask{image}
      image_FreeBitMap{image}
      image_FreeAlpha{image}
      image_FreeRP{image}
    Else
      image_Free{image}
    End If
  End If

  If \ARGBbitmap_ptr = 0 Then \ARGBbitmap_ptr = AllocBitMap_(img_width,img_height,24,#BMF_MINPLANES|#BMF_SPECIALFMT|(#PIXFMT_ARGB32 LSL #BMB_PIXFMT_SHIFTUP),0)
  If \ARGBbitmap_ptr
    ; set initial values
    \isused           = True
    ; ARGB bitmap
    \rastport_ptr     = 0
    \layerinfo_ptr    = 0
    \layer_ptr        = 0
    \raw_ptr          = Null ;\ARGBbitmap_ptr\Planes
    \bpr              = 0    ;\ARGBbitmap_ptr\BytesPerRow
    \bpp              = 4
    \bmaplock         = 0
    \bmaplock_count   = 0

    ; picture dimensions
    \img_height       = img_height
    \img_width        = img_width

    ; grab handle
    \handle_x         = 0
    \handle_y         = 0

    ; blit clip bounds
    \clip_x           = 0
    \clip_y           = 0
    \clip_xs          = \img_width
    \clip_ys          = \img_height

    ; Settings
    \mask_tolerance   = 1
    \mask_threshold   = 128
    \dither_threshold = 0
    \dither_mode      = #image_dithermode_none
    \mask_trgb        = -1
    \is_solid         = 1

    ; Mask
    \mask_ptr         = 0
    \mask_bytesize    = 0
    \mask_isused      = False
    \mask_bpr         = 0

    ; Shadow Bitmap
    \bitmap_ptr       = 0

    ; Alpha channel
    \alpha_isused     = False

    ; from file ?
    \filename         = ""

    ; set the dithermode based on a sophisticated guess
    ;If \img_width > 32 AND \img_height > 32  ; seems to be a big picture
    ;  \dithermode = #DITHERMODE_FS
    ;Else                                ; seems to be a gui element
    ;  \dithermode = #image_dithermode_none
    ;End If

    ; fill the image, if argb is set
    If nofill = False
      image_InitRP{image}
      If \rastport_ptr Then FillPixelArray_ \rastport_ptr,0,0,\img_width,\img_height,argb
      ;ptr.l = \raw_ptr
    End If

    image_Lock{image}
    image_Unlock{image}
  Else
    error{"\\__THIS_FUNCTION : Unable to allocate ARGB bitmap! ("+Str$(img_width)+"x"+Str$(img_height)+"x32)"}
  End If
  If \isused = False Then image_Free{image}
  Function Return \isused
  USELASTPATH
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  image.l = image_GetFree{}                                          /
;/                                                                             /
;/ Description:                                                                /
;/ Find a free image object ID.                                                /
;/ NOTE: This is useful if you load and display images dynamically, that mea:: /
;/ ns it is not predictable how many images you will use                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - image.l  : image object ID of a free image, ready to be loaded with ima:: /
;/ ge data, or -1 if all image IDs are in use.                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_GetFree{}
SHARED imagedat()

  image.l = 0
  While imagedat(image)\isused >< False AND image < #max_images-2 : image+1 : Wend
  If imagedat(image)\isused Then image = -1
  Function Return image
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  image.l = image_FindByName{filename.s}                             /
;/                                                                             /
;/ Description:                                                                /
;/ Find an already loaded image by filename. This return either the image ob:: /
;/ ject number or "-1" if the image could not be found.                        /
;/ NOTE: This is useful if you load and display images dynamically, and want:: /
;/  to check if the image is already loaded.                                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s : Filename including full path which you used originally to :: /
;/ load the image                                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - image.l    : Object number of a free image, ready to be loaded with ima:: /
;/ ge data                                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_FindByName{filename.s}
SHARED imagedat()

  retimage.l = -1
  For image.l = 0 To #max_images-1
    If imagedat(image)\isused
      If imagedat(image)\filename = filename.s
        retimage = image : image=#max_images
      End If
    End If
  Next
  Function Return retimage
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = image_GetFilename{image.l}                              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s image_GetFilename{image.l}
SHARED imagedat()

  Function Return imagedat(image)\filename
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_SetBlitBounds{image.l,@x1.l,@y1.l,@x2.l,@y2.l}                /
;/                                                                             /
;/ Description:                                                                /
;/ Set the clip bound of an image object. This is useful, if you plan to bli:: /
;/ t only a certain area of the image.                                         /
;/ The clip bounds work with most blit commands.                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image to attach the clip bounds to                              /
;/ - x1.l    : coordinates of the clipbounds within the image                  /
;/ - y1.l                                                                      /
;/ - x2.l                                                                      /
;/ - y2.l                                                                      /
;/                                                                             /
;/ Bugs:   This functionality is not fully implemented yet. For the time       /
;/         beeing, use image_BlitArea.                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_SetBlitBounds{image.l,@x1.l,@y1.l,@x2.l,@y2.l}
SHARED imagedat()

  If x1 < 0 Then x1 = 0
  If y1 < 0 Then y1 = 0
  If x2 > \img_width-1 OR x2 < 0 Then x2 = \img_width-1
  If y2 > \img_height-1 OR y2 < 0 Then y2 = \img_height-1
  \clip_x  = x1
  \clip_y  = y1
  \clip_xs = x2-x1+1
  \clip_ys = y2-y1+1
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_SetBlitDims{image.l,@x1.l,@y1.l,@xs.l,@ys.l}                  /
;/                                                                             /
;/ Description:                                                                /
;/ Set used blit dimenions for the source image                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image to attach the clip bounds to                              /
;/ - x1.l    : start position x                                                /
;/ - y1.l    : start position y                                                /
;/ - xs.l    : size x (width)                                                  /
;/ - ys.l    : size y (height)                                                 /
;/                                                                             /
;/ Bugs:   This functionality is not fully implemented yet. For the time       /
;/         beeing, use image_BlitArea.                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_SetBlitDims{image.l,@x1.l,@y1.l,@xs.l,@ys.l}

  If x1 < 0 Then x1 = 0
  If y1 < 0 Then y1 = 0
  x2.l = x1+xs-1 : y2.l = y1+ys -1
  image_SetBlitBounds{image,x1,y1,x2,y2}

End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_RemBlitDims{image.l}                                          /
;/                                                                             /
;/ Description:                                                                /
;/ Remove privius set Blittbounds and set it to image dimentions (size)        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image to remove the clip bounds                                 /
;/                                                                             /
;/ Bugs:   This functionality is not fully implemented yet. For the time       /
;/         beeing, use image_BlitArea.                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_RemBlitDims{image.l}

  image_SetBlitBounds{image}

End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_FreeAll{}                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Frees all loaded images and its color allocations on the screen.            /
;/ It is save to call this if no image was loaded.                             /
;/                                                                             /
;/ NOTE: you should always use this before you exit your program.              /
;/ NOTE: If you forget this, the autoexit handler ist doing this for you.      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_FreeAll{}
SHARED imagedat(),imageengine

  For image.l = 0 To #max_images-1
    image_Free{image}
  Next
  If imageengine\cmap
    cmap_Free{imageengine\cmap}
    imageengine\cmap = 0
  End If
  tempbuffer_Free{}
End Statement
!autoexit{image_FreeAll}

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.Rastport = image_GetRPPtr{image.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Get the pointer to the rastport of the image itself.                        /
;/                                                                             /
;/ Note: This is very useful if yoou want to redirect blit commands into oth:: /
;/ er images.                                                                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.rastport     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.RastPort image_GetRPPtr{image.l}

  If \rastport_ptr = 0 Then image_InitRP{image}
  Function Return \rastport_ptr
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_GetARGBPtr{image.l}                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_GetARGBPtr{image.l}

  Function Return \raw_ptr
End Function

Function.l image_GetARGBBpr{image.l}

  Function Return \bpr
End Function

Function.l image_GetARGBBitmapPtr{image.l}

  Function Return \ARGBbitmap_ptr
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_GetOpenGLTexturePtr{image.l}                      /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_GetOpenGLTexturePtr{image.l}

  For y.l = 0 To \img_height-1 ; convert to GBRA
    ptr.l = \raw_ptr + y*\bpr
    If \alpha_isused=False
      For x.l = 0 To \img_width-1
        ARGB.l = Peek.l(ptr)
        RGBA.l = (ARGB LSL 8) | $FF
        Poke.l ptr,RGBA
        ptr+4
      Next
    Else
      For x.l = 0 To \img_width-1
        ARGB.l = Peek.l(ptr)
        RGBA.l = (ARGB LSL 8) | (ARGB LSR 24)
        Poke.l ptr,RGBA
        ptr+4
      Next
    End If
  Next
  Function Return \raw_ptr
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_GetClipBounds{*rp.RastPort,minx.l,miny.l,maxx.l,maxy.l}      /
;/                                                                             /
;/ Description:                                                                /
;/ Get the outer clip bounds of a RastPort with a layer attached, relative t:: /
;/ o the underlying bitmap.                                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *rp.RastPort    : RastPort to get the clip bounds from                    /
;/ - minx.l    : x of top left edge                                            /
;/ - miny.l    : y of top left edge                                            /
;/ - maxx.l    : x of bottom right edge                                        /
;/ - maxy.l    : y of bottom right edge                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_GetClipBounds ;{*rp.RastPort,minx.l,miny.l,maxx.l,maxy.l}

  If `1\Layer
    If `1\Layer\ClipRegion
      *cliprec.Rectangle = `1\Layer\ClipRegion\bounds
      `2 = *cliprec\MinX
      `3 = *cliprec\MinY
      `4 = *cliprec\MaxX
      `5 = *cliprec\MaxY
    Else
    *cliprec = `1\Layer\bounds
    `2 = 0 ;*cliprec\MinX
    `3 = 0 ;*cliprec\MinY
    `4 = *cliprec\MaxX - *cliprec\MinX
    `5 = *cliprec\MaxY - *cliprec\MinY
    End If
  Else
    `2 = 0
    `3 = 0
    If `1\BitMap
      `4 = GetBitMapAttr_(`1\BitMap,#BMA_WIDTH)
      `5 = GetBitMapAttr_(`1\BitMap,#BMA_HEIGHT)
    Else
      `4 = 0
      `5 = 0
    End If
  End If
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_GetLayerOffset{*rp.RastPort,xoff,yoff}                       /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *rp.RastPort    : ???                                                     /
;/ - xoff    : ???                                                             /
;/ - yoff    : ???                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_GetLayerOffset ;{*rp.RastPort,xoff,yoff}

  If `1\Layer
    *cliprec.Rectangle = `1\Layer\bounds
    `2 = *cliprec\MinX
    `3 = *cliprec\MinY
  Else
    `2 = 0
    `3 = 0
  End If
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_GetRPDims{*rp.RastPort,x_ptr.l,y_ptr.l,xs_ptr.l,ys_ptr.l}     /
;/                                                                             /
;/ Description:                                                                /
;/ Get the rastports maximum dimensions.                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *rp.RastPort    : pointer to a rastport                                   /
;/ - x_ptr.l    : pointer to a .l variable                                     /
;/ - y_ptr.l    : pointer to a .l variable                                     /
;/ - xs_ptr.l    : pointer to a .l variable                                    /
;/ - ys_ptr.l    : pointer to a .l variable                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_GetRPDims{*rp.RastPort,x_ptr.l,y_ptr.l,xs_ptr.l,ys_ptr.l}

  Poke.l x_ptr, 0
  Poke.l y_ptr, 0

  If *rp\Layer
    Poke.l xs_ptr, *rp\Layer\Width
    Poke.l ys_ptr, *rp\Layer\Height
  Else
    If *rp\BitMap
      Poke.l xs_ptr, GetBitMapAttr_(*rp\BitMap,#BMA_WIDTH)
      Poke.l ys_ptr, GetBitMapAttr_(*rp\BitMap,#BMA_HEIGHT)
    Else
      Poke.l xs_ptr, 0
      Poke.l ys_ptr, 0
    End If
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_IsPictureDT{filename.s}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Test, if this file can be loaded via Datatypes.                             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : file name of the image file to test                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if the image can be loaded via datatype, 0 otherwise    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_IsPictureDT{filename.s}
SHARED imageengine

  succ.l = False
  numimg.l = #PDTANUMPICTURES_Unknown
  tag5.tag5\ti_Tag = #DTA_SourceType,#DTST_FILE,#DTA_GroupID,#GID_PICTURE,#PDTA_DestMode,#PMODE_V43,#PDTA_GetNumPictures,&numimg.l,#TAG_DONE,0
  *DTPic._Object = NewDTObjectA_ (&filename.s,tag5)
  If *DTPic
    succ = True
    tag5.tag5\ti_Tag = #PDTA_BitMapHeader,&*bmhdp.BitMapHeader,#TAG_DONE,0
    If GetDTAttrsA_ (*DTPic,tag5) = 0 Then *bmhdp = 0
    tag5.tag5\ti_Tag = #PDTA_NumColors,&colors.l,#TAG_DONE,0
    If GetDTAttrsA_ (*DTPic,tag5) = 0 Then colors = 0
    If numimg = #PDTANUMPICTURES_Unknown Then numimg = 1
    DisposeDTObject_(*DTPic)
    If *bmhdp
      imageengine\exWidth  = *bmhdp\bmh_Width
      imageengine\exHeight = *bmhdp\bmh_Height
      imageengine\exDepth  = *bmhdp\bmh_Depth
    End If
    imageengine\exNumImg = numimg
    If colors = 0 Then imageengine\exDepth = 24 ; what an assumption!
    ;error{"Reported depth: "+Str$(imageengine\exDepth)+" | colors: "+Str$(colors)+" colorMap: "+Hex$(colorMap)+" cRegs:"+Hex$(cRegs)}
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_ExtractAlpha{image.l,alpha_ptr.l,alpha_bpr.l,@::  /
;/ threshold.l}                                                                /
;/                                                                             /
;/ Description:                                                                /
;/ Extract the alpha mask found in the ARGB pixelformat and prepare it to us:: /
;/ e with the image.include.                                                   /
;/ NOTE: for private use only !                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - alpha_ptr.l    : pointer to an ARGB pixel array                           /
;/ - alpha_bpr.l    : bytes per row of the ARGB pixel array                    /
;/ - threshold.l    : theshold for setting alpha values to 0                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_ExtractAlpha{image.l,alpha_ptr.l,alpha_bpr.l,@threshold.l}
SHARED imagedat(),imageengine,imgargs()

  USEPATH imagedat(image)
  succ.l = False
  If alpha_ptr
    If image_Lock{image}
      If threshold < 0 Then threshold = 1
      bpp.l = \bpp
      For y.l = 0 To \img_height-1
        ptr.l  = \raw_ptr + \bpr * y
        aptr.l = alpha_ptr  + alpha_bpr*y
        For x.l = 0 To \img_width-1
          A.l  = Peek.l(ptr) LSR 24
          If A < threshold Then A = 0
          Poke.b aptr,A
          aptr+1
          ptr+bpp
        Next
      Next
      image_Unlock{image}
      succ = True
    End If
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_OptimizeAlpha{image.l,threshold.l}                /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - threshold.l    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_OptimizeAlpha{image.l,threshold.l}
SHARED imagedat(),imageengine,imgargs()

  USEPATH imagedat(image)
  succ.l = False
  If threshold < 0 Then threshold = 10
  ithreshold.l = 255 - threshold
    If image_Lock{image}
      bpp.l = \bpp
      For y.l = 0 To \img_height-1
        ptr.l  = \raw_ptr + \bpr * y
        For x.l = 0 To \img_width-1
          ARGB.l  = Peek.l(ptr)
          A.l = ARGB LSR 24
          If A<=threshold  Then A = 0
          If A >= ithreshold Then A = 255
          ARGB.l = (ARGB & $00FFFFFF) | (A LSL 24)
          Poke.l ptr,ARGB
          ptr+bpp
        Next
      Next
      image_Unlock{image}
      succ = True
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_CreateAlpha{image.l,@trgb.l,@tolerance.l,@aima::  /
;/ ge.l,@threshold.l}                                                          /
;/                                                                             /
;/ Description:                                                                /
;/ Create an alpha channel for the given image object.                         /
;/ The alpha channel can be either created by supplying the trgb and toleran:: /
;/ ce paramters, that choose                                                   /
;/ an RGB color with a tolerance to build the transparency, or by supplying :: /
;/ another image object by aimage.                                             /
;/ The aimage object will be converted to greyscale and used as the alpha ma:: /
;/ sk.                                                                         /
;/ NOTE: aimage and image can be identical                                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l  : image object ID that will get the alpha mask attached          /
;/ - trgb.l    : RGB value to use as the transparent color, e.g. $FF0000 for:: /
;/ red.                                                                        /
;/ - tolerance.l    : tolerance around the trgb value, 1...255                 /
;/ - aimage.l : Number of the image that will be converted to greyscale and :: /
;/ used as alpha mask                                                          /
;/ - threshold.l: Use this to set vallues below theshold to 0 (=transparent):: /
;/ and values above 255-threshold to 255 (=opaque)                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_CreateAlpha{image.l,@trgb.l,@tolerance.l,@aimage.l,@threshold.l,@set.l}
SHARED imagedat(),imageengine,imgargs()

  USEPATH imagedat(image)
  succ.l = False
  If threshold < 0 Then threshold = 1
  If tolerance < 0 Then tolerance = 32
  If tolerance = 0 Then tolerance = 1
  If trgb = -1 Then trgb = $000000
  If aimage.l = -1 Then aimage.l = image

  If \img_width >< imagedat(aimage)\img_width OR \img_height >< imagedat(aimage)\img_height
    error{"\\__THIS_FUNCTION: images do not have the same dimensions!"}
    Function Return False
  End If

  If image_Lock{image}
    If image_Lock{aimage}
      If set Then image_FreeAlpha{image}
      Bt.l = (trgb & $FF    )
      Gt.l = (trgb & $FF00  ) LSR 8
      Rt.l = (trgb & $FF0000) LSR 16
      ratio.l = (256)/tolerance
      For y.l = 0 To \img_height-1
        ptr.l = \raw_ptr + \bpr * y
        aptr.l = imagedat(aimage)\raw_ptr + imagedat(aimage)\bpr*y
        For x.l = 0 To \img_width-1
          rgbv.l  = Peek.l(ptr)
          alpha.l = Peek.l(aptr)

          Ba.l    = (alpha & $FF    )
          Ga.l    = (alpha & $FF00  ) LSR 8
          Ra.l    = (alpha & $FF0000) LSR 16

          Bd.l    = Bt-Ba  : If Bd<0 Then Bd=-Bd
          Gd.l    = Gt-Ga  : If Gd<0 Then Gd=-Gd
          Rd.l    = Rt-Ra  : If Rd<0 Then Rd=-Rd

          A.l     = ((Rd + Gd + Bd) * ratio) / 3

          If set = False Then A = A + (rgbv LSR 24)

          If A > 255 Then A = 255
          If A < threshold Then A = 0
          Poke.l ptr,(rgbv & $00FFFFFF) | (A LSL 24)
          ptr + \bpp
          aptr + imagedat(aimage)\bpp
        Next
      Next
      succ          = True
      \alpha_isused = True
      \is_solid     = 1
      image_Unlock{aimage}
    Else
      error{"\\__THIS_FUNCTION: uninitialized alpha image!"}
    End If
    image_Unlock{image}
  Else
    error{"\\__THIS_FUNCTION: uninitialized image!"}
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_AttachAlpha{image.l,alpha_ptr.l,@threshold.l}     /
;/                                                                             /
;/ Description:                                                                /
;/ Attach an external alpha mask (8 bit pixelarray) to the picture. The pixe:: /
;/ l array will be doublicated and can be freed after attaching it.            /
;/ The optional threshold parameter can be used to set almost transparent pi:: /
;/ xels to be completely transparent. The picture might be blittet slightly :: /
;/ faster. A threshold of 10-20 is reasonable and will not change the visual:: /
;/  effect a lot.                                                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object number                                          /
;/ - alpha_ptr.l    : pointer to an 8 bit pixel array containing the alpha c:: /
;/ hannel (0= transparent, 255=full opaque)                                    /
;/ - threshold.l    : threshold to cut almost transparent pixels of            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_AttachAlpha{image.l,alpha_ptr.l,@threshold.l}
SHARED imagedat(),imageengine,imgargs()

  USEPATH imagedat(image)
  succ.l = False
  If image_Lock{image}
    If threshold < 0 Then threshold = 1
    For y.l = 0 To \img_height-1
      aptr.l = alpha_ptr + \img_width * y
      ptr.l  = \raw_ptr + \bpr * y
      For x.l = 0 To \img_width-1
        rgbv.l = Peek.l(ptr) & $00FFFFFF
        A.l = Peek.b(aptr) &$FF
        If A < threshold Then A = 0
        A      = A LSL 24
        rgbv.l = rgbv | A
        Poke.l ptr,rgbv
        ptr + \bpp
        aptr + 1
      Next
    Next
    succ          = True
    \alpha_isused = True
    image_Unlock{image}
  Else
    error{"\\__THIS_FUNCTION: Uninitialized image!"}
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_SetAlpha{image.l,A.l}                             /
;/                                                                             /
;/ Description:                                                                /
;/ Set the alpha channel of an image to a fix value.                           /
;/ NOTE: This can be used to flush an aplha channel (A=$0) or to set it opaq:: /
;/ ue (A=$FF)                                                                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - A.l    : alpha value                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_SetAlpha{image.l,A.l}
SHARED imagedat(),imageengine,imgargs()

  USEPATH imagedat(image)
  succ.l = False
  If A > 255 Then A = 255
  If A < 0 Then A = 0
  A = A LSL 24
  bpp.l = \bpp
  If image_Lock{image}
    For y.l = 0 To \img_height-1
      ptr.l = \raw_ptr + \bpr * y
      For x.l = 0 To \img_width-1
        rgbv.l  = (Peek.l(ptr) & $00FFFFFF) | A
        Poke.l ptr,rgbv
        ptr + bpp
      Next
    Next
    succ          = True
    \alpha_isused = True
    image_Unlock{image}
  Else
    error{"\\__THIS_FUNCTION: Uninitialized image!"}
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_AllocMask{image.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Creates an 1 bit mask makeing the given rgb value transparent for use wit:: /
;/ h image_BlitMask{}                                                          /
;/                                                                             /
;/ It is save to call this function several times to update the mask if the :: /
;/ image has changed                                                           /
;/ NOTE: This function is called automatically if you pass a transparent col:: /
;/ or value to the image_Load function                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l   : image object ID                                               /
;/ - trgb.l    : rgbvalue for the desired transparent color, e.g. $ff0000 fo:: /
;/ r red                                                                       /
;/ - tolerance.l : optional the tolerance in 1/256 steps. Default is 1         /
;/ - threshold.l    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_AllocMask{image.l}
SHARED imagedat(),imgargs()

  USEPATH imagedat(image)
  If \mask_ptr = False
    wordwidth.l    = ((\img_width+15) LSR 4)
    bytewidth.l    = wordwidth LSL 1
    \mask_bpr      = bytewidth
    bytesize.l     = bytewidth*\img_height
    \mask_ptr      = AllocVec_(bytesize+32,0)
    \mask_bytesize = bytesize+32
  End If
  Function Return \mask_ptr
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_InitMask{image.l,@trgb.l,@tolerance.l,@threshold.l}           /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - trgb.l    : ???                                                           /
;/ - tolerance.l    : ???                                                      /
;/ - threshold.l    : ???                                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_InitMask{image.l,@trgb.l,@tolerance.l,@threshold.l}
SHARED imagedat(),imgargs()

  USEPATH imagedat(image)
  If image_Lock{image}
    If tolerance < 1 Then tolerance = \mask_tolerance
    If threshold < 1 Then threshold = \mask_threshold
    \mask_tolerance = tolerance
    \mask_threshold = threshold
    \mask_trgb      = trgb
    succ.l          = True
    threshold2.l    = threshold/4

    ;  ExtractColor_ \rp,plbmap,trgb,0,0,\img_width,\img_height
    ; if bitmask is requested with a trgb=-1, then the alpha mask is used to generate the bitmask
    If trgb >= 0
      succ & image_CreateAlpha{image,trgb,tolerance,image,1} : remalpha.l = True
    Else
      remalpha = False
    End If
    If succ
      image_AllocMask{image}
      bytewidth.l = \mask_bpr
      wordwidth.l = bytewidth/2
      If \mask_ptr
        If \alpha_isused
          A.l = 0
          For y.l = 0 To \img_height-1
            ptr.l  = \raw_ptr   + \bpr * y
            mptr.l = \mask_ptr  + bytewidth * y
            For w.l = 0 To wordwidth-1
              plane.l = 0
              bit.l   = 1 LSL 15
              w4.l    = w LSL 4
              maxw.l  = Min(w4+16,\img_width)
              For x.l = w4 To maxw -1
                ;A = (A ASR 1) + ((Peek.l(ptr) LSR 24) & $FF)
                ;If A > threshold Then plane = plane | bit : A-255
                argb.l = Peek.l(ptr)
                A.l    = argb LSR 24
                rgb_.l = argb &$00F0F0F0
                If (argb LSR 24)>threshold Then plane = plane | bit

                If \dither_mode
                  s.l = (x+y)&1
                  If s Then If (A>threshold2) AND rgb_=0 Then plane = plane | bit
                End If

                bit LSR 1
                ptr + \bpp
              Next
              Poke.w mptr,plane
              mptr+2
            Next
          Next
        Else ; make block mask
          mptr.l = \mask_ptr
          For n.l = 0 To (\img_height*\mask_bpr/2)-1
            Poke.w mptr,$FFFF : mptr+2
          Next
        End If
        \mask_isused = True
      Else
        error{"\\__THIS_FUNCTION: Unable to allocate mask memory!"}
      End If
      If remalpha Then image_FreeAlpha{image}
    Else
      error{"\\__THIS_FUNCTION: Unable to create alphamask!"}
    End If
    image_Unlock{image}
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !penale                                                             /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro penale

  If errX>errt
    `1 + errmask`1
    errX-errmask`1
    err`1-errmask`1
  End If
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Dither{image.l,@bit.l,@dithermode.l}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Simulate dithering on a 24 bit image.                                       /
;/ This can be used to prepare an image for use on a 16 or 8bit bit screen.    /
;/ NOTE: dithering to 16bit will use 5(R):6(G):5(B) pixelformat, this can le:: /
;/ ad to slightly wrong colors if your screen uses 5(R):5(G):5(B) pixelforma:: /
;/ t. Use 15bit dithering in that case.                                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - bit.l    : number of virtual bits [1...24]                                /
;/ - dithermode.l    : dither mode, must be one of                             /
;/     #image_dithermode_default      = -1 ; default, currently errnoisefast   /
;/     #image_dithermode_none         = 0  ; no dithering, simple bit trunca:: /
;/ tion                                                                        /
;/     #image_dithermode_err          = 1  ; error dithering, looks like FS :: /
;/ dithering                                                                   /
;/     #image_dithermode_noise        = 2  ; pure noise dithering              /
;/     #image_dithermode_tk           = 3  ; Thilo's special experimental di:: /
;/ thering                                                                     /
;/     #image_dithermode_errnoise     = 4  ; error + noise dithering           /
;/     #image_dithermode_noneshift    = 5  ; no dithering, but shifting, mig:: /
;/ ht be better than just truncation                                           /
;/     #image_dithermode_errnoisefast = 6  ; error + noise dithering, fast v:: /
;/ ersion                                                                      /
;/     #image_dithermode_errfast      = 7  ; error dithering, fast version     /
;/     #image_dithermode_errnoiseadd  = 8  ; error in add mode + noise dithe:: /
;/ ring, experimental                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Dither{image.l,@bit.l,@dithermode.l}
SHARED imagedat(),imageengine

  seed.l = $6F3531A1
  ;bitR.l = bit/3           ; 8/3 = 2        7/3 = 2
  ;bitB.l = (bit-bitR)/2    ; 8-2/2 = 3      7-2/2 ) = 2
  ;bitG.l = bit-bitR-bitB   ; 8-2-3 = 3      7-2-2 = 3

  ;bitG.l = bit/3           ; 8/3 = 2        7/3 = 2
  ;bitB.l = (bit-bitG)/2    ; 8-2/2 = 3      7-2/2 ) = 2
  ;bitR.l = bit-bitG-bitB   ; 8-2-3 = 3      7-2-2 = 3

  bitB.l = bit/3           ; 8/3 = 2        7/3 = 2
  bitR.l = (bit-bitB)/2    ; 8-2/2 = 3      7-2/2 ) = 2
  bitG.l = bit-bitR-bitB   ; 8-2-3 = 3      7-2-2 = 3


  bitmaskR.l = $FF - ((1 LSL (8-bitR))-1)
  bitmaskG.l = $FF - ((1 LSL (8-bitG))-1)
  bitmaskB.l = $FF - ((1 LSL (8-bitB))-1)
  bitmaskA.l = $FF
  bitmaskARGB.l = bitmaskR | (bitmaskG LSL 8) | (bitmaskB LSL 16) | (bitmaskA LSL 24)

  errmaskR.l = (NOT(bitmaskR)) & $FF
  errmaskG.l = (NOT(bitmaskG)) & $FF
  errmaskB.l = (NOT(bitmaskB)) & $FF
  errmaskARGB.l = errmaskR | (errmaskG LSL 8) | (errmaskB LSL 16) | 0

  noisemaskR.l = errmaskR
  noisemaskG.l = errmaskG
  noisemaskB.l = errmaskB
  noisemaskARGB.l = noisemaskR | (noisemaskG LSL 8) | (noisemaskB LSL 16) | 0

  shiftR.l =  errmaskR LSR 1
  shiftG.l =  errmaskG LSR 1
  shiftB.l =  errmaskB LSR 1

  dynlossR.l = 255*256/bitmaskR
  dynlossG.l = 255*256/bitmaskG
  dynlossB.l = 255*256/bitmaskB

  errR.l = 0
  errG.l = 0
  errB.l = 0

  If dithermode = #image_dithermode_default Then dithermode = #image_dithermode_errnoise

  Select dithermode
    Case #image_dithermode_err ; strictly error dithering , ok
      For y.l = 0 To \img_height-1
        ptr.l = \raw_ptr + y * \bpr
        For x.l = 0 To \img_width-1
          R.l = (Peek.b(ptr+1)&$FF)
          G.l = (Peek.b(ptr+2)&$FF)
          B.l = (Peek.b(ptr+3)&$FF)

          Re.l = R + errR
          Ge.l = G + errG
          Be.l = B + errB
          If Re > 255 Then Re = 255
          If Ge > 255 Then Ge = 255
          If Be > 255 Then Be = 255
          If Re < 0 Then Re = 0
          If Ge < 0 Then Ge = 0
          If Be < 0 Then Be = 0

          Rq.l = ((Re & bitmaskR) * dynlossR) ASR 8  ;: If Rq>255 Then Rq=255
          Gq.l = ((Ge & bitmaskG) * dynlossG) ASR 8  ;: If Gq>255 Then Gq=255
          Bq.l = ((Be & bitmaskB) * dynlossB) ASR 8  ;: If Bq>255 Then Bq=255

          errR = (errR *7) ASR 3
          errG = (errG *7) ASR 3
          errB = (errB *7) ASR 3

          errR.l + R-Rq
          errG.l + G-Gq
          errB.l + B-Bq

          Poke.b ptr+1,Rq
          Poke.b ptr+2,Gq
          Poke.b ptr+3,Bq
          ptr +4
        Next
      Next

    Case #image_dithermode_noise ; strictly noise dithering
  ;    noisemaskR LSR 1 : noisemaskG LSR 1 : noisemaskB LSR 1
   ;   shiftR LSR 1 : shiftG LSR 1 : shiftB LSR 1
      For y.l = 0 To \img_height-1
        ptr.l = \raw_ptr + y * \bpr
        For x.l = 0 To \img_width-1
          seed = seed * 196314165 + 907633515
          R.l = ((Peek.b(ptr+1) & $FF) LSL 8) / dynlossR + ((seed LSR  8 ) & noisemaskR) ;+ shiftR
          G.l = ((Peek.b(ptr+2) & $FF) LSL 8) / dynlossG + ((seed LSR 16 ) & noisemaskG) ;+ shiftG
          B.l = ((Peek.b(ptr+3) & $FF) LSL 8) / dynlossB + ((seed LSR 24 ) & noisemaskB) ;+ shiftB
          If R > 255 Then R = 255
          If G > 255 Then G = 255
          If B > 255 Then B = 255
          If R < 0 Then R = 0
          If G < 0 Then G = 0
          If B < 0 Then B = 0

          Poke.b ptr+1,((R & bitmaskR) * dynlossR) ASR 8
          Poke.b ptr+2,((G & bitmaskG) * dynlossG) ASR 8
          Poke.b ptr+3,((B & bitmaskB) * dynlossB) ASR 8
          ptr +4
        Next
      Next

    Case #image_dithermode_none  ; strictly no dithering and no shifting
      For y.l = 0 To \img_height-1
        ptr.l = \raw_ptr + y * \bpr
        For x.l = 0 To \img_width-1
          C.l = Peek.l(ptr)
          Cx.l = (C & bitmaskARGB)
          Poke.l ptr,Cx
          ptr +4
        Next
      Next

    Case #image_dithermode_noneshift ; no dither, but shift!
      bitmaskR | $100
      bitmaskG | $100
      bitmaskB | $100
      For y.l = 0 To \img_height-1

        ptr.l = \raw_ptr + y * \bpr
        For x.l = 0 To \img_width-1
          R.l = (Peek.b(ptr+1)&$FF)
          G.l = (Peek.b(ptr+2)&$FF)
          B.l = (Peek.b(ptr+3)&$FF)
  ;        Poke.b ptr+1,((R & bitmaskR) * dynlossR) ASR 8
  ;        Poke.b ptr+2,((G & bitmaskG) * dynlossG) ASR 8
  ;        Poke.b ptr+3,((B & bitmaskB) * dynlossB) ASR 8
  ;        Poke.b ptr+1,((R * dynlossR) ASR 8)            & bitmaskR
  ;        Poke.b ptr+2,((G * dynlossG) ASR 8)            & bitmaskG
  ;        Poke.b ptr+3,((B * dynlossB) ASR 8)            & bitmaskB

          R = ((R+shiftR) & bitmaskR)
          G = ((G+shiftG) & bitmaskG)
          B = ((B+shiftB) & bitmaskB)

          ;R = (R* dynlossR) ASR 8
          ;G = (G* dynlossG) ASR 8
          ;B = (B* dynlossB) ASR 8

          If R > 255 Then R = 255
          If G > 255 Then G = 255
          If B > 255 Then B = 255

          Poke.b ptr+1,R
          Poke.b ptr+2,G
          Poke.b ptr+3,B
          ptr +4
        Next
      Next

    Case #image_dithermode_tk
      noisemaskR LSR 1 : noisemaskG LSR 1 : noisemaskB LSR 1
      errt.l      = (errmaskR+errmaskG+errmaskB)/3 /2
      dynloss1R.l = 255*256/(bitmaskR )
      dynloss1G.l = 255*256/(bitmaskG )
      dynloss1B.l = 255*256/(bitmaskB )

      For y.l = 0 To \img_height-1
        seed.l = seed * 196314165 + 907633515
        errR.l = ((seed LSR  8) &errmaskR)
        errG.l = ((seed LSR 16) &errmaskG)
        errB.l = ((seed LSR 24) &errmaskB)
        ptr.l = \raw_ptr + y * \bpr
        For x.l = 0 To \img_width-1
          R.l  = ((Peek.b(ptr+1)&$FF)); LSL 8) / dynloss1R + shiftR
          G.l  = ((Peek.b(ptr+2)&$FF)); LSL 8) / dynloss1G + shiftG
          B.l  = ((Peek.b(ptr+3)&$FF)); LSL 8) / dynloss1B + shiftB
          seed = seed * 196314165 + 907633515
          R.l  = R-((seed LSR 8) &noisemaskR)  ;:
          G.l  = G-((seed LSR 6) &noisemaskG) ;: seed = seed * 196314165 + 907633515
          B.l  = B-((seed LSR 4) &noisemaskB) ;: seed = seed * 196314165 + 907633515

          errR + (R & errmaskR)
          errG + (G & errmaskG)
          errB + (B & errmaskB)

          errX.l = errR+errG+errB
          If errR > errB
            If errR >= errG
              c.l = 0
            Else
              c = 1
            End If
          Else
            If errG >= errB
              c = 1
            Else
              c = 2
            End If
          End If
          d.l = (x+y) MOD 2

          If d = 0
            If c = 0
              !penale{R}
              !penale{G}
              !penale{B}
            End If
            If c = 1
              !penale{G}
              !penale{B}
              !penale{R}
            End If
            If c = 2
              !penale{B}
              !penale{R}
              !penale{G}
            End If
          Else
            If c = 0
              !penale{R}
              !penale{B}
              !penale{G}
            End If
            If c = 1
              !penale{G}
              !penale{R}
              !penale{B}
            End If
            If c = 2
              !penale{B}
              !penale{G}
              !penale{R}
            End If
          End If

          Ri.l = R
          Gi.l = G
          Bi.l = B
          If Ri > 255 Then Ri = 255 ;:errR = 0
          If Ri < 0 Then Ri = 0
          If Gi > 255 Then Gi = 255 ;:errG = 0
          If Gi < 0 Then Gi = 0
          If Bi > 255 Then Bi = 255 ;:errB = 0
          If Bi < 0 Then Bi = 0
          Rx.l = (((Ri) & bitmaskR) * dynloss1R) ASR 8
          Gx.l = (((Gi) & bitmaskG) * dynloss1G) ASR 8
          Bx.l = (((Bi) & bitmaskB) * dynloss1B) ASR 8
          Poke.b ptr+1,Rx
          Poke.b ptr+2,Gx
          Poke.b ptr+3,Bx
          ptr +4
        Next
      Next

    Case #image_dithermode_errnoiseadd ; experimental
      ;noisemaskR LSR 1 : noisemaskG LSR 1 : noisemaskB LSR 1
      For y.l = 0 To \img_height-1
        seed.l = seed * 196314165 + 907633515
        errR.l = ((seed LSR  8) &errmaskR)
        errG.l = ((seed LSR 16) &errmaskG)
        errB.l = ((seed LSR 24) &errmaskB)
        ptr.l  = \raw_ptr + y * \bpr
        For x.l = 0 To \img_width-1
          seed = seed * 196314165 + 907633515
          R.l  = (Peek.b(ptr+1)&$FF)  ;+errR
          G.l  = (Peek.b(ptr+2)&$FF)  ;+errG
          B.l  = (Peek.b(ptr+3)&$FF)  ;+errB

          Ri.l = R+errR +((seed LSR 8 ) &noisemaskR) -shiftR
          Gi.l = G+errG +((seed LSR 16) &noisemaskG) -shiftG
          Bi.l = B+errB +((seed LSR 24) &noisemaskB) -shiftB
          If Ri > 255 Then Ri = 255 ;:errR = 0
          If Ri < 0 Then Ri = 0
          If Gi > 255 Then Gi = 255 ;:errG = 0
          If Gi < 0 Then Gi = 0
          If Bi > 255 Then Bi = 255 ;:errB = 0
          If Bi < 0 Then Bi = 0
          Rx.l   = (((Ri) & bitmaskR)  * dynlossR) ASR 8
          Gx.l   = (((Gi) & bitmaskG)  * dynlossG) ASR 8
          Bx.l   = (((Bi) & bitmaskB)  * dynlossB) ASR 8
          errR.l = R-Rx
          errG.l = G-Gx
          errB.l = B-Bx
          Poke.b ptr+1,Rx
          Poke.b ptr+2,Gx
          Poke.b ptr+3,Bx
          ptr +4
        Next
      Next

    Case #image_dithermode_errnoise ; ok
      noisemaskR LSR 1 : noisemaskG LSR 1 : noisemaskB LSR 1
      shiftR LSR 1 : shiftG LSR 1 : shiftB LSR 1
      For y.l = 0 To \img_height-1
        seed.l = seed * 196314165 + 907633515
        errR.l = ((seed LSR  8) &errmaskR)
        errG.l = ((seed LSR 16) &errmaskG)
        errB.l = ((seed LSR 24) &errmaskB)
        ptr.l = \raw_ptr + y * \bpr
        For x.l = 0 To \img_width-1
          seed = seed * 196314165 + 907633515
          R.l = (Peek.b(ptr+1)&$FF) +((seed LSR 16) &noisemaskR)  - shiftR
          G.l = (Peek.b(ptr+2)&$FF) +((seed LSR 16) &noisemaskG)  - shiftG
          B.l = (Peek.b(ptr+3)&$FF) +((seed LSR 16) &noisemaskB)  - shiftB

          Re.l = R +errR ;+((seed LSR 16) &noisemaskR)  - shiftR
          Ge.l = G +errG ;+((seed LSR 16) &noisemaskG)  - shiftG
          Be.l = B +errB ;+((seed LSR 16) &noisemaskB)  - shiftB
          If Re > 255 Then Re = 255
          If Ge > 255 Then Ge = 255
          If Be > 255 Then Be = 255
          If Re < 0 Then Re = 0
          If Ge < 0 Then Ge = 0
          If Be < 0 Then Be = 0
          Rq.l = ((Re & bitmaskR) * dynlossR) ASR 8
          Gq.l = ((Ge & bitmaskG) * dynlossG) ASR 8
          Bq.l = ((Be & bitmaskB) * dynlossB) ASR 8

          errR = (errR *7) ASR 3
          errG = (errG *7) ASR 3
          errB = (errB *7) ASR 3

          errR.l + R-Rq
          errG.l + G-Gq
          errB.l + B-Bq
          Poke.b ptr+1,Rq
          Poke.b ptr+2,Gq
          Poke.b ptr+3,Bq
          ptr +4
        Next
      Next

    Case #image_dithermode_errfast
      bitmaskARGB   = (bitmaskARGB & $FEFEFEFE) LSR 1
      tstmaskARGB.l = $00808080
      For y.l = 0 To \img_height-1
        errARGB.l = 0
        ptr.l     = \raw_ptr + y * \bpr
        For x.l = 0 To \img_width-1
          ARGB.l = ((Peek.l(ptr)&$FEFEFEFE) LSR 1) + errARGB
          If (ARGB & tstmaskARGB)
            If ARGB & $00000080 Then ARGB = ARGB &$FFFFFF00 | $0000007F
            If ARGB & $00008000 Then ARGB = ARGB &$FFFF00FF | $00007F00
            If ARGB & $00800000 Then ARGB = ARGB &$FF00FFFF | $007F0000
          End If
          ARGBq.l = (ARGB & bitmaskARGB)
          errARGB.l = ARGB-ARGBq
          Poke.l ptr,(ARGBq LSL 1)
          ptr +4
        Next
      Next

    Case #image_dithermode_errnoisefast ; err + noise fast
      ;noisemaskARGB = (noisemaskARGB & $FCFCFCFC) LSR 2
      noisemaskARGB = (noisemaskARGB & $FEFEFEFE) LSR 1
      bitmaskARGB   = (bitmaskARGB & $FEFEFEFE) LSR 1
      errmaskARGB   = (errmaskARGB & $FEFEFEFE) LSR 1
      tstmaskARGB.l = $00808080

      For y.l = 0 To \img_height-1
        seed.l * 196314165 + 907633515
        errARGB.l = (seed & errmaskARGB)
        ptr.l     = \raw_ptr + y * \bpr
        For x.l = 0 To \img_width-1
          seed * 196314165 + 907633515
          ARGB.l = ((Peek.l(ptr)&$FEFEFEFE) LSR 1) + errARGB + (seed & noisemaskARGB)
          If (ARGB & tstmaskARGB)
            If ARGB & $00000080 Then ARGB = ARGB &$FFFFFF00 | $0000007F
            If ARGB & $00008000 Then ARGB = ARGB &$FFFF00FF | $00007F00
            If ARGB & $00800000 Then ARGB = ARGB &$FF00FFFF | $007F0000
          End If
          ARGBq.l = (ARGB & bitmaskARGB)
          errARGB.l = ARGB-ARGBq
          Poke.l ptr,(ARGBq LSL 1)
          ptr +4
        Next
      Next
  End Select
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_AddToHistory{image.l}                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_AddToHistory{image.l}
SHARED imagedat()

  If imageengine\cmap = 0 Then imageengine\cmap = cmap_Init{}
  cmap_InitHistory{imageengine\cmap}
  If image_Lock{image}
    cmap_AddPixelArrayToHistory{imageengine\cmap,\raw_ptr,\img_width,\img_height,\bpr}
    image_Unlock{image}
  End If
End Statement

Statement image_CreateCMapFromHistory{}

  If imageengine\cmap = 0 Then imageengine\cmap = cmap_Init{}
  cmap_UpdateFromHistory{imageengine\cmap}
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_InitBitMap{image.l,@*friendlybitmap.BitMap}       /
;/                                                                             /
;/ Description:                                                                /
;/ Creates an OS friendly bitmap out of the given image.                       /
;/                                                                             /
;/ NOTE: This image can only be blittet to the same screen. If you change th:: /
;/ e screen you have to release this image and call this function again.       /
;/ NOTE: This function is called automatically at the first blit command, so:: /
;/  there is normally no need to call this manually.                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID                                                 /
;/ - *friendlybitmap.BitMap : friendly bitmap                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_InitBitMap{image.l,@*friendlybitmap.BitMap,@*cmap.cmap}
SHARED imagedat(),imageengine

  DEFTYPE.RastPort temprp
  USEPATH imagedat(image)
  succ.l = False
  If image_Lock{image}
    If *cmap = -1 Then *cmap = 0
    If *friendlybitmap = -1
      *friendlybitmap.BitMap = 0
      *friendlyscreen.Screen = Peek.l(Addr Screen (Used Screen))
      If *friendlyscreen
        *friendlyrastport.RastPort = *friendlyscreen\RastPort
        If *friendlyrastport
          *friendlybitmap.BitMap = *friendlyrastport\BitMap
        End If
      End If
    End If

    If \bitmap_ptr Then image_FreeBitMap{image}

    If *friendlybitmap >< 0
      d.l = GetBitMapAttr_(*friendlybitmap,#BMA_DEPTH)
      ;If d = 0 Then d = 24
      \bitmap_ptr = AllocBitMap_(\img_width,\img_height,d,#BMF_MINPLANES,*friendlybitmap)
      If \bitmap_ptr
        bmap_depth.l  = GetBitMapAttr_(\bitmap_ptr,#BMA_DEPTH)
        If bmap_depth = 0 Then bmap_depth = 24
        InitRastPort_ temprp
        temprp\BitMap = \bitmap_ptr
        If bmap_depth > 8
          If bmap_depth < 24 AND \dither_mode><#image_dithermode_none Then image_Dither{image,bmap_depth,\dither_mode}
          WritePixelArray_ \raw_ptr,0,0,\bpr,temprp,0,0,\img_width,\img_height,#RECTFMT_ARGB
          succ.l = True
        Else
          penArray8.l = tempbuffer_Get{\img_width*\img_height}
          If penArray8
            If *cmap = 0
              If imageengine\cmap = 0 Then imageengine\cmap = cmap_GrabFromScreen{} : cmap_LockScreenPens{imageengine\cmap}
              *cmap = imageengine\cmap
              ;cmap_SetFastMode{*cmap}
            End If
            If *cmap
              cmap_RemapPixelArray{*cmap,\raw_ptr,\img_width,\img_height,\bpr,penArray8.l,\img_width*1,\dither_mode}
              WriteChunkyPixels_ temprp,0,0,\img_width-1,\img_height-1,penArray8,\img_width
              succ = True
            End If
          End If
        End If
      End If
    Else
      error{"\\__THIS_FUNCTION: Unable to allocate shadow bitmap!"}
    End If
  End If
  Function Return succ
End Function

Function.l image_ReleaseScreen{}

  If imageengine\cmap
    cmap_Free{imageengine\cmap}
    cmap_ReleaseScreenPens{imageengine\cmap}
    imageengine\cmap = 0
  End If
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_PrepareAll{@*friendlybitmap.BitMap}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Prepares all loaded images for fastest blitting.                            /
;/ This is done automatically by the blit commands but takes some time, so y:: /
;/ ou probably want to do this in advance and not in your game loop.           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *friendlybitmap.BitMap    : ???                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_PrepareAll{@*friendlybitmap.BitMap}
SHARED imagedat()

  If *friendlybitmap = -1
    *friendlybitmap.BitMap = 0
    *friendlyscreen.Screen = Peek.l(Addr Screen (Used Screen))
    If *friendlyscreen
      *friendlyrastport.RastPort = *friendlyscreen\RastPort
      If *friendlyrastport
        *friendlybitmap.BitMap = *friendlyrastport\BitMap
      End If
    End If
  End If
  If *friendlybitmap
     For image.l = 0 To #max_images-1
      If \isused
        If \ARGBbitmap_ptr Then image_InitBitMap{image,*friendlybitmap}
      End If
    Next
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_SetLoadDevisor{devisor.l}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Allow a 2^ downscale factor for image_Load.                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - devisor.l    : ???                                                        /
;/                                                                             /
;/ Bugs:        This feature might be broken at the moment. I suggest to use:: /
;/ image_Half.                                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_SetLoadDevisor{devisor.l}
SHARED imageengine

  If devisor <= 0 Then devisor = 1
  imageengine\devisor = devisor
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = _image_ExamineInternal{fid.l}                             /
;/                                                                             /
;/ Description:                                                                /
;/ Test if file exists AND is an image that is supported.                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l      : fileobject ID from file.include                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : True if image is supported, False if it failed               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _image_ExamineInternal{fid.l}

  isImage.l = False
  If fid < 0 Then Function Return False
  fpos.l = file_GetSeekPos{fid}
  succ.l = file_ReadMem{fid,&head.l,4}
  succ.l & file_ReadMem{fid,&size.l,4}

  If (head = @"IMG_" OR head = @"IIMG" OR head=@"FIMG" OR head=@"DIMG")
    head = @"AB2I"
    file_SeekRel{fid,-8}
  End If

  If head = @"AB2I" OR head = @"AB3I"
    succ.l = file_ReadMem{fid,&head.l,4}
    succ.l & file_ReadMem{fid,&size.l,4}
    If head = @"IMG_" OR head = @"IIMG" OR head = @"DIMG"; Image found !
      imgptr.l = tempbuffer_Get{size}
      file_ReadMem{fid,imgptr,size}
      head.l      = Peek.l(imgptr)
      chunksize.l = Peek.l(imgptr+4)
      If head = @"GEOM"
        imgptr+8
        img_width.l  = -1
        img_height.l = -1
        isImage      = True
        While chunksize>0
          Select Peek.l(imgptr)
             Case @"IMGW": img_width.l        = Peek.l(imgptr+4)
             Case @"IMGH": img_height.l       = Peek.l(imgptr+4)
             Case @"HNDX": handle_x.l         = Peek.l(imgptr+4)
             Case @"HNDY": handle_y.l         = Peek.l(imgptr+4)
             Case @"ALPH": alpha_isused.l     = Peek.l(imgptr+4)
             Case @"TRGB": mask_trgb.l        = Peek.l(imgptr+4)
             Case @"MASK": mask_isused.l      = Peek.l(imgptr+4)
             Case @"MTOL": mask_tolerance.l   = Peek.l(imgptr+4)
             Case @"MTHR": mask_threshold.l   = Peek.l(imgptr+4)
             Case @"DTHM": dither_mode.l      = Peek.l(imgptr+4)
             Case @"DTHT": dither_threshold.l = Peek.l(imgptr+4)
             Case @"BCX1": clip_x.l           = Peek.l(imgptr+4)
             Case @"BCX2": clip_x2.l          = Peek.l(imgptr+4)
             Case @"BCY1": clip_y.l           = Peek.l(imgptr+4)
             Case @"BCY2": clip_y2.l          = Peek.l(imgptr+4)
             Case @"BCXX": clip_x.l           = Peek.l(imgptr+4)
             Case @"BCXS": clip_xs.l          = Peek.l(imgptr+4)
             Case @"BCYY": clip_y.l           = Peek.l(imgptr+4)
             Case @"BCYS": clip_ys.l          = Peek.l(imgptr+4)
             Case @"PFMT": PFMT.l             = Peek.l(imgptr+4)
             Case @"FIL$": slen.l             = Peek.l(imgptr+4)
               filename.s = LSet$(" ",slen)
               CopyMem_ imgptr+8,&filename.s,slen
             Default
               error{"\\__THIS_FUNCTION: Unknown tag in file! ("+Mkl$(Peek.l(imgptr))+")"}
          End Select
          If Peek.l(imgptr)&$FF = @"$"  ; we got a string, so skip it!
            slen.l   = Peek.l(imgptr+4)
            aligns.l = 4-(slen+1) MOD 4
            chunksize - slen - 1 : imgptr+slen+1
            If aligns < 4 Then chunksize-aligns : imgptr+aligns
          End If
          chunksize-8
          imgptr+8
        Wend
      End If
    End If
  End If
  If isImage
    imageengine\exWidth  = img_width
    imageengine\exHeight = img_height
    imageengine\exDepth  = 24
  End If
  file_Seek{fid,fpos}
  Function Return isImage
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = image_Examine{fid.l}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Test if file exists AND is an image that is supported.                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : True if image is supported, False if it failed              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_Examine{filename.s}

  succ.l = False
  If dos_IsDir{filename} Then Function Return False
  imageengine\exWidth  = -1
  imageengine\exHeight = -1
  imageengine\exDepth  = -1
  imageengine\exNumImg = 0
  If image_IsPictureDT{filename} Then Function Return True
  If dos_Exist{filename}
    fid.l = file_Open{filename,#file_read}
    If fid >= 0
      succ.l = _image_ExamineInternal{fid}
      file_Close{fid}
    End If
  End If
  Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_Test{filename.s}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_Test{filename.s}

  Function Return image_Examine{filename}
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_GetExWidth{}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_GetExWidth{}

  Function Return imageengine\exWidth
End Function

Function.l image_GetExNumImg{}

  Function Return imageengine\exWidth
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_GetExHeight{}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_GetExHeight{}

  Function Return imageengine\exHeight
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_GetExDepth{}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_GetExDepth{}

  Function Return imageengine\exDepth
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = image_CutRP{image.l,*rp.RastPort,@x.l,@y.l,@xs.l,@ys.l::  /
;/ ,@trgb.l,@tolerance.l,@dithermode.l,@colorMap.l}                            /
;/                                                                             /
;/ Description:                                                                /
;/ Creates an image object out of (a part of) the given Rastport.              /
;/ NOTE:  ideal for screen-grabbing.                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l        : image object ID                                          /
;/ - *rp.RastPort   : Rastport where to fetch the data from                    /
;/ - trgb.l         : rgbvalue for the desired transparent color, e.g. ::      /
;/ $ff0000 for red, set it to -1 for no transparency                           /
;/ - x.l,y.l        : optional: position from where to fetch                   /
;/ - xs.l,ys.l      : optional: width and height of the area to fetch          /
;/ - tolerance.l    : ???                                                      /
;/ - dithermode.l   : ???                                                      /
;/ - colorMap.l     : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : True if everything went well, False if it failed             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_CutRP{image.l,*rp.RastPort,@x.l,@y.l,@xs.l,@ys.l,@trgb.l,@tolerance.l,@dithermode.l,@colorMap.l}
SHARED imagedat(),imageengine:USEPATH imagedat(image)

  succ.l = False
  If *rp
    If x < 0 Then x = 0
    If y < 0 Then y = 0
    If *rp\Layer
      If xs <= 0 Then xs = *rp\Layer\Width  -x
      If ys <= 0 Then ys = *rp\Layer\Height -y
    Else
      If *rp\BitMap
        If xs <= 0 Then xs = GetBitMapAttr_(*rp\BitMap,#BMA_WIDTH)  -x
        If ys <= 0 Then ys = GetBitMapAttr_(*rp\BitMap,#BMA_HEIGHT) -y
      End If
    End If

    If image_Create{image,xs,ys}
      d.l = GetBitMapAttr_(*rp\BitMap,#BMA_DEPTH)
      If d > 8 OR d <= 0
        #image_readblockwise = 0
        CNIF #image_readblockwise = 1
        #image_readblocksize = 320*100 ; max blocksize
        chunkN.l   = ((xs+ys) + #image_readblocksize-1) / #image_readblocksize
        mys.l      = ys / (chunkN+1) : If mys < 1 Then mys = 1 : chunkN = ys-1
        dy.l       = 0
        sy.l       = y
        For n.l = 0 To chunkN
          cys.l = Min(ys-dy,mys)
          ReadPixelArray_ \raw_ptr,0,dy,\bpr,*rp,x,sy,xs,cys,#RECTFMT_ARGB
          dy + cys
          sy + cys
        Next
        CEND
        CNIF #image_readblockwise=0
          ReadPixelArray_ \raw_ptr,0,0,\bpr,*rp,x,y,xs,ys,#RECTFMT_ARGB
        CEND
        CNIF #image_readblockwise=2
          RunErrsOff
          tag5.tag5\ti_Tag = #LBMI_BASEADDRESS,&bmapbase.l,#LBMI_BYTESPERROW,&bmapbpr.l,#LBMI_PIXFMT,&pixfmt.l,#LBMI_BYTESPERPIX,&bmapbpp.l,#TAG_DONE,0
          bmaplock.l       = LockBitMapTagList_(*rp\BitMap,tag5)
          UnLockBitMap_ bmaplock
          LastRunErrsMode

          Select pixfmt
            Case #PIXFMT_ARGB32
              For dy.l = 0 To ys-1
                srcptr.l = bmapbase + (dy+y) * bmapbpr + (x)*4
                dstptr.l = \raw_ptr +     dy *    \bpr
                For dx.l = 0 To xs-1
                  ARGB.l = Peek.l(srcptr) : srcptr+4
                  Poke.l (dstptr),ARGB    : dstptr+4
                Next
              Next
            Case #PIXFMT_BGRA32
              For dy.l = 0 To ys-1
                srcptr = bmapbase + (dy+y) * bmapbpr + (x)*4
                dstptr = \raw_ptr +     dy *    \bpr
                For dx.l = 0 To xs-1
                  BGRA.l = Peek.l(srcptr) : srcptr+4
                  ARGB.l = ((BGRA&$FF000000) LSR 16) | ((BGRA&$00FF0000) LSR 8) | ((BGRA&$0000FF00) LSL 8)
                  Poke.l (dstptr),ARGB    : dstptr+4
                Next
              Next
          End Select
        CEND
      Else
        *scr.Screen = Peek.l(Addr Screen (Used Screen))
        If *scr
          scr_depth.l = d ;*scr\BitMap\Depth
          CopyMem_ *rp,temprp.RastPort,SizeOf.RastPort
          temprp\Layer              = 0
          xsw.l                     = (((xs+15) LSR 4) LSL 4)
          temprp\BitMap             = AllocBitMap_ (xsw,1,8,0,0)
          temprp\BitMap\BytesPerRow = xsw LSR 3
          penArray8.l               = tempbuffer_Get{xsw*ys*1}
          ReadPixelArray8_ *rp,x,y,x+xs-1,y+ys-1,penArray8,temprp
          FreeBitMap_ temprp\BitMap

          lut.l = AllocVec_(256*4,#MEMF_CLEAR)

          If colorMap = -1
            For n.l = 0 To 1 LSL scr_depth-1
              GetRGB32_ *scr\ViewPort\ColorMap,n,1,col.cmapitem
              R.l    = col\R LSR 24
              G.l    = col\G LSR 24
              B.l    = col\B LSR 24
              ARGB.l = (R LSL 16) | (G LSL 8) | (B)
              Poke.l lut+n*4,ARGB
            Next
          Else
            For pen.l = 0 To (1 LSL scr_depth)-1
              *CReg.ColorRegister = colorMap + 3*pen
              Poke.l lut + (pen LSL 2),((*CReg\red&$00FF) LSL 16) | ((*CReg\green & $00FF) LSL 8) | (*CReg\blue & $FF)
            Next
          End If
          For y.l = 0 To ys-1
            For x.l = 0 To xs-1
              pen.l = Peek.b(penArray8+y*xsw+x) & $FF
              Poke.l \raw_ptr+y*\bpr+(x LSL 2),Peek.l(lut+(pen LSL 2))
            Next
          Next
          FreeVec_ lut
        End If
      End If
      If trgb >< -1
        image_InitMask{image,trgb,tolerance}
      Else
        \mask_trgb = -1
      End If
      succ = True
    End If
  Else
    error{"\\__THIS_FUNCTION: Uninitialized rastport!"}
  End If
  If succ = False Then image_Free{image}
  Function Return succ
  USELASTPATH
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_DecodeMask{image.l,ptr.l}                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l   : ???                                                           /
;/ - ptr.l     : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l  : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_DecodeMask{image.l,ptr.l}

  succ.l = False
  head.l = Peek.l(ptr) : ptr + 4
  Select head
    Case @"CMSK"
      If image_AllocMask{image}
        csize.l     = Peek.l(ptr) : ptr + 4
        mask_bpr.l  = Peek.l(ptr) : ptr + 4
        datatotal.l = Peek.l(ptr) : ptr + 4
        totalmem.l  = \mask_bpr * \img_height
        If mask_bpr = \mask_bpr
          status.l = zlib_Uncompress{\mask_ptr,&totalmem,ptr,datatotal}
          If status = #Z_OK Then succ = True
        Else
          ; re-copy
          error{"\\__THIS_FUNCTION: Different bytes per row!"}
        End If
      End If
    Case @"MASK"
      If image_AllocMask{image}
        csize.l     = Peek.l(ptr) : ptr + 4
        mask_bpr.l  = Peek.l(ptr) : ptr + 4
        datatotal.l = Peek.l(ptr) : ptr + 4
        totalmem.l  = \mask_bpr * \img_height
        If mask_bpr = \mask_bpr
          CopyMem_ ptr,\mask_ptr,Min(datatotal,\mask_bpr*\img_height)
          succ = True
        Else
          ; now we have to re-copy ...
          error{"\\__THIS_FUNCTION: Different bytes per row!"}
        End If
      End If
  End Select
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  count.l = image_Decode{image.l,memptr.l,@maximages.l,@memlength::  /
;/ .l}                                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ Get an image from a memory location (must be saved with image_Save and e.:: /
;/ g. included with IncBin)                                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l   : image object number the first decoded image will get. Next :: /
;/ images will get increasingly number                                         /
;/ - memptr.l  : pointer to some memory where the data can be found, typical:: /
;/ ly a label before IncBin                                                    /
;/ - maximages.l    : maximum amount of images to decode                       /
;/ - memlength.l : if you dont have a "AB2I" header, you can set the memory :: /
;/ length. A value of 1 will deocde only the first picture found               /
;/                                                                             /
;/ Result:                                                                     /
;/ - count.l   : Number of images decoded                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_Decode{image.l,memptr.l,@maximages.l,@memlength.l}
SHARED imagedat()

  decodecount.l = 0
  head.l        = Peek.l(memptr)
  If  (head = @"IMG_" OR head = @"IIMG" OR head = @"FIMG" OR head = @"DIMG")
    If memlength <= 0 Then totalsize.l = Peek.l(memptr+4) : Else totalsize = memlength
    head      = @"AB2I"
    memptr-8
    maximages = 1
  Else
    totalsize.l = Peek.l(memptr+4)
  End If
  If head = @"AB2I" OR head = @"AB3I"
    memptr+8
    While totalsize > 0
      succ.l      = False
      head.l      = Peek.l(memptr)
      chunksize.l = Peek.l(memptr+4)
      totalsize - 8 - chunksize
      imgptr.l    = memptr +8
      memptr+8+chunksize
      If head=@"IMG_" OR head = @"IIMG" OR head = @"DIMG"; Image found !
        imgtyp.l    = head
        head.l      = Peek.l(imgptr)
        chunksize.l = Peek.l(imgptr+4)
        If head = @"GEOM"
          image_Free{image}
          imgptr+8
          img_width.l  = -1
          img_height.l = -1
          While chunksize > 0
            Select Peek.l(imgptr)
               Case @"IMGW": img_width.l        = Peek.l(imgptr+4)
               Case @"IMGH": img_height.l       = Peek.l(imgptr+4)
               Case @"HNDX": handle_x.l         = Peek.l(imgptr+4)
               Case @"HNDY": handle_y.l         = Peek.l(imgptr+4)
               Case @"ALPH": alpha_isused.l     = Peek.l(imgptr+4)
               Case @"TRGB": mask_trgb.l        = Peek.l(imgptr+4)
               Case @"MASK": mask_isused.l      = Peek.l(imgptr+4)
               Case @"MTOL": mask_tolerance.l   = Peek.l(imgptr+4)
               Case @"MTHR": mask_threshold.l   = Peek.l(imgptr+4)
               Case @"DTHM": dither_mode.l      = Peek.l(imgptr+4)
               Case @"DTHT": dither_threshold.l = Peek.l(imgptr+4)
               Case @"BCX1": clip_x.l           = Peek.l(imgptr+4)
               Case @"BCX2": clip_x2.l          = Peek.l(imgptr+4)
               Case @"BCY1": clip_y.l           = Peek.l(imgptr+4)
               Case @"BCY2": clip_y2.l          = Peek.l(imgptr+4)
               Case @"BCXX": clip_x.l           = Peek.l(imgptr+4)
               Case @"BCXS": clip_xs.l          = Peek.l(imgptr+4)
               Case @"BCYY": clip_y.l           = Peek.l(imgptr+4)
               Case @"BCYS": clip_ys.l          = Peek.l(imgptr+4)
               Case @"PFMT": PFMT.l             = Peek.l(imgptr+4)
               Case @"FIL$": slen.l             = Peek.l(imgptr+4)
                 filename.s = LSet$(" ",slen)
                 CopyMem_ imgptr+8,&filename.s,slen
               Default
                 error{"\\__THIS_FUNCTION: Unknown tag in file! ("+Mkl$(Peek.l(imgptr))+")"}
            End Select
            If Peek.l(imgptr)&$FF = @"$"  ; we got a string, so skip it!
              slen.l   = Peek.l(imgptr+4)
              aligns.l = 4-(slen+1) MOD 4
              chunksize - slen - 1 : imgptr+slen+1
              If aligns < 4 Then chunksize-aligns:imgptr+aligns
            End If
            chunksize-8
            imgptr+8
          Wend

          If image_Create{image,img_width,img_height}
            If image_Lock{image}
            \handle_x         = handle_x
            \handle_y         = handle_y
            \dither_mode      = dither_mode
            \dither_threshold = dither_threshold
            \mask_tolerance   = mask_tolerance
            \mask_threshold   = mask_threshold
            \mask_trgb        = mask_trgb
            \alpha_isused     = alpha_isused
            If clip_x2 <= clip_x Then clip_x2 = \img_width-1
            If clip_y2 <= clip_y Then clip_y2 = \img_height-1
            If clip_xs = 0 Then clip_xs = clip_x2-clip_x+1
            If clip_ys = 0 Then clip_ys = clip_y2-clip_y+1
            \clip_x         = clip_x
            \clip_xs        = clip_xs
            \clip_y         = clip_y
            \clip_ys        = clip_ys
            head.l          = Peek.l(imgptr)
            datachunksize.l = Peek.l(imgptr+4)
            mptr.l          = 0
            datachunkptr.l  = imgptr+8
            Select head
              Case @"DATA"
                Select imgtyp
                  Case @"DIMG"
                    Select PFMT
                      Case @"ARGB"
                        *rp.RastPort = image_GetRPPtr{image}
                        If *rp Then WritePixelArray_ imgptr+8,0,0,img_width*4,*rp,0,0,img_width,img_height,#RECTFMT_ARGB
                        mptr = imgptr+8 + (img_width*img_height*4)
                      Case @"0RGB"
                        *rp.RastPort = image_GetRPPtr{image}
                        If *rp Then WritePixelArray_ imgptr+8,0,0,img_width*3,*rp,0,0,img_width,img_height,#RECTFMT_RGB
                        image_FreeAlpha{image}
                        mptr = imgptr+8 + img_width*img_height*3
                      Case @"AYUV"
                        *rp.RastPort = image_GetRPPtr{image}
                        If *rp Then WritePixelArray_ imgptr+8,0,0,img_width*4,*rp,0,0,img_width,img_height,#RECTFMT_ARGB
                        _image_YUV2RGB32{\raw_ptr,\bpr,img_width,img_height}
                        mptr = imgptr+8 + img_width*img_height*4
                      Case @"0YUV"
                        *rp.RastPort = image_GetRPPtr{image}
                        If *rp Then WritePixelArray_ imgptr+8,0,0,img_width*3,*rp,0,0,img_width,img_height,#RECTFMT_RGB
                        _image_YUV2RGB32{\raw_ptr,\bpr,img_width,img_height}
                        image_FreeAlpha{image}
                        mptr = imgptr+8 + img_width*img_height*3
                      Default
                        error{"\\__THIS_FUNCTION: Unknown pixelformat in AB3I file: "+Mkl$(PFMT)+"!"}
                    End Select

                  Case @"IIMG"
                    *rp.RastPort = image_GetRPPtr{image}
                    If *rp Then WritePixelArray_ imgptr+8,0,0,img_width*4,*rp,0,0,img_width,img_height,#RECTFMT_ARGB
                    mptr = imgptr+8 + img_width*img_height*4

                  Default
                    error{"\\__THIS_FUNCTION: Unknown image typ in AB2I/AB3I file!"}
                End Select

              Case @"CDAT"
                cptr.l = imgptr+8
                Select imgtyp
                  Case @"DIMG"
                    clen.l = Peek.l(cptr) : cptr+4
                    temp.l = AllocVec_(img_width*img_height*4,#MEMF_ANY)
                    mptr   = cptr + clen
                    If temp
                      ; decompress
                      temp_size.l = img_width*img_height*4
                      status.l = zlib_Uncompress{temp,&temp_size,cptr,clen}
                      If status = #Z_OK
                      Select PFMT
                        Case @"0rgb"
                          *rp.RastPort = image_GetRPPtr{image}
                          If *rp Then WritePixelArray_ temp,0,0,img_width*3,*rp,0,0,img_width,img_height,#RECTFMT_RGB
                          _image_UnfilterDelta32{\raw_ptr,\bpr,\raw_ptr,\bpr,img_width,img_height}
                          image_FreeAlpha{image}
                        Case @"argb"
                          _image_UnfilterDelta32{temp,img_width*4,\raw_ptr,\bpr,img_width,img_height}
                        Case @"ARGB"
                          *rp.RastPort = image_GetRPPtr{image}
                          If *rp Then WritePixelArray_ temp,0,0,img_width*4,*rp,0,0,img_width,img_height,#RECTFMT_ARGB
                        Case @"0RGB"
                          *rp.RastPort = image_GetRPPtr{image}
                          If *rp Then WritePixelArray_ temp,0,0,img_width*3,*rp,0,0,img_width,img_height,#RECTFMT_RGB
                          image_FreeAlpha{image}
                        Case @"0yuv"
                          *rp.RastPort = image_GetRPPtr{image}
                          If *rp Then WritePixelArray_ temp,0,0,img_width*3,*rp,0,0,img_width,img_height,#RECTFMT_RGB
                          _image_UnfilterDelta32{\raw_ptr,\bpr,\raw_ptr,\bpr,img_width,img_height}
                          _image_YUV2RGB32{\raw_ptr,\bpr,img_width,img_height}
                          image_FreeAlpha{image}
                        Case @"ayuv"
                          _image_UnfilterDelta32{temp,img_width*4,\raw_ptr,\bpr,img_width,img_height}
                          _image_YUV2RGB32{\raw_ptr,\bpr,img_width,img_height}
                        Case @"AYUV"
                          *rp.RastPort = image_GetRPPtr{image}
                          If *rp Then WritePixelArray_ temp,0,0,img_width*4,*rp,0,0,img_width,img_height,#RECTFMT_ARGB
                          _image_YUV2RGB32{\raw_ptr,\bpr,img_width,img_height}
                        Case @"0YUV"
                          *rp.RastPort = image_GetRPPtr{image}
                          If *rp Then WritePixelArray_ temp,0,0,img_width*3,*rp,0,0,img_width,img_height,#RECTFMT_RGB
                          _image_YUV2RGB32{\raw_ptr,\bpr,img_width,img_height}
                          image_FreeAlpha{image}
                        Default
                          error{"\\__THIS_FUNCTION: Unknown pixelformat in AB3I file: "+Mkl$(PFMT)+"!"}
                      End Select
                      End If
                      If temp Then FreeVec_ temp : temp = 0
                    End If

                  Case @"IIMG"
                    For y.l = 0 To img_height-1
                      clen.l = Peek.l(cptr) : cptr + 4
                      ptr.l  = \raw_ptr + y* \bpr
                      ulen.l = img_width*4
                      status = zlib_Uncompress{ptr,&ulen,cptr,clen}
                      cptr + clen
                    Next
                    mptr = cptr

                  Default
                    error{"\\__THIS_FUNCTION: Unknown image typ found in AB2I/AB3I file: "+Mkl$(imgtyp)+"!"}
                End Select
              Default
                error{"\\__THIS_FUNCTION: Unknown data chunk found!"}
            End Select

            If (mptr >= memptr-8) Then mptr = 0 ; there cant be any MASK chunk!

            If mask_isused
              succ.l = False
              If mptr Then succ = image_DecodeMask{image,mptr}
              If succ = False Then image_InitMask{image,mask_trgb,mask_tolerance,mask_threshold}
            End If
            succ = True
            decodecount+1
            image+1
            If image >= #max_images Then totalsize = 0
            maximages-1
            End If
          End If
        End If
      End If
      If head = @"FIMG" ; found a placeholder!
        head.l      = Peek.l(imgptr)
        chunksize.l = Peek.l(imgptr+4)
        image+1
        imgptr+8+chunksize
        succ        = True
        maximages-1
      End If
      If succ = False Then totalsize = 0
      If maximages = 0 Then totalsize = 0
    Wend
  End If
  Function Return decodecount
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_BlitMask{image.l,x.l,y.l,@*rp.RastPort}                       /
;/                                                                             /
;/ Description:                                                                /
;/ Blits an image with a 1bit mask on the current window or given rastport.    /
;/ If there is no mask present, it will blit the image opaque.                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID                                                 /
;/ - x.l     : x position                                                      /
;/ - y.l     : y position                                                      /
;/ - *rp.RastPort : optional a rastport where to blit,                         /
;/ otherwise it is blitted to::                                                /
;/ the used window                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_BlitMask{image.l,x.l,y.l,@*rp.RastPort}
SHARED imagedat()

  USEPATH imagedat(image)
  If \bitmap_ptr = False Then image_InitBitMap{image}
  If *rp=-1 AND Used Window >= 0 Then *rp = RastPort(Used Window)
  If \bitmap_ptr >< False AND *rp >< 0 AND *rp >< -1
    If \mask_ptr
      BltMaskBitMapRastPort_ \bitmap_ptr,\clip_x,\clip_y,*rp,x-\handle_x,y-\handle_y,\clip_xs,\clip_ys,$c0,\mask_ptr
    Else
      BltBitMapRastPort_ \bitmap_ptr,\clip_x,\clip_y,*rp,x-\handle_x,y-\handle_y,\clip_xs,\clip_ys,$c0
    End If
  Else
    error{"\\__THIS_FUNCTION: Uninitialized image bitmap (ptr= "+Hex$(\bitmap_ptr)+")/window(*rp= "+Hex$(*rp)+")!"}
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Blit{image.l,x.l,y.l,@*rp.RastPort}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Blit an image to the used window or a RastPort.                             /
;/ This function uses BltBitMapRastPort() and is the fastest way to get the :: /
;/ image to your screen.                                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID                                                 /
;/ - x.l     : x position in pixel                                             /
;/ - y.l     : y position in pixel                                             /
;/ - *rp.RastPort : optional a rastport to blit into, otherwise it is blitted  /
; / to the used window                                                         /
;/                                                                             /
;/ See also:    image_BlitMask                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Blit{image.l,x.l,y.l,@*rp.RastPort}
SHARED imagedat()

  USEPATH imagedat(image)
  If \bitmap_ptr = False Then image_InitBitMap{image}
  If *rp = -1 AND Used Window >= 0 Then *rp = RastPort(Used Window)
  If \bitmap_ptr >< False AND *rp >< 0 AND *rp >< -1
    BltBitMapRastPort_ \bitmap_ptr,\clip_x,\clip_y,*rp,x-\handle_x,y-\handle_y,\clip_xs,\clip_ys,$c0
  Else
    error{"\\__THIS_FUNCTION: Uninitialized image bmap/window/screen!"}
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_BlitScaled{image.l,x.l,y.l,xs.l,ys.l,@*rp.RastPort}           /
;/                                                                             /
;/ Description:                                                                /
;/ Same like image_Blit, but scaled to the given size xs/ys.                   /
;/ This function uses BitMapScale().                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID                                                 /
;/ - x.l     : x position                                                      /
;/ - y.l     : y position                                                      /
;/ - xs.l    : destination width                                               /
;/ - ys.l    : destination height                                              /
;/ - *rp.RastPort : optional rastport to blit to                               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_BlitScaled{image.l,x.l,y.l,xs.l,ys.l,@*rp.RastPort}
SHARED imagedat(),bsa

  USEPATH imagedat(image)
  If \bitmap_ptr = False Then image_InitBitMap{image}
  If *rp = -1 AND Used Window >= 0 Then *rp = RastPort(Used Window)
  If \bitmap_ptr >< False AND *rp >< 0 AND *rp >< -1
    If xs < 1 Then xs = \img_width
    If ys < 1 Then ys = \img_height * xs / \img_width

    dx.l = x-\handle_x*xs/\img_width
    dy.l = y-\handle_y*ys/\img_height
    If *rp\Layer
      dx.l + *rp\Layer\bounds\MinX
      dy.l + *rp\Layer\bounds\MinY
    End If

    bsa\bsa_SrcX        = 0 ,0                     ; /* source origin */
    bsa\bsa_DestX       = dx,dy                    ; /* destination origin */
    bsa\bsa_DestWidth   = 0,0 ;xs,ys               ; /* destination size result */
    bsa\bsa_SrcWidth    = \img_width, \img_height  ; /* source size */
    bsa\bsa_SrcBitMap   = \bitmap_ptr              ; /* source BitMap */
    bsa\bsa_DestBitMap  = *rp\BitMap               ; /* destination BitMap */

    fakx.l = 256 * xs / \img_width
    faky.l = 256 * ys / \img_height
    bsa\bsa_XSrcFactor  = 256,256                  ; /* scale factor denominators */
    bsa\bsa_XDestFactor = fakx,faky                ; /* scale factor numerators */

    BitMapScale_ bsa
  Else
    error{"\\__THIS_FUNCTION: Uninitialized image bmap/window/screen!"}
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Draw{image.l,x.l,y.l,@*rp.RastPort}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Draw an image instread of blit.                                             /
;/ This means, the picture is converted on-the-fly to the destiantion screen:: /
;/  pixelformat.                                                               /
;/ No shadow bitmap is created to speed the blit operation up like in image_:: /
;/ Blit.                                                                       /
;/ NOTE: this functions saves you some memory, and is useful if you blit the:: /
;/  image once.                                                                /
;/ If you plan to blit the image many times, better use image_Blit for speed.  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - x.l    : x position                                                       /
;/ - y.l    : y position                                                       /
;/ - *rp.RastPort    : rastport to draw the image to                           /
;/                                                                             /
;/ See also:    image_Blit                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Draw{image.l,x.l,y.l,@*rp.RastPort}

  If *rp = -1 Then *rp = RastPort
  If *rp >< 0 AND image_IsUsed{image}
    *bmap.BitMap = *rp\BitMap
    d.l = GetBitMapAttr_(*bmap,#BMA_DEPTH)
    If d = 0 OR d > 8
      WritePixelArray_ \raw_ptr,\clip_x,\clip_y,\bpr,*rp,x-\handle_x,y-\handle_y,\clip_xs,\clip_ys,#RECTFMT_ARGB
    Else
      ; lazy!
      image_Blit{image,x,y,*rp}
    End If
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_DrawScaled{image.l,x.l,y.l,xs.l,ys.l,@*rp.Rast::  /
;/ Port,@smoothing.f}                                                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/ - xs.l    : ???                                                             /
;/ - ys.l    : ???                                                             /
;/ - *rp.RastPort    : ???                                                     /
;/ - smoothing.f    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_DrawScaled{image.l,x.l,y.l,xs.l,ys.l,@*rp.RastPort,@smoothing.f}
SHARED imagedat(),imgargs(),imageengine

  USEPATH imagedat(image)
  If *rp = -1 AND Used Window >= 0 Then *rp = RastPort(Used Window)

  If \raw_ptr = False OR *rp = 0 OR *rp = -1 Then Function Return False

  If xs < 1 Then xs = \img_width
  If ys < 1 Then ys = \img_height * xs / \img_width


  bltwidth.l  = \clip_xs;\img_width
  bltheight.l = \clip_ys;\img_height
  If xs = bltwidth AND ys = bltheight Then image_Draw{image,x,y,*rp} : Function Return -1

  *bmap.BitMap = *rp\BitMap
  If *bmap Then d.l = GetBitMapAttr_(*bmap,#BMA_DEPTH) : Else d = 0
  If d <= 8 Then image_BlitScaled{image,x,y,xs,ys,*rp} : Function Return -1

  x.l - \handle_x * xs / bltwidth
  y.l - \handle_y * ys / bltheight

  ;  !image_GetClipBounds{*rp,minx.l,miny.l,maxx.l,maxy.l}
  ;  xoff.l = 0
  ;  yoff.l = 0
  ;  x1.l =  x - (\handle_x  *xs/bltwidth) ;+ minx
  ;  y1.l =  y - (\handle_y  *ys/bltheight) ;+ miny
  ;  x2.l = x1 + xs-1
  ;  y2.l = y1 + ys-1
  ;  If x1 < minx Then xoff+(minx-x1)*bltwidth/xs : x1 = minx
  ;  If y1 < miny Then yoff+(miny-y1)*bltheight/ys : y1 = miny
  ;  If x2 > maxx Then x2 = maxx
  ;  If y2 > maxy Then y2 = maxy
  ;  blitwidth.l = x2-x1+1
  ;  blitheight.l = y2-y1+1
  ;  WLocate 20,20
  ;  NPrint "CPUblitScaled: ",x1,"/",y1," - ",blitwidth,"x",blitheight,"! Clipbound:"+Str$(minx)+"/"+Str$(maxx)+"..."+Str$(miny)+"/"+Str$(maxy)
  ;  xs = blitwidth
  ;  dx.l = xoff
  ;  ys = blitheight
  ;  dy.l = yoff

  If smoothing = -1 Then ScalePixelArray_ \raw_ptr+\bpr*\clip_y+\clip_x*\bpp,bltwidth,bltheight,\bpr,*rp,x,y,xs,ys,#RECTFMT_ARGB : Function Return -1

  ifx.f = (bltwidth -1) / (xs-1)
  ify.f = (bltheight-1) / (ys-1)
  If smoothing < 0 Then smoothing = 2.0 : Else If smoothing = 0 Then smoothing = 1000 : Else smoothing = 4-1/(smoothing+1)*4

  prescale.l = 1
  If ifx > smoothing AND ify > smoothing ; compute smoothing factor (pre scaling)
    While ifx > smoothing AND ify > smoothing AND prescale < 16
      prescale*2 : ifx*0.5 : ify*0.5
    Wend
  ;  If ifx < 1.0 AND prescale > 1 Then error{"ifx: "+Str$(ifx)+" / prescale = "+Str$(prescale)}
  End If
  sourcebpr.l    = \bpr
  sourcebase.l   = \raw_ptr
  sourcewidth.l  = \img_width
  sourceheight.l = \img_height

  #SCALE_LINES = 16
  If prescale = 1
    destbase.l = tempbuffer_Get{(xs*4)*#SCALE_LINES+4}
  Else
    prescalebpr.l    = ((sourcewidth+prescale-1) / prescale ) * 4 + 4
    tmpmem.l         = tempbuffer_Get{(xs*4)*#SCALE_LINES + prescalebpr*2} ; cache lines
    destbase.l       = tmpmem + 0
    prescalebase1.l  = tmpmem + (xs*4)*#SCALE_LINES
    prescalebase2.l  = prescalebase1 + prescalebpr
    prescalewidth.l  = \img_width  / prescale
    prescaleheight.l = \img_height / prescale
  End If
  destaddr.l  = destbase
  linecount.l = 0

  !setfpcr{($10)}
  oldinty.l = -1
  For dy.l = 0 To ys-1
    sy.f   = dy*ify
    sx.f   = 0
    inty.l = sy
    Select prescale
      Case 1
        sourceaddry1.l = sourcebase+(inty*sourcebpr)
        sourceaddry2.l = sourceaddry1+sourcebpr

      Case 2
        While inty >= oldinty
          oldinty+1
          Exchange prescalebase1,prescalebase2
          sourceaddry1.l = sourcebase+(oldinty*sourcebpr)*2
          sourceaddry2.l = sourceaddry1+sourcebpr
          prescaleaddr.l = prescalebase1
          For px.l = 0 To prescalewidth-1
            ARGB.l = (Peek.l(sourceaddry1) & $FCFCFCFC) LSR 2 : sourceaddry1 + 4
            ARGB.l + (Peek.l(sourceaddry1) & $FCFCFCFC) LSR 2 : sourceaddry1 + 4
            ARGB.l + (Peek.l(sourceaddry2) & $FCFCFCFC) LSR 2 : sourceaddry2 + 4
            ARGB.l + (Peek.l(sourceaddry2) & $FCFCFCFC) LSR 2 : sourceaddry2 + 4
            Poke.l prescaleaddr,ARGB : prescaleaddr+4
          Next
          Poke.l prescaleaddr,ARGB : prescaleaddr+4
        Wend
        sourceaddry1.l = prescalebase2
        sourceaddry2.l = prescalebase1

      Case 4
        While inty >= oldinty
          oldinty+1
          Exchange prescalebase1,prescalebase2
          sourceaddry1.l = sourcebase+(oldinty*sourcebpr)*4
          sourceaddry2.l = sourceaddry1+sourcebpr
          sourceaddry3.l = sourceaddry2+sourcebpr
          sourceaddry4.l = sourceaddry3+sourcebpr

          prescaleaddr.l = prescalebase1
          For px.l = 0 To prescalewidth-1
            ARGB1.l = (Peek.l(sourceaddry1) & $F8F8F8F8) LSR 3 : sourceaddry1 + 4
            ARGB1.l + (Peek.l(sourceaddry1) & $F8F8F8F8) LSR 3 : sourceaddry1 + 4
            ARGB1.l + (Peek.l(sourceaddry1) & $F8F8F8F8) LSR 3 : sourceaddry1 + 4
            ARGB1.l + (Peek.l(sourceaddry1) & $F8F8F8F8) LSR 3 : sourceaddry1 + 4
            ARGB1.l + (Peek.l(sourceaddry2) & $F8F8F8F8) LSR 3 : sourceaddry2 + 4
            ARGB1.l + (Peek.l(sourceaddry2) & $F8F8F8F8) LSR 3 : sourceaddry2 + 4
            ARGB1.l + (Peek.l(sourceaddry2) & $F8F8F8F8) LSR 3 : sourceaddry2 + 4
            ARGB1.l + (Peek.l(sourceaddry2) & $F8F8F8F8) LSR 3 : sourceaddry2 + 4
            ARGB2.l = (Peek.l(sourceaddry3) & $F8F8F8F8) LSR 3 : sourceaddry3 + 4
            ARGB2.l + (Peek.l(sourceaddry3) & $F8F8F8F8) LSR 3 : sourceaddry3 + 4
            ARGB2.l + (Peek.l(sourceaddry3) & $F8F8F8F8) LSR 3 : sourceaddry3 + 4
            ARGB2.l + (Peek.l(sourceaddry3) & $F8F8F8F8) LSR 3 : sourceaddry3 + 4
            ARGB2.l + (Peek.l(sourceaddry4) & $F8F8F8F8) LSR 3 : sourceaddry4 + 4
            ARGB2.l + (Peek.l(sourceaddry4) & $F8F8F8F8) LSR 3 : sourceaddry4 + 4
            ARGB2.l + (Peek.l(sourceaddry4) & $F8F8F8F8) LSR 3 : sourceaddry4 + 4
            ARGB2.l + (Peek.l(sourceaddry4) & $F8F8F8F8) LSR 3 : sourceaddry4 + 4
            ARGB.l = ((ARGB1 & $FEFEFEFE) LSR 1) + ((ARGB2 & $FEFEFEFE) LSR 1)
            Poke.l prescaleaddr,ARGB : prescaleaddr+4
          Next
          Poke.l prescaleaddr,ARGB : prescaleaddr+4
        Wend
        sourceaddry1.l = prescalebase2
        sourceaddry2.l = prescalebase1

      Case 8
        While inty >= oldinty
          oldinty+1
          Exchange prescalebase1,prescalebase2
          prescaleaddr.l = prescalebase1

          For px.l = 0 To prescalewidth-1
            ARGB.l = 0
            For py.l = 0 To 7
              sourceaddry.l = sourcebase+(((oldinty LSL 3)+py)*sourcebpr) + (px LSL 5)
              ARGBT.l = ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGBT.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGBT.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGBT.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGBT.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGBT.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGBT.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGBT.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB + ((ARGBT & $F8F8F8F8) LSR 3)
            Next
            Poke.l prescaleaddr,ARGB : prescaleaddr+4
          Next
          Poke.l prescaleaddr,ARGB : prescaleaddr+4
        Wend
        sourceaddry1.l = prescalebase2
        sourceaddry2.l = prescalebase1

      Case 16
        While inty >= oldinty
          oldinty+1
          Exchange prescalebase1,prescalebase2
          prescaleaddr.l = prescalebase1

          For px.l = 0 To prescalewidth-1
            ARGB.l = 0
            For py.l = 0 To 15
              sourceaddry.l = sourcebase+(((oldinty LSL 4)+py)*sourcebpr) + (px LSL 6)
              ARGB1.l = ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB1.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB1.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB1.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4

              ARGB1.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB1.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB1.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB1.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4

              ARGB2.l = ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB2.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB2.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB2.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4

              ARGB2.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB2.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB2.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGB2.l + ((Peek.l(sourceaddry) & $F8F8F8F8) LSR 3) : sourceaddry + 4
              ARGBT.l = ((ARGB1 & $FEFEFEFE) LSR 1) + ((ARGB2 & $FEFEFEFE) LSR 1)
              ARGB + ((ARGBT & $F0F0F0F0) LSR 4)
            Next
            Poke.l prescaleaddr,ARGB : prescaleaddr+4
          Next
          Poke.l prescaleaddr,ARGB : prescaleaddr+4
        Wend
        sourceaddry1.l = prescalebase2
        sourceaddry2.l = prescalebase1

    End Select
    ;yii.f = (1-Cos(Pi*(sy - inty)))*0.5
    yii.f = sy-inty
    yii*yii
    ;If yii < 0.5 Then yii = 0
    yi.f = 1-yii
    For dx.l = 0 To xs-1
      intx.l = (sx)

      ;xii.f = (1-Cos(Pi*(sx - intx)))*0.5

      xii.f = sx-intx

      xii*xii
      ;If xii < 0.5 Then xii = 0
      xi.f = 1-xii

      sourceaddr1.l = sourceaddry1+(intx LSL 2)
      sourceaddr2.l = sourceaddry2+(intx LSL 2)

      i1.f = (xi  * yi )
      i2.f = (xii * yi )
      i3.f = (xi  * yii)
      i4.f = (xii * yii)

      sx + ifx

      ARGB.l = Peek.l(sourceaddr1)
      B.l    = (ARGB & $FF     ) * i1
      G.l    = (ARGB & $FF00   ) * i1
      R.l    = (ARGB & $FF0000 ) * i1
      A.l    = ((ARGB & $FF000000 ) LSR 8) * i1

      ARGB = Peek.l(sourceaddr1+4)
      B + (ARGB & $FF     ) * i2
      G + (ARGB & $FF00   ) * i2
      R + (ARGB & $FF0000 ) * i2
      A + ((ARGB & $FF000000 )LSR 8) * i2

      ARGB = Peek.l(sourceaddr2)
      B + (ARGB & $FF     ) * i3
      G + (ARGB & $FF00   ) * i3
      R + (ARGB & $FF0000 ) * i3
      A + ((ARGB & $FF000000 )LSR 8) * i3

      ARGB = Peek.l(sourceaddr2+4)
      B + (ARGB & $FF     ) * i4
      G + (ARGB & $FF00   ) * i4
      R + (ARGB & $FF0000 ) * i4
      A + ((ARGB & $FF000000) LSR 8) * i4

      ARGB.l = B | (G & $FF00) | (R & $FF0000) | ((A & $FF0000) LSL 8)

      Poke.l destaddr,ARGB
      destaddr+4
    Next
    linecount+1
    If linecount.l >= #SCALE_LINES
      WritePixelArray_ destbase,0,0,xs*4,*rp,x,y,xs,linecount,#RECTFMT_ARGB
      linecount  = 0
      destaddr.l = destbase
      y+#SCALE_LINES
    End If
  Next
  If linecount.l > 0
    WritePixelArray_ destbase,0,0,xs*4,*rp,x,y,xs,linecount,#RECTFMT_ARGB
  End If
  !setfpcr{($0)}
  Function Return -1
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_Resize{dstimage.l,srcimage.l,newwidth.l,@newhe::  /
;/ ight.l,@interpol.l,@sharpness.f}                                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - dstimage.l    : ???                                                       /
;/ - srcimage.l    : ???                                                       /
;/ - newwidth.l    : ???                                                       /
;/ - newheight.l   : ???                                                       /
;/ - interpol.l    : ???                                                       /
;/ - sharpness.f   : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
;RunErrsOff
Function.l image_Resize{dstimage.l,srcimage.l,newwidth.l,@newheight.l,@interpol.l,@sharpness.f}
SHARED imagedat()

  succ.l = False
  If image_IsUsed{srcimage} = False
    error{"\\__THIS_FUNCTION: Source image is not inisialized!"}
    Function Return False
  End If

  If sharpness < 0 Then sharpness = 0
  If sharpness > 1 Then sharpness = 1

  If newheight <= 0 Then newheight = imagedat(srcimage)\img_height * newwidth  / imagedat(srcimage)\img_width
  If newwidth <= 0 Then newwidth = imagedat(srcimage)\img_width  * newheight / imagedat(srcimage)\img_height

  If interpol = -1
    interpol = #image_interpol_window
    If newheight >= imagedat(srcimage)\img_height AND newwidth >= imagedat(srcimage)\img_width
      interpol = #image_interpol_cubic
    End If
    If imagedat(srcimage)\alpha_isused Then interpol = #image_interpol_alpha
  End If

  If image_Create{dstimage,newwidth,newheight,True,$000000}
    image_CopyConfig{dstimage,srcimage}
  ;  imagedat(dstimage)\alpha_isused = imagedat(srcimage)\alpha_isused
    *rp.RastPort = image_GetRPPtr{dstimage}
    If *rp
      succ    = True
      sxs.l   = imagedat(srcimage)\img_width
      sys.l   = imagedat(srcimage)\img_height
      dxs.l   = imagedat(dstimage)\img_width
      dys.l   = imagedat(dstimage)\img_height
      fracX.l = 0
      fracY.l = 0
      sy.l    = 0
      Select interpol
        Case #image_interpol_none
          fracY.l = (sys) ASR 1
          dptr.l  = imagedat(dstimage)\raw_ptr
          For dy.l  = 0 To dys-1
            sptr.l  = imagedat(srcimage)\raw_ptr + sy * imagedat(srcimage)\bpr
            dptr.l  = imagedat(dstimage)\raw_ptr + dy * imagedat(dstimage)\bpr
            fracY+sys : While fracY > dys : fracY-dys : sy+1 : Wend
            fracX.l = (sxs ) ASR 1
            For dx.l = 0 To dxs-1
              Poke.l dptr,Peek.l(sptr) : dptr+4
              fracX+sxs : While fracX > dxs : fracX-dxs : sptr+4 : Wend
            Next
          Next

        Case #image_interpol_linear
   ;       s.f = 2-sharpness*2
   ;       image_DrawScaled{srcimage,0,0,newwidth,newheight,*rp,s}
          fracY.l = (dys +sys) ASR 1
          sbpr.l  = imagedat(srcimage)\bpr
          sy.l    = 0

          For dy.l = 0 To dys-1
            dptr.l = imagedat(dstimage)\raw_ptr + dy * imagedat(dstimage)\bpr

            ifracY.l = dys-fracY
            fracX.l  = (dxs + sxs) ASR 1
            sx.l     = 0

            sptr = imagedat(srcimage)\raw_ptr + sy * sbpr
            If (sy > 0  ) pix11.l = Peek.l(sptr-sbpr) : Else pix11 = Peek.l(sptr)
            If (sy < sys) pix12.l = Peek.l(sptr     ) : Else pix12 = pix11
            pix21.l = pix11
            pix22.l = pix12

            For dx.l = 0 To dxs-1
              ifracX.l = dxs - fracX

              B.l = ((pix11       ) & $FF) * ifracY * ifracX
              G.l = ((pix11 LSR  8) & $FF) * ifracY * ifracX
              R.l = ((pix11 LSR 16) & $FF) * ifracY * ifracX
              A.l = ((pix11 LSR 24)      ) * ifracY * ifracX

              B.l + ((pix12       ) & $FF) * fracY * ifracX
              G.l + ((pix12 LSR  8) & $FF) * fracY * ifracX
              R.l + ((pix12 LSR 16) & $FF) * fracY * ifracX
              A.l + ((pix12 LSR 24)      ) * fracY * ifracX

              B.l + ((pix21       ) & $FF) * ifracY * fracX
              G.l + ((pix21 LSR  8) & $FF) * ifracY * fracX
              R.l + ((pix21 LSR 16) & $FF) * ifracY * fracX
              A.l + ((pix21 LSR 24)      ) * ifracY * fracX

              B.l + ((pix22       ) & $FF) * fracY * fracX
              G.l + ((pix22 LSR  8) & $FF) * fracY * fracX
              R.l + ((pix22 LSR 16) & $FF) * fracY * fracX
              A.l + ((pix22 LSR 24)      ) * fracY * fracX

              A = (A) / (dxs*dys)
              R = (R) / (dxs*dys)
              G = (G) / (dxs*dys)
              B = (B) / (dxs*dys)

              ARGB.l = A LSL 24 | R LSL 16 | G LSL 8 | B

              Poke.l dptr,ARGB : dptr+4

              fracX+sxs
              While fracX >= dxs
                fracX-dxs : sptr+4 : sx+1
                pix11 = pix21
                pix12 = pix22
                If (sx < sxs)
                  If (sy > 0  ) pix21 = Peek.l(sptr-sbpr) : Else pix21 = Peek.l(sptr)
                  If (sy < sys) pix22 = Peek.l(sptr     ) : Else pix22 = pix21
                End If
              Wend
            Next

            fracY+sys
            While fracY >= dys
              fracY-dys
              sy+1
            Wend
          Next

        Case #image_interpol_cos
          fracY.l = (dys+sys) ASR 1
          sbpr.l  = imagedat(srcimage)\bpr
          sy.l    = 0

          For dy.l = 0 To dys-1
            dptr.l    = imagedat(dstimage)\raw_ptr + dy * imagedat(dstimage)\bpr
            cfraqf.f  = .5 - .5*Cos(Pi * fracY / (dys+1))
            cfracY.l  = cfraqf * dys
            icfracY.l = dys-cfracY
            fracX.l   = (dxs+sxs) ASR 1
            sx.l      = 0
            sptr      = imagedat(srcimage)\raw_ptr + sy * sbpr
            If (sy > 0  ) pix11.l = Peek.l(sptr-sbpr) : Else pix11 = Peek.l(sptr)
            If (sy < sys) pix12.l = Peek.l(sptr     ) : Else pix12 = pix11
            pix21.l   = pix11
            pix22.l   = pix12

            For dx.l = 0 To dxs-1
              cfraqf.f  = .5 - .5*Cos(Pi * fracX / (dxs+1))
              cfracX.l  = cfraqf * dxs
              icfracX.l = dxs - cfracX

              B.l = ((pix11       ) & $FF) * icfracY * icfracX
              G.l = ((pix11 LSR  8) & $FF) * icfracY * icfracX
              R.l = ((pix11 LSR 16) & $FF) * icfracY * icfracX
              A.l = ((pix11 LSR 24)      ) * icfracY * icfracX

              B.l + ((pix12       ) & $FF) * cfracY * icfracX
              G.l + ((pix12 LSR  8) & $FF) * cfracY * icfracX
              R.l + ((pix12 LSR 16) & $FF) * cfracY * icfracX
              A.l + ((pix12 LSR 24)      ) * cfracY * icfracX

              B.l + ((pix21       ) & $FF) * icfracY * cfracX
              G.l + ((pix21 LSR  8) & $FF) * icfracY * cfracX
              R.l + ((pix21 LSR 16) & $FF) * icfracY * cfracX
              A.l + ((pix21 LSR 24)      ) * icfracY * cfracX

              B.l + ((pix22       ) & $FF) * cfracY * cfracX
              G.l + ((pix22 LSR  8) & $FF) * cfracY * cfracX
              R.l + ((pix22 LSR 16) & $FF) * cfracY * cfracX
              A.l + ((pix22 LSR 24)      ) * cfracY * cfracX

              A = A / (dxs*dys)
              R = R / (dxs*dys)
              G = G / (dxs*dys)
              B = B / (dxs*dys)

              ARGB.l = A LSL 24 | R LSL 16 | G LSL 8 | B

              Poke.l dptr,ARGB : dptr+4

              fracX+sxs
              While fracX > dxs
                fracX-dxs : sptr+4 : sx+1
                pix11 = pix21
                pix12 = pix22
                If (sx < sxs)
                  If (sy > 0  ) pix21 = Peek.l(sptr-sbpr) : Else pix21 = Peek.l(sptr)
                  If (sy < sys) pix22 = Peek.l(sptr     ) : Else pix22 = pix21
                End If
              Wend
            Next

            fracY+sys
            While fracY > dys
              fracY-dys
              sy+1
            Wend
        Next

       Case #image_interpol_cubic

          Macro cubic_natural ; natural?
            `10.f = `23 - `22 - `20 + `21
            `11.f = `20 - `21 - `10
            `12.f = `22 - `20
            `13.f = `21
            `2.f  = (`10*`33 + `11*`32 + `12*`3 + `13)
          End Macro

          Macro cubic_catmul_vers1 ; catmull
            `10.f = -.5*`20 + 1.5*`21 - 1.5*`22 + .5*`23
            `11.f = `20 - 2.5*`21 + 2*`22-.5*`23
            `12.f = .5*(`22 - `20)
            `13.f = `21
            `2.f  = (`10*`33 + `11*`32 + `12*`3 + `13)
          End Macro

          Macro cubic_catmul ; catmull
            `2.f =  `21 + 0.5 * `3*(`22 - `20 + `3*(2.0*`20 - 5.0*`21 + 4.0*`22 - `23 + `3*(3.0*(`21 - `22) + `23 - `20)))
          End Macro

          Macro cubic_hermite
            alpha.f = .75
            tens.f  = 0
            conti.f = 0
            bias.f  = 0

            s.f     = `3
            P1.f    = `21
            P2.f    = `22
            ;T1.f    = ( (`22-`20) ) * alpha
            ;T2.f    = ( (`23-`21) ) * alpha

            T1.f    = (1-tens)*(1-conti)*(1+bias)/2 * (`21-`20)  + (1-tens)*(1+conti)*(1-bias) * (`22-`21)
            T2.f    = (1-tens)*(1+conti)*(1+bias)/2 * (`22-`21)  + (1-tens)*(1-conti)*(1-bias) * (`23-`22)

            h1.f    =  2*s*s*s - 3*s*s + 1  ;          // calculate basis function 1
            h2.f    = -2*s*s*s + 3*s*s      ;              // calculate basis function 2
            h3.f    =    s*s*s - 2*s*s + s ;         // calculate basis function 3
            h4.f    =    s*s*s - s*s       ;              // calculate basis function 4
            `2.f    = h1*P1 +h2*P2 +h3*T1 +h4*T2
          End Macro

          fracY.l = ((dys+sys) ASR 1)
          sy.l    = 0
          sbpr.l  =  imagedat(srcimage)\bpr

          For dy.l = 0 To dys-1
            sx.l   = 0
            sptr.l = imagedat(srcimage)\raw_ptr     + (sy) * sbpr

            If (sy < sys)
              pix22.l = Peek.l(sptr)
              If (sx > 0    ) Then pix12.l = Peek.l(sptr -4) : Else pix12 = pix22
              If (sx > 1    ) Then pix02.l = Peek.l(sptr -8) : Else pix02 = pix12
              If (sx < sxs-1) Then pix32.l = Peek.l(sptr +4) : Else pix32 = pix22
            Else
              sptr2.l = imagedat(srcimage)\raw_ptr     + (sys-1) * sbpr
              pix22.l = Peek.l(sptr2)
              If (sx > 0    ) Then pix12.l = Peek.l(sptr2 -4) : Else pix12 = pix22
              If (sx > 1    ) Then pix02.l = Peek.l(sptr2 -8) : Else pix02 = pix12
              If (sx < sxs-1) Then pix32.l = Peek.l(sptr2 +4) : Else pix32 = pix22
            End If

            If (sy > 0)
              pix21.l = Peek.l(sptr     - sbpr)
              If (sx > 0    ) Then pix11.l = Peek.l(sptr -4  - sbpr) : Else pix11 = pix21
              If (sx > 1    ) Then pix01.l = Peek.l(sptr -8  - sbpr) : Else pix01 = pix11
              If (sx < sxs-1) Then pix31.l = Peek.l(sptr +4  - sbpr) : Else pix31 = pix21
            Else
              pix01 = pix02 : pix11 = pix12 : pix21 = pix22 : pix31=pix32
            End If

            If (sy > 1)
              pix20.l = Peek.l(sptr     - sbpr*2)
              If (sx > 0    ) Then pix10.l = Peek.l(sptr -4  - sbpr*2) : Else pix10 = pix20
              If (sx > 1    ) Then pix00.l = Peek.l(sptr -8  - sbpr*2) : Else pix00 = pix10
              If (sx < sxs-1) Then pix30.l = Peek.l(sptr +4  - sbpr*2) : Else pix30 = pix20
            Else
              pix00 = pix01 : pix10 = pix11 : pix20 = pix21 : pix30=pix31
            End If

            If (sy < sys-1)
              pix23.l = Peek.l(sptr     + sbpr)
              If (sx > 0    ) Then pix13.l = Peek.l(sptr -4  + sbpr) : Else pix13 = pix23
              If (sx > 1    ) Then pix03.l = Peek.l(sptr -8  + sbpr) : Else pix03 = pix13
              If (sx < sxs-1) Then pix33.l = Peek.l(sptr +4  + sbpr) : Else pix33 = pix23
            Else
              pix03 = pix02 : pix13 = pix12 : pix23 = pix22 : pix33=pix32
            End If

            dptr.l = imagedat(dstimage)\raw_ptr + dy * imagedat(dstimage)\bpr
            fracX.l = ((dxs+sxs) ASR 1)

            For dx.l = 0 To dxs-1

              For c.l = 0 To 3
                y00.l = (Peek.b(&pix00+c) & $FF)
                y10.l = (Peek.b(&pix10+c) & $FF)
                y20.l = (Peek.b(&pix20+c) & $FF)
                y30.l = (Peek.b(&pix30+c) & $FF)
                y01.l = (Peek.b(&pix01+c) & $FF)
                y11.l = (Peek.b(&pix11+c) & $FF)
                y21.l = (Peek.b(&pix21+c) & $FF)
                y31.l = (Peek.b(&pix31+c) & $FF)
                y02.l = (Peek.b(&pix02+c) & $FF)
                y12.l = (Peek.b(&pix12+c) & $FF)
                y22.l = (Peek.b(&pix22+c) & $FF)
                y32.l = (Peek.b(&pix32+c) & $FF)
                y03.l = (Peek.b(&pix03+c) & $FF)
                y13.l = (Peek.b(&pix13+c) & $FF)
                y23.l = (Peek.b(&pix23+c) & $FF)
                y33.l = (Peek.b(&pix33+c) & $FF)

                muy.f = (fracY / (dys))
                mux.f = (fracX / (dxs))

                !cubic_catmul{a,y0,muy}
                !cubic_catmul{a,y1,muy}
                !cubic_catmul{a,y2,muy}
                !cubic_catmul{a,y3,muy}
                !cubic_catmul{b,y,mux}

                If y > 255 Then y = 255
                If y < 0 Then y = 0

                Select c
                  Case 0 : ARGB  = Int(y) LSL 24
                  Case 1 : ARGB  | Int(y) LSL 16
                  Case 2 : ARGB  | Int(y) LSL 8
                  Case 3 : ARGB  | Int(y)
                End Select
              Next

              Poke.l dptr,ARGB :dptr+4

              fracX+sxs
              While fracX > dxs : fracX-dxs
                sptr+4 : sx+1
                pix02 = pix12 : pix12 = pix22 : pix22 = pix32
                If (sx < sxs-1)
                  If (sy < sys  )
                    pix32 = Peek.l(sptr        + 4)
                  Else
                    pix32 = Peek.l(sptr2+(sx+1)*4)
                  End If
                End If
                pix01 = pix11 : pix11 = pix21 : pix21 = pix31  : If (sx < sxs-1) Then If (sy > 0    ) Then pix31 = Peek.l(sptr - sbpr + 4) : Else pix31 = pix32
                pix00 = pix10 : pix10 = pix20 : pix20 = pix30  : If (sx < sxs-1) Then If (sy > 1    ) Then pix30 = Peek.l(sptr - sbpr*2+4) : Else pix30 = pix31
                pix03 = pix13 : pix13 = pix23 : pix23 = pix33  : If (sx < sxs-1) Then If (sy < sys-1) Then pix33 = Peek.l(sptr + sbpr + 4) : Else pix33 = pix32
              Wend
            Next
            fracY+sys : While fracY > dys : fracY-dys : sy+1 : Wend
          Next

        Case #image_interpol_gui
          tmp.l    = imagedat(dstimage)\raw_ptr
          tmpbpr.l = imagedat(dstimage)\bpr
          If imagedat(srcimage)\alpha_isused = False Then image_SetAlpha{srcimage,$FF} : imagedat(srcimage)\alpha_isused = False

          destbase.l   = tmp
          dbpr.l       = tmpbpr
          sourcebase.l = imagedat(srcimage)\raw_ptr
          sbpr.l       = imagedat(srcimage)\bpr

          ; scale step
          fracY.l      = 0
          pw.l         = sxs*sys

          shift.l      = 0
          While pw > $1000 : pw/2 : shift+1 : Wend
          If pw < 1 Then pw = 1

          For dy.l = 0 To dys-1
            weightY1.l = (dys-fracY)
            cy.l       = 0 : fracY+sys : While fracY > dys : fracY-dys : cy+1 : Wend
            sptr.l     = imagedat(srcimage)\raw_ptr + sy * imagedat(srcimage)\bpr
            dptr.l     = imagedat(dstimage)\raw_ptr + dy * imagedat(dstimage)\bpr
            fracX.l    = 0
            For dx.l = 0 To dxs-1
              weightX1.l = (dxs-fracX)
              cx.l=0 : fracX+sxs : While fracX > dxs : fracX-dxs : cx+1 : Wend

              ; Calculate the pixel...
              R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
              weightY.l = weightY1
              nsptr.l   = sptr + (cx LSL 2)

              div.l = 0
              For m.l = 0 To cy
                weightX.l = weightX1
                If m = cy Then weightY = weightY + (fracY-dys)
                For n.l = 0 To cx
                  If n = cx Then weightX = weightX + (fracX-dxs)
                  tpw.l   = (weightX*weightY) LSR shift
                  tA.l    = Peek.b(sptr  ) & $FF
                  A.l + (tA) * tpw
                  R.l + (Peek.b(sptr+1) & $FF) * (tpw * tA)
                  G.l + (Peek.b(sptr+2) & $FF) * (tpw * tA)
                  B.l + (Peek.b(sptr+3) & $FF) * (tpw * tA)
                  div     = div + (tpw*tA)
                  weightX = (dxs)
                  sptr+4
                Next
                sptr - 4*(cx+1) + imagedat(srcimage)\bpr
                weightY = (dys)
              Next
              sptr = nsptr
              If div > 0
                Poke.b dptr  ,A / pw
                Poke.b dptr+1,R / div
                Poke.b dptr+2,G / div
                Poke.b dptr+3,B / div
              Else
                Poke.l dptr,0
              End If
  ;
  ;            For m.l = 0 To cy
  ;              weightX.l = weightX1
  ;              If m = cy Then weightY = weightY + (fracY-dys)
  ;              For n.l = 0 To cx
  ;                If n = cx Then weightX = weightX + (fracX-dxs)
  ;                tpw.l = weightX*weightY
  ;                A.l + (Peek.b(sptr  ) & $FF) * tpw
  ;                R.l + (Peek.b(sptr+1) & $FF) * tpw
  ;                G.l + (Peek.b(sptr+2) & $FF) * tpw
  ;                B.l + (Peek.b(sptr+3) & $FF) * tpw
  ;                weightX = (dxs)
  ;                sptr+4
  ;              Next
  ;              sptr - 4*(cx+1) + imagedat(srcimage)\bpr
  ;              weightY = (dys)
  ;            Next
  ;            sptr = nsptr
  ;
  ;            Poke.b dptr  ,A / pw
  ;            Poke.b dptr+1,R / pw
  ;            Poke.b dptr+2,G / pw
  ;            Poke.b dptr+3,B / pw
              dptr+4
            Next
            sy+cy
          Next

          fracX.l = 0
          fracY.l = 0
          sy.l    = 0
          pw.l    = sxs*sys
          shift.l = 0
          While pw > $1000 : pw/2 : shift+1 : Wend
          If pw < 1 Then pw = 1
          sharpness = sharpness * 256.0
          sn.l      = sharpness

          For dy.l = 0 To dys-1
            weightY1.l = (dys-fracY)
            cy.l       = 0 : fracY+sys : While fracY > dys : fracY-dys : cy+1 : Wend
            sptr.l     = imagedat(srcimage)\raw_ptr + sy * imagedat(srcimage)\bpr
            dptr.l     = imagedat(dstimage)\raw_ptr + dy * imagedat(dstimage)\bpr
            tptr.l     = tmp + dy * tmpbpr
            tbpr.l     = tmpbpr
            fracX.l = 0
            For dx.l = 0 To dxs-1
              weightX1.l = (dxs-fracX)
              cx.l=0 : fracX+sxs : While fracX>dxs : fracX-dxs : cx+1 : Wend

              ; Calculate the pixel...
              R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
              weightY.l = weightY1
              nsptr.l = sptr + (cx LSL 2)

              ; get the sourounding ...
              div.l = 0
              aR.l  = 0
              aG.l  = 0
              aB.l  = 0
              If dx > 0
                aR.l + (Peek.b(tptr+1-4) & $FF) LSL 1
                aG.l + (Peek.b(tptr+2-4) & $FF) LSL 1
                aB.l + (Peek.b(tptr+3-4) & $FF) LSL 1
                div+2
              End If
              If dx < dxs-1
                aR.l + (Peek.b(tptr+1+4) & $FF) LSL 1
                aG.l + (Peek.b(tptr+2+4) & $FF) LSL 1
                aB.l + (Peek.b(tptr+3+4) & $FF) LSL 1
                div+2
              End If
              If dy > 0
                aR.l + (Peek.b(tptr+1-tbpr) & $FF) LSL 1
                aG.l + (Peek.b(tptr+2-tbpr) & $FF) LSL 1
                aB.l + (Peek.b(tptr+3-tbpr) & $FF) LSL 1
                div+2
              End If
              If dy < dys-1
                aR.l + (Peek.b(tptr+1+tbpr) & $FF) LSL 1
                aG.l + (Peek.b(tptr+2+tbpr) & $FF) LSL 1
                aB.l + (Peek.b(tptr+3+tbpr) & $FF) LSL 1
                div+2
              End If

  ;If False
              If dx > 0 AND dy > 0
                aR.l + (Peek.b(tptr+1-4-tbpr) & $FF)
                aG.l + (Peek.b(tptr+2-4-tbpr) & $FF)
                aB.l + (Peek.b(tptr+3-4-tbpr) & $FF)
                div+1
              End If
              If dx < dxs-1 AND dy < dys-1
                aR.l + (Peek.b(tptr+1+4+tbpr) & $FF)
                aG.l + (Peek.b(tptr+2+4+tbpr) & $FF)
                aB.l + (Peek.b(tptr+3+4+tbpr) & $FF)
                div+1
              End If
              If dy > 0 AND dx < dxs-1
                aR.l + (Peek.b(tptr+1+4-tbpr) & $FF)
                aG.l + (Peek.b(tptr+2+4-tbpr) & $FF)
                aB.l + (Peek.b(tptr+3+4-tbpr) & $FF)
                div+1
              End If
              If dy < dys-1 AND dx > 0
                aR.l + (Peek.b(tptr+1-4+tbpr) & $FF)
                aG.l + (Peek.b(tptr+2-4+tbpr) & $FF)
                aB.l + (Peek.b(tptr+3-4+tbpr) & $FF)
                div+1
              End If
  ;End If
              If div > 0
                aR / div
                aG / div
                aB / div
              End If
              addWeight.l = 0

              For m.l = 0 To cy
                weightX.l = weightX1
                If m = cy Then weightY = weightY + (fracY-dys)
                For n.l = 0 To cx
                  If n = cx Then weightX = weightX + (fracX-dxs)
                  tpw.l = (weightX*weightY) LSR shift
                  tA.l  = Peek.b(sptr  ) & $FF
                  tR.l  = Peek.b(sptr+1) & $FF
                  tG.l  = Peek.b(sptr+2) & $FF
                  tB.l  = Peek.b(sptr+3) & $FF

                  dR.l  = aR-tR
                  dG.l  = aG-tG
                  dB.l  = aB-tB
                  d.l   = ((dR*dR + dG*dG + dB*dB) * sn ) LSR 16
                  ;NPrint aR,"/",aG,"/",aB," :: ",tR,"/",tG,"/",tB,"=> ",d
                  If d < 1 Then d = 1
                  fX.l = (tpw * d * tA) LSR 8
                  ;A.l + (tA * fX) ; alternative
                  R.l + (tR * fX)
                  G.l + (tG * fX)
                  B.l + (tB * fX)
                  addWeight + fX
                  weightX = dxs
                  sptr+4
                Next
                sptr - 4*(cx+1) + imagedat(srcimage)\bpr
                weightY = (dys)
              Next
              sptr = nsptr

              If addWeight > 0
                R / addWeight
                G / addWeight
                B / addWeight
               ; A / addWeight
              End If

  ;            Poke.b dptr  ,A / pw
              Poke.b dptr+1,R ;/ pw
              Poke.b dptr+2,G ;/ pw
              Poke.b dptr+3,B ;/ pw
              dptr +4
              tptr +4
            Next
            sy+cy
          Next

        Case #image_interpol_gui_depricated
          If False;True
            tmp.l    = tempbuffer_Get{dxs*dys*4}
            tmpbpr.l = dxs*4
            If tmp = 0 Then Function Return False
          Else
            tmp.l    = imagedat(dstimage)\raw_ptr
            tmpbpr.l = imagedat(dstimage)\bpr
          End If
          If imagedat(srcimage)\alpha_isused = False Then image_SetAlpha{srcimage,$FF} : imagedat(srcimage)\alpha_isused = False

          destbase.l   = tmp
          dbpr.l       = tmpbpr
          sourcebase.l = imagedat(srcimage)\raw_ptr
          sbpr.l       = imagedat(srcimage)\bpr

          ; scale step
          fracY.l = 0
          pw.l = sxs*sys : If pw < 1 Then pw = 1
          For dy.l = 0 To dys-1
            weightY1.l = (dys-fracY)
            cy.l       = 0 : fracY+sys : While fracY > dys : fracY-dys : cy+1 : Wend
            sptr.l     = imagedat(srcimage)\raw_ptr + sy * imagedat(srcimage)\bpr
            dptr.l     = imagedat(dstimage)\raw_ptr + dy * imagedat(dstimage)\bpr
            fracX.l    = 0
            For dx.l = 0 To dxs-1
              weightX1.l = (dxs-fracX)
              cx.l=0 : fracX+sxs : While fracX > dxs : fracX-dxs : cx+1 : Wend

              ; Calculate the pixel...
              R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
              weightY.l = weightY1
              nsptr.l = sptr + (cx LSL 2)
              For m.l = 0 To cy
                weightX.l = weightX1
                If m = cy Then weightY = weightY + (fracY-dys)
                For n.l = 0 To cx
                  If n = cx Then weightX = weightX + (fracX-dxs)
                  tpw.l = weightX*weightY
                  A.l + (Peek.b(sptr  ) & $FF) * tpw
                  R.l + (Peek.b(sptr+1) & $FF) * tpw
                  G.l + (Peek.b(sptr+2) & $FF) * tpw
                  B.l + (Peek.b(sptr+3) & $FF) * tpw
                  weightX = (dxs)
                  sptr+4
                Next
                sptr - 4*(cx+1) + imagedat(srcimage)\bpr
                weightY = (dys)
              Next
              sptr = nsptr

              Poke.b dptr  ,A / pw
              Poke.b dptr+1,R / pw
              Poke.b dptr+2,G / pw
              Poke.b dptr+3,B / pw
              dptr+4
            Next
            sy+cy
          Next

          fracX.l   = 0
          fracY.l   = 0
          sy.l      = 0
          winsize.l = 256-(sharpness*128.0)
          If winsize < 1 Then winsize = 1
          If winsize > 256 Then winsize = 256
          winxs.l   = (sxs * winsize) LSR 8 : If winxs < 1 Then winxs = 1
          winx.l    = (sxs-winxs) / 2
          winys.l   = (sys * winsize) LSR 8 : If winys < 1 Then winys = 1
          winy.l    = (sys-winys) / 2
          pw.l      = winxs*winys

          ;pw.l = sxs*sys : If pw<1 Then pw=1
          r.l = pw / $1000
          If r < 1 Then r = 1
          r = r*r
          pw / (r)
          If pw < 1 Then pw = 1

          destbase.l   = imagedat(dstimage)\raw_ptr
          dbpr.l       = imagedat(dstimage)\bpr
          sourcebase.l = imagedat(srcimage)\raw_ptr
          sbpr.l       = imagedat(srcimage)\bpr
          tmpbase.l    = tmp
          tbpr.l       = tmpbpr
          ; the sharpen step

          For dy.l = 0 To dys-1
            fracYR.l   = fracY + winy
            cyO.l      = 0 : While fracYR > dys : fracYR-dys : cyO+1 : Wend
            weightY1.l = (dys-fracYR)
            cy.l       = 0 : fracY+sys : While fracY > dys : fracY-dys : cy+1 : Wend
            ny.l       = sy+cy
            cyR.l      = 0 : fracYR+winys : While fracYR > dys : fracYR-dys : cyR+1 : Wend
            sy + cyO
            sptr.l     = sourcebase + sy * sbpr
            dptr.l     = destbase   + dy * dbpr
            tptr.l     = tmpbase    + dy * tbpr
            fracX.l    = 0

            For dx.l = 0 To dxs-1
              fracXR.l   = fracX + winx
              cxO.l=0 : While fracXR > dxs : fracXR-dxs : cxO+1 : Wend
              weightX1.l = (dxs-fracXR)
              cx.l       = 0 : fracX+sxs : While fracX > dxs : fracX-dxs : cx+1 : Wend
              cxR.l      = 0 : fracXR+winxs : While fracXR > dxs : fracXR-dxs : cxR+1 : Wend
              ; Calculate the pixel...
              R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
              weightY.l  = weightY1
              nsptr.l    = sptr + (cx LSL 2)
              sptr + (cxO LSL 2)

              ; get the sourounding ...
              div.l = 0
              aR.l  = 0
              aG.l  = 0
              aB.l  = 0
              If dx > 0
                aR.l + (Peek.b(tptr+1-4) & $FF) LSL 1
                aG.l + (Peek.b(tptr+2-4) & $FF) LSL 1
                aB.l + (Peek.b(tptr+3-4) & $FF) LSL 1
                div+2
              End If
              If dx < dxs-1
                aR.l + (Peek.b(tptr+1+4) & $FF) LSL 1
                aG.l + (Peek.b(tptr+2+4) & $FF) LSL 1
                aB.l + (Peek.b(tptr+3+4) & $FF) LSL 1
                div+2
              End If
              If dy > 0
                aR.l + (Peek.b(tptr+1-tbpr) & $FF) LSL 1
                aG.l + (Peek.b(tptr+2-tbpr) & $FF) LSL 1
                aB.l + (Peek.b(tptr+3-tbpr) & $FF) LSL 1
                div+2
              End If
              If dy < dys-1
                aR.l + (Peek.b(tptr+1+tbpr) & $FF) LSL 1
                aG.l + (Peek.b(tptr+2+tbpr) & $FF) LSL 1
                aB.l + (Peek.b(tptr+3+tbpr) & $FF) LSL 1
                div+2
              End If

              If dx > 0 AND dy > 0
                aR.l + (Peek.b(tptr+1-4-tbpr) & $FF)
                aG.l + (Peek.b(tptr+2-4-tbpr) & $FF)
                aB.l + (Peek.b(tptr+3-4-tbpr) & $FF)
                div+1
              End If
              If dx < dxs-1 AND dy < dys-1
                aR.l + (Peek.b(tptr+1+4+tbpr) & $FF)
                aG.l + (Peek.b(tptr+2+4+tbpr) & $FF)
                aB.l + (Peek.b(tptr+3+4+tbpr) & $FF)
                div+1
              End If
              If dy > 0 AND dx < dxs-1
                aR.l + (Peek.b(tptr+1+4-tbpr) & $FF)
                aG.l + (Peek.b(tptr+2+4-tbpr) & $FF)
                aB.l + (Peek.b(tptr+3+4-tbpr) & $FF)
                div+1
              End If
              If dy < dys-1 AND dx > 0
                aR.l + (Peek.b(tptr+1-4+tbpr) & $FF)
                aG.l + (Peek.b(tptr+2-4+tbpr) & $FF)
                aB.l + (Peek.b(tptr+3-4+tbpr) & $FF)
                div+1
              End If

              If div > 0
                aR / div
                aG / div
                aB / div
              End If
              addWeight.l = 0

              For m.l = 0 To cyR
                weightX.l = weightX1
                If m = cyR Then weightY = weightY + (fracYR-dys)
                For n.l = 0 To cxR
                  If n = cxR Then weightX = weightX + (fracXR-dxs)
                  tpw.l = (weightX*weightY)/(r)
                  If tpw < 1 Then tpw = 1

                  tR.l = Peek.b(sptr+1) & $FF
                  tG.l = Peek.b(sptr+2) & $FF
                  tB.l = Peek.b(sptr+3) & $FF

                  dR.l = aR-tR ;: If dR<0 Then dR = -dR
                  dG.l = aG-tG ;: If dG<0 Then dG = -dG
                  dB.l = aB-tB ;: If dB<0 Then dB = -dB
                  f.f = Sqr(dR*dR + dG*dG + dB*dB) * sharpness
                  d.l = f
                  ;d = d+1;(d LSR 1) + 1

                  tA.l = (Peek.b(sptr  ) & $FF)
                  fX.l = (tpw * (d)  * tA) LSR 8
                  If fX < 1 Then fX = 1
                  ;A = A+(tA*tpw)
                  A.l + (tA * fX) ; alternative
                  R.l + (tR * fX)
                  G.l + (tG * fX)
                  B.l + (tB * fX)
                  addWeight + fX
                  weightX = dxs
                  sptr+4
                Next
                sptr - 4*(cxR+1) + sbpr
                weightY = dys
              Next
              sptr = nsptr
              ;A / pw    : If A>255 Then A=255
              If addWeight > 0
                R / addWeight  ;: If R>255 Then R=255
                G / addWeight  ;: If G>255 Then G=255
                B / addWeight  ;: If B>255 Then B=255
                A / addWeight
              End If

              ;Poke.b dptr  ,A
              Poke.b dptr+1,R
              Poke.b dptr+2,G
              Poke.b dptr+3,B

              dptr+4
              tptr+4
            Next
            sy = ny
          Next

        Case #image_interpol_test; test
            fracY.l = 0
            pw.l    = sxs*sys
            r.l     = pw / $100000
            If r < 1 Then r = 1
            r = r*r
            pw / (r)
            For dy.l = 0 To dys-1
              weightY1.l = (dys-fracY)
              cy.l       = 0 : fracY+sys : While fracY > dys : fracY-dys : cy+1 : Wend
              sptr.l     = imagedat(srcimage)\raw_ptr + sy * imagedat(srcimage)\bpr
              dptr.l     = imagedat(dstimage)\raw_ptr + dy * imagedat(dstimage)\bpr
              fracX.l    = 0
              For dx.l = 0 To dxs-1
                weightX1.l = (dxs-fracX)
                cx.l       = 0 : fracX+sxs : While fracX > dxs : fracX-dxs : cx+1 : Wend
                ; Calculate the pixel...
                R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
                weightY.l  = weightY1
                nsptr.l    = sptr ;+ (cx LSL 2)
                For m.l = 0 To cy
                  weightX.l = weightX1
                  If m = cy Then weightY = weightY + (fracY-dys)
                  For n.l = 0 To cx
                    If n = cx Then weightX = weightX + (fracX-dxs)
                    tpw.l = weightX*weightY/r
                    A.l + (Peek.b(sptr  ) & $FF) * tpw
                    R.l + (Peek.b(sptr+1) & $FF) * tpw
                    G.l + (Peek.b(sptr+2) & $FF) * tpw
                    B.l + (Peek.b(sptr+3) & $FF) * tpw
                    weightX = (dxs)
                    sptr+4
                  Next
                  sptr - 4*(cx+1) + imagedat(srcimage)\bpr
                  weightY = (dys)
                Next

                rR.l = 0 : rG.l = 0: rB.l = 0 : rA.l = 0
                weightY.l = weightY1
                addWA.l   = 0
                addWR.l   = 0
                addWG.l   = 0
                addWB.l   = 0
                sptr      = nsptr
                nsptr.l   = sptr + (cx LSL 2)
                For m.l = 0 To cy
                  weightX.l = weightX1
                  If m = cy Then weightY = weightY + (fracY-dys)
                  For n.l = 0 To cx
                    If n = cx Then weightX = weightX + (fracX-dxs)
                    tpw.l = weightX*weightY
                    dA.l  = (Peek.b(sptr  ) & $FF) - lAx.l
                    dR.l  = (Peek.b(sptr+1) & $FF) - lR.l
                    dG.l  = (Peek.b(sptr+2) & $FF) - lG.l
                    dB.l  = (Peek.b(sptr+3) & $FF) - lB.l
                    If dA < 0 Then dA =- dA
                    If dR < 0 Then dR =- dR
                    If dG < 0 Then dG =- dG
                    If dB < 0 Then dB =- dB
                    ;dA*dA / 256
                    ;dR*dR / 256
                    ;dG*dG / 256
                    ;dB*dB / 256

                    ;dA = 256-dA
                    ;dR = 256-dR
                    ;dG = 256-dG
                    ;dB = 256-dB

                    dA = ((32 + dA ) *tpw) / 256
                    dR = ((32 + dR ) *tpw) / 256
                    dG = ((32 + dG ) *tpw) / 256
                    dB = ((32 + dB ) *tpw) / 256
                    addWA + (dA)
                    addWR + (dR)
                    addWG + (dG)
                    addWB + (dB)
                    rA + (Peek.b(sptr  ) & $FF) * (dA)
                    rR + (Peek.b(sptr+1) & $FF) * (dR)
                    rG + (Peek.b(sptr+2) & $FF) * (dG)
                    rB + (Peek.b(sptr+3) & $FF) * (dB)
                    weightX = (dxs)
                    sptr+4
                  Next
                  sptr - 4*(cx+1) + imagedat(srcimage)\bpr
                  weightY = (dys)
                Next

                sptr = nsptr

                rA / (addWA) : If rA > 255 Then rA = 255
                rR / (addWR) : If rR > 255 Then rR = 255
                rG / (addWG) : If rG > 255 Then rG = 255
                rB / (addWB) : If rB > 255 Then rB = 255

                Poke.b dptr  ,rA
                Poke.b dptr+1,rR
                Poke.b dptr+2,rG
                Poke.b dptr+3,rB
                dptr+4

                lAx = A / pw
                lR  = R/ pw
                lG  = G/ pw
                lB  = B/ pw
                lAx = rA
                lG  = rG
                lB  = rB
                lR  = rR
              Next
              sy+cy
            Next

        Case #image_interpol_alpha
          fracY.l = 0
          pw.l    = sxs*sys
          shift   = 0
          While pw > $1000 : pw/2 : shift+1 : Wend
          ;r.l = pw / $100000
          If r < 1 Then r = 1
          ;r = r*r
          ;pw / (r)
          For dy.l = 0 To dys-1
            weightY1.l = (dys-fracY)
            cy.l       = 0 : fracY+sys : While fracY > dys : fracY-dys : cy+1 : Wend
            sptr.l     = imagedat(srcimage)\raw_ptr + sy * imagedat(srcimage)\bpr
            dptr.l     = imagedat(dstimage)\raw_ptr + dy * imagedat(dstimage)\bpr
            fracX.l    = 0
            For dx.l = 0 To dxs-1
              weightX1.l = (dxs-fracX)
              cx.l       = 0 : fracX+sxs : While fracX > dxs : fracX-dxs : cx+1 : Wend
              ; Calculate the pixel...
              R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
              weightY.l  = weightY1
              nsptr.l    = sptr + (cx LSL 2)
              div.l      = 0
              For m.l = 0 To cy
                weightX.l = weightX1
                If m = cy Then weightY = weightY + (fracY-dys)
                For n.l = 0 To cx
                  If n = cx Then weightX = weightX + (fracX-dxs)
                  tpw.l   = (weightX*weightY) LSR shift
                  tA.l    = Peek.b(sptr  ) & $FF
                  A.l + (tA) * tpw
                  R.l + (Peek.b(sptr+1) & $FF) * (tpw * tA)
                  G.l + (Peek.b(sptr+2) & $FF) * (tpw * tA)
                  B.l + (Peek.b(sptr+3) & $FF) * (tpw * tA)
                  div     = div + (tpw*tA)
                  weightX = (dxs)
                  sptr+4
                Next
                sptr - 4*(cx+1) + imagedat(srcimage)\bpr
                weightY = (dys)
              Next
              sptr = nsptr
              If div > 0
                Poke.b dptr  ,A / pw
                Poke.b dptr+1,R / div
                Poke.b dptr+2,G / div
                Poke.b dptr+3,B / div
              Else
                Poke.l dptr,0
              End If
              dptr+4
            Next
            sy+cy
          Next

        Default ; sliding window interpolation
          sharpness * 256.0
          winsize.l = 256-sharpness
          If winsize < 1 Then winsize = 1
          If winsize > 256 Then winsize = 256
          If winsize > 254
            fracY.l = 0
            pw.l    = sxs*sys
            r.l     = pw / $100000
            If r < 1 Then r = 1
            r = r*r
            pw / (r)
            For dy.l = 0 To dys-1
              weightY1.l = (dys-fracY)
              cy.l       = 0 : fracY+sys : While fracY > dys : fracY-dys : cy+1 : Wend
              sptr.l     = imagedat(srcimage)\raw_ptr + sy * imagedat(srcimage)\bpr
              dptr.l     = imagedat(dstimage)\raw_ptr + dy * imagedat(dstimage)\bpr
              fracX.l    = 0
              For dx.l = 0 To dxs-1
                weightX1.l = (dxs-fracX)
                cx.l       = 0 : fracX+sxs : While fracX > dxs : fracX-dxs : cx+1 : Wend
                ; Calculate the pixel...
                R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
                weightY.l = weightY1
                nsptr.l = sptr + (cx LSL 2)
                For m.l = 0 To cy
                  weightX.l = weightX1
                  If m = cy Then weightY = weightY + (fracY-dys)
                  For n.l = 0 To cx
                    If n = cx Then weightX = weightX + (fracX-dxs)
                    tpw.l   = weightX*weightY/r
                    A.l + (Peek.b(sptr  ) & $FF) * tpw
                    R.l + (Peek.b(sptr+1) & $FF) * tpw
                    G.l + (Peek.b(sptr+2) & $FF) * tpw
                    B.l + (Peek.b(sptr+3) & $FF) * tpw
                    weightX = (dxs)
                    sptr+4
                  Next
                  sptr - 4*(cx+1) + imagedat(srcimage)\bpr
                  weightY = (dys)
                Next
                sptr = nsptr

                Poke.b dptr  ,A / pw
                Poke.b dptr+1,R / pw
                Poke.b dptr+2,G / pw
                Poke.b dptr+3,B / pw
                dptr+4
              Next
              sy+cy
            Next
          Else
            winxs.l = (sxs * winsize) LSR 8 : If winxs < 1 Then winxs = 1
            winx.l  = (sxs-winxs) / 2
            winys.l = (sys * winsize) LSR 8 : If winys < 1 Then winys = 1
            winy.l  = (sys-winys) / 2
            pw.l    = winxs*winys
            r.l     = pw / $100000
            If r < 1 Then r = 1
            r = r*r
            pw / (r)
            fracY.l = 0
            For dy.l = 0 To dys-1
              fracYR.l   = fracY + winy
              cyO.l      = 0 : While fracYR > dys : fracYR-dys : cyO+1 : Wend
              weightY1.l = (dys-fracYR)
              cy.l       = 0 : fracY+sys : While fracY > dys : fracY-dys : cy+1 : Wend
              ny.l       = sy+cy
              cyR.l      = 0 : fracYR+winys : While fracYR > dys : fracYR-dys : cyR+1 : Wend
              sy + cyO
              sptr.l     = imagedat(srcimage)\raw_ptr + sy * imagedat(srcimage)\bpr
              dptr.l     = imagedat(dstimage)\raw_ptr + dy * imagedat(dstimage)\bpr
              fracX.l    = 0
              For dx.l = 0 To dxs-1
                fracXR.l = fracX + winx
                cxO.l      = 0 : While fracXR > dxs : fracXR-dxs : cxO+1 : Wend
                weightX1.l = (dxs-fracXR)
                cx.l       = 0 : fracX+sxs : While fracX > dxs : fracX-dxs : cx+1 : Wend
                cxR.l      = 0 : fracXR+winxs : While fracXR > dxs : fracXR-dxs : cxR+1 : Wend
                ; Calculate the pixel...
                R.l = 0 : G.l = 0: B.l = 0 : A.l = 0
                weightY.l  = weightY1
                nsptr.l    = sptr + (cx LSL 2)
                sptr + (cxO LSL 2)
                For m.l = 0 To cyR
                  weightX.l = weightX1
                  If m = cyR Then weightY = weightY + (fracYR-dys)
                  For n.l = 0 To cxR
                    If n = cxR Then weightX = weightX + (fracXR-dxs)
                    tpw.l = weightX*weightY/r
                    A.l + (Peek.b(sptr  ) & $FF) * tpw
                    R.l + (Peek.b(sptr+1) & $FF) * tpw
                    G.l + (Peek.b(sptr+2) & $FF) * tpw
                    B.l + (Peek.b(sptr+3) & $FF) * tpw
                    weightX = dxs
                    sptr+4
                  Next
                  sptr - 4*(cxR+1) + imagedat(srcimage)\bpr
                  weightY = dys
                Next
                sptr = nsptr

                Poke.b dptr  ,A / pw
                Poke.b dptr+1,R / pw
                Poke.b dptr+2,G / pw
                Poke.b dptr+3,B / pw
                dptr+4
              Next
              sy=ny
            Next
          End If
      End Select
    End If
  End If

  Function Return succ
End Function
;LastRunErrsMode
;     dxs
;s |------|------|------|------|
;d |---|---|---|---|---|---|---|
;   sxs

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_SetClip{image.l,x1.l,y1.l,x2.l,y2.l}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Set a clip region to the images rastport.                                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - x1.l    : ???                                                             /
;/ - y1.l    : ???                                                             /
;/ - x2.l    : ???                                                             /
;/ - y2.l    : ???                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_SetClip{image.l,x1.l,y1.l,x2.l,y2.l}

  cliprect.Rectangle\MinX = Max(x1,0)
  cliprect.Rectangle\MinY = Max(y1,0)
  cliprect.Rectangle\MaxX = Min(x2,\img_width-1)
  cliprect.Rectangle\MaxY = Min(y2,\img_height-1)
  *new_region.Region = NewRegion_
  If *new_region
    If OrRectRegion_(*new_region, &cliprect)
      *old_region.Region = InstallClipRegion_(\rastport_ptr\Layer, *new_region)
      If *old_region
        DisposeRegion_ *old_region
      End If
    End If
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_RemClip{image.l}                                              /
;/                                                                             /
;/ Description:                                                                /
;/ Remove a layer clip region on an image rastport.                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_RemClip{image.l}
SHARED imagedat()

  image_SetClip{image.l,0,0,\img_width-1,\img_height-1}
End Statement

NEWTYPE .ChunkyImage
  Width.w
  Height.w
  NumColors.w
  Flags.w
  *Palettez.b
  *ChunkyData.b
End NEWTYPE

#CIF_COLOR_0_TRANSP = 0
#CIF_DEFAULT        = 1

NEWTYPE .NewDiskObject
  *ndo_StdObject.DiskObject
  *ndo_NormalImage.ChunkyImage
  *ndo_SelectedImage.ChunkyImage
End NEWTYPE

NEWTYPE.image_RGB32
  R.l
  G.l
  B.l
  A.l
End NEWTYPE

NEWTYPE.image_ARGB
  A.b
  R.b
  G.b
  B.b
End NEWTYPE

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = image_LoadViaNI{image.l,filename.s,@normal.l}             /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/ Loads an NewIcon .info file into an image object.                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - filename.s : Complete dos filename including path                         /
;/ - normal :  0= selected, ><0 normal state                                   /
;/ - normal.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : True if everything went well, False if it failed             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_LoadNewIcon{image.l,filename.s,@normal.l} ; NNum.l,NPath$,NMode.l}
SHARED imagedat(),imageengine,version_newiconlib.l

  USEPATH imagedat(image)
  DEFTYPE.RastPort temprp
  If version_newiconlib = 0 Then version_newiconlib = dos_GetLibVersion{"newicon.library"}
  If version_newiconlib <= 0 Then Function Return False

  succ.l = False
  If LCase$(Right$(filename.s,5)) = ".info"
    filename.s = UnLeft$(filename.s,5)
  EndIf
  *ndo.NewDiskObject = GetNewDiskObject_(&filename.s)
  If *ndo
    If Used Screen >= 0
      *scr.Screen = Peek.l(Addr Screen(Used Screen))
      If *scr
        scr_depth.l  = GetBitMapAttr_(*scr\RastPort\BitMap,#BMA_DEPTH)
        If normal
          *image.Image = RemapChunkyImage_(*ndo\ndo_NormalImage,*scr)
        Else
          *image.Image = RemapChunkyImage_(*ndo\ndo_SelectedImage,*scr)
        End If
        If *image
  ;        *bmp.BitMap = AllocBitMap_(*image\Width,*image\Height,scr_depth,#BMF_CLEAR|#BMF_DISPLAYABLE,*scr\RastPort\BitMap)
          *bmp.BitMap = AllocBitMap_(*image\Width,*image\Height,scr_depth,#BMF_CLEAR|#BMF_DISPLAYABLE|#BMF_MINPLANES,*scr\RastPort\BitMap)
          If *bmp
            InitRastPort_ temprp
            temprp\BitMap = *bmp
            ;SetAPen_ temprp,2
            ;RectFill_ temprp,0,0,*image\Width-1,*image\Height-1
            DrawImage_ temprp,*image,0,0
            *view.ViewPort = *scr\ViewPort
            *cmap.ColorMap = *view\ColorMap
            GetRGB32_ *cmap,0,1,&bgcol.image_RGB32
            trgb.l = ((bgcol\B LSR 24)) | ((bgcol\G LSR 24) LSL 8) | ((bgcol\R LSR 24) LSL 16)
            succ = image_CutRP{image,temprp,0,0,*image\Width,*image\Height,trgb,40}
            FreeBitMap_ *bmp
          End If
          FreeRemappedImage_ *image,*scr
        End If
        FreeNewDiskObject_ *ndo
      End If
    End If
  EndIf
  Function Return succ
End Function

Function.l image_LoadIconV44{image.l,filename.s,@normal.l}
SHARED imagedat(),imageengine,version_iconlib.l

  USEPATH imagedat(image)
  If version_iconlib = 0 Then version_iconlib = dos_GetLibVersion{"icon.library"}
  If version_iconlib < 44 Then Function Return False

  succ.l = False
  If LCase$(Right$(filename.s,5)) = ".info"
    filename.s = UnLeft$(filename.s,5)
  EndIf

  tag5.tag5\ti_Tag = #ICONGETA_FailIfUnavailable,#FALSE,#TAG_END,0
  *icon.DiskObject = GetIconTagList_ (&filename,&tag5)

  If *icon
    DEFTYPE.Rectangle rectLI
    rectLI\MinX = 0,0,0,0

    tag5.tag5\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#TAG_DONE,0
  RunErrsOff
    MOVE.l a4,-(a7)
    MOVE.l a5,-(a7)
    MOVE.l a6,-(a7)
    MOVE.l d7,-(a7)
    GetIconRectangleA_ 0,*icon,0,rectLI,tag5
    MOVE.l (a7)+,d7
    MOVE.l (a7)+,a6
    MOVE.l (a7)+,a5
    MOVE.l (a7)+,a4
  LastRunErrsMode
    width.l  = rectLI\MaxX - rectLI\MinX +1
    height.l = rectLI\MaxY - rectLI\MinY +1
    xoff.l   = -rectLI\MinX
    yoff.l   = -rectLI\MinY

    If image_Create{image,width,height,True}
    *rp.RastPort     = image_GetRPPtr{image}
    *raw.image_RGB32 = AllocVec_(width*height*4,#MEMF_ANY)

    If *rp >< #NULL AND *raw >< #NULL
      If normal Then state.l = #IDS_NORMAL : Else state = #IDS_SELECTED
      FillPixelArray_ *rp,0,0,width,height,$00FFFFFF
      tag5.tag5\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#TAG_DONE,0
      DrawIconStateA_ *rp,*icon,#NULL,xoff,yoff,state,tag5
      ReadPixelArray_ *raw,0,0,width*4,*rp,0,0,width,height,#RECTFMT_ARGB

      FillPixelArray_ *rp,0,0,width,height,$00000000
      tag5.tag5\ti_Tag = #ICONDRAWA_Borderless,#TRUE,#ICONDRAWA_EraseBackground,#FALSE,#TAG_DONE,0
      DrawIconStateA_ *rp,*icon,#NULL,xoff,yoff,state,tag5
      bmaplock.l = LockBitMapTagList_(*rp\BitMap,Tags(#LBMI_BASEADDRESS,&bmapptr.l,#LBMI_BYTESPERROW,&bmapbpr.l))
      UnLockBitMap_ bmaplock
      For y.l = 0 To height-1 ; Opaque Alpha Channel
        *src2.image_ARGB = *raw + y*(width*4)
        *src1.image_ARGB = bmapptr + y*bmapbpr
        *dst.image_ARGB  = *raw + y*(width*4)
        For x.l = 0 To width-1
          a.l = ( ((*src2\R&$FF) - (*src1\R&$FF))); + ((*src2\G&$FF) - (*src1\G&$FF)) + ((*src2\B&$FF) - (*src1\B&$FF))) / 3
          ;If a<0 Then a=0
          ;If a>255 Then a=255
          a = 255-a
          *dst\A = a
          *dst+4
          *src1+4
          *src2+4
        Next
      Next

      For y.l = 0 To height-1 ; Opaque Alpha Channel
        *src.image_ARGB = *raw + y*(width*4)
        *dst.image_ARGB = bmapptr + y*bmapbpr
        For x.l = 0 To width-1
          a.l = (*src\A&$FF)
          If a > 0
            r.l = ((*dst\R&$FF) *255) / (a)
            g.l = ((*dst\G&$FF) *255) / (a)
            b.l = ((*dst\B&$FF) *255) / (a)

            ;If r > 255 Then r=255
            ;If g > 255 Then g=255
            ;If b > 255 Then b=255
            *dst\R = r
            *dst\G = g
            *dst\B = b
          ;Else
          ;  *dst\R = $FF
          ;  *dst\G = 0
          ;  *dst\B = $FF
          End If
          *dst\A = a
          *dst+4
          *src+4
        Next
      Next
      \alpha_isused = True
    End If

    If *raw Then FreeVec_ *raw
    End If
    FreeDiskObject_ *icon
    succ=True
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_Half{image.l,srcimage.l}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Half the size of an image, doing pixel averaging.                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l       : image object ID to create                                 /
;/ - srcimage.l    : source image object ID                                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_Half{image.l,srcimage.l}
SHARED imagedat()

  succ.l = False
  xs.l   = image_GetWidth{srcimage}
  ys.l   = image_GetHeight{srcimage}
  xsh.l  = (xs)/2 ; was (xs+1)
  ysh.l  = (ys)/2

  If image_Create{image,xsh,ysh}
     succ = True
     ;If xs MOD 2 Then xrow.l = True : xsh-1 : Else xrow = False
     ;If ys MOD 2 Then yrow.l = True : ysh-1 : Else yrow = False
     srcptr.l = imagedat(srcimage)\raw_ptr
     srcbpr.l = imagedat(srcimage)\bpr
     dstptr.l = \raw_ptr
     dstbpr.l = \bpr
     For y.l = 0 To ysh-1
       row1ptr.l = srcptr + (y*2) * srcbpr
       row2ptr.l = row1ptr+ srcbpr
       rowptr.l  = dstptr + y * dstbpr
       For x.l = 0 To xsh-1
         col11.l = (Peek.l (row1ptr) & $FCFCFCFC) LSR 2 : row1ptr+4
         col21.l = (Peek.l (row1ptr) & $FCFCFCFC) LSR 2 : row1ptr+4
         col12.l = (Peek.l (row2ptr) & $FCFCFCFC) LSR 2 : row2ptr+4
         col22.l = (Peek.l (row2ptr) & $FCFCFCFC) LSR 2 : row2ptr+4
         Poke.l rowptr, (col11+col12+col21+col22 ) : rowptr+4
       Next
       ;If xrow Then Poke.l rowptr,Peek.l(row1ptr)
     Next
     ;If yrow
     ;  row1ptr.l = srcptr + (y*2) * srcbpr
     ;  rowptr.l  = dstptr + y * dstbpr
     ;  For x.l = 0 To xsh-1
     ;    col.l = Peek.l (row1ptr) : row1ptr+4
     ;    Poke.l rowptr, col : rowptr+4
     ;  Next
     ;End If
     image_CopyConfig{image,srcimage}
     \handle_x = imagedat(srcimage)\handle_x / 2
     \handle_y = imagedat(srcimage)\handle_y / 2
     ;\alpha_isused = imagedat(srcimage)\alpha_isused
     ;\mask_trgb    = imagedat(srcimage)\mask_trgb
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = image_Cut{image.l,src_image.l,@x.l,@y.l,@xs.l,@ys.l,@t::  /
;/ rgb.l,@tolerance.l}                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ Creates an image object out of (a part of) another image.                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : new image object ID                                          /
;/ - src_image.l: source image object ID                                       /
;/ - x.l,y.l    : optional: position from where to fetch                       /
;/ - xs.l,ys.l  : optional: width and height of the area to fetch              /
;/ - trgb.l     : rgbvalue for the desired transparent color, e.g. $ff0000 f:: /
;/ or red, set it to -1 for no transparency                                    /
;/ - tolerance.l: tolerance for the transparency detection, default is 1       /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : True if everything went well, False if it failed             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_Cut{image.l,src_image.l,@x.l,@y.l,@xs.l,@ys.l,@trgb.l,@tolerance.l}
SHARED imagedat(),imageengine:USEPATH imagedat(image)

  succ.l = False
  If image_IsUsed{src_image}
    If x < 0 Then x = 0
    If y < 0 Then y = 0
    If xs <= 0 Then xs = image_GetWidth{src_image} - x
    If ys <= 0 Then ys = image_GetHeight{src_image} - y
    If xs+x > image_GetWidth{src_image} Then xs = image_GetWidth{src_image} - x
    If ys+y > image_GetHeight{src_image} Then ys = image_GetHeight{src_image} - y
    If xs > 0 AND ys > 0
      If image_Create{image,xs,ys}
        If image_Lock{image}
          If image_Lock{src_image}
            *rp.RastPort = image_GetRPPtr{src_image}
            If *rp >< 0
              ReadPixelArray_ \raw_ptr,0,0,\bpr,*rp,x,y,xs,ys,#RECTFMT_ARGB
            Else
               error{"\\__THIS_FUNCTION: Unable to readpixel from source image!"}
            End If
            image_Unlock{src_image}
          End If
          image_Unlock{image}
        End If

        image_CopyConfig{image,src_image}
        If imagedat(src_image)\mask_isused OR trgb >< -1
          image_InitMask{image,\mask_trgb,\mask_tolerance,\mask_threshold}
        Else
          \mask_trgb = -1
        End If
        If imagedat(src_image)\alpha_isused
          \alpha_isused = True
        End If
        succ = True
      End If
    Else
      error{"\\__THIS_FUNCTION: Invalid dimensions ("+Str$(x)+"/"+Str$(y)+")("+Str$(x+xs-1)+"/"+Str$(y+ys-1)+")!" }
    End If
  Else
    error{"\\__THIS_FUNCTION: Uninitialized source image!"}
  End If
  If succ=False Then image_Free{image}
  Function Return succ
  USELASTPATH
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_LoadViaDT{image.l,filename.s}                     /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_LoadViaDT{image.l,filename.s,imgnum.l}

DEFTYPE.BitMapHeader *bmhdp
DEFTYPE.BitMap *bmap
DEFTYPE.pdtBlitPixelArray DTM

  succ.l = False
  If imgnum < 0 Then imgnum = 0
  tag5.tag5\ti_Tag = #PDTA_DestMode, #PMODE_V43, #DTA_SourceType, #DTST_FILE, #DTA_GroupID, #GID_PICTURE, #PDTA_Remap, False,#PDTA_WhichPicture,imgnum,#TAG_DONE,0
  *DTPic._Object = NewDTObjectA_ (&filename.s,tag5)
  If *DTPic
    tag5.tag5\ti_Tag = #PDTA_BitMapHeader,&*bmhdp,#TAG_DONE,0
    GetDTAttrsA_ *DTPic,tag5
    If image_Create{image,*bmhdp\bmh_Width,*bmhdp\bmh_Height}
      If image_Lock{image}
        ; try to get as ARGB immediately, good datatpyes support this, but not all!
        ; If *bmhdp\bmh_Depth>8 ; dont even try if depth <= 8
          DTM\MethodID            = #PDTM_READPIXELARRAY
          DTM\pbpa_PixelData      = \raw_ptr          ; /* The pixel data to transfer to/from */
          DTM\pbpa_PixelFormat    = #PBPAFMT_ARGB     ; /* Format of the pixel data (see "Pixel Formats" below) */
          DTM\pbpa_PixelArrayMod  = \bpr              ; /* Number of bytes per row */
          DTM\pbpa_Left           = 0                 ; /* Left edge of the rectangle to transfer pixels to/from */
          DTM\pbpa_Top            = 0                 ; /* Top edge of the rectangle to transfer pixels to/from */
          DTM\pbpa_Width          = *bmhdp\bmh_Width  ; /* Width of the rectangle to transfer pixels to/from */
          DTM\pbpa_Height         = *bmhdp\bmh_Height
          If DoMethodA (*DTPic,&DTM) Then succ = True
        ;End If

        ; ok, try to read out the bitmap if ARGB failed...
        If succ = False
          tag5.tag5\ti_Tag = #PDTA_ColorRegisters,&colorMap.l,#TAG_DONE,0
          If GetDTAttrsA_ (*DTPic,tag5)
            tag5.tag5\ti_Tag = #PDTA_BitMap,&*bmap,#TAG_DONE,0
            If GetDTAttrsA_ (*DTPic,tag5)
              *layerinfo.Layer_Info = NewLayerInfo_
              If *layerinfo
                *layer.Layer = CreateUpfrontHookLayer_ (*layerinfo,*bmap,0,0,*bmhdp\bmh_Width-1,*bmhdp\bmh_Height-1,0,#LAYERS_NOBACKFILL,0)
                If *layer
                  *rp.RastPort = *layer\rp
                  If *rp
                    image_Unlock{image}
                    succ = image_CutRP{image,*rp,0,0,*bmhdp\bmh_Width,*bmhdp\bmh_Height,-1,-1,-1,colorMap}
                    If succ Then image_Lock{image}
                  End If
                  DeleteLayer_ 0,*layer
                End If
                DisposeLayerInfo_ *layerinfo
              End If
            End If
          End If
        End If

        ; Try READPIXELARRAY LUT8, if we couldn't catch the bitmap (outch!)
        If succ = False
          penArray8.l = AllocVec_(*bmhdp\bmh_Height * *bmhdp\bmh_Width,#MEMF_ANY)
          lut.l       = AllocVec_(256*4,#MEMF_CLEAR)
          If penArray8 >< 0 AND lut >< 0
            DTM\MethodID            = #PDTM_READPIXELARRAY
            DTM\pbpa_PixelData      = penArray8         ; /* The pixel data to transfer to/from */
            DTM\pbpa_PixelFormat    = #PBPAFMT_LUT8     ; /* Format of the pixel data (see "Pixel Formats" below) */
            DTM\pbpa_PixelArrayMod  = *bmhdp\bmh_Width  ; /* Number of bytes per row */
            DTM\pbpa_Left           = 0                 ; /* Left edge of the rectangle to transfer pixels to/from */
            DTM\pbpa_Top            = 0                 ; /* Top edge of the rectangle to transfer pixels to/from */
            DTM\pbpa_Width          = *bmhdp\bmh_Width  ; /* Width of the rectangle to transfer pixels to/from */
            DTM\pbpa_Height         = *bmhdp\bmh_Height
            If DoMethodA (*DTPic,&DTM)
              tag5.tag5\ti_Tag = #PDTA_ColorRegisters,&colMap.l,#TAG_DONE,0
              If GetDTAttrsA_ (*DTPic,tag5)
                For pen.l = 0 To (1 LSL *bmhdp\bmh_Depth)-1
                  *CReg.ColorRegister = colMap + 3*pen
                  Poke.l lut + (pen LSL 2),((*CReg\red&$00FF) LSL 16) | ((*CReg\green & $00FF) LSL 8) | (*CReg\blue & $FF)
                Next
                For y.l = 0 To *bmhdp\bmh_Height -1
                  For x.l = 0 To *bmhdp\bmh_Width -1
                    pen.l = Peek.b(penArray8+y**bmhdp\bmh_Width+x) & $FF
                    Poke.l \raw_ptr+y*\bpr+(x LSL 2),(Peek.l(lut+(pen LSL 2)) );& $FEFEFEFE) LSR 1
                  Next
                Next
                succ = True
              End If
            End If
            If penArray8 Then FreeVec_ penArray8 : penArray8 = 0
            If lut       Then FreeVec_ lut       : lut       = 0
          End If
        End If
        image_Unlock{image}
      End If
      If succ = False Then image_Free{image}
    End If
    DisposeDTObject_ (*DTPic)
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_LoadViaPNG{image.l,filename.s}                    /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_LoadViaPNG{image.l,filename.s}
SHARED imageengine

  succ.l = False
  If dos_Exist{filename} = False Then Function Return False
  If png_Open{filename.s}
    If png_Read{}
      If image_Create{image,png_GetWidth{},png_GetHeight{}}
        If image_Lock{image}
          png_DecodeARGB{\raw_ptr,\bpr}
          \alpha_isused = True
          image_Unlock{image}
          succ = True
        End If
      End If
    End If
    png_Close{}
  End If
  If succ = False Then image_Free{image}
  Function Return succ
End Function

Function.l image_LoadViaILBM{image.l,filename.s,imgnum.l}
SHARED imageengine

  succ.l = False
  If dos_Exist{filename} = False Then Function Return False
  If ilbm_Open{filename.s}
    If ilbm_ReadLayer{imgnum}
      If image_Create{image,ilbm_GetWidth{},ilbm_GetHeight{}}
        If image_Lock{image}
          ilbm_DecodeLayer{\raw_ptr,\img_width,\img_height,\bpr}
          \alpha_isused = True
          image_Unlock{image}
          succ = True
        End If
      End If
    End If
    ilbm_Close{}
  End If
  If succ = False Then image_Free{image}
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_Read{image.l,fid.l}                               /
;/                                                                             /
;/ Description:                                                                /
;/ Read an image from an already open file.                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - fid.l    : file handle returned by file_open (file.include)               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_Read{image.l,fid.l}

  filepos.l = file_GetSeekPos{fid}
  succ.l    = file_ReadMem{fid,&header.l,4}
  succ      = file_ReadMem{fid,&csize.l,4}
  If succ
  Select header
     Case @"IIMG"
       If csize < 1024*1024*1024 AND csize > 0
         mem.l = tempbuffer_Get{csize+8}
         If file_ReadMem{fid,mem+8,csize}
           Poke.l mem,header
           Poke.l mem+4,csize
           If image_Decode{image,mem,1}
             succ = True
           End If
         End If
       End If

     Case @"DIMG"
       If csize < 1024*1024*1024 AND csize > 0
         mem.l = tempbuffer_Get{csize+8}
         If file_ReadMem{fid,mem+8,csize}
           Poke.l mem,header
           Poke.l mem+4,csize
           If image_Decode{image,mem,1}
             succ = True
           End If
         End If
       End If

     Default
       file_Seek{fid,filepos}
       CNIF #use_jpeg_library
       jph.l = jpeg_Read{fid}
       If jph
         w.l = jpeg_GetWidth{jph}
         h.l = jpeg_GetHeight{jph}
         image_Create{image,w,h}
         *rp.RastPort = image_GetRPPtr{image}
         succ = jpeg_Decode{jph,*rp}
         Else
           ; unknown header !
         file_Seek{fid,filepos}
       End If
       CEND
  End Select
  End If
  Function Return succ
End Function

Function.l image_LoadIcon{image.l,filename.s,imgnum.l}
SHARED version_iconlib.l,version_newiconlib.l

  If version_iconlib = 0 Then version_iconlib = dos_GetLibVersion{"icon.library"}
  If imgnum <= 0 Then state.l = -1 : Else state = 0
  If version_iconlib < 44
    If version_newiconlib = 0 Then version_newiconlib = dos_GetLibVersion{"newicon.library"}
    If version_newiconlib > 0
      Function Return image_LoadNewIcon{image,filename,state}
    End If
  Else
    Function Return image_LoadIconV44{image,filename,state}
  End If
  Function Return False
End Function


NEWTYPE.imgheader
  HEAD.l
  SIZE.l
  FORM.l
End NEWTYPE

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = image_Load{image.l,filename.s,@trgb.l,@tolerance.l,@di::  /
;/ thermode.l,@ditherthreshold.l}                                              /
;/                                                                             /
;/ Description:                                                                /
;/ Loads an image object.                                                      /
;/ All file formats that have a datatype installed are supported.              /
;/ Additionally, ARGB PNG and AB2I files can be loaded directly.               /
;/ It also supports loading alpha masks from png and iff ILBM files, if they:: /
;/  contain any.                                                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - filename.s : Complete dos filename including path                         /
;/ - trgb.l     : rgbvalue for the desired transparent color, e.g. $ff0000 f:: /
;/ or red                                                                      /
;/ - tolerance.l  : tolerance in RGB steps for the transparency                /
;/ - dithermode.l : see #image_dithermode_... for available dithermodes, in :: /
;/ case the image is blittet on color index screens                            /
;/ - ditherthreshold.l    : ???                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : True if everything went well, False if it failed             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_Load{image.l,filename.s,@trgb.l,@tolerance.l,@dithermode.l,@ditherthreshold.l,@imgnum.l}
SHARED imagedat(),imageengine:USEPATH imagedat(image)

  succ.l = False

  ; load icon via newicon.library!
  If succ = False Then If LCase$(Right$(filename.s,5)) = ".info" Then succ = image_LoadIcon{image,filename,imgnum}

  If succ = False
    fid.l = file_Open{filename,#file_read}
    If fid >= 0
      file_ReadMem{fid,imgheader.imgheader,SizeOf.imgheader}
      file_Close{fid}
    Else
      imgheader\HEAD = @"UNKN"
    End If

    ; try if we can load an alpha-channel 24bit png
    If succ = False
      If imgheader\HEAD = $89504E47 OR LCase$(Right$(filename,4)) = ".png"
        succ = image_LoadViaPNG{image,filename.s}
      End If
    End If
  End If

  If succ = False AND imgnum >= 0 Then succ = image_LoadViaILBM{image,filename,imgnum}

  ; try to load via datatypes
  If succ = False Then succ = image_LoadViaDT{image,filename,imgnum}

  If succ
    \filename = filename.s
    If ditherthreshold >= 0 Then \dither_threshold = ditherthreshold : Else \dither_threshold = 0
    If dithermode >= 0
      \dither_mode = dithermode
    Else
      If \img_width > 64 AND \img_height > 64 Then \dither_mode = #image_dithermode_default : Else \dither_mode = #image_dithermode_noneshift
    End If
    \is_solid = 1
    If trgb = -1 ; no transparecy color, so check for alpha channel
      ; check for IFF built-in mask (ALPH chunk as used in ArtEffect3/4)
      If \alpha_isused = False
        If ilbm_Open{filename.s}
          If ilbm_ReadAlpha{}
            alpha_bytesize.l = \img_width*\img_height*1
            alpha_ptr.l      = AllocVec_(alpha_bytesize,#MEMF_ANY)
            If alpha_ptr
              ilbm_DecodeAlpha{alpha_ptr,\img_width,\img_height}
              image_AttachAlpha{image,alpha_ptr}
              FreeVec_ alpha_ptr
            End If
          End If
          ilbm_Close{}
        End If
      End If

  CNIF #use_maskfile
      ; check for external .msk File
      If \alpha_isused = False
        alphafilename.s = ""
        If dos_Exist{dos_SetExt{filename.s,".msk"}}
          If image_IsPictureDT{dos_SetExt{filename.s,".msk"}} Then alphafilename.s = dos_SetExt{filename.s,".msk"}
        End If

        ; check if there is a mask image
        If alphafilename.s >< ""
          aimage.l = image_GetFree{}
          If aimage >= 0
            image_Load{aimage,alphafilename.s}
            image_CreateAlpha{image,$000000,-1,aimage,-1}
            image_Free{aimage}
          End If
        End If
      End If
  CEND
    End If

    Else
      ; try to load image(s) via internal format
      fid.l = file_Open{filename.s,#file_read}
      If fid >= 0
        blength.l   = file_GetLength{fid}
        membuffer.l = AllocVec_(blength,0)
      If membuffer
        If file_ReadMem{fid,membuffer,blength}
          succ = image_Decode{image,membuffer}
        Else
          error{"\\__THIS_FUNCTION: Unable to read data from file!"}
        End If
        FreeVec_ membuffer
      Else
        error{"\\__THIS_FUNCTION: Not enough memory for file buffer!"}
      End If
      file_Close{fid}
    Else
      error{"\\__THIS_FUNCTION: Unable to read image file \\22"+filename.s+"\\22!"}
    End If
  End If

  If succ = False ; we couldnt load the image
    image_Free{image}
  Else
    If imageengine\devisor > 1
      ;error{"loaddevisor!"+Str$(imageengine\devisor)}
      img2.l = image_GetFree{}
      ;If imageengine\devisor = 2
      ;  image_Half{img2,image}
      ;Else
        ;img_width = .l /imageengine\devisor
        ;img_height.l/imageengine\devisor
        image_Resize{img2,image,\img_width/imageengine\devisor,\img_height/imageengine\devisor}
      ;End If
      image_Cut{image,img2}
      \filename = filename
      image_Free{img2}
    End If

    ; create a bit mask out of the trgb color
    If trgb >< -1 AND \alpha_isused = False
      If tolerance = -1 Then tolerance = 9 ; set the default tolerance
      threshold.l = -1
      image_InitMask{image,trgb,tolerance,threshold}
    Else
      \mask_trgb = -1
    End If
  End If
  Function Return succ
  USELASTPATH
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_SetFileName{image.l,filename.s}                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_SetFileName{image.l,filename.s}
SHARED imagedat()

  \filename = filename
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_WriteMask{image.l,fid.l,@compress.l}              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - fid.l      : ???                                                          /
;/ - compress.l : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l   : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_WriteMask{image.l,fid.l,@compress.l}

  If \mask_ptr=#NULL Then Function Return False
  succ.l = False
  If compress
    If file_WriteChunk{fid,@"CMSK"}   ; Save compressed mask
      succ        = file_WriteLong{fid,\mask_bpr}
      written.l   = 0
      If compress < 0 OR compress > 9 Then compress = 9
      rowlength.l = \mask_bpr
      totalmem.l  = rowlength * \img_height
      temp_size.l = zlib_CompressBound{totalmem}
      temp.l      = AllocVec_(temp_size,#MEMF_ANY)
      If temp
        written     = temp_size
        zlib_Compress{temp,&written,\mask_ptr,totalmem,compress}
        succ & file_WriteLong{fid,written}
        succ & file_WriteMem{fid,temp,written}
        succ & file_CloseChunk{fid,@"CMSK"}
        FreeVec_ temp
      Else
        succ = False
      End If
    EndIf
    Function Return succ
  End If
  If file_WriteChunk{fid,@"MASK"}   ; Save Raw Data
    succ        = file_WriteLong{fid,\mask_bpr}
    rowlength.l = \mask_bpr
    totalmem.l  = rowlength * \img_height
    succ & file_WriteLong{fid,totalmem}
    succ & file_WriteMem{fid,\mask_ptr,totalmem}
    succ & file_CloseChunk{fid,@"MASK"}
  EndIf
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_WriteDT{image.l,filename.s}                       /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/ Write a picture as 24Bit IFF-ILBM via datatypes.                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l     : image object ID                                             /
;/ - fid.l       : file object ID                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l    : -1 if everything went well, 0 otherwise                     /
;/                                                                             /
;/ Bugs: does not work on AfA4.2 and lower                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_WriteDT{fid.l,image.l}
SHARED imagedat()
DEFTYPE.dtWrite DTMW
DEFTYPE.pdtBlitPixelArray DTMB

  succ.l = False
  If \ARGBbitmap_ptr
    *newbm.BitMap = AllocBitMap_(\img_width,\img_height,24,#BMF_MINPLANES|#BMF_SPECIALFMT|(#PIXFMT_RGB24 LSL #BMB_PIXFMT_SHIFTUP) ,0)
    If *newbm = 0 Then error{"\\__THIS_FUNCTION: Unable to allocate 24bit Bitmap!"} : Function Return False

    DEFTYPE.RastPort rp
    InitRastPort_ rp
    rp\BitMap = *newbm
    ClipBlit_ \rastport_ptr,0,0,rp,0,0,\img_width,\img_height,$c0

    basename.s = "iff"          ;          #DTA_BaseName    ,&basename,@@
    tag5.tag5\ti_Tag  = #DTA_SourceType,#DTST_RAM,#DTA_GroupID,#GID_PICTURE,#PDTA_DestMode,#PMODE_V43,#PDTA_BitMap,*newbm,#TAG_DONE,0
    *DTPic._Object    = NewDTObjectA_ (0,tag5)
    If *DTPic
      tag5.tag5\ti_Tag = #PDTA_BitMapHeader,&*bmhd.BitMapHeader,#TAG_DONE,0
      GetDTAttrsA_ *DTPic,tag5
      If *bmhd
        *bmhd\bmh_Width      = \img_width
        *bmhd\bmh_Height     = \img_height
        *bmhd\bmh_Depth      = 24
        *bmhd\bmh_XAspect    = 22
        *bmhd\bmh_YAspect    = 22
        *bmhd\bmh_PageWidth  = 1600
        If (*bmhd\bmh_Width <= 1280) Then *bmhd\bmh_PageWidth = 1280
        If (*bmhd\bmh_Width <= 1024) Then *bmhd\bmh_PageWidth = 1024
        If (*bmhd\bmh_Width <= 800) Then *bmhd\bmh_PageWidth = 800
        If (*bmhd\bmh_Width <= 640) Then *bmhd\bmh_PageWidth = 640
        If (*bmhd\bmh_Width <= 320) Then *bmhd\bmh_PageWidth = 320
        *bmhd\bmh_PageHeight = *bmhd\bmh_PageWidth * 3 / 4
      Else
         error{"\\__THIS_FUNCTION: Unable to get bitmap header!"}
      End If

      ;fh.l = Open_ (&filename.s,#MODE_NEWFILE)
      fh.l = file_GetFH{fid}
      If fh
        DTMW\MethodID            = #DTM_WRITE
        DTMW\dtw_GInfo           = 0
        DTMW\dtw_FileHandle      = fh
        DTMW\dtw_Mode            = #DTWM_IFF
        DTMW\dtw_AttrList        = 0
        succ = DoDTMethodA_(*DTPic,0,0,DTMW)
        ;succ = DoMethodA(*DTPic,DTMW)
       ; Close_ fh
        If succ = False
          error{"\\__THIS_FUNCTION: Unable to write image via "+basename+" datatype!"}
        EndIf
      EndIf

      DisposeDTObject_ *DTPic
    Else
      error{"\\__THIS_FUNCTION: Unable to create datatype object out of the bitmap!"}
      FreeBitMap_ *newbm
    EndIf
  Else
    error{"\\__THIS_FUNCTION: No bitmap!"}
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = image_Write{image.l,fid.l,@form.l,@compress.l,@flags.l}   /
;/                                                                             /
;/ Description:                                                                /
;/ Writes the image in various file formats into an already open file.         /
;/ The file must be opened via file.include.                                   /
;/                                                                             /
;/ NOTE: Use this function if you want To store an image embedded in your ow:: /
;/ n file format, use image_Save if you just want to save a picture !          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - fid.l      : fid handle obtained by file_Open{}                           /
;/ - compress.l : -1 = default compression, 0 = no compression, 1...9 zlib c:: /
;/ ompression 1 = fast / 9 = best                                              /
;/ - form.l     : must be one of                                               /
;/ @"ILBM" - 24bit iff-ilbm image                                              /
;/ @"BMP"  - 24bit bmp (Microsoft Bitmap) image                                /
;/ @"IIMG" - internal image format, can only be loaded by image.include        /
;/ - flags.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : True if everything went well, False if it failed             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_Write{image.l,fid.l,@form.l,@compress.l,@flags.l}
SHARED imagedat(),imageengine,imgargs():USEPATH imagedat(image)

  succ.l = False
  If flags.l = -1 Then flags = 0
  If fid >= 0 AND image >= 0
    If image_Lock{image}
      Select form
        Case @"IFFD"
          succ = image_WriteDT{fid,image}

        Case @"ILBM"
          succ = ilbm_WriteHeader{fid}
          If \alpha_isused Then alphamode.l = #IFFILBM_RGB_ALPHA : Else alphamode = #IFFILBM_RGB
          succ & ilbm_WriteARGBBitMap{fid,\raw_ptr,\img_width,\img_height,\bpr,compress,alphamode}
          succ & ilbm_WriteGrabChunk{fid,\handle_x,\handle_y}
          succ & ilbm_FixUp{fid}

        Case @"BMP5"
          If \alpha_isused
            ; V5
            succ = bmp_WriteARGBBitMap32{fid,\raw_ptr,\img_width,\img_height,\bpr}
          Else
            succ = bmp_WriteARGBBitMap24{fid,\raw_ptr,\img_width,\img_height,\bpr}
          End If

        Case @"BMP"
          If \alpha_isused
            ; V3
            succ = bmp_WriteARGBBitMap24{fid,\raw_ptr,\img_width,\img_height,\bpr}
          Else
            succ = bmp_WriteARGBBitMap24{fid,\raw_ptr,\img_width,\img_height,\bpr}
          End If
        Case @"PNG"
          succ = png_Write{fid,\raw_ptr,\img_width,\img_height,\bpr,compress,\alpha_isused,-1}

        Case @"JPEG"
  CNIF #use_jpeg_library
          smoothing.l  = 0
          If flags&#image_sf_smoothing Then smoothing = 25
          If flags&#image_sf_moresmoothing Then smoothing + 75
          If flags&#image_sf_progressive Then noprogressive.l = False : Else noprogressive = True
          If compress < 0 Then compress = 15
          quality.l    = Min(100-compress,100)
          *rp.RastPort = image_GetRPPtr{image}
          succ         = jpeg_Write{fid,*rp,\img_width,\img_height,quality,smoothing,noprogressive}
  CELSE
          error{"\\__THIS_FUNCTION: Compile with #use_jpeg_library to support jpeg export!"}
  CEND
        Case @"DIMG" ; fast delta image
          If file_WriteChunk{fid,@"DIMG"}
            succ = True
            If flags&#image_sf_lossy Then gmask.l = $FF-3 : cmask.l = $FF-7 : Else gmask = $FF : cmask = $FF
            If file_WriteChunk{fid,@"GEOM"}   ; Save Picture geometrics
              file_WriteTag{fid,@"IMGW",\img_width}
              file_WriteTag{fid,@"IMGH",\img_height}
              If \handle_x >< 0 Then file_WriteTag{fid,@"HNDX",\handle_x}
              If \handle_y >< 0 Then file_WriteTag{fid,@"HNDY",\handle_y}

              If \dither_mode><#image_dithermode_none
                file_WriteTag{fid,@"DTHM",\dither_mode}
                file_WriteTag{fid,@"DTHT",\dither_threshold}
              End If
              If \clip_x >< 0 Then file_WriteTag{fid,@"BCXX",\clip_x}
              If \clip_xs >< \img_width Then file_WriteTag{fid,@"BCXS",\clip_xs}
              If \clip_y >< 0 Then file_WriteTag{fid,@"BCYY",\clip_y}
              If \clip_ys >< \img_height Then file_WriteTag{fid,@"BCYS",\clip_ys}

              If \mask_isused
                file_WriteTag{fid,@"MASK",\mask_isused}
                file_WriteTag{fid,@"TRGB",\mask_trgb}
                file_WriteTag{fid,@"MTOL",\mask_tolerance}
                file_WriteTag{fid,@"MTHR",\mask_threshold}
              End If
              If flags&#image_sf_YUV Then doYUV.l = True : Else doYUV = False
              If \alpha_isused Then doRGB.l = False : file_WriteTag{fid,@"ALPH",\alpha_isused} : Else doRGB = True
              formpos.l = file_GetSeekPos{fid}
              file_WriteTag{fid,@"PFMT",@"ARGB"}
              If \filename >< "" Then file_WriteTagString{fid,@"FIL$",\filename}
              succ & file_CloseChunk{fid,@"GEOM"}
            End If

            ; prepare image for compression
            If doRGB
              imgmemsize.l = \img_width*\img_height*3
              temp.l       = AllocVec_(imgmemsize,#MEMF_ANY)
              If temp
                *rp.RastPort = image_GetRPPtr{image}
                ReadPixelArray_ temp,0,0,\img_width*3,*rp,0,0,\img_width,\img_height,#RECTFMT_RGB
                If flags&#image_sf_YUV Then _image_RGB2YUV24{temp,\img_width*3,\img_width,\img_height,gmask,cmask}
              End If
            Else
              imgmemsize.l = \img_width*\img_height*4
              temp.l       = AllocVec_(imgmemsize,#MEMF_ANY)
              If temp
                *rp.RastPort = image_GetRPPtr{image}
                ReadPixelArray_ temp,0,0,\img_width*4,*rp,0,0,\img_width,\img_height,#RECTFMT_ARGB
                If flags&#image_sf_YUV Then _image_RGB2YUV32{temp,\img_width*4,\img_width,\img_height,gmask,cmask}
              End If
            End If

            If temp
              If compress
                If file_WriteChunk{fid,@"CDAT"}   ; Save Raw Data 32bit
                  written.l   = 0
                  tempCSize.l = zlib_CompressBound{imgmemsize}
                  tempC.l     = AllocVec_(tempCSize,#MEMF_ANY)
                  If tempC
                    If compress < 0 OR compress > 9 Then compress = 9 : If (flags&#image_sf_fast) Then compress = 1
                    written = tempCSize
                    status.l = zlib_Compress{tempC,&written,temp,imgmemsize,compress}
                    If status = #Z_OK
                     If (flags&#image_sf_fast) = 0
                      If doRGB
                        _image_FilterDelta24{temp,\img_width*3,temp,\img_width*3,\img_width,\img_height}
                      Else
                        _image_FilterDelta32{temp,\img_width*4,temp,\img_width*4,\img_width,\img_height}
                      End If
                      writtenD.l = tempCSize-written
                      status.l = zlib_Compress{tempC+written,&writtenD,temp,imgmemsize,compress}
                      If status >< #Z_OK Then writtenD = -1
                     Else
                      writtenD = -1
                     End If
                     If written <= writtenD OR writtenD <= 0
                      dataSize.l = written
                      dataPtr.l  = tempC
                      doDelta.l  = False
                     Else
                      dataSize = writtenD
                      dataPtr  = tempC+written
                      doDelta  = True
                     End If

                     PFMT.l = @"????"
                     If doRGB
                      If doYUV
                        If doDelta Then PFMT = @"0yuv" : Else PFMT = @"0YUV"
                      Else
                        If doDelta Then PFMT = @"0rgb" : Else PFMT = @"0RGB"
                      End If
                     Else
                      If doYUV
                        If doDelta Then PFMT = @"ayuv" : Else PFMT = @"AYUV"
                      Else
                        If doDelta Then PFMT = @"argb" : Else PFMT = @"ARGB"
                      End If
                     End If

                     datapos.l = file_GetSeekPos{fid}
                     file_Seek{fid,formpos}
                     file_WriteTag{fid,@"PFMT",PFMT}
                     file_Seek{fid,datapos}
                     succ & file_WriteLong{fid,dataSize}
                     succ & file_WriteMem{fid,dataPtr,dataSize}
                    Else
                      succ = False
                    End If
                  End If
                  succ & file_CloseChunk{fid,@"CDAT"}
                  If tempC Then FreeVec_ tempC : tempC = 0
                End If
              Else
                PFMT.l = @"????"
                If doRGB
                  If doYUV
                    PFMT = @"0YUV"
                  Else
                    PFMT = @"0RGB"
                  End If
                Else
                  If doYUV
                    PFMT = @"AYUV"
                  Else
                    PFMT = @"ARGB"
                  End If
                End If

                datapos.l = file_GetSeekPos{fid}
                file_Seek{fid,formpos}
                file_WriteTag{fid,@"PFMT",PFMT}
                file_Seek{fid,datapos}
                If file_WriteChunk{fid,@"DATA"}   ; Save Raw Data 32bit
                  succ & file_WriteMem{fid,temp,imgmemsize}
                  succ & file_CloseChunk{fid,@"DATA"}
                End If
              End If
              If temp  Then FreeVec_ temp : temp = 0
            End If
            image_WriteMask{image,fid,compress}
            succ&file_CloseChunk{fid,@"DIMG"}
          End If

        Case @"IIMG" ; internal image
          If file_WriteChunk{fid,@"IIMG"}
            succ = True
            If file_WriteChunk{fid,@"GEOM"}   ; Save Picture geometrics
              file_WriteTag{fid,@"IMGW",\img_width}
              file_WriteTag{fid,@"IMGH",\img_height}
              file_WriteTag{fid,@"HNDX",\handle_x}
              file_WriteTag{fid,@"HNDY",\handle_y}
              file_WriteTag{fid,@"ALPH",\alpha_isused}
              file_WriteTag{fid,@"MASK",\mask_isused}
              file_WriteTag{fid,@"TRGB",\mask_trgb}
              file_WriteTag{fid,@"MTOL",\mask_tolerance}
              file_WriteTag{fid,@"MTHR",\mask_threshold}
              file_WriteTag{fid,@"DTHM",\dither_mode}
              file_WriteTag{fid,@"DTHT",\dither_threshold}
              file_WriteTag{fid,@"BCXX",\clip_x}
              file_WriteTag{fid,@"BCXS",\clip_xs}
              file_WriteTag{fid,@"BCYY",\clip_y}
              file_WriteTag{fid,@"BCYS",\clip_ys}
              If \filename >< "" Then file_WriteTagString{fid,@"FIL$",\filename}
              succ & file_CloseChunk{fid,@"GEOM"}
            End If
            If compress
              If file_WriteChunk{fid,@"CDAT"}   ; Save Raw Data 32bit
                written.l = 0
                If compress < 0 OR compress > 9 Then compress = 6
                rowlength.l = \img_width*4
                temp_size.l = zlib_CompressBound{rowlength}
                temp.l      = AllocVec_(temp_size,#MEMF_ANY)
                For y.l = 0 To \img_height-1
                  ptr.l   = \raw_ptr + y*\bpr
                  written = temp_size
                  status.l = zlib_Compress{temp,&written,ptr,rowlength,compress}
                  If status = #Z_OK
                    succ & file_WriteLong{fid,written}
                    succ & file_WriteMem{fid,temp,written}
                  End If
                Next
                succ & file_CloseChunk{fid,@"CDAT"}
                FreeVec_ temp
              End If
            Else
              If file_WriteChunk{fid,@"DATA"}   ; Save Raw Data 32bit
                rowlength.l = \img_width*4
                For y.l = 0 To \img_height-1
                  ptr.l = \raw_ptr + y*\bpr
                  succ & file_WriteMem{fid,ptr,rowlength}
                Next
                succ & file_CloseChunk{fid,@"DATA"}
              End If
            End If
            succ&file_CloseChunk{fid,@"IIMG"}
          End If

        Default
          error{"\\__THIS_FUNCTION: Unsupported file format "+Mkl$(form)+"!"}
      End Select
    Else
     error{"\\__THIS_FUNCTION: Uninitialized image!"}
    End If
  Else
   error{"\\__THIS_FUNCTION: Invalid image/file!"}
  End If
  USELASTPATH
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = image_Save{image.l,filename.s,@form.l,@compress.l,@fla::  /
;/ gs.l,@image2.l}                                                             /
;/                                                                             /
;/ Description:                                                                /
;/ Writes the image in various file formats into an already open file.         /
;/ The file must be opened via file.include,                                   /
;/ NOTE: Use this function if you want To store an image embedded in your ow:: /
;/ n file format, use image_save if you just                                   /
;/ want to save a picture !                                                    /
;/ You can also save a bunch of images like e.g. an animation sequence, if y:: /
;/ ou use AB2I.                                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - filename.s : filename for the image(s)                                    /
;/ - form.l     : must be one of                                               /
;/ @"ILBM" - 24bit iff-ilbm image                                              /
;/ @"PNG" - 24bit png image                                                    /
;/ @"JPEG" - 24bit jpeg image                                                  /
;/ @"AB2I" - AB2 image file format                                             /
;/ - compress.l : -1 = default compression, 0 = no compression, 1...9 zlib c:: /
;/ ompression level, 1 = fast / 9 = best                                       /
;/ - image2.l   : if not -1, all images between image and image2 will be sav:: /
;/ ed into this file, works only with form = @"AB2I"                           /
;/ - flags.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : True if everything went well, False if it failed             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_Save{image.l,filename.s,@form.l,@compress.l,@flags.l,@image2.l}
SHARED imagedat(),imageengine,imgargs()

  USEPATH imagedat(image)
  fid.l  = file_Open{filename.s,#file_forcewrite}
  succ.l = False
  If fid >= 0
    Select form
      Case @"AB2I"
        If file_WriteChunk{fid,@"AB2I",-1}
          If image2 = -1 Then image2 = image
          For image.l = image To image2
            If image_IsUsed{image}
              succ.l = image_Write{image,fid,@"IIMG",compress,flags}
              If succ = False Then image = image2
            Else
              ; write only a placeholder !
              file_WriteChunk{fid,@"FIMG",-1}
              file_CloseChunk{fid,@"FIMG"}
            End If
          Next
          succ&file_CloseChunk{fid,@"AB2I"}
        End If

      Case @"AB3I"
        If file_WriteChunk{fid,@"AB3I",-1}
          If image2 = -1 Then image2 = image
          For image.l = image To image2
            If image_IsUsed{image}
              succ.l = image_Write{image,fid,@"DIMG",compress,flags}
              If succ = False Then image = image2
            Else
              ; write only a placeholder !
              file_WriteChunk{fid,@"FIMG",-1}
              file_CloseChunk{fid,@"FIMG"}
            End If
          Next
          succ&file_CloseChunk{fid,@"AB3I"}
        End If

      Default
        If image2 >= 0
          error{"\\__THIS_FUNCTION: Saving more than one image is only possible for \\22AB2I\\22 or \\22AB3I\\22 file format!"}
        Else
          succ = image_Write{image,fid,form,compress,flags}
        End If
    End Select
    file_Close{fid}
    If succ = False Then DeleteFile_ &filename
  End If
  USELASTPATH
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_BlitArea{image.l,x.l,y.l,xs.l,ys.l,sourcex.l,sourcey.l,@rp::  /
;/ .l,@usemaskifpresent.l}                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Blits a certain area of an image to the used window or the given rastport:: /
;/ , opaque or bit mask transparent.                                           /
;/ This function uses BltBitMapRastPort() or BltMaskBitMapRastPort(), depend:: /
;/ ing if the image has a transparency bitmask or not.                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l  : Number of the source image "Object"                            /
;/ - x.l      : Destination x position                                         /
;/ - y.l      : Destination y position                                         /
;/ - xs.l     : Width of the clipped area                                      /
;/ - ys.l     : Height of the clipped area                                     /
;/ - sourcex.l: Source x position                                              /
;/ - sourcey.l: Source y position                                              /
;/ - *rp.RastPort : optional a rastport where to blit, otherwise it is blitted /
;/ to the used window                                                           /
;/ - usemaskifpresent.l    : if set to 0, this forces to blit opaque, even i:: /
;/ f the image has a bit mask                                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_BlitArea{image.l,x.l,y.l,xs.l,ys.l,sourcex.l,sourcey.l,@*rp.RastPort,@usemaskifpresent.l}
SHARED imagedat()

  USEPATH imagedat(image)
  If \bitmap_ptr = False Then image_InitBitMap{image}
  If *rp = -1 AND Used Window >= 0 Then *rp = RastPort(Used Window)
    If sourcex < 0 Then x-sourcex : xs+sourcex : sourcex = 0
    If sourcey < 0 Then y-sourcey : ys+sourcey : sourcey = 0
    If xs >= \img_width -sourcex Then xs = \img_width -sourcex
    If ys >= \img_height-sourcey Then ys = \img_height-sourcey
    If xs > 0 AND ys > 0
    If \bitmap_ptr >< False AND *rp >< 0 AND *rp >< -1
      If \mask_ptr AND usemaskifpresent
        BltMaskBitMapRastPort_ \bitmap_ptr,sourcex,sourcey,*rp,x-\handle_x,y-\handle_y,xs,ys,$c0,\mask_ptr
      Else
        BltBitMapRastPort_     \bitmap_ptr,sourcex,sourcey,*rp,x-\handle_x,y-\handle_y,xs,ys,$c0
      End If
    Else
      If \bitmap_ptr
        error{"\\__THIS_FUNCTION: Uninitialized window/screen!"}
      Else
        error{"\\__THIS_FUNCTION: Uninitialized image bitmap!"}
      End If
    End If
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_BlitPattern{image.l,x.l,y.l,xs.l,ys.l,@xoffset.l,@yoffset.::  /
;/ l,@rp.l,@usemaskifpresent.l}                                                /
;/                                                                             /
;/ Description:                                                                /
;/ Blits an area of an image using BltBitMapRastPort() or BltMaskBitMapRastP:: /
;/ ort(), depending if a bitmask for transparency is present.                  /
;/ If the image bounds are exceeded, the image will wrap like a pattern.       /
;/ It is also safe to specify negative values for xoffset/yoffset.             /
;/ NOTE: if the image has a mask present, it will be blitted with mask, unle:: /
;/ ss you specify usemaskifpresent=0.                                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l  : Number of the source image "Object"                            /
;/ - x.l    : position                                                         /
;/ - y.l    :                                                                  /
;/ - xs.l    : size of the are to fill with the pattern                        /
;/ - ys.l    :                                                                 /
;/ - xoffset.l: x offset within the pattern                                    /
;/ - yoffset.l: y offset within the pattern                                    /
;/ - *rp.RastPort: optional a ratport where to blit, otherwise it is blitted ::/
;/ to the used window                                                          /
;/ - usemaskifpresent.l    : if set to 0, the image is always blitted opaque.  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_BlitPattern{image.l,x.l,y.l,xs.l,ys.l,@xoffset.l,@yoffset.l,@*rp.RastPort,@usemaskifpresent.l}
SHARED imagedat()

  USEPATH imagedat(image)
  If \bitmap_ptr = False Then image_InitBitMap{image}
  If *rp = -1 AND Used Window >= 0 Then *rp = RastPort(Used Window)
  If \bitmap_ptr >< False AND *rp >< 0 AND *rp >< -1
    x2.l = x+xs
    y2.l = y+ys
    dx.l  = x
    px.l  = (x - xoffset) MOD \img_width
    pxs.l = \img_width-px

    While dx < x2
      If dx+pxs > x2 Then pxs = x2-dx
      dy.l  = y
      py.l  = (y - yoffset) MOD \img_height
      pys.l = \img_height-py
      While dy < y2
        If dy+pys > y2 Then pys = y2-dy
        If \mask_ptr >< 0 AND usemaskifpresent >< False
          BltMaskBitMapRastPort_ \bitmap_ptr,px,py,*rp,dx,dy,pxs,pys,$c0,\mask_ptr
        Else
          BltBitMapRastPort_     \bitmap_ptr,px,py,*rp,dx,dy,pxs,pys,$c0
        End If
        dy+pys
        pys = \img_height
        py  = 0
      Wend
      dx+pxs
      pxs = \img_width
      px  = 0
    Wend
  Else
    error{"\\__THIS_FUNCTION: Uninitialized image/window/screen!"}
  End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_SetDitherMode{image.l,dithermode.l}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Defines the dithermode.                                                     /
;/ NOTE: this has only effect on 8bit or lower screens                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l       : image object ID                                           /
;/ - dithermode.l  : ???                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST image_SetDitherMode{image.l,dithermode.l}
SHARED imagedat()

  USEPATH imagedat(image)
  If \dither_mode >< dithermode
    \dither_mode = dithermode
    If \bitmap_ptr Then FreeBitMap_ \bitmap_ptr : \bitmap_ptr = False
  End If
  USELASTPATH
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_SetHandle{image.l,x.l,y.l}                                    /
;/                                                                             /
;/ Description:                                                                /
;/ Defines the handle of the image. Default is the left-top edge.              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l       : image object ID                                           /
;/ - x.l           : x-handle                                                  /
;/ - y.l           : y-handle                                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST image_SetHandle{image.l,x.l,y.l}
SHARED imagedat()

  USEPATH imagedat(image)
  \handle_x = x
  \handle_y = y
  USELASTPATH
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  image_GetHandleX{image.l}                              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_GetHandleX{image.l}
SHARED imagedat()

  USEPATH imagedat(image)
  Function Return \handle_x
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  image_GetHandleY{image.l}                              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_GetHandleY{image.l}
SHARED imagedat()

  USEPATH imagedat(image)
  Function Return \handle_y
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_MidHandle{image.l}                                            /
;/                                                                             /
;/ Description:                                                                /
;/ Defines the handle of the image as the middle.                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l       : image object ID                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST image_MidHandle{image.l}
SHARED imagedat()

  USEPATH imagedat(image)
  \handle_x = \clip_x + \clip_xs/2
  \handle_y = \clip_y + \clip_ys/2
  USELASTPATH
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_FootHandle{image.l}                                           /
;/                                                                             /
;/ Description:                                                                /
;/ Defines the handle of the image as the middle horizontal and the bottom v:: /
;/ ertical.                                                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l       : image object ID                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST image_FootHandle{image.l}
SHARED imagedat()

  USEPATH imagedat(image)
  \handle_x = \clip_x + \clip_xs/2
  \handle_y = \clip_y + \clip_ys-1
  USELASTPATH
End Statement

CNIF #use_shapeslib
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_MakeBlockCookie{bshape.l}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Creates a cookie for the given shape that is fully opaque.                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - bshape.l    : object ID of the target blitz2 shape object                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_MakeBlockCookie{bshape.l}

  cookie.l = Peek.l(Addr Shape(bshape) + 18)
  xsize.l  = Peek.w(Addr Shape(bshape) +  0) - 1
  ysize.l  = Peek.w(Addr Shape(bshape) +  2) - 1
  xrand.l  = xsize MOD 16
  pot.l    = 32768
  xpokes.l = xsize / 16
  For n.l = 0 To xrand
    mask.w + pot
    pot / 2
  Next
  For y.l = 0 To ysize
    x.l = 0
    xcounter.l = xpokes
    While xcounter > 0
      Poke.w cookie,$FFFF
      cookie + 2
      xcounter-1
    Wend
    Poke.w cookie,mask
    cookie + 2
  Next
End Statement
CEND

CNIF #use_shapeslib
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_MakeCookie{image.l,bshape.l,trgb.l}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Creates a cookie for the given blitzshape with trgb as transparent color.   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l         : Number if the image object                              /
;/ - bshape.l        : Number of the shape object                              /
;/ - trgb.l          : Transparent color value, e.g. $00ff00 for green         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////

NEWTYPE.shapeint       ;size=32
  _pixwidth.w         ;00: pixel width of shape null=noshape
  _pixheight.w        ;02: pixel height of shape
  _depth.w            ;04: depth, in bitplanes, of shape
  _ebwidth.w          ;06: even byte width of shape
  _bltsize.w          ;08: BLTSIZE of shape
  _xhandle.w          ;10: horizontal handle of shape
  _yhandle.w          ;12: vertical handle of shape
  _data.l             ;14: pointer to graphic data - Plane1, Plane2...
  _cookie.l           ;18: pointer to one bitplane cookiecut
  _onebpmem.w         ;22: memory taken by one bitplane of shape
  _onebpmemx.w        ;24: memory taken by one bitplane of shape,
                      ;    plus an extra word per bitplane per
                      ;    vertical pixel
  _allbpmem.w         ;26: memory taken by entire shape.
  _allbpmemx.w        ;28: memory taken by entire shape, plus an
                      ;    extra word per bitplane per vertical
                      ;    pixel
  _pad.b[2]           ;30:
End NEWTYPE

Statement image_MakeCookie{image.l,bshape.l,trgb.l}
SHARED imagedat(),imgargs()

  USEPATH imagedat(image)
  cookie.l = Peek.l(Addr Shape(bshape) + 18)
  xsize.l  = Peek.w(Addr Shape(bshape) +  0)
  ysize.l  = Peek.w(Addr Shape(bshape) +  2)
  If cookie >< False
    If xsize = \img_width AND ysize = \img_height
      If trgb >< \mask_trgb Then image_InitMask{image,trgb,1}
      If \mask_ptr
        CopyMem_ \mask_ptr,cookie,\mask_bytesize
      End If
    Else
      error{"\\__THIS_FUNCTION: Unable to make cookie: different dimensions of image ("+Str$(\img_width)+"/"+Str$(\img_height)+")and bshape("+Str$(xsize)+"/"+Str$(ysize)+")!"}
      image_MakeBlockCookie{bshape}
    End If
  Else
    error{"\\__THIS_FUNCTION: Uninitialized image/cookie!"}
  End If
End Statement

Statement image_ShapeCookie2Alpha{image.l,bshape.l}
SHARED imagedat(),imgargs()

  USEPATH imagedat(image)
  *bs.shapeint = Addr Shape(bshape)
  If *bs\_cookie
    If *bs\_pixwidth = \img_width AND *bs\_pixheight = \img_height

      bytewidth.l = *bs\_ebwidth
      wordwidth.l = bytewidth/2

      For y.l = 0 To \img_height-1
        aptr.l = \raw_ptr + \bpr * y
        cptr.l = *bs\_cookie + bytewidth * y
        For w.l = 0 To wordwidth-1
          bit.l  = 1 LSL 15
          w4.l   = w LSL 4
          maxw.l = Min(w4+16,\img_width)
          For x.l = w4 To maxw -1
            A.l = Peek.w(cptr) & bit
            If A Then A = 255 : Else A = 0
            argb.l = Peek.l(aptr)
            argb   = argb & $00FFFFFF | (A LSL 24)
            Poke.l aptr,argb
            bit LSR 1
            aptr + \bpp
          Next
          cptr+SizeOf.w
        Next
      Next
      \alpha_isused = True
    Else
      error{"\\__THIS_FUNCTION: Unable to make cookie: different dimensions of image ("+Str$(\img_width)+"/"+Str$(\img_height)+")and bshape("+Str$(*bs\_pixwidth)+"/"+Str$(*bs\_pixheight)+")!"}
    End If
  Else
    error{"\\__THIS_FUNCTION: Uninitialized image/cookie!"}
  End If
End Statement

CEND

CNIF #use_shapeslib
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_2Shape{image.l,bshape.l,@trgb.l}                  /
;/                                                                             /
;/ Description:                                                                /
;/ Converts any image into a blitz2 shape object. You need to have opned a s:: /
;/ creen first, otherwise                                                      /
;/ the image can not be remapped.                                              /
;/ NOTE: Don't release the image as long as the shape is visible somewhere o:: /
;/ n the screen to keep the colors allocated. You may call image_free_data.    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l  : image object ID                                                /
;/ - bshape.l : Number of the Blitz shape object                               /
;/ - trgb.l   : transparent RGB value, e.g. $ff0000 for red                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;/ See also:    image_LoadShape                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_2Shape{image.l,bshape.l,@trgb.l}
SHARED imagedat()
DEFTYPE.RastPort rp
DEFTYPE.BitMap bmp

  USEPATH imagedat(image)
  succ.l = False
  If \isused >< False AND Used Screen >= 0
    *scr.Screen = Peek.l(Addr Screen(Used Screen))
    If *scr
      shapedepth.l = GetBitMapAttr_(*scr\RastPort\BitMap,#BMA_DEPTH)
      If shapedepth > 8 Then shapedepth = 8
      If shapedepth < 1 Then shapedepth = 8
      ;error{"Shapedepth: "+Str$(shapedepth)}
      width.l  = image_GetWidth{image}
      height.l = image_GetHeight{image}
      *shape_ptr.shapeint = Addr Shape(bshape)
      Free Shape bshape
      InitShape bshape,width,height,shapedepth
      InitRastPort_ &rp
      InitBitMap_ &bmp,shapedepth,width,height
      For i.w=0 To shapedepth-1
        bmp\Planes[i] = *shape_ptr\_data + i * height * (((width + 15) LSR 3) & $FFFE)
      Next i
      rp\BitMap = &bmp
      image_SetDitherMode{image,#image_dithermode_none}  ; we don't want dithering in GUI elements
      image_InitBitMap{image,bmp}
      image_Blit{image,0,0,&rp}
      image_FreeBitMap{image}
      If trgb >< -1 Then image_MakeCookie{image,bshape,trgb} : Else image_MakeBlockCookie{bshape}
      succ.l = True
    End If
  Else
    error{"\\__THIS_FUNCTION: Tried to convert a non-exisiting image!"}
  End If
  USELASTPATH
  Function Return succ
End Function
CEND

CNIF #use_shapeslib
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = image_LoadShape{bshape.l,filename.s,@trgb.l}              /
;/                                                                             /
;/ Description:                                                                /
;/ Replaces LoadShape with possibility to load 24bit images and all fileform:: /
;/ ats                                                                         /
;/                                                                             /
;/ NOTE: make sure to have a used screen before you call this                  /
;/ NOTE: if you change the screen you have to load the shape again             /
;/ NOTE: the image and the shape object share the same obj number              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - bshape.l   : Number of the image/shape "object"                           /
;/ - filename.s : filename of the image file (can be gif, jpg, iff, bmp usw.)  /
;/ - trgb.l     : rgb value of the transparent color, e.g. $00ff00 for pure :: /
;/ green                                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : True if everything went well, False if it failed             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_LoadShape{bshape.l,filename.s,@trgb.l}

  succ.l = False
  If image_Load{bshape,filename.s,trgb}
    If image_2Shape{bshape,bshape,trgb}
      image_FreeData{bshape}
      succ = True
    End If
  End If
  Function Return succ
End Function
CEND

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l =  image_MaskHit{image.l,x.l,y.l}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Test if the given coordinates hit the transparency mask or not              /
;/                                                                             /
;/ NOTE: this function can be used to detect collision with the foreground i:: /
;/ f you have foreground and background in two different images                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l       : image object ID                                           /
;/ - x.l           : x position                                                /
;/ - y.l           : y position                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l        : True if the mask is set, False if it is transparent       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_MaskHit{image.l,x.l,y.l}
SHARED imagedat()

  USEPATH imagedat(image)
  succ.l = False
  ;If \mask_ptr = 0 Then image_InitMask{image.l,$0}
  If x >= 0 AND y >= 0 AND x < \img_width AND y < \img_height
    If \mask_ptr
      linemod.l = \mask_bpr
      bytepos.l = \mask_ptr + y * linemod + x / 8
      bitmask.l = 1 LSL (x MOD 8)
      If (Peek.b(bytepos) AND bitmask) Then succ = True
    Else
      succ = True
    End If
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  image_GetMask{image.l,x.l,y.l}                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_GetMask{image.l,x.l,y.l}

  Function Return image_MaskHit{image,x,y}
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  image_IsSolid{image.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_IsSolid{image.l}
SHARED imagedat()

  USEPATH imagedat(image)
  solid.l = True
  If \is_solid = 0 Then Function Return False
  If \is_solid = -1 Then Function Return True
  If \alpha_isused = 0
    If \mask_isused = 0 OR \mask_ptr = 0
      solid = True
    Else
      lastbyte.l = 1 LSL (\img_width MOD 8)-1
      solid.l = True
      For y.l = 0 To \img_height-1
        ptr.l = \mask_ptr + y*\mask_bpr
        For x.l = 0 To (\img_width+7)/8-2
          If Peek.b(ptr+x) >< -1 Then solid = False : y = \img_height
        Next
        If (Peek.b(ptr+x)&lastbyte) >< lastbyte Then solid = False
      Next
    End If
  Else
    For y.l = 0 To \img_height-1
      ptr.l = \raw_ptr+y*\bpr
      For x.l = 0 To \img_width-1
        If Peek.b(ptr) >< -1 Then solid = False : y = \img_height
        ptr+4
      Next
    Next
  End If
  \is_solid = solid
  Function Return solid
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  rgbvalue.l =  image_GetRGB{image.l,x.l,y.l}                        /
;/                                                                             /
;/ Description:                                                                /
;/ Extracts the RGB value at the given coordinates of the image.               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l       : image object ID                                           /
;/ - x.l           : x position                                                /
;/ - y.l           : y position                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - rgbvalue.l    : rgbvalue at the x/y position, e.g. $00ff00 for green      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_GetRGB{image.l,x.l,y.l}
SHARED imagedat(),imgargs()

  USEPATH imagedat(image)
  If \ARGBbitmap_ptr
    If x >= 0 AND y >= 0 AND x < \img_width AND y < \img_height
      memloc.l = \raw_ptr + (\bpr*y) + (x*\bpp)
      Function Return Peek.l(memloc) AND $00ffffff
    End If
  End If
  Function Return $00000000
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  image_GetARGB{image.l,x.l,y.l}                         /
;/                                                                             /
;/ Description:                                                                /
;/ Get the ARGB value of a pixel within the image.                             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID                                                 /
;/ - x.l     : x position                                                      /
;/ - y.l     : y position                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l  : ARGB value as a long integer                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_GetARGB{image.l,x.l,y.l}
SHARED imagedat(),imgargs()

  USEPATH imagedat(image)
  If \ARGBbitmap_ptr
    If x >= 0 AND y >= 0 AND x < \img_width AND y < \img_height
      memloc.l = \raw_ptr + (\bpr*y) + (x*\bpp)
      Function Return Peek.l(memloc)
    End If
  End If
  Function Return $00000000
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  image_GetAlpha{image.l,x.l,y.l}                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_GetAlpha{image.l,x.l,y.l}
SHARED imagedat(),imgargs()

  USEPATH imagedat(image)
  If x >= 0 AND y >= 0 AND x < \img_width AND y < \img_height
    If \ARGBbitmap_ptr >< 0 AND \alpha_isused
      memloc.l = \raw_ptr + (\bpr*y) + (x*\bpp)
      Function Return Peek.l(memloc) LSR 24
    Else
      Function Return $FF
    End If
  End If
  Function Return $00
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  image_GetTransparency{image.l,x.l,y.l}                 /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_GetOpacity{image.l,x.l,y.l}
SHARED imagedat(),imgargs()

  USEPATH imagedat(image)
  If x >= 0 AND y >= 0 AND x < \img_width AND y < \img_height
    If \ARGBbitmap_ptr >< 0 AND \alpha_isused
      memloc.l = \raw_ptr + (\bpr*y) + (x*\bpp)
      Function Return Peek.l(memloc) LSR 24   ; return alpha
    Else
      If \mask_ptr
        linemod.l = \mask_bpr
        bytepos.l = \mask_ptr + y * linemod + x / 8
        bitmask.l = 1 LSL (x MOD 8)
        If (Peek.b(bytepos) AND bitmask) Then Function Return $FF
      Else
        Function Return $FF
      End If
    End If
  End If
  Function Return $00
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  rgbvalue.l =  image_GetRGBFromRP{rp.l,x.l,y.l,scr.l}               /
;/                                                                             /
;/ Description:                                                                /
;/ Extracts the RGB value at the given coordinates from any rastport.          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - rp.l          : Rastport                                                  /
;/ - x.l           : x position                                                /
;/ - y.l           : y position                                                /
;/ - scr.l         : optional screen from where to fetch the colormap          /
;/                                                                             /
;/ Result:                                                                     /
;/ - rgbvalue.l    : rgbvalue at the x/y position, e.g. $00ff00 for green      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST image_GetRGBFromRP{*rp.RastPort,x.l,y.l,@*scr.Screen}
SHARED imagedat(),imgargs(),cme.cmapitem

  USEPATH imagedat(image)
  rgbvalue.l = $000000
  If *rp >< Null
    d.l = GetBitMapAttr_(*rp\BitMap,#BMA_DEPTH)>8
    If d = 0 OR d > 8
      rgbvalue.l = ReadRGBPixel_(*rp,x,y)
    Else
      If *scr = -1 Then *scr = Peek.l(Addr Screen(Used Screen))
      If *scr
        ;rgb4.l     = GetRGB4_(*scr\ViewPort\ColorMap,ReadPixel_(rp,x,y))
        ;rgbvalue.l = ((rgb4 & $00000f) LSL  4)
        ;rgbvalue.l + ((rgb4 & $0000f0) LSL  8)
        ;rgbvalue.l + ((rgb4 & $000f00) LSL 12)
        rgb32.l = GetRGB32_(*scr\ViewPort\ColorMap,ReadPixel_(*rp,x,y),1,cme)
        rgbvalue = (cme\R & $FF000000 LSR 8) | ((cme\G & $FF000000) LSR 16) | ((cme\B & $FF000000) LSR 24)
      End If
    End If
  End If
  Function Return rgbvalue
End Function

Function.l image_AutoCrop{image.l,threshold.l,@image_src.l}
SHARED imagedat(),imageengine

  USEPATH imagedat(image_src)
  If image_src = -1 Then image_src = image
  succ.l = False
  If threshold < 0 Then threshold = 10
  If image_Lock{image_src}
    y1.l = 0
    y2.l = \img_height-1
    x1.l = 0
    x2.l = \img_width-1

    Repeat                              ; top
      gotdata.l = False
      ptr.l     = \raw_ptr + \bpr * y1 + x1 * \bpp
      For x.l = x1 To x2
        A.l = Peek.l(ptr) LSR 24
        If A > threshold Then gotdata = True
        ptr + \bpp
      Next
      If y1 > y2 Then gotdata = True
      If gotdata = False Then y1+1
    Until gotdata

    Repeat                            ; bottom
      gotdata.l = False
      ptr.l     = \raw_ptr + \bpr * y2 + x1 * \bpp
      For x.l = x1 To x2
        A.l = Peek.l(ptr) LSR 24
        If A > threshold Then gotdata = True
        ptr + \bpp
      Next
      If y2 < y1 Then gotdata = True
      If gotdata = False Then y2-1
    Until gotdata

    Repeat                              ; left
      gotdata.l = False
      ptr.l     = \raw_ptr + \bpr * y1 + x1 * \bpp
      For y.l = y1 To y2
        A.l = Peek.l(ptr) LSR 24
        If A > threshold Then gotdata = True
        ptr + \bpr
      Next
      If x1 > x2 Then gotdata = True
      If gotdata = False Then x1+1
    Until gotdata

    Repeat                            ; right
      gotdata.l = False
      ptr.l     = \raw_ptr + \bpr * y1 + x2 * \bpp
      For y.l = y1 To y2
        A.l = Peek.l(ptr) LSR 24
        If A > threshold Then gotdata = True
        ptr + \bpr
      Next
      If x2 < x1 Then gotdata = True
      If gotdata = False Then x2-1
    Until gotdata

    image_Unlock{image_src}
    If x1 <= x2 AND y1 <= y2
    NPrint "autocrop: (",x1,"|",y1,") (",x2,"|",y2,")"
    hx.l = \handle_x
    hy.l = \handle_y
    USEPATH imagedat(image)
    If (image_src = image)
      image2.l = image_GetFree{}
      image_Cut{image2,image,x1,y1,x2-x1+1,y2-y1+1}
      image_Cut{image,image2}
      image_Free{image2}
    Else
      image_Cut{image,image_src,x1,y1,x2-x1+1,y2-y1+1}
    End If
    image_SetHandle{image,hx-x1,hy-y1}
    image_ReuseAlpha{image}
    succ = True
    Else
      ;NPrint "image does not contain data!"
      ;succ=False
      If (image_src >< image)
       image_Cut{image,image_src}
       succ = True
      End If
    End If
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_CPUBlit{image.l,x.l,y.l,@rp.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Blit an image transparent using the CPU.                                    /
;/ Note: This works only on GFX cards with 8, 16, 24 or 32 bit color depth.    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID                                                 /
;/ - x.l     : x position                                                      /
;/ - y.l     : y position                                                      /
;/ - rp.l    : optional a rastport to blit into, otherwise it is blitted to :: /
;/ the used window                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_CPUBlit{image.l,x.l,y.l,@*rp.RastPort}
SHARED imagedat()

  USEPATH imagedat(image)
  If \bitmap_ptr = False Then image_InitBitMap{image}
  If *rp = -1 AND Used Window >= 0 Then *rp = RastPort(Used Window)
  If \bitmap_ptr >< False AND *rp >< 0 AND *rp >< -1
    ;*rp.RastPort = rp
    tag5.tag5\ti_Tag = #LBMI_BASEADDRESS,&destaddr.l  ,#LBMI_BYTESPERROW,&destbpr.l,#TAG_DONE,0
    *hand.l          = LockBitMapTagList_(*rp\BitMap ,tag5) : If *hand Then UnLockBitMap_ *hand
    tag5.tag5\ti_Tag = #LBMI_BASEADDRESS,&sourceaddr.l,#LBMI_BYTESPERROW,&sourcebpr.l,#LBMI_BYTESPERPIX,&pixelsize.l ,#TAG_DONE,0
    *hand            = LockBitMapTagList_(\bitmap_ptr,tag5) : If *hand Then UnLockBitMap_ *hand
    maskaddr.l       = \mask_ptr
    maskbpr.l        = \mask_bpr;((\img_width+15)LSR 4)ASL 1
    xoff.l           = \clip_x
    yoff.l           = \clip_y
    !image_GetClipBounds{*rp,minx.l,miny.l,maxx.l,maxy.l}

    x1.l = x - \handle_x ;+ minx
    y1.l = y - \handle_y ;+ miny
    x2.l = x1 + \clip_xs-1
    y2.l = y1 + \clip_ys-1
    If x1 < minx Then xoff-x1+minx : x1 = minx
    If y1 < miny Then yoff-y1+miny : y1 = miny
    If x2 > maxx Then x2 = maxx
    If y2 > maxy Then y2 = maxy

    blitwidth.l = x2-x1+1
  ;  blitheight.l = y2-y1+1
    !image_GetLayerOffset{*rp,lxoff.l,lyoff.l}
    x1+lxoff : x2+lxoff
    y1+lyoff : y2+lyoff

  ;  WLocate 20,20
  ;  NPrint "CPUblit: ",x1,"/",y1," - ",blitwidth,"x",blitheight,"! Clipbound:",minx,"/",maxx,"..."+Str$(miny)+"/"+Str$(maxy)

    If blitwidth > 0
      blitwidth-1
      destaddr.l   = destaddr   + destbpr   *y1    + x1   *pixelsize
      sourceaddr.l = sourceaddr + sourcebpr *yoff  + xoff *pixelsize

      If maskaddr
        maskaddr.l   = maskaddr   + maskbpr   *yoff  + (Int(xoff / 16)*2)
        maskoff.l    = 15 - (xoff MOD 16)
        For i.l = y1 To y2
          ;GetRegD0 blitwidth :MOVE.l d0,d1
          ;GetRegD0 sourceaddr:MOVE.l d0,a0
          ;GetRegD0 destaddr  :MOVE.l d0,a1
          ;GetRegD0 maskaddr  :MOVE.l d0,a2
          ;GetRegD0 maskoff   :MOVE.l d0,d3
          ;GetRegD0 pixelsize

          GetReg d1,blitwidth
          GetReg a0,sourceaddr
          GetReg a1,destaddr
          GetReg a2,maskaddr
          GetReg d3,maskoff
          GetReg d0,pixelsize

          MOVE.w (a2)+,d2  ; mask
          CMP.l #1,d0
          BEQ cpublitm8
          CMP.l #2,d0
          BEQ cpublitm16
          CMP.l #3,d0
          BEQ cpublitm24
          CMP.l #4,d0
          BEQ cpublitm32
          BRA cpublit_opaque_mask_nextrow
          cpublitm8 : !image_blitrow_mask_opaque_8
          cpublitm16: !image_blitrow_mask_opaque_16
          cpublitm24: !image_blitrow_mask_opaque_24
          cpublitm32: !image_blitrow_mask_opaque_32
          cpublit_opaque_mask_nextrow:
          sourceaddr+sourcebpr
          destaddr  +destbpr
          maskaddr  +maskbpr
        Next
      Else
        blitwidth*pixelsize + pixelsize
        For i.l = y1 To y2
          CopyMem_ sourceaddr,destaddr,blitwidth
          sourceaddr+sourcebpr
          destaddr  +destbpr
        Next
      End If
    End If
  ; all the code above is replacing just this: (but using CPU)
  ; BltBitMapRastPort_ \bitmap_ptr,0,0,rp,x-\handle_x,y-\handle_y,\img_width,\img_height,$c0
  Else
    error{"\\__THIS_FUNCTION: Uninitialized image bmap/Window/Screen!"}
  End If
End Statement

#texfix= 0
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_crossline                                                    /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_crossline
  If m`1y >< 0
    r.f = (y - y`1) / m`1y
    xp`1.f = x`1 + r*m`1x
  Else
    xp`1 = -1
    r  = -1
  End If
  If r <= 1 AND r >= 0

    CNIF `1 = 1
      If xp`1 < gx1 Then gx1 = xp`1   : sx1.f = imgw * (r) : sy1.f = 0.0 : CNIF #texfix : a.f = l`1.f : CEND
      If xp`1 > gx2 Then gx2 = xp`1   : sx2.f = imgw * (r) : sy2.f = 0.0 : CNIF #texfix : b.f = l`1.f : CEND
    CEND
    CNIF `1 = 2
      If xp`1 < gx1 Then gx1 = xp`1   : sy1.f = imgh * (r) : sx1.f = imgw : CNIF #texfix : a.f = l`1.f : CEND
      If xp`1 > gx2 Then gx2 = xp`1   : sy2.f = imgh * (r) : sx2.f = imgw : CNIF #texfix : b.f = l`1.f : CEND
    CEND
    CNIF `1 = 3
      If xp`1 < gx1 Then gx1 = xp`1   : sx1.f = imgw * (1-r) : sy1.f = imgh : CNIF #texfix : a.f = l`1.f : CEND
      If xp`1 > gx2 Then gx2 = xp`1   : sx2.f = imgw * (1-r) : sy2.f = imgh : CNIF #texfix : b.f = l`1.f : CEND
    CEND
    CNIF `1 = 4
      If xp`1 < gx1 Then gx1 = xp`1   : sy1.f = imgh * (1-r) : sx1.f = 0.0 : CNIF #texfix : a.f = l`1.f : CEND
      If xp`1 > gx2 Then gx2 = xp`1   : sy2.f = imgh * (1-r) : sx2.f = 0.0 : CNIF #texfix : b.f = l`1.f : CEND
    CEND
  End If
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_AreCompatible{image.l,image2.l,@checkbpr.l}       /
;/                                                                             /
;/ Description:                                                                /
;/ Check if two images are compatible in size and depth.                       /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - image2.l    : image object ID                                             /
;/ - checkbpr.l    : bytes per row                                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_AreCompatible{image.l,image2.l,@checkbpr.l}

  succ.l = False
  If checkbpr
    If (\img_width = imagedat(image2)\img_width) AND (\img_height = imagedat(image2)\img_height) AND (\bpr = imagedat(image2)\bpr) Then succ = -1
  Else
    If (\img_width = imagedat(image2)\img_width) AND (\img_height = imagedat(image2)\img_height) Then succ = -1
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_TextureBlit{image.l,*coos.texturearray,@brightness.l,@db.l::  /
;/ ,@fast.l,@*rp.RastPort}                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Blit in perspective.                                                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - *coos.texturearray    : ???                                               /
;/ - brightness.l    : ???                                                     /
;/ - db.l    : ???                                                             /
;/ - fast.l    : ???                                                           /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
RunErrsOff
Statement image_TextureBlit{image.l,*coos.texturearray,@brightness.l,@db.l,@fast.l,@*rp.RastPort}
SHARED imagedat(),imgargs(),imageengine

  USEPATH imagedat(image)
  If *rp = -1 AND Used Window >= 0 Then *rp = RastPort(Used Window)
  sourcebase.l = \raw_ptr;bpr ; image_get_rawptr{image}

  If *rp >< 0 AND *rp >< -1 AND sourcebase >< 0
      sourcebpr.l  = \bpr
      sourcebase.l = \raw_ptr + \bpr * \clip_y + \bpp * \clip_x
      imgw.f       = \clip_xs
      imgh.f       = \clip_ys
      maskaddr.l   = \mask_ptr
      maskbpr.l    = \mask_bpr;((\img_width+15)LSR 4)ASL 1
      !image_GetClipBounds{*rp,minx.l,miny.l,maxx.l,maxy.l}

      x1.l = *coos\x1
      x2.l = *coos\x2
      x3.l = *coos\x3
      x4.l = *coos\x4
      y1.l = *coos\y1
      y2.l = *coos\y2
      y3.l = *coos\y3
      y4.l = *coos\y4

      n.l = (x1-x2)*(y2-y3) - (y1-y2)*(x2-x3) ; from which side are we "looking" at the texture ?

      If n >= 0 OR db  ; from the front side or d_raw b_ackside mode
        ty.l = Min(Min(Min(y1,y2),y3),y4)
        by.l = Max(Max(Max(y1,y2),y3),y4)

        lx.l = Min(Min(Min(x1,x2),x3),x4)
        rx.l = Max(Max(Max(x1,x2),x3),x4)

        blitwidth.l = rx-lx+1
        tmpptr.l = tempbuffer_Get{blitwidth*4}

        m1y.f = (y2-y1)
        m1x.f = (x2-x1)

        m2y.f = (y3-y2)
        m2x.f = (x3-x2)

        m3y.f = (y4-y3)
        m3x.f = (x4-x3)

        m4y.f = (y1-y4)
        m4x.f = (x1-x4)

        CNIF #texfix
        l1.f = Sqr(m1y*m1y + m1x*m1x)
        l2.f = Sqr(m2y*m2y + m2x*m2x)
        l3.f = Sqr(m3y*m3y + m3x*m3x)
        l4.f = Sqr(m4y*m4y + m4x*m4x)
        CEND

       ; set default brightness
        If brightness < 0 Then brightness = 256

        If fast ; we want fast blitting
          imgw.f = imgw -0.01
          imgh.f = imgh -0.01
        Else    ; we want interpolation
          imgw.f   = imgh -1.01
          imgh.f   = imgh -1.01
          bright.f = Sqr(brightness / 256.0)
        End If

        If ty < miny Then ty = miny  ; clip top
        If by > maxy Then by = maxy  ; clip bottom
    !setfpcr{($10)}
    For y.l = ty To by
      gx1.f = rx
      gx2.f = lx
      sx1.f = 0
      sy1.f = 0
      sx2.f = 0
      sy2.f = 0

      !image_crossline{1}
      !image_crossline{2}
      !image_crossline{3}
      !image_crossline{4}

      xs.f = gx2-gx1+1 : If xs <= 0 Then xs = 1
      dx.f = (sx2-sx1)/xs
      dy.f = (sy2-sy1)/xs

  CNIF #texfix
  ;_______________________________
      dr.f    = a/b
      dmin.f  = xs / dr
      dmax.f  = xs * dr
      ;dx.f   = (sx2-sx1) /dmax
      ;dy.f   = (sy2-sy1) /dmax
      dx2.f   = (sx2-sx1) /dmin
      dy2.f   = (sy2-sy1) /dmin
      syb.f   = sy1
      sxb.f   = sx1
      diffx.f = (dx2-dx)/ xs
      diffy.f = (dy2-dy)/ xs
      dlx.f   = sx2-sx1
      dly.f   = sy2-sy1
  ;_______________________________
  CEND
      xa.l  = gx1
      xb.l  = gx2
      frx.f = gx1-xa
      sx1 + ((1-frx) * dx)
      sy1 - ((frx) * dy) +dy

      If xa < minx
        dx2.f = minx-xa
        sx1+dx2*dx
        sy1+dx2*dy
        xa = minx
      End If

      If xb > maxx
        xb = maxx
      End If

      destaddr.l = tmpptr ; imageengine\tmpbuffer
      ;ReadPixelArray_ destaddr,0,0,xb-xa+1,*rp,xa-minx,y-miny,xb-xa+1,1,#RECTFMT_ARGB

      If brightness = 256 AND fast
        RegLoad dy,dx,sy1,sx1
        For x.l = xa To xb ; blit 32 bit 1:1
          sy1i.l = sy1
          sx1i.l = sx1
          sy1 + dy : sx1 + dx
          CNIF #texfix
            ;_______________________________
            dy+diffy
            dx+diffx
            ;_______________________________
          CEND

          Poke.l destaddr,Peek.l((sx1i LSL 2) + sourcebase + sourcebpr * sy1i )
          destaddr+4
        Next
        RegSave
      Else
        If fast
          RegLoad dy,dx,sy1,sx1
          For x = xa To xb  ; blit 32 bit shaded
            sy1i.l = sy1
            sx1i.l = sx1
            sy1 + dy : sx1 + dx
            CNIF #texfix
            ;_______________________________
            sy1 = syb + (dy+diffy)*(x-xa)
            dx+diffx
            ;_______________________________
            CEND
            col.l = Peek.l(sourcebase + sourcebpr * sy1i + (sx1i LSL 2))
            R.l = ((col          & $FF   ) * brightness)             : If R > $FF00   Then R = $FF00
            G.l = (((col       ) & $FF00 ) * brightness) & $FFFF0000 : If G > $FF0000 Then G = $FF0000
            B.l = (((col LSR 8 ) & $FF00 ) * brightness) & $FFFF0000 : If B > $FF0000 Then B = $FF0000
            A.l = (col & $FF000000 )
            Poke.l destaddr,((R | G) LSR 8) | B | A
            destaddr+4
          Next
          RegSave
        Else
          RegLoad dy,dx,sy1,sx1
          For x = xa To xb   ; blit 32 bit with interpolation
            sy1i.l = sy1
            sx1i.l = sx1

            sourceaddr.l = (sx1i LSL 2) + sourcebase + sourcebpr * sy1i

            xii.f = (sx1 - sx1i) * bright:; If xii<0 Then xii=0
            yii.f = (sy1 - sy1i) * bright:; If yii<0 Then yii=0
            xi.f = bright-xii
            yi.f = bright-yii

            CNIF #texfix
            ;_______________________________
            i.f = x-xa
            nn.f = xs
            dx = (a * i / nn + b * (nn-i)/nn * dlx) / (b * i + a*(n-i))
            dy = (a * i / nn + b * (nn-i)/nn * dly) / (b * i + a*(n-i))
            ;_______________________________
            CEND

            sy1 + dy  : sx1 + dx

            i1.f = (xi  * yi )
            i2.f = (xii * yi )
            i3.f = (xi  * yii)
            i4.f = (xii * yii)

            col.l = Peek.l(sourceaddr)
            R.l = (col & $FF     ) * i1
            G.l = (col & $FF00   ) * i1
            B.l = (col & $FF0000 ) * i1
            A.l = ((col & $FF000000 ) LSR 8) * i1

            col = Peek.l(sourceaddr+4)
            R + (col & $FF     ) * i2
            G + (col & $FF00   ) * i2
            B + (col & $FF0000 ) * i2
            A + ((col & $FF000000 )LSR 8) * i2

            col = Peek.l(sourceaddr+sourcebpr)
            R + (col & $FF     ) * i3
            G + (col & $FF00   ) * i3
            B + (col & $FF0000 ) * i3
            A + ((col & $FF000000 )LSR 8) * i3

            col = Peek.l(sourceaddr+sourcebpr+4)
            R + (col & $FF     ) * i4
            G + (col & $FF00   ) * i4
            B + (col & $FF0000 ) * i4
            A + ((col & $FF000000) LSR 8) * i4

            If R > $FF     Then R = $FF
            If G > $FF00   Then G = $FF00
            If B > $FF0000 Then B = $FF0000
            If A > $FF0000 Then A = $FF0000

            col.l = R | (G & $FF00) | (B & $FF0000) | ((A & $FF0000) LSL 8)

            Poke.l destaddr,col
            destaddr+4
          Next
          RegSave
        End If
      End If
      WritePixelArray_ tmpptr,0,0,xb-xa+1,*rp,xa,y,xb-xa+1,1,#RECTFMT_ARGB
    Next
    End If
    !setfpcr{0}
  Else
    error{"\\__THIS_FUNCTION: Uninitialized image bmap/Window/Screen!"}
  End If
End Statement
LastRunErrsMode

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_TwoThird{image.l,srcimage.l}                      /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - srcimage.l    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_TwoThird{image.l,srcimage.l}
SHARED imagedat()

  succ.l = False
  xs.l   = image_GetWidth{srcimage}
  ys.l   = image_GetHeight{srcimage}
  Function Return  image_Resize{image,srcimage,xs*2/3,ys*2/3}

  xsh.l  = (xs)*2/3
  ysh.l  = (ys)*2/3

  If image_Create{image,xsh,ysh}
     succ     = True
     ;If xs MOD 3 Then xrow.l = True : xsh-1 : Else xrow = False
     ;If ys MOD 3 Then yrow.l = True : ysh-1 : Else yrow = False
     srcptr.l = imagedat(srcimage)\raw_ptr
     srcbpr.l = imagedat(srcimage)\bpr
     dstptr.l = \raw_ptr
     dstbpr.l = \bpr
     For y.l = 0 To (ysh/2)-1
       row1ptr.l  = srcptr  + (y*3) * srcbpr
       row2ptr.l  = row1ptr + srcbpr
       row3ptr.l  = row2ptr + srcbpr

       drow1ptr.l = dstptr + (y*2) * dstbpr
       drow2ptr.l = drow1ptr + dstbpr

       For x.l = 0 To (xsh/2)-1
         col11.l = (Peek.l (row1ptr) & $FEFEFEFE) LSR 1  : row1ptr+4
         col21.l = (Peek.l (row1ptr) & $F8F8F8F8) LSR 2  : row1ptr+4
         col31.l = (Peek.l (row1ptr) & $FEFEFEFE) LSR 1  : row1ptr+4
         col12.l = (Peek.l (row2ptr) & $F8F8F8F8) LSR 2  : row2ptr+4
         col22.l = (Peek.l (row2ptr) & $F8F8F8F8) LSR 3  : row2ptr+4
         col32.l = (Peek.l (row2ptr) & $F8F8F8F8) LSR 2  : row2ptr+4
         col13.l = (Peek.l (row3ptr) & $FEFEFEFE) LSR 1  : row3ptr+4
         col23.l = (Peek.l (row3ptr) & $F8F8F8F8) LSR 2  : row3ptr+4
         col33.l = (Peek.l (row3ptr) & $FEFEFEFE) LSR 1  : row3ptr+4
         dcol11.l = col11+col21+(col12 LSR 1)+col22
         dcol21.l = col31+(col21 LSR 1)+col32+col22
         dcol12.l = col13+(col23 LSR 1)+col12+col22
         dcol22.l = col33+col23+(col32 LSR 1)+col22
         Poke.l drow1ptr  , dcol11  : drow1ptr +4
         Poke.l drow1ptr  , dcol21  : drow1ptr +4
         Poke.l drow2ptr  , dcol12  : drow2ptr +4
         Poke.l drow2ptr  , dcol22  : drow2ptr +4
       Next
       ;If xrow Then Poke.l drow1ptr,Peek.l(row1ptr)
     Next
     If False;yrow
       row1ptr.l  = srcptr + (y*3) * srcbpr
       drow1ptr.l = dstptr + (y*2) * dstbpr
       For x.l = 0 To xsh-1
         col.l = Peek.l (row1ptr) : row1ptr+4
         Poke.l drow1ptr, col : drow1ptr+4
       Next
     End If
     image_CopyConfig{image,srcimage}
     \handle_x = imagedat(srcimage)\handle_x *2/ 3
     \handle_y = imagedat(srcimage)\handle_y *2/ 3
     ;\alpha_isused = imagedat(srcimage)\alpha_isused
     ;\mask_trgb = imagedat(srcimage)\mask_trgb
  End If
  Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_RotateBlit{image.l,x.l,y.l,angle.f,@zoom.f,@fast.l,@*rp.Ra::  /
;/ stPort}                                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Blit a picture, rotated at any angle.                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - x.l    : x position                                                       /
;/ - y.l    : y position                                                       /
;/ - angle.f    : angle                                                        /
;/ - zoom.f    : zoom                                                          /
;/ - fast.l    : -1 = use fast function, 0 = use quality function              /
;/ - *rp.RastPort    : destination rastport                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement  image_RotateBlit{image.l,x.l,y.l,angle.f,@zoom.f,@fast.l,@*rp.RastPort}
SHARED imagedat()

  w.f = \clip_xs
  h.f = \clip_ys
  r.f = Sqr(w*w + h*h) ; edge Radius

  a1.f = ASin(w/r)  ; calculate angles
  a2.f = -a1

  a1-angle
  a2-angle

  If zoom <= 0 Then zoom = 1

  r*zoom /2
  offx.f = \handle_x * zoom
  offy.f = \handle_y * zoom
  x - offx
  y - offy
  w*zoom /2
  h*zoom /2

  x+w
  y+h

  x1.f = Sin(a1) * r
  y1.f = Cos(a1) * r
  x2.f = Sin(a2) * r
  y2.f = Cos(a2) * r

  coos.texturearray\x1 = x - x1
  coos.texturearray\y1 = y - y1
  coos.texturearray\x2 = x - x2
  coos.texturearray\y2 = y - y2
  coos.texturearray\x3 = x + x1
  coos.texturearray\y3 = y + y1
  coos.texturearray\x4 = x + x2
  coos.texturearray\y4 = y + y2

  image_TextureBlit{image,coos,-1,-1,fast,*rp}
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_CPUBlitRPRP{rp_s.l,b_x.l,b_y.l,rp_d.l,r_x.l,r_y.l,xs.l,ys.::  /
;/ l,@fade_ratio.l,@fade_rgb.l}                                                /
;/                                                                             /
;/ Description:                                                                /
;/ Blit an area of a rastport to another rastport using CPU and optional fad:: /
;/ ing towards a color.                                                        /
;/                                                                             /
;/ NOTE: This statement is probably not very useful for you. It is used in d:: /
;/ bl.include for fading.                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - rp_s.l    : source rastport                                               /
;/ - b_x.l    :                                                                /
;/ - b_y.l    :                                                                /
;/ - rp_d.l    : destination rastport                                          /
;/ - r_x.l    :                                                                /
;/ - r_y.l    :                                                                /
;/ - xs.l    : area width                                                      /
;/ - ys.l    : area height                                                     /
;/ - fade_ratio.l    : fade ration 0...256                                     /
;/ - fade_rgb.l    : RGB value to fade to                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_CPUBlitRPRP{rp_s.l,b_x.l,b_y.l,rp_d.l,r_x.l,r_y.l,xs.l,ys.l,@fade_ratio.l,@fade_rgb.l}
SHARED imagedat(),imageengine

  USEPATH imagedat(image)
  *rp_d.RastPort = rp_d
  *rp_s.RastPort = rp_s
  tag5.tag5\ti_Tag = #LBMI_BASEADDRESS,&destaddr.l  ,#LBMI_BYTESPERROW,&destbpr.l,#TAG_DONE,0
  *hand.l          = LockBitMapTagList_(*rp_d\BitMap,tag5) : If *hand Then UnLockBitMap_ *hand
  tag5.tag5\ti_Tag = #LBMI_BASEADDRESS,&sourceaddr.l,#LBMI_BYTESPERROW,&sourcebpr.l,#LBMI_BYTESPERPIX,&pixelsize.l ,#TAG_DONE,0
  *hand            = LockBitMapTagList_(*rp_s\BitMap,tag5) : If *hand Then UnLockBitMap_ *hand

  !image_GetClipBounds{*rp_d,minx.l,miny.l,maxx.l,maxy.l}
  !image_GetClipBounds{*rp_s,minbx.l,minby.l,maxbx.l,maxby.l}
  !image_GetLayerOffset{*rp_d,dxoff.l,dyoff.l}
  !image_GetLayerOffset{*rp_s,sxoff.l,syoff.l}
  x1.l = r_x ;+ minx
  y1.l = r_y ;+ miny
  x2.l = x1 + xs-1
  y2.l = y1 + ys-1
  If x1 < minx Then b_x-x1+minx : x1 = minx
  If y1 < miny Then b_y-y1+miny : y1 = miny
  If x2 >= maxx Then x2 = maxx
  If y2 >= maxy Then y2 = maxy
  blitwidth.l = x2-x1+1

  ;blitheight.l = y2-y1+1
  ;WLocate 20,20
  ;NPrint "CPUblitRPRP: ",x1,"/",y1," - ",blitwidth,"x",blitheight,"! Clipbound:"+Str$(minx)+"/"+Str$(maxx)+"..."+Str$(miny)+"/"+Str$(maxy)

  If blitwidth > 0
    destaddr.l   = destaddr   + destbpr   * (y1+dyoff)   + (x1+dxoff)  * 4
    sourceaddr.l = sourceaddr + sourcebpr * (b_y+sxoff)  + (b_x+syoff) * 4
    If fade_ratio <= 0
      blitwidth*4
      For i.l = y1 To y2
        CopyMem_ sourceaddr,destaddr,blitwidth
        sourceaddr+sourcebpr
        destaddr  +destbpr
      Next
    Else
      blitheight.l = y2-y1+1
      tmpptr.l     = tempbuffer_Get{blitwidth*blitheight*4}
      sourceaddr.l = tmpptr
      destaddr.l   = sourceaddr
    If sourceaddr
      sourcebpr = blitwidth*4
      destbpr   = blitwidth*4
      dbpr.l    = blitwidth*4
      ReadPixelArray_ sourceaddr,0,0,dbpr,rp_s,b_x,b_y,blitwidth,blitheight,#RECTFMT_ARGB
      For i.l = y1 To y2
        GetReg d5,blitwidth
        GetReg a1,destaddr
        GetReg d1,255-fade_ratio
        GetReg d4, (fade_rgb & $FF)          * (fade_ratio)
        GetReg d3,((fade_rgb LSR 8 ) & $FF)  * (fade_ratio)
        GetReg d2,((fade_rgb LSR 16) & $FF)  * (fade_ratio)
        GetReg a0,sourceaddr

        MOVE.l d7,-(a7)
          fadeloop:
          MOVE.l   (a0)+,d0   ; get the source pixel
          ;LSR.l #8,d0         ; remove alpha


          MOVE.l d0,d6
          AND.l #%11111111,d6 : MULU.l d1,d6
          ADD.l  d4,d6 : LSR.l #8,d6


          LSR.l #8,d0
          MOVE.l d0,d7
          AND.l #%11111111,d7 : MULU.l d1,d7
          ADD.l d3,d7
          AND.l #%1111111100000000,d7


          OR.l d7,d6

          LSR.l #8,d0
          AND.l #%11111111,d0 : MULU.l d1,d0
          ADD.l d2,d0
          AND.l #%1111111100000000,d0
          LSL.l #8,d0
          OR.l d0,d6

          ;LSL.l #8,d6 ; add alpha

          MOVE.l  d6,(a1)+

          SUB.l #1,d5
          BGT fadeloop
          MOVE.l  (a7)+,d7
          sourceaddr+sourcebpr
          destaddr  +destbpr
        Next
        WritePixelArray_ tmpptr,0,0,dbpr,rp_d,x1,y1,blitwidth,blitheight,#RECTFMT_ARGB
      End If
    End If
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_begin_blit                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_begin_blit

  For i.l = y1 To y2
    sourceaddr.l = saddr + sbpr * Int(yoff/#image_scaleres+\clip_y)  + xoff*4
    ;;alphaaddr.l = alphabaseaddr + alphabpr * Int(yoff/#image_scaleres)  + xoff
    ;GetRegD0 blitwidth-1 :MOVE.l d0,d1
    ;GetRegD0 sourceaddr  :MOVE.l d0,a0
    ;GetRegD0 daddr       :MOVE.l d0,a1
    ;;GetRegD0 alphaaddr   :MOVE.l d0,a3
    ;GetRegD0 xscale      :MOVE.l d0,d4
    ;GetRegD0 konto       :MOVE.l d0,d5

    GetReg d1,blitwidth-1
    GetReg a0,sourceaddr
    GetReg a1,daddr
    ;Getreg a3,alphaaddr
    GetReg d4,xscale
    GetReg d5,konto
    all_blit`1
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_begin_blit_ealpha                                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_begin_blit_ealpha

  For i.l = y1 To y2
    sourceaddr.l = saddr + sbpr * Int(yoff/#image_scaleres+\clip_y) + xoff*4
    alphaaddr.l  = alpha_ptr + alpha_bpr * Int(yoff/#image_scaleres) + xoff-\clip_x
    ;GetRegD0 blitwidth-1 :MOVE.l d0,d1
    ;GetRegD0 sourceaddr  :MOVE.l d0,a0
    ;GetRegD0 daddr       :MOVE.l d0,a1
    ;GetRegD0 alphaaddr   :MOVE.l d0,a3
    ;GetRegD0 xscale      :MOVE.l d0,d4
    ;GetRegD0 konto       :MOVE.l d0,d5
    GetReg d1,blitwidth-1
    GetReg a0,sourceaddr
    GetReg a1,daddr
    GetReg a3,alphaaddr
    GetReg d4,xscale
    GetReg d5,konto
    all_e_blit`1
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_begin_blitmask                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_begin_blitmask

  For i.l = y1 To y2
    sourceaddr.l = saddr + sbpr * Int(yoff/#image_scaleres+\clip_y) + xoff*4
    ;alphaaddr.l = alphabaseaddr + alphabpr * Int(yoff/#image_scaleres)  + xoff
    maskaddr.l   = maskbaseaddr   + maskbpr   * Int(yoff/#image_scaleres+\clip_y) + Int(xoff/16)*2
    ;GetRegD0 blitwidth-1 :MOVE.l d0,d1
    ;GetRegD0 sourceaddr  :MOVE.l d0,a0
    ;GetRegD0 daddr       :MOVE.l d0,a1
    ;GetRegD0 maskaddr    :MOVE.l d0,a2
    ;GetRegD0 alphaaddr   :MOVE.l d0,a3
    ;GetRegD0 maskoff     :MOVE.l d0,d3
    ;GetRegD0 xscale      :MOVE.l d0,d4
    ;GetRegD0 konto       :MOVE.l d0,d5

    GetReg d1,blitwidth-1
    GetReg a0,sourceaddr
    GetReg a1,daddr
    GetReg a2,maskaddr
    ;GetReg a3,alphaaddr
    GetReg d3,maskoff
    GetReg d4,xscale
    GetReg d5,konto

    MOVE.w (a2)+,d2  ; mask
    allmask_blit`1
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_end_blit                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_end_blit

    yoff + yscale
    daddr + dbpr
  Next
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_read_bg                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_read_bg

  ReadPixelArray_ tmpbuffer,0,0,dbpr,*rp,x1,y1,blitwidth,blitheight,#RECTFMT_ARGB
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_FancyBlit{image.l,x.l,y.l,@xs.l,@ys.l,@*rp.RastPort,@mode.::  /
;/ l,@density.l,@alpha_ptr.l,@alpha_bpr.l}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Blits an image using CPU in different blitmodes, scaled and with mask if :: /
;/ available.                                                                  /
;/ Note: This works only on GFX cards with 16, 24 or 32bit color depth, no c:: /
;/ olor indexed screens are supported.                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l : image object ID                                                 /
;/ - x.l     : x position                                                      /
;/ - y.l     : y position                                                      /
;/ - xs.l    : xs destination width                                            /
;/ - ys.l    : ys destination height                                           /
;/ - *rp     : optional a ratport where to blit, otherwise it is blitted to :: /
;/ the used window                                                             /
;/ - mode.l  : one of                                                          /
;/     #image_blitmode_opaque  = normal blitting, with mask if present         /
;/     #image_blitmode_trans   = transparent blitting according denity         /
;/     #image_blitmode_alpha   = normal blit with mask & alpha if present      /
;/     #image_blitmode_add     = pixels are added to the background            /
;/     #image_blitmode_sub     = pixels are substracted from the bg            /
;/     #image_blitmode_mul     = pixels are multiplied with the bg             /
;/ - density.l : 0-256, mix value for trans, add, sub and mul blitting modes   /
;/ - alpha_ptr.l    : pointer to an external 8-bit alpha channel               /
;/ - alpha_bpr.l    : bytes per row of external alpha channel                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_FancyBlit{image.l,x.l,y.l,@xs.l,@ys.l,@*rp.RastPort,@mode.l,@density.l,@alpha_ptr.l,@alpha_bpr.l}
SHARED imagedat(),imgargs(),imageengine

  USEPATH imagedat(image)
  If *rp = -1 AND Used Window >= 0 Then *rp = RastPort(Used Window)

  If \raw_ptr >< False AND *rp >< 0 AND *rp>< -1

    dd.l = GetBitMapAttr_(*rp\BitMap,#BMA_DEPTH)
    If dd <= 8 Then Statement Return

    If density < 0 Then density = 256

    bltw.l = \clip_xs
    blth.l = \clip_ys

    If xs < 0 Then xs = bltw ;\img_width
    If ys < 0 Then ys = blth ;\img_height

    If xs > 0 AND ys > 0
    maskbaseaddr.l = \mask_ptr
    If alpha_ptr = -1 Then alpha_ptr = 0
    If \alpha_isused = 0 AND alpha_ptr = 0 AND (mode = #image_blitmode_alpha OR mode = #image_blitmode_invalpha) Then If density = 256 Then mode = #image_blitmode_opaque : Else mode = #image_blitmode_trans

    maskbpr.l = \mask_bpr
    xscale.l  = (#image_scaleres * bltw ) / xs
    yscale.l  = (#image_scaleres * blth ) / ys
    xoff.l    = 0 ;\clip_x1
    yoff.l    = 0 ;\clip_y1
    !image_GetClipBounds{*rp,minx.l,miny.l,maxx.l,maxy.l}

    x1.l =  x - (\handle_x  *#image_scaleres/xscale) ;+ minx
    y1.l =  y - (\handle_y  *#image_scaleres/yscale) ;+ miny
    x2.l = x1 + (bltw *#image_scaleres/xscale)-1
    y2.l = y1 + (blth *#image_scaleres/yscale)-1
    If x1 < minx Then xoff+(minx-x1)*xscale : x1 = minx
    If y1 < miny Then yoff+(miny-y1)*yscale : y1 = miny
    If x2 >= maxx Then x2 = maxx
    If y2 >= maxy Then y2 = maxy
    blitwidth.l  = x2-x1+1
    blitheight.l = y2-y1+1
    If blitwidth <= 0 OR blitheight <= 0 Then Statement Return

    konto.l = #image_scaleres-(xoff MOD #image_scaleres) - xscale/2

    xoff/#image_scaleres
    yoff+yscale/2
    xoff + \clip_x

    dbpr.l      = blitwidth * 4
    saddr.l     = \raw_ptr
    sbpr.l      = \bpr
    tmpbuffer.l = tempbuffer_Get{blitwidth*blitheight*4}
    daddr.l     = tmpbuffer
    maskoff.l   = 15 - (xoff MOD 16)
    ;WLocate 20,20
    ;NPrint "Fancyblit: ",x1,"/",y1," - ",blitwidth,"x"+Str$(blitheight)+"! Clipbound:"+Str$(minx)+"/"+Str$(maxx)+"..."+Str$(miny)+"/"+Str$(maxy)
    If saddr >< 0 AND tmpbuffer >< 0
    Poke.l ?bd,density
    If blitwidth > 0 AND blitheight > 0
      ;RunErrsOff
      Select mode
        Case #image_blitmode_trans
          !image_read_bg
          If maskbaseaddr
            !image_begin_blitmask{_trans}
            !image_trans_mask_32
            !image_end_blit
          Else
            !image_begin_blit{_trans}
            !image_trans_32
            !image_end_blit
          End If

        Case #image_blitmode_add
          !image_read_bg
          If maskbaseaddr
            !image_begin_blitmask{_add}
            !image_add_mask_32
            !image_end_blit
          Else
            !image_begin_blit{_add}
            !image_add_32
            !image_end_blit
          End If

        Case #image_blitmode_mul
          !image_read_bg
          If maskbaseaddr
            !image_begin_blitmask{_mul}
            !image_mul_mask_32
            !image_end_blit
          Else
            !image_begin_blit{_mul}
            !image_mul_32
            !image_end_blit
          End If

        Case #image_blitmode_sub
          !image_read_bg
          If maskbaseaddr
            !image_begin_blitmask{_sub}
            !image_sub_mask_32
            !image_end_blit
          Else
            !image_begin_blit{_sub}
            !image_sub_32
            !image_end_blit
          End If

        Case #image_blitmode_suba
          !image_read_bg
          !image_begin_blit{_suba}
          !image_suba_32
          !image_end_blit

        Case #image_blitmode_alpha   ; alpha is not combined with bit mask, we trust the alpha
          !image_read_bg
          If alpha_ptr = 0
            If (density = 255 OR density = 256) AND xs = bltw AND ys = blth
            !image_begin_blit{_alphafix}
            !image_alpha_own_32_fix
            !image_end_blit
            Else
            !image_begin_blit{_alpha}
            !image_alpha_own_32
            !image_end_blit
            End If
          Else
            If \alpha_isused
              !image_begin_blit_ealpha{_ealpha_own}
              !image_external_alpha_own_32
              !image_end_blit
            Else
              !image_begin_blit_ealpha{_ealpha}
              !image_external_alpha_32
              !image_end_blit
            End If
          End If

        Case #image_blitmode_alphaadd   ; alpha is not combined with bit mask, we trust the alpha
          !image_read_bg
          !image_begin_blit{_alphaaddfix}
          !image_alphaadd_own_32_fix
          !image_end_blit

        Case #image_blitmode_invalpha   ; alpha is not combined with bit mask, we trust the alpha
          !image_read_bg
          If alpha_ptr = 0
            !image_begin_blit{_ialpha}
            !image_invalpha_own_32
            !image_end_blit
          Else
            If \alpha_isused
              !image_begin_blit_ealpha{_iealpha_own}
              !image_invexternal_alpha_own_32
              !image_end_blit
            Else
              !image_begin_blit_ealpha{_iealpha}
              !image_invexternal_alpha_32
              !image_end_blit
            End If
          End If

        Default ; image_blitmode_opaque
          If maskbaseaddr
            !image_read_bg
            !image_begin_blitmask{_opaque}
            !image_opaque_mask_32
            !image_end_blit
          Else
            !image_begin_blit{_opaque}
            !image_opaque_32
            !image_end_blit
          End If
      End Select
      WritePixelArray_ tmpbuffer,0,0,dbpr,*rp,x1,y1,blitwidth,blitheight,#RECTFMT_ARGB
      ;LastRunErrsMode
   ; Else
    ;  error{"blitwidth<0 Nothing to blit !"}
    End If
  ;  Else
   ;   error{"Some pointers are 0 !"}
    End If
  ;  Else
   ;   error{"Size is <0"}
    End If
  Else
    If \raw_ptr = 0
      error{"\\__THIS_FUNCTION: Tried to blit a non-existing image ("+Str$(image)+")!"}
    Else
      error{"\\__THIS_FUNCTION: Uninitialized rastport/window/screen!"}
    End If
  End If
  Statement Return
  bd:
  Dc.l 0
  _dR:
  Dc.l 0
  _dG:
  Dc.l 0
  _dB:
  Dc.l 0
  _sR: ; g
  Dc.l 0
  _sG: ; r
  Dc.l 0
  _sB: ; b
  Dc.l 0
  _A:
  Dc.l 0
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_TextureTriBlit{image.l,*coos.texturearray,@*rp.RastPort}      /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - *coos.texturearray    : ???                                               /
;/ - *rp.RastPort    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_TextureTriBlit{image.l,*coos.texturearray,@*rp.RastPort}
SHARED imagedat(),imgargs(),imageengine

  USEPATH imagedat(image)
  If *rp = -1 AND Used Window >= 0 Then *rp = RastPort(Used Window)

  If *rp >< 0 AND *rp >< -1 AND \raw_ptr >< 0
      src_bpr.l   = \bpr
      src_base.l  = \raw_ptr + \bpr * \clip_y + \bpp * \clip_x
      src_w.f     = \clip_xs
      src_h.f     = \clip_ys
      !image_GetClipBounds{*rp,minx.l,miny.l,maxx.l,maxy.l}

      x1.l = *coos\x1
      x2.l = x1 + src_w ;*coos\x2
      x3.l = x2 ;*coos\x3
      x4.l = x1 ; *coos\x4
      y1.l = *coos\y1
      y2.l = *coos\y2
      y3.l = *coos\y3
      y4.l = *coos\y4

      x5.l = (x1+x2+x3+x4)/4
      y5.l = (y1+y2+y3+y4)/4

      SetAPen_ *rp,2
        Move_ *rp,x1, y1 : Draw_ *rp,x5,y5
        Move_ *rp,x2 ,y2 : Draw_ *rp,x5,y5
        Move_ *rp,x3 ,y3 : Draw_ *rp,x5,y5
        Move_ *rp,x4 ,y4 : Draw_ *rp,x5,y5

        SetAPen_ *rp,1
        Move_ *rp,x1 ,y1 : Draw_ *rp,x2,y2
        Move_ *rp,x1, y1 : Draw_ *rp,x4,y4
        Move_ *rp,x2 ,y2 : Draw_ *rp,x3,y3
        Move_ *rp,x3, y3 : Draw_ *rp,x4,y4

        ty.l = Min(Min(Min(y1,y2),y3),y4)
        by.l = Max(Max(Max(y1,y2),y3),y4)

        lx.l = Min(Min(Min(x1,x2),x3),x4)
        rx.l = Max(Max(Max(x1,x2),x3),x4)

        blitwidth.l = rx-lx+1
        tmp_ptr.l = tempbuffer_Get{blitwidth*4}

        x5.l = (x1+x2+x3+x4)/4 ; not correct, but anyway...
        y5.l = (y1+y2+y3+y4)/4

        dst_hl.f = y4-y1
        dst_hr.f = y3-y2

        dst_split_x.f = x5-lx
        dst_split_y.f = y5-ty

        r_l.f = dst_hl / src_h
        r_r.f = dst_hr / src_h

        ; 1 .Triangle
        If y1 > y5
          typ.l = 0 ; UP
        Else
          If y4 < y5
            typ.l = 1 ; DOWN
          Else
            typ.l = 2 ; MID
          End If
        End If
        ;///////////////////////////////////////////////////////////////////////////////
        ;/                                                                             /
        ;/ Syntax: !image_triblit_left                                                 /
        ;/                                                                             /
        ;/ Description:                                                                /
        ;/ * no description available *                                                /
        ;/                                                                             /
        ;///////////////////////////////////////////////////////////////////////////////
        Macro image_triblit_left
          For dst_y.l = fromy To toy
            src_y.f + src_dy
            dst_w.f + dst_dw
            dst_ptr.l = tmp_ptr
            src_x.l = 0
            For dest_x.l = lx To lx+dst_w-1
              src_ptr.l = src_base + Int(src_y)*src_bpr+src_x : src_x+4
              ARGB.l = Peek.l(src_ptr)
              Poke.l dst_ptr,ARGB       : dst_ptr+4
            Next
            WritePixelArray_ tmp_ptr,0,0,4096,*rp,x1,dst_y,dst_w,1,#RECTFMT_ARGB
          Next
        End Macro
        ; 1. left triangle
        Select typ
          Case 2 ; MID
            src_dy.f    = 1 / r_r
            src_y.f     = 0
            dst_bw.f    = x5-lx
            dst_w.f     = 0
            dst_dw.f    = dst_bw / dst_split_y
            fromy.l     = y1 : toy.l = y1+dst_split_y
            !image_triblit_left
            dst_dw.f    = -dst_bw / (dst_hl-dst_split_y)
            fromy.l     = toy+1 : toy = y4
            !image_triblit_left
          Default
            error{"\\__THIS_FUNCTION: Typ not implemented! "+Str$(typ)}
       End Select

        ;///////////////////////////////////////////////////////////////////////////////
        ;/                                                                             /
        ;/ Syntax: !image_triblit_right                                                /
        ;/                                                                             /
        ;/ Description:                                                                /
        ;/ * no description available *                                                /
        ;/                                                                             /
        ;///////////////////////////////////////////////////////////////////////////////
        Macro image_triblit_right
          For dst_y.l = fromy To toy
            src_y.f + src_dy
            dst_w.f + dst_dw
            dst_ptr.l = tmp_ptr
            src_x.l   = 0
            For dest_x.l = lx To lx+dst_w-1
              src_ptr.l = src_base + Int(src_y)*src_bpr+src_x : src_x+4
              ARGB.l    = Peek.l(src_ptr)
              Poke.l dst_ptr,ARGB : dst_ptr+4
            Next
            WritePixelArray_ tmp_ptr,0,0,4096,*rp,x1,dst_y,dst_w,1,#RECTFMT_ARGB
          Next
        End Macro
        ; 1. right triangle
        Select typ
          Case 2 ; MID
            src_dy.f    = 1 / r_l
            src_y.f     = 0
            dst_bw.f    = rx - x5
            dst_w.f     = 0
            dst_dw.f    = dst_bw / dst_split_y
            fromy.l     = y1 : toy.l = y1+dst_split_y
            !image_triblit_right
            dst_bw.f    = rx - x5
            dst_dw.f    = -dst_bw / (dst_hl-dst_split_y)
            fromy.l     = toy+1 : toy = y4
            !image_triblit_right
          Default
            error{"\\__THIS_FUNCTION: Typ not implemented! "+Str$(typ)}
       End Select
  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_CPUBlitScaled{image.l,x.l,y.l,@xs.l,@ys.l,@*rp.RastPort}      /
;/                                                                             /
;/ Description:                                                                /
;/ Same like image_CPUBlit, but scaled to xs/ys.                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object ID                                              /
;/ - x.l    : x position                                                       /
;/ - y.l    : y position                                                       /
;/ - xs.l    : target width                                                    /
;/ - ys.l    : target height                                                   /
;/ - rp.l    : optional rastport to blit into                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_CPUBlitScaled{image.l,x.l,y.l,@xs.l,@ys.l,@*rp.RastPort}
SHARED imagedat()

  USEPATH imagedat(image)
  If \bitmap_ptr=False Then image_InitBitMap{image}
  If *rp = -1 AND Used Window >= 0 Then *rp = RastPort(Used Window)

  If xs < 1 Then xs = \img_width
  If ys < 1 Then ys = \img_height * xs / \img_width

  If xs <= 0 OR ys <= 0 Then Statement Return

  If \bitmap_ptr >< False AND *rp >< 0 AND *rp >< -1

    ;*rp.RastPort = rp
    tag5.tag5\ti_Tag = #LBMI_BASEADDRESS,&destbaseaddr.l  ,#LBMI_BYTESPERROW,&destbpr.l,#TAG_DONE,0
    *hand.l          = LockBitMapTagList_(*rp\BitMap ,tag5) : If *hand Then UnLockBitMap_ *hand
    tag5.tag5\ti_Tag = #LBMI_BASEADDRESS,&sourcebaseaddr.l,#LBMI_BYTESPERROW,&sourcebpr.l,#LBMI_BYTESPERPIX,&pixelsize.l ,#TAG_DONE,0
    *hand            = LockBitMapTagList_(\bitmap_ptr,tag5) : If *hand Then UnLockBitMap_ *hand
    maskbaseaddr.l   = \mask_ptr
    maskbpr.l        = \mask_bpr ;((\img_width+15) LSR 4) ASL 1

    xscale.l = (#image_scaleres * \img_width ) / xs
    yscale.l = (#image_scaleres * \img_height) / ys
    xoff.l   = 0
    yoff.l   = 0

    !image_GetClipBounds{*rp,minx.l,miny.l,maxx.l,maxy.l}

    x1.l =  x - (\handle_x  *#image_scaleres/xscale) ;+ minx
    y1.l =  y - (\handle_y  *#image_scaleres/yscale) ;+ miny
    x2.l = x1 + (\img_width *#image_scaleres/xscale)-1
    y2.l = y1 + (\img_height*#image_scaleres/yscale)-1
    If x1 < minx Then xoff+(minx-x1)*xscale : x1 = minx
    If y1 < miny Then yoff+(miny-y1)*yscale : y1 = miny

    konto.l = #image_scaleres-(xoff MOD #image_scaleres) - xscale/2

    xoff/#image_scaleres
    yoff+yscale/2

    If x2 > maxx Then x2 = maxx
    If y2 > maxy Then y2 = maxy
    blitwidth.l = x2-x1+1

  ;  blitheight.l = y2-y1+1
  ;  WLocate 20,20
  ;  NPrint "CPUblitScaled: ",x1,"/",y1," - ",blitwidth,"x",blitheight,"! Clipbound:"+Str$(minx)+"/"+Str$(maxx)+"..."+Str$(miny)+"/"+Str$(maxy)

    !image_GetLayerOffset{*rp,lxoff.l,lyoff.l}
    x1 + lxoff : x2 + lxoff
    y1 + lyoff : y2 + lyoff

    If blitwidth > 0
      blitwidth-1
      destaddr.l = destbaseaddr + destbpr *y1 + x1 *pixelsize
      RunErrsOff

      If \mask_isused
        maskoff.l = 15 - (xoff MOD 16)
        If xs = \img_width AND ys = \img_height
          image_BlitMask{image,x,y,*rp}
        Else
          !image_cpublit_mask_scale_opaque
        End If
      Else
        If xs = \img_width AND ys = \img_height
          image_Blit{image,x,y,*rp}
        Else
          !image_cpublit_scale_opaque
        End If
      End If
      LastRunErrsMode
    End If
  Else
    error{"\\__THIS_FUNCTION: Uninitialized image bmap/window/screen!"}
  End If
End Statement


CNIF #__include=0
image_inlcude_test:
WbToScreen 0 ; we need to use a screen
NoCli
;*cmap.cmap = cmap_CreateRGB8{}
;*cmap.cmap = cmap_CreateBlackWhite{}
;*cmap.cmap = cmap_CreateGrayScale{}
;*cmap.cmap = cmap_Load{"Workbench:Programme/PPaint/Colors/Spectrum256.col"}
;cmap_Save{*cmap,"ram:colmap.iff"}
;*cmap.cmap = cmap_GrabFromScreen{}
XINCLUDE "screen.include.ab3"

;If screen_Open{"MyScreen",#scr_mode_wb_use}
If screen_Open{"MyScreen",#scr_mode_ask}
  ;cmap_PutToScreen{*cmap}
  *scr.Screen = Peek.l(Addr Screen(0))
  Window 0,0,0,800,600,$E,"image.include test",1,2
  succ.l = -1

  succ & image_Load{ 2,"/Data/AlphaBlit.png"} : image_MidHandle{2}
  ;succ   & image_Load{ 2,"/Data/ic_action_star.png"}    :  image_MidHandle{2}
  ;succ   & image_Load{ 2,"sys:disk.info"}    :  image_MidHandle{2}
  succ & image_Load{20,"/Data/AlphaBlit_ea.iff"} :  image_MidHandle{20}
  If succ
    DEFTYPE.texturearray tbcoo
    tbcoo\x1 = 100
    tbcoo\y1 = 100
    tbcoo\x2 = 210
    tbcoo\y2 = 110
    tbcoo\x3 = 220
    tbcoo\y3 = 220
    tbcoo\x4 = 130
    tbcoo\y4 = 230

    image_CreateAlpha{20,0,255}

    alpha_ptr.l = AllocMem(image_GetWidth{20}*image_GetHeight{20}*1,#MEMF_CLEAR)
    alpha_bpr.l = image_GetWidth{20}
    image_ExtractAlpha{20,alpha_ptr,alpha_bpr}

    g1.l   = 128-24
    g2.l   = 128+24
    s.l    = 8
    apen.l = screen_GetPenRGB{g1|g1 LSL 8|g1 LSL 16}
    bpen.l = screen_GetPenRGB{g2|g2 LSL 8|g2 LSL 16}

    For x.l = 0 To InnerWidth/s-1
      For y.l = 0 To InnerHeight/s-1
        If (x+y) MOD 2 Then pen.l = apen : Else pen = bpen
        WBox x*s+WLeftOff,y*s+WTopOff,x*s+s-1+WLeftOff,y*s+s-1+WTopOff,pen
      Next
    Next
    eclock_Start{1000}

    image_SetDitherMode{2,#image_dithermode_err}
    #bfally = 25+50
    WLocate WLeftOff,#bfally-70 : NPrint "blit functions that work on all GFX card screens:"
    image_Blit       {2, 50,#bfally}                 : WLocate 50,#bfally : Print "Blit"
    ;image_InitMask   {2,$6A4C30,30,64}
    image_InitMask   {2,-1,30,64}
    image_BlitMask   {2,150,#bfally}                 : WLocate 150,#bfally : Print "BlitMask"
    image_BlitPattern{2,250-35,#bfally-25,70,70,5,5} : WLocate 250,#bfally : Print "BlitPattern+M"
    image_BlitArea   {2,350,#bfally,35,35,5,5}       : WLocate 350,#bfally : Print "BlitArea+M"
    image_BlitScaled {2,450,#bfally,90,40}           : WLocate 450,#bfally : Print "BlitScaled"
    image_CPUBlit    {2,550,#bfally}                 : WLocate 550,#bfally : Print "CPUBlit+M"
    image_CPUBlitScaled{2,650,#bfally,90,40}         : WLocate 650,#bfally : Print "CPUBlitScaled+M"
    image_TwoThird{9,2}
    #bf241y = 115+50
    WLocate WLeftOff,#bf241y-70 : NPrint "FancyBlit (works only on 16/24bit, all can be scaled), without mask:"
    image_FreeMask{2}

    image_FancyBlit{2, 50,#bf241y,-1,-1,-1,#image_blitmode_alpha,256}    : WLocate 50,#bf241y : Print "Alpha"
    image_FancyBlit{2,150,#bf241y,-1,-1,-1,#image_blitmode_add,150}      : WLocate 150,#bf241y : Print "Add"
    image_FancyBlit{2,250,#bf241y,-1,-1,-1,#image_blitmode_suba,150}     : WLocate 250,#bf241y : Print "Sub"
    image_FancyBlit{2,350,#bf241y,-1,-1,-1,#image_blitmode_trans,150}    : WLocate 350,#bf241y : Print "Trans"
    image_FancyBlit{2,450,#bf241y,-1,-1,-1,#image_blitmode_opaque,150}   : WLocate 450,#bf241y : Print "Opaque"
    image_FancyBlit{2,550,#bf241y,-1,-1,-1,#image_blitmode_mul,150}      : WLocate 550,#bf241y : Print "Mul"
    image_FancyBlit{2,650,#bf241y,-1,-1,-1,#image_blitmode_invalpha,256} : WLocate 650,#bf241y : Print "InvAlpha"
    image_FancyBlit{9,750,#bf241y,-1,-1,-1,#image_blitmode_alpha,256}    : WLocate 750,#bf241y : Print "Half"

    ;Goto alphatest
    #bf242y = 205+50
    WLocate WLeftOff,#bf242y-70 : NPrint "FancyBlit (works only on 16/24bit, all can be scaled), with mask:"
    image_InitMask{2,-1,30,64}
    *rp.RastPort = image_GetRPPtr{2}
    image_FancyBlit{2, 50,#bf242y,-1,-1,-1,#image_blitmode_alpha,256}  : WLocate 50,#bf242y : Print "Alpha +M"
    image_FancyBlit{2,150,#bf242y,-1,-1,-1,#image_blitmode_add,150}    : WLocate 150,#bf242y : Print "Add +M"
    image_FancyBlit{2,250,#bf242y,-1,-1,-1,#image_blitmode_sub,150}    : WLocate 250,#bf242y : Print "Sub +M"
    image_FancyBlit{2,350,#bf242y,-1,-1,-1,#image_blitmode_trans,150}  : WLocate 350,#bf242y : Print "Trans +M"
    image_FancyBlit{2,450,#bf242y,-1,-1,-1,#image_blitmode_opaque,150} : WLocate 450,#bf242y : Print "Opaque +M"
    image_FancyBlit{2,550,#bf242y,-1,-1,-1,#image_blitmode_mul,150}    : WLocate 550,#bf242y : Print "Mul +M"
    image_FancyBlit{2,650,#bf242y,-1,-1,-1,#image_blitmode_alpha,256,alpha_ptr,alpha_bpr}
    image_Blit{20,750,#bf242y}                                         : WLocate 650,#bf242y : Print "external Alpha"
    #bf243y = 295+50
    WLocate WLeftOff,#bf243y-70 : NPrint "exotic blitting functions, mostly 16/24bit only:"
    image_RotateBlit{2,50,#bf243y,Pi/4,1.0,False}                      : WLocate 50,#bf243y : Print "RotateBlit"
    image_Create{3,image_GetWidth{2}+6,image_GetHeight{2}+6,False,$0}
    *irp.RastPort = image_GetRPPtr{3}
    image_RotateBlit{2,image_GetWidth{3}/2,image_GetHeight{3}/2,Pi/4,1.0,False,*irp}
    imagedat(3)\alpha_isused = -1
    image_MidHandle{3}
    image_FancyBlit{3,250,#bf243y,-1,-1,-1,#image_blitmode_alpha ,256} : WLocate 250,#bf243y : Print "Rot+Alpha"
    image_InitMask{3,-1,30,64}
    image_BlitMask{3,150,#bf243y}                                      : WLocate 150,#bf243y : Print "Rot+BlitMask"
    coos.texturearray\x1 = 350-20,#bf243y-30
    coos.texturearray\x2 = 350+10,#bf243y-40
    coos.texturearray\x3 = 350+40,#bf243y+30
    coos.texturearray\x4 = 350-30,#bf243y+20
    image_TextureBlit{2,coos,-1,-1,False}                              : WLocate 350,#bf243y : Print "TextureBlit"

    image_DrawScaled{2,450,#bf243y,90,40,-1}                           : WLocate 450,#bf243y : Print "DrawScaled"
    image_DrawScaled{2,550,#bf243y,90,40,-1, 1.0}                      : WLocate 550,#bf243y : Print "DrawScaled +I"
    ;image_DrawScaled{2,650,#bf243y,90,60,-1,1.0} : WLocate 650,#bf243y : Print "DrawScaled"

    If ask{"Do you want further tests with Save and Load?","No|Yes"}
      Goto skipall  ; to skip the rest of the tests
    EndIf

    USEPATH imagedat(2)
    ;image_FilterDelta32{\raw_ptr,\bpr,\raw_ptr,\bpr,\img_width,\img_height}
    ;image_UnfilterDelta32{\raw_ptr,\bpr,\raw_ptr,\bpr,\img_width,\img_height}
    #bf244y = 385+50
    WLocate WLeftOff,#bf244y-70 : NPrint "save image and reload from saved files (incl. Alpha channel except JPEG):"
    image_FreeMask{2}
    image_SetDitherMode{2,#image_dithermode_none}
    ;image_InitMask   {2,$6A4C30,30,64}

    succ.l = image_Save{2,"RAM:testpic.iff"     ,@"ILBM",True}               ; internal IFF-ILBM
    succ   = image_Save{2,"RAM:testpic.ab2i"    ,@"AB2I",True}               ; AB2I
    succ   = image_Save{2,"RAM:testpic_nc.ab2i" ,@"AB2I",False}              ; AB2I without compression
    succ   = image_Save{2,"RAM:testpic_nc.iff"  ,@"ILBM",False}              ; internal IFF-ILBM without compression
    succ   = image_Save{2,"RAM:testpic.png"     ,@"PNG" ,9}                  ; PNG (ab3support.library required)
    succ   = image_Save{2,"RAM:testpic.jpg"     ,@"JPEG",20}                 ; JPEG (jpeg.library required)
    succ   = image_Save{2,"RAM:testpic.ab3i"    ,@"AB3I",True,#image_sf_YUV} ; AB3I high compression
    succ   = image_Save{2,"RAM:testpic_nc.ab3i" ,@"AB3I",0}                  ; AB3I no compression
    ;succ   = image_Save{2,"RAM:testpic_DT.iff"  ,@"IFFD"}                    ; save via Datatype
    succ   = image_Save{2,"RAM:testpic.bmp"     ,@"BMP"}                     ; save via Datatype

    ;End

    ;ScalePixelArray_ image_GetARGBPtr{2},image_GetWidth{2},image_GetHeight{2},image_GetARGBBpr{2},RastPort,WLeftOff,WTopOff,100,100,#RECTFMT_ARGB
    Format "#0.0"
    image_Load{5,"RAM:testpic.ab3i"}    : image_MidHandle{5} :fs.l= dos_GetFileSize{"RAM:testpic.ab3i"}   /1024
    image_FancyBlit{5, 50,#bf244y,-1,-1,-1,#image_blitmode_alpha} : WLocate 50,#bf244y : Print "AB3I"     :  WLocate  50,#bf244y-50 : Print fs,"kB"
    image_Load{5,"RAM:testpic_nc.ab3i"} : image_MidHandle{5} : fs = dos_GetFileSize{"RAM:testpic_nc.ab3i"}/1024
    image_FancyBlit{5,150,#bf244y,-1,-1,-1,#image_blitmode_alpha} : WLocate 150,#bf244y : Print "AB3I nc" :  WLocate 150,#bf244y-50 : Print fs,"kB"
    image_Load{5,"RAM:testpic.iff"}     : image_MidHandle{5} : fs = dos_GetFileSize{"RAM:testpic.iff"}  /1024
    image_FancyBlit{5,250,#bf244y,-1,-1,-1,#image_blitmode_alpha} : WLocate 250,#bf244y : Print "ILBM"    :  WLocate 250,#bf244y-50 : Print fs,"kB"
    image_Load{5,"RAM:testpic_nc.iff"}  : image_MidHandle{5} : fs = dos_GetFileSize{"RAM:testpic_nc.iff"} /1024
    image_FancyBlit{5,350,#bf244y,-1,-1,-1,#image_blitmode_alpha} : WLocate 350,#bf244y : Print "ILBM nc" :  WLocate 350,#bf244y-50 : Print fs,"kB"
    image_Load{5,"RAM:testpic.png"}     : image_MidHandle{5} : fs = dos_GetFileSize{"RAM:testpic.png"}    /1024
    image_FancyBlit{5,450,#bf244y,-1,-1,-1,#image_blitmode_alpha} : WLocate 450,#bf244y : Print "PNG"     :  WLocate 450,#bf244y-50 : Print fs,"kB"
    image_Load{5,"RAM:testpic.jpg"}     : image_MidHandle{5} : fs = dos_GetFileSize{"RAM:testpic.jpg"}    /1024
    image_FancyBlit{5,550,#bf244y,-1,-1,-1,#image_blitmode_alpha} : WLocate 550,#bf244y : Print "JPEG(no alpha)" :  WLocate 550,#bf244y-50 : Print fs,"kB"
    image_Load{5,"RAM:testpic.bmp"}     : image_MidHandle{5} : fs = dos_GetFileSize{"RAM:testpic.bmp"}    /1024
    image_FancyBlit{5,650,#bf244y,-1,-1,-1,#image_blitmode_alpha} : WLocate 650,#bf244y : Print "BMP"     :  WLocate 650,#bf244y-50 : Print fs,"kB"

    If ask{"Do you want further tests with interpolation?","No|Yes"}
      Goto skipall  ; to skip the rest of the tests
    EndIf

    succ   & image_Load{5,"/Data/testpic.png"} : xs.l = 160 : ys.l = 100
    image_Resize{1,5,xs,ys,#image_interpol_none  , 0  }     : image_Save{1,"ram:downscale_nn.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_linear, 0  }     : image_Save{1,"ram:downscale_linear.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_gui   , 0.5}     : image_Save{1,"ram:downscale_gui05.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_cubic , 0  }     : image_Save{1,"ram:downscale_cubic.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_cos   , 0  }     : image_Save{1,"ram:downscale_cos.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_window, 0.1 }    : image_Save{1,"ram:downscale_win01.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_window, 0.25}    : image_Save{1,"ram:downscale_win025.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_window, 0.5 }    : image_Save{1,"ram:downscale_win05.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_window, 0.75}    : image_Save{1,"ram:downscale_win075.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_window, 1   }    : image_Save{1,"ram:downscale_win1.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_window, 0  }     : image_Save{1,"ram:downscale_window.png",@"PNG"}
    image_Resize{2,5,xs*2,ys*2,#image_interpol_window, 0  }
    image_Resize{1,2,xs,ys,#image_interpol_cubic , 0  }     : image_Save{1,"ram:downscale_cubic_aa.png",@"PNG"}
    image_Resize{2,5,xs*2,ys*2,#image_interpol_window, .5  }
    image_Resize{1,2,xs,ys,#image_interpol_cubic , 0  }     : image_Save{1,"ram:downscale_cubic_aa05.png",@"PNG"}

    For p.l = 300 To 100 Step -100
      image_Resize{2,5,160*p/100,100*p/100,#image_interpol_cubic, 0  }
      image_Cut{5,2}
    Next
    image_Save{2,"ram:downscale_cubic_ss.png",@"PNG"}

    ;succ   & image_Load{5,"/Data/interpoltest.png"}
    image_Resize{1,5,160,100,#image_interpol_window, 0  }

    image_Cut{5,1} : xs.l = 512 : ys.l = 320
    image_Resize{1,5,xs,ys,#image_interpol_none  , 0  }  : image_Save{1,"ram:upscale_nn.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_linear, 0  }  : image_Save{1,"ram:upscale_linear.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_window, 0  }  : image_Save{1,"ram:upscale_window.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_gui   , 0.5}  : image_Save{1,"ram:upscale_gui05.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_cubic , 0  }  : image_Save{1,"ram:upscale_cubic.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_cos   , 0  }  : image_Save{1,"ram:upscale_cos.png",@"PNG"}
    image_Resize{1,5,xs,ys,#image_interpol_window, 0.5}  : image_Save{1,"ram:upscale_win05.png",@"PNG"}

    image_Resize{1,5,256,160,#image_interpol_cubic, 0  }
    image_Cut{5,1}
    image_Resize{1,5,320,200,#image_interpol_cubic, 0  }
    image_Cut{5,1}
    image_Resize{1,5,xs,ys,#image_interpol_cubic, 0  }
    image_Save{1,"ram:upscale_cubic_ss.png",@"PNG"}

    Format ""
    ;Goto skipall
    #swi = 100
    #shi = 445
    #dxi = 110
    #dyi = 170
    #x   = 20
    #y   = 485
    #depth = 9
    image_Load{2,"/Data/aros.iff"}
    ;image_Load{2,"cache:lotr.gif"}
    image_Cut{1,2}
    image_SetDitherMode{1,#image_dithermode_err}
    image_Blit{1,#x+0*#swi,#y}                : WLocate #x+0*#swi,#y+95-WTopOff : Print "24 bit"         : image_Save{1,"RAM:dither_none.png",@"PNG"}
    image_SetDitherMode{1,#image_dithermode_none}

    image_Cut{1,2}
    image_Dither{1,#depth ,#image_dithermode_none}
    image_Draw{1,#x+1*#swi,#y}                : WLocate #x+1*#swi,#y+95-WTopOff : Print #depth," bit"    : image_Save{1,"RAM:dither_clip.png",@"PNG"}

    image_Cut{1,2}
    image_Dither{1,#depth ,#image_dithermode_err}
    image_Draw{1,#x+2*#swi,#y}                : WLocate #x+2*#swi,#y+95-WTopOff : Print "error dither"

    image_Cut{1,2}
    image_Dither{1,#depth ,#image_dithermode_noise}
    image_Draw{1,#x+3*#swi,#y}                : WLocate #x+3*#swi,#y+95-WTopOff : Print "noise dither"

    image_Cut{1,2}
    image_Dither{1,#depth ,#image_dithermode_tk}
    image_Draw{1,#x+4*#swi,#y}                : WLocate #x+4*#swi,#y+95-WTopOff : Print "tk special"

    image_Cut{1,2}
    image_Dither{1,#depth,#image_dithermode_errnoise}
    image_Draw{1,#x+5*#swi,#y}                : WLocate #x+5*#swi,#y+95-WTopOff : Print "err noise"

    image_Cut{1,2}
    image_Dither{1,#depth,-1}
    image_Draw{1,#x+6*#swi,#y}                : WLocate #x+6*#swi,#y+95-WTopOff : Print "default (fast)" : image_Save{1,"RAM:dither_error.png",@"PNG"}

    *wrp.RastPort = RastPort(0)
    image_CutRP{5,*wrp,0,0,WindowWidth,WindowHeight}
    image_FreeAlpha{5}
    succ.l = image_Save{5,"RAM:screenshot.png",@"PNG",6}

    Goto skipall

    coos.texturearray\x1 = 500,#bf243y-30
    coos.texturearray\x2 = 500,#bf243y-50
    coos.texturearray\x3 = 500,#bf243y+20
    coos.texturearray\x4 = 500,#bf243y+30
    image_TextureTriBlit{2,coos} : WLocate 350,#bf243y : Print "TextureBlit"

    Goto skipall

    For n.l = 10 To 700 Step 200
      image_Resize {1,5, n,n,#image_interpol_linear,1} : image_MidHandle{1}
      image_Draw{1,200,300}
      ;image_DrawScaled{5,600,300, n,n,-1,.7}
      Delay_ 1
    Next
    alphatest:
    succ & image_Load{1,"/Data/AlphaBlit.png"}
    succ & image_Load{1,"sys:Programme/MapEdit/Gfx/Objects/House1.png",-1,20}
    image_OptimizeAlpha{1,20}
    WCls 0
    eclock_Start{}
    For n.l = 0 To 100-1
      image_FancyBlit{1,20,20,-1,-1,-1,#image_blitmode_alpha,256,0}
    Next
    timeA.l = eclock_Stop{}
    WLocate 30,30 : NPrint "Slow: ",timeA," ms"

    eclock_Start{}
    For n.l = 0 To 100-1
      image_FancyBlit{1,400,20,-1,-1,-1,#image_blitmode_alpha,255,0}
    Next
    timeA.l = eclock_Stop{}
    WLocate 430,30 : NPrint "Fast: ",timeA," ms"

    ;If image_Load{5,"/Data/10"} = False Then End
    Goto skipall
    WCls 1
    eclock_Start{}
    ;For n.l = 0 To 10-1
    ;  image_DrawScaled {5,10,0,200,200,-1,.7}
    ;  image_DrawScaled {5,10,200,100,100,-1,.7}
    ;  image_DrawScaled {5,10,300, 50,50,-1,.7}
    ;  image_DrawScaled {5,10,350, 25,25,-1,.7}
    ;  image_DrawScaled {5,10,375, 12,12,-1,.7}
    For n.l = 0 To 10-1
      image_Resize {1,5,200,200,0} : image_Draw{1,10,0}
      image_Resize {2,5,100,100,0} : image_Draw{2,10,200}
      image_Resize {3,5, 50,50,0}  : image_Draw{3,10,300}
      image_Resize {4,5, 25,25,0}  : image_Draw{4,10,350}
      image_Resize {6,5, 12,12,0}  : image_Draw{6,10,375}
    Next
    timeA.l = eclock_Stop{}
    WLocate 30,30 : NPrint timeA," ms"

    eclock_Start{}
    For n.l = 0 To 10-1
    image_DrawScaled {5,210,0,200,200,-1,1}
    image_DrawScaled {5,210,200,100,100,-1,1}
    image_DrawScaled {5,210,300, 50,50,-1,1}
    image_DrawScaled {5,210,350, 25,25,-1,1}
    image_DrawScaled {5,210,375, 12,12,-1,1}
    Next
    timeA.l = eclock_Stop{}
    WLocate 230,30 : NPrint timeA," ms"

    eclock_Start{}
    For n.l = 0 To 10-1
    image_DrawScaled {5,410,0,200,200,-1}
    image_DrawScaled {5,410,200,100,100,-1}
    image_DrawScaled {5,410,300, 50,50,-1}
    image_DrawScaled {5,410,350, 25,25,-1}
    image_DrawScaled {5,410,375, 12,12,-1}
    Next
    timeA.l = eclock_Stop{}
    WLocate 430,30 : NPrint timeA," ms"

    eclock_Start{}
    For n.l = 0 To 10-1
    image_Resize {1,5,200,200,-1} : image_Draw{1,610,0}
    image_Resize {2,5,100,100,-1} : image_Draw{2,610,200}
    image_Resize {3,5, 50,50,-1}  : image_Draw{3,610,300}
    image_Resize {4,5, 25,25,-1}  : image_Draw{4,610,350}
    image_Resize {6,5, 12,12,-1}  : image_Draw{6,610,375}
    Next
    timeA.l = eclock_Stop{}
    WLocate 630,30 : NPrint timeA," ms"
    : image_MidHandle{5}
    ;image_Load{0,"/Data/test.iff"}
    For n.l = 1 To 700 Step 200
      image_Resize {1,5, n,n,#image_interpol_linear,1} : image_MidHandle{1}
      image_Draw{1,200,300}
      ;image_DrawScaled{5,600,300, n,n,-1,.7}
      Delay_ 1
    Next

    image_MidHandle{5}
    For n.l = 1 To 300 Step 4
     ; image_DrawScaled {5,400,300,n,-1,-1,1}
    ;  Delay_ 2
    Next
    skipall:

    While WaitEvent >< #IDCMP_CLOSEWINDOW : Wend
  Else
    error{"Something went wrong!"}
  End If

  CloseWindow 0
  image_FreeAll{}
  screen_Close{}
End If

End
CEND
