; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "/Bin"
; ExeFile         = "ImageDemo3"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 298
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 7
; CursorColumn    = 30
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 9
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 20
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 20
; Max ChunkyBuffer= 2
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: map.include                                                           /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 24/05/2007                                                            /
;/                                                                             /
;/ Author: Thilo Koehler                                                       /
;/                                                                             /
;/ Requirements:  Amiblitz3                                                    /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Provide map functionality for games.                                        /
;/ Maps can be edited with MapEdit, and used with this include within your g:: /
;/ ame.                                                                        /
;/                                                                             /
;/ Abstract:                                                                   /
;/ * no abstract available *                                                   /
;/                                                                             /
;/ User Constants:                                                             /
;/ #MAX_LAYERS = n                                                             /
;/ #MAX_ALPHAS = n                                                             /
;/ #MAX_IMAGES = n                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
CNIF #__include=0
Syntax 2
optimize 7
CEND

#MAX_MAPLAYERS   = 10   ; maximum number of layers per tile
#MAX_MAPALPHAS   = 100
#MAX_MAPIMAGES   = 1000

#MAX_TILEWIDTH   = 1024
#MAX_TILEHEIGHT  = 1024
#MAP_TILEINCSTEP = 16

XINCLUDE "xlog.include.ab3"
XINCLUDE "error.include.ab3"
XINCLUDE "image.include.ab3"
XINCLUDE "image_ext.include.ab3"
XINCLUDE "strptr.include.ab3"
XINCLUDE "xml.include.ab3"

#MAPOF_ALWAYSTOP    = 1
#MAPOF_ALWAYSBOTTOM = 2
#MAPOF_SORTED       = 4

;/* RGB Colors */
#ARGB_LGREY = $00BBBBBB
#ARGB_GREY  = $00999999
#ARGB_DGREY = $00777777
#ARGB_WHITE = $00FFFFFF
#ARGB_BLACK = $00000000
#ARGB_RED   = $00FF0000
#ARGB_GREEN = $0000FF00
#ARGB_BLUE  = $000000FF

;/* Map Attributes */
#MAPA_TILEHEIGHT  = #TAG_USER + 0
#MAPA_TILEWIDTH   = #TAG_USER + 1
#MAPA_MAPX        = #TAG_USER + 2
#MAPA_MAPY        = #TAG_USER + 3
#MAPA_PLAYFIELDX  = #TAG_USER + 4
#MAPA_PLAYFIELDY  = #TAG_USER + 5
#MAPA_NAME        = #TAG_USER + 6
#MAPA_COLS        = #TAG_USER + 7
#MAPA_ROWS        = #TAG_USER + 8
#MAPA_ALLOCCOLS   = #TAG_USER + 9
#MAPA_ALLOCROWS   = #TAG_USER + 10
#MAPA_PIXELWIDTH  = #TAG_USER + 11
#MAPA_PIXELHEIGHT = #TAG_USER + 12
#MAPA_GFXDIV      = #TAG_USER + 13

;/* Map Render Flags */
#MAPRF_CARPET       = $000001
#MAPRF_LAYER1       = $000002
#MAPRF_LAYER2       = $000004
#MAPRF_LAYER3       = $000008
#MAPRF_LAYER4       = $000010
#MAPRF_LAYER5       = $000020
#MAPRF_LAYER6       = $000040
#MAPRF_OBJECT       = $001000
#MAPRF_CLOUD        = $002000
#MAPRF_EVENTS       = $004000
#MAPRF_GRID         = $008000
#MAPRF_HEIGHT       = $010000
#MAPRF_BACKGROUND   = $020000
#MAPRF_HEIGHTGRID   = $040000
#MAPRF_CHECKERBOARD = $080000
#MAPRF_LAYERS     = #MAPRF_LAYER1|#MAPRF_LAYER2|#MAPRF_LAYER3|#MAPRF_LAYER4|#MAPRF_LAYER5|#MAPRF_LAYER6
#MAPRF_GROUND     = #MAPRF_CARPET|#MAPRF_LAYERS
#MAPRF_INGAME     = #MAPRF_GROUND|#MAPRF_OBJECT|#MAPRF_CLOUD
#MAPRF_EDITOR     = #MAPRF_INGAME|#MAPRF_EVENTS|#MAPRF_CHECKERBOARD|#MAPRF_HEIGHT|#MAPRF_GRID

;/* Map Pin Flags */
#MAPPF_SELECTED   = $000001 ;/* pin is selected in MapEditor */
#MAPPF_ACTIVE     = $000002 ;/* event is ready to fire */

;/* Tile blit modes */
#MAPBM_UNDEFINED  = 0
#MAPBM_ALPHA      = 1
#MAPBM_OPAQUE     = 2
#MAPBM_IALPHA     = 3
#MAPBM_ADD        = 4
#MAPBM_SUB        = 5
#MAPBM_TRANS      = 6
#MAPBM_MASK       = 7
#MAPBM_MUL        = 8
#MAPBM_INVISIBLE  = 9

;/* Object Events */
#MAPEV_NEVER      = 0   ; event is never fired/reloaded
#MAPEV_ONVISIBLE  = 1   ; event is fired/reloaded if in visible field
#MAPEV_ONTOUCH    = 2   ; event is fired/reloaded when touched
#MAPEV_ONINIT     = 3   ; event is fired on init of the map
#MAPEV_ONLEAVE    = 4   ; event is fired/reloaded when not in visible field
#MAPEV_ONTIMER    = 5   ; event is fired/reloaded after timer has passed

NEWTYPE.mapalpha
is_used.l    ; indicate that alpha is used
filename.s   ; filename of the original file
count.l      ; -1 if the whole image is used, positon in tile mod otherwise
ptr.l        ; pointer to data, -1 if not in RAM
xs.l         ; dimensions
ys.l
typ.b        ; typ
pad.b
fileoffset.l ; pointer to the alpha in file system
End NEWTYPE

NEWTYPE.mapimage
is_used.l    ; indicate that image is used
filename.s   ; filename to the original image file
rimage.l      ; -1, if image is not in RAM
AvgABGR.l    ; average color (for overview purposes)
count.l      ; -1 if the whole image is used, positon in tile mod otherwise
fileoffset.l ; pointer to the image in file system
hotx.l
hoty.l
xs.l
ys.l
End NEWTYPE

NEWTYPE.mapdatabase
*alphaA.mapalpha
*imageA.mapimage
*mapA.mapbase
*objA.mapobject
dataFile.s
dataFid.l
End NEWTYPE

NEWTYPE.dword
w.w[2]
End NEWTYPE

NEWTYPE.qbyte
b.b[4]
End NEWTYPE

NEWTYPE.maplayer
mimage.w  ; base image
alpha.w   ; alpha channel
mode.b    ; blit mode
typ.b     ; multitile typ
End NEWTYPE

NEWTYPE.maptile
layer.maplayer[#MAX_MAPLAYERS]
End NEWTYPE

NEWTYPE.mapevent
*obj.mapobject
absx.l          ; pin spot
absy.l
absz.l
user_data.l
End NEWTYPE

NEWTYPE.mapobject
name.l
mainimage.w    ; image number of main image
bltmode.w      ; blitmode of main image
shadowimage.w  ; image of shadow (always on floor)
shadowdepth.w  ; 0..255
heightimage.w  ; image for height information
vm.f           ; visibility margin

bound_x1.l     ; rectangle boundary of all images relative to pin spot
bound_y1.l
bound_x2.l
bound_y2.l

user_data.l    ; anything you want to store
ownID.l
flags.l        ; flags for internal use

eventFire.w    ; #MAPEV_...
eventReload.w  ; #MAPEV_...
End NEWTYPE

NEWTYPE.mappin
*obj.mapobject  ; pointer to mapobject
absx.l          ; pin spot
absy.l
absz.l
user_data.l
flags.l
End NEWTYPE

NEWTYPE.mappinlist
*pin.mappin[1000]
End NEWTYPE

NEWTYPE.mappinhead
allocN.w
useN.w
*pinlist.mappinlist
End NEWTYPE

NEWTYPE.mapengine
cacheimage.l
askdone.l
mapevent.mapevent
End NEWTYPE

NEWTYPE.mapheightinfo
height.w
tileoffset.b
reserved.b
End NEWTYPE

NEWTYPE.mapbase  ; map basis structure
name.l

map_x.l        ; offset within map
map_y.l

tile_width.l   ; tile dimensions
tile_height.l
playfield_x.l  ; playfield position relative to rastport
playfield_y.l

cols.l
rows.l
useCols.l
useRows.l

index_cols.l
index_rows.l

*tile_matrix.maptile   ; array colsXrows with tile pointers
*pinhead_matrix.mappinhead    ; array colsXrows with pinhead pointers
*height_matrix.mapheightinfo

bgARGB.l

dataFid.l
dataImageOffset.l
dataAlphaOffset.l

renderimage.l

gfxDiv.l
End NEWTYPE

Dim mapalpha.mapalpha(#MAX_MAPALPHAS-1)
Dim mapimage.mapimage(#MAX_MAPIMAGES-1)
Dim List *maplist.mapbase(0)    ; list of created maps for resource tracking
Dim List *tilelist.maptile(0)   ; list of tiles in database
Dim List *objlist.mapobject(0)  ; list of objects in database
Dim List *pindrawlist.mappin(0) ; list of pins to draw
Dim List mapeventqueue.mapevent(0)
DEFTYPE.mapengine mapengine
mapengine\cacheimage=-1

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_ReleaseImage {mimage.l}                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - mimage.l    : ???                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_ReleaseImage{mimage.l}
SHARED mapimage()
If mapimage(mimage)\rimage<0 Then Statement Return
image_Free{mapimage(mimage)\rimage}  : mapimage(mimage)\rimage = -1
End Statement

Statement map_UnlockImage{mimage.l}
SHARED mapimage()
If mapimage(mimage)\rimage<0 Then Statement Return
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !map_GetTile {xpos.l,ypos.l}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ Get the pointer to a tile at xpos/ypos postion in the map.                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - xpos.l    : x position                                                    /
;/ - ypos.l    : y position                                                    /
;/                                                                             /
;/ Result:                                                                     /
;/ *tile.maptile : pointer to a tile                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro map_GetTile ;{xpos.l,ypos.l}
Peek.l(*map\tile_matrix + (SizeOf.l * (((`2) * *map\cols) + (`1))))
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !map_GetTileEdgeHeight {map,col,row}                                /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - map    : ???                                                              /
;/ - col    : ???                                                              /
;/ - row    : ???                                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro map_GetTileEdgeHeight; {map,col,row}
Peek.w(`1\height_matrix + (SizeOf.mapheightinfo * (((`3) * `1\cols) + (`2))))
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !map_SetTileEdgeHeight {map,col,row,h}                              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - map    : ???                                                              /
;/ - col    : ???                                                              /
;/ - row    : ???                                                              /
;/ - h    : ???                                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro map_SetTileEdgeHeight; {map,col,row,h}
Poke.w(`1\height_matrix + (SizeOf.mapheightinfo * (((`3) * `1\cols) + (`2)))),`4
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_UpdateHeightInfo {*map.mapbase}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_UpdateHeightInfo{*map.mapbase}
If *map
  If *map\height_matrix
    For row.l = 0 To *map\rows-1
      For col.l = 0 To *map\cols-1
        *maphi.mapheightinfo = *map\height_matrix + (row * *map\rows + col) * SizeOf.mapheightinfo
        minrow.l = row-63 : If minrow<0 Then minrow = 0
        maxrow.l = row+63 : If maxrow>=*map\rows Then maxrow = *map\rows-1
        For checkrow.l = minrow To maxrow

        Next
      Next
    Next
  End If
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetTileHeight {*map.mapbase,col.l,row.l}            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - col.l    : ???                                                            /
;/ - row.l    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetTileHeight{*map.mapbase,col.l,row.l}
If *map
  If *map\height_matrix
    If col>=0 AND row>=0
      If col<*map\cols-1 AND row<*map\rows-1
        h1.l = !map_GetTileEdgeHeight {*map,col  ,row  }
        h2.l = !map_GetTileEdgeHeight {*map,col+1,row  }
        h3.l = !map_GetTileEdgeHeight {*map,col  ,row+1}
        h4.l = !map_GetTileEdgeHeight {*map,col+1,row+1}
      End If
    End If
  End If
End If
h.l = (h1+h2+h3+h4)/4
Function Return h
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetTileEdgeHeight {*map.mapbase,col.l,row.l}        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - col.l    : ???                                                            /
;/ - row.l    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetTileEdgeHeight{*map.mapbase,col.l,row.l}
If *map
  If *map\height_matrix
    If col>=0 AND row>=0
      If col<*map\cols AND row<*map\rows
        h.l = !map_GetTileEdgeHeight {*map,col,row}
      End If
    End If
  End If
End If
Function Return h
End Function
 
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_SetTileEdgeHeight {*map.mapbase,col.l,row.l,h.l}                /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - col.l    : ???                                                            /
;/ - row.l    : ???                                                            /
;/ - h.l    : ???                                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_SetTileEdgeHeight{*map.mapbase,col.l,row.l,h.l}
If *map
  If *map\height_matrix
    If col>=0 AND row>=0
      If col<*map\cols AND row<*map\rows
        !map_SetTileEdgeHeight {*map,col,row,h}
      End If
    End If
  End If
End If
End Statement
 
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_SetTileHeight {*map.mapbase,col.l,row.l,h.l}                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - col.l    : ???                                                            /
;/ - row.l    : ???                                                            /
;/ - h.l    : ???                                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_SetTileHeight{*map.mapbase,col.l,row.l,h.l}
If *map
  If *map\height_matrix
    If col>=0 AND row>=0
      If col<*map\cols-1 AND row<*map\rows-1
        !map_SetTileEdgeHeight {*map,col  ,row  ,h}
        !map_SetTileEdgeHeight {*map,col+1,row  ,h}
        !map_SetTileEdgeHeight {*map,col  ,row+1,h}
        !map_SetTileEdgeHeight {*map,col+1,row+1,h}
      End If
    End If
  End If
End If
End Statement
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !map_GetPinHead {xpos.l,ypos.l}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - xpos.l    : ???                                                           /
;/ - ypos.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro map_GetPinHead ;{xpos.l,ypos.l}
Peek.l(*map\pinhead_matrix + (SizeOf.l * (((`2) * *map\cols) + (`1))))
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !map_SetPinHead {pinhead.l,xpos.l,ypos.l}                           /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - pinhead.l    : ???                                                        /
;/ - xpos.l    : ???                                                           /
;/ - ypos.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro map_SetPinHead ;{pinhead.l,xpos.l,ypos.l}
Poke.l(*map\pinhead_matrix + (SizeOf.l * (((`3) * *map\cols) + (`2)))),`1
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !map_AddDrawPin Listname,x,y                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro map_AddDrawPin ; Listname, x, y
breakme.l = False
*newpin.mappin = `2
ResetList `1()
Repeat
 If NextItemFast(`1())
   *oldpin.mappin    = `1()
   xd.f = *newpin\absx - *oldpin\absx
   yd.f = *newpin\absy - *oldpin\absy
   If xd><0
     vm.f = yd/xd
     If *oldpin\obj\vm><0
       If xd>0
         If *oldpin\obj\vm>=vm Then doit.l=True:Else doit=False
       Else
         If *oldpin\obj\vm<=vm Then doit.l=True:Else doit=False
       End If
     Else
       If xd>0
         If *newpin\obj\vm>=vm Then doit.l=True:Else doit=False
       Else
         If *newpin\obj\vm<=vm Then doit.l=True:Else doit=False
       End If
     End If
   Else
     vm.f = 0
     If yd<0 Then doit=True:Else doit=False
   End If

   If doit
     If PrevItem (`1()) ; whoops, we seeked 1 to far
       If AddItem (`1()) Then `1() = *newpin
       breakme = True
     Else
       If AddFirst (`1()) Then `1() = *newpin
       breakme=True
     End If
   End If
 Else
   If AddItem (`1()) ; seek till there is no more
     `1() = *newpin
   End If
   breakme = True
 End If
Until breakme = True
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetFreeImage {@minmimage.l}                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - minmimage.l    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetFreeImage{@minmimage.l}
SHARED mapimage()
If minmimage<0 Then mimage.l = 0:Else mimage=minmimage
While mimage<#MAX_MAPIMAGES-1 AND mapimage(mimage)\is_used=True:mimage+1:Wend
If mapimage(mimage)\is_used=True Then mimage=-1
Function Return mimage
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetFreeAlpha {@minalpha.l}                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - minalpha.l    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetFreeAlpha{@minalpha.l}
SHARED mapalpha()
If minalpha<0 Then alpha.l = 0:Else alpha=minalpha
While alpha<#MAX_MAPALPHAS-1 AND mapalpha(alpha)\is_used=True:alpha+1:Wend
If mapalpha(alpha)\is_used=True Then alpha=-1
Function Return alpha
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_SetImageAttrs {mimage.l,xs.l,ys.l,ABGR.l,hotx.l,hoty.l}         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - mimage.l    : ???                                                         /
;/ - xs.l    : ???                                                             /
;/ - ys.l    : ???                                                             /
;/ - ABGR.l    : ???                                                           /
;/ - hotx.l    : ???                                                           /
;/ - hoty.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_SetImageAttrs{mimage.l,xs.l,ys.l,ABGR.l,hotx.l,hoty.l}
SHARED mapimage()
mapimage(mimage)\xs         = xs
mapimage(mimage)\ys         = ys
mapimage(mimage)\hotx       = hotx
mapimage(mimage)\hoty       = hoty
mapimage(mimage)\AvgABGR    = ABGR
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_CreateImage {filename.s,fileoffset.l,@mimage.l,@i:: /
;/ mage.l}                                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Create a map image.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : filename to load, optional (from file)                                                      /
;/ - fileoffset.l  : fileoffset to load from, optional (from database)                                                    /
;/ - mimage.l      : mimage to load, or -1 for dynamic allocation                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : mimage id or 1 if failed                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_CreateImage{filename.s,fileoffset.l,@mimage.l,@image.l}
SHARED mapimage(),mapengine
If mimage<0 Then mimage = map_GetFreeImage{}
If mimage<0 Then Function Return -1
mapimage(mimage)\filename   = filename
mapimage(mimage)\is_used    = True
mapimage(mimage)\AvgABGR    = 0
mapimage(mimage)\rimage     = -1
mapimage(mimage)\count      = -1
mapimage(mimage)\fileoffset = fileoffset
mapimage(mimage)\xs         = 1
mapimage(mimage)\ys         = 1
mapimage(mimage)\hotx       = 0
mapimage(mimage)\hoty       = 0
If image>=0
  mapimage(mimage)\rimage     = image
  mapimage(mimage)\xs         = image_GetWidth  {image}
  mapimage(mimage)\ys         = image_GetHeight {image}
  mapimage(mimage)\hotx       = image_GetHandleX{image}
  mapimage(mimage)\hoty       = image_GetHandleY{image}
  ARGB.l = image_GetAvgARGB{image}
  mapimage(mimage)\AvgABGR    = ( (ARGB & $FF) LSL 16) | (ARGB & $00FF00) | ( (ARGB LSR 16) & $FF)
End If
Function Return mimage
End Function
 

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_LoadImage {*map.mapbase,filename.s,@mimage.l,@cou:: /
;/ nt.l}                                                                       /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase  : ???                                                       /
;/ - filename.s    : ???                                                       /
;/ - mimage.l      : ???                                                       /
;/ - count.l       : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l      : ???                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_LoadImage{*map.mapbase,filename.s,@mimage.l,@count.l}
SHARED mapimage(),mapengine
If mimage<0 Then mimage = map_GetFreeImage{}
If mimage<0 Then Function Return 0

nosplit.l = False
If count=-1 Then nosplit=True ; we want the whole image
If *map=0 Then nosplit = True : count=0 ; we have no map, so get the whole image (rare case)

; get the cache filename
If mapengine\cacheimage>=0
  cachefilename.s = image_GetFilename{mapengine\cacheimage}
Else
  cachefilename.s = ""
End If
If *map Then image_SetLoadDevisor{*map\gfxDiv}
; if not already in cache, load again!
If cachefilename.s >< filename.s
  If mapengine\cacheimage>=0 Then image_Free{mapengine\cacheimage}
  mapengine\cacheimage = image_GetFree{}
  If mapengine\cacheimage>=0
    If image_Load{mapengine\cacheimage,filename.s,-1,-1,#image_dithermode_default}
      imagedat(mapengine\cacheimage)\mask_threshold=145
      ;image_OptimizeAlpha{mapengine\cacheimage,16}
      mapengine\askdone = False
      If image_AlphaIsUsed{mapengine\cacheimage}
        ; ok, we will use the Alpha channel
        image_InitMask {mapengine\cacheimage}
      Else
        ; if not opaque ...
        iw.l = image_GetWidth{mapengine\cacheimage}
        ih.l = image_GetHeight{mapengine\cacheimage}
        trgb.l = $FF00FF

        rgb1.l = image_GetRGB{mapengine\cacheimage,0,0}
        rgb2.l = image_GetRGB{mapengine\cacheimage,iw-1,0}
        rgb3.l = image_GetRGB{mapengine\cacheimage,iw-1,ih-1}
        rgb4.l = image_GetRGB{mapengine\cacheimage,0,ih-1}

        If rgb1=rgb2 AND rgb2=rgb3 AND rgb3=rgb4
          trgb.l = rgb1
        Else
          rgb1.l = image_GetRGB{mapengine\cacheimage,iw/2,0}
          rgb2.l = image_GetRGB{mapengine\cacheimage,iw-1,ih/2}
          rgb3.l = image_GetRGB{mapengine\cacheimage,iw/2,ih-1}
          rgb4.l = image_GetRGB{mapengine\cacheimage,0,ih/2}
          If rgb1=rgb2 AND rgb2=rgb3 AND rgb3=rgb4 Then trgb.l = rgb1
        End If

        image_InitMask {mapengine\cacheimage,trgb}
        ; end if
      End If
    End If
  End If
End If

; check if the image was loaded
If image_IsUsed{mapengine\cacheimage} = False Then Function Return 0

If nosplit=False
  iw.l = image_GetWidth{mapengine\cacheimage}
  ih.l = image_GetHeight{mapengine\cacheimage}

  If (iw MOD *map\tile_width><0 OR ih MOD *map\tile_height><0) AND mapengine\askdone=False
    mapengine\askdone = True
    If ask {filename.s+":\\nImage size ("+Str$(iw)+"x"+Str$(ih)+") if not a multiple of the tile size ("+Str$(*map\tile_width)+"x"+Str$(*map\tile_height)+") !","Ignore|Ooops!"}=False Then Function Return 0
  End If
End If

If *map
  multix.l = iw / *map\tile_width
  multiy.l = ih / *map\tile_height
Else
  multix.l = 1
  multiy.l = 1
End If

If count=-2
  If multix<=1 AND multiy<=1
    nosplit=True
  Else
    If ask{"Load as...","Single Tile|Splitted Images"}
      nosplit=True
    Else
      nosplit=False
    End If
  End If
End If

If nosplit=False ; check if the split image is only single-sized
  If multix<=1 AND multiy<=1 Then nosplit=True
End If

mapimage(mimage)\is_used = False

If nosplit
  mapimage(mimage)\filename   = filename
  mapimage(mimage)\is_used    = True
  ARGB.l = image_GetAvgARGB{mapengine\cacheimage}
  mapimage(mimage)\AvgABGR    = ( (ARGB & $FF) LSL 16) | (ARGB & $00FF00) | ( (ARGB LSR 16) & $FF)
  mapimage(mimage)\rimage     = mapengine\cacheimage
  mapimage(mimage)\count      = -1
  mapimage(mimage)\fileoffset = -1
  mapimage(mimage)\xs         = image_GetWidth{mapengine\cacheimage}
  mapimage(mimage)\ys         = image_GetHeight{mapengine\cacheimage}
  mapimage(mimage)\hotx       = image_GetHandleX{mapengine\cacheimage}
  mapimage(mimage)\hoty       = image_GetHandleY{mapengine\cacheimage}
  mapengine\cacheimage        = -1
Else
  If count=-2
    mb.l = 0 : me.l = multiy-1
    nb.l = 0 : ne.l = multix-1
    count.l = 0
  Else
    If multix<1 Then multix=1
    If multiy<1 Then multiy=1
    mb.l = count  /  multix : me.l = mb
    nb.l = count MOD multix : ne.l = nb
  End If
  For m.l=mb To me
    For n.l=nb To ne
      If m<multiy AND mimage>=0
        mapimage(mimage)\is_used = False
        image.l = image_GetFree{}
        If image>=0
          image_Cut{image,mapengine\cacheimage,n**map\tile_width,m**map\tile_height,*map\tile_width,*map\tile_height}
          If image_IsUsed{image}
            mapimage(mimage)\fileoffset = -1
            mapimage(mimage)\filename   = filename
            mapimage(mimage)\rimage     = image
            ARGB.l = image_GetAvgARGB{image}
            mapimage(mimage)\AvgABGR    = ((ARGB & $FF) LSL 16) | (ARGB & $00FF00) | ((ARGB LSR 16) & $FF)
            mapimage(mimage)\is_used    = True
            mapimage(mimage)\count      = count
            mapimage(mimage)\xs         = image_GetWidth{image}
            mapimage(mimage)\ys         = image_GetHeight{image}
            mapimage(mimage)\hotx       = image_GetHandleX{image}
            mapimage(mimage)\hoty       = image_GetHandleY{image}
          Else
            mapimage(mimage)\filename = ""
            mapimage(mimage)\rimage = -1
            mapimage(mimage)\fileoffset= -1
            mapimage(mimage)\is_used  = False
          End If
        End If
      Else
        error {"Requested split-image outside of main image!"}
      End If
      count+1
      mimage = map_GetFreeImage{}
    Next
  Next
End If
Function Return mapimage(mimage)\is_used
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_FreeImage {mimage.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - mimage.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_FreeImage{mimage.l}
SHARED mapimage()
If mapimage(mimage)\is_used
  map_ReleaseImage{mimage}
  mapimage(mimage)\is_used = False
  mapimage(mimage)\filename = ""
  mapimage(mimage)\fileoffset = -1
End If
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_LoadAlpha {*map.mapbase,filename.s,@alpha.l}        /
;/                                                                             /
;/ Description:                                                                /
;/ Load a greyscale image as an alpha channel.                                 /
;/ If the image is a multiple of the tile dimensions, it is read as several :: /
;/ alphas.                                                                     /
;/ Check the return value how many alphas were read.                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase  : pointer to the map                                        /
;/ - filename.s    : of the image file                                         /
;/ - alpha.l       : load to a specific alpha ID or -1 for auto select         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l      : number of alphas read                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_LoadAlpha{*map.mapbase,filename.s,@alpha.l}
SHARED mapalpha()
count.l=0
image.l = image_GetFree{}
If alpha<0 Then alpha=map_GetFreeAlpha{alpha}
If alpha<0 OR image<0 Then Function Return 0
If image_Load{image,filename.s}
  image_CreateAlpha{image,#ARGB_BLACK,256}
  aimage.l = image_GetFree{}
  multix.l = image_GetWidth{image}  / *map\tile_width
  multiy.l = image_GetHeight{image} / *map\tile_height

  For m.l = 0 To multiy-1
    For n.l =0 To multix-1
      If alpha>=0
       image_Cut{aimage,image,n**map\tile_width,m**map\tile_height,*map\tile_width,*map\tile_height}
       If image_IsUsed{aimage}
        alphaptr.l = AllocVec_(*map\tile_width* *map\tile_height,#MEMF_ANY)
        If alphaptr
          image_ExtractAlpha{aimage,alphaptr,*map\tile_width}
          mapalpha(alpha)\xs       = *map\tile_width
          mapalpha(alpha)\ys       = *map\tile_height
          mapalpha(alpha)\ptr      = alphaptr
          mapalpha(alpha)\filename = filename.s
          mapalpha(alpha)\is_used  = -1
          If multiy<=1 AND multix<=1
            mapalpha(alpha)\count    = -1
          Else
            mapalpha(alpha)\count    = m*multix + n
          End If
          count+1
          alpha=map_GetFreeAlpha{alpha}
        End If
       End If
      End If
    Next
  Next
  image_Free{image}
End If
Function Return count
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_FreeAlpha {alpha.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - alpha.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_FreeAlpha{alpha.l}
SHARED mapalpha()
If mapalpha(alpha)\is_used
  FreeVec_ mapalpha(alpha)\ptr
  mapalpha(alpha)\is_used = False
  mapalpha(alpha)\ptr = False
End If
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_AccessImage {mimage.l,@*map.mapbase}                /
;/                                                                             /
;/ Description:                                                                /
;/ Swap in an image if not already im memory.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - mimage.l      : map image                                                         /
;/ - *map.mapbase  : map the image belongs to                                                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l      : image.include image ID or -1 if failed                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_LockImage{mimage.l,@*map.mapbase}
SHARED mapimage(),*maplist()
If mimage<0 Then Function Return -1
If mapimage(mimage)\rimage>=0 Then Function Return mapimage(mimage)\rimage
If *map=0 OR *map=-1 Then ResetList *maplist() : If NextItemFast(*maplist()) Then *map = *maplist()
If *map=0 OR *map=-1 Then Function Return -1 ; no map available
If mapimage(mimage)\fileoffset>=0
  If *map\dataFid>=0
    If file_Seek{*map\dataFid,*map\dataImageOffset+mapimage(mimage)\fileoffset}
      image.l = image_GetFree{}
      If image>=0
        If image_Read{image,*map\dataFid}
          mapimage(mimage)\rimage = image
          mapimage(mimage)\xs     = image_GetWidth{image}
          mapimage(mimage)\ys     = image_GetHeight{image}
        End If
      End If
    End If
  End If
Else
  If mapimage(mimage)\filename
    If map_LoadImage{*map,mapimage(mimage)\filename,mimage,mapimage(mimage)\count}
      If mapimage(mimage)\rimage>=0
        image_SetHandle{mapimage(mimage)\rimage,mapimage(mimage)\hotx,mapimage(mimage)\hoty}
        mapimage(mimage)\xs     = image_GetWidth{mapimage(mimage)\rimage}
        mapimage(mimage)\ys     = image_GetHeight{mapimage(mimage)\rimage}
      End If
    End If
  End If
End If
Function Return mapimage(mimage)\rimage
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_SetHandle {mimage.l,x.l,y.l}                                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - mimage.l    : ???                                                         /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_SetHandle{mimage.l,x.l,y.l}
SHARED mapimage()
mapimage(mimage)\hotx = x
mapimage(mimage)\hoty = y
If mapimage(mimage)\rimage>=0
  image_SetHandle{mapimage(mimage)\rimage,x,y}
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_FootHandle {mimage.l}                                           /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - mimage.l    : ???                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_FootHandle{mimage.l}
SHARED mapimage()
image.l = map_LockImage{mimage}
If image>=0
  image_FootHandle{image}
  mapimage(mimage)\hotx = image_GetHandleX{image}
  mapimage(mimage)\hoty = image_GetHandleY{image}
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = map_Long2String {long.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - long.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s map_Long2String{long.l}
succ.l = True
For n.l=0 To 3
  c.b = Peek.b(&long+n)
  If c.b<32 Then succ=False
Next
If succ
  string.s = "@"+Mkl$(long)
Else
  If n<32767 AND n>-32768 Then string.s = Str$(long) : Else string.s = "$"+Hex$(long)
End If
Function Return string.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_Resize {*map.mapbase,col.l,row.l}                   /
;/                                                                             /
;/ Description:                                                                /
;/ Resize a map. Internal use only.                                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - col.l    : ???                                                            /
;/ - row.l    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_Resize{*map.mapbase,col.l,row.l}
col+*map\index_cols
row+*map\index_rows
dcol.l = 0
drow.l = 0
cols.l = *map\cols
rows.l = *map\rows
If col<0 Then dcol.l = -col : cols - col : col=0
If row<0 Then drow.l = -row : rows - row : row=0
If col>*map\cols-1 Then cols = col +1
If row>*map\rows-1 Then rows = row +1
succ.l = -1

If cols>*map\cols OR rows>*map\rows
  If cols>*map\cols Then cols+#MAP_TILEINCSTEP
  If rows>*map\rows Then rows+#MAP_TILEINCSTEP
  succ = False
  tile_matrix.l    = AllocVec_(SizeOf.l*cols*rows,#MEMF_CLEAR)
  pinhead_matrix.l = AllocVec_(SizeOf.l*cols*rows,#MEMF_CLEAR)
  height_matrix.l  = AllocVec_(SizeOf.mapheightinfo*cols*rows,#MEMF_CLEAR)
  For n.l=0 To cols*rows-1
    h.l = RRnd(0,20)
    ;Poke.l n*4+height_matrix,h
  Next
  If tile_matrix ><0 AND pinhead_matrix><0 AND height_matrix><0
    If *map\tile_matrix><0 AND *map\pinhead_matrix><0 AND *map\height_matrix><0
      For y.l = 0 To *map\rows-1
        For x.l = 0 To *map\cols-1
          *tile.maptile = !map_GetTile{x,y}
          Poke.l tile_matrix    + SizeOf.l*(cols*(y+drow)+x+dcol),*tile
          *pinhead.mappinhead = !map_GetPinHead{x,y}
          Poke.l pinhead_matrix + SizeOf.l*(cols*(y+drow)+x+dcol),*pinhead
          height.l = Peek.l(*map\height_matrix  + SizeOf.l*((cols*y)+x))
          Poke.l height_matrix  + SizeOf.mapheightinfo*(cols*(y+drow)+x+dcol),height
        Next
      Next
      FreeVec_ *map\tile_matrix
      FreeVec_ *map\pinhead_matrix
      FreeVec_ *map\height_matrix
    End If
    *map\cols       = cols
    *map\rows       = rows
    *map\index_cols + dcol
    *map\index_rows + drow
    *map\tile_matrix    = tile_matrix
    *map\pinhead_matrix = pinhead_matrix
    *map\height_matrix  = height_matrix
    succ = True
  Else
    error{"Not enough memory to extend map ! ("+Str$(cols)+"x"+Str$(rows)+")"}
  End If
End If
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_SetAttrs {*map.mapbase,*taglist.TagItem}            /
;/                                                                             /
;/ Description:                                                                /
;/ Set attributes for a map                                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - *taglist.TagItem    : ???                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_SetAttrs{*map.mapbase,*taglist.TagItem}
count.l = 0
If *taglist=0 Then Function Return count

While *taglist\ti_Tag><#TAG_DONE
  Select *taglist\ti_Tag
    Case #MAPA_TILEWIDTH    : *map\tile_width   = *taglist\ti_Data / *map\gfxDiv: count+1
    Case #MAPA_TILEHEIGHT   : *map\tile_height  = *taglist\ti_Data / *map\gfxDiv: count+1
    Case #MAPA_MAPX         : *map\map_x        = *taglist\ti_Data : count+1
    Case #MAPA_MAPY         : *map\map_y        = *taglist\ti_Data : count+1
    Case #MAPA_PLAYFIELDX   : *map\playfield_x  = *taglist\ti_Data : count+1
    Case #MAPA_PLAYFIELDY   : *map\playfield_y  = *taglist\ti_Data : count+1
    Case #MAPA_NAME         : str_WritePtr {&*map\name,*taglist\ti_Data} : count+1
    Case #MAPA_ROWS         : *map\useRows = *taglist\ti_Data : count+1
    Case #MAPA_COLS         : *map\useCols = *taglist\ti_Data : count+1
    Case #MAPA_ALLOCCOLS    : map_Resize{*map,*map\useCols-1,*taglist\ti_Data-1} : count+1
    Case #MAPA_ALLOCROWS    : map_Resize{*map,*taglist\ti_Data-1,*map\useRows-1} : count+1
    Case #MAPA_GFXDIV
      *map\tile_width  * *map\gfxDiv
      *map\tile_height * *map\gfxDiv
      *map\gfxDiv = *taglist\ti_Data
      *map\tile_width  / *map\gfxDiv
      *map\tile_height / *map\gfxDiv
      count+1
  End Select
  *taglist + SizeOf.TagItem
Wend
Function Return count
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetAttr {*map.mapbase,tag.l,@tagdata.l}             /
;/                                                                             /
;/ Description:                                                                /
;/ Get an attribute from a map                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - tag.l    : ???                                                            /
;/ - tagdata.l    : ???                                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetAttr{*map.mapbase,tag.l,@tagdata.l}
Select tag
  Case #MAPA_TILEWIDTH   : ret.l = *map\tile_width
  Case #MAPA_TILEHEIGHT  : ret.l = *map\tile_height
  Case #MAPA_MAPX        : ret.l = *map\map_x
  Case #MAPA_MAPY        : ret.l = *map\map_y
  Case #MAPA_PLAYFIELDX  : ret.l = *map\playfield_x
  Case #MAPA_PLAYFIELDY  : ret.l = *map\playfield_y
  Case #MAPA_NAME        : ret.l = *map\name+4
  Case #MAPA_ROWS        : ret.l = *map\useRows
  Case #MAPA_COLS        : ret.l = *map\useCols
  Case #MAPA_ALLOCROWS   : ret.l = *map\rows
  Case #MAPA_ALLOCCOLS   : ret.l = *map\cols
  Case #MAPA_PIXELWIDTH  : ret.l = *map\useCols * *map\tile_width
  Case #MAPA_PIXELHEIGHT : ret.l = *map\useRows * *map\tile_height
  Default : ret.l = 0
End Select
Function Return ret
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetTileCarpet {*map.mapbase,col.l,row.l,layer.l}    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - col.l    : ???                                                            /
;/ - row.l    : ???                                                            /
;/ - layer.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetTileCarpet{*map.mapbase,col.l,row.l,layer.l}
SHARED mapimage()
If *map=0 Then Function Return -1
If col>=*map\cols OR row>=*map\rows OR col<0 OR row<0 OR layer<0 OR layer>=#MAX_MAPLAYERS Then Function Return -1
*tile.maptile = !map_GetTile{col,row}
If *tile Then mimage.l = *tile\layer[layer]\mimage : Else mimage = -1
Function Return mimage
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetTileImage {*map.mapbase,col.l,row.l,layer.l}     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - col.l    : ???                                                            /
;/ - row.l    : ???                                                            /
;/ - layer.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetTileImage{*map.mapbase,col.l,row.l,layer.l}
SHARED mapimage()
If *map=0 Then Function Return -1
If col>=*map\cols OR row>=*map\rows OR col<0 OR row<0 OR layer<0 OR layer>=#MAX_MAPLAYERS Then Function Return -1
*tile.maptile = !map_GetTile{col,row}
If *tile Then mimage.l = *tile\layer[layer]\mimage : Else mimage = -1
If mimage>=0
  image.l = map_LockImage{mimage,*map}
Else
  image=-1
End If
Function Return image
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetTileAlpha {*map.mapbase,col.l,row.l,layer.l}     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - col.l    : ???                                                            /
;/ - row.l    : ???                                                            /
;/ - layer.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetTileAlpha{*map.mapbase,col.l,row.l,layer.l}
If *map=0 Then Function Return -1
If col>=*map\cols OR row>=*map\rows OR col<0 OR row<0 OR layer<0 OR layer>=#MAX_MAPLAYERS Then Function Return -1
*tile.maptile = !map_GetTile{col,row}
If *tile Then alpha.l = *tile\layer[layer]\alpha : Else alpha = -1
Function Return alpha
End Function
 
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetTileMode {*map.mapbase,col.l,row.l,layer.l}      /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - col.l    : ???                                                            /
;/ - row.l    : ???                                                            /
;/ - layer.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetTileMode{*map.mapbase,col.l,row.l,layer.l}
If *map=0 Then Function Return #MAPBM_UNDEFINED
If col>=*map\cols OR row>=*map\rows OR col<0 OR row<0 OR layer<0 OR layer>=#MAX_MAPLAYERS Then Function Return #MAPBM_UNDEFINED
*tile.maptile = !map_GetTile{col,row}
If *tile Then mode.l = *tile\layer[layer]\mode : Else mode = #MAPBM_UNDEFINED
Function Return mode
End Function
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_Create {name.s,tile_width.l,tile_height.l}          /
;/                                                                             /
;/ Description:                                                                /
;/ Create a new map.                                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - name.s        : name of the map                                           /
;/ - tile_width.l  : tile size in pixels                                       /
;/ - tile_height.l :                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l      : pointer to a map or 0 if failed                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_Create{name.s,tile_width.l,tile_height.l}
SHARED *maplist()
If tile_width<1 OR tile_height<1 OR tile_width>#MAX_TILEWIDTH OR tile_height>#MAX_TILEHEIGHT Then Function Return 0
*map.mapbase = AllocVec_(SizeOf.mapbase,#MEMF_CLEAR)
If *map
  If AddItem(*maplist())
    *maplist() = *map
  End If
  *map\index_cols      =  0
  *map\index_rows      =  0
  *map\cols            =  0
  *map\rows            =  0
  *map\tile_matrix     =  0
  *map\pinhead_matrix  =  0
  *map\dataFid         = -1
  *map\dataImageOffset =  0
  *map\dataAlphaOffset =  0
  *map\renderimage     = -1
  *map\gfxDiv          =  1
  map_SetAttrs{*map,Tags(#MAPA_NAME,&name,#MAPA_TILEWIDTH,tile_width,#MAPA_TILEHEIGHT,tile_height) }
End If
Function Return *map
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_Free {*map.mapbase}                                             /
;/                                                                             /
;/ Description:                                                                /
;/ Free a map and all associated resources.                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : pointer to a map.                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_Free{*map.mapbase}
SHARED *maplist()
If *map.mapbase

  ResetList *maplist()
  While NextItemFast(*maplist())
    If *maplist() = *map Then KillItem *maplist()
  Wend

  If *map\tile_matrix
    FreeVec_ *map\tile_matrix
    *map\tile_matrix = 0
  End If
  If *map\pinhead_matrix
    FreeVec_ *map\pinhead_matrix
    *map\pinhead_matrix = 0
  End If

  If *map\renderimage>=0 Then image_Free{*map\renderimage} : *map\renderimage=-1

  *map\cols = 0
  *map\rows = 0
  FreeVec_ *map
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_RenderOverview {*map.mapbase,*rp.RastPort,rpx.l,rpy.l,startco:: /
;/ l.l,startrow.l,width.l,height.l,@flags.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - *rp.RastPort    : ???                                                     /
;/ - rpx.l    : ???                                                            /
;/ - rpy.l    : ???                                                            /
;/ - startcol.l    : ???                                                       /
;/ - startrow.l    : ???                                                       /
;/ - width.l    : ???                                                          /
;/ - height.l    : ???                                                         /
;/ - flags.l    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_RenderOverview{*map.mapbase,*rp.RastPort,rpx.l,rpy.l,startcol.l,startrow.l,width.l,height.l,@flags.l}
SHARED mapalpha(),*pindrawlist(),mapimage()
If *map = 0 Then Statement Return
If *rp  = 0 Then Statement Return
If flags = -1 Then flags = #MAPRF_INGAME

If rpx<0 Then width+rpx:rpx=0
If rpy<0 Then height+rpy:rpy=0

rect.Rectangle\MinX = rpx           ;+*map\playfield_x
rect\MinY           = rpy           ;+*map\playfield_y
rect\MaxX           = rpx+width -1
rect\MaxY           = rpy+height-1
*newregion.Region = NewRegion_()
LockLayer_ 0,*rp\Layer
If *newregion
  If OrRectRegion_(*newregion, &rect)
    *oldregion.Region = InstallClipRegion_(*rp\Layer, *newregion)
  End If
End If

endcol.l = (startcol+width ) -1
endrow.l = (startrow+height) -1

If flags&(#MAPRF_LAYERS|#MAPRF_CARPET)
  For row.l = startrow To endrow
    backpen.l = ((row +startcol) MOD 2)
    For col.l = startcol To endcol
      backpen=1-backpen

      blitx.l = col -startcol + rpx
      blity.l = row -startrow + rpy

      If flags&#MAPRF_BACKGROUND
        argb.l = *map\bgARGB
      Else
        If backpen Then argb.l = #ARGB_GREY:Else argb = #ARGB_LGREY
      End If
      FillPixelArray_ *rp,blitx,blity,1,1,argb

      If col>=0 AND row>=0 AND col<*map\cols AND row<*map\rows
        *tile.maptile = !map_GetTile{col,row}
      Else
        *tile = 0
      End If

      If *tile
        For layer.l=0 To #MAX_MAPLAYERS-1
          If (1 LSL layer) & flags
            mimage.l = *tile\layer[layer]\mimage
            alpha.l  = *tile\layer[layer]\alpha
            If mimage>=0
              multix.l = (*tile\layer[layer]\typ LSR 4) & $F
              multiy.l = (*tile\layer[layer]\typ      ) & $F
              tilex.l = (col MOD multix)*  *map\tile_width
              tiley.l = (row MOD multiy)*  *map\tile_height
              If alpha<0 OR alpha>=#MAX_MAPALPHAS Then aptr.l = 0 : axs.l = -1: Else aptr = mapalpha(alpha)\ptr : axs = mapalpha(alpha)\xs
              Select *tile\layer[layer]\mode
                Case #MAPBM_SUB
                 ; image_FancyBlit{image,blitx,blity,-1,-1,*rp,#image_blitmode_sub,-1,aptr,axs}
                Case #MAPBM_ADD
                 ; image_FancyBlit{image,blitx,blity,-1,-1,*rp,#image_blitmode_add,-1,aptr,axs}
                Case #MAPBM_ALPHA
                  FillPixelArray_ *rp,blitx,blity,1,1,mapimage(mimage)\AvgABGR & $FFFFFF
                Case #MAPBM_IALPHA
                  FillPixelArray_ *rp,blitx,blity,1,1,mapimage(mimage)\AvgABGR & $FFFFFF
                Case #MAPBM_OPAQUE
                  FillPixelArray_ *rp,blitx,blity,1,1,mapimage(mimage)\AvgABGR & $FFFFFF
                Case #MAPBM_TRANS
                  FillPixelArray_ *rp,blitx,blity,1,1,mapimage(mimage)\AvgABGR & $FFFFFF
                Case #MAPBM_MASK
                  FillPixelArray_ *rp,blitx,blity,1,1,mapimage(mimage)\AvgABGR & $FFFFFF
                Case #MAPBM_UNDEFINED
                  FillPixelArray_ *rp,blitx,blity,1,1,mapimage(mimage)\AvgABGR & $FFFFFF
              End Select
            End If
          End If
        Next
      End If
    Next
  Next
End If


ClearList *pindrawlist()

For row.l = startrow To endrow
  For col.l = startcol To endcol
    If col<*map\cols AND row<*map\rows
    *pinhead.mappinhead = !map_GetPinHead{col,row}
    If *pinhead
      For n.l = 0 To *pinhead\useN-1
        ResetList *pindrawlist()
        found.l = False
        While NextItemFast(*pindrawlist()) AND found=False
          If *pindrawlist()=*pinhead\pinlist\pin[n] Then found=True
        Wend
        If found=False
          !map_AddDrawPin{*pindrawlist,*pinhead\pinlist\pin[n] }
        End If
      Next
    End If
    End If
  Next
Next


ResetList *pindrawlist()
While NextItemFast(*pindrawlist())
  *Pin.mappin  = *pindrawlist()
  *obj.mapobject = *Pin\obj
  blitx.l = *Pin\absx / *map\tile_width  + rpx
  blity.l = *Pin\absy / *map\tile_height + rpy
  If flags&#MAPRF_OBJECT
    If *obj\shadowimage>=0 AND *obj\shadowimage<#MAX_MAPIMAGES
      FillPixelArray_ *rp,blitx,blity,1,1,mapimage(*obj\shadowimage)\AvgABGR & $FFFFFF
    End If
  End If
Wend

ResetList *pindrawlist()
While NextItemFast(*pindrawlist())
  *Pin.mappin  = *pindrawlist()
  *obj.mapobject = *Pin\obj
  blitx.l = *Pin\absx / *map\tile_width   + rpx
  blity.l = *Pin\absy / *map\tile_height + rpy

  If flags&#MAPRF_OBJECT
    If *obj\mainimage>=0 AND *obj\mainimage<#MAX_MAPIMAGES
      If *Pin\flags & #MAPPF_SELECTED
        FillPixelArray_ *rp,blitx,blity,1,1,mapimage(*obj\mainimage)\AvgABGR & $FFFFFF
      Else
        FillPixelArray_ *rp,blitx,blity,1,1,mapimage(*obj\mainimage)\AvgABGR & $FFFFFF
      End If
    End If
  End If
  If flags&#MAPRF_HEIGHT
    If *obj\heightimage>=0 AND *obj\heightimage<#MAX_MAPIMAGES
      FillPixelArray_ *rp,blitx,blity,1,1,mapimage(*obj\heightimage)\AvgABGR & $FFFFFF
    End If
  End If
Wend


ClearList *pindrawlist()

If flags&#MAPRF_CLOUD
EndIf

*oldregion.Region = InstallClipRegion_(*rp\Layer, *oldregion)
If *oldregion Then DisposeRegion_ *oldregion
UnlockLayer_ *rp\Layer
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !map_GetHeightMap                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro map_GetHeightMap
base.l = *map\height_matrix +  ((row**map\cols)+col)*SizeOf.mapheightinfo
h1.l = Peek.w(base)
h2.l = Peek.w(base+SizeOf.mapheightinfo)
h3.l = Peek.w(base+(*map\cols+1)*SizeOf.mapheightinfo)
h4.l = Peek.w(base+(*map\cols)*SizeOf.mapheightinfo)

h5.l = (h1+h2+h3+h4)/4

x1.l =  col    * *map\tile_width  - *map\map_x + *map\playfield_x
y1.l =  row    * *map\tile_height - *map\map_y + *map\playfield_y

x2.l = (col+1) * *map\tile_width  - *map\map_x + *map\playfield_x
y2.l =  row    * *map\tile_height - *map\map_y + *map\playfield_y

x3.l = (col+1) * *map\tile_width  - *map\map_x + *map\playfield_x
y3.l = (row+1) * *map\tile_height - *map\map_y + *map\playfield_y

x4.l = (col  ) * *map\tile_width  - *map\map_x + *map\playfield_x
y4.l = (row+1) * *map\tile_height - *map\map_y + *map\playfield_y

x5.l = (x1+x2+x3+x4)/4; +(col * *map\tile_width  - *map\map_x + *map\playfield_x )
y5.l = (y1+y2+y3+y4)/4; +(row * *map\tile_height - *map\map_y + *map\playfield_y )

y1+h1
y2+h2
y3+h3
y4+h4

End Macro



Statement map_CausePinEvent{*pin.mappin}
SHARED mapeventqueue()
If *pin
  If AddItem(mapeventqueue())
    mapeventqueue()\obj       = *pin\obj
    mapeventqueue()\user_data = *pin\user_data
    mapeventqueue()\absx      = *pin\absx
    mapeventqueue()\absy      = *pin\absy
    mapeventqueue()\absz      = *pin\absz
    *pin\flags = (*pin\flags | #MAPPF_ACTIVE) - #MAPPF_ACTIVE  ; /* deactive pin */
  End If
End If
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_Render {*map.mapbase,*rp.RastPort,rpx.l,rpy.l,width.l,height.:: /
;/ l,@flags.l}                                                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Cause events in the given area on the map.
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - xoff.l    : ???                                                            /
;/ - yoff.l    : ???                                                            /
;/ - width.l    : ???                                                          /
;/ - height.l    : ???                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_CauseEvents{*map.mapbase,xoff.l,yoff.l,width.l,height.l}
SHARED mapalpha(),*pindrawlist(),mapimage()
If *map = 0 Then Statement Return

xabs.l = xoff
yabs.l = yoff

startcol.l = xabs / *map\tile_width
startrow.l = yabs / *map\tile_height
endcol.l = (xabs+width ) / *map\tile_width
endrow.l = (yabs+height) / *map\tile_height

ClearList *pindrawlist()

For row.l = startrow To endrow
  For col.l = startcol To endcol
    If col<*map\cols AND row<*map\rows
    *pinhead.mappinhead = !map_GetPinHead{col,row}
    If *pinhead
      For n.l = 0 To *pinhead\useN-1
        ResetList *pindrawlist()
        found.l = False
        While NextItemFast(*pindrawlist()) AND found=False
          If *pindrawlist()=*pinhead\pinlist\pin[n] Then found=True
        Wend
        If found=False
          If AddItem (*pindrawlist())
            *pindrawlist() = *pinhead\pinlist\pin[n]
          End If
        End If
      Next
    End If
    End If
  Next
Next


ResetList *pindrawlist()
While NextItemFast(*pindrawlist())
  *pin.mappin  = *pindrawlist()
  *obj.mapobject = *pin\obj
  If *pin\flags&#MAPPF_ACTIVE
    Select *obj\eventFire            ; fire
      Case #MAPEV_NEVER
        ;-)
      Case #MAPEV_ONVISIBLE
        map_CausePinEvent{*pin}
      Case #MAPEV_ONTOUCH
        ;-) check for hits
      Case #MAPEV_ONINIT
        ;-) not now!
      Case #MAPEV_ONLEAVE
        ;-) Check if pin is not in list anymore
      Case #MAPEV_ONTIMER
        ;-) increase timer and checl

    End Select
  Else
    Select *obj\eventReload            ; releoad
      Case #MAPEV_NEVER
        ;-)
      Case #MAPEV_ONVISIBLE
        *pin\flags | #MAPPF_ACTIVE
      Case #MAPEV_ONTOUCH
        ;-) not now!
      Case #MAPEV_ONINIT
        ;-) not now!
      Case #MAPEV_ONLEAVE
        ;-) check if not visible anymore
      Case #MAPEV_ONTIMER
        ;-) timer...
    End Select
  End If
Wend
End Statement




Function.l map_GetEvent{}
SHARED mapeventqueue(),mapengine
ResetList mapeventqueue()
If NextItemFast(mapeventqueue())
  CopyMem_ &mapeventqueue(),&mapengine\mapevent,SizeOf.mapevent
  KillItem mapeventqueue()
  Function Return &mapengine\mapevent
End If
Function Return #NULL
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_Render {*map.mapbase,*rp.RastPort,rpx.l,rpy.l,width.l,height.:: /
;/ l,@flags.l}                                                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Render a map to a given rastport at the given rastport coordinates          /
;/ This function respects the current offset of the map, set by                /
;/ map_ScrollTo.                                                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - *rp.RastPort    : ???                                                     /
;/ - rpx.l    : ???                                                            /
;/ - rpy.l    : ???                                                            /
;/ - width.l    : ???                                                          /
;/ - height.l    : ???                                                         /
;/ - flags.l    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////


Statement map_Render{*map.mapbase,*rp.RastPort,rpx.l,rpy.l,width.l,height.l,@flags.l}
SHARED mapalpha(),*pindrawlist(),mapimage()
If *map = 0 Then Statement Return
If *rp  = 0 Then Statement Return
If flags = -1 Then flags = #MAPRF_INGAME

If rpx<0 Then width+rpx:rpx=0
If rpy<0 Then height+rpy:rpy=0

rect.Rectangle\MinX = rpx           ;+*map\playfield_x
rect\MinY           = rpy           ;+*map\playfield_y
rect\MaxX           = rpx+width -1
rect\MaxY           = rpy+height-1
*newregion.Region = NewRegion_()
LockLayer_ 0,*rp\Layer
If *newregion
  If OrRectRegion_(*newregion, &rect)
    *oldregion.Region = InstallClipRegion_(*rp\Layer, *newregion)
  End If
End If

mapDepth.l = GetBitMapAttr_(*rp\BitMap,#BMA_DEPTH)

xabs.l = rpx + *map\map_x - *map\playfield_x
yabs.l = rpy + *map\map_y - *map\playfield_y

startcol.l = xabs / *map\tile_width
startrow.l = yabs / *map\tile_height
endcol.l = (xabs+width ) / *map\tile_width
endrow.l = (yabs+height) / *map\tile_height

If flags&#MAPRF_BACKGROUND
  For row.l = startrow To endrow
    backpen.l = ((row +startcol) MOD 2)
    For col.l = startcol To endcol
      blitx.l = col * *map\tile_width  - *map\map_x + *map\playfield_x
      blity.l = row * *map\tile_height - *map\map_y + *map\playfield_y
      argb.l = *map\bgARGB
      If mapDepth>8
        FillPixelArray_ *rp,blitx,blity,*map\tile_width,*map\tile_height,argb
      Else
        SetAPen_ *rp,0
        RectFill_ *rp,blitx,blity,blitx+*map\tile_width-1,blity+*map\tile_height-1
      End If
    Next
  Next
Else

  If flags&#MAPRF_CHECKERBOARD
    For row.l = startrow To endrow
      backpen.l = ((row +startcol) MOD 2)
      For col.l = startcol To endcol
        blitx.l = col * *map\tile_width  - *map\map_x + *map\playfield_x
        blity.l = row * *map\tile_height - *map\map_y + *map\playfield_y
        backpen=1-backpen
        If backpen Then argb.l = #ARGB_GREY:Else argb = #ARGB_LGREY
        If mapDepth>8 Then FillPixelArray_ *rp,blitx,blity,*map\tile_width,*map\tile_height,argb
      Next
    Next
  End If

End If


If flags&(#MAPRF_LAYERS|#MAPRF_CARPET)
  For row.l = startrow To endrow
    backpen.l = ((row +startcol) MOD 2)
    For col.l = startcol To endcol
      backpen=1-backpen

      If col>=0 AND row>=0 AND col<*map\cols AND row<*map\rows
        *tile.maptile = !map_GetTile{col,row}
      Else
        *tile = 0
      End If

      If *tile
        ;!map_GetHeightMap

        ;If h1=h2 AND h1=h3 AND h1=h4
          blitx.l = col * *map\tile_width  - *map\map_x + *map\playfield_x
          blity.l = row * *map\tile_height - *map\map_y + *map\playfield_y ;+ h1
          *brp.RastPort = *rp
          stretch.l = False
;        Else
;          If *map\renderimage<0
;            *map\renderimage = image_GetFree{}
;            If *map\renderimage>=0
;              If image_Create{*map\renderimage,*map\tile_width,*map\tile_height} = False
;                *map\renderimage = -1
;              End If
;            End If
;          End If
;          If *map\renderimage>=0
;            *brp.RastPort = image_GetRPPtr{*map\renderimage}
;            blitx=0
;            blity=0
;            stretch.l = True
;          Else
;            Statement Return
;          End If
;        End If

        For layer.l=0 To #MAX_MAPLAYERS-1
          If (1 LSL layer) & flags
            mimage.l = *tile\layer[layer]\mimage
            alpha.l  = *tile\layer[layer]\alpha
            If mimage>=0
              image.l = map_LockImage{mimage,*map}
              If image>=0
                multix.l = (*tile\layer[layer]\typ LSR 4) & $F
                multiy.l = (*tile\layer[layer]\typ      ) & $F
                tilex.l = (col MOD multix) *  *map\tile_width
                tiley.l = (row MOD multiy) *  *map\tile_height
                image_SetBlitDims{image,tilex,tiley,*map\tile_width,*map\tile_height}
                If alpha<0 OR alpha>=#MAX_MAPALPHAS Then aptr.l = 0 : axs.l = -1: Else aptr = mapalpha(alpha)\ptr : axs = mapalpha(alpha)\xs

                Select *tile\layer[layer]\mode
                  Case #MAPBM_SUB
                    If mapDepth>8 Then image_FancyBlit{image,blitx,blity,-1,-1,*brp,#image_blitmode_sub,-1,aptr,axs}
                  Case #MAPBM_ADD
                    If mapDepth>8 Then image_FancyBlit{image,blitx,blity,-1,-1,*brp,#image_blitmode_add,-1,aptr,axs}
                  Case #MAPBM_ALPHA
                    If mapDepth>8
                      image_FancyBlit{image,blitx,blity,-1,-1,*brp,#image_blitmode_alpha,-1,aptr,axs}
                    Else
                      image_BlitMask {image,blitx,blity,*brp}
                    End If
                  Case #MAPBM_IALPHA
                    If mapDepth>8 Then image_FancyBlit{image,blitx,blity,-1,-1,*brp,#image_blitmode_invalpha,-1,aptr,axs}
                  Case #MAPBM_OPAQUE
                    image_Draw{image,blitx,blity,*brp}
                  Case #MAPBM_TRANS
                    If mapDepth>8
                      image_FancyBlit{image,blitx,blity,-1,-1,*brp,#image_blitmode_trans,128 }
                    Else
                      image_Blit{image,blitx,blity,*brp}
                    End If
                  Case #MAPBM_MASK
                    image_BlitMask {image,blitx,blity,*brp}
                    ;image_FancyBlit{image,blitx,blity,-1,-1,*brp,#image_blitmode_alpha,-1}
                  Case #MAPBM_UNDEFINED
                    image_Draw{image,blitx,blity,*brp}
                End Select
              End If
            End If
          End If
        Next

;        If stretch
;          coos.texturearray\x1 = x1,y1
;          coos.texturearray\x2 = x2,y2
;          coos.texturearray\x3 = x3,y3
;          coos.texturearray\x4 = x4,y4
;
;          a1.f = *map\tile_width
;          a2.f = (h3-h1) * 1.1547005;383792515290182975610039
;          a3.f = *map\tile_height *2
;
;          b1.f = *map\tile_width
;          b2.f = (h4-h2) * 1.1547005
;          b3.f =-*map\tile_height *2
;
;          n1.f = a2*b3 - a3*b2
;          n2.f = a3*b1 - a1*b3
;          n3.f = a1*b2 - a2*b1
;
;          s1.f = 1
;          s2.f = 1
;          s3.f = -1
;
;          nl.f = Sqr(n1*n1 + n2*n2 + n3*n3)
;          sl.f = Sqr(s1*s1 + s2*s2 + s3*s3)
;
;          a.f = ((n1*s1 + n2*s2 + n3*s3) / (nl*sl))
;          If a<0.5 Then a=0.5
;          bright.f = (2.2-a*2) * 256.0
;          image_TextureBlit{*map\renderimage,coos,bright,True,True,*rp}
;;
;;          hr.f = *map\tile_width
;;          hf.f = hr / 1.7320508 ; hr = sqr(hf*hf+hf*hf+hf*hf) = hf * sqr(3)
;;
;;
;;          n1/nl * hf
;;          n2/nl * hf
;;          n3/nl * hf
;;
;;          ; projection 2D
;;          o1.f = n3
;;          o2.f = n2/2         ; 1/sin(30)
;;          o2   + n1/1.1547005 ; 1/cos(30)
;;
;;          mx.f = (x1+x2+x3+x4)/4
;;          my.f = (y1+y2+y3+y4)/4
;;          Move_ *rp,mx,my
;;          Draw_ *rp,mx-o1,my-o2
;        End If
      End If
    Next
  Next
End If


ClearList *pindrawlist()

For row.l = startrow To endrow
  For col.l = startcol To endcol
    If col<*map\cols AND row<*map\rows
      *pinhead.mappinhead = !map_GetPinHead{col,row}
      If *pinhead
        For n.l = 0 To *pinhead\useN-1
          ResetList *pindrawlist()
          found.l = False
          While NextItemFast(*pindrawlist()) AND found=False
            If *pindrawlist()=*pinhead\pinlist\pin[n] Then found=True
          Wend
          If found=False
            !map_AddDrawPin{*pindrawlist,*pinhead\pinlist\pin[n]}
          End If
        Next
      End If
    End If
  Next
Next


ResetList *pindrawlist()
While NextItemFast(*pindrawlist())
  *pin.mappin  = *pindrawlist()
  *obj.mapobject = *pin\obj
  rpx.l = *pin\absx - *map\map_x + *map\playfield_x
  rpy.l = *pin\absy - *map\map_y + *map\playfield_y
  If flags&#MAPRF_OBJECT
    If *obj\shadowimage>=0 AND *obj\shadowimage<#MAX_MAPIMAGES
      image.l = map_LockImage{*obj\shadowimage,*map}
      If image>=0 Then image_FancyBlit{image,rpx,rpy,-1,-1,*rp,#image_blitmode_alpha ,*obj\shadowdepth}
    End If
  End If
Wend

ResetList *pindrawlist()
While NextItemFast(*pindrawlist())
  *pin.mappin  = *pindrawlist()
  *obj.mapobject = *pin\obj
  rpx.l = *pin\absx - *map\map_x + *map\playfield_x
  rpy.l = *pin\absy - *map\map_y + *map\playfield_y
  If flags&#MAPRF_OBJECT
    If *obj\mainimage>=0 AND *obj\mainimage<#MAX_MAPIMAGES
      image.l = map_LockImage{*obj\mainimage,*map}
      If image>=0
        If *pin\flags & #MAPPF_SELECTED
          image_FancyBlit{image,rpx,rpy,-1,-1,*rp,#image_blitmode_alpha,196}
        Else
          Select *obj\bltmode
            Case #MAPBM_SUB
              If mapDepth>8 Then image_FancyBlit{image,rpx,rpy,-1,-1,*rp,#image_blitmode_sub,-1}
            Case #MAPBM_ADD
              If mapDepth>8 Then image_FancyBlit{image,rpx,rpy,-1,-1,*rp,#image_blitmode_add,-1}
            Case #MAPBM_ALPHA
              If mapDepth>8
                image_FancyBlit{image,rpx,rpy,-1,-1,*rp,#image_blitmode_alpha,-1}
              Else
                image_BlitMask {image,rpx,rpy,*rp}
              End If
            Case #MAPBM_IALPHA
              If mapDepth>8 Then image_FancyBlit{image,rpx,rpy,-1,-1,*rp,#image_blitmode_invalpha,-1}
            Case #MAPBM_OPAQUE
              image_Draw{image,rpx,rpy,*rp}
            Case #MAPBM_TRANS
              If mapDepth>8
                image_FancyBlit{image,rpx,rpy,-1,-1,*rp,#image_blitmode_trans,128 }
              Else
                image_Blit{image,rpx,rpy,*rp}
              End If
            Case #MAPBM_MASK
              image_BlitMask {image,rpx,rpy,*rp}
            Case #MAPBM_UNDEFINED
              image_Draw{image,rpx,rpy,*rp}
            Case #MAPBM_INVISIBLE
              If flags&#MAPRF_EVENTS
                image_FancyBlit{image,rpx,rpy,-1,-1,*rp,#image_blitmode_alpha,128}
              End If
          End Select
        End If
      End If
    End If
  End If

  If flags&#MAPRF_HEIGHT
    If *obj\heightimage>=0 AND *obj\heightimage<#MAX_MAPIMAGES
      image.l = map_LockImage{*obj\heightimage,*map}
      If image>=0 Then image_FancyBlit{image,rpx,rpy,-1,-1,*rp,#image_blitmode_add }
    End If
  End If

Wend


ClearList *pindrawlist()

If flags&#MAPRF_CLOUD
EndIf


If flags&(#MAPRF_HEIGHTGRID|#MAPRF_GRID)
  SetDrMd_ *rp,#JAM1
  If endrow>=*map\rows Then endrow = *map\rows
  If endcol>=*map\cols Then endcol = *map\cols
  For row.l = startrow To endrow
    For col.l = startcol To endcol
      !map_GetHeightMap
      ;m1.f = x5
      ;m2.f = y5 + h5;/2         ; 1/sin(30)
      ;m2   + h5/1.1547005 ; 1/cos(30)
      If flags&#MAPRF_HEIGHTGRID
        m1.l = (x1+x2+x3+x4)/4
        m2.l = (y1+y2+y3+y4)/4
        SetAPen_ *rp,2
        Move_ *rp,x1, y1 : Draw_ *rp,m1,m2
        Move_ *rp,x2 ,y2 : Draw_ *rp,m1,m2
        Move_ *rp,x3 ,y3 : Draw_ *rp,m1,m2
        Move_ *rp,x4 ,y4 : Draw_ *rp,m1,m2
      End If

      If flags&#MAPRF_GRID
        SetAPen_ *rp,1
        Move_ *rp,x1 ,y1 : Draw_ *rp,x2,y2
        Move_ *rp,x1, y1 : Draw_ *rp,x4,y4
      End If
    Next
  Next
End If
 


*oldregion.Region = InstallClipRegion_(*rp\Layer, *oldregion)
If *oldregion Then DisposeRegion_ *oldregion
UnlockLayer_ *rp\Layer
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_ScrollTo {*map.mapbase,xoffset.l,yoffset.l}                     /
;/                                                                             /
;/ Description:                                                                /
;/ Scroll the map to the given pixel coordinates. map_Render will              /
;/ automatically respect those offsets.                                        /
;/ Note: Nothing will be redrawn, this function simply sets the offset param:: /
;/ eters.                                                                      /
;/ you have to take care about the refreshing, which can be a complete redra:: /
;/ w  using map_Render, but also a ScrollRastPort_ and a subsequent restaura:: /
;/ tion of the newly-scrolled-in areas.                                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - xoffset.l    : ???                                                        /
;/ - yoffset.l    : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_ScrollTo{*map.mapbase,xoffset.l,yoffset.l}
map_SetAttrs{*map,Tags(#MAPA_MAPX,xoffset,#MAPA_MAPY,yoffset)}
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_X2Tile {*map.mapbase,x.l}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Convert screen pixel coordinates to a tile offset number.                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : pointer to map                                                     /
;/ - x.l             : x pixel coordinate                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l        : tile column                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_X2Tile{*map.mapbase,x.l}
tilex.l = (x+*map\map_x) / *map\tile_width
Function Return tilex
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_Y2Tile {*map.mapbase,y.l}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Convert screen pixel coordinates to a tile offset number.                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : pointer to map                                                     /
;/ - y.l             : y pixel coordinate                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l        : tile row                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_Y2Tile{*map.mapbase,y.l}
tiley.l = (y+*map\map_y) / *map\tile_height
Function Return tiley
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_CreatePin {*obj.mapobject,x.l,y.l,@z.l,@user_data:: /
;/ .l,@flags.l}                                                                /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *obj.mapobject    : ???                                                   /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/ - z.l    : ???                                                              /
;/ - user_data.l    : ???                                                      /
;/ - flags.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_CreatePin{*obj.mapobject,x.l,y.l,@z.l,@user_data.l,@flags.l}
*pin.mappin = AllocVec_(SizeOf.mappin,#MEMF_ANY)
If *pin
  *pin\obj = *obj
  *pin\absx = x
  *pin\absy = y
  *pin\absz = z
  *pin\user_data = user_data
  If flags=-1 Then flags=0
  *pin\flags     = flags | #MAPPF_ACTIVE
End If
Function Return *pin
End Function
 



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_PinObject {*pinhead.mappinhead,*pin.mappin}         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *pinhead.mappinhead    : ???                                              /
;/ - objID.l    : ???                                                          /
;/ - *pin.mappin    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _map_AddPinToTile{*pinhead.mappinhead,*pin.mappin}
succ.l = False
If *pinhead
  If *pinhead\useN>=*pinhead\allocN
    newallocN.l = *pinhead\useN+2
    pinlist.l = AllocVec_(newallocN*SizeOf.l,#MEMF_CLEAR)
    If pinlist
      If *pinhead\pinlist
        CopyMem_ *pinhead\pinlist,pinlist,SizeOf.l**pinhead\useN
        FreeVec_ (*pinhead\pinlist)
      End If
      *pinhead\allocN  = newallocN
    End If
    *pinhead\pinlist = pinlist
  End If
  If *pinhead\pinlist
    *pinhead\pinlist\pin[*pinhead\useN]  = *pin
    *pinhead\useN +1
  End If
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_DePinObject {*pinhead.mappinhead,*obj.mapobject}    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *pinhead.mappinhead    : ???                                              /
;/ - objID.l    : ???                                                          /
;/ - *obj.mapobject    : ???                                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _map_RemPinFromTile{*pinhead.mappinhead,*pin.mappin}
succ.l = False
If *pinhead
  If *pinhead\pinlist
    n.l = 0
    While n<*pinhead\useN
      If *pinhead\pinlist\pin[n]  = *pin
        For m.l = n To *pinhead\useN-2
          *pinhead\pinlist\pin[m] = *pinhead\pinlist\pin[m+1]
        Next
        n=*pinhead\useN
        *pinhead\useN -1
        succ=True
      Else
        n+1
      End If
    Wend
  End If
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_LayoutPin {*map.mapbase,*pin.mappin,set.l}                      /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - objID.l    : ???                                                          /
;/ - set.l    : ???                                                            /
;/ - *pin.mappin    : ???                                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_LayoutPin{*map.mapbase,*pin.mappin,set.l}
If *pin
  *obj.mapobject = *pin\obj
  If *obj
    ; calculate the bounds
    minx.l = *pin\absx+*obj\bound_x1
    miny.l = *pin\absy+*obj\bound_y1
    maxx.l = *pin\absx+*obj\bound_x2
    maxy.l = *pin\absy+*obj\bound_y2
    mincol.l = minx / *map\tile_width  + *map\index_cols : If mincol<0 Then mincol=0
    minrow.l = miny / *map\tile_height + *map\index_rows : If minrow<0 Then minrow=0
    maxcol.l = maxx / *map\tile_width  + *map\index_cols : If maxcol>*map\cols-1 Then maxcol = *map\cols-1
    maxrow.l = maxy / *map\tile_height + *map\index_rows : If maxrow>*map\rows-1 Then maxrow = *map\rows-1

    For row.l = minrow To maxrow
      For col.l = mincol To maxcol
        *pinhead.mappinhead = !map_GetPinHead{col,row}
        If set
          If *pinhead=0
            *pinhead = AllocVec_(SizeOf.mappinhead,#MEMF_CLEAR)
            *pinhead\useN    = 0
            *pinhead\allocN  = 0
            *pinhead\pinlist = 0
            !map_SetPinHead{*pinhead,col,row}
          End If
          If *pinhead Then _map_AddPinToTile{*pinhead,*pin}
        Else
          If *pinhead Then _map_RemPinFromTile{*pinhead,*pin}
        End If
      Next
    Next
  End If
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_SetObject {*map.mapbase,*obj.mapobject,absx.l,abs:: /
;/ y.l,@absz.l}                                                                /
;/                                                                             /
;/ Description:                                                                /
;/ Set an object to the map and return a handle that identifies                /
;/ this instance of the object                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - *obj.mapobject    : ???                                                   /
;/ - absx.l    : ???                                                           /
;/ - absy.l    : ???                                                           /
;/ - absz.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_SetObject{*map.mapbase,*obj.mapobject,absx.l,absy.l,@absz.l}
*pin.mappin = map_CreatePin{*obj,absx,absy,absz};AllocVec_(SizeOf.mappin,#MEMF_CLEAR)
If *pin Then map_LayoutPin{*map,*pin,On}
Function Return *pin
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_RemPin {*map.mapbase,*pin.mappin}                               /
;/                                                                             /
;/ Description:                                                                /
;/ Remove an object from the map.                                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase   : map that carries the pin                                                    /
;/ - *pin.mappin    : pin to remove                                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_RemPin{*map.mapbase,*pin.mappin}
If *pin
  map_LayoutPin{*map,*pin,Off}
  FreeVec_ *pin
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_MovePin {*map.mapbase,*pin.mappin,absx.l,absy.l}    /
;/                                                                             /
;/ Description:                                                                /
;/ Move an pin on the map.                                                  /
;/ NOTE: this is much more efficient than removing a pin and setting it :: /
;/ again.                                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - *pin.mappin     : ???                                                      /
;/ - absx.l          : ???                                                           /
;/ - absy.l          : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l        : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_MovePin{*map.mapbase,*pin.mappin,absx.l,absy.l}
If *pin
  If *pin\absx><absx OR *pin\absy><absy
    map_LayoutPin{*map,*pin,Off}
    *pin\absx = absx
    *pin\absy = absy
    map_LayoutPin{*map,*pin,On}
    Function Return -1
  End If
End If
Function Return 0
End Function

Statement map_MoveObject{*map.mapbase,*obj.mapobject,dx.l,dy.l}
 SHARED *pindrawlist()
 ClearList *pindrawlist()

 For row.l = 0 To *map\useRows-1
   For col.l = 0 To *map\useCols-1
     *pinhead.mappinhead = !map_GetPinHead{col,row}
     If *pinhead
       If *pinhead\pinlist
         n.l = 0
         While n<*pinhead\useN
           *pin.mappin = *pinhead\pinlist\pin[n]
           If *pin\obj  = *obj
             done.l = False
             ResetList *pindrawlist()
             While NextItemFast(*pindrawlist())
               If *pindrawlist() = *pin Then done=True
             Wend
             If done= False
               If AddItem(*pindrawlist())
                 *pindrawlist() = *pin
               End If
             End If
           End If
           n+1
         Wend
       End If
     End If
   Next
 Next

  ResetList *pindrawlist()
  While NextItemFast(*pindrawlist())
    map_MovePin{*map,*pindrawlist(),*pindrawlist()\absx+dx,*pindrawlist()\absy+dy}
  Wend

End Statement


Statement map_ForceEvenPosition{*map.mapbase}
 SHARED *pindrawlist()
 ClearList *pindrawlist()

 For row.l = 0 To *map\useRows-1
   For col.l = 0 To *map\useCols-1
     *pinhead.mappinhead = !map_GetPinHead{col,row}
     If *pinhead
       If *pinhead\pinlist
         n.l = 0
         While n<*pinhead\useN
           *pin.mappin = *pinhead\pinlist\pin[n]
           ;If *pin\obj  = *obj
             done.l = False
             ResetList *pindrawlist()
             While NextItemFast(*pindrawlist())
               If *pindrawlist() = *pin Then done=True
             Wend
             If done= False
               If AddItem(*pindrawlist())
                 *pindrawlist() = *pin
               End If
             End If
           ;End If
           n+1
         Wend
       End If
     End If
   Next
 Next

  ResetList *pindrawlist()
  While NextItemFast(*pindrawlist())
    img.l = *pindrawlist()\obj\mainimage
    If img>=0
      imagedat(img)\handle_x &$FFFFFFFE
      imagedat(img)\handle_y &$FFFFFFFE
    End If
    map_MovePin{*map,*pindrawlist(),*pindrawlist()\absx&$FFFFFFFE,*pindrawlist()\absy&$FFFFFFFE}
  Wend

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetPinX {*pin.mappin}                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - objID.l    : ???                                                          /
;/ - *pin.mappin    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetPinX{*pin.mappin}
If *pin Then Function Return *pin\absx
Function Return 0
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetPinY {*pin.mappin}                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - objID.l    : ???                                                          /
;/ - *pin.mappin    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetPinY{*pin.mappin}
If *pin Then Function Return *pin\absy
Function Return 0
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetPinObject {*pin.mappin}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Get the object of the pin.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *pin.mappin   : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l      : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetPinObject{*pin.mappin}
If *pin Then Function Return *pin\obj
Function Return 0
End Function
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_HitPin {*map.mapbase,absx.l,absy.l,@absz.l}         /
;/                                                                             /
;/ Description:                                                                /
;/ Check the given  coordinates and return an object handle,                   /
;/ if any object was hit. If absz is omitted, the hit will be                  /
;/ performed "from sky", useful for map editors. Otherwise the                 /
;/ hit will respect the height of the in-game-pixel, useful for                /
;/ in-game hitting                                                             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - absx.l    : ???                                                           /
;/ - absy.l    : ???                                                           /
;/ - absz.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_HitPin{*map.mapbase,absx.l,absy.l,@absz.l}
SHARED *pindrawlist(),mapimage()
*respin.mappin = 0
If absz=-1
  col.l = absx / *map\tile_width
  row.l = absy / *map\tile_height
  If col>=0 AND row>=0 AND col<*map\cols AND row<*map\rows
    *pinhead.mappinhead = !map_GetPinHead{col,row}
    If *pinhead
      ClearList *pindrawlist()
      For n.l = 0 To *pinhead\useN-1
        !map_AddDrawPin{*pindrawlist,*pinhead\pinlist\pin[n] }
      Next
      ResetList *pindrawlist()
      While NextItemFast(*pindrawlist()); AND objID=-1 ; <= this would select the most-behind object!
        *pin.mappin  = *pindrawlist()
        *obj.mapobject = *pin\obj
        ix.l = absx - *pin\absx + mapimage(*obj\mainimage)\hotx
        iy.l = absy - *pin\absy + mapimage(*obj\mainimage)\hoty
        If ix>=0 AND ix<mapimage(*obj\mainimage)\xs
          If iy>=0 AND iy<mapimage(*obj\mainimage)\ys
            image.l = map_LockImage{*obj\mainimage,*map}
            If image>=0
              A.l =  image_GetOpacity{image,ix,iy}
              If A><0 Then *respin = *pindrawlist()
            End If
          End If
        End If
      Wend
    End If
  End If
End If
Function Return *respin
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_GetHeight {*map.mapbase,absx.l,absy.l}              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - absx.l    : ???                                                           /
;/ - absy.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_GetHeight{*map.mapbase,absx.l,absy.l}
SHARED mapimage()
col.l = absx / *map\tile_width
row.l = absy / *map\tile_height

height.l = 0 ; get from tile
If col>=0 AND row>=0 AND col<*map\cols AND row<*map\rows
  *pinhead.mappinhead = !map_GetPinHead{col,row}
  If *pinhead
    For n.l = 0 To *pinhead\useN-1
      *pin.mappin    = *pinhead\pinlist\pin[n]
      *obj.mapobject = *pin\obj
      If *obj\heightimage>=0
        image.l = map_LockImage{*obj\heightimage}
        If image>=0
          ix.l = absx - *pin\absx + image_GetHandleX{image}
          iy.l = absy - *pin\absy + image_GetHandleY{image}
          If ix>=0 AND ix<image_GetWidth{image}
            If iy>=0 AND iy<image_GetHeight{image}
              height + ((image_GetRGB{image,ix,iy} LSR 16) AND $FF)
            End If
          End If
        End If
      End If
    Next
  End If
End If
Function Return height
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_CreateTile {}                                       /
;/                                                                             /
;/ Description:                                                                /
;/ Create a new tile. This is only for internal use.                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_CreateTile{}
SHARED *tilelist()
*tile.maptile = AllocVec_(SizeOf.maptile,#MEMF_CLEAR)
If *tile
  For layer.l = 0 To #MAX_MAPLAYERS-1
    *tile\layer[layer]\mode    = #MAPBM_UNDEFINED
    *tile\layer[layer]\mimage  = -1
    *tile\layer[layer]\alpha   = -1
  Next
  If AddItem(*tilelist())
    *tilelist() = *tile
  End If
End If
Function Return *tile
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_FreeTile {*tile.maptile}                            /
;/                                                                             /
;/ Description:                                                                /
;/ Free a tile. Internal use only.                                             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *tile.maptile    : ???                                                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_FreeTile{*tile.maptile}
SHARED *tilelist()
If *tile
  ResetList *tilelist()
  While NextItemFast(*tilelist())
    If *tilelist() = *tile Then KillItem *tilelist()
  Wend
  FreeVec_ *tile
End If
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_FindMapImageByName {filename.s}                     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_FindMapImageByName{filename.s}
SHARED mapimage()
For mimage.l = 0 To #MAX_MAPIMAGES-1
  If mapimage(mimage)\is_used
    If mapimage(mimage)\filename = filename Then Function Return mimage
  End If
Next
Function Return -1
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_UpdateObject {*obj.mapobject}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Calculate the new bounding box of an object.                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *obj.mapobject    : ???                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_UpdateObject{*obj.mapobject}
SHARED mapimage()
If *obj
  If *obj\mainimage>=0
    image.l = map_LockImage{*obj\mainimage}
    If image>=0
      mx1.l    = -image_GetHandleX{image}
      my1.l    = -image_GetHandleY{image }
      mx2.l    = mx1 + image_GetWidth{image }-1
      my2.l    = my1 + image_GetHeight{image }-1
    End If
  End If

  If *obj\shadowimage>=0
    image.l = map_LockImage{*obj\shadowimage}
    If image>=0
    sx1.l    = -image_GetHandleX{image}
    sy1.l    = -image_GetHandleY{image }
    sx2.l    = sx1 + image_GetWidth{image }-1
    sy2.l    = sy1 + image_GetHeight{image }-1
    End If
  End If

  If *obj\heightimage>=0
    image.l = map_LockImage{*obj\heightimage}
    If image>=0
    hx1.l    = -image_GetHandleX{image}
    hy1.l    = -image_GetHandleY{image }
    hx2.l    = hx1 + image_GetWidth{image }-1
    hy2.l    = hy1 + image_GetHeight{image }-1
    End If
  End If

  *obj\bound_x1    = Min(Min(mx1,sx1),hx1)
  *obj\bound_y1    = Min(Min(my1,sy1),hy1)
  *obj\bound_x2    = Max(Max(mx2,sx2),hx2)
  *obj\bound_y2    = Max(Max(my2,sy2),hy2)
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_CreateObject {name.s,vm.f,@mainimage.l,@shadowima:: /
;/ ge.l,@heightimage.l,@user_data.l,@shadowdepth.l}                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - name.s    : ???                                                           /
;/ - vm.f    : ???                                                             /
;/ - mainimage.l    : ???                                                      /
;/ - shadowimage.l    : ???                                                    /
;/ - heightimage.l    : ???                                                    /
;/ - user_data.l    : ???                                                      /
;/ - shadowdepth.l    : ???                                                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_CreateObject{name.s,vm.f,@mainimage.l,@shadowimage.l,@heightimage.l,@user_data.l,@shadowdepth.l,@bltmode.l}
SHARED *objlist(),mapimage()
*obj.mapobject = AllocVec_(SizeOf.maptile,#MEMF_CLEAR)
If *obj
  If AddItem(*objlist())
    *objlist() = *obj
  End If

  If mainimage<0   Then mainimage   = -1
  If shadowimage<0 Then shadowimage = -1
  If heightimage<0 Then heightimage = -1
  If shadowdepth<0 Then shadowdepth = 128
  If bltmode<0     Then bltmode = #MAPBM_OPAQUE

  *obj\mainimage   = mainimage
  *obj\bltmode     = bltmode
  *obj\heightimage = heightimage
  *obj\shadowimage = shadowimage
  *obj\shadowdepth = shadowdepth
  *obj\vm          = vm
  *obj\user_data   = user_data
  *obj\flags       = 0
  *obj\shadowdepth = 128
  *obj\eventFire   = #MAPEV_NEVER
  *obj\eventReload = #MAPEV_NEVER
  map_UpdateObject{*obj}
  If name.s><"" Then str_Write {&*obj\name,name}
End If
Function Return *obj
End Function

Statement map_SetEvent{*obj.mapobject,eventFire.l,eventReload.l}
*obj\eventFire   = eventFire
*obj\eventReload = eventReload
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_ObjectExist {name.s,vm.f,@mainimage.l,@shadowimag:: /
;/ e.l,@heightimage.l,@user_data.l}                                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - name.s    : ???                                                           /
;/ - vm.f    : ???                                                             /
;/ - mainimage.l    : ???                                                      /
;/ - shadowimage.l    : ???                                                    /
;/ - heightimage.l    : ???                                                    /
;/ - user_data.l    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_ObjectExist{name.s,vm.f,@mainimage.l,@shadowimage.l,@heightimage.l,@user_data.l}
SHARED *objlist(),mapimage()
ResetList *objlist()
While NextItemFast(*objlist())
  *obj.mapobject = *objlist()
  issame.l=True
  If mainimage   >< *obj\mainimage   Then issame=False
  If shadowimage >< *obj\shadowimage Then issame=False
  If heightimage >< *obj\heightimage Then issame=False

  If *obj\vm          >< vm          Then issame=False
  If *obj\user_data   >< user_data   Then issame=False
  If issame
    rname.s = str_Read {&*obj\name}
    If rname.s          >< name Then issame=False
  End If
  If issame Then Function Return *obj
Wend
Function Return 0
End Function
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_FreeObject {*obj.mapobject}                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *obj.mapobject    : ???                                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_FreeObject{*obj.mapobject}
SHARED *objlist()
If *obj
  ResetList *objlist()
  While NextItemFast(*objlist())
    If *objlist() = *obj Then KillItem *objlist()
  Wend
  FreeVec_ *obj
End If
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_Trim {*map.mapbase}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_Trim{*map.mapbase}
SHARED mapengine
maxcol.l = 0
maxrow.l = 0
For row.l=0 To *map\rows-1
  For col.l=0 To *map\cols-1
    *tile.maptile = !map_GetTile{col,row}
    *pinhead.mappinhead = !map_GetPinHead{col,row}
    If *tile
      succ.l = False
      For layer.l =0 To #MAX_MAPLAYERS-1
        If *tile\layer[layer]\mimage>=0 Then succ=True
      Next
      If succ=False Then Poke.l *map\tile_matrix + SizeOf.mapheightinfo*(row**map\cols+col),0
    End If
    ;If *pinhead><0 OR
    If *tile><0
      If col>maxcol Then maxcol = col
      If row>maxrow Then maxrow = row
    End If
  Next
Next
*map\useCols = maxcol+1
*map\useRows = maxrow+1
End Function




;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_SetTile {*map.mapbase,col.l,row.l,layer.l,@mimage:: /
;/ .l,@alpha.l,@mode.l}                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - col.l    : ???                                                            /
;/ - row.l    : ???                                                            /
;/ - layer.l    : ???                                                          /
;/ - mimage.l    : ???                                                         /
;/ - alpha.l    : ???                                                          /
;/ - mode.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_SetTile{*map.mapbase,col.l,row.l,layer.l,@mimage.l,@alpha.l,@mode.l}
SHARED mapimage()
If map_Resize{*map,col,row}
  col + *map\index_cols
  row + *map\index_rows
  If col>=*map\useCols Then *map\useCols=col+1
  If row>=*map\useRows Then *map\useRows=row+1
  *tile.maptile = !map_GetTile{col,row}
  If *tile=0
    *tile = map_CreateTile{}
  End If
  If *tile
    If mimage>=0 AND mimage<#MAX_MAPIMAGES
      *tile\layer[layer]\mimage = mimage
      multix.l = mapimage(mimage)\xs / *map\tile_width
      multiy.l = mapimage(mimage)\ys / *map\tile_height
      *tile\layer[layer]\typ = ((multix LSL 4 ) | multiy) & $FF
      If *tile\layer[layer]\mode = #MAPBM_UNDEFINED
        *tile\layer[layer]\mode = #MAPBM_OPAQUE
      End If
    End If
    If alpha>=0 AND alpha<#MAX_MAPALPHAS Then *tile\layer[layer]\alpha = alpha
    If mode  ><-1 Then *tile\layer[layer]\mode  = mode
  End If
  Poke.l *map\tile_matrix + SizeOf.l*(*map\cols*row + col),*tile
  succ.l = -1
Else
  succ = 0
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_RemTile {*map.mapbase,col.l,row.l,layer.l}                      /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - col.l    : ???                                                            /
;/ - row.l    : ???                                                            /
;/ - layer.l    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement map_RemTile{*map.mapbase,col.l,row.l,layer.l}
SHARED mapimage()
col + *map\index_cols
row + *map\index_rows
If col<*map\cols AND row<*map\rows AND col>=0 AND row>=0
  *tile.maptile = !map_GetTile{col,row}
  If *tile
    *tile\layer[layer]\mimage = -1
    *tile\layer[layer]\mode   = #MAPBM_UNDEFINED
    *tile\layer[layer]\alpha  = -1
  End If
End If
End Statement



Function.s _map_BltMode2Str{bltmode.l}
  Select bltmode
    Case #MAPBM_INVISIBLE : a.s = "invisible"
    Case #MAPBM_ALPHA     : a.s = "alpha"
    Case #MAPBM_IALPHA    : a.s = "ialpha"
    Case #MAPBM_ADD       : a.s = "add"
    Case #MAPBM_SUB       : a.s = "sub"
    Case #MAPBM_OPAQUE    : a.s = "opaque"
    Case #MAPBM_TRANS     : a.s = "trans"
    Case #MAPBM_MASK      : a.s = "mask"
    Case #MAPBM_MUL       : a.s = "mul"
    Default
      a.s = Str$(bltmode)
  End Select
  Function Return a.s
End Function

Function.l _map_Str2BltMode{modestr.s}
  Select LCase$(modestr.s)
    Case "invisible" : mode.l = #MAPBM_INVISIBLE
    Case "alpha"     : mode.l = #MAPBM_ALPHA
    Case "ialpha"    : mode.l = #MAPBM_IALPHA
    Case "opaque"    : mode.l = #MAPBM_OPAQUE
    Case "add"       : mode.l = #MAPBM_ADD
    Case "sub"       : mode.l = #MAPBM_SUB
    Case "mask"      : mode.l = #MAPBM_MASK
    Case "trans"     : mode.l = #MAPBM_TRANS
    Default
      mode.l  = Vallong(modestring.s)
  End Select
  Function Return mode
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_OpenXMLMap {filename.s}                             /
;/                                                                             /
;/ Description:                                                                /
;/ Open a map from disk, either in develope or release mode.                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_OpenXMLMap{filename.s,@gfxDiv.l}
SHARED mapimage(),mapalpha()
*map.mapbase = 0
If gfxDiv<1 Then gfxDiv=1
fid.l = file_Open{filename.s,#file_read}
If fid<0 Then Function Return False
Repeat
  tagname.s = xml_ReadTag{fid}
  Select LCase$(tagname.s)
    Case "map"
      name.s = "unnamed"
      rows.l = 0:cols.l = 0 :mapx.l = 0:mapy.l = 0:playfieldx.l=0:playfieldy.l=0
      Repeat
        param.s = xml_ReadParamName{fid}
        Select LCase$(param.s)
          Case "name"        : name.s       = xml_ReadParamString{fid}
          Case "cols"        : cols.l       = xml_ReadParamValue{fid}
          Case "rows"        : rows.l       = xml_ReadParamValue{fid}
          Case "tilewidth"   : tilewidth.l  = xml_ReadParamValue{fid}
          Case "tileheight"  : tileheight.l = xml_ReadParamValue{fid}
          Case "mapx"        : mapx.l       = xml_ReadParamValue{fid}
          Case "mapy"        : mapy.l       = xml_ReadParamValue{fid}
          Case "playfield_x" : playfieldx.l = xml_ReadParamValue{fid}
          Case "playfield_y" : playfieldy.l = xml_ReadParamValue{fid}
        End Select
      Until param.s = ""
      If tilewidth<1 Then tilewidth=32
      If tileheight<1 Then tileheight=32
      *map = map_Create{name.s,tilewidth,tileheight}
      If *map
        map_SetAttrs{*map,Tags(#MAPA_MAPX,mapx,#MAPA_MAPY,mapy,#MAPA_PLAYFIELDX,playfieldx,#MAPA_PLAYFIELDY,playfieldy)}
        map_SetAttrs{*map,Tags(#MAPA_COLS,1,#MAPA_ROWS,1)}
;        error{"gfxdiv= "+Str$(gfxDiv)}
        map_SetAttrs{*map,Tags(#MAPA_GFXDIV,gfxDiv)}
        If rows>1 AND cols>1 AND rows<32767 AND cols<32767
          map_Resize{*map,Max(cols-#MAP_TILEINCSTEP,0),Max(rows-#MAP_TILEINCSTEP,0)}
        End If
      Else
        error {"map_OpenXML: Unable to create map!"}
        Function Return 0
      End If

    Case "image"
      filename.s = ""
      mimage.l   = -1
      pos.l      = -1
      hx.l = 0: hy.l = 0 : ABGR.l = 0
      Repeat
        param.s = xml_ReadParamName{fid}
        Select LCase$(param.s)
          Case "src"        : filename  = xml_ReadParamString{fid}
          Case "id"         : mimage    = xml_ReadParamValue{fid}
          Case "pos"        : pos       = xml_ReadParamValue{fid}
          Case "hx"         : hx.l      = xml_ReadParamValue{fid} / gfxDiv
          Case "hy"         : hy.l      = xml_ReadParamValue{fid} / gfxDiv
          Case "ABGR"       : ABGR.l    = xml_ReadParamValue{fid}
        End Select
      Until param.s = ""
      If mimage>=0
        n.l = 2
        If mapimage(mimage)\is_used
          If mapimage(mimage)\filename><filename.s
            n.l = ask {"map_OpenXML: image "+Str$(mimage)+" is already in use!\\nold: "+dos_FilePart{mapimage(mimage)\filename}+" / new:"+dos_FilePart{filename},"load new|keep old|cancel"}
          Else
            n=1
          End If
        End If
        If n=2
          If map_LoadImage{*map,filename,mimage,pos}
            map_SetHandle{mimage,hx,hy}
          End If
        End If
      Else
        error {"map_OpenXML: image id out of range: "+Str$(mimage)+"!"}
      End If

    Case "alpha"
      filename.s = ""
      alpha.l    = -1
      pos.l      = 0
      Repeat
        param.s = xml_ReadParamName{fid}
        Select LCase$(param.s)
          Case "src"        : filename  = xml_ReadParamString{fid}
          Case "id"         : alpha     = xml_ReadParamValue{fid}
          Case "pos"        : pos       = xml_ReadParamValue{fid}
        End Select
      Until param.s = ""
      If alpha>=0
        n.l = 2
        If mapalpha(alpha)\is_used
          If mapalpha(alpha)\filename><filename.s
            n.l = ask {"map_OpenXML: alpha"+Str$(alpha)+" is already in Use!\\nold: "+dos_FilePart{mapalpha(alpha)\filename}+" / New:"+dos_FilePart{filename},"load New|keep old|cancel"}
          Else
            n=1
          End If
        End If
        If n=2
          map_LoadAlpha{*map,filename,alpha}
        End If
      Else
        error {"map_OpenXML: alpha id out of range ("+Str$(alpha)+")!"}
      End If

    Case "object"
      objptr.l    = 0
      absx.l      = 0
      absy.l      = 0
      absz.l      = 0
      vm.f        = 0
      reload.l    = #MAPEV_NEVER
      fire.l      = #MAPEV_NEVER
      mainimage.l = -1: shadowimage.l = -1: heightimage.l = -1
      shadowdepth.l = -1
      bltmode.l   = #MAPBM_ALPHA
      name.s      = ""

      Repeat
        param.s = xml_ReadParamName{fid}
        Select LCase$(param.s)
          Case "vm"          : vm.f           = xml_ReadParamFloat{fid}
          Case "data"        : user_data.l    = xml_ReadParamValue{fid}
          Case "flags"       : flags.l        = xml_ReadParamValue{fid}
          Case "mainimage"   : mainimage.l    = xml_ReadParamValue{fid}
          Case "shadowimage" : shadowimage.l  = xml_ReadParamValue{fid}
          Case "shadowdepth" : shadowdepth.l  = xml_ReadParamValue{fid}
          Case "heightimage" : heightimage.l  = xml_ReadParamValue{fid}
          Case "bltmode"     : modestring.s   = xml_ReadParamString{fid} : bltmode.l = _map_Str2BltMode{modestring}
          Case "name"        : name.s         = xml_ReadParamString{fid}
          Case "fire"        : fire.l         = xml_ReadParamValue{fid}
          Case "reload"      : reload.l       = xml_ReadParamValue{fid}

        End Select
      Until param.s = ""
      *obj.mapobject = map_ObjectExist{name.s,vm,mainimage,shadowimage,heightimage,user_data}
      If *obj=0
        *obj.mapobject = map_CreateObject{name.s,vm,mainimage,shadowimage,heightimage,user_data,shadowdepth,bltmode}
        If *obj Then map_SetEvent{*obj,fire,reload}
      End If
      If *obj
        Repeat
          objtagname.s = xml_ReadTag{fid}
          Select LCase$(objtagname.s)
            Case "pin"
              absz.l = 0
              absy.l = 0
              absx.l = 0
              Repeat
                param.s = xml_ReadParamName{fid}
                Select LCase$(param.s)
                  Case "x"         : absx.l     = xml_ReadParamValue{fid} / gfxDiv
                  Case "y"         : absy.l     = xml_ReadParamValue{fid} / gfxDiv
                  Case "z"         : absz.l     = xml_ReadParamValue{fid}
                End Select
              Until param.s = ""
              map_SetObject {*map,*obj,absx,absy,absz}
            Case "/object"
              objtagname.s = ""
          End Select
        Until objtagname.s = ""
      Else
        ;xml_CloseTag{"object"}
      End If

    Case "tile"
      col.l      = 0
      row.l      = 0
      layer.l    = 0

      Repeat
        param.s = xml_ReadParamName{fid}
        Select LCase$(param.s)
          Case "col"         : col.l        = xml_ReadParamValue{fid}
          Case "row"         : row.l        = xml_ReadParamValue{fid}
          Case "height"      : h.l          = xml_ReadParamValue{fid} : map_SetTileEdgeHeight{*map,col,row,h}
          Default
            If Left$(LCase$(param.s),5) = "layer"
              layer = Vallong(Right$(param.s,FLen(param.s)-5))

              string.s = xml_ReadParamString{fid}
              string.s = Replace$(string.s," ","")
              pos.l = Instr(string.s,",")
              imagestring.s = ""
              alphastring.s = ""
              modestring.s  = ""
              If pos
                imagestring.s = Left$(string.s,pos-1)
                string.s = Right$(string.s,FLen(string.s)-pos)
                pos.l = Instr(string.s,",")
                If pos
                  alphastring.s = Left$(string.s,pos-1)
                  modestring.s = Right$(string.s,FLen(string.s)-pos)
                End If
              Else
                imagestring.s = string.s
              End If
              If Instr(imagestring,"*")
                mimage.l=-1
              Else
                mimage.l = Vallong(imagestring.s)
                If mimage<0 OR mimage>=#MAX_MAPIMAGES Then mimage=-1
              End If
              If Instr(alphastring,"*")
                alpha=-1
              Else
                alpha.l = Vallong(alphastring.s)
                If alpha<0 OR alpha>=#MAX_MAPALPHAS Then alpha=-1
              End If
              mode.l = _map_Str2BltMode{modestring}
              map_SetTile{*map,col,row,layer,mimage,alpha,mode}
            End If
        End Select
      Until param.s = ""

    Default
      ;error {"map_OpenXML: Unknown tag in xml file: "+tagname.s}
  End Select
Until tagname.s = ""
file_Close{fid}
Function Return *map
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_OpenXMLProject {filename.s}                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_OpenXMLProject{filename.s}
SHARED mapimage(),mapalpha()
fid.l = file_Open{filename.s,#file_read}
If fid<0 Then Function Return False
succ.l = True
ok.l = False
Repeat
  tagname.s = xml_ReadTag{fid}
  Select LCase$(tagname.s)
    Case "mapproject"
      ;OK
      ok.l = True
    Case "map"
      If ok
        src.s = ""
        name.s = "???"
        Repeat
          param.s = xml_ReadParamName{fid}
          Select LCase$(param.s)
            Case "name"       : name.s      = xml_ReadParamString{fid}
            Case "src"        : src.s       = xml_ReadParamString{fid}
          End Select
        Until param.s =""
        If src><""
          If map_OpenXMLMap{src}=False Then succ=False:Else succ=True
        End If
      End If
  End Select
Until tagname.s = "" OR succ=False
file_Close{fid}
Function Return succ
End Function




;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = _map_WriteString {fid.l,string.s}                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : ???                                                            /
;/ - string.s    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _map_WriteString{fid.l,string.s}
Function Return file_WriteMem{fid,&string,FLen(string)}
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = _map_WriteStringN {fid.l,string.s}                       /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : ???                                                            /
;/ - string.s    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _map_WriteStringN{fid.l,string.s}
string +Chr$(10)
Function Return file_WriteMem{fid,&string,FLen(string)}
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_SaveXMLMap {*map.mapbase,filename.s}                /
;/                                                                             /
;/ Description:                                                                /
;/ Save a map to disk. This can be in develope mode (all images are only       /
;/ referred and thus can be changed any time), or release mode,                /
;/ were all data inlcuding images will be packet as one file.                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_SaveXMLMap{*map.mapbase,filename.s}
SHARED *objlist(),*tilelist(),*maplist(),mapimage(),mapalpha(),*pindrawlist()
fid.l = file_Open{filename.s,#file_forcewrite,"xml"}
Format ""
If fid>=0
  map_Trim{*map}
  _map_WriteStringN{fid,"<?xml version=\\221.0\\22 encoding=\\22UTF-8\\22 standalone=\\22yes\\22?>"}
  _map_WriteStringN{fid,"\\n<!-- Amiblitz3 Map File (map.include, 2007 - 2015 (c) Thilo Koehler) -->\\n"}
  _map_WriteString{fid,"<!-- Map Base -->\\n<map name=\\22"+str_Read{&*map\name}+"\\22"}
  _map_WriteString{fid," cols="+Str$(*map\useCols)}
  _map_WriteString{fid," rows="+Str$(*map\useRows)}
  _map_WriteString{fid," tileWidth="+Str$(*map\tile_width)}
  _map_WriteString{fid," tileHeight="+Str$(*map\tile_height)}
  _map_WriteString{fid," mapX="+Str$(*map\map_x)}
  _map_WriteString{fid," mapY="+Str$(*map\map_y)}
  _map_WriteString{fid," indexCols="+Str$(*map\index_cols)}
  _map_WriteString{fid," indexRows="+Str$(*map\index_rows)}
  _map_WriteString{fid," playfieldX="+Str$(*map\playfield_x)}
  _map_WriteString{fid," playfieldY="+Str$(*map\playfield_y)}
  _map_WriteStringN{fid,">"}

  _map_WriteStringN{fid,"\\n<!-- Image List -->"}
  For mimage.l=0 To #MAX_MAPIMAGES-1
    If mapimage(mimage)\is_used
        _map_WriteString{fid,"<image id="+Str$(mimage)+" src=\\22"+ mapimage(mimage)\filename+"\\22"}
        If mapimage(mimage)\count>=0 Then _map_WriteString{fid," pos="+Str$(mapimage(mimage)\count)}
        hx.l = mapimage(mimage)\hotx
        hy.l = mapimage(mimage)\hoty
        If hx><0 OR hy ><0 Then _map_WriteString{fid," hx="+Str$(hx)+" hy="+Str$(hy)}
        _map_WriteString{fid," ABGR=$"+Hex$(mapimage(mimage)\AvgABGR)}
        _map_WriteStringN{fid,">"}
    End If
  Next

  _map_WriteStringN{fid,"\\n<!-- Alpha List -->"}
  For alpha.l=0 To #MAX_MAPALPHAS-1
    If mapalpha(alpha)\is_used
        _map_WriteString{fid,"<alpha id="+Str$(alpha)+" src=\\22"+ mapalpha(alpha)\filename+"\\22"}
        If mapalpha(alpha)\count>=0 Then _map_WriteString{fid," pos="+Str$(mapalpha(alpha)\count)}
        _map_WriteStringN{fid,"/>"}
    End If
  Next

  _map_WriteStringN{fid,"\\n<!-- Map Array (layer?=\\22imageID, alphaID, blitMode\\22) -->"}
  For row.l = 0 To *map\rows-1
    For col.l = 0 To *map\cols-1
      *tile.maptile = !map_GetTile{col,row}
      If *tile
        _map_WriteString{fid,"<tile col="+Str$(col)+" row="+Str$(row)}
        If *map\height_matrix
          h.l = !map_GetTileEdgeHeight{*map,col,row}
          If h><0 Then _map_WriteString{fid," height="+Str$(h)}
        End If
        For layer.l=0 To #MAX_MAPLAYERS-1
          If *tile\layer[layer]\mimage>=0
            a.s = _map_BltMode2Str{*tile\layer[layer]\mode}
            alpha.l = *tile\layer[layer]\alpha
            alphastring.s = Str$(alpha)
            If alpha<0 OR alpha>=#MAX_MAPALPHAS
              alphastring.s = "*"
            Else
              If mapalpha(alpha)\is_used=False Then alphastring.s = "*"
            End If
            _map_WriteString{fid," layer"+Str$(layer)+"=\\22"+Str$(*tile\layer[layer]\mimage)+","+Str$(alphastring)+","+a.s+"\\22"}
          End If
        Next
        _map_WriteStringN{fid,"/>"}
      End If
    Next
  Next

  _map_WriteStringN{fid,"\\n<!-- Object List -->"}
  ResetList *objlist()
  While NextItemFast(*objlist())
     *obj.mapobject = *objlist()
     If *obj
       _map_WriteString{fid,"<object"}
       If *obj\name Then name.s = str_Read{&*obj\name}:Else name.s =""
       If name.s         ><"" Then _map_WriteString{fid," name=\\22"+name.s+"\\22"}
       If *obj\mainimage  >=0 Then _map_WriteString{fid," mainImage="+Str$(*obj\mainimage)}
       If *obj\shadowimage>=0 Then _map_WriteString{fid," shadowImage="+Str$(*obj\shadowimage)+" shadowDepth="+Str$(*obj\shadowdepth)}
       If *obj\heightimage>=0 Then _map_WriteString{fid," heightImage="+Str$(*obj\heightimage)}
       If *obj\user_data      Then _map_WriteString{fid," data="+map_Long2String{*obj\user_data}}
       If *obj\flags          Then _map_WriteString{fid," flags=$"+Hex$(*obj\flags)}
       If *obj\vm         ><0 Then _map_WriteString{fid," vm=\\22"+Str$(*obj\vm)+"\\22"}

       If *obj\bltmode     ><#MAPBM_ALPHA Then _map_WriteString{fid," bltmode="+_map_BltMode2Str{*obj\bltmode}}
       If *obj\eventFire   ><#MAPEV_NEVER Then _map_WriteString{fid," fire="+Str$(*obj\eventFire)}
       If *obj\eventReload ><#MAPEV_NEVER Then _map_WriteString{fid," reload="+Str$(*obj\eventReload)}

       _map_WriteStringN{fid,">"}
       ClearList *pindrawlist()
       For row.l = 0 To *map\useRows-1
         For col.l = 0 To *map\useCols-1
           *pinhead.mappinhead = !map_GetPinHead{col,row}
           If *pinhead
             If *pinhead\pinlist
               n.l = 0
               While n<*pinhead\useN
                 *pin.mappin = *pinhead\pinlist\pin[n]
                 If *pin\obj  = *obj
                   done.l = False
                   ResetList *pindrawlist()
                   While NextItemFast(*pindrawlist())
                     If *pindrawlist() = *pin Then done=True
                   Wend
                   If done= False
                     _map_WriteStringN{fid,"  <pin x="+Str$(*pin\absx)+" y="+Str$(*pin\absy)+" z="+Str$(*pin\absz)+"/>"}
                     If AddItem(*pindrawlist())
                       *pindrawlist() = *pin
                     End If
                   End If
                 End If
                 n+1
               Wend
             End If
           End If
         Next
       Next
       _map_WriteStringN{fid,"</object>\\n"}
     End If
  Wend

  _map_WriteStringN{fid,"</map>\\n\\n<!-- End-Of-File -->"}
  file_Close{fid}
  succ.l=-1
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_SaveXMLProject {basename.s}                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - basename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_SaveXMLProject{basename.s}
SHARED *maplist()
n.l=1:succ.l=0
basename.s = dos_RemExt{dos_RemExt{basename}}
fid.l = file_Open{basename,#file_forcewrite,"proj.xml"}
If fid>=0
  _map_WriteStringN{fid,"<?xml version=\\221.0\\22 encoding=\\22UTF-8\\22 standalone=\\22yes\\22?>"}
  _map_WriteStringN{fid,"\\n<!-- Amiblitz3 Map Project File (map.include, 2007-2015 (c) Thilo Koehler) -->\\n"}
  _map_WriteString{fid,"<!-- Project Base -->\\n<mapproject file=\\22"+dos_FilePart{basename}+"\\22"}
  _map_WriteStringN{fid,">"}
  _map_WriteStringN{fid,"\\n<!-- Map List -->"}

  ResetList *maplist()
  While NextItemFast(*maplist())
   Format "000"
   filename.s = basename.s+".map"+Str$(n)+".xml"
   Format ""
   *map.mapbase = *maplist()
   If map_SaveXMLMap{*map,filename}
     _map_WriteString{fid,"<map name=\\22"+str_Read{&*map\name}+"\\22 src=\\22"+filename+"\\22"}
     _map_WriteString{fid," cols="+Str$(*map\useCols)+" rows="+Str$(*map\useRows)}
     _map_WriteString{fid," tilewidth="+Str$(*map\tile_width)+" tileheight="+Str$(*map\tile_height)}
     _map_WriteStringN{fid,">"}
     succ+1
   End If
   n+1
  Wend
  _map_WriteStringN{fid,"</mapproject>\\n\\n<!-- End-Of-File -->"}
  file_Close{fid}
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_WriteAlpha {fid.l,alpha.l}                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : ???                                                            /
;/ - alpha.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _map_WriteAlpha{fid.l,alpha.l}
SHARED mapalpha()
succ.l = True
file_WriteChunk{fid,@"ALPH"}
file_WriteTag{fid,@"WIDT",mapalpha(alpha)\xs}
file_WriteTag{fid,@"HIGH",mapalpha(alpha)\ys}
file_WriteTag{fid,@"TYPE",mapalpha(alpha)\typ}
file_WriteTag{fid,@"DATA",mapalpha(alpha)\xs * mapalpha(alpha)\ys}
file_WriteMem{fid,mapalpha(alpha)\ptr,mapalpha(alpha)\xs * mapalpha(alpha)\ys}
file_CloseChunk{fid,@"ALPH"}
Function Return succ
End Function

NEWTYPE.imagechunk
FOFF.l:fileoffset.l
MPOS.l:count.l
DIMS.l:xs.w:ys.w
HAND.l:hotx.w:hoty.w
ABGR.l:AvgABGR.l
End NEWTYPE

NEWTYPE.alphachunk
FOFF.l:fileoffset.l
End NEWTYPE

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_SaveData {basename.s}                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - basename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_SaveData{basename.s}
SHARED mapalpha(),mapimage()
fid.l = file_Open{basename,#file_forcewrite,"dat"}
If fid>=0
  file_WriteChunk{fid,@"MDAT"}
  ; image table
  file_WriteChunk{fid,@"ITAB"}
  itabpos.l = file_GetSeekPos{fid}
  maximage.l = #MAX_MAPIMAGES-1
  While mapimage(maximage)\is_used=False AND maximage>1: maximage-1 : Wend
  For mimage.l=0 To maximage
    imagechunk.imagechunk\FOFF = @"FOFF",-1
    imagechunk.imagechunk\MPOS = @"MPOS",mapimage(mimage)\count
    imagechunk.imagechunk\DIMS = @"DIMS",mapimage(mimage)\xs,mapimage(mimage)\ys
    imagechunk.imagechunk\HAND = @"HAND",mapimage(mimage)\hotx,mapimage(mimage)\hoty
    imagechunk.imagechunk\ABGR = @"ABGR",mapimage(mimage)\AvgABGR
    file_WriteMem{fid,imagechunk,SizeOf.imagechunk}
  Next
  file_CloseChunk{fid,@"ITAB"}

  file_WriteChunk{fid,@"ATAB"}
  atabpos.l = file_GetSeekPos{fid}
  maxalpha.l = #MAX_MAPIMAGES-1
  While mapalpha(maxalpha)\is_used=False AND maxalpha>1: maxalpha-1 : Wend

  For alpha.l=0 To maxalpha
    file_WriteTag{fid,@"FOFF",-1}
    alphachunk.alphachunk\FOFF = @"FOFF",-1
    file_WriteMem{fid,alphachunk,SizeOf.alphachunk}
  Next
  file_CloseChunk{fid,@"ATAB"}

  ; save all images ...
  For mimage.l=0 To #MAX_MAPIMAGES-1
    If mapimage(mimage)\is_used
      indexpos.l = file_GetSeekPos{fid}
      image.l = map_LockImage{mimage}
      If image>=0
        image_Write{image,fid,@"DIMG"}
      End If
      pos.l = file_GetSeekPos{fid}
      file_Seek{fid,itabpos+(SizeOf.imagechunk*mimage)+&imagechunk\fileoffset-imagechunk}
      file_WriteLong{fid,indexpos}
      file_Seek{fid,pos}
    End If
  Next

  For alpha.l=0 To #MAX_MAPALPHAS-1
    If mapalpha(alpha)\is_used
      indexpos.l = file_GetSeekPos{fid}
      _map_WriteAlpha{fid,alpha}
      pos.l = file_GetSeekPos{fid}
      file_Seek{fid,itabpos+(SizeOf.alphachunk*alpha)+&alphachunk\fileoffset-alphachunk}
      file_WriteLong{fid,indexpos}
      file_Seek{fid,pos}
    End If
  Next

  succ.l=-1
  file_Close{fid}
End If
Function Return succ
End Function

NEWTYPE.mapchunk_MGEO
version.l
cols.l
rows.l
tile_width.l
tile_height.l
name.b[64]
End NEWTYPE

NEWTYPE.mapchunk_LAYER
mimage.w
alpha.w
mode.w
pad.w
End NEWTYPE

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_SaveMap {*map.mapbase,filename.s}                   /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : ???                                                     /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////


Function.l map_SaveMap{*map.mapbase,filename.s}
SHARED *objlist(),*tilelist(),*maplist(),mapimage(),mapalpha()
fid.l = file_Open{filename.s,#file_forcewrite,"map"}
Format ""
If fid>=0
  map_Trim{*map}
  file_WriteChunk{fid,@"MAP!"}

  file_WriteChunk{fid,@"MGEO"} ; Map Geometrie
  mapchunk_MGEO.mapchunk_MGEO\cols = *map\useCols,*map\useRows
  mapchunk_MGEO\tile_width         = *map\tile_width,*map\tile_height
  mapchunk_MGEO\version = 1
  name.s = Left$(str_Read{&*map\name},63)
  Poke.s &mapchunk_MGEO\name[0],name
  file_WriteMem{fid,mapchunk_MGEO,SizeOf.mapchunk_MGEO}
  file_CloseChunk{fid,@"MGEO"}

  file_WriteChunk{fid,@"MAPA"} ; Map Array
  *dummytile.maptile = map_CreateTile{}
  For row.l = 0 To *map\rows-1
    For col.l = 0 To *map\cols-1
      *tile.maptile = !map_GetTile{col,row}
      If *tile = 0 Then *tile = *dummytile;
      file_WriteMem{fid,*tile,SizeOf.maptile}
    Next
  Next
  map_FreeTile{*dummytile}
  file_CloseChunk{fid,@"MAPA"}

  file_WriteChunk{fid,@"OBJS"} ; Objects
  ResetList *objlist()
  While NextItemFast(*objlist())
     *obj.mapobject = *objlist()
     If *obj
       file_WriteTag{fid,@"MOBJ",0}
       If *obj\name Then name.s = str_Read{&*obj\name}:Else name.s =""
       If name.s ><""      Then file_WriteTagString{fid,@"NAME",name.s}
       If *obj\mainimage  >=0 Then file_WriteTag{fid,@"MAIN",*obj\mainimage}
       If *obj\shadowimage>=0
         file_WriteTag{fid,@"SHDW",*obj\shadowimage}
         file_WriteTag{fid,@"DEPT",*obj\shadowdepth}
       End If
       If *obj\heightimage>=0 Then file_WriteTag{fid,@"HIGH",*obj\heightimage}
       If *obj\user_data   Then file_WriteTag{fid,@"DATA",*obj\user_data}
       If *obj\flags       Then file_WriteTag{fid,@"FLAG",*obj\flags}
       If *obj\vm><0       Then file_WriteTag{fid,@"VISI",*obj\vm*1000}
       ;For n.l=0 To *map\objH_useN-1
         ;*pin.mapobjh = !map_GetObjH{n}
         *pin.mappin = 0
         If *pin\obj = *obj
           file_WriteTag{fid,@"PINX",*pin\absx}
           file_WriteTag{fid,@"PINY",*pin\absy}
           file_WriteTag{fid,@"PINZ",*pin\absz}
         End If
       ;Next
     End If
  Wend
  file_CloseChunk{fid,@"OBJS"}
  file_CloseChunk{fid,@"MAP!"}
  file_Close{fid}
  succ.l=-1
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_SaveProject {basename.s}                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - basename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_SaveProject{basename.s}
SHARED *maplist()
ResetList *maplist() : succ.l=True : n.l = 0
While NextItemFast(*maplist()) AND succ
  Format "000"
  filename.s = basename.s+"."+Str$(n)+".map"
  Format ""
  *map.mapbase = *maplist()
  If map_SaveMap{*map,filename}
    succ=True
  Else
    succ=False
  End If
  n+1
Wend
If succ Then map_SaveData{basename}
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_OpenMap {filename.s}                                /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_OpenMap{filename.s}
SHARED mapimage(),mapalpha()
*map.mapbase = 0
fid.l = file_Open{filename.s,#file_read}
If fid<0 Then Function Return #NULL
If file_FindChunk{fid,@"MAP!"}
  searchpos.l = file_GetSeekPos{fid}
  If file_FindChunk{fid,@"MGEO",searchpos}
    file_ReadMem{fid,mapchunk_MGEO.mapchunk_MGEO,SizeOf.mapchunk_MGEO}
  End If
  If file_FindChunk{fid,@"MAPA",searchpos}
    For row.l = 0 To *map\rows-1
      For col.l = 0 To *map\cols-1
;        file_ReadMem{fid,*tile,SizeOf.maptile}
 ;       map_SetTile{*map,col,row,0}
      Next
    Next
  End If
  If file_FindChunk{fid,@"OBJS",searchpos}
    While file_ReadTag{fid}
    Wend
  End If
End If

Function Return *map.mapbase
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_FindObjectByUserData {user_data.l}                  /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - user_data.l    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_FindObjectByUserData{user_data.l}
SHARED *objlist()
ResetList *objlist()
While NextItemFast(*objlist())
  *obj.mapobject = *objlist()
  If *obj\user_data = user_data Then Function Return *obj
Wend
Function Return 0
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = map_FindPin {*map.mapbase,*obj.mapobject}               /
;/                                                                             /
;/ Description:                                                                /
;/ Find a pin that represents the object.                                                /
;/ Note: If the objects have several pins, you will get the first one in the list /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *map.mapbase    : map to search                                                     /
;/ - *obj.mapobject  : object to find                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - *result.mappin  : pin                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l map_FindPin{*map.mapbase,*obj.mapobject}
If *map
  For row.l = 0 To *map\useRows-1
    For col.l = 0 To *map\useCols-1
     *pinhead.mappinhead = !map_GetPinHead{col,row}
     If *pinhead
       If *pinhead\pinlist
         n.l = 0
         While n<*pinhead\useN
           *pin.mappin = *pinhead\pinlist\pin[n]
           If *pin\obj  = *obj
             Function Return *pin
           End If
           n+1
         Wend
       End If
     End If
    Next
  Next
End If
Function Return 0
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: map_CleanUp {}                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Clean everything up. This function is called on autoexit.                   /
;/ All maps that are created during runtime will be tracked                    /
;/ and freed by this function, if not already done so.                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _map_AutoExit{}
SHARED *tilelist(),mapalpha()
SHARED *maplist(),*objlist()

ResetList *maplist()
While NextItemFast(*maplist())
  map_Free{*maplist()}
  ResetList *maplist()
Wend

ResetList *tilelist()
While NextItemFast(*tilelist())
  map_FreeTile{*tilelist()}
  ResetList *tilelist()
Wend

ResetList *objlist()
While NextItemFast(*objlist())
  map_FreeObject{*objlist()}
  ResetList *objlist()
Wend

For alpha.l=0 To #MAX_MAPALPHAS-1
  map_FreeAlpha{alpha}
Next

For mimage.l = 0 To #MAX_MAPIMAGES-1
  map_FreeImage{mimage}
Next
End Statement

!autoexit{_map_AutoExit}

Statement map_CleanUp{}
_map_AutoExit{}
End Statement

CNIF #__include=0



WbToScreen 0
Window 0,0,0,640,480,$E,"map.include demo",1,0
*map.mapbase= map_Create{"TestMap",128,64}

succ.l=map_LoadImage{*map,"/Data/map/tile_desert.png",2}
succ&map_LoadImage{*map,"/Data/map/tile_snow.png",3}
succ&map_LoadImage{*map,"/Data/map/tile_stone.png",4}
succ&map_LoadImage{*map,"/Data/map/tile_water.png",5}
succ&map_LoadImage{*map,"/Data/map/tile_mud.png",7}
succ&map_LoadImage{*map,"/Data/map/tile_grass.png",6}
succ&map_LoadImage{*map,"/Data/map/obj_tree_main.png",8} : map_FootHandle{8}
succ&map_LoadImage{*map,"/Data/map/obj_tree_height.png",12} : map_FootHandle{12}

;succ&map_LoadImage{*map,11,"/Data/map/obj_house.png"} : image_MidHandle{11}
succ&map_LoadImage{*map,"/Data/map/obj_figur.png",9} : map_FootHandle{9}
succ&map_LoadImage{*map,"/Data/map/obj_fence.png",10} : map_FootHandle{10}
If succ=False Then End


map_LoadAlpha{*map,"/Data/map/alpha_x.png",6}
map_LoadAlpha{*map,"/Data/map/alpha_y.png",1}
map_LoadAlpha{*map,"/Data/map/alpha_e1.png",2}
map_LoadAlpha{*map,"/Data/map/alpha_e2.png",3}
map_LoadAlpha{*map,"/Data/map/alpha_e3.png",4}
map_LoadAlpha{*map,"/Data/map/alpha_e4.png",5}
map_LoadAlpha{*map,"/Data/map/alpha_path.png",10}
;map_SetAttrs{*map,Tags(#MAPA_PLAYFIELDX,WLeftOff,#MAPA_PLAYFIELDY,WTopOff)}

map_SetTile{*map,0,0,0,2}
map_SetTile{*map,0,1,0,2}
map_SetTile{*map,0,2,0,3}
map_SetTile{*map,0,2,1,2,1,#MAPBM_ALPHA}
map_SetTile{*map,0,3,0,3}

map_SetTile{*map,1,0,0,7}
map_SetTile{*map,1,0,1,2,2,#MAPBM_ALPHA}
map_SetTile{*map,1,1,0,2}
map_SetTile{*map,1,1,1,7,6,#MAPBM_ALPHA}
map_SetTile{*map,1,2,0,3}
map_SetTile{*map,1,2,1,2,4,#MAPBM_ALPHA}
map_SetTile{*map,1,2,3,7,5,#MAPBM_IALPHA}
map_SetTile{*map,1,3,0,2}
map_SetTile{*map,1,3,1,3,5,#MAPBM_ALPHA}


map_SetTile{*map,2,0,0,7}
map_SetTile{*map,2,0,1,2,1,#MAPBM_ALPHA}
map_SetTile{*map,2,1,0,7}
map_SetTile{*map,2,2,0,2}
map_SetTile{*map,2,2,1,7,1,#MAPBM_ALPHA}
map_SetTile{*map,2,3,0,3}
map_SetTile{*map,2,3,1,2,1,#MAPBM_ALPHA}

map_SetTile{*map,3,4,0,3}
map_SetTile{*map,3,5,0,3}
map_SetTile{*map,2,4,0,3}
map_SetTile{*map,2,5,0,3}
map_SetTile{*map,1,4,0,3}
map_SetTile{*map,1,5,0,3}
map_SetTile{*map,0,4,0,3}
map_SetTile{*map,0,5,0,3}


map_SetTile{*map,3,0,0,2}
map_SetTile{*map,3,0,1,7,3,#MAPBM_ALPHA}
map_SetTile{*map,3,1,0,7}
map_SetTile{*map,3,2,0,2}
map_SetTile{*map,3,2,1,7,1,#MAPBM_ALPHA}
map_SetTile{*map,3,3,0,3}
map_SetTile{*map,3,3,1,2,1,#MAPBM_ALPHA}

map_SetTile{*map,3,1,2,6,1,#MAPBM_IALPHA}
map_SetTile{*map,3,2,2,6}
map_SetTile{*map,3,3,2,6}
map_SetTile{*map,3,4,2,6,1,#MAPBM_ALPHA}
map_SetTile{*map,2,4,2,6,1,#MAPBM_ALPHA}
map_SetTile{*map,1,4,2,6,1,#MAPBM_ALPHA}
map_SetTile{*map,0,4,2,6,5,#MAPBM_IALPHA}

map_SetTile{*map,2,1,3,6,2,#MAPBM_IALPHA}
map_SetTile{*map,2,2,3,6,6,#MAPBM_ALPHA}
map_SetTile{*map,2,3,3,6,3,#MAPBM_ALPHA}
map_SetTile{*map,1,3,3,6,1,#MAPBM_IALPHA}
map_SetTile{*map,0,3,3,6,2,#MAPBM_IALPHA}

map_SetTile{*map,3,4,3,5,1,#MAPBM_IALPHA}
map_SetTile{*map,3,5,3,5}
map_SetTile{*map,2,5,3,5,6,#MAPBM_ALPHA}
map_SetTile{*map,2,4,3,5,2,#MAPBM_IALPHA}

map_SetTile{*map,4,0,0,7}
map_SetTile{*map,4,1,0,7}
map_SetTile{*map,4,2,0,7}
map_SetTile{*map,4,3,0,2}
map_SetTile{*map,4,4,0,5}
map_SetTile{*map,4,5,0,5}

map_SetTile{*map,4,1,3,6,1,#MAPBM_IALPHA}
map_SetTile{*map,4,2,3,6,#MAPBM_ALPHA}
map_SetTile{*map,4,3,3,6,#MAPBM_ALPHA}
map_SetTile{*map,4,4,3,6,1,#MAPBM_ALPHA}

map_SetTile{*map,0,6,0,3}
map_SetTile{*map,1,6,0,3}
map_SetTile{*map,2,6,0,3}
map_SetTile{*map,3,6,0,3}
map_SetTile{*map,4,6,0,5}

map_SetTile{*map,2,6,1,5,5,#MAPBM_IALPHA}
map_SetTile{*map,3,6,1,5,4,#MAPBM_ALPHA}


map_SetTile{*map,0,0,4,4,22,#MAPBM_ALPHA}
map_SetTile{*map,0,1,4,4,28,#MAPBM_ALPHA}
map_SetTile{*map,0,2,4,4,34,#MAPBM_ALPHA}
map_SetTile{*map,1,2,4,4,35,#MAPBM_ALPHA}
map_SetTile{*map,1,3,4,4,41,#MAPBM_ALPHA}
map_SetTile{*map,2,3,4,4,26,#MAPBM_ALPHA} ; : map_SetTile{*map,0,2,5,3,1,#MAPBM_IALPHA}
map_SetTile{*map,3,3,4,4,39,#MAPBM_ALPHA} ; : map_SetTile{*map,1,2,5,3,4,#MAPBM_IALPHA}
map_SetTile{*map,3,2,4,4,38,#MAPBM_ALPHA} ; : map_SetTile{*map,1,3,5,3,6,#MAPBM_IALPHA}
map_SetTile{*map,4,2,4,4,25,#MAPBM_ALPHA}
;map_SetAttrs{*map,Tags(#MAPA_PLAYFIELDX,100,#MAPA_PLAYFIELDY,100)}

map_SetTile{*map,0,7,0,3,#MAPBM_ALPHA}
map_SetTile{*map,1,7,0,3,#MAPBM_ALPHA}
map_SetTile{*map,2,7,0,3,#MAPBM_ALPHA}
map_SetTile{*map,3,7,0,3,#MAPBM_ALPHA}
map_SetTile{*map,4,7,0,5,#MAPBM_ALPHA}
map_SetTile{*map,5,7,0,5,#MAPBM_ALPHA}

;myobj.l = map_CreateObject{0.0,11}
;house.l   = map_SetObject{*map,myobj,330,0,0}
;house.l   = map_SetObject{*map,myobj,-30,150,0}

myobj.l  = map_CreateObject{"Tree",0.0,8,-1,12}
ref1.l   = map_SetObject{*map,myobj,380,200}
ref2.l   = map_SetObject{*map,myobj,260,302}
ref3.l   = map_SetObject{*map,myobj,150,410}
ref4.l   = map_SetObject{*map,myobj,570,200}
ref4.l   = map_SetObject{*map,myobj,560,40}
;map_RemObjectID{*map,ref2}

;map_ScrollTo{*map,50,50}
image_Create {99,640,480,#ARGB_GREY,False}
*rp.RastPort = image_GetRPPtr{99}

fenceObj.l = map_CreateObject{"Fence",-0.5,10}
fencePin.l = map_SetObject{*map,fenceObj,400,433,0}
map_Render{*map,*rp,0,0,640,480,#MAPRF_INGAME};|#MAPRF_GRID}
mouseObj.l = map_CreateObject{"Hero",0.0,9,-1,-1,@"HERO"}
mousePin.l = map_SetObject{*map,mouseObj,320,240,0}
heroimage.l = map_LockImage{9};_map_Carpet2Image{9}
heroHotX.l = image_GetHandleX{heroimage}
heroHotY.l = image_GetHandleY{heroimage}
heroW.l =  image_GetWidth{heroimage}
heroH.l =  image_GetHeight{heroimage}

While Event><#IDCMP_CLOSEWINDOW
  mx.l = WMouseX   - WLeftOff
  my.l = WMouseY   - WTopOff

  If map_GetHeight{*map,mx,my-4}=0
    x1.l = Min(mx,omx.l) - heroHotX
    y1.l = Min(my,omy.l) - heroHotY

    x2.l = Max(mx,omx.l) + heroW - heroHotX
    y2.l = Max(my,omy.l) + heroH - heroHotY

    map_MovePin{*map,mousePin,mx,my}
    map_Render{*map,*rp,x1,y1,x2-x1+1,y2-y1+1,#MAPRF_INGAME};|#MAPRF_GRID}
    image_Draw{99,WLeftOff,WTopOff,RastPort(0)}
    omx.l = mx
    omy.l = my
  End If
  Delay_ 1
Wend
map_SaveXMLMap{*map,"cache:test.xml"}
;map_OpenXMLMap{"ram:test.xml"}
map_Free{*map}
_map_AutoExit{}
End
CEND

