; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "ram:"
; ExeFile         = "createw.exe"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 100000
; MakeSmallest    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 999
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8192
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 1005
; CursorColumn    = 35
; LabelSearch     = "mix"
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 100
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 100
; Max GadgetList  = 100
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 200
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 100
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 1
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 10
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 100
; Max BlitzFont   = 1
; Max GTList      = 100
; /XTRA
CNIF #__include=0
Syntax 2
optimize 7
CEND

XINCLUDE "useful.include.bb2"
Syntax 2
; Oscillator Types
#OSC_SAW      = 0 ; saw tooth
#OSC_SIN      = 1 ; sinus
#OSC_RECT     = 2 ; rectangle
#OSC_TRI      = 3 ; triangle
#OSC_NOISE    = 4 ; noise

#OSC_IMP      = 5 ; impuls
#OSC_NOISE2   = 7 ; better? white noise

#MOD_NONE        = 0
#MOD_SELFFM      = 1
#MOD_EXTFM       = 2
#MOD_SELFEXTFM   = 3
#MOD_SELFPM      = 4
#MOD_EXTPM       = 5
#MOD_SELFEXTPM   = 6
#MOD_EXTAM       = 7

; Envelope States
#ENV_ATTACK   = 0
#ENV_DECAY    = 1
#ENV_SUSTAIN  = 2
#ENV_RELEASE  = 3
#ENV_END      = 4
#ENV_MAX      = 5

; Filter Types
#FILTER_LP1     = 0 ; simple low pass with resonance
#FILTER_HPx     = 1 ; extreme high pass
#FILTER_MOOG    = 2 ; moog-like low pass
#FILTER_BTBLP   = 3 ; biquad low pass
#FILTER_BTBHP   = 4 ; biquad high pass
#FILTER_FORMANT = 5

; Dither Modes
#DITHER_NONE  = 0 ; no dithering
#DITHER_ERR   = 1 ; error dithering

; Synthesizer Library Attributes
#SYNTHA_BYTESPERSAMPLE = 0
#SYNTHA_FORMAT         = 1
#SYNTHA_QUALITY        = 2
#SYNTHA_SIZEOFOSC      = 3
#SYNTHA_SIZEOFFILTER   = 4
#SYNTHA_SIZEOFENV      = 5
#SYNTHA_SIZEOFDELAY    = 6

; Sample Formats
#FORMAT_INT8  = 0 ; 8bit integer
#FORMAT_INT16 = 1 ; 16bit integer
#FORMAT_INT24 = 2 ; 24 bit integer + 8bit headroom
#FORMAT_FLOAT = 3 ; 1.0 normalized float

#QUALITY_FAST = 0 ; fastest possible
#QUALITY_FAIR = 1
#QUALITY_BEST = 2 ; best possible

NEWTYPE.synth
quality.l
End NEWTYPE

SHARED synthGlobal.synth

Function.l synth_GetAttr{attr.l}

  Select attr
    Case #SYNTHA_BYTESPERSAMPLE : Function Return SizeOf.w
    Case #SYNTHA_FORMAT         : Function Return #FORMAT_INT16
    Case #SYNTHA_QUALITY        : Function Return synthGlobal\quality
  End Select

  Function Return 0

End Function


Function.l synth_SetAttr{attr.l,value.l}

  Select attr
    Case #SYNTHA_QUALITY  : synthGlobal\quality = value
    Default
      Function Return 0
  End Select

  Function Return 1

End Function


Statement synth_RenderConvert{*outP.w,*inP.w,sampleN.l,form.l}

  Select form
    Case #FORMAT_INT8
      For n.l=0 To sampleN-1
        samplew.w = Peek.w(*inP+n*SizeOf.w) ASR 8
        Poke.b *outP+n*SizeOf.b,samplew
      Next

    Case #FORMAT_INT16
      CopyMem_ *inP,*outP,sampleN*SizeOf.w

    Case #FORMAT_INT24
      For n.l=0 To sampleN-1
        samplel.l = Peek.w(*inP+n*SizeOf.w) ASL 8
        Poke.l *outP+n*SizeOf.l,samplel
      Next

    Case #FORMAT_FLOAT
      For n.l=0 To sampleN-1
        samplef.f = Peek.w(*inP+n*SizeOf.w) / 32768.0
        Poke.f *outP+n*SizeOf.f,samplef
      Next

  End Select

End Statement


; Oscillator
NEWTYPE.synthOsc

  ; settings
  type_.l          ; OSC_...
  modtype.l        ; MOD_...
  frequency.f      ; Hz
  startphase.f     ; [0...2pi]
  samplingrate.f   ; Hz
  gain.f           ; 0...1.0
  moddepth.f

  *tableP.w        ; table
  *funcP.l         ; hook

  ; state
  iphase.l         ; for integer rendering
  iphase2.l        ; some need 2
  iphaseinc.l      ; phase increment
  igain.l          ; 0...256
  imoddepth.l

End NEWTYPE

; Filter
NEWTYPE.synthFilter

  ; settings
  type_.l
  samplingrate.f
  frequency.f
  resonance.f

  *funcP.l

  ; coefficients
  a.f[4]
  b.f[4]

  ; state
  x.f[4]
  y.f[4]

End NEWTYPE

; Envelope
NEWTYPE.synthEnv

  ; settings
  duration.f[#ENV_MAX]
  level.f[#ENV_MAX]

  ;state
  state.l
  offset.f
  rlevel.f
  ir.f
  r.f

End NEWTYPE


NEWTYPE.synthDelay

  ; delay
  ring_buffer.w[$1000] ; should be enough for 10Hz@44kHz

  read_a.f
  read_b.f
  frequency.f
  samplingrate.f

  ; filter
  hidamp.f
  lodamp.f
  feedback.f
  pass.f
  ph.f
  pl.f

  ; state
  xl.f
  xh.f
  ring_read.l
  ring_write.l

End NEWTYPE

NEWTYPE.synthFlute

  frequency.f
  sensitivity.f
  energy.f
  gain.f
  samplingrate.f
  lastbreath.f

  *sinP.w
  *distP.w

  iphase.l
  iphaseinc.l
  igain.l

End NEWTYPE


; Lookup Tables
Dim SinTable.w  ($8000)
Dim TanTable.w  ($8000)
Dim RectTable.w ($8000)
Dim TriTable.w  ($8000)
Dim NoiseTable.w($8000)
Dim SawTable.w  ($8000)
Dim ISawTable.w ($8000)


SHARED SinTable(),SawTable(),RectTable(),TriTable(),NoiseTable(),ISawTable()
SHARED TanTable()

seed.l = 1234567

; calculate lookup tables
For n.l=0 To 32767
  SinTable(n) = -(Sin(n*2.0*Pi / 32768.0) * 32767)
  If n<16384 Then TanTable(n) = -ATan((16384-n)/128.0)*20861.0 : Else TanTable(n) = ATan((n-16384)/128)*20861.0
  If n<16384 Then RectTable(n) = -32767 : Else RectTable(n)=32767

  NoiseTable(n) = (seed LSR 16) : seed = (seed+907633515) * 196314165

  If n<8192
    TriTable(n) = n*4
  Else
    If n<16384 + 8192
      TriTable(n) = 32767 - (n-8192)*4
    Else
      TriTable(n) = n*4 -32768-32768
    EndIf
  End If
  TriTable(n) = -TriTable(n)

  SawTable(n) = (n-16384)*2
  ISawTable(n) = -SawTable(n)-2

  ;NPrint "#",n," Saw=",ISawTable(n)," Sin=",SinTable(n)," Sqr=",RectTable(n)," Tri=",TriTable(n)," Noise=",NoiseTable(n), " ATan=",TanTable(n)
Next

; generate an FM modulated signal
._synth_osc_ExtFM
Statement FAST _synth_osc_ExtFM{*outP.w, sampleN.l, *osc.synthOsc, *modulatorP.w}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,*osc\iphaseinc
  GetReg d3,*osc\igain
  GetReg a0,*outP
  GetReg a1,*modulatorP
  GetReg a2,*osc\tableP +16384*SizeOf.w

  .fm_loop
    ADD.l d2,d1            ; proceed in wave phase
    CLR.l d3
    MOVE.w (a1)+,d4 : SWAP.w d4  ; get modulator value
    ADD.l d4,d1            ; and add it to the phase
    MOVE.l d1,d4
    SWAP.w d4
    AND.w #$FFFE,d4        ; make it multiple of 2
    MOVE.w $0(a2,d4),d5
    MULS.w d3,d5
    ASR.l #8,d5
    MOVE.w d5,(a0)+ ; out = table[in]

  SUB.l #1,d0              ; loop for all sampleN
  BGT fm_loop

  .fm_exit
  PutReg d1,*osc\iphase     ; store the phase

End Statement


; generate an FM modulated signal
._synth_osc_SelfFM
Statement FAST _synth_osc_SelfFM{*outP.w, sampleN.l, *osc.synthOsc}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,*osc\iphaseinc
  GetReg d3,*osc\igain
  GetReg d6,*osc\imoddepth
  GetReg a0,*outP
  GetReg a2,*osc\tableP +16384*SizeOf.w

  .sfm_loop
    ADD.l d2,d1            ; proceed in wave phase
    MOVE.l d1,d4
    SWAP.w d4
    AND.w #$FFFE,d4        ; make it multiple of 2
    MOVE.w $0(a2,d4),d5
    MULS.w d3,d5
    ASR.l #8,d5
    MOVE.w d5,(a0)+ ; out = table[in]

    MULS.w d6,d5
    LSL.l #8,d5
    ADD.l d5,d1            ; and add it to the phase

  SUB.l #1,d0              ; loop for all sampleN
  BGT sfm_loop

  .sfm_exit
  PutReg d1,*osc\iphase     ; store the phase

End Statement


; generate an PM modulated signal
._synth_osc_ExtPM
Statement FAST _synth_osc_ExtPM{*outP.w, sampleN.l, *osc.synthOsc, *modulatorP.w}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,*osc\iphaseinc
  GetReg d3,*osc\igain
  GetReg d6,*osc\imoddepth*256
  GetReg a0,*outP
  GetReg a1,*modulatorP
  GetReg a2,*osc\tableP +16384*SizeOf.w

  .epm_loop
    ADD.l d2,d1            ; proceed in wave phase
    MOVE.w (a1)+,d4        ; get modulator value
    MULS.w d6,d4
    ;ASL.l #8,d4
    ADD.l d1,d4            ; and add it to the phase
    SWAP.w d4
    AND.w #$FFFE,d4        ; make it multiple of 2
    MOVE.w $0(a2,d4),d5    ; table[in]
    MULS.w d3,d5           ; * gain
    ASR.l #8,d5
    MOVE.w d5,(a0)+        ; out

  SUB.l #1,d0              ; loop for all sampleN
  BGT epm_loop

  .epm_exit
  PutReg d1,*osc\iphase     ; store the phase

End Statement


._synth_osc_SelfExtPM
Statement FAST _synth_osc_SelfExtPM{*outP.w, sampleN.l, *osc.synthOsc, *modulatorP.w}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,*osc\iphaseinc
  GetReg d3,*osc\igain
  GetReg d5,*osc\iphase2
  GetReg d6,*osc\imoddepth*256
  GetReg a0,*outP
  GetReg a1,*modulatorP
  GetReg a2,*osc\tableP +16384*SizeOf.w

  .espm_loop
    ADD.l d2,d1            ; proceed in wave phase
    MOVE.w (a1)+,d4        ; get modulator value
    MULS.w d6,d4
    ;ASL.l #8,d4
    ADD.l d1,d4            ; and add it to the phase

    MULS.w d6,d5           ; the self-mod part...
    ;ASL.l #8,d5
    ADD.l d5,d4            ; get modulator value

    SWAP.w d4
    AND.w #$FFFE,d4        ; make it multiple of 2
    MOVE.w $0(a2,d4),d5    ; table[in]
    MULS.w d3,d5           ; * gain
    ASR.l #8,d5
    MOVE.w d5,(a0)+        ; out

  SUB.l #1,d0              ; loop for all sampleN
  BGT espm_loop

  .espm_exit
  PutReg d1,*osc\iphase     ; store the phase

End Statement


._synth_osc_SelfPM
Statement FAST _synth_osc_SelfPM{*outP.w, sampleN.l, *osc.synthOsc}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,*osc\iphaseinc
  GetReg d3,*osc\igain
  GetReg d5,*osc\iphase2
  GetReg a0,*outP
  GetReg d6,*osc\imoddepth*256
  GetReg a2,*osc\tableP +16384*SizeOf.w

  .spm_loop
    ADD.l d2,d1            ; proceed in wave phase
    MOVE.l d1,d4
    MULS.w d6,d5
    ;ASL.l #8,d5
    ADD.l d5,d4            ; get modulator value
    SWAP.w d4
    AND.w #$FFFE,d4        ; make it multiple of 2
    MOVE.w $0(a2,d4),d5    ; table[in]
    MULS.w d3,d5           ; * gain
    ASR.l #8,d5
    MOVE.w d5,(a0)+        ; out

  SUB.l #1,d0              ; loop for all sampleN
  BGT spm_loop

  .spm_exit
  PutReg d1,*osc\iphase     ; store the phase
  PutReg d5,*osc\iphase2

End Statement


; ring modulate (=multiply) two 16bit audio buffers
Statement FAST synth_RenderAM{*outP.w,*in1P.w,*in2P.w,sampleN.l}

  GetReg d0,sampleN        ; load registers
  GetReg a0,*outP
  GetReg a1,*in1P
  GetReg a2,*in2P

  .ringmod_loop
    MOVE.w (a1)+,d1
    MOVE.w (a2)+,d2
    MULS.w d1,d2
    SWAP.w d2
    MOVE.w d2,(a0)+        ; out = in1 * in2

  SUB.l #1,d0              ; loop for all sampleN
  BGT ringmod_loop

End Statement


; generate primitve wave
_synth_osc_LookupTable:
Statement FAST _synth_osc_LookupTable{*outP.w, sampleN.l, *osc.synthOsc}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,*osc\iphaseinc
  GetReg d3,*osc\igain
  GetReg a0,*outP
  GetReg a1,*osc\tableP +16384*SizeOf.w

  .osc_loop
    ADD.l d2,d1            ; proceed in wave phase
    MOVE.l d1,d4           ; copy lower 16bit to sample to buffer
    SWAP.w d4
    AND.w #$FFFE,d4        ; make it multiple of 2
    MOVE.w $0(a1,d4),d5
    MULS.w d3,d5
    ASR.l #8,d5
    MOVE.w d5,(a0)+        ;  out = table[in]

  SUB.l #1,d0              ; loop for all sampleN
  BGT osc_loop

  .osc_exit
  PutReg d1,*osc\iphase     ; store the phase

End Statement


; generate saw tooth wave
_synth_osc_DirectSaw:
Statement FAST _synth_osc_DirectSaw{*outP.w, sampleN.l, *osc.synthOsc}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,*osc\iphaseinc
  GetReg d3,*osc\igain
  GetReg a0,*outP

  .saw_loop
    ADD.l d2,d1            ; proceed in wave phase
    MOVE.l d1,d4
    SWAP.w d4
    MULS.w d3,d4
    ASR.l #8,d4
    MOVE.w d4,(a0)+        ; copy lower 16bit to sample to buffer

  SUB.l #1,d0              ; loop for all sampleN
  BGT saw_loop

  .saw_exit
  PutReg d1,*osc\iphase     ; store the phase

End Statement

_synth_osc_SawAA:
Statement FAST _synth_osc_SawAA{*outP.w, sampleN.l, *osc.synthOsc}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,*osc\iphaseinc
  GetReg d3,*osc\igain
  GetReg a0,*outP

  MOVE.l d2,d7 : ASR.l #1,d7

  .qsaw_loop
    MOVE.l d1,d4           ; v1 = phase
    ADD.l d2,d1            ; phase + ifrequency
    BVS qsaw_wrap          ; wrap? => wrap!

    ADD.l d7,d4
    SWAP.w d4
    MULS.w d3,d4
    ASR.l #8,d4
    MOVE.w d4,(a0)+        ; copy lower 16bit to sample to buffer

  SUB.l #1,d0              ; loop for all sampleN
  BGT qsaw_loop
  BRA qsaw_exit

  .qsaw_wrap               ; ((ifrequency-d)*(v1+max)/2 + d*(min+v2)/2)/ifrequency
    MOVE.l d3,-(a7)
                                  ; d4 = v1
    MOVE.l d1,d3                  ; d3 = v2
    SWAP.w d3   : ASR.w #1,d3     ; /2
    SWAP.w d4   : ASR.w #1,d4     ; /2

    ADD.w  #$3FFF,d4              ; v1+max
    ADD.w #-$4000,d3              ; v2+min

    MOVE.l d1,d5                  ; d5=phase
    SWAP.w d5
    ADD.w #$7FFF,d5

    MULS.w d5,d3                  ; d*(v2+min)/2

    MOVE.l d2,d6                  ; ifrequency...
    SWAP.w d6                     ; => 15bit
    SUB.w d5,d6                   ; ifrequency-d

    MULS.w d6,d4                  ; (ifrequency-d)*(v1+max)/2

    ADD.l d3,d4                   ; ... + ...

    ADD.w d6,d5                   ; =ifrequency
    EXT.l d5

    DIVS.w d5,d4                  ; / ifrequency
    MOVE.l (a7)+,d3
    MULS.w d3,d4                  ; * gain
    ASR.l #8,d4

    MOVE.w d4,(a0)+        ; copy lower 16bit to sample to buffer

  SUB.l #1,d0              ; loop for all sampleN
  BGT qsaw_loop


  .qsaw_exit
  PutReg d1,*osc\iphase     ; store the phase

End Statement


_synth_osc_Impuls:
Statement FAST _synth_osc_Impuls{*outP.w, sampleN.l, *osc.synthOsc}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,*osc\iphaseinc
  GetReg d3,*osc\igain
  GetReg a0,*outP

  MULS.w #255,d3

  .imp_loop
    ADD.l d2,d1            ; phase + ifrequency
    BVS imp_wrap          ; wrap? => wrap!
    MOVE.w #0,(a0)+        ; copy lower 16bit to sample to buffer

  SUB.l #1,d0              ; loop for all sampleN
  BGT imp_loop
  BRA imp_exit

  .imp_wrap           ; ((ifrequency-d)*(v1+max)/2 + d*(min+v2)/2)/ifrequency
    MOVE.w d3,(a0)+
  SUB.l #1,d0              ; loop for all sampleN
  BGT imp_loop

  .imp_exit
  PutReg d1,*osc\iphase     ; store the phase

End Statement


; generate square wave
_synth_osc_DirectRect:
Statement FAST _synth_osc_DirectRect{*outP.w, sampleN.l, *osc.synthOsc}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,*osc\iphaseinc
  GetReg d3,-*osc\igain
  GetReg d4,*osc\igain

  GetReg a0,*outP

  MULS.w 255,d3
  MULS.w 255,d4

  .square_loop
    ADD.l d2,d1            ; proceed in wave phase
    BGT square_hi

  .square_lo
    MOVE.w d3,(a0)+   ; set min value

  SUB.l #1,d0              ; loop for all sampleN
  BGT square_loop

  BRA square_exit

  .square_hi
    MOVE.w d4,(a0)+    ; set max value

  SUB.l #1,d0              ; loop for all sampleN
  BGT square_loop

  .square_exit
  PutReg d1,*osc\iphase     ; store the phase

End Statement


; generate triangle wave
_synth_osc_DirectTri:
Statement FAST _synth_osc_DirectTri_dep{*outP.w, sampleN.l, *osc.synthOsc}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,*osc\iphaseinc
  GetReg d3,*osc\igain

  GetReg a0,*outP

  .triangle_loop
    ADD.l d2,d1            ; proceed in wave phase
    SWAP.w d1
    MOVE.w d1,d3
    SWAP.w d1              ; copy sample to temp buffer
    TST.l d1
    BGT triangle_hi

    .triangle_lo
    NEG.w d3
    LSL #1,d3
    ADD.w #32767,d3
    MOVE.w d3,(a0)+

  SUB.l #1,d0              ; loop for all sampleN
  BGT triangle_loop

  BRA triangle_exit

    .triangle_hi
    LSL #1,d3
    ADD.w #-32767,d3
    MOVE.w d3,(a0)+

  SUB.l #1,d0              ; loop for all sampleN
  BGT triangle_loop

  .triangle_exit
  PutReg d1,*osc\iphase     ; store the phase

End Statement


; generate white noise
_synth_osc_Noise:
Statement FAST _synth_osc_Noise{*outP.w, sampleN.l, *osc.synthOsc}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,196314165      ; magic number 1
  GetReg d3,*osc\igain
  GetReg a0,*outP

  .noise_loop
    ADD.w #907633515,d1    ; magic number 2
    MULS.w d2,d1
    MOVE.l d1,d4
    SWAP.w d4
    MULS.w d3,d4
    ASR.l #8,d4
    MOVE.w d4,(a0)+        ; out = rand()

  SUB.l #1,d0              ; loop for all sampleN
  BGT noise_loop

  .noise_exit
  PutReg d1,*osc\iphase     ; store the phase

End Statement


_synth_osc_Noise2x:
Statement FAST _synth_osc_Noise2x{*outP.w, sampleN.l, *osc.synthOsc}

  GetReg d0,sampleN        ; load registers
  GetReg d1,*osc\iphase
  GetReg d2,*osc\iphase2
  GetReg a0,*outP

  .noise2_loop
    MOVE.l d1,d4   ; gx1 = gx1 XOR gx2
    AND.l d2,d4
    OR.l d2,d1
    SUB.l d4,d1
    
    SWAP.w d2    
    MOVE.w d2,(a0)+        ; out = rand()
    SWAP.w d2
    
    ADD.l d1,d2
    
  SUB.l #1,d0              ; loop for all sampleN
  BGT noise2_loop

  .noise2_exit
  PutReg d1,*osc\iphase     ; store the phase
  PutReg d2,*osc\iphase2    ; store the phase
  
End Statement

_synth_osc_Noise2:
Statement FAST _synth_osc_Noise2{*outP.w, sampleN.l, *osc.synthOsc}

  seed.l = *osc\iphase

  For n.l=0 To sampleN-1
    seed.l = seed * 196314165 + 907633515
    f1.f = seed
    seed.l = seed * 196314165 + 907633515
    f2.f = seed
    seed.l = seed * 196314165 + 907633515
    r.f = seed
    r = r / 32768 / 32768 / 4 * 2 * Pi

    f.f = Sqr(f1*f1 + f2*f2)  / 32768 / 2 / Sqr(2)
    f = Sin(r) * f

    Poke.w *outP,Int(f) : *outP+SizeOf.w
  Next

  *osc\iphase = seed    ; store the phase


End Statement


_synth_filter_Lp1:
Function.l FAST _synth_filter_Lp1{*outP.w, *inP.w, sampleN.l, *filt.synthFilter}

  pos.f   = *filt\x[0]
  speed.f = *filt\y[0]
  c.f     = *filt\a[0]
  r.f     = *filt\b[0]

  For n.l=0 To sampleN-1
    in.f = (Peek.w(*inP) - pos) * c
    speed = speed * r + in
    pos + speed
    If pos>32767 Then pos=32767
    If pos<-32767 Then pos=-32767
    Poke.w *outP,pos
    *outP+SizeOf.w
    *inP +SizeOf.w
  Next

  *filt\x[0] = pos
  *filt\y[0] = speed

  Function Return sampleN
End Function

._synth_filter_Formant
Function.l FAST _synth_filter_Formant{*outP.w, *inP.w, sampleN.l, *filt.synthFilter}

  y1.f     = *filt\y[0]
  y2.f     = *filt\y[1]
  p.f      = *filt\b[0]
  q.f      = *filt\b[1]

  For n.l=0 To sampleN-1
    x0.f = Peek.w(*inP) / 16.0

    y0.f = x0 - p*y1 - q*y2
    y2 = y1 : y1 = y0
    out.f=y0

    If out> 32767 Then out= 32767
    If out<-32767 Then out=-32767
    Poke.w *outP,out
    *outP+SizeOf.w
    *inP +SizeOf.w
  Next

  *filt\y[0] = y1
  *filt\y[1] = y2

  Function Return sampleN

End Function


_synth_filter_Btb:
Function.l FAST _synth_filter_Btb{*outP.w, *inP.w, sampleN.l, *filt.synthFilter}

  x1.f     = *filt\x[0]
  x2.f     = *filt\x[1]
  y1.f     = *filt\y[0]
  y2.f     = *filt\y[1]
  a0.f     = *filt\a[0]
  a1.f     = *filt\a[1]
  a2.f     = *filt\a[2]
  b1.f     = *filt\b[0]
  b2.f     = *filt\b[1]

  For n.l=0 To sampleN-1
    x0.f = Peek.w(*inP)
    y0.f = a0*x0 + a1*x1 + a2*x2 - b1*y1 - b2*y2

    x2=x1
    x1=x0
    y2=y1
    y1=y0
    
    out.f=y0

    If out> 32767 Then out= 32767
    If out<-32767 Then out=-32767
    Poke.w *outP,out
    *outP+SizeOf.w
    *inP +SizeOf.w
  Next

  *filt\x[0] = x1
  *filt\x[1] = x2
  *filt\y[0] = y1
  *filt\y[1] = y2

  Function Return sampleN
End Function

_synth_filter_AllPass1
Function.l FAST _synth_filter_AllPass1{}
;function [b,a] = allpass(order, Fc, Fs, Q)
;% Returns allpass filter coefficients.
;% Currently only 1st and 2nd orders are supported.
;%
;% Usage: [b,a] = ALLPASS(N, FC, FS, Q);
;%
;%        N is the order of the allpass
;%        FC is the frequency a the 90deg phase shift point
;%        FS is the sampling rate
;%        Q is quality factor describing the slope of phase shift
;%
;% Author: sparafucile17 01/07/2004
;
;,if(order > 2)
;    error('Only 1st and 2nd orders are supported');
;end
;
;%Bilinear transform
;g = tan(pi*(Fc/Fs));;
;
;if(order == 2)
;    d  = 1/Q;
;    K  = 1/(1 + d*g + g^2);
;    b0 = (1 - g*d + g^2) * K;
;    b1 = 2 * (g^2 - 1) * K;
;    b2 = 1;
;    a1 = b1;
;    a2 = b0;
;else
;    b0 = (g-1)/(g+1);
;    b1 = 1;
;    b2 = 0;
;    a1 = b0;
;    a2 = 0;
;end
;
;b = [b0 b1 b2];
;a = [1  a1 a2];
End Function


_synth_filter_Moog:
Function.l FAST _synth_filter_Moog{*outP.w, *inP.w, sampleN.l, *filt.synthFilter}
  ; 24db
  p.f     = *filt\a[0]
  k.f     = *filt\a[1]
  r.f     = *filt\a[2]

  oldx.f  = *filt\x[0]
  y1.f    = *filt\y[0]
  y2.f    = *filt\y[1]
  y3.f    = *filt\y[2]
  y4.f    = *filt\y[3]
  oldy1.f = *filt\y[0]
  oldy2.f = *filt\y[1]
  oldy3.f = *filt\y[2]
  _kd.f   = 0.000001
  
  For n.l=0 To sampleN-1
    x.f  = Peek.w(*inP)/32768.0 - r*y4
    y1 = x *p + oldx *p - k*y1
    y2 = y1*p + oldy1*p - k*y2
    y3 = y2*p + oldy2*p - k*y3
    y4 = y3*p + oldy3*p - k*y4
    y4 = y4 - ((y4*y4*y4)/6.0)
    oldx = x
    oldy1 = y1+_kd
    oldy2 = y2+_kd
    oldy3 = y3+_kd
    out.f = y4 *32768.0
    If out>32767 Then out=32767
    If out<-32767 Then out=-32767
    Poke.w *outP,out
    *inP+SizeOf.w
    *outP+SizeOf.w
  Next
  
  *filt\x[0] = x
  *filt\y[0] = y1
  *filt\y[1] = y2
  *filt\y[2] = y3
  *filt\y[3] = y4
  
  Function Return sampleN
End Function


_synth_filter_Hpx:
Function.l FAST _synth_filter_Hpx{*outP.w, *inP.w, sampleN.l, *filt.synthFilter}

  prev.l = *filt\x[0]

  For n.l=0 To sampleN-1
    this.l = Peek.w(*inP)
    out.l = (this - prev) ASR 1
    prev.l = this
    ;If out>32767 Then out=32767
    ;If out<-32767 Then out=-32767
    Poke.w *outP,out
    *outP+SizeOf.w
    *inP +SizeOf.w
  Next

  *filt\x[0] = prev

  Function Return sampleN
End Function



; mix two 16bit audio buffers
Statement FAST synth_RenderMix_dep{*outP.w,*in1P.w,*in2P.w,sampleN.l}

  GetReg d0,sampleN        ; load registers
  GetReg a0,*outP
  GetReg a1,*in1P
  GetReg a2,*in2P

  .mix_loop_dep
    MOVE.w (a1)+,d1
    MOVE.w (a2)+,d2
    ADD.w d1,d2
    MOVE.w d2,(a0)+        ; out = in1 + in2

  SUB.l #1,d0              ; loop for all sampleN
  BGT mix_loop_dep

End Statement


; mix two 16bit audio buffers
Statement FAST synth_RenderMix{*outP.w,*in1P.w,*in2P.w,sampleN.l,gain_a.f,gain_b.f}

  GetReg d0,sampleN        ; load registers
  GetReg a0,*outP
  GetReg a1,*in1P
  GetReg a2,*in2P
  GetReg d3,gain_a*256.0
  GetReg d4,gain_b*256.0

  .mix_loop
    MOVE.w (a1)+,d1
    MOVE.w (a2)+,d2
    MULS.w d3,d1
    MULS.w d4,d2
    ADD.l d1,d2
    ASR.l #8,d2
    MOVE.w d2,(a0)+        ; out = in1 + in2

  SUB.l #1,d0              ; loop for all sampleN
  BGT mix_loop

End Statement


Statement FAST synth_RenderAmp32s{*outP.l,*in1P.w,sampleN.l,gain.f,pan.f}

  igainl.l = (pan+1) * gain * 256.0
  igainr.l = (1-pan) * gain * 256.0
  If igainl<0 Then igainl=0
  If igainr<0 Then igainr=0

  GetReg d0,sampleN        ; load registers
  GetReg a0,*outP
  GetReg a1,*in1P
  GetReg d1, igainl
  GetReg d2, igainr

  .amp32s_loop
    MOVE.w (a1)+,d3
    MOVE.w d3,d4
    MULS.w d1,d3
    MULS.w d2,d4

    ADD.l d3,(a0)+        ; out = in1 + in2
    ADD.l d4,(a0)+        ; out = in1 + in2

  SUB.l #1,d0              ; loop for all sampleN
  BGT amp32s_loop

End Statement


; scale a 16bit audio buffer with gain (256 = normal level)
Statement FAST synth_RenderScale{*outP.w, *inP.w, sampleN.l, gain.f, offset.f}

  ioffset.l = offset * 32767
  igain.l  = gain    * 256

  GetReg d0,sampleN        ; load registers
  GetReg a0,*outP
  GetReg a1,*inP
  GetReg d1,igain
  GetReg d2,ioffset

  .scale_loop
    MOVE.w (a1)+,d3
    MULS.w d1,d3
    ASR.l #8,d3
    ADD.l d2,d3
    MOVE.w d3,(a0)+        ; out = in * gain + offset

  SUB.l #1,d0              ; loop for all sampleN
  BGT scale_loop

End Statement



Statement synth_ChangeFilter {*filt.synthFilter,detune.f}
  Select *filt\type_
    Case #FILTER_HPx:
     
    Case #FILTER_LP1: 
      t.f =  *filt\frequency / *filt\samplingrate * 2.0^(detune)
      If t>0.15   Then t=0.15
      ;If t<0.0001 Then t=0.0001
      c.f      = (1-Cos(Pi*t)) * 16.0
      r.f      = (*filt\resonance)^(12000.0/*filt\samplingrate)
      ;If c<*vc\minfreq_f Then c = *vc\minfreq_f
      *filt\a[0] = c
      *filt\b[0] = r
      
    Case #FILTER_MOOG:
      f.f  = 2.0 * *filt\frequency * 2.0^(detune) / *filt\samplingrate
      p.f  = f*(1.8-0.8*f)
      k.f  = p+p-1.0
      t.f  = (1.0-p)*1.386249
      t2.f = 12.0+t*t
      r.f  = *filt\resonance*(t2+6.0*t)/(t2-6.0*t)
      *filt\a[0] = p
      *filt\a[1] = k
      *filt\a[2] = r
      
    Case #FILTER_BTBLP:
      c.f = 1.0 / Tan(Pi * *filt\frequency * 2.0^(detune)/ *filt\samplingrate)
      r.f = (1-*filt\resonance) * Sqr(2.0)

      a1.f = 1.0 / ( 1.0 + r * c + c * c);
      a2.f = 2* a1;
      a3.f = a1;
      b1.f = 2.0 * ( 1.0 - c*c) * a1;
      b2.f = ( 1.0 - r * c + c * c) * a1;
      
      *filt\a[0] = a1
      *filt\a[1] = a2
      *filt\a[2] = a3
      *filt\b[0] = b1
      *filt\b[1] = b2

    Case #FILTER_BTBHP:
      c.f = Tan(Pi * *filt\frequency * 2.0^(detune)/ *filt\samplingrate);
      r.f = (1-*filt\resonance) * Sqr(2.0)
      
      a1.f = 1.0 / ( 1.0 + r * c + c * c);
      a2.f = -2*a1;
      a3.f = a1;
      b1.f = 2.0 * ( c*c - 1.0) * a1;
      b2.f = ( 1.0 - r * c + c * c) * a1;
      
      *filt\a[0] = a1
      *filt\a[1] = a2
      *filt\a[2] = a3
      *filt\b[0] = b1
      *filt\b[1] = b2

    Case #FILTER_FORMANT:
      bandwidth.f = *filt\resonance * *filt\frequency
      p.f = -2.0 * Exp (-Pi * bandwidth / *filt\samplingrate) * Cos (2*Pi* *filt\frequency / *filt\samplingrate)
      q.f = Exp (-2.0*Pi* bandwidth / *filt\samplingrate)

      *filt\b[0] = p
      *filt\b[1] = q

  End Select
  
End Statement


Statement synth_ResetFilter{*filt.synthFilter}

  *filt\x[0] = 0
  *filt\x[1] = 0
  *filt\x[2] = 0
  *filt\x[3] = 0
  
  *filt\y[0] = 0
  *filt\y[1] = 0
  *filt\y[2] = 0
  *filt\y[3] = 0

End Statement


Statement synth_InitFilter{*filt.synthFilter,type_.l,frequency.f,resonance.f,samplingrate.f}

  *filt\samplingrate = samplingrate
  *filt\resonance    = resonance
  *filt\frequency    = frequency
  *filt\type_        = type_

  !_GetFuncPointer{*btbFuncP.l,_synth_filter_Btb,{Null,Null,0,Null}}

  Select *filt\type_
    Case #FILTER_LP1:   !_GetFuncPointer{*filt\funcP,_synth_filter_Lp1,{Null,Null,0,Null}}
    Case #FILTER_HPx:   !_GetFuncPointer{*filt\funcP,_synth_filter_Hpx,{Null,Null,0,Null}}
    Case #FILTER_MOOG:  !_GetFuncPointer{*filt\funcP,_synth_filter_Moog,{Null,Null,0,Null}}    
    Case #FILTER_BTBLP: *filt\funcP = *btbFuncP    
    Case #FILTER_BTBHP: *filt\funcP = *btbFuncP
    Case #FILTER_FORMANT: !_GetFuncPointer{*filt\funcP,_synth_filter_Formant,{Null,Null,0,Null}}
    Default:            *filt\funcP = Null
  End Select

  synth_ChangeFilter{*filt,0}
  synth_ResetFilter{*filt}

End Statement


Statement synth_RenderDither{*outP.w, *inP.w, sampleN.l, bits.l, mode.l}

  errmask.l = (1 LSL (16-bits))-1
  sigmask.l = $FFFFFFFF-errmask
  avgerr.l = errmask LSR 1

  Select mode
    Case #DITHER_ERR
      err.l = 0

      For n.l=0 To sampleN-1
        s.l = Peek.w(*inP)
        sq.l = (s+err) & sigmask
        If sq> 32767 Then sq= 32767
        If sq<-32767 Then sq=-32767
        Poke.w *outP,sq
        err + (s-sq)/2

        *outP+SizeOf.w
        *inP +SizeOf.w
      Next

    Default: ; DITHER_NONE
      For n.l=0 To sampleN-1
        s.l = Peek.w(*inP)
        sq.l = (s+avgerr) & sigmask
        Poke.w *outP,sq
        *outP+SizeOf.w
        *inP +SizeOf.w
      Next

  End Select

End Statement


Statement synth_RenderOsc{*outP.w, sampleN.l, *osc.synthOsc, *modulator.w}

  !_CallFuncPointer{*osc\funcP, result.l, *outP, sampleN, *osc, *modulator}

End Statement



Statement synth_RenderFilter{*outP.w, *inP.w, sampleN.l, *filt.synthFilter}

  !_CallFuncPointer{*filt\funcP, result.l, *outP, *inP, sampleN, *filt}

End Statement

Statement synth_ChangeDelay{*delay.synthDelay,detune.f}

   delta.f = *delay\samplingrate/(*delay\frequency * 2^(detune))
   *delay\ring_read = (*delay\ring_write-Int(delta)) & $FFF
   fracd.f = (delta-Int(delta))
   *delay\read_a = fracd
   *delay\read_b = 1.0-fracd

End Statement

Statement synth_InitDelay{*delay.synthDelay,frequency.f,hidamp.f,lodamp.f,feedback.f,samplingrate.f,pass.f}

   *delay\samplingrate = samplingrate
   *delay\frequency    = frequency
   *delay\hidamp       = hidamp
   *delay\lodamp       = lodamp
   *delay\feedback     = feedback
   *delay\pass         = pass

   If hidamp<18000 AND hidamp<samplingrate/2
     f.f = 2*Pi*hidamp/samplingrate
     *delay\pl = (2-Cos(f)) - Sqr((2-Cos(f))^2 - 1) ;with x = 2*Pi*cutoff/samplerate
     ;coeficient approximation: p = (1 - 2*cutoff/samplerate)^2
   Else
     *delay\pl = 0
   End If

   If lodamp>0
     f.f = 2*Pi*lodamp/samplingrate
     *delay\ph = (2-Cos(f)) - Sqr((2-Cos(f))^2 - 1) ;with x = 2*Pi*cutoff/samplerate
     ;*delay\ph = (2+Cos(f)) - Sqr((2+Cos(f))^2 - 1) ;with x = 2*Pi*cutoff/samplerate
   Else
     *delay\ph = 1
   End If

   synth_ChangeDelay{*delay,0}

End Statement

Statement synth_RenderDelay{*outP.w,*inP.w,sampleN.l,*delay.synthDelay}

  ringP.l    = &*delay\ring_buffer[0]
  ringW.l    = *delay\ring_write
  ringR.l    = *delay\ring_read
  dia.f      = *delay\read_a
  dib.f      = *delay\read_b
  backh.f    = *delay\xh
  ph.f       = *delay\ph
  backl.f    = *delay\xl
  pl.f       = *delay\pl
  feedback.f = *delay\feedback
  pass.f     = *delay\pass

  For n.l=0 To sampleN-1

    ; read input
    in.f = Peek.w(*inP)    : *inP + SizeOf.w

    ; read delay
    da.f = Peek.w(ringP + ringR*SizeOf.w)
    ringR = (ringR + 1) & $FFF
    db.f = Peek.w(ringP + ringR*SizeOf.w)
    echo.f = da*dia + db*dib

    ; output
    out.f = echo + in * pass
    If out> 32767 Then out= 32767
    If out<-32767 Then out=-32767
    Poke.w *outP,out : *outP + SizeOf.w

    ; filter for delay
    back.f = echo * feedback + in
    backl.f = (1-pl)*back  + pl*backl
    backh.f = (1-ph)*backl + ph*backh
    back=backl-backh
    If back> 32767 Then back= 32767
    If back<-32767 Then back=-32767

    ; write delay
    Poke.w ringP + ringW*SizeOf.w ,back : ringW = (ringW + 1) & $FFF
  Next

  *delay\ring_read  = ringR
  *delay\ring_write = ringW
  *delay\xl         = backl
  *delay\xh         = backh


End Statement



; waveshape 16bit signal given a lookup table
Statement FAST synth_RenderWaveShape{*outP.w, *inP.w, sampleN.l, *tableP.w}

  GetReg d0,sampleN        ; load registers
  GetReg a0,*inP
  GetReg a1,*outP
  GetReg a2,*tableP

  ADDA.l #32768,a2         ; seek to the middle of the table (because offset is signed short)

  .waveshape_loop
    MOVE.w (a0)+,d1        ; get the sample
    AND.w #$FFFE,d1        ; make it multiple of 2
    MOVE.w $0(a2,d1),(a1)+ ; out = table[in]

  SUB.l #1,d0              ; loop for all sampleN
  BGT waveshape_loop

End Statement

Statement FAST synth_ChangeFlute{*flute.synthFlute, detune.f, gain.f}

  *flute\iphaseinc           = Int(65536.0 * 65536.0 / *flute\samplingrate * *flute\frequency * 2^(detune))
  *flute\igain               = 256 * gain * *flute\gain

End Statement

Statement synth_InitFlute{*flute.synthFlute,samplingrate.f,sensitivity.f,frequency.f,gain.f}

  *flute\frequency    = frequency
  *flute\sensitivity  = sensitivity
  *flute\samplingrate = samplingrate
  *flute\energy       = 0
  *flute\sinP         = &SinTable(0)
  *flute\distP        = &TanTable(0)
  *flute\iphase       = 0
  *flute\gain         = gain

  synth_ChangeFlute{*flute,0,1}

End Statement


Statement synth_RenderFlute{*outP.w,*breathP.w,*flute.synthFlute,sampleN.l}

  energy.f     = *flute\energy
  lastbreath.f = *flute\lastbreath
  sense.f      = *flute\sensitivity
  iphase.l     = *flute\iphase
  iphaseinc.l  = *flute\iphaseinc
  gain.f       = *flute\igain/256

  For n.l=0 To sampleN-1
    breath.f = Peek.w(*breathP+n*SizeOf.w)
    diff.f = breath/32768;  //(breath-lastbreath)/32768
    diff = (diff*diff)  * 200
    energy = diff*sense + energy*(1-sense)

    iphase + iphaseinc

    offset.l = (iphase LSR 16) & $FFFE

    sinus.f = Peek.w(*flute\sinP + offset) * gain * energy

    out.f = sinus + (1-energy)*breath
    If out> 32767 Then out= 32767
    If out<-32768 Then out=-32768

    offset = out
    offset = (offset+32768) & $FFFE

    outw.w = Peek.w(*flute\distP + offset)

    Poke.w *outP + n*SizeOf.w,outw

  Next

  *flute\energy     = energy
  *flute\lastbreath = breath
  *flute\iphase     = iphase

End Statement


; *osc    : osciallator
; detune  : detune from basefrequency in musical tones
Statement FAST synth_ChangeOsc{*osc.synthOsc, detune.f, gain.f, moddepth.f}

  *osc\iphaseinc           = Int(65536.0 * 65536.0 / *osc\samplingrate * *osc\frequency * 2^(detune))
  *osc\igain               = 256 * gain * *osc\gain
  *osc\imoddepth           = 256 * moddepth * *osc\moddepth

End Statement


Function.synthOsc FAST synth_AllocOsc{n.l}

  *osc.synthOsc = AllocMem_(SizeOf.synthOsc*n,#MEMF_ANY)
  Function Return *osc

End Function

Statement FAST synth_FreeOsc{*osc.synthOsc}

  FreeMem_ *osc,SizeOf.synthOsc

End Statement


Statement synth_InitOsc{*osc.synthOsc, type_.l, samplingrate.f, phase.f, frequency.f, gain.f, modtype.l, moddepth.f}

  *osc\type_         = type_
  *osc\frequency     = frequency
  *osc\startphase    = phase
  *osc\samplingrate  = samplingrate
  *osc\gain          = gain
  *osc\iphase        = Int(65536.0 * 65536.0 * phase / 2.0 / Pi)
  *osc\modtype       = modtype
  *osc\moddepth      = moddepth

  !_GetFuncPointer{*osc\funcP,_synth_osc_LookupTable,{Null,0,Null}}

  Select *osc\type_
    Case #OSC_SAW:      *osc\tableP = &SawTable(0)
      If synthGlobal\quality>=#QUALITY_FAIR
        !_GetFuncPointer{*osc\funcP,_synth_osc_SawAA,{Null,0,Null}}
      End If
    Case #OSC_IMP:      *osc\tableP = &SawTable(0)   : !_GetFuncPointer{*osc\funcP,_synth_osc_Impuls,{Null,0,Null}}
    Case #OSC_SIN:      *osc\tableP = &SinTable(0)
    Case #OSC_RECT:     *osc\tableP = &RectTable(0)
    Case #OSC_TRI:      *osc\tableP = &TriTable(0)
    Case #OSC_NOISE:    *osc\tableP = &NoiseTable(0) : !_GetFuncPointer{*osc\funcP,_synth_osc_Noise,{Null,0,Null}}
    Case #OSC_NOISE2:   *osc\tableP = &NoiseTable(0) : !_GetFuncPointer{*osc\funcP,_synth_osc_Noise2,{Null,0,Null}}
     *osc\iphase  = $67452301;
     *osc\iphase2 = $efcdab89;
    Default:            *osc\tableP = &SinTable(0)
  End Select


  Select *osc\modtype
    Case #MOD_NONE ; we are ok with the above
    Case #MOD_EXTFM
      !_GetFuncPointer{*osc\funcP,_synth_osc_ExtFM,{Null,0,Null,Null}}
    Case #MOD_EXTPM
      !_GetFuncPointer{*osc\funcP,_synth_osc_ExtPM,{Null,0,Null,Null}}
    Case #MOD_SELFFM
      !_GetFuncPointer{*osc\funcP,_synth_osc_SelfFM,{Null,0,Null}}
    Case #MOD_SELFPM
      !_GetFuncPointer{*osc\funcP,_synth_osc_SelfPM,{Null,0,Null}}
    Case #MOD_SELFEXTPM
      !_GetFuncPointer{*osc\funcP,_synth_osc_SelfExtPM,{Null,0,Null,Null}}

  End Select

  synth_ChangeOsc{*osc, 0, 1, 1}

End Statement


Function.f FAST synth_StepEnv{*env.synthEnv}
  If *env\state=#ENV_END     Then *env\rlevel = *env\level[#ENV_END]
  If *env\state=#ENV_SUSTAIN Then *env\rlevel = *env\level[#ENV_SUSTAIN]
  If *env\state=#ENV_RELEASE
    *env\rlevel = *env\rlevel * *env\ir + *env\level[#ENV_END] * *env\r
    If Abs(*env\rlevel-*env\level[#ENV_END])<0.0001 Then *env\state=#ENV_END
  End If
  If *env\state=#ENV_ATTACK OR *env\state=#ENV_DECAY
    *env\rlevel = (*env\level[*env\state] * (*env\duration[*env\state]-*env\offset) + *env\level[*env\state+1] * (*env\offset)) / *env\duration[*env\state]
    *env\offset+1
    If *env\offset>*env\duration[*env\state]
      *env\offset = 0
      If *env\state<#ENV_SUSTAIN
        *env\state+1
        If *env\duration[#ENV_SUSTAIN]=0 Then *env\state=#ENV_RELEASE
      EndIf
    EndIf
  End If

  Function Return *env\rlevel

End Function


Statement FAST synth_ReleaseEnv{*env.synthEnv}
  If *env\duration[#ENV_SUSTAIN]><0 Then *env\state=#ENV_RELEASE
End Statement


Statement FAST synth_InitEnvLevel{*env.synthEnv, attack.f, decay.f, sustain.f, release.f}

  *env\level[#ENV_ATTACK  ] = attack          ; 0
  *env\level[#ENV_DECAY   ] = decay           ; 1
  *env\level[#ENV_SUSTAIN ] = sustain         ; .7
  *env\level[#ENV_RELEASE ] = sustain         ; 0
  *env\level[#ENV_END     ] = release         ; 0

End Statement


Statement FAST synth_InitEnvDuration{*env.synthEnv, attack.f, decay.f, sustain.f, release.f}

  *env\duration[#ENV_ATTACK  ] = attack  ; ms
  If decay<1 Then decay=1
  *env\duration[#ENV_DECAY   ] = decay
  If sustain<1 Then sustain=1
  *env\duration[#ENV_SUSTAIN ] = sustain
  If release<1 Then release=1
  *env\duration[#ENV_RELEASE ] = release
  *env\duration[#ENV_END     ] = 0
  *env\ir = Exp(-1.0 / (release/1.0))
  *env\r  = 1.0-*env\ir

End Statement

Statement FAST synth_ResetEnv{*env.synthEnv}

  *env\offset = #ENV_ATTACK
  *env\state  = 0

End Statement


Statement synth_RenderOscWithEnv{*outP.w, sampleN.l, *osc.synthOsc, *filt.synthFilter, *ampEnv.synthEnv, *filtEnv.synthEnv, *pitchEnv.synthEnv}

  If *ampEnv   Then synth_ResetEnv{*ampEnv}   : Else gain.f    = 1.0
  If *filtEnv  Then synth_ResetEnv{*filtEnv}  : Else cutoff.f  = 0
  If *pitchEnv Then synth_ResetEnv{*pitchEnv} : Else pitch.f   = 0

  If *filt    Then synth_ResetFilter{*filt}

  chunkN.l = (*osc\samplingrate+500) / 1000
  While sampleN>0
    todoN.l = Min(chunkN,sampleN)
    If *ampEnv  Then gain   = synth_StepEnv{*ampEnv}
    If *filtEnv Then cutoff = synth_StepEnv{*filtEnv}
    If *pitchEnv Then pitch = synth_StepEnv{*pitchEnv}

    synth_ChangeOsc{*osc,pitch,gain,0}
    synth_RenderOsc{*outP,todoN,*osc,Null}

    If *filt
      synth_ChangeFilter{*filt,cutoff}
      synth_RenderFilter{*outP, *outP, todoN, *filt}
    End If

    sampleN-todoN
    *outP + todoN*SizeOf.w
  Wend

End Statement



CNIF #__include=0
; Demo =========================================================
XINCLUDE "ahi.include.bb2"

DEFTYPE.synthOsc osc, carrier, modulator
DEFTYPE.synthEnv ampEnv, pitchEnv, filtEnv
DEFTYPE.synthFilter filt
DEFTYPE.synthDelay delay
DEFTYPE.synthFlute flute

midiNote.l     = 69 ; A-5
samplingRate.l = 44100
sampleLength.l = samplingRate * 4 ; sec audio
ahi_CreateSound{0,sampleLength*SizeOf.w,samplingRate,1,16}
ahi_CreateSound{1,sampleLength*SizeOf.w,samplingRate,1,16}
ahi_CreateSound{2,sampleLength*SizeOf.w,samplingRate,1,16}
ahi_CreateSound{3,sampleLength*SizeOf.w,samplingRate,1,16}
*bufferP.w     = ahi_GetSoundDataPtr{0}
*scratch1P.w   = ahi_GetSoundDataPtr{1}
*scratch2P.w   = ahi_GetSoundDataPtr{2}
*scratch3P.w   = ahi_GetSoundDataPtr{3}

synth_InitOsc        {osc,#OSC_SAW,samplingRate,0,19*222,1}
synth_RenderOsc{*bufferP,sampleLength,osc}
ahi_SaveSound{0,"RAM:saw.wav",@"WAVE"}

synth_InitOsc        {osc,#OSC_SAWAA,samplingRate,0,19*222,1}
synth_RenderOsc{*bufferP,sampleLength,osc}
ahi_SaveSound{0,"RAM:sawq.wav",@"WAVE"}

synth_InitOsc        {osc,#OSC_IMP,samplingRate,0,220,1}
synth_RenderOsc{*bufferP,sampleLength,osc}
ahi_SaveSound{0,"RAM:imp.wav",@"WAVE"}

synth_InitOsc        {osc,#OSC_SIN,samplingRate,0,220,1}
synth_RenderOsc{*bufferP,sampleLength,osc}
ahi_SaveSound{0,"RAM:sin.wav",@"WAVE"}

synth_InitOsc        {osc,#OSC_TRI,samplingRate,0,220,1}
synth_RenderOsc{*bufferP,sampleLength,osc}
ahi_SaveSound{0,"RAM:triangle.wav",@"WAVE"}

synth_InitOsc        {osc,#OSC_RECT,samplingRate,0,220,1}
synth_RenderOsc{*bufferP,sampleLength,osc}
ahi_SaveSound{0,"RAM:square.wav",@"WAVE"}

synth_InitOsc        {osc,#OSC_NOISE,samplingRate,0,220,1}
synth_RenderOsc{*bufferP,sampleLength,osc}
ahi_SaveSound{0,"RAM:noise.wav",@"WAVE"}

synth_InitOsc        {osc,#OSC_NOISE2,samplingRate,0,220,1}
synth_RenderOsc{*bufferP,sampleLength,osc}
ahi_SaveSound{0,"RAM:noise2.wav",@"WAVE"}


synth_InitOsc        {osc,#OSC_TRI,samplingRate,Pi/3,120,1}
synth_InitEnvLevel   {ampEnv,100,250,150,150}
synth_InitEnvDuration{ampEnv,10,150,400,80}
synth_RenderOscWithEnv{*bufferP,sampleLength,osc,Null,ampEnv,Null,Null}
ahi_SaveSound{0,"RAM:ampenv.wav",@"WAVE"}

synth_InitOsc        {osc,#OSC_TRI,samplingRate,Pi/3,120,1}
synth_InitEnvLevel   {ampEnv,100,250,150,150}
synth_InitEnvDuration{ampEnv,10,150,400,80}
synth_InitEnvLevel   {pitchEnv,128,256,128,128}
synth_InitEnvDuration{pitchEnv,50,100,1,2400}
synth_RenderOscWithEnv{*bufferP,sampleLength,osc,Null,ampEnv,Null,pitchEnv}
ahi_SaveSound{0,"RAM:pitchenv.wav",@"WAVE"}

synth_InitOsc        {carrier  ,#OSC_SIN,samplingRate,Pi/3,220,1}
synth_InitOsc        {modulator,#OSC_SIN,samplingRate,Pi/2,220*27,1}
synth_InitOsc        {osc      ,#OSC_SIN,samplingRate,Pi/5,220*5,1}
synth_InitEnvLevel   {ampEnv,250,150,0,0}
synth_InitEnvDuration{ampEnv,0,700,1000,0}
synth_InitEnvLevel   {filtEnv,150,100,0,0}
synth_InitEnvDuration{filtEnv,100,250,500,0}
synth_InitEnvLevel   {pitchEnv,250,200,100,0}
synth_InitEnvDuration{pitchEnv,0,250,800,0}
synth_RenderOscWithEnv{*scratch1P,sampleLength,carrier  ,Null,ampEnv  ,Null,Null}
synth_RenderOscWithEnv{*scratch2P,sampleLength,modulator,Null,filtEnv ,Null,Null}
synth_RenderOscWithEnv{*scratch3P,sampleLength,osc      ,Null,pitchEnv,Null,Null}
synth_RenderScale{*scratch2P,*scratch2P,sampleLength,148,128}
synth_RenderScale{*scratch3P,*scratch3P,sampleLength,128,128}
synth_RenderAM{*bufferP,*scratch1P,*scratch2P,sampleLength}
synth_RenderAM{*bufferP,*bufferP,*scratch3P,sampleLength}
synth_RenderScale{*bufferP,*bufferP,sampleLength,256*8,0}
ahi_SaveSound{0,"RAM:bell.wav",@"WAVE"}
synth_RenderDither{*bufferP,*bufferP,sampleLength,8,0}
ahi_SaveSound{0,"RAM:bell_d0.wav",@"WAVE"}

synth_InitOsc        {carrier  ,#OSC_TRI,samplingRate,Pi/3,220,1}
synth_InitOsc        {modulator,#OSC_SIN,samplingRate,0,4.5,1}
synth_InitEnvLevel   {ampEnv,250,250,250,250}
synth_InitEnvDuration{ampEnv,0,700,100,1000}
synth_InitEnvLevel   {filtEnv,250,250,150,150}
synth_InitEnvDuration{filtEnv,100,250,100,1000}
synth_RenderOscWithEnv{*scratch1P,sampleLength,carrier  ,Null,ampEnv  ,Null,Null}
synth_RenderOscWithEnv{*scratch2P,sampleLength,modulator,Null,filtEnv ,Null,Null}
synth_RenderAM{*bufferP,*scratch1P,*scratch2P,sampleLength}
ahi_SaveSound{0,"RAM:tremolo.wav",@"WAVE"}
;ahi_PlaySound{0} : Delay_ 100


synth_InitOsc        {carrier  ,#OSC_SAW,samplingRate,0,110.0,1}
synth_InitOsc        {modulator,#OSC_SAW,samplingRate,0.2,110.1,1}
synth_InitEnvLevel   {ampEnv,100,250,150,150}
synth_InitEnvDuration{ampEnv,10,150,400,80}
synth_RenderOscWithEnv{*scratch1P,sampleLength,carrier  ,Null,ampEnv ,Null,Null}
synth_RenderOscWithEnv{*scratch2P,sampleLength,modulator,Null,ampEnv ,Null,Null}
synth_RenderScale{*scratch1P,*scratch1P,sampleLength,128,0}
synth_RenderScale{*scratch2P,*scratch2P,sampleLength,-128,0}
synth_RenderMix{*bufferP,*scratch1P,*scratch2P,sampleLength}
ahi_SaveSound{0,"RAM:detune.wav",@"WAVE"}
;ahi_PlaySound{0} : Delay_ 100


synth_InitOsc        {carrier  ,#OSC_SIN,samplingRate,0,55,1}
synth_InitOsc        {modulator,#OSC_SIN,samplingRate,0.1,55*3,1}
synth_InitEnvLevel   {ampEnv,160,80,40,1}
synth_InitEnvDuration{ampEnv,40,200,8,1500}

synth_RenderOscWithEnv{*scratch1P,sampleLength,modulator,Null,ampEnv ,Null,Null}
;synth_RenderScale{*scratch1P,*scratch1P,sampleLength,80,0}
;synth_RenderFM{*bufferP,*scratch1P,sampleLength,carrier}
ahi_SaveSound{0,"RAM:fm.wav",@"WAVE"}
;ahi_PlaySound{0} : Delay_ 200

synth_InitOsc        {carrier  ,#OSC_TRI,samplingRate,0,55,1}
synth_InitOsc        {modulator,#OSC_SIN,samplingRate,0.1,55*3,1}
synth_InitEnvLevel   {ampEnv,160,80,40,1}
synth_InitEnvDuration{ampEnv,40,200,8,1500}

synth_RenderOscWithEnv{*scratch1P,sampleLength,modulator,Null,ampEnv ,Null,Null}
;synth_RenderScale{*scratch1P,*scratch1P,sampleLength,2280,0}
;synth_RenderPM{*bufferP,*scratch1P,sampleLength,carrier}
ahi_SaveSound{0,"RAM:pm.wav",@"WAVE"}
;ahi_PlaySound{0} : Delay_ 200


synth_InitOsc        {osc,#OSC_SAWAA,samplingRate,Pi/3,55,1}
synth_InitFilter     {filt,#FILTER_BTBLP,110.0,.8,samplingRate}
synth_InitEnvLevel   {ampEnv,100,100,100,100}
synth_InitEnvDuration{ampEnv,10,150,2000,80}
synth_InitEnvLevel   {filtEnv,30,40,0,0}
synth_InitEnvDuration{filtEnv,20,350,1000,2400}
synth_RenderOscWithEnv{*bufferP,sampleLength,osc,filt,ampEnv,filtEnv,Null}
ahi_SaveSound{0,"RAM:filtenv_btblp.wav",@"WAVE"}


synth_InitFilter     {filt,#FILTER_BTBHP,110.0,.8,samplingRate}
synth_RenderOscWithEnv{*bufferP,sampleLength,osc,filt,ampEnv,filtEnv,Null}
ahi_SaveSound{0,"RAM:filtenv_btbhp.wav",@"WAVE"}

synth_InitFilter     {filt,#FILTER_MOOG,110.0,.8,samplingRate}
synth_RenderOscWithEnv{*bufferP,sampleLength,osc,filt,ampEnv,filtEnv,Null}
ahi_SaveSound{0,"RAM:filtenv_moog.wav",@"WAVE"}

synth_InitFilter     {filt,#FILTER_LP1,110.0,.8,samplingRate}
synth_RenderOscWithEnv{*bufferP,sampleLength,osc,filt,ampEnv,filtEnv,Null}
ahi_SaveSound{0,"RAM:filtenv_lp1.wav",@"WAVE"}

synth_InitFilter     {filt,#FILTER_HPx,110.0,.8,samplingRate}
synth_RenderOscWithEnv{*bufferP,sampleLength,osc,filt,ampEnv,filtEnv,Null}
ahi_SaveSound{0,"RAM:filtenv_hpx.wav",@"WAVE"}

;ahi_PlaySound{0} : Delay_ 100

synth_InitOsc        {osc,#OSC_NOISE,samplingRate,Pi/3,110,1}
synth_InitFilter     {filt,#FILTER_LP1,8000.0,.5,samplingRate}
synth_InitEnvLevel   {ampEnv,200,105,0,0}
synth_InitEnvDuration{ampEnv,20,250,400,80}
synth_InitEnvLevel   {filtEnv,200,50,1,1}
synth_InitEnvDuration{filtEnv,20,150,10,2400}
synth_RenderOscWithEnv{*scratch1P,sampleLength,osc,filt,ampEnv,filtEnv,Null}


synth_InitOsc        {osc,#OSC_NOISE,samplingRate,Pi/2,25,1}
synth_InitEnvLevel   {pitchEnv,500,200,100,0}
synth_InitEnvDuration{pitchEnv,40,250,800,0}
synth_RenderOscWithEnv{*scratch2P,sampleLength,osc,Null,ampEnv,Null,pitchEnv}
synth_RenderScale{*scratch1P,*scratch1P,sampleLength,64,0}
synth_RenderMix{*bufferP,*scratch1P,*scratch2P,sampleLength}
ahi_SaveSound{0,"RAM:snare.wav",@"WAVE"}
;ahi_PlaySound{0} : Delay_ 100


synth_InitOsc        {osc,#OSC_SAW,samplingRate,0,100,1}
synth_InitEnvLevel   {pitchEnv,0,2500,0,0}
synth_InitEnvDuration{pitchEnv,10000,0,0,0}
synth_RenderOscWithEnv{*bufferP,sampleLength,osc,Null,Null,Null,pitchEnv}
ahi_SaveSound{0,"RAM:aliasing.wav",@"WAVE"}
;ahi_PlaySound{0} : Delay_ 100

synth_InitOsc        {osc,#OSC_SAWAA,samplingRate,0,100,1}
synth_InitEnvLevel   {pitchEnv,0,2500,0,0}
synth_InitEnvDuration{pitchEnv,10000,0,0,0}
synth_RenderOscWithEnv{*bufferP,sampleLength,osc,Null,Null,Null,pitchEnv}
ahi_SaveSound{0,"RAM:aliasing_free.wav",@"WAVE"}
;ahi_PlaySound{0} : Delay_ 100

synth_InitOsc        {osc,#OSC_NOISE,samplingRate,1,55,1}
synth_InitEnvLevel   {ampEnv,30,0,0,0}
synth_InitEnvDuration{ampEnv,2,2,2,10}
synth_RenderOscWithEnv{*bufferP,sampleLength,osc,Null,ampEnv,Null,Null}

synth_InitOsc        {osc,#OSC_SAW,samplingRate,.5,51,1}
synth_InitEnvLevel   {ampEnv,200,0,0,0}
synth_RenderOscWithEnv{*scratch1P,sampleLength,osc,Null,ampEnv,Null,Null}
synth_RenderMix{*bufferP,*bufferP,*scratch1P,sampleLength}

synth_InitFilter     {filt,#FILTER_MOOG,4700.0,.4,samplingRate}
synth_RenderFilter    {*bufferP,*bufferP,sampleLength,filt}


synth_InitDelay       {delay,55*8,20000,20,1.0,samplingRate}
synth_RenderDelay     {*bufferP,*bufferP,sampleLength,delay}
;synth_RenderWaveShape {*bufferP,*bufferP,sampleLength,&SawTable(0)}
ahi_SaveSound{0,"RAM:delay.wav",@"WAVE"}


synth_InitOsc        {osc,#OSC_NOISE,samplingRate,1,55,1}
synth_InitEnvLevel   {ampEnv,0,.20,.10,0}
synth_InitEnvDuration{ampEnv,50,1000,2000,10}
synth_RenderOscWithEnv{*bufferP,sampleLength,osc,Null,ampEnv,Null,Null}


synth_InitFilter     {filt,#FILTER_LP1,2400.0,.9,samplingRate}
synth_RenderFilter    {*bufferP,*bufferP,sampleLength,filt}

synth_InitFlute        {flute,samplingRate,.0002,55*4,1}
synth_RenderFlute      {*bufferP,*bufferP,flute,sampleLength}



ahi_SaveSound{0,"RAM:flute.wav",@"WAVE"}
ahi_PlaySound{0} : Delay_ 100



End
CEND

