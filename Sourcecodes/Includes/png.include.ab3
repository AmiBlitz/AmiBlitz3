; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "/Bin"
; ExeFile         = "PNGDemo"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 22
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 985
; CursorColumn    = 2
; LabelSearch     = "tempbuffer_get"
; LabelRemark     = 0
; LabelAll        = 1
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 5
; Max GadgetList  = 5
; Max Shape       = 100
; Max Bank        = 5
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 5
; Max Palette     = 4
; Max BitMap      = 10
; Max Screen      = 5
; Max Window      = 5
; Max IntuiFont   = 5
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: png.include                                                           /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 29/12/2006                                                            /
;/                                                                             /
;/ Author: Thilo Koehler                                                       /
;/                                                                             /
;/ Requirements:  Amiblitz2.4, ab3zlib.library                                 /
;/                                                                             /
;/ Purpose:                                                                    /
;/ This is a include to support the image.include with png functionality.      /
;/                                                                             /
;/ Abstract:                                                                   /
;/ This include is of not much use stand alone, as you can load and save ima:: /
;/ ges through the image.include, but you might want to have a look at the s:: /
;/ ource code for educational reasons.                                         /
;/                                                                             /
;/ This include is used by the image.include to load the alpha channel of a :: /
;/ .png file, because picture.datatype on OS3.x does not support this.         /
;/ It can also be used to save a png file from an ARGB or RGB pixel array.     /
;/                                                                             /
;/ User Constants: none                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
CNIF #__include=0
  OPTIMIZE 7
  SYNTAX 6
CEND

XINCLUDE "error.include.ab3"
XINCLUDE "zlib.include.ab3"
XINCLUDE "crc32.include.ab3"
XINCLUDE "file.include.ab3"
XINCLUDE "tempbuffer.include.ab3"

NEWTYPE.PNG_IHDR
  _PNG.l
  _check.l
  csize.l
  IHDR.l
  img_width.l               ; : 4 bytes
  img_height.l              ; : 4 bytes
  img_bitdepth.b            ; : 1 byte
  img_colortype.b           ; : 1 byte
  img_compression_method.b  ; : 1 byte
  img_filter_method.b       ; : 1 byte
  img_interlace_method.b    ; : 1 byte
  b.b[4]
  ;dy.l
End NEWTYPE

NEWTYPE.PNG_IEND
  csize.l
  IEND.l
End NEWTYPE

;Color                         Allowed     Interpretation
#png_color_gray       = 0   ; 1,2,4,8,16  Each pixel is a grayscale sample.
#png_color_rgb        = 2   ; 8,16        Each pixel is an R,G,B triple.
#png_color_clut       = 3   ; 1,2,4,8     Each pixel is a Index;  a PLTE chunk must appear.
#png_color_ga         = 4   ; 8,16        Each pixel is a grayscale sample, followed by an alpha sample.
#png_color_rgba       = 6   ; 8,16        Each pixel is an R,G,B triple, followed by an alpha sample.

#png_filter_none      = 0   ; None
#png_filter_sub       = 1   ; SUB
#png_filter_up        = 2   ; Up
#png_filter_average   = 3   ; Average
#png_filter_paeth     = 4   ; Paeth

#png_interlace_none   = 0   ; no interlacing
#png_interlace_adam7  = 1   ; adam7 scheme interlacing
; adam 7
;   1 6 4 6 2 6 4 6
;   7 7 7 7 7 7 7 7
;   5 6 5 6 5 6 5 6
;   7 7 7 7 7 7 7 7
;   3 6 4 6 3 6 4 6
;   7 7 7 7 7 7 7 7
;   5 6 5 6 5 6 5 6
;   7 7 7 7 7 7 7 7


#png_compression_zlib = 0   ; zlib compression

#png_filtermethod_5   = 0   ; 5 filters, standard

#png_unfilter_ARGB    = 0
#png_unfilter_alpha   = 1
#png_unfilter_RGB     = 2


NEWTYPE.PNG_IDAT
  csize.l
  IDAT.l
End NEWTYPE

NEWTYPE.PNG_bKGD
  csize.l
  bKGD.l
  R.w
  G.w
  B.w
End NEWTYPE


NEWTYPE.png_engine
  is_open.l
  dos.l
  compressed_data.l
  buffer_size.l
  compressed_size.l
End NEWTYPE

SHARED png_engine.png_engine
SHARED PNG_IHDR.PNG_IHDR
SHARED PNG_IDAT.PNG_IDAT
SHARED PNG_IEND.PNG_IEND
SHARED PNG_bKGD.PNG_bKGD

USEPATH png_engine
\is_open = False
\dos     = -1
\compressed_data = 0


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  width.l = png_GetWidth{}                                          /
;/                                                                             /
;/ Description:                                                                /
;/ Return the width of the open png image in pixel.                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - width.l     : width in pixel                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_GetWidth{}
 Function Return PNG_IHDR\img_width
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  height.l = png_GetHeight{}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ Return the height of the png image in pixel.                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - height.l     : height in pixel                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_GetHeight{}
 Function Return PNG_IHDR\img_height
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = png_FindChunk{dos.l,chunk.l,@pos.l,@blength.l,@immed:: /
;/ iate.l}                                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Find a chunk within a png file.                                             /
;/ NOTE: The chunk format is different from the FORM chunks, so the png.incl:: /
;/ ude needs its own function.                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - dos.l    : file object ID (file.include)                                  /
;/ - chunk.l    : chunk header ID                                              /
;/ - pos.l    : file seek position from where to start                         /
;/ - blength.l    : maximum byte length                                        /
;/ - immediate.l    : allow the first chunk to be found                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_FindChunk{dos.l,chunk.l,@pos.l,@blength.l,@immediate.l}
  If blength<=0 Then blength = file_GetLength{dos}-pos
  If pos<0 Then pos.l = file_GetSeekPos{dos}
  count.l = 0
  If immediate Then immediate = 0:Else immediate=1
  Repeat
    If file_Seek{dos,pos}
      dummy2.l = file_ReadMem{dos,&chlen.l,4}
      dummy2.l & file_ReadMem{dos,&dummy.l,4}
      If dummy2
        blength-chlen - 8 -4
        pos + chlen + 8 +4
        If pos>=file_GetLength{dos} OR pos<=0 Then blength=-1
        count+1
      Else
        blength=-1
        dummy=0
      End If
    Else
      blength=0
      dummy=0
      error{"Called file_findchunk() with invalid seek position ! ("+Str$(pos)+")"}
    End If
    If count<=immediate Then dummy=0

  Until dummy = chunk OR blength<=0
  If dummy = chunk Then succ.l = pos-chlen-8-4:dummy=file_Seek{dos,succ}:Else succ.l = False
 Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: png_Close{}                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ Close the png file.                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement png_Close{}
  If \compressed_data Then FreeVec_ \compressed_data
  If \dos>=0 Then  file_Close{\dos}
  \is_open    = False
  \compressed_data = 0
  \dos        = -1
End Statement
!autoexit{png_Close}

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = png_Open{filename.s}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Open a png file for reading.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : file name of the png file                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_Open{filename.s}

  png_Close{}
  dos.l = file_Open{filename.s,#file_read}
  If dos>=0
    \dos = dos
    If file_ReadMem{\dos,PNG_IHDR,SizeOf.PNG_IHDR-1}
      If (PNG_IHDR\_PNG = $89504E47) AND (PNG_IHDR\_check=$0D0A1A0A) AND (PNG_IHDR\IHDR = @"IHDR")
        If (PNG_IHDR\img_colortype = #png_color_rgba) AND (PNG_IHDR\img_bitdepth = 8)
         If (PNG_IHDR\img_compression_method = #png_compression_zlib) AND (PNG_IHDR\img_filter_method=#png_filtermethod_5)
           If (PNG_IHDR\img_interlace_method=#png_interlace_none OR PNG_IHDR\img_interlace_method=#png_interlace_adam7)
             If png_FindChunk{dos,@"IDAT"}
               \is_open = True
             End If
           Else
            ; error{"png_Open: unsupported interlace mode: "+Str$(PNG_IHDR\img_interlace_method)}
           End If
         End If
        End If
      End If
    End If
  End If
  If \is_open=False Then png_Close{}
 Function Return \is_open
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = png_Filter{sourceaddr.l,destaddr.l,lines.l,bpr.l,fil:: /
;/ tertype.l,bpp.l}                                                            /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/ Perform the png filtering.                                                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - sourceaddr.l    : ???                                                     /
;/ - destaddr.l    : ???                                                       /
;/ - lines.l    : ???                                                          /
;/ - bpr.l    : ???                                                            /
;/ - filtertype.l    : ???                                                     /
;/ - bpp.l    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_Filter{sourceaddr.l,destaddr.l,lines.l,bpr.l,filtertype.l,bpp.l}
  srowmod.l = bpr
  drowmod.l = PNG_IHDR\img_width * bpp
  done.l = 0
  For y.l = 0 To lines-1
    Poke.b destaddr,filtertype
    destaddr+1
    done+1

    Select bpp
      Case 3
        Select filtertype
          Case #png_filter_none
            ; convert from ARGB to RGBA
            For n.l=0 To PNG_IHDR\img_width-1
              Poke.b destaddr+n*3+0,Peek.b(sourceaddr+n*4+1)
              Poke.b destaddr+n*3+1,Peek.b(sourceaddr+n*4+2)
              Poke.b destaddr+n*3+2,Peek.b(sourceaddr+n*4+3)
            Next
            sourceaddr+srowmod
            destaddr+drowmod
            done+drowmod

          Default
            error{"\\__THIS_FUNCTION: requested filter type is not implemented ("+Str$(filtertype)+" )!"}
            y = lines
            done=0
        End Select


      Case 4
        Select filtertype
          Case #png_filter_none
            ; convert from ARGB to RGBA
            For n.l=0 To PNG_IHDR\img_width-1
              Poke.b destaddr+n*4+0,Peek.b(sourceaddr+n*4+1)
              Poke.b destaddr+n*4+1,Peek.b(sourceaddr+n*4+2)
              Poke.b destaddr+n*4+2,Peek.b(sourceaddr+n*4+3)
              Poke.b destaddr+n*4+3,Peek.b(sourceaddr+n*4+0)
            Next
            sourceaddr+srowmod
            destaddr+drowmod
            done+drowmod

          Default
            error{"\\__THIS_FUNCTION: requested filter type is not implemented ("+Str$(filtertype)+" )!"}
            y = lines
            done=0
        End Select


      Default
        error{"\\__THIS_FUNCTION: unsupported pixelformat (BytesPerPixel:"+Str$(bpp)+")!"}
    End Select
  Next
 Function Return done
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = png_Write{dos.l,dataptr.l,img_width.l,img_height.l,b:: /
;/ pr.l,@compress.l,@usealpha.l}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ Write a png file.                                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - dos.l    : ???                                                            /
;/ - dataptr.l    : ???                                                        /
;/ - img_width.l    : ???                                                      /
;/ - img_height.l    : ???                                                     /
;/ - bpr.l    : ???                                                            /
;/ - compress.l    : ???                                                       /
;/ - usealpha.l    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_Write{dos.l,dataptr.l,img_width.l,img_height.l,bpr.l,@compress.l,@usealpha.l,@bgcolor.l}

  succ.l = True
  If compress<1 Then compress=6 ; default compression level

  ; write header information
  PNG_IHDR\_PNG                     = $89504E47
  PNG_IHDR\_check                   = $0D0A1A0A
  PNG_IHDR\IHDR                     = @"IHDR"
  PNG_IHDR\csize                    = 13
  PNG_IHDR\img_width                = img_width
  PNG_IHDR\img_height               = img_height
  PNG_IHDR\img_bitdepth             = 8 ; bit per color sample
  If usealpha
    PNG_IHDR\img_colortype          = #png_color_rgba
    bpp.l = 4
  Else
    PNG_IHDR\img_colortype          = #png_color_rgb
    bpp.l = 3
  End If
  PNG_IHDR\img_compression_method   = 0 ; always 0, 32k sliding window
  PNG_IHDR\img_filter_method        = 0 ; filter method, always 0 (5 filter method)
  PNG_IHDR\img_interlace_method     = 0 ; 0 = no interlace, 1 = adam7 inerlace
  PNG_IHDR\b[0]                     = 0
  PNG_IHDR\b[1]                     = 0
  PNG_IHDR\b[2]                     = 0
  PNG_IHDR\b[3]                     = 0
  succ & file_WriteMem{dos,PNG_IHDR,13+8+8}
  CRC.l = CRC32_FromMem{&PNG_IHDR\IHDR,13+4}
  succ & file_WriteLong{dos,CRC}

  If bgcolor><-1
    PNG_bKGD\csize = 6
    PNG_bKGD\bKGD  = @"bKGD"
    PNG_bKGD\R     = (bgcolor LSR 16) &$FF
    PNG_bKGD\G     = (bgcolor LSR  8) &$FF
    PNG_bKGD\B     = (bgcolor       ) &$FF
    succ & file_WriteMem{dos,PNG_bKGD,SizeOf.PNG_bKGD}
    CRC.l = CRC32_FromMem{&PNG_bKGD\bKGD,6+4}
    succ & file_WriteLong{dos,CRC}
  End If

  ; write data
  tempsize.l  = img_width*img_height*bpp + img_height
  tempsize2.l = zlib_CompressBound{tempsize}
  temp.l  = AllocVec_(tempsize ,#MEMF_ANY)
  ctemp.l = AllocVec_(tempsize2,#MEMF_ANY)
  If temp><0 AND ctemp><0
    Rows.l        = img_height
    BytesPerRow.l = img_width * bpp
    RowsAtOnce.l  = Min(img_height,tempsize / BytesPerRow)

    While Rows>0
      DoRows.l=Rows;Min(RowsAtOnce,Rows)
      Rows-DoRows
      BytesDone.l = png_Filter{dataptr,temp,DoRows,bpr,#png_filter_none,bpp}
      clength.l = 0
      dataptr + DoRows*BytesPerRow
      clength = tempsize2
      status.l = zlib_Compress{ctemp,&clength,temp,BytesDone,compress}
      If status = #Z_OK
        PNG_IDAT\csize = clength
        PNG_IDAT\IDAT = @"IDAT"
        succ & file_WriteMem{dos,PNG_IDAT,8};SizeOf.PNG_IDAT}
        succ & file_WriteMem{dos,ctemp,clength}
        CRC = CRC32_Add{$ffffffff,&PNG_IDAT\IDAT,4}
        CRC = CRC32_Add{CRC,ctemp,clength}
        CRC = CRC32_Finalize{CRC}
        succ & file_WriteLong{dos,CRC}
      End If
    Wend
  End If
  If temp  Then FreeVec_ temp  :temp  = 0
  If ctemp Then FreeVec_ ctemp :ctemp = 0

  ; write end
  PNG_IEND\IEND = @"IEND"
  PNG_IEND\csize = 0
  succ & file_WriteMem{dos,PNG_IEND,SizeOf.PNG_IEND}
  CRC = CRC32_FromMem{&PNG_IEND\IEND,4}
  succ & file_WriteLong{dos,CRC}
 Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_unfilter_peath                                                 /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_unfilter_peath
  p.l  = `1a + `1b - `1c
  pa.l = (p-`1a) : If pa<0 Then pa=0-pa
  pb.l = (p-`1b) : If pb<0 Then pb=0-pb
  pc.l = (p-`1c) : If pc<0 Then pc=0-pc
  Poke.b &`1px+3,Peek.b(sourceaddr+(`2))

  If pa<=pb AND pa<=pc
    p = `1a + `1px
  Else
    If pb<=pc
      p = `1b + `1px
    Else
      p = `1c + `1px
    End If
  End If
  Poke.b destaddr+(`3),Peek.b(&p+3)
  `1a = p & $FF
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_unfilter_up                                                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_unfilter_up
  Poke.b &`1px+3,Peek.b(sourceaddr+`2)
  p.l = `1px + `1b
  Poke.b destaddr+`3,Peek.b(&p+3)
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_unfilter_sub                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_unfilter_sub
  Poke.b &`1px+3,Peek.b(sourceaddr+`2)
  p.l = `1px + `1a
  `1a = p & $FF
  Poke.b destaddr+`3,Peek.b(&p+3)
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_unfilter_average                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_unfilter_average
  Poke.b &`1px+3,Peek.b(sourceaddr+`2)
;  p.l = Int((`1a+`1b)/2) + `1px
  p.l = ((`1a+`1b) LSR 1) + `1px
  `1a = p & $FF
  Poke.b destaddr+`3,Peek.b(&p+3)
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_init_a                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_init_a
  Aa=0
  Ra=0
  Ga=0
  Ba=0
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_init_b                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_init_b
  If y>0
    Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow+0)
    Poke.b &Rb+3,Peek.b(destaddr-dBytesPerRow+1)
    Poke.b &Gb+3,Peek.b(destaddr-dBytesPerRow+2)
    Poke.b &Bb+3,Peek.b(destaddr-dBytesPerRow+3)
  Else
    Ab=0
    Rb=0
    Gb=0
    Bb=0
  End If
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_init_c                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_init_c
  Ac=0
  Rc=0
  Gc=0
  Bc=0
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_shift_b                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_shift_b
  If y>0
    Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow+0)
    Poke.b &Rb+3,Peek.b(destaddr-dBytesPerRow+1)
    Poke.b &Gb+3,Peek.b(destaddr-dBytesPerRow+2)
    Poke.b &Bb+3,Peek.b(destaddr-dBytesPerRow+3)
  End If
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_shift_c                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_shift_c
;  If y>0
    Ac = Ab
    Rc = Rb
    Gc = Gb
    Bc = Bb
;  End If
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_inc_buffer                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_inc_buffer
  destaddr+dBytesPerPixel
  sourceaddr+sBytesPerPixel
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = png_Unfilter{sourceaddr.l,destaddr.l,pixelwidth.l,sc:: /
;/ anlines.l,bpr.l,bpp.l,mode.l}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - sourceaddr.l    : ???                                                     /
;/ - destaddr.l    : ???                                                       /
;/ - bpr.l    : ???                                                            /
;/ - mode.l    : ???                                                           /
;/ - pixelwidth.l    : ???                                                     /
;/ - scanlines.l    : ???                                                      /
;/ - bpp.l    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_Unfilter{sourceaddr.l,destaddr.l,pixelwidth.l,scanlines.l,bpr.l,bpp.l,mode.l}
  sBytesPerPixel.l = 4 ; we only decode ARGB pngs
  sBytesPerRow.l   = pixelwidth*sBytesPerPixel

  ;Select mode
  ;  Case #png_unfilter_ARGB
  ;    dBytesPerPixel.l = 4
  ;  Case #png_unfilter_RGB
  ;    dBytesPerPixel.l = 3
  ;  Case #png_unfilter_alpha
  ;    dBytesPerPixel.l = 1
  ;End Select
  dBytesPerRow.l   = bpr
  dBytesPerPixel.l = bpp
  Aa.l = 0 ; left
  Ab.l = 0 ; above
  Ac.l = 0 ; upperleft
  Ra.l = 0 ; left
  Rb.l = 0 ; above
  Rc.l = 0 ; upperleft
  Ga.l = 0 ; left
  Gb.l = 0 ; above
  Gc.l = 0 ; upperleft
  Ba.l = 0 ; left
  Bb.l = 0 ; above
  Bc.l = 0 ; upperleft
  Apx.l = 0
  Rpx.l = 0
  Gpx.l = 0
  Bpx.l = 0

  sourcebase.l = sourceaddr
  destbase.l   = destaddr
  For y.l = 0 To scanlines-1 ; PNG_IHDR\img_height-1
    destaddr.l = destbase + y*dBytesPerRow
    prefilt.b  = filt.b
    filt.b     = Peek.b(sourceaddr)
    sourceaddr+1
       ; error{"Decoding filter id="+Str$(filt)+"!"}
    Select filt
      Case #png_filter_none
        Select mode
          Case #png_unfilter_alpha
            For x.l = 0 To pixelwidth-1 ;PNG_IHDR\img_width-1
              Poke.b destaddr,Peek.b(sourceaddr+3)
              !png_inc_buffer
            Next

          Case #png_unfilter_ARGB
            For x.l = 0 To pixelwidth-1 ; PNG_IHDR\img_width-1
              Poke.b destaddr+3,Peek.b(sourceaddr+2) ; B
              Poke.b destaddr+2,Peek.b(sourceaddr+1) ; G
              Poke.b destaddr+1,Peek.b(sourceaddr+0) ; R
              Poke.b destaddr+0,Peek.b(sourceaddr+3) ; A
              !png_inc_buffer
            Next

        End Select


      Case #png_filter_sub
        Select mode
          Case #png_unfilter_alpha
            Aa = 0
            For x.l = 0 To pixelwidth-1 ;PNG_IHDR\img_width-1
              !png_unfilter_sub{A,3,0}
              !png_inc_buffer
            Next

          Case #png_unfilter_ARGB
            !png_init_a
            For x.l = 0 To pixelwidth-1 ;PNG_IHDR\img_width-1
              !png_unfilter_sub{B,2,3}
              !png_unfilter_sub{G,1,2}
              !png_unfilter_sub{R,0,1}
              !png_unfilter_sub{A,3,0}
              !png_inc_buffer
            Next

        End Select


      Case #png_filter_up
        Select mode
          Case #png_unfilter_alpha
            If y>0 Then Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow):Else Ab=0
            For x.l = 0 To pixelwidth-1;PNG_IHDR\img_width-1
              !png_unfilter_up{A,3,0}
              !png_inc_buffer
              If y>0 Then Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow)
            Next

          Case #png_unfilter_ARGB
            !png_init_b
            For x.l = 0 To pixelwidth-1;PNG_IHDR\img_width-1
              !png_unfilter_up{B,2,3}
              !png_unfilter_up{G,1,2}
              !png_unfilter_up{R,0,1}
              !png_unfilter_up{A,3,0}
              !png_inc_buffer
              !png_shift_b
            Next

        End Select


      Case #png_filter_average
        Select mode
          Case #png_unfilter_alpha
            Aa = 0
            If y>0 Then Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow):Else Ab=0
            For x.l = 0 To pixelwidth-1;PNG_IHDR\img_width-1
              !png_unfilter_average{A,3,0}
              !png_inc_buffer
              If y>0 Then Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow)
            Next

          Case #png_unfilter_ARGB
            !png_init_a
            !png_init_b
            For x.l = 0 To pixelwidth-1;PNG_IHDR\img_width-1
              !png_unfilter_average{B,2,3}
              !png_unfilter_average{G,1,2}
              !png_unfilter_average{R,0,1}
              !png_unfilter_average{A,3,0}
              !png_inc_buffer
              !png_shift_b
            Next

        End Select


      Case #png_filter_paeth
        Select mode
          Case #png_unfilter_alpha
            Aa=0:Ac=0
            If y>0 Then Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow) :Else Ab=0
            For x.l = 0 To pixelwidth-1;PNG_IHDR\img_width-1
              !png_unfilter_peath{A,3,0}
              !png_inc_buffer
              If y>0 Then Ac = Ab : Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow)
            Next

          Case #png_unfilter_ARGB
            !png_init_a
            !png_init_b
            !png_init_c
            For x.l = 0 To pixelwidth-1;PNG_IHDR\img_width-1
              !png_unfilter_peath{B,2,3}
              !png_unfilter_peath{G,1,2}
              !png_unfilter_peath{R,0,1}
              !png_unfilter_peath{A,3,0}
              !png_inc_buffer
              !png_shift_c
              !png_shift_b
            Next

        End Select


      Default
        sourceaddr + sBytesPerRow
        destaddr   + dBytesPerRow
        If errdone.l=0
          error{"Invalid filter in png file (line "+Str$(y)+", filter id "+Str$(filt)+", pre id "+Str$(prefilt)+")!"}
          errdone = -1
        End If
    End Select

  Next

  BytesDone.l = sourceaddr-sourcebase
 Function Return BytesDone
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = png_Read{}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_Read{}
  SHARED filedat()
  succ.l = 0
  If \is_open
    \buffer_size = file_GetLength{\dos}

    offset.l = 0
    \compressed_data = AllocVec_(\buffer_size,#MEMF_ANY)

    While png_FindChunk{\dos,@"IDAT"}
      If file_ReadMem{\dos,PNG_IDAT,SizeOf.PNG_IDAT}
        If file_ReadMem{\dos,\compressed_data+offset,PNG_IDAT\csize}
          offset + PNG_IDAT\csize
          file_SeekRel{\dos,4}
        End If
      End If
    Wend

    If offset>0 Then succ=True
    \compressed_size = offset
  End If
 Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_unfilter_adam7_alpha{xoff,yoff,xstep,ystep}                   /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - xoff    : ???                                                             /
;/ - yoff    : ???                                                             /
;/ - xstep    : ???                                                            /
;/ - ystep    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_unfilter_adam7_alpha;{xoff,yoff,xstep,ystep}
   pixelxoff.l  = `1
   pixelxstep.l = `3
   pixelyoff.l  = `2
   pixelystep.l = `4
   pixelwidth.l = (PNG_IHDR\img_width+pixelxstep-1-pixelxoff)/pixelxstep
   scanlines.l  = (PNG_IHDR\img_height+pixelystep-1-pixelyoff)/pixelystep
   destoff.l    = pixelxoff *1 + pixelyoff * bpr
   If pixelwidth>0 AND scanlines>0
     temp+  png_Unfilter{temp,destbuffer+destoff,pixelwidth,scanlines,bpr*pixelystep,1*pixelxstep,#png_unfilter_alpha}
   End If
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: png_DecodeAlpha{destbuffer.l,bpr.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Decode (means decompress and unfilter) a png buffer into an 8bit alpha ar:: /
;/ ray.                                                                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - destbuffer.l    : memory pointer of the alpha array (make sure it is bi:: /
;/ g enough: width*height*1 bytes!)                                            /
;/ - bpr.l    : bpr of the alpha array                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement png_DecodeAlpha{destbuffer.l,bpr.l}
  If \is_open
    If \compressed_data
      If destbuffer
        temp_size.l = PNG_IHDR\img_width*PNG_IHDR\img_height*4   +PNG_IHDR\img_height*2 +4
        temp.l = tempbuffer_Get{temp_size}
        If temp
          status.l = zlib_Uncompress{temp,&temp_size,\compressed_data,\compressed_size}
          If status = #Z_OK
            Select PNG_IHDR\img_interlace_method
              Case #png_interlace_none
                png_Unfilter{temp,destbuffer,PNG_IHDR\img_width,PNG_IHDR\img_height,bpr,1,#png_unfilter_alpha}
              Case #png_interlace_adam7
                !png_unfilter_adam7_alpha{0,0,8,8}
                !png_unfilter_adam7_alpha{4,0,8,8}
                !png_unfilter_adam7_alpha{0,4,4,8}
                !png_unfilter_adam7_alpha{2,0,4,4}
                !png_unfilter_adam7_alpha{0,2,2,4}
                !png_unfilter_adam7_alpha{1,0,2,2}
                !png_unfilter_adam7_alpha{0,1,1,2}
            End Select
          Else
            error{"\\__THIS_FUNCTION: Unable to decrunch !"}
          End If
        Else
          error{"\\__THIS_FUNCTION: Not enough memory for temp buffer!"}
        End If
      End If
    End If
  End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_unfilter_adam7_argb{xoff,yoff,xstep,ystep}                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - xoff    : ???                                                             /
;/ - yoff    : ???                                                             /
;/ - xstep    : ???                                                            /
;/ - ystep    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_unfilter_adam7_argb;{xoff,yoff,xstep,ystep}
   pixelxoff.l  = `1
   pixelxstep.l = `3
   pixelyoff.l  = `2
   pixelystep.l = `4
   pixelwidth.l = (PNG_IHDR\img_width+pixelxstep-1-pixelxoff)/pixelxstep
   scanlines.l  = (PNG_IHDR\img_height+pixelystep-1-pixelyoff)/pixelystep
   destoff.l    = pixelxoff *4 + pixelyoff * bpr
   If pixelwidth>0 AND scanlines>0
     temp+  png_Unfilter{temp,destbuffer+destoff,pixelwidth,scanlines,bpr*pixelystep,4*pixelxstep,#png_unfilter_ARGB}
   End If
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: png_DecodeARGB{destbuffer.l,bpr.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Decode (means decompress and unfilter) a png buffer into an ARGB pixel ar:: /
;/ ray.                                                                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - destbuffer.l    : memory pointer of the ARGB pixel array (make sure it :: /
;/ is big enough: width*height*4 bytes!)                                       /
;/ - bpr.l    : bpr of the ARGB pixel array                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement png_DecodeARGB{destbuffer.l,bpr.l}
  If \is_open
    If \compressed_data
      If destbuffer
        temp_size.l = PNG_IHDR\img_width*PNG_IHDR\img_height*4     +PNG_IHDR\img_height*2 +4
        temp.l = tempbuffer_Get{temp_size}
        tempx.l = temp
        If temp
;error{Str$(temp) + " " + Str$(temp_size)}
          status.l = zlib_Uncompress{temp,&temp_size,\compressed_data,\compressed_size}
          If status = #Z_OK
            Select PNG_IHDR\img_interlace_method
              Case #png_interlace_none
                png_Unfilter{temp,destbuffer,PNG_IHDR\img_width,PNG_IHDR\img_height,bpr,4,#png_unfilter_ARGB}
              Case #png_interlace_adam7
                !png_unfilter_adam7_argb{0,0,8,8}
                !png_unfilter_adam7_argb{4,0,8,8}
                !png_unfilter_adam7_argb{0,4,4,8}
                !png_unfilter_adam7_argb{2,0,4,4}
                !png_unfilter_adam7_argb{0,2,2,4}
                !png_unfilter_adam7_argb{1,0,2,2}
                !png_unfilter_adam7_argb{0,1,1,2}
            End Select
          Else
            error{"\\__THIS_FUNCTION: Unable to decrunch (error #" + Str$(status) + ") !"}
          End If
        Else
          error{"\\__THIS_FUNCTION: Not enough memory for temp buffer!"}
        End If
      End If
    End If
  End If
End Statement


;include Demo
CNIF #__include=0

  If png_Open{"/Data/AlphaBlit.png"}
    NPrint "PNG file open !"
    succ.l = png_Read{}
    If succ
      ; png_DecodeAlpha{destbuffer.l,awidth.l,aheight.l}
      NPrint "Alphachannel loaded !",succ
    Else
      NPrint "No Aplha infile !"
    End If
    png_Close{}
  Else
    NPrint "File is not an PNG file !"
  End If

  ;Delay_ 200
  End

CEND
