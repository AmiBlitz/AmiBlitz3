; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "/Bin"
; ExeFile         = "PNGDemo"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 19
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 11
; CursorColumn    = 73
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 5
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 5
; Max ChunkyBuffer= 2
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: png.include                                                           /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 29/12/2006                                                            /
;/                                                                             /
;/ Author: Thilo Koehler                                                       /
;/                                                                             /
;/ Requirements:  Amiblitz2.4, z.library                                       /
;/                                                                             /
;/ Purpose:                                                                    /
;/ This is a include to support the image.inlcude with png functionality.      /
;/                                                                             /
;/ Abstract:                                                                   /
;/ This include is of not much use stand alone, as you can load and save ima:: /
;/ ges through the image.include, but you might want to have a look at the s:: /
;/ ource code for educational reasons.                                         /
;/                                                                             /
;/ This include is used by the image.include to load the alpha channel of a :: /
;/ .png file, because picture.datatype on OS3.x does not support this.         /
;/ It can also be used to save a png file from an ARGB or RGB pixel array.     /
;/                                                                             /
;/ User Constants: none                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
CNIF #__include=0
optimize 7
Syntax 2
CEND
 
XINCLUDE "crc32.include.ab3"
XINCLUDE "file.include.ab3"
XINCLUDE "tempbuffer.include.ab3"
XINCLUDE "z.include.ab3"

NEWTYPE.PNG_IHDR
_PNG.l
_check.l
csize.l
IHDR.l
img_width.l ; :              4 bytes
img_height.l ; :             4 bytes
img_bitdepth.b ; :          1 byte
img_colortype.b ; :         1 byte
img_compression_method.b ; : 1 byte
img_filter_method.b ; :          1 byte
img_interlace_method.b ; :   1 byte
b.b[4]
;dy.l
End NEWTYPE

NEWTYPE.PNG_IEND
csize.l
IEND.l
End NEWTYPE

;Color                        Allowed     Interpretation
#png_color_gray  =   0 ;  1,2,4,8,16  Each pixel is a grayscale sample.
#png_color_rgb   =   2 ;  8,16        Each pixel is an R,G,B triple.
#png_color_clut  =   3 ;  1,2,4,8     Each pixel is a Index;  a PLTE chunk must appear.
#png_color_ga    =   4 ;  8,16        Each pixel is a grayscale sample, followed by an alpha sample.
#png_color_rgba  =   6 ;  8,16        Each pixel is an R,G,B triple, followed by an alpha sample.

#png_filter_none    =   0   ; None
#png_filter_sub     =   1   ; SUB
#png_filter_up      =   2   ; Up
#png_filter_average =   3   ; Average
#png_filter_paeth   =   4   ; Paeth

#png_interlace_none     = 0 ; no interlacing
#png_interlace_adam7    = 1 ; adam7 scheme interlacing
; adam 7
;   1 6 4 6 2 6 4 6
;   7 7 7 7 7 7 7 7
;   5 6 5 6 5 6 5 6
;   7 7 7 7 7 7 7 7
;   3 6 4 6 3 6 4 6
;   7 7 7 7 7 7 7 7
;   5 6 5 6 5 6 5 6
;   7 7 7 7 7 7 7 7


#png_compression_zlib   = 0 ; zlib compression

#png_filtermethod_5  = 0; 5 filters, standard

#png_unfilter_ARGB   = 0
#png_unfilter_alpha  = 1
#png_unfilter_RGB    = 2

NEWTYPE.PNG_IDAT
csize.l
IDAT.l
End NEWTYPE

NEWTYPE.PNG_bKGD
csize.l
bKGD.l
R.w
G.w
B.w
End NEWTYPE


NEWTYPE.png_engine
is_open.l
dos.l
compressed_data.l
buffer_size.l
compressed_size.l
End NEWTYPE

SHARED png_engine.png_engine
SHARED PNG_IHDR.PNG_IHDR
SHARED PNG_IDAT.PNG_IDAT
SHARED PNG_IEND.PNG_IEND
SHARED PNG_bKGD.PNG_bKGD

USEPATH png_engine
\is_open = False
\dos     = -1
\compressed_data = 0

version_zlib.l = 0

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  width.l = png_GetWidth{}                                          /
;/                                                                             /
;/ Description:                                                                /
;/ Return the width of the open png image in pixel.                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - width.l     : width in pixel                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_GetWidth{}
Function Return PNG_IHDR\img_width
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  height.l = png_GetHeight{}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ Return the height of the png image in pixel.                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - height.l     : height in pixel                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_GetHeight{}
Function Return PNG_IHDR\img_height
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = png_FindChunk{dos.l,chunk.l,@pos.l,@blength.l,@immed:: /
;/ iate.l}                                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Find a chunk within a png file.                                             /
;/ NOTE: The chunk format is different from the FORM chunks, so the png.incl:: /
;/ ude needs its own function.                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - dos.l    : file object ID (file.include)                                  /
;/ - chunk.l    : chunk header ID                                              /
;/ - pos.l    : file seek position from where to start                         /
;/ - blength.l    : maximum byte length                                        /
;/ - immediate.l    : allow the first chunk to be found                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_FindChunk{dos.l,chunk.l,@pos.l,@blength.l,@immediate.l}
If blength<=0 Then blength = file_GetLength{dos}-pos
If pos<0 Then pos.l = file_GetSeekPos{dos}
count.l = 0
If immediate Then immediate = 0:Else immediate=1
Repeat
  If file_Seek{dos,pos}
    dummy2.l = file_ReadMem{dos,&chlen.l,4}
    dummy2.l & file_ReadMem{dos,&dummy.l,4}
    If dummy2
      blength-chlen - 8 -4
      pos + chlen + 8 +4
      If pos>=file_GetLength{dos} OR pos<=0 Then blength=-1
      count+1
    Else
      blength=-1
      dummy=0
    End If
  Else
    blength=0
    dummy=0
    error{"Called file_findchunk() with invalid seek position ! ("+Str$(pos)+")"}
  End If
  If count<=immediate Then dummy=0

Until dummy = chunk OR blength<=0
If dummy = chunk Then succ.l = pos-chlen-8-4:dummy=file_Seek{dos,succ}:Else succ.l = False
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: png_Close{}                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ Close the png file.                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement png_Close{}
If \compressed_data Then FreeVec_ \compressed_data
If \dos>=0 Then  file_Close{\dos}
\is_open    = False
\compressed_data = 0
\dos        = -1
End Statement
!autoexit{png_Close}

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = png_Open{filename.s}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Open a png file for reading.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : file name of the png file                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_Open{filename.s}
SHARED version_zlib.l
If version_zlib=0 Then version_zlib = dos_GetLibVersion{"z.library"}
If version_zlib<3 Then Function Return False
png_Close{}
dos.l = file_Open{filename.s,#file_read}
If dos>=0
  \dos = dos
  If file_ReadMem{\dos,PNG_IHDR,SizeOf.PNG_IHDR-1}
    If (PNG_IHDR\_PNG = $89504E47) AND (PNG_IHDR\_check=$0D0A1A0A) AND (PNG_IHDR\IHDR = @"IHDR")
      If (PNG_IHDR\img_colortype = #png_color_rgba) AND (PNG_IHDR\img_bitdepth = 8)
       If (PNG_IHDR\img_compression_method = #png_compression_zlib) AND (PNG_IHDR\img_filter_method=#png_filtermethod_5)
         If (PNG_IHDR\img_interlace_method=#png_interlace_none OR PNG_IHDR\img_interlace_method=#png_interlace_adam7)
           If png_FindChunk{dos,@"IDAT"}
             \is_open = True
           End If
         Else
          ; error{"png_Open: unsupported interlace mode: "+Str$(PNG_IHDR\img_interlace_method)}
         End If
       End If
      End If
    End If
  End If
End If
If \is_open=False Then png_Close{}
Function Return \is_open
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = png_Filter{sourceaddr.l,destaddr.l,lines.l,bpr.l,fil:: /
;/ tertype.l,bpp.l}                                                            /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/ Perform the png filtering.                                                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - sourceaddr.l    : ???                                                     /
;/ - destaddr.l    : ???                                                       /
;/ - lines.l    : ???                                                          /
;/ - bpr.l    : ???                                                            /
;/ - filtertype.l    : ???                                                     /
;/ - bpp.l    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_Filter{sourceaddr.l,destaddr.l,lines.l,bpr.l,filtertype.l,bpp.l}
srowmod.l = bpr
drowmod.l = PNG_IHDR\img_width * bpp
done.l = 0
For y.l = 0 To lines-1
  Poke.b destaddr,filtertype
  destaddr+1
  done+1
  Select bpp
    Case 3
      Select filtertype
        Case #png_filter_none
          ; convert from ARGB to RGBA
          For n.l=0 To PNG_IHDR\img_width-1
            Poke.b destaddr+n*3+0,Peek.b(sourceaddr+n*4+1)
            Poke.b destaddr+n*3+1,Peek.b(sourceaddr+n*4+2)
            Poke.b destaddr+n*3+2,Peek.b(sourceaddr+n*4+3)
          Next
          sourceaddr+srowmod
          destaddr+drowmod
          done+drowmod
        Default
          error{"png_filter: requested filter type is not implemented ("+Str$(filtertype)+" )!"}
          y = lines
          done=0
      End Select
    Case 4
      Select filtertype
        Case #png_filter_none
          ; convert from ARGB to RGBA
          For n.l=0 To PNG_IHDR\img_width-1
            Poke.b destaddr+n*4+0,Peek.b(sourceaddr+n*4+1)
            Poke.b destaddr+n*4+1,Peek.b(sourceaddr+n*4+2)
            Poke.b destaddr+n*4+2,Peek.b(sourceaddr+n*4+3)
            Poke.b destaddr+n*4+3,Peek.b(sourceaddr+n*4+0)
          Next
          sourceaddr+srowmod
          destaddr+drowmod
          done+drowmod
        Default
          error{"png_filter: requested filter type is not implemented ("+Str$(filtertype)+" )!"}
          y = lines
          done=0
      End Select
    Default
      error{"png_filer: unsupported pixelformat (BytesPerPixel:"+Str$(bpp)+")!"}
  End Select
Next
Function Return done
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = png_Write{dos.l,dataptr.l,img_width.l,img_height.l,b:: /
;/ pr.l,@compress.l,@usealpha.l}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ Write a png file.                                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - dos.l    : ???                                                            /
;/ - dataptr.l    : ???                                                        /
;/ - img_width.l    : ???                                                      /
;/ - img_height.l    : ???                                                     /
;/ - bpr.l    : ???                                                            /
;/ - compress.l    : ???                                                       /
;/ - usealpha.l    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_Write{dos.l,dataptr.l,img_width.l,img_height.l,bpr.l,@compress.l,@usealpha.l,@bgcolor.l}
SHARED version_zlib.l
If version_zlib=0 Then version_zlib = dos_GetLibVersion{"z.library"}
If version_zlib<3 Then Function Return False

succ.l = True
If compress<1 Then compress=6 ; default compression level

; write header information
PNG_IHDR\_PNG   = $89504E47
PNG_IHDR\_check = $0D0A1A0A
PNG_IHDR\IHDR   = @"IHDR"
PNG_IHDR\csize  = 13
PNG_IHDR\img_width              = img_width
PNG_IHDR\img_height             = img_height
PNG_IHDR\img_bitdepth           = 8 ; bit per color sample
If usealpha
  PNG_IHDR\img_colortype          = #png_color_rgba
  bpp.l = 4
Else
  PNG_IHDR\img_colortype          = #png_color_rgb
  bpp.l = 3
End If
PNG_IHDR\img_compression_method = 0 ; always 0, 32k sliding window
PNG_IHDR\img_filter_method      = 0 ; filter method, always 0 (5 filter method)
PNG_IHDR\img_interlace_method   = 0 ; 0 = no interlace, 1 = adam7 inerlace
PNG_IHDR\b[0] = 0
PNG_IHDR\b[1] = 0
PNG_IHDR\b[2] = 0
PNG_IHDR\b[3] = 0
succ & file_WriteMem{dos,PNG_IHDR,13+8+8}
CRC.l = CRC32_FromMem{&PNG_IHDR\IHDR,13+4}
succ & file_WriteLong{dos,CRC}

If bgcolor><-1
  PNG_bKGD\csize = 6
  PNG_bKGD\bKGD  = @"bKGD"
  PNG_bKGD\R = (bgcolor LSR 16) &$FF
  PNG_bKGD\G = (bgcolor LSR  8) &$FF
  PNG_bKGD\B = (bgcolor       ) &$FF
  succ & file_WriteMem{dos,PNG_bKGD,SizeOf.PNG_bKGD}
  CRC.l = CRC32_FromMem{&PNG_bKGD\bKGD,6+4}
  succ & file_WriteLong{dos,CRC}
End If

; write data
tempsize.l  = img_width*img_height*bpp + img_height
tempsize2.l = tempsize + tempsize/1000 + 12  + 64
temp.l  = AllocVec_(tempsize ,#MEMF_ANY)
ctemp.l = AllocVec_(tempsize2,#MEMF_ANY)
If temp><0 AND ctemp><0
  Rows.l        = img_height
  BytesPerRow.l = img_width * bpp
  RowsAtOnce.l  = Min(img_height,tempsize / BytesPerRow)

  While Rows>0
    DoRows.l=Rows;Min(RowsAtOnce,Rows)
    Rows-DoRows
    BytesDone.l = png_Filter{dataptr,temp,DoRows,bpr,#png_filter_none,bpp}
    clength.l = 0
    dataptr + DoRows*BytesPerRow
    ;GZ_CompressMem_ temp,BytesDone,ctemp,tempsize2,0,compress,&clength
    clength = tempsize2 : z_Compress{ctemp,&clength,temp,BytesDone}
    If clength>0
      PNG_IDAT\csize = clength
      PNG_IDAT\IDAT = @"IDAT"
      succ & file_WriteMem{dos,PNG_IDAT,8};SizeOf.PNG_IDAT}
      succ & file_WriteMem{dos,ctemp,clength}
      CRC = CRC32_Add{$ffffffff,&PNG_IDAT\IDAT,4}
      CRC = CRC32_Add{CRC,ctemp,clength}
      CRC = CRC32_Finalize{CRC}
      succ & file_WriteLong{dos,CRC}
    Else
      error{"clength<=0 !"}
    End If
  Wend
End If
If temp  Then FreeVec_ temp  :temp  = 0
If ctemp Then FreeVec_ ctemp :ctemp = 0

; write end
PNG_IEND\IEND = @"IEND"
PNG_IEND\csize = 0
succ & file_WriteMem{dos,PNG_IEND,SizeOf.PNG_IEND}
CRC = CRC32_FromMem{&PNG_IEND\IEND,4}
succ & file_WriteLong{dos,CRC}
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = png_Unfilter{sourceaddr.l,destaddr.l,pixelwidth.l,sc:: /
;/ anlines.l,bpr.l,bpp.l,mode.l}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - sourceaddr.l    : ???                                                     /
;/ - destaddr.l    : ???                                                       /
;/ - bpr.l    : ???                                                            /
;/ - mode.l    : ???                                                           /
;/ - pixelwidth.l    : ???                                                     /
;/ - scanlines.l    : ???                                                      /
;/ - bpp.l    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_Unfilter{sourceaddr.l,destaddr.l,pixelwidth.l,scanlines.l,bpr.l,bpp.l,mode.l}
sBytesPerPixel.l = 4 ; we only decode ARGB pngs
sBytesPerRow.l = pixelwidth*sBytesPerPixel

;Select mode
;  Case #png_unfilter_ARGB
;    dBytesPerPixel.l = 4
;  Case #png_unfilter_RGB
;    dBytesPerPixel.l = 3
;  Case #png_unfilter_alpha
;    dBytesPerPixel.l = 1
;End Select
dBytesPerRow.l   = bpr
dBytesPerPixel.l = bpp
Aa.l = 0 ; left
Ab.l = 0 ; above
Ac.l = 0 ; upperleft
Ra.l = 0 ; left
Rb.l = 0 ; above
Rc.l = 0 ; upperleft
Ga.l = 0 ; left
Gb.l = 0 ; above
Gc.l = 0 ; upperleft
Ba.l = 0 ; left
Bb.l = 0 ; above
Bc.l = 0 ; upperleft
Apx.l = 0
Rpx.l = 0
Gpx.l = 0
Bpx.l = 0

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_unfilter_peath                                                 /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_unfilter_peath
  p.l  = `1a + `1b - `1c
  pa.l = (p-`1a) : If pa<0 Then pa=0-pa
  pb.l = (p-`1b) : If pb<0 Then pb=0-pb
  pc.l = (p-`1c) : If pc<0 Then pc=0-pc
  Poke.b &`1px+3,Peek.b(sourceaddr+(`2))

  If pa<=pb AND pa<=pc
    p = `1a + `1px
  Else
    If pb<=pc
      p = `1b + `1px
    Else
      p = `1c + `1px
    End If
  End If
  Poke.b destaddr+(`3),Peek.b(&p+3)
  `1a = p & $FF
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_unfilter_up                                                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_unfilter_up
Poke.b &`1px+3,Peek.b(sourceaddr+`2)
p.l = `1px + `1b
Poke.b destaddr+`3,Peek.b(&p+3)
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_unfilter_sub                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_unfilter_sub
Poke.b &`1px+3,Peek.b(sourceaddr+`2)
p.l = `1px + `1a
`1a = p & $FF
Poke.b destaddr+`3,Peek.b(&p+3)
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_unfilter_average                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_unfilter_average
Poke.b &`1px+3,Peek.b(sourceaddr+`2)
;p.l = Int((`1a+`1b)/2) + `1px
p.l = ((`1a+`1b) LSR 1) + `1px
`1a = p & $FF
Poke.b destaddr+`3,Peek.b(&p+3)
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_init_a                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_init_a
  Aa=0:Ra=0:Ga=0:Ba=0
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_init_b                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_init_b
  If y>0
    Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow+0)
    Poke.b &Rb+3,Peek.b(destaddr-dBytesPerRow+1)
    Poke.b &Gb+3,Peek.b(destaddr-dBytesPerRow+2)
    Poke.b &Bb+3,Peek.b(destaddr-dBytesPerRow+3)
  Else
    Ab=0:Rb=0:Gb=0:Bb=0
  End If
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_init_c                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_init_c
  Ac=0:Rc=0:Gc=0:Bc=0
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_shift_b                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_shift_b
  If y>0
    Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow+0)
    Poke.b &Rb+3,Peek.b(destaddr-dBytesPerRow+1)
    Poke.b &Gb+3,Peek.b(destaddr-dBytesPerRow+2)
    Poke.b &Bb+3,Peek.b(destaddr-dBytesPerRow+3)
  End If
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_shift_c                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_shift_c
  ;If y>0
    Ac = Ab
    Rc = Rb
    Gc = Gb
    Bc = Bb
  ;End If
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_inc_buffer                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_inc_buffer
  destaddr+dBytesPerPixel
  sourceaddr+sBytesPerPixel
End Macro
sourcebase.l = sourceaddr
destbase.l = destaddr
For y.l = 0 To scanlines-1 ; PNG_IHDR\img_height-1
  destaddr.l = destbase + y*dBytesPerRow
  prefilt.b = filt.b
  filt.b = Peek.b(sourceaddr)
  sourceaddr+1
     ; error{"Decoding filter id="+Str$(filt)+"!"}
  Select filt
    Case #png_filter_none
      Select mode
        Case #png_unfilter_alpha
          For x.l = 0 To pixelwidth-1 ;PNG_IHDR\img_width-1
            Poke.b destaddr,Peek.b(sourceaddr+3)
            !png_inc_buffer
          Next
        Case #png_unfilter_ARGB
          For x.l = 0 To pixelwidth-1 ; PNG_IHDR\img_width-1
            Poke.b destaddr+3,Peek.b(sourceaddr+2) ; B
            Poke.b destaddr+2,Peek.b(sourceaddr+1) ; G
            Poke.b destaddr+1,Peek.b(sourceaddr+0) ; R
            Poke.b destaddr+0,Peek.b(sourceaddr+3) ; A
            !png_inc_buffer
          Next
      End Select


    Case #png_filter_sub
      Select mode
        Case #png_unfilter_alpha
          Aa = 0
          For x.l = 0 To pixelwidth-1 ;PNG_IHDR\img_width-1
            !png_unfilter_sub{A,3,0}
            !png_inc_buffer
          Next
        Case #png_unfilter_ARGB
          !png_init_a
          For x.l = 0 To pixelwidth-1 ;PNG_IHDR\img_width-1
            !png_unfilter_sub{B,2,3}
            !png_unfilter_sub{G,1,2}
            !png_unfilter_sub{R,0,1}
            !png_unfilter_sub{A,3,0}
            !png_inc_buffer
          Next
       End Select

    Case #png_filter_up
      Select mode
        Case #png_unfilter_alpha
          If y>0 Then Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow):Else Ab=0
          For x.l = 0 To pixelwidth-1;PNG_IHDR\img_width-1
            !png_unfilter_up{A,3,0}
            !png_inc_buffer
            If y>0 Then Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow)
          Next
        Case #png_unfilter_ARGB
          !png_init_b
          For x.l = 0 To pixelwidth-1;PNG_IHDR\img_width-1
            !png_unfilter_up{B,2,3}
            !png_unfilter_up{G,1,2}
            !png_unfilter_up{R,0,1}
            !png_unfilter_up{A,3,0}
            !png_inc_buffer
            !png_shift_b
          Next
      End Select

    Case #png_filter_average
      Select mode
        Case #png_unfilter_alpha
          Aa = 0
          If y>0 Then Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow):Else Ab=0
          For x.l = 0 To pixelwidth-1;PNG_IHDR\img_width-1
            !png_unfilter_average{A,3,0}
            !png_inc_buffer
            If y>0 Then Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow)
          Next
        Case #png_unfilter_ARGB
          !png_init_a
          !png_init_b
          For x.l = 0 To pixelwidth-1;PNG_IHDR\img_width-1
            !png_unfilter_average{B,2,3}
            !png_unfilter_average{G,1,2}
            !png_unfilter_average{R,0,1}
            !png_unfilter_average{A,3,0}
            !png_inc_buffer
            !png_shift_b
          Next
      End Select

    Case #png_filter_paeth
      Select mode
        Case #png_unfilter_alpha
          Aa=0:Ac=0
          If y>0 Then Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow) :Else Ab=0
          For x.l = 0 To pixelwidth-1;PNG_IHDR\img_width-1
            !png_unfilter_peath{A,3,0}
            !png_inc_buffer
            If y>0 Then Ac = Ab : Poke.b &Ab+3,Peek.b(destaddr-dBytesPerRow)
          Next

        Case #png_unfilter_ARGB
          !png_init_a
          !png_init_b
          !png_init_c
          For x.l = 0 To pixelwidth-1;PNG_IHDR\img_width-1
            !png_unfilter_peath{B,2,3}
            !png_unfilter_peath{G,1,2}
            !png_unfilter_peath{R,0,1}
            !png_unfilter_peath{A,3,0}
            !png_inc_buffer
            !png_shift_c
            !png_shift_b
          Next
       End Select

    Default
       sourceaddr+sBytesPerRow
       destaddr+dBytesPerRow
      If errdone.l=0
        error{"Invalid filter in png file (line "+Str$(y)+", filter id "+Str$(filt)+", pre id "+Str$(prefilt)+")!"}
        errdone = -1
      End If
   End Select
Next
BytesDone.l = sourceaddr-sourcebase
Function Return BytesDone
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = png_Read{}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l png_Read{}
SHARED filedat()
succ.l = 0
If \is_open
  \buffer_size = file_GetLength{\dos}

  offset.l = 0
  \compressed_data = AllocVec_(\buffer_size,#MEMF_ANY)

  While png_FindChunk{\dos,@"IDAT"}
    If file_ReadMem{\dos,PNG_IDAT,SizeOf.PNG_IDAT}
      If file_ReadMem{\dos,\compressed_data+offset,PNG_IDAT\csize}
        offset + PNG_IDAT\csize
        file_SeekRel{\dos,4}
      End If
    End If
  Wend
  If offset>0 Then succ=True
  \compressed_size = offset
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_unfilter_adam7_alpha{xoff,yoff,xstep,ystep}                   /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - xoff    : ???                                                             /
;/ - yoff    : ???                                                             /
;/ - xstep    : ???                                                            /
;/ - ystep    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_unfilter_adam7_alpha;{xoff,yoff,xstep,ystep}
            pixelxoff.l  = `1
            pixelxstep.l = `3
            pixelyoff.l  = `2
            pixelystep.l = `4
            pixelwidth.l = (PNG_IHDR\img_width+pixelxstep-1-pixelxoff)/pixelxstep
            scanlines.l  = (PNG_IHDR\img_height+pixelystep-1-pixelyoff)/pixelystep
            destoff.l    = pixelxoff *1 + pixelyoff * bpr
            If pixelwidth>0 AND scanlines>0
              temp+  png_Unfilter{temp,destbuffer+destoff,pixelwidth,scanlines,bpr*pixelystep,1*pixelxstep,#png_unfilter_alpha}
            End If
End Macro

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: png_DecodeAlpha{destbuffer.l,bpr.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Decode (means decompress and unfilter) a png buffer into an 8bit alpha ar:: /
;/ ray.                                                                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - destbuffer.l    : memory pointer of the alpha array (make sure it is bi:: /
;/ g enough: width*height*1 bytes!)                                            /
;/ - bpr.l    : bpr of the alpha array                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement png_DecodeAlpha{destbuffer.l,bpr.l}
If \is_open
  If \compressed_data
    If destbuffer
      temp_size.l = PNG_IHDR\img_width*PNG_IHDR\img_height*4   +PNG_IHDR\img_height*2 +4
      temp.l = tempbuffer_Get{temp_size}
      If temp
        ;error.l= GZ_DecompressMem_(\compressed_data,\compressed_size,temp,temp_size)
        error.l = z_Uncompress{temp,&temp_size,\compressed_data,\compressed_size}
        If error=0
          Select PNG_IHDR\img_interlace_method
            Case #png_interlace_none
              png_Unfilter{temp,destbuffer,PNG_IHDR\img_width,PNG_IHDR\img_height,bpr,1,#png_unfilter_alpha}
            Case #png_interlace_adam7
              !png_unfilter_adam7_alpha{0,0,8,8}
              !png_unfilter_adam7_alpha{4,0,8,8}
              !png_unfilter_adam7_alpha{0,4,4,8}
              !png_unfilter_adam7_alpha{2,0,4,4}
              !png_unfilter_adam7_alpha{0,2,2,4}
              !png_unfilter_adam7_alpha{1,0,2,2}
              !png_unfilter_adam7_alpha{0,1,1,2}
          End Select
        Else
          error{"png_decoder_ARGB: Unable to decrunch !"}
        End If
      Else
        error{"png_decoder_ARGB: Not enough memory for temp buffer!"}
      End If
    End If
  End If
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !png_unfilter_adam7_argb{xoff,yoff,xstep,ystep}                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - xoff    : ???                                                             /
;/ - yoff    : ???                                                             /
;/ - xstep    : ???                                                            /
;/ - ystep    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro png_unfilter_adam7_argb;{xoff,yoff,xstep,ystep}
            pixelxoff.l  = `1
            pixelxstep.l = `3
            pixelyoff.l  = `2
            pixelystep.l = `4
            pixelwidth.l = (PNG_IHDR\img_width+pixelxstep-1-pixelxoff)/pixelxstep
            scanlines.l  = (PNG_IHDR\img_height+pixelystep-1-pixelyoff)/pixelystep
            destoff.l    = pixelxoff *4 + pixelyoff * bpr
            If pixelwidth>0 AND scanlines>0
              temp+  png_Unfilter{temp,destbuffer+destoff,pixelwidth,scanlines,bpr*pixelystep,4*pixelxstep,#png_unfilter_ARGB}
            End If
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: png_DecodeARGB{destbuffer.l,bpr.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Decode (means decompress and unfilter) a png buffer into an ARGB pixel ar:: /
;/ ray.                                                                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - destbuffer.l    : memory pointer of the ARGB pixel array (make sure it :: /
;/ is big enough: width*height*4 bytes!)                                       /
;/ - bpr.l    : bpr of the ARGB pixel array                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement png_DecodeARGB{destbuffer.l,bpr.l}
If \is_open
  If \compressed_data
    If destbuffer
      temp_size.l = PNG_IHDR\img_width*PNG_IHDR\img_height*4     +PNG_IHDR\img_height*2 +4
      temp.l = tempbuffer_Get{temp_size}
      tempx.l = temp
      If temp
        ;error.l= GZ_DecompressMem_(\compressed_data,\compressed_size,temp,temp_size)
        error.l = z_Uncompress{temp,&temp_size,\compressed_data,\compressed_size}
        If error=0
          Select PNG_IHDR\img_interlace_method
            Case #png_interlace_none
              png_Unfilter{temp,destbuffer,PNG_IHDR\img_width,PNG_IHDR\img_height,bpr,4,#png_unfilter_ARGB}
            Case #png_interlace_adam7
              !png_unfilter_adam7_argb{0,0,8,8}
              !png_unfilter_adam7_argb{4,0,8,8}
              !png_unfilter_adam7_argb{0,4,4,8}
              !png_unfilter_adam7_argb{2,0,4,4}
              !png_unfilter_adam7_argb{0,2,2,4}
              !png_unfilter_adam7_argb{1,0,2,2}
              !png_unfilter_adam7_argb{0,1,1,2}
           ; error{"left "+Str$(temp_size-temp+tempx)+" bytes!"}
          End Select
        Else
          error{"png_decode_ARGB: Unable to decrunch !"}
        End If
      Else
        error{"png_decoder_ARGB: Not enough memory for temp buffer!"}
      End If
    End If
  End If
End If
End Statement

CNIF #__include=0

If png_Open{"/Data/AlphaBlit.png"}
  NPrint "PNG file open !"
  succ.l = png_Read{}
  If succ
    ; png_DecodeAlpha{destbuffer.l,awidth.l,aheight.l}
    NPrint "Alphachannel loaded !",succ
  Else
    NPrint "No Aplha infile !"
  End If
  png_Close{}
Else
  NPrint "File is not an PNG file !"
End If

;Delay_ 200
End





CEND
