; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "/bin"
; ExeFile         = "DblIncludeDemo"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 79
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 2765
; CursorColumn    = 3
; LabelSearch     = "dbl\"
; LabelRemark     = 0
; LabelAll        = 1
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 5
; Max GadgetList  = 5
; Max Shape       = 100
; Max Bank        = 5
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 5
; Max Palette     = 4
; Max BitMap      = 10
; Max Screen      = 5
; Max Window      = 5
; Max IntuiFont   = 5
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: dbl_display.include                                                   /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, AmigaOS4, MOS                         /
;/                                                                             /
;/ Date: 11.08.2006                                                            /
;/                                                                             /
;/ Author: Thilo Koehler                                                       /
;/                                                                             /
;/ Requirements: Amiblitz2.4, image.include                                    /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Provide a 2D game interface for double buffered gfx, that runs fast on gr:: /
;/ aphics cards on ALL systems, including Classic (in contrast to SDL).        /
;/ The basic functionality works on AGA/OCS as well, but it might be slow. S:: /
;/ ome of the functions even require 16 or 24 or 32 bit screens.               /
;/ It is possbile to do a 640x480x16 game on a Classic at 50 Hz!               /
;/                                                                             /
;/ Abstract:                                                                   /
;/ This include is ideal if you plan to write a 2D action game, that should :: /
;/ use the graphicscard (e.g. 24bit), but still be fast enough to run on a C:: /
;/ lassic Amiga.                                                               /
;/ If you plan to write for WinUAE, Amithlon, AmigaOS4, MOS, you have even m:: /
;/ ore possibilities like alpha channel, transparency and illuminations, als:: /
;/ o some simple 3D texture capabilities. This will work on Classic too, but:: /
;/  it will be simply to slow.                                                 /
;/ Additional to the functions in this include, you can use ALL rastport bas:: /
;/ ed functions of the OS to draw things into the double buffered display, s:: /
;/ o there are no limitations.                                                 /
;/ There are several demos for the dbl.include, check them out to see whats :: /
;/ possible!                                                                   /
;/                                                                             /
;/ User Constants:                                                             /
;/                                                                             /
;/ #dbl_method   = 1 (default)                                                 /
;/ 0=few objects / 1=many objects, no overhead for scrolling                   /
;/ Note: if you plan a game with scrolling and a lot of objects, "1" is your:: /
;/  choise. Use "0" only, if you want to save CPU power and you have few obj:: /
;/ ects, lets say <10.                                                         /
;/                                                                             /
;/ #max_dblqueue = 500 (default)                                               /
;/ Maximum number of objects in dbl queue. This is only important for #dbl_m:: /
;/ ethod=0.                                                                    /
;/ The dbl_queue remembers the blitted objects and can removes them with dbl:: /
;/ _Unqueue.                                                                   /
;/                                                                             /
;/ #use_cpublit  = 0 (default)                                                 /
;/ 0=use blitter / 1=use CPU                                                   /
;/ Usually, you want to use the blitter!                                       /
;/                                                                             /
;/ #use_screenhack = 0 (default)                                               /
;/ The screen hack is a little hack that opens a 3x higher screen to ensure :: /
;/ that all double buffer bitmaps are in the video memory.                     /
;/ I removed it because the OS offers functionality for this. However, its a:: /
;/  bit slower. If you want the scree hack back, set this to 1.                /
;/ NOTE: Window mode will not be available anymore, as well as some flip met:: /
;/ hods.                                                                       /
;/                                                                             /
;/ Example:                                                                    /
;/ See the Examples folder.                                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
CNIF #__include=0
  optimize 5
  Syntax 6
  #use_screenhack = 0
  ;#flip_mode=5
  ;#dbl_method = 5
CEND


XINCLUDE "error.include.ab3"
XINCLUDE "image.include.ab3"
XINCLUDE "vvblank.include.ab3"
XINCLUDE "eclock.include.ab3"
#flip_scrollvp  = 0   ; use ScrollVP()
#flip_bltbmap   = 1   ; blit bitmaps via BltBmapRastPort()
#flip_none      = 2   ; no dbl
#flip_smart     = 3   ; use seletive blit bia BltBmapRastPort and Queue()
#flip_changebmap= 4   ; use ChangeVPBitMap()
#flip_scrbuff   = 5   ; use ChangeScreenBuffer()

#refresh_object = 0   ; refresh objectwise
#refresh_full   = 1   ; refresh always complete screen

#dbl_scr_ASL        = 0
#dbl_scr_BestModeID = -1
#dbl_scr_Window     = -2
#dbl_scr_WB         = -3

CNIF @#dbl_method = 0
  #dbl_method   = 1    ; 0=few objects / 1=many objects, no overhead for scrolling
CEND

CNIF @#max_dblqueue = 0
  #max_dblqueue = 500  ; Max objects in dbl queue
CEND

CNIF @#use_cpublit = 0
  #use_cpublit  = 0    ; 0=use blitter / 1=use CPU
CEND

CNIF @#use_screenhack=0
  #use_screenhack = 0  ; use 3x height screen for bitmaps
  ; screenhack doesnt work with #flip_scrbuff, #flip_bmap and in window mode
CEND

; Dont touch the below!
CNIF #dbl_method=0
  CNIF @#refresh_mode = 0
  #refresh_mode = #refresh_object
  CEND
  CNIF @#flip_mode =0
  #flip_mode    = #flip_smart
;  #flip_mode    = #flip_bltbmap
;  #flip_mode    = #flip_changebmap
;  #flip_mode    = #flip_none
;  #flip_mode    = #flip_viewport
;   #flip_mode    = #flip_scrbuff
  CEND
CELSE
  CNIF @#refresh_mode=0
  #refresh_mode = #refresh_full
  CEND
  CNIF @#flip_mode=0
  #flip_mode    = #flip_bltbmap
;  #flip_mode    = #flip_changebmap
;  #flip_mode    = #flip_none
;  #flip_mode    = #flip_smart      ; works only with refresh_object
;  #flip_mode    = #flip_scrollvp
;  #flip_mode    = #flip_scrbuff
  CEND
CEND


#BT_Nxs   =$80000004
#BT_Nys   =$80000005
#BT_Dxs   =$80000006
#BT_Dys   =$80000007
#BT_Dd    =$80000008

#dbl_fps_vbeam   = -1 ; use VBeam via WaitBOVP
#dbl_fps_vblank  = -3 ; use VBlank via WaitTOF
#dbl_fps_free    =  0 ; no timing
#dbl_fps_monitor = -2 ; timer with FPS of monitor


NEWTYPE.aslscreeninfox
  scr_id.l
  scr_width.l
  scr_height.l
  scr_depth.w
  scr_overscan.w
  scr_ascroll.w
  bmapwidth.l
  bmapheight.l
End NEWTYPE

NEWTYPE.queueitem
  x.l
  y.l
  xs.l
  ys.l
End NEWTYPE

NEWTYPE.rgbval
  R.l
  G.l
  B.l
End NEWTYPE

NEWTYPE.dbl
  *bmap.BitMap        ; current bitmap
  *bmap_0.BitMap      ; bitmap dbl1
  *bmap_1.BitMap      ; bitmao dbl2
  *bmap_bg.BitMap     ; bitmap restore background
  *bmap_col.BitMap    ; collision compare bitmap

  *rp.RastPort
  *rp_0.RastPort
  *rp_1.RastPort
  *rp_bg.RastPort
  *rp_col.RastPort

  CNIF #use_screenhack
    *xwin_0.Window
    *xwin_1.Window
    *xwin_bg.Window
  CEND

  *win.Window

  *layer_0.Layer
  *layer_1.Layer
  *layer_bg.Layer
  *layer.Layer
  *layer_col.Layer

  *layerinfo_0.Layer_Info
  *layerinfo_1.Layer_Info
  *layerinfo_bg.Layer_Info
  *layerinfo_col.Layer_Info

  *pf_region_0.Region
  *pf_region_1.Region
  *pf_region_bg.Region
  *pf_region_col.Region

  *scrbuff_0.ScreenBuffer
  *scrbuff_1.ScreenBuffer

  *mp_safe.MsgPort
  *mp_disp.MsgPort

  safeToChange.l
  safeToWrite.l
  layer_0_stolen.l
  winmode.l

  scr_width.l ; Screen Dimensions
  scr_height.l
  scr_depth.l
  *scr_bmap.BitMap
  *scr.Screen
  *scr_vp.ViewPort
  *scr_rp.RastPort
  *scr_cm.ColorMap
  *scr_db.DBufInfo

  eclockunit.l

  scr_pens.l
  db.l
  pf_width.l
  pf_height.l
  pf_xoff.l
  pf_yoff.l
  pf_rec.Rectangle
  fps.f
  last_rgbval.l
  fade_ratio.l
  fade_rgb.l
  paletteSnap.l
  cmap.rgbval[256]
  tst_fps.f
  tst_fpsc.l
  tst_lastframetime.d
  tst_lastdiff.d
  realfps.d

  temppen.l
End NEWTYPE


DEFTYPE.DisplayInfo disinfo
DEFTYPE.DimensionInfo diminfo
DEFTYPE.MonitorInfo moninfo
Dim List dblqueue0.queueitem(#max_dblqueue)
Dim List dblqueue1.queueitem(#max_dblqueue)
SHARED dbl.dbl
USEPATH dbl
 \pf_region_0  = -1
 \pf_region_1  = -1
 \pf_region_bg = -1
 \safeToWrite  = True
 \safeToChange = True

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_HideMousePointer {}                                             /
;/                                                                             /
;/ Description:                                                                /
;/ Hide the mouse pointer on the doublebuffer display, useful for games with:: /
;/  no mouse.                                                                  /
;/ NOTE: The pointer is hidden by default.                                     /
;/ NOTE: If you want to have a 24bit mousepointer, hide the system pointer a:: /
;/ nd blit it with dbl_QBlit {mypointerimage,SMouseX,SMouseY}                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_HideMousePointer {}
  If Peek.l(Addr Window(0)) Then SetPointer_ Peek.l(Addr Window(0)),?EmptyPointer , 0,0,1,1:Use Window 0:Menus Off : Activate 0
  CNIF #use_screenhack
    If Peek.l(Addr Window(1)) Then SetPointer_ Peek.l(Addr Window(1)),?EmptyPointer , 0,0,1,1:Use Window 1:Menus Off
    If Peek.l(Addr Window(2)) Then SetPointer_ Peek.l(Addr Window(2)),?EmptyPointer , 0,0,1,1:Use Window 2:Menus Off
  CEND
 Statement Return

  EmptyPointer:
    Dcb.w 4,$0
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_ShowMousePointer {@pnum.l}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Show the mousepointer again after use of dbl_HideMousePointer{}             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - pnum.l     : optional blitz shape object for use as a mousepointer (2 B:: /
;/ itplanes)                                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_ShowMousePointer {@pnum.l}
  If pnum=-1
   If Peek.l(Addr Window(0)) Then ClearPointer_ Peek.l(Addr Window(0))
   CNIF #use_screenhack
     If Peek.l(Addr Window(1)) Then ClearPointer_ Peek.l(Addr Window(1))
     If Peek.l(Addr Window(2)) Then ClearPointer_ Peek.l(Addr Window(2))
   CEND
  Else
   Use Window 0:WPointer pnum
   CNIF #use_screenhack
     Use Window 1 : WPointer pnum
     Use Window 2 : WPointer pnum
   CEND
  End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  pen.l = dbl_GetPen {r.l,g.l,b.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Get the pen number best approximating the given rgb color for use with e.:: /
;/ g. Wline or other pen oriented functions.                                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - r.l         : red component, 0..255                                       /
;/ - g.l         : green component, 0..255                                     /
;/ - b.l         : blue component, 0..255                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - pen.l       : Number of the pen representing the desired color            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dbl_GetPen {r.l,g.l,b.l}
  pen.l=0
  If dbl\scr_cm
    r=r LSL 24
    g=g LSL 24
    b=b LSL 24
    pen=ObtainBestPenA_(dbl\scr_cm,r,g,b,Tags(#PRECISION_IMAGE,True))
    If pen=-1 Then pen=0
  End If

 Function Return pen
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  pen.l = dbl_GetPenRGB {rgbval.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Get the pen number best approximating the given rgb color for use with e.:: /
;/ g. Wline or other pen oriented functions.                                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - rgbval.l       : 24 bit RGB value, e.g. $00FF00 for pure green            /
;/                                                                             /
;/ Result:                                                                     /
;/ - pen.l       : Number of the pen representing the desired color            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dbl_GetPenRGB {rgbval.l}
  Function Return  dbl_GetPen {((rgbval LSR 16)&$FF),((rgbval LSR 8)&$FF),(rgbval&$FF)}
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_SetPen {n.l,r.l,g.l,b.l}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ Set a pen to the given rgb values.                                          /
;/ Note: You should only use this if you know what you are doing because it :: /
;/ may change the color of images that are already draw on the screen          /
;/ Note: Use dbl_GetPen{} as it creates new pens to get the color exactly if:: /
;/  there are free pens left.                                                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - n.l         : index number pen to change                                  /
;/ - r.l         : red component, 0..255                                       /
;/ - g.l         : green component, 0..255                                     /
;/ - b.l         : blue component, 0..255                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_SetPen {n.l,r.l,g.l,b.l}
  If dbl\scr_vp
    r=r LSL 24
    g=g LSL 24
    b=b LSL 24
    SetRGB32_ dbl\scr_vp,n,r,g,b
  End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_SetPenRGB {n.l,rgbval.l}                                        /
;/                                                                             /
;/ Description:                                                                /
;/  dbl_SetPen {n.l,rgbval.l}                                                  /
;/ Set a pen to the given rgb value.                                           /
;/ Note: You should only use this if you know what you are doing because it :: /
;/ may change the color of images that are already visible on the screen       /
;/ Note: Use dbl_GetPen{} as it creates new pens to get the color exactly if:: /
;/  there are free pens left.                                                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - n.l         : index number pen to change                                  /
;/ - rgbval.l    :  rgbvalue, e.g. $FF0000 for pure red                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_SetPenRGB {n.l,rgbval.l}
  dbl_SetPen {n,((rgbval LSR 16)&$FF),((rgbval LSR 8)&$FF),(rgbval&$FF)}
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_FreeCollision {}                                                /
;/                                                                             /
;/ Description:                                                                /
;/ Free all resources associated with the collision bitmap.                    /
;/ NOTE: For internal use only!                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_FreeCollision {}
 USEPATH dbl

  If \layer_col      Then DeleteLayer_        0,\layer_col : \layer_col      = 0
  If \layerinfo_col  Then DisposeLayerInfo_ \layerinfo_col : \layerinfo_col  = 0
  If \rp_col         Then FreeMem_ \rp_col,0               : \rp_col         = 0 ; this is correct for now
  ;If \rp_col         Then                                  : \rp_col         = 0
  If \bmap_col       Then FreeBitMap_ \bmap_col            : \bmap_col       = 0
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_RemPlayField {}                                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Remove the playfield definitions. The whole visible area will be the play:: /
;/ field.                                                                      /
;/                                                                             /
;/ See also:    dbl_SetPlayField                                               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_RemPlayField {}
 USEPATH dbl

  If \pf_region_0><-1 AND \layer_0
    *new_region.Region = InstallClipRegion_(\layer_0, \pf_region_0)
    If *new_region Then DisposeRegion_ *new_region
    \pf_region_0 = -1
  End If
  If \pf_region_1><-1 AND \layer_1
    *new_region.Region = InstallClipRegion_(\layer_1, \pf_region_1)
    If *new_region Then DisposeRegion_ *new_region
    \pf_region_1 = -1
  End If
  If \pf_region_bg><-1 AND \layer_bg
    *new_region.Region = InstallClipRegion_(\layer_bg, \pf_region_bg)
    If *new_region Then DisposeRegion_ *new_region
    \pf_region_bg =-1
  End If
  \pf_width  = \scr_width
  \pf_height = \scr_height
  \pf_xoff   = 0
  \pf_yoff   = 0
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_SetPlayField {x1.l,y1.l,x2.l,y2.l}                              /
;/                                                                             /
;/ Description:                                                                /
;/ Set a certain rectangle area on the display as the "playfield". All blitt:: /
;/ ing and drawing operations will be clipped to this area.                    /
;/ You can use this e.g. if your game has a split screen or a cockpit consol:: /
;/ e or something, that does not belong to the part where the "action" takes:: /
;/  place.                                                                     /
;/ NOTE: You can use this functions seveal times in your game loop, to updat:: /
;/ e several playfields.                                                       /
;/ NOTE: to set the whole screen as playfield again, use dbl_RemPlayField if:: /
;/  you are to lazy to determine the screen dimensions.                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - x1.l    : coordiates of the playfield area                                /
;/ - y1.l    :                                                                 /
;/ - x2.l    :                                                                 /
;/ - y2.l    :                                                                 /
;/                                                                             /
;/ See also:    dbl_RemPlayField                                               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_SetPlayField{x1.l,y1.l,x2.l,y2.l}
 USEPATH dbl

  dbl_RemPlayField {}
  \pf_rec\MinX = x1
  \pf_rec\MinY = y1
  \pf_rec\MaxX = x2
  \pf_rec\MaxY = y2
  \pf_width  = x2-x1+1
  \pf_height = y2-y1+1
  \pf_xoff   = x1
  \pf_yoff   = y1
  *new_region.Region = NewRegion_
  If *new_region
    If OrRectRegion_(*new_region, &\pf_rec)
      \pf_region_0 = InstallClipRegion_(\layer_0, *new_region)
      ;If \pf_region_0 = 0 Then error {"Unable to install reagion !"}
    End If
  End If
  *new_region.Region = NewRegion_
  If *new_region
    If OrRectRegion_(*new_region, &\pf_rec)
      \pf_region_1 = InstallClipRegion_(\layer_1, *new_region)
    End If
  End If
  *new_region.Region = NewRegion_
  If *new_region
    If OrRectRegion_(*new_region, &\pf_rec)
      \pf_region_bg = InstallClipRegion_(\layer_bg, *new_region)
    End If
  End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_Free {}                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ Close the screen and free all resources assiciated with the dbl_display.i:: /
;/ nclude.                                                                     /
;/ NOTE: This is executed on auto exit, but use this funktion if you need th:: /
;/ is earlier.                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ none                                                                        /
;/                                                                             /
;/ See also:    dbl_Init                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_Free {}
 USEPATH dbl

  dbl_FreeCollision {}
  dbl_RemPlayField{}
  eclock_ReleaseUnit{\eclockunit} : \eclockunit=0

  CNIF #flip_mode=#flip_changebmap OR #flip_mode=#flip_scrbuff
    If \safeToChange=False AND \mp_disp><0
      While (GetMsg_(\mp_disp)=0)
        Wait_(1 LSL \mp_disp\mp_SigBit)
      Wend
    End If

    If \safeToWrite=False AND \mp_safe><0
      While (GetMsg_(\mp_safe)=0)
        Wait_(1 LSL \mp_safe\mp_SigBit)
      Wend
    End If
  CEND
  \safeToWrite = True
  \safeToChange = True

  CNIF #flip_mode = #flip_changebmap
    ChangeVPBitMap_ \scr_vp,\bmap_0,\scr_db  : \bmap_0 = 0 ; set the correct bitmap
  CEND
  ;If \scr_db Then FreeDBufInfo_ \scr_db : \scr_db = 0

  CNIF #use_screenhack
    If Peek.l(Addr Window(0)) Then CloseWindow 0 : \rp_0 = 0  : \layer_0 = 0 :\layerinfo_0 = 0
    If Peek.l(Addr Window(1)) Then CloseWindow 1 : \rp_1 = 0  : \layer_1 = 0 : \layerinfo_1  = 0
    If Peek.l(Addr Window(2)) Then CloseWindow 2 : \rp_bg = 0 : \layer_bg = 0 : \layerinfo_bg = 0
    \bmap_1 = 0   ; we got them from screen
    \bmap_bg = 0
  CELSE
    If Peek.l(Addr Window(0)) Then CloseWindow 0
    If \layer_0_stolen Then \layer_0 = 0:\layerinfo_0=0:\rp =0:\bmap_0=0:\layer_0_stolen=0

    If \layer_0      Then DeleteLayer_        0,\layer_0 : \layer_0       = 0
    If \layerinfo_0  Then DisposeLayerInfo_ \layerinfo_0 : \layerinfo_0   = 0
    If \rp_0         Then                                  \rp_0          = 0

    If \layer_1      Then DeleteLayer_        0,\layer_1 : \layer_1       = 0
    If \layerinfo_1  Then DisposeLayerInfo_ \layerinfo_1 : \layerinfo_1   = 0
    If \rp_1         Then                                  \rp_1          = 0

    If \layer_bg      Then DeleteLayer_        0,\layer_bg : \layer_bg       = 0
    If \layerinfo_bg  Then DisposeLayerInfo_ \layerinfo_bg : \layerinfo_bg   = 0
    If \rp_bg         Then                                   \rp_bg          = 0

    If \scrbuff_0 Then FreeScreenBuffer_ \scr,\scrbuff_0: \bmap_0 = 0 :\scrbuff_0=0 ; bitmap 0 goes with the buffer !
    If \scrbuff_1 Then FreeScreenBuffer_ \scr,\scrbuff_1: \bmap_1 = 0 :\scrbuff_1=0 ; bitmap 1 goes with the buffer !
    If Peek.l(Addr Screen(0)) Then CloseScreen 0 : \bmap_0 = 0 ; bitmap 0 goes with the screen!

    If \bmap_0  Then FreeBitMap_ \bmap_0 : \bmap_0 = 0
    If \bmap_1  Then FreeBitMap_ \bmap_1 : \bmap_1 = 0
    If \bmap_bg Then FreeBitMap_ \bmap_bg : \bmap_bg = 0

    If \mp_safe Then DeleteMsgPort_ \mp_safe : \mp_safe = 0
    If \mp_disp Then DeleteMsgPort_ \mp_disp : \mp_disp = 0
  CEND
End Statement

!autoexit{dbl_Free}


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_Fade {rgbval.l,ratio.l,@nosnap.l}                               /
;/                                                                             /
;/ Description:                                                                /
;/ Fade the whole display into the rgb value with ratio.l.                     /
;/ This can be used to fade the display to black or white, but also to indic:: /
;/ ate an "injury" to the player by fading short to red.                       /
;/ To do a fade on color index screens, it is necessary to manipulate the sc:: /
;/ reens palette. To remember what the actutal palette was, this function ma:: /
;/ kes a snapshot the original palette when it is called the first time.       /
;/ If you want to force a snapshot later, use nosnap.l=False. Be sure that a:: /
;/ t this time the screen has the correct palette.                             /
;/ Note: The action on the display can continue while fading of course. This:: /
;/  function is called on framewise, and can slowly change ratio.l to do a f:: /
;/ ade-out or fade-in effect.                                                  /
;/ Note: This works on color indexed and true/hi color screens! (but it can :: /
;/ be very slow on true/hi color screens, depending on your system power)      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - rgbval.l    : RGB value to fade the display to                            /
;/ - ratio.l     : ratio of fading 0=no incluence, 50=faded half/half, 100=d:: /
;/ isplay is faded completely                                                  /
;/ - nosnap.l    : False = use the current palette as the base palette, True:: /
;/ = use the already "snapped" palette                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_Fade{rgbval.l,ratio.l,@nosnap.l}
 USEPATH dbl

  \fade_rgb = rgbval
  If ratio<0 Then ratio=0
  If ratio>255 Then ratio=255
  \fade_ratio = ratio

  Select \scr_depth
    Case 16

    Case 24

    Default
      ; set palette
      rgbgetval.l = 0
      If \paletteSnap=0 OR nosnap=0
        GetRGB32_ \scr_cm,0,256,&\cmap[0]
        For  n.l=0 To 255
          \cmap[n]\R = \cmap[n]\R LSR 8
          \cmap[n]\G = \cmap[n]\G LSR 8
          \cmap[n]\B = \cmap[n]\B LSR 8
        Next
        \paletteSnap=-1
      End If
      iratio.l = 255 - ratio
      R.l = ((rgbval LSR 16) & $FF) * ratio LSL 16
      G.l = ((rgbval LSR  8) & $FF) * ratio LSL 16
      B.l = ((rgbval LSR  0) & $FF) * ratio LSL 16
      For n.l=0 To 255
        SetRGB32_ \scr_vp,n,(\cmap[n]\R*iratio + R),(\cmap[n]\G*iratio + G),(\cmap[n]\B*iratio + B)
      Next

  End Select
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.f = dbl_GetFPS {@interval.f}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Get the current frames-per-second (in Hz).                                  /
;/ The interval parameter gives you control about the smoothness.              /
;/ Default is 1s, that means the frames per second are messured every second.  /
;/ Smaller intervals give you more results per second, but the accuracy will:: /
;/  be lower.                                                                  /
;/ NOTE: This function is ideal to display a FPS counter on the screen.        /
;/ NOTE: To messure the time for the last frame for frame-rate-independent p:: /
;/ rogramming, use dbl_GetFrameTime.                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - interval.f    : minimum interval to messure                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.f     : frames per second                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.f dbl_GetFPS {@interval.f}
 USEPATH dbl

  If interval<=0 Then interval=1000
  time.f = eclock_Stop{\eclockunit}
  If (time>interval)
     \tst_fps = 1000/time * \tst_fpsc
     eclock_Start{1000,\eclockunit}
     \tst_fpsc = 0
  EndIf

 Function Return \tst_fps
End Function
 
;
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  ratio.f = dbl_GetFrameTime {desiredFPS.f}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Get the ratio of the desired FPS.                                           /
;/ This function is very useful if you want to write a fps-independent game.   /
;/ Lets say, your spaceship speed (in pixels / frame) is meant for 50 FPS, y:: /
;/ ou call r.f = dbl_GetFrameTime{50}, and r will contain the ratio you have:: /
;/ to multiply your spaceship speed. E.g. if your current fps is 100Hz, you :: /
;/ will get r.f = 0.5, if your fps is only 25Hz, you get r.f = 2.0.            /
;/ NOTE: This funtion might return freakingly high or low values, if your ga:: /
;/ me hangs or one frame was very fast. You might want to clip the ratio to :: /
;/ reasonable values, e.g. 0.25 and 4.0.                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - desiredFPS.f  : the FPS you real speed is designed for                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - ratio.f       : ratio you have to multiply your movments in one frame     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.f dbl_GetFrameTime{desiredFPS.f}
 USEPATH dbl

  time.d = eclock_ReadDouble{1.0}
  diff.d = time - \tst_lastframetime
  \tst_lastframetime = time
  \tst_lastdiff = diff ; * 0.9 + diff * 0.1

 Function Return \tst_lastdiff * desiredFPS
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_Flip {}                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ Switch the double buffer. This function has to be called when you have fi:: /
;/ nished drawing your objects.                                                /
;/ It also wait till the tiem frame passed, e.g. if you have set the system :: /
;/ to 50fps, each frame takes 20ms.                                            /
;/ If you spend 14ms on drawing, it will wait 6ms till the frame is over. If:: /
;/  you set the fps to -1, it will return immediately.                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ none                                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST dbl_Flip {}
 SHARED dblqueue0(),dblqueue1()
 USEPATH dbl

  \tst_fpsc+1
  If \fps=#dbl_fps_vbeam  Then WaitBlit_ : WaitBOVP_ \scr_vp
  If \fps=#dbl_fps_vblank Then WaitBlit_ : WaitTOF_
  If \fps>0 Then WaitBlit_ : vvblank_Wait{}

  If (\winmode><0 OR #flip_mode=#flip_bltbmap) AND (#flip_mode><#flip_smart)
    CNIF #use_screenhack
      yoffset.l = \scr_height
    CELSE
      yoffset.l = 0
    CEND

    If \fade_ratio=0 OR \scr_depth<=8
      BltBitMapRastPort_ \bmap,0,yoffset,\rp_0,0,0,\scr_width,\scr_height,$c0
    Else
      image_CPUBlitRPRP {\rp,0,yoffset,\rp_0,0,0,\scr_width,\scr_height,\fade_ratio,\fade_rgb}
    End If

    \db    = 1
    \rp    = \rp_1
    \layer = \layer_1
    \bmap  = \bmap_1
   Statement Return
  End If



  CNIF #flip_mode=#flip_scrollvp
    CNIF #use_screenhack
      bmap.l  = \bmap
      If \db
        yoffset.l = \scr_height
      Else
        yoffset = 0
      End If
    CELSE
      yoffset.l = 0
      If \db
        bmap.l = \bmap_1
      Else
        bmap = \bmap_0
      End If
    CEND

    \scr_vp\RasInfo\BitMap  = bmap
    \scr_vp\RasInfo\RyOffset = yoffset
    WaitBlit_
    ScrollVPort_ (\scr_vp)
    \db = 1-\db
    If \db
      \rp    = \rp_1
      \layer = \layer_1
      \bmap  = \bmap_1
    Else
      \rp    = \rp_0
      \layer = \layer_0
      \bmap  = \bmap_0
    End If
  CEND

  CNIF #flip_mode=#flip_changebmap
    CNIF #use_screenhack
       serror {"#flipmode=#flip_changebmap does not work with #use_screenhack!"}
    CELSE

      If \safeToChange=False
        While (GetMsg_(\mp_disp)=0)
          Wait_(1 LSL \mp_disp\mp_SigBit)
        Wend
      End If
      \safeToChange = True

      WaitBlit_
      ChangeVPBitMap_ \scr_vp,\bmap,\scr_db
      \safeToChange=False
      \safeToWrite=False

      If \safeToWrite=False
        While (GetMsg_(\mp_safe)=0)
          Wait_(1 LSL \mp_safe\mp_SigBit)
        Wend
      End If
      \safeToWrite = True

      \db = 1-\db
      If \db
        \rp    = \rp_1
        \layer = \layer_1
        \bmap  = \bmap_1
      Else
        \rp    = \rp_0
        \layer = \layer_0
        \bmap  = \bmap_0
      End If
    CEND

  CEND


  CNIF #flip_mode=#flip_scrbuff
    CNIF #use_screenhack
       serror {"#flipmode=#flip_scrbuff does not work with #use_screenhack!"}
    CELSE

      If \safeToChange=False
        While (GetMsg_(\mp_disp)=0)
          Wait_(1 LSL \mp_disp\mp_SigBit)
        Wend
      End If

      \safeToChange = True
      WaitBlit_

      If \db
        succ.l = ChangeScreenBuffer_ (\scr,\scrbuff_1)
      Else
        succ.l = ChangeScreenBuffer_ (\scr,\scrbuff_0)
      End If

      If succ
        \db=1-\db
        \safeToChange=False
        \safeToWrite=False

        If \safeToWrite=False
          While (GetMsg_(\mp_safe)=0)
            Wait_(1 LSL \mp_safe\mp_SigBit)
          Wend
        End If
        \safeToWrite = True

        ;If \db=0 Then SetAPen_ \rp_0,1 : RectFill_ \rp_0,10, 10,100,100 : SetAPen_ \rp_1,1 : RectFill_ \rp_1,100, 10,200,100  : Delay_ 10
        ;If \db=1 Then SetAPen_ \rp_0,1 : RectFill_ \rp_0,10,100,100,200 : SetAPen_ \rp_1,1 : RectFill_ \rp_1,100,100,200,200  : Delay_ 10
        ;Delay_ 20
        If \db
          \rp    = \rp_1
          \layer = \layer_1
          \bmap  = \bmap_1
        Else
          \rp    = \rp_0
          \layer = \layer_0
          \bmap  = \bmap_0
        End If
      End If
    CEND

  CEND


  CNIF #flip_mode=#flip_none
    \db = 0 : \rp = \rp_0 ;: Use Window 0
    \bmap = \bmap_0
    \layer = \layer_0
  CEND

  CNIF #flip_mode=#flip_smart
    CNIF #use_screenhack
      yoffset.l = \scr_height
    CELSE
      yoffset.l = 0
    CEND

    #smart_opt=1 ; use optimized routine
    CNIF #smart_opt=0
     USEPATH dblqueue0()
      ResetList dblqueue0()
      While NextItemFast(dblqueue0())
        CNIF #use_cpublit
          image_CPUBlitRPRP {dbl\rp  ,\x,\y+yoffset,dbl\rp_0,\x,\y,\xs,\ys }
        CELSE
          BltBitMapRastPort_ dbl\bmap,\x,\y+yoffset,dbl\rp_0,\x,\y,\xs,\ys,$c0
        CEND
        KillItem dblqueue0()
      Wend
     USEPATH dblqueue1()
      ResetList dblqueue1()
      While NextItemFast(dblqueue1())
        CNIF #use_cpublit
          image_CPUBlitRPRP {dbl\rp  ,\x,\y+yoffset,dbl\rp_0,\x,\y,\xs,\ys }
        CELSE
          BltBitMapRastPort_ dbl\bmap,\x,\y+yoffset,dbl\rp_0,\x,\y,\xs,\ys,$c0
        CEND
        If AddItem (dblqueue0())
          CopyMem_ &dblqueue1(),&dblqueue0(),SizeOf.queueitem
        End If
      Wend
     USEPATH dbl ; set back to the default
    CELSE
     USEPATH dblqueue1()
      ResetList dblqueue1()
      ResetList dblqueue0()
      While NextItemFast(dblqueue1())
        If NextItemFast(dblqueue0())
          If \x+\xs>dblqueue0()\x AND dblqueue0()\x+dblqueue0()\xs>\x AND \y+\ys>dblqueue0()\y AND dblqueue0()\y+dblqueue0()\ys>\y
            y.l = Min(\y,dblqueue0()\y)
            x.l = Min(\x,dblqueue0()\x)
            xs.l = Max(\x+\xs,dblqueue0()\x+dblqueue0()\xs) -x
            ys.l = Max(\y+\ys,dblqueue0()\y+dblqueue0()\ys) -y
            CNIF #use_cpublit
              image_CPUBlitRPRP {dbl\rp  ,x,y+yoffset,dbl\rp_0,x,y,xs,ys }
            CELSE
              BltBitMapRastPort_ dbl\bmap,x,y+yoffset,dbl\rp_0,x,y,xs,ys,$c0
            CEND
          Else
            CNIF #use_cpublit
             USEPATH dblqueue0():image_CPUBlitRPRP {dbl\rp  ,\x,\y+yoffset,dbl\rp_0,\x,\y,\xs,\ys }
             USEPATH dblqueue1():image_CPUBlitRPRP {dbl\rp  ,\x,\y+yoffset,dbl\rp_0,\x,\y,\xs,\ys }
            CELSE
             USEPATH dblqueue0():BltBitMapRastPort_ dbl\bmap,\x,\y+yoffset,dbl\rp_0,\x,\y,\xs,\ys,$c0
             USEPATH dblqueue1():BltBitMapRastPort_ dbl\bmap,\x,\y+yoffset,dbl\rp_0,\x,\y,\xs,\ys,$c0
            CEND
          End If
          KillItem dblqueue0()
        Else
          CNIF #use_cpublit
            image_CPUBlitRPRP {dbl\rp  ,\x,\y+yoffset,dbl\rp_0,\x,\y,\xs,\ys }
          CELSE
            BltBitMapRastPort_ dbl\bmap,\x,\y+yoffset,dbl\rp_0,\x,\y,\xs,\ys,$c0
          CEND
        End If
      Wend

     USEPATH dblqueue0()
      While NextItemFast(dblqueue0())
        CNIF #use_cpublit
          image_CPUBlitRPRP {dbl\rp  ,\x,\y+yoffset,dbl\rp_0,\x,\y,\xs,\ys }
        CELSE
          BltBitMapRastPort_ dbl\bmap,\x,\y+yoffset,dbl\rp_0,\x,\y,\xs,\ys,$c0
        CEND
        KillItem dblqueue0()
      Wend

     USEPATH dblqueue1()
      ResetList dblqueue1()
      While NextItemFast(dblqueue1())
        If AddItem (dblqueue0())
          CopyMem_ &dblqueue1(),&dblqueue0(),SizeOf.queueitem
        End If
      Wend

     USEPATH dbl  ; set the default back
    CEND

    \db    = 1
    \rp    = \rp_1
    \layer = \layer_1
    \bmap  = \bmap_1
  CEND

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  dbl_GetWidth {}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ Retrun the width in pixels of the dbl display.                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : pixel width of the dbl display                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST dbl_GetWidth{}
 Function Return dbl\scr_width
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  dbl_GetHeight {}                                       /
;/                                                                             /
;/ Description:                                                                /
;/ Return the height in pixels of the dbl display.                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : height in pixels of the dbl display                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST dbl_GetHeight{}
 Function Return dbl\scr_height
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  dbl_GetRPPtr {}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST dbl_GetRPPtr{}
 Function Return dbl\rp
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  dbl_GetBGRPPtr {}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST dbl_GetBGRPPtr{}
 Function Return dbl\rp_bg
End Function
 

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  dbl_GetDepth {}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : depth of the dbl display                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST dbl_GetDepth{}
 Function Return dbl\scr_depth
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !dbl_GetWidth                                                       /
;/                                                                             /
;/ Description:                                                                /
;/ Return the pixel width of the dbl display.                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ pixel width of the dbl display                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro dbl_GetWidth
  dbl\scr_width
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !dbl_GetRPPtr                                                       /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro dbl_GetRPPtr
  dbl\rp
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !dbl_GetHeight                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Return the current pixel height of the dbl display.                         /
;/                                                                             /
;/ Result:                                                                     /
;/ pixel height of the dbl display                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro dbl_GetHeight
  dbl\scr_height
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !dbl_GetDepth                                                       /
;/                                                                             /
;/ Description:                                                                /
;/ Return the current color depth of the dbl display.                          /
;/                                                                             /
;/ Result:                                                                     /
;/ color depth in bits                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro dbl_GetDepth
  dbl\scr_depth
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !dbl_GetPFWidth                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Return the current pixel width of the current playfield clip.               /
;/                                                                             /
;/ Result:                                                                     /
;/ pixel width of the current playfield clip                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro dbl_GetPFWidth
  dbl\pf_width
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !dbl_GetPFHeight                                                    /
;/                                                                             /
;/ Description:                                                                /
;/ Return the current pixel height of the current playfield clip.              /
;/                                                                             /
;/ Result:                                                                     /
;/ pixel height of the current playfield clip                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro dbl_GetPFHeight
  dbl\pf_height
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !dbl_GetPFX                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro dbl_GetPFX
  dbl\pf_xoff
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !dbl_GetPFY                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro dbl_GetPFY
  dbl\pf_yoff
End Macro



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_QDamage {x.l,@y.l,@xs.l,@ys.l,@db.l}                            /
;/                                                                             /
;/ Description:                                                                /
;/ Clear the given region with the background image.                           /
;/ (it is marked as "damaged", and will be cleared in the next call of dbl_U:: /
;/ nqueue).                                                                    /
;/ NOTE: Use this if you made the display "dirty" with some other commands t:: /
;/ han dbl_QBlit{}, e.g. with WBox and tell the queue to clean it.             /
;/ NOTE: This is only needed in dbl_method=0, however, its always a good ide:: /
;/ a to do it correctly.                                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - x.l         : x coordinate                                                /
;/ - y.l         : y coordinate                                                /
;/ - xs.l        : width of the region that should be cleared                  /
;/ - ys.l        : height of the region that should be cleared                 /
;/ - db.l        : optional: force the buffer, can be 0 or 1                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST dbl_QDamage {x.l,@y.l,@xs.l,@ys.l,@db.l}
 SHARED dblqueue0(),dblqueue1()
 USEPATH dbl

  CNIF #refresh_mode=#refresh_object
    If x<0 Then x=0
    If y<0 Then y=0
    If xs<0 Then xs=\pf_width
    If ys<0 Then ys=\pf_height
    x+\pf_xoff
    y+\pf_yoff

    If db=-1 Then db=\db
    If db
     USEPATH dblqueue1()
      If AddItem(dblqueue1())
        \x  = x
        \y  = y
        \xs = xs
        \ys = ys
      End If
    Else
     USEPATH dblqueue0()
      If AddItem(dblqueue0())
        \x  = x
        \y  = y
        \xs = xs
        \ys = ys
      End If
    End If
   USEPATH dbl ; set it back to the default
  CEND
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_QRefresh {x.l,y.l,xs.l,ys.l,@db.l}                              /
;/                                                                             /
;/ Description:                                                                /
;/ * absolete * (for compatibelity)                                            /
;/ Use dbl_damage istead.                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/ - xs.l    : ???                                                             /
;/ - ys.l    : ???                                                             /
;/ - db.l    : ???                                                             /
;/                                                                             /
;/ See also:    dbl_damage                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST dbl_QRefresh {x.l,y.l,xs.l,ys.l,@db.l}
  dbl_QDamage {x,y,xs,ys,db}
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_QDamageArea {x1.l,y1.l,x2.l,y2.l,@db.l}                         /
;/                                                                             /
;/ Description:                                                                /
;/ Same like dbl_QDamage, but for lazy people who dont want to calculate the:: /
;/  width and height of the damaged area if the x1/y1 x2/y2 coordinates are :: /
;/ given.                                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - x1.l         : x1 coordinate                                              /
;/ - y1.l         : y1 coordinate                                              /
;/ - x2.l         : x2 coordinate                                              /
;/ - y2.l         : y2 coordinate                                              /
;/ - db.l        : optional: force the buffer, can be 0 or 1                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST dbl_QDamageArea{x1.l,y1.l,x2.l,y2.l,@db.l}
  dbl_QDamage {x1,y1,x2-x1+1,y2-y1+1,db}
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_Reset {@pen.l}                                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Reset the double buffer display. It is a good idea to call this before yo:: /
;/ u enter the gameplay loop to clear everything up.                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ none                                                                        /
;/ - pen.l    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_Reset {@pen.l}
 SHARED dblqueue0(),dblqueue1()
 USEPATH dbl

  \db   = 1
  \rp   = \rp_1
  \bmap   = \bmap_1
  \layer  = \layer_1

  CNIF #flip_mode=#flip_changebmap OR #flip_mode=#flip_scrbuff
    If \safeToChange=False AND \mp_disp><0
    While (GetMsg_(\mp_disp)=0)
      Wait_(1 LSL \mp_disp\mp_SigBit)
      Wend
    End If

    If (\safeToWrite=False) AND (\mp_safe><0)
    While (GetMsg_(\mp_safe)=0)
      Wait_(1 LSL \mp_safe\mp_SigBit)
      Wend
    End If
  CEND

  \safeToWrite  = True
  \safeToChange = True
  ClearList dblqueue0()
  ClearList dblqueue1()

  eclock_Start{1000,\eclockunit}
  dbl_GetFrameTime{50}
  dbl_GetFPS{}
  Use Window 0
  If pen<0 Then pen=0
  SetAPen_ \rp_0,pen
  RectFill_ \rp_0,0,0,\scr_width,\scr_height
  SetAPen_ \rp_1,pen
  RectFill_ \rp_1,0,0,\scr_width,\scr_height
  SetAPen_ \rp_bg,pen
  RectFill_ \rp_bg,0,0,\scr_width,\scr_height
  dbl_Flip {}
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_SetFPS {fps.f}                                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Set the desired fps.                                                        /
;/ Usually, this is something from 25 to 100Hz.                                /
;/ Your game will be triggered to this fps within the dbl_Flip function.       /
;/ If you need more time for drawing your objects, your gameplay will slow d:: /
;/ own.                                                                        /
;/ If you want to program your game fps independent, use dbl_GetFrameTime to:: /
;/  correct your objects movements. Your gamplay will then stay at the same :: /
;/ speed, but the objects move more rough, as found in most 3D games nowadays. /
;/                                                                             /
;/ Possible values for fps are:                                                /
;/ 1...250               : the desired FPS you want in Hz                      /
;/ #dbl_fps_free    =  0 : no timing, pass every frame as fast as possible     /
;/ #dbl_fps_vbeam   = -1 : use VBeam via WaitBOVP_() for timing (usually the:: /
;/  monitors FPS)                                                              /
;/ #dbl_fps_monitor = -2 : normal timer with calculated FPS of screenmode      /
;/ #dbl_fps_vblank  = -3 : use VBlank via WaitTOF_() for timing (usually 50H:: /
;/ z or monitors FPS)                                                          /
;/                                                                             /
;/ NOTE: It is a hard choise what does the best for you.                       /
;/ If you program for a fix FPS, you might just want to set the FPS with a H:: /
;/ z number.                                                                   /
;/ If you can handle variable frame rates, I recommend #dbl_fps_vbeam, at le:: /
;/ ast under WinUAE it looks like kinda syncronized with the real refresh ra:: /
;/ te of the monitor.                                                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fps.f    : FPS in Hz or #dbl_fps_xxx constant                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_SetFPS {fps.f}
 USEPATH dbl

  \fps = fps
  If \fps<#dbl_fps_monitor+.5 AND \fps>#dbl_fps_monitor-.5 Then \fps=\realfps
  ;error {"set fps:"+Str$(fps)}
  If \fps>0 Then succ.l = vvblank_SetFreq{\fps}
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = dbl_Init {screenname.s,modeid.l,@scr_width.l,@scr_heigh:: /
;/ t.l,@scr_depth.l,@idcmp.l}                                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Init the double buffered display (screen).                                  /
;/ It is recommended to use the intuition.library to receive input events an:: /
;/ d leave the idcmp parameter out.                                            /
;/ It is only needed if you check your IDCMP messages in another way. By def:: /
;/ ault, you will not receive IDCMP_VANILLAKEY events.                         /
;/ The intuition.inlcude only receives IDCMP_RAWKEY events, but allows to as:: /
;/ k for the vanillakey value. This is necessary to track the keyboard statu:: /
;/ s systemfriendly, which is necessary for games.                             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - screenname.s : name of the screen                                         /
;/ - modeid.l     : screenmode ID / 0=ASL Requester / -1=BestModeID / -2 = w:: /
;/ indow mode / -3 = workbench                                                                 /
;/ - scr_width.l  : width of screen                                            /
;/ - scr_height.l : height of screen                                           /
;/ - scr_depth.l  : depth of screen (HiColor is depth=16, TrueColor is depth:: /
;/ =24)                                                                        /
;/ - idcmp.l    : IDCMP Mask of messages you want to receive                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l       : True if everthing went well, False if it fails             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dbl_Init {screenname.s,modeid.l,@scr_width.l,@scr_height.l,@scr_depth.l,@idcmp.l}
 SHARED imagedat(),dblqueue0(),dblqueue1()
 SHARED diminfo,disinfo,moninfo,imageengine
 USEPATH dbl

  asldepth.l=24
  winmode.l = 0
  \eclockunit = eclock_ObtainUnit{}
  If modeid=False
    aslsm_SetInitialDims{scr_width,scr_height,scr_depth}
    aslsm_SetMinDims{scr_width,scr_height,-1}
    aslsm_SetMaxDims{scr_width,scr_height,-1}
    If aslsm_Request{True,True,True,False}
    ;*scrinfo.aslscreeninfox = ASLScreenRequest(4)
    ;If *scrinfo
  ;    modeid.l   = *scrinfo\scr_id
  ;    asldepth.l = *scrinfo\scr_depth
      modeid.l   = aslsm_GetModeID{}
      asldepth.l = aslsm_GetDepth{};*scrinfo\scr_depth
      name.s     = aslsm_GetModeName{}
    End If
  End If

  If modeid=-1
   WbToScreen 0
   *scr.Screen = Peek.l(Addr Screen(0))
   If *scr
     wbmode.l = GetVPModeID_(*scr\ViewPort) & #MONITOR_ID_MASK
     modeid.l = BestCModeIDTagList_ (Tags(#CYBRBIDTG_NominalWidth,scr_width,#CYBRBIDTG_NominalHeight,scr_height,#CYBRBIDTG_Depth,scr_depth))
   End If
   *scr = 0
  End If

  If modeid=-2 OR modeid=-3
   WbToScreen 0
   *scr.Screen = Peek.l(Addr Screen(0))
   If *scr
     If modeid=-2 Then winmode=1:Else winmode=2
     modeid.l = GetVPModeID_(*scr\ViewPort) & #MONITOR_ID_MASK
   End If
   *scr = 0
  End If

  If modeid
    modename.s = aslsm_GetModeName{modeid}
    mode_ptr.l = FindDisplayInfo_ (modeid)
    If mode_ptr
      GetDisplayInfoData_ mode_ptr,&disinfo,SizeOf.DisplayInfo,#DTAG_DISP,modeid
      GetDisplayInfoData_ mode_ptr,&diminfo,SizeOf.DisplayInfo,#DTAG_DIMS,modeid
      GetDisplayInfoData_ mode_ptr,&moninfo,SizeOf.DisplayInfo,#DTAG_MNTR,modeid

      If disinfo\NotAvailable=False
        max_depth.l  = diminfo\MaxDepth
        max_width.l  = diminfo\Nominal\MaxX - diminfo\Nominal\MinX +1
        max_height.l = diminfo\Nominal\MaxY - diminfo\Nominal\MinY +1
        pixelclock.d = 1000000000 / disinfo\PixelSpeed
        pixelclockperline.d = 280 / disinfo\PixelSpeed * moninfo\TotalColorClocks
        hscan.d = pixelclock / pixelclockperline
        vscan.d = hscan / moninfo\TotalRows
        \realfps = vscan
      End If
      If scr_depth <1 Then scr_depth  = max_depth
      If scr_width <1 Then scr_width  = max_width
      If scr_height<1 Then scr_height = max_height
    Else
      scr_depth=-1
    End If

    If scr_depth>max_depth Then scr_depth=max_depth

    If scr_width<=max_width AND scr_height<=max_height AND scr_depth<=max_depth AND scr_depth>0 AND scr_width>0 AND scr_height>0
      If asldepth<scr_depth Then scr_depth=asldepth
      succ.l = False
      \scr_width  = scr_width
      \scr_height = scr_height
      \scr_depth  = scr_depth
      \scr_pens   = -1
      If winmode = 0
        \winmode = 0
        CNIF #use_screenhack=0; #flip_mode=#flip_bmap
          ScreenTags 0,screenname.s,Tags(#SA_Width,scr_width,#SA_Height,scr_height,#SA_Depth,scr_depth,#SA_DisplayID,modeid,#SA_SharePens,-1,#SA_Pens,&\scr_pens,#SA_Behind,1,#SA_Quiet,1)
        CELSE
          ScreenTags 0,screenname.s,Tags(#SA_Width,scr_width,#SA_Height,scr_height*3,#SA_Depth,scr_depth,#SA_DisplayID,modeid,#SA_SharePens,-1,#SA_Pens,&\scr_pens,#SA_Behind,1,#SA_Quiet,1)
        CEND
      Else
        \winmode = winmode
      ;  If #use_screenhack Then serror {"Window mode does not work with screenhack !"}
      ;  If #flip_mode = #flip_scrollvp Then serror {"Window mode does not work with #flip_mode = #flip_scrollvp!"}
      ;  If #flip_mode = #flip_changebmap Then serror {"Window mode does not work with #flip_mode = #flip_chnagebmap!"}
      ;  If #flip_mode = #flip_scrbuff Then serror {"Window mode does not work with #flip_mode = #flip_scrbuff!"}
        WbToScreen 0
      End If

      *scr.Screen = Peek.l(Addr Screen(0))
      If *scr
        \scr        = *scr
        \scr_rp     = *scr\RastPort
        \scr_vp     = *scr\ViewPort
        \scr_cm     = *scr\ViewPort\ColorMap
        \scr_bmap   = *scr\RastPort\BitMap
        succ=True
        If winmode=0
          dbl_SetPen{0,0,0,0}
          dbl_SetPen{1,255,255,255}
        End If
        If idcmp = -1 Then idcmp = #IDCMP_MOUSEBUTTONS|#IDCMP_MOUSEMOVE|#IDCMP_RAWKEY|#IDCMP_GADGETUP|#IDCMP_GADGETDOWN|#IDCMP_ACTIVEWINDOW|#IDCMP_INACTIVEWINDOW
        DefaultIDCMP idcmp
        \layer_0_stolen = False

        CNIF #use_screenhack=0
          If winmode><0
            If winmode=1
              wxs.l = \scr_width+*scr\WBorLeft + *scr\WBorRight
              wys.l = \scr_height+*scr\Font\ta_YSize+*scr\WBorTop+*scr\WBorBottom+1
              Window 0,*scr\Width/2-wxs/2,*scr\Height/2-wys/2,wxs,wys,#WFLG_ACTIVATE|#WFLG_SIMPLE_REFRESH|#WFLG_GIMMEZEROZERO|#WFLG_NOCAREREFRESH|$4|$2,screenname,1,0

              ;Window 0,ScreenWidth/2-wxs/2,ScreenHeight/2-wys/2,wxs,wys,#WFLG_SIMPLE_REFRESH|#WFLG_NOCAREREFRESH|$4|$2,screenname,1,0
            Else
              wxs.l = \scr_width
              wys.l = \scr_height
              Window 0,0,0,wxs,wys,#WFLG_SIMPLE_REFRESH|#WFLG_BORDERLESS|#WFLG_ACTIVATE|#WFLG_NOCAREREFRESH ,"",1,0
            End If
            \win = Peek.l(Addr Window (0))
            If \win
              \layer_0     = \win\WLayer
              \layerinfo_0 = 0
              \rp_0        = \win\RPort
              \bmap_0      = \win\RPort\BitMap
            End If
            \layer_0_stolen = True
          Else
            Window 0,0,\scr_height*0,\scr_width,\scr_height,#WFLG_BORDERLESS|#WFLG_SIMPLE_REFRESH|#WFLG_ACTIVATE,"",1,0
            \win = Peek.l(Addr Window (0))
            \bmap_0  = \scr_bmap
            \layerinfo_0  = NewLayerInfo_()
            If \layerinfo_0  Then \layer_0  = CreateUpfrontHookLayer_ (\layerinfo_0 ,\bmap_0 ,0,0,\scr_width-1,\scr_height-1,0,#LAYERS_NOBACKFILL,0)
            If \layer_0  Then \rp_0  = \layer_0\rp
          End If

          d.l = GetBitMapAttr_(\scr_bmap,#BMA_DEPTH)
          If d<=0 Then d=24
          CNIF #flip_mode = #flip_scrbuff OR #flip_mode = #flip_changebmap
            \scrbuff_0 = AllocScreenBuffer_(\scr,0,#SB_SCREEN_BITMAP)
            \scrbuff_1 = AllocScreenBuffer_(\scr,0,#SB_COPY_BITMAP)
            If \scrbuff_0 ><0 AND \scrbuff_1><0
              \bmap_0 = \scrbuff_0\sb_BitMap
              \bmap_1 = \scrbuff_1\sb_BitMap
              If \scrbuff_0\sb_DBufInfo><0 AND \scrbuff_1\sb_DBufInfo><0
                \scrbuff_0\sb_DBufInfo\dbi_UserData1 = 0
                \scrbuff_1\sb_DBufInfo\dbi_UserData1 = 1
                \scr_db=\scrbuff_0\sb_DBufInfo
                \mp_safe = CreateMsgPort_()
                \mp_disp = CreateMsgPort_()
                \scrbuff_0\sb_DBufInfo\dbi_SafeMessage\mn_ReplyPort = \mp_safe
                \scrbuff_0\sb_DBufInfo\dbi_DispMessage\mn_ReplyPort = \mp_disp
                \scrbuff_1\sb_DBufInfo\dbi_SafeMessage\mn_ReplyPort = \mp_safe
                \scrbuff_1\sb_DBufInfo\dbi_DispMessage\mn_ReplyPort = \mp_disp
              End If
            End If
          CELSE
            \bmap_1  = AllocBitMap_(\scr_width,\scr_height,d,#BMF_DISPLAYABLE|#BMF_MINPLANES,\scr_bmap)
          CEND

          \bmap_bg = AllocBitMap_(\scr_width,\scr_height,d,#BMF_DISPLAYABLE|#BMF_MINPLANES,\scr_bmap)
          \layerinfo_1  = NewLayerInfo_()
          \layerinfo_bg = NewLayerInfo_()
          If \layerinfo_1  Then \layer_1  = CreateUpfrontHookLayer_ (\layerinfo_1 ,\bmap_1 ,0,0,\scr_width-1,\scr_height-1,0,#LAYERS_NOBACKFILL,0)
          If \layerinfo_bg Then \layer_bg = CreateUpfrontHookLayer_ (\layerinfo_bg,\bmap_bg,0,0,\scr_width-1,\scr_height-1,0,#LAYERS_NOBACKFILL,0)
          If \layer_1  Then \rp_1  = \layer_1\rp
          If \layer_bg Then \rp_bg = \layer_bg\rp
        CELSE
          Window 0,0,\scr_height*0,\scr_width,\scr_height,#WFLG_BORDERLESS|#WFLG_SIMPLE_REFRESH,"",1,0
          Window 1,0,\scr_height*1,\scr_width,\scr_height,#WFLG_BORDERLESS|#WFLG_SIMPLE_REFRESH,"",1,0
          Window 2,0,\scr_height*2,\scr_width,\scr_height,#WFLG_BORDERLESS|#WFLG_SIMPLE_REFRESH,"",1,0
          \bmap_0   = \scr_bmap
          \bmap_1   = \scr_bmap
          \bmap_bg  = \scr_bmap
          \xwin_0   = Peek.l(Addr Window (0))
          \xwin_1   = Peek.l(Addr Window (1))
          \xwin_bg  = Peek.l(Addr Window (2))
          \layer_0  = \xwin_0\WLayer
          \layer_1  = \xwin_1\WLayer
          \layer_bg = \xwin_bg\WLayer
          \rp_0     = RastPort(0)
          \rp_1     = RastPort(1)
          \rp_bg    = RastPort(2)
        CEND

        \rp           = \rp_0
        \layer        = \layer_0
        \bmap         = \bmap_0
        \db           = 0
        \pf_width     = \scr_width
        \pf_height    = \scr_height
        \pf_xoff      = 0
        \pf_yoff      = 0
        dbl_SetFPS{\realfps}
        \pf_region_0  = -1
        \pf_region_1  = -1
        \pf_region_bg = -1
        \safeToWrite  = True
        \safeToChange = True

        If \bmap_0=0 OR \bmap_1=0 OR \bmap_bg=0    Then succ=False
        If \layer_0=0 OR \layer_1=0 OR \layer_bg=0 Then succ=False
        If \rp_0=0 OR \rp_1=0 OR \rp_bg=0          Then succ=False
        SetAPen_ \rp_0,0 : RectFill_ \rp_0 ,0,0,\scr_width-1,\scr_height-1
        SetAPen_ \rp_1,0 : RectFill_ \rp_1 ,0,0,\scr_width-1,\scr_height-1
        SetAPen_ \rp_bg,0: RectFill_ \rp_bg,0,0,\scr_width-1,\scr_height-1
        If succ
          ClearList dblqueue0()
          ClearList dblqueue1()
          If winmode=0 Then dbl_HideMousePointer {}
          dbl_Reset{}
        End If
      Else
        If \winmode
          error {"Unable to find Workbench screen!"}
        Else
          error {"Unable to open screen! ("+Str$(\scr_width)+"x"+Str$(\scr_height)+"x"+Str$(\scr_depth)+")"}
        End If
      End If
    Else
      a.s = "Visible screensize for the selected mode\\n\\22"+modename.s+"\\22 is too small ("
      a.s + Str$(max_width)+"x"+Str$(max_height)
      a.s + ")!\\nUse at least "+Str$(scr_width)+"x"+Str$(scr_height)+"."
      error {a.s}
    End If
  Else
    error {"\\__THIS_FUNCTION: Invalid screenmode ID!"}
  End If
  If succ=False
    dbl_Free{}
  Else
    If \scr
      ScreenToFront_ \scr
      \scr_depth = GetBitMapAttr_(\scr\RastPort\BitMap,#BMA_DEPTH)
    End If
  End If
  If \scr_depth>8 Then \temppen=255: Else \temppen=(1 LSL \scr_depth)-1

 Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_QLine {rgbval.l,x1.l,y1.l,x2.l,y2.l}                            /
;/                                                                             /
;/ Description:                                                                /
;/ Draw a uni-color line that will be removed with the next call of dbl_Unqu:: /
;/ eue.                                                                        /
;/ Note: this function is designed for True/Hi color screens!                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - rgbval.l    : RGB value of the color, e.g. $FF00FF for pink               /
;/ - x1.l    :  x1 coordinate                                                  /
;/ - y1.l    :  y1 coordinate                                                  /
;/ - x2.l    :  x2 coordinate                                                  /
;/ - y2.l    :  y2 coordinate                                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_QLine24 {rgbval.l,x1.l,y1.l,x2.l,y2.l}
 USEPATH dbl

  If rgbval><\last_rgbval Then dbl_SetPenRGB{\temppen,rgbval} : \last_rgbval = rgbval
  x1+\pf_xoff
  y1+\pf_yoff
  x2+\pf_xoff
  y2+\pf_yoff

  SetAPen_ \rp,\temppen
  CNIF #refresh_mode=#refresh_object
    dbl_QDamage{x1,y1,x2-x1+1,y2-y1+1}
  CEND
  Move_ \rp,x1,y1
  Draw_ \rp,x2,y2
End Statement

;///////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////
Function.l dbl_IsWindowMode{}
 Function Return \winmode
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_QPlot {rgbval.l,x1.l,y1.l}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Draw a uni-color pixel that will be removed with the next call of dbl_Unq:: /
;/ ueue.                                                                       /
;/ Note: this function is designed for True/Hi color screens!                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - rgbval.l    : RGB value of the color, e.g. $FF00FF for pink               /
;/ - x1.l    :  x1 coordinate                                                  /
;/ - y1.l    :  y1 coordinate                                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_QPlot24 {rgbval.l,x1.l,y1.l}
 USEPATH dbl

  If rgbval><\last_rgbval Then dbl_SetPenRGB{\temppen,rgbval} : \last_rgbval = rgbval
  x1+\pf_xoff
  y1+\pf_yoff
  SetAPen_ \rp,\temppen
  CNIF #refresh_mode=#refresh_object
    dbl_QDamage{x1,y1,1,1}
  CEND
  WritePixel_ \rp,x1,y1
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_QBox {rgbval.l,x1.l,y1.l,x2.l,y2.l}                             /
;/                                                                             /
;/ Description:                                                                /
;/ Draw a uni-color rectangle box  that will be removed with the next call o:: /
;/ f dbl_Unqueue.                                                              /
;/ Note: this function is designed for True/Hi color screens!                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - rgbval.l    : RGB value of the color, e.g. $FF00FF for pink               /
;/ - x1.l    :  x1 coordinate                                                  /
;/ - y1.l    :  y1 coordinate                                                  /
;/ - x2.l    :  x2 coordinate                                                  /
;/ - y2.l    :  y2 coordinate                                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_QBox24 {rgbval.l,x1.l,y1.l,x2.l,y2.l}
 USEPATH dbl

  If rgbval><\last_rgbval Then dbl_SetPenRGB{\temppen,rgbval} : \last_rgbval = rgbval
  x1+\pf_xoff
  y1+\pf_yoff
  x2+\pf_xoff
  y2+\pf_yoff
  If x1>x2 Then Exchange x1,x2
  If y1>y2 Then Exchange y1,y2
  SetAPen_ \rp,\temppen
  CNIF #refresh_mode=#refresh_object
    dbl_QDamage{x1,y1,x2-x1+1,y2-y1+1}
  CEND
  RectFill_ \rp,x1,y1,x2,y2
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_QBlitx {image.l,x.l,y.l,@factor.f,@yfactor.f,@mode.l,@density:: /
;/ .l}                                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * obsolete *                                                                /
;/ Use dbl_QBlit instead.                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l     : image you want to blit                                      /
;/ - x.l         : x coordinate                                                /
;/ - y.l         : y coordinate                                                /
;/ - factor      : zooming factor (1.0 = same size, 2.0 = double size, 0.5 =:: /
;/ half size                                                                   /
;/ - yfactor.f   : optional y-zooming factor if you want to change the aspect  /
;/ - mode.l    : ???                                                           /
;/ - density.l    : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST dbl_QBlit_deprecated {image.l,x.l,y.l,@factor.f,@yfactor.f,@mode.l,@density.l}
 SHARED dblqueue0(),dblqueue1(),imagedat()
 USEPATH dbl

  x+\pf_xoff
  y+\pf_yoff
  If factor<=0 OR (factor=1 AND (yfactor=1 OR yfactor=-1))
    CNIF #refresh_mode=#refresh_full
      CNIF #use_cpublit
        image_CPUBlit  {image,x,y,\rp}
      CELSE
        image_BlitMask {image,x,y,\rp}
      CEND
    CEND

    CNIF #refresh_mode=#refresh_object
      If \db
       USEPATH dblqueue1()
        If AddItem(dblqueue1())
          \x  = x - imagedat(image)\handle_x
          \y  = y - imagedat(image)\handle_y
          \xs = imagedat(image)\img_width
          \ys = imagedat(image)\img_height
          CNIF #use_cpublit
            image_CPUBlit {image,x,y,dbl\rp}
          CELSE
            image_BlitMask {image,x,y,dbl\rp}
          CEND
        End If
      Else
       USEPATH dblqueue0()
        If AddItem(dblqueue0())
          \x  = x - imagedat(image)\handle_x
          \y  = y - imagedat(image)\handle_y
          \xs = imagedat(image)\img_width
          \ys = imagedat(image)\img_height

          CNIF #use_cpublit
            image_CPUBlit {image,x,y,dbl\rp}
          CELSE
            image_BlitMask {image,x,y,dbl\rp}
          CEND
        End If
      End If
     USEPATH dbl ; set it back to the default
    CEND
  Else
    xs.l   = imagedat(image)\img_width *factor
    If yfactor>0
      ys.l = imagedat(image)\img_height*yfactor
    Else
      ys.l = imagedat(image)\img_height*factor
    End If

    CNIF #refresh_mode=#refresh_full
      image_CPUBlitScaled {image,x,y,xs,ys,\rp}
    CEND

    CNIF #refresh_mode=#refresh_object
      xscale.l = (#image_scaleres * imagedat(image)\img_width ) / xs
      yscale.l = (#image_scaleres * imagedat(image)\img_height) / ys
      x1.l = x - (imagedat(image)\handle_x*#image_scaleres/xscale)
      y1.l = y - (imagedat(image)\handle_y*#image_scaleres/yscale)

      If \db
       USEPATH dblqueue1()
        If AddItem(dblqueue1())
          \x  = x1
          \y  = y1
          \xs = xs
          \ys = ys
          image_CPUBlitScaled {image,x,y,xs,ys,dbl\rp}
        End If
      Else
       USEPATH dblqueue0()
        If AddItem(dblqueue0())
          \x  = x1
          \y  = y1
          \xs = xs
          \ys = ys
          image_CPUBlitScaled {image,x,y,xs,ys,dbl\rp}
        End If
      End If
     USEPATH dbl ; set it back to the default
    CEND

  End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_QBlit {image.l,x.l,y.l,@factor.f,@yfactor.f,@mode.l,@density.l} /
;/                                                                             /
;/ Description:                                                                /
;/ Blit an image to the foreground and remember its position the be able to :: /
;/ remove it again with dbl_Unqueue{}.                                         /
;/ NOTE: After you blitted the image it will cause collision until it is rem:: /
;/ oved with dbl_Unqueue. If you dont want it to cause collision you have to:: /
;/  check with dbl_Hit AFTER dbl_Unqueue and BEFORE dbl_QBlit.                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l     : image you want to blit                                      /
;/ - x.l         : x coordinate                                                /
;/ - y.l         : y coordinate                                                /
;/ - factor      : zooming factor (1.0 = same size, 2.0 = double size, 0.5 =:: /
;/ half size                                                                   /
;/ - yfactor.f   : optional y-zooming factor if you want to change the aspect  /
;/ - mode.l      : one of                                                      /
;/     #image_blitmode_opaque  = normal blitting, with bit mask if present     /
;/     #image_blitmode_trans   = transparent blitting acodoring denity         /
;/     #image_blitmode_alpha   = normal blitt with mask & alpha if present     /
;/     #image_blitmode_add     = pixels are added to the background            /
;/     #image_blitmode_sub     = pixels are substracted from the bg            /
;/ - density.l   : 0-256, mix value for trans, alpha, add and sub blitting m:: /
;/ odes                                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST dbl_QBlit {image.l,x.l,y.l,@factor.f,@yfactor.f,@mode.l,@density.l}
 SHARED dblqueue0(),dblqueue1(),imagedat()
 USEPATH dbl

  x+\pf_xoff
  y+\pf_yoff
  If factor<=0 Then factor=1
  If yfactor<=0 Then yfactor=factor
  bltw.l = imagedat(image)\clip_xs;-imagedat(image)\clip_x2+1
  blth.l = imagedat(image)\clip_ys;-imagedat(image)\clip_y2+1
  If factor><1 OR yfactor><1

    xs.l = bltw * factor
    ys.l = blth *yfactor
    CNIF #refresh_mode=#refresh_object
      xscale.l = (#image_scaleres * bltw) / xs
      yscale.l = (#image_scaleres * blth) / ys
      x1.l = x - (imagedat(image)\handle_x*#image_scaleres/xscale)
      y1.l = y - (imagedat(image)\handle_y*#image_scaleres/yscale)
    CEND
    zoom.l = True
  Else
    xs.l = bltw
    ys.l = blth
    CNIF #refresh_mode=#refresh_object
      x1  = x - imagedat(image)\handle_x
      y1  = y - imagedat(image)\handle_y
    CEND
    zoom.l = False
  End If

  CNIF #refresh_mode=#refresh_object
    If \db
     USEPATH dblqueue1()
      If AddItem(dblqueue1())
        \x  = x1
        \y  = y1
        \xs = xs
        \ys = ys
      End If
    Else
     USEPATH dblqueue0()
      If AddItem(dblqueue0())
        \x  = x1
        \y  = y1
        \xs = xs
        \ys = ys
      End If
    End If
   USEPATH dbl ; set it back to the default
  CEND

  If mode = -1 Then If imagedat(image)\alpha_isused Then mode=#image_blitmode_alpha : Else mode = #image_blitmode_opaque
  Select mode
    Case #image_blitmode_opaque
      If zoom
        image_CPUBlitScaled {image,x,y,xs,ys,\rp}
      Else
        CNIF #use_cpublit
          image_CPUBlit {image,x,y,\rp}
        CELSE
          image_BlitMask {image,x,y,\rp}
        CEND
      End If

    Default
      If \scr_depth>8
        image_FancyBlit {image,x,y,xs,ys,\rp,mode,density}
      Else
        If (imagedat(image)\mask_ptr=0) AND imagedat(image)\alpha_isused Then image_InitMask{image,-1,imagedat(image)\mask_tolerance,imagedat(image)\mask_threshold}
        If zoom
          image_CPUBlitScaled{image,x,y,xs,ys,\rp}
        Else
          image_BlitMask {image,x,y,\rp}
        End If
      End If

  End Select
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_QBlitScaled {image.l,x.l,y.l,factor.f,@yfactor.f}               /
;/                                                                             /
;/ Description:                                                                /
;/ * obsolete* (for compatibelity)                                             /
;/ Use dbl_QBlit instead.                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/ - factor.f    : ???                                                         /
;/ - yfactor.f    : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST dbl_QBlitScaled {image.l,x.l,y.l,factor.f,@yfactor.f}
  dbl_QBlit {image.l,x.l,y.l,factor.f,yfactor.f}
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_QPrint {text.s,x.l,y.l,@fgpen.l,@bgpen.l,@align.l,@valign.l}    /
;/                                                                             /
;/ Description:                                                                /
;/ Blit an text to the foreground and remember its position the be able to r:: /
;/ emove it again with dbl_Unqueue{}.                                          /
;/ NOTE: After you blitted the text it will cause collision until it is remo:: /
;/ ved with dbl_Unqueue{}. If you dont want it to cause collision you have t:: /
;/ o check with dbl_Hit{} AFTER dbl_Unqueue{} and BEFORE dbl_QPrint{}.         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - text.s      : text you want to blit                                       /
;/ - x.l         : x coordinate                                                /
;/ - y.l         : y coordinate                                                /
;/ - fgpen.l       : (optional) foreground pen                                 /
;/ - bgpen.l       : (optional) background pen, transparent if left out        /
;/ - align.l       : (optional) -1=left, 0=center,1=right                      /
;/ - valign.l      : (optional) -1=top, 0=baseline,1=bottom                    /
;/                                                                             /
;/ See also:    dbl_QPlot, dbl_QLine, dbl_QBox, dbl_QBlit                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_QPrint {text.s,x.l,y.l,@fgpen.l,@bgpen.l,@align.l,@valign.l}
 SHARED dblqueue0(),dblqueue1(),imagedat()
 USEPATH dbl

  x+\pf_xoff
  y+\pf_yoff

  xs.l = TextLength_ (\rp,&text.s,FLen(text))
  ys.l = \rp\TxHeight
  If align = 0 Then x-xs/2
  If align = 1 Then x-xs
  If valign=-1 Then y + \rp\TxBaseline
  If valign= 1 Then y + \rp\TxBaseline - ys

  CNIF #refresh_mode=#refresh_full
    If fgpen>=0 Then SetAPen_ (\rp),fgpen
    If bgpen>=0 Then SetBPen_ (\rp),bgpen:SetDrMd_ \rp,1:Else SetDrMd_ \rp,0
    Move_ \rp,x,y
    Text_ \rp,&text.s,FLen(text)
  CEND


  CNIF #refresh_mode=#refresh_object
    If fgpen>=0 Then SetAPen_ (\rp),fgpen
    If bgpen>=0 Then SetBPen_ (\rp),bgpen:SetDrMd_ \rp,1:Else SetDrMd_ \rp,0
    If \db
     USEPATH dblqueue1()
      If AddItem(dblqueue1())
        Move_ dbl\rp,x,y
        Text_ dbl\rp,&text.s,FLen(text)
        \x  = x
        \y  = y - dbl\rp\TxBaseline
        \xs = xs
        \ys = ys
      End If
    Else
     USEPATH dblqueue0()
      If AddItem(dblqueue0())
        Move_ dbl\rp,x,y
        Text_ dbl\rp,&text.s,FLen(text)
        \x  = x
        \y  = y - dbl\rp\TxBaseline
        \xs = xs
        \ys = ys
      End If
    End If
   USEPATH dbl ; set it back to default
  CEND
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_BGBlit {image.l,x.l,y.l,@collision.l,@factor.f,@yfactor.f,@mo:: /
;/ de.l,@density.l}                                                            /
;/                                                                             /
;/ Description:                                                                /
;/ Blit an image permanent to the background so that it does not disappear a:: /
;/ fter unqueue.                                                               /
;/ This object will cause collision if collision is True and the collision i:: /
;/ s initialisized.                                                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l     : image you want to blit                                      /
;/ - x.l         : x coordinate                                                /
;/ - y.l         : y coordinate                                                /
;/ - collision.l : optional, cause collision when set True or left out         /
;/ - factor      : zooming factor (1.0 = same size, 2.0 = double size, 0.5 =:: /
;/ half size                                                                   /
;/ - yfactor.f   : optional y-zooming factor if you want to change the aspect  /
;/ - mode.l      : one of                                                      /
;/     #image_blitmode_opaque  = normal blitting, with bit mask if present     /
;/     #image_blitmode_trans   = transparent blitting acodoring denity         /
;/     #image_blitmode_alpha   = normal blitt with mask & alpha if present     /
;/     #image_blitmode_add     = pixels are added to the background            /
;/     #image_blitmode_sub     = pixels are substracted from the bg            /
;/ - density.l   : 0-256, mix value for trans, add and sub blitting modes      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST dbl_BGBlit_deprecated {image.l,x.l,y.l,factor.f,yfactor.f,mode.l,density.l}
 SHARED dblqueue0(),dblqueue1(),imagedat()
 USEPATH dbl

  x+\pf_xoff
  y+\pf_yoff
  If factor<=0 Then factor=1
  If yfactor<=0 Then yfactor=factor
  bltw.l = imagedat(image)\clip_xs;-imagedat(image)\clip_x2+1
  blth.l = imagedat(image)\clip_ys;-imagedat(image)\clip_y2+1
  If factor><1 OR yfactor><1

    xs.l = bltw * factor
    ys.l = blth *yfactor
    CNIF #refresh_mode=#refresh_object
      xscale.l = (#image_scaleres * bltw) / xs
      yscale.l = (#image_scaleres * blth) / ys
      x1.l = x - (imagedat(image)\handle_x*#image_scaleres/xscale)
      y1.l = y - (imagedat(image)\handle_y*#image_scaleres/yscale)
    CEND
    zoom.l = True
  Else
    xs.l = bltw
    ys.l = blth
    CNIF #refresh_mode=#refresh_object
      x1  = x - imagedat(image)\handle_x
      y1  = y - imagedat(image)\handle_y
    CEND
    zoom.l = False
  End If

  If mode = -1 Then If imagedat(image)\alpha_isused Then mode=#image_blitmode_alpha : Else mode = #image_blitmode_opaque
  Select mode
    Case #image_blitmode_opaque
      If zoom
        image_CPUBlitScaled {image,x,y,xs,ys,\rp}
      Else
        CNIF #use_cpublit
          image_CPUBlit {image,x,y,\rp}
        CELSE
          image_BlitMask {image,x,y,\rp}
        CEND
      End If

    Default
      If \scr_depth>8
        image_FancyBlit {image,x,y,xs,ys,\rp,mode,density}
      Else
        If (imagedat(image)\mask_ptr=0) AND imagedat(image)\alpha_isused Then image_InitMask{image,-1,imagedat(image)\mask_tolerance,imagedat(image)\mask_threshold}
        image_BlitMask {image,x,y,\rp}
      End If

  End Select
End Statement


;///////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////
Statement FAST dbl_BGBlit{image.l,x.l,y.l,@collision.l,@factor.f,@yfactor.f,@mode.l,@density.l}
 SHARED imagedat()
 USEPATH dbl

  x+\pf_xoff
  y+\pf_yoff

  If factor<=0 Then factor=1
  If yfactor<=0 Then yfactor=factor
  bltw.l = imagedat(image)\clip_xs;-imagedat(image)\clip_x2+1
  blth.l = imagedat(image)\clip_ys;-imagedat(image)\clip_y2+1
  If factor><1 OR yfactor><1
    xs.l = bltw * factor
    ys.l = blth *yfactor

    CNIF #refresh_mode=#refresh_object
      xscale.l = (#image_scaleres * bltw) / xs
      yscale.l = (#image_scaleres * blth) / ys
      x1.l = x - (imagedat(image)\handle_x*#image_scaleres/xscale)
      y1.l = y - (imagedat(image)\handle_y*#image_scaleres/yscale)
    CEND

    zoom.l = True
  Else
    xs.l = bltw
    ys.l = blth
    CNIF #refresh_mode=#refresh_object
      x1  = x - imagedat(image)\handle_x
      y1  = y - imagedat(image)\handle_y
    CEND
    zoom.l = False
  End If

  If xs<1 OR ys<1 Then Statement Return : error    {"Blitsize<1 !"}

  If mode = -1 Then If imagedat(image)\alpha_isused Then mode=#image_blitmode_alpha : Else mode = #image_blitmode_opaque
  Select mode
    Case #image_blitmode_opaque
      If zoom
        image_CPUBlitScaled {image,x,y,xs,ys,\rp_bg}
        If collision=False AND \rp_col><False Then image_CPUBlitScaled {image,x,y,xs,ys,\rp_col}
        CNIF #refresh_mode=#refresh_object
          image_CPUBlitScaled {image,x,y,xs,ys,\rp_0}
          image_CPUBlitScaled {image,x,y,xs,ys,\rp_1}
        CEND

      Else
        CNIF #use_cpublit
          image_CPUBlit {image,x,y,\rp_bg}
          If collision=False AND \rp_col><False Then image_CPUBlit {image,x,y,\rp_col}
          CNIF #refresh_mode=#refresh_object
            image_CPUBlit {image,x,y,\rp_0}
            image_CPUBlit {image,x,y\rp_1}
          CEND

        CELSE
          image_BlitMask {image,x,y,\rp_bg}
          If collision=False AND \rp_col><False Then image_BlitMask {image,x,y,\rp_col}
          CNIF #refresh_mode=#refresh_object
            image_BlitMask {image,x,y,\rp_0}
            image_BlitMask {image,x,y,\rp_1}
          CEND

        CEND
      End If
    Default
      If \scr_depth>8
        image_FancyBlit {image,x,y,xs,ys,\rp_bg,mode,density}
        If collision=False AND \rp_col><False Then image_FancyBlit {image,x,y,xs,ys,\rp_col,mode,density}
        CNIF #refresh_mode=#refresh_object
          image_FancyBlit {image,x,y,xs,ys,\rp_0,mode,density}
          image_FancyBlit {image,x,y,xs,ys,\rp_1,mode,density}
        CEND
      Else
        image_CPUBlitScaled {image,x,y,xs,ys,\rp_bg}
        If collision=False AND \rp_col><False Then image_CPUBlitScaled{image,x,y,xs,ys,\rp_col}
        CNIF #refresh_mode=#refresh_object
          image_CPUBlitScaled {image,x,y,xs,ys,\rp_0}
          image_CPUBlitScaled {image,x,y,xs,ys,\rp_1}
        CEND

      End If
  End Select

  CNIF #refresh_mode=#refresh_object
    ;dbl_QDamage{x,y,xs,ys}
  CEND
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_BGBox {rgbval.l,x1.l,y1.l,x2.l,y2.l,@collision.l}               /
;/                                                                             /
;/ Description:                                                                /
;/ Draw a uni-color rectangle box into the background.                         /
;/ Note: this function is designed for True/Hi color screens!                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - rgbval.l    : RGB value of the color, e.g. $FF00FF for pink               /
;/ - x1.l    :  x1 coordinate                                                  /
;/ - y1.l    :  y1 coordinate                                                  /
;/ - x2.l    :  x2 coordinate                                                  /
;/ - y2.l    :  y2 coordinate                                                  /
;/ - collision.l: optional, cause collision when set True or left out          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_BGBox24 {rgbval.l,x1.l,y1.l,x2.l,y2.l,@collision.l}
 USEPATH dbl

  If rgbval><\last_rgbval Then dbl_SetPenRGB{\temppen,rgbval} : \last_rgbval = rgbval
  x1+\pf_xoff
  y1+\pf_yoff
  x2+\pf_xoff
  y2+\pf_yoff
  SetAPen_ \rp_bg,\temppen
  RectFill_ \rp_bg,x1,y1,x2,y2
  CNIF #refresh_mode=#refresh_object
    RectFill_ \rp_0,x1,y1,x2,y2
    RectFill_ \rp_1,x1,y1,x2,y2
  CEND
  If collision=False AND \rp_col><False Then RectFill_ \rp_col,x1,y1,x2,y2
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_BGLine {rgbval.l,x1.l,y1.l,x2.l,y2.l,@collision.l}              /
;/                                                                             /
;/ Description:                                                                /
;/ Draw a uni-color line into the background.                                  /
;/ Note: this function is designed for True/Hi color screens!                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - rgbval.l    : RGB value of the color, e.g. $FF00FF for pink               /
;/ - x1.l    :  x1 coordinate                                                  /
;/ - y1.l    :  y1 coordinate                                                  /
;/ - x2.l    :  x2 coordinate                                                  /
;/ - y2.l    :  y2 coordinate                                                  /
;/ - collision.l: optional, cause collision when set True or left out          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_BGLine24 {rgbval.l,x1.l,y1.l,x2.l,y2.l,@collision.l}
 USEPATH dbl

  If rgbval><\last_rgbval Then dbl_SetPenRGB{\temppen,rgbval} : \last_rgbval = rgbval
  x1+\pf_xoff
  y1+\pf_yoff
  x2+\pf_xoff
  y2+\pf_yoff
  SetAPen_ \rp_bg,\temppen
  Move_ \rp_bg,x1,y1
  Draw_ \rp_bg,x2,y2
  CNIF #refresh_mode=#refresh_object
    Move_ \rp_0,x1,y1
    Draw_ \rp_0,x2,y2
    Move_ \rp_1,x1,y1
    Draw_ \rp_1,x2,y2
  CEND
  If collision=False AND \rp_col><False
    Move_ \rp_col,x1,y1
    Draw_ \rp_col,x2,y2
  End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_BGPlot {rgbval.l,x1.l,y1.l,@collision.l}                        /
;/                                                                             /
;/ Description:                                                                /
;/ Draw a uni-color pixel into the background.                                 /
;/ Note: this function is designed for True/Hi color screens!                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - rgbval.l    : RGB value of the color, e.g. $FF00FF for pink               /
;/ - x1.l    :  x1 coordinate                                                  /
;/ - y1.l    :  y1 coordinate                                                  /
;/ - collision.l: optional, cause collision when set True or left out          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_BGPlot24 {rgbval.l,x1.l,y1.l,@collision.l}
 USEPATH dbl

  If rgbval><\last_rgbval Then dbl_SetPenRGB{\temppen,rgbval} : \last_rgbval = rgbval
  x1+\pf_xoff
  y1+\pf_yoff
  SetAPen_ \rp_bg,\temppen
  WritePixel_ \rp_bg,x1,y1
  CNIF #refresh_mode=#refresh_object
    WritePixel_ \rp_0,x1,y1
    WritePixel_ \rp_1,x1,y1
  CEND
  If collision=False AND \rp_col><False
    WritePixel_ \rp_col,x1,y1
  End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_BGBlitPattern {image.l,x.l,y.l,xs.l,ys.l,@xoff.l,@yoff.l,@col:: /
;/ lision.l}                                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Blit an image permanent to the background so that it does not disappear a:: /
;/ fter unqueue.                                                               /
;/ If the size is bigger than the actual image, it is repeated. useful for r:: /
;/ epeating patterns.                                                          /
;/ This object will cause collision if collision is True and the collision i:: /
;/ s initialisized.                                                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l      : image you want to blit                                     /
;/ - x.l          : x coordinate                                                /
;/ - y.l          : y coordinate                                                /
;/ - xs.l         : pixel width                                                /
;/ - ys.l         : pixel height                                               /
;/ - xoff.l       : x offset in source                                         /
;/ - yoff.l       : y offset in source                                         /
;/ - collision.l: optional, cause collision when set True or left out          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST dbl_BGBlitPattern {image.l,x.l,y.l,xs.l,ys.l,@xoff.l,@yoff.l,@collision.l}
 USEPATH dbl

  x+\pf_xoff
  y+\pf_yoff
  image_BlitPattern {image,x,y,xs,ys,xoff,yoff,\rp_bg}
  CNIF #refresh_mode=#refresh_object
    image_BlitPattern {image,x,y,xs,ys,xoff,yoff,\rp_0}
    image_BlitPattern {image,x,y,xs,ys,xoff,yoff,\rp_1}
  CEND
  If collision=False AND \rp_col><False Then image_BlitPattern {image,x,y,xs,ys,xoff,yoff,\rp_col}
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_BGScroll {dx.l,dy.l,@collision.l}                               /
;/                                                                             /
;/ Description:                                                                /
;/ Scroll the background!                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - dx.l         : amount of pixels in x direction                            /
;/ - dy.l         : amount of pixels in y direction                            /
;/ - collision.l    : scroll the collision mask as well                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST dbl_BGScroll {dx.l,dy.l,@collision.l}
 USEPATH dbl

  If dx=0 AND dy=0 Then Statement Return
  ScrollRaster_ \rp_bg,dx,dy,\pf_xoff,\pf_yoff,\pf_xoff+\pf_width-1,\pf_yoff+\pf_height-1
  If collision=False AND \rp_col><False Then ScrollRaster_ \rp_col,dx,dy,\pf_xoff,\pf_yoff,\pf_xoff+\pf_width-1,\pf_yoff+\pf_height-1
  CNIF #refresh_mode=#refresh_object
    dbl_QDamage{\pf_xoff,\pf_yoff,\pf_width,\pf_height}
  CEND
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_BGPrint {text.s,x.l,y.l,@fgpen.l,@bgpen.l,@collision.l,@align:: /
;/ .l,@valign.l}                                                               /
;/                                                                             /
;/ Description:                                                                /
;/ Blit a text permanently to the background.                                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - text.s      : text you want to blit                                       /
;/ - x.l         : x coordinate                                                /
;/ - y.l         : y coordinate                                                /
;/ - fgpen.l       : (optional) foreground pen                                 /
;/ - bgpen.l       : (optional) background pen, transparent if left out        /
;/ - collision.l   : 0 dont cause collision, or -1                             /
;/ - align.l       : (optional) -1=left, 0=center,1=right                      /
;/ - valign.l      : (optional) -1=top, 0=baseline,1=bottom                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dbl_BGPrint {text.s,x.l,y.l,@fgpen.l,@bgpen.l,@collision.l,@align.l,@valign.l}
 USEPATH dbl

  x+\pf_xoff
  y+\pf_yoff

  xs.l = TextLength_ (\rp,&text,Peek.l(&text-4))
  ys.l = \rp\TxHeight
  If align=0 Then x-xs/2
  If align=1 Then x-xs
  If valign=-1 Then y + \rp\TxBaseline
  If valign= 1 Then y + \rp\TxBaseline - ys


  If fgpen>=0 Then SetAPen_ (\rp_bg),fgpen
  If bgpen>=0 Then SetBPen_ (\rp_bg),bgpen : SetDrMd_ \rp_bg,1 : Else SetDrMd_ \rp_bg,0
  Move_ \rp_bg,x,y
  Text_ \rp_bg,&text,Peek.l(&text-4)

  CNIF #refresh_mode=#refresh_object
    If fgpen>=0 Then SetAPen_ (\rp_0),fgpen
    If bgpen>=0 Then SetBPen_ (\rp_0),bgpen : SetDrMd_ \rp_0,1 : Else SetDrMd_ \rp_0,0
    Move_ \rp_0,x,y
    Text_ \rp_0,&text,Peek.l(&text-4)
    If fgpen>=0 Then SetAPen_ (\rp_1),fgpen
    If bgpen>=0 Then SetBPen_ (\rp_1),bgpen : SetDrMd_ \rp_1,1 : Else SetDrMd_ \rp_1,0
    Move_ \rp_1,x,y
    Text_ \rp_1,&text,Peek.l(&text-4)
  CEND

  If collision=False AND \rp_col><False
    If fgpen>=0 Then SetAPen_ (\rp_col),fgpen
    If bgpen>=0 Then SetBPen_ (\rp_col),bgpen : SetDrMd_ \rp_col,1 : Else SetDrMd_ \rp_col,0
    Move_ \rp_col,x,y
    Text_ \rp_col,&text,Peek.l(&text-4)
  End If
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dbl_Unqueue {}                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Remove all objects draw with dbl_QBlit.                                     /
;/ Call this function before you are going to draw the objects on the new ca:: /
;/ lculated positions to remove the objects on the old positions.              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement FAST dbl_Unqueue {}
 SHARED dblqueue0(),dblqueue1()
 USEPATH dbl

  CNIF #use_screenhack
    #hmult = 2
  CELSE
    #hmult = 0
  CEND

  CNIF #refresh_mode=#refresh_object
    If \db
     USEPATH dblqueue1()
      ResetList dblqueue1()
      While NextItemFast(dblqueue1())
        CNIF #use_cpublit
          image_CPUBlitRPRP {dbl\rp_bg  ,\x,\y+(dbl\scr_height*#hmult),dbl\rp,\x,\y,\xs,\ys}
        CELSE
          BltBitMapRastPort_ dbl\bmap_bg,\x,\y+(dbl\scr_height*#hmult),dbl\rp,\x,\y,\xs,\ys,$c0
        CEND
        KillItem dblqueue1()
      Wend
    Else
     USEPATH dblqueue0()
      ResetList dblqueue0()
      While NextItemFast(dblqueue0())
        CNIF #use_cpublit
          image_CPUBlitRPRP {dbl\rp_bg  ,\x,\y+(dbl\scr_height*#hmult),dbl\rp,\x,\y,\xs,\ys}
        CELSE
          BltBitMapRastPort_ dbl\bmap_bg,\x,\y+(dbl\scr_height*#hmult),dbl\rp,\x,\y,\xs,\ys,$c0
        CEND
        KillItem dblqueue0()
      Wend
    End If
   USEPATH dbl ; set it back to default
  CEND

  CNIF #refresh_mode=#refresh_full
    CNIF #use_cpublit
      image_CPUBlitRPRP {\rp_bg  ,0,(\scr_height*#hmult),\rp,0,0,\scr_width,\scr_height }
    CELSE
      BltBitMapRastPort_ \bmap_bg,0,(\scr_height*#hmult),\rp,0,0,\scr_width,\scr_height,$c0
    CEND
  CEND
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = dbl_InitCollision {}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Creates a bitmap with data that should not cause collision for use with d:: /
;/ bl_tst{} later. Usually you do it like this:                                /
;/ - draw the objects that should NOT cause collision, then                    /
;/ - call dbl_InitCollision{}, and then                                        /
;/ - draw objects (like walls) that should cause collision.                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l    : True if collision bitmap was successfully created             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dbl_InitCollision {}
 SHARED imagedat(),imageengine
 USEPATH dbl

  dbl_FreeCollision {}
  succ.l = False
  \bmap_col=AllocBitMap_ (\scr_width,\scr_height,\scr_depth,#BMF_MINPLANES,\bmap_bg)
  If \bmap_col
    \layerinfo_col = NewLayerInfo_
    If \layerinfo_col
      \layer_col    =  CreateUpfrontHookLayer_ (\layerinfo_col,\bmap_col,0,0,\scr_width-1,\scr_height-1,0,#LAYERS_NOBACKFILL,0)
      If \layer_col
        \rp_col = \layer_col\rp
         succ = True
      Else
        error{"\\__THIS_FUNCTION: Unable to create upfront layer!"}
      End If
    Else
      error{"\\__THIS_FUNCTION : Unable to allocate LayerInfo!"}
    End If
    BltBitMapRastPort_ \bmap_bg,0,\scr_height*#hmult,\rp_col,0,0,\scr_width,\scr_height,$c0
  Else
    error{"\\__THIS_FUNCTION: Unable to create collision bitmap!"}
  End If
  If succ = False Then dbl_FreeCollision {}

 Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l =  dbl_Hit {x.l,y.l}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ Test if there the color at the given x/y coos has changed compared to the:: /
;/  time when dbl_InitCollision{}  was called (which is usualy after you hav:: /
;/ e created your non-collision background).                                   /
;/ You go like this:                                                           /
;/ 1. Create your non-colision background with dbl_BGBlit, dbl_BGBlitPattern   /
;/ 2. Call dbl_collision_init                                                  /
;/ 3. Blit your walls that cause collision with dbl_BGBlit                     /
;/ 4. Ask with dbl_Hit{x,y} in the gameplay loop for collision                 /
;/ If you have no walls, simply dont call dbl_collision_init  to save some m:: /
;/ emory.                                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - x.l       : x coordinate to check                                         /
;/ - y.l       : y coordinate to check                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l    : True if the color has changed, False if not                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST dbl_Hit {x.l,y.l}
 USEPATH dbl

  x+\pf_xoff
  y+\pf_yoff

  succ.l = False
  If \rp_col
    If x>=0 AND y>=0 AND x<\scr_width AND y<\scr_height
      If GetBitMapAttr_(\bmap,#BMA_DEPTH)>8
        If ReadRGBPixel_(\rp,x,y)><ReadRGBPixel_(\rp_col,x,y) Then succ=True : Else succ=False
      Else
        If ReadPixel_   (\rp,x,y)><ReadPixel_   (\rp_col,x,y) Then succ=True : Else succ=False
      End If
    End If
  Else
    If x>=0 AND y>=0 AND x<\scr_width AND y<\scr_height
      If GetBitMapAttr_(\bmap,#BMA_DEPTH)>8
        If ReadRGBPixel_(\rp,x,y)><ReadRGBPixel_(\rp_bg,x,y) Then succ=True : Else succ=False
      Else
        If ReadPixel_   (\rp,x,y)><ReadPixel_   (\rp_bg,x,y) Then succ=True : Else succ=False
      End If
    End If
  End If

 Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l =  dbl_2ImgHit {image1.l,x1.l,y1.l,image2.l,x2.l,y2.l}      /
;/                                                                             /
;/ Description:                                                                /
;/ Test if image1 and image2 would hit (=do a collision) at the given coos.    /
;/ The collision detection is based on their rectangle boundaries, but very :: /
;/ fast.                                                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image1.l  : image object number                                           /
;/ - x1.l      : x coordinate of image1                                        /
;/ - y1.l      : y coordinate of image1                                        /
;/ - image2.l  : image object number                                           /
;/ - x2.l      : x coordinate of image2                                        /
;/ - y2.l      : y coordinate of image2                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l    : True if they collide, False if not                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST dbl_2ImgHit {image1.l,x1.l,y1.l,image2.l,x2.l,y2.l}
 SHARED imagedat()

  If image2<>-1
    x1 = x1-imagedat(image1)\handle_x
    x2 = x2-imagedat(image2)\handle_x
    y1 = y1-imagedat(image1)\handle_y
    y2 = y2-imagedat(image2)\handle_y
   Function Return RectsHit(x1,y1,imagedat(image1)\img_width,imagedat(image1)\img_height,x2,y2,imagedat(image2)\img_width,imagedat(image2)\img_height)
  Else
    x1 = x1-imagedat(image1)\handle_x
    y1 = y1-imagedat(image1)\handle_y
   Function Return RectsHit(x1,y1,imagedat(image1)\img_width,imagedat(image1)\img_height,x2,y2,2,2)
  End If
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l =  dbl_ImgMaskHit {image.l,x.l,y.l,tstx.l,tsty.l}           /
;/                                                                             /
;/ Description:                                                                /
;/ Test if the image bit mask would hit at tstx.l/tsty.l if the image would :: /
;/ be at x.l/y.l                                                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image object number                                          /
;/ - x.l        : x coordinate of image                                        /
;/ - y.l        : y coordinate of image                                        /
;/ - tstx.l     : x coordinate of test point                                   /
;/ - tsty.l     : y coordinate of test point                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l    : True if collide, False if not                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST dbl_ImgMaskHit {image.l,x.l,y.l,tstx.l,tsty.l}
SHARED imagedat()

 Function Return image_MaskHit {image,tstx-x-imagedat(image)\handle_x,tsty-y-imagedat(image)\handle_y}
End Function



; internal Demo
.internal_Demo:
CNIF #__include=0
  XINCLUDE "intuition.include.ab3"

  NEWTYPE.ball
    x.f:y.f:xs.f:ys.f
  End NEWTYPE

  Dim List ball.ball(0)
  If AddItem(ball()) Then  ball()\x=  0,200,1,-2
  If AddItem(ball()) Then  ball()\x=  0,200,2,-1
  If AddItem(ball()) Then  ball()\x=  0,200,1.5,-1.5

  gfxpath.s = "/Data/"
  succ.l = image_Load {2,gfxpath.s+"glass_big",$FF00FF,20}  : image_MidHandle {2}
  succ.l = image_Load {1,gfxpath.s+"pattern"}
  image_FreeAlpha{2}

  ;succ   & dbl_Init {"MyGame",#dbl_scr_ASL,640,480,16}
  ;succ   & dbl_Init {"MyGame",-1,640,480,16}
  succ   & dbl_Init {"MyGame",#dbl_scr_WB}
  doscroll.f = 2.0
  If succ
  ;  dbl_SetFPS{#dbl_fps_free}
  ;  dbl_SetFPS{#dbl_fps_vbeam}
    dbl_SetFPS{#dbl_fps_vblank}
  ;  dbl_SetFPS{#dbl_fps_monitor}
  ;  dbl_SetFPS{61}
    dbl_BGBlitPattern{1,0,0,!dbl_GetWidth,!dbl_GetHeight}
    Repeat
      dbl_Flip{}
      dbl_Unqueue{}

      ; move balls
      ResetList ball()
      While NextItemFast(ball())
        ball()\ys + 0.1
        ball()\x+ball()\xs
        ball()\y+ball()\ys
        If ball()\x<0 OR ball()\x>!dbl_GetWidth  Then ball()\xs=-ball()\xs : ball()\x+ball()\xs
        If ball()\y<0 OR ball()\y>!dbl_GetHeight Then ball()\ys=-ball()\ys : ball()\y+ball()\ys
        dbl_QBlit {2,ball()\x,ball()\y}     ;draw ball
      Wend


      ; calculate how we want to scroll in a wired way
      rx.f + 0.003
      sxv.l = Sin(rx) * doscroll
      syv.l = Cos(rx) * doscroll
      scroll_x.l - sxv
      scroll_y.l - syv

      ; acutally scroll the playfield sxv/syv pixels
      If sxv><0 OR syv><0
      dbl_BGScroll {sxv,syv,False}


      ; fill the new scrolled-in areas with background pattern
      If sxv<0 ; we scrolled right ?
        dbl_BGBlitPattern{1,0,0,-sxv,!dbl_GetPFHeight,scroll_x,scroll_y,False}
      Else     ; we scrolled left !
        If sxv>0 Then dbl_BGBlitPattern{1,!dbl_GetPFWidth-sxv,0,sxv,!dbl_GetPFHeight,scroll_x,scroll_y,False}
      End If
      If syv<0 ; we scrolled down?
        dbl_BGBlitPattern{1,0,0,!dbl_GetPFWidth,-syv,scroll_x,scroll_y,False}
      Else     ; we scrolled up !
        If syv>0 Then dbl_BGBlitPattern{1,0,!dbl_GetPFHeight-syv,!dbl_GetPFWidth,syv,scroll_x,scroll_y,False}
      End If
      End If
      fps.f =  dbl_GetFPS{1000}

      Format "##0.0"
      a.s  = Str$(fps)
      Format ""
      dbl_QPrint {"FPS: "+a.s,10,10,2}  ; Print a text for 1 frame

    Until Event=#IDCMP_RAWKEY
  End If
  End
CEND

