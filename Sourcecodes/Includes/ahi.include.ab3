; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "/Bin"
; ExeFile         = "AHIDemo"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 2024
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 549
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 7
; CursorColumn    = 77
; LabelSearch     = "str"
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 2
; Max GadgetList  = 5
; Max Queue       = 1
; Max Screen      = 2
; Max Shape       = 2
; Max CopList     = 1
; Max Sprite      = 1
; Max Stencil     = 1
; Max Module      = 1
; Max Window      = 2
; Max Anim        = 1
; Max Sound       = 1
; Max Bank        = 1
; Max Buffer      = 1
; Max BitMap      = 1
; Max Slice       = 1
; Max Page        = 4
; Max Tape        = 1
; Max IntuiFont   = 1
; Max MedModule   = 1
; Max Palette     = 1
; Max MenuList    = 1
; Max BlitzFont   = 1
; Max GTList      = 5
; Max ChunkyBuffer= 2
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: ahi_device.include                                                    /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 11.03.2006                                                            /
;/                                                                             /
;/ Author: Thilo Koehler                                                       /
;/                                                                             /
;/ Requirements: AHI v4+, Amiblitz2.4                                          /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Replace most sound commands of BlitzBasic with AHI compatible ones          /
;/ and add some new functionality like streaming.                              /
;/                                                                             /
;/ Abstract:                                                                   /
;/ This include provides a lot of commands to play single sounds via AHI sys:: /
;/ tem as well as streaming from disk. It also supports recording audio via :: /
;/ AHI.                                                                        /
;/                                                                             /
;/ The standard usage is to load some sounds using ahi_LoadSound, open the a:: /
;/ hi.device using ahi_OpenDevice, and then play the sounds using ahi_PlaySo:: /
;/ und.                                                                        /
;/ The "sounds" are called Sound Objects, because they can be seen like Blit:: /
;/ zBasic Objects.                                                             /
;/                                                                             /
;/ Streaming is initiated by ahi_OpenStream. The stream will start the first:: /
;/  time you call ahi_DoStream. You have to call this function in regular in:: /
;/ tervals, fast enough to not get buffer underruns.                           /
;/ You can wait for new buffers using the ahi_GetOutSiglfag in your Wait_() :: /
;/ command, or simply call it every frame in your gameloop. Streams can also:: /
;/  be looped and faded.                                                       /
;/                                                                             /
;/ The include support .aiff, .wav, .8svx, .maud, .mp3, .mp2 and .cdda files:: /
;/  (such as created by MakeCD).                                               /
;/                                                                             /
;/ User Constants:                                                             /
;/ #max_ahisounds   = 100                                                      /
;/ Number of samples (Sound Objects) you are going to use, replaces the soun:: /
;/ d BB2 Object                                                                /
;/                                                                             /
;/ #max_ahichannels = 32                                                       /
;/ Number of simultaneous channels you need, Paula had 4 channels, we can ha:: /
;/ ve more...                                                                  /
;/ Remember that the user has to set this amount of channels in the AHI pref:: /
;/ erences, otherwise it will work but they are cutted faster of.              /
;/                                                                             /
;/ #max_ahistreams = 4                                                         /
;/ Number of streams you can play simultaniously.                              /
;/                                                                             /
;/ Example:                                                                    /
;/ Just load and play a sound !                                                /
;/ __________________________________________________________________ snip!    /
;/                                                                             /
;/ #max_ahisounds = 5                                                          /
;/ #max_ahichannels = 4                                                        /
;/ XINCLUDE "ahi.include.ab3"                                                  /
;/                                                                             /
;/ If ahi_OpenDevice{0}  ; open ahi.device unit 0                              /
;/   If ahi_LoadSound0,"DH0:MySound.wav"}                                      /
;/     ahi_PlaySound{0}                 ; play the sound!                      /
;/   End If                                                                    /
;/ End If                                                                      /
;/ End                                                                         /
;/ __________________________________________________________________ snip!    /
;/                                                                             /
;/ Play a stream from disk:                                                    /
;/ __________________________________________________________________ snip!    /
;/                                                                             /
;/ XINCLUDE "ahi.include.ab3"                                                  /
;/                                                                             /
;/ If ahi_OpenDevice{0} ; open ahi.device unit 0                               /
;/   If ahi_OpenStream{filename.s,1000} ; 1000ms buffer                        /
;/     While ahi_DoStream{}                                                    /
;/       ahi_WaitStream{} ; or do somehing meaningful here                     /
;/     Wend                                                                    /
;/     ahi_WaitStreamFinish{}                                                  /
;/   End If                                                                    /
;/ End If                                                                      /
;/ End                                                                         /
;/ __________________________________________________________________ snip!    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
CNIF @#max_ahisounds=0
#max_ahisounds   = 100  ; number of samples you are going to use, replaces the sound BB2 Object
CEND

CNIF @#max_ahichannels=0
#max_ahichannels = 32   ; number of simultaneous channels you need, Paula had 4 channels, we can have more...
CEND

CNIF @#max_ahistreams=0
#max_ahistreams = 4   ; number of simultaneous streams you need...
CEND

;%Code
CNIF #__include=0
SYNTAX 2
OPTIMIZE 7
CEND

XINCLUDE "file_audio.include.ab3"

#AHIST_NOTYPE       =-1
#AHIST_SAMPLE       = 0
#AHIST_DYNAMICSAMPLE= 1
#AHIST_INPUT        = $20000000
#AHIST_BW           = $40000000

#AHIST_M8S  = 0     ;  8 mono signed
#AHIST_M16S = 1     ; 16 mono signed
#AHIST_S8S  = 2     ;
#AHIST_S16S = 3
#AHIST_M32S = 8
#AHIST_S32S =10
#AHIST_M8U  = 4

.AHI_NEWTYPES
NEWTYPE.AHIrequest
StdIO.IOStdReq
version.w
pad1.w
private1.l
private2.l
type_.l
frequency.l
volume_.l
position.l
link_.l
End NEWTYPE

NEWTYPE.ahi_buffer
IORequest.l
ptr.l
size.l
fsize.l
rsize.l
busy.w
End NEWTYPE

NEWTYPE.ahi_stream
fid.l
offset.l
flength.l
loop_start.l
loop_end.l
filename.s
fade_pos.l
fade_length.l
fade_startgain.l
fade_endgain.l
End NEWTYPE

NEWTYPE.ahi_unit
is_open.w
device_base.l
nextchannel.l
msgport.l
out_actual.w
samplerate.l
sigflag.l
sampleformat.l
framesize.w
channels.w
bits.w
gain.w
timeindex_base.l
running.w
out_buffer.ahi_buffer [2]
temp_buffer.l
stream_count.l
visual_smoothness.l
visual_square.l
visual_norm.l
out_v_peakl.l
out_v_peakr.l
out_v_lpos.l
out_v_lbuffer.l
visual_last.l
in_buffer.ahi_buffer [1]
rec_timeindex_base.l
rec_running.l
rec_samplerate.l
rec_sampleformat.l
End NEWTYPE

NEWTYPE.ahi_sound
is_used.l
memptr.l
blength.l
samplerate.l
gain.l
pan.l
bits.l
channels.l
sampleform.l
End NEWTYPE

NEWTYPE.ahi_channel
IORequest.l
running.l
snd.l
End NEWTYPE


.AHI_GLOBALS
DEFTYPE.ahi_unit   ahi_unit
Dim ahi_sound.ahi_sound(#max_ahisounds-1)
Dim ahi_channel.ahi_channel(#max_ahichannels-1)
Dim ahi_stream.ahi_stream(#max_ahistreams-1)

;SHARED ahi_unit.ahi_unit
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = _ahi_Init {}                                             /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ahi_Init{}
SHARED ahi_channel(),ahi_stream()
For n.l=0 To #max_ahichannels-1
  ahi_channel(n)\running=False
  ahi_channel(n)\snd       =-1
Next

For n.l=0 To #max_ahistreams-1
  ahi_stream(n)\fid=-1
Next
Function Return True
End Function

_ahi_Init{}


USEPATH ahi_unit
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  samps.l = ahi_Bytes2Samps {bytes.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Return the number of sampleframes for the given number of bytes.            /
;/ Teh function uses therefore the currently opened AHI unit.                  /
;/ The ahi.device must be successfully opened before using AHI_open.           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - bytes.l    : Number of bytes                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - samps.l    : Number of sampleframes                                       /
;/                                                                             /
;/ Example:                                                -                   /
;/                                                                             /
;/ Bugs:        none                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_Bytes2Samps{bytes.l}
SHARED ahi_unit
If \is_open
  samps.l = bytes/\framesize
Else
  error{"\\__THIS_FUNCTION: ahi.device is not open!"}
End If
Function Return samps
End Function


Function.l ahi_Samps2Bytes{samps.l}
SHARED ahi_unit
If \is_open
  bytes.l = samps * \framesize
Else
  error{"\\__THIS_FUNCTION: ahi.device is not open!"}
End If
Function Return bytes
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  AHI_form.l = ahi_GetSampleForm {channels.w,bits.w,signed.w}        /
;/                                                                             /
;/ Description:                                                                /
;/ Return the AHI sampleformat code for the given audio specs.                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - channels.w  : number of channels, 1 (=mono) or 2 (=stereo)                /
;/ - bits.w      : number of bits (8 or 16)                                    /
;/ - signed.w    : True or False, wether it is signed or unsigned (usually s:: /
;/ igned)                                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - AHI_form.l  : AHI specific id number that characterizes the sample format /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_GetSampleForm{channels.w,bits.w,signed.w}
ahi_form.l = #AHIST_NOTYPE
If signed
  If channels=1
    If bits =  8 Then ahi_form=#AHIST_M8S
    If bits = 16 Then ahi_form=#AHIST_M16S
  End If
  If channels=2
    If bits =  8 Then ahi_form=#AHIST_S8S
    If bits = 16 Then ahi_form=#AHIST_S16S
  End If
Else
  If channels=1
    If bits = 8 Then ahi_form=#AHIST_M8U
  End If
End If
Function Return ahi_form
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ahi_GetSamplerate {}                                    /
;/                                                                             /
;/ Description:                                                                /
;/ Get the samplerate at that the ahi.device is running right now.             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : samplerate in Hz                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_GetSamplerate{}
SHARED ahi_unit
Function Return ahi_unit\samplerate
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ahi_IsOpen {}                                           /
;/                                                                             /
;/ Description:                                                                /
;/ Check if the ahi.device was opened using ahi_OpenDevice.                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if ahi.device is open, 0 otherwise                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_IsOpen{}
SHARED ahi_unit
Function Return ahi_unit\is_open
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  buffer.l = ahi_GetOutBufferNum {}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Return the number of the audio double buffer that has to be filled next, :: /
;/ after ahi_CheckOutBuffer returned success.                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - buffer.l     : number of the audio buffer to be filled next               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_GetOutBufferNum{}
SHARED ahi_unit
If \is_open Then nextbuffer.l = 1-\out_actual :Else error{"\\__THIS_FUNCTION: ahi.device is not open!"}:nextbuffer.l=0
Function Return nextbuffer
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  ptr.l = ahi_GetOutBufferPtr {}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Return the memory pointer to the audio double buffer that has to be fille:: /
;/ d next, after ahi_CheckOutBuffer returned success.                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - ptr.l     : memory pointer to the audio buffer data                       /
;/                                                                             /
;/ See also:    ahi_CheckOutBuffer                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_GetOutBufferPtr{}
SHARED ahi_unit
ptr.l = False
If \is_open
  nextbuffer.l = ahi_GetOutBufferNum{}
  ptr.l  = \out_buffer[nextbuffer]\ptr
Else
  error{"\\__THIS_FUNCTION: ahi.device is not open!"}
End If
Function Return ptr
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  bsize.l = ahi_GetOutBufferByteSize {}                              /
;/                                                                             /
;/ Description:                                                                /
;/ Return the size in bytes of the audio double buffer that has to be filled:: /
;/  next, after ahi_CheckOutBuffer returned success.                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - bsize.l     : size in bytes of the audio buffer                           /
;/                                                                             /
;/ See also:    ahi_CheckOutBuffer, ahi_GetOutBufferFrameSize                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_GetOutBufferByteSize{}
SHARED ahi_unit
If \is_open
  nextbuffer.l = ahi_GetOutBufferNum{}
  nsize.l = \out_buffer[nextbuffer]\size
Else
  error{"\\__THIS_FUNCTION: ahi.device is not open!"}:nsize.l=0
End If
Function Return nsize
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  fsize.l = ahi_GetOutBufferFrameSize {}                             /
;/                                                                             /
;/ Description:                                                                /
;/ Return the size in sampleframes of the audio double buffer that has to be:: /
;/  filled next, after ahi_CheckOutBuffer returned success.                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - fsize.l     : size of the buffer in sampleframes                          /
;/                                                                             /
;/ See also:    ahi_CheckOutBuffer, ahi_GetOutBufferPtr, ahi_GetOutBufferByt:: /
;/ eSize                                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_GetOutBufferFrameSize{}
SHARED ahi_unit
If \is_open
  nextbuffer.l = ahi_GetOutBufferNum{}
  nsize.l = \out_buffer[nextbuffer]\fsize
Else
  error{"\\__THIS_FUNCTION: ahi.device is not open!"}:nsize.l=0
End If
Function Return nsize
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  timeindex.l =  ahi_GetOutTimeindex {}                              /
;/                                                                             /
;/ Description:                                                                /
;/ Return the number of samples that have been played yet in double bufferin:: /
;/ g. It is not very accurate but better than nothing.                         /
;/ You can reset the counter using ahi_SetOutTimeindex.                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - timeindex.l     : counter in samples                                      /
;/                                                                             /
;/ See also:    ahi_SetOutTimeindex                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST ahi_GetOutTimeindex{}
SHARED ahi_unit
If \is_open
  If \running
    *AHIIO.AHIrequest = \out_buffer[\out_actual]\IORequest
    offset.l = *AHIIO\StdIO\io_Actual ;/ \framesize
    If offset>\out_buffer[\out_actual]\fsize Then offset = 0
    timeindex.l = \timeindex_base + offset
  Else
    timeindex   = \timeindex_base
  End If
End If
Function Return timeindex
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l =  ahi_GetRecTimeindex {}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Get the timeindex since ahi_InitRec.                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : timeindex in sampleframes                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l FAST ahi_GetRecTimeindex{}
SHARED ahi_unit
If \is_open
  If \rec_running
    *AHIIO.AHIrequest = \in_buffer[0]\IORequest
    offset.l = *AHIIO\StdIO\io_Actual ;/ \framesize
    If offset>\in_buffer[0]\fsize Then offset = 0
    timeindex.l       = \rec_timeindex_base + offset
  Else
    timeindex         = \rec_timeindex_base
  End If
End If
Function Return timeindex
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_SetOutTimeindex {timeindex.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Set the timeindex for doublebuffering to the given value.                   /
;/ This can also be done during playback. The timeindex is just a counter fo:: /
;/ r the already played samples. It will not cause the stream to jump.         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - timeindex.l    : counter in samples                                       /
;/                                                                             /
;/ See also:    ahi_GetOutTimeindex                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_SetOutTimeindex{timeindex.l}
SHARED ahi_unit
If \is_open
  If \running
    *AHIIO.AHIrequest = \out_buffer[\out_actual]\IORequest
    offset.l = *AHIIO\StdIO\io_Actual
    If offset>\out_buffer[\out_actual]\fsize Then offset = \out_buffer[\out_actual]\fsize
    \timeindex_base = timeindex - offset
  Else
    \timeindex_base = timeindex
  End If
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_WaitOut {}                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Wait till there is an audio double buffer ready to fill. You can call ahi:: /
;/ _GetNext??? functions after this function returned.                    /
;/ It is the same like calling ahi_stream_check until it returns success.      /
;/                                                                             /
;/ See also:    ahi_CheckOutBuffer, ahi_GetOutBufferPtr                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_WaitOut{}
SHARED ahi_unit
If \is_open
  If \out_buffer[\out_actual]\busy = True
    WaitIO_ \out_buffer[\out_actual]\IORequest
    \out_buffer[\out_actual]\busy = False
    \timeindex_base + \out_buffer[\out_actual]\rsize/ \framesize ;ahi_Bytes2Samps{\out_buffer[\out_actual]\rsize}
  End If
  \out_actual=1-\out_actual
Else
  error{"\\__THIS_FUNCTION: ahi.device is not open!"}
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ahi_CheckOutBuffer {}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Check if there is an audio buffer to fill and retrun -1 if successful, 0 :: /
;/ otherwise. You need this function only, if you want to fill the buffers w:: /
;/ ith your own rendered data. If you just open an audiofile using ahi_OpenS:: /
;/ tream, calling ahi_DoStream is enough.                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : -1 if there is an empty buffer waiting, or 0 if all buffer:: /
;/ s are still full                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_CheckOutBuffer{}
SHARED ahi_unit
If \is_open
  succ.l = True
  If \out_buffer[\out_actual]\busy = True
    If CheckIO_(\out_buffer[\out_actual]\IORequest) ><0
      WaitIO_ \out_buffer[\out_actual]\IORequest
      \out_buffer[\out_actual]\busy = False
      \timeindex_base + \out_buffer[\out_actual]\rsize/ \framesize ;ahi_Bytes2Samps{\out_buffer[\out_actual]\rsize}
      \out_actual = 1-\out_actual
      succ=True
    Else
      succ=False
    End If
  Else
    \out_actual = 1-\out_actual
  End If
Else
  error{"\\__THIS_FUNCTION: ahi.device is not open!"}
  succ = False
End If
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_WaitOutFinish {}                                                /
;/                                                                             /
;/ Description:                                                                /
;/ Wait till all pending double buffers are finished.                          /
;/ After this functions returned, you can call ahi_CloseStream safely withou:: /
;/ t stopping a buffer while it is still playing.                              /
;/                                                                             /
;/ See also:    ahi_InitOut, ahi_CloseAllStreams                               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_WaitOutFinish{}
SHARED ahi_unit
If \is_open
  ahi_WaitOut{}
  ahi_WaitOut{}
Else
  error{"\\__THIS_FUNCTION: ahi.device is not open!"}
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ahi_IsOutQuiet {}                                         /
;/                                                                             /
;/ Description:                                                                /
;/ Check if something is playing on the stream or not.                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : -1 if nothing is playing, 0 otherwise                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_IsOutQuiet{}
SHARED ahi_unit
If \is_open
  If \out_buffer[0]\busy = False AND \out_buffer[1]\busy = False Then succ.l = True:Else succ = False
Else
  error{"\\__THIS_FUNCTION: ahi.device is not open!"}
End If
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ahi_WriteOutBuffer {@blength.l}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Start the next buffer to play. If there is already another buffer playing:: /
;/  this one will be queued.                                                   /
;/ blength is optional and determines the number of bytes that should be pla:: /
;/ yed, e.g. if you did not fill the complete buffer, you want only a part o:: /
;/ f it to be played.                                                          /
;/ If you leave this out the whole buffer will be played.                      /
;/ Note: call this function after ahi_CheckOutBuffer returned True.            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - blength.l    : number of bytes to play, default is the whole buffer       /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : -1 if everything went well, 0 if it failed (normally this :: /
;/ does not happen)                                                            /
;/                                                                             /
;/ See also:    ahi_CheckOutBuffer, ahi_GetOutBufferPtr                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_WriteOutBuffer{@blength.l}
SHARED ahi_unit
succ.l=False
If \is_open
  nextbuffer.l = ahi_GetOutBufferNum{}
  prevbuffer.l = 1 - nextbuffer
  If \out_buffer[nextbuffer]\busy = False
;    If blength <=0 Then blength=\out_buffer[nextbuffer]\size
    If blength<=-1 OR blength>\out_buffer[nextbuffer]\size Then blength=\out_buffer[nextbuffer]\size
    *AHIIO.AHIrequest      = \out_buffer[nextbuffer]\IORequest
    *AHIIO\StdIO\io_Data   = \out_buffer[nextbuffer]\ptr
    *AHIIO\StdIO\io_Length = blength
    If \running=True
      *AHIIO\link_ = \out_buffer[prevbuffer]\IORequest
    Else
      *AHIIO\link_ = 0:\running = True
    End If
    If SendIO_(*AHIIO) < 0
      error{"\\__THIS_FUNCTION: Can`t send data to device! - "+Str$(*AHIIO\StdIO\io_Error)+" Played: "+Str$(*AHIIO\StdIO\io_Actual)}
      \out_buffer[nextbuffer]\busy = False
    Else
      \out_buffer[nextbuffer]\busy = True
      \out_buffer[nextbuffer]\rsize = blength
      succ = True
    End If
  Else
    error{"\\__THIS_FUNCTION: Buffer was still busy!"}
  End If
Else
  error{"\\__THIS_FUNCTION: ahi.device is not open!"}
End If
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_FreeOut {}                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Free a stream created using ahi_stream_init. It is save to call this func:: /
;/ tion twice, or if no stream was initiated.                                  /
;/ Use ahi_CloseStream, if you created the stream using ahi_OpenStream.        /
;/ Note: you can always use ahi_CloseAllStreams.                               /
;/                                                                             /
;/ See also:    ahi_InitOut, ahi_CloseAllStreams                               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_FreeOut{}
SHARED ahi_unit

\timeindex_base = 0;ahi_stream_GetTimeindex{}
If \out_buffer[0]\IORequest
  If \out_buffer[0]\busy Then AbortIO_ \out_buffer[0]\IORequest:WaitIO_ \out_buffer[0]\IORequest:\out_buffer[0]\busy=False
End If
If \out_buffer[1]\IORequest
  If \out_buffer[1]\busy Then AbortIO_ \out_buffer[1]\IORequest:WaitIO_ \out_buffer[1]\IORequest:\out_buffer[1]\busy=False
End If
\running        = False
\out_actual     = 0
If \temp_buffer Then FreeVec_ \temp_buffer : \temp_buffer= 0
If \out_buffer[0]\ptr Then FreeMem_ \out_buffer[0]\ptr,\out_buffer[0]\size :\out_buffer[0]\ptr = False:\out_buffer[0]\size = 0
If \out_buffer[1]\ptr Then FreeMem_ \out_buffer[1]\ptr,\out_buffer[1]\size :\out_buffer[1]\ptr = False:\out_buffer[1]\size = 0

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_CloseStream {@stream.l}                                         /
;/                                                                             /
;/ Description:                                                                /
;/ Stop and close a stream. It is save to call this function twice, or if no:: /
;/  stream is playing.                                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - stream.l    : ???                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_CloseStream{@stream.l}
SHARED ahi_unit,ahi_stream()
If stream<0 Then stream=0
If ahi_stream(stream)\fid>=0 Then ffa_Close{ahi_stream(stream)\fid} : \stream_count-1
ahi_stream(stream)\fid=-1
ahi_stream(stream)\filename = ""
If \stream_count<=0 Then ahi_FreeOut{} : \stream_count=0
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_StopRec {}                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Stop recording.                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_StopRec{}
SHARED ahi_unit,ahi_channel()
If \is_open
  \rec_timeindex_base = ahi_GetRecTimeindex{}
  If \in_buffer[0]\busy Then AbortIO_ \in_buffer[0]\IORequest:WaitIO_ \in_buffer[0]\IORequest:\in_buffer[0]\busy=False
  \rec_running        = False
End If
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_Stop {}                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ Stop all ahi activity immediately, stream, one shot sounds and recording.   /
;/ This function is called within ahi_CloseDevice, to make sure that no soun:: /
;/ d is playing anymore before freeing the resources.                          /
;/                                                                             /
;/ See also:    ahi_IsOutQuiet, ahi_StopSound, ahi_StopRec                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_Stop{}
SHARED ahi_unit,ahi_channel()
If \is_open
  \timeindex_base = ahi_GetOutTimeindex{}
  If \out_buffer[0]\busy Then AbortIO_ \out_buffer[0]\IORequest:WaitIO_ \out_buffer[0]\IORequest:\out_buffer[0]\busy=False
  If \out_buffer[1]\busy Then AbortIO_ \out_buffer[1]\IORequest:WaitIO_ \out_buffer[1]\IORequest:\out_buffer[1]\busy=False
  ahi_StopRec{}
  \running        = False
  \out_actual     = 0
  For n.l = 0 To #max_ahichannels-1
    If ahi_channel(n)\running Then AbortIO_ ahi_channel(n)\IORequest:WaitIO_ ahi_channel(n)\IORequest : ahi_channel(n)\running = False
  Next
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_StopSound {snd.l}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ Stop the given Sound Object immediately, if it is currently playing.        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - snd.l    : Sound Object number                                            /
;/                                                                             /
;/ See also:    ahi_Stop                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_StopSound{snd.l}
SHARED ahi_unit,ahi_channel()
If \is_open
  For n.l = 0 To #max_ahichannels-1
    If ahi_channel(n)\running
      If ahi_channel(n)\snd = snd
        AbortIO_ ahi_channel(n)\IORequest
        WaitIO_ ahi_channel(n)\IORequest
        ahi_channel(n)\running = False
        ahi_channel(n)\snd=-1
      End If
    End If
  Next
End If
End Statement


USEPATH ahi_sound(snd)
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_FreeSound {snd.l}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ Free the given Sound Object.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - snd.l    : Sound Object number to free                                    /
;/                                                                             /
;/ See also:    ahi_LoadSound, ahi_CreateSound                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_FreeSound{snd.l}
SHARED ahi_sound()
If snd>=0 AND snd<#max_ahisounds
  If \is_used Then ahi_StopSound{snd}
  \is_used = False
  If \memptr Then FreeVec_ \memptr : \memptr = False
End If
End Statement

Function.l ahi_IsSoundUsed{snd.l}
SHARED ahi_sound()
Function Return  \is_used
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_FreeAllSounds {}                                                /
;/                                                                             /
;/ Description:                                                                /
;/ Free all Sound Objects.                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_FreeAllSounds{}
For n.l = 0 To #max_ahisounds-1
  ahi_FreeSound{n}
Next
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_CloseAllStreams {}                                              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_CloseAllStreams{}
SHARED ahi_stream()
For stream.l=0 To #max_ahistreams-1
  If ahi_stream(stream)\fid>=0 Then ahi_CloseStream{stream}
Next
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_CloseDevice {}                                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Close the ahi.device and cleans up everything that was allocated by ahi_O:: /
;/ penDevice.                                                                  /
;/ It is safe to call this twice or if AHI was not opened.                     /
;/ This function calls ahi_Stop, ahi_CloseAllStreams.                          /
;/ This function is called on autoexit, so you dont have to call it manually:: /
;/ , even if it is a good idea to keep a good coding style.                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_CloseDevice{}
SHARED ahi_unit,ahi_channel()
USEPATH ahi_unit
ahi_Stop{}
ahi_CloseAllStreams{}
If \is_open
  If \out_buffer[0]\IORequest Then CloseDevice_ \out_buffer[0]\IORequest
  \is_open = False
End If
If \out_buffer[0]\IORequest Then DeleteIORequest_ \out_buffer[0]\IORequest:\out_buffer[0]\IORequest = False
If \out_buffer[1]\IORequest Then FreeMem_ \out_buffer[1]\IORequest,SizeOf.AHIrequest:\out_buffer[1]\IORequest = False
If \out_buffer[0]\ptr Then FreeMem_ \out_buffer[0]\ptr,\out_buffer[0]\size :\out_buffer[0]\ptr = False:\out_buffer[0]\size = 0
If \out_buffer[1]\ptr Then FreeMem_ \out_buffer[1]\ptr,\out_buffer[1]\size :\out_buffer[1]\ptr = False:\out_buffer[1]\size = 0
If \in_buffer[0]\IORequest Then FreeMem_ \in_buffer[0]\IORequest,SizeOf.AHIrequest:\in_buffer[0]\IORequest = False

If \msgport Then DeleteMsgPort_ \msgport : \msgport = False
For n.l = 0 To #max_ahichannels-1
  If ahi_channel(n)\IORequest Then FreeMem_ ahi_channel(n)\IORequest,SizeOf.AHIrequest: ahi_channel(n)\IORequest = False
  ahi_channel(n)\running=False
  ahi_channel(n)\snd       =-1
Next
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_Free {}                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ Eventually close ahi.device and free everything that is associated with t:: /
;/ his include.                                                                /
;/ This function calls ahi_FreeAllSounds, ahi_CloseAllStreams and ahi_CloseD:: /
;/ evice.                                                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_Free{}
ahi_FreeAllSounds{}
ahi_CloseAllStreams{}
ahi_CloseDevice{}
End Statement
!autoexit{ahi_Free}


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ahi_OpenDevice {unit.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Opens the ahi.device and returns "True" if successful.                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - unit.l    : ahi.device unit number, can be 0, 1, 2 or 3                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l    : -1 if everything went well, 0 if the device could not be op:: /
;/ ened                                                                        /
;/                                                                             /
;/ See also:    ahi_CloseDevice                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_OpenDevice{unit.l}
SHARED ahi_unit,ahi_channel()
If \is_open Then ahi_CloseDevice{}
If unit>=0 AND unit<=3
  \msgport    = CreateMsgPort_ ()
  If \msgport
    \out_buffer[0]\IORequest = CreateIORequest_ (\msgport,SizeOf.AHIrequest)
    \out_buffer[1]\IORequest  = AllocMem_ (SizeOf.AHIrequest,#MEMF_CLEAR)
    \in_buffer[0]\IORequest   = AllocMem_ (SizeOf.AHIrequest,#MEMF_CLEAR)
    *AHIIO.AHIrequest = \out_buffer[0]\IORequest
    If \out_buffer[0]\IORequest ><0 AND \out_buffer[1]\IORequest ><0
      *AHIIO\version = 4
      If OpenDevice_ ("ahi.device",unit,\out_buffer[0]\IORequest,0) = 0
        \is_open        = True
        \device_base    = *AHIIO\StdIO\io_Device
        *msgp.MsgPort = \msgport
        \sigflag        = 1 LSL *msgp\mp_SigBit
        For n.l = 0 To #max_ahichannels-1
          ahi_channel(n)\IORequest = AllocMem_ (SizeOf.AHIrequest,#MEMF_CLEAR)
          If ahi_channel(n)\IORequest
            CopyMem_ ahi_unit\out_buffer[0]\IORequest,ahi_channel(n)\IORequest ,SizeOf.AHIrequest
            *AHIIO.AHIrequest = ahi_channel(n)\IORequest
            *AHIIO\StdIO\io_Message\mn_Node\ln_Pri = 0
            *AHIIO\StdIO\io_Command                = #CMD_WRITE
            *AHIIO\StdIO\io_Offset                 = 0
            *AHIIO\link_                           = False
          End If
          CopyMem_ \out_buffer[0]\IORequest,\in_buffer[0]\IORequest ,SizeOf.AHIrequest
          CopyMem_ \out_buffer[0]\IORequest,\out_buffer[1]\IORequest ,SizeOf.AHIrequest
        Next
        \framesize=4
      Else
        error{"\\__THIS_FUNCTION: Unable to open ahi.device!"}
      End If
    Else
      error{"\\__THIS_FUNCTION: Unable to create IORequests!"}
    End If
  Else
    error{"\\__THIS_FUNCTION: Unable to create MsgPort!"}
  End If
Else
  error{"\\__THIS_FUNCTION: Invalid device unit: "+Str$(unit)+" - should be 0...3!"}
End If
If \is_open = False Then ahi_CloseDevice{}
Function Return \is_open
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  sigflag.l = ahi_GetSigFlag {}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Return the ahi.device sigflag, which can be used to Wait_() for a new buf:: /
;/ fer in a stream. However, ahi_CheckOutBuffer has still to be successfully:: /
;/  called in order to access the next buffer.                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - sigflag.l     : signal flag for use e.g. with the Wait_() OS function.    /
;/                                                                             /
;/ See also:    ahi_CheckOutBuffer, ahi_DoStream                               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_GetSigFlag{}
SHARED ahi_unit
Function Return \sigflag
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ahi_InitOut {buffersize.l,channels.l,bits.l,samplerate.:: /
;/ l,@gain.l}                                                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Init the system for double buffered output stream.                          /
;/ Buffersize is the size for each buffer in bytes (doublebuffering).          /
;/ Samplerate is the samplerate you want to use for doublebuffering playback:: /
;/  and NOT neccessarily the samplerate the audio hardware is allocated with.  /
;/ Use this function, if you plan to output audio data rendered by your own.:: /
;/  If you just want to play back a file, use the higher level function ahi_:: /
;/ OpenStream, as this is doing file i/o already for you.                      /
;/ Use this function in combination with ahi_CheckOutBuffer to see if there :: /
;/ is an empty buffer waiting to be filled and retrieve the memory pointer w:: /
;/ ith ahi_GetOutBufferPtr and the length with ahi_GetOutBufferByteSize.       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - buffersize.l   : size of each buffer in bytes                             /
;/ - channels.l     : number of channels, 1 (=mono) or 2(=stereo)              /
;/ - bits.l         : number of bits, either 8 or 16                           /
;/ - samplerate.l   : samplerate of the audio sdata that is planned to feedi:: /
;/ nto the stream                                                              /
;/ - gain.l         : volume gain of this stream                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l         : -1 if everything went well, 0 if it failed               /
;/                                                                             /
;/ See also:    ahi_CheckOutBuffer, ahi_FreeOut                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_InitOut{buffersize.l,channels.l,bits.l,samplerate.l,@gain.l}
SHARED ahi_unit,ahi_channel()
If \is_open
  ahi_FreeOut{}
  \channels     = channels
  \bits         =  bits
  \framesize    = bits/8 * channels
  \sampleformat = ahi_GetSampleForm{channels,bits,True}
  If gain=-1 Then gain = 100
  \gain         = gain *256/100
  If \sampleformat><#AHIST_NOTYPE
    bufferfsize.l   = buffersize / \framesize
    If bufferfsize>=4
      \out_buffer[0]\ptr = AllocMem_ (buffersize.l,0) : \out_buffer[0]\size = buffersize : \out_buffer[0]\fsize = bufferfsize
      \out_buffer[1]\ptr = AllocMem_ (buffersize.l,0) : \out_buffer[1]\size = buffersize : \out_buffer[1]\fsize = bufferfsize
      \temp_buffer       = 0
      If (\out_buffer[0]\ptr><0 AND \out_buffer[1]\ptr><0)
        *AHIIO.AHIrequest = \out_buffer[0]\IORequest
        \samplerate     = samplerate
        \timeindex_base = 0
        *AHIIO\StdIO\io_Message\mn_Node\ln_Pri = 0
        *AHIIO\StdIO\io_Command                = #CMD_WRITE
        *AHIIO\StdIO\io_Offset                 = 0
        *AHIIO\frequency                       = \samplerate
        *AHIIO\type_                           = \sampleformat
        *AHIIO\volume_                         = $10000        ;  // Full Volume
        *AHIIO\position                        = $8000         ;  // Centered
        CopyMem_ \out_buffer[0]\IORequest,\out_buffer[1]\IORequest ,SizeOf.AHIrequest
        ;ahi_Stop{}
        succ.l = True
      Else
        error{"\\__THIS_FUNCTION: Unable to allocate memory for the buffers!"}
      End If
    Else
      error{"\\__THIS_FUNCTION: Buffersize too small!"}
    End If
  Else
    error{"\\__THIS_FUNCTION: Unsupported sampleformat #"+Str$(\sampleformat)+"!"}
  End If
End If
Function Return succ
End Function


USEPATH ahi_sound(snd)
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ahi_CreateSound {snd.l,blength.l,samplerate.l,channels.:: /
;/ l,bits.l}                                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Create a new, blank sound, ready to be filled with your own data.           /
;/ This makes only sense if you want to generate a soundwave. If you want to:: /
;/  load a Sound from disk, use ahi_sound_load instead.                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - snd.l    : Sound Object number                                            /
;/ - blength.l    : byte length (= [bits*channels / 8] * samples)              /
;/ - samplerate.l    : desired samplrate, can be much higher or lower than t:: /
;/ he ahi.device unit offers                                                   /
;/ - channels.l    : number of channels, can be 1 (=mono) or 2 (=stereo)       /
;/ - bits.l    : number of bits, can be 8 or 16                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l:     -1 if everything went well, 0 if there was an error and not:: /
;/ hing is allocated                                                           /
;/                                                                             /
;/ See also:    ahi_SaveSound, ahi_FreeSound                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_CreateSound{snd.l,blength.l,samplerate.l,channels.l,bits.l}
SHARED ahi_sound(),ahi_unit
If snd<0 OR snd>=#max_ahisounds
  error{"\\__THIS_FUNCTION: Invalid sound object number!"}
  Function Return 0
End If

If blength<0
  error {"\\__THIS_FUNCTION: Tried to allocate sample with invalid length = "+Str$(blength)+"!"}
  Function Return 0
End If

If \is_used Then ahi_FreeSound{snd}
\sampleform = ahi_GetSampleForm{channels,bits,True}
If \sampleform >< #AHIST_NOTYPE
  \blength    = blength
  \memptr     = AllocVec_(\blength,#MEMF_ANY)
  \samplerate = samplerate
  \pan        = 50
  \gain       = 100
  \bits       = bits
  \channels   = channels
  If \memptr
    \is_used = True
  Else
    error{"\\__THIS_FUNCTION: Not enough memory for sample data!"}
  End If
Else
  error{"\\__THIS_FUNCTION: Unsupported sample format!"}
End If

Function Return \is_used
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  memptr.l = ahi_GetSoundDataPtr {snd.l}                             /
;/                                                                             /
;/ Description:                                                                /
;/ Get the pointer to the sample data.                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - snd.l     : the sound object number                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - memptr.l  : memory pointer to the raw sample data                         /
;/                                                                             /
;/ See also:    ahi_CreateSound                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_GetSoundDataPtr{snd.l}
SHARED ahi_sound(),ahi_unit
Function Return \memptr
End Function

Function.l ahi_GetSoundSamplerate{snd.l}
SHARED ahi_sound(),ahi_unit
Function Return \samplerate
End Function
 
Function.l ahi_GetSoundSampleLength{snd.l}
SHARED ahi_sound(),ahi_unit
Function Return \blength/\channels * 8 / \bits
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_PlaySound {snd.l,@gain.q,@pan.q,@samplerate.l}                  /
;/                                                                             /
;/ Description:                                                                /
;/ Play a sound back via ahi.device. The device must be opened using ahi_ope:: /
;/ n and the Sound Object must be loaded using ahi_LoadSound before.           /
;/                                                                             /
;/ The optional parameters are set as the new default parameters and will be:: /
;/  remembered for the next call of ahi_PlaySound, if they are not overwritt:: /
;/ en.                                                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - snd.l        : Sound Object number                                        /
;/ optional                                                                    /
;/ - gain.q        : volume gain, where 100 is "normal" volume, 0 is compl:: /
;/ etely silent, default is 100                                                /
;/ - pan.q        : place in the stereo panorama, where 0 is left, 50 in :: /
;/ the middle and 100 right, default is 0                                    /
;/ - samplerate.l : desired samplerate, default is the samples native sample:: /
;/ rate                                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_PlaySound {snd.l,@gain.l,@pan.l,@samplerate.l}
SHARED ahi_sound(),ahi_unit,ahi_channel()
If ahi_unit\is_open=0 Then ahi_OpenDevice{0}
If ahi_unit\is_open
If \is_used
  If gain<0       Then gain = \gain
  If pan<0        Then pan  = \pan
  If samplerate<=0 Then samplerate = \samplerate
  ahi_unit\nextchannel + 1 : If ahi_unit\nextchannel >= #max_ahichannels Then ahi_unit\nextchannel=0
  *AHIIO.AHIrequest = ahi_channel(ahi_unit\nextchannel)\IORequest
  If *AHIIO
    If ahi_channel(ahi_unit\nextchannel)\running Then AbortIO_ *AHIIO:WaitIO_ *AHIIO
    *AHIIO\StdIO\io_Data                   = \memptr
    *AHIIO\StdIO\io_Length                 = \blength
    *AHIIO\StdIO\io_Offset                 = 0
    *AHIIO\frequency                       = samplerate
    *AHIIO\volume_                         = gain * $10000 / 100
    *AHIIO\position                        = pan  * $10000 / 100
    *AHIIO\type_                           = \sampleform
    If SendIO_(*AHIIO) < 0
      error{"Can`t sound data to device ! - "}
    Else
      ahi_channel(ahi_unit\nextchannel)\running = True
      ahi_channel(ahi_unit\nextchannel)\snd     = snd
    End If
  End If
Else
  error{"\\__THIS_FUNCTION: Tried to play an uninitialisized sound!"}
End If
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  snd.l = ahi_GetFreeSound {}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ Find a free Sound Object number, ready for use with ahi_LoadSound or ahi_:: /
;/ CreateSound.                                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - snd.l     : Sound Object number                                           /
;/                                                                             /
;/ See also:    ahi_LoadSound, ahi_CreateSound                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_GetFreeSound{}
SHARED ahi_sound()
snd.l=0
While ahi_sound(snd)\is_used=True AND snd<#max_ahisounds-2:snd+1:Wend
If ahi_sound(snd)\is_used Then snd=-1
Function Return snd
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_SetSoundFreq {snd.l,samplerate.l}                               /
;/                                                                             /
;/ Description:                                                                /
;/ Set the playback samplerate of a Sound Object.                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - snd.l    : Sound Object number                                            /
;/ - samplerate.l    : samplerate for playback                                 /
;/                                                                             /
;/ See also:    ahi_SetSoundPan, ahi_SetSoundVolume                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_SetSoundFreq{snd.l,samplerate.l}
SHARED ahi_sound()
\samplerate = samplerate
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_SetSoundVolume {snd.l,gain.q}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Set the default volume gain.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - snd.l    : Sound Object number                                            /
;/ - gain.q    : 0 = quiet, 1.0 = full volume gain                             /
;/                                                                             /
;/ See also:    ahi_SetSoundPan, ahi_SetSoundFreq                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_SetSoundVolume{snd.l,gain.q} ; gain: 0 = mute, 1=full gain
SHARED ahi_sound()
\gain = Peek.l(&gain)
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_SetSoundPan {snd.l,pan.q}                                       /
;/                                                                             /
;/ Description:                                                                /
;/ Set the default place in stereo panorama.                                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - snd.l    : Sound Object number                                            /
;/ - pan.q    : 0 = left, 0.5 = middle, 1.0 = right                            /
;/                                                                             /
;/ See also:    ahi_SetSoundFreq, ahi_SetSoundVolume                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_SetSoundPan{snd.l,pan.q} ; pan: 0 = left, .5 = middle, 1 = right
SHARED ahi_sound()
\pan = Peek.l(&pan)
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ahi_LoadSound {snd.l,filename.s}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Load an audio file from disk into a Sound Object, ready to be played by a:: /
;/ hi_PlaySound.                                                               /
;/ Supported file formats are .aiff, .wav, .8svx (IFF), .maud, .cdda, .mp3, :: /
;/ .mp2.                                                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - snd.l      : Sound Object number                                          /
;/ - filename.s : filename of the audio file                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : -1 if the Sound Object was loaded, 0 if it failed            /
;/                                                                             /
;/ See also:    ahi_PlaySound, ahi_FreeSound                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_LoadSound{snd.l,filename.s}
SHARED ahi_sound()
dos.l = ffa_Open{filename.s}
If dos>=0
  If ahi_CreateSound{snd,ffa_GetByteLength{dos},ffa_GetSamplerate{dos},ffa_GetChannels{dos},ffa_GetBits{dos}}
    If ffa_ReadData{dos,\memptr,\blength}
      succ.l = True
    End If
  End If
  ffa_Close{dos}
End If
If succ=False Then ahi_FreeSound{snd}
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ahi_SaveSound {snd.l,filename.s,@form.l}                  /
;/                                                                             /
;/ Description:                                                                /
;/ Save a sound as an audiofile to disk.                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - snd.l      : sound object number                                          /
;/ - filename.s : filename                                                     /
;/ - form.l     : form identifier:                                             /
;/ @"AIFF" - aiff File                                                         /
;/ @"WAVE" - RIFF-WAVE file                                                    /
;/ @"8SVX" - IFF-8SVX file                                                     /
;/ @"MAUD" - IFF-MAUD file                                                     /
;/ @"CDDA" - CDDA image file                                                   /
;/ @"RAW"  - RAW data                                                          /
;/ @"MP3"  - MP3 via blademp3.library                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : -1 if everything went well, 0 otherwise                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_SaveSound{snd.l,filename.s,@form.l}
SHARED ahi_sound()
If \is_used
  If form=-1 Then form=@"AIFF"
  fid.l = ffa_Write{filename.s,form,\channels,\bits,\samplerate,-1,False,False}
  If fid>=0
    If ffa_WriteData{fid,\memptr,\blength}
      succ.l = True
    End If
  End If
  ffa_Close{fid}
End If
Function Return succ
End Function
 


USEPATH ahi_unit
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ahi_OpenStream {filename.s,buffersize.l,@speed.l,@gain.:: /
;/ l,@native.l,@stream.l}                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Create a double buffered output using ahi_InitOut and associate an audiofile as a:: /
;/  stream. If the stream is created, the first call of ahi_DoStream will s:: /
;/ tart playback.                                                              /
;/ All you have to do is call ahi_DoStream in regular intervals to fill the:: /
;/  buffers automatically with the data from the audio file. No need to call:: /
;/  ahi_CheckutBuffer or the ahi_GetOutBuffer??? functions.                     /
;/                                                                             /
;/ It supports .aiff, .wav, .8svx (IFF), .maud, .cdda, .mp3 and .mp2 files.    /
;/                                                                             /
;/ Note: unlike the low level function ahi_InitOut, this function takes :: /
;/ the buffersize in milliseconds.                                             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : filename of the audio file                                /
;/ - buffersize.l  : size for one audio buffer in milliseconds               /
;/ - speed.l       : change the playback speed in percent, default is 100 %.      /
;/ - gain.l        : 0.100 volume gain                                                          /
;/ - native.l      : open in file-native audio format or in 16bit/stereo                                                        /
;/ - stream.l      : id of stream, default is 0                                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l        : -1 if the stream was opened, 0 if it failed                  /
;/                                                                             /
;/ See also:    ahi_DoStream, ahi_CloseStream                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_OpenStream{filename.s,buffersize.l,@speed.l,@gain.l,@native.l,@stream.l}  ; buffersize in ms!!!
SHARED ahi_unit,ahi_stream()
succ.l=False
If speed<20 Then speed=100
If gain=-1 Then gain = 100
If stream<0 Then stream=0 ;: error {"Using default!"}
ahi_CloseStream{stream}
fid.l = ffa_Open{filename.s}
If fid>=0
  buffersize * ffa_GetSamplerate{fid} / 1000
  buffersize * ffa_GetChannels{fid} * Int(ffa_GetBits{fid}/8)
  If buffersize<256 Then buffersize=256
  buffersize / 8
  buffersize * 8

  If native
    channels.l = ffa_GetChannels{fid}
    bits.l     = ffa_GetBits{fid}
  Else
    channels.l = 2
    bits.l     = 16
  End If

  If \stream_count=0
    succ = ahi_InitOut{buffersize,channels,bits,ffa_GetSamplerate{fid}*speed/100,gain}
  Else
    succ = True
  End If

  If succ
    ahi_stream(stream)\fid        = fid
    ahi_stream(stream)\offset     = 0
    ahi_stream(stream)\flength    = ffa_GetFrameLength{fid}
    ahi_stream(stream)\loop_start = -1
    ahi_stream(stream)\loop_end   = ffa_GetFrameLength{fid}
    ahi_stream(stream)\filename   = filename.s
    ahi_stream(stream)\fade_startgain = 256
    ahi_stream(stream)\fade_endgain   = 256
    ahi_stream(stream)\fade_length = 0
    ahi_stream(stream)\fade_pos    = -1
    \stream_count+1
  Else
    ffa_Close{fid}
  End If
End If
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ahi_RenderGain {ptr.l,blength.l,gain.l,bits.l}                     /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - ptr.l      : pointer to an audio buffer                                   /
;/ - blength.l  : byte length of audio buffer                                  /
;/ - gain.l     : gain 0...256                                                 /
;/ - bits.l     : bit depth of audio data                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ahi_RenderGain{ptr.l,blength.l,gain.l,bits.l}
samplesize.l = bits/8
If samplesize=0 Then samplesize=1
Select bits
  Case 8
    For memaddr.l = ptr To ptr+blength-1 Step samplesize
      s.l = (Peek.b(memaddr) * gain) ASR 8
      If s> $7F Then s =  $7F
      If s<-$80 Then s = -$80
      Poke.b memaddr,s
    Next
  Case 16
    For memaddr.l = ptr To ptr+blength-1 Step samplesize
      s.l = (Peek.w(memaddr) * gain) ASR 8
      If s> $7FFF Then s =  $7FFF
      If s<-$8000 Then s = -$8000
      Poke.w memaddr,s
    Next
  Case 24
    For memaddr.l = ptr To ptr+blength-1 Step samplesize
      s.l = ( Peek.b(memaddr) + (Peek.b(memaddr+1) LSL 8) + (Peek.b(memaddr+2) LSL 16)  ASR 8) * gain
      If s> $7FFFFF Then s =  $7FFFFF
      If s<-$800000 Then s = -$800000
      Poke.b memaddr  , s&$FF
      Poke.b memaddr+1, (s LSR 8)  &$FF
      Poke.b memaddr+2, (s LSR 16) &$FF
    Next
  Case 32  ;float
    gainf.f = gain / 256
    For memaddr.l = ptr To ptr+blength-1 Step samplesize
      sfl.f = Peek.f(memaddr) * gain
      Poke.f memaddr,sfl
    Next

End Select
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ahi_Merge {destptr.l,sourceptr.l,blength.l,gain.l,bits.l}          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - destptr.l    : ???                                                        /
;/ - sourceptr.l    : ???                                                      /
;/ - blength.l    : ???                                                        /
;/ - gain.l    : ???                                                           /
;/ - bits.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ahi_Merge{destptr.l,sourceptr.l,blength.l,gain.l,bits.l}
samplesize.l = bits/8
If samplesize=0 Then samplesize=1
slength.l = blength/samplesize
Select bits
  Case 8
    For n.l=0 To slength-1
      s.l = (Peek.b(sourceptr+n) * gain) ASR 8 + Peek.b(destptr+n)
      If s> $7F Then s =  $7F
      If s<-$80 Then s = -$80
      Poke.b destptr+n,s
    Next
  Case 16
    For n.l=0 To slength-1
      s.l = (Peek.w(sourceptr+(n LSL 1)) * gain) ASR 8 + Peek.w(destptr+(n LSL 1))
      If s> $7FFF Then s =  $7FFF
      If s<-$8000 Then s = -$8000
      Poke.w destptr+(n LSL 1),s
    Next
  Case 24
    For n.l=0 To slength-1
      s.l = ( ((Peek.b(sourceptr)&$FF) + ((Peek.b(sourceptr+1)&$FF) LSL 8) + (Peek.b(sourceptr+2) LSL 16))  ASR 8) * gain
      s.l +   (Peek.b(destptr)&$FF) + ((Peek.b(destptr+1)&$FF) LSL 8) + (Peek.b(destptr+2) LSL 16)
      If s> $7FFFFF Then s =  $7FFFFF
      If s<-$800000 Then s = -$800000
      Poke.b destptr  , s&$FF
      Poke.b destptr+1, (s LSR 8)  &$FF
      Poke.b destptr+2, (s LSR 16) &$FF
      destptr+3
      sourceptr+3
    Next
  Case 32  ;float
    gainf.f = gain / 256
    For n.l=0 To slength-1
      sfl.f = Peek.f(sourceptr+(n LSL 2)) * gain  + Peek.f(destptr+(n LSL 2))
      Poke.f destptr+(n LSL 2),sfl
    Next

End Select
End Statement
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ahi_RenderFade {stream.l,destptr.l,sourceptr.l,blength.l,channel:: /
;/ s.l,bits.l}                                                                 /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - stream.l    : ???                                                         /
;/ - destptr.l    : ???                                                        /
;/ - sourceptr.l    : ???                                                      /
;/ - blength.l    : ???                                                        /
;/ - channels.l    : ???                                                       /
;/ - bits.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ahi_RenderFade{stream.l,destptr.l,sourceptr.l,blength.l,channels.l,bits.l}
SHARED ahi_stream(),ahi_unit
samplesize.l = bits/8
If channels<1 Then channels=1
If samplesize=0 Then samplesize=1
slength.l = blength/samplesize
flength.l = slength / channels
For n.l=0 To flength-1
  If ahi_stream(stream)\fade_pos<0
    gain.l = ahi_stream(stream)\fade_startgain
  Else
    If ahi_stream(stream)\fade_pos>=ahi_stream(stream)\fade_length
      gain.l = ahi_stream(stream)\fade_endgain
    Else
      re.l   = 100 * ahi_stream(stream)\fade_pos/ahi_stream(stream)\fade_length
      rs.l   = 100 - re
      gain   = (re*ahi_stream(stream)\fade_endgain + rs*ahi_stream(stream)\fade_startgain)/ 100
    End If
  End If
  For m.l = 0 To channels-1
  Select bits
    Case 16
        s.l = (Peek.w(sourceptr) * gain) ASR 8
        If destptr><sourceptr Then s + Peek.w(destptr)
        If s> $7FFF Then s =  $7FFF
        If s<-$8000 Then s = -$8000
        Poke.w destptr,s
        destptr+2
        sourceptr+2
  End Select
  Next
  ahi_stream(stream)\fade_pos+1

Next
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ahi_DoStream {}                                           /
;/                                                                             /
;/ Description:                                                                /
;/ Check if there are pending free buffers using ahi_CheckOutBuffer, and fil:: /
;/ l it with audio data from disk, if one or more streams is opened using ah:: /
;/ i_OpenStream.                                                               /
;/ Don't use this if you init your stream using ahi_InitOut and plan to fill:: /
;/  it with your own rendered data. Only use this function, if you open dire:: /
;/ ctly a file using ahi_OpenStream.                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : -1 if there was a buffer to fill, 0 otherwise                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_DoStream{}
SHARED ahi_unit,ahi_stream()
If \stream_count<=0 Then Function Return False
If \is_open=False Then Function Return False
If ahi_CheckOutBuffer{}=False Then Function Return True
Repeat
  isbusy.l = False
  baseptr.l = ahi_GetOutBufferPtr{}
  baselen.l = ahi_GetOutBufferByteSize{}
  If \stream_count>1 ; init temp buffer if necessary
    If \temp_buffer=0
      \temp_buffer = AllocVec_ (\out_buffer[0]\size,#MEMF_ANY)
    End If
  End If
  count.l = 0
  For stream.l=0 To #max_ahistreams-1 ; check all streams
    If ahi_stream(stream)\fid>=0  ; it is open
      blength.l = baselen   ; get the length of our buffer to fill
      ptr.l     = baseptr
      succ.l    = True
      While blength>0 AND succ=True
        ; min if what we want and what we have left in audio file
        chunk.l = Min(blength,(ahi_stream(stream)\loop_end - ahi_stream(stream)\offset)*\framesize)

        If chunk<=0 ; there is no data waiting in audio file
          If ahi_stream(stream)\loop_start>=0 ; if we have a loop, we jump to loopstart
            ahi_stream(stream)\offset = ahi_stream(stream)\loop_start
            succ.l = ffa_Seek{ahi_stream(stream)\fid,ahi_stream(stream)\offset}
            chunk.l = Min(blength,(ahi_stream(stream)\loop_end - ahi_stream(stream)\offset)*\framesize)
          Else  ; well we can't do anthing more
            chunk=0
          End If
        End If

        If ahi_stream(stream)\fade_pos>=ahi_stream(stream)\fade_length  ; we are past the fade
          If ahi_stream(stream)\fade_endgain=0
            chunk=0
          End If
        End If

        If chunk>0 ; if we have data in file...
          If count=0  ; we are the first stream, so go directly into the buffer...
            succ.l = ffa_ReadData{ahi_stream(stream)\fid,ptr,chunk,\channels,\bits}
            If ahi_stream(stream)\fade_length>0
              _ahi_RenderFade{stream,ptr,ptr,chunk,\channels,\bits}
            End If
          Else
            If \temp_buffer ; we need to add the data, since we are not the first buffer
              succ.l = ffa_ReadData{ahi_stream(stream)\fid,\temp_buffer,chunk,\channels,\bits}
              If ahi_stream(stream)\fade_length>0
                _ahi_RenderFade{stream,ptr,\temp_buffer,chunk,\channels,\bits}
              Else
                _ahi_Merge{ptr,\temp_buffer,chunk,256,\bits}
              End If
            End If
          End If
          ptr+chunk

          ahi_stream(stream)\offset + (chunk / \framesize)
          isbusy=True  ; we loaded some data, so we are bussy
        Else  ;no data available, so we fill with zeros
          ahi_stream(stream)\offset + (blength / \framesize)
          If count=0
            While blength>3:Poke.l ptr,0 : ptr+4 : blength-4 : Wend
            While blength>0:Poke.b ptr,0 : ptr+1 : blength-1 : Wend
          End If
          chunk=0
        End If

        blength-chunk
      Wend
      If isbusy Then count+1
    End If
  Next

  If \gain><256 ; apply master gain
    ;_ahi_RenderGain{baseptr,baselen,\gain,\bits}
  End If

  succ.l = ahi_WriteOutBuffer{}
Until ahi_CheckOutBuffer{} = False OR succ=False
Function Return isbusy
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_SetOutVolume {gain.l}                                           /
;/                                                                             /
;/ Description:                                                                /
;/ Set the master volume for the out buffer (affects streams)                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - gain.l    : master gain in % (0=silence, 100=normal level)                /
;/                                                                             /
;/ See also:    ahi_InitOut, ahi_FreeOut                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_SetOutVolume{gain.l}
SHARED ahi_unit
ahi_unit\gain = gain * 256 / 100
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ahi_GetStreamFid {@stream.l}                            /
;/                                                                             /
;/ Description:                                                                /
;/ Get the file object ID of the file that is associated with the stream.      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - stream.l  : stream object number                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : fid of audio file (see file.include)                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_GetStreamFid{@stream.l}
SHARED ahi_unit,ahi_stream()
If stream<0 Then stream=0
Function Return ahi_stream(stream)\fid
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_JumpStreamPos {ms.l,@stream.l}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ "Jump" (or seek) to a specific timestamp within the stream. This requires:: /
;/  to have the stream created on a file using ahi_OpenStream.                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - ms.l     : new position within the audio file in milliseconds             /
;/ - stream.l : stream object number                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_JumpStreamPos{ms.l,@stream.l}
SHARED ahi_unit,ahi_stream()
If stream<0 Then stream=0
If ahi_stream(stream)\fid>=0
  ahi_stream(stream)\offset = ffa_ms2off{ahi_stream(stream)\fid,ms}
  If ahi_stream(stream)\offset<ahi_stream(stream)\flength Then succ.l = ffa_Seek{ahi_stream(stream)\fid,ahi_stream(stream)\offset}
  ahi_Stop{}
  succ.l=ahi_DoStream{}
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  pos.l = ahi_GetStreamPos {@stream.l}                               /
;/                                                                             /
;/ Description:                                                                /
;/ Get the current playback position of an audio stream in milliseconds.       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - stream.l  : stream object number                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - pos.l     : playback position in ms                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_GetStreamPos{@stream.l}
SHARED ahi_unit,ahi_stream()
ms.l = 0
If stream<0 Then stream=0
If ahi_stream(stream)\fid>=0
  ms.l = ffa_off2ms{ahi_stream(stream)\fid,ahi_stream(stream)\offset}
End If
Function Return ms
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_SetStreamLoop {startpos.l,@endepos.l,@stream.l}                 /
;/                                                                             /
;/ Description:                                                                /
;/ Set the loop points for a stream. This way you can create endless backgro:: /
;/ und music.                                                                  /
;/                                                                             /
;/ Note: You can change the loop while the stream is playing. The changes wi:: /
;/ ll not cause a jump in the audio data.                                      /
;/ After passing the old end positon, it will smoothly jump to the new start:: /
;/  position and continue looping there. This way, you can create context de:: /
;/ pendent background music, e.g. having several patterns for several athmos:: /
;/ pheres and smoothly changing between them.                                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - startpos.l   : start position in milliseconds                             /
;/ - endepos.l    : end position in milliseconds                               /
;/ - stream.l     : stream object number                                       /
;/                                                                             /
;/ See also:    ahi_OpenStream, ahi_DoStream                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_SetStreamLoop{startpos.l,@endepos.l,@stream.l}
SHARED ahi_unit,ahi_stream()
If stream<0 Then stream=0
If ahi_stream(stream)\fid>=0
  If startpos>=0
    startpos = ffa_ms2off{ahi_stream(stream)\fid,startpos}
  Else
    startpos=-1
  End If
  If endepos>=0
    endepos  = ffa_ms2off{ahi_stream(stream)\fid,endepos}
  Else
    endepos=-1
  End If
  If endepos>=ahi_stream(stream)\flength Then endepos = ahi_stream(stream)\flength-1
  ahi_stream(stream)\loop_start = startpos
  If endepos>0 Then ahi_stream(stream)\loop_end   = endepos
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_SetStreamFade {startgain.l,endgain.l,mslength.l,@stream.l}      /
;/                                                                             /
;/ Description:                                                                /
;/ Initialize a gain change (fade) from startgain to endgain that takes msle:: /
;/ ngth milliseconds.                                                          /
;/ The fade will start at the very next audio buffer when you call ahi_DoStr:: /
;/ eam.                                                                        /
;/ Note: after the fade is done, the gain will stay at endgain level.          /
;/ Note: if endgain=0, the stream stop to play once the fade is done and ahi:: /
;/ _DoStream will return False.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - startgain.l  : gain from where to start the fade in % (e.g. 100=normal :: /
;/ level)                                                                      /
;/ - endgain.l    : gain of the end of the fade in % (e.g. 0=complete silence) /
;/ - mslength.l   : time in ms the fade needs to get from startgain to endgain /
;/ - stream.l     : id of the affected stream                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_SetStreamFade{startgain.l,endgain.l,mslength.l,@stream.l}
SHARED ahi_unit,ahi_stream()
If stream<0 Then stream=0
If ahi_stream(stream)\fid>=0
  ahi_stream(stream)\fade_length     = ffa_ms2off{ahi_stream(stream)\fid,mslength}
  ahi_stream(stream)\fade_pos        = 0
  ahi_stream(stream)\fade_startgain  = startgain * 256 / 100
  ahi_stream(stream)\fade_endgain    = endgain   * 256 / 100
End If
End Statement
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = _ahi_GetPeak {startaddr.l,flength.l,visual.l}           /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - startaddr.l    : ???                                                      /
;/ - flength.l    : ???                                                        /
;/ - visual.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ahi_GetPeak{startaddr.l,flength.l,visual.l}
SHARED ahi_unit
If flength>0
If \channels = 2
  If \bits = 16
    If flength>0
    GetReg d0,flength
    GetReg a0,startaddr
    GetReg a1,&peakl.l
    GetReg a2,&peakr.l

    CLR.l d1
    CLR.l d2
    getpeakloop16s:

      CMP.w (a0)+,d1
      BGE ahi_nohighl
      MOVE.w -2(a0),d1
      ahi_nohighl:
      CMP.w (a0)+,d2
      BGE ahi_nohighr
      MOVE.w -2(a0),d2
      ahi_nohighr:

    SUB.l #1,d0 : BGT getpeakloop16s
    ASR.w #8,d1 : EXT.l d1
    ASR.w #8,d2 : EXT.l d2

    MOVE.l d1,(a1)
    MOVE.l d2,(a2)
    End If
  Else
;    peakl.l = Peek.b(endaddr)  )
;    peakr.l = Peek.b(endaddr+1))
  End If
Else
  If \bits = 16
;    peakl.l = Abs(Peek.w(endaddr)/256)
;    peakr.l = peakl
  Else
;    peakl.l = Abs(Peek.b(endaddr))
;    peakr.l = peakl
  End If
End If
End If

If peakl<0 Then peakl=0-peakl
If peakr<0 Then peakr=0-peakr

If \visual_square
;  peakl = Sqr(peakl*128)
;  peakr = Sqr(peakr*128)
  peakl = Sqr(peakl*128)
  peakr = Sqr(peakr*128)
End If
 


If peakl<\out_v_peakl
  \out_v_peakl = (\out_v_peakl * \visual_smoothness + peakl * (100-\visual_smoothness)) / 100
Else
  \out_v_peakl = peakl
End If

If peakr<\out_v_peakr
  \out_v_peakr = (\out_v_peakr * \visual_smoothness + peakr * (100-\visual_smoothness)) / 100
Else
  \out_v_peakr = peakr
End If

peakl = \out_v_peakl * \visual_norm / 128
peakr = \out_v_peakr * \visual_norm / 128

If peakl>Peek.w(&visual  ) Then Poke.w &visual.l  ,Peek.w(&peakl+2)
If peakr>Peek.w(&visual+2) Then Poke.w &visual.l+2,Peek.w(&peakr+2)

;If visual<0 Then error{"Visual ist kleiner 0!"}
Function Return visual
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ahi_GetVisualOut {}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Get peak level infromation about the current playback for visual display.   /
;/ The peak of the left and right channel are encoded in the upper and lower:: /
;/  word of the longword result.                                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : peaks of the left and right channel                        /
;/                                                                             /
;/ See also:    ahi_ConfigVisual                                               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_GetVisualOut{}
SHARED ahi_unit
timeindex.l = ahi_GetOutTimeindex{}
visual.l = 0
If \running
  If \out_actual >< \out_v_lbuffer
    bufferpos_old.l = \out_v_lpos
    psize.l = (\out_buffer[ \out_v_lbuffer]\size-bufferpos_old)/\framesize
    If psize>0
;      visual.l = ahi_stream_Getpeak{\out_buffer[\out_v_lbuffer]\ptr+bufferpos_old,psize,0}
      ;\visual_last   = 0;visual
    End If
  Else
  ;\visual_last = 0
  End If

  bufferpos.l = (timeindex-\timeindex_base) * \framesize
  If bufferpos<0 Then bufferpos=0  ;:error{"Bufferpos = 0 !!!"}

  If \out_actual >< \out_v_lbuffer Then bufferpos_old.l = 0:Else bufferpos_old = \out_v_lpos
  psize.l = bufferpos-bufferpos_old

  If bufferpos_old + psize>\out_buffer[ \out_v_lbuffer]\size
    psize = \out_buffer[ \out_v_lbuffer]\size - bufferpos_old
  End If

  If psize>=0
    visual.l = _ahi_GetPeak{\out_buffer[\out_actual]\ptr+bufferpos_old,psize/\framesize,visual.l}
    \visual_last   = visual
  Else
    visual = \visual_last : \visual_last=0
  End If
Else
  visual.l = _ahi_GetPeak{\out_buffer[\out_actual]\ptr,0,visual.l}
  \visual_last   = visual
  bufferpos=0
End If
\out_v_lbuffer = \out_actual
\out_v_lpos    = bufferpos
Function Return visual
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ahi_ConfigVisual {smoothness.l,norm.l,square.w}                     /
;/                                                                             /
;/ Description:                                                                /
;/ Configure the attributes how the visual information of ahi_GetVisualOut w:: /
;/ ill be formatted.                                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - smoothness.l  : speed of level changes [0=fast, 99=very slow]             /
;/ - norm.l        : maximum level, e.g. 100                                   /
;/ - square.w      : make the square root of the peaks, looks more like the :: /
;/ ears "hears" the signal                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ahi_ConfigVisual{smoothness.l,norm.l,square.w}
SHARED ahi_unit
\visual_square     = square
\visual_smoothness = smoothness
\visual_norm       = norm
End Statement
 

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ahi_WaitRec {}                                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_WaitRec{}
SHARED ahi_unit
done.l = 0
If \is_open
  If \rec_running
    If \in_buffer[0]\busy
      WaitIO_ \in_buffer[0]\IORequest
      *AHIIO.AHIrequest      = \in_buffer[0]\IORequest
      done = ahi_Bytes2Samps{*AHIIO\StdIO\io_Actual}
      \rec_timeindex_base + done
      If done=0 Then done=-1
    End If
  End If
;Else
;  error{"\\__THIS_FUNCTION: ahi.device is not open!"}
End If
Function Return done
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ahi_CheckRecBuffer {}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Check if a recording buffer is full and ready to be read out.               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if the last buffer is full                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_CheckRecBuffer{}
SHARED ahi_unit
done.l=0
If \is_open
  If \rec_running
    If \in_buffer[0]\busy
      If CheckIO_ (\in_buffer[0]\IORequest)
        WaitIO_ \in_buffer[0]\IORequest
        ;\rec_timeindex_base + ahi_Bytes2Samps{\in_buffer[0]\rsize}
        *AHIIO.AHIrequest      = \in_buffer[0]\IORequest
        done = ahi_Bytes2Samps{*AHIIO\StdIO\io_Actual}
        \rec_timeindex_base + done
        If done=0 Then done=-1
      End If
    End If
  End If
Else
  error{"\\__THIS_FUNCTION: ahi.device is not open!"}
End If
Function Return done
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ahi_ReadRecBuffer {ptr.l,blength.l}                     /
;/                                                                             /
;/ Description:                                                                /
;/ Attach a memory block as an audio buffer to the recording queue.            /
;/ The buffer will be filled with data specified in ahi_InitRec.               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - ptr.l      : pointer to your buffer                                       /
;/ - blength.l  : byte length of your buffer                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l   : -1 if everything went well, 0 otherwise                      /
;/                                                                             /
;/ See also:    ahi_InitRec, ahi_CheckRecBuffer                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_ReadRecBuffer{ptr.l,blength.l}
SHARED ahi_unit
succ.l=False
If \is_open
  If \rec_running=True AND ptr><0
    *AHIIO.AHIrequest      = \in_buffer[0]\IORequest
    *AHIIO\StdIO\io_Data   = ptr
    *AHIIO\StdIO\io_Length = blength
    *AHIIO\frequency       = \rec_samplerate
    *AHIIO\type_           = \rec_sampleformat
    *AHIIO\StdIO\io_Command= #CMD_READ
    If \in_buffer[0]\busy = False
      ;res.l = SendIO_(*AHIIO)
      res.l = DoIO_(*AHIIO)
    Else
      res.l = SendIO_(*AHIIO)
    End If
    If res< 0
      error{"\\__THIS_FUNCTION: Can`t read data from device! - "+Str$(*AHIIO\StdIO\io_Error)+" recorded: "+Str$(*AHIIO\StdIO\io_Actual)}
    Else
      \in_buffer[0]\rsize = blength
      \in_buffer[0]\busy = True
      succ = True
    End If
  End If
Else
  error{"\\__THIS_FUNCTION: ahi.device is not open!"}
End If
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ahi_InitRec {@samplerate.l,@sampleformat.l}             /
;/                                                                             /
;/ Description:                                                                /
;/ Init and start audio recording. Use ahi_ReadRecBuffer to put a buffer int:: /
;/ o the queue and use ahi_CheckRecBuffer for incoming audio data.             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - samplerate.l   : desired samplerate                                       /
;/ - sampleformat.l : desired sampleformat, e.g. #AHIST_S16S                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l       : -1 if everything went ok, 0 otherwise                    /
;/                                                                             /
;/ See also:    ahi_GetSampleForm, ahi_CheckRecBuffer, ahi_ReadRecBuffer       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ahi_InitRec{@samplerate.l,@sampleformat.l}
SHARED ahi_unit
succ.l=False
If sampleformat=-1 Then sampleformat = #AHIST_S16S
If samplerate= -1 Then samplerate = \samplerate
If samplerate<1  Then samplerate = 11025

If \rec_running Then ahi_StopRec{}
If \is_open><0
  \rec_samplerate     = samplerate
  \rec_sampleformat   = sampleformat
  \rec_running        = True
  \rec_timeindex_base = 0
  \in_buffer[0]\busy  = False
  *AHIIO.AHIrequest = \in_buffer[0]\IORequest
  *AHIIO\StdIO\io_Command= #CMD_READ
  *AHIIO\StdIO\io_Offset = 0
  succ=-1
;  Signal_ FindTask_(0),\sigflag
End If
Function Return succ
End Function




CNIF #__include=0
;%Example:
unit.l = 0
If ahi_OpenDevice{unit}
  If ahi_LoadSound{0,"/Data/Shot"}
    ahi_PlaySound{0}                 ; play the sound!
    Delay_ 200
  End If

  If ahi_OpenStream{"/Data/DemoSong.mp3",250} ; play a stream
;  If ahi_OpenStream{"Work:Music/Thilo/ExDorf.mp3",250,100,100,True,1} ; play a stream
 ;   ahi_SetStreamFade{100,0,10000,0}
;    ahi_SetStreamFade{100,0,20000,1}
    While ahi_DoStream{} : Delay_ 10 : Wend
    Delay_ 50
    ahi_WaitOutFinish{}
  End If

 ; End If
End If
End
CEND




