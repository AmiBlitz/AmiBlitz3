; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "/Bin"
; ExeFile         = "FileAudioDemo"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 388
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 7
; CursorColumn    = 9
; LabelSearch     = "wr"
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 1
; Max GadgetList  = 1
; Max Queue       = 1
; Max Screen      = 2
; Max Shape       = 1
; Max CopList     = 1
; Max Sprite      = 1
; Max Stencil     = 1
; Max Module      = 1
; Max Window      = 30
; Max Anim        = 1
; Max Sound       = 1
; Max Bank        = 1
; Max Buffer      = 1
; Max BitMap      = 1
; Max Slice       = 1
; Max Page        = 1
; Max Tape        = 1
; Max IntuiFont   = 12
; Max MedModule   = 1
; Max Palette     = 1
; Max MenuList    = 1
; Max BlitzFont   = 1
; Max GTList      = 30
; Max ChunkyBuffer= 2
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: file_audio.include                                                    /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 02/01/2007                                                            /
;/                                                                             /
;/ Author: Thilo Koehler                                                       /
;/                                                                             /
;/ Requirements:  Amiblitz2.4                                                  /
;/                                                                             /
;/ Purpose:                                                                    /
;/ This include brings load and save functionality for audio files to AB2.     /
;/                                                                             /
;/ Abstract:                                                                   /
;/ This include is an add-on include of the file.include. It supports readin:: /
;/ g and writing of various audio formats such as iff-8svx, riff-wav, aiff, :: /
;/ maud or cdda. It has a build in format convertion from mono to stereo, 8 :: /
;/ to 32bit.                                                                   /
;/ The idea is, that you open a file for writing, lets say 44.1kHz, 16bit mo:: /
;/ no. Then, each write command is feeded with the input format, which is us:: /
;/ ually an array of samples, that can be 16kHz, 8bit stereo. The write func:: /
;/ tion will automatially write it correctly to the audio file.                /
;/                                                                             /
;/ User Constants:                                                             /
;/ #mpega_support = 1                                                          /
;/ Make use of the mpega.library to load mp3/2 files. If mpega.library is no:: /
;/ t installed, you program will work but refuse to load mp3 files and compl:: /
;/ ain about the missing mpega.lib.                                            /
;/                                                                             /
;/ See also:    file.include                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////

CNIF @#use_mpega_library=0
  #use_mpega_library=1        ; we will support mp3 files throu mpega.library
CEND

CNIF @#use_ptplay_library=0
  #use_ptplay_library=1        ; we will support mp3 files throu mpega.library
CEND


CNIF #__include=0
Syntax 2
optimize 7
CEND

XINCLUDE "error.include.ab3"
XINCLUDE "convert.include.ab3"
XINCLUDE "file.include.ab3"
XINCLUDE "convert_audio.include.ab3"
XINCLUDE "blademp3.include.ab3"
CNIF #use_ptplay_library
XINCLUDE "ptplay.include.ab3"
CEND
CNIF #use_mpega_library
XINCLUDE "mpega.include.ab3"
CEND

.FFA_STATS
#ffa_workbuffersize = 12800 ; size of buffer to convert audiodata

; known fileformats
#FFA_UNKNOWN = 0
;#FFA_AIFF    = @"AIFF"
;#FFA_WAVE    = @"WAVE"
;#FFA_MAUD    = @"MAUD"
;#FFA_8SVX    = @"8SVX"
;#FFA_CDDA    = @"CDDA"
;#FFA_RAW     = @"RAW"
;#FFA_MP3     = @"MP3"
;#FFA_MP2     = @"MP3"
;#FFA_MP1     = @"MP1"
;#FFA_HDREC   = @"HDRC"
;#FFA_ADC     = @"ADC"
;#FFA_SYSEX   = @"SYSX"
;#FFA_AB3S    = @"AB3S"
;#FFA_AB3C    = @"AB3C"

; known byteorders
#FFABO_BIGENDIAN     = 1
#FFABO_LITTLEENDIAN  = 2

#FFAMAX_SAMPLERATE = 192000*2
#FFAMIN_SAMPLERATE =    512

; encoding modes
#FFAE_RAW      = 0  ; 8, 16, 24 or 32 bit integers
#FFAE_MPEGA    = 3  ; MPEG
#FFAE_FLOAT32  = 4  ; 32bit floats
#FFAE_SYSEX    = 5  ; sysex encoded
#FFAE_MOD      = 6  ; MOD
#FFAE_UNKNOWN  = 7  ; invalid format
#FFAE_BLADEMP3 = 8  ; blade mp3 for writing only
#FFAE_ADPCM2   = 9  ; ADPCM 4Bit for AB3S format
#FFAE_ADPCM3   = 10  ; ADPCM 4Bit for AB3S format
#FFAE_ADPCM4   = 11  ; ADPCM 4Bit for AB3S format
#FFAE_ADPCM6   = 12  ; ADPCM 4Bit for AB3S format
#FFAE_ADPCM8   = 13  ; ADPCM 4Bit for AB3S format
#FFAE_ADDPCM2  = 14
#FFAE_ADDPCM3  = 15
#FFAE_ADDPCM4  = 16
#FFAE_ADDPCM6  = 17
#FFAE_ADDPCM8  = 18

#FFAE_PCM8     = 0
#FFAE_PCM16    = 0
#FFAE_PCM24    = 0
#FFAE_PCM32    = 0

; known channels
#FFAC_MONO   = 1
#FFAC_STEREO = 2

; modes for stereo2mono conversion
#mode_right = -1
#mode_both  = 0
#mode_left  = 1

; quality of conversion
#quality_fast = 0
#quality_high = -1

#WAVE_FORMAT_UNKNOWN     = $0000 ; /* Unknown Format */
#WAVE_FORMAT_PCM         = $0001 ; /* PCM */
#WAVE_FORMAT_ADPCM       = $0002 ; /* Microsoft ADPCM Format */
#WAVE_FORMAT_IEEE_FLOAT  = $0003 ; /* IEEE Float */
#WAVE_FORMAT_VSELP       = $0004 ; /* Compaq Computer's VSELP */
#WAVE_FORMAT_IBM_CSVD    = $0005 ; /* IBM CVSD */
#WAVE_FORMAT_ALAW        = $0006 ; /* ALAW */
#WAVE_FORMAT_MULAW       = $0007 ; /* MULAW */
#WAVE_FORMAT_OKI_ADPCM   = $0010 ; /* OKI ADPCM */
#WAVE_FORMAT_DVI_ADPCM   = $0011 ; /* Intel's DVI ADPCM */
#WAVE_FORMAT_MEDIASPACE_ADPCM  = $0012 ; /*Videologic's MediaSpace ADPCM*/
#WAVE_FORMAT_SIERRA_ADPCM  = $0013 ; /* Sierra ADPCM */
#WAVE_FORMAT_G723_ADPCM    = $0014 ; /* G.723 ADPCM */
#WAVE_FORMAT_DIGISTD       = $0015 ; /* DSP Solution's DIGISTD */
#WAVE_FORMAT_DIGIFIX       = $0016 ; /* DSP Solution's DIGIFIX */
#WAVE_FORMAT_DIALOGIC_OKI_ADPCM  = $0017 ; /* Dialogic OKI ADPCM */
#WAVE_FORMAT_MEDIAVISION_ADPCM = $0018 ; /* MediaVision ADPCM */
#WAVE_FORMAT_CU_CODEC      = $0019 ; /* HP CU */
#WAVE_FORMAT_YAMAHA_ADPCM  = $0020 ; /* Yamaha ADPCM */
#WAVE_FORMAT_SONARC        = $0021 ; /* Speech Compression's Sonarc */
#WAVE_FORMAT_TRUESPEECH    = $0022 ; /* DSP Group's True Speech */
#WAVE_FORMAT_ECHOSC1       = $0023 ; /* Echo Speech's EchoSC1 */
#WAVE_FORMAT_AUDIOFILE_AF36  = $0024 ; /* Audiofile AF36 */
#WAVE_FORMAT_APTX          = $0025 ; /* APTX */
#WAVE_FORMAT_AUDIOFILE_AF10  = $0026 ; /* AudioFile AF10 */
#WAVE_FORMAT_PROSODY_1612  = $0027 ; /* Prosody 1612 */
#WAVE_FORMAT_LRC           = $0028 ; /* LRC */
#WAVE_FORMAT_AC2           = $0030 ; /* Dolby AC2 */
#WAVE_FORMAT_GSM610        = $0031 ; /* GSM610 */
#WAVE_FORMAT_MSNAUDIO      = $0032 ; /* MSNAudio */
#WAVE_FORMAT_ANTEX_ADPCME  = $0033 ; /* Antex ADPCME */
#WAVE_FORMAT_CONTROL_RES_VQLPC = $0034 ; /* Control Res VQLPC */
#WAVE_FORMAT_DIGIREAL      = $0035 ; /* Digireal */
#WAVE_FORMAT_DIGIADPCM     = $0036 ; /* DigiADPCM */
#WAVE_FORMAT_CONTROL_RES_CR10  = $0037 ; /* Control Res CR10 */
#WAVE_FORMAT_VBXADPCM      = $0038 ; /* NMS VBXADPCM */
#WAVE_FORMAT_ROLAND_RDAC   = $0039 ; /* Roland RDAC */
#WAVE_FORMAT_ECHOSC3       = $003A ; /* EchoSC3 */
#WAVE_FORMAT_ROCKWELL_ADPCM = $003B ; /* Rockwell ADPCM */
#WAVE_FORMAT_ROCKWELL_DIGITALK = $003C ; /* Rockwell Digit LK */
#WAVE_FORMAT_XEBEC         = $003D ; /* Xebec */
#WAVE_FORMAT_G721_ADPCM    = $0040 ; /* Antex Electronics G.721 */
#WAVE_FORMAT_G728_CELP     = $0041 ; /* G.728 CELP */
#WAVE_FORMAT_MSG723        = $0042 ; /* MSG723 */
#WAVE_FORMAT_MPEG          = $0050 ; /* MPEG Layer 1,2 */
#WAVE_FORMAT_RT24          = $0051 ; /* RT24 */
#WAVE_FORMAT_PAC           = $0051 ; /* PAC */
#WAVE_FORMAT_MPEGLAYER3    = $0055 ; /* MPEG Layer 3 */
#WAVE_FORMAT_CIRRUS        = $0059 ; /* Cirrus */
#WAVE_FORMAT_ESPCM         = $0061 ; /* ESPCM */
#WAVE_FORMAT_VOXWARE       = $0062 ; /* Voxware (obsolete) */
#WAVE_FORMAT_CANOPUS_ATRAC = $0063 ; /* Canopus Atrac */
#WAVE_FORMAT_G726_ADPCM    = $0064 ; /* G.726 ADPCM */
#WAVE_FORMAT_G722_ADPCM    = $0065 ; /* G.722 ADPCM */
#WAVE_FORMAT_DSAT          = $0066 ; /* DSAT */
#WAVE_FORMAT_DSAT_DISPLAY  = $0067 ; /* DSAT Display */
#WAVE_FORMAT_VOXWARE_BYTE_ALIGNED = $0069 ; /* Voxware Byte Aligned (obsolete) */
#WAVE_FORMAT_VOXWARE_AC8   = $0070 ; /* Voxware AC8 (obsolete) */
#WAVE_FORMAT_VOXWARE_AC10  = $0071 ; /* Voxware AC10 (obsolete) */
#WAVE_FORMAT_VOXWARE_AC16  = $0072 ; /* Voxware AC16 (obsolete) */
#WAVE_FORMAT_VOXWARE_AC20  = $0073 ; /* Voxware AC20 (obsolete) */
#WAVE_FORMAT_VOXWARE_RT24  = $0074 ; /* Voxware MetaVoice (obsolete) */
#WAVE_FORMAT_VOXWARE_RT29  = $0075 ; /* Voxware MetaSound (obsolete) */
#WAVE_FORMAT_VOXWARE_RT29HW  = $0076 ; /* Voxware RT29HW (obsolete) */
#WAVE_FORMAT_VOXWARE_VR12  = $0077 ; /* Voxware VR12 (obsolete) */
#WAVE_FORMAT_VOXWARE_VR18  = $0078 ; /* Voxware VR18 (obsolete) */
#WAVE_FORMAT_VOXWARE_TQ40  = $0079 ; /* Voxware TQ40 (obsolete) */
#WAVE_FORMAT_SOFTSOUND     = $0080 ; /* Softsound */
#WAVE_FORMAT_VOXWARE_TQ60  = $0081 ; /* Voxware TQ60 (obsolete) */
#WAVE_FORMAT_MSRT24        = $0082 ; /* MSRT24 */
#WAVE_FORMAT_G729A         = $0083 ; /* G.729A */
#WAVE_FORMAT_MVI_MV12      = $0084 ; /* MVI MV12 */
#WAVE_FORMAT_DF_G726       = $0085 ; /* DF G.726 */
#WAVE_FORMAT_DF_GSM610     = $0086 ; /* DF GSM610 */
#WAVE_FORMAT_ISIAUDIO      = $0088 ; /* ISIAudio */
#WAVE_FORMAT_ONLIVE        = $0089 ; /* Onlive */
#WAVE_FORMAT_SBC24         = $0091 ; /* SBC24 */
#WAVE_FORMAT_DOLBY_AC3_SPDIF = $0092 ; /* Dolby AC3 SPDIF */
#WAVE_FORMAT_ZYXEL_ADPCM   = $0097 ; /* ZyXEL ADPCM */
#WAVE_FORMAT_PHILIPS_LPCBB = $0098 ; /* Philips LPCBB */
#WAVE_FORMAT_PACKED        = $0099 ; /* Packed */
#WAVE_FORMAT_RHETOREX_ADPCM  = $0100 ; /* Rhetorex ADPCM */
#WAVE_FORMAT_IRAT          = $0101 ; /* BeCubed Software's IRAT */
#WAVE_FORMAT_VIVO_G723     = $0111 ; /* Vivo G.723 */
#WAVE_FORMAT_VIVO_SIREN    = $0112 ; /* Vivo Siren */
#WAVE_FORMAT_DIGITAL_G723  = $0123 ; /* Digital G.723 */
#WAVE_FORMAT_CREATIVE_ADPCM  = $0200 ; /* Creative ADPCM */
#WAVE_FORMAT_CREATIVE_FASTSPEECH8 = $0202 ; /* Creative FastSpeech8 */
#WAVE_FORMAT_CREATIVE_FASTSPEECH10 = $0203 ; /* Creative FastSpeech10 */
#WAVE_FORMAT_QUARTERDECK   = $0220 ; /* Quarterdeck */
#WAVE_FORMAT_FM_TOWNS_SND  = $0300 ; /* FM Towns Snd */
#WAVE_FORMAT_BTV_DIGITAL   = $0400 ; /* BTV Digital */
#WAVE_FORMAT_VME_VMPCM     = $0680 ; /* VME VMPCM */
#WAVE_FORMAT_OLIGSM        = $1000 ; /* OLIGSM */
#WAVE_FORMAT_OLIADPCM      = $1001 ; /* OLIADPCM */
#WAVE_FORMAT_OLICELP       = $1002 ; /* OLICELP */
#WAVE_FORMAT_OLISBC        = $1003 ; /* OLISBC */
#WAVE_FORMAT_OLIOPR        = $1004 ; /* OLIOPR */
#WAVE_FORMAT_LH_CODEC      = $1100 ; /* LH Codec */
#WAVE_FORMAT_NORRIS        = $1400 ; /* Norris */
#WAVE_FORMAT_ISIAUDIO2     = $1401 ; /* ISIAudio */
#WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS = $1500 ; /* Soundspace Music Compression */
#WAVE_FORMAT_DVM           = $2000 ; /* DVM */
#WAVE_FORMAT_EXTENSIBLE    = $FFFE ; /* SubFormat */
#WAVE_FORMAT_DEVELOPMENT   = $FFFF ; /* Development */

; /*?#WAVE_FORMAT_IBM_MULAW  = $0101 IBM MULAW? */
; /*?#WAVE_FORMAT_IBM_ALAW   = $0102 IBM ALAW? */
; /*?#WAVE_FORMAT_IBM_ADPCM  = $0103 IBM ADPCM? */
; /*?#WAVE_FORMAT_DIVX_AUDIO160  = $00000160 DivX Audio? */
; /*?#WAVE_FORMAT_DIVX_AUDIO161  = $00000161 DivX Audio? */





#MCI_MONO         =  0  ;mono
#MCI_STEREO       =  1  ;stereo
#MCI_MULTIMONO    =  2  ;mono multichannel (channels can be 2, 3, 4, ...)
#MCI_MULTISTEREO  =  3  ;stereo multichannel (channels must be 4, 6, 8, ...)
#MCI_MULTICHANNEL =  4  ;multichannel (requires additional MINF-chunks) (future)

;---- possible values for mhdr_Compression

#MCOMP_NONE       =  0  ;no compression
#MCOMP_FIBDELTA   =  1  ;'Fibonacci Delta Compression' as used in 8SVX
#MCOMP_ALAW       =  2  ;16->8 bit, European PCM standard A-Law
#MCOMP_ULAW       =  3  ;16->8 bit, American PCM standard 5-Law
#MCOMP_ADPCM2     =  4  ;16->2 bit, ADPCM compression
#MCOMP_ADPCM3     =  5  ;16->3 bit, ADPCM compression
#MCOMP_ADPCM4     =  6  ;16->4 bit, ADPCM compression

; types of 8svx fies
#svxtype_left   = 2
#svxtype_right  = 4
#svxtype_stereo = 6

#svx_comp_none     = 0
#svx_comp_fibdelta = 1

.FFA_NEWTYPES
NEWTYPE.afileinfo
form.l              ; fileformat
flength.l           ; frame length
slength.l           ; sample length
blength.l           ; byte length
datapos.l           ; position des data chunks
headerpos.l
byteorder.b
encoding.b
samplerate.l
bits.b
channels.b
signed.b
framesize.b
cframesize.b ; compressed frame size
dummy.b
mode.b
quality.b
accessmode.w
rootkey.b
fine.b
sample_start.l
sample_end.l
loop_start.l
loop_end.l
seekpos.l ; seek pos in sampleframes
brain.l   ; multi purpose memory
brain_size.l
user_data.l
End NEWTYPE

NEWTYPE.chunk_form
FORM.l
size.l
formtype.l
End NEWTYPE

NEWTYPE.chunk_maud
MHDR.l
size.l
mhdr_Samples.l       ;number of samples stored in MDAT
mhdr_SampleSizeC.w   ;number of bits per sample as stored in MDAT
mhdr_SampleSizeU.w   ;number of bits per sample after decompression
mhdr_RateSource.l    ;clock source frequency (see maud.doc)
mhdr_RateDevide.w    ;clock devide           (see maud.doc)
mhdr_ChannelInfo.w   ;channel information (see below)
mhdr_Channels.w      ;number of channels (mono: 1, stereo: 2, ...)
mhdr_Compression.w   ;compression type (see below)
mhdr_Reserved1.l     ;MUST be set to 0 when saving
mhdr_Reserved2.l     ;MUST be set to 0 when saving
mhdr_Reserved3.l     ;MUST be set to 0 when saving
End NEWTYPE


NEWTYPE.chunk_fmt
fmt.l                            ;
size.l                           ;
form.w           ; =1 for PCM    ; 4   4
channels.w                       ; 2   6
samplerate.l                     ; 4   10
bytes_per_sec.l                  ; 4   14
framesize.w                      ; 2   16
bits.w                           ; 2   18
End NEWTYPE

NEWTYPE.SampleLoop
dwIdentifier.l
dwType.l
dwStart.l
dwEnd.l
dwFraction.l
dwPlayCount.l
End NEWTYPE

NEWTYPE.chunk_smpl
smpl.l
size.l
dwManufacturer.l
dwProduct.l
dwSamplePeriod.l
dwMIDIUnityNote.l     ; rootkey
dwMIDIPitchFraction.l ; finetune +- 50cent
dwSMPTEFormat.l
dwSMPTEOffset.l
cSampleLoops.l        ; Anzahl der Sampleloops
cbSamplerData.l       ; Laenge des SamplerSpez. Daten am Ende
;Loops.SampleLoop[1024]
End NEWTYPE



NEWTYPE.chunk_comm
COMM.l                   ; 0
size.l                   ; 4
channels.w               ; 8
sampleframes.l           ; 10
bits.w         ; in Bits ; 14
samplerate.extended      ; 16
pad.w                    ; 24
compression.l            ; 26
End NEWTYPE

NEWTYPE.chunk_ssnd
SSND.l                   ; 0
size.l                   ; 4
offset.l                 ; 8
blocksize.l
End NEWTYPE


NEWTYPE.chunk_data
DAT.l
size.l
End NEWTYPE


NEWTYPE.chunk_vhdr
VHDR.l
size.l
OneShotHiSamples.l
RepeatHiSamples.l
SamplesPerHiCycle.l
Samplerate.w
Octaves.b
Compression.b
Gain.q
End NEWTYPE



NEWTYPE.chunk_chan
CHAN.l
size.l
sampletype.l
End NEWTYPE

NEWTYPE.chunk_sysex_header
_F0.b
_7E.b
cc.b           ; sysex channel
_01.b
id_l.b         ; ID number low
id_h.b         ; ID number high
bits.b         ; bit resolution of sample
period_l.b     ; period in nanoseconds = 1.000.000.000/samplerate
period_m.b
period_h.b
length_l.b     ; length in words
length_m.b
length_h.b
loop_start_l.b ; loop start point in words
loop_start_m.b
loop_start_h.b
loop_end_l.b   ; loop end point in words
loop_end_m.b
loop_end_h.b
loop_type.b    ; 0 = foreward, 01 = bw/fw, 7F = no loop
_F7.b
End NEWTYPE
#sizeof_chunk_sysex_header = 21

NEWTYPE.chunk_sysex_data
_F0.b
_7E.b
cc.b   ; sysex channel
_02.b
packetID.b ; 0...127
dat.b[120]; 120 bytes
ll.b
_F7.b
;_______________ additional data
offset.l
cframesize.l
End NEWTYPE
#sizeof_chunk_sysex_data = 127

NEWTYPE.adpcmblockheader_tag_mono
bPredictor.b[1]
iDelta.l[1]
iSamp1.l[1]
iSamp2.l[1]
End NEWTYPE

NEWTYPE.adpcmblockheader_tag_stereo
bPredictor.b[2]
iDelta.l[2]
iSamp1.l[2]
iSamp2.l[2]
End NEWTYPE
 


Dim ADPCM_StepTab.w(89)
ADPCM_StepTab.w( 0) = 7
ADPCM_StepTab.w( 1) = 8
ADPCM_StepTab.w( 2) = 9
ADPCM_StepTab.w( 3) = 10
ADPCM_StepTab.w( 4) = 11
ADPCM_StepTab.w( 5) = 12
ADPCM_StepTab.w( 6) = 13
ADPCM_StepTab.w( 7) = 14
ADPCM_StepTab.w( 8) = 16
ADPCM_StepTab.w( 9) = 17
ADPCM_StepTab.w(10) = 19
ADPCM_StepTab.w(11) = 21
ADPCM_StepTab.w(12) = 23
ADPCM_StepTab.w(13) = 25
ADPCM_StepTab.w(14) = 28
ADPCM_StepTab.w(15) = 31
ADPCM_StepTab.w(16) = 34
ADPCM_StepTab.w(17) = 37
ADPCM_StepTab.w(18) = 41
ADPCM_StepTab.w(19) = 45
ADPCM_StepTab.w(20) = 50
ADPCM_StepTab.w(21) = 55
ADPCM_StepTab.w(22) = 60
ADPCM_StepTab.w(23) = 66
ADPCM_StepTab.w(24) = 73
ADPCM_StepTab.w(25) = 80
ADPCM_StepTab.w(26) = 88
ADPCM_StepTab.w(27) = 97
ADPCM_StepTab.w(28) = 107
ADPCM_StepTab.w(29) = 118
ADPCM_StepTab.w(30) = 130
ADPCM_StepTab.w(31) = 143
ADPCM_StepTab.w(32) = 157
ADPCM_StepTab.w(33) = 173
ADPCM_StepTab.w(34) = 190
ADPCM_StepTab.w(35) = 209
ADPCM_StepTab.w(36) = 230
ADPCM_StepTab.w(37) = 253
ADPCM_StepTab.w(38) = 279
ADPCM_StepTab.w(39) = 307
ADPCM_StepTab.w(40) = 337
ADPCM_StepTab.w(41) = 371
ADPCM_StepTab.w(42) = 408
ADPCM_StepTab.w(43) = 449
ADPCM_StepTab.w(44) = 494
ADPCM_StepTab.w(45) = 544
ADPCM_StepTab.w(46) = 598
ADPCM_StepTab.w(47) = 658
ADPCM_StepTab.w(48) = 724
ADPCM_StepTab.w(49) = 796
ADPCM_StepTab.w(50) = 876
ADPCM_StepTab.w(51) = 963
ADPCM_StepTab.w(52) = 1060
ADPCM_StepTab.w(53) = 1166
ADPCM_StepTab.w(54) = 1282
ADPCM_StepTab.w(55) = 1411
ADPCM_StepTab.w(56) = 1552
ADPCM_StepTab.w(57) = 1707
ADPCM_StepTab.w(58) = 1878
ADPCM_StepTab.w(59) = 2066
ADPCM_StepTab.w(60) = 2272
ADPCM_StepTab.w(61) = 2499
ADPCM_StepTab.w(62) = 2749
ADPCM_StepTab.w(63) = 3024
ADPCM_StepTab.w(64) = 3327
ADPCM_StepTab.w(65) = 3660
ADPCM_StepTab.w(66) = 4026
ADPCM_StepTab.w(67) = 4428
ADPCM_StepTab.w(68) = 4871
ADPCM_StepTab.w(69) = 5358
ADPCM_StepTab.w(70) = 5894
ADPCM_StepTab.w(71) = 6484
ADPCM_StepTab.w(72) = 7132
ADPCM_StepTab.w(73) = 7845
ADPCM_StepTab.w(74) = 8630
ADPCM_StepTab.w(75) = 9493
ADPCM_StepTab.w(76) = 10442
ADPCM_StepTab.w(77) = 11487
ADPCM_StepTab.w(78) = 12635
ADPCM_StepTab.w(79) = 13899
ADPCM_StepTab.w(80) = 15289
ADPCM_StepTab.w(81) = 16818
ADPCM_StepTab.w(82) = 18500
ADPCM_StepTab.w(83) = 20350
ADPCM_StepTab.w(84) = 22385
ADPCM_StepTab.w(85) = 24623
ADPCM_StepTab.w(86) = 27086
ADPCM_StepTab.w(87) = 29794
ADPCM_StepTab.w(88) = 32767

Dim ADPCM_IndexTab4Bit.w(16)
ADPCM_IndexTab4Bit.w( 0) = -1 ; 0
ADPCM_IndexTab4Bit.w( 1) = -1 ; 1
ADPCM_IndexTab4Bit.w( 2) = -1 ; 2
ADPCM_IndexTab4Bit.w( 3) = -1 ; 3
ADPCM_IndexTab4Bit.w( 4) =  2 ; 4
ADPCM_IndexTab4Bit.w( 5) =  4 ; 5
ADPCM_IndexTab4Bit.w( 6) =  6 ; 6
ADPCM_IndexTab4Bit.w( 7) =  8 ; 7
ADPCM_IndexTab4Bit.w( 8) = -1
ADPCM_IndexTab4Bit.w( 9) = -1
ADPCM_IndexTab4Bit.w(10) = -1
ADPCM_IndexTab4Bit.w(11) = -1
ADPCM_IndexTab4Bit.w(12) =  2
ADPCM_IndexTab4Bit.w(13) =  4
ADPCM_IndexTab4Bit.w(14) =  6
ADPCM_IndexTab4Bit.w(15) =  8

Dim ADPCM_IndexTab3Bit.w(8)
ADPCM_IndexTab3Bit.w(0) = -1
ADPCM_IndexTab3Bit.w(1) = -1
ADPCM_IndexTab3Bit.w(2) =  1
ADPCM_IndexTab3Bit.w(3) =  2
ADPCM_IndexTab3Bit.w(4) = -1
ADPCM_IndexTab3Bit.w(5) = -1
ADPCM_IndexTab3Bit.w(6) =  1
ADPCM_IndexTab3Bit.w(7) =  2


.FFA_VARIABLES
DEFTYPE.chunk_form chunk_form
DEFTYPE.chunk_comm chunk_comm
DEFTYPE.chunk_maud chunk_maud
DEFTYPE.chunk_data chunk_data
DEFTYPE.chunk_ssnd chunk_ssnd
DEFTYPE.chunk_vhdr chunk_vhdr
DEFTYPE.chunk_data chunk_anno
DEFTYPE.chunk_fmt  chunk_fmtw
DEFTYPE.chunk_chan chunk_chan
DEFTYPE.chunk_smpl chunk_smpl
DEFTYPE.SampleLoop SampleLoop
NEWTYPE.ffa_base
showerr.w
End NEWTYPE

DEFTYPE.ffa_base ffa_base
Dim afileinfo.afileinfo(#max_files-1)   ; max_files is defined in file.include and is set to Maximum(Files)

ffa_workbuffer.l = AllocVec_(#ffa_workbuffersize,#MEMF_ANY)
If ffa_workbuffer = False Then error{"Unable to allocate workbuffer for audiofiles!"}:End


.FFA
USEPATH afileinfo(fid)
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = _ffa_CheckFormOK{channels.l,bits.l,samplerate.l,byte:: /
;/ order.l,compression.l}                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - channels.l    : number of channels (1=mono, 2=stereo)                     /
;/ - bits.l        : number of bits (usually 8, 16 or 24)                      /
;/ - samplerate.l  : ???                                                       /
;/ - byteorder.l   : ???                                                       /
;/ - compression.l : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ffa_CheckFormOK{channels.l,bits.l,samplerate.l,byteorder.l,encoding.l}
succ.l = True

If bits><16 AND bits><8 AND bits><24 AND bits><32
  succ = False
  If bits=0
    error{"Unsupported compression format!"}
  Else
    error{"No support for "+Str$(bits)+"bit audiodata!"}
  End If
End If

If channels><2 AND channels><1  Then succ = False:error{"No support for "+Str$(channels)+" channels!"}

If samplerate<#FFAMIN_SAMPLERATE
  succ = False
  error{Str$(samplerate)+"Hz samplerate is too low!"}
End If

If samplerate>#FFAMAX_SAMPLERATE Then succ = False:error{Str$(samplerate)+"Hz samplerate is too high!"}

If byteorder><#FFABO_LITTLEENDIAN AND byteorder><#FFABO_BIGENDIAN Then succ = False:error{"Unknown byteorder!"}

Select encoding
  Case #FFAE_FLOAT32   : If bits><32 Then succ=False ; only 32bit floats
  Case #FFAE_SYSEX
  Case #FFAE_MPEGA
  Case #FFAE_RAW
  Case #FFAE_MOD
  Case #FFAE_ADPCM2    : If bits><16 Then succ=False
  Case #FFAE_ADPCM3    : If bits><16 Then succ=False
  Case #FFAE_ADPCM4    : If bits><16 Then succ=False
  Case #FFAE_ADPCM6    : If bits><16 Then succ=False
  Case #FFAE_ADPCM8    : If bits><16 Then succ=False
  Case #FFAE_ADDPCM2   : If bits><16 Then succ=False
  Case #FFAE_ADDPCM3   : If bits><16 Then succ=False
  Case #FFAE_ADDPCM4   : If bits><16 Then succ=False
  Case #FFAE_ADDPCM6   : If bits><16 Then succ=False
  Case #FFAE_ADDPCM8   : If bits><16 Then succ=False
  Case #FFAE_UNKNOWN   : succ=False
  Default
    error{"Unsupported encoding/compression!"}
    succ=False
End Select
Function Return succ
End Function


;XINCLUDE "xlog.include.bb2"

Dim ffa_ADPCM2.l($03)
Dim ffa_ADPCM3.l($07)
Dim ffa_ADPCM4.l($0f)
Dim ffa_ADPCM5.l($1f)
Dim ffa_ADPCM6.l($3F)
Dim ffa_ADPCM8.l($FF)

#FFA_ADPCM2_MAXFB = 12
#FFA_ADPCM2_MINFB = 0
#FFA_ADPCM2_LOW   = $1
#FFA_ADPCM2_HI    = $3 - $1

#FFA_ADPCM3_MAXFB = 12
#FFA_ADPCM3_MINFB = 0
#FFA_ADPCM3_LOW   = $1
#FFA_ADPCM3_HI    = $7 - $3

#FFA_ADPCM4_MAXFB = 12
#FFA_ADPCM4_MINFB = 0
#FFA_ADPCM4_LOW   = $1
#FFA_ADPCM4_HI    = $F - $3

#FFA_ADPCM5_MAXFB = 12
#FFA_ADPCM5_MINFB = 0
#FFA_ADPCM5_LOW   = $1
#FFA_ADPCM5_HI    = $1F - $0F

#FFA_ADPCM6_MAXFB = 12
#FFA_ADPCM6_MINFB = 0
#FFA_ADPCM6_LOW   = $1
#FFA_ADPCM6_HI    = $3F - $1F

#FFA_ADPCM8_MAXFB = 12
#FFA_ADPCM8_MINFB = 0
#FFA_ADPCM8_LOW   = $1
#FFA_ADPCM8_HI    = $FF - $7F

#FFA_ADPCM_BLOCKSIZE = $400

ffa_ADPCM2($00) =     1
ffa_ADPCM3($00) =     1
ffa_ADPCM4($00) =     1
ffa_ADPCM5($00) =     1
ffa_ADPCM6($00) =     1
ffa_ADPCM8($00) =     1
ffa_ADPCM2($01) =     -1
ffa_ADPCM3($01) =     -1
ffa_ADPCM4($01) =     -1
ffa_ADPCM5($01) =     -1
ffa_ADPCM6($01) =     -1
ffa_ADPCM8($01) =     -1

fib_p1.l = 1
fib_p2.l = 1
fibi2.l  = 2
fibi3.l  = 2
fibi4.l  = 2
fibi5.l  = 2
fibi6.l  = 2
fibi8.l  = 2
d8.l = 8
For n.l=0 To $7F
  fib.l = fib_p1+fib_p2
  If fibi2<=$03 Then ffa_ADPCM2(fibi2) =  fib*2 : fibi2+1
  If fibi2<=$03 Then ffa_ADPCM2(fibi2) = -fib*2 : fibi2+1

  If fibi3<=$07 Then ffa_ADPCM3(fibi3) =  fib : fibi3+1
  If fibi3<=$07 Then ffa_ADPCM3(fibi3) = -fib : fibi3+1

  If fibi4<=$0F Then ffa_ADPCM4(fibi4) =  fib : fibi4+1
  If fibi4<=$0F Then ffa_ADPCM4(fibi4) = -fib : fibi4+1

  If fibi5<=$1F Then ffa_ADPCM5(fibi5) = (fib*1 + fib_p1*1)/2 : fibi5+1 : If ffa_ADPCM5(fibi5-1)<=-ffa_ADPCM5(fibi5-2) Then ffa_ADPCM5(fibi5-1)=-ffa_ADPCM5(fibi5-2)+1
  If fibi5<=$1F Then ffa_ADPCM5(fibi5) = -ffa_ADPCM5(fibi5-1) : fibi5+1
  If fibi5<=$1F Then ffa_ADPCM5(fibi5) = (fib*2 + fib_p1*0)/2 : fibi5+1 : If ffa_ADPCM5(fibi5-1)<=-ffa_ADPCM5(fibi5-2) Then ffa_ADPCM5(fibi5-1)=-ffa_ADPCM5(fibi5-2)+1
  If fibi5<=$1F Then ffa_ADPCM5(fibi5) = -ffa_ADPCM5(fibi5-1) : fibi5+1

  If fibi6<=$3F Then ffa_ADPCM6(fibi6) = (fib*1 + fib_p1*3)/4 : fibi6+1 : If ffa_ADPCM6(fibi6-1)<=-ffa_ADPCM6(fibi6-2) Then ffa_ADPCM6(fibi6-1)=-ffa_ADPCM6(fibi6-2)+1
  If fibi6<=$3F Then ffa_ADPCM6(fibi6) = -ffa_ADPCM6(fibi6-1) : fibi6+1
  If fibi6<=$3F Then ffa_ADPCM6(fibi6) = (fib*2 + fib_p1*2)/4 : fibi6+1 : If ffa_ADPCM6(fibi6-1)<=-ffa_ADPCM6(fibi6-2) Then ffa_ADPCM6(fibi6-1)=-ffa_ADPCM6(fibi6-2)+1
  If fibi6<=$3F Then ffa_ADPCM6(fibi6) = -ffa_ADPCM6(fibi6-1) : fibi6+1
  If fibi6<=$3F Then ffa_ADPCM6(fibi6) = (fib*3 + fib_p1*1)/4 : fibi6+1 : If ffa_ADPCM6(fibi6-1)<=-ffa_ADPCM6(fibi6-2) Then ffa_ADPCM6(fibi6-1)=-ffa_ADPCM6(fibi6-2)+1
  If fibi6<=$3F Then ffa_ADPCM6(fibi6) = -ffa_ADPCM6(fibi6-1) : fibi6+1
  If fibi6<=$3F Then ffa_ADPCM6(fibi6) = (fib*4 + fib_p1*0)/4 : fibi6+1 : If ffa_ADPCM6(fibi6-1)<=-ffa_ADPCM6(fibi6-2) Then ffa_ADPCM6(fibi6-1)=-ffa_ADPCM6(fibi6-2)+1
  If fibi6<=$3F Then ffa_ADPCM6(fibi6) = -ffa_ADPCM6(fibi6-1) : fibi6+1

  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*1 + fib_p1* 7)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*2 + fib_p1* 6)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*3 + fib_p1* 5)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*4 + fib_p1* 4)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*5 + fib_p1* 3)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*6 + fib_p1* 2)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*7 + fib_p1* 1)/d8  : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*8 + fib_p1* 0)/d8  : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*9 + fib_p1* 3)/d8  : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*10 + fib_p1* 2)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*11 + fib_p1* 1)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*12 + fib_p1* 0)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*13 + fib_p1* 1)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*14 + fib_p1* 0)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*15 + fib_p1*0)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = (fib*16 + fib_p1*0)/d8 : fibi8+1 : If ffa_ADPCM8(fibi8-1)<=-ffa_ADPCM8(fibi8-2) Then ffa_ADPCM8(fibi8-1)=-ffa_ADPCM8(fibi8-2)+1
;  If fibi8<=$FF Then ffa_ADPCM8(fibi8) = -ffa_ADPCM8(fibi8-1)   : fibi8+1

  fib_p2 = fib_p1
  fib_p1 = fib

Next

;ffa_ADPCM2(0) = 1
;ffa_ADPCM2(1) = -1
;ffa_ADPCM2(2) = 4
;ffa_ADPCM2(3) = -4

;ffa_ADPCM4($0) =  1
;ffa_ADPCM4($1) = -1
;ffa_ADPCM4($2) =  2
;ffa_ADPCM4($3) = -8
;ffa_ADPCM4($4) =  3
;ffa_ADPCM4($5) =  5
;ffa_ADPCM4($6) =  7
;ffa_ADPCM4($7) =  11
;ffa_ADPCM4($8) =  14
;ffa_ADPCM4($9) =  17
;ffa_ADPCM4($a) =  21
;ffa_ADPCM4($b) =  27
;ffa_ADPCM4($c) =  34
;ffa_ADPCM4($d) =  43
;ffa_ADPCM4($e) = -32
;ffa_ADPCM4($f) =  64


;Format "+####0"
;For n.l=0 To $FF
;If n<=$03
;  NPrint "fib ",n," = ADPCM8:",ffa_ADPCM8(n)," ADPCM6:",ffa_ADPCM6(n)," ADPCM5:",ffa_ADPCM5(n)," ADPCM4:",ffa_ADPCM4(n)," ADPCM3:",ffa_ADPCM3(n)," ADPCM2:",ffa_ADPCM2(n)
;Else : If n<=$07
;  NPrint "fib ",n," = ADPCM8:",ffa_ADPCM8(n)," ADPCM6:",ffa_ADPCM6(n)," ADPCM5:",ffa_ADPCM5(n)," ADPCM4:",ffa_ADPCM4(n)," ADPCM3:",ffa_ADPCM3(n)
;Else : If n<=$0F
;  NPrint "fib ",n," = ADPCM8:",ffa_ADPCM8(n)," ADPCM6:",ffa_ADPCM6(n)," ADPCM5:",ffa_ADPCM5(n)," ADPCM4:",ffa_ADPCM4(n)
;Else : If n<=$1F
;  NPrint "fib ",n," = ADPCM8:",ffa_ADPCM8(n)," ADPCM6:",ffa_ADPCM6(n)," ADPCM5:",ffa_ADPCM5(n)
;Else : If n<=$3F
;  NPrint "fib ",n," = ADPCM8:",ffa_ADPCM8(n)," ADPCM6:",ffa_ADPCM6(n)
;Else : If n<=$FF
; nPrint "fib ",n," = ADPCM8:",ffa_ADPCM8(n)
;Print ffa_ADPCM8(n),","
;If n&$F = $F Then NPrint ""
;EndIf : EndIf : EndIf: EndIf : EndIf:EndIf
;Next
;Format ""
;

NEWTYPE.ffa_ADPCM_Ctx
rSampM.l
rSampS.l
cSampM.l
cSampS.l
cDeltaM.l
cDeltaS.l
fbM.l
fbS.l
cByte.b
fpos.l
End NEWTYPE

Macro ffa_EncodeADPCMx ; {channel,bits}
    rSamp`1   = Peek.w(srcP) : srcP +2       ; get the real sample

    If doDD = True
      rDelta`1 = rSamp`1 - cSamp`1 + cError`1      ; calculate the real delta to previous (compressed) sample
      rValue`1 = rDelta`1 - cDelta`1               ; calculate the delta delta
    End If

    If doDD = False
      rValue`1 = rSamp`1 - cSamp`1 + cError`1
    End If

    dmin.l = $7FFFFF                                ; set initial dmin
    cIndex`1 = $0                                ; set initial compressed value
    For i.l=0 To (1 LSL (`2))-1                    ; check all 16 possible values
      d.l = (rValue`1)-(ffa_ADPCM`2(i) * fb`1 / 256)  ; calculate distance
      If d<0 Then d=-d                             ; abs(distance)
      If d<dmin Then dmin=d : cIndex`1 = i         ; if distance is smaller, use it!
    Next

    cValue`1 = ffa_ADPCM`2(cIndex`1) * fb`1 / 256    ; get compressed delta from compress value

    If doDD = True
      cDelta`1  = cDelta`1 + cValue`1
      cSamp`1  = cSamp`1 + cDelta`1                  ; calculate the next compressed sample
    End If

    If doDD = False
      cSamp`1  = cSamp`1 + cValue`1                  ; calculate the next compressed sample
    End If

    cError`1 = (cSamp`1-rSamp`1)/2

    If cIndex`1>=#FFA_ADPCM`2_HI
      fb`1 = (fb`1+1) *150/100
    Else
      If cIndex`1<=#FFA_ADPCM`2_LOW
        fb`1 * 50/100
      End If
    End If

    errd.f = cSamp`1-rSamp`1                       ; calculate error to real sample
    err`1  = (err`1) + errd*errd

End Macro


Macro ffa_EncodeADPCM ; {channel,bits}
    cError`1 = 0;(cSamp`1-rSamp`1)/2

    rSamp`1   = Peek.w(srcP) : srcP +2       ; get the real sample

    If doDD
      rDelta`1 = rSamp`1 - cSamp`1 + cError`1      ; calculate the real delta to previous (compressed) sample
      rValue`1 = rDelta`1 - cDelta`1               ; calculate the delta delta
      ;If ((cSamp`1)>=0) Then sig.l = -1 : Else sig   = 1
    Else
      rValue`1 = rSamp`1 - cSamp`1 + cError`1
      ;If ((cSamp`1)>=0) Then sig.l = -1 : Else sig   = 1
    End If

    dmin.l = $7FFFFF                               ; set initial dmin
    cIndex`1 = $0                                  ; set initial compressed value
    For i.l=0 To (1 LSL (`2))-1                    ; check all 16 possible values
      d.l = (rValue`1)-((ffa_ADPCM`2(i) LSL fb`1)*sig)   ; calculate distance
      If d<0 Then d=-d                             ; abs(distance)
      If d<dmin
        dmin = d : cIndex`1 = i
      End If
    Next

    If doDD
      cDelDel`1 = ((ffa_ADPCM`2(cIndex`1) LSL fb`1)*sig)
      cDelta`1  = cDelta`1 +  cDelDel`1
      cSamp`1   = cSamp`1 + cDelta`1                  ; calculate the next compressed sample
    Else
      cDelta`1 = ((ffa_ADPCM`2(cIndex`1) LSL fb`1)*sig)
      cSamp`1   = cSamp`1 + ((ffa_ADPCM`2(cIndex`1) LSL fb`1)*sig)        ; calculate the next compressed sample
    End If

    If cIndex`1>=#FFA_ADPCM`2_HI
      If fb`1<#FFA_ADPCM`2_MAXFB Then fb`1+1      ; move bit shift up if very low or high
    Else
      If cIndex`1<=#FFA_ADPCM`2_LOW
        If fb`1>#FFA_ADPCM`2_MINFB Then fb`1-1    ; move bitshift down if delta was zero
      End If
    End If

    errd.f = cSamp`1-rSamp`1                       ; calculate error to real sample
    err`1  = (err`1) + errd*errd

End Macro

Macro ffa_DecodeADPCM ; {channel,bits}

    If doDD
      ;If ((cSamp`1)>=0) Then sig.l = -1 : Else sig   = 1
      cDelta`1  = cDelta`1 + ((ffa_ADPCM`2(cIndex`1) LSL fb`1)*sig)
      cSamp`1  = cSamp`1 + cDelta`1                  ; calculate the next compressed sample
    Else
      ;If ((cSamp`1)>=0) Then sig.l = -1 : Else sig   = 1
      cSamp`1   = cSamp`1   + (ffa_ADPCM`2(cIndex`1) LSL fb`1)*sig
    EndIf

    If cSamp`1>=(-$8000) AND cSamp`1<=($7FFF)
      Poke.w dstP,cSamp`1
    Else
      If cSamp`1<0
        Poke.w dstP,-$8000
      Else
        Poke.w dstP,$7FFF
      End If
    End If

    dstP+2

    If cIndex`1>=#FFA_ADPCM`2_HI
      If fb`1<#FFA_ADPCM`2_MAXFB
        fb`1+1
      End If
    Else
      If cIndex`1<=#FFA_ADPCM`2_LOW
        If fb`1>#FFA_ADPCM`2_MINFB
          fb`1-1
        End If
      End If
    EndIf
End Macro

Macro ffa_UpdateContext

    If ((n+fpos) & (#FFA_ADPCM_BLOCKSIZE-1)) = 0  ; read a full frame
      cSampL   = Peek.w(srcP) : srcP+2
      cDeltaL  = 0
      If doDD Then cDeltaL  = Peek.w(srcP) : srcP+2
      fbL      = Peek.b(srcP)&$FF : srcP+1
      cByte    = 0
      cDelDelL = 0
      cIndexL  = 0

      If channels=2
        cSampR   = Peek.w(srcP) : srcP+2
        If doDD Then cDeltaR  = Peek.w(srcP) : srcP+2
        fbR      = Peek.b(srcP)&$FF : srcP+1
      End If
    EndIf

End Macro


;/* decompress audio buffer, in-place decompression is allowed (srcP==dstP) */
Function.l _ffa_DecodeADPCM{srcP.l,dstP.l,flength.l,channels.l,bits.l,doDD.l,*ctx.ffa_ADPCM_Ctx}
  SHARED ffa_ADPCM2(),ffa_ADPCM3(),ffa_ADPCM4(),ffa_ADPCM5(),ffa_ADPCM6(),ffa_ADPCM8(),ffa_ADPCM4p()

  cSampL.l   = *ctx\cSampM           ; previous sample
  cDeltaL.l  = *ctx\cDeltaM
  cDelDelL.l = 0
  fbL.l      = *ctx\fbM              ; current bit shift
  cSampR.l   = *ctx\cSampS           ; previous sample
  cDeltaR.l  = *ctx\cDeltaS
  cDelDelR.l = 0
  fbR.l      = *ctx\fbS              ; current bit shift
  cByte.b    = *ctx\cByte
  cIndexL.l  = 0
  cIndexR.l  = 0
  fpos.l     = *ctx\fpos
  dstPBase.l = dstP
  sig.l      = 1

  Select bits
    Case 2
      If channels=2
        For n.l=0 To flength-1
          !ffa_UpdateContext
          Select ((n+fpos)&1)
            Case 0 : cByte = Peek.b(srcP) : srcP+1
                     cIndexL = (cByte & %00000011) LSR 0
                     cIndexR = (cByte & %00001100) LSR 2
            Case 1 : cIndexL = (cByte & %00110000) LSR 4
                     cIndexR = (cByte & %11000000) LSR 6
          End Select
          !ffa_DecodeADPCM{L,2}
          !ffa_DecodeADPCM{R,2}
        Next
      Else
        For n.l=0 To flength-1
          !ffa_UpdateContext
          Select ((n+fpos)&3)
            Case 0 : cByte = Peek.b(srcP) : srcP+1
                     cIndexL = (cByte & %00000011) LSR 0
            Case 1 : cIndexL = (cByte & %00001100) LSR 2
            Case 2 : cIndexL = (cByte & %00110000) LSR 4
            Case 3 : cIndexL = (cByte & %11000000) LSR 6
          End Select
          !ffa_DecodeADPCM{L,2}
        Next
      End If

    Case 4
      If channels=2
        For n.l=0 To flength-1
          !ffa_UpdateContext
          cByte.b = Peek.b(srcP) :srcP+1
          cIndexL = (cByte & $0F) LSR 0
          cIndexR = (cByte & $F0) LSR 4
          !ffa_DecodeADPCM{L,4}
          !ffa_DecodeADPCM{R,4}
        Next
      Else
        For n.l=0 To flength-1
          !ffa_UpdateContext
          Select ((n+fpos)&1)
            Case 0 : cByte = Peek.b(srcP) : srcP+1
                     cIndexL = (cByte & %00001111) LSR 0
            Case 1 : cIndexL = (cByte & %11110000) LSR 4
          End Select
          !ffa_DecodeADPCM{L,4}
        Next
      End If

    Case 8
      If channels=2
        For n.l=0 To flength-1
          !ffa_UpdateContext
          cIndexL = Peek.b(srcP)&$FF : srcP+1
          !ffa_DecodeADPCM{L,8}
          cIndexR = Peek.b(srcP)&$FF : srcP+1
          !ffa_DecodeADPCM{R,8}
        Next
      Else
        For n.l=0 To flength-1
          !ffa_UpdateContext
          cIndexL = Peek.b(srcP)&$FF : srcP+1
          !ffa_DecodeADPCM{L,8}
        Next
      End If

  End Select

  *ctx\cSampM  = cSampL           ; previous sample
  *ctx\cDeltaM = cDeltaL
  *ctx\fbM     = fbL              ; current bit shift
  *ctx\cSampS  = cSampR           ; previous sample
  *ctx\cDeltaS = cDeltaR
  *ctx\fbS     = fbR              ; current bit shift
  *ctx\cByte   = cByte
  *ctx\fpos    + flength

  Function Return (dstP-dstPBase)
End Function


Function.l _ffa_EncodeADPCM{srcP.l,dstP.l,flength.l,channels.l,bits.l,doDD.l,*ctx.ffa_ADPCM_Ctx}
  SHARED ffa_ADPCM2(),ffa_ADPCM3(),ffa_ADPCM4(),ffa_ADPCM5(),ffa_ADPCM6(),ffa_ADPCM8(),ffa_ADPCM4p()

  rSampL.l   = *ctx\rSampM ; real sample
  rSampR.l   = *ctx\rSampS
  rDeltaL.l  = 0           ; real delta
  rDeltaR.l  = 0           ; real delta
  rDelDelL.l = 0
  rDelDelR.l = 0

  cSampL.l   = *ctx\cSampM           ; previous sample
  cSampR.l   = *ctx\cSampS           ; previous sample
  cDeltaL.l  = *ctx\cDeltaM
  cDeltaR.l  = *ctx\cDeltaS
  cDelDelL.l = 0
  cDelDelR.l = 0

  rValueL.l  = 0
  rValueR.l  = 0
  cValueL.l  = 0
  cValueR.l  = 0
  cIndexL.l  = 0
  cIndexR.l  = 0
  cErrorL.l  = 0
  cErrorR.l  = 0

  fbL.l      = *ctx\fbM              ; current bit shift
  fbR.l      = *ctx\fbS              ; current bit shift

  cByte.b    = *ctx\cByte            ; last half-encoded byte
  fpos.l     = *ctx\fpos
  dstPBase.l = dstP
  sig.l      = 1

  errR.f     = 0          ; for error statistics
  errL.f     = 0          ; for error statistics

  For n.l=0 To flength-1     ; for each sample
    oSampL.l = rSampL

    If ((n+fpos) & (#FFA_ADPCM_BLOCKSIZE-1)) = 0  ; write a full frame
      Poke.w dstP, cSampL  : dstP+2
      If doDD Then Poke.w dstP, cDeltaL : dstP+2
      Poke.b dstP, fbL     : dstP+1
      If channels=2
        Poke.w dstP, cSampR  : dstP+2
        If doDD Then Poke.w dstP, cDeltaR : dstP+2
        Poke.b dstP, fbR     : dstP+1
      End If
    EndIf

    Select bits
      Case 2
        If channels=2
          !ffa_EncodeADPCM{L,2}
          !ffa_EncodeADPCM{R,2}
          Select ((n+fpos)&$01)
            Case 0 : cByte =  (((cIndexL&$03) LSL 0) | ((cIndexR&$03) LSL 2))
            Case 1 : cByte |  (((cIndexL&$03) LSL 4) | ((cIndexR&$03) LSL 6))
              Poke.b dstP, cByte : dstP+1
          End Select
        Else
          !ffa_EncodeADPCM{L,2}
          Select ((n+fpos)&$03)
            Case 0 : cByte = ((cIndexL&$03) LSL 0)
            Case 1 : cByte | ((cIndexL&$03) LSL 2)
            Case 2 : cByte | ((cIndexL&$03) LSL 4)
            Case 3 : cByte | ((cIndexL&$03) LSL 6)
              Poke.b dstP, cByte : dstP+1
          End Select
        End If

      Case 4
        If channels=2
          !ffa_EncodeADPCM{L,4}
          !ffa_EncodeADPCM{R,4}
          cByte.b = (cIndexL&$0F) | ((cIndexR&$0F) LSL 4)
          Poke.b dstP,cByte: dstP+1
        Else
          !ffa_EncodeADPCM{L,4}
          Select ((n+fpos)&$01)
            Case 0 : cByte =  ((cIndexL&$0F) LSL 0)
            Case 1 : cByte |  ((cIndexL&$0F) LSL 4)
              Poke.b dstP, cByte : dstP+1
          End Select
        End If

      Case 8
        If channels=2
          !ffa_EncodeADPCM{L,8}
          !ffa_EncodeADPCM{R,8}
          Poke.b dstP,cIndexL : dstP+1
          Poke.b dstP,cIndexR : dstP+1
        Else
          !ffa_EncodeADPCM{L,8}
          Poke.b dstP,cIndexL : dstP+1
        End If

      Default
        NPrint "Unsuported bits"
        n=flength

    End Select

    ooDelta.l = oDelta.l
    oDelta.l  = oSampL-rSampL
    oDelDel.l = oDelta-ooDelta
    dda.f + Abs(oDelDel)
    da.f  + Abs(oDelta)
    sa.f  + Abs(rSampL)

  Next
  *ctx\rSampM    = rSampL           ; previous sample
  *ctx\cSampM    = cSampL           ; previous sample
  *ctx\fbM       = fbL              ; current bit shift
  *ctx\cDeltaM   = cDeltaL
  *ctx\rSampS    = rSampR           ; previous sample
  *ctx\cSampS    = cSampR           ; previous sample
  *ctx\fbS       = fbR              ; current bit shift
  *ctx\cDeltaS   = cDeltaR
  *ctx\cByte     = cByte
  *ctx\fpos      + flength

  ;xlog_Close{}
  errL = Sqr(errL/flength)
  errR = Sqr(errR/flength)
  dda / flength                     ; do statistics
  da / flength
  sa / flength
  If doDD Then name.s="ADDPCM" : Else name="ADPCM "
  If channels=2 Then name+"(stereo)":Else name+"(mono)  "
  name+Str$(bits)+"bit"
  error{name+" = "+Str$((errL))+"|"+Str$((errR))+"/"+Str$(flength) + "  Statistics: S="+Str$(sa)+" D="+Str$(da)+" DD="+Str$(dda)}

  Function Return dstP-dstPBase
End Function



;/* decompress audio buffer, in-place decompression is allowed (srcP==dstP) */
Statement _ffa_DecodeADDPCM4_fast{srcP.l,dstP.l,flength.l,*ctx.ffa_ADPCM_Ctx}
  SHARED ffa_ADPCM4()

  cDelta.l = *ctx\cDeltaM
  cSamp.l  = *ctx\cSampM           ; previous sample
  fb.l     = *ctx\fbM              ; current bit shift

  For n.l=0 To flength-1
    If (n & 1)
      cIndex.l = (c.b & $F0) LSR 4
    Else
      c.b = Peek.b(srcP) :srcP+1 : cIndex.l = c & $0F
    End If

    cDelta.l = cDelta + (ffa_ADPCM4(cIndex) LSL fb)
    cSamp = cSamp + cDelta
    Poke.w dstP,cSamp : dstP+2

    If cIndex>=#FFA_ADPCM4_HI
      If fb<#FFA_ADPCM4_MAXFB Then fb+1
    Else
      If cIndex<=#FFA_ADPCM4_LOW Then If fb>#FFA_ADPCM4_MINFB Then fb-1
    EndIf
  Next

  *ctx\cSampM  = cSamp           ; previous sample
  *ctx\cDeltaM = cDelta
  *ctx\fbM     = fb              ; current bit shift
  *ctx\fpos    + flength

End Statement

;/* decompress audio buffer, in-place decompression is allowed (srcP==dstP) */
Statement _ffa_DecodeADPCM4_fast{srcP.l,dstP.l,flength.l,*ctx.ffa_ADPCM_Ctx}
  SHARED ffa_ADPCM4()

  cSamp.l  = *ctx\cSampM           ; previous sample
  fb.l     = *ctx\fbM              ; current bit shift

  For n.l=0 To flength-1
    If (n & 1)
      cIndex.l = (c.b & $F0) LSR 4
    Else
      c.b = Peek.b(srcP) :srcP+1 : cIndex.l = c & $0F
    End If

    cSamp = cSamp + (ffa_ADPCM4(cIndex) LSL fb)
    Poke.w dstP,cSamp : dstP+2

    If cIndex>=#FFA_ADPCM4_HI
      If fb<#FFA_ADPCM4_MAXFB Then fb+1
    Else
      If cIndex<=#FFA_ADPCM4_LOW Then If fb>#FFA_ADPCM4_MINFB Then fb-1
    EndIf
  Next

  *ctx\cSampM  = cSamp           ; previous sample
  *ctx\fbM     = fb              ; current bit shift
  *ctx\fpos    + flength

End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ffa_off2ms{fid.l,offset.l}                             /
;/                                                                             /
;/ Description:                                                                /
;/ convert an offset in sample frames to milliseconds.                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/ - offset.l    : sample frame offset                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ms offset                                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_off2ms{fid.l,offset.l}
SHARED afileinfo(),filedat()
If fid>=0
  If filedat(fid)\is_used
    f.f = offset
    f * 1000
    f / afileinfo(fid)\samplerate
    ms.l = f
  Else
    ms = offset * 10 / 441
  End If
End If
Function Return ms
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ffa_ms2off{fid.l,ms.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Convert a millisecond offset to a sample frame offset value within the wa:: /
;/ vefile.                                                                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l   : file object ID                                                  /
;/ - ms.l    : offset in ms                                                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : offset in sample frames                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_ms2off{fid.l,ms.l}
SHARED afileinfo(),filedat()
If fid>=0
  If filedat(fid)\is_used
    f.f = ms
    f * afileinfo(fid)\samplerate
    f / 1000
    offset.l = f
  Else
    offset = ms * 441 / 10
  End If
End If
Function Return offset
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ffa_EncodeSysexHeader{*sh.chunk_sysex_header,*sd.chunk_sysex_da:: /
;/ ta,waveID.l,sxchannel.l,bits.l,samplerate.l,flength.l,loop_start.l,loop_e:: /
;/ nd.l}                                                                       /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/ Encode sysex header out of the given parameters.                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *sh.chunk_sysex_header : ???                                              /
;/ - *sd.chunk_sysex_data   : ???                                              /
;/ - waveID.l       : ???                                                      /
;/ - sxchannel.l    : ???                                                      /
;/ - bits.l         : number of bits (usually 8, 16 or 24)                     /
;/ - samplerate.l   : ???                                                      /
;/ - flength.l      : ???                                                      /
;/ - loop_start.l   : ???                                                      /
;/ - loop_end.l     : ???                                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ffa_EncodeSysexHeader{*sh.chunk_sysex_header,*sd.chunk_sysex_data,waveID.l,sxchannel.l,bits.l,samplerate.l,flength.l,loop_start.l,loop_end.l}
USEPATH *sh
If loop_end<=loop_start Then loop_start=0:loop_end = flength
\_F0  = $F0
\_7E  = $7E
\cc   = sxchannel   ; sysex channel
\_01  = $01
\id_l = waveID & $7F
\id_h = (waveID LSR 7) & $7F ; ID number high
\bits = bits ; bit resolution of sample
per.d = 1000000000 / samplerate
period.l = Int(per+0.5)
\period_l     = (period       )& $7F ; period in nanoseconds = 1.000.000.000/samplerate
\period_m     = (period LSR  7)& $7F
\period_h     = (period LSR 14)& $7F
\length_l     = (flength       )& $7F ; length in words
\length_m     = (flength LSR  7)& $7F
\length_h     = (flength LSR 14)& $7F
\loop_start_l = (loop_start       )& $7F ; loop start point in words
\loop_start_m = (loop_start LSR  7)& $7F
\loop_start_h = (loop_start LSR 14)& $7F
\loop_end_l   = (loop_end       )& $7F ; loop end point in words
\loop_end_m   = (loop_end LSR  7)& $7F
\loop_end_h   = (loop_end LSR 14)& $7F
If loop_start=0 AND loop_end=flength
  \loop_type    = $7F ; 0 = foreward, 01 = bw/fw, 7F = no loop
Else
  \loop_type    = $00
End If
\_F7 = $F7

; prepare data chunk
*sd\cframesize  = 1
If \bits> 7 Then *sd\cframesize+1
If \bits>14 Then *sd\cframesize+1
If \bits>21 Then *sd\cframesize+1
If \bits>28 Then *sd\cframesize+1
*sd\packetID = -1
*sd\_F0 = $F0
*sd\_7E = $7E
*sd\cc  = *sh\cc   ; sysex channel
*sd\_02 = $02
*sd\_F7 = $F7
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = _ffa_EncodeSysexData{*sh.chunk_sysex_header,*sd.chun:: /
;/ k_sysex_data,dataptr.l,sourcebits.l,@flength.l}                             /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/ Encode audio samples to a midi sysex chunk.                                 /
;/ NOTE: This needs 120/cframesize samples present in dataptr, otherwise fle:: /
;/ ngth has to be specified                                                    /
;/ NOTE: This function returns the amount of samples that were aborbed into :: /
;/ the chunk                                                                   /
;/ NOTE: once a chunk is full, you have to clear \offset=0 to read more samp:: /
;/ les                                                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *sh.chunk_sysex_header    : ???                                           /
;/ - *sd.chunk_sysex_data    : ???                                             /
;/ - dataptr.l    : ???                                                        /
;/ - sourcebits.l    : number of bits (usually 8, 16 or 24)                    /
;/ - flength.l    : ???                                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ffa_EncodeSysexData{*sh.chunk_sysex_header,*sd.chunk_sysex_data,dataptr.l,sourcebits.l,@flength.l}
USEPATH *sd
\cc  = *sh\cc   ; sysex channel
\packetID = (\packetID+1) & $7F ; 0...127

sampsPerDump.l = 120        / *sd\cframesize
sampsDone.l    = *sd\offset / *sd\cframesize
If flength<0 Then flength = sampsPerDump
tptr.l         = dataptr
sampsTodo.l      = Min(sampsPerDump-sampsDone,flength)
mpos.l         = *sd\offset
framesize.l = 1 * sourcebits / 8

For s.l = 0 To sampsTodo-1
  Select sourcebits
    Case 8
      dat.l = (Peek.b(tptr) LSL 24) -$80000000 ; 8bit
    Case 16
      dat.l = (Peek.w(tptr) LSL 16) -$80000000 ; 16bit
    Case 24
      dat.l = (Peek.w(tptr) LSL  8) -$80000000 ; 24bit
    Case 32
      dat.l = (Peek.l(tptr) LSL  0) -$80000000 ; 32bit
  End Select
  tptr + framesize

  Select \cframesize
    Case 1
      \dat[mpos+0] = (dat LSR 25) & $7F
    Case 2
      \dat[mpos+0] = (dat LSR 25) & $7F
      \dat[mpos+1] = (dat LSR 18) & $7F
    Case 3
      \dat[mpos+0] = (dat LSR 25) & $7F
      \dat[mpos+1] = (dat LSR 18) & $7F
      \dat[mpos+2] = (dat LSR 11) & $7F
    Case 4
      \dat[mpos+0] = (dat LSR 25) & $7F
      \dat[mpos+1] = (dat LSR 18) & $7F
      \dat[mpos+2] = (dat LSR 11) & $7F
      \dat[mpos+3] = (dat LSR  4) & $7F
    Case 5
      \dat[mpos+0] = (dat LSR 25) & $7F
      \dat[mpos+1] = (dat LSR 18) & $7F
      \dat[mpos+2] = (dat LSR 11) & $7F
      \dat[mpos+3] = (dat LSR  4) & $7F
      \dat[mpos+4] = (dat LSL  3) & $7F
  End Select
  mpos + *sd\cframesize
Next
*sd\offset = mpos

While mpos<120
  \dat[mpos] = 0 : mpos+1
Wend

\ll = 0; checksum
\ll = Xor(\ll,\_7E)
\ll = Xor(\ll,\cc)
\ll = Xor(\ll,\_02)
\ll = Xor(\ll,\packetID)
For n.l=0 To 120-1
  \ll = Xor(\ll,\dat[n])
Next
Function Return sampsTodo
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  form.l = ffa_GetFileFormat{fid.l,@pos.l}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Return the file format identifier or #FFA_UNKNOWN if the file format is n:: /
;/ ot supported.                                                               /
;/ Possible file format identifiers are:                                       /
;/ @"AIFF" : AIFF or AIFC file format (used on MACs)                           /
;/ @"WAVE" : Windows RIFF-WAV format (used on Windows)                         /
;/ @"CDDA" : 44.1kHzm 16 bit stereo RAW data at a certian length, read to us:: /
;/ e with MakeCD.                                                              /
;/ @"MAUD" : old, proprietary Amiga format for Maestro Sound card and others   /
;/ @"8SVX" : THE Amiga IFF-8SVX format, unfortunately it can handle only 8 b:: /
;/ it, rarely used nowadays                                                    /
;/ @"MP3"  : 16 bit, highly compressed audio format common on all platforms,:: /
;/  read only, requires mpega.library                                          /
;/ @"MP2"  : older version of MP3.                                             /
;/ @"RAW"  : RAW data, can be anything                                         /
;/ @"SYSX" : MIDI SysEx Sample dump, can hanlde only mono data                 /
;/ @"HDRC" : HD-Rec specific format, not used anymore                          /
;/ @"ADC"  : 16bit, 16kHz mono sample, signed little endian encoded            /
;/ #FFA_UNKNOWN : equals to 0, invalid file format, or not identifyable        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/ - pos.l    : seek positon from where to analyse the file                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - form.l   : file format identifier, e.g. @"AIFF" or @"MP3"                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetFileFormat{fid.l,@pos.l}
SHARED afileinfo()
USEPATH afileinfo(fid)
If \form><#FFA_UNKNOWN Then Function Return \form

If pos<0 Then pos=0
oldpos.l = file_GetSeekPos{fid}
form.l = #FFA_UNKNOWN

If fid>=0 AND form = #FFA_UNKNOWN
 If file_Seek{fid,pos}
  If file_ReadMem{fid,&header.l,4}
    Select header
      Case @"AB3S"
        form = @"AB3S" ; Amiblitz3 Sample!
      Case @"FORM"
        succ.l=file_ReadMem{ fid,&header,4 }  ; size
        succ.l=file_ReadMem{ fid,&header,4 }
        Select header
          Case @"MAUD"
            form = @"MAUD"

          Case @"AIFF"
            form = @"AIFF"

          Case @"AIFC"
            form = @"AIFF"

          Case @"8SVX"
            form = @"8SVX"

        End Select

      Case @"RIFF"
        succ.l=file_ReadMem{ fid,&header,4 } ; size
        succ.l=file_ReadMem{ fid,&header,4 }
        Select header
          Case @"WAVE"
            form = @"WAVE"
        End Select

      Case @"PROW"
        form = @"HDRC"

      Default
        ; check for sysex
        file_Seek{fid,pos}
        If file_ReadMem{fid,sh.chunk_sysex_header,4}
          If sh\_F0 = !UBYTE{$F0} AND sh\_7E = $7E
            If sh\_01 = $01
              ; yes, it is a sysex dump header !
              ;Stop
              form = @"SYSX"
            End If
          End If
        End If

; own mod implementation
;        If mod_Examine{file_GetFullName{fid}} then form = @"MOD"
CNIF #use_ptplay_library
; ptplay.library
        If pt_Examine{file_GetFullName{fid}} Then form = @"MOD"
CEND
        If form = #FFA_UNKNOWN
         If file_GetLength{fid} MOD 2352 = 0
          form = @"CDDA"
         Else
          If form=#FFA_UNKNOWN
            If LCase$(Right$(file_GetName{fid},4))=".adc"
              form = @"ADC"
            End If
            If LCase$(Right$(file_GetName{fid},4))=".pcm"
              form = @"ADC"
            End If

          End If
         End If
        End If

; check for mp3 first !
CNIF #use_mpega_library
If form = #FFA_UNKNOWN
ex.s = LCase$(dos_GetExt{file_GetFullName{fid}})
If Instr(ex,"mp")
mpeglayer.w = mpega_Examine{file_GetFullName{fid}}
If mpeglayer>0
  Select mpeglayer
    Case 1
      form = @"MP3" ; 1
    Case 2
      form = @"MP3" ; 2
    Case 3
      form = @"MP3"
  End Select
End If
End If
End If
CEND
 


    End Select
  End If
 End If
End If
file_Seek{fid,oldpos}
Function Return form
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ffa_WriteSampleInfo{fid.l,rootkey.l,fine.l,@loop_start:: /
;/ .l,@loop_end.l}                                                             /
;/                                                                             /
;/ Description:                                                                /
;/ Write additional sample information to a file.                              /
;/ NOTE: This function has only effect on file formats that support this inf:: /
;/ ormations.                                                                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l        : file object ID                                             /
;/ - rootkey.l    : root key on musical midi keyboard                          /
;/ - fine.l       : fine tuning in cents                                       /
;/ - loop_start.l : sample frame offset for loop start                         /
;/ - loop_end.l   : sample frame offset for loop end                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : -1 if everything went well, 0 otherwise                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_WriteSampleInfo{fid.l,rootkey.l,fine.l,@loop_start.l,@loop_end.l}
SHARED chunk_smpl,afileinfo(),SampleLoop,chunk_data,chunk_form
succ.l = True
Select afileinfo(fid)\form
  Case @"WAVE"
    If rootkey<0 Then rootkey = 60
    USEPATH chunk_smpl
    \smpl = @"smpl"
    \size = SizeOf.chunk_smpl -8
    \dwManufacturer      = 0
    \dwProduct           = 0
    \dwSamplePeriod      = con_LFlip{1}
    \dwMIDIUnityNote     = con_LFlip{rootkey}
    \dwMIDIPitchFraction = con_LFlip{fine}  ; finetune +- 50cent
    \dwSMPTEFormat       = 0
    \dwSMPTEOffset       = 0
    \cSampleLoops        = 0       ; Anzahl der Sampleloops
    \cbSamplerData       = 0       ; Laenge des SamplerSpez. Daten am Ende
    USEPATH SampleLoop
    If loop_end>loop_start
      chunk_smpl\size + SizeOf.SampleLoop
      chunk_smpl\cSampleLoops        = con_LFlip{1}
      \dwIdentifier = 0
      \dwType       = 0
      \dwStart      = con_LFlip{loop_start}
      \dwEnd        = con_LFlip{loop_end}
      \dwFraction   = 0
      \dwPlayCount  = 0
    End If

    chunk_form\size = con_LFlip{chunk_form\size}

    If file_Seek{fid,afileinfo(fid)\datapos-SizeOf.chunk_data}
      chunk_smpl\size  = con_LFlip{chunk_smpl\size}
      succ.l & file_WriteMem{ fid,&chunk_smpl\smpl ,SizeOf.chunk_smpl }
      afileinfo(fid)\datapos + SizeOf.chunk_smpl
      chunk_form\size        + SizeOf.chunk_smpl
      If loop_end>loop_start
        succ.l & file_WriteMem{ fid,SampleLoop ,SizeOf.SampleLoop}
        afileinfo(fid)\datapos + SizeOf.SampleLoop
        chunk_form\size        + SizeOf.SampleLoop
      End If
      succ.l & file_WriteMem{ fid,&chunk_data\DAT ,SizeOf.chunk_data }
    EndIf

    If file_Seek{fid,4}
      chunk_form\size = con_LFlip{chunk_form\size}
      succ&file_WriteMem{fid,&chunk_form\size,4}
    End If

    succ & file_Seek{fid,afileinfo(fid)\datapos}

  Case @"SYSX"
    USEPATH *sh
    *sh.chunk_sysex_header = afileinfo(fid)\brain
    If *sh
      ; do something if we want to write a loop ...
      \loop_start_l = 0 ; loop start point in words
      \loop_start_m = 0
      \loop_start_h = 0
      \loop_end_l  = \length_l ; loop end point in words
      \loop_end_m  = \length_m
      \loop_end_h  = \length_h
      \loop_type   = $7F ; 0 = foreward, 01 = bw/fw, 7F = no loop
    End If

  Default
   ;-)

End Select
USEPATH afileinfo(fid)
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = _ffa_CheckLittleEndian{fid.l,channels.l,bits.l}          /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/ Test if the raw audio data is little or big endian.                         /
;/ This is done by messuring the "roughness" o little endian and big endian :: /
;/ encoded signal. The less "rough" signal is considered to be in correct en:: /
;/ dianess.                                                                    /
;/ NOTE: This function is used to detect the correct endianess of raw data.    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/ - channels.l    : number of channels (1=mono, 2=stereo)                     /
;/ - bits.l    : number of bits (usually 8, 16 or 24)                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : -1 = little endian, 0 = big endian                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ffa_CheckLittleEndian{fid.l,channels.l,bits.l}
SHARED ffa_workbuffer.l,afileinfo()
succ.l=False
If bits=16
  todo.l = Min(afileinfo(fid)\blength,1024*1024)
  count1.l = 1
  distsum1.f = 0
  count2.l  = 1
  distsum2.f = 0
  While todo>4
    chunksize.l = Min(#ffa_workbuffersize,todo) / 4
    If file_ReadMem{fid,ffa_workbuffer,chunksize*4}
      Select channels
        Case 1
          For n.l=0 To chunksize*2-2
            dist.l  = (Peek.w(ffa_workbuffer+n*2) - Peek.w(ffa_workbuffer+n*2+2)) / 2
            dist = dist*dist
            If dist>64
              distsum1 = distsum1 + dist
              count1+1
           End If
         Next
         FlipEndian16{ffa_workbuffer,ffa_workbuffer,chunksize*2}
         For n.l=0 To chunksize*2-2
           dist.l  = (Peek.w(ffa_workbuffer+n*2) - Peek.w(ffa_workbuffer+n*2+2)) / 2
           dist = dist*dist
           If dist>64
             distsum2 = distsum2 + dist
             count2+1
           End If
         Next

      Case 2
        For n.l=0 To chunksize-2
          dist.l  = (Peek.w(ffa_workbuffer+n*4) - Peek.w(ffa_workbuffer+n*4+4)) / 2
          dist = dist*dist
          If dist>64
            distsum1 = distsum1 + dist
            count1+1
          End If
        Next
        FlipEndian16{ffa_workbuffer,ffa_workbuffer,chunksize*2}
        For n.l=0 To chunksize-2
          dist.l  = (Peek.w(ffa_workbuffer+n*4) - Peek.w(ffa_workbuffer+n*4+4)) / 2
          dist = dist*dist
          If dist>64
            distsum2 = distsum2 + dist
            count2+1
          End If
        Next

      End Select
    End If
    todo - chunksize * 4
  Wend
  distsum1 / count1
  distsum2 / count2
  If distsum1>distsum2 Then succ=True ;:error{"Little Endian detected!"}
EndIf
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = _ffa_CheckUnsigned{fid.l,channels.l,bits.l,bo.l}         /
;/                                                                             /
;/ Description:                                                                /
;/ Guess if the raw data from file is signed or unsiged.                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/ - channels.l    : number of channels (1=mono, 2=stereo)                     /
;/ - bits.l    : number of bits (usually 8, 16 or 24)                          /
;/ - bo.l    : byte order                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : -1 = unsigned, 0 = signed                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ffa_CheckUnsigned{fid.l,channels.l,bits.l,bo.l}
SHARED ffa_workbuffer.l,afileinfo()
succ.l=False
If bits=16
  todo.l = Min(afileinfo(fid)\blength,1024*1024)
  count1.l = 1
  distsum1.f = 0
  count2.l  = 1
  distsum2.f = 0
  While todo>4
    chunksize.l = Min(#ffa_workbuffersize,todo) / 4
    If file_ReadMem{fid,ffa_workbuffer,chunksize*4}
      If (bo=#FFABO_LITTLEENDIAN)
        FlipEndian16{ffa_workbuffer,ffa_workbuffer,chunksize*2}
      End If
      Select channels
        Case 1
          For n.l=0 To chunksize*2-2
            dist.l  = (Peek.w(ffa_workbuffer+n*2) - Peek.w(ffa_workbuffer+n*2+2)) / 2
            dist = dist*dist
            If dist>64
              distsum1 = distsum1 + dist
              count1+1
           End If
         Next
         Unsigned2Signed16{ffa_workbuffer,ffa_workbuffer,chunksize*2}
         For n.l=0 To chunksize*2-2
           dist.l  = (Peek.w(ffa_workbuffer+n*2) - Peek.w(ffa_workbuffer+n*2+2)) / 2
           dist = dist*dist
           If dist>64
             distsum2 = distsum2 + dist
             count2+1
           End If
         Next

      Case 2
        For n.l=0 To chunksize-2
          dist.l  = (Peek.w(ffa_workbuffer+n*4) - Peek.w(ffa_workbuffer+n*4+4)) / 2
          dist = dist*dist
          If dist>64
            distsum1 = distsum1 + dist
            count1+1
          End If
        Next
        Unsigned2Signed16{ffa_workbuffer,ffa_workbuffer,chunksize*2}
        For n.l=0 To chunksize-2
          dist.l  = (Peek.w(ffa_workbuffer+n*4) - Peek.w(ffa_workbuffer+n*4+4)) / 2
          dist = dist*dist
          If dist>64
            distsum2 = distsum2 + dist
            count2+1
          End If
        Next

      End Select
    End If
    todo - chunksize * 4
  Wend
  distsum1 / count1
  distsum2 / count2
  If distsum1>distsum2 Then succ=True ;:error{"Unsigned detected!"}
EndIf
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = _ffa_CheckStereo{fid.l,bits.l,bo.l,signed.l}             /
;/                                                                             /
;/ Description:                                                                /
;/ Guess if the raw data is mono or stereo.                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/ - bits.l    : number of bits (usually 8, 16 or 24)                          /
;/ - bo.l    : byte order of signal                                            /
;/ - signed.l    : -1 = signed, 0 = unsigned                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : -1 = stereo, 0 = mono                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ffa_CheckStereo{fid.l,bits.l,bo.l,signed.l}
SHARED ffa_workbuffer.l,afileinfo()
succ.l=False
If bits=16
  todo.l = Min(afileinfo(fid)\blength,1024*1024)
  count1.l = 1
  distsum1.f = 0
  count2.l  = 1
  distsum2.f = 0
  While todo>4
    chunksize.l = Min(#ffa_workbuffersize,todo) / 4
    If file_ReadMem{fid,ffa_workbuffer,chunksize*4}
      If (bo=#FFABO_LITTLEENDIAN)
        FlipEndian16{ffa_workbuffer,ffa_workbuffer,chunksize*2}
      End If
      If (signed=False)
        Unsigned2Signed16{ffa_workbuffer,ffa_workbuffer,chunksize*2}
      End If

          For n.l=0 To chunksize*2-2
            dist.l  = (Peek.w(ffa_workbuffer+n*2) - Peek.w(ffa_workbuffer+n*2+2)) / 2
            dist = dist*dist
            If dist>64
              distsum1 = distsum1 + dist
              count1+1
           End If
         Next

         For n.l=0 To chunksize-2
           dist.l  = (Peek.w(ffa_workbuffer+n*4) - Peek.w(ffa_workbuffer+n*4+4)) / 2
           dist = dist*dist
           If dist>64
             distsum2 = distsum2 + dist
             count2+1
           End If

           dist.l  = (Peek.w(ffa_workbuffer+n*4+2) - Peek.w(ffa_workbuffer+n*4+6)) / 2
           dist = dist*dist
           If dist>64
             distsum2 = distsum2 + dist
             count2+1
           End If

         Next


    End If
    todo - chunksize * 4
  Wend
  distsum1 / count1
  distsum2 / count2
  If distsum1>distsum2 Then succ=True ;:error{"Stereo detected!"}:Else error{"Mono detected!"}
EndIf
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _ffa_FreeHeader{fid.l}                                             /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _ffa_FreeHeader{fid.l}
SHARED afileinfo()
USEPATH afileinfo(fid)
If fid<0 Statement Return
CNIF #use_mpega_library
If \encoding = #FFAE_MPEGA Then mpega_Close{fid}
CEND
;If \encoding = #FFAE_MOD Then mod_close{\user_data}:\user_data=0
CNIF #use_ptplay_library
If \encoding = #FFAE_MOD Then pt_CloseMod{(.ptH)\user_data}:\user_data=0
CEND
If \encoding = #FFAE_BLADEMP3 Then blade_FreeHeader{fid,(.BladeH)\user_data}:\user_data=0
\form        = #FFA_UNKNOWN
\flength     = 0
\slength     = 0
\blength     = 0
\datapos     = 0
\byteorder   = False
\bits        = 0
\channels    = 0
\signed      = False
\samplerate  = 0
\encoding    = #FFAE_UNKNOWN
If \brain Then FreeVec_ \brain : \brain = 0
\brain_size  = 0
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.w = ffa_ReadHeaderInfo{fid.l,@checkform.l}                   /
;/                                                                             /
;/ Description:                                                                /
;/ Read the header information of an audio file.                               /
;/ The checkform parameter tell the function, if it should check the file fo:: /
;/ r a known file format (-1), or if unknown file formats should be loaded a:: /
;/ s raw data without asking (0).                                              /
;/ NOTE: Normally you do not need to call this function. This is only needed:: /
;/ , if you read an audio file that is embedded in another file.               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l       : file object ID                                              /
;/ - checkform.l : -1= check file format, 0=read everything                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l    : -1 if everything went well, 0 otherwise                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.w ffa_ReadHeader{fid.l,@checkform.l}
SHARED afileinfo()
SHARED chunk_form,chunk_maud,chunk_comm,chunk_data,chunk_fmtw,chunk_ssnd,chunk_vhdr,chunk_chan,chunk_smpl,SampleLoop
USEPATH afileinfo(fid)
\rootkey      = -1 ; 60
\fine         = 0
\cframesize   = -1
\framesize    = -1
\mode         = #mode_both
\quality      = #quality_high
\accessmode   = #file_read
\seekpos      = 0
\brain        = 0
\brain_size   = 0
\sample_start = 0
\user_data    = 0

If checkform
  \form = ffa_GetFileFormat{fid}
Else
  \form = @"RAW"
End If

If \form = #FFA_UNKNOWN
  If ask{"Unknown fileformat!"+Chr$(10)+"Load as RAW data?","RAW Data|Cancel"} Then \form = @"RAW"
End If

succ.l=False
\headerpos = file_GetSeekPos{fid}

  Select \form
    Case @"AB3S"
      \signed = True
      \byteorder = #FFABO_BIGENDIAN
      \encoding = #FFAE_UNKNOWN
      done.l = False
      Repeat
        If file_ReadTag{fid}
          Select file_GetTagID{}
            Case @"AB3S" : chunksize.l   = file_GetTagValue{}
            Case @"RATE" : \samplerate   = file_GetTagValue{}
            Case @"COMP"
              Select file_GetTagValue{}
                Case @"RAWD" : \encoding = #FFAE_RAW
                Case @"ADP2" : \encoding = #FFAE_ADPCM2
                Case @"ADP3" : \encoding = #FFAE_ADPCM3
                Case @"ADP4" : \encoding = #FFAE_ADPCM4
                Case @"ADP6" : \encoding = #FFAE_ADPCM6
                Case @"ADP8" : \encoding = #FFAE_ADPCM8
                Case @"ADD2" : \encoding = #FFAE_ADDPCM2
                Case @"ADD3" : \encoding = #FFAE_ADDPCM3
                Case @"ADD4" : \encoding = #FFAE_ADDPCM4
                Case @"ADD6" : \encoding = #FFAE_ADDPCM6
                Case @"ADD8" : \encoding = #FFAE_ADDPCM8
              End Select
            Case @"RKEY" : \rootkey      = file_GetTagValue{}
            Case @"FINE" : \fine         = file_GetTagValue{}
            Case @"LOOP" : \loop_start   = file_GetTagValue{}
            Case @"LEND" : \loop_end     = file_GetTagValue{}
            Case @"CHAN" : \channels     = file_GetTagValue{}
            Case @"BITS" : \bits         = file_GetTagValue{}
            Case @"FLEN" : \flength      = file_GetTagValue{}
            Case @"DATA" : blength.l     = file_GetTagValue{}
              done=True
              ; todo: check if blength makes sense...
              \datapos = file_GetSeekPos{fid}
          End Select
        Else
          done = True
        End If
      Until done

      If \encoding>< #FFAE_RAW
        \brain_size = SizeOf.ffa_ADPCM_Ctx
        *ctx.ffa_ADPCM_Ctx = AllocVec_(\brain_size,#MEMF_CLEAR)
        *ctx\cSampM  = 0
        *ctx\cSampS  = 0
        *ctx\cDeltaM = 0
        *ctx\cDeltaS = 0
        *ctx\rSampM  = 0
        *ctx\rSampS  = 0
        *ctx\cByte   = 0
        *ctx\fbM     = 0
        *ctx\fbS     = 0
        *ctx\fpos    = 0
        \brain      = *ctx
      End If
      \sample_start = 0
      \sample_end   = \flength-1
      \blength = \flength * (\bits / 8) * \channels
      \slength = \blength / \channels

      succ.l = True
      If \encoding = #FFAE_UNKNOWN Then error{"Unsupported encoding method in AB3S file!"} : succ=False
      If \bits><8 AND \bits><16 AND \bits><24 AND \bits><32 Then error{"Unsupported bit resolution AB3S file!"} : succ=False
      If \channels><1 AND \channels><2 Then error{"Unsupported channels in AB3S file!"} : succ=False

    Case @"MAUD"
      dummy.l = file_ReadMem{fid,&chunk_form\FORM,SizeOf.chunk_form  }
      If chunk_form\FORM = @"FORM" AND chunk_form\formtype = @"MAUD"
        If file_FindChunk{fid,@"MHDR",12,chunk_form\size,-1,0}
          dummy = file_ReadMem{fid,&chunk_maud\MHDR,SizeOf.chunk_maud }
          \flength    = chunk_maud\mhdr_Samples
          \bits       = chunk_maud\mhdr_SampleSizeU
          \samplerate = chunk_maud\mhdr_RateSource
          \channels   = chunk_maud\mhdr_Channels
          \byteorder  = #FFABO_BIGENDIAN
          \encoding   = #FFAE_RAW
          \signed     = True
          If _ffa_CheckFormOK{\channels,\bits,\samplerate,\byteorder,\encoding}
            \blength = \flength * (\bits / 8) * \channels
            \slength = \blength / \channels
            \datapos = file_FindChunk{fid,@"MDAT",\headerpos+12,chunk_form\size,-1,0}
            If \datapos>0
              dummy = file_ReadMem{ fid,&chunk_data\DAT,SizeOf.chunk_data}
              Select chunk_maud\mhdr_Compression
                Case #MCOMP_NONE
                  If chunk_data\size >< \blength
                    \blength = chunk_data\size
                    \flength = \blength / \channels / (\bits/8)
                    \slength = \blength / \channels
                    \loop_start = 0
                    \loop_end   = 0
                    \sample_start = 0
                    \sample_end   = \flength-1
                    error{"MAUD header corrupt, wrong length ! " + Str$(chunk_data\size)+" >< " + Str$(\blength)+" (chunk)"}
                  End If
                  \datapos + SizeOf.chunk_data
                  succ = True
                Default
                  error{"Unsupported compression used in MAUD file ! (id="+Str$(chunk_maud\mhdr_Compression)+")"}
              End Select
            Else
              error{"No data-chunk found in MAUD file!"}
            End If
          Else
            error{"MAUD: Audio format is not supported ! ("+Str$(\samplerate)+" Hz / "+Str$(\bits)+" bit)"}
          End If
        Else
          error{"No MHDR-chunk found in MAUD file!"}
        End If
      Else
        error{"File is not a MAUD file!"}
      End If

    Case @"WAVE"
      If file_ReadMem{ fid,&chunk_form\FORM,SizeOf.chunk_form}
       If chunk_form\FORM = @"RIFF" AND chunk_form\formtype = @"WAVE"
        chunk_form\size = con_LFlip{chunk_form\size}
        file_SetLittleEndian{fid}
        If file_FindChunk{fid,@"fmt ",\headerpos+12,chunk_form\size,-1,0}
         chunk_fmtw\fmt = 0
         If file_ReadMem{fid,&chunk_fmtw\fmt,SizeOf.chunk_fmt}
          \bits  = con_WFlip{chunk_fmtw\bits}
          \samplerate = con_LFlip{chunk_fmtw\samplerate}
          \channels   = con_WFlip{chunk_fmtw\channels}
          encodingtag.w = con_WFlip{chunk_fmtw\form}
          \byteorder  = #FFABO_LITTLEENDIAN
          \encoding = #FFAE_UNKNOWN
          Select encodingtag
             Case #WAVE_FORMAT_PCM
               \encoding = #FFAE_RAW
             Case #WAVE_FORMAT_IEEE_FLOAT
               \bits=32:\encoding=#FFAE_FLOAT32
             Case #WAVE_FORMAT_DVI_ADPCM
                ;If \bits = 4 Then \bits = 16 : \compression = #FFAE_ADPCM_4BIT
                ;If \bits = 3 Then \bits = 16 : \compression = #FFAE_ADPCM_3BIT
             Default
               \encoding = #FFAE_UNKNOWN
               error{"WAV: Encoding format (ID=0x"+Right$(Hex$(encodingtag),4)+") is not supported!"}
          End Select
          If \bits = 8 Then \signed=False:Else \signed = True
          If _ffa_CheckFormOK{\channels,\bits,\samplerate,\byteorder,\encoding}
            \datapos = file_FindChunk{fid,@"data",\headerpos+12,chunk_form\size,-1,0}
            If \datapos>0
              If file_ReadMem{fid,&chunk_data\DAT,SizeOf.chunk_data}
                \datapos + SizeOf.chunk_data
                \blength = con_LFlip{chunk_data\size}
                succ = True
                testlength.l = file_GetLength{fid} -\datapos
                If testlength<\blength
                  error{"WAV: Fileheader contains not the correct length ! ("+Str$(testlength)+"><"+Str$(\blength)+")"}
                  \blength=testlength
                End If
                div.l = \bits / 8  : If div><0 Then \slength = \blength / div
                div.l = \channels  : If div><0 Then \flength = \slength / div

              Else
                error{"WAV: Unable to read data chunk!"}
              End If
            Else
               error{"WAV: No data-chunk found in WAVE file!"}
            End If

            \loop_start   = 0
            \loop_end     = 0
            \sample_start = 0
            \sample_end   = \flength-1

            smplpos.l = file_FindChunk{fid,@"smpl",\headerpos+12,chunk_form\size,-1,0}
            If smplpos>0
              If file_ReadMem{fid,&chunk_smpl\smpl,SizeOf.chunk_smpl}
                \rootkey    = con_LFlip{chunk_smpl\dwMIDIUnityNote}
                \fine       = con_LFlip{(chunk_smpl\dwMIDIPitchFraction LSR 16)*50/32768}
                numloops.l  = con_LFlip{chunk_smpl\cSampleLoops}
                If numloops>0
                  If file_ReadMem{fid,SampleLoop,SizeOf.SampleLoop}
                    \loop_start = con_LFlip{SampleLoop\dwStart}
                    \loop_end   = con_LFlip{SampleLoop\dwEnd}
                  End If
                End If
              End If
            End If

          Else
            error{"WAV: Encoding/compression format is not supported ! ("+Str$(\samplerate)+" Hz / "+Str$(\bits)+" bit)"}
          End If
         Else
           error{"WAV: Unable to read fmt chunk!"}
         End If
        Else
          error{"WAV: No fmt-chunk found in WAVE file!"}
        End If
       Else
         error{"WAV: This is not a WAVE file!"}
       End If
      Else
        error{"WAV: Unable to read FORM header!"}
      End If

    Case @"AIFF"
      If file_ReadMem{fid,&chunk_form\FORM,SizeOf.chunk_form}
       If chunk_form\FORM = @"FORM" AND (chunk_form\formtype = @"AIFF" OR chunk_form\formtype = @"AIFC")
        If file_FindChunk{fid,@"COMM",SizeOf.chunk_form,chunk_form\size,-1,0}
         succ2.l = file_ReadMem{ fid,&chunk_comm\COMM,8}
         chunk_comm\compression = @"NONE"
         succ2 & file_ReadMem{ fid,&chunk_comm\COMM+8,Min(SizeOf.chunk_comm-8,chunk_comm\size)}
         If chunk_form\formtype = @"AIFF" Then chunk_comm\compression = @"NONE"
         If succ2
          \slength    = chunk_comm\sampleframes * chunk_comm\channels
          \bits       = chunk_comm\bits
          \samplerate = con_Extended2Long{&chunk_comm\samplerate\exponent}
          \channels   = chunk_comm\channels
          \byteorder  = #FFABO_BIGENDIAN
          \signed     = True
          Select chunk_comm\compression
            Case @"NONE"
              \encoding = #FFAE_RAW
            Case @"FL32"
              \encoding = #FFAE_FLOAT32
            Case @"fl32"
              \encoding = #FFAE_FLOAT32
            Default
              error{"AIFC: Unsupported encoding "+Hex$(chunk_comm\compression)+"/"+Mkl$(chunk_comm\compression)+"!"}
              \encoding = #FFAE_UNKNOWN
          End Select

          If _ffa_CheckFormOK{\channels,\bits,\samplerate,\byteorder,\encoding}
            div.l = \bits / 8  : \blength = \slength * div
            div.l = \channels  : If div><0 Then \flength = \slength / div
            \datapos = file_FindChunk{fid,@"SSND",\headerpos+SizeOf.chunk_form,chunk_form\size,-1,0}
            If \datapos>0
             If file_ReadMem{fid,&chunk_data\DAT,SizeOf.chunk_data}
            ;  If chunk_data\size = \blength + SizeOf.chunk_ssnd - 8
                succ = True
                \datapos + SizeOf.chunk_ssnd
                testlength.l = file_GetLength{fid} - \datapos
                If testlength<\blength
                  error{"AIFF: Fileheader contains not the correct length ! ("+Str$(testlength)+"><"+Str$(\blength)+")"}
                  \blength=testlength
                  \slength=\blength*8/\bits
                  \flength=\slength/\channels
                End If

            ;  Else
            ;    error{"AIFF header corrupt, wrong length ! " + Str$(chunk_data\size)+" >< " + Str$(\blength)+" (chunk)"}
            ;  End If
             Else
               error{"AIFF: Unable to read DAT chunk!"}
             End If
             \loop_start = 0
             \loop_end   = 0
             \sample_start = 0
             \sample_end   = \flength-1

            Else
              error{"AIFF: No SSND-chunk found in AIFF file!"}
            End If
          Else
            error{"AIFF: Audio format is not supported ! ("+Str$(\samplerate)+" Hz / "+Str$(\bits)+" bit)"}
          End If
         Else
           error{"AIFF: Unable to read COMM chunk!"}
         End If
        Else
          error{"AIFF: No COMM-chunk found in AIFF file!"}
        End If
       Else
         error{"AIFF: File is not an AIFF file!"}
       End If
      Else
        error{"AIFF: Unable to read AIFF header!"}
      End If

    Case @"RAW"
      \blength   = file_GetLength{fid} - \headerpos
      \datapos   = 0
      \byteorder = #FFABO_BIGENDIAN
      \encoding  = #FFAE_RAW
      \signed    = True
      \samplerate = -1
      dummy = ask{"Select format of RAW data:","8 bit mono|8 bit stereo|16 bit mono|16 bit stereo|Cancel"}
      Select dummy
        Case 0
          \channels = False
        Case 1
          \bits     = 8
          \channels = 1
        Case 2
          \bits     = 8
          \channels = 2
        Case 3
          \bits     = 16
          \channels = 1
        Case 4
          \bits     = 16
          \channels = 2
      End Select
      \loop_start = 0
      \loop_end   = 0
      \sample_start = 0
      \sample_end   = \flength-1
      If _ffa_CheckLittleEndian{fid,\channels,\bits}            Then \byteorder = #FFABO_LITTLEENDIAN
      If _ffa_CheckUnsigned   {fid,\channels,\bits,\byteorder} Then \signed = False
      ;If _ffa_CheckStereo {fid,\bits,\byteorder,\signed}   Then \channels=2:Else \channels=1

      div.l = \bits / 8  : If div><0 Then \slength = \blength / div
      div.l = \channels  : If div><0 Then \flength = \slength / div
      If \channels Then succ = _ffa_CheckFormOK{\channels,\bits,44100,\byteorder,\encoding}:Else succ = False


    Case @"CDDA"
      \blength    = file_GetLength{fid} -\headerpos
      \datapos    = 0
      \byteorder  = #FFABO_BIGENDIAN
      \encoding   = #FFAE_RAW
      \signed     = True
      \samplerate = 44100
      \channels   = 2
      \bits       = 16
      If _ffa_CheckLittleEndian{fid,\channels,\bits}  Then \byteorder = #FFABO_LITTLEENDIAN
      \slength    = \blength / (\bits / 8)
      \flength    = \slength / \channels
      \loop_start = 0
      \loop_end   = 0
      \sample_start = 0
      \sample_end   = \flength-1
      succ        = True

    Case @"ADC"
      \blength    = file_GetLength{fid} - \headerpos
      \datapos    = 0
      \byteorder  = #FFABO_LITTLEENDIAN
      \encoding   = #FFAE_RAW
      \signed     = True
      \samplerate = 16000
      \channels   = 1
      \bits       = 16
      \slength    = \blength / (\bits / 8)
      \flength    = \slength / \channels
      \loop_start = 0
      \loop_end   = 0
      \sample_start = 0
      \sample_end   = \flength-1
      succ        = True

   Case @"SYSX"
     If \brain=False OR \brain_size<SizeOf.chunk_sysex_header +SizeOf.chunk_sysex_data
       \brain_size = SizeOf.chunk_sysex_header +SizeOf.chunk_sysex_data
       \brain      = AllocVec_(\brain_size,#MEMF_CLEAR)
     End If

     If \brain
       *sd.chunk_sysex_data   = \brain
       *sh.chunk_sysex_header = \brain + SizeOf.chunk_sysex_data
       If file_ReadMem{fid,*sh,#sizeof_chunk_sysex_header}
         midibits.l   = *sh\bits ; bit resolution of sample
         \cframesize  = 1
         If midibits> 7 Then \cframesize+1
         If midibits>14 Then \cframesize+1
         If midibits>21 Then \cframesize+1
         If midibits>28 Then \cframesize+1
         *sd\cframesize = \cframesize
         *sd\offset     = 120

         \bits = 8
         If midibits>8 Then \bits = 16
         If midibits>16 Then \bits = 24

         \channels    = 1
         ; period in nanoseconds = 1.000.000.000/samplerate
         period.l     = *sh\period_l     + (*sh\period_m LSL 7)     + (*sh\period_h LSL 14)
         wlength.l    = *sh\length_l     + (*sh\length_m LSL 7)     + (*sh\length_h LSL 14)
         loop_start.l = *sh\loop_start_l + (*sh\loop_start_m LSL 7) + (*sh\loop_start_h LSL 14)
         loop_end.l   = *sh\loop_end_l   + (*sh\loop_end_m LSL 7)   + (*sh\loop_end_h LSL 14)

         \sample_start = 0
         \sample_end   = wlength-1
         \loop_start   = 0
         \loop_end     = 0
         If *sh\loop_type=0 ; 0 = foreward, 01 = bw/fw, 7F = no loop
           \loop_start = loop_start
           \loop_end   = loop_end
         End If
         sr.d = period
         sr = 1000000000/sr  + 0.6
         \samplerate = Int(sr)
         \framesize = \channels * \bits / 8
         \flength = wlength
         \slength = \flength * \channels
         \blength = \flength * \framesize
         \datapos = file_GetSeekPos{fid}
         \byteorder   = #FFABO_BIGENDIAN
         \encoding = #FFAE_SYSEX
         \signed = False
         succ = True
       End If
     End If

    Case @"HDRC"
      \blength    = file_GetLength{fid} - 32 - \headerpos
      \datapos    = 32
      \byteorder  = #FFABO_BIGENDIAN
      \encoding   = #FFAE_RAW
      \signed     = True
      If file_Seek{fid,8}
        succ.l= file_ReadMem{fid,&\samplerate,4}
        succ.l= file_ReadMem{fid,&\channels,1}
        succ.l = True
      End If
      \bits       = 16
      \slength    = \blength / 2
      If \channels>0
        \flength    = \slength / \channels
        succ = _ffa_CheckFormOK{\channels,\bits,\samplerate,\byteorder,\encoding}
      Else
        \channels   = 1
        \samplerate = 48000
        \flength    = \slength / \channels
        succ=True
      End If

    CNIF #use_mpega_library
    Case @"MP3"
      fil.s       = file_GetName{fid}
      path.s      = file_GetPath{fid}
      filename.s  = file_GetFullName{fid}
      If mpega_Open{fid,filename.s}
        \blength    = mpega_GetByteLength{fid}
        \datapos    = 0
        \byteorder  = #FFABO_BIGENDIAN
        \encoding   = #FFAE_MPEGA
        \signed     = True
        \samplerate = mpega_GetSamplerate{fid}
        \channels   = mpega_GetChannels{fid}:If \channels=0 Then \channels=1
        \bits       = 16
        If _ffa_CheckFormOK{\channels,\bits,\samplerate,\byteorder,\encoding}
          \slength    = \blength / 2
          \flength    = \slength / \channels
          succ        = True
        End If
        \loop_start = 0
        \loop_end   = 0
        \sample_start = 0
        \sample_end   = \flength-1

      End If
    CEND
CNIF #use_ptplay_library
    Case @"MOD"
      filename.s  = file_GetFullName{fid}
      \user_data = pt_OpenMod{filename.s,44100,2}
      If \user_data
        \blength    = pt_GetLength{(.ptH)\user_data} * 4
        \datapos    = 0
        \byteorder  = #FFABO_BIGENDIAN
        \encoding   = #FFAE_MOD
        \signed     = True
        \samplerate = 44100
        \channels   = 2:If \channels=0 Then \channels=1
        \bits       = 16
        If _ffa_CheckFormOK{\channels,\bits,\samplerate,\byteorder,\encoding}
          \slength    = \blength / 2
          \flength    = \slength / \channels
          succ        = True
        End If
        \loop_start = 0
        \loop_end   = 0
        \sample_start = 0
        \sample_end   = \flength-1
      End If
CEND
;    Case @"MODX"
;      filename.s  = file_GetFullName{fid}
;      \user_data = mod_Open{filename.s}
;      If \user_data
;        \blength    = mod_GetByteLength{\user_data}
;        \datapos    = 0
;        \byteorder  = #FFABO_BIGENDIAN
;        \encoding = #FFAE_MOD
;        \signed     = True
;        \samplerate = 44100
;        \channels   = 2:If \channels=0 Then \channels=1
;        \bits       = 16
;        mod_ConfigureAudio{\user_data,\samplerate,\channels,\bits}
;        If _ffa_CheckFormOK{\channels,\bits,\samplerate,\byteorder,\encoding}
;          \slength    = \blength / 2
;          \flength    = \slength / \channels
;          succ        = True
;        End If
;        \loop_start = 0
;        \loop_end   = 0
;        \sample_start = 0
;        \sample_end   = \flength-1
;      End If

    Case @"8SVX"
      dummy.l = file_ReadMem{fid,&chunk_form\FORM,SizeOf.chunk_form}
      If chunk_form\FORM = @"FORM" AND chunk_form\formtype = @"8SVX"
        If file_FindChunk{fid,@"VHDR",\headerpos+SizeOf.chunk_form,chunk_form\size,-1,0}
          dummy.l = file_ReadMem{fid,&chunk_vhdr\VHDR,SizeOf.chunk_vhdr}
          \bits       = 8
          \channels   = 1
          \samplerate = 0
          Poke.w &\samplerate+2,Peek.w(&chunk_vhdr\Samplerate)
          \signed     = True
          \byteorder  = #FFABO_BIGENDIAN
          \encoding   = #FFAE_RAW
          If _ffa_CheckFormOK{\channels,\bits,\samplerate,\byteorder,\encoding}
            If file_FindChunk{fid,@"CHAN",\headerpos+SizeOf.chunk_form,chunk_form\size-4,-1,0}
              If file_ReadMem{fid,&chunk_chan\CHAN,SizeOf.chunk_chan}
                Select chunk_chan\sampletype
                  Case #svxtype_right
                  Case #svxtype_left
                  Case #svxtype_stereo
                    error{"Stereo 8SVX samples are not supported, it will be loaded as mono sample."}
                End Select
              End If
            End If
            \datapos = file_FindChunk{fid,@"BODY",\headerpos+SizeOf.chunk_form,chunk_form\size-4,-1,0}
            If \datapos>0
              dummy.l = file_ReadMem{fid,&chunk_data\DAT,SizeOf.chunk_data}
              \datapos + SizeOf.chunk_data
              Select chunk_vhdr\Compression
                Case #svx_comp_none
                  \blength = chunk_data\size
                  \slength = \blength / \channels
                  \flength = \slength
                  succ = True
                Default
                  error{"Compression in 8SVX files not supported ! (compression="+Str$(chunk_vhdr\Compression)+")"}
              End Select
            Else
              error{"No BODY-chunk found in 8SVX file!"}
            End If
            \loop_start = 0
            \loop_end   = 0
            \sample_start = 0
            \sample_end   = \flength-1

          Else
            error{"8SVX: Audio format is not supported ! ("+Str$(\samplerate)+" Hz / "+Str$(\bits)+" bit)"}
          End If
        Else
          error{"No VHDR-chunk found in 8SVX file!"}
        End If
      Else
        error{"File is not an 8SVX file!"}
      End If
    Case #FFA_UNKNOWN
      ;-)

    Default
      error{"Unsupported fileformat!"}

  End Select
  If \framesize<1 Then \framesize  = (\channels * \bits) / 8
  If \cframesize<1 Then \cframesize = \framesize

  If succ=True AND \datapos>=0
    succ = file_Seek{fid,\datapos}
  Else
    _ffa_FreeHeader{fid}
  End If
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.w = ffa_WriteHeaderInfo{fid.l,form.l,channels.l,bits.l,sam:: /
;/ plerate.l,@flength.l}                                                       /
;/                                                                             /
;/ Description:                                                                /
;/ Write an audio file header to the already open file.                        /
;/ NOTE: This function is only needed, if you plan to embedd an audio file i:: /
;/ nto another file.                                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l        : file object ID                                             /
;/ - form.l       : file format identifier                                     /
;/ - channels.l   : number of channels (1=mono, 2=stereo)                      /
;/ - bits.l       : number of bits (usually 8, 16 or 24)                       /
;/ - samplerate.l : samplerate in Hz                                           /
;/ - flength.l    : expected sample frame length (if known)                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l       : -1 if file header was written, 0 otherwise                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.w ffa_WriteHeader{fid.l,form.l,channels.l,bits.l,samplerate.l,@flength.l}
SHARED ver.s,afileinfo()
SHARED chunk_form,chunk_fmtw,chunk_comm,chunk_maud,chunk_data,chunk_anno,chunk_ssnd,chunk_vhdr
succ.l = False
If file_IsUsed{fid}
 If flength<0 Then flength = 0

 \flength    = flength
 \bits       = bits
 \channels   = channels
 \byteorder  = #FFABO_BIGENDIAN
 \encoding   = #FFAE_RAW
 \signed     = True
 \samplerate = samplerate
 \datapos    = 0
 \cframesize = -1
 \seekpos    = 0
 \accessmode = #file_write
 \mode       = #mode_both
 \quality    = #quality_high
 \framesize  = (\channels * \bits) / 8

 Select form
   Case @"AB3C" : form = @"AB3S" : \encoding = #FFAE_ADDPCM4
   Case @"ADP2" : form = @"AB3S" : \encoding = #FFAE_ADPCM2
   Case @"ADP3" : form = @"AB3S" : \encoding = #FFAE_ADPCM3
   Case @"ADP4" : form = @"AB3S" : \encoding = #FFAE_ADPCM4
   Case @"ADP6" : form = @"AB3S" : \encoding = #FFAE_ADPCM6
   Case @"ADP8" : form = @"AB3S" : \encoding = #FFAE_ADPCM8
   Case @"ADD2" : form = @"AB3S" : \encoding = #FFAE_ADDPCM2
   Case @"ADD3" : form = @"AB3S" : \encoding = #FFAE_ADDPCM3
   Case @"ADD4" : form = @"AB3S" : \encoding = #FFAE_ADDPCM4
   Case @"ADD6" : form = @"AB3S" : \encoding = #FFAE_ADDPCM6
   Case @"ADD8" : form = @"AB3S" : \encoding = #FFAE_ADDPCM8
   Case @"WAV"  : form = @"WAVE"
   Case @"RIFF" : form = @"WAVE"
   Case @"IFF"  : form = @"8svx"
   Case @"SYX"  : form = @"SYSX"
   Case @"AIFC" : form = @"AIFF"
 End Select
 \form       = form
 \headerpos  = file_GetSeekPos{fid}

 div.l = \bits / 8  : If div><0 Then \slength = \flength * div
 div.l = \channels  : If div><0 Then \blength = \slength * div

 framesize.l = channels * bits / 8

 Select form
   Case @"AB3S"
     If file_WriteChunk{fid,@"AB3S"}
       file_WriteTag{fid,@"RATE",\samplerate}
       Select \encoding
         Case #FFAE_ADPCM2  : file_WriteTag{fid,@"COMP",@"ADP2"}
         Case #FFAE_ADPCM3  : file_WriteTag{fid,@"COMP",@"ADP3"}
         Case #FFAE_ADPCM4  : file_WriteTag{fid,@"COMP",@"ADP4"}
         Case #FFAE_ADPCM6  : file_WriteTag{fid,@"COMP",@"ADP6"}
         Case #FFAE_ADPCM8  : file_WriteTag{fid,@"COMP",@"ADP8"}
         Case #FFAE_ADDPCM2 : file_WriteTag{fid,@"COMP",@"ADD2"}
         Case #FFAE_ADDPCM3 : file_WriteTag{fid,@"COMP",@"ADD3"}
         Case #FFAE_ADDPCM4 : file_WriteTag{fid,@"COMP",@"ADD4"}
         Case #FFAE_ADDPCM6 : file_WriteTag{fid,@"COMP",@"ADD6"}
         Case #FFAE_ADDPCM8 : file_WriteTag{fid,@"COMP",@"ADD8"}
         Default            : file_WriteTag{fid,@"COMP",@"RAWD"}
       End Select
       If \rootkey>0 Then file_WriteTag{fid,@"RKEY",\rootkey}
       If \fine><0   Then file_WriteTag{fid,@"FINE",\fine}
       If \loop_start>0 Then file_WriteTag{fid,@"LOOP",\loop_start}
       If \loop_end>0   Then file_WriteTag{fid,@"LEND",\loop_end}
       file_WriteTag{fid,@"CHAN",\channels}
       file_WriteTag{fid,@"BITS",\bits}
       file_WriteTag{fid,@"FLEN",\flength}
       \headerpos = file_GetSeekPos{fid}-4
       file_WriteChunk{fid,@"DATA"}
       \datapos = file_GetSeekPos{fid}
       succ.l = True
       If \encoding><#FFAE_RAW
         \brain_size = SizeOf.ffa_ADPCM_Ctx
         *ctx.ffa_ADPCM_Ctx = AllocVec_(\brain_size,#MEMF_CLEAR)
         *ctx\cSampM  = 0
         *ctx\cSampS  = 0
         *ctx\cDeltaM = 0
         *ctx\cDeltaS = 0
         *ctx\rSampM  = 0
         *ctx\rSampS  = 0
         *ctx\cByte   = 0
         *ctx\fbM     = 0;256
         *ctx\fbS     = 0;256
         *ctx\fpos    = 0
         \brain  = *ctx
       End If
     End If

  Case @"SYSX"
    If \brain=False OR \brain_size<SizeOf.chunk_sysex_header + SizeOf.chunk_sysex_data
      \brain_size = SizeOf.chunk_sysex_header + SizeOf.chunk_sysex_data
      \brain = AllocVec_(\brain_size,#MEMF_CLEAR)
    End If

    If \brain
      *sd.chunk_sysex_data   = \brain
      *sh.chunk_sysex_header = \brain + SizeOf.chunk_sysex_data
      waveID.l = 0
      sxchannel.l = 0
      _ffa_EncodeSysexHeader{*sh,*sd,waveID,sxchannel,\bits,\samplerate,\flength,-1,-1}
      succ = file_WriteMem{fid,*sh,#sizeof_chunk_sysex_header}
      \datapos = file_GetSeekPos{fid}
      \encoding = #FFAE_SYSEX
      \signed = False
    End If

  Case @"WAVE"
    chunk_fmtw\fmt                         = @"fmt "
    chunk_fmtw\size                        = con_LFlip{16}
    chunk_fmtw\form                        = con_WFlip{#WAVE_FORMAT_PCM}
    chunk_fmtw\channels                    = con_WFlip{channels}
    chunk_fmtw\samplerate                  = con_LFlip{samplerate}
    chunk_fmtw\bytes_per_sec               = con_LFlip{samplerate * framesize}
    chunk_fmtw\framesize                   = con_WFlip{framesize  }
    chunk_fmtw\bits                        = con_WFlip{bits }

    chunk_data\DAT                        = @"data"
    cds.l                                 = \blength
    chunk_data\size                       = con_LFlip{cds} ; Laenge der Sampledaten in Bytes

    chunk_form\FORM                       = @"RIFF"
    chunk_form\size                       = con_LFlip{SizeOf.chunk_data + cds + SizeOf.chunk_fmt + 4}
    chunk_form\formtype                   = @"WAVE"

    succ.l = file_WriteMem{ fid,&chunk_form\FORM,SizeOf.chunk_form }
    succ.l & file_WriteMem{ fid,&chunk_fmtw\fmt ,SizeOf.chunk_fmt  }
    succ.l & file_WriteMem{ fid,&chunk_data\DAT ,SizeOf.chunk_data }

    \byteorder = #FFABO_LITTLEENDIAN
    \datapos = file_GetSeekPos{fid}
    ;\datapos   = SizeOf.chunk_form + SizeOf.chunk_fmt + SizeOf.chunk_data
    If \bits = 8 Then \signed = False
    file_SetLittleEndian{fid}

  Case @"AIFF"
    chunk_comm\COMM                       = @"COMM"
    chunk_comm\size                       = &chunk_comm\compression-&chunk_comm\COMM - 8
    chunk_comm\channels                   = channels
    chunk_comm\sampleframes               = \flength
    chunk_comm\bits                       = bits
    chunk_comm\pad                        = 0
    chunk_comm\compression                = 0 ; @"NONE"
    con_Long2Extended{samplerate,&chunk_comm\samplerate\exponent}

    chunk_ssnd\SSND                       = @"SSND"
    chunk_ssnd\size                       = \blength + SizeOf.chunk_ssnd - 8
    chunk_ssnd\offset                     = 0
    chunk_ssnd\blocksize                  = 0

    chunk_form\FORM                       = @"FORM"
    chunk_form\size                       = chunk_comm\size + 8 + chunk_ssnd\size + 8 + 4
    chunk_form\formtype                   = @"AIFF"

    succ = file_WriteMem{fid,&chunk_form\FORM,SizeOf.chunk_form}
    succ & file_WriteMem{fid,&chunk_comm\COMM,chunk_comm\size+8}
    succ & file_WriteMem{fid,&chunk_ssnd\SSND,SizeOf.chunk_ssnd}

    \datapos   = file_GetSeekPos{fid};SizeOf.chunk_form + SizeOf.chunk_comm + SizeOf.chunk_ssnd

  Case @"MAUD"
    chunk_maud\MHDR                       = @"MHDR"
    chunk_maud\size                       = 32
    chunk_maud\mhdr_Samples     = \flength
    chunk_maud\mhdr_SampleSizeC = bits       ;number of bits per sample as stored in MDAT
    chunk_maud\mhdr_SampleSizeU = bits       ;number of bits per sample after decompression
    chunk_maud\mhdr_RateSource  = samplerate ;clock source frequency (see maud.doc)
    chunk_maud\mhdr_RateDevide  = 1          ;clock devide           (see maud.doc)
    chunk_maud\mhdr_ChannelInfo = #MCI_STEREO;channel information (see below)
    chunk_maud\mhdr_Channels    = channels   ;number of channels (mono: 1, stereo: 2, ...)
    chunk_maud\mhdr_Compression = #MCOMP_NONE;compression  (see below)
    chunk_maud\mhdr_Reserved1   = 0          ;MUST be set to 0 when saving
    chunk_maud\mhdr_Reserved2   = 0          ;MUST be set to 0 when saving
    chunk_maud\mhdr_Reserved3   = 0          ;MUST be set to 0 when saving

    chunk_anno\DAT                        = @"ANNO"
    comment.s                             = "This file was created using "+ver.s+". "
    chunk_anno\size                       = Int( FLen(comment.s) / 2) * 2

    chunk_data\DAT                        = @"MDAT"
    chunk_data\size                       = \blength  ; Laenge der Sampledaten in Bytes

    chunk_form\FORM                       = @"FORM"
    chunk_form\size                       = 8 + chunk_data\size + 8 + chunk_anno\size + 8 + chunk_maud\size + 4
    chunk_form\formtype                   = @"MAUD"

    succ = file_WriteMem{fid,&chunk_form\FORM,SizeOf.chunk_form}
    succ & file_WriteMem{fid,&chunk_maud\MHDR,SizeOf.chunk_maud}
    succ & file_WriteMem{fid,&chunk_anno\DAT ,SizeOf.chunk_data}
    succ & file_WriteMem{fid,&comment.s,chunk_anno\size        }
    succ & file_WriteMem{fid,&chunk_data\DAT ,SizeOf.chunk_data}
    \datapos = file_GetSeekPos{fid}
    ;\datapos   = SizeOf.chunk_form + SizeOf.chunk_maud + SizeOf.chunk_data + SizeOf.chunk_data + chunk_anno\size

  Case @"8SVX"
    \bits=8
    \channels=1
    \framesize  = (\channels * \bits) / 8
    \blength = \flength
    \slength = \flength

    chunk_vhdr\VHDR                       = @"VHDR"
    chunk_vhdr\size                       = 20
    chunk_vhdr\OneShotHiSamples           = \flength
    chunk_vhdr\RepeatHiSamples            = 0
    chunk_vhdr\SamplesPerHiCycle          = 0

    GetReg a0,&samplerate+2
    GetReg a1,&chunk_vhdr\Samplerate
    MOVE.w (a0),(a1)

    chunk_vhdr\Octaves                    = 1
    chunk_vhdr\Compression                = #svx_comp_none
    chunk_vhdr\Gain                       = 1.0

    chunk_anno\DAT                        = @"ANNO"
    comment.s                             = "This file was created using "+ver.s+". "
    chunk_anno\size                       = Int( FLen(comment.s) / 2) * 2

    chunk_data\DAT                        = @"BODY"
    chunk_data\size                       = \blength ; Laenge der Sampledaten in Bytes

    chunk_form\FORM                       = @"FORM"
    chunk_form\size                       = 8 + chunk_data\size + 8 + chunk_anno\size + 8 + chunk_vhdr\size + 4
    chunk_form\formtype                   = @"8SVX"

    succ = file_WriteMem{fid,&chunk_form\FORM,SizeOf.chunk_form}
    succ & file_WriteMem{fid,&chunk_vhdr\VHDR,SizeOf.chunk_vhdr}
    succ & file_WriteMem{fid,&chunk_anno\DAT ,SizeOf.chunk_data}
    succ & file_WriteMem{fid,&comment.s,chunk_anno\size        }
    succ & file_WriteMem{fid,&chunk_data\DAT ,SizeOf.chunk_data}
    \datapos = file_GetSeekPos{fid}
    ;\datapos = SizeOf.chunk_form + SizeOf.chunk_vhdr + SizeOf.chunk_data + SizeOf.chunk_data + chunk_anno\size

  Case @"CDDA"
    \bits=16
    \channels=2
    \samplerate = 44100
    \framesize  = (\channels * \bits) / 8
    \blength = \flength * 4
    \slength = \flength * 2
    succ = True

  Case @"ADC"
    \bits=16
    \channels=1
    \samplerate = 16000
    \framesize  = (\channels * \bits) / 8
    \blength = \flength * 4
    \slength = \flength * 2
    \byteorder = #FFABO_LITTLEENDIAN
    succ = True

  Case @"MP3"
    \bits = 16
    \framesize  = (\channels * \bits) / 8
    \blength = \flength * \channels * (\bits / 8)
    \slength = \flength * (\bits / 8)
    kbps.l = 128
    If \samplerate<44100 kbps=96
    If \samplerate>44100 Then kbps=160
    If \channels=1 Then kbps/2
    \user_data = blade_WriteHeader{fid,\samplerate,\channels,kbps}
    \encoding = #FFAE_BLADEMP3
    If \user_data Then succ=True

  Case @"RAW"
    ;-)
    succ = True

  Default
    error{"ffa_WriteHeaderInfo: Unsupported fileformat! ("+Mkl$(form)+")"}

 End Select
 \flength = 0
 If \cframesize<1 Then \cframesize = \framesize
Else
  error{"ffa_WriteHeaderInfo: Tried to write into closed file!"}
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.w = _ffa_UpdateHeader{fid.l}                               /
;/                                                                             /
;/ Description:                                                                /
;/ * private                                                                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.w     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.w _ffa_FinalizeHeader{fid.l}
SHARED ver.s,afileinfo()
SHARED chunk_form,chunk_fmtw,chunk_comm,chunk_maud,chunk_data,chunk_anno,chunk_ssnd,chunk_vhdr
succ.l = False
If file_IsUsed{fid}
 div.l = \bits / 8 : If div=0 Then div=1
 If div><0 Then \slength = \flength * div

 div.l = \channels
 If div=0 Then div=1
 If div><0 Then \blength = \slength * div

 framesize.l = \channels * \bits / 8
 Select \form
  Case @"AB3S"
    If \encoding><#FFAE_RAW  ; TODO: write only when needed
      *ctx.ffa_ADPCM_Ctx = \brain
      file_WriteByte{fid,*ctx\cByte}
    End If
    succ = file_CloseChunk{fid,@"DATA"}
    succ = file_CloseChunk{fid,@"AB3S"}

    If file_Seek{fid,\headerpos}
      file_WriteLong{fid,\flength}
    End If
    succ.l = True

  Case @"SYSX"
    If \brain
      *sd.chunk_sysex_data = \brain
      If *sd\offset>0
        succ = file_WriteMem{fid,*sd,#sizeof_chunk_sysex_data}
      Else
        succ = True
      End If

      *sh.chunk_sysex_header = \brain + SizeOf.chunk_sysex_data
      *sh\length_l = (\flength       )& $7F ; length in words
      *sh\length_m = (\flength LSR  7)& $7F
      *sh\length_h = (\flength LSR 14)& $7F
      If *sh\loop_type=$7F
        loop_end.l = \flength
        *sh\loop_end_l = (loop_end       )& $7F ; loop end point in words
        *sh\loop_end_m = (loop_end LSR  7)& $7F
        *sh\loop_end_h = (loop_end LSR 14)& $7F
      End If

      If file_Seek{fid,\headerpos}
        succ = file_WriteMem{fid,*sh,#sizeof_chunk_sysex_header}
      End If
    End If

  Case @"WAVE"
    chunk_data\size                       = con_LFlip{\blength} ; Laenge der Sampledaten in Bytes
    chunk_form\size                       = con_LFlip{SizeOf.chunk_data + \blength + SizeOf.chunk_fmt + 4}

    If file_Seek{fid,\headerpos + &chunk_form\size-&chunk_form\FORM}
      succ.l = file_WriteMem{ fid,&chunk_form\size  ,4 }
    Else
      error{"Unable to seek to pos "+Str$(\headerpos + &chunk_form\size-&chunk_form\FORM)}
    End If
    If file_FindChunk{fid,@"data",\headerpos + SizeOf.chunk_form+SizeOf.chunk_fmt,-1,-1,0}
      If file_SeekRel{fid,&chunk_data\size-&chunk_data\DAT}
        succ.l & file_WriteMem{ fid,&chunk_data\size, 4}
      End If
    Else
      error{"INTERNAL ERROR: Unable to find \\22data\\22 chunk in wave file again!"}
    End If

  Case @"AIFF"
    chunk_comm\sampleframes               = \flength
    chunk_ssnd\size                       = \blength + SizeOf.chunk_ssnd - 8
    chunk_form\size                       = chunk_comm\size + 8 + chunk_ssnd\size + 8 + 4

    If file_Seek{fid,\headerpos + &chunk_form\size-&chunk_form\FORM}
      succ = file_WriteMem{fid,&chunk_form\size,4}
    End If

    If file_Seek{fid,\headerpos + SizeOf.chunk_form + &chunk_comm\sampleframes-&chunk_comm\COMM}
      succ & file_WriteMem{fid,&chunk_comm\sampleframes,4}
    End If

    If file_Seek{fid,\headerpos + SizeOf.chunk_form +  chunk_comm\size+8 + &chunk_ssnd\size-&chunk_ssnd\SSND}
      succ & file_WriteMem{fid,&chunk_ssnd\size,4}
    End If

  Case @"MAUD"
    chunk_maud\mhdr_Samples     = \flength
    chunk_data\size             = \blength  ; Laenge der Sampledaten in Bytes
    comment.s                   = "This file was created using "+ver.s+"."
    chunk_anno\size             = Int( FLen(comment.s) / 2) * 2
    chunk_form\size             = 8 + chunk_data\size + 8 + chunk_anno\size + 8 + chunk_maud\size + 4

    If file_Seek{fid,\headerpos + &chunk_form\size-&chunk_form\FORM}
    succ = file_WriteMem{fid,&chunk_form\size,4}
    End If
    If file_FindChunk{fid,@"MHDR",\headerpos + SizeOf.chunk_form,-1,-1,0}
      If file_SeekRel{fid,&chunk_maud\mhdr_Samples-&chunk_maud\MHDR}
        succ & file_WriteMem{fid,&chunk_maud\mhdr_Samples,4}
      End If
    Else
      error{"INTERNAL ERROR: Unable to find \\22MHDR\\22 chunk in MAUD file again!"}
    End If

    If file_FindChunk{fid,@"MDAT",\headerpos + SizeOf.chunk_form,-1,-1,0}
      If file_SeekRel{fid,&chunk_data\size-&chunk_data\DAT}
        succ & file_WriteMem{fid,&chunk_data\size ,4}
      End If
    Else
      error{"INTERNAL ERROR: Unable to find \\22MDAT\\22 chunk in MAUD file again!"}
    End If

  Case @"8SVX"
    chunk_vhdr\OneShotHiSamples           = \flength
    chunk_data\size                       = \blength ; Laenge der Sampledaten in Bytes
    comment.s                             = "This file was created using "+ver.s+". "
    chunk_anno\size                       = Int( FLen(comment.s) / 2) * 2
    chunk_form\size                       = 8 + chunk_data\size + 8 + chunk_anno\size + 8 + chunk_vhdr\size + 4

    If file_Seek{fid,\headerpos + &chunk_form\size-&chunk_form\FORM}
      succ = file_WriteMem{fid,&chunk_form\size,4}
    End If

    If file_FindChunk{fid,@"VHDR",\headerpos + SizeOf.chunk_form,-1,-1,0}
      If file_SeekRel{fid,&chunk_vhdr\OneShotHiSamples-&chunk_vhdr\VHDR}
        succ & file_WriteMem{fid,&chunk_vhdr\OneShotHiSamples,4}
      End If
    Else
      error{"INTERNAL ERROR: Unable to find \\22VHDR\\22 chunk in 8SVX file again!"}

    End If

    If file_FindChunk{fid,@"BODY",\headerpos + SizeOf.chunk_form,-1,-1,0}
      If file_SeekRel{fid,&chunk_data\size-&chunk_data\DAT}
        succ & file_WriteMem{fid,&chunk_data\size ,4}
      End If
    Else
      error{"INTERNAL ERROR: Unable to find \\22BODY\\22 chunk in 8SVX file again!"}
    End If

  Case @"CDDA"
    succ=True
    blength.l = \flength*\framesize
    todo.l = 2352 - (blength MOD 2352)
    If todo<2352
      z.l = AllocVec_(todo,#MEMF_CLEAR)
      succ.l = file_WriteMem{fid,z,todo}
      FreeVec_ z
    End If

  Case @"RAW"
  Case @"ADC"
  Case @"MP3"

  Default
    error{"INTERNAL: Unknow header to write!"}

 End Select
Else
  error{"\\__THIS_FUNCTION: Tried to write into closed file!"}
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = ffa_Form2Ext{form.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/ Get a reasonable file extentions for the given form value.                  /
;/ E.g. ffa_Form2Ext{@"MP3"} would result in "mp3".                            /
;/ See ffa_GetFileFormat for possible file formats.                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - form.l    : internal form value                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : file extention                                             /
;/                                                                             /
;/ See also:    ffa_GetFileFormat                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s ffa_Form2Ext{form.l}
Select form
  Case @"AB3S" : extention.s = "ab3s"
  Case @"AB3C" : extention.s = "ab3c"
  Case @"ADD2" : extention.s = "ad2"
  Case @"ADD3" : extention.s = "ad3"
  Case @"ADD4" : extention.s = "ad4"
  Case @"ADD6" : extention.s = "ad6"
  Case @"ADD8" : extention.s = "ad8"
  Case @"ADP2" : extention.s = "ap2"
  Case @"ADP3" : extention.s = "ap3"
  Case @"ADP4" : extention.s = "ap4"
  Case @"ADP6" : extention.s = "ap6"
  Case @"ADP8" : extention.s = "ap8"
  Case @"8SVX" : extention.s = "iff"
  Case @"AIFF" : extention.s = "aiff"
  Case @"WAVE" : extention.s = "wav"
  Case @"MAUD" : extention.s = "maud"
  Case @"CDDA" : extention.s = "cdda"
  Case @"MP3"  : extention.s = "mp3"
  Case @"MP2"  : extention.s = "mp2"
  Case @"MP1"  : extention.s = "mp1"
  Case @"HDRC" : extention.s = "dat"
  Case @"ADC"  : extention.s = "adc"
  Case @"SYSX" : extention.s = "syx"
  Default
    extention.s = ""
End Select
Function Return extention.s
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !ffa_scratch                                                        /
;/                                                                             /
;/ Description:                                                                /
;/       )                                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro ffa_scratch
d0
End Macro
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !ffa_scratch2                                                       /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro ffa_scratch2
d4
End Macro
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !ffa_bfsize                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro ffa_bfsize
d1
End Macro
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !ffa_konto                                                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro ffa_konto
d2
End Macro
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !ffa_sample_end                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro ffa_sample_end
d3
End Macro
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !ffa_ratio                                                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro ffa_ratio
d6
End Macro
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !ffa_srcptr                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro ffa_srcptr
a1
End Macro
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !ffa_dstptr                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro ffa_dstptr
a0
End Macro

#ffa_pitchresbit      = 14
#ffa_pitchresbit_low  = #ffa_pitchresbit-8
#ffa_pitchres         = 1 LSL #ffa_pitchresbit

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = _ffa_Resample{sourceaddr.l,destaddr.l,d_length.l,s_l:: /
;/ ength.l,ratio.l,brain_ptr.l}                                                /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - sourceaddr.l    : ???                                                     /
;/ - destaddr.l    : ???                                                       /
;/ - d_length.l    : ???                                                       /
;/ - s_length.l    : ???                                                       /
;/ - ratio.l    : ???                                                          /
;/ - brain_ptr.l    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _ffa_Resample{sourceaddr.l,destaddr.l,d_length.l,s_length.l,ratio.l,brain_ptr.l}
MOVE.l d5,a3 ; brain ptr

;a3  brain_ptr  0=pointer 4=leftsample 6=rightsample      *

GetReg d3,sourceaddr + s_length*4 ; sample_end
GetReg d1,d_length
GetReg a1,sourceaddr
GetReg a0,destaddr

MOVE.l (a3),d2 ; konto aus brain
MOVE.l d4,d6 ; pitch ratio
MOVE.l d7,-(a7)
MOVE.l 4(a3),a2 ; Last 2 samps

CMP.l #ffa_pitchres,d6
BNE ffa_sint_outloop

SUB.l a1,d3 : ASR.l #2,d3
CMP.l d3,!ffa_bfsize
BLE ffa_sint_directloop
MOVE.l d3,!ffa_bfsize


ffa_sint_directloop:
  MOVE.w (!ffa_srcptr)+,d0 ;:EXT.l d0
  MOVE.w (!ffa_srcptr)+,d4 ;:EXT.l d4
  MOVE.w d0,(!ffa_dstptr)+
  MOVE.w d4,(!ffa_dstptr)+
  SUB.l #1,!ffa_bfsize
  BGT ffa_sint_directloop
BRA ffa_sint_exit

ffa_sint_outloop:
  TST.l !ffa_bfsize : BLE ffa_sint_exit

  ffa_sint_kontorefresh:
    CMP.l ##ffa_pitchres,!ffa_konto : BLE ffa_sint_kontodone
    SUB.l ##ffa_pitchres,!ffa_konto
    MOVE.l (!ffa_srcptr)+,a2
    BRA ffa_sint_kontorefresh
  ffa_sint_kontodone:

  CMP.l !ffa_srcptr,!ffa_sample_end : BLE ffa_sint_exit

  ffa_sint_writesample:
    MOVE.l a2,d0 : SWAP d0 : EXT.l d0
    MOVE.l ##ffa_pitchres,d4  : SUB.l !ffa_konto,d4 : MULS.l d0,d4
    MOVE.w (!ffa_srcptr),d0 : EXT.l d0
    MULS.l !ffa_konto,d0

    ADD.l d0,d4
    ASR.l #8,d4 : ASR.l ##ffa_pitchresbit_low,d4
    MOVE.w d4,(!ffa_dstptr)+


    MOVE.l a2,d0 :  EXT.l d0
    MOVE.l ##ffa_pitchres,d4  : SUB.l !ffa_konto,d4 : MULS.l d0,d4
    MOVE.w 2(!ffa_srcptr),d0 : EXT.l d0
    MULS.l !ffa_konto,d0

    ADD.l d0,d4
    ASR.l #8,d4 : ASR.l ##ffa_pitchresbit_low,d4
    MOVE.w d4,(!ffa_dstptr)+

    ADD.l !ffa_ratio,!ffa_konto
    SUB.l #1,!ffa_bfsize
    BGT ffa_sint_kontorefresh
  ffa_sint_exit:

MOVE.l (a7)+,d7
MOVE.l !ffa_konto,(a3)
MOVE.l a2,4(a3)

GetReg a1,destaddr    ; done zurueck
SUB.l a1,!ffa_dstptr
MOVE.l !ffa_dstptr,d0
ASR.l #3,d0
ret.l = PutD0
Function Return ret
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.w = ffa_WriteData{fid.l,ptr.l,s_blength.l,@channels.l,@bit:: /
;/ s.l,@samplerate.l}                                                          /
;/                                                                             /
;/ Description:                                                                /
;/ Write some audio data to the audio file previously opened with ffa_WriteH:: /
;/ eader.                                                                      /
;/ The arguments specify the format of your source data that can be differen:: /
;/ t from what you want to write to the file. Convertion will be done on the:: /
;/  fly.                                                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l        : file object ID                                             /
;/ - ptr.l        : pointer to memory buffer                                   /
;/ - s_blength.l  : length of the buffer                                       /
;/ - channels.l   : number of channels (1=mono, 2=stereo)                      /
;/ - bits.l       : number of bits (usually 8, 16 or 24)                       /
;/ - samplerate.l : samplerate of the audio data                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l       : -1 if all data was writte, 0 otherwise                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.w ffa_WriteData{fid.l,ptr.l,s_blength.l,@channels.l,@bits.l,@samplerate.l}
SHARED ffa_workbuffer,afileinfo()
succ.l = False
If file_IsUsed{fid}
  If samplerate = -1 Then samplerate = \samplerate
  If bits       = -1 Then bits       = \bits
  If channels   = -1 Then channels   = \channels
  s_framesize.l = channels * bits/8
  \flength + s_blength/s_framesize
  If samplerate=\samplerate AND bits=\bits AND channels=\channels AND \byteorder=#FFABO_BIGENDIAN AND \signed = True AND \encoding=#FFAE_RAW
    succ = file_WriteMem{fid,ptr,s_blength} ;: error{"Burst mode!"}
  Else
    d_framesize.l = \channels * \bits/8
    flength.l     = s_blength / s_framesize
    d_blength.l   = flength * d_framesize

    If s_framesize>d_framesize Then fchunk.l = #ffa_workbuffersize / s_framesize:Else fchunk = #ffa_workbuffersize/d_framesize
    succ = True
    While flength>0 AND succ=True
      If flength>fchunk Then chunk.l=fchunk:Else chunk = flength

      flength-chunk
      conv_any{ptr,ffa_workbuffer,chunk,\mode,\quality,bits,channels,\bits,\channels}

      Select \encoding
        Case #FFAE_RAW
          If \signed=False
            Select \bits
              Case 8
                Unsigned2Signed8{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
              Case 16
                Unsigned2Signed16{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
              Case 24
                Unsigned2Signed24{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
              Case 32
                Unsigned2Signed32{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
            End Select
          End If

          If \byteorder = #FFABO_LITTLEENDIAN
            Select \bits
              Case 8
                ; no convertion!
              Case 16
                FlipEndian16{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
              Case 24
                FlipEndian24{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
              Case 32
                FlipEndian32{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
            End Select
          End If
          succ = file_WriteMem{fid,ffa_workbuffer,chunk * d_framesize}

        Case #FFAE_SYSEX
          ; write data chunk ...
          todo.l = chunk
          tptr.l = ffa_workbuffer
          If \brain
            *sd.chunk_sysex_data   = \brain
            *sh.chunk_sysex_header = \brain + SizeOf.chunk_sysex_data
            While todo>0
              done.l = _ffa_EncodeSysexData{*sh,*sd,tptr,\bits,todo}
              tptr + done * \framesize
              If *sd\offset >= 120
                succ.l = file_WriteMem{fid,*sd,#sizeof_chunk_sysex_data}
                *sd\offset = 0
              End If
              todo - done
            Wend
          End If

        Case #FFAE_FLOAT32 ; 32bit only
          conv_32_Float{ffa_workbuffer,ffa_workbuffer,chunk*\channels,1.0}
          If \byteorder = #FFABO_LITTLEENDIAN Then FlipEndian32{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
          succ = file_WriteMem{fid,ffa_workbuffer,chunk  * \channels * 4}

        Case #FFAE_BLADEMP3
          If \user_data
            succ = blade_WriteData{fid,(.BladeH)\user_data,ffa_workbuffer,chunk*d_framesize}
          End If

        Case #FFAE_ADPCM2
          written.l = _ffa_EncodeADPCM{ffa_workbuffer,ffa_workbuffer,chunk,\channels,2,False,(.ffa_ADPCM_Ctx)\brain}
          succ = file_WriteMem{fid,ffa_workbuffer,written}

        Case #FFAE_ADPCM4
          written.l = _ffa_EncodeADPCM{ffa_workbuffer,ffa_workbuffer,chunk,\channels,4,False,(.ffa_ADPCM_Ctx)\brain}
          succ = file_WriteMem{fid,ffa_workbuffer,written}

        Case #FFAE_ADPCM8
          written.l = _ffa_EncodeADPCM{ffa_workbuffer,ffa_workbuffer,chunk,\channels,8,False,(.ffa_ADPCM_Ctx)\brain}
          succ = file_WriteMem{fid,ffa_workbuffer,written}

        Case #FFAE_ADDPCM2
          written.l = _ffa_EncodeADPCM{ffa_workbuffer,ffa_workbuffer,chunk,\channels,2,True,(.ffa_ADPCM_Ctx)\brain}
          succ = file_WriteMem{fid,ffa_workbuffer,written}

        Case #FFAE_ADDPCM4
          written = _ffa_EncodeADPCM{ffa_workbuffer,ffa_workbuffer,chunk,\channels,4,True,(.ffa_ADPCM_Ctx)\brain}
          succ = file_WriteMem{fid,ffa_workbuffer,written}

        Case #FFAE_ADDPCM8
          written = _ffa_EncodeADPCM{ffa_workbuffer,ffa_workbuffer,chunk,\channels,8,True,(.ffa_ADPCM_Ctx)\brain}
          succ = file_WriteMem{fid,ffa_workbuffer,written}


      End Select
      ptr + chunk * s_framesize
    Wend
  EndIf

Else
  error{"Tried to write into a non-exisiting file!"}
End If
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ffa_ReadData{fid.l,ptr.l,d_blength.l,@channels.l,@bits:: /
;/ .l,@samplerate.l}                                                           /
;/                                                                             /
;/ Description:                                                                /
;/ Read some audiodata from the audiofile previously opened with ffa_ReadHea:: /
;/ der.                                                                        /
;/ The arguments specify the format of your destination data that can be dif:: /
;/ ferent from the data in the file. Convertion will be done on the fly.       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l        : file object ID                                             /
;/ - ptr.l        : pointer to memory buffer                                   /
;/ - d_blength.l  : maxmimum byte length of the buffer                         /
;/ - channels.l   : number of channels (default is the best match with the f:: /
;/ ile)                                                                        /
;/ Possible values are 1 and 2                                                 /
;/ - bits.l       : number of bits (default is the best match with the file)   /
;/ Possible values are 8, 16, 24 and 32 bit                                    /
;/ - samplerate.l : desired sample rate (default is same as file)              /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l       : -1 if everything went well, 0 otherwise                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_ReadData{fid.l,ptr.l,d_blength.l,@channels.l,@bits.l,@samplerate.l}
SHARED ffa_workbuffer,afileinfo()
succ.l = False
If file_IsUsed{fid}

  If samplerate = -1 Then samplerate = \samplerate
  If bits       = -1 Then bits       = \bits
  If channels   = -1 Then channels   = \channels

  If samplerate=\samplerate AND bits=\bits AND channels=\channels AND \byteorder=#FFABO_BIGENDIAN AND \signed = True AND \encoding=#FFAE_RAW
    If file_ReadMem{fid,ptr,d_blength} Then succ=True; : error{"Burst mode!"}
  Else
    s_framesize.l = \channels * \bits/8
    d_framesize.l = channels * bits/8
    flength.l     = d_blength / d_framesize
    s_blength.l   = flength * s_framesize

    If s_framesize>d_framesize Then fchunk.l = #ffa_workbuffersize / s_framesize:Else fchunk = #ffa_workbuffersize/d_framesize
    succ = True

    While flength>0 AND succ=True
      If flength>fchunk Then chunk.l=fchunk:Else chunk = flength

      Select \encoding
        Case #FFAE_MPEGA
          CNIF #use_mpega_library
          succ = mpega_Read{fid,ffa_workbuffer,chunk * s_framesize }
          CEND
        Case #FFAE_MOD
          CNIF #use_ptplay_library
          ;succ = mod_RenderAudio{\user_data,ffa_workbuffer,chunk * s_framesize}
          succ=pt_ReadData{(.ptH)\user_data,ffa_workbuffer,chunk * s_framesize}
          CEND
        Case #FFAE_RAW
          If file_ReadMem{fid,ffa_workbuffer,chunk * s_framesize } Then succ=True
          If \byteorder = #FFABO_LITTLEENDIAN
            Select \bits
              Case 8
                ; no conversion!
              Case 16
                FlipEndian16{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
              Case 24
                FlipEndian24{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
              Case 32
                FlipEndian32{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
            End Select
          End If

          If \signed=False
            Select \bits
              Case 8
                Unsigned2Signed8{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
              Case 16
                Unsigned2Signed16{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
              Case 24
                Unsigned2Signed24{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
              Case 32
                Unsigned2Signed32{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
            End Select
          End If

        Case #FFAE_ADPCM2
           blength2bit.l  = ((chunk / 2) * \channels)/2      ; memory for encoded data
           blength16bit.l = (chunk * 2) * \channels
           If file_ReadMem{fid,ffa_workbuffer+blength16bit,blength2bit} Then succ=True
           _ffa_DecodeADPCM{ffa_workbuffer+blength16bit,ffa_workbuffer,chunk,\channels,2,False,(.ffa_ADPCM_Ctx)\brain}

        Case #FFAE_ADPCM4
           blength4bit.l  = (chunk  *\channels) /2     ; memory for encoded data
           blength16bit.l = chunk * 2 * \channels
           If file_ReadMem{fid,ffa_workbuffer+blength16bit,blength4bit} Then succ=True
           ;If \channels=1
           ;  _ffa_DecodeADPCM4_fast{ffa_workbuffer+blength16bit,ffa_workbuffer,chunk,\brain}
           ;Else
             _ffa_DecodeADPCM{ffa_workbuffer+blength16bit,ffa_workbuffer,chunk,\channels,4,False,(.ffa_ADPCM_Ctx)\brain}
           ;End If

        Case #FFAE_ADPCM8
           blength8bit.l  = (chunk    ) * \channels      ; memory for encoded data
           blength16bit.l = (chunk * 2) * \channels
           If file_ReadMem{fid,ffa_workbuffer+blength16bit,blength8bit} Then succ=True
           _ffa_DecodeADPCM{ffa_workbuffer+blength16bit,ffa_workbuffer,chunk,\channels,8,False,(.ffa_ADPCM_Ctx)\brain}

        Case #FFAE_ADDPCM2
           blength2bit.l  = ((chunk / 2) * \channels)/2      ; memory for encoded data
           blength16bit.l = (chunk * 2) * \channels
           If file_ReadMem{fid,ffa_workbuffer+blength16bit,blength2bit} Then succ=True
           _ffa_DecodeADPCM{ffa_workbuffer+blength16bit,ffa_workbuffer,chunk,\channels,2,True,(.ffa_ADPCM_Ctx)\brain}

        Case #FFAE_ADDPCM4
           blength4bit.l  = (chunk  * \channels) /2     ; memory for encoded data
           blength16bit.l = (chunk * 2) * \channels
           If file_ReadMem{fid,ffa_workbuffer+blength16bit,blength4bit} Then succ=True
           ;If \channels=1
           ;  _ffa_DecodeADDPCM4_fast{ffa_workbuffer+blength16bit,ffa_workbuffer,chunk,\brain}
           ;Else
             _ffa_DecodeADPCM{ffa_workbuffer+blength16bit,ffa_workbuffer,chunk,\channels,4,True,(.ffa_ADPCM_Ctx)\brain}
           ;End If

        Case #FFAE_ADDPCM8
           blength8bit.l  = (chunk    ) * \channels      ; memory for encoded data
           blength16bit.l = (chunk * 2) * \channels
           If file_ReadMem{fid,ffa_workbuffer+blength16bit,blength8bit} Then succ=True
           _ffa_DecodeADPCM{ffa_workbuffer+blength16bit,ffa_workbuffer,chunk,\channels,8,True,(.ffa_ADPCM_Ctx)\brain}

        Case #FFAE_SYSEX
          If \brain
            *sd.chunk_sysex_data = \brain
            *sh.chunk_sysex_header = \brain + SizeOf.chunk_sysex_data
            tptr.l = ffa_workbuffer
            todo.l = chunk
            moffset.l = *sd\offset
            succ.l = True
            While todo>0 AND succ><False
              If moffset>=120
                moffset = 0
                ; todo this has to be checked to seek to a legal sysex dump
                succ = file_ReadMem{fid,*sd,#sizeof_chunk_sysex_data}
              End If
              Select \cframesize
                Case 1 ; 0...7
                  samp.l = *sd\dat[moffset+0]
                  samp = (samp LSL 25) - $80000000
                Case 2 ; 8...13
                  samp = (*sd\dat[moffset+0] LSL  7) | (*sd\dat[moffset+1] LSL  0)
                  samp = (samp LSL 18) - $80000000
                Case 3 ; 14...20
                  samp = (*sd\dat[moffset+0] LSL 14) | (*sd\dat[moffset+1] LSL  7) | (*sd\dat[moffset+2] LSL  0)
                  samp = (samp LSL 11) - $80000000
                Case 4 ; 21...27
                  samp = (*sd\dat[moffset+0] LSL 21) | (*sd\dat[moffset+1] LSL 14) | (*sd\dat[moffset+2] LSL  7) | (*sd\dat[moffset+3] LSL 0)
                  samp = (samp LSL  4) - $80000000
                Case 5 ; 28...32...35
                  samp = (*sd\dat[moffset+0] LSL (28-3)) | (*sd\dat[moffset+1] LSL (21-3)) | (*sd\dat[moffset+2] LSL (14-3)) | (*sd\dat[moffset+3] LSL (7-3)) | (*sd\dat[moffset+4] LSR 3)
                  samp = samp - $80000000
              End Select
              moffset + *sd\cframesize

              Select \framesize
                Case 1 ; 8 bit
                  Poke.b tptr,samp LSR 24
                Case 2 ; 16 bit
                  Poke.w tptr,samp LSR 16
                Case 3 ; 24bit
                  samp LSR 8
                  Poke.w tptr,(samp LSR 8)
                  Poke.b tptr+2,samp & $FF
                Case 4 ; 32bit
                  Poke.l tptr,samp
              End Select
              tptr + \framesize

              todo-1
            Wend
            *sd\offset = moffset
          End If

        Case #FFAE_FLOAT32
          If file_ReadMem{fid,ffa_workbuffer,chunk * s_framesize }
            If \byteorder = #FFABO_LITTLEENDIAN Then FlipEndian32{ffa_workbuffer,ffa_workbuffer,chunk*\channels}
            conv_Float_32{ffa_workbuffer,ffa_workbuffer,chunk*s_framesize/4,1.0}
            succ=True
          End If
      End Select
      \seekpos + chunk
      flength-chunk

      conv_any{ffa_workbuffer,ptr,chunk,\mode,\quality,\bits,\channels,bits,channels}

      ptr + chunk * d_framesize
    Wend
  End If
Else
  error{"Tried to read from a non-exisiting file!"}
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  bytes.l = ffa_GetByteLength{fid.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Get the raw, uncompressed length of audio data in bytes.                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - bytes.l     : number of bytes                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetByteLength{fid.l}
SHARED afileinfo()
Function Return \blength
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  flength.l = ffa_GetFrameLength{fid.l}                             /
;/                                                                             /
;/ Description:                                                                /
;/ Return the sample frame length of the raw, uncompressed audio data.         /
;/ NOTE: in a 16bit stereo file, one frame takes 2*2=4 bytes.                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - flength.l     : sample frame length                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetFrameLength{fid.l}
SHARED afileinfo()
Function Return \flength
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ffa_GetLength{fid.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetLength{fid.l}
SHARED afileinfo()
Function Return ffa_off2ms{fid,\flength}
End Function
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  sr.l = ffa_GetSamplerate{fid.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Return the samplerate of the file (in Hz)                                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - sr.l     : samplerate (=sample frequency)                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetSamplerate{fid.l}
SHARED afileinfo()
Function Return \samplerate
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  bytes.l = ffa_GetFrameSize{fid.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Return the number of bytes of one uncompressed sample frame.                /
;/ NOTE: 16bit stereo data has a frame size of 2*2=4 bytes.                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - bytes.l  : frame size in bytes                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetFrameSize{fid.l}
SHARED afileinfo()
Function Return \framesize
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  channels.l = ffa_GetChannels{fid.l}                               /
;/                                                                             /
;/ Description:                                                                /
;/ Get the number of channels of the raw, uncompressed audio data.             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - channels.l     : number of channels (1=mono, 2=stereo)                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetChannels{fid.l}
SHARED afileinfo()
Function Return \channels
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = ffa_GetCompressionString{fid.l}                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s ffa_GetEncodingString{fid.l}
SHARED afileinfo()
Select \encoding
  Case #FFAE_RAW      : comp.s = "linear PCM"
  Case #FFAE_ADPCM2   : comp.s = "2Bit ADPCM"
  Case #FFAE_ADDPCM2  : comp.s = "2Bit ADDPCM"
  Case #FFAE_ADPCM3   : comp.s = "3Bit ADPCM"
  Case #FFAE_ADDPCM3  : comp.s = "3Bit ADDPCM"
  Case #FFAE_ADPCM4   : comp.s = "4Bit ADPCM"
  Case #FFAE_ADDPCM4  : comp.s = "4Bit ADDPCM"
  Case #FFAE_ADPCM6   : comp.s = "6Bit ADPCM"
  Case #FFAE_ADDPCM6  : comp.s = "6Bit ADDPCM"
  Case #FFAE_ADPCM8   : comp.s = "8Bit ADPCM"
  Case #FFAE_ADDPCM8  : comp.s = "8Bit ADDPCM"
  Case #FFAE_MPEGA    : comp.s = "MPEG"
  Case #FFAE_FLOAT32  : comp.s = "Floating Point"
  Case #FFAE_SYSEX    : comp.s = "SysEx"
  Case #FFAE_MOD      : comp.s = "MOD"
  Case #FFAE_UNKNOWN  : comp.s = "unknown"
  Case #FFAE_BLADEMP3 : comp.s = "Blade MP3"
  Default
    comp.s = "unknown"
End Select
Function Return comp.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ffa_GetCompression{fid.l}                              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetEncoding{fid.l}
SHARED afileinfo()
Function Return \encoding
End Function
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  bits.l = ffa_GetBits{fid.l}                                       /
;/                                                                             /
;/ Description:                                                                /
;/ Get the number of bits of an open file.                                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - bits.l     : number of bits                                               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetBits{fid.l}
SHARED afileinfo()
Function Return \bits
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ffa_GetEndianess{fid.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Get the byte order value of the audio data.                                 /
;/ The byte order can be #FFABO_LITTLEENDIAN OR #FFABO_BIGENDIAN.              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.w     : byte order                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetEndianess{fid.l}
SHARED afileinfo()
Function Return \byteorder
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ffa_GetSigned{fid.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetSigned{fid.l}
SHARED afileinfo()
Function Return \signed
End Function
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ffa_ReportErrs{fid.l,bool.w}                                       /
;/                                                                             /
;/ Description:                                                                /
;/ Set if the file_audio.inlcude should report errors during operation\(-1) :: /
;/ or suppress it (0).                                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/ - bool.w   : report errors during reading                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ffa_ReportErrs{fid.l,bool.w}
SHARED afileinfo()
;\showerr = bool
CNIF #use_mpega_library
If \encoding = #FFAE_MPEGA Then mpega_ReportErrs{fid,bool}
CEND
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ffa_SetMode{fid.l,mode.l,quality.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Set some attributes about how conversion is done.                           /
;/ mode   : 1=left, 0=mix channels, -1=right                                   /
;/ quality: 0=fast, ><0=high quality                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l     : file object ID                                                /
;/ - mode.l    : mode for stereo=>mono convertion                              /
;/ - quality.l : quality settings                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ffa_SetMode{fid.l,mode.l,quality.l}
SHARED afileinfo()
\mode    = mode
\quality = quality
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ffa_Examine{filename.s}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Check if the format of the file is known to the file_audio.include.         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : file name of the file to examine                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : -1 if the file can be loaded, 0 otherwise                    /
;/                                                                             /
;/ See also:    ffa_GetFileFormat                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_Examine{filename.s}
form.l = #FFA_UNKNOWN
fid.l = file_Open{filename.s,#file_read}
If fid>=0
  form.l = ffa_GetFileFormat{fid}
  file_Close{fid}
End If
Function Return form.l
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ffa_Seek{fid.l,fpos.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Seek within the audio file to a cetrain sample frame position.              /
;/ NOTE: The acutal file position that result in this function can differ wa:: /
;/ stly with each file format.                                                 /
;/ NOTE: The next ffa_ReadData will read the data from the new position.       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/ - fpos.l   : samnple frame position                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l   : -1 if seek position was found, 0 otherwise                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_Seek{fid.l,fpos.l}
SHARED afileinfo()
;If fpos><\seekpos
 Select \form
  CNIF #use_mpega_library
  Case @"MP3"
    succ.l = mpega_seek{fid,fpos}

  Case @"MP2"
    succ.l = mpega_seek{fid,fpos}

  Case @"MP1"
    succ.l = mpega_seek{fid,fpos}
  CEND
  CNIF #use_ptplay_library
  Case @"MOD"
    succ.l = pt_Seek{(.ptH)\user_data,fpos}
  CEND

  Case @"SYSX"
    If \brain
      *sd.chunk_sysex_data = \brain
      *sh.chunk_sysex_header = \brain + SizeOf.chunk_sysex_data

      sampsPerDump.l = 120 / *sd\cframesize
      dumps.l = fpos / sampsPerDump
      fseekpos.l = \datapos + dumps * #sizeof_chunk_sysex_data
      succ.l = file_Seek{fid,fseekpos}
      soffset.l = fpos MOD sampsPerDump
      moffset.l = soffset * *sd\cframesize
      *sd\offset = moffset
      succ = file_ReadMem{fid,*sd,#sizeof_chunk_sysex_data}
    End If

  Case @"AB3S"
    If \encoding=#FFAE_RAW
      bpos.l = fpos * \framesize + \datapos
    Else
      Select \encoding
        Case #FFAE_ADPCM2
          blocksize.l = (#FFA_ADPCM_BLOCKSIZE/4) + 3
        Case #FFAE_ADPCM4
          blocksize.l = (#FFA_ADPCM_BLOCKSIZE/2) + 3
        Case #FFAE_ADPCM8
          blocksize.l = (#FFA_ADPCM_BLOCKSIZE/1) + 3
        Case #FFAE_ADDPCM2
          blocksize.l = (#FFA_ADPCM_BLOCKSIZE/4) + 5
        Case #FFAE_ADDPCM4
          blocksize.l = (#FFA_ADPCM_BLOCKSIZE/2) + 5
        Case #FFAE_ADDPCM8
          blocksize.l = (#FFA_ADPCM_BLOCKSIZE/1) + 5
        Default
          error{"Invalid encoding type!"}
      End Select
      blocksize * \channels
      blockpos.l = fpos/#FFA_ADPCM_BLOCKSIZE
      bpos.l = (blockpos * blocksize) + \datapos
      fpos = blockpos*#FFA_ADPCM_BLOCKSIZE
      *ctx.ffa_ADPCM_Ctx = \brain
      *ctx\fpos = fpos
      ;error{"Seek in encoded part!"}
      a.s = "Encoding Seek at byte "+Str$(bpos)+" fpos "+Str$(fpos)+" file: "+Str$(file_GetSeekPos{fid})
      error{a.s}
    End If
    succ.l = file_Seek{fid,bpos}

  Default
    ;error{"Seek in raw part!"}
    bpos.l = fpos * \framesize + \datapos
    succ.l = file_Seek{fid,bpos}
 End Select
 \seekpos = fpos
;Else
;  succ=True
;End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ffa_GetFrameOffset{fid.l}                              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetFrameOffset{fid.l}
SHARED afileinfo()
Function Return \seekpos
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ffa_ReadHeader{filename.s,@checkform.l}                  /
;/                                                                             /
;/ Description:                                                                /
;/ Open an audio file for reading and read the header information.             /
;/ If the function succeeds, you are read to read audio data via ffa_ReadData. /
;/ NOTE: Is is not needed to call ffa_ReadHeaderInfo to get the specs audio :: /
;/ file. ffa_readHeader is doing this already.                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : file name                                                 /
;/ - checkform.l   : check for a valid file format                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l        : -1 if everything went well, 0 otherwise                   /
;/                                                                             /
;/ See also:    ffa_ReadData                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_Open{filename.s,@checkform.l}
SHARED afileinfo()
fid.l = file_Open{filename.s,#file_read}
If fid>=0
  If ffa_ReadHeader{fid,checkform.l}
    ; ...
  Else
    _ffa_FreeHeader{fid}
    file_Close{fid}
    fid = -1
  End If
End If
Function Return fid
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  fid.l = ffa_Clone{ofid.l}                                         /
;/                                                                             /
;/ Description:                                                                /
;/ Clone the lock on an audio file.                                            /
;/ NOTE: this is useful, if you want to keep two different seek positions on:: /
;/  the same file for reading without jumping back and forth in the file.      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - ofid.l    : file object ID                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - fid.l     : file obect ID                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_Clone{ofid.l}
SHARED afileinfo()
fid.l = -1
If ofid>=0
  fid.l = file_Clone{ofid}
  If fid>=0
    succ.l = True
    If afileinfo(ofid)\brain
      \brain = AllocVec_ (afileinfo(ofid)\brain_size,#MEMF_ANY)
      If \brain
        \brain_size  = afileinfo(ofid)\brain_size
        CopyMem_ afileinfo(ofid)\brain, \brain,\brain_size
      Else
        succ = False
      End If
    Else
      \brain_size = 0
      \brain      = False
    End If

    If succ
      Select afileinfo(ofid)\form
        CNIF #use_mpega_library
        Case @"MP3"
          succ.l = mpega_Open{fid,file_GetFullName{ofid}}
        CEND
        Default
          succ.l = True
      End Select
    End If

    If succ
        \form       = afileinfo(ofid)\form
        \flength    = afileinfo(ofid)\flength
        \slength    = afileinfo(ofid)\slength
        \blength    = afileinfo(ofid)\blength
        \datapos    = afileinfo(ofid)\datapos
        \headerpos  = afileinfo(ofid)\headerpos
        \byteorder  = afileinfo(ofid)\byteorder
        \encoding   = afileinfo(ofid)\encoding
        \samplerate = afileinfo(ofid)\samplerate
        \bits       = afileinfo(ofid)\bits
        \channels   = afileinfo(ofid)\channels
        \signed     = afileinfo(ofid)\signed
        \framesize  = afileinfo(ofid)\framesize
        \mode       = afileinfo(ofid)\mode
        \quality    = afileinfo(ofid)\quality
        \accessmode = afileinfo(ofid)\accessmode
        \form       = afileinfo(ofid)\form

        ffa_Seek{fid,afileinfo(ofid)\seekpos}
    Else
      file_Close{fid}
      fid = -1
    End If
  End If
End If
Function Return fid
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  succ.l = ffa_WriteHeader{filename.s,form.l,channels.l,bits.l,sa:: /
;/ mplerate.l,@flength.l,@askoverwrite.l,@setext.l}                            /
;/                                                                             /
;/ Description:                                                                /
;/ Open an audio file for writing and write the header information. The file:: /
;/  is read to take audio data by ffa_WriteData.                               /
;/ NOTE: There is no need to call ffa_WriteHeaderInfo, this is already done :: /
;/ by this function.                                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s     : file name                                                /
;/ - form.l         : form identifier, see ffa_GetFileFromat)                  /
;/ - channels.l     : number of channels (1=mono, 2=stereo)                    /
;/ - bits.l         : number of bits (usually 8, 16 or 24)                     /
;/ - samplerate.l   : samplerate in Hz                                         /
;/ - flength.l      : expected sample frame length (if known)                  /
;/ - askoverwrite.l : ask before overwriting an exisitng file                  /
;/ - setext.l       : force a proper file extention                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - succ.l     : -1 if everything went well, 0 otherwise                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_Write{filename.s,form.l,channels.l,bits.l,samplerate.l,@flength.l,@askoverwrite.l,@setext.l}
SHARED afileinfo()
fid.l = -1

If form><#FFA_UNKNOWN
  If setext Then extention.s = ffa_Form2Ext{form}:Else extention.s = ""
  If askoverwrite Then mode.l = #file_write: Else mode=#file_forcewrite
  fid.l = file_Open{filename.s,mode,extention.s}
  If fid>=0
    If ffa_WriteHeader{fid,form,channels,bits,samplerate,flength}
      ; ...
    Else
      _ffa_FreeHeader{fid}
      file_Erase{fid}
      fid = -1
    End If
  End If
Else
  error{"ffa_Write: called with unknown form! \\22"+Mkl$(form)+"\\22"}
End If
Function Return fid
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ffa_Close{fid.l}                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Close a file opend by ffa_read or ffa_write.                                /
;/ NOTE: It is important to call ffa_close and NOT file_close, since some fi:: /
;/ lformats require a fixup after all data is written.                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ffa_Close{fid.l}
SHARED afileinfo()
If file_IsUsed{fid}
  If \accessmode = #file_write Then succ.l = _ffa_FinalizeHeader{fid}
End If
_ffa_FreeHeader{fid}
file_Close{fid}
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ffa_Erase{fid.l}                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Erase an open audio file. This function does the same like ffa_Close and :: /
;/ dos_delete, but you do not need the close the file.                         /
;/ NOTE: This is useful, if problems during writing occured and you want to :: /
;/ discard the file.                                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - dos.l    : file object ID                                                 /
;/ - fid.l    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ffa_Erase{fid.l}
SHARED afileinfo()
_ffa_FreeHeader{fid}
file_Erase{fid}
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: ffa_Free{}                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ Free all resources associated with the file_audio.include.                  /
;/ NOTE: This is an autoexit function, you do not have to call this manually.  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement ffa_Free{}
SHARED ffa_workbuffer,afileinfo()
For fid.l=0 To #max_files-1
  If \form >< #FFA_UNKNOWN
    ffa_Close{fid}
  End If
Next
If ffa_workbuffer Then FreeVec_ ffa_workbuffer:ffa_workbuffer=False
End Statement
!autoexit{ffa_Free}

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  rookey.b = ffa_GetRootKey{fid.l}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Return the root key on a musical keyboard according the midi standard of :: /
;/ the sample.                                                                 /
;/ NOTE: Not all file formats support this information. If not available, th:: /
;/ e root key will be reported as -1.                                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - rookey.b     : root key (0...127) or -1 (not available)                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.b ffa_GetRootKey{fid.l}
SHARED afileinfo()
Function Return \rootkey
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  fine.b = ffa_GetFineTuning{fid.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Return the fine tuning of the wavesample.                                   /
;/ The fine tuning is messured in "cents", 1 cent = 1/100 semi tone on a mus:: /
;/ ical keyboard.                                                              /
;/ NOTE: Not all file formats support the tuning information. If not availab:: /
;/ le, fine tune will be reported as 0.                                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - fine.b     : fine tuning, usually -50..+50 cents                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.b ffa_GetFineTuning{fid.l}
SHARED afileinfo()
Function Return \fine
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  offset.l = ffa_GetSampleStart{fid.l}                              /
;/                                                                             /
;/ Description:                                                                /
;/ Return the actual start sample frame offset of the wavesample.              /
;/ NOTE: Not all file formats support this information. If not available, sa:: /
;/ mple start will be 0.                                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - offset.l     : sample frame offset                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetSampleStart{fid.l}
SHARED afileinfo()
Function Return \sample_start
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  offset.l = ffa_GetSampleEnd{fid.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Return the actual end sample frame offset of the wavesample.                /
;/ NOTE: Not all file formats support this information. If not available, sa:: /
;/ mple start will be the last sample frame in the file.                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - offset.l     : sample frame offset                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetSampleEnd{fid.l}
SHARED afileinfo()
Function Return \sample_end
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  offset.l = ffa_GetLoopStart{fid.l}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Get the loop start sample frame offset of the wavesample.                   /
;/ NOTE: Not all file formats support this information. If not available, 0 :: /
;/ will be returned.                                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - offset.l     : sample frame offset                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetLoopStart{fid.l}
SHARED afileinfo()
Function Return \loop_start
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = ffa_GetLoop{fid.l}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Return the loop type of the wavesample (usually 0=no loop, 1=normal loop,:: /
;/  2=bidirectional loop).                                                     /
;/ NOTE: Not all file formats support this information. If not available, 0 :: /
;/ is returned.                                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetLoop{fid.l}
SHARED afileinfo()
If \loop_start>=\loop_end Then succ.l=False:Else succ=True
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  offset.l = ffa_GetLoopEnd{fid.l}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Get the loop end sample frame offset of the wavesample.                     /
;/ NOTE: Not all file formats support this information. If not available, th:: /
;/ e sample frame length is returned.                                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - fid.l    : file object ID                                                 /
;/                                                                             /
;/ Result:                                                                     /
;/ - offset.l     : sample frame offset                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l ffa_GetLoopEnd{fid.l}
SHARED afileinfo()
Function Return \loop_end
End Function

CNIF #__include=0
;%Example:
error_SetFlags{#error_stdout}
NPrint "Open audio file..."
Dim files.s(25)
path.s = "ram:"
files.s(0) = "Cache:adpcm4_music.wav"
;files.s(1) = "Cache:adpcm4_explo.wav"
;files.s(2) = "Cache:adpcm4_voice.wav"
;files.s(3) = "Work:Sourcecodes/Games/AmegaOne/Sources/SFX/Sharrukin Soundpool TM/In-Game-Musik/Intro-Music/Title Finale A.wav"
;files.s(3) = "Desktop:/music/W1_Level1_.wav"
;files.s(4) = "Desktop:/music/FF10.wav"

;files.s(0) = "Desktop:/music/IWSLT06_read-speech/IWSLT06_CE_DEV4_001_C.pcm"
;files.s(1) = "Desktop:/music/IWSLT06_read-speech/IWSLT06_CE_TEST_001_C.pcm"
;files.s(2) = "Desktop:/music/IWSLT06_spontaneous-speech/IWSLT06_CE_DEV4_001_C.pcm"
;files.s(3) = "Desktop:/music/IWSLT06_spontaneous-speech/IWSLT06_CE_TEST_001_C.pcm"

;files.s(0) = "Desktop:/music/Audio/Audio_Casio01/A_.wav"
;files.s(0) = "Desktop:/music/Audio/Audio_Casio01/A2007.11.01.14.29.38.wav"

For channels.l=1 To 2
  n.l = 0
  While (files(n))
    sourcefile.l = ffa_Open{files(n)}
    If sourcefile>=0
      flength.l = ffa_GetFrameLength{sourcefile} /2
      flength * 2
      mlength.l = flength * 2 * channels
      membuffer.l = AllocVec_(mlength,#MEMF_ANY)
      If membuffer
        ffa_ReadData{sourcefile,membuffer,mlength,channels,16}
        NPrint "Writing ",dos_FilePart{files(n)},"..."
        fn.s = dos_FilePart{files(n)}
        fn.s = dos_AddPart{path,fn}
        destfile1.l = ffa_Write{dos_RemExt{fn}+Str$(channels),@"ADP4",channels,16,ffa_GetSamplerate{sourcefile},-1,False,True}
        destfile2.l = ffa_Write{dos_RemExt{fn}+Str$(channels),@"ADD4",channels,16,ffa_GetSamplerate{sourcefile},-1,False,True}
        destfile3.l = ffa_Write{dos_RemExt{fn}+Str$(channels),@"ADD8",channels,16,ffa_GetSamplerate{sourcefile},-1,False,True}
        If destfile1>=0
          succ.l = ffa_WriteData{destfile1,membuffer,mlength,channels,16}
          If succ=False Then error{"Error writing data..."}
          ffa_Close{destfile1}
        End If
        If destfile2>=0
          succ.l = ffa_WriteData{destfile2,membuffer,mlength,channels,16}
          If succ=False Then error{"Error writing data..."}
          testfile.s = file_GetDosName{destfile2}
          ffa_Close{destfile2}
        End If
        If destfile3>=0
          succ.l = ffa_WriteData{destfile3,membuffer,mlength,channels,16}
          If succ=False Then error{"Error writing data..."}
          ffa_Close{destfile3}
        End If

        testfid.l = ffa_Open{testfile,True}
        If testfid>=0
          NPrint "Testing..."
          ffa_ReadData{testfid,membuffer,mlength}
          ffa_Clone{testfid}
        End If

        FreeVec_ membuffer
      Else
        error{"Not enough memory!"}
      End If
      ffa_Close{sourcefile}
    Else
      error{"File not found!"}
    End If
    n+1
  Wend
Next

NPrint "Done."
End

CEND
