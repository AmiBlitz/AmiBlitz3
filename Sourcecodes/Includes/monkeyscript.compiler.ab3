; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "WORKBENCH:Programme/Monkeyscript"
; ExeFile         = "msCompiler"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 174
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 6
; CursorColumn    = 13
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 50
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 50
; Max Anim        = 100
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 50
; Max ChunkyBuffer= 2
; /XTRA
CNIF #__include=0
  Syntax 2
  optimize 7
CEND

XINCLUDE "file.include.ab3"
XINCLUDE "monkeyscript.defs.ab3"

#msCompiler_INCLUDED = 1
#msDebug = 0
NEWTYPE.msLabel
name.s      ; name of the label
offset.l    ; offset in binary code
End NEWTYPE

NEWTYPE.msVar
name.s      ; name of the variable
memoffset.l ; offset in var memory
typ.w       ; type
arraysize.l
End NEWTYPE

NEWTYPE.msMacro
name.s        ; name of the macro
replacement.s ; replacetext
End NEWTYPE

NEWTYPE.msCompiler
; compile stats
temp_script_length.l
temp_script_seek.l
temp_script_base.l
temp_line.l
temp_failed.w
temp_errorline.l
temp_error.s
temp_errcount.l
temp_warncount.l

; counters
numLocals.l
numGlobals.l
numLabels.l
numMacros.l

numLocals_l.l
numLocals_f.l
numLocals_b.l
numLocals_s.l
numLocals_p.l

; settings
syntax_softtype_level.l
syntax_autodefine.l
output_depth.l

lasttype.l
externcount.l
End NEWTYPE

#MAX_MSLABELS  =  500
#MAX_MSLOCALS  = 2000
#MAX_MSGLOBALS = 2000
#MAX_MSIFS     =  500
#MAX_MSMACROS  = 1000

#msblocktype_if            = 0
#msblocktype_while         = 1
#msblocktype_select        = 2
#msblocktype_for           = 3
#msblocktype_repeat        = 4
#msblocktype_none          = 5

NEWTYPE.ifbrain
ifid.l
typ.w
special.w
argtyp.w
End NEWTYPE

Dim ms_ifbrain.ifbrain  (#MAX_MSIFS)
Dim ms_lutlabel.msLabel (#MAX_MSLABELS)
Dim ms_lutlocal.msVar   (#MAX_MSLOCALS)
Dim ms_lutglobal.msVar  (#MAX_MSGLOBALS)
Dim ms_lutmacro.msMacro (#MAX_MSMACROS)

Dim typename.s(16) ; wrapper from typID to name
Dim typeext.s(16)  ; wrapper from typID to extention
Dim blockname.s(16)
Dim blockend.s(16)

SHARED msCompiler.msCompiler
USEPATH msCompiler

typeext.s(#mstype_int)           = "l"
typeext.s(#mstype_float)         = "f"
typeext.s(#mstype_bool)          = "b"
typeext.s(#mstype_string)        = "s"
typeext.s(#mstype_pointer)       = "p"
typeext.s(#mstype_undefined)     = "?"
typeext.s(#mstype_none)          = "#"
typeext.s(#mstype_any)           = "*"
typeext.s(#mstype_intvar)        = "i"
typeext.s(#mstype_floatvar)      = "g"
typeext.s(#mstype_boolvar)       = "a"
typeext.s(#mstype_stringvar)     = "t"
typeext.s(#mstype_var)           = "v"

typename.s(#mstype_int)          = "integer"
typename.s(#mstype_float)        = "float"
typename.s(#mstype_bool)         = "bool"
typename.s(#mstype_string)       = "string"
typename.s(#mstype_pointer)      = "pointer"
typename.s(#mstype_undefined)    = "undefined"
typename.s(#mstype_none)         = "none"
typename.s(#mstype_any)          = "any"
typename.s(#mstype_var)          = "variable"
typename.s(#mstype_intvar)       = "*integer"
typename.s(#mstype_floatvar)     = "*float"
typename.s(#mstype_boolvar)      = "*bool"
typename.s(#mstype_stringvar)    = "*string"

blockname.s(#msblocktype_if)     = "If"
blockname.s(#msblocktype_while)  = "While"
blockname.s(#msblocktype_select) = "Select"
blockname.s(#msblocktype_for)    = "For"
blockname.s(#msblocktype_repeat) = "Repeat"
blockname.s(#msblocktype_none)   = "{"

blockend.s(#msblocktype_if)      = "EndIf"
blockend.s(#msblocktype_while)   = "Wend"
blockend.s(#msblocktype_select)  = "EndSelect"
blockend.s(#msblocktype_for)     = "Next"
blockend.s(#msblocktype_repeat)  = "Until"
blockend.s(#msblocktype_none)    = "}"

; output a log message via stdout
Statement msc_Log{text.s}
DefaultOutput
NPrint text.s
If Used Window >=0 Then WindowOutput Used Window
End Statement

; output an error
Statement msc_Error{error.s}
If msCompiler\output_depth>0
  msc_Log{"\\1b[1mError in line "+Str$(msCompiler\temp_line)+": \\1b[0m"+error.s}
EndIf
If \temp_errorline<0 Then \temp_errorline = msCompiler\temp_line:\temp_error=error.s
\temp_failed = True
\temp_errcount+1
End Statement

; output a warning
Statement msc_Warn{error.s}
If msCompiler\output_depth>1
  msc_Log{"Warning in line "+Str$(msCompiler\temp_line)+": "+error.s}
End If
\temp_warncount+1
End Statement

; output a warning
Statement msc_Info{text.s,@pri.l}
If pri<0 Then pri=3
If msCompiler\output_depth>=pri
  msc_Log{text.s}
End If
End Statement


Function.l msc_IsTokenChar{char.b}
If char>=@"a" AND char<=@"z" Then Function Return True
If char>=@"A" AND char<=@"Z" Then Function Return True
If char>=@"0" AND char<=@"9" Then Function Return True
If char=@"$" OR char=@"_" OR char=@"@" OR char=@"." OR char=@"}" Then Function Return True
Function Return False
End Function


; find the lut index of a statement/function
Function.w msc_FindFunc{name.s,@typ.w,@arg1typ.w,@args.l,@unique.l}
SHARED msfunc()
succ.w = False:n.l = 0:func.w = -1
count.l = 0

If LCase$(Left$(name,5))="func$"
  fid.l = Vallong(Right$(name,FLen(name)-4))
  name = Mkl$(fid)
  name = Peek.s(&name)
End If

If name.s><""
  While n<msengine\numFuncs
    If LCase$(name.s) = LCase$(msfunc(n)\name)
      ok.l = 0
      If (typ=msfunc(n)\typ[0]) OR (typ=#mstype_any AND msfunc(n)\typ[0]><#mstype_none) OR (typ=-1) Then ok+1
      If (arg1typ=msfunc(n)\typ[1]) OR (arg1typ=#mstype_any) OR (arg1typ=-1) OR (msfunc(n)\typ[1]=#mstype_any) Then ok+1
      If args<=msfunc(n)\maxargs Then ok+1
      If ok=3 Then func=n : count+1
    End If
    n+1
  Wend
End If
If unique AND count>1 Then func=-2
Function Return func
End Function



; find the lut index of a local variable
Function.l msc_FindLocal{name.s}
SHARED ms_lutlocal(),typeext.s()
succ.w = False:n.l = 0:var.l = -1
ex.s  = LCase$(dos_GetExt{name})
name.s = dos_RemExt{name}
While n<msCompiler\numLocals AND var = -1
  If LCase$(name.s) = LCase$(ms_lutlocal(n)\name) Then var = n
  n+1
Wend
If var>=0
  If ex
    If ex><typeext.s(ms_lutlocal(var)\typ)
      msc_Error{"Variable "+ms_lutlocal(var)\name+"."+typeext(ms_lutlocal(var)\typ)+" referenced with wrong type ."+ex+"!"}
    End If
  End If
End If
Function Return var
End Function

; find the lut index of a global variable
Function.l msc_FindGlobal{name.s}
SHARED ms_lutglobal(),typeext.s()
succ.w = False:n.l = 0:var.l = -1
ex.s  = LCase$(dos_GetExt{name})
name.s = dos_RemExt{name}

While n<msCompiler\numGlobals AND var = -1
  If LCase$(name.s) = LCase$(ms_lutglobal(n)\name) Then var = n
  n+1
Wend
If var>=0
  If ex
    If ex><typeext.s(ms_lutglobal(var)\typ)
      msc_Error{"Global variable "+ms_lutglobal(var)\name+"."+typeext(ms_lutglobal(var)\typ)+" referenced with wrong type ."+ex+"!"}
    End If
  End If
End If
Function Return var
End Function


; crop the first token of a line
Function.s msc_CropToken{}
succ.w = False
comline.s = ""
count.l = 0
While comline.s="" AND msCompiler\temp_script_seek<msCompiler\temp_script_length AND count<1000
  ptr.l = msCompiler\temp_script_base + msCompiler\temp_script_seek
  While msCompiler\temp_script_seek<msCompiler\temp_script_length AND PeekUB(ptr)<=@" "
    If Peek.b(ptr) = 10 Then msCompiler\temp_line+1
    ptr+1
    msCompiler\temp_script_seek + 1
  Wend
  c.b = Peek.b(ptr)
  While msCompiler\temp_script_seek<msCompiler\temp_script_length AND msc_IsTokenChar{c}
    comline.s + Chr$(Peek.b(ptr))
    ptr + 1
    msCompiler\temp_script_seek + 1
    c.b = Peek.b(ptr)
  Wend

  If Peek.b(ptr) = @";" AND msCompiler\temp_script_seek<msCompiler\temp_script_length
    Repeat
      ptr+1
      msCompiler\temp_script_seek + 1
    Until Peek.b(ptr)=10 OR msCompiler\temp_script_seek>=msCompiler\temp_script_length
  End If
  count+1
Wend
Function Return comline.s
End Function


; crop all arguments following a token
Function.s msc_CropArgs{}
succ.w = False
comline.s = ""
ptr.l = msCompiler\temp_script_base + msCompiler\temp_script_seek
quoted.w = False

While msCompiler\temp_script_seek<msCompiler\temp_script_length AND Peek.b(ptr)><10 AND (((Peek.b(ptr)><@":" OR Peek.b(ptr+1)=@"=") AND Peek.b(ptr)><@";" AND Peek.b(ptr)><@"{" AND Peek.b(ptr)><@"}") OR quoted=1)
  If Peek.b(ptr)=34 Then quoted = 1-quoted
  If Peek.b(ptr)>32 OR quoted=1 Then comline.s + Chr$(Peek.b(ptr))
  ptr + 1
  msCompiler\temp_script_seek + 1
Wend
If Peek.b(ptr) = @":" Then msCompiler\temp_script_seek + 1
If Peek.b(ptr) = @"{" Then msCompiler\temp_script_seek + 1
If Peek.b(ptr) = @";" AND msCompiler\temp_script_seek<msCompiler\temp_script_length
  Repeat
    ptr+1
    msCompiler\temp_script_seek + 1
  Until Peek.b(ptr)=10 OR msCompiler\temp_script_seek>=msCompiler\temp_script_length
End If

Function Return comline.s
End Function


; declare a local variable
Function.l msc_DeclareLocal{name.s,typ.b,arraysize.l}
SHARED ms_lutlocal()
var.l = -1
If Mid$(name.s,FLen(name.s)-1,1) = "." Then name.s = Left$(name.s,FLen(name.s)-2)
If \numLocals<#MAX_MSLOCALS
  If msc_FindLocal{name.s}  >< -1 Then msc_Error{"Variable \\22"+name+"\\22  is already declared as local!" }:Goto skiplocal
  If msc_FindGlobal{name.s} >< -1 Then msc_Error{"Variable \\22"+name+"\\22  is already declared as global!"}:Goto skiplocal
  If arraysize<1 Then arraysize=1
  Select typ
   Case #mstype_int
     ms_lutlocal(\numLocals)\memoffset = (\numLocals_l*4) : \numLocals_l+1*arraysize
   Case #mstype_float
     ms_lutlocal(\numLocals)\memoffset = (\numLocals_f*4) : \numLocals_f+1*arraysize
   Case #mstype_bool
     ms_lutlocal(\numLocals)\memoffset = (\numLocals_b*1) : \numLocals_b+1*arraysize
   Case #mstype_string
     ms_lutlocal(\numLocals)\memoffset = (\numLocals_s*4) : \numLocals_s+1*arraysize
   Case #mstype_pointer
     ms_lutlocal(\numLocals)\memoffset = (\numLocals_p*4) : \numLocals_p+1*arraysize
   Default
     msc_Error{"Internal error: Invalid type defined!"}
  End Select
  ms_lutlocal(\numLocals)\name      = name.s
  ms_lutlocal(\numLocals)\typ       = typ
  ms_lutlocal(\numLocals)\arraysize = arraysize
  var.l = \numLocals
  \numLocals + 1
  skiplocal:
;  error{"LOCAL Defined "+name.s}
Else
  msc_Error{"Too many local variables declared! Maximum is "+Str$(#MAX_MSLOCALS)+"!"}
End If
Function Return var
End Function

; declare a global variable
Function.l msc_DeclareGlobal{name.s,typ.b,noarray.l}
SHARED ms_lutglobal()
var.l = -1

If Mid$(name.s,FLen(name.s)-1,1) = "." Then name.s = Left$(name.s,FLen(name.s)-2)
If \numGlobals<#MAX_MSGLOBALS
  If msc_FindLocal{name.s}  >< -1 Then msc_Error{"Variable \\22"+name+"\\22  is already declared as local!" }:Goto skipglobal
  If msc_FindGlobal{name.s} >< -1 Then msc_Error{"Variable \\22"+name+"\\22  is already declared as global!"}:Goto skipglobal

  ms_lutglobal(\numGlobals)\name      = name.s
  ms_lutglobal(\numGlobals)\typ       = typ
  If noarray
    ms_lutglobal(\numGlobals)\arraysize = 1
  Else
    ms_lutglobal(\numGlobals)\arraysize = 0
  End If
  var.l = \numGlobals
  \numGlobals + 1
  skipglobal:
;  error{"global Defined "+name.s}
Else
  msc_Error{"Too many global variables declared! Maximum is "+Str$(#MAX_MSGLOBALS)+"!"}
End If
Function Return var
End Function
 

; define a label
Statement msc_DefineLabel{name.s,offset.l}
SHARED ms_lutlabel()
If Left$(name.s,1)="." Then name.s = Right$(name.s,FLen(name.s)-1)
n.l = 0
succ.w = False

While n.l<msCompiler\numLabels AND succ.w = False
  If ms_lutlabel(n)\name = name.s
    If ms_lutlabel(n)\offset>=0
      msc_Error{"Label \\22"+name.s+"\\22 is already defined!"}
    End If
    succ.w = True
  Else
    n+1
  End If
Wend
If succ=False Then msCompiler\numLabels+1
If n>=#MAX_MSLABELS
  msc_Error{"Too many labels defined. Maximum is "+Str$(#MAX_MSLABELS)+"!"}
Else
  ms_lutlabel(n)\name   = name.s
  ms_lutlabel(n)\offset = offset
End If
End Statement


; find OR create a label
Function.l msc_FindLabel{name.s}
SHARED ms_lutlabel()
If Left$(name.s,1)="." Then name.s = Right$(name.s,FLen(name.s)-1)
n.l = 0
succ.w = False
While n.l<msCompiler\numLabels AND succ.w = False
  If ms_lutlabel(n)\name = name.s
    succ.w = True
  Else
    n+1
  End If
Wend

If succ = False
  msCompiler\numLabels +1
  ms_lutlabel(n)\name   = name.s
  ms_lutlabel(n)\offset = -1
End If
Function Return n
End Function


; check if the operator could be infix
Function.w msc_IsInfixChar{char.b}
succ.w = False
Select char
  Case @"%" : succ=True
  Case @"&" : succ=True
  Case @"*" : succ=True
  Case @"+" : succ=True
  Case @"-" : succ=True
  Case @"/" : succ=True
  Case @">" : succ=True
  Case @"=" : succ=True
  Case @"<" : succ=True
  Case @"|" : succ=True
  Case @"!" : succ=True
End Select
Function Return succ
End Function


; check if the operator could be prefix
Function.w msc_IsPrefixChar{char.b}
succ.w = False
Select char
  Case @"!" : succ=True
  Case @"-" : succ=True
End Select
Function Return succ
End Function


Function.s msc_ParseArg{arg.s,typ.w,@onlyexp.l}
SHARED ms_lutlocal(),ms_lutglobal(),msfunc(),typeext.s(),typename.s(),codeline.s
realtyp.b         = #mstype_undefined
CNIF #msDebug =1
NPrint "parsearg <"+typename(typ)+">: <",arg,">"
CEND
oarg.s = arg
; ********************************** find infix operator and make it prefix
infixagain:
quoted.w         = False
klammercounter.w = 0
lastklammer.l    = -1
infix.w          = False
infixpos.l       = -1
infixpri.l       = -1
infixname.s      = ""
infixop.w        = -1
infixfound.l     = False
varmode.l        = False

; find infix operator....
For n.l=1 To FLen(arg.s)
  char.b = Peek.b(&arg.s+n-1)
  If char=@"(" OR char=@"[" Then klammercounter+1:If klammercounter=1 Then lastklammer=n
  If char=34 Then quoted=1-quoted

  If klammercounter<1 AND quoted=False AND n>=1 ; surface level
    If n>1 ; not the first char
      If msc_IsInfixChar{char}=True
        infix.w = True
        pos.l = n
        name.s = ""
        succ.w = False
        infixfound=False
        While pos<=FLen(arg.s) AND succ.w=False
          If msc_IsInfixChar{Asc(Mid$(arg.s,pos,1))} = False ;AND is_prefix{Asc(Mid$(arg.s,pos,1))} = False
            succ=True
          Else
            newname.s = name + Mid$(arg.s,pos,1)
            infixop = msc_FindFunc{newname.s}
            If infixop><-1 OR infixfound=False
              name.s = newname
              infixfound = True
              pos+1
            Else
              succ=True
            End If
          End If
        Wend
        infixop=msc_FindFunc{name.s,-1,-1,-1,False}
        If infixop>=0
          If msfunc(infixop)\precedence>=infixpri
            infixpri  = msfunc(infixop)\precedence
            infixpos  = n
            infixname = name
            n=pos-1
          End If
        End If
      End If
    Else
      If msc_IsPrefixChar{char}=True Then infix.w = True : infixpos = n :infixpri=#msprec_unary : infixname=Chr$(char)
    End If
  End If
  If char=@")" OR char=@"]" Then klammercounter-1
Next

If lastklammer=1 AND Right$(arg.s,1)=")" Then arg.s = Mid$(arg.s,2,FLen(arg.s)-2) : Goto infixagain

If klammercounter>0 Then msc_Error{"Error in expression! \\22)\\22 expected."}
If klammercounter<0 Then msc_Error{"Error in expression! \\22(\\22 expected."}


If infix=True ; convert infix to prefix
  If infixname><"" Then name=infixname
  pos = infixpos+FLen(name)
  arg1.s = Left$ (arg.s,infixpos-1)
  arg2.s = Right$(arg.s,FLen(arg.s)-pos+1)
  If arg1.s="" Then arg1.s=arg2.s : arg2.s = "" ; for unary operators
  minargs.l=0
  If arg1.s Then minargs+1
  If arg2.s Then minargs+1
  infixop = msc_FindFunc{name.s,-1,-1,minargs,False}
  If infixop>=0
    If msfunc(infixop)\id = #msfunc_let
      varmode.l = True
    End If
    dummy.l = 0
    l.l = FLen(name)
    If l>0 Then Poke.b &dummy+0,Peek.b(&name+0)
    If l>1 Then Poke.b &dummy+1,Peek.b(&name+1)
    If l>2 Then Poke.b &dummy+2,Peek.b(&name+2)
    name = "func$"+Hex$(dummy)  ; for tunneling
    If arg1
      If arg2
        arg.s = name+"("+arg1+","+arg2+")"
      Else
        arg.s = name+"("+arg1+")"
      End If
    Else
      arg.s = name
    End If
  Else
    msc_Error{"Unknown infix operator \\22"+name.s+"\\22!"}
  End If
  ;NPrint "Covnerted infix to :",arg
End If
first.b  = Peek.b(&arg.s)
pos.l    = 0

CNIF #msDebug=1
NPrint "continue <"+typename(typ)+">: <",arg,">"
CEND
result.s = "X"

;************************************************** do we have a constant value ?
If first =@"#"  OR first =@"$" Then realtyp=#mstype_int  ; (Hex)
If first =@"-"  OR first =@"+" Then If typ=#mstype_float Then realtyp=#mstype_float:Else realtyp=#mstype_int
If first>=@"0" AND first<=@"9" Then If typ=#mstype_float Then realtyp=#mstype_float:Else realtyp=#mstype_int
If first =@"." Then realtyp = #mstype_float

If realtyp=#mstype_int
  For n.l=1 To FLen(arg.s)
    If Peek.b(&arg.s+n-1)=@"." Then realtyp=#mstype_float
  Next
End If

If first=$22 ; Dequote
  realtyp=#mstype_string

  If Peek.b(&arg+FLen(arg)-1)=34
    arg.s = Mid$(arg.s,2,FLen(arg.s)-2)
  Else
    msc_Error{"Unterminated string!"}
    arg.s = Mid$(arg.s,2,FLen(arg.s)-1)
  End If
  For n.l=0 To FLen(arg)-1
    Select Peek.b(&arg+n)
      Case @"\" : deref.l = True
      Case 34
        If deref=False
          msc_Error{"Unexpected quote in string!"}
        End If
        deref=False
      Default
        deref=False
    End Select
  Next
  stringres.s = arg.s : xpos.l = 0
  While xpos<FLen(stringres)
    ypos.l = Instr(stringres,"\",xpos)
    If ypos>0
      Select Peek.b(&stringres+ypos+1-1)
        Case @"n" : stringres = Left$(stringres,ypos-1)+Chr$(10)+Right$(stringres,FLen(stringres)-ypos-1) : ypos-1
        Case @"r" : stringres = Left$(stringres,ypos-1)+Chr$(13)+Right$(stringres,FLen(stringres)-ypos-1) : ypos-1
        Case @"t" : stringres = Left$(stringres,ypos-1)+Chr$( 9)+Right$(stringres,FLen(stringres)-ypos-1) : ypos-1
        Case @"f" : stringres = Left$(stringres,ypos-1)+Chr$(12)+Right$(stringres,FLen(stringres)-ypos-1) : ypos-1
        Case @"a" : stringres = Left$(stringres,ypos-1)+Chr$( 7)+Right$(stringres,FLen(stringres)-ypos-1) : ypos-1
        Case @"b" : stringres = Left$(stringres,ypos-1)+Chr$( 8)+Right$(stringres,FLen(stringres)-ypos-1) : ypos-1
        Case @"v" : stringres = Left$(stringres,ypos-1)+Chr$(11)+Right$(stringres,FLen(stringres)-ypos-1) : ypos-1
        Case 34   : stringres = Left$(stringres,ypos-1)+Chr$(34)+Right$(stringres,FLen(stringres)-ypos-1) : ypos-1
        Case @"\" : stringres = Left$(stringres,ypos-1)+"\"+Right$(stringres,FLen(stringres)-ypos-1)      : ypos-1
        Case @"x"
          char1.b = Peek.b(&stringres+ypos+2-1)
          char2.b = Peek.b(&stringres+ypos+3-1)
          acc1.l = False:acc2.l=False
          If char1>=@"0" AND char1<=@"9" Then acc1=True
          If char1>=@"a" AND char1<=@"f" Then acc1=True
          If char1>=@"A" AND char1<=@"F" Then acc1=True
          If char2>=@"0" AND char2<=@"9" Then acc2=True
          If char2>=@"a" AND char2<=@"f" Then acc2=True
          If char2>=@"A" AND char2<=@"F" Then acc2=True
          If acc1 AND acc2
            a.s = "$"+Chr$(char1)+Chr$(char2)
            n.l = Vallong(a.s)
            stringres = Left$(stringres,ypos-1)+Chr$(n)+Right$(stringres,FLen(stringres)-ypos-3)
            ypos-3
          Else
            msc_Error{"ASCII code is not a valid hexadecimal number!"}
          End If
        Default
          c.b = Peek.b(&stringres+ypos+1-1)
          msc_Error{"Invalid escape sequence \"+Chr$(c)+" ("+Str$(c)+")in string constant!"}
      End Select
      xpos=ypos+1
    Else
      xpos = FLen(stringres)
    End If
  Wend
End If

If first=@"#" Then arg.s = "$"+Right$(arg.s,FLen(arg.s)-1)
intres.l   = Vallong(arg.s)
floatres.f = Val(arg.s)
boolres.b  = False
ptrres.l   = Vallong(arg)
Select LCase$(arg.s)
   Case "true"
     boolres = True  : realtyp = #mstype_bool
   Case "false"
     boolres = False : realtyp = #mstype_bool
   Case "on"
     boolres = True  : realtyp = #mstype_bool
   Case "off"
     boolres = False : realtyp = #mstype_bool
   Case "pi"
     floatres = Pi   : realtyp = #mstype_float
   Default
     boolres= Vallong(arg.s)
End Select

; any? => then we can defined it by the found constant
If typ=#mstype_any AND realtyp><#mstype_undefined Then typ=realtyp

; constant convertion
If msCompiler\syntax_softtype_level>0  ; only looseless
  If realtyp=#mstype_int    AND typ=#mstype_float  Then msc_Warn{"Implicit constant conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_float : floatres = intres
  If realtyp=#mstype_bool   AND typ=#mstype_int    Then msc_Warn{"Implicit constant conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_int   : intres   = boolres
  If realtyp=#mstype_float  AND typ=#mstype_int    Then msc_Warn{"Implicit constant conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_int   : intres   = Int(floatres)
  If realtyp=#mstype_int    AND typ=#mstype_bool   Then msc_Warn{"Implicit constant conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_bool  : If intres Then boolres=True:Else boolres=False
End If
If msCompiler\syntax_softtype_level>1  ; lossy
  If realtyp=#mstype_int    AND typ=#mstype_string Then msc_Warn{"Implicit constant conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_string : stringres = Str$(intres)
  If realtyp=#mstype_float  AND typ=#mstype_string Then msc_Warn{"Implicit constant conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_string : stringres = Str$(floatres)
  If realtyp=#mstype_bool   AND typ=#mstype_string Then msc_Warn{"Implicit constant conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_string : If boolres Then stringres = "True":Else stringres = "False"
End If
If msCompiler\syntax_softtype_level>2  ; crazy
  If realtyp=#mstype_string AND typ=#mstype_float  Then msc_Warn{"Implicit constant conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_float  : floatres = Val(stringres)
  If realtyp=#mstype_bool   AND typ=#mstype_float  Then msc_Warn{"Implicit constant conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_float  : If boolres Then floatres=-1:Else floatres=0
  If realtyp=#mstype_string AND typ=#mstype_int    Then msc_Warn{"Implicit constant conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_int    : intres   = Vallong(stringres)
  If realtyp=#mstype_float  AND typ=#mstype_bool   Then msc_Warn{"Implicit constant conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_bool   : If floatres Then boolres=True:Else boolres=False
  If realtyp=#mstype_string AND typ=#mstype_bool
    msc_Warn{"Implicit constant conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_bool
    Select LCase$(stringres)
      Case "true"
        boolres=True
      Case"on"
        boolres=True
      Default
        boolres=False
    End Select
  End If
End If
Select realtyp
  Case #mstype_int    : result.s = "C"+typeext(#mstype_int    ) + Mkl$(intres)
  Case #mstype_float  : result.s = "C"+typeext(#mstype_float  ) + Mkl$(Peek.l(&floatres))
  Case #mstype_bool   : result.s = "C"+typeext(#mstype_bool   ) + Chr$(boolres)
  Case #mstype_string : result.s = "C"+typeext(#mstype_string ) + stringres.s + Chr$(0)
  Case #mstype_pointer: result.s = "C"+typeext(#mstype_pointer) + Mkl$(ptrres)

  Default  ; Operator oder Variable ?
    pos.l = 1 : name.s = ""
    done.l = False
    opcount.l=-1
    Repeat
      char.b=Peek.b(&arg+pos-1)
      If msc_IsTokenChar{char}
        name + Chr$(char)
        pos+1
      Else
        done=True
      End If
      If pos>FLen(arg.s) Then done=True
    Until done

    ex.s = dos_GetExt{name}
    If ex><""  ; it's a variable with extention
      Select LCase$(ex)
        Case typeext(#mstype_int)     : realtyp = #mstype_int
        Case typeext(#mstype_float)   : realtyp = #mstype_float
        Case typeext(#mstype_bool)    : realtyp = #mstype_bool
        Case typeext(#mstype_string)  : realtyp = #mstype_string
        Case typeext(#mstype_pointer) : realtyp = #mstype_pointer
        Default
          msc_Error{"Unknown variable type \\22"+ex+"\\22!"}
      End Select
      ;If typ=#mstype_any AND realtyp><#mstype_undefined Then typ=realtyp
    Else
      ;Print "Checking for ",name.s,"<",typename(typ),">..."
      opcount.l = msc_FindFunc{name.s}
      ;NPrint opcount
    End If

    If opcount=-1 ; nothing found, must be a variable
      var_l.l = msc_FindLocal {name.s} : If var_l>=0 AND realtyp=#mstype_undefined Then realtyp=ms_lutlocal(var_l)\typ
      var_g.l = msc_FindGlobal{name.s} : If var_g>=0 AND realtyp=#mstype_undefined Then realtyp=ms_lutglobal(var_g)\typ
      If var_l>=0 AND var_g>=0 Then msc_Error{"INTERNAL: Variable local/global clash!!!"}

      If var_l<0 AND var_g<0  AND realtyp><#mstype_undefined
        var_l = msc_DeclareLocal{name.s,realtyp,1}
        If var_l>=0
          If msCompiler\syntax_autodefine=False
            msc_Warn{"Implicit variable declaration: \\22"+arg.s+"\\22 (<"+typename(realtyp)+">)!"}
          End If
        Else
          msc_Error{"Unable to declare local variable \\22"+arg.s+"\\22!"}
        End If
      Else
        If var_l>=0
          If realtyp><ms_lutlocal(var_l)\typ  Then msc_Error{"Variable referenced with wrong type!"}
          ;If ex Then msc_Warn{"Variable \\22"+ms_lutlocal(var_l)\name+"\\22 (<"+typename(ms_lutlocal(var_l)\typ)+">) already declared!"}
        End If
        If var_g>=0
          If realtyp><ms_lutglobal(var_g)\typ  Then msc_Error{"Global variable referenced with wrong type!"}
          ;If ex Then msc_Warn{"Global variable \\22"+ms_lutglobal(var_g)\name+"\\22 (<"+typename(ms_lutglobal(var_g)\typ)+">) already declared!"}
        End If
      End If

      If var_l>=0 AND var_g>=0 Then msc_Error{"INTERNAL: Variable Local/Global clash!!!"}

      arrayIndex.s=""
      ;Print "x: ",arg
      If Peek.b(&arg+pos-1)=@"["
        While Peek.b(&arg+pos)>31 AND Peek.b(&arg+pos)><@"]"
          c.b = (Peek.b(&arg+pos))
          If c.b>@" " Then arrayIndex.s+Chr$(c)
          pos+1
        Wend
        pos+1
        If arrayIndex
          arg=Right$(arg,FLen(arg)-pos)
        End If
        ;NPrint "Found index: ",arrayIndex
      End If
      ;NPrint "=> [",arrayIndex,"]",arg

      If var_l>=0
        If arrayIndex Then result.s = "A" : Else result.s = "V"
      End If
      If var_g>=0
        If arrayIndex Then result.s = "Z" : Else result.s = "G"
      End If

      If var_l>=0 OR var_g>=0
        If onlyexp=False
          ;Print "Patching "+typename(realtyp)
          Select realtyp
            Case #mstype_int    : realtyp = #mstype_intvar    : result.s = LCase$(result)
            Case #mstype_float  : realtyp = #mstype_floatvar  : result.s = LCase$(result)
            Case #mstype_bool   : realtyp = #mstype_boolvar   : result.s = LCase$(result)
            Case #mstype_string : realtyp = #mstype_stringvar : result.s = LCase$(result)
          End Select
          ;NPrint "... to "+typename(realtyp)
        End If
      End If

      If typ=#mstype_any Then typ = realtyp ; we got the type from the variable type!

      If var_l>=0
        If arrayIndex
          If ms_lutlocal(var_l)\arraysize=1
            msc_Error{"Variable \\22"+ms_lutlocal(var_l)\name+"\\22 is not an array!"}
          End If
          result.s + typeext.s(ms_lutlocal(var_l)\typ) + Mkl$(ms_lutlocal(var_l)\memoffset)
          result.s + msc_ParseArg{arrayIndex,#mstype_int}
        Else
          If ms_lutlocal(var_l)\arraysize>1
            msc_Error{"Variable \\22"+ms_lutlocal(var_l)\name+"["+Str$(ms_lutlocal(var_l)\arraysize)+"]\\22 is an array!"}
          End If
          result.s + typeext.s(ms_lutlocal(var_l)\typ) + Mkl$(ms_lutlocal(var_l)\memoffset)
        End If
      Else
        If var_g>=0
          ;NPrint "found global"
          If arrayIndex
            If ms_lutglobal(var_g)\arraysize=1
              msc_Error{"Global variable \\22"+ms_lutglobal(var_g)\name+"\\22 is not an array!"}
            End If
            result.s + typeext.s(ms_lutglobal(var_g)\typ) + ms_lutglobal(var_g)\name + Chr$(0)
            result.s + msc_ParseArg{arrayIndex,#mstype_any}
          Else
            If ms_lutglobal(var_g)\arraysize=0
              msc_Error{"Global variable \\22"+ms_lutglobal(var_g)\name+"[]\\22 is an array!"}
            End If
            result.s + typeext.s(ms_lutglobal(var_g)\typ) + ms_lutglobal(var_g)\name + Chr$(0)
          End If
        Else
          If realtyp<0 Then realtyp=#mstype_undefined
          If name.s=""
            msc_Error{"Argument missing of type <"+typename(typ)+">!"}
          Else
            msc_Error{"Undeclared variable \\22"+name.s+"."+typeext.s(realtyp)+"\\22 or no function \\22"+name.s+"\\22!"}
          End If
          realtyp=#mstype_undefined
        End If
      End If
    Else ; prefix operator
      result.s=""
      ; remove operator name
      arg.s = Right$(arg,FLen(arg)-pos+1)

      ; rempove brackets
      touchground.l=False
      While Left$(arg,1)="(" AND Right$(arg,1)=")" AND touchground=False
        brackets.l     = False
        quoted         = False
        For n.l=0 To (FLen(arg)-2)
          Select Peek.b(&arg+n)
            Case 34   : quoted=1-quoted
            Case @"(" : If quoted=False Then brackets+1
            Case @")" : If quoted=False Then brackets-1 : If brackets=0 Then touchground=True
          End Select
        Next
        If touchground=False Then arg=Mid$(arg,2,FLen(arg)-2)
      Wend

      ; parse args...
      n.l = 0
      pos.l = 1
      moreArgs.l = True
      realop.l = -1
      arg1typ.w = -1
      argcount.l = 0
      Dim List argL.s(0)

      While moreArgs AND \temp_failed=False
        klammercounter.w=0
        quoted.w = 0
        done.l = False
        argx.s = ""

        While pos<=FLen(arg) AND done = False
          char.b = Peek.b(&arg+pos-1) : pos+1 : addit.l = False
          Select char
            Case $22  : quoted=1-quoted ;: If klammercounter=0 AND quoted=0 Then done=True
              addit=True
            Case @"(" : If quoted=0 Then klammercounter+1
              addit=True
            Case @")" : If quoted=0 Then klammercounter-1 ;: If klammercounter=0 Then done=True
              addit=True
            Case @"," : If quoted=0 AND klammercounter=0 Then done=True : Else addit=True
            Default
              If quoted=False AND klammercounter=0
                If char<=32 AND char>=0
                  If argx><""
                    done=True
                  End If
                Else
                  addit=True
                End If
              Else
                addit=True
              End If
          End Select
          If addit Then argx+Chr$(char)
        Wend
        If klammercounter>0 Then msc_Error{"Error in expression! \\22)\\22 expected."}
        If klammercounter<0 Then msc_Error{"Error in expression! \\22(\\22 expected."}
        If quoted Then msc_Error{"String is not terminated!"}

        ;NPrint "argx:",argx
        If argx.s=""
          moreArgs=False
        Else
          If AddItem(argL())
            argL()=argx
            argcount+1
          EndIf
        End If
      Wend

      realop = msc_FindFunc{name,typ,arg1typ,argcount}
      If realop>=0
        realtyp = msfunc(realop)\typ[0]
      Else
        ResetList argL()   ; function is still ambiguous, check first argument
        If NextItem(argL())
          CNIF #msDebug=1
          NPrint "Checking next arg to resolve ambiguity..."
          CEND
          realop = msc_FindFunc{name,typ,arg1typ,argcount,False}
          onlyexp.l = True
          If realop>=0 Then If msfunc(realop)\id=#msfunc_let Then onlyexp = False
          msc_ParseArg{argL(),#mstype_any,onlyexp}
          arg1typ = msCompiler\lasttype
          CNIF #msDebug=1
          NPrint "Abiguity resolved to ",typename(arg1typ)," for first argument..."
          CEND
        End If
        realop = msc_FindFunc{name,typ,arg1typ,argcount}
        Select realop
          Case -1
            ;msc_Error{"Function "+name.s+" does not take "+Str$(argcount)+" parameters!"}
            While argcount>0 AND realop=-1
              argcount-1
              realop = msc_FindFunc{name,typ,arg1typ,argcount}
            Wend
            msc_Error{"Too many parameters for \\1b[2m"+name+"\\1b[0m - maximum is "+Str$(argcount) +"!"}
          Case -2
            msc_Error{"Unable to resolve ambiguity for function \\1b[2m"+name.s+"\\1b[0m!"}
          Default
            If realop>=0
              realtyp = msfunc(realop)\typ[0]
            Else
              msc_Error{"Internal error while parsing function \\1b[2m"+name.s+"\\1b[0m!"}
            End If
        End Select
      End If

      If realop>=0
        If typ=#mstype_any AND realtyp><#mstype_undefined Then typ=realtyp
        ;NPrint "Found function <"+typename(realtyp)+">"+msfunc(realop)\name+" that is good!"
        result.s = "F" + typeext.s(msfunc(realop)\typ[0]) + Mki$(msfunc(realop)\id)
        n.l = 0
        ResetList argL()
        While NextItem(argL()) AND \temp_failed=False
          ;NPrint "Going for agrument ",n,": ",argL()
          Select msfunc(realop)\typ[n+1]
             Case #mstype_none      : onlyexp = True
             Case #mstype_int       : onlyexp = True
             Case #mstype_bool      : onlyexp = True
             Case #mstype_float     : onlyexp = True
             Case #mstype_string    : onlyexp = True
             Case #mstype_intvar    : onlyexp = False
             Case #mstype_boolvar   : onlyexp = False
             Case #mstype_floatvar  : onlyexp = False
             Case #mstype_stringvar : onlyexp = False
             Case #mstype_any       : onlyexp = True
             Case #mstype_var       : onlyexp = False
             Default
               onlyexp = True
          End Select
          result + msc_ParseArg{argL(),msfunc(realop)\typ[n+1],onlyexp}
          n+1
        Wend

        While n<msfunc(realop)\maxargs
          Select msfunc(realop)\typ[n+1]
            Case #mstype_int    : result.s + "C"+typeext(#mstype_int    ) + Mkl$(0)
            Case #mstype_float  : f.f = 0 : result.s + "C"+typeext(#mstype_float  ) + Mkl$(Peek.l(&f.f))
            Case #mstype_bool   : result.s + "C"+typeext(#mstype_bool   ) + Chr$(0)
            Case #mstype_string : result.s + "C"+typeext(#mstype_string ) + Chr$(0)
            Case #mstype_pointer: result.s + "C"+typeext(#mstype_pointer) + Mkl$(0)
            Default
              error{"Internal error! (Overloading statement)"}
          End Select
          n+1
        Wend


        ; patch the external call
        If msfunc(realop)\id = #msfunc_extern
          retop.w = -1
          For n.l=0 To #max_msfuncs
            If msfunc(n)\id = #msfunc_getexres   Then retop=n; actually, we want the result
          Next
          If retop>=0
            ; add the hidden externcount parameter
            result.s + "C"+typeext(#mstype_int)+Mkl$(msCompiler\externcount)
            ; add the ext call to the code
            codeline.s = "/"+result.s + codeline
            ;NPrint "patching codeline to "+codeline
            ; change the argument to GetExternResult(externcount)
            result.s = "F"+typeext(msfunc(retop)\typ[0])+Mki$(msfunc(retop)\id)+"C"+typeext(#mstype_int)+Mkl$(msCompiler\externcount) : msCompiler\externcount+1
          End If
        End If
      End If

    End If
End Select


convert.s = ""
If msCompiler\syntax_softtype_level>0  ; only looseless
  If realtyp=#mstype_int     AND typ=#mstype_float  Then convert.s = "F"+typeext.s(#mstype_float )+Mki$(#msfunc_float) : msc_Warn{"Implicit type conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_float
  If realtyp=#mstype_int     AND typ=#mstype_bool   Then convert.s = "F"+typeext.s(#mstype_bool  )+Mki$(#msfunc_xtype) : msc_Warn{"Implicit type conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_bool
  If realtyp=#mstype_bool    AND typ=#mstype_int    Then convert.s = "F"+typeext.s(#mstype_int   )+Mki$(#msfunc_xtype) : msc_Warn{"Implicit type conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_int
  If realtyp=#mstype_float   AND typ=#mstype_int    Then convert.s = "F"+typeext.s(#mstype_int   )+Mki$(#msfunc_int)   : msc_Warn{"Implicit type conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_int
End If
If msCompiler\syntax_softtype_level>1  ; lossy
  If realtyp=#mstype_int     AND typ=#mstype_string Then convert.s = "F"+typeext.s(#mstype_string)+Mki$(#msfunc_str)   : msc_Warn{"Implicit type conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_string
  If realtyp=#mstype_float   AND typ=#mstype_string Then convert.s = "F"+typeext.s(#mstype_string)+Mki$(#msfunc_str)   : msc_Warn{"Implicit type conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_string
  If realtyp=#mstype_bool    AND typ=#mstype_string Then convert.s = "F"+typeext.s(#mstype_string)+Mki$(#msfunc_xtype) : msc_Warn{"Implicit type conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_string
End If
If msCompiler\syntax_softtype_level>2  ; crazy
  If realtyp=#mstype_float   AND typ=#mstype_bool   Then convert.s = "F"+typeext.s(#mstype_bool  )+Mki$(#msfunc_xtype) : msc_Warn{"Implicit type conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_bool
  If realtyp=#mstype_bool    AND typ=#mstype_float  Then convert.s = "F"+typeext.s(#mstype_float )+Mki$(#msfunc_xtype) : msc_Warn{"Implicit type conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_float
  If realtyp=#mstype_string  AND typ=#mstype_int    Then convert.s = "F"+typeext.s(#mstype_int   )+Mki$(#msfunc_val)   : msc_Warn{"Implicit type conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_int
  If realtyp=#mstype_string  AND typ=#mstype_float  Then convert.s = "F"+typeext.s(#mstype_float )+Mki$(#msfunc_val)   : msc_Warn{"Implicit type conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_float
  If realtyp=#mstype_string  AND typ=#mstype_bool   Then convert.s = "F"+typeext.s(#mstype_bool  )+Mki$(#msfunc_xtype) : msc_Warn{"Implicit type conversion <"+typename.s(realtyp)+"> to <"+typename.s(typ)+">!"}  : realtyp = #mstype_bool
End If
result.s = convert+result


If realtyp><typ
  Select typ
    Case #mstype_none
      msc_Warn{"Return value is not used!"}
    Case #mstype_var
      msc_Error{"Can't assign expression \\22"+oarg+"\\22 - expected a variable!"}
    Default
      Select realtyp
        Case #mstype_undefined : msc_Error{"Unable to estimate the type of argument!"}
        Case #mstype_none      : msc_Error{"Function has no return value!"}
        Default
          msc_Error{"Type mismatch! Got \\22"+oarg+"\\22 of type <"+typename.s(realtyp)+"> but <"+typename.s(typ)+"> expected."}
      End Select
  End Select
End If
msCompiler\lasttype = realtyp

Function Return result.s
End Function


Function.s msc_Parse{sptr.l,blength.l}
SHARED ms_lutglobal(),ms_lutlocal(),ms_lutlabel(),typeext.s(),ms_ifbrain(),msfunc(),ms_lutmacro(),typename(),blockend(),blockname(),codeline.s
quoted.l  = False
dptr.l    = AllocMem(blength,#MEMF_CLEAR)
dbase.l   = dptr
todo.l    = blength
dlength.l = blength
While todo>0
  c.b = Peek.b(sptr)  : succ.l = False

  If c=34 Then quoted = 1-quoted
  If c=10 Then quoted = False
  If c=@";" Then quoted = True

  If quoted=False
    If c=@"#"
      n.l = 0
      name.s = ""
      While c=@"_" OR c=@"#" OR (c>=@"a" AND c<=@"z") OR (c>=@"A" AND c<=@"Z") OR (c>=@"0" AND c<=@"9") AND n<todo
        name.s + Chr$(c)
        n+1
        c = Peek.b(sptr+n)
      Wend
      sptr + n
      todo - n
      name.s = LCase$(name.s)
      For const.l = 0 To msCompiler\numMacros-1
        If name.s = ms_lutmacro(const)\name
          z.l = AllocMem_(dlength+FLen(ms_lutmacro(const)\replacement) - FLen(ms_lutmacro(const)\name),#MEMF_CLEAR )
          CopyMem_ dbase,z,dptr-dbase
          CopyMem_ &ms_lutmacro(const)\replacement,z+dptr-dbase,FLen(ms_lutmacro(const)\replacement)
          FreeMem_ dbase,dlength
          dptr    = dptr-dbase+z + FLen(ms_lutmacro(const)\replacement)
          dbase   = z
          dlength = dlength + FLen(ms_lutmacro(const)\replacement) - FLen(ms_lutmacro(const)\name)
          succ    = True
          const   = msCompiler\numMacros+1
        End If
      Next
      If succ=False Then c.b=Asc("0"):msc_Error{"Undefined macro \\1b[2m"+name.s+"\\1b[0m!"} :sptr-1:todo+1
    End If
  End If

  If succ=False Then Poke.b dptr,c : dptr+1 : sptr+1 : todo-1
Wend


msCompiler\temp_script_length = dlength
msCompiler\temp_script_seek   = 0
msCompiler\temp_script_base   = dbase
msCompiler\temp_line          = 1
msCompiler\temp_errcount      = 0
msCompiler\temp_warncount     = 0
ifdeep.l = -1
ifid.l = 0
bin.s = ""
biniff.l = 0
;xlog{Peek.s(dbase)}

o_stat.s = msc_CropToken{}
stat.s = LCase$(o_stat.s)
args.s  = msc_CropArgs{}
While stat.s><"" AND \temp_failed = False
  binoff.l = FLen(bin)
  codeline.s = ""
  msCompiler\externcount=0
  If stat.s = "global" Then stat.s="var":globalmode.l=True:Else globalmode=False

  If stat="}"
    If ifdeep>=0
      Select ms_ifbrain(ifdeep)\typ
        Case #msblocktype_if
          stat="endif"

        Case #msblocktype_while
          stat="wend"

        Case #msblocktype_for
          stat="next"

        Case #msblocktype_repeat
          stat="until"

        Default
          msc_Error{"\\22}\\22 can not close \\1b[2m"+blockend(ms_ifbrain(ifdeep)\typ)+"\\1b[0m block!"}
      End Select
    Else
      msc_Error{"\\22}\\22 without \\22{\\22!"}
    End If
    o_stat=stat
  End If

  Select stat.s
    Case "var"
      typ.w = #mstype_undefined
      pos.l = 0
      While pos<FLen(args)
        name.s       = ""
        arraysizeS.s = ""
        arraysize.l  = 1
        While Peek.b(&args+pos)><0 AND Peek.b(&args+pos)><@"," AND Peek.b(&args+pos)><@" " AND Peek.b(&args+pos)><@"["
          c.b = (Peek.b(&args+pos))
          If c.b>32 Then name+Chr$(c)
          pos+1
        Wend
        If Peek.b(&args+pos)=@"["
          pos+1
          While Peek.b(&args+pos)><0 AND Peek.b(&args+pos)><@"]"
            c.b = (Peek.b(&args+pos))
            If c.b>@" " Then arraysizeS.s+Chr$(c)
            pos+1
          Wend
          pos+1

          If globalmode
            If arraysizeS
              msc_Warn{"Global arrays are dynmaic, use myArray[] for declaration!"}
              arraysize = 0
            Else
              arraysize = 0
            End If
          Else
            If arraysizeS
              arraysize = Vallong(arraysizeS)
              If arraysize<=0
                msc_Error{"Size of array must be an integer constant >0!"}
              End If
            Else
              msc_Error{"Invalid array declaration!"}
            End If
          End If
        Else
          pos+1
        End If
        typex.s = dos_GetExt{name.s}
        Select LCase$(typex)
          Case typeext(#mstype_int)     : typ=#mstype_int
          Case typeext(#mstype_float)   : typ=#mstype_float
          Case typeext(#mstype_bool)    : typ=#mstype_bool
          Case typeext(#mstype_string)  : typ=#mstype_string
          Case typeext(#mstype_pointer) : typ=#mstype_pointer
          Case "" : typ=typ
          Default
            msc_Error{"Unknown type "+typex+" in "+name}
        End Select
        varname.s = dos_RemExt{name}
        If varname.s><"" AND typ><#mstype_undefined
          If globalmode
            var.l = msc_DeclareGlobal{varname.s,typ,arraysize}
          Else
            var.l = msc_DeclareLocal{varname.s,typ,arraysize}
          End If
        Else
          If varname><""
            msc_Error{"Type of variable is missing (.l, .f, .b, .p or .s)!"}
          End If
        End If
      Wend

    Case "goto"
      lutlabel.l = msc_FindLabel{args.s}
      codeline.s+"/B\_"+Mki$(lutlabel)+"Cb"+Chr$(0)

    Case "if"
      ifdeep+1
      If ifdeep>=#MAX_MSIFS
        msc_Error{"Too complex \\1b[2mIf/While/Select\\1b[0m expression! (wow!)"}
      Else
        ms_ifbrain(ifdeep)\ifid = ifid
        ms_ifbrain(ifdeep)\typ = #msblocktype_if ; fuer IF
        lutlabel.l = msc_FindLabel{"_elselabel_"+Str$(ifid)}
        a.s = msc_ParseArg{args.s,#mstype_bool}
        codeline.s+"/B\_"+Mki$(lutlabel)
        codeline + a.s
        ms_ifbrain(ifdeep)\special = False
      End If
      ifid.l + 1

    Case "else"
      If ifdeep>=0
        If ms_ifbrain(ifdeep)\typ = #msblocktype_if
          lutlabel.l = msc_FindLabel{"_endiflabel_"+Str$(ms_ifbrain(ifdeep)\ifid)}
          codeline.s+"/B\_"+Mki$(lutlabel)+"Cb"+Chr$(0)
          msc_DefineLabel{"_elselabel_"+Str$(ms_ifbrain(ifdeep)\ifid),FLen(codeline.s)+binoff}
          ms_ifbrain(ifdeep)\special = True
        Else
          ;msc_Error{"Got \\1b[2mElse\\1b[0m but "+blockend(ms_ifbrain(ifdeep)\typ)+" expected!"}
          msc_Error{"\\1b[2mElse\\1b[0m without \\1b[2mIf\\1b[0m!"}
        End If
      Else
        msc_Error{"\\1b[2mElse\\1b[0m without \\1b[2mIf\\1b[0m!"}
      End If

    Case "endif"
      If ifdeep>=0
        If ms_ifbrain(ifdeep)\typ = #msblocktype_if
          If ms_ifbrain(ifdeep)\special = True
            msc_DefineLabel{"_endiflabel_"+Str$(ms_ifbrain(ifdeep)\ifid),FLen(codeline.s)+binoff}
          Else
            msc_DefineLabel{"_elselabel_"+Str$(ms_ifbrain(ifdeep)\ifid),FLen(codeline.s)+binoff }
          End If
          ifdeep-1
        Else
          ;msc_Error{"\\1b[2mEndIf\\1b[0m: Illegal nested condtition!"}
          msc_Error{"Got \\1b[2mEndIf\\1b[0m but \\1b[2m"+blockend(ms_ifbrain(ifdeep)\typ)+"\\1b[0m expected!"}
        End If
      Else
        msc_Error{"\\1b[2mEndIf\\1b[0m without \\1b[2mIf\\1b[0m!"}
      End If

    Case "for"
      ifdeep+1
      If ifdeep>=#MAX_MSIFS
        msc_Error{"Too complex \\1b[2mIf/While/Select\\1b[0m expression!"}
      Else
        ms_ifbrain(ifdeep)\ifid = ifid
        ms_ifbrain(ifdeep)\typ  = #msblocktype_for ; fuer FOR
        lutlabel.l = msc_FindLabel{"_forlabel_"+Str$(ifid)}
        msc_DefineLabel{"_forlabel_"+Str$(ms_ifbrain(ifdeep)\ifid),FLen(codeline.s)+binoff}
        a.s = msc_ParseArg{args.s,#mstype_bool}
        codeline.s+"/B\_"+Mki$(lutlabel) + a.s
        ms_ifbrain(ifdeep)\special = False
      End If
      ifid.l + 1

    Case "next"
      If ifdeep>=0
        If ms_ifbrain(ifdeep)\typ = #msblocktype_for
          lutlabel.l = msc_FindLabel{"_forlabel_"+Str$(ms_ifbrain(ifdeep)\ifid)}
          codeline.s+"/B\_"+Mki$(lutlabel)+"Cb"+Chr$(0)
          msc_DefineLabel{"_nextlabel_"+Str$(ms_ifbrain(ifdeep)\ifid),FLen(codeline.s)+binoff }
          ifdeep-1
        Else
          msc_Error{"Got \\1b[2mNext\\1b[0m but \\1b[2m"+blockend(ms_ifbrain(ifdeep)\typ)+"\\1b[0m expected!"}
        End If
      Else
        msc_Error{"\\1b[2mWend\\1b[0m without \\1b[2mWhile\\1b[0m!"}
      End If

    Case "repeat"
      ifdeep+1
      If ifdeep>=#MAX_MSIFS
        msc_Error{"Too complex \\1b[2mIf/While/Select\\1b[0m expression!"}
      Else
        ms_ifbrain(ifdeep)\ifid = ifid
        ms_ifbrain(ifdeep)\typ = #msblocktype_repeat ; fuer REPEAT
        msc_DefineLabel{"_repeatlabel_"+Str$(ms_ifbrain(ifdeep)\ifid),FLen(codeline.s)+binoff }
        ms_ifbrain(ifdeep)\special = False
      End If
      ifid.l + 1

    Case "until"
      If ifdeep>=0
        If ms_ifbrain(ifdeep)\typ = #msblocktype_repeat
          lutlabel.l = msc_FindLabel{"_repeatlabel_"+Str$(ms_ifbrain(ifdeep)\ifid)}
          a.s = msc_ParseArg{args.s,#mstype_bool}
          codeline.s+"/B\_"+Mki$(lutlabel) + a.s
          ifdeep-1
        Else
          msc_Error{"Got \\1b[2mUntil\\1b[0m but \\1b[2m"+blockend(ms_ifbrain(ifdeep)\typ)+"\\1b[0m expected!"}
        End If
      Else
        msc_Error{"\\1b[2mUntil\\1b[0m without \\1b[2mRepeat\\1b[0m!"}
      End If

    Case "while"
      ifdeep+1
      If ifdeep>=#MAX_MSIFS
        msc_Error{"Too complex \\1b[2mIf/While/Select\\1b[0m expression!"}
      Else
        ms_ifbrain(ifdeep)\ifid = ifid
        ms_ifbrain(ifdeep)\typ = #msblocktype_while ; fuer WHILE
        lutlabel.l = msc_FindLabel{"_wendlabel_"+Str$(ifid)}
        msc_DefineLabel{"_whilelabel_"+Str$(ms_ifbrain(ifdeep)\ifid),FLen(codeline.s)+binoff }
        a.s = msc_ParseArg{args.s,#mstype_bool}
        codeline.s+"/B\_"+Mki$(lutlabel) + a.s
        ms_ifbrain(ifdeep)\special = False
      End If
      ifid.l + 1

    Case "wend"
      If ifdeep>=0
        If ms_ifbrain(ifdeep)\typ = #msblocktype_while
          lutlabel.l = msc_FindLabel{"_whilelabel_"+Str$(ms_ifbrain(ifdeep)\ifid)}
          codeline.s+"/B\_"+Mki$(lutlabel)+"Cb"+Chr$(0)
          msc_DefineLabel{"_wendlabel_"+Str$(ms_ifbrain(ifdeep)\ifid),FLen(codeline.s)+binoff }
          ifdeep-1
        Else
          ;msc_Error{"\\1b[2mWend\\1b[0m: Illegal nested condition!"}
          msc_Error{"Got \\1b[2mWend\\1b[0m but \\1b[2m"+blockend(ms_ifbrain(ifdeep)\typ)+"\\1b[0m expected!"}
        End If
      Else
        msc_Error{"\\1b[2mWend\\1b[0m without \\1b[2mWhile\\1b[0m!"}
      End If

    Case "select"
      ifdeep+1
      If ifdeep>=#MAX_MSIFS
        msc_Error{"Too complex \\1b[2mIf/While/Select\\1b[0m expression!"}
      Else
        ms_ifbrain(ifdeep)\ifid   = ifid
        ms_ifbrain(ifdeep)\typ    = #msblocktype_select ; fuer SELECT
        selectarg.s               = msc_ParseArg{args.s,#mstype_any}
        ms_ifbrain(ifdeep)\argtyp = msCompiler\lasttype
        selectvar.s = "_select_"+typeext(ms_ifbrain(ifdeep)\argtyp)+"_"+Str$(ifdeep)
        var.l = msc_FindLocal{selectvar}
        If var<0 Then var.l = msc_DeclareLocal{selectvar,ms_ifbrain(ifdeep)\argtyp,1}
        If var>=0
          If ms_lutlocal(var)\typ=ms_ifbrain(ifdeep)\argtyp
            codeline.s +"/V"+typeext.s(ms_lutlocal(var)\typ)+Mkl$(ms_lutlocal(var)\memoffset)
            codeline.s + selectarg
          Else
            msc_Error{"INTERNAL ERROR: \\1b[2Select\\1b[0 variable has wrong type!"}
          End If
        Else
          error{"Internal error! - (can`t find var in \\1b[2mSelect\\1b[0m)"}
        End If
        ms_ifbrain(ifdeep)\special = 0

      End If
      ifid.l + 1

    Case "case"
      If ifdeep>=0
        If ms_ifbrain(ifdeep)\typ = #msblocktype_select
          If ms_ifbrain(ifdeep)\special >0
            lutlabel.l = msc_FindLabel{"_endselectlabel_"+Str$(ms_ifbrain(ifdeep)\ifid)}
            codeline.s + "/B\_"+Mki$(lutlabel)+"Cb"+Chr$(0)
            msc_DefineLabel{"_caselabel_"+Str$(ms_ifbrain(ifdeep)\ifid)+"_"+Str$(ms_ifbrain(ifdeep)\special),FLen(codeline.s)+binoff }
          End If

          ms_ifbrain(ifdeep)\special + 1
          lutlabel.l = msc_FindLabel{"_caselabel_"+Str$(ms_ifbrain(ifdeep)\ifid)+"_"+Str$(ms_ifbrain(ifdeep)\special)}
          op.w = msc_FindFunc{"=",#mstype_bool}

          If op>=0
            codeline.s+"/B\_"+Mki$(lutlabel)+"Fb"+Mki$(msfunc(op)\id)
            selectvar.s = "_select_"+typeext(ms_ifbrain(ifdeep)\argtyp)+"_"+Str$(ifdeep)
            var.l = msc_FindLocal{selectvar}
            If var>=0
              a.s = msc_ParseArg{args.s,ms_ifbrain(ifdeep)\argtyp}
              codeline.s+"V"+typeext.s(ms_lutlocal(var)\typ)+Mkl$(ms_lutlocal(var)\memoffset) + a.s
            Else
              error{"Internal error! (can`t find variable: "+selectvar+" )"}
            End If
          Else
            error{"Internal error! (can`t find operator \\22=\\22)"}
          End If
        Else
          msc_Error{"\\1b[2mCase\\1b[0m without \\1b[2mSelect\\1b[0m!"}
          ;msc_Error{"\\1b[2mCase\\1b[0m: Illegal nested condition!"}
        End If
      Else
        msc_Error{"\\1b[2mCase\\1b[0m without \\1b[2mSelect\\1b[0m!"}
      End If

    Case "default"
      If ifdeep>=0
        If ms_ifbrain(ifdeep)\typ = #msblocktype_select
          If ms_ifbrain(ifdeep)\special >0
            lutlabel.l = msc_FindLabel{"_endselectlabel_"+Str$(ms_ifbrain(ifdeep)\ifid)}
            codeline.s + "/B\_"+Mki$(lutlabel)+"Cb"+Chr$(0)
            msc_DefineLabel{"_caselabel_"+Str$(ms_ifbrain(ifdeep)\ifid)+"_"+Str$(ms_ifbrain(ifdeep)\special),FLen(codeline.s)+binoff }
          End If
          ms_ifbrain(ifdeep)\special + 1
        Else
          ;msc_Error{"\\1b[2mDefault\\1b[0m: Illegal nested condition!"}
          msc_Error{"\\1b[2mDefault\\1b[0m without \\1b[2mSelect\\1b[0m!"}
        End If
      Else
        msc_Error{"\\1b[2mDefault\\1b[0m without \\1b[2mSelect\\1b[0m!"}
      End If

    Case "endselect"
      If ifdeep>=0
        If ms_ifbrain(ifdeep)\typ = #msblocktype_select
          msc_DefineLabel{"_caselabel_"+Str$(ms_ifbrain(ifdeep)\ifid)+"_"+Str$(ms_ifbrain(ifdeep)\special),FLen(codeline.s)+binoff }
          msc_DefineLabel{"_endselectlabel_"+Str$(ms_ifbrain(ifdeep)\ifid),FLen(codeline.s)+binoff }
          ifdeep-1
        Else
          ;msc_Error{"\\1b[2mEndSelect\\1b[0m: Illegal nested condition!"}
          msc_Error{"Got \\1b[2mEndSelect\\1b[0m but \\1b[2m"+blockend(ms_ifbrain(ifdeep)\typ)+"\\1b[0m expected!"}
        End If
      Else
        msc_Error{"\\1b[2mEndSelect\\1b[0m without \\1b[2mSelect\\1b[0m!"}
      End If

    Default
      If Left$(stat.s,1)="."   ; Label
        If args.s Then msc_Warn{"Garbage after Label!"}
        msc_DefineLabel{stat.s,FLen(codeline.s)+binoff }
      Else
        If Left$(stat.s,1)="@" ; direct call umpatchen
          stat.s = Right$(Replace$(o_stat.s,".","/"),FLen(stat.s)-1)
          If dos_Exist{stat.s+".msc"} = False Then msc_Warn{"Non-existing script \\22"+stat.s+"\\22 referred!"}
          args.s = Chr$(34)+stat.s+Chr$(34)+",True,"+args.s:stat.s = "CALL"
        End If

        comtyp.w = #mstype_none
        com.w    = msc_FindFunc{stat.s,#mstype_none}
        comf.w   = msc_FindFunc{stat.s,#mstype_any}
        If com=-1 AND comf><-1
          com=comf
          msc_Warn{"Return value of \\1b[2m"+msfunc(com)\name+"\\1b[0m  will be ignored."}
          comtyp = #mstype_any
        End If

        codeline.s + "/"
        If args.s><"" AND com><-1 Then args = "("+args+")"
        ;If args.s><"" AND com><-1 AND Peek.b(&arg.s)><@"(" Then args = " "+args
        ;xa.s = o_stat+args
        a.s = msc_ParseArg{o_stat+args,comtyp}
        codeline.s + a.s

      End If
  End Select
  bin.s + codeline.s
  o_stat.s  = msc_CropToken{}
  stat.s = LCase$(o_stat.s)
  args.s  = msc_CropArgs{}
Wend


bin.s + "/F?"+Mki$(#msfunc_exit)+"Cs"+Chr$(0) ; EXIT

quoted.l = False
pos.l = 1
While pos<=FLen(bin.s)       ; Second pass
  If Mid$(bin.s,pos,4)="/B\_"; AND quoted = False
    pos+1
    lutlabel.l = Peek.w(&bin.s+pos+2)
    If lutlabel>=#MAX_MSLABELS
      error{"INTERNAL: Too many labels declaredl!"}
    Else
      Poke.l &bin.s+pos,ms_lutlabel(lutlabel)\offset
      If ms_lutlabel(lutlabel)\offset < 0 Then msc_Error{"Label \\22"+ms_lutlabel(lutlabel)\name+"\\22 was not defined!"}
    End If
  End If
  pos+1
Wend

If ifdeep>=0
  msc_Error{"\\1b[2m"+blockname(ms_ifbrain(ifdeep)\typ)+"\\1b[0m block not closed!"}
End If

Function Return bin.s
End Function


Function.l msc_CompileFile{sourcefile.s,@binfile.s}
\temp_script_length = 0
\temp_script_seek   = 0
\temp_script_base   = 0
\temp_line          = 0
\temp_failed        = False
\temp_errorline     = -1
\temp_error         = "not compiled!"

\numLocals      = 0
\numLabels      = 0

\numLocals_l    = 0
\numLocals_f    = 0
\numLocals_b    = 0
\numLocals_s    = 0
\numLocals_p    = 0

succ.l = False
dummy.l = msc_DeclareLocal{"argv",#mstype_string,1}

msc_Info{"Compiling "+dos_FilePart{sourcefile}+"..."}
dos.l = file_Open{sourcefile,#file_read}

If dos>=0
  ascii_length.l = file_GetLength{dos}
  ascii_ptr.l    = AllocVec_ (ascii_length+128,0)
  If ascii_ptr
    succ.l = file_ReadMem{dos,ascii_ptr,ascii_length}
    If succ
      bin.s = msc_Parse{ascii_ptr,ascii_length}
      succ.l = False
      msc_Info{Str$(msCompiler\temp_errcount)+" error(s) and "+Str$(msCompiler\temp_warncount)+" warning(s) occured.",1}

      If \temp_failed
        ;error{"Script parsing failed!"}
      Else
        msc_Info{"Compiled successfully!"}

        DEFTYPE.msBinary header
        header\MSVB        = @"MSVB"
        header\csizeMSVB   = SizeOf.msBinary-8  + FLen(bin) +8+8
        header\INFO        = @"INFO"
        header\csizeINFO   = SizeOf.msBinary-8-8
        header\numLocals_l = msCompiler\numLocals_l
        header\numLocals_f = msCompiler\numLocals_f
        header\numLocals_b = msCompiler\numLocals_b
        header\numLocals_s = msCompiler\numLocals_s
        header\numLocals_p = msCompiler\numLocals_p
        header\CODE        = @"CODE"
        header\csizeCODE   = FLen(bin)

        imageSize.l    =  header\csizeMSVB + 8
        *binP.msBinary = AllocVec_ (imageSize,#MEMF_ANY)
        If *binP
          CopyMem_ header,*binP,SizeOf.msBinary
          CopyMem_ &bin,*binP+SizeOf.msBinary,FLen(bin)
          msc_Info{"Created virtual binary."}
          \temp_error ="compiled successfully!"
          ;If binfile="" Then binfile.s = dos_SetExt{sourcefile,"msb"}
          If binfile
            dos2.l = file_Open{binfile,#file_forcewrite}
            If dos2>=0
              If file_WriteMem{dos2,*binP,imageSize}
                file_Close{dos2}
                msc_Info{"Binary saved as \\22"+binfile+"\\22!"}
              Else
                file_Erase{dos2}
                msc_Info{"Error while writing binary file as \\22"+binfile+"\\22!"}
              End If
            End If
          End If
        End If
      End If
    Else
      msc_Error{"Unable to read script!"}
    End If
    FreeVec_ ascii_ptr
  Else
    msc_Error{"Not enough memory!"}
  End If
  file_Close{dos}
End If

If succ = False

End If
Function Return *binP
End Function

; output_depth = 0(quiet), 1(errors) 2(+warnings) 3(+infos)
Statement msc_Configure{output_depth.l,strict.l,autodeclare.l}
\output_depth          = output_depth
\syntax_softtype_level = strict
\syntax_autodefine     = autodeclare
End Statement



