; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "DH18:"
; ExeFile         = "LowLevelDemo"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 204
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 7
; CursorColumn    = 9
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 20
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 20
; Max ChunkyBuffer= 2
; /XTRA
; lowlevel.include.bb2 generated by FD2Include (Thilo Koehler)
; fixed and changed/expand functionality of lowlevel_Querykey{} at 2009.11.24 tomsmart1



CNIF #__include=0
  OPTIMIZE 7
  SYNTAX 2
  WBStartup
CEND

XINCLUDE "error.include.ab3"

; Library offsets:
#_LVO_LOWLEVELBASE_ReadJoyPort          = -30
#_LVO_LOWLEVELBASE_GetLanguageSelection = -36
#_LVO_LOWLEVELBASE_lowlevelPrivate1     = -42
#_LVO_LOWLEVELBASE_GetKey               = -48
#_LVO_LOWLEVELBASE_QueryKeys            = -54
#_LVO_LOWLEVELBASE_AddKBInt             = -60
#_LVO_LOWLEVELBASE_RemKBInt             = -66
#_LVO_LOWLEVELBASE_SystemControlA       = -72
#_LVO_LOWLEVELBASE_AddTimerInt          = -78
#_LVO_LOWLEVELBASE_RemTimerInt          = -84
#_LVO_LOWLEVELBASE_StopTimerInt         = -90
#_LVO_LOWLEVELBASE_StartTimerInt        = -96
#_LVO_LOWLEVELBASE_ElapsedTime          = -102
#_LVO_LOWLEVELBASE_AddVBlankInt         = -108
#_LVO_LOWLEVELBASE_RemVBlankInt         = -114
#_LVO_LOWLEVELBASE_lowlevelPrivate2     = -120
#_LVO_LOWLEVELBASE_lowlevelPrivate3     = -126
#_LVO_LOWLEVELBASE_SetJoyPortAttrsA     = -132
#_LVO_LOWLEVELBASE_lowlevelPrivate4     = -138
#_LVO_LOWLEVELBASE_lowlevelPrivate5     = -144
#_LVO_LOWLEVELBASE_lowlevelPrivate6     = -150
#_LVO_LOWLEVELBASE_lowlevelPrivate7     = -156
#_LVO_LOWLEVELBASE_lowlevelPrivate8     = -162

; Constants for LanguageSelection()
#LANG_UNKNOWN    = 0
#LANG_AMERICAN   = 1 ;/* American English */
#LANG_ENGLISH    = 2 ;/* British English  */
#LANG_GERMAN     = 3
#LANG_FRENCH     = 4
#LANG_SPANISH    = 5
#LANG_ITALIAN    = 6
#LANG_PORTUGUESE = 7
#LANG_DANISH     = 8
#LANG_DUTCH      = 9
#LANG_NORWEGIAN  = 10
#LANG_FINNISH    = 11
#LANG_SWEDISH    = 12
#LANG_JAPANESE   = 13
#LANG_CHINESE    = 14
#LANG_ARABIC     = 15
#LANG_GREEK      = 16
#LANG_HEBREW     = 17
#LANG_KOREAN     = 18

; Constants for GetKey()
#LLKB_LSHIFT   = 16
#LLKB_RSHIFT   = 17
#LLKB_CAPSLOCK = 18
#LLKB_CONTROL  = 19
#LLKB_LALT     = 20
#LLKB_RALT     = 21
#LLKB_LAMIGA   = 22
#LLKB_RAMIGA   = 23

; Tags for SetJoyPortAttrs()
#SJA_Dummy        = $c00100
#SJA_Type         = #SJA_Dummy+1 ; force type to mouse, joy, game cntrlr
#SJA_Reinitialize = #SJA_Dummy+2 ; free PotGo bits, RESET To autosense

; Controller types for SJA_Type tag
#SJA_TYPE_AUTOSENSE = 0
#SJA_TYPE_GAMECTLR  = 1
#SJA_TYPE_MOUSE     = 2
#SJA_TYPE_JOYSTK    = 3

;/* structure for use with QueryKeys() */
;NEWTYPE .KeyQuery                        ;structure is defined in all.res
;  kp_KeyCode.w
;  kp_Pressed.w
;End NEWTYPE

;Dim lowlevel_RawKeyStatus.KeyQuery(256) ; a QueryArray with max size


SHARED *_LowLevelBase.Library



; Wrapper Macros:

Macro __LowLevelBase_SaveRegs
  MOVE.l a5,-(a7) :  MOVE.l a6,-(a7) :  MOVE.l d7,-(a7)
End Macro

Macro __LowLevelBase_RestoreRegs
  MOVE.l (a7)+,d7 : MOVE.l (a7)+,a6 : MOVE.l (a7)+,a5
End Macro


Macro lowlevel_ReadJoyPort ; {ret.l,port}
  !__LowLevelBase_SaveRegs
  GetReg d0,`2
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_ReadJoyPort(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_GetLanguageSelection ; {ret.l}
  !__LowLevelBase_SaveRegs
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_GetLanguageSelection(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevelPrivate1 ; {ret.l}
  !__LowLevelBase_SaveRegs
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_lowlevelPrivate1(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_GetKey ; {ret.l}
  !__LowLevelBase_SaveRegs
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_GetKey(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_QueryKeys ; {queryArray,arraySize}
  !__LowLevelBase_SaveRegs
  GetReg a0,`1
  GetReg d1,`2
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_QueryKeys(a6)
  !__LowLevelBase_RestoreRegs
End Macro

Macro lowlevel_AddKBInt ; {ret.l,intRoutine,intData}
  !__LowLevelBase_SaveRegs
  GetReg a0,`2
  GetReg a1,`3
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_AddKBInt(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_RemKBInt ; {ret.l,intHandle}
  GetReg a1,`2
  !__LowLevelBase_SaveRegs
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_RemKBInt(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_SystemControlA ; {ret.l,tagList}
  !__LowLevelBase_SaveRegs
  GetReg a1,`2
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_SystemControlA(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_AddTimerInt ; {ret.l,intRoutine,intData}
  !__LowLevelBase_SaveRegs
  GetReg a0,`2
  GetReg a1,`3
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_AddTimerInt(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_RemTimerInt ; {ret.l,intHandle}
  !__LowLevelBase_SaveRegs
  GetReg a1,`2
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_RemTimerInt(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_StopTimerInt ; {ret.l,intHandle}
  GetReg a1,`2
  !__LowLevelBase_SaveRegs
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_StopTimerInt(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_StartTimerInt ; {ret.l,intHandle,timeInterval,continuous}
  !__LowLevelBase_SaveRegs
  GetReg a1,`2
  GetReg d0,`3
  GetReg d1,`4
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_StartTimerInt(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_ElapsedTime ; {ret.l,context}
  !__LowLevelBase_SaveRegs
  GetReg a0,`2
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_ElapsedTime(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_AddVBlankInt ; {ret.l,intRoutine,intData}
  !__LowLevelBase_SaveRegs
  GetReg a0,`2
  GetReg a1,`3
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_AddVBlankInt(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_RemVBlankInt ; {ret.l,intHandle}
  !__LowLevelBase_SaveRegs
  GetReg a1,`2
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_RemVBlankInt(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevelPrivate2 ; {ret.l}
  !__LowLevelBase_SaveRegs
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_lowlevelPrivate2(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevelPrivate3 ; {ret.l}
  !__LowLevelBase_SaveRegs
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_lowlevelPrivate3(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevel_SetJoyPortAttrsA ; {ret.l,portNumber,tagList}
  !__LowLevelBase_SaveRegs
  GetReg d0,`2
  GetReg a1,`3
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_SetJoyPortAttrsA(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevelPrivate4 ; {ret.l}
  !__LowLevelBase_SaveRegs
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_lowlevelPrivate4(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevelPrivate5 ; {ret.l}
  !__LowLevelBase_SaveRegs
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_lowlevelPrivate5(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevelPrivate6 ; {ret.l}
  !__LowLevelBase_SaveRegs
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_lowlevelPrivate6(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevelPrivate7 ; {ret.l}
  !__LowLevelBase_SaveRegs
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_lowlevelPrivate7(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro

Macro lowlevelPrivate8 ; {ret.l}
  !__LowLevelBase_SaveRegs
  GetReg a6,*_LowLevelBase
  JSR _LVO_LOWLEVELBASE_lowlevelPrivate8(a6)
  !__LowLevelBase_RestoreRegs
  `1 = PutRegD0
End Macro


; *****************************************************************************
; * lowlevel_InitLib {}                                                       *
; *                                                                           *
; * returns the the Librarybase its succesful else 0.                         *
; *                                                                           *
; * Syntax: LibraryBase.l = lowlevel_InitLib {@minVersion.l}                  *             *
; *                                                                           *
; *****************************************************************************
Function.l lowlevel_InitLib{@minVersion.l}
If *_LowLevelBase Then Function Return *_LowLevelBase
If minVersion<0 Then minVersion = 0
*_LowLevelBase = OpenLibrary_ ("lowlevel.library",minVersion)
If *_LowLevelBase
  ; ** Do some other init stuff here...
Else
  error {"Unable to open lowlevel.library (v"+Str$(minVersion)+".0+)!"}
End If
Function Return *_LowLevelBase
End Function

; *****************************************************************************
; * lowlevel_FreeLib {}                                                       *
; *                                                                           *
; * Syntax: lowlevel_FreeLib {}                                               *
; *                                                                           *
; *****************************************************************************
Statement lowlevel_FreeLib{}
If *_LowLevelBase
  ; ** Do some freeing stuff here that you inited in _LowLevelBase_Init{}...
  CloseLibrary_ *_LowLevelBase : *_LowLevelBase = 0
End If
End Statement
!autoexit {lowlevel_FreeLib}

; *****************************************************************************
; * lowlevel_ReadJoyPort {portnumber.l}                                       *
; *                                                                           *
; * returns the state of the selected joystick/joypad/mouse on the given port *
; *                                                                           *
; * Syntax: portState = lowlevel_ReadJoyPort(portnumber.l)                    *
; *                                                                           *
; *****************************************************************************
Function.l lowlevel_ReadJoyPort{portnumber.l}
  If *_LowLevelBase=0 Then Function Return #JP_TYPE_NOTAVAIL
  !lowlevel_ReadJoyPort {state.l,portnumber}
  Function Return state
End Function


; *****************************************************************************
; * lowlevel_GetKey {}                                                        *
; *                                                                           *
; * returns the currently pressed rawkeycode and qualifiers.                  *
; *                                                                           *
; * Syntax: keypresscode.l = lowlevel_GetKey {}                               *
; *                                                                           *
; * This function is save for use within an interrupt !                       *
; *                                                                           *
; *****************************************************************************
Function.l lowlevel_GetKey{}
  If *_LowLevelBase=0 Then Function Return 0
  !lowlevel_GetKey {keypresscode.l}
  Function Return keypresscode
End Function

; *****************************************************************************
; * lowlevel_GetLanguageSelection {}                                          *
; *                                                                           *
; * returns the current language selection from the User                      *
; *                                                                           *
; * Syntax: language = lowlevel_GetLanguageSelection {}                       *
; *                                                                           *
; *****************************************************************************
Function.l lowlevel_GetLanguageSelection{}
  If *_LowLevelBase=0 Then Function Return #LANG_UNKNOWN
  !lowlevel_GetLanguageSelection {language.l}
  Function Return language
End Function

; *****************************************************************************
; * lowlevel_QueryKey {queryarrayaddress.l,arraysize.b}                       *
; *                                                                           *
; * Scans the keyboard to determine which of the rawkey codes listed in the   *
; * QueryArray are currently pressed. The state for each key is returned in   *
; * the array. True for pressed , False for unpressed.                        *
; *                                                                           *
; * Syntax: lowlevel_QueryKey {queryarrayaddress.l,arraysize.b}               *
; *                                                                           *
; *****************************************************************************
Statement lowlevel_QueryKeys{queryarrayaddress.l,arraysize.b}
  !lowlevel_QueryKeys{queryarrayaddress,arraysize}
End Statement


CNIF #__include=0
WBStartup

Dim lowlevel_RawKeyStatus.KeyQuery(256)     ; create a array with the needed structur for lowlevel_QueryKeys{}

NPrint "lowlevel.library demo in Amiblitz3:"
NPrint "Press CTRL+C to quit..."
error_SetFlags{#error_stdout} ; error messages only to console

;initiate the lowlevel.library
If lowlevel_InitLib{} = False Then End

;check witch Language the user choose in his System
Select lowlevel_GetLanguageSelection{}
  Case #LANG_GERMAN   : language$="Deutsch"
  Case #LANG_ENGLISH  : language$="English"
  Case #LANG_AMERICAN : language$="American"
  Case #LANG_UNKNOWN  : language$="<unknown>"
  Default
     language$="<some language>"
End Select
NPrint "Language detected: ",language$

;Set Keycode(RAWKeycode) for lowlevel_QueryKeys{} function
lowlevel_RawKeyStatus(255)\kq_KeyCode = 64            ; set RawKeycode for Space


Repeat
  keystatus.l  = lowlevel_GetKey{}
  If (keystatus><$FF)
    Print "Keyboard: Key #"+Str$(keystatus&$FF)
    If (keystatus&#LLKF_CAPSLOCK) Then Print " +Capslock"
    If (keystatus&#LLKF_CONTROL)  Then Print " +Control"
    If (keystatus&#LLKF_LALT)     Then Print " +LAlt"
    If (keystatus&#LLKF_LAMIGA)   Then Print " +LAMIGA"
    If (keystatus&#LLKF_LSHIFT)   Then Print " +LShift"
    If (keystatus&#LLKF_RALT)     Then Print " +RAlt"
    If (keystatus&#LLKF_RAMIGA)   Then Print " +RAMIGA"
    If (keystatus&#LLKF_RSHIFT)   Then Print " +RShift"
    Print "\\n"
  End If


  lowlevel_QueryKeys{&lowlevel_RawKeyStatus(0),0}       ; a arraysize of 0 stays for 256, 1 for 1  ...
  If lowlevel_RawKeyStatus(255)\kq_Pressed = True       ; checked if Key was pressed
    NPrint "SPACE is pressed"
  Else
    NPrint "SPACE is released"
  End If


  For port.l=0 To 3
    portstatus.l = lowlevel_ReadJoyPort{port}

    Select (portstatus&#JP_TYPE_MASK)
      Case #JP_TYPE_NOTAVAIL : device$ = "Port "+Str$(port)+" / <No Controller>"
      Case #JP_TYPE_GAMECTLR : device$ = "Port "+Str$(port)+" / GameController"
      Case #JP_TYPE_MOUSE    : device$ = "Port "+Str$(port)+" / Mouse"
      Case #JP_TYPE_JOYSTK   : device$ = "Port "+Str$(port)+" / JoyStick"
      Case #JP_TYPE_UNKNOWN  : device$ = "Port "+Str$(port)+" / Unknow device"
    End Select

    Select (portstatus&#JP_BUTTON_MASK)
      Case #JPF_BUTTON_BLUE    : NPrint device$+": Button #1 (Blue)"
      Case #JPF_BUTTON_RED     : NPrint device$+": Button #2 (Red)"
      Case #JPF_BUTTON_YELLOW  : NPrint device$+": Button #3 (Yellow)"
      Case #JPF_BUTTON_GREEN   : NPrint device$+": Button #4 (Green)"
      Case #JPF_BUTTON_FORWARD : NPrint device$+": Button #5 (Forward)"
      Case #JPF_BUTTON_REVERSE : NPrint device$+": Button #6 (Reverse)"
      Case #JPF_BUTTON_PLAY    : NPrint device$+": Button #7 (Play)"
    End Select

    Select (portstatus&#JP_DIRECTION_MASK)
      Case #JPF_UP             : NPrint  device$+": Up"
      Case #JPF_DOWN           : NPrint  device$+": Down"
      Case #JPF_LEFT           : NPrint  device$+": Left"
      Case #JPF_RIGHT          : NPrint  device$+": Right"
    End Select

    Select (portstatus&#JP_MOUSE_MASK)
      Case 0 : ;no movement
      Default
        ; NPrint device$+": MouseMovement"
    End Select

    Select (portstatus&#JP_MHORZ_MASK)
      Case 0 : ;no movement
        ; NPrint device$+": Horizontal"
    End Select

    Select (portstatus&#JP_MVERT_MASK)
      Case 0 : ;no movement
      Default
        ; NPrint device$+": Vertical"
    End Select

  Next
  Delay_ 5
  breakme.l=SetSignal_(0,#SIGBREAKF_CTRL_C)
Until breakme

End
CEND

