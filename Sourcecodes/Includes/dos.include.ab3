; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "/Bin"
; ExeFile         = "DosDemo"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 126
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 65535
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 2281
; CursorColumn    = 1
; LabelSearch     = "dos_getex"
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 1
; Max GadgetList  = 1
; Max Shape       = 1
; Max Bank        = 1
; Max MenuList    = 1
; Max BlitzFont   = 1
; Max GTList      = 30
; Max Palette     = 1
; Max BitMap      = 1
; Max Screen      = 2
; Max IntuiFont   = 12
; Max Window      = 30
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 1
; Max Sound       = 1
; Max MedModule   = 1
; Max Buffer      = 1
; Max Queue       = 1
; Max Sprite      = 1
; Max Module      = 1
; Max Slice       = 1
; Max Page        = 1
; Max CopList     = 1
; Max PTModule    = 5
; Max Anim        = 1
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 1
; Max XBSound     = 10
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name:  dos.include                                                          /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 18.08.2006                                                            /
;/                                                                             /
;/ Author: Thilo Koehler                                                       /
;/                                                                             /
;/ Requirements: Amiblitz3.0                                                   /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Provide a lot of nice DOS releated functions to Amiblitz2.                  /
;/                                                                             /
;/ Abstract:                                                                   /
;/ The include is a collection of functions like concatenating or splitting :: /
;/ of filenames, running CLI or WB programs etc.                               /
;/ Everything was coded to be OS friendly. Some of the functions can be foun:: /
;/ d as Blitzbasic functions as well, but here they are transparent what the:: /
;/ y are really doing.                                                         /
;/                                                                             /
;/ User Constants:                                                             /
;/                                                                             /
;/ #USE_WBSTARTUPMSG=0                                                         /
;/ 0 = dont get the pointer to the WBStartUpMessage                            /
;/ 1 = get the pointer, needed for dos_GetWB... functions                      /
;/ Note: if you write a WB App, you want to set this to 1                      /
;/       if you write a library or segment code, set this to 0                 /
;/                                                                             /
;/ #CLIARGMODE=0                                                               /
;/ ; 0 = use OS calls           ;  (default) does not support the CLI Arg si:: /
;/ mulation from IDE!                                                          /
;/ ; 1 = use BlitzBasic Par$()                                                 /
;/ ; 2 = disable completely but keeps dummy calls for compatibelity            /
;/                                                                             /
;/ This user constant is used by the functions dos_ReadArgs, dos_nGetNxtArg :: /
;/ and dos_NumArgs.                                                            /
;/ Default is 0.                                                               /
;/                                                                             /
;/ Example:                                                 none               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
CNIF #__include=0
OPTIMIZE 6
SYNTAX 2
WBStartup
CEND

CNIF @#USE_WBSTARTUPMSG=0
#USE_WBSTARTUPMSG = 1
CEND

XINCLUDE "error.include.ab3"
XINCLUDE "multilist.include.ab3"
XINCLUDE "useful.include.ab3"
XINCLUDE "wbstart.include.ab3"

#MAX_DOSTEMPSTRING  = 4096
MaxLen dos_tempstring.s = #MAX_DOSTEMPSTRING

NEWTYPE.DiskObject_
  do_Magic.w; /* a magic number at the start of the file */
  do_Version.w; /* a version number, so we can change it */
  do_Gadget.Gadget;  /* a copy of in core gadget */
  do_Type.b;
  pad.b
  *do_DefaultTool.b;
  *do_ToolTypes.b;
  do_CurrentX.l;
  do_CurrentY.l;
  *do_DrawerData.DrawerData;
  *do_ToolWindow.b;  /* only applies to tools */
  do_StackSize.l; /* only applies to tools */
End NEWTYPE


*dos_WBMsg.WBStartup    = 0
*dos_icon.DiskObject_   = 0
dos_iconfile.s          = ""
dos_iconmodified.l      = 0
dos_debugexe.s          = ""
dos_lastscanpatt.s      = ""
dos_lastscanpath.s      = ""
dos_lastscanflags.l     = 0
*dos_scanlist.ml_node   = 0
*dos_scanroot.ml_node   = 0
*dos_devicelist.ml_node = 0
*dos_deviceroot.ml_node = 0
*dos_volumelist.ml_node = 0
*dos_volumeroot.ml_node = 0
*dos_assignlist.ml_node = 0
*dos_assignroot.ml_node = 0
*dos_fib.FileInfoBlock  = AllocDosObject_ (#DOS_FIB,#TAG_DONE)
version_iconlib.l = 0
version_doslib.l  = 0

Dim List dos_toolstring.s(0)

#CLIARGMODE_OS       = 0
#CLIARGMODE_BLITZ    = 1
#CLIARGMODE_DISABLED = 2

#dos_scan_dirs          = 1
#dos_scan_files         = 2
#dos_scan_nocasesense   = 4
#dos_scan_sorted        = 8


CNIF @#CLIARGMODE=0
#CLIARGMODE=#CLIARGMODE_BLITZ
; 1 = use BlitzBasic Par$()
; 0 = use OS calls           ;  run only in executable, NOT from BLITZ!
; 2 = disable completely but keeps dummy calls for compatibelity
CEND


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_FromBlitz {}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_FromBlitz{}
Function Return FromBlitz
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_FromCLI {}                                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_FromCLI {}
If dos_FromBlitz{} Then Function Return 0
*pr.Process = FindTask_(0)
If *pr\pr_CLI = 0 Then succ.l=False:Else succ=True
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_FromWB {}                                           /
;/                                                                             /
;/ Description:                                                                /
;/ Test if we are running from Workbench.                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if we are running from WB, 0 otherwise                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_FromWB {}
If dos_FromBlitz{} Then Function Return 0
*pr.Process = FindTask_(0)
If *pr\pr_CLI = 0 Then succ.l=True:Else succ=False
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  libversion.l = dos_GetibVersion{library.s}                   /
;/                                                                             /
;/ Description:                                                                /
;/ Get the version of the library.
;/                                                                             /
;/ Inputs:                                                                     /
;/ - library.s     : name of a amiga shared library                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - libversion.l     : version or -1 if the library does not exist /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetLibVersion{library.s}
libversion.l = -1
*lib.Library=OpenLibrary_(&library.s,0)
If *lib
libversion.l = *lib\lib_Version
CloseLibrary_ *lib
End If
Function Return libversion
End Function



CNIF #CLIARGMODE = #CLIARGMODE_OS
NEWTYPE.arghandle
arghandle.l
strings.l[100]
argcounter.l
End NEWTYPE

DEFTYPE.arghandle arghandle
arghandle\strings[0] = 0
arghandle\arghandle  = 0

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dos_ReadArgs {}                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * private *                                                                 /
;/ Read the CLI arguments.                                                     /
;/ Note: this is automatically called on program startup, if you program is :: /
;/ compiled with #support_cliargs=1.                                           /
;/ Note: use dos_nextarg and dos_numargs to get the arguments.                 /
;/                                                                             /
;/ See also:    dos_GetNumArgs, dos_GetNextArg                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dos_ReadArgs {}
SHARED arghandle
If dos_FromCLI{}
  a.s = "all/M"
  arghandle\arghandle = ReadArgs_ (&a.s,&arghandle\strings[0],0)
  arghandle\argcounter = 0
End If
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_GetNumArgs {}                                       /
;/                                                                             /
;/ Description:                                                                /
;/ Get the number of CLI arguments waiting to be collected.                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : number of CLU arguments                                    /
;/                                                                             /
;/ Bugs:                                                                       /
;/ Doesnt work in compile&run mode if you use #support_cliargs=1               /
;/                                                                             /
;/ See also:    dos_GetNextArg                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetNumArgs {}
SHARED arghandle
If arghandle\arghandle = 0 Then dos_ReadArgs{}
offset.l = 0
If arghandle\strings[0]
  While Peek.l(arghandle\strings[0]+offset)
    offset + 4
  Wend
End If
Function Return offset/4
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_GetNextArg {}                                       /
;/                                                                             /
;/ Description:                                                                /
;/ Get the next CLI argument.                                                  /
;/ You can set the following user constant:                                    /
;/                                                                             /
;/ #support_cliargs=x                                                          /
;/                                                                             /
;/ x = 0 : use BlitzBasic Par$()                                               /
;/ x = 1 : use OS calls           ;  run only in executable, NOT from BLITZ!   /
;/ x = 2 : disable completely but keeps dummy calls for compatibelity          /
;/                                                                             /
;/ Note: The purpose of the whole thing is that you can get rid of the blitz:: /
;/ lib that contains Par$() and Numpars and do this with OS function calls.    /
;/ The disadvantage is, that it currently crashes if you do compile&run. May:: /
;/ be this will be fixed somewhen.                                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : CLI argument                                               /
;/                                                                             /
;/ Bugs:                                                                       /
;/ Doesn't work in compile&run mode if you use #support_cliargs=1              /
;/                                                                             /
;/ See also:    dos_GetNumArgs                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetNextArg {}
SHARED arghandle
If arghandle\arghandle = 0 Then dos_ReadArgs{}
arg.s = ""
If arghandle\arghandle
  If arghandle\strings[0]
    sptr.l = Peek.l(arghandle\strings[0]+(arghandle\argcounter LSL 2))
    If sptr
      arg.s = Peek.s(sptr)
      arghandle\argcounter + 1
    End If
  End If
End If
Function Return arg.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_GetArg {argc.l}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Get the CLI argument by index.                                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - argc.l    : index of argument, counting from 0                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : cli argument                                               /
;/                                                                             /
;/ See also:    dos_GetNumArgs                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetArg {argc.l}
SHARED arghandle
If arghandle\arghandle = 0 Then dos_ReadArgs{}
arg.s = ""
If arghandle\arghandle
  If arghandle\strings[0]
    If argc>1 Then argc-1
    If argc<dos_GetNumArgs{} AND argc>=0
      sptr.l = Peek.l(arghandle\strings[0]+(argc LSL 2))
      If sptr
        arg.s = Peek.s(sptr)
        arghandle\argcounter = argc
      End If
    End If
  End If
End If
Function Return arg.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dos_FreeArgs {}                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Free all resources associated with the dos_GetArgs function.                /
;/ NOTE: This function is called on autoexit.                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dos_FreeArgs{}
SHARED arghandle
If arghandle\arghandle
  FreeArgs_ arghandle\arghandle
  arghandle\arghandle = False
End If
End Statement
CEND


CNIF #CLIARGMODE = #CLIARGMODE_DISABLED
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.s = dos_GetNextArg {}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetNextArg {}
Function Return ""
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.s = dos_GetArg {argc.l}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetArg {argc.l}
Function Return ""
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = dos_GetNumArgs {}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetNumArgs {}
Function Return 0
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dos_ReadArgs {}                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dos_ReadArgs {}
End Statement

Statement dos_FreeArgs{}
End Statement

CEND



CNIF #CLIARGMODE = #CLIARGMODE_BLITZ
; **************************************************************
; *                                                            *
; * Read CLI Args the Blitz way, using the same API like OS    *
; *                                                            *
; **************************************************************
NEWTYPE.arghandlex
argcounter.l
End NEWTYPE
DEFTYPE.arghandlex arghandle

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.s = dos_GetNextArg {}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetNextArg {}
SHARED arghandle
arghandle\argcounter+1
If NumPars>=arghandle\argcounter Then a.s = Par$(arghandle\argcounter):Else a.s = ""
Function Return a.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.s = dos_GetArg {argc.l}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetArg {argc.l}
SHARED arghandle
If argc<1 Then argc=1
arghandle\argcounter = argc
If NumPars>=arghandle\argcounter Then a.s = Par$(arghandle\argcounter):Else a.s = ""
Function Return a.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = dos_GetNumArgs {}                                        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetNumArgs {}
Function Return NumPars
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dos_ReadArgs {}                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dos_ReadArgs {}
SHARED arghandle
; Blitz is doing this automatically for us
arghandle\argcounter=0
End Statement

Statement dos_FreeArgs{}
End Statement


CEND


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_AddPartAB3 {path.s,fil.s}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Concatenate a path and a filename, coded in AB3.                            /
;/ Note: Better use dos_AddPart!                                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - path.s    : dos path                                                      /
;/ - fil.s    : file name                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : path+file name                                             /
;/                                                                             /
;/ Example:                                                                    /
;/ NPrint dos_AddPart{"Work:Pictures","MyPic.gif"}                             /
;/ NPrint dos_AddPart{"Work:Pictures/","MyPic.gif"}                            /
;/                                                                             /
;/ Would both output "Work:Pictures/MyPic.gif".                                /
;/                                                                             /
;/ See also:    dos_FilePart, dos_PathPart                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_AddPartAB3 {path.s,fil.s}
If Right$(path.s,1)><":" AND Right$(path.s,1)><"/" AND path.s><""
  path.s = path.s + "/"
End If
path.s = path.s + fil.s
Function Return path.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_AddPart {pathpart.s,filepart.s}                     /
;/                                                                             /
;/ Description:                                                                /
;/ Concatenate a path and a filename.                                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - pathpart.s   : dos path                                                   /
;/ - filepart.s   : file name                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : path+file name                                             /
;/                                                                             /
;/ Example:                                                                    /
;/ NPrint dos_AddPart{"Work:Pictures","MyPic.gif"}                             /
;/ NPrint dos_AddPart{"Work:Pictures/","MyPic.gif"}                            /
;/                                                                             /
;/ Would both output "Work:Pictures/MyPic.gif".                                /
;/                                                                             /
;/ See also:    dos_FilePart, dos_PathPart                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_AddPart {pathpart.s,filepart.s}
SHARED dos_tempstring.s
dos_tempstring = pathpart
AddPart_ &dos_tempstring,&filepart.s,#MAX_DOSTEMPSTRING
Function Return Peek.s(&dos_tempstring)
End Function


Function.s dos_DevicePart{path.s}

  cpos.l = Instr(path,":")
  If cpos>0
    device.s = Left$(path,cpos)
  End If

  Function Return device
  
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_FilePartAB3 {path.s}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Crop the file part out of a filename with complete path.                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - path.s    : filename with path                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : only the file part                                         /
;/                                                                             /
;/ Example:                                                                    /
;/ NPrint dos_FilePart{"Work:Samples/mysound.info"}                            /
;/                                                                             /
;/ This would return "mysound.info".                                           /
;/                                                                             /
;/ See also:    dos_PathPart, dos_AddPart                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_FilePartAB3 {path.s}
w$=""
Repeat
  newpath.s=w$+newpath.s
  w$=Right$(path.s,1)
  path.s=Left$(path.s,Len(path.s)-1)
Until w$="/" OR w$=":" OR w$=""
Function Return newpath.s
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_PathPartAB3 {path.s}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Get the path part pout of a file or directory name.                         /
;/ Note: This is somehow similar to dos_PathPart. If dos_PathPart works for :: /
;/ you, you should prefere it.                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - path.s    : name of the path/file                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : name of the parent path                                    /
;/                                                                             /
;/ Example:                                                                    /
;/ NPrint "Work:MySamples/GunShots/gun.wav"                                    /
;/                                                                             /
;/ This would return "Work:MySamples/GunShots".                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_PathPartAB3 {path.s}
Repeat
w$     = Right$(path.s,1)
path.s = Left$ (path.s,Len(path.s)-1)
Until w$ = ":" OR w$="/" OR w$=""
If w$=":" Then path.s=path.s+":"
Function Return path.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_ParentPathAB3 {path.s}                              /
;/                                                                             /
;/ Description:                                                                /
;/ Get the parent directory.                                                   /
;/ Note: This is somehow similar to dos_ParentPart. If dos_PathPart works fo:: /
;/ r you, you should prefere it.                                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - path.s    : path name                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : parent path                                                /
;/                                                                             /
;/ Example:                                                                    /
;/ NPrint "Work:MySamples/GunShots/"                                           /
;/                                                                             /
;/ This would return "Work:MySamples".                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_ParentPathAB3 {path.s}
If Right$(path.s,1) = "/" Then path.s = Left$(path.s,Len(path.s)-1)
While Right$(path.s,1)><"/" AND Right$(path.s,1) ><":" AND Right$(path.s,1)><""
path.s = Left$(path.s,Len(path.s)-1)
Wend
If Right$(path.s,1) = "/" Then path.s = Left$(path.s,Len(path.s)-1)
Function Return path.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_FilePart {filename.s}                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s   : filename with path                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : only the file part                                         /
;/                                                                             /
;/ Example:                                                                    /
;/ NPrint dos_FilePart{"Work:Samples/mysound.info"}                            /
;/                                                                             /
;/ This would return "mysound.info".                                           /
;/                                                                             /
;/ See also:    dos_PathPart, dos_AddPart                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_FilePart {filename.s}
fptr.l = FilePart_(&filename.s)
If fptr
  filepart.s = Peek.s(fptr)
Else
  filepath.s = ""
End If
Function Return filepart.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_PathPart {filename.s}                               /
;/                                                                             /
;/ Description:                                                                /
;/ Get the path part out of a file or directory name.                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s   : name of the path/file                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : name of the parent path                                    /
;/                                                                             /
;/ Example:                                                                    /
;/ NPrint "Work:MySamples/GunShots/gun.wav"                                    /
;/                                                                             /
;/ This would return "Work:MySamples/GunShots".                                /
;/                                                                             /
;/ See also:    dos_FilePart, dos_AddPart                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_PathPart {filename.s}
pathpart.s = Left$(filename.s,PathPart_(&filename.s)-&filename.s)
Function Return pathpart.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_ParentPath {path.s}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Well, the same like dos_PathPart.                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - path.s     : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s   : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_ParentPath {path.s}
Function Return dos_PathPart{path.s}
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_Exist {filename.s}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Check if the given file exists.                                             /
;/ Note: This function fails, if the file exists but is currently written.     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : name of fie                                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if the file exists, 0 if not                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_Exist {filename.s}
lock.l=Lock_(&filename.s,#ACCESS_READ)
If lock Then UnLock_ lock:succ.l=True:Else succ=False
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_CreateDosList {flags.l}                             /
;/                                                                             /
;/ Description:                                                                /
;/ Create a List (multilist.include) of DosList entires.                       /
;/ Search the RKM for LockDosList to see available flags.                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - flags.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : list of dos entry names according the flags                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_CreateDosList{flags.l}
*doslist.DosList = LockDosList_(flags)
*node.ml_node  = 0
If *doslist
  Repeat
    *doslist = NextDosEntry_(*doslist,flags)
    If *doslist
      pathname.s = LSet$("_",64)
      NameFromLock_ *doslist\dol_Lock,&pathname.s,64
      pathname.s = Peek.s(&pathname)
      !BADDR{name.s,*doslist\dol_Name}
      name +":"
      *node.ml_node = ml_AddNodeSorted{*node,#node_simple,name,pathname,1}
    End If
  Until *doslist = 0
  UnLockDosList_(flags)
End If
*node = ml_GetFirstNode{*node}
Function Return *node
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_ScanAssigns {}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Walk through the OS list of assigns. Call this function until it returns :: /
;/ an empty string, then there are no more assigns.                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s  : name of an assign, e.g. "LIBS"                                /
;/                                                                             /
;/ See also:    dos_ScanDevices, dos_ScanVolumes, dos_ScanDir                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_ScanAssigns{}
SHARED *dos_assignroot,*dos_assignlist
If *dos_assignroot=0
  x.l = #LDF_READ|#LDF_ASSIGNS ;  this is due to a bug in AmiBlitz3.3 compiler
  *dos_assignroot = dos_CreateDosList{x}
  *dos_assignlist = *dos_assignroot
End If
If *dos_assignlist
  name.s = ml_GetLabelString{*dos_assignlist}
  *dos_assignlist = ml_GetNextNode{*dos_assignlist}
Else
  name.s = ""
  ml_RemoveAllNodes{*dos_assignroot}
  *dos_assignroot=0
End If
Function Return name.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_ScanDevices {}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Walk through the OS list of mounted devices. Call this function until it :: /
;/ returns an empty string, then there are no more device.                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s  : name of an device, e.g. "RAM"                                 /
;/                                                                             /
;/ See also:    dos_ScanAssigns, dos_ScanVolumes, dos_ScanDir                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_ScanDevices{}
SHARED *dos_deviceroot,*dos_devicelist
If *dos_deviceroot=0
  x.l = #LDF_READ|#LDF_DEVICES
  *dos_deviceroot = dos_CreateDosList{x}
  *dos_devicelist = *dos_deviceroot
End If
If *dos_devicelist
  name.s = ml_GetLabelString{*dos_devicelist}
  *dos_devicelist = ml_GetNextNode{*dos_devicelist}
Else
  name.s = ""
  ml_RemoveAllNodes{*dos_deviceroot} : *dos_deviceroot=0
End If
Function Return name.s
End Function
 
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_ScanVolumes {}                                      /
;/                                                                             /
;/ Description:                                                                /
;/ Walk through the OS list of volumes. Call this function until it returns :: /
;/ an empty string, then there are no more volume.                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s  : name of a volume, e.g. "Ram Disk"                             /
;/                                                                             /
;/ See also:    dos_ScanDevices, dos_ScanAssigns, dos_ScanDir                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_ScanVolumes{}
SHARED *dos_volumeroot,*dos_volumelist
If *dos_volumeroot=0
  x.l = #LDF_READ|#LDF_VOLUMES
  *dos_volumeroot = dos_CreateDosList{x}
  *dos_volumelist = *dos_volumeroot
End If
If *dos_volumelist
  name.s = ml_GetLabelString{*dos_volumelist}
  *dos_volumelist = ml_GetNextNode{*dos_volumelist}
Else
  name.s = ""
  ml_RemoveAllNodes{*dos_volumeroot} : *dos_volumeroot=0
End If
Function Return name.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_CheckAssign {name.s}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Check if the requestet assign exists (it does not check devices or volumes) /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - name.s    : assign to check                                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l  : -1 if the device exists, 0 otherwise                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_CheckAssign {name.s}
If Right$(name.s,1)=":" Then name.s = UnLeft$(name.s,1)
*assignlist.DosList = LockDosList_(#LDF_READ|#LDF_ASSIGNS)
If *assignlist
  found.l = FindDosEntry_(*assignlist,&name.s,#LDF_ASSIGNS)
  If found
    succ.l = True
  Else
    succ.l = False
  End If
  UnLockDosList_(#LDF_READ|#LDF_ASSIGNS)
End If
Function Return succ.l
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_SetAssign {name.s,path.s,@force.l}                  /
;/                                                                             /
;/ Description:                                                                /
;/ Make an assign to a disk path.                                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - name.s    : name of the assign                                            /
;/ - path.s    : path were the assign should point to                          /
;/ - force.l   : set this assign, even if it already exists (the old one wil:: /
;/ l be replaced!)                                                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l  : -1 if the assign was created, 0 otherwise                     /
;/                                                                             /
;/ See also:    dos_AddAssign                                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_SetAssign {name.s,path.s,@force.l}
succ.l = 0
If Right$(name.s,1)=":" Then name.s = UnLeft$(name.s,1)
If force=False
  If dos_CheckAssign{name.s} Then Function Return 0
End If
succ.l = AssignPath_(&name,&path)
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_SetAssignLock {name.s,path.s,@force.l}              /
;/                                                                             /
;/ Description:                                                                /
;/ Same like dos_SetAssign, but uses AssignLock().                             /
;/ See RKM for differneces between AssignLock() and AssignPath().              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - name.s    : name of the assign                                            /
;/ - path.s    : path were the assign should point to                          /
;/ - force.l   : add this assign, even if it already exists                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l  : -1 if the assign was created, 0 otherwise                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_SetAssignLock {name.s,path.s,@force.l}
succ.l = 0
If Right$(name.s,1)=":" Then name.s = UnLeft$(name.s,1)
If force=False
  If dos_CheckAssign{name.s} Then Function Return 0
End If

lock.l = Lock_(&path,#ACCESS_READ)
If lock
  succ.l = AssignLock_(&name,lock)
  If succ=False Then UnLock_ lock
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_AddAssign {name.s,path.s}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Add a path to an existing assing.                                           /
;/ Note: The assign must already exist. Use dos_CheckAssign to choose betwee:: /
;/ n dos_SetAssign and dos_AddAssign.                                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - name.s    : name of the assing                                            /
;/ - path.s    : name were the assing should point to                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l  : -1 if the assign was added 0 otherwise                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_AddAssign{name.s,path.s}
succ.l = 0
If Right$(name.s,1)=":" Then name.s = UnLeft$(name.s,1)
If dos_CheckAssign{name.s} ; check if the assing exists...
  lock.l = Lock_(&path,#ACCESS_READ)
  succ.l = AssignAdd_(&name,lock.l)
  If succ=False Then UnLock_ lock
EndIf
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_RemAssign {name.s}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Remove an Assing from the system list.                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - name.s    : name of the assign                                            /
;/ - path.s    : optional path of were the assign points to, if multi-assign
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l  : -1 if the assign was removed, 0 otherwise                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_RemAssign {name.s,@path.s}
If Right$(name.s,1)=":" Then name.s = UnLeft$(name.s,1)
If path=""
  succ.l = AssignLock_(&name,Null)          ; workbench freeze with OS 3.2 ??? bug ???
Else
  lock.l = Lock_ (&path,#ACCESS_READ)
  If lock
    succ = RemAssignList_(&name,lock)
    UnLock_ lock : lock=0
  End If
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dos_ReadWBArgs {}                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ *private*                                                                   /
;/ Read the startup arguments from the WBStartUpMessage.                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dos_ReadWBArgs {}
SHARED *dos_WBMsg.WBStartup
CNIF #USE_WBSTARTUPMSG
SysJsr $BF01 ; GetWBStartupMsg
MOVE.l d0,WBStartupMsg
*dos_WBMsg.WBStartup    = Peek.l(?WBStartupMsg)
JMP SkipDosASM
.WBStartupMsg
Dc.l 0
SkipDosASM:
CEND
End Statement

Function.WBStartup dos_GetWBStartup{}
SysJsr $BF01 ; GetWBStartupMsg
MOVE.l d0,GetWBStartupMsg
*WBStartup_.WBStartup = Peek.l(?GetWBStartupMsg)
Function Return *WBStartup_
.GetWBStartupMsg
Dc.l 0
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_GetWBNumArgs {}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Get the number of WB arguments.                                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l   : # of WB Arguments                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetWBNumArgs{}
_WBNumArgs.l = 0
If dos_FromWB{}
  CNIF #USE_WBSTARTUPMSG
  SHARED *dos_WBMsg
  If *dos_WBMsg = 0 Then dos_ReadWBArgs{}
  If *dos_WBMsg
    _WBNumArgs.l = *dos_WBMsg\sm_NumArgs
  End If
  CEND
End If
Function Return _WBNumArgs
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_GetWBArg {argc.l}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Get an WB argument by index.                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - argc.l    : index of argument                                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s  : argument string                                               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetWBArg{argc.l}
arg.s = ""
If dos_FromWB{}
  CNIF #USE_WBSTARTUPMSG
  SHARED *dos_WBMsg
  If *dos_WBMsg = 0 Then dos_ReadWBArgs{}
  If *dos_WBMsg
    If argc<*dos_WBMsg\sm_NumArgs
      *argP.WBArg = *dos_WBMsg\sm_ArgList + (SizeOf.WBArg * argc)
      arg.s = Peek.s(*argP\wa_Name)
    End If
  End If
  CEND
End If
Function Return arg.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_GetWBLock {argc.l}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - argc.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetWBLock{argc.l}
lock.l = 0
If dos_FromWB{}
  CNIF #USE_WBSTARTUPMSG
  SHARED *dos_WBMsg
  If *dos_WBMsg = 0 Then dos_ReadWBArgs{}
  If *dos_WBMsg
    If argc<*dos_WBMsg\sm_NumArgs
      *argP.WBArg = *dos_WBMsg\sm_ArgList + (SizeOf.WBArg * argc)
      lock = *argP\wa_Lock
    End If
  End If
  CEND
End If
Function Return lock
End Function
 
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_GetProgDir {defaultdir.s}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Return die directory from where the exectable was started from.             /
;/ Note: This makes is almost always possible to get rid of ugly assings, th:: /
;/ at are often a source of problems to users.                                 /
;/ If you read out the programs directory, and do all your data file reading:: /
;/  relative from here (e.g. by concatenating filenames with dos_AddPart), y:: /
;/ ou get indepentend form the location on the disk.                           /
;/                                                                             /
;/ The defaultdir.s should point to the directory you are developing your ap:: /
;/ plication in. If you do compile&run, this function will return the defaul:: /
;/ tdir.s, because in compile&run mode you dont start the program out of you:: /
;/ r usual directory.                                                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - defaultdir.s    : name of you development default dir                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : path of the executable.                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetProgDir {defaultdir.s}
SHARED dos_tempstring,dos_debugexe
If dos_FromBlitz{}
  If defaultdir="" AND dos_debugexe><"" Then defaultdir=dos_PathPart{dos_debugexe}
  Function Return defaultdir.s
End If
NameFromLock_ GetProgramDir_(),&dos_tempstring,#MAX_DOSTEMPSTRING
path.s=Peek.s(&dos_tempstring)
;If Right$(path.s,1)<>":" AND Right$(path.s,1)<>"/" Then path.s+"/"
Function Return path.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_GetProgFile {defaultexe.s}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Return the own executable's path+filename, or defaultexe.s if started fro:: /
;/ m wihtin Amiblitz IDE.                                                      /
;/ Notes: Works for CLI and Workbench.                                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - defaultexe.s : default string that is returned if you start from Amiblitz /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : full path+filename of your own executable.                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetProgFile {defaultexe.s}
SHARED dos_tempstring,dos_debugexe
If defaultexe = "" Then defaultexe = dos_debugexe
exe.s = ""
If dos_FromBlitz{}
  exe = defaultexe
End If

If dos_FromWB{}
  CNIF #USE_WBSTARTUPMSG
  fil.s  = dos_FilePart{dos_GetWBArg{0}}
  path.s = dos_GetProgDir{""}
  exe.s  = dos_AddPart{path,fil} ; get the path + file
  CELSE
  exe.s = ProgPath$
  CEND
End If

If dos_FromCLI{}
  If GetProgramName_ (&dos_tempstring,#MAX_DOSTEMPSTRING  )
    exe.s = Peek.s(&dos_tempstring)
    ;fil.s = dos_FilePart{Peek.s(&dos_tempstring)} ; not sure what is the correct path
    ;path.s = dos_GetProgDir{""}
    ;exe.s = dos_AddPart{path,fil}
  End If
End If
Function Return exe
End Function

Function.s dos_GetCurrentDir{}
  SHARED dos_tempstring
  cd.s =  ""
  If GetCurrentDirName_ (&dos_tempstring,#MAX_DOSTEMPSTRING  )
    cd.s = Peek.s(&dos_tempstring)
  End If
  Function Return cd
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_GetStartFile {defaultfile.s}                        /
;/                                                                             /
;/ Description:                                                                /
;/ Get the file name of the file that is associated with your program being :: /
;/ launched.                                                                   /
;/ Workbench:                                                                  /
;/ The deficon or project icon                                                 /
;/ CLI:                                                                        /
;/ First CLI argument                                                          /
;/ Amiblitz:                                                                   /
;/ Just returns the defaultfile.s string                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - defaultfile.s    : ???                                                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetStartFile {defaultfile.s}
SHARED dos_tempstring
fil.s = ""
If dos_FromBlitz{}
  fil = defaultfile
End If

If dos_FromWB{}
  CNIF #USE_WBSTARTUPMSG
  If dos_GetWBNumArgs{}>1 ; its a project icon...
    lock.l = dos_GetWBLock{1}
    fil.s  = dos_FilePart{dos_GetWBArg{1}}
    NameFromLock_ lock,&dos_tempstring,#MAX_DOSTEMPSTRING : path.s = Peek.s(&dos_tempstring)
    fil = dos_AddPart{path,fil} ; get the path + file
  End If
  CEND
End If

If dos_FromCLI{}
  If dos_GetNumArgs{}>0 Then fil = dos_GetArg{0}
  ;path.s = dos_GetCurrentDir{} ; not sure which path is correct
  ;fil  = dos_AddPart{path,fil}
End If
Function Return fil
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_GetProgIcon {defaulticon.s}                         /
;/                                                                             /
;/ Description:                                                                /
;/ Get the programs icon (without .info)                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - defaulticon.s    : ???                                                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetProgIcon {defaulticon.s}
icon.s = dos_GetProgFile{defaulticon}
Function Return icon;+".info"
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_GetStartIcon {defaulticon.s}                        /
;/                                                                             /
;/ Description:                                                                /
;/ Get the icon from which a WB App was stated from.                           /
;/ This can be a Tool Icon or Project Icon.                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - defaulticon.s    : ???                                                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetStartIcon {defaulticon.s}
icon.s = dos_GetStartFile{""}
If icon="" Then icon.s = dos_GetProgIcon{defaulticon}
Function Return icon;+".info"
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_GetStartDir {defaultdir.s}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Get the directory from where the program was started from.                  /
;/ Note: This does not necessarily be the directory where the executables li:: /
;/ ves in.                                                                     /
;/ E.g:                                                                        /
;/ If you type in a shell:                                                     /
;/ DH0:Work>DH1:Test/mytool"                                                   /
;/ You will get "DH0:Work", whereas dos_GetProgDir would return "DH1:Test"     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - defaultdir.s    : ???                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetStartDir {defaultdir.s}
SHARED dos_tempstring,dos_debugexe
path.s = ""
If defaultdir="" Then defaultdir=dos_PathPart{dos_debugexe}

If dos_FromBlitz{}
  path = defaultdir.s
End If

If dos_FromWB{}
  path = dos_GetStartFile{""}
  If path="" Then path = dos_GetProgFile{""}
  path = dos_ParentPath{path}
End If

If dos_FromCLI{}
  If GetCurrentDirName_ (&dos_tempstring,#MAX_DOSTEMPSTRING  )
    path = Peek.s(&dos_tempstring)
  End If
End If
Function Return path
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dos_CloseToolTypes {}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_CloseToolTypes{}
SHARED *dos_icon,dos_iconfile,dos_iconmodified,dos_toolstring()
succ.l = False
If *dos_icon
  If dos_iconmodified
; that is OS3.5 only!
;    PutIconTagList_ &dos_iconfile,*dos_icon,Tags(#TAG_DONE,0)
    succ=PutDiskObject_ (&dos_iconfile,*dos_icon)
  Else
    succ=True
  End If
  FreeDiskObject_ *dos_icon
  dos_iconmodified = False
  *dos_icon        = 0
  dos_iconfile.s   = ""
  ClearList dos_toolstring()
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dos_FlushToolTypes {}                                               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dos_FlushToolTypes{}
dos_CloseToolTypes{}
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_SetDefTool {filename.s,tool.s}                      /
;/                                                                             /
;/ Description:                                                                /
;/ Set Icon's Default tool.                                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s   : name of file or .info file                                 /
;/ - tool.s       : Default tool                                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : true if everything went allright                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.w dos_SetDefTool{filename.s,deftool.s}
  SHARED version_iconlib.l
  succ.w = False

  If (version_iconlib=0) Then version_iconlib = dos_GetLibVersion{"icon.library"}
  If (LCase$(Right$(filename,5))=".info") Then filename = Left$(filename,FLen(filename)-5)

  If (version_iconlib<36)
    *dos_icon.DiskObject_ = GetDiskObject_(&filename)
  Else
    *dos_icon.DiskObject_ = GetDiskObjectNew_(&filename)
  End If

  If (*dos_icon)
    *old_deftool.b = *dos_icon\do_DefaultTool
    ;deftoolP.l = AllocVec_(FLen(deftool)+1,#MEMF_ANY)
    ;Poke.s deftoolP,deftool
    *dos_icon\do_DefaultTool = &deftool
    If (PutDiskObject_(&filename,*dos_icon)=1) Then succ=True
    *dos_icon\do_DefaultTool = *old_deftool
    ;FreeVec_ deftoolP
    FreeDiskObject_ *dos_icon
  End If
  Function Return succ

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_SetIconType {filename.s,icontyp.b}                  /
;/                                                                             /
;/ Description:                                                                /
;/ Set Icontype to Project, Program, ...  .                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s   : name of file or .info file                                 /
;/ - icontyp.b    : #WBDISK, #WBDRAWER, #WBTOOL, #WBPROJECT,                   /
;/                  #WBGARBAGE, #WBKICK, #WBAPPICON                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : true if everything went allright                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.w dos_SetIconType{filename.s,icontyp.b}
  SHARED version_iconlib.l
  succ.w = False

  If (version_iconlib=0) Then version_iconlib = dos_GetLibVersion{"icon.library"}
  If (LCase$(Right$(filename,5))=".info") Then filename = Left$(filename,FLen(filename)-5)

  If (version_iconlib<36)
    *dos_icon.DiskObject_ = GetDiskObject_(&filename)
  Else
    *dos_icon.DiskObject_ = GetDiskObjectNew_(&filename)
  End If

  If (*dos_icon)
    *dos_icon\do_Type = icontyp
    If (PutDiskObject_(&filename,*dos_icon)=1) Then succ=True
    FreeDiskObject_ *dos_icon
  End If
  Function Return succ

End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dos_Free {}                                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dos_Free{}
SHARED *dos_icon,dos_iconfile,dos_iconmodified
SHARED *dos_assignroot,*dos_assignnode
SHARED *dos_deviceroot,*dos_devicenode
SHARED *dos_volumeroot,*dos_volumenode
SHARED *dos_fib
dos_CloseToolTypes{}
If *dos_assignroot Then ml_RemoveAllNodes{*dos_assignroot} : *dos_assignroot=0 : *dos_assignnode = 0
If *dos_deviceroot Then ml_RemoveAllNodes{*dos_deviceroot} : *dos_deviceroot=0 : *dos_devicenode = 0
If *dos_volumeroot Then ml_RemoveAllNodes{*dos_volumeroot} : *dos_volumeroot=0 : *dos_volumenode = 0
dos_FreeArgs{}
If *dos_fib Then FreeDosObject_ #DOS_FIB,*dos_fib : *dos_fib=0
End Statement
!autoexit {dos_Free}

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_OpenToolTypes {filename.s}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Open the tooltype information of a certain file.                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s   : name of the file                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : pointer to the disk object                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_OpenToolTypes{filename.s}
SHARED *dos_icon,dos_iconfile,dos_iconmodified,version_iconlib.l
 ; no name, so we have to get our executable's icon
If filename.s = "" Then filename.s = dos_GetProgIcon{""}
If Right$(filename,5)=".info" Then filename = Left$(filename,FLen(filename)-5)

If *dos_icon ; do we already have an icon open ?
  If filename><dos_iconfile Then dos_CloseToolTypes{}
End If
If *dos_icon=0 AND filename.s><""; there is no icon open yet ? Then open it !
  If version_iconlib=0 Then version_iconlib = dos_GetLibVersion{"icon.library"}
  If version_iconlib<36
    *dos_icon.DiskObject_ = GetDiskObject_(&filename.s)
  Else
    *dos_icon.DiskObject_ = GetDiskObjectNew_(&filename.s)
  End If
  dos_iconfile         = filename
  dos_iconmodified     = False
End If
Function Return *dos_icon
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_GetToolString {toolname.s,def.s,@filename.s}        /
;/                                                                             /
;/ Description:                                                                /
;/ Get the value of a tooltype as a string.                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - toolname.s    : name of the tooltype                                      /
;/ - def.s    : default value, in case the tooltype does not exist             /
;/ - iconfile.s    : optionally an icon file, if not the file from the calli:: /
;/ ng program                                                                  /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : data string containing the value of the tooltype           /
;/                                                                             /
;/ Bugs:                                                                       /
;/ This functions searches in the icon file that has the same name like the :: /
;/ executable.                                                                 /
;/ If the program was started as a default tool of a project icon, it wont w:: /
;/ ork.                                                                        /
;/ Therefore you might want to catch the real icon file name from the first :: /
;/ CLI argument, and pass it to this function via the filename parameter.      /
;/                                                                             /
;/ See also:    dos_GetToolValue                                               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetToolString {toolname.s,def.s,@filename.s}
SHARED *dos_icon,dos_iconfile,dos_iconmodified
If dos_OpenToolTypes{filename} ; do we finally have an icon ?
  succ.l=FindToolType_(*dos_icon\do_ToolTypes,&toolname.s)
  If succ ; we found it!
    a.s=Peek.s(succ)
  EndIf
EndIf
If succ=False Then a.s = def.s ; set the default
; remove the "..."
If Peek.b(&a.s)=$22 AND Peek.b(&a.s+FLen(a.s)-1)=$22 Then a.s = Mid$(a.s,2,FLen(a.s)-2)
Function Return a.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_GetToolState {toolname.s,@filename.s}               /
;/                                                                             /
;/ Description:                                                                /
;/ returns  1 if tool exists and is disabled (put in brackets)                /
;/ returns -1 if tool exists and is enabled                                    /
;/ returns  0 if tool doesnt exist                                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - toolname.s  : name of the tooltype                                        /
;/ - filename.s  : icon file                                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l    : see above.                                                  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetToolState {toolname.s,@filename.s}
SHARED *dos_icon,dos_iconfile.s,dos_iconmodified
tool_exist.l  = False
tool_active.l = False
res.l = 0
If dos_OpenToolTypes{filename}
  ttp.l = *dos_icon\do_ToolTypes
  If ttp
    While Peek.l(ttp)><0 AND tool_exist=False
      toolptr.l = Peek.l(ttp)
      If toolptr
        ; get string
        string.s   = Peek.s(toolptr)  : activated.l=True

        ; remove spaces
        nospaces.s = Replace$(string.s," ","")

        ; find the name
        pos.l      = Instr(nospaces,"=",1)
        If pos>0
          name.s = LCase$(Left$(nospaces,pos-1))
        Else
          name.s = LCase$(nospaces)
        End If

        ; remove brackets
        If Left$(name,1)="(" Then name = Right$(name,FLen(name)-1): activated=False
        If activated=False AND Right$(name,1)=")" Then name = Left$(name,FLen(name)-1)

        If name.s = LCase$(toolname)
          tool_exist = True
          If activated Then tool_active=True:Else tool_active=False
        End If
      End If
      ttp + SizeOf.l
    Wend
  End If
End If
If tool_exist Then res=1
If tool_active Then res=-1
Function Return res
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_Trim {a.s}                                          /
;/                                                                             /
;/ Description:                                                                /
;/ Remove leading and trailing spaces, return codes or tabs.                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - a.s       : input string                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s  : trimmed string                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_Trim{a.s}
While Peek.b(&a.s)<=32 AND Peek.b(&a.s)>0:a.s=Right$(a.s,FLen(a.s)-1):Wend
While Peek.b(&a.s+FLen(a.s)-1)<=32 AND Peek.b(&a.s+FLen(a.s)-1)>0:a.s=Left$(a.s,FLen(a.s)-1):Wend
For i.l=0 To FLen(a.s)-1
  Select Peek.b(&a.s+i)
    Case @":" :Poke.b &a.s+i,@"_"
    Case @"#" :Poke.b &a.s+i,@"H"
    Case @"?" :Poke.b &a.s+i,@"7"
    Case @"/" :Poke.b &a.s+i,@"_"
    Case @"\" :Poke.b &a.s+i,@"_"
    Case @"<" :Poke.b &a.s+i,@"("
    Case @">" :Poke.b &a.s+i,@")"
    Case @"|" :Poke.b &a.s+i,@"_"
  End Select
Next
Function Return a.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_SetToolState {toolname.s,enabled.l,@filename.s}     /
;/                                                                             /
;/ Description:                                                                /
;/ this function will return -1, if the toolstate was set,                     /
;/ 0 if it failed (probably the tooltype or the icon doesnt exist)             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - toolname.s   : name of the tooltype                                                       /
;/ - enabled.l    : enable or disable it                                                       /
;/ - filename.s   : optional icon file name                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : success                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_SetToolState {toolname.s,enabled.l,@filename.s}
SHARED *dos_icon,dos_iconfile.s,dos_iconmodified,dos_toolstring()
If AddItem(dos_toolstring())=False Then Function Return 0
tool_exist.l     = False
If dos_OpenToolTypes{filename}
  ttp.l = *dos_icon\do_ToolTypes
  If ttp
    While Peek.l(ttp)><0 AND tool_exist=False
      toolptr.l = Peek.l(ttp)
      If toolptr
        ; get string
        string.s   = Peek.s(toolptr)  : activated.l=True

        ; remove spaces
        nospaces.s = Trim$(string);dos_Trim{string}

        ; check if it is activated
        If Left$(nospaces,1)="(" Then nospaces = Right$(nospaces,FLen(nospaces)-1): activated=False
        If activated=False AND Right$(nospaces,1)=")" Then nospaces = Left$(nospaces,FLen(nospaces)-1)

        ; find the =
        pos.l      = Instr(nospaces,"=",1)
        If pos>0
          name.s = Trim$(LCase$(Left$(nospaces,pos-1)))      ; was dos_Trim
        Else
          name.s = Trim$(LCase$(nospaces)) ; was dos_trim
        End If
        If name.s = LCase$(toolname)
          tool_exist = True

          If activated
            If enabled=False
              dos_toolstring() = "("+nospaces+")"
              Poke.l ttp,&dos_toolstring()       ; fixed the pointer changed to ttp tomsmart1
              dos_iconmodified = True
            End If
          Else
            If enabled=True
              dos_toolstring() = nospaces
              Poke.l ttp,&dos_toolstring()      ; fixed the pointer changed to ttp tomsmart1
              dos_iconmodified = True
            End If
          End If

        End If
      End If
      ttp + SizeOf.l
    Wend
  End If
End If
Function Return tool_exist
End Function
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_GetToolValue {toolname.s,def.l,@filename.s}         /
;/                                                                             /
;/ Description:                                                                /
;/ Same like dos_GetToolString, but interprets the string as an integer value. /
;/ Strings like 'yes', 'true' or 'on' are interpreted as -1, and 'no', 'fals:: /
;/ e', 'off' as 0.                                                             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - toolname.s  : name of the tooltype                                        /
;/ - def.l       : default value, in case the tooltype does not exist          /
;/ - iconfile.s  : optionally an icon file, if not the file from the calling:: /
;/ program                                                                     /
;/ - filename.s  : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l    : integer containing the tooltypes value                      /
;/                                                                             /
;/ See also:    dos_gettooltstring                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetToolValue {toolname.s,def.l,@filename.s}   ; 0 = no value found, value else, e.g. ("$4A3F4B" or "1234")
string.s = dos_GetToolString {toolname.s,Str$(def),filename.s}
string.s = Replace$(LCase$(string.s)," ","")
value.l=Vallong(string.s)
If string.s="true" Then value=-1
If string.s="on"   Then value=-1
If string.s="yes"  Then value=-1
Function Return value
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_GetToolHex {toolname.s,def.l,@filename.s}           /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - toolname.s    : ???                                                       /
;/ - def.l    : ???                                                            /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetToolHex {toolname.s,def.l,@filename.s}   ; 0 = no value found, value else, e.g. ("$4A3F4B" or "1234")
string.s = dos_GetToolString {toolname.s,Str$(def),filename.s}
string.s = Replace$(LCase$(string.s)," ","")
If Left$(string,2) = "0x" Then string = Right$(string,FLen(string)-2)
If Left$(string,1) =  "$" Then string = Right$(string,FLen(string)-1)
If Left$(string,1) =  "#" Then string = Right$(string,FLen(string)-1)
If Left$(string,1) =  "h" Then string = Right$(string,FLen(string)-1)
If Left$(string,2) = "0h" Then string = Right$(string,FLen(string)-2)
value.l=Vallong("$"+string.s)
If string.s="true" Then value=-1
If string.s="on"   Then value=-1
If string.s="yes"  Then value=-1
Function Return value
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.f = dos_GetToolFloat {toolname.s,def.f,@iconfile.s}         /
;/                                                                             /
;/ Description:                                                                /
;/ Same like dos_GetToolValue, but returns a float value.                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - toolname.s  : name of the tooltype                                                        /
;/ - def.f       : default value if tooltype is not found                                                        /
;/ - iconfile.s  : optional icon file                                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.f     : float value                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.f dos_GetToolFloat {toolname.s,def.f,@iconfile.s}
string.s = dos_GetToolString {toolname.s,Str$(def),iconfile.s}
string.s = Replace$(LCase$(string.s)," ","")
value.f=Val(string.s)
If string.s="true" Then value=-1
If string.s="on"   Then value=-1
If string.s="yes"  Then value=-1
Function Return value
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_GetToolSwitch {toolname.s,@iconfile.s}              /
;/                                                                             /
;/ Description:                                                                /
;/ Check if the tooltype exists (-1) or if it is disabled or doesnt even exi:: /
;/ st (0).                                                                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - toolname.s  : name of the tooltype                                                        /
;/ - iconfile.s  : optional icon file                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if tooltype is present, 0 if not                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetToolSwitch {toolname.s,@iconfile.s}
succ.l = 0
ret.l = dos_GetToolState {toolname.s,iconfile.s}
If ret=-1 Then succ=-1
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_SetToolString {toolname.s,string.s,@filename.s,@q:: /
;/ uote.l}                                                                     /
;/                                                                             /
;/ Description:                                                                /
;/ Set the tooltype with the given data string.                                /
;/ If the toolname does not exist, it will be created.                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - toolname.s   : name of the tooltype                                       /
;/ - toolstring.s : string value of the tooltype                               /
;/ - filename.s   : optionally the icon file, if not the programs own icon     /
;/ - quote.l      : put the string in quotes                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if everything went well, 0 if not                       /
;/                                                                             /
;/ See also:    dos_SetToolValue, dos_GetToolString                            /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_SetToolString {toolname.s,string.s,@filename.s,@quote.l}
SHARED *dos_icon,dos_iconfile.s,dos_iconmodified,dos_toolstring()
If dos_OpenToolTypes{filename}
  If AddItem(dos_toolstring())=0 Then Function Return False
  If quote
    dos_toolstring() = toolname.s+"=\\22"+string+"\\22"
  Else
    dos_toolstring() = toolname.s
    If string><""
      dos_toolstring()+"="+string
    End If
  End If
  toolname.s = LCase$(toolname.s)
  count.l = 0
  found.l = False

  ttp.l = *dos_icon\do_ToolTypes
  If ttp
     While Peek.l(ttp)><0 AND found=False
      toolptr.l = Peek.l(ttp)
      If toolptr
        string.s   = Peek.s(toolptr)
        nospaces.s = Replace$(string.s," ","")
        pos.l      = Instr(nospaces,"=",1)
        If pos>=0
          name.s = LCase$(Left$(nospaces,pos-1))
        Else
          name.s = LCase$(nospaces)
        End If
        If name.s = toolname
          Poke.l ttp,&dos_toolstring()
          dos_iconmodified = True
          found = True
        End If
        count+1
      End If
      ttp + SizeOf.l
     Wend
  End If

  If found=False
    newtoolarray.l = AllocVec_(SizeOf.l*(count+2),#MEMF_CLEAR)
    If newtoolarray
      If *dos_icon\do_ToolTypes
        CopyMem_ *dos_icon\do_ToolTypes,newtoolarray,count*SizeOf.l
      End If
      *dos_icon\do_ToolTypes = newtoolarray        ; ? what happend to the original alloced mem, if it get freed ?
      ttp.l = *dos_icon\do_ToolTypes + count*SizeOf.l
      Poke.l ttp,&dos_toolstring()
      Poke.l ttp+SizeOf.l,0
      dos_iconmodified = True
      found = True
      dos_CloseToolTypes{}
      FreeVec_ newtoolarray : newtoolarray = 0
    End If
  End If
End If
Function Return found
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_SetToolValue {toolname.s,value.l,@filename.s}       /
;/                                                                             /
;/ Description:                                                                /
;/ Set the tooltype with the given integer value.                              /
;/ If the toolname does not exist, it will be created.                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - toolname.s  : name of the tooltype                                        /
;/ - value.l     : integer value of the tooltype                               /
;/ - filename.s  : optionally the icon file, if not the programs own icon      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l    : -1 if everything went well, 0 if not                        /
;/                                                                             /
;/ See also:    dos_SetToolString, dos_GetToolValue                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_SetToolValue {toolname.s,value.l,@filename.s}
succ.l = dos_SetToolString{toolname.s,Str$(value),filename.s,False}
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_SetToolHex {toolname.s,value.l,@filename.s}         /
;/                                                                             /
;/ Description:                                                                /
;/ Same like dos_SetToolValue, but writes the value in hexadecimal format.                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - toolname.s  : name of the tooltype                                        /
;/ - alue.l      : integer value of the tooltype                               /
;/ - filename.s  : optionally the icon file, if not the programs own icon      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l    : -1 if everything went well, 0 if not                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_SetToolHex {toolname.s,value.l,@filename.s}
succ.l = dos_SetToolString{toolname.s,Hex$(value),filename.s,False}
Function Return succ
End Function
 
Function.l dos_SetToolBool {toolname.s,value.w,@filename.s}
If value
  succ.l = dos_SetToolString{toolname.s,"true",filename.s,False}
Else
  succ.l = dos_SetToolString{toolname.s,"false",filename.s,False}
End If
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_SetToolFloat {toolname.s,value.f,@filename.s}       /
;/                                                                             /
;/ Description:                                                                /
;/ Same like dos_SetToolValue, but writes a float value.                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - toolname.s  : name of the tooltype                                        /
;/ - value.f     : float value of the tooltype                               /
;/ - filename.s  : optionally the icon file, if not the programs own icon      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l    : -1 if everything went well, 0 if not                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_SetToolFloat {toolname.s,value.f,@filename.s}
succ.l = dos_SetToolString{toolname.s,Str$(value),filename.s,False}
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_SetToolSwitch {toolname.s,state.b,@filename.s}      /
;/                                                                             /
;/ Description:                                                                /
;/ Set a switch (=on or off) tooltype.                                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - toolname.s    : name of the tooltype                                                      /
;/ - state.b       : -1 = on, 0 = off                                                          /
;/ - filename.s    : optionally the icon file                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l      : -1 if everything went well, 0 if not
;/                                              /
;/ See also: dos_GetToolSwitch
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_SetToolSwitch {toolname.s,state.b,@filename.s}
  succ.l = 0
  If NOT dos_SetToolState{toolname.s,state.b}
    succ.l = dos_SetToolString{toolname.s,"",filename,False}
    dos_SetToolState{toolname.s,state}
  Else
    succ.l = True
  EndIf
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.w = dos_CheckDiskSpace {disk.s,bytes.f}                     /
;/                                                                             /
;/ Description:                                                                /
;/ Check if there is bytes.f amount of memory on the given disk path availab:: /
;/ le.                                                                         /
;/ Note: "bytes.f" is a float value, and is allowed to be greater than 2GB.    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - disk.s   : name of a disk or directory, e.g. "Sys:" or "Sys:T"            /
;/ - bytes.f  : number of bytes                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.w     : -1 if the memory is available, 0 if not                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.w dos_CheckDiskSpace {disk.s,bytes.f}
succ.w = False
lock.l=Lock_(&disk.s,#ACCESS_READ)
If lock
  DEFTYPE .InfoData idat
  If Info_(lock, idat)
    If idat\id_DiskState = #ID_VALIDATED
      nbu.f = idat\id_NumBlocksUsed
      nb.f  = idat\id_NumBlocks
      bpb.f = idat\id_BytesPerBlock
      bytes_total.f = nb  * bpb
      bytes_used.f  = nbu * bpb
      bytes_free.f  = bytes_total - bytes_used
      If bytes_free>=bytes Then succ = True
    End If
  End If
  UnLock_ lock
EndIf
Function Return succ
End Function

Function.f dos_GetDiskSpace{disk.s}
succ.w = False
lock.l=Lock_(&disk.s,#ACCESS_READ)
If lock
  DEFTYPE .InfoData idat
  If Info_(lock, idat)
    If idat\id_DiskState = #ID_VALIDATED
      nbu.f = idat\id_NumBlocksUsed
      nb.f  = idat\id_NumBlocks
      bpb.f = idat\id_BytesPerBlock
      bytes_total.f = nb  * bpb
      bytes_used.f  = nbu * bpb
      bytes_free.f  = bytes_total - bytes_used
    End If
  End If
  UnLock_ lock
EndIf
Function Return bytes_free
End Function

Function.f dos_GetDiskSize{disk.s}
succ.w = False
lock.l=Lock_(&disk.s,#ACCESS_READ)
If lock
  DEFTYPE .InfoData idat
  If Info_(lock, idat)
    If idat\id_DiskState = #ID_VALIDATED
      nbu.f = idat\id_NumBlocksUsed
      nb.f  = idat\id_NumBlocks
      bpb.f = idat\id_BytesPerBlock
      bytes_total.f = nb  * bpb
      bytes_used.f  = nbu * bpb
      bytes_free.f  = bytes_total - bytes_used
    End If
  End If
  UnLock_ lock
EndIf
Function Return bytes_total
End Function
 

Function.f dos_GetDiskUsed{disk.s}
succ.w = False
lock.l=Lock_(&disk.s,#ACCESS_READ)
If lock
  DEFTYPE .InfoData idat
  If Info_(lock, idat)
    If idat\id_DiskState = #ID_VALIDATED
      nbu.f = idat\id_NumBlocksUsed
      nb.f  = idat\id_NumBlocks
      bpb.f = idat\id_BytesPerBlock
      bytes_total.f = nb  * bpb
      bytes_used.f  = nbu * bpb
      bytes_free.f  = bytes_total - bytes_used
    End If
  End If
  UnLock_ lock
EndIf
Function Return bytes_used
End Function
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_RemPath {filename.s,path.s}                         /
;/                                                                             /
;/ Description:                                                                /
;/ Remove the path from the filename.                                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s : complete filename                                            /
;/ - path.s     : path                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s   : filename without path                                      /
;/                                                                             /
;/ Example:                                                                    /
;/ NPrint dos_RemPath{"Work:MySamples/Gunshots/gun.wav","Work:MySamples"}      /
;/                                                                             /
;/ This would return "Gunshots/gun.wav".                                       /
;/                                                                             /
;/ See also:    dos_AddPart, dos_PathPart, dos_FilePart                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_RemPath {filename.s,path.s}
ufilename.s = UCase$(filename.s)
path.s      = UCase$(path.s)
pos.l       = Instr(ufilename.s,path.s,1)
If pos>0
  filename.s = Right$(filename.s,Len(filename.s)-pos-Len(path.s)+1)
  If Left$(filename.s,1)="/" Then filename.s = Right$(filename.s,Len(filename.s)-1)
End If
Function Return filename.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.w = dos_SetTaskPri {newpri.w}                               /
;/                                                                             /
;/ Description:                                                                /
;/ Set the task pri of the current or given task.                              /
;/ Note: Be careful with extreme task priorities.                              /
;/ A task with a value smaller than 0 (default) can be blocked completely.     /
;/ A task with a value greater than 20 freeze the mouse and keyboard until t:: /
;/ hey go lower again or sleep. Dont do bussy loops in a task >0 ! (dont do :: /
;/ them anyway!)                                                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - newpri.w    : new priority [-128...127]                                   /
;/ - *task.Task   : optionally an other task than you own one                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.w     : old task priority                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.w dos_SetTaskPri {newpri.w}
If newpri>=-128 AND newpri<=127
  Forbid_
  owntask.l=FindTask_(0)
  oldpri.w=SetTaskPri_(owntask,newpri)
  Permit_
End If
Function Return oldpri
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_RemExt {filename.s}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Remove the extention from the file name.                                    /
;/ Note: As an extentions counts the alphanumerical part after the last dot,:: /
;/  it is is shorter than 8 characters.                                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : name of file                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : name of file without extention                             /
;/                                                                             /
;/ Example:                                                                    /
;/ NPrint dos_RemExt{"Libs:graphics.library"}                                  /
;/                                                                             /
;/ This would return "Libs:graphics".                                          /
;/                                                                             /
;/ See also:    dos_ext_set                                                    /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_RemExt {filename.s} ; ------------------------------------------------------
m.l = FLen(filename.s)
While w$><"."
  w$=Mid$(filename.s,m,1):m-1:If m=0 OR (FLen(filename.s)-m)>8 Then w$=".":m=FLen(filename.s)
Wend
filename.s = Left$(filename.s,m)
Function Return filename.s
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_GetExt {filename.s}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ Crop the filenames extention.                                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : filename                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : extention of the filename                                  /
;/                                                                             /
;/ Example:                                                                    /
;/ NPrint "Work:disk.info"                                                     /
;/                                                                             /
;/ This would return "info".                                                   /
;/                                                                             /
;/ See also:    dos_SetExt                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetExt {filename.s} ; ------------------------------------------------------
  m.l = FLen(filename.s)
  If m > 0
    While w$ <> "."
      w$ = Mid$(filename.s,m,1)
      m - 1
      If m = 0 OR (FLen(filename.s)-m) > 10 Then w$ = "." : m = FLen(filename.s)
    Wend
    filename.s = Right$(filename.s,FLen(filename.s)-m-1)
    Function Return filename.s
  Else
    Function Return ""
  EndIf
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_SetExt {filename.s,extention.s}                     /
;/                                                                             /
;/ Description:                                                                /
;/ Changes the extention of the filename.                                      /
;/ If the file has no extention, the new extention will be added.              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : name of file                                              /
;/ - extention.s    : new extention.                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : filename with new extention.                               /
;/                                                                             /
;/ Example:                                                                    /
;/ NPrint dos_SetExt{"Work:Samples/mysound.aiff","wav"}                        /
;/                                                                             /
;/ This would return "Work:Samples/mysound.wav".                               /
;/                                                                             /
;/ See also:    dos_ext_remove                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_SetExt {filename.s,extention.s}
If extention.s><""
  filename.s = dos_RemExt {filename.s}
  filename.s + "." + extention.s
End If
Function Return filename.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_CreateDir {dir.s}                                   /
;/                                                                             /
;/ Description:                                                                /
;/ Create a new directory. The function will fail if the directory already e:: /
;/ xists, or if the parent path does not exist.                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - dir.s    : name of directory to create                                    /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if everything went well, 0 if not                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_CreateDir {dir.s}
succ.l = False
*lock.l = CreateDir_(&dir.s)
If *lock
  succ.l = True
  UnLock_ *lock
EndIf
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_CheckLib {library.s,libversion.l}                   /
;/                                                                             /
;/ Description:                                                                /
;/ Check a library for existence and version.                                  /
;/ Note: If you use external libraries, always check for their existence. Th:: /
;/ is hold even for libraries, that you use as blitz tokens.                   /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - library.s    : name of a amiga shared library                             /
;/ - libversion.l    : minimum version number                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if the library exists with the mimimum version number:: /
;/ , or 0                                                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_CheckLib{library.s,libversion.l}
If libversion<0 Then libversion=0
*lib.Library=OpenLibrary_(&library.s,libversion)
If *lib
  CloseLibrary_ *lib
  Function Return True
End If
Function Return False
End Function




;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: dos_SetDebugExe {path.s}                                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - path.s    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement dos_SetDebugExe{path.s}
SHARED dos_debugexe
dos_debugexe = path.s
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_CreateFileList {path.s,pattern.s,@flags.l}          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - path.s    : ???                                                           /
;/ - pattern.s    : ???                                                        /
;/ - flags.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_CreateFileList {path.s,pattern.s,@flags.l}
SHARED dos_listlength.l,*dos_fib
lock.l = Lock_(&path.s,#ACCESS_READ)
If lock><0 AND *dos_fib><0
  dos_listlength=0
  oldlock.l = CurrentDir_(lock)
  If oldlock
    buf.s = LSet$(" ",FLen(pattern.s)*3+4)
    If flags&#dos_scan_nocasesense
      ParsePatternNoCase_ &pattern.s,&buf.s,FLen(buf.s)
    Else
      ParsePattern_ &pattern.s,&buf.s,FLen(buf.s)
    End If
    pattern.s = Peek.s(&buf.s)
    If Examine_(lock,*dos_fib)
      While ExNext_(lock,*dos_fib)
        filename.s = dos_AddPart{path.s,Peek.s(&*dos_fib\fib_FileName)}
        If *dos_fib\fib_DirEntryType<0
          If flags&#dos_scan_files
            If flags&#dos_scan_nocasesense
              succ.l = MatchPatternNoCase_ (&pattern.s,&*dos_fib\fib_FileName)
            Else
              succ = MatchPattern_ (&pattern.s,&*dos_fib\fib_FileName)
            End If
            If succ
              dos_listlength+1
              If flags&#dos_scan_sorted
                *node.ml_node = ml_AddNodeSorted {*node,#node_simple,dos_FilePart{filename.s},filename.s,0}
              Else
                *node.ml_node = ml_AddNode       {*node,#node_simple,dos_FilePart{filename.s},filename.s,0}
              End If
            End If
          EndIf
        Else
          If flags&#dos_scan_dirs
            ;If flags&#dos_scan_nocasesense
            ;  succ.l = MatchPatternNoCase_ (&pattern.s,&*dos_fib\fib_FileName)
            ;Else
            ;  succ = MatchPattern_ (&pattern.s,&*dos_fib\fib_FileName)
            ;End If
            succ = True
            If succ
              dos_listlength+1
              If flags&#dos_scan_sorted
                *node.ml_node = ml_AddNodeSorted {*node,#node_tree,dos_FilePart{filename.s},filename.s,1}
              Else
                *node.ml_node = ml_AddNode       {*node,#node_tree,dos_FilePart{filename.s},filename.s,1}
              End If
            End If
          End If
        End If
      Wend
    End If
    oldlock = CurrentDir_ (oldlock)
  End If
  UnLock_ lock
End If
*node = ml_GetFirstNode{*node}
Function Return *node
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_ScanDir {path.s,@pattern.s,@flags.l}                /
;/                                                                             /
;/ Description:                                                                /
;/ Scan through a directory according the pattern. See #dos_scan_... for pos:: /
;/ sible flags.                                                                /
;/ Call this function in a loop until it returns the empty string to indicate  /
;/ that all files have been iterated.                                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - path.s     : dos path to scan                                             /
;/ - pattern.s  : dos pattern for matching                                     /
;/ - flags.l    : flags for dirs, files and sorting                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s   : filename of the next matching file                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_ScanDir{path.s,@pattern.s,@flags.l}
SHARED dos_lastscanpatt.s,dos_lastscanpath.s,dos_lastscanflags.l,*dos_scanlist.ml_node,*dos_scanroot.ml_node
If path.s><dos_lastscanpath OR pattern><dos_lastscanpatt OR flags><dos_lastscanflags OR *dos_scanroot=0
  dos_lastscanpath  = path
  dos_lastscanpatt  = pattern
  dos_lastscanflags = flags
  If *dos_scanroot Then ml_RemoveAllNodes{*dos_scanroot} : *dos_scanroot=0
  *dos_scanroot = dos_CreateFileList{path.s,pattern.s,flags}
  *dos_scanlist = *dos_scanroot
End If

If *dos_scanlist
  filename.s = ml_GetUserString{*dos_scanlist}
  *dos_scanlist = ml_GetNextNode{*dos_scanlist}
Else
  filename.s = ""
  ml_RemoveAllNodes{*dos_scanroot} : *dos_scanroot=0
End If
Function Return filename
End Function

Function.l dos_GetListLength{}
SHARED dos_listlength
Function Return dos_listlength
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_Copy {sourcefile.s,destfile.s}                      /
;/                                                                             /
;/ Description:                                                                /
;/ Copy sourcefile to destination file. This is the same as if you would exe:: /
;/ cute in a shell:                                                            /
;/                                                                             /
;/ 1> copy "<sourcefile>" to "<destfile>"                                      /
;/                                                                             /
;/ Note: The functions automatically adds quotation marks to the filenames. :: /
;/ This way, spaces in the filenames are allowed.                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - sourcefile.s    : name of the source file                                 /
;/ - destfile.s    : name of the destination file                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if everything went well, 0 if something went wrong      /
;/                                                                             /
;/ Bugs:                                                                       /
;/ The function might fail if your filenames contain already quotation marks.  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_Copy {sourcefile.s,destfile.s}
;If Peek.b(&sourcefile.s)><$22 Then sourcefile.s = "\\22"+sourcefile.s + "\\22"
;If Peek.b(&destfile.s)><$22   Then destfile.s   = "\\22"+destfile.s   + "\\22"
a.s = "C:Copy \\22"+sourcefile.s+"\\22 to \\22"+destfile.s+"\\22"
succ.l = Execute_ (&a.s,0,0)
If dos_Exist{destfile.s} Then succ=True:Else succ=False
;If succ Then succ=False:Else succ=True
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_Rename {oldname.s,newname.s}                        /
;/                                                                             /
;/ Description:                                                                /
;/ Rename a file or directory.                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - oldname.s    : name of the exisiting file                                 /
;/ - newname.s    : new name of the file                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if everything went well, 0 if not                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_Rename {oldname.s,newname.s}
If Rename_ (&oldname.s,&newname.s)
  Function Return True
Else Function Return False
EndIf
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_SetProtect {filename.s,bits.l}                      /
;/                                                                             /
;/ Description:                                                                /
;/ Set the protection bits of a file or directory.                             /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : name of file/directory                                    /
;/ - bits.l    : protection bitmask                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if everything went well, 0 if not                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_SetProtect {filename.s, bits.l}
If SetProtection_(&filename.s,bits)
  Function Return True
Else Function Return False
EndIf
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_Delete {filename.s,@respectprotection.l}            /
;/                                                                             /
;/ Description:                                                                /
;/ Delete the file.                                                            /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s          : name of file to delete                              /
;/ - respectprotection.l : if set to False, the file will be deleted even if:: /
;/  it is protected from deletion.                                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if the file was deleted, 0 if not (probably it was op:: /
;/ en then or did not exist)                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_Delete {filename.s,@respectprotection.l}
If respectprotection=False
  dos_SetProtect{filename,0}
End If
If DeleteFile_ (&filename.s)
  Function Return True
Else Function Return False
EndIf
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_GetFileSizeEx {filename.s}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Get the file size in bytes.                                                 /
;/ Note: This is a cool version of the fsize function, because it even retur:: /
;/ ns the current size of a file that is being written, without the need to :: /
;/ make a lock on the file.                                                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : name of file                                              /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : file size in bytes                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetFileSizeEx {filename.s}
SHARED *dos_fib
size.l = -1
path.s = dos_PathPart {filename.s}
fil.s = dos_FilePart {filename.s}
lock.l = Lock_ (&path.s,#ACCESS_READ)
If lock><0 AND *dos_fib><0
  If Examine_(lock, *dos_fib) <> 0
    If *dos_fib\fib_DirEntryType >=0
      breakme.l=False
      While ExNext_ (lock,*dos_fib)><0 AND breakme=False
        If Peek.s(&*dos_fib\fib_FileName)=fil.s Then size=*dos_fib\fib_Size:breakme=True
      Wend
    End If
  End If
  UnLock_ lock
End If
Function Return size
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_IsDir {filename.s}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Check if the given file is a directory or a file.                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : file to check                                             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if it is a directory, 0 if it is a file                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_IsDir {filename.s}
SHARED *dos_fib
succ.l = False
If filename = "" Then Function Return False
lock.l=Lock_(&filename,#ACCESS_READ)
If lock><0 AND *dos_fib><0
  If Examine_(lock, *dos_fib) <> 0
    If *dos_fib\fib_DirEntryType < 0
      succ = False
    Else
      succ = True
    EndIf
  EndIf
  UnLock_ lock
EndIf
Function Return succ
End Function

Function.l dos_IsFile {filename.s}
SHARED *dos_fib
succ.l = False
If filename = "" Then Function Return False
lock.l=Lock_(&filename,#ACCESS_READ)
If lock><0 AND *dos_fib><0
  If Examine_(lock, *dos_fib) <> 0
    If *dos_fib\fib_DirEntryType < 0
      succ = True
    Else
      succ = False
    EndIf
  EndIf
  UnLock_ lock
EndIf
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_Check {filename.s}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Tried to open a file and closes it again. It returns -1 if everything wen:: /
;/ t well, or the DOS error code if something went wrong.                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : file name to check                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 or DOS error code                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_Check {filename.s}
lock.l = Lock_ (&filename.s,#ACCESS_READ)
If lock
  succ.l = -1
  UnLock_ lock
Else
  succ = IoErr_()
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_GetFileSize {filename.s}                            /
;/                                                                             /
;/ Description:                                                                /
;/ Get the file size in bytes.                                                 /
;/ Note: This is a straigt forward implentation, it gets a lock on the file :: /
;/ and reads out the size. It will fail on files that are exclusivly locked :: /
;/ (e.g. beeing written). If you want to monitor a locked file, use dos_GetF:: /
;/ ileSizeEx.                                                                  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : name of the file                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : size in bytes                                              /
;/                                                                             /
;/ See also:    dos_GetFileSizeEx                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetFileSize {filename.s}
SHARED *dos_fib
size.l = -1
lock.l=Lock_(&filename.s,#ACCESS_READ)
If lock><0 AND *dos_fib><0
  If Examine_(lock, *dos_fib) <> 0
    If *dos_fib\fib_DirEntryType < 0
      ;size=Peek.l(&*dos_fib\fib_Size)  ; filesize
      size=*dos_fib\fib_Size ; filesize
    Else
      size=-3                  ; drawer
    EndIf
  Else
    size=-2        ; failed!
  EndIf
  UnLock_ lock
Else
  size=-1
EndIf
Function Return size
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_GetFileDate {filename.s}                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s   : ???                                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_GetFileDate {filename.s}
SHARED *dos_fib
date.s = ""
lock.l = Lock_ (&filename.s,#ACCESS_READ)
If lock><0 AND *dos_fib><0
  If Examine_(lock, *dos_fib) <> 0
      date = Date$(*dos_fib\fib_Date\ds_Days)
      ; we should use DateToStr_
  End If
  UnLock_ lock
End If
Function Return date
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = dos_TrimFileName {filename.s}                           /
;/                                                                             /
;/ Description:                                                                /
;/ The given string is forced to be a nice string that works on most filesys:: /
;/ tems by replacing invalid characters with "_".                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : problematic filename                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : nice filename                                              /
;/                                                                             /
;/ Example:                                                                    /
;/ NPrint dos_TrimFileName {"Heya, this is f#?%ing cool :-/"}                  /
;/                                                                             /
;/ This would return "Heya, this is f__ing cool _-_"                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s dos_TrimFileName {filename.s}
For n.l=0 To Peek.l(&filename.s-4)-1
  c.b = Peek.b(&filename.s+n)
  If c=@"?" OR c=@"%" OR c=@"#" OR c=@":" OR c=$22 OR c=@"\" OR c=@"/"
    Poke.b (&filename.s+n),@"_"
  End If
Next
Function Return filename.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_RunCli {filename.s,priority.l,@stack.l,@waitfinis:: /
;/ h.l,@cliargs.s}                                                             /
;/                                                                             /
;/ Description:                                                                /
;/ Run an external program in CLI mode (as if it was run from the Shell).      /
;/ Note: There are many ways to run an external program. If it should be in :: /
;/ CLI mode, this is the best solution, because it is system friendly and al:: /
;/ lows you detailed control over priority and stack.                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : name of the program                                       /
;/ - priority.l    : task priority, usually 0                                  /
;/ - stacksize.l   : optionally amount of stack memory in bytes                   /
;/ - waitfinish    : -1 = wait till the program exits (default), 0 = run a:: /
;/ synchron and return immediately                                             /
;/ - cliargs.s    : pass any cli args as you want, but dont put them into th:: /
;/ e filename !                                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : 0 for success or -1 if something went:: /
;/ wrong,                                                                       /
;/ in waitfinish mode, it returns the return code of the program               /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_RunCli {filename.s,priority.l,@stacksize.l,@waitfinish.w,@cliargs.s,@inputFH.l,@outputFH.l}
  DEFTYPE.tagL10 tagList : n.l = 0
  If Left$(filename,1)><"\\22" Then filename = "\\22" + filename + "\\22"
  If cliargs.s><"" Then filename.s + " " + cliargs.s
  If waitfinish=False AND inputFH =-1 Then inputFH =Null ; protect our own file handles
  If waitfinish=False AND outputFH=-1 Then outputFH=Null
  If inputFH=outputFH AND outputFH><Null AND outputFH><-1 Then inputFH=Null; in- and outputFH must NOT be the same

  tagList\tag[n]\ti_Tag = #NP_Priority, priority : n=n+1
  ;tagList\tag[n]\ti_Tag = #NP_Cli, #DOSTRUE              : n=n+1
  ;tagList\tag[n]\ti_Tag = #NP_Path,         : n=n+1 ; only from CLI
  If waitfinish=False Then tagList\tag[n]\ti_Tag = #SYS_Asynch  , #DOSTRUE         : n=n+1
  If stacksize > 4096  Then tagList\tag[n]\ti_Tag = #NP_StackSize, stacksize : n=n+1
  If inputFH  ><-1 Then tagList\tag[n]\ti_Tag = #SYS_Input    , inputFH   : n=n+1
  If outputFH ><-1
    tagList\tag[n]\ti_Tag = #SYS_Output   , outputFH  : n=n+1
    ;tagList\tag[n]\ti_Tag = #SYS_ErrorOutput,outputFH : n=n+1 ; OS4 only
    ;tagList\tag[n]\ti_Tag = #NP_Error, Null : n=n+1
   ; tagList\tag[n]\ti_Tag = #NP_CloseError,0 : n=n+1
  End If
  tagList\tag[n]\ti_Tag = #TAG_DONE , 0

  ret.l = SystemTagList_ (&filename.s,tagList)
  Function Return ret

End Function

Function.l dos_RunCli3 {filename.s,priority.l,@stacksize.l,@waitfinish.w,@cliargs.s,@inputFH.l,@outputFH.l}
  DEFTYPE.tagL10 tagList : n.l = 0
  If Left$(filename,1)><"\\22" Then filename = "\\22" + filename + "\\22"
  If cliargs.s><"" Then filename.s + " " + cliargs.s
  If waitfinish=False AND inputFH =-1 Then inputFH =0 ; protect our own file handles
  If waitfinish=False AND outputFH=-1 Then outputFH=0
  If inputFH=outputFH AND outputFH><0 AND outputFH><-1 Then inputFH=0; in- and outputFH must NOT be the same

  tagList\tag[n]\ti_Tag = #NP_Priority, priority : n=n+1
  ;tagList\tag[n]\ti_Tag = #NP_Cli, #DOSTRUE              : n=n+1 ; filtered out!
  If waitfinish=False Then tagList\tag[n]\ti_Tag = #SYS_Asynch  , #DOSTRUE         : n=n+1
  If stacksize > 4096  Then tagList\tag[n]\ti_Tag = #NP_StackSize, stacksize : n=n+1
  If inputFH  ><-1    Then tagList\tag[n]\ti_Tag = #SYS_Input    , inputFH   : n=n+1
  If outputFH ><-1
    tagList\tag[n]\ti_Tag = #SYS_Output   , outputFH  : n=n+1
    ;tagList\tag[n]\ti_Tag = #NP_Error, Null : n=n+1 ; gutu
  End If
  
  ;If workdir><""
    ;tagList\tag[n]\ti_Tag = #NP_HomeDir,&workdir : n=n+1  
  ;End If
  tagList\tag[n]\ti_Tag = #TAG_DONE , 0
  ret.l = SystemTagList_ (&filename.s,tagList)

  Function Return ret

End Function


Function.l dos_RunCli2 {filename.s,priority.l,@stacksize.l,@waitfinish.w,@cliargs.s,@inputFH.l,@outputFH.l}
  DEFTYPE.tagL20 tagList : n.l = 0

  If waitfinish=False AND inputFH =-1 Then inputFH =0 ; protect our own file handles
  If waitfinish=False AND outputFH=-1 Then outputFH=0
  If inputFH=outputFH AND outputFH><0 AND outputFH><-1 Then inputFH=0; in- and outputFH must NOT be the same

  seg.l = LoadSeg_ (&filename)
  If seg=Null Then Function Return -1

  tagList\tag[n]\ti_Tag = #NP_Seglist      ,seg   : n+1
  tagList\tag[n]\ti_Tag = #NP_FreeSeglist  ,1     : n+1
  filename = "RUNCLI: "+filename
  tagList\tag[n]\ti_Tag = #NP_Name         ,&filename     : n+1
  If waitfinish
    tagList\tag[n]\ti_Tag = #NP_Synchronous  ,1  : n+1
  Else
    tagList\tag[n]\ti_Tag = #NP_Synchronous  ,0  : n+1
  End If
  If priority><0    Then tagList\tag[n]\ti_Tag = #NP_Priority   ,priority  : n+1
  ;If cliargs        Then tagList\tag[n]\ti_Tag = #NP_Arguments  ,&cliargs  : n+1
  If stacksize>4096 Then tagList\tag[n]\ti_Tag = #NP_StackSize  ,stacksize : n+1
  If inputFH  ><-1
    tagList\tag[n]\ti_Tag = #NP_Input     ,inputFH  : n+1
    tagList\tag[n]\ti_Tag = #NP_CloseInput,0        : n+1
  End If
  If outputFH ><-1
    tagList\tag[n]\ti_Tag = #NP_Output   ,outputFH  : n+1
    ;tagList\tag[n]\ti_Tag = #NP_Error    ,outputFH  : n+1
    ;tagList\tag[n]\ti_Tag = #NP_CloseError ,0 : n+1
    ;tagList\tag[n]\ti_Tag = #NP_CloseOutput,1 : n+1
  End If
  tagList\tag[n]\ti_Tag = #TAG_DONE , 0

  *proc.Process = CreateNewProc_ (tagList)
  If *proc=Null Then ret.l=-1:Else ret=0
  Function Return ret

End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_GetStackSize {@*task.Task}                          /
;/                                                                             /
;/ Description:                                                                /
;/ Return the size of the stack in Bytes.                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *task.Task   : task (or you own task if omitted)                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : stack size                                                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_GetStackSize{@*task.Task}
If *task=-1 OR *task=0 Then *task.Task = FindTask_(0)
stacksize.l = (*task\tc_SPUpper - *task\tc_SPLower)
Function Return stacksize
End Function
 
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_CheckStackSize {bytes.l}                            /
;/                                                                             /
;/ Description:                                                                /
;/ Check the stack size to be at least <bytes> bytes large.                    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - bytes.l    : minimum stack                                                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l   : -1 if the stack is large enough, 0 otherwise                 /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_CheckStackSize{bytes.l}
If dos_GetStackSize{0}<bytes
  succ.l=False
Else
  succ=True
End If
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = dos_RunWB {filename.s}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Run an external program in Workbench mode (as if it was started from a Wo:: /
;/ rkbench icon).                                                              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : filename                                                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : -1 if the program was started, 0 if not.                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l dos_RunWB {filename.s}
  succ.l = False

  ;Start with WBRun command  tomsmart1
  ;If dos_Exist{"WBRun"}                                   ; test if we have the WBRun Command
  ;  succ.l = dos_RunCli{"WBRun",0,8192,False,filename}    ; start the program with it
  ;EndIf

  If dos_CheckLib{"workbench.library",45}               ; test if we have workbench V45 the function is not save at V44 and don't exits in older Versions
    ;start with WorkBench V45 function  tomsmart1
    prog_path.s = dos_PathPart{filename}                ; try to get path of the program
    If prog_path <> ""                                  ; test if we have a path

      newlock.l = Lock_ (prog_path,#SHARED_LOCK )       ; try to Lock the path of the program to start
      If newlock = 0
          error{"Can't Lock path of the Program to start!"}
      Else
        oldlock.l   = CurrentDir_ (newlock)             ; set path for the start of the program to have the right path
        succ.l      = OpenWorkbenchObjectA_(&filename,Tags(#TAG_DONE,#TAG_DONE) )   ; start the program
        newerlock.l = CurrentDir_ (oldlock)             ; restore the old path
        UnLock_ (newlock)                               ; remove the lock
        If succ=0 Then succ=False : Else succ=True
      EndIf
    Else  ; try to start program without a path
      succ  = OpenWorkbenchObjectA_(&filename,Tags(#TAG_DONE,#TAG_DONE) )   ; start the program
      If succ=0 Then succ=False : Else succ=True
    EndIf

  Else ; no Workbech V45
    ; try start with the help of wbstart.library
    If wbstart_OpenLib{2}                               ; replaced wbstart Blitzlib Commands with wbstart.include Function calls to fix problems  tomsmart1
      #WBSTART_VERSION = 2
      #WBStart_Name =          (#TAG_USER + 1)
      #WBStart_DirectoryName = (#TAG_USER + 2)
      #WBStart_DirectoryLock = (#TAG_USER + 3)
      #WBStart_Stack =         (#TAG_USER + 4)
      #WBStart_Priority =      (#TAG_USER + 5)
      #WBStart_ArgumentCount = (#TAG_USER + 6)
      #WBStart_ArgumentList =  (#TAG_USER + 7)
      succ = wbstart_TagList{Tags(#WBStart_Name,&filename.s) }
      If succ=0 Then succ=True : Else succ=False
      wbstart_CloseLib{}
    End If

  EndIf
 Function Return succ
End Function

CNIF #__include=0
;WbToScreen 0
;Window 0,0,0,800,600,$E,"",1,0
a.s = "MyFile.txt"
b.s = "Sys:MyPath"
c.s = dos_AddPart {b.s,a.s}
NPrint "Full Path: ",c.s
NPrint "File Part: ",dos_FilePart {c.s}
NPrint "Path Part: ",dos_PathPart {c.s}
NPrint "File Size of Ram:disk.info: ",dos_GetFileSize {"ram:disk.info"},"bytes"

;NPrint dos_RunCli{"C:TKplayer",0,-1,0,"Cache:krister.aiff"}

;NPrint "Assign: ",dos_SetAssign{"THEMES:","Ram Disk:T",False}

;NPrint "TKPLayer done."
;Repeat
;name.s = dos_ScanDrives{}
;NPrint "DRIVE: ",name.s
;Until name.s=""
;NPrint "Blitz2:",dos_CheckAssign {"Blitz2"}
;NPrint "YXZ:",dos_CheckAssign {"XZY"}
;NPrint "Assign rem: ",dos_RemAssign{"Test2"}

;dos_SetToolValue{"test",-1,"cache:T"}
;NPrint "Enabled:",dos_GetToolState{"iamenabled",""}
;NPrint "Disabled:",dos_GetToolState{"iamdisabled","cache:T"}
;NPrint "Doesnt exist:",dos_GetToolState{"test2","cache:T"}
;NPrint "set dis: "
;NPrint dos_SetToolState{"test2",-1,"cache:T"}

CNIF #USE_WBSTARTUPMSG
NPrint "wbstartupmessage1: ",*dos_WBMsg
CEND
NPrint "GetProgDir:   ",dos_GetProgDir{"defdir"}
NPrint "GetProgFile:  ",dos_GetProgFile{"defexe"}
NPrint "GetProgIcon:  ",dos_GetProgIcon{"deficon"}

NPrint "GetStartDir:  ",dos_GetStartDir{"defdir2"}
NPrint "GetStartFile: ",dos_GetStartFile{"deffile"}
NPrint "GetStartIcon: ",dos_GetStartIcon{"deficon2"}

a.s = dos_FilePart{b.s}
name.s = ""
NPrint "All Devices..."
Repeat
  name.s = dos_ScanDevices{}
  NPrint name
Until name=""


NPrint "All Assigns..."
Repeat
  name.s = dos_ScanAssigns{}
  NPrint name
Until name=""
 
NPrint "All Volumes..."
Repeat
  name.s = dos_ScanVolumes{}
  NPrint name
Until name=""
 
NPrint "All Files..."
Repeat
  name.s = dos_ScanDir{"Sys:","#?",#dos_scan_files}
  NPrint name
Until name=""

;NPrint "Assign: ",dos_CheckAssign{"TBImages:"}
;NPrint "Check: ",dos_Check{"xxx:"}

;NPrint "SetIconType: ",dos_SetIconType{"Sys:test.info",#WBPROJECT}
;NPrint "SetDefTool: ",dos_SetDefTool{"Sys:test.info","MyDefaultTool"}

;If NumPars>0 Then NPrint "par$: 0=",Par$(1):Else NPrint "nopar 1!"
; run CLI test

filename.s = "RAM:dos.include.test.sync.txt"
fh.l = Open_(&filename,#MODE_NEWFILE)
If fh
  dos_RunCli{"dir",0,8192,True,"Sys:",0,fh}
  Close_ fh
End If

filename.s = "RAM:dos.include.test.async.txt"
fh.l = Open_(&filename,#MODE_NEWFILE)
If fh
  dos_RunCli{"dir",0,8192,False,"Sys:",0,fh}
End If

End
CEND




