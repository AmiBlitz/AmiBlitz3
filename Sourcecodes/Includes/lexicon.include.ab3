; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "/Bin"
; ExeFile         = "PreFixTreeDemo"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10000
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 154
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 1
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 7
; CursorColumn    = 9
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 100
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 100
; Max GadgetList  = 100
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 200
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 100
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 1
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 10
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 100
; Max BlitzFont   = 1
; Max GTList      = 100
; Max ChunkyBuffer= 2
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: lexicon.include                                                       /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 08/05/2008                                                            /
;/                                                                             /
;/ Author: <unknown>                                                           /
;/                                                                             /
;/ Requirements:  Amiblitz3                                                    /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Extend AB3 functionality.                                                   /
;/ * no description available *                                                /
;/                                                                             /
;/ Abstract:                                                                   /
;/ * no abstract available *                                                   /
;/                                                                             /
;/ User Constants:                                                             /
;/ #max_objects   = n                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
CNIF #__include=0
  optimize 7
  Syntax 2
CEND

XINCLUDE "dos.include.ab3"  ; we will use functions from the dos.include
XINCLUDE "useful.include.ab3"
XINCLUDE "file.include.ab3"
XINCLUDE "prefixtree.include.ab3"

NEWTYPE.lexicon
doPreFix.l
doPostFix.l
doCaseSense.l
phonemBase.l
phonemSet.l[256]
phonemN.l
*pft.prefixtree
lexN.l
name.l
End NEWTYPE

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = lex_Create {doCaseSense.l,doPreFix.l,doPostFix.l}        /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - doCaseSense.l    : ???                                                    /
;/ - doPreFix.l    : ???                                                       /
;/ - doPostFix.l    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l lex_Create{name.s,doCaseSense.l,doPreFix.l,doPostFix.l}
*lex.lexicon = AllocVec_(SizeOf.lexicon,#MEMF_ANY)
If *lex
  *lex\doPreFix    = doPreFix
  *lex\doPostFix   = doPostFix
  *lex\doCaseSense = doCaseSense
  *lex\phonemBase  = 64
  *lex\phonemN     = 0
  *lex\lexN        = 0
  *lex\pft         = pft_Create{}
  *lex\name        = !_NULL : str_Write{&*lex\name,name}
  For n.l=0 To 255
    *lex\phonemSet[n] = !_NULL
  Next
End If
Function Return *lex
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: lex_Free {*lex.lexicon}                                             /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *lex.lexicon    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement lex_Free{*lex.lexicon}
If *lex
  pft_Free{*lex\pft}
  str_Free{&*lex\name}
  FreeVec_ *lex
End If
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: lex_AddWord {*lex.lexicon,written.s,pron.s}                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *lex.lexicon    : ???                                                     /
;/ - written.s    : ???                                                        /
;/ - pron.s    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement lex_AddWord {*lex.lexicon,written.s,pron.s}
ph.l = 0
newpron.s = ""
phN.l = 0

If *lex\doCaseSense = False Then written.s = LCase$(written)

pos.l= Instr(written,"(")
If pos>0 Then written = Left$(written,pos-1)
;If Instr(written,"=") Then written = ""
;If Instr(written,"_T") Then written = ""

Repeat
  phonem.s   = lindex{pron,ph}
  If phonem
    boundary.s = lindex{phonem,1}
    phonem.s   = lindex{phonem,0}
    If ph=0 AND boundary="WB" AND *lex\doPreFix Then written = "<"+written
    id.l = -1
    ;phonem.s = Replace$(phonem,"}","_")

    If phonem="V"
      If (Instr(written,"v")=0 AND Instr(written,"V")=0) OR Instr(written,"w")>0 Then phonem = "W"
    End If

    For n.l=0 To *lex\phonemN-1
      If phonem.s = str_Read{&*lex\phonemSet[n]} Then id.l = n : n= 255
    Next


    If id=-1 Then id = *lex\phonemN : *lex\phonemN+1 : str_Write{&*lex\phonemSet[id], phonem}
    phN+1
    newpron+Chr$(id+*lex\phonemBase)
  End If
  ph+1
Until phonem=""

If written><""
  basewritten.s = written
  count.l = 1
  Repeat
    If boundary="WB" AND *lex\doPostFix Then written = written+">"
    oldpron.s = pft_FindItem{*lex\pft,written}
    If oldpron
      If oldpron=newpron
        oldpron = ""
      Else
        count+1
        written = basewritten + "("+Str$(count)+")"
      End If
    End If
  Until oldpron = ""
  pft_AddItem{*lex\pft,written,newpron}
  *lex\lexN +1
End If
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.s = lex_Text2Phonem {*lex.lexicon,text.s}                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *lex.lexicon    : ???                                                     /
;/ - text.s    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s lex_Text2Phonem{*lex.lexicon,text.s}
If *lex\doCaseSense=False Then text = LCase$(text)
text.s = Replace$(text,"."," . ")
text.s = Replace$(text,","," , ")
text.s = Replace$(text,":"," : ")
text.s = Replace$(text,"?"," ? ")
text.s = Replace$(text,"!"," ! ")
text.s = Replace$(text,"-"," - ")
text.s = Replace$(text,"\\22"," \\22 ")
text.s = Replace$(text,"'"," '")
wc.l = 0
textpron.s = ""
break.l = False
Repeat
  textword.s = lindex{text,wc}
  If textword = ""
    break=True
    plen.l = 0
    pron.s = ""
  Else
    break=False
    If *lex\doPreFix  Then textword = "<"+textword
    If *lex\doPostFix Then textword = textword+">"
    pron.s = ""
    If wc>0 Then textpron+" + "
    plen.l = 0
  End If

  If Instr(textword," ") ; we got an phonem sequence ?
  ;  textpron + " "+textword :textword= ""
  End If

  While textword><""
    wlen.l = FLen(textword)
    mlen.l = 0
    ;NPrint "Search for ",textword
    wordfrac.s = pft_GetLongestMatch{*lex\pft,textword}
    ;NPrint "Prefix: ",wordfrac
    pronfrac.s = pft_FindItem{*lex\pft,wordfrac}
    ;NPrint "Pron: ",pronfrac

    If FLen(pronfrac)>0
      textword.s = Right$(textword,FLen(textword)-FLen(wordfrac))
      pron.s + pronfrac
    Else
      NPrint "No pron found for \\22",textword,"\\22"
      textword.s = ""
    End If
  Wend
  plen.l = FLen(pron)
  For n.l=0 To plen-1
    id.l = (Peek.b(&pron+n)-*lex\phonemBase)&$00FF
    phonem.s = str_Read{&*lex\phonemSet[id]}
    If phonem><"" Then textpron.s + phonem + " "
  Next
  wc+1
Until break

Function Return textpron
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = lex_LoadASCII {*lex.lexicon,filename.s}                  /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *lex.lexicon    : ???                                                     /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l lex_LoadASCII {*lex.lexicon,filename.s}
fid.l = file_Open{filename,#file_read}
succ.l = False
If fid<0 Then NPrint "Unable to open file!" : Function Return False
While file_EOF{fid}=False
  dictline.s = file_ReadLine{fid}
  If FLen(dictline)>2
    If Peek.l(&dictline)&$FFFFFF00=$EFBBBF00
      dictline = Right$(dictline,FLen(dictline)-3)
    End If
  End If
  written.s = lindex{dictline,0}
  pron.s    = lindex{dictline,1}
  lex_AddWord{*lex,written,pron}
  If (*lex\lexN MOD 1000)= 0 Then NPrint "Read ",*lex\lexN," items!"
  succ.l = True
Wend
file_Close{fid}
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = lex_SaveBin {*lex.lexicon,filename.s}                    /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *lex.lexicon    : ???                                                     /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l lex_SaveBin{*lex.lexicon,filename.s}
succ.l = False
fid.l = file_Open{filename,#file_forcewrite}
If fid<0 Then Function Return False
*pft.prefixtree = pft_Optimize{*lex\pft}
If *pft
  pft_Free{*lex\pft}
  *lex\pft = *pft
End If

If file_WriteChunk{fid,@"LEXX"}
  file_WriteTag{fid,@"PHBA",*lex\phonemBase}
  file_WriteTag{fid,@"LEXN",*lex\lexN}
  file_WriteTag{fid,@"CASE",*lex\doCaseSense}
  file_WriteTag{fid,@"DEOW",*lex\doPostFix}
  file_WriteTag{fid,@"DBOW",*lex\doPreFix}
  For ph.l =0 To *lex\phonemN-1
    file_WriteTagString{fid,@"PHO$",str_Read{&*lex\phonemSet[ph]}}
  Next
  file_WriteTag{fid,@"WORD",0}
  succ.l = pft_Write{*lex\pft,fid}
End If
file_Close{fid}
Function Return succ
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = lex_LoadBin {filename.s}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - filename.s    : ???                                                       /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l lex_LoadBin{filename.s}
fid.l = file_Open{filename,#file_read}
If fid<0 Then Function Return False
*lex.lexicon = lex_Create{dos_RemExt{dos_FilePart{filename}},False,True,True}
If *lex=!_NULL Then Function Return False

If file_ReadTag{fid} = @"LEXX"
  bsize.l = file_GetTagValue{}
  While file_EOF{fid}=False
    bsize - 8
    Select file_ReadTag{fid}
      Case @"NAM$" : str_Write{&*lex\name,file_GetTagString{}}
      Case @"PHBA" : *lex\phonemBase  = file_GetTagValue{}
      Case @"LEXN" : *lex\lexN        = file_GetTagValue{}
      Case @"CASE" : *lex\doCaseSense = file_GetTagValue{}
      Case @"DEOW" : *lex\doPostFix   = file_GetTagValue{}
      Case @"DBOW" : *lex\doPreFix    = file_GetTagValue{}
      Case @"PHO$" : str_Write{&*lex\phonemSet[*lex\phonemN],file_GetTagString{}} : *lex\phonemN+1
      Case @"WORD"
        *lex\pft = pft_Read{fid}
      Default
        ;---
    End Select
  Wend
End If
file_Close{fid}
Function Return *lex
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: lex_Reset {*lex.lexicon}                                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *lex.lexicon    : ???                                                     /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement lex_Reset{*lex.lexicon}
pft_Reset{*lex\pft}
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = lex_GetNextItem {*lex.lexicon}                           /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *lex.lexicon    : ???                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l lex_GetNextItem{*lex.lexicon}
Function Return pft_GetNextItem{*lex\pft}
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.s = lex_GetNextWord {*lex.lexicon}                           /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *lex.lexicon    : ???                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s lex_GetNextWord{*lex.lexicon}
Function Return pft_GetKey{*lex\pft}
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.s = lex_GetNextPron {*lex.lexicon}                           /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *lex.lexicon    : ???                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s lex_GetNextPron{*lex.lexicon}
pron.s = pft_GetString{*lex\pft}
phonem.s = ""
For n.l=0 To FLen(pron)-1
  phonem + str_Read{&*lex\phonemSet[(Peek.b(&pron+n)-*lex\phonemBase)&$00FF]}
  If n<FLen(pron)-1 Then phonem + " "
Next
Function Return phonem
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.s = lex_GetPron {*lex.lexicon,written.s}                     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *lex.lexicon    : ???                                                     /
;/ - written.s    : ???                                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s lex_GetPron{*lex.lexicon,written.s}
pron.s = pft_FindItem{*lex\pft,written}
phonem.s = ""
For n.l=0 To FLen(pron)-1
  phonem + str_Read{&*lex\phonemSet[(Peek.b(&pron+n)-*lex\phonemBase)&$00FF]}
  If n<FLen(pron)-1 Then phonem + " "
Next
Function Return phonem
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = lex_SaveASCII {*lex.lexicon,filename.s,@boundwritten.l}  /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - *lex.lexicon    : ???                                                     /
;/ - filename.s    : ???                                                       /
;/ - boundwritten.l    : ???                                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l lex_SaveASCII {*lex.lexicon,filename.s,@boundwritten.l}
fid.l = file_Open{filename,#file_forcewrite}
If fid<0 Then Function Return False
file_WriteLine{fid,"# Lexicon created by lexicon.include / Thilo Koehler"}
file_WriteLine{fid,"# "+Str$(*lex\lexN)+" entries, "+Str$(*lex\phonemN)+ "phonems"}
file_WriteLine{fid,"# PhonemSet: "}
For ph.l =0 To *lex\phonemN-1
  file_WriteLine{fid,str_Read{&*lex\phonemSet[ph]}}
Next
file_WriteLine{fid,"# Lexicon Items: "}
pft_Reset{*lex\pft}
While pft_GetNextItem{*lex\pft}
   lexkey.s  = pft_GetKey{*lex\pft}
   lexpron.s = pft_GetString{*lex\pft}
   pron.s = ""
   pos.l= Instr(lexkey,"(")
   If pos>0
     variant.s = Right$(lexkey,FLen(lexkey)-pos+1)
     lexkey = Left$(lexkey,pos-1)
   Else
     variant.s = ""
   End If

   If Left$ (lexkey,1)="<" Then lexkey = Right$(lexkey,FLen(lexkey)-1) : doPreFix.l  = True : Else doPreFix  = False
   If Right$(lexkey,1)=">" Then lexkey = Left$ (lexkey,FLen(lexkey)-1) : doPostFix.l = True : Else doPostFix = False
   For n.l=0 To FLen(lexpron)-1
     phon.s = str_Read{&*lex\phonemSet[(Peek.b(&lexpron+n)-*lex\phonemBase)&$00FF]}
     If n=0 AND doPreFix=True
       If boundwritten
         lexkey = "<"+lexkey
       Else
         phon = "{"+phon+" WB}"
       End If
     End If
     If n=FLen(lexpron)-1 AND doPostFix=True
       If boundwritten
         lexkey + ">"
       Else
         phon = "{"+phon+" WB}"
       End If
     End If
     pron.s + phon + " "
   Next
   file_WriteLine{fid, lexkey+variant+Chr$($9)+"{ "+pron+"}"}
Wend
succ.l = True
file_Close{fid}
Function Return succ
End Function

CNIF #__include=0
*lex.lexicon = lex_Create{"Translate",False,False,False}
If *lex
  lex_AddWord{*lex,"Good morning ladies and gentlemen","Guten Morgen meine Damen und Herren"}

  NPrint lex_GetPron{*lex,"Good morning ladies and gentlemen" }
  lex_Free{*lex}
End If
End

CEND
