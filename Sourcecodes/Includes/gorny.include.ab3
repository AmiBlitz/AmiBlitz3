; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "RAM:"
; ExeFile         = "Prog.exe"
; CreateIcon      = 0
; Residents       = ""
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 0
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 5
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 32768
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 1
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 201
; CursorColumn    = 1
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelCase       = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 5
; Max GadgetList  = 5
; Max Shape       = 100
; Max Bank        = 5
; Max MenuList    = 5
; Max GTList      = 20
; Max Palette     = 4
; Max BitMap      = 10
; Max Screen      = 5
; Max IntuiFont   = 5
; Max BlitzFont   = 4
; Max Window      = 20
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max TagList     = 5
; Max Database    = 16
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; Max ChunkyBuffer= 2
; /XTRA
; 2B3D
; Blitz Basic II 3D Graphics Engine
; Version 0.9
;

.definitions

#MAXPOINTS    =    4  ;max points per polygon
#MAXPOLYGONS  =   32  ;max polygons per object
#MAXVERTSOBJ  =  128  ;max vertices per object
#MAXOBJECTS   =   32  ;max OBJECTS per 3d world
#MAXPOLYFRAME = 1024  ;max polygons in a frame (16*12)

#FLAT         = 0     ;shading type
#CONSTANT     = 1

#ZPLANE       = 0     ;clipping boundaries
#FRUSTUM      = 1

NEWTYPE.matrix4x4
  r0.f[4]
  r1.f[4]
  r2.f[4]
  r3.f[4]
End NEWTYPE

NEWTYPE.matrix1x4
  r.f[4]
End NEWTYPE

NEWTYPE.vector
  x.f:y:z:w
End NEWTYPE

NEWTYPE.vertex
  x.f:y:z
End NEWTYPE

NEWTYPE.pixel
  x.w:y
End NEWTYPE

NEWTYPE.line
a.vertex:b
End NEWTYPE

NEWTYPE.polytemp
x1.w:y1:x2:y2:x3:y3:x4:y4
End NEWTYPE

NEWTYPE.dir3d
  angx.l:angy:angz
End NEWTYPE

NEWTYPE.rgbtype
  r.w:g:b
End NEWTYPE

NEWTYPE.polygon
  numpoints.w
  color.w
  shade.w
  shading.w
  twosided.b
  visible.b
  clipped.b
  active.b
  vertexlist.l[#MAXPOINTS]
  normallength.f
End NEWTYPE

NEWTYPE.facet
  svalue.l
  numpoints.w
  color.w
  shade.w
  shading.w
  twosided.b
  visible.b
  clipped.b
  active.b
  vertexlist.vertex[#MAXPOINTS]
  normallength.f
End NEWTYPE

NEWTYPE.objectnode
  id.b
  name.s
  numverts.w
  vlocal.vertex[#MAXVERTSOBJ]
  vglobal.vertex[#MAXVERTSOBJ]
  vcamera.vertex[#MAXVERTSOBJ]
  numpolys.w
  polys.polygon[#MAXPOLYGONS]
  radius.f
  state.b
  worldpos.vertex
End NEWTYPE

.declarations

DEFTYPE.l HALF_SCREEN_WIDTH, HALF_SCREEN_HEIGHT, VIEWING_DISTANCE
DEFTYPE.w GL_TRIANGLE_COLOR, MINX, MINY, MAXX, MAXY, MAXINTENSITY
DEFTYPE.l NEAR_Z, FAR_Z
DEFTYPE.f ASPECT_RATIO, AMBIENT_LIGHT, INVERSE_ASPECT_RATIO
DEFTYPE.b CLIP_MODE
DEFTYPE.vector LIGHT_SOURCE, VIEW_POINT
DEFTYPE.dir3d VIEW_ANGLE
DEFTYPE.matrix4x4 GLOBAL_VIEW

Dim List OBJECTS.objectnode(#MAXOBJECTS)
Dim List WORLDPOLYS.facet(#MAXPOLYFRAME)

Dim SINTABLE.f(360)
Dim COSTABLE.f(360)

TOTAL_OBJECTS.w=0
;--------------------------------------------------------------
Statement BuildLookUpTables{}
; Builds all the look up tables
;
  SHARED SINTABLE(), COSTABLE()
  DEFTYPE.l angle
  DEFTYPE.f rad
  For angle=0 To 360
    rad = Pi*angle/180
    COSTABLE(angle)=Cos(rad)
    SINTABLE(angle)=Sin(rad)
  Next angle
End Statement

;--------------------------------------------------------------
.Display3D
Statement Display3D{scrW.l, scrH.l, vdist.l}
; Prepares display for 3d environment
;
  SHARED HALF_SCREEN_WIDTH, HALF_SCREEN_HEIGHT, AMBIENT_LIGHT
  SHARED ASPECT_RATIO, VIEWING_DISTANCE, GL_TRIANGLE_COLOR
  SHARED MINX, MINY, MAXX, MAXY, LIGHT_SOURCE, MAXINTENSITY
  SHARED VIEW_POINT, VIEW_ANGLE, NEAR_Z, FAR_Z, INVERSE_ASPECT_RATIO
  BuildLookUpTables{}
  HALF_SCREEN_WIDTH=scrW/2
  HALF_SCREEN_HEIGHT=scrH/2
  ASPECT_RATIO=1
  VIEWING_DISTANCE=vdist
  MINX=0
  MINY=0
  MAXX=scrW
  MAXY=scrH
  GL_TRIANGLE_COLOR=1
  AMBIENT_LIGHT=6
  LIGHT_SOURCE\x=-0.913913, 0.389759, -0.113369
  ;LIGHT_SOURCE\x=0.918926, 0.248436, -0.306359
  VIEW_POINT\x=0, 0, 0, 10
  VIEW_ANGLE\angx=0, 0, 0
  NEAR_Z=VIEWING_DISTANCE
  FAR_Z=4096
  INVERSE_ASPECT_RATIO=1-ASPECT_RATIO
  CLIP_MODE=#ZPLANE
  MAXINTENSITY=15
End Statement

;--------------------------------------------------------------
.AspectRatio
Statement AspectRatio{ratio.f}
; Sets a new aspect ration for display
;
  SHARED ASPECT_RATIO
  ASPECT_RATIO = ratio
End Statement

;--------------------------------------------------------------
Statement MakeVector3D{*a.vertex, *b.vertex, *result.vector}
; Creates a vector from two points in 3d space.
;
  *result\x = *b\x - *a\x
  *result\y = *b\y - *a\y
  *result\z = *b\z - *a\z
End Statement

;--------------------------------------------------------------
Function.f VectorMag3D{*a.vector}
; Returns a magnitude of a vector.
;
  Function Return Sqr((*a\x)^2+(*a\y)^2+(*a\z)^2)
End Function

;--------------------------------------------------------------
Function.f DotProduct2{*u.vector, *v.vector}
; Returns dot product of two vectors.
;
  Function Return (((*u\x)*(*v\x))+((*u\y)*(*v\y))+((*u\z)*(*v\z)))
End Function

;--------------------------------------------------------------
Statement CrossProduct2{*u.vector, *v.vector, *normal.vector}
;  Returns the cross product of two vectors.
;
  *normal\x =  ((*u\y) * (*v\z) - (*u\z) * (*v\y))
  *normal\y = -((*u\x) * (*v\z) - (*u\z) * (*v\x))
  *normal\z =  ((*u\x) * (*v\y) - (*u\y) * (*v\x))
End Statement

;--------------------------------------------------------------
Statement MatIdentity4x4{*imatrix.matrix4x4}
; Creates a 4x4 identity matrix.
;
  USEPATH *imatrix
  \r0[0]=0:\r0[1]=0:\r0[2]=0:\r0[3]=0
  \r1[0]=0:\r1[1]=0:\r1[2]=0:\r1[3]=0
  \r2[0]=0:\r2[1]=0:\r2[2]=0:\r2[3]=0
  \r3[0]=0:\r3[1]=0:\r3[2]=0:\r3[3]=0

  ;set main diagonal to 1s
  \r0[0]=1:\r1[1]=1:\r2[2]=1:\r3[3]=1
End Statement

;--------------------------------------------------------------
Statement MatZero4x4{*zmatrix.matrix4x4}
; Zeros out a 4x4 matrix.
;
  USEPATH *zmatrix
  \r0[0]=0:\r0[1]=0:\r0[2]=0:\r0[3]=0
  \r1[0]=0:\r1[1]=0:\r1[2]=0:\r1[3]=0
  \r2[0]=0:\r2[1]=0:\r2[2]=0:\r2[3]=0
  \r3[0]=0:\r3[1]=0:\r3[2]=0:\r3[3]=0
End Statement

;--------------------------------------------------------------
Statement MatCopy4x4{*s.matrix4x4, *d.matrix4x4}
; Copies one 4x4 matrix to another 4x4
;
  For i.b=0 To 3
    *d\r0[i] = *s\r0[i]
    *d\r1[i] = *s\r1[i]
    *d\r2[i] = *s\r2[i]
    *d\r3[i] = *s\r3[i]
  Next i
End Statement
;--------------------------------------------------------------
Statement MatPrint4x4{*pmatrix.matrix4x4}
; Prints content of a 4x4 matrix.
;
  Format "-##0.0##"
  For i.b=0 To 3:Print *pmatrix\r0[i],", ":Next i:NPrint ""
  For i.b=0 To 3:Print *pmatrix\r1[i],", ":Next i:NPrint ""
  For i.b=0 To 3:Print *pmatrix\r2[i],", ":Next i:NPrint ""
  For i.b=0 To 3:Print *pmatrix\r3[i],", ":Next i:NPrint ""
End Statement

;--------------------------------------------------------------
Statement MatPrint1x4{*omatrix.matrix1x4}
; Prints out a 1x4 matrix also known as row vector
;
  Format "####.####"
  For i.b=0 To 3
  Print *omatrix\r[i]
  Next i
End Statement

;--------------------------------------------------------------
Statement MatMult4x4{*A.matrix4x4, *B.matrix4x4, *R.matrix4x4}
; Multiplies two 4x4 matrices together
;
  *R\r0[0]=(*A\r0[0]*(*B\r0[0]))+(*A\r0[1]*(*B\r1[0]))+(*A\r0[2]*(*B\r2[0]))+(*A\r0[3]*(*B\r3[0]))
  *R\r0[1]=(*A\r0[0]*(*B\r0[1]))+(*A\r0[1]*(*B\r1[1]))+(*A\r0[2]*(*B\r2[1]))+(*A\r0[3]*(*B\r3[1]))
  *R\r0[2]=(*A\r0[0]*(*B\r0[2]))+(*A\r0[1]*(*B\r1[2]))+(*A\r0[2]*(*B\r2[2]))+(*A\r0[3]*(*B\r3[2]))
  *R\r0[3]=(*A\r0[0]*(*B\r0[3]))+(*A\r0[1]*(*B\r1[3]))+(*A\r0[2]*(*B\r2[3]))+(*A\r0[3]*(*B\r3[3]))

  *R\r1[0]=(*A\r1[0]*(*B\r0[0]))+(*A\r1[1]*(*B\r1[0]))+(*A\r1[2]*(*B\r2[0]))+(*A\r1[3]*(*B\r3[0]))
  *R\r1[1]=(*A\r1[0]*(*B\r0[1]))+(*A\r1[1]*(*B\r1[1]))+(*A\r1[2]*(*B\r2[1]))+(*A\r1[3]*(*B\r3[1]))
  *R\r1[2]=(*A\r1[0]*(*B\r0[2]))+(*A\r1[1]*(*B\r1[2]))+(*A\r1[2]*(*B\r2[2]))+(*A\r1[3]*(*B\r3[2]))
  *R\r1[3]=(*A\r1[0]*(*B\r0[3]))+(*A\r1[1]*(*B\r1[3]))+(*A\r1[2]*(*B\r2[3]))+(*A\r1[3]*(*B\r3[3]))

  *R\r2[0]=(*A\r2[0]*(*B\r0[0]))+(*A\r2[1]*(*B\r1[0]))+(*A\r2[2]*(*B\r2[0]))+(*A\r2[3]*(*B\r3[0]))
  *R\r2[1]=(*A\r2[0]*(*B\r0[1]))+(*A\r2[1]*(*B\r1[1]))+(*A\r2[2]*(*B\r2[1]))+(*A\r2[3]*(*B\r3[1]))
  *R\r2[2]=(*A\r2[0]*(*B\r0[2]))+(*A\r2[1]*(*B\r1[2]))+(*A\r2[2]*(*B\r2[2]))+(*A\r2[3]*(*B\r3[2]))
  *R\r2[3]=(*A\r2[0]*(*B\r0[3]))+(*A\r2[1]*(*B\r1[3]))+(*A\r2[2]*(*B\r2[3]))+(*A\r2[3]*(*B\r3[3]))

  *R\r3[0]=(*A\r3[0]*(*B\r0[0]))+(*A\r3[1]*(*B\r1[0]))+(*A\r3[2]*(*B\r2[0]))+(*A\r3[3]*(*B\r3[0]))
  *R\r3[1]=(*A\r3[0]*(*B\r0[1]))+(*A\r3[1]*(*B\r1[1]))+(*A\r3[2]*(*B\r2[1]))+(*A\r3[3]*(*B\r3[1]))
  *R\r3[2]=(*A\r3[0]*(*B\r0[2]))+(*A\r3[1]*(*B\r1[2]))+(*A\r3[2]*(*B\r2[2]))+(*A\r3[3]*(*B\r3[2]))
  *R\r3[3]=(*A\r3[0]*(*B\r0[3]))+(*A\r3[1]*(*B\r1[3]))+(*A\r3[2]*(*B\r2[3]))+(*A\r3[3]*(*B\r3[3]))
End Statement

;--------------------------------------------------------------
Statement MatMult4x4S{*A.matrix4x4, *B.matrix4x4, *R.matrix4x4}
; Multiplies two 4x4 matrices together
;
  *R\r0[0]=(*A\r0[0]*(*B\r0[0]))+(*A\r0[1]*(*B\r1[0]))+(*A\r0[2]*(*B\r2[0]))
  *R\r0[1]=(*A\r0[0]*(*B\r0[1]))+(*A\r0[1]*(*B\r1[1]))+(*A\r0[2]*(*B\r2[1]))
  *R\r0[2]=(*A\r0[0]*(*B\r0[2]))+(*A\r0[1]*(*B\r1[2]))+(*A\r0[2]*(*B\r2[2]))
  *R\r0[3]=0

  *R\r1[0]=(*A\r1[0]*(*B\r0[0]))+(*A\r1[1]*(*B\r1[0]))+(*A\r1[2]*(*B\r2[0]))
  *R\r1[1]=(*A\r1[0]*(*B\r0[1]))+(*A\r1[1]*(*B\r1[1]))+(*A\r1[2]*(*B\r2[1]))
  *R\r1[2]=(*A\r1[0]*(*B\r0[2]))+(*A\r1[1]*(*B\r1[2]))+(*A\r1[2]*(*B\r2[2]))
  *R\r1[3]=0

  *R\r2[0]=(*A\r2[0]*(*B\r0[0]))+(*A\r2[1]*(*B\r1[0]))+(*A\r2[2]*(*B\r2[0]))
  *R\r2[1]=(*A\r2[0]*(*B\r0[1]))+(*A\r2[1]*(*B\r1[1]))+(*A\r2[2]*(*B\r2[1]))
  *R\r2[2]=(*A\r2[0]*(*B\r0[2]))+(*A\r2[1]*(*B\r1[2]))+(*A\r2[2]*(*B\r2[2]))
  *R\r2[3]=0

  *R\r3[0]=(*A\r3[0]*(*B\r0[0]))+(*A\r3[1]*(*B\r1[0]))+(*A\r3[2]*(*B\r2[0])+*B\r3[0])
  *R\r3[1]=(*A\r3[0]*(*B\r0[1]))+(*A\r3[1]*(*B\r1[1]))+(*A\r3[2]*(*B\r2[1])+*B\r3[1])
  *R\r3[2]=(*A\r3[0]*(*B\r0[2]))+(*A\r3[1]*(*B\r1[2]))+(*A\r3[2]*(*B\r2[2])+*B\r3[2])
  *R\r3[3]=1
End Statement

;--------------------------------------------------------------
Statement MatMult1x4{*A.matrix1x4, *B.matrix4x4, *R.matrix1x4}
; Mutltiplies one 1x4 matrix with 4x4 matrix. Result is 4x4.
; Uses global variables: ..._1x4*..._matrix->..._result
;
  *R\r[0]=(*B\r0[0]*(*A\r[0]))+(*B\r0[1]*(*A\r[1]))+(*B\r0[2]*(*A\r[2]))+(*B\r0[3]*(*A\r[3]))
  *R\r[1]=(*B\r1[0]*(*A\r[0]))+(*B\r1[1]*(*A\r[1]))+(*B\r1[2]*(*A\r[2]))+(*B\r1[3]*(*A\r[3]))
  *R\r[2]=(*B\r2[0]*(*A\r[0]))+(*B\r2[1]*(*A\r[1]))+(*B\r2[2]*(*A\r[2]))+(*B\r2[3]*(*A\r[3]))
  *R\r[3]=(*B\r3[0]*(*A\r[0]))+(*B\r3[1]*(*A\r[1]))+(*B\r3[2]*(*A\r[2]))+(*B\r3[3]*(*A\r[3]))
End Statement

;--------------------------------------------------------------
Function.s PLGGetLine{strline.s}
; Strips comments from a strline string...
; Returns a PLG string line without comments.
;
  DEFTYPE.s string, char
  ctr.b=1
  strline=StripLead$(strline,32)
  char=Mid$(strline,ctr,1)
  While ((char<>"#") AND (char<>";")) AND ctr<=Len(strline)
   ctr+1
   char=Mid$(strline,ctr,1)
  Wend
  string=Left$(strline,ctr-1)
  string=StripTrail$(string,32)
  Function Return string
End Function

;--------------------------------------------------------------
Statement ComputeObjectRadius{}
; Computes maximum radius of an object for colision detection.
; Better method could be finding average radius.
;
  SHARED OBJECTS()
  DEFTYPE.f new_radius, x, y, z
  DEFTYPE.l index
  USEPATH OBJECTS()
  \radius=0
  For index=0 To \numverts
    x=\vlocal[index]\x
    y=\vlocal[index]\y
    z=\vlocal[index]\z
    new_radius=Sqr(x*x + y*y + z*z)
    If (new_radius > \radius) Then \radius=new_radius
  Next index
End Statement

;--------------------------------------------------------------
.PLGLoadObject
Statement PLGLoadObject{filename.s, scalar.f}
; Reads in an object data from a PLG file.
; Uses global variable to store read object.
;
  SHARED TOTAL_OBJECTS, OBJECTS()
  DEFTYPE.w total_vertices, total_polys, num_vertices, color_des
  DEFTYPE.w logical_color, shading, index
  DEFTYPE.w ln, tempword, vertex_0, vertex_1, vertex_2
  DEFTYPE.b tempbyte
  DEFTYPE.f x, y, z
  DEFTYPE.vector u, v, normal
  DEFTYPE.s sbuffer, object_name, tempstr
  ln=0             ;how many actual PLG code lines

If AddItem(OBJECTS())
  USEPATH OBJECTS()
  If ReadFile(0,filename)               ;open file
    FileInput 0
    While NOT(Eof(0))
      sbuffer=PLGGetLine{Edit$(80)}
      If sbuffer<>""                 ;not an empty line?
        ln+1                         ;it is actual PLG line
        If ln=1                      ;must be a header then
          tempbyte=Instr(sbuffer," ")
          \name=Left$(sbuffer,tempbyte-1)
          tempstr=Right$(sbuffer,Len(sbuffer)-tempbyte)
          tempbyte=Instr(tempstr," ")
          total_vertices=Val(Left$(tempstr,tempbyte-1))
          total_polys=Val(Right$(tempstr,Len(tempstr)-tempbyte))
          \numverts=total_vertices
          \numpolys=total_polys
          \state=1
          \worldpos\x=0
          \worldpos\y=0
          \worldpos\z=0
          TOTAL_OBJECTS+1
          \id=TOTAL_OBJECTS
        Else
          ;list of vertices follow now
          ;ln=2 through ln+total_vertices
          If (ln>=2) AND (ln<=total_vertices+1)
          ;vertex line dissected here

              sbuffer=StripLead$(sbuffer,32)
              tempbyte=Instr(sbuffer," ")
              x=Val(Left$(sbuffer,tempbyte-1))
              sbuffer=UnRight$(sbuffer,tempbyte)

              sbuffer=StripLead$(sbuffer,32)
              tempbyte=Instr(sbuffer," ")
              y=Val(Left$(sbuffer,tempbyte-1))
              sbuffer=UnRight$(sbuffer,tempbyte)

              sbuffer=StripLead$(sbuffer,32)
              tempbyte=Instr(sbuffer," ")
              If tempbyte=0 Then tempbyte=Len(sbuffer)
              z=Val(Left$(sbuffer,tempbyte))

            \vlocal[ln-2]\x=x * scalar
            \vlocal[ln-2]\y=y * scalar
            \vlocal[ln-2]\z=z * scalar
          Else
            If ln>=total_vertices+2 AND ln<=(total_polys+total_vertices+1)
            ;polygon lines dissected here
            tempbyte=Instr(sbuffer," ")
            ;recognize if color is in decimal or hex form
            If Left$(sbuffer,2)="0x" OR Left$(sbuffer,2)="0X" OR Left$(sbuffer,1)="$"
            ;hex handling not implemeted

            Else
            ;dec
              color_des=Val(Left$(sbuffer,tempbyte-1))
              sbuffer=UnRight$(sbuffer,tempbyte)
              sbuffer=StripLead$(sbuffer,32)
            EndIf
            tempword=total_vertices+2
            num_vertices=Val(Left$(sbuffer,Instr(sbuffer," ")-1))
            index.w=ln-tempword
            \polys[index]\numpoints=num_vertices
            \polys[index]\shading  =color_des LSR 13
            \polys[index]\twosided =color_des LSR 12
            \polys[index]\color    =color_des BitClr 12
            \polys[index]\visible  =1
            \polys[index]\clipped  =0
            \polys[index]\active   =1
            ;extract number of vertices...
            sbuffer=UnRight$(sbuffer,Instr(sbuffer," "))
            sbuffer=StripLead$(sbuffer,32)
            ;...and read vertices into an object structure
            For i=1 To num_vertices-1
              k.w=Instr(sbuffer," ")
              If Len(sbuffer)=1 Then k=2
              t.w=Val(Left$(sbuffer,k-1))
              sbuffer=UnRight$(sbuffer,k)
              sbuffer=StripLead$(sbuffer,32)
              \polys[index]\vertexlist[i-1]=t
            Next
            \polys[index]\vertexlist[num_vertices-1]=Val(sbuffer)

            ;precompute normals, etc...
            vertex_0=\polys[index]\vertexlist[0]
            vertex_1=\polys[index]\vertexlist[1]
            vertex_2=\polys[index]\vertexlist[2]

            v0.vertex\x=\vlocal[vertex_0]\x, \vlocal[vertex_0]\y, \vlocal[vertex_0]\z
            v1.vertex\x=\vlocal[vertex_1]\x, \vlocal[vertex_1]\y, \vlocal[vertex_1]\z
            v2.vertex\x=\vlocal[vertex_2]\x, \vlocal[vertex_2]\y, \vlocal[vertex_2]\z

            MakeVector3D{v0, v1, u}
            MakeVector3D{v0, v2, v}

            CrossProduct2{u, v, normal}
            \polys[index]\normallength=VectorMag3D{normal}
            EndIf
          EndIf
        EndIf
      EndIf
      FileSeek 0,Loc(0) ;advance to the next line in PLG file
    Wend
    CloseFile 0
    ComputeObjectRadius{}
  EndIf
EndIf
End Statement

;--------------------------------------------------------------
.ObjectPrint
Statement ObjectPrint{}
; Prints out content of an object structure to default output
;
  SHARED OBJECTS()
  USEPATH OBJECTS()
  NPrint "ID: ",\id:NPrint "Name: ",\name
  NPrint "Number of vertices: ",\numverts
  NPrint "Number of polygons: ",\numpolys
  NPrint "State: ",\state
  NPrint "World Position: X=",\worldpos\x
  NPrint "                Y=",\worldpos\y
  NPrint "                Z=",\worldpos\z
  NPrint "Object's radius: ",\radius
  NPrint "Local Vertices:"
  Format "-###.0#####"
  For k=0 To \numverts-1
    NPrint \vlocal[k]\x," ",\vlocal[k]\y," ",\vlocal[k]\z
  Next
  NPrint "Global Vertices:"
  For k=0 To \numverts-1
    NPrint \vglobal[k]\x," ",\vglobal[k]\y," ",\vglobal[k]\z
  Next
  NPrint "Camera Vertices:"
  For k=0 To \numverts-1
    NPrint \vcamera[k]\x," ",\vcamera[k]\y," ",\vcamera[k]\z
  Next
  Format ""
  NPrint "":NPrint "Polygons list:":NPrint ""
  For i=0 To \numpolys-1
  NPrint "Polygon",i,": "
  For j=0 To \polys[i]\numpoints-1
    Print \polys[i]\vertexlist[j]," "
  Next
  Print " color:",\polys[i]\color," shade:",\polys[i]\shade," shading:",\polys[i]\shading," 2-sided:",\polys[i]\twosided
  NPrint " visible:",\polys[i]\visible," clipped:",\polys[i]\clipped," active:",\polys[i]\active
  NPrint "This polys Normal length=",\polys[i]\normallength
  NPrint ""
  Next
End Statement

;--------------------------------------------------------------
.TranslateObject
Statement TranslateObject{dx.l, dy.l, dz.l}
; Translates an object relative to its own local coordinates
;
  SHARED OBJECTS()
  USEPATH OBJECTS()
  \worldpos\x+dx
  \worldpos\y+dy
  \worldpos\z+dz
End Statement

;--------------------------------------------------------------
.PositionObject
Statement PositionObject{x.l, y.l, z.l}
; Position an object in the 3d world
;
  SHARED OBJECTS()
  USEPATH OBJECTS()
  \worldpos\x=x
  \worldpos\y=y
  \worldpos\z=z
End Statement

;--------------------------------------------------------------
.ScaleObject
Statement ScaleObject{scale_factor.f}
; Scales an object by a factor relative to local coordinates.
;
  SHARED OBJECTS()
  DEFTYPE.l curr_poly, curr_vertex
  DEFTYPE.f scale_2
  USEPATH OBJECTS()

  For curr_vertex=0 To \numverts
    \vlocal[curr_vertex]\x * scale_factor
    \vlocal[curr_vertex]\y * scale_factor
    \vlocal[curr_vertex]\z * scale_factor
  Next curr_vertex

  scale_2 = scale_factor^2
  For curr_poly=0 To \numpolys
    \polys[curr_poly]\normallength * scale_2
  Next curr_poly

  \radius * scale_factor
End Statement

;--------------------------------------------------------------
.RotateObject
Statement RotateObject{angle_x.w, angle_y.w, pad.l, angle_z.w}
; Rotates an object around its local coordinate system,
; allowing simultaneous rotations.
;
  SHARED SINTABLE(), COSTABLE(), OBJECTS()
  DEFTYPE.l i, product
  DEFTYPE.matrix4x4 rotate_x, rotate_y, rotate_z, rot, temp
  DEFTYPE.f temp_x, temp_y, temp_z

  ;check if need to rotate at all
  If angle_x=0 AND angle_y=0 AND angle_z=0 Then Statement Return

  USEPATH OBJECTS()
  product=0

  ;create identity matrix
  MatIdentity4x4{rot}

  If (angle_x<>0) Then product+4
  If (angle_y<>0) Then product+2
  If (angle_z<>0) Then product+1

  Select product
    Case 1
      rot\r0[0]= ( COSTABLE(angle_z))
      rot\r0[1]= ( SINTABLE(angle_z))
      rot\r1[0]= (-SINTABLE(angle_z))
      rot\r1[1]= ( COSTABLE(angle_z))
      For i=0 To \numverts
        temp_x=\vlocal[i]\x*rot\r0[0]+\vlocal[i]\y*rot\r1[0]
        temp_y=\vlocal[i]\x*rot\r0[1]+\vlocal[i]\y*rot\r1[1]
        temp_z=\vlocal[i]\z
        \vlocal[i]\x=temp_x
        \vlocal[i]\y=temp_y
        \vlocal[i]\z=temp_z
      Next i
    Case 2
      rot\r0[0]= ( COSTABLE(angle_y))
      rot\r0[2]= (-SINTABLE(angle_y))
      rot\r2[0]= ( SINTABLE(angle_y))
      rot\r2[2]= ( COSTABLE(angle_y))
      For i=0 To \numverts
        temp_x=\vlocal[i]\x*rot\r0[0]+\vlocal[i]\z*rot\r2[0]
        temp_y=\vlocal[i]\y
        temp_z=\vlocal[i]\x*rot\r0[2]+\vlocal[i]\z*rot\r2[2]
        \vlocal[i]\x=temp_x
        \vlocal[i]\y=temp_y
        \vlocal[i]\z=temp_z
      Next i
    Case 3
      rot\r0[0]= COSTABLE(angle_y)*COSTABLE(angle_z)
      rot\r0[1]= COSTABLE(angle_y)*SINTABLE(angle_z)
      rot\r0[2]=-SINTABLE(angle_y)
      rot\r1[0]=-SINTABLE(angle_z)
      rot\r1[1]= COSTABLE(angle_z)
      rot\r2[0]= SINTABLE(angle_y)*COSTABLE(angle_z)
      rot\r2[1]= SINTABLE(angle_y)*SINTABLE(angle_z)
      rot\r2[2]= COSTABLE(angle_y)
      For i=0 To \numverts
        temp_x=\vlocal[i]\x*rot\r0[0] + \vlocal[i]\y*rot\r1[0] + \vlocal[i]\z*rot\r2[0]
        temp_y=\vlocal[i]\x*rot\r0[1] + \vlocal[i]\y*rot\r1[1] + \vlocal[i]\z*rot\r2[1]
        temp_z=\vlocal[i]\x*rot\r0[2] + \vlocal[i]\z*rot\r2[2]
        \vlocal[i]\x=temp_x
        \vlocal[i]\y=temp_y
        \vlocal[i]\z=temp_z
      Next i
    Case 4
      rot\r1[1]= ( COSTABLE(angle_x))
      rot\r1[2]= ( SINTABLE(angle_x))
      rot\r2[1]= (-SINTABLE(angle_x))
      rot\r2[2]= ( COSTABLE(angle_x))
      For i=0 To \numverts
        temp_x=\vlocal[i]\x
        temp_y=\vlocal[i]\y*rot\r1[1] + \vlocal[i]\z*rot\r2[1]
        temp_z=\vlocal[i]\y*rot\r1[2] + \vlocal[i]\z*rot\r2[2]
        \vlocal[i]\x=temp_x
        \vlocal[i]\y=temp_y
        \vlocal[i]\z=temp_z
      Next i
    Case 5
      rot\r0[0]= COSTABLE(angle_z)
      rot\r0[1]= SINTABLE(angle_z)
      rot\r1[0]=-COSTABLE(angle_x)*SINTABLE(angle_z)
      rot\r1[1]= COSTABLE(angle_x)*COSTABLE(angle_z)
      rot\r1[2]= SINTABLE(angle_x)
      rot\r2[0]= SINTABLE(angle_x)*SINTABLE(angle_z)
      rot\r2[1]=-SINTABLE(angle_x)*COSTABLE(angle_z)
      rot\r2[2]= COSTABLE(angle_x)
      For i=0 To \numverts
        temp_x=\vlocal[i]\x*rot\r0[0] + \vlocal[i]\y*rot\r1[0] + \vlocal[i]\z*rot\r2[0]
        temp_y=\vlocal[i]\x*rot\r0[1] + \vlocal[i]\y*rot\r1[1] + \vlocal[i]\z*rot\r2[1]
        temp_z=\vlocal[i]\y*rot\r1[2] + \vlocal[i]\z*rot\r2[2]

        \vlocal[i]\x=temp_x
        \vlocal[i]\y=temp_y
        \vlocal[i]\z=temp_z
      Next i
    Case 6
      rot\r0[0]= COSTABLE(angle_y)
      rot\r0[2]=-SINTABLE(angle_y)

      rot\r1[0]= SINTABLE(angle_x)*SINTABLE(angle_y)
      rot\r1[1]= COSTABLE(angle_x)
      rot\r1[2]= SINTABLE(angle_x)*COSTABLE(angle_y)

      rot\r2[0]= COSTABLE(angle_x)*SINTABLE(angle_y)
      rot\r2[1]=-SINTABLE(angle_x)
      rot\r2[2]= COSTABLE(angle_x)*COSTABLE(angle_y)

      For i=0 To \numverts
        temp_x=\vlocal[i]\x*rot\r0[0] + \vlocal[i]\y*rot\r1[0] + \vlocal[i]\z*rot\r2[0]
        temp_y=\vlocal[i]\y*rot\r1[1] + \vlocal[i]\z*rot\r2[1]
        temp_z=\vlocal[i]\x*rot\r0[2] + \vlocal[i]\y*rot\r1[2] + \vlocal[i]\z*rot\r2[2]
        \vlocal[i]\x=temp_x
        \vlocal[i]\y=temp_y
        \vlocal[i]\z=temp_z
      Next i
    Case 7
      MatIdentity4x4{rotate_x}
      rotate_x\r1[1]= ( COSTABLE(angle_x))
      rotate_x\r1[2]= ( SINTABLE(angle_x))
      rotate_x\r2[1]= (-SINTABLE(angle_x))
      rotate_x\r2[2]= ( COSTABLE(angle_x))
      MatIdentity4x4{rotate_y}
      rotate_y\r0[0]= ( COSTABLE(angle_y))
      rotate_y\r0[2]= (-SINTABLE(angle_y))
      rotate_y\r2[0]= ( SINTABLE(angle_y))
      rotate_y\r2[2]= ( COSTABLE(angle_y))
      MatIdentity4x4{rotate_z}
      rotate_z\r0[0]= ( COSTABLE(angle_z))
      rotate_z\r0[1]= ( SINTABLE(angle_z))
      rotate_z\r1[0]= (-SINTABLE(angle_z))
      rotate_z\r1[1]= ( COSTABLE(angle_z))
      MatMult4x4S{rotate_x, rotate_y, temp}
      MatMult4x4S{temp, rotate_z, rot}
      For i=0 To \numverts
        temp_x=\vlocal[i]\x*rot\r0[0] + \vlocal[i]\y*rot\r1[0] + \vlocal[i]\z*rot\r2[0]
        temp_y=\vlocal[i]\x*rot\r0[1] + \vlocal[i]\y*rot\r1[1] + \vlocal[i]\z*rot\r2[1]
        temp_z=\vlocal[i]\x*rot\r0[2] + \vlocal[i]\y*rot\r1[2] + \vlocal[i]\z*rot\r2[2]
        \vlocal[i]\x=temp_x
        \vlocal[i]\y=temp_y
        \vlocal[i]\z=temp_z
      Next i
  End Select
  ;
  ; multiply each point in an object by transformation matrix
  ; should not be necessary to multiply each point, just one
  ; and apply (dx,dy,dz) to all the rest!!!
  ;
End Statement

;--------------------------------------------------------------
;--------------------------------------------------------------
Statement DrawTopTriangle{*r1.pixel, *r2.pixel, *r3.pixel, col.w}
; Draws a triangle that has a flat top
;
  DEFTYPE.f dx_right, dx_left, xs, xe, height
  DEFTYPE.l temp_y, right, left, x1, y1, x2, y2, x3, y3
  SHARED MINY, MAXY, MINX,  MAXX

  x1=*r1\x : y1=*r1\y : x2=*r2\x : y2=*r2\y : x3=*r3\x : y3=*r3\y

  ;test order of x1 and x2
  If x2<x1 Then Exchange x1,x2

  height   =  y3-y1

  dx_left  = (x3-x1)/height
  dx_right = (x3-x2)/height

  ;set starting point
  xs=x1
  xe=x2+0.5

  ;perform y clipping
  If y1<MINY
    xs=xs+dx_left*(-y1+MINY)
    xe=xe+dx_right*(-y1+MINY)
    y1=MINY
  EndIf

  If y3>MAXY Then y3=MAXY

  If (x1>=MINX AND x1<=MAXX AND x2>=MINX AND x2<=MAXX AND x3>=MINX AND x3<=MAXX)
  ;draw the triangle
    For temp_y=y1 To y3
      Line xs, temp_y, xe, temp_y, col
      xs+dx_left
      xe+dx_right
    Next temp_y
  Else
  ;clipping needed
    For temp_y=y1 To y3
      left=xs
      right=xe
      xs+dx_left
      xe+dx_right
      If left<MINX
        left=MINX
        If right<MINX
          Pop If: Goto continue1
        EndIf
      EndIf
      If right>MAXX
        right=MAXX
        If left>MAXX
          Pop If: Goto continue1
        EndIf
      EndIf
      Line left, temp_y, right, temp_y, col
    continue1:
    Next temp_y
  EndIf
End Statement

;--------------------------------------------------------------
Statement DrawBottomTriangle{*s1.pixel, *s2.pixel, *s3.pixel, c.w}
; Draws a triangle with flat bottom
;
  DEFTYPE.f dx_left, dx_right, xs, xe, height
  DEFTYPE.l temp_x, temp_y, right, left, x1, y1, x2, y2, x3, y3
  SHARED MINY, MAXY, MINX, MAXX

  x1=*s1\x:y1=*s1\y:x2=*s2\x:y2=*s2\y:x3=*s3\x:y3=*s3\y

  If x3<x2 Then Exchange x3,x2

  height  = y3-y1
  dx_left = (x2-x1)/height
  dx_right= (x3-x1)/height

  xs=x1
  xe=x1+0.5

  If y1<MINY
    xs=xs+dx_left*(-y1+MINY)
    xe=xe+dx_right*(-y1+MINY)
    y1=MINY
  EndIf

  If y3>MAXY Then y3=MAXY

   If (x1>=MINX AND x1<=MAXX AND x2>=MINX AND x2<=MAXX AND x3>=MINX AND x3<=MAXX)
   ;draw triangle
     For temp_y=y1 To y3
      Line xs, temp_y, xe, temp_y, c
      xs+dx_left
      xe+dx_right
     Next temp_y
   Else
   ;clipping needed
    For temp_y=y1 To y3
      left=xs
      right=xe
      xs+dx_left
      xe+dx_right
      If left<MINX
        left=MINX
        If right<MINX
          Pop If: Goto continue3
        EndIf
      EndIf
      If right>MAXX
        right=MAXX
        If left>MAXX
          Pop If: Goto continue3
        EndIf
      EndIf
      Line left, temp_y, right, temp_y, c
    continue3:
    Next temp_y
   EndIf
End Statement

;--------------------------------------------------------------
Statement SetTriangleColor{c.w}
; Sets a color for use by DrawTriangle2D function because
; parameters passed to that function get corrupted: BB2 bug.
;
  SHARED GL_TRIANGLE_COLOR
  GL_TRIANGLE_COLOR=c
End Statement

;--------------------------------------------------------------
.DrawTriangle2D
Statement DrawTriangle2D{*p1.pixel,*p2.pixel,colordummy.l,*p3.pixel}
; Draws a triangle on a screen
;
  DEFTYPE.w x1, y1, x2, y2, x3, y3, color
  DEFTYPE.l temp_x, temp_y, new_x, miny, maxy, minx, maxx
  DEFTYPE.pixel q1, q2, q3
  SHARED MINX, MINY, MAXX, MAXY, GL_TRIANGLE_COLOR

  x1=*p1\x: y1=*p1\y: x2=*p2\x: y2=*p2\y: x3=*p3\x: y3=*p3\y

  color=GL_TRIANGLE_COLOR

  ;test for h lines and v lines
  If ((x1=x2 AND x2=x3) OR (y1=y2 AND y2=y3)) Then Statement Return

  ;sort p1, p2 and p3 in ascending y order
  If y2<y1
    temp_x=x2
    temp_y=y2
    x2=x1
    y2=y1
    x1=temp_x
    y1=temp_y
  EndIf
  If y3<y1
    temp_x=x3
    temp_y=y3
    x3=x1
    y3=y1
    x1=temp_x
    y1=temp_y
  EndIf
  If y3<y2
    temp_x=x3
    temp_y=y3
    x3=x2
    y3=y2
    x2=temp_x
    y2=temp_y
  EndIf

;do trivial rejection test
If (y3<MINY OR y1>MAXY OR (x1<MINX AND x2<MINX AND x3<MINX) OR (x1>MAXX AND x2>MAXX AND x3>MAXX)) Then Statement Return

q1\x = x1, y1
q2\x = x2, y2
q3\x = x3, y3

;is top of triangle flat?
If (y1=y2)
  DrawTopTriangle{q1, q2, q3, color}
Else
  If (y2=y3)
    DrawBottomTriangle{q1, q2, q3, color}
  Else
    new_x=x1+((y2-y1)*(x3-x1))/(y3-y1)
    newq2.pixel\x=new_x,y2
    DrawBottomTriangle{q1,newq2,q2,color}
    DrawTopTriangle{q2,newq2,q3,color}
  EndIf
EndIf
End Statement

;--------------------------------------------------------------
.ClipMode
Statement ClipMode{mode.b}
; Sets a particular mode for clipping
;
  SHARED CLIP_MODE
  CLIP_MODE=mode
  If (CLIP_MODE<>#FRUSTUM) OR (CLIP_MODE<>#ZPLANE) Then CLIP_MODE=#ZPLANE
End Statement

;--------------------------------------------------------------
;--------------------------------------------------------------
;--------------------------------------------------------------
;--------------------------------------------------------------
;--------------------------------------------------------------
;--------------------------------------------------------------
;--------------------------------------------------------------
;--------------------------------------------------------------
.ShowObjectWire
Statement ShowObjectWire{coloroffset.w}
; Draws a currrent object as a wireframe and clips it to
; a near clipping plane (VIEWING DISTANCE)
;
  SHARED VIEWING_DISTANCE, HALF_SCREEN_HEIGHT, HALF_SCREEN_WIDTH
  SHARED ASPECT_RATIO, OBJECTS()
  DEFTYPE.f x1,y1,z1,x2,y2,z2,u,xi,yi
  DEFTYPE.l curr_poly, curr_vertex, vert
  USEPATH OBJECTS()

  For curr_poly=0 To \numpolys
    For vert=0 To \polys[curr_poly]\numpoints-1
      curr_vertex=\polys[curr_poly]\vertexlist[vert]
      x1=\vcamera[curr_vertex]\x
      y1=\vcamera[curr_vertex]\y
      z1=\vcamera[curr_vertex]\z
      temp=vert
      temp+1
      If temp>=\polys[curr_poly]\numpoints Then temp=0
      curr_vertex=\polys[curr_poly]\vertexlist[temp]
      x2=\vcamera[curr_vertex]\x
      y2=\vcamera[curr_vertex]\y
      z2=\vcamera[curr_vertex]\z

      If z2<VIEWING_DISTANCE AND z1<VIEWING_DISTANCE
      ;both endpoints below \d
        Goto skip
      EndIf
      If z2>=VIEWING_DISTANCE AND z1>=VIEWING_DISTANCE
      ;both endpoints above \d
        Goto project
      EndIf

      ;clip a line
      If z1<VIEWING_DISTANCE AND z2>=VIEWING_DISTANCE
        u=(VIEWING_DISTANCE-z1)/(z2-z1)
        x1=x1+(x2-x1)*u
        y1=y1+(y2-y1)*u
        z1=VIEWING_DISTANCE

      Else
        If z2<VIEWING_DISTANCE AND z1>=VIEWING_DISTANCE
          Exchange x2,x1
          Exchange y2,y1
          Exchange z2,z1
          u=(VIEWING_DISTANCE-z1)/(z2-z1)
          x1=x1+(x2-x1)*u
          y1=y1+(y2-y1)*u
          z1=VIEWING_DISTANCE
        EndIf
      EndIf

    project:
      mult1.l=z1-VIEWING_DISTANCE:If mult1=0 Then mult1=1
      mult2.l=z2-VIEWING_DISTANCE:If mult2=0 Then mult2=1
      x1=((x1*VIEWING_DISTANCE)/mult1)+HALF_SCREEN_WIDTH
      y1=HALF_SCREEN_HEIGHT-ASPECT_RATIO*((y1*VIEWING_DISTANCE)/mult1)
      x2=((x2*VIEWING_DISTANCE)/mult2)+HALF_SCREEN_WIDTH
      y2=HALF_SCREEN_HEIGHT-ASPECT_RATIO*((y2*VIEWING_DISTANCE)/mult2)
      Line x1,y1,x2,y2,\polys[curr_poly]\color+coloroffset
    skip:
    Next vert
  Next curr_poly
End Statement

;--------------------------------------------------------------
.TouchPalette
Statement TouchPalette{fr.w, lr.w, *init_color.rgbtype, *last_color.rgbtype}
; Creates (and alters into) a 16 color palette registers with
; initial color r,g,b values
;
  SHARED MAXINTENSITY
  t.w=lr-fr+1
  MAXINTENSITY=lr-fr
  Dim temp_red.w(t)
  Dim temp_green.w(t)
  Dim temp_blue.w(t)
  DEFTYPE.w i
  fc=*init_color\r
  lc=*last_color\r
  For i=fr To lr
    temp_red(i-fr)=(fc*(lr-i)+lc*i)/lr
  Next i
  fc=*init_color\g
  lc=*last_color\g
  For i=fr To lr
    temp_green(i-fr)=(fc*(lr-i)+lc*i)/lr
  Next i
  fc=*init_color\b
  lc=*last_color\b
  For i=fr To lr
    temp_blue(i-fr)=(fc*(lr-i)+lc*i)/lr
  Next i
  For i=fr To lr
    RGB i, temp_red(i-fr), temp_green(i-fr), temp_blue(i-fr)
  Next i
End Statement

;--------------------------------------------------------------
.RemoveBackfacesAndShade
Statement RemoveBackfacesAndShade{}
; Removes backfaces of currently used object and computes
; the flat shading of the object
;
  SHARED OBJECTS(), AMBIENT_LIGHT, LIGHT_SOURCE, VIEW_POINT, MAXINTENSITY
  DEFTYPE.l vertex_0, vertex_1, vertex_2, curr_poly
  DEFTYPE.f dp, intensity
  DEFTYPE.vector u, v, normal, sight

  USEPATH OBJECTS()

  For curr_poly=0 To \numpolys
    If \polys[curr_poly]\twosided=0

        vertex_0 = \polys[curr_poly]\vertexlist[0]
        vertex_1 = \polys[curr_poly]\vertexlist[1]
        vertex_2 = \polys[curr_poly]\vertexlist[2]

        v0.vertex\x=\vglobal[vertex_0]\x, \vglobal[vertex_0]\y, \vglobal[vertex_0]\z
        v1.vertex\x=\vglobal[vertex_1]\x, \vglobal[vertex_1]\y, \vglobal[vertex_1]\z
        v2.vertex\x=\vglobal[vertex_2]\x, \vglobal[vertex_2]\y, \vglobal[vertex_2]\z

        MakeVector3D{v0, v1, u}
        MakeVector3D{v0, v2, v}
        CrossProduct2{u, v, normal}

        sight\x = VIEW_POINT\x - \vglobal[vertex_0]\x
        sight\y = VIEW_POINT\y - \vglobal[vertex_0]\y
        sight\z = VIEW_POINT\z - \vglobal[vertex_0]\z

        dp = DotProduct2{normal, sight}
        If dp>0
          \polys[curr_poly]\visible=1

          If \polys[curr_poly]\shading=#FLAT
            dp=DotProduct2{normal, LIGHT_SOURCE}

            If dp>0
              intensity=AMBIENT_LIGHT+(MAXINTENSITY*dp/(\polys[curr_poly]\normallength))

              If intensity>MAXINTENSITY Then intensity=MAXINTENSITY
              ;intensity is now anywhere between 0 and 1
              ;use this value to find index of shade
              \polys[curr_poly]\shade=\polys[curr_poly]\color+intensity

            Else
            \polys[curr_poly]\shade=\polys[curr_poly]\color+AMBIENT_LIGHT

            EndIf
          Else
            ;different type of shading than flat, constant assumed
            ;!!!!
            \polys[curr_poly]\shade=\polys[curr_poly]\color

          EndIf
        Else
      \polys[curr_poly]\visible=0
      EndIf
    Else
      ;polygon is two sided
      \polys[curr_poly]\visible=1
      If \polys[curr_poly]\shading=#FLAT
        vertex_0 = \polys[curr_poly]\vertexlist[0]
        vertex_1 = \polys[curr_poly]\vertexlist[1]
        vertex_2 = \polys[curr_poly]\vertexlist[2]

        v0.vertex\x=\vglobal[vertex_0]\x, \vglobal[vertex_0]\y, \vglobal[vertex_0]\z
        v1.vertex\x=\vglobal[vertex_1]\x, \vglobal[vertex_1]\y, \vglobal[vertex_1]\z
        v2.vertex\x=\vglobal[vertex_2]\x, \vglobal[vertex_2]\y, \vglobal[vertex_2]\z

        MakeVector3D{v1, v0, u}
        MakeVector3D{v1, v3, v}
        CrossProduct2{u, v, normal}
        dp=DotProduct2{normal, LIGHT_SOURCE}
        If dp>0
          intensity=AMBIENT_LIGHT+(15*dp/(\polys[curr_poly]\normallength))
          If intensity>15 Then intensity=15
          \polys[curr_poly]\shade=\polys[curr_poly]\color+intensity
        Else
          \polys[curr_poly]\shade=\polys[curr_poly]\color-AMBIENT_LIGHT
        EndIf
      Else
        ;different shading options here
        ;constant shading assumed
        \polys[curr_poly]\shade=\polys[curr_poly]\color
      EndIf
    EndIf
  Next curr_poly
End Statement

;--------------------------------------------------------------
.DrawObjectSolid
Statement DrawObjectSolid{}
; Draws a solid, shaded currently used object
;
  SHARED OBJECTS(), ASPECT_RATIO, VIEWING_DISTANCE
  SHARED HALF_SCREEN_WIDTH, HALF_SCREEN_HEIGHT, NEAR_Z, FAR_Z
  DEFTYPE.l curr_poly, vertex_1, vertex_2, vertex_3, vertex_4, is_quad
  is_quad=0
  DEFTYPE.f x1,y1,z1, x2,y2,z2, x3,y3,z3, x4,y4,z4
  DEFTYPE.polytemp p
  USEPATH OBJECTS()

  For curr_poly=0 To \numpolys-1

    ;is this polygon visible?
    If \polys[curr_poly]\visible=0 OR \polys[curr_poly]\clipped=1 Then Goto continue

    ;extract vertex numbers
    vertex_1=\polys[curr_poly]\vertexlist[0]
    vertex_2=\polys[curr_poly]\vertexlist[1]
    vertex_3=\polys[curr_poly]\vertexlist[2]

    ;do Z clipping first before projection
    z1=\vcamera[vertex_1]\z
    z2=\vcamera[vertex_2]\z
    z3=\vcamera[vertex_3]\z

    ;test if this is a quad
    If \polys[curr_poly]\numpoints=4
      vertex_4=\polys[curr_poly]\vertexlist[3]
      z4=\vcamera[vertex_4]\z
      is_quad=1
    Else
      z4=z3
    EndIf

    If (z1<NEAR_Z AND z2<NEAR_Z AND z3<NEAR_Z AND z4<NEAR_Z) OR (z1>FAR_Z AND z2>FAR_Z AND z3>FAR_Z AND z4>FAR_Z)
      Goto continue
    EndIf

    x1 = \vcamera[vertex_1]\x
    y1 = \vcamera[vertex_1]\y

    x2 = \vcamera[vertex_2]\x
    y2 = \vcamera[vertex_2]\y

    x3 = \vcamera[vertex_3]\x
    y3 = \vcamera[vertex_3]\y

    x1=(HALF_SCREEN_WIDTH+x1*VIEWING_DISTANCE/z1)
    y1=(HALF_SCREEN_HEIGHT-ASPECT_RATIO*y1*VIEWING_DISTANCE/z1)

    x2=(HALF_SCREEN_WIDTH+x2*VIEWING_DISTANCE/z2)
    y2=(HALF_SCREEN_HEIGHT-ASPECT_RATIO*y2*VIEWING_DISTANCE/z2)

    x3=(HALF_SCREEN_WIDTH+x3*VIEWING_DISTANCE/z3)
    y3=(HALF_SCREEN_HEIGHT-ASPECT_RATIO*y3*VIEWING_DISTANCE/z3)

    p\x1=x1,y1,x2,y2,x3,y3
    Polyf 3,p,\polys[curr_poly]\shade

    ;draw second poly if this is a quad
    If is_quad
      ;extract the extra point
        x4 = \vcamera[vertex_4]\x
        y4 = \vcamera[vertex_4]\y
      ;project to screen
        x4=(HALF_SCREEN_WIDTH+x4*VIEWING_DISTANCE/z4)
        y4=(HALF_SCREEN_HEIGHT-ASPECT_RATIO*y4*VIEWING_DISTANCE/z4)
      ;draw second triangle
      p\x4=x4,y4
      Polyf 4,p,\polys[curr_poly]\shade
    EndIf
  continue:
  Next curr_poly

End Statement

;--------------------------------------------------------------
.LocalToWorld
Statement LocalToWorld{}
; Translates current object's local coordinates to world
; coordinates (global)
;
  SHARED OBJECTS()
  USEPATH OBJECTS()
  For index.w=0 To \numverts
    \vglobal[index]\x = \vlocal[index]\x + \worldpos\x
    \vglobal[index]\y = \vlocal[index]\y + \worldpos\y
    \vglobal[index]\z = \vlocal[index]\z + \worldpos\z
  Next index
  ;reset visibility flags
  For index=0 To \numpolys
    \polys[index]\visible=1
    \polys[index]\clipped=0
  Next index
End Statement

;--------------------------------------------------------------
.WorldToCamera
Statement WorldToCamera{}
; Converts current object's world coordinates to camera
; coordinates.
;
  SHARED GLOBAL_VIEW, OBJECTS(), VIEW_ANGLE
  DEFTYPE.w index, active_axes
  DEFTYPE.matrix4x4 GV
  active_axes=0
  USEPATH OBJECTS()

  If (VIEW_ANGLE\angx) Then active_axes+1
  If (VIEW_ANGLE\angy) Then active_axes+2
  If (VIEW_ANGLE\angz) Then active_axes+4

  Select active_axes
    Case 0
      For index=0 To \numverts
        \vcamera[index]\x=\vglobal[index]\x+GLOBAL_VIEW\r3[0]
        \vcamera[index]\y=\vglobal[index]\y+GLOBAL_VIEW\r3[1]
        \vcamera[index]\z=\vglobal[index]\z+GLOBAL_VIEW\r3[2]
      Next index
    Case 1
      For index=0 To \numverts
        \vcamera[index]\x=\vglobal[index]\x+GLOBAL_VIEW\r3[0]
        \vcamera[index]\y=\vglobal[index]\y*GLOBAL_VIEW\r1[1]+\vglobal[index]\z*GLOBAL_VIEW\r2[1]+GLOBAL_VIEW\r3[1]
        \vcamera[index]\z=\vglobal[index]\y*GLOBAL_VIEW\r1[2]+\vglobal[index]\z*GLOBAL_VIEW\r2[2]+GLOBAL_VIEW\r3[2]
      Next index
    Case 2
      For index=0 To \numverts
        \vcamera[index]\x=\vglobal[index]\x*GLOBAL_VIEW\r0[0]+\vglobal[index]\z*GLOBAL_VIEW\r2[0]+GLOBAL_VIEW\r3[0]
        \vcamera[index]\y=\vglobal[index]\y+GLOBAL_VIEW\r3[1]
        \vcamera[index]\z=\vglobal[index]\x*GLOBAL_VIEW\r0[2]+\vglobal[index]\z*GLOBAL_VIEW\r2[2]+GLOBAL_VIEW\r3[2]
      Next index
    Case 4
      For index=0 To \numverts
        \vcamera[index]\x=\vglobal[index]\x*GLOBAL_VIEW\r0[0]+\vglobal[index]\y*GLOBAL_VIEW\r1[0]+GLOBAL_VIEW\r3[0]
        \vcamera[index]\y=\vglobal[index]\x*GLOBAL_VIEW\r0[1]+\vglobal[index]\y*GLOBAL_VIEW\r1[1]+GLOBAL_VIEW\r3[1]
        \vcamera[index]\z=\vglobal[index]\z+GLOBAL_VIEW\r3[2]
      Next index
    Case 3
    Case 5
    Case 6
    Case 7
      MatCopy4x4{GLOBAL_VIEW,GV}
      For index=0 To \numverts
        \vcamera[index]\x=\vglobal[index]\x*GV\r0[0]+\vglobal[index]\y*GV\r1[0]+\vglobal[index]\z*GV\r2[0]+GV\r3[0]
        \vcamera[index]\y=\vglobal[index]\x*GV\r0[1]+\vglobal[index]\y*GV\r1[1]+\vglobal[index]\z*GV\r2[1]+GV\r3[1]
        \vcamera[index]\z=\vglobal[index]\x*GV\r0[2]+\vglobal[index]\y*GV\r1[2]+\vglobal[index]\z*GV\r2[2]+GV\r3[2]
      Next index
  End Select
End Statement

;--------------------------------------------------------------
.CreateWorldToCamera
Statement CreateWorldToCamera{}
; Creates global inverse transformation matrix used to transform
; world coordinates to camera coordinates.
;
  SHARED GLOBAL_VIEW, VIEW_POINT, VIEW_ANGLE
  SHARED COSTABLE(), SINTABLE()
  DEFTYPE.matrix4x4 translate, rotate_x, rotate_y, rotate_z
  DEFTYPE.matrix4x4 result_1, result_2
  DEFTYPE.b active_axes

  active_axes=0

  MatIdentity4x4{translate}

  translate\r3[0]=-VIEW_POINT\x
  translate\r3[1]=-VIEW_POINT\y
  translate\r3[2]=-VIEW_POINT\z

  If VIEW_ANGLE\angx
    MatIdentity4x4{rotate_x}
    rotate_x\r1[1]= ( COSTABLE(VIEW_ANGLE\angx))
    rotate_x\r1[2]= ( SINTABLE(VIEW_ANGLE\angx))
    rotate_x\r2[1]= (-SINTABLE(VIEW_ANGLE\angx))
    rotate_x\r2[2]= ( COSTABLE(VIEW_ANGLE\angx))
    active_axes+1
  EndIf

  If VIEW_ANGLE\angy
    MatIdentity4x4{rotate_y}
    rotate_y\r0[0]= ( COSTABLE(VIEW_ANGLE\angy))
    rotate_y\r0[2]=-(-SINTABLE(VIEW_ANGLE\angy))
    rotate_y\r2[0]=-( SINTABLE(VIEW_ANGLE\angy))
    rotate_y\r2[2]= ( COSTABLE(VIEW_ANGLE\angy))
    active_axes+2
  EndIf

  If VIEW_ANGLE\angz
    MatIdentity4x4{rotate_z}
    rotate_z\r0[0]= ( COSTABLE(VIEW_ANGLE\angz))
    rotate_z\r0[1]=-( SINTABLE(VIEW_ANGLE\angz))
    rotate_z\r1[0]=-(-SINTABLE(VIEW_ANGLE\angz))
    rotate_z\r1[1]= ( COSTABLE(VIEW_ANGLE\angz))
    active_axes+4
  EndIf

  Select active_axes
    Case 0
      MatCopy4x4{translate, GLOBAL_VIEW}
    Case 1
      MatCopy4x4{rotate_x, GLOBAL_VIEW}
      GLOBAL_VIEW\r3[0]=(-VIEW_POINT\x)
      GLOBAL_VIEW\r3[1]=(-VIEW_POINT\y*COSTABLE(VIEW_ANGLE\angy)-VIEW_POINT\z*SINTABLE(VIEW_ANGLE\angy))
      GLOBAL_VIEW\r3[2]=(VIEW_POINT\y*SINTABLE(VIEW_ANGLE\angy)-VIEW_POINT\z*COSTABLE(VIEW_ANGLE\angy))
    Case 2
      MatCopy4x4{rotate_y, GLOBAL_VIEW}
      GLOBAL_VIEW\r3[0]=(-VIEW_POINT\x*COSTABLE(VIEW_ANGLE\angy)+VIEW_POINT\z*SINTABLE(VIEW_ANGLE\angy))
      GLOBAL_VIEW\r3[1]=(-VIEW_POINT\y)
      GLOBAL_VIEW\r3[2]=(-VIEW_POINT\y*SINTABLE(VIEW_ANGLE\angy)-VIEW_POINT\z*COSTABLE(VIEW_ANGLE\angy))
    Case 3
      MatMult4x4S{translate, rotate_x, result_1}
      MatMult4x4S{result_1, rotate_y, GLOBAL_VIEW}
    Case 4
      MatCopy4x4{rotate_z, GLOBAL_VIEW}
      GLOBAL_VIEW\r3[0]=(-VIEW_POINT\x*COSTABLE(VIEW_ANGLE\angz)-VIEW_POINT\y*SINTABLE(VIEW_ANGLE\angz))
      GLOBAL_VIEW\r3[1]=( VIEW_POINT\x*SINTABLE(VIEW_ANGLE\angz)-VIEW_POINT\y*COSTABLE(VIEW_ANGLE\angz))
      GLOBAL_VIEW\r3[2]=(-VIEW_POINT\z)
    Case 5
      MatMult4x4S{translate, rotate_x, result_1}
      MatMult4x4S{result_1, rotate_z, GLOBAL_VIEW}
    Case 6
      MatMult4x4S{translate, rotate_y, result_1}
      MatMult4x4S{result_1, rotate_z, GLOBAL_VIEW}
    Case 7
      MatMult4x4S{translate, rotate_x, result_1}
      MatMult4x4S{result_1, rotate_y, result_2}
      MatMult4x4S{result_2, rotate_z, GLOBAL_VIEW}
  End Select
End Statement

;--------------------------------------------------------------
.RemoveObject
Function.l RemoveObject{}
; Determines if the entire currently used object is within
; viewing volume by testing the bounding sphere of an object.
;
  SHARED OBJECTS(), GLOBAL_VIEW, NEAR_Z, FAR_Z, INVERSE_ASPECT_RATIO
  SHARED CLIP_MODE
  SHARED HALF_SCREEN_WIDTH, HALF_SCREEN_HEIGHT, VIEWING_DISTANCE
  DEFTYPE.f x_bsphere, y_bsphere, z_bsphere, radius, x_compare, y_compare

  USEPATH OBJECTS()

  x_bsphere=\worldpos\x*GLOBAL_VIEW\r0[0]+\worldpos\y*GLOBAL_VIEW\r1[0]+\worldpos\z*GLOBAL_VIEW\r2[0]+GLOBAL_VIEW\r3[0]
  y_bsphere=\worldpos\x*GLOBAL_VIEW\r0[1]+\worldpos\y*GLOBAL_VIEW\r1[1]+\worldpos\z*GLOBAL_VIEW\r2[1]+GLOBAL_VIEW\r3[1]
  z_bsphere=\worldpos\x*GLOBAL_VIEW\r0[2]+\worldpos\y*GLOBAL_VIEW\r1[2]+\worldpos\z*GLOBAL_VIEW\r2[2]+GLOBAL_VIEW\r3[2]

  radius=\radius

  If CLIP_MODE=#ZPLANE
    If ((z_bsphere-radius) > FAR_Z) OR ((z_bsphere+radius) < NEAR_Z)
      Function Return True
    Else
      Function Return False
    EndIf
  Else
  ;perform full XYZ test
    If ((z_bsphere-radius) > FAR_Z) OR ((z_bsphere+radius) < NEAR_Z) Then Function Return True
    x_compare=(HALF_SCREEN_WIDTH*z_bsphere)/VIEWING_DISTANCE
    If ((x_bsphere-radius) > x_compare) OR ((x_bsphere+radius) < -x_compare) Then Function Return True
    y_compare=(INVERSE_ASPECT_RATIO*HALF_SCREEN_HEIGHT*z_bsphere)/VIEWING_DISTANCE
    If ((y_bsphere-radius) > y_compare) OR ((y_bsphere+radius) < -y_compare) Then Function Return True
    Function Return False
  EndIf
End Function

;--------------------------------------------------------------
.DeleteObject
Statement DeleteObject{}
; Removes (deletes) current object from 3d world
;
  SHARED OBJECTS()
  KillItem OBJECTS()
End Statement

;--------------------------------------------------------------
.Frustum
Statement Frustum{near.l, far.l}
; Sets near and far z-clipping planes of the viewing volume
;
  SHARED NEAR_Z, FAR_Z, VIEWING_DISTANCE
  NEAR_Z=near
  FAR_Z=far
  If NEAR_Z < VIEWING_DISTANCE Then NEAR_Z=VIEWING_DISTANCE
  If  FAR_Z < NEAR_Z Then FAR_Z=2*NEAR_Z
End Statement

;--------------------------------------------------------------
.CreateLightSource
Statement CreateLightSource{lx.l, ly.l, lz.l}
; Creates a vector describring direction from which rays of light
; from infinite light source are coming.

  SHARED LIGHT_SOURCE
  vert1.vertex\x=lx, ly, lz
  vert2.vertex\x=0, 0, 0
  MakeVector3D{vert1, vert2, LIGHT_SOURCE}
End Statement

;--------------------------------------------------------------
.AmbientLight
Statement AmbientLight{light.w}
; Sets intensity level for use as ambient light. It is actually
;
  SHARED AMBIENT_LIGHT
  AMBIENT_LIGHT=light
End Statement
;--------------------------------------------------------------
.PositionCamera
Statement PositionCamera{x.l, y.l, z.l}
; Positions view point in a 3d world
;
  SHARED VIEW_POINT
  VIEW_POINT\x=x,y,z
End Statement

;--------------------------------------------------------------
.ViewAngle
Statement ViewAngle{ax.w, ay.w, az.w}
; Defines an angle at which the camera looks at the 3d world.
; Angle is relative to x, y, and z -axis.

  SHARED VIEW_ANGLE
  If ax<0   Then ax=Abs(ax)-(Int(Abs(ax)/360)*360)
  If ax>360 Then ax=ax-(Int(ax/360)*360)
  If ay<0   Then ay=Abs(ay)-(Int(Abs(ay)/360)*360)
  If ay>360 Then ay=ay-(Int(ay/360)*360)
  If az<0   Then az=Abs(az)-(Int(Abs(az)/360)*360)
  If az>360 Then az=az-(Int(az/360)*360)
  VIEW_ANGLE\angx=ax, ay, az
End Statement

;--------------------------------------------------------------
.ClipObject3D
Statement ClipObject3D{}
; clips an object in camera coordinates against viewing volume.
;
  SHARED OBJECTS(), NEAR_Z, FAR_Z, VIEWING_DISTANCE, CLIP_MODE
  DEFTYPE.l curr_poly
  DEFTYPE.f x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4
  DEFTYPE.f x1_cmp, y1_cmp, x2_cmp, y2_cmp, fov_width
  DEFTYPE.f x3_cmp, y3_cmp, x4_cmp, y4_cmp, fov_height

  USEPATH OBJECTS()

  If CLIP_MODE=#ZPLANE
  ;attempt to clip each polygon against viewing olume
    For curr_poly=0 To \numpolys
      z1=\vcamera[\polys[curr_poly]\vertexlist[0]]\z
      z2=\vcamera[\polys[curr_poly]\vertexlist[1]]\z
      z3=\vcamera[\polys[curr_poly]\vertexlist[2]]\z
      ;test if this is a quad
      If \polys[curr_poly]\numpoints=4
        z4=\vcamera[\polys[curr_poly]\vertexlist[3]]\z
      Else
        z4=z3
      EndIf
    If (z1<NEAR_Z AND z2<NEAR_Z AND z3<NEAR_Z AND z4<NEAR_Z) OR (z1>FAR_Z AND z2>FAR_Z AND z3>FAR_Z AND z4>FAR_Z)
      \polys[curr_poly]\clipped=1
    EndIf
    Next curr_poly
  Else
    ;means #FRUSTUM mode

    fov_width=HALF_SCREEN_WIDTH/VIEWING_DISTANCE
    fov_height=HALF_SCREEN_HEIGHT/VIEWING_DISTANCE

    For curr_poly=0 To \numpolys
      x1=\vcamera[\polys[curr_poly]\vertexlist[0]]\x
      y1=\vcamera[\polys[curr_poly]\vertexlist[0]]\y
      z1=\vcamera[\polys[curr_poly]\vertexlist[0]]\z

      x2=\vcamera[\polys[curr_poly]\vertexlist[1]]\x
      y2=\vcamera[\polys[curr_poly]\vertexlist[1]]\y
      z2=\vcamera[\polys[curr_poly]\vertexlist[1]]\z

      x3=\vcamera[\polys[curr_poly]\vertexlist[2]]\x
      y3=\vcamera[\polys[curr_poly]\vertexlist[2]]\y
      z3=\vcamera[\polys[curr_poly]\vertexlist[2]]\z

      ;what if it is a quad?
      If \polys[curr_poly]\numpoints=4
        x4=\vcamera[\polys[curr_poly]\vertexlist[3]]\x
        y4=\vcamera[\polys[curr_poly]\vertexlist[3]]\y
        z4=\vcamera[\polys[curr_poly]\vertexlist[3]]\z
        If (z1<NEAR_Z AND z2<NEAR_Z AND z3<NEAR_Z AND z4<NEAR_Z) OR (z1>FAR_Z AND z2>FAR_Z AND z3>FAR_Z AND z4>FAR_Z)
          \polys[curr_poly]\clipped=1
          Pop If
          Goto continue2
        EndIf
        x1_cmp = fov_width*z1
        x2_cmp = fov_width*z2
        x3_cmp = fov_width*z3
        x4_cmp = fov_width*z4
        If NOT((x1>-x1_cmp OR x2>-x1_cmp OR x3>-x3_cmp OR x4>-x4_cmp) AND (x1<x1_cmp OR x2<x2_cmp OR x3<x3_cmp OR x4<x4_cmp))
          \polys[curr_poly]\clipped=1
          Pop If
          Goto continue2
        EndIf
        y1_cmp = fov_height*z1
        y2_cmp = fov_height*z2
        y3_cmp = fov_height*z3
        y4_cmp = fov_height*z4
        If NOT((y1>-y1_cmp OR y2>-y1_cmp OR y3>-y3_cmp OR y4>-y4_cmp) AND (y1<y1_cmp OR y2<y2_cmp OR y3<y3_cmp OR y4<y4_cmp))
          \polys[curr_poly]\clipped=1
          Pop If
          Goto continue2
        EndIf
      Else
      ;must be a triangle
        If NOT((z1>NEAR_Z OR z2>NEAR_Z OR z3>NEAR_Z) AND (z1<FAR_Z OR z2<FAR_Z OR z3<FAR_Z))
          \polys[curr_poly]\clipped=1
          Pop If:Goto continue2
        EndIf
        x1_cmp = fov_width*z1
        x2_cmp = fov_width*z2
        x3_cmp = fov_width*z3
        If NOT((x1>-x1_cmp OR x2>-x1_cmp OR x3>-x3_cmp) AND (x1<x1_cmp OR x2<x2_cmp OR x3<x3_cmp))
          \polys[curr_poly]\clipped=1
          Pop If
          Goto continue2
        EndIf
        y1_cmp = fov_height*z1
        y2_cmp = fov_height*z2
        y3_cmp = fov_height*z3
        If NOT((y1>-y1_cmp OR y2>-y1_cmp OR y3>-y3_cmp) AND (y1<y1_cmp OR y2<y2_cmp OR y3<y3_cmp))
          \polys[curr_poly]\clipped=1
          Pop If:
          Goto continue2
        EndIf
      EndIf
    continue2:
    Next curr_poly
  EndIf
End Statement

;--------------------------------------------------------------
.GeneratePolyList
Statement GeneratePolyList{}
; Creates a list of all polygons visible in current frame.
;
  SHARED OBJECTS(), WORLDPOLYS(), FAR_Z, NEAR_Z
  DEFTYPE.l vertx, curr_vertex, curr_poly

USEPATH WORLDPOLYS()

ClearList WORLDPOLYS()
ResetList WORLDPOLYS()
ResetList OBJECTS()

While NextItem(OBJECTS())
    For curr_poly=0 To OBJECTS()\numpolys-1
      If OBJECTS()\polys[curr_poly]\visible AND NOT(OBJECTS()\polys[curr_poly]\clipped)
        If AddItem(WORLDPOLYS())
          \numpoints = OBJECTS()\polys[curr_poly]\numpoints
              \color = OBJECTS()\polys[curr_poly]\color
              \shade = OBJECTS()\polys[curr_poly]\shade
            \shading = OBJECTS()\polys[curr_poly]\shading
           \twosided = OBJECTS()\polys[curr_poly]\twosided
            \visible = OBJECTS()\polys[curr_poly]\visible
            \clipped = OBJECTS()\polys[curr_poly]\clipped
             \active = OBJECTS()\polys[curr_poly]\active
             \svalue = NEAR_Z
          ;now copy vertices
          For curr_vertex=0 To \numpoints-1
            vertx=OBJECTS()\polys[curr_poly]\vertexlist[curr_vertex]
            \vertexlist[curr_vertex]\x=OBJECTS()\vcamera[vertx]\x
            \vertexlist[curr_vertex]\y=OBJECTS()\vcamera[vertx]\y
            \vertexlist[curr_vertex]\z=OBJECTS()\vcamera[vertx]\z
            If OBJECTS()\vcamera[vertx]\z>\svalue Then \svalue=FAR_Z-OBJECTS()\vcamera[vertx]\z
          Next curr_vertex
        EndIf ;AddItem()
      EndIf ;if visible
    Next curr_poly
Wend
End Statement

;--------------------------------------------------------------
.PaintFrame
Statement PaintFrame{}
; Paints visible in current frame polygons on a screen using
; painters algorythm. Sorts polygons according to their maximum Z value
;
  SHARED WORLDPOLYS(), ASPECT_RATIO, VIEWING_DISTANCE, NEAR_Z, FAR_Z
  SHARED HALF_SCREEN_WIDTH, HALF_SCREEN_HEIGHT, VIEW_ANGLE
  DEFTYPE.l curr_vertex, x1,y1,z1, x2,y2,z2, x3,y3,z3, x4,y4,z4
  DEFTYPE.vertex vertex_1, vertex_2, vertex_3, vertex_4
  DEFTYPE.pixel p1, p2, p3, p4
  DEFTYPE.polytemp p

  SortList WORLDPOLYS(), SizeOf.facet\svalue

  ResetList WORLDPOLYS()
  USEPATH WORLDPOLYS()
  While NextItem(WORLDPOLYS())
    If (\clipped=0) AND (\visible=1)

      x1=\vertexlist[0]\x
      y1=\vertexlist[0]\y
      z1=\vertexlist[0]\z

      x2=\vertexlist[1]\x
      y2=\vertexlist[1]\y
      z2=\vertexlist[1]\z

      x3=\vertexlist[2]\x
      y3=\vertexlist[2]\y
      z3=\vertexlist[2]\z

      If z1=0 Then z1=1
      If z2=0 Then z2=1
      If z3=0 Then z3=1

      x1=(HALF_SCREEN_WIDTH+x1*VIEWING_DISTANCE/z1)
      y1=(HALF_SCREEN_HEIGHT-ASPECT_RATIO*y1*VIEWING_DISTANCE/z1)

      x2=(HALF_SCREEN_WIDTH+x2*VIEWING_DISTANCE/z2)
      y2=(HALF_SCREEN_HEIGHT-ASPECT_RATIO*y2*VIEWING_DISTANCE/z2)

      x3=(HALF_SCREEN_WIDTH+x3*VIEWING_DISTANCE/z3)
      y3=(HALF_SCREEN_HEIGHT-ASPECT_RATIO*y3*VIEWING_DISTANCE/z3)

      p\x1=x1,y1,x2,y2,x3,y3
      Polyf 3,p,\shade

      If \numpoints=4
        x4=\vertexlist[3]\x
        y4=\vertexlist[3]\y
        z4=\vertexlist[3]\z

        If z4=0 Then z4=1 ;JUST IN CASE...
        x4=(HALF_SCREEN_WIDTH+x4*VIEWING_DISTANCE/z4)
        y4=(HALF_SCREEN_HEIGHT-ASPECT_RATIO*y4*VIEWING_DISTANCE/z4)

        p\x4=x4,y4
        Polyf 4,p,\shade

      EndIf
    EndIf
  skipper:
  Wend
End Statement

;--------------------------------------------------------------
.NewView
Statement NewView{}
; Re-calculates 3d world view..
;
  SHARED OBJECTS()
  CreateWorldToCamera{}
  ResetList OBJECTS()
  While NextItem(OBJECTS())
    If NOT(RemoveObject{})
      LocalToWorld{}
      RemoveBackfacesAndShade{}
      WorldToCamera{}
      ClipObject3D{}
    EndIf
  Wend
  GeneratePolyList{}
End Statement

;--------------------------------------------------------------
.MoveForward
Statement MoveForward{dist.l}
; Moves viewer ahead by dist units
;
  SHARED VIEW_ANGLE, VIEW_POINT, SINTABLE(), COSTABLE()
  DEFTYPE.l active_axes, dx, dy, dz
    active_axes=0
  USEPATH VIEW_ANGLE

  If \angx Then active_axes+1
  If \angy Then active_axes+2
  If \angz Then active_axes+4

  Select active_axes
    Case 0
      dx=0:dy=0:dz=dist
    Case 1
      dx=0:dy=COSTABLE(\angx)*dist:dz=SINTABLE(\angx)*dist
    Case 2
      dx=SINTABLE(\angy)*dist:dy=0:dz=COSTABLE(\angy)*dist
    Case 3
      dx=SINTABLE(\angy)*dist
      dy=COSTABLE(\angx)*dist
      dz=COSTABLE(\angy)*dist + SINTABLE(\angx)*dist
    Case 4
      dx=SINTABLE(\angz)*dist:dy=COSTABLE(\angz)*dist:dz=0
    Case 5
      dx=SINTABLE(\angz)*dist
      dy=COSTABLE(\angx)*dist + COSTABLE(\angz)*dist
      dz=SINTABLE(\angx)*dist
    Case 6
      dx=SINTABLE(\angy)*dist + SINTABLE(\angz)*dist
      dy=COSTABLE(\angz)*dist
      dz=COSTABLE(\angy)*dist
    Case 7
      dx=SINTABLE(\angy)*dist + SINTABLE(\angz)*dist
      dy=COSTABLE(\angx)*dist + COSTABLE(\angz)*dist
      dz=SINTABLE(\angx)*dist + COSTABLE(\angy)*dist
  End Select
  VIEW_POINT\x+dx
  VIEW_POINT\y+dy
  VIEW_POINT\z+dz
End Statement

;--------------------------------------------------------------
.MoveUp
Statement MoveUp{dist.l}
; Moves viewer upwards in 3d world coordinate system
;
  SHARED VIEW_POINT
  VIEW_POINT\y+dist
End Statement

;--------------------------------------------------------------
.MoveDown
Statement MoveDown{dist.l}
; Moves viewer (camera) down in 3d world coordinate system
;
 SHARED VIEW_POINT
 VIEW_POINT\y-dist
End Statement

;--------------------------------------------------------------
.ObjectsUseColor
Statement ObjectsUseColor{colreg.w}
; Changes objects default color register (one specified in a PLG
; file) and forces all objects to use that color as a base for
; finding shading offset.

  SHARED OBJECTS()
  DEFTYPE.l curr_poly
  USEPATH OBJECTS()
  ResetList OBJECTS()
  While NextItem(OBJECTS())
    For curr_poly=0 To \numpolys
      \polys[curr_poly]\color=colreg
    Next curr_poly
  Wend
End Statement

;--------------------------------------------------------------
.CameraX
Function.l CameraX{}
; Returns camera's (viewer) X position in coordinate system
  SHARED VIEW_POINT
  Function Return VIEW_POINT\x
End Function

;--------------------------------------------------------------
.CameraY
Function.l CameraY{}
; Returns camera's (viewer) Y position in coordinate system
  SHARED VIEW_POINT
  Function Return VIEW_POINT\y
End Function

;--------------------------------------------------------------
.CameraZ
Function.l CameraZ{}
; Returns camera's (viewer) Z position in coordinate system
  SHARED VIEW_POINT
  Function Return VIEW_POINT\z
End Function

;--------------------------------------------------------------
.AngleX
Function.w AngleX{}
; Returns camera's (viewer) viewing angle around X-axis
  SHARED VIEW_ANGLE
  Function Return VIEW_ANGLE\angx
End Function

;--------------------------------------------------------------
.AngleY
Function.w AngleY{}
; Returns camera's (viewer) viewing angle around Y-axis
  SHARED VIEW_ANGLE
  Function Return VIEW_ANGLE\angy
End Function

;--------------------------------------------------------------
.AngleZ
Function.w AngleZ{}
; Returns camera's (viewer) viewing angle around Z-axis
  SHARED VIEW_ANGLE
  Function Return VIEW_ANGLE\angz
End Function

;--------------------------------------------------------------

