; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "/Bin"
; ExeFile         = "HTTPGet"
; CreateIcon      = 0
; Residents       = "all.res,sdstcp.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 102400
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 3
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = "593700"
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 1
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 564
; CursorColumn    = 41
; LabelSearch     = "nprint"
; LabelRemark     = 0
; LabelAll        = 1
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 5
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 5
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 5
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: http.include                                                          /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 19/01/2007                                                            /
;/                                                                             /
;/ Author: <unknown>                                                           /
;/                                                                             /
;/ Requirements:  Amiblitz3                                                    /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Extend AB3 functionality.                                                   /
;/ * no description available *                                                /
;/                                                                             /
;/ Abstract:                                                                   /
;/ * no abstract available *                                                   /
;/                                                                             /
;/ User Constants:                                                             /
;/ #max_objects   = n                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
CNIF #__include=0
  OPTIMIZE 7
  SYNTAX 2
CEND

XINCLUDE "error.include.ab3"
XINCLUDE "tcp.include.ab3"
XINCLUDE "dos.include.ab3"
XINCLUDE "file.include.ab3"

NEWTYPE.httpdat
body.s[#max_sockets]
err.w[#max_sockets]
url.s[#max_sockets]
todisk.l[#max_sockets]
dos.l[#max_sockets]
filename.s[#max_sockets]
referer.s[#max_sockets]
host.s[#max_sockets]
loading.l[#max_sockets]
lastsocket.l
size.l[#max_sockets]
author.s[#max_sockets]
moreheader.s[#max_sockets]

proxy_name_http.s[#max_sockets]
proxy_port_http.l[#max_sockets]
proxy_author.s[#max_sockets]
use_proxy.l[#max_sockets]
End NEWTYPE

CNIF @#max_htmlbuffer = 0
  #max_htmlbuffer=256000
CEND

DEFTYPE.httpdat httpdat
USEPATH httpdat


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = _BASE64_Decode {a$}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ decode BASE64 string to plain text                                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - a$    : ???                                                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s _BASE64_Decode{a$}
  b64$="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  m$=""
  f$=""
  l.l = Len(a$)
  cx$ = ""
  If Right$(a$,1) = "=" Then l = l - 2: flag.l = 1

  For decode.l = 1 To l
    x$ = Mid$(a$,decode,1)
    pos.l = Instr(b64$,x$)-1
    b$ = Bin$(pos)
    b$ = Right$(b$,6)
    cx$ = cx$ + b$
  Next

  If flag = 1
    numBits.l = 6 * (Len(a$)-2)
    rmdr.l = ( Int(numBits/8)+1 ) * 8 - numBits
    oddChar$ = Mid$(a$,Len(a$)-1,1)
    pos =Instr(b64$, oddChar$)-1
    b$ = Right$(Bin$(pos),6)
    b$ = Left$(b$,rmdr)
    cx$ = cx$ + b$
  End If

  l = Len(cx$)

  For decode = 1 To l Step 8
    b$ = Mid$(cx$,decode,8)
    res.l = 0
    For y.l = 0 To 7
      bit.l =Asc( Mid$(b$,8-y,1)) - 48
      If bit <> 0
        res2. l = (2^y * bit)
        res = res OR res2
      End If
    Next
    m$ = m$ + Chr$(res)
  Next
  Function Return m$
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = _BASE64_Encode {a$}                                     /
;/                                                                             /
;/ Description:                                                                /
;/ encode plain text to BASE64 string                                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - a$    : ???                                                               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s _BASE64_Encode{a$}
  b64$ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  m$ = ""
  f$ = ""

  largo.l = Len(a$) : cx$ = ""
  For decode.l = 1 To largo
    x$ = Mid$(a$,decode,1)
    Tx.b = Asc(x$)
    b$ = Bin$(Tx)
    b$ = Right$(b$,8)
    cx$ = cx$ + b$
  Next

  largo = Len(cx$)
  For decode.l = 1 To largo Step 6
    x$ = Mid$(cx$,decode,6)
    bbb.l = Len(x$)
    bbbx.l = 6 - bbb
    If bbbx > 0 Then f$ = "="
    x$ = x$ + Left$("00000000",bbbx)
    res.l = 0

    For y.b = 1 To 6
      by$ = Mid$(x$,7-y,1)
      res = res + (2^(y-1) * Vallong(by$))
    Next
    m$ = m$ + Mid$(b64$,res+1,1) + f$
  Next decode

  Function Return m$
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: http_SetProxy {socket.l,proxy_name.s,@proxy_port.l,@username.s,@p:: /
;/ assword.s}                                                                  /
;/                                                                             /
;/ Description:                                                                /
;/ set a proxy server for a socket, or remove it (when proxy_name.s = "")      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - socket.l    : ???                                                         /
;/ - proxy_name.s    : ???                                                     /
;/ - proxy_port.l    : ???                                                     /
;/ - username.s    : ???                                                       /
;/ - password.s    : ???                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement http_SetProxy{socket.l,proxy_name.s,@proxy_port.l,@username.s,@password.s}
SHARED httpdat
\proxy_name_http[socket] = proxy_name.s
If proxy_port=-1 Then proxy_port=#port_http
\proxy_port_http[socket] = proxy_port
\use_proxy      [socket] = True
\proxy_author   [socket] = _BASE64_Encode{username.s+":"+password.s}
If proxy_name.s="" Then \use_proxy[socket] = False:Else \use_proxy[socket] = True
End Statement
 
Statement http_SetMoreHeaders{socket.l,headers.s}
SHARED httpdat
\moreheader[socket] = headers
End Statement

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = http_GetDocument {url.s}                                /
;/                                                                             /
;/ Description:                                                                /
;/ Get document from URL string                                                /
;/ e.g. "mypath/index.html" out of "http://www.hd-rec.de/mypath/index.html"    /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - url.s    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s http_GetDocument{url.s}
a.l = Instr(url.s,"@")
If a
  url.s = "http://"+Right$(url.s,FLen(url.s)-a)
End If
h1.l = Instr(url.s,"://",1)
h2.l = Instr(url.s,"/",h1+3)
Function Return Mid$(url.s,h2,FLen(url.s)-h2+1)
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = http_GetAuthorization {url.s}                           /
;/                                                                             /
;/ Description:                                                                /
;/ Extract the BASE64 encoded authorization string from an "@" URL             /
;/ e.g. "myuser:mypasswd@www.myhompage.com/index.html"                         /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - url.s    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s  http_GetAuthorization{url.s}
author.s = ""
h1.l = Instr(url.s,"://",1)
a.l = Instr(url.s,"@")
If a
  author.s = _BASE64_Encode{Mid$(url.s,h1+3,a-h1-3)}
End If
Function Return author.s
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = http_GetHost {url.s}                                    /
;/                                                                             /
;/ Description:                                                                /
;/ Get host name from URL                                                      /
;/ e.g. "www.hd-rec.de" out of "http://www.hd-rec.de/index.html"               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - url.s    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s http_GetHost{url.s}
a.l = Instr(url.s,"@")
If a
  url.s = "http://"+Right$(url.s,FLen(url.s)-a) ; cut the @ out !
End If
h1.l = Instr(url.s,"://",1)
h2.l = Instr(url.s,"/",h1+3)
Function Return Mid$(url.s,h1+3,h2-h1-3)
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = http_GetDomain {url.s}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Get domain name from URL                                                    /
;/ e.g. "de" out of "http://www.hd-rec.de/index.html"                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - url.s    : ???                                                            /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s http_GetDomain{url.s}
a.l = Instr(url.s,"@")
If a
  url.s = "http://"+Right$(url.s,FLen(url.s)-a) ; cut the @ out !
End If
h1.l = Instr(url.s,"://",1)
h2.l = Instr(url.s,"/",h1+3)
host.s = Mid$(url.s,h1+3,h2-h1-3)
pos.l = Len(host.s)
While Mid$(host.s,pos,1)><"." AND pos>1
  domain.s = Mid$(host.s,pos,1) + domain.s
  pos-1
Wend
Function Return domain.s
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = http_IsUsed {socket.l}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Is the socket in use ?                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - socket.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l http_IsUsed{socket.l}
Function Return socket_IsUsed{socket}
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = http_IsConnected {socket.l}                             /
;/                                                                             /
;/ Description:                                                                /
;/ Is the socket already connected ?                                           /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - socket.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l http_IsConnected{socket.l}
Function Return socket_IsConnected{socket}
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = http_GetUrl {socket.l}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ Return the sockets URL                                                      /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - socket.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s http_GetUrl{socket.l}
SHARED httpdat
Function Return \url[socket]
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: http_Disconnect {socket.l,@keepfile.l}                              /
;/                                                                             /
;/ Description:                                                                /
;/ Shut the socket and remove it                                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - socket.l    : ???                                                         /
;/ - keepfile.l    : ???                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement http_Disconnect{socket.l,@keepfile.l}
SHARED httpdat
socket_Free{socket}
If \todisk[socket]
  If \dos[socket]>=0
    file_Close{\dos[socket]}
    If keepfile=0 Then succ.l = dos_Delete{\filename[socket]}
  End If
End If
\dos[socket]=-1
\loading[socket] = False
End Statement


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = _http_Get {socket.l}                                    /
;/                                                                             /
;/ Description:                                                                /
;/ Send http GET command, socket must be already connected !                   /
;/ NOTE: this function is private and will not be called by you !              /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - socket.l    : ???                                                         /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l _http_Get{socket.l}
SHARED httpdat,tcp
succ.l = False
If socket_IsConnected{socket}
  ;If socket_GetPort{socket} = #port_http
    \body [socket] = ""
    socket_CreatePacket {socket}
    socket_AddPacketString{socket,"GET "}

    If \use_proxy[socket]
      socket_AddPacketString{socket,\host[socket] + \url[socket]}
    Else
      socket_AddPacketString {socket,http_GetDocument{\url[socket]}}
    EndIf

    socket_AddPacketStringN{socket," HTTP/1.0"}
    socket_AddPacketStringN{socket,"User-Agent: BlitzBrowser"}
    socket_AddPacketStringN{socket,"Accept: */*;q=1"}
    socket_AddPacketStringN{socket,"Host: "+socket_GetHost{socket}}
    socket_AddPacketStringN{socket,"Pragma: no-cache"}
    socket_AddPacketStringN{socket,"Referer: "+\referer[socket]}


    If \use_proxy[socket]
      socket_AddPacketStringN{socket,"Proxy-Authorization: Basic " + \proxy_author[socket]}
    EndIf

    If \author[socket]><"" Then socket_AddPacketStringN{socket,"Authorization: Basic "+\author[socket]}

    If \moreheader[socket]
      socket_AddPacketStringN{socket,\moreheader[socket]}
    End If

    socket_AddPacketStringN{socket,""}
    socket_SendPacket{socket}
    ;error{tcp\socket[socket]\packet}
    succ = True
  ;Else
  ;  error{"Socket is not connected to HTTP port ("+Str$(#port_http)+") !"}
  ;End If
Else
  _tcp_error{"Internal error: Socket is not connected !"}
End If
Function Return succ
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = http_Connect {socket.l,url.s,referer.s,filename.s,tim:: /
;/ eout.l}                                                                     /
;/                                                                             /
;/ Description:                                                                /
;/   ;If socket_GetPort{socket} = #port_http                                   /
;/     socket_AddPacketStringN{socket,"Accept: */*;q=1"}                       /
;/     ;error{tcp\socket[socket]\packet}                                       /
;/   ;Else                                                                     /
;/   ;  error{"Socket is not connected to HTTP port ("+Str$(#port_http)+") !"} /
;/   ;End If                                                                   /
;/                                                                             /
;/ Start to make a connection to the given URL                                 /
;/ NOTE: socket may NOT be connected yet when this function returns            /
;/ After the socket is connected, you can do _http_Get{}                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - socket.l    : ???                                                         /
;/ - url.s    : ???                                                            /
;/ - referer.s    : ???                                                        /
;/ - filename.s    : ???                                                       /
;/ - timeout.l    : ???                                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l http_Connect{socket.l,url.s,referer.s,filename.s,timeout.l}
SHARED httpdat
succ.l = False

If \use_proxy[socket]
  host.s = "http://" + http_GetHost{url.s}       ; bei Proxynutzung mu_ die komplette URL inkl. http:// bei GET aufgerufen werden
  tcp_host.s = \proxy_name_http[socket]
  tcp_port.l = \proxy_port_http[socket]
Else
  host.s = http_GetHost{url.s}
  tcp_host.s = http_GetHost{url.s}
  tcp_port.l = #port_http
EndIf

If socket_Connect{socket.l,tcp_host.s,tcp_port,timeout}
  \referer   [socket] = referer.s
  \url       [socket] = url.s
  \err       [socket] = True
  \author    [socket] = http_GetAuthorization{url.s}
  \loading   [socket] = False
  \body      [socket] = ""
  \host      [socket] = host.s
  \size      [socket] = 0
  If filename.s><""
    \todisk    [socket] = True
    \filename  [socket] = filename.s
    \dos       [socket] = file_Open{filename.s,#file_open}
    If \dos[socket]<0 Then succ=False:Else succ=True
  Else
    \todisk    [socket] = False
    \filename  [socket] = ""
    \dos       [socket] = -1
    succ = True
  End If
End If
If succ=False Then http_Disconnect{socket}
Function Return succ
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = http_Check {@timeout.l}                                 /
;/                                                                             /
;/ Description:                                                                /
;/   host.s = "http://" + http_GetHost{url.s}       ; bei Proxynutzung mu_ d:: /
;/ ie komplette URL inkl. http:// bei GET aufgerufen werden                    /
;/                                                                             /
;/ Call this in regular intervals (e.g. 2 times a second or more) to perfrom:: /
;/  I/O                                                                        /
;/ If it returns success one or more sockets are done, and you can ask with    /
;/ http_GetReceived_... for information                                        /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - timeout.l    : ???                                                        /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l http_Check{@timeout.l}
SHARED httpdat,tcp
succ.l = False
break.l = False
err.l = False
If tcp\is_open
While break=False
  If tcp_Check{-1,timeout}
    socket.l = tcp_GetReceivedSocket{}
    If socket>=0 AND socket<#max_sockets
      Select tcp_GetReceivedState{}
        Case #packet_stat_connected
          If _http_Get{socket} = False
            succ  = True
            break = True
            err   = True
          End If

        Case #packet_stat_data
          body.s = tcp_GetReceivedBody{}
          l.l    = tcp_GetReceivedSize{}
          If \loading[socket] = False
            ;pos.l = Instr(body.s,"Content-Length:")
            ;error{"Length: "+Mid$(body.s,pos-100,200)}
            pos.l = Instr(body.s,"Content-Type:")
            If pos>0
              pos2.l = Instr(body.s,Chr$($0d)+Chr$($0a)+Chr$($0d)+Chr$($0a),pos)
              If pos2>0
                body.s = Right$(body.s,FLen(body.s)-pos2-3)
                \loading[socket] = True
              End If
            End If
          End If

          If \loading[socket]
            If \todisk[socket]
              If \dos[socket]>=0
                If body.s><""
                  If file_WriteMem{\dos[socket],&body.s,FLen(body.s)} = False
                    succ  = True
                    break = True
                    err   = True
                  End If
                End If
              End If
            Else
              If (FLen(\body[socket])+FLen(body.s))<#max_htmlbuffer
                \body [socket] + body.s
              End If
            End If
            \size [socket] + FLen(body.s)
          End If

        Case #packet_stat_done
          succ  = True
          break = True
          err   = False

        Default
;          If tcp_GetReceivedState{} = #packet_stat_error Then error{"Error occured !"}
          succ  = True
          break = True
          err   = True

      End Select

    Else
      error{"Received data on invalid socket !"}
      break=True
    End If
  Else
    break=True
  End If
Wend
EndIf
If succ
  \err[socket] = err
  \lastsocket  = socket
  http_Disconnect{socket}
End If
Function Return succ
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = http_GetReceivedBody {}                                 /
;/                                                                             /
;/ Description:                                                                /
;/             ;pos.l = Instr(body.s,"Content-Length:")                        /
;/             ;error{"Length: "+Mid$(body.s,pos-100,200)}                     /
;/          If tcp_GetReceivedState{} = #packet_stat_error Then error{"Error:: /
;/  occured !"}                                                                /
;/                                                                             /
;/ return body (=data) of last received socket after http_Check                /
;/ NOTE: the string may contain 0 bytes !!!                                    /
;/ NOTE: if you specified a filename during http_Connect, the body string will /
;/ be empty. You downloaded directly to a file (e.g. good for large files)     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s http_GetReceivedBody{}
SHARED httpdat
Function Return \body [\lastsocket]
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = http_GetReceivedUrl {}                                  /
;/                                                                             /
;/ Description:                                                                /
;/ return data bytelength of last received socket after http_Check{}           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s http_GetReceivedUrl{}
SHARED httpdat
Function Return \url [\lastsocket]
End Function

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = http_GetReceivedReferer {}                              /
;/                                                                             /
;/ Description:                                                                /
;/ return data bytelength of last received socket after http_Check{}           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s http_GetReceivedReferer{}
SHARED httpdat
Function Return \referer [\lastsocket]
End Function


;\ is "" if you did not define a filename during http_Connect                     *
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.s = http_GetReceivedFile {}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ return filename of last received socket after http_Check                    /
;/ \ is "" if you did not define a filename during http_Connect                /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.s     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.s http_GetReceivedFile{}
SHARED httpdat
Function Return \filename [\lastsocket]
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = http_GetReceivedSocket {}                               /
;/                                                                             /
;/ Description:                                                                /
;/ return socket number of last received socket after http_Check               /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l http_GetReceivedSocket{}
SHARED httpdat
Function Return \lastsocket
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = http_GetReceivedErrCode {}                              /
;/                                                                             /
;/ Description:                                                                /
;/ return error code of last received socket after http_Check                  /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l http_GetReceivedErrCode{}
SHARED httpdat
Function Return \err [\lastsocket]
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = http_GetReceivedSize {}                                 /
;/                                                                             /
;/ Description:                                                                /
;/ return data bytelength of last received socket after http_Check             /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l http_GetReceivedSize{}
SHARED httpdat
Function Return \size [\lastsocket]
End Function


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: http_Free {}                                                        /
;/                                                                             /
;/ Description:                                                                /
;/ close http engine, all sockets will be removed automatically                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement http_Free{}
SHARED httpdat
For socket.l=0 To #max_sockets-1
  http_Disconnect{socket}
Next
tcp_Close{}
End Statement
!autoexit{http_Free}



; build in demo:
CNIF #__include=0

;url.s = "http://www.teledata.maxblue.de/teledata/mape003.html?symbol=NDX.X.IND"
;url.s = "http://www.hd-rec.de/HD-Rec/bilder/hd-banner.gif"
;url.s = "http://michael:michael@falconfotovip.com/members/"
;url.s = "http://941261:1260840@www.atklounge.com/members/"
;url.s = "https://www.hd-rec.de/index.php?site=home"
url.s = "https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&apikey=3QXN27RL3QW69HTV"
;If NumPars>0 Then url.s = Par$(1)

downloadfile.s = "ram:test.dat"

message{"Attempt to open URL:\\n"+url.s}

If http_Connect{0,url.s,"",downloadfile.s,10}
  ;error{"host: "+\host[0]}
  ;error{"url: "+\url[0]}
  ;error{"doc: "+http_GetDocument{url.s}}
  ;error{"author: "+_BASE64_Decode{http_GetAuthorization{url.s}}}
  timeout.l=200
  ;message{"Will wait..."}
  While timeout>0
    If http_Check{}
      timeout=-1
      If http_GetReceivedErrCode{}
        error{"Error: "+Str$(http_GetReceivedErrCode{})}
      Else ; if we did not specify a file in http_attempt, the data is in a.s now
        If http_GetReceivedFile{} = ""
          a.s = http_GetReceivedBody{}
          NPrint a.s
        Else
          message{"Got URL, see "+http_GetReceivedFile{}+"!"}
        End If
      End If
    End If
    Delay_ 1
    timeout-1
  Wend
  http_Free{}
  If timeout=0 Then message{"Time out!"}
End If
End
CEND

