; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "/Bin"
; ExeFile         = "ImageExtDemo"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 10240
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 618
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8191
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 3846
; CursorColumn    = 1
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 20
; 
; Blitz Objects
; -------------------------------------------------------
; Max IconInfo    = 1
; Max NChunky     = 50
; Max MUIObject   = 50
; Max PTModule    = 5
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 30
; Max Console     = 5
; Max TCPSock     = 5
; Max XBSound     = 10
; Max Chunky      = 20
; Max File        = 5
; Max GadgetList  = 5
; Max Queue       = 10
; Max Screen      = 5
; Max Shape       = 100
; Max CopList     = 10
; Max Sprite      = 20
; Max Stencil     = 5
; Max Module      = 5
; Max Window      = 5
; Max Anim        = 10
; Max Sound       = 10
; Max Bank        = 5
; Max Buffer      = 10
; Max BitMap      = 10
; Max Slice       = 10
; Max Page        = 4
; Max Tape        = 5
; Max IntuiFont   = 5
; Max MedModule   = 8
; Max Palette     = 4
; Max MenuList    = 5
; Max BlitzFont   = 4
; Max GTList      = 5
; /XTRA
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Name: image_ext.include                                                     /
;/                                                                             /
;/ Platforms: Classic, WinUAE, Amithlon, MorphOS, AmigaOS4                     /
;/                                                                             /
;/ Date: 19/01/2007                                                            /
;/                                                                             /
;/ Author: <unknown>                                                           /
;/                                                                             /
;/ Requirements:  Amiblitz3                                                    /
;/                                                                             /
;/ Purpose:                                                                    /
;/ Extend AB3 functionality.                                                   /
;/ * no description available *                                                /
;/                                                                             /
;/ Abstract:                                                                   /
;/ * no abstract available *                                                   /
;/                                                                             /
;/ User Constants:                                                             /
;/ #max_objects   = n                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
CNIF #__include=0
  OPTIMIZE 7
  SYNTAX 6
  XINCLUDE "eclock.include.ab3"
  #use_jpeg_library=1
  #max_images = 100
CEND

XINCLUDE "image.include.ab3"
XINCLUDE "perlin.include.ab3"



USEPATH imagedat(image)
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_PerlinNoise {image.l,*rec.Rectangle,*perlinPars:: /
;/ .perlinPars,@*rp.RastPort}                                                  /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - *rec.perlinRect    : ???                                                  /
;/ - *perlinPars.perlinPars    : ???                                           /
;/ - *rp.RastPort    : ???                                                     /
;/ - *rec.Rectangle    : ???                                                   /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_PerlinNoise{image.l,*rec.Rectangle,*perlinPars.perlinPars,@*rp.RastPort}
  succ.l = 0
  If image_Create{image,*rec\MaxX - *rec\MinX+1,*rec\MaxY - *rec\MinY+1,False,$00FFFF00}
    *rpi.RastPort = image_GetRPPtr{image}
    perlin_RenderNoise2d{*rp,*rec,*perlinPars,*rpi}
    succ.l = -1
  End If
 Function Return succ
End Function
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Square2Iso {image.l,dstimage.l,@dw.l,@dh.l,@interpol.l}       /
;/                                                                             /
;/ Description:                                                                /
;/ Rotate image 45 degree and resize.                                          /
;/ This function can be used to convert a square (or rectangle) tile graphic:: /
;/  into an iso view tile.                                                     /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : source image                                                 /
;/ - dstimage.l : destination image                                            /
;/ - dw.l       : destination width                                            /
;/ - dh.l       : destination height                                           /
;/ - interpol   : -1 = use lienar interpolation, 0 = no interpolation          /
;/ - interpol.l    : ???                                                       /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Square2Iso{image.l,dstimage.l,@dw.l,@dh.l,@interpol.l}
 SHARED imagedat(),imgargs(),imageengine
 USEPATH imagedat(image)
  If dw<=0
    dw.l = Sqr((\img_width * \img_width) + (\img_height * \img_height))/4
    dw * 4
  End If

  If dh<=0
    dh.l = dw/4
    dh   = dh*2
  End If

  !setfpcr{$10}
  dh2.l = dh/2
  sw.f = \img_width   - 0.001
  sh.f = \img_height  - 0.001
  If image_Create{dstimage,dw,dh,False,$0000000}
    srcptr.l = \raw_ptr
    destptr.l = imagedat(dstimage)\raw_ptr
    imagedat(dstimage)\alpha_isused = True
    If srcptr><0 AND destptr><0
      dlinemod.l = imagedat(dstimage)\bpr ; dw*4
      slinemod.l = \bpr;\img_width*4

      For y.l = 0 To dh
        If y<dh2
          xs.l = (y * dw) / dh
          sx1.f = 0
          sy1.f = y * sh / (dh2)
          sx2.f = y * sw / (dh2)
          sy2.f = 0
        Else
          y2.l = y - dh2+1
          xs.l = ((dh2-y2) * dw) / dh
          sy1.f = sh
          sx1.f = y2 * sw / (dh2)
          sy2.f = y2 * sh / (dh2)
          sx2.f = sw
        End If
        dx.f = (sx2-sx1) / (xs+1) / 2
        dy.f = (sy2-sy1) / (xs+1) / 2

        If interpol
          For x.l = dw/2-xs-1 To dw/2+xs
            sx1i.l = sx1
            sy1i.l = sy1
            ifracx.f = sx1-sx1i : fracx.f = 1.0-ifracx
            ifracy.f = sy1-sy1i : fracy.f = 1.0-ifracy
            sx1 + dx
            sy1 + dy

            ptr.l = srcptr + sy1i * slinemod + sx1i * 4
            R.l = (Peek.b(ptr+1)  & $FF) * fracx * fracy
            G.l = (Peek.b(ptr+2)  & $FF) * fracx * fracy
            B.l = (Peek.b(ptr+3)  & $FF) * fracx * fracy

            If sx1i<sw-1 Then ptr = srcptr + sy1i * slinemod + sx1i * 4+4
            R.l + (Peek.b(ptr+1)  & $FF) * ifracx * fracy
            G.l + (Peek.b(ptr+2)  & $FF) * ifracx * fracy
            B.l + (Peek.b(ptr+3)  & $FF) * ifracx * fracy

            If sy1i<sh-1 Then ptr = srcptr + (sy1i+1) * slinemod + sx1i * 4
            R.l + (Peek.b(ptr+1)  & $FF) * fracx * ifracy
            G.l + (Peek.b(ptr+2)  & $FF) * fracx * ifracy
            B.l + (Peek.b(ptr+3)  & $FF) * fracx * ifracy

            If sx1i<sw-1 AND sy1i<sh-1 Then ptr = srcptr + (sy1i+1) * slinemod + sx1i * 4+4
            R.l + (Peek.b(ptr+1)  & $FF) * ifracx * ifracy
            G.l + (Peek.b(ptr+2)  & $FF) * ifracx * ifracy
            B.l + (Peek.b(ptr+3)  & $FF) * ifracx * ifracy

            col.l = B | (G LSL 8) | (R LSL 16) | $FF000000
            Poke.l destptr+x*4,col
          Next
        Else
          For x.l = dw/2-xs-1 To dw/2+xs
            sx1i.l = sx1
            sy1i.l = sy1
            sx1 + dx
            sy1 + dy
            ptr.l = srcptr + sy1i * slinemod + sx1i * 4
            col.l = Peek.l(ptr) | $FF000000
            Poke.l destptr+x*4,col
          Next
        End If
        destptr + dlinemod
      Next


    End If
    image_InitMask{dstimage}
    image_FreeAlpha{dstimage}
  End If
  !setfpcr{$0}
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !imagext_GetARGB {ptr.l,A.l,R.l,G.l,B.l}                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - ptr.l    : ???                                                            /
;/ - A.l    : ???                                                              /
;/ - R.l    : ???                                                              /
;/ - G.l    : ???                                                              /
;/ - B.l    : ???                                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro imagext_GetARGB ; {ptr.l,A.l,R.l,G.l,B.l}
  tempcol.l = Peek.l(`1)
  `5 = ((tempcol       ) & $FF )
  `4 = ((tempcol LSR 8 ) & $FF )
  `3 = ((tempcol LSR 16) & $FF )
  `2 = ((tempcol LSR 24) & $FF )
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !imagext_ClipARGB {A,R,G,B}                                         /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - A    : ???                                                                /
;/ - R    : ???                                                                /
;/ - G    : ???                                                                /
;/ - B    : ???                                                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro imagext_ClipARGB; {A,R,G,B}
  If `1>255 Then `1=255
  If `1<0   Then `1=0
  If `2>255 Then `2=255
  If `2<0   Then `2=0
  If `3>255 Then `3=255
  If `3<0   Then `3=0
  If `4>255 Then `4=255
  If `4<0   Then `4=0
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !imagext_median {A,count}                                           /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - A    : ???                                                                /
;/ - count    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro imagext_median ; {A,count}
  m.l = `2 : n.l = 0
  While `1>matrix3\coeff[n] AND n<m:n+1:Wend
  For i.l = m-1 To n Step-1 : matrix3\coeff[i+1] = matrix3\coeff[i]:Next
  matrix3\coeff[n] = `1
  `2+1
End Macro
 

;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !imagext_SetARGB {ptr.l,A.l,R.l,G.l,B.l}                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - ptr.l    : ???                                                            /
;/ - A.l    : ???                                                              /
;/ - R.l    : ???                                                              /
;/ - G.l    : ???                                                              /
;/ - B.l    : ???                                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro imagext_SetARGB; {ptr.l,A.l,R.l,G.l,B.l}
  Poke.l (`1),(`5) | ((`4) LSL 8) | ((`3) LSL 16) | ((`2) LSL 24)
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !imagext_MixARGB {ptr.l,A.l,R.l,G.l,B.l}                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - ptr.l    : ???                                                            /
;/ - A.l    : ???                                                              /
;/ - R.l    : ???                                                              /
;/ - G.l    : ???                                                              /
;/ - B.l    : ???                                                              /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro imagext_MixARGB; {ptr.l,A.l,R.l,G.l,B.l}
  __ARGB__.l = (`5) | ((`4) LSL 8) | ((`3) LSL 16) | ((`2) LSL 24)
  Poke.l (`1),((Peek.l(`1)&$FEFEFEFE) LSR 1) + ((__ARGB__&$FEFEFEFE) LSR 1)
End Macro



; calculate average color of the image
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_GetAvgARGB {image.l}                              /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_GetAvgARGB{image.l}
  sourcebase.l = \raw_ptr
  sourcebpr.l  = \bpr
  AVGRy.l = 0
  AVGGy.l = 0
  AVGBy.l = 0
  AVGAy.l = 0
  For y.l = 0 To \img_height-1
    AVGRx.l = 0
    AVGGx.l = 0
    AVGBx.l = 0
    AVGAx.l = 0
    srcptr.l = sourcebase + sourcebpr * y
    For x.l = 0 To \img_width-1
      col.l = Peek.l(srcptr)
      AVGBx + (col           & $FF )
      AVGGx + ((col LSR 8  ) & $FF )
      AVGRx + ((col LSR 16 ) & $FF )
      AVGAx + ((col LSR 24 ) & $FF )
      srcptr+4
    Next
    AVGRy + (AVGRx / \img_width)
    AVGGy + (AVGGx / \img_width)
    AVGBy + (AVGBx / \img_width)
    AVGAy + (AVGAx / \img_width)
  Next
  AVGRy / \img_height
  AVGGy / \img_height
  AVGBy / \img_height
  AVGAy / \img_height
  AVGARGB.l = AVGBy | (AVGGy LSL 8) | (AVGRy LSL 16) | (AVGAy LSL 24)
 Function Return AVGARGB
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Mix {sourceimage.l,destimage.l,mode.l,ratio.l}                         /
;/                                                                             /
;/ Description:                                                                /
;/ Mix two images in different possbile modes.                                 /
;/ NOTE: dirty                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - mode.l     : ???                                                          /
;/ - ratio.l    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Mix{srcimage.l,dstimage.l,mode.l,ratio.l}
 SHARED imagedat(),imageengine

  If image_IsUsed{dstimage} = False
    image_Create{dstimage,imagedat(srcimage)\img_width,imagedat(srcimage)\img_height,False,$0}
  End If

  destbase.l   = image_GetARGBPtr{dstimage}
  sourcebase.l = image_GetARGBPtr{srcimage}

  If destbase.l = 0 OR sourcebase =0 Then Statement Return

  sourcebpr.l = imagedat(srcimage)\bpr ; img_width*4
  destbpr.l   = imagedat(dstimage)\bpr ; img_width*4

  mxs.l = Min(imagedat(srcimage)\img_width ,imagedat(dstimage)\img_width) -1
  mys.l = Min(imagedat(srcimage)\img_height,imagedat(dstimage)\img_height) -1

  Select mode
    Case #image_blitmode_trans
      mix.l = ratio.l
      imix.l = 256-ratio
      For y.l = 0 To mys
        For x.l = 0 To mxs
          sourceptr.l = sourcebase + sourcebpr * y + (x LSL 2)
          !imagext_GetARGB{sourceptr,A1.l,R1.l,G1.l,B1.l}
          destptr.l = destbase + destbpr * y + (x LSL 2)
          !imagext_GetARGB{destptr,A2.l,R2.l,G2.l,B2.l}
          R.l = (R1*mix + R2*imix) ASR 8
          G.l = (G1*mix + G2*imix) ASR 8
          B.l = (B1*mix + B2*imix) ASR 8
          A.l = (A1*mix + A2*imix) ASR 8
          !imagext_ClipARGB{A,R,G,B}
          !imagext_SetARGB{destptr,A,R,G,B}
        Next
      Next

    Case #image_blitmode_add
      mix.l = ratio.l
      For y.l = 0 To mys
        For x.l = 0 To mxs
          sourceptr.l = sourcebase + sourcebpr * y + (x LSL 2)
          !imagext_GetARGB{sourceptr,A1.l,R1.l,G1.l,B1.l}
          destptr.l = destbase + destbpr * y + (x LSL 2)
          !imagext_GetARGB{destptr,A2.l,R2.l,G2.l,B2.l}
          R.l = R2 + ((R1 * mix) ASR 8)
          G.l = G2 + ((G1 * mix) ASR 8)
          B.l = B2 + ((B1 * mix) ASR 8)
          A.l = A2 + ((A1 * mix) ASR 8)
          !imagext_ClipARGB{A,R,G,B}
          !imagext_SetARGB{destptr,A,R,G,B}
        Next
      Next

    Case #image_blitmode_opaque
      ratio / 3
      For y.l = 0 To mys
        For x.l = 0 To mxs
          sourceptr.l = sourcebase + sourcebpr * y + (x LSL 2)
          col.l = Peek.l(sourceptr)
          R1.l = (col           & $FF )
          G1.l = ((col LSR 8  ) & $FF )
          B1.l = ((col LSR 16 ) & $FF )

          destptr.l = destbase + destbpr * y + (x LSL 2)
          col.l = Peek.l(destptr)
          R2.l = (col           & $FF )
          G2.l = ((col LSR 8  ) & $FF )
          B2.l = ((col LSR 16 ) & $FF )

          A.l = (R2+G2+B2)
          mix.l = (A * ratio) LSR 8
          If mix>256 Then mix = 256
          imix = 256-mix

          R.l = (R1*imix + R2*mix) ASR 8
          G.l = (G1*imix + G2*mix) ASR 8
          B.l = (B1*imix + B2*mix) ASR 8
          If R>255 Then R=255
          If G>255 Then G=255
          If B>255 Then B=255
          If R<0 Then R=0
          If G<0 Then G=0
          If B<0 Then B=0

          Poke.l destptr,(R) | (G LSL 8) | (B LSL 16)
        Next
      Next

    Case #image_blitmode_alpha
      ratio / 3
      For y.l = 0 To mys
        For x.l = 0 To mxs
          sourceptr.l = sourcebase + sourcebpr * y + (x LSL 2)
          col.l = Peek.l(sourceptr)
          R1.l = (col           & $FF )
          G1.l = ((col LSR 8  ) & $FF )
          B1.l = ((col LSR 16 ) & $FF )

          destptr.l = destbase + destbpr * y + (x LSL 2)
          col.l = Peek.l(destptr)
          R2.l = (col           & $FF )
          G2.l = ((col LSR 8  ) & $FF )
          B2.l = ((col LSR 16 ) & $FF )

          A.l = (R1+G1+B1)
          mix.l = (A * ratio) LSR 8
          If mix>256 Then mix = 256
          imix = 256-mix

          R.l = (R1*mix + R2*imix) ASR 8
          G.l = (G1*mix + G2*imix) ASR 8
          B.l = (B1*mix + B2*imix) ASR 8
          If R>255 Then R=255
          If G>255 Then G=255
          If B>255 Then B=255
          If R<0 Then R=0
          If G<0 Then G=0
          If B<0 Then B=0
          Poke.l destptr,(R) | (G LSL 8) | (B LSL 16)
        Next
      Next


    Case #image_blitmode_mul
      ;ratio * 256 / 255
      offset.l = 256-ratio
      For y.l = 0 To mys
        For x.l = 0 To mxs
          sourceptr.l = sourcebase + (sourcebpr * y) + (x LSL 2)
          col.l = Peek.l(sourceptr)
          R1.l = (((col           & $FF ) * ratio) ASR 8) + offset
          G1.l = ((((col LSR 8  ) & $FF ) * ratio) ASR 8) + offset
          B1.l = ((((col LSR 16 ) & $FF ) * ratio) ASR 8) + offset

          destptr.l = destbase + (destbpr * y) + (x LSL 2)
          col.l = Peek.l(destptr)
          R2.l = (col           & $FF )
          G2.l = ((col LSR 8  ) & $FF )
          B2.l = ((col LSR 16 ) & $FF )

          R.l = (R1*R2) ASR 8
          G.l = (G1*G2) ASR 8
          B.l = (B1*B2) ASR 8
          If R>255 Then R=255
          If G>255 Then G=255
          If B>255 Then B=255
          If R<0 Then R=0
          If G<0 Then G=0
          If B<0 Then B=0

          Poke.l destptr,(R) | (G LSL 8) | (B LSL 16)
        Next
      Next

    Case #image_blitmode_muladd
      For y.l = 0 To mys
        For x.l = 0 To mxs
          sourceptr.l = sourcebase + (sourcebpr * y) + (x LSL 2)
          col.l = Peek.l(sourceptr)
          R1.l = (((col           & $FF ) * ratio) ASR 8)
          G1.l = ((((col LSR 8  ) & $FF ) * ratio) ASR 8)
          B1.l = ((((col LSR 16 ) & $FF ) * ratio) ASR 8)

          destptr.l = destbase + (destbpr * y) + (x LSL 2)
          col.l = Peek.l(destptr)
          R2.l = (col           & $FF )
          G2.l = ((col LSR 8  ) & $FF )
          B2.l = ((col LSR 16 ) & $FF )

          R.l = (R1*R2) ASR 8
          G.l = (G1*G2) ASR 8
          B.l = (B1*B2) ASR 8
          If R>255 Then R=255
          If G>255 Then G=255
          If B>255 Then B=255
          If R<0 Then R=0
          If G<0 Then G=0
          If B<0 Then B=0

          Poke.l destptr,(R) | (G LSL 8) | (B LSL 16)
        Next
      Next



    Case #image_blitmode_shadow
      grad.l = 1
      ;image_SetAlpha{dstimage,0}
      If grad
        minWinkel.f = ((256*3)/ratio)
      End If

      For y.l = 0 To mys
        For x.l = 0 To mxs
          sourceptr.l = sourcebase + sourcebpr * y + (x LSL 2)
          destptr.l = destbase + destbpr * y + (x LSL 2)
          !imagext_GetARGB{sourceptr,AX.l,R1.l,G1.l,B1.l}
          !imagext_GetARGB{  destptr, A.l, R.l, G.l, B.l}

          H.l = R1+G1+B1
          diff.l=256
          shadow.l = 0
          For count.l = 1 To ratio-1
            tx.l = x - count
            ty.l = y - count
            While tx>=mxs : tx-mxs : Wend
            While ty>=mys : ty-mys : Wend
            While tx<0 : tx+mxs : Wend
            While ty<0 : ty+mys : Wend

            sourceptr.l = sourcebase + sourcebpr * ty + (tx LSL 2)
            !imagext_GetARGB{sourceptr,AX.l,R2.l,G2.l,B2.l}
            tH.l = (R2+G2+B2)
            If tH>H
              If grad
                Gegenkathede.f = tH-H
                Ankathede.f    = count
                Winkel.f = (Gegenkathede/Ankathede)
                If Winkel.f>minWinkel Then shadow+(Winkel*10)
              Else
                tH.l = tH * (ratio-count) / ratio
                If tH>H
                  diff.l = Min(diff,(256-(tH-H)*8) )
                End If
              End If
            End If
          Next
          If grad
            If shadow>0
              diff.l = (ratio-shadow)*256/ratio
              If diff<96 Then diff=96
              R = (R * diff) LSR 8
              G = (G * diff) LSR 8
              B = (B * diff) LSR 8
            End If
          Else
          If diff<256
            If diff<96 Then diff=96
            R = (R * diff) LSR 8
            G = (G * diff) LSR 8
            B = (B * diff) LSR 8

            If R>255 Then R=255
            If G>255 Then G=255
            If B>255 Then B=255
            If R<0 Then R=0
            If G<0 Then G=0
            If B<0 Then B=0
          End If
          End If
          !imagext_SetARGB{destptr,AX,R,G,B}
        Next
      Next

    Case #image_blitmode_bump ; bump map
      ratio*4
      For y.l = 0 To mys
        For x.l = 0 To mxs
          destptr.l = destbase + destbpr * y + (x LSL 2)
          !imagext_GetARGB{destptr,AX.l,R1.l,G1.l,B1.l}

          sourceptr.l = sourcebase + sourcebpr * y + (x LSL 2)
          col.l = Peek.l(sourceptr)
          R.l = (col           & $FF )
          G.l = ((col LSR 8  ) & $FF )
          B.l = ((col LSR 16 ) & $FF )
          A.l = (R+G+B) LSL 8
          A.l + (col LSR 24) *3

          sx.l = x -1;* imagedat(image)\img_width / imagedat(image2)\img_width  -1
          If sx<0 Then sx + imagedat(srcimage)\img_width
          sourceptr.l = sourcebase + sourcebpr * y + (sx LSL 2)
          col.l = Peek.l(sourceptr)
          R.l = (col           & $FF )
          G.l = ((col LSR 8  ) & $FF )
          B.l = ((col LSR 16 ) & $FF )
          Ar.l = (R+G+B) LSL 8
          Ar.l + (col LSR 24) *3

          sy.l = y -1;* imagedat(image)\img_height / imagedat(image2)\img_height -1
          If sy<0 Then sy + imagedat(srcimage)\img_height
          sourceptr.l = sourcebase + sourcebpr * sy + (x LSL 2)
          col.l = Peek.l(sourceptr)
          R.l = (col           & $FF )
          G.l = ((col LSR 8  ) & $FF )
          B.l = ((col LSR 16 ) & $FF )
          Ao.l = (R+G+B) LSL 8
          Ao.l + (col LSR 24) *3

          mix.l = ((((2*A-Ar-Ao)) * ratio) ASR 16) + 256
          If mix<0 Then mix=0
          If mix>512 Then mix=512

          R.l = (R1*mix) ASR 8
          G.l = (G1*mix) ASR 8
          B.l = (B1*mix) ASR 8
          If R>255 Then R=255
          If G>255 Then G=255
          If B>255 Then B=255
          If R<0 Then R=0
          If G<0 Then G=0
          If B<0 Then B=0

          !imagext_SetARGB{destptr,AX,R,G,B}
        Next
      Next
  End Select
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Smooth {image.l,smoothing.l,@image2.l}                        /
;/                                                                             /
;/ Description:                                                                /
;/ Smooth an image.                                                            /
;/ Note: dirty                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - smoothing.l    : ???                                                      /
;/ - image2.l    : ???                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Smooth{image.l,smoothing.l,@image2.l}
 SHARED imagedat(),imageengine

  sourcebase.l = \raw_ptr
  If image2>=0
    image_Create{image2,\img_width,\img_height,False,$00FF0000}
    destbase.l = imagedat(image2)\raw_ptr
  Else
    destbase.l = sourcebase
    image_Release{image}
  End If
  If destbase.l = 0 OR sourcebase =0 Then Statement Return
  If image_AreCompatible{image,image2}=False Then Statement Return

  If smoothing<1
    If sourcebase><destbase
      CopyMem_ sourcebase,destbase,\img_height*\bpr
    End If
    Statement Return
  End If

  sourcebpr.l = \bpr
  destbpr.l   = imagedat(image2)\bpr
  wrapx.l     = \img_width -1
  wrapy.l     = \img_height-1

  mw.l = 100
  sw.l = 100 * smoothing / 256
  cw.l = sw/2

  ww.l = mw + sw * 4 + cw * 4


  For y.l = 0 To \img_height-1
    yo.l = y -1 : If yo<0 Then yo = wrapy
    yu.l = y +1 : If yu>wrapy Then yu=0

    For x.l = 0 To \img_width-1
      xl.l = x -1 : If xl<0 Then xl = wrapx
      xr.l = x +1 : If xr>wrapx Then xr=0

      ; middle
      srcptr.l = sourcebase + sourcebpr * y + (x LSL 2)
      col.l = Peek.l(srcptr)
      RM.l = (col           & $FF )
      GM.l = ((col LSR 8  ) & $FF )
      BM.l = ((col LSR 16 ) & $FF )

      ; cross
      srcptr = sourcebase + sourcebpr * yo + (x LSL 2)
      col = Peek.l(srcptr)
      RS.l = (col           & $FF )
      GS.l = ((col LSR 8  ) & $FF )
      BS.l = ((col LSR 16 ) & $FF )

      srcptr = sourcebase + sourcebpr * yu + (x LSL 2)
      col = Peek.l(srcptr)
      RS + (col           & $FF )
      GS + ((col LSR 8  ) & $FF )
      BS + ((col LSR 16 ) & $FF )

      srcptr = sourcebase + sourcebpr * y + (xl LSL 2)
      col = Peek.l(srcptr)
      RS + (col           & $FF )
      GS + ((col LSR 8  ) & $FF )
      BS + ((col LSR 16 ) & $FF )

      srcptr = sourcebase + sourcebpr * y + (xr LSL 2)
      col = Peek.l(srcptr)
      RS + (col           & $FF )
      GS + ((col LSR 8  ) & $FF )
      BS + ((col LSR 16 ) & $FF )

      ; diagonals
      srcptr = sourcebase + sourcebpr * yo + (xl LSL 2)
      col = Peek.l(srcptr)
      RC.l = (col           & $FF )
      GC.l = ((col LSR 8  ) & $FF )
      BC.l = ((col LSR 16 ) & $FF )


      srcptr = sourcebase + sourcebpr * yo + (xr LSL 2)
      col = Peek.l(srcptr)
      RC + (col           & $FF )
      GC + ((col LSR 8  ) & $FF )
      BC + ((col LSR 16 ) & $FF )


      srcptr = sourcebase + sourcebpr * yu + (xl LSL 2)
      col = Peek.l(srcptr)
      RC + (col           & $FF )
      GC + ((col LSR 8  ) & $FF )
      BC + ((col LSR 16 ) & $FF )


      srcptr = sourcebase + sourcebpr * yu + (xr LSL 2)
      col = Peek.l(srcptr)
      RC + (col           & $FF )
      GC + ((col LSR 8  ) & $FF )
      BC + ((col LSR 16 ) & $FF )


      R.l = ((RM*mw + RS*sw + RC*cw) / ww)& $FF
      G.l = ((GM*mw + GS*sw + GC*cw) / ww)& $FF
      B.l = ((BM*mw + BS*sw + BC*cw) / ww)& $FF

      destptr.l = destbase + destbpr * y + (x LSL 2)
      Poke.l destptr,(R LSL 0) | (G LSL 8) | (B LSL 16)
    Next
  Next
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: _image_ConeBlit_old {image.l,x1.l,y1.l,x2.l,y2.l,fat1.f,fat2.f,an:: /
;/ gle.f,light.f}                                                              /
;/                                                                             /
;/ Description:                                                                /
;/ NOTE: dirty                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - x1.l    : ???                                                             /
;/ - y1.l    : ???                                                             /
;/ - x2.l    : ???                                                             /
;/ - y2.l    : ???                                                             /
;/ - fat1.f    : ???                                                           /
;/ - fat2.f    : ???                                                           /
;/ - angle.f    : ???                                                          /
;/ - light.f    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement _image_ConeBlit_old{image.l,x1.l,y1.l,x2.l,y2.l,fat1.f,fat2.f,angle.f,light.f}
 SHARED imagedat()

  dx.f = x2-x1
  dy.f = y2-y1
  l.f = Sqr(dx*dx + dy*dy)
  sl.f = l * 1.41
  dx / sl
  dy / sl
  dfx.f = (fat2-fat1)           / sl
  dfy.f = (fat2-fat1)  * angle  / sl
  x.f = x1
  y.f = y1

  pi2.f = 2*Pi
  !setfpcr{$10}
  width.f = \img_width
  height.f = \img_height
  sourcebpr.l = \bpr
  rx.f = fat1
  ry.f = fat1 * angle

  sourcebase.l = \raw_ptr

  For s.f = 0 To sl
    img_y.f = s * height/ sl
    For a.f = 0 To pi2  Step Pi/fat1/4
      xl.f = rx * Cos(a+light)
      yl.f = ry * Sin(a+light)

      If a<Pi
        If a<Pi/2
          bright.f = a/Pi*2*256
        Else
          bright.f = 256-(a/Pi*2*256 - 256)
        End If

      Else
        bright=0
      End If
      bright + 100

      scr_x.f = x + yl * dx - xl * dy
      scr_y.f = y + xl * dx + yl * dy

      img_x.f = a * width / pi2
      ix.l = img_x
      iy.l = img_y
      srcptr.l = sourcebase + sourcebpr * iy + (ix LSL 2)
      col.l = Peek.l(srcptr)
      R.l = (col           & $FF ) * bright / 256 : If R>255 Then R=255
      G.l = ((col LSR 8  ) & $FF ) * bright / 256 : If G>255 Then G=255
      B.l = ((col LSR 16 ) & $FF ) * bright / 256 : If B>255 Then B=255

      RGBA.l = (R LSL 0) | (G LSL 8) | (B LSL 16)
      WriteRGBPixel_ RastPort,scr_x,scr_y,RGBA
    Next
    x+dx
    y+dy
    rx+dfx
    ry+dfy
  Next
End Statement



NEWTYPE.texcone
  x1.l
  y1.l
  z1.l
  x2.l
  y2.l
  z2.l
  fat1.f
  fat2.f
  angle.f
  light_angle.f
  light_ambient.f
  light_glow.f
  light_max.f
  blow.f
  texmod.f
  texrot.f
  textwist.f
End NEWTYPE



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_ConeBlit {image.l,*tc.texcone,@image2.l,@*rp.RastPort,@zbuf:: /
;/ fer.l}                                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ NOTE: dirty                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - *tc.texcone    : ???                                                      /
;/ - image2.l    : ???                                                         /
;/ - *rp.RastPort    : ???                                                     /
;/ - zbuffer.l    : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_ConeBlit{image.l,*tc.texcone,@image2.l,@*rp.RastPort,@zbuffer.l}
 SHARED imagedat()

  dx.f = *tc\x2-*tc\x1
  dy.f = *tc\y2-*tc\y1
  dz.f = *tc\z2-*tc\z1

  l.f = Sqr(dx*dx + dy*dy)
  sl.f = l * 1.41
  dx / sl
  dy / sl
  dz / sl
  dfx.f = (*tc\fat2-*tc\fat1)               / sl
  dfy.f = (*tc\fat2-*tc\fat1)  * *tc\angle  / sl
  dfz.f = (*tc\fat2-*tc\fat1)               / sl
  x.f = *tc\x1
  y.f = *tc\y1
  z.f = *tc\z1

  pi2.f = 2*Pi
  !setfpcr{$10}
  width.f     = \img_width
  height.f    = \img_height
  iwidth.l     = \img_width
  iheight.l    = \img_height


  sourcebpr.l = \bpr
  rx.f        = *tc\fat1
  ry.f        = *tc\fat1 * *tc\angle
  rz.f        = *tc\fat1
  ;fat.f       = *tc\fat1
  ;df.f        =
  sourcebase.l = \raw_ptr

  If *tc\texmod=0 Then *tc\texmod = 1

  texmod.f = *tc\texmod
  texrot.f = *tc\texrot
  textwist.f = *tc\textwist
  texrot + textwist

  dtwist.f = -textwist / sl


  If image2>=0
    destbase.l   = imagedat(image2)\raw_ptr
    destbpr.l    = imagedat(image2)\bpr
    destheight.l = imagedat(image2)\img_height
    destwidth.l  = imagedat(image2)\img_width
  End If

  If zbuffer=-1 Then zbuffer=0

  For s.f = 0 To sl
    img_y.f = s * height/ sl
    blow.f = 1 + ((Sin(s*Pi/sl)) * *tc\blow)
    stepping.f = Pi/rx/5 * 2
    For a.f = 0 To pi2  Step stepping
      xl.f = rx * Cos(a+*tc\light_angle) * blow
      yl.f = ry * Sin(a+*tc\light_angle) * blow
      zl.f = Sqr(rx*rx - xl*xl - yl*yl)  * blow
      If a>Pi-*tc\light_angle AND a<Pi*2-*tc\light_angle Then zl = -zl
      If a<Pi
        ; the bright side with glow
        bright.f = *tc\light_ambient + *tc\light_glow * (Pi/2 - Abs(Pi/2-a))
        If bright>*tc\light_max Then bright = *tc\light_max
      Else
        ; the dark side ...
        bright=*tc\light_ambient
      End If

      scr_x.f = x + yl * dx - xl * dy
      scr_y.f = y + xl * dx + yl * dy
      scr_z.f = z + zl

      img_x.f = ((a+texrot) * width / pi2) * texmod

      ix.l = img_x
      iy.l = img_y
      While ix>=iwidth : ix-iwidth : Wend
      srcptr.l = sourcebase + sourcebpr * iy + (ix LSL 2)
      col.l = Peek.l(srcptr)
      R.l = (col           & $FF ) * bright : R ASR 8 : If R>255 Then R=255
      G.l = ((col LSR 8  ) & $FF ) * bright : G ASR 8 : If G>255 Then G=255
      B.l = ((col LSR 16 ) & $FF ) * bright : B ASR 8 : If B>255 Then B=255

      RGBX.l = (R) | (G LSL 8) | (B LSL 16)
      scr_ix.l = scr_x
      scr_iy.l = scr_y
      scr_z + 100000

      If scr_x>=0 AND scr_y>=0
        If zbuffer
          zptr.l = zbuffer + destbpr * scr_iy + (scr_ix LSL 2)
          zdepth.f = Peek.f(zptr)
        Else
          zdepth.f = 0
          zptr=0
        End If

        If zdepth < scr_z
          If zptr Then Poke.f zptr,scr_z
          If *rp
            ;Wline x,y,scr_x,scr_y,2
            WriteRGBPixel_ *rp,scr_x,scr_y,RGBX
          End If
          If destbase ><0 AND scr_x<destwidth AND scr_y<destheight
            destptr.l = destbase + destbpr * scr_iy + (scr_ix LSL 2)
            Poke.l destptr,RGBX
          End If
        End If
      End If
    Next
    x+dx
    y+dy
    z+dz
    rx+dfx
    ry+dfy
    rz+dfz
    texrot + dtwist
  Next
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_nrnd {seed}                                                  /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - seed    : ???                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_nrnd ;{seed}
  `1 * 196314165 + 907633515
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_rnd255 {seed}                                                /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - seed    : ???                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_rnd255 ;{seed}
  ((`1 LSR 23) & $FF)
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_rndf {seed}                                                  /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - seed    : ???                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_rndf ;{seed}
  ((`1 & $7FFFFFFF) / $7FFFFFFF)
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !image_rndset {seed,value}                                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - seed    : ???                                                             /
;/ - value    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro image_rndset ;{seed,value}
  `1 = `2
End Macro



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_IlluminateRGB {RGBA.l,brightness.f}               /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - RGBA.l    : ???                                                           /
;/ - brightness.f    : ???                                                     /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_IlluminateRGB{RGBA.l,brightness.f}
  If brightness<0 Then Function Return 0
  b.l = brightness * 256
  R.l = (RGBA           & $FF ) * b LSR 8  : If R>255 Then R=255
  G.l = ((RGBA LSR 8  ) & $FF ) * b LSR 8  : If G>255 Then G=255
  B.l = ((RGBA LSR 16 ) & $FF ) * b LSR 8  : If B>255 Then B=255
 Function Return (R LSL 0) | (G LSL 8) | (B LSL 16)
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax:  result.l = image_GetBrightness {RGBA.l}                            /
;/                                                                             /
;/ Description:                                                                /
;/ Get the brightness of an RGB value                                          /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - RGBA.l    : ???                                                           /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_GetBrightness{RGBA.l}
  R.l = (RGBA           & $FF )
  G.l = ((RGBA LSR 8  ) & $FF )
  B.l = ((RGBA LSR 16 ) & $FF )
 Function Return (R + G + B) / 3
End Function



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_DryMudFilter {image.l,image2.l,@opacity.l,@threshold.l}       /
;/                                                                             /
;/ Description:                                                                /
;/ NOTE: dirty                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - image2.l    : ???                                                         /
;/ - opacity.l    : ???                                                        /
;/ - threshold.l    : ???                                                      /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_DryMudFilter{image.l,image2.l,@opacity.l,@threshold.l}
 SHARED imagedat(),imageengine

  If image_IsUsed{image2} = False
    image_Create{image2,\img_width,\img_height,False,$0}
  End If

  destbase.l   = imagedat(image2)\raw_ptr
  sourcebase.l = \raw_ptr

  If destbase.l = 0 OR sourcebase =0 Then Statement Return

  sourcebpr.l = \bpr ; img_width*4
  destbpr.l = imagedat(image2)\bpr ; img_width*4

  mxs.l = Min(\img_width,imagedat(image2)\img_width) -1
  mys.l = Min(\img_height,imagedat(image2)\img_height) -1

      mix.l = ratio.l
      imix.l = 256-ratio

  If threshold<0 Then threshold.l = 96

      For y.l = 0 To mys
        For x.l = 0 To mxs
          sourceptr.l = sourcebase + sourcebpr * y + (x LSL 2)
          col.l = Peek.l(sourceptr)
          R1.l = (col           & $FF )
          G1.l = ((col LSR 8  ) & $FF )
          B1.l = ((col LSR 16 ) & $FF )

      A.l = R1 + G1 + B1 - threshold
      If A<0 Then A=0-A
      ;A/3
      ;A=(A*A)
      A * opacity / 100
      imix.l = 256-A

      If imix<0 Then imix=0
      imix * opacity/100

          destptr.l = destbase + destbpr * y + (x LSL 2)
          col.l = Peek.l(destptr)
          R2.l = (col           & $FF )
          G2.l = ((col LSR 8  ) & $FF )
          B2.l = ((col LSR 16 ) & $FF )

      R.l = R2-(((imix*R1) ASR 8))
      G.l = G2-(((imix*G1) ASR 8))
      B.l = B2-(((imix*B1) ASR 8))


          If R>255 Then R=255
          If G>255 Then G=255
          If B>255 Then B=255
          If R<0 Then R=0
          If G<0 Then G=0
          If B<0 Then B=0

          Poke.l destptr,(R) | (G LSL 8) | (B LSL 16)
        Next
      Next
End Statement



;dirty
#image_flipx  = 1
#image_flipy  = 2
#image_flipdot = #image_flipx | #image_flipy
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Mirror {image.l,direction.l,@image2.l}                        /
;/                                                                             /
;/ Description:                                                                /
;/ sourcebpr.l = \bpr ; img_width*4                                            /
;/ destbpr.l = imagedat(image2)\bpr ; img_width*4                              /
;/     ;A/3                                                                    /
;/     ;A=(A*A)                                                                /
;/ dirty                                                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - direction.l    : ???                                                      /
;/ - image2.l    : ???                                                         /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Mirror{image.l,direction.l,@image2.l}
 SHARED imagedat(),imageengine

  If image2=-1
    image2=image
  Else
    image_Cut{image2,image,0,0,\img_width,\img_height}
  End If

  destbase.l   = imagedat(image2)\raw_ptr
  sourcebase.l = \raw_ptr

  If destbase.l = 0 OR sourcebase =0 Then Statement Return

  sourcebpr.l = \bpr ; img_width*4
  destbpr.l = imagedat(image2)\bpr ; img_width*4

  mxs.l = Min(\img_width,imagedat(image2)\img_width) -1
  mys.l = Min(\img_height,imagedat(image2)\img_height) -1

  If direction & #image_flipx
      For ry.l = 0 To mys
        wx.l=mxs
        For rx.l = 0 To mxs/2
          destptrA.l = destbase + destbpr * ry + (rx LSL 2)
          destptrB.l = destbase + destbpr * ry + (wx LSL 2)
          colA.l = Peek.l(destptrA)
          colB.l = Peek.l(destptrB)
          Poke.l destptrA,colB
          Poke.l destptrB,colA
          wx-1
        Next
      Next
  End If

  If direction & #image_flipy
      wy.l = mys
      For ry.l = 0 To mys/2
        For rx.l = 0 To mxs
          destptrA.l = destbase + destbpr * ry + (rx LSL 2)
          destptrB.l = destbase + destbpr * wy + (rx LSL 2)
          colA.l = Peek.l(destptrA)
          colB.l = Peek.l(destptrB)
          Poke.l destptrA,colB
          Poke.l destptrB,colA
        Next
        wy-1
      Next
  End If
  image_Release{image2}
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Rotate {image.l,beta.f,@image2.l}                             /
;/                                                                             /
;/ Description:                                                                /
;/ Rotate an image by the angle of beta.                                       /
;/ beta is in clockwise degrees.                                               /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : image to rotate                                              /
;/ - beta.f     : angle of rotation                                            /
;/ - image2.l   : optional destination image, if different from source image   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Rotate{image.l,beta.f,@image2.l}
 SHARED imagedat(),imageengine

  If image2=-1 Then image2=image_GetFree{} : own.l =-1:Else own=0
  If image2<0 Then Statement Return
  ys.l = -1
  xs.l = -1

  ; normalize beta
  While beta<0 : beta + 360 : Wend
  While beta>=360 : beta - 360 : Wend

  If beta=90 OR beta=270 Then xs.l = \img_height : ys.l = \img_width
  If beta=180 Then ys.l = \img_height : xs.l = \img_width

  If xs=-1 OR ys=-1
    xs.l = Sqr(\img_width*\img_width + \img_height*\img_height)
    ys.l = xs
  End If
  If image_Create{image2,xs,ys,False,$0} = False Then Statement Return

  destbase.l   = imagedat(image2)\raw_ptr
  sourcebase.l = \raw_ptr

  If destbase.l = 0 OR sourcebase =0 Then Statement Return

  sourcebpr.l = \bpr ; img_width*4
  destbpr.l = imagedat(image2)\bpr ; img_width*4

  mxs.l = imagedat(image2)\img_width -1
  mys.l = imagedat(image2)\img_height -1
  done.l = False
  If beta=180
    wy.l = mys
    For ry.l = 0 To mys/2
      wx.l = mxs
      For rx.l = 0 To mxs/2
        sourceptrA.l = sourcebase + sourcebpr * ry + (rx LSL 2)
        sourceptrB.l = sourcebase + sourcebpr * wy + (rx LSL 2)
        sourceptrC.l = sourcebase + sourcebpr * ry + (wx LSL 2)
        sourceptrD.l = sourcebase + sourcebpr * wy + (wx LSL 2)
        colA.l = Peek.l(sourceptrA)
        colB.l = Peek.l(sourceptrB)
        colC.l = Peek.l(sourceptrC)
        colD.l = Peek.l(sourceptrD)
        destptrA.l = destbase + destbpr * ry + (rx LSL 2)
        destptrB.l = destbase + destbpr * wy + (rx LSL 2)
        destptrC.l = destbase + destbpr * ry + (wx LSL 2)
        destptrD.l = destbase + destbpr * wy + (wx LSL 2)
        Poke.l destptrA,colD
        Poke.l destptrB,colC
        Poke.l destptrC,colB
        Poke.l destptrD,colA
        wx-1
      Next
      wy-1
    Next
    done=True
  End If

  If beta=90 OR beta=270
    If beta=90 Then dx.l=-1:dy.l=1:iwx.l=mxs:iwy.l=0:Else dx=1:dy=-1:iwx=0:iwy=mys
    wy.l = iwy
    For ry.l = 0 To mys
      wx.l = iwx
      For rx.l = 0 To mxs
        sourceptrA.l = sourcebase + sourcebpr * rx + (ry LSL 2)
        colA.l = Peek.l(sourceptrA)
        destptrA.l = destbase + destbpr * wy + (wx LSL 2)
        Poke.l destptrA,colA
        wx+dx
      Next
      wy+dy
    Next
    done=True
  End If

  If done=False
    *rp.RastPort =image_GetRPPtr{image2}
    image_MidHandle{image}
    alpha.f = beta * 2*Pi/360
    image_RotateBlit{image,xs/2,ys/2,alpha,-1,False,*rp}
  End If

  If own=-1
    image_Cut{image,image2}
    image_Free{image2}
  End If
End Statement



#IMFA_BASE         = #TAG_USER
#IMFA_TYPE         =  0 + #IMFA_BASE
#IMFA_RED          =  1 + #IMFA_BASE
#IMFA_GREEN        =  2 + #IMFA_BASE
#IMFA_BLUE         =  3 + #IMFA_BASE
#IMFA_ALPHA        =  4 + #IMFA_BASE
#IMFA_ALPHAWEIGHT  =  5 + #IMFA_BASE
#IMFA_REDWEIGHT    =  6 + #IMFA_BASE
#IMFA_GREENWEIGHT  =  7 + #IMFA_BASE
#IMFA_BLUEWEIGHT   =  8 + #IMFA_BASE
#IMFA_MATHGRAY     =  9 + #IMFA_BASE
#IMFA_NATURALGRAY  = 10 + #IMFA_BASE
#IMFA_MASK         = 11 + #IMFA_BASE
#IMFA_MATRIX3      = 12 + #IMFA_BASE
#IMFA_ARGB         = 13 + #IMFA_BASE

#image_filter_night        = 1
#image_filter_contrast     = 2
#image_filter_gray         = 3
#image_filter_saturation   = 4
#image_filter_brightness   = 5
#image_filter_gamma        = 6
#image_filter_sepia        = 7
#image_filter_invert       = 8
#image_filter_sharpen      = 9
#image_filter_smooth       = 10
#image_filter_edge         = 11
#image_filter_convolution3 = 12
#image_filter_tint         = 13
#image_filter_mul          = 14
#image_filter_bias         = 15
#image_filter_screen       = 16
#image_filter_threshold    = 17
#image_filter_dither       = 18
#image_filter_median3      = 19
#image_filter_embross      = 20
#image_filter_glow         = 21
#image_filter_mix          = 22
#image_filter_opacity      = 23
#image_filter_fire         = 24
#image_filter_blur         = 25
#image_filter_sqr          = 26
#image_filter_lowpass      = 27
#image_filter_lowpassY     = 28
#image_filter_highpass     = 29
#image_filter_highpassY    = 30
#image_filter_121          = 31
#image_filter_sharpenY     = 32
#image_filter_glare        = 33
#image_filter_color        = 34
#image_filter_yuv2rgb      = 35
#image_filter_rgb2yuv      = 36
#image_filter_mediansharpen = 37
#image_filter_mediansharpenY = 38
#image_filter_restorealphafromblackandwhite = 39


NEWTYPE.matrix3
  coeff.l[10]
End NEWTYPE


NEWTYPE.lutRGB
  r.l[256]
  g.l[256]
  b.l[256]
End NEWTYPE



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: result.l = image_Filter {image.l,filterType.l,mix.l,@*taglist.Tag:: /
;/ Item,@destimage.l}                                                          /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - filterType.l    : ???                                                     /
;/ - mix.l    : ???                                                            /
;/ - *taglist.TagItem    : ???                                                 /
;/ - destimage.l    : ???                                                      /
;/                                                                             /
;/ Result:                                                                     /
;/ - result.l     : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Function.l image_Filter{image.l,filterType.l,mix.l,@*taglist.TagItem,@destimage.l}
  If image_IsUsed{image} = False Then Function Return False
  ret.l = True

  If destimage=-1
    destimage  = image
  End If

  If image_IsUsed{destimage}=False OR image_AreCompatible{destimage,image}=False
    If image_Create{destimage,\img_width,\img_height} = False Then Function Return False
  Else
    image_FreeBitMap{destimage}
  End If

  sourcebase.l = \raw_ptr
  sourcebpr.l  = \bpr
  destbase.l   = imagedat(destimage)\raw_ptr
  destbpr.l    = imagedat(destimage)\bpr

  *matrix3.matrix3 = 0

  ; source coo
  sx1.l         = 0
  sy1.l         = 0
  sx2.l        = \img_width  -1
  sy2.l        = \img_height -1

  ; destination coo
  dx1.l         = 0
  dy1.l         = 0
  dx2.l        = imagedat(destimage)\img_width  -1
  dy2.l        = imagedat(destimage)\img_height -1

  ; component weight
  wA.l = 0
  wR.l = 256 * 30 / 100
  wG.l = 256 * 59 / 100
  wB.l = 256 * 11 / 100

  ; destination color
  dA.l = 255
  dR.l = 255
  dB.l = 255
  dG.l = 255

  ; mask
  mask.l = $FFFFFFFF

  DEFTYPE.matrix3 matrix3

  If *taglist><0 AND *taglist><-1
    While *taglist\ti_Tag><#TAG_DONE
      Select *taglist\ti_Tag
        Case #IMFA_ALPHA         : dA = *taglist\ti_Data
        Case #IMFA_ALPHAWEIGHT   : wA = *taglist\ti_Data
        Case #IMFA_RED           : dR = *taglist\ti_Data
        Case #IMFA_REDWEIGHT     : wR = *taglist\ti_Data
        Case #IMFA_GREEN         : dG = *taglist\ti_Data
        Case #IMFA_GREENWEIGHT   : wG = *taglist\ti_Data
        Case #IMFA_BLUE          : dB = *taglist\ti_Data
        Case #IMFA_BLUEWEIGHT    : wB = *taglist\ti_Data
        Case #IMFA_ARGB          : !imagext_GetARGB{&*taglist\ti_Data,dA,dR,dG,dB}
        Case #IMFA_MATHGRAY      : wR = 256/3 : wG = 256/3 : wB = 256/3
        Case #IMFA_NATURALGRAY   : wR = 256 * 30 / 100
                                   wG = 256 * 59 / 100
                                   wB = 256 * 11 / 100
        Case #IMFA_TYPE          : filterType = *taglist\ti_Data
        Case #IMFA_MATRIX3       : *matrix3.matrix3 = *taglist\ti_Data
        Case #IMFA_MASK          : mask = *taglist\ti_Data
      End Select
      *taglist + SizeOf.TagItem
    Wend
  End If


  imix.l = 256-mix
  x1.l = Max(sx1,dx1)
  x2.l = Min(sx2,dx2)

  y1.l = Max(sy1,dy1)
  y2.l = Min(sy2,dy2)

  imagedat(destimage)\alpha_isused= \alpha_isused
  Select filterType
    Case #image_filter_lowpass
      image_Filter{image,#image_filter_blur,mix,0,destimage}
      argb.l = image_GetAvgARGB{destimage}
      wB.l = (argb & $000000FF)
      wG.l = (argb & $0000FF00) LSR 8
      wR.l = (argb & $00FF0000) LSR 16

      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
           !imagext_GetARGB{destptr  ,dA.l,dR.l,dG.l,dB.l}
           sourceptr + 4

           R.l = sR-dR + wR
           G.l = sG-dG + wG
           B.l = sB-dB + wB
           A.l = sA
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_highpass
      image_Filter{image,#image_filter_blur,mix,0,destimage}

      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
           !imagext_GetARGB{destptr  ,dA.l,dR.l,dG.l,dB.l}
           sourceptr + 4

           R.l = (sR-dR) *2 + dR
           G.l = (sG-dG) *2 + dG
           B.l = (sB-dB) *2 + dB
           A.l = sA
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_lowpassY
      tempimage.l=image_GetFree{}
      If tempimage>=0
        image_Create{tempimage,\img_width,\img_height}
        image_Filter{image,#image_filter_gray,256,0,tempimage}
        image_Filter{tempimage,#image_filter_blur,mix,0,destimage}
        image_Free{tempimage}
        argb.l = image_GetAvgARGB{destimage}
        wX.l = (argb & $000000FF)

        For y.l = y1 To y2
          sourceptr.l = sourcebase + y*sourcebpr + sx1*4
          destptr.l   = destbase   + y*destbpr   + dx1*4
          For x.l = x1 To x2
             !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
             !imagext_GetARGB{destptr  ,dA.l,dR.l,dG.l,dB.l}
             sourceptr + 4

             R.l = sR *wX /dR
             G.l = sG *wX /dG
             B.l = sB *wX /dB

             A.l = sA
             !imagext_ClipARGB{A,R,G,B}
             !imagext_SetARGB{destptr,A,R,G,B}
             destptr+4
          Next
        Next
      End If

    Case #image_filter_highpassY
      tempimage.l=image_GetFree{}
      If tempimage>=0
        image_Create{tempimage,\img_width,\img_height}
        image_Filter{image,#image_filter_gray,256,0,tempimage}
        image_Filter{tempimage,#image_filter_blur,mix,0,destimage}
        image_Free{tempimage}
        ;argb.l = image_GetAvgARGB{destimage}
        ;wX.l = (argb & $000000FF)

        For y.l = y1 To y2
          sourceptr.l = sourcebase + y*sourcebpr + sx1*4
          destptr.l   = destbase   + y*destbpr   + dx1*4
          For x.l = x1 To x2
             !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
             !imagext_GetARGB{destptr  ,dA.l,dR.l,dG.l,dB.l}
             sourceptr + 4

             R.l = (sR-dR) * 2 + dR
             G.l = (sG-dG) * 2 + dG
             B.l = (sB-dB) * 2 + dB

             A.l = sA
             !imagext_ClipARGB{A,R,G,B}
             !imagext_SetARGB{destptr,A,R,G,B}
             destptr+4
          Next
        Next
      End If

    Case #image_filter_mix
      imask.l = Xor($FFFFFFFF,mask)
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
           !imagext_GetARGB{destptr  ,dA.l,dR.l,dG.l,dB.l}

           A.l=(256-sA)*dA / 256
           D.l = A+sA
           If D<1 Then D=1
           R.l = (dR*A + sR*sA) / D
           G.l = (dG*A + sG*sA) / D
           B.l = (dB*A + sB*sA) / D
           A.l = dA + sA
           !imagext_ClipARGB{A,R,G,B}

           dARGB.l = (B) | ((G) LSL 8) | ((R) LSL 16) | ((A) LSL 24)
           sARGB.l = Peek.l(sourceptr)
           dARGB = (dARGB & mask) | (sARGB & imask)


           Poke.l destptr,dARGB
           destptr+4
           sourceptr + 4
        Next
      Next

    Case #image_filter_restorealphafromblackandwhite
      imask.l = Xor($FFFFFFFF,mask)
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
           !imagext_GetARGB{destptr  ,dA.l,dR.l,dG.l,dB.l}

           R.l = (dR - sR) : If R<0 Then R=-R
           G.l = (dG - sG) : If G<0 Then G=-G
           B.l = (dB - sB) : If B<0 Then B=-B
           A.l = 255 - ((R+G+B)/3)
           If True
           If A>0 AND A<255
             If sR<dR OR sG<dG OR sB<dB
             R = sR *256 / A
             G = sG *256 / A
             B = sB *256 / A
             Else
             R = dR *256 / A
             G = dG *256 / A
             B = dB *256 / A
             End If
           Else
             R = sR
             G = sG
             B = sB
           End If
           End If

           !imagext_ClipARGB{A,R,G,B}

           dARGB.l = (B) | ((G) LSL 8) | ((R) LSL 16) | ((A) LSL 24)
           sARGB.l = Peek.l(sourceptr)
           dARGB = (dARGB & mask) | (sARGB & imask)

           Poke.l destptr,dARGB
           destptr+4
           sourceptr + 4
        Next
      Next


    Case #image_filter_opacity
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           A=(A*mix) ASR 8
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_fire
      For y.l = y1 To y2-6
        sourceptr.l = sourcebase + (y)*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1+2 To x2-2
           !imagext_GetARGB{sourceptr+4,sA.l,sR.l,sG.l,sB.l}
           !imagext_GetARGB{sourceptr-sourcebpr  , A.l, R.l, G.l, B.l}
           !imagext_GetARGB{sourceptr-4,dA.l,dR.l,dG.l,dB.l}
           !imagext_GetARGB{sourceptr+sourcebpr,xA.l,xR.l,xG.l,xB.l}
           sourceptr + 4
           A.l = ((sA + dA + xA + A) * 128) LSR 9
           R.l = ((sR + dR + xR + R) * 128) LSR 9
           G.l = ((sG + dG + xG + G) * 128) LSR 9
           B.l = ((sB + dB + xB + B) * 128) LSR 9
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_sepia ; *
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           R = (R*101 +G*197 + B*48) ASR 8
           G = (R* 89 +G*176 + B*43) ASR 8
           B = (R* 70 +G*137 + B*34) ASR 8
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_sqr
      imix.l = 256-mix
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           R = ((((R*R) ASR 7 )*mix) + (R*imix)) ASR 8
           G = ((((G*G) ASR 7 )*mix) + (G*imix)) ASR 8
           B = ((((B*B) ASR 7 )*mix) + (B*imix)) ASR 8
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_tint ; -256...+256
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           R = (R*imix + dR*mix) ASR 8
           G = (G*imix + dG*mix) ASR 8
           B = (B*imix + dB*mix) ASR 8
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_blur
      #BlurBit=11
      f.f = mix
      f.f = Log(f)/Log(2.0)
      f.f = f * 32 * 8
      mix = Int(f)
      imix.l = (256*8)-mix

      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        !imagext_GetARGB{sourceptr,dA.l,dR.l,dG.l,dB.l}
         dA LSL #BlurBit : dR LSL #BlurBit : dG LSL #BlurBit : dB LSL #BlurBit
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           dA = ((dA*mix) ASR #BlurBit)+ (A*imix)
           dR = ((dR*mix) ASR #BlurBit)+ (R*imix)
           dG = ((dG*mix) ASR #BlurBit)+ (G*imix)
           dB = ((dB*mix) ASR #BlurBit)+ (B*imix)
           sourceptr + 4
           !imagext_SetARGB{destptr,dA ASR #BlurBit,dR ASR #BlurBit,dG ASR #BlurBit,dB ASR #BlurBit}
           destptr+4
        Next
      Next

      For x.l = x1 To x2
        destptr.l   = destbase + dy1*destbpr + x*4
        !imagext_GetARGB{destptr,dA.l,dR.l,dG.l,dB.l}
         dA LSL #BlurBit : dR LSL #BlurBit : dG LSL #BlurBit : dB LSL #BlurBit
        For y.l = y1 To y2
           !imagext_GetARGB{destptr,A.l,R.l,G.l,B.l}
           dA = ((dA*mix) ASR #BlurBit)+ (A*imix)
           dR = ((dR*mix) ASR #BlurBit)+ (R*imix)
           dG = ((dG*mix) ASR #BlurBit)+ (G*imix)
           dB = ((dB*mix) ASR #BlurBit)+ (B*imix)
           !imagext_SetARGB{destptr,dA ASR #BlurBit,dR ASR #BlurBit,dG ASR #BlurBit,dB ASR #BlurBit}
           destptr+destbpr
        Next
      Next


      For y.l = y1 To y2
        destptr.l   = destbase   + y*destbpr   + dx2*4
        !imagext_GetARGB{destptr,dA.l,dR.l,dG.l,dB.l}
         dA LSL #BlurBit : dR LSL #BlurBit : dG LSL #BlurBit : dB LSL #BlurBit
        For x.l = x1 To x2
           !imagext_GetARGB{destptr,A.l,R.l,G.l,B.l}
           dA = ((dA*mix) ASR #BlurBit)+ (A*imix)
           dR = ((dR*mix) ASR #BlurBit)+ (R*imix)
           dG = ((dG*mix) ASR #BlurBit)+ (G*imix)
           dB = ((dB*mix) ASR #BlurBit)+ (B*imix)
           !imagext_SetARGB{destptr,dA ASR #BlurBit,dR ASR #BlurBit,dG ASR #BlurBit,dB ASR #BlurBit}
           destptr-4
        Next
      Next


      For x.l = x1 To x2
        destptr.l   = destbase   + dy2*destbpr   + x*4
        !imagext_GetARGB{destptr,dA.l,dR.l,dG.l,dB.l}
        dA LSL #BlurBit : dR LSL #BlurBit : dG LSL #BlurBit : dB LSL #BlurBit
        For y.l = y1 To y2
           !imagext_GetARGB{destptr,A.l,R.l,G.l,B.l}
           dA = ((dA*mix) ASR #BlurBit)+ (A*imix)
           dR = ((dR*mix) ASR #BlurBit)+ (R*imix)
           dG = ((dG*mix) ASR #BlurBit)+ (G*imix)
           dB = ((dB*mix) ASR #BlurBit)+ (B*imix)
           !imagext_SetARGB{destptr,dA ASR #BlurBit,dR ASR #BlurBit,dG ASR #BlurBit,dB ASR #BlurBit}
           destptr-destbpr
        Next
      Next


    Case #image_filter_glow ; -256...+256

      ; copy source image to dest
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           If R+G+B>16 OR A>192
             !imagext_SetARGB{destptr,255,A,A,A}
           Else
             !imagext_SetARGB{destptr,0,0,0,0}
           End If
           destptr+4
        Next
      Next

      tempimage.l = image_GetFree{}
      image_Filter{destimage,#image_filter_blur,20,0,tempimage}
      ;image_Filter{destimage,#image_filter_smooth,256,0,tempimage}
      ;image_Filter{destimage,#image_filter_smooth,256,0,tempimage}

      ;image_Filter{tempimage,#image_filter_smooth,256,0,destimage}
      ;image_Filter{destimage,#image_filter_smooth,256,0,tempimage}


      tempbase.l = image_GetARGBPtr{tempimage}
      tempbpr.l  = image_GetARGBBpr{tempimage}

      ; copy source image to dest
      For y.l = y1 To y2
        tempptr.l   = tempbase   + y*tempbpr   + dx1*4
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{tempptr  ,tA.l,tR.l,tG.l,tB.l}
           !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
           A.l = (tR)
           If sR+sG+sB>16 OR sA>192 Then A-sA : If A<0 Then A=0
           A*mix/128 : If A>255 Then A=255
           !imagext_SetARGB{destptr,255,A,A,A}

           sourceptr + 4
           destptr   + 4
           tempptr   + 4
        Next
      Next

      image_Filter{destimage,#image_filter_smooth,256,0,tempimage}
      ;image_Filter{tempimage,#image_filter_smooth,256,0,destimage}
      ;image_Filter{destimage,#image_filter_smooth,256,0,tempimage}

      ;image_Filter{destimage,#image_filter_blur,15,0,tempimage}
      tempbase.l = image_GetARGBPtr{tempimage}
      tempbpr.l  = image_GetARGBBpr{tempimage}

      ; copy source image to dest
      For y.l = y1 To y2
        tempptr.l   = tempbase   + y*tempbpr   + dx1*4
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{tempptr  ,tA.l,tR.l,tG.l,tB.l}
           !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
           ;tR = (tR - 16)  : If tR<0 Then tR=0
           ;If sR+sG+sB>16 OR sA>192 Then tR-sA/8
           ;If tR<0 Then tR=0
           ;A.l = tR + sA +1

           ;xR.l = dR * tR*4 : If xR>255*256 Then xR=255*256
           ;xG.l = dG * tR*4 : If xG>255*256 Then xG=255*256
           ;xB.l = dB * tR*4 : If xB>255*256 Then xB=255*256

           ;sA-33: If sA<0 Then sA=0
           ;R.l = (xR + sR*sA)/(A)
           ;G.l = (xG + sG*sA)/(A)
           ;B.l = (xB + sB*sA)/(A)
           ;R=tR*2
           ;G=R:B=R:A=255
           ;R + sR/4
           tR*4-16
           sR-33:sG-33:sB-33
           !imagext_ClipARGB{sA,sR,sG,sB}

           R = (dR*tR)/256 + sR
           G = (dG*tR)/256 + sG
           B = (dB*tR)/256 + sB
           A = sA +tR
           If tR>0 AND tR<255
             R*256/A;tR
             G*256/A;tR
             B*256/A;tR
           End If

            ;If A>200 Then A=255

           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}

           sourceptr + 4
           destptr   + 4
           tempptr   + 4
        Next
      Next
      image_Free{tempimage}

      imagedat(destimage)\alpha_isused = True

    Case #image_filter_glow+1000 ; -256...+256

      ; copy source image to dest
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,gA.l,gR.l,gG.l,gB.l}
           sourceptr + 4
           ; if not shadow and not transparent
           ;If gA>0 AND (gR+gG+gB)>0

             ; calculate average alpha
             count.l = 0
             avA.l = 0
             For yg.l=y-3 To y+3
               If yg>=0 AND yg<=y2
                 For xg.l=x-3 To x+3
                   If xg>=0 AND xg<=x2
                     sourceptr2.l   = sourcebase   + yg*sourcebpr   + (sx1+xg)*4
                     !imagext_GetARGB{sourceptr2,A.l,R.l,G.l,B.l}
                     If R+G+B>16 OR A>200
                       avA.l + A
                     End If
                     count+1
                   End If
                 Next
               End If
             Next
             If count>0 Then avA / count
             ;If gA>200 Then
             ;avA-gA : If avA<0 Then avA=0

             For yg.l=y-3 To y+3
               If yg>=0 AND yg<=y2
                 ;yA.l = (y-yg) : If yA<0 Then yA=-yA
                 ;yA = 4-yA
                 For xg.l=x-3 To x+3
                   If xg>=0 AND xg<=x2
                     ;xA.l = (x-xg) : If xA<0 Then xA=-xA
                     ;xA = 4-xA

                     ;nA.l = (xA*yA)*avA/16  ; negative weight of read pixel to dest
                     nA.l = avA
                     ;If nA>0
                       destptr2.l   = destbase   + yg*destbpr   + (dx1+xg)*4
                       sourceptr2.l = sourcebase + yg*sourcebpr + (sx1+xg)*4
                       !imagext_GetARGB{destptr2,A.l,R.l,G.l,B.l}
                       !imagext_GetARGB{sourceptr2,sA.l,sR.l,sG.l,sB.l}
                       ;gA = avA;*avA/255
                       nA = nA*(255-sA) / 256
                       xA.l = sA*avA/255
                       If avA>64
                         r.l=(avA-64)*4+256
                       Else
                         r = 256
                       End If
                       ;If R+G+B<16 AND A<200 Then A=0   ;: A=0 ;: ssA/2 ; shadow?
                       If (nA)>0
                         ;R = (R*xA + dR*nA*r/256) / (xA+nA)
                         ;G = (G*xA + dG*nA*r/256) / (xA+nA)
                         ;B = (B*xA + dB*nA*r/256) / (xA+nA)

                         A + nA
                       End If

                       iavA.l = 255-avA
                         R = (avA *dR + iavA*R) / 256
                         G = (avA *dR + iavA*G) / 256
                         B = (avA *dB + iavA*B) / 256
                       R=gA
                       G=gA
                       B=gA
                       A=255

                       !imagext_ClipARGB{A,R,G,B}
                       !imagext_SetARGB{destptr2,A,R,G,B}
                     ;End If
                   End If
                 Next
               End If
             Next
           ;End If
           ;destptr+4
        Next
      Next
      ; copy original image over...

      If True
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
           !imagext_GetARGB{destptr,dA.l,dR.l,dG.l,dB.l}
           sourceptr + 4
           dR = (dR*(256-sA) + sR*(sA+1))/256
           dG = (dG*(256-sA) + sG*(sA+1))/256
           dB = (dB*(256-sA) + sB*(sA+1))/256

           !imagext_SetARGB{destptr,dA,dR,dG,dB}
           destptr+4
        Next
      Next
      End If


      imagedat(destimage)\alpha_isused = True

    Case #image_filter_mul ; -256...+256
      dR = (256 * imix + dR * mix) ASR 8
      dG = (256 * imix + dG * mix) ASR 8
      dB = (256 * imix + dB * mix) ASR 8
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           R = (R*dR) ASR 8
           G = (G*dG) ASR 8
           B = (B*dB) ASR 8
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_screen ; -256...+256
      dR = (256 * imix + (255-dR) * mix) ASR 8
      dG = (256 * imix + (255-dG) * mix) ASR 8
      dB = (256 * imix + (255-dB) * mix) ASR 8

      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           R = 255-(((255-R)*dR) ASR 8)
           G = 255-(((255-G)*dG) ASR 8)
           B = 255-(((255-B)*dB) ASR 8)
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_bias ; -256...+256
      dR = (dR * mix) ASR 8
      dG = (dG * mix) ASR 8
      dB = (dB * mix) ASR 8
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           R = (R+dR)
           G = (G+dG)
           B = (B+dB)
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next


    Case #image_filter_night    ; 0 ...+256
      image_Filter{image,#image_filter_saturation,(-200*mix) ASR 8,0,destimage}
      image_Filter{destimage,#image_filter_gamma,(-128*mix) ASR 8,0}
      image_Filter{destimage,#image_filter_brightness,(64*mix) ASR 8,0}
      image_Filter{destimage,#image_filter_contrast,(112*mix) ASR 8,0}
  ;    image_Filter{destimage,#image_filter_mul,mix,Tags(#IMFA_ARGB,$0080FF)}

      rmix.l = mix / 2
      gmix.l = mix
      bmix.l = mix * 2
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = sx1 To sx2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           gray.l = (R + G + B) / 3
           gray = (gray * gray) ASR 8
           R.l   = (gray*rmix + R*imix) ASR 8
           G.l   = (gray*gmix + G*imix) ASR 8
           B.l   = (gray*bmix + B*imix) ASR 8
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_gray       ; *
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           gray.l = ((R*wR + G*wG + B*wB) ASR 8)
           R.l   = gray
           G.l   = gray
           B.l   = gray
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next


    Case #image_filter_color       ; *
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           gray.l = ((R*wR + G*wG + B*wB) ASR 8)
           If gray>0
             R.l   = (R*imix + R*128*mix/gray) ASR 8
             G.l   = (G*imix + G*128*mix/gray) ASR 8
             B.l   = (B*imix + B*128*mix/gray) ASR 8
           End If
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_rgb2yuv      ; *
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           Y.l = ((R*wR + G*wG + B*wB) ASR 8)
           U.l = B-Y+128
           V.l = G-Y+128
           !imagext_ClipARGB{A,Y,U,V}
           !imagext_SetARGB{destptr,A,Y,U,V}
           destptr+4
        Next
      Next

    Case #image_filter_yuv2rgb      ; *
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,Y.l,U.l,V.l}
           sourceptr + 4
           B.l = Y+U-128
           G.l = Y+V-128
           R.l = (Y*256 - G*wG - B*wB)/wR
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next


    Case #image_filter_saturation ; -256...+256
      mix=-mix
      imix = 256-mix
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           gray.l = ((R*wR + G*wG + B*wB) ASR 8)
           R.l   = (gray*mix + R*imix) ASR 8
           G.l   = (gray*mix + G*imix) ASR 8
           B.l   = (gray*mix + B*imix) ASR 8
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_contrast ; -256... +256
      mix + 256
      imix = 256-mix
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           R.l   = ((R - 128) * mix) ASR 8 + 128
           G.l   = ((G - 128) * mix) ASR 8 + 128
           B.l   = ((B - 128) * mix) ASR 8 + 128
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_brightness ; -256...+256
      For y.l = sy1 To sy2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = sx1 To sx2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           R.l   = R + mix
           G.l   = G + mix
           B.l   = B + mix
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_threshold ; 0...+255
      For y.l = sy1 To sy2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = sx1 To sx2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           If R>=mix Then R=255:Else R=0
           If G>=mix Then G=255:Else G=0
           If B>=mix Then B=255:Else B=0
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

    Case #image_filter_dither
      If destimage><image
        CopyMem_ sourcebase,destbase,sourcebpr*(sy2-sy1+1)
      End If
      image_Dither{destimage,mix,#image_dithermode_none}

    Case #image_filter_gamma   ; -256...+256
      mix + 256
      If mix<1 Then mix=1
      mixf.f = 256.0/mix
      !setfpcr{$10}
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,A.l,R.l,G.l,B.l}
           sourceptr + 4
           Rf.f = ((R/255.0+0.00000001) ^ mixf) * 255.0
           Gf.f = ((G/255.0+0.00000001) ^ mixf) * 255.0
           Bf.f = ((B/255.0+0.00000001) ^ mixf) * 255.0
           R = Rf
           G = Gf
           B = Bf
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next
      !setfpcr{$0}

    Case #image_filter_invert   ; *
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           ARGB.l = Peek.l(sourceptr)
           sourceptr + 4
           ARGB.l = (ARGB | mask) - (ARGB & mask)
           Poke.l destptr,ARGB
           destptr+4
        Next
      Next

    Case #image_filter_convolution3 ; -256...+256
      If sx2<=0 Then sx1=0
      If sy1<=0 Then sy1=0
      If sx2>=\img_width  Then sx2=\img_width-1
      If sy2>=\img_height Then sy2=\img_height-1
      bpline.l = (\img_width+2)*4
      tempbuff.l = tempbuffer_Get{bpline*3}

      line1.l = tempbuff
      line2.l = tempbuff + bpline
      line3.l = tempbuff + bpline*2
      CopyMem_ sourcebase + (sy1  )*sourcebpr + sx1*4,line1+4,bpline-8
      Poke.l line1,Peek.l(line1+4) : Poke.l line1+bpline-4,Peek.l(line1+bpline-8)
      CopyMem_ sourcebase + (sy1  )*sourcebpr + sx1*4,line2+4,bpline-8
      Poke.l line2,Peek.l(line2+4) : Poke.l line2+bpline-4,Peek.l(line2+bpline-8)
      CopyMem_ sourcebase + (sy1+1)*sourcebpr + sx1*4,line3+4,bpline-8
      Poke.l line3,Peek.l(line3+4) : Poke.l line3+bpline-4,Peek.l(line3+bpline-8)

      If *matrix3
        ret = True
        For y.l = sy1 To sy2
          sourceptr.l = sourcebase + y*sourcebpr + sx1*4
          destptr.l   = destbase   + y*destbpr   + dx1*4

          sptr1.l = line1
          sptr2.l = line2
          sptr3.l = line3

          For x.l = sx1 To sx2
            !imagext_GetARGB{sptr1  ,A11.l,R11.l,G11.l,B11.l} : sptr1+4
            !imagext_GetARGB{sptr1  ,A21.l,R21.l,G21.l,B21.l}
            !imagext_GetARGB{sptr1+4,A31.l,R31.l,G31.l,B31.l}
            !imagext_GetARGB{sptr2  ,A12.l,R12.l,G12.l,B12.l} : sptr2+4
            !imagext_GetARGB{sptr2  ,A22.l,R22.l,G22.l,B22.l}
            !imagext_GetARGB{sptr2+4,A32.l,R32.l,G32.l,B32.l}
            !imagext_GetARGB{sptr3  ,A13.l,R13.l,G13.l,B13.l} : sptr3+4
            !imagext_GetARGB{sptr3  ,A23.l,R23.l,G23.l,B23.l}
            !imagext_GetARGB{sptr3+4,A33.l,R33.l,G33.l,B33.l}

            R.l = R11 * *matrix3\coeff[0] + R21 * *matrix3\coeff[1] + R31 * *matrix3\coeff[2]
            R.l + R12 * *matrix3\coeff[3] + R22 * *matrix3\coeff[4] + R32 * *matrix3\coeff[5]
            R.l + R13 * *matrix3\coeff[6] + R23 * *matrix3\coeff[7] + R33 * *matrix3\coeff[8]
            R ASR 8

            G.l = G11 * *matrix3\coeff[0] + G21 * *matrix3\coeff[1] + G31 * *matrix3\coeff[2]
            G.l + G12 * *matrix3\coeff[3] + G22 * *matrix3\coeff[4] + G32 * *matrix3\coeff[5]
            G.l + G13 * *matrix3\coeff[6] + G23 * *matrix3\coeff[7] + G33 * *matrix3\coeff[8]
            G ASR 8

            B.l = B11 * *matrix3\coeff[0] + B21 * *matrix3\coeff[1] + B31 * *matrix3\coeff[2]
            B.l + B12 * *matrix3\coeff[3] + B22 * *matrix3\coeff[4] + B32 * *matrix3\coeff[5]
            B.l + B13 * *matrix3\coeff[6] + B23 * *matrix3\coeff[7] + B33 * *matrix3\coeff[8]
            B ASR 8

            R + *matrix3\coeff[9]
            G + *matrix3\coeff[9]
            B + *matrix3\coeff[9]

            R = (R22 * imix + R * mix) ASR 8
            G = (G22 * imix + G * mix) ASR 8
            B = (B22 * imix + B * mix) ASR 8
            A = A22

            !imagext_ClipARGB{A,R,G,B}
            !imagext_SetARGB{destptr,A,R,G,B}
            destptr+4
          Next
          templ.l = line1
          line1=line2
          line2=line3
          line3=templ
          cy.l = Min(y+2,\img_height-1)
          CopyMem_ sourcebase + (cy)*sourcebpr + sx1*4,line3+4,bpline-8
          Poke.l line3,Peek.l(line3+4) : Poke.l line3+bpline-4,Peek.l(line3+bpline-8)
        Next

      Else
        error {"\\__THIS_FUNCTION: 3x3 Convolution without matrix!"}
        ret=False
      End If


    Case #image_filter_median3 ; -256...+256
      If sx2<=0 Then sx1=0
      If sy1<=0 Then sy1=0
      If sx2>=\img_width-1  Then sx2=\img_width-1
      If sy2>=\img_height-1 Then sy2=\img_height-1

      bpline.l = (\img_width+2)*4
      tempbuff.l = tempbuffer_Get{bpline*3}

      line1.l = tempbuff
      line2.l = tempbuff + bpline
      line3.l = tempbuff + bpline*2
      CopyMem_ sourcebase + (sy1  )*sourcebpr + sx1*4,line1+4,bpline-8
      Poke.l line1,Peek.l(line1+4) : Poke.l line1+bpline-4,Peek.l(line1+bpline-8)
      CopyMem_ sourcebase + (sy1  )*sourcebpr + sx1*4,line2+4,bpline-8
      Poke.l line2,Peek.l(line2+4) : Poke.l line2+bpline-4,Peek.l(line2+bpline-8)
      CopyMem_ sourcebase + (sy1+1)*sourcebpr + sx1*4,line3+4,bpline-8
      Poke.l line3,Peek.l(line3+4) : Poke.l line3+bpline-4,Peek.l(line3+bpline-8)

      ;If *matrix3
        ret = True
        For y.l = sy1 To sy2
          sourceptr.l = sourcebase + y*sourcebpr + sx1*4
          destptr.l   = destbase   + y*destbpr   + dx1*4

          sptr1.l = line1
          sptr2.l = line2
          sptr3.l = line3

          For x.l = sx1 To sx2
            !imagext_GetARGB{sptr1  ,A11.l,R11.l,G11.l,B11.l} : sptr1+4
            !imagext_GetARGB{sptr1  ,A21.l,R21.l,G21.l,B21.l}
            !imagext_GetARGB{sptr1+4,A31.l,R31.l,G31.l,B31.l}
            !imagext_GetARGB{sptr2  ,A12.l,R12.l,G12.l,B12.l} : sptr2+4
            !imagext_GetARGB{sptr2  ,A22.l,R22.l,G22.l,B22.l}
            !imagext_GetARGB{sptr2+4,A32.l,R32.l,G32.l,B32.l}
            !imagext_GetARGB{sptr3  ,A13.l,R13.l,G13.l,B13.l} : sptr3+4
            !imagext_GetARGB{sptr3  ,A23.l,R23.l,G23.l,B23.l}
            !imagext_GetARGB{sptr3+4,A33.l,R33.l,G33.l,B33.l}

            matrix3\coeff[0]=R11
            count.l=1
            !imagext_median{R12,count}
            !imagext_median{R13,count}
            !imagext_median{R21,count}
            !imagext_median{R22,count}
            !imagext_median{R23,count}
            !imagext_median{R31,count}
            !imagext_median{R32,count}
            !imagext_median{R33,count}
            R = matrix3\coeff[5]

            matrix3\coeff[0]=G11
            count.l=1
            !imagext_median{G12,count}
            !imagext_median{G13,count}
            !imagext_median{G21,count}
            !imagext_median{G22,count}
            !imagext_median{G23,count}
            !imagext_median{G31,count}
            !imagext_median{G32,count}
            !imagext_median{G33,count}
            G = matrix3\coeff[5]

            matrix3\coeff[0]=B11
            count.l=1
            !imagext_median{B12,count}
            !imagext_median{B13,count}
            !imagext_median{B21,count}
            !imagext_median{B22,count}
            !imagext_median{B23,count}
            !imagext_median{B31,count}
            !imagext_median{B32,count}
            !imagext_median{B33,count}
            B = matrix3\coeff[5]

            A=A22
            !imagext_SetARGB{destptr,A,R,G,B}
            destptr+4
          Next
          templ.l = line1
          line1=line2
          line2=line3
          line3=templ
          cy.l = Min(y+2,\img_height-1)
          CopyMem_ sourcebase + (cy)*sourcebpr + sx1*4,line3+4,bpline-8
          Poke.l line3,Peek.l(line3+4) : Poke.l line3+bpline-4,Peek.l(line3+bpline-8)
        Next

    Case #image_filter_sharpen   ;-512...+256
      matrix3\coeff[0] = 1*16 : matrix3\coeff[1] =  2*16 : matrix3\coeff[2] = 1*16  ; 4
      matrix3\coeff[3] = 2*16 : matrix3\coeff[4] =  4*16 : matrix3\coeff[5] = 2*16  ; 8
      matrix3\coeff[6] = 1*16 : matrix3\coeff[7] =  2*16 : matrix3\coeff[8] = 1*16  ; 4
      matrix3\coeff[9] =   0
      ret = image_Filter{image,#image_filter_convolution3,-mix,Tags(#IMFA_MATRIX3,&matrix3\coeff[0]),destimage}

    Case #image_filter_sharpenY   ;-512...+256
      tempimage.l=image_GetFree{}
      If tempimage>=0
        image_Create{tempimage,\img_width,\img_height}
        image_Filter{image,#image_filter_gray,256,0,tempimage}
        image_Filter{tempimage,#image_filter_sharpen,mix,0,destimage}
        image_Free{tempimage}

        For y.l = y1 To y2
          sourceptr.l = sourcebase + y*sourcebpr + sx1*4
          destptr.l   = destbase   + y*destbpr   + dx1*4
          For x.l = x1 To x2
             !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
             !imagext_GetARGB{destptr  ,dA.l,dR.l,dG.l,dB.l}
             sourceptr + 4
             Y.l = (sR+sG+sB)/3
             R.l = sR-Y +dR
             G.l = sG-Y +dG
             B.l = sB-Y +dB

             A.l = sA
             !imagext_ClipARGB{A,R,G,B}
             !imagext_SetARGB{destptr,A,R,G,B}
             destptr+4
          Next
        Next

      End If

    Case #image_filter_mediansharpen   ;-512...+256
      tempimage.l=image_GetFree{}
      If tempimage>=0
        image_Create{tempimage,\img_width,\img_height}
        image_Filter{image,#image_filter_median3,256,0,tempimage}
        medianbase.l = image_GetARGBPtr{tempimage}
        For y.l = y1 To y2
          medianptr.l = medianbase + y*sourcebpr + sx1*4
          sourceptr.l = sourcebase + y*sourcebpr + sx1*4
          destptr.l   = destbase   + y*destbpr   + dx1*4
          For x.l = x1 To x2
             !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
             !imagext_GetARGB{medianptr,mA.l,mR_.l,mG.l,mB.l}
             sourceptr + 4 : medianptr +4
             R.l = (sR - mR_) * mix/256 +sR
             G.l = (sG - mG ) * mix/256 +sG
             B.l = (sB - mB ) * mix/256 +sB
             A.l = sA
             !imagext_ClipARGB{A,R,G,B}
             !imagext_SetARGB{destptr,A,R,G,B}
             destptr+4
          Next
        Next
        image_Free{tempimage}

      End If

    Case #image_filter_mediansharpenY   ;-512...+256
      tempimage.l=image_GetFree{}
      If tempimage>=0
        image_Create{tempimage,\img_width,\img_height}
        image_Filter{image,#image_filter_median3,256,0,tempimage}
        medianbase.l = image_GetARGBPtr{tempimage}
        For y.l = y1 To y2
          medianptr.l = medianbase + y*sourcebpr + sx1*4
          sourceptr.l = sourcebase + y*sourcebpr + sx1*4
          destptr.l   = destbase   + y*destbpr   + dx1*4
          For x.l = x1 To x2
             !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
             !imagext_GetARGB{medianptr,mA.l,mR_.l,mG.l,mB.l}
             sourceptr + 4 : medianptr +4

             sY.l = ((sR *wR + sG*wG + sB*wB) ASR 8)
             mY.l = ((mR_*wR + mG*wG + mB*wB) ASR 8)

             Y.l = (sY - mY) * mix/256 +sY

             R.l = sR + Y - sY
             G.l = sG + Y - sY
             B.l = sB + Y - sY
             A.l = sA + Y - sY
             !imagext_ClipARGB{A,R,G,B}
             !imagext_SetARGB{destptr,A,R,G,B}
             destptr+4
          Next
        Next
        image_Free{tempimage}

      End If

    Case #image_filter_smooth   ;-512...+256
      matrix3\coeff[0] = 1*16 : matrix3\coeff[1] =  2*16 : matrix3\coeff[2] = 1*16  ; 4
      matrix3\coeff[3] = 2*16 : matrix3\coeff[4] =  4*16 : matrix3\coeff[5] = 2*16  ; 8
      matrix3\coeff[6] = 1*16 : matrix3\coeff[7] =  2*16 : matrix3\coeff[8] = 1*16  ; 4
      matrix3\coeff[9] =   0
      ret = image_Filter{image,#image_filter_convolution3,mix,Tags(#IMFA_MATRIX3,&matrix3\coeff[0]),destimage}

    Case #image_filter_121   ;-256...+256
      matrix3\coeff[0] = 1*16 : matrix3\coeff[1] =  2*16 : matrix3\coeff[2] = 1*16  ; 4
      matrix3\coeff[3] = 2*16 : matrix3\coeff[4] =  4*16 : matrix3\coeff[5] = 2*16  ; 8
      matrix3\coeff[6] = 1*16 : matrix3\coeff[7] =  2*16 : matrix3\coeff[8] = 1*16  ; 4
      matrix3\coeff[9] =   0
      ret = image_Filter{image,#image_filter_convolution3,mix,Tags(#IMFA_MATRIX3,&matrix3\coeff[0]),destimage}

    Case #image_filter_edge    ;
      matrix3\coeff[0] = 32 : matrix3\coeff[1] =   32 : matrix3\coeff[2] = 32
      matrix3\coeff[3] = 32 : matrix3\coeff[4] = -256 : matrix3\coeff[5] = 32
      matrix3\coeff[6] = 32 : matrix3\coeff[7] =   32 : matrix3\coeff[8] = 32
      matrix3\coeff[9] =  0
      ret = image_Filter{image,#image_filter_convolution3,mix,Tags(#IMFA_MATRIX3,&matrix3\coeff[0]),destimage}

    Case #image_filter_embross    ; -256..+256
      matrix3\coeff[0] = 256 : matrix3\coeff[1] =    0 : matrix3\coeff[2] =  0
      matrix3\coeff[3] =   0 : matrix3\coeff[4] =   -128 : matrix3\coeff[5] =  0
      matrix3\coeff[6] =   0 : matrix3\coeff[7] =    0 : matrix3\coeff[8] =   -128
      matrix3\coeff[9] = 128
      ret = image_Filter{image,#image_filter_convolution3,mix,Tags(#IMFA_MATRIX3,&matrix3\coeff[0]),destimage}

    Case #image_filter_glare
      ret = image_Filter{image,#image_filter_blur,50,0,destimage}
      For y.l = y1 To y2
        sourceptr.l = sourcebase + y*sourcebpr + sx1*4
        destptr.l   = destbase   + y*destbpr   + dx1*4
        For x.l = x1 To x2
           !imagext_GetARGB{sourceptr,sA.l,sR.l,sG.l,sB.l}
           !imagext_GetARGB{destptr  ,dA.l,dR.l,dG.l,dB.l}
           sourceptr + 4
           ;Y.l = (dR+dG+dB)/3

           R.l = sR + ((dR * mix) ASR 8)
           G.l = sG + ((dG * mix) ASR 8)
           B.l = sB + ((dB * mix) ASR 8)

           A.l = sA
           !imagext_ClipARGB{A,R,G,B}
           !imagext_SetARGB{destptr,A,R,G,B}
           destptr+4
        Next
      Next

  End Select

 Function Return ret
End Function



CNIF @#grassalpha = 0
  #grassalpha=1
CEND



#mingrass = 24
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_GrowGrass {image.l,amount.l,@image2.l,@opacity.l,@light.f,@:: /
;/ maxdrift.f,@gravity.f,@doalpha.l}                                           /
;/                                                                             /
;/ Description:                                                                /
;/ NOTE: dirty                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - amount.l    : ???                                                         /
;/ - image2.l    : ???                                                         /
;/ - opacity.l    : ???                                                        /
;/ - light.f    : ???                                                          /
;/ - maxdrift.f    : ???                                                       /
;/ - gravity.f    : ???                                                        /
;/ - doalpha.l    : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_GrowGrass{dstimage.l,srcimage.l,glength.f,@chaos.f,@gravity.f,@thickness.f,@glow.f}
 SHARED imagedat(),imageengine

  If image_IsUsed{dstimage} = False
    image_Create{dstimage,imagedat(srcimage)\img_width,imagedat(srcimage)\img_height,False,$0}
    image_SetAlpha{dstimage,$0}
  End If

  destbase.l   = imagedat(dstimage)\raw_ptr
  sourcebase.l = imagedat(srcimage)\raw_ptr

  If destbase.l = 0 OR sourcebase =0 Then Statement Return

  sourcebpr.l = imagedat(srcimage)\bpr ; img_width*4
  destbpr.l   = imagedat(dstimage)\bpr ; img_width*4

  mxs.l = Min(imagedat(srcimage)\img_width ,imagedat(dstimage)\img_width)
  mys.l = Min(imagedat(srcimage)\img_height,imagedat(dstimage)\img_height)
  gravity / Pi/2

  For turn.l = 1 To 1
    seed.l = 0
    For y.l = 0 To mys-1 Step 2
      For x.l = 0 To mxs-1 Step 2
        srcptr.l = sourcebase + sourcebpr * y + (x LSL 2)
        !imagext_GetARGB{srcptr,AB.l,RB.l,GB.l,BB.l}

        lengthOfGrass.f = Max(Max(RB , GB ) , BB) * glength
        If lengthOfGrass<2 Then lengthOfGrass=0

        !image_nrnd{seed}
        s.l = seed & $7FFFFFFF
        f.f = s / $7FFFFFFF
        bias.f = 0.8*bias + 0.2*bright.l/200
        bright.l = (1 + f - bias) * 255
        If bright<0 Then bright=0
        RR.l = (RB * bright) LSR 8  : If RR>255 Then RR=255
        GR.l = (GB * bright) LSR 8  : If GR>255 Then GR=255
        BR.l = (BB * bright) LSR 8  : If BR>255 Then BR=255
        nbright.l = bright
        If lengthOfGrass>0
          !image_nrnd{seed}
          n.l = seed & $00FFFFFF
          viewAngle.f = (n/$00FFFFFF-0.5) * Pi

          !image_nrnd{seed}
          n.l = seed & $00FFFFFF
          growAngle.f = (n/$00FFFFFF-0.5) * Pi
          growAngle * chaos

          yg.f = y
          xg.f = x

          While lengthOfGrass>2
        RR = (RB * nbright) LSR 8  : If RR>255 Then RR=255
        GR = (GB * nbright) LSR 8  : If GR>255 Then GR=255
        BR = (BB * nbright) LSR 8  : If BR>255 Then BR=255
        nbright+(glow/glength)*8
        If nbright<0 Then nbright=0

            If gravity>0
              growAngle = growAngle * (1+gravity) + gravity*0.1
            Else
              growAngle = growAngle * (1+gravity)
            End If

            xi.l = Int(xg) MOD mxs
            yi.l = Int(yg) MOD mys

              xf.f = xg-Int(xg)
              yf.f = yg-Int(yg)
              ixf.f = 1-xf
              iyf.f = 1-yf
              xi2.l = (xi+1) MOD mxs
              yi2.l = (yi+1) MOD mys

            If turn=1


              yg = yg - Cos(growAngle)
              xg = xg + Sin(growAngle)  * Sin(viewAngle)

              AR.l = 255*(lengthOfGrass/10) * thickness * ixf*iyf  ; 00
              If AR>255 Then AR=255 : Else If AR<10 Then AR=10
              dstptr.l = destbase + destbpr * yi + (xi LSL 2)
              !imagext_GetARGB{dstptr,A.l,R.l,G.l,B.l}
              R = ((R * A) + (RR * AR)) / (A+AR)
              G = ((G * A) + (GR * AR)) / (A+AR)
              B = ((B * A) + (BR * AR)) / (A+AR)
              A = A + AR : If A>255 Then A=255
              !imagext_SetARGB{dstptr,A,R,G,B}

              AR.l = 255*(lengthOfGrass/10) * thickness * xf*iyf  ; 10
              If AR>255 Then AR=255 : Else If AR<10 Then AR=10
              dstptr.l = destbase + destbpr * yi + (xi2 LSL 2)
              !imagext_GetARGB{dstptr,A.l,R.l,G.l,B.l}
              R = ((R * A) + (RR * AR)) / (A+AR)
              G = ((G * A) + (GR * AR)) / (A+AR)
              B = ((B * A) + (BR * AR)) / (A+AR)
              A = A + AR : If A>255 Then A=255
              !imagext_SetARGB{dstptr,A,R,G,B}

              AR.l = 255*(lengthOfGrass/10) * thickness * ixf*yf ; 01
              If AR>255 Then AR=255 : Else If AR<10 Then AR=10
              dstptr.l = destbase + destbpr * yi2 + (xi LSL 2)
              !imagext_GetARGB{dstptr,A.l,R.l,G.l,B.l}
              R = ((R * A) + (RR * AR)) / (A+AR)
              G = ((G * A) + (GR * AR)) / (A+AR)
              B = ((B * A) + (BR * AR)) / (A+AR)
              A = A + AR : If A>255 Then A=255
              !imagext_SetARGB{dstptr,A,R,G,B}

              AR.l = 255*(lengthOfGrass/10) * thickness * xf*yf ; 11
              If AR>255 Then AR=255 : Else If AR<10 Then AR=10
              dstptr.l = destbase + destbpr * yi2 + (xi2 LSL 2)
              !imagext_GetARGB{dstptr,A.l,R.l,G.l,B.l}
              R = ((R * A) + (RR * AR)) / (A+AR)
              G = ((G * A) + (GR * AR)) / (A+AR)
              B = ((B * A) + (BR * AR)) / (A+AR)
              A = A + AR : If A>255 Then A=255
              !imagext_SetARGB{dstptr,A,R,G,B}

            Else
              yg = yg - Cos(growAngle) *0.25  + Cos(growAngle) * Sin(viewAngle)
              xg = xg + Cos(growAngle)        + Sin(growAngle) * Cos(viewAngle)

              AR.l = 64*(lengthOfGrass/10) * thickness        *ixf*iyf
              If AR>128 Then AR=128 : Else If AR<1 Then AR=1
              dstptr.l = destbase + destbpr * yi + (xi LSL 2)
              !imagext_GetARGB{dstptr,A.l,R.l,G.l,B.l}
              R = ((R * A) ) / (A+AR)
              G = ((G * A) ) / (A+AR)
              B = ((B * A) ) / (A+AR)
              A = A + AR : If A>128 Then A=128
              !imagext_SetARGB{dstptr,A,R,G,B}

              AR.l = 64*(lengthOfGrass/10) * thickness     *xf*iyf
              If AR>128 Then AR=128 : Else If AR<1 Then AR=1
              dstptr.l = destbase + destbpr * yi + (xi2 LSL 2)
              !imagext_GetARGB{dstptr,A.l,R.l,G.l,B.l}
              R = ((R * A) ) / (A+AR)
              G = ((G * A) ) / (A+AR)
              B = ((B * A) ) / (A+AR)
              A = A + AR : If A>128 Then A=128
              !imagext_SetARGB{dstptr,A,R,G,B}

              AR.l = 64*(lengthOfGrass/10) * thickness * ixf*yf
              If AR>128 Then AR=128 : Else If AR<1 Then AR=1
              dstptr.l = destbase + destbpr * yi2 + (xi LSL 2)
              !imagext_GetARGB{dstptr,A.l,R.l,G.l,B.l}
              R = ((R * A) ) / (A+AR)
              G = ((G * A) ) / (A+AR)
              B = ((B * A) ) / (A+AR)
              A = A + AR : If A>128 Then A=128
              !imagext_SetARGB{dstptr,A,R,G,B}

              AR.l = 64*(lengthOfGrass/10) * thickness * xf * yf
              If AR>128 Then AR=128 : Else If AR<1 Then AR=1
              dstptr.l = destbase + destbpr * yi2 + (xi2 LSL 2)
              !imagext_GetARGB{dstptr,A.l,R.l,G.l,B.l}
              R = ((R * A) ) / (A+AR)
              G = ((G * A) ) / (A+AR)
              B = ((B * A) ) / (A+AR)
              A = A + AR : If A>128 Then A=128
              !imagext_SetARGB{dstptr,A,R,G,B}


            End If
            lengthOfGrass-1
          Wend

        End If
      Next
    Next
  Next
End Statement



Statement image_GrowGrass_old{image.l,amount.l,@image2.l,@opacity.l,@light.f,@maxdrift.f,@gravity.f,@doalpha.l}
 SHARED imagedat(),imageengine

  If image_IsUsed{image2} = False
    image_Create{image2,\img_width,\img_height,False,$0}
    image_SetAlpha{image2,$0}
  End If

  destbase.l   = imagedat(image2)\raw_ptr
  sourcebase.l = \raw_ptr

  If destbase.l = 0 OR sourcebase =0 Then Statement Return

  sourcebpr.l = \bpr ; img_width*4
  destbpr.l = imagedat(image2)\bpr ; img_width*4

  mxs.l = Min(\img_width,imagedat(image2)\img_width) -1
  mys.l = Min(\img_height,imagedat(image2)\img_height) -1

  ;light.f = 0.95
  If light<=0 Then light=0.9
  ilight.f = 1-light
  bias.f = 0.5
  If amount<1 Then amount=1
  seed.l = 0
  If opacity.l<0 Then opacity = 456


  If maxdrift<0 Then maxdrift=1
  maxdrift/2
  If gravity<0 Then gravity=1
  For turn.l = 0 To 1
    seed.l = 0
    For y.l = 0 To mys + amount
      If y = \img_height Then seed=0
      For x.l = 0 To mxs
        yd.l = y MOD \img_height
        srcptr.l = sourcebase + sourcebpr * yd + (x LSL 2)

        col.l = Peek.l(srcptr)
        R1.l = (col           & $FF )
        G1.l = ((col LSR 8  ) & $FF )
        B1.l = ((col LSR 16 ) & $FF )
        ;A1.l = ((col LSR 24 ) & $FF )

        mix.l = Max(Max(R1 , G1 ) , B1)
    ;    mix.l = (R1 + G1 + B1) / 3
        mix=(mix*opacity) ASR 8
    ;    mix=mix*2
       If mix>256 Then mix=256
       If mix<#mingrass Then mix=0

        bias = light*bias + ilight*(mix/128)

        If mix>0
          stepping.l = (mix) / amount
          If stepping<1 Then stepping=1

          drift.f = 0
          !image_nrnd{seed}
          s.l = seed & $00FFFF00
          f.f = s / $FFFF00
          driftv.f = (f - 0.5) * amount * ((mix+128)/384) * maxdrift

          !image_nrnd{seed}
          s.l = seed & $7FFFFFFF
          f.f = s / $7FFFFFFF

          colvar.f = 1 + f*3 - bias
          col = image_IlluminateRGB{col,colvar}
          R1.l = (col           & $FF )
          G1.l = ((col LSR 8  ) & $FF )
          B1.l = ((col LSR 16 ) & $FF )

    ; if we use alpha!
    CNIF #grassalpha
      ;    A1.l = ((col LSR 24 ) & $FF )
    CEND
    ;      ramount.l = (amount * amount) / (drift * drift)
          ramount.l= amount
          For y2.l = y To y-ramount Step -1
            drift + driftv

            ;If y2<0 Then y2d.l = y2 + \img_height:Else y2d = y2
            y2d.l=y2
            If y2d<\img_height AND y2d>=0
              ox.l = xd.l
              xd.l = x + Int(drift.f)
              If ox><xd Then y2+1 : drift-driftv
              ox = xd
              If xd<0           Then xd+\img_width
              If xd>=\img_width Then xd-\img_width

              imix.l = 256-mix
              If turn=0   ; shadow!
                xmix.l = mix LSR 1
                ;For nx.l = -1 To 1
                 ; For ny.l = -1 To 1
                 nx.l = 0
                 ny.l = 0
                    xds.l = x + y-y2+1 +nx + drift +1
                    yds.l = y + ny  - (y-y2+1)*0.3
                    If xds<0            Then xds+\img_width
                    If xds>=\img_width  Then xds-\img_width
                    If yds<0            Then yds+\img_height
                    If yds>=\img_height Then yds-\img_height

                    destptr.l = destbase + destbpr * yds + (xds LSL 2)
                    col.l = Peek.l(destptr)
                    R2.l = (col           & $FF )
                    G2.l = ((col LSR 8  ) & $FF )
                    B2.l = ((col LSR 16 ) & $FF )
                    A2.l = ((col LSR 24 ) & $FF )

                    If xmix<1 Then xmix=1
                    R.l = (0 + R2*A2) / (A2+xmix)
                    G.l = (0 + G2*A2) / (A2+xmix)
                    B.l = (0 + B2*A2) / (A2+xmix)
                    A.l = (A2+xmix) : If A>128 Then A=128
                    Poke.l destptr,(R) | (G LSL 8) | (B LSL 16) | (A LSL 24)
                 ; Next
                ;Next
              End If

              If turn=1
                destptr.l = destbase + destbpr * y2d + (xd LSL 2)
                col.l = Peek.l(destptr)
                R2.l = (col           & $FF )
                G2.l = ((col LSR 8  ) & $FF )
                B2.l = ((col LSR 16 ) & $FF )
      CNIF #grassalpha
                A2.l = ((col LSR 24 ) & $FF )

                R.l = (R1*mix + R2*A2) / (A2+mix)
                G.l = (G1*mix + G2*A2) / (A2+mix)
                B.l = (B1*mix + B2*A2) / (A2+mix)
                A.l = (A2+mix/2+1) : If A>255 Then A=255
                Poke.l destptr,(R) | (G LSL 8) | (B LSL 16) | (A LSL 24)
      CELSE
                R.l = (R1*mix + R2*imix) / 256
                G.l = (G1*mix + G2*imix) / 256
                B.l = (B1*mix + B2*imix) / 256
                Poke.l destptr,(R) | (G LSL 8) | (B LSL 16)
      CEND

              End If
            End If
             driftv * gravity
            mix - stepping
            If mix<=2 Then y2=y-ramount-1
          Next
        End If
      Next
    Next
  Next
End Statement
 


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_GrowLeave {image.l,amount.l,image2.l,@opacity.l,@light.f,@m:: /
;/ axdrift.f,@gravity.f,@doalpha.l}                                            /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - amount.l    : ???                                                         /
;/ - image2.l    : ???                                                         /
;/ - opacity.l    : ???                                                        /
;/ - light.f    : ???                                                          /
;/ - maxdrift.f    : ???                                                       /
;/ - gravity.f    : ???                                                        /
;/ - doalpha.l    : ???                                                        /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_GrowLeave{image.l,amount.l,image2.l,@opacity.l,@light.f,@maxdrift.f,@gravity.f,@doalpha.l}
 SHARED imagedat(),imageengine

  If image_IsUsed{image2} = False
    image_Create{image2,\img_width,\img_height,False,$0}
    image_SetAlpha{image2,$0}
  End If

  destbase.l   = imagedat(image2)\raw_ptr
  sourcebase.l = \raw_ptr

  If destbase.l = 0 OR sourcebase =0 Then Statement Return

  sourcebpr.l = \bpr ; img_width*4
  destbpr.l = imagedat(image2)\bpr ; img_width*4

  mxs.l = Min(\img_width,imagedat(image2)\img_width) -1
  mys.l = Min(\img_height,imagedat(image2)\img_height) -1

  ;light.f = 0.95
  If light<=0 Then light=0.9
  ilight.f = 1-light
  bias.f = 0.5
  If amount<1 Then amount=1
  seed.l = 0
  If opacity.l<0 Then opacity = 456


  If maxdrift<0 Then maxdrift=1
  maxdrift/2
  If gravity<0 Then gravity=1

  For y.l = 0 To mys + amount
    If y = \img_height Then seed=0
    For x.l = 0 To mxs
      yd.l = y MOD \img_height
      srcptr.l = sourcebase + sourcebpr * yd + (x LSL 2)

      col.l = Peek.l(srcptr)
      R1.l = (col           & $FF )
      G1.l = ((col LSR 8  ) & $FF )
      B1.l = ((col LSR 16 ) & $FF )
      ;A1.l = ((col LSR 24 ) & $FF )

      mix.l = Max(Max(R1 , G1 ) , B1)
  ;    mix.l = (R1 + G1 + B1) / 3
      mix=(mix*opacity) ASR 8
  ;    mix=mix*2
     If mix>256 Then mix=256
     If mix<10 Then mix=0

      bias = light*bias + ilight*(mix/128)

      If mix>0
        stepping.l = (mix) / amount
        If stepping<1 Then stepping=1

        drift.f = 0
        !image_nrnd{seed}
        s.l = seed & $00FFFF00
        f.f = s / $FFFF00
        driftv.f = (f - 0.5) * amount * ((mix+128)/384) * maxdrift

        !image_nrnd{seed}
        s.l = seed & $7FFFFFFF
        f.f = s / $7FFFFFFF
        colvar.f = 1 + f*3 - bias
        col = image_IlluminateRGB{col,colvar}
        R1.l = (col           & $FF )
        G1.l = ((col LSR 8  ) & $FF )
        B1.l = ((col LSR 16 ) & $FF )

  ; if we use alpha!
  CNIF #grassalpha
        A1.l = ((col LSR 24 ) & $FF )
  CEND
        For y2.l = y To y-amount Step -1
          drift+driftv
          driftv * gravity
          ;If y2<0 Then y2d.l = y2 + \img_height:Else y2d = y2
          y2d.l=y2
          If y2d<\img_height AND y2d>=0

            xd.l = x + (drift.f)
            If xd<0 Then xd+\img_width
            If xd>=\img_width Then xd-\img_width

            destptr.l = destbase + destbpr * y2d + (xd LSL 2)

            imix.l = 256-mix

            col.l = Peek.l(destptr)
            R2.l = (col           & $FF )
            G2.l = ((col LSR 8  ) & $FF )
            B2.l = ((col LSR 16 ) & $FF )
  CNIF #grassalpha
            A2.l = ((col LSR 24 ) & $FF )

            R.l = (R1*mix + R2*A2) / (A2+mix+1)
            G.l = (G1*mix + G2*A2) / (A2+mix+1)
            B.l = (B1*mix + B2*A2) / (A2+mix+1)
            A.l = (A2+mix) : If A>255 Then A=255
            Poke.l destptr,(R) | (G LSL 8) | (B LSL 16) | (A LSL 24)
  CELSE
            R.l = (R1*mix + R2*imix) / 256
            G.l = (G1*mix + G2*imix) / 256
            B.l = (B1*mix + B2*imix) / 256
            Poke.l destptr,(R) | (G LSL 8) | (B LSL 16)
  CEND

          End If

          mix - stepping
          If mix<=24 Then y2=y-amount-1
        Next
      End If
    Next
  Next

End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Patternize {image.l,fadex.f,fadey.f,@dstimage.l,@hq.l,@xoff:: /
;/ set.l,@yoffset.l}                                                           /
;/                                                                             /
;/ Description:                                                                /
;/ Dirty                                                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l     : source image                                                /
;/ - fadex.f     : horizontal fade zone 0...1                                  /
;/ - fadey.f     : vertical fade zone 0...1                                    /
;/ - dstimage.l  : destination image                                           /
;/ - hq.l        : enable high quality algorithm                               /
;/ - xoffset.l   : horizontal offsset for blending                             /
;/ - yoffset.l   : vertical offset for blending                                /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Patternize{image.l,fadex.f,fadey.f,@dstimage.l,@hq.l,@xoffset.l,@yoffset.l}
 SHARED imagedat(),imageengine

  sourcebase.l = \raw_ptr
  If dstimage>=0
    image_Create{dstimage,\img_width,\img_height}
    destbase.l = imagedat(dstimage)\raw_ptr
  Else
    destbase.l = sourcebase
    image_Release{image}
    dstimage = image
  End If
  If destbase.l = 0 OR sourcebase =0 Then Statement Return

  If fadex>0
    fadex = 1/fadex
  End If
  If fadey>0
    fadey = 1/fadey
  End If


  sourcebpr.l = \bpr ; img_width*4
  destbpr.l = imagedat(dstimage)\bpr
  wrapx.l = \img_width/2
  wrapy.l = \img_height/2
  If xoffset=-1 Then xoffset = 0
  If yoffset=-1 Then yoffset = 0

  If hq ; calculate average color of the image
    AVGARGB.l = image_GetAvgARGB{image}
    AVGB.l = (AVGARGB       ) & $FF
    AVGG.l = (AVGARGB LSR  8) & $FF
    AVGR.l = (AVGARGB LSR 16) & $FF
  End If

  If fadey>0
  For y.l = 0 To \img_height-1
    If y<wrapy  Then mix_y.l = (wrapy - y*fadey)*256 / wrapy  : If mix_y<0 Then mix_y=0
    If y>=wrapy Then mix_y = ((y-wrapy)*256*fadey  / wrapy) - (256*(fadey-1)) : If mix_y<0 Then mix_y=0

    f.f = mix_y
    f.f / 256 * Pi
    f.f = (1 - Cos(f)) * 0.5
    f.f * 256
    mix_y = f

    imix_y.l = 256-mix_y
    yw.l = y - wrapy+yoffset
    While yw<0 Then yw + \img_height :Wend
    While yw>\img_height Then yw - \img_height :Wend

    For x.l = 0 To \img_width-1
      srcptr.l = sourcebase + sourcebpr * y + (x LSL 2)
      col.l = Peek.l(srcptr)
      R1.l = (col           & $FF )
      G1.l = ((col LSR 8  ) & $FF )
      B1.l = ((col LSR 16 ) & $FF )

      col.l = Peek.l(sourcebase + sourcebpr * yw + (x LSL 2))
      R2.l = (col           & $FF )
      G2.l = ((col LSR 8  ) & $FF )
      B2.l = ((col LSR 16 ) & $FF )

      If hq
        dR1.l = AVGR - R1
        dG1.l = AVGG - G1
        dB1.l = AVGB - B1

        dR2.l = AVGR - R2
        dG2.l = AVGG - G2
        dB2.l = AVGB - B2

        d1.l = Sqr((dR1*dR1 + dG1*dG1 + dB1*dB1)/3) *2
        d2.l = Sqr((dR2*dR2 + dG2*dG2 + dB2*dB2)/3) *2
        d1 = (d1 * imix_y) ASR 8
        d2 = (d2 *  mix_y) ASR 8
        If d1<d2
          R1.l = (R2 * (d1)  + R1 * (256-d1) ) ASR 8
          G1.l = (G2 * (d1)  + G1 * (256-d1) ) ASR 8
          B1.l = (B2 * (d1)  + B1 * (256-d1) ) ASR 8
        Else
          R2.l = (R1 * (256-d2)  + R2 * (d2) ) ASR 8
          G2.l = (G1 * (256-d2)  + G2 * (d2) ) ASR 8
          B2.l = (B1 * (256-d2)  + B2 * (d2) ) ASR 8
        End If
      End If


      R.l = (R1*imix_y + R2*mix_y) ASR 8
      G.l = (G1*imix_y + G2*mix_y) ASR 8
      B.l = (B1*imix_y + B2*mix_y) ASR 8

      destptr.l = destbase + destbpr * y + (x LSL 2)
      Poke.l destptr,(R LSL 0) | (G LSL 8) | (B LSL 16)
    Next
  Next
  sourcebase.l = destbase
  End If

  If fadex>0
  For x.l = 0 To \img_width-1
    If x<wrapx Then mix_x.l = (wrapx - x*fadex)*256 / wrapx  : If mix_x<0 Then mix_x=0
    If x>=wrapx Then mix_x = ((x-wrapx)*256*fadex  / wrapx) - (256*(fadex-1)) : If mix_x<0 Then mix_x=0

    f.f = mix_x
    f.f / 256 * Pi
    f.f = (1 - Cos(f)) * 0.5
    f.f * 256
    mix_x = f

    imix_x.l = 256-mix_x
    xw.l = x - wrapx+xoffset
    While xw<0 Then xw + \img_width :Wend
    While xw>\img_width Then xw - \img_width :Wend

    For y.l = 0 To \img_height-1
      srcptr.l = sourcebase + sourcebpr * y + (x LSL 2)
      col.l = Peek.l(srcptr)
      R1.l = (col           & $FF )
      G1.l = ((col LSR 8  ) & $FF )
      B1.l = ((col LSR 16 ) & $FF )

      col.l = Peek.l(sourcebase + sourcebpr * y + (xw LSL 2))
      R2.l = (col           & $FF )
      G2.l = ((col LSR 8  ) & $FF )
      B2.l = ((col LSR 16 ) & $FF )

      If hq
        dR1.l = AVGR - R1
        dG1.l = AVGG - G1
        dB1.l = AVGB - B1

        dR2.l = AVGR - R2
        dG2.l = AVGG - G2
        dB2.l = AVGB - B2

        d1.l = Sqr((dR1*dR1 + dG1*dG1 + dB1*dB1)/3)
        d2.l = Sqr((dR2*dR2 + dG2*dG2 + dB2*dB2)/3)
        If d1>d2
          d1 = (d1 * imix_x) ASR 8
          R2.l = (R1 * (d1)  + R2 * (256-d1) ) ASR 8
          G2.l = (G1 * (d1)  + G2 * (256-d1) ) ASR 8
          B2.l = (B1 * (d1)  + B2 * (256-d1) ) ASR 8
        Else
          d2 = (d2 * mix_x) ASR 8
          R1.l = (R1 * (256-d2)  + R2 * (d2) ) ASR 8
          G1.l = (G1 * (256-d2)  + G2 * (d2) ) ASR 8
          B1.l = (B1 * (256-d2)  + B2 * (d2) ) ASR 8
        End If
      End If

      R.l = (R1*imix_x + R2*mix_x) ASR 8
      G.l = (G1*imix_x + G2*mix_x) ASR 8
      B.l = (B1*imix_x + B2*mix_x) ASR 8

      destptr.l = destbase + sourcebpr * y + (x LSL 2)
      Poke.l destptr,(R LSL 0) | (G LSL 8) | (B LSL 16)
    Next
  Next
  sourcebase.l = destbase
  End If
  If sourcebase >< destbase
    CopyMem_ sourcebase,destbase,sourcebpr * \img_height
  End If
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !setAPenRGB {rp,fgRGB}                                              /
;/                                                                             /
;/ Description:                                                                /
;/ Set the foreground pen as RGB value in penless mode (24bit)                 /
;/ NOTE: This function requires OS4, MOS or AfA OS and a hi/true color screen  /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - rp    : ???                                                               /
;/ - fgRGB    : ???                                                            /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro setAPenRGB ; { rp, fgRGB }
  SetRPAttrsA_ `1,Tags(#RPTAG_PenMode,False,#RPTAG_FgColor,`2,#RPTAG_APenColor,`2)
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !setBPenRGB rp,bgRGB                                                /
;/                                                                             /
;/ Description:                                                                /
;/ Set the background pen as RGB value in penless mode (24bit)                 /
;/ NOTE: This function requires OS4, MOS or AfA OS and a hi/true color screen  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro setBPenRGB ; rp, bgRGB
  SetRPAttrsA_ `1,Tags(#RPTAG_PenMode,False,#RPTAG_BgColor,`2,#RPTAG_BPenColor,`2)
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !setPenRGB rp,fgRGB,bgRGB                                           /
;/                                                                             /
;/ Description:                                                                /
;/ Set the fore- and background pen as RGB value in penless mode (24bit)       /
;/ NOTE: This function requires OS4, MOS or AfA OS and a hi/true color screen  /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro setPenRGB ; rp, fgRGB, bgRGB
  SetRPAttrsA_ `1,Tags(#RPTAG_PenMode,False,#RPTAG_FgColor,`2,#RPTAG_BgColor,`3,#RPTAG_APenColor,`2,#RPTAG_BPenColor,`3)
End Macro



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_DrawLine_t {image.l,x1.l,y1.l,x2.l,y2.l,argb.l,thickness.f,:: /
;/ @flags.l}                                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ NOTE: dirty                                                                 /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - x1.l    : ???                                                             /
;/ - y1.l    : ???                                                             /
;/ - x2.l    : ???                                                             /
;/ - y2.l    : ???                                                             /
;/ - argb.l    : ???                                                           /
;/ - thickness.f    : ???                                                      /
;/ - flags.l    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_DrawLine_t{image.l,x1.l,y1.l,x2.l,y2.l,argb.l,thickness.f,@flags.l}
 SHARED imagedat()

  If flags=-1 Then flags=0
  ptr.l = \raw_ptr
  If y1>y2 Then Exchange y1,y2  : Exchange x1,x2
  m.f = (x2-x1) / (y2-y1)
  ca.f = y1
  ce.f = ca + Tan(m) * thickness
  bpp.l = \bpp
  bpr.l = \bpr

  R.l =  (argb & $FF      )
  G.l =  (argb & $FF00    ) LSR 8
  B.l =  (argb & $FF0000  ) LSR 16
  A.l =  (argb & $FF000000) LSR 24

  For y.l = y1 To y2
    xa.f = ca + m * y
    xe.f = ce + m * y
    xi.l = xa
    mix.f = 1-(xa-xi)
    destptr.l = ptr + bpr * y + xi * bpp
    col.l = 256.0 * mix

    For x.l = xa To xe+1
      rgbv.l = ((B * col) LSR 8)  + ((G * col) AND $FF00) + (((R * col) LSR 8) LSL 16) + (((A * col) LSR 8) LSL 24)
      Poke.l destptr,rgbv
      destptr+bpp
      If x>=xe-1
        xi.l = xe
        mix.f = (xe-xi)
        col.l = 256.0 * mix
      Else
        col = 255
      End If
    Next
  Next
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_DrawLineAA {image.l,x1.f,y1.f,x2.f,y2.f,argb.l,thickness.f,:: /
;/ @flags.l}                                                                   /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - x1.f    : ???                                                             /
;/ - y1.f    : ???                                                             /
;/ - x2.f    : ???                                                             /
;/ - y2.f    : ???                                                             /
;/ - argb.l    : ???                                                           /
;/ - thickness.f    : ???                                                      /
;/ - flags.l    : ???                                                          /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_DrawLineAA{image.l,x1.f,y1.f,x2.f,y2.f,argb.l,thickness.f,@flags.l}
 SHARED imagedat()

  If flags=-1 Then flags=0
  ptr.l = \raw_ptr

  If ptr=0 Then Statement Return;
  bpp.l = \bpp
  bpr.l = \bpr

  B.l =  (argb & $FF      )
  G.l =  (argb & $FF00    ) LSR 8
  R.l =  (argb & $FF0000  ) LSR 16
  A.l =  (argb & $FF000000) LSR 24

  If x1>x2 Then Exchange y1,y2  : Exchange x1,x2

  dx.f = x2 - x1
  dy.f = y2 - y1

  If Abs(dy)>Abs(dx)
    If y1>y2
       Exchange y1,y2  : Exchange x1,x2
       dx.f = x2 - x1
       dy.f = y2 - y1
    End If
    Exchange dx,dy
    Exchange x1,y1
    Exchange x2,y2
    flip.l = -1
  End If

  gradient.f = dy / dx

  xend.f = Int(x1+0.5)
  yend.f = y1 + gradient * (xend - x1)
  xgap.f = 1-((x1+0.5 )-Int(x1 + 0.5))
  xpxl1.f = xend  ;// this will be Used in the main loop
  ypxl1.f = Int(yend)

  If flip
    destptr.l = ptr + bpp * Int(ypxl1) + Int(xpxl1) * bpr
    destptr2.l = destptr + bpp
  Else
    destptr.l = ptr + bpr * Int(ypxl1) + Int(xpxl1) * bpp
    destptr2.l = destptr + bpr
  End If

  mix2.f = yend-Int(yend)
  mix.f = 1-mix2
  col.l = 256.0 * mix * xgap
  rgbv.l = ((B * col) LSR 8)  + ((G * col) AND $FF00) + (((R * col) LSR 8) LSL 16) + (((A * col) LSR 8) LSL 24)
  Poke.l destptr,rgbv

  col.l = 256.0 * mix2 *xgap
  rgbv.l = ((B * col) LSR 8)  + ((G * col) AND $FF00) + (((R * col) LSR 8) LSL 16) + (((A * col) LSR 8) LSL 24)
  Poke.l destptr2,rgbv

  intery.f = yend + gradient ;// first y-intersection For the main loop

  xend = Int(x2+0.5)
  yend = y2 + gradient * (xend - x2)
  xgap = x2+0.5 - Int(x2 + 0.5)
  xpxl2.f = xend  ;// this will be Used in the main loop
  ypxl2.f = Int(yend)

  If flip
    destptr.l = ptr + bpp * Int(ypxl2) + Int(xpxl2) * bpr
    destptr2.l = destptr + bpp
  Else
    destptr.l = ptr + bpr * Int(ypxl2) + Int(xpxl2) * bpp
    destptr2.l = destptr + bpr
  End If

  mix2.f = yend-Int(yend)
  mix.f = 1-mix2
  col.l = 256.0 * mix * xgap
  rgbv.l = ((B * col) LSR 8)  + ((G * col) AND $FF00) + (((R * col) LSR 8) LSL 16) + (((A * col) LSR 8) LSL 24)
  Poke.l destptr,rgbv

  col.l = 256.0 * mix2 *xgap
  rgbv.l = ((B * col) LSR 8)  + ((G * col) AND $FF00) + (((R * col) LSR 8) LSL 16) + (((A * col) LSR 8) LSL 24)
  Poke.l destptr2,rgbv

  For x.l = xpxl1 + 1 To xpxl2 - 1 Step 1
     If flip
       destptr.l = ptr + bpp * Int(intery) + x * bpr
       destptr2.l = destptr + bpp
     Else
       destptr.l = ptr + bpr * Int(intery) + x * bpp
       destptr2.l = destptr + bpr
     End If
     mix2.f = intery-Int(intery)
     mix.f = 1-mix2
     If thickness>1
       mix.f = (1-Cos(mix*Pi)) * 0.5
       mix2.f = (1-Cos(mix2*Pi)) * 0.5
     End If
     col.l = 256.0 * mix
     rgbv.l = ((B * col) LSR 8)  + ((G * col) AND $FF00) + (((R * col) LSR 8) LSL 16) + (((A * col) LSR 8) LSL 24)
     Poke.l destptr,rgbv
     col.l = 256.0 * mix2
     rgbv.l = ((B * col) LSR 8)  + ((G * col) AND $FF00) + (((R * col) LSR 8) LSL 16) + (((A * col) LSR 8) LSL 24)
     Poke.l destptr2,rgbv
     intery = intery + gradient
  Next
End Statement



NEWTYPE.fillpoint
  x.l
  y.l
End NEWTYPE



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !_addfillpoint                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ * private                                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro _addfillpoint
  If tempc>=maxfillpoints
    maxfillpoints*2
    temp.l = tempbuffer_Resize {maxfillpoints*SizeOf.fillpoint}
  End If
  If temp
    *fp.fillpoint = temp + (tempc * SizeOf.fillpoint)
    *fp\x = (`1)
    *fp\y = (`2)
    tempc+1
  End If
End Macro


;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: !_getfillpoint                                                      /
;/                                                                             /
;/ Description:                                                                /
;/ * private                                                                   /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Macro _getfillpoint
  If tempc
    tempc-1
    *fp.fillpoint = temp + (tempc * SizeOf.fillpoint)
    `1 = *fp\x
    `2 = *fp\y
    brokenUp.l   = True
    brokenDown.l = True
  End If
End Macro



USEPATH imagedat(image)
;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_FloodFill {image.l,x.l,y.l,fillRGB.l,borderRGB.l,@mask.l}     /
;/                                                                             /
;/ Description:                                                                /
;/ * no description available *                                                /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - x.l    : ???                                                              /
;/ - y.l    : ???                                                              /
;/ - fillRGB.l    : ???                                                        /
;/ - borderRGB.l    : ???                                                      /
;/ - mask.l    : ???                                                           /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_FloodFill{image.l,x.l,y.l,fillRGB.l,borderRGB.l,@mask.l}
 SHARED imagedat()

  If image_Lock{image}
    ptr.l = \raw_ptr
    bpr.l = \bpr
    bpp.l = \bpp
    maxfillpoints.l = \img_width ; what a rough estimation !
    temp.l = tempbuffer_Get{maxfillpoints*SizeOf.fillpoint}
    tempc.l = 0
    borderRGB & mask
    ownRGB.l = fillRGB & mask
    !_addfillpoint{x,y}
    While tempc>0
      !_getfillpoint{x,y}
      destptr.l = ptr + bpr*y + x LSL 2
      While x>0 AND ( (Peek.l(destptr)& mask) >< ownRGB AND (Peek.l(destptr)& mask) >< borderRGB): destptr-bpp:x-1:Wend
      If ((Peek.l(destptr)& mask)=ownRGB OR (Peek.l(destptr)& mask))=borderRGB Then x+1:destptr+bpp
      While x<\img_width
        ARGB.l = Peek.l(destptr) & mask
        If ARGB=ownRGB OR ARGB=borderRGB
          x=\img_width
        Else
          Poke.l destptr,fillRGB

          ; test top
          If y>0
            tstptr.l = destptr - bpr
            ARGB.l = Peek.l(tstptr) & mask
            If ARGB >< borderRGB AND ARGB><ownRGB
              If brokenUp
                !_addfillpoint{x,y-1}
                brokenUp=False
              End If
            Else
              brokenUp=True
            End If
          End If

          ; test bottom
          If y<\img_height-1
            tstptr.l = destptr + bpr
            ARGB.l = Peek.l(tstptr) & mask
            If ARGB >< borderRGB AND ARGB><ownRGB
              If brokenDown
                !_addfillpoint{x,y+1}
                brokenDown=False
              End If
            Else
              brokenDown=True
            End If
          End If
          x+1
          destptr+bpp
        End If
      Wend
    Wend
    image_Unlock{image}
    image_Release{image}
  End If
End Statement



;///////////////////////////////////////////////////////////////////////////////
;/                                                                             /
;/ Syntax: image_Scroll {image.l,dx.l,dy.l}                                    /
;/                                                                             /
;/ Description:                                                                /
;/ * Scroll the image data by dx and dy.                                       /
;/                                                                             /
;/ Inputs:                                                                     /
;/ - image.l    : ???                                                          /
;/ - dx.l    : ???                                                             /
;/ - dy.l    : ???                                                             /
;/                                                                             /
;///////////////////////////////////////////////////////////////////////////////
Statement image_Scroll{image.l,dx.l,dy.l}
  *rp.RastPort = image_GetRPPtr{image}
  If *rp
    ScrollRaster_ *rp,dx,dy,0,0,\img_width-1,\img_height-1
  End If
End Statement



ext_example:
CNIF #__include=0
.internal_Demo

  WbToScreen 0 ; we need to use a screen
  XINCLUDE "screen.include.ab3"
  If screen_Open{"Myscreen",#scr_mode_wb_use}
  *scr.Screen = Peek.l(Addr Screen(0))
  Window 0,0,0,1200,600,$E,"image_ext.include test",1,2
  succ.l = -1
  succ   & image_Load{2,"/Data/alphablit.png"}           :  image_MidHandle{2}
  succ   & image_Load{2,"sys:disk.info"}                 :  image_MidHandle{2}
  succ   & image_Load{33,"sys:disk.info",-1,-1,-1,-1,1}  :  image_MidHandle{2}
  succ   & image_Load{12,"/Data/house.iff"}

  If succ

    apen.l = screen_GetPenRGB{$666666}
    bpen.l = screen_GetPenRGB{$999999}
    For x.l=0 To InnerWidth/25-1
      For y.l = 0 To InnerHeight/25-1
        If (x+y) MOD 2 Then pen.l = apen:Else pen=bpen
        WBox x*25+WLeftOff,y*25+WTopOff,x*25+24+WLeftOff,y*25+24+WTopOff,pen
      Next
    Next


    ;If screen_GetDepth{}<=8 Then  colmap_Grab{}
    image_SetHandle{2,0,0}
    #xp = 10
    #xr = 110
    #yp = 30
    #yr = 90
    image_Blit{2,#xp,#yp} : WLocate #xp,#yp+#yr/2 : Print "Reference"
    image_Patternize{2,0.5,0.5,4,False}
    image_Cut{7,2}
    image_FloodFill{7,25,25,$FF9988,$0,$00FFFFFF}

    image_BlitPattern{4,#xp+1*#xr,#yp,80,80} : WLocate #xp+#xr*1,#yp+#yr/2 : Print "Patternize"


    image_Blit{7,#xp+2*#xr,#yp} : WLocate #xp+#xr*2,#yp+#yr/2 : Print "FloodFill"
    image_Smooth{2,100,5}

    image_Blit{5,#xp+3*#xr,#yp} : WLocate #xp+#xr*3,#yp+#yr/2 : Print "Smooth"

    Dim taglist.TagItem(10)
    taglist(0)\ti_Tag = #IMFA_ARGB,$FFC084
    taglist(1)\ti_Tag = #TAG_DONE,0

    image_Filter{2,#image_filter_glow,250,&taglist(0),3}
    image_FancyBlit{2 ,#xp+6*#xr,#yp+#yr*2,-1,-1,-1,#image_blitmode_alpha} : WLocate #xp+#xr*6,#yp+#yr/2+#yr*2 : Print "normal"
    image_FancyBlit{3 ,#xp+5*#xr,#yp+#yr*2,-1,-1,-1,#image_blitmode_alpha} : WLocate #xp+#xr*5,#yp+#yr/2+#yr*2 : Print "glow"
    image_FancyBlit{33,#xp+4*#xr,#yp+#yr*2,-1,-1,-1,#image_blitmode_alpha} : WLocate #xp+#xr*4,#yp+#yr/2+#yr*2 : Print "org"
    Goto skipfire

    image_Create{5,320,420,False,$0}
    seed.l = 100
    For n.l = 0 To 400
      ;seed.l=oseed.l
      For nn.l=0 To 200
        ptr.l = image_GetARGBPtr{5}
        x.l = ((seed LSR 8) & $FF) + 50
        y.l = (((seed LSR 17) & $FF))/40
        y = y*y*y + 200
        seed=seed*11+131
        pt.l = ptr + image_GetARGBBpr{5}*y + x*4
        Poke.l pt,$FF9922
      Next

      ;If n MOD 1 =0 Then image_FancyBlit{3,1+n,300,-1,-1,image_GetRPPtr{5},#image_blitmode_alpha}
      oseed.l*11+131
      oseed*11+131
      oseed*11+131
      image_Filter{5,#image_filter_fire,256,0}
      image_Draw{5,0,0}
      ;Delay_ 1
    Next

  skipfire:

    image_Blit{12,#xp+0*#xr,#yp+#yr*3} : WLocate #xp+#xr*0,#yp+#yr/2+#yr*3 : Print "original"
    image_Free{3}

    ; color filters

    image_Filter{12,#image_filter_contrast,156,0,3}
    image_Blit{3,#xp+1*#xr,#yp+#yr*3} : WLocate #xp+#xr*1,#yp+#yr/2+#yr*3 : Print "contast"

    image_Filter{12,#image_filter_gamma,156,0,3}
    image_Blit{3,#xp+2*#xr,#yp+#yr*3} : WLocate #xp+#xr*2,#yp+#yr/2+#yr*3 : Print "gamma"

    image_Filter{12,#image_filter_brightness,100,0,3}
    image_Blit{3,#xp+3*#xr,#yp+#yr*3} : WLocate #xp+#xr*3,#yp+#yr/2+#yr*3 : Print "brightness"

    image_Filter{12,#image_filter_saturation,256,0,3}
    image_Blit{3,#xp+4*#xr,#yp+#yr*3} : WLocate #xp+#xr*4,#yp+#yr/2+#yr*3 : Print "saturation"

    image_Filter{12,#image_filter_invert,-1,0,3}
    image_Blit{3,#xp+5*#xr,#yp+#yr*3} : WLocate #xp+#xr*5,#yp+#yr/2+#yr*3 : Print "invert"

    image_Filter{12,#image_filter_embross,256,0,3}
    image_Blit{3,#xp+6*#xr,#yp+#yr*3} : WLocate #xp+#xr*6,#yp+#yr/2+#yr*3 : Print "embross"

    image_Filter{12,#image_filter_smooth,256,0,3}
    image_Blit{3,#xp+7*#xr,#yp+#yr*3} : WLocate #xp+#xr*7,#yp+#yr/2+#yr*3 : Print "smooth"

    image_Filter{12,#image_filter_edge,256,0,3}
    image_Blit{3,#xp+8*#xr,#yp+#yr*3} : WLocate #xp+#xr*8,#yp+#yr/2+#yr*3 : Print "edge"

    image_Filter{12,#image_filter_rgb2yuv,256,0,3}
    image_Blit{3,#xp+9*#xr,#yp+#yr*3} : WLocate #xp+#xr*9,#yp+#yr/2+#yr*3 : Print "=>yuv"

    image_Filter{3,#image_filter_yuv2rgb,256,0,12}
    image_Blit{12,#xp+10*#xr,#yp+#yr*3} : WLocate #xp+#xr*10,#yp+#yr/2+#yr*3 : Print "=>rgb"



    ; convolution


    image_Filter{12,#image_filter_sharpen,256,0,3}
    image_Blit{3,#xp+0*#xr,#yp+#yr*4} : WLocate #xp+#xr*0,#yp+#yr/2+#yr*4 : Print "sharpen"

    image_Filter{12,#image_filter_sharpenY,256,0,3}
    image_Blit{3,#xp+1*#xr,#yp+#yr*4} : WLocate #xp+#xr*1,#yp+#yr/2+#yr*4 : Print "sharpenY"

    image_Filter{12,#image_filter_mediansharpen,256,0,3}
    image_Blit{3,#xp+1*#xr,#yp+#yr*4} : WLocate #xp+#xr*1,#yp+#yr/2+#yr*4 : Print "msharpen"

    image_Filter{12,#image_filter_blur,50,0,3}
    image_Blit{3,#xp+2*#xr,#yp+#yr*4} : WLocate #xp+#xr*2,#yp+#yr/2+#yr*4 : Print "blur"

    image_Filter{12,#image_filter_median3,-1,0,3}
    image_Blit{3,#xp+3*#xr,#yp+#yr*4} : WLocate #xp+#xr*3,#yp+#yr/2+#yr*4 : Print "median"

    image_Filter{12,#image_filter_gray,-1,0,3}
    image_Blit{3,#xp+4*#xr,#yp+#yr*4} : WLocate #xp+#xr*4,#yp+#yr/2+#yr*4 : Print "gray"

    image_Filter{12,#image_filter_sepia,-1,0,3}
    image_Blit{3,#xp+5*#xr,#yp+#yr*4} : WLocate #xp+#xr*5,#yp+#yr/2+#yr*4 : Print "sepia"

    image_Filter{12,#image_filter_night,230,0,3}
    image_Blit{3,#xp+6*#xr,#yp+#yr*4} : WLocate #xp+#xr*6,#yp+#yr/2+#yr*4 : Print "night"

    image_Filter{12,#image_filter_sqr,256,0,3}
    image_Blit{3,#xp+7*#xr,#yp+#yr*4} : WLocate #xp+#xr*7,#yp+#yr/2+#yr*4 : Print "sqr"

    image_Filter{12,#image_filter_glare,200,0,3}
    image_Blit{3,#xp+8*#xr,#yp+#yr*4} : WLocate #xp+#xr*8,#yp+#yr/2+#yr*4 : Print "glare"

    image_Filter{12,#image_filter_color,256,0,3}
    image_Blit{3,#xp+9*#xr,#yp+#yr*4} : WLocate #xp+#xr*9,#yp+#yr/2+#yr*4 : Print "color"



    ;..................

    image_Filter{12,#image_filter_tint,100,Tags(#IMFA_ARGB,$FF5522),3}
    image_Blit{3,#xp+0*#xr,#yp+#yr*5} : WLocate #xp+#xr*0,#yp+#yr/2+#yr*5 : Print "tint"

    image_Filter{12,#image_filter_mul,155,Tags(#IMFA_ARGB,$FF5522),3}
    image_Blit{3,#xp+1*#xr,#yp+#yr*5} : WLocate #xp+#xr*1,#yp+#yr/2+#yr*5 : Print "mul"

    image_Filter{12,#image_filter_screen,155,Tags(#IMFA_ARGB,$FF5522),3}
    image_Blit{3,#xp+2*#xr,#yp+#yr*5} : WLocate #xp+#xr*2,#yp+#yr/2+#yr*5 : Print "screen"

    image_Filter{12,#image_filter_bias,50,Tags(#IMFA_ARGB,$FF5522),3}
    image_Blit{3,#xp+3*#xr,#yp+#yr*5} : WLocate #xp+#xr*3,#yp+#yr/2+#yr*5 : Print "bias"

    image_Filter{12,#image_filter_threshold,60,0,3}
    image_Blit{3,#xp+4*#xr,#yp+#yr*5} : WLocate #xp+#xr*4,#yp+#yr/2+#yr*5 : Print "threshold"

    image_Filter{12,#image_filter_dither,9,0,3}
    image_Blit{3,#xp+5*#xr,#yp+#yr*5} : WLocate #xp+#xr*5,#yp+#yr/2+#yr*5 : Print "color reduction"

    image_Filter{12,#image_filter_lowpass,100,0,3}
    image_Blit{3,#xp+6*#xr,#yp+#yr*5} : WLocate #xp+#xr*6,#yp+#yr/2+#yr*5 : Print "lowpass"

    image_Filter{12,#image_filter_lowpassY,100,0,3}
    image_Blit{3,#xp+7*#xr,#yp+#yr*5} : WLocate #xp+#xr*7,#yp+#yr/2+#yr*5 : Print "lowpassY"

    image_Filter{12,#image_filter_highpass,100,0,3}
    image_Blit{3,#xp+8*#xr,#yp+#yr*5} : WLocate #xp+#xr*8,#yp+#yr/2+#yr*5 : Print "highpassY"

    rec.Rectangle\MinX = 0,0,80,80
    par.perlinPars\persistence = 0.6,.04,0.7,1.3,104,6,1
    par\FGRGB = $FFFFFF,$446699
    image_PerlinNoise{1,rec,par}

    image_Blit{1,#xp+4*#xr,#yp} : WLocate #xp+#xr*4,#yp+#yr/2 : Print "Perlin"

    image_Square2Iso{1,6} : image_SetHandle{6,image_GetWidth{6}/2,0}
    image_BlitMask{6,#xp+5*#xr+#xr/2-10,#yp} : WLocate #xp+#xr*5,#yp+#yr/2 : Print "Square2Iso"


    image_Create{3,80,80,False,$0}
    image_DrawLineAA{3,10,20,70,60,$FFFFFF,2}
    image_DrawLineAA{3,30,60,70,30,$00FF00,2}
    image_DrawLineAA{3,40,10,80,60,$FF0000,2}
    image_FancyBlit{3,#xp+6*#xr,#yp,-1,-1,-1,#image_blitmode_alpha} : WLocate #xp+#xr*6,#yp+#yr/2 : Print "drawlineAA"

  DEFTYPE.texcone tbcoo
  tbcoo\x1 = #xp+#xr/4
  tbcoo\y1 = #yp+#yr*1 + 10
  tbcoo\x2 = #xp+#xr/2
  tbcoo\y2 = #yp+#yr*1+#yr/2 + 20

  tbcoo\fat1 = 30,40
  tbcoo\angle = 0.5
  tbcoo\light_angle = 0.8+Pi
  tbcoo\light_ambient = 80
  tbcoo\light_glow = 400
  tbcoo\light_max= 270
  tbcoo\blow = -0.3
  tbcoo\texmod = 1.5
  tbcoo\texrot = 0
  tbcoo\textwist = 0.5

  ;image_Load{6,"/Data/256x256/_TreeStem2Brown.png"}
  ;image_Mirror{6,#image_flipx|#image_flipy,5}

  image_ConeBlit{1,tbcoo,-1,RastPort(0),-1}  : WLocate #xp+#xr*0,#yp+#yr*1+#yr/2 : Print "ConeBlit"
  image_Mirror{2,#image_flipx,8}
  image_Blit{8,#xp+1*#xr,#yp+#yr} : WLocate #xp+#xr*1,#yp+#yr*3/2 : Print "Mirror x"
  image_Mirror{2,#image_flipy,8}
  image_Blit{8,#xp+2*#xr,#yp+#yr} : WLocate #xp+#xr*2,#yp+#yr*3/2 : Print "Mirror y"
  image_Mirror{2,#image_flipx|#image_flipy,8}
  image_Blit{8,#xp+3*#xr,#yp+#yr} : WLocate #xp+#xr*3,#yp+#yr*3/2 : Print "Mirror x+y"
  image_Rotate{2,90,8}
  image_Blit{8,#xp+4*#xr,#yp+#yr} : WLocate #xp+#xr*4,#yp+#yr*3/2 : Print "Rotate90"
  image_Rotate{2,180,8}
  image_Blit{8,#xp+5*#xr,#yp+#yr} : WLocate #xp+#xr*5,#yp+#yr*3/2 : Print "Rotate180"
  image_Rotate{2,270,8}
  image_Blit{8,#xp+6*#xr,#yp+#yr} : WLocate #xp+#xr*6,#yp+#yr*3/2 : Print "Rotate270"



  rec.Rectangle\MinX = 0,0,160,160
  par.perlinPars\persistence = 0.2,.04,0.8,2,134,6,5
  par\FGRGB = $99FF33,$000000
  image_PerlinNoise{9,rec,par}
  ;image_GrowGrass{9,15,10,260,0.5,1.3,0.8}
  image_GrowGrass{10,9,0.1,0.2,0.2,0.5,0.3}
  image_Half{4,9}
  image_Blit{4,#xp+0*#xr,#yp+2*#yr} : WLocate #xp+#xr*0,#yp+#yr*5/2 : Print "Perlin =>"
  image_Half{4,10}
  image_Blit{4,#xp+1*#xr,#yp+2*#yr} : WLocate #xp+#xr*1,#yp+#yr*5/2 : Print "GrowGrass"
  image_FancyBlit{4,#xp+2*#xr,#yp+2*#yr,-1,-1,-1,#image_blitmode_alpha}  : WLocate #xp+#xr*2,#yp+#yr*5/2 : Print "GrowGrass"

  image_CutRP{4,RastPort(0),0,0,WindowWidth,WindowHeight}
  image_FreeAlpha{4}
  ;succ.l = image_Save{4,"RAM:screenshot_ext.png",@"PNG",9}

  image_Load{4,"/Data/button.9.png"}
  image_Half{5,4}
  succ.l = image_Save{5,"RAM:screenshot_ext_x2.png",@"PNG",9}

  image_Filter{4,#image_filter_smooth,256,0,14}
  image_Half{5,14}
  succ.l = image_Save{5,"RAM:screenshot_ext_x2s.png",@"PNG",9}
  While WaitEvent><#IDCMP_CLOSEWINDOW:Wend
  Else
    error{"Something went wrong !"}
  End If
  CloseWindow 0
  screen_Close{}
  End If
  End
CEND
