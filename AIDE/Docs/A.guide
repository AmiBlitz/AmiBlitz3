@DATABASE A++.guide
@INDEX main
@Width 80
@$VER: A/A++ Guide 0.9

@NODE main "A/A++ Guide"

@{B}A/A++@{UB} Programming Language - Documentation                    (date: 17.03.2013)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                                            
  Table of Contents 
  
  1 @{"Introduction"                 link "Abstract"}

  2 @{"Syntax"                       link "Syntax"}
  2.1 @{"Program Flow"               link "ProgramFlow"}
  2.2 @{"Variables"                  link "Variables"}
  2.3 @{"Arrays"                     link "Arrays"}
  2.4 @{"Lists"                      link "Lists"} 
  2.5 @{"Primitive Types"            link "Primitives"}
  2.6 @{"Structures"                 link "Structures"}
  2.7 @{"Pointers"                   link "Pointers"}
  2.8 @{"Constants"                  link "Constants"}
  2.9 @{"Functions"                  link "Functions"}
  2.10 @{"Macros"                    link "Macros"}
  2.11 @{"Modifiers"                 link "Modifiers"}
  2.12 @{"Compiler Directives"       link "Directives"}
        
  3 @{"Object Oriented Programming"  link "OOP"}
  3.1 @{"Inherit from Super Class"   link "Inherit"}
  3.2 @{"Defining own Init/Deinit"   link "OwnInit"}
  
  4 @{"A Function Reference"         link "AFunctions"}
  
  5 @{"A++ Library Reference"        link "APP"}      
  5.1 @{"Basic Runtime Library"      link "BRL"}      
  5.2 @{"File Library"               link "File"}      
  5.3 @{"Graphic Library"            link "Graphic"}      
  5.4 @{"Audio Library"              link "Audio"}      
  5.5 @{"GUI Library"                link "GUI"}      
  5.6 @{"NTUI Library"               link "NTUI"}      
  5.7 @{"Network Library"            link "Network"}      
  5.8 @{"Game Library"               link "Game"}
  5.9 @{"Data Library"               link "Data"}      
    
  6 @{"V - Virtual Assembler Reference"  link "VBin"}  

  A @{"Code Style Guide"             link "StyleGuide"}   
  B @{"Code Examples"                link "Examples"}  
  C @{"Glossary"                     link "Glossary"}
  D @{"License/Disclaimer"           link "License"}
  E @{"Author"                       link "Author"}


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                                            © 2009 Thilo Koehler
            
@ENDNODE

@NODE Abstract "Introduction"
@{b}1 Introduction@{ub}

@{b}1.1 What is A/A++?@{ub}

  @{b}A/A++@{ub} is a programming language that is inspired by AmiBlitz³ and C.
  It comes with the integrated development environment called @{b}AIDE@{ub},
  which contains a text editor, compiler, debugger and interpreter.
  The source code files are plain 8bit ASCII text files and are edited in AIDE
  or by any other text editor.

  The idea is to provide an all-purpose, easy yet powerful programming
  language for Amiga and Amiga-Like platforms. It is developed to keep in mind
  to support non-Amiga platforms in the future, such as Linux or Windows.

  It is easy to learn if you know programming principles, but not designed
  to be a beginner's language to learn programming itself. It uses as many
  quasi-standardized symbols and keywords as possible to make the source code
  understandable even for non-A programmers.
  
  There will be support for 68K executables in the first version. Later,
  Amiga Shared Libraries and Devices are planned as well as x86 and PPC
  support, given the project gets enough public interest.
  Beside real executables, it can generate virtual binaries. The virtual
  assembler is called "@{b}V@{ub}" and the virtual machine that runs it is called
  the @{b}V@{ub} Interpreter.
  This will help to develop the language itself and can help in debugging
  situations. In fact, the A compiler always generates V code, which will
  be either interpreted or converted to a real binary such as 68K.

  There are also plans to use the very same language as a scripting language
  inside A/A++. The only difference will be, that no pointers and no
  external Library calls are allowed. This ensures that the script can be
  frozen and restored at any time, since it runs 100% sandboxed.

@{b}1.2 Design Issues@{ub}

  @{b}Minimalistic While Powerful@{ub}

    A/A++ is divided into two parts:

    1. @{b}A@{ub}
      The language A, which is comparable to plain C/C++ and has only a very
      small set of @{"build-in functions" link "AFunctions"}, even less than C/C++. 

    2. @{b}A++@{ub}
      On top of A, there are the @{b}A++ Libraries@{ub}. They come as A
      source code and can be used for high-level functionality, such as loading
      and displaying images, sounds, accessing the internet and alike.

    It is up to you, if you program everything by yourself in A using the
    OS API or use the A++ Libraries, that provide you object oriented solutions
    for many aspects of programming. Since they come as A source code,
    you can examine them for educational purposes or improve and bugfix them.
    You never run into a dead end because your code relies on an unmaintained
    library!

  @{b}Expandable to Other Platforms@{ub}

    The compiler itself does not directly generate a specific machine code.
    It generates a virtual machine code, that is platform (not API)
    independent.
    This code can be relatively easy interpreted or converted into
    real machine code, no matter if this is 68K, PPC or x86, and no matter
    how the calling conventions look like, e.g. for external library calls.
    This design avoids to re-write/modify the compiler for every supported
    platform, just the final step - instancing the virtual machine instructions
    to real ones - has to be implemented.
    However, if two seperate APIs are used, e.g. Win32 and AmigaOS,
    the system specific tasks have to be implemented for each API.

  @{b}Compiler Strictness Levels@{ub}

    The compiler knows 3 strictness levels (mainly about type safety):

      * compatible : Tries to compile everybody and everything, 
                     good for beginners.
                     
      * normal     : Warns on things that are not clean, and errors on things
                     that are probably wrong. This is the preferred setting.

      * strict     : Warns you on any inaccuracy and errors as soon as
                     data might get lost, e.g. assigning a long to a float.
    
@{b}1.3 Comparism A/A++, C and AmiBlitz³@{ub}

  @{b}How does A compare to AmiBlitz³?@{ub}
  Pros:
  - A will support more OSes/CPUs than OS3.x/68K.
  - A is (optionally) type safe, AmiBlitz³ is not type safe.
  - A supports more primitive types, e.g. Bool or Unsigned Integers. 
  - A does not only output the first best error while compiling, but runs
    further and reports all warnings and errors.
  - A has the concept of source file "intern", means what happens in a
    file, stays in the file, unless you make things explicitly "extern".
  - A supports OOP (Object Oriented Programming).
  - Functions can be used before their actual declaration.
  - A has a drastically cleaned up syntax compared to AmiBlitz³.

  Cons:
  - AmiBlitz³ compiler is faster (the fastest compiler I have ever seen).
  - AmiBlitz³ generates highly optimized 68K code, A will probalby not reach
    this level of optimization.

  @{b}How does A compare to C/C++?@{ub}
  Pros:
  - A compiler is faster than e.g. GCC.
  - A does not use ";" (semicolon) to seperate expressions.
    @{i}Note: Generally, the semicolon as an expression delimiter is a good
          idea in C, but practically it creates unnecessary attention
          the coder has to pay.@{ui}
  - A does not require header files (the compiler does 2 passes and makes
    functions/struct available at any line of code).
  - A does not require a makefile for larger projects.
  - Every source code file can have a build-in demo that is ignored if the
    file is used as an include (#_Include compiler constant).
  - Strings are as easy to handle as integers.
  - No library wrappers/stubs etc. are needed, the Codegenerator takes care
    of library calling conventions.
  - OOP integrates much smoother and easier into functional programming.
  - A is less complex and slightly higher leveled, making the code more
    readable and uniform.
  - Variables can be declared during usage, in 68K ASM style by using 
    a type extension (a.l = 0), no declaration monsters like
    "unsigned const char * myVar".
  - Variables and Objects are initialized, no more random bugs due to
    uninitialized variables.

  Cons:
  - C is widely spread and much more examples and docu is out there.
  - C can compile for almost every OS/CPU.
  - C generates highly optimized native code, A will probalby not reach
    this level of optimization.

  @{b}Code Examples:@{ub}
  
  Check a character for number (not assume 0-9 are neighbours in ASCII):
  +-----------------------------------------------------------------------------
  | 
  | AmiBlitz³:           C:                   A:
  | 24 lines, 211 chars  16 lines, 133 chars  6 lines, 90 chars
  | 
  | Select char.b        switch(char) {       Select(char.c) {
  |   Case @"0"            Case '0':            Case '0','1','2','3','4','5','6','7','8','9'
  |     number=True        Case '1':              number=True
  |   Case @"1"            Case '2':            Default
  |     number=True        Case '3':              number=False
  |   Case @"2"            Case '4':          }
  |     number=True        Case '5':
  |   Case @"3"            Case '6':
  |     number=True        Case '7':
  |   Case @"4"            Case '8':
  |     number=True        Case '9':
  |   Case @"5"              number=true;
  |     number=True          break;
  |   Case @"6"            Default:
  |     number=True          number=false;
  |   Case @"7"          }
  |     number=True         
  |   Case @"8" 
  |     number=True         
  |   Case @"9" 
  |     number=True         
  |   Default   
  |     number=False        
  | End Select
  |
  +-----------------------------------------------------------------------------

  Define a structure, allocate an instance and set some values:

  AmiBlitz³:                            6 lines, 93 chars        
  +-----------------------------------------------------------------------------
  |  
  | NewType.myType
  |  x.f 
  |  y.f
  | End Newtype
  |
  | *myVar.myType = AllocMem(SizeOf.myType,#MEMF_CLEAR)
  | *myVar\\x = 100,100
  |
  +-----------------------------------------------------------------------------

  C:                                    7 lines, 94 chars
  +-----------------------------------------------------------------------------
  |
  | struct myType { 
  |  float x;
  |  float y;
  | }
  |
  | struct myType *myVar = calloc(1,sizeof(myType));
  | myVar->x = 100;
  | myVar->y = 100;
  |
  +-----------------------------------------------------------------------------

  A:                                    6 lines, 52 chars
  +-----------------------------------------------------------------------------
  |
  | Struct myType {
  |  x.f
  |  y.f
  | }
  |
  | *myVar.myType = New()
  | myVar\\x = 100,100
  |
  +-----------------------------------------------------------------------------

  Define and call a macro:

  AmiBlitz³:                            4 lines, 56 chars        
  +-----------------------------------------------------------------------------
  |  
  | Macro MulTwoValues
  |  (`1) * (`2)
  | End Macro
  |
  | r.l = !MulTwoValues(2,3)
  |
  +-----------------------------------------------------------------------------

  C:                                    2 lines, 53 chars
  +-----------------------------------------------------------------------------
  |
  | #define MulTwoValues(A,B)  (A) * (B)
  |
  | int r = MulTwoValues(2,3);
  |
  +-----------------------------------------------------------------------------

  A:                                    2 lines, 47 chars
  +-----------------------------------------------------------------------------
  |
  | #MulTwoValues(A,B) (A) * (B)
  |
  | r.l = #MulTwoValues(2,3)
  |
  +-----------------------------------------------------------------------------

  ...

@ENDNODE

@NODE Syntax "Syntax"
@{b}2 Syntax@{ub}

  An @{b}A@{ub} program is a sequence of expressions (and definitions).
  Two expressions are separated by a new line or by a ":" (colon).
  
  Example:
  +-----------------------------------------------------------------------------
  |
  | @{i}expression@{ui}
  | @{i}expression@{ui} : @{i}expression@{ui}
  |
  +-----------------------------------------------------------------------------
  @{i}Note: This is exactly the same way AmiBlitz³ handles the separation of
        expressions.@{ui}
  
  An expression is usually a function call or a statement call (function with
  no return value).

  An expression can be spanned over multiple lines, if the new line is escaped
  by "\\" (back slash):
  +-----------------------------------------------------------------------------
  | 
  | @{i}expression part1@{ui} \\
  | @{i}expression part2@{ui}
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: This is the same way C handles multi-line expressions in macros.@{ui}

  A comment is added by using the ";" (semicolon):
  +-----------------------------------------------------------------------------
  | 
  | @{i}expression@{ui} @{i}; this is a comment@{ui}
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: Unlike in C, a expressions do not have a terminating semicolon.
        The semicolon acts as the comment delimiter, like in AmiBlitz³.@{ui}
  
  The curly brackets are used to group a block of expressions together, e.g.
  if they make up the body of a loop, or the conditional block of an "If":
  +-----------------------------------------------------------------------------
  | 
  | If (@{i}condition@{ui}) {
  |   @{i}expression@{ui}
  |   @{i}expression@{ui}
  |   ...
  | }
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: "@{i}condition@{ui}" is an expression that evaluates to a bool (True/False).@{ui}

@ENDNODE

@NODE Variables "Variables"
@{b}2.2 Variables@{ub}

  @{b}Variables@{ub} are declared by using the "Var" instruction or
  by mentioning their type extension on first usage. On later usage, the
  extension is optional. 
  When using Var, variables are initialized to 0 and it must be the
  first time the variable occures. Otherwise, the compiler will throw a
  warning or error. This is for your own protection to avoid double
  usage of the same variable.
  If you just mention the type extension on first usage, you have
  to take care of the initialization, which should be the first usage anyway.
  If a variable however is used without setting an initial value, the compiler
  *might* throw a warning.

  +-----------------------------------------------------------------------------
  | 
  | Var [@{i}@{"modifier" link "Modifiers"}@{ui}] @{i}name@{ui}.t, ...     ; declare variable @{i}name@{ui} as type .t
  | @{i}name@{ui} = @{i}expression@{ui}              ; assign the result of the expression to @{i}name@{ui}
  |
  | @{i}; or straight away: @{ui}
  | [@{i}@{"modifier" link "Modifiers"}@{ui}] @{i}name@{ui}.t = @{i}expression@{ui} ; declare and assign at once
  | 
  +-----------------------------------------------------------------------------
  
  Example:
  +-----------------------------------------------------------------------------
  | 
  | Var a.l, b.l, c.l   @{i}; declare a, b and c as type Long (and set to 0)@{ui}
  | d.l = 1             @{i}; declare d as type Long   and set it to 1@{ui}
  | e.f = 1.0           @{i}; declare e as type Float  and set it to 1@{ui}
  | f.s = "test"        @{i}; declare f as type String and set it to "test"@{ui}
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: See section @{"Primitive Types" link "Primitives"} and @{"Structures" link "Structures"} for more information
        and possible types.@{ui}
  @{i}Note: See section @{"Constants" link "Constants"} how to write constant expressions such as
        numbers or strings.@{ui}
  @{i}Note: See section @{"Modifiers" link "Modifiers"} about supported modifiers.@{ui}

  As a shortcut, the assign operator "=" can be ommited if the first operand is
  also the variable to assign the result to. 

  Example:
  +-----------------------------------------------------------------------------
  |
  | a = a+1   @{i}; normal writing@{ui}
  | a + 1     @{i}; this does the same, it's a short cut@{ui}
  |
  | a = a/2+5 @{i}; normal writing@{ui}
  | a / 2+5   @{i}; short cut@{ui}
  |
  +-----------------------------------------------------------------------------
  @{i}Note: Unlike "a /= 2+5" in C/C++, "a / 2+5" would first devide though 2 and
        then add 5, as it would be in AmiBlitz³ (respecting common mathematical
        precedence).@{ui}

@ENDNODE

@NODE Arrays "Arrays"
@{b}2.3 Arrays@{ub}

  @{b}Arrays@{ub} of variables are declared by using the "Var" instruction and
  stating the number of elements in square brackets:
  +-----------------------------------------------------------------------------
  | 
  | Var [@{i}@{"modifier" link "Modifiers"}@{ui}] @{i}name@{ui}.t[@{i}#elements@{ui}]
  |
  +-----------------------------------------------------------------------------

  @{i}name@{ui} is an array of @{i}#elements@{ui} elements of type .t,
  starting from index 0 to @{i}#elements@{ui}-1.
  It is allowed to declare an array with 0 elements. The size of the array
  will be dynamic then.
  The modifier "array" is optional, as it is already clear that we use an 
  array by stating the square brackets.
  
  An element is indexed by:
  +-----------------------------------------------------------------------------
  | 
  | @{i}name@{ui}.t[@{i}index@{ui}]
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: Negative indices are not allowed. If the array is not dynamic, the
        index must be smaller than #elements.@{ui}

  Any array can be "re-dimmed" any time by calling "Redim(@{i}name,#elements@{ui})".
  If the array is down-sized, data might be lost.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Var Race.s[5]        @{i}; declare an array of strings called "Race"@{ui}
  |
  | Race[0] = "Human"    @{i}; fill the elements of the array@{ui}
  | Race[1] = "Elve"
  | Race[2] = "Dwarf"
  | Race[3] = "Ork"
  | Race[4] = "Halfling"
  |
  | For (n.l=0, n<5) {
  |   NPrint Race[n]     @{i}; print out all 5 race names@{ui}
  | }
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: The last element is 4, since we have 5 elements, from 0..4.
        Using 5 or higher as index would cause a runtime error!@{ui}
  @{i}Note: Unlike in AmiBlitz³, Arrays use square brackets.@{ui}

@ENDNODE

@NODE Lists "Lists"
@{b}2.4 Lists@{ub}

  @{b}Lists@{ub} are declared by using "~" (Tilde) and the "Var" instruction:
  +-----------------------------------------------------------------------------
  | 
  | Var [@{i}@{"modifier" link "Modifiers"}@{ui}] @{i}~name@{ui}.t
  | 
  +-----------------------------------------------------------------------------

  @{i}~name@{ui} is now an empty list of type .t. The list is referred by
  using the Tilde before the actual name, whike elements are referred
  without. Elements are handled by the following functions:
  +-----------------------------------------------------------------------------
  | 
  | AddItem(~list)           @{i}; add a new item at the current position and@{ui}
  |                          @{i}; make it the current item@{ui}
  | RemItem(~list)           @{i}; remove the current item from the list@{ui}
  | NextItem(~list)          @{i}; seek to the next item@{ui}
  | PrevItem(~list)          @{i}; seek to the previous item@{ui}
  | ResetList(~list)         @{i}; seek before the first item@{ui}
  | FirstItem(~list)         @{i}; seek to the first item@{ui}
  | LastItem(~list)          @{i}; seek to the last item@{ui}
  | ClearList(~list)         @{i}; remove all items from list@{ui}
  | SortList(~list[,field])  @{i}; sort the list according the field name,@{ui}
  |                          @{i}; if it is a structure@{ui}
  | AddSorted(~list,value[,field]) @{i}; add a new item sorted into the list,@{ui}
  |                                @{i}; by comparing value with field@{ui}
  +-----------------------------------------------------------------------------

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Var ~Race.s                   @{i}; declare a list of strings called Race@{ui}
  | 
  | AddItem(~Race) : Race = "Human"
  | AddItem(~Race) : Race = "Elve"
  | AddItem(~Race) : Race = "Dwarf"
  | 
  | ResetList(~Race)              @{i}; go before the first item@{ui}
  | While (NextItem(~Race)) {     @{i}; print out all items@{ui}
  |   NPrint Race
  | }
  | 
  | ClearList(~Race)              @{i}; remove all items@{ui}
  |
  +-----------------------------------------------------------------------------

@ENDNODE

@NODE Constants "Constants"
@{b}2.8 Constants@{ub}

  Depending on the type, constants are written in different ways:

  @{b}Bool@{ub}      
  True, False, On, Off, -1 or 0

  @{b}Integers@{ub} (Byte, Word, Long, DoubleLong, Signed/Unsigned)
  65      (decimal, = 65)
  $41     (hex,     = 65)
  %10001  (binary,  = 65)
  'A'     (ASCII,   = 65)

  @{b}Floats@{ub} (Float or DoubleFloats)
  65, 65.0

  @{b}Strings@{ub} (String, WideString or CString)
  "A", "Hello World"

  If the type is ambiguous, e.g. Word, Long or Float, the type will be
  determined by choosing the best fitting type within the expression. If
  Information is lost, e.g. when doing x.l = 2.1, the compiler throws a warning.

  @{b}A@{ub} knows the following pre-defined plain-text-constants:

  Symbol      | Description
  ------------+-----------------------------------------------------------------
  True        | logic true,  equals to -1
  False       | logic false, equals to  0
  On          | logic true,  equals to -1
  Off         | logic false, equals to  0
  Pi          | 3.1415926535
  Null        | Null pointer, equals to 0
  
  For use within string constants, the following escape sequences are defined:

  Symbol      | Description    
  ------------+-----------------------------------------------------------------
  \\t          | tab             (ASCII  #9)
  \\n          | new line        (ASCII #10)
  \\r          | carriage return (ASCII #13)
  \\E          | escape          (ASCII #27)
  \\0          | Null Byte       (ASCII  #0)
  \\\\          | Back Slash      (ASCII #92)
  \\"          | quotation mark  (ASCII #34)
  \\x@{i}<hex>@{ui}     | any character given by 2 digit hex value,
              | e.g. \\x40 for "@"
  \\u@{i}<hex>@{ui}     | any 16bit unicode character given by 4 digit hex value,
              | e.g. \\u0040 for "@" (will be UTF-8 encoded)
  \\U@{i}<hex>@{ui}     | any 32bit unicode character given by 8 digit hex value,
              | e.g. \\U00000040 for "@" (will be UTF-8 encoded)
  \\#<macro>   | use a @{i}@{"Macro" link "Macros"}@{ui} text inside of a string
  \\$<var>     | use a @{i}@{"Variable" link "Variables"}@{ui} as text inside of a string

  Examples:
  +-----------------------------------------------------------------------------
  | 
  | myBool.bool = True
  | myFloat.f   = 2*Pi
  | *myPtr.void = Null
  | myString.s  = "Hello World"
  | myInt1.l    = 12345
  | myInt2.l    = $BEEF
  | myInt3.l    = %101110101011
  | myInt4.l    = 'ILBM'
  |
  | If (#_BigEndian) Print "We compile for Big Endian machine!" 
  |
  | version.s   = "$VER: \\#_Program V\\#_Major.\\#_Minor (\\#_Date) by \\#_Author\\n"
  |
  | x.l = 41 : y.l = 27
  | Print "The coordinates are \\$x and \\$y!"
  | 
  +-----------------------------------------------------------------------------

@ENDNODE

@NODE Functions "Functions"
@{b}2.9 Functions@{ub}

  A function is @{b}defined@{ub} as follows:
  +-----------------------------------------------------------------------------
  | 
  | Function [@{i}@{"modifier" link "Modifiers"}@{ui}] @{i}name@{ui}.t (@{i}param@{ui}.t, ...) {
  |   Return @{i}value@{ui}
  | }
  | 
  +-----------------------------------------------------------------------------
  
  Function        : keyword to indicate we are defining a function
  @{i}modifier@{ui}        : optional @{"modifier" link "Modifiers"} keyword
  @{i}name@{ui}            : function's name
  .t              : type extension
  @{i}value@{ui}           : expression we want to return
  @{i}param@{ui}.t, ...    : list of parameters, can be none up to no limit  

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Function AddTwoFloats.f(a.f, b.f) {
  |   result.f = a + b
  |   Return result
  | }
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: Unlike in AmiBlitz³, the type of the return value is specified
        after the function name, and not after the keyword "Function".@{ui}

  If the function has no return value, the type extension after the function
  name is omitted or type .v (void) can be used. There is no need for a
  "Return" statement, unless the function should be exited earlier than the
  closing bracket.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Function NPrint(text.s) {
  |   Print(text+"\\n")
  | }  
  | 
  +-----------------------------------------------------------------------------

  A function can have @{b}optional parameters@{ub}. The optional parameters
  are declared by giving a default value. Once a parameter
  is optional, all following parameters must be optional too.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Function AddLongs.l(a.l, b.l, c.l=0, d.l=0, e.l=0) {
  |   Return a+b+c+d+e
  | }
  |
  | Print AddLongs(3,2,5)   @{i}; this would print "10"@{ui}
  | Print AddLongs(3,2,5,1) @{i}; this would print "11"@{ui}  
  |  
  +-----------------------------------------------------------------------------

  Functions can be @{b}overloaded@{ub}. That means, you can define a function with
  the same function name again, if the parameters are different in number
  and/or type.
  
  Example:
  +-----------------------------------------------------------------------------
  |
  | Function Min.l(a.l,b.l) {              @{i}; first version of Min() of type Long@{ui}
  |   If (a<b) Return a
  |   Return b
  | }
  |
  | Function overload Min.l(a.l,b.l,c.l) { @{i}; another version that takes@{ui} 
  |   If (a<b && a<c) Return a              @{i}; 3 parameters@{ui}
  |   If (b<a && b<c) Return b
  |   Return c
  | }
  |
  | Function overload Min.f(a.f,b.f) {     @{i}; another version that takes floats@{ui}
  |   If (a<b) Return a
  |   Return b 
  | }
  |
  +-----------------------------------------------------------------------------
  @{i}Note: The modifier "overload" is needed to avoid accidental overloading.
        Depending on the strictness level, omitting this modifier results in
        a warning or error.@{ui}

  If a function should be an infix, prefix or postfix operator, the function
  name must use only characters from the operator sympbols:
  "!$%&|/=?`+-'#*~><^:" (excluding the quotes)
 
  Examples:
  +-----------------------------------------------------------------------------
  | 
  | Function --.l(a.l) {      @{i}; decrement, realized as prefix operator@{ui}
  |   Return a-1
  | }
  |
  | Function (a.l)++.l {      @{i}; increment, realized as postfix operator@{ui}
  |   Return a+1
  | }
  |
  | Function |=|.B(a.l,b.l) { @{i}; compare absolute value, infix operator@{ui}
  |   If (a<0) a = -a
  |   If (b<0) b = -b
  |   Return a==b
  | }
  |
  | a.l = 10 : b.l = -10
  | Print --a     ; prints "9"
  | Print a++     ; prints "11"
  | Print a |=| b ; prints "True"
  |
  +-----------------------------------------------------------------------------
  The defined operator will be prefix if it has one argument, infix if it has
  two arguments. More than two parameters must be appened at the right side.
  If the operator should be postfix, place its name behind
  the round brackets.
  
  This is a nice way of defining compact code for a new data type.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Struct tv { @{i}; define the time-value structure@{ui}
  |   hours.l
  |   minutes.l
  |   seconds.l
  | }
  |   
  | @{i}; add two time-values@{ui}
  | Function overload +.tv(a.tv, b.tv) {
  |   Var c.tv
  |   c\\seconds = a\\seconds + b\\seconds
  |   c\\minutes = a\\minutes + b\\minutes
  |   c\\hours   = a\\hours   + b\\hours
  |   If (c\\seconds>60) c\\seconds-60 : c\\minutes+1
  |   If (c\\minutes>60) c\\minutes-60 : c\\hours  +1
  |   Return c
  | }
  |
  | @{i}; cast 3 Longs to a time-value@{ui}
  | Function overload Cast.tv(hours.l, minutes.l, seconds.l) {
  |   Var a.tv
  |   a\\seconds = seconds
  |   a\\minutes = minutes
  |   a\\hours   = hours
  |   Return a
  | }
  |
  | @{i}; assign a time-value@{ui}
  | Function overload =(*a.tv, b.tv) {
  |   a\\seconds = b\\seconds
  |   a\\minutes = b\\minutes
  |   a\\hours   = b\\hours
  | }
  |
  | @{i}; cast time value to string@{ui}
  | Function overload Cast.s(a.tv) {
  |   Return = Str(a\\hours)+":"+Str(a\\minutes)+":"+Str(a\\seconds)
  | }
  |
  | @{i}; now we are done with the heavy work, and life becomes easy...@{ui}
  |
  | Var a.tv,b.tv
  | a = (2, 50, 30)
  | b = (1, 12,  5)
  |
  | Print (a+b) @{i}; this would output: 4:2:35@{ui}
  |
  +-----------------------------------------------------------------------------
  @{i}Note: Unlike C and AmiBlitz³, A/A++ can use functions and other definitions
        like Structures before they are actually defined in the source code.@{ui}

@ENDNODE

@NODE Macros "Macros"
@{b}2.10 Macros@{ub}

  A macro is a definition of text that is inserted during compilation time
  whenever the name of the macro is mentioned. In A, they are defined and
  referred by using a leading "#" (hash sign).
  For macro parameter names, the same rules as for variables apply.
  Recommended is to use only uppercase letters.

  +-----------------------------------------------------------------------------
  | 
  | #myIntConst         5
  | #myFloatConst       5.4
  | #myStringConst      "Test"
  | #myFuncMacro(A,B)   ((A) * (B))
  | 
  | Print #myFuncMacro(2,3)
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: The Print would output "6".@{ui}
  @{i}Note: Macros are handled similar to "integer constants" in AmiBlitz³,
         but they cover all kinds of macros, not only integer values.@{ui}

  A disadvantage of Macros is, that they are typeless.
  Mismatching types are determined AFTER the macro is applied, which makes
  debugging harder.

  If the macro spans over multiple lines, the escaped new line is used:
  +-----------------------------------------------------------------------------
  | 
  | #myMultiLine(A,B,RESULT) { temp.l = A*B 
  |                            RESULT = temp
  |                          }
  |                       
  +-----------------------------------------------------------------------------
  @{i}Note: Since the newline is escaped by "\\", it is not a newline anymore.
        Therefore the colon is needed to seperate the expressions.@{ui}

  Macros preset by the compiler for conditional compiling or
  code/source information:
  
  Symbol         | Description
  ---------------+--------------------------------------------------------------
  #_Debug        | True, if compiled with debug info, False otherwise
  #_Include      | True, if file is included, False if main file
  #_Amiga        | True, if target operation system API is AmigaOS
  #_Win32        | True, if target operation system API is Win32
  #_Amiga3       | True, if target operation system is AmigaOS 3.x
  #_Amiga4       | True, if target operation system is AmigaOS 4.x
  #_MorphOS      | True, if target operation system is MorphOS
  #_AROS         | True, if target operation system is AROS
  #_WinXP        | True, if target operation system is Windows XP
  #_Vista        | True, if target operation system is Windows Vista
  #_Win7         | True, if target operation system is Windows 7.x
  #_WinCE        | True, if target operation system is Windows CE
  #_68K          | True, if target CPU is 68K
  #_PPC          | True, if target CPU is PPC
  #_x86          | True, if target CPU is x86
  #_LittleEndian | True, if target CPU uses Little Endian
  #_BigEndian    | True, if target CPU uses Big Endian
  #_Date         | compilation date (e.g. 21/01/2009)
  #_Time         | compilation time (e.g. 14:25)
  #_Line         | actual line of code (e.g. 1234)
  #_Function     | actual function name (e.g. "MyFunction")
  #_File         | actual source file name e.g. "program.app")
  #_Major        | major version (e.g. 0)
  #_Minor        | minor version (e.g. 4)
  #_Patch        | patch version (e.g. 31)
  #_Build        | autoincremental build counter (e.g. 1241)
  #_Author       | author of the source code (e.g. "Thilo Koehler")
  #_Program      | program name (e.g. "Pic Viewer")        
        
@ENDNODE

@NODE OOP "Object Oriented Programming"
@{b}3 Object Oriented Programming@{ub}

  Every structure (complex type) is also a @{b}class@{ub} in A/A++, there is
  no difference.
  We will say "class" now instead of "structure", as this is according the OOP
  terminology. An instance of the class (e.g. variable in memory) is called
  an @{b}object@{ub}.
  Functions that are associated with a class are called "methods".
  There are class methods and object methods. The difference is, that
  object methods are always associated with an object of the class, that is
  used as the first parameter. A class method may have any parameter signature,
  and does not necessarily work on an object, it can perform class-wide
  operations or anything else.
  To indicate the class a methods belongs to, the class name is put in front
  of the method name, seperated by double colon ("::"').

  There are 4 default functions defined for every class (assuming @{i}classname@{ui}
  is the name of your class):
  +-----------------------------------------------------------------------------
  |
  | @{i}classname@{ui}::Init.bool(*this.@{i}classname@{ui})   @{i}; init the object@{ui}
  | @{i}classname@{ui}::*New.@{i}classname@{ui}()             @{i}; allocate memory and call Init()@{ui}
  | @{i}classname@{ui}::Deinit.bool(*this.@{i}classname@{ui}) @{i}; de-init the object@{ui}
  | @{i}classname@{ui}::Delete.bool(*this.@{i}classname@{ui}) @{i}; call Deinit() and free memory@{ui}
  |
  +-----------------------------------------------------------------------------

  Per default, Init() sets the object's memory to zero, while Deinit()
  does nothing. If you define your own Init/Deinit pair, Init() might
  allocate resources associated with the object, while Deinit() might
  free resources that were allocated in Init() or during the objects
  lifetime.

  Init() and Deinit() are almost always called automatically without your
  notice. E.g. if you declare a variable of type @{i}.classname@{ui}, @{b}A@{ub} will
  call Init() immidiately. The memory is in @{b}A@{ub}'s variable heap and does
  not need to be allocated.
  If the variable gets out of scope, Deinit() is called.

  Most often, you create an object as a pointer by calling New()
  and destroy it by calling Delete().
  New() does nothing else than allocating the memory for the object and then
  call Init() on it, while Delete() calls Deinit() on the object
  and frees the memory.

  To add your own methods, normal functions are used that have "@{i}classname@{ui}::"
  as a prefix of the function name.
  If they have a pointer to the structure as the first parameter,
  they are called @{b}object methods@{ub}. Object methods are called "on" an object
  rather than the class, and the first paramter will be omitted.
  The object itself will work as the first parameter.
  This parameter *should* be called "*this.@{i}classname@{ui}", but doesn't have to.

  If they have a different parameter type as the first parameter, they
  are called @{b}class methods@{ub}, like New() is a class method. Class methods
  need to have "@{i}classname@{ui}::" in front to resolve ambiguities with
  other classes.
  If a method can be associated with a class from the context, e.g. return value,
  it is not necessary to write the classname in front.

  Lifecycle of an object:
  +-----------------------------------------------------------------------------
  | 
  | Struct @{i}classname@{ui} {             @{i}; define the class/structure@{ui}
  |   ... fields...
  | }
  |
  | ; define a method 
  | Function @{i}classname@{ui}::methodname.t(*this.@{i}classname@{ui}, ...) { 
  |   @{i}... do something on object called "this"@{ui}
  | }
  | 
  | ; allocate and init an object
  | *objectname.@{i}classname@{ui} = @{i}classname@{ui}::New()        @{i}; long version@{ui}
  | *objectname.@{i}classname@{ui} = New()                   @{i}; short version@{ui}
  |
  | ; call the method
  | @{i}classname@{ui}::MyMethod(*objectname.@{i}classname@{ui}, ...) @{i}; functional style@{ui}
  | MyMethod(*objectname.@{i}classname@{ui}, ...)            @{i}; functional style, short@{ui}
  | objectname\\MyMethod(...)                        @{i}; OOP style@{ui}
  |
  | ; delete the object
  | @{i}classname@{ui}::Delete(*objectname)                  @{i}; functional style, long@{ui}
  | Delete(*objectname)                             @{i}; functional style, short@{ui}
  | objectname\\Delete()                             @{i}; OOP style@{ui}
  |
  +-----------------------------------------------------------------------------
  @{i}Note: New() is a class method, and therefore cannot be called on an object.@{ui}
         
  Example (recommended style):
  +-----------------------------------------------------------------------------
  | 
  | Struct alien {                          @{i}; define the structure@{ui}
  |   x.f:y.f
  |   energy.f
  |   image.l
  | }
  | 
  | Function alien::Hit(*this.alien,energy.f) { @{i}; define a method@{ui}
  |   this\\energy - energy
  | }
  | 
  | Function alien::Draw(*this.alien) {     @{i}; define another method@{ui}
  |   DrawImage(this\\image,this\\x,this\\y)   @{i}; use fictive function DrawImage()@{ui}
  | }
  | 
  | *myAlien.alien = New()                  @{i}; create a new alien object@{ui}
  | 
  | myAlien\\Hit(10)  @{i}; call the methods on "myAlien" object@{ui}
  | myAlien\\Draw()
  | 
  | Delete(*myAlien)                        @{i}; delete the alien object@{ui}
  |
  +-----------------------------------------------------------------------------
  @{i}Note: New() and Delete() are used in function style, while during the
        usage of the object the object style is used. How to notate the
        function calls is a matter of taste.@{ui}

@ENDNODE

@NODE Inherit "Inherit from Super Class"
@{b}3.1 Inherit from Super Class@{ub}

  A class can inherit the structure and methods from another class, which is
  then referred as the @{b}super class@{ub}.
  Therefore, the structure must be defined by stating the name of the
  super class using the symbols "->" (hyphen and "greater than").
  The inheriting class itself is now called the @{b}sub class@{ub} of the
  super class. The sub class has all fields and methods of the super class,
  plus the fields and methods that are defined for it.

  +-----------------------------------------------------------------------------
  | 
  | Struct @{i}nameofsuperclass@{ui}->@{i}classname@{ui} {   
  |   ...
  | }
  | 
  +-----------------------------------------------------------------------------

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Struct sprite {                     @{i}; define a general "sprite" structure@{ui}
  |   x.f:y.f
  |   image.l
  | }
  | 
  | Function sprite::Draw(*this.sprite) {   @{i}; define a general draw method@{ui}
  |   DrawImage(this\\image,this\\x,this\\y)   @{i}; use fictive function DrawImage()@{ui}
  | }
  | 
  | Struct sprite->alien {  @{i}; define alien sub class, by inheriting from sprite@{ui}
  |   energy.f
  | }
  | 
  | Function alien::Hit(*this.alien,energy.f) { @{i}; define a method for the alien@{ui}
  |   this\\energy - energy
  | }
  | 
  | *myAlien.alien = New()              @{i}; create a new alien object@{ui}
  | 
  | @{i}; call the methods on myAlien object:@{ui}
  | myAlien\\Hit(10)                     @{i}; this works only on aliens!@{ui}
  | myAlien\\Draw()                      @{i}; this is a method inherited from sprite@{ui}
  | Delete(*myAlien)                    @{i}; delete the alien object@{ui}
  |
  +-----------------------------------------------------------------------------

@ENDNODE

@NODE OwnInit "Define own Init/Deinit"
@{b}3.2 Define own Init/Deinit@{ub}

  Per default, every class (structure) has an Init() and a Deinit() function.
  Init() just zeros the memory buffer of the object. If you need to allocate
  resources or want to set inital values, it is handy to pack this into
  the Init() function by "replacing" or "overloading" it.
  
  The default Deinit() function does nothing.
  This is ok for many cases, but if the object allocates own resources (also
  during usage, not only init) and you don't want to write (and let
  the user call) an extra function to free them, you can pack this into the
  Deinit() function by replacing it. The Deinit() function can not be
  overloaded, because it is always called without any parameters.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Struct sprite {                    @{i}; define a general "sprite" structure@{ui}
  |   x.f:y.f
  |   image.l
  | }
  |
  | Function overload sprite::Init.bool(*this.sprite,imagefile.s) {
  |   this\\x     = 100
  |   this\\y     = 100
  |   this\\image = LoadImage(imagefile) @{i}; using fictive function LoadImage()@{ui}
  |   Return (this\\image!=Null)
  | } 
  |
  | Function replace sprite::Deinit.bool(*this.sprite) {
  |   If (this\\image) FreeImage(this\\image) : this\\image = Null
  |   Return True
  | }   
  |
  +-----------------------------------------------------------------------------

  Once the new functions are defined, usage is now as easy as:
  +-----------------------------------------------------------------------------
  |
  | *mySprite.sprite = New("Dh0:images/alien.png",100,100)
  |
  | ...
  |
  | Delete(*mySprite) 
  |
  +-----------------------------------------------------------------------------
  @{i}Note: Per default, the parameters of Init() are propagated to New().@{ui}

  For your understanding, this is the same as if you would do this:
  (without using New()/Delete())
  +-----------------------------------------------------------------------------
  |
  | *mySprite.sprite = AllocMem(SizeOf(sprite),MEMF_ANY)
  | If (*mySprite) {
  |   mySprite\\x     = 100
  |   mySprite\\y     = 100
  |   mySprite\\image = LoadImage("Dh0:images/alien.png")
  |   If (mySprite\\image==Null) {
  |     FreeMem(*mySprite,SizeOf(sprite))
  |     *mySprite = Null
  |   }
  | }
  |
  | ...
  |
  | If (*mySprite) {
  |   If (mySprite\\image) FreeImage(mySprite\\image) : mySprite\\image = Null
  |   FreeMem(*mySprite,SizeOf(sprite))
  |   *mySprite = Null
  | }
  |
  +-----------------------------------------------------------------------------
  
@ENDNODE

@NODE Directives "Compiler Directives"
@{b}2.12 Compiler Directives@{ub}

  A compiler directive is a keyword in the source code that influences the
  compiling process, rather than an expression that generates executable code.
  Compiler directives are all uppercased to identify them easily.

  Keyword          | Description
  -----------------+------------------------------------------------------------
  CSTRICT n        | set the strictness level 0=loose, 1=normal, 2=stict
  CIF (@{i}condition@{ui})  | compile if @{i}condition@{ui} evaluates to True
  CDEF #macro      | compile if macro is defined
  CELSE            | alternative block to CIF or CDEF
  CEND             | end the conditional block
  CERR "text"      | make the compiler output an error message
  CWARN "text"     | make the compiler output a warning message
                   |
  INCLUDE "file"   | include "file" as if written in that place in source code
  SOURCE "file"    | include "file" as source code, only once
  INCBIN "file"    | include "file" as if compiled in that place as binary  
  
  The search order (if not an absolute path in "file") is:
  1. the path set in IDE to the includes directory
  2. the path to the current source code file
  3. the path to the executable to create
  
@ENDNODE

@NODE Modifiers "Modifiers"
@{b}2.11 Modifiers@{ub}

  Modifiers influence the way a function (F), label (L), struct (S) or
  variable (V) behaves.
  
  The following modifiers are defined:

  Symbol    | Applicable | Description
  ----------+-------------------------------------------------------------------
  overload  | F          | overload an existing function
            |            | (overload = same function name, but different parameters)
  inline    | F          | function will be compiled in-line
  library   | F          | the function will be available in the library interface
            |            | (if target is an Amiga Shared Library, DLL, C-Lib etc.)
            |            |
  pointer/* | V          | the variable becomes a "pointer to ..."
            |            |
  replace   | F/L/S      | replace retrospective a function, label or struct 
            |            |
  intern    | F/L/S/V    | the entity is reachable in the same source code file only
  global/@  | F/L/S/V    | the entity is reachable program-wide
            |            | (a field of a class structure becomes class attribute) 
            |            |
  local/'   | L/S/V      | the label/struct/variable is only accessible locally
            |            |

@ENDNODE

@NODE Primitives "Primitive Types"
@{b}2.5 Primitive Types@{ub}

  @{b}A@{ub} knows the following primitive types:

  Name          | Extension    | Size   | Value Range
  --------------+--------------+--------+---------------------------------------
  Void          | .void,   .v  |  0 bit | -
  Bool          | .bool,   .B  |  8 bit | True/False
  Byte          | .byte,   .b  |  8 bit | -128...+127
  Word          | .word,   .w  | 16 bit | -32768...+32767
  Long          | .long,   .l  | 32 bit | -2^31...+2^31-1
  Float         | .float,  .f  | 32 bit | quite large
  String        | .str,    .s  | 32 bit | character string from 0-2^31-1 length
                |              | +64+(n+1)*8 bit

  In future versions of A, more types are planed:

  Name          | Extension    | Size   | Value Range
  --------------+--------------+--------+---------------------------------------
  Character     | .char,   .c  |  8 bit | 0...255
  WideCharacter | .wchar,  .wc | 16 bit | 0...65535 
  Unsigned Byte | .ubyte,  .ub |  8 bit | 0...255
  Unsigned Word | .uword,  .uw | 16 bit | 0...65535
  Unsigned Long | .ulong,  .ul | 32 bit | 0...+2^32-1
  Double Float  | .dfloat, .df | 64 bit | even larger
  Double Long   | .dlong,  .dl | 64 bit | 0...2^64-1
  Large Number  | .lnum,   .ln | n*16Bit| -inf ... +inf
  C-String      | .cstr,   .cs | 32 Bit | Null-terminated array of characters
                |              | +(n+1)*8 bit 
  WideString    | .wstr,   .ws | 32 bit | wide char string from 0-2^31-1 length
                |              | +64+(n+1)*16 bit
                
  The @{b}A@{ub} Compiler will throw a warning or an error if the types within an
  expression don't match, depending on the similarity of the types and the
  strictness level.
  To be sure to avoid warnings/error in all strictness levels, different types
  must be "casted" explicitly to fit, using the "Cast.t" function.
  
  Examples:
  +-----------------------------------------------------------------------------
  | 
  | a.f = 1           @{i}; set the variable a of type Float to the initial value 1@{ui}
  | x.l = 2           @{i}; set the variable x of type Long to the initial value 2@{ui}
  | y.f = x + a       @{i}; set the variable x to the sum of x and a.@{ui}
  |                   @{i}; Note: This will cause a warning at the highest strictness@{ui}
  |                   @{i}; level, since x has a different type than y and a@{ui}
  | y.f = Cast.f(x)+a @{i}; this will case x to a float, and then add it to a@{ui}
  | s.s = "Test"
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: The Cast() function has some aliases, to make the source look more
        readable: Str(), Val(), Int(). It will be often omitted, e.g.
        when the casting is relatively safe, e.g. from long to float.@{ui}

@ENDNODE

@NODE Structures "Structures"
@{b}2.6 Structures (Complex Types, NewTypes)@{ub}

  Structures are compositions of primitive and/or other structures.
  They are defined using the "Struct" keyword:
  +-----------------------------------------------------------------------------
  | 
  | Struct @{i}name@{ui} {
  |   [@{i}@{"modifier" link "Modifiers"}@{ui}] @{i}varname@{ui}.t
  |   ...
  | }
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: Unlike in AmiBlitz³ and C, you can assign complex types. But be
        careful, if the types contain pointers you are planning to free, since
        an assign will make a flat copy - the content of pointers will not be
        douplicated.@{ui}

  A field in the type is addressed by using "\\" (back slash):
  +-----------------------------------------------------------------------------
  | 
  | Struct myType {
  |   x.f
  |   y.f
  | }
  |
  | Var test.myType
  | test\\x = 1,2
  | Print test\\x
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: When assigning values, multiple fields can be filled at once by
        starting with one field and give several values separated by commas.@{ui}

  If a field is declared as global, is will still behave like a field of the
  structure, however, it will physically exist only once (globally).
  So even if you have two instances, change a global field will change it for
  the other instance too. Global fields don't contribute to the SizeOf value.

  +-----------------------------------------------------------------------------
  | 
  | Struct @{i}name@{ui} {
  |   global @{i}var1@{ui}.t @{i}; this will be a global field@{ui}
  |   @{i}@var2@{ui}.t    @{i}; this will be global too@{ui}
  |   @{i}var3@{ui}.t @{i}; this will be a regular field@{ui}
  |   ...
  | }
  | 
  +-----------------------------------------------------------------------------
  
  Because structs are often used in combination with pointers, there are
  two dedicated functions type::New and type::Delete for
  allocating+initializing and deinitialization+freeing:
  +-----------------------------------------------------------------------------
  | 
  | Struct myType {
  |   x.f
  |   y.f
  | }
  |
  | *test.myType = New()
  | test\\x = 1,2
  | Print test\\x
  |
  | @{i}; delete in functional style:@{ui}
  | Delete(*test)
  | 
  | @{i}; delete in OOP style:@{ui}
  | test\\Delete()
  |
  +-----------------------------------------------------------------------------
  @{i}Note: This is going to be more important when it comes to
        Object Oriented Programing.@{ui}

@ENDNODE

@NODE Pointers "Pointers"
@{b}2.7 Pointers@{ub}

  To declare a pointer variable to a certain type instead of the type
  itself, the "*" (asterix) sign will be put in front.
  The * is always in front of the variable name if the pointer itself is
  addressed. If the * is left out, the content of the pointer is addressed. 

  Example:
  +-----------------------------------------------------------------------------
  | 
  | *myPointer.l = Null  @{i}; declare myPointer and let it point to address 0@{ui}
  | 
  | myPointer  = 12345   @{i}; this would set the long at the memory address to 12345@{ui}
  | *myPointer = 12345   @{i}; this would change the pointer to point to 12345@{ui}
  |                      @{i}; (which is a bad idea, actually)@{ui}
  |   
  +-----------------------------------------------------------------------------
  @{i}Note: There is a special build-in constant called "Null", that represents
        the Null pointer. Whenever you set or test for Null pointers, use this
        constant instread of 0. This is easier to read.@{ui}

  To get a pointer to a variable or label use "&" (ampersand) in front of
  its name.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | *myPointer.l = &x.l   @{i}; let myPointer point to the content of x@{ui}
  | myPointer    = 12345  @{i}; this will set the content of myPointer to 12345.@{ui}
  |                       @{i}; Note: because it points to the content of x,@{ui}
  |                       @{i}; x is changed too!@{ui}
  | 
  +-----------------------------------------------------------------------------

  Every pointer variable has the ability to function as an array.
  Just use the square brackets + index to jump to the memory location,
  as if it was an array. Be carefuly to not read over the boundaries!

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Var A.l[100]
  | *myPointer.l = &A[50] @{i}; let myPointer point to the content of A[50]@{ui}
  | myPointer    = 12345  @{i}; this will set the content of myPointer to 12345.@{ui}
  | myPointer[7] = 12345  @{i}; this will set the content of myPointer[7] to 12345.@{ui}
  |                       @{i}; Note: because it points to the content of A[50],@{ui}
  |                       @{i}; A[50] and A[57] are changed too!@{ui}
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: Actually, "Var A.t[100]" does nothing else than defining *A.t,
        and allocate memory for 100 elements of type .t, plus initializing them.@{ui}

@ENDNODE

@NODE ProgramFlow "Program Flow"
@{b}2.1 Program Flow@{ub}

  The program flow is from top down. The program starts with the first
  expression in the source code and keeps on running until it exits with
  "End". It forces an "End" if the execution runs into the void.

@{b}2.1.0 Labels@{ub}

  +-----------------------------------------------------------------------------
  |
  | [@{i}@{"modifier" link "Modifiers"}@{ui}] @{i}label@{ui}:
  |
  +-----------------------------------------------------------------------------
  
  A label is specified by stating its name with an optional modifier in front.
  It is a good style to use a seperating ":" (colon) after the label,
  however, it is not necessary. 

  To avoid clashes of label names, a label is per default "intern" (accessible
  only within the same source code file).
  If the label should be global, you must specify "global" or "@" (at sign)
  modifier.
  
  A label can be made locally unique, by using the "local" or ' (apostrophe)
  modifier. The label name will be concatenated with the previous non-local
  label, thus being locally unique.

  A label can have the following @{b}modifiers@{ub}:

  intern   : the function is reachable within the same source code file only
             (default)
  global   : the function is reachable program wide
  @        : shortcut for extern
  local    : label is expanded by the previous label, thus being locally unique
  '        : shortcut for local
  replace  : this allows to entirely replace a label (not a good style!)
  
  Example:
  +-----------------------------------------------------------------------------
  |
  | John:         @{i}; this is accessible within the same source code file@{ui}
  | intern John:  @{i}; "@{ui}
  |
  | 'Smith:       @{i}; actual label name becomes "JohnSmith"@{ui}
  | local Smith:  @{i}; "@{ui}
  |
  | @Jack:        @{i}; this is accessible within the whole program@{ui}
  | global Jack:  @{i}; " @{ui}
  |
  | 'Smith:       @{i}; actual label name becomes "JackSmith" and does not clash with@{ui}
  |                 @{i}above 'Smith, thus being locally unique.@{ui}
  |
  +-----------------------------------------------------------------------------

@{b}2.1.1 Goto@{ub}

  +-----------------------------------------------------------------------------
  |
  | Goto @{i}label@{ui}
  |
  +-----------------------------------------------------------------------------
  
  A simple branch is performed. Program execution will continue
  at the position of the label.

  +-----------------------------------------------------------------------------
  | 
  | myLabel:
  | 
  | ...
  | 
  | Goto myLabel
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: "Goto" is usually considered as beginner programming style and
        theoretically can be always avoided. However, there might be
        situation where a "Goto" is handy and makes life easier.@{ui}

@{b}2.1.2 If/Else @{ub}

  To make the execution of a block of statements dependent on a condition
  (expression that evaluates to type bool), use "If":

  +-----------------------------------------------------------------------------
  |
  | If (@{i}condition@{ui}) { ... }
  |
  +-----------------------------------------------------------------------------

  The curly brackets are only needed, if the block spans over multiple lines.
  Otherwise they can be omitted.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | If (a==0) : a=1 : Print "Hello!"
  |  
  | If (a==0) { 
  |   a=1
  |   Print "Hello!"
  | }
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: The colon after the first "If" is not necessary, by increases
        the readability.@{ui}

  For every "If", you can define an alternative "Else" block:

  +-----------------------------------------------------------------------------
  |
  | If (@{i}condition@{ui}) { ... } Else { ... }
  |
  +-----------------------------------------------------------------------------

  Same rules for multilines apply for the "Else" block.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | If (a==0) : a=1 : Print "Hello!" : Else a=0 : Print "Blabla."
  |  
  | If (a==0) { 
  |   a=1
  |   Print "Hello!"
  | } Else {
  |   a=0
  |   Print "Blabla."
  | }
  | 
  +-----------------------------------------------------------------------------

@{b}2.1.3 While@{ub}

  +-----------------------------------------------------------------------------
  |
  | While (@{i}condition@{ui}) { ... }
  |
  +-----------------------------------------------------------------------------

  This executes a block of expressions, while the @{i}condition@{ui} evaluates
  to True. If the block is entirely in the same line, no brackets are required.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | While (a>0) : a=a-1 : Print "Hello!"
  | 
  | While (a>0) { 
  |   a=a-1 
  |   Print "Hello!"
  | }
  | 
  +-----------------------------------------------------------------------------

@{b}2.1.4 Repeat/Until@{ub}

  +-----------------------------------------------------------------------------
  |
  | Repeat { ... } Until (@{i}condition@{ui})
  |
  +-----------------------------------------------------------------------------

  This is the same like a while loop, only that the @{i}condition@{ui} is tested
  at the end of the block in contrast to the beginning of the block. Thus, the
  block is always executed at least once.
  If the block is entirely in the same line, no brackets are required.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Repeat : a=a-1 : Print "Hello!" : Until (a<=0)
  | 
  | Repeat { 
  |   a=a-1
  |   Print "Hello!"
  | } Until (a<=0)
  | 
  +-----------------------------------------------------------------------------

@{b}2.1.5 For@{ub}

  +-----------------------------------------------------------------------------
  |
  | For (@{i}init@{ui}, @{i}condition@{ui} [,@{i}increment@{ui}]) { ... } 
  |
  +-----------------------------------------------------------------------------

  A "For" loop is a loop that typically sets a counter variable in @{i}init@{ui},
  checks for the @{i}condition@{ui}, executes a block of expressions and then
  de/increments the counter.
  If the block is entirely in the same line, no brackets are required.

  The increment is optional, and auto-increments the counter about 1 if omitted.
  
  Examples:
  +-----------------------------------------------------------------------------
  |
  | For (n=a, n<b) { ... }      @{i}; n is incremented by 1 for each cycle@{ui}
  | For (n=a, n<b, n+c) { ... } @{i}; n is incremented by c for each cycle@{ui}
  | For (n=a, n>b, n-c) { ... } @{i}; n is decremented by c for each cycle@{ui}
  | For (n=a, n<b, n*2) { ... } @{i}; n is multiplied by 2 for each cycle@{ui}
  |
  +-----------------------------------------------------------------------------
  @{i}Note: This is more flexible than a common "For...To...Next" construct in a
        Basic dialect, and it conforms more to the strict functional
        syntax approach of C.@{ui}
  
  A real example (output the first 100 integer numbers):
  +-----------------------------------------------------------------------------
  |
  | For (n.l=1, n<=100) : Print n 
  | 
  | For (n.l=1, n<=100) { 
  |   Print n
  | }
  |
  +-----------------------------------------------------------------------------

@{b}2.1.6 Select/Case@{ub}

  "Select" is selecting a "Case Block" for execution that matches a previously
  given value.
  +-----------------------------------------------------------------------------
  | 
  | Select (@{i}value@{ui}) {
  |   Case @{i}alternative1@{ui}
  |     ...
  |   Case @{i}alternative2@{ui}
  |     ...
  |   ...
  |   Default 
  |     ...
  | }
  | 
  +-----------------------------------------------------------------------------

  If multiple values should match the same block, they can be stated seperated
  by commas.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Select (a.l) {
  |   Case 1   : Print "Value is 1"
  |   Case 2   : Print "Value is 2"
  |   Case 3,4 : Print "Value is 3 or 4"
  |   Default  : Print "Value is something else..."
  | }
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: Unlike C "switch", no "break" is needed after each block.@{ui}

@{b}2.1.7 Assert@{ub}

  +-----------------------------------------------------------------------------
  | 
  | Assert (condition.Bool[, text.s])
  | 
  +-----------------------------------------------------------------------------

  Assert causes a runtime error, if the condition evaluates to False.
  When a runtime error occures, a requester will be displayed showing a
  runtime error message including the optional text. The user has the two
  choises, continue (at own risk!) or shut down the application.
  If the compiler generates a release exectuable, this function is ignored.
  
  Example:
  +-----------------------------------------------------------------------------
  |
  | Function DoSomething(*myObject.object) { 
  |   Assert (*myObject, "Null-pointer as parameter in \\#_Function!")
  |   ...
  | }
  | 
  +-----------------------------------------------------------------------------
  
@{b}2.1.8 End/InitA@{ub}

  +-----------------------------------------------------------------------------
  | 
  | End [code.l=0]
  | 
  +-----------------------------------------------------------------------------

  "End" frees all resources (that A is aware of...) and terminates the program.
  All programs, including libraries, must have this function as the
  last instruction.
  Optionally, you can let the program return an error code. Default is 0 (ok).

  +-----------------------------------------------------------------------------
  | 
  | InitA
  | 
  +-----------------------------------------------------------------------------

  "InitA" will move the initialization code of @{b}A/A++@{ub} to this line.
  It is not allowed to execute any @{b}A/A++@{ub} code before this function is called!
  If there is no InitA, this will be done before the first line of source code.
  "InitA" can be called at maximum once!

@ENDNODE

@NODE AFunctions "A - Build-In Function Reference"
@{b}4 Build-In Functions@{ub}

@{b}4.1 Assign Operators@{ub}

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  x = y          | assign y to x (primitive types only)
  x := y         | assign y to x (primitive or complex flat copy)
  x ~= y         | assign y approximately to x (autmatic cast)

@{b}4.2 Comparators@{ub}

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  x == y         | True if x is equal to y, False otherwise
  x >  y         | True if x is greater than y, False otherwise
  x >= y         | True if x is greater than or equal y, False otherwise
  x <  y         | True if x is smaller than y, False otherwise
  x <= y         | True if x is smaller than or equal y, False otherwise
  x != y         | True if x is not equal to y, False otherwise

@{b}4.3 Logic Operators@{ub}

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  !x             | logic NOT
  x && y         | logic AND
  x || y         | logic OR
  x ## y         | logic XOR, equals to (x && !y) || (!x && y)

@{b}4.4 Bit Manipulating Operators@{ub}

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  x # -1         | bitwise negation of x (= XOR with all bits set)
  x & y          | bitwise AND (integer only)
  x | y          | bitwise OR  (integer only)
  x # y          | bitwise XOR (integer only)
  x >> y         | shift down x about y bits (sign respected)
  x >>> y        | forced unsigned shift down
  x << y         | shift up x about y bits

@{b}4.5 Math Operators@{ub}

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  -x             | negation of x
  x + y          | add x and y
  x - y          | subtract y from x
  x * y          | multiply x by y
  x / y          | divide x through y
  x % y          | x modulo y 
  x ^ y          | x power y
  Log.f(x.f,y.f) | logarithm of x to base y

@{b}4.6 Trigonometric Functions@{ub}

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  Sin.f(x.f)     | Sinus of x
  Cos.f(x.f)     | Cosinus of x
  Tan.f(x.f)     | Tangents of x
  ASin.f(x.f)    | inverse Sinus of x
  ACos.f(x.f)    | inverse Cosinus of x
  ATan.f(x.f)    | inverse Tangents of x 

@{b}4.7 String Functions@{ub}

  Symbol                    | Description
  --------------------------+---------------------------------------------------
  Range.s(str.s,pos.p,n.p)  | crop n characters starting from pos of str 
  Len.p(str.s)              | string length of str

@{b}4.8 Program Flow Functions@{ub}

  Symbol                    | Description
  --------------------------+---------------------------------------------------
  Var a.t                   | declare and initialized variable a of type t
  Var a.t[n]                | dimension an array of type t with n indices
  Var ~a.t                  | create a linked list of name a of type t
  Struct name {...}         | declare a data structure
  Function name (...) {...} | declare a function
  Goto label                | unconditional branch
  Return (r)                | return from a function 
  For (i,c,a) {...}         | "For" loop
  While (c) {...}           | "While" loop
  Repeat {...} Until (c)    | "Repeat" loop
  If (c) {...}              | "If" block
  Else {...}                | "Else" block
  Select (x) {...}          | "Select" block
  Case y                    | "Case" block
  End (r)                   | end program
  Assert(c,text.s)          | cause a runtime error if c is false
  InitA                     | init A context

@{b}4.9 Connection to the Outer World@{ub}

  Symbol                    | Description
  --------------------------+---------------------------------------------------
  LibCall.t(Lib\\Func(...))  | call an external library function
  OpenLib.B(Lib)            | open a library
  CloseLib.B(Lib)           | close a library

@{b}4.10 Memory Functions@{ub}

  Symbol               | Description
  ---------------------+--------------------------------------------------------
  Dc.t value           | declare a value directly in binary code
  SizeOf.p(x)          | memory size of type or expression x
  TypeOf.l(x)          | type ID of expression x or type 
  Peek.t(mem)          | (flat) copy the data from mem to the structure
  Poke.t(mem)          | (flat) copy the data from the structure to mem
  Pop.t()              | (flat) copy the data from stack to the structure
  Push.t(value)        | (flat) copy the data from the structure to stack

@{b}4.11 Default Object/Class Functions@{ub}

  Symbol               | Description
  ---------------------+--------------------------------------------------------
  type::New.t(...)     | allocate and initialize a structure
  type::Delete.bool()  | de-initialize and free a structure/array
  type::Init.bool(...) | initialize a structure
  type::DeInit.bool()  | de-initalize a structure

@{b}4.12 Casting Function@{ub}

  Symbol        | Description
  --------------+---------------------------------------------------------------
  Cast.t(x)     | convert x to .t, general casting function
                | use Cast.*t() or *Cast.t() to cast as "pointer to .t"

@ENDNODE


@NODE APP "5 A++ Library Reference"
@{b}5 A++ Library Reference@{ub}

  The A++ Library can be considered to be the A runtime. It is written in A.
  It covers the main aspects of programming.
  
  Overview:

5.1 @{"Basic Runtime Library"      link "BRL"}      

  This is a set of functions that complete the build-in functions.
  You will find here more string functions, I/O functions,
  numeric functions etc.

5.2 @{"File Library"               link "File"}     

  The File Library implements the CFile class, that is used for file access. 

5.3 @{"Graphic Library"            link "Graphic"}

  The Graphic Library implements the CImage Class that can be used to load,
  display, manipulate and save images.
  
5.4 @{"Audio Library"              link "Audio"}

  The Audio Library implements the CSound and CAudioStream class, that can be
  used to load, play and save sounds either in memory or streamed from disk.   
  
5.5 @{"GUI Library"                link "GUI"}

  The GUI Library implements a wider set of classes, such as CWindow, CScreen,
  CEvent and encapsules GUI from the acutal operation system. However, this is
  not a GUI toolkit.
  
5.6 @{"NTUI Library"               link "NTUI"}

  The NTUI Library implements th NTUI GUI Toolkit for system independent GUIs.
  
5.7 @{"Network Library"            link "Network"}

  The Network Library implements the CNet class, that provides easy Internet or
  local network access for web applications, network gaming etc.     
  
5.8 @{"Game Library"               link "Game"}

  The Ggame Library provides functionality for game related development, such
  as the CDisplay class for double buffered display or OpenGL functions.
  
5.9 @{"Data Library"               link "Data"}     

  The Data Library implements various concepts how to handle data efficiently,
  e.g. a hashmap, prefixtree, undo container management etc.
  
@ENDNODE


@NODE BRL "5.1 Basic Runtime Library"
@{b}5.1 Basic Runtime@{ub}
 
  The basic runtime Library provides every-day functions for various problems.
  It is per default included when an A program is compiled.

@{b}5.1.1 Memory Functions@{ub}
  
  Symbol                 | Description
  -----------------------+------------------------------------------------------
  Redim(array,count)     | resize an array to count elements
  MAlloc.p(size)         | allocate block of n bytes
  MFree(mem)             | free memory block
  MClear(mem,size)       | clear memory
  MCopy(from,to,size)    | copy memory (can overlap!)
  MFlip(mem,size,count)  | flip endianess   

@{b}5.1.2 Math Functions@{ub}
  
  Symbol        | Description
  --------------+---------------------------------------------------------------
  Log10(a)      | = Log(a,10), logarithm decimalis of a
  Ln(a)         | = Log(a,e), logarithm naturalis of a
  Ld(a)         | = Log(a,2), logarithm dualis of a
  Exp(a)        | = e^a, exponent a
  Pow(a,b)      | = a^b, a power b 
  Sqr(a)        | = a^.5, square root of a
  Rnd(a,b)      | random number between (and including)  a and b
  Randomize(a)  | set seed for Rnd()
  Sgn(a)        | signum of a
  Abs(a)        | absolute value of a
  Min(a,b)      | minimum of a and b
  Max(a,b)      | maximum of a and b
  Lim(a,b,c)    | limit a between b and c
  Wrap(a,b,c)   | wrap a between b and c
  Rad(a)        | convert degree to rad
  Deg(a)        | convert rad to degree
  a++           | = (a=a+1), increase a
  Inc(a)        | "
  --a           | = (a=a-1), decrease a
  Dec(a)        | "

@{b}5.1.3 String Functions@{ub}
  
  Symbol                           | Description
  ---------------------------------+--------------------------------------------
  str.s = Replace.s(str.s,a.s,b.s) | replace all a with b in str
  pos.p = Instr.p(str.s,a.s,pos.p) | position of a in str, starting from pos
  str.s = UpperCase.s(str.s)       | turn the string to upper case
  str.s = LowerCase.s(str.s)       | turn the string to lower case
  str.s = Left.s(str.s,n.l)        | left n characters of str
  str.s = Right.s(str.s,n.l)       | right n characters of str
  str.s = Trim.s(str.s)            | trim (remove leading/trailing spaces)
  str.s = LIndex.s(str.s,n.l)      | get the nth element in the string
  str.s = LLength.s(str.s)         | count the elements in the string
  
@{b}5.1.4 I/O Functions@{ub}
  
  Symbol                   | Description
  -------------------------+----------------------------------------------------
           Print(text.s)   | print a text to the console
           NPrint(text.s)  | print a text and a return code to console
  text.s = Input.s(max.l)  | read input from console
  char.s = Inkey.s()       | read a character from console
           Alert(text.s)   | display an alert message as a requester
 
@{b}5.1.5 File Functions:@{ub}

  Symbol                                   | Description
  -----------------------------------------+------------------------------------
  fid.p  = FOpen.p(name.s,access.s)        | open file
           FClose(fid.p)                   | close file
  succ.B = FDelete.B(name.s)               | delete file
  succ.B = FSeek.p(fid.p,pos.p)            | seek to position
  pos.p  = FGetPos(fid.p)                  | get file position
  len.p  = FGetLength(fid.p)               | get file length
                                           |
  len.p  = FRead.p(fid.p,mem.p,size.p)     | read memory from file
  dat.b  = FReadByte.b(fid.p)              | 
  dat.w  = FReadWord.w(fid.p)              |
  dat.l  = FReadLong.l(fid.p)              |
  dat.s  = FReadStr.s(fid.p)               |
  dat.f  = FReadFloat.f(fid.p)             | 
  dat.s  = FReadLine.s(fid.p)              |
                                           |
  len.p  = FWrite.p(fid.p,mem.p,size.p)    | write memory to file
  succ.B = FWriteByte.B(fid.p)             |
  succ.B = FWriteWord.B(fid.p)             |
  succ.B = FWriteLong.B(fid.p)             |
  succ.B = FWriteStr.B(fid.p)              |
  succ.B = FWriteFloat.B(fid.p)            |
  succ.B = FWriteLine.B(fid.p)             |
                                           |
  name.l = FReadTag.l(fid.p)               |
  dat.l  = FGetTagL.l(fid.p)               |
  dat.s  = FGetTagS.s(fid.p)               |
  dat.f  = FGetTagF.f(fid.p)               |
  succ.B = FWriteTagL.B(fid.p,tag.l,dat.l) |
  succ.B = FWriteTagS.B(fid.p,tag.l,dat.s) |
  succ.B = FWriteTagF.B(fid.p,tag.l,dat.f) |
                                           |
  succ.B = FWriteChunk(fid.p,name.l)       |
  succ.B = FCloseChunk(fid.p,name.l)       |
  pos.p  = FFindChunk(fid.p,name.l,pos.p)  |
                                           |
  
@ENDNODE


@NODE File "File Library"
@{b}5.2 File Library Reference@{ub}

@{b}5.2.1 CFile Class@{ub}
  
  CFile::New()
  CFile::Init()
  CFile::Delete()
  CFile::Deinit()
  
  CFile::Open(filename.s,mode.l)
  CFile::Read(buffer.p,length.p)
  CFile::Write(buffer.p,length.p)
  CFile::Close()
  CFile::Seek(position.p)
  CFile::GetPos()
  CFile::EOF()
  CFile::Length()
  CFile::GetFP()
  CFile::SetCacheMode(mode.l)
  
@{b}5.2.2 File Functions:@{ub}
  
  DeleteFile(filename.s)
  RenameFile(filename.s)
  AddPart(path.s,file.s)
  PathPart(file.s)
  FilePart(file.s)
  RealPath(file.s)
  
  GetFirstFile(path.s)
  GetNextFile()
  
  GetFirstDevice(flags.l)
  GetNextDevice()

  GetFreeDiskSpace(path.s)
  GetUsedDiskSpace(path.s)
  GetDiskSize(path.s)
  
@ENDNODE


@NODE Graphic "Graphic Library"
@{b}5.3 Graphic Library Reference@{ub}

@{b}5.3.1 CImage Class@{ub}

  The CImage class handles bitmap images. It can load, manipulate, display
  and save images in various formats.

  CImage::FreeAll()

  CImage::New.CImage()
  CImage::Delete.B()
  CImage::Init.B()
  CImage::Deinit.B()

  CImage::width.w
  CImage::height.w
  CImage::hasAlpha.B
  CImage::hasMask.B
  CImage::bytesPerRow.w
  
  CImage::New.CImage(width.l,height.l)
  CImage::Init.B(width.l,height.l)
  CImage::Load.B(filename.s)
  CImage::Cut(from.CImage,left.l,top.l,right.l,bottom.l)
  CImage::Save.B(filename.s,format.l)
  
  CImage::SetAlpha(A.l)
  CImage::SetAlpha(alpha.CImage)
  CImage::SetAlpha(pixelArray.p,width.l,height.l,bytesPerRow.l)
  CImage::SetAlphaFromMask()
  CImage::FreeAlpha()

  CImage::SetMask(transparentRGB.l)  
  CImage::SetMaskFromAlpha(threshold.l)
  CImage::FreeMask()

  CImage::Resize.B(width.l,height.l)
  CImage::SetClip(left.l,top.l,right.l,bottom.l)
  CImage::Filter(filterID.l,amount.l,*tags.TagItem)
  CImage::Draw(rastport,x.l,y.l)
  CImage::Release()
  CImage::Prepare(rastport)
  CImage::SetARGB(ARGB.l[,x.l,y.l])
  CImage::GetARGB([x.l,y.l])
  CImage::Remap(cmap.CColMap)

  CImage::Read(file.CFile)
  CImage::Write(file.CFile,format.l)
  
@{b}5.3.2 CColMap Class@{ub}

  The CColMap class handles color maps. A color map is a list of pens and their
  corresponding RGB values. THis is used e.g. to remap an image to a certain
  palette on color indexed screens (<= 8bit screens).
  This class is used by the CImage to prepare an image for display.

  CColMap::New.CColMap()
  CColMap::Delete.B()
  CColMap::Init.B()
  CColMap::Deinit.B()
  
  CColMap::CreateGreySscale([numColors.l=256])
  CColMap::CreateRGB8()
  CColMap::CreateFromStatistic(stat.CColStatistic[,numColors.l=256])
  CColMap::GetFromScreen(screen.CScreen)
  CColMap::SetToScreen(screen.CScreen)
  CColMap::Remap(fromPixelArray.p,width.l,height.l,bpr.l,
                 toPixelArray.p  ,width.l,height.l,bpr.l)

@{b}5.3.2 CColStatistic Class@{ub}

  CColStatistic::Accumulate(ARGBPixelArray.p,width.l,height.l,bpr.l)
  
@ENDNODE


@NODE Audio "Audio Library"
@{b}5.4 Audio Library Reference@{ub}

@{b}5.4.1 CSound Class@{ub}

  The CSound handles samples. It can load, play and save audio files in various
  formats. A CSound is typically hold in memory and used for instant and
  frequent playback, such as sounds in games. It is not suitable for long
  audio files such as music. See CAudioStream for music playback.
  
  CSound::New()
  CSound::Delete()
  CSound::Init()
  CSound::Deinit()

  CSound::samplerate.l
  CSound::bits.l
  CSound::channels.l
  CSound::frameLength.l
  CSound::bytesPerFrame.l
  
  CSound::New(length.l,samplerate.l)
  CSound::Load(filename)
  CSound::Save(filename,format.l)
  CSound::Play()
  CSound::LoopPlay()
  CSound::Stop()
  CSound::Resample(samplerate.l)
  CSound::Stereo2Mono(channelSelect.l)
  CSound::Mono2Stereo()
  CSound::Convert(bits.l)

@{b}5.4.2 CAudioStream Class@{ub}
  
  CAudioStream::New()
  CAudioStream::Delete()
  CAudioStream::Init()
  CAudioStream::Deinit()

  CAudioStream::New(filename.s)
  CAudioStream::Open(filename.s)
  CAudioStream::Play()
  CAudioStream::Check()
  CAudioStream::Jump(position.l)
  CAudioStream::Stop()
  CAudioStream::WriteBuffer()
  CAudioStream::ReadBuffer()
  CAudioStream::BufferPtr()
  CAudioStream::BufferSize()
    
@ENDNODE


@NODE GUI "GUI Library"
@{b}5.5 GUI Library Reference@{ub}

@{b}5.5.1 CWindow Class@{ub}
  
@{b}5.5.2 CScreen Class@{ub}
  
@{b}5.5.3 CEvent Class@{ub}
  
@{b}5.5.4 CFont Class@{ub}
  
  ...
  
@ENDNODE


@NODE NTUI "NTUI Library Reference"
@{b}5.6 NTUI Library Reference@{ub}

  5.6.1 @{"NTUI Object"                       link "ntuiObject"}
  5.6.2 @{"NTUI Engine"                       link "ntuiEngine"}
  5.6.3 @{"NTUI Window"                       link "ntuiWindow"}
  5.6.4 @{"NTUI Group"                        link "ntuiGroup"}
  5.6.5 @{"NTUI Label"                        link "ntuiLabel"}
  5.6.6 @{"NTUI Button"                       link "ntuiButton"}
  5.6.7 @{"NTUI Scroller"                     link "ntuiScroller"}
  5.6.8 @{"NTUI Slider"                       link "ntuiSlider"}
  5.6.9 @{"NTUI Seperator"                    link "ntuiSeperator"}
  5.6.10 @{"NTUI Balancer"                     link "ntuiBalancer"}
  5.6.11 @{"NTUI Menu"                         link "ntuiMenu"}
  5.6.12 @{"NTUI Image"                        link "ntuiImage"}
  5.6.13 @{"NTUI CustomView"                   link "ntuiCustomView"}
  5.6.14 @{"NTUI ProgressBar"                  link "ntuiProgressBar"}
  5.6.15 @{"NTUI TabView"                      link "ntuiTabView"}
  5.6.16 @{"NTUI ScrollView"                   link "ntuiScrollView"}
  5.6.17 @{"NTUI ListView"                     link "ntuiListView"}
  ...
  5.6.20 @{"How to write your own NTUI Widgets"                       link "ntuiCustom"}

@ENDNODE

@NODE ntuiCustom "How to write your own NTUI Widgets"
@{b}5.6.0 How to write your own NTUI Widgets@{ub}

  Every ntui widget is a subclass of the tuiObject class.
  The interface to ntui consists of a handful of functions, that need to be
  implemented and the function pointers must be set in the tuiObject structure.
  
  The first function is the constructor:
  
  ntuiMyWidget* ntui_MyWidget(...) {
    tuiObject* obj = _ntui_CreateObject();
	myWidget = (ntuiMyWidget*)obj;
	// ...
	return myWidget;
  }
  
  
  
  Checklist:
  * Are custom TUI<>A_... defined with TUIA_USER + x?
  * Get/SetAttr shall return True, if Attrbiute was processed, false otherwise
  * Set #TUI_HAS_<xzy> constant
  * Events: - SetXMLAttrs
          - seperate correct against mouse buttons
          - keyboard support?
  * Layout: bbox, ibox and cbox
  * Make ASSERT for Object Type!

@ENDNODE

@NODE ntuiObject "NTUI Object"
@{b}5.6.2 NTUI Object Class@{ub}

  This is the tuiObject super class. All NTUI widgets, including the tuiEngine, are subclasses of the tuiObject,
  and therefore support all methods listed for this class.
  
  There is no public constructor for an tuiObject. tuiObjects are always constructed using one of the subclasses.
  
@{b}5.6.2.1 Methods@{ub}

  ntui_FreeObject(*tuiObject)
  ntui_SetAttr(*tuiObject)
  ntui_GetAttr(*tuiObject)
  ntui_Refresh(*tuiObject)
  ntui_Bind(*master,*slave)
  ntui_HitObject(*tuiObject, int x, int y)
  ntui_ObtainRastPort(*tuiObject)
  ntui_ReleaseRastPort(*tuiObject)
  ntui_FindObjectByID(*parent, str id)
  ntui_FintObjectWindow(*tuiObject)
  ntui_BuildFromXML()
  ntui_BeginBuild()
  ntui_EndBuild()
    
@{b}5.6.2.1 Attributes@{ub}
    TUIA_CLASSID           : r (int) TUICLASS_... identifier for this class
    TUIA_ID                : rw (string) id of this tuiObject
    TUIA_USERDATA          : rw (*) multiple purpose user data
    TUIA_STRING            : rw (string) general string value
    TUIA_VALUE             : rw (int) general integer value
    TUIA_HELP              : rw (string) tooltip text
    TUIA_ONCLICK           : rw (string) notifyID when the object is clicked
    TUIA_ONMOUSEOVER       : rw (string) notifyID when mouse gets over the object
    TUIA_ONDOUBLECLICK     : rw (string) notifyID when the object is double clicked
    TUIA_ONTOUCH           : rw (string) notifyID when the object is touched (mouse down)
    TUIA_ONRELEASE         : rw (string) notifyID when the object is released (mouse up, doesn't need to be a valid click)
    TUIA_ONKEY             : rw (string) notifyID when a key is pressed
    TUIA_ONBEGINREFRESH    : rw (string) notifyID before internal refresh
    TUIA_ONREFRESH         : rw (string) notifyID after internal refresh
    TUIA_ONFOCUS           : rw (string) notifyID when object gains focus
    TUIA_ONLOSEFOCUS       : rw (string) notifyID when object loses focus
    TUIA_ONHELP            : rw (string) notifyID when mouse rests over object or HELP key is pressed
    TUIA_FLAGS             : rw (int)     TUIF_... flags
    TUIA_WIDTH             : r  (int) width in pixels
    TUIA_HEIGHT            : r  (int) height in pixels
    TUIA_MINWIDTH          : rw (int) minimum width in pixels
    TUIA_MINHEIGHT         : rw (int) minimum height in pixels
    TUIA_MAXWIDTH          : rw (int) maximum width in pixels
    TUIA_MAXHEIGHT         : rw (int) maximum height in pixels
    TUIA_XPOS              : r  (int) x position, left edge in pixels relative to window
    TUIA_YPOS              : r  (int) y position, top edge in pixels relative to window
    TUIA_BORDERTYPE        : rw (int)     TUIBORDER_... type of border
    TUIA_FOCUS             : rw (bool) if object has focus
    TUIA_BGPEN             : rw (int)     TUIPEN_... background pen
    TUIA_FGPEN             : rw (int)     TUIPEN_... foreground pen
    TUIA_BGRGB             : rw (int) $rrggbb background color
    TUIA_FGRGB             : rw (int) $rrggbb foreground color
    TUIA_BGIMAGE           : rw (string) background image (name or file)
    TUIA_FGIMAGE           : rw (string) foreground image (name or file)
    TUIA_SETFLAGS          :  w (int) set the given flags
    TUIA_CLEARFLAGS        :  w (int) clear the given flags
    TUIA_INVISIBLE         : rw (bool) object is hidden
    TUIA_ENABLED           : rw (bool) object is enabled
    TUIA_ONSCREEN          : r  (bool) object is visible
    TUIA_ACTIVE            : r  (bool) object is active
    TUIA_MOVER             : r  (bool) object is mouse over
    TUIA_DISABLED          : rw (bool) object is in disabled state
    TUIA_LEFTMARGIN        : rw (int) left margin in pixels
    TUIA_TOPMARGIN         : rw (int) top margin in pixels
    TUIA_RIGHTMARGIN       : rw (int) right margin in pixels
    TUIA_BOTTOMMARGIN      : rw (int) bottom margin in pixels
    TUIA_LEFTPADDING       : rw (int) left padding in pixels
    TUIA_TOPPADDING        : rw (int) top padding in pixels
    TUIA_RIGHTPADDING      : rw (int) right padding in pixels
    TUIA_BOTTOMPADDING     : rw (int) bottom padding in pixels
    TUIA_XMLPARAM          : w  (string) interpret as xml parameter
    TUIA_CBOX              : r  (*tuiRect) content box
    TUIA_IBOX              : r  (*tuiRect) innerbox box
    TUIA_BBOX              : r  (*tuiRect) bounding box
@ENDNODE

@NODE ntuiEngine "NTUI Engine"    
@{b}5.6.2 NTUI Engine Class@{ub}

  Constructor    : ntui_CreateEngine(str appName, str arexxPort="", str appMenu="", str appIcon="", str pubname="", Screen *scr=null)
  XML Tag        : <Engine ...>

@{b}5.6.2.1 Methods@{ub}

   ntui_HideAppicon(*tuiEngine)
   ntui_ShowAppIcon(*tuiEngine)   
   ntui_Iconify(*tuiEngine)
   ntui_PopUp(*tuiEngine)
   ntui_GetEvent(*tuiEngine)
   
  Default Attributes
    TUIA_CLASSID           : (int) identifier for this class
    TUIA_ID                : (str) id of this tuiObject
    
  Engine Attributes
    TUIEA_SKINPATH         : (str) path of the skin graphics data
    TUIEA_USESKIN          : (bool) use skin instead of procedural look
    TUIEA_USEAISS          : (bool) use AISS images instead of build-in images
    TUIEA_BORDERSTYLE      : (int) 0 = thin borders, 1 = thick border
    TUIEA_DEFLEFTMARGIN    : (int) default left margin for child widgets
    TUIEA_DEFTOPMARGIN     : (int) default top margin for child widgets
    TUIEA_DEFRIGHTMARGIN   : (int) default right margin for child widgets
    TUIEA_DEFBOTTOMMARGIN  : (int) default bottom margin for child widgets
    TUIEA_DEFLEFTPADDING   : (int) default left padding for child widgets
    TUIEA_DEFTOPPADDING    : (int) default top padding for child widgets
    TUIEA_DEFRIGHTPADDING  : (int) default right padding for child widgets
    TUIEA_DEFBOTTOMPADDING : (int) default bottom padding for child widgets
    TUIEA_AREXXPORT        : (str) name of the AREXX Port
    TUIEA_APPNAME          : (str) name of the application
    TUIEA_MENUNAME         : (str) name of the workbench menu entry
    TUIEA_APPICONFILE      : (str) name of the appicon file
    TUIEA_APPICONTEXT      : (str) name of the appicon text
    TUIEA_PUBSCREENNAME    : (str) name of the public screen
    TUIEA_NORMALFONTNAME   : (str) name of the normal (sans) font
    TUIEA_FIXFONTNAME      : (str) name of the fix (monospace) font
    TUIEA_SERIFFONTNAME    : (str) name of the serif font
    TUIEA_SMALLFONTNAME    : (str) name of the small font
    TUIEA_NORMALFONTSIZE   : (int) size of the normal font
    TUIEA_FIXFONTSIZE      : (int) size of the fix font
    TUIEA_SERIFFONTSIZE    : (int) size of the serif font
    TUIEA_SMALLFONTSIZE    : (int) size of the small font
    TUIEA_ONMESSAGE        : (str) notify id when arexx message comes in
    TUIEA_ONICONDROP       : (str) notify id when icon is dropped on appicon 
    TUIEA_ONQUIT           : (str) notify id if application is requested to quit
    TUIEA_ONICONIFY        : (str) notify id if application is requested to iconify
    TUIEA_ONPOPUP          : (str) notify id if application is requested to pop up

@{b}5.6.2.3 XML Properties  @{ub}

    appName      : name of the application
    arexxPort    : name of the AREXX Port or empty string for no AREXX Support
    appMenu      : text of the menu entry that should appear in the WB Tool Menu, or empty string for no menu entry
    appIcon      : filename of the app icon that can be shown on desktop, or empty string for no app icon
    pubName      : name of the public screen to open on, or empty string for the default public screen

@ENDNODE

@NODE ntuiWindow "NTUI Window"
@{b}5.6.2 NTUI NWindow Class@{ub}

@{b}5.6.3 CNEvent Class@{ub}

@{b}5.6.4 CNWidget Class@{ub}

@{b}5.6.4.1 CNGroup Subclass@{ub}

@{b}5.6.4.2 CNPage Subclass@{ub}

@{b}5.6.4.3 CNMenu Subclass@{ub}

@{b}5.6.4.4 CNLabel Subclass@{ub}

@{b}5.6.4.5 CNButton Subclass@{ub}
  
@{b}5.6.4.6 CNScroller Subclass@{ub}
  
@{b}5.6.4.7 CNSlider Subclass@{ub}
  
@{b}5.6.4.8 CNListView Subclass@{ub}
  
@{b}5.6.4.9 CNTextBox Subclass@{ub}
  
@{b}5.6.4.10 CNProgressBar Subclass@{ub}
  
  ...
  
@ENDNODE


@NODE Network "Network Library"
@{b}5.7 Network Library Reference@{ub}

@{b}5.7.1 CNet Class@{ub}
 
  CNet::GetEvent()
  CNet::ShutDown()
  ...
  
@{b}5.7.2 CSocket Class@{ub}

  CSocket::Connect(ip.s)
  CSocket::WaitConnect(ip.s)
  CSocket::IsConnected()
  CSocket::ShutDown()
  CSocket::ReadData.l(buffer.p,maxlength.l)
  CSocket::WriteData.l(buffer.p,length.l)
  ...
  
@ENDNODE


@NODE Game "Game Library"
@{b}5.8 Game Library Reference@{ub}

@{b}5.8.1 CDisplay Class@{ub}
 
  CDisplay::New()
  CDisplay::Delete()  
  CDisplay::Init()
  CDisplay::Deinit()  

  CDisplay::rastport.p
  CDisplay::width.l
  CDisplay::height.l
  CDisplay::depth.l

  CDisplay::New(width.l,height.l,depth.l)
  CDisplay::Flip()
  CDisplay::Show()
  CDisplay::Hide()
  CDisplay::SetFPS()
  CDisplay::GetFPS()
  ...
  
@ENDNODE


@NODE Data "Data Library"
@{b}5.9 Data Library Reference@{ub}

@{b}5.9.1 CHashMap Class@{ub}
  
  CHashMap::AddItem(key.s,data.s)
  CHashMap::GetItem(key.s)
  CHashMap::RemItem(key.s)

  CHashMap::GetFirstItem()
  CHashMap::GetNextItem()

  CHashMap::GetHashValue(key.s)

  CHashMap::Save(filename.s)
  CHashMap::Write(file.CFile)
  CHashMap::Load(filename.s)
  CHashMap::Read(file.CFile)
  
@{b}5.9.2 CPrefixTree Class@{ub}
  
  CPrefixTree::AddItem(key.s,data.s)
  CPrefixTree::GetItem(key.s)
  CPrefixTree::RemItem(key.s)

  CPrefixTree::GetFirstItem()
  CPrefixTree::GetNextItem()

  CPrefixTree::Save(filename.s)
  CPrefixTree::Write(file.CFile)
  CPrefixTree::Load(filename.s)
  CPrefixTree::Read(file.CFile)
  
@{b}5.9.3 CUndo Class@{ub}
  
  ...
  
@{b}5.9.4 CDynArray@{ub}

  ...  
  
@ENDNODE


@NODE VBin "V - Virtual Assembler Reference"
@{b}6 Virtual Assembler Reference@{ub}

  The A/A++ compiler generates virtual code, its assembler is called "V".
  This is an artificial assembler-style language, that can be easily
  interpreted or converted to a real world assembler/machine code.
  The virtual CPU that can "execute" this code is a pure Stack-Machine,
  it makes no assumptions about registers. This still leaves space for
  register optimizations and makes interpretation and code generation quite
  easy.
  All instructions fetch their parameters from the stack and write the result
  - if any - to the stack.
  Function calls of external libraries are not resolved, this is done by the
  code generator or interpreter. This way, the whole code is truly
  platform independent (not API independent, though).
  
  The assembler knows the following primitive types:
  
  Name          | Extension    | Size   | Value Range
  --------------+--------------+--------+---------------------------------------
  Void          | .void,   .v  |  0 bit | -
  Bool          | .bool,   .B  |  8 bit | True/False
  Byte          | .byte,   .b  |  8 bit | -128...+127
  Word          | .word,   .w  | 16 bit | -32768...+32767
  Long          | .long,   .l  | 32 bit | -2^31...+2^31-1
  Float         | .float,  .f  | 32 bit | quite large
  Pointer       | .ptr,    .p  | 32 bit | address space (could be 64 bit too)
  String        | .str,    .s  | 32 bit | character string from 0-2^31-1 length
                |              | +64+(n+1)*8 bit
 
  @{i}Note: The Bool type is acutally a byte, that has all bits cleared or all 
        bits set. This is used for better stack debugging.@{ui}
  @{i}Note: The Pointer is an own type, to be 64 bit proof and for better stack
        debugging.@{ui}

  The String structure is defined as:
  
  aaaalllllsss...s0uuu...u
           ^
           string pointer points here

  allocated.p     offset -8        (size of the string buffer in bytes)
  length.p        offset -4        (length of the string in bytes)
  s1,s2,...,sn    offset  0...n-1  (actual string)
  0               offset  n        (terminating 0 Byte)
  u1,u2,...,um    offset  n+1      (unused bytes in string buffer)
                  sizeof  n+m+1+8
  
  A string is technically a pointer to the first byte after length.p.
  @{i}Note: a Null pointer is a valid string too, it represents the empty string.@{ui}

  Example Code:
  +-----------------------------------------------------------------------------
  | 
  | PUSH.p 4096                 ; buffer = AllocVec(4096,MEMF_CLEAR)
  | PUSH.l $10                  ; MEMF_CLEAR
  | CALL.p exec.library\\AllocVec
  | POP.p  buffer
  | 
  | PUSH.p buffer               ; If (!buffer) Goto errorexit
  | BOOL.p
  | JMPF errorexit
  | 
  | PUSH.s "Ram:Disk.info"      ; fp = Open("Ram:Disk.info",MODE_OLD_FILE)
  | PUSH.l 1                    ; MODE_OLD_FILE 
  | CALL.p dos.library\\Open
  | POP.p  fp
  | 
  | PUSH.p fp                   ; If (!fp) Goto errorexit
  | BOOL.p
  | JMPF errorexit
  |   
  | PUSH.l 4                    ; If (Read(fp,buffer,4)==0) Goto errorexit
  | PUSH.p buffer
  | PUSH.p fp
  | CALL.p dos.library\\Read
  | BOOL.p
  | JMPF errorexit
  |   
  | PUSH.p fp                   ; Close(fp)
  | CALL.v dos.library\\Close
  | 
  | okexit:                           
  |   PUSH.l 0                  ; End(0)
  |   END
  |   
  | errorexit:
  |   PUSH.l -1                 ; End(-1)
  |   END
  |   
  | fp:      DC.p 0
  | buffer:  DC.p 0
  |
  +-----------------------------------------------------------------------------

  Instruction Reference:

  Format:
  NAME.x [parameters] [(from stack)] [=> to stack]

  Symbol                      | Description
  ----------------------------+-------------------------------------------------
  CMP.l  (x.l, y.l) => r.B    | True if x is equal to y, False otherwise
  CMP.w  (x.w, y.w) => r.B    | True if x is equal to y, False otherwise
  CMP.b  (x.b, y.b) => r.B    | True if x is equal to y, False otherwise
  CMP.f  (x.f, y.f) => r.B    | True if x is equal to y, False otherwise
  CMP.s  (x.s, y.s) => r.B    | True if x is equal to y, False otherwise
  CMP.p  (x.p, y.p) => r.B    | True if x is equal to y, False otherwise
                              |
  GT.l   (x.l, y.l) => r.B    | True if x is greater than y, False otherwise
  GT.w   (x.w, y.w) => r.B    | True if x is greater than y, False otherwise
  GT.b   (x.b, y.b) => r.B    | True if x is greater than y, False otherwise
  GT.f   (x.f, y.f) => r.B    | True if x is greater than y, False otherwise
  GT.s   (x.s, y.s) => r.B    | True if x is greater than y, False otherwise
  GT.p   (x.p, y.p) => r.B    | True if x is greater than y, False otherwise
                              |
  GE.l   (x.l, y.l) => r.B    | True if x is greater than or equal y, False oth.
  GE.w   (x.w, y.w) => r.B    | True if x is greater than or equal y, False oth.
  GE.b   (x.b, y.b) => r.B    | True if x is greater than or equal y, False oth.
  GE.f   (x.f, y.f) => r.B    | True if x is greater than or equal y, False oth.
  GE.s   (x.s, y.s) => r.B    | True if x is greater than or equal y, False oth.
  GE.p   (x.p, y.p) => r.B    | True if x is greater than or equal y, False oth.
                              |
  LT.l   (x.l, y.l) => r.B    | True if x is smaller than y, False otherwise
  LT.w   (x.w, y.w) => r.B    | True if x is smaller than y, False otherwise
  LT.b   (x.b, y.b) => r.B    | True if x is smaller than y, False otherwise
  LT.f   (x.f, y.f) => r.B    | True if x is smaller than y, False otherwise
  LT.s   (x.s, y.s) => r.B    | True if x is smaller than y, False otherwise
  lT.p   (x.p, y.p) => r.B    | True if x is smaller than y, False otherwise
                              |
  LE.l   (x.l, y.l) => r.B    | True if x is smaller than or equal y, False oth.
  LE.w   (x.w, y.w) => r.B    | True if x is smaller than or equal y, False oth.
  LE.b   (x.b, y.b) => r.B    | True if x is smaller than or equal y, False oth.
  LE.f   (x.f, y.f) => r.B    | True if x is smaller than or equal y, False oth.
  LE.s   (x.s, y.s) => r.B    | True if x is smaller than or equal y, False oth.
  LE.p   (x.p, y.p) => r.B    | True if x is smaller than or equal y, False oth.
                              |
  NE.l   (x.l, y.l) => r.B    | True if x is not equal to y, False otherwise
  NE.w   (x.w, y.w) => r.B    | True if x is not equal to y, False otherwise
  NE.b   (x.b, y.b) => r.B    | True if x is not equal to y, False otherwise
  NE.f   (x.f, y.f) => r.B    | True if x is not equal to y, False otherwise
  NE.s   (x.s, y.s) => r.B    | True if x is not equal to y, False otherwise
  NE.p   (x.p, y.p) => r.B    | True if x is not equal to y, False otherwise
                              |
  NOT.l  (x.l) => r.l         | bitwise NOT
  NOT.w  (x.w) => r.w         | bitwise NOT
  NOT.b  (x.b) => r.b         | bitwise NOT
                              |
  AND.l  (x.l, y.l) => r.l    | bitwise AND
  AND.w  (x.w, y.w) => r.w    | bitwise AND
  AND.b  (x.b, y.b) => r.b    | bitwise AND
                              |
  OR.l   (x.l, y.l) => r.l    | bitwise OR
  OR.w   (x.w, y.w) => r.w    | bitwise OR
  OR.b   (x.b, y.b) => r.b    | bitwise OR
                              |
  XOR.l  (x.l, y.l) => r.l    | bitwise XOR
  XOR.w  (x.w, y.w) => r.w    | bitwise XOR
  XOR.b  (x.b, y.b) => r.b    | bitwise XOR
                              |
  LSR.l  (x.l,n.w) => r.l     | shift down x about y bits (sign respected)
  LSR.w  (x.w,n.w) => r.w     | shift down x about y bits (sign respected)
  LSR.b  (x.b,n.w) => r.b     | shift down x about y bits (sign respected)
                              |
  ASR.l  (x.l, n.w) => r.l    | forced unsigned shift down
  ASR.w  (x.w, n.w) => r.w    | forced unsigned shift down
  ASR.b  (x.b, n.w) => r.b    | forced unsigned shift down
                              |
  LSL.l  (x.l, n.w) => r.l    | shift up x about y bits
  LSL.w  (x.w, n.w) => r.w    | shift up x about y bits
  LSL.b  (x.b, n.w) => r.b    | shift up x about y bits
                              |
  NEG.l  (x.l) => r.l         | negation of x
  NEG.w  (x.w) => r.w         | negation of x
  NEG.b  (x.b) => r.b         | negation of x
  NEG.f  (x.f) => r.f         | negation of x
                              |
  ADD.l  (x.l, y.l) => r.l    | add x and y
  ADD.w  (x.w, y.w) => r.w    | add x and y
  ADD.b  (x.b, y.b) => r.b    | add x and y
  ADD.f  (x.f, y.f) => r.f    | add x and y
  ADD.p  (x.p, y.l) => r.p    | add x and y
                              |
  SUB.l  (x.l, y.l) => r.l    | subtract y from x
  SUB.w  (x.w, y.w) => r.w    | subtract y from x
  SUB.b  (x.b, y.b) => r.b    | subtract y from x
  SUB.f  (x.f, y.f) => r.f    | subtract y from x
  SUB.p  (x.p, y.l) => r.p    | subtract y from x
                              |
  MUL.l  (x.l, y.l) => r.l    | multiply x by y
  MUL.w  (x.w, y.w) => r.w    | multiply x by y
  MUL.b  (x.b, y.b) => r.b    | multiply x by y
  MUL.f  (x.f, y.f) => r.f    | multiply x by y
                              |
  DIV.l  (x.l, y.l) => r.l    | divide x through y
  DIV.w  (x.w, y.w) => r.w    | divide x through y
  DIV.b  (x.b, y.b) => r.b    | divide x through y
  DIV.f  (x.f, y.f) => r.f    | divide x through y
                              |
  MOD.l  (x.l, y.l) => r.l    | x modulo y 
  MOD.w  (x.w, y.w) => r.w    | x modulo y 
  MOD.b  (x.b, y.b) => r.b    | x modulo y 
  MOD.f  (x.f, y.f) => r.f    | x modulo y 
                              |
  FLOOR.l (x.f)               | round x.f down and return long
  CEIL.l (x.f)                | round x.f up and return long
                              |
  POW.f  (x.f, y.f) => r.f    | x power y
                              |
  LOG.f  (x.f, y.f) => r.f    | logarithm of x to base y
                              |
  SIN.f  (x.f) => r.f         | Sinus of x
  COS.f  (x.f) => r.f         | Cosinus of x
  TAN.f  (x.f) => r.f         | Tangents of x
  ASIN.f (x.f) => r.f         | inverse Sinus of x
  ACOS.f (x.f) => r.f         | inverse Cosinus of x
  ATAN.f (x.f) => r.f         | inverse Tangents of x
                              |
  CAT.s  (x.s, y.s) => r.s    | concatenate x and y
  RANGE.s(s.s,p.p,n.p) => r.s | middle n characters starting from p of s 
  LEN.p  (s.s) => r.p         | string length of str
                              |
  ALLOC.p(n.p) => r.p         | allocate memory of n bytes
  CLEAR  (m.p,n.p)            | clear memory at m of n bytes
  FREE   (m.p,n.p)            | free memory at m of n bytes
  COPY   (x.p,y.p,n.p)        | copy n bytes from x to y    
                              |
  PUSH.* (m.p, n.p) => r.b[n] | push n bytes from m to stack
  LEA.p  label => r.p         | push label address to stack
                              |
  PUSH.p label => r.p         | push pointer found at label to stack
  PUSH.l label => r.l         | push long    found at label to stack
  PUSH.w label => r.w         | push word    found at label to stack
  PUSH.b label => r.b         | push byte    found at label to stack
  PUSH.f label => r.f         | push float   found at label to stack
  PUSH.s label => r.s         | push string  found at label to stack
                              |
  PUSH.p #.p => r.p           | push constant pointer to stack
  PUSH.l #.l => r.l           | push constant long    to stack
  PUSH.w #.w => r.w           | push constant word    to stack
  PUSH.b #.b => r.b           | push constant byte    to stack
  PUSH.f #.f => r.f           | push constant float   to stack
  PUSH.s #.s => r.s           | push constant string  to stack
                              |
  POP.*  label (m.p, n.p)     | pop n bytes from stack to label
  POP.p  label (x.p)          | pop pointer from stack to label
  POP.l  label (x.l)          | pop long    from stack to label
  POP.w  label (x.w)          | pop word    from stack to label
  POP.b  label (x.b)          | pop byte    from stack to label
  POP.f  label (x.f)          | pop float   from stack to label
  POP.s  label (x.s)          | pop string  from stack to label
                              |
  PUSH.p (x.p) => r.p         | push pointer found in address to stack
  PUSH.l (x.p) => r.l         | push long    found in address to stack
  PUSH.w (x.p) => r.w         | push word    found in address to stack
  PUSH.b (x.p) => r.b         | push byte    found in address to stack
  PUSH.f (x.p) => r.f         | push float   found in address to stack
  PUSH.s (x.p) => r.s         | push string  found in address to stack
  PUSH.* (m.p,n.p) => r.b[n]  | push memory  found in address to stack
                              |
  OPENLIB.B lib.l(name.s)=>r.B| Open Library
  CLOSELIB.v lib.l => r.B     | Close Library
                              |
  CALL.p lib\\func => r.p      | call an external function with return type ptr
  CALL.l lib\\func => r.l      | call an external function with return type long
  CALL.w lib\\func => r.w      | call an external function with return type word
  CALL.b lib\\func => r.b      | call an external function with return type byte
  CALL.f lib\\func => r.f      | call an external function with return type flt
  CALL.s lib\\func => r.s      | call an external function with return type str
  CALL.v lib\\func             | call an external statement
                              |
  DC.p   #n.p                 | declare a value directly in binary code
  DC.l   #n.l                 | declare a value directly in binary code
  DC.w   #n.w                 | declare a value directly in binary code
  DC.b   #n.b                 | declare a value directly in binary code
  DC.f   #n.f                 | declare a value directly in binary code
  DC.s   #n.s                 | declare a value directly in binary code
                              |
  JMP    label                | goto label 
  JMPF   label (c.B)          | goto label if cond is false
  JMPT   label (c.B)          | goto label if cond is true
  JSR    label => r.p         | goto label and store current PC
  RTS    (r.p)                | goto PC on stack (return from subroutine)
  END    (c.l)                | end the program
                              |
  BOOL.l (x.l) => r.B         | convert x to bool     (True/False)
  BOOL.w (x.w) => r.B         | convert x to bool     (True/False)
  BOOL.b (x.b) => r.B         | convert x to bool     (True/False)
  BOOL.f (x.f) => r.B         | convert x to bool     (True/False)
  BOOL.s (x.s) => r.B         | convert x to bool     (True/False)
  BOOL.p (x.p) => r.B         | convert x to bool     (True/False)
                              |
  BYTE.l (x.l) => r.b         | convert x to byte     (-128...+127)
  BYTE.w (x.w) => r.b         | convert x to byte     (-128...+127)
  BYTE.f (x.f) => r.b         | convert x to byte     (-128...+127)
  BYTE.s (x.s) => r.b         | convert x to byte     (-128...+127)
  BYTE.p (x.p) => r.b         | convert x to byte     (-128...+127)
                              |
  WORD.l (x.l) => r.w         | convert x to word     (-32768...+32767)
  WORD.b (x.b) => r.w         | convert x to word     (-32768...+32767)
  WORD.f (x.f) => r.w         | convert x to word     (-32768...+32767)
  WORD.s (x.s) => r.w         | convert x to word     (-32768...+32767)
  WORD.p (x.p) => r.w         | convert x to word     (-32768...+32767)
                              |
  LONG.w (x.w) => r.l         | convert x to Long     (-2^31...+2^31-1)
  LONG.b (x.b) => r.l         | convert x to Long     (-2^31...+2^31-1)
  LONG.f (x.f) => r.l         | convert x to Long     (-2^31...+2^31-1)
  LONG.s (x.s) => r.l         | convert x to Long     (-2^31...+2^31-1)
  LONG.p (x.p) => r.l         | convert x to Long     (-2^31...+2^31-1)
                              |
  FLOAT.l  (x.l) => r.f       | convert x to float    (...)
  FLOAT.w  (x.w) => r.f       | convert x to float    (...)
  FLOAT.b  (x.b) => r.f       | convert x to float    (...)
  FLOAT.s  (x.s) => r.f       | convert x to float    (...)
  FLOAT.p  (x.p) => r.f       | convert x to float    (...)
                              |
  STR.l  (x.l) => r.s         | convert x to string   (0-2^31-1 length)
  STR.w  (x.w) => r.s         | convert x to string   (0-2^31-1 length)
  STR.b  (x.b) => r.s         | convert x to string   (0-2^31-1 length)
  STR.s  (x.s) => r.s         | convert x to string   (0-2^31-1 length)
  STR.p  (x.p) => r.s         | convert x to string   (0-2^31-1 length)
                              |
  PTR.*  (x.*) => r.p         | convert x to pointer
                              |
= Scribble =====================================================================
                              |
  UBYTE.*  (x.*) => r.ub      | convert x to unsigned byte (0...255)
  UWORD.*  (x.*) => r.uw      | convert x to unsigned word (0...65535)
  ULONG.*  (x.*) => r.ul      | convert x to unsigned long (0...+2^32-1)
  DFLOAT.* (x.*) => r.d       | convert x to double float  (...)
  DLONG.*  (x.*) => r.dl      | convert x to double long   (0...2^64-1)
  CSTR.*   (x.*) => r.cs      | convert x to Null-terminated character array
  
@ENDNODE

@NODE Author "C Author"
@{b}C Author@{ub}

  Name:  Thilo Koehler
  Nick:  Der Wanderer
  Mail:  koehlerthilo(a)gmx de
  Web:   http://www.hd-rec.de
 
@ENDNODE

@NODE License "D License/Disclaimer"
@{b}D License/Disclaimer@{ub}

License:

  A/A++ programming language is freeware and open source.
  No special license is pending. You can use this product
  in any fashion you like, just some credits to "Der Wanderer" are
  mandatory, and the name of the language must not be changed if used
  elsewhere.
@{i}
DISCLAIMER:

  THE SOFTWARE AND DOCUMENTATION IS PROVIDED "AS IS" WITHOUT WARRANTY
  OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED
  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
  PARTICULAR PURPOSE. YOU ARE ADVISED TO TEST THE SOFTWARE THOROUGHLY BEFORE
  RELYING ON IT. YOU AGREE TO ACCEPT THE ENTIRE RISK AS TO THE QUALITY AND
  PERFORMANCE OF THE SOFTWARE AND DOCUMENTATION.
  IN NO EVENT WILL THILO KOEHLER BE LIABLE FOR DIRECT, INDIRECT, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES RESULTING FROM ANY DEFECT IN THE PROGRAM.
@{ui}
 
@ENDNODE

@NODE Glossary "B Glossary"
@{b}B Glossary@{ub}

Variable      : A memory cell that can store value of the type the variable has.

Constant      : A value of a certain type that does not change over compile
                time. This is usually set by the compiler.

Type          : The kind of data that is in a memory cell, this can be an
                integer, float or string, or user defined "complex type".

Primitive Type: A primitive type is one of the types A/A++ knows build-in.

Complex Type  : A complex type is a composition of primitive types. They are
                defined by the user.
                
Function      : A block of expressions that has some input parameters and one
                output result.
                A/A++ has some build in functions, and the user can define own
                functions.

Macro         : Instruction how to replace the macro name in source code with
                its body.
                Note: AmiBlitz³ uses macros in form of constants defined by
                preceding # and "Macro"s, while C uses #define for both.
                A/A++ uses only the preceding #.

Bool          : a type that can hold only two values: true and false
                This is usually the result type of comparators.

Long/Word/Byte: Those are Integer values, which can contain only numbers
                without fraction.
                Results are rounded downwards, e.g. 5/2 = 2 in integer space

Float/Double  : Float is a numeric value with fractions, Double is the same
                with higher precision

String        : A string in A/A++ is a sequence of character terminated by a 0.

Array         : An Array is a sequence of variables of a certain type.
                The variables are accessed by their index.
                
List          : A List is a sequence of variables of a certain type.
                The variables are accessed by stepping forward and backwards in
                the list.

AmiBlitz³     : programming language, see http://AmiBlitz³.amiforce.de               

C             : programming language

Expression    : anything that can be evaluated. An expression is composed out
                of terminals and non-terminals.

@ENDNODE


@NODE Examples "A Code Examples"
@{b}A Code Examples@{ub}

  Hello World:
  +-----------------------------------------------------------------------------
  | 
  | Print "Hello World!"                    @{i}; console output@{ui}
  | End                                     @{i}; end of program@{ui}
  |
  +-----------------------------------------------------------------------------


  Load, resize and save an image (via A++):
  +-----------------------------------------------------------------------------
  |
  | SOURCE "graphic.include.app"            @{i}; use graphics.include@{ui}
  |
  | Var img.CImage                          @{i}; declare an image object@{ui}
  |
  | img\\Load("DH0:Pics/image.png")          @{i}; load from disk@{ui}
  | img\\Resize(800,600)                     @{i}; resize to 800x600 pixels@{ui}
  | img\\Save("DH0:Pics/image.jpg",'JPEG')   @{i}; save as JPEG@{ui}
  |
  | End                                     @{i}; end of program@{ui}
  |
  +-----------------------------------------------------------------------------
  @{i}Note: Because "img" is an A maintained object, we don't have to free it.
        A is freeing it on "End".@{ui}

  
  Load, play, resample and save a sound (via A++):
  +-----------------------------------------------------------------------------
  |
  | SOURCE "audio.include.app"              @{i}; use the audio.include@{ui}
  |
  | Var snd.CSound                          @{i}; declare a sound object@{ui}
  |
  | snd\\Load("DH0:SFX/Bing.wav")            @{i}; load a sound from disk@{ui}
  | snd\\Play()                              @{i}; play the sound@{ui}
  | snd\\Resample(44100)                     @{i}; resample the sound to 44100kHz@{ui}
  | snd\\Save("DH0:SFX/Bing.aiff",'AIFF');   @{i}; save the sound as AIFF@{ui}
  | 
  | End                                     @{i}; end of program@{ui}
  |
  +-----------------------------------------------------------------------------  
  @{i}Note: Because "snd" is an A maintained object, we don't have to free it.
        A is freeing it on "End".@{ui}

         
  Load an image, open a window and show the image (via A++):
  +-----------------------------------------------------------------------------
  | 
  | SOURCE "graphic.include.app"            @{i}; use the graphics.include@{ui}
  | SOURCE "gui.include.app"                @{i}; use the gui.include@{ui}
  |
  | Var win.CWindow, img.CImage             @{i}; declare window and image object@{ui}
  |
  | img\\Load("DH0:Pics/image.png")          @{i}; load the image from disk@{ui}
  | win\\Init(img\\FileName,0,0, \\
  |          img\\Width,img\\Height)          @{i}; init the window@{ui}
  | win\\Open()                              @{i}; open the window@{ui}
  | img\\Draw(win\\RastPort(),0,0)             @{i}; draw the image to 0/0@{ui}
  |
  | Repeat                                  @{i}; @{ui}
  |   *event.Event = WaitEvent()            @{i}; wait for events@{ui}
  | Until (*event\\Notify = #Notify_Close)   @{i}; repeat until close button is hit@{ui}
  |
  | End                                     @{i}; end of program@{ui}
  |
  +-----------------------------------------------------------------------------  
  @{i}Note: Because "img" and "win" are an A maintained objects, we don't have
        to free them. A is closing/freeing it on "End".@{ui}

         
  Load an image, open a window and show the image using NTUI Toolkit (via A++):
  +-----------------------------------------------------------------------------
  |
  | SOURCE "ntui.include.app"              @{i}; use the ntui.include@{ui}
  |
  | Var nEngine.CNEngine                   @{i}; declare/init the ntui Engine@{ui}
  | 
  | *nWin.CNWindow = \\                    @{i}; create an ntui Window@{ui}
  |       nEngine\\Window("Pic Viewer")    
  | nWin\\Image("DH0:Pics/image.png")       @{i}; create an image widget@{ui}
  | nWin\\Show()                            @{i}; show the window@{ui}
  |
  | Repeat                                 @{i}; @{ui}
  |   *event.CNEvent = nEngine\\WaitEvent() @{i}; wait for events@{ui}
  | Until (*event\\Notify = #Notify_Close)  @{i}; repeat until close button is hit@{ui}
  |
  | End                                    @{i}; end of program@{ui}
  |
  +-----------------------------------------------------------------------------  

        
  Small GUI using NTUI Toolkit (via A++):
  +-----------------------------------------------------------------------------
  |
  | SOURCE "ntui.include.app"              @{i}; use the ntui.include@{ui}
  |
  | #Notify_Hello 1                        @{i}; define user notification values@{ui}
  | #Notify_World 2                        @{i}; they will be used for the buttons@{ui}
  |
  | Var nEngine.CNEngine                   @{i}; declare/init the ntui Engine@{ui}
  | nEngine\\Init("Demo App",  \\            @{i}; init with various parameters@{ui}
  |              "DEMO_REXX", \\
  |              "AppIcon.info")
  |
  | *nWin.CNWindow = \\                     @{i}; create a new ntui Window@{ui}
  |       nEngine\\Window("Demo Window")
  | nWin\\Label("This is a test window!")   @{i}; create a label widget@{ui}
  | nWin\\HGroup()                          @{i}; create a horizontal group@{ui}
  | nWin\\Button("Hello!",#Notify_Hello)    @{i}; create a text button@{ui}
  | nWin\\Button("World!",#Notify_World)    @{i}; create a text button@{ui}
  | nWin\\EndGroup()                        @{i}; close the group@{ui}
  |
  | nWin\\Show()                            @{i}; show the window@{ui}
  |
  | quit.B = false                         @{i}; init quit switch variable@{ui}
  | Repeat                                 @{i}; @{ui}
  |   *event.CNEvent = nEngine\\WaitEvent() @{i}; wait for events@{ui}
  |
  |   Select(*event\\Notify) {              @{i}; process notify value@{ui}
  |     Case #Notify_Close : quit = True
  |     Case #Notify_Hello : Alert("Hello button pressed!")
  |     Case #Notify_World : Alert("World button pressed!")
  |   }
  |
  | Until (quit)                           @{i}; repeat until quit switch is set@{ui}
  |
  | End                                    @{i}; end program@{ui}
  |
  +-----------------------------------------------------------------------------    

        
  Writing a C-Style runtime for AmigaOS and Windows:
  (now we go OS-API specific)
  +-----------------------------------------------------------------------------
  | 
  | Function.p malloc(blocksize.l) {
  |   Assert(blocksize>0,"\\#_Function: Allocate negative block size!")
  |
  |   CIF (#_Win32)
  |     heapH.p = LibCall(Kernel32\\GetProcessHeap())
  |     block.p = LibCall(Kernel32\\HeapAlloc(heapH,0,blocksize))
  |   CEND
  |
  |   CDEF (#_Amiga)
  |     block.p = LibCall(exec\\AllocVec(blocksize,#MEMF_ANY))
  |   CEND
  |
  |   Return block
  | }
  | 
  | 
  | Function free(block.p) {
  |   Assert(block,"\\#_Function: Null pointer parameter!")
  |   CDEF (#_Win32)
  |     heapH.p = LibCall(Kernel32\\GetProcessHeap())
  |     LibCall(Kernel32\\HeapFree(heapH,block))
  |   CEND
  |   CDEF (#_Amiga)
  |     LibCall(exec\\FreeVec(block))
  |   CEND
  | }
  |
  |
  | Function.p fopen(file.s,mode.s) {
  |   CDEF #_Win32
  |     CERR("\\#_Function is not available under Win32 API!")
  |   CEND
  |   CDEF #_Amiga
  |     modeF.l = 0
  |     fp.p = LibCall(dos\\Open(&file,modeF))
  |   CEND
  |   Return fp
  | }
  |
  | 
  | Function fclose(fp.p) {
  |   CDEF #_Win32
  |     CERR("\\#_Function is not available under Win32 API!")
  |   CEND
  |   CDEF #_Amiga
  |     LibCall(dos\\Close(fp))
  |   CEND
  | }
  | 
  +-----------------------------------------------------------------------------
  
@ENDNODE

@NODE StyleGuide "A Code Style Guide"
@{b}A Code Style Guide@{ub}

A Code Style Rules

The rules below are not guidelines or recommendations, but strict rules.
You may not disregard the rules we list below except as approved on a
need-to-use basis.

Not all existing code follows these rules, but all new code is expected to.

A Language Rules

Exceptions: Never catch and ignore them without explanation.
Exceptions: do not catch generic Exception, except in library code at the
root of the stack.
Finalizers: generally don't use them.
Imports: Fully qualify imports
Java Library Rules

There are conventions for using Android's Java libraries and tools.
In some cases, the convention has changed in important ways and older code
might use a deprecated pattern or library. When working with such code, it's
okay to continue the existing style (see Consistency). When creating new
components never use deprecated libraries.

Java Style Rules

Programs are much easier to maintain when all files have a consistent style.
We follow the standard Java coding style, as defined by Sun in their
Code Conventions for the Java Programming Language, with a few exceptions
and additions. This style guide is comprehensive and detailed and is in
common usage in the Java community.

In addition, we enforce the following style rules:

Comments/Javadoc: write it; use standard style
Short methods: don't write giant methods
Fields: should either be at the top of the file, or immediately before
the methods that use them
Local variables: limit the scope
Imports: android; third party alphabetical; java(x)
Indentation: 4 spaces, no tabs.
Line length: 100 columns
Field names: Non-public, non-static fields start with m. Static fields start s.
Braces: Opening braces don't go on their own line.
Annotations: Use the standard annotations.
Acronyms are words: Treat acronyms as words in names, yielding XmlHttpRequest, getUrl(), etc.
TODO style: "TODO: write this description"
Consistency: Look at what's around you!
Logging: Be careful with logging. It's expensive.
Javatests Style Rules

Naming test methods: testMethod_specificCase is ok
Java Language Rules

Exceptions: do not ignore

Sometimes it is tempting to write code that completely ignores an exception like this:
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
    }
}

You must never do this. While you may think that your code will never encounter this error condition or that it is not important to handle it, ignoring exceptions like above creates mines in your code for someone else to trip over some day. You must handle every Exception in your code in some principled way. The specific handling varies depending on the case.

Anytime somebody has an empty catch clause they should have a creepy feeling. There are definitely times when it is actually the correct thing to do, but at least you have to think about it. In Java you can't escape the creepy feeling.
- James Gosling
Acceptable alternatives (in order of preference) are:

Throw the exception up to the caller of your method.
void setServerPort(String value) throws NumberFormatException {
    serverPort = Integer.parseInt(value);
}

Throw a new exception that's appropriate to your level of abstraction.
void setServerPort(String value) throws ConfigurationException {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        throw new ConfigurationException("Port " + value + " is not valid.");
    }

Handle the error gracefully and substitute an appropriate value in the catch {} block.
/** Set port. If value is not a valid number, 80 is substituted. */
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        serverPort = 80;  // default port for server
    }
Catch the Exception and throw a new RuntimeException. This is dangerous: only do it if you are positive that if this error occurs, the appropriate thing to do is crash.
/** Set port. If value is not a valid number, die. */
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        throw new RuntimeException("port " + value " is invalid, ", e);
    }
Note that the original exception is passed to the constructor for RuntimeException. This wrapped exception paradigm is very useful but only works in Java 1.4. If your code must compile under Java 1.3, you will need to omit the exception that is the cause.

Last resort: if you are confident that actually ignoring the exception is appropriate then you may ignore it, but you must also comment why with a good reason:
/** If value is not a valid number, original port number is used. */
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        // Method is documented to just ignore invalid user input.
        // serverPort will just be unchanged.
    }
}
Exceptions: do not catch generic Exception

Sometimes it is tempting to be lazy when catching exceptions and do something like this:
try {
    someComplicatedIOFunction();        // may throw IOException
    someComplicatedParsingFunction();   // may throw ParsingException
    someComplicatedSecurityFunction();  // may throw SecurityException
    // phew, made it all the way
} catch (Exception e) {               // I'll just catch all exceptions
    handleError();                      // with one generic handler!
}

You should not do this. In almost all cases it is inappropriate to catch generic Exception or Throwable, preferably not Throwable, because it includes Error exceptions as well. It is very dangerous. It means that Exceptions you never expected (including RuntimeExceptions like ClassCastException) end up getting caught in application-level error handling. It obscures the failure handling properties of your code. It means if someone adds a new type of Exception in the code you're calling, the compiler won't help you realize you need to handle that error differently. And in most cases you shouldn't be handling different types of exception the same way, anyway.
There are rare exceptions to this rule: certain test code and top-level code where you want to catch all kinds of errors (to prevent them from showing up in a UI, or to keep a batch job running). In that case you may catch generic Exception (or Throwable) and handle the error appropriately. You should think very carefully before doing this, though, and put in comments explaining why it is safe in this place.


Comments/Javadoc

Every file should have a copyright statement at the top. Then a package
statement and import statements should follow, each block separated by a
blank line. And then there is the class or interface declaration. In the
Javadoc comments, describe what the class or interface does.

/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.internal.foo;

import android.os.Blah;
import android.view.Yada;

import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * Does X and Y and provides an abstraction for Z.
 */
public class Foo {
    ...
}
Every class and nontrivial public method you write must contain a Javadoc
comment with at least one sentence describing what the class or method does.
This sentence should start with a 3rd person descriptive verb. Examples:

/** Returns the correctly rounded positive square root of a double value. */
static double sqrt(double a) {
}

/**
 * Constructs a new String by converting the specified array of
 * bytes using the platform's default character encoding.
 */
public String(byte[] bytes) {
}
You do not need to write Javadoc for trivial get and set methods such as
setFoo() if all your Javadoc would say is "sets Foo". If the method does
something more complex (such as enforcing a constraint or having an important
side effect), then you must document it. And if it's not obvious what the
property "Foo" means, you should document it.

Every method you write, whether public or otherwise, would benefit from
Javadoc. Public methods are part of an API and therefore require Javadoc.

Android does not currently enforce a specific style for writing Javadoc
comments, but you should follow the Sun Javadoc conventions.
Short methods

To the extent that it is feasible, methods should be kept small and focused.
It is, however, recognized that long methods are sometimes appropriate, so no
hard limit is placed on method length. If a method exceeds 40 lines or so,
think about whether it can be broken up without harming the structure of
the program.

Local variables

The scope of local variables should be kept to a minimum (Effective Java Item 29). By doing so, you increase the readability and maintainability of your code and reduce the likelihood of error. Each variable should be declared in the innermost block that encloses all uses of the variable.
Local variables should be declared at the point they are first used. Nearly every local variable declaration should contain an initializer. If you don't yet have enough information to initialize a variable sensibly, you should postpone the declaration until you do.

One exception to this rule concerns try-catch statements. If a variable is initialized with the return value of a method that throws a checked exception, it must be initialized inside a try block. If the value must be used outside of the try block, then it must be declared before the try block, where it cannot yet be sensibly initialized:

// Instantiate class cl, which represents some sort of Set
Set s = null;
try {
    s = (Set) cl.newInstance();
} catch(IllegalAccessException e) {
    throw new IllegalArgumentException(cl + " not accessible");
} catch(InstantiationException e) {
    throw new IllegalArgumentException(cl + " not instantiable");
}

// Exercise the set
s.addAll(Arrays.asList(args));
But even this case can be avoided by encapsulating the try-catch block in a method:

Set createSet(Class cl) {
    // Instantiate class cl, which represents some sort of Set
    try {
        return (Set) cl.newInstance();
    } catch(IllegalAccessException e) {
        throw new IllegalArgumentException(cl + " not accessible");
    } catch(InstantiationException e) {
        throw new IllegalArgumentException(cl + " not instantiable");
    }
}
...
// Exercise the set
Set s = createSet(cl);
s.addAll(Arrays.asList(args));
Loop variables should be declared in the for statement itself unless there is a compelling reason to do otherwise:
for (int i = 0; i < n; i++) {
    doSomething(i);
}

for (Iterator i = c.iterator(); i.hasNext(); ) {
    doSomethingElse(i.next());
}


Imports

The ordering of import statements is:
Android imports
Imports from third parties (com, junit, net, org) 
java and javax
To exactly match the IDE settings, the imports should be:

Alphabetical within each grouping.
    Capital letters are considered to come before lower case letter (e.g. Z before a).
There should be a blank line between each major grouping (android, com, junit, net, org, java, javax).
Why?

Originally there was no style requirement on the ordering. This meant that the IDE's were either always changing the ordering, or IDE developers had to disable the automatic import management features and maintain the imports by hand. This was deemed bad. When java-style was asked, the preferred styles were all over the map. It pretty much came down to our needing to "pick an ordering and be consistent." So we chose a style, updated the javaguide and made the IDE's obey it. We expect that as IDE users work on the code, the imports in all of the packages will end up matching this pattern without any extra engineering effort.

The style chosen such that:

The imports people want to look at first tend to be at the top (android)
The imports people want to look at least tend to be at the bottom (java)
Humans can easily follow the style
The IDE's can follow the style
What about static imports?

The use and location of static imports have been mildly controversial issues. Some people would prefer static imports to be interspersed with the remaining imports, some would prefer them reside above or below all other imports. Additinally, we have not yet come up with a way to make all IDEs use the same ordering.
Since most people consider this a low priority issue, just use your judgement and please be consistent.

Indentation

We use 4 space indents for blocks. We never use tabs. When in doubt, be consistent with code around you.

We use 8 space indents for line wraps, including function calls and assignments. For example, this is correct:

Instrument i
        = someLongExpression(that, wouldNotFit, on, one, line);
and this is not correct:
Instrument i
    = someLongExpression(that, wouldNotFit, on, one, line);
Field Names

Non-public, non-static field names start with m.
Static field names start with s.
Other fields start with a lower case letter.
Public static final fields (constants) are ALL_CAPS_WITH_UNDERSCORES.
For example:

public class MyClass {
    public static final int SOME_CONSTANT = 42;
    public int publicField;
    private static MyClass sSingleton;
    int mPackagePrivate;
    private int mPrivate;
    protected int mProtected;
}
Braces

Braces do not go on their own line; they go on the same line as the code before them. So:

class MyClass {
    int func() {
        if (something) {
            // ...
        } else if (somethingElse) {
            // ...
        } else {
            // ...
        }
    }
}
We require braces around the statements for a conditional. Except, if the entire conditional (the condition and the body) fit on one line, you may (but are not obligated to) put it all on one line. That is, this is legal:

if (condition) {
    body; // ok
}
if (condition) body; // ok
but this is still illegal:

if (condition)
    body; // bad
Line length

Each line of text in your code should be at most 100 characters long.

There has been lots of discussion about this rule and the decision remains that 100 characters is the maximum.

Exception: if a comment line contains an example command or a literal URL longer than 100 characters, that line may be longer than 100 characters for ease of cut and paste.

Exception: import lines can go over the limit because humans rarely see them. This also simplifies tool writing.

Java 1.5 Annotations

Annotations should precede other modifiers for the same language element. Simple marker annotations (e.g. @Override) can be listed on the same line with the language element. If there are multiple annotations, or parameterized annotations, they should each be listed one-per-line in alphabetical order.

Android -standard practices for the three predefined annotations in Java 1.5's are:

@Deprecated
The @Deprecated annotation must be used whenever the use of the annotated element is discouraged. If you use the @Deprecated annotation, you must also have a @deprecated Javadoc tag and it should name an alternate implementation. In addition, remember that a @Deprecated method is still supposed to work.
If you see old code that has a @deprecated Javadoc tag, please add the @Deprecated annotation.

@Override
The @Override annotation must be used whenever a method overrides the declaration or implementation from a super-class.
For example, if you use the {@inheritdocs} Javadoc tag, and derive from a class (not an interface), you must also annotate that the method @Overrides the parent class's method.

@SuppressWarnings
The @SuppressWarnings annotation should only be used under circumstances where it is impossible to eliminate a warning. If a warning passes this "impossible to eliminate" test, the @SuppressWarnings annotation must be used, so as to ensure that all warnings reflect actual problems in the code.
When a @SuppressWarnings annotation is necessary, it must be prefixed with a TODO comment that explains the "impossible to eliminate" condition. This will normally identify an offending class that has an awkward interface. For example:

// TODO: The third-party class com.third.useful.Utility.rotate() needs generics
@SuppressWarnings({"generic-cast"})
List<String> blix = Utility.rotate(blax);
When a @SuppressWarnings annotation is required, the code should be refactored to isolate the software elements where the annotation applies.
Acronyms in names

Treat acronyms and abbreviations as words. The names are much more readable:

Good    Bad
XmlHttpRequest     XMLHTTPRequest
getCustomerId     getCustomerID
This style rule also applies when an acronym or abbreviation is the entire name:

Good    Bad
class Html     class HTML
String url;     String URL;
long id;     long ID;
Both the JDK and the Android code bases are very inconsistent with regards to acronyms, therefore, it is virtually impossible to be consistent with the code around you. Bite the bullet, and treat acronyms as words.

For further justifications of this style rule, see Effective Java Item 38 and Java Puzzlers Number 68.

TODO style

Use TODO comments for code that is temporary, a short-term solution, or good-enough but not perfect.

TODOs should include the string TODO in all caps, followed by a colon:

  // TODO: Remove this code after the UrlTable2 has been checked in.

  // TODO: Change this to use a flag instead of a constant.
If your TODO is of the form "At a future date do something" make sure that you either include a very specific date ("Fix by November 2005") or a very specific event ("Remove this code after all production mixers understand protocol V7.").

Consistency

Our parting thought: BE CONSISTENT. If you're editing code, take a few minutes to look at the code around you and determine its style. If they use spaces around their if clauses, you should too. If their comments have little boxes of stars around them, make your comments have little boxes of stars around them too.

The point of having style guidelines is to have a common vocabulary of coding, so people can concentrate on what you're saying, rather than on how you're saying it. We present global style rules here so people know the vocabulary. But local style is also important. If code you add to a a file looks drastically different from the existing code around it, it throws readers out of their rhythm when they go to read it. Try to avoid this.

Logging

While logging is necessary it has a significantly negative impact on performance and quickly loses its usefulness if it's not kept reasonably terse. The logging facilities provides five different levels of logging. Below are the different levels and when and how they should be used.

ERROR: This level of logging should be used when something fatal has happened, i.e. something that will have user-visible consequences and won't be recoverable without explicitly deleting some data, uninstalling applications, wiping the data partitions or reflashing the entire phone (or worse). This level is always logged. Issues that justify some logging at the ERROR level are typically good candidates to be reported to a statistics-gathering server.
WARNING: This level of logging should used when something serious and unexpected happened, i.e. something that will have user-visible consequences but is likely to be recoverable without data loss by performing some explicit action, ranging from waiting or restarting an app all the way to re-downloading a new version of an application or rebooting the device. This level is always logged. Issues that justify some logging at the WARNING level might also be considered for reporting to a statistics-gathering server.
INFORMATIVE: This level of logging should used be to note that something interesting to most people happened, i.e. when a situation is detected that is likely to have widespread impact, though isn't necessarily an error. Such a condition should only be logged by a module that reasonably believes that it is the most authoritative in that domain (to avoid duplicate logging by non-authoritative components). This level is always logged.
DEBUG: This level of logging should be used to further note what is happening on the device that could be relevant to investigate and debug unexpected behaviors. You should log only what is needed to gather enough information about what is going on about your component. If your debug logs are dominating the log then you probably should be using verbose logging. This level will be logged, even on release builds, and is required to be surrounded by an if (LOCAL_LOG) or if (LOCAL_LOGD) block, where LOCAL_LOG[D] is defined in your class or subcomponent, so that there can exist a possibility to disable all such logging. There must therefore be no active logic in an if (LOCAL_LOG) block. All the string building for the log also needs to be placed inside the if (LOCAL_LOG) block. The logging call should not be re-factored out into a method call if it is going to cause the string building to take place outside of the if (LOCAL_LOG) block. There is some code that still says if (localLOGV). This is considered acceptable as well, although the name is nonstandard.
VERBOSE: This level of logging should be used for everything else. This level will only be logged on debug builds and should be surrounded by if (LOCAL_LOGV) block (or equivalent) so that it can be compiled out by default. Any string building will be stripped out of release builds and needs to appear inside the if (LOCAL_LOGV) block.
Note: Within a given module, other than at the VERBOSE level, an error should only be reported once if possible: within a single chain of function calls within a module, only the innermost function should return the error, and callers in the same module should only add some logging if that significantly helps to isolate the issue.

Note: In a chain of modules, other than at the VERBOSE level, when a lower-level module detects invalid data coming from a higher-level module, the lower-level module should only log this situation to the DEBUG log, and only if logging provides information that is not otherwise available to the caller. Specifically, there is no need to log situations where an exception is thrown (the exception should contain all the relevant information), or where the only information being logged is contained in an error code. This is especially important in the interaction between the framework and applications, and conditions caused by third-party applications that are properly handled by the framework should not trigger logging higher than the DEBUG level. The only situations that should trigger logging at the INFORMATIVE level or higher is when a module or application detects an error at its own level or coming from a lower level.

Note: When a condition that would normally justify some logging is likely to occur many times, it can be a good idea to implement some rate-limiting mechanism to prevent overflowing the logs with many duplicate copies of the same (or very similar) information.

Note: Losses of network connectivity are considered common and fully expected and should not be logged gratuitously. A loss of network connectivity that has consequences within an app should be logged at the DEBUG or VERBOSE level (depending on whether the consequences are serious enough and unexpected enough to be logged in a release build).

Note: A full filesystem on a filesystem that is acceessible to or on behalf of third-party applications should not be logged at a level higher than INFORMATIVE.

Note: Invalid data coming from any untrusted source (including any file on shared storage, or data coming through just about any network connections) is considered expected and should not trigger any logging at a level higher then DEBUG when it's detected to be invalid (and even then logging should be as limited as possible).

Note: Keep in mind that the '+' operator, when used on Strings, implicitly creates a StringBuilder with the default buffer size (16 characters) and potentially quite a few other temporary String objects, i.e. that explicitly creating StringBuilders isn't more expensive than relying on the default '+' operator (and can be a lot more efficient in fact). Also keep in mind that code that calls Log.v() is compiled and executed on release builds, including building the strings, even if the logs aren't being read.

Note: Any logging that is meant to be read by other people and to be available in release builds should be terse without being cryptic, and should be reasonably understandable. This includes all logging up to the DEBUG level.

Note: When possible, logging should be kept on a single line if it makes sense. Line lengths up to 80 or 100 characters are perfectly acceptable, while lengths longer than about 130 or 160 characters (including the length of the tag) should be avoided if possible.

Note: Logging that reports successes should never be used at levels higher than VERBOSE.

Note: Temporary logging that is used to diagnose an issue that's hard to reproduce should be kept at the DEBUG or VERBOSE level, and should be enclosed by if blocks that allow to disable it entirely at compile-time.

Note: Be careful about security leaks through the log. Private information should be avoided. Information about protected content must definitely be avoided. This is especially important when writing framework code as it's not easy to know in advance what will and will not be private information or protected content.

Note: System.out.println() (or printf() for native code) should never be used. System.out and System.err get redirected to /dev/null, so your print statements will have no visible effects. However, all the string building that happens for these calls still gets executed.

Note: The golden rule of logging is that your logs may not unnecessarily push other logs out of the buffer, just as others may not push out yours.

Javatests Style Rules

Naming test methods

When naming test methods, you can use an underscore to seperate what is being tested from the specific case being tested. This style makes it easier to see exactly what cases are being tested.
Example:

    testMethod_specificCase1 
    testMethod_specificCase2
 void testIsDistinguishable_protanopia() {
    ColorMatcher colorMatcher = new ColorMatcher(PROTANOPIA)
    assertFalse(colorMatcher.isDistinguishable(Color.RED, Color.BLACK))
    assertTrue(colorMatcher.isDistinguishable(Color.X, Color.Y))
}
@ENDNODE

