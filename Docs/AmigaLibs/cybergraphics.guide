@database CybergraphicsV1.0
@author "Blackbird"
@remark by Blackbird
@$VER: CYBERGRAPHICSLIB V1.1 (27.01.2007)- Updated by mrodfr.
@node MAIN "Overview of Cybergraphics.library"
     Copyright © 1996-1998 by phase5 digital products
     All Rights reserved.

     Port from Aminet CGX-DEV release from Blackbird to AB2 Onlineguide

    @{"AllocCModeListTagList" link "AllocCModeListTagList" 0}     @{"InvertPixelArray" link "InvertPixelArray"0}

    @{"BestCModeIDTagList" link "BestCModeIDTagList" 0}        @{"LockBitMapTagList" link "LockBitMapTagList" 0}

    @{"CModeRequestTagList" link "CModeRequestTagList" 0}       @{"MovePixelArray" link "MovePixelArray" 0}

    @{"CVideoCtrlTagList" link "CVideoCtrlTagList" 0}         @{"ReadPixelArray" link "ReadPixelArray" 0}

    @{"IsCyberModeID" link "IsCyberModeID" 0}               @{"ReadRGBPixel" link "ReadRGBPixel" 0}

    @{"DoCDrawMethodTagList" link "DoCDrawMethodTagList" 0}      @{"ScalePixelArray" link "ScalePixelArray" 0}

    @{"ExtractColor" link "ExtractColor" 0}              @{"WritePixelArray" link "WritePixelArray" 0}

    @{"FillPixelArray" link "FillPixelArray" 0}            @{"WriteLUTPixelArray" link "WriteLUTPixelArray" 0}

    @{"FreeCModeList" link "FreeCModeList" 0}             @{"WriteRGBPixel" link "WriteRGBPixel" 0}

    @{"GetCyberMapAttr" link "GetCyberMapAttr" 0}           @{"UnLockBitMap" link "UnLockBitMap" 0}

    @{"GetCyberIDAttr" link "GetCyberIDAttr" 0}            @{"UnLockBitMapTagList" link "UnLockBitMapTagList" 0}

@endnode

@node AllocCModeListTagList
 @{fg shine} Funktion: AllocCModeListTagList@{fg text}

    NAME
    AllocCModeListTagList -- get an exec list with requested modes.
    AllocCModeListTags -- Varargs stub for AllocCModeListTagList

   SYNOPSIS
    result = AllocCModeListTagList( TagItems )
    D0                               A1

    APTR AllocCModeListTagList( struct TagItem * );

    result = AllocCModeListTags( Tag1, ... )

    APTR AllocCModeListTags( Tag Tag1, ... );

   FUNCTION
    Allocates a list structure which contains all requested modes (All nodes
    are of type CyberModeNode). See defines for more information about the
    structure of this nodes.

   INPUTS
    TagItems - pointer to an optional tag list which may be used to
               control the number of returned modes

   TAGS
    Tags available are:

    CYBRMREQ_MinWidth (ULONG) - The minimum display width to let the user
            choose. Default is 320.

    CYBRMREQ_MaxWidth (ULONG) - The maximum display width to let the user
            choose. Default is 1600.

    CYBRMREQ_MinHeight (ULONG) - The minimum display height to let the user
            choose. Default is 240.

    CYBRMREQ_MaxHeight (ULONG) - The maximum display height to let the user
            choose. Default is 1200.

    CYBRMREQ_MinDepth (UWORD) - The minimum display depth to let the user
            choose. Default is 8.

    CYBRMREQ_MaxDepth (UWORD) - The maximum display depth to let the user
            choose. Default is 32.

    CYBRMREQ_CModelArray (UWORD *) - Array of color models which should be
                    available for screenmode selection. Currently supported
                    colormodels are:
                     PIXFMT_LUT8
                     PIXFMT_RGB15
                     PIXFMT_BGR15
                     PIXFMT_RGB15PC
                     PIXFMT_BGR15PC
                     PIXFMT_RGB16
                     PIXFMT_BGR16
                     PIXFMT_RGB16PC
                     PIXFMT_BGR16PC
                     PIXFMT_RGB24
                     PIXFMT_BGR24
                     PIXFMT_ARGB32
                     PIXFMT_BGRA32
                     PIXFMT_RGBA32
                    default is all colormodels available, nothing filtered

   RESULT
    result - 0 if no modes are available, a pointer to a exec list if there
         are modes which fit your needs.

   SEE ALSO
    FreeCModeList()
@endnode

@node "BestCModeIDTagList"
 @{fg shine} Funktion: BestCModeIDTagList@{fg text}

    NAME
    BestCModeIDTagList -- calculate the best ModeID with given parameters
    BestCModeIDTags -- Varags stub for BestCModeIDTagList

   SYNOPSIS
    ID = BestCModeIDTagList( TagItems )
    D0                          A0

        ULONG BestCModeIDTagList( struct TagItem * );

    ID = BestCModeIDTags( Tag1, ...)

        ULONG BestCModeIDTags( Tag, ... );

   FUNCTION
    Returns the CyberGraphX displaymode ID which fits best for the parameters
        supplied in the TagList.

   INPUTS
    TagItems - pointer to an array of TagItems

   TAGS
        CYBRBIDTG_Depth (ULONG) - depth the returned ModeID must support
                                  Default is 8

        CYBRBIDTG_NominalWidth (UWORD),
        CYBRBIDTAG_NominalHeight (UWORD) - desired width and height the ModeID
                                           should have

        CYBRBIDTG_MonitorID (ULONG) - if multiple graphics boards are
                                      installed in the system, you can choose
                                      the desired one with this tag

                Currently supported boards are:

                    CVision64 [1]
                    Piccolo [2]
                    PicassoII [3]
                    Spectrum [4]
                    Domino [5]
                    RetinaZ3/DraCoAltais [6]
                    PiccoSD64 [7]
                                        A2410 [8]
                    CVision3D [13] (V41)
                    Inferno [14] (V41)
                    PicassoIV [15] (V41)

    CYBRBIDTG_BoardName (STRPTR) - Specify the card name directly. For
                example, pass "CVision3D" to get a
                CyberVision64/3D board ID

   RESULT
    ID - id of the best mode to use, or INVALID_ID if a match could
         not be found.

   BUGS
    Older versions return displaymode ids with wrong depth if the
    desired color depth is not available.
    If you specify very small widths/heights (e.g. 50/20 icon size) this
    call returns INVALID_ID instead of the smallest available lowres
    ID 
@endnode

@node "CModeRequestTagList"
  @{fg shine} Funktion: CModeRequestTagList@{fg text}

   NAME
    CModeRequestTagList -- get screenmode from user using a requester.
    CModeRequestTags -- Varargs stub for CModeRequestTagList

   SYNOPSIS
    result = CModeRequestTagList( Requester, TagItems )
    D0                                A0        A1

    LONG CModeRequestTagList( APTR, struct TagItem * );

    result = CModeRequestTags( Requester, Tag1, ... )

    LONG CModeRequestTags( APTR, Tag, ...);

   FUNCTION
    Prompts the user for input by showing all available CyberGraphX
    screenmodes in a requester.
    If the user cancels or the system aborts the request, FALSE is returned,
    otherwise the displaymode id of the selected screenmode.

   INPUTS
    Requester - not used currently. You have to set it to NULL!
    TagItems - pointer to an optional tag list which may be used to
               control features of the requester

   TAGS
    Tags used for the screen mode requester

    CYBRMREQ_Screen (struct Screen *) - Screen on which to open the requester.
            default locale will be used.

    CYBRMREQ_WinTitle (STRPTR) - Title to use for the requesting window.

    CYBRMREQ_OKText (STRPTR) - Label of the positive gadget in the
            requester. English default is "OK".

    CYBRMREQ_CancelText (STRPTR) - Label of the negative gadget in the
            requester. English default is "Cancel".

    CYBRMREQ_MinWidth (ULONG) - The minimum display width to let the user
            choose. Default is 320.

    CYBRMREQ_MaxWidth (ULONG) - The maximum display width to let the user
            choose. Default is 1600.

    CYBRMREQ_MinHeight (ULONG) - The minimum display height to let the user
            choose. Default is 240.

    CYBRMREQ_MaxHeight (ULONG) - The maximum display height to let the user
            choose. Default is 1200.

    CYBRMREQ_MinDepth (UWORD) - The minimum display depth to let the user
            choose. Default is 8.

    CYBRMREQ_MaxDepth (UWORD) - The maximum display depth to let the user
            choose. Default is 32.

    CYBRMREQ_CModelArray (UWORD *) - Array of color models which should
                    be available for screenmode selection. Currently
                    supported colormodels are:

            PIXFMT_LUT8
            PIXFMT_RGB15
            PIXFMT_BGR15
            PIXFMT_RGB15PC
            PIXFMT_BGR15PC
            PIXFMT_RGB16
            PIXFMT_BGR16
            PIXFMT_RGB16PC
            PIXFMT_BGR16PC
            PIXFMT_RGB24
            PIXFMT_BGR24
            PIXFMT_ARGB32
            PIXFMT_BGRA32
            PIXFMT_RGBA32

            default is all colormodels available, nothing filtered

   RESULT
    result - 0 if the user cancelled the requester or if something
         prevented the requester from opening. If!= 0 the displaymode
         id of the selected screenmode is returned.

   BUGS
    The requester structure is not supported.

   NOTES
    You should better use asl.library/AslRequest() instead.
@endnode

@node "CVideoCtrlTagList"
  @{fg shine} Funktion: CVideoCtrlTagList@{fg text}

   NAME
    CVideoCtrlTagList -- Control video output
    CVideoCtrlTags -- Varargs stub for CVideoCtrlTagList

   SYNOPSIS
    CVideoCtrlTagList( ViewPort, TagItems )
                          A0        A1

    void CVideoCtrlTagList( struct ViewPort *, struct TagItem * );

    CVideoCtrlTags( ViewPort, Tag1, ... )

    void CVideoCtrlTags( struct ViewPort *, Tag tag1, ... );

   FUNCTION
    This function controls the video output of the gfx board to which the
    specified ViewPort belongs to.

   INPUTS
    ViewPort - pointer to a ViewPort of a CyberGraphX screen
    TagItems - taglist to control operation

   TAGS

    SETVC_DPMSLevel    (ULONG)  Set the DPMS level for the specified viewport
        Supported levels are:
         DPMS_ON    Full operation
         DPMS_STANDBY    Optional state of minimal power reduction
         DPMS_SUSPEND    Significant reduction of power consumption
         DPMS_OFF    Lowest level of power consumption

   EXAMPLE
    CVideoCtrlTags (&Scr->ViewPort,SETVC_DPMSLevel,DPMS_OFF,TAG_DONE);
    /* set DPMS level */

   NOTES
    Some DPMS levels are not implemented for certain graphics cards
@endnode
  
@node "DoCDrawMethodTagList"
  @{fg shine} Funktion: DoCDrawMethodTagList@{fg text}

   NAME
    DoCDrawMethodTagList -- Do the given hook for the supplied rastport
    DoCDrawMethodTags -- Varargs stub for DoCDrawMethodTagList

   SYNOPSIS
    DoCDrawMethodTagList( Hook, RastPort, TagItems )
                           A0      A1        A2

    void DoCDrawMethodTagList( struct Hook *, struct RastPort *,
                               struct TagItem * )

    DoCDrawMethodTags( Hook, RastPort, Tag1, ... )

    void DoCDrawMethodTags( struct Hook *, struct RastPort *,
                            Tag1, ... )

   FUNCTION
    This function will call the given hook for the given rastport. Is is
    mainly used to do direct bitmap modifications in a locked graphics
    environment. You have to support ALL known color models, so only use
    this call if you really need it!!
    

   INPUTS
    Hook - pointer to callback hook which will be called
           with object == (struct RastPort *)
           and message == [ (APTR) memptr,
                            (ULONG) offsetx, (ULONG) offsety,
                            (ULONG) xsize, (ULONG) ysize,
                            (UWORD) bytesperrow, (UWORD) bytesperpix,
                            (UWORD) colormodel]
           Where colormodel is one of the following:
            PIXFMT_LUT8
            PIXFMT_RGB15
            PIXFMT_BGR15
            PIXFMT_RGB15PC
            PIXFMT_BGR15PC
            PIXFMT_RGB16
            PIXFMT_BGR16
            PIXFMT_RGB16PC
            PIXFMT_BGR16PC
            PIXFMT_RGB24
            PIXFMT_BGR24
            PIXFMT_ARGB32
            PIXFMT_BGRA32
            PIXFMT_RGBA32
    RastPort- A pointer to a cybergraphics RastPort
    TagItems - optional taglist, currently not used. Set it to NULL!

   NOTES
    Use this call only if you want high speed. Keep in mind that you have
    to handle all color models! Do not use ANY os functions in your hook.
    They would cause unpredictable results.

   BUGS
    In previous autodocs, the bytesperrow message field was described as
    an (ULONG) which in fact was an (UWORD). 

   SEE ALSO
    LockBitMap(), LockBitMapTagList()
@endnode
  
@node "ExtractColor"
 @{fg shine} Funktion: ExtractColor@{fg text}
 
   NAME
        ExtractColor -- Extract the specified colour/CLUT value from a given
        CyberGraphX RastPort into a single plane bitmap starting at
        a certain x,y location and using the specified width and
        height. (V41)

   SYNOPSIS
    result = ExtractColor(RastPort,SingleMap,Colour,sX,sY, Width, Height)
    D0                     A0         A1      D0   D1 D2   D3      D4
            

    LONG ExtractColor(struct RastPort *,struct BitMap *,ULONG, ULONG,
                ULONG, ULONG, ULONG );

   FUNCTION
        ExtractColor -- Extract the specified colour/CLUT value from a given
        CyberGraphX RastPort into a single plane bitmap starting at
        a certain x,y location and using the specified width and
        height. Use this function if you want to create masks.
        (V41)

   INPUTS
    RastPort -  pointer to a CyberGraphX RastPort structure

    SingleMap - planar destination bitmap that has at least a depth of
        one and the minimum width and height specified.

        Colour - the color that should be extracted in AARRGGBB format for
        true color rastports or in indexed mode for CLUT rastports.
        The ULONG coding is as follows (for rgb screens):
                 AA - 8-bit alpha channel component
              (set it to 00 if you do not use it!)
                 RR - 8-bit red component of the pixel
                 GG - 8-bit green component
                 BB - 8-bit blue component

        For CLUT rastports only the lowest byte is used as an index
        value to a 256 colour lookup table
        
    sX,sY - starting point in the RastPort that should be analyzed
    Width,Height - size of the rectangle that should be analyzed

   RESULT
    result - returns TRUE if colour could be extraced, FALSE if not

   NOTES
    This call was a no-op in very early revisions of cybergraphics v41
@endnode

@node "FillPixelArray"
 @{fg shine} Funktion: FillPixelArray@{fg text}

   NAME
        FillPixelArray -- fill a rectangular area with the supplied ARGB value
    starting at a specified x,y location and continuing through to another
    x,y location within a certain RastPort

   SYNOPSIS
    count = FillPixelArray(RastPort,DestX, DestY,SizeX,SizeY,ARGB)
    D0                        A1    D0:16  D1:16 D2:16 D3:16 D4:32
            

    LONG FillPixelArray( struct RastPort *, UWORD, UWORD,
                         UWORD, UWORD, ULONG );

   FUNCTION
    For each pixel in a rectangular region, write the supplied color value
    into the bitmap used to describe a particular rastport.

   INPUTS
    RastPort -  pointer to a RastPort structure
    (DestX,DestY) - starting point in the RastPort
    (SizeX,SizeY) - size of the rectangle that should be transfered
        ARGB  - the desired color in AARRGGBB format for true color rastports
        or in indexed mode for CLUT rastports. Every component
        uses 8 bits in the supplied longword. The coding is as
        follows (for rgb screens):
                 AA - 8-bit alpha channel component
              (set it to 00 if you do not use it!)
                 RR - 8-bit red component of the pixel
                 GG - 8-bit green component
                 BB - 8-bit blue component

        For CLUT rastports only the blue component is used as an
        index value to a 256 colour lookup table
        

   RESULT
    count will be set to the number of pixels plotted

   NOTES
    This function should only be used on screens depths > 8 bits in
    cybergraphics versions prior v41.

   BUGS
    The returned count value is wrong up to and including v41 of the
    cybergraphics.library

   SEE ALSO
    InvertPixelArray()
@endnode

@node "FreeCModeList"
   @{fg shine} Funktion: FreeCModeList@{fg text}

   NAME
    FreeCModeList -- frees a previously allocated ModeList

   SYNOPSIS
    FreeCModeList( ModeList );
                      A0

    void FreeCModeList( struct List * );

   FUNCTION
    frees all data which was previously allocated by AllocCModeListTagList()

   INPUTS
    ModeList - a list structure which contains all the mode data.

   SEE ALSO
    AllocCModeListTagList()
@endnode  

@node "GetCyberMapAttr"
 @{fg shine} Funktion: GetCyberMapAttr@{fg text}

   NAME
    GetCyberMapAttr -- Returns information about a cybergraphics bitmap

   SYNOPSIS
    value = GetCyberMapAttr( BitMap, Attribute );
        D0                        A0       D0

    ULONG GetCyberMapAttr( struct BitMap *, ULONG );

   FUNCTION
    Gets information about an extended cybergraphics bitmap.
    This function should be used instead of making any assumptions about
    fields in the bitmap structure. This will provide future
        compatibility.

   INPUTS
    BitMap - pointer to a cybergraphics bitmap structure

    Attribute - a number telling cybergraphics which attribute
                of the bitmap should be returned:

                CYBRMATTR_XMOD        returns bytes per row of the
                                      supplied bitmap

                CYBRMATTR_BPPIX       returns number of bytes per pixel

                CYBRMATTR_PIXFMT      return the pixel format of the
                                      bitmap

                CYBRMATTR_WIDTH       return width of the bitmap in
                                      pixels

                CYBRMATTR_HEIGHT      return the height in lines

                CYBRMATTR_DEPTH       returns bits per pixel

                CYBRMATTR_ISCYBERGFX  returns TRUE if supplied bitmap is
                                      a CyberGraphX one

                CYBRMATTR_ISLINEARMEM returns TRUE if the related display
                                      buffer supports linear memory access

   NOTES
    Unknown attributes are reserved for future use, and return (-1L).

    You should know what you are doing if you call this function!
    Always use the CYBRMATTR_ISCYBERGFX attribute first to check if the
    bitmap is a CyberGraphX one.

   SEE ALSO
    graphics.library/GetBitMapAttr() 
@endnode

@node "GetCyberIDAttr"
  @{fg shine} Funktion: GetCyberIDAttr@{fg text}

   NAME
    GetCyberIDAttr -- Returns information about a cybergraphics id

   SYNOPSIS
    value = GetCyberIDAttr( Attribute, DisplayModeID )
      D0                       D0            D1

    ULONG GetCyberIDAttr( ULONG, ULONG );

   FUNCTION
        Returns information about a specified displaymode id.

   INPUTS
    Attribute - A number telling cybergraphics which attribute
                of the displaymode id should be returned:

                CYBRIDATTR_PIXFMT return the pixel format of the supplied
                                  screenmode id

                CYBRIDATTR_WIDTH  returns visible width in pixels
                CYBRIDATTR_HEIGHT returns visible height in lines
                CYBRIDATTR_DEPTH  returns bits per pixel
                CYBRIDATTR_BPPIX  returns bytes per pixel

    DisplayModeID - CyberGraphX displaymode id

   NOTES
    Unknown attributes are reserved for future use, and return (-1L).

    You should know what you are doing if you call this function!
    Don't apply it on a non cybergraphics displaymode!
@endnode

@node "InvertPixelArray"
 @{fg shine} Funktion: InvertPixelArray@{fg text}

   NAME
        InvertPixelArray -- invert a rectangular area

   SYNOPSIS
    count = InvertPixelArray(RastPort,DestX, DestY,SizeX,SizeY)
    D0               A1     D0:16  D1:16 D2:16 D3:16
            

    LONG InvertPixelArray( struct RastPort *, UWORD, UWORD,
                           UWORD,UWORD );

   FUNCTION
    Invert each pixel in a rectangular region.

   INPUTS
    RastPort -  pointer to a RastPort structure
    (DestX,DestY) - starting point in the RastPort
    (SizeX,SizeY) - size of the rectangle that should be transfered

   RESULT
    count will be set to the number of pixels plotted

   NOTES
    This function should only be used on screens depths > 8 bits with
    cybergraphics versions prior v41.

   BUGS
    The count value returned is totally wrong.

   SEE ALSO
    FillPixelArray()
@endnode  

@node "IsCyberModeID"
  @{fg shine} Funktion: IsCyberModeID@{fg text}

   NAME
    IsCyberModeID -- returns whether supplied ModeID is a cybergraphics id

   SYNOPSIS
    result = IsCyberModeID( DisplayModeID )
    D0                            D0

    BOOL IsCyberModeID( ULONG );

   FUNCTION
    returns whether the supplied ModeID is a cybergraphics.library mode
    identifier (TRUE) or not (FALSE).

   INPUTS
    DisplayModeID -- a 32 bit display identifier.

   RESULT
    result - Flag to indicate if DisplayModeID is a CyberGraphX id
@endnode

@node "LockBitMapTagList"
 @{fg shine} Funktion: LockBitMapTagList@{fg text}

   NAME
    LockBitMapTagList -- Lock supplied BitMap for a short amount of time
                             to allow direct memory access

   SYNOPSIS
    handle = LockBitmapTagList(bitmap,tags);
    D0                           A0    A1

    APTR LockBitMapTagList( APTR,struct TagItem * );

    APTR LockBitMapTags( APTR,Tag1, ... );

   FUNCTION

   INPUTS
        bitmap - pointer to a CyberGraphX bitmap pointer. please check if it is
                 a cybermap by calling GetCyberMapAttr() first.
    tags - pointer to a mandatory taglist which's tagdata pointer fields
               contain valid longwords after a successful call.

   TAGS
     Tags used for the screen mode requester

    LBMI_WIDTH (ULONG *) - points to a longword which contains the bitmap
                               width after a succesful call
    LBMI_HEIGHT (ULONG *) - points to a longword which contains the bitmap
                                height after a succesful call
    LBMI_DEPTH (ULONG *) - points to a longword which contains the bitmap
                               depth after a successful call
    LBMI_PIXFMT (ULONG *) - points to a longword which contains the used
                                pixel format.

            Possibly returned colormodels are:

            PIXFMT_LUT8
            PIXFMT_RGB15
            PIXFMT_BGR15
            PIXFMT_RGB15PC
            PIXFMT_BGR15PC
            PIXFMT_RGB16
            PIXFMT_BGR16
            PIXFMT_RGB16PC
            PIXFMT_BGR16PC
            PIXFMT_RGB24
            PIXFMT_BGR24
            PIXFMT_ARGB32
            PIXFMT_BGRA32
            PIXFMT_RGBA32

    LBMI_BYTESPERPIX (ULONG *) - points to a longword which contains the
                                     amount of bytes per pixel data.
    LBMI_BYTESPERROW (ULONG *) - points to a longword which contains the
                                     number of bytes per row for one bitmap
                                     line
    LBMI_BASEADDRESS (ULONG *) - points to a longword which contains the
                                     bitmap base address. THIS ADDRESS IS ONLY
                                     VALID INSIDE OF THE LOCK/UNLOCKBITMAP
                                     CALL!!!!!!!!!


   RESULT
    handle - 0 if the bitmap could not be locked,!= 0 it contains a handle
                 which should be passed to UnLockBitMap afterwards

   NOTES
        Only use this call if you really NEED the rendering speed, DON'T lock the
        bitmap longer than for one frame. DON'T use any library calls while the
        bitmap is locked! This function is considered low level.

   BUGS
    The LBMI_DEPTH tagitem pointer will always contain 8 even for deeper
    bitmaps. Use GetCyberMapAttr() or graphics.library/GetBitMapAttr() to
    get the correct depth.

   SEE ALSO
    UnLockBitMap(), UnLockBitMapTagList()
@endnode
 
@node "MovePixelArray"
 @{fg shine} Funktion: MovePixelArray@{fg text}

   NAME
        MovePixelArray -- move the color values of a rectangular area of
    pixels starting at a specified x,y location and continuing through
    to another x,y location within a certain RastPort

   SYNOPSIS
    count = MovePixelArray(SrcX, SrcY, RastPort,DstX , DstY ,SizeX, SizeY)
    D0               D0:16 D1:16  A1      D2:16  D3:16 D4:16  D5:16

    LONG MovePixelArray(UWORD,UWORD,struct RastPort *,UWORD,UWORD,UWORD,
                UWORD)

   FUNCTION
    For each pixel in a rectangular region, move the pixel value from a
    specified source to a specified destination

   INPUTS
    (SrcX,SrcY) - starting point in the source rectangle
    RastPort -  pointer to a RastPort structure
    (DestX,DestY) - starting point in the destination rectangle
    (SizeX,SizeY) - size of the rectangle that should be transfered

   RESULT
    count will be set to the number of pixels moved

   NOTES
    This function should only be used on screens depths > 8 bits with
    cybergraphics versions up to v40.
    The blitter can be used to move the data if the bitmap is in display
    memory. This is why you should use this call.

   BUGS
    The count value returned is totally wrong.

   SEE ALSO
    FillPixelArray(), InvertPixelArray(),
    graphics.library/BltBitMapRastPort()
@endnode

@node "ReadPixelArray"
 @{fg shine} Funktion: ReadPixelArray@{fg text}

   NAME
        ReadPixelArray -- Read the color values of a rectangular array of
    pixels starting at a specified x,y location and continuing through
    to another x,y location within a certain RastPort

   SYNOPSIS
    count = ReadPixelArray(destRect,DestX,DestY,DestMod,RastPort,SrcX ,
    D0              A0    D0:16 D1:16 D2:16     A1     D3:16
                SrcY ,SizeX,SizeY,DestFormat)
                D4:16 D5:16 D6:16    D7

    LONG ReadPixelArray(APTR,UWORD,UWORD,UWORD,struct RastPort *,UWORD,
                UWORD,UWORD,UWORD,UBYTE)

   FUNCTION
    For each pixel in a rectangular region, write the color value to a
    linear array of color values from the bitmap used to describe a
    particular rastport.

   INPUTS
    destRect - pointer to an array of pixels where to write the pixel
               data to. The pixel format is specified in DestFormat
    (DestX,DestY) - starting point in the destination rectangle
    DestMod - The number of bytes per row in the destination rectangle.
    RastPort -  pointer to a RastPort structure
    (SrcX,SrcY) - starting point in the RastPort
    (SizeX,SizeY) - size of the rectangle that should be transfered
    DestFormat - pixel format in the destination rectangle
                Currently supported formats are:

                RECTFMT_RGB  3 bytes per pixel, one byte red, one blue
                             and one byte green component

                RECTFMT_RGBA 4 bytes per pixel, one byte red, one blue,
                             one byte green component and the last
                                 byte is alpha channel information which
                         is 0 if the board does not support alpha
                                 channel

                RECTFMT_ARGB 4 bytes per pixel, one byte red, one blue,
                             one byte green component and the first
                                 byte is alpha channel information. If the
                                 board does not support alpha channel a 
                         0 is returned for alpha channel information

   RESULT
    count will be set to the number of pixels read

   NOTES
    This function should only be used on screens depths > 8 bits.

   BUGS
    The count value returned is totally wrong.

   SEE ALSO
    WritePixelArray(), graphics.library/ReadPixelArray8()
@endnode

@node "ReadRGBPixel"
 @{fg shine} Funktion: ReadRGBPixel@{fg text}

   NAME
        ReadRGBPixel -- Reads a pixel from a specified location

   SYNOPSIS
        color = ReadRGBPixel(RastPort,x ,y )
        D0                     A1     D0 D1

        ULONG ReadRGBPixel(struct RastPort *,UWORD,UWORD);

   FUNCTION
    Read the alpha,red,green & blue 8-bit color components of the pixel at
        a specified x,y location within a certain RastPort

   INPUTS
    rp -  pointer to a RastPort structure
        x,y    - the coordinates of the pixel

   RESULT
        color  - the desired color in AARRGGBB format. Every component
         allocates 8 bits in the returned longword. The coding is as
         follows:

                 AA - 8-bit alpha channel component
              (boards which do not have an alpha channel return 00)
                 RR - 8-bit red component of the pixel
                 GG - 8-bit green component
                 BB - 8-bit blue component

  NOTES
    This function should only be used on screens depths > 8 bits. Use
    ReadPixel() on 8 bit screens!

  SEE ALSO
    WriteRGBPixel()
@endnode

@node "ScalePixelArray"
 @{fg shine} Funktion: ScalePixelArray@{fg text}

   NAME
       ScalePixelArray -- Scale the colors values of a rectangular array of
    pixels starting at a specified x,y location and continuing through
    to another x,y location within a certain RastPort (V41)

   SYNOPSIS
    count = ScalePixelArray(srcRect,SrcW,SrcH ,SrcMod,RastPort,DestX,
    D0               A0   D0:16 D1:16 D2:16     A1    D3:16
                DestY,DestW,DestH,SrcFormat)
                D4:16 D5:16 D6:16    D7

    LONG ScalePixelArray(APTR,UWORD,UWORD,UWORD,struct RastPort *,UWORD,
                 UWORD,UWORD,UWORD,UBYTE)

   FUNCTION
    For each pixel in a rectangular region, scale the color values from a
    linear array of color values into the bitmap used to describe a
    particular rastport.

   INPUTS
    srcRect - pointer to an array of pixels from which to fetch the
              pixel data. The pixel format is specified in SrcFormat
    (SrcW,SrcH) - Width and Height of the source rectangle
    SrcMod - The n umber of bytes per row in the source rectangle.
    RastPort -  pointer to a RastPort structure
    (DestX,DestY) - starting point in the RastPort
    (DestW,DestH) - size of the destination area
    SrcFormat - pixel format in the source rectangle
                Currently supported formats are:

                RECTFMT_RGB  3 bytes per pixel, one byte red, one blue
                             and one byte green component

                RECTFMT_RGBA 4 bytes per pixel, one byte red, one blue,
                             one byte green component and the last
                                 byte is alpha channel information. If you
                                 do not use alpha channel set this byte to
                         0!!!

                RECTFMT_ARGB 4 bytes per pixel, one byte red, one blue,
                             one byte green component and the first
                                 byte is alpha channel information. If you
                                 do not use alpha channel set this byte to
                         0!!!

                RECTFMT_LUT8  1 byte per pixel, specifying the pen
                                  number. On screen depths > 8 bits the
                              data is converted using the actual color
                              lookup table.

                RECTFMT_GREY8 1 byte per pixel, specifying grey scale
                              value.
   RESULT
    count will be set to the number of pixels plotted

   NOTES
    Up to v40, this function only worked on screens depths > 8 bits.
    You may specify RECTFMT_LUT8 on 8bit screens, too now if v41 is
    available

   BUGS
    Very early v40 revision did not support RECTFMT_LUT8 and
    RECTFMT_GREY8.
        Scaling is not very accurate. If you need high quality, use
        graphics.library/BitMapScale() instead or custom code.
    The count value returned is totally wrong.

   SEE ALSO
    graphics.library/BitMapScale()
@endnode

@node "WritePixelArray"
 @{fg shine} Funktion: WritePixelArray@{fg text}

   NAME
        WritePixelArray -- write the color value of a rectangular array of
    pixels starting at a specified x,y location and continuing through
    to another x,y location within a certain RastPort

   SYNOPSIS
    count = WritePixelArray(srcRect,SrcX ,SrcY ,SrcMod,RastPort,DestX,
    D0               A0   D0:16 D1:16 D2:16     A1    D3:16
                DestY,SizeX,SizeY,SrcFormat)
                D4:16 D5:16 D6:16    D7

    LONG WritePixelArray(APTR,UWORD,UWORD,UWORD,struct RastPort *,UWORD,
                 UWORD,UWORD,UWORD,UBYTE)

   FUNCTION
    For each pixel in a rectangular region, write the color value from a
    linear array of color values into the bitmap used to describe a
    particular rastport.

   INPUTS
    srcRect - pointer to an array of pixels from which to fetch the
              pixel data. The pixel format is specified in SrcFormat
    (SrcX,SrcY) - starting point in the source rectangle
    SrcMod - The number of bytes per row in the source rectangle.
    RastPort -  pointer to a RastPort structure
    (DestX,DestY) - starting point in the RastPort
    (SizeX,SizeY) - size of the rectangle that should be transfered
    SrcFormat - pixel format in the source rectangle
                Currently supported formats are:

                RECTFMT_RGB   3 bytes per pixel, one byte red, one blue
                              and one byte green component

                RECTFMT_RGBA  4 bytes per pixel, one byte red, one
                              blue, one byte green component and the
                              last byte is alpha channel information.
                              If you do not use alpha channel set this
                              byte to 0!!!

                RECTFMT_ARGB  4 bytes per pixel, one byte red, one
                              blue, one byte green component and the
                              first byte is alpha channel information.
                              If you do not use alpha channel set this
                              byte to 0!!!

                RECTFMT_LUT8  1 byte per pixel, specifying the pen
                                  number. On screen depths > 8 bits the
                              data is converted using the actual color
                              lookup table.

                RECTFMT_GREY8 1 byte per pixel, specifying grey scale
                              value.

   RESULT
    count will be set to the number of pixels plotted

   NOTES
    Only RECTFMT_LUT8 can be used on screen depths <= 8 bits.
    For > 8 bit rastport RECTFMT_LUT8 uses the actual colormap "attached"
    to the bitmap. If the bitmap is a friend bitmap of a screen bitmap
    or the screen bitmap itself, it uses the screen's viewport colormap.
    
   BUGS
    The count value returned is totally wrong.

   SEE ALSO
    ReadPixelArray(), WriteLUTPixelArray(),
    graphics.library/WritePixelArray()
@endnode

@node "WriteLUTPixelArray"
 @{fg shine} Funktion: WriteLUTPixelArray@{fg text}

   NAME
        WriteLUTPixelArray -- write the color value generated from a given
    color table of a rectangular array of pixels starting at a specified
    x,y location and continuing through to another x,y location within
    a certain RastPort (V41)

   SYNOPSIS
    count = WriteLUTPixelArray(srcRect,SrcX ,SrcY ,SrcMod,RastPort,
    D0                    A0   D0:16 D1:16 D2:16     A1
            CTable,DestX,DestY,SizeX,SizeY,CTabFormat)
              A2   D3:16 D4:16 D5:16 D6:16      D7

    LONG WriteLUTPixelArray(APTR,UWORD,UWORD,UWORD,struct RastPort *,APTR,
                         UWORD, UWORD,UWORD,UWORD,UBYTE)

   FUNCTION
    For each pixel in a rectangular region, write the color value
    generated with a given color lookup table from a linear array of
        indexed pixel values into the bitmap used to describe a    particular
    rastport.

   INPUTS
    srcRect - pointer to an array of pixels from which to fetch the
              CLUT data. Pixels are specified in bytes, 8bits/pixel.
    (SrcX,SrcY) - starting point in the source rectangle
    SrcMod - The number of bytes per row in the source rectangle.
    RastPort -  pointer to a RastPort structure
    CTable - pointer to the color table using the format specified
        with CTabFormat
    (DestX,DestY) - starting point in the RastPort
    (SizeX,SizeY) - size of the rectangle that should be transfered
    CTabFormat - color table format in the source rectangle
        Currently supported formats are:
         CTABFMT_XRGB8 - CTable is a pointer to a ULONG table
             which contains 256 entries. Each entry specifies the
            rgb colour value for the related index. The format
            is XXRRGGBB.

                     XX - unused
                     RR - 8-bit red component of the pixel
                     GG - 8-bit green component
                        BB - 8-bit blue component

    
   RESULT
    count will be set to the number of pixels plotted

   NOTES
    Does only work on rastports with depth > 8bits

   BUGS
    The count value returned is totally wrong.
    With cgxsystem.library up to version 41.19, the call returns
    immediately with CTABFMT_XRGB8 due to a bug in the code

   SEE ALSO
    ReadPixelArray(), WritePixelArray(), 
    graphics.library/WritePixelArray8()
@endnode


@node "WriteRGBPixel"
 @{fg shine} Funktion: WriteRGBPixel@{fg text}

   NAME
        WriteRGBPixel -- Writes a pixel to a specified location

   SYNOPSIS
        error = WriteRGBPixel(RastPort,x ,y ,color)
        D0                      A1     D0 D1 D2

        ULONG WriteRGBPixel(struct RastPort *,UWORD,UWORD,ULONG);

   FUNCTION
    Write the alpha,red,green and blue 8-bit color component of the given
        color to a specified x,y location within a certain RastPort

   INPUTS
    rp     - pointer to a RastPort structure
        x,y    - the coordinates of the pixel
        color  - the desired color in AARRGGBB format. Every component
         allocates 8 bits of the returned longword. The coding is as
         follows:

                 AA - 8-bit alpha channel component
              (set it to 00 if you dont want to use it!)
                 RR - 8-bit red component of the pixel
                 GG - 8-bit green component
                 BB - 8-bit blue component

   RESULT
    error = 0 if pixel succesfully changed
          = -1 if (x,y) is outside the rastport

   NOTES
    This function should only be used on screens depths > 8 bits. Use
    WritePixel() on 8 bit screens!

   SEE ALSO
    ReadRGBPixel(), graphics.library/WritePixel()
@endnode


@node "UnLockBitMap"
 @{fg shine} Funktion: UnLockBitMap@{fg text}

   NAME
    UnLockBitMap -- Unlock CyberGraphX BitMap that was previously locked

   SYNOPSIS
    UnLockBitmap( Handle )
                        A0

    void UnLockBitMap( APTR );

   FUNCTION
        Unlock CyberGraphX BitMap that was previously locked

   INPUTS
        handle - handle to the previously locked BitMap

   SEE ALSO
    LockBitMapTagList()
@endnode 

@node "UnLockBitMapTagList"
 @{fg shine} Funktion: UnLockBitMapTagList@{fg text}

   NAME
    UnLockBitMapTagList -- Unlock CyberGraphX BitMap that was previously
        locked
    UnLockBitMapTags -- Varargs stub for UnLockBitMapTagList

   SYNOPSIS
    UnLockBitmapTagList( Handle, Tags )
                              A0      A1

    void UnLockBitMapTagList( APTR, struct TagItem * );

    void UnLockBitMapTags( APTR, Tag1, ... );

   FUNCTION
        Unlock CyberGraphX BitMap that was previously locked

   INPUTS
        handle - handle to the previously locked BitMap

    Tags - pointer to a mandatory taglist
   TAGS
    UBMI_UPDATERECTS (struct RectList *) - pointer to a rectlist which
        contains rectangles that should be updated. This is needed for
        cards that don't have a linear display memory address space
        The RectList structure looks like this:
            struct RectList
            {
             ULONG rl_num;           // no. of rects in this list
             struct RectList *rl_next; // pointer to next list
             struct Rectangle rect1;   // This is the first
                ..           // rectangle followed by
                ..           // rl_num-1 rectangles
                ..
            }
    UBMI_REALLYUNLOCK (BOOL) - Specifies whether bitmap should really be
        unlocked (TRUE) or not (FALSE) in case you just want to update
        certain rectangles and unlock later.

   BUGS
    Very early v40 revisions did not support this call

   SEE ALSO
    LockBitMapTagList(), UnLockBitMap()
@endnode 

@node "Overview__bitmaps"
 @{fg shine} Funktion: Overview--bitmaps--@{fg text}
 
   PURPOSE
    cybergraphics.library is meant to be a gfx board extension for the
    native graphics.library. Because C= never developed a rtg compliant
    graphics.library (up to OS3.1 there are no possibilities to add custom
    boards into the display database in a system friendly fashion), it
    patches some of the original graphics functions in order to integrate
    custom graphics boards into the system.
     It also features some new functions which are not available in the
    standard graphics.library. Currently graphics.library v39 and v40 is
    supported.
     Additionally it is possible to open screens deeper than 256 colours
    which are completely intuition compatible. Nearly every function may
    be used on such screen except some special blits which rely on planar
    bitmap graphics. Also, this screens are 8bit backwards compatible.
    Nearly every standard 8bit application will work on this 15/16/24 bit
    screen. But it only can use the additional features, if it knows of
    CyberGraphX, of course.
     Maybe in a future release of graphics, CyberGraphX will be
    obsolete.  But until then, cybergraphics.library is the only way to
    add truecolour features to your application under an intuition
    environment with minimum effort.
     So, CyberGraphX is not meant to be a replacement for the original
    graphics/intuition system (just like EGS is for example), e.g. there
    is no ECS/AGA native chipset CyberGraphX driver, because all the
    functionality of the original chipset is already given in the
    original graphics.library.
    
   OVERVIEW
    This part only describes how to use the extended features of
    CyberGraphX. Anything else about programming graphics can be found
    in the original graphics.library documentation. Most graphics.library
        functions are extended to work on CyberGraphX's 15/16/24 bit
        rastports.

--bitmaps--

Bitmaps & CyberGraphX

 Before OS 3.x there was no standard method to create bitmaps.  It was up
to the application programmer to allocate memory for the bitmap structure
and to get the plane pointers by subsequent calls to AllocRaster()/gfx.  A
InitBitMap() call was available to initialize various elements in the
bitmap structure.
 Unfortunately some people didn't even use AllocRaster() and InitBitmap()
to setup their bitmaps but used AllocMem() and initialized the bitmap
structure on their own.
 Because there was only one certain bitplane format description, it was no
problem to directly poke into the allocated planes.  It even was no problem
to alter the contents of the bitmap structure because the application had
total control over the location and the contents of this structure and
related plane pointers.

 Starting with OS 3.x two new graphics calls were added to support bitmap
creation and removal:  AllocBitmap()/gfx and FreeBitmap()/gfx.  With this
calls the first step was made to allow custom bitmap formats.  Before it
was no problem at all to directly render into the planes or to make
assumptions about the structure of the bitmap data.  To get more
information about the bitmap data an information retrieval call was added:
GetBitmapAttr()/gfx.  With this one you could get information on the width,
height, depth and certain flags of the bitmap.  This was the first step
into the RTG direction.  As soon as GetBitmapAttr(bm,BMA_FLAGS) didn't
return BMF_STANDARD, the bitmap was not direct accessable anymore and could
only be accessed by attachment to a rastport and subsequent rendering calls
or by using blit calls with a standard amiga bitmap as destination.
 Unfortunately many programs didn't follow these guide lines and didn't
check for the BMF_STANDARD flag with OS3.0 and above.  Up to now many
programs still use the methods described at the beginning of this chapter.
That's one reason why graphics extensions like CyberGraphX still have to
fiddle around with planar to chunky conversions, even if the underlying
hardware doesn't support planar graphics anymore.  This often leads to
dramatic speed losses with certain applications which often could be
redundant if standard rendering calls were used.
 So please use AllocBitmap()/FreeBitmap() whereever possible when running
3.x.  It really gives you a major performance improvement in most cases
when used on 3rd party display adapters.  Don't forget to add a friend
bitmap pointer whereever possible to allocate compatible bitmap structures.
 With CyberGraphX you also have to add BMF_MINPLANES in the flags field of
AllocBitmap()/gfx.  This is due to bug in the standard picture.datatype
which doesn't check for BMF_STANDARD and directly pokes into the bitplanes
even if the returned bitmap is non planar ......  Using BMF_MINPLANES in a
non CyberGraphX environment remains still compatible and should not lead to
any problems, with CyberGraphX a chunky bitmap is returned, if a chunky
friendbitmap is supplied.  How to access the bitmap data will be discussed
later on.  Don't make assumptions on the bitmap contents before you have
called the required CyberGraphX library calls !!

 Besides the AllocBitmap() friend bitmap method, AllocBitmap() has been
extended to allow for allocation of certain pixel format bitmaps when using
CyberGraphX.  With CyberGraphX, bitmaps aren't limited to planar image maps
or 8 bit chunky data (which wasn't even available with the standard
chipset/ graphics.library) anymore.  It is also possible now to allocate
device dependant pixel format bitmaps and standard 15/16/24/32 bit depth
image maps.  Therefore new bits in the 32bit flags field parameter of
AllocBitmap() have been added.  If you specify the BMB_SPECIALFMT bit (see
includes), the upper 8 bits of the flags longword contain information on
the pixel format of the requested bitmap.  The following pixel formats are
available:
  PIXFMT_LUT8,PIXFMT_RGB15,PIXFMT_BGR15,PIXFMT_RGB15PC,PIXFMT_BGR15PC,
  PIXFMT_RGB16,PIXFMT_BGR16,PIXFMT_RGB16PC,PIXFMT_BGR16PC,PIXFMT_RGB24,
  PIXFMT_BGR24,PIXFMT_ARGB32,PIXFMT_BGRA32,PIXFMT_RGBA32 Many of this pixel
formats are device specific and should not be used, recommended formats are
PIXFMT_LUT8, PIXFMT_RGB16, PIXFMT_RGB24 and PIXFMT_ARGB32.
 Once allocated, you can attach the returned bitmap to a rastport and do
rendering calls.  It is NOT possible to attach this bitmap to a screen by
supplying it as custom bitmap with OpenScreenTagList() !!
 You are not allowed to directly poke into the bitmap image data as long as
the bitmap isn't locked !.  The location and contents of the image data is
subject to change and is only valid when it's locked by using the available
locking calls (see autodocs).  LockBitmapTags()/UnLockBitmap() has been
added for this purpose.  You HAVE TO supply a taglist with LockBitmapTags()
which contains pointers to longwords which are filled with valid data if
the call returns with a non-zero value.  Only if a non-zero value is
returned you are able to access the bitmap directly !  Check the address
you get back with the LBMI_BASEADDRESS tag.  This is the base address you
can do your rendering to.  Get the value of the LBMI_PIXFMT ULONG field to
get information on the colormodel you have to use for image rendering.  ALL
models have to be supported!  The other fields give you information on the
layout of the bitmap data.  It should be no problem, to directly render
into the bitmap anymore.  Keep in mind that all this values are only valid
until a subsequent call to UnLockBitmap().  Afterwards you have to lock the
bitmap again.  Don't hold this lock for longer than one frame !  You may
use the standard graphics.library bitmap blitting calls to copy the bitmap
contents to another bitmap.  Copying truecolour bitmaps into indexed colour
chunky bitmaps is not supported by now.
@endnode


