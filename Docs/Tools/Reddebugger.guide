@DATABASE "RED Debugger AmigaGuide Documentation"
@REMARK $VER: RED Debugger AmigaGuide Documentation v2.5
@INDEX INDEX
@NODE MAIN "RED Debugger v2.5"
                             @{u}@{b}RED Debugger v2.5@{uu}@{ub}

                         (C)1996 Red When Excited


   @{" Introduction            " link ABOUT}    -- What is the RED Debugger?
   @{" Credits                 " link CREDITS}    -- Credits
   @{" Red When Excited        " link RWE}    -- About Red When Excited
   @{" Context Sensitive Help  " link onlinehelp}    -- The Online Help System
   @{" Debugger Windows        " link WINDOWS}    -- The Debugger Windows
   @{" Debugger Menus          " link MENUS}    -- The Debugger Menus
   @{" Configuration Saving    " link NODEconfiguration}    -- Saving The Configuration
   @{" Communications          " link COMMS}    -- Communicating With The Debugger
   @{" Custom Menu             " link CUSTOMMENU}    -- The Custom Menu
   @{" Example Programs        " link IDX_examples}    -- Examples Programs

   @{" Main Index              " link INDEX}    -- The Main Index Page


              This program requires the reqtools.library v38+
@ENDNODE MAIN

@NODE INDEX "The Index Page"
                             @{u}@{b}RED Debugger v2.5@{uu}@{ub}

                 Please select the topic you wish to read:


   @{" Introduction            " link ABOUT}    -- What is the RED Debugger?
   @{" Credits                 " link CREDITS}    -- Credits
   @{" Red When Excited        " link RWE}    -- About Red When Excited

Online Help:
   @{" Context Sensitive Help  " link onlinehelp}    -- The Online Help System

The Debugger Windows:
   @{" Program Control Window  " link WIN_PROGCNTRL}    -- About The Program Control Window
   @{" Register Window         " link WIN_REGS}    -- About The Register Display Window
   @{" Source Window           " link WIN_SOURCE}    -- About The Source Display Window
   @{" Memory Windows          " link WIN_MEM}    -- About The Memory Display Windows
   @{" Object Trace Windows    " link WIN_OBJECTS}    -- About The Object Trace Windows
   @{" Variable Trace Window   " link WIN_VARS}    -- About The Variable Trace Windows
   @{" 680x0 Disassembly Window" link WIN_DISASM}    -- About The 680x0 Disassembly Window
   @{" Copper DisAsm Window    " link WIN_COPPER}    -- About The Copper Disassembly Window
   @{" Search Memory Window    " link WIN_SEARCH}    -- About The Search Memory Window
   @{" Array Window            " link WIN_ARRAY}    -- About The Array Display Window
   @{" Stucture Windows        " link WIN_STRUCTURES}    -- About The Structure Windows
   @{" Custom Chip Registers   " link WIN_CUSTOMCHIPS}    -- About The Custom Chip Window
   @{" Label List              " link WIN_LABELLIST}    -- About The Label List Window

The Debugger Menu Strip:
   @{" Debugger Menus          " link MENUS}    -- The Debugger Menus

Program Execution Control:
   @{" Auto EVALuation         " link NODEautoeval}    -- The AutoEVAL Function
   @{" Procedure Control       " link NODEproccontrol}    -- The Procedure Control Option
   @{" Blitz Mode Control      " link NODEblitzcontrol}    -- The Blitz Mode Control Option
   @{" Gosub Stepping          " link NODEgosubstep}    -- The Gosub Step Option

Configuration:
   @{" Configuration Saving    " link NODEconfiguration}    -- Saving The Configuration
   @{" Screen Mode Selection   " link NODEscrmode}    -- Selecting A Screen Mode

Miscellaneous:
   @{" Locking                 " link NODElocking}    -- Locking Windows To Expressions
   @{" Breakpoints             " link NODEbreakpoints}    -- About Breakpoints
   @{" Defining Structures     " link STRUCTURES}    -- How To Define Structures
   @{" Communications          " link COMMS}    -- Communicating With The Debugger
   @{" Custom Menu             " link CUSTOMMENU}    -- The Custom Menu

Example Programs:
   @{" Demo 1 - Blitz Control " link demo1}    -- Demo 1 - Blitz Control
   @{" Demo 2 - Proc Control  " link demo2}    -- Demo 2 - Procedure Control
   @{" Demo 3 - Copper Trace  " link demo3}    -- Demo 3 - Copper Trace Window
   @{" Demo 4 - Var Trace     " link demo4}    -- Demo 4 - Variable Tracing
@ENDNODE INDEX

@NODE IDX_examples "Example Programs"
                             @{b}@{u}Example Programs@{ub}@{uu}

                 Please select the topic you wish to read:


   @{" Demo 1 - Blitz Control " link demo1}    -- Demo 1 - Blitz Control
   @{" Demo 2 - Proc Control  " link demo2}    -- Demo 2 - Procedure Control
   @{" Demo 3 - Copper Trace  " link demo3}    -- Demo 3 - Copper Trace Window
   @{" Demo 4 - Var Trace     " link demo4}    -- Demo 4 - Variable Tracing
@ENDNODE IDX_examples

@NODE ABOUT "About the debugger"
                           @{u}@{b}About the REDDebugger@{uu}@{ub}

  This program replaces the default debugger supplied with B.U.M. 7.  It 
is only of use for people who have version 1.9 of Blitz2 (which was supplied
with B.U.M. 7) or later.

  The standard debugger supplied with Blitz2 is very basic in that it 
only allows you to step programs and evaluate variables.  It opened a 
window on the Workbench screen, in which it had program listing and some 
program control gadgets.  This debugger goes for a full MonAm (the 
disassembler/debugger supplied with Devpac) approach in that it opens its
own screen.  On this screen are a series of windows that allow you to 
watch what you're program is doing whilst running it, see the section
@{" Windows " link WINDOWS} for information on them.

  There are a few things that should be pointed out about using this
program.  Firstly, it is big and memory hungry, thus you will need to have
at least 1meg to use it alongside Blitz2.  Also, at the moment anyway, the
program uses the ReqTools library via Neil O'Rourke's blitz library.  You
will thus have to have reqtools.library installed on your machine.


                         @{b}@{u}defaultdbug & REDDebugger@{ub}@{uu}

  Note that the way this program runs is different to the debugger supplied
with BUM7 and all versions of this program to date (this program was
originally the LES Debugger and was distributed as Public Domain).
Previously all versions of Blitz Basic currently running each had their own
version of the Debugger loaded.  Since the debugger is quite a big program
(30k for the original, 160k for LESDebugger) this caused a lot of memory
loss if you have several versions of Blitz2 running.  This debugger uses a
different method.  Instead of the file defaultdbug being the debugger, it
is instead a very small program which sends a debug request to a separate
debugger program - REDDebugger.  The REDDebugger is loaded into memory if
it is not already loaded.  Thus several versions of Blitz2 can share the
same debugger program, saving 160k for every extra version of Blitz2
loaded.

  This change, though, means that only one program at once can be debugged
at a time in any system.  Thus attempting to debug a program whilst another
is already being debugged will cause Blitz2 to halt until the REDDebugger
is free to debug the new program.  The REDDebugger will become free when
the current program being debugged ends or quits.

  The REDDebugger opens a window on the default public screen when it is
loaded but not currently in use.  This window can be moved about or closed
to quit the debugger.

  Since the REDDebugger works differently to previous incarnations of the
debugger it is now possible to run it on its own (e.g. without having any
copies of Blitz2 loaded).  Also the debugger will not quit when you quit
any copies of Blitz2 currently load - it must be closed manually by
clicking on the close gadget in its window.  Also, you cannot run two
copies on the REDDebugger at once, if you attempt to a requester will open
informing you that the debugger is already running.


                               @{b}@{u}Installation@{ub}@{uu}

  Note that you cannot directly replace your current defaultdbug program
file with any files from this archive - you must use the Installer provided
with the Blitz Support Suite to install the REDDebugger.
@ENDNODE ABOUT

@NODE WINDOWS "Windows In The Debugger"
                          @{u}@{b}Windows In The Debugger@{uu}@{ub}

  The debugger can have a very large number of windows open at once, each
with different functions and uses.  Note though that having a large number
of windows open at once can cause your programs performance to degrade
during trace operations.  Since the debugger does no window updating whilst
you are RUNning your program, this is not effected.

  The windows that can be opened.

   @{" Program Control Window  " link WIN_PROGCNTRL}    -- About The Program Control Window
   @{" Register Window         " link WIN_REGS}    -- About The Register Display Window
   @{" Source Window           " link WIN_SOURCE}    -- About The Source Display Window
   @{" Memory Windows          " link WIN_MEM}    -- About The Memory Display Windows
   @{" Object Trace Windows    " link WIN_OBJECTS}    -- About The Object Trace Windows
   @{" Variable Trace Window   " link WIN_VARS}    -- About The Variable Trace Windows
   @{" 680x0 Disassembly Window" link WIN_DISASM}    -- About The 680x0 Disassembly Window
   @{" Copper DisAsm Window    " link WIN_COPPER}    -- About The Copper Disassembly Window
   @{" Search Memory Window    " link WIN_SEARCH}    -- About The Search Memory Window
   @{" Array Window            " link WIN_ARRAY}    -- About The Array Display Window
   @{" Stucture Windows        " link WIN_STRUCTURES}    -- About The Structure Windows
   @{" Custom Chip Registers   " link WIN_CUSTOMCHIPS}    -- About The Custom Chip Window
   @{" Label List              " link WIN_LABELLIST}    -- About The Label List Window
@ENDNODE WINDOWS

@NODE WIN_PROGCNTRL "Program Control Window"
                          @{u}@{b}Program Control Window@{uu}@{ub}

  The gadgets inside the Control Window allow you to control your programs
execution and interrogate its current state.  Inside the window, from left
to right order, the gadgets are:

	STOP : Causes program execution to stop and the debugger
	       to take over

	STEP : Execute the current instruction (whilst program
	       stopped).  If you press <CTRL> whilst selecting this gadget
	       the debugger will ask you how many times you wish to step.
	       In this way you can STEP as many instructions as you like.

	SKIP : Ignore current instruction and move to the next one

	TRACE: Trace the program (like running, except the
	       debuggers windows are updated.  Your program will
	       run very slowly in trace mode, but you'll be able
	       to see exactly what is going on.

	RUN  : Resume normal speed execution of the program

	<    : Move backwards through history buffer

	>    : Move forwards through history buffer

	EXEC : Execute a basic instruction

	EVAL : Evaluate a value (e.g. variable, addition etc) 


	BLTZ : Click to view blitz mode display (if program is in
	       blitzmode).  Press a mouse button to return to
	       debugger.

	REGS : Toggle the @{" Register Window " link WIN_REGS} (open/closed)

	MEM1 : Toggle @{" Memory Window " link WIN_MEM} 1 (open/closed)

	MEM2 : Toggle @{" memory window " link WIN_MEM} 2 (open/closed)

	VARS : Toggle the @{" Variable Trace Window " link WIN_VARS} (open/closed)

	ASM  : Toggle the @{" 680x0 Disassembly window " link WIN_DISASM} (open/closed)

        COP  : Toggle the @{" Copper Disassembly Window " link WIN_COPPER} (open/closed)

	GS   : Toggle @{" Gosub Stepping " link NODEgosubstep} on/off (highlighted=on)

	PS   : Toggle @{" Procedure Control " link NODEproccontrol} on/off (highlighted=on)

	BC   : Toggle @{" Blitz Mode Control " link NODEblitzcontrol} on/off


                      @{b}@{u}Notes about the control window@{ub}@{uu}

	1) All gadgets have keyboard shortcuts associated with them.  See the
	   menu option 'Keyboard Shortcuts' inside the debugger for the list of
	   keys.

	2) Closing the program control window causes the debugger to quit and
	   your program to end.

	3) The control window title contains the current program mode
	   of the program being debugged. Possible modes are: AMIGA, QAMIGA
	   and BLITZ.
@ENDNODE WIN_PROGCNTRL

@NODE WIN_REGS "Register window"
                              @{u}@{b}Register window@{uu}@{ub}

   This window allows you to view the contents of the 8 data and address
registers.  It will mainly be of use to people who have a little knowledge of
assembler.  As well as the register contents, you are also shown the 6 words
that the address registers point to.  The status register flags are also shown
in this window, as is the program counter (which will be mainly used to make
the disassembly window open at the current instruction).

   Inside this window you can click on any register to set its value
(except register A7 which is unmodifiable).  When you click on a register
you will be asked to enter a value for it.  The value can be typed in as a
number or as a 4 character string, surrounded by quotes.  Thus the following
are allowed:

			$fff0
			12466
			%1001111111100000
			"CMAP"
			"ANHD"
@ENDNODE WIN_REGS

@NODE WIN_SOURCE "Source Window"
                               @{u}@{b}Source Window@{uu}@{ub}

   This window shows you the source code of the program currently being
traced.  Whilst it is active, you can use the cursor keys to move up and down
through your code.  The window can also be sized so that you can make as
much or as little of the source visible as you debug.  Note that you cannot
close this window - doing so causes the debugger to finish (after shutting
down the program being debugged).

   The current instruction (the instruction which will be executed next)
will be shown with a black square in front of it - unless you are moving
backwards through the history buffer.


                               @{b}@{u}Tokenisation@{ub}@{uu}

  Just like Ted (the Blitz2 source editor) the debugger can tokenise the
output of the source code window.  This allows you to easily identify the
different commands in your source code and makes the window contents a lot
clearer.  To enable source code tokenising just select the 'Tokenise' menu
item from the @{"'Project' menu" link MENUS}.


                                @{b}@{u}Free Memory@{ub}@{uu}

  The source code windows title is used to show the available memory in the
system.  The available chip memory and fast memory are both shown in the
title.
@ENDNODE WIN_SOURCE

@NODE WIN_MEM "Memory Windows"
                              @{u}@{b}Memory Windows@{uu}@{ub}

  These windows allow you to look through memory.  They are both identical in
that they show memory in both hex and ascii form, there are two so that you
can keep tabs on different addresses at the same time.  The windows are
split into three display areas:

		1) Address display
			This area shows an eight digit hex value which is
			the address of the data being displayed.

		2) Hex data display
			This is the contents of the memory, displayed in
			hex bytes (2 digits per byte of memory).

		3) ASCii data display
			This is the contents of the memory displayed as
			ASCii characters.

  Memory windows can be sized horizontally and vertically to allow you to
see more at once.  When the width or height of the windows changes the debugger
automatically calculates how much it can display inside the windows and adjusts
its contents accordingly.  You should note, though, that The debugger can only
display multiples of four bytes horizontally inside the windows.


                                 @{b}@{u}Movement@{ub}@{uu}

  The address range displayed in the memory windows can be changed using
the following methods:

	Up cursor:	Move backwards through memory.
	Down cursor:	Move forwards through memory.
	Left cursor:	Move 1 byte backwards through memory
	Right cursor:	Move 1 byte forwards through memory
	M:		Evaluate a Blitz command line then move to address.
	<SHIFT>-M:	Move to address generated by last EVAL.


                              @{b}@{u}Memory Editing@{ub}@{uu}

  You can edit the contents of the memory being displayed inside either
memory window.  Do this by activating the window whose contents you wish to
edit and press <SPACE> on the keyboard.  A cursor will then appear inside
the window - you can move this cursor around by using the cursor pad.

  Edit mode allows you to edit the memory displayed in either HEX or ASCii
mode - the location of the cursor decides what mode you are in.  To change
mode press the TAB key.  The cursor will then swap to the other display
area.  The display area you are in decides what characters can be typed by
you using the keyboard.  If you are in hex mode you can only uses the
numeric keys (0-9) and the letters A-F, if in ASCii any keys are allowed.
If you are in ASCii mode and want to actually use the TAB and SPACE keys to
write data to memory (e.g. to write a space character into a string) you
you should press and hold the CONTROL key and then press either TAB or
SPACE.


                           @{b}@{u}Memory Window Locking@{ub}@{uu}

  Memory windows can now be locked to an expression.  See @{" Locking " link NODElocking} for more
information.
@ENDNODE WIN_MEM

@NODE WIN_OBJECTS "Object Trace Windows"
                          @{u}@{b}Object Trace Window(s)@{uu}@{ub}

   These windows allow you to keep tabs on particular objects whilst your
program is being traced or single-stepped.  They hold the structure of an
object and will show you the objects items in the relevant format (e.g.
strings will appear as actual strings, not addresses).

   To open a window for a particular object type just select the relevant
type from the menu.  The object window will then open at the address of
object 0 for the type selected.  The contents of the window will be the
current settings of the object.  You can change the object number being
view by moving the slider located on the right hand side of the window, or
by pressing M and entering a string to be EVALuated and then moved to.

  More than one object window can be open at once, in fact upto 10 can be
open at once.  To open another object window, just select the new object
type from the Objects menu.  If any more object windows are available the
selected object type will be displayed otherwise you will be informed of
the lack of windows and asked to close a currently opened one.


                             @{u}@{b}Supported Objects@{uu}@{ub}

   The following Blitz2 objects are supported by the Red Debugger:

	Bitmap			Blitz2 bitmap object
	Blitzfont		Blitz2 8x8 font object
	Buffer			Blitz2 buffer object
	Coplist			Blitz2 copper list object (Blitz mode)
	File			Blitz2 file object
	GTList			Blitz2 Gadtools gadget list object
	GTMenuList		Blitz2 Gadtools menu list object
	Intuifont		Blitz2 intuition font object
	MapObj			Private RED Map Editor object
	Module			Blitz2 sound module object
	Palette			Blitz2 Palette object
	Queue			Blitz2 queue object
	Shape			Blitz2 shape object
	Slice			Blitz2 slice object (Blitz mode)
	Sound			Blitz2 sound object
	Sprite			Blitz2 sprite object
	Stencil			Blitz2 stencil object
	Tape			Blitz2 tape object
	Window			Blitz2 window object
@ENDNODE WIN_OBJECTS

@NODE WIN_VARS "Variable Trace Window"
                           @{u}@{b}Variable Trace Window@{uu}@{ub}

  This window allows you to trace different variables whilst your program is
running.  It has been completely fixed to work fine with all variable types
(strings now work all the time!).

   Add variables to the trace list by selecting the 'Add Trace...' menu item.
You'll be asked to enter the name of the variable to trace, then the type, and
then the output mode (if the variable is of type string).  Output mode for
strings allows you to select whether or not the string length and max
length is displayed.  Thus if you wanted a trace the word sized variable 'xpos'
in hex format you would enter the following into the requesters:


Variable name requester:	xpos		-- xpos is variable name

Variable type requester:	w		-- type is word

Since the variable is of type w (for word) no output requester will open.
The variable will be displayed in decimal inside the Variable Trace Window
by default.  To force the display to be in hex or binary you should prefix
the variable name with:

			$	to force hex display
			%	to force binary display

These steps can be shorted by entering a more complex value into the
'Variable name requester'.  This complex expression merges the two requesters
together.  Note that this 'quick' mode can not be used to select all output
options for strings.  For the example above you could have entered the
following into the 'Variable name requester':

		$xpos.w
		||   |
		||   Type of the variable, in this case w=Word
		||
		|Name of the variable
		|
		Outut format, $=hex, %=binary

Valid types to put after the variable name in the 'Variable name requester'
are:
			$		-- string type
			.s		-- string type
			.b		-- byte type
			.w		-- word type
			.l		-- long type
			.q		-- quick type
			.f		-- float type

Note that only the types b,w and l can be displayed in binary and hex.

  Variables can be added whilst the Variable Trace Window is closed, but you
must open it yourself before tracing will start.  Variables can also be added
directly by the program being traced by using the AddVarTrace library command
(see documentation for the RIDebug Library).

  If you desire the variables inside the Variable Trace Window can be
sorted into alphabetical order.  To do this just select the @{" Sort names " link MENUS}
menu option.

  Note that variables can only be added after they have been declared
inside the program being debugged.
@ENDNODE WIN_VARS

@NODE WIN_DISASM "680x0 Disassembly window"
                         @{u}@{b}680x0 Disassembly window@{uu}@{ub}

           *** Note that this window is not for novice users ***

   This window is for the users who have a knowledge of assembly language
and use it inside their programs (via inline assembly).  It can also be
used to set up breakpoints inside the basic code.  Using this window you
can watch your basic program executing and view the code being run - you
cannot, though, single step the actual assembly commands being executed.

   This window is split up vertically into 3 regions:


	1) Memory address display
		An eight digit, hex, memory address is displayed on the
		left hand side of the window.

	2) Status Indicator
		This area holds special information for the current
		address - the information is only shown if the instruction
		at the address is an actual Blitz Basic command.  The value
		in this area will be blank if the current address does not
		point to a Blitz2 instruction, otherwise the contents will
		be >>> unless a breakpoint is currently defined at the
		address.

		See @{" Breakpoints " link NODEbreakpoints} for more information.

	3) Disassembly display
		This area holds the actual disassembly of the data at the
		current address.  Note that if the address is the start of
		a Blitz basic command the actual command will be displayed
		in this window, otherwise the display will be 68000-68020
		disassembly.

		Note that if tokenisation is enabled, the Blitz command
		strings will be displayed tokenised.  See the @{" Source Window " link WIN_SOURCE}
		for information about how to disable/enable tokenisation.


                                 @{b}@{u}Movement@{ub}@{uu}

  The address range displayed in the display window can be changed using
the standard methods available in the debugger:

	Up cursor:	Move backwards through memory.
	Down cursor:	Move forwards through memory.
	M:		Evaluate a Blitz command line then move to address.
	<SHIFT>-M:	Move to address generated by last EVAL.


                              @{b}@{u}Window Locking@{ub}@{uu}

  This window can now be locked to an expression.  See @{" Locking " link NODElocking} for more
information.
@ENDNODE WIN_DISASM

@NODE WIN_COPPER "Copper Disassembly Window"
                         @{u}@{b}Copper Disassembly Window@{uu}@{ub}


   This window allows you to view a copper list held in memory.  The window
is split into two regions:

	1) Memory address display
		An eight digit, hex, memory address is displayed on the
		left hand side of the window.

	2) Copper instructions
		The copper instruction present at the address is shown to
		the right of the address display.  The instruction will
		match one of the following patterns:

			MOVE <$VALUE> <REGISTER>
			WAIT <$xx,$yy> MASK <$xx,$yy>
			SKIP <$xx,$yy> MASK <$xx,$yy>

		The WAIT and SKIP instructions will sometimes have [BFD]
		written after them.  If present, this means that the
		instruction has "blitter finish disable' on.


   A useful application of this window is to check on custom copperlist
code generated with the RICopperFXLib.  This can be done by using the
following sequence of events:

	1) Open a CopList object window by selecting the CopList menu item
	   inside the Objects menu.

	2) If the Copper Disassembly Window is not already open, open it
	   now.

	3) Press the 'm' key whilst the Copper Ðisassembly Window is
	   active.  This will open a requester asking you to enter the
	   address to move the window to.

	4) Into the requester type the a $ character, then enter the
	   address held inside the CopList window against field
	   'Custom'.  The $ needs to be typed because object window fields
	   are always displayed in hexadecimal.

The Copper Disassembly Window should now be pointing at your custom copper
instructions.  Note that you can also set this windows address from inside
your programs using the CopperTrace program inside the RIDebugLib library.


                                 @{b}@{u}Movement@{ub}@{uu}

  The address range displayed in the display window can be changed using
all the standard methods available in the debugger:

	Up cursor:	Move backwards through memory.
	Down cursor:	Move forwards through memory.
	M:		Evaluate a Blitz command line then move to address.
	<SHIFT>-M:	Move to address generated by last EVAL.
@ENDNODE WIN_COPPER

@NODE WIN_SEARCH "Search Memory Window"
                           @{u}@{b}Search Memory Window@{uu}@{ub}

   This window allows you to search through memory for values.  The values
you search for can by any of the Blitz Basic types, e.g. byte, word, string
etc.  The search requires four parameters before it can begin:


	Start Address:    Enter a start address into this gadget

	End address  :    Enter an end address into this gadget.  Searching
			  will stop when this address is reached.

	Search value :    Enter a value to search for into this requester.
			  The type of the value entered should match the type
			  being searched for.  E.g. if you are looking for
			  strings, the value in this gadget will be treated
			  as a string.

	Search type  :    Select the type to look for with this gadget.
			  Clicking on the gadget will cycle to the next
			  type available to search for.  The current type
			  is written to the right of this gadget.

	Start search :    After setting up your search parameters, click on
			  this gadget to begin the search.

Four extra gadgets exist in this window.  There are two named 'MEM 1' and
two named 'MEM 2'.  They are positioned to the right of the Start and End
address gadgets and allow quick setting of the addresses.  Clicking on
either of these 4 gadgets will cause the address gadget to the left of it
to be changed to hold the address of the memory window selected.
@ENDNODE WIN_SEARCH

@NODE WIN_ARRAY "Array Window"
                               @{u}@{b}Array Window@{uu}@{ub}

   This window allows you to view the contents of a 1 or 2 dimensional
array of bytes, words or longwords.  When you attempt to open this window,
you will be asked for an array name to open with.  You should type in the
name of your array, followed by how it is defined - meaning the limits of
its dimensions and the number of dimensions.

   For example, if you had dimensioned an array as follows:

		Dim myarray(10,20)

you would type the following into the requester:

		myarray(10,20)

After entering this information, you will be asked to select the type of
the array.  The type can be either b (byte), w (word) or l (longword).  The
REDDebugger will then look for the array and open the array window with its
contents if it was found.  The array will be displayed in hexadecimal
format with array indexes displayed across the top and down the left side
of the window.  There will also be sliders in the windows borders to allow
you to scroll the windows contents if the array is too big to display fully
in the window.

   For a one dimensional array the contents of the array will be displayed
vertically.  For a two dimensional array, the first dimension will be
displayed horizontally, the second vertically.
@ENDNODE WIN_ARRAY

@NODE WIN_STRUCTURES "Structure Windows"
                             @{u}@{b}Structure Windows@{uu}@{ub}

  These windows are mainly for use of people who do a lot of work with the
operating system and need access to the OS defined structures detailed in
the Amiga Include files.  Inside the includes is one big file called
'structure.offsets' which contains an entire list of all the structures.
This file gives a definition of every structure used by the OS - the
REDDebugger uses this file to open structure windows.  These structure
windows are almost the same as @{" Object Windows " link WIN_OBJECTS} the difference is though
that instead of tracing Blitz2 objects, the window is pointed by the user
of the debugger at a memory address.  The contents of the window then
become the structure overlaid onto the memory address specified.

  Note that to use the Structure Windows you require a valid
structure.offsets file - this file is not included with the REDDebugger as
it is a copyrighted file.  It must be obtained as part of the Amiga Include
files.

  The structure windows make it very easy to step through linked lists
(e.g. those used by the OS to hold gadget lists and window lists).  The
REDDebugger allows you to move a structure window by either pressing the M
key and entering an address or by just clicking on a field in the
structure.  When you click on the field, a requester will open asking you
if you wish to move to the address of the field, selecting YES will change
the window address.  In this way you can quickly step through linked lists
by just repeatedly clicking on the 'Next' field in the structure.

  The structure windows can be controlled by the user, allowing you to
define your own structures that you want to use and have the REDDEbugger
support.  See the section @{" Defining structures " link STRUCTURES} for more information
about how to define structures and what files to update.


                                 @{b}@{u}Movement@{ub}@{uu}

  The address range displayed in the display window can be changed using
the following two methods:

	M:		Evaluate a Blitz command line then move to address.
	<SHIFT>-M:	Move to address generated by last EVAL.
@ENDNODE WIN_STRUCTURES


@NODE WIN_CUSTOMCHIPS "Custom Chip Registers"
                           @{u}@{b}Custom Chip Registers@{uu}@{ub}

  This window allows you to easily fine the address of a custom chip and
vice versa, allows you to find the custom chip name that an address refers
to.

  The window contains two string requesters:

	Address$	Enter an address here.  NOTE that the number should
			be given in HEX.  The number can either be in the
			form of a full address (e.g. dff002) or just as an
			offset from $dff000 (e.g. 2).

	Name		The name of the custom chip.  Type a name in here
			to get the address of a custom chip register.
@ENDNODE WIN_CUSTOMCHIPS


@NODE WIN_LABELLIST "Label List Window"
                             @{u}@{b}Label List Window@{uu}@{ub}

   This window allows you to view the current Ted mouseable label list as
shown on the Ted screen.  The window will contain all defined labels that
are prefixed with a fullstop character (".").  This window can then be used
to make the other windows in the program 'jump' to a label in the source
code, do this by performing the following steps:


		1) Active the window you wish to move to the address of a
		   label (by clicking on it or cycling windows).

		2) Click on the desired label name in the Label List window.

   If there are two many label names to fit inside the window the scroll
bar down the right hand side of the window can be used to move down through
the list of labels.  The window can also be dragged out bigger is required.

   Note that these steps are the same as evaluating the address of a label
(using ?<LABELNAME>) and then moving a window to the address.


                              @{b}@{u}Important Note@{ub}@{uu}

   To use the Label List feature you must have installed by latest version
of the Blitz2 text editor Ted.
@ENDNODE WIN_LABELLIST

@NODE MENUS "Debugger Menus"
                              @{u}@{b}Debugger Menus@{uu}@{ub}

  Here is a the menu structure for the debugger, along with an explanation
of the items.

  [ITEM]		[KEY]	[DESCRIPTION]
<Project>
  Status Register		Display flags for the status register
  About debugger		Display program information
  About RWE			Display info about Red When Excited
  Keyboard shortcuts		Display keyboard shortcut information
  ---------------------
  Save configuration	W	Saves out the current debugger setup,
				including screen info, window positions
				and window status (open/closed & size)
				See @{" Configuration Saving " link NODEconfiguration} for more information
  Screen mode        >>		Allows control over @{" screen mode " link NODEscrmode}
  Window height...		Allows selection of maximum window height		
    Tokenise			Controls tokenisation inside the Source and
				Disassembly windows.
  ---------------------
  Quit				End the debugger and the program being
				debugged
  Quit & Die			End the debugger - leaving debug process
				active (ONLY USE AFTER A DEBUG PROCESS
				CRASH!)

  [ITEM]		[KEY]	[DESCRIPTION]
<Windows>
  REGS			D	Toggle the @{" Register Window " link WIN_REGS} (open/closed)
  MEM1			M	Toggle @{" Memory Window " link WIN_MEM} 1 (open/closed)
  MEM2			N	Toggle @{" Memory Window " link WIN_MEM} 2 (open/closed)
  VAR			V	Toggle the @{" Variable Trace Window " link WIN_VARS} (open/closed)
  ASM			6	Toggle the @{" 680x0 Disassembly window " link WIN_DISASM} (open/closed)
  COP			C	Toggle the @{" Copper Disassembly Window " link WIN_COPPER} (open/closed)
  GS                            Toggle @{" Gosub Stepping " link NODEgosubstep} on/off
  PS			P	Toggle @{" Procedure Control " link NODEproccontrol} on/off
  BC			B	Toggle @{" Blitz Mode Control " link NODEblitzcontrol} ON/OFF
  ---------------------
  Search Memory		S	Open the memory search window
  Array window...	R	Open the array window (with prompt for
				array to open as)
  Structure...		T	Open an object window as a structure.
				You will be prompted for the name of
				structure to find.
  Custom chips...		Open/Close the custom chip window
  Label list...			Open/Close the label list window

  [ITEM]		[KEY]	[DESCRIPTION]
<Object>
  <Object name>			Open the selected object inside a window

  [ITEM]		[KEY]	[DESCRIPTION]
<Misc>
  Add Trace...		A	Add a variable trace
  Del Trace...			Delete a variable trace
  Del All...			Delete all traces
  Sort names			Sort all variable traces into alphabetical
				order
  ---------------------
    Auto EVAL			Enable AutoEVAL feature
  Define			Enter a string to EVALuate after every
				line of code is stepped.
				See @{" AutoEVAL " link NODEautoeval} for more information
  ---------------------
  Add breakpoint...	[	Add a breakpoint
  Delete...		]	Delete a breakpoint
  Delete All...			Delete all breakpoints
  List...			List all current breakpoints
				See @{" AutoEVAL " link NODEbreakpoints} for more information
@ENDNODE MENUS

@NODE STRUCTURES "Defining Structures"
                            @{u}@{b}Defining Structures@{uu}@{ub}

  The REDDebugger's structure windows allow you to use your own custom
structures within them, as well as the OS structures held inside the
structure.offsets file.  Your structures should be placed inside a file
in the Blitz2:dbug folder and should be defined as follows:

MYStructure:				--- name of structure followed by a ':'
  $0024    36  sizeof(MYStructure)	--- must be byte size of structure!
  $0000     0     4  pointer		--- first item in structure
  $0004     4     4  another		--- next item
  |         |     |  |
  |         |     |  Name of this item
  |         |     |
  |         |     Decimal byte size of this item
  |         |
  |         Decimal offset from start of structure for this item
  |
  Hex offset from the start of the structure for this item


As an example I'll show a conversion of the following Blitz2 newtype:

	Newtype.Coordinates
		x.w
		y.w
	End Newtype

converts to:

Coordinates:
  $0004    4   sizeof(Coordinates)
  $0000    0      2  x
  $0002    2      2  y

Note that the field character positions are important - the hex string must
start at character 2 (zero relative).  The other fields must start as given
in this example, e.g.

	Decimal offset:		right aligned at character 12
	Size:			right aligned at character 19
	Name:			left aligned at character 22


                           @{b}@{u}Using The Structures@{ub}@{uu}

  Before you can use your structures you need to run the MakeOffsets
program.  This program auto-generates an extra file required by the
REDDebugger.  This file holds information about all your structure files
(including the structure.offsets file).  You do not need to know about the
structure of this second file.  When you run MakeOffsets it will open
a file requester asking you to select a structure file to use.  It will
then parse this file, when finished it will ask you to select another file.
If required do this, otherwise selecting cancel from the file requester
exits the program.


			@{" Load MakeOffsets Program " system "run >NIL: Blitz2:RedHelp/ShowExample FILE=Blitz2:RedHelp/REDDebugger/MakeOffsets.bb"}


  Now you can use your structures - just simply select the 'Structure...'
menu item and enter your structure name into the string requester that
opens.  A structure window will then open up with your structure.
@ENDNODE STRUCTURE

@NODE NODEscrmode "Screen Mode Selection"
                           @{u}@{b}Screen Mode Selection@{uu}@{ub}

  The REDDebugger supports control of its screen mode by the user.  You
have three options with regards to screen mode:

   'Workbench'		- select to open directly onto the Workbench
			  screen.  This saves memory and is more
			  convenient if the program being debugged opens
			  on Workbench itself.

   'Like Workbench'	- the REDDebugger opens up a screen that matchs the
			  display mode, width and height of your Workbench
			  screen.  The depth is always set to 2 bitplanes
			  (4 colours).

   'Custom'		- the REDDebugger opens with a screen mode that you
			  select.  The screenmode is selected by choosing
			  the 'Select Custom...' menu item.

   'Default public'	- the REDDebugger opens up on the current default
			  public screen.  Using this function and SuperTED
			  2.5's Default Public Screen mode you can make the
			  REDDebugger open on SuperTED's screen.

  If your screen mode is 'Like Workbench' or 'Custom' you can decide
whether or not to make the screen a public screen.  Making a screen public
is a OS legal way of telling other programs that they can open their own
windows on the REDDebugger's screen.  You can also select whether or not
the REDDebuggers screen should be the default public screen.  To make the
REDDebugger's screen the default public screen you must specify that the
REDebugger's screen should be a public screen.

  After changing the screen mode you ***MUST*** save your configuration,
otherwise your changes will be lost.  Changes do not come into effect until
the debugger is opened again.  Note that the minimum allowable screen size
is 640x200.

  As an extra for those users with lovely multisync monitors, you can now
specify the maximum height of the debuggers windows.  This option allows
you to change the internal buffer that the debugger keeps to allow fast
printing and window updating - the bigger the height, the more chip mem this
buffer will take up.  The minimum height of the buffer is 200 pixels, the
maximum is 1024 pixels.
@ENDNODE NODEscrmode

@NODE NODElocking "Locking"
                                  @{u}@{b}Locking@{uu}@{ub}

  It is possible to lock the certain windows to an expression.  This
expression is made up of numeric values and register names.  You CANNOT
lock windows onto a variables value.  The debugger uses a complex
expression evaluater, which can except the following tokens:

  Note that float values cannot be used.  You can use parenthesis
(brackets) to group arguments together.

		$	- The following number is hexadecimal
		%	- The following number is binary
		+	- Add two operands
		-	- Subtract two operands
		*	- Multiple two operands
		/	- Divide two operands
		=	- Test for equality between operands
		<	- Test for less than
		>	- Test for greater than
		^	- Power operation
		&	- Logically AND two operands
		|	- Logically OR two operands
		{}	- The absolute decimal number inside the curly
			  brackets is an address to read a value from.
			  The value defaults to a longword in size but
			  can be changed by using a '.W' or '.B' extension
			  on the close curly bracket.

This function will mainly be useful for assembly programmers since it
allows you to trace code and have a window continuously pointing to a value
held in a register.

The disassembly window can use this function to 'lock' onto the current
instruction by setting the lock for the window to 'PC-2'.  'PC-2' will
evaluate to the address of the current instruction minus two bytes.

You could lock a memory window to the value of a variable by first
EVALuating its address and then locking a memory window to the address
surrounded by curly brackets.

		E.g. if the address of 'ad.l' is 2000, you could use:

				{2000}.l

		to lock a memory window to the address 'ad.l' points to.
@ENDNODE NODElocking

@NODE NODEbreakpoints "Breakpoints"
                                @{u}@{b}Breakpoints@{uu}@{ub}

  For those of you not familiar with MonAm, breakpoints are a way of
stopping your program when a certain instruction is executed.  They are
equivalent to a STOP instruction placed in your source code.

  Breakpoints are set up via the Disassembly window.   To set up a
breakpoint on an instruction you just have to click on the basic line of
code inside the disassembly window.

  The debugger allows you to set up 4 different types of breakpoint on your
code:


	Countdown:	these breakpoints have a counter which says how
			many times they can be passed before the program
			is stopped.  Thus you can have a breakpoint stop
			you program after a specific line of code has
			executed a specific number of times.
			After the counter has reached 0 the breakpoint
			will be cleared.
			The counter can have a value from 1 to 65535.

	Simple:		these breakpoints stop your program when
			encountered.  They are essentially countdown
			breakpoints with a counter of 1.


	Permanent:	these always stop your program when they are
			reached.  They are not though cleared when your
			program is stoped by them.

	Counter:	these don't actually stop your program, instead
			they just count how many times your program went
			passed them.

Breakpoints are displayed in the disassembly window in the following way:

	Countdown:	[xxxx]	<Source code>
	Simple:		[01]	<Source code>
	Permanent:	[*]	<Source code>
	Counter:	[=xxxx]	<Source code>

These displays replace the standard '>>>' which precedes a basic
instruction in the disassembly window.  Breakpoints can only be set up on
basic instructions - they cannot be setup on the assembly code of basic
instructions.

The debugger allows you to set up upto 5 different breakpoints inside your
program.  Each breakpoint *must* be set at an unique address.  You should
note that breakpoints slow your program down slightly - have as few as
possible going at once if you want maximum speed.
@ENDNODE NODEbreakpoints

@NODE NODEautoeval "AutoEVAL"
                                 @{u}@{b}AutoEVAL@{uu}@{ub}

  The EVAL button in the debugger allows you to evaluate any variables,
find label addresses etc.  AutoEVAL takes this a step further and allows
you to enter a line that will be evaluated after *EVERY* instruction is
single stepped (using the STEP gadget).  To enter a line to AutoEVAL just
select the menu option, when a non-null string is entered, the AutoEVAL
will be enabled and will display its output after every step at the bottom
of the source window.
  An example of how this can be used is to evaluate an expression like
mymap(x,y) after every instruction is stepped.  This can be used to easily
keep track of what your program is doing.  The output of AutoEVAL for this
example instruction will look like this:

	mymap(x,y)=50

You can only AutoEVAL one line at a time.  Also, you should note that the
AutoEVAL does degrade the speed of your program, since the EVAL command
itself is slow.
  Remove the AutoEVAL by selecting the menu option and clearing the command
string.
@ENDNODE NODEautoeval

@NODE NODEproccontrol "Procedure Control"
                             @{u}@{b}Procedure Control@{uu}@{ub}

  This function allows you to skip over procedures as if they were single
instructions when either STEPing or TRACEing your program.  When running,
this function has no effect.  When you use this function, the procedure
runs exactly the same except that it no longer causes the debugger to
update its windows whilst it is executing.
  In effect, what this function does it to, at the start of a procedure,
which the debugger into RUN mode, and then at the end return it to its
previous mode.
@ENDNODE NODEproccontrol

@NODE NODEblitzcontrol "Blitz Mode Control"
                            @{u}@{b}Blitz Mode Control@{uu}@{ub}

  This function is for all those people who're getting annoyed at the
debugger constantly rebuilding the blitz mode display every time they step
an instruction or evaluate an expression.  With this function on, singular
calls to the debugger like evaluating and execing no longer cause Blitz to
redraw the display.
  To understand this you have to have a little knowledge of what blitz does
when it goes into blitz mode.  When blitz mode is activated, Blitz disables
multitasking, sets up a custom copperlist and owns the blitter.  What this
function does is to stop blitz setting a custom copperlist.  The program
being debugged *IS* in blitz mode, it just doesn't have the display.  This
may not be useful at times (for when you need, for example, to check to see
where a blit is occuring) - you must decide yourself when and where to
enable/disable it (default is disabled).  That said, this function is very
useful, since it stops all flashing, including flashes for opening object
windows etc.
@ENDNODE NODEblitzcontrol

@NODE NODEgosubstep "Gosub Stepping"
                              @{u}@{b}Gosub Stepping@{uu}@{ub}

  The debugger now allows you to step over calls to subroutines via the
GOSUB instruction as if they were a single instruction.  Control of this
mode of operation is via the 'GS' gadget/menuitem.  If on, STEPping a gosub
command will cause the debugger to run the program being debugged until the
subroutine RETURNS back to the calling routine.

  Note that if you step a subroutine whilst in blitz mode, the blitz mode
display is redrawn - even if you have Blitz Control on (via the BC
gadget/menuitem).  Also note that with this function on, you can only step
one line of code at a time - you cannot use the multiple step feature to
step more than one instruction.


                         @{b}@{u}How Gosub Stepping Works@{ub}@{uu}

  Gosub stepping works by putting a breakpoint after the gosub instruction.
When you perform a step on a Gosub instruction the Debugger recognises
whats happening a places a breakpoint.  A side effect of this is that if
the program stops whilst Gosub Stepping is active the return address is
always remembered - since it is set up as a breakpoint.  Thus when
execution resumes the program will still stop on return from the Gosub.

@ENDNODE NODEgosubstep

@NODE NODEconfiguration "Configuration Saving"
                           @{u}@{b}Configuration Saving@{uu}@{ub}

  A default configuration can be saved from the REDDebugger by selecting
the 'Save Configuration' menu item on the 'Project' menu.  When you select
this option the REDDebugger will attempt to save its current configuration
to ENV: and ENVARC:, you should make sure that both of these volumes are
available.

  The Debugger saves information relating to current open windows and their
positions into the configuration file.  Thus you can customise how the
Debugger looks on your machine.  A lot more data, though, is also saved:

	1) Screen Information
		The current screen mode is saved, along with screen width
		and height if the current mode is CUSTOM.
		See @{" Screen Mode " link NODEscrmode} for information about screen modes.

	2) Tokenisation
		The current state of tokenisation inside the Source and
		DisAssembly windows is saved.

	3) Max Window Height
		The maximum window height is save into the configuration
		file.  This value determines the size of the REDDebugger's
		window redraw buffer.
		See @{" Screen Mode " link NODEscrmode} for information about window heights.

	4) Window states
		For each main debugger window (excluding Object/Structure
		windows) the window status (open/closed), position and size.
		are saved.

	5) Status of procedure stepping.
		On/Off will be written to the configuration file.
		See @{" Procedure Control " link NODEproccontrol} for information about Procedure stepping.

	6) Status of blitz mode control
		On/Off will be written to the configuration file.
		See @{" Blitz Mode Control " link NODEblitzcontrol} for information about blitz mode control.

	6) Status of gosub stepping
		On/Off will be written to the configuration file.
		See @{" Gosub Stepping " link NODEgosubstep} for information about gosub stepping.


                         @{b}@{u}Reading The Configuration@{ub}@{uu}

  When the debugger gets a debug request from Blitz2 it will look for the
volume ENV: for a preferences file.  If it finds the preferences file and
the version level of the preferences file is correct it will load it in and
use it as its current configuration.  If the Debugger does not find this
file, or the version level is incorrect, default settings will be used for
all configuration options.  Note that no requesters will be displayed if
the Debugger cannot find this file.
@ENDNODE NODEconfiguration

@NODE COMMS "Communications"
                              @{u}@{b}Communications@{uu}@{ub}

  The debugger has a communications channel that can be made use of by the
Blitz program it is currently debugging.  This channel is invoked in one of
two ways, depending on the situation:

	AlibJsr $d509	- if the code is inside of a Blitz library

	TokeJsr $d509   - if the code is inside a Blitz program

*** NOTE *** Multitasking must be enabled before you call this channel - do
not call it in Blitz mode.

This input channel expects register a0 to point to a data array, laid out
in the following format:

	+0		Command number
	+1		Data byte 1
	+2		Data byte 2
	+3		pad
	+4		Data longword 1
	+8...255	String area

  Valid commands at the moment, and the parameters they expect are:

addtrace:	Add a variable trace

		Command number =255
		Data byte 1    =variable type (debugger format)
		Data byte 2    =output preferences
		Data longword 1=address of variable
		String area    =string to display in variable window

   NOTE: This command could be used to trace internal variables inside
libraries.  E.g. setting up a trace on an important 'dc.l'ed variable.


deltrace:	Delete a variable trace
 
		Command number =254
		String area    =name of trace to kill


varwindow:	Open the variable trace window

		Command number =253


diswindow:	Open the disassembly window at an address

		Command number =252
		Data longword 1=address to open at


copperlist:	Open the copper disassembly window at an address
		Command number =251
		Data longword 1=address to open at


proccontrol:	Toggle procedure control
		Command number =250
		Data byte 1    = -1 for ON, 0 for OFF (OPTIONAL
		Data byte 2    =Mode select:

				-1=Data byte 1 holds new mode
				 0=Toggle current mode


memwindowmove
		Command number =249
		Data longword 1=address to move to


  It may in the future be possible for the user to add their own
functions to this channel by implemation of external debug modules for the
debugger
@ENDNODE COMMS

@NODE RWE "Red When Excited"
                           @{u}@{b}Red When Excited@{uu}@{ub}

  This program is part of the Red When Excited Blitz Support Suite.

Red When Excited are:

			Steven Matty
			Stephen McNamara
			Nigel Hughes
			Steven Innell
			Mike Richards
			Mark Tiffany

Email to the blitz-list is a good way of getting our attention if anyone
needs to contact us OR see the main Support Suite docs for details of other
ways to contact us.
@ENDNODE

@NODE CREDITS "RED Debugger v2.5 - Credits"
                             @{u}@{b}RED Debugger v2.5@{uu}@{ub}

                        Written by Stephen McNamara
                                    of
                             Red When Excited

                           Original debugger by
                        Mark Sibly of Acid Software

                               Release Date:
                                 16/05/1996

                               Documentation
                             Stephen McNamara


                         @{u}@{b}Thanx go to the following@{uu}@{ub}

                      OS2.0/68000 testing and fixing:
                                 Son H. Le

                      Suppling the disassembler code:
                      Simon Armstrong (Acid software)

                            Help and criticism:
                               Steven Matty
                               Steven Innell
                  And loads of chappies on the Blitz-list

                       For feedback and bug reports:
                                 Son H. Le
                               Rupert Henson
                     And the others I've forgotten :)

                             Quick hello's to:
               Martin 'it doesn't work with StarWoids' Kift
                         Jurgen 'AmigaGuide' Valks
                       Mark 'Virtual Worlds' Tiffany
                          Nigel 'Cascade' Hughes
                     And everyone on #amiga/Blitz-list
@ENDNODE THANX

@NODE demo1 "Demo 1 - Blitz Control"
                          @{b}@{u}Demo 1 - Blitz Control@{ub}@{uu}

This program demonstrates using the RED Debugger's Blitz Control feature.
The program will ask you to toggle the Blitz Control gadget yourself (see
@{" Program Control Window " link WIN_PROGCNTRL}) and see what effect it has on a test program
running in Blitz mode.

See @{" Blitz Mode Control " link NODEblitzcontrol} for more information about Blitz Control.

The source code for this program can be found in the RedHelp/REDDebugger
folder as Demo2.

			@{" View Demo 1 Source Code " system "run >NIL: Blitz2:RedHelp/ShowExample FILE=Blitz2:RedHelp/REDDebugger/Test_BlitzControl.bb"}
@ENDNODE demo1

@NODE demo2 "Demo 2 - Procedure Control"
                        @{b}@{u}Demo 2 - Procedure Control@{ub}@{uu}

This program demonstrates using the RED Debuggers Procedure Control feature.
Running the source code will present you with the Debugger screen, from
where you can single step the program, seeing the effect the Procedure
Control feature has on the program being stepped.

See @{" Procedure Control " link NODEproccontrol} for more information about Procedure Control.

The source code for this program can be found in the RedHelp/REDDebugger
folder as Test_ProcControl.

			@{" View Demo 2 Source Code " system "run >NIL: Blitz2:RedHelp/ShowExample FILE=Blitz2:RedHelp/REDDebugger/Test_ProcControl.bb"}
@ENDNODE demo2

@NODE demo3 "Demo 3 - Copper Trace"
                           @{b}@{u}Demo 3 - Copper Trace@{ub}@{uu}

                     ***** This Demo is AGA Only *****

This program demonstrates using the RED Debuggers copper tracing abilities
to debug copper list code.  Running it will generate a custom copperlist
and then open the Debuggers @{" Copper DisAsm Window " link WIN_COPPER}.  You can then view
the actual copper instructions created by the program.  The program will
stop after setting the up the copper list, you can then view the copper
instructions, or RUN the program to see the finished effect.

On non AGA machines this program may produce unpredictable results - it is
not recommended that it be run.

The source code for this program can be found in the RedHelp/REDDebugger
folder as Test_CopperTrace.

			@{" View Demo 3 Source Code " system "run >NIL: Blitz2:RedHelp/ShowExample FILE=Blitz2:RedHelp/REDDebugger/Test_CopperTrace.bb"}
@ENDNODE demo3

@NODE demo4 "Demo 4 - Variable Trace"
                          @{b}@{u}Demo 4 - Variable Trace@{ub}@{uu}

This demo program simply demonstrates opening the RED Debuggers
@{" Variable Trace Window " link WIN_VARS} and adding variables to the list of variables
currently be traced.

The source code for this program can be found in the RedHelp/REDDebugger
folder as Test_VarTrace.

			@{" View Demo 4 Source Code " system "run >NIL: Blitz2:RedHelp/ShowExample FILE=Blitz2:RedHelp/REDDebugger/Test_VarTrace.bb"}
@ENDNODE demo4

@NODE onlinehelp "Context Sensitive Help"
                          @{b}@{u}Context Sensitive Help@{ub}@{uu}

The RED Debugger has a help system built in.  This help system allows you
to get immediate help for all of the menu items and the windows inside the
RED Debugger.  Note that the help system requires RexxMast to be running
BEFORE the debugger is itself run.  If you wish to use the help system you
should consider adding the line

		sys:System/RexxMast >NIL:

to your user-startup file.  This way RexxMast will always be running and
the online help system will always be available.


                          @{b}@{u}How To Invoke Menu Help@{ub}@{uu}

To get help on any menu item, follow the following steps:


		1. Hold the right mouse button down to show the menu titles
		   at the top of the screen.

		2. Whilst holding the right mouse button, move to the menu
		   item you require help for.

		3. Whilst holding the right mouse button, press the HELP
		   key.

		4. Release the right mouse button.

The RED Debugger AmigaGuide file will now open up on your Workbench
screen at the correct location for the menu item.  If help is no
appropriate for the menu item you selected, nothing will happen.


                         @{b}@{u}How To Invoke Window Help@{ub}@{uu}

To get help on a window just press the HELP key whilst the window is
active.  Note that there must be no gadgets activated when you press HELP
(e.g. the cursor cannot be within a string gadget).

The RED Debugger AmigaGuide file will now open up on your Workbench
screen at the correct location for the menu item.  If help is no
appropriate for the window you selected, nothing will happen.


                                @{b}@{u}Help Screen@{ub}@{uu}

By default the help window for REDDebugger opens up on your Workbench
screen.  If, though, your current REDDebugger screen is public, the
help window will open up on it instead of the Workbench screen.
@ENDNODE RED_onelinehelp

@NODE CUSTOMMENU "The Custom Menu"

                                @{b}@{u}Custom Menu@{ub}@{uu}

REDDebugger allows the programmer to add their own menu items to a specially
created menu called the 'Custom Menu'. This menu is maintained by using the
supplied @{"Menu Editor" link /Tools/MenuED.Guide/MAIN}. Please read the supplied documentation for instructions
on its usage.

The following formating strings can be used inside the command strings for
the custom menu items:

	%f	The filename of the current program being debugged.
	%d	The directory the current program is in.
	%F	The full pathname of the current program.
	%c	The token list for this version of Blitz2.
	%p	The public screen name for REDDebugger, nothing is returned
		if the REDDebugger's screen is not public.
	%s	The program name - REDDebugger.

An example command line that uses two of these options is:

	run Blitz2:dbug/TokenList %p %c

This line runs the program TokenList with two parameters:

	%p	is replaced with the public screen name
	%c	is replaced with the address of Blitz2's token list.
@ENDNODE CUSTOMMENU
