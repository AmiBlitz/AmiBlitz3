@DATABASE SYSTEM1
@Author Conversion program
@$VER: SYSTEM1LIB V1.3 (28.02.2007)- Updated by mrodfr.
@NODE OVERVIEW "Overview of SYSTEM1"

                                  @{b}@{u}Overview@{ub}@{uu}


                          An Acid Software Library

                         Converted to AmigaGuide by

                            Red When Excited Ltd

                 Used with the permission of Acid Software

          Edited, fixed and cleaned by Toby Zuijdveld 27/02/1999.
                       mailto:hotcakes\@abacus.net.au



@ENDNODE OVERVIEW

@node SYNTAX "Syntax"
SYNTAX 0 old SYNTAX without declare Check
SYNTAX 1 all vars need declare with deftype (same as C)
SYNTAX 2 you can declare vars also with a.typ= definieren
SYNTAX 4 Typecheck.If a longword move to word is error here
         If you are sure you can add a @ before

a.w=b.l is Error

a.w=b.l is ok

Is same as CAST in C

a=(short)b
@endnode

@NODE NEWTYPE "SYSTEM1"

@{fg shine}Statement: NEWTYPE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : NEWTYPE .Typename

NEWTYPE is used to create a custom variable type. NEWTYPE must be 
followed by a list of entry names separated by colons (':') and/or 
newlines. NEWTYPEs are terminated using End NEWTYPE.

Newtype .person
name$
age.b
height.f
x.w:y:z
name2.s
adress.s[4]
*exec.ExecBase ;a pointer to execbase
End Newtype

a.person\name="harry",20,1.8    ; define a as type person
a\adress[0]="New Zealand"

Note: DONT write a.person\name$

Another definition

deftype .person a

a\age=20

a\adress[0]="New Zealand"
a\adress[1]="Auckland"
a\exec=peek.l(4) ;set the pointer to addr of execbase
a\exec\ColdCapture=mycoldcapture

@ENDNODE NEWTYPE

@NODE End "SYSTEM1"

@{fg shine}Statement: End@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : End [If|While|Select|Statement|Function|SetInt|SetErr|NEWTYPE|Macro]

End will halt program flow completely. In the case of programs run from 
the Blitz 2 editor, you will be returned to the editor. In the case of 
executable files, you will be returned to the Workbench or CLI.

End is often also useful to prevent program flow from running into a 
subroutine.


@ENDNODE End

@NODE Let "SYSTEM1"

@{fg shine}Statement: Let@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Let Var=|Operator Expression


@ENDNODE Let

@NODE Dim "SYSTEM1"

@{fg shine}Statement: Dim@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Dim Arrayname [List] (Dimension1[,Dimension2..])

Dim is used to initialize a BASIC array. Blitz 2 supports 2 array types - 
simple arrays, and list arrays. The optional List parameter, if 
present, denotes a list array. Simple arrays are identical to standard 
BASIC arrays, and may be of any number dimensions. List arrays may be 
of only 1 dimension.

Lists are covered fully in the Blitz 2 programmers guide, under the 
programming section.


@ENDNODE Dim

@NODE Goto "SYSTEM1"

@{fg shine}Statement: Goto@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Goto Program Label

Goto causes program flow to be transferred to the specified program 
label. This allows sections of a program to be 'skipped' or 
'repeated'.


@ENDNODE Goto

@NODE Gosub "SYSTEM1"

@{fg shine}Statement: Gosub@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Gosub Program Label

Gosub operates in two steps. First, the location of the instruction 
following the Gosub is remembered in a special storage area (known as 
the 'stack'). Secondly, program flow is transferred to the specified 
Program Label.

The section of program that program flow is transferred to is known as 
a 'subroutine' and is usually terminated by a Return command. The 
Return command has the effect of returning program flow to the location 
remembered by the previous Gosub command. 

This allows a section of a program to be used by many other parts of 
the same program.


@ENDNODE Gosub

@NODE Return "SYSTEM1"

@{fg shine}Statement: Return@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Return 

Return is used to return program flow to the instruction following the 
previously executed Gosub command. This allows the creation of 
'subroutines' which may be called from various points in a 
program.


@ENDNODE Return

@NODE Statement "SYSTEM1"

@{fg shine}Statement: Statement@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Statement Procedurename{[Parameter1[,Parameter2...]]}

Statement declares all following code up to the next End Statement as 
being a 'statement type' procedure.

Up to 6 Parameters may be passed to a statement in the form of local 
variables through which calling parameters are passed.

In Blitz 2, all statements and functions must be declared before they 
are called.

With statement return
you can leave a statement early

The Keyword FAST (statement/function FAST {.....)
disable the autoclear vars to zero.This can not used with strings
(only with stringpointers)
and you also make sure that like in C set the var manually to usefull
values

@ENDNODE Statement

@NODE Function "SYSTEM1"

Statement: Function
--------------------------------------------------------------------------------
Modes  : 
Syntax : Function [.Type] Procedurename{[Parameter1[,Parameter2...]]}

Function declares all following code up to the next End Function as 
being a function type procedure.
The optional Type parameter may be used to determine what type of 
result is returned by the function. Type, if specified, must be one 
Blitz 2's 6 primitive variable types. If no Type is given, the current 
default type is used.

Up to 6 Parameters may be passed to a function in the form of local 
variables through which calling parameters are passed.

Functions may return values through the Function Return command.

In Blitz 2, all statements and functions must be declared before they 
are called.


@ENDNODE Function

@NODE MouseWait "SYSTEM1"

@{fg shine}Statement: MouseWait@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : MouseWait 

MouseWait simply halts program flow until the left mouse button is 
pushed. If the left mouse button is already held down when a MouseWait 
is executed, program flow will simply continue through.

This is often useful in Blitz 2 to prevent a program from terminating 
too quickly and leaving you back in the editor.

MouseWait should normally be used only for program testing purposes, as 
MouseWait severely slows down multi-tasking.


@ENDNODE MouseWait

@NODE If "SYSTEM1"

@{fg shine}Statement: If@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : If Expression [Then...]



@ENDNODE If

@NODE While "SYSTEM1"

@{fg shine}Statement: While@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : While Expression

The While command is used to execute a series of commands repeatedly 
while the specified Expression proves to be true. The commands to be 
executed include all the commands following the While until the next 
matching Wend.

Example:

While a<20
a=a+1
Wend

@ENDNODE While

@NODE Macro "SYSTEM1"

@{fg shine}Statement: Macro@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Macro Macroname

Macro is used to declare the start of a macro definition. All text 
following Macro, up until the next End Macro, will be included in the 
macro's contents.

Example:
Macro distance
Sqr(`1*`1+`2*`2)
End Macro

Nprint !Distance {20,30}

`0 is the number of parameter count

Macro twopars
cnif `0=2
 `1=`1+`2
celse
   cerr "Wrong parameter number"
cend
End Macro

If you need Labels in macros use this

label`@

are usefull if you want labels in macros to avoid double labels




Please refer to the Programming chapter of the Blitz 2 Programmers 
Guide for more information on macros.


@ENDNODE Macro

@NODE Select "SYSTEM1"

@{fg shine}Statement: Select@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Select Expression

Select Expression
  Case 1
;execute this if expression evaluated to 1
  Case 2
;execute this if expression evaluated to 2
.
.may have many more 'Case's...
.
  Default
;execute this if expression did not match any of the cases.
End Select


@ENDNODE Select

@NODE Case "SYSTEM1"

@{fg shine}Statement: Case@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Case Expression

A Case is used following a Select to execute a section of program code 
when, and only when, the Expression specified in the Case statement is 
equivalent to the Expression specified in the Select statement.

If a Case statement is satisfied, program flow will continue until the 
next Case, Default or End Select statement is encountered, at which 
point program flow will branch to the next matching End Select.


@ENDNODE Case

@NODE Default "SYSTEM1"

@{fg shine}Statement: Default@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Default 

A Default statement may appear following a series of Case statements 
to cause a section of program code to be executed if NONE of the Case 
statements were satisfied.


@ENDNODE Default

@NODE AsmExit "SYSTEM1"

@{fg shine}Statement: AsmExit@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : AsmExit 

AsmExit is used to exit from functions and statements written in assembler.
Remember also that registers A4-A6 must be preserved in functions and
statements written in assembler.


@ENDNODE AsmExit

@NODE XINCLUDE "SYSTEM1"

@{fg shine}Statement: XINCLUDE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : XINCLUDE Filename

XINCLUDE stands for exclusive include. XINCLUDE works identically to 
INCLUDE with the exception that XINCLUDE'd files are only ever included 
once. For example, if a program has 2 XINCLUDE statements with the same 
filename, only the first XINCLUDE will have any effect.

INCDIR may be used to specify a path for Filename.

Filename may be optionally quote enclosed to avoid tokenisation 
problems.


@ENDNODE XINCLUDE

@NODE INCLUDE "SYSTEM1"

@{fg shine}Statement: INCLUDE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : INCLUDE Filename

INCLUDE is a compile time directive which causes the specified file, 
Filename, to be compiled as part of the programs object code. The file 
must be in tokenised form (ie: saved from the Blitz 2 editor) - ascii 
files may not be INCLUDE'd.

INCDIR may be used to specify a path for Filename.

Filename may be optionally quote enclosed to avoid tokenisation 
problems.



@ENDNODE INCLUDE

@NODE Jimi  "SYSTEM1"

@{fg shine}Statement: Jimi @{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Jimi  ;Unless



@ENDNODE Jimi 

@NODE SHARED "SYSTEM1"

@{fg shine}Statement: SHARED@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : SHARED Var[,Var...]

Shared is used to declare certain variables within a procedure 
definition as being global variables. Any variables appearing within a 
procedure definition that do not appear in a Shared statement are, by 
default, local variables.


@ENDNODE SHARED

@NODE For "SYSTEM1"

@{fg shine}Statement: For@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : For Var=Expression1 To Expression2 [Step Expression3]

The For statement initializes a For...Next loop. All For/Next loops 
must begin with a For statement, and must have a terminating Next 
statement further down the program. For/Next loops cause a particular 
section of code to be repeated a certain number of times. The For 
statement does most of the work in a For/Next loop. When For is 
executed, the variable specified by Var (known as the index variable) 
will be set to the value Expression1. After this, the actual loop 
commences.

At the beginning of the loop, a check is made to see if the value of 
Var has exceeded Expression2. If so, program flow will branch to the 
command following the For/Next loop's Next, ending the loop. If not, 
program flow continues on until the loop's Next is reached. At this 
point, the value specified in Expression3 (the 'step' value) is added 
to Var, and program flow is sent back to the top of the loop, where Var 
is again checked against Expression2. If Expression3 is omitted, a 
default step value of 1 will be used.

An interesting feature of For/Next loops is the ability to use the 
loop's index variable within the loop.
In order for a For/Next loop to count 'down' from one value to a lower 
value, a negative step number must be supplied.


@ENDNODE For

@NODE Next "SYSTEM1"

@{fg shine}Statement: Next@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Next [Var[,Var...]]

Next terminates a For/Next loop. Please refer to the For command for 
more information on For/Next loops.


@ENDNODE Next

@NODE To "SYSTEM1"

@{fg shine}Statement: To@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : To Expression2 [Step Expression3]



@ENDNODE To

@NODE Step "SYSTEM1"

@{fg shine}Statement: Step@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Step increment



@ENDNODE Step

@NODE Data "SYSTEM1"

@{fg shine}Statement: Data@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Data [.Type] Item[,Item...]

The Data statement allows you to include pre-defined values in your 
programs. These 'data items' may be transferred into variables using 
the Read statement.
When data is read into variables, the Type of the data being read MUST 
match the type of the variable it is being read into.





@ENDNODE Data

@NODE Read "SYSTEM1"

@{fg shine}Statement: Read@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Read Var[,Var...]

Read is used to transfer items in Data statements into variables. Data 
is transferred sequentially into variables through what is known as a 
'data pointer'. Each time a pice of data is read, the data pointer is 
incremented to point at the next piece of data. The data pointer may be 
set to point to a particular piece of data using the Restore 
command.


@ENDNODE Read

@NODE CNIF "SYSTEM1"

@{fg shine}Statement: CNIF@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CNIF Constant Comparison Constant

CNIF allows you to conditionally compile a section of program code 
based on a comparison of 2 constants. Comparison should be one of '<', 
'>', '=', '<>', '<=' or '>='. If the comparison proves to be true, then 
compiling will continue as normal. If the comparison proves to be 
false, then no object code will be generated until a matching CEND is 
encountered.

System constant

#__include

is set if the file is included by the compiler from another one

CNIF @#constant ;check if #constant is defined (1) or not (0)

Please refer to the Programming chapter of the Blitz 2 Programmers 
Guide for more information on conditional compiling.
 

@ENDNODE CNIF

@NODE CSIF "SYSTEM1"

@{fg shine}Statement: CSIF@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CSIF "String" Comparison "String"

CSIF allows you to conditionally compile a section of program code 
based on a comparison of 2 literal strings. Comparison should be one of 
'<', '>', '=', '<>', '<=' or '>='. Both strings must be quote enclosed 
literal strings. If the comparison proves to be true, then compiling 
will continue as normal. If the comparison proves to be false, then no 
object code will be generated until a matching CEND is 
encountered.

CSIF is of most use in macros for checking macro parameters.

Please refer to the Programming chapter of the Blitz 2 Programmers 
Guide for more information on conditional compiling.


@ENDNODE CSIF

@NODE CELSE "SYSTEM1"

@{fg shine}Statement: CELSE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CELSE 

CELSE may be used between a CNIF or CSIF, and a CEND to cause code to 
be compiled when a constant comparison proves to be false. 

Please refer to the Programming chapter of the Blitz 2 Programmers 
Guide for more information on conditional compiling.


@ENDNODE CELSE

@NODE CEND "SYSTEM1"

@{fg shine}Statement: CEND@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CEND 

CEND marks the end of a block of conditionally compiled code. CEND must 
always appear somewhere following a CNIF or CSIF directive.

Please refer to the Programming chapter of the Blitz 2 Programmers 
Guide for more information on conditional compiling.


@ENDNODE CEND

@NODE CERR "SYSTEM1"

@{fg shine}Statement: CERR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CERR Errormessage

CERR allows a program to generate compile-time error messages. CERR is 
normally used in conjunction with macros and conditional compiling to 
generate errors when incorrect macro parameters are encountered.

Please refer to the Programming chapter of the Blitz 2 Programmers 
Guide for more information on conditional compiling.



@ENDNODE CERR

@NODE Then "SYSTEM1"

@{fg shine}Statement: Then@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Then Statement...



@ENDNODE Then

@NODE Else "SYSTEM1"

@{fg shine}Statement: Else@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Else [Statement...]

Else may be used after an If to cause program instructions to be 
executed if the expression specified in the If proved to be 
false.


@ENDNODE Else

@NODE Jimi  "SYSTEM1"

@{fg shine}Statement: Jimi @{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Jimi  ;CAnd  ; available



@ENDNODE Jimi 

@NODE Jimi  "SYSTEM1"

@{fg shine}Statement: Jimi @{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Jimi  ;COr   ; available



@ENDNODE Jimi 

@NODE Dc "SYSTEM1"

@{fg shine}Statement: Dc@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Dc [.Size] Data[,Data...]



@ENDNODE Dc

@NODE Ds "SYSTEM1"

@{fg shine}Statement: Ds@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Ds [.Size] Length



@ENDNODE Ds

@NODE Even "SYSTEM1"

@{fg shine}Statement: Even@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Even 

EVEN allows you to word align Blitz 2's internal program counter. This 
may be necessary if a DC, DCB or DS statement has caused the program 
counter to be left at an odd address similar to this:

        ...
VALUE1: Dc.b 1
VALUE2: Dc.w 1

If the VALUE1 is located at an even address, VALUE2 is automatically 
located at an odd one.  If an Even is inserted here, a fill byte (0) 
is inserted by the compiler, thus making the second address even.

        ...
VALUE1: Dc.b 1
Even
VALUE2: Dc.w 1

@ENDNODE Even

@NODE Dcb "SYSTEM1"

@{fg shine}Statement: Dcb@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Dcb [.Size] Repeats,Data

DCB stand for 'define constant block'. DCB allows you to insert a 
repeating series of the same value into your assembler programs.

@ENDNODE Dcb

@NODE GetReg "SYSTEM1"

@{fg shine}Statement: GetReg@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : GetReg 68000 Reg,Expression

GetReg allows you to transfer the result of a BASIC expression to a 
68000 register. The result of the expression will first be converted 
into a long value before being moved to the data register.

GetReg should only be used to transfer expressions to one of the 8 data 
registers (d0-d7).

GetReg will use the stack to temporarily store any registers used in 
calculation of the expression.

@ENDNODE GetReg

@NODE IncBin "SYSTEM1"

@{fg shine}Statement: IncBin@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : IncBin Filename

INCBIN allows you to include a binary file in your object code. This is 
mainly of use to assembler language programmers, as having big chunks 
of binary data in the middle of a BASIC program is not really a good 
idea.

INCDIR may be used to specify an AmigaDos path for Filename.

Filename may be optionally quote enclosed to avoid tokenisation 
problems.

@ENDNODE IncBin

@NODE Free "SYSTEM1"

@{fg shine}Statement: Free@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Free Objectname Object#

Free is used to free a Blitz 2 object. Any memory consumed by the 
object's existance will be free'd up, and in the case of things such as 
windows and screens, the display may be altered. 
Attempting to free a non-existant object will have no effect.


@ENDNODE Free

@NODE Use "SYSTEM1"

@{fg shine}Statement: Use@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Use Objectname Object#

Use will cause the Blitz 2 object specified by Objectname and Object# 
to become the currently used object.


@ENDNODE Use

@NODE Stop "SYSTEM1"

@{fg shine}Statement: Stop@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Stop 

The Stop command will cause program flow to stop, and user control to 
be transferred to Blitz 2 direct mode.

The Stop command is really only useful in debugging situations, as it 
allows the programmer a chance to have a look at program variables via 
Blitz 2's direct mode.


@ENDNODE Stop

@NODE Cont "SYSTEM1"

@{fg shine}Statement: Cont@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Cont [N]

The Cont command is only available in Blitz 2 direct mode. Cont will 
cause program flow to continue from the instruction following the 
instruction which caused a jump to direct mode. This instruction may 
have been either a Stop or a program error of some kind.

The optional N parameter can be used to tell Blitz 2 programs to ignore 
a number of Stop commands after a Cont. This is useful in debugging as 
it allows you to insert a Stop inside a program loop, but not have to 
Cont every pass of the loop.


@ENDNODE Cont

@NODE SizeOf "SYSTEM1"

@{fg shine}Statement: SizeOf@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : SizeOf .Typename[,Entrypath]

SizeOf allows you to determine the amount of memory, in bytes, a 
particular variable type takes up. SizeOf may also be followed by an 
optional Entrypath, in which case the offset from the start of the type 
to the specified entry is returned.


@ENDNODE SizeOf

@NODE SetInt "SYSTEM1"

@{fg shine}Statement: SetInt@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : SetInt Type

SetInt is used to declare a section of program code as 'interupt' code. 
Before going further into the details of SetInt, let's have a quick 
look at what interupts are.

Often, when a computer program is running, an event of some importance 
takes place which must be processed immediately. This is done through 
interupts. When an interupt occurs, whatever program may be currently 
running is completely halted by the 68000. Then, a program known as an 
'interupt handler' is started. Once the interupt handler has done it's 
work, the program which was originally interupted is restarted, without 
any knowledge of having been disturbed.

So what can cause an interupt? On the Amiga, there are 14 different 
types of possible interupts, each assigned it's own special number. 
These interupts are as follows:

Interupt   Cause of Interupt

0          Serial transmit buffer empty
1          Disk Block read/written
2          Software interupt
3          Cia ports interupt
4          Co-processor ('copper') interupt
5          Vetical Blank
6          Blitter finished
7          Audio channel 0 pointer/length fetched
8          Audio channel 1 pointer/length fetched
9          Audio channel 2 pointer/length fetched
10         Audio channel 3 pointer/length fetched
11         Serial receive buffer full
12         Floppy disk sync
13         External interupt


The most useful of these interupts is the vertical blank interupt. This 
interupt occurs every time an entire video frame has been fully 
displayed (about every sixtieth of a second), and is very useful for 
animation purposes. If a section of program code has been designated as 
a vertical blank interupt handler, then that section of code will be 
executed every sixtieth of a second.

Interupt handlers must perform their task as quickly as possible, 
especially in the case of vertical blank handlers which must NEVER take 
longer than one sixtieth of a second to execute.

Interupt handlers in Blitz 2 must NEVER access string variables or 
literal strings. In Blitz mode, this is the only restriction on 
interupt handlers. In Amiga mode, no blitter, Intuition or file i/o 
commands may be executed by interupt handlers.

To set up a section of code to be used as an interupt handler, you use 
the SetInt command followed by the actual interupt handler code. An 
End SetInt should follow the interupt code. The Type parameter specifies 
the type of interupt, from the above table, the interupt handler should 
be attached to. For example, SetInt 5 should be used for vertical blank 
interupt code.

More than one interupt handler may be attached to a particular type of 
interupt.


@ENDNODE SetInt

@NODE ClrInt "SYSTEM1"

@{fg shine}Statement: ClrInt@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ClrInt Type

ClrInt may be used to remove any interupt handlers currently attached 
to the specified interupt Type. The SetInt command is used to attached 
interupt handlers to particular interupts.


@ENDNODE ClrInt

@NODE MaxLen "SYSTEM1"

@{fg shine}Statement: MaxLen@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : MaxLen StringVar=Expression

MaxLen sets aside a block of memory for a string variable to grow into. 
This is normally only necessary in the case of special Blitz 2 commands 
which require this space to be present before execution. Currently, 
only 2 Blitz 2 commands require the use of MaxLen - FileRequest$ and 
Fields.

Example

; 
; filerequest program example 
; 

WbToScreen 0      ;pick up workbench as currently used screen 
WBenchToFront_     ;bring workbench to front of view 
MaxLen pa$=160     ;these are necessary for FileRequest$...
MaxLen fi$=64      ;to operate properly! 


a$=FileRequest$("Select a File",pa$,fi$) ;bring up a file requester

WBenchToBack_      ;workbench back to rear of view.


@ENDNODE MaxLen

@NODE DEFTYPE "SYSTEM1"

@{fg shine}Statement: DEFTYPE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DEFTYPE .Typename [Var[,Var...]]

DEFTYPE may be used to declare a list of variables as being of a 
particular type. In this case, Var parameters must be supplied.

DEFTYPE may be used to select a default variable type for future 
'unknown' variables. Unknown variables are variables created with no 
Typename specifier. In this case, no Var parameters are 
supplied.

Please refer to the Programming chapter of the Blitz 2 Programmers 
guide for more information on variable types and the use of 
DEFTYPE.


@ENDNODE DEFTYPE

@NODE BLITZ "SYSTEM1"

@{fg shine}Statement: BLITZ@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BLITZ 

The BLITZ directive is used to enter Blitz mode. For a full discussion 
on Amiga/Blitz mode, please refer to the programming chapter of the 
Blitz 2 Programmers Guide.


@ENDNODE BLITZ

@NODE AMIGA "SYSTEM1"

@{fg shine}Statement: AMIGA@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : AMIGA 

The AMIGA directive is used to enter Amiga mode. For a full discussion 
on Amiga/Blitz mode, please refer to the programming chapter of the 
Blitz 2 Programmers Guide.


@ENDNODE AMIGA

@NODE QAMIGA "SYSTEM1"

@{fg shine}Statement: QAMIGA@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : QAMIGA 

The QAMIGA directive is used to enter Quick Amiga mode. For a full 
discussion on Amiga/Blitz mode, please refer to the programming chapter 
of the Blitz 2 Programmers Guide.


@ENDNODE QAMIGA

@NODE VWait "SYSTEM1"

@{fg shine}Statement: VWait@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : VWait [Frames]

VWait will cause program flow to halt until the next vertical blank 
occurs. The optional Frames parameter may be used to wait for a 
particular number of vertical blanks.

VWait is especially useful in animation for synchronizing display 
changes with the rate at which the display is physically redrawn by the 
monitor.


@ENDNODE VWait

@NODE ALibJsr "SYSTEM1"

@{fg shine}Statement: ALibJsr@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ALibJsr Token[,Form]

ALibJsr is only used when writing Blitz libraries. ALibJsr allows you to call a 
routine from another library from within your own library.

Please refer to the Library Writing section of the programmers guide for more 
information on library writing.

Use "SysJsr" instead for directly calling blitz rountines when you don't write 
a library.


Example:

ALibJsr $c702 : strcpy string working in libs
ALibJsr $c704 : detecting FPU/PPC/optimize/newsyntax compile in libs or AB3 at
                runtime
@ENDNODE ALibJsr

@NODE TokeJsr "SYSTEM1"

@{fg shine}Statement: TokeJsr@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : TokeJsr Token[,Form]

TokeJsr allows you to call any of AmiBlitz's library based routines. 
Token refers to either a token number, or an actual token name. Form 
refers to a particular form of the token. A full list of all token 
numbers with their various forms will be available shortly from Acid 
Software.
@ENDNODE TokeJsr

@NODE BLibJsr "SYSTEM1"

@{fg shine}Statement: BLibJsr@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BLibJsr Token[,Form]

BLibJsr is only used when writing Blitz 2 libraries. BLibJsr allows you 
to call a routine from another library from within your own library. 
Please refer to the Library Writing section of the programmers guide 
for more information on library writing.


@ENDNODE BLibJsr

@NODE Jimi  "SYSTEM1"

@{fg shine}Statement: Jimi @{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Jimi  ;AbortVBOK



@ENDNODE Jimi 

@NODE ABCD "SYSTEM1"

@{fg shine}Statement: ABCD@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ABCD Source operand,Destination operand

Addition of two BCD numbers

@ENDNODE ABCD

@NODE ADD "SYSTEM1"

@{fg shine}Statement: ADD@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ADD Source operand,Destination operand

Binary addition

@ENDNODE ADD

@NODE ADDI "SYSTEM1"

@{fg shine}Statement: ADDI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ADDI Direct value,Address of Register

Addition with a constant

@ENDNODE ADDI

@NODE ADDA "SYSTEM1"

@{fg shine}Statement: ADDA@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ADDA Source operand,Address register 0-6

Binary addition to an address register

@ENDNODE ADDA

@NODE ADDQ "SYSTEM1"

@{fg shine}Statement: ADDQ@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ADDQ Direct value,Address or Register

Fast addition of a constant which only needs bits 0 to 7

@ENDNODE ADDQ

@NODE ADDX "SYSTEM1"

@{fg shine}Statement: ADDX@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ADDX Source operand,Destination operand

Addition with transfer to X flag

@ENDNODE ADDX

@NODE AND "SYSTEM1"

@{fg shine}Statement: AND@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : AND Source operand,Destination Operand

Logical AND

@ENDNODE AND

@NODE ANDI "SYSTEM1"

@{fg shine}Statement: ANDI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ANDI Direct value,Address or Register

Logical AND with a constant

@ENDNODE ANDI

@NODE ASL "SYSTEM1"

@{fg shine}Statement: ASL@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ASL n,Address or Register

Arithmetic shift left (*2^n)

@ENDNODE ASL

@NODE ASR "SYSTEM1"

@{fg shine}Statement: ASR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ASR n,Address or Register

Arithmetic shift right (/2^n)

@ENDNODE ASR

@NODE BCC "SYSTEM1"

@{fg shine}Statement: BCC@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BCC A label (address)

Branch depending on the condition

Here's a list of condition codes,which allow you to form
conditional branches using the Bcc(cc=condition code)format:

   cc       Condition                     Bits
   ---------------------------------------------------
   T        true,corresponds to BRA
   F        false,never branches
   HI       higher than                   C'* Z'
   LS       lower or same                 C + Z
   CC,HS    carry clear,higher or same    C'
   CS,LO    carry set,lower               C
   NE       not equal                     Z'
   EQ       equal                         Z
   VC       overflow clear                V'
   VS       overflow set                  V
   PL       plus,positive
   MI       minus,negative
   GE       greater or equal              N*V+N'*V'
   LT       less than                     N*V'+N'*V
   GT       greater than                  N*V*Z'+N'*V'*Z'
   LE       less or equal                 Z + N*V' + N'*V

   *=logic AND, +=logic OR, '=logic NOT

@ENDNODE BCC

@NODE BCS "SYSTEM1"

@{fg shine}Statement: BCS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BCS A label (address)

See @{" BCC        " link BCC}

@ENDNODE BCS

@NODE BEQ "SYSTEM1"

@{fg shine}Statement: BEQ@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BEQ A label (address)

See @{" BCC        " link BCC}

@ENDNODE BEQ

@NODE BGE "SYSTEM1"

@{fg shine}Statement: BGE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BGE A label (address)

See @{" BCC        " link BCC}

@ENDNODE BGE

@NODE BGT "SYSTEM1"

@{fg shine}Statement: BGT@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BGT A label (address)

See @{" BCC        " link BCC}

@ENDNODE BGT

@NODE BHI "SYSTEM1"

@{fg shine}Statement: BHI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BHI A label (address)

See @{" BCC        " link BCC}

@ENDNODE BHI

@NODE BLE "SYSTEM1"

@{fg shine}Statement: BLE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BLE A label (address)

See @{" BCC        " link BCC}

@ENDNODE BLE

@NODE BLS "SYSTEM1"

@{fg shine}Statement: BLS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BLS A label (address)

See @{" BCC        " link BCC}

@ENDNODE BLS

@NODE BLT "SYSTEM1"

@{fg shine}Statement: BLT@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BLT A label (address)

See @{" BCC        " link BCC}

@ENDNODE BLT

@NODE BMI "SYSTEM1"

@{fg shine}Statement: BMI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BMI A label (address)

See @{" BCC        " link BCC}

@ENDNODE BMI

@NODE BNE "SYSTEM1"

@{fg shine}Statement: BNE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BNE A label (address)

See @{" BCC        " link BCC}

@ENDNODE BNE

@NODE BPL "SYSTEM1"

@{fg shine}Statement: BPL@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BPL A label (address)

See @{" BCC        " link BCC}

@ENDNODE BPL

@NODE BVC "SYSTEM1"

@{fg shine}Statement: BVC@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BVC A label (address)

See @{" BCC        " link BCC}

@ENDNODE BVC

@NODE BVS "SYSTEM1"

@{fg shine}Statement: BVS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BVS A label (address)

See @{" BCC        " link BCC}

@ENDNODE BVS

@NODE BCHG "SYSTEM1"

@{fg shine}Statement: BCHG@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BCHG n,Address or Register

Change bit n (0 becomes 1 and vice versa)

@ENDNODE BCHG

@NODE BCLR "SYSTEM1"

@{fg shine}Statement: BCLR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BCLR n,Address or Register

Erase bit n

@ENDNODE BCLR

@NODE BSET "SYSTEM1"

@{fg shine}Statement: BSET@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BSET n,Address or Register

Set bit n

@ENDNODE BSET

@NODE BTST "SYSTEM1"

@{fg shine}Statement: BTST@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BTST n,Address or Register

Test bit n, the result goes in the Z flag

@ENDNODE BTST

@NODE BRA "SYSTEM1"

@{fg shine}Statement: BRA@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BRA A label (address)

Unconditional branch (similar to JMP)

@ENDNODE BRA

@NODE BSR "SYSTEM1"

@{fg shine}Statement: BSR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BSR A label (address)

Branch to a subroutine.  The return address is put on the stack just like 
for the JSR command.  You return with a RTS command.


@ENDNODE BSR

@NODE CHK "SYSTEM1"

@{fg shine}Statement: CHK@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CHK Address or Register,D0-7

Check a data register

@ENDNODE CHK

@NODE CLR "SYSTEM1"

@{fg shine}Statement: CLR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CLR Address or Register

Erase an operand

@ENDNODE CLR

@NODE CMP "SYSTEM1"

@{fg shine}Statement: CMP@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CMP Source operand,Destination operand

Compare two operands

@ENDNODE CMP

@NODE CMPI "SYSTEM1"

@{fg shine}Statement: CMPI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CMPI Direct value,Address or Register

Compare with a constant

@ENDNODE CMPI

@NODE CMPA "SYSTEM1"

@{fg shine}Statement: CMPA@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CMPA Address or Register,A0-6

Compare with an address register

@ENDNODE CMPA

@NODE CMPM "SYSTEM1"

@{fg shine}Statement: CMPM@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CMPM Source operand,Destination operand

Compare two operands in memory

@ENDNODE CMPM

@NODE DBCC "SYSTEM1"

@{fg shine}Statement: DBCC@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBCC Register,A label (address)

Check condition, decrement and branch.  This command is used with loops a lot.

Here's a list of condition codes,which allow you to form
conditional branches using the DBcc(cc=condition code)format:

   cc       Condition                     Bits
   ---------------------------------------------------
   T        true,corresponds to BRA
   F        false,never branches
   HI       higher than                   C'* Z'
   LS       lower or same                 C + Z
   CC,HS    carry clear,higher or same    C'
   CS,LO    carry set,lower               C
   NE       not equal                     Z'
   EQ       equal                         Z
   VC       overflow clear                V'
   VS       overflow set                  V
   PL       plus,positive
   MI       minus,negative
   GE       greater or equal              N*V+N'*V'
   LT       less than                     N*V'+N'*V
   GT       greater than                  N*V*Z'+N'*V'*Z'
   LE       less or equal                 Z + N*V' + N'*V

   *=logic AND, +=logic OR, '=logic NOT


@ENDNODE DBCC

@NODE DBCS "SYSTEM1"

@{fg shine}Statement: DBCS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBCS Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBCS

@NODE DBEQ "SYSTEM1"

@{fg shine}Statement: DBEQ@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBEQ Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBEQ

@NODE DBGE "SYSTEM1"

@{fg shine}Statement: DBGE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBGE Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBGE

@NODE DBGT "SYSTEM1"

@{fg shine}Statement: DBGT@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBGT Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBGT

@NODE DBHI "SYSTEM1"

@{fg shine}Statement: DBHI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBHI Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBHI

@NODE DBLE "SYSTEM1"

@{fg shine}Statement: DBLE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBLE Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBLE

@NODE DBLS "SYSTEM1"

@{fg shine}Statement: DBLS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBLS Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBLS

@NODE DBLT "SYSTEM1"

@{fg shine}Statement: DBLT@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBLT Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBLT

@NODE DBMI "SYSTEM1"

@{fg shine}Statement: DBMI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBMI Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBMI

@NODE DBNE "SYSTEM1"

@{fg shine}Statement: DBNE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBNE Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBNE

@NODE DBPL "SYSTEM1"

@{fg shine}Statement: DBPL@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBPL Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBPL

@NODE DBVC "SYSTEM1"

@{fg shine}Statement: DBVC@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBVC Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBVC

@NODE DBVS "SYSTEM1"

@{fg shine}Statement: DBVS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBVS Register,A label (address)

See @{" DBCC       " link DBCC}

@ENDNODE DBVS

@NODE DBF "SYSTEM1"

@{fg shine}Statement: DBF@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBF 

See @{" DBCC       " link DBCC}

@ENDNODE DBF

@NODE dra "SYSTEM1"

@{fg shine}Statement: dra@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : dra 



@ENDNODE dra

@NODE DBT "SYSTEM1"

@{fg shine}Statement: DBT@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBT 

See @{" DBCC       " link DBCC}

@ENDNODE DBT

@NODE DIVS "SYSTEM1"

@{fg shine}Statement: DIVS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DIVS Source operand,Destination operand

Sign correct division of a 32 bit destination operand by a 16 bit source operand.  
The result goes in the LO word of the destination long word.
The remainder goes in the HI word.

@ENDNODE DIVS

@NODE DIVU "SYSTEM1"

@{fg shine}Statement: DIVU@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DIVU Source operand,Destination operand

Division without sign, similar to DIVS

@ENDNODE DIVU

@NODE EOR "SYSTEM1"

@{fg shine}Statement: EOR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : EOR Source operand,Destination operand

Exclusive OR

@ENDNODE EOR

@NODE EORI "SYSTEM1"

@{fg shine}Statement: EORI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : EORI Direct value,Address or Register

Exclusive OR with a constant

@ENDNODE EORI

@NODE EXG "SYSTEM1"

@{fg shine}Statement: EXG@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : EXG Register,Register

Exchange the contents of two registers (don't mix this up with SWAP).

@ENDNODE EXG

@NODE EXT "SYSTEM1"

@{fg shine}Statement: EXT@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : EXT D0-7

Sign correct extension to double width

@ENDNODE EXT

@NODE ILLEGAL "SYSTEM1"

@{fg shine}Statement: ILLEGAL@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ILLEGAL 



@ENDNODE ILLEGAL

@NODE JMP "SYSTEM1"

@{fg shine}Statement: JMP@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : JMP A label (address)

Jump to an address (similar to BRA)

@ENDNODE JMP

@NODE JSR "SYSTEM1"

@{fg shine}Statement: JSR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : JSR A label (address)

Jump to a subroutine.  The return address is put on the stack.  
A RTS returns to the command after this one.


@ENDNODE JSR

@NODE LEA "SYSTEM1"

@{fg shine}Statement: LEA@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : LEA Address or Register,A0-6

Load an effective address into A0-6

@ENDNODE LEA

@NODE LINK "SYSTEM1"

@{fg shine}Statement: LINK@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : LINK A0-6,Direct value

Build stack area

@ENDNODE LINK

@NODE LSL "SYSTEM1"

@{fg shine}Statement: LSL@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : LSL Direct value,Address or Register

Logical shift left

@ENDNODE LSL

@NODE LSR "SYSTEM1"

@{fg shine}Statement: LSR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : LSR Direct value,Address or Register

Logical shift right

@ENDNODE LSR

@NODE MOVE "SYSTEM1"

@{fg shine}Statement: MOVE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : MOVE Source operand,Destination operand

Transfer a value from Source operand to Destination operand.



Syntax : MOVE SR,Address or Register

Transfer the Status register contents



Syntax : MOVE Address or Register,SR

Transfer the Status register contents



Syntax : MOVE Address or Register,CCR

Load flags



Syntax : MOVE A7,Address or Register

Transfer the User Stackpointer



Syntax : MOVE Address or Register,A7

Transfer the User Stackpointer

@ENDNODE MOVE

@NODE MOVEP "SYSTEM1"

@{fg shine}Statement: MOVEP@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : MOVEP Source operand,Destination operand

Transfer data to peripheral devices

@ENDNODE MOVEP

@NODE MAIN "SYSTEM1"
.-----------------------------------------------------------------------------.
|                                  @{b}SYSTEM1@{ub}                                    |
`-----------------------------------------------------------------------------'

                  @{"     Overview     " link OVERVIEW}    @{"   SYNTAX     " link SYNTAX}

                         Command Index

                 @{" AsmExit    " link AsmExit}                @{" Case       " link Case}
                 @{" CELSE      " link CELSE}                @{" CEND       " link CEND}
                 @{" CERR       " link CERR}                @{" ClrInt     " link ClrInt}
                 @{" CNIF       " link CNIF}                @{" Cont       " link Cont}
                 @{" CSIF       " link CSIF}                @{" Data       " link Data}
                 @{" Dc         " link Dc}                @{" Dcb        " link Dcb}
                 @{" Default    " link Default}                @{" Dim        " link Dim}
                 @{" Ds         " link Ds}                @{" Else       " link Else}
                 @{" End        " link End}                @{" Even       " link Even}
                 @{" Free       " link Free}
                 @{" Function   " link Function}               @{" For        " link For}
                 @{" GetReg     " link GetReg}                @{" Gosub      " link Gosub}
                 @{" Goto       " link Goto}                @{" If         " link If}
                 @{" IncBin     " link IncBin}                @{" INCLUDE    " link INCLUDE}
                 @{" Jimi       " link Jimi }                @{" Jimi       " link Jimi }
                 @{" Jimi       " link Jimi }                @{" Let        " link Let}
                 @{" Macro      " link Macro}                @{" MaxLen     " link MaxLen}
                 @{" MouseWait  " link MouseWait}                @{" MOVEP      " link MOVEP}
                 @{" NEWTYPE    " link NEWTYPE}                @{" Next       " link Next}
                 @{" Read       " link Read}                @{" Return     " link Return}
                 @{" Select     " link Select}                @{" SetInt     " link SetInt}
                 @{" SHARED     " link SHARED}                @{" SizeOf     " link SizeOf}
                 @{" Statement  " link Statement}                @{" Step       " link Step}
                 @{" Stop       " link Stop}                @{" Then       " link Then}
                 @{" To         " link To}                @{" Use        " link Use}
                 @{" While      " link While}                @{" XINCLUDE   " link XINCLUDE}

                 @{" Amiga      " link Amiga}                @{" Deftype    " link Deftype}
                 @{" Blitz      " link Blitz}                @{" QAMIGA     " link Qamiga}
                 @{" Vwait      " link Vwait}                @{" ALibJsr    " link ALibJsr}
                 @{" TokeJsr    " link TokeJsr}                @{" BLibJsr    " link BLibJsr}

                                   Command Index

                 @{" ABCD       " link ABCD}                @{" ADD        " link ADD}
                 @{" ADDI       " link ADDI}                @{" ADDA       " link ADDA}
                 @{" ADDQ       " link ADDQ}                @{" ADDX       " link ADDX}
                 @{" AND        " link AND}                @{" ANDI       " link ANDI}
                 @{" ASL        " link ASL}                @{" ASR        " link ASR}
                 @{" BCC        " link BCC}                @{" BCS        " link BCS}
                 @{" BEQ        " link BEQ}                @{" BGE        " link BGE}
                 @{" BGT        " link BGT}                @{" BHI        " link BHI}
                 @{" BLE        " link BLE}                @{" BLS        " link BLS}
                 @{" BLT        " link BLT}                @{" BMI        " link BMI}
                 @{" BNE        " link BNE}                @{" BPL        " link BPL}
                 @{" BVC        " link BVC}                @{" BVS        " link BVS}
                 @{" BCHG       " link BCHG}                @{" BCLR       " link BCLR}
                 @{" BSET       " link BSET}                @{" BTST       " link BTST}
                 @{" BRA        " link BRA}                @{" BSR        " link BSR}
                 @{" CHK        " link CHK}                @{" CLR        " link CLR}
                 @{" CMP        " link CMP}                @{" CMPI       " link CMPI}
                 @{" CMPA       " link CMPA}                @{" CMPM       " link CMPM}
                 @{" DBCC       " link DBCC}                @{" DBCS       " link DBCS}
                 @{" DBEQ       " link DBEQ}                @{" DBGE       " link DBGE}
                 @{" DBGT       " link DBGT}                @{" DBHI       " link DBHI}
                 @{" DBLE       " link DBLE}                @{" DBLS       " link DBLS}
                 @{" DBLT       " link DBLT}                @{" DBMI       " link DBMI}
                 @{" DBNE       " link DBNE}                @{" DBPL       " link DBPL}
                 @{" DBVC       " link DBVC}                @{" DBVS       " link DBVS}
                 @{" DBF        " link DBF}                @{" DRA        " link DRA}
                 @{" DBT        " link DBT}                @{" DIVS       " link DIVS}
                 @{" DIVU       " link DIVU}                @{" EOR        " link EOR}
                 @{" EORI       " link EORI}                @{" EXG        " link EXG}
                 @{" EXT        " link EXT}                @{" ILLEGAL    " link ILLEGAL}
                 @{" JMP        " link JMP}                @{" JSR        " link JSR}
                 @{" LEA        " link LEA}                @{" LINK       " link LINK}
                 @{" LSL        " link LSL}                @{" LSR        " link LSR}
                 @{" MOVE       " link MOVE}
@ENDNODE MAIN

