@DataBase "LotanIntuition"
@$VER: LOTANINTUITIONLIB V1.1 (27.01.2007)- Updated by mrodfr.
@Node Main "LotanIntuition"

  @{b}Lotan's Intuition Library 0.22 (29-09-99)@{ub}

    @{" AcScreen      " link AcScreen} Function (Long)
    @{" AcWindow      " link AcWindow} Function (Long)
    @{" CloseS        " link CloseS} Statement
    @{" CloseW        " link CloseW} Statement
    @{" GetIClass     " link GetIClass} Function (Long)
    @{" GetICode      " link GetICode} Function (Word)
    @{" intuibase     " link intuibase} Function (Long)
    @{" MsgAddr       " link MsgAddr} Function (Long)
    @{" MsgClass      " link MsgClass} Function (Long)
    @{" MsgCode       " link MsgCode} Function (Word)
    @{" MsgQualifier  " link MsgQualifier} Function (Word)
    @{" NoMoreWin     " link NoMoreWin} Function (Long)
    @{" OpenS         " link OpenS} Function (Long)
    @{" OpenW         " link OpenW} Function (Long)
    @{" ScrMseIn      " link ScrMseIn} Function (Boolean)
    @{" ScrMseX       " link ScrMseX} Function (Word)
    @{" ScrMseY       " link ScrMseY} Function (Word)
    @{" WaitIClass    " link WaitIClass} Statement
    @{" WaitICode     " link WaitICode} Statement
    @{" WaitIMsg      " link WaitIMsg} Statement
    @{" WaitNoMoreWin " link WaitNoMoreWin} Statement
    @{" WinMseIn      " link WinMseIn} Function (Boolean)
    @{" WinMseX       " link WinMseX} Function (Word)
    @{" WinMseY       " link WinMseY} Function (Word)

  @{b}Author@{ub}

    Olivier Laviale, Doumenge 46230 Montdoumerc, FRANCE

  @{b}Overview@{ub}

    If like me you really don't like @{b}WindowsLib@{ub} and @{b}ScreensLib@{ub} try this  one.  Small,
    powerful, beautiful, easy to use, it don't make coffee but who knows...

  @{b}Different ways@{ub}

    As you may have noticed this set of commands doesn't use @{i}Blitz  Objects@{ui}  concept.
    Sorry but I definatly don't like @{i}Objects@{ui}, in fact I'am a pointer lover :-). Why :

      @{b}1.@{ub} Objects are heavy to use when you have to deal with multiple things.
      @{b}2.@{ub} No @{i}@{fg highlight}CloseScreen@{fg text} 0,@{ui} but @{i}@{fg highlight}CloseS@{fg text} *MyScr@{ui}, more readable.
      @{b}3.@{ub} The set of command is @{u}totaly@{uu} independant.
      @{b}4.@{ub} You can change the Id of the set without problems.
      @{b}5.@{ub} No @{i}@{fg highlight}Peek@{fg text}.l(@{fg highlight}Addr Window@{fg text}(0)) @{ui}to get real pointers, you can use any OS functions
         with pointers returned.

    As usual all resources are freed,  all  windows  and  screens  closed,  when  the
    program quits.

  @{b}Limitations@{ub}

    Sorry but you cannot open more than 256 screens and more than 256  windows...  If
    it is not enought for you (!?!), write me, it's very easy to change.

  @{b}Note@{ub}

    My english if far from perfect, so if I have made mistakes write  me,  and  if  I
    have made really big mistakes send me homeworks or exercices ;-)

  @{b}See also@{ub}

    @{" History             " link HIST}
    @{" Comparaison         " link COMP}
    OS Libs / Intuition on intuition.doc
@EndNode

@Node AcScreen "LotanIntuition : AcScreen"

  @{b}@{u}AcScreen@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.l @{ui}= AcScreen

    @{b}Function@{ub} : Used to get the pointer of the active screen.

    @{b}Values@{ub}   : @{b}rc@{ub} is a pointer to the @{i}Screen structure@{ui} of the active screen.

    @{b}See also@{ub} : @{" AcWindow " link AcWindow}
@EndNode
@Node AcWindow "LotanIntuition : AcWindow"

  @{b}@{u}AcWindow@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.l @{ui}= AcWindow

    @{b}Function@{ub} : Used to get the pointer of the active window.

    @{b}Values@{ub}   : @{b}rc@{ub} is a pointer to the @{i}Window structure@{ui} of the active window.

    @{b}See also@{ub} : @{" AcScreen " link AcScreen}
@EndNode
@Node CloseS "LotanIntuition : CloseS"

  @{b}@{u}CloseS@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : CloseS Scr

    @{b}Function@{ub} : Used to close a screen.

               All windows on your Screen @{u}must@{uu} have been closed before you may  close
               the  screen.  If  you close a window after the screen has been closed,
               the system will crash.  (Not  recommended  ;-)  Use  @{fg highlight}WaitNoMoreWin@{fg text}  or
               @{fg highlight}NoMoreWin@{fg text} to avert this kind of troubles.

               If there does not  exist  any  more  screens  when  you  close  yours,
               Intuition will automatically reopen the Workbench Screen.

               You can use @{fg highlight}CloseS@{fg text} to close  a  screen  opened  with  @{fg highlight}OpenScreen()@{fg text}  or
               @{fg highlight}OpenScreenTags()@{fg text}  but @{u}never@{uu} use @{fg highlight}CloseScreen()@{fg text} to close a screen opened
               with @{fg highlight}OpenS@{fg text}.

    @{b}Note@{ub}     : Screens opened with @{fg highlight}OpenS@{fg text} are automaticaly closed  when  your  program
               quits.

    @{b}Values@{ub}   : @{b}Scr@{ub} is a pointer the @{i}Screen structure@{ui} of an already opened screen.

    @{b}See also@{ub} : @{" CloseW " link CloseW}
               @{" OpenS  " link OpenS}
@EndNode
@Node CloseW "LotanIntuition : CloseW"

  @{b}@{u}CloseW@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : CloseW Win

    @{b}Function@{ub} : Used to close a window.

               Remember that you need to close all  windows  connected  to  a  screen
               before  you  may  close  the  screen.  Windows  opened  with @{fg highlight}OpenW@{fg text} are
               automatically closed when your program quits.

               @{fg highlight}CloseW@{fg text} can be used  to  close  windows  opened  with  @{fg highlight}OpenWindow()@{fg text}  or
               @{fg highlight}OpenWindowTags()@{fg text}  but @{u}never@{uu} use @{fg highlight}CloseWindow()@{fg text} to close a window opened
               with @{fg highlight}OpenW@{fg text}.

    @{b}Values@{ub}   : @{b}Win@{ub} is a pointer to the @{i}Window structure@{ui} of the window which you  want
               to close.

    @{b}See also@{ub} : @{" CloseS " link CloseS}
               @{" OpenW  " link OpenW}
@EndNode
@Node GetIClass "LotanIntuition : GetIClass"

  @{b}@{u}GetIClass@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.l @{ui}= GetIClass(Win)

    @{b}Function@{ub} : Used to get window event class.

               This command unlike @{fg highlight}WaitIClass@{fg text} will not halt program flow, but  cannot
               be used to wait for a special event (code or class).

               @{fg highlight}GetIClass@{fg text} will also update all @{fg highlight}Msgxxx@{fg text} internal variables.

    @{b}Example@{ub}  : @{fg highlight}Repeat
                  Printf@{fg text} "Close me please\n"
               @{fg highlight}Until GetIClass@{fg text}(*Win) = $200

    @{b}See also@{ub} : @{" GetICode   " link GetICode}
               @{" MsgClass   " link MsgClass}
               @{" WaitIClass " link WaitIClass}
               @{" WaitIMsg   " link WaitIMsg}

@EndNode
@Node GetICode "LotanIntuition : GetICode"

  @{b}@{u}GetICode@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.w @{ui}= GetICode(Win)

    @{b}Function@{ub} : Used to get window event code.

               This command unlike @{fg highlight}WaitICode@{fg text} will not halt program flow,  but  cannot
               be used to wait for a special event (code).

               @{fg highlight}GetICode@{fg text} will also update all @{fg highlight}Msgxxx@{fg text} internal variables.

    @{b}Example@{ub}  : @{fg highlight}Repeat
                  Printf@{fg text} "I'am waiting for left mouse button\n"
               @{fg highlight}Until GetICode@{fg text}(*Win) = $68

    @{b}See also@{ub} : @{" GetIClass " link GetIClass}
               @{" MsgCode   " link MsgCode}
               @{" WaitICode " link WaitICode}
@EndNode
@Node intuibase "LotanIntuition : intuibase"

  @{b}@{u}intuibase@{ub}@{uu}

    @{b}Syntax@{ub}   : @{i}rc.l @{ui}= intuibase

    @{b}Function@{ub} : Returns pointer to the Intuition library base.

    @{b}See also@{ub} : @{" execbase " link LotanSystem.guide/execbase}
@EndNode
@Node MsgAddr "LotanIntuition : MsgAddr"

  @{b}@{u}MsgAddr@{ub}@{uu}

    @{b}Syntax@{ub}   : @{i}rc.l @{ui}= MsgAddr

    @{b}Function@{ub} : Return last IntuiMessage structure.

               This function will return a  pointer  to  the  @{i}IntuiMessage  structure@{ui}
               allocated  by @{fg highlight}LotanIntuition@{fg text}. As this structure is allocated when your
               program starts, the pointer will always be the same.

               This structure is used to save the  last  IntuiMessage  received  from
               Intuition. All @{fg highlight}MsgXxx@{fg text} function get values from this structure.

               The contents of the structure will be updated by @{fg highlight}GetIClass@{fg text},  @{fg highlight}GetICode@{fg text},
               @{fg highlight}WaitIClass@{fg text}, @{fg highlight}WaitICode@{fg text}, @{fg highlight}WaitIMsg@{fg text}.

    @{b}Note@{ub}     : This structure don't have to be freed. Note also that it is read only,
               you can write in but at your own risks.

    @{b}Example@{ub}  : @{fg highlight}Repeat@{fg text}
                  ev.l = @{fg highlight}WaitIMsg@{fg text}(*Win)
                  *Msg.IntuiMessage = @{fg highlight}MsgAddr@{fg text}

                  @{fg highlight}Printf@{fg text} "Class $%h - Code $%h[4] - Mouse %d[3] / %d[3]\n",*Msg\\Class,*Msg\\Code,*Msg\\MouseX,*Msg\\MouseY
               @{fg highlight}Until@{fg text} ev = #IDCMP_CLOSEWINDOW

    @{b}See also@{ub} : @{" GetIClass " link GetIClass}
               @{" GetICode  " link GetICode}
               @{" Printf    " link LotanPrint.guide/Printf}
               @{" WaitIMsg  " link WaitIMsg}
@EndNode
@Node MsgClass "LotanIntuition : MsgClass"

  @{b}@{u}MsgClass@{ub}@{uu}

    @{b}Syntax@{ub}   : @{i}rc.l @{ui}= MsgClass

    @{b}Function@{ub} : Returns the @{i}Class part @{ui}of the @{u}last@{uu} intuition message.

               This value is updated by @{fg highlight}GetIClass@{fg text}, @{fg highlight}GetICode@{fg text},  @{fg highlight}WaitIClass@{fg text},  @{fg highlight}WaitICode@{fg text},
               @{fg highlight}WaitIMsg@{fg text}.

    @{b}See also@{ub} : @{" GetIClass    " link GetIClass}
               @{" MsgAddr      " link MsgAddr}
               @{" MsgCode      " link MsgCode}
               @{" MsgQualifier " link MsgQualifier}

@EndNode
@Node MsgCode "LotanIntuition : MsgCode"

  @{b}@{u}MsgCode@{ub}@{uu}

    @{b}Syntax@{ub}   : @{i}rc.w @{ui}= MsgCode

    @{b}Function@{ub} : Returns the @{i}code part @{ui}of the @{u}last@{uu} intuition message.

               This value is updated by @{fg highlight}GetIClass@{fg text}, @{fg highlight}GetICode@{fg text},  @{fg highlight}WaitIClass@{fg text},  @{fg highlight}WaitICode@{fg text},
               @{fg highlight}WaitIMsg@{fg text}.

    @{b}See also@{ub} : @{" GetICode     " link GetICode}
               @{" MsgAddr      " link MsgAddr}
               @{" MsgClass     " link MsgClass}
               @{" MsgQualifier " link MsgQualifier}

@EndNode
@Node MsgQualifier "LotanIntuition : MsgQualifier"

  @{b}@{u}MsgQualifier@{ub}@{uu}

    @{b}Syntax@{ub}   : @{i}rc.w @{ui}= MsgQualifier

    @{b}Function@{ub} : Returns the @{i}qualifier part @{ui}of the @{u}last@{uu} intuition message.

               This value is updated by @{fg highlight}GetIClass@{fg text}, @{fg highlight}GetICode@{fg text},  @{fg highlight}WaitIClass@{fg text},  @{fg highlight}WaitICode@{fg text},
               @{fg highlight}WaitIMsg@{fg text}.

    @{b}See also@{ub} : @{" GetIClass " link GetIClass}
               @{" WaitIMsg  " link WaitIMsg}
@EndNode
@Node NoMoreWin "LotanIntuition : NoMoreWin"

  @{b}@{u}NoMoreWin@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.l @{ui}= NoMoreWin
               @{i}rc.l @{ui}= NoMoreWin(Scr)

    @{b}Function@{ub} : Used to check if there are still windows on a screen.

    @{b}Values@{ub}   : @{b}Scr@{ub} is a pointer to the @{i}Screen structure@{ui} of the screen which you  want
               to  use.  If you don't specify any screen, the active one will be used
               instead.

               @{b}rc@{ub} is a pointer to the @{i}Window structure@{ui} of the first window opened  on
               the  screen.  If  @{b}rc@{ub} is @{fg highlight}False@{fg text} (0), all windows have been closed on the
               screen.

    @{b}Example@{ub}  : @{fg highlight}While NoMoreWin@{fg text}(*Scr)
                  @{fg highlight}WaitTOF_
               Wend@{fg text}

    @{b}Example@{ub}  : *Win._Window = @{fg highlight}NoMoreWin@{fg text}(*Scr)

               @{fg highlight}While@{fg text} *Win
                  @{fg highlight}WaitTOF_@{fg text}
                  *Win = @{fg highlight}NoMoreWin@{fg text}(*Scr)
                  @{fg highlight}Printf@{fg text} "Close Window '%s' please\n",*Win\Title
               @{fg highlight}Wend@{fg text}

    @{b}See also@{ub} : @{" WaitNoMoreWin " link WaitNoMoreWin}
@EndNode
@Node OpenS "LotanIntuition : OpenS"

  @{b}@{u}OpenS@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.l @{ui}= OpenS(Width,Height,Depth,ScrRes,Title)
               @{i}rc.l @{ui}= OpenS(Width,Height,Depth,ScrRes,Title,Tags)

    @{b}Function@{ub} : Will open a Custom Screen with your requirements.

               Screens opened with @{fg highlight}OpenS@{fg text} are automatically closed  when  the  program
               quits.

    @{b}Values@{ub}   : @{b}Width@{ub} and @{b}Height@{ub} are width and height of the screen (incredible...:-).

               The @{b}Depth@{ub} of the screen, i.e., the number of bit-planes. This can be a
               number in the range 1-8 for AGA machines, or 1-6 for pre-AGA machines.
               A screen with @{b}Depth@{ub} 3 will be able to show  2^3  (i.e.,  8)  different
               colours,  since  it will have 2^3 different pens (or colour registers)
               available.

               @{b}ScrRes@{ub} flags control the screen mode. The  following  (common)  values
               are taken from the include @{i}graphics/view@{ui}. You can, if you want, define
               your own constants for the values that you use. Either way  it's  best
               to use descriptive constants rather than directly using the values.

                  @{fg shine}#LACE@{fg text}             = $0004
                  @{fg shine}#DOUBLESCAN@{fg text}       = $0008
                  @{fg shine}#SUPERHIRES@{fg text}       = $0020
                  @{fg shine}#PFBA@{fg text}             = $0040
                  @{fg shine}#EXTRA_HALFBRITE@{fg text}  = $0080
                  @{fg shine}#DUALPF@{fg text}           = $0400
                  @{fg shine}#HAM@{fg text}              = $0800
                  @{fg shine}#HIRES@{fg text}            = $8000

               So, to get a hires, interlaced screen you specify both  of  the  flags
               @{fg shine}#HIRES@{fg text}  and @{fg shine}#LACE@{fg text} either by @{i}OR-@{ui}ing the constants or (less readably) by
               using calculated value $8004.

               @{b}Title@{ub} is the screen title (a string) which appears on the title bar of
               the screen.

               @{b}rc@{ub} is a pointer to a @{i}Screen structure@{ui}. It will  point  to  your  newly
               opened screen or be equal to 0 if the screen could not be opened.

    @{b}Example@{ub}  : @{" Simple example. " System "Blitz2:Guide/Examples/OpenS.exe"}

               Col.l = @{fg highlight}ArOfWord@{fg text}(0,160,160,160, 1,0,0,0, 2,250,250,250, 3,0,100,200, 7,255,255,0, -1)
               Pen.l = @{fg highlight}ArOfWord@{fg text}(0,1,1,2,1,3,1,0,7,1,2,1)
               Tag.l = @{fg highlight}ArOfLong@{fg text}(@{fg shine}#SA_Colors@{fg text},Col, @{fg shine}#SA_Pens@{fg text},Pen, @{fg shine}#TAG_END@{fg text})

               *Scr._Screen = @{fg highlight}OpenS@{fg text}(320,256,3,0,"Screen Test",Tag)

               @{fg highlight}If@{fg text} *Scr
                  *Win._Window = @{fg highlight}OpenW@{fg text}(0,*Scr\BarHeight+1,320,255-*Scr\BarHeight,$200,$1|$2|$4|$8|$20|$200|$1000,"Window Test",*Scr)

                  @{fg highlight}If@{fg text} *Win @{fg highlight}WaitIClass@{fg text} *Win,$200
               @{fg highlight}EndIf

               End@{fg text}

    @{b}Note@{ub}     : Opening a @{i}Publics screen@{ui} is a bit more complicated,  take  a  look  at
               @{fg highlight}WaitNoMoreWin@{fg text} for an example.

    @{b}See also@{ub} : @{" ArOfLong      " link LotanArray.guide/ArOfLong}   @{" CloseS        " link CloseS}
               @{" OpenW         " link OpenW}   @{" WaitIClass    " link WaitIClass}
               @{" WaitNoMoreWin " link WaitNoMoreWin}

@EndNode
@Node OpenW "LotanIntuition : OpenW"

  @{b}@{u}OpenW@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.l @{ui}= OpenW(X,Y,Width,Height,IDCMP,Flags,Title)
               @{i}rc.l @{ui}= OpenW(X,Y,Width,Height,IDCMP,Flags,Title,Scr)
               @{i}rc.l @{ui}= OpenW(X,Y,Width,Height,IDCMP,Flags,Title,Scr,Gads)
               @{i}rc.l @{ui}= OpenW(X,Y,Width,Height,IDCMP,Flags,Title,Scr,Gads,Tags)

    @{b}Function@{ub} : Opens and returns a pointer to a window with the supplied properties.

               If you are going to use the Workbench screen, and it has been  closed,
               it  will  automatically reopen. If you, on the other hand, connect the
               window to a Custom screen, you need to open it yourself before calling
               @{fg highlight}OpenW@{fg text}.

               Windows opened with @{fg highlight}OpenW@{fg text} are automatically closed when  your  program
               quits.

    @{b}Values@{ub}   : @{b}X@{ub} and @{b}Y@{ub} are the coordinates  where  the  window  will  appear  on  the
               screen.  The width and height of the window are defined with @{b}Width@{ub} and
               @{b}Height@{ub} (nooo!! :-)

               @{b}IDCMP@{ub} and @{b}Flags@{ub} are the IDCMP and window specific flags.  See  @{fg highlight}Tags  &
               Flags / Window IDCMP@{fg text} and @{fg highlight}Window Flags@{fg text} for details.

               You use the flags by OR-ing the ones you want together.  However,  you
               should supply only IDCMP flags as part of the @{b}IDCMP@{ub} parameter, and you
               should supply only window flags as part of the @{b}Flags@{ub} parameter.

               Some of the window flags require some of IDCMP flags  to  be  used  as
               well,  if  an  effect is to be complete. For example, if you want your
               window to have a close gadget (a standard window gadget) you  need  to
               use  @{fg shine}#WFLG_CLOSEGADGET@{fg text}  as  one  of the window flags. If you want that
               gadget to be useful then you need to get an  IDCMP  message  when  the
               gadget is clicked. You therefore need to use @{fg shine}#IDCMP_CLOSEWINDOW@{fg text} as one
               of the IDCMP flags. So the full effect requires both a window  and  an
               IDCMP  flag  (a  gadget  is pretty useless if you can't tell when it's
               been clicked).

               @{b}Title@{ub} is the window title (a string) which appears on the title bar of
               the window.

               @{b}Scr@{ub} is a pointer to the @{i}Screen structure@{ui} of the screen  on  which  the
               window should open. If not specified the window will open on the front
               most public screen. See @{fg highlight}OpenS@{fg text} to see how to open a custom  screen  and
               get a screen pointer.

               @{b}Gads@{ub} is a pointer to a gadget  list,  or  0  if  you  don't  want  any
               gadgets.  These  are  not  the standard window gadgets, since they are
               specified using the window @{b}Flags@{ub}.

               @{b}Tags@{ub} is a pointer to a  tag-list  of  other  options  available  under
               Kickstart  version  37  or  greater. This can normally be omitted. See
               @{fg highlight}Tags & Flags / Window Tags@{fg text} for details about the  available  tags  and
               their meanings.

    @{b}Example@{ub}  : @{" Simple example " System "Blitz2:Guide/Examples/OpenW.1.exe"}

               *Win = @{fg highlight}OpenW@{fg text}(20,20,320,200,$200,$1|$2|$4|$8|$20|$200|$1000,"A Window")

               @{fg highlight}If@{fg text} *Win @{fg highlight}WaitIClass@{fg text} *Win,$200

               @{fg highlight}End@{fg text}

    @{b}Example@{ub}  : @{" Using a TagList " System "Blitz2:Guide/Examples/OpenW.2.exe"}

               Tags.l = @{fg highlight}ArOfLong@{fg text}(@{fg shine}#WA_IDCMP@{fg text},$200, @{fg shine}#WA_Flags@{fg text},$1|$2|$4|$8|$20|$200|$1000, @{fg shine}#WA_AutoAdjust@{fg text},-1, @{fg shine}#TAG_END@{fg text})

               *Win = @{fg highlight}OpenW@{fg text}(20,20,320,200,0,0,"MyWin and its Tags",0,0,Tags)

               @{fg highlight}If@{fg text} *Win @{fg highlight}WaitIClass@{fg text} *Win,$200

               @{fg highlight}End@{fg text}

    @{b}See also@{ub} : @{" ArOfLong   " link LotanArray.guide/ArOfLong}
               @{" CloseW     " link CloseW}
               @{" OpenS      " link OpenS}
               @{" WaitIClass " link WaitIClass}

@EndNode
@Node ScrMseIn "LotanIntuition : ScrMseIn"

  @{b}@{u}ScrMseIn@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.b @{ui}= ScrMseIn(x1,y1,x2,y2)
               @{i}rc.b @{ui}= ScrMseIn(Scr,x1,y1,x2,y2)

    @{b}Function@{ub} : Used to see if the mouse pointer is in an area.

               The coordinates are relative to the screen.

    @{b}Values@{ub}   : @{b}x1@{ub}, @{b}y1@{ub}, @{b}x2@{ub}, @{b}y2@{ub} define the coordinates of the area.

               @{b}Scr@{ub} is a pointer to the @{i}Screen structure@{ui} of the  screen  you  want  to
               use. If not specified, the active screen will be used instead.

    @{b}See also@{ub} : @{" ScrMseX  " link ScrMseX}
               @{" ScrMseY  " link ScrMseY}
               @{" WinMseIn " link WinMseIn}
@EndNode
@Node ScrMseX "LotanIntuition : ScrMseX"

  @{b}@{u}ScrMseX@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.w @{ui}= ScrMseX
               @{i}rc.w @{ui}= ScrMseX(Scr)

    @{b}Function@{ub} : Returns the horizontal position of the mouse relative to the left edge
               of a screen.

    @{b}Values@{ub}   : @{b}Scr@{ub} is a pointer to the @{i}Screen structure@{ui} of the screen which you  want
               to  use.  If you don't specify any screen, the active one will be used
               instead.

    @{b}See also@{ub} : @{" ScrMseY  " link ScrMseY}
               @{" WinMseX  " link WinMseX}
@EndNode
@Node ScrMseY "LotanIntuition : ScrMseY"

  @{b}@{u}ScrMseY@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.w @{ui}= ScrMseY
               @{i}rc.w @{ui}= ScrMseY(Scr)

    @{b}Function@{ub} : Returns the vertical position of the mouse relative to the top edge of
               a screen.

    @{b}Values@{ub}   : @{b}Scr@{ub} is a pointer to the @{i}Screen structure@{ui} of the screen which you  want
               to  use.  If you don't specify any screen, the active one will be used
               instead.

    @{b}See also@{ub} : @{" ScrMseX  " link ScrMseX}
               @{" WinMseY  " link WinMseY}
@EndNode
@Node WaitIClass "LotanIntuition : WaitIClass"

  @{b}@{u}WaitIClass@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : WaitIClass Win,Class

    @{b}Function@{ub} : Halts program flow until the specified class event happens.

               Use it carefully, and check the window's IDCMP flags, because  if  you
               specify  to  wait  an event that you don't have set in the IDCMP flags
               the function will wait forever...

               @{fg highlight}WaitIClass@{fg text} can be used  to  wait  for  multiple  classes  by  or  them
               together.  If  one  of  them  happens  the result will be available in
               @{fg highlight}MsgClass@{fg text}.

               @{fg highlight}WaitIClass@{fg text} will also update all @{fg highlight}Msgxxx@{fg text} internal variables.

    @{b}Values@{ub}   : @{b}Win@{ub} is a pointer to the @{i}Window structure@{ui} of a window. For example  the
               pointer returned by @{fg highlight}OpenW@{fg text}.

               @{b}Class@{ub} is an IDCMP value like @{fg shine}#IDCMP_MOUSEBUTTONS@{fg text} ($8)...

    @{b}Example@{ub}  : Simple

               @{fg highlight}Printf@{fg text} "Click my pleeeaaase\n"
               @{fg highlight}WaitIClass@{fg text} *Win,   $8
               @{fg highlight}Printf@{fg text} "Mouse button pressed : $%h[4]\nClose me now\n",@{fg highlight}MsgCode@{fg text}
               @{fg highlight}WaitIClass@{fg text} *Win, $200

    @{b}Example@{ub}  : Multiple

               @{fg highlight}WaitIClass@{fg text} *Win, $8|$200|$40000

               @{fg highlight}Select MsgClass
                  Case@{fg text} $8     : @{fg highlight}Printf@{fg text} "Mouse button pressed\n"
                  @{fg highlight}Case@{fg text} $200   : @{fg highlight}Printf@{fg text} "Window closed\n"
                  @{fg highlight}Case@{fg text} $40000 : @{fg highlight}Printf@{fg text} "Window inactive\n"
               @{fg highlight}End Select@{fg text}

    @{b}See also@{ub} : @{" GetIClass " link GetIClass}
               @{" MsgClass  " link MsgClass}
               @{" WaitICode " link WaitICode}

@EndNode
@Node WaitICode "LotanIntuition : WaitICode"

  @{b}@{u}WaitICode@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : WaitICode Win,Code

    @{b}Function@{ub} : Halts program flow until the specified code event happens.

               Use it carefully, and check the window's IDCMP flags, because  if  you
               specify  to  wait  an event that you don't have set in the IDCMP flags
               the function will wait forever...

               @{fg highlight}WaitICode@{fg text} can be used to wait for multiple codes by or them  together.
               If one of them happens the result will be available in @{fg highlight}MsgCode@{fg text}.

               @{fg highlight}WaitICode@{fg text} will also update all @{fg highlight}Msgxxx@{fg text} internal variables.

    @{b}Values@{ub}   : @{b}Win@{ub} is a pointer to the @{i}Window structure@{ui} of a window. For example  the
               pointer returned by @{fg highlight}OpenW@{fg text}.

               @{b}Code@{ub} is a complement of an IDCMP event. For example if you press  left
               mouse  button  the @{b}Class@{ub} will be @{fg shine}#IDCMP_MOUSEBUTTONS@{fg text} ($8) and the @{b}Code@{ub}
               @{fg shine}#SELECTDOWN@{fg text} ($68)

    @{b}Example@{ub}  : Simple

               @{fg highlight}Printf@{fg text} "I'am waiting left mouse button\n"
               @{fg highlight}WaitICode@{fg text} *Win, @{fg shine}#SELECTDOWN@{fg text}
               @{fg highlight}Printf@{fg text} "Left mouse button pressed\n"
               @{fg highlight}WaitICode@{fg text} *Win, @{fg shine}#SELECTUP@{fg text}
               @{fg highlight}Printf@{fg text} "Left mouse button released\n"

    @{b}Example@{ub}  : Multiple

               @{fg highlight}WaitICode@{fg text} *Win,#SELECDOWN|#SELECTUP|#MENUDOWN|#MENUUP|#MIDDLEDOWN|#MIDDLEUP

               @{fg highlight}Select MsgCode
                  Case @{fg shine}#SELECTDOWN@{fg text} : @{fg highlight}Printf@{fg text} "Left mouse button down\n"
                  @{fg highlight}Case @{fg shine}#SELECTUP@{fg text}   : @{fg highlight}Printf@{fg text} "Left mouse button up\n"
                  @{fg highlight}Case @{fg shine}#MENUDOWN@{fg text}   : @{fg highlight}Printf@{fg text} "Right mouse button down\n"
                  @{fg highlight}Case @{fg shine}#MENUUP@{fg text}     : @{fg highlight}Printf@{fg text} "Right mouse button up\n"
                  @{fg highlight}Case @{fg shine}#MIDDLEDOWN@{fg text} : @{fg highlight}Printf@{fg text} "Middle mouse button down\n"
                  @{fg highlight}Case @{fg shine}#MIDDLEUP@{fg text}   : @{fg highlight}Printf@{fg text} "Middle mouse button up\n"
               @{fg highlight}End Select@{fg text}

    @{b}See also@{ub} : @{" GetIClass " link GetIClass}
               @{" MsgClass  " link MsgClass}
               @{" WaitICode " link WaitICode}
@EndNode
@Node WaitIMsg "LotanIntuition : WaitIMsg"

  @{b}@{u}WaitIMsg@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.l @{ui}= WaitIMsg(Win)

    @{b}Function@{ub} : Waits for a message from Intuition for a window and returns the  class
               of the message (which is an IDCMP flag).

               If you did not specify any IDCMP flags when  the  window  was  opened,
               then this function may return strange values.

               When you've got a message you can use the @{fg highlight}MsgXXX@{fg text} functions to get some
               more information about the message.

               This function is  basically  equivalent  to  the  following  function,
               except that the @{fg highlight}MsgXXX@{fg text} functions can also access the message data held
               in the variables @{i}class@{ui}, @{i}code@{ui}, @{i}qual @{ui}and @{i}iaddr@{ui}.

    @{b}Values@{ub}   : @{b}Win@{ub} is a pointer to a  @{i}Window  structure@{ui}  which  has  previously  been
               initialized.

               @{b}rc@{ub} is the class (an IDCMP flag) of the message sent  by  intuition  to
               the window.

    @{b}Code@{ub}     : @{fg highlight}Function@{fg text}.l WaitIMsg{*Win._Window}
                  *Port.MsgPort     = *Win\UserPort
                  *Msg.IntuiMessage = @{fg highlight}GetMsg_@{fg text}(*Port)

                  @{fg highlight}If@{fg text} *Msg = 0
                     @{fg highlight}Repeat@{fg text}
                        @{fg highlight}WaitPort_@{fg text} *Port
                        *Msg = @{fg highlight}GetMsg_@{fg text}(*Port)
                     @{fg highlight}Until@{fg text} *Msg
                  @{fg highlight}EndIf@{fg text}

                  class.l = *Msg\Class
                  code.w  = *Msg\Code
                  qual.w  = *Msg\_Qualifier
                  iaddr.l = *Msg\IAddress

                  @{fg highlight}ReplyMsg_@{fg text} *Msg

                  @{fg highlight}Function Return@{fg text} class
               @{fg highlight}End Function@{fg text}

    @{b}See also@{ub} : @{" GetIClass    " link GetIClass}
               @{" MsgClass     " link MsgClass}
               @{" MsgCode      " link MsgCode}
               @{" MsgIaddr     " link MsgIaddr}
               @{" MsgQualifier " link MsgQualifier}
@EndNode
@Node WaitNoMoreWin "LotanIntuition : WaitNoMoreWin"

  @{b}@{u}WaitNoMoreWin@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : WaitNoMoreWin
               WaitNoMoreWin Scr

    @{b}Function@{ub} : Waits while windows are still opened on a screen.

    @{b}Values@{ub}   : @{b}Scr@{ub} is a pointer to the @{i}Screen structure@{ui} of the screen which you  want
               to  use.  If  you  don't specify any screen, the activated one will be
               used instead.

    @{b}Example@{ub}  : @{" PubScreen Test " System "Blitz2:Guide/Examples/WaitNoMoreWin.exe"}

               The following code will open a Public screen and a window on it,  then
               wait  until  you  close the window. If other windows are opened on the
               screen it will wait until all visitors have disapeared.

               PubName.s = "MyPub"

               Sig.l = @{fg highlight}AllocSignal_@{fg text}(-1)
               Col.l = @{fg highlight}ArOfWord@{fg text}(0,160,160,160, 1,0,0,0, 2,250,250,250, 3,0,100,200, 4,255,255,0, -1)
               Pen.l = @{fg highlight}ArOfWord@{fg text}(0,1,1,2,1,3,1,0,5,1,2,1)
               Tag.l = @{fg highlight}ArOfLong@{fg text}(@{fg shine}#SA_Colors@{fg text},Col, @{fg shine}#SA_Pens,Pen@{fg text}, @{fg shine}#SA_PubName@{fg text},&PubName, @{fg shine}#SA_PubSig@{fg text},Sig, @{fg shine}#SA_PubTask@{fg text},0,0,0)

               *Scr._Screen = @{fg highlight}OpenS@{fg text}(320,256,3,0,"PubScreen Test",Tag)

               @{fg highlight}If@{fg text} *Scr
                  @{fg highlight}PubScreenStatus_@{fg text} *Scr,0

                  *Win._Window = @{fg highlight}OpenW@{fg text}(0,*Scr\BarHeight+1,320,255-*Scr\BarHeight,$200,$1|$2|$4|$8|$20|$200|$1000,"Test",0,*Scr)

                  @{fg highlight}If@{fg text} *Win
                     @{fg highlight}WaitIClass@{fg text} *Win,$200
                     @{fg highlight}CloseW@{fg text}     *Win
                  @{fg highlight}EndIf

                  WaitNoMoreWin@{fg text} *Scr

                  @{fg highlight}CloseS@{fg text} *Scr : @{fg highlight}FreeSignal_@{fg text} Sig
               @{fg highlight}EndIf

               End@{fg text}

    @{b}Note@{ub}     : @{fg highlight}WaitNoMoreWin@{fg text} calls @{fg highlight}WaitTOF()@{fg text} after every checking, so  it  won't  eat
               all your precious CPU time.

    @{b}See also@{ub} : AllocSignal()  on exec.doc   @{" ArOfLong          " link LotanArray.guide/ArOfLong}
               @{" NoMoreWin         " link NoMoreWin}   @{" OpenS             " link OpenS}
               @{" OpenW             " link OpenW}   PubScreenStatus() on Intuition.doc
               @{" WaitIClass        " link WaitIClass}   WaitTOF() on Graphics.doc
@EndNode
@Node WinMseIn "LotanIntuition : WinMseIn"

  @{b}@{u}WinMseIn@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.b @{ui}= WinMseIn(x1,y1,x2,y2)
               @{i}rc.b @{ui}= WinMseIn(Win,x1,y1,x2,y2)

    @{b}Function@{ub} : Used to see if the mouse pointer is in an area.

               The coordinates are relative to the window.

    @{b}Values@{ub}   : @{b}x1@{ub}, @{b}y1@{ub}, @{b}x2@{ub}, @{b}y2@{ub} define the coordinates of the area.

               @{b}Win@{ub} is a pointer to the @{i}Window structure@{ui} of the  window  you  want  to
               use. If not specified, the active window will be used instead.

    @{b}Example@{ub}  : @{" Test WinMseIn " System "Blitz2:Guide/Examples/WinMseIn.exe"}

               Col.l = @{fg highlight}ArrayOfWord@{fg text}(0,160,160,160, 1,0,0,0, 2,250,250,250, 3,0,100,200, 7,255,255,0, -1)
               Pen.l = @{fg highlight}ArrayOfWord@{fg text}(0,1,1,2,1,3,1,0,7,1,2,1)
               Tag.l = @{fg highlight}ArrayOfLong@{fg text}(@{fg shine}#SA_Colors@{fg text},Col, @{fg shine}#SA_Pens@{fg text},Pen, @{fg shine}#TAG_END@{fg text},0)

               *Scr._Screen = @{fg highlight}OpenS@{fg text}(320,256,3,0,"Screen Test",Tag)

               @{fg highlight}If@{fg text} *Scr
                  *Win._Window = @{fg highlight}OpenW@{fg text}(0,*Scr\BarHeight+1,320,255-*Scr\BarHeight,$200,$1|$2|$4|$8|$20|$200|$1000,"Window Test",*Scr)

                  @{fg highlight}If@{fg text} *Win
                     @{fg highlight}DrPort@{fg text} *Win\RPort

                     @{fg highlight}While GetIClass@{fg text}(*Win) <> $200
                        @{fg highlight}WaitTOF_@{fg text}

                        x1.w = *Win\BorderLeft
                        y1.w = *Win\BorderTop
                        x2.w = *Win\Width-*Win\BorderRight
                        y2.w = *Win\Height-*Win\BorderBottom

                        @{fg highlight}If WinMseIn@{fg text}(*Win,x1,y1,x2,y2) @{fg highlight}DrBoxf@{fg text} x1,y1,x2-1,y2-1,i.b

                        i+1 : @{fg highlight}If@{fg text} i = 7 @{fg highlight}Then@{fg text} i = 0
                     @{fg highlight}Wend
                  EndIf
               EndIf

               End@{fg text}

    @{b}See also@{ub} : @{" DrPort   " link LotanDraw.guide/DrPort}
               @{" ScrMseIn " link ScrMseIn}
               @{" WinMseX  " link WinMseX}
               @{" WinMseY  " link WinMseY}
@EndNode
@Node WinMseX "LotanIntuition : WinMseX"

  @{b}@{u}WinMseX@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.w @{ui}= WinMseX
               @{i}rc.w @{ui}= WinMseX(Win)

    @{b}Function@{ub} : Returns the horizontal position of the mouse relative to the left edge
               of a window.

    @{b}Values@{ub}   : @{b}Win@{ub} is a pointer to the @{i}Window structure@{ui} of the window which you  want
               to  use.  If you don't specify any window, the active one will be used
               instead.

    @{b}See also@{ub} : @{" ScrMseX  " link ScrMseX}
               @{" WinMseY  " link WinMseY}
@EndNode
@Node WinMseY "LotanIntuition : WinMseY"

  @{b}@{u}WinMseY@{ub}@{uu}

    @{b}Modes@{ub}    : Amiga
    @{b}Syntax@{ub}   : @{i}rc.w @{ui}= WinMseY
               @{i}rc.w @{ui}= WinMseY(Win)

    @{b}Function@{ub} : Returns the vertical position of the mouse relative to the top edge of
               a window.

    @{b}Values@{ub}   : @{b}Win@{ub} is a pointer to the @{i}Window structure@{ui} of the window which you  want
               to  use.  If you don't specify any window, the active one will be used
               instead.

    @{b}See also@{ub} : @{" ScrMseY  " link ScrMseY}
               @{" WinMseX  " link WinMseX}
@EndNode

@Node HIST "LotanIntuition : History"
@Prev Main

  @{b}@{u}History@{ub}@{uu}

    @{b}0.00@{ub}

      I created this set to easily get events from windows opened with OS  functions.
      First commands were @{fg highlight}GetIMsg@{fg text}, @{fg highlight}WaitIMsg@{fg text}, @{fg highlight}MsgCode@{fg text}, @{fg highlight}MsgIaddr@{fg text}, @{fg highlight}MsgQualifier@{fg text}.

    @{b}0.02@{ub}

      - Added @{fg highlight}OpenW@{fg text} because @{fg highlight}OpenWindow()@{fg text} or @{fg highlight}OpenWindowTags()@{fg text} are heavy to use.
      - Added @{fg highlight}OpenS@{fg text} for the same reasons.

    @{b}0.03@{ub}

      Changed @{fg highlight}OpenW@{fg text} and @{fg highlight}OpenS@{fg text} to use  an  optional  TagList.  Use  @{fg highlight}OpenWinTags()@{fg text}  and
      @{fg highlight}OpenScreenTags()@{fg text} now.

    @{b}0.05@{ub}                                                                  (Size  344)

      - Added @{fg highlight}CloseW@{fg text} and @{fg highlight}CloseS@{fg text} for convenience.

    @{b}0.06@{ub}

      - Changed deeply the ways I get window's events.
      - Added @{fg highlight}GetIClass@{fg text}, @{fg highlight}GetICode@{fg text}, @{fg highlight}WaitIClass@{fg text}, @{fg highlight}WaitICode@{fg text}.
      - Added @{fg highlight}MsgClass@{fg text} for convenience.

    @{b}0.08@{ub}

      - Added @{fg highlight}acScreen@{fg text} and @{fg highlight}acWindow@{fg text}.
      - Added @{fg highlight}ScrMseX@{fg text}, @{fg highlight}ScrMseY@{fg text}, @{fg highlight}WinMseX@{fg text} and @{fg highlight}WinMseY@{fg text}.

    @{b}0.09@{ub}

      - Added @{fg highlight}WaitNoMoreWin@{fg text} and @{fg highlight}NoMoreWin@{fg text} for easier PubScreens management.

    @{b}0.10@{ub}                                                                  (Size  504)

      - Changed the way @{fg highlight}OpenS@{fg text} and @{fg highlight}OpenW@{fg text} allocate their structures.

    @{b}0.14@{ub}                                                                  (Size  720)

      - Added @{i}LibInit @{ui}and @{i}LibFini @{ui}code.  Now  all  screens  and  windows  opened  are
        automatically closed when the program ends.

      - Changed @{fg highlight}OpenS@{fg text}, @{fg highlight}OpenW@{fg text}, @{fg highlight}CloseS@{fg text} and @{fg highlight}CloseW@{fg text}.

    @{b}0.15@{ub}                                                                   (Size 700)

      Made some optimizations.

    @{b}0.16@{ub}                                                                   (Size 768)

      Added @{fg highlight}ScrMseIn@{fg text} and @{fg highlight}WinMseIn@{fg text}.

    @{b}0.18@{ub}   (03-04-99)                                                      (Size 764)

      - Made some optimizations.
      - Added @{fg highlight}intuitionbase@{fg text}.

    @{b}0.19@{ub}   (24-08-99)                                                      (Size 764)

      Changed an instruction in @{fg highlight}WaitICode@{fg text} and @{fg highlight}WaitIClass@{fg text}, they are now able  to  wait
      for multiple things to happen and not only for one.

    @{b}0.20@{ub}   (28-08-99)                                                      (Size 764)

      Removed a really stupid bug in @{fg highlight}GetICode@{fg text}, used @{i}@{fg highlight}MOVE@{fg text}.L @{ui} instead  of  @{i}@{fg highlight}MOVE@{fg text}.W.@{ui}  Now
      @{fg highlight}GetICode@{fg text} returns good values.

    @{b}0.22@{ub}   (29.09.99)                                          (Size 3632 / Code 826)

      - Added multiple IDCMP checking.

      - Forgot to clear saved values when using @{fg highlight}GetICode@{fg text}, @{fg highlight}GetIClass@{fg text}  functions.  This
        was  confusing  as  if  there  was  no  new  IntuiMessage,  saved values were
        unchanged, instead of being NULL.

      - Changed the way of getting last values  from  IntuiMessages.  Now  I  use  an
        allocated  structure  instead  of  saving @{i}im_Class@{ui}, @{i}im_Code@{ui}, @{i}im_Qualifier@{ui} and
        @{i}im_IAddress@{ui} in built in spaces.

      - Added @{fg highlight}MsgAddr@{fg text} to get the allocated @{i}IntuiMessage structure@{ui} pointer.  With  the
        new saving method, all fields are accessible (e.g. @{i}im_MouseX,@{ui} @{i}im_MouseY.@{ui}..)

      - Removed @{fg highlight}MsgIaddr@{fg text}, because it wasn't that useful. It is accessible  anyway  by
        using @{fg highlight}MsgAddr@{fg text}.

    @{b}0.24@{ub}   (24-01-99)                                          (Size 3540 / Code 752)

      - Made some optimizations.
      - Recompiled with PhxAss v4 by Frank Wille.
@EndNode
@Node COMP "LotanIntuition : Comparaison"

  @{b}@{u}Comparaison@{ub}@{uu}

    Small??, Powerful?? Easy?? Try this and you'll understand :

      @{fg shine}#MY@{fg text} = 1

      @{fg highlight}CNIF@{fg text} @{fg shine}#MY@{fg text}
         *Win = @{fg highlight}OpenW@{fg text}(10,10,200,100,$8|$200,$1|$2|$4|$8|$10|$1000,"Test")

         @{fg highlight}If@{fg text} *Win
            @{fg highlight}WaitIClass@{fg text} *Win,$8
            @{fg highlight}CloseW@{fg text}     *Win
         @{fg highlight}EndIf
      CELSE
         FindScreen@{fg text} 0

         @{fg highlight}If Window@{fg text}(0,10,10,200,100,$1|$2|$4|$8|$10|$1000,"Test",0,1)

            @{fg highlight}Repeat
            Until WaitEvent@{fg text} = $8

            @{fg highlight}CloseWindow@{fg text} 0
         @{fg highlight}EndIf
      CEND

      End@{fg text}

    Compile it with @{fg shine}#MY@{fg text} = 1 then @{fg shine}#MY@{fg text} = 0 and ... what the hell ...  about  14  Ko  of
    difference between mine (2108) and ACID (16100)....

    If you are still not  convinced  (humm..)  try  to  open  a  Public  screen  with
    @{b}ScreenLib@{ub}, then take a look at @{fg highlight}WaitNoMoreWin@{fg text}.

  @{b}@{u}See also@{ub}@{uu}

    @{" WaitNoMoreWin " link WaitNoMoreWin}
@EndNode
