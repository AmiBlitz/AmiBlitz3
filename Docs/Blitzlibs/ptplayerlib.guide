@DATABASE ptplayerlib V1.00
@NODE MAIN "PtPlayerlib"

    PTPlayerLib  General Information:@{ub}

    @{b}Port of Frank Wille's Protracker player v6.4 as a Blitz Basic library@{ub}

    @{" What it is all about " LINK about}

    @{" Additional information about the blitzlib" LINK blitzlibinfo}
    
    Commands:

    @{" MTInstall " LINK MTInstall }
    @{" MTInit " LINK MTInit }
    @{" MTPlay "  LINK MTPlay }
    @{" MTEnd " LINK MTEnd }
    @{" MTSoundFX " LINK MTSoundFX }
    @{" MTPlayFx " LINK MTPlayFx }
    @{" MTStopFx " LINK MTStopFx }
    @{" MTLoopFx " LINK MTLoopFx }
    @{" MTMasterVolume " LINK MTMasterVolume }
    @{" MTSampleVolume " LINK MTSampleVolume }
    @{" MTMusicMask " LINK MTMusicMask }
    @{" MTMusicChannels " LINK MTMusicChannels }
    @{" MTChannelMask " LINK MTChannelMask }
    @{" MTE8Trigger " LINK MTE8Trigger }

@ENDNODE

@NODE about

While developing the games Sqrxz and Solid Gold I needed a Protracker
player which can insert sound effects from the game into the current song.
I ended up in writing a completely new player based on the original
replayer source which came with ProTracker 2.3.

This player is quite optimized and has some useful features for game
developers:

- Insert external sound effects into the replayed module.

- Can also play sound effects while music is stopped or not even initialized.

- A fast master volume for the replayed music.

- No busy waiting. DMA and repeat pointers are set with timer interrupts.

- Optionally works without timer interrupts at all.

- E8 command can be used as a trigger for your main program.

- Lots of tables for best performance. No multiplications or divisions.


The sound fx system gives you the possibility to play samples on a channel
of your choice or on the channel which the player thinks is the best one.

It may be a channel which is currently not replaying music and/or has
the longest period of inactivity ahead. This has the effect that the
replayed song is often not disturbed at all.

Up to four sound effects can be played at the same time and any of them
has its own priority, which is especially useful when trying to play
several sounds on the same channel. You may for example define that a
shooting-sound has a higher priority than a jumping-sound.

For automatic channel selection you can additionally reserve specific
channels for music only, or define the maximum number of channels which
may be used for sound effects at once.

The master volume is always applied to the music, but does never affect
external sound effects.

@ENDNODE about

@NODE blitzlibinfo

    Blitz Basic function/statement entry points added by idrougge, macros by earok
    
    Further development by E-Penguin
    
    VBR fix by phx
    
    compiled with vasm 2.0a, with the following options:
    vasmm68k_mot.exe -devpac -Fhunkexe -kick1hunks -nosym  ptplayer.asm -o ptplayer.obj
    Built with the following configuration flags:
    MINIMAL		equ	0
    ENABLE_SAWRECT	equ	0
    NULL_IS_CLEARED	equ	0

    New for ptplayer 6.4 is "OS Compatible" mode; there is a separate build for this with the OSCOMPAT flag = 1.
    As a result, the MTInstall statement has changed, see below if using this version. 
    Rename the obj to remove "_oscompat" and rebuild the blitzlibs accordingly.

@ENDNODE blitzlibinfo

@NODE MTInstall

    @{b}SYNTAX@{ub}
    MTInstall PAL=1, NTSC=0    [OSCOMPAT=0, default]
    or
    success.l = MTInstall             [OSCOMPAT=1]
    
    @{b}FUNCTION@{ub}
    Install a CIA-B interrupt for calling MTMusic or MTSfxonly
    automatically. The music module is replayed via MTMusic when MTEnable
    is non-zero. Otherwise the interrupt handler calls mt_sfxonly to play
    sound effects only.
    VectorBase is 0 for 68000, otherwise set it to the CPU's VBR register.
    A non-zero PALflag selects PAL-clock for the CIA timers (NTSC otherwise).
 
    
@ENDNODE

@NODE MTInit

    @{b}SYNTAX@{ub}
    MTInit Bank#, startpos 
    or
    MTInit &module_addr, &instr_addr, startpos
    
    @{b}FUNCTION@{ub}
    Initialize a new module.
    Reset speed to 6, tempo to 125 and start at the given song position.
    Master volume is at 64 (maximum).
    When a1 is NULL the samples are assumed to be stored after the patterns,
    which is the usual case.

    @{b}EXAMPLE@{ub}
    LoadBank 0,"mod.song",2
    MTInit 0,0

@ENDNODE

@NODE MTPlay

    @{b}SYNTAX@{ub}
    MTPlay On/Off 

    @{b}FUNCTION@{ub}
    Start/stop module playback

@ENDNODE

@NODE MTEnd

    @{b}SYNTAX@{ub}
    MTEnd

    @{b}FUNCTION@{ub}
    Stop playing the current module and sound effects.

@ENDNODE

@NODE MTRemove

    @{b}SYNTAX@{ub}
    MTRemove 

    @{b}FUNCTION@{ub}
    Remove the  CIA-B music interrupt, restore the previous handler and
    reset the CIA timer registers to their original values.

@ENDNODE

@NODE MTSoundFX

    @{b}SYNTAX@{ub}
    MTSoundFX Sound#, volume (0..64)
    or
    MTSoundFX &sample_addr.l, length.w, period.w, volume.w (0..64)

    @{b}FUNCTION@{ub}
    Request playing of an external sound effect on the most unused channel.
    This function is for compatibility with the old API only.
    You should call @{"MTPlayFx" LINK MTPlayFx} instead.

@ENDNODE

@NODE MTPlayFx

    @{b}SYNTAX@{ub}
    MTPlayFx &SfxStructure

    @{b}FUNCTION@{ub}
    Request playing of a prioritized external sound effect, either on a
    fixed channel or on the most unused one.
    
    Structure layout of SfxStructure:
    void *sfx_ptr  (pointer to raw sample start in Chip RAM, even address)
    WORD  sfx_len  (sample length in words)
    WORD  sfx_per  (hardware replay period for sample)
    WORD  sfx_vol  (volume 0..64, is unaffected by the song's master volume)
    BYTE  sfx_cha  (0..3 selected replay channel, -1 selects best channel)
    BYTE  sfx_pri  (priority, must be in the range 1..127)
  
    When multiple samples are assigned to the same channel the lower
    priority sample will be replaced. When priorities are the same, then
    the older sample is replaced.
    The chosen channel is blocked for music until the effect has
    completely been replayed.

    RETURN VALUES: A pointer to a channel-status structure (see ptplayer.h)
    when the sample is scheduled for playing, or NULL when the request was
    ignored.
    NOTE: Remember that sfx_ptr points to raw sample data (no IFF header
    or similar). And always make sure the first two bytes of your sound
    effect sample are zero! Alternatively, refer to NULL_IS_CLEARED.

@ENDNODE


@NODE MTStopFx

    @{b}SYNTAX@{ub}
    MTStopFx channel

    @{b}FUNCTION@{ub}
    Immediately stop a currently playing sound effect on a channel (0..3)
    and make it available for music, or other effects, again. This is the
    only way to stop a looped sound effect (MTLoopFx), besides stopping
    replay completely (MTEnd).
@ENDNODE

@NODE MTLoopFX

    @{b}SYNTAX@{ub}
    MTLoopFx &SfxStructure

    @{b}FUNCTION@{ub}
    Request playing of a looped sound effect on a fixed channel, which
    will be blocked for music until the effect is stopped (MTStopFx).
    It uses the same SfxStructure as MTPlayFx, but the priority is
    ignored. A looped sound effect has always highest priority and will
    replace a previous effect on the same channel. No automatic channel
    selection is possible!
    Also make sure the sample starts with a zero-word, which is used
    for idling when the effect is stopped by MTStopFx. This word is
    included in the total length calculation, but excluded when actually
    playing the loop. 

@ENDNODE

@NODE MTMasterVolume

    @{b}SYNTAX@{ub}
    MTMasterVolume 0..64

    @{b}FUNCTION@{ub}
    Set a master volume from 0 to 64 for all music channels.
    Note that the master volume does not affect the volume of external
    sound effects (which is desired).
@ENDNODE

@NODE MTSampleVolume

    @{b}SYNTAX@{ub}
    MTSampleVolume SampleNumber.w, Volume.b

    @{b}FUNCTION@{ub}
    Redefine a sample's volume. May also be done while the song is playing.
    Warning: Does not check arguments for valid range! You must have done
    MTnit before calling this function!
    The new volume is persistent. Even when the song is restarted.
 
@ENDNODE

@NODE MTMusicMask

    @{b}SYNTAX@{ub}
    MTMusicMask bitmask.b 

    @{b}FUNCTION@{ub}
    Bits set in the mask define which specific channels are reserved
    for music only. Set bit 0 for channel 0, ..., bit 3 for channel 3.
    Additionally a cleared bit prevents any access to the sample pointers
    of this channel.
    When calling MTSoundFx or MTPlayFx with automatic channel selection
    (sfx_cha=-1) then these masked channels will never be picked.
    The mask defaults to 0.

@ENDNODE

@NODE MTMusicChannels

    @{b}SYNTAX@{ub}
    MTMusicChannels 0..4

    @{b}FUNCTION@{ub}
    This byte defines the number of channels which should be dedicated
    for playing music. So sound effects will never use more
    than 4 - MTMusicChannels channels at once. Defaults to 0.

@ENDNODE


@NODE MTChannelMask

    @{b}SYNTAX@{ub}
    MTMusicChannels ChannelMask.b

    @{b}FUNCTION@{ub}
    Bits cleared in the mask define which specific channels are muted
    for music replay. Clear bit 0 for channel 0, ..., bit 3 for channel 3.
    The mask defaults to all channels unmuted (bits set) and is reset to
    this state on MTInit and MTEnd.

@ENDNODE


@NODE MTE8Trigger

    @{b}SYNTAX@{ub}
    MTE8Trigger

    @{b}FUNCTION@{ub}
    This byte reflects the value of the last E8 command.
    It is reset to 0 after MTInit.
@ENDNODE