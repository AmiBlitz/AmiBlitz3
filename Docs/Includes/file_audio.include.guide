@Database "AB3Includes"
@Width 80
@font helvetica.font 13
@wordwrap
@TAB 3

@NODE main "file_audio.include"

@{B}file_audio.include@{UB}

@{B}Abstract@{UB}

   @{" Introduction " link Introduction} 

@{B}Public Function Index:@{UB}

   @{" ffa_Clone " link ffa_Clone} 
   @{" ffa_Close " link ffa_Close} 
   @{" ffa_Erase " link ffa_Erase} 
   @{" ffa_Examine " link ffa_Examine} 
   @{" ffa_Free " link ffa_Free} 
   @{" ffa_GetBits " link ffa_GetBits} 
   @{" ffa_GetByteLength " link ffa_GetByteLength} 
   @{" ffa_GetChannels " link ffa_GetChannels} 
   @{" ffa_GetCompression " link ffa_GetCompression} 
   @{" ffa_GetCompressionString " link ffa_GetCompressionString} 
   @{" ffa_GetEndianess " link ffa_GetEndianess} 
   @{" ffa_GetFileFormat " link ffa_GetFileFormat} 
   @{" ffa_GetFineTuning " link ffa_GetFineTuning} 
   @{" ffa_GetFrameLength " link ffa_GetFrameLength} 
   @{" ffa_GetFrameOffset " link ffa_GetFrameOffset} 
   @{" ffa_GetFrameSize " link ffa_GetFrameSize} 
   @{" ffa_GetLength " link ffa_GetLength} 
   @{" ffa_GetLoop " link ffa_GetLoop} 
   @{" ffa_GetLoopEnd " link ffa_GetLoopEnd} 
   @{" ffa_GetLoopStart " link ffa_GetLoopStart} 
   @{" ffa_GetRootKey " link ffa_GetRootKey} 
   @{" ffa_GetSampleEnd " link ffa_GetSampleEnd} 
   @{" ffa_GetSampleStart " link ffa_GetSampleStart} 
   @{" ffa_GetSamplerate " link ffa_GetSamplerate} 
   @{" ffa_GetSigned " link ffa_GetSigned} 
   @{" ffa_ReadData " link ffa_ReadData} 
   @{" ffa_ReadHeader " link ffa_ReadHeader} 
   @{" ffa_ReadHeaderInfo " link ffa_ReadHeaderInfo} 
   @{" ffa_ReportErrs " link ffa_ReportErrs} 
   @{" ffa_Seek " link ffa_Seek} 
   @{" ffa_SetMode " link ffa_SetMode} 
   @{" ffa_WriteData " link ffa_WriteData} 
   @{" ffa_WriteHeader " link ffa_WriteHeader} 
   @{" ffa_WriteHeaderInfo " link ffa_WriteHeaderInfo} 
   @{" ffa_WriteSampleInfo " link ffa_WriteSampleInfo} 
   @{" ffa_ms2off " link ffa_ms2off} 
   @{" ffa_off2ms " link ffa_off2ms} 

@{B}Private Function Index:@{UB}

   @{" _ffa_CheckFormOK " link _ffa_CheckFormOK} 
   @{" _ffa_CheckLittleEndian " link _ffa_CheckLittleEndian} 
   @{" _ffa_CheckStereo " link _ffa_CheckStereo} 
   @{" _ffa_CheckUnsigned " link _ffa_CheckUnsigned} 
   @{" _ffa_EncodeSysexData " link _ffa_EncodeSysexData} 
   @{" _ffa_EncodeSysexHeader " link _ffa_EncodeSysexHeader} 
   @{" _ffa_Fixup " link _ffa_Fixup} 
   @{" _ffa_FreeHeader " link _ffa_FreeHeader} 
   @{" _ffa_Resample " link _ffa_Resample} 
   @{" _ffa_UpdateHeader " link _ffa_UpdateHeader} 
   @{" ffa_Form2Ext " link ffa_Form2Ext} 

@{B}Public Macro Index:@{UB}

   @{" !ffa_bfsize " link !ffa_bfsize} 
   @{" !ffa_dstptr " link !ffa_dstptr} 
   @{" !ffa_konto " link !ffa_konto} 
   @{" !ffa_ratio " link !ffa_ratio} 
   @{" !ffa_sample_end " link !ffa_sample_end} 
   @{" !ffa_scratch " link !ffa_scratch} 
   @{" !ffa_scratch2 " link !ffa_scratch2} 
   @{" !ffa_srcptr " link !ffa_srcptr} 

@ENDNODE
@NODE !ffa_bfsize "!ffa_bfsize"

@{B}!ffa_bfsize@{UB}

@{B}Syntax:@{UB} !ffa_bfsize

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ffa_dstptr "!ffa_dstptr"

@{B}!ffa_dstptr@{UB}

@{B}Syntax:@{UB} !ffa_dstptr

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ffa_konto "!ffa_konto"

@{B}!ffa_konto@{UB}

@{B}Syntax:@{UB} !ffa_konto

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ffa_ratio "!ffa_ratio"

@{B}!ffa_ratio@{UB}

@{B}Syntax:@{UB} !ffa_ratio

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ffa_sample_end "!ffa_sample_end"

@{B}!ffa_sample_end@{UB}

@{B}Syntax:@{UB} !ffa_sample_end

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ffa_scratch "!ffa_scratch"

@{B}!ffa_scratch@{UB}

@{B}Syntax:@{UB} !ffa_scratch

@{B}Description:@{UB}
      )

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ffa_scratch2 "!ffa_scratch2"

@{B}!ffa_scratch2@{UB}

@{B}Syntax:@{UB} !ffa_scratch2

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ffa_srcptr "!ffa_srcptr"

@{B}!ffa_srcptr@{UB}

@{B}Syntax:@{UB} !ffa_srcptr

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE Introduction "Introduction"

@{B}Name:@{UB} file_audio.include

@{B}Platforms:@{UB} Classic, WinUAE, Amithlon, MorphOS, AmigaOS4

@{B}Date:@{UB} 02/01/2007

@{B}Author:@{UB} Thilo Koehler

@{B}Requirements:@{UB}  Amiblitz2.4

@{B}Purpose:@{UB}
This include brings load and save functionality for audio files to AB2.

@{B}Abstract:@{UB}
This include is an add-on include of the file.include. It supports reading and writing of various audio formats such as iff-8svx, riff-wav, aiff, maud or cdda. It has a build in format convertion from mono to stereo, 8 to 32bit.
The idea is, that you open a file for writing, lets say 44.1kHz, 16bit mono. Then, each write command is feeded with the input format, which is usually an array of samples, that can be 16kHz, 8bit stereo. The write function will automatially write it correctly to the audio file.

@{B}User Constants:@{UB}
#mpega_support = 1
Make use of the mpega.library to load mp3/2 files. If mpega.library is not installed, you program will work but refuse to load mp3 files and complain about the missing mpega.lib.

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    file.include




@ENDNODE
@NODE _ffa_CheckFormOK "_ffa_CheckFormOK"

@{B}_ffa_CheckFormOK@{UB}

@{B}Syntax:@{UB}  result.l = _ffa_CheckFormOK \{channels.l,bits.l,samplerate.l,byteorder.l,compression.l\}

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      
- channels.l    : number of channels (1=mono, 2=stereo)
- bits.l        : number of bits (usually 8, 16 or 24)
- samplerate.l  : ???
- byteorder.l   : ???
- compression.l : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ffa_CheckLittleEndian "_ffa_CheckLittleEndian"

@{B}_ffa_CheckLittleEndian@{UB}

@{B}Syntax:@{UB}  succ.l = _ffa_CheckLittleEndian \{fid.l,channels.l,bits.l\}

@{B}Description:@{UB}
* private *
Test if the raw audio data is little or big endian.
This is done by messuring the "roughness" o little endian and big endian encoded signal. The less "rough" signal is considered to be in correct endianess.
NOTE: This function is used to detect the correct endianess of raw data.

@{B}Inputs:@{UB}      
- fid.l    : file object ID
- channels.l    : number of channels (1=mono, 2=stereo)
- bits.l    : number of bits (usually 8, 16 or 24)

@{B}Result:@{UB}      
- succ.l     : -1 = little endian, 0 = big endian

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ffa_CheckStereo "_ffa_CheckStereo"

@{B}_ffa_CheckStereo@{UB}

@{B}Syntax:@{UB}  succ.l = _ffa_CheckStereo \{fid.l,bits.l,bo.l,signed.l\}

@{B}Description:@{UB}
Guess if the raw data is mono or stereo.

@{B}Inputs:@{UB}      
- fid.l    : file object ID
- bits.l    : number of bits (usually 8, 16 or 24)
- bo.l    : byte order of signal
- signed.l    : -1 = signed, 0 = unsigned

@{B}Result:@{UB}      
- succ.l     : -1 = stereo, 0 = mono

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ffa_CheckUnsigned "_ffa_CheckUnsigned"

@{B}_ffa_CheckUnsigned@{UB}

@{B}Syntax:@{UB}  succ.l = _ffa_CheckUnsigned \{fid.l,channels.l,bits.l,bo.l\}

@{B}Description:@{UB}
Guess if the raw data from file is signed or unsiged.

@{B}Inputs:@{UB}      
- fid.l    : file object ID
- channels.l    : number of channels (1=mono, 2=stereo)
- bits.l    : number of bits (usually 8, 16 or 24)
- bo.l    : byte order

@{B}Result:@{UB}      
- succ.l     : -1 = unsigned, 0 = signed

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ffa_EncodeSysexData "_ffa_EncodeSysexData"

@{B}_ffa_EncodeSysexData@{UB}

@{B}Syntax:@{UB}  result.l = _ffa_EncodeSysexData \{*sh.chunk_sysex_header,*sd.chunk_sysex_data,dataptr.l,sourcebits.l,@flength.l\}

@{B}Description:@{UB}
* private *
Encode audio samples to a midi sysex chunk.
NOTE: This needs 120/cframesize samples present in dataptr, otherwise flength has to be specified
NOTE: This function returns the amount of samples that were aborbed into the chunk
NOTE: once a chunk is full, you have to clear \offset=0 to read more samples

@{B}Inputs:@{UB}      
- *sh.chunk_sysex_header    : ???
- *sd.chunk_sysex_data    : ???
- dataptr.l    : ???
- sourcebits.l    : number of bits (usually 8, 16 or 24)
- flength.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ffa_EncodeSysexHeader "_ffa_EncodeSysexHeader"

@{B}_ffa_EncodeSysexHeader@{UB}

@{B}Syntax:@{UB} _ffa_EncodeSysexHeader \{*sh.chunk_sysex_header,*sd.chunk_sysex_data,waveID.l,sxchannel.l,bits.l,samplerate.l,flength.l,loop_start.l,loop_end.l\}

@{B}Description:@{UB}
* private *
Encode sysex header out of the given parameters.

@{B}Inputs:@{UB}      
- *sh.chunk_sysex_header : ???
- *sd.chunk_sysex_data   : ???
- waveID.l       : ???
- sxchannel.l    : ???
- bits.l         : number of bits (usually 8, 16 or 24)
- samplerate.l   : ???
- flength.l      : ???
- loop_start.l   : ???
- loop_end.l     : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ffa_Fixup "_ffa_Fixup"

@{B}_ffa_Fixup@{UB}

@{B}Syntax:@{UB}  result.l = _ffa_Fixup \{fid.l\}

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ffa_FreeHeader "_ffa_FreeHeader"

@{B}_ffa_FreeHeader@{UB}

@{B}Syntax:@{UB} _ffa_FreeHeader \{fid.l\}

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ffa_Resample "_ffa_Resample"

@{B}_ffa_Resample@{UB}

@{B}Syntax:@{UB}  result.l = _ffa_Resample \{sourceaddr.l,destaddr.l,d_length.l,s_length.l,ratio.l,brain_ptr.l\}

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      
- sourceaddr.l    : ???
- destaddr.l    : ???
- d_length.l    : ???
- s_length.l    : ???
- ratio.l    : ???
- brain_ptr.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ffa_UpdateHeader "_ffa_UpdateHeader"

@{B}_ffa_UpdateHeader@{UB}

@{B}Syntax:@{UB}  result.w = _ffa_UpdateHeader \{fid.l\}

@{B}Description:@{UB}
* private

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- result.w     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_Clone "ffa_Clone"

@{B}ffa_Clone@{UB}

@{B}Syntax:@{UB}  fid.l = ffa_Clone \{ofid.l\}

@{B}Description:@{UB}
Clone the lock on an audio file.
NOTE: this is useful, if you want to keep two different seek positions on the same file for reading without jumping back and forth in the file.

@{B}Inputs:@{UB}      
- ofid.l    : file object ID

@{B}Result:@{UB}      
- fid.l     : file obect ID

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_Close "ffa_Close"

@{B}ffa_Close@{UB}

@{B}Syntax:@{UB} ffa_Close \{fid.l\}

@{B}Description:@{UB}
Close a file opend by ffa_read or ffa_write.
NOTE: It is important to call ffa_close and NOT file_close, since some filformats require a fixup after all data is written.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_Erase "ffa_Erase"

@{B}ffa_Erase@{UB}

@{B}Syntax:@{UB} ffa_Erase \{fid.l\}

@{B}Description:@{UB}
Erase an open audio file. This function does the same like @{" ffa_Close " link ffa_Close} and dos_delete, but you do not need the close the file.
NOTE: This is useful, if problems during writing occured and you want to discard the file.

@{B}Inputs:@{UB}      
- dos.l    : file object ID
- fid.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_Examine "ffa_Examine"

@{B}ffa_Examine@{UB}

@{B}Syntax:@{UB}  succ.l = ffa_Examine \{filename.s\}

@{B}Description:@{UB}
Check if the format of the file is known to the file_audio.include.

@{B}Inputs:@{UB}      
- filename.s    : file name of the file to examine

@{B}Result:@{UB}      
- succ.l     : -1 if the file can be loaded, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ffa_GetFileFormat " link ffa_GetFileFormat}




@ENDNODE
@NODE ffa_Form2Ext "ffa_Form2Ext"

@{B}ffa_Form2Ext@{UB}

@{B}Syntax:@{UB}  result.s = ffa_Form2Ext \{form.l\}

@{B}Description:@{UB}
* private *
Get a reasonable file extentions for the given form value.
E.g. ffa_Form2Ext\{@"MP3"\} would result in "mp3".
See @{" ffa_GetFileFormat " link ffa_GetFileFormat} for possible file formats.

@{B}Inputs:@{UB}      
- form.l    : internal form value

@{B}Result:@{UB}      
- result.s     : file extention

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ffa_GetFileFormat " link ffa_GetFileFormat}




@ENDNODE
@NODE ffa_Free "ffa_Free"

@{B}ffa_Free@{UB}

@{B}Syntax:@{UB} ffa_Free \{\}

@{B}Description:@{UB}
Free all resources associated with the file_audio.include.
NOTE: This is an autoexit function, you do not have to call this manually.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetBits "ffa_GetBits"

@{B}ffa_GetBits@{UB}

@{B}Syntax:@{UB}  bits.l = ffa_GetBits \{fid.l\}

@{B}Description:@{UB}
Get the number of bits of an open file.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- bits.l     : number of bits

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetByteLength "ffa_GetByteLength"

@{B}ffa_GetByteLength@{UB}

@{B}Syntax:@{UB}  bytes.l = ffa_GetByteLength \{fid.l\}

@{B}Description:@{UB}
Get the raw, uncompressed length of audio data in bytes.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- bytes.l     : number of bytes

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetChannels "ffa_GetChannels"

@{B}ffa_GetChannels@{UB}

@{B}Syntax:@{UB}  channels.l = ffa_GetChannels \{fid.l\}

@{B}Description:@{UB}
Get the number of channels of the raw, uncompressed audio data.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- channels.l     : number of channels (1=mono, 2=stereo)

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetCompression "ffa_GetCompression"

@{B}ffa_GetCompression@{UB}

@{B}Syntax:@{UB}  result.l = ffa_GetCompression \{fid.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- fid.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetCompressionString "ffa_GetCompressionString"

@{B}ffa_GetCompressionString@{UB}

@{B}Syntax:@{UB}  result.s = ffa_GetCompressionString \{fid.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- fid.l    : ???

@{B}Result:@{UB}      
- result.s     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetEndianess "ffa_GetEndianess"

@{B}ffa_GetEndianess@{UB}

@{B}Syntax:@{UB}  result.l = ffa_GetEndianess \{fid.l\}

@{B}Description:@{UB}
Get the byte order value of the audio data.
The byte order can be #FFABO_LITTLEENDIAN OR #FFABO_BIGENDIAN.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- result.w     : byte order

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetFileFormat "ffa_GetFileFormat"

@{B}ffa_GetFileFormat@{UB}

@{B}Syntax:@{UB}  form.l = ffa_GetFileFormat \{fid.l,@pos.l\}

@{B}Description:@{UB}
Return the file format identifier or #FFA_UNKNOWN if the file format is not supported.
Possible file format identifiers are:
@"AIFF" : AIFF or AIFC file format (used on MACs)
@"WAVE" : Windows RIFF-WAV format (used on Windows)
@"CDDA" : 44.1kHzm 16 bit stereo RAW data at a certian length, read to use with MakeCD.
@"MAUD" : old, proprietary Amiga format for Maestro Sound card and others
@"8SVX" : THE Amiga IFF-8SVX format, unfortunately it can handle only 8 bit, rarely used nowadays
@"MP3"  : 16 bit, highly compressed audio format common on all platforms, read only, requires mpega.library
@"MP2"  : older version of MP3.
@"RAW"  : RAW data, can be anything
@"SYSX" : MIDI SysEx Sample dump, can hanlde only mono data
@"HDRC" : HD-Rec specific format, not used anymore
@"ADC"  : 16bit, 16kHz mono sample, signed little endian encoded
#FFA_UNKNOWN : equals to 0, invalid file format, or not identifyable

@{B}Inputs:@{UB}      
- fid.l    : file object ID
- pos.l    : seek positon from where to analyse the file

@{B}Result:@{UB}      
- form.l   : file format identifier, e.g. @"AIFF" or @"MP3"

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetFineTuning "ffa_GetFineTuning"

@{B}ffa_GetFineTuning@{UB}

@{B}Syntax:@{UB}  fine.b = ffa_GetFineTuning \{fid.l\}

@{B}Description:@{UB}
Return the fine tuning of the wavesample.
The fine tuning is messured in "cents", 1 cent = 1/100 semi tone on a musical keyboard.
NOTE: Not all file formats support the tuning information. If not available, fine tune will be reported as 0.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- fine.b     : fine tuning, usually -50..+50 cents

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetFrameLength "ffa_GetFrameLength"

@{B}ffa_GetFrameLength@{UB}

@{B}Syntax:@{UB}  flength.l = ffa_GetFrameLength \{fid.l\}

@{B}Description:@{UB}
Return the sample frame length of the raw, uncompressed audio data.
NOTE: in a 16bit stereo file, one frame takes 2*2=4 bytes.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- flength.l     : sample frame length

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetFrameOffset "ffa_GetFrameOffset"

@{B}ffa_GetFrameOffset@{UB}

@{B}Syntax:@{UB}  result.l = ffa_GetFrameOffset \{fid.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- fid.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetFrameSize "ffa_GetFrameSize"

@{B}ffa_GetFrameSize@{UB}

@{B}Syntax:@{UB}  bytes.l = ffa_GetFrameSize \{fid.l\}

@{B}Description:@{UB}
Return the number of bytes of one uncompressed sample frame.
NOTE: 16bit stereo data has a frame size of 2*2=4 bytes.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- bytes.l  : frame size in bytes

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetLength "ffa_GetLength"

@{B}ffa_GetLength@{UB}

@{B}Syntax:@{UB}  result.l = ffa_GetLength \{fid.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- fid.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetLoop "ffa_GetLoop"

@{B}ffa_GetLoop@{UB}

@{B}Syntax:@{UB}  result.l = ffa_GetLoop \{fid.l\}

@{B}Description:@{UB}
Return the loop type of the wavesample (usually 0=no loop, 1=normal loop, 2=bidirectional loop).
NOTE: Not all file formats support this information. If not available, 0 is returned.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetLoopEnd "ffa_GetLoopEnd"

@{B}ffa_GetLoopEnd@{UB}

@{B}Syntax:@{UB}  offset.l = ffa_GetLoopEnd \{fid.l\}

@{B}Description:@{UB}
Get the loop end sample frame offset of the wavesample.
NOTE: Not all file formats support this information. If not available, the sample frame length is returned.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- offset.l     : sample frame offset

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetLoopStart "ffa_GetLoopStart"

@{B}ffa_GetLoopStart@{UB}

@{B}Syntax:@{UB}  offset.l = ffa_GetLoopStart \{fid.l\}

@{B}Description:@{UB}
Get the loop start sample frame offset of the wavesample.
NOTE: Not all file formats support this information. If not available, 0 will be returned.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- offset.l     : sample frame offset

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetRootKey "ffa_GetRootKey"

@{B}ffa_GetRootKey@{UB}

@{B}Syntax:@{UB}  rookey.b = ffa_GetRootKey \{fid.l\}

@{B}Description:@{UB}
Return the root key on a musical keyboard according the midi standard of the sample.
NOTE: Not all file formats support this information. If not available, the root key will be reported as -1.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- rookey.b     : root key (0...127) or -1 (not available)

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetSampleEnd "ffa_GetSampleEnd"

@{B}ffa_GetSampleEnd@{UB}

@{B}Syntax:@{UB}  offset.l = ffa_GetSampleEnd \{fid.l\}

@{B}Description:@{UB}
Return the actual end sample frame offset of the wavesample.
NOTE: Not all file formats support this information. If not available, sample start will be the last sample frame in the file.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- offset.l     : sample frame offset

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetSampleStart "ffa_GetSampleStart"

@{B}ffa_GetSampleStart@{UB}

@{B}Syntax:@{UB}  offset.l = ffa_GetSampleStart \{fid.l\}

@{B}Description:@{UB}
Return the actual start sample frame offset of the wavesample.
NOTE: Not all file formats support this information. If not available, sample start will be 0.

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- offset.l     : sample frame offset

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetSamplerate "ffa_GetSamplerate"

@{B}ffa_GetSamplerate@{UB}

@{B}Syntax:@{UB}  sr.l = ffa_GetSamplerate \{fid.l\}

@{B}Description:@{UB}
Return the samplerate of the file (in Hz)

@{B}Inputs:@{UB}      
- fid.l    : file object ID

@{B}Result:@{UB}      
- sr.l     : samplerate (=sample frequency)

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_GetSigned "ffa_GetSigned"

@{B}ffa_GetSigned@{UB}

@{B}Syntax:@{UB}  result.l = ffa_GetSigned \{fid.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- fid.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_ReadData "ffa_ReadData"

@{B}ffa_ReadData@{UB}

@{B}Syntax:@{UB}  succ.l = ffa_ReadData \{fid.l,ptr.l,d_blength.l,@channels.l,@bits.l,@samplerate.l\}

@{B}Description:@{UB}
Read some audiodata from the audiofile previously opened with @{" ffa_ReadHeader " link ffa_ReadHeader}.
The arguments specify the format of your destination data that can be different from the data in the file. Convertion will be done on the fly.

@{B}Inputs:@{UB}      
- fid.l        : file object ID
- ptr.l        : pointer to memory buffer
- d_blength.l  : maxmimum byte length of the buffer
- channels.l   : number of channels (default is the best match with the file)
Possible values are 1 and 2
- bits.l       : number of bits (default is the best match with the file)
Possible values are 8, 16, 24 and 32 bit
- samplerate.l : desired sample rate (default is same as file)

@{B}Result:@{UB}      
- succ.l       : -1 if everything went well, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_ReadHeader "ffa_ReadHeader"

@{B}ffa_ReadHeader@{UB}

@{B}Syntax:@{UB}  succ.l = ffa_ReadHeader \{filename.s,@checkform.l\}

@{B}Description:@{UB}
Open an audio file for reading and read the header information.
If the function succeeds, you are read to read audio data via @{" ffa_ReadData " link ffa_ReadData}.
NOTE: Is is not needed to call @{" ffa_ReadHeaderInfo " link ffa_ReadHeaderInfo} to get the specs audio file. ffa_readHeader is doing this already.

@{B}Inputs:@{UB}      
- filename.s    : file name
- checkform.l   : check for a valid file format

@{B}Result:@{UB}      
- succ.l        : -1 if everything went well, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ffa_ReadData " link ffa_ReadData}




@ENDNODE
@NODE ffa_ReadHeaderInfo "ffa_ReadHeaderInfo"

@{B}ffa_ReadHeaderInfo@{UB}

@{B}Syntax:@{UB}  succ.w = ffa_ReadHeaderInfo \{fid.l,@checkform.l\}

@{B}Description:@{UB}
Read the header information of an audio file.
The checkform parameter tell the function, if it should check the file for a known file format (-1), or if unknown file formats should be loaded as raw data without asking (0).
NOTE: Normally you do not need to call this function. This is only needed, if you read an audio file that is embedded in another file.

@{B}Inputs:@{UB}      
- fid.l       : file object ID
- checkform.l : -1= check file format, 0=read everything

@{B}Result:@{UB}      
- succ.l    : -1 if everything went well, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_ReportErrs "ffa_ReportErrs"

@{B}ffa_ReportErrs@{UB}

@{B}Syntax:@{UB} ffa_ReportErrs \{fid.l,bool.w\}

@{B}Description:@{UB}
Set if the file_audio.inlcude should report errors during operation\(-1) or suppress it (0).

@{B}Inputs:@{UB}      
- fid.l    : file object ID
- bool.w   : report errors during reading

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_Seek "ffa_Seek"

@{B}ffa_Seek@{UB}

@{B}Syntax:@{UB}  succ.l = ffa_Seek \{fid.l,fpos.l\}

@{B}Description:@{UB}
Seek within the audio file to a cetrain sample frame position.
NOTE: The acutal file position that result in this function can differ wastly with each file format.
NOTE: The next @{" ffa_ReadData " link ffa_ReadData} will read the data from the new position.

@{B}Inputs:@{UB}      
- fid.l    : file object ID
- fpos.l   : samnple frame position

@{B}Result:@{UB}      
- succ.l   : -1 if seek position was found, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_SetMode "ffa_SetMode"

@{B}ffa_SetMode@{UB}

@{B}Syntax:@{UB} ffa_SetMode \{fid.l,mode.l,quality.l\}

@{B}Description:@{UB}
Set some attributes about how conversion is done.
mode   : 1=left, 0=mix channels, -1=right
quality: 0=fast, ><0=high quality

@{B}Inputs:@{UB}      
- fid.l     : file object ID
- mode.l    : mode for stereo=>mono convertion
- quality.l : quality settings

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_WriteData "ffa_WriteData"

@{B}ffa_WriteData@{UB}

@{B}Syntax:@{UB}  succ.w = ffa_WriteData \{fid.l,ptr.l,s_blength.l,@channels.l,@bits.l,@samplerate.l\}

@{B}Description:@{UB}
Write some audio data to the audio file previously opened with @{" ffa_WriteHeader " link ffa_WriteHeader}.
The arguments specify the format of your source data that can be different from what you want to write to the file. Convertion will be done on the fly.

@{B}Inputs:@{UB}      
- fid.l        : file object ID
- ptr.l        : pointer to memory buffer
- s_blength.l  : length of the buffer
- channels.l   : number of channels (1=mono, 2=stereo)
- bits.l       : number of bits (usually 8, 16 or 24)
- samplerate.l : samplerate of the audio data

@{B}Result:@{UB}      
- succ.l       : -1 if all data was writte, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_WriteHeader "ffa_WriteHeader"

@{B}ffa_WriteHeader@{UB}

@{B}Syntax:@{UB}  succ.l = ffa_WriteHeader \{filename.s,form.l,channels.l,bits.l,samplerate.l,@flength.l,@askoverwrite.l,@setext.l\}

@{B}Description:@{UB}
Open an audio file for writing and write the header information. The file is read to take audio data by @{" ffa_WriteData " link ffa_WriteData}.
NOTE: There is no need to call @{" ffa_WriteHeaderInfo " link ffa_WriteHeaderInfo}, this is already done by this function.

@{B}Inputs:@{UB}      
- filename.s     : file name
- form.l         : form identifier, see ffa_GetFileFromat)
- channels.l     : number of channels (1=mono, 2=stereo)
- bits.l         : number of bits (usually 8, 16 or 24)
- samplerate.l   : samplerate in Hz
- flength.l      : expected sample frame length (if known)
- askoverwrite.l : ask before overwriting an exisitng file
- setext.l       : force a proper file extention

@{B}Result:@{UB}      
- succ.l     : -1 if everything went well, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_WriteHeaderInfo "ffa_WriteHeaderInfo"

@{B}ffa_WriteHeaderInfo@{UB}

@{B}Syntax:@{UB}  succ.w = ffa_WriteHeaderInfo \{fid.l,form.l,channels.l,bits.l,samplerate.l,@flength.l\}

@{B}Description:@{UB}
Write an audio file header to the already open file.
NOTE: This function is only needed, if you plan to embedd an audio file into another file.

@{B}Inputs:@{UB}      
- fid.l        : file object ID
- form.l       : file format identifier
- channels.l   : number of channels (1=mono, 2=stereo)
- bits.l       : number of bits (usually 8, 16 or 24)
- samplerate.l : samplerate in Hz
- flength.l    : expected sample frame length (if known)

@{B}Result:@{UB}      
- succ.l       : -1 if file header was written, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_WriteSampleInfo "ffa_WriteSampleInfo"

@{B}ffa_WriteSampleInfo@{UB}

@{B}Syntax:@{UB}  succ.l = ffa_WriteSampleInfo \{fid.l,rootkey.l,fine.l,@loop_start.l,@loop_end.l\}

@{B}Description:@{UB}
Write additional sample information to a file.
NOTE: This function has only effect on file formats that support this informations.

@{B}Inputs:@{UB}      
- fid.l        : file object ID
- rootkey.l    : root key on musical midi keyboard
- fine.l       : fine tuning in cents
- loop_start.l : sample frame offset for loop start
- loop_end.l   : sample frame offset for loop end

@{B}Result:@{UB}      
- succ.l     : -1 if everything went well, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_ms2off "ffa_ms2off"

@{B}ffa_ms2off@{UB}

@{B}Syntax:@{UB}  result.l = ffa_ms2off \{fid.l,ms.l\}

@{B}Description:@{UB}
Convert a millisecond offset to a sample frame offset value within the wavefile.

@{B}Inputs:@{UB}      
- fid.l   : file object ID
- ms.l    : offset in ms

@{B}Result:@{UB}      
- result.l     : offset in sample frames

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ffa_off2ms "ffa_off2ms"

@{B}ffa_off2ms@{UB}

@{B}Syntax:@{UB}  result.l = ffa_off2ms \{fid.l,offset.l\}

@{B}Description:@{UB}
convert an offset in sample frames to milliseconds.

@{B}Inputs:@{UB}      
- fid.l    : file object ID
- offset.l    : sample frame offset

@{B}Result:@{UB}      
- result.l     : ms offset

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
