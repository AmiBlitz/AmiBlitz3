@Database "AB3Includes"
@Width 80
@font helvetica.font 13
@wordwrap
@TAB 3

@NODE main "ahi.include"

@{B}ahi.include@{UB}

@{B}Abstract@{UB}

   @{" Introduction " link Introduction} 

@{B}Public Function Index:@{UB}

   @{" ahi_Bytes2Samps " link ahi_Bytes2Samps} 
   @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer} 
   @{" ahi_CheckRecBuffer " link ahi_CheckRecBuffer} 
   @{" ahi_CloseAllStreams " link ahi_CloseAllStreams} 
   @{" ahi_CloseDevice " link ahi_CloseDevice} 
   @{" ahi_CloseStream " link ahi_CloseStream} 
   @{" ahi_ConfigVisual " link ahi_ConfigVisual} 
   @{" ahi_CreateSound " link ahi_CreateSound} 
   @{" ahi_DoStream " link ahi_DoStream} 
   @{" ahi_Free " link ahi_Free} 
   @{" ahi_FreeAllSounds " link ahi_FreeAllSounds} 
   @{" ahi_FreeOut " link ahi_FreeOut} 
   @{" ahi_FreeSound " link ahi_FreeSound} 
   @{" ahi_GetFreeSound " link ahi_GetFreeSound} 
   @{" ahi_GetOutBufferByteSize " link ahi_GetOutBufferByteSize} 
   @{" ahi_GetOutBufferFrameSize " link ahi_GetOutBufferFrameSize} 
   @{" ahi_GetOutBufferNum " link ahi_GetOutBufferNum} 
   @{" ahi_GetOutBufferPtr " link ahi_GetOutBufferPtr} 
   @{" ahi_GetOutTimeindex " link ahi_GetOutTimeindex} 
   @{" ahi_GetRecTimeindex " link ahi_GetRecTimeindex} 
   @{" ahi_GetSampleForm " link ahi_GetSampleForm} 
   @{" ahi_GetSamplerate " link ahi_GetSamplerate} 
   @{" ahi_GetSigFlag " link ahi_GetSigFlag} 
   @{" ahi_GetSoundDataPtr " link ahi_GetSoundDataPtr} 
   @{" ahi_GetStreamFid " link ahi_GetStreamFid} 
   @{" ahi_GetStreamPos " link ahi_GetStreamPos} 
   @{" ahi_GetVisualOut " link ahi_GetVisualOut} 
   @{" ahi_InitOut " link ahi_InitOut} 
   @{" ahi_InitRec " link ahi_InitRec} 
   @{" ahi_IsOpen " link ahi_IsOpen} 
   @{" ahi_IsOutQuiet " link ahi_IsOutQuiet} 
   @{" ahi_JumpStreamPos " link ahi_JumpStreamPos} 
   @{" ahi_LoadSound " link ahi_LoadSound} 
   @{" ahi_OpenDevice " link ahi_OpenDevice} 
   @{" ahi_OpenStream " link ahi_OpenStream} 
   @{" ahi_PlaySound " link ahi_PlaySound} 
   @{" ahi_ReadRecBuffer " link ahi_ReadRecBuffer} 
   @{" ahi_SaveSound " link ahi_SaveSound} 
   @{" ahi_SetOutTimeindex " link ahi_SetOutTimeindex} 
   @{" ahi_SetOutVolume " link ahi_SetOutVolume} 
   @{" ahi_SetSoundFreq " link ahi_SetSoundFreq} 
   @{" ahi_SetSoundPan " link ahi_SetSoundPan} 
   @{" ahi_SetSoundVolume " link ahi_SetSoundVolume} 
   @{" ahi_SetStreamFade " link ahi_SetStreamFade} 
   @{" ahi_SetStreamLoop " link ahi_SetStreamLoop} 
   @{" ahi_Stop " link ahi_Stop} 
   @{" ahi_StopRec " link ahi_StopRec} 
   @{" ahi_StopSound " link ahi_StopSound} 
   @{" ahi_WaitOut " link ahi_WaitOut} 
   @{" ahi_WaitOutFinish " link ahi_WaitOutFinish} 
   @{" ahi_WaitRec " link ahi_WaitRec} 
   @{" ahi_WriteOutBuffer " link ahi_WriteOutBuffer} 

@{B}Private Function Index:@{UB}

   @{" _ahi_GetPeak " link _ahi_GetPeak} 
   @{" _ahi_Init " link _ahi_Init} 
   @{" _ahi_Merge " link _ahi_Merge} 
   @{" _ahi_RenderFade " link _ahi_RenderFade} 
   @{" _ahi_RenderGain " link _ahi_RenderGain} 

@{B}Public Macro Index:@{UB}

 * no macros defined * 

@ENDNODE
@NODE Introduction "Introduction"

@{B}Name:@{UB} ahi_device.include

@{B}Platforms:@{UB} Classic, WinUAE, Amithlon, MorphOS, AmigaOS4

@{B}Date:@{UB} 11.03.2006

@{B}Author:@{UB} Thilo Koehler

@{B}Requirements:@{UB} AHI v4+, Amiblitz2.4

@{B}Purpose:@{UB}
Replace most sound commands of BlitzBasic with AHI compatible ones
and add some new functionality like streaming.

@{B}Abstract:@{UB}
This include provides a lot of commands to play single sounds via AHI system as well as streaming from disk. It also supports recording audio via AHI.

The standard usage is to load some sounds using @{" ahi_LoadSound " link ahi_LoadSound}, open the ahi.device using @{" ahi_OpenDevice " link ahi_OpenDevice}, and then play the sounds using @{" ahi_PlaySound " link ahi_PlaySound}.
The "sounds" are called Sound Objects, because they can be seen like BlitzBasic Objects.

Streaming is initiated by @{" ahi_OpenStream " link ahi_OpenStream}. The stream will start the first time you call @{" ahi_DoStream " link ahi_DoStream}. You have to call this function in regular intervals, fast enough to not get buffer underruns.
You can wait for new buffers using the ahi_GetOutSiglfag in your Wait_() command, or simply call it every frame in your gameloop. Streams can also be looped and faded.

The include support .aiff, .wav, .8svx, .maud, .mp3, .mp2 and .cdda files (such as created by MakeCD).

@{B}User Constants:@{UB}
#max_ahisounds   = 100
Number of samples (Sound Objects) you are going to use, replaces the sound BB2 Object

#max_ahichannels = 32
Number of simultaneous channels you need, Paula had 4 channels, we can have more...
Remember that the user has to set this amount of channels in the AHI preferences, otherwise it will work but they are cutted faster of.

#max_ahistreams = 4
Number of streams you can play simultaniously.

@{B}Example:@{UB}     
Just load and play a sound !
__________________________________________________________________ snip!

#max_ahisounds = 5
#max_ahichannels = 4
XINCLUDE "ahi_device.include.ab3"

If ahi_OpenDevice\{0\}  ; open ahi.device unit 0
  If ahi_LoadSound0,"DH0:MySound.wav"\}
    ahi_PlaySound\{0\}                 ; play the sound!
  End If
End If
End
__________________________________________________________________ snip!

Play a stream from disk:
__________________________________________________________________ snip!

XINCLUDE "ahi_device.include.ab3"

If ahi_OpenDevice\{0\} ; open ahi.device unit 0
  If ahi_OpenStream\{filename.s,1000\} ; 1000ms buffer
    While ahi_DoStream\{\}
      ahi_WaitStream\{\} ; or do somehing meaningful here
    Wend
    ahi_WaitStreamFinish\{\}
  End If
End If
End
__________________________________________________________________ snip!



@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ahi_GetPeak "_ahi_GetPeak"

@{B}_ahi_GetPeak@{UB}

@{B}Syntax:@{UB}  result.l = _ahi_GetPeak \{startaddr.l,flength.l,visual.l\}

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      
- startaddr.l    : ???
- flength.l    : ???
- visual.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ahi_Init "_ahi_Init"

@{B}_ahi_Init@{UB}

@{B}Syntax:@{UB} result.l = _ahi_Init \{\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ahi_Merge "_ahi_Merge"

@{B}_ahi_Merge@{UB}

@{B}Syntax:@{UB} _ahi_Merge \{destptr.l,sourceptr.l,blength.l,gain.l,bits.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- destptr.l    : ???
- sourceptr.l    : ???
- blength.l    : ???
- gain.l    : ???
- bits.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ahi_RenderFade "_ahi_RenderFade"

@{B}_ahi_RenderFade@{UB}

@{B}Syntax:@{UB} _ahi_RenderFade \{stream.l,destptr.l,sourceptr.l,blength.l,channels.l,bits.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- stream.l    : ???
- destptr.l    : ???
- sourceptr.l    : ???
- blength.l    : ???
- channels.l    : ???
- bits.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _ahi_RenderGain "_ahi_RenderGain"

@{B}_ahi_RenderGain@{UB}

@{B}Syntax:@{UB} _ahi_RenderGain \{ptr.l,blength.l,gain.l,bits.l\}

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      
- ptr.l      : pointer to an audio buffer
- blength.l  : byte length of audio buffer
- gain.l     : gain 0...256
- bits.l     : bit depth of audio data

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_Bytes2Samps "ahi_Bytes2Samps"

@{B}ahi_Bytes2Samps@{UB}

@{B}Syntax:@{UB}  samps.l = ahi_Bytes2Samps \{bytes.l\}

@{B}Description:@{UB}
Return the number of sampleframes for the given number of bytes.
Teh function uses therefore the currently opened AHI unit.
The ahi.device must be successfully opened before using AHI_open.

@{B}Inputs:@{UB}      
- bytes.l    : Number of bytes

@{B}Result:@{UB}      
- samps.l    : Number of sampleframes

@{B}Example:@{UB}                                                -


@{B}Bugs:@{UB}        none



@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_CheckOutBuffer "ahi_CheckOutBuffer"

@{B}ahi_CheckOutBuffer@{UB}

@{B}Syntax:@{UB}  succ.l = ahi_CheckOutBuffer \{\}

@{B}Description:@{UB}
Check if there is an audio buffer to fill and retrun -1 if successful, 0 otherwise. You need this function only, if you want to fill the buffers with your own rendered data. If you just open an audiofile using @{" ahi_OpenStream " link ahi_OpenStream}, calling @{" ahi_DoStream " link ahi_DoStream} is enough.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- succ.l     : -1 if there is an empty buffer waiting, or 0 if all buffers are still full

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_CheckRecBuffer "ahi_CheckRecBuffer"

@{B}ahi_CheckRecBuffer@{UB}

@{B}Syntax:@{UB}  result.l = ahi_CheckRecBuffer \{\}

@{B}Description:@{UB}
Check if a recording buffer is full and ready to be read out.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : -1 if the last buffer is full

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_CloseAllStreams "ahi_CloseAllStreams"

@{B}ahi_CloseAllStreams@{UB}

@{B}Syntax:@{UB} ahi_CloseAllStreams \{\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_CloseDevice "ahi_CloseDevice"

@{B}ahi_CloseDevice@{UB}

@{B}Syntax:@{UB} ahi_CloseDevice \{\}

@{B}Description:@{UB}
Close the ahi.device and cleans up everything that was allocated by @{" ahi_OpenDevice " link ahi_OpenDevice}.
It is safe to call this twice or if AHI was not opened.
This function calls @{" ahi_Stop " link ahi_Stop}, @{" ahi_CloseAllStreams " link ahi_CloseAllStreams}.
This function is called on autoexit, so you dont have to call it manually, even if it is a good idea to keep a good coding style.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_CloseStream "ahi_CloseStream"

@{B}ahi_CloseStream@{UB}

@{B}Syntax:@{UB} ahi_CloseStream \{@stream.l\}

@{B}Description:@{UB}
Stop and close a stream. It is save to call this function twice, or if no stream is playing.

@{B}Inputs:@{UB}      
- stream.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_ConfigVisual "ahi_ConfigVisual"

@{B}ahi_ConfigVisual@{UB}

@{B}Syntax:@{UB} ahi_ConfigVisual \{smoothness.l,norm.l,square.w\}

@{B}Description:@{UB}
Configure the attributes how the visual information of @{" ahi_GetVisualOut " link ahi_GetVisualOut} will be formatted.

@{B}Inputs:@{UB}      
- smoothness.l  : speed of level changes [0=fast, 99=very slow]
- norm.l        : maximum level, e.g. 100
- square.w      : make the square root of the peaks, looks more like the ears "hears" the signal

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_CreateSound "ahi_CreateSound"

@{B}ahi_CreateSound@{UB}

@{B}Syntax:@{UB}  succ.l = ahi_CreateSound \{snd.l,blength.l,samplerate.l,channels.l,bits.l\}

@{B}Description:@{UB}
Create a new, blank sound, ready to be filled with your own data.
This makes only sense if you want to generate a soundwave. If you want to load a Sound from disk, use ahi_sound_load instead.

@{B}Inputs:@{UB}      
- snd.l    : Sound Object number
- blength.l    : byte length (= [bits*channels / 8] * samples)
- samplerate.l    : desired samplrate, can be much higher or lower than the ahi.device unit offers
- channels.l    : number of channels, can be 1 (=mono) or 2 (=stereo)
- bits.l    : number of bits, can be 8 or 16

@{B}Result:@{UB}      
- succ.l:     -1 if everything went well, 0 if there was an error and nothing is allocated

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_SaveSound " link ahi_SaveSound}, @{" ahi_FreeSound " link ahi_FreeSound}




@ENDNODE
@NODE ahi_DoStream "ahi_DoStream"

@{B}ahi_DoStream@{UB}

@{B}Syntax:@{UB}  succ.l = ahi_DoStream \{\}

@{B}Description:@{UB}
Check if there are pending free buffers using @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer}, and fill it with audio data from disk, if one or more streams is opened using @{" ahi_OpenStream " link ahi_OpenStream}.
Don't use this if you init your stream using @{" ahi_InitOut " link ahi_InitOut} and plan to fill it with your own rendered data. Only use this function, if you open directly a file using @{" ahi_OpenStream " link ahi_OpenStream}.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- succ.l     : -1 if there was a buffer to fill, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_Free "ahi_Free"

@{B}ahi_Free@{UB}

@{B}Syntax:@{UB} ahi_Free \{\}

@{B}Description:@{UB}
Eventually close ahi.device and free everything that is associated with this include.
This function calls @{" ahi_FreeAllSounds " link ahi_FreeAllSounds}, @{" ahi_CloseAllStreams " link ahi_CloseAllStreams} and @{" ahi_CloseDevice " link ahi_CloseDevice}.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_FreeAllSounds "ahi_FreeAllSounds"

@{B}ahi_FreeAllSounds@{UB}

@{B}Syntax:@{UB} ahi_FreeAllSounds \{\}

@{B}Description:@{UB}
Free all Sound Objects.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_FreeOut "ahi_FreeOut"

@{B}ahi_FreeOut@{UB}

@{B}Syntax:@{UB} ahi_FreeOut \{\}

@{B}Description:@{UB}
Free a stream created using ahi_stream_init. It is save to call this function twice, or if no stream was initiated.
Use @{" ahi_CloseStream " link ahi_CloseStream}, if you created the stream using @{" ahi_OpenStream " link ahi_OpenStream}.
Note: you can always use @{" ahi_CloseAllStreams " link ahi_CloseAllStreams}.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_InitOut " link ahi_InitOut}, @{" ahi_CloseAllStreams " link ahi_CloseAllStreams}




@ENDNODE
@NODE ahi_FreeSound "ahi_FreeSound"

@{B}ahi_FreeSound@{UB}

@{B}Syntax:@{UB} ahi_FreeSound \{snd.l\}

@{B}Description:@{UB}
Free the given Sound Object.

@{B}Inputs:@{UB}      
- snd.l    : Sound Object number to free

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_LoadSound " link ahi_LoadSound}, @{" ahi_CreateSound " link ahi_CreateSound}




@ENDNODE
@NODE ahi_GetFreeSound "ahi_GetFreeSound"

@{B}ahi_GetFreeSound@{UB}

@{B}Syntax:@{UB}  snd.l = ahi_GetFreeSound \{\}

@{B}Description:@{UB}
Find a free Sound Object number, ready for use with @{" ahi_LoadSound " link ahi_LoadSound} or @{" ahi_CreateSound " link ahi_CreateSound}.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- snd.l     : Sound Object number

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_LoadSound " link ahi_LoadSound}, @{" ahi_CreateSound " link ahi_CreateSound}




@ENDNODE
@NODE ahi_GetOutBufferByteSize "ahi_GetOutBufferByteSize"

@{B}ahi_GetOutBufferByteSize@{UB}

@{B}Syntax:@{UB}  bsize.l = ahi_GetOutBufferByteSize \{\}

@{B}Description:@{UB}
Return the size in bytes of the audio double buffer that has to be filled next, after @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer} returned success.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- bsize.l     : size in bytes of the audio buffer

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer}, @{" ahi_GetOutBufferFrameSize " link ahi_GetOutBufferFrameSize}




@ENDNODE
@NODE ahi_GetOutBufferFrameSize "ahi_GetOutBufferFrameSize"

@{B}ahi_GetOutBufferFrameSize@{UB}

@{B}Syntax:@{UB}  fsize.l = ahi_GetOutBufferFrameSize \{\}

@{B}Description:@{UB}
Return the size in sampleframes of the audio double buffer that has to be filled next, after ahi_stream_check returned success.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- fsize.l     : size of the buffer in sampleframes

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer}, @{" ahi_GetOutBufferPtr " link ahi_GetOutBufferPtr}, @{" ahi_GetOutBufferByteSize " link ahi_GetOutBufferByteSize}




@ENDNODE
@NODE ahi_GetOutBufferNum "ahi_GetOutBufferNum"

@{B}ahi_GetOutBufferNum@{UB}

@{B}Syntax:@{UB}  buffer.l = ahi_GetOutBufferNum \{\}

@{B}Description:@{UB}
Return the number of the audio double buffer that has to be filled next, after @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer} returned success.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- buffer.l     : number of the audio buffer to be filled next

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_GetOutBufferPtr "ahi_GetOutBufferPtr"

@{B}ahi_GetOutBufferPtr@{UB}

@{B}Syntax:@{UB}  ptr.l = ahi_GetOutBufferPtr \{\}

@{B}Description:@{UB}
Return the memory pointer to the audio double buffer that has to be filled next, after @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer} returned success.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- ptr.l     : memory pointer to the audio buffer data

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer}




@ENDNODE
@NODE ahi_GetOutTimeindex "ahi_GetOutTimeindex"

@{B}ahi_GetOutTimeindex@{UB}

@{B}Syntax:@{UB}  timeindex.l =  ahi_GetOutTimeindex \{\}

@{B}Description:@{UB}
Return the number of samples that have been played yet in double buffering. It is not very accurate but better than nothing.
You can reset the counter using @{" ahi_SetOutTimeindex " link ahi_SetOutTimeindex}.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- timeindex.l     : counter in samples

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_SetOutTimeindex " link ahi_SetOutTimeindex}




@ENDNODE
@NODE ahi_GetRecTimeindex "ahi_GetRecTimeindex"

@{B}ahi_GetRecTimeindex@{UB}

@{B}Syntax:@{UB}  result.l =  ahi_GetRecTimeindex \{\}

@{B}Description:@{UB}
Get the timeindex since @{" ahi_InitRec " link ahi_InitRec}.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : timeindex in sampleframes

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_GetSampleForm "ahi_GetSampleForm"

@{B}ahi_GetSampleForm@{UB}

@{B}Syntax:@{UB}  AHI_form.l = ahi_GetSampleForm \{channels.w,bits.w,signed.w\}

@{B}Description:@{UB}
Return the AHI sampleformat code for the given audio specs.

@{B}Inputs:@{UB}      
- channels.w  : number of channels, 1 (=mono) or 2 (=stereo)
- bits.w      : number of bits (8 or 16)
- signed.w    : True or False, wether it is signed or unsigned (usually signed)

@{B}Result:@{UB}      
- AHI_form.l  : AHI specific id number that characterizes the sample format

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_GetSamplerate "ahi_GetSamplerate"

@{B}ahi_GetSamplerate@{UB}

@{B}Syntax:@{UB}  result.l = ahi_GetSamplerate \{\}

@{B}Description:@{UB}
Get the samplerate at that the ahi.device is running right now.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : samplerate in Hz

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_GetSigFlag "ahi_GetSigFlag"

@{B}ahi_GetSigFlag@{UB}

@{B}Syntax:@{UB}  sigflag.l = ahi_GetSigFlag \{\}

@{B}Description:@{UB}
Return the ahi.device sigflag, which can be used to Wait_() for a new buffer in a stream. However, @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer} has still to be successfully called in order to access the next buffer.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- sigflag.l     : signal flag for use e.g. with the Wait_() OS function.

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer}, @{" ahi_DoStream " link ahi_DoStream}




@ENDNODE
@NODE ahi_GetSoundDataPtr "ahi_GetSoundDataPtr"

@{B}ahi_GetSoundDataPtr@{UB}

@{B}Syntax:@{UB}  memptr.l = ahi_GetSoundDataPtr \{snd.l\}

@{B}Description:@{UB}
Get the pointer to the sample data.

@{B}Inputs:@{UB}      
- snd.l     : the sound object number

@{B}Result:@{UB}      
- memptr.l  : memory pointer to the raw sample data

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_CreateSound " link ahi_CreateSound}




@ENDNODE
@NODE ahi_GetStreamFid "ahi_GetStreamFid"

@{B}ahi_GetStreamFid@{UB}

@{B}Syntax:@{UB}  result.l = ahi_GetStreamFid \{@stream.l\}

@{B}Description:@{UB}
Get the file object ID of the file that is associated with the stream.

@{B}Inputs:@{UB}      
- stream.l  : stream object number

@{B}Result:@{UB}      
- result.l     : fid of audio file (see file.include)

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_GetStreamPos "ahi_GetStreamPos"

@{B}ahi_GetStreamPos@{UB}

@{B}Syntax:@{UB}  pos.l = ahi_GetStreamPos \{@stream.l\}

@{B}Description:@{UB}
Get the current playback position of an audio stream in milliseconds.

@{B}Inputs:@{UB}      
- stream.l  : stream object number

@{B}Result:@{UB}      
- pos.l     : playback position in ms

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_GetVisualOut "ahi_GetVisualOut"

@{B}ahi_GetVisualOut@{UB}

@{B}Syntax:@{UB}  result.l = ahi_GetVisualOut \{\}

@{B}Description:@{UB}
Get peak level infromation about the current playback for visual display.
The peak of the left and right channel are encoded in the upper and lower word of the longword result.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : peaks of the left and right channel

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_ConfigVisual " link ahi_ConfigVisual}




@ENDNODE
@NODE ahi_InitOut "ahi_InitOut"

@{B}ahi_InitOut@{UB}

@{B}Syntax:@{UB}  succ.l = ahi_InitOut \{buffersize.l,channels.l,bits.l,samplerate.l,@gain.l\}

@{B}Description:@{UB}
Init the system for double buffered output stream.
Buffersize is the size for each buffer in bytes (doublebuffering).
Samplerate is the samplerate you want to use for doublebuffering playback and NOT neccessarily the samplerate the audio hardware is allocated with.
Use this function, if you plan to output audio data rendered by your own. If you just want to play back a file, use the higher level function @{" ahi_OpenStream " link ahi_OpenStream}, as this is doing file i/o already for you.
Use this function in combination with @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer} to see if there is an empty buffer waiting to be filled and retrieve the memory pointer with @{" ahi_GetOutBufferPtr " link ahi_GetOutBufferPtr} and the length with @{" ahi_GetOutBufferByteSize " link ahi_GetOutBufferByteSize}.

@{B}Inputs:@{UB}      
- buffersize.l   : size of each buffer in bytes
- channels.l     : number of channels, 1 (=mono) or 2(=stereo)
- bits.l         : number of bits, either 8 or 16
- samplerate.l   : samplerate of the audio sdata that is planned to feedinto the stream
- gain.l         : volume gain of this stream

@{B}Result:@{UB}      
- succ.l         : -1 if everything went well, 0 if it failed

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer}, @{" ahi_FreeOut " link ahi_FreeOut}




@ENDNODE
@NODE ahi_InitRec "ahi_InitRec"

@{B}ahi_InitRec@{UB}

@{B}Syntax:@{UB}  result.l = ahi_InitRec \{@samplerate.l,@sampleformat.l\}

@{B}Description:@{UB}
Init and start audio recording. Use @{" ahi_ReadRecBuffer " link ahi_ReadRecBuffer} to put a buffer into the queue and use @{" ahi_CheckRecBuffer " link ahi_CheckRecBuffer} for incoming audio data.

@{B}Inputs:@{UB}      
- samplerate.l   : desired samplerate
- sampleformat.l : desired sampleformat, e.g. #AHIST_S16S

@{B}Result:@{UB}      
- result.l       : -1 if everything went ok, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_GetSampleForm " link ahi_GetSampleForm}, @{" ahi_CheckRecBuffer " link ahi_CheckRecBuffer}, @{" ahi_ReadRecBuffer " link ahi_ReadRecBuffer}




@ENDNODE
@NODE ahi_IsOpen "ahi_IsOpen"

@{B}ahi_IsOpen@{UB}

@{B}Syntax:@{UB}  result.l = ahi_IsOpen \{\}

@{B}Description:@{UB}
Check if the ahi.device was opened using @{" ahi_OpenDevice " link ahi_OpenDevice}.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : -1 if ahi.device is open, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_IsOutQuiet "ahi_IsOutQuiet"

@{B}ahi_IsOutQuiet@{UB}

@{B}Syntax:@{UB}  succ.l = ahi_IsOutQuiet \{\}

@{B}Description:@{UB}
Check if something is playing on the stream or not.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- succ.l     : -1 if nothing is playing, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_JumpStreamPos "ahi_JumpStreamPos"

@{B}ahi_JumpStreamPos@{UB}

@{B}Syntax:@{UB} ahi_JumpStreamPos \{ms.l,@stream.l\}

@{B}Description:@{UB}
"Jump" (or seek) to a specific timestamp within the stream. This requires to have the stream created on a file using @{" ahi_OpenStream " link ahi_OpenStream}.

@{B}Inputs:@{UB}      
- ms.l     : new position within the audio file in milliseconds
- stream.l : stream object number

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_LoadSound "ahi_LoadSound"

@{B}ahi_LoadSound@{UB}

@{B}Syntax:@{UB}  succ.l = ahi_LoadSound \{snd.l,filename.s\}

@{B}Description:@{UB}
Load an audio file from disk into a Sound Object, ready to be played by @{" ahi_PlaySound " link ahi_PlaySound}.
Supported file formats are .aiff, .wav, .8svx (IFF), .maud, .cdda, .mp3, .mp2.

@{B}Inputs:@{UB}      
- snd.l      : Sound Object number
- filename.s : filename of the audio file

@{B}Result:@{UB}      
- succ.l     : -1 if the Sound Object was loaded, 0 if it failed

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_PlaySound " link ahi_PlaySound}, @{" ahi_FreeSound " link ahi_FreeSound}




@ENDNODE
@NODE ahi_OpenDevice "ahi_OpenDevice"

@{B}ahi_OpenDevice@{UB}

@{B}Syntax:@{UB}  succ.l = ahi_OpenDevice \{unit.l\}

@{B}Description:@{UB}
Opens the ahi.device and returns "True" if successful.

@{B}Inputs:@{UB}      
- unit.l    : ahi.device unit number, can be 0, 1, 2 or 3

@{B}Result:@{UB}      
- succ.l    : -1 if everything went well, 0 if the device could not be opened

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_CloseDevice " link ahi_CloseDevice}




@ENDNODE
@NODE ahi_OpenStream "ahi_OpenStream"

@{B}ahi_OpenStream@{UB}

@{B}Syntax:@{UB}  succ.l = ahi_OpenStream \{filename.s,buffersize.l,@speed.l,@gain.l,@native.l,@stream.l\}

@{B}Description:@{UB}
Create a stream using ahi_stream_init and associate an audiofile with the stream. If the stream is created, the first call of ahi_stream_do will start playback.
All you have to do is call ahi_stream_do in regular intervals to fill the buffers automatically with the data from the audio file. No need to call ahi_stream_check or the ahi_stream_next_??? functions.

It supports .aiff, .wav, .8svx (IFF), .maud, .cdda, .mp3 and .mp2 files.

Note: unlike the low level function ahi_stream_init, this function takes the buffersize in milliseconds.

@{B}Inputs:@{UB}      
- filename.s    : filename of the audio file
- buffersize.l    : size for one audio buffer in milliseconds
- speed.l    : change the playback speed in percent, default is 100 %.
- gain.l    : ???
- native.l    : ???
- stream.l    : ???

@{B}Result:@{UB}      
- succ.l     : -1 if the stream was opened, 0 if it failed

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    ahi_stream_do, ahi_stream_close




@ENDNODE
@NODE ahi_PlaySound "ahi_PlaySound"

@{B}ahi_PlaySound@{UB}

@{B}Syntax:@{UB} ahi_PlaySound \{snd.l,@gain.q,@pan.q,@samplerate.l\}

@{B}Description:@{UB}
Play a sound back via ahi.device. The device must be opened using ahi_open and the Sound Object must be loaded using @{" ahi_LoadSound " link ahi_LoadSound} before.

The optional parameters are set as the new default parameters and will be remembered for the next call of ahi_PlaySound, if they are not overwritten.

@{B}Inputs:@{UB}      
- snd.l        : Sound Object number
optional
- gain.q        : volume gain, where 1.0 is "normal" volume, 0.0 is completely silent, default is 1.0
- pan.q        : place in the stereo panorama, where 0.0 is left, 0.5 in the middle and 1.0 right, default is 0.5
- samplerate.l : desired samplerate, default is the samples native samplerate

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_ReadRecBuffer "ahi_ReadRecBuffer"

@{B}ahi_ReadRecBuffer@{UB}

@{B}Syntax:@{UB}  result.l = ahi_ReadRecBuffer \{ptr.l,blength.l\}

@{B}Description:@{UB}
Attach a memory block as an audio buffer to the recording queue.
The buffer will be filled with data specified in @{" ahi_InitRec " link ahi_InitRec}.

@{B}Inputs:@{UB}      
- ptr.l      : pointer to your buffer
- blength.l  : byte length of your buffer

@{B}Result:@{UB}      
- result.l   : -1 if everything went well, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_InitRec " link ahi_InitRec}, @{" ahi_CheckRecBuffer " link ahi_CheckRecBuffer}




@ENDNODE
@NODE ahi_SaveSound "ahi_SaveSound"

@{B}ahi_SaveSound@{UB}

@{B}Syntax:@{UB}  succ.l = ahi_SaveSound \{snd.l,filename.s,@form.l\}

@{B}Description:@{UB}
Save a sound as an audiofile to disk.

@{B}Inputs:@{UB}      
- snd.l      : sound object number
- filename.s : filename
- form.l     : form identifier:
@"AIFF" - aiff File
@"WAVE" - RIFF-WAVE file
@"8SVX" - IFF-8SVX file
@"MAUD" - IFF-MAUD file
@"CDDA" - CDDA image file
@"RAW"  - RAW data
@"MP3"  - MP3 via blademp3.library

@{B}Result:@{UB}      
- succ.l     : -1 if everything went well, 0 otherwise

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_SetOutTimeindex "ahi_SetOutTimeindex"

@{B}ahi_SetOutTimeindex@{UB}

@{B}Syntax:@{UB} ahi_SetOutTimeindex \{timeindex.l\}

@{B}Description:@{UB}
Set the timeindex for doublebuffering to the given value.
This can also be done during playback. The timeindex is just a counter for the already played samples. It will not cause the stream to jump.

@{B}Inputs:@{UB}      
- timeindex.l    : counter in samples

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_GetOutTimeindex " link ahi_GetOutTimeindex}




@ENDNODE
@NODE ahi_SetOutVolume "ahi_SetOutVolume"

@{B}ahi_SetOutVolume@{UB}

@{B}Syntax:@{UB} ahi_SetOutVolume \{gain.l\}

@{B}Description:@{UB}
Set the master volume for the out buffer (affects streams)

@{B}Inputs:@{UB}      
- gain.l    : master gain in % (0=silence, 100=normal level)

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_InitOut " link ahi_InitOut}, @{" ahi_FreeOut " link ahi_FreeOut}




@ENDNODE
@NODE ahi_SetSoundFreq "ahi_SetSoundFreq"

@{B}ahi_SetSoundFreq@{UB}

@{B}Syntax:@{UB} ahi_SetSoundFreq \{snd.l,samplerate.l\}

@{B}Description:@{UB}
Set the playback samplerate of a Sound Object.

@{B}Inputs:@{UB}      
- snd.l    : Sound Object number
- samplerate.l    : samplerate for playback

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_SetSoundPan " link ahi_SetSoundPan}, @{" ahi_SetSoundVolume " link ahi_SetSoundVolume}




@ENDNODE
@NODE ahi_SetSoundPan "ahi_SetSoundPan"

@{B}ahi_SetSoundPan@{UB}

@{B}Syntax:@{UB} ahi_SetSoundPan \{snd.l,pan.q\}

@{B}Description:@{UB}
Set the default place in stereo panorama.

@{B}Inputs:@{UB}      
- snd.l    : Sound Object number
- pan.q    : 0 = left, 0.5 = middle, 1.0 = right

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_SetSoundFreq " link ahi_SetSoundFreq}, @{" ahi_SetSoundVolume " link ahi_SetSoundVolume}




@ENDNODE
@NODE ahi_SetSoundVolume "ahi_SetSoundVolume"

@{B}ahi_SetSoundVolume@{UB}

@{B}Syntax:@{UB} ahi_SetSoundVolume \{snd.l,gain.q\}

@{B}Description:@{UB}
Set the default volume gain.

@{B}Inputs:@{UB}      
- snd.l    : Sound Object number
- gain.q    : 0 = quiet, 1.0 = full volume gain

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_SetSoundPan " link ahi_SetSoundPan}, @{" ahi_SetSoundFreq " link ahi_SetSoundFreq}




@ENDNODE
@NODE ahi_SetStreamFade "ahi_SetStreamFade"

@{B}ahi_SetStreamFade@{UB}

@{B}Syntax:@{UB} ahi_SetStreamFade \{startgain.l,endgain.l,mslength.l,@stream.l\}

@{B}Description:@{UB}
Initialize a gain change (fade) from startgain to endgain that takes mslength milliseconds.
The fade will start at the very next audio buffer when you call @{" ahi_DoStream " link ahi_DoStream}.
Note: after the fade is done, the gain will stay at endgain level.
Note: if endgain=0, the stream stop to play once the fade is done and @{" ahi_DoStream " link ahi_DoStream} will return False.

@{B}Inputs:@{UB}      
- startgain.l  : gain from where to start the fade in % (e.g. 100=normal level)
- endgain.l    : gain of the end of the fade in % (e.g. 0=complete silence)
- mslength.l   : time in ms the fade needs to get from startgain to endgain
- stream.l     : id of the affected stream

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_SetStreamLoop "ahi_SetStreamLoop"

@{B}ahi_SetStreamLoop@{UB}

@{B}Syntax:@{UB} ahi_SetStreamLoop \{startpos.l,@endepos.l,@stream.l\}

@{B}Description:@{UB}
Set the loop points for a stream. This way you can create endless background music.

Note: You can change the loop while the stream is playing. The changes will not cause a jump in the audio data.
After passing the old end positon, it will smoothly jump to the new start position and continue looping there. This way, you can create context dependent background music, e.g. having several patterns for several athmospheres and smoothly changing between them.

@{B}Inputs:@{UB}      
- startpos.l   : start position in milliseconds
- endepos.l    : end position in milliseconds
- stream.l     : stream object number

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_OpenStream " link ahi_OpenStream}, @{" ahi_DoStream " link ahi_DoStream}




@ENDNODE
@NODE ahi_Stop "ahi_Stop"

@{B}ahi_Stop@{UB}

@{B}Syntax:@{UB} ahi_Stop \{\}

@{B}Description:@{UB}
Stop all ahi activity immediately, stream, one shot sounds and recording.
This function is called within @{" ahi_CloseDevice " link ahi_CloseDevice}, to make sure that no sound is playing anymore before freeing the resources.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_IsOutQuiet " link ahi_IsOutQuiet}, @{" ahi_StopSound " link ahi_StopSound}, @{" ahi_StopRec " link ahi_StopRec}




@ENDNODE
@NODE ahi_StopRec "ahi_StopRec"

@{B}ahi_StopRec@{UB}

@{B}Syntax:@{UB} ahi_StopRec \{\}

@{B}Description:@{UB}
Stop recording.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_StopSound "ahi_StopSound"

@{B}ahi_StopSound@{UB}

@{B}Syntax:@{UB} ahi_StopSound \{snd.l\}

@{B}Description:@{UB}
Stop the given Sound Object immediately, if it is currently playing.

@{B}Inputs:@{UB}      
- snd.l    : Sound Object number

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_Stop " link ahi_Stop}




@ENDNODE
@NODE ahi_WaitOut "ahi_WaitOut"

@{B}ahi_WaitOut@{UB}

@{B}Syntax:@{UB} ahi_WaitOut \{\}

@{B}Description:@{UB}
Wait till there is an audio double buffer ready to fill. You can call ahi_stream_next_??? functions after this function returned.
It is the same like calling ahi_stream_check until it returns success.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer}, @{" ahi_GetOutBufferPtr " link ahi_GetOutBufferPtr}




@ENDNODE
@NODE ahi_WaitOutFinish "ahi_WaitOutFinish"

@{B}ahi_WaitOutFinish@{UB}

@{B}Syntax:@{UB} ahi_WaitOutFinish \{\}

@{B}Description:@{UB}
Wait till all pending double buffers are finished.
After this functions returned, you can call @{" ahi_CloseStream " link ahi_CloseStream} safely without stopping a buffer while it is still playing.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_InitOut " link ahi_InitOut}, @{" ahi_CloseAllStreams " link ahi_CloseAllStreams}




@ENDNODE
@NODE ahi_WaitRec "ahi_WaitRec"

@{B}ahi_WaitRec@{UB}

@{B}Syntax:@{UB}  result.l = ahi_WaitRec \{\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE ahi_WriteOutBuffer "ahi_WriteOutBuffer"

@{B}ahi_WriteOutBuffer@{UB}

@{B}Syntax:@{UB}  succ.l = ahi_WriteOutBuffer \{@blength.l\}

@{B}Description:@{UB}
Start the next buffer to play. If there is already another buffer playing this one will be queued.
blength is optional and determines the number of bytes that should be played, e.g. if you did not fill the complete buffer, you want only a part of it to be played.
If you leave this out the whole buffer will be played.
Note: call this function after @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer} returned True.

@{B}Inputs:@{UB}      
- blength.l    : number of bytes to play, default is the whole buffer

@{B}Result:@{UB}      
- succ.l     : -1 if everything went well, 0 if it failed (normally this does not happen)

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" ahi_CheckOutBuffer " link ahi_CheckOutBuffer}, @{" ahi_GetOutBufferPtr " link ahi_GetOutBufferPtr}




@ENDNODE
