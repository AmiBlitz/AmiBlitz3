@Database "AB3Includes"
@Width 80
@font helvetica.font 13
@wordwrap
@TAB 3

@NODE main "dbl_display.include"

@{B}dbl_display.include@{UB}

@{B}Abstract@{UB}

   @{" Introduction " link Introduction} 

@{B}Public Function Index:@{UB}

   @{" dbl_2ImgHit " link dbl_2ImgHit} 
   @{" dbl_BGBlit " link dbl_BGBlit} 
   @{" dbl_BGBlitPattern " link dbl_BGBlitPattern} 
   @{" dbl_BGBox " link dbl_BGBox} 
   @{" dbl_BGLine " link dbl_BGLine} 
   @{" dbl_BGPlot " link dbl_BGPlot} 
   @{" dbl_BGPrint " link dbl_BGPrint} 
   @{" dbl_BGScroll " link dbl_BGScroll} 
   @{" dbl_Fade " link dbl_Fade} 
   @{" dbl_Flip " link dbl_Flip} 
   @{" dbl_Free " link dbl_Free} 
   @{" dbl_FreeCollision " link dbl_FreeCollision} 
   @{" dbl_GetBGRPPtr " link dbl_GetBGRPPtr} 
   @{" dbl_GetDepth " link dbl_GetDepth} 
   @{" dbl_GetFPS " link dbl_GetFPS} 
   @{" dbl_GetFrameTime " link dbl_GetFrameTime} 
   @{" dbl_GetHeight " link dbl_GetHeight} 
   @{" dbl_GetPen " link dbl_GetPen} 
   @{" dbl_GetPenRGB " link dbl_GetPenRGB} 
   @{" dbl_GetRPPtr " link dbl_GetRPPtr} 
   @{" dbl_GetWidth " link dbl_GetWidth} 
   @{" dbl_HideMousePointer " link dbl_HideMousePointer} 
   @{" dbl_Hit " link dbl_Hit} 
   @{" dbl_ImgMaskHit " link dbl_ImgMaskHit} 
   @{" dbl_Init " link dbl_Init} 
   @{" dbl_InitCollision " link dbl_InitCollision} 
   @{" dbl_QBlit " link dbl_QBlit} 
   @{" dbl_QBlitScaled " link dbl_QBlitScaled} 
   @{" dbl_QBlitx " link dbl_QBlitx} 
   @{" dbl_QBox " link dbl_QBox} 
   @{" dbl_QDamage " link dbl_QDamage} 
   @{" dbl_QDamageArea " link dbl_QDamageArea} 
   @{" dbl_QLine " link dbl_QLine} 
   @{" dbl_QPlot " link dbl_QPlot} 
   @{" dbl_QPrint " link dbl_QPrint} 
   @{" dbl_QRefresh " link dbl_QRefresh} 
   @{" dbl_RemPlayField " link dbl_RemPlayField} 
   @{" dbl_Reset " link dbl_Reset} 
   @{" dbl_SetFPS " link dbl_SetFPS} 
   @{" dbl_SetPen " link dbl_SetPen} 
   @{" dbl_SetPenRGB " link dbl_SetPenRGB} 
   @{" dbl_SetPlayField " link dbl_SetPlayField} 
   @{" dbl_ShowMousePointer " link dbl_ShowMousePointer} 
   @{" dbl_Unqueue " link dbl_Unqueue} 

@{B}Public Macro Index:@{UB}

   @{" !dbl_GetDepth " link !dbl_GetDepth} 
   @{" !dbl_GetHeight " link !dbl_GetHeight} 
   @{" !dbl_GetPFHeight " link !dbl_GetPFHeight} 
   @{" !dbl_GetPFWidth " link !dbl_GetPFWidth} 
   @{" !dbl_GetPFX " link !dbl_GetPFX} 
   @{" !dbl_GetPFY " link !dbl_GetPFY} 
   @{" !dbl_GetRPPtr " link !dbl_GetRPPtr} 
   @{" !dbl_GetWidth " link !dbl_GetWidth} 

@ENDNODE
@NODE !dbl_GetDepth "!dbl_GetDepth"

@{B}!dbl_GetDepth@{UB}

@{B}Syntax:@{UB} !dbl_GetDepth

@{B}Description:@{UB}
Return the current color depth of the dbl display.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
color depth in bits

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !dbl_GetHeight "!dbl_GetHeight"

@{B}!dbl_GetHeight@{UB}

@{B}Syntax:@{UB} !dbl_GetHeight

@{B}Description:@{UB}
Return the current pixel height of the dbl display.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
pixel height of the dbl display

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !dbl_GetPFHeight "!dbl_GetPFHeight"

@{B}!dbl_GetPFHeight@{UB}

@{B}Syntax:@{UB} !dbl_GetPFHeight

@{B}Description:@{UB}
Return the current pixel height of the current playfield clip.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
pixel height of the current playfield clip

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !dbl_GetPFWidth "!dbl_GetPFWidth"

@{B}!dbl_GetPFWidth@{UB}

@{B}Syntax:@{UB} !dbl_GetPFWidth

@{B}Description:@{UB}
Return the current pixel width of the current playfield clip.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
pixel width of the current playfield clip

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !dbl_GetPFX "!dbl_GetPFX"

@{B}!dbl_GetPFX@{UB}

@{B}Syntax:@{UB} !dbl_GetPFX

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !dbl_GetPFY "!dbl_GetPFY"

@{B}!dbl_GetPFY@{UB}

@{B}Syntax:@{UB} !dbl_GetPFY

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !dbl_GetRPPtr "!dbl_GetRPPtr"

@{B}!dbl_GetRPPtr@{UB}

@{B}Syntax:@{UB} !dbl_GetRPPtr

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !dbl_GetWidth "!dbl_GetWidth"

@{B}!dbl_GetWidth@{UB}

@{B}Syntax:@{UB} !dbl_GetWidth

@{B}Description:@{UB}
Return the pixel width of the dbl display.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
pixel width of the dbl display

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE Introduction "Introduction"

@{B}Name:@{UB} dbl_display.include

@{B}Platforms:@{UB} Classic, WinUAE, Amithlon, AmigaOS4, MOS

@{B}Date:@{UB} 11.08.2006

@{B}Author:@{UB} Thilo Koehler

@{B}Requirements:@{UB} Amiblitz2.4, image.include

@{B}Purpose:@{UB}
Provide a 2D game interface for double buffered gfx, that runs fast on graphics cards on ALL systems, including Classic (in contrast to SDL).
The basic functionality works on AGA/OCS as well, but it might be slow. Some of the functions even require 16 or 24 or 32 bit screens.
It is possbile to do a 640x480x16 game on a Classic at 50 Hz!

@{B}Abstract:@{UB}
This include is ideal if you plan to write a 2D action game, that should use the graphicscard (e.g. 24bit), but still be fast enough to run on a Classic Amiga.
If you plan to write for WinUAE, Amithlon, AmigaOS4, MOS, you have even more possibilities like alpha channel, transparency and illuminations, also some simple 3D texture capabilities. This will work on Classic too, but it will be simply to slow.
Additional to the functions in this include, you can use ALL rastport based functions of the OS to draw things into the double buffered display, so there are no limitations.
There are several demos for the dbl.include, check them out to see whats possible!

@{B}User Constants:@{UB}

#dbl_method   = 1 (default)
0=few objects / 1=many objects, no overhead for scrolling
Note: if you plan a game with scrolling and a lot of objects, "1" is your choise. Use "0" only, if you want to save CPU power and you have few objects, lets say <10.

#max_dblqueue = 500 (default)
Maximum number of objects in dbl queue. This is only important for #dbl_method=0.
The dbl_queue remembers the blitted objects and can removes them with @{" dbl_Unqueue " link dbl_Unqueue}.

#use_cpublit  = 0 (default)
0=use blitter / 1=use CPU
Usually, you want to use the blitter!

#use_screenhack = 0 (default)
The screen hack is a little hack that opens a 3x higher screen to ensure that all double buffer bitmaps are in the video memory.
I removed it because the OS offers functionality for this. However, its a bit slower. If you want the scree hack back, set this to 1.
NOTE: Window mode will not be available anymore, as well as some flip methods.

@{B}Example:@{UB}     
See the Examples folder.



@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_2ImgHit "dbl_2ImgHit"

@{B}dbl_2ImgHit@{UB}

@{B}Syntax:@{UB}  succ.l =  dbl_2ImgHit \{image1.l,x1.l,y1.l,image2.l,x2.l,y2.l\}

@{B}Description:@{UB}
Test if image1 and image2 would hit (=do a collision) at the given coos.
The collision detection is based on their rectangle boundaries, but very fast.

@{B}Inputs:@{UB}      
- image1.l  : image object number
- x1.l      : x coordinate of image1
- y1.l      : y coordinate of image1
- image2.l  : image object number
- x2.l      : x coordinate of image2
- y2.l      : y coordinate of image2

@{B}Result:@{UB}      
- succ.l    : True if they collide, False if not

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_BGBlit "dbl_BGBlit"

@{B}dbl_BGBlit@{UB}

@{B}Syntax:@{UB} dbl_BGBlit \{image.l,x.l,y.l,@collision.l,@factor.f,@yfactor.f,@mode.l,@density.l\}

@{B}Description:@{UB}
Blit an image permanent to the background so that it does not disappear after unqueue.
This object will cause collision if collision is True and the collision is initialisized.

@{B}Inputs:@{UB}      
- image.l     : image you want to blit
- x.l         : x coordinate
- y.l         : y coordinate
- collision.l : optional, cause collision when set True or left out
- factor      : zooming factor (1.0 = same size, 2.0 = double size, 0.5 =half size
- yfactor.f   : optional y-zooming factor if you want to change the aspect
- mode.l      : one of
    #image_blitmode_opaque  = normal blitting, with bit mask if present
    #image_blitmode_trans   = transparent blitting acodoring denity
    #image_blitmode_alpha   = normal blitt with mask & alpha if present
    #image_blitmode_add     = pixels are added to the background
    #image_blitmode_sub     = pixels are substracted from the bg
- density.l   : 0-256, mix value for trans, add and sub blitting modes

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_BGBlitPattern "dbl_BGBlitPattern"

@{B}dbl_BGBlitPattern@{UB}

@{B}Syntax:@{UB} dbl_BGBlitPattern \{image.l,x.l,y.l,xs.l,ys.l,@xoff.l,@yoff.l,@collision.l\}

@{B}Description:@{UB}
Blit an image permanent to the background so that it does not disappear after unqueue.
If the size is bigger than the actual image, it is repeated. useful for repeating patterns.
This object will cause collision if collision is True and the collision is initialisized.

@{B}Inputs:@{UB}      
- image.l      : image you want to blit
- x.l         : x coordinate
- y.l         : y coordinate
- xs.l         : pixel width
- ys.l         : pixel height
- xoff.l       : x offset in source
- yoff.l       : y offset in source
- collision.l: optional, cause collision when set True or left out

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_BGBox "dbl_BGBox"

@{B}dbl_BGBox@{UB}

@{B}Syntax:@{UB} dbl_BGBox \{rgbval.l,x1.l,y1.l,x2.l,y2.l,@collision.l\}

@{B}Description:@{UB}
Draw a uni-color rectangle box into the background.
Note: this function is designed for True/Hi color screens!

@{B}Inputs:@{UB}      
- rgbval.l    : RGB value of the color, e.g. $FF00FF for pink
- x1.l    :  x1 coordinate
- y1.l    :  y1 coordinate
- x2.l    :  x2 coordinate
- y2.l    :  y2 coordinate
- collision.l: optional, cause collision when set True or left out

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_BGLine "dbl_BGLine"

@{B}dbl_BGLine@{UB}

@{B}Syntax:@{UB} dbl_BGLine \{rgbval.l,x1.l,y1.l,x2.l,y2.l,@collision.l\}

@{B}Description:@{UB}
Draw a uni-color line into the background.
Note: this function is designed for True/Hi color screens!

@{B}Inputs:@{UB}      
- rgbval.l    : RGB value of the color, e.g. $FF00FF for pink
- x1.l    :  x1 coordinate
- y1.l    :  y1 coordinate
- x2.l    :  x2 coordinate
- y2.l    :  y2 coordinate
- collision.l: optional, cause collision when set True or left out

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_BGPlot "dbl_BGPlot"

@{B}dbl_BGPlot@{UB}

@{B}Syntax:@{UB} dbl_BGPlot \{rgbval.l,x1.l,y1.l,@collision.l\}

@{B}Description:@{UB}
Draw a uni-color pixel into the background.
Note: this function is designed for True/Hi color screens!

@{B}Inputs:@{UB}      
- rgbval.l    : RGB value of the color, e.g. $FF00FF for pink
- x1.l    :  x1 coordinate
- y1.l    :  y1 coordinate
- collision.l: optional, cause collision when set True or left out

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_BGPrint "dbl_BGPrint"

@{B}dbl_BGPrint@{UB}

@{B}Syntax:@{UB} dbl_BGPrint \{text.s,x.l,y.l,@fgpen.l,@bgpen.l,@collision.l,@align.l,@valign.l\}

@{B}Description:@{UB}
Blit a text permanently to the background.

@{B}Inputs:@{UB}      
- text.s      : text you want to blit
- x.l         : x coordinate
- y.l         : y coordinate
- fgpen.l       : (optional) foreground pen
- bgpen.l       : (optional) background pen, transparent if left out
- collision.l   : 0 dont cause collision, or -1
- align.l       : (optional) -1=left, 0=center,1=right
- valign.l      : (optional) -1=top, 0=baseline,1=bottom

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_BGScroll "dbl_BGScroll"

@{B}dbl_BGScroll@{UB}

@{B}Syntax:@{UB} dbl_BGScroll \{dx.l,dy.l,@collision.l\}

@{B}Description:@{UB}
Scroll the background!

@{B}Inputs:@{UB}      
- dx.l         : amount of pixels in x direction
- dy.l         : amount of pixels in y direction
- collision.l    : scroll the collision mask as well

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_Fade "dbl_Fade"

@{B}dbl_Fade@{UB}

@{B}Syntax:@{UB} dbl_Fade \{rgbval.l,ratio.l,@nosnap.l\}

@{B}Description:@{UB}
Fade the whole display into the rgb value with ratio.l.
This can be used to fade the display to black or white, but also to indicate an "injury" to the player by fading short to red.
To do a fade on color index screens, it is necessary to manipulate the screens palette. To remember what the actutal palette was, this function makes a snapshot the original palette when it is called the first time.
If you want to force a snapshot later, use nosnap.l=False. Be sure that at this time the screen has the correct palette.
Note: The action on the display can continue while fading of course. This function is called on framewise, and can slowly change ratio.l to do a fade-out or fade-in effect.
Note: This works on color indexed and true/hi color screens! (but it can be very slow on true/hi color screens, depending on your system power)

@{B}Inputs:@{UB}      
- rgbval.l    : RGB value to fade the display to
- ratio.l     : ratio of fading 0=no incluence, 50=faded half/half, 100=display is faded completely
- nosnap.l    : False = use the current palette as the base palette, True= use the already "snapped" palette

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_Flip "dbl_Flip"

@{B}dbl_Flip@{UB}

@{B}Syntax:@{UB} dbl_Flip \{\}

@{B}Description:@{UB}
Switch the double buffer. This function has to be called when you have finished drawing your objects.
It also wait till the tiem frame passed, e.g. if you have set the system to 50fps, each frame takes 20ms.
If you spend 14ms on drawing, it will wait 6ms till the frame is over. If you set the fps to -1, it will return immediately.

@{B}Inputs:@{UB}      
none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_Free "dbl_Free"

@{B}dbl_Free@{UB}

@{B}Syntax:@{UB} dbl_Free \{\}

@{B}Description:@{UB}
Close the screen and free all resources assiciated with the dbl_display.include.
NOTE: This is executed on auto exit, but use this funktion if you need this earlier.

@{B}Inputs:@{UB}      
none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" dbl_Init " link dbl_Init}




@ENDNODE
@NODE dbl_FreeCollision "dbl_FreeCollision"

@{B}dbl_FreeCollision@{UB}

@{B}Syntax:@{UB} dbl_FreeCollision \{\}

@{B}Description:@{UB}
Free all resources associated with the collision bitmap.
NOTE: For internal use only!

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_GetBGRPPtr "dbl_GetBGRPPtr"

@{B}dbl_GetBGRPPtr@{UB}

@{B}Syntax:@{UB}  result.l =  dbl_GetBGRPPtr \{\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_GetDepth "dbl_GetDepth"

@{B}dbl_GetDepth@{UB}

@{B}Syntax:@{UB}  result.l =  dbl_GetDepth \{\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : depth of the dbl display

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_GetFPS "dbl_GetFPS"

@{B}dbl_GetFPS@{UB}

@{B}Syntax:@{UB}  result.f = dbl_GetFPS \{@interval.f\}

@{B}Description:@{UB}
Get the current frames-per-second (in Hz).
The interval parameter gives you control about the smoothness.
Default is 1s, that means the frames per second are messured every second.
Smaller intervals give you more results per second, but the accuracy will be lower.
NOTE: This function is ideal to display a FPS counter on the screen.
NOTE: To messure the time for the last frame for frame-rate-independent programming, use @{" dbl_GetFrameTime " link dbl_GetFrameTime}.

@{B}Inputs:@{UB}      
- interval.f    : minimum interval to messure

@{B}Result:@{UB}      
- result.f     : frames per second

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_GetFrameTime "dbl_GetFrameTime"

@{B}dbl_GetFrameTime@{UB}

@{B}Syntax:@{UB}  ratio.f = dbl_GetFrameTime \{desiredFPS.f\}

@{B}Description:@{UB}
Get the ratio of the desired FPS.
This function is very useful if you want to write a fps-independent game.
Lets say, your spaceship speed (in pixels / frame) is meant for 50 FPS, you call r.f = dbl_GetFrameTime\{50\}, and r will contain the ratio you haveto multiply your spaceship speed. E.g. if your current fps is 100Hz, you will get r.f = 0.5, if your fps is only 25Hz, you get r.f = 2.0.
NOTE: This funtion might return freakingly high or low values, if your game hangs or one frame was very fast. You might want to clip the ratio to reasonable values, e.g. 0.25 and 4.0.

@{B}Inputs:@{UB}      
- desiredFPS.f  : the FPS you real speed is designed for

@{B}Result:@{UB}      
- ratio.f       : ratio you have to multiply your movments in one frame

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_GetHeight "dbl_GetHeight"

@{B}dbl_GetHeight@{UB}

@{B}Syntax:@{UB}  result.l =  dbl_GetHeight \{\}

@{B}Description:@{UB}
Return the height in pixels of the dbl display.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : height in pixels of the dbl display

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_GetPen "dbl_GetPen"

@{B}dbl_GetPen@{UB}

@{B}Syntax:@{UB}  pen.l = dbl_GetPen \{r.l,g.l,b.l\}

@{B}Description:@{UB}
Get the pen number best approximating the given rgb color for use with e.g. Wline or other pen oriented functions.

@{B}Inputs:@{UB}      
- r.l         : red component, 0..255
- g.l         : green component, 0..255
- b.l         : blue component, 0..255

@{B}Result:@{UB}      
- pen.l       : Number of the pen representing the desired color

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_GetPenRGB "dbl_GetPenRGB"

@{B}dbl_GetPenRGB@{UB}

@{B}Syntax:@{UB}  pen.l = dbl_GetPenRGB \{rgbval.l\}

@{B}Description:@{UB}
Get the pen number best approximating the given rgb color for use with e.g. Wline or other pen oriented functions.

@{B}Inputs:@{UB}      
- rgbval.l       : 24 bit RGB value, e.g. $00FF00 for pure green

@{B}Result:@{UB}      
- pen.l       : Number of the pen representing the desired color

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_GetRPPtr "dbl_GetRPPtr"

@{B}dbl_GetRPPtr@{UB}

@{B}Syntax:@{UB}  result.l =  dbl_GetRPPtr \{\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_GetWidth "dbl_GetWidth"

@{B}dbl_GetWidth@{UB}

@{B}Syntax:@{UB}  result.l =  dbl_GetWidth \{\}

@{B}Description:@{UB}
Retrun the width in pixels of the dbl display.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : pixel width of the dbl display

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_HideMousePointer "dbl_HideMousePointer"

@{B}dbl_HideMousePointer@{UB}

@{B}Syntax:@{UB} dbl_HideMousePointer \{\}

@{B}Description:@{UB}
Hide the mouse pointer on the doublebuffer display, useful for games with no mouse.
NOTE: The pointer is hidden by default.
NOTE: If you want to have a 24bit mousepointer, hide the system pointer and blit it with @{" dbl_QBlit " link dbl_QBlit} \{mypointerimage,SMouseX,SMouseY\}

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_Hit "dbl_Hit"

@{B}dbl_Hit@{UB}

@{B}Syntax:@{UB}  succ.l =  dbl_Hit \{x.l,y.l\}

@{B}Description:@{UB}
Test if there the color at the given x/y coos has changed compared to the time when dbl_InitCollision\{\}  was called (which is usualy after you have created your non-collision background).
You go like this:
1. Create your non-colision background with @{" dbl_BGBlit " link dbl_BGBlit}, @{" dbl_BGBlitPattern " link dbl_BGBlitPattern}
2. Call dbl_collision_init
3. Blit your walls that cause collision with @{" dbl_BGBlit " link dbl_BGBlit}
4. Ask with dbl_Hit\{x,y\} in the gameplay loop for collision
If you have no walls, simply dont call dbl_collision_init  to save some memory.

@{B}Inputs:@{UB}      
- x.l       : x coordinate to check
- y.l       : y coordinate to check

@{B}Result:@{UB}      
- succ.l    : True if the color has changed, False if not

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_ImgMaskHit "dbl_ImgMaskHit"

@{B}dbl_ImgMaskHit@{UB}

@{B}Syntax:@{UB}  succ.l =  dbl_ImgMaskHit \{image.l,x.l,y.l,tstx.l,tsty.l\}

@{B}Description:@{UB}
Test if the image bit mask would hit at tstx.l/tsty.l if the image would be at x.l/y.l

@{B}Inputs:@{UB}      
- image.l    : image object number
- x.l        : x coordinate of image
- y.l        : y coordinate of image
- tstx.l     : x coordinate of test point
- tsty.l     : y coordinate of test point

@{B}Result:@{UB}      
- succ.l    : True if collide, False if not

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_Init "dbl_Init"

@{B}dbl_Init@{UB}

@{B}Syntax:@{UB}  succ.l = dbl_Init \{screenname.s,modeid.l,@scr_width.l,@scr_height.l,@scr_depth.l,@idcmp.l\}

@{B}Description:@{UB}
Init the double buffered display (screen).
It is recommended to use the intuition.library to receive input events and leave the idcmp parameter out.
It is only needed if you check your IDCMP messages in another way. By default, you will not receive IDCMP_VANILLAKEY events.
The intuition.inlcude only receives IDCMP_RAWKEY events, but allows to ask for the vanillakey value. This is necessary to track the keyboard status systemfriendly, which is necessary for games.

@{B}Inputs:@{UB}      
- screenname.s : name of the screen
- modeid.l     : screenmode ID / 0=ASL Requester / -1=BestModeID / -2 = window mode
- scr_width.l  : width of screen
- scr_height.l : height of screen
- scr_depth.l  : depth of screen (HiColor is depth=16, TrueColor is depth=24)
- idcmp.l    : IDCMP Mask of messages you want to receive

@{B}Result:@{UB}      
- succ.l       : True if everthing went well, False if it fails

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_InitCollision "dbl_InitCollision"

@{B}dbl_InitCollision@{UB}

@{B}Syntax:@{UB}  succ.l = dbl_InitCollision \{\}

@{B}Description:@{UB}
Creates a bitmap with data that should not cause collision for use with dbl_tst\{\} later. Usually you do it like this:
- draw the objects that should NOT cause collision, then
- call dbl_InitCollision\{\}, and then
- draw objects (like walls) that should cause collision.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- succ.l    : True if collision bitmap was successfully created

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_QBlit "dbl_QBlit"

@{B}dbl_QBlit@{UB}

@{B}Syntax:@{UB} dbl_QBlit \{image.l,x.l,y.l,@factor.f,@yfactor.f,@mode.l,@density.l\}

@{B}Description:@{UB}
Blit an image to the foreground and remember its position the be able to remove it again with dbl_Unqueue\{\}.
NOTE: After you blitted the image it will cause collision until it is removed with @{" dbl_Unqueue " link dbl_Unqueue}. If you dont want it to cause collision you have to check with @{" dbl_Hit " link dbl_Hit} AFTER @{" dbl_Unqueue " link dbl_Unqueue} and BEFORE dbl_QBlit.

@{B}Inputs:@{UB}      
- image.l     : image you want to blit
- x.l         : x coordinate
- y.l         : y coordinate
- factor      : zooming factor (1.0 = same size, 2.0 = double size, 0.5 =half size
- yfactor.f   : optional y-zooming factor if you want to change the aspect
- mode.l      : one of
    #image_blitmode_opaque  = normal blitting, with bit mask if present
    #image_blitmode_trans   = transparent blitting acodoring denity
    #image_blitmode_alpha   = normal blitt with mask & alpha if present
    #image_blitmode_add     = pixels are added to the background
    #image_blitmode_sub     = pixels are substracted from the bg
- density.l   : 0-256, mix value for trans, alpha, add and sub blitting modes

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_QBlitScaled "dbl_QBlitScaled"

@{B}dbl_QBlitScaled@{UB}

@{B}Syntax:@{UB} dbl_QBlitScaled \{image.l,x.l,y.l,factor.f,@yfactor.f\}

@{B}Description:@{UB}
* obsolete* (for compatibelity)
Use @{" dbl_QBlit " link dbl_QBlit} instead.

@{B}Inputs:@{UB}      
- image.l    : ???
- x.l    : ???
- y.l    : ???
- factor.f    : ???
- yfactor.f    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_QBlitx "dbl_QBlitx"

@{B}dbl_QBlitx@{UB}

@{B}Syntax:@{UB} dbl_QBlitx \{image.l,x.l,y.l,@factor.f,@yfactor.f,@mode.l,@density.l\}

@{B}Description:@{UB}
* obsolete *
Use @{" dbl_QBlit " link dbl_QBlit} instead.

@{B}Inputs:@{UB}      
- image.l     : image you want to blit
- x.l         : x coordinate
- y.l         : y coordinate
- factor      : zooming factor (1.0 = same size, 2.0 = double size, 0.5 =half size
- yfactor.f   : optional y-zooming factor if you want to change the aspect
- mode.l    : ???
- density.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_QBox "dbl_QBox"

@{B}dbl_QBox@{UB}

@{B}Syntax:@{UB} dbl_QBox \{rgbval.l,x1.l,y1.l,x2.l,y2.l\}

@{B}Description:@{UB}
Draw a uni-color rectangle box  that will be removed with the next call of @{" dbl_Unqueue " link dbl_Unqueue}.
Note: this function is designed for True/Hi color screens!

@{B}Inputs:@{UB}      
- rgbval.l    : RGB value of the color, e.g. $FF00FF for pink
- x1.l    :  x1 coordinate
- y1.l    :  y1 coordinate
- x2.l    :  x2 coordinate
- y2.l    :  y2 coordinate

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_QDamage "dbl_QDamage"

@{B}dbl_QDamage@{UB}

@{B}Syntax:@{UB} dbl_QDamage \{x.l,@y.l,@xs.l,@ys.l,@db.l\}

@{B}Description:@{UB}
Clear the given region with the background image.
(it is marked as "damaged", and will be cleared in the next call of @{" dbl_Unqueue " link dbl_Unqueue}).
NOTE: Use this if you made the display "dirty" with some other commands than dbl_QBlit\{\}, e.g. with WBox and tell the queue to clean it.
NOTE: This is only needed in dbl_method=0, however, its always a good idea to do it correctly.

@{B}Inputs:@{UB}      
- x.l         : x coordinate
- y.l         : y coordinate
- xs.l        : width of the region that should be cleared
- ys.l        : height of the region that should be cleared
- db.l        : optional: force the buffer, can be 0 or 1

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_QDamageArea "dbl_QDamageArea"

@{B}dbl_QDamageArea@{UB}

@{B}Syntax:@{UB} dbl_QDamageArea \{x1.l,y1.l,x2.l,y2.l,@db.l\}

@{B}Description:@{UB}
Same like @{" dbl_QDamage " link dbl_QDamage}, but for lazy people who dont want to calculate the width and height of the damaged area if the x1/y1 x2/y2 coordinates are given.

@{B}Inputs:@{UB}      
- x1.l         : x1 coordinate
- y1.l         : y1 coordinate
- x2.l         : x2 coordinate
- y2.l         : y2 coordinate
- db.l        : optional: force the buffer, can be 0 or 1

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_QLine "dbl_QLine"

@{B}dbl_QLine@{UB}

@{B}Syntax:@{UB} dbl_QLine \{rgbval.l,x1.l,y1.l,x2.l,y2.l\}

@{B}Description:@{UB}
Draw a uni-color line that will be removed with the next call of @{" dbl_Unqueue " link dbl_Unqueue}.
Note: this function is designed for True/Hi color screens!

@{B}Inputs:@{UB}      
- rgbval.l    : RGB value of the color, e.g. $FF00FF for pink
- x1.l    :  x1 coordinate
- y1.l    :  y1 coordinate
- x2.l    :  x2 coordinate
- y2.l    :  y2 coordinate

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_QPlot "dbl_QPlot"

@{B}dbl_QPlot@{UB}

@{B}Syntax:@{UB} dbl_QPlot \{rgbval.l,x1.l,y1.l\}

@{B}Description:@{UB}
Draw a uni-color pixel that will be removed with the next call of @{" dbl_Unqueue " link dbl_Unqueue}.
Note: this function is designed for True/Hi color screens!

@{B}Inputs:@{UB}      
- rgbval.l    : RGB value of the color, e.g. $FF00FF for pink
- x1.l    :  x1 coordinate
- y1.l    :  y1 coordinate

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_QPrint "dbl_QPrint"

@{B}dbl_QPrint@{UB}

@{B}Syntax:@{UB} dbl_QPrint \{text.s,x.l,y.l,@fgpen.l,@bgpen.l,@align.l,@valign.l\}

@{B}Description:@{UB}
Blit an text to the foreground and remember its position the be able to remove it again with dbl_Unqueue\{\}.
NOTE: After you blitted the text it will cause collision until it is removed with dbl_Unqueue\{\}. If you dont want it to cause collision you have to check with dbl_Hit\{\} AFTER dbl_Unqueue\{\} and BEFORE dbl_QPrint\{\}.

@{B}Inputs:@{UB}      
- text.s      : text you want to blit
- x.l         : x coordinate
- y.l         : y coordinate
- fgpen.l       : (optional) foreground pen
- bgpen.l       : (optional) background pen, transparent if left out
- align.l       : (optional) -1=left, 0=center,1=right
- valign.l      : (optional) -1=top, 0=baseline,1=bottom

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" dbl_QPlot " link dbl_QPlot}, @{" dbl_QLine " link dbl_QLine}, @{" dbl_QBox " link dbl_QBox}, @{" dbl_QBlit " link dbl_QBlit}




@ENDNODE
@NODE dbl_QRefresh "dbl_QRefresh"

@{B}dbl_QRefresh@{UB}

@{B}Syntax:@{UB} dbl_QRefresh \{x.l,y.l,xs.l,ys.l,@db.l\}

@{B}Description:@{UB}
* absolete * (for compatibelity)
Use dbl_damage istead.

@{B}Inputs:@{UB}      
- x.l    : ???
- y.l    : ???
- xs.l    : ???
- ys.l    : ???
- db.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    dbl_damage




@ENDNODE
@NODE dbl_RemPlayField "dbl_RemPlayField"

@{B}dbl_RemPlayField@{UB}

@{B}Syntax:@{UB} dbl_RemPlayField \{\}

@{B}Description:@{UB}
Remove the playfield definitions. The whole visible area will be the playfield.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" dbl_SetPlayField " link dbl_SetPlayField}




@ENDNODE
@NODE dbl_Reset "dbl_Reset"

@{B}dbl_Reset@{UB}

@{B}Syntax:@{UB} dbl_Reset \{@pen.l\}

@{B}Description:@{UB}
Reset the double buffer display. It is a good idea to call this before you enter the gameplay loop to clear everything up.

@{B}Inputs:@{UB}      
none
- pen.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_SetFPS "dbl_SetFPS"

@{B}dbl_SetFPS@{UB}

@{B}Syntax:@{UB} dbl_SetFPS \{fps.f\}

@{B}Description:@{UB}
Set the desired fps.
Usually, this is something from 25 to 100Hz.
Your game will be triggered to this fps within the @{" dbl_Flip " link dbl_Flip} function.
If you need more time for drawing your objects, your gameplay will slow down.
If you want to program your game fps independent, use @{" dbl_GetFrameTime " link dbl_GetFrameTime} to correct your objects movements. Your gamplay will then stay at the same speed, but the objects move more rough, as found in most 3D games nowadays.

Possible values for fps are:
1...250               : the desired FPS you want in Hz
#dbl_fps_free    =  0 : no timing, pass every frame as fast as possible
#dbl_fps_vbeam   = -1 : use VBeam via WaitBOVP_() for timing (usually the monitors FPS)
#dbl_fps_monitor = -2 : normal timer with calculated FPS of screenmode
#dbl_fps_vblank  = -3 : use VBlank via WaitTOF_() for timing (usually 50Hz or monitors FPS)

NOTE: It is a hard choise what does the best for you.
If you program for a fix FPS, you might just want to set the FPS with a Hz number.
If you can handle variable frame rates, I recommend #dbl_fps_vbeam, at least under WinUAE it looks like kinda syncronized with the real refresh rate of the monitor.

@{B}Inputs:@{UB}      
- fps.f    : FPS in Hz or #dbl_fps_xxx constant

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_SetPen "dbl_SetPen"

@{B}dbl_SetPen@{UB}

@{B}Syntax:@{UB} dbl_SetPen \{n.l,r.l,g.l,b.l\}

@{B}Description:@{UB}
Set a pen to the given rgb values.
Note: You should only use this if you know what you are doing because it may change the color of images that are already draw on the screen
Note: Use dbl_GetPen\{\} as it creates new pens to get the color exactly if there are free pens left.

@{B}Inputs:@{UB}      
- n.l         : index number pen to change
- r.l         : red component, 0..255
- g.l         : green component, 0..255
- b.l         : blue component, 0..255

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_SetPenRGB "dbl_SetPenRGB"

@{B}dbl_SetPenRGB@{UB}

@{B}Syntax:@{UB} dbl_SetPenRGB \{n.l,rgbval.l\}

@{B}Description:@{UB}
 @{" dbl_SetPen " link dbl_SetPen} \{n.l,rgbval.l\}
Set a pen to the given rgb value.
Note: You should only use this if you know what you are doing because it may change the color of images that are already visible on the screen
Note: Use dbl_GetPen\{\} as it creates new pens to get the color exactly if there are free pens left.

@{B}Inputs:@{UB}      
- n.l         : index number pen to change
- rgbval.l    :  rgbvalue, e.g. $FF0000 for pure red

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_SetPlayField "dbl_SetPlayField"

@{B}dbl_SetPlayField@{UB}

@{B}Syntax:@{UB} dbl_SetPlayField \{x1.l,y1.l,x2.l,y2.l\}

@{B}Description:@{UB}
Set a certain rectangle area on the display as the "playfield". All blitting and drawing operations will be clipped to this area.
You can use this e.g. if your game has a split screen or a cockpit console or something, that does not belong to the part where the "action" takes place.
NOTE: You can use this functions seveal times in your game loop, to update several playfields.
NOTE: to set the whole screen as playfield again, use @{" dbl_RemPlayField " link dbl_RemPlayField} if you are to lazy to determine the screen dimensions.

@{B}Inputs:@{UB}      
- x1.l    : coordiates of the playfield area
- y1.l    :
- x2.l    :
- y2.l    :

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" dbl_RemPlayField " link dbl_RemPlayField}




@ENDNODE
@NODE dbl_ShowMousePointer "dbl_ShowMousePointer"

@{B}dbl_ShowMousePointer@{UB}

@{B}Syntax:@{UB} dbl_ShowMousePointer \{@pnum.l\}

@{B}Description:@{UB}
Show the mousepointer again after use of dbl_HideMousePointer\{\}

@{B}Inputs:@{UB}      
- pnum.l     : optional blitz shape object for use as a mousepointer (2 Bitplanes)

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE dbl_Unqueue "dbl_Unqueue"

@{B}dbl_Unqueue@{UB}

@{B}Syntax:@{UB} dbl_Unqueue \{\}

@{B}Description:@{UB}
Remove all objects draw with @{" dbl_QBlit " link dbl_QBlit}.
Call this function before you are going to draw the objects on the new calculated positions to remove the objects on the old positions.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
