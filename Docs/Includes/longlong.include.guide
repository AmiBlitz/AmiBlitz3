@Database "AB3Includes"
@Width 80
@font helvetica.font 13
@wordwrap
@TAB 3

@NODE main "longlong.include"

@{B}longlong.include@{UB}

@{B}Abstract@{UB}

   @{" Introduction " link Introduction} 

@{B}Public Function Index:@{UB}

 * no functions/statements defined * 

@{B}Public Macro Index:@{UB}

   @{" !ll_Add " link !ll_Add} 
   @{" !ll_Dec " link !ll_Dec} 
   @{" !ll_Divu " link !ll_Divu} 
   @{" !ll_Divu6432 " link !ll_Divu6432} 
   @{" !ll_Inc " link !ll_Inc} 
   @{" !ll_Mod " link !ll_Mod} 
   @{" !ll_Mulu " link !ll_Mulu} 
   @{" !ll_Mulu3232 " link !ll_Mulu3232} 
   @{" !ll_Set " link !ll_Set} 
   @{" !ll_SetLong " link !ll_SetLong} 
   @{" !ll_SetLongLong " link !ll_SetLongLong} 
   @{" !ll_Shift " link !ll_Shift} 
   @{" !ll_Sub " link !ll_Sub} 
   @{" !ll_ToDouble " link !ll_ToDouble} 
   @{" !ll_ToHex " link !ll_ToHex} 
   @{" !ll_ToLong " link !ll_ToLong} 
   @{" !ll_ToStr " link !ll_ToStr} 
   @{" !ll_UShift " link !ll_UShift} 
   @{" !test_divu " link !test_divu} 
   @{" !test_mulu " link !test_mulu} 

@ENDNODE
@NODE !ll_Add "!ll_Add"

@{B}!ll_Add@{UB}

@{B}Syntax:@{UB} !ll_Add \{res.ll,a.ll,b.ll\}

@{B}Description:@{UB}
Add to 64 integer values:
res = a + b
NOTE: There is a blitz version and an 68K ASM version.

@{B}Inputs:@{UB}      
- res.ll   : result
- a.ll     : value to add
- b.ll     : value to add

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_Dec "!ll_Dec"

@{B}!ll_Dec@{UB}

@{B}Syntax:@{UB} !ll_Dec \{res\}

@{B}Description:@{UB}
Decrease the value of res by 1:
res = res - 1

@{B}Inputs:@{UB}      
- res    : value to decrease

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_Divu "!ll_Divu"

@{B}!ll_Divu@{UB}

@{B}Syntax:@{UB} !ll_Divu \{res.ll,a.ll,b.ll\}

@{B}Description:@{UB}
Unsigned division of a 64bit value through a 64bit value.
res = a / b

@{B}Inputs:@{UB}      
- res.ll  : ???
- a.ll    : ???
- b.ll    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_Divu6432 "!ll_Divu6432"

@{B}!ll_Divu6432@{UB}

@{B}Syntax:@{UB} !ll_Divu6432 \{res,a,b\}

@{B}Description:@{UB}
Unsigned division of a 64bit value through a 32bit value.
res = a / b

@{B}Inputs:@{UB}      
- res.ll  : ???
- a.ll    : ???
- b.l     : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_Inc "!ll_Inc"

@{B}!ll_Inc@{UB}

@{B}Syntax:@{UB} !ll_Inc \{res\}

@{B}Description:@{UB}
Increase the value of res by 1.
res = res + 1

@{B}Inputs:@{UB}      
- res    : value to increase

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_Mod "!ll_Mod"

@{B}!ll_Mod@{UB}

@{B}Syntax:@{UB} !ll_Mod \{res.ll,a.ll,b.ll\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- res.ll    : ???
- a.ll    : ???
- b.ll    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_Mulu "!ll_Mulu"

@{B}!ll_Mulu@{UB}

@{B}Syntax:@{UB} !ll_Mulu \{res.ll,a.ll,b.ll\}

@{B}Description:@{UB}
Multiply two 64bit integers and store the result as 64bit integer.
res = a * b

@{B}Inputs:@{UB}      
- res.ll  : result
- a.ll    : value to multiply
- b.ll    : value to multiply

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_Mulu3232 "!ll_Mulu3232"

@{B}!ll_Mulu3232@{UB}

@{B}Syntax:@{UB} !ll_Mulu3232 \{res.ll,a.l,b.l\}

@{B}Description:@{UB}
Multiply two 32bit integers and store the result as 64bit integer.
res = a * b

@{B}Inputs:@{UB}      
- res.ll : result
- a.l    : value to multiply
- b.l    : value to multiply

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_Set "!ll_Set"

@{B}!ll_Set@{UB}

@{B}Syntax:@{UB} !ll_Set \{res,a\}

@{B}Description:@{UB}
Set a long long to a long long.

@{B}Inputs:@{UB}      
- res    : ???
- a    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_SetLong "!ll_SetLong"

@{B}!ll_SetLong@{UB}

@{B}Syntax:@{UB} !ll_SetLong \{res,long.l\}

@{B}Description:@{UB}
Set a long long to a long.

@{B}Inputs:@{UB}      
- res    : ???
- long.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_SetLongLong "!ll_SetLongLong"

@{B}!ll_SetLongLong@{UB}

@{B}Syntax:@{UB} !ll_SetLongLong \{res,longhi.l,longlo.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- res    : ???
- longhi.l    : ???
- longlo.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_Shift "!ll_Shift"

@{B}!ll_Shift@{UB}

@{B}Syntax:@{UB} !ll_Shift \{res.ll,a.ll,shift.l\}

@{B}Description:@{UB}
Signed bitshift of a long long value.
res = a ASL shift
Note: this function can perform left and right shift, depending on the sign of shift
Negative shift will shift right, positive value will shift left

@{B}Inputs:@{UB}      
- res.ll    : result
- a.ll      : long long value
- shift.l   : amount of bits to shift [-32...+32]

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_Sub "!ll_Sub"

@{B}!ll_Sub@{UB}

@{B}Syntax:@{UB} !ll_Sub \{res.ll,a.ll,b.ll\}

@{B}Description:@{UB}
Subtract a and b and store the result in res:
res = a-b
NOTE: There is a blitz version and an 68K ASM version.

@{B}Inputs:@{UB}      
- res.ll   : result
- a.ll     : value
- b.ll     : value to subtract

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_ToDouble "!ll_ToDouble"

@{B}!ll_ToDouble@{UB}

@{B}Syntax:@{UB} !ll_ToDouble \{double.d,a.ll\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- double.d    : ???
- a.ll    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_ToHex "!ll_ToHex"

@{B}!ll_ToHex@{UB}

@{B}Syntax:@{UB} !ll_ToHex \{strings.s,a\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- strings.s    : ???
- a    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_ToLong "!ll_ToLong"

@{B}!ll_ToLong@{UB}

@{B}Syntax:@{UB} !ll_ToLong \{long.l,a\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- long.l    : ???
- a    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_ToStr "!ll_ToStr"

@{B}!ll_ToStr@{UB}

@{B}Syntax:@{UB} !ll_ToStr \{string.s,a\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- string.s    : ???
- a    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !ll_UShift "!ll_UShift"

@{B}!ll_UShift@{UB}

@{B}Syntax:@{UB} !ll_UShift \{res.ll,a.ll,shift.l\}

@{B}Description:@{UB}
Unsigned bitshift of a long long value.
res = a LSL shift
Note: this function can perform left and right shift, depending on the sign of shift
Negative shift will shift right, positive value will shift left

@{B}Inputs:@{UB}      
- res.ll    : result
- a.ll      : long long value
- shift.l   : amount of bits to shift [-32...+32]

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !test_divu "!test_divu"

@{B}!test_divu@{UB}

@{B}Syntax:@{UB} !test_divu \{a,b\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- a    : ???
- b    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !test_mulu "!test_mulu"

@{B}!test_mulu@{UB}

@{B}Syntax:@{UB} !test_mulu \{a,b\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- a    : ???
- b    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE Introduction "Introduction"

@{B}Name:@{UB} longlong.include

@{B}Platforms:@{UB} Classic, WinUAE, Amithlon, MorphOS, AmigaOS4

@{B}Date:@{UB} 24/05/2007

@{B}Author:@{UB} <unknown>

@{B}Requirements:@{UB}  Amiblitz3

@{B}Purpose:@{UB}
Extend AB3 functionality.
* no description available *

@{B}Abstract:@{UB}
* no abstract available *

@{B}User Constants:@{UB}
#max_objects   = n

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
