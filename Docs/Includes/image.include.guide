@Database "AB3Includes"
@Width 80
@font helvetica.font 13
@wordwrap
@TAB 3

@NODE main "image.include"

@{B}image.include@{UB}

@{B}Abstract@{UB}

   @{" Introduction " link Introduction} 

@{B}Public Function Index:@{UB}

   @{" conv_0RGB_ARGB " link conv_0RGB_ARGB} 
   @{" conv_ARGB_0RGB " link conv_ARGB_0RGB} 
   @{" image_2Shape " link image_2Shape} 
   @{" image_AddToHistory " link image_AddToHistory} 
   @{" image_AllocMask " link image_AllocMask} 
   @{" image_AlphaIsUsed " link image_AlphaIsUsed} 
   @{" image_AttachAlpha " link image_AttachAlpha} 
   @{" image_Blit " link image_Blit} 
   @{" image_BlitArea " link image_BlitArea} 
   @{" image_BlitMask " link image_BlitMask} 
   @{" image_BlitPattern " link image_BlitPattern} 
   @{" image_BlitScaled " link image_BlitScaled} 
   @{" image_CPUBlit " link image_CPUBlit} 
   @{" image_CPUBlitRPRP " link image_CPUBlitRPRP} 
   @{" image_CPUBlitScaled " link image_CPUBlitScaled} 
   @{" image_Create " link image_Create} 
   @{" image_CreateAlpha " link image_CreateAlpha} 
   @{" image_Cut " link image_Cut} 
   @{" image_CutRP " link image_CutRP} 
   @{" image_Decode " link image_Decode} 
   @{" image_DecodeMask " link image_DecodeMask} 
   @{" image_Dither " link image_Dither} 
   @{" image_Draw " link image_Draw} 
   @{" image_DrawScaled " link image_DrawScaled} 
   @{" image_Examine " link image_Examine} 
   @{" image_ExtractAlpha " link image_ExtractAlpha} 
   @{" image_FancyBlit " link image_FancyBlit} 
   @{" image_FilterDelta24 " link image_FilterDelta24} 
   @{" image_FilterDelta32 " link image_FilterDelta32} 
   @{" image_FindByName " link image_FindByName} 
   @{" image_FootHandle " link image_FootHandle} 
   @{" image_Free " link image_Free} 
   @{" image_FreeAll " link image_FreeAll} 
   @{" image_FreeAlpha " link image_FreeAlpha} 
   @{" image_FreeData " link image_FreeData} 
   @{" image_FreeMask " link image_FreeMask} 
   @{" image_GetARGB " link image_GetARGB} 
   @{" image_GetARGBPtr " link image_GetARGBPtr} 
   @{" image_GetAlpha " link image_GetAlpha} 
   @{" image_GetExDepth " link image_GetExDepth} 
   @{" image_GetExHeight " link image_GetExHeight} 
   @{" image_GetExWidth " link image_GetExWidth} 
   @{" image_GetFilename " link image_GetFilename} 
   @{" image_GetFree " link image_GetFree} 
   @{" image_GetHandleX " link image_GetHandleX} 
   @{" image_GetHandleY " link image_GetHandleY} 
   @{" image_GetHeight " link image_GetHeight} 
   @{" image_GetMask " link image_GetMask} 
   @{" image_GetOpenGLTexturePtr " link image_GetOpenGLTexturePtr} 
   @{" image_GetRGB " link image_GetRGB} 
   @{" image_GetRGBFromRP " link image_GetRGBFromRP} 
   @{" image_GetRPDims " link image_GetRPDims} 
   @{" image_GetRPPtr " link image_GetRPPtr} 
   @{" image_GetTransparency " link image_GetTransparency} 
   @{" image_GetWidth " link image_GetWidth} 
   @{" image_Half " link image_Half} 
   @{" image_InitBitMap " link image_InitBitMap} 
   @{" image_InitMask " link image_InitMask} 
   @{" image_IsPictureDT " link image_IsPictureDT} 
   @{" image_IsSolid " link image_IsSolid} 
   @{" image_IsUsed " link image_IsUsed} 
   @{" image_Load " link image_Load} 
   @{" image_LoadShape " link image_LoadShape} 
   @{" image_MakeBlockCookie " link image_MakeBlockCookie} 
   @{" image_MakeCookie " link image_MakeCookie} 
   @{" image_MaskHit " link image_MaskHit} 
   @{" image_MaskIsUsed " link image_MaskIsUsed} 
   @{" image_MidHandle " link image_MidHandle} 
   @{" image_OptimizeAlpha " link image_OptimizeAlpha} 
   @{" image_PrepareAll " link image_PrepareAll} 
   @{" image_RGB2YUV24 " link image_RGB2YUV24} 
   @{" image_RGB2YUV32 " link image_RGB2YUV32} 
   @{" image_Read " link image_Read} 
   @{" image_Release " link image_Release} 
   @{" image_ReleaseAll " link image_ReleaseAll} 
   @{" image_RemClip " link image_RemClip} 
   @{" image_Resize " link image_Resize} 
   @{" image_Resize2 " link image_Resize2} 
   @{" image_Resize3 " link image_Resize3} 
   @{" image_Resize4 " link image_Resize4} 
   @{" image_RotateBlit " link image_RotateBlit} 
   @{" image_Save " link image_Save} 
   @{" image_SetAlpha " link image_SetAlpha} 
   @{" image_SetBlitBounds " link image_SetBlitBounds} 
   @{" image_SetBlitDims " link image_SetBlitDims} 
   @{" image_SetClip " link image_SetClip} 
   @{" image_SetDitherMode " link image_SetDitherMode} 
   @{" image_SetFileName " link image_SetFileName} 
   @{" image_SetHandle " link image_SetHandle} 
   @{" image_SetLoadDevisor " link image_SetLoadDevisor} 
   @{" image_Test " link image_Test} 
   @{" image_TextureBlit " link image_TextureBlit} 
   @{" image_TextureTriBlit " link image_TextureTriBlit} 
   @{" image_TwoThird " link image_TwoThird} 
   @{" image_UnfilterDelta32 " link image_UnfilterDelta32} 
   @{" image_Unlock " link image_Unlock} 
   @{" image_UnlockForce " link image_UnlockForce} 
   @{" image_Write " link image_Write} 
   @{" image_WriteMask " link image_WriteMask} 
   @{" image_YUV2RGB24 " link image_YUV2RGB24} 
   @{" image_YUV2RGB32 " link image_YUV2RGB32} 

@{B}Private Function Index:@{UB}

   @{" _image_DrawScaledx " link _image_DrawScaledx} 
   @{" image_AreCompatible " link image_AreCompatible} 
   @{" image_FreeARGB " link image_FreeARGB} 
   @{" image_FreeBitMap " link image_FreeBitMap} 
   @{" image_FreeRP " link image_FreeRP} 
   @{" image_InitRP " link image_InitRP} 
   @{" image_LoadViaDT " link image_LoadViaDT} 
   @{" image_LoadViaNI " link image_LoadViaNI} 
   @{" image_LoadViaPNG " link image_LoadViaPNG} 
   @{" image_Lock " link image_Lock} 
   @{" image_SaveDT " link image_SaveDT} 

@{B}Public Macro Index:@{UB}

   @{" !image_GetClipBounds " link !image_GetClipBounds} 
   @{" !image_GetHeight " link !image_GetHeight} 
   @{" !image_GetLayerOffset " link !image_GetLayerOffset} 
   @{" !image_GetWidth " link !image_GetWidth} 
   @{" !image_begin_blit_ealpha " link !image_begin_blit_ealpha} 
   @{" !image_triblit_left " link !image_triblit_left} 
   @{" !image_triblit_right " link !image_triblit_right} 

@{B}Private Macro Index:@{UB}

   @{" !image_begin_blit " link !image_begin_blit} 
   @{" !image_begin_blitmask " link !image_begin_blitmask} 
   @{" !image_crossline " link !image_crossline} 
   @{" !image_end_blit " link !image_end_blit} 
   @{" !image_read_bg " link !image_read_bg} 
   @{" !penale " link !penale} 

@ENDNODE
@NODE !image_GetClipBounds "!image_GetClipBounds"

@{B}!image_GetClipBounds@{UB}

@{B}Syntax:@{UB} !image_GetClipBounds \{*rp.RastPort,minx.l,miny.l,maxx.l,maxy.l\}

@{B}Description:@{UB}
Get the outer clip bounds of a RastPort with a layer attached, relative to the underlying bitmap.

@{B}Inputs:@{UB}      
- *rp.RastPort    : RastPort to get the clip bounds from
- minx.l    : x of top left edge
- miny.l    : y of top left edge
- maxx.l    : x of bottom right edge
- maxy.l    : y of bottom right edge

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !image_GetHeight "!image_GetHeight"

@{B}!image_GetHeight@{UB}

@{B}Syntax:@{UB} !image_GetHeight

@{B}Description:@{UB}
Get the height in pixel of an image. This is a faster version of the function image_height.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    image_height




@ENDNODE
@NODE !image_GetLayerOffset "!image_GetLayerOffset"

@{B}!image_GetLayerOffset@{UB}

@{B}Syntax:@{UB} !image_GetLayerOffset \{*rp.RastPort,xoff,yoff\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- *rp.RastPort    : ???
- xoff    : ???
- yoff    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !image_GetWidth "!image_GetWidth"

@{B}!image_GetWidth@{UB}

@{B}Syntax:@{UB} !image_GetWidth

@{B}Description:@{UB}
Get the width in pixel of an image. This is a faster version of the function image_width.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    image_width




@ENDNODE
@NODE !image_begin_blit "!image_begin_blit"

@{B}!image_begin_blit@{UB}

@{B}Syntax:@{UB} !image_begin_blit

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !image_begin_blit_ealpha "!image_begin_blit_ealpha"

@{B}!image_begin_blit_ealpha@{UB}

@{B}Syntax:@{UB} !image_begin_blit_ealpha

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !image_begin_blitmask "!image_begin_blitmask"

@{B}!image_begin_blitmask@{UB}

@{B}Syntax:@{UB} !image_begin_blitmask

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !image_crossline "!image_crossline"

@{B}!image_crossline@{UB}

@{B}Syntax:@{UB} !image_crossline

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !image_end_blit "!image_end_blit"

@{B}!image_end_blit@{UB}

@{B}Syntax:@{UB} !image_end_blit

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !image_read_bg "!image_read_bg"

@{B}!image_read_bg@{UB}

@{B}Syntax:@{UB} !image_read_bg

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !image_triblit_left "!image_triblit_left"

@{B}!image_triblit_left@{UB}

@{B}Syntax:@{UB} !image_triblit_left

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !image_triblit_right "!image_triblit_right"

@{B}!image_triblit_right@{UB}

@{B}Syntax:@{UB} !image_triblit_right

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE !penale "!penale"

@{B}!penale@{UB}

@{B}Syntax:@{UB} !penale

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE Introduction "Introduction"

@{B}Name:@{UB} image.include

@{B}Platforms:@{UB} Classic, WinUAE, Amithlon, MorphOS, AmigaOS4

@{B}Date:@{UB} 28.12.2006

@{B}Author:@{UB} Thilo Koehler

@{B}Requirements:@{UB} Amiblitz2.4, zlib.library (for png support), jpeg.library (for jpeg support)

@{B}Purpose:@{UB}
Replace and heavily extend the custom chip blit commands and shape commands and make them system friendly.

@{B}Abstract:@{UB}
This include provides commands to load images via datatypes (e.g. IFF-ILBM, JPG, PNG, GIF) and blit them into a window on a screen with any color depth or convert them into blitz shape objects.
It can also save images in IFF-ILBM, PNG and JPEG.
Images are stored as "image" objects, similar to blitz objects. Every image object is references by an ID, that ranges from 0 to #max_images-1.

AB3I format
The include comes with its own file format called AB3I (AmiBlitz3 Image), that can be raw or compressed data (both require zlib.library).
The use of this proprietary file format is to store images in an "unreadable" format for other applications like paint programs.
One AB3I file can also contain multiple pictures, that can make up e.g. an animation or a complete sprite set for a game.
The AB3I format stores automatically all information of an image object, like its handle, transparent color, alpha channel or bitmask.
There is also a AB2I format, but I recommend AB3I, because it has a better
and faster compression, and more features to control the compression.

@{B}User Constants:@{UB}
#max_images = 100
Set this BEFORE you include the image.include to control the maximum number of images you need.
Don't use object IDs above #max_images-1.

#use_zlib_library = 1
Set this to 0, if your program doesn't need png or compressed AB3I format images.
Your program will not require zlib.library any more.
The zlib is used for decompressing the alpha channel in PNG pictures and to compress/decompress the AB3I format.

#use_jpeg_library = 1
Set this to 0, if your program doesn't need to write JPEG pictures. Your program will not require the jpeg.library any more.

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE _image_DrawScaledx "_image_DrawScaledx"

@{B}_image_DrawScaledx@{UB}

@{B}Syntax:@{UB} _image_DrawScaledx \{image.l,x.l,y.l,xs.l,ys.l,@*rp.RastPort\}

@{B}Description:@{UB}
The same like @{" image_Draw " link image_Draw}, but scaled.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- x.l    : ???
- y.l    : ???
- xs.l    : ???
- ys.l    : ???
- *rp.RastPort    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" image_Draw " link image_Draw}, image_blit_scaled.




@ENDNODE
@NODE conv_0RGB_ARGB "conv_0RGB_ARGB"

@{B}conv_0RGB_ARGB@{UB}

@{B}Syntax:@{UB} conv_0RGB_ARGB \{src.l,dst.l,img_width.l,img_height.l,@img_bpr.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- src.l    : ???
- dst.l    : ???
- img_width.l    : ???
- img_height.l    : ???
- img_bpr.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE conv_ARGB_0RGB "conv_ARGB_0RGB"

@{B}conv_ARGB_0RGB@{UB}

@{B}Syntax:@{UB} conv_ARGB_0RGB \{src.l,dst.l,pixel.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- src.l    : ???
- dst.l    : ???
- pixel.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_2Shape "image_2Shape"

@{B}image_2Shape@{UB}

@{B}Syntax:@{UB}  result.l = image_2Shape \{image.l,bshape.l,@trgb.l\}

@{B}Description:@{UB}
Converts any image into a blitz2 shape object. You need to have opned a screen first, otherwise
the image can not be remapped.
NOTE: Don't release the image as long as the shape is visible somewhere on the screen to keep the colors allocated. You may call image_free_data.

@{B}Inputs:@{UB}      
- image.l  : image object ID
- bshape.l : Number of the Blitz shape object
- trgb.l   : transparent RGB value, e.g. $ff0000 for red

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" image_LoadShape " link image_LoadShape}




@ENDNODE
@NODE image_AddToHistory "image_AddToHistory"

@{B}image_AddToHistory@{UB}

@{B}Syntax:@{UB} image_AddToHistory \{image.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_AllocMask "image_AllocMask"

@{B}image_AllocMask@{UB}

@{B}Syntax:@{UB}  result.l = image_AllocMask \{image.l\}

@{B}Description:@{UB}
Creates an 1 bit mask makeing the given rgb value transparent for use with @{" image_BlitMask " link image_BlitMask} \{\}

It is save to call this function several times to update the mask if the image has changed
NOTE: This function is called automatically if you pass a transparent color value to the @{" image_Load " link image_Load} function

@{B}Inputs:@{UB}      
- image.l   : image object ID
- trgb.l    : rgbvalue for the desired transparent color, e.g. $ff0000 for red
- tolerance.l : optional the tolerance in 1/256 steps. Default is 1
- threshold.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_AlphaIsUsed "image_AlphaIsUsed"

@{B}image_AlphaIsUsed@{UB}

@{B}Syntax:@{UB}  succ.l =  image_AlphaIsUsed \{image.l\}

@{B}Description:@{UB}
Check if the image has an alpha channel attached.

@{B}Inputs:@{UB}      
- image.l    : image object ID

@{B}Result:@{UB}      
- succ.l    : -1, if the image has an alpha channel, 0 if not

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_AreCompatible "image_AreCompatible"

@{B}image_AreCompatible@{UB}

@{B}Syntax:@{UB}  result.l = image_AreCompatible \{image.l,image2.l,@checkbpr.l\}

@{B}Description:@{UB}
Check if two images are compatible in size and depth.
* private *

@{B}Inputs:@{UB}      
- image.l    : image object ID
- image2.l    : image object ID
- checkbpr.l    : bytes per row

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_AttachAlpha "image_AttachAlpha"

@{B}image_AttachAlpha@{UB}

@{B}Syntax:@{UB}  result.l = image_AttachAlpha \{image.l,alpha_ptr.l,@threshold.l\}

@{B}Description:@{UB}
Attach an external alpha mask (8 bit pixelarray) to the picture. The pixel array will be doublicated and can be freed after attaching it.
The optional threshold parameter can be used to set almost transparent pixels to be completely transparent. The picture might be blittet slightly faster. A threshold of 10-20 is reasonable and will not change the visual effect a lot.

@{B}Inputs:@{UB}      
- image.l    : image object number
- alpha_ptr.l    : pointer to an 8 bit pixel array containing the alpha channel (0= transparent, 255=full opaque)
- threshold.l    : threshold to cut almost transparent pixels of

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Blit "image_Blit"

@{B}image_Blit@{UB}

@{B}Syntax:@{UB} image_Blit \{image.l,x.l,y.l,@*rp.RastPort\}

@{B}Description:@{UB}
Blit an image to the used window or a RastPort.
This function uses BltBitMapRastPort() and is the fastest way to get the image to your screen.

@{B}Inputs:@{UB}      
- image.l : image object ID
- x.l     : x position in pixel
- y.l     : y position in pixel
- *rp     : optional a rastport to blit into, otherwise it is blitted to the used window
- *rp.RastPort    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" image_BlitMask " link image_BlitMask}




@ENDNODE
@NODE image_BlitArea "image_BlitArea"

@{B}image_BlitArea@{UB}

@{B}Syntax:@{UB} image_BlitArea \{image.l,x.l,y.l,xs.l,ys.l,sourcex.l,sourcey.l,@rp.l,@usemaskifpresent.l\}

@{B}Description:@{UB}
Blits a certain area of an image to the used window or the given rastport, opaque or bit mask transparent.
This function uses BltBitMapRastPort() or BltMaskBitMapRastPort(), depending if the image has a transparency bitmask or not.

@{B}Inputs:@{UB}      
- image.l  : Number of the source image "Object"
- x.l      : Destination x position
- y.l      : Destination y position
- xs.l     : Width of the clipped area
- ys.l     : Height of the clipped area
- sourcex.l: Source x position
- sourcey.l: Source y position
- rp.l     : optional a rastport where to blit, otherwise it is blitted to the used window
- usemaskifpresent.l    : if set to 0, this forces to blit opaque, even if the image has a bit mask

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_BlitMask "image_BlitMask"

@{B}image_BlitMask@{UB}

@{B}Syntax:@{UB} image_BlitMask \{image.l,x.l,y.l,@rp.l\}

@{B}Description:@{UB}
Blits an image with a 1bit mask on the current window or given rastport.
If there is no mask present, it will blit the image opaque.

@{B}Inputs:@{UB}      
- image.l : image object ID
- x.l     : x position
- y.l     : y position
- rp.l    : optional a rastport where to blit, otherwise it is blitted tothe used window

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_BlitPattern "image_BlitPattern"

@{B}image_BlitPattern@{UB}

@{B}Syntax:@{UB} image_BlitPattern \{image.l,x.l,y.l,xs.l,ys.l,@xoffset.l,@yoffset.l,@rp.l,@usemaskifpresent.l\}

@{B}Description:@{UB}
Blits an area of an image using BltBitMapRastPort() or BltMaskBitMapRastPort(), depending if a bitmask for transparency is present.
If the image bounds are exceeded, the image will wrap like a pattern.
It is also safe to specify negative values for xoffset/yoffset.
NOTE: if the image has a mask present, it will be blitted with mask, unless you specify usemaskifpresent=0.

@{B}Inputs:@{UB}      
- image.l  : Number of the source image "Object"
- x.l    : position
- y.l    :
- xs.l    : size of the are to fill with the pattern
- ys.l    :
- xoffset.l: x offset within the pattern
- yoffset.l: y offset within the pattern
- rp.l     : optional a ratport where to blit, otherwise it is blitted tothe used window
- usemaskifpresent.l    : if set to 0, the image is always blitted opaque.

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_BlitScaled "image_BlitScaled"

@{B}image_BlitScaled@{UB}

@{B}Syntax:@{UB} image_BlitScaled \{image.l,x.l,y.l,xs.l,ys.l,@*rp.RastPort\}

@{B}Description:@{UB}
Same like @{" image_Blit " link image_Blit}, but scaled to the given size xs/ys.
This function uses BitMapScale().

@{B}Inputs:@{UB}      
- image.l : image object ID
- x.l     : x position
- y.l     : y position
- xs.l    : destination width
- ys.l    : destination height
- *rp     : optional rastport to blit to
- *rp.RastPort    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_CPUBlit "image_CPUBlit"

@{B}image_CPUBlit@{UB}

@{B}Syntax:@{UB} image_CPUBlit \{image.l,x.l,y.l,@rp.l\}

@{B}Description:@{UB}
Blit an image transparent using the CPU.
Note: This works only on GFX cards with 8, 16, 24 or 32 bit color depth.

@{B}Inputs:@{UB}      
- image.l : image object ID
- x.l     : x position
- y.l     : y position
- rp.l    : optional a rastport to blit into, otherwise it is blitted to the used window

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_CPUBlitRPRP "image_CPUBlitRPRP"

@{B}image_CPUBlitRPRP@{UB}

@{B}Syntax:@{UB} image_CPUBlitRPRP \{rp_s.l,b_x.l,b_y.l,rp_d.l,r_x.l,r_y.l,xs.l,ys.l,@fade_ratio.l,@fade_rgb.l\}

@{B}Description:@{UB}
Blit an area of a rastport to another rastport using CPU and optional fading towards a color.

NOTE: This statement is probably not very useful for you. It is used in dbl.include for fading.

@{B}Inputs:@{UB}      
- rp_s.l    : source rastport
- b_x.l    :
- b_y.l    :
- rp_d.l    : destination rastport
- r_x.l    :
- r_y.l    :
- xs.l    : area width
- ys.l    : area height
- fade_ratio.l    : fade ration 0...256
- fade_rgb.l    : RGB value to fade to

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_CPUBlitScaled "image_CPUBlitScaled"

@{B}image_CPUBlitScaled@{UB}

@{B}Syntax:@{UB} image_CPUBlitScaled \{image.l,x.l,y.l,@xs.l,@ys.l,@rp.l\}

@{B}Description:@{UB}
Same like @{" image_CPUBlit " link image_CPUBlit}, but scaled to xs/ys.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- x.l    : x position
- y.l    : y position
- xs.l    : target width
- ys.l    : target height
- rp.l    : optional rastport to blit into

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Create "image_Create"

@{B}image_Create@{UB}

@{B}Syntax:@{UB}  result.l = image_Create \{image.l,img_width.l,img_height.l,@nofill.l,@argb.l\}

@{B}Description:@{UB}
Create a new image object from scratch.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- img_width.l    : pixel width
- img_height.l    : pixel height
- nofill.l    : set this to 0 if you want to image to be filled with the argb parameter
- argb.l    : ARGB value to fill the image width.

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_CreateAlpha "image_CreateAlpha"

@{B}image_CreateAlpha@{UB}

@{B}Syntax:@{UB}  result.l = image_CreateAlpha \{image.l,@trgb.l,@tolerance.l,@aimage.l,@threshold.l\}

@{B}Description:@{UB}
Create an alpha channel for the given image object.
The alpha channel can be either created by supplying the trgb and tolerance paramters, that choose
an RGB color with a tolerance to build the transparency, or by supplying another image object by aimage.
The aimage object will be converted to greyscale and used as the alpha mask.
NOTE: aimage and image can be identical

@{B}Inputs:@{UB}      
- image.l  : image object ID that will get the alpha mask attached
- trgb.l    : RGB value to use as the transparent color, e.g. $FF0000 forred.
- tolerance.l    : tolerance around the trgb value, 1...255
- aimage.l : Number of the image that will be converted to greyscale and used as alpha mask
- threshold.l: Use this to set vallues below theshold to 0 (=transparent)and values above 255-threshold to 255 (=opaque)

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Cut "image_Cut"

@{B}image_Cut@{UB}

@{B}Syntax:@{UB}  succ.l = image_Cut \{image.l,src_image.l,@x.l,@y.l,@xs.l,@ys.l,@trgb.l,@tolerance.l\}

@{B}Description:@{UB}
Creates an image object out of (a part of) another image.

@{B}Inputs:@{UB}      
- image.l    : new image object ID
- src_image.l: source image object ID
- x.l,y.l    : optional: position from where to fetch
- xs.l,ys.l  : optional: width and height of the area to fetch
- trgb.l     : rgbvalue for the desired transparent color, e.g. $ff0000 for red, set it to -1 for no transparency
- tolerance.l: tolerance for the transparency detection, default is 1

@{B}Result:@{UB}      
- succ.l     : True if everything went well, False if it failed

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_CutRP "image_CutRP"

@{B}image_CutRP@{UB}

@{B}Syntax:@{UB}  succ.l = image_CutRP \{image.l,*rp.RastPort,@x.l,@y.l,@xs.l,@ys.l,@trgb.l,@tolerance.l,@dithermode.l,@colorMap.l\}

@{B}Description:@{UB}
Creates an image object out of (a part of) the given Rastport.
NOTE:  ideal for screen-grabbing.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- *rp.RastPort   : Rastport where to fetch the data from
- trgb.l     : rgbvalue for the desired transparent color, e.g. $ff0000 for red, set it to -1 for no transparency
- x.l,y.l    : optional: position from where to fetch
- xs.l,ys.l  : optional: width and height of the area to fetch
- tolerance.l    : ???
- dithermode.l    : ???
- colorMap.l    : ???

@{B}Result:@{UB}      
- succ.l     : True if everything went well, False if it failed

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Decode "image_Decode"

@{B}image_Decode@{UB}

@{B}Syntax:@{UB}  count.l = image_Decode \{image.l,memptr.l,@maximages.l,@memlength.l\}

@{B}Description:@{UB}
Get an image from a memory location (must be saved with @{" image_Save " link image_Save} and e.g. included with IncBin)

@{B}Inputs:@{UB}      
- image.l   : image object number the first decoded image will get. Next images will get increasingly number
- memptr.l  : pointer to some memory where the data can be found, typically a label before IncBin
- maximages.l    : maximum amount of images to decode
- memlength.l : if you dont have a "AB2I" header, you can set the memory length. A value of 1 will deocde only the first picture found

@{B}Result:@{UB}      
- count.l   : Number of images decoded

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_DecodeMask "image_DecodeMask"

@{B}image_DecodeMask@{UB}

@{B}Syntax:@{UB}  result.l = image_DecodeMask \{image.l,ptr.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- ptr.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Dither "image_Dither"

@{B}image_Dither@{UB}

@{B}Syntax:@{UB} image_Dither \{image.l,@bit.l,@dithermode.l\}

@{B}Description:@{UB}
Simulate dithering on a 24 bit image.
This can be used to prepare an image for use on a 16 or 8bit bit screen.
NOTE: dithering to 16bit will use 5(R):6(G):5(B) pixelformat, this can lead to slightly wrong colors if your screen uses 5(R):5(G):5(B) pixelformat. Use 15bit dithering in that case.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- bit.l    : number of virtual bits [1...24]
- dithermode.l    : dither mode, must be one of
    #image_dithermode_default      = -1 ; default, currently errnoisefast
    #image_dithermode_none         = 0  ; no dithering, simple bit truncation
    #image_dithermode_err          = 1  ; error dithering, looks like FS dithering
    #image_dithermode_noise        = 2  ; pure noise dithering
    #image_dithermode_tk           = 3  ; Thilo's special experimental dithering
    #image_dithermode_errnoise     = 4  ; error + noise dithering
    #image_dithermode_noneshift    = 5  ; no dithering, but shifting, might be better than just truncation
    #image_dithermode_errnoisefast = 6  ; error + noise dithering, fast version
    #image_dithermode_errfast      = 7  ; error dithering, fast version
    #image_dithermode_errnoiseadd  = 8  ; error in add mode + noise dithering, experimental

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Draw "image_Draw"

@{B}image_Draw@{UB}

@{B}Syntax:@{UB} image_Draw \{image.l,x.l,y.l,@*rp.RastPort\}

@{B}Description:@{UB}
Draw an image instread of blit.
This means, the picture is converted on-the-fly to the destiantion screen pixelformat.
No shadow bitmap is created to speed the blit operation up like in @{" image_Blit " link image_Blit}.
NOTE: this functions saves you some memory, and is useful if you blit the image once.
If you plan to blit the image many times, better use @{" image_Blit " link image_Blit} for speed.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- x.l    : x position
- y.l    : y position
- *rp.RastPort    : rastport to draw the image to

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" image_Blit " link image_Blit}




@ENDNODE
@NODE image_DrawScaled "image_DrawScaled"

@{B}image_DrawScaled@{UB}

@{B}Syntax:@{UB}  result.l = image_DrawScaled \{image.l,x.l,y.l,xs.l,ys.l,@*rp.RastPort,@smoothing.f\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- x.l    : ???
- y.l    : ???
- xs.l    : ???
- ys.l    : ???
- *rp.RastPort    : ???
- smoothing.f    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Examine "image_Examine"

@{B}image_Examine@{UB}

@{B}Syntax:@{UB}  succ.l = image_Examine \{fid.l\}

@{B}Description:@{UB}
Test if file exists AND is an image that is supported.

@{B}Inputs:@{UB}      
- filename.s : Complete dos filename including path
- fid.l    : ???

@{B}Result:@{UB}      
- succ.l     : True if everything went well, False if it failed

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_ExtractAlpha "image_ExtractAlpha"

@{B}image_ExtractAlpha@{UB}

@{B}Syntax:@{UB}  result.l = image_ExtractAlpha \{image.l,alpha_ptr.l,alpha_bpr.l,@threshold.l\}

@{B}Description:@{UB}
Extract the alpha mask found in the ARGB pixelformat and prepare it to use with the image.include.
NOTE: for private use only !

@{B}Inputs:@{UB}      
- image.l    : image object ID
- alpha_ptr.l    : pointer to an ARGB pixel array
- alpha_bpr.l    : bytes per row of the ARGB pixel array
- threshold.l    : theshold for setting alpha values to 0

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_FancyBlit "image_FancyBlit"

@{B}image_FancyBlit@{UB}

@{B}Syntax:@{UB} image_FancyBlit \{image.l,x.l,y.l,@xs.l,@ys.l,@*rp.RastPort,@mode.l,@density.l,@alpha_ptr.l,@alpha_bpr.l\}

@{B}Description:@{UB}
Blits an image using CPU in different blitmodes, scaled and with mask if available.
Note: This works only on GFX cards with 16, 24 or 32bit color depth, no color indexed screens are supported.

@{B}Inputs:@{UB}      
- image.l : image object ID
- x.l     : x position
- y.l     : y position
- xs.l    : xs destination width
- ys.l    : ys destination height
- rp.l    : optional a ratport where to blit, otherwise it is blitted to the used window
- mode.l  : one of
    #image_blitmode_opaque  = normal blitting, with mask if present
    #image_blitmode_trans   = transparent blitting accodoring denity
    #image_blitmode_alpha   = normal blitt with mask & alpha if present
    #image_blitmode_add     = pixels are added to the background
    #image_blitmode_sub     = pixels are substracted from the bg
- density.l : 0-256, mix value for trans, add and sub blitting modes
- *rp.RastPort    : ???
- alpha_ptr.l    : ???
- alpha_bpr.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_FilterDelta24 "image_FilterDelta24"

@{B}image_FilterDelta24@{UB}

@{B}Syntax:@{UB} image_FilterDelta24 \{src.l,srcbpr.l,dst.l,dstbpr.l,w.l,h.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- src.l    : ???
- srcbpr.l    : ???
- dst.l    : ???
- dstbpr.l    : ???
- w.l    : ???
- h.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_FilterDelta32 "image_FilterDelta32"

@{B}image_FilterDelta32@{UB}

@{B}Syntax:@{UB} image_FilterDelta32 \{src.l,srcbpr.l,dst.l,dstbpr.l,w.l,h.l,@ARGBMASK.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- src.l    : ???
- srcbpr.l    : ???
- dst.l    : ???
- dstbpr.l    : ???
- w.l    : ???
- h.l    : ???
- ARGBMASK.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_FindByName "image_FindByName"

@{B}image_FindByName@{UB}

@{B}Syntax:@{UB}  image.l = image_FindByName \{filename.s\}

@{B}Description:@{UB}
Find an already loaded image by filename. This return either the image object number or "-1" if the image could not be found.
NOTE: This is useful if you load and display images dynamically, and want to check if the image is already loaded.

@{B}Inputs:@{UB}      
- filename.s : Filename including full path which you used originally to load the image

@{B}Result:@{UB}      
- image.l    : Object number of a free image, ready to be loaded with image data

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_FootHandle "image_FootHandle"

@{B}image_FootHandle@{UB}

@{B}Syntax:@{UB} image_FootHandle \{image.l\}

@{B}Description:@{UB}
Defines the handle of the image as the middle horizontal and the bottom vertical.

@{B}Inputs:@{UB}      
- image.l       : image object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Free "image_Free"

@{B}image_Free@{UB}

@{B}Syntax:@{UB} image_Free \{image.l\}

@{B}Description:@{UB}
Free a loaded image and its color allocations on the screen.

@{B}Inputs:@{UB}      
- image.l : image object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_FreeARGB "image_FreeARGB"

@{B}image_FreeARGB@{UB}

@{B}Syntax:@{UB} image_FreeARGB \{image.l\}

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      
- image.l    : image object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_FreeAll "image_FreeAll"

@{B}image_FreeAll@{UB}

@{B}Syntax:@{UB} image_FreeAll \{\}

@{B}Description:@{UB}
Frees all loaded images and its color allocations on the screen.
It is save to call this if no image was loaded.

NOTE: you should always use this before you exit your program.
NOTE: If you forget this, the autoexit handler ist doing this for you.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_FreeAlpha "image_FreeAlpha"

@{B}image_FreeAlpha@{UB}

@{B}Syntax:@{UB} image_FreeAlpha \{image.l\}

@{B}Description:@{UB}
Free the alpha channel of an image.

@{B}Inputs:@{UB}      
- image.l    : image object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_FreeBitMap "image_FreeBitMap"

@{B}image_FreeBitMap@{UB}

@{B}Syntax:@{UB} image_FreeBitMap \{image.l\}

@{B}Description:@{UB}
* private *
Free the shadow bitmap of an image.

@{B}Inputs:@{UB}      
- image.l    : image object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_FreeData "image_FreeData"

@{B}image_FreeData@{UB}

@{B}Syntax:@{UB} image_FreeData \{image.l\}

@{B}Description:@{UB}
Free all image data except the pen allocations on the screen.
The image can not be blitted anymore, but can stay visible on the screen.

@{B}Inputs:@{UB}      
- image.l    : image object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_FreeMask "image_FreeMask"

@{B}image_FreeMask@{UB}

@{B}Syntax:@{UB} image_FreeMask \{image.l\}

@{B}Description:@{UB}
Frees the image data of a loaded image but the color allocations are still present.
NOTE: after you have called this you can not blit the image anymore.
NOTE: use this if you want to free the memory of the image but it should stay visible in the correct colors.

@{B}Inputs:@{UB}      
- image.l : image object ID (valid range is from 0 to #max_images-1, lookon top for the maximum

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_FreeRP "image_FreeRP"

@{B}image_FreeRP@{UB}

@{B}Syntax:@{UB} image_FreeRP \{image.l\}

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      
- image.l    : image object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetARGB "image_GetARGB"

@{B}image_GetARGB@{UB}

@{B}Syntax:@{UB}  result.l =  image_GetARGB \{image.l,x.l,y.l\}

@{B}Description:@{UB}
Get the ARGB value of a pixel within the image.

@{B}Inputs:@{UB}      
- image.l : image object ID
- x.l     : x position
- y.l     : y position

@{B}Result:@{UB}      
- result.l  : ARGB value as a long integer

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetARGBPtr "image_GetARGBPtr"

@{B}image_GetARGBPtr@{UB}

@{B}Syntax:@{UB}  result.l = image_GetARGBPtr \{image.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetAlpha "image_GetAlpha"

@{B}image_GetAlpha@{UB}

@{B}Syntax:@{UB}  result.l =  image_GetAlpha \{image.l,x.l,y.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- x.l    : ???
- y.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetExDepth "image_GetExDepth"

@{B}image_GetExDepth@{UB}

@{B}Syntax:@{UB}  result.l = image_GetExDepth \{\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetExHeight "image_GetExHeight"

@{B}image_GetExHeight@{UB}

@{B}Syntax:@{UB}  result.l = image_GetExHeight \{\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetExWidth "image_GetExWidth"

@{B}image_GetExWidth@{UB}

@{B}Syntax:@{UB}  result.l = image_GetExWidth \{\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetFilename "image_GetFilename"

@{B}image_GetFilename@{UB}

@{B}Syntax:@{UB}  result.s = image_GetFilename \{image.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???

@{B}Result:@{UB}      
- result.s     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetFree "image_GetFree"

@{B}image_GetFree@{UB}

@{B}Syntax:@{UB}  image.l = image_GetFree \{\}

@{B}Description:@{UB}
Find a free image object ID.
NOTE: This is useful if you load and display images dynamically, that means it is not predictable how many images you will use

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      
- image.l  : image object ID of a free image, ready to be loaded with image data

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetHandleX "image_GetHandleX"

@{B}image_GetHandleX@{UB}

@{B}Syntax:@{UB}  result.l =  image_GetHandleX \{image.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetHandleY "image_GetHandleY"

@{B}image_GetHandleY@{UB}

@{B}Syntax:@{UB}  result.l =  image_GetHandleY \{image.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetHeight "image_GetHeight"

@{B}image_GetHeight@{UB}

@{B}Syntax:@{UB} result.l =  image_GetHeight \{image.l\}

@{B}Description:@{UB}
Return the height of the specified image

NOTE: Never use imagedat() variables directly as they may change in the future
NOTE: There exists also a macro, if you need to be really fast!

@{B}Inputs:@{UB}      
- image.l : image object ID

@{B}Result:@{UB}      
- height : height of the image

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    !image_height, image_width




@ENDNODE
@NODE image_GetMask "image_GetMask"

@{B}image_GetMask@{UB}

@{B}Syntax:@{UB}  result.l =  image_GetMask \{image.l,x.l,y.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- x.l    : ???
- y.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetOpenGLTexturePtr "image_GetOpenGLTexturePtr"

@{B}image_GetOpenGLTexturePtr@{UB}

@{B}Syntax:@{UB}  result.l = image_GetOpenGLTexturePtr \{image.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetRGB "image_GetRGB"

@{B}image_GetRGB@{UB}

@{B}Syntax:@{UB}  rgbvalue.l =  image_GetRGB \{image.l,x.l,y.l\}

@{B}Description:@{UB}
Extracts the RGB value at the given coordinates of the image.

@{B}Inputs:@{UB}      
- image.l       : image object ID
- x.l           : x position
- y.l           : y position

@{B}Result:@{UB}      
- rgbvalue.l    : rgbvalue at the x/y position, e.g. $00ff00 for green

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetRGBFromRP "image_GetRGBFromRP"

@{B}image_GetRGBFromRP@{UB}

@{B}Syntax:@{UB}  rgbvalue.l =  image_GetRGBFromRP \{rp.l,x.l,y.l,scr.l\}

@{B}Description:@{UB}
Extracts the RGB value at the given coordinates from any rastport.

@{B}Inputs:@{UB}      
- rp.l          : Rastport
- x.l           : x position
- y.l           : y position
- scr.l         : optional screen from where to fetch the colormap

@{B}Result:@{UB}      
- rgbvalue.l    : rgbvalue at the x/y position, e.g. $00ff00 for green

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetRPDims "image_GetRPDims"

@{B}image_GetRPDims@{UB}

@{B}Syntax:@{UB} image_GetRPDims \{*rp.RastPort,x_ptr.l,y_ptr.l,xs_ptr.l,ys_ptr.l\}

@{B}Description:@{UB}
Get the rastports maximum dimensions.

@{B}Inputs:@{UB}      
- *rp.RastPort    : pointer to a rastport
- x_ptr.l    : pointer to a .l variable
- y_ptr.l    : pointer to a .l variable
- xs_ptr.l    : pointer to a .l variable
- ys_ptr.l    : pointer to a .l variable

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetRPPtr "image_GetRPPtr"

@{B}image_GetRPPtr@{UB}

@{B}Syntax:@{UB}  result.l = image_GetRPPtr \{image.l\}

@{B}Description:@{UB}
Get the pointer to the rastport of the image itself.

Note: This is very useful if yoou want to redirect blit commands into other images.

@{B}Inputs:@{UB}      
- image.l    : image object ID

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetTransparency "image_GetTransparency"

@{B}image_GetTransparency@{UB}

@{B}Syntax:@{UB}  result.l =  image_GetTransparency \{image.l,x.l,y.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- x.l    : ???
- y.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_GetWidth "image_GetWidth"

@{B}image_GetWidth@{UB}

@{B}Syntax:@{UB}  width.l =  image_GetWidth \{image.l\}

@{B}Description:@{UB}
Return the width of the specified image.

NOTE: Never use imagedat() variables directly as they may change in the future
NOTE: There exists also a macro, if you need to be really fast!

@{B}Inputs:@{UB}      
- image.l : image object ID

@{B}Result:@{UB}      
- width.l : width of the image

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    !image_width, image_height




@ENDNODE
@NODE image_Half "image_Half"

@{B}image_Half@{UB}

@{B}Syntax:@{UB}  result.l = image_Half \{image.l,srcimage.l\}

@{B}Description:@{UB}
Half the size of an image, doing pixel averaging.

@{B}Inputs:@{UB}      
- image.l    : image object ID to create
- srcimage.l    : source image object ID

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_InitBitMap "image_InitBitMap"

@{B}image_InitBitMap@{UB}

@{B}Syntax:@{UB}  result.l = image_InitBitMap \{image.l,@*friendlybitmap.BitMap\}

@{B}Description:@{UB}
Creates an OS friendly bitmap out of the given image.

NOTE: This image can only be blittet to the same screen. If you change the screen you have to release this image and call this function again.
NOTE: This function is called automatically at the first blit command, so there is normally no need to call this manually.

@{B}Inputs:@{UB}      
- image.l : image object ID
- *friendlybitmap.BitMap : friendly bitmap

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_InitMask "image_InitMask"

@{B}image_InitMask@{UB}

@{B}Syntax:@{UB} image_InitMask \{image.l,@trgb.l,@tolerance.l,@threshold.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- trgb.l    : ???
- tolerance.l    : ???
- threshold.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_InitRP "image_InitRP"

@{B}image_InitRP@{UB}

@{B}Syntax:@{UB}  result.l = image_InitRP \{image.l\}

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      
- image.l    : image object ID

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_IsPictureDT "image_IsPictureDT"

@{B}image_IsPictureDT@{UB}

@{B}Syntax:@{UB}  result.l = image_IsPictureDT \{filename.s\}

@{B}Description:@{UB}
Test, if this file can be loaded via Datatypes.

@{B}Inputs:@{UB}      
- filename.s    : file name of the image file to test

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_IsSolid "image_IsSolid"

@{B}image_IsSolid@{UB}

@{B}Syntax:@{UB}  result.l =  image_IsSolid \{image.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_IsUsed "image_IsUsed"

@{B}image_IsUsed@{UB}

@{B}Syntax:@{UB} result.l =  image_IsUsed \{image.l\}

@{B}Description:@{UB}
Test if the image number is in use (e.g. is loaded) or not

@{B}Inputs:@{UB}      
- image.l : image object ID

@{B}Result:@{UB}      
- True if image is used, otherwise False

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Load "image_Load"

@{B}image_Load@{UB}

@{B}Syntax:@{UB}  succ.l = image_Load \{image.l,filename.s,@trgb.l,@tolerance.l,@dithermode.l,@ditherthreshold.l\}

@{B}Description:@{UB}
Loads an image object.
All file formats that have a datatype installed are supported.
Additionally, ARGB PNG and AB2I files can be loaded directly.
It also supports loading alpha masks from png and iff ILBM files, if they contain any.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- filename.s : Complete dos filename including path
- trgb.l     : rgbvalue for the desired transparent color, e.g. $ff0000 for red
- tolerance.l  : tolerance in RGB steps for the transparency
- dithermode.l : see #image_dithermode_... for available dithermodes, in case the image is blittet on color index screens
- ditherthreshold.l    : ???

@{B}Result:@{UB}      
- succ.l     : True if everything went well, False if it failed

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_LoadShape "image_LoadShape"

@{B}image_LoadShape@{UB}

@{B}Syntax:@{UB}  succ.l = image_LoadShape \{bshape.l,filename.s,@trgb.l\}

@{B}Description:@{UB}
Replaces LoadShape with possibility to load 24bit images and all fileformats

NOTE: make sure to have a used screen before you call this
NOTE: if you change the screen you have to load the shape again
NOTE: the image and the shape object share the same obj number

@{B}Inputs:@{UB}      
- bshape.l   : Number of the image/shape "object"
- filename.s : filename of the image file (can be gif, jpg, iff, bmp usw.)
- trgb.l     : rgb value of the transparent color, e.g. $00ff00 for pure green

@{B}Result:@{UB}      
- succ.l     : True if everything went well, False if it failed

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_LoadViaDT "image_LoadViaDT"

@{B}image_LoadViaDT@{UB}

@{B}Syntax:@{UB}  result.l = image_LoadViaDT \{image.l,filename.s\}

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      
- image.l    : image object ID
- filename.s    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_LoadViaNI "image_LoadViaNI"

@{B}image_LoadViaNI@{UB}

@{B}Syntax:@{UB}  succ.l = image_LoadViaNI \{image.l,filename.s,@normal.l\}

@{B}Description:@{UB}
* private *
Loads an NewIcon .info file into an image object.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- filename.s : Complete dos filename including path
- normal :  0= selected, ><0 normal state
- normal.l    : ???

@{B}Result:@{UB}      
- succ.l     : True if everything went well, False if it failed

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_LoadViaPNG "image_LoadViaPNG"

@{B}image_LoadViaPNG@{UB}

@{B}Syntax:@{UB}  result.l = image_LoadViaPNG \{image.l,filename.s\}

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      
- image.l    : image object ID
- filename.s    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Lock "image_Lock"

@{B}image_Lock@{UB}

@{B}Syntax:@{UB}  result.l = image_Lock \{image.l\}

@{B}Description:@{UB}
* private *

@{B}Inputs:@{UB}      
- image.l    : image object ID

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_MakeBlockCookie "image_MakeBlockCookie"

@{B}image_MakeBlockCookie@{UB}

@{B}Syntax:@{UB} image_MakeBlockCookie \{bshape.l\}

@{B}Description:@{UB}
Creates a cookie for the given shape that is fully opaque.

@{B}Inputs:@{UB}      
- bshape.l    : object ID of the target blitz2 shape object

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_MakeCookie "image_MakeCookie"

@{B}image_MakeCookie@{UB}

@{B}Syntax:@{UB} image_MakeCookie \{image.l,bshape.l,trgb.l\}

@{B}Description:@{UB}
Creates a cookie for the given blitzshape with trgb as transparent color.

@{B}Inputs:@{UB}      
- image.l         : Number if the image object
- bshape.l        : Number of the shape object
- trgb.l          : Transparent color value, e.g. $00ff00 for green

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_MaskHit "image_MaskHit"

@{B}image_MaskHit@{UB}

@{B}Syntax:@{UB}  succ.l =  image_MaskHit \{image.l,x.l,y.l\}

@{B}Description:@{UB}
Test if the given coordinates hit the transparency mask or not

NOTE: this function can be used to detect collision with the foreground if you have foreground and background in two different images

@{B}Inputs:@{UB}      
- image.l       : image object ID
- x.l           : x position
- y.l           : y position

@{B}Result:@{UB}      
- succ.l        : True if the mask is set, False if it is transparent

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_MaskIsUsed "image_MaskIsUsed"

@{B}image_MaskIsUsed@{UB}

@{B}Syntax:@{UB}  result.l =  image_MaskIsUsed \{image.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_MidHandle "image_MidHandle"

@{B}image_MidHandle@{UB}

@{B}Syntax:@{UB} image_MidHandle \{image.l\}

@{B}Description:@{UB}
Defines the handle of the image as the middle.

@{B}Inputs:@{UB}      
- image.l       : image object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_OptimizeAlpha "image_OptimizeAlpha"

@{B}image_OptimizeAlpha@{UB}

@{B}Syntax:@{UB}  result.l = image_OptimizeAlpha \{image.l,threshold.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- threshold.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_PrepareAll "image_PrepareAll"

@{B}image_PrepareAll@{UB}

@{B}Syntax:@{UB} image_PrepareAll \{@*friendlybitmap.BitMap\}

@{B}Description:@{UB}
Prepares all loaded images for fastest blitting.
This is done automatically by the blit commands but takes some time, so you probably want to do this in advance and not in your game loop.

@{B}Inputs:@{UB}      
- *friendlybitmap.BitMap    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_RGB2YUV24 "image_RGB2YUV24"

@{B}image_RGB2YUV24@{UB}

@{B}Syntax:@{UB} image_RGB2YUV24 \{src.l,srcbpr.l,w.l,h.l,@GMASK.l,@CMASK.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- src.l    : ???
- srcbpr.l    : ???
- w.l    : ???
- h.l    : ???
- GMASK.l    : ???
- CMASK.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_RGB2YUV32 "image_RGB2YUV32"

@{B}image_RGB2YUV32@{UB}

@{B}Syntax:@{UB} image_RGB2YUV32 \{src.l,srcbpr.l,w.l,h.l,@GMASK.l,@CMASK.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- src.l    : ???
- srcbpr.l    : ???
- w.l    : ???
- h.l    : ???
- GMASK.l    : ???
- CMASK.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Read "image_Read"

@{B}image_Read@{UB}

@{B}Syntax:@{UB}  result.l = image_Read \{image.l,fid.l\}

@{B}Description:@{UB}
Read an image from an already open file.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- fid.l    : file handle returned by file_open (file.include)

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Release "image_Release"

@{B}image_Release@{UB}

@{B}Syntax:@{UB} image_Release \{image.l\}

@{B}Description:@{UB}
Releases the colormap allocations on the screen. Use this only if your image is not visible any more the idea of this is to free the pens allocated for this picture on the screen to get free pens for other graphic operations.

NOTE: after you have called this you have no guarrantee that your image is displayed with the right colors
NOTE: on 16/24bit screens this has no visual effect, because the image allocates no pens from the screens colormap
NOTE: before you close a screen where did some blitting you MUST call this function or free the images before
NOTE: before you blit the image to another screen you MUST release it!

@{B}Inputs:@{UB}      
- image.l : image object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_ReleaseAll "image_ReleaseAll"

@{B}image_ReleaseAll@{UB}

@{B}Syntax:@{UB} image_ReleaseAll \{\}

@{B}Description:@{UB}
Same like image_Release\{\} but releases all blitted images.

@{B}Inputs:@{UB}      none

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_RemClip "image_RemClip"

@{B}image_RemClip@{UB}

@{B}Syntax:@{UB} image_RemClip \{image.l\}

@{B}Description:@{UB}
Remove a layer clip region on an image rastport.

@{B}Inputs:@{UB}      
- image.l    : image object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Resize "image_Resize"

@{B}image_Resize@{UB}

@{B}Syntax:@{UB}  result.l = image_Resize \{dstimage.l,srcimage.l,newwidth.l,@newheight.l,@interpol.l,@sharpness.f\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- dstimage.l    : ???
- srcimage.l    : ???
- newwidth.l    : ???
- newheight.l   : ???
- interpol.l    : ???
- sharpness.f   : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Resize2 "image_Resize2"

@{B}image_Resize2@{UB}

@{B}Syntax:@{UB}  result.l = image_Resize2 \{image.l,srcimage.l,newwidth.l,newheight.l,@smoothing.f\}

@{B}Description:@{UB}
Resize an image.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- srcimage.l    : source image object ID
- newwidth.l    : new pixel width
- newheight.l    : new pixel height
- fast.l    : 0 = fast, quality otherwise
- smoothing.f    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Resize3 "image_Resize3"

@{B}image_Resize3@{UB}

@{B}Syntax:@{UB}  result.l = image_Resize3 \{image.l,srcimage.l,newwidth.l,@newheight.l,@interpol.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- srcimage.l    : ???
- newwidth.l    : ???
- newheight.l    : ???
- interpol.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Resize4 "image_Resize4"

@{B}image_Resize4@{UB}

@{B}Syntax:@{UB}  result.l = image_Resize4 \{dstimage.l,srcimage.l,newwidth.l,@newheight.l,@interpol.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- dstimage.l    : ???
- srcimage.l    : ???
- newwidth.l    : ???
- newheight.l    : ???
- interpol.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_RotateBlit "image_RotateBlit"

@{B}image_RotateBlit@{UB}

@{B}Syntax:@{UB} image_RotateBlit \{image.l,x.l,y.l,angle.f,@zoom.f,@fast.l,@*rp.RastPort\}

@{B}Description:@{UB}
Blit a picture, rotated at any angle.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- x.l    : x position
- y.l    : y position
- angle.f    : angle
- zoom.f    : zoom
- fast.l    : -1 = use fast function, 0 = use quality function
- *rp.RastPort    : destination rastport

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Save "image_Save"

@{B}image_Save@{UB}

@{B}Syntax:@{UB}  succ.l = image_Save \{image.l,filename.s,@form.l,@compress.l,@flags.l,@image2.l\}

@{B}Description:@{UB}
Writes the image in various file formats into an already open file.
The file must be opened via file.include,
NOTE: Use this function if you want To store an image embedded in your own file format, use image_save if you just
want to save a picture !
You can also save a bunch of images like e.g. an animation sequence, if you use AB2I.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- filename.s : filename for the image(s)
- form.l     : must be one of
@"ILBM" - 24bit iff-ilbm image
@"PNG" - 24bit png image
@"JPEG" - 24bit jpeg image
@"AB2I" - AB2 image file format
- compress.l : -1 = default compression, 0 = no compression, 1...9 zlib compression level, 1 = fast / 9 = best
- image2.l   : if not -1, all images between image and image2 will be saved into this file, works only with form = @"AB2I"
- flags.l    : ???

@{B}Result:@{UB}      
- succ.l     : True if everything went well, False if it failed

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_SaveDT "image_SaveDT"

@{B}image_SaveDT@{UB}

@{B}Syntax:@{UB}  result.l = image_SaveDT \{image.l,filename.s\}

@{B}Description:@{UB}
* private *
Save a picture via datatypes, highly experimental - dont try this at home !

@{B}Inputs:@{UB}      
- image.l    : image object ID
- filename.s    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_SetAlpha "image_SetAlpha"

@{B}image_SetAlpha@{UB}

@{B}Syntax:@{UB}  result.l = image_SetAlpha \{image.l,A.l\}

@{B}Description:@{UB}
Set the alpha channel of an image to a fix value.
NOTE: This can be used to flush an aplha channel (A=$0) or to set it opaque (A=$FF)

@{B}Inputs:@{UB}      
- image.l    : image object ID
- A.l    : alpha value

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_SetBlitBounds "image_SetBlitBounds"

@{B}image_SetBlitBounds@{UB}

@{B}Syntax:@{UB} image_SetBlitBounds \{image.l,@x1.l,@y1.l,@x2.l,@y2.l\}

@{B}Description:@{UB}
Set the clip bound of an image object. This is useful, if you plan to blit only a certain area of the image.
The clip bounds work with most blit commands.

@{B}Inputs:@{UB}      
- image.l    : image to attach the clip bounds to
- x1.l    : coordinates of the clipbounds within the image
- y1.l
- x2.l
- y2.l

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        This functionality is not fully implemented yet. For the time beeing, use @{" image_BlitArea " link image_BlitArea}.



@{B}See also:@{UB}    -


@ENDNODE
@NODE image_SetBlitDims "image_SetBlitDims"

@{B}image_SetBlitDims@{UB}

@{B}Syntax:@{UB} image_SetBlitDims \{image.l,@x1.l,@y1.l,@xs.l,@ys.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- x1.l    : ???
- y1.l    : ???
- xs.l    : ???
- ys.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_SetClip "image_SetClip"

@{B}image_SetClip@{UB}

@{B}Syntax:@{UB} image_SetClip \{image.l,x1.l,y1.l,x2.l,y2.l\}

@{B}Description:@{UB}
Set a clip region to the images rastport.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- x1.l    : ???
- y1.l    : ???
- x2.l    : ???
- y2.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_SetDitherMode "image_SetDitherMode"

@{B}image_SetDitherMode@{UB}

@{B}Syntax:@{UB} image_SetDitherMode \{image.l,dithermode.l\}

@{B}Description:@{UB}
Defines the dithermode.
NOTE: this has only effect on 8bit or lower screens

@{B}Inputs:@{UB}      
- image.l       : image object ID
- dithermode.l  : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_SetFileName "image_SetFileName"

@{B}image_SetFileName@{UB}

@{B}Syntax:@{UB} image_SetFileName \{image.l,filename.s\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- filename.s    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_SetHandle "image_SetHandle"

@{B}image_SetHandle@{UB}

@{B}Syntax:@{UB} image_SetHandle \{image.l,x.l,y.l\}

@{B}Description:@{UB}
Defines the handle of the image. Default is the left-top edge.

@{B}Inputs:@{UB}      
- image.l       : image object ID
- x.l           : x-handle
- y.l           : y-handle

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_SetLoadDevisor "image_SetLoadDevisor"

@{B}image_SetLoadDevisor@{UB}

@{B}Syntax:@{UB} image_SetLoadDevisor \{devisor.l\}

@{B}Description:@{UB}
Allow a 2^ downscale factor for @{" image_Load " link image_Load}.

@{B}Inputs:@{UB}      
- devisor.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        This feature might be broken at the moment. I suggest to use@{" image_Half " link image_Half}.



@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Test "image_Test"

@{B}image_Test@{UB}

@{B}Syntax:@{UB}  result.l = image_Test \{filename.s\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- filename.s    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_TextureBlit "image_TextureBlit"

@{B}image_TextureBlit@{UB}

@{B}Syntax:@{UB} image_TextureBlit \{image.l,*coos.texturearray,@brightness.l,@db.l,@fast.l,@*rp.RastPort\}

@{B}Description:@{UB}
Blit in perspective.

@{B}Inputs:@{UB}      
- image.l    : image object ID
- *coos.texturearray    : ???
- brightness.l    : ???
- db.l    : ???
- fast.l    : ???
- *rp.RastPort    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_TextureTriBlit "image_TextureTriBlit"

@{B}image_TextureTriBlit@{UB}

@{B}Syntax:@{UB} image_TextureTriBlit \{image.l,*coos.texturearray,@*rp.RastPort\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- *coos.texturearray    : ???
- *rp.RastPort    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_TwoThird "image_TwoThird"

@{B}image_TwoThird@{UB}

@{B}Syntax:@{UB}  result.l = image_TwoThird \{image.l,srcimage.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- srcimage.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_UnfilterDelta32 "image_UnfilterDelta32"

@{B}image_UnfilterDelta32@{UB}

@{B}Syntax:@{UB} image_UnfilterDelta32 \{src.l,srcbpr.l,dst.l,dstbpr.l,w.l,h.l,@ARGBMASK.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- src.l    : ???
- srcbpr.l    : ???
- dst.l    : ???
- dstbpr.l    : ???
- w.l    : ???
- h.l    : ???
- ARGBMASK.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_Unlock "image_Unlock"

@{B}image_Unlock@{UB}

@{B}Syntax:@{UB} image_Unlock \{image.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : image object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" image_Lock " link image_Lock}




@ENDNODE
@NODE image_UnlockForce "image_UnlockForce"

@{B}image_UnlockForce@{UB}

@{B}Syntax:@{UB} image_UnlockForce \{image.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : image object ID

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    @{" image_Lock " link image_Lock}




@ENDNODE
@NODE image_Write "image_Write"

@{B}image_Write@{UB}

@{B}Syntax:@{UB}  succ.l = image_Write \{image.l,fid.l,@form.l,@compress.l,@flags.l\}

@{B}Description:@{UB}
Writes the image in various file formats into an already open file.
The file must be opened via file.include.

NOTE: Use this function if you want To store an image embedded in your own file format, use @{" image_Save " link image_Save} if you just want to save a picture !

@{B}Inputs:@{UB}      
- image.l    : image object ID
- fid.l      : fid handle obtained by file_Open\{\}
- compress.l : -1 = default compression, 0 = no compression, 1...9 zlib compression 1 = fast / 9 = best
- form.l     : must be one of
@"ILBM" - 24bit iff-ilbm image
@"IIMG" - internal image format, can only be loaded by image.include
- flags.l    : ???

@{B}Result:@{UB}      
- succ.l     : True if everything went well, False if it failed

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_WriteMask "image_WriteMask"

@{B}image_WriteMask@{UB}

@{B}Syntax:@{UB}  result.l = image_WriteMask \{image.l,fid.l,@compress.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- image.l    : ???
- fid.l    : ???
- compress.l    : ???

@{B}Result:@{UB}      
- result.l     : ???

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_YUV2RGB24 "image_YUV2RGB24"

@{B}image_YUV2RGB24@{UB}

@{B}Syntax:@{UB} image_YUV2RGB24 \{src.l,srcbpr.l,w.l,h.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- src.l    : ???
- srcbpr.l    : ???
- w.l    : ???
- h.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
@NODE image_YUV2RGB32 "image_YUV2RGB32"

@{B}image_YUV2RGB32@{UB}

@{B}Syntax:@{UB} image_YUV2RGB32 \{src.l,srcbpr.l,w.l,h.l\}

@{B}Description:@{UB}
* no description available *

@{B}Inputs:@{UB}      
- src.l    : ???
- srcbpr.l    : ???
- w.l    : ???
- h.l    : ???

@{B}Result:@{UB}      none

@{B}Example:@{UB}     no example

@{B}Bugs:@{UB}        no bugs

@{B}See also:@{UB}    -


@ENDNODE
