@Database "AB3Includes"
@$VER 1.5
@Width 80
@wordwrap
@xsmartwrap
@TAB 3
@Node Main "Table Of Contents"
@{jcenter}
@{fg shine}____________________________________________________________________________@{fg shadow}
@{fg text}
@{B}AB3 Includes V1.6 @{UB}
a Source Code Library for AB3
� 1998-2007 Thilo Koehler / Support: support@hd-rec.de
@{fg shine}____________________________________________________________________________@{fg shadow}
@{fg text}
@{jleft}
  @{B}TABLE OF CONTENTS (Date: 06.12.2007)@{UB}

  @{B}1. Introduction@{UB}
      @{"   " link intro} What are the AB3 Includes?
      @{"   " link basics} Basic concept

  @{B}2. Technical Stuff@{UB}
      @{"   " link install} Installation  
      @{"   " link requirements} Requirements
      @{"   " link "history.guide/main"} History
            
  @{B}3. How Do I ... ?@{UB}
      @{"   " link internet} ...make an Internet application               
      @{"   " link games} ...make a 2D game (gfx, sfx and control)
      @{"   " link file} ...do file I/O
      @{"   " link tui} ...make nice GUI
      @{"   " link audio} ...deal with audio files
      @{"   " link own} ...write my own includes
      @{"   " link faq} FAQ
                      
  @{B}4. Include Reference@{UB}
      @{" ahi_device.include " link "ahi_device.include.guide/main" }
      @{" amigaguide.include " link "amigaguide.include.guide/main" }
      @{" app.include " link "app.include.guide/main" }
      @{" arexx.include " link "arexx.include.guide/main" }
      @{" asl.include " link "asl.include.guide/main" }
      @{" camd.include " link "camd.include.guide/main" }
      @{" ciatimer.include " link "ciatimer.include.guide/main" }
      @{" clipboard.include " link "clipboard.include.guide/main" }
      @{" colmap.include " link "colmap.include.guide/main" }
      @{" convert.include " link "convert.include.guide/main" }
      @{" crc32.include " link "crc32.include.guide/main" }
      @{" dbl_display.include " link "dbl_display.include.guide/main" }
      @{" dos.include " link "dos.include.guide/main" }
      @{" dsp.include " link "dsp.include.guide/main" }
      @{" dynamicarray.include " link "dynamicarray.include.guide/main" }      
      @{" eclock.include " link "eclock.include.guide/main" }
      @{" error.include " link "error.include.guide/main" }
      @{" fft.include " link "fft.include.guide/main" }
      @{" file.include " link "file.include.guide/main" }
      @{" file_audio.include " link "file_audio.include.guide/main" }
      @{" file_config.include " link "file_config.include.guide/main" }
      @{" file_instr.include " link "file_instr.include.guide/main" }
      @{" font.include " link "font.include.guide/main" }
      @{" gtimer.include " link "gtimer.include.guide/main" }
      @{" http.include " link "http.include.guide/main" }
      @{" id3tag.include " link "id3tag.include.guide/main" }
      @{" image.include " link "image.include.guide/main" }
      @{" image_ext.include " link "image_ext.include.guide/main" }
      @{" intuition.include " link "intuition.include.guide/main" }
      @{" lexicon.include " link "lexicon.include.guide/main" }
      @{" longlong.include " link "longlong.include.guide/main" }
      @{" map.include " link "map.include.guide/main" }
      @{" md5.include " link "md5.include.guide/main" }
      @{" midi_device.include " link "midi_device.include.guide/main" }
      @{" msgport.include " link "msgport.include.guide/main" }
      @{" multilist.include " link "multilist.include.guide/main" }
      @{" opengl.include " link "opengl.include.guide/main" }
      @{" perlin.include " link "perlin.include.guide/main" }
      @{" plugin_api.include " link "plugin_api.include.guide/main" }
      @{" prefixtree.include " link "prefixtree.include.guide/main" }
      @{" random.include " link "random.include.guide/main" }
      @{" rastport.include " link "rastport.include.guide/main" }
      @{" rawkey.include " link "rawkey.include.guide/main" }
      @{" screen.include " link "screen.include.guide/main" }
      @{" semaphore.include " link "semaphore.include.guide/main" }
      @{" serial_device.include " link "serial_device.include.guide/main" }
      @{" tcp.include " link "tcp.include.guide/main" }
      @{" tui.include " link "tui.include.guide/main" }
      @{" undo.include " link "undo.include.guide/main" }
      @{" vvblank.include " link "vvblank.include.guide/main" }
      @{" window.include " link "window.include.guide/main" }
      @{" xlog.include " link "xlog.include.guide/main" }
  
  @{B}5. Supporting Includes @{UB}
      (Includes that are needed but not very interesting for users)  
      @{" asm_audio.include " link "asm_audio.include.guide/main" }
      @{" blademp3.include " link "blademp3.include.guide/main" }
      @{" convert_audio.include " link "convert_audio.include.guide/main" }
      @{" cpu.include " link "cpu.include.guide/main" }
      @{" gus.include " link "gus.include.guide/main" }
      @{" iff-ilbm.include " link "iff-ilbm.include.guide/main" }
      @{" jpeg.include " link "jpeg.include.guide/main" }
      @{" libcall.include " link "libcall.include.guide/main" }
      @{" mod.include " link "mod.include.guide/main" }
      @{" mousepointer.include " link "mousepointer.include.guide/main" }
      @{" mpega.include " link "mpega.include.guide/main" }
      @{" png.include " link "png.include.guide/main" }
      @{" ptplay.include " link "ptplay.include.guide/main" }
      @{" useful.include " link "useful.include.guide/main" }
      @{" sf2.include " link "sf2.include.guide/main" }
      @{" strptr.include " link "strptr.include.guide/main" }
      @{" tempbuffer.include " link "tempbuffer.include.guide/main" }
      @{" ylog.include " link "ylog.include.guide/main" }
  
@ENDNODE

@NODE intro "What are the AB3 Includes?"

@{B}Introduction@{UB}
The AB3 Includes represent a huge AB3 source code library that was created mainly by Thilo Koehler over many years. This is not just a collection of functions or thrown-together code snippets, they are organized like Blitzlibs.

The basic idea is to encapsule a certain topic (like AHI audio output) into one reusable piece of code and use only the public functions (=API). The same code can be included in many programs, and will get therefore more robust against bugs than an individual implementation for every project. Bugfixes will improve all programs by a simple recompile. You will also benefit from my AB3 experience that went into this includes, they can be regarded as new Blitzlibs or replacements for old, buggy, custom-chip dependent Blitzlibs.

Compared to Blitzlibs, the include concept has several advantages:
  
  - YOU own the source code, and you can read, edit and learn from it
  - if there is a bug, YOU can fix it
  - if there is a missing feature, YOU can add it
  - the source is (mostly) in AB3, so no fiddling around with cryptic 68k ASM
  - only functions that are used in your program will be compiled into the final executable
  - they provide functionality, where no Blitzlibs exist for, e.g. 24bit pictures, RTG double buffering etc.

A lot of problems have already been solved in AB3 (such as AHI, 24bit images, TCP/IP, 2D Game API), so in many cases you will find the solution to your specific programming problem in this piece of work.
You are allowed to use the includes in your source code, or just take their source as an example how to do the trick, even for commercial projects.
  
If you improve the includes, I would like to get a copy to merge them with my sources and release it, so others can benefit from your work. I kindly ask you to NOT release includes that are based on my includes, to avoid confusion about the versions. If you did a nice include on your own, it would be a good idea to add them to this archive.
  
@{B}Why should I use your includes ?@{UB}
The includes have been tested over many years in many different programs, and are made compatible with many platforms. To achieve the same functionality and stability across the platforms, you will need years - like me.
Most of the includes (unlike many BlitzLibs) run on Classic, WinUAE, Amithlon, OS4 and MOS without any changes. Plus, you have the source in nice, readable AB3 code, and you can bugfix, improve or adapt it to your needs, any time you fancy.
 
If you have further questions feel free to contact me (support@hd-rec.de).

Thilo Koehler.

@ENDNODE

@NODE basics "Basic Concept"

@{B}Some ideas behind it@{UB}
I tried to make all includes as encapsuled as possible, that means you don't have to know how the include does the trick, and you have as few sideffects as possbile. However, I was not always successful.

@{B}How to use them?@{UB}
Simple include them with a

@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}
  @{fg highlight}XINCLUDE @{fg text}"whatsoever.include.ab3"
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}

and all commands of <whatsoever> will be available.
If you have installed the includes correctly, AB3 will find them automatically.
You will notice that some includes require others, e.g. almost every include uses the "error.include.ab3" to display error messages. You don't have to take care about this, because every include does an "XInclude" for all required other includes. If you want to use the file.include, doing XInclude "file.include.ab3" is enough, even if it uses the error.include, dos.include and filerequester.include.
After including, all functions can be used within your code, but only the used ones will be compiled into your executable.
  
@{B}Naming conventions@{UB}
All functions and specific constants from the xyz_include will start with xyz, e.g. "file_open{}" comes from the file_include, image_blit{} can be found in the image.include.
There are some exceptions, e.g. functions from fileformat_audio.include.bb2 are called ffa_... for shortening reasons.
You might find some global variables. Typically they are made unique by naming them like the include, e.g. in the tui.include you will find the "tuiengine" and "tuidat()", whereas the "engine" variables contain typically data shared accross all objects created by this include, and the "dat()" array contains the single objects.
e.g. imageengine keeps screen pen information, and imagedat() the single image objects, with all its data like width, height, depth and pixel data.

@{B}How can I set the maximum number for objects of an include?@{UB}
Some includes deal with objects, like the image.include. Every "image" is an object. To set the maximum number, you set BEFORE the XInclude: "#max_images=1234".
Note: Not all includes use objects, not all use only on type of object. Have a look at the top of the source what kind of maximums are available and how they are spelled.
Sometimes they also have specific options for compiling. Constants, that can be defined by the user typically look like this:
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}
  @{fg highlight}CNIF @{fg text}@#user_constant=0
     #user_constant = @{fg shadow}<default value>@{fg text}
  @{fg highlight}CEND@{fg text}
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}

@{B}Are there demos?@{UB}
Yes. Nearly every include has a built-in demo, if you compile the include itself. To see the source of the demo, scoll to the bottom of the include and see the part of code after
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}
  @{fg highlight}CNIF @{fg text}#__include=0
     @{fg shadow}<here is the demo code>@{fg text}
  @{fg highlight}CEND@{fg text}
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}
  
Note: The built-in demos are usually very small, and show only the very basic usage of a few commands. Bigger demos, or demos that demonstrate more than one include, can be found in the subdirectory "demos" in this archive.
  
@{B}What is the "!autoexit" thing?@{UB}
The !autoexit is a macro that defines a function to be executed when a AB3 program terminates, may it be a normal termination or a forced termination by the Debugger. AB3 will call the function mentioned in this macro. This way, you don't have to free all resources before you do "End", like you would expect from a "Basic" language. But anyway, it is a good idea to free all data correctly, bringing some discipline into your programming style.

@ENDNODE

@NODE install "How to install them ?"

@{B}Installation@{UB}
Copy the directory "Includes/" to your "Blitz2:" path. If you prefere them to store somewhere else, set the tooltype "INCDIR=DH0:MySources/Includes/" of the Amitlbitz2 icon accordingly.
  
The other source codes from this archive can be stored wherever you want, but you should keep the directory strcuture. I recommend to use the structure like it is, and adjust the INCDIR tooltype. This makes updates easier.

@ENDNODE

@NODE own "How to write your own includes"

@{B}Programming style@{UB}
* try to use as few Blitzlibs as possible, in the best case use none
(Blitzlibs are manually coded 68K ASM, and may contain hard-to-fix bugs, maybe you don't have the source at all, don't make yourself dependent on them!)
   
* use OS libraries whenever possible, or Amiga Shared Libraries that are still developed

* use other includes for more complex tasks, if there are any suitable ones, don't reinvent the wheel in every include
  
* use ???engine as a global variable of NewType.???engine to hold your global data
(e.g. imageengine stores pen allocations, tuiengine the configuration of the GUI toolkit)
  
* use ???dat() as a global array of NewType.???dat to hold your objects, if there are any
(e.g. imagedat() holds image objects, tuidat() holds tui objects/widgets)
  
* use #max_???s to specify the size of the ???dat() array, and set the default number like this:
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}
  @{fg highlight}CNIF@{fg text} #max_???s = 0
    #max_???s = @{fg shadow}<default values>@{fg text}
  @{fg highlight}CEND@{fg text}
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}
     
* set other user changable default values the same way like maximum values

* make a short, 1-page demo of your include at the end of the include, embedded in
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}
  @{fg highlight}CNIF@{fg text} #__include=0
     @{fg shadow}<demo code>@{fg text}
  @{fg highlight}CEND@{fg text}
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}
This is only compiled if the include is compiled stand alone, and will not influence anything if your file is used as an include

* use the !autoexit{} macro to specify a function that will clean up everything your include made dirty. Expect this function to be called when the "End" Statement is executed or when the user terminates the program using the debugger. The function might be called twice or when nothing was allocated!

* format the source nicely. If you make an If, While, For, go 2 spaces deeper, e.g.
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}
  @{fg highlight}If@{fg text} mycondition
    @{fg shadow}<do something>@{fg text}
  @{fg highlight}Else@{fg text}
    @{fg shadow}<do something different>@{fg text}
  @{fg highlight}End If@{fg text}
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}

* try to avoid "Goto", everything is possible without "Goto"!

* try to avoid 68K ASM, onyl when you really, really need it!

* check functions that can fail always for failure, e.g. Allocmem_()

* if your function can fail, let the API programmer be able to catch the error by using a function with "success" as a return value istead of an Statement, or use a special value to indicate failure, e.g. -1 when you want to return a valid object number, or 0 if you want to return a memory pointer.

* if you make heavy use of strings, better operate with pointers on them. Otherwise, the string will be copied all the time, which is much slower and fragments the memory.
  E.g. Peek.l(&a.s-4) gives you the length of the string, much faster than Len(a.s), and there is a macro !slen{a.s} to do this for you.
  
@ENDNODE

@NODE requirements "Requirements"

@{B}Requirements@{UB}
As I always use the newest features that Bernd Roesch does to AB3, you will always need the newest version to compile the includes! don't complain that they don't compile if you are using a one year old AB3 or maybe even BlitzBasic2 - this wont do it!
  
Most includes require "OPTIMIZE 7" and "SYNTAX 2" at the beginning of your program, which is a good setting to create release executables.
 
AB3 runns nicely on Classic, WinUAE, Amtihlon and MOS. Under OS4, you can not use the debugger, but you can compile programs. (turn the debugger off in compiler options)

@ENDNODE

@NODE faq "FAQ"

@{B}FAQ (Frequently Asked Questions)@{UB}

@{B}Q: Can I do <put here whatever> with your includes ?@{UB}
@{B}A:@{UB} First, check this guide for suitable includes. If there are none, think if this is suitable to make an include out of it. Ask in an Amiblitz mailing group if this can be implemented, or think about  implementing your own include!
  
@ENDNODE

@NODE audio "Audio Files"

@{B}Audio Files@{UB}
There is an include called file_audio.include. Using this include, you can load and save the audio fileformats: aiff, wav, 8svx, maud, cdda, raw. You can also read mp2 and mp3, if the switch #use_mpega=1 is set before including.
  
While reading and writing, you can have a on-the-ly convertion of the audio data. E.g. if you want always 16bit mono, you can read out of every file 16 bit mono data, without taking care how the file actually is encoded. You still can detect the files encoding of course    .
 
@ENDNODE

@NODE tui " ...make nice GUI"

@{B}GUI applications@{UB}
There are many way to create a GUI. You can use MUI, Gadtools, Reaction etc. AB3 has good support for MUI and for Gadtools. Some people don't like MUI and some want more control over the GUI objects, but Gadtools is too poor for a nice GUI. The solution here is "TUI" (Thilos User Interface). But before you scream "Oh my god, not another GUI toolkit", I can calm you down: It is not really a new toolkit, and it will run on all platforms that support Gadtools, and that are all platforms so far. Why Gadtools ? TUI uses Gadtools Gadgets for most things, but arranges them dynamically very similar to MUI. Examples for a TUI GUI are HD-Rec, TuiTED and PosTED.

@{B}TUI applications@{UB}
You surely want to avoid to start a program and then half way find out, that your choise of GUI Toolkit does not support what you need. In case of TUI, you have the source code available and can add new widgets. But this requires to understand tui quite deeply. So here is the checklist:

Widget types:
  
"borrowed" from Gadtools:
  * text button
  * horizontal/vertical scroller/slider (otpional arrow buttons)
  * num/string gadget (optional +/- buttons)
  * cycle gadget
  * checkbox
  
own implementation:
  * group object
  * page groups (with tabs)
  * 24 bit image button (click or toggle)
  * 24 bit image/anim
  * simple spacer
  * (multi column) listview
  * texteditor (configurable (editpad vs. Ped), build in copy&paste clipboard, undo, build-in HTML and C highlightning)
  * tree view (direct support for directory structures, but also custom tree-like lists are possible)
  * text label 
  * custom "view" (like the wavesample and MIDI editor in HD-Rec)
  * progresss bar
  * audio levelmeter (like the HD-Rec audio mixer)
  * gain slider (like in the HD-Rec audio mixer)
  * envelope for synthesizers
  
All widgets can have a help-bubble (small help text that appears after resting a few seconds over the widget) and a mouse-over effect, adding a border when the user moves the mouse over the widget. All objects can detect a mouse click on them, including coordinates.
  
For a quick test, you can run the built-in demo of the tui.include, showing you most of the widgets.
  
You can use the "App" functionality through the app.include, giving you a menu entry in the Workbenchs App menu, and an optional App-Icon on the desktop, which you can show/hide, e.g. your program can iconify.
You can also get drag&drop messages on the app icon or your windows. TUI will find out for your, which widget was hit. E.g. you can program a disk filer with two listviews showing two directories, and if the user drops a disk or folder icons, you can detect which listview was meant.
  
However, the tui.include grew over a couple of years, and was not designed straight forward. Using the include is a bit tricky therefore. Check out the TUI demos found in the demo drawer of this archive.
  
@ENDNODE


@NODE games " ...make a 2D game"

@{B}2D Games@{UB}
If you plan a 2D game, there are some important includes for you to do system friendly graphics, audio (sounds and mp3 music) and keyboard control. 
 
@{B}Graphics@{UB}
The original Blitzbasic Shapes and other graphics commands are limited to 8-bit (max 256 colours), and many of the functions don't work on the new platforms. So unless you want to write a game exclusive for A500 Users, you will need the image.include to deal with 1-24bit images.
  
The image.include provides a lot of functions to load, blit and save 24bit images. You can also blit on colour mapped screens (<256 colours) without takeing care of remapping, only alpha channel related commands need a 16 or 24 bit screen.
There are some limitations on AGA/OCS, but if you keep things simple it will work here as well.
  
@{B}Double Buffering@{UB}
If you plan a full screen game, you will need double buffering to avoid ugly flickering. Here the dbl_display.include comes into play. It provides functions to open a screen (using BestModeID !), blit objects and refresh backgrounds, do collision and make a good timing using the timer.device (remember we don't want to reply on the existence of a VBlank interrupt anymore, which gives only fix 50Hz anyway!).
 
A simple ball bouncing demo (system friendly in 1-24bit, 640x480 on GFX card, running on OS4, MOS, Amithlon, WinUAE and Classic) can be done like this:

@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}
@{fg highlight}XINCLUDE@{fg text} "dbl_display.include.ab3"  @{fg shadow}; include the important stuff!@{fg text}

@{fg shadow}; Our bouncing ball newtype !@{fg text}
@{fg highlight}NEWTYPE@{fg text}.ball : x.f:y.f:xv.f:yv.f :@{fg highlight}End NEWTYPE@{fg text}

@{fg shadow}; define ball list and add some balls@{fg text}
@{fg highlight}Dim List@{fg text} ball.ball(0) : @{fg highlight}If AddItem@{fg text}(ball()) Then  ball()\x=  0,200,1,-2

@{fg shadow}; load graphics (image 0 is reserved by dbl_display!)@{fg text}
succ.l = image_load {1,"/gfx/glass_big",$FF00FF,20}  : image_midhandle {1}

@{fg shadow}; init screen (using bestmodeID for 640x480 True colour)@{fg text}
@{fg highlight}If@{fg text} dbl_init {"MyGame",-1,640,480,24}
  @{fg highlight}Repeat@{fg text}
    dbl_flip{} @{fg shadow}; flip the doublebuffer (default is synced with 50Hz )!@{fg text}

    dbl_unqueue{} @{fg shadow}; unblit all objects drawn with "dbl_q???" functions@{fg text}

    @{fg shadow}; move and draw all balls@{fg text}
    @{fg highlight}ResetList@{fg text} ball()
    @{fg highlight}While NextItem@{fg text}(ball())
      ball()\yv + 0.1      @{fg shadow}; gravity!@{fg text}
      ball()\x+ball()\xv   @{fg shadow}; move ball in x-direction@{fg text}
      ball()\y+ball()\yv   @{fg shadow}; move ball in y-direction@{fg text}

      @{fg highlight}If@{fg text} ball()\x<0 @{fg highlight}OR@{fg text} ball()\x>!dbl_width  @{fg highlight}Then@{fg text} ball()\xv=-ball()\xv @{fg shadow}; bounce on sides@{fg text}
      @{fg highlight}If@{fg text} ball()\y<0 @{fg highlight}OR@{fg text} ball()\y>!dbl_height @{fg highlight}Then@{fg text} ball()\yv=-ball()\yv @{fg shadow}; bounce top/bottom@{fg text}

      dbl_qblit {2,ball()\x,ball()\y}     @{fg shadow};draw the ball@{fg text}
    @{fg highlight}Wend@{fg text}

  @{fg highlight}Until Event@{fg text}=#IDCMP_MOUSEBUTTONS @{fg shadow}; until user pressed a mousebutton@{fg text}
@{fg highlight}End If@{fg text}
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}

See also the other demos of the dbl_display.include!

@{B}Keyboard/Mouse Control@{UB}
To be able to have responsive input control in an action game, you can use the intuition.include.
Throw away all Blitz "Event" commands, and replace them with the corresponding command from this include. E.g. Event will be intui_event{}, EventCode => !event_code, GadgetHit => !event_gadgethit. It is 100% system friendly, does no hacks or installs 68K hooks.
For game keyboard control, you can check a key for the status with intui_rawkeystate{keycode}.
At the same time, you can check for any IDCMP messages, or check if the menu is open or closed. This works on all platforms, and brings some bugfixes e.g. for scroller gadgets, which have problems with the arrow buttons if you use Blitz commands. There are new features as well, like checking if the menu is currently open, which mouse button was pressed and if it is currently pressed, getting mouse coordinates of any events, detect double click etc.
  
See also the dbl_simple_10_control demo!


@{B}AHI Audio@{UB}
To be able to have audio in your game or app, you need the ahi_device.include.
The old Blitz commands work only if the Paula chip is present - which is not the case on Amithlon, OS4 and MOS. It also breaks the 4 channel, 8bit and 29kHz limit.
  
You can load aiff, wav, iff-8svx, maud, cdda and mp2/mp3 files and play them back.
Long files, typically mp3, can be streamed doublebuffered from disk, so no need to load a 50MB sample into ram. This can be used for background music in games, while at the same time you can play back sounds from RAM like shots, explosions etc.
  
This include is also very useful to pimp up applications, to give system gongs etc.
   
@ENDNODE

@NODE internet " ...make an Internet application"

Yes, writing an internet application such as a Web Browser, Email client or Webcrawler is possbile with AB3.
  
@{B}TCP/IP@{UB}
First, all communication goes though the TCP/IP protocol. The tcp.include is doing this for you.
You create a "socket", which represents your "end point" of an internet (or LAN) connection.
If your "socket request" is accepted on the other shide, you can transmit any data you like, i.e. text or binary data.
  
WHAT YOU CAN NOT DO: You can currently not WAIT for an incomming socket request, so you can only write client-type applications, not servers. This means you can not write an internet game :-(
To do this, someone has to implemt this using the bsdsocket.library API, which is generally possbile, but nobody did this so far.
  
@{B}HTTP@{UB}  
On top of the TCP/IP protocol, there is HTTP. You create a socket connection to a webserver, and then send some text data that goes along the HTTP specifications. You will receviethen from the server and answer, and then probably some data, and then the socket is closed.
The http.include is doing this for you, as easy as:

@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}
  @{fg highlight}If@{fg text} http_attempt {0,"www.hd-rec.de/index.html"}
    @{fg highlight}While@{fg text} http_check {} = @{fg highlight}False@{fg text}: @{fg highlight}Delay_@{fg text} 1: @{fg highlight}Wend@{fg text}
    a.s = http_received_body {}
    @{fg highlight}NPrint@{fg text} a.s @{fg shadow}; print the received html file!@{fg text}
  @{fg highlight}End If@{fg text}
@{fg shine}__________________________________________________________________@{fg text} snip!
@{fg shadow}���������������������������������������������������������������������������������������������������������������������������@{fg text}

As you can see, the download is asynchron, so you can do somehting else meanwhile.
This example is very primitive, but it gives you an idea how it works.
You will not need to access the tcp.include command directly, if you plan to use the HTTP protocol. You only need the tcp.include for other protocols, e.g. Email, Gnutella etc.
  
@ENDNODE








