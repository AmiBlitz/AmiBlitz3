@DATABASE AmiBlitz³.guide
@INDEX main
@Width 80
@REMARK $VER: AmiBlitz³ Guide 0.4

@NODE main "AmiBlitz³ Guide"

@{B}AmiBlitz³@{UB} Programming Language - Documentation                (date: 24.05.2010)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                                            
  Table of Contents 
  
  1 @{"Introduction"                 link "Abstract"}

  2 @{"Syntax"                       link "Syntax"}
  2.1 @{"Program Flow"               link "ProgramFlow"}
  2.2 @{"Variables"                  link "Variables"}
  2.3 @{"Arrays"                     link "Arrays"}
  2.4 @{"Lists"                      link "Lists"} 
  2.5 @{"Primitive Types"            link "Primitives"}
  2.6 @{"Newtypes"                   link "Structures"}
  2.7 @{"Pointers"                   link "Pointers"}
  2.8 @{"Constants"                  link "Constants"}
  2.9 @{"Functions"                  link "Functions"}
  2.10 @{"Macros"                    link "Macros"}
  2.11 @{"Modifiers"                 link "Modifiers"}
  2.12 @{"Compiler Directives"       link "Directives"}
        
  4 @{"AmiBlitz³ Reference"          link "AFunctions"}
  4.1 @{"Build-In Functions"         link "BLR"}      
  4.2 @{"AcidLibs"                   link "AcidLibs"}      
  4.3 @{"DefLibs"                    link "DefLibs"}      
  4.4 @{"AmigaLibs"                  link "AmigaLibs"}      
  4.5 @{"Includes"                   link "Includes"}      
    
  5 @{"68K - Assembler Reference"    link "MC68K"}  

  A @{"Code Examples"                link "Examples"}  
  B @{"Glossary"                     link "Glossary"}
  C @{"License/Disclaimer"           link "License"}
  D @{"Author"                       link "Author"}


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                                            © 2010 Thilo Koehler

@ENDNODE

@NODE Abstract "Introduction"
@{b}1 Introduction@{ub}

@{b}1.1 What is AmiBlitz³?@{ub}
  AmiBlitz³ is a free, open-source programming language for AmigaOS3.x and
  compatible. It comes with its own integrated development environment called
  PED (Program EDitor). PED includes a texteditor, multi-source handling and
  various browsers for functions and documentation. The compiler itself is
  called AmiBlitz³ and generates 68K executables or shared libraries.
  Executables can be debugged using a source code level runtime debugger.
  There are two types of runtime libraries, the so called BlitzLibs
  (68K static libraries) and the Includes (source code libraries).
  
@{b}1.2 Design Issues@{ub}
  AmiBlitz³ is the non-commercial follower of BlitzBasic2 on the Amiga,
  published by AcidSoft. BlitzBasic was designed to develop games for Classic
  Amigas, with direct support for the classic hardware, such as OCS/AGA
  chipset or Paula for audio. Over the years, especially when BlitzBasic became
  Amiblitz, the system conform parts were more and more developed, leading to
  a programming language that can be used for other hardware too, such as x86
  running Amithlon or WinUAE, PPCs running AmigaOS4 or MorphOS, as long as the
  OS API is compatible and the OS is able to execute 68K code.
  The runtime libraries of AmiBlitz³ are splitted up into:

  @{b}AcidLibs@{ub}
    AcidLibs are the original BlitzLibs (something like "linker" libs)
    from AcidSoft. All the basic functionality can be found here, that AcidSoft
    wanted to have in BlitzBasic.
    The AcidLibs (like all other BlitzLibs) come as binary 68K code and are
    automatically loaded during IDE startup. There is no need to link/include
    them manually.

  @{b}DefLibs@{ub}
    DefLibs are BlitzLibs that extent the functionality on certain topics, most
    of them are 3rd party developments and were intended to be configurable
    via the "MakeDefLibs" tool.
    However in reality, and to keep the source code cross-installation
	compatible, they are part of the distribution and should not be changed
	anymore, if there is no vital reason to do so. It is very likely that there
	won't be any new DefLibs in the future.
    
  @{b}AmigaLibs@{ub} (aka FD-Converted Libs)
    AmigaLibs are BlitzLibs too, but they do no contain real code, they are just
    wrappers to integrate an Amiga Shared Library into AmiBlitz³.
    The AmigaOS3.x API plus some other important Shared Libraries are
    integrated that way. All AmigaLibs are part of the Deflibs.

  @{b}Includes@{ub}
    Includes are NOT BlitzLibs. They are AmiBlitz³ source code files that are
    included (usually at the beginning) in the source code of a program.
	Unlike BlitzLibs, they are coded in AmiBlitz³ and not in 68K Assembler.
	This makes them debugable, user-expandable and, in the future, maybe
	CPU-retargetable.
    
  BlitzLibs have the followig shortcommings:
  - maximum 128 tokens (instructions/functions/directives/keywords) per library
  - maximum 256 libraries installed at the same time
  - fix IDs for libraries (most of them are already in use)
  - coded 100% in Assembler, bad maintainability
  - many BlitzLib source codes are not available and are not maintained anymore
    
  This is why future projects should use Includes to expand the runtime of
  AmiBlitz³.
  Includes are always included on source code level and therefore maintainable.
  There is no limit for the amount of includes or their tokens. 
  Amiga Shared Libraries can be made availabe in AmiBlitz³ programs as Includes,
  like the SDL.library, bsdsocket.library or amissl.library.
    
@{b}1.3 Comparism AmiBlitz³, C and BASIC@{ub}

  @{b}How does AmiBlitz³ compare to BASIC?@{ub}
  Pros:
  - AmiBlitz³ compiler is insanely fast, the fastest compiler I have ever seen.
  - AmiBlitz³ generates highly optimized 68K code, probably much faster than
    any BASIC dialect does.
  - AmiBlitz³ allows forced variable declaration.

  Cons:
  - AmiBlitz³ does not conform to BASIC standards.
    (your BASIC specific knowledge is pretty much useless).
  - AmiBlitz³ is only available for AmigaOS3.x and compatible.

  @{b}How does Amblitz3 compare to C/C++?@{ub}
  Pros:
  - AmiBlitz³ compiler is much faster than e.g. GCC.
  - AmiBlitz³ does not use ";" (semicolon) to seperate expressions.
    @{i}Note: Generally, the semicolon as an expression delimiter is a good
          idea in C, but practically it creates unnecessary attention
          the coder has to pay.@{ui}
  - An AmiBlitz³ project is much simplier set up than a C makefile.
    (actually, you just compile the main file)
  - Every source code file can have a build-in demo that is ignored if the
    file is used as an include (#__include compiler constant).
  - Strings are as easy to handle as integers.
  - AmiBlitz³ is less complex and higher leveled.
  - Variables can be declared during usage, in 68K ASM style by using 
    a type extension (a.l = 0), no declaration monsters like
    "unsigned static const char * myVar".
  - Variables are initialized, no random bugs due to uninitialized variables.

  Cons:
  - C is widely spread and much more examples and documentation is out there.
  - C is available for almost every OS/CPU.
  - AmiBlitz³ does not support object oriented programming.
  - AmiBlitz³ is not type safe.
  - AmiBlitz³ does not allow forward declaration.
  
@ENDNODE

@NODE Syntax "Syntax"
@{b}2 Syntax@{ub}

  An @{b}AmiBlitz³@{ub} program is a sequence of expressions (and definitions).
  Two expressions are separated by a new line or by a ":" (colon).

  +-----------------------------------------------------------------------------
  |
  | @{i}expression@{ui}
  | @{i}expression@{ui} : @{i}expression@{ui}
  |
  +-----------------------------------------------------------------------------

  An expression is usually an BlitzLib instruction or function,
  or an Amiblitz function or statement call (function with no return value).
 
  Example:
  +-----------------------------------------------------------------------------
  |
  | Deftype.s myStringVar
  | myStringVar = "Hello World!" : NPrint a.s
  | End
  |
  +-----------------------------------------------------------------------------
  
  An expression can be spanned over multiple lines, if the new line is escaped
  by "@@" (two at-signs):
  +-----------------------------------------------------------------------------
  | 
  | @{i}expression part1@{ui} @@
  | @{i}expression part2@{ui}
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: AmiBlitz³ needs "newsyntax" mode enabled by using @{"optimize 4" link "Directives"}.@{ui}

  A comment is added by using the ";" (semicolon), and always ends at
  the end of line:
  +-----------------------------------------------------------------------------
  | 
  | @{i}expression@{ui} @{i}; this is a comment@{ui}
  | 
  +-----------------------------------------------------------------------------
  
  The "End @{i}somthing@{ui}" instruction is used terminate a block of expressions
  that have been grouped together, e.g. if they make up the body of a loop,
  function, or the conditional block of an "If":
  +-----------------------------------------------------------------------------
  | 
  | If @{i}condition@{ui}
  |   @{i}expression@{ui}
  |   @{i}expression@{ui}
  |   ...
  | End If
  | 
  | Function.t @{i}name@{ui}{...}
  |   @{i}expression@{ui}
  |   @{i}expression@{ui}
  |   ...
  | End Function
  |  
  +-----------------------------------------------------------------------------
  @{i}Note: "@{i}condition@{ui}" is an expression that evaluates to a bool (True/False).@{ui}
  @{i}Note: A single "End" terminates the whole program.@{ui}
  @{i}Note: Many types of blocks have a shortcut, e.g. "End While" can be written as "Wend".@{ui}

@ENDNODE

@NODE Variables "Variables"
@{b}2.2 Variables@{ub}

  @{b}Variables@{ub} are declared and initialized (to zero) by using the
  "DEFTYPE" instruction or by mentioning their type extension on first usage.
  On later usage, the extension is optional.
  Using the same variable name with different type extentions will lead to a
  type-missmatch compiler error.

  +-----------------------------------------------------------------------------
  | 
  | DEFTYPE.t @{i}name@{ui}, ...       ; declare variable @{i}name@{ui} as type .t
  | @{i}name@{ui} = @{i}expression@{ui}      ; assign the result of the expression to @{i}name@{ui}
  |
  | @{i}; or straight away: @{ui}
  | @{i}name@{ui}.t = @{i}expression@{ui}    ; declare and assign at once
  | 
  +-----------------------------------------------------------------------------
  
  Example:
  +-----------------------------------------------------------------------------
  | 
  | DEFTYPE.l a, b, c   @{i}; declare a, b and c as type Long (and set to 0)@{ui}
  | d.l = 1             @{i}; declare d as type Long   and set it to 1@{ui}
  | e.f = 1.0           @{i}; declare e as type Float  and set it to 1@{ui}
  | f.s = "test"        @{i}; declare f as type String and set it to "test"@{ui}
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: See section @{"Primitive Types" link "Primitives"} and @{"Structures" link "Structures"} for more information
        and possible types.@{ui}
  @{i}Note: See section @{"Constants" link "Constants"} how to write constant expressions such as
        numbers or strings.@{ui}

  As a shortcut, the assign operator "=" can be ommited if the first operand is
  also the variable to assign the result to. 

  Example:
  +-----------------------------------------------------------------------------
  |
  | a = a+1   @{i}; normal writing@{ui}
  | a + 1     @{i}; this does the same, it's a short cut@{ui}
  |
  | a = a/2+5 @{i}; normal writing@{ui}
  | a / 2+5   @{i}; short cut@{ui}
  |
  +-----------------------------------------------------------------------------
  @{i}Note: Unlike "a /= 2+5" in C/C++, "a / 2+5" would first devide though 2 and
        then add 5 (respecting common mathematical precedence).@{ui}

  Variables that are declared in the global context (outside of a
  Function/Statement) are global and have a liftime that equals to the runtime
  of the program.
  Variables that are declared in a local context (inside a Function/Statement)
  are local and have a lifetime that starts and ends with the local context.

  By default, global variables are not reachable within local contexts. To
  "import" a global variable into a local context, the "SHARED" directive is
  used. If this is done inside a local context, the import is valid only for
  this specific context. If SHARED is used in global context, the variable is
  imported implicitly to every local context.

  Example:
  +-----------------------------------------------------------------------------
  |
  | DEFTYPE.l a   @{i}; declare a global variable@{ui}
  | SHARED b.l    @{i}; declare a global variable that is reachable in functions@{ui}
  | 
  | Function.l test{}
  | SHARED a      @{i}; a needs to be "SHARED"@{ui}
  | c.l = a + b
  | Function Return c
  | End Function
  |
  +-----------------------------------------------------------------------------
  @{i}Note: "a" and "b" are both global variables. "a" needs to be explicitly
        imported, while "b" is imported by default. "c" is a local variable
        that is not available in global context and its lifetime ends when the
        function exits.
  @{i}Note: The global usage of SHARED needs new syntax mode (optimize 4) to
        be switched on.
	
@ENDNODE

@NODE Arrays "Arrays"
@{b}2.3 Arrays@{ub}

  @{b}Arrays@{ub} of variables are declared by using the "Dim" instruction and
  stating the number of elements in round brackets:
  +-----------------------------------------------------------------------------
  | 
  | Dim [KEEP] @{i}name@{ui}.t(@{i}n@{ui})
  |
  +-----------------------------------------------------------------------------

  @{i}name@{ui} is an array of @{i}n@{ui} elements of type .t,
  starting from index 0 to @{i}#elements@{ui}-1. Same as single variables,
  all array elements are initialized to zero.
  The keyword "KEEP" is optional and used if the array already exists and the
  content should be kept (only new elements are initialized to zero).
  If the array is down-sized however, data might get lost.
  
  An element is indexed by:
  +-----------------------------------------------------------------------------
  | 
  | @{i}name@{ui}.t(@{i}index@{ui})
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: Negative indices are not allowed. The index must be smaller
        than #elements.@{ui}

  Any array can be "re-dimmed" any time by calling "Dim KEEP @{i}name.t@{ui} (@{i}n@{ui})".

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Dim Race.s(5)        @{i}; declare an array of strings called "Race"@{ui}
  |
  | Race(0) = "Human"    @{i}; fill the elements of the array@{ui}
  | Race(1) = "Elve"
  | Race(2) = "Dwarf"
  | Race(3) = "Ork"
  | Race(4) = "Halfling"
  |
  | For (n.l=0, n<5) {
  |   NPrint Race(n)     @{i}; print out all 5 race names@{ui}
  | }
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: The last element is 4, since we have 5 elements, from 0..4.
        Using 5 or higher as index would cause a runtime error!@{ui}

@ENDNODE

@NODE Lists "Lists"
@{b}2.4 Lists@{ub}

  @{b}Lists@{ub} are declared by using "LIST" and the "Dim" instruction:
  +-----------------------------------------------------------------------------
  | 
  | Dim LIST @{i}name@{ui}.t(n)
  | 
  +-----------------------------------------------------------------------------

  @{i}name@{ui} is now an empty list of type .t, with maximum of n elements.
  The list is referred by using the round brackets without index.
  Elements are handled by the following functions:
  +-----------------------------------------------------------------------------
  | 
  | AddItem(name())           @{i}; add a new item at the current position and@{ui}
  |                           @{i}; make it the current item@{ui}
  | KillItem name()           @{i}; remove the current item from the list@{ui}
  | NextItem(name())          @{i}; seek to the next item@{ui}
  | PrevItem(name())          @{i}; seek to the previous item@{ui}
  | ResetList name()          @{i}; seek before the first item@{ui}
  | FirstItem(name())         @{i}; seek to the first item@{ui}
  | LastItem(name())          @{i}; seek to the last item@{ui}
  | ClearList name()          @{i}; remove all items from list@{ui}
  | SortList(name()[,field])  @{i}; sort the list according the field name,@{ui}
  |                           @{i}; if it is a structure@{ui}
  +-----------------------------------------------------------------------------

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Dim LIST Race.s(5)           @{i}; declare a list of strings called Race@{ui}
  | 
  | AddItem(Race()) : Race() = "Human"
  | AddItem(Race()) : Race() = "Elve"
  | AddItem(Race()) : Race() = "Dwarf"
  | 
  | ResetList Race()              @{i}; go before the first item@{ui}
  | While (NextItem(Race())) {     @{i}; print out all items@{ui}
  |   NPrint Race()
  | }
  | 
  | ClearList Race()              @{i}; remove all items@{ui}
  |
  +-----------------------------------------------------------------------------

@ENDNODE

@NODE Constants "Constants"
@{b}2.8 Constants@{ub}

  Depending on the type, constants are written in different ways:

  @{b}Bool@{ub}      
  True
  False
  On
  Off
  -1 or 0

  @{i}Note: AmiBlitz³ does not really know bools, a bool is an integer value of
        either -1 (all bits set) or 0 (all bits cleared).@{ui}
  
  @{b}Integers@{ub} (Byte, Word, Long)
  65      (decimal, = 65)
  $41     (hex,     = 65)
  %10001  (binary,  = 65)
  @"A"    (ASCII,   = 65, newsyntax mode required)

  @{b}Floats@{ub} (Float or Double Float)
  65       (integer number)
  65.0     (fractal number)
  0.1      (fractal number with leading 0)
  .1       (fractal number without leading 0)

  @{b}Strings@{ub} (String, WideString or CString)
  "A", "Hello World"

  If the type is ambiguous, e.g. Word, Long or Float, the type will be
  determined by choosing the best fitting type within the expression. 

  @{b}A@{ub} knows the following pre-defined plain-text-constants:

  Symbol             | Description
  -------------------+----------------------------------------------------------
  True               | logic true,  equals to -1
  False              | logic false, equals to  0
  On                 | logic true,  equals to -1
  Off                | logic false, equals to  0
  Pi                 | 3.1415926535
                     | require optimize 4:
  #__include         | 0 if main source, -1 if included
  #__autoconstantnum | value of the next auto-increment constant (read/write)
  #__debug           | -1 if debugger is on, 0 if debugger is off
  @#constant         | -1 if "constant" was defined earier, 0 if undefined

  
  For use within string constants, the following escape sequences are defined:

  Symbol              | Description    
  --------------------+---------------------------------------------------------
  \\\\n               | new line        (ASCII #10)
  \\\\@{i}<hex>@{ui}           | any character given by 2 digit hex value,
                      | e.g. \\x40 for "@"
  \\\\r<nn><b>        | repeat the byte b for n times, while n is a two digit decimal number
                      |
  \\\\__CODELINE      | number of the current code line in sourc code
  \\\\__DATE__        | compile date in US format (mm/dd/yyyy)
  \\\\__DATE_GER__    | compile date in German format (dd.mm.yyy)
  \\\\__VER_MAJOR     | major verion number (from project settings)
  \\\\__VER_MINOR     | minor verion number (from project settings)
  \\\\__VER_PATCH     | patch number (from project settings)
  \\\\__VER_BUILD     | build bumver (auto-incremental)
  \\\\__THIS_FUNCTION | name of the current function or "GLOBAL"
  \\\\__THIS_INCLUDE  | name of the current include file
  \\\\__THIS_POINTER  | hex pointer of the current function


  Examples:
  +-----------------------------------------------------------------------------
  | 
  | myBool.b    = True
  | myFloat.f   = 2*Pi
  | myString.s  = "Hello World"
  | myInt1.l    = 12345
  | myInt2.l    = $BEEF
  | myInt3.l    = %101110101011
  | myInt4.l    = @"ILBM"
  |
  | version.s   = "$VER: MyProggy V\\\\__VER_MAJOR.\\\\__VER_MINOR (\\\\__DATE__)\\\\n"
  | 
  +-----------------------------------------------------------------------------

  The user can define own constants. They are always of type long and must have
  a leading "#" (hash).

  Example:
  +-----------------------------------------------------------------------------
  | 
  | #MyConstant = 1234
  |
  | Print #MyConstant + 1 ; this outputs 1235
  |
  +-----------------------------------------------------------------------------
  
@ENDNODE

@NODE Functions "Functions"
@{b}2.9 Functions@{ub}

  A function is @{b}defined@{ub} as follows:
  +-----------------------------------------------------------------------------
  | 
  | Function.t [FAST] @{i}name@{ui} {@{i}param@{ui}.t, ...}
  |   Function Return @{i}value@{ui}
  | End Function
  |
  | Statement [FAST] @{i}name@{ui} {@{i}param@{ui}.t, ...} 
  | End Statement
  | 
  +-----------------------------------------------------------------------------
  
  Function/Statement: keyword to indicate we are defining a function
  @{i}FAST@{ui}          : optional modifier
  @{i}name@{ui}          : function's name
  .t                     : type extension
  @{i}value@{ui}         : expression we want to return
  @{i}param@{ui}.t, ...  : list of parameters, can be none up to no limit  

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Function.f AddTwoFloats{a.f, b.f}
  |   result.f = a + b
  |   Function Return result
  | End Function
  | 
  | Statement NPrint{text.s}
  |   Print text.s,"\\\\n"
  | End Statement
  |
  +-----------------------------------------------------------------------------

  If the function has no return value, the keyword "Statement" is used instead
  of "Function". There is no need for a "Return" statement, unless the function
  should be exited earlier than the "End Statement".

  A function can have @{b}optional parameters@{ub}. The optional parameters
  are declared by using the "@" (at sign). Once a parameter is optional,
  all following parameters must be optional too.
  Optional parameters that are omitted will be filled with the default value -1
  if they are numeric (integers and floats), and the empty string if they are
  strings.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Function.l AddLongs{a.l, @b.l, @c.l}
  |   Function Return a+b+c
  | End Function
  |
  | Function.l ConcatStrings{a.s, @b.s, @c.s}
  |   Function Return a+b+c
  | End Function
  |
  | Print AddLongs{3,2}                  @{i}; this would output "4" (yes, "4")@{ui}
  | Print ConcatStrings{"Hello","World"} @{i}; this would output "Hello World"@{ui}  
  |  
  +-----------------------------------------------------------------------------
  
  There is no possibility to overload a function.
  
  FAST
  The FAST modifier removed the init code from the function.
  All local variables must be.

@ENDNODE

@NODE Macros "Macros"
@{b}2.10 Macros@{ub}

  A macro is a definition of text that is inserted during compilation time
  whenever the name of the macro is stated. In AmiBlitz³, they are defined
  by the "MACRO" Compiler diective and and referred by using a
  leading "!" (exclamation mark).
  A macro can have parameters, they are reference by `n (Back Quote + param#)
  within the macro.
 
  +-----------------------------------------------------------------------------
  | 
  | MACRO myIntConst    :             5 : End MACRO
  | MACRO myFloatConst  :           5.4 : End MACRO
  | MACRO myStringConst :        "Test" : End MACRO
  | MACRO myFuncMacro   : ((`1) * (`2)) : End MACRO
  | 
  | Print !myStringConst,!myFuncMacro{2,3}
  |  
  | @{i}; The compiler would see: Print "Test",((2) * (3))@{ui}
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: The Print would output "Test6".@{ui}

  A disadvantage of Macros is, that they are typeless.
  Mismatching types are determined AFTER the macro is applied, which makes
  debugging harder.

  Useful macros found in all.res:
  
  Symbol         | Description
  ---------------+--------------------------------------------------------------
  !version       | version string

  Useful macros found in "useful.include.bb2"

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  !_NULL         | 0, Null pointer to make source more readable  
  
@ENDNODE



@NODE Directives "Compiler Directives"
@{b}2.12 Compiler Directives@{ub}

  A compiler directive is a keyword in the source code that influences the
  compiling process, rather than an expression that generates executable code.
  Compiler directives are all uppercased to identify them easily.

  Keyword          | Description
  -----------------+------------------------------------------------------------
  optimize n       | control the compiler optimizeation/syntaxmode
                   | "Or" the follwing numbers:
                   | 1  : 68020 optimizer
                   | 2  : use FPU
                   | 4  : new syntax mode enabled
                   |
  Syntax n         | set the strictness:
                   | 0 : variables do not have to be declared (like BlitzBasic2)
                   | 1 : variables need to be defined via DEFTYPE
                   | 2 : vatiables need to be defined via DEFTYPE or first usage
                   | 
  CNIF @{i}condition@{ui}   | compile if @{i}condition@{ui} evaluates to True
  CELSE            | alternative block to CNIF
  CEND             | end the conditional block
                   |
  RunErrsOff       | switch runtime debugger off
  RunErrsOn        | switch runtime debugger on
  LastRunErrsMode  | switch runtime debugger to last state
                   |
  INCLUDE          | include a source code file
  XINCLUDE         | include a source code file (only once!)
  IncBin           | include a binary file
  
  The search order (if not an absolute path in "file") is:
  1. the path set in IDE to the includes directory
  2. the path to the executable to create
  
@ENDNODE

@ENDNODE

@NODE Primitives "Primitive Types"
@{b}2.5 Primitive Types@{ub}

  AmiBlitz³ knows the following primitive types:

  Name          | Extension | Size   | Value Range
  --------------+-----------+--------+---------------------------------------
  Byte          |       .b  |  8 bit | -128...+127
  Word          |       .w  | 16 bit | -32768...+32767
  Long          |       .l  | 32 bit | -2^31...+2^31-1
  Float         |       .f  | 32 bit | quite large
  Double Float  |       .d  | 64 bit | even larger
  String        |       .s  | 32 bit | character string from 0-2^31-1 length
                |           | +64+(n+1)*8 bit
  Pointer       | *         | 32 bit | 0...2^31-1

  The AmiBlitz³ compiler will throw an error if the types within an
  expression don't match and can't be casted easily.
  
@ENDNODE

@NODE Structures "NEWTYPEs"
@{b}2.6 NEWTYPEs (Complex Types)@{ub}

  NEWTYPEs are compositions of primitive and/or other NEWTYPEs.
  They are defined using the "NEWTYPE" keyword:
  +-----------------------------------------------------------------------------
  | 
  | NEWTYPE @{i}name@{ui} 
  |   @{i}varname@{ui}.t
  |   ...
  | End NEWTYPE
  | 
  +-----------------------------------------------------------------------------

  A field in the type is addressed by using "\\" (back slash):
  +-----------------------------------------------------------------------------
  | 
  | NEWTYPE myType
  |   x.f
  |   y.f
  | End NEWTYPE
  |
  | DEFTYPE.myType test
  | test\\x = 1,2
  | Print test\\x
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: When assigning values, multiple fields can be filled at once by
        starting with one field and give several values separated by commas.@{ui}

@ENDNODE

@NODE Pointers "Pointers"
@{b}2.7 Pointers@{ub}

  To declare a pointer variable to a certain type instead of the type
  itself, the "*" (asterix) sign will be put in front.
  The * is always in front of the variable name and cannot be left out.
  If the content of the pointer is addressed, it needs to be dereferred by
  accessing the fields in the NEWTYPE the pointer is pointing to.
  Primitive types cannot access their values, only via Peek.t function.  

  Example:
  +-----------------------------------------------------------------------------
  | 
  | *myPointer.l = 0     @{i}; declare myPointer and let it point to address 0@{ui}
  | 
  | *myPointer = 12345   @{i}; this would change the pointer to point to 12345@{ui}
  |                      @{i}; (which is a bad idea, actually)@{ui}
  |  
  +-----------------------------------------------------------------------------
  @{i}Note: The value of the long cannot be reached directly. You need a NEWTYPE
        for dereferencing.@{ui}

  To get a pointer to a variable or label use "&" (ampersand) in front of
  its name.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | NEWTYPE.t
  |   y.l
  | End NEWTYPE
  |
  | *myNEWTYPE.t = &x.l  @{i}; let myPointer point to the content of x@{ui}
  | *myNEWTYPE\y = 12345 @{i}; this will set the content of *myNEWTYPE\y to 12345.@{ui}
  |                      @{i}; Note: because it points to the content of x,@{ui}
  |                      @{i}; x is changed too!@{ui}
  | 
  +-----------------------------------------------------------------------------

@ENDNODE

@NODE ProgramFlow "Program Flow"
@{b}2.1 Program Flow@{ub}

  The program flow is from top down. The program starts with the first
  expression in the source code and keeps on running until it exits with
  "End". It forces an "End" if the execution runs into the void.

@{b}2.1.0 Labels@{ub}

  +-----------------------------------------------------------------------------
  |
  | ['][.]@{i}label@{ui}[:]
  |
  +-----------------------------------------------------------------------------
  
  A label is specified by stating its name with an optional . (full stop) or '
  (apostrophe) in front. It is a good style to use a seperating ":" (colon)
  after the label, however, it is not necessary. 

  To avoid clashes of label names, a label can be made locally unique by using
  the ' (apostrophe) modifier. The label name will be concatenated with the
  previous label, thus being locally unique.
  
  The leading full stop is used to indicate that the label should be visible
  in the source browser for quick access.

  Example:
  +-----------------------------------------------------------------------------
  |
  | John:         @{i}; this is a normal labele@{ui}
  |
  | 'Smith:       @{i}; actual label name becomes "JohnSmith"@{ui}
  |
  | .Jack:        @{i}; this is another label, visible in source browser@{ui}
  |
  | 'Smith:       @{i}; actual label name becomes "JackSmith" and does not clash with@{ui}
  |               @{i}; above 'Smith, thus being locally unique.@{ui}
  |
  +-----------------------------------------------------------------------------

@{b}2.1.1 Goto@{ub}

  +-----------------------------------------------------------------------------
  |
  | Goto @{i}label@{ui}
  |
  +-----------------------------------------------------------------------------
  
  A simple branch is performed. Program execution will continue
  at the position of the label.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | myLabel:
  | 
  | ...
  | 
  | Goto myLabel
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: "Goto" is usually considered as a beginner's programming style and
        theoretically can be always avoided. However, there might be
        situation where a "Goto" is handy and makes life easier.@{ui}

@{b}2.1.1 Gosub/Return@{ub}

  +-----------------------------------------------------------------------------
  |
  | Gosub @{i}label@{ui}
  |
  | Return
  |
  +-----------------------------------------------------------------------------
  
  A branch is performed. Program execution will continue
  at the position of the label, and the address of the calling "Gosub" is
  remembered. When the program execution reaches a "Return", it will jump back
  to the position after the calling Gosub. This is used for subroutines, that
  should be executed in the global context rather than a Function that uses its
  own context.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | ...
  |
  | Gosub mySubRoutine  @{i}; jump to label "mySubRoutine"@{ui}
  |
  | ...
  |
  | End                 @{i}; end of program@{ui}
  |
  |
  | mySubRoutine:
  | 
  | ...                 @{i}; do something ...@{ui}
  | 
  | Return              @{i}; jump back to the calling Gosub@{ui}
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: "Gosub" is usually considered as a beginner's programming style.
        Gosub is sometimes handy but makes your code unmaintainable if the
        project grows. Usage is only recommended in very small, script-like
        applications. Use functions instead.@{ui}
        
@{b}2.1.2 If/Then/Else @{ub}

  To make the execution of a block of statements dependent on a condition
  (expression that evaluates to type bool), use "If":

  +-----------------------------------------------------------------------------
  |
  | If (@{i}condition@{ui}) : ... : End If
  |
  | If (@{i}condition@{ui}) Then ...
  |
  +-----------------------------------------------------------------------------

  The "End If" are only needed, if the block spans over multiple lines.
  Otherwise they can be omitted and a "Then" is used.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | If (a=0) Then a=1 : Print "Hello!"
  |  
  | If (a=0)  
  |   a=1
  |   Print "Hello!"
  | End If
  | 
  +-----------------------------------------------------------------------------

  For every "If", you can define an alternative "Else" block:

  +-----------------------------------------------------------------------------
  |
  | If (@{i}condition@{ui}) : ... : Else : ... : End If
  |
  | If (@{i}condition@{ui}) Then ... : Else ... 
  |
  +-----------------------------------------------------------------------------

  Same rules for multilines apply for the "Else" block.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | If (a=0) Then a=1 : Print "Hello!" : Else a=0 : Print "Blabla."
  |  
  | If (a=0) 
  |   a=1
  |   Print "Hello!"
  | Else
  |   a=0
  |   Print "Blabla."
  | End If
  | 
  +-----------------------------------------------------------------------------

@{b}2.1.3 While/Wend@{ub}

  +-----------------------------------------------------------------------------
  |
  | While (@{i}condition@{ui}) : ... : Wend
  |
  +-----------------------------------------------------------------------------

  This executes a block of expressions, while the @{i}condition@{ui} evaluates
  to True.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | While (a>0)
  |   a=a-1 
  |   Print "Hello!"
  | Wend
  | 
  +-----------------------------------------------------------------------------

@{b}2.1.4 Repeat/Until@{ub}

  +-----------------------------------------------------------------------------
  |
  | Repeat : ... : Until (@{i}condition@{ui})
  |
  +-----------------------------------------------------------------------------

  This is the same like a while loop, only that the @{i}condition@{ui} is tested
  at the end of the block in contrast to the beginning of the block. Thus, the
  block is always executed at least once.

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Repeat 
  |   a=a-1
  |   Print "Hello!"
  | Until (a<=0)
  | 
  +-----------------------------------------------------------------------------

@{b}2.1.5 For/Next@{ub}

  +-----------------------------------------------------------------------------
  |
  | For @{i}var=a@{ui} To @{i}b@{ui} [ Step @{i}increment@{ui}] : ... : Next 
  |
  +-----------------------------------------------------------------------------

  A "For" loop is a loop that sets a counter variable to an initial value @{i}a@{ui},
  executes a block of expressions and then de/increments the counter until it
  reaches the "To" value @{i}b@{ui}.
  The increment is the value added to the counter variable for each step,
  and is 1 if omitted.
  
  Examples:
  +-----------------------------------------------------------------------------
  |
  | For n=a To b : ... : Next        @{i}; n is incremented by 1 for each cycle@{ui}
  | For n=a To b Step c : ... : Next @{i}; n is incremented by c for each cycle@{ui}
  |
  +-----------------------------------------------------------------------------
  
  A real example (output the first 100 integer numbers):
  +-----------------------------------------------------------------------------
  |
  | For n.l=1 To 100 
  |   Print n
  | Next
  |
  +-----------------------------------------------------------------------------

@{b}2.1.6 Select/Case@{ub}

  "Select" is selecting a "Case Block" for execution that matches a previously
  given value.
  +-----------------------------------------------------------------------------
  | 
  | Select (@{i}value@{ui})
  |   Case @{i}alternative1@{ui}
  |     ...
  |   Case @{i}alternative2@{ui}
  |     ...
  |   ...
  |   Default 
  |     ...
  | End Select
  | 
  +-----------------------------------------------------------------------------

  Example:
  +-----------------------------------------------------------------------------
  | 
  | Select (a.l)
  |   Case 1   : Print "Value is 1"
  |   Case 2   : Print "Value is 2"
  |   Default  : Print "Value is something else..."
  | End Select
  | 
  +-----------------------------------------------------------------------------
  @{i}Note: Unlike C "switch", no "break" is needed after each block.@{ui}

@{b}2.1.8 End/initbasic@{ub}

  +-----------------------------------------------------------------------------
  | 
  | End
  | 
  +-----------------------------------------------------------------------------

  "End" frees all resources (that AmiBlitz³ is aware of...) and terminates
  the program. All programs, including libraries, must have this function as the
  last instruction.

  +-----------------------------------------------------------------------------
  | 
  | initbasic
  | 
  +-----------------------------------------------------------------------------

  "initbasic" will move the initialization code of @{b}AmiBlitz³@{ub} to this line.
  It is not allowed to execute any @{b}AmiBlitz³@{ub} code before this function is called!
  If there is no initbasic, this will be done before the first line of source code.
  "initbasic" should be called at maximum once!

@ENDNODE

@NODE AFunctions "AmiBlitz³ - Build-In Function Reference"
@{b}4 Build-In Functions@{ub}

@{b}4.1 Assign Operators@{ub}

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  x = y          | assign y to x (primitive types/pointers only)

@{b}4.2 Comparators@{ub}

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  x = y          | True if x is equal to y, False otherwise
  x >  y         | True if x is greater than y, False otherwise
  x >= y         | True if x is greater than or equal y, False otherwise
  x => y         | True if x is greater than or equal y, False otherwise
  x <  y         | True if x is smaller than y, False otherwise
  x <= y         | True if x is smaller than or equal y, False otherwise
  x =< y         | True if x is smaller than or equal y, False otherwise
  x >< y         | True if x is not equal to y, False otherwise
  x <> y         | True if x is not equal to y, False otherwise

@{b}4.3 Logic Operators@{ub}

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  NOT(x)         | logic NOT
  x AND y        | logic AND
  x OR y         | logic OR
  Xor(x,y)       | logic XOR, equals to (x AND NOT(y)) OR (NOT(x) AND y)

@{b}4.4 Bit Manipulating Operators@{ub}

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  NEG(x)         | bitwise negation of x (= XOR with all bits set)
  x & y          | bitwise AND (integer only)
  x | y          | bitwise OR  (integer only)
  Xor(x,y)       | bitwise XOR (integer only)
  x LSR y        | shift down x about y bits (unsigned)
  x ASR y        | shift down x about y bits (signed)
  x LSL y        | shift up x about y bits

@{b}4.5 Math Operators@{ub}

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  -x             | negation of x
  x + y          | add x and y
  x - y          | subtract y from x
  x * y          | multiply x by y
  x / y          | divide x through y
  x MOD y        | x modulo y 
  x ^ y          | x power y
  Log(x.f,y.f)   | logarithm of x to base y

@{b}4.6 Trigonometric Functions@{ub}

  Symbol         | Description
  ---------------+--------------------------------------------------------------
  Sin(x.f)       | Sinus of x
  Cos(x.f)       | Cosinus of x
  Tan(x.f)       | Tangents of x
  ASin(x.f)      | inverse Sinus of x
  ACos(x.f)      | inverse Cosinus of x
  ATan(x.f)      | inverse Tangents of x 

@{b}4.7 String Functions@{ub}

  Symbol                    | Description
  --------------------------+---------------------------------------------------
  Mid$(str.s,pos.p,n.p)     | crop n characters starting from pos of str 
  Len(str.s)                | string length of str

@{b}4.8 Program Flow Functions@{ub}

  Symbol                    | Description
  --------------------------+---------------------------------------------------
  DEFTYPE.t a               | declare and initialized variable a of type t
  Dim a.t(n)                | dimension an array of type t with n indices
  Dim List a.t(n)           | create a linked list of name a of type t
  NEWTPYE name              | declare a data structure
  ...                       |
  End NEWTYPE               | 
  Function name {...}       | declare a function
  Goto label                | unconditional branch
  Function Return (r)       | return from a function 
  For (i,c,a) {...}         | "For" loop
  While (c) {...}           | "While" loop
  Repeat {...} Until (c)    | "Repeat" loop
  If (c) {...}              | "If" block
  Else {...}                | "Else" block
  Select (x) {...}          | "Select" block
  Case y                    | "Case" block
  End (r)                   | end program
  initbasic                 | init A context

@{b}4.10 Memory Functions@{ub}

  Symbol               | Description
  ---------------------+--------------------------------------------------------
  Dc.t value           | declare a value directly in binary code
  SizeOf.t             | memory size of type t
  Peek.t(mem)          | (flat) copy the data from mem to the structure
  Poke.t(mem)          | (flat) copy the data from the structure to mem

@{b}4.12 Casting Function@{ub}

  Symbol        | Description
  --------------+---------------------------------------------------------------
  Val(x)        | convert string to float
  Vallong(x)    | convert string to integer
  Str(x)        | convert integer/float to string
  Int(x)        | convert float to integer

@ENDNODE


@NODE BRL "5.1 Basic Runtime Library"
@{b}5.1 Basic Runtime@{ub}
 
  The basic runtime Library provides every-day functions for various problems.
  It is per default included when an A program is compiled.

@ENDNODE

@NODE Author "C Author"
@{b}C Author@{ub}

  Name:  Thilo Koehler
  Nick:  Der Wanderer
  Mail:  koehlerthilo(a)gmx de
  Web:   http://www.hd-rec.de
 
@ENDNODE

@NODE License "D License/Disclaimer"
@{b}D License/Disclaimer@{ub}

License:

  AmiBlitz³ programming language is freeware and open source.
  No special license is pending. You can use this product
  in any fashion you like, just some credits to "Der Wanderer" are
  mandatory, and the name of the language must not be changed if used
  elsewhere.
@{i}
DISCLAIMER:

  THE SOFTWARE AND DOCUMENTATION IS PROVIDED "AS IS" WITHOUT WARRANTY
  OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED
  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
  PARTICULAR PURPOSE. YOU ARE ADVISED TO TEST THE SOFTWARE THOROUGHLY BEFORE
  RELYING ON IT. YOU AGREE TO ACCEPT THE ENTIRE RISK AS TO THE QUALITY AND
  PERFORMANCE OF THE SOFTWARE AND DOCUMENTATION.
  IN NO EVENT WILL THILO KOEHLER BE LIABLE FOR DIRECT, INDIRECT, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES RESULTING FROM ANY DEFECT IN THE PROGRAM.
@{ui}
 
@ENDNODE

@NODE Glossary "B Glossary"
@{b}B Glossary@{ub}

Variable      : A memory cell that can store value of the type the variable has.

Constant      : A value of a certain type that does not change over compile
                time. This is usually set by the compiler.

Type          : The kind of data that is in a memory cell, this can be an
                integer, float or string, or user defined "complex type".

Primitive Type: A primitive type is one of the types AmiBlitz³ knows build-in.

Complex Type  : A complex type is a composition of primitive types. They are
                defined by the user.
                
Function      : A block of expressions that has some input parameters and one
                output result.
                AmiBlitz³ has some build in functions, and the user can define own
                functions.

Macro         : Instruction how to replace the macro name in source code with
                its body.
                Note: AmiBlitz³ uses macros in form of constants defined by
                preceding # and "Macro"s, while C uses #define for both.
                AmiBlitz³ uses only the preceding #.

Bool          : a type that can hold only two values: true and false
                This is usually the result type of comparators.

Long/Word/Byte: Those are Integer values, which can contain only numbers
                without fraction.
                Results are rounded downwards, e.g. 5/2 = 2 in integer space

Float/Double  : Float is a numeric value with fractions, Double is the same
                with higher precision

String        : A string in AmiBlitz³ is a sequence of character terminated by a 0.

Array         : An Array is a sequence of variables of a certain type.
                The variables are accessed by their index.
                
List          : A List is a sequence of variables of a certain type.
                The variables are accessed by stepping forward and backwards in
                the list.

AmiBlitz³     : programming language, see http://AmiBlitz³.amiforce.de               

C             : programming language

Expression    : anything that can be evaluated. An expression is composed out
                of terminals and non-terminals.

@ENDNODE


@NODE Examples "AmiBlitz³ Code Examples"
@{b}A Code Examples@{ub}

  Hello World:
  +-----------------------------------------------------------------------------
  | 
  | Print "Hello World!"                    @{i}; console output@{ui}
  | End                                     @{i}; end of program@{ui}
  |
  +-----------------------------------------------------------------------------


  Load, resize and save an image (via Includes):
  +-----------------------------------------------------------------------------
  |
  | XINCLUDE "image.include.bb2"               @{i}; use graphics.include@{ui}
  |
  | image_Load{0,"DH0:Pics/image.png"}         @{i}; load from disk@{ui}
  | image_Resize{1,0,800,600}                  @{i}; resize to 800x600 pixels@{ui}
  | image_Save{1,"DH0:Pics/image.jpg",@"JPEG"} @{i}; save as JPEG@{ui}
  |
  | End                                        @{i}; end of program@{ui}
  |
  +-----------------------------------------------------------------------------
  @{i}Note: Because the images are AmiBlitz³ maintained object, we don't have to free them.
        AmiBlitz³ is freeing it on "End".@{ui}

@ENDNODE
